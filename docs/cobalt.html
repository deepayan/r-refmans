<!DOCTYPE html><html lang="en"><head><title>Help for package cobalt</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {cobalt}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cobalt-package'><p>cobalt: Covariate Balance Tables and Plots</p></a></li>
<li><a href='#bal.compute'><p>Efficiently compute scalar balance statistics</p></a></li>
<li><a href='#bal.plot'><p>Visualize Distributional Balance</p></a></li>
<li><a href='#bal.tab'><p>Display Balance Statistics in a Table</p></a></li>
<li><a href='#bal.tab.CBPS'><p>Balance Statistics for <code>CBPS</code> Objects</p></a></li>
<li><a href='#bal.tab.cem.match'><p>Balance Statistics for <code>cem</code> Objects</p></a></li>
<li><a href='#bal.tab.default'><p>Balance Statistics for Other Objects</p></a></li>
<li><a href='#bal.tab.designmatch'><p>Balance Statistics for <code>designmatch</code> Objects</p></a></li>
<li><a href='#bal.tab.ebalance'><p>Balance Statistics for <code>ebalance</code> Objects</p></a></li>
<li><a href='#bal.tab.formula'><p>Balance Statistics for Data Sets</p></a></li>
<li><a href='#bal.tab.Match'><p>Balance Statistics for <code>Matching</code> Objects</p></a></li>
<li><a href='#bal.tab.matchit'><p>Balance Statistics for <code>MatchIt</code> Objects</p></a></li>
<li><a href='#bal.tab.mimids'><p>Balance Statistics for <code>MatchThem</code> Objects</p></a></li>
<li><a href='#bal.tab.optmatch'><p>Balance Statistics for <code>optmatch</code> Objects</p></a></li>
<li><a href='#bal.tab.ps'><p>Balance Statistics for <code>twang</code> Objects</p></a></li>
<li><a href='#bal.tab.sbwcau'><p>Balance Statistics for <code>sbw</code> Objects</p></a></li>
<li><a href='#bal.tab.time.list'><p>Balance Statistics for Longitudinal Datasets</p></a></li>
<li><a href='#bal.tab.weightit'><p>Balance Statistics for <code>WeightIt</code> Objects</p></a></li>
<li><a href='#balance-statistics'><p>Balance Statistics in <code>bal.tab</code> and <code>love.plot</code></p></a></li>
<li><a href='#balance-summary'><p>Compute Balance and Summary Statistics for Covariates</p></a></li>
<li><a href='#class-bal.tab.cluster'><p>Using <code>bal.tab()</code> with Clustered Data</p></a></li>
<li><a href='#class-bal.tab.imp'><p>Using <code>bal.tab()</code> with Multiply Imputed Data</p></a></li>
<li><a href='#class-bal.tab.msm'><p>Using <code>bal.tab()</code> with Longitudinal Treatments</p></a></li>
<li><a href='#class-bal.tab.multi'><p>Using <code>bal.tab()</code> with Multi-Category Treatments</p></a></li>
<li><a href='#class-bal.tab.subclass'><p>Using <code>bal.tab()</code> with Subclassified Data</p></a></li>
<li><a href='#display-options'><p>Options for Displaying <code>bal.tab()</code> Output</p></a></li>
<li><a href='#f.build'><p>Convenient Formula Generation</p></a></li>
<li><a href='#get.w'><p>Extract Weights from Preprocessing Objects</p></a></li>
<li><a href='#lalonde'><p>Data from National Supported Work Demonstration and PSID, as analyzed by</p>
Dehejia and Wahba (1999).</a></li>
<li><a href='#love.plot'><p>Display Balance Statistics in a Love Plot</p></a></li>
<li><a href='#print.bal.tab'><p>Print Results of a Call to <code>bal.tab()</code></p></a></li>
<li><a href='#set.cobalt.options'><p>Set and Get Options in <code>cobalt</code></p></a></li>
<li><a href='#splitfactor'><p>Split and Unsplit Factors into Dummy Variables</p></a></li>
<li><a href='#var.names'><p>Extract Variable Names from <code>bal.tab</code> Objects</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Covariate Balance Tables and Plots</td>
</tr>
<tr>
<td>Version:</td>
<td>4.5.5</td>
</tr>
<tr>
<td>Description:</td>
<td>Generate balance tables and plots for covariates of groups preprocessed through 
             matching, weighting or subclassification, for example, using propensity scores. Includes 
             integration with 'MatchIt', 'WeightIt', 'MatchThem', 'twang', 'Matching', 'optmatch', 'CBPS', 'ebal', 
             'cem', 'sbw', and 'designmatch' for assessing balance on the output of their preprocessing 
             functions. Users can also specify data for balance assessment not generated through 
             the above packages. Also included are methods for assessing balance in clustered or 
             multiply imputed data sets or data sets with multi-category, continuous, or longitudinal treatments.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, grid, grDevices, ggplot2 (&ge; 3.4.1), gtable (&ge;
0.3.0), gridExtra (&ge; 2.3), chk (&ge; 0.8.1), rlang (&ge; 0.4.0),
crayon, backports (&ge; 1.1.9)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>MatchIt (&ge; 4.0.0), WeightIt (&ge; 1.0.0), twang (&ge; 1.6),
twangContinuous, Matching, optmatch, ebal, CBPS (&ge; 0.17),
designmatch, optweight, mice (&ge; 3.8.0), MatchThem (&ge; 0.9.3),
cem (&ge; 1.1.30), sbw (&ge; 1.1.5), gbm (&ge; 2.1.7), brglm2 (&ge;
0.9), caret, knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://ngreifer.github.io/cobalt/">https://ngreifer.github.io/cobalt/</a>,
<a href="https://github.com/ngreifer/cobalt">https://github.com/ngreifer/cobalt</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ngreifer/cobalt/issues">https://github.com/ngreifer/cobalt/issues</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-02 20:39:58 UTC; NoahGreifer</td>
</tr>
<tr>
<td>Author:</td>
<td>Noah Greifer <a href="https://orcid.org/0000-0003-3067-7154"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Noah Greifer &lt;noah.greifer@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-02 21:25:01 UTC</td>
</tr>
</table>
<hr>
<h2 id='cobalt-package'>cobalt: Covariate Balance Tables and Plots</h2><span id='topic+cobalt'></span><span id='topic+cobalt-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>A set of tools for assessing covariate balance in observational studies numerically and graphically. The functions provide integration with the major R packages used for balancing covariates, including <span class="pkg">MatchIt</span>, <span class="pkg">WeightIt</span>, <span class="pkg">twang</span>, <span class="pkg">CBPS</span>, and many others, and support objects not made using these packages. They support binary, multi-category and continuous treatments, point and longitudinal treatments, and clustered and multiply imputed data.
</p>
<p>The main functions of <span class="pkg">cobalt</span> are the following:
</p>

<ul>
<li> <p><code><a href="#topic+bal.tab">bal.tab()</a></code> - generate tables of balance statistics before and after matching, weighting, or subclassification
</p>
</li>
<li> <p><code><a href="#topic+bal.plot">bal.plot()</a></code> - generate plots to assess balance visually on one covariate at a time
</p>
</li>
<li> <p><code><a href="#topic+love.plot">love.plot()</a></code> - generate plots to summarize and report balance statistics
</p>
</li></ul>

<p>Other functions include <code><a href="#topic+get.w">get.w()</a></code> for extracting weights from objects produced by other packages, <code><a href="#topic+col_w_smd">col_w_smd()</a></code> (and friends documented on the same page) for computing (weighted) balance statistics outside of <code>bal.tab()</code>, <code><a href="#topic+bal.compute">bal.compute()</a></code> for computing scalar balance statistics efficiently, and <code><a href="#topic+splitfactor">splitfactor()</a></code> for splitting factor variables in a dataset into dummy variables.
</p>
<p><span class="pkg">cobalt</span> has several vignettes, which can be accessed using <code>vignette(package = "cobalt")</code> or visiting the website at <a href="https://ngreifer.github.io/cobalt/">https://ngreifer.github.io/cobalt/</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Noah Greifer <a href="mailto:noah.greifer@gmail.com">noah.greifer@gmail.com</a> (<a href="https://orcid.org/0000-0003-3067-7154">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://ngreifer.github.io/cobalt/">https://ngreifer.github.io/cobalt/</a>
</p>
</li>
<li> <p><a href="https://github.com/ngreifer/cobalt">https://github.com/ngreifer/cobalt</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ngreifer/cobalt/issues">https://github.com/ngreifer/cobalt/issues</a>
</p>
</li></ul>


<hr>
<h2 id='bal.compute'>Efficiently compute scalar balance statistics</h2><span id='topic+bal.compute'></span><span id='topic+bal.compute.bal.init'></span><span id='topic+bal.compute.default'></span><span id='topic+bal.init'></span><span id='topic+available.stats'></span>

<h3>Description</h3>

<p>These are functions primarily designed for programmers who want to be able to quickly compute one of several scalar (single number) sample balance statistics, e.g., for use in selecting a tuning parameter when estimating balancing weights. <code>bal.compute()</code> computes a scalar balance statistics from the supplied inputs. <code>bal.init()</code> initializes the input so that when <code>bal.compute()</code> is used on the output along with a set of weights, the computation of the balance statistic is fast. <code>vignette("optimizing-balance")</code> provides an overview and more examples of how to use these functions. <code>available.stats()</code> returns the balance statistics available for the given treatment type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bal.compute(x, ...)

## S3 method for class 'bal.init'
bal.compute(x, weights = NULL, ...)

## Default S3 method:
bal.compute(x, treat, stat, s.weights = NULL, weights = NULL, ...)

bal.init(x, treat, stat, s.weights = NULL, ...)

available.stats(treat.type = "binary")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bal.compute_+3A_x">x</code></td>
<td>
<p>for <code>bal.compute()</code>, a <code>bal.init</code> object created by <code>bal.init()</code> or a matrix or data frame containing the covariates. For <code>bal.init()</code>, a matrix or data frame containing the covariates.</p>
</td></tr>
<tr><td><code id="bal.compute_+3A_...">...</code></td>
<td>
<p>other arguments used to specify options for the balance statistic. See Details for which arguments are allowed with each balance statistic. Ignored for the <code>bal.init</code> method of <code>bal.compute()</code>.</p>
</td></tr>
<tr><td><code id="bal.compute_+3A_weights">weights</code></td>
<td>
<p>a vector of balancing weights to compute the weighted statistics.</p>
</td></tr>
<tr><td><code id="bal.compute_+3A_treat">treat</code></td>
<td>
<p>a vector containing the treatment variable.</p>
</td></tr>
<tr><td><code id="bal.compute_+3A_stat">stat</code></td>
<td>
<p>string; the name of the statistic to compute. See Details.</p>
</td></tr>
<tr><td><code id="bal.compute_+3A_s.weights">s.weights</code></td>
<td>
<p>optional; a vector of sampling weights.</p>
</td></tr>
<tr><td><code id="bal.compute_+3A_treat.type">treat.type</code></td>
<td>
<p>string; the treatment type, either <code>"binary"</code>, <code>"multinomial"</code>, or <code>"continuous"</code>. Abbreviations allowed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following list contains the allowable balance statistics that can be supplied to <code>bal.init()</code> or the default method of <code>bal.compute()</code>, the additional arguments that can be used with each one, and the treatment types allowed with each one. For all balance statistics, lower values indicate better balance.
</p>

<dl>
<dt><code>smd.mean</code>, <code>smd.max</code>, <code>smd.rms</code></dt><dd>
<p>The mean, maximum, or root-mean-squared absolute standardized mean difference, computed using <code><a href="#topic+col_w_smd">col_w_smd()</a></code>. The other allowable arguments include <code>estimand</code> (<code>"ATE"</code>, <code>"ATT"</code>, or <code>"ATC"</code>) to select the estimand (default is <code>"ATE"</code>), <code>focal</code> to identify the focal treatment group when the ATT is the estimand and the treatment has more than two categories, and <code>pairwise</code> to select whether mean differences should be computed between each pair of treatment groups or between each treatment group and the target group identified by <code>estimand</code> (default <code>TRUE</code>). Can be used with binary and multi-category treatments.
</p>
</dd>
<dt><code>ks.mean</code>, <code>ks.max</code>, <code>ks.rms</code></dt><dd>
<p>The mean, maximum, or root-mean-squared Kolmogorov-Smirnov statistic, computed using <code><a href="#topic+col_w_ks">col_w_ks()</a></code>. The other allowable arguments include <code>estimand</code> (<code>"ATE"</code>, <code>"ATT"</code>, or <code>"ATC"</code>) to select the estimand (default is <code>"ATE"</code>), <code>focal</code> to identify the focal treatment group when the ATT is the estimand and the treatment has more than two categories, and <code>pairwise</code> to select whether statistics should be computed between each pair of treatment groups or between each treatment group and the target group identified by <code>estimand</code> (default <code>TRUE</code>). Can be used with binary and multi-category treatments.
</p>
</dd>
<dt><code>ovl.mean</code>, <code>ovl.max</code>, <code>ovl.rms</code></dt><dd>
<p>The mean, maximum, or root-mean-squared overlapping coefficient complement, computed using <code><a href="#topic+col_w_ovl">col_w_ovl()</a></code>. The other allowable arguments include <code>estimand</code> (<code>"ATE"</code>, <code>"ATT"</code>, or <code>"ATC"</code>) to select the estimand (default is <code>"ATE"</code>), <code>integrate</code> to select whether integration is done using using <code><a href="stats.html#topic+integrate">integrate()</a></code> (<code>TRUE</code>) or a Riemann sum (<code>FALSE</code>, the default), <code>focal</code> to identify the focal treatment group when the ATT is the estimand and the treatment has more than two categories, <code>pairwise</code> to select whether statistics should be computed between each pair of treatment groups or between each treatment group and the target group identified by <code>estimand</code> (default <code>TRUE</code>). Can be used with binary and multi-category treatments.
</p>
</dd>
<dt><code>mahalanobis</code></dt><dd>
<p>The Mahalanobis distance between the treatment group means. This is similar to <code>smd.rms</code> but the covariates are standardized to remove correlations between them and de-emphasize redundant covariates. The other allowable arguments include <code>estimand</code> (<code>"ATE"</code>, <code>"ATT"</code>, or <code>"ATC"</code>) to select the estimand (default is <code>"ATE"</code>) and <code>focal</code> to identify the focal treatment group when the ATT is the estimand. Can only be used with binary treatments.
</p>
</dd>
<dt><code>energy.dist</code></dt><dd>
<p>The total energy distance between each treatment group and the target sample, which is a scalar measure of the similarity between two multivariate distributions. The other allowable arguments include <code>estimand</code> (<code>"ATE"</code>, <code>"ATT"</code>, <code>"ATC"</code>, or <code>NULL</code>) to select the estimand (default is <code>NULL</code>), <code>focal</code> to identify the focal treatment group when the ATT is the estimand and the treatment has more than two categories, and <code>improved</code> to select whether the &quot;improved&quot; energy distance should be used when <code>estimand = "ATE"</code>, which emphasizes difference between treatment groups in addition to difference between each treatment group and the target sample (default <code>TRUE</code>). When <code>estimand = NULL</code>, only the energy distance between the treatment groups will be computed (i.e., as opposed to the energy distance between each treatment groups and the target sample). Can be used with binary and multi-category treatments.
</p>
</dd>
<dt><code>kernel.dist</code></dt><dd>
<p>The kernel distance between the treatment groups, which is a scalar measure of the similarity between two multivariate distributions. Can only be used with binary treatments.
</p>
</dd>
<dt><code>l1.med</code></dt><dd>
<p>The median L1 statistic computed across a random selection of possible coarsening of the data. The other allowable arguments include <code>estimand</code> (<code>"ATE"</code>, <code>"ATT"</code>, or <code>"ATC"</code>) to select the estimand (default is <code>"ATE"</code>), <code>focal</code> to identify the focal treatment group when the ATT is the estimand and the treatment has more than two categories, <code>l1.min.bin</code> (default 2) and <code>l1.max.bin</code> default (12) to select the minimum and maximum number of bins with which to bin continuous variables and <code>l1.n</code> (default 101) to select the number of binnings used to select the binning at the median. <code>covs</code> should be supplied without splitting factors into dummies to ensure the binning works correctly; for simplicity, the <code>.covs</code> argument can be supplied, which will override <code>covs</code> but isn't used by other statistics. Can be used with binary and multi-category treatments.
</p>
</dd>
<dt><code>r2</code>, <code>r2.2</code>, <code>r2.3</code></dt><dd>
<p>The post-weighting <code class="reqn">R^2</code> of a model for the treatment. The other allowable arguments include <code>poly</code> to add polynomial terms of the supplied order to the model and <code>int</code> (default <code>FALSE</code>) to add two-way interaction between covariates into the model. Using <code>r2.2</code> is a shortcut to requesting squares, and using <code>r2.3</code> is a shortcut to requesting cubes. Can be used with binary and continuous treatments. For binary treatments, the McKelvey and Zavoina <code class="reqn">R^2</code> from a logistic regression is used; for continuous treatments, the <code class="reqn">R^2</code> from a linear regression is used.
</p>
</dd>
<dt><code>p.mean</code>, <code>p.max</code>, <code>p.rms</code></dt><dd>
<p>The mean, maximum, or root-mean-squared absolute Pearson correlation between the treatment and covariates, computed using <code><a href="#topic+col_w_corr">col_w_corr()</a></code>. Can only be used with continuous treatments.
</p>
</dd>
<dt><code>s.mean</code>, <code>s.max</code>, <code>s.rms</code></dt><dd>
<p>The mean, maximum, or root-mean-squared absolute Spearman correlation between the treatment and covariates, computed using <code><a href="#topic+col_w_corr">col_w_corr()</a></code>. Can only be used with continuous treatments.
</p>
</dd>
<dt><code>distance.cov</code></dt><dd>
<p>The distance covariance between the scaled covariates and treatment, which is a scalar measure of the independence of two possibly multivariate distributions. Can only be used with continuous treatments.
</p>
</dd>
</dl>

<p>Although statistics can be computed directly using <code>bal.compute()</code> alone, the intended workflow is to use <code>bal.init()</code> to initialize a <code>bal.init</code> object, which can then be passed to <code>bal.compute()</code> many times with different sets of weights, thereby minimizing the processing that <code>bal.init()</code> does because it is only done once. In contrast, using <code>bal.compute()</code> on covariates directly (i.e., using the default method) calls <code>bal.init()</code> internally each time, which can slow down evaluation. When speed isn't of interest or to calculate a balance statistic outside the context of balance optimization, the default method of <code>bal.compute()</code> can be a quick shortcut to avoid having to create a <code>bal.init</code> object first.
</p>


<h3>Value</h3>

<p>For <code>bal.compute()</code>, a single numeric value. For <code>bal.init()</code>, a <code>bal.init</code> object containing the components created in the initialization and the function used to compute the balance statistic. For <code>available.stats()</code>, a character vector of available statistics.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+balance-summary">balance-summary</a></code>, <code><a href="#topic+bal.tab">bal.tab()</a></code>
</p>
<p>See <code>vignette("optimizing-balance")</code> for references and definitions of some of the above quantities.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Select the optimal number of subclasses for
# subclassification:
data("lalonde")
covs &lt;- c("age", "educ", "race", "married",
          "nodegree", "re74", "re75")

# Estimate propensity score
p &lt;- glm(reformulate(covs, "treat"),
         data = lalonde, 
         family = "binomial")$fitted.values

# Function to compute subclassification weights
subclass_ATE &lt;- function(treat, p, nsub) {
    m &lt;- MatchIt::matchit(treat ~ 1,
                          data = lalonde,
                          distance = p,
                          method = "subclass",
                          estimand = "ATE",
                          subclass = nsub)
    return(m$weights)
}

# Initialize balance statistic; largest KS statistic
init &lt;- bal.init(lalonde[covs], treat = lalonde$treat, 
                 stat = "ks.max",
                 estimand = "ATE")

# Statistic prior to subclassification:
bal.compute(init)

# Testing 4 to 50 subclasses
nsubs &lt;- 4:50
stats &lt;- vapply(nsubs, function(n) {
    w &lt;- subclass_ATE(lalonde$treat, p, n)
    bal.compute(init, w)
}, numeric(1L))

plot(stats ~ nsubs)

# 6 subclass gives lowest ks.max value (.238)
nsubs[which.min(stats)]
stats[which.min(stats)]

# See which statistics are available
available.stats("binary")
available.stats("multinomial")

</code></pre>

<hr>
<h2 id='bal.plot'>Visualize Distributional Balance</h2><span id='topic+bal.plot'></span>

<h3>Description</h3>

<p>Generates density plots, bar graphs, or scatterplots displaying distributional balance between treatment and covariates using <span class="pkg">ggplot2</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bal.plot(
  x,
  var.name,
  ...,
  which,
  which.sub = NULL,
  cluster = NULL,
  which.cluster = NULL,
  imp = NULL,
  which.imp = NULL,
  which.treat = NULL,
  which.time = NULL,
  mirror = FALSE,
  type = "density",
  colors = NULL,
  grid = FALSE,
  sample.names,
  position = "right",
  facet.formula = NULL,
  disp.means = getOption("cobalt_disp.means", FALSE),
  alpha.weight = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bal.plot_+3A_x">x</code></td>
<td>
<p>the object for which balance is to be assessed; can be any object for which there is support in <code><a href="#topic+bal.tab">bal.tab()</a></code>.</p>
</td></tr>
<tr><td><code id="bal.plot_+3A_var.name">var.name</code></td>
<td>
<p><code>character</code>; the name of the variable whose values are to be plotted. To view distributions of the distance measure (e.g., propensity score), if any, use <code>"distance"</code> as the argument unless the distance variable has been named. If there are duplicate variable names across inputs, <code>bal.plot()</code> will first look in the covariate <code>data.frame</code> from <code>x</code>, followed by <code>addl</code>, and then <code>distance</code>, if any. If not specified, will use the first covariate available with a warning.</p>
</td></tr>
<tr><td><code id="bal.plot_+3A_...">...</code></td>
<td>
<p>other arguments to define the variable, treatment, and weights. Some inputs are required depending on the method. See Additional Arguments. Can also be used to supply the <code>bw</code>, <code>adjust</code>, <code>kernel</code>, and <code>n</code> arguments for <code><a href="ggplot2.html#topic+geom_density">ggplot2::geom_density()</a></code> and the <code>bins</code> argument for <code><a href="ggplot2.html#topic+geom_histogram">ggplot2::geom_histogram()</a></code>.</p>
</td></tr>
<tr><td><code id="bal.plot_+3A_which">which</code></td>
<td>
<p>whether to display distributional balance for the adjusted (<code>"adjusted"</code>) or unadjusted sample (<code>"unadjusted"</code>) or both at the same time (<code>"both"</code>). When multiple weights are present, the names of the weights can be supplied, too. The default is to display balance for the adjusted sample only unless no weights, subclasses, or matching strata are specified. Multiple values and abbreviations allowed.</p>
</td></tr>
<tr><td><code id="bal.plot_+3A_which.sub">which.sub</code></td>
<td>
<p><code>numeric</code>; if subclassification is used, a vector corresponding to the subclass(es) for which the distributions are to be displayed. If <code>.all</code> (the default), distributions from all subclasses are displayed in a grid.</p>
</td></tr>
<tr><td><code id="bal.plot_+3A_cluster">cluster</code></td>
<td>
<p>optional; a vector of cluster membership, or the name of a variable in an available data set passed to <code>bal.plot()</code> that contains cluster membership.</p>
</td></tr>
<tr><td><code id="bal.plot_+3A_which.cluster">which.cluster</code></td>
<td>
<p>if clusters are used, which cluster(s) to display. Can be cluster names or numerical indices for which to display balance. Indices correspond to the alphabetical order of cluster names. If <code>.all</code> (the default), all clusters are displayed. If <code>.none</code>, cluster information is ignored and the marginal distribution of the covariates is displayed.</p>
</td></tr>
<tr><td><code id="bal.plot_+3A_imp">imp</code></td>
<td>
<p>optional; a vector of imputation indices, or the name of a variable in an available data set passed to <code>bal.plot()</code> that contains imputation indices.</p>
</td></tr>
<tr><td><code id="bal.plot_+3A_which.imp">which.imp</code></td>
<td>
<p>if imputations are used, which imputations(s) to display. Must be numerical indices for which to display balance. If <code>.all</code> (the default), all imputations are displayed. If <code>.none</code>, data from all imputations are combined into one distribution.</p>
</td></tr>
<tr><td><code id="bal.plot_+3A_which.treat">which.treat</code></td>
<td>
<p>which treatment groups to display. If <code>NULL</code> (the default) or <code>NA</code>, all treatment groups are displayed.</p>
</td></tr>
<tr><td><code id="bal.plot_+3A_which.time">which.time</code></td>
<td>
<p>for longitudinal treatments, which time points to display. Can be treatment names or time period indices. If <code>NULL</code> (the default) or <code>NA</code>, all time points are displayed.</p>
</td></tr>
<tr><td><code id="bal.plot_+3A_mirror">mirror</code></td>
<td>
<p><code>logical</code>; if the treatment is binary, the covariate is continuous, and densities or histograms are requested, whether to display mirrored densities/histograms or overlapping densities/histograms. Ignored otherwise.</p>
</td></tr>
<tr><td><code id="bal.plot_+3A_type">type</code></td>
<td>
<p><code>character</code>; for binary and multi-category treatments with a continuous covariate, whether to display densities (<code>"density"</code>), histograms  (<code>"histogram"</code>), or empirical cumulative density function plots (<code>"ecdf"</code>). The default is to display densities. Abbreviations are allowed.</p>
</td></tr>
<tr><td><code id="bal.plot_+3A_colors">colors</code></td>
<td>
<p>a vector of colors for the plotted densities/histograms. See 'Color Specification' at <code><a href="graphics.html#topic+par">graphics::par()</a></code>. Defaults to the default <span class="pkg">ggplot2</span> colors.</p>
</td></tr>
<tr><td><code id="bal.plot_+3A_grid">grid</code></td>
<td>
<p><code>logical</code>; whether gridlines should be shown on the plot. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="bal.plot_+3A_sample.names">sample.names</code></td>
<td>
<p><code>character</code>; new names to be given to the samples (i.e., in place of &quot;Unadjusted Sample&quot; and &quot;Adjusted Sample&quot;). For example, when matching it used, it may be useful to enter <code>c("Unmatched", "Matched")</code>.</p>
</td></tr>
<tr><td><code id="bal.plot_+3A_position">position</code></td>
<td>
<p>the position of the legend. This can be any value that would be appropriate as an argument to <code>legend.position</code> in <code><a href="ggplot2.html#topic+theme">ggplot2::theme()</a></code>.</p>
</td></tr>
<tr><td><code id="bal.plot_+3A_facet.formula">facet.formula</code></td>
<td>
<p>a <code>formula</code> designating which facets should be on the rows and columns. This should be of the &quot;historical&quot; formula interface to <code><a href="ggplot2.html#topic+facet_grid">ggplot2::facet_grid()</a></code>. If of the form <code>a ~ b</code>, <code>a</code> will be faceted on the rows and <code>b</code> on the columns. To only facet on the rows, provide a one-sided formula with an empty left-hand side. To only facet on the columns, the formula should be of the form <code>a ~ .</code> (i.e., with only <code>.</code> on the right-hand side). The allowable facets depend on which arguments have been supplied to <code>bal.plot()</code>; possible values include <code>which</code>, <code>cluster</code>, <code>imp</code>, and (for longitudinal treatments) <code>time</code>. If <code>NULL</code>, <code>bal.plot()</code> will decide what looks best; this argument exists in case you disagree with its choice.</p>
</td></tr>
<tr><td><code id="bal.plot_+3A_disp.means">disp.means</code></td>
<td>
<p><code>logical</code>; for a categorical treatment with a continuous covariate, whether a line should be drawn for each treatment level denoting the (weighted) mean of the covariate. Ignored if <code>type</code> is not &quot;density&quot; or &quot;histogram&quot;. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="bal.plot_+3A_alpha.weight">alpha.weight</code></td>
<td>
<p><code>logical</code>; if both the treatment and the covariate are continuous, whether points should be shaded according to their weight. Fainter points are those that have smaller weights. Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bal.plot()</code> uses <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code> from the <span class="pkg">ggplot2</span> package, and (invisibly) returns a <code>"ggplot"</code> object. For categorical treatments with continuous covariates or continuous treatments with categorical covariates, density plots are created using <code><a href="ggplot2.html#topic+geom_density">ggplot2::geom_density()</a></code>, histograms are created using <code><a href="ggplot2.html#topic+geom_histogram">ggplot2::geom_histogram()</a></code>, and empirical CDF plots are created using <code><a href="ggplot2.html#topic+geom_path">ggplot2::geom_step()</a></code>; for categorical treatments with categorical covariates, bar graphs are created using <code><a href="ggplot2.html#topic+geom_bar">ggplot2::geom_bar()</a></code>; for continuous treatments with continuous covariates, scatterplots are created using <code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point()</a></code>.
</p>
<p>For continuous treatments with continuous covariates, four additional lines are presented for aid in balance assessment. The red line is the linear fit line. The blue line is a smoothing curve generated with <span class="pkg">ggplot2</span>'s <code><a href="ggplot2.html#topic+geom_smooth">ggplot2::geom_smooth()</a></code> with <code>method = "auto"</code>. The horizontal black line is a horizontal reference line intercepting the (unweighted) treatment mean. The vertical black line is a reference line intercepting the (unweighted) treatment mean. Balance is indicated by the flatness of both fit lines and whether they pass through the intersection of the two black reference lines.
</p>
<p>When multiple plots are to be displayed (i.e., when requesting subclass balance, cluster balance, or imputation balance, or when multiple sets of weights are provided or <code>which = "both"</code>, or when treatment is longitudinal), the plots will be displayed in a grid using <span class="pkg">ggplot2</span>'s <code><a href="ggplot2.html#topic+facet_grid">ggplot2::facet_grid()</a></code>. Subclassification cannot be used with clusters or multiply imputed data.
</p>
<p>To change the plot and axis titles, use <code><a href="ggplot2.html#topic+labs">ggplot2::labs()</a></code>. Because the output is a <code>ggplot</code> object, other elements can be changed using <span class="pkg">ggplot2</span> functions; see <a href="https://stackoverflow.com/questions/61255335/change-legend-generated-by-bal-plot">here</a> for an example.
</p>


<h3>Value</h3>

<p>A <code>"ggplot"</code> object, returned invisibly.
</p>


<h3>Additional Arguments</h3>

<p><code>bal.plot()</code> works like <code><a href="#topic+bal.tab">bal.tab()</a></code> in that it can take a variety of types of inputs and yield the same output for each. Depending on what kind of input is given, different additional parameters are required in <code>...</code>. For details on what is required and allowed for each additional input and their defaults, see the help file for the <code><a href="#topic+bal.tab">bal.tab()</a></code> method associated with the input. The following are the required additional arguments based on each input type:
</p>

<ul>
<li><p> For <code>matchit</code> objects: None
</p>
</li>
<li><p> For <code>weightit</code> objects: None
</p>
</li>
<li><p> For <code>ps</code>, <code>ps.cont</code>, <code>mnps</code>, and <code>iptw</code> objects: (<code>stop.method</code>; see <a href="#topic+bal.tab.ps">defaults</a>).
</p>
</li>
<li><p> For <code>Match</code> objects: <code>formula</code> and <code>data</code> or <code>covs</code> and <code>treat</code>.
</p>
</li>
<li><p> For <code>optmatch</code> objects: <code>formula</code> and <code>data</code> or <code>covs</code> (<code>treat</code> is not required).
</p>
</li>
<li><p> For <code>CBPS</code> objects: None
</p>
</li>
<li><p> For <code>ebalance</code> objects: <code>formula</code> and <code>data</code> or <code>covs</code> and <code>treat</code>.
</p>
</li>
<li><p> For <code>formula</code>s: <code>data</code>
</p>
</li>
<li><p> For <code>data.frame</code>s: <code>treat</code>
</p>
</li>
<li><p> For <code>designmatch</code> objects: <code>formula</code> and <code>data</code> or <code>covs</code> and <code>treat</code>.
</p>
</li>
<li><p> For <code>sbw</code> objects: None
</p>
</li>
<li><p> For <code>mimids</code> and <code>wimids</code> objects: None, but an argument to <code>which.imp</code> should be specified.
</p>
</li>
<li><p> For other objects processed through <code>bal.tab()</code>'s default method, whichever arguments are required to identify treatment, variables, and a conditioning method (if any).
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+bal.tab">bal.tab()</a></code>, <code><a href="#topic+love.plot">love.plot()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("lalonde", package = "cobalt")

#Nearest Neighbor Matching
m.out &lt;- MatchIt::matchit(treat ~ age + educ + race +  married +
                              nodegree + re74 + re75, 
                          data = lalonde)

bal.plot(m.out, "age", which = "both")
bal.plot(m.out, "re74", which = "both", type = "ecdf")
bal.plot(m.out, "race", which = "both")
bal.plot(m.out, "distance", which = "both", mirror = TRUE,
         type = "histogram", colors = c("white", "black"))


#Entropy balancing with a continuous treatment
w.out &lt;- WeightIt::weightit(re75 ~ age + I(age^2) + educ + 
                                race + married + nodegree,
                            data = lalonde, method = "ebal")

bal.plot(w.out, "age", which = "both")
bal.plot(w.out, "married", which = "both")

</code></pre>

<hr>
<h2 id='bal.tab'>Display Balance Statistics in a Table</h2><span id='topic+bal.tab'></span>

<h3>Description</h3>

<p>Generates balance statistics on covariates in relation to an observed treatment variable. It is a generic function that dispatches to the method corresponding to the class of the first argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bal.tab(x, ...)

## # Arguments common across all input types:
## bal.tab(x,
##         stats,
##         int = FALSE,
##         poly = 1,
##         distance = NULL,
##         addl = NULL,
##         data = NULL,
##         continuous,
##         binary,
##         s.d.denom,
##         thresholds = NULL,
##         weights = NULL,
##         cluster = NULL,
##         imp = NULL,
##         pairwise = TRUE,
##         s.weights = NULL,
##         abs = FALSE,
##         subset = NULL,
##         quick = TRUE,
##         ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bal.tab_+3A_x">x</code></td>
<td>
<p>an input object on which to assess balance. Can be the output of a call to a balancing function in another package or a formula or data frame. Input to this argument will determine which <code>bal.tab()</code> method is used. Each input type has its own documentation page, which is linked in the See Also section below. Some input types require or allow additional arguments to be specified. For inputs with no dedicated method, the <a href="#topic+bal.tab.default">default method</a> will be dispatched. See Details below.</p>
</td></tr>
<tr><td><code id="bal.tab_+3A_...">...</code></td>
<td>
<p>for some input types, other arguments that are required or allowed. Otherwise, further arguments to control display of output. See <a href="#topic+display-options">display options</a> for details.</p>
</td></tr>
<tr><td><code id="bal.tab_+3A_stats">stats</code></td>
<td>
<p><code>character</code>; which statistic(s) should be reported. See <code><a href="#topic+balance-statistics">stats</a></code> for allowable options. For binary and multi-category treatments, <code>"mean.diffs"</code> (i.e., mean differences) is the default. For continuous treatments, <code>"correlations"</code> (i.e., treatment-covariate Pearson correlations) is the default. Multiple options are allowed.</p>
</td></tr>
<tr><td><code id="bal.tab_+3A_int">int</code></td>
<td>
<p><code>logical</code> or <code>numeric</code>; whether or not to include 2-way interactions of covariates included in <code>covs</code> and in <code>addl</code>. If <code>numeric</code>, will be passed to <code>poly</code> as well.</p>
</td></tr>
<tr><td><code id="bal.tab_+3A_poly">poly</code></td>
<td>
<p><code>numeric</code>; the highest polynomial of each continuous covariate to display. For example, if 2, squares of each continuous covariate will be displayed (in addition to the covariate itself); if 3, squares and cubes of each continuous covariate will be displayed, etc. If 1, the default, only the base covariate will be displayed. If <code>int</code> is numeric, <code>poly</code> will take on the value of <code>int</code>.</p>
</td></tr>
<tr><td><code id="bal.tab_+3A_distance">distance</code></td>
<td>
<p>an optional formula or data frame containing distance values (e.g., propensity scores) or a character vector containing their names. If a formula or variable names are specified, <code>bal.tab()</code> will look in the argument to <code>data</code>, if specified. For longitudinal treatments, can be a list of allowable arguments, one for each time point.</p>
</td></tr>
<tr><td><code id="bal.tab_+3A_addl">addl</code></td>
<td>
<p>an optional formula or data frame containing additional covariates for which to present balance or a character vector containing their names. If a formula or variable names are specified, <code>bal.tab()</code> will look in the arguments to the input object, <code>covs</code>, and <code>data</code>, if specified. For longitudinal treatments, can be a list of allowable arguments, one for each time point.</p>
</td></tr>
<tr><td><code id="bal.tab_+3A_data">data</code></td>
<td>
<p>an optional data frame containing variables named in other arguments. For some input object types, this is required.</p>
</td></tr>
<tr><td><code id="bal.tab_+3A_continuous">continuous</code></td>
<td>
<p>whether mean differences for continuous variables should be standardized (<code>"std"</code>) or raw (<code>"raw"</code>). Default <code>"std"</code>. Abbreviations allowed. This option can be set globally using <code><a href="#topic+set.cobalt.options">set.cobalt.options()</a></code>.</p>
</td></tr>
<tr><td><code id="bal.tab_+3A_binary">binary</code></td>
<td>
<p>whether mean differences for binary variables (i.e., difference in proportion) should be standardized (<code>"std"</code>) or raw (<code>"raw"</code>). Default <code>"raw"</code>. Abbreviations allowed. This option can be set globally using <code><a href="#topic+set.cobalt.options">set.cobalt.options()</a></code>.</p>
</td></tr>
<tr><td><code id="bal.tab_+3A_s.d.denom">s.d.denom</code></td>
<td>
<p><code>character</code>; how the denominator for standardized mean differences should be calculated, if requested. See <code><a href="#topic+col_w_smd">col_w_smd()</a></code> for allowable options. If weights are supplied, each set of weights should have a corresponding entry to <code>s.d.denom</code>. Abbreviations allowed. If left blank and weights, subclasses, or matching strata are supplied, <code>bal.tab()</code> will figure out which one is best based on the <code>estimand</code>, if given (for ATT, <code>"treated"</code>; for ATC, <code>"control"</code>; otherwise <code>"pooled"</code>) and other clues if not.</p>
</td></tr>
<tr><td><code id="bal.tab_+3A_thresholds">thresholds</code></td>
<td>
<p>a named vector of balance thresholds, where the name corresponds to the statistic (i.e., in <code>stats</code>) that the threshold applies to. For example, to request thresholds on mean differences and variance ratios, one can set <code>thresholds = c(m = .05, v = 2)</code>. Requesting a threshold automatically requests the display of that statistic. When specified, extra columns are inserted into the Balance table describing whether the requested balance statistics exceeded the threshold or not. Summary tables tallying the number of variables that exceeded and were within the threshold and displaying the variables with the greatest imbalance on that balance measure are added to the output.</p>
</td></tr>
<tr><td><code id="bal.tab_+3A_weights">weights</code></td>
<td>
<p>a vector, list, or <code>data.frame</code> containing weights for each unit, or a string containing the names of the weights variables in <code>data</code>, or an object with a <code><a href="#topic+get.w">get.w()</a></code> method or a list thereof. The weights can be, e.g., inverse probability weights or matching weights resulting from a matching algorithm.</p>
</td></tr>
<tr><td><code id="bal.tab_+3A_cluster">cluster</code></td>
<td>
<p>either a vector containing cluster membership for each unit or a string containing the name of the cluster membership variable in <code>data</code> or the input object. See <code><a href="#topic+class-bal.tab.cluster">class-bal.tab.cluster</a></code> for details.</p>
</td></tr>
<tr><td><code id="bal.tab_+3A_imp">imp</code></td>
<td>
<p>either a vector containing imputation indices for each unit or a string containing the name of the imputation index variable in <code>data</code> or the input object. See <code><a href="#topic+class-bal.tab.imp">class-bal.tab.imp</a></code> for details. Not necessary if <code>data</code> is a <code>mids</code> object.</p>
</td></tr>
<tr><td><code id="bal.tab_+3A_pairwise">pairwise</code></td>
<td>
<p>whether balance should be computed for pairs of treatments or for each treatment against all groups combined. See <code><a href="#topic+class-bal.tab.multi">bal.tab.multi()</a></code> for details. This can also be used with a binary treatment to assess balance with respect to the full sample.</p>
</td></tr>
<tr><td><code id="bal.tab_+3A_s.weights">s.weights</code></td>
<td>
<p>Optional; either a vector containing sampling weights for each unit or a string containing the name of the sampling weight variable in <code>data</code>. These function like regular weights except that both the adjusted and unadjusted samples will be weighted according to these weights if weights are used.</p>
</td></tr>
<tr><td><code id="bal.tab_+3A_abs">abs</code></td>
<td>
<p><code>logical</code>; whether displayed balance statistics should be in absolute value or not.</p>
</td></tr>
<tr><td><code id="bal.tab_+3A_subset">subset</code></td>
<td>
<p>a <code>logical</code> or <code>numeric</code> vector denoting whether each observation should be included or which observations should be included. If <code>logical</code>, it should have length equal to the number of units. <code>NA</code>s will be treated as <code>FALSE</code>. This can be used as an alternative to <code>cluster</code> to examine balance on subsets of the data.</p>
</td></tr>
<tr><td><code id="bal.tab_+3A_quick">quick</code></td>
<td>
<p><code>logical</code>; if <code>TRUE</code>, will not compute any values that will not be displayed. Set to <code>FALSE</code> if computed values not displayed will be used later.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bal.tab()</code> performs various calculations on the the data objects given. This page details the arguments and calculations that are used across <code>bal.tab()</code> methods.
</p>


<h4>With Binary Point Treatments</h4>

<p>Balance statistics can be requested with the <code><a href="#topic+balance-statistics">stats</a></code> argument. The default balance statistic for mean differences for continuous variables is the standardized mean difference, which is the difference in the means divided by a measure of spread (i.e., a d-type effect size measure). This is the default because it puts the mean differences on the same scale for comparison with each other and with a given threshold. For binary variables, the default balance statistic is the raw difference in proportion. Although standardized differences in proportion can be computed, raw differences in proportion for binary variables are already on the same scale, and computing the standardized difference in proportion can obscure the true difference in proportion by dividing the difference in proportion by a number that is itself a function of the observed proportions.
</p>
<p>Standardized mean differences are calculated using <code><a href="#topic+col_w_smd">col_w_smd()</a></code> as follows: the numerator is the mean of the treated group minus the mean of the control group, and the denominator is a measure of spread calculated in accordance with the argument to <code>s.d.denom</code> or the default of the specific method used. Common approaches in the literature include using the standard deviation of the treated group or using the &quot;pooled&quot; standard deviation (i.e., the square root of the mean of the group variances) in calculating standardized mean differences. The computed spread <code>bal.tab()</code> uses is always that of the full, unadjusted sample (i.e., before matching, weighting, or subclassification), as recommended by Stuart (2010).
</p>
<p>Prior to computation, all variables are checked for variable type, which allows users to differentiate balance statistic calculations based on type using the arguments to <code>continuous</code> and <code>binary</code>. First, if a given covariate is numeric and has only 2 levels, it is converted into a binary (0,1) variable. If 0 is a value in the original variable, it retains its value and the other value is converted to 1; otherwise, the lower value is converted to 0 and the other to 1. Next, if the covariate is not numeric or logical (i.e., is a character or factor variable), it will be split into new binary variables, named with the original variable and the value, separated by an underscore. Otherwise, the covariate will be used as is and treated as a continuous variable.
</p>
<p>When weighting or matching are used, an &quot;effective sample size&quot; is calculated for each group using the following formula: <code class="reqn">(\sum w)^2 / \sum w^2</code>. The effective sample size is &quot;approximately the number of observations from a simple random sample that yields an estimate with sampling variation equal to the sampling variation obtained with the weighted comparison observations&quot; (Ridgeway et al., 2016). The calculated number tends to underestimate the true effective sample size of the weighted samples. The number depends on the variability of the weights, so sometimes trimming units with large weights can actually increase the effective sample size, even though units are being down-weighted. When matching is used, an additional &quot;unweighted&quot; sample size will be displayed indicating the total number of units contributing to the weighted sample.
</p>
<p>When subclassification is used, the balance tables for each subclass stored in <code style="white-space: pre;">&#8288;$Subclass.Balance&#8288;</code> use values calculated as described above. For the aggregate balance table stored in <code style="white-space: pre;">&#8288;$Balance.Across.Subclass&#8288;</code>, the values of each statistic are computed as a weighted average of the statistic across subclasses, weighted by the proportion of units in each subclass. See <code><a href="#topic+class-bal.tab.subclass">class-bal.tab.subclass</a></code> for more details.
</p>



<h4>With Continuous Point Treatments</h4>

<p>When continuous treatment variables are considered, the balance statistic calculated is the Pearson correlation between the covariate and treatment. The correlation after adjustment is computed using <code><a href="#topic+col_w_cov">col_w_cov()</a></code> as the weighted covariance between the covariate and treatment divided by the product of the standard deviations of the unweighted covariate and treatment, in an analogous way to how how the weighted standardized mean difference uses an unweighted measure of spread in its denominator, with the purpose of avoiding the analogous paradox (i.e., where the covariance decreases but is accompanied by a change in the standard deviations, thereby distorting the actual resulting balance computed using the weighted standard deviations). This can sometimes yield correlations greater than 1 in absolute value; these usually indicate degenerate cases anyway.
</p>



<h4>With Multi-Category Point Treatments</h4>

<p>For information on using <code>bal.tab()</code> with multi-category treatments, see <code><a href="#topic+class-bal.tab.multi">class-bal.tab.multi</a></code>. Essentially, <code>bal.tab()</code> compares pairs of treatment groups in a standard way.
</p>



<h4>With Longitudinal Treatments</h4>

<p>For information on using <code>bal.tab()</code> with longitudinal treatments, see <code><a href="#topic+class-bal.tab.msm">class-bal.tab.msm</a></code> and <code>vignette("longitudinal-treat")</code>. Essentially, <code>bal.tab()</code> summarizes balance at each time point and summarizes across time points.
</p>



<h4>With Clustered or Multiply Imputed Data</h4>

<p>For information on using <code>bal.tab()</code> with clustered data, see <code><a href="#topic+class-bal.tab.cluster">class-bal.tab.cluster</a></code>. For information on using <code>bal.tab()</code> with multiply imputed data, see <code><a href="#topic+class-bal.tab.imp">class-bal.tab.imp</a></code>.
</p>



<h4><code>quick</code></h4>

<p>Calculations can take some time, especially when there are many variables, interactions, or clusters. When certain values are not printed, by default they are not computed. In particular, summary tables are not computed when their display has not been requested. This can speed up the overall production of the output when these values are not to be used later. However, when they are to be used later, such as when output is to be further examined with <code>print()</code> or is to be used in some other way after the original call to <code>bal.tab()</code>, it may be useful to compute them even if they are not to be printed initially. To do so, users can set <code>quick = FALSE</code>, which will cause <code>bal.tab()</code> to calculate all values and components it can. Note that <code>love.plot()</code> is fully functional even when <code>quick = TRUE</code> and values are requested that are otherwise not computed in <code>bal.tab()</code> with <code>quick = TRUE</code>.
</p>



<h4>Missing Data</h4>

<p>If there is missing data in the covariates (i.e., <code>NA</code>s in the covariates provided to <code>bal.tab()</code>), a few additional things happen. A warning will appear mentioning that missing values were present in the data set. The computed balance summaries will be for the variables ignoring the missing values. New variables will be created representing missingness indicators for each variable, named <code style="white-space: pre;">&#8288;var: &lt;NA&gt;&#8288;</code> (with <code>var</code> replaced by the actual name of the variable). If <code>int = TRUE</code>, balance for the pairwise interactions between the missingness indicators will also be computed. These variables are treated like regular variables once created.
</p>



<h3>Value</h3>

<p>An object of class <code>"bal.tab"</code>. The use of continuous treatments, subclasses, clusters, and/or imputations will also cause the object to inherit other classes. The class <code>"bal.tab"</code> has its own <code>print()</code> method (<code><a href="#topic+print.bal.tab">print.bal.tab()</a></code>), which formats the output nicely and in accordance with print-related options given in the call to <code>bal.tab()</code>, and which can be called with its own options.
</p>
<p>For scenarios with binary point treatments and no subclasses, imputations, or clusters, the following are the elements of the <code>bal.tab</code> object:
</p>
<table role = "presentation">
<tr><td><code>Balance</code></td>
<td>
<p>A data frame containing balance information for each covariate. Balance contains the following columns, with additional columns present when other balance statistics are requested, and some columns omitted when not requested:
</p>

<ul>
<li><p><code>Type</code>: Whether the covariate is binary, continuous, or a measure of distance (e.g., the propensity score).
</p>
</li>
<li><p><code>M.0.Un</code>: The mean of the control group prior to adjusting.
</p>
</li>
<li><p><code>SD.0.Un</code>: The standard deviation of the control group prior to adjusting.
</p>
</li>
<li><p><code>M.1.Un</code>: The mean of the treated group prior to adjusting.
</p>
</li>
<li><p><code>SD.1.Un</code>: The standard deviation of the treated group prior to adjusting.
</p>
</li>
<li><p><code>Diff.Un</code>: The (standardized) difference in means between the two groups prior to adjusting. See the <code>binary</code> and <code>continuous</code> arguments on the <code>bal.tab</code> method pages to determine whether standardized or raw mean differences are being reported. By default, the standardized mean difference is displayed for continuous variables and the raw mean difference (difference in proportion) is displayed for binary variables.
</p>
</li>
<li><p><code>M.0.Adj</code>: The mean of the control group after adjusting.
</p>
</li>
<li><p><code>SD.0.Adj</code>: The standard deviation of the control group after adjusting.
</p>
</li>
<li><p><code>M.1.Adj</code>: The mean of the treated group after adjusting.
</p>
</li>
<li><p><code>SD.1.Adj</code>: The standard deviation of the treated group after adjusting.
</p>
</li>
<li><p><code>Diff.Adj</code>: The (standardized) difference in means between the two groups after adjusting. See the <code>binary</code> and <code>continuous</code> arguments on the <code>bal.tab</code> method pages to determine whether standardized or raw mean differences are being reported. By default, the standardized mean difference is displayed for continuous variables and the raw mean difference (difference in proportion) is displayed for binary variables.
</p>
</li>
<li><p><code>M.Threshold</code>: Whether or not the calculated mean difference after adjusting exceeds or is within the threshold given by <code>thresholds</code>.  If a threshold for mean differences is not specified, this column will be <code>NA</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code>Balanced.Means</code></td>
<td>
<p>If a threshold on mean differences is specified, a table tallying the number of variables that exceed or are within the threshold.</p>
</td></tr>
<tr><td><code>Max.Imbalance.Means</code></td>
<td>
<p>If a threshold on mean differences is specified, a table displaying the variable with the greatest absolute mean difference.</p>
</td></tr>
<tr><td><code>Observations</code></td>
<td>
<p>A table displaying the sample sizes before and after adjusting. Often the effective sample size (ESS) will be displayed. See Details.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>The original function call, if adjustment was performed by a function in another package.</p>
</td></tr>
</table>
<p>If the treatment is continuous, instead of producing mean differences, <code>bal.tab()</code> will produce correlations between the covariates and the treatment. The default corresponding entries in the output will be <code>"Corr.Un"</code>, &quot;<code style="white-space: pre;">&#8288;Corr.Adj"&#8288;</code>, and <code>"R.Threshold"</code> (and accordingly for the balance tally and maximum imbalance tables).
</p>
<p>If multiple weights are supplied, <code>"Adj"</code> in <code>Balance</code> will be replaced by the provided names of the sets of weights, and extra columns will be added for each set of weights. Additional columns and rows for other items in the output will be created as well.
</p>
<p>For <code>bal.tab</code> output with subclassification, see <code><a href="#topic+class-bal.tab.subclass">class-bal.tab.subclass</a></code>.
</p>


<h3>References</h3>

<p>Ridgeway, G., McCaffrey, D., Morral, A., Burgette, L., &amp; Griffin, B. A. (2016). Toolkit for Weighting and Analysis of Nonequivalent Groups: A tutorial for the twang package. R vignette. RAND.
</p>
<p>Stuart, E. A. (2010). Matching Methods for Causal Inference: A Review and a Look Forward. Statistical Science, 25(1), 1-21. <a href="https://doi.org/10.1214/09-STS313">doi:10.1214/09-STS313</a>
</p>


<h3>See Also</h3>

<p>For information on the use of <code>bal.tab()</code> with specific types of objects, use the following links:
</p>

<ul>
<li> <p><code><a href="#topic+bal.tab.matchit">bal.tab.matchit()</a></code> for the method for objects returned by <span class="pkg">MatchIt</span>.
</p>
</li>
<li> <p><code><a href="#topic+bal.tab.weightit">bal.tab.weightit()</a></code> for the method for <code>weightit</code> and <code>weightitMSM</code> objects returned by <span class="pkg">WeightIt</span>.
</p>
</li>
<li> <p><code><a href="#topic+bal.tab.ps">bal.tab.ps()</a></code> for the method for <code>ps</code>, <code>mnps</code>, and <code>iptw</code> objects returned by <span class="pkg">twang</span> and for <code>ps.cont</code> objects returned by <span class="pkg">twangContinuous</span>.
</p>
</li>
<li> <p><code><a href="#topic+bal.tab.Match">bal.tab.Match()</a></code> for the method for objects returned by <span class="pkg">Matching</span>.
</p>
</li>
<li> <p><code><a href="#topic+bal.tab.optmatch">bal.tab.optmatch()</a></code> for the method for objects returned by <span class="pkg">optmatch</span>.
</p>
</li>
<li> <p><code><a href="#topic+bal.tab.cem.match">bal.tab.cem.match()</a></code> for the method for objects returned by <span class="pkg">cem</span>.
</p>
</li>
<li> <p><code><a href="#topic+bal.tab.CBPS">bal.tab.CBPS()</a></code> for the method for objects returned by <span class="pkg">CBPS</span>.
</p>
</li>
<li> <p><code><a href="#topic+bal.tab.ebalance">bal.tab.ebalance()</a></code> for the method for objects returned by <span class="pkg">ebal</span>.
</p>
</li>
<li> <p><code><a href="#topic+bal.tab.designmatch">bal.tab.designmatch()</a></code> for the method for objects returned by <span class="pkg">designmatch</span>.
</p>
</li>
<li> <p><code><a href="#topic+bal.tab.mimids">bal.tab.mimids()</a></code> for the method for objects returned by <span class="pkg">MatchThem</span>.
</p>
</li>
<li> <p><code><a href="#topic+bal.tab.sbwcau">bal.tab.sbwcau()</a></code> for the method for objects returned by <span class="pkg">sbw</span>.
</p>
</li>
<li> <p><code><a href="#topic+bal.tab.formula">bal.tab.formula()</a></code> and <code><a href="#topic+bal.tab.data.frame">bal.tab.data.frame()</a></code> for the methods for <code>formula</code> and data frame interfaces when the user has covariate values and weights (including matching weights) or subclasses or wants to evaluate balance on an unconditioned data set. For data that corresponds to a longitudinal treatment (i.e., to be analyzed with a marginal structural model), see <code><a href="#topic+bal.tab.time.list">bal.tab.time.list()</a></code>.
</p>
</li></ul>

<p>See <code>vignette("faq")</code> for answers to frequently asked questions about <code>bal.tab()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## See individual pages above for examples with
## different inputs, or see `vignette("cobalt")`
</code></pre>

<hr>
<h2 id='bal.tab.CBPS'>Balance Statistics for <code>CBPS</code> Objects</h2><span id='topic+bal.tab.CBPS'></span>

<h3>Description</h3>

<p>Generates balance statistics for <code>CBPS</code> and <code>CBMSM</code> objects from the <span class="pkg">CBPS</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'CBPS'
bal.tab(
  x,
  stats,
  int = FALSE,
  poly = 1,
  distance = NULL,
  addl = NULL,
  data = NULL,
  continuous,
  binary,
  s.d.denom,
  thresholds = NULL,
  weights = NULL,
  cluster = NULL,
  imp = NULL,
  pairwise = TRUE,
  s.weights = NULL,
  abs = FALSE,
  subset = NULL,
  quick = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bal.tab.CBPS_+3A_x">x</code></td>
<td>
<p>a <code>CBPS</code> or <code>CBMSM</code> object; the output of a call to <code><a href="CBPS.html#topic+CBPS">CBPS::CBPS()</a></code> or <code><a href="CBPS.html#topic+CBMSM">CBPS::CBMSM()</a></code>.</p>
</td></tr>
<tr><td><code id="bal.tab.CBPS_+3A_stats">stats</code></td>
<td>
<p><code>character</code>; which statistic(s) should be reported. See <code><a href="#topic+balance-statistics">stats</a></code> for allowable options. For binary and multi-category treatments, <code>"mean.diffs"</code> (i.e., mean differences) is the default. For continuous treatments, <code>"correlations"</code> (i.e., treatment-covariate Pearson correlations) is the default. Multiple options are allowed.</p>
</td></tr>
<tr><td><code id="bal.tab.CBPS_+3A_int">int</code></td>
<td>
<p><code>logical</code> or <code>numeric</code>; whether or not to include 2-way interactions of covariates included in <code>covs</code> and in <code>addl</code>. If <code>numeric</code>, will be passed to <code>poly</code> as well.</p>
</td></tr>
<tr><td><code id="bal.tab.CBPS_+3A_poly">poly</code></td>
<td>
<p><code>numeric</code>; the highest polynomial of each continuous covariate to display. For example, if 2, squares of each continuous covariate will be displayed (in addition to the covariate itself); if 3, squares and cubes of each continuous covariate will be displayed, etc. If 1, the default, only the base covariate will be displayed. If <code>int</code> is numeric, <code>poly</code> will take on the value of <code>int</code>.</p>
</td></tr>
<tr><td><code id="bal.tab.CBPS_+3A_distance">distance</code></td>
<td>
<p>an optional formula or data frame containing distance values (e.g., propensity scores) or a character vector containing their names. If a formula or variable names are specified, <code>bal.tab()</code> will look in the argument to <code>data</code>, if specified. Propensity scores generated by <code>CBPS()</code> and <code>CBMSM()</code> are automatically included and named <code>"prop.score"</code>. For <code>CBMSM</code> objects, can be a list of allowable arguments, one for each time point, but each dataset in the list supplied to <code>distance</code> must have one row per individual, unlike the data frame in the original call to <code>CBMSM()</code>.</p>
</td></tr>
<tr><td><code id="bal.tab.CBPS_+3A_addl">addl</code></td>
<td>
<p>an optional formula or data frame containing additional covariates for which to present balance or a character vector containing their names. If a formula or variable names are specified, <code>bal.tab()</code> will look in the arguments to the input object, <code>covs</code>, and <code>data</code>, if specified. For <code>CBMSM</code> objects, can be a list of allowable arguments, one for each time point, but each dataset in the list supplied to <code>addl</code> must have one row per individual, unlike the data frame in the original call to <code>CBMSM()</code>.</p>
</td></tr>
<tr><td><code id="bal.tab.CBPS_+3A_data">data</code></td>
<td>
<p>an optional data frame containing variables named in other arguments. For some input object types, this is required.</p>
</td></tr>
<tr><td><code id="bal.tab.CBPS_+3A_continuous">continuous</code></td>
<td>
<p>whether mean differences for continuous variables should be standardized (<code>"std"</code>) or raw (<code>"raw"</code>). Default <code>"std"</code>. Abbreviations allowed. This option can be set globally using <code><a href="#topic+set.cobalt.options">set.cobalt.options()</a></code>.</p>
</td></tr>
<tr><td><code id="bal.tab.CBPS_+3A_binary">binary</code></td>
<td>
<p>whether mean differences for binary variables (i.e., difference in proportion) should be standardized (<code>"std"</code>) or raw (<code>"raw"</code>). Default <code>"raw"</code>. Abbreviations allowed. This option can be set globally using <code><a href="#topic+set.cobalt.options">set.cobalt.options()</a></code>.</p>
</td></tr>
<tr><td><code id="bal.tab.CBPS_+3A_s.d.denom">s.d.denom</code></td>
<td>
<p><code>character</code>; how the denominator for standardized mean differences should be calculated, if requested. See <code><a href="#topic+col_w_smd">col_w_smd()</a></code> for allowable options. Abbreviations allowed. If not specified, will be set to <code>"treated"</code> if the estimand of the call to <code>CBPS()</code> is the ATT and &quot;pooled&quot; if the estimand is the ATE.</p>
</td></tr>
<tr><td><code id="bal.tab.CBPS_+3A_thresholds">thresholds</code></td>
<td>
<p>a named vector of balance thresholds, where the name corresponds to the statistic (i.e., in <code>stats</code>) that the threshold applies to. For example, to request thresholds on mean differences and variance ratios, one can set <code>thresholds = c(m = .05, v = 2)</code>. Requesting a threshold automatically requests the display of that statistic. When specified, extra columns are inserted into the Balance table describing whether the requested balance statistics exceeded the threshold or not. Summary tables tallying the number of variables that exceeded and were within the threshold and displaying the variables with the greatest imbalance on that balance measure are added to the output.</p>
</td></tr>
<tr><td><code id="bal.tab.CBPS_+3A_weights">weights</code></td>
<td>
<p>a vector, list, or <code>data.frame</code> containing weights for each unit, or a string containing the names of the weights variables in <code>data</code>, or an object with a <code><a href="#topic+get.w">get.w()</a></code> method or a list thereof. The weights can be, e.g., inverse probability weights or matching weights resulting from a matching algorithm.</p>
</td></tr>
<tr><td><code id="bal.tab.CBPS_+3A_cluster">cluster</code></td>
<td>
<p>either a vector containing cluster membership for each unit or a string containing the name of the cluster membership variable in <code>data</code> or the input object. See <code><a href="#topic+class-bal.tab.cluster">class-bal.tab.cluster</a></code> for details.</p>
</td></tr>
<tr><td><code id="bal.tab.CBPS_+3A_imp">imp</code></td>
<td>
<p>either a vector containing imputation indices for each unit or a string containing the name of the imputation index variable in <code>data</code> or the input object. See <code><a href="#topic+class-bal.tab.imp">class-bal.tab.imp</a></code> for details. Not necessary if <code>data</code> is a <code>mids</code> object.</p>
</td></tr>
<tr><td><code id="bal.tab.CBPS_+3A_pairwise">pairwise</code></td>
<td>
<p>whether balance should be computed for pairs of treatments or for each treatment against all groups combined. See <code><a href="#topic+class-bal.tab.multi">bal.tab.multi()</a></code> for details. This can also be used with a binary treatment to assess balance with respect to the full sample.</p>
</td></tr>
<tr><td><code id="bal.tab.CBPS_+3A_s.weights">s.weights</code></td>
<td>
<p>Optional; either a vector containing sampling weights for each unit or a string containing the name of the sampling weight variable in <code>data</code>. These function like regular weights except that both the adjusted and unadjusted samples will be weighted according to these weights if weights are used. If sampling weights are used in <code>CBPS()</code>, it is critical that they are specified in <code>bal.tab()</code> as well using the <code>s.weights</code> argument.</p>
</td></tr>
<tr><td><code id="bal.tab.CBPS_+3A_abs">abs</code></td>
<td>
<p><code>logical</code>; whether displayed balance statistics should be in absolute value or not.</p>
</td></tr>
<tr><td><code id="bal.tab.CBPS_+3A_subset">subset</code></td>
<td>
<p>a <code>logical</code> or <code>numeric</code> vector denoting whether each observation should be included or which observations should be included. If <code>logical</code>, it should have length equal to the number of units. <code>NA</code>s will be treated as <code>FALSE</code>. This can be used as an alternative to <code>cluster</code> to examine balance on subsets of the data.</p>
</td></tr>
<tr><td><code id="bal.tab.CBPS_+3A_quick">quick</code></td>
<td>
<p><code>logical</code>; if <code>TRUE</code>, will not compute any values that will not be displayed. Set to <code>FALSE</code> if computed values not displayed will be used later.</p>
</td></tr>
<tr><td><code id="bal.tab.CBPS_+3A_...">...</code></td>
<td>
<p>for some input types, other arguments that are required or allowed. Otherwise, further arguments to control display of output. See <a href="#topic+display-options">display options</a> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bal.tab.CBPS()</code> and <code>bal.tab.CBMSM()</code> generate a list of balance summaries for the <code>CBPS</code> or <code>CBMSM</code> object given and functions similarly to <code><a href="CBPS.html#topic+balance">CBPS::balance()</a></code>.
</p>


<h3>Value</h3>

<p>For point treatments, if clusters are not specified, an object of class <code>"bal.tab"</code> containing balance summaries for the <code>CBPS</code> object. See <code><a href="#topic+bal.tab">bal.tab()</a></code> for details.
</p>
<p>If clusters are specified, an object of class <code>"bal.tab.cluster"</code> containing balance summaries within each cluster and a summary of balance across clusters. See <code><a href="#topic+class-bal.tab.cluster">class-bal.tab.cluster</a></code> for details.
</p>
<p>If <code>CBPS()</code> is used with multi-category treatments, an object of class <code>"bal.tab.multi"</code> containing balance summaries for each pairwise treatment comparison and a summary of balance across pairwise comparisons. See <code><a href="#topic+class-bal.tab.multi">bal.tab.multi()</a></code> for details.
</p>
<p>If <code>CBMSM()</code> is used for longitudinal treatments, an object of class <code>"bal.tab.msm"</code> containing balance summaries for each time period and a summary of balance across time periods. See <code><a href="#topic+class-bal.tab.msm">class-bal.tab.msm</a></code> for details.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+bal.tab">bal.tab()</a></code> for details of calculations.
</p>
</li>
<li> <p><code><a href="#topic+class-bal.tab.cluster">class-bal.tab.cluster</a></code> for more information on clustered data.
</p>
</li>
<li> <p><code><a href="#topic+class-bal.tab.multi">bal.tab.multi()</a></code> for more information on multi-category treatments.
</p>
</li>
<li> <p><code><a href="#topic+class-bal.tab.msm">class-bal.tab.msm</a></code> for more information on longitudinal treatments.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
data("lalonde", package = "cobalt")

## Using CBPS() for generating covariate balancing 
## propensity score weights
cbps.out &lt;- CBPS::CBPS(treat ~ age + educ + married + race +
                           nodegree + re74 + re75,
                       data = lalonde)

bal.tab(cbps.out)

</code></pre>

<hr>
<h2 id='bal.tab.cem.match'>Balance Statistics for <code>cem</code> Objects</h2><span id='topic+bal.tab.cem.match'></span>

<h3>Description</h3>

<p>Generates balance statistics for <code>cem.match</code> objects from <span class="pkg">cem</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cem.match'
bal.tab(
  x,
  data,
  stats,
  int = FALSE,
  poly = 1,
  distance = NULL,
  addl = NULL,
  continuous,
  binary,
  s.d.denom,
  thresholds = NULL,
  weights = NULL,
  cluster = NULL,
  imp = NULL,
  pairwise = TRUE,
  s.weights = NULL,
  abs = FALSE,
  subset = NULL,
  quick = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bal.tab.cem.match_+3A_x">x</code></td>
<td>
<p>a <code>cem.match</code> or <code>cem.match.list</code> object; the output of a call to <code><a href="cem.html#topic+cem">cem::cem()</a></code>.</p>
</td></tr>
<tr><td><code id="bal.tab.cem.match_+3A_data">data</code></td>
<td>
<p>a data frame containing variables named in other arguments. An argument to <code>data</code> is <strong>required</strong>. It must be the same data used in the call to <code>cem()</code> or a <code>mids</code> object from which the data supplied to <code>datalist</code> in the <code>cem()</code> call originated.</p>
</td></tr>
<tr><td><code id="bal.tab.cem.match_+3A_stats">stats</code></td>
<td>
<p><code>character</code>; which statistic(s) should be reported. See <code><a href="#topic+balance-statistics">stats</a></code> for allowable options. For binary and multi-category treatments, <code>"mean.diffs"</code> (i.e., mean differences) is the default. For continuous treatments, <code>"correlations"</code> (i.e., treatment-covariate Pearson correlations) is the default. Multiple options are allowed.</p>
</td></tr>
<tr><td><code id="bal.tab.cem.match_+3A_int">int</code></td>
<td>
<p><code>logical</code> or <code>numeric</code>; whether or not to include 2-way interactions of covariates included in <code>covs</code> and in <code>addl</code>. If <code>numeric</code>, will be passed to <code>poly</code> as well.</p>
</td></tr>
<tr><td><code id="bal.tab.cem.match_+3A_poly">poly</code></td>
<td>
<p><code>numeric</code>; the highest polynomial of each continuous covariate to display. For example, if 2, squares of each continuous covariate will be displayed (in addition to the covariate itself); if 3, squares and cubes of each continuous covariate will be displayed, etc. If 1, the default, only the base covariate will be displayed. If <code>int</code> is numeric, <code>poly</code> will take on the value of <code>int</code>.</p>
</td></tr>
<tr><td><code id="bal.tab.cem.match_+3A_distance">distance</code></td>
<td>
<p>an optional formula or data frame containing distance values (e.g., propensity scores) or a character vector containing their names. If a formula or variable names are specified, <code>bal.tab()</code> will look in the argument to <code>data</code>, if specified. For longitudinal treatments, can be a list of allowable arguments, one for each time point.</p>
</td></tr>
<tr><td><code id="bal.tab.cem.match_+3A_addl">addl</code></td>
<td>
<p>an optional formula or data frame containing additional covariates for which to present balance or a character vector containing their names. If a formula or variable names are specified, <code>bal.tab()</code> will look in the arguments to the input object, <code>covs</code>, and <code>data</code>, if specified. For longitudinal treatments, can be a list of allowable arguments, one for each time point.</p>
</td></tr>
<tr><td><code id="bal.tab.cem.match_+3A_continuous">continuous</code></td>
<td>
<p>whether mean differences for continuous variables should be standardized (<code>"std"</code>) or raw (<code>"raw"</code>). Default <code>"std"</code>. Abbreviations allowed. This option can be set globally using <code><a href="#topic+set.cobalt.options">set.cobalt.options()</a></code>.</p>
</td></tr>
<tr><td><code id="bal.tab.cem.match_+3A_binary">binary</code></td>
<td>
<p>whether mean differences for binary variables (i.e., difference in proportion) should be standardized (<code>"std"</code>) or raw (<code>"raw"</code>). Default <code>"raw"</code>. Abbreviations allowed. This option can be set globally using <code><a href="#topic+set.cobalt.options">set.cobalt.options()</a></code>.</p>
</td></tr>
<tr><td><code id="bal.tab.cem.match_+3A_s.d.denom">s.d.denom</code></td>
<td>
<p><code>character</code>; how the denominator for standardized mean differences should be calculated, if requested. See <code><a href="#topic+col_w_smd">col_w_smd()</a></code> for allowable options. Abbreviations allowed. If not specified, will be set to <code>"treated"</code>, where the treated group corresponds to the <code>baseline.group</code> in the call to <code>cem()</code>.</p>
</td></tr>
<tr><td><code id="bal.tab.cem.match_+3A_thresholds">thresholds</code></td>
<td>
<p>a named vector of balance thresholds, where the name corresponds to the statistic (i.e., in <code>stats</code>) that the threshold applies to. For example, to request thresholds on mean differences and variance ratios, one can set <code>thresholds = c(m = .05, v = 2)</code>. Requesting a threshold automatically requests the display of that statistic. When specified, extra columns are inserted into the Balance table describing whether the requested balance statistics exceeded the threshold or not. Summary tables tallying the number of variables that exceeded and were within the threshold and displaying the variables with the greatest imbalance on that balance measure are added to the output.</p>
</td></tr>
<tr><td><code id="bal.tab.cem.match_+3A_weights">weights</code></td>
<td>
<p>a vector, list, or <code>data.frame</code> containing weights for each unit, or a string containing the names of the weights variables in <code>data</code>, or an object with a <code><a href="#topic+get.w">get.w()</a></code> method or a list thereof. The weights can be, e.g., inverse probability weights or matching weights resulting from a matching algorithm.</p>
</td></tr>
<tr><td><code id="bal.tab.cem.match_+3A_cluster">cluster</code></td>
<td>
<p>either a vector containing cluster membership for each unit or a string containing the name of the cluster membership variable in <code>data</code> or the input object. See <code><a href="#topic+class-bal.tab.cluster">class-bal.tab.cluster</a></code> for details.</p>
</td></tr>
<tr><td><code id="bal.tab.cem.match_+3A_imp">imp</code></td>
<td>
<p>either a vector containing imputation indices for each unit or a string containing the name of the imputation index variable in <code>data</code> or the input object. See <code><a href="#topic+class-bal.tab.imp">class-bal.tab.imp</a></code> for details. Not necessary if <code>data</code> is a <code>mids</code> object.</p>
</td></tr>
<tr><td><code id="bal.tab.cem.match_+3A_pairwise">pairwise</code></td>
<td>
<p>whether balance should be computed for pairs of treatments or for each treatment against all groups combined. See <code><a href="#topic+class-bal.tab.multi">bal.tab.multi()</a></code> for details. This can also be used with a binary treatment to assess balance with respect to the full sample.</p>
</td></tr>
<tr><td><code id="bal.tab.cem.match_+3A_s.weights">s.weights</code></td>
<td>
<p>Optional; either a vector containing sampling weights for each unit or a string containing the name of the sampling weight variable in <code>data</code>. These function like regular weights except that both the adjusted and unadjusted samples will be weighted according to these weights if weights are used.</p>
</td></tr>
<tr><td><code id="bal.tab.cem.match_+3A_abs">abs</code></td>
<td>
<p><code>logical</code>; whether displayed balance statistics should be in absolute value or not.</p>
</td></tr>
<tr><td><code id="bal.tab.cem.match_+3A_subset">subset</code></td>
<td>
<p>a <code>logical</code> or <code>numeric</code> vector denoting whether each observation should be included or which observations should be included. If <code>logical</code>, it should have length equal to the number of units. <code>NA</code>s will be treated as <code>FALSE</code>. This can be used as an alternative to <code>cluster</code> to examine balance on subsets of the data.</p>
</td></tr>
<tr><td><code id="bal.tab.cem.match_+3A_quick">quick</code></td>
<td>
<p><code>logical</code>; if <code>TRUE</code>, will not compute any values that will not be displayed. Set to <code>FALSE</code> if computed values not displayed will be used later.</p>
</td></tr>
<tr><td><code id="bal.tab.cem.match_+3A_...">...</code></td>
<td>
<p>for some input types, other arguments that are required or allowed. Otherwise, further arguments to control display of output. See <a href="#topic+display-options">display options</a> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bal.tab.cem.match()</code> generates a list of balance summaries for the <code>cem.match</code> object given, and functions similarly to <code><a href="cem.html#topic+imbalance">cem::imbalance()</a></code>.
</p>


<h3>Value</h3>

<p>If clusters and imputations are not specified, an object of class <code>"bal.tab"</code> containing balance summaries for the <code>cem.match</code> object. See <code><a href="#topic+bal.tab">bal.tab()</a></code> for details.
</p>
<p>If imputations are specified, an object of class <code>"bal.tab.imp"</code> containing balance summaries for each imputation and a summary of balance across imputations. See <code><a href="#topic+class-bal.tab.imp">class-bal.tab.imp</a></code> for details.
</p>
<p>If <code>cem()</code> is used with multi-category treatments, an object of class <code>"bal.tab.multi"</code> containing balance summaries for each pairwise treatment comparison. See <code><a href="#topic+class-bal.tab.multi">bal.tab.multi()</a></code> for details.
</p>
<p>If clusters are specified, an object of class <code>"bal.tab.cluster"</code> containing balance summaries within each cluster and a summary of balance across clusters. See <code><a href="#topic+class-bal.tab.cluster">class-bal.tab.cluster</a></code> for details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bal.tab">bal.tab()</a></code> for details of calculations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("lalonde", package = "cobalt")

## Coarsened exact matching
cem.out &lt;- cem::cem("treat", data = lalonde, drop = "re78")

bal.tab(cem.out, data = lalonde, un = TRUE, 
        stats = c("m", "k"))

</code></pre>

<hr>
<h2 id='bal.tab.default'>Balance Statistics for Other Objects</h2><span id='topic+bal.tab.default'></span>

<h3>Description</h3>

<p>Generates balance statistics using an object for which there is not a defined method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
bal.tab(
  x,
  stats,
  int = FALSE,
  poly = 1,
  distance = NULL,
  addl = NULL,
  data = NULL,
  continuous,
  binary,
  s.d.denom,
  thresholds = NULL,
  weights = NULL,
  cluster = NULL,
  imp = NULL,
  pairwise = TRUE,
  s.weights = NULL,
  abs = FALSE,
  subset = NULL,
  quick = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bal.tab.default_+3A_x">x</code></td>
<td>
<p>An object containing information about conditioning. See Details.</p>
</td></tr>
<tr><td><code id="bal.tab.default_+3A_stats">stats</code></td>
<td>
<p><code>character</code>; which statistic(s) should be reported. See <code><a href="#topic+balance-statistics">stats</a></code> for allowable options. For binary and multi-category treatments, <code>"mean.diffs"</code> (i.e., mean differences) is the default. For continuous treatments, <code>"correlations"</code> (i.e., treatment-covariate Pearson correlations) is the default. Multiple options are allowed.</p>
</td></tr>
<tr><td><code id="bal.tab.default_+3A_int">int</code></td>
<td>
<p><code>logical</code> or <code>numeric</code>; whether or not to include 2-way interactions of covariates included in <code>covs</code> and in <code>addl</code>. If <code>numeric</code>, will be passed to <code>poly</code> as well.</p>
</td></tr>
<tr><td><code id="bal.tab.default_+3A_poly">poly</code></td>
<td>
<p><code>numeric</code>; the highest polynomial of each continuous covariate to display. For example, if 2, squares of each continuous covariate will be displayed (in addition to the covariate itself); if 3, squares and cubes of each continuous covariate will be displayed, etc. If 1, the default, only the base covariate will be displayed. If <code>int</code> is numeric, <code>poly</code> will take on the value of <code>int</code>.</p>
</td></tr>
<tr><td><code id="bal.tab.default_+3A_distance">distance</code></td>
<td>
<p>an optional formula or data frame containing distance values (e.g., propensity scores) or a character vector containing their names. If a formula or variable names are specified, <code>bal.tab()</code> will look in the argument to <code>data</code>, if specified. For longitudinal treatments, can be a list of allowable arguments, one for each time point.</p>
</td></tr>
<tr><td><code id="bal.tab.default_+3A_addl">addl</code></td>
<td>
<p>an optional formula or data frame containing additional covariates for which to present balance or a character vector containing their names. If a formula or variable names are specified, <code>bal.tab()</code> will look in the arguments to the input object, <code>covs</code>, and <code>data</code>, if specified. For longitudinal treatments, can be a list of allowable arguments, one for each time point.</p>
</td></tr>
<tr><td><code id="bal.tab.default_+3A_data">data</code></td>
<td>
<p>an optional data frame containing variables named in other arguments. For some input object types, this is required.</p>
</td></tr>
<tr><td><code id="bal.tab.default_+3A_continuous">continuous</code></td>
<td>
<p>whether mean differences for continuous variables should be standardized (<code>"std"</code>) or raw (<code>"raw"</code>). Default <code>"std"</code>. Abbreviations allowed. This option can be set globally using <code><a href="#topic+set.cobalt.options">set.cobalt.options()</a></code>.</p>
</td></tr>
<tr><td><code id="bal.tab.default_+3A_binary">binary</code></td>
<td>
<p>whether mean differences for binary variables (i.e., difference in proportion) should be standardized (<code>"std"</code>) or raw (<code>"raw"</code>). Default <code>"raw"</code>. Abbreviations allowed. This option can be set globally using <code><a href="#topic+set.cobalt.options">set.cobalt.options()</a></code>.</p>
</td></tr>
<tr><td><code id="bal.tab.default_+3A_s.d.denom">s.d.denom</code></td>
<td>
<p><code>character</code>; how the denominator for standardized mean differences should be calculated, if requested. See <code><a href="#topic+col_w_smd">col_w_smd()</a></code> for allowable options. If weights are supplied, each set of weights should have a corresponding entry to <code>s.d.denom</code>. Abbreviations allowed. If left blank and weights, subclasses, or matching strata are supplied, <code>bal.tab()</code> will figure out which one is best based on the <code>estimand</code>, if given (for ATT, <code>"treated"</code>; for ATC, <code>"control"</code>; otherwise <code>"pooled"</code>) and other clues if not.</p>
</td></tr>
<tr><td><code id="bal.tab.default_+3A_thresholds">thresholds</code></td>
<td>
<p>a named vector of balance thresholds, where the name corresponds to the statistic (i.e., in <code>stats</code>) that the threshold applies to. For example, to request thresholds on mean differences and variance ratios, one can set <code>thresholds = c(m = .05, v = 2)</code>. Requesting a threshold automatically requests the display of that statistic. When specified, extra columns are inserted into the Balance table describing whether the requested balance statistics exceeded the threshold or not. Summary tables tallying the number of variables that exceeded and were within the threshold and displaying the variables with the greatest imbalance on that balance measure are added to the output.</p>
</td></tr>
<tr><td><code id="bal.tab.default_+3A_weights">weights</code></td>
<td>
<p>a vector, list, or <code>data.frame</code> containing weights for each unit, or a string containing the names of the weights variables in <code>data</code>, or an object with a <code><a href="#topic+get.w">get.w()</a></code> method or a list thereof. The weights can be, e.g., inverse probability weights or matching weights resulting from a matching algorithm.</p>
</td></tr>
<tr><td><code id="bal.tab.default_+3A_cluster">cluster</code></td>
<td>
<p>either a vector containing cluster membership for each unit or a string containing the name of the cluster membership variable in <code>data</code> or the input object. See <code><a href="#topic+class-bal.tab.cluster">class-bal.tab.cluster</a></code> for details.</p>
</td></tr>
<tr><td><code id="bal.tab.default_+3A_imp">imp</code></td>
<td>
<p>either a vector containing imputation indices for each unit or a string containing the name of the imputation index variable in <code>data</code> or the input object. See <code><a href="#topic+class-bal.tab.imp">class-bal.tab.imp</a></code> for details. Not necessary if <code>data</code> is a <code>mids</code> object.</p>
</td></tr>
<tr><td><code id="bal.tab.default_+3A_pairwise">pairwise</code></td>
<td>
<p>whether balance should be computed for pairs of treatments or for each treatment against all groups combined. See <code><a href="#topic+class-bal.tab.multi">bal.tab.multi()</a></code> for details. This can also be used with a binary treatment to assess balance with respect to the full sample.</p>
</td></tr>
<tr><td><code id="bal.tab.default_+3A_s.weights">s.weights</code></td>
<td>
<p>Optional; either a vector containing sampling weights for each unit or a string containing the name of the sampling weight variable in <code>data</code>. These function like regular weights except that both the adjusted and unadjusted samples will be weighted according to these weights if weights are used.</p>
</td></tr>
<tr><td><code id="bal.tab.default_+3A_abs">abs</code></td>
<td>
<p><code>logical</code>; whether displayed balance statistics should be in absolute value or not.</p>
</td></tr>
<tr><td><code id="bal.tab.default_+3A_subset">subset</code></td>
<td>
<p>a <code>logical</code> or <code>numeric</code> vector denoting whether each observation should be included or which observations should be included. If <code>logical</code>, it should have length equal to the number of units. <code>NA</code>s will be treated as <code>FALSE</code>. This can be used as an alternative to <code>cluster</code> to examine balance on subsets of the data.</p>
</td></tr>
<tr><td><code id="bal.tab.default_+3A_quick">quick</code></td>
<td>
<p><code>logical</code>; if <code>TRUE</code>, will not compute any values that will not be displayed. Set to <code>FALSE</code> if computed values not displayed will be used later.</p>
</td></tr>
<tr><td><code id="bal.tab.default_+3A_...">...</code></td>
<td>
<p>other arguments that would be passed to <code><a href="#topic+bal.tab.formula">bal.tab.formula()</a></code>, <code><a href="#topic+bal.tab.data.frame">bal.tab.data.frame()</a></code>, or <code><a href="#topic+bal.tab.time.list">bal.tab.time.list()</a></code>. See Details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bal.tab.default()</code> processes its input and attempt to extract enough information from it to display covariate balance for <code>x</code>. The purpose of this method is to allow users who have created their own objects containing conditioning information (i.e., weights, subclasses, treatments, covariates, etc.) to access the capabilities of <code>bal.tab()</code> without having a special method written for them. By including the correct items in <code>x</code>, <code>bal.tab.default()</code> can present balance tables as if the input was the output of one of the specifically supported packages (e.g., <span class="pkg">MatchIt</span>, <span class="pkg">twang</span>, etc.).
</p>
<p>The function will search <code>x</code> for the following named items and attempt to process them:
</p>

<dl>
<dt><code>treat</code></dt><dd><p>A vector (<code>numeric</code>, <code>character</code>, <code>factor</code>) containing the values of the treatment for each unit or the name of the column in <code>data</code> containing them. Essentially the same input to <code>treat</code> in <code><a href="#topic+bal.tab.data.frame">bal.tab.data.frame()</a></code>.
</p>
</dd>
<dt><code>treat.list</code></dt><dd><p>A list of vectors (<code>numeric</code>, <code>character</code>, <code>factor</code>) containing, for each time point, the values of the treatment for each unit or the name of the column in <code>data</code> containing them. Essentially the same input to <code>treat.list</code> in <code><a href="#topic+bal.tab.time.list">bal.tab.time.list()</a></code>.
</p>
</dd>
<dt><code>covs</code></dt><dd><p>A <code>data.frame</code> containing the values of the covariates for each unit. Essentially the same input to <code>covs</code> in <code><a href="#topic+bal.tab.data.frame">bal.tab.data.frame()</a></code>.
</p>
</dd>
<dt><code>covs.list</code></dt><dd><p>A list of <code>data.frame</code>s containing, for each time point, the values of the covariates for each unit. Essentially the same input to <code>covs.list</code> in <code><a href="#topic+bal.tab.time.list">bal.tab.time.list()</a></code>.
</p>
</dd>
<dt><code>formula</code></dt><dd><p>A <code>formula</code> with the treatment variable as the response and the covariates for which balance is to be assessed as the terms. Essentially the same input to <code>formula</code> in <code><a href="#topic+bal.tab.formula">bal.tab.formula()</a></code>.
</p>
</dd>
<dt><code>formula.list</code></dt><dd><p>A list of <code>formula</code>s with, for each time point, the treatment variable as the response and the covariates for which balance is to be assessed as the terms. Essentially the same input to <code>formula.list</code> in <code><a href="#topic+bal.tab.time.list">bal.tab.time.list()</a></code>.
</p>
</dd>
<dt><code>data</code></dt><dd><p>A <code>data.frame</code> containing variables with the names used in other arguments and components (e.g., <code>formula</code>, <code>weights</code>, etc.). Essentially the same input to <code>data</code> in <code><a href="#topic+bal.tab.formula">bal.tab.formula()</a></code>, <code><a href="#topic+bal.tab.data.frame">bal.tab.data.frame()</a></code>, or <code><a href="#topic+bal.tab.time.list">bal.tab.time.list()</a></code>.
</p>
</dd>
<dt><code>weights</code></dt><dd><p>A vector, list, or <code>data.frame</code> containing weights for each unit or a string containing the names of the weights variables in <code>data</code>. Essentially the same input to <code>weights</code> in <code><a href="#topic+bal.tab.data.frame">bal.tab.data.frame()</a></code> or <code><a href="#topic+bal.tab.time.list">bal.tab.time.list()</a></code>.
</p>
</dd>
<dt><code>distance</code></dt><dd>
<p>A vector, formula, or data frame containing distance values (e.g., propensity scores) or a character vector containing their names. If a formula or variable names are specified, <code>bal.tab()</code> will look in the argument to <code>data</code>, if specified. Essentially the same input to <code>distance</code> in <code><a href="#topic+bal.tab.data.frame">bal.tab.data.frame()</a></code>.
</p>
</dd>
<dt><code>formula.list</code></dt><dd><p>A list of vectors or <code>data.frame</code>s containing, for each time point, distance values (e.g., propensity scores) for each unit or a string containing the name of the distance variable in <code>data</code>. Essentially the same input to <code>distance.list</code> in <code><a href="#topic+bal.tab.time.list">bal.tab.time.list()</a></code>.
</p>
</dd>
<dt><code>subclass</code></dt><dd><p>A vector containing subclass membership for each unit or a string containing the name of the subclass variable in <code>data</code>. Essentially the same input to <code>subclass</code> in <code><a href="#topic+bal.tab.data.frame">bal.tab.data.frame()</a></code>.
</p>
</dd>
<dt><code>match.strata</code></dt><dd><p>A vector containing matching stratum membership for each unit or a string containing the name of the matching stratum variable in <code>data</code>. Essentially the same input to <code>match.strata</code> in <code><a href="#topic+bal.tab.data.frame">bal.tab.data.frame()</a></code>.
</p>
</dd>
<dt><code>estimand</code></dt><dd><p>A <code>character</code> vector; whether the desired estimand is the &quot;ATT&quot;, &quot;ATC&quot;, or &quot;ATE&quot; for each set of weights. Essentially the same input to <code>estimand</code> in <code><a href="#topic+bal.tab.data.frame">bal.tab.data.frame()</a></code>.
</p>
</dd>
<dt><code>s.weights</code></dt><dd><p>A vector containing sampling weights for each unit or a string containing the name of the sampling weight variable in <code>data</code>. Essentially the same input to <code>s.weights</code> in <code><a href="#topic+bal.tab.data.frame">bal.tab.data.frame()</a></code> or <code><a href="#topic+bal.tab.time.list">bal.tab.time.list()</a></code>.
</p>
</dd>
<dt><code>focal</code></dt><dd><p>The name of the focal treatment when multi-category treatments are used. Essentially the same input to <code>focal</code> in <code><a href="#topic+bal.tab.data.frame">bal.tab.data.frame()</a></code>.
</p>
</dd>
<dt><code>call</code></dt><dd><p>A <code>call</code> object containing the function call, usually generated by using <code><a href="base.html#topic+match.call">match.call()</a></code> inside the function that created <code>x</code>.
</p>
</dd>
</dl>

<p>Any of these items can also be supplied directly to <code>bal.tab.default</code>, e.g., <code>bal.tab.default(x, formula = treat ~ x1 + x2)</code>. If supplied, it will override the object with the same role in <code>x</code>. In addition, any arguments to <code><a href="#topic+bal.tab.formula">bal.tab.formula()</a></code>, <code><a href="#topic+bal.tab.data.frame">bal.tab.data.frame()</a></code>, and <code><a href="#topic+bal.tab.time.list">bal.tab.time.list()</a></code> are allowed and perform the same function.
</p>
<p>At least some inputs containing information to create the treatment and covariates are required (e.g., <code>formula</code> and <code>data</code> or <code>covs</code> and <code>treat</code>). All other arguments are optional and have the same defaults as those in <code><a href="#topic+bal.tab.data.frame">bal.tab.data.frame()</a></code> or <code><a href="#topic+bal.tab.time.list">bal.tab.time.list()</a></code>. If <code>treat.list</code>, <code>covs.list</code>, or <code>formula.list</code> are supplied in <code>x</code> or as an argument to <code>bal.tab.default()</code>, the function will proceed considering a longitudinal treatment. Otherwise, it will proceed considering a point treatment.
</p>
<p><code>bal.tab.default()</code>, like other <code>bal.tab()</code> methods, is just a shortcut to supply arguments to <code>bal.tab.data.frame()</code> or <code>bal.tab.time.list()</code>. Therefore, any matters regarding argument priority or function are described in the documentation for these methods.
</p>


<h3>Value</h3>

<p>For point treatments, if clusters and imputations are not specified, an object of class <code>"bal.tab"</code> containing balance summaries for the specified treatment and covariates. See <code><a href="#topic+bal.tab">bal.tab()</a></code> for details.
</p>
<p>If clusters are specified, an object of class <code>"bal.tab.cluster"</code> containing balance summaries within each cluster and a summary of balance across clusters. See <code><a href="#topic+class-bal.tab.cluster">class-bal.tab.cluster</a></code> for details.
</p>
<p>If imputations are specified, an object of class <code>"bal.tab.imp"</code> containing balance summaries for each imputation and a summary of balance across imputations, just as with clusters. See <code><a href="#topic+class-bal.tab.imp">class-bal.tab.imp</a></code> for details.
</p>
<p>If multi-category treatments are used, an object of class <code>"bal.tab.multi"</code> containing balance summaries for each pairwise treatment comparison and a summary of balance across pairwise comparisons. See <code><a href="#topic+class-bal.tab.multi">bal.tab.multi()</a></code> for details.
</p>
<p>If longitudinal treatments are used, an object of class <code>"bal.tab.msm"</code> containing balance summaries at each time point. Each balance summary is its own <code>bal.tab</code> object. See <code><a href="#topic+class-bal.tab.msm">class-bal.tab.msm</a></code> for more details.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+bal.tab.formula">bal.tab.formula()</a></code> and <code><a href="#topic+bal.tab.time.list">bal.tab.time.list()</a></code> for additional arguments to be supplied.
</p>
</li>
<li> <p><code><a href="#topic+bal.tab">bal.tab()</a></code> for output and details of calculations.
</p>
</li>
<li> <p><code><a href="#topic+class-bal.tab.cluster">class-bal.tab.cluster</a></code> for more information on clustered data.
</p>
</li>
<li> <p><code><a href="#topic+class-bal.tab.imp">class-bal.tab.imp</a></code> for more information on multiply imputed data.
</p>
</li>
<li> <p><code><a href="#topic+class-bal.tab.multi">bal.tab.multi()</a></code> for more information on multi-category treatments.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data("lalonde", package = "cobalt")
covs &lt;- subset(lalonde,  select = -c(treat, re78))

##Writing a function the produces output for direct
##use in bal.tab.default

ate.weights &lt;- function(treat, covs) {
    data &lt;- data.frame(treat, covs)
    formula &lt;- formula(data)
    ps &lt;- glm(formula, data = data, 
              family = "binomial")$fitted.values
    weights &lt;- treat/ps + (1-treat)/(1-ps)
    call &lt;- match.call()
    out &lt;- list(treat = treat,
                covs = covs,
                distance = ps,
                weights = weights,
                estimand = "ATE",
                call = call)
    return(out)
}

out &lt;- ate.weights(lalonde$treat, covs)

bal.tab(out, un = TRUE)
</code></pre>

<hr>
<h2 id='bal.tab.designmatch'>Balance Statistics for <code>designmatch</code> Objects</h2><span id='topic+bal.tab.designmatch'></span>

<h3>Description</h3>

<p>Generates balance statistics for output objects from <span class="pkg">designmatch</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'designmatch'
bal.tab(
  x,
  formula = NULL,
  data = NULL,
  treat = NULL,
  covs = NULL,
  stats,
  int = FALSE,
  poly = 1,
  distance = NULL,
  addl = NULL,
  continuous,
  binary,
  s.d.denom,
  thresholds = NULL,
  weights = NULL,
  cluster = NULL,
  imp = NULL,
  pairwise = TRUE,
  s.weights = NULL,
  abs = FALSE,
  subset = NULL,
  quick = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bal.tab.designmatch_+3A_x">x</code></td>
<td>
<p>the output of a call to <code><a href="designmatch.html#topic+bmatch">designmatch::bmatch()</a></code> or related wrapper functions from the <span class="pkg">designmatch</span> package.</p>
</td></tr>
<tr><td><code id="bal.tab.designmatch_+3A_formula">formula</code></td>
<td>
<p>a <code>formula</code> with the treatment variable as the response and the covariates for which balance is to be assessed as the predictors. All named variables must be in <code>data</code>. See Details.</p>
</td></tr>
<tr><td><code id="bal.tab.designmatch_+3A_data">data</code></td>
<td>
<p>a data frame containing variables named in <code>formula</code>, if supplied, and other arguments.</p>
</td></tr>
<tr><td><code id="bal.tab.designmatch_+3A_treat">treat</code></td>
<td>
<p>a vector of treatment statuses. See Details.</p>
</td></tr>
<tr><td><code id="bal.tab.designmatch_+3A_covs">covs</code></td>
<td>
<p>a data frame of covariate values for which to check balance. See Details.</p>
</td></tr>
<tr><td><code id="bal.tab.designmatch_+3A_stats">stats</code></td>
<td>
<p><code>character</code>; which statistic(s) should be reported. See <code><a href="#topic+balance-statistics">stats</a></code> for allowable options. For binary and multi-category treatments, <code>"mean.diffs"</code> (i.e., mean differences) is the default. For continuous treatments, <code>"correlations"</code> (i.e., treatment-covariate Pearson correlations) is the default. Multiple options are allowed.</p>
</td></tr>
<tr><td><code id="bal.tab.designmatch_+3A_int">int</code></td>
<td>
<p><code>logical</code> or <code>numeric</code>; whether or not to include 2-way interactions of covariates included in <code>covs</code> and in <code>addl</code>. If <code>numeric</code>, will be passed to <code>poly</code> as well.</p>
</td></tr>
<tr><td><code id="bal.tab.designmatch_+3A_poly">poly</code></td>
<td>
<p><code>numeric</code>; the highest polynomial of each continuous covariate to display. For example, if 2, squares of each continuous covariate will be displayed (in addition to the covariate itself); if 3, squares and cubes of each continuous covariate will be displayed, etc. If 1, the default, only the base covariate will be displayed. If <code>int</code> is numeric, <code>poly</code> will take on the value of <code>int</code>.</p>
</td></tr>
<tr><td><code id="bal.tab.designmatch_+3A_distance">distance</code></td>
<td>
<p>an optional formula or data frame containing distance values (e.g., propensity scores) or a character vector containing their names. If a formula or variable names are specified, <code>bal.tab()</code> will look in the argument to <code>data</code>, if specified. For longitudinal treatments, can be a list of allowable arguments, one for each time point.</p>
</td></tr>
<tr><td><code id="bal.tab.designmatch_+3A_addl">addl</code></td>
<td>
<p>an optional formula or data frame containing additional covariates for which to present balance or a character vector containing their names. If a formula or variable names are specified, <code>bal.tab()</code> will look in the arguments to the input object, <code>covs</code>, and <code>data</code>, if specified. For longitudinal treatments, can be a list of allowable arguments, one for each time point.</p>
</td></tr>
<tr><td><code id="bal.tab.designmatch_+3A_continuous">continuous</code></td>
<td>
<p>whether mean differences for continuous variables should be standardized (<code>"std"</code>) or raw (<code>"raw"</code>). Default <code>"std"</code>. Abbreviations allowed. This option can be set globally using <code><a href="#topic+set.cobalt.options">set.cobalt.options()</a></code>.</p>
</td></tr>
<tr><td><code id="bal.tab.designmatch_+3A_binary">binary</code></td>
<td>
<p>whether mean differences for binary variables (i.e., difference in proportion) should be standardized (<code>"std"</code>) or raw (<code>"raw"</code>). Default <code>"raw"</code>. Abbreviations allowed. This option can be set globally using <code><a href="#topic+set.cobalt.options">set.cobalt.options()</a></code>.</p>
</td></tr>
<tr><td><code id="bal.tab.designmatch_+3A_s.d.denom">s.d.denom</code></td>
<td>
<p><code>character</code>; how the denominator for standardized mean differences should be calculated, if requested. See <code><a href="#topic+col_w_smd">col_w_smd()</a></code> for allowable options. Abbreviations allowed. If not specified, will be set to <code>"treated"</code>.</p>
</td></tr>
<tr><td><code id="bal.tab.designmatch_+3A_thresholds">thresholds</code></td>
<td>
<p>a named vector of balance thresholds, where the name corresponds to the statistic (i.e., in <code>stats</code>) that the threshold applies to. For example, to request thresholds on mean differences and variance ratios, one can set <code>thresholds = c(m = .05, v = 2)</code>. Requesting a threshold automatically requests the display of that statistic. When specified, extra columns are inserted into the Balance table describing whether the requested balance statistics exceeded the threshold or not. Summary tables tallying the number of variables that exceeded and were within the threshold and displaying the variables with the greatest imbalance on that balance measure are added to the output.</p>
</td></tr>
<tr><td><code id="bal.tab.designmatch_+3A_weights">weights</code></td>
<td>
<p>a vector, list, or <code>data.frame</code> containing weights for each unit, or a string containing the names of the weights variables in <code>data</code>, or an object with a <code><a href="#topic+get.w">get.w()</a></code> method or a list thereof. The weights can be, e.g., inverse probability weights or matching weights resulting from a matching algorithm.</p>
</td></tr>
<tr><td><code id="bal.tab.designmatch_+3A_cluster">cluster</code></td>
<td>
<p>either a vector containing cluster membership for each unit or a string containing the name of the cluster membership variable in <code>data</code> or the input object. See <code><a href="#topic+class-bal.tab.cluster">class-bal.tab.cluster</a></code> for details.</p>
</td></tr>
<tr><td><code id="bal.tab.designmatch_+3A_imp">imp</code></td>
<td>
<p>either a vector containing imputation indices for each unit or a string containing the name of the imputation index variable in <code>data</code> or the input object. See <code><a href="#topic+class-bal.tab.imp">class-bal.tab.imp</a></code> for details. Not necessary if <code>data</code> is a <code>mids</code> object.</p>
</td></tr>
<tr><td><code id="bal.tab.designmatch_+3A_pairwise">pairwise</code></td>
<td>
<p>whether balance should be computed for pairs of treatments or for each treatment against all groups combined. See <code><a href="#topic+class-bal.tab.multi">bal.tab.multi()</a></code> for details. This can also be used with a binary treatment to assess balance with respect to the full sample.</p>
</td></tr>
<tr><td><code id="bal.tab.designmatch_+3A_s.weights">s.weights</code></td>
<td>
<p>Optional; either a vector containing sampling weights for each unit or a string containing the name of the sampling weight variable in <code>data</code>. These function like regular weights except that both the adjusted and unadjusted samples will be weighted according to these weights if weights are used.</p>
</td></tr>
<tr><td><code id="bal.tab.designmatch_+3A_abs">abs</code></td>
<td>
<p><code>logical</code>; whether displayed balance statistics should be in absolute value or not.</p>
</td></tr>
<tr><td><code id="bal.tab.designmatch_+3A_subset">subset</code></td>
<td>
<p>a <code>logical</code> or <code>numeric</code> vector denoting whether each observation should be included or which observations should be included. If <code>logical</code>, it should have length equal to the number of units. <code>NA</code>s will be treated as <code>FALSE</code>. This can be used as an alternative to <code>cluster</code> to examine balance on subsets of the data.</p>
</td></tr>
<tr><td><code id="bal.tab.designmatch_+3A_quick">quick</code></td>
<td>
<p><code>logical</code>; if <code>TRUE</code>, will not compute any values that will not be displayed. Set to <code>FALSE</code> if computed values not displayed will be used later.</p>
</td></tr>
<tr><td><code id="bal.tab.designmatch_+3A_...">...</code></td>
<td>
<p>for some input types, other arguments that are required or allowed. Otherwise, further arguments to control display of output. See <a href="#topic+display-options">display options</a> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bal.tab()</code> generates a list of balance summaries for the object given, and functions similarly to <code><a href="designmatch.html#topic+meantab">designmatch::meantab()</a></code>. Note that output objects from <span class="pkg">designmatch</span> do not have their own class; <code>bal.tab()</code> first checks whether the object meets the criteria to be treated as a <code>designmatch</code> object before dispatching the correct method. Renaming or removing items from the output object can create unintended consequences.
</p>
<p>The input to <code>bal.tab.designmatch()</code> must include either both <code>formula</code> and <code>data</code> or both <code>covs</code> and <code>treat</code>. Using the <code>covs</code> + <code>treat</code> input mirrors how <code><a href="designmatch.html#topic+meantab">designmatch::meantab()</a></code> is used (note that to see identical results to <code>meantab()</code>, <code>s.d.denom</code> must be set to <code>"pooled"</code>).
</p>


<h3>Value</h3>

<p>If clusters and imputations are not specified, an object of class <code>"bal.tab"</code> containing balance summaries for the given object. See <code><a href="#topic+bal.tab">bal.tab()</a></code> for details.
</p>
<p>If clusters are specified, an object of class <code>"bal.tab.cluster"</code> containing balance summaries within each cluster and a summary of balance across clusters. See <code><a href="#topic+class-bal.tab.cluster">class-bal.tab.cluster</a></code> for details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bal.tab">bal.tab()</a></code> for details of calculations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("lalonde", package = "cobalt")

library(designmatch)
covariates &lt;- as.matrix(lalonde[c("age", "educ", "re74", "re75")])
treat &lt;- lalonde$treat
dmout &lt;- bmatch(treat,
                total_groups = sum(treat == 1),
                mom = list(covs = covariates,
                           tols = absstddif(covariates, 
                                            treat, .05))
)

## Using treat and covs
bal.tab(dmout, treat = treat, covs = covariates)

</code></pre>

<hr>
<h2 id='bal.tab.ebalance'>Balance Statistics for <code>ebalance</code> Objects</h2><span id='topic+bal.tab.ebalance'></span>

<h3>Description</h3>

<p>Generates balance statistics for output objects from <span class="pkg">ebal</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ebalance'
bal.tab(
  x,
  formula = NULL,
  data = NULL,
  treat = NULL,
  covs = NULL,
  stats,
  int = FALSE,
  poly = 1,
  distance = NULL,
  addl = NULL,
  continuous,
  binary,
  s.d.denom,
  thresholds = NULL,
  weights = NULL,
  cluster = NULL,
  imp = NULL,
  pairwise = TRUE,
  s.weights = NULL,
  abs = FALSE,
  subset = NULL,
  quick = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bal.tab.ebalance_+3A_x">x</code></td>
<td>
<p>an <code>ebalance</code> object (the output of a call to <code><a href="ebal.html#topic+ebalance">ebal::ebalance()</a></code> or <code><a href="ebal.html#topic+ebalance.trim">ebal::ebalance.trim()</a></code>).</p>
</td></tr>
<tr><td><code id="bal.tab.ebalance_+3A_formula">formula</code></td>
<td>
<p>a <code>formula</code> with the treatment variable as the response and the covariates for which balance is to be assessed as the predictors. All named variables must be in <code>data</code>. See Details.</p>
</td></tr>
<tr><td><code id="bal.tab.ebalance_+3A_data">data</code></td>
<td>
<p>a data frame containing variables named in <code>formula</code>, if supplied, and other arguments.</p>
</td></tr>
<tr><td><code id="bal.tab.ebalance_+3A_treat">treat</code></td>
<td>
<p>a vector of treatment statuses. See Details.</p>
</td></tr>
<tr><td><code id="bal.tab.ebalance_+3A_covs">covs</code></td>
<td>
<p>a data frame of covariate values for which to check balance. See Details.</p>
</td></tr>
<tr><td><code id="bal.tab.ebalance_+3A_stats">stats</code></td>
<td>
<p><code>character</code>; which statistic(s) should be reported. See <code><a href="#topic+balance-statistics">stats</a></code> for allowable options. For binary and multi-category treatments, <code>"mean.diffs"</code> (i.e., mean differences) is the default. For continuous treatments, <code>"correlations"</code> (i.e., treatment-covariate Pearson correlations) is the default. Multiple options are allowed.</p>
</td></tr>
<tr><td><code id="bal.tab.ebalance_+3A_int">int</code></td>
<td>
<p><code>logical</code> or <code>numeric</code>; whether or not to include 2-way interactions of covariates included in <code>covs</code> and in <code>addl</code>. If <code>numeric</code>, will be passed to <code>poly</code> as well.</p>
</td></tr>
<tr><td><code id="bal.tab.ebalance_+3A_poly">poly</code></td>
<td>
<p><code>numeric</code>; the highest polynomial of each continuous covariate to display. For example, if 2, squares of each continuous covariate will be displayed (in addition to the covariate itself); if 3, squares and cubes of each continuous covariate will be displayed, etc. If 1, the default, only the base covariate will be displayed. If <code>int</code> is numeric, <code>poly</code> will take on the value of <code>int</code>.</p>
</td></tr>
<tr><td><code id="bal.tab.ebalance_+3A_distance">distance</code></td>
<td>
<p>an optional formula or data frame containing distance values (e.g., propensity scores) or a character vector containing their names. If a formula or variable names are specified, <code>bal.tab()</code> will look in the argument to <code>data</code>, if specified. For longitudinal treatments, can be a list of allowable arguments, one for each time point.</p>
</td></tr>
<tr><td><code id="bal.tab.ebalance_+3A_addl">addl</code></td>
<td>
<p>an optional formula or data frame containing additional covariates for which to present balance or a character vector containing their names. If a formula or variable names are specified, <code>bal.tab()</code> will look in the arguments to the input object, <code>covs</code>, and <code>data</code>, if specified. For longitudinal treatments, can be a list of allowable arguments, one for each time point.</p>
</td></tr>
<tr><td><code id="bal.tab.ebalance_+3A_continuous">continuous</code></td>
<td>
<p>whether mean differences for continuous variables should be standardized (<code>"std"</code>) or raw (<code>"raw"</code>). Default <code>"std"</code>. Abbreviations allowed. This option can be set globally using <code><a href="#topic+set.cobalt.options">set.cobalt.options()</a></code>.</p>
</td></tr>
<tr><td><code id="bal.tab.ebalance_+3A_binary">binary</code></td>
<td>
<p>whether mean differences for binary variables (i.e., difference in proportion) should be standardized (<code>"std"</code>) or raw (<code>"raw"</code>). Default <code>"raw"</code>. Abbreviations allowed. This option can be set globally using <code><a href="#topic+set.cobalt.options">set.cobalt.options()</a></code>.</p>
</td></tr>
<tr><td><code id="bal.tab.ebalance_+3A_s.d.denom">s.d.denom</code></td>
<td>
<p><code>character</code>; how the denominator for standardized mean differences should be calculated, if requested. See <code><a href="#topic+col_w_smd">col_w_smd()</a></code> for allowable options. Abbreviations allowed. If not specified, will be set to <code>"treated"</code>.</p>
</td></tr>
<tr><td><code id="bal.tab.ebalance_+3A_thresholds">thresholds</code></td>
<td>
<p>a named vector of balance thresholds, where the name corresponds to the statistic (i.e., in <code>stats</code>) that the threshold applies to. For example, to request thresholds on mean differences and variance ratios, one can set <code>thresholds = c(m = .05, v = 2)</code>. Requesting a threshold automatically requests the display of that statistic. When specified, extra columns are inserted into the Balance table describing whether the requested balance statistics exceeded the threshold or not. Summary tables tallying the number of variables that exceeded and were within the threshold and displaying the variables with the greatest imbalance on that balance measure are added to the output.</p>
</td></tr>
<tr><td><code id="bal.tab.ebalance_+3A_weights">weights</code></td>
<td>
<p>a vector, list, or <code>data.frame</code> containing weights for each unit, or a string containing the names of the weights variables in <code>data</code>, or an object with a <code><a href="#topic+get.w">get.w()</a></code> method or a list thereof. The weights can be, e.g., inverse probability weights or matching weights resulting from a matching algorithm.</p>
</td></tr>
<tr><td><code id="bal.tab.ebalance_+3A_cluster">cluster</code></td>
<td>
<p>either a vector containing cluster membership for each unit or a string containing the name of the cluster membership variable in <code>data</code> or the input object. See <code><a href="#topic+class-bal.tab.cluster">class-bal.tab.cluster</a></code> for details.</p>
</td></tr>
<tr><td><code id="bal.tab.ebalance_+3A_imp">imp</code></td>
<td>
<p>either a vector containing imputation indices for each unit or a string containing the name of the imputation index variable in <code>data</code> or the input object. See <code><a href="#topic+class-bal.tab.imp">class-bal.tab.imp</a></code> for details. Not necessary if <code>data</code> is a <code>mids</code> object.</p>
</td></tr>
<tr><td><code id="bal.tab.ebalance_+3A_pairwise">pairwise</code></td>
<td>
<p>whether balance should be computed for pairs of treatments or for each treatment against all groups combined. See <code><a href="#topic+class-bal.tab.multi">bal.tab.multi()</a></code> for details. This can also be used with a binary treatment to assess balance with respect to the full sample.</p>
</td></tr>
<tr><td><code id="bal.tab.ebalance_+3A_s.weights">s.weights</code></td>
<td>
<p>Optional; either a vector containing sampling weights for each unit or a string containing the name of the sampling weight variable in <code>data</code>. These function like regular weights except that both the adjusted and unadjusted samples will be weighted according to these weights if weights are used.</p>
</td></tr>
<tr><td><code id="bal.tab.ebalance_+3A_abs">abs</code></td>
<td>
<p><code>logical</code>; whether displayed balance statistics should be in absolute value or not.</p>
</td></tr>
<tr><td><code id="bal.tab.ebalance_+3A_subset">subset</code></td>
<td>
<p>a <code>logical</code> or <code>numeric</code> vector denoting whether each observation should be included or which observations should be included. If <code>logical</code>, it should have length equal to the number of units. <code>NA</code>s will be treated as <code>FALSE</code>. This can be used as an alternative to <code>cluster</code> to examine balance on subsets of the data.</p>
</td></tr>
<tr><td><code id="bal.tab.ebalance_+3A_quick">quick</code></td>
<td>
<p><code>logical</code>; if <code>TRUE</code>, will not compute any values that will not be displayed. Set to <code>FALSE</code> if computed values not displayed will be used later.</p>
</td></tr>
<tr><td><code id="bal.tab.ebalance_+3A_...">...</code></td>
<td>
<p>for some input types, other arguments that are required or allowed. Otherwise, further arguments to control display of output. See <a href="#topic+display-options">display options</a> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bal.tab()</code> generates a list of balance summaries for the object given. The input to <code>bal.tab.ebalance()</code> must include either both <code>formula</code> and <code>data</code> or both <code>covs</code> and <code>treat</code>.
</p>


<h3>Value</h3>

<p>If clusters and imputations are not specified, an object of class <code>"bal.tab"</code> containing balance summaries for the given object. See <code><a href="#topic+bal.tab">bal.tab()</a></code> for details.
</p>
<p>If clusters are specified, an object of class <code>"bal.tab.cluster"</code> containing balance summaries within each cluster and a summary of balance across clusters. See <code><a href="#topic+class-bal.tab.cluster">class-bal.tab.cluster</a></code> for details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bal.tab">bal.tab()</a></code> for details of calculations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("lalonde", package = "cobalt")

covs &lt;- subset(lalonde, select = -c(re78, treat))
covs0 &lt;- splitfactor(covs)

e.out &lt;- ebal::ebalance(lalonde$treat, covs0)

## Using formula and data
bal.tab(e.out, formula = treat ~ age + educ + race +
            married + nodegree + re74 + re75,
        data = lalonde)

## Using treat and covs
bal.tab(e.out, treat = lalonde$treat, covs = covs)

</code></pre>

<hr>
<h2 id='bal.tab.formula'>Balance Statistics for Data Sets</h2><span id='topic+bal.tab.formula'></span><span id='topic+bal.tab.data.frame'></span><span id='topic+bal.tab.matrix'></span>

<h3>Description</h3>

<p>Generates balance statistics for unadjusted, matched, weighted, or stratified data using either a <code>data.frame</code> or formula interface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
bal.tab(
  x,
  data = NULL,
  stats,
  int = FALSE,
  poly = 1,
  distance = NULL,
  addl = NULL,
  continuous,
  binary,
  s.d.denom,
  thresholds = NULL,
  weights = NULL,
  cluster = NULL,
  imp = NULL,
  pairwise = TRUE,
  s.weights = NULL,
  abs = FALSE,
  subset = NULL,
  quick = TRUE,
  subclass = NULL,
  match.strata = NULL,
  method,
  estimand = NULL,
  focal = NULL,
  ...
)

## S3 method for class 'data.frame'
bal.tab(
  x,
  treat,
  stats,
  int = FALSE,
  poly = 1,
  distance = NULL,
  addl = NULL,
  data = NULL,
  continuous,
  binary,
  s.d.denom,
  thresholds = NULL,
  weights = NULL,
  cluster = NULL,
  imp = NULL,
  pairwise = TRUE,
  s.weights = NULL,
  abs = FALSE,
  subset = NULL,
  quick = TRUE,
  subclass = NULL,
  match.strata = NULL,
  method,
  estimand = NULL,
  focal = NULL,
  ...
)

## S3 method for class 'matrix'
bal.tab(
  x,
  treat,
  stats,
  int = FALSE,
  poly = 1,
  distance = NULL,
  addl = NULL,
  data = NULL,
  continuous,
  binary,
  s.d.denom,
  thresholds = NULL,
  weights = NULL,
  cluster = NULL,
  imp = NULL,
  pairwise = TRUE,
  s.weights = NULL,
  abs = FALSE,
  subset = NULL,
  quick = TRUE,
  subclass = NULL,
  match.strata = NULL,
  method,
  estimand = NULL,
  focal = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bal.tab.formula_+3A_x">x</code></td>
<td>
<p>either a <code>data.frame</code> containing covariate values for each unit or a <code>formula</code> with the treatment variable as the response and the covariates for which balance is to be assessed as the terms. If a formula is supplied, all terms must be present as variable names in <code>data</code> or the global environment.</p>
</td></tr>
<tr><td><code id="bal.tab.formula_+3A_data">data</code></td>
<td>
<p>an optional data frame containing variables named in other arguments. For some input object types, this is required.</p>
</td></tr>
<tr><td><code id="bal.tab.formula_+3A_stats">stats</code></td>
<td>
<p><code>character</code>; which statistic(s) should be reported. See <code><a href="#topic+balance-statistics">stats</a></code> for allowable options. For binary and multi-category treatments, <code>"mean.diffs"</code> (i.e., mean differences) is the default. For continuous treatments, <code>"correlations"</code> (i.e., treatment-covariate Pearson correlations) is the default. Multiple options are allowed.</p>
</td></tr>
<tr><td><code id="bal.tab.formula_+3A_int">int</code></td>
<td>
<p><code>logical</code> or <code>numeric</code>; whether or not to include 2-way interactions of covariates included in <code>covs</code> and in <code>addl</code>. If <code>numeric</code>, will be passed to <code>poly</code> as well.</p>
</td></tr>
<tr><td><code id="bal.tab.formula_+3A_poly">poly</code></td>
<td>
<p><code>numeric</code>; the highest polynomial of each continuous covariate to display. For example, if 2, squares of each continuous covariate will be displayed (in addition to the covariate itself); if 3, squares and cubes of each continuous covariate will be displayed, etc. If 1, the default, only the base covariate will be displayed. If <code>int</code> is numeric, <code>poly</code> will take on the value of <code>int</code>.</p>
</td></tr>
<tr><td><code id="bal.tab.formula_+3A_distance">distance</code></td>
<td>
<p>an optional formula or data frame containing distance values (e.g., propensity scores) or a character vector containing their names. If a formula or variable names are specified, <code>bal.tab()</code> will look in the argument to <code>data</code>, if specified. For longitudinal treatments, can be a list of allowable arguments, one for each time point.</p>
</td></tr>
<tr><td><code id="bal.tab.formula_+3A_addl">addl</code></td>
<td>
<p>an optional formula or data frame containing additional covariates for which to present balance or a character vector containing their names. If a formula or variable names are specified, <code>bal.tab()</code> will look in the arguments to the input object, <code>covs</code>, and <code>data</code>, if specified. For longitudinal treatments, can be a list of allowable arguments, one for each time point.</p>
</td></tr>
<tr><td><code id="bal.tab.formula_+3A_continuous">continuous</code></td>
<td>
<p>whether mean differences for continuous variables should be standardized (<code>"std"</code>) or raw (<code>"raw"</code>). Default <code>"std"</code>. Abbreviations allowed. This option can be set globally using <code><a href="#topic+set.cobalt.options">set.cobalt.options()</a></code>.</p>
</td></tr>
<tr><td><code id="bal.tab.formula_+3A_binary">binary</code></td>
<td>
<p>whether mean differences for binary variables (i.e., difference in proportion) should be standardized (<code>"std"</code>) or raw (<code>"raw"</code>). Default <code>"raw"</code>. Abbreviations allowed. This option can be set globally using <code><a href="#topic+set.cobalt.options">set.cobalt.options()</a></code>.</p>
</td></tr>
<tr><td><code id="bal.tab.formula_+3A_s.d.denom">s.d.denom</code></td>
<td>
<p><code>character</code>; how the denominator for standardized mean differences should be calculated, if requested. See <code><a href="#topic+col_w_smd">col_w_smd()</a></code> for allowable options. Abbreviations allowed. If weights are supplied, each set of weights should have a corresponding entry to <code>s.d.denom</code>; a single entry will be recycled to all sets of weights. If left blank and one of <code>weights</code>, <code>subclass</code>, or <code>match.strata</code> are supplied, <code>bal.tab()</code> will figure out which one is best based on <code>estimand</code>, if given (for ATT, <code>"treated"</code>; for ATC, <code>"control"</code>; otherwise &quot;pooled&quot;) and other clues if not.</p>
</td></tr>
<tr><td><code id="bal.tab.formula_+3A_thresholds">thresholds</code></td>
<td>
<p>a named vector of balance thresholds, where the name corresponds to the statistic (i.e., in <code>stats</code>) that the threshold applies to. For example, to request thresholds on mean differences and variance ratios, one can set <code>thresholds = c(m = .05, v = 2)</code>. Requesting a threshold automatically requests the display of that statistic. When specified, extra columns are inserted into the Balance table describing whether the requested balance statistics exceeded the threshold or not. Summary tables tallying the number of variables that exceeded and were within the threshold and displaying the variables with the greatest imbalance on that balance measure are added to the output.</p>
</td></tr>
<tr><td><code id="bal.tab.formula_+3A_weights">weights</code></td>
<td>
<p>a vector, list, or <code>data.frame</code> containing weights for each unit, or a string containing the names of the weights variables in <code>data</code>, or an object with a <code><a href="#topic+get.w">get.w()</a></code> method or a list thereof. The weights can be, e.g., inverse probability weights or matching weights resulting from a matching algorithm.</p>
</td></tr>
<tr><td><code id="bal.tab.formula_+3A_cluster">cluster</code></td>
<td>
<p>either a vector containing cluster membership for each unit or a string containing the name of the cluster membership variable in <code>data</code> or the input object. See <code><a href="#topic+class-bal.tab.cluster">class-bal.tab.cluster</a></code> for details.</p>
</td></tr>
<tr><td><code id="bal.tab.formula_+3A_imp">imp</code></td>
<td>
<p>either a vector containing imputation indices for each unit or a string containing the name of the imputation index variable in <code>data</code> or the input object. See <code><a href="#topic+class-bal.tab.imp">class-bal.tab.imp</a></code> for details. Not necessary if <code>data</code> is a <code>mids</code> object.</p>
</td></tr>
<tr><td><code id="bal.tab.formula_+3A_pairwise">pairwise</code></td>
<td>
<p>whether balance should be computed for pairs of treatments or for each treatment against all groups combined. See <code><a href="#topic+class-bal.tab.multi">bal.tab.multi()</a></code> for details. This can also be used with a binary treatment to assess balance with respect to the full sample.</p>
</td></tr>
<tr><td><code id="bal.tab.formula_+3A_s.weights">s.weights</code></td>
<td>
<p>Optional; either a vector containing sampling weights for each unit or a string containing the name of the sampling weight variable in <code>data</code>. These function like regular weights except that both the adjusted and unadjusted samples will be weighted according to these weights if weights are used.</p>
</td></tr>
<tr><td><code id="bal.tab.formula_+3A_abs">abs</code></td>
<td>
<p><code>logical</code>; whether displayed balance statistics should be in absolute value or not.</p>
</td></tr>
<tr><td><code id="bal.tab.formula_+3A_subset">subset</code></td>
<td>
<p>a <code>logical</code> or <code>numeric</code> vector denoting whether each observation should be included or which observations should be included. If <code>logical</code>, it should have length equal to the number of units. <code>NA</code>s will be treated as <code>FALSE</code>. This can be used as an alternative to <code>cluster</code> to examine balance on subsets of the data.</p>
</td></tr>
<tr><td><code id="bal.tab.formula_+3A_quick">quick</code></td>
<td>
<p><code>logical</code>; if <code>TRUE</code>, will not compute any values that will not be displayed. Set to <code>FALSE</code> if computed values not displayed will be used later.</p>
</td></tr>
<tr><td><code id="bal.tab.formula_+3A_subclass">subclass</code></td>
<td>
<p>optional; either a vector containing subclass membership for each unit or a string containing the name of the subclass variable in <code>data</code>.</p>
</td></tr>
<tr><td><code id="bal.tab.formula_+3A_match.strata">match.strata</code></td>
<td>
<p>optional; either a vector containing matching stratum membership for each unit or a string containing the name of the matching stratum variable in <code>data</code>. See Details.</p>
</td></tr>
<tr><td><code id="bal.tab.formula_+3A_method">method</code></td>
<td>
<p><code>character</code>; the method of adjustment, if any. If <code>weights</code> are specified, the user can specify either &quot;matching&quot; or &quot;weighting&quot;; &quot;weighting&quot; is the default. If multiple sets of weights are used, each must have a corresponding value for <code>method</code>, but if they are all of the same type, only one value is required. If <code>subclass</code> is specified, &quot;subclassification&quot; is the default. Abbreviations allowed. The only distinction between &quot;matching&quot; and &quot;weighting&quot; is how sample sizes are displayed.</p>
</td></tr>
<tr><td><code id="bal.tab.formula_+3A_estimand">estimand</code></td>
<td>
<p><code>character</code>; whether the desired estimand is the &quot;ATT&quot;, &quot;ATC&quot;, or &quot;ATE&quot; for each set of weights. This argument can be used in place of <code>s.d.denom</code> to specify how standardized differences are calculated.</p>
</td></tr>
<tr><td><code id="bal.tab.formula_+3A_focal">focal</code></td>
<td>
<p>the name of the focal treatment when multi-category treatments are used. See <code><a href="#topic+class-bal.tab.multi">bal.tab.multi()</a></code> for details.</p>
</td></tr>
<tr><td><code id="bal.tab.formula_+3A_...">...</code></td>
<td>
<p>for some input types, other arguments that are required or allowed. Otherwise, further arguments to control display of output. See <a href="#topic+display-options">display options</a> for details.</p>
</td></tr>
<tr><td><code id="bal.tab.formula_+3A_treat">treat</code></td>
<td>
<p>either a vector containing treatment status values for each unit or a string containing the name of the treatment variable in <code>data</code>. Required for the <code>data.frame</code> method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bal.tab.data.frame()</code> generates a list of balance summaries for the covariates and treatment status values given. <code>bal.tab.formula()</code> does the same but uses a formula interface instead.  When the formula interface is used, the formula and data are reshaped into a treatment vector and <code>data.frame</code> of covariates and then simply passed through the <code>data.frame</code> method.
</p>
<p>If <code>weights</code>, <code>subclass</code> and <code>match.strata</code> are all <code>NULL</code>, balance information will be presented only for the unadjusted sample.
</p>
<p>The argument to <code>match.strata</code> corresponds to a factor vector containing the name or index of each pair/stratum for units conditioned through matching, for example, using the <span class="pkg">optmatch</span> package. If more than one of <code>weights</code>, <code>subclass</code>, or <code>match.strata</code> are specified, <code>bal.tab()</code> will attempt to figure out which one to apply. Currently only one of these can be applied ta a time. <code>bal.tab()</code> behaves differently depending on whether subclasses are used in conditioning or not. If they are used, <code>bal.tab()</code> creates balance statistics for each subclass and for the sample in aggregate. See <code><a href="#topic+class-bal.tab.subclass">class-bal.tab.subclass</a></code> for more information.
</p>
<p>Multiple sets of weights can be supplied simultaneously by entering a <code>data.frame</code> or a character vector containing the names of weight variables found in <code>data</code> or a list of weights vectors or names. The arguments to <code>method</code>, <code>s.d.denom</code>, and <code>estimand</code>, if any, must be either the same length as the number of sets of weights or of length one, where the sole entry is applied to all sets. When standardized differences are computed for the unadjusted group, they are done using the first entry to <code>s.d.denom</code> or <code>estimand</code>. When only one set of weights is supplied, the output for the adjusted group will simply be called <code>"Adj"</code>, but otherwise will be named after each corresponding set of weights. Specifying multiple sets of weights will also add components to other outputs of <code>bal.tab()</code>.
</p>


<h3>Value</h3>

<p>For point treatments, if clusters and imputations are not specified, an object of class <code>"bal.tab"</code> containing balance summaries for the specified treatment and covariates. See <code><a href="#topic+bal.tab">bal.tab()</a></code> for details.
</p>
<p>If imputations are specified, an object of class <code>"bal.tab.imp"</code> containing balance summaries for each imputation and a summary of balance across imputations. See <code><a href="#topic+class-bal.tab.imp">class-bal.tab.imp</a></code> for details.
</p>
<p>If multi-category treatments are used, an object of class <code>"bal.tab.multi"</code> containing balance summaries for each pairwise treatment comparison. See <code><a href="#topic+class-bal.tab.multi">bal.tab.multi()</a></code> for details.
</p>
<p>If clusters are specified, an object of class <code>"bal.tab.cluster"</code> containing balance summaries within each cluster and a summary of balance across clusters. See <code><a href="#topic+class-bal.tab.cluster">class-bal.tab.cluster</a></code> for details.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+bal.tab">bal.tab()</a></code> for details of calculations.
</p>
</li>
<li> <p><code><a href="#topic+class-bal.tab.cluster">class-bal.tab.cluster</a></code> for more information on clustered data.
</p>
</li>
<li> <p><code><a href="#topic+class-bal.tab.imp">class-bal.tab.imp</a></code> for more information on multiply imputed data.
</p>
</li>
<li> <p><code><a href="#topic+class-bal.tab.multi">bal.tab.multi()</a></code> for more information on multi-category treatments.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data("lalonde", package = "cobalt")
lalonde$p.score &lt;- glm(treat ~ age + educ + race, data = lalonde, 
                       family = "binomial")$fitted.values
covariates &lt;- subset(lalonde, select = c(age, educ, race))

## Propensity score weighting using IPTW
lalonde$iptw.weights &lt;- ifelse(lalonde$treat==1, 
                               1/lalonde$p.score, 
                               1/(1-lalonde$p.score))

# data frame interface:
bal.tab(covariates, treat = "treat", data = lalonde, 
        weights = "iptw.weights", s.d.denom = "pooled")

# Formula interface:
bal.tab(treat ~ age + educ + race, data = lalonde, 
        weights = "iptw.weights", s.d.denom = "pooled")

## Propensity score subclassification
lalonde$subclass &lt;- findInterval(lalonde$p.score, 
                                 quantile(lalonde$p.score, 
                                          (0:6)/6), all.inside = TRUE)

# data frame interface:
bal.tab(covariates, treat = "treat", data = lalonde, 
        subclass = "subclass", disp.subclass = TRUE, 
        s.d.denom = "pooled")

# Formula interface:
bal.tab(treat ~ age + educ + race, data = lalonde, 
        subclass = "subclass", disp.subclass = TRUE, 
        s.d.denom = "pooled")
</code></pre>

<hr>
<h2 id='bal.tab.Match'>Balance Statistics for <code>Matching</code> Objects</h2><span id='topic+bal.tab.Match'></span>

<h3>Description</h3>

<p>Generates balance statistics for output objects from <span class="pkg">Matching</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Match'
bal.tab(
  x,
  formula = NULL,
  data = NULL,
  treat = NULL,
  covs = NULL,
  stats,
  int = FALSE,
  poly = 1,
  distance = NULL,
  addl = NULL,
  continuous,
  binary,
  s.d.denom,
  thresholds = NULL,
  weights = NULL,
  cluster = NULL,
  imp = NULL,
  pairwise = TRUE,
  s.weights = NULL,
  abs = FALSE,
  subset = NULL,
  quick = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bal.tab.Match_+3A_x">x</code></td>
<td>
<p>a <code>Match</code> object (the output of a call to <code><a href="Matching.html#topic+Match">Matching::Match()</a></code> or <code><a href="Matching.html#topic+Matchby">Matching::Matchby()</a></code>).</p>
</td></tr>
<tr><td><code id="bal.tab.Match_+3A_formula">formula</code></td>
<td>
<p>a <code>formula</code> with the treatment variable as the response and the covariates for which balance is to be assessed as the predictors. All named variables must be in <code>data</code>. See Details.</p>
</td></tr>
<tr><td><code id="bal.tab.Match_+3A_data">data</code></td>
<td>
<p>a data frame containing variables named in <code>formula</code>, if supplied, and other arguments.</p>
</td></tr>
<tr><td><code id="bal.tab.Match_+3A_treat">treat</code></td>
<td>
<p>a vector of treatment statuses. See Details.</p>
</td></tr>
<tr><td><code id="bal.tab.Match_+3A_covs">covs</code></td>
<td>
<p>a data frame of covariate values for which to check balance. See Details.</p>
</td></tr>
<tr><td><code id="bal.tab.Match_+3A_stats">stats</code></td>
<td>
<p><code>character</code>; which statistic(s) should be reported. See <code><a href="#topic+balance-statistics">stats</a></code> for allowable options. For binary and multi-category treatments, <code>"mean.diffs"</code> (i.e., mean differences) is the default. For continuous treatments, <code>"correlations"</code> (i.e., treatment-covariate Pearson correlations) is the default. Multiple options are allowed.</p>
</td></tr>
<tr><td><code id="bal.tab.Match_+3A_int">int</code></td>
<td>
<p><code>logical</code> or <code>numeric</code>; whether or not to include 2-way interactions of covariates included in <code>covs</code> and in <code>addl</code>. If <code>numeric</code>, will be passed to <code>poly</code> as well.</p>
</td></tr>
<tr><td><code id="bal.tab.Match_+3A_poly">poly</code></td>
<td>
<p><code>numeric</code>; the highest polynomial of each continuous covariate to display. For example, if 2, squares of each continuous covariate will be displayed (in addition to the covariate itself); if 3, squares and cubes of each continuous covariate will be displayed, etc. If 1, the default, only the base covariate will be displayed. If <code>int</code> is numeric, <code>poly</code> will take on the value of <code>int</code>.</p>
</td></tr>
<tr><td><code id="bal.tab.Match_+3A_distance">distance</code></td>
<td>
<p>an optional formula or data frame containing distance values (e.g., propensity scores) or a character vector containing their names. If a formula or variable names are specified, <code>bal.tab()</code> will look in the argument to <code>data</code>, if specified. For longitudinal treatments, can be a list of allowable arguments, one for each time point.</p>
</td></tr>
<tr><td><code id="bal.tab.Match_+3A_addl">addl</code></td>
<td>
<p>an optional formula or data frame containing additional covariates for which to present balance or a character vector containing their names. If a formula or variable names are specified, <code>bal.tab()</code> will look in the arguments to the input object, <code>covs</code>, and <code>data</code>, if specified. For longitudinal treatments, can be a list of allowable arguments, one for each time point.</p>
</td></tr>
<tr><td><code id="bal.tab.Match_+3A_continuous">continuous</code></td>
<td>
<p>whether mean differences for continuous variables should be standardized (<code>"std"</code>) or raw (<code>"raw"</code>). Default <code>"std"</code>. Abbreviations allowed. This option can be set globally using <code><a href="#topic+set.cobalt.options">set.cobalt.options()</a></code>.</p>
</td></tr>
<tr><td><code id="bal.tab.Match_+3A_binary">binary</code></td>
<td>
<p>whether mean differences for binary variables (i.e., difference in proportion) should be standardized (<code>"std"</code>) or raw (<code>"raw"</code>). Default <code>"raw"</code>. Abbreviations allowed. This option can be set globally using <code><a href="#topic+set.cobalt.options">set.cobalt.options()</a></code>.</p>
</td></tr>
<tr><td><code id="bal.tab.Match_+3A_s.d.denom">s.d.denom</code></td>
<td>
<p><code>character</code>; how the denominator for standardized mean differences should be calculated, if requested. See <code><a href="#topic+col_w_smd">col_w_smd()</a></code> for allowable options. Abbreviations allowed. If not specified, <code>bal.tab()</code> will use &quot;treated&quot; if the estimand of the call to <code>Match()</code> is the ATT, &quot;pooled&quot; if the estimand is the ATE, and &quot;control&quot; if the estimand is the ATC.</p>
</td></tr>
<tr><td><code id="bal.tab.Match_+3A_thresholds">thresholds</code></td>
<td>
<p>a named vector of balance thresholds, where the name corresponds to the statistic (i.e., in <code>stats</code>) that the threshold applies to. For example, to request thresholds on mean differences and variance ratios, one can set <code>thresholds = c(m = .05, v = 2)</code>. Requesting a threshold automatically requests the display of that statistic. When specified, extra columns are inserted into the Balance table describing whether the requested balance statistics exceeded the threshold or not. Summary tables tallying the number of variables that exceeded and were within the threshold and displaying the variables with the greatest imbalance on that balance measure are added to the output.</p>
</td></tr>
<tr><td><code id="bal.tab.Match_+3A_weights">weights</code></td>
<td>
<p>a vector, list, or <code>data.frame</code> containing weights for each unit, or a string containing the names of the weights variables in <code>data</code>, or an object with a <code><a href="#topic+get.w">get.w()</a></code> method or a list thereof. The weights can be, e.g., inverse probability weights or matching weights resulting from a matching algorithm.</p>
</td></tr>
<tr><td><code id="bal.tab.Match_+3A_cluster">cluster</code></td>
<td>
<p>either a vector containing cluster membership for each unit or a string containing the name of the cluster membership variable in <code>data</code> or the input object. See <code><a href="#topic+class-bal.tab.cluster">class-bal.tab.cluster</a></code> for details.</p>
</td></tr>
<tr><td><code id="bal.tab.Match_+3A_imp">imp</code></td>
<td>
<p>either a vector containing imputation indices for each unit or a string containing the name of the imputation index variable in <code>data</code> or the input object. See <code><a href="#topic+class-bal.tab.imp">class-bal.tab.imp</a></code> for details. Not necessary if <code>data</code> is a <code>mids</code> object.</p>
</td></tr>
<tr><td><code id="bal.tab.Match_+3A_pairwise">pairwise</code></td>
<td>
<p>whether balance should be computed for pairs of treatments or for each treatment against all groups combined. See <code><a href="#topic+class-bal.tab.multi">bal.tab.multi()</a></code> for details. This can also be used with a binary treatment to assess balance with respect to the full sample.</p>
</td></tr>
<tr><td><code id="bal.tab.Match_+3A_s.weights">s.weights</code></td>
<td>
<p>Optional; either a vector containing sampling weights for each unit or a string containing the name of the sampling weight variable in <code>data</code>. These function like regular weights except that both the adjusted and unadjusted samples will be weighted according to these weights if weights are used.</p>
</td></tr>
<tr><td><code id="bal.tab.Match_+3A_abs">abs</code></td>
<td>
<p><code>logical</code>; whether displayed balance statistics should be in absolute value or not.</p>
</td></tr>
<tr><td><code id="bal.tab.Match_+3A_subset">subset</code></td>
<td>
<p>a <code>logical</code> or <code>numeric</code> vector denoting whether each observation should be included or which observations should be included. If <code>logical</code>, it should have length equal to the number of units. <code>NA</code>s will be treated as <code>FALSE</code>. This can be used as an alternative to <code>cluster</code> to examine balance on subsets of the data.</p>
</td></tr>
<tr><td><code id="bal.tab.Match_+3A_quick">quick</code></td>
<td>
<p><code>logical</code>; if <code>TRUE</code>, will not compute any values that will not be displayed. Set to <code>FALSE</code> if computed values not displayed will be used later.</p>
</td></tr>
<tr><td><code id="bal.tab.Match_+3A_...">...</code></td>
<td>
<p>for some input types, other arguments that are required or allowed. Otherwise, further arguments to control display of output. See <a href="#topic+display-options">display options</a> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bal.tab()</code> generates a list of balance summaries for the object given, and functions similarly to <code><a href="Matching.html#topic+MatchBalance">Matching::MatchBalance()</a></code>. The input to <code>bal.tab.Match()</code> must include either both <code>formula</code> and <code>data</code> or both <code>covs</code> and <code>treat</code>. Using the <code>formula</code> + <code>data</code> inputs mirrors how <code><a href="Matching.html#topic+MatchBalance">Matching::MatchBalance()</a></code> is used.
</p>
<p><code>cobalt</code> functions do not support <code>Match</code> object with sampling weights, i.e., with an argument passed to the <code>weights</code> argument of <code>Matching::Match()</code>.
</p>


<h3>Value</h3>

<p>If clusters and imputations are not specified, an object of class <code>"bal.tab"</code> containing balance summaries for the given object. See <code><a href="#topic+bal.tab">bal.tab()</a></code> for details.
</p>
<p>If clusters are specified, an object of class <code>"bal.tab.cluster"</code> containing balance summaries within each cluster and a summary of balance across clusters. See <code><a href="#topic+class-bal.tab.cluster">class-bal.tab.cluster</a></code> for details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bal.tab">bal.tab()</a></code> for details of calculations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(Matching); data("lalonde", package = "cobalt")

p.score &lt;- glm(treat ~ age + educ + race + 
                   married + nodegree + re74 + re75, 
               data = lalonde, family = "binomial")$fitted.values
Match.out &lt;- Match(Tr = lalonde$treat, X = p.score)

## Using formula and data
bal.tab(Match.out, formula = treat ~ age + educ + race + 
            married + nodegree + re74 + re75, data = lalonde)

</code></pre>

<hr>
<h2 id='bal.tab.matchit'>Balance Statistics for <code>MatchIt</code> Objects</h2><span id='topic+bal.tab.matchit'></span>

<h3>Description</h3>

<p>Generates balance statistics for <code>matchit</code> objects from <span class="pkg">MatchIt</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'matchit'
bal.tab(
  x,
  stats,
  int = FALSE,
  poly = 1,
  distance = NULL,
  addl = NULL,
  data = NULL,
  continuous,
  binary,
  s.d.denom,
  thresholds = NULL,
  weights = NULL,
  cluster = NULL,
  imp = NULL,
  pairwise = TRUE,
  s.weights = NULL,
  abs = FALSE,
  subset = NULL,
  quick = TRUE,
  method,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bal.tab.matchit_+3A_x">x</code></td>
<td>
<p>a <code>matchit</code> object; the output of a call to <code><a href="MatchIt.html#topic+matchit">MatchIt::matchit()</a></code>.</p>
</td></tr>
<tr><td><code id="bal.tab.matchit_+3A_stats">stats</code></td>
<td>
<p><code>character</code>; which statistic(s) should be reported. See <code><a href="#topic+balance-statistics">stats</a></code> for allowable options. For binary and multi-category treatments, <code>"mean.diffs"</code> (i.e., mean differences) is the default. For continuous treatments, <code>"correlations"</code> (i.e., treatment-covariate Pearson correlations) is the default. Multiple options are allowed.</p>
</td></tr>
<tr><td><code id="bal.tab.matchit_+3A_int">int</code></td>
<td>
<p><code>logical</code> or <code>numeric</code>; whether or not to include 2-way interactions of covariates included in <code>covs</code> and in <code>addl</code>. If <code>numeric</code>, will be passed to <code>poly</code> as well.</p>
</td></tr>
<tr><td><code id="bal.tab.matchit_+3A_poly">poly</code></td>
<td>
<p><code>numeric</code>; the highest polynomial of each continuous covariate to display. For example, if 2, squares of each continuous covariate will be displayed (in addition to the covariate itself); if 3, squares and cubes of each continuous covariate will be displayed, etc. If 1, the default, only the base covariate will be displayed. If <code>int</code> is numeric, <code>poly</code> will take on the value of <code>int</code>.</p>
</td></tr>
<tr><td><code id="bal.tab.matchit_+3A_distance">distance</code></td>
<td>
<p>an optional formula or data frame containing distance values (e.g., propensity scores) or a character vector containing their names. If a formula or variable names are specified, <code>bal.tab()</code> will look in the argument to <code>data</code>, if specified. The distance measure (e.g., propensity score) generated by <code>matchit()</code> is automatically included and named &quot;distance&quot;.</p>
</td></tr>
<tr><td><code id="bal.tab.matchit_+3A_addl">addl</code></td>
<td>
<p>an optional formula or data frame containing additional covariates for which to present balance or a character vector containing their names. If a formula or variable names are specified, <code>bal.tab()</code> will look in the arguments to the input object, <code>covs</code>, and <code>data</code>, if specified. For longitudinal treatments, can be a list of allowable arguments, one for each time point.</p>
</td></tr>
<tr><td><code id="bal.tab.matchit_+3A_data">data</code></td>
<td>
<p>an optional data frame containing variables named in other arguments. For some input object types, this is required.</p>
</td></tr>
<tr><td><code id="bal.tab.matchit_+3A_continuous">continuous</code></td>
<td>
<p>whether mean differences for continuous variables should be standardized (<code>"std"</code>) or raw (<code>"raw"</code>). Default <code>"std"</code>. Abbreviations allowed. This option can be set globally using <code><a href="#topic+set.cobalt.options">set.cobalt.options()</a></code>.</p>
</td></tr>
<tr><td><code id="bal.tab.matchit_+3A_binary">binary</code></td>
<td>
<p>whether mean differences for binary variables (i.e., difference in proportion) should be standardized (<code>"std"</code>) or raw (<code>"raw"</code>). Default <code>"raw"</code>. Abbreviations allowed. This option can be set globally using <code><a href="#topic+set.cobalt.options">set.cobalt.options()</a></code>.</p>
</td></tr>
<tr><td><code id="bal.tab.matchit_+3A_s.d.denom">s.d.denom</code></td>
<td>
<p><code>character</code>; how the denominator for standardized mean differences should be calculated, if requested. See <code><a href="#topic+col_w_smd">col_w_smd()</a></code> for allowable options. Abbreviations allowed. If not specified, <code>bal.tab()</code> will figure out which one is best based on the estimand of the <code>matchit</code> object: if ATT, <code>"treated"</code>; if ATC, <code>"control"</code>, otherwise <code>"pooled"</code>.</p>
</td></tr>
<tr><td><code id="bal.tab.matchit_+3A_thresholds">thresholds</code></td>
<td>
<p>a named vector of balance thresholds, where the name corresponds to the statistic (i.e., in <code>stats</code>) that the threshold applies to. For example, to request thresholds on mean differences and variance ratios, one can set <code>thresholds = c(m = .05, v = 2)</code>. Requesting a threshold automatically requests the display of that statistic. When specified, extra columns are inserted into the Balance table describing whether the requested balance statistics exceeded the threshold or not. Summary tables tallying the number of variables that exceeded and were within the threshold and displaying the variables with the greatest imbalance on that balance measure are added to the output.</p>
</td></tr>
<tr><td><code id="bal.tab.matchit_+3A_weights">weights</code></td>
<td>
<p>a vector, list, or <code>data.frame</code> containing weights for each unit, or a string containing the names of the weights variables in <code>data</code>, or an object with a <code><a href="#topic+get.w">get.w()</a></code> method or a list thereof. The weights can be, e.g., inverse probability weights or matching weights resulting from a matching algorithm.</p>
</td></tr>
<tr><td><code id="bal.tab.matchit_+3A_cluster">cluster</code></td>
<td>
<p>either a vector containing cluster membership for each unit or a string containing the name of the cluster membership variable in <code>data</code> or the input object. See <code><a href="#topic+class-bal.tab.cluster">class-bal.tab.cluster</a></code> for details.</p>
</td></tr>
<tr><td><code id="bal.tab.matchit_+3A_imp">imp</code></td>
<td>
<p>either a vector containing imputation indices for each unit or a string containing the name of the imputation index variable in <code>data</code> or the input object. See <code><a href="#topic+class-bal.tab.imp">class-bal.tab.imp</a></code> for details. Not necessary if <code>data</code> is a <code>mids</code> object.</p>
</td></tr>
<tr><td><code id="bal.tab.matchit_+3A_pairwise">pairwise</code></td>
<td>
<p>whether balance should be computed for pairs of treatments or for each treatment against all groups combined. See <code><a href="#topic+class-bal.tab.multi">bal.tab.multi()</a></code> for details. This can also be used with a binary treatment to assess balance with respect to the full sample.</p>
</td></tr>
<tr><td><code id="bal.tab.matchit_+3A_s.weights">s.weights</code></td>
<td>
<p>Optional; either a vector containing sampling weights for each unit or a string containing the name of the sampling weight variable in <code>data</code>. These function like regular weights except that both the adjusted and unadjusted samples will be weighted according to these weights if weights are used. If <code>s.weights</code> was specified in the call to <code>matchit()</code>, they will automatically be included and do not need be specified again (though there is no harm if they are).</p>
</td></tr>
<tr><td><code id="bal.tab.matchit_+3A_abs">abs</code></td>
<td>
<p><code>logical</code>; whether displayed balance statistics should be in absolute value or not.</p>
</td></tr>
<tr><td><code id="bal.tab.matchit_+3A_subset">subset</code></td>
<td>
<p>a <code>logical</code> or <code>numeric</code> vector denoting whether each observation should be included or which observations should be included. If <code>logical</code>, it should have length equal to the number of units. <code>NA</code>s will be treated as <code>FALSE</code>. This can be used as an alternative to <code>cluster</code> to examine balance on subsets of the data.</p>
</td></tr>
<tr><td><code id="bal.tab.matchit_+3A_quick">quick</code></td>
<td>
<p><code>logical</code>; if <code>TRUE</code>, will not compute any values that will not be displayed. Set to <code>FALSE</code> if computed values not displayed will be used later.</p>
</td></tr>
<tr><td><code id="bal.tab.matchit_+3A_method">method</code></td>
<td>
<p>a character vector containing the method of adjustment. Ignored unless subclassification was used in the original call to <code>matchit()</code>. If <code>"weighting"</code>, the subclassification weights will be used and subclasses will be ignored. If <code>"subclassification"</code>, balance will be assessed using the subclasses (see <code><a href="#topic+class-bal.tab.subclass">class-bal.tab.subclass</a></code> for details). Abbreviations allowed.</p>
</td></tr>
<tr><td><code id="bal.tab.matchit_+3A_...">...</code></td>
<td>
<p>for some input types, other arguments that are required or allowed. Otherwise, further arguments to control display of output. See <a href="#topic+display-options">display options</a> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bal.tab.matchit()</code> generates a list of balance summaries for the <code>matchit</code> object given, and functions similarly to <code><a href="MatchIt.html#topic+summary.matchit">MatchIt::summary.matchit()</a></code>. <code>bal.tab()</code> behaves differently depending on whether subclasses are used in conditioning or not. If they are used, <code>bal.tab()</code> creates balance statistics for each subclass and for the sample in aggregate; see <code><a href="#topic+class-bal.tab.subclass">class-bal.tab.subclass</a></code> for more information.
</p>


<h3>Value</h3>

<p>If subclassification is used and <code>method</code> is set to <code>"subclassification"</code>, an object of class <code>"bal.tab.subclass"</code> containing balance summaries within and across subclasses. See <code><a href="#topic+class-bal.tab.subclass">class-bal.tab.subclass</a></code> for details.
</p>
<p>If matching is used and clusters are not specified, an object of class <code>"bal.tab"</code> containing balance summaries for the <code>matchit</code> object. See <code><a href="#topic+bal.tab">bal.tab()</a></code> for details.
</p>
<p>If clusters are specified, an object of class <code>"bal.tab.cluster"</code> containing balance summaries within each cluster and a summary of balance across clusters. See <code><a href="#topic+class-bal.tab.cluster">class-bal.tab.cluster</a></code> for details.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+bal.tab">bal.tab()</a></code> for details of calculations.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(MatchIt); data("lalonde", package = "cobalt")

## Nearest Neighbor matching
m.out1 &lt;- matchit(treat ~ age + educ + race + 
                      married + nodegree + re74 + re75, 
                  data = lalonde, method = "nearest")

bal.tab(m.out1, un = TRUE, m.threshold = .1, 
        v.threshold = 2)

## Subclassification
m.out2 &lt;- matchit(treat ~ age + educ + race + 
                      married + nodegree + re74 + re75, 
                  data = lalonde, method = "subclass")

bal.tab(m.out2, disp.subclass = TRUE)

</code></pre>

<hr>
<h2 id='bal.tab.mimids'>Balance Statistics for <code>MatchThem</code> Objects</h2><span id='topic+bal.tab.mimids'></span>

<h3>Description</h3>

<p>Generates balance statistics for <code>mimids</code> and <code>wimids</code> objects from <span class="pkg">MatchThem</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mimids'
bal.tab(
  x,
  stats,
  int = FALSE,
  poly = 1,
  distance = NULL,
  addl = NULL,
  data = NULL,
  continuous,
  binary,
  s.d.denom,
  thresholds = NULL,
  weights = NULL,
  cluster = NULL,
  pairwise = TRUE,
  s.weights = NULL,
  abs = FALSE,
  subset = NULL,
  quick = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bal.tab.mimids_+3A_x">x</code></td>
<td>
<p>a <code>mimids</code> or <code>wimids</code> object; the output of a call to <code><a href="MatchThem.html#topic+matchthem">MatchThem::matchthem()</a></code> or <code><a href="MatchThem.html#topic+weightthem">MatchThem::weightthem()</a></code>.</p>
</td></tr>
<tr><td><code id="bal.tab.mimids_+3A_stats">stats</code></td>
<td>
<p><code>character</code>; which statistic(s) should be reported. See <code><a href="#topic+balance-statistics">stats</a></code> for allowable options. For binary and multi-category treatments, <code>"mean.diffs"</code> (i.e., mean differences) is the default. For continuous treatments, <code>"correlations"</code> (i.e., treatment-covariate Pearson correlations) is the default. Multiple options are allowed.</p>
</td></tr>
<tr><td><code id="bal.tab.mimids_+3A_int">int</code></td>
<td>
<p><code>logical</code> or <code>numeric</code>; whether or not to include 2-way interactions of covariates included in <code>covs</code> and in <code>addl</code>. If <code>numeric</code>, will be passed to <code>poly</code> as well.</p>
</td></tr>
<tr><td><code id="bal.tab.mimids_+3A_poly">poly</code></td>
<td>
<p><code>numeric</code>; the highest polynomial of each continuous covariate to display. For example, if 2, squares of each continuous covariate will be displayed (in addition to the covariate itself); if 3, squares and cubes of each continuous covariate will be displayed, etc. If 1, the default, only the base covariate will be displayed. If <code>int</code> is numeric, <code>poly</code> will take on the value of <code>int</code>.</p>
</td></tr>
<tr><td><code id="bal.tab.mimids_+3A_distance">distance</code></td>
<td>
<p>an optional formula or data frame containing distance values (e.g., propensity scores) or a character vector containing their names. If a formula or variable names are specified, <code>bal.tab()</code> will look in the argument to <code>data</code>, if specified. The distance measure generated by <code>matchthem()</code> or <code>weightthem()</code> is automatically included and named &quot;distance&quot; or &quot;prop.score&quot;, respectively.</p>
</td></tr>
<tr><td><code id="bal.tab.mimids_+3A_addl">addl</code></td>
<td>
<p>an optional formula or data frame containing additional covariates for which to present balance or a character vector containing their names. If a formula or variable names are specified, <code>bal.tab()</code> will look in the arguments to the input object, <code>covs</code>, and <code>data</code>, if specified. For longitudinal treatments, can be a list of allowable arguments, one for each time point.</p>
</td></tr>
<tr><td><code id="bal.tab.mimids_+3A_data">data</code></td>
<td>
<p>an optional data frame containing variables named in other arguments. For some input object types, this is required.</p>
</td></tr>
<tr><td><code id="bal.tab.mimids_+3A_continuous">continuous</code></td>
<td>
<p>whether mean differences for continuous variables should be standardized (<code>"std"</code>) or raw (<code>"raw"</code>). Default <code>"std"</code>. Abbreviations allowed. This option can be set globally using <code><a href="#topic+set.cobalt.options">set.cobalt.options()</a></code>.</p>
</td></tr>
<tr><td><code id="bal.tab.mimids_+3A_binary">binary</code></td>
<td>
<p>whether mean differences for binary variables (i.e., difference in proportion) should be standardized (<code>"std"</code>) or raw (<code>"raw"</code>). Default <code>"raw"</code>. Abbreviations allowed. This option can be set globally using <code><a href="#topic+set.cobalt.options">set.cobalt.options()</a></code>.</p>
</td></tr>
<tr><td><code id="bal.tab.mimids_+3A_s.d.denom">s.d.denom</code></td>
<td>
<p><code>character</code>; how the denominator for standardized mean differences should be calculated, if requested. See <code><a href="#topic+col_w_smd">col_w_smd()</a></code> for allowable options. Abbreviations allowed. If not specified, the defaults depend on the options specified in the original function calls; see <code><a href="#topic+bal.tab.matchit">bal.tab.matchit()</a></code> and <code><a href="#topic+bal.tab.weightit">bal.tab.weightit()</a></code> for details on the defaults.</p>
</td></tr>
<tr><td><code id="bal.tab.mimids_+3A_thresholds">thresholds</code></td>
<td>
<p>a named vector of balance thresholds, where the name corresponds to the statistic (i.e., in <code>stats</code>) that the threshold applies to. For example, to request thresholds on mean differences and variance ratios, one can set <code>thresholds = c(m = .05, v = 2)</code>. Requesting a threshold automatically requests the display of that statistic. When specified, extra columns are inserted into the Balance table describing whether the requested balance statistics exceeded the threshold or not. Summary tables tallying the number of variables that exceeded and were within the threshold and displaying the variables with the greatest imbalance on that balance measure are added to the output.</p>
</td></tr>
<tr><td><code id="bal.tab.mimids_+3A_weights">weights</code></td>
<td>
<p>a vector, list, or <code>data.frame</code> containing weights for each unit, or a string containing the names of the weights variables in <code>data</code>, or an object with a <code><a href="#topic+get.w">get.w()</a></code> method or a list thereof. The weights can be, e.g., inverse probability weights or matching weights resulting from a matching algorithm.</p>
</td></tr>
<tr><td><code id="bal.tab.mimids_+3A_cluster">cluster</code></td>
<td>
<p>either a vector containing cluster membership for each unit or a string containing the name of the cluster membership variable in <code>data</code> or the input object. See <code><a href="#topic+class-bal.tab.cluster">class-bal.tab.cluster</a></code> for details.</p>
</td></tr>
<tr><td><code id="bal.tab.mimids_+3A_pairwise">pairwise</code></td>
<td>
<p>whether balance should be computed for pairs of treatments or for each treatment against all groups combined. See <code><a href="#topic+class-bal.tab.multi">bal.tab.multi()</a></code> for details. This can also be used with a binary treatment to assess balance with respect to the full sample.</p>
</td></tr>
<tr><td><code id="bal.tab.mimids_+3A_s.weights">s.weights</code></td>
<td>
<p>Optional; either a vector containing sampling weights for each unit or a string containing the name of the sampling weight variable in <code>data</code>. These function like regular weights except that both the adjusted and unadjusted samples will be weighted according to these weights if weights are used.</p>
</td></tr>
<tr><td><code id="bal.tab.mimids_+3A_abs">abs</code></td>
<td>
<p><code>logical</code>; whether displayed balance statistics should be in absolute value or not.</p>
</td></tr>
<tr><td><code id="bal.tab.mimids_+3A_subset">subset</code></td>
<td>
<p>a <code>logical</code> or <code>numeric</code> vector denoting whether each observation should be included or which observations should be included. If <code>logical</code>, it should have length equal to the number of units. <code>NA</code>s will be treated as <code>FALSE</code>. This can be used as an alternative to <code>cluster</code> to examine balance on subsets of the data.</p>
</td></tr>
<tr><td><code id="bal.tab.mimids_+3A_quick">quick</code></td>
<td>
<p><code>logical</code>; if <code>TRUE</code>, will not compute any values that will not be displayed. Set to <code>FALSE</code> if computed values not displayed will be used later.</p>
</td></tr>
<tr><td><code id="bal.tab.mimids_+3A_...">...</code></td>
<td>
<p>for some input types, other arguments that are required or allowed. Otherwise, further arguments to control display of output. See <a href="#topic+display-options">display options</a> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bal.tab.mimids()</code> and <code>bal.tab.wimids()</code> generate a list of balance summaries for the <code>mimids</code> or <code>wimids</code> object given.
</p>


<h3>Value</h3>

<p>If clusters are not specified, an object of class <code>"bal.tab.imp"</code> containing balance summaries for each imputation and a summary of balance across imputations. See <code><a href="#topic+class-bal.tab.imp">class-bal.tab.imp</a></code> for details.
</p>
<p>If clusters are specified, an object of class <code>"bal.tab.imp.cluster"</code> containing summaries between and across all clusters and imputations.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+bal.tab">bal.tab()</a></code> for details of calculations
</p>
</li>
<li> <p><code><a href="#topic+bal.tab.matchit">bal.tab.matchit()</a></code> and <code><a href="#topic+bal.tab.weightit">bal.tab.weightit()</a></code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(mice)
library(MatchThem)

data("lalonde_mis", package = "cobalt")

#Imputing the missing data
imp &lt;- mice(lalonde_mis, m = 5)

#Matching using within-imputation propensity scores
mt.out1 &lt;- matchthem(treat ~ age + educ + race + 
                         married + nodegree + re74 + re75, 
                     data = imp, approach = "within")
bal.tab(mt.out1)

#Matching using across-imputation average propensity scores
mt.out2 &lt;- matchthem(treat ~ age + educ + race + 
                         married + nodegree + re74 + re75, 
                     data = imp, approach = "across")

bal.tab(mt.out2)

#Weighting using within-imputation propensity scores
wt.out &lt;- weightthem(treat ~ age + educ + race + 
                         married + nodegree + re74 + re75, 
                     data = imp, approach = "within",
                     estimand = "ATT")

bal.tab(wt.out)

</code></pre>

<hr>
<h2 id='bal.tab.optmatch'>Balance Statistics for <code>optmatch</code> Objects</h2><span id='topic+bal.tab.optmatch'></span>

<h3>Description</h3>

<p>Generates balance statistics for output objects from <span class="pkg">optmatch</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'optmatch'
bal.tab(
  x,
  formula = NULL,
  data = NULL,
  treat = NULL,
  covs = NULL,
  estimand = NULL,
  stats,
  int = FALSE,
  poly = 1,
  distance = NULL,
  addl = NULL,
  continuous,
  binary,
  s.d.denom,
  thresholds = NULL,
  weights = NULL,
  cluster = NULL,
  imp = NULL,
  pairwise = TRUE,
  s.weights = NULL,
  abs = FALSE,
  subset = NULL,
  quick = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bal.tab.optmatch_+3A_x">x</code></td>
<td>
<p>an <code>optmatch</code> object (the output of a call to <code><a href="optmatch.html#topic+pairmatch">optmatch::pairmatch()</a></code> or <code><a href="optmatch.html#topic+fullmatch">optmatch::fullmatch()</a></code>).</p>
</td></tr>
<tr><td><code id="bal.tab.optmatch_+3A_formula">formula</code></td>
<td>
<p>a <code>formula</code> with the treatment variable as the response and the covariates for which balance is to be assessed as the predictors. All named variables must be in <code>data</code>. See Details.</p>
</td></tr>
<tr><td><code id="bal.tab.optmatch_+3A_data">data</code></td>
<td>
<p>a data frame containing variables named in <code>formula</code>, if supplied, and other arguments.</p>
</td></tr>
<tr><td><code id="bal.tab.optmatch_+3A_treat">treat</code></td>
<td>
<p>a vector of treatment statuses. See Details.</p>
</td></tr>
<tr><td><code id="bal.tab.optmatch_+3A_covs">covs</code></td>
<td>
<p>a data frame of covariate values for which to check balance. See Details.</p>
</td></tr>
<tr><td><code id="bal.tab.optmatch_+3A_estimand">estimand</code></td>
<td>
<p><code>character</code>; whether the desired estimand is the &quot;ATT&quot;, &quot;ATC&quot;, or &quot;ATE&quot;. Default is &quot;ATT&quot;.</p>
</td></tr>
<tr><td><code id="bal.tab.optmatch_+3A_stats">stats</code></td>
<td>
<p><code>character</code>; which statistic(s) should be reported. See <code><a href="#topic+balance-statistics">stats</a></code> for allowable options. For binary and multi-category treatments, <code>"mean.diffs"</code> (i.e., mean differences) is the default. For continuous treatments, <code>"correlations"</code> (i.e., treatment-covariate Pearson correlations) is the default. Multiple options are allowed.</p>
</td></tr>
<tr><td><code id="bal.tab.optmatch_+3A_int">int</code></td>
<td>
<p><code>logical</code> or <code>numeric</code>; whether or not to include 2-way interactions of covariates included in <code>covs</code> and in <code>addl</code>. If <code>numeric</code>, will be passed to <code>poly</code> as well.</p>
</td></tr>
<tr><td><code id="bal.tab.optmatch_+3A_poly">poly</code></td>
<td>
<p><code>numeric</code>; the highest polynomial of each continuous covariate to display. For example, if 2, squares of each continuous covariate will be displayed (in addition to the covariate itself); if 3, squares and cubes of each continuous covariate will be displayed, etc. If 1, the default, only the base covariate will be displayed. If <code>int</code> is numeric, <code>poly</code> will take on the value of <code>int</code>.</p>
</td></tr>
<tr><td><code id="bal.tab.optmatch_+3A_distance">distance</code></td>
<td>
<p>an optional formula or data frame containing distance values (e.g., propensity scores) or a character vector containing their names. If a formula or variable names are specified, <code>bal.tab()</code> will look in the argument to <code>data</code>, if specified. For longitudinal treatments, can be a list of allowable arguments, one for each time point.</p>
</td></tr>
<tr><td><code id="bal.tab.optmatch_+3A_addl">addl</code></td>
<td>
<p>an optional formula or data frame containing additional covariates for which to present balance or a character vector containing their names. If a formula or variable names are specified, <code>bal.tab()</code> will look in the arguments to the input object, <code>covs</code>, and <code>data</code>, if specified. For longitudinal treatments, can be a list of allowable arguments, one for each time point.</p>
</td></tr>
<tr><td><code id="bal.tab.optmatch_+3A_continuous">continuous</code></td>
<td>
<p>whether mean differences for continuous variables should be standardized (<code>"std"</code>) or raw (<code>"raw"</code>). Default <code>"std"</code>. Abbreviations allowed. This option can be set globally using <code><a href="#topic+set.cobalt.options">set.cobalt.options()</a></code>.</p>
</td></tr>
<tr><td><code id="bal.tab.optmatch_+3A_binary">binary</code></td>
<td>
<p>whether mean differences for binary variables (i.e., difference in proportion) should be standardized (<code>"std"</code>) or raw (<code>"raw"</code>). Default <code>"raw"</code>. Abbreviations allowed. This option can be set globally using <code><a href="#topic+set.cobalt.options">set.cobalt.options()</a></code>.</p>
</td></tr>
<tr><td><code id="bal.tab.optmatch_+3A_s.d.denom">s.d.denom</code></td>
<td>
<p><code>character</code>; how the denominator for standardized mean differences should be calculated, if requested. See <code><a href="#topic+col_w_smd">col_w_smd()</a></code> for allowable options. Abbreviations allowed. If unspecified, <code>bal.tab()</code> will figure out which one is best based on the <code>estimand</code>, if given (for ATT, <code>"treated"</code>; for ATC, <code>"control"</code>; otherwise <code>"pooled"</code>) and other clues if not.</p>
</td></tr>
<tr><td><code id="bal.tab.optmatch_+3A_thresholds">thresholds</code></td>
<td>
<p>a named vector of balance thresholds, where the name corresponds to the statistic (i.e., in <code>stats</code>) that the threshold applies to. For example, to request thresholds on mean differences and variance ratios, one can set <code>thresholds = c(m = .05, v = 2)</code>. Requesting a threshold automatically requests the display of that statistic. When specified, extra columns are inserted into the Balance table describing whether the requested balance statistics exceeded the threshold or not. Summary tables tallying the number of variables that exceeded and were within the threshold and displaying the variables with the greatest imbalance on that balance measure are added to the output.</p>
</td></tr>
<tr><td><code id="bal.tab.optmatch_+3A_weights">weights</code></td>
<td>
<p>a vector, list, or <code>data.frame</code> containing weights for each unit, or a string containing the names of the weights variables in <code>data</code>, or an object with a <code><a href="#topic+get.w">get.w()</a></code> method or a list thereof. The weights can be, e.g., inverse probability weights or matching weights resulting from a matching algorithm.</p>
</td></tr>
<tr><td><code id="bal.tab.optmatch_+3A_cluster">cluster</code></td>
<td>
<p>either a vector containing cluster membership for each unit or a string containing the name of the cluster membership variable in <code>data</code> or the input object. See <code><a href="#topic+class-bal.tab.cluster">class-bal.tab.cluster</a></code> for details.</p>
</td></tr>
<tr><td><code id="bal.tab.optmatch_+3A_imp">imp</code></td>
<td>
<p>either a vector containing imputation indices for each unit or a string containing the name of the imputation index variable in <code>data</code> or the input object. See <code><a href="#topic+class-bal.tab.imp">class-bal.tab.imp</a></code> for details. Not necessary if <code>data</code> is a <code>mids</code> object.</p>
</td></tr>
<tr><td><code id="bal.tab.optmatch_+3A_pairwise">pairwise</code></td>
<td>
<p>whether balance should be computed for pairs of treatments or for each treatment against all groups combined. See <code><a href="#topic+class-bal.tab.multi">bal.tab.multi()</a></code> for details. This can also be used with a binary treatment to assess balance with respect to the full sample.</p>
</td></tr>
<tr><td><code id="bal.tab.optmatch_+3A_s.weights">s.weights</code></td>
<td>
<p>Optional; either a vector containing sampling weights for each unit or a string containing the name of the sampling weight variable in <code>data</code>. These function like regular weights except that both the adjusted and unadjusted samples will be weighted according to these weights if weights are used.</p>
</td></tr>
<tr><td><code id="bal.tab.optmatch_+3A_abs">abs</code></td>
<td>
<p><code>logical</code>; whether displayed balance statistics should be in absolute value or not.</p>
</td></tr>
<tr><td><code id="bal.tab.optmatch_+3A_subset">subset</code></td>
<td>
<p>a <code>logical</code> or <code>numeric</code> vector denoting whether each observation should be included or which observations should be included. If <code>logical</code>, it should have length equal to the number of units. <code>NA</code>s will be treated as <code>FALSE</code>. This can be used as an alternative to <code>cluster</code> to examine balance on subsets of the data.</p>
</td></tr>
<tr><td><code id="bal.tab.optmatch_+3A_quick">quick</code></td>
<td>
<p><code>logical</code>; if <code>TRUE</code>, will not compute any values that will not be displayed. Set to <code>FALSE</code> if computed values not displayed will be used later.</p>
</td></tr>
<tr><td><code id="bal.tab.optmatch_+3A_...">...</code></td>
<td>
<p>for some input types, other arguments that are required or allowed. Otherwise, further arguments to control display of output. See <a href="#topic+display-options">display options</a> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bal.tab()</code> generates a list of balance summaries for the object given. The input to <code>bal.tab.optmatch()</code> must include either both <code>formula</code> and <code>data</code> or just <code>covs</code> (<code>treat</code> is not necessary).
</p>


<h3>Value</h3>

<p>If clusters and imputations are not specified, an object of class <code>"bal.tab"</code> containing balance summaries for the given object. See <code><a href="#topic+bal.tab">bal.tab()</a></code> for details.
</p>
<p>If clusters are specified, an object of class <code>"bal.tab.cluster"</code> containing balance summaries within each cluster and a summary of balance across clusters. See <code><a href="#topic+class-bal.tab.cluster">class-bal.tab.cluster</a></code> for details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bal.tab">bal.tab()</a></code> for details of calculations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("lalonde", package = "cobalt")

lalonde$prop.score &lt;- glm(treat ~ age + educ + race + 
                              married + nodegree + re74 + re75, 
                          data = lalonde, family = binomial)$fitted.values
pm &lt;- optmatch::pairmatch(treat ~ prop.score, data = lalonde)

## Using formula and data; LHS of formula not required
bal.tab(pm, formula = ~ age + educ + race +
            married + nodegree + re74 + re75,
        data = lalonde)

## Using covs
covs &lt;- subset(lalonde, select = -c(re78, treat))
bal.tab(pm, covs = covs)

</code></pre>

<hr>
<h2 id='bal.tab.ps'>Balance Statistics for <code>twang</code> Objects</h2><span id='topic+bal.tab.ps'></span>

<h3>Description</h3>

<p>Generates balance statistics for <code>ps</code>, <code>mnps</code>, and <code>iptw</code> objects from <span class="pkg">twang</span> and for <code>ps.cont</code> objects from <span class="pkg">twangContinuous</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ps'
bal.tab(
  x,
  stop.method,
  stats,
  int = FALSE,
  poly = 1,
  distance = NULL,
  addl = NULL,
  data = NULL,
  continuous,
  binary,
  s.d.denom,
  thresholds = NULL,
  weights = NULL,
  cluster = NULL,
  imp = NULL,
  pairwise = TRUE,
  s.weights = NULL,
  abs = FALSE,
  subset = NULL,
  quick = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bal.tab.ps_+3A_x">x</code></td>
<td>
<p>a <code>ps</code>, <code>mnps</code>, <code>iptw</code>, or <code>ps.cont</code> object; the output of a call to <code><a href="twang.html#topic+ps">twang::ps()</a></code>, <code><a href="twang.html#topic+mnps">twang::mnps()</a></code>, <code><a href="twang.html#topic+iptw">twang::iptw()</a></code> or <code><a href="twangContinuous.html#topic+ps.cont">twangContinuous::ps.cont()</a></code>.</p>
</td></tr>
<tr><td><code id="bal.tab.ps_+3A_stop.method">stop.method</code></td>
<td>
<p>a string containing the names of the stopping methods used in the original call to <code>ps()</code>, <code>mnps()</code>, or <code>iptw()</code>. Examples include <code>"es.max"</code> or <code>"ks.mean"</code> for <code>ps</code> and <code>mnps</code> objects. <code>bal.tab()</code> will assess balance for the weights created by those stopping methods. The names can be abbreviated as long as the abbreviations are specific enough. If no stopping methods are provided, <code>bal.tab()</code> will default to displaying balance for all available stopping methods. Ignored for <code>ps.cont</code> objects.</p>
</td></tr>
<tr><td><code id="bal.tab.ps_+3A_stats">stats</code></td>
<td>
<p><code>character</code>; which statistic(s) should be reported. See <code><a href="#topic+balance-statistics">stats</a></code> for allowable options. For binary and multi-category treatments, <code>"mean.diffs"</code> (i.e., mean differences) is the default. For continuous treatments, <code>"correlations"</code> (i.e., treatment-covariate Pearson correlations) is the default. Multiple options are allowed.</p>
</td></tr>
<tr><td><code id="bal.tab.ps_+3A_int">int</code></td>
<td>
<p><code>logical</code> or <code>numeric</code>; whether or not to include 2-way interactions of covariates included in <code>covs</code> and in <code>addl</code>. If <code>numeric</code>, will be passed to <code>poly</code> as well.</p>
</td></tr>
<tr><td><code id="bal.tab.ps_+3A_poly">poly</code></td>
<td>
<p><code>numeric</code>; the highest polynomial of each continuous covariate to display. For example, if 2, squares of each continuous covariate will be displayed (in addition to the covariate itself); if 3, squares and cubes of each continuous covariate will be displayed, etc. If 1, the default, only the base covariate will be displayed. If <code>int</code> is numeric, <code>poly</code> will take on the value of <code>int</code>.</p>
</td></tr>
<tr><td><code id="bal.tab.ps_+3A_distance">distance</code></td>
<td>
<p>an optional formula or data frame containing distance values (e.g., propensity scores) or a character vector containing their names. If a formula or variable names are specified, <code>bal.tab()</code> will look in the argument to <code>data</code>, if specified. The propensity scores generated by <code>ps()</code> and <code>iptw()</code> (but not <code>mnps()</code> or <code>ps.cont()</code>) are automatically included and named &quot;prop.score.{stop.method}&quot;.</p>
</td></tr>
<tr><td><code id="bal.tab.ps_+3A_addl">addl</code></td>
<td>
<p>an optional formula or data frame containing additional covariates for which to present balance or a character vector containing their names. If a formula or variable names are specified, <code>bal.tab()</code> will look in the arguments to the input object, <code>covs</code>, and <code>data</code>, if specified. For longitudinal treatments, can be a list of allowable arguments, one for each time point.</p>
</td></tr>
<tr><td><code id="bal.tab.ps_+3A_data">data</code></td>
<td>
<p>an optional data frame containing variables named in other arguments. For some input object types, this is required.</p>
</td></tr>
<tr><td><code id="bal.tab.ps_+3A_continuous">continuous</code></td>
<td>
<p>whether mean differences for continuous variables should be standardized (<code>"std"</code>) or raw (<code>"raw"</code>). Default <code>"std"</code>. Abbreviations allowed. This option can be set globally using <code><a href="#topic+set.cobalt.options">set.cobalt.options()</a></code>.</p>
</td></tr>
<tr><td><code id="bal.tab.ps_+3A_binary">binary</code></td>
<td>
<p>whether mean differences for binary variables (i.e., difference in proportion) should be standardized (<code>"std"</code>) or raw (<code>"raw"</code>). Default <code>"raw"</code>. Abbreviations allowed. This option can be set globally using <code><a href="#topic+set.cobalt.options">set.cobalt.options()</a></code>.</p>
</td></tr>
<tr><td><code id="bal.tab.ps_+3A_s.d.denom">s.d.denom</code></td>
<td>
<p><code>character</code>; how the denominator for standardized mean differences should be calculated, if requested. See <code><a href="#topic+col_w_smd">col_w_smd()</a></code> for allowable options. Abbreviations allowed. If not specified, for <code>ps</code> objects, <code>bal.tab()</code> will use &quot;treated&quot; if the estimand of the call to <code>ps()</code> is the ATT and &quot;pooled&quot; if the estimand is the ATE; for <code>mnps</code> objects, <code>bal.tab()</code> will use &quot;treated&quot; if <code>treatATT</code> was specified in the original call to <code>mnps</code> and &quot;pooled&quot; otherwise. Use &quot;all&quot; to get the same values computed by <code>bal.table()</code> in <span class="pkg">twang</span>.</p>
</td></tr>
<tr><td><code id="bal.tab.ps_+3A_thresholds">thresholds</code></td>
<td>
<p>a named vector of balance thresholds, where the name corresponds to the statistic (i.e., in <code>stats</code>) that the threshold applies to. For example, to request thresholds on mean differences and variance ratios, one can set <code>thresholds = c(m = .05, v = 2)</code>. Requesting a threshold automatically requests the display of that statistic. When specified, extra columns are inserted into the Balance table describing whether the requested balance statistics exceeded the threshold or not. Summary tables tallying the number of variables that exceeded and were within the threshold and displaying the variables with the greatest imbalance on that balance measure are added to the output.</p>
</td></tr>
<tr><td><code id="bal.tab.ps_+3A_weights">weights</code></td>
<td>
<p>a vector, list, or <code>data.frame</code> containing weights for each unit, or a string containing the names of the weights variables in <code>data</code>, or an object with a <code><a href="#topic+get.w">get.w()</a></code> method or a list thereof. The weights can be, e.g., inverse probability weights or matching weights resulting from a matching algorithm.</p>
</td></tr>
<tr><td><code id="bal.tab.ps_+3A_cluster">cluster</code></td>
<td>
<p>either a vector containing cluster membership for each unit or a string containing the name of the cluster membership variable in <code>data</code> or the input object. See <code><a href="#topic+class-bal.tab.cluster">class-bal.tab.cluster</a></code> for details.</p>
</td></tr>
<tr><td><code id="bal.tab.ps_+3A_imp">imp</code></td>
<td>
<p>either a vector containing imputation indices for each unit or a string containing the name of the imputation index variable in <code>data</code> or the input object. See <code><a href="#topic+class-bal.tab.imp">class-bal.tab.imp</a></code> for details. Not necessary if <code>data</code> is a <code>mids</code> object.</p>
</td></tr>
<tr><td><code id="bal.tab.ps_+3A_pairwise">pairwise</code></td>
<td>
<p>whether balance should be computed for pairs of treatments or for each treatment against all groups combined. See <code><a href="#topic+class-bal.tab.multi">bal.tab.multi()</a></code> for details. This can also be used with a binary treatment to assess balance with respect to the full sample.</p>
</td></tr>
<tr><td><code id="bal.tab.ps_+3A_s.weights">s.weights</code></td>
<td>
<p>Optional; either a vector containing sampling weights for each unit or a string containing the name of the sampling weight variable in <code>data</code>. These function like regular weights except that both the adjusted and unadjusted samples will be weighted according to these weights if weights are used. If <code>sampw</code> was supplied in the call to <code>ps()</code>, <code>mnps()</code>, <code>iptw()</code>, or <code>ps.cont()</code>, they will automatically be supplied to <code>s.weights</code> and do not need be specified again (though there is no harm if they are).</p>
</td></tr>
<tr><td><code id="bal.tab.ps_+3A_abs">abs</code></td>
<td>
<p><code>logical</code>; whether displayed balance statistics should be in absolute value or not.</p>
</td></tr>
<tr><td><code id="bal.tab.ps_+3A_subset">subset</code></td>
<td>
<p>a <code>logical</code> or <code>numeric</code> vector denoting whether each observation should be included or which observations should be included. If <code>logical</code>, it should have length equal to the number of units. <code>NA</code>s will be treated as <code>FALSE</code>. This can be used as an alternative to <code>cluster</code> to examine balance on subsets of the data.</p>
</td></tr>
<tr><td><code id="bal.tab.ps_+3A_quick">quick</code></td>
<td>
<p><code>logical</code>; if <code>TRUE</code>, will not compute any values that will not be displayed. Set to <code>FALSE</code> if computed values not displayed will be used later.</p>
</td></tr>
<tr><td><code id="bal.tab.ps_+3A_...">...</code></td>
<td>
<p>for some input types, other arguments that are required or allowed. Otherwise, further arguments to control display of output. See <a href="#topic+display-options">display options</a> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bal.tab.ps()</code> generates a list of balance summaries for the input object given, and functions similarly to <code><a href="twang.html#topic+bal.table">twang::bal.table()</a></code>. The variances used in the denominator of the standardized mean differences computed in <code>twang::bal.table()</code> are weighted and computed using <code>survey::svyvar()</code> and are unweighted here (except when <code>s.weights</code> are specified, in which case <code><a href="#topic+col_w_sd">col_w_sd()</a></code> is used). <span class="pkg">twang</span> also uses &quot;all&quot; as the default <code>s.d.denom</code> when the estimand is the ATE; the default here is &quot;pooled&quot;. For these reasons, results may differ slightly between the two packages.
</p>


<h3>Value</h3>

<p>For binary or continuous point treatments, if clusters are not specified, an object of class <code>"bal.tab"</code> containing balance summaries for the <code>ps</code> object. See <code><a href="#topic+bal.tab">bal.tab()</a></code> for details.
</p>
<p>If clusters are specified, an object of class <code>"bal.tab.cluster"</code> containing balance summaries within each cluster and a summary of balance across clusters. See <code><a href="#topic+class-bal.tab.cluster">class-bal.tab.cluster</a></code> for details.
</p>
<p>If <code>mnps()</code> is used with multi-category treatments, an object of class <code>"bal.tab.multi"</code> containing balance summaries for each pairwise treatment comparison and a summary of balance across pairwise comparisons. See <code><a href="#topic+class-bal.tab.multi">bal.tab.multi()</a></code> for details.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+bal.tab">bal.tab()</a></code> for details of calculations.
</p>
</li>
<li> <p><code><a href="#topic+class-bal.tab.cluster">class-bal.tab.cluster</a></code> for more information on clustered data.
</p>
</li>
<li> <p><code><a href="#topic+class-bal.tab.multi">bal.tab.multi()</a></code> for more information on multi-category treatments.
</p>
</li>
<li> <p><code><a href="#topic+class-bal.tab.msm">class-bal.tab.msm</a></code> for more information on longitudinal treatments.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(twang); data("lalonde", package = "cobalt")

## Using ps() for generalized boosted modeling
ps.out &lt;- ps(treat ~ age + educ + married + race +
                 nodegree + re74 + re75, data = lalonde, 
             stop.method = c("ks.mean", "es.mean"), 
             estimand = "ATT", verbose = FALSE)

bal.tab(ps.out, stop.method = "ks.mean", un = TRUE, 
        m.threshold = .1, disp.ks = TRUE)


</code></pre>

<hr>
<h2 id='bal.tab.sbwcau'>Balance Statistics for <code>sbw</code> Objects</h2><span id='topic+bal.tab.sbwcau'></span>

<h3>Description</h3>

<p>Generates balance statistics for <code>sbwcau</code> objects from <span class="pkg">sbw</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sbwcau'
bal.tab(
  x,
  stats,
  int = FALSE,
  poly = 1,
  distance = NULL,
  addl = NULL,
  data = NULL,
  continuous,
  binary,
  s.d.denom,
  thresholds = NULL,
  weights = NULL,
  cluster = NULL,
  imp = NULL,
  pairwise = TRUE,
  s.weights = NULL,
  abs = FALSE,
  subset = NULL,
  quick = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bal.tab.sbwcau_+3A_x">x</code></td>
<td>
<p>an <code>sbwcau</code> object; the output of a call to <code><a href="sbw.html#topic+sbw">sbw::sbw()</a></code>.</p>
</td></tr>
<tr><td><code id="bal.tab.sbwcau_+3A_stats">stats</code></td>
<td>
<p><code>character</code>; which statistic(s) should be reported. See <code><a href="#topic+balance-statistics">stats</a></code> for allowable options. For binary and multi-category treatments, <code>"mean.diffs"</code> (i.e., mean differences) is the default. For continuous treatments, <code>"correlations"</code> (i.e., treatment-covariate Pearson correlations) is the default. Multiple options are allowed.</p>
</td></tr>
<tr><td><code id="bal.tab.sbwcau_+3A_int">int</code></td>
<td>
<p><code>logical</code> or <code>numeric</code>; whether or not to include 2-way interactions of covariates included in <code>covs</code> and in <code>addl</code>. If <code>numeric</code>, will be passed to <code>poly</code> as well.</p>
</td></tr>
<tr><td><code id="bal.tab.sbwcau_+3A_poly">poly</code></td>
<td>
<p><code>numeric</code>; the highest polynomial of each continuous covariate to display. For example, if 2, squares of each continuous covariate will be displayed (in addition to the covariate itself); if 3, squares and cubes of each continuous covariate will be displayed, etc. If 1, the default, only the base covariate will be displayed. If <code>int</code> is numeric, <code>poly</code> will take on the value of <code>int</code>.</p>
</td></tr>
<tr><td><code id="bal.tab.sbwcau_+3A_distance">distance</code></td>
<td>
<p>an optional formula or data frame containing distance values (e.g., propensity scores) or a character vector containing their names. If a formula or variable names are specified, <code>bal.tab()</code> will look in the argument to <code>data</code>, if specified. For longitudinal treatments, can be a list of allowable arguments, one for each time point.</p>
</td></tr>
<tr><td><code id="bal.tab.sbwcau_+3A_addl">addl</code></td>
<td>
<p>an optional formula or data frame containing additional covariates for which to present balance or a character vector containing their names. If a formula or variable names are specified, <code>bal.tab()</code> will look in the arguments to the input object, <code>covs</code>, and <code>data</code>, if specified. For longitudinal treatments, can be a list of allowable arguments, one for each time point.</p>
</td></tr>
<tr><td><code id="bal.tab.sbwcau_+3A_data">data</code></td>
<td>
<p>an optional data frame containing variables named in other arguments. For some input object types, this is required.</p>
</td></tr>
<tr><td><code id="bal.tab.sbwcau_+3A_continuous">continuous</code></td>
<td>
<p>whether mean differences for continuous variables should be standardized (<code>"std"</code>) or raw (<code>"raw"</code>). Default <code>"std"</code>. Abbreviations allowed. This option can be set globally using <code><a href="#topic+set.cobalt.options">set.cobalt.options()</a></code>.</p>
</td></tr>
<tr><td><code id="bal.tab.sbwcau_+3A_binary">binary</code></td>
<td>
<p>whether mean differences for binary variables (i.e., difference in proportion) should be standardized (<code>"std"</code>) or raw (<code>"raw"</code>). Default <code>"raw"</code>. Abbreviations allowed. This option can be set globally using <code><a href="#topic+set.cobalt.options">set.cobalt.options()</a></code>.</p>
</td></tr>
<tr><td><code id="bal.tab.sbwcau_+3A_s.d.denom">s.d.denom</code></td>
<td>
<p><code>character</code>; how the denominator for standardized mean differences should be calculated, if requested. See <code><a href="#topic+col_w_smd">col_w_smd()</a></code> for allowable options. Abbreviations allowed. If not specified, <code>bal.tab()</code> will figure out which one is best based on the <code>par</code> component of the <code>sbwcau</code> object: if &quot;att&quot;, <code>"treated"</code>; if &quot;atc&quot;, <code>"control"</code>; otherwise <code>"pooled"</code>.</p>
</td></tr>
<tr><td><code id="bal.tab.sbwcau_+3A_thresholds">thresholds</code></td>
<td>
<p>a named vector of balance thresholds, where the name corresponds to the statistic (i.e., in <code>stats</code>) that the threshold applies to. For example, to request thresholds on mean differences and variance ratios, one can set <code>thresholds = c(m = .05, v = 2)</code>. Requesting a threshold automatically requests the display of that statistic. When specified, extra columns are inserted into the Balance table describing whether the requested balance statistics exceeded the threshold or not. Summary tables tallying the number of variables that exceeded and were within the threshold and displaying the variables with the greatest imbalance on that balance measure are added to the output.</p>
</td></tr>
<tr><td><code id="bal.tab.sbwcau_+3A_weights">weights</code></td>
<td>
<p>a vector, list, or <code>data.frame</code> containing weights for each unit, or a string containing the names of the weights variables in <code>data</code>, or an object with a <code><a href="#topic+get.w">get.w()</a></code> method or a list thereof. The weights can be, e.g., inverse probability weights or matching weights resulting from a matching algorithm.</p>
</td></tr>
<tr><td><code id="bal.tab.sbwcau_+3A_cluster">cluster</code></td>
<td>
<p>either a vector containing cluster membership for each unit or a string containing the name of the cluster membership variable in <code>data</code> or the input object. See <code><a href="#topic+class-bal.tab.cluster">class-bal.tab.cluster</a></code> for details.</p>
</td></tr>
<tr><td><code id="bal.tab.sbwcau_+3A_imp">imp</code></td>
<td>
<p>either a vector containing imputation indices for each unit or a string containing the name of the imputation index variable in <code>data</code> or the input object. See <code><a href="#topic+class-bal.tab.imp">class-bal.tab.imp</a></code> for details. Not necessary if <code>data</code> is a <code>mids</code> object.</p>
</td></tr>
<tr><td><code id="bal.tab.sbwcau_+3A_pairwise">pairwise</code></td>
<td>
<p>whether balance should be computed for pairs of treatments or for each treatment against all groups combined. See <code><a href="#topic+class-bal.tab.multi">bal.tab.multi()</a></code> for details. This can also be used with a binary treatment to assess balance with respect to the full sample.</p>
</td></tr>
<tr><td><code id="bal.tab.sbwcau_+3A_s.weights">s.weights</code></td>
<td>
<p>Optional; either a vector containing sampling weights for each unit or a string containing the name of the sampling weight variable in <code>data</code>. These function like regular weights except that both the adjusted and unadjusted samples will be weighted according to these weights if weights are used.</p>
</td></tr>
<tr><td><code id="bal.tab.sbwcau_+3A_abs">abs</code></td>
<td>
<p><code>logical</code>; whether displayed balance statistics should be in absolute value or not.</p>
</td></tr>
<tr><td><code id="bal.tab.sbwcau_+3A_subset">subset</code></td>
<td>
<p>a <code>logical</code> or <code>numeric</code> vector denoting whether each observation should be included or which observations should be included. If <code>logical</code>, it should have length equal to the number of units. <code>NA</code>s will be treated as <code>FALSE</code>. This can be used as an alternative to <code>cluster</code> to examine balance on subsets of the data.</p>
</td></tr>
<tr><td><code id="bal.tab.sbwcau_+3A_quick">quick</code></td>
<td>
<p><code>logical</code>; if <code>TRUE</code>, will not compute any values that will not be displayed. Set to <code>FALSE</code> if computed values not displayed will be used later.</p>
</td></tr>
<tr><td><code id="bal.tab.sbwcau_+3A_...">...</code></td>
<td>
<p>for some input types, other arguments that are required or allowed. Otherwise, further arguments to control display of output. See <a href="#topic+display-options">display options</a> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bal.tab.sbwcau()</code> generates a list of balance summaries for the <code>sbwcau</code> object given, and functions similarly to <code><a href="sbw.html#topic+summarize">sbw::summarize()</a></code>.
</p>


<h3>Value</h3>

<p>If clusters are not specified, an object of class <code>"bal.tab"</code> containing balance summaries for the <code>sbwcau</code> object. See <code><a href="#topic+bal.tab">bal.tab()</a></code> for details.
</p>
<p>If clusters are specified, an object of class <code>"bal.tab.cluster"</code> containing balance summaries within each cluster and a summary of balance across clusters. See <code><a href="#topic+class-bal.tab.cluster">class-bal.tab.cluster</a></code> for details.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+bal.tab">bal.tab()</a></code> for details of calculations.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(sbw); data("lalonde", package = "cobalt")

## Stable balancing weights for the ATT
sbw.out &lt;- sbw(splitfactor(lalonde, drop.first = "if2"),
               ind = "treat",
               bal = list(bal_cov = c("age", "educ", "race_black", 
                                      "race_hispan", "race_white", 
                                      "married", "nodegree", 
                                      "re74", "re75"),
                          bal_alg = FALSE, 
                          bal_tol = .001),
               par = list(par_est = "att"))

bal.tab(sbw.out, un = TRUE, poly = 2)

</code></pre>

<hr>
<h2 id='bal.tab.time.list'>Balance Statistics for Longitudinal Datasets</h2><span id='topic+bal.tab.time.list'></span><span id='topic+bal.tab.formula.list'></span><span id='topic+bal.tab.data.frame.list'></span>

<h3>Description</h3>

<p>Generates balance statistics for data coming from a longitudinal treatment scenario. The primary input is in the form of a list of formulas or <code>data.frame</code>s contain the covariates at each time point. <code>bal.tab()</code> automatically classifies this list as either a <code>data.frame.list</code> or <code>formula.list</code>, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula.list'
bal.tab(
  x,
  stats,
  int = FALSE,
  poly = 1,
  distance = NULL,
  addl = NULL,
  data = NULL,
  continuous,
  binary,
  s.d.denom,
  thresholds = NULL,
  weights = NULL,
  cluster = NULL,
  imp = NULL,
  pairwise = TRUE,
  s.weights = NULL,
  abs = FALSE,
  subset = NULL,
  quick = TRUE,
  ...
)

## S3 method for class 'data.frame.list'
bal.tab(
  x,
  treat.list,
  stats,
  int = FALSE,
  poly = 1,
  distance = NULL,
  addl = NULL,
  data = NULL,
  continuous,
  binary,
  s.d.denom,
  thresholds = NULL,
  weights = NULL,
  cluster = NULL,
  imp = NULL,
  pairwise = TRUE,
  s.weights = NULL,
  abs = FALSE,
  subset = NULL,
  quick = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bal.tab.time.list_+3A_x">x</code></td>
<td>
<p>either a list of data frames containing all the covariates to be assessed at each time point or a list of formulas with the treatment for each time period on the left and the covariates for which balance is to be displayed on the right. Covariates to be assessed at multiple points must be included in the entries for each time point. Data must be in the &quot;wide&quot; format, with one row per unit. If a formula list is supplied, an argument to <code>data</code> is required unless all objects in the formulas exist in the environment.</p>
</td></tr>
<tr><td><code id="bal.tab.time.list_+3A_stats">stats</code></td>
<td>
<p><code>character</code>; which statistic(s) should be reported. See <code><a href="#topic+balance-statistics">stats</a></code> for allowable options. For binary and multi-category treatments, <code>"mean.diffs"</code> (i.e., mean differences) is the default. For continuous treatments, <code>"correlations"</code> (i.e., treatment-covariate Pearson correlations) is the default. Multiple options are allowed.</p>
</td></tr>
<tr><td><code id="bal.tab.time.list_+3A_int">int</code></td>
<td>
<p><code>logical</code> or <code>numeric</code>; whether or not to include 2-way interactions of covariates included in <code>covs</code> and in <code>addl</code>. If <code>numeric</code>, will be passed to <code>poly</code> as well.</p>
</td></tr>
<tr><td><code id="bal.tab.time.list_+3A_poly">poly</code></td>
<td>
<p><code>numeric</code>; the highest polynomial of each continuous covariate to display. For example, if 2, squares of each continuous covariate will be displayed (in addition to the covariate itself); if 3, squares and cubes of each continuous covariate will be displayed, etc. If 1, the default, only the base covariate will be displayed. If <code>int</code> is numeric, <code>poly</code> will take on the value of <code>int</code>.</p>
</td></tr>
<tr><td><code id="bal.tab.time.list_+3A_distance">distance</code></td>
<td>
<p>an optional formula or data frame containing distance values (e.g., propensity scores) or a character vector containing their names. If a formula or variable names are specified, <code>bal.tab()</code> will look in the argument to <code>data</code>, if specified. For longitudinal treatments, can be a list of allowable arguments, one for each time point.</p>
</td></tr>
<tr><td><code id="bal.tab.time.list_+3A_addl">addl</code></td>
<td>
<p>an optional formula or data frame containing additional covariates for which to present balance or a character vector containing their names. If a formula or variable names are specified, <code>bal.tab()</code> will look in the arguments to the input object, <code>covs</code>, and <code>data</code>, if specified. For longitudinal treatments, can be a list of allowable arguments, one for each time point.</p>
</td></tr>
<tr><td><code id="bal.tab.time.list_+3A_data">data</code></td>
<td>
<p>an optional data frame containing variables named in other arguments. For some input object types, this is required.</p>
</td></tr>
<tr><td><code id="bal.tab.time.list_+3A_continuous">continuous</code></td>
<td>
<p>whether mean differences for continuous variables should be standardized (<code>"std"</code>) or raw (<code>"raw"</code>). Default <code>"std"</code>. Abbreviations allowed. This option can be set globally using <code><a href="#topic+set.cobalt.options">set.cobalt.options()</a></code>.</p>
</td></tr>
<tr><td><code id="bal.tab.time.list_+3A_binary">binary</code></td>
<td>
<p>whether mean differences for binary variables (i.e., difference in proportion) should be standardized (<code>"std"</code>) or raw (<code>"raw"</code>). Default <code>"raw"</code>. Abbreviations allowed. This option can be set globally using <code><a href="#topic+set.cobalt.options">set.cobalt.options()</a></code>.</p>
</td></tr>
<tr><td><code id="bal.tab.time.list_+3A_s.d.denom">s.d.denom</code></td>
<td>
<p><code>character</code>; how the denominator for standardized mean differences should be calculated, if requested. See <code><a href="#topic+col_w_smd">col_w_smd()</a></code> for allowable options. Abbreviations allowed. It is recommended not to set this argument for longitudinal treatments.</p>
</td></tr>
<tr><td><code id="bal.tab.time.list_+3A_thresholds">thresholds</code></td>
<td>
<p>a named vector of balance thresholds, where the name corresponds to the statistic (i.e., in <code>stats</code>) that the threshold applies to. For example, to request thresholds on mean differences and variance ratios, one can set <code>thresholds = c(m = .05, v = 2)</code>. Requesting a threshold automatically requests the display of that statistic. When specified, extra columns are inserted into the Balance table describing whether the requested balance statistics exceeded the threshold or not. Summary tables tallying the number of variables that exceeded and were within the threshold and displaying the variables with the greatest imbalance on that balance measure are added to the output.</p>
</td></tr>
<tr><td><code id="bal.tab.time.list_+3A_weights">weights</code></td>
<td>
<p>a vector, list, or <code>data.frame</code> containing weights for each unit, or a string containing the names of the weights variables in <code>data</code>, or an object with a <code><a href="#topic+get.w">get.w()</a></code> method or a list thereof. The weights can be, e.g., inverse probability weights or matching weights resulting from a matching algorithm.</p>
</td></tr>
<tr><td><code id="bal.tab.time.list_+3A_cluster">cluster</code></td>
<td>
<p>either a vector containing cluster membership for each unit or a string containing the name of the cluster membership variable in <code>data</code> or the input object. See <code><a href="#topic+class-bal.tab.cluster">class-bal.tab.cluster</a></code> for details.</p>
</td></tr>
<tr><td><code id="bal.tab.time.list_+3A_imp">imp</code></td>
<td>
<p>either a vector containing imputation indices for each unit or a string containing the name of the imputation index variable in <code>data</code> or the input object. See <code><a href="#topic+class-bal.tab.imp">class-bal.tab.imp</a></code> for details. Not necessary if <code>data</code> is a <code>mids</code> object.</p>
</td></tr>
<tr><td><code id="bal.tab.time.list_+3A_pairwise">pairwise</code></td>
<td>
<p>whether balance should be computed for pairs of treatments or for each treatment against all groups combined. See <code><a href="#topic+class-bal.tab.multi">bal.tab.multi()</a></code> for details. This can also be used with a binary treatment to assess balance with respect to the full sample.</p>
</td></tr>
<tr><td><code id="bal.tab.time.list_+3A_s.weights">s.weights</code></td>
<td>
<p>Optional; either a vector containing sampling weights for each unit or a string containing the name of the sampling weight variable in <code>data</code>. These function like regular weights except that both the adjusted and unadjusted samples will be weighted according to these weights if weights are used.</p>
</td></tr>
<tr><td><code id="bal.tab.time.list_+3A_abs">abs</code></td>
<td>
<p><code>logical</code>; whether displayed balance statistics should be in absolute value or not.</p>
</td></tr>
<tr><td><code id="bal.tab.time.list_+3A_subset">subset</code></td>
<td>
<p>a <code>logical</code> or <code>numeric</code> vector denoting whether each observation should be included or which observations should be included. If <code>logical</code>, it should have length equal to the number of units. <code>NA</code>s will be treated as <code>FALSE</code>. This can be used as an alternative to <code>cluster</code> to examine balance on subsets of the data.</p>
</td></tr>
<tr><td><code id="bal.tab.time.list_+3A_quick">quick</code></td>
<td>
<p><code>logical</code>; if <code>TRUE</code>, will not compute any values that will not be displayed. Set to <code>FALSE</code> if computed values not displayed will be used later.</p>
</td></tr>
<tr><td><code id="bal.tab.time.list_+3A_...">...</code></td>
<td>
<p>for some input types, other arguments that are required or allowed. Otherwise, further arguments to control display of output. See <a href="#topic+display-options">display options</a> for details.</p>
</td></tr>
<tr><td><code id="bal.tab.time.list_+3A_treat.list">treat.list</code></td>
<td>
<p>treatment status for each unit at each time point. This can be specified as a list or data frame of vectors, each of which contains the treatment status of each individual at each time point, or a list or vector of the names of variables in <code>data</code> that contain treatment at each time point. Required for the <code>data.frame.list</code> method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bal.tab.formula.list()</code> and <code>bal.tab.data.frame.list()</code> generate a list of balance summaries for each time point based on the treatments and covariates provided. All data must be in the &quot;wide&quot; format, with exactly one row per unit and columns representing variables at different time points. See the <code><a href="WeightIt.html#topic+weightitMSM">WeightIt::weightitMSM()</a></code> documentation for an example of how to transform long data into wide data using <code><a href="stats.html#topic+reshape">reshape()</a></code>.
</p>
<p>Multiple sets of weights can be supplied simultaneously by including entering a data frame or a character vector containing the names of weight variables found in <code>data</code> or a list thereof. When only one set of weights is supplied, the output for the adjusted group will simply be called <code>"Adj"</code>, but otherwise will be named after each corresponding set of weights. Specifying multiple sets of weights will also add components to other outputs of <code>bal.tab()</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>bal.tab.msm</code> containing balance summaries at each time point. Each balance summary is its own <code>bal.tab</code> object. See <code><a href="#topic+class-bal.tab.msm">class-bal.tab.msm</a></code> for more details.
</p>
<p>See <code><a href="#topic+bal.tab.formula">bal.tab() base methods()</a></code> for more detailed information on the value of the <code>bal.tab</code> objects produced for each time point.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+bal.tab">bal.tab()</a></code> for details of calculations.
</p>
</li>
<li> <p><code><a href="#topic+class-bal.tab.msm">class-bal.tab.msm</a></code> for output and related options.
</p>
</li>
<li> <p><code><a href="#topic+class-bal.tab.cluster">class-bal.tab.cluster</a></code> for more information on clustered data.
</p>
</li>
<li> <p><code><a href="#topic+class-bal.tab.imp">class-bal.tab.imp</a></code> for more information on multiply imputed data.
</p>
</li>
<li> <p><code><a href="#topic+class-bal.tab.multi">bal.tab.multi()</a></code> for more information on multi-category treatments.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
data("msmdata", package = "WeightIt")

## Estimating longitudinal propensity scores and weights
ps1 &lt;- glm(A_1 ~ X1_0 + X2_0,
           data = msmdata, 
           family = "binomial")$fitted.values
w1 &lt;- ifelse(msmdata$A_1 == 1, 1 / ps1, 1 / (1 - ps1))

ps2 &lt;- glm(A_2 ~ X1_1 + X2_1 +
               A_1 + X1_0 + X2_0,
           data = msmdata, 
           family = "binomial")$fitted.values
w2 &lt;- ifelse(msmdata$A_2 == 1, 1 / ps2, 1 / (1 - ps2))

ps3 &lt;- glm(A_3 ~ X1_2 + X2_2 +
               A_2 + X1_1 + X2_1 +
               A_1 + X1_0 + X2_0,
           data = msmdata, 
           family = "binomial")$fitted.values
w3 &lt;- ifelse(msmdata$A_3 == 1, 1 / ps3, 1 / (1 - ps3))

w &lt;- w1 * w2 * w3

# Formula interface plus addl:
bal.tab(list(A_1 ~ X1_0 + X2_0,
             A_2 ~ X1_1 + X2_1 +
                 A_1 + X1_0 + X2_0,
             A_3 ~ X1_2 + X2_2 +
                 A_2 + X1_1 + X2_1 +
                 A_1 + X1_0 + X2_0),
        data = msmdata, 
        weights = w,
        distance = list(~ps1, ~ps2, ~ps3),
        addl = ~X1_0 * X2_0,
        un = TRUE)

# data frame interface:
bal.tab(list(msmdata[c("X1_0", "X2_0")],
             msmdata[c("X1_1", "X2_1", "A_1", "X1_0", "X2_0")],
             msmdata[c("X1_2", "X2_2", "A_2", "X1_1", "X2_1",
                       "A_1", "X1_0", "X2_0")]),
        treat.list = msmdata[c("A_1", "A_2", "A_3")], 
        weights = w,
        distance = list(~ps1, ~ps2, ~ps3),
        un = TRUE)

</code></pre>

<hr>
<h2 id='bal.tab.weightit'>Balance Statistics for <code>WeightIt</code> Objects</h2><span id='topic+bal.tab.weightit'></span>

<h3>Description</h3>

<p>Generates balance statistics for <code>weightit</code> and <code>weightitMSM</code> objects from <span class="pkg">WeightIt</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'weightit'
bal.tab(
  x,
  stats,
  int = FALSE,
  poly = 1,
  distance = NULL,
  addl = NULL,
  data = NULL,
  continuous,
  binary,
  s.d.denom,
  thresholds = NULL,
  weights = NULL,
  cluster = NULL,
  imp = NULL,
  pairwise = TRUE,
  s.weights = NULL,
  abs = FALSE,
  subset = NULL,
  quick = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bal.tab.weightit_+3A_x">x</code></td>
<td>
<p>a <code>weightit</code> or <code>weightitMSM</code> object; the output of a call to <code><a href="WeightIt.html#topic+weightit">WeightIt::weightit()</a></code> or <code><a href="WeightIt.html#topic+weightitMSM">WeightIt::weightitMSM()</a></code>.</p>
</td></tr>
<tr><td><code id="bal.tab.weightit_+3A_stats">stats</code></td>
<td>
<p><code>character</code>; which statistic(s) should be reported. See <code><a href="#topic+balance-statistics">stats</a></code> for allowable options. For binary and multi-category treatments, <code>"mean.diffs"</code> (i.e., mean differences) is the default. For continuous treatments, <code>"correlations"</code> (i.e., treatment-covariate Pearson correlations) is the default. Multiple options are allowed.</p>
</td></tr>
<tr><td><code id="bal.tab.weightit_+3A_int">int</code></td>
<td>
<p><code>logical</code> or <code>numeric</code>; whether or not to include 2-way interactions of covariates included in <code>covs</code> and in <code>addl</code>. If <code>numeric</code>, will be passed to <code>poly</code> as well.</p>
</td></tr>
<tr><td><code id="bal.tab.weightit_+3A_poly">poly</code></td>
<td>
<p><code>numeric</code>; the highest polynomial of each continuous covariate to display. For example, if 2, squares of each continuous covariate will be displayed (in addition to the covariate itself); if 3, squares and cubes of each continuous covariate will be displayed, etc. If 1, the default, only the base covariate will be displayed. If <code>int</code> is numeric, <code>poly</code> will take on the value of <code>int</code>.</p>
</td></tr>
<tr><td><code id="bal.tab.weightit_+3A_distance">distance</code></td>
<td>
<p>an optional formula or data frame containing distance values (e.g., propensity scores) or a character vector containing their names. If a formula or variable names are specified, <code>bal.tab()</code> will look in the argument to <code>data</code>, if specified. Propensity scores generated by <code>weightit()</code> and <code>weightitMSM()</code> are automatically included and named &quot;prop.score&quot;.</p>
</td></tr>
<tr><td><code id="bal.tab.weightit_+3A_addl">addl</code></td>
<td>
<p>an optional formula or data frame containing additional covariates for which to present balance or a character vector containing their names. If a formula or variable names are specified, <code>bal.tab()</code> will look in the arguments to the input object, <code>covs</code>, and <code>data</code>, if specified. For longitudinal treatments, can be a list of allowable arguments, one for each time point.</p>
</td></tr>
<tr><td><code id="bal.tab.weightit_+3A_data">data</code></td>
<td>
<p>an optional data frame containing variables named in other arguments. For some input object types, this is required.</p>
</td></tr>
<tr><td><code id="bal.tab.weightit_+3A_continuous">continuous</code></td>
<td>
<p>whether mean differences for continuous variables should be standardized (<code>"std"</code>) or raw (<code>"raw"</code>). Default <code>"std"</code>. Abbreviations allowed. This option can be set globally using <code><a href="#topic+set.cobalt.options">set.cobalt.options()</a></code>.</p>
</td></tr>
<tr><td><code id="bal.tab.weightit_+3A_binary">binary</code></td>
<td>
<p>whether mean differences for binary variables (i.e., difference in proportion) should be standardized (<code>"std"</code>) or raw (<code>"raw"</code>). Default <code>"raw"</code>. Abbreviations allowed. This option can be set globally using <code><a href="#topic+set.cobalt.options">set.cobalt.options()</a></code>.</p>
</td></tr>
<tr><td><code id="bal.tab.weightit_+3A_s.d.denom">s.d.denom</code></td>
<td>
<p><code>character</code>; how the denominator for standardized mean differences should be calculated, if requested. See <code><a href="#topic+col_w_smd">col_w_smd()</a></code> for allowable options. Abbreviations allowed. If not specified, <code>bal.tab()</code> will figure out which one is best based on the estimand of the <code>weightit</code> object: if ATT, <code>"treated"</code>; if ATC, <code>"control"</code>; otherwise <code>"pooled"</code>.</p>
</td></tr>
<tr><td><code id="bal.tab.weightit_+3A_thresholds">thresholds</code></td>
<td>
<p>a named vector of balance thresholds, where the name corresponds to the statistic (i.e., in <code>stats</code>) that the threshold applies to. For example, to request thresholds on mean differences and variance ratios, one can set <code>thresholds = c(m = .05, v = 2)</code>. Requesting a threshold automatically requests the display of that statistic. When specified, extra columns are inserted into the Balance table describing whether the requested balance statistics exceeded the threshold or not. Summary tables tallying the number of variables that exceeded and were within the threshold and displaying the variables with the greatest imbalance on that balance measure are added to the output.</p>
</td></tr>
<tr><td><code id="bal.tab.weightit_+3A_weights">weights</code></td>
<td>
<p>a vector, list, or <code>data.frame</code> containing weights for each unit, or a string containing the names of the weights variables in <code>data</code>, or an object with a <code><a href="#topic+get.w">get.w()</a></code> method or a list thereof. The weights can be, e.g., inverse probability weights or matching weights resulting from a matching algorithm.</p>
</td></tr>
<tr><td><code id="bal.tab.weightit_+3A_cluster">cluster</code></td>
<td>
<p>either a vector containing cluster membership for each unit or a string containing the name of the cluster membership variable in <code>data</code> or the input object. See <code><a href="#topic+class-bal.tab.cluster">class-bal.tab.cluster</a></code> for details.</p>
</td></tr>
<tr><td><code id="bal.tab.weightit_+3A_imp">imp</code></td>
<td>
<p>either a vector containing imputation indices for each unit or a string containing the name of the imputation index variable in <code>data</code> or the input object. See <code><a href="#topic+class-bal.tab.imp">class-bal.tab.imp</a></code> for details. Not necessary if <code>data</code> is a <code>mids</code> object.</p>
</td></tr>
<tr><td><code id="bal.tab.weightit_+3A_pairwise">pairwise</code></td>
<td>
<p>whether balance should be computed for pairs of treatments or for each treatment against all groups combined. See <code><a href="#topic+class-bal.tab.multi">bal.tab.multi()</a></code> for details. This can also be used with a binary treatment to assess balance with respect to the full sample.</p>
</td></tr>
<tr><td><code id="bal.tab.weightit_+3A_s.weights">s.weights</code></td>
<td>
<p>Optional; either a vector containing sampling weights for each unit or a string containing the name of the sampling weight variable in <code>data</code>. These function like regular weights except that both the adjusted and unadjusted samples will be weighted according to these weights if weights are used. If <code>s.weights</code> was supplied in the call to <code>weightit()</code> or <code>weightitMSM()</code>, they will automatically be included and do not need be specified again (though there is no harm if they are).</p>
</td></tr>
<tr><td><code id="bal.tab.weightit_+3A_abs">abs</code></td>
<td>
<p><code>logical</code>; whether displayed balance statistics should be in absolute value or not.</p>
</td></tr>
<tr><td><code id="bal.tab.weightit_+3A_subset">subset</code></td>
<td>
<p>a <code>logical</code> or <code>numeric</code> vector denoting whether each observation should be included or which observations should be included. If <code>logical</code>, it should have length equal to the number of units. <code>NA</code>s will be treated as <code>FALSE</code>. This can be used as an alternative to <code>cluster</code> to examine balance on subsets of the data.</p>
</td></tr>
<tr><td><code id="bal.tab.weightit_+3A_quick">quick</code></td>
<td>
<p><code>logical</code>; if <code>TRUE</code>, will not compute any values that will not be displayed. Set to <code>FALSE</code> if computed values not displayed will be used later.</p>
</td></tr>
<tr><td><code id="bal.tab.weightit_+3A_...">...</code></td>
<td>
<p>for some input types, other arguments that are required or allowed. Otherwise, further arguments to control display of output. See <a href="#topic+display-options">display options</a> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bal.tab.weightit()</code> generates a list of balance summaries for the <code>weightit</code> object given.
</p>


<h3>Value</h3>

<p>For point treatments, if clusters and imputations are not specified, an object of class <code>"bal.tab"</code> containing balance summaries for the <code>weightit</code> object. See <code><a href="#topic+bal.tab">bal.tab()</a></code> for details.
</p>
<p>If imputations are specified, an object of class <code>"bal.tab.imp"</code> containing balance summaries for each imputation and a summary of balance across imputations. See <code><a href="#topic+class-bal.tab.imp">class-bal.tab.imp</a></code> for details.
</p>
<p>If <code>weightit()</code> is used with multi-category treatments, an object of class <code>"bal.tab.multi"</code> containing balance summaries for each pairwise treatment comparison. See <code><a href="#topic+class-bal.tab.multi">bal.tab.multi()</a></code> for details.
</p>
<p>If <code>weightitMSM()</code> is used for longitudinal treatments, an object of class <code>"bal.tab.msm"</code> containing balance summaries for each time period. See <code><a href="#topic+class-bal.tab.msm">class-bal.tab.msm</a></code> for details.
</p>
<p>If clusters are specified, an object of class <code>"bal.tab.cluster"</code> containing balance summaries within each cluster and a summary of balance across clusters. See <code><a href="#topic+class-bal.tab.cluster">class-bal.tab.cluster</a></code> for details.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+bal.tab">bal.tab()</a></code> for details of calculations.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
library(WeightIt)
data("lalonde", package = "cobalt")

## Basic propensity score weighting
w.out1 &lt;- weightit(treat ~ age + educ + race + 
                       married + nodegree + re74 + re75, 
                   data = lalonde, method = "glm")
bal.tab(w.out1, un = TRUE, m.threshold = .1, 
        v.threshold = 2)

## Weighting with a multi-category treatment
w.out2 &lt;- weightit(race ~ age + educ + married + 
                       nodegree + re74 + re75, 
                   data = lalonde, method = "glm",
                   estimand = "ATE")
bal.tab(w.out2, un = TRUE)
bal.tab(w.out2, un = TRUE, pairwise = FALSE)

## IPW for longitudinal treatments
data("msmdata", package = "WeightIt")

wmsm.out &lt;- weightitMSM(list(A_1 ~ X1_0 + X2_0,
                        A_2 ~ X1_1 + X2_1 +
                            A_1 + X1_0 + X2_0,
                        A_3 ~ X1_2 + X2_2 +
                            A_2 + X1_1 + X2_1 +
                            A_1 + X1_0 + X2_0),
                   data = msmdata,
                   method = "glm")
bal.tab(wmsm.out)

</code></pre>

<hr>
<h2 id='balance-statistics'>Balance Statistics in <code>bal.tab</code> and <code>love.plot</code></h2><span id='topic+balance-statistics'></span>

<h3>Description</h3>

<p><code><a href="#topic+bal.tab">bal.tab()</a></code> and <code><a href="#topic+love.plot">love.plot()</a></code> display balance statistics for the included covariates. The <code>stats</code> argument in each of these functions controls which balance statistics are to be displayed. The argument to <code>stats</code> should be a character vector with the names of the desired balance statistics.
</p>
<p>This page describes all of the available balance statistics and how to request them. Abbreviations are allowed, so you can use the first few letters of each balance statistics to request it instead of typing out its whole name. That convention is used throughout the documentation. For example, to request mean differences and variance ratios in <code>bal.tab()</code> or <code>love.plot()</code>, you could include <code>stats = c("m", "v")</code>. In addition, the <code>thresholds</code> argument uses the same naming conventions and can be used to request balance thresholds on each statistic. For example, to request a balance threshold of .1 for mean differences, you could include <code>thresholds = c(m = .1)</code>.
</p>
<p>Below, each allowable entry to <code>stats</code> and <code>thresholds</code> are described, along with other details or option that accompany them.
</p>


<h4>Binary/Multi-Category Treatments</h4>


<dl>
<dt><code>"mean.diffs"</code></dt><dd><p>Mean differences as computed by <code><a href="#topic+col_w_smd">col_w_smd()</a></code>. Can be abbreviated as <code>"m"</code>. Setting the arguments <code>continuous</code> and <code>binary</code> to either <code>"std"</code> or <code>"raw"</code> will determine whether standardized mean differences or raw mean differences are calculated for continuous and categorical variables, respectively. When standardized mean differences are requested, the <code>s.d.denom</code> argument controls how the standardization occurs. When <code>abs = TRUE</code>, negative values become positive. Mean differences are requested by default when no entry to <code>stats</code> is provided.</p>
</dd>
<dt><code>"variance.ratios"</code></dt><dd><p>Variance ratios as computed by <code><a href="#topic+col_w_vr">col_w_vr()</a></code>. Can be abbreviated as <code>"v"</code>. Will not be computed for binary variables. When <code>abs = TRUE</code>, values less than 1 will have their inverse taken. When used with <code>love.plot</code>, the x-axis scaled will be logged so that, e.g., .5 is as far away from 1 as 2 is.</p>
</dd>
<dt><code>"ks.statistics"</code></dt><dd><p>Kolmogorov-Smirnov (KS) statistics as computed by <code><a href="#topic+col_w_ks">col_w_ks()</a></code>.</p>
</dd>
<dt><code>"ovl.coefficients"</code></dt><dd><p>Overlapping (OVL) statistics as computed by <code><a href="#topic+col_w_ovl">col_w_ovl()</a></code>. Can be abbreviated as <code>"ovl"</code>. Additional arguments passed to <code>col_w_ovl()</code>, such as <code>integrate</code> or <code>bw</code>, can be supplied to <code>bal.tab()</code> or <code>love.plot()</code>.</p>
</dd>
</dl>




<h4>Continuous Treatments</h4>


<dl>
<dt><code>"correlations"</code></dt><dd><p>Pearson correlations as computed by <code><a href="#topic+col_w_cov">col_w_cov()</a></code>. Can be abbreviated as <code>"cor"</code>. Setting the arguments <code>continuous</code> and <code>binary</code> to either <code>"std"</code> or <code>"raw"</code> will determine whether correlations or covariances are calculated for continuous and categorical variables, respectively (they are both <code>"std"</code> by default). When correlations are requested, the <code>s.d.denom</code> argument controls how the standardization occurs. When <code>abs = TRUE</code>, negative values become positive. Pearson correlations are requested by default when no entry to <code>stats</code> is provided.</p>
</dd>
<dt><code>"spearman.correlations"</code></dt><dd><p>Spearman correlations as computed by <code><a href="#topic+col_w_cov">col_w_cov()</a></code>. Can be abbreviated as <code>"sp"</code>. All arguments are the same as those for <code>"correlations"</code>. When <code>abs = TRUE</code>, negative values become positive.</p>
</dd>
<dt><code>"mean.diffs.target"</code></dt><dd><p>Mean differences computed between the weighted and unweighted sample to ensure the weighted sample is representative of the original population. Can be abbreviated as <code>"m"</code>. Setting the arguments <code>continuous</code> and <code>binary</code> to either <code>"std"</code> or <code>"raw"</code> will determine whether standardized mean differences or raw mean differences are calculated for continuous and categorical variables, respectively. The standardization factor will be computed in the unweighted sample. When <code>abs = TRUE</code>, negative values become positive. This statistic is only computed for the adjusted samples.</p>
</dd>
<dt><code>"ks.statistics.target"</code></dt><dd><p>KS-statistics computed between the weighted and unweighted sample to ensure the weighted sample is representative of the original population. Can be abbreviated as <code>"ks"</code>. This statistic is only computed for the adjusted samples.</p>
</dd>
</dl>

<p>If a statistic is requested in <code>thresholds</code>, it will automatically be placed in <code>stats</code>. For example, <code>bal.tab(..., stats = "m", thresholds = c(v = 2))</code> will display both mean differences and variance ratios, and the variance ratios will have a balance threshold set to 2.
</p>



<h3>Examples</h3>

<pre><code class='language-R'>data(lalonde)

#Binary treatments
bal.tab(treat ~ age + educ + married + re74, data = lalonde,
        stats = c("m", "v", "ks"))
love.plot(treat ~ age + educ + married + re74, data = lalonde,
          stats = c("m", "v", "ks"), binary = "std",
          thresholds = c(m = .1, v = 2))

#Continuous treatments
bal.tab(re75 ~ age + educ + married + re74, data = lalonde,
        stats = c("cor", "sp"))
love.plot(re75 ~ age + educ + married + re74, data = lalonde,
          thresholds = c(cor = .1, sp = .1))

</code></pre>

<hr>
<h2 id='balance-summary'>Compute Balance and Summary Statistics for Covariates</h2><span id='topic+balance-summary'></span><span id='topic+col_w_mean'></span><span id='topic+col_w_sd'></span><span id='topic+col_w_smd'></span><span id='topic+col_w_vr'></span><span id='topic+col_w_ks'></span><span id='topic+col_w_ovl'></span><span id='topic+col_w_cov'></span><span id='topic+col_w_corr'></span>

<h3>Description</h3>

<p>These functions quickly compute balance statistics for the given covariates. These functions are used in <code><a href="#topic+bal.tab">bal.tab()</a></code>, but they are available for use in programming without having to call <code>bal.tab()</code> to get them.
</p>

<ul>
<li><p><code>col_w_mean()</code> computes the (weighted) means for a set of covariates and weights and is essentially a weighted version of <code><a href="base.html#topic+colMeans">colMeans()</a></code>.
</p>
</li>
<li><p><code>col_w_sd()</code> computes the (weighted) standard deviations for a set of covariates and weights.
</p>
</li>
<li><p><code>col_w_smd()</code> computes the (weighted) (absolute) (standardized) difference in means for a set of covariates, a binary treatment, and weights.
</p>
</li>
<li><p><code>col_w_vr()</code> computes the (weighted) variance ratio for a set of covariates, a binary treatment, and weights.
</p>
</li>
<li><p><code>col_w_ks()</code> computes the (weighted) Kolmogorov-Smirnov (KS) statistic for a set of covariates, a binary treatment, and weights.
</p>
</li>
<li><p><code>col_w_ovl()</code> computes the complement of the (weighted) overlapping coefficient compliment for a set of covariates, a binary treatment, and weights (based on Franklin et al, 2014).
</p>
</li>
<li><p><code>col_w_cov()</code> and <code>col_w_corr()</code> compute the (weighted) (absolute) treatment-covariate covariance or correlation for a set of covariates, a continuous treatment, and weights.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>col_w_mean(
  mat,
  weights = NULL,
  s.weights = NULL,
  subset = NULL,
  na.rm = TRUE,
  ...
)

col_w_sd(
  mat,
  weights = NULL,
  s.weights = NULL,
  bin.vars,
  subset = NULL,
  na.rm = TRUE,
  ...
)

col_w_smd(
  mat,
  treat,
  weights = NULL,
  std = TRUE,
  s.d.denom = "pooled",
  abs = FALSE,
  s.weights = NULL,
  bin.vars,
  subset = NULL,
  weighted.weights = weights,
  na.rm = TRUE,
  ...
)

col_w_vr(
  mat,
  treat,
  weights = NULL,
  abs = FALSE,
  s.weights = NULL,
  bin.vars,
  subset = NULL,
  na.rm = TRUE,
  ...
)

col_w_ks(
  mat,
  treat,
  weights = NULL,
  s.weights = NULL,
  bin.vars,
  subset = NULL,
  na.rm = TRUE,
  ...
)

col_w_ovl(
  mat,
  treat,
  weights = NULL,
  s.weights = NULL,
  bin.vars,
  integrate = FALSE,
  subset = NULL,
  na.rm = TRUE,
  ...
)

col_w_cov(
  mat,
  treat,
  weights = NULL,
  type = "pearson",
  std = FALSE,
  s.d.denom = "all",
  abs = FALSE,
  s.weights = NULL,
  bin.vars,
  subset = NULL,
  weighted.weights = weights,
  na.rm = TRUE,
  ...
)

col_w_corr(
  mat,
  treat,
  weights = NULL,
  type = "pearson",
  s.d.denom = "all",
  abs = FALSE,
  s.weights = NULL,
  bin.vars,
  subset = NULL,
  weighted.weights = weights,
  na.rm = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="balance-summary_+3A_mat">mat</code></td>
<td>
<p>a numeric matrix or a data frame containing the covariates for which the statistic is to be computed. If a data frame, <code><a href="#topic+splitfactor">splitfactor()</a></code> with <code>drop.first = "if2"</code> will be called if any character or factor variables are present. This can slow down the function, so it's generally best to supply a numeric matrix. If a numeric vector is supplied, it will be converted to a 1-column matrix first.</p>
</td></tr>
<tr><td><code id="balance-summary_+3A_weights">weights</code></td>
<td>
<p><code>numeric</code>; an optional set of weights used to compute the weighted statistics. If sampling weights are supplied through <code>s.weights</code>, the <code>weights</code> should not incorporate these weights, as <code>weights</code> and <code>s.weights</code> will be multiplied together prior to computing the weighted statistics.</p>
</td></tr>
<tr><td><code id="balance-summary_+3A_s.weights">s.weights</code></td>
<td>
<p><code>numeric</code>; an optional set of sampling weights used to compute the weighted statistics. If weights are supplied through <code>weights</code>, <code>weights</code> and <code>s.weights</code> will be multiplied together prior to computing the weighted statistics. Some functions use <code>s.weights</code> in a particular way; for others, supplying <code>weights</code> and <code>s.weights</code> is equivalent to supplying their product to either <code>weights</code> or <code>s.weights</code>. See Details.</p>
</td></tr>
<tr><td><code id="balance-summary_+3A_subset">subset</code></td>
<td>
<p>a <code>logical</code> vector with length equal to the number of rows of <code>mat</code> used to subset the data. See Details for notes on its use with <code>col_w_smd()</code>, <code>col_w_cov()</code>, and <code>col_w_corr()</code>.</p>
</td></tr>
<tr><td><code id="balance-summary_+3A_na.rm">na.rm</code></td>
<td>
<p><code>logical</code>; whether <code>NA</code>s should be ignored or not. If <code>FALSE</code>, any variable with any <code>NA</code>s will have its corresponding statistic returned as <code>NA</code>. If <code>TRUE</code>, any variable with any <code>NA</code>s will have its corresponding statistic computed as if the missing value were not there.</p>
</td></tr>
<tr><td><code id="balance-summary_+3A_...">...</code></td>
<td>
<p>for all functions, additional arguments supplied to <code><a href="#topic+splitfactor">splitfactor()</a></code> when <code>mat</code> is a data.frame. <code>data</code>, <code>var.name</code>, <code>drop.first</code>, and <code>drop.level</code> are ignored; <code>drop.first</code> is automatically set to <code>"if2"</code>. For <code>col_w_ovl()</code> and <code>col_w_ent()</code>, other arguments passed to <code><a href="stats.html#topic+density">density()</a></code> besides <code>x</code> and <code>weights</code>. Note that the default value for <code>bw</code> when unspecified is <code>"nrd"</code> rather than the default in <code>density()</code>, which is <code>"nrd0"</code>.</p>
</td></tr>
<tr><td><code id="balance-summary_+3A_bin.vars">bin.vars</code></td>
<td>
<p>a vector used to denote whether each variable is binary or not. Can be a <code>logical</code> vector with length equal to the number of columns of <code>mat</code> or a vector of numeric indices or character names of the binary variables. If missing (the default), the function will figure out which covariates are binary or not, which can increase computation time. If <code>NULL</code>, it will be assumed no variables are binary. All functions other than <code>col_w_mean()</code> treat binary variables different from continuous variables. If a factor or character variable is in <code>mat</code>, all the dummies created will automatically be marked as binary, but it should still receive an entry when <code>bin.vars</code> is supplied as <code>logical</code>.</p>
</td></tr>
<tr><td><code id="balance-summary_+3A_treat">treat</code></td>
<td>
<p>a vector of treatment status for each individual. For <code>col_w_smd()</code>, <code>col_w_vr()</code>, <code>col_w_ks()</code>, and <code>col_w_ovl()</code>, <code>treat</code> should have exactly two unique values. For <code>col_w_cov()</code> and <code>col_w_corr()</code>, <code>treat</code> should be a many-valued numeric vector.</p>
</td></tr>
<tr><td><code id="balance-summary_+3A_std">std</code></td>
<td>
<p><code>logical</code>; for <code>col_w_smd()</code>, whether the computed mean differences for each variable should be standardized; for <code>col_w_cov()</code>, whether treatment-covariate correlations should be computed (<code>TRUE</code>) rather than covariances (<code>FALSE</code>). Can be either length 1, whereby all variables will be standardized or not, or length equal to the number of columns of <code>mat</code>, whereby only variables with a value of <code>TRUE</code> will be standardized. See Details.</p>
</td></tr>
<tr><td><code id="balance-summary_+3A_s.d.denom">s.d.denom</code></td>
<td>
<p>for <code>col_w_smd()</code> and <code>col_w_cov()</code> when <code>std</code> is <code>TRUE</code> for some variables, and for <code>col_w_corr()</code>, how the standardization factor should be computed. For <code>col_w_smd()</code> (i.e., when computing standardized mean differences), allowable options include
</p>

<ul>
<li><p><code>"treated"</code> - uses the standard deviation of the variable in the treated group
</p>
</li>
<li><p><code>"control"</code> - uses the standard deviation of the variable in the control group
</p>
</li>
<li><p><code>"pooled"</code> - uses the square root of the average of the variances of the variable in the treated and control groups
</p>
</li>
<li><p><code>"all"</code> - uses the standard deviation of the variable in the full sample
</p>
</li>
<li><p><code>"weighted"</code> - uses the standard deviation of the variable in the full sample weighted by <code>weighted.weights</code>
</p>
</li>
<li><p><code>"hedges"</code> - uses the small-sample corrected version of Hedge's G described in the WWC Procedures Handbook (see References)
</p>
</li>
<li><p>the name of one of the treatment values - uses the standard deviation of the variable in that treatment group.
</p>
</li></ul>

<p>For <code>col_w_cov()</code> and <code>col_w_corr()</code>, only <code>"all"</code> and <code>"weighted"</code> are allowed. Abbreviations allowed. This can also be supplied as a numeric vector of standard deviations with length equal to the number of columns of <code>mat</code>; the values will be used as the standardization factors.</p>
</td></tr>
<tr><td><code id="balance-summary_+3A_abs">abs</code></td>
<td>
<p><code>logical</code>; for <code>col_w_smd()</code>, <code>col_w_cov()</code>, and <code>col_w_corr()</code>, whether the returned statistics should be in absolute value (<code>TRUE</code>) or not. For <code>col_w_vr()</code>, whether the ratio should always include the larger variance in the numerator, so that the ratio is always greater than or equal to 1. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="balance-summary_+3A_weighted.weights">weighted.weights</code></td>
<td>
<p>for <code>col_w_smd()</code>, <code>col_w_cov()</code>, and <code>col_w_corr()</code>, when <code>std = TRUE</code> and <code>s.d.denom = "weighted"</code>, a vector of weights to be applied to the computation of the denominator standard deviation. If not specified, will use the argument to <code>weights</code>. When <code>s.d.denom</code> is not <code>"weighted"</code>, this is ignored. The main purpose of this is to allow <code>weights</code> to be <code>NULL</code> while weighting the denominator standard deviations for assessing balance in the unweighted sample but using the standard deviations of the weighted sample.</p>
</td></tr>
<tr><td><code id="balance-summary_+3A_integrate">integrate</code></td>
<td>
<p><code>logical</code>; for <code>col_w_ovl()</code>, whether to use <code><a href="stats.html#topic+integrate">integrate()</a></code> to calculate the area of overlap or the distance between the densities, respectively. If <code>FALSE</code>, a midpoint Riemann sum with 1000 partitions will be used instead. The Riemann sum is a little slower and very slightly imprecise (unnoticibly in most contexts), but the integral can fail sometimes and thus is less stable. The default is to use the Riemann sum.</p>
</td></tr>
<tr><td><code id="balance-summary_+3A_type">type</code></td>
<td>
<p>for <code>col_w_cov()</code> and <code>col_w_corr()</code>, the type of covariance/correlation to be computed. Allowable options include <code>"pearson"</code> and <code>"spearman"</code>. When <code>"spearman"</code> is requested, the covariates and treatment are first turned into ranks using <code><a href="base.html#topic+rank">rank()</a></code> with <code>na.last = "keep"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>col_w_mean()</code> computes column weighted means for a matrix of variables. It is similar to <code><a href="base.html#topic+colMeans">colMeans()</a></code> but (optionally) incorporates weights. <code>weights</code> and <code>s.weights</code> are multiplied together prior to being used, and there is no distinction between them. This could be used to compute the weighted means of each covariate in the general population to examine the degree to which a weighting method has left the weighted samples resembling the original population.
</p>
<p><code>col_w_sd()</code> computes column weighted standard deviations for a matrix of variables. <code>weights</code> and <code>s.weights</code> are multiplied together prior to being used, and there is no distinction between them. The variance of binary variables is computed as <code class="reqn">p(1-p)</code>, where <code class="reqn">p</code> is the (weighted) proportion of 1s, while the variance of continuous variables is computed using the standard formula; the standard deviation is the square root of this variance.
</p>
<p><code>col_w_smd()</code> computes the mean difference for each covariate between treatment groups defined by <code>treat</code>. These mean differences can optionally be weighted, standardized, and/or in absolute value. The standardization factor is computed using the unweighted standard deviation or variance when <code>s.weights</code> are absent, and is computed using the <code>s.weights</code>-weighted standard deviation or variance when <code>s.weights</code> are present, except when <code>s.d.denom = "weighted"</code>, in which case the product of <code>weighted.weights</code> and <code>s.weights</code> (if present) are used to weight the standardization factor. The standardization factor is computed using the whole sample even when <code>subset</code> is used. Note that unlike <code>bal.tab()</code>, <code>col_w_smd()</code> requires the user to specify whether each individual variable should be standardized using <code>std</code> rather than relying on <code>continuous</code> or <code>binary</code>. The weighted mean difference is computed using the product of <code>weights</code> and <code>s.weights</code>, if specified. The variance of binary variables is computed as <code class="reqn">p(1-p)</code>, where <code class="reqn">p</code> is the (weighted) proportion of 1s, while the variance of continuous variables is computed using the standard formula.
</p>
<p><code>col_w_vr()</code> computes the variance ratio for each covariate between treatment groups defined by <code>treat</code>. When <code>abs = TRUE</code>, <code>pmax(out, 1/out)</code> is applied to the output so that the ratio is always greater than or equal to 1. For binary variables, the variance is computed as <code class="reqn">p(1-p)</code>, where <code class="reqn">p</code> is the (weighted) proportion of 1s, while the variance of continuous variables is computed using the standard formula. Note that in <code>bal.tab()</code>, variance ratios are not computed for binary variables, while here, they are (but likely should not be interpreted). <code>weights</code> and <code>s.weights</code> are multiplied together prior to being used, and there is no distinction between them. Because of how the weighted variance is computed, exactly balanced groups may have variance ratios that differ slightly from 1.
</p>
<p><code>col_w_ks()</code> computes the KS statistic for each covariate using the method implemented in <span class="pkg">twang</span>. The KS statistics can optionally be weighted. For binary variables, the KS statistic is just the difference in proportions. <code>weights</code> and <code>s.weights</code> are multiplied together prior to being used, and there is no distinction between them.
</p>
<p><code>col_w_ovl()</code> computes the complement of the overlapping coefficient as described by Franklin et al. (2014). It does so by computing the density of the covariate in the treated and control groups, then finding the area where those density overlap, and subtracting that number from 1, yielding a value between 0 and 1 where 1 indicates complete imbalance, and 0 indicates perfect balance. <code><a href="stats.html#topic+density">density()</a></code> is used to model the density in each group. The bandwidth of the covariate in the smaller treatment group is used for both groups. The area of overlap can be computed using <code>integrate</code>, which quickly and accurately computes the integral, or using a midpoint Riemann sum with 1000 partitions, which approximates the area more slowly. A reason to prefer the Riemann sum is that <code>integrate</code> can fail for unknown reasons, though Riemann sums will fail with some extreme distributions. When either method fails, the resulting value will be <code>NA</code>. For binary variables, the complement of the overlapping coefficient is just the difference in proportions. <code>weights</code> and <code>s.weights</code> are multiplied together prior to being used, and there is no distinction between them. The weights are used to compute the weighted density by supplying them to the <code>weights</code> argument of <code>density</code>.
</p>
<p><code>col_w_cov()</code> computes the covariance between a continuous treatment and the covariates to assess balance for continuous treatments as recommended in Austin (2019). These covariance can optionally be weighted or in absolute value or can be requested as correlations (i.e., standardized covariances). The correlations are computed as the covariance between the treatment and covariate divided by a standardization factor, which is equal to the square root of the product of the variance of treatment and the variance of the covariate. The standardization factor is computed using the unweighted variances when <code>s.weights</code> are absent, and is computed using the sampling weighted variances when <code>s.weights</code> are present, except when <code>s.d.denom = "weighted"</code>, in which case the product of <code>weighted.weights</code> and <code>s.weights</code> (if present) are used to weight the standardization factor. For this reason, the computed correlation can be greater than 1 or less than -1. The standardization factor is always computed using the whole sample even when <code>subset</code> is used. The covariance is computed using the product of <code>weights</code> and <code>s.weights</code>, if specified. The variance of binary variables is computed as <code class="reqn">p(1-p)</code>, where <code class="reqn">p</code> is the (weighted) proportion of 1s, while the variance of continuous variables is computed using the standard formula.
</p>
<p><code>col_w_corr()</code> is a wrapper for <code>col_w_cov</code> with <code>std</code> set to <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>A vector of balance statistics, one for each variable in <code>mat</code>. If <code>mat</code> has column names, the output will be named as well.
</p>


<h3>References</h3>

<p>Austin, P. C. (2019). Assessing covariate balance when using the generalized propensity score with quantitative or continuous exposures. <em>Statistical Methods in Medical Research</em>, 28(5), 13651377. <a href="https://doi.org/10.1177/0962280218756159">doi:10.1177/0962280218756159</a>
</p>
<p>Franklin, J. M., Rassen, J. A., Ackermann, D., Bartels, D. B., &amp; Schneeweiss, S. (2014). Metrics for covariate balance in cohort studies of causal effects. <em>Statistics in Medicine</em>, 33(10), 16851699. <a href="https://doi.org/10.1002/sim.6058">doi:10.1002/sim.6058</a>
</p>
<p>What Works Clearinghouse. (2020). WWC Procedures Handbook (Version 4.1). Retrieved from
<a href="https://ies.ed.gov/ncee/wwc/Handbooks">https://ies.ed.gov/ncee/wwc/Handbooks</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+bal.tab">bal.tab()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+bal.compute">bal.compute()</a></code>
</p>
</li>
<li> <p><a href="#topic+balance-statistics">balance-statistics</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
data("lalonde", package = "cobalt")

treat &lt;- lalonde$treat
covs &lt;- subset(lalonde, select = -c(treat, re78))
covs0 &lt;- splitfactor(covs, drop.first = "if2")
bin.vars &lt;- c(FALSE, FALSE, TRUE, TRUE, TRUE,
              TRUE, TRUE, FALSE, FALSE)
W &lt;- WeightIt::weightit(treat ~ covs, method = "glm", 
                        estimand = "ATE")
weights &lt;- W$weights

round(data.frame(
    m0 = col_w_mean(covs0, weights = weights, subset = treat == 0),
    sd0 = col_w_sd(covs0, weights = weights,
                   bin.vars = bin.vars, subset = treat == 0),
    m1 = col_w_mean(covs0, weights = weights, subset = treat == 1),
    sd1 = col_w_sd(covs0, weights = weights,
                   bin.vars = bin.vars, subset = treat == 1),
    smd = col_w_smd(covs0, treat = treat, weights = weights,
                    std = TRUE, bin.vars = bin.vars),
    vr = col_w_vr(covs0, treat = treat, weights = weights,
                  bin.vars = bin.vars),
    ks = col_w_ks(covs0, treat = treat, weights = weights,
                  bin.vars = bin.vars),
    row.names = colnames(covs0)
), 4)

# Compare to bal.tab():
bal.tab(covs, treat = treat, weights = weights,
        disp = c("m", "sd"), stats = c("m", "v", "ks"),
        estimand = "ATE", method = "weighting",
        binary = "std")


</code></pre>

<hr>
<h2 id='class-bal.tab.cluster'>Using <code>bal.tab()</code> with Clustered Data</h2><span id='topic+class-bal.tab.cluster'></span>

<h3>Description</h3>

<p>When using <code><a href="#topic+bal.tab">bal.tab()</a></code> with clustered data, the output will be different from the case with single-level data, and there are some options that are common across all <code>bal.tab()</code> methods. This page outlines the outputs and options in this case.
</p>
<p>There are two main components of the output of <code>bal.tab()</code> with clustered data: the within-cluster balance summaries and the across-cluster balance summary. The within-cluster balance summaries display balance for units within each cluster separately.
</p>
<p>The across-cluster balance summary pools information across the within-cluster balance summaries to simplify balance assessment. It provides a combination (e.g., mean or maximum) of each balance statistic for each covariate across all clusters. This allows you to see how bad the worst imbalance is and what balance looks like on average. The balance summary will not be computed if longitudinal treatments, multi-category treatments, or multiply imputed data are used.
</p>


<h3>Allowable arguments</h3>

<p>There are four arguments for each <code>bal.tab()</code> method that can handle clustered data: <code>cluster</code>, <code>which.cluster</code>, <code>cluster.summary</code>, and <code>cluster.fun</code>.
</p>

<dl>
<dt><code>cluster</code></dt><dd><p>A vector of cluster membership. This can be factor, character, or numeric vector. This argument is required to let <code>bal.tab()</code> know that the data is clustered. If a <code>data</code> argument is specified, this can also be the name of a variable in <code>data</code> that contains cluster membership.</p>
</dd>
<dt><code>which.cluster</code></dt><dd><p>This is a display option that does not affect computation. If <code>.all</code> (the default), all clusters in <code>cluster</code> will be displayed. If <code>.none</code>, no clusters will be displayed. Otherwise, can be a vector of cluster names or numerical indices for which to display balance. Indices correspond to the alphabetical order of cluster names (or the order of cluster levels if a factor).</p>
</dd>
<dt><code>cluster.summary</code></dt><dd><p>This is a display option that does not affect computation. If <code>TRUE</code>, the balance summary across clusters will be displayed. The default is <code>TRUE</code>, and if <code>which.cluster</code> is <code>.none</code>, it will automatically be set to <code>TRUE</code>.</p>
</dd>
<dt><code>cluster.fun</code></dt><dd><p>This is a display option that does not affect computation. Can be &quot;min&quot;, &quot;mean&quot;, or &quot;max&quot; and corresponds to which function is used in the across-cluster summary to combine results across clusters. For example, if <code>cluster.fun = "mean"</code> the mean balance statistic across clusters will be displayed. The default when <code>abs = FALSE</code> in the <code>bal.tab()</code> call is to display all three. The default when <code>abs = FALSE</code> in the <code>bal.tab()</code> call is to display just the mean and max balance statistic.
</p>
</dd>
</dl>



<h3>Output</h3>

<p>The output is a <code>bal.tab.cluster</code> object, which inherits from <code>bal.tab</code>. It has the following elements:
</p>

<ul>
<li> <p><code>Cluster.Balance</code>: For each cluster, a regular <code>bal.tab</code> object containing a balance table, a sample size summary, and other balance assessment tools, depending on which options are specified.
</p>
</li>
<li> <p><code>Cluster.Summary</code>: The balance summary across clusters. This will include the combination of each balance statistic for each covariate across all clusters according to the value of <code>cluster.fun</code>.
</p>
</li>
<li> <p><code>Observations</code>: A table of sample sizes or effective sample sizes for each cluster before and after adjustment.
</p>
</li></ul>

<p>As with other methods, multiple weights can be specified, and values for all weights will appear in all tables.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+bal.tab">bal.tab()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+bal.tab.data.frame">bal.tab.data.frame()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+print.bal.tab">print.bal.tab()</a></code>
</p>
</li>
<li> <p><code>vignette("segmented-data")</code> for examples
</p>
</li></ul>


<hr>
<h2 id='class-bal.tab.imp'>Using <code>bal.tab()</code> with Multiply Imputed Data</h2><span id='topic+class-bal.tab.imp'></span>

<h3>Description</h3>

<p>When using <code><a href="#topic+bal.tab">bal.tab()</a></code> with multiply imputed data, the output will be different from the case with a single data set. Multiply imputed data can be used with all <code>bal.tab()</code> methods, and the <code>mimids</code> and <code>wimids</code> methods for <span class="pkg">MatchThem</span> objects automatically incorporate multiply imputed data. This page outlines the outputs and options available with multiply imputed data.
</p>
<p>There are two main components of the output of <code>bal.tab()</code> with multiply imputed data: the within-imputation balance summaries and the across-imputation balance summary. The within-imputation balance summaries display balance for units within each imputed data set separately. In general, this will not be very useful because interest rarely lies in the qualities of any individual imputed data set.
</p>
<p>The across-imputation balance summary pools information across the within-imputation balance summaries to simplify balance assessment. It provides the average, smallest, and largest balance statistic for each covariate across all imputations. This allows you to see how bad the worst imbalance is and what balance looks like on average across the imputations. The summary behaves differently depending on whether <code>abs</code> is specified as <code>TRUE</code> or <code>FALSE</code>. When <code>abs = TRUE</code>, the across-imputation balance summary will display the mean absolute balance statistics and the maximum absolute balance statistics. When <code>abs = FALSE</code>, the across-imputation balance summary will display the minimum, mean, and maximum of the balance statistic in its original form.
</p>


<h3>Allowable arguments</h3>

<p>There are four arguments for each <code>bal.tab()</code> method that can handle multiply imputed data: <code>imp</code>, <code>which.imp</code>, <code>imp.summary</code>, and <code>imp.fun</code>.
</p>

<dl>
<dt><code>imp</code></dt><dd><p>A vector of imputation membership. This can be factor, character, or numeric vector. This argument is required to let <code>bal.tab()</code> know that the data is multiply imputed unless <span class="pkg">MatchThem</span> objects are used. If a <code>data</code> argument is specified, this can also be the name of a variable in <code>data</code> that contains imputation membership. If the <code>data</code> argument is a <code>mids</code> object, the output of a call to <code>mice()</code>, <code>imp</code> does not need to be specified and will automatically be extracted from the <code>mids</code> object.</p>
</dd>
<dt><code>which.imp</code></dt><dd><p>This is a display option that does not affect computation. If <code>.all</code>, all imputations in <code>imp</code> will be displayed. If <code>.none</code> (the default), no imputations will be displayed. Otherwise, can be a vector of imputation indices for which to display balance.</p>
</dd>
<dt><code>imp.summary</code></dt><dd><p>This is a display option that does not affect computation. If <code>TRUE</code>, the balance summary across imputations will be displayed. The default is <code>TRUE</code>, and if <code>which.imp</code> is <code>.none</code>, it will automatically be set to <code>TRUE</code>.</p>
</dd>
<dt><code>imp.fun</code></dt><dd><p>This is a display option that does not affect computation. Can be &quot;min&quot;, &quot;mean&quot;, or &quot;max&quot; and corresponds to which function is used in the across-imputation summary to combine results across imputations. For example, if <code>imp.fun = "mean"</code> the mean balance statistic across imputations will be displayed. The default when <code>abs = FALSE</code> in the <code>bal.tab()</code> call is to display all three. The default when <code>abs = FALSE</code> in the <code>bal.tab()</code> call is to display just the mean and max balance statistic.
</p>
</dd>
</dl>



<h3>Output</h3>

<p>The output is a <code>bal.tab.imp</code> object, which inherits from <code>bal.tab</code>. It has the following elements:
</p>

<ul>
<li> <p><code>Imputation.Balance</code>: For each imputation, a regular <code>bal.tab</code> object containing a balance table, a sample size summary, and other balance assessment tools, depending on which options are specified.
</p>
</li>
<li> <p><code>Balance.Across.Imputations</code>: The balance summary across imputations. This will include the combination of each balance statistic for each covariate across all imputations according to the value of <code>imp.fun</code>.
</p>
</li>
<li> <p><code>Observations</code>: A table of sample sizes or effective sample sizes averaged across imputations before and after adjustment.
</p>
</li></ul>

<p>As with other methods, multiple weights can be specified, and values for all weights will appear in all tables.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+bal.tab">bal.tab()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+bal.tab.data.frame">bal.tab.data.frame()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+print.bal.tab">print.bal.tab()</a></code>
</p>
</li>
<li> <p><code>vignette("segmented-data")</code> for examples
</p>
</li></ul>


<hr>
<h2 id='class-bal.tab.msm'>Using <code>bal.tab()</code> with Longitudinal Treatments</h2><span id='topic+class-bal.tab.msm'></span>

<h3>Description</h3>

<div class="sourceCode"><pre>When using [bal.tab()] with longitudinal treatments, the output will be different from the case with point treatments, and there are some options that are common across all `bal.tab()` methods for dealing with longitudinal data. This page outlines the outputs and options in this case.

There are two main components of the output of `bal.tab()` with longitudinal treatments: the time-point-specific balance summary and across-time-points balance summary. The time-point-specific balance summaries are standard point treatment balance summaries at each time point.

The across-time-points balance summary is, for each variable, the greatest imbalance across all time-point-specific balance summaries. If the greatest observed imbalance is tolerable, then all other imbalances for that variable will be tolerable too, so focusing on reducing the greatest imbalance is sufficient for reducing imbalance overall. The balance summary will not be computed if multi-category treatments or multiply imputed data are used.
</pre></div>


<h3>Allowable arguments</h3>

<p>There are two additional arguments for each <code>bal.tab()</code> method that can handle longitudinal treatments: <code>which.time</code> and <code>msm.summary</code>.
</p>

<dl>
<dt><code>which.time</code></dt><dd><p>This is a display option that does not affect computation. If <code>.all</code> (the default), all time points will be displayed. If <code>.none</code>, no time points will be displayed. Otherwise, can be a vector of treatment names or indices for which to display balance.</p>
</dd>
<dt><code>msm.summary</code></dt><dd><p>This is a display option that does not affect computation. If <code>TRUE</code>, the balance summary across time points will be displayed. The default is <code>TRUE</code>, and if <code>which.time</code> is <code>.none</code>, it will automatically be set to <code>TRUE</code>.</p>
</dd>
</dl>



<h3>Output</h3>

<p>The output is a <code>bal.tab.msm</code> object, which inherits from <code>bal.tab</code>. It has the following elements:
</p>

<ul>
<li> <p><code>Time.Balance</code>: For each time point, a regular <code>bal.tab</code> object containing a balance table, a sample size summary, and other balance assessment tools, depending on which options are specified.
</p>
</li>
<li> <p><code>Balance.Across.Times</code>: The balance summary across time points. This will include the maximum balance statistic(s) for each covariate across all time points.
</p>
</li>
<li> <p><code>Observations</code>: A table of sample sizes or effective sample sizes for each time point before and after adjustment.
</p>
</li></ul>

<p>As with other methods, multiple weights can be specified, and values for all weights will appear in all tables.
</p>


<h3>Note</h3>

<p>The balance tables presented here are not the same as those recommended by Jackson (2016) and computed in his R package, <a href="https://CRAN.R-project.org/package=confoundr"><span class="pkg">confoundr</span></a>, as these do not take into account treatment history. The balance statistics presented here should be used with caution and may not reflect balance in an accurate way.
</p>


<h3>References</h3>

<p>Jackson, J. W. (2016). Diagnostics for Confounding of Time-varying and Other Joint Exposures: <em>Epidemiology</em>, 27(6), 859869. <a href="https://doi.org/10.1097/EDE.0000000000000547">doi:10.1097/EDE.0000000000000547</a>
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+bal.tab">bal.tab()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+bal.tab.time.list">bal.tab.time.list()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+print.bal.tab">print.bal.tab()</a></code>
</p>
</li>
<li> <p><code>vignette("longitudinal-treat")</code> for examples
</p>
</li></ul>


<hr>
<h2 id='class-bal.tab.multi'>Using <code>bal.tab()</code> with Multi-Category Treatments</h2><span id='topic+class-bal.tab.multi'></span>

<h3>Description</h3>

<p>When using <code><a href="#topic+bal.tab">bal.tab()</a></code> with multi-category treatments, the output will be different from the case with binary or continuous treatments, and there are some options that are common across all <code>bal.tab()</code> methods. This page outlines the outputs and options in this case.
</p>
<p>There are two main components of the output of <code>bal.tab()</code> with multi-category treatments: the two-group treatment comparisons and the balance summary. The two-group treatment comparisons are standard binary treatment comparison either for pairs of groups (e.g., for treatments A, B, and C, &quot;A vs. B&quot;, &quot;A vs. C&quot;, and &quot;B vs. C&quot;) or each group against all the groups (i.e., the entire sample).
</p>
<p>The balance summary is, for each variable, the greatest imbalance across all two-group comparisons. So, for variable X1, if &quot;A vs. B&quot; had a standardized mean difference of 0.52, &quot;A vs. C&quot; had a standardized mean difference of .17,  and &quot;B vs. C&quot; had a standardized mean difference of .35, the balance summary would have 0.52 for the value of the standardized mean difference for X1. The same goes for other variables and other measures of balance. If the greatest observed imbalance is tolerable, then all other imbalances for that variable will be tolerable too, so focusing on reducing the greatest imbalance is sufficient for reducing imbalance overall. (Note that when <code>s.d.denom = "pooled"</code>, i.e., when the estimand is the ATE, the pooled standard deviation in the denominator will be the average of the standard deviations across all treatment groups, not just those used in the pairwise comparison.) The balance summary will not be computed if multiply imputed data are used.
</p>


<h3>Allowable arguments</h3>

<p>There are four arguments for each <code>bal.tab()</code> method that can handle multi-category treatments: <code>pairwise</code>, <code>focal</code>, <code>which.treat</code>, and <code>multi.summary</code>.
</p>

<dl>
<dt><code>pairwise</code></dt><dd>
<p>Whether to compute the two-group comparisons pairwise or not. If <code>TRUE</code>, <code>bal.tab()</code> will compute comparisons for each pair of treatments. This can be valuable if treatments are to be compared with one another (which is often the case). If <code>FALSE</code>, <code>bal.tab()</code> will compute balance for each treatment group against the full unadjusted sample when <code>focal</code> is <code>NULL</code> and for each non-focal group against the focal group otherwise.
</p>
</dd>
<dt><code>focal</code></dt><dd>
<p>When one group is to be compared to multiple control groups in an ATT analysis, the group considered &quot;treated&quot; is the focal group. By specifying the name or index of the treatment condition considered focal, <code>bal.tab()</code> will only compute and display pairwise balance for treatment comparisons that include the focal group when <code>pairwise = FALSE</code>.
</p>
</dd>
<dt><code>which.treat</code></dt><dd>
<p>This is a display option that does not affect computation. When displaying the <code>bal.tab</code> output, which treatments should be displayed? If a vector of length 1 is entered, all comparisons involving that treatment group will be displayed. If a vector of length 2 or more is entered, all comparisons involving treatments that both appear in the input will be displayed. For example, inputting <code>"A"</code> will display &quot;A vs. B&quot; and &quot;A vs. C&quot;, while entering <code>c("A", "B")</code> will only display &quot;A vs. B&quot;. <code>.none</code> indicates no treatment comparisons will be displayed, and <code>.all</code> indicates all treatment comparisons will be displayed. <code>.none</code> is the default.
</p>
</dd>
<dt><code>multi.summary</code></dt><dd>
<p>If <code>TRUE</code>, the balance summary across all comparisons will be computed and displayed. This includes one row for each covariate with maximum balance statistic across all pairwise comparisons. Note that, if variance ratios or KS statistics are requested in addition to mean differences, the displayed values may not come from the same pairwise comparisons; that is, the greatest standardized mean difference and the greatest variance ratio may not come from the same comparison. The default is <code>TRUE</code>, and if <code>which.treat</code> is <code>.none</code>, it will automatically be set to <code>TRUE</code>.
</p>
</dd>
</dl>



<h3>Output</h3>

<p>The output is a <code>bal.tab.multi</code> object, which inherits from <code>bal.tab</code>. It has the following elements:
</p>

<ul>
<li> <p><code>Pair.Balance</code>:For each pair of treatment groups, a regular <code>bal.tab</code> object containing a balance table, a sample size summary, and other balance assessment tools, depending on which options are specified. If <code>pairwise</code> is <code>FALSE</code>, the comparisons will be between each group and the groups combined (labeled &quot;All&quot;) when <code>focal</code> is <code>NULL</code> and between each non-focal group and the focal group otherwise.
</p>
</li>
<li> <p><code>Balance.Across.Pairs</code>: The balance summary across two-group comparisons. This will include the greatest (i.e., maximum) absolute balance statistics(s) for each covariate across all comparisons computed. Thresholds can be requested for each balance measure as with binary treatments.
</p>
</li>
<li> <p><code>Observations</code>: A table of sample sizes or effective sample sizes for each treatment group before and after adjustment.
</p>
</li></ul>

<p>As with other methods, multiple weights can be specified, and values for all weights will appear in all tables.
</p>


<h3>Note</h3>

<p>In versions 4.3.1 and earlier, setting <code>pairwise = FALSE</code> would compare each group to the full adjusted sample. Now, each group is compared to the full <em>un</em>adjusted sample (unadjusted except for <code>s.weights</code>, if supplied).
</p>
<p>In versions 4.3.1 and earlier, <code>pairwise</code> was ignored with non-<code>NULL</code> <code>focal</code> and was automatically set to <code>FALSE</code>. <code>pairwise</code> can be specified and its default is now <code>TRUE</code>, so balance between all treatment groups will be computed by default rather than only between each non-group and the focal group. To recover previous functionality, set <code>pairwise = FALSE</code> with non-<code>NULL</code> <code>focal</code>.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+bal.tab">bal.tab()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+bal.tab.data.frame">bal.tab.data.frame()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+print.bal.tab">print.bal.tab()</a></code>
</p>
</li>
<li> <p><code>vignette("segmented-data")</code> for examples
</p>
</li></ul>


<hr>
<h2 id='class-bal.tab.subclass'>Using <code>bal.tab()</code> with Subclassified Data</h2><span id='topic+class-bal.tab.subclass'></span>

<h3>Description</h3>

<p>When using <code><a href="#topic+bal.tab">bal.tab()</a></code> with subclassified data, i.e., data split into subclasses where balance may hold, the output will be different from the standard, non-subclassified case, and there is an additional option for controlling display. This page outlines the outputs and options in this case.
</p>
<p>There are two main components of the output of <code>bal.tab()</code> with subclassified data: the balance within subclasses and the balance summary across subclasses. The within-subclass balance displays essentially are standard balance displays for each subclass, except that only &quot;adjusted&quot; values are available, because the subclassification itself is the adjustment.
</p>
<p>The balance summary is, for each variable, like a weighted average of the balance statistics across subclasses. This is computed internally by assigning each individual a weight based on their subclass and treatment group membership and then computing weighted balance statistics as usual with these weights. This summary is the same one would get if subclasses were supplied to the <code>match.strata</code> argument rather than to <code>subclass</code>. Because the means and mean differences are additive, their computed values will be weighted averages of the subclass-specific values, but for other statistics, the computed values will not be.
</p>


<h3>Allowable arguments</h3>

<p>There are three arguments for <code>bal.tab()</code> that relate to subclasses: <code>subclass</code>, <code>which.subclass</code>, and <code>subclass.summary</code>.
</p>

<dl>
<dt><code>subclass</code></dt><dd><p>For the <code>data.frame</code> and formula methods of <code>bal.tab()</code>, a vector of subclass membership or the name of the variable in <code>data</code> containing subclass membership. When using subclassification with a function compatible with <span class="pkg">cobalt</span>, such as <code>matchit()</code> in <span class="pkg">MatchIt</span>, this argument can be omitted because the subclasses are in the output object.</p>
</dd>
<dt><code>which.subclass</code></dt><dd><p>This is a display option that does not affect computation. If <code>.all</code>, all subclasses in <code>subclass</code> will be displayed. If <code>.none</code> (the default), no subclasses will be displayed. Otherwise, can be a vector of subclass indices for which to display balance.</p>
</dd>
<dt><code>subclass.summary</code></dt><dd><p>This is a display option that does not affect computation. If <code>TRUE</code>, the balance summary across subclasses will be displayed. The default is <code>TRUE</code>, and if <code>which.subclass</code> is <code>.none</code>, it will automatically be set to <code>TRUE</code>.</p>
</dd>
</dl>



<h3>Output</h3>

<p>The output is a <code>bal.tab.subclass</code> object, which inherits from <code>bal.tab</code>. It has the following elements:
</p>

<ul>
<li> <p><code>Subclass.Balance</code>: A list of data frames containing balance information for each covariate in each subclass.
</p>
</li>
<li> <p><code>Balance.Across.Subclass</code>: A data frame containing balance statistics for each covariate aggregated across subclasses and for the original sample (i.e., unadjusted). See <code><a href="#topic+bal.tab">bal.tab()</a></code> for details on what this includes.
</p>
</li>
<li> <p><code>Observations</code>: A table of sample sizes in each subclass and overall.
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li> <p><code><a href="#topic+bal.tab">bal.tab()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+bal.tab.data.frame">bal.tab.data.frame()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+print.bal.tab">print.bal.tab()</a></code>
</p>
</li></ul>


<hr>
<h2 id='display-options'>Options for Displaying <code>bal.tab()</code> Output</h2><span id='topic+display-options'></span>

<h3>Description</h3>

<p>Several additional arguments can be passed to <code><a href="#topic+bal.tab">bal.tab()</a></code> that control the display of the output; these arguments are documented here. Not all arguments are applicable to all uses of <code>bal.tab()</code>; for example, <code>which.subclass</code>, which controls which subclasses are displayed when subclassification is used, won't do anything when subclassification is not used. Note that when <code>quick = TRUE</code> is set in the call to <code>bal.tab()</code> (which is the default), setting any of these arguments to <code>FALSE</code> can prevent some values from being computed, which can have unintended effects.
</p>


<h3>Allowed arguments</h3>


<dl>
<dt><code>disp.bal.tab</code></dt><dd><p><code>logical</code>; whether to display the table of balance statistics. Default is <code>TRUE</code>, so the balance table is displayed.
</p>
</dd>
<dt><code>imbalanced.only</code></dt><dd><p><code>logical</code>; whether to display only the covariates that failed to meet at least one of balance thresholds. Default is <code>FALSE</code>, so all covariates are displayed.
</p>
</dd>
<dt><code>un</code></dt><dd><p><code>logical</code>; whether to print statistics for the unadjusted sample as well as for the adjusted sample. Default is <code>FALSE</code>, so only the statistics for the adjusted sample are displayed.
</p>
</dd>
<dt><code>disp</code></dt><dd><p><code>character</code>; which distribution summary statistic(s) should be reported. Allowable options include <code>"means"</code> and <code>"sds"</code>. Multiple options are allowed. Abbreviations allowed.
</p>
</dd>
<dt><code>stats</code></dt><dd><p><code>character</code>; which statistic(s) should be reported. See <code><a href="#topic+balance-statistics">stats</a></code> to see which options are available. Multiple options are allowed. Abbreviations allowed. For binary and multi-category treatments, the default is <code>"mean.diffs"</code> (i.e., [standardized] mean differences), and for continuous treatments, the default is <code>"correlations"</code> (i.e., treatment-covariate Pearson correlations).
</p>
</dd>
<dt><code>factor_sep</code></dt><dd><p><code>character</code>; the string used to separate factor variables from their levels when variable names are printed. Default is <code>"_"</code>.
</p>
</dd>
<dt><code>int_sep</code></dt><dd><p><code>character</code>; the string used to separate two variables involved in an interaction when variable names are printed. Default is <code>" * "</code>. Older versions of <span class="pkg">cobalt</span> used <code>"_"</code>.
</p>
</dd>
<dt><code>disp.call</code></dt><dd><p><code>logical</code>; whether to display the function call from the original input object, if present. Default is <code>FALSE</code>, so the function call is not displayed.
</p>
</dd>
</dl>



<h4>When subclassification is used</h4>


<dl>
<dt><code>which.subclass</code></dt><dd><p>Which subclasses (if any) should be displayed. If <code>.all</code>, all subclasses will be displayed. If <code>.none</code> (the default), no subclasses will be displayed. Otherwise, can be a vector of subclass indices for which to display balance.
</p>
</dd>
<dt><code>subclass.summary</code></dt><dd><p><code>logical</code>; whether to display the balance summary across subclasses. If <code>TRUE</code>, the balance summary across subclasses will be displayed. The default is <code>TRUE</code>, and if <code>which.subclass</code> is <code>.none</code>, it will automatically be set to <code>TRUE</code>.
</p>
</dd>
</dl>




<h4>When the treatment is multi-category</h4>


<dl>
<dt><code>which.treat</code></dt><dd><p>For which treatments or treatment combinations balance tables should be displayed. If a vector of length 1 is entered, all comparisons involving that treatment group will be displayed. If a vector of length 2 or more is entered, all comparisons involving treatments that both appear in the input will be displayed. For example, setting  <code>which.treat = "A"</code> will display &quot;A vs. B&quot; and &quot;A vs. C&quot;, while setting <code>which.treat = c("A", "B")</code> will only display &quot;A vs. B&quot;. <code>.none</code> indicates no treatment comparisons will be displayed, and <code>.all</code> indicates all treatment comparisons will be displayed. Default is <code>.none</code>. See <code><a href="#topic+class-bal.tab.multi">bal.tab.multi()</a></code>.
</p>
</dd>
<dt><code>multi.summary</code></dt><dd><p><code>logical</code>; whether to display the balance summary across all treatment pairs. This includes one row for each covariate with maximum balance statistic across all pairwise comparisons. Note that, if variance ratios or KS statistics are requested, the displayed values may not come from the same pairwise comparisons; that is, the greatest standardized mean difference and the greatest variance ratio may not come from the same comparison. Default is <code>TRUE</code> when <code>which.treat</code> is <code>.none</code> and <code>FALSE</code> otherwise. See <code><a href="#topic+class-bal.tab.multi">bal.tab.multi()</a></code>.
</p>
</dd>
</dl>




<h4>When clusters are present</h4>


<dl>
<dt><code>which.cluster</code></dt><dd><p>For which clusters balance tables should be displayed. If <code>.all</code>, all clusters in <code>cluster</code> will be displayed. If <code>.none</code>, no clusters will be displayed. Otherwise, can be a vector of cluster names or numerical indices for which to display balance. Indices correspond to the alphabetical order of cluster names (or the order of cluster levels if a factor). Default is <code>.all</code>. See <code><a href="#topic+class-bal.tab.cluster">class-bal.tab.cluster</a></code>.
</p>
</dd>
<dt><code>cluster.summary</code></dt><dd><p><code>logical</code>; whether to display the balance summary across clusters. Default is <code>TRUE</code> when <code>which.cluster</code> is <code>.none</code> and <code>FALSE</code> otherwise (note the default for <code>which.cluster</code> is <code>.all</code>). See <code><a href="#topic+class-bal.tab.cluster">class-bal.tab.cluster</a></code>.
</p>
</dd>
<dt><code>cluster.fun</code></dt><dd><p>Which function is used in the across-cluster summary to combine results across clusters. Can be &quot;min&quot;, &quot;mean&quot;, or &quot;max&quot;. For example, if <code>cluster.fun = "mean"</code> the mean balance statistic across clusters will be displayed. The default when <code>abs = FALSE</code> in the <code>bal.tab()</code> call is to display all three. The default when <code>abs = FALSE</code> in the <code>bal.tab()</code> call is to display just the mean and max balance statistic. See <code><a href="#topic+class-bal.tab.cluster">class-bal.tab.cluster</a></code>.
</p>
</dd>
</dl>




<h4>When multiple imputations are present</h4>


<dl>
<dt><code>which.imp</code></dt><dd><p>For which imputations balance tables should be displayed. If <code>.all</code>, all imputations in <code>imp</code> will be displayed. If <code>.none</code>, no imputations will be displayed. Otherwise, can be a vector of imputation indices for which to display balance. Default is <code>.none</code>. See <code><a href="#topic+class-bal.tab.imp">class-bal.tab.imp</a></code>.
</p>
</dd>
<dt><code>imp.summary</code></dt><dd><p><code>logical</code>; whether to display the balance summary across imputations. Default is <code>TRUE</code> when <code>which.imp</code> is <code>.none</code> and <code>FALSE</code> otherwise. See <code><a href="#topic+class-bal.tab.imp">class-bal.tab.imp</a></code>.
</p>
</dd>
<dt><code>imp.fun</code></dt><dd><p>Which function is used in the across-imputation summary to combine results across imputations. Can be &quot;min&quot;, &quot;mean&quot;, or &quot;max&quot;. For example, if <code>imp.fun = "mean"</code> the mean balance statistic across imputations will be displayed. The default when <code>abs = FALSE</code> in the <code>bal.tab()</code> call is to display all three. The default when <code>abs = FALSE</code> in the <code>bal.tab()</code> call is to display just the mean and max balance statistic. See <code><a href="#topic+class-bal.tab.imp">class-bal.tab.imp</a></code>.
</p>
</dd>
</dl>




<h4>When the treatment is longitudinal</h4>


<dl>
<dt><code>which.time</code></dt><dd><p>For which time points balance tables should be displayed. If <code>.all</code>, all time points will be displayed. If <code>.none</code>, no time points will be displayed. Otherwise, can be a vector of treatment names or indices for which to display balance. Default is <code>.none</code>. See <code><a href="#topic+class-bal.tab.msm">class-bal.tab.msm</a></code>.
</p>
</dd>
<dt><code>msm.summary</code></dt><dd><p><code>logical</code>; whether to display the balance summary across time points. Default is <code>TRUE</code> when <code>which.time</code> is <code>.none</code> and <code>FALSE</code> otherwise. See <code><a href="#topic+class-bal.tab.msm">class-bal.tab.msm</a></code>.
</p>
</dd>
</dl>




<h3>Setting options globally</h3>

<p>In addition to being able to be specified as arguments, if you find you frequently set a display option to something other than its default, you can set that as a global option (for the present R session) using <code><a href="#topic+set.cobalt.options">set.cobalt.options()</a></code> and retrieve it using <code><a href="#topic+get.cobalt.options">get.cobalt.options()</a></code>. Note that global options cannot be set for <code>which.subclass</code>, <code>which.cluster</code>, <code>which.imp</code>, <code>which.treat</code>, or <code>which.time</code>.
</p>


<h3>Note</h3>

<p>When calling <code>bal.tab()</code> using <code><a href="base.html#topic+do.call">do.call()</a></code>, if you are using <code>.all</code> or <code>.none</code> as inputs to arguments, you need to use <code><a href="base.html#topic+alist">alist()</a></code> rather than <code><a href="base.html#topic+list">list()</a></code> to group the arguments. For example, <code>do.call(bal.tab, list(., which.cluster = .none))</code> will produce an error, but <code>do.call(bal.tab, alist(., which.cluster = .none))</code> should work correctly.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bal.tab">bal.tab()</a></code>, <code><a href="#topic+print.bal.tab">print.bal.tab()</a></code>
</p>

<hr>
<h2 id='f.build'>Convenient Formula Generation</h2><span id='topic+f.build'></span>

<h3>Description</h3>

<p><code>f.build()</code> returns a <code><a href="stats.html#topic+formula">formula</a></code> of the form <code>y ~ x1 + x2 + ...</code> from a data frame input. It can be much quicker to use <code>f.build()</code> than to hand-write the precise formula, which may contain errors. It can be used in place of a formula in, for example, <code><a href="stats.html#topic+glm">glm()</a></code>, <code>matchit()</code>, or <code><a href="#topic+bal.tab">bal.tab()</a></code>. It provides similar functionality to <code><a href="stats.html#topic+reformulate">reformulate()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f.build(y = NULL, rhs = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f.build_+3A_y">y</code></td>
<td>
<p>the quoted name of the response (left hand side) variable in the formula. Only one variable is supported. If missing, <code>NULL</code>, or the empty string (<code>""</code>), the formula will have no response variable. If <code>rhs</code> is not supplied, <code>y</code> will replace <code>rhs</code> and <code>y</code> will be set to <code>""</code>.</p>
</td></tr>
<tr><td><code id="f.build_+3A_rhs">rhs</code></td>
<td>
<p>a data frame whose variable names will be the terms on the right hand side of the formula, or a character vector whose values will be the terms on the right hand side of the formula. If missing, the argument to <code>y</code> will replace <code>rhs</code> and <code>y</code> will be set to <code>""</code>; in essence, <code>f.build("x")</code> is the same as <code>f.build("", "x")</code>, both producing <code>~ x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>formula</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+reformulate">reformulate()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(lalonde)
covs &lt;- subset(lalonde, select = -c(treat, re78))
lm(f.build("treat", covs), data = lalonde)
</code></pre>

<hr>
<h2 id='get.w'>Extract Weights from Preprocessing Objects</h2><span id='topic+get.w'></span><span id='topic+get.w.matchit'></span><span id='topic+get.w.ps'></span><span id='topic+get.w.mnps'></span><span id='topic+get.w.ps.cont'></span><span id='topic+get.w.iptw'></span><span id='topic+get.w.Match'></span><span id='topic+get.w.CBPS'></span><span id='topic+get.w.CBMSM'></span><span id='topic+get.w.ebalance'></span><span id='topic+get.w.optmatch'></span><span id='topic+get.w.cem.match'></span><span id='topic+get.w.weightit'></span><span id='topic+get.w.designmatch'></span><span id='topic+get.w.mimids'></span><span id='topic+get.w.wimids'></span><span id='topic+get.w.sbwcau'></span>

<h3>Description</h3>

<p>Extracts weights from the outputs of preprocessing functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.w(x, ...)

## S3 method for class 'matchit'
get.w(x, ...)

## S3 method for class 'ps'
get.w(x, stop.method = NULL, estimand, s.weights = FALSE, ...)

## S3 method for class 'mnps'
get.w(x, stop.method = NULL, s.weights = FALSE, ...)

## S3 method for class 'ps.cont'
get.w(x, s.weights = FALSE, ...)

## S3 method for class 'iptw'
get.w(x, stop.method = NULL, s.weights = FALSE, ...)

## S3 method for class 'Match'
get.w(x, ...)

## S3 method for class 'CBPS'
get.w(x, estimand, ...)

## S3 method for class 'CBMSM'
get.w(x, ...)

## S3 method for class 'ebalance'
get.w(x, treat, ...)

## S3 method for class 'optmatch'
get.w(x, estimand, ...)

## S3 method for class 'cem.match'
get.w(x, estimand, ...)

## S3 method for class 'weightit'
get.w(x, s.weights = FALSE, ...)

## S3 method for class 'designmatch'
get.w(x, treat, estimand, ...)

## S3 method for class 'mimids'
get.w(x, ...)

## S3 method for class 'wimids'
get.w(x, ...)

## S3 method for class 'sbwcau'
get.w(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get.w_+3A_x">x</code></td>
<td>
<p>output from the corresponding preprocessing packages.</p>
</td></tr>
<tr><td><code id="get.w_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods.</p>
</td></tr>
<tr><td><code id="get.w_+3A_stop.method">stop.method</code></td>
<td>
<p>the name of the stop method used in the original call to <code>ps()</code> or <code>mnps()</code> in <span class="pkg">twang</span>, e.g., <code>"es.mean"</code>. If empty, will return weights from all stop method available into a data.frame. Abbreviations allowed.</p>
</td></tr>
<tr><td><code id="get.w_+3A_estimand">estimand</code></td>
<td>
<p>if weights are computed using the propensity score (i.e., for the <code>ps</code> and <code>CBPS</code> methods), which estimand to use to compute the weights. If <code>"ATE"</code>, weights will be computed as <code>1/ps</code> for the treated group and <code>1/(1-ps)</code> for the control group. If <code>"ATT"</code>, weights will be computed as <code>1</code> for the treated group and <code>ps/(1-ps)</code> for the control group. If not specified, <code>get.w()</code> will try to figure out which estimand is desired based on the object.
</p>
<p>If weights are computed using subclasses/matching strata (i.e., for the <code>cem</code> and <code>designmatch</code> methods), which estimand to use to compute the weights. First, a subclass propensity score is computed as the proportion of treated units in each subclass, and the one of the formulas above will be used based on the estimand requested. If not specified, <code>"ATT"</code> is assumed.</p>
</td></tr>
<tr><td><code id="get.w_+3A_s.weights">s.weights</code></td>
<td>
<p>whether the sampling weights included in the original call to the fitting function should be included in the weights. If <code>TRUE</code>, the returned weights will be the product of the balancing weights estimated by the fitting function and the sampling weights. If <code>FALSE</code>, only the balancing weights will be returned.</p>
</td></tr>
<tr><td><code id="get.w_+3A_treat">treat</code></td>
<td>
<p>a vector of treatment status for each unit. This is required for methods that include <code>treat</code> as an argument. The treatment variable that was used in the original preprocessing function call should be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The output of <code>get.w()</code> can be used in calls to the formula and data frame methods of <code><a href="#topic+bal.tab">bal.tab()</a></code> (see example below). In this way, the output of multiple preprocessing packages can be viewed simultaneously and compared. The weights can also be used in <code>weights</code> statements in regression methods to compute weighted effects.
</p>
<p><span class="pkg">twang</span> has a function called <code>get.weights()</code> that performs the same function on <code>ps</code> objects but offers slightly finer control. Note that the weights generated by <code>get.w()</code> for <code>ps</code> objects do not include sampling weights by default.
</p>
<p>When sampling weights are used with <code>CBPS()</code> in <span class="pkg">CBPS</span>, the returned weights will already have the sampling weights incorporated. To retrieve the balancing weights on their own, divide the returned weights by the original sampling weights. For other packages, the balancing weights are returned separately unless <code>s.weights = TRUE</code>, which means they must be multiplied by the sampling weights for effect estimation.
</p>
<p>When <code>Match()</code> in <span class="pkg">Matching</span> is used with <code>CommonSupport = TRUE</code>, the returned weights will be incorrect. This option is not recommended by the package authors.
</p>


<h3>Value</h3>

<p>A vector or data frame of weights for each unit. These may be matching weights or balancing weights.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("lalonde", package = "cobalt")

m.out &lt;- MatchIt::matchit(treat ~ age + educ + race,
                          data = lalonde,
                          estimand = "ATT") 

w.out &lt;- WeightIt::weightit(treat ~ age + educ + race,
                            data = lalonde,
                            estimand = "ATT")

bal.tab(treat ~ age + educ + race, data = lalonde,
        weights = data.frame(matched = get.w(m.out),
                             weighted = get.w(w.out)),
        method = c("matching", "weighting"), 
        estimand = "ATT")

</code></pre>

<hr>
<h2 id='lalonde'>Data from National Supported Work Demonstration and PSID, as analyzed by
Dehejia and Wahba (1999).</h2><span id='topic+lalonde'></span><span id='topic+lalonde_mis'></span>

<h3>Description</h3>

<p>This is a subsample of the data from the treated group in the National
Supported Work Demonstration (NSW) and the comparison sample from the
Population Survey of Income Dynamics (PSID). This data was previously
analyzed extensively by Lalonde (1986) and Dehejia and Wahba (1999).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lalonde

lalonde_mis
</code></pre>


<h3>Format</h3>

<p>A data frame with 614 observations (185 treated, 429 control).
There are 9 variables measured for each individual.
</p>

<ul>
<li><p> &quot;treat&quot;
is the treatment assignment (1=treated, 0=control).
</p>
</li>
<li><p> &quot;age&quot; is age in years.
</p>
</li>
<li><p> &quot;educ&quot; is education in number of years of schooling.
</p>
</li>
<li><p> &quot;race&quot; is the individual's race/ethnicity, (Black, Hispanic, or White). Note
some other versions of this dataset use indicator variables <code>black</code> and
<code>hispan</code> instead of a single race variable.
</p>
</li>
<li><p> &quot;married&quot; is an
indicator for married (1=married, 0=not married).
</p>
</li>
<li><p> &quot;nodegree&quot; is an
indicator for whether the individual has a high school degree (1=no degree,
0=degree).
</p>
</li>
<li><p> &quot;re74&quot; is income in 1974, in U.S. dollars.
</p>
</li>
<li><p> &quot;re75&quot; is
income in 1975, in U.S. dollars.
</p>
</li>
<li><p> &quot;re78&quot; is income in 1978, in U.S.
dollars. </p>
</li></ul>

<p>&quot;treat&quot; is the treatment variable, &quot;re78&quot; is the outcome, and the
others are pre-treatment covariates.
</p>
<p>An object of class <code>data.frame</code> with 614 rows and 9 columns.
</p>


<h3>Details</h3>

<p><code>lalonds_mis</code> is the same dataset with missing values in three of the covariates.
</p>


<h3>References</h3>

<p>Lalonde, R. (1986). Evaluating the econometric evaluations of
training programs with experimental data. <em>American Economic Review</em> 76:
604-620.
</p>
<p>Dehejia, R.H. and Wahba, S. (1999).  Causal Effects in Nonexperimental
Studies: Re-Evaluating the Evaluation of Training Programs.  <em>Journal of the
American Statistical Association</em> 94: 1053-1062.
</p>

<hr>
<h2 id='love.plot'>Display Balance Statistics in a Love Plot</h2><span id='topic+love.plot'></span>

<h3>Description</h3>

<p>Generates a &quot;Love&quot; plot graphically displaying covariate balance before and after adjusting. Options are available for producing publication-ready plots. Detailed examples are available in <code>vignette("love.plot")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>love.plot(
  x,
  stats,
  abs,
  agg.fun = NULL,
  var.order = NULL,
  drop.missing = TRUE,
  drop.distance = FALSE,
  thresholds = NULL,
  line = FALSE,
  stars = "none",
  grid = FALSE,
  limits = NULL,
  colors = NULL,
  shapes = NULL,
  alpha = 1,
  size = 3,
  wrap = 30,
  var.names = NULL,
  title,
  sample.names,
  labels = FALSE,
  position = "right",
  themes = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="love.plot_+3A_x">x</code></td>
<td>
<p>the valid input to a call to <code><a href="#topic+bal.tab">bal.tab()</a></code> (e.g., the output of a preprocessing function). Other arguments that would be supplied to <code>bal.tab()</code> can be entered with <code>...</code>. Can also be a <code>bal.tab</code> object, i.e., the output of a call to <code>bal.tab()</code>. See Examples. If <code>x</code> is not a <code>bal.tab</code> object, <code>love.plot()</code> calls <code>bal.tab()</code> with the arguments supplied.</p>
</td></tr>
<tr><td><code id="love.plot_+3A_stats">stats</code></td>
<td>
<p><code>character</code>; which statistic(s) should be reported. See <code><a href="#topic+balance-statistics">stats</a></code> for allowable options. For binary and multi-category treatments, &quot;mean.diffs&quot; (i.e., mean differences) is the default. For continuous treatments, &quot;correlations&quot; (i.e., treatment-covariate Pearson correlations) is the default. Multiple options are allowed.</p>
</td></tr>
<tr><td><code id="love.plot_+3A_abs">abs</code></td>
<td>
<p><code>logical</code>; whether to present the statistic in absolute value or not. For variance ratios, this will force all ratios to be greater than or equal to 1. If <code>x</code> is a <code>bal.tab</code> object, <code>love.plot()</code> might ignore <code>abs</code> depending on the original <code>bal.tab()</code> call. If unspecified, uses whatever was used in the call to <code>bal.tab()</code>.</p>
</td></tr>
<tr><td><code id="love.plot_+3A_agg.fun">agg.fun</code></td>
<td>
<p>if balance is to be displayed across clusters or imputations rather than within a single cluster or imputation, which summarizing function (&quot;mean&quot;, &quot;max&quot;, or &quot;range&quot;) of the balance statistics should be used. If &quot;range&quot; is entered, <code>love.plot()</code> will display a line from the min to the max with a point at the mean for each covariate. Abbreviations allowed; &quot;range&quot; is default. Remember to set <code style="white-space: pre;">&#8288;which.&lt;ARG&gt; = .none&#8288;</code> (where <code style="white-space: pre;">&#8288;&lt;ARG&gt;&#8288;</code> is the grouping argument, such as <code>cluster</code> or <code>imp</code>) to use <code>agg.fun</code>. See Details.</p>
</td></tr>
<tr><td><code id="love.plot_+3A_var.order">var.order</code></td>
<td>
<p>a <code>character</code> or <code>love.plot</code> object; how to order the variables in the plot. See Details.</p>
</td></tr>
<tr><td><code id="love.plot_+3A_drop.missing">drop.missing</code></td>
<td>
<p><code>logical</code>; whether to drop rows for variables for which the statistic has a value of <code>NA</code>, for example, variance ratios for binary variables. If <code>FALSE</code>, there will be rows for these variables but no points representing their value. Default is <code>TRUE</code>, so that variables with missing balance statistics are absent. When multiple <code>stats</code> are requested, only variables with <code>NA</code>s for all <code>stats</code> will be dropped if <code>drop.missing = TRUE</code>. This argument used to be called <code>no.missing</code>, and that name still works (but has been deprecated).</p>
</td></tr>
<tr><td><code id="love.plot_+3A_drop.distance">drop.distance</code></td>
<td>
<p><code>logical</code>; whether to ignore the distance measure (if there are any) in plotting.</p>
</td></tr>
<tr><td><code id="love.plot_+3A_thresholds">thresholds</code></td>
<td>
<p><code>numeric</code>; an optional value to be used as a threshold marker in the plot. Should be a named vector where each name corresponds to the statistic for which the threshold is to be applied. See example at <code><a href="#topic+balance-statistics">stats</a></code>. If <code>x</code> is a <code>bal.tab</code> object and a threshold was set in it (e.g., with <code>thresholds</code>), its threshold will be used unless overridden using the <code>threshold</code> argument in <code>love.plot()</code>.</p>
</td></tr>
<tr><td><code id="love.plot_+3A_line">line</code></td>
<td>
<p><code>logical</code>; whether to display a line connecting the points for each sample.</p>
</td></tr>
<tr><td><code id="love.plot_+3A_stars">stars</code></td>
<td>
<p>when mean differences are to be displayed, which variable names should have a star (i.e., an asterisk) next to them. Allowable values are &quot;none&quot;, &quot;std&quot; (for variables with mean differences that have been standardized), or &quot;raw&quot; (for variables with mean differences that have not been standardized). If &quot;raw&quot;, the x-axis title will be &quot;Standardized Mean Differences&quot;. Otherwise, it will be &quot;Mean Differences&quot;. Ignored when mean difference are not displayed. See Details for an explanation of the purpose of this option.</p>
</td></tr>
<tr><td><code id="love.plot_+3A_grid">grid</code></td>
<td>
<p><code>logical</code>; whether gridlines should be shown on the plot. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="love.plot_+3A_limits">limits</code></td>
<td>
<p><code>numeric</code>; the bounds for the x-axis of the plot. Must a (named) list of vectors of length 2 in ascending order, one for each value of <code>stats</code> that is to have limits; e.g., <code>list(m = c(-.2, .2))</code>. If values exceed the limits, they will be plotted at the edge.</p>
</td></tr>
<tr><td><code id="love.plot_+3A_colors">colors</code></td>
<td>
<p>the colors of the points on the plot. See 'Color Specification' at <code><a href="graphics.html#topic+par">graphics::par()</a></code> or the <code>ggplot2</code> <a href="https://ggplot2.tidyverse.org/articles/ggplot2-specs.html#colour-and-fill">aesthetic specifications</a> page. The first value corresponds to the color for the unadjusted sample, and the second color to the adjusted sample. If only one is specified, it will apply to both. Defaults to the default <span class="pkg">ggplot2</span> colors.</p>
</td></tr>
<tr><td><code id="love.plot_+3A_shapes">shapes</code></td>
<td>
<p>the shapes of the points on the plot. Must be one or two numbers between 1 and 25 or the name of a valid shape. See the <code>ggplot2</code> <a href="https://ggplot2.tidyverse.org/articles/ggplot2-specs.html#point">aesthetic specifications</a> page for valid options. Values 15 to 25 are recommended. The first value corresponds to the shape for the unadjusted sample, and the second color to the adjusted sample. If only one is specified, it will apply to both. Defaults to 19 (<code>"circle filled"</code>).</p>
</td></tr>
<tr><td><code id="love.plot_+3A_alpha">alpha</code></td>
<td>
<p><code>numeric</code>; the transparency of the points. See <code><a href="ggplot2.html#topic+scale_alpha">ggplot2::scale_alpha()</a></code>.</p>
</td></tr>
<tr><td><code id="love.plot_+3A_size">size</code></td>
<td>
<p><code>numeric</code>; the size of the points on the plot. Defaults to 3. In previous versions, the size was scaled by a factor of 3. Now <code>size</code> corresponds directly to the <code>size</code> aesthetic in <code><a href="ggplot2.html#topic+geom_point">ggplot2::geom_point()</a></code>.</p>
</td></tr>
<tr><td><code id="love.plot_+3A_wrap">wrap</code></td>
<td>
<p><code>numeric</code>; the number of characters at which to wrap axis labels to the next line. Defaults to 30. Decrease this if the axis labels are excessively long.</p>
</td></tr>
<tr><td><code id="love.plot_+3A_var.names">var.names</code></td>
<td>
<p>an optional object providing alternate names for the variables in the plot, which will otherwise be the variable names as they are stored. This may be useful when variables have ugly names. See Details on how to specify <code>var.names</code>. <code><a href="#topic+var.names">var.names()</a></code> can be a useful tool for extracting and editing the names from the <code>bal.tab</code> object.</p>
</td></tr>
<tr><td><code id="love.plot_+3A_title">title</code></td>
<td>
<p><code>character</code>; the title of the plot.</p>
</td></tr>
<tr><td><code id="love.plot_+3A_sample.names">sample.names</code></td>
<td>
<p><code>character</code>; new names to be given to the samples (i.e., in place of &quot;Unadjusted&quot; and &quot;Adjusted&quot;). For example, when matching it used, it may be useful to enter <code>c("Unmatched", "Matched")</code>.</p>
</td></tr>
<tr><td><code id="love.plot_+3A_labels">labels</code></td>
<td>
<p><code>logical</code> or <code>character</code>; labels to give the plots when multiple <code>stats</code> are requested. If <code>TRUE</code>, the labels will be capital letters. Otherwise, must be a string with the same length as <code>stats</code>. This can be useful when the plots are to be used in an article.</p>
</td></tr>
<tr><td><code id="love.plot_+3A_position">position</code></td>
<td>
<p>the position of the legend. When <code>stats</code> has length 1, this can be any value that would be appropriate as an argument to <code>legend.position</code> in <code><a href="ggplot2.html#topic+theme">ggplot2::theme()</a></code>. When <code>stat</code> has length greater than 1, can be one of &quot;none&quot;, &quot;left&quot;, &quot;right&quot;, &quot;bottom&quot;, or &quot;top&quot;.</p>
</td></tr>
<tr><td><code id="love.plot_+3A_themes">themes</code></td>
<td>
<p>an optional list of <code>theme</code> objects to append to each individual plot. Each entry should be the output of a call to <code><a href="ggplot2.html#topic+theme">ggplot2::theme()</a></code> in <span class="pkg">ggplot2</span>. This is a way to customize the individual plots when multiple <code>stats</code> are requested since the final output is not a manipulable <code>ggplot</code> object. It can be used with length-1 <code>stats</code>, but it probably makes more sense to just add the <code>theme()</code> call after <code>love.plot()</code>.</p>
</td></tr>
<tr><td><code id="love.plot_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>bal.tab()</code> or options for display of the plot. The following related arguments are currently accepted:
</p>

<dl>
<dt><code>use.grid</code></dt><dd><p>whether to use <code><a href="gridExtra.html#topic+arrangeGrob">gridExtra::arrangeGrob()</a></code> in <code>gridExtra</code> to make the plot when <code>stats</code> has length 1. See section Value.</p>
</dd>
<dt><code>disp.subclass</code></dt><dd><p>whether to display individual subclasses if subclassification is used. Overrides the <code>disp.subclass</code> option in the original <code>bal.tab()</code> call if <code>x</code> is a <code>bal.tab</code> object.</p>
</dd>
<dt><code>star_char</code></dt><dd><p><code>character</code>; when <code>stars</code> are used, the character that should be the &quot;star&quot; next to the starred variables. The default is <code>"*"</code>. <code>""</code> or <code>"\u2020"</code> (i.e., dagger) might be appealing as well.</p>
</dd>
</dl>

<p>Additionally, any of the <code>which.</code> arguments used with clustered or multiply imputed data or longitudinal or multi-category treatments can be specified to display balance on selected groupings. Set to <code>.none</code> to aggregate across groups (in which <code>agg.fun</code> comes into effect) and set to <code>.all</code> to view all groups. See <a href="#topic+display-options">display-options</a> for options, and see <code>vignette("segmented-data")</code> for details and examples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>love.plot</code> can be used with clusters, imputations, and multi-category and longitudinal treatments in addition to the standard case. Setting the corresponding <code>which.</code> argument to <code>.none</code> will aggregate across that dimension. When aggregating, an argument should be specified to <code>agg.fun</code> referring to whether the mean, minimum (&quot;min&quot;), or maximum (&quot;max&quot;) balance statistic or range (&quot;range&quot;, the default) of balance statistics for each covariate should be presented in the plot. See <code>vignette("segmented-data")</code> for examples.
</p>
<p>With subclasses, balance will be displayed for the unadjusted sample and the aggregated subclassified sample. If <code>disp.subclass</code> is <code>TRUE</code>, each subclass will be displayed additionally as a number on the plot.
</p>


<h4>Variable order using <code>var.order</code></h4>

<p>The order that the variables are presented in depends on the argument to <code>var.order</code>. If <code>NULL</code>, the default, they will be displayed in the same order as in the call to <code>bal.tab()</code>, which is the order of the underlying data set. If &quot;alphabetical&quot;, they will be displayed in alphabetical order. If &quot;unadjusted&quot;, they will be ordered by the balance statistic of the unadjusted sample. To order by the values of the adjusted sample, &quot;adjusted&quot; can be supplied if only one set of weights (or subclasses) are specified; otherwise, the name of the set of weights should be specified.
</p>
<p>If multiple <code>stats</code> are requested, the order will be determined by the first entry to <code>stats</code> (e.g., if both &quot;mean.diffs&quot; and &quot;ks.statistics&quot; are requested, and <code>var.order = "unadjusted"</code>, the variables will be displayed in order of the unadjusted mean differences for both plots). If multiple plots are produced simultaneously (i.e., for individual clusters or imputations), <code>var.order</code> can only be <code>NULL</code> or &quot;alphabetical&quot;.
</p>
<p>If a <code>love.plot</code> object is supplied, the plot being drawn will use the variable order in the supplied <code>love.plot</code> object. This can be useful when making more than one plot and the variable order should be the same across plots.
</p>



<h4>Variable names using <code>var.names</code></h4>

<p>The default in <code>love.plot()</code> is to present variables as they are named in the output of the call to <code>bal.tab()</code>, so it is important to know this output before specifying alternate variable names when using <code>var.names</code>, as the displayed variable names may differ from those in the original data.
</p>
<p>There are several ways to specify alternate names for presentation in the displayed plot using the <code>var.names</code> argument by specifying a list of old and new variable names, pairing the old name with the new name. You can do this in three ways: 1) use a vector or list of new variable names, with the <code>names</code> of the values the old variable names; 2) use a data frame with exactly one column containing the new variable names and the row names containing the old variable names; or 3) use a data frame with two columns, the first (or the one named &quot;old&quot;) containing the old variable names and the second (or the one named &quot;new&quot;) containing the new variable names. If a variable in the output from <code>bal.tab()</code> is not provided in the list of old variable names, <code>love.plot()</code> will use the original old variable name.
</p>
<p><code>love.plot()</code> can replace old variables names with new ones based on exact matching for the name strings or matching using the variable name components. For example, if a factor variable <code>"X"</code> with levels <code>"a"</code>, <code>"b"</code>, and <code>"c"</code> is displayed with <code>love.plot()</code>, the variables <code>"X_a"</code>, <code>"X_b"</code>, and <code>"X_c"</code> will be displayed. You can enter replacement names for all three variables individually with <code>var.names</code>, or you can simply specify a replacement name for <code>"X"</code>, and <code>"X"</code> will be replaced by the given name in all instances it appears, including not just factor expansions, but also polynomials and interactions in <code>int = TRUE</code> in the original <code>bal.tab()</code> call. In an interaction with another variable, say <code>"Y"</code>, there are several ways to replace the name of the interaction term <code>"X_a * Y"</code>. If the entire string (<code>"X_a * Y"</code>) is included in <code>var.names</code>, the entire string will be replaced. If <code>"X_a"</code> is included in <code>var.names</code>, only it will be replaced (and it will be replaced everywhere else it appears). If <code>"X"</code> is included in <code>var.names</code>, only it will be replaced (and it will be replaced everywhere else it appears). See example at <code><a href="#topic+var.names">var.names()</a></code>.
</p>



<h4>Stars and the x-axis label with mean differences</h4>

<p>When mean differences are to be displayed, <code>love.plot()</code> attempts to figure out the appropriate label for the x-axis. If all mean differences are standardized, the x-axis label will be &quot;Standardized Mean Differences&quot;. If all mean differences are raw (i.e., unstandardized), the x-axis label will be &quot;Mean Differences&quot;. Otherwise, <code>love.plot()</code> turns to the <code>stars</code> argument. If &quot;raw&quot;, the x-axis label will be &quot;Standardized Mean Differences&quot; (i.e., because un-starred variables have standardized mean differences displayed). If &quot;std&quot;, the x-axis label will be &quot;Mean Differences&quot; (i.e., because un-starred variables have raw mean differences displayed). If &quot;none&quot;, the x-axis label will be &quot;Mean Differences&quot; and a warning will be issued recommending the use of <code>stars</code>.
</p>
<p>The default is to display standardized mean differences for continuous variables, raw mean differences for binary variables, and no stars, so this warning will be issued in most default uses of <code>love.plot()</code>. The purpose of this is to correct behavior of previous versions of <span class="pkg">cobalt</span> in which the default x-axis label was &quot;Mean Differences&quot;, even when standardized mean differences were displayed, yielding a potentially misleading plot. This warning requires the user to think about what values are being displayed. The idea of using <code>stars</code> is that the user can, in a caption for the plot, explain that variables with an asterisk have standardized (or raw) mean differences display, in contrast to un-starred variables.
</p>



<h3>Value</h3>

<p>When only one type of balance statistic is requested, the returned object is a standard <code>ggplot</code> object that can be manipulated using <span class="pkg">ggplot2</span> syntax. This facilitates changing fonts, background colors, and features of the legend outside of what <code>love.plot()</code> provides automatically.
</p>
<p>When more than one type of balance statistic is requested, the plot is constructed using <code><a href="gridExtra.html#topic+arrangeGrob">gridExtra::arrangeGrob()</a></code> in <code>gridExtra</code>, which arranges multiple plots and their shared legend into one plot. Because the output of <code>arrangeGrob</code> is a <code>gtable</code> object, its features cannot be manipulated in the standard way. Use the <code>themes</code> argument to change theme elements of the component plots. The original plots are stored in the <code>"plots"</code> attribute of the output object.
</p>


<h3>Note</h3>

<p><code>love.plot</code> can also be called by using <code>plot()</code> or <code>autoplot()</code> on a <code>bal.tab</code> object. If used in this way, some messages may appear twice. It is recommended that you just use <code>love.plot()</code> instead.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bal.tab">bal.tab()</a></code>, <code>vignette("love.plot")</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("lalonde", package = "cobalt")

## Propensity score weighting
w.out1 &lt;- WeightIt::weightit(treat ~ age + educ + race + married +
                                 nodegree + re74 + re75, 
                             data = lalonde)

love.plot(w.out1, thresholds = c(m = .1), var.order = "unadjusted")

## Using alternate variable names
v &lt;- data.frame(old = c("age", "educ", "race_black", "race_hispan", 
                        "race_white", "married", "nodegree", "re74", 
                        "re75", "distance"),
                new = c("Age", "Years of Education", "Black", 
                        "Hispanic", "White", "Married", "No Degree", 
                        "Earnings 1974", "Earnings 1975", 
                        "Propensity Score"))

love.plot(w.out1, stats = "m", threshold = .1, 
          var.order = "unadjusted", var.names = v)

#Using multiple stats
love.plot(w.out1, stats = c("m", "ks"), 
          thresholds = c(m = .1, ks = .05), 
          var.order = "unadjusted", var.names = v, stars = "raw",
          position = "bottom", wrap = 20)

#Changing visual elements
love.plot(w.out1, thresholds = c(m = .1), 
          var.order = "unadjusted", var.names = v, abs = TRUE,
          shapes = c("triangle filled", "circle"), 
          colors = c("red", "blue"), line = TRUE,
          grid = FALSE, sample.names = c("Original", "Weighted"),
          stars = "raw", position = "top")

</code></pre>

<hr>
<h2 id='print.bal.tab'>Print Results of a Call to <code>bal.tab()</code></h2><span id='topic+print.bal.tab'></span>

<h3>Description</h3>

<p>Prints <code>bal.tab()</code> output in a clean way. Provides options for printing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bal.tab'
print(
  x,
  imbalanced.only,
  un,
  disp.bal.tab,
  disp.call,
  stats,
  disp.thresholds,
  disp,
  which.subclass,
  subclass.summary,
  which.imp,
  imp.summary,
  imp.fun,
  which.treat,
  multi.summary,
  which.time,
  msm.summary,
  which.cluster,
  cluster.summary,
  cluster.fun,
  digits = max(3, getOption("digits") - 3),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.bal.tab_+3A_x">x</code></td>
<td>
<p>a <code>bal.tab</code> object; the output of a call to <code><a href="#topic+bal.tab">bal.tab()</a></code>.</p>
</td></tr>
<tr><td><code id="print.bal.tab_+3A_imbalanced.only">imbalanced.only</code></td>
<td>
<p><code>logical</code>; whether to display only the covariates that failed to meet at least one of balance thresholds. Depends only on whether threshold were initial set in the call to <code>bal.tab()</code> and not on any arguments to <code>print()</code> (except <code>disp.bal.tab</code>).</p>
</td></tr>
<tr><td><code id="print.bal.tab_+3A_un">un</code></td>
<td>
<p><code>logical</code>; whether to display balance values for the unadjusted sample. Ignored (and set to <code>TRUE</code>) if no conditioning was performed.</p>
</td></tr>
<tr><td><code id="print.bal.tab_+3A_disp.bal.tab">disp.bal.tab</code></td>
<td>
<p><code>logical</code>; whether to display the table of balance statistics. If <code>FALSE</code>, only other values (e.g., the call, sample sizes, balance tallies, and maximum imbalances) will be presented.</p>
</td></tr>
<tr><td><code id="print.bal.tab_+3A_disp.call">disp.call</code></td>
<td>
<p><code>logical</code>; whether to display the function call for the input object, if any.</p>
</td></tr>
<tr><td><code id="print.bal.tab_+3A_stats">stats</code></td>
<td>
<p><code>character</code>; which statistic(s) should be reported. For binary or multi-category treatments, the options are &quot;mean.diffs&quot; for mean differences (standardized or not according the selected <code>bal.tab()</code> options), &quot;variance.ratios&quot; for variance ratios, and &quot;ks.statistics&quot; for Kolmogorov-Smirnov statistics. &quot;mean.diffs&quot; is the default. For continuous treatments, the only option is &quot;correlations&quot; for treatment-covariate correlations. Multiple options are allowed. Abbreviations allowed. Statistics that weren't requested in the original call to <code>bal.tab()</code> cannot be requested with <code>print()</code> unless <code>quick = FALSE</code> in the original call.</p>
</td></tr>
<tr><td><code id="print.bal.tab_+3A_disp.thresholds">disp.thresholds</code></td>
<td>
<p><code>logical</code>; whether to display thresholds for each statistic for which thresholds were originally requested in the call to <code>bal.tab()</code>. Should be a named logical vector with names corresponding to the thresholds. For example, if thresholds for mean differences were requested in <code>bal.tab()</code>, set <code>disp.thresholds = c(m = FALSE)</code> to prevent them from being printed. If a statistic was prevented from being displayed by another argument to <code>print()</code>, the thresholds will not be displayed.</p>
</td></tr>
<tr><td><code id="print.bal.tab_+3A_disp">disp</code></td>
<td>
<p><code>character</code>; which distribution summary statistics to display. Allowable options include &quot;means&quot; and &quot;sds&quot;. Statistics that weren't requested in the original call to <code>bal.tab()</code> cannot be requested with <code>print()</code> unless <code>quick = FALSE</code> in the original call.</p>
</td></tr>
<tr><td><code id="print.bal.tab_+3A_which.subclass">which.subclass</code></td>
<td>
<p>when used with subclassification, which subclass(es) to display. If <code>NULL</code>, all subclasses will be displayed. If <code>NA</code>, no subclasses will be displayed. Otherwise, can be a vector of subclass indices for which to display balance. To display the subclasses requested in the original call to <code>bal.tab()</code>, omit this argument. See <code><a href="#topic+class-bal.tab.subclass">class-bal.tab.subclass</a></code> for details.</p>
</td></tr>
<tr><td><code id="print.bal.tab_+3A_subclass.summary">subclass.summary</code></td>
<td>
<p><code>logical</code>; when used with subclassification, whether to display the subclass balance summary table. If <code>which.subclass</code> is <code>NA</code>, <code>subclass.summary</code> will be set to <code>TRUE</code>. See <code><a href="#topic+class-bal.tab.subclass">class-bal.tab.subclass</a></code> for details.</p>
</td></tr>
<tr><td><code id="print.bal.tab_+3A_which.imp">which.imp</code></td>
<td>
<p>when used with multiply imputed data, which imputation(s) to display. If <code>NULL</code>, all imputations will be displayed. If <code>NA</code>, no imputations will be displayed. Otherwise, can be a vector of imputations numbers for which to display balance. To display the imputations requested in the original call to <code>bal.tab()</code>, omit this argument. See <code><a href="#topic+class-bal.tab.imp">class-bal.tab.imp</a></code> for details.</p>
</td></tr>
<tr><td><code id="print.bal.tab_+3A_imp.summary">imp.summary</code></td>
<td>
<p><code>logical</code>; when used with multiply imputed data, whether to display the imputation summary table. If <code>which.imp</code> is <code>NA</code>, <code>imp.summary</code> will be set to <code>TRUE</code>. See <code><a href="#topic+class-bal.tab.imp">class-bal.tab.imp</a></code> for details.</p>
</td></tr>
<tr><td><code id="print.bal.tab_+3A_imp.fun">imp.fun</code></td>
<td>
<p><code>character</code>; when used with multiply imputed data, a character vector of functions of balance statistics to display when displaying balance across imputations. Can be &quot;mean&quot;, &quot;min&quot;, or &quot;max&quot;. More than one are allowed. See <code><a href="#topic+class-bal.tab.imp">class-bal.tab.imp</a></code> for details.</p>
</td></tr>
<tr><td><code id="print.bal.tab_+3A_which.treat">which.treat</code></td>
<td>
<p>when used with multi-category treatments, which treatments to display. See <code><a href="#topic+class-bal.tab.multi">bal.tab.multi()</a></code> for details.</p>
</td></tr>
<tr><td><code id="print.bal.tab_+3A_multi.summary">multi.summary</code></td>
<td>
<p><code>logical</code>; when used with multi-category treatments, whether to display the balance summary table across pairwise comparisons. See <code><a href="#topic+class-bal.tab.multi">bal.tab.multi()</a></code> for details.</p>
</td></tr>
<tr><td><code id="print.bal.tab_+3A_which.time">which.time</code></td>
<td>
<p>when used with longitudinal treatments, which time periods to display if longitudinal treatments are used. See <code><a href="#topic+class-bal.tab.msm">class-bal.tab.msm</a></code> for details.</p>
</td></tr>
<tr><td><code id="print.bal.tab_+3A_msm.summary">msm.summary</code></td>
<td>
<p><code>logical</code>; when used with longitudinal treatments, whether to display the balance summary table across time periods. See <code><a href="#topic+class-bal.tab.msm">class-bal.tab.msm</a></code> for details.</p>
</td></tr>
<tr><td><code id="print.bal.tab_+3A_which.cluster">which.cluster</code></td>
<td>
<p>when used with clustered data, which cluster(s) to display. If <code>NULL</code>, all clusters will be displayed. If <code>NA</code>, no clusters will be displayed. Otherwise, can be a vector of cluster names or numerical indices for which to display balance. Indices correspond to the alphabetical order of cluster names. To display the clusters requested in the original call to <code>bal.tab()</code>, omit this argument. See <code><a href="#topic+class-bal.tab.cluster">class-bal.tab.cluster</a></code> for details.</p>
</td></tr>
<tr><td><code id="print.bal.tab_+3A_cluster.summary">cluster.summary</code></td>
<td>
<p><code>logical</code>; when used with clustered data, whether to display the cluster summary table. If <code>which.cluster</code> is <code>NA</code>, <code>cluster.summary</code> will be set to <code>TRUE</code>. See <code><a href="#topic+class-bal.tab.cluster">class-bal.tab.cluster</a></code> for details.</p>
</td></tr>
<tr><td><code id="print.bal.tab_+3A_cluster.fun">cluster.fun</code></td>
<td>
<p><code>character</code>; when used with clustered data, a character vector of functions of balance statistics to display when displaying balance across clusters. Can be &quot;mean&quot;, &quot;min&quot;, or &quot;max&quot;. More than one are allowed. See <code><a href="#topic+class-bal.tab.cluster">class-bal.tab.cluster</a></code> for details.</p>
</td></tr>
<tr><td><code id="print.bal.tab_+3A_digits">digits</code></td>
<td>
<p>the number of digits to display.</p>
</td></tr>
<tr><td><code id="print.bal.tab_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simply calling <code>bal.tab()</code> will print its results, but it can be useful to store the results into an object and print them again later, possibly with different print options specified. The <code>print()</code> function automatically dispatches the correct method for the <code>bal.tab</code> object given.
</p>
<p>Any parameter used in <code>bal.tab()</code> for calculations, such as <code>int</code>, <code>addl</code>, or <code>distance</code>, cannot be used with <code>print()</code>; only those parameters listed above, those that solely determine printing options, can be used. To change computation options, a new call to <code>bal.tab()</code> must be performed.
</p>
<p>Prior versions of <code>print()</code> had separate methods for each <code>bal.tab</code> class. Now they are dispatched internally.
</p>


<h3>Note</h3>

<p>Unless <code>quick = FALSE</code> in the original call to <code>bal.tab()</code> (which is not the default), some values may not be calculated, in which case using <code>print()</code> will not display these values even when requested. For example, if <code>stats = "m"</code> and <code>quick = TRUE</code> in the original call to <code>bal.tab()</code> (the default for both), setting <code>stats = "ks"</code> in <code>print()</code> will not print the KS statistics because they were not calculated.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print">print()</a></code>, <code><a href="#topic+bal.tab">bal.tab()</a></code>
</p>
<p><code><a href="#topic+display-options">display-options</a></code> for further information on some of these options.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data("lalonde", package = "cobalt")

w.out &lt;- WeightIt::weightit(treat ~ age + educ + married +
                                race + re74 + re75, 
                            data = lalonde)

b &lt;- bal.tab(w.out, stats = c("m", "v", "ks"), 
             un = TRUE, v.threshold = 2)

print(b, un = FALSE, stats = c("m", "v"),
      disp.thresholds = c(v = FALSE))

</code></pre>

<hr>
<h2 id='set.cobalt.options'>Set and Get Options in <code>cobalt</code></h2><span id='topic+set.cobalt.options'></span><span id='topic+get.cobalt.options'></span>

<h3>Description</h3>

<p>Makes it easier to set <span class="pkg">cobalt</span> options. <code>set.cobalt.options()</code> is essentially a wrapper for <code><a href="base.html#topic+options">options()</a></code> but performs several checks, and <code>get.cobalt.options()</code> is essentially a wrapper for <code><a href="base.html#topic+getOption">getOption()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.cobalt.options(..., default = FALSE)

get.cobalt.options(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="set.cobalt.options_+3A_...">...</code></td>
<td>
<p>For <code>set.cobalt.options()</code>, <code>bal.tab()</code> parameters and the values they should take. These should be the name of the parameter in <code>bal.tab()</code> without <code>"cobalt_"</code> preceding them. See examples. If any values are <code>NULL</code>, the corresponding options will be set back to their defaults.
</p>
<p>For <code>get.cobalt.options()</code>, one or more strings containing the name of a parameter option to be retrieved. See examples. If empty, all available options and their values will be returned.</p>
</td></tr>
<tr><td><code id="set.cobalt.options_+3A_default">default</code></td>
<td>
<p>if <code>TRUE</code>, sets all <span class="pkg">cobalt</span> options not named in <code>...</code> to their default values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When an option is set to <code>NULL</code>, it is set to its default value. The defaults are not displayed but are listed on the help pages where they appear. Most options correspond to display options, which can be accessed <a href="#topic+display-options">here</a>. Some others (e.g., <code>continuous</code> and <code>binary</code>) are described on the <code><a href="#topic+bal.tab">bal.tab()</a></code> help page.
</p>


<h3>See Also</h3>


<ul>
<li> <p><code><a href="base.html#topic+options">options()</a></code>
</p>
</li>
<li> <p><code><a href="#topic+display-options">display-options</a></code> for some arguments that can be set via options.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Set un to be TRUE to always display unadjusted 
# balance measures and set binary to "std" to 
# produce standardized mean differences for 
# binary variables.

set.cobalt.options(un = TRUE, binary = "std")

# Note: the above is equivalent to:
# options(cobalt_un = TRUE, cobalt_binary = "std")
# but performs some additional checks

get.cobalt.options("un", "binary")

# Note: the above is equivalent to:
# getOption("cobalt_un")
# getOption("cobalt_binary")

# Return all cobalt options to their defaults

set.cobalt.options(default = TRUE)

# View all available options
get.cobalt.options()

</code></pre>

<hr>
<h2 id='splitfactor'>Split and Unsplit Factors into Dummy Variables</h2><span id='topic+splitfactor'></span><span id='topic+unsplitfactor'></span>

<h3>Description</h3>

<p><code>splitfactor()</code> splits factor variables into dummy (0/1) variables. This can be useful when functions do not process factor variables well or require numeric matrices to operate. <code>unsplitfactor()</code> combines dummy variables into factor variables, undoing the operation of <code>splitfactor()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitfactor(
  data,
  var.name,
  drop.level = NULL,
  drop.first = TRUE,
  drop.singleton = FALSE,
  drop.na = TRUE,
  sep = "_",
  replace = TRUE,
  split.with = NULL,
  check = TRUE
)

unsplitfactor(
  data,
  var.name,
  dropped.level = NULL,
  dropped.na = TRUE,
  sep = "_",
  replace = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splitfactor_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> containing the variables to be split or unsplit. In <code>splitfactor()</code>, can be a factor variable to be split.</p>
</td></tr>
<tr><td><code id="splitfactor_+3A_var.name">var.name</code></td>
<td>
<p>For <code>splitfactor()</code>, the names of the factor variables to split. If not specified, will split all factor variables in <code>data</code>. If <code>data</code> is a factor, the stem for each of the new variables to be created. For <code>unsplitfactor()</code>, the name of the previously split factor. If not specified and <code>data</code> is the output of a call to <code>splitfactor()</code>, all previously split variables will be unsplit.</p>
</td></tr>
<tr><td><code id="splitfactor_+3A_drop.level">drop.level</code></td>
<td>
<p>The name of a level of <code>var.name</code> for which to drop the dummy variable. Only works if there is only one variable to be split.</p>
</td></tr>
<tr><td><code id="splitfactor_+3A_drop.first">drop.first</code></td>
<td>
<p>Whether to drop the first dummy created for each factor. If <code>"if2"</code>, will only drop the first category if the factor has exactly two levels. The default is to always drop the first dummy (<code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="splitfactor_+3A_drop.singleton">drop.singleton</code></td>
<td>
<p>Whether to drop a factor variable if it only has one level.</p>
</td></tr>
<tr><td><code id="splitfactor_+3A_drop.na">drop.na</code></td>
<td>
<p>If <code>NA</code>s are present in the variable, how to handle them. If <code>TRUE</code>, no new dummy will be created for <code>NA</code> values, but all created dummies will have <code>NA</code> where the original variable was <code>NA</code>. If <code>FALSE</code>, <code>NA</code> will be treated like any other factor level, given its own column, and the other dummies will have a value of 0 where the original variable is <code>NA</code>.</p>
</td></tr>
<tr><td><code id="splitfactor_+3A_sep">sep</code></td>
<td>
<p>A character separating the the stem from the value of the variable for each dummy. For example, for <code>"race_black"</code>, <code>sep = "_"</code>.</p>
</td></tr>
<tr><td><code id="splitfactor_+3A_replace">replace</code></td>
<td>
<p>Whether to replace the original variable(s) with the new variable(s) (<code>TRUE</code>) or the append the newly created variable(s) to the end of the data set (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="splitfactor_+3A_split.with">split.with</code></td>
<td>
<p>A list of vectors or factors with lengths equal to the number of columns of <code>data</code> that are to be split in the same way <code>data</code> is. See Details.</p>
</td></tr>
<tr><td><code id="splitfactor_+3A_check">check</code></td>
<td>
<p>Whether to make sure the variables specified in <code>var.name</code> are actually factor (or character) variables. If splitting non-factor (or non-character) variables into dummies, set <code>check = FALSE</code>. If <code>check = FALSE</code> and <code>data</code> is a <code>data.frame</code>, an argument to <code>var.name</code> must be specified.</p>
</td></tr>
<tr><td><code id="splitfactor_+3A_dropped.level">dropped.level</code></td>
<td>
<p>The value of each original factor variable whose dummy was dropped when the variable was split. If left empty and a dummy was dropped, the resulting factor will have the value <code>NA</code> instead of the dropped value. There should be one entry per variable to unsplit. If no dummy was dropped for a variable, an entry is still required, but it will be ignored.</p>
</td></tr>
<tr><td><code id="splitfactor_+3A_dropped.na">dropped.na</code></td>
<td>
<p>If <code>TRUE</code>, will assume that <code>NA</code>s in the variables to be unsplit correspond to <code>NA</code> in the unsplit factor (i.e., that <code>drop.na = TRUE</code> was specified in <code>split.factor()</code>). If <code>FALSE</code>, will assume there is a dummy called &quot;var.name_stem_NA&quot; (e.g., &quot;x_NA&quot;) that contains 1s where the unsplit factor should be <code>NA</code> (i.e., that <code>drop.na = FALSE</code> was specified in <code>split.factor()</code>. If <code>NA</code>s are stored in a different column with the same stem, e.g., &quot;x_miss&quot;, that name (e.g., &quot;miss&quot;) can be entered instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If there are <code>NA</code>s in the variable to be split, the new variables created by <code>splitfactor()</code> will have <code>NA</code> where the original variable is <code>NA</code>.
</p>
<p>When using <code>unsplitfactor()</code> on a <code>data.frame</code> that was generated with <code>splitfactor()</code>, the arguments <code>dropped.na</code>, and <code>sep</code> are unnecessary.
</p>
<p>If <code>split.with</code> is supplied, the elements will be split in the same way <code>data</code> is. For example, if <code>data</code> contained a 4-level factor that was to be split, the entries of <code>split.with</code> at the same index as the factor and would be duplicated so that resulting entries will have the same length as the number of columns of <code>data</code> after being split. The resulting values are stored in the <code>"split.with"</code> attribute of the output object. See Examples.
</p>


<h3>Value</h3>

<p>For <code>splitfactor()</code>, a <code>data.frame</code> containing the original data set with the newly created dummies. For <code>unsplitfactor()</code>. a <code>data.frame</code> containing the original data set with the newly created factor variables.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+model.matrix">model.matrix()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("lalonde", package = "cobalt")

lalonde.split &lt;- splitfactor(lalonde, "race", 
                             replace = TRUE, 
                             drop.first = TRUE)
# A data set with "race_hispan" and "race_white" instead
# of "race".

lalonde.unsplit &lt;- unsplitfactor(lalonde.split, "race", 
                                 replace = TRUE,
                                 dropped.level = "black")

all.equal(lalonde, lalonde.unsplit) #TRUE

# Demonstrating the use of split.with:
to.split &lt;- list(letters[1:ncol(lalonde)],
                 1:ncol(lalonde))

lalonde.split &lt;- splitfactor(lalonde, split.with = to.split,
                             drop.first = FALSE)
attr(lalonde.split, "split.with")


</code></pre>

<hr>
<h2 id='var.names'>Extract Variable Names from <code>bal.tab</code> Objects</h2><span id='topic+var.names'></span>

<h3>Description</h3>

<p>This function extracts variable names from a <code>bal.tab</code> object for use in specifying alternate variable names in <code><a href="#topic+love.plot">love.plot()</a></code>. Optionally, a file can be written for easy editing of names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var.names(b, type, file = NULL, minimal = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="var.names_+3A_b">b</code></td>
<td>
<p>a <code>bal.tab</code> object; the output of a call to <code><a href="#topic+bal.tab">bal.tab()</a></code>.</p>
</td></tr>
<tr><td><code id="var.names_+3A_type">type</code></td>
<td>
<p>the type of output desired. Can either be <code>"df"</code> for a data.frame or <code>"vec"</code> for a named vector. See &quot;Value&quot;. The default is <code>"vec"</code> unless <code>file</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="var.names_+3A_file">file</code></td>
<td>
<p>optional; a file name to save the output if <code>type = "df"</code>. See <code><a href="utils.html#topic+write.table">utils::write.csv()</a></code>, which <code>var.name()</code> calls. Must end in <code>.csv</code>.</p>
</td></tr>
<tr><td><code id="var.names_+3A_minimal">minimal</code></td>
<td>
<p>whether the output should contain all variable names (i.e., all rows that appear the output of <code>bal.tab()</code>) or just the unique base variables. See &quot;Details&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The goal of the function is to make supplying new variable names to the <code>var.names</code> argument in <code><a href="#topic+love.plot">love.plot()</a></code> easier. Rather than manually creating a vector or <code>data.frame</code> with all the variable names that one desires to change, one can use <code>var.names()</code> to extract variable names from a <code>bal.tab</code> object and edit the output. Importantly, the output can be saved to a CSV file, which can be easily edited and read back into R for use in <code>love.plot()</code>, as demonstrated in the Example.
</p>
<p>When <code>minimal = TRUE</code>, only a minimal set of variables will be output. For example, if the variables analyzed in <code>bal.tab()</code> are <code>age</code>, <code>race</code>, and <code>married</code>, and <code>int = TRUE</code> in <code>bal.tab()</code>, many variables will appear in the output, including expansions of the factor variables, the polynomial terms, and the interactions. Rather than renaming all of these variables individually, one can rename just the three base variables, and all variables that arise from them will be accordingly renamed. Setting <code>minimal = TRUE</code> requests only these base variables.
</p>


<h3>Value</h3>

<p>If <code>type = "vec"</code>, a character vector the the variable names both as the names and the entries.
</p>
<p>If <code>type = "df"</code>, a <code>data.frame</code> with two columns called <code>"old"</code> and <code>"new"</code>, each with the variables as the entries.
</p>
<p>If file is not <code>NULL</code>, the output will be returned invisibly.
</p>


<h3>Note</h3>

<p>Not all programs can properly read the Unicode characters for the polynomial terms when requested. These may appear strange in, e.g., Excel, but R will process the characters correctly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(lalonde, package = "cobalt")

b1 &lt;- bal.tab(treat ~ age + race + married, data = lalonde,
              int = TRUE)
v1 &lt;- var.names(b1, type = "vec", minimal = TRUE)
v1["age"] &lt;- "Age (Years)"
v1["race"] &lt;- "Race/Eth"
v1["married"] &lt;- "Married"
love.plot(b1, var.names = v1)
## Not run: 
b2 &lt;- bal.tab(treat ~ age + race + married + educ + nodegree +
                  re74 + re75 + I(re74==0) + I(re75==0), 
              data = lalonde)
var.names(b2, file = "varnames.csv")

##Manually edit the CSV (e.g., in Excel), then save it.
v2 &lt;- read.csv("varnames.csv")
love.plot(b2, var.names = v2)

## End(Not run)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
