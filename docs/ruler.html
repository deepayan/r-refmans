<!DOCTYPE html><html><head><title>Help for package ruler</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ruler}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#act_after_exposure'><p>Act after exposure</p></a></li>
<li><a href='#add_pack_names'><p>Add pack names to single exposures</p></a></li>
<li><a href='#any_breaker'><p>Is there any breaker in exposure?</p></a></li>
<li><a href='#assert_any_breaker'><p>Assert presence of rule breaker</p></a></li>
<li><a href='#bind_exposures'><p>Bind exposures</p></a></li>
<li><a href='#cell-pack'><p>Cell rule pack</p></a></li>
<li><a href='#column-pack'><p>Column rule pack</p></a></li>
<li><a href='#data-pack'><p>Data rule pack</p></a></li>
<li><a href='#expose'><p>Expose data to rule packs</p></a></li>
<li><a href='#expose_single'><p>Expose data to single rule pack</p></a></li>
<li><a href='#exposure'><p>Exposure</p></a></li>
<li><a href='#group-pack'><p>Group rule pack</p></a></li>
<li><a href='#inside_punct'><p>Inside punctuation regular expression</p></a></li>
<li><a href='#pack_info'><p>Pack info</p></a></li>
<li><a href='#packs_info'><p>Packs info</p></a></li>
<li><a href='#row-pack'><p>Row rule pack</p></a></li>
<li><a href='#rule-packs'><p>Create rule packs</p></a></li>
<li><a href='#ruler-package'><p>ruler: Rule Your Data</p></a></li>
<li><a href='#ruler-report'><p>Tidy data validation report</p></a></li>
<li><a href='#rules'><p>Create a list of rules</p></a></li>
<li><a href='#single_exposure'><p>Single exposure</p></a></li>
<li><a href='#spread_groups'><p>Spread grouping columns</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Tidy Data Validation Reports</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for creating data validation pipelines and
    tidy reports. This package offers a framework for exploring and
    validating data frame like objects using 'dplyr' grammar of data
    manipulation.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://echasnovski.github.io/ruler/">https://echasnovski.github.io/ruler/</a>,
<a href="https://github.com/echasnovski/ruler">https://github.com/echasnovski/ruler</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/echasnovski/ruler/issues">https://github.com/echasnovski/ruler/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr (&ge; 0.8.0), keyholder, rlang, tibble, tidyr (&ge; 0.7.0),
magrittr, purrr (&ge; 1.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-28 10:36:27 UTC; evgeni</td>
</tr>
<tr>
<td>Author:</td>
<td>Evgeni Chasnovski <a href="https://orcid.org/0000-0002-1617-4019"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Evgeni Chasnovski &lt;evgeni.chasnovski@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-28 10:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>

<hr>
<h2 id='act_after_exposure'>Act after exposure</h2><span id='topic+act_after_exposure'></span>

<h3>Description</h3>

<p>A wrapper for consistent application of some actions based on the data after
exposure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>act_after_exposure(.tbl, .trigger, .actor)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="act_after_exposure_+3A_.tbl">.tbl</code></td>
<td>
<p>Result of <a href="#topic+expose">exposure</a>, i.e. data frame with <a href="#topic+exposure">exposure</a>
attribute.</p>
</td></tr>
<tr><td><code id="act_after_exposure_+3A_.trigger">.trigger</code></td>
<td>
<p>Function which takes <code>.tbl</code> as argument and returns <code>TRUE</code> if
some action needs to be performed.</p>
</td></tr>
<tr><td><code id="act_after_exposure_+3A_.actor">.actor</code></td>
<td>
<p>Function which takes <code>.tbl</code> as argument and performs the
action.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Basically <code>act_after_exposure()</code> is doing the following:
</p>

<ul>
<li><p> Check that <code>.tbl</code> has a proper <a href="#topic+exposure">exposure</a> attribute.
</p>
</li>
<li><p> Compute whether to perform intended action by computing <code>.trigger(.tbl)</code>.
</p>
</li>
<li><p> If trigger results in <code>TRUE</code> then <code>.actor(.tbl)</code> <strong>is returned</strong>. In other
case <code>.tbl</code> is returned.
</p>
</li></ul>

<p>It is a good idea that <code>.actor</code> should be doing one of two things:
</p>

<ul>
<li><p> Making side effects. For example throwing an error (if condition in
<code>.trigger</code> is met), printing some information and so on. In this case it
should return <code>.tbl</code> to be used properly inside a <a href="magrittr.html#topic+pipe">pipe</a>.
</p>
</li>
<li><p> Changing <code>.tbl</code> based on exposure information. In this case it should
return the imputed version of <code>.tbl</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+any_breaker">any_breaker</a> for trigger which returns <code>TRUE</code> in case any rule
breaker is found in exposure.
</p>
<p><a href="#topic+assert_any_breaker">assert_any_breaker</a> for usage of <code>act_after_exposure()</code> in building data
validation pipelines.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exposure_printer &lt;- function(.tbl) {
  print(get_exposure(.tbl))
  .tbl
}
mtcars_exposed &lt;- mtcars %&gt;%
  expose(data_packs(. %&gt;% dplyr::summarise(nrow_low = nrow(.) &gt; 50))) %&gt;%
  act_after_exposure(any_breaker, exposure_printer)
</code></pre>

<hr>
<h2 id='add_pack_names'>Add pack names to single exposures</h2><span id='topic+add_pack_names'></span>

<h3>Description</h3>

<p>Function to add pack names to single exposures. Converts list of
<a href="#topic+single_exposure">single exposures</a> to list of <a href="#topic+exposure">exposures</a> without
validating.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_pack_names(.single_exposures)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_pack_names_+3A_.single_exposures">.single_exposures</code></td>
<td>
<p>List of <a href="#topic+single_exposure">single exposures</a>.</p>
</td></tr>
</table>

<hr>
<h2 id='any_breaker'>Is there any breaker in exposure?</h2><span id='topic+any_breaker'></span>

<h3>Description</h3>

<p>Function designed to be used as trigger in <code><a href="#topic+act_after_exposure">act_after_exposure()</a></code>. Returns
<code>TRUE</code> if <a href="#topic+exposure">exposure</a> attribute of <code>.tbl</code> has any information about data units
not obeying the rules, i.e. rule breakers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>any_breaker(.tbl)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="any_breaker_+3A_.tbl">.tbl</code></td>
<td>
<p>Result of <a href="#topic+expose">exposure</a>, i.e. data frame with <a href="#topic+exposure">exposure</a>
attribute.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+assert_any_breaker">assert_any_breaker</a> for implicit usage of <code>any_breaker()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars %&gt;%
  expose(data_packs(. %&gt;% dplyr::summarise(nrow_low = nrow(.) &gt; 50))) %&gt;%
  any_breaker()
</code></pre>

<hr>
<h2 id='assert_any_breaker'>Assert presence of rule breaker</h2><span id='topic+assert_any_breaker'></span>

<h3>Description</h3>

<p>Function to assert if <a href="#topic+expose">exposure</a> resulted in <a href="#topic+any_breaker">detecting</a>
some rule breakers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assert_any_breaker(.tbl, .type = "error", .silent = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assert_any_breaker_+3A_.tbl">.tbl</code></td>
<td>
<p>Result of <a href="#topic+expose">exposure</a>, i.e. data frame with <a href="#topic+exposure">exposure</a>
attribute.</p>
</td></tr>
<tr><td><code id="assert_any_breaker_+3A_.type">.type</code></td>
<td>
<p>The type of assertion. Can be only one of &quot;error&quot;, &quot;warning&quot; or
&quot;message&quot;.</p>
</td></tr>
<tr><td><code id="assert_any_breaker_+3A_.silent">.silent</code></td>
<td>
<p>If <code>TRUE</code> no printing of rule breaker information is done.</p>
</td></tr>
<tr><td><code id="assert_any_breaker_+3A_...">...</code></td>
<td>
<p>Arguments for printing rule breaker information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In case breaker presence this function does the following:
</p>

<ul>
<li><p> In case <code>.silent</code> is <code>FALSE</code> print rows from exposure
<a href="#topic+ruler-report">report</a> corresponding to rule breakers.
</p>
</li>
<li><p> Make assertion of the chosen <code>.type</code> about breaker presence in exposure.
</p>
</li>
<li><p> Return <code>.tbl</code> (for using inside a <a href="magrittr.html#topic+pipe">pipe</a>).
</p>
</li></ul>

<p>If there are no breakers only <code>.tbl</code> is returned.
</p>


<h3>See Also</h3>

<p><a href="#topic+any_breaker">any_breaker</a> for checking of breaker presence in exposure result.
</p>
<p><a href="#topic+act_after_exposure">act_after_exposure</a> for making general actions based in exposure result.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
mtcars %&gt;%
  expose(data_packs(. %&gt;% dplyr::summarise(nrow_low = nrow(.) &gt; 50))) %&gt;%
  assert_any_breaker()

## End(Not run)
</code></pre>

<hr>
<h2 id='bind_exposures'>Bind exposures</h2><span id='topic+bind_exposures'></span>

<h3>Description</h3>

<p>Function to bind several exposures into one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bind_exposures(..., .validate_output = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bind_exposures_+3A_...">...</code></td>
<td>
<p>Exposures to bind.</p>
</td></tr>
<tr><td><code id="bind_exposures_+3A_.validate_output">.validate_output</code></td>
<td>
<p>Whether to validate with <code><a href="#topic+is_exposure">is_exposure()</a></code> if the
output is exposure.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><strong>Note</strong> that the output might not have names in list-column <code>fun</code>
in <a href="#topic+packs_info">packs info</a>, which depends on version of
<a href="dplyr.html#topic+dplyr-package">dplyr</a> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my_data_packs &lt;- data_packs(
  data_dims = . %&gt;% dplyr::summarise(nrow_low = nrow(.) &lt; 10),
  data_sum = . %&gt;% dplyr::summarise(sum = sum(.) &lt; 1000)
)

ref_exposure &lt;- mtcars %&gt;%
  expose(my_data_packs) %&gt;%
  get_exposure()

exposure_1 &lt;- mtcars %&gt;%
  expose(my_data_packs[1]) %&gt;%
  get_exposure()
exposure_2 &lt;- mtcars %&gt;%
  expose(my_data_packs[2]) %&gt;%
  get_exposure()
exposure_binded &lt;- bind_exposures(exposure_1, exposure_2)

exposure_pipe &lt;- mtcars %&gt;%
  expose(my_data_packs[1]) %&gt;%
  expose(my_data_packs[2]) %&gt;%
  get_exposure()

identical(exposure_binded, ref_exposure)

identical(exposure_pipe, ref_exposure)
</code></pre>

<hr>
<h2 id='cell-pack'>Cell rule pack</h2><span id='topic+cell-pack'></span>

<h3>Description</h3>

<p>Cell rule pack is a <a href="#topic+rule-packs">rule pack</a> which defines a set of rules for
cells, i.e. functions which convert cells of interest to logical values. It
should return a data frame with the following properties:
</p>

<ul>
<li><p> Number of rows equals to <strong>number of rows for checked cells</strong>.
</p>
</li>
<li><p> Column names should be treated as concatenation of
<b>'column name of check cell' + 'separator' + 'rule name'</b>
</p>
</li>
<li><p> Values indicate whether the <strong>cell</strong> follows the rule.
</p>
</li></ul>



<h3>Details</h3>

<p>This format is inspired by <a href="dplyr.html#topic+mutate_all">scoped variants of transmute()</a>.
</p>
<p>The most common way to define cell pack is by creating a
<a href="magrittr.html#topic+pipe">functional sequence</a> containing one of:
</p>

<ul>
<li> <p><code>transmute_all(.funs = rules(...))</code>.
</p>
</li>
<li> <p><code>transmute_if(.predicate, .funs = rules(...))</code>.
</p>
</li>
<li> <p><code>transmute_at(.vars, .funs = rules(...))</code>.
</p>
</li></ul>

<p><strong>Note</strong> that (as of <code>dplyr</code> version 0.7.4) when only one column is
transmuted, names of the output don't have a necessary structure. The 'column
name of check cell' is missing which results (after <a href="#topic+expose">exposure</a>)
into empty string in <code>var</code> column of <a href="#topic+ruler-report">validation report</a>. The
current way of dealing with this is to name the input column (see examples).
</p>


<h3>Using rules()</h3>

<p>Using <code><a href="#topic+rules">rules()</a></code> to create list of functions for scoped <code>dplyr</code> &quot;mutating&quot;
verbs (such as <a href="dplyr.html#topic+summarise_all">summarise_all()</a> and
<a href="dplyr.html#topic+mutate_all">transmute_all()</a>) is recommended because:
</p>

<ul>
<li><p> It is a convenient way to ensure consistent naming of rules without manual
name.
</p>
</li>
<li><p> It adds a common prefix to all rule names. This helps in defining
separator as prefix surrounded by any number of non-alphanumeric values.
</p>
</li></ul>



<h3>Note about rearranging rows</h3>

<p><strong>Note</strong> that during exposure packs are applied to <a href="keyholder.html#topic+keys-set">keyed object</a> with <a href="keyholder.html#topic+keyholder-id">id key</a>. So they
can rearrange rows as long as it is done with <a href="keyholder.html#topic+keyholder-supported-funs">functions supported by keyholder</a>. Rows will be tracked and
recognized as in the original data frame of interest.
</p>


<h3>See Also</h3>

<p><a href="#topic+data-pack">Data pack</a>, <a href="#topic+group-pack">group pack</a>, <a href="#topic+column-pack">column pack</a>, <a href="#topic+row-pack">row pack</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cell_outlier_rules &lt;- . %&gt;% dplyr::transmute_at(
  c("disp", "qsec"),
  rules(z_score = abs(. - mean(.)) / sd(.) &gt; 1)
)

cell_packs(outlier = cell_outlier_rules)

# Dealing with one column edge case
improper_pack &lt;- . %&gt;% dplyr::transmute_at(
  dplyr::vars(vs),
  rules(improper_is_neg = . &lt; 0)
)

proper_pack &lt;- . %&gt;% dplyr::transmute_at(
  dplyr::vars(vs = vs),
  rules(proper_is_neg = . &lt; 0)
)

mtcars[1:2, ] %&gt;%
  expose(cell_packs(improper_pack, proper_pack)) %&gt;%
  get_report()
</code></pre>

<hr>
<h2 id='column-pack'>Column rule pack</h2><span id='topic+column-pack'></span>

<h3>Description</h3>

<p>Column rule pack is a <a href="#topic+rule-packs">rule pack</a> which defines a set of rules
for columns as a whole, i.e. functions which convert columns of interest to
logical values. It should return a data frame with the following properties:
</p>

<ul>
<li><p> Number of rows equals to <strong>one</strong>.
</p>
</li>
<li><p> Column names should be treated as concatenation of
<b>'check column name' + 'separator' + 'rule name'</b>.
</p>
</li>
<li><p> Values indicate whether the <strong>column as a whole</strong> follows the rule.
</p>
</li></ul>



<h3>Details</h3>

<p>This format is inspired by <code>dplyr</code>'s
<a href="dplyr.html#topic+summarise_all">scoped variants of summarise()</a> applied to non-grouped
data.
</p>
<p>The most common way to define column pack is by creating a
<a href="magrittr.html#topic+pipe">functional sequence</a> with no grouping and ending with
one of:
</p>

<ul>
<li> <p><code>summarise_all(.funs = rules(...))</code>.
</p>
</li>
<li> <p><code>summarise_if(.predicate, .funs = rules(...))</code>.
</p>
</li>
<li> <p><code>summarise_at(.vars, .funs = rules(...))</code>.
</p>
</li></ul>

<p><strong>Note</strong> that (as of <code>dplyr</code> version 0.7.4) when only one column is
summarised, names of the output don't have a necessary structure. The 'check
column name' is missing which results (after <a href="#topic+expose">exposure</a>) into empty
string in <code>var</code> column of <a href="#topic+ruler-report">validation report</a>. The current way
of dealing with this is to name the input column (see examples).
</p>


<h3>Using rules()</h3>

<p>Using <code><a href="#topic+rules">rules()</a></code> to create list of functions for scoped <code>dplyr</code> &quot;mutating&quot;
verbs (such as <a href="dplyr.html#topic+summarise_all">summarise_all()</a> and
<a href="dplyr.html#topic+mutate_all">transmute_all()</a>) is recommended because:
</p>

<ul>
<li><p> It is a convenient way to ensure consistent naming of rules without manual
name.
</p>
</li>
<li><p> It adds a common prefix to all rule names. This helps in defining
separator as prefix surrounded by any number of non-alphanumeric values.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+data-pack">Data pack</a>, <a href="#topic+group-pack">group pack</a>, <a href="#topic+row-pack">row pack</a>, <a href="#topic+cell-pack">cell pack</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Validating present columns
numeric_column_rules &lt;- . %&gt;% dplyr::summarise_if(
  is.numeric,
  rules(mean(.) &gt; 5, sd(.) &lt; 10)
)
character_column_rules &lt;- . %&gt;% dplyr::summarise_if(
  is.character,
  rules(. %in% letters[1:4])
)

col_packs(
  num_col = numeric_column_rules,
  chr_col = character_column_rules
)

# Dealing with one column edge case
improper_pack &lt;- . %&gt;% dplyr::summarise_at(
  dplyr::vars(vs),
  rules(improper_is_chr = is.character)
)

proper_pack &lt;- . %&gt;% dplyr::summarise_at(
  dplyr::vars(vs = vs),
  rules(proper_is_chr = is.character)
)

mtcars %&gt;%
  expose(col_packs(improper_pack, proper_pack)) %&gt;%
  get_report()
</code></pre>

<hr>
<h2 id='data-pack'>Data rule pack</h2><span id='topic+data-pack'></span>

<h3>Description</h3>

<p>Data rule pack is a <a href="#topic+rule-packs">rule pack</a> which defines a set of rules for
data as a whole, i.e. functions which convert data to logical values. It
should return a data frame with the following properties:
</p>

<ul>
<li><p> Number of rows equals to <strong>one</strong>.
</p>
</li>
<li><p> Column names should be treated as <strong>rule names</strong>.
</p>
</li>
<li><p> Values indicate whether the <strong>data as a whole</strong> follows the rule.
</p>
</li></ul>



<h3>Details</h3>

<p>This format is inspired by <code>dplyr</code>'s <a href="dplyr.html#topic+summarise">summarise()</a> applied
to non-grouped data.
</p>
<p>The most common way to define data pack is by creating a
<a href="magrittr.html#topic+pipe">functional sequence</a> with no grouping and ending with
<code>summarise(...)</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+group-pack">Group pack</a>, <a href="#topic+column-pack">Column pack</a>, <a href="#topic+row-pack">row pack</a>, <a href="#topic+cell-pack">cell pack</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data_dims_rules &lt;- . %&gt;%
  dplyr::summarise(
    nrow_low = nrow(.) &gt; 10,
    nrow_up = nrow(.) &lt; 20,
    ncol_low = ncol(.) &gt; 5,
    ncol_up = ncol(.) &lt; 10
  )
data_na_rules &lt;- . %&gt;%
  dplyr::summarise(all_not_na = Negate(anyNA)(.))

data_packs(
  data_nrow = data_dims_rules,
  data_na = data_na_rules
)
</code></pre>

<hr>
<h2 id='expose'>Expose data to rule packs</h2><span id='topic+expose'></span>

<h3>Description</h3>

<p>Function for applying rule packs to data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expose(.tbl, ..., .rule_sep = inside_punct("\\._\\."),
  .remove_obeyers = TRUE, .guess = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expose_+3A_.tbl">.tbl</code></td>
<td>
<p>Data frame of interest.</p>
</td></tr>
<tr><td><code id="expose_+3A_...">...</code></td>
<td>
<p>Rule packs. They can be in pure form or inside a list
(at any depth).</p>
</td></tr>
<tr><td><code id="expose_+3A_.rule_sep">.rule_sep</code></td>
<td>
<p>Regular expression used as separator between column and
rule names in <a href="#topic+column-pack">col packs</a> and <a href="#topic+cell-pack">cell packs</a>.</p>
</td></tr>
<tr><td><code id="expose_+3A_.remove_obeyers">.remove_obeyers</code></td>
<td>
<p>Whether to remove elements which obey rules from
report.</p>
</td></tr>
<tr><td><code id="expose_+3A_.guess">.guess</code></td>
<td>
<p>Whether to guess type of unsupported rule pack type (see
Details).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>expose()</code> applies all supplied rule packs to data, creates an
<a href="#topic+exposure">exposure</a> object based on results and stores it to attribute 'exposure'.
It is guaranteed that <code>.tbl</code> is not modified in any other way in order to
use <code>expose()</code> inside a <code><a href="magrittr.html#topic+pipe">pipe</a></code>.
</p>
<p>It is a good idea to name all rule packs: explicitly in <code>...</code> (if they are
supplied not inside list) or during creation with respective rule pack
function. In case of missing name it is imputed based on possibly existing
exposure attribute in <code>.tbl</code> and supplied rule packs. Imputation is similar
to one in <code><a href="#topic+rules">rules()</a></code> but applied to every pack type separately.
</p>
<p>Default value for <code>.rule_sep</code> is the regular expression <code style="white-space: pre;">&#8288;characters ._. surrounded by non alphanumeric characters&#8288;</code>. It is picked to be used
smoothly with <code>dplyr</code>'s <a href="dplyr.html#topic+scoped">scoped verbs</a> and <code><a href="#topic+rules">rules()</a></code> instead
of pure list. In most cases it shouldn't be changed but if needed it
should align with <code>.prefix</code> in <code><a href="#topic+rules">rules()</a></code>.
</p>


<h3>Value</h3>

<p>A <code>.tbl</code> with possibly added 'exposure' attribute containing the
resulting <a href="#topic+exposure">exposure</a>. If <code>.tbl</code> already contains 'exposure' attribute then
the result is binded with it.
</p>


<h3>Guessing</h3>

<p>To work properly in some edge cases one should specify pack types with
<a href="#topic+rule-packs">appropriate function</a>. However with <code>.guess</code> equals to <code>TRUE</code>
<code>expose</code> will guess the pack type based on its output after applying to
<code>.tbl</code>. It uses the following features:
</p>

<ul>
<li><p> Presence of non-logical columns: if present then the guess is <a href="#topic+group-pack">group pack</a>. Grouping columns are guessed as all non-logical. This
works incorrectly if some grouping column is logical: it will be guessed as
result of applying the rule. <strong>Note</strong> that on most occasions this edge case
will produce error about grouping columns define non-unique levels.
</p>
</li>
<li><p> Combination of whether number of rows equals 1 (<code>n_rows_one</code>) and
presence of <code>.rule_sep</code> in all column names (<code>all_contain_sep</code>). Guesses
are:
</p>

<ul>
<li> <p><a href="#topic+data-pack">Data pack</a> if <code>n_rows_one == TRUE</code> and <code>all_contain_sep   == FALSE</code>.
</p>
</li>
<li> <p><a href="#topic+column-pack">Column pack</a> if <code>n_rows_one == TRUE</code> and
<code>all_contain_sep == TRUE</code>.
</p>
</li>
<li> <p><a href="#topic+row-pack">Row pack</a> if <code>n_rows_one == FALSE</code> and <code>all_contain_sep ==   FALSE</code>. This works incorrectly if output has one row which is checked.
In this case it will be guessed as data pack.
</p>
</li>
<li> <p><a href="#topic+cell-pack">Cell pack</a> if <code>n_rows_one == FALSE</code> and <code>all_contain_sep   == TRUE</code>. This works incorrectly if output has one row in which cells
are checked. In this case it will be guessed as column pack.
</p>
</li></ul>

</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>my_rule_pack &lt;- . %&gt;% dplyr::summarise(nrow_neg = nrow(.) &lt; 0)
my_data_packs &lt;- data_packs(my_data_pack_1 = my_rule_pack)

# These pipes give identical results
mtcars %&gt;%
  expose(my_data_packs) %&gt;%
  get_report()

mtcars %&gt;%
  expose(my_data_pack_1 = my_rule_pack) %&gt;%
  get_report()

# This throws an error because no pack type is specified for my_rule_pack
## Not run: 
mtcars %&gt;% expose(my_data_pack_1 = my_rule_pack, .guess = FALSE)

## End(Not run)

# Edge cases against using 'guess = TRUE' for robust code
group_rule_pack &lt;- . %&gt;%
  dplyr::mutate(vs_one = vs == 1) %&gt;%
  dplyr::group_by(vs_one, am) %&gt;%
  dplyr::summarise(n_low = dplyr::n() &gt; 10)
group_rule_pack_dummy &lt;- . %&gt;%
  dplyr::mutate(vs_one = vs == 1) %&gt;%
  dplyr::group_by(mpg, vs_one, wt) %&gt;%
  dplyr::summarise(n_low = dplyr::n() &gt; 10)
row_rule_pack &lt;- . %&gt;% dplyr::transmute(neg_row_sum = rowSums(.) &lt; 0)
cell_rule_pack &lt;- . %&gt;% dplyr::transmute_all(rules(neg_value = . &lt; 0))

# Only column 'am' is guessed as grouping which defines non-unique levels.
## Not run: 
mtcars %&gt;%
  expose(group_rule_pack, .remove_obeyers = FALSE, .guess = TRUE) %&gt;%
  get_report()

## End(Not run)

# Values in `var` should contain combination of three grouping columns but
# column 'vs_one' is guessed as rule. No error is thrown because the guessed
# grouping column define unique levels.
mtcars %&gt;%
  expose(group_rule_pack_dummy, .remove_obeyers = FALSE, .guess = TRUE) %&gt;%
  get_report()

# Results should have in column 'id' value 1 and not 0.
mtcars %&gt;%
  dplyr::slice(1) %&gt;%
  expose(row_rule_pack) %&gt;%
  get_report()

mtcars %&gt;%
  dplyr::slice(1) %&gt;%
  expose(cell_rule_pack) %&gt;%
  get_report()
</code></pre>

<hr>
<h2 id='expose_single'>Expose data to single rule pack</h2><span id='topic+expose_single'></span>

<h3>Description</h3>

<p>The workhorse generic function for doing exposure. The result is
<a href="#topic+single_exposure">single_exposure</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expose_single(.tbl, .pack, .rule_sep, .remove_obeyers, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expose_single_+3A_.tbl">.tbl</code></td>
<td>
<p>Data frame of interest.</p>
</td></tr>
<tr><td><code id="expose_single_+3A_.pack">.pack</code></td>
<td>
<p>Rule pack function.</p>
</td></tr>
<tr><td><code id="expose_single_+3A_.rule_sep">.rule_sep</code></td>
<td>
<p>Regular expression used as separator between column and
rule names in <a href="#topic+column-pack">col packs</a> and <a href="#topic+cell-pack">cell packs</a>.</p>
</td></tr>
<tr><td><code id="expose_single_+3A_.remove_obeyers">.remove_obeyers</code></td>
<td>
<p>Whether to remove elements which obey rules from
report.</p>
</td></tr>
<tr><td><code id="expose_single_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>

<hr>
<h2 id='exposure'>Exposure</h2><span id='topic+exposure'></span><span id='topic+is_exposure'></span><span id='topic+get_exposure'></span><span id='topic+remove_exposure'></span>

<h3>Description</h3>

<p>Exposure is a result of <a href="#topic+expose">exposing</a> data to rules. It is
implemented with S3 class <code>exposure</code> which is a list of the following
structure: <code>packs_info</code> - a <a href="#topic+packs_info">packs_info</a> object; <code>report</code> -
<a href="#topic+ruler-report">tidy data validation report</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_exposure(.x)

get_exposure(.object)

remove_exposure(.object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exposure_+3A_.x">.x</code></td>
<td>
<p>Object to test.</p>
</td></tr>
<tr><td><code id="exposure_+3A_.object">.object</code></td>
<td>
<p>Object to get or remove <code>exposure</code> attribute from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>get_exposure()</code> returns <code>object</code> if it is exposure and its attribute
'exposure' otherwise.
</p>
<p><code>remove_exposure()</code> returns <code>object</code> with removed attributed 'exposure'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my_col_packs &lt;- col_packs(
  col_sum_props = . %&gt;% dplyr::summarise_all(
    rules(
      col_sum_low = sum(.) &gt; 100,
      col_sum_high = sum(.) &lt; 1000
    )
  )
)
mtcars_exposed &lt;- mtcars %&gt;% expose(my_col_packs)
mtcars_exposure &lt;- mtcars_exposed %&gt;% get_exposure()

is_exposure(mtcars_exposure)

identical(remove_exposure(mtcars_exposed), mtcars)

identical(get_exposure(mtcars_exposure), mtcars_exposure)
</code></pre>

<hr>
<h2 id='group-pack'>Group rule pack</h2><span id='topic+group-pack'></span>

<h3>Description</h3>

<p>Group rule pack is a <a href="#topic+rule-packs">rule pack</a> which defines a set of rules
for groups of rows as a whole, i.e. functions which convert groups of
interest to logical values. It should return a data frame with the following
properties:
</p>

<ul>
<li><p> There should be present some columns which combined values <strong>uniquely</strong>
describe group. They should be defined during creation with
<a href="#topic+rule-packs">group_packs()</a>.
</p>
</li>
<li><p> Number of rows equals to <strong>number of checked groups</strong>.
</p>
</li>
<li><p> Names of non-grouping columns should be treated as <strong>rule names</strong>.
</p>
</li>
<li><p> Values indicate whether the <strong>group as a whole</strong> follows the rule.
</p>
</li></ul>



<h3>Details</h3>

<p>This format is inspired by <code>dplyr</code>'s <a href="dplyr.html#topic+summarise">summarise()</a> applied
to grouped data.
</p>
<p>The most common way to define data pack is by creating a
<a href="magrittr.html#topic+pipe">functional sequence</a> with grouping and ending with
<code>summarise(...)</code>.
</p>


<h3>Interpretation</h3>

<p>Group pack output is interpreted in the following way:
</p>

<ul>
<li><p> All grouping columns are <a href="tidyr.html#topic+unite">united</a> with delimiter <code>.group_sep</code>
(which is an argument of <code>group_packs()</code>).
</p>
</li>
<li><p> Levels of the resulting column are treated as names of some new variables
which should be exposed as a whole. Names of non-grouping columns are treated
as rule names. They are transformed in <a href="#topic+column-pack">column pack</a> format and
interpreted accordingly.
</p>
</li></ul>

<p>Exposure result of group pack is different from others in a way that column
<code>var</code> in <a href="#topic+ruler-report">exposure report</a> doesn't represent the actual column
in data.
</p>


<h3>See Also</h3>

<p><a href="#topic+data-pack">Data pack</a>, <a href="#topic+column-pack">Column pack</a>, <a href="#topic+row-pack">row pack</a>, <a href="#topic+cell-pack">cell pack</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vs_am_rules &lt;- . %&gt;%
  dplyr::group_by(vs, am) %&gt;%
  dplyr::summarise(
    nrow_low = n(.) &gt; 10,
    nrow_up = n(.) &lt; 20,
    rowmeans_low = rowMeans(.) &gt; 19
  )

group_packs(vs_am = vs_am_rules, .group_vars = c("vs", "am"))
</code></pre>

<hr>
<h2 id='inside_punct'>Inside punctuation regular expression</h2><span id='topic+inside_punct'></span>

<h3>Description</h3>

<p>Function to construct regular expression of form: 'non alpha-numeric
characters' + 'some characters' + 'non alpha-numeric characters'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inside_punct(.x = "\\._\\.")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inside_punct_+3A_.x">.x</code></td>
<td>
<p>Middle characters to be put between non alpha-numeric characters.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>inside_punct()

inside_punct("abc")
</code></pre>

<hr>
<h2 id='pack_info'>Pack info</h2><span id='topic+pack_info'></span><span id='topic+new_pack_info'></span>

<h3>Description</h3>

<p>An S3 class <code>pack_info</code> to represent information about pack in <a href="#topic+single_exposure">single exposure</a>. Its content is as in <a href="#topic+packs_info">packs_info</a> but without
column 'name'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_pack_info(.pack, .remove_obeyers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pack_info_+3A_.pack">.pack</code></td>
<td>
<p><a href="#topic+rule-packs">Rule pack</a>.</p>
</td></tr>
<tr><td><code id="pack_info_+3A_.remove_obeyers">.remove_obeyers</code></td>
<td>
<p>Value of <code>.remove_obeyers</code> argument of <code><a href="#topic+expose">expose()</a></code> with
which <code>.pack</code> was applied.</p>
</td></tr>
</table>

<hr>
<h2 id='packs_info'>Packs info</h2><span id='topic+packs_info'></span><span id='topic+is_packs_info'></span><span id='topic+get_packs_info'></span>

<h3>Description</h3>

<p>An S3 class <code>packs_info</code> to represent information about packs in <a href="#topic+exposure">exposure</a>.
It is a tibble with the following structure:
</p>

<ul>
<li> <p><strong>name</strong> <code style="white-space: pre;">&#8288;&lt;chr&gt;&#8288;</code> : Name of the pack.
</p>
</li>
<li> <p><strong>type</strong> <code style="white-space: pre;">&#8288;&lt;chr&gt;&#8288;</code> : <a href="#topic+rule-packs">Pack type</a>.
</p>
</li>
<li> <p><strong>fun</strong> <code style="white-space: pre;">&#8288;&lt;list&gt;&#8288;</code> : List (preferably unnamed) of rule pack functions.
</p>
</li>
<li> <p><strong>remove_obeyers</strong> <code style="white-space: pre;">&#8288;&lt;lgl&gt;&#8288;</code> : value of <code>.remove_obeyers</code> argument of
<code><a href="#topic+expose">expose()</a></code> with which pack was applied.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>is_packs_info(.x, .skip_class = FALSE)

get_packs_info(.object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="packs_info_+3A_.x">.x</code></td>
<td>
<p>Object to test.</p>
</td></tr>
<tr><td><code id="packs_info_+3A_.skip_class">.skip_class</code></td>
<td>
<p>Whether to skip checking inheritance from <code>packs_info</code>.</p>
</td></tr>
<tr><td><code id="packs_info_+3A_.object">.object</code></td>
<td>
<p>Object to get <code>packs_info</code> value from <code>exposure</code> attribute.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>To avoid possible confusion it is preferred (but not required) that
list-column <code>fun</code> doesn't have names. Names of packs are stored in <code>name</code>
column. During <a href="#topic+expose">exposure</a> <code>fun</code> is always created without names.
</p>


<h3>Value</h3>

<p><code>get_packs_info()</code> returns <code>packs_info</code> attribute of <code>object</code> if it
is exposure and of its 'exposure' attribute otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my_row_packs &lt;- row_packs(
  row_mean_props = . %&gt;% dplyr::transmute(row_mean = rowMeans(.)) %&gt;%
    dplyr::transmute(
      row_mean_low = row_mean &gt; 20,
      row_mean_high = row_mean &lt; 60
    ),
  row_outlier = . %&gt;% dplyr::transmute(row_sum = rowSums(.)) %&gt;%
    dplyr::transmute(
      not_row_outlier = abs(row_sum - mean(row_sum)) / sd(row_sum) &lt; 1.5
    )
)
my_data_packs &lt;- data_packs(
  data_dims = . %&gt;% dplyr::summarise(
    nrow = nrow(.) == 32,
    ncol = ncol(.) == 5
  )
)

mtcars_exposed &lt;- mtcars %&gt;%
  expose(my_data_packs, .remove_obeyers = FALSE) %&gt;%
  expose(my_row_packs)

mtcars_exposed %&gt;% get_packs_info()

mtcars_exposed %&gt;%
  get_packs_info() %&gt;%
  is_packs_info()
</code></pre>

<hr>
<h2 id='row-pack'>Row rule pack</h2><span id='topic+row-pack'></span>

<h3>Description</h3>

<p>Row rule pack is a <a href="#topic+rule-packs">rule pack</a> which defines a set of rules for
rows as a whole, i.e. functions which convert rows of interest to logical
values. It should return a data frame with the following properties:
</p>

<ul>
<li><p> Number of rows equals to <strong>number of checked rows</strong>.
</p>
</li>
<li><p> Column names should be treated as <strong>rule names</strong>.
</p>
</li>
<li><p> Values indicate whether the <strong>row as a whole</strong> follows the rule.
</p>
</li></ul>



<h3>Details</h3>

<p>This format is inspired by <code>dplyr</code>'s <a href="dplyr.html#topic+transmute">transmute()</a>.
</p>
<p>The most common way to define row pack is by creating a
<a href="magrittr.html#topic+pipe">functional sequence</a> containing <code>transmute(...)</code>.
</p>


<h3>Note about rearranging rows</h3>

<p><strong>Note</strong> that during exposure packs are applied to <a href="keyholder.html#topic+keys-set">keyed object</a> with <a href="keyholder.html#topic+keyholder-id">id key</a>. So they
can rearrange rows as long as it is done with <a href="keyholder.html#topic+keyholder-supported-funs">functions supported by keyholder</a>. Rows will be tracked and
recognized as in the original data frame of interest.
</p>


<h3>See Also</h3>

<p><a href="#topic+data-pack">Data pack</a>, <a href="#topic+group-pack">group pack</a>, <a href="#topic+column-pack">column pack</a>, <a href="#topic+cell-pack">cell pack</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>some_row_mean_rules &lt;- . %&gt;%
  dplyr::slice(1:3) %&gt;%
  dplyr::mutate(row_mean = rowMeans(.)) %&gt;%
  dplyr::transmute(
    row_mean_low = row_mean &gt; 10,
    row_mean_up = row_mean &lt; 20
  )
all_row_sum_rules &lt;- . %&gt;%
  dplyr::mutate(row_sum = rowSums(.)) %&gt;%
  dplyr::transmute(row_sum_low = row_sum &gt; 30)

row_packs(
  some_row_mean_rules,
  all_row_sum_rules
)
</code></pre>

<hr>
<h2 id='rule-packs'>Create rule packs</h2><span id='topic+rule-packs'></span><span id='topic+packs'></span><span id='topic+data_packs'></span><span id='topic+group_packs'></span><span id='topic+col_packs'></span><span id='topic+row_packs'></span><span id='topic+cell_packs'></span>

<h3>Description</h3>

<p>Functions for creating different kinds of rule packs. <strong>Rule</strong> is a function
which converts data unit of interest (data, group, column, row, cell) to
logical value indicating whether this object satisfies certain condition.
<strong>Rule pack</strong> is a function which combines several rules into one functional
block. It takes a data frame of interest and returns a data frame with
certain structure and column naming scheme. Types of packs differ in
interpretation of their output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data_packs(...)

group_packs(..., .group_vars, .group_sep = ".")

col_packs(...)

row_packs(...)

cell_packs(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rule-packs_+3A_...">...</code></td>
<td>
<p>Functions which define packs. They can be in pure form or inside a
list (at any depth).</p>
</td></tr>
<tr><td><code id="rule-packs_+3A_.group_vars">.group_vars</code></td>
<td>
<p>Character vector of names of grouping variables.</p>
</td></tr>
<tr><td><code id="rule-packs_+3A_.group_sep">.group_sep</code></td>
<td>
<p>String to be used as separator when uniting grouping
levels for <code>var</code> column in <a href="#topic+ruler-report">exposure report</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions convert <code>...</code> to list, apply <code>rlang</code>'s
<a href="rlang.html#topic+flatten">squash()</a> and add appropriate classes (<code>group_packs()</code> also
adds necessary attributes). Also they are only constructors and do not check
for validity of certain pack. <strong>Note</strong> that it is allowed for elements of
<code>...</code> to not have names: they will be computed during exposure. However it is
a good idea to manually name packs.
</p>


<h3>Value</h3>

<p><code>data_packs()</code> returns a list of what should be <a href="#topic+data-pack">data rule packs</a>, <code>group_packs()</code> - <a href="#topic+group-pack">group rule packs</a>,
<code>col_packs()</code> - <a href="#topic+column-pack">column rule packs</a>, <code>row_packs()</code> - <a href="#topic+row-pack">row rule packs</a>, <code>cell_packs()</code> - <a href="#topic+cell-pack">cell rule packs</a>.
</p>

<hr>
<h2 id='ruler-package'>ruler: Rule Your Data</h2><span id='topic+ruler'></span><span id='topic+ruler-package'></span>

<h3>Description</h3>

<p><code>ruler</code> offers a set of tools for creating tidy data validation reports using
<a href="https://dplyr.tidyverse.org">dplyr</a> grammar of data manipulation. It
is designed to be flexible and extendable in terms of creating rules and
using their output.
</p>


<h3>Details</h3>

<p>The common workflow is:
</p>

<ul>
<li><p> Define dplyr-style <a href="#topic+rule-packs">packs</a> of rules for basic data units (data,
group, column, row, cell) to obey.
</p>
</li>
<li> <p><a href="#topic+expose">Expose</a> some data to those rules. The result is the same data with
possibly created <a href="#topic+exposure">exposure</a> attribute. Exposure contains
information <a href="#topic+packs_info">about applied packs</a> and <a href="#topic+ruler-report">tidy data validation report</a>.
</p>
</li>
<li><p> Use data and exposure to perform some <a href="#topic+act_after_exposure">actions</a>:
<a href="#topic+assert_any_breaker">assert about rule breakers</a>, impute data, remove
outliers and so on.
</p>
</li></ul>

<p>To learn more about <code>ruler</code> browse vignettes with <code>browseVignettes(package = "ruler")</code>. The preferred order is:
</p>

<ol>
<li><p> Design process and exposure format.
</p>
</li>
<li><p> Rule packs.
</p>
</li>
<li><p> Validation
</p>
</li></ol>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Evgeni Chasnovski <a href="mailto:evgeni.chasnovski@gmail.com">evgeni.chasnovski@gmail.com</a> (<a href="https://orcid.org/0000-0002-1617-4019">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://echasnovski.github.io/ruler/">https://echasnovski.github.io/ruler/</a>
</p>
</li>
<li> <p><a href="https://github.com/echasnovski/ruler">https://github.com/echasnovski/ruler</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/echasnovski/ruler/issues">https://github.com/echasnovski/ruler/issues</a>
</p>
</li></ul>


<hr>
<h2 id='ruler-report'>Tidy data validation report</h2><span id='topic+ruler-report'></span><span id='topic+is_report'></span><span id='topic+get_report'></span>

<h3>Description</h3>

<p>A tibble representing the data validation result of certain data units in
tidy way:
</p>

<ul>
<li> <p><strong>pack</strong> <code style="white-space: pre;">&#8288;&lt;chr&gt;&#8288;</code> : Name of rule pack from column 'name' of corresponding
<a href="#topic+packs_info">packs_info</a> object.
</p>
</li>
<li> <p><strong>rule</strong> <code style="white-space: pre;">&#8288;&lt;chr&gt;&#8288;</code> : Name of the rule defined in rule pack.
</p>
</li>
<li> <p><strong>var</strong> <code style="white-space: pre;">&#8288;&lt;chr&gt;&#8288;</code> : Name of the variable which validation result is reported.
Value '.all' is reserved and interpreted as 'all columns as a whole'.
<strong>Note</strong> that <code>var</code> doesn't always represent the actual column in data frame
(see <a href="#topic+group-pack">group packs</a>).
</p>
</li>
<li> <p><strong>id</strong> <code style="white-space: pre;">&#8288;&lt;int&gt;&#8288;</code> : Index of the row in tested data frame which validation
result is reported. Value 0 is reserved and interpreted as 'all rows as a
whole'.
</p>
</li>
<li> <p><strong>value</strong> <code style="white-space: pre;">&#8288;&lt;lgl&gt;&#8288;</code> : Whether the described data unit obeys the rule.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>is_report(.x, .skip_class = FALSE)

get_report(.object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ruler-report_+3A_.x">.x</code></td>
<td>
<p>Object to test.</p>
</td></tr>
<tr><td><code id="ruler-report_+3A_.skip_class">.skip_class</code></td>
<td>
<p>Whether to skip checking inheritance from <code>ruler_report</code>.</p>
</td></tr>
<tr><td><code id="ruler-report_+3A_.object">.object</code></td>
<td>
<p>Object to get <code>report</code> value from <code>exposure</code> attribute.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are four basic combinations of <code>var</code> and <code>id</code> values which
define five basic data units:
</p>

<ul>
<li> <p><code>var == '.all'</code> and <code>id == 0</code>: Data as a whole.
</p>
</li>
<li> <p><code>var != '.all'</code> and <code>id == 0</code>: Group (<code>var</code> shouldn't be an actual column
name) or column (<code>var</code> should be an actual column name) as a whole.
</p>
</li>
<li> <p><code>var == '.all'</code> and <code>id != 0</code>: Row as a whole.
</p>
</li>
<li> <p><code>var != '.all'</code> and <code>id != 0</code>: Described cell.
</p>
</li></ul>



<h3>Value</h3>

<p><code>get_report()</code> returns <code>report</code> element of <code>object</code> if it is
exposure and of its 'exposure' attribute otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my_row_packs &lt;- row_packs(
  row_mean_props = . %&gt;% dplyr::transmute(row_mean = rowMeans(.)) %&gt;%
    dplyr::transmute(
      row_mean_low = row_mean &gt; 20,
      row_mean_high = row_mean &lt; 60
    ),
  row_outlier = . %&gt;% dplyr::transmute(row_sum = rowSums(.)) %&gt;%
    dplyr::transmute(
      not_row_outlier = abs(row_sum - mean(row_sum)) / sd(row_sum) &lt; 1.5
    )
)
my_data_packs &lt;- data_packs(
  data_dims = . %&gt;% dplyr::summarise(
    nrow = nrow(.) == 32,
    ncol = ncol(.) == 5
  )
)

mtcars_exposed &lt;- mtcars %&gt;%
  expose(my_data_packs, .remove_obeyers = FALSE) %&gt;%
  expose(my_row_packs)

mtcars_exposed %&gt;% get_report()

mtcars_exposed %&gt;%
  get_report() %&gt;%
  is_report()
</code></pre>

<hr>
<h2 id='rules'>Create a list of rules</h2><span id='topic+rules'></span>

<h3>Description</h3>

<p><code>rules()</code> is a function designed to create input for <code>.funs</code> argument of
scoped <code>dplyr</code> &quot;mutating&quot; verbs (such as
<a href="dplyr.html#topic+summarise_all">summarise_all()</a> and
<a href="dplyr.html#topic+mutate_all">transmute_all()</a>). It converts bare expressions
with <code>.</code> as input into formulas and repairs names of the output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rules(..., .prefix = "._.")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rules_+3A_...">...</code></td>
<td>
<p>Bare expression(s) with <code>.</code> as input.</p>
</td></tr>
<tr><td><code id="rules_+3A_.prefix">.prefix</code></td>
<td>
<p>Prefix to be added to function names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rules()</code> repairs names by the following algorithm:
</p>

<ul>
<li><p> Absent names are replaced with the 'rule__\ind\' where \ind\ is the
index of function position in the <code>...</code> .
</p>
</li>
<li> <p><code>.prefix</code> is added at the beginning of all names. The default is <code>._.</code> . It
is picked for its symbolism (it is the Morse code of letter 'R') and rare
occurrence in names. In those rare cases it can be manually changed but
this will not be tracked further. <strong>Note</strong> that it is a good idea for
<code>.prefix</code> to be <a href="base.html#topic+make.names">syntactic</a>, as <code>dplyr</code> will force tibble
names to be syntactic. To check if string is &quot;good&quot;, use it as input to
<code>make.names()</code>: if output equals that string than it is a &quot;good&quot; choice.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># `rules()` accepts bare expression calls with `.` as input, which is not
# possible with advised `list()` approach of `dplyr`
dplyr::summarise_all(mtcars[, 1:2], rules(sd, "sd", sd(.), ~ sd(.)))

dplyr::summarise_all(mtcars[, 1:2], rules(sd, .prefix = "a_a_"))

# Use `...` in `summarise_all()` to supply extra arguments
dplyr::summarise_all(data.frame(x = c(1:2, NA)), rules(sd), na.rm = TRUE)
</code></pre>

<hr>
<h2 id='single_exposure'>Single exposure</h2><span id='topic+single_exposure'></span>

<h3>Description</h3>

<p>An S3 class <code>single_exposure</code> to represent exposure of data to <strong>one</strong> rule
pack. It is a list of the following structure: <code>pack_info</code> - single
<a href="#topic+pack_info">pack_info</a> object; <code>report</code> - <a href="#topic+ruler-report">tidy data validation report</a>
without column <code>pack</code>.
</p>


<h3>Details</h3>

<p>Single exposure is implemented in order to encapsulate preliminary
exposure data from single rule pack. It is needed to impute possibly missing
pack names during <a href="#topic+expose">exposure</a>. That is why <code>single_exposure</code> doesn't
contain pack name in any form.
</p>

<hr>
<h2 id='spread_groups'>Spread grouping columns</h2><span id='topic+spread_groups'></span>

<h3>Description</h3>

<p>Function that is used during interpretation of <a href="#topic+group-pack">group pack</a>
output. It converts grouped <a href="dplyr.html#topic+summarise">summary</a> into <a href="#topic+column-pack">column pack</a> format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spread_groups(.tbl, ..., .group_sep = ".", .col_sep = "._.")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spread_groups_+3A_.tbl">.tbl</code></td>
<td>
<p>Data frame with result of grouped summary.</p>
</td></tr>
<tr><td><code id="spread_groups_+3A_...">...</code></td>
<td>
<p>A selection of grouping columns (as in <code><a href="tidyr.html#topic+unite">tidyr::unite()</a></code>).</p>
</td></tr>
<tr><td><code id="spread_groups_+3A_.group_sep">.group_sep</code></td>
<td>
<p>A string to be used as separator of grouping levels.</p>
</td></tr>
<tr><td><code id="spread_groups_+3A_.col_sep">.col_sep</code></td>
<td>
<p>A string to be used as separator in column pack.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multiple grouping variables are converted to one with
<code><a href="tidyr.html#topic+unite">tidyr::unite()</a></code> and separator <code>.group_sep</code>. New values are then treated as
variable names which should be validated and which represent the group data
as a whole.
</p>


<h3>Value</h3>

<p>A data frame in <a href="#topic+column-pack">column pack</a> format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mtcars_grouped_summary &lt;- mtcars %&gt;%
  dplyr::group_by(vs, am) %&gt;%
  dplyr::summarise(n_low = dplyr::n() &gt; 6, n_high = dplyr::n() &lt; 10)

spread_groups(mtcars_grouped_summary, vs, am)

spread_groups(mtcars_grouped_summary, vs, am, .group_sep = "__")

spread_groups(mtcars_grouped_summary, vs, am, .col_sep = "__")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
