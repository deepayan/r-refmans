<!DOCTYPE html><html lang="en"><head><title>Help for package UPSvarApprox</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {UPSvarApprox}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#UPSvarApprox-package'><p>UPSvarApprox: Approximate the variance of the Horvitz-Thompson estimator</p></a></li>
<li><a href='#approx_var_est'><p>Approximated Variance Estimators</p></a></li>
<li><a href='#is.wholenumber'><p>Check if a number is integer</p></a></li>
<li><a href='#Var_approx'><p>Approximate the Variance of the Horvitz-Thompson estimator</p></a></li>
<li><a href='#var_Berger'><p>Berger approximate variance estimator</p></a></li>
<li><a href='#var_Brewer_class2'><p>Approximate Variance Estimators by Brewer (2002)</p></a></li>
<li><a href='#var_Brewer_class3'><p>Approximate Variance Estimators by Brewer (2002)</p></a></li>
<li><a href='#var_Deville'><p>Deville's approximate variance estimators</p></a></li>
<li><a href='#var_FixedPoint'><p>Fixed-Point approximate variance estimator</p></a></li>
<li><a href='#var_Hajek'><p>Hájek Approximate Variance Estimator</p></a></li>
<li><a href='#var_HartleyRao'><p>Hartley and Rao approximate variance estimator</p></a></li>
<li><a href='#var_MateiTille'><p>Approximate Variance Estimators by Matei and Tillé (2005)</p></a></li>
<li><a href='#var_Rosen'><p>Rosén Approximate Variance Estimator</p></a></li>
<li><a href='#var_Tille'><p>Tillé's Approximate Variance Estimator</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Approximate the Variance of the Horvitz-Thompson Total Estimator</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-26</td>
</tr>
<tr>
<td>Description:</td>
<td>Variance approximations for the 
    Horvitz-Thompson total estimator in Unequal Probability Sampling
    using only first-order inclusion probabilities. 
    See Matei and Tillé (2005) and Haziza, Mecatti and Rao (2008) for details.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rhobis/UPSvarApprox/issues">https://github.com/rhobis/UPSvarApprox/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-26 08:22:20 UTC; Roberto</td>
</tr>
<tr>
<td>Author:</td>
<td>Roberto Sichera [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Roberto Sichera &lt;rob.sichera@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-27 07:00:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='UPSvarApprox-package'>UPSvarApprox: Approximate the variance of the Horvitz-Thompson estimator</h2><span id='topic+UPSvarApprox'></span><span id='topic+UPSvarApprox-package'></span>

<h3>Description</h3>

<p>Variance approximations for the
Horvitz-Thompson total estimator in Unequal Probability Sampling
using only first-order inclusion probabilities.
See Matei and Tillé (2005) and Haziza, Mecatti and Rao (2008) for details.
</p>


<h3>Variance approximation</h3>

<p>The package provides function <code><a href="#topic+Var_approx">Var_approx</a></code> for the approximation of the
Horvitz-Thompson variance, and function <code><a href="#topic+approx_var_est">approx_var_est</a></code> for the computation
of approximate variance estimators.
For both functions, different estimators are implemented,
see their documentation for details.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Roberto Sichera <a href="mailto:rob.sichera@gmail.com">rob.sichera@gmail.com</a>
</p>


<h3>References</h3>

<p>Matei, A.; Tillé, Y., 2005. Evaluation of variance approximations and estimators
in maximum entropy sampling with unequal probability and fixed sample size.
Journal of Official Statistics 21 (4), 543-570.
</p>
<p>Haziza, D.; Mecatti, F.; Rao, J.N.K. 2008.
Evaluation of some approximate variance estimators under the Rao-Sampford
unequal probability sampling design. Metron LXVI (1), 91-108.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li><p> Report bugs at <a href="https://github.com/rhobis/UPSvarApprox/issues">https://github.com/rhobis/UPSvarApprox/issues</a>
</p>
</li></ul>


<hr>
<h2 id='approx_var_est'>Approximated Variance Estimators</h2><span id='topic+approx_var_est'></span>

<h3>Description</h3>

<p>Approximated variance estimators which use only first-order inclusion probabilities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>approx_var_est(y, pik, method, sample = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="approx_var_est_+3A_y">y</code></td>
<td>
<p>numeric vector of sample observations</p>
</td></tr>
<tr><td><code id="approx_var_est_+3A_pik">pik</code></td>
<td>
<p>numeric vector of first-order inclusion probabilities of length N,
the population size,  or n, the sample size
depending on the chosen method (see Details for more information)</p>
</td></tr>
<tr><td><code id="approx_var_est_+3A_method">method</code></td>
<td>
<p>string indicating the desired approximate variance estimator.
One of &quot;Deville1&quot;, &quot;Deville2&quot;, &quot;Deville3&quot;, &quot;Hajek&quot;, &quot;Rosen&quot;, &quot;FixedPoint&quot;,
&quot;Brewer1&quot;, &quot;HartleyRao&quot;, &quot;Berger&quot;, &quot;Tille&quot;, &quot;MateiTille1&quot;, &quot;MateiTille2&quot;,
&quot;MateiTille3&quot;, &quot;MateiTille4&quot;, &quot;MateiTille5&quot;, &quot;Brewer2&quot;, &quot;Brewer3&quot;, &quot;Brewer4&quot;.</p>
</td></tr>
<tr><td><code id="approx_var_est_+3A_sample">sample</code></td>
<td>
<p>Either a numeric vector of length equal to the sample size with
the indices of sample units, or a boolean vector of the same length of <code>pik</code>, indicating which
units belong to the sample (<code>TRUE</code> if the unit is in the sample,
<code>FALSE</code> otherwise.
Only used with estimators of the third class (see Details for more information).</p>
</td></tr>
<tr><td><code id="approx_var_est_+3A_...">...</code></td>
<td>
<p>two optional parameters can be modified to control the iterative
procedures in methods <code>"MateiTille5"</code>, <code>"Tille"</code> and
<code>"FixedPoint"</code>: <code>maxIter</code> sets the maximum number
of iterations to perform and <code>eps</code> controls the convergence error</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The choice of the estimator to be used is made through the argument <code>method</code>,
the list of methods and their respective equations is presented below.
</p>
<p>Matei and Tillé (2005) divides the approximated variance estimators into
three classes, depending on the quantities they require:
</p>

<ol>
<li><p> First and second-order inclusion probabilities:
The first class is composed of the Horvitz-Thompson estimator (Horvitz and Thompson 1952)
and the Sen-Yates-Grundy estimator (Yates and Grundy 1953; Sen 1953),
which are available through function <code>varHT</code> in package <code>sampling</code>;
</p>
</li>
<li><p> Only first-order inclusion probabilities and only for sample units;
</p>
</li>
<li><p> Only first-order inclusion probabilities, for the entire population.
</p>
</li></ol>

<p>Haziza, Mecatti and Rao (2008) provide a common form to express most of the
estimators in class 2 and 3:
</p>
<p style="text-align: center;"><code class="reqn">\widehat{var}(\hat{t}_{HT}) = \sum_{i \in s}c_i e_i^2 </code>
</p>

<p>where <code class="reqn"> e_i = \frac{y_i}{\pi_i} - \hat{B} </code>, with
</p>
<p style="text-align: center;"><code class="reqn"> \hat{B} = \frac{\sum_{i\in s} a_i (y_i/\pi_i) }{\sum_{i\in s} a_i} </code>
</p>

<p>and <code class="reqn">a_i</code> and <code class="reqn">c_i</code> are parameters that define the different
estimators:
</p>

<ul>
<li> <p><code>method="Hajek"</code> [Class 2]
</p>
<p style="text-align: center;"><code class="reqn">c_i = \frac{n}{n-1}(1-\pi_i) ; \quad a_i= c_i</code>
</p>

</li>
<li> <p><code>method="Deville2"</code> [Class 2]
</p>
<p style="text-align: center;"><code class="reqn">c_i = (1-\pi_i)\Biggl\{ 1 - \sum_{j\in s}\Bigl[ \frac{1-\pi_j}{\sum_{k\in s} (1-\pi_k)} \Bigr]^2 \Biggr\}^{-1} ; \quad a_i= c_i</code>
</p>

</li>
<li> <p><code>method="Deville3"</code> [Class 2]
</p>
<p style="text-align: center;"><code class="reqn">c_i = (1-\pi_i)\Biggl\{ 1 - \sum_{j\in s}\Bigl[ \frac{1-\pi_j}{\sum_{k\in s} (1-\pi_k)} \Bigr]^2 \Biggr\}^{-1}; \quad a_i= 1 </code>
</p>

</li>
<li> <p><code>method="Rosen"</code> [Class 2]
</p>
<p style="text-align: center;"><code class="reqn">c_i = \frac{n}{n-1} (1-\pi_i); \quad a_i= (1-\pi_i)log(1-\pi_i) / \pi_i</code>
</p>

</li>
<li> <p><code>method="Brewer1"</code> [Class 2]
</p>
<p style="text-align: center;"><code class="reqn">c_i = \frac{n}{n-1}(1-\pi_i); \quad a_i= 1</code>
</p>

</li>
<li> <p><code>method="Brewer2"</code> [Class 3]
</p>
<p style="text-align: center;"><code class="reqn">c_i = \frac{n}{n-1} \Bigl(1-\pi_i+ \frac{\pi_i}{n} - n^{-2}\sum_{j \in U} \pi_j^2 \Bigr) ; \quad a_i=1</code>
</p>

</li>
<li> <p><code>method="Brewer3"</code> [Class 3]
</p>
<p style="text-align: center;"><code class="reqn">c_i = \frac{n}{n-1} \Bigl(1-\pi_i - \frac{\pi_i}{n} - n^{-2}\sum_{j \in U} \pi_j^2 \Bigr); \quad a_i = 1</code>
</p>

</li>
<li> <p><code>method="Brewer4"</code> [Class 3]
</p>
<p style="text-align: center;"><code class="reqn">c_i = \frac{n}{n-1} \Bigl(1-\pi_i - \frac{\pi_i}{n-1} + n^{-1}(n-1)^{-1}\sum_{j \in U} \pi_j^2 \Bigr); \quad a_i=1</code>
</p>

</li>
<li> <p><code>method="Berger"</code> [Class 3]
</p>
<p style="text-align: center;"><code class="reqn">c_i = \frac{n}{n-1} (1-\pi_i) \Biggl[ \frac{\sum_{j\in s} (1-\pi_j)}{\sum_{j\in U} (1-\pi_j)} \Biggr] ; \quad a_i=c_i</code>
</p>

</li>
<li> <p><code>method="HartleyRao"</code> [Class 3]
</p>
<p style="text-align: center;"><code class="reqn">c_i = \frac{n}{n-1} \Bigl(1-\pi_i - n^{-1}\sum_{j \in s}\pi_i + n^{-1}\sum_{j\in U} \pi_j^2 \Bigr) ; \quad a_i=1</code>
</p>

</li></ul>

<p>Some additional estimators are defined in Matei and Tillé (2005):
</p>

<ul>
<li> <p><code>method="Deville1"</code> [Class 2]
</p>
<p style="text-align: center;"><code class="reqn">\widehat{var}(\hat{t}_{HT}) = \sum_{i \in s} \frac{c_i}{ \pi_i^2} (y_i - y_i^*)^2 </code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn"> y_i^* = \pi_i \frac{\sum_{j \in s} c_j y_j / \pi_j}{\sum_{j \in s} c_j} </code>
</p>

<p>and <code class="reqn">c_i = (1-\pi_i)\frac{n}{n-1} </code>
</p>
</li>
<li> <p><code>method="Tille"</code> [Class 3]
</p>
<p style="text-align: center;"><code class="reqn">
     \widehat{var}(\hat{t}_{HT}) = \biggl( \sum_{i \in s} \omega_i \biggr)
     \sum_{i\in s} \omega_i (\tilde{y}_i - \bar{\tilde{y}}_\omega )^2
     - n \sum_{i\in s}\biggl( \tilde{y}_i - \frac{\hat{t}_{HT}}{n} \biggr)^2
     </code>
</p>

<p>where  <code class="reqn">\tilde{y}_i = y_i / \pi_i </code>,
<code class="reqn">\omega_i = \pi_i / \beta_i</code>
and <code class="reqn">\bar{\tilde{y}}_\omega =
                  \biggl( \sum_{i \in s} \omega_i \biggr)^{-1} \sum_{i \in s} \omega_i \tilde{y}_i </code>
</p>
<p>The coefficients <code class="reqn">\beta_i</code> are computed iteratively through the
following procedure:
</p>

<ol>
<li> <p><code class="reqn">\beta_i^{(0)} = \pi_i, \,\, \forall i\in U</code>
</p>
</li>
<li> <p><code class="reqn"> \beta_i^{(2k-1)} = \frac{(n-1)\pi_i}{\beta^{(2k-2)} - \beta_i^{(2k-2)}}  </code>
</p>
</li>
<li> <p><code class="reqn">\beta_i^{2k} = \beta_i^{(2k-1)}
        \Biggl( \frac{n(n-1)}{(\beta^(2k-1))^2 - \sum_{i\in U} (\beta_k^{(2k-1)})^2 } \Biggr)^{(1/2)} </code>
</p>
</li></ol>

<p>with <code class="reqn">\beta^{(k)} = \sum_{i\in U} \beta_i^{i}, \,\, k=1,2,3, \dots </code>
</p>
</li>
<li> <p><code>method="MateiTille1"</code> [Class 3]
</p>
<p style="text-align: center;"><code class="reqn">\widehat{var}(\hat{t}_{HT}) = \frac{n(N-1)}{N(n-1)} \sum_{i\in s} \frac{b_i}{\pi_i^3} (y_i - \hat{y}_i^*)^2 </code>
</p>

<p>where </p>
<p style="text-align: center;"><code class="reqn">\hat{y}_i^* = \pi_i \frac{\sum_{i\in s} b_i y_i/\pi_i^2}{\sum_{i\in s} b_i/\pi_i} </code>
</p>

<p>and the coefficients <code class="reqn">b_i</code> are computed iteratively by the algorithm:
</p>

<ol>
<li> <p style="text-align: center;"><code class="reqn">b_i^{(0)} = \pi_i (1-\pi_i) \frac{N}{N-1}, \,\, \forall i \in U </code>
</p>

</li>
<li> <p style="text-align: center;"><code class="reqn"> b_i^{(k)} = \frac{(b_i^{(k-1)})^2 }{\sum_{j\in U} b_j^{(k-1)} } + \pi_i(1-\pi_i) </code>
</p>

</li></ol>

<p>a necessary condition for convergence is checked and, if not satisfied,
the function returns an alternative solution that uses only one iteration:
</p>
<p style="text-align: center;"><code class="reqn">b_i = \pi_i(1-\pi_i)\Biggl( \frac{N\pi_i(1-\pi_i)}{ (N-1)\sum_{j\in U}\pi_j(1-\pi_j) } + 1 \Biggr) </code>
</p>

</li>
<li> <p><code>method="MateiTille2"</code> [Class 3]
</p>
<p style="text-align: center;"><code class="reqn"> \widehat{var}(\hat{t}_{HT}) = \frac{1}{1 - \sum_{i\in U} \frac{d_i^2}{\pi_i} }
     \sum_{i\in s} (1-\pi_i) \Biggl( \frac{y_i}{\pi_i} - \frac{\hat{t}_{HT}}{n} \Biggr)^2 </code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn"> d_i = \frac{\pi_i(1-\pi_i)}{\sum_{j\in U} \pi_j(1-\pi_j) } </code>
</p>

</li>
<li> <p><code>method="MateiTille3"</code> [Class 3]
</p>
<p style="text-align: center;"><code class="reqn"> \widehat{var}(\hat{t}_{HT}) = \frac{1}{1 - \sum_{i\in U} \frac{d_i^2}{\pi_i} }
     \sum_{i\in s} (1-\pi_i) \Biggl( \frac{y_i}{\pi_i} -
     \frac{ \sum_{j\in s} (1-\pi_j)\frac{y_j}{\pi_j} }{ \sum_{j\in s} (1-\pi_j)  } \Biggr)^2 </code>
</p>

<p>where <code class="reqn">d_i</code> is defined as in <code>method="MateiTille2"</code>.
</p>
</li>
<li> <p><code>method="MateiTille4"</code> [Class 3]
</p>
<p style="text-align: center;"><code class="reqn"> \widehat{var}(\hat{t}_{HT}) = \frac{1}{1 - \sum_{i\in U} b_i/n^2 }
     \sum_{i\in s} \frac{b_i}{\pi_i^3} (y_i - y_i^* )^2  </code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">  y_i^* = \pi_i \frac{ \sum_{j\in s} b_j y_j/\pi_j^2 }{  \sum_{j\in s} b_j/\pi_j } </code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn"> b_i = \frac{ \pi_i(1-\pi_i)N }{ N-1 } </code>
</p>

</li>
<li> <p><code>method="MateiTille5"</code> [Class 3]
This estimator is defined as in <code>method="MateiTille4"</code>, and the <code class="reqn">b_i</code>
values are defined as in <code>method="MateiTille1"</code>
</p>
</li></ul>



<h3>Value</h3>

<p>a scalar, the estimated variance
</p>


<h3>References</h3>

<p>Matei, A.; Tillé, Y., 2005. Evaluation of variance approximations and estimators
in maximum entropy sampling with unequal probability and fixed sample size.
Journal of Official Statistics 21 (4), 543-570.
</p>
<p>Haziza, D.; Mecatti, F.; Rao, J.N.K. 2008.
Evaluation of some approximate variance estimators under the Rao-Sampford
unequal probability sampling design. Metron LXVI (1), 91-108.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
### Generate population data ---
N &lt;- 500; n &lt;- 50

set.seed(0)
x &lt;- rgamma(500, scale=10, shape=5)
y &lt;- abs( 2*x + 3.7*sqrt(x) * rnorm(N) )

pik &lt;- n * x/sum(x)
s   &lt;- sample(N, n)

ys &lt;- y[s]
piks &lt;- pik[s]

### Estimators of class 2 ---
approx_var_est(ys, piks, method="Deville1")
approx_var_est(ys, piks, method="Deville2")
approx_var_est(ys, piks, method="Deville3")
approx_var_est(ys, piks, method="Hajek")
approx_var_est(ys, piks, method="Rosen")
approx_var_est(ys, piks, method="FixedPoint")
approx_var_est(ys, piks, method="Brewer1")

### Estimators of class 3 ---
approx_var_est(ys, pik, method="HartleyRao", sample=s)
approx_var_est(ys, pik, method="Berger", sample=s)
approx_var_est(ys, pik, method="Tille", sample=s)
approx_var_est(ys, pik, method="MateiTille1", sample=s)
approx_var_est(ys, pik, method="MateiTille2", sample=s)
approx_var_est(ys, pik, method="MateiTille3", sample=s)
approx_var_est(ys, pik, method="MateiTille4", sample=s)
approx_var_est(ys, pik, method="MateiTille5", sample=s)
approx_var_est(ys, pik, method="Brewer2", sample=s)
approx_var_est(ys, pik, method="Brewer3", sample=s)
approx_var_est(ys, pik, method="Brewer4", sample=s)


</code></pre>

<hr>
<h2 id='is.wholenumber'>Check if a number is integer</h2><span id='topic+is.wholenumber'></span>

<h3>Description</h3>

<p>Check if <code>x</code> is an integer number, differently from <code>is.integer</code>,
which checks the type of the object <code>x</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.wholenumber(x, tol = .Machine$double.eps^0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.wholenumber_+3A_x">x</code></td>
<td>
<p>a scalar or a numeric vector</p>
</td></tr>
<tr><td><code id="is.wholenumber_+3A_tol">tol</code></td>
<td>
<p>a scalar, indicating the tolerance</p>
</td></tr>
</table>


<h3>Note</h3>

<p>From the help page of function <code><a href="base.html#topic+is.integer">is.integer</a></code>
</p>

<hr>
<h2 id='Var_approx'>Approximate the Variance of the Horvitz-Thompson estimator</h2><span id='topic+Var_approx'></span>

<h3>Description</h3>

<p>Approximations of the Horvitz-Thompson variance for High-Entropy sampling designs.
Such methods use only first-order inclusion probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Var_approx(y, pik, n, method, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Var_approx_+3A_y">y</code></td>
<td>
<p>numeric vector containing the values of the variable of interest for
all population units</p>
</td></tr>
<tr><td><code id="Var_approx_+3A_pik">pik</code></td>
<td>
<p>numeric vector of first-order inclusion probabilities, of length
equal to population size</p>
</td></tr>
<tr><td><code id="Var_approx_+3A_n">n</code></td>
<td>
<p>a scalar indicating the sample size</p>
</td></tr>
<tr><td><code id="Var_approx_+3A_method">method</code></td>
<td>
<p>string indicating the approximation that should be used.
One of &quot;Hajek1&quot;, &quot;Hajek2&quot;, &quot;HartleyRao1&quot;, &quot;HartleyRao2&quot;, &quot;FixedPoint&quot;.</p>
</td></tr>
<tr><td><code id="Var_approx_+3A_...">...</code></td>
<td>
<p>two optional parameters can be modified to control the iterative
procedure in <code>method="FixedPoint"</code>: <code>maxIter</code> sets the maximum number
of iterations and <code>eps</code> controls the convergence error</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The variance approximations available in this function are described below,
the notation used is that of Matei and Tillé (2005).
</p>

<ul>
<li><p> Hájek variance approximation (<code>method="Hajek1"</code>):
</p>
<p style="text-align: center;"><code class="reqn"> \tilde{Var} = \sum_{i \in U} \frac{b_i}{\pi_i^2}(y_i - y_i^*)^2  </code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">y_i^* = \pi_i \frac{ \sum_{j\in U} b_j y_j/\pi_j }{ \sum_{j \in U} b_j } </code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn"> b_i = \frac{ \pi_i(1-\pi_i)N }{ N-1 } </code>
</p>

</li>
<li><p> Starting from Hajék (1964), Brewer (2002) defined the following estimator
(<code>method="Hajek2"</code>):
</p>
<p style="text-align: center;"><code class="reqn">\tilde{Var} = \sum_{i \in U} \pi_i(1-\pi_i) \Bigl( \frac{y_i}{\pi_i} -
    \frac{\tilde{Y}}{n} \Bigr)^2 </code>
</p>

<p>where <code class="reqn">\tilde{Y} = \sum_{i \in U} a_i y_i</code>
and <code class="reqn">a_i = n(1-\pi_i)/\sum_{j \in U} \pi_j(1-\pi_j) </code>
</p>
</li>
<li><p> Hartley and Rao (1962) variance approximation (<code>method="HartleyRao1"</code>):
</p>
<p style="text-align: center;"><code class="reqn"> \tilde{Var} =
    \sum_{i \in U} \pi_i \Bigl( 1 - \frac{n-1}{n}\pi_i \Bigr)
    \Biggr( \frac{y_i}{\pi_i} - \frac{Y}{n}  \Biggr)^2</code>
</p>

<p style="text-align: center;"><code class="reqn">\qquad - \frac{n-1}{n^2} \sum_{i \in U} \Biggl( 2\pi_i^3 -
    \frac{\pi_i^2}{2} \sum_{j \in U} \pi_j^2 \Biggr)
    \Biggr( \frac{y_i}{\pi_i} - \frac{Y}{n}  \Biggr)^2</code>
</p>

<p style="text-align: center;"><code class="reqn">\quad \qquad + \frac{2(n-1)}{n^3} \Biggl( \sum_{i \in U}\pi_i y_i
    - \frac{Y}{n}\sum_{i\in U} \pi_i^2 \Biggr)^2 </code>
</p>

</li>
<li><p> Hartley and Rao (1962) provide a simplified version of the
variance above (<code>method="HartleyRao2"</code>):
</p>
<p style="text-align: center;"><code class="reqn"> \tilde{Var} = \sum_{i \in U} \pi_i \Bigl( 1 - \frac{n-1}{n}\pi_i \Bigr) \Biggr( \frac{y_i}{\pi_i} - \frac{Y}{n}  \Biggr)^2 </code>
</p>

</li>
<li> <p><code>method="FixedPoint"</code> computes the Fixed-Point variance approximation
proposed by Deville and Tillé (2005).
The variance can be expressed in the same form as in <code>method="Hajek1"</code>,
and the coefficients <code class="reqn">b_i</code> are computed iteratively by the algorithm:
</p>

<ol>
<li> <p style="text-align: center;"><code class="reqn">b_i^{(0)} = \pi_i (1-\pi_i) \frac{N}{N-1}, \,\, \forall i \in U </code>
</p>

</li>
<li> <p style="text-align: center;"><code class="reqn"> b_i^{(k)} = \frac{(b_i^{(k-1)})^2 }{\sum_{j\in U} b_j^{(k-1)} } + \pi_i(1-\pi_i) </code>
</p>

</li></ol>

<p>a necessary condition for convergence is checked and, if not satisfied,
the function returns an alternative solution that uses only one iteration:
</p>
<p style="text-align: center;"><code class="reqn">b_i = \pi_i(1-\pi_i)\Biggl( \frac{N\pi_i(1-\pi_i)}{ (N-1)\sum_{j\in U}\pi_j(1-\pi_j) } + 1 \Biggr) </code>
</p>

</li></ul>



<h3>Value</h3>

<p>a scalar, the approximated variance.
</p>


<h3>References</h3>

<p>Matei, A.; Tillé, Y., 2005. Evaluation of variance approximations and estimators
in maximum entropy sampling with unequal probability and fixed sample size.
Journal of Official Statistics 21 (4), 543-570.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N &lt;- 500; n &lt;- 50

set.seed(0)
x &lt;- rgamma(n=N, scale=10, shape=5)
y &lt;- abs( 2*x + 3.7*sqrt(x) * rnorm(N) )

pik  &lt;- n * x/sum(x)
pikl &lt;- outer(pik, pik, '*'); diag(pikl) &lt;- pik

### Variance approximations ---
Var_approx(y, pik, n, method = "Hajek1")
Var_approx(y, pik, n, method = "Hajek2")
Var_approx(y, pik, n, method = "HartleyRao1")
Var_approx(y, pik, n, method = "HartleyRao2")
Var_approx(y, pik, n, method = "FixedPoint")


</code></pre>

<hr>
<h2 id='var_Berger'>Berger approximate variance estimator</h2><span id='topic+var_Berger'></span>

<h3>Description</h3>

<p>Compute the Berger approximate variance estimator (Berger, 1998)
Estimator of class 3, it requires only first-order inclusion probabilities but
for all population units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_Berger(y, pik, sample)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="var_Berger_+3A_y">y</code></td>
<td>
<p>numeric vector of sample observations</p>
</td></tr>
<tr><td><code id="var_Berger_+3A_pik">pik</code></td>
<td>
<p>numeric vector of first-order inclusion probabilities for all population units</p>
</td></tr>
<tr><td><code id="var_Berger_+3A_sample">sample</code></td>
<td>
<p>Either a numeric vector of length equal to the sample size with
the indices of sample units, or a boolean vector of the same length of <code>pik</code>, indicating which
units belong to the sample (<code>TRUE</code> if the unit is in the sample,
<code>FALSE</code> otherwise.
Only used with estimators of the third class (see Details for more information).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar, the estimated variance
</p>

<hr>
<h2 id='var_Brewer_class2'>Approximate Variance Estimators by Brewer (2002)</h2><span id='topic+var_Brewer_class2'></span>

<h3>Description</h3>

<p>Computes an approximate variance estimate according to one  of
the estimators proposed by Brewer (2002).
This estimator belongs to class 2, it requires only first-order inclusion
probabilities and only for sample units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_Brewer_class2(y, pik)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="var_Brewer_class2_+3A_y">y</code></td>
<td>
<p>numeric vector of sample observations</p>
</td></tr>
<tr><td><code id="var_Brewer_class2_+3A_pik">pik</code></td>
<td>
<p>numeric vector of first-order inclusion probabilities for sample units</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar, the estimated variance
</p>

<hr>
<h2 id='var_Brewer_class3'>Approximate Variance Estimators by Brewer (2002)</h2><span id='topic+var_Brewer_class3'></span>

<h3>Description</h3>

<p>Compute an approximate variance estimate using the class of estimators
proposed by Brewer (2002).
Estimators of class 3, they require only first-order inclusion probabilities but
for all population units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_Brewer_class3(y, pik, method, sample)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="var_Brewer_class3_+3A_y">y</code></td>
<td>
<p>numeric vector of sample observations</p>
</td></tr>
<tr><td><code id="var_Brewer_class3_+3A_pik">pik</code></td>
<td>
<p>numeric vector of first-order inclusion probabilities for all population units</p>
</td></tr>
<tr><td><code id="var_Brewer_class3_+3A_method">method</code></td>
<td>
<p>string indicating the desired approximate variance estimator.
One of &quot;Deville1&quot;, &quot;Deville2&quot;, &quot;Deville3&quot;, &quot;Hajek&quot;, &quot;Rosen&quot;, &quot;FixedPoint&quot;,
&quot;Brewer1&quot;, &quot;HartleyRao&quot;, &quot;Berger&quot;, &quot;Tille&quot;, &quot;MateiTille1&quot;, &quot;MateiTille2&quot;,
&quot;MateiTille3&quot;, &quot;MateiTille4&quot;, &quot;MateiTille5&quot;, &quot;Brewer2&quot;, &quot;Brewer3&quot;, &quot;Brewer4&quot;.</p>
</td></tr>
<tr><td><code id="var_Brewer_class3_+3A_sample">sample</code></td>
<td>
<p>Either a numeric vector of length equal to the sample size with
the indices of sample units, or a boolean vector of the same length of <code>pik</code>, indicating which
units belong to the sample (<code>TRUE</code> if the unit is in the sample,
<code>FALSE</code> otherwise.
Only used with estimators of the third class (see Details for more information).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar, the estimated variance
</p>

<hr>
<h2 id='var_Deville'>Deville's approximate variance estimators</h2><span id='topic+var_Deville'></span>

<h3>Description</h3>

<p>Compute Deville's approximate variance estimators of class 2, which require only
first-order inclusion probabilities and only for sample units
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_Deville(y, pik, method)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="var_Deville_+3A_y">y</code></td>
<td>
<p>numeric vector of sample observations</p>
</td></tr>
<tr><td><code id="var_Deville_+3A_pik">pik</code></td>
<td>
<p>numeric vector of first-order inclusion probabilities for sample units</p>
</td></tr>
<tr><td><code id="var_Deville_+3A_method">method</code></td>
<td>
<p>string indicating the desired approximate variance estimator.
One of &quot;Deville1&quot;, &quot;Deville2&quot;, &quot;Deville3&quot;, &quot;Hajek&quot;, &quot;Rosen&quot;, &quot;FixedPoint&quot;,
&quot;Brewer1&quot;, &quot;HartleyRao&quot;, &quot;Berger&quot;, &quot;Tille&quot;, &quot;MateiTille1&quot;, &quot;MateiTille2&quot;,
&quot;MateiTille3&quot;, &quot;MateiTille4&quot;, &quot;MateiTille5&quot;, &quot;Brewer2&quot;, &quot;Brewer3&quot;, &quot;Brewer4&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar, the estimated variance
</p>

<hr>
<h2 id='var_FixedPoint'>Fixed-Point approximate variance estimator</h2><span id='topic+var_FixedPoint'></span>

<h3>Description</h3>

<p>Fixed-Point estimator for approximate variance estimation by Deville and Tillé (2005).
Estimator of class 2, it requires only first-order inclusion probabilities and
only for sample units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_FixedPoint(y, pik, maxIter = 1000, eps = 1e-05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="var_FixedPoint_+3A_y">y</code></td>
<td>
<p>numeric vector of sample observations</p>
</td></tr>
<tr><td><code id="var_FixedPoint_+3A_pik">pik</code></td>
<td>
<p>numeric vector of first-order inclusion probabilities for sample units</p>
</td></tr>
<tr><td><code id="var_FixedPoint_+3A_maxiter">maxIter</code></td>
<td>
<p>a scalar indicating the maximum number of iterations for the
fixed-point procedure</p>
</td></tr>
<tr><td><code id="var_FixedPoint_+3A_eps">eps</code></td>
<td>
<p>tolerance value for the convergence of the fixed-point procedure</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar, the estimated variance
</p>

<hr>
<h2 id='var_Hajek'>Hájek Approximate Variance Estimator</h2><span id='topic+var_Hajek'></span>

<h3>Description</h3>

<p>Compute an approximate variance estimate using the approximation of
joint-inclusion probabilities proposed by Hájek (1964).
Estimator of class 2, it requires only first-order inclusion probabilities and
only for sample units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_Hajek(y, pik)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="var_Hajek_+3A_y">y</code></td>
<td>
<p>numeric vector of sample observations</p>
</td></tr>
<tr><td><code id="var_Hajek_+3A_pik">pik</code></td>
<td>
<p>numeric vector of first-order inclusion probabilities for sample units</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar, the estimated variance
</p>

<hr>
<h2 id='var_HartleyRao'>Hartley and Rao approximate variance estimator</h2><span id='topic+var_HartleyRao'></span>

<h3>Description</h3>

<p>Compute the an approximate variance estimator obtained by the approximation
of joint-inclusion probabilities proposed by Hartley and Rao (1962).
Estimator of class 3, it requires only first-order inclusion probabilities but
for all population units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_HartleyRao(y, pik, sample)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="var_HartleyRao_+3A_y">y</code></td>
<td>
<p>numeric vector of sample observations</p>
</td></tr>
<tr><td><code id="var_HartleyRao_+3A_pik">pik</code></td>
<td>
<p>numeric vector of first-order inclusion probabilities for all population units</p>
</td></tr>
<tr><td><code id="var_HartleyRao_+3A_sample">sample</code></td>
<td>
<p>Either a numeric vector of length equal to the sample size with
the indices of sample units, or a boolean vector of the same length of <code>pik</code>, indicating which
units belong to the sample (<code>TRUE</code> if the unit is in the sample,
<code>FALSE</code> otherwise.
Only used with estimators of the third class (see Details for more information).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar, the estimated variance
</p>

<hr>
<h2 id='var_MateiTille'>Approximate Variance Estimators by Matei and Tillé (2005)</h2><span id='topic+var_MateiTille'></span>

<h3>Description</h3>

<p>Computes an approximate variance estimate according to
one of the estimators proposed by Matei and Tillé (2005)
Estimators of class 3, they require only first-order inclusion probabilities but
for all population units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_MateiTille(y, pik, method, sample, maxIter = 1000, eps = 1e-05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="var_MateiTille_+3A_y">y</code></td>
<td>
<p>numeric vector of sample observations</p>
</td></tr>
<tr><td><code id="var_MateiTille_+3A_pik">pik</code></td>
<td>
<p>numeric vector of first-order inclusion probabilities for all population units</p>
</td></tr>
<tr><td><code id="var_MateiTille_+3A_method">method</code></td>
<td>
<p>string indicating the desired approximate variance estimator.
One of &quot;Deville1&quot;, &quot;Deville2&quot;, &quot;Deville3&quot;, &quot;Hajek&quot;, &quot;Rosen&quot;, &quot;FixedPoint&quot;,
&quot;Brewer1&quot;, &quot;HartleyRao&quot;, &quot;Berger&quot;, &quot;Tille&quot;, &quot;MateiTille1&quot;, &quot;MateiTille2&quot;,
&quot;MateiTille3&quot;, &quot;MateiTille4&quot;, &quot;MateiTille5&quot;, &quot;Brewer2&quot;, &quot;Brewer3&quot;, &quot;Brewer4&quot;.</p>
</td></tr>
<tr><td><code id="var_MateiTille_+3A_sample">sample</code></td>
<td>
<p>Either a numeric vector of length equal to the sample size with
the indices of sample units, or a boolean vector of the same length of <code>pik</code>, indicating which
units belong to the sample (<code>TRUE</code> if the unit is in the sample,
<code>FALSE</code> otherwise.
Only used with estimators of the third class (see Details for more information).</p>
</td></tr>
<tr><td><code id="var_MateiTille_+3A_maxiter">maxIter</code></td>
<td>
<p>a scalar indicating the maximum number of iterations for the
fixed-point procedure</p>
</td></tr>
<tr><td><code id="var_MateiTille_+3A_eps">eps</code></td>
<td>
<p>tolerance value for the convergence of the fixed-point procedure</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar, the estimated variance
</p>

<hr>
<h2 id='var_Rosen'>Rosén Approximate Variance Estimator</h2><span id='topic+var_Rosen'></span>

<h3>Description</h3>

<p>Compute an approximate variance estimate using the estimator
proposed by Rosén (1991).
Estimator of class 2, it requires only first-order inclusion probabilities and
only for sample units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_Rosen(y, pik)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="var_Rosen_+3A_y">y</code></td>
<td>
<p>numeric vector of sample observations</p>
</td></tr>
<tr><td><code id="var_Rosen_+3A_pik">pik</code></td>
<td>
<p>numeric vector of first-order inclusion probabilities for sample units</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar, the estimated variance
</p>

<hr>
<h2 id='var_Tille'>Tillé's Approximate Variance Estimator</h2><span id='topic+var_Tille'></span>

<h3>Description</h3>

<p>Compute an approximate variance estimate using the estimator
proposed by Tillé (1996).
Estimator of class 3, it requires only first-order inclusion probabilities but
for all population units.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var_Tille(y, pik, sample, maxIter = 1000, eps = 1e-05)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="var_Tille_+3A_y">y</code></td>
<td>
<p>numeric vector of sample observations</p>
</td></tr>
<tr><td><code id="var_Tille_+3A_pik">pik</code></td>
<td>
<p>numeric vector of first-order inclusion probabilities for all population units</p>
</td></tr>
<tr><td><code id="var_Tille_+3A_sample">sample</code></td>
<td>
<p>Either a numeric vector of length equal to the sample size with
the indices of sample units, or a boolean vector of the same length of <code>pik</code>, indicating which
units belong to the sample (<code>TRUE</code> if the unit is in the sample,
<code>FALSE</code> otherwise.
Only used with estimators of the third class (see Details for more information).</p>
</td></tr>
<tr><td><code id="var_Tille_+3A_maxiter">maxIter</code></td>
<td>
<p>a scalar indicating the maximum number of iterations for the
fixed-point procedure</p>
</td></tr>
<tr><td><code id="var_Tille_+3A_eps">eps</code></td>
<td>
<p>tolerance value for the convergence of the fixed-point procedure</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scalar, the estimated variance
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
