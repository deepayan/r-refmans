<!DOCTYPE html><html><head><title>Help for package DRIP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DRIP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#brain'><p>Brain image</p></a></li>
<li><a href='#circles'><p>Image of circles</p></a></li>
<li><a href='#cv.jpex'><p>Bandwidth Selection and Noise Level Estimation</p></a></li>
<li><a href='#diffLC2K'><p>local constant kernel difference</p></a></li>
<li><a href='#diffLCK'><p>local constant kernel difference</p></a></li>
<li><a href='#diffLL2K'><p>local linear kernel difference</p></a></li>
<li><a href='#diffLLK'><p>local linear kernel difference</p></a></li>
<li><a href='#dKQ'><p>edge detection, performance measure</p></a></li>
<li><a href='#jpex'><p>Blind Image Deblurring</p></a></li>
<li><a href='#JPLLK_surface'><p>Denoising and jump-preserving</p></a></li>
<li><a href='#kid'><p>Image of a kid taking test</p></a></li>
<li><a href='#lena'><p>Image of Lena</p></a></li>
<li><a href='#modify1'><p>Edge detection, post processing</p></a></li>
<li><a href='#modify2'><p>Edge detection, post processing</p></a></li>
<li><a href='#peppers'><p>Image of peppers</p></a></li>
<li><a href='#roofDiff'>
<p>roof/valley edge detection</p></a></li>
<li><a href='#roofEdge'><p>Edge detection, denoising and deblurring</p></a></li>
<li><a href='#roofEdgeParSel'><p>roof/valley edge detection, parameter selection</p></a></li>
<li><a href='#sar'><p>Synthetic aperture radar image of an area near Thetford forest,</p>
England</a></li>
<li><a href='#stepEdgeLC2K'><p>Edge detection, denoising and deblurring</p></a></li>
<li><a href='#stepEdgeLCK'><p>Edge detection, denoising and deblurring</p></a></li>
<li><a href='#stepEdgeLL2K'><p>Edge detection, denoising and deblurring</p></a></li>
<li><a href='#stepEdgeLLK'><p>Edge detection, denoising and deblurring</p></a></li>
<li><a href='#stepEdgeParSelLC2K'><p>edge detection, parameter selection</p></a></li>
<li><a href='#stepEdgeParSelLCK'><p>edge detection, parameter selection</p></a></li>
<li><a href='#stepEdgeParSelLL2K'><p>edge detection, parameter selection</p></a></li>
<li><a href='#stepEdgeParSelLLK'><p>edge detection, parameter selection</p></a></li>
<li><a href='#stopsign'><p>Image of Stop Sign</p></a></li>
<li><a href='#surfaceCluster'><p>Denoising, deblurring and edge-preserving</p></a></li>
<li><a href='#surfaceCluster_bandwidth'><p>Denoising, deblurring, bandwidth selection, and edge-preserving</p></a></li>
<li><a href='#threeStage'><p>Denoising, deblurring and edge-preserving</p></a></li>
<li><a href='#threeStageParSel'><p>image denoising/deblurring, bandwidth selection, bootstrap</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Version:</td>
<td>1.9</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-05</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of functions that perform jump regression
	     and image analysis such as denoising, deblurring and
	     jump detection.</td>
</tr>
<tr>
<td>Title:</td>
<td>Discontinuous Regression and Image Processing</td>
</tr>
<tr>
<td>Author:</td>
<td>Yicheng Kang [aut, cre],
  Peihua Qiu [aut, ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yicheng Kang &lt;kangyicheng0527@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), parallel, graphics, stats</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-05 15:34:57 UTC; yicheng</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-05 21:40:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='brain'>Brain image</h2><span id='topic+brain'></span>

<h3>Description</h3>

<p>This file contains data of a brain image. It has
217x217 pixels. Gray levels are in the range [0, 255].
In the data file, observations are listed as a 217
x217 matrix. This image has blur involved.</p>


<h3>Usage</h3>

<pre><code class='language-R'>brain</code></pre>


<h3>Format</h3>

<p>This dataset is saved in an ascii file.</p>

<hr>
<h2 id='circles'>Image of circles</h2><span id='topic+circles'></span>

<h3>Description</h3>

<p>This file contains data of the original circles image.
It has 256x256 pixels. Gray levels are in the range
[0, 255]. In the data file, observations are listed as
a 256x256 matrix.</p>


<h3>Usage</h3>

<pre><code class='language-R'>circles</code></pre>


<h3>Format</h3>

<p>This dataset is saved in an ascii file.</p>

<hr>
<h2 id='cv.jpex'>Bandwidth Selection and Noise Level Estimation</h2><span id='topic+cv.jpex'></span>

<h3>Description</h3>

<p>cv.jpex() selects the leave-one-out cross validation (CV) bandwidth for LLK smoothing and estimates the noise level in the input image. Both the bandwidth parameter and the noise level are required inputs for the blind image deblurring procedure jpex().  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.jpex(image, bandwidths, ncpus = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.jpex_+3A_image">image</code></td>
<td>
<p>A blurry image to deblurred</p>
</td></tr>
<tr><td><code id="cv.jpex_+3A_bandwidths">bandwidths</code></td>
<td>
<p>A vector of positive integers that specifies the size
of the neighborhood for local smoothing.</p>
</td></tr>
<tr><td><code id="cv.jpex_+3A_ncpus">ncpus</code></td>
<td>
<p>The number of CPUs allocated for parallel computing.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>LLK</code></td>
<td>
<p>The estimated surface by local linear kernel (LLK) smoothing, using the CV selected bandwidth.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>The estimated noise level, defined as the square root of the mean squared error (MSE) between LLK and the input image.</p>
</td></tr>
<tr><td><code>cv</code></td>
<td>
<p>A vector of the same length as that of bandwidth. Each element in the vector is the leave-one-out CV error associated with the corresponding bandwidth parameter.</p>
</td></tr>
<tr><td><code>bandwidth</code></td>
<td>
<p>The bandwidth parameters input by user.</p>
</td></tr>
<tr><td><code>band.min</code></td>
<td>
<p>The bandwidth parameter that results in the smallest CV error.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yicheng Kang</p>


<h3>References</h3>

<p>Kang, Y. (2020) &ldquo;Consistent Blind Image Deblurring Using
Jump-Preserving Extrapolation&rdquo;, <em>Journal of Computational and
Graphical Statistics</em>, <b>29</b>(2), 372 &ndash; 382.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jpex">jpex</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(DRIP)
data(stopsign)
out &lt;- cv.jpex(stopsign, c(2,3))
</code></pre>

<hr>
<h2 id='diffLC2K'>local constant kernel difference</h2><span id='topic+diffLC2K'></span>

<h3>Description</h3>

<p>Compute difference between two one-sided LC2K
estimators along the gradient direction.</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffLC2K(image, bandwidth, plot)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diffLC2K_+3A_image">image</code></td>
<td>
<p>A square matrix object of size n by n, no
missing value allowed.</p>
</td></tr>
<tr><td><code id="diffLC2K_+3A_bandwidth">bandwidth</code></td>
<td>
<p>A positive integer to specify the number of
pixels used in the local smoothing.</p>
</td></tr>
<tr><td><code id="diffLC2K_+3A_plot">plot</code></td>
<td>
<p>If plot = TRUE, an image of the difference at
each pixel is plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At each pixel, the gradient is estimated by a local linear
kernel smoothing procedure. Next, the local neighborhood is
divided into two halves along the direction perpendicular to
(<code class="reqn">\widehat{f}'_{x}</code>, <code class="reqn">\widehat{f}'_{y}</code>). Then the one-
sided deblurring local constant kernel (LC2K) estimates are obtained in the
two half neighborhoods respectively.
</p>


<h3>Value</h3>

<p>Returns a matrix of the estimated difference, <code class="reqn">|\widehat{f}_+ - \widehat{f}_-|</code>,
at each pixel.</p>


<h3>References</h3>

<p>Kang, Y., and Qiu, P., &quot;Jump Detection in Blurred Regression 
Surfaces,&quot; <em>Technometrics</em>, <b>56</b>, 2014, 539-550.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diffLCK">diffLCK</a></code>, <code><a href="#topic+diffLLK">diffLLK</a></code>, <code><a href="#topic+diffLL2K">diffLL2K</a></code>,
<code><a href="#topic+stepEdgeLC2K">stepEdgeLC2K</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sar) # SAR image is bundled with the package and it is a 
          # standard test image in statistics literature.
diff &lt;- diffLC2K(image = sar, bandwidth = 4)
</code></pre>

<hr>
<h2 id='diffLCK'>local constant kernel difference</h2><span id='topic+diffLCK'></span>

<h3>Description</h3>

<p>Compute difference between two one-sided LCK
estimators along the gradient direction.</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffLCK(image, bandwidth, plot)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diffLCK_+3A_image">image</code></td>
<td>
<p>A square matrix object of size n by n, no
missing value allowed.</p>
</td></tr>
<tr><td><code id="diffLCK_+3A_bandwidth">bandwidth</code></td>
<td>
<p>A positive integer to specify the number of
pixels used in the local smoothing.</p>
</td></tr>
<tr><td><code id="diffLCK_+3A_plot">plot</code></td>
<td>
<p>If plot = TRUE, an image of the difference at
each pixel is plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At each pixel, the gradient is estimated by a local linear
kernel smoothing procedure. Next, the local neighborhood is
divided into two halves along the direction perpendicular to
(<code class="reqn">\widehat{f}'_{x}</code>, <code class="reqn">\widehat{f}'_{y}</code>). Then the one-
sided local constant kernel (LCK) estimates are obtained in the
two half neighborhoods respectively.
</p>


<h3>Value</h3>

<p>Returns a matrix of the estimated difference, <code class="reqn">|\widehat{f}_+ - \widehat{f}_-|</code>,
at each pixel.</p>


<h3>References</h3>

<p>Kang, Y., and Qiu, P., &quot;Jump Detection in Blurred Regression 
Surfaces,&quot; <em>Technometrics</em>, <b>56</b>, 2014, 539-550.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diffLLK">diffLLK</a></code>, <code><a href="#topic+diffLC2K">diffLC2K</a></code>, <code><a href="#topic+diffLL2K">diffLL2K</a></code>,
<code><a href="#topic+stepEdgeLCK">stepEdgeLCK</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sar) # SAR image is bundled with the package and it is a 
          # standard test image in statistics literature.
diff &lt;- diffLCK(image = sar, bandwidth = 4)
</code></pre>

<hr>
<h2 id='diffLL2K'>local linear kernel difference</h2><span id='topic+diffLL2K'></span>

<h3>Description</h3>

<p>Compute difference between two one-sided LL2K
estimators along the gradient direction.</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffLL2K(image, bandwidth, plot)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diffLL2K_+3A_image">image</code></td>
<td>
<p>A square matrix object of size n by n, no
missing value allowed.</p>
</td></tr>
<tr><td><code id="diffLL2K_+3A_bandwidth">bandwidth</code></td>
<td>
<p>A positive integer to specify the number of
pixels used in the local smoothing.</p>
</td></tr>
<tr><td><code id="diffLL2K_+3A_plot">plot</code></td>
<td>
<p>If plot = TRUE, an image of the difference at
each pixel is plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At each pixel, the gradient is estimated by a local linear
kernel smoothing procedure. Next, the local neighborhood is
divided into two halves along the direction perpendicular to
(<code class="reqn">\widehat{f}'_{x}</code>, <code class="reqn">\widehat{f}'_{y}</code>). Then the one-
sided deblurring local linear kernel (LL2K) estimates are obtained in the
two half neighborhoods respectively.
</p>


<h3>Value</h3>

<p>Returns a matrix of the estimated difference, <code class="reqn">|\widehat{f}_+ - \widehat{f}_-|</code>,
at each pixel.</p>


<h3>References</h3>

<p>Kang, Y., and Qiu, P., &quot;Jump Detection in Blurred Regression 
Surfaces,&quot; <em>Technometrics</em>, <b>56</b>, 2014, 539-550.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diffLCK">diffLCK</a></code>, <code><a href="#topic+diffLC2K">diffLC2K</a></code>, <code><a href="#topic+diffLLK">diffLLK</a></code>,
<code><a href="#topic+stepEdgeLL2K">stepEdgeLL2K</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sar) # SAR image is bundled with the package and it is a 
          # standard test image in statistics literature.
diff &lt;- diffLL2K(image = sar, bandwidth = 6)
</code></pre>

<hr>
<h2 id='diffLLK'>local linear kernel difference</h2><span id='topic+diffLLK'></span>

<h3>Description</h3>

<p>Compute difference between two one-sided LLK
estimators along the gradient direction.</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffLLK(image, bandwidth, plot)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diffLLK_+3A_image">image</code></td>
<td>
<p>A square matrix object of size n by n, no
missing value allowed.</p>
</td></tr>
<tr><td><code id="diffLLK_+3A_bandwidth">bandwidth</code></td>
<td>
<p>A positive integer to specify the number of
pixels used in the local smoothing.</p>
</td></tr>
<tr><td><code id="diffLLK_+3A_plot">plot</code></td>
<td>
<p>If plot = TRUE, an image of the difference at
each pixel is plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At each pixel, the gradient is estimated by a local linear
kernel smoothing procedure. Next, the local neighborhood is
divided into two halves along the direction perpendicular to
(<code class="reqn">\widehat{f}'_{x}</code>, <code class="reqn">\widehat{f}'_{y}</code>). Then the one-
sided local linear kernel (LLK) estimates are obtained in the
two half neighborhoods respectively.
</p>


<h3>Value</h3>

<p>Returns a matrix of the estimated difference, <code class="reqn">|\widehat{f}_+ - \widehat{f}_-|</code>,
at each pixel.</p>


<h3>References</h3>

<p>Kang, Y., and Qiu, P., &quot;Jump Detection in Blurred Regression 
Surfaces,&quot; <em>Technometrics</em>, <b>56</b>, 2014, 539-550.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diffLCK">diffLCK</a></code>, <code><a href="#topic+diffLC2K">diffLC2K</a></code>, <code><a href="#topic+diffLL2K">diffLL2K</a></code>,
<code><a href="#topic+stepEdgeLLK">stepEdgeLLK</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sar) # SAR image is bundled with the package and it is a 
          # standard test image in statistics literature.
diff &lt;- diffLLK(image = sar, bandwidth = 6)
</code></pre>

<hr>
<h2 id='dKQ'>edge detection, performance measure</h2><span id='topic+dKQ'></span>

<h3>Description</h3>

<p> Compute the d_KQ distance between two sets of
edge pixels. It can be used as a performance measure for
(step/roof) edge detectors</p>


<h3>Usage</h3>

<pre><code class='language-R'>dKQ(edge1, edge2)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dKQ_+3A_edge1">edge1</code></td>
<td>
<p>One set of pixels</p>
</td></tr>
<tr><td><code id="dKQ_+3A_edge2">edge2</code></td>
<td>
<p>The other set of pixels</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mathematical definition of <code class="reqn">d_{KQ}</code> is as follows.
<code class="reqn">d_{KQ}(S_1, S_2) = \frac{0.5}{|S_1|}\sum_{p_1\in S_1} d_E(p_1, S_2) +
	\frac{0.5}{|S_2|}\sum_{p_2\in S_2} d_E(p_2, S_1)</code>, where <code class="reqn">S_1</code> and <code class="reqn">S_2</code>
are two point sets, and <code class="reqn">d_E</code> denotes the Euclidean distance.
</p>


<h3>Value</h3>

<p>Value of the <code class="reqn">d_{KQ}</code></p>


<h3>References</h3>

<p>Kang, Y., and Qiu, P., &quot;Jump Detection in Blurred Regression 
Surfaces,&quot; <em>Technometrics</em>, <b>56</b>, 2014, 539-550.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat1 &lt;- matrix(c(1, rep(0, 3)), ncol = 2)
mat2 &lt;- matrix(c(rep(0, 3), 1), ncol = 2)
dKQ(mat1, mat2)
</code></pre>

<hr>
<h2 id='jpex'>Blind Image Deblurring</h2><span id='topic+jpex'></span>

<h3>Description</h3>

<p>jpex() takes in any square matrix (noisy blurry image) and deblurs it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jpex(image, bandwidth, alpha, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jpex_+3A_image">image</code></td>
<td>
<p>An input blurry image to deblurred. The input image is represented a square matrix.</p>
</td></tr>
<tr><td><code id="jpex_+3A_bandwidth">bandwidth</code></td>
<td>
<p>A positive integer that specifies the size of the neighborhood for local smoothing.</p>
</td></tr>
<tr><td><code id="jpex_+3A_alpha">alpha</code></td>
<td>
<p>A numberic between 0 and 1. This is the signifance level for the Chi-square hypothesis test that a given pixel is in a continuity region and not affected by the blur.</p>
</td></tr>
<tr><td><code id="jpex_+3A_sigma">sigma</code></td>
<td>
<p>A positive numeric for the noise level in the blurred image. It is used in the Chi-square test.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>deblurred</code></td>
<td>
<p>The deblurred image</p>
</td></tr>
<tr><td><code>edge</code></td>
<td>
<p>The square matrix, the element of which is the value of the Chi-square test statistic at the pixel location. One can classify a given pixel as a blurry pixcel if edge[i,j]&gt;qchisq(1-alpha, 2).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yicheng Kang</p>


<h3>References</h3>

<p>Kang, Y. (2020) &ldquo;Consistent Blind Image Deblurring Using
Jump-Preserving Extrapolation&rdquo;, <em>Journal of Computational and
Graphical Statistics</em>, <b>29</b>(2), 372 &ndash; 382.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.jpex">cv.jpex</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>library(DRIP)
data(stopsign)
out &lt;- jpex(image = stopsign, bandwidth = as.integer(2), sigma =
0.00623, alpha = 0.001)
</code></pre>

<hr>
<h2 id='JPLLK_surface'>Denoising and jump-preserving</h2><span id='topic+JPLLK_surface'></span>

<h3>Description</h3>

<p> Estimate surface using piecewise local linear 
kernel smoothing. Bandwidth is chosen by leave-one-out cross validation.</p>


<h3>Usage</h3>

<pre><code class='language-R'>JPLLK_surface(image, bandwidth, plot = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="JPLLK_surface_+3A_image">image</code></td>
<td>
<p>A square matrix object of size n by n, no missing
value allowed.</p>
</td></tr>
<tr><td><code id="JPLLK_surface_+3A_bandwidth">bandwidth</code></td>
<td>
<p>A numeric vector with positive integers, which
specify the number of pixels used in the local smoothing. The 
final fitted surface chooses the optimal bandwidth from those
provided by users.</p>
</td></tr>
<tr><td><code id="JPLLK_surface_+3A_plot">plot</code></td>
<td>
<p> If plot = TRUE, the image of the fitted surface is
plotted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At each pixel, the gradient is estimated by a local linear
kernel smoothing procedure. Next, the local neighborhood is
divided into two halves along the direction perpendicular to
(<code class="reqn">\widehat{f}'_{x}</code>, <code class="reqn">\widehat{f}'_{y}</code>). Then the one-
sided local linear kernel (LLK) estimates are obtained in the
two half neighborhoods respectively. Among these two one-sided
estimates, the one with smaller weighted mean square error is
chosen to be the final estimate of the regression surface at the
pixel.
</p>


<h3>Value</h3>

<p>A list of fitted values, residuals, chosen bandwidth and
estimated sigma.</p>


<h3>References</h3>

<p>Qiu, P., &quot;Jump-preserving surface reconstruction from noisy data&quot;, <em>Annals
of the Institute of Statistical Mathematics</em>, <b>61(3)</b>, 2009, 715-751.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+threeStage">threeStage</a></code>, <code><a href="#topic+surfaceCluster">surfaceCluster</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sar) # SAR image is bundled with the package and it is a 
          # standard test image in statistics literature.
fit &lt;- JPLLK_surface(image=sar, bandwidth=c(3, 4))
</code></pre>

<hr>
<h2 id='kid'>Image of a kid taking test</h2><span id='topic+kid'></span>

<h3>Description</h3>

<p> This file contains data of original kid image.
The image has 387x387 pixels. Gray levels are in the range
[0, 255]. In the data file, observations are listed as
a 387x387 matrix. This image has spatially variant blur
involved.</p>


<h3>Usage</h3>

<pre><code class='language-R'>kid</code></pre>


<h3>Format</h3>

<p>This dataset is saved in an ascii file.</p>


<h3>References</h3>

<p>Kang, Y., and Qiu, P., &quot;Jump Detection in Blurred Regression 
Surfaces,&quot; <em>Technometrics</em>, <b>56</b>, 2014, 539-550.
</p>

<hr>
<h2 id='lena'>Image of Lena</h2><span id='topic+lena'></span>

<h3>Description</h3>

<p>This file contains data of the original Lena image.
It has 512x512 pixels. Gray levels are in the
range [0, 255]. In the data file, observations are
listed as a 512x512 matrix.</p>


<h3>Usage</h3>

<pre><code class='language-R'>lena</code></pre>


<h3>Format</h3>

<p>This dataset is saved in an ascii file.</p>


<h3>References</h3>

<p> November 1972 issue of Playboy magazine </p>

<hr>
<h2 id='modify1'>Edge detection, post processing</h2><span id='topic+modify1'></span>

<h3>Description</h3>

<p>Modify detected edges to make them thin. </p>


<h3>Usage</h3>

<pre><code class='language-R'>modify1(bandwidth, image, edge, plot)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modify1_+3A_image">image</code></td>
<td>
<p>A matrix that represents the image.</p>
</td></tr>
<tr><td><code id="modify1_+3A_bandwidth">bandwidth</code></td>
<td>
<p>A positive integer to specify the number of
pixels used in the local smoothing.</p>
</td></tr>
<tr><td><code id="modify1_+3A_edge">edge</code></td>
<td>
<p>A matrix of 0 and 1 represents detected edge 
pixels. </p>
</td></tr>
<tr><td><code id="modify1_+3A_plot">plot</code></td>
<td>
<p>If plot = TRUE, images of detected edges before
the modification and after the modification are plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A local-smoothing based edge detection algorithm may flag deceptive edge
pixel candidates. One kind of such candidates consists of those close
to the real edges. They occur due to the nature of local
smoothing. That is, if the point <code class="reqn">(x_i, y_j)</code> is flagged,
then its neighboring pixels will be flagged with high probability.
This kind of deceptive candidates can make the detected edges
thick. This modification procedure makes the detected edges
thin.
</p>


<h3>Value</h3>

<p>Returns a matrix of zeros and ones of the same size as
edge.</p>


<h3>References</h3>

<p>Qiu, P. and Yandell, B., &quot;Jump detection in regression surfaces,&quot;
<em>Journal of Computational and Graphical Statistics</em> <b>6(3)</b>, 1997,
332-354.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modify2">modify2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sar) # SAR image is bundled with the package and it is a 
          # standard test image in statistics literature.
edge &lt;- stepEdgeLCK(sar, 4, 20)
out &lt;- modify1(4, sar, edge)
</code></pre>

<hr>
<h2 id='modify2'>Edge detection, post processing</h2><span id='topic+modify2'></span>

<h3>Description</h3>

<p>Delete deceptive edge pixels that are scattered
in the design space.</p>


<h3>Usage</h3>

<pre><code class='language-R'>modify2(bandwidth, edge, plot)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modify2_+3A_bandwidth">bandwidth</code></td>
<td>
<p>A positive integer to specify the number of
pixels used in the local smoothing.</p>
</td></tr>
<tr><td><code id="modify2_+3A_edge">edge</code></td>
<td>
<p>A matrix of 0 and 1 represents detected edge 
pixels. </p>
</td></tr>
<tr><td><code id="modify2_+3A_plot">plot</code></td>
<td>
<p>If plot = TRUE, images of detected edges before
the modification and after the modification are plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A local-smoothing based edge detection algorithm may flag deceptive edge
pixel candidates. One kind of such candidates existis due to the nature of hypothesis
testing, on which the threshold value of the edge detection criterion is
based. That is, a point <code class="reqn">(x_i, y_j)</code> could be flagged as a edge
pixel with certain probability, even if it is actually not a edge pixel.
Deceptive candidates of this kind are scattered in the whole design
space. This modification procedure deletes scattered edge pixel candidates.
</p>


<h3>Value</h3>

<p>Returns a matrix of zeros and ones of the same size as
edge.</p>


<h3>References</h3>

<p>Qiu, P. and Yandell, B., &quot;Jump detection in regression surfaces,&quot;
<em>Journal of Computational and Graphical Statistics</em> <b>6(3)</b>, 1997,
332-354.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modify1">modify1</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sar) # SAR image is bundled with the package and it is a 
          # standard test image in statistics literature.
edge &lt;- stepEdgeLCK(sar, 4, 20)
out &lt;- modify2(4, edge)
</code></pre>

<hr>
<h2 id='peppers'>Image of peppers</h2><span id='topic+peppers'></span>

<h3>Description</h3>

<p>This file contains data of the original peppers image.
It has 512x512 pixels. Gray levels are in the
range [0, 255]. In the data file, observations are
listed as a 512x512 matrix.</p>


<h3>Usage</h3>

<pre><code class='language-R'>peppers</code></pre>


<h3>Format</h3>

<p>This dataset is saved in an ascii file.</p>

<hr>
<h2 id='roofDiff'>
roof/valley edge detection
</h2><span id='topic+roofDiff'></span>

<h3>Description</h3>

<p>Compute difference between two one-sided gradient
estimators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>	roofDiff(image, bandwidth, blur)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roofDiff_+3A_image">image</code></td>
<td>
<p>A square matrix object of size n by n, no
missing value allowed.</p>
</td></tr>
<tr><td><code id="roofDiff_+3A_bandwidth">bandwidth</code></td>
<td>
<p>A positive integer to specify the number of
pixels used in the local smoothing.</p>
</td></tr>
<tr><td><code id="roofDiff_+3A_blur">blur</code></td>
<td>
<p>If blur = TRUE, besides the conventional 2-D kernel
function, a univariate kernel function is used to address
the issue of blur.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At each pixel, the second-order derivarives (i.e., <code class="reqn">f''_{xx}</code>,
<code class="reqn">f''_{xy}</code>, and <code class="reqn">f''_{yy}</code>) are estimated by
a local quadratic kernel smoothing procedure. Next, the local
neighborhood is first divided into two halves along the direction
perpendicular to (<code class="reqn">\widehat{f}''_{xx}</code>, <code class="reqn">\widehat{f}''_{xy}</code>). Then the
one-sided estimates of <code class="reqn">f'_{x+}</code> and <code class="reqn">f'_{x-}</code> are obtained
respectively by local linear kernel smoothing. The estimates of
<code class="reqn">f'_{y+}</code> and <code class="reqn">f'_{y-}</code> are obtained by the same procedure
except that the neighborhood is divided along the direction
(<code class="reqn">\widehat{f}''_{xy}</code>, <code class="reqn">\widehat{f}''_{yy}</code>).
</p>


<h3>Value</h3>

<p>Returns a matrix where each entry is the maximum of the 
differences: <code class="reqn">|\widehat{f}_{x+} - \widehat{f}_{x-}|</code> and  
<code class="reqn">|\widehat{f}_{y+} - \widehat{f}_{y-}|</code> at each pixel.
</p>


<h3>References</h3>

<p>Qiu, P., and Kang, Y. &quot;Blind Image Deblurring Using Jump Regression
Analysis,&quot; <em>Statistica Sinica</em>, <b>25</b>, 2015, 879-899.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+roofEdgeParSel">roofEdgeParSel</a></code>, <code><a href="#topic+roofEdge">roofEdge</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	data(peppers) 
	diff &lt;- roofDiff(image = peppers, bandwidth = 8) # Time consuming
</code></pre>

<hr>
<h2 id='roofEdge'>Edge detection, denoising and deblurring</h2><span id='topic+roofEdge'></span>

<h3>Description</h3>

<p>Detect roof/valley edges in an image using 
piecewise local linear kernel smoothing.</p>


<h3>Usage</h3>

<pre><code class='language-R'>roofEdge(image, bandwidth, thresh, edge1, blur, plot)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roofEdge_+3A_image">image</code></td>
<td>
<p>A square matrix object of size n by n, no
missing value allowed.</p>
</td></tr>
<tr><td><code id="roofEdge_+3A_bandwidth">bandwidth</code></td>
<td>
<p>A positive integer to specify the number of
pixels used in the local smoothing.</p>
</td></tr>
<tr><td><code id="roofEdge_+3A_thresh">thresh</code></td>
<td>
<p>Threshold value used in the edge detection
criterion. </p>
</td></tr>
<tr><td><code id="roofEdge_+3A_edge1">edge1</code></td>
<td>
<p>Step edges. The function excludes step edges when
detects roof/valley edges.</p>
</td></tr>
<tr><td><code id="roofEdge_+3A_blur">blur</code></td>
<td>
<p>If blur = TRUE, besides the conventional 2-D
kernel function, a univariate kernel function is used
in the local smoothing to address the issue of blur.</p>
</td></tr>
<tr><td><code id="roofEdge_+3A_plot">plot</code></td>
<td>
<p>If plot = TRUE, an image of detected edges is
plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At each pixel, the second-order derivarives (i.e., <code class="reqn">f''_{xx}</code>,
<code class="reqn">f''_{xy}</code>, and <code class="reqn">f''_{yy}</code>) are estimated by
a local quadratic kernel smoothing procedure. Next, the local
neighborhood is first divided into two halves along the direction
perpendicular to (<code class="reqn">\widehat{f}''_{xx}</code>, <code class="reqn">\widehat{f}''_{xy}</code>). Then the
one-sided estimates of <code class="reqn">f'_{x+}</code> and <code class="reqn">f'_{x-}</code> are obtained
respectively by local linear kernel smoothing. The estimates of
<code class="reqn">f'_{y+}</code> and <code class="reqn">f'_{y-}</code> are obtained by the same procedure
except that the neighborhood is divided along the direction
(<code class="reqn">\widehat{f}''_{xy}</code>, <code class="reqn">\widehat{f}''_{yy}</code>). The pixel is
flagged as a roof/valley edge pixel if <code class="reqn">max(|\widehat{f}_{x+} - \widehat{f}_{x-}|,  
	|\widehat{f}_{y+} - \widehat{f}_{y-}|)&gt;</code> the specified thresh and there is
no step edge pixels in the neighborhood.
</p>


<h3>Value</h3>

<p>Returns a matrix of zeros and ones of the same size as
image.</p>


<h3>References</h3>

<p>Qiu, P., and Kang, Y. &quot;Blind Image Deblurring Using Jump Regression
Analysis,&quot; <em>Statistica Sinica</em>, <b>25</b>, 2015, 879-899.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+roofEdgeParSel">roofEdgeParSel</a></code>, <code><a href="#topic+roofDiff">roofDiff</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(peppers)
# Not run
#step.edges &lt;- stepEdgeLLK(peppers, bandwidth=6, thresh=25, plot=FALSE)
#roof.edges &lt;- roofEdge(image=peppers, bandwidth=9, thresh=3000, edge1=step.edges,
#     blur=FALSE, plot=FALSE) # Time consuming
#edges = step.edges + roof.edges     
#par(mfrow=c(2,2))
#image(1-step.edges, col=gray(0:1))
#image(1-roof.edges, col=gray(0:1))
#image(1-edges, col=gray(0:1))
#image(peppers, col=gray(c(0:255)/255))
</code></pre>

<hr>
<h2 id='roofEdgeParSel'>roof/valley edge detection, parameter selection</h2><span id='topic+roofEdgeParSel'></span>

<h3>Description</h3>

<p>Select bandwidth and threshold value for the roof/valley edge detector
using bootstrap procedure</p>


<h3>Usage</h3>

<pre><code class='language-R'>roofEdgeParSel(image, bandwidth, thresh, nboot, edge1, blur=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roofEdgeParSel_+3A_image">image</code></td>
<td>
<p>A square matrix object of size n by n, no
missing value allowed.</p>
</td></tr>
<tr><td><code id="roofEdgeParSel_+3A_bandwidth">bandwidth</code></td>
<td>
<p>Positive integers to specify the number of
pixels used in the local smoothing. These are the bandwidth parameters
to be chosen from.</p>
</td></tr>
<tr><td><code id="roofEdgeParSel_+3A_thresh">thresh</code></td>
<td>
<p>Threshold values to be chosen from.</p>
</td></tr>
<tr><td><code id="roofEdgeParSel_+3A_nboot">nboot</code></td>
<td>
<p>Number of bootstrap samples.</p>
</td></tr>
<tr><td><code id="roofEdgeParSel_+3A_edge1">edge1</code></td>
<td>
<p>Step edges. The function excludes step edges when detect
roof/valley edges.</p>
</td></tr>
<tr><td><code id="roofEdgeParSel_+3A_blur">blur</code></td>
<td>
<p>TRUE if the image contains blur, FALSE otherwise.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>If <em>blur=TRUE</em>, then a conventional local linear kernel smoothing is
applied to estimate the blurred surface; Bootstrap samples are obtained by
drawing with replacement from the residuals and the <code class="reqn">d_{KQ}</code> is computed
for the detected edges of the original sample and those of the bootstrap
samples. If <em>blur=FALSE</em>, the procedure is the same as when <em>blur=TRUE</em>
except that a jump-preserving kernel smoothing procedure is used to obtain
residuals.
</p>


<h3>Value</h3>

<p>Returns a list of the selected bandwdith, the selected threshold value,
and a matrix of <code class="reqn">d_{KQ}</code> values with each entry corresponding to each combination
of bandwdith and threshold.</p>


<h3>References</h3>

<p>Qiu, P., and Kang, Y. &quot;Blind Image Deblurring Using Jump Regression
Analysis,&quot; <em>Statistica Sinica</em>, <b>25</b>, 2015, 879-899.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+roofDiff">roofDiff</a></code>, <code><a href="#topic+roofEdge">roofEdge</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Not Run
#data(peppers) # Peppers image is bundled with the package and it is a
              # standard test image in image processing literature.
#step.edges &lt;- stepEdgeLLK(image = peppers, bandwidth = 9, thresh = 17, plot = FALSE)
#set.seed(24)
#parSel &lt;- roofEdgeParSel(image = peppers, bandwidth = 5, thresh = 5000,
#nboot = 1, edge1 = step.edges, blur = TRUE) # Time Consuming
</code></pre>

<hr>
<h2 id='sar'>Synthetic aperture radar image of an area near Thetford forest,
England</h2><span id='topic+sar'></span>

<h3>Description</h3>

<p> This file contains data of original sar image.
The image has 250x250 pixels. Gray levels are in the range
[0, 255]. In the data file, observations are listed as
a 250x250 matrix. This image contains much noise.</p>


<h3>Usage</h3>

<pre><code class='language-R'>sar</code></pre>


<h3>Format</h3>

<p>This dataset is saved in an ascii file.</p>


<h3>References</h3>

<p>This data can be downloaded from:
http://peipa.essex.ac.uk/ipa/pix/books/glasbey-horgan/</p>

<hr>
<h2 id='stepEdgeLC2K'>Edge detection, denoising and deblurring</h2><span id='topic+stepEdgeLC2K'></span>

<h3>Description</h3>

<p>Detect step edges in an image using piecewise
local constant kernel smoothing.</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepEdgeLC2K(image, bandwidth, thresh, plot)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepEdgeLC2K_+3A_image">image</code></td>
<td>
<p>A square matrix object of size n by n, no
missing value allowed.</p>
</td></tr>
<tr><td><code id="stepEdgeLC2K_+3A_bandwidth">bandwidth</code></td>
<td>
<p>A positive integer to specify the number of
pixels used in the local smoothing.</p>
</td></tr>
<tr><td><code id="stepEdgeLC2K_+3A_thresh">thresh</code></td>
<td>
<p>Threshold value used in the edge detection
criterion. </p>
</td></tr>
<tr><td><code id="stepEdgeLC2K_+3A_plot">plot</code></td>
<td>
<p>If plot = TRUE, an image of detected edges is
plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At each pixel, the gradient is estimated by a local linear
kernel smoothing procedure. Next, the local neighborhood is
divided into two halves along the direction perpendicular to
(<code class="reqn">\widehat{f}'_{x}</code>, <code class="reqn">\widehat{f}'_{y}</code>). Then the one-
sided deblurring local constant kernel (LC2K) estimates are obtained in the
two half neighborhoods respectively. The pixel is flagged as
a step edge pixel if <code class="reqn">|\widehat{f}_+ - \widehat{f}_-|&gt;u</code>, where
<code class="reqn">u</code> is a threshold value.
</p>


<h3>Value</h3>

<p>Returns a matrix of zeros and ones of the same size as
image. Value one represent edge pixels and value zero represent
non-edge pixels.</p>


<h3>References</h3>

<p>Kang, Y., and Qiu, P., &quot;Jump Detection in Blurred Regression 
Surfaces,&quot; <em>Technometrics</em>, <b>56</b>, 2014, 539-550.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stepEdgeLCK">stepEdgeLCK</a></code>, <code><a href="#topic+stepEdgeLLK">stepEdgeLLK</a></code>, <code><a href="#topic+stepEdgeLL2K">stepEdgeLL2K</a></code>,
<code><a href="#topic+diffLC2K">diffLC2K</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sar) # SAR image is bundled with the package and it is a 
          # standard test image in statistics literature.
edge &lt;- stepEdgeLC2K(image = sar, bandwidth = 4, thresh = 20)
</code></pre>

<hr>
<h2 id='stepEdgeLCK'>Edge detection, denoising and deblurring</h2><span id='topic+stepEdgeLCK'></span>

<h3>Description</h3>

<p>Detect step edges in an image using piecewise
local constant kernel smoothing.</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepEdgeLCK(image, bandwidth, thresh, plot)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepEdgeLCK_+3A_image">image</code></td>
<td>
<p>A square matrix object of size n by n, no
missing value allowed.</p>
</td></tr>
<tr><td><code id="stepEdgeLCK_+3A_bandwidth">bandwidth</code></td>
<td>
<p>A positive integer to specify the number of
pixels used in the local smoothing.</p>
</td></tr>
<tr><td><code id="stepEdgeLCK_+3A_thresh">thresh</code></td>
<td>
<p>Threshold value used in the edge detection
criterion. </p>
</td></tr>
<tr><td><code id="stepEdgeLCK_+3A_plot">plot</code></td>
<td>
<p>If plot = TRUE, an image of detected edges is
plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At each pixel, the gradient is estimated by a local linear
kernel smoothing procedure. Next, the local neighborhood is
divided into two halves along the direction perpendicular to
(<code class="reqn">\widehat{f}'_{x}</code>, <code class="reqn">\widehat{f}'_{y}</code>). Then the one-
sided local constant kernel (LCK) estimates are obtained in the
two half neighborhoods respectively. The pixel is flagged as
a step edge pixel if <code class="reqn">|\widehat{f}_+ - \widehat{f}_-|&gt;u</code>, where
<code class="reqn">u</code> is a threshold value.
</p>


<h3>Value</h3>

<p>Returns a matrix of zeros and ones of the same size as
image. Value one represent edge pixels and value zero represent
non-edge pixels.</p>


<h3>References</h3>

<p>Kang, Y., and Qiu, P., &quot;Jump Detection in Blurred Regression 
Surfaces,&quot; <em>Technometrics</em>, <b>56</b>, 2014, 539-550.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stepEdgeLC2K">stepEdgeLC2K</a></code>, <code><a href="#topic+stepEdgeLLK">stepEdgeLLK</a></code>, <code><a href="#topic+stepEdgeLL2K">stepEdgeLL2K</a></code>,
<code><a href="#topic+diffLCK">diffLCK</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sar) # SAR image is bundled with the package and it is a 
          # standard test image in statistics literature.
edge &lt;- stepEdgeLCK(image = sar, bandwidth = 4, thresh = 20)
</code></pre>

<hr>
<h2 id='stepEdgeLL2K'>Edge detection, denoising and deblurring</h2><span id='topic+stepEdgeLL2K'></span>

<h3>Description</h3>

<p>Detect step edges in an image using piecewise
local linear kernel smoothing.</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepEdgeLL2K(image, bandwidth, thresh, plot)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepEdgeLL2K_+3A_image">image</code></td>
<td>
<p>A square matrix object of size n by n, no
missing value allowed.</p>
</td></tr>
<tr><td><code id="stepEdgeLL2K_+3A_bandwidth">bandwidth</code></td>
<td>
<p>A positive integer to specify the number of
pixels used in the local smoothing.</p>
</td></tr>
<tr><td><code id="stepEdgeLL2K_+3A_thresh">thresh</code></td>
<td>
<p>Threshold value used in the edge detection
criterion. </p>
</td></tr>
<tr><td><code id="stepEdgeLL2K_+3A_plot">plot</code></td>
<td>
<p>If plot = TRUE, an image of detected edges is
plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At each pixel, the gradient is estimated by a local linear
kernel smoothing procedure. Next, the local neighborhood is
divided into two halves along the direction perpendicular to
(<code class="reqn">\widehat{f}'_{x}</code>, <code class="reqn">\widehat{f}'_{y}</code>). Then the one-
sided deblurring local linear kernel (LL2K) estimates are obtained in the
two half neighborhoods respectively. The pixel is flagged as
a step edge pixel if <code class="reqn">|\widehat{f}_+ - \widehat{f}_-|&gt;u</code>, where
<code class="reqn">u</code> is a threshold value.
</p>


<h3>Value</h3>

<p>Returns a matrix of zeros and ones of the same size as
image. Value one represent edge pixels and value zero represent
non-edge pixels.</p>


<h3>References</h3>

<p>Kang, Y., and Qiu, P., &quot;Jump Detection in Blurred Regression 
Surfaces,&quot; <em>Technometrics</em>, <b>56</b>, 2014, 539-550.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stepEdgeLCK">stepEdgeLCK</a></code>, <code><a href="#topic+stepEdgeLLK">stepEdgeLLK</a></code>, <code><a href="#topic+stepEdgeLC2K">stepEdgeLC2K</a></code>,
<code><a href="#topic+diffLL2K">diffLL2K</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sar) # SAR image is bundled with the package and it is a 
          # standard test image in statistics literature.
edge &lt;- stepEdgeLL2K(image = sar, bandwidth = 6, thresh = 20)
</code></pre>

<hr>
<h2 id='stepEdgeLLK'>Edge detection, denoising and deblurring</h2><span id='topic+stepEdgeLLK'></span>

<h3>Description</h3>

<p>Detect step edges in an image using piecewise
local linear kernel smoothing.</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepEdgeLLK(image, bandwidth, thresh, plot)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepEdgeLLK_+3A_image">image</code></td>
<td>
<p>A square matrix object of size n by n, no
missing value allowed.</p>
</td></tr>
<tr><td><code id="stepEdgeLLK_+3A_bandwidth">bandwidth</code></td>
<td>
<p>A positive integer to specify the number of
pixels used in the local smoothing.</p>
</td></tr>
<tr><td><code id="stepEdgeLLK_+3A_thresh">thresh</code></td>
<td>
<p>Threshold value used in the edge detection
criterion. </p>
</td></tr>
<tr><td><code id="stepEdgeLLK_+3A_plot">plot</code></td>
<td>
<p>If plot = TRUE, an image of detected edges is
plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At each pixel, the gradient is estimated by a local linear
kernel smoothing procedure. Next, the local neighborhood is
divided into two halves along the direction perpendicular to
(<code class="reqn">\widehat{f}'_{x}</code>, <code class="reqn">\widehat{f}'_{y}</code>). Then the one-
sided local linear kernel (LLK) estimates are obtained in the
two half neighborhoods respectively. The pixel is flagged as
a step edge pixel if <code class="reqn">|\widehat{f}_+ - \widehat{f}_-|&gt;u</code>, where
<code class="reqn">u</code> is a threshold value.
</p>


<h3>Value</h3>

<p>Returns a matrix of zeros and ones of the same size as
image. Value one represent edge pixels and value zero represent
non-edge pixels.</p>


<h3>References</h3>

<p>Kang, Y., and Qiu, P., &quot;Jump Detection in Blurred Regression 
Surfaces,&quot; <em>Technometrics</em>, <b>56</b>, 2014, 539-550.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stepEdgeLCK">stepEdgeLCK</a></code>, <code><a href="#topic+stepEdgeLC2K">stepEdgeLC2K</a></code>, <code><a href="#topic+stepEdgeLL2K">stepEdgeLL2K</a></code>,
<code><a href="#topic+diffLLK">diffLLK</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sar) # SAR image is bundled with the package and it is a 
          # standard test image in statistics literature.
edge &lt;- stepEdgeLLK(image = sar, bandwidth = 9, thresh = 17)
</code></pre>

<hr>
<h2 id='stepEdgeParSelLC2K'>edge detection, parameter selection</h2><span id='topic+stepEdgeParSelLC2K'></span>

<h3>Description</h3>

<p>Select bandwidth and threshold value for LC2K edge detector
using bootstrap procedure</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepEdgeParSelLC2K(image, bandwidth, thresh, nboot)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepEdgeParSelLC2K_+3A_image">image</code></td>
<td>
<p>A square matrix object of size n by n, no
missing value allowed.</p>
</td></tr>
<tr><td><code id="stepEdgeParSelLC2K_+3A_bandwidth">bandwidth</code></td>
<td>
<p>Positive integers to specify the number of
pixels used in the local smoothing. These are the bandwidth
parameters to be chosen from.</p>
</td></tr>
<tr><td><code id="stepEdgeParSelLC2K_+3A_thresh">thresh</code></td>
<td>
<p>Threshold values to be chosen from.</p>
</td></tr>
<tr><td><code id="stepEdgeParSelLC2K_+3A_nboot">nboot</code></td>
<td>
<p>Number of bootstrap samples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A jump-preserving local linear kernel smoothing is applied to estimate the
discontinuous regression surface; Bootstrap samples are obtained by
drawing with replacement from the residuals and the <code class="reqn">d_{KQ}</code> is computed
for the detected edges of the original sample and those of the bootstrap
samples. 
</p>


<h3>Value</h3>

<p>Returns a list of the selected bandwdith, the selected threshold value,
and a matrix of <code class="reqn">d_{KQ}</code> values with each entry corresponding to each
combination of bandwdith and threshold.</p>


<h3>References</h3>

<p>Kang, Y., and Qiu, P., &quot;Jump Detection in Blurred Regression 
Surfaces,&quot; <em>Technometrics</em>, <b>56</b>, 2014, 539-550.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stepEdgeParSelLCK">stepEdgeParSelLCK</a></code>, <code><a href="#topic+stepEdgeParSelLLK">stepEdgeParSelLLK</a></code>,
<code><a href="#topic+stepEdgeParSelLL2K">stepEdgeParSelLL2K</a></code>, <code><a href="#topic+stepEdgeLC2K">stepEdgeLC2K</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sar) # SAR image is bundled with the package and it is a
          # standard test image in statistics literature.
set.seed(24)
parSel &lt;- stepEdgeParSelLC2K(image = sar, bandwidth = 4, thresh = 19:20, nboot = 1)
</code></pre>

<hr>
<h2 id='stepEdgeParSelLCK'>edge detection, parameter selection</h2><span id='topic+stepEdgeParSelLCK'></span>

<h3>Description</h3>

<p>Select bandwidth and threshold value for LCK edge detector
using bootstrap procedure</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepEdgeParSelLCK(image, bandwidth, thresh, nboot)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepEdgeParSelLCK_+3A_image">image</code></td>
<td>
<p>A square matrix object of size n by n, no
missing value allowed.</p>
</td></tr>
<tr><td><code id="stepEdgeParSelLCK_+3A_bandwidth">bandwidth</code></td>
<td>
<p>Positive integers to specify the number of
pixels used in the local smoothing. These are bandwidth parameters
to be chosen from.</p>
</td></tr>
<tr><td><code id="stepEdgeParSelLCK_+3A_thresh">thresh</code></td>
<td>
<p>Threshold values to be chosen from.</p>
</td></tr>
<tr><td><code id="stepEdgeParSelLCK_+3A_nboot">nboot</code></td>
<td>
<p>Number of bootstrap samples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A jump-preserving local linear kernel smoothing is applied to estimate the
discontinuous regression surface; Bootstrap samples are obtained by
drawing with replacement from the residuals and the <code class="reqn">d_{KQ}</code> is computed
for the detected edges of the original sample and those of the bootstrap
samples. 
</p>


<h3>Value</h3>

<p>Returns a list of the selected bandwdith, the selected threshold
value, and a matrix of <code class="reqn">d_{KQ}</code> values with each entry corresponding to
each combination of bandwdith and threshold.</p>


<h3>References</h3>

<p>Kang, Y., and Qiu, P., &quot;Jump Detection in Blurred Regression 
Surfaces,&quot; <em>Technometrics</em>, <b>56</b>, 2014, 539-550.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stepEdgeParSelLC2K">stepEdgeParSelLC2K</a></code>, <code><a href="#topic+stepEdgeParSelLLK">stepEdgeParSelLLK</a></code>,
<code><a href="#topic+stepEdgeParSelLL2K">stepEdgeParSelLL2K</a></code>, <code><a href="#topic+stepEdgeLCK">stepEdgeLCK</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sar) # SAR image is bundled with the package and it is a
          # standard test image in statistics literature.
set.seed(24)
parSel &lt;- stepEdgeParSelLCK(image = sar, bandwidth = 4, thresh = 19:20, nboot = 1)
</code></pre>

<hr>
<h2 id='stepEdgeParSelLL2K'>edge detection, parameter selection</h2><span id='topic+stepEdgeParSelLL2K'></span>

<h3>Description</h3>

<p>Select threshold value for LL2K edge detector
using bootstrap procedure</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepEdgeParSelLL2K(image, bandwidth, thresh, nboot)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepEdgeParSelLL2K_+3A_image">image</code></td>
<td>
<p>A square matrix object of size n by n, no
missing value allowed.</p>
</td></tr>
<tr><td><code id="stepEdgeParSelLL2K_+3A_bandwidth">bandwidth</code></td>
<td>
<p>Positive integers to specify the number of
pixels used in the local smoothing. These are the bandwidth
parameters to be chosen from.</p>
</td></tr>
<tr><td><code id="stepEdgeParSelLL2K_+3A_thresh">thresh</code></td>
<td>
<p>Threshold values to be chosen from.</p>
</td></tr>
<tr><td><code id="stepEdgeParSelLL2K_+3A_nboot">nboot</code></td>
<td>
<p>Number of bootstrap samples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A jump-preserving local linear kernel smoothing is applied to estimate the
discontinuous regression surface; Bootstrap samples are obtained by
drawing with replacement from the residuals and the <code class="reqn">d_{KQ}</code> is computed
for the detected edges of the original sample and those of the bootstrap
samples. 
</p>


<h3>Value</h3>

<p>Returns a list of the selected bandwdith, the selected
threshold value, and a matrix of <code class="reqn">d_{KQ}</code> values with each entry
corresponding to each combination of bandwdith and threshold.</p>


<h3>References</h3>

<p>Kang, Y., and Qiu, P., &quot;Jump Detection in Blurred Regression 
Surfaces,&quot; <em>Technometrics</em>, <b>56</b>, 2014, 539-550.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stepEdgeParSelLCK">stepEdgeParSelLCK</a></code>, <code><a href="#topic+stepEdgeParSelLLK">stepEdgeParSelLLK</a></code>,
<code><a href="#topic+stepEdgeParSelLC2K">stepEdgeParSelLC2K</a></code>, <code><a href="#topic+stepEdgeLL2K">stepEdgeLL2K</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sar) # SAR image is bundled with the package and it is a
          # standard test image in statistics literature.
set.seed(24)
parSel &lt;- stepEdgeParSelLL2K(image = sar, bandwidth = 5, thresh = 20:21, nboot = 1) # Time consuming
</code></pre>

<hr>
<h2 id='stepEdgeParSelLLK'>edge detection, parameter selection</h2><span id='topic+stepEdgeParSelLLK'></span>

<h3>Description</h3>

<p>Select threshold value for LLK edge detector
using bootstrap procedure</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepEdgeParSelLLK(image, bandwidth, thresh, nboot)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepEdgeParSelLLK_+3A_image">image</code></td>
<td>
<p>A square matrix object of size n by n, no
missing value allowed.</p>
</td></tr>
<tr><td><code id="stepEdgeParSelLLK_+3A_bandwidth">bandwidth</code></td>
<td>
<p>Positive integers to specify the number of
pixels used in the local smoothing. These are the bandwidth
parameters to be chosen from.</p>
</td></tr>
<tr><td><code id="stepEdgeParSelLLK_+3A_thresh">thresh</code></td>
<td>
<p>Threshold values to be chosen from.</p>
</td></tr>
<tr><td><code id="stepEdgeParSelLLK_+3A_nboot">nboot</code></td>
<td>
<p>Number of bootstrap samples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A jump-preserving local linear kernel smoothing is applied to estimate the
discontinuous regression surface; Bootstrap samples are obtained by
drawing with replacement from the residuals and the <code class="reqn">d_{KQ}</code> is computed
for the detected edges of the original sample and those of the bootstrap
samples. 
</p>


<h3>Value</h3>

<p>Returns a list of the selected bandwdith, the selected
threshold value, and a matrix of <code class="reqn">d_{KQ}</code> values with each entry
corresponding to each combination of bandwdith and threshold.</p>


<h3>References</h3>

<p>Kang, Y., and Qiu, P., &quot;Jump Detection in Blurred Regression 
Surfaces,&quot; <em>Technometrics</em>, <b>56</b>, 2014, 539-550.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stepEdgeParSelLCK">stepEdgeParSelLCK</a></code>, <code><a href="#topic+stepEdgeParSelLC2K">stepEdgeParSelLC2K</a></code>,
<code><a href="#topic+stepEdgeParSelLL2K">stepEdgeParSelLL2K</a></code>, <code><a href="#topic+stepEdgeLLK">stepEdgeLLK</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sar) # SAR image is bundled with the package and it is a
          # standard test image in statistics literature.
set.seed(24)
parSel &lt;- stepEdgeParSelLLK(image = sar, bandwidth = 5, thresh = c(17,21), nboot = 1)
</code></pre>

<hr>
<h2 id='stopsign'>Image of Stop Sign</h2><span id='topic+stopsign'></span>

<h3>Description</h3>

<p> This file contains data of stop sign image.
The image has 160x160 pixels. Gray levels are in the range
[0, 255]. In the data file, observations are listed as
a 160x160 matrix. This image has much blurring involved.</p>


<h3>Usage</h3>

<pre><code class='language-R'>stopsign</code></pre>


<h3>Format</h3>

<p>This dataset is saved in an ascii file.</p>

<hr>
<h2 id='surfaceCluster'>Denoising, deblurring and edge-preserving</h2><span id='topic+surfaceCluster'></span>

<h3>Description</h3>

<p> Estimate surface using local pixel clustering 
and kernel smoothing. Bandwidth is specified by user.</p>


<h3>Usage</h3>

<pre><code class='language-R'>surfaceCluster(image, bandwidth, sig.level, sigma, phi0, mean_std_abs, cw=3,
blur = FALSE, plot = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surfaceCluster_+3A_image">image</code></td>
<td>
<p>A square matrix object of size n by n, no missing
value allowed.</p>
</td></tr>
<tr><td><code id="surfaceCluster_+3A_bandwidth">bandwidth</code></td>
<td>
<p>A positive integer that specifies the number of
pixels used in the local smoothing.</p>
</td></tr>
<tr><td><code id="surfaceCluster_+3A_sig.level">sig.level</code></td>
<td>
<p>Specifies the significance level of the
hypothesis test deciding to cluster pixels or not.</p>
</td></tr>
<tr><td><code id="surfaceCluster_+3A_sigma">sigma</code></td>
<td>
<p>Specifies the noise level (i.e., standard deviation of the error distribution). It is used for computing the asymptotic threshold for residuals, which are defined to be the difference between the local linear kernel smoothing output and the center weighted median filter output. If not specified by the user, a jump-preserving local linear kernel smoothing surface estimation (Qiu 2009) is used to obtain an estimated sigma.</p>
</td></tr>
<tr><td><code id="surfaceCluster_+3A_phi0">phi0</code></td>
<td>
<p>Specifies the density of the standardized error distribution at 0. It is used for computing the asymptotic threshold for residuals, which are defined to be the difference between the local linear kernel smoothing output and the center weighted median filter output. If not specified by the user, a jump-preserving local linear kernel smoothing surface estimation (Qiu 2009) is used to obtain an estimated value.</p>
</td></tr>
<tr><td><code id="surfaceCluster_+3A_mean_std_abs">mean_std_abs</code></td>
<td>
<p>Specifies the mean of absolute value of the standardized error. It is used for computing the asymptotic threshold for residuals, which are defined to be the difference between the local linear kernel smoothing output and the center weighted median filter output. If not specified by the user, a jump-preserving local linear kernel smoothing surface estimation (Qiu 2009) is used to obtain an estimated value.</p>
</td></tr>
<tr><td><code id="surfaceCluster_+3A_cw">cw</code></td>
<td>
<p>Specifies the center weight for the center weighted
median filter. It must be a positive integer.</p>
</td></tr>
<tr><td><code id="surfaceCluster_+3A_blur">blur</code></td>
<td>
<p>If blur = TRUE, besides a conventional 2-D kernel
function, a univariate increasing kernel function is used in
the local kernel smoothing to address the issue with blur.</p>
</td></tr>
<tr><td><code id="surfaceCluster_+3A_plot">plot</code></td>
<td>
<p> If plot = TRUE, the image of the fitted surface is
plotted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list. 'estImg' is the restored image. 'sigma' is the estimated standard deviation of the random error. It is the input value if specified by the user. 'phi0' is the estimated density of the error distribution at 0. It is the input value if specified by the user. 'mean_std_abs' is the estimated absolute mean of the error distribution. It is the input value if specified by the user.</p>


<h3>References</h3>

<p>Kang, Y., Mukherjee, P.S., and Qiu, P. (2017), &quot;Efficient Blind Image
Deblurring Using Nonparametric Regression and Local Pixel 
Clustering&quot;, Technometrics, DOI: 10.1080/00401706.2017.1415975.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+JPLLK_surface">JPLLK_surface</a></code>, <code><a href="#topic+threeStage">threeStage</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(brain) 
fit &lt;- surfaceCluster(image=brain, bandwidth=4, sig.level=.9995, cw=3, blur=TRUE)
</code></pre>

<hr>
<h2 id='surfaceCluster_bandwidth'>Denoising, deblurring, bandwidth selection, and edge-preserving</h2><span id='topic+surfaceCluster_bandwidth'></span>

<h3>Description</h3>

<p> Select the bandwidth parameter for the function surfaceCluster based on cross validation. In the cases when there is no blur involved (i.e., denoising only), leave-one-out cross validation is used. In the cases when there is blur involved, a modified cross validation is used. </p>


<h3>Usage</h3>

<pre><code class='language-R'>surfaceCluster_bandwidth(image, bandwidths, sig.level, sigma,
 phi0, mean_std_abs, relwt=0.5, cw=3, blur=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surfaceCluster_bandwidth_+3A_image">image</code></td>
<td>
<p>A square matrix object of size n by n, no missing
value allowed.</p>
</td></tr>
<tr><td><code id="surfaceCluster_bandwidth_+3A_bandwidths">bandwidths</code></td>
<td>
<p>An array of positive integers that specifies the candiate bandwidth parameters. All the array elements must be positive integers because the bandwidth is specified in terms of number of pixels.</p>
</td></tr>
<tr><td><code id="surfaceCluster_bandwidth_+3A_sig.level">sig.level</code></td>
<td>
<p>Specifies the significance level of the
hypothesis test deciding to cluster pixels or not.</p>
</td></tr>
<tr><td><code id="surfaceCluster_bandwidth_+3A_sigma">sigma</code></td>
<td>
<p>Specifies the noise level (i.e., standard deviation of the error distribution). It is used for computing the asymptotic threshold for residuals, which are defined to be the difference between the local linear kernel smoothing output and the center weighted median filter output. If not specified by the user, a jump-preserving local linear kernel smoothing surface estimation (Qiu 2009) is used to obtain an estimated sigma.</p>
</td></tr>
<tr><td><code id="surfaceCluster_bandwidth_+3A_phi0">phi0</code></td>
<td>
<p>Specifies the density of the standardized error distribution at 0. It is used for computing the asymptotic threshold for residuals, which are defined to be the difference between the local linear kernel smoothing output and the center weighted median filter output. If not specified by the user, a jump-preserving local linear kernel smoothing surface estimation (Qiu 2009) is used to obtain an estimated value.</p>
</td></tr>
<tr><td><code id="surfaceCluster_bandwidth_+3A_mean_std_abs">mean_std_abs</code></td>
<td>
<p>Specifies the mean of absolute value of the standardized error. It is used for computing the asymptotic threshold for residuals, which are defined to be the difference between the local linear kernel smoothing output and the center weighted median filter output. If not specified by the user, a jump-preserving local linear kernel smoothing surface estimation (Qiu 2009) is used to obtain an estimated value.</p>
</td></tr>
<tr><td><code id="surfaceCluster_bandwidth_+3A_relwt">relwt</code></td>
<td>
<p>The relative weight assigned to the cross validation score in the continuity region. That is, 1 - relwt is assigned to the cross validation score around the step edges. It is used only when there is blur involved.</p>
</td></tr>
<tr><td><code id="surfaceCluster_bandwidth_+3A_cw">cw</code></td>
<td>
<p>Specifies the center weight for the center weighted median filter. It must be a positive integer.</p>
</td></tr>
<tr><td><code id="surfaceCluster_bandwidth_+3A_blur">blur</code></td>
<td>
<p>If blur = TRUE, besides a conventional 2-D kernel
function, a univariate increasing kernel function is used in
the local kernel smoothing to address the issue with blur.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list. 'cv_dataframe' contains the cross validation scores corresponding to each candidate bandwidth. 'bandwidth_hat' is the selected bandwidth. 'sigma' is the estimated standard deviation of the random error. It is the input value if specified by the user. 'phi0' is the estimated density of the error distribution at 0. It is the input value if specified by the user. 'mean_std_abs' is the estimated absolute mean of the error distribution. It is the input value if specified by the user. </p>


<h3>References</h3>

<p>Kang, Y., Mukherjee, P.S., and Qiu, P. (2017), &quot;Efficient Blind Image
Deblurring Using Nonparametric Regression and Local Pixel 
Clustering&quot;, Technometrics, DOI: 10.1080/00401706.2017.1415975.
</p>
<p>Qiu, P., &quot;Jump-preserving surface reconstruction from noisy data,&quot;
Annals of the Institute of Statistical Mathematics, 61(3), 2009,
715&ndash;751.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+JPLLK_surface">JPLLK_surface</a></code>, <code><a href="#topic+threeStage">threeStage</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(brain) 
bandwidth_select &lt;- surfaceCluster_bandwidth(image=brain,
bandwidths=c(3:4), sig.level=.9995, blur=TRUE)
</code></pre>

<hr>
<h2 id='threeStage'>Denoising, deblurring and edge-preserving</h2><span id='topic+threeStage'></span>

<h3>Description</h3>

<p> Estimate surface using local smoothing
and fitting principal component line. Bandwidth is
specified by user.</p>


<h3>Usage</h3>

<pre><code class='language-R'>threeStage(image, bandwidth, edge1, edge2, 
blur = FALSE, plot = FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="threeStage_+3A_image">image</code></td>
<td>
<p>A square matrix object of size n by n, no missing
value allowed.</p>
</td></tr>
<tr><td><code id="threeStage_+3A_bandwidth">bandwidth</code></td>
<td>
<p>A positive integer that specifies the number of
pixels used in the local smoothing.</p>
</td></tr>
<tr><td><code id="threeStage_+3A_edge1">edge1</code></td>
<td>
<p>A matrix of 0 and 1 of the same size as
image represents detected step edge pixels</p>
</td></tr>
<tr><td><code id="threeStage_+3A_edge2">edge2</code></td>
<td>
<p>A matrix of 0 and 1 of the same size as
image represents detected roof/valley edge pixels</p>
</td></tr>
<tr><td><code id="threeStage_+3A_blur">blur</code></td>
<td>
<p>If blur = TRUE, besides a conventional 2-D kernel
function, a univariate increasing kernel function is used in
the local kernel smoothing to address the issue with blur.</p>
</td></tr>
<tr><td><code id="threeStage_+3A_plot">plot</code></td>
<td>
<p> If plot = TRUE, the image of the fitted surface is
plotted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At each pixel, if there are step edges detected in the local neighborhood, a principal
component line is fitted through the detected edge pixels to approximate
the step edge locally and then the regression surface is estimated
by a local constant kernel smoothing procedure using only the pixels
on one side of the principal component line. If there are no step edges
but roof/valley edges detected in the local neighborhood, the same
procedure is followed except that the principal component line to fitted
through the detected roof/valley edge pixels. In cases when there is
either no step edges or roof/valley edges detected in the neighborhood,
the regression surface at the pixel is estimated by the conventional
local linear kernel smoothing procedure.
</p>


<h3>Value</h3>

<p>Returns the restored image, which is represented by
a matrix</p>


<h3>References</h3>

<p>Qiu, P., and Kang, Y. &quot;Blind Image Deblurring Using Jump Regression
Analysis,&quot; <em>Statistica Sinica</em>, <b>25</b>, 2015, 879-899.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+JPLLK_surface">JPLLK_surface</a></code>, <code><a href="#topic+surfaceCluster">surfaceCluster</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sar)
stepEdge &lt;- stepEdgeLCK(sar, bandwidth=4, thresh=20)
stepEdge1 &lt;- modify2(bandwidth=4, stepEdge)
fit &lt;- threeStage(image=sar, bandwidth=4, edge1=stepEdge1, edge2=array(0, rep(ncol(sar), 2)))
</code></pre>

<hr>
<h2 id='threeStageParSel'>image denoising/deblurring, bandwidth selection, bootstrap</h2><span id='topic+threeStageParSel'></span>

<h3>Description</h3>

<p>Select the bandwidth value for the image restoration method
implemented in the function threeStage</p>


<h3>Usage</h3>

<pre><code class='language-R'>threeStageParSel(image, bandwidth, edge1, edge2, nboot, blur=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="threeStageParSel_+3A_image">image</code></td>
<td>
<p>A square matrix object of size n by n, no
missing value allowed.</p>
</td></tr>
<tr><td><code id="threeStageParSel_+3A_bandwidth">bandwidth</code></td>
<td>
<p>Bandwidth values to be chosen from. Each of these values need to
be an positive integer which specifies the number of pixels used in the local smoothing.</p>
</td></tr>
<tr><td><code id="threeStageParSel_+3A_edge1">edge1</code></td>
<td>
<p>A matrix of 0 and 1 of the same size as
image represents detected step edge pixels.</p>
</td></tr>
<tr><td><code id="threeStageParSel_+3A_edge2">edge2</code></td>
<td>
<p>A matrix of 0 and 1 of the same size as
image represents detected roof/valley edge pixels.</p>
</td></tr>
<tr><td><code id="threeStageParSel_+3A_nboot">nboot</code></td>
<td>
<p>Required when blur is TRUE. Unused when blur is FALSE. An positive integer to specify the number of bootstraps to perform. See Qiu and Kang (2015) Statistica Sinica for details.</p>
</td></tr>
<tr><td><code id="threeStageParSel_+3A_blur">blur</code></td>
<td>
<p>TRUE if the image contains blur, FALSE otherwise. If TRUE, the hybrid selection method proposed in Qiu and Kang (2015) Statistica Sinica is used. If FALSE, the leave-one-out cross validation is used.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>Returns a list of the selected bandwdith, and a matrix of CV values with each entry corresponding to each choice of bandwdith.</p>


<h3>References</h3>

<p>Qiu, P., and Kang, Y. &quot;Blind Image Deblurring Using Jump Regression
Analysis,&quot; <em>Statistica Sinica</em>, <b>25</b>, 2015, 879-899.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(peppers) # Peppers image is bundled with the package and it is a
          # standard test image in image processing literature.
# Not Run
#step.edges &lt;- stepEdgeLLK(peppers, 9, 17) # Step edge detection
#roof.edges &lt;- roofEdge(peppers, 6, 3000, edge1=step.edges) # Roof edge detection
#set.seed(24)
#parSel &lt;- threeStageParSel(image = peppers, edge1 = step.edges, edge2 = roof.edges,
#bandwidth = 4, nboot = 1, blur = TRUE) # Time consuming
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
