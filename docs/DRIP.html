<!DOCTYPE html><html lang="en"><head><title>Help for package DRIP</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DRIP}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#brain'><p>Brain Image</p></a></li>
<li><a href='#circles'><p>Image of Circles</p></a></li>
<li><a href='#cv.jpex'><p>Bandwidth Selection and Noise Level Estimation</p></a></li>
<li><a href='#dKQ'><p>Performance Measure of Edge Detector</p></a></li>
<li><a href='#jpex'><p>Blind Image Deblurring</p></a></li>
<li><a href='#JPLLK_surface'><p>Jump-Preserving Local Linear Kernel Smoothing</p></a></li>
<li><a href='#kid'><p>Image of a Kid</p></a></li>
<li><a href='#lena'><p>Lena Image</p></a></li>
<li><a href='#modify1'><p>Type-1 Modification Procedure</p></a></li>
<li><a href='#modify2'><p>Type-2 Modification Procedure</p></a></li>
<li><a href='#peppers'><p>Image of Peppers</p></a></li>
<li><a href='#plot.JPEX_Parameters'><p>Plot Parameter Selection Results in JPEX Deblurring</p></a></li>
<li><a href='#plot.JPLLK_Parameters'><p>Plot the Residual Image from a JPLLK Estimation</p></a></li>
<li><a href='#plot.Surface_Cluster_Parameters'><p>Plot Parameter Selection Results in Surface Estimation</p></a></li>
<li><a href='#plot.Three_Stage_Parameters'><p>Plot Parameter Selection Results in 3-Stage Estimation</p></a></li>
<li><a href='#print.Edge_Parameters'><p>Print Parameter Selection Results in Edge Detection</p></a></li>
<li><a href='#print.JPEX_Parameters'><p>Print Parameter Selection Results in JPEX Deblurring</p></a></li>
<li><a href='#print.JPLLK_Parameters'><p>Print Parameter Selection Results in JPLLK Estimation</p></a></li>
<li><a href='#print.Surface_Cluster_Parameters'><p>Print Parameter Selection Results in Surface Estimation</p></a></li>
<li><a href='#print.Three_Stage_Parameters'><p>Print Parameter Selection Results in 3-Stage Estimation</p></a></li>
<li><a href='#roofDiff'><p>Roof Edge Detection Statistics</p></a></li>
<li><a href='#roofEdge'><p>Roof Edge Detector</p></a></li>
<li><a href='#roofEdgeParSel'><p>Parameter Selection in Roof Edge Detection</p></a></li>
<li><a href='#sar'><p>Synthetic Aperture Radar Image</p></a></li>
<li><a href='#stepDiff'><p>Step Edge Detection Statistics</p></a></li>
<li><a href='#stepEdge'><p>Step Edge Detector</p></a></li>
<li><a href='#stepEdgeParSel'><p>Parameter Selection in Step Edge Detection</p></a></li>
<li><a href='#stopsign'><p>Stop Sign Image</p></a></li>
<li><a href='#summary.Edge_Parameters'><p>Summarize Parameter Selection Results in Edge Detection</p></a></li>
<li><a href='#summary.JPEX_Parameters'><p>Summarize Parameter Selection Results in JPEX Deblurring</p></a></li>
<li><a href='#summary.JPLLK_Parameters'><p>Summarize Parameter Selection Results in JPLLK Estimation</p></a></li>
<li><a href='#summary.Surface_Cluster_Parameters'><p>Summarize Parameter Selection Results in Surface Estimation</p></a></li>
<li><a href='#summary.Three_Stage_Parameters'><p>Summarize Parameter Selection Results in 3-Stage Estimation</p></a></li>
<li><a href='#surfaceCluster'><p>Jump-Preserving Surface Estimation Using Pixel Clustering</p></a></li>
<li><a href='#surfaceCluster_bandwidth'><p>Bandwidth Selection for Clustering-Based Surface Estimation</p></a></li>
<li><a href='#threeStage'><p>Three-Stage Denoising and Deblurring</p></a></li>
<li><a href='#threeStageParSel'><p>Parameter Selection in Three-Stage Image Restoration</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Version:</td>
<td>2.3</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of functions that perform jump regression
	     and image analysis such as denoising, deblurring and
	     jump detection. The implemented methods are based on
	     the following research: Qiu, P. (1998) &lt;<a href="https://doi.org/10.1214%2Faos%2F1024691468">doi:10.1214/aos/1024691468</a>&gt;,
	     Qiu, P. and Yandell, B. (1997) &lt;<a href="https://doi.org/10.1080%2F10618600.1997.10474746">doi:10.1080/10618600.1997.10474746</a>&gt;,
	     Qiu, P. (2009) &lt;<a href="https://doi.org/10.1007%2Fs10463-007-0166-9">doi:10.1007/s10463-007-0166-9</a>&gt;,
	     Kang, Y. and Qiu, P. (2014) &lt;<a href="https://doi.org/10.1080%2F00401706.2013.844732">doi:10.1080/00401706.2013.844732</a>&gt;,
	     Qiu, P. and Kang, Y. (2015) &lt;<a href="https://doi.org/10.5705%2Fss.2014.054">doi:10.5705/ss.2014.054</a>&gt;,
	     Kang, Y., Mukherjee, P.S. and Qiu, P. (2018) &lt;<a href="https://doi.org/10.1080%2F00401706.2017.1415975">doi:10.1080/00401706.2017.1415975</a>&gt;,
	     Kang, Y. (2020) &lt;<a href="https://doi.org/10.1080%2F10618600.2019.1665536">doi:10.1080/10618600.2019.1665536</a>&gt;.</td>
</tr>
<tr>
<td>Title:</td>
<td>Discontinuous Regression and Image Processing</td>
</tr>
<tr>
<td>Author:</td>
<td>Yicheng Kang [aut, cre],
  Peihua Qiu [aut, ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yicheng Kang &lt;kangyicheng0527@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel, graphics, stats</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://miamioh.edu/fsb/directory/?up=/directory/kangy10">https://miamioh.edu/fsb/directory/?up=/directory/kangy10</a>,
<a href="https://github.com/kangy10/DRIP">https://github.com/kangy10/DRIP</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/kangy10/DRIP/issues">https://github.com/kangy10/DRIP/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-20 17:06:20 UTC; yicheng</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-21 21:20:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='brain'>Brain Image</h2><span id='topic+brain'></span>

<h3>Description</h3>

<p>This file contains data of a brain image. It has
217x217 pixels. Gray levels are in the range [0, 255].
In the data file, observations are listed as a 217
x217 matrix. This image has blur involved.</p>


<h3>Usage</h3>

<pre><code class='language-R'>brain</code></pre>


<h3>Format</h3>

<p>A matrix containing 217x217 pixels.</p>


<h3>Author(s)</h3>

<p>Yicheng Kang</p>


<h3>References</h3>

<p>Kang, Y., Mukherjee, P.S. and Qiu, P. (2018) &ldquo;Efficient Blind
Image Deblurring Using Nonparametric Regression and Local
Pixel Clustering&rdquo;, <em>Technometrics</em>, <b>60</b>(4),
522 &ndash; 531, <a href="https://doi.org/10.1080/00401706.2017.1415975">doi:10.1080/00401706.2017.1415975</a>.
</p>

<hr>
<h2 id='circles'>Image of Circles</h2><span id='topic+circles'></span>

<h3>Description</h3>

<p>This file contains the circles image. It has 256x256 pixels.
Gray levels are in the range [0, 255]. In the data file,
observations are listed as a 256x256 matrix.</p>


<h3>Usage</h3>

<pre><code class='language-R'>circles</code></pre>


<h3>Format</h3>

<p>A matrix of 256x256 pixels.</p>


<h3>Author(s)</h3>

<p>Yicheng Kang</p>


<h3>References</h3>

<p>Qiu, P. (2005) <em>Image Processing and Jump Regression
Analysis</em>. New Jersey: Wiley.
</p>

<hr>
<h2 id='cv.jpex'>Bandwidth Selection and Noise Level Estimation</h2><span id='topic+cv.jpex'></span>

<h3>Description</h3>

<p>Select the leave-one-out cross validation bandwidth for local
linear kernel smoothing and estimates the noise level in the
input image. Both the bandwidth parameter and the noise level
are required inputs for the blind image deblurring procedure
<code>jpex</code>.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.jpex(image, bandwidths, ncpus = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cv.jpex_+3A_image">image</code></td>
<td>
<p>A blurry input image.</p>
</td></tr>
<tr><td><code id="cv.jpex_+3A_bandwidths">bandwidths</code></td>
<td>
<p>A vector of positive integers that specify the
size  of the neighborhood for local smoothing.</p>
</td></tr>
<tr><td><code id="cv.jpex_+3A_ncpus">ncpus</code></td>
<td>
<p>The number of CPUs allocated for parallel computing.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>LLK</code></td>
<td>
<p>The estimated surface by local linear kernel (LLK)
smoothing, using the CV selected bandwidth.</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>The estimated noise level, defined as the square root
of the mean squared error (MSE) between LLK and the input image.</p>
</td></tr>
<tr><td><code>cv_scores</code></td>
<td>
<p>A vector of the same length as that of the input bandwidths.
Each element in the vector is the leave-one-out CV score associated
with the corresponding bandwidth value.</p>
</td></tr>
<tr><td><code>input</code></td>
<td>
<p>The bandwidth parameters input by user.</p>
</td></tr>
<tr><td><code>bandwidth</code></td>
<td>
<p>The bandwidth parameter that results in the smallest
CV score.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yicheng Kang</p>


<h3>References</h3>

<p>Kang, Y. (2020) &ldquo;Consistent Blind Image Deblurring Using
Jump-Preserving Extrapolation&rdquo;, <em>Journal of Computational and
Graphical Statistics</em>, <b>29</b>(2), 372 &ndash; 382,
<a href="https://doi.org/10.1080/10618600.2019.1665536">doi:10.1080/10618600.2019.1665536</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jpex">jpex</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- cv.jpex(stopsign, c(2,3))
</code></pre>

<hr>
<h2 id='dKQ'>Performance Measure of Edge Detector</h2><span id='topic+dKQ'></span>

<h3>Description</h3>

<p>Compute the dissimilarity measure between two sets of edge pixels.
It is used as a performance measure for step or roof edge  detectors.</p>


<h3>Usage</h3>

<pre><code class='language-R'>dKQ(edge1, edge2)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dKQ_+3A_edge1">edge1</code></td>
<td>
<p>One set of pixels.</p>
</td></tr>
<tr><td><code id="dKQ_+3A_edge2">edge2</code></td>
<td>
<p>The other set of pixels.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mathematical definition of <code class="reqn">d_{KQ}</code> is as follows.
<code class="reqn">d_{KQ}(S_1, S_2) = \frac{0.5}{|S_1|}\sum_{p_1\in S_1} d_E(p_1, S_2) +
    \frac{0.5}{|S_2|}\sum_{p_2\in S_2} d_E(p_2, S_1)</code>, where <code class="reqn">S_1</code> and <code class="reqn">S_2</code>
are two point sets, and <code class="reqn">d_E</code> denotes the Euclidean distance.
</p>


<h3>Value</h3>

<p>Value of the <code class="reqn">d_{KQ}</code></p>


<h3>Author(s)</h3>

<p>Yicheng Kang</p>


<h3>References</h3>

<p>Kang, Y. and Qiu, P., &quot;Jump Detection in Blurred Regression 
Surfaces,&quot; <em>Technometrics</em>, <b>56</b>, 2014, 539-550,
<a href="https://doi.org/10.1080/00401706.2013.844732">doi:10.1080/00401706.2013.844732</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat1 &lt;- matrix(c(1, rep(0, 3)), ncol = 2)
mat2 &lt;- matrix(c(rep(0, 3), 1), ncol = 2)
dKQ(mat1, mat2)
</code></pre>

<hr>
<h2 id='jpex'>Blind Image Deblurring</h2><span id='topic+jpex'></span>

<h3>Description</h3>

<p>Take in any square matrix (noisy blurry image) and deblur it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jpex(image, bandwidth, alpha, sigma)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jpex_+3A_image">image</code></td>
<td>
<p>A square matrix representing a blurry image.</p>
</td></tr>
<tr><td><code id="jpex_+3A_bandwidth">bandwidth</code></td>
<td>
<p>A positive integer that specifies the size of
the neighborhood for local smoothing.</p>
</td></tr>
<tr><td><code id="jpex_+3A_alpha">alpha</code></td>
<td>
<p>A numeric between 0 and 1. This is the significance
level for the Chi-square hypothesis test. The null hypothesis
is that a given pixel is in a continuity region and not affected
by the blur.</p>
</td></tr>
<tr><td><code id="jpex_+3A_sigma">sigma</code></td>
<td>
<p>A positive numeric value for the noise level in
the blurred image. It is used in the Chi-square test.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>deblurred</code></td>
<td>
<p>A square matrix representing the deblurred
image.</p>
</td></tr>
<tr><td><code>edge</code></td>
<td>
<p>A square matrix, the element of which is the value
of the Chi-square test statistic at a pixel location. One can
classify a given pixel as a blurry pixel if
<code>edge[i, j] &gt; qchisq(1 - alpha, 2)</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yicheng Kang</p>


<h3>References</h3>

<p>Kang, Y. (2020) &ldquo;Consistent Blind Image Deblurring Using
Jump-Preserving Extrapolation&rdquo;, <em>Journal of Computational and
Graphical Statistics</em>, <b>29</b>(2), 372 &ndash; 382,
<a href="https://doi.org/10.1080/10618600.2019.1665536">doi:10.1080/10618600.2019.1665536</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.jpex">cv.jpex</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>out &lt;- jpex(image = stopsign, bandwidth = as.integer(2), sigma =
0.00623, alpha = 0.001)
</code></pre>

<hr>
<h2 id='JPLLK_surface'>Jump-Preserving Local Linear Kernel Smoothing</h2><span id='topic+JPLLK_surface'></span>

<h3>Description</h3>

<p>Estimate surface using piecewise local linear kernel smoothing.
The bandwidth is chosen by leave-one-out cross validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>JPLLK_surface(image, bandwidth, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="JPLLK_surface_+3A_image">image</code></td>
<td>
<p>A square matrix, no missing value allowed.</p>
</td></tr>
<tr><td><code id="JPLLK_surface_+3A_bandwidth">bandwidth</code></td>
<td>
<p>A numeric vector of positive integers, which
specifies the number of pixels used in the local smoothing. The 
final fitted surface uses the optimal bandwidth chosen from
those provided by users.</p>
</td></tr>
<tr><td><code id="JPLLK_surface_+3A_plot">plot</code></td>
<td>
<p>If plot = TRUE, the image of the fitted surface is
plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At each pixel, the gradient is estimated by a local linear
kernel smoothing procedure. Next, the local neighborhood is
divided into two halves along the direction perpendicular to
(<code class="reqn">\widehat{f}'_{x}</code>, <code class="reqn">\widehat{f}'_{y}</code>). Then the one-
sided local linear kernel (LLK) estimates are obtained in the
two half neighborhoods respectively. Among these two one-sided
estimates, the one with smaller weighted mean square error is
chosen to be the final estimate of the regression surface at the
pixel.
</p>


<h3>Value</h3>

<p>A list of fitted values, residuals, chosen bandwidth and
estimated sigma.
</p>


<h3>Author(s)</h3>

<p>Yicheng Kang</p>


<h3>References</h3>

<p>Qiu, P. (2009) &quot;Jump-Preserving Surface Reconstruction from Noisy Data&quot;,
<em>Annals of the Institute of Statistical Mathematics</em>, <b>61</b>(3),
715 &ndash; 751, <a href="https://doi.org/10.1007/s10463-007-0166-9">doi:10.1007/s10463-007-0166-9</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+threeStage">threeStage</a></code>, <code><a href="#topic+surfaceCluster">surfaceCluster</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- JPLLK_surface(image = sar, bandwidth = c(3, 4))
</code></pre>

<hr>
<h2 id='kid'>Image of a Kid</h2><span id='topic+kid'></span>

<h3>Description</h3>

<p>This file contains the kid image. The image has 387x387
pixels. Gray levels are in the range [0, 255]. In the data
file, observations are listed as a 387x387 matrix. This image
has spatially variant blur involved.</p>


<h3>Usage</h3>

<pre><code class='language-R'>kid</code></pre>


<h3>Format</h3>

<p>A matrix of 387x387 pixels.</p>


<h3>Author(s)</h3>

<p>Yicheng Kang</p>


<h3>References</h3>

<p>Kang, Y. and Qiu, P. (2014) &quot;Jump Detection in Blurred 
Regression Surfaces,&quot; <em>Technometrics</em>, <b>56</b>(4),
539 &ndash; 550, <a href="https://doi.org/10.1080/00401706.2013.844732">doi:10.1080/00401706.2013.844732</a>.
</p>

<hr>
<h2 id='lena'>Lena Image</h2><span id='topic+lena'></span>

<h3>Description</h3>

<p>This file contains the Lena image. It has 512x512 pixels. Gray
levels are in the range [0, 255]. In the data file, observations
are listed as a 512x512 matrix.</p>


<h3>Usage</h3>

<pre><code class='language-R'>lena</code></pre>


<h3>Format</h3>

<p>A 512x512 matrix.</p>


<h3>Author(s)</h3>

<p>Yicheng Kang</p>


<h3>Source</h3>

<p> November 1972 issue of Playboy magazine.</p>

<hr>
<h2 id='modify1'>Type-1 Modification Procedure</h2><span id='topic+modify1'></span>

<h3>Description</h3>

<p>Modify detected edges to make them thin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modify1(bandwidth, image, edge, plot)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modify1_+3A_image">image</code></td>
<td>
<p>A matrix that represents the image.</p>
</td></tr>
<tr><td><code id="modify1_+3A_bandwidth">bandwidth</code></td>
<td>
<p>A positive integer that specifies the number of
pixels to use in the local smoothing.</p>
</td></tr>
<tr><td><code id="modify1_+3A_edge">edge</code></td>
<td>
<p>A matrix of 0 and 1 represents detected edge 
pixels. </p>
</td></tr>
<tr><td><code id="modify1_+3A_plot">plot</code></td>
<td>
<p>If plot = TRUE, images of detected edges before
and after the modification are plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A local-smoothing based edge detection algorithm may flag deceptive edge
pixel candidates. One kind of such candidates consists of those close
to the real edges. They occur due to the nature of local
smoothing. That is, if the point <code class="reqn">(x_i, y_j)</code> is flagged,
then its neighboring pixels will be flagged with high probability.
This kind of deceptive candidates can make the detected edges
thick. This modification procedure makes the detected edges
thin.
</p>


<h3>Value</h3>

<p>A matrix of zeros and ones of the same size as the input image.
</p>


<h3>Author(s)</h3>

<p>Yicheng Kang</p>


<h3>References</h3>

<p>Qiu, P. and Yandell, B. (1997) &quot;Jump Detection in Regression Surfaces,&quot;
<em>Journal of Computational and Graphical Statistics</em> <b>6(3)</b>,
332-354, <a href="https://doi.org/10.1080/10618600.1997.10474746">doi:10.1080/10618600.1997.10474746</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modify2">modify2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>edge &lt;- stepEdge(sar, bandwidth = 4, thresh = 20, degree = 0)
out &lt;- modify1(4, sar, edge)
</code></pre>

<hr>
<h2 id='modify2'>Type-2 Modification Procedure</h2><span id='topic+modify2'></span>

<h3>Description</h3>

<p>Delete deceptive edge pixels that are scattered in the design space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modify2(bandwidth, edge, plot)</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modify2_+3A_bandwidth">bandwidth</code></td>
<td>
<p>A positive integer that specifies the number of
pixels to use in the local smoothing.</p>
</td></tr>
<tr><td><code id="modify2_+3A_edge">edge</code></td>
<td>
<p>A matrix of 0 and 1 representing the detected edge 
pixels.</p>
</td></tr>
<tr><td><code id="modify2_+3A_plot">plot</code></td>
<td>
<p>If plot = TRUE, images of the detected edges before
and after the modification are plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A local-smoothing based edge detection algorithm may flag deceptive edge
pixel candidates. One kind of such candidates existis due to the nature of hypothesis
testing, on which the threshold value of the edge detection criterion is
based. That is, a point <code class="reqn">(x_i, y_j)</code> could be flagged as a edge
pixel with certain probability, even if it is actually not a edge pixel.
Deceptive candidates of this kind are scattered in the whole design
space. This modification procedure deletes scattered edge pixel candidates.
</p>


<h3>Value</h3>

<p>A matrix of zeros and ones of the same size as the input image.
</p>


<h3>Author(s)</h3>

<p>Yicheng Kang</p>


<h3>References</h3>

<p>Qiu, P. and Yandell, B. (1997) &quot;Jump Detection in Regression Surfaces,&quot;
<em>Journal of Computational and Graphical Statistics</em> <b>6(3)</b>,
332-354, <a href="https://doi.org/10.1080/10618600.1997.10474746">doi:10.1080/10618600.1997.10474746</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modify1">modify1</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>edge &lt;- stepEdge(sar, bandwidth = 4, thresh = 20, degree = 0)
out &lt;- modify2(4, edge)
</code></pre>

<hr>
<h2 id='peppers'>Image of Peppers</h2><span id='topic+peppers'></span>

<h3>Description</h3>

<p>This file contains the peppers image. It has 512x512 pixels.
Gray levels are in the range [0, 255]. In the data file,
observations are  listed as a 512x512 matrix.</p>


<h3>Usage</h3>

<pre><code class='language-R'>peppers</code></pre>


<h3>Format</h3>

<p>A matrix of 512x512 pixels.</p>


<h3>Author(s)</h3>

<p>Yicheng Kang</p>


<h3>References</h3>

<p>Kang, Y. (2020) &ldquo;Consistent Blind Image Deblurring Using
Jump-Preserving Extrapolation&rdquo;, <em>Journal of Computational and
Graphical Statistics</em>, <b>29</b>(2), 372 &ndash; 382,
<a href="https://doi.org/10.1080/10618600.2019.1665536">doi:10.1080/10618600.2019.1665536</a>.
</p>

<hr>
<h2 id='plot.JPEX_Parameters'>Plot Parameter Selection Results in JPEX Deblurring</h2><span id='topic+plot.JPEX_Parameters'></span>

<h3>Description</h3>

<p>Plot the results of a JPEX parameter selection procedure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'JPEX_Parameters'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.JPEX_Parameters_+3A_x">x</code></td>
<td>
<p>A JPEX parameter selection object.</p>
</td></tr>
<tr><td><code id="plot.JPEX_Parameters_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plot the cross-validation scores against the bandwidth values.
</p>


<h3>Value</h3>

<p>A plot of cross-validation scores is produced. 
</p>


<h3>Author(s)</h3>

<p>Yicheng Kang</p>


<h3>References</h3>

<p>Kang, Y. (2020) &ldquo;Consistent Blind Image Deblurring Using
Jump-Preserving Extrapolation&rdquo;, <em>Journal of Computational and
Graphical Statistics</em>, <b>29</b>(2), 372 &ndash; 382,
<a href="https://doi.org/10.1080/10618600.2019.1665536">doi:10.1080/10618600.2019.1665536</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.jpex">cv.jpex</a></code>, <code><a href="#topic+print.JPEX_Parameters">print.JPEX_Parameters</a></code>,
<code><a href="#topic+summary.JPEX_Parameters">summary.JPEX_Parameters</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parSel &lt;- cv.jpex(stopsign, c(2,3))
plot(parSel)
</code></pre>

<hr>
<h2 id='plot.JPLLK_Parameters'>Plot the Residual Image from a JPLLK Estimation</h2><span id='topic+plot.JPLLK_Parameters'></span>

<h3>Description</h3>

<p>Plot the residual image from a JPLLK parameter selection object where
the bandwidth is chosen by cross validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'JPLLK_Parameters'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.JPLLK_Parameters_+3A_x">x</code></td>
<td>
<p>A JPLLK parameter selection object.</p>
</td></tr>
<tr><td><code id="plot.JPLLK_Parameters_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plot the residual image from a JPLLK parameter selection object.
The bandwidth used in producing the residual image is chosen by
cross validation. 
</p>


<h3>Value</h3>

<p>A residual image is produced. 
</p>


<h3>Author(s)</h3>

<p>Yicheng Kang</p>


<h3>References</h3>

<p>Qiu, P. (2009) &quot;Jump-Preserving Surface Reconstruction from Noisy Data&quot;,
<em>Annals of the Institute of Statistical Mathematics</em>, <b>61</b>(3),
715 &ndash; 751, <a href="https://doi.org/10.1007/s10463-007-0166-9">doi:10.1007/s10463-007-0166-9</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+JPLLK_surface">JPLLK_surface</a></code>, <code><a href="#topic+print.JPLLK_Parameters">print.JPLLK_Parameters</a></code>,
<code><a href="#topic+summary.JPLLK_Parameters">summary.JPLLK_Parameters</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- JPLLK_surface(image=sar, bandwidth=c(3, 4))
plot(fit)
</code></pre>

<hr>
<h2 id='plot.Surface_Cluster_Parameters'>Plot Parameter Selection Results in Surface Estimation</h2><span id='topic+plot.Surface_Cluster_Parameters'></span>

<h3>Description</h3>

<p>Plot information about a clustering-based surface estimation
parameter selection object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Surface_Cluster_Parameters'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.Surface_Cluster_Parameters_+3A_x">x</code></td>
<td>
<p>A clustering-based surface estimation parameter selection object.</p>
</td></tr>
<tr><td><code id="plot.Surface_Cluster_Parameters_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plot some information about a clustering-based surface estimation parameter
selection object. In particular, it plots the cross-validation (no blur) or modified
cross-validation (there is blur involved) scores against the specified bandwidth
values.
</p>


<h3>Value</h3>

<p>A plot of (modified) cross-validation scores is produced. 
</p>


<h3>Author(s)</h3>

<p>Yicheng Kang</p>


<h3>References</h3>

<p>Kang, Y., Mukherjee, P.S. and Qiu, P. (2018) &quot;Efficient Blind Image
Deblurring Using Nonparametric Regression and Local Pixel 
Clustering&quot;, <em>Technometrics</em>, <b>60</b>(4), 522 &ndash; 531,
<a href="https://doi.org/10.1080/00401706.2017.1415975">doi:10.1080/00401706.2017.1415975</a>.
</p>
<p>Qiu, P. (2009) &quot;Jump-Preserving Surface Reconstruction from Noisy 
Data&quot;, <em>Annals of the Institute of Statistical Mathematics</em>,
<b>61</b>, 715 &ndash; 751, <a href="https://doi.org/10.1007/s10463-007-0166-9">doi:10.1007/s10463-007-0166-9</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+surfaceCluster_bandwidth">surfaceCluster_bandwidth</a></code>, <code><a href="#topic+print.Surface_Cluster_Parameters">print.Surface_Cluster_Parameters</a></code>,
<code><a href="#topic+summary.Surface_Cluster_Parameters">summary.Surface_Cluster_Parameters</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(brain)
bandwidth_select &lt;- surfaceCluster_bandwidth(image = brain,
    bandwidths = c(3:4), sig.level = .9995, blur = FALSE)
plot(bandwidth_select)
</code></pre>

<hr>
<h2 id='plot.Three_Stage_Parameters'>Plot Parameter Selection Results in 3-Stage Estimation</h2><span id='topic+plot.Three_Stage_Parameters'></span>

<h3>Description</h3>

<p>Plot information about a 3-stage estimation bandwidth selection object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Three_Stage_Parameters'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.Three_Stage_Parameters_+3A_x">x</code></td>
<td>
<p>A three-stage estimation bandwidth selection object.</p>
</td></tr>
<tr><td><code id="plot.Three_Stage_Parameters_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It plots the cross-validation (no blur involved) or modified cross-validation
(there is blur involved) scores against the specified bandwidth values.
</p>


<h3>Value</h3>

<p>A plot of the (modified) cross-validation scores is produced. 
</p>


<h3>Author(s)</h3>

<p>Yicheng Kang</p>


<h3>References</h3>

<p>Qiu, P. and Kang, Y. (2015) &ldquo;Blind Image Deblurring Using Jump 
Regression Analysis&rdquo;, <em>Statistica Sinica</em>, <b>25</b>,
879 &ndash; 899, <a href="https://doi.org/10.5705/ss.2014.054">doi:10.5705/ss.2014.054</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+threeStageParSel">threeStageParSel</a></code>, <code><a href="#topic+print.Three_Stage_Parameters">print.Three_Stage_Parameters</a></code>,
<code><a href="#topic+summary.Three_Stage_Parameters">summary.Three_Stage_Parameters</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
step.edges &lt;- stepEdge(peppers, bandwidth = 9, thresh = 17) 
roof.edges &lt;- roofEdge(peppers, bandwidth = 6, thresh = 3000,
    edge1 = step.edges) 
set.seed(24)
# Time consuming
parSel &lt;- threeStageParSel(image = peppers, edge1 = step.edges,
    edge2 = roof.edges, bandwidth = 3:4, nboot = 1, blur = TRUE)
plot(parSel)

## End(Not run)
</code></pre>

<hr>
<h2 id='print.Edge_Parameters'>Print Parameter Selection Results in Edge Detection</h2><span id='topic+print.Edge_Parameters'></span>

<h3>Description</h3>

<p>Display information about an edge detection parameter selection object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Edge_Parameters'
print(x, type = "all", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.Edge_Parameters_+3A_x">x</code></td>
<td>
<p>An edge detection parameter selection object.</p>
</td></tr>
<tr><td><code id="print.Edge_Parameters_+3A_type">type</code></td>
<td>
<p>The type of information to display. The &quot;matrix&quot;
option prints the bootstrap version of <code>dKQ</code> values for each
combination of bandwidth and threshold. The &quot;parameters&quot;
option prints the selected bandwidth and threshold. The
&quot;all&quot; option prints all the information.</p>
</td></tr>
<tr><td><code id="print.Edge_Parameters_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints some information about an edge detection parameter
selection object. In particular, this method prints the <code class="reqn">d_{KQ}</code>
values based on bootstrap samples, the selected bandwidth and
threshold.
</p>


<h3>Value</h3>

<p>A display of parameter selection results in edge detection.
</p>


<h3>Author(s)</h3>

<p>Yicheng Kang</p>


<h3>References</h3>

<p>Kang, Y. and Qiu, P. (2014) &quot;Jump Detection in Blurred Regression
Surfaces,&quot; <em>Technometrics</em>, <b>56</b>(4), 539 &ndash; 550,
<a href="https://doi.org/10.1080/00401706.2013.844732">doi:10.1080/00401706.2013.844732</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stepEdgeParSel">stepEdgeParSel</a></code>, <code><a href="#topic+roofEdgeParSel">roofEdgeParSel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(24)
parSel &lt;- stepEdgeParSel(image = sar, bandwidth = 5,
thresh = c(17, 21), nboot = 1)
print(parSel, type = "all")
</code></pre>

<hr>
<h2 id='print.JPEX_Parameters'>Print Parameter Selection Results in JPEX Deblurring</h2><span id='topic+print.JPEX_Parameters'></span>

<h3>Description</h3>

<p>Display information about a JPEX parameter selection object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'JPEX_Parameters'
print(x, type = "all", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.JPEX_Parameters_+3A_x">x</code></td>
<td>
<p>A JPEX parameter selection object.</p>
</td></tr>
<tr><td><code id="print.JPEX_Parameters_+3A_type">type</code></td>
<td>
<p>The type of information to display. The &quot;cv_scores&quot;
option prints the cross-validation scores for each
bandwidth. The &quot;bandwidth&quot; option prints the selected bandwidth.
The &quot;sigma&quot; option prints the estimated noise level. The &quot;all&quot;
option prints all the information.</p>
</td></tr>
<tr><td><code id="print.JPEX_Parameters_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints some information about a JPEX parameter selection object.
In particular, this method prints the cross-validation scores,
the selected bandwidth and estimated noise level.
</p>


<h3>Value</h3>

<p>A display of parameter selection results in JPEX estimation.
</p>


<h3>Author(s)</h3>

<p>Yicheng Kang</p>


<h3>References</h3>

<p>Kang, Y. (2020) &ldquo;Consistent Blind Image Deblurring Using
Jump-Preserving Extrapolation&rdquo;, <em>Journal of Computational and
Graphical Statistics</em>, <b>29</b>(2), 372 &ndash; 382,
<a href="https://doi.org/10.1080/10618600.2019.1665536">doi:10.1080/10618600.2019.1665536</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.jpex">cv.jpex</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parSel &lt;- cv.jpex(stopsign, c(2,3))
print(parSel, type = "all")
</code></pre>

<hr>
<h2 id='print.JPLLK_Parameters'>Print Parameter Selection Results in JPLLK Estimation</h2><span id='topic+print.JPLLK_Parameters'></span>

<h3>Description</h3>

<p>Display information about a JPLLK parameter selection object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'JPLLK_Parameters'
print(x, type =  "all", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.JPLLK_Parameters_+3A_x">x</code></td>
<td>
<p>A JPLLK parameter selection object.</p>
</td></tr>
<tr><td><code id="print.JPLLK_Parameters_+3A_type">type</code></td>
<td>
<p>The type of information to display. The &quot;bandwidth&quot; option
prints the selected bandwidth. The &quot;sigma&quot; option prints the estimated
noise level. The &quot;all&quot; option prints all the information.</p>
</td></tr>
<tr><td><code id="print.JPLLK_Parameters_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints some information about a JPLLK parameter selection object.
In particular, this method prints the selected bandwidth and
estimated noise level.
</p>


<h3>Value</h3>

<p>A display of parameter selection results in JPLLK estimation.
</p>


<h3>Author(s)</h3>

<p>Yicheng Kang</p>


<h3>References</h3>

<p>Qiu, P. (2009) &quot;Jump-Preserving Surface Reconstruction from Noisy Data&quot;,
<em>Annals of the Institute of Statistical Mathematics</em>, <b>61</b>(3),
715 &ndash; 751, <a href="https://doi.org/10.1007/s10463-007-0166-9">doi:10.1007/s10463-007-0166-9</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+JPLLK_surface">JPLLK_surface</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- JPLLK_surface(image = sar, bandwidth = c(3, 4))
print(fit, type = "bandwidth")
</code></pre>

<hr>
<h2 id='print.Surface_Cluster_Parameters'>Print Parameter Selection Results in Surface Estimation</h2><span id='topic+print.Surface_Cluster_Parameters'></span>

<h3>Description</h3>

<p>Display information about a clustering-based surface estimation
parameter selection object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Surface_Cluster_Parameters'
print(x, type = "all", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.Surface_Cluster_Parameters_+3A_x">x</code></td>
<td>
<p>A clustering-based surface estimation parameter selection object.</p>
</td></tr>
<tr><td><code id="print.Surface_Cluster_Parameters_+3A_type">type</code></td>
<td>
<p>The type of information to display. The &quot;cv_scores&quot;
option prints the cross-validation or modified cross-validation scores
for each bandwidth. The &quot;sigma&quot; option prints the estimated noise level.
The &quot;phi0&quot; option prints the estimated value of the error density at 0.
The &quot;mean_std_abs&quot; option prints the estimated mean of absolute error.
The &quot;all&quot; option prints all the information.</p>
</td></tr>
<tr><td><code id="print.Surface_Cluster_Parameters_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints some information about a clustering-based surface estimation
parameter selection object. In particular, this method prints the cross-
validation or modified cross-validation scores, the selected bandwidth, the
estimated noise level, the estimated value of the  error density at 0 and
the estimated mean of absolute error.
</p>


<h3>Value</h3>

<p>A display of parameter selection results in clustering-based surface
estimation.
</p>


<h3>Author(s)</h3>

<p>Yicheng Kang</p>


<h3>References</h3>

<p>Kang, Y., Mukherjee, P.S. and Qiu, P. (2018) &quot;Efficient Blind Image
Deblurring Using Nonparametric Regression and Local Pixel
Clustering&quot;, <em>Technometrics</em>, <b>60</b>(4), 522 &ndash; 531,
<a href="https://doi.org/10.1080/00401706.2017.1415975">doi:10.1080/00401706.2017.1415975</a>.
</p>
<p>Qiu, P. (2009) &quot;Jump-Preserving Surface Reconstruction from Noisy
Data&quot;, <em>Annals of the Institute of Statistical Mathematics</em>,
<b>61</b>, 715 &ndash; 751, <a href="https://doi.org/10.1007/s10463-007-0166-9">doi:10.1007/s10463-007-0166-9</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+surfaceCluster_bandwidth">surfaceCluster_bandwidth</a></code>,
<code><a href="#topic+summary.Surface_Cluster_Parameters">summary.Surface_Cluster_Parameters</a></code>,
<code><a href="#topic+plot.Surface_Cluster_Parameters">plot.Surface_Cluster_Parameters</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(brain)
bandwidth_select &lt;- surfaceCluster_bandwidth(image = brain,
    bandwidths = c(3:4), sig.level = .9995, blur = FALSE)
print(bandwidth_select, type = "cv_scores")
</code></pre>

<hr>
<h2 id='print.Three_Stage_Parameters'>Print Parameter Selection Results in 3-Stage Estimation</h2><span id='topic+print.Three_Stage_Parameters'></span>

<h3>Description</h3>

<p>Display information about a three-stage estimation bandwidth selection object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Three_Stage_Parameters'
print(x, type = "all", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.Three_Stage_Parameters_+3A_x">x</code></td>
<td>
<p>A three-stage estimation bandwidth selection object.</p>
</td></tr>
<tr><td><code id="print.Three_Stage_Parameters_+3A_type">type</code></td>
<td>
<p>The type of information to display. The &quot;cv_scores&quot;
option prints the cross-validation or modified cross-validation
scores for each bandwidth. The &quot;bandwidth&quot; option prints the
selected the bandwidth. The &quot;all&quot; option prints all the information.</p>
</td></tr>
<tr><td><code id="print.Three_Stage_Parameters_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints some information about a three-stage estimation bandwidth
selection object. In particular, this method prints the
cross-validation or modified cross-validation scores and the
selected bandwidth.
</p>


<h3>Value</h3>

<p>Display (modified) cross-validation scores and the selected bandwidth.
</p>


<h3>Author(s)</h3>

<p>Yicheng Kang</p>


<h3>References</h3>

<p>Qiu, P. and Kang, Y. (2015) &ldquo;Blind Image Deblurring Using Jump
Regression Analysis&rdquo;, <em>Statistica Sinica</em>, <b>25</b>,
879 &ndash; 899, <a href="https://doi.org/10.5705/ss.2014.054">doi:10.5705/ss.2014.054</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+threeStageParSel">threeStageParSel</a></code>, <code><a href="#topic+summary.Three_Stage_Parameters">summary.Three_Stage_Parameters</a></code>,
<code><a href="#topic+plot.Three_Stage_Parameters">plot.Three_Stage_Parameters</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
step.edges &lt;- stepEdge(peppers, bandwidth = 9, thresh = 17)
roof.edges &lt;- roofEdge(peppers, bandwidth = 6, thresh = 3000,
    edge1 = step.edges)
set.seed(24)
# Time consuming
parSel &lt;- threeStageParSel(image = peppers, edge1 = step.edges,
    edge2 = roof.edges, bandwidth = 3:4, nboot = 1, blur = TRUE)
print(parSel, type = "all")

## End(Not run)
</code></pre>

<hr>
<h2 id='roofDiff'>Roof Edge Detection Statistics</h2><span id='topic+roofDiff'></span>

<h3>Description</h3>

<p>Compute the difference between two one-sided gradient estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>   roofDiff(image, bandwidth, blur)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="roofDiff_+3A_image">image</code></td>
<td>
<p>A square matrix, no missing value allowed.</p>
</td></tr>
<tr><td><code id="roofDiff_+3A_bandwidth">bandwidth</code></td>
<td>
<p>A positive integer that specifies the number of
pixels to use in the local smoothing.</p>
</td></tr>
<tr><td><code id="roofDiff_+3A_blur">blur</code></td>
<td>
<p>If blur = TRUE, besides the conventional 2-D kernel
function, a univariate kernel function is used to address
the issue of blur.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At each pixel, the second-order derivarives (i.e., <code class="reqn">f''_{xx}</code>,
<code class="reqn">f''_{xy}</code> and <code class="reqn">f''_{yy}</code>) are estimated by
a local quadratic kernel smoothing procedure. Next, the local
neighborhood is first divided into two halves along the direction
perpendicular to (<code class="reqn">\widehat{f}''_{xx}</code>, <code class="reqn">\widehat{f}''_{xy}</code>).
Then the one-sided estimates of <code class="reqn">f'_{x+}</code> and <code class="reqn">f'_{x-}</code>
are obtained	respectively by local linear kernel smoothing. The
estimates of	<code class="reqn">f'_{y+}</code> and <code class="reqn">f'_{y-}</code> are obtained by the
same procedure except that the neighborhood is divided along the
direction perpendicular to (<code class="reqn">\widehat{f}''_{xy}</code>,
<code class="reqn">\widehat{f}''_{yy}</code>).
</p>


<h3>Value</h3>

<p>A matrix where each entry is the maximum of the differences:
<code class="reqn">|\widehat{f}_{x+} - \widehat{f}_{x-}|</code> and  
<code class="reqn">|\widehat{f}_{y+} - \widehat{f}_{y-}|</code> at each pixel location.
</p>


<h3>Author(s)</h3>

<p>Yicheng Kang</p>


<h3>References</h3>

<p>Qiu, P. and Kang, Y. (2015) &quot;Blind Image Deblurring Using Jump Regression
Analysis&quot;, <em>Statistica Sinica</em>, <b>25</b>, 879 &ndash; 899,
<a href="https://doi.org/10.5705/ss.2014.054">doi:10.5705/ss.2014.054</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+roofEdgeParSel">roofEdgeParSel</a></code>, <code><a href="#topic+roofEdge">roofEdge</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>diff &lt;- roofDiff(image = peppers, bandwidth = 8)
</code></pre>

<hr>
<h2 id='roofEdge'>Roof Edge Detector</h2><span id='topic+roofEdge'></span>

<h3>Description</h3>

<p>Detect roof/valley edges in an image using piecewise local
quadratic kernel smoothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roofEdge(image, bandwidth, thresh, edge1, blur, plot)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="roofEdge_+3A_image">image</code></td>
<td>
<p>A square matrix, no missing value allowed.</p>
</td></tr>
<tr><td><code id="roofEdge_+3A_bandwidth">bandwidth</code></td>
<td>
<p>A positive integer that specifies the number
of pixels to use in the local smoothing.</p>
</td></tr>
<tr><td><code id="roofEdge_+3A_thresh">thresh</code></td>
<td>
<p>Threshold value to use in the edge detection
criterion.</p>
</td></tr>
<tr><td><code id="roofEdge_+3A_edge1">edge1</code></td>
<td>
<p>A square matrix representing the image's step
edges. The function excludes step edges when detects roof
edges.</p>
</td></tr>
<tr><td><code id="roofEdge_+3A_blur">blur</code></td>
<td>
<p>If blur = TRUE, besides the conventional 2-D
kernel function, a univariate kernel function is used
in the local smoothing to address the issue of blur.</p>
</td></tr>
<tr><td><code id="roofEdge_+3A_plot">plot</code></td>
<td>
<p>If plot = TRUE, an image of detected edges is
plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At each pixel, the second-order derivarives (i.e., <code class="reqn">f''_{xx}</code>,
<code class="reqn">f''_{xy}</code>, and <code class="reqn">f''_{yy}</code>) are estimated by a local
quadratic kernel smoothing procedure. Next, the local neighborhood
is first divided into two halves along the direction perpendicular
to (<code class="reqn">\widehat{f}''_{xx}</code>, <code class="reqn">\widehat{f}''_{xy}</code>). Then the
one-sided estimates of <code class="reqn">f'_{x+}</code> and <code class="reqn">f'_{x-}</code> are obtained
respectively by local linear kernel smoothing. The estimates of
<code class="reqn">f'_{y+}</code> and <code class="reqn">f'_{y-}</code> are obtained by the same procedure
except that the neighborhood is divided along the direction perpendicular
to (<code class="reqn">\widehat{f}''_{xy}</code>, <code class="reqn">\widehat{f}''_{yy}</code>). The pixel is
flagged as a roof/valley edge pixel if <code class="reqn">max(|\widehat{f}_{x+} -
    \widehat{f}_{x-}|,  |\widehat{f}_{y+} - \widehat{f}_{y-}|)&gt;</code> the
specified threshold and there is no step edge pixels in the neighborhood.
</p>


<h3>Value</h3>

<p>A matrix of zeros and ones of the same size as the input image.
</p>


<h3>Author(s)</h3>

<p>Yicheng Kang</p>


<h3>References</h3>

<p>Qiu, P. and Kang, Y. (2015) &ldquo;Blind Image Deblurring Using Jump 
Regression Analysis&rdquo;, <em>Statistica Sinica</em>, <b>25</b>,
879 &ndash; 899, <a href="https://doi.org/10.5705/ss.2014.054">doi:10.5705/ss.2014.054</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+roofEdgeParSel">roofEdgeParSel</a></code>, <code><a href="#topic+roofDiff">roofDiff</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
step.edges &lt;- stepEdge(peppers, bandwidth = 6, thresh = 25, degree = 1)
roof.edges &lt;- roofEdge(image = peppers, bandwidth = 9, thresh = 3000,
    edge1 = step.edges, blur = FALSE, plot = FALSE) # Time consuming
edges &lt;- step.edges + roof.edges     
par(mfrow = c(2, 2))
image(1 - step.edges, col = gray(0:1))
image(1 - roof.edges, col = gray(0:1))
image(1 - edges, col = gray(0:1))
image(peppers, col = gray(c(0:255)/255))

## End(Not run)
</code></pre>

<hr>
<h2 id='roofEdgeParSel'>Parameter Selection in Roof Edge Detection</h2><span id='topic+roofEdgeParSel'></span>

<h3>Description</h3>

<p>Select bandwidth and threshold value for the roof/valley edge detector
using bootstrap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roofEdgeParSel(image, bandwidth, thresh, nboot, edge1, blur = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="roofEdgeParSel_+3A_image">image</code></td>
<td>
<p>A square matrix object of size n by n, no
missing value allowed.</p>
</td></tr>
<tr><td><code id="roofEdgeParSel_+3A_bandwidth">bandwidth</code></td>
<td>
<p>Positive integers to specify the number of
pixels used in the local smoothing. These are the bandwidth parameters
to be chosen from.</p>
</td></tr>
<tr><td><code id="roofEdgeParSel_+3A_thresh">thresh</code></td>
<td>
<p>Threshold values to be chosen from.</p>
</td></tr>
<tr><td><code id="roofEdgeParSel_+3A_nboot">nboot</code></td>
<td>
<p>Number of bootstrap samples.</p>
</td></tr>
<tr><td><code id="roofEdgeParSel_+3A_edge1">edge1</code></td>
<td>
<p>Step edges. The function excludes step edges when detect
roof/valley edges.</p>
</td></tr>
<tr><td><code id="roofEdgeParSel_+3A_blur">blur</code></td>
<td>
<p>TRUE if the image contains blur, FALSE otherwise.</p>
</td></tr> 
</table>


<h3>Details</h3>

<p>If <em>blur=TRUE</em>, then a conventional local linear kernel smoothing is
applied to estimate the blurred surface; Bootstrap samples are obtained by
drawing with replacement from the residuals and the <code class="reqn">d_{KQ}</code> is computed
for the detected edges of the original sample and those of the bootstrap
samples. If <em>blur=FALSE</em>, the procedure is the same as when <em>blur=TRUE</em>
except that a jump-preserving kernel smoothing procedure is used to obtain
residuals.
</p>


<h3>Value</h3>

<p>Returns a list of the selected bandwdith, the selected threshold value,
and a matrix of <code class="reqn">d_{KQ}</code> values with each entry corresponding to each combination
of bandwdith and threshold.</p>


<h3>Author(s)</h3>

<p>Yicheng Kang</p>


<h3>References</h3>

<p>Qiu, P. and Kang, Y. (2015) &ldquo;Blind Image Deblurring Using Jump Regression
Analysis&rdquo;, <em>Statistica Sinica</em>, <b>25</b>, 879-899,
<a href="https://doi.org/10.5705/ss.2014.054">doi:10.5705/ss.2014.054</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+roofDiff">roofDiff</a></code>, <code><a href="#topic+roofEdge">roofEdge</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
step.edges &lt;- stepEdge(peppers, bandwidth = 9, thresh = 17)
set.seed(24)
parSel &lt;- roofEdgeParSel(image = peppers, bandwidth = 5, thresh = 5000,
    nboot = 1, edge1 = step.edges, blur = TRUE) # Time Consuming

## End(Not run)
</code></pre>

<hr>
<h2 id='sar'>Synthetic Aperture Radar Image</h2><span id='topic+sar'></span>

<h3>Description</h3>

<p>This file contains the synthetic aperture radar (SAR) image
of an area near Thetford forest, England. The image has
250x250 pixels. Gray levels are in the range [0, 255]. In the
data file, observations are listed as a 250x250 matrix. This
image is noisy.</p>


<h3>Usage</h3>

<pre><code class='language-R'>sar</code></pre>


<h3>Format</h3>

<p>A matrix of 250x250 pixels.</p>


<h3>Author(s)</h3>

<p>Yicheng Kang</p>


<h3>Source</h3>

<p><a href="https://users.phhp.ufl.edu/pqiu/research/book/data/index.html">https://users.phhp.ufl.edu/pqiu/research/book/data/index.html</a></p>


<h3>References</h3>

<p>Qiu, P. (2005) <em>Image Processing and Jump Regression
Analysis</em>. New Jersey: Wiley.
</p>

<hr>
<h2 id='stepDiff'>Step Edge Detection Statistics</h2><span id='topic+stepDiff'></span>

<h3>Description</h3>

<p>Compute difference between two one-sided local kernel
estimates along the gradient direction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepDiff(image, bandwidth, degree = 1, blur = FALSE, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stepDiff_+3A_image">image</code></td>
<td>
<p>A square matrix, no missing value allowed.</p>
</td></tr>
<tr><td><code id="stepDiff_+3A_bandwidth">bandwidth</code></td>
<td>
<p>A positive integer that specifies the number of
pixels to use in the local smoothing.</p>
</td></tr>
<tr><td><code id="stepDiff_+3A_degree">degree</code></td>
<td>
<p>An integer equal to 0 for local constant kernel
smoothing or 1 for local linear kernel smoothing. The default
value is 1.</p>
</td></tr>
<tr><td><code id="stepDiff_+3A_blur">blur</code></td>
<td>
<p>If blur = TRUE, in addition to a conventional 2-D kernel
function, a 1-D kernel is used in local smoothing to address
the issue of blur. The default value is FALSE.</p>
</td></tr>
<tr><td><code id="stepDiff_+3A_plot">plot</code></td>
<td>
<p>If plot = TRUE, an image of the detection statistics at
each pixel is plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At each pixel, the gradient is estimated by a local linear
kernel smoothing procedure. Next, the local neighborhood is
divided into two halves along the direction perpendicular to
(<code class="reqn">\widehat{f}'_{x}</code>, <code class="reqn">\widehat{f}'_{y}</code>). Then the one-
sided local kernel estimates are obtained in the two half
neighborhoods respectively.
</p>


<h3>Value</h3>

<p>A matrix of the estimated difference, <code class="reqn">|\widehat{f}_+ - \widehat{f}_-|</code>,
at each pixel.</p>


<h3>Author(s)</h3>

<p>Yicheng Kang</p>


<h3>References</h3>

<p>Kang, Y. and Qiu, P. (2014) &quot;Jump Detection in Blurred Regression 
Surfaces,&quot; <em>Technometrics</em>, <b>56</b>(4), 539 &ndash; 550,
<a href="https://doi.org/10.1080/00401706.2013.844732">doi:10.1080/00401706.2013.844732</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+roofDiff">roofDiff</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>diff &lt;- stepDiff(image = sar, bandwidth = 4, degree = 0)
</code></pre>

<hr>
<h2 id='stepEdge'>Step Edge Detector</h2><span id='topic+stepEdge'></span>

<h3>Description</h3>

<p>Detect step edges in an image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepEdge(image, bandwidth, thresh, degree = 1, blur = FALSE,
plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stepEdge_+3A_image">image</code></td>
<td>
<p>A square matrix, no missing value allowed.</p>
</td></tr>
<tr><td><code id="stepEdge_+3A_bandwidth">bandwidth</code></td>
<td>
<p>A positive integer that specifies the number of
pixels to use in the local smoothing.</p>
</td></tr>
<tr><td><code id="stepEdge_+3A_thresh">thresh</code></td>
<td>
<p>The threshold value to use in the edge detection
criterion. Must be a positive value.</p>
</td></tr>
<tr><td><code id="stepEdge_+3A_degree">degree</code></td>
<td>
<p>An integer equal to 0 for local constant kernel
smoothing or 1 for local linear kernel smoothing. The default
value is 1.</p>
</td></tr>
<tr><td><code id="stepEdge_+3A_blur">blur</code></td>
<td>
<p>If blur = TRUE, in addition to a conventional 2-D kernel
function, a 1-D kernel is used in local smoothing to address
the issue of blur. The default value is FALSE.</p>
</td></tr>
<tr><td><code id="stepEdge_+3A_plot">plot</code></td>
<td>
<p>If plot = TRUE, an image of the detected edges is
plotted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At each pixel, the gradient is estimated by a local	kernel
smoothing procedure. Next, the local neighborhood is divided
into two halves along the direction perpendicular to
(<code class="reqn">\widehat{f}'_{x}</code>, <code class="reqn">\widehat{f}'_{y}</code>). Then the
one-sided local kernel estimates are obtained in the two half
neighborhoods respectively. The pixel is flagged as	a step
edge pixel if <code class="reqn">|\widehat{f}_+ - \widehat{f}_-|&gt;u</code>, where
<code class="reqn">u</code> is the specified threshold value.
</p>


<h3>Value</h3>

<p>A matrix of zeros and ones. Ones represent the detected edge
pixels and zeros represent the non-edge pixels.
</p>


<h3>Author(s)</h3>

<p>Yicheng Kang</p>


<h3>References</h3>

<p>Kang, Y. and Qiu, P. (2014) &quot;Jump Detection in Blurred Regression 
Surfaces,&quot; <em>Technometrics</em>, <b>56</b>(4), 539 &ndash; 550,
<a href="https://doi.org/10.1080/00401706.2013.844732">doi:10.1080/00401706.2013.844732</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+roofDiff">roofDiff</a></code>, <code><a href="#topic+stepDiff">stepDiff</a></code>, <code><a href="#topic+roofEdge">roofEdge</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sar) 
edges &lt;- stepEdge(image = sar, bandwidth = 4, degree = 0,
thresh = 16)
</code></pre>

<hr>
<h2 id='stepEdgeParSel'>Parameter Selection in Step Edge Detection</h2><span id='topic+stepEdgeParSel'></span>

<h3>Description</h3>

<p>Select the bandwidth and threshold parameters for step edge
detection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepEdgeParSel(image, bandwidth, thresh, nboot, degree = 1,
blur = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stepEdgeParSel_+3A_image">image</code></td>
<td>
<p>A square matrix, no missing value allowed.</p>
</td></tr>
<tr><td><code id="stepEdgeParSel_+3A_bandwidth">bandwidth</code></td>
<td>
<p>A positive integer that specifies the number of
pixels to use in the local smoothing.</p>
</td></tr>
<tr><td><code id="stepEdgeParSel_+3A_thresh">thresh</code></td>
<td>
<p>The threshold value to use in the edge detection
criterion. Must be a positive value.</p>
</td></tr>
<tr><td><code id="stepEdgeParSel_+3A_nboot">nboot</code></td>
<td>
<p>Number of bootstrap samples to use in estimating
<code class="reqn">d_{KQ}</code>.</p>
</td></tr> 
<tr><td><code id="stepEdgeParSel_+3A_degree">degree</code></td>
<td>
<p>An integer equal to 0 for local constant kernel
smoothing or 1 for local linear kernel smoothing. The default
value is 1.</p>
</td></tr>
<tr><td><code id="stepEdgeParSel_+3A_blur">blur</code></td>
<td>
<p>If blur = TRUE, in addition to a conventional 2-D kernel
function, a 1-D kernel is used in local smoothing to address
the issue of blur. The default value is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A jump-preserving local linear kernel smoothing is applied to
estimate the discontinuous regression surface; Bootstrap
samples are obtained by drawing with replacement from the
residuals and the <code class="reqn">d_{KQ}</code> is computed for the detected
edges of the original sample and those of the bootstrap samples.
</p>


<h3>Value</h3>

<p>A list of the selected bandwidth, the selected threshold value
and a matrix of <code class="reqn">d_{KQ}</code> values with each entry
corresponding to each combination of bandwidth and threshold.
</p>


<h3>Author(s)</h3>

<p>Yicheng Kang</p>


<h3>References</h3>

<p>Kang, Y. and Qiu, P. (2014) &quot;Jump Detection in Blurred Regression 
Surfaces,&quot; <em>Technometrics</em>, <b>56</b>(4), 539 &ndash; 550,
<a href="https://doi.org/10.1080/00401706.2013.844732">doi:10.1080/00401706.2013.844732</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+roofDiff">roofDiff</a></code>, <code><a href="#topic+stepDiff">stepDiff</a></code>, <code><a href="#topic+roofEdge">roofEdge</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(24)
parSel &lt;- stepEdgeParSel(image = sar, bandwidth = 5,
thresh = c(17, 21), nboot = 1)
</code></pre>

<hr>
<h2 id='stopsign'>Stop Sign Image</h2><span id='topic+stopsign'></span>

<h3>Description</h3>

<p>This file contains the stop sign image. The image has 160x160
pixels. Gray levels are in the range [0, 255]. In the data
file, observations are listed as a 160x160 matrix. This image
has much blurring involved.</p>


<h3>Usage</h3>

<pre><code class='language-R'>stopsign</code></pre>


<h3>Format</h3>

<p>A matrix of 160x160 pixels.</p>


<h3>Author(s)</h3>

<p>Yicheng Kang</p>


<h3>References</h3>

<p>Kang, Y. (2020) &ldquo;Consistent Blind Image Deblurring Using
Jump-Preserving Extrapolation&rdquo;, <em>Journal of Computational and
Graphical Statistics</em>, <b>29</b>(2), 372 &ndash; 382,
<a href="https://doi.org/10.1080/10618600.2019.1665536">doi:10.1080/10618600.2019.1665536</a>.
</p>

<hr>
<h2 id='summary.Edge_Parameters'>Summarize Parameter Selection Results in Edge Detection</h2><span id='topic+summary.Edge_Parameters'></span>

<h3>Description</h3>

<p>Summarize and display some key information about an edge detection parameter selection object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Edge_Parameters'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.Edge_Parameters_+3A_object">object</code></td>
<td>
<p>An edge detection parameter selection object.</p>
</td></tr>
<tr><td><code id="summary.Edge_Parameters_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Summarize results about an edge detection parameter
selection object. In particular, it shows the <code class="reqn">d_{KQ}</code>
values based on bootstrap samples for combinations of bandwidth and
threshold values.
</p>


<h3>Value</h3>

<p>A brief display of parameter selection results in edge detection. 
</p>


<h3>Author(s)</h3>

<p>Yicheng Kang</p>


<h3>References</h3>

<p>Kang, Y. and Qiu, P. (2014) &quot;Jump Detection in Blurred Regression 
Surfaces,&quot; <em>Technometrics</em>, <b>56</b>(4), 539 &ndash; 550,
<a href="https://doi.org/10.1080/00401706.2013.844732">doi:10.1080/00401706.2013.844732</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stepEdgeParSel">stepEdgeParSel</a></code>, <code><a href="#topic+roofEdgeParSel">roofEdgeParSel</a></code>,
<code><a href="#topic+print.Edge_Parameters">print.Edge_Parameters</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(24)
parSel &lt;- stepEdgeParSel(image = sar, bandwidth = 5,
thresh = c(17, 21), nboot = 1)
summary(parSel)
</code></pre>

<hr>
<h2 id='summary.JPEX_Parameters'>Summarize Parameter Selection Results in JPEX Deblurring</h2><span id='topic+summary.JPEX_Parameters'></span>

<h3>Description</h3>

<p>Summarize and display key information about a JPEX parameter selection object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'JPEX_Parameters'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.JPEX_Parameters_+3A_object">object</code></td>
<td>
<p>A JPEX parameter selection object.</p>
</td></tr>
<tr><td><code id="summary.JPEX_Parameters_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Summarize some key information about a JPEX parameter selection object.
In particular, it displays the chosen bandwidth and estimated noise
level.
</p>


<h3>Value</h3>

<p>A brief display of parameter selection results in JPEX estimation. 
</p>


<h3>Author(s)</h3>

<p>Yicheng Kang</p>


<h3>References</h3>

<p>Kang, Y. (2020) &ldquo;Consistent Blind Image Deblurring Using
Jump-Preserving Extrapolation&rdquo;, <em>Journal of Computational and
Graphical Statistics</em>, <b>29</b>(2), 372 &ndash; 382,
<a href="https://doi.org/10.1080/10618600.2019.1665536">doi:10.1080/10618600.2019.1665536</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.jpex">cv.jpex</a></code>, <code><a href="#topic+print.JPEX_Parameters">print.JPEX_Parameters</a></code>,
<code><a href="#topic+plot.JPEX_Parameters">plot.JPEX_Parameters</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>parSel &lt;- cv.jpex(stopsign, c(2,3))
summary(parSel)
</code></pre>

<hr>
<h2 id='summary.JPLLK_Parameters'>Summarize Parameter Selection Results in JPLLK Estimation</h2><span id='topic+summary.JPLLK_Parameters'></span>

<h3>Description</h3>

<p>Summarize and display some key information about a JPLLK parameter selection object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'JPLLK_Parameters'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.JPLLK_Parameters_+3A_object">object</code></td>
<td>
<p>A JPLLK parameter selection object.</p>
</td></tr>
<tr><td><code id="summary.JPLLK_Parameters_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Summarize some information about a JPLLK parameter selection object.
In particular, it displays the selected bandwidth and estimated noise
level.
</p>


<h3>Value</h3>

<p>A brief summary of parameter selection results in JPLLK estimation.
</p>


<h3>Author(s)</h3>

<p>Yicheng Kang</p>


<h3>References</h3>

<p>Qiu, P. (2009) &quot;Jump-Preserving Surface Reconstruction from Noisy Data&quot;,
<em>Annals of the Institute of Statistical Mathematics</em>, <b>61</b>(3),
715 &ndash; 751, <a href="https://doi.org/10.1007/s10463-007-0166-9">doi:10.1007/s10463-007-0166-9</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+JPLLK_surface">JPLLK_surface</a></code>, <code><a href="#topic+print.JPLLK_Parameters">print.JPLLK_Parameters</a></code>,
<code><a href="#topic+plot.JPLLK_Parameters">plot.JPLLK_Parameters</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fit &lt;- JPLLK_surface(image=sar, bandwidth=c(3, 4))
summary(fit)
</code></pre>

<hr>
<h2 id='summary.Surface_Cluster_Parameters'>Summarize Parameter Selection Results in Surface Estimation</h2><span id='topic+summary.Surface_Cluster_Parameters'></span>

<h3>Description</h3>

<p>Summarize and display some key information about a clustering-based surface estimation
parameter selection object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Surface_Cluster_Parameters'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.Surface_Cluster_Parameters_+3A_object">object</code></td>
<td>
<p>A clustering-based surface estimation parameter selection object.</p>
</td></tr>
<tr><td><code id="summary.Surface_Cluster_Parameters_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Summarize some information about a clustering-based surface estimation parameter
selection object. In particular, it displays the selected bandwidth, the estimated
noise level, the estimated value of the  error density at 0 and the estimated
mean of absolute error.
</p>


<h3>Value</h3>

<p>A brief display of parameter selection results in clustering-based estimation. 
</p>


<h3>Author(s)</h3>

<p>Yicheng Kang</p>


<h3>References</h3>

<p>Kang, Y., Mukherjee, P.S. and Qiu, P. (2018) &quot;Efficient Blind Image
Deblurring Using Nonparametric Regression and Local Pixel 
Clustering&quot;, <em>Technometrics</em>, <b>60</b>(4), 522 &ndash; 531,
<a href="https://doi.org/10.1080/00401706.2017.1415975">doi:10.1080/00401706.2017.1415975</a>.
</p>
<p>Qiu, P. (2009) &quot;Jump-Preserving Surface Reconstruction from Noisy 
Data&quot;, <em>Annals of the Institute of Statistical Mathematics</em>,
<b>61</b>, 715 &ndash; 751, <a href="https://doi.org/10.1007/s10463-007-0166-9">doi:10.1007/s10463-007-0166-9</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+surfaceCluster_bandwidth">surfaceCluster_bandwidth</a></code>, <code><a href="#topic+print.Surface_Cluster_Parameters">print.Surface_Cluster_Parameters</a></code>,
<code><a href="#topic+plot.Surface_Cluster_Parameters">plot.Surface_Cluster_Parameters</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(brain)
bandwidth_select &lt;- surfaceCluster_bandwidth(image = brain,
    bandwidths = c(3:4), sig.level = .9995, blur = FALSE)
summary(bandwidth_select)
</code></pre>

<hr>
<h2 id='summary.Three_Stage_Parameters'>Summarize Parameter Selection Results in 3-Stage Estimation</h2><span id='topic+summary.Three_Stage_Parameters'></span>

<h3>Description</h3>

<p>Summarize and display key information about a 3-stage estimation bandwidth selection object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'Three_Stage_Parameters'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.Three_Stage_Parameters_+3A_object">object</code></td>
<td>
<p>A three-stage estimation bandwidth selection object.</p>
</td></tr>
<tr><td><code id="summary.Three_Stage_Parameters_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Summarize some information about a three-stage estimation bandwidth
selection object. In particular, this method prints the
cross-validation or modified cross-validation scores and the
selected bandwidth.
</p>


<h3>Value</h3>

<p>A brief display of bandwidth selection results in three-stage estimation. 
</p>


<h3>Author(s)</h3>

<p>Yicheng Kang</p>


<h3>References</h3>

<p>Qiu, P. and Kang, Y. (2015) &ldquo;Blind Image Deblurring Using Jump 
Regression Analysis&rdquo;, <em>Statistica Sinica</em>, <b>25</b>,
879 &ndash; 899, <a href="https://doi.org/10.5705/ss.2014.054">doi:10.5705/ss.2014.054</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+threeStageParSel">threeStageParSel</a></code>, <code><a href="#topic+print.Three_Stage_Parameters">print.Three_Stage_Parameters</a></code>,
<code><a href="#topic+plot.Three_Stage_Parameters">plot.Three_Stage_Parameters</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
step.edges &lt;- stepEdge(peppers, bandwidth = 9, thresh = 17) 
roof.edges &lt;- roofEdge(peppers, bandwidth = 6, thresh = 3000,
    edge1 = step.edges) 
set.seed(24)
# Time consuming
parSel &lt;- threeStageParSel(image = peppers, edge1 = step.edges,
    edge2 = roof.edges, bandwidth = 3:4, nboot = 1, blur = TRUE)
summary(parSel)

## End(Not run)
</code></pre>

<hr>
<h2 id='surfaceCluster'>Jump-Preserving Surface Estimation Using Pixel Clustering</h2><span id='topic+surfaceCluster'></span>

<h3>Description</h3>

<p>Estimate surface using local pixel clustering and kernel
smoothing. The bandwidth parameter is specified by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surfaceCluster(image, bandwidth, sig.level, sigma, phi0,
    mean_std_abs, cw=3, blur = FALSE, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="surfaceCluster_+3A_image">image</code></td>
<td>
<p>A square matrix, no missing   value allowed.</p>
</td></tr>
<tr><td><code id="surfaceCluster_+3A_bandwidth">bandwidth</code></td>
<td>
<p>A positive integer that specifies the number
of pixels to use in the local smoothing.</p>
</td></tr>
<tr><td><code id="surfaceCluster_+3A_sig.level">sig.level</code></td>
<td>
<p>The significance level for the hypothesis
test deciding whether to cluster pixels or not.</p>
</td></tr>
<tr><td><code id="surfaceCluster_+3A_sigma">sigma</code></td>
<td>
<p>The noise level (i.e., standard deviation of the
error distribution). It is used for computing the asymptotic
threshold for residuals, which are defined to be the difference
between the local linear kernel smoothing output and the center
weighted median filter output. If not specified by the user, a
jump-preserving local linear kernel smoothing surface estimation
(Qiu 2009) is used to obtain an estimated sigma.</p>
</td></tr>
<tr><td><code id="surfaceCluster_+3A_phi0">phi0</code></td>
<td>
<p>The density of the standardized error distribution
at 0. It is used for computing the asymptotic threshold for
residuals, whose definition is given above. If not specified by
the user, a jump-preserving local linear kernel smoothing
surface estimation (Qiu 2009) is used to obtain an estimated
value.</p>
</td></tr>
<tr><td><code id="surfaceCluster_+3A_mean_std_abs">mean_std_abs</code></td>
<td>
<p>The mean of absolute value of the standardized
error. It is used for computing the asymptotic threshold for
residuals, whose definition is given above. If not specified by
the user, a jump-preserving local linear kernel smoothing
surface estimation (Qiu 2009) is used to obtain an estimated
value.</p>
</td></tr>
<tr><td><code id="surfaceCluster_+3A_cw">cw</code></td>
<td>
<p>The center weight for the center weighted
median filter. It must be a positive integer.</p>
</td></tr>
<tr><td><code id="surfaceCluster_+3A_blur">blur</code></td>
<td>
<p>If blur = TRUE, besides a conventional 2-D kernel
function, a univariate increasing kernel function is used in
the local kernel smoothing to address the issue with blur.</p>
</td></tr>
<tr><td><code id="surfaceCluster_+3A_plot">plot</code></td>
<td>
<p> If plot = TRUE, the image of the fitted surface is
plotted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of 'estImg', the restored image,  'sigma', the
estimated standard deviation of the random error, 'phi0', the
estimated density of the error distribution at 0, and 'mean_std_abs',
the estimated absolute mean of the error distribution.
</p>


<h3>Author(s)</h3>

<p>Yicheng Kang</p>


<h3>References</h3>

<p>Kang, Y., Mukherjee, P.S. and Qiu, P. (2018) &quot;Efficient Blind Image
Deblurring Using Nonparametric Regression and Local Pixel 
Clustering&quot;, <em>Technometrics</em>, <b>60</b>(4), 522 &ndash; 531,
<a href="https://doi.org/10.1080/00401706.2017.1415975">doi:10.1080/00401706.2017.1415975</a>.
</p>
<p>Qiu, P. (2009) &quot;Jump-Preserving Surface Reconstruction from Noisy 
Data&quot;, <em>Annals of the Institute of Statistical Mathematics</em>,
<b>61</b>, 715 &ndash; 751, <a href="https://doi.org/10.1007/s10463-007-0166-9">doi:10.1007/s10463-007-0166-9</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+JPLLK_surface">JPLLK_surface</a></code>, <code><a href="#topic+threeStage">threeStage</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
fit &lt;- surfaceCluster(image = brain, bandwidth = 4,
    sig.level = .9995, cw = 3, blur = FALSE)
</code></pre>

<hr>
<h2 id='surfaceCluster_bandwidth'>Bandwidth Selection for Clustering-Based Surface Estimation</h2><span id='topic+surfaceCluster_bandwidth'></span>

<h3>Description</h3>

<p>Select the bandwidth parameter for the function
<code><a href="#topic+surfaceCluster">surfaceCluster</a></code> using cross validation. In the
cases when there is no blur involved (i.e., denoising only),
leave-one-out cross validation is used. In the cases when there
is blur involved, a modified cross validation is used. </p>


<h3>Usage</h3>

<pre><code class='language-R'>surfaceCluster_bandwidth(image, bandwidths, sig.level, sigma,
 phi0, mean_std_abs, relwt = 0.5, cw = 3, blur = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="surfaceCluster_bandwidth_+3A_image">image</code></td>
<td>
<p>A square matrix, no missing value allowed.</p>
</td></tr>
<tr><td><code id="surfaceCluster_bandwidth_+3A_bandwidths">bandwidths</code></td>
<td>
<p>An array of positive integers that specifies
the candidate bandwidth parameters. All the array elements
must be positive integers because the bandwidth is specified
in terms of number of pixels.</p>
</td></tr>
<tr><td><code id="surfaceCluster_bandwidth_+3A_sig.level">sig.level</code></td>
<td>
<p>The significance level for the hypothesis
test deciding whether to cluster pixels or not.</p>
</td></tr>
<tr><td><code id="surfaceCluster_bandwidth_+3A_sigma">sigma</code></td>
<td>
<p>The noise level (i.e., standard deviation of the
error distribution). It is used for computing the asymptotic
threshold for residuals, which are defined to be the
difference between the local linear kernel smoothing output
and the center weighted median filter output. If not specified
by the user, a jump-preserving local linear kernel smoothing
surface estimation (Qiu 2009) is used to obtain an estimated
sigma.</p>
</td></tr>
<tr><td><code id="surfaceCluster_bandwidth_+3A_phi0">phi0</code></td>
<td>
<p>The density of the standardized error distribution
at 0. It is used for computing the asymptotic threshold for
residuals, whose definition is given above. If not specified by
the user, a jump-preserving local linear kernel smoothing
surface estimation (Qiu 2009) is used to obtain an estimated
value.</p>
</td></tr>
<tr><td><code id="surfaceCluster_bandwidth_+3A_mean_std_abs">mean_std_abs</code></td>
<td>
<p>The mean of absolute value of the standardized
error. It is used for computing the asymptotic threshold for
residuals, whose definition is given above. If not specified by
the user, a jump-preserving local linear kernel smoothing
surface estimation (Qiu 2009) is used to obtain an estimated
value.</p>
</td></tr>
<tr><td><code id="surfaceCluster_bandwidth_+3A_relwt">relwt</code></td>
<td>
<p>The relative weight assigned to the cross validation
score in the continuity region. That is, 1 - relwt is assigned
to the cross validation score around the step edges. It is used
only when there is blur involved.</p>
</td></tr>
<tr><td><code id="surfaceCluster_bandwidth_+3A_cw">cw</code></td>
<td>
<p>The center weight for the center weighted median filter.
It must be a positive integer.</p>
</td></tr>
<tr><td><code id="surfaceCluster_bandwidth_+3A_blur">blur</code></td>
<td>
<p>If blur = TRUE, besides a conventional 2-D kernel
function, a univariate increasing kernel function is used in
the local kernel smoothing to address the issue with blur.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list: 'cv_dataframe', a data frame containing the cross
validation scores corresponding to each candidate bandwidth,
'bandwidth_hat', the selected bandwidth, 'sigma', the 
estimated standard deviation of the random error, 'phi0', the
estimated density of the error distribution at 0, and
'mean_std_abs', the estimated absolute mean of the error
distribution.
</p>


<h3>Author(s)</h3>

<p>Yicheng Kang</p>


<h3>References</h3>

<p>Kang, Y., Mukherjee, P.S. and Qiu, P. (2018) &quot;Efficient Blind Image
Deblurring Using Nonparametric Regression and Local Pixel 
Clustering&quot;, <em>Technometrics</em>, <b>60</b>(4), 522 &ndash; 531,
<a href="https://doi.org/10.1080/00401706.2017.1415975">doi:10.1080/00401706.2017.1415975</a>.
</p>
<p>Qiu, P. (2009) &quot;Jump-Preserving Surface Reconstruction from Noisy 
Data&quot;, <em>Annals of the Institute of Statistical Mathematics</em>,
<b>61</b>, 715 &ndash; 751, <a href="https://doi.org/10.1007/s10463-007-0166-9">doi:10.1007/s10463-007-0166-9</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+JPLLK_surface">JPLLK_surface</a></code>, <code><a href="#topic+threeStage">threeStage</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(brain) 
bandwidth_select &lt;- surfaceCluster_bandwidth(image = brain,
bandwidths = c(3:4), sig.level = .9995, blur = FALSE)
</code></pre>

<hr>
<h2 id='threeStage'>Three-Stage Denoising and Deblurring</h2><span id='topic+threeStage'></span>

<h3>Description</h3>

<p>Estimate jump location curves using local principal component
lines. One-sided kernel smoothing is then used for surface
estimation. Bandwidth is specified by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>threeStage(image, bandwidth, edge1, edge2, 
    blur = FALSE, plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="threeStage_+3A_image">image</code></td>
<td>
<p>A square matrix, no missing value allowed.</p>
</td></tr>
<tr><td><code id="threeStage_+3A_bandwidth">bandwidth</code></td>
<td>
<p>A positive integer that specifies the number
of pixels to use in the local smoothing.</p>
</td></tr>
<tr><td><code id="threeStage_+3A_edge1">edge1</code></td>
<td>
<p>A matrix of 0 and 1 representing the detected
step edge pixels</p>
</td></tr>
<tr><td><code id="threeStage_+3A_edge2">edge2</code></td>
<td>
<p>A matrix of 0 and 1 representing the detected
roof/valley edge pixels</p>
</td></tr>
<tr><td><code id="threeStage_+3A_blur">blur</code></td>
<td>
<p>If blur = TRUE, besides a conventional 2-D kernel
function, a univariate increasing kernel function is used in
the local kernel smoothing to address the issue with blur.</p>
</td></tr>
<tr><td><code id="threeStage_+3A_plot">plot</code></td>
<td>
<p> If plot = TRUE, the image of the fitted surface is
plotted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At each pixel, if there are step edges detected in the local
neighborhood, a principal component line is fitted through the
detected edge pixels to approximate	the step edge locally and
then the regression surface is estimated by a local constant
kernel smoothing procedure using only the pixels on one side
of the principal component line. If there are no step edges
but roof/valley edges detected in the local neighborhood, the
same procedure is followed except that the principal component
line to fitted through the detected roof/valley edge pixels.
In cases when there is either no step edges or roof/valley
edges detected in the neighborhood, the regression surface at
the pixel is estimated by the conventional local linear kernel
smoothing procedure.
</p>


<h3>Value</h3>

<p>The restored image, which is represented by a matrix.
</p>


<h3>Author(s)</h3>

<p>Yicheng Kang</p>


<h3>References</h3>

<p>Qiu, P. and Kang, Y. (2015) &ldquo;Blind Image Deblurring Using Jump 
Regression Analysis&rdquo;, <em>Statistica Sinica</em>, <b>25</b>,
879 &ndash; 899, <a href="https://doi.org/10.5705/ss.2014.054">doi:10.5705/ss.2014.054</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+JPLLK_surface">JPLLK_surface</a></code>, <code><a href="#topic+surfaceCluster">surfaceCluster</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>step.edges &lt;- stepEdge(sar, bandwidth = 4, thresh = 20, degree = 0)
stepEdge1 &lt;- modify2(bandwidth = 4, step.edges)
fit &lt;- threeStage(image = sar, bandwidth = 4, edge1 = stepEdge1,
    edge2 = array(0, rep(ncol(sar), 2)))
</code></pre>

<hr>
<h2 id='threeStageParSel'>Parameter Selection in Three-Stage Image Restoration</h2><span id='topic+threeStageParSel'></span>

<h3>Description</h3>

<p>Select the bandwidth value for the image restoration method
implemented in the function <code><a href="#topic+threeStage">threeStage</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>threeStageParSel(image, bandwidth, edge1, edge2, nboot,
    blur = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="threeStageParSel_+3A_image">image</code></td>
<td>
<p>A square matrix, no  missing value allowed.</p>
</td></tr>
<tr><td><code id="threeStageParSel_+3A_bandwidth">bandwidth</code></td>
<td>
<p>Bandwidth values to be chosen from. Each of
these values need to be an positive integer specifying the
number of pixels to use in the local smoothing.</p>
</td></tr>
<tr><td><code id="threeStageParSel_+3A_edge1">edge1</code></td>
<td>
<p>A matrix of 0 and 1 representing the detected
step edge pixels.</p>
</td></tr>
<tr><td><code id="threeStageParSel_+3A_edge2">edge2</code></td>
<td>
<p>A matrix of 0 and 1 representing the detected
roof/valley edge pixels.</p>
</td></tr>
<tr><td><code id="threeStageParSel_+3A_nboot">nboot</code></td>
<td>
<p>Required when <code>blur</code> is TRUE. Unused when
<code>blur</code> is FALSE. It must be a positive integer
specifying the number of bootstraps to perform. See
Qiu and Kang (2015) for details.</p>
</td></tr>
<tr><td><code id="threeStageParSel_+3A_blur">blur</code></td>
<td>
<p>TRUE if the image contains blur, FALSE otherwise.
If TRUE, the hybrid selection method proposed in
Qiu and Kang (2015) is used. If FALSE, the leave-one-out cross
validation is used.</p>
</td></tr> 
</table>


<h3>Value</h3>

<p>A list of the selected bandwidth, and a matrix of
cross-validation scores with each entry corresponding to a
choice of bandwidth.</p>


<h3>Author(s)</h3>

<p>Yicheng Kang</p>


<h3>References</h3>

<p>Qiu, P. and Kang, Y. (2015) &ldquo;Blind Image Deblurring Using Jump 
Regression Analysis&rdquo;, <em>Statistica Sinica</em>, <b>25</b>,
879 &ndash; 899, <a href="https://doi.org/10.5705/ss.2014.054">doi:10.5705/ss.2014.054</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
step.edges &lt;- stepEdge(peppers, bandwidth = 9, thresh = 17) 
roof.edges &lt;- roofEdge(peppers, bandwidth = 6, thresh = 3000,
    edge1 = step.edges) 
set.seed(24)
# Time consuming
parSel &lt;- threeStageParSel(image = peppers, edge1 = step.edges,
    edge2 = roof.edges, bandwidth = 3:4, nboot = 1, blur = TRUE) 

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
