<!DOCTYPE html><html lang="en"><head><title>Help for package rjaf</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rjaf}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Example_data'><p>Simulated randomized experiment data</p></a></li>
<li><a href='#residualize'><p>Arbitrary residualization of outcomes</p></a></li>
<li><a href='#rjaf'><p>Regularized Joint Assignment Forest with Treatment Arm Clustering</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Regularized Joint Assignment Forest with Treatment Arm
Clustering</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/wustat/rjaf">https://github.com/wustat/rjaf</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/wustat/rjaf/issues">https://github.com/wustat/rjaf/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Personalized assignment to one of many treatment arms via regularized and clustered joint assignment forests as described in Ladhania, Spiess, Ungar, and Wu (2023) &lt;<a href="https://doi.org/10.48550%2FarXiv.2311.00577">doi:10.48550/arXiv.2311.00577</a>&gt;. The algorithm pools information across treatment arms: it considers a regularized forest-based assignment algorithm based on greedy recursive partitioning that shrinks effect estimates across arms; and it incorporates a clustering scheme that combines treatment arms with consistently similar outcomes.</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, dplyr, tibble, magrittr, readr, randomForest, ranger,
forcats, rlang (&ge; 1.1.0), tidyr, stringr, MASS</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-16 17:38:22 UTC; xinyizhang</td>
</tr>
<tr>
<td>Author:</td>
<td>Wenbo Wu <a href="https://orcid.org/0000-0002-7642-9773"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cph],
  Xinyi Zhang <a href="https://orcid.org/0009-0007-7306-491X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre, cph],
  Jann Spiess <a href="https://orcid.org/0000-0002-4120-8241"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cph],
  Rahul Ladhania <a href="https://orcid.org/0000-0002-7902-7681"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Xinyi Zhang &lt;zhang.xinyi@nyu.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-16 18:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Example_data'>Simulated randomized experiment data</h2><span id='topic+Example_data'></span>

<h3>Description</h3>

<p>A data set simulated based on the function <code>sim.data</code> in the Examples section
of <code>rjaf.R</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Example_data
</code></pre>


<h3>Format</h3>

<p>A data frame with 100 rows, 12 columns, and 5 treatment arms:
</p>

<dl>
<dt>id</dt><dd><p>Subject ID.</p>
</dd>
<dt>trt</dt><dd><p>Character strings indicating treatment arms (0, 1, 2, 3, and 4)
assigned to subjects, where arm 0 is considered to be the control.</p>
</dd>
<dt>X1</dt><dd><p>Covariate X1.</p>
</dd>
<dt>X2</dt><dd><p>Covariate X2.</p>
</dd>
<dt>X3</dt><dd><p>Covariate X3.</p>
</dd>
<dt>prob</dt><dd><p>Probabilities of treatment assignment.</p>
</dd>
<dt>Y</dt><dd><p>Observed outcomes.</p>
</dd>
<dt>Y0</dt><dd><p>Counterfactual outcomes when subjects are assigned to treatment 0.</p>
</dd>
<dt>Y1</dt><dd><p>Counterfactual outcomes when subjects are assigned to treatment 1.</p>
</dd>
<dt>Y2</dt><dd><p>Counterfactual outcomes when subjects are assigned to treatment 2.</p>
</dd>
<dt>Y3</dt><dd><p>Counterfactual outcomes when subjects are assigned to treatment 3.</p>
</dd>
<dt>Y4</dt><dd><p>Counterfactual outcomes when subjects are assigned to treatment 4.</p>
</dd>
</dl>


<hr>
<h2 id='residualize'>Arbitrary residualization of outcomes</h2><span id='topic+residualize'></span>

<h3>Description</h3>

<p>This function employs random forests and cross-validation to residualize
outcomes following Section 3.3 of Ladhania et al. (2023).
That is, predicted outcomes resulting from random forests are
subtracted from the original outcomes. Doing so helps in adjusting for small imbalanaces
in baseline covariates and removing part of the variation in
outcomes common across treatment arms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residualize(data, y, vars, nfold = 5, fun.rf = "ranger")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residualize_+3A_data">data</code></td>
<td>
<p>input data used for training and estimation, where each
row corresponds to an individual and columns contain information on treatments,
covariates, probabilities of treatment assignment, and observed outcomes.</p>
</td></tr>
<tr><td><code id="residualize_+3A_y">y</code></td>
<td>
<p>a character string denoting the column name of outcomes.</p>
</td></tr>
<tr><td><code id="residualize_+3A_vars">vars</code></td>
<td>
<p>a vector of character strings denoting the column names of covariates.</p>
</td></tr>
<tr><td><code id="residualize_+3A_nfold">nfold</code></td>
<td>
<p>number of folds in cross-validation. The default value is 5.</p>
</td></tr>
<tr><td><code id="residualize_+3A_fun.rf">fun.rf</code></td>
<td>
<p>a character string specifying which random forest package to use.
Two options are <code>ranger</code> and <code>randomForest</code>, with the default being <code>ranger</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data for training and estimation with residualized outcomes.
</p>


<h3>References</h3>

<p>Ladhania Rahul, Spiess Jann, Ungar Lyle, Wu Wenbo (2023). Personalized Assignment
to One of Many Treatment Arms via Regularized and Clustered Joint Assignment Forests.
https://doi.org/10.48550/arXiv.2311.00577.
<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Example_data)
library(dplyr)
library(magrittr)
Example_trainest &lt;- Example_data %&gt;% slice_sample(n = floor(0.5 * nrow(Example_data)))
y &lt;- "Y"
vars &lt;- paste0("X", 1:3)
Example_resid &lt;- residualize(Example_trainest, y, vars, nfold = 5, fun.rf = "ranger")

</code></pre>

<hr>
<h2 id='rjaf'>Regularized Joint Assignment Forest with Treatment Arm Clustering</h2><span id='topic+rjaf'></span>

<h3>Description</h3>

<p>This algorithm trains a joint forest model to estimate the optimal treatment assignment
by pooling information across treatment arms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rjaf(
  data.trainest,
  data.heldout,
  y,
  id,
  trt,
  vars,
  prob,
  ntrt = 5,
  nvar = 3,
  lambda1 = 0.5,
  lambda2 = 0.5,
  ipw = TRUE,
  nodesize = 5,
  ntree = 1000,
  prop.train = 0.5,
  eps = 0.1,
  resid = TRUE,
  clus.tree.growing = FALSE,
  clus.outcome.avg = FALSE,
  clus.max = 10,
  reg = TRUE,
  impute = TRUE,
  setseed = FALSE,
  seed = 1,
  nfold = 5
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rjaf_+3A_data.trainest">data.trainest</code></td>
<td>
<p>input data used for training and estimation, where each
row corresponds to an individual and columns contain information on treatments,
covariates, probabilities of treatment assignment, and observed outcomes.</p>
</td></tr>
<tr><td><code id="rjaf_+3A_data.heldout">data.heldout</code></td>
<td>
<p>input data used for validation with covariates
and optional counterfactual outcomes.</p>
</td></tr>
<tr><td><code id="rjaf_+3A_y">y</code></td>
<td>
<p>a character string denoting the column name of outcomes.</p>
</td></tr>
<tr><td><code id="rjaf_+3A_id">id</code></td>
<td>
<p>a character string denoting the column name of individual IDs. If missing,
a column of integers named &quot;id&quot; will be added to <code>data.trainest</code> and <code>data.heldout</code>.</p>
</td></tr>
<tr><td><code id="rjaf_+3A_trt">trt</code></td>
<td>
<p>a character string denoting the column name of treatments.</p>
</td></tr>
<tr><td><code id="rjaf_+3A_vars">vars</code></td>
<td>
<p>a vector of character strings denoting the column names of covariates.</p>
</td></tr>
<tr><td><code id="rjaf_+3A_prob">prob</code></td>
<td>
<p>a character string denoting the column name of probabilities of
treatment assignment. If missing, a column named &quot;prob&quot; will be added to <code>data.trainest</code> and
<code>data.heldout</code> indicating simple random treatment assignment.</p>
</td></tr>
<tr><td><code id="rjaf_+3A_ntrt">ntrt</code></td>
<td>
<p>number of treatments randomly sampled at each split. It should be
at most equal to the number of unique treatments available. The default value is 5.</p>
</td></tr>
<tr><td><code id="rjaf_+3A_nvar">nvar</code></td>
<td>
<p>number of covariates randomly sampled at each split. It should be
at most equal to the number of unique covariates available. The default value is 3.</p>
</td></tr>
<tr><td><code id="rjaf_+3A_lambda1">lambda1</code></td>
<td>
<p>regularization parameter for shrinking arm-wise within-leaf average
outcomes towards the overall within-leaf average outcome during recursive
partitioning. The default value is 0.5.</p>
</td></tr>
<tr><td><code id="rjaf_+3A_lambda2">lambda2</code></td>
<td>
<p>regularization parameter for shrinking arm-wise within-leaf average
outcomes towards the overall within-leaf average outcome during outcome estimation.
It is only valid when <code>reg</code> is <code>TRUE</code>. The default value is 0.5.</p>
</td></tr>
<tr><td><code id="rjaf_+3A_ipw">ipw</code></td>
<td>
<p>a logical indicator of inverse probability weighting when calculating
leaf-wise weighted averages based on Wu and Gagnon-Bartsch (2018). The default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="rjaf_+3A_nodesize">nodesize</code></td>
<td>
<p>minimum number of observations in a terminal node. The default value is 5.</p>
</td></tr>
<tr><td><code id="rjaf_+3A_ntree">ntree</code></td>
<td>
<p>number of trees to grow in the forest. This should not be set to
too small a number. The default value is 1000.</p>
</td></tr>
<tr><td><code id="rjaf_+3A_prop.train">prop.train</code></td>
<td>
<p>proportion of data used for training in <code>data.trainest</code>.
The default value is 0.5.</p>
</td></tr>
<tr><td><code id="rjaf_+3A_eps">eps</code></td>
<td>
<p>threshold for minimal welfare gain in terms of the empirical standard
deviation of the overall outcome <code>y</code>. The default value is 0.1.</p>
</td></tr>
<tr><td><code id="rjaf_+3A_resid">resid</code></td>
<td>
<p>a logical indicator of arbitrary residualization. If <code>TRUE</code>,
residualization is implemented to reduce the variance of the outcome.
The default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="rjaf_+3A_clus.tree.growing">clus.tree.growing</code></td>
<td>
<p>a logical indicator of clustering for tree growing.
The default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="rjaf_+3A_clus.outcome.avg">clus.outcome.avg</code></td>
<td>
<p>a logical indicator of clustering for tree bagging.
If <code>TRUE</code>, the average outcome is calculated across treatment clusters
determined by the k-means. The default value is <code>FALSE</code>. This option is deprecated.</p>
</td></tr>
<tr><td><code id="rjaf_+3A_clus.max">clus.max</code></td>
<td>
<p>the maximum number of clusters for k-means. It should be
greater than 1 and at most equal to the number of unique treatments.
The default value is 10.</p>
</td></tr>
<tr><td><code id="rjaf_+3A_reg">reg</code></td>
<td>
<p>a logical indicator of regularization when calculating the arm-wise
within-leaf average outcome.</p>
</td></tr>
<tr><td><code id="rjaf_+3A_impute">impute</code></td>
<td>
<p>a logical indicator of imputation. If <code>TRUE</code>, the within-leaf
average outcome is used to impute the arm-wise within-leaf average outcome
when the arm has no observation. If <code>FALSE</code>, the within-leaf average outcome
is set to zero when the arm has no observation. The default value is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="rjaf_+3A_setseed">setseed</code></td>
<td>
<p>a logical indicator. If <code>TRUE</code>, a seed is set through the
argument <code>seed</code> below and passed to the function <code>rjaf_cpp</code>.
The default value is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="rjaf_+3A_seed">seed</code></td>
<td>
<p>an integer used as a random seed if <code>setseed=TRUE</code>.
The default value is 1.</p>
</td></tr>
<tr><td><code id="rjaf_+3A_nfold">nfold</code></td>
<td>
<p>the number of folds used for cross-validation in outcome
residualization and k-means clustering. The default value is 5.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It first obtains an assignment forest by bagging trees as in Kallus (2017) with
covariate and treatment arm randomization for each tree
and estimating &quot;honest&quot; and regularized estimates of the treatment-specific counterfactual outcomes
on the training sample following Wager and Athey (2018).
</p>
<p>Like Bonhomme and Manresa (2015), it uses a clustering of treatment arms when
constructing the assignment trees. It employs a k-means algorithm for
clustering the K treatment arms into M treatment groups
based on the K predictions for each of the n units in the training sample.
</p>
<p>After clustering, it then repeats the assignment-forest algorithm on the full training data
with M+1 (including control) &quot;arms&quot; (where data from the original arms are combined by groups)
to obtain an ensemble of trees.
</p>
<p>It obtains final regularized predictions and assignments, where it estimates
regularized averages separately by the original treatment arms <code class="reqn">k \in \{0,\ldots,K\}</code>
and obtain the corresponding assignment.
</p>


<h3>Value</h3>

<p>If <code>clus.tree.growing</code> and <code>clus.outcome.avg</code> are <code>TRUE</code>, <code>rjaf</code>
returns a list of two objects: a tibble named as <code>res</code> consisting of individual
IDs, cluster identifiers, and predicted outcomes, and a data frame named as
<code>clustering</code> consisting of cluster identifiers, probabilities of being assigned
to the clusters, and treatment arms. Otherwise, <code>rjaf</code>  returns a list of two tibbles
named <code>res</code> and <code>counterfactuals</code>. <code>res</code> consists of individual IDs (<code>id</code>),
optimal treatment arms identified by the algorithm (<code>trt.rjaf</code>), treatment
clusters (<code>clus.rjaf</code>) if <code>clus.tree.growing</code> is <code>TRUE</code>, and predicted optimal outcomes (<code>Y.rjaf</code>).
If counterfactual outcomes are also present, they will be included
in <code>res</code> along with the column of predicted outcomes (<code>Y.cf</code>). <code>counterfactuals</code> consists of
counterfactual estimates of every available treatment.
</p>


<h3>References</h3>

<p>Bonhomme, Stéphane and Elena Manresa (2015). Grouped Patterns of Heterogeneity in Panel Data. Econometrica, 83: 1147-1184.
<br />
</p>
<p>Kallus, Nathan (2017). Recursive Partitioning for Personalization using Observational Data. In Precup, Doina and Yee Whye Teh, editors,
Proceedings of the 34th International Conference on Machine Learning, volume 70 of Proceedings of Machine Learning Research, pages 1789–1798. PMLR.
<br />
</p>
<p>Wager, Stefan and Susan Athey (2018). Estimation and inference of heterogeneous treatment effects
using random forests. Journal of the American Statistical Association, 113(523):1228–1242.
<br />
</p>
<p>Wu, Edward and Johann A Gagnon-Bartsch (2018). The LOOP Estimator: Adjusting
for Covariates in Randomized Experiments. Evaluation Review, 42(4):458–488.
<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
library(MASS)
sim.data &lt;- function(n, K, gamma, sigma, prob=rep(1,K+1)/(K+1)) {
   # K: number of treatment arms
  options(stringsAsFactors=FALSE)
  data &lt;- left_join(data.frame(id=1:n,
                               trt=sample(0:K, n, replace=TRUE, prob),
                               mvrnorm(n, rep(0,3), diag(3))),
                    data.frame(trt=0:K, prob), by="trt")
  data &lt;- mutate(data, tmp1=10+20*(X1&gt;0)-20*(X2&gt;0)-40*(X1&gt;0&amp;X2&gt;0),
                 tmp2=gamma*(2*(X3&gt;0)-1)/(K-1),
                 tmp3=-10*X1^2,
                 Y=tmp1+tmp2*(trt&gt;0)*(2*trt-K-1)+tmp3*(trt==0)+rnorm(n,0,sigma))
  # Y: observed outcomes
  Y.cf &lt;- data.frame(sapply(0:K, function(t) # counterfactual outcomes
    mutate(data, Y=tmp1+tmp2*(t&gt;0)*(2*t-K-1)+tmp3*(t==0))$Y))
  names(Y.cf) &lt;- paste0("Y",0:K)
  return(mutate(bind_cols(dplyr::select(data, -c(tmp1,tmp2,tmp3)), Y.cf),
                across(c(id, trt), as.character)))
}

n &lt;- 200; K &lt;- 3; gamma &lt;- 10; sigma &lt;- 10
Example_data &lt;- sim.data(n, K, gamma, sigma)
Example_trainest &lt;- Example_data %&gt;% slice_sample(n = floor(0.5 * nrow(Example_data)))
Example_heldout &lt;- Example_data %&gt;% filter(!id %in% Example_trainest$id)
id &lt;- "id"; y &lt;- "Y"; trt &lt;- "trt"
vars &lt;- paste0("X", 1:3)
forest.reg &lt;- rjaf(Example_trainest, Example_heldout, y, id, trt, vars, ntrt = 4, ntree = 100,
                   clus.tree.growing = FALSE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
