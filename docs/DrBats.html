<!DOCTYPE html><html><head><title>Help for package DrBats</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DrBats}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#calc.loglik'><p>Calculate the log likelihood of the model</p></a></li>
<li><a href='#coda.obj'><p>Convert a STAN objet to MCMC list</p></a></li>
<li><a href='#coinertia.drbats'><p>Perform Coinertia Analysis on the PCA</p>
of the Weighted PCA and Deville's PCA</a></li>
<li><a href='#drbats.simul'><p>Main simulation function</p></a></li>
<li><a href='#histoProj'><p>Project a set of curves onto a histogram basis</p></a></li>
<li><a href='#modelFit'><p>Fit a Bayesian Latent Factor to a data set</p>
using STAN</a></li>
<li><a href='#pca.Deville'><p>Perform a PCA using Deville's method</p></a></li>
<li><a href='#pca.proj.Xt'><p>PCA data projected onto a histogram basis</p></a></li>
<li><a href='#postdens'><p>Calculate the unnormalized posterior density of the model</p></a></li>
<li><a href='#stanfit'><p>A stanfit object fitted to the toydata</p></a></li>
<li><a href='#toydata'><p>A toy longitudinal data set</p></a></li>
<li><a href='#visbeta'><p>Format scores output for visualization</p></a></li>
<li><a href='#visW'><p>Plot the estimates for the latent factors</p></a></li>
<li><a href='#W.QR'><p>Build and decompose a low-rank matrix W</p></a></li>
<li><a href='#weighted.Deville'><p>Perform a weighted PCA using Deville's method</p>
on a data matrix X that we project
onto a histogram basis and weighted</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Data Representation: Bayesian Approach That's Sparse</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.6</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Benedicte Fontez &lt;benedicte.fontez@supagro.fr&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Feed longitudinal data into a Bayesian Latent Factor Model to obtain 
  a low-rank representation. Parameters are estimated using a Hamiltonian 
  Monte Carlo algorithm with STAN. See G. Weinrott, B. Fontez, N. Hilgert and 
  S. Holmes, "Bayesian Latent Factor Model for Functional Data Analysis", 
  Actes des JdS 2016.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0), rstan</td>
</tr>
<tr>
<td>Imports:</td>
<td>ade4, coda, MASS, Matrix, sde</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Suggests:</td>
<td>fda, ggplot2, knitr, parallel, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Author:</td>
<td>Gabrielle Weinrott [aut],
  Brigitte Charnomordic [ctr],
  Benedicte Fontez [cre, aut],
  Nadine Hilgert [ctr],
  Susan Holmes [ctr],
  Isabelle Sanchez [ctr]</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-02-02 15:48:37 UTC; sanchez</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-02-13 19:00:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='calc.loglik'>Calculate the log likelihood of the model</h2><span id='topic+calc.loglik'></span>

<h3>Description</h3>

<p>Calculate the log likelihood of the model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc.loglik(Y, W, B, sigma2, tau2, a = 0.001, b = 0.001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc.loglik_+3A_y">Y</code></td>
<td>
<p>is an NxP matrix</p>
</td></tr>
<tr><td><code id="calc.loglik_+3A_w">W</code></td>
<td>
<p>is a PxD matrix</p>
</td></tr>
<tr><td><code id="calc.loglik_+3A_b">B</code></td>
<td>
<p>is a DxN matrix</p>
</td></tr>
<tr><td><code id="calc.loglik_+3A_sigma2">sigma2</code></td>
<td>
<p>is a real number</p>
</td></tr>
<tr><td><code id="calc.loglik_+3A_tau2">tau2</code></td>
<td>
<p>is a real number</p>
</td></tr>
<tr><td><code id="calc.loglik_+3A_a">a</code></td>
<td>
<p>the first parameter of the inverse gamma distribution</p>
</td></tr>
<tr><td><code id="calc.loglik_+3A_b">b</code></td>
<td>
<p>the second parameter of the inverse gamma distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>loglik the likelihood
</p>


<h3>Author(s)</h3>

<p>Gabrielle Weinrott
</p>

<hr>
<h2 id='coda.obj'>Convert a STAN objet to MCMC list</h2><span id='topic+coda.obj'></span>

<h3>Description</h3>

<p>Convert a STAN objet to MCMC list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coda.obj(stanfit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coda.obj_+3A_stanfit">stanfit</code></td>
<td>
<p>a STAN object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>codafit an mcmc.list
</p>


<h3>Author(s)</h3>

<p>Gabrielle Weinrott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(stanfit) # output of modelFit or main.modelFit
coda.fit &lt;- coda.obj(stanfit)
head(coda.fit)

</code></pre>

<hr>
<h2 id='coinertia.drbats'>Perform Coinertia Analysis on the PCA
of the Weighted PCA and Deville's PCA</h2><span id='topic+coinertia.drbats'></span>

<h3>Description</h3>

<p>Perform Coinertia Analysis on the PCA
of the Weighted PCA and Deville's PCA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coinertia.drbats(
  X.histo = NULL,
  Qp = NULL,
  X = NULL,
  t = NULL,
  t.range = c(0, 1000),
  breaks
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coinertia.drbats_+3A_x.histo">X.histo</code></td>
<td>
<p>the data matrix projected onto the histogram basis</p>
</td></tr>
<tr><td><code id="coinertia.drbats_+3A_qp">Qp</code></td>
<td>
<p>a matrix of weights, if Qp = NULL the function specifies a diagonal weight matrix</p>
</td></tr>
<tr><td><code id="coinertia.drbats_+3A_x">X</code></td>
<td>
<p>a data matrix, if X.histo is NULL and needs to be built</p>
</td></tr>
<tr><td><code id="coinertia.drbats_+3A_t">t</code></td>
<td>
<p>a matrix of observation times, if X.histo is NULL and needs to be built</p>
</td></tr>
<tr><td><code id="coinertia.drbats_+3A_t.range">t.range</code></td>
<td>
<p>the range of observation times in vector form,
if X.histo is NULL and needs to be built (default: t.range = c(0, 1000))</p>
</td></tr>
<tr><td><code id="coinertia.drbats_+3A_breaks">breaks</code></td>
<td>
<p>integer number of histogram windows</p>
</td></tr>
</table>


<h3>Value</h3>

<p>co_weight the co-inertia object
</p>


<h3>Author(s)</h3>

<p>Gabrielle Weinrott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- drbats.simul(N = 5, P = 100, t.range = c(5, 100), breaks = 8)
res.coinertia &lt;- coinertia.drbats(X = res$X, t = res$t.simul, t.range = c(5, 100), breaks = 8)
res.coinertia

</code></pre>

<hr>
<h2 id='drbats.simul'>Main simulation function</h2><span id='topic+drbats.simul'></span>

<h3>Description</h3>

<p>Main simulation function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drbats.simul(
  N = 10,
  P = 150,
  t.range = c(0, 1000),
  b.range = c(0.2, 0.4),
  c.range = c(0.6, 0.8),
  b.sd = 2,
  c.sd = 2,
  a.range = c(-0.4, 0.4),
  y.range = c(0, 10),
  amp = 10,
  per = 12,
  data.type = "sparse",
  breaks = 15,
  sigma2 = 0.2,
  seed = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drbats.simul_+3A_n">N</code></td>
<td>
<p>integer number of functions to simulate (default = 10)</p>
</td></tr>
<tr><td><code id="drbats.simul_+3A_p">P</code></td>
<td>
<p>a number of observation times (default = 150)</p>
</td></tr>
<tr><td><code id="drbats.simul_+3A_t.range">t.range</code></td>
<td>
<p>a range of times in which to place the P observations (default = c(1, 1000))</p>
</td></tr>
<tr><td><code id="drbats.simul_+3A_b.range">b.range</code></td>
<td>
<p>a vector giving the range of values for the mean of the first mode (default b.range = c(0.2, 0.4))</p>
</td></tr>
<tr><td><code id="drbats.simul_+3A_c.range">c.range</code></td>
<td>
<p>a vector giving the range of values for the mean of the second mode (default c.range = c(0.6, 0.8))</p>
</td></tr>
<tr><td><code id="drbats.simul_+3A_b.sd">b.sd</code></td>
<td>
<p>the standard deviation for the first mode (default b.sd = 2)</p>
</td></tr>
<tr><td><code id="drbats.simul_+3A_c.sd">c.sd</code></td>
<td>
<p>the standard deviation for the second mode (default c.sd = 2)</p>
</td></tr>
<tr><td><code id="drbats.simul_+3A_a.range">a.range</code></td>
<td>
<p>a vector giving the range of values for the slope (default a.range = c(-0.4, 0.4))</p>
</td></tr>
<tr><td><code id="drbats.simul_+3A_y.range">y.range</code></td>
<td>
<p>a vector giving the range of values for the intercept (default y.range = c(0, 10))</p>
</td></tr>
<tr><td><code id="drbats.simul_+3A_amp">amp</code></td>
<td>
<p>the amplitude of the cosine function (default = 10)</p>
</td></tr>
<tr><td><code id="drbats.simul_+3A_per">per</code></td>
<td>
<p>the periodicity of the cosine function (default = 12)</p>
</td></tr>
<tr><td><code id="drbats.simul_+3A_data.type">data.type</code></td>
<td>
<p>string indicating type of functions (options :sparse, sparse.tend, sparse.tend.cos)</p>
</td></tr>
<tr><td><code id="drbats.simul_+3A_breaks">breaks</code></td>
<td>
<p>number of breaks in the histogram basis</p>
</td></tr>
<tr><td><code id="drbats.simul_+3A_sigma2">sigma2</code></td>
<td>
<p>the precision of the error terms (default = 0.2)</p>
</td></tr>
<tr><td><code id="drbats.simul_+3A_seed">seed</code></td>
<td>
<p>integer specification of a seed (default = NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Y.simul a list containing a matrix Y, a matrix beta, and a matrix epsilon
</p>
<p>t.simul a matrix of simulated observation times
</p>
<p>X the underlying signal to build the data, see DataSimulationandProjection vignette
</p>
<p>proj.pca the outputs of the function pca.proj.Xt
</p>
<p>wlu the outputs of the function W.QR
</p>


<h3>Author(s)</h3>

<p>Gabrielle Weinrott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- drbats.simul(N = 5, P = 100, t.range = c(5, 100), breaks = 8)
X &lt;- res$X
t &lt;- res$t.simul
# To plot the observations, ie the rows
matplot(t(t), t(X), type = 'l', xlab = "Time", ylab = "X")

</code></pre>

<hr>
<h2 id='histoProj'>Project a set of curves onto a histogram basis</h2><span id='topic+histoProj'></span>

<h3>Description</h3>

<p>Project a set of curves onto a histogram basis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>histoProj(X, t, t.range, breaks)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="histoProj_+3A_x">X</code></td>
<td>
<p>a matrix</p>
</td></tr>
<tr><td><code id="histoProj_+3A_t">t</code></td>
<td>
<p>a matrix of observation times</p>
</td></tr>
<tr><td><code id="histoProj_+3A_t.range">t.range</code></td>
<td>
<p>a range of times in which to place the P projections (default = c(0, 1000))</p>
</td></tr>
<tr><td><code id="histoProj_+3A_breaks">breaks</code></td>
<td>
<p>the number of intervals in the histogram basis</p>
</td></tr>
</table>


<h3>Value</h3>

<p>X.proj the matrix X after projection
</p>
<p>X.count a matrix containing the number of observations used to build the projection onto the histogram basis
</p>
<p>windows a vector containing the first time of each window of the histogram intervals
</p>
<p>X.max the matrix of minimum values in each window
</p>
<p>X.min the matrix of maximum values in each window
</p>


<h3>Author(s)</h3>

<p>Gabrielle Weinrott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- drbats.simul(N = 5, P = 100, t.range = c(5, 100), breaks = 8)
res.proj &lt;- histoProj(res$X, res$t.simul, t.range = c(5, 100), breaks = 8)
res.proj

</code></pre>

<hr>
<h2 id='modelFit'>Fit a Bayesian Latent Factor to a data set
using STAN</h2><span id='topic+modelFit'></span>

<h3>Description</h3>

<p>Fit a Bayesian Latent Factor to a data set
using STAN
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelFit(
  model = "PLT",
  var.prior = "IG",
  prog = "stan",
  parallel = TRUE,
  Xhisto = NULL,
  nchains = 4,
  nthin = 10,
  niter = 10000,
  R = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modelFit_+3A_model">model</code></td>
<td>
<p>a string indicating the type of model (&quot;PLT&quot;, or sparse&quot;, default = &quot;PLT&quot;)</p>
</td></tr>
<tr><td><code id="modelFit_+3A_var.prior">var.prior</code></td>
<td>
<p>the family of priors to use for the variance parameters (&quot;IG&quot; for inverse gamma, or &quot;cauchy&quot;)</p>
</td></tr>
<tr><td><code id="modelFit_+3A_prog">prog</code></td>
<td>
<p>a string indicating the MCMC program to use (default = &quot;stan&quot;)</p>
</td></tr>
<tr><td><code id="modelFit_+3A_parallel">parallel</code></td>
<td>
<p>true or false, whether or not to parelleize (done using the package &quot;parallel&quot;)</p>
</td></tr>
<tr><td><code id="modelFit_+3A_xhisto">Xhisto</code></td>
<td>
<p>matrix of simulated data (projected onto the histogram basis)</p>
</td></tr>
<tr><td><code id="modelFit_+3A_nchains">nchains</code></td>
<td>
<p>number of chains (default = 2)</p>
</td></tr>
<tr><td><code id="modelFit_+3A_nthin">nthin</code></td>
<td>
<p>the number of thinned interations (default = 1)</p>
</td></tr>
<tr><td><code id="modelFit_+3A_niter">niter</code></td>
<td>
<p>number of iterations (default = 1e4)</p>
</td></tr>
<tr><td><code id="modelFit_+3A_r">R</code></td>
<td>
<p>rotation matrix of the same dimension as the number of desired latent factors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>stanfit, a STAN object
</p>


<h3>Author(s)</h3>

<p>Gabrielle Weinrott
</p>


<h3>References</h3>

<p>The Stan Development Team Stan Modeling Language User's Guide and Reference Manual. http://mc-stan.org/
</p>

<hr>
<h2 id='pca.Deville'>Perform a PCA using Deville's method</h2><span id='topic+pca.Deville'></span>

<h3>Description</h3>

<p>Perform a PCA using Deville's method
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pca.Deville(X, t, t.range, breaks)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pca.Deville_+3A_x">X</code></td>
<td>
<p>a data matrix</p>
</td></tr>
<tr><td><code id="pca.Deville_+3A_t">t</code></td>
<td>
<p>a matrix of observation times corresponding to X</p>
</td></tr>
<tr><td><code id="pca.Deville_+3A_t.range">t.range</code></td>
<td>
<p>the range of observation times in vector form (ex. t.range = c(0, 1000))</p>
</td></tr>
<tr><td><code id="pca.Deville_+3A_breaks">breaks</code></td>
<td>
<p>integer number of histogram windows</p>
</td></tr>
</table>


<h3>Value</h3>

<p>X.histo the matrix projected onto the histogram basis
</p>
<p>U.histo a matrix of eigenvectors in the histogram basis
</p>
<p>Cp a matrix of principal components
</p>
<p>lambda a vector of eigenvalues
</p>
<p>perc.lambda a vector of the percentage of total inertia explained by each principal component
</p>


<h3>Author(s)</h3>

<p>Gabrielle Weinrott
</p>


<h3>References</h3>

<p>JC Deville, &quot;Methodes statisiques et numeriques de l'analyse harmonique&quot;, Annales de l'INSEE, 1974.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- drbats.simul(N = 5, P = 100, t.range = c(5, 100), breaks = 8)
res.pca &lt;- pca.Deville(res$X, res$t.simul, t.range = c(5, 100), breaks = 8)
res.pca

</code></pre>

<hr>
<h2 id='pca.proj.Xt'>PCA data projected onto a histogram basis</h2><span id='topic+pca.proj.Xt'></span>

<h3>Description</h3>

<p>PCA data projected onto a histogram basis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pca.proj.Xt(X, t, t.range = c(0, 1000), breaks = 15)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pca.proj.Xt_+3A_x">X</code></td>
<td>
<p>the data matrix</p>
</td></tr>
<tr><td><code id="pca.proj.Xt_+3A_t">t</code></td>
<td>
<p>the matrix of observation times</p>
</td></tr>
<tr><td><code id="pca.proj.Xt_+3A_t.range">t.range</code></td>
<td>
<p>a vector specifying the observation time range (default : c(0, 1000))</p>
</td></tr>
<tr><td><code id="pca.proj.Xt_+3A_breaks">breaks</code></td>
<td>
<p>the number of breaks in the histogram basis (default : breaks = 15)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Xt.proj a matrix of projected observations
</p>
<p>U a matrix of eigenvectors
</p>
<p>lambda a vector of eigenvalues
</p>
<p>lambda.perc the percentage of inertia captured by each axis
</p>


<h3>Author(s)</h3>

<p>Gabrielle Weinrott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- drbats.simul(N = 5, P = 100, t.range = c(5, 100), breaks = 8)
pca.proj.Xt(res$X, res$t.simul, t.range = c(0, 100), breaks = 8)

</code></pre>

<hr>
<h2 id='postdens'>Calculate the unnormalized posterior density of the model</h2><span id='topic+postdens'></span>

<h3>Description</h3>

<p>Calculate the unnormalized posterior density of the model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>postdens(mcmc.output, Y, D, chain = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="postdens_+3A_mcmc.output">mcmc.output</code></td>
<td>
<p>an mcmc list as produced by clean.mcmc</p>
</td></tr>
<tr><td><code id="postdens_+3A_y">Y</code></td>
<td>
<p>the data matrix</p>
</td></tr>
<tr><td><code id="postdens_+3A_d">D</code></td>
<td>
<p>the number of latent factors</p>
</td></tr>
<tr><td><code id="postdens_+3A_chain">chain</code></td>
<td>
<p>the chain to plot (default = 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>post a vector containing the posterior density at each iteration##' @examples
</p>


<h3>Author(s)</h3>

<p>Gabrielle Weinrott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("toydata")
data("stanfit")
dens &lt;- postdens(coda.obj(stanfit), Y = toydata$Y.simul$Y, D = 2, chain = 1)
hist(dens)

</code></pre>

<hr>
<h2 id='stanfit'>A stanfit object fitted to the toydata</h2><span id='topic+stanfit'></span>

<h3>Description</h3>

<p>A stanfit object fitted to the toydata
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stanfit
</code></pre>


<h3>Format</h3>

<p>A large stanfit object
</p>

<hr>
<h2 id='toydata'>A toy longitudinal data set</h2><span id='topic+toydata'></span>

<h3>Description</h3>

<p>A toy longitudinal data set
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toydata
</code></pre>


<h3>Format</h3>

<p>A list with 5 elements :
</p>

<dl>
<dt>Y.simul</dt><dd><p>a list of simulated data with 3 elements</p>
</dd>
<dt>t.simul</dt><dd><p>a matrix with 5 rows and 150 columns giving the observation times of the original data</p>
</dd>
<dt>X</dt><dd><p>the original data matrix with 5 rows and 150 columns</p>
</dd>
<dt>proj.pca</dt><dd><p>a list with 4 elements : results of the function histoProj(X, t, t.range = c(0, 1000), breaks = 8) </p>
</dd>
<dt>wlu</dt><dd><p>a list with 4 elements : results of the function W.QR(U, lambda) where U and lambda are the results of the PCA of X</p>
</dd>
</dl>


<hr>
<h2 id='visbeta'>Format scores output for visualization</h2><span id='topic+visbeta'></span>

<h3>Description</h3>

<p>Format scores output for visualization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>visbeta(mcmc.output, Y, D, chain = 1, axes = c(1, 2), quant = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="visbeta_+3A_mcmc.output">mcmc.output</code></td>
<td>
<p>an mcmc list as produced by clean.mcmc</p>
</td></tr>
<tr><td><code id="visbeta_+3A_y">Y</code></td>
<td>
<p>the matrix of data</p>
</td></tr>
<tr><td><code id="visbeta_+3A_d">D</code></td>
<td>
<p>the number of latent factors</p>
</td></tr>
<tr><td><code id="visbeta_+3A_chain">chain</code></td>
<td>
<p>the chain to use (default = 1)</p>
</td></tr>
<tr><td><code id="visbeta_+3A_axes">axes</code></td>
<td>
<p>the axes to use (default = c(1, 2))</p>
</td></tr>
<tr><td><code id="visbeta_+3A_quant">quant</code></td>
<td>
<p>a vector of quantiles to retain (default = NULL)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mean.df are the MCMC estimates for the parmeters
</p>
<p>points.df contains all of the estimates of the chain
</p>
<p>contour.df contains the exterior points of the convex hull of the cloud of estimates
</p>


<h3>Author(s)</h3>

<p>Gabrielle Weinrott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("toydata")
data("stanfit")
codafit &lt;- coda.obj(stanfit) ## convert to mcmc.list
beta.res &lt;- visbeta(codafit, Y = toydata$Y.simul$Y, D = toydata$wlu$D, chain = 1,
axes = c(1, 2), quant = c(0.05, 0.95))

ggplot2::ggplot() +
  ggplot2::geom_path(data = beta.res$contour.df, ggplot2::aes(x = x, y = y, colour = ind)) +
  ggplot2::geom_point(data = beta.res$mean.df, ggplot2::aes(x = x, y = y, colour = ind))

</code></pre>

<hr>
<h2 id='visW'>Plot the estimates for the latent factors</h2><span id='topic+visW'></span>

<h3>Description</h3>

<p>Plot the estimates for the latent factors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>visW(mcmc.output, Y, D, chain = 1, factors = c(1, 2))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="visW_+3A_mcmc.output">mcmc.output</code></td>
<td>
<p>an mcmc list as produced by clean.mcmc</p>
</td></tr>
<tr><td><code id="visW_+3A_y">Y</code></td>
<td>
<p>the matrix of data</p>
</td></tr>
<tr><td><code id="visW_+3A_d">D</code></td>
<td>
<p>the number of latent factors</p>
</td></tr>
<tr><td><code id="visW_+3A_chain">chain</code></td>
<td>
<p>the chain to plot (default = 1)</p>
</td></tr>
<tr><td><code id="visW_+3A_factors">factors</code></td>
<td>
<p>a vector indicating the factors to plot (default = c(1, 2))</p>
</td></tr>
</table>


<h3>Value</h3>

<p>res.W a data frame containing the estimates for the factors, and their lower
and upper bounds
</p>
<p>Inertia the percentage of total inertia captured by each of the factors
</p>


<h3>Author(s)</h3>

<p>Gabrielle Weinrott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("toydata")
data("stanfit")
codafit &lt;- coda.obj(stanfit) ## convert to mcmc.list
W.res &lt;- visW(codafit, Y = toydata$Y.simul$Y, D = toydata$wlu$D,
chain = 1, factors = c(1, 2))

## plot the results

data &lt;- data.frame(time = rep(1:9, 2), W.res$res.W)
ggplot2::ggplot() +
  ggplot2::geom_step(data = data, ggplot2::aes(x = time, y = Estimation, colour = Factor)) +
  ggplot2::geom_step(data = data, ggplot2::aes(x = time, y = Lower.est, colour = Factor),
  linetype = "longdash") +
  ggplot2::geom_step(data = data, ggplot2::aes(x = time, y = Upper.est, colour = Factor),
  linetype = "longdash")

</code></pre>

<hr>
<h2 id='W.QR'>Build and decompose a low-rank matrix W</h2><span id='topic+W.QR'></span>

<h3>Description</h3>

<p>Build and decompose a low-rank matrix from
a matrix of eigenvectors and eigenvalues
from principal component analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>W.QR(U, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="W.QR_+3A_u">U</code></td>
<td>
<p>a matrix of eigenvectors</p>
</td></tr>
<tr><td><code id="W.QR_+3A_lambda">lambda</code></td>
<td>
<p>a vector of corresponding eigenvalues</p>
</td></tr>
</table>


<h3>Value</h3>

<p>W a low-rank matrix
</p>
<p>D the number of latent factors
</p>
<p>Q the orthogonal matrix of the W = QR matrix decomposition
</p>
<p>R the upper triangular matrix of the W = QR matrix decomposition
</p>


<h3>Author(s)</h3>

<p>Gabrielle Weinrott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- drbats.simul(N = 5, P = 100, t.range = c(5, 100), breaks = 8)
res.pca &lt;- pca.Deville(res$X, res$t.simul, t.range = c(5, 100), breaks = 8)
Wres.pca &lt;- W.QR(res.pca$U, res.pca$lambda)
Wres.pca

</code></pre>

<hr>
<h2 id='weighted.Deville'>Perform a weighted PCA using Deville's method
on a data matrix X that we project
onto a histogram basis and weighted</h2><span id='topic+weighted.Deville'></span>

<h3>Description</h3>

<p>Perform a weighted PCA using Deville's method
on a data matrix X that we project
onto a histogram basis and weighted
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted.Deville(X, t, t.range, breaks, Qp = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted.Deville_+3A_x">X</code></td>
<td>
<p>a data matrix</p>
</td></tr>
<tr><td><code id="weighted.Deville_+3A_t">t</code></td>
<td>
<p>a matrix of observation times corresponding to X</p>
</td></tr>
<tr><td><code id="weighted.Deville_+3A_t.range">t.range</code></td>
<td>
<p>the range of observation times in vector form (ex. t.range = c(a, b))</p>
</td></tr>
<tr><td><code id="weighted.Deville_+3A_breaks">breaks</code></td>
<td>
<p>integer number of histogram windows</p>
</td></tr>
<tr><td><code id="weighted.Deville_+3A_qp">Qp</code></td>
<td>
<p>a matrix of weights, if Qp = NULL the function specifies a diagonal weight matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>X.histo the matrix projected onto the histogram basis
</p>
<p>U.histo a matrix of eigenvectors in the histogram basis
</p>
<p>Cp a matrix of principal components
</p>
<p>lambda a vector of eigenvalues
</p>
<p>perc.lambda a vector of the percentage of total inertia explained by each principal component
</p>


<h3>Author(s)</h3>

<p>Gabrielle Weinrott
</p>


<h3>Examples</h3>

<pre><code class='language-R'>res &lt;- drbats.simul(N = 5, P = 100, t.range = c(5, 100), breaks = 8)
res.weighted &lt;- weighted.Deville(res$X, res$t.simul, t.range = c(5, 100), breaks = 8, Qp = NULL)
res.weighted

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
