<!DOCTYPE html><html lang="en"><head><title>Help for package relations</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {relations}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#algebra'><p>Relational Algebra</p></a></li>
<li><a href='#Cetacea'><p>Cetacea Data</p></a></li>
<li><a href='#charfun'><p>Relation Characteristic Functions</p></a></li>
<li><a href='#choice'><p>Relation-Based Choices</p></a></li>
<li><a href='#classes'><p>Relation Equivalence Classes</p></a></li>
<li><a href='#closure'><p>Transitive and Reflexive Closure</p></a></li>
<li><a href='#components'><p>Connected components</p></a></li>
<li><a href='#consensus'><p>Consensus Relations</p></a></li>
<li><a href='#cover'><p>Covering Relations</p></a></li>
<li><a href='#dissimilarity'><p>Dissimilarity Between Relations</p></a></li>
<li><a href='#domain'><p>Relation Domain, Arity, and Size</p></a></li>
<li><a href='#elements'><p>Elements of Relation Domains</p></a></li>
<li><a href='#ensemble'><p>Relation Ensembles</p></a></li>
<li><a href='#Felines'><p>Felines Data</p></a></li>
<li><a href='#graph'><p>Relation Graph</p></a></li>
<li><a href='#impute'><p>Impute relations</p></a></li>
<li><a href='#incidence'><p>Relation Incidences</p></a></li>
<li><a href='#pclust'><p>Prototype-Based Partitions of Relations</p></a></li>
<li><a href='#plot'><p>Visualize Relations</p></a></li>
<li><a href='#predicates'><p>Relation Predicates</p></a></li>
<li><a href='#properties'><p>Relation Properties</p></a></li>
<li><a href='#ranking'><p>Rankings</p></a></li>
<li><a href='#reduction'><p>Transitive and Reflexive Reduction</p></a></li>
<li><a href='#relation'><p>Relations</p></a></li>
<li><a href='#scores'><p>Relation Scores</p></a></li>
<li><a href='#setters'><p>Modify Relations</p></a></li>
<li><a href='#SVMBench'><p>SVM Benchmarking Data and Consensus Relations</p></a></li>
<li><a href='#table'><p>Relation Table</p></a></li>
<li><a href='#trace'><p>Traces of Endorelations</p></a></li>
<li><a href='#transform'><p>Transform incidences</p></a></li>
<li><a href='#violations'><p>Violations of Relation Properties</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.6-15</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Title:</td>
<td>Data Structures and Algorithms for Relations</td>
</tr>
<tr>
<td>Description:</td>
<td>Data structures and algorithms for k-ary relations with
  arbitrary domains, featuring relational algebra, predicate functions,
  and fitters for consensus relations.</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>cluster, stats, slam, sets (&ge; 1.0-16), graphics, grDevices</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Rgraphviz, clue (&ge; 0.3-49), Rglpk (&ge; 0.3-1), lpSolve (&ge;
5.6.3), Rsymphony (&ge; 0.1-9), methods</td>
</tr>
<tr>
<td>Enhances:</td>
<td>seriation, Rcplex</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-19 08:28:31 UTC; hornik</td>
</tr>
<tr>
<td>Author:</td>
<td>David Meyer <a href="https://orcid.org/0000-0002-5196-3048"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Kurt Hornik <a href="https://orcid.org/0000-0003-4198-9911"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Christian Buchta [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kurt Hornik &lt;Kurt.Hornik@R-project.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-19 08:34:40 UTC</td>
</tr>
</table>
<hr>
<h2 id='algebra'>Relational Algebra</h2><span id='topic+algebra'></span><span id='topic+relation_union'></span><span id='topic+relation_intersection'></span><span id='topic+relation_symdiff'></span><span id='topic+relation_complement'></span><span id='topic+relation_cartesian'></span><span id='topic+relation_projection'></span><span id='topic+relation_selection'></span><span id='topic+relation_division'></span><span id='topic+relation_join'></span><span id='topic+relation_semijoin'></span><span id='topic+relation_antijoin'></span><span id='topic+relation_remainder'></span><span id='topic++25+3E+3C+25'></span><span id='topic++25+3D+3E+3C+25'></span><span id='topic++25+3E+3C+3D+25'></span><span id='topic++25+3D+3E+3C+3D+25'></span><span id='topic++25+7C+3E+3C+25'></span><span id='topic++25+3E+3C+7C+25'></span><span id='topic++25+7C+3E+3C+7C+25'></span><span id='topic++25+7C+3E+25'></span><span id='topic++25+3C+7C+25'></span><span id='topic++25U+25'></span>

<h3>Description</h3>

<p>Various &ldquo;relational algebra&rdquo;-like operations.</p>


<h3>Usage</h3>

<pre><code class='language-R'>relation_projection(x, margin = NULL)
relation_selection(x, subset)
relation_cartesian(x, y, ...)
relation_complement(x, y)
relation_intersection(x, y, ...)
relation_union(x, y, ...)
relation_symdiff(x, y)
relation_division(x, y)
relation_remainder(x, y)
relation_join(x, y, ...)
relation_semijoin(x, y, ...)
relation_antijoin(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="algebra_+3A_x">x</code>, <code id="algebra_+3A_y">y</code></td>
<td>
<p>Relation objects.</p>
</td></tr>
<tr><td><code id="algebra_+3A_margin">margin</code></td>
<td>
<p>Either a character vector of domain names, or an integer
vector of domain indices.</p>
</td></tr>
<tr><td><code id="algebra_+3A_subset">subset</code></td>
<td>
<p>Expression resulting in a logical vector of length equal
to the number of tuples in the graph.</p>
</td></tr>
<tr><td><code id="algebra_+3A_...">...</code></td>
<td>
<p>Relation objects for <code>relation_cartesian()</code>,
<code>relation_intersection()</code>, and <code>relation_union()</code>.
Otherwise, passed to <code><a href="base.html#topic+merge">merge</a>()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions provide functionality similar to the corresponding
operations defined in relational algebra theory as introduced by Codd
(1970).  Note, however, that domains in database relations, unlike the
concept of relations we use here, are unordered.  In fact, a database
relation (&ldquo;table&rdquo;) is defined as a set of elements called
&ldquo;tuples&rdquo;, where the &ldquo;tuple&rdquo; components are named, but
unordered.  So in fact, a &ldquo;tuple&rdquo; in this sense is a set of
mappings from the attribute names into the union of the attribute
domains.
</p>
<p>The <em>projection</em> of a relation on a specified margin (i.e., a
vector of domain names or indices) is the relation obtained when all
tuples are restricted to this margin. As a consequence, duplicate
tuples are removed.
</p>
<p>The <em>selection</em> of a relation is the relation obtained by taking
a subset of the relation graph, defined by some logical expression.
</p>
<p>The <em>Cartesian product</em> of two relations is obtained by basically
building the Cartesian product of all graph elements, but combining the
resulting pairs into single tuples.
</p>
<p>The <em>union</em> of two relations simply combines the graph elements
of both relations; the <em>complement</em> of two relations <code class="reqn">R</code> and
<code class="reqn">S</code> removes the tuples of <code class="reqn">S</code> from <code class="reqn">R</code>.
</p>
<p>The <em>intersection</em> (<em>symmetric difference</em>)
of two relations is the relation with all tuples they have (do not have)
in common.
</p>
<p>The <em>division</em> of relation <code class="reqn">R</code> by relation <code class="reqn">S</code> is the
reversed Cartesian product. The result is a relation with the domain
unique to <code class="reqn">R</code> and containing the maximum number of tuples which,
multiplied by <code class="reqn">S</code>, are contained in <code class="reqn">R</code>. The <em>remainder</em>
of this operation is the complement of <code class="reqn">R</code> and the division of
<code class="reqn">R</code> by <code class="reqn">S</code>. Note that for both operations, the domain of
<code class="reqn">S</code> must be contained in the domain of <code class="reqn">R</code>.
</p>
<p>The (natural) <em>join</em> of two relations is their Cartesian product,
restricted to the subset where the elements of the common attributes
do match. The left/right/full outer join of two relations
<code class="reqn">R</code> and <code class="reqn">S</code> is
the union of <code class="reqn">R</code>/<code class="reqn">S</code>/<code class="reqn">R</code> and <code class="reqn">S</code>,
and the inner join of <code class="reqn">R</code> and <code class="reqn">S</code>.
The implementation uses <code><a href="base.html#topic+merge">merge</a>()</code>, and so the
left/right/full outer joins are obtained by setting
<code>all.x</code>/<code>all.y</code>/<code>all</code> to <code>TRUE</code> in
<code>relation_join()</code>.
The domains to be matched are specified using <code>by</code>.
</p>
<p>The left (right) <em>semijoin</em> of two relations <code class="reqn">R</code> and <code class="reqn">S</code>
is the join of these, projected to the attributes of <code class="reqn">R</code>
(<code class="reqn">S</code>). Thus, it yields all tuples of <code class="reqn">R</code>
(<code class="reqn">S</code>) participating in the join of <code class="reqn">R</code> and <code class="reqn">S</code>. 
</p>
<p>The left (right) <em>antijoin</em> of two relations <code class="reqn">R</code> and <code class="reqn">S</code>
is the complement of <code class="reqn">R</code> (<code class="reqn">S</code>) and the join of both,
projected to the attributes of <code class="reqn">R</code> (<code class="reqn">S</code>).
Thus, it yields all tuples of <code class="reqn">R</code>
(<code class="reqn">S</code>) <em>not</em> participating in the join of <code class="reqn">R</code> and <code class="reqn">S</code>. 
</p>
<p>The operators <code>%&gt;&lt;%</code>, <code>%=&gt;&lt;%</code>, <code>%&gt;&lt;=%</code>,
<code>%=&gt;&lt;=%</code>, <code>%|&gt;&lt;%</code>, <code>%&gt;&lt;|%</code>, <code>%|&gt;&lt;|%</code>,
<code>%|&gt;%</code>, <code>%&lt;|%</code>, and <code>%U%</code> can be used for the
Cartesian product, left outer join, right outer join, full outer join,
left semi-join, right semi-join, join, left antijoin, right antijoin,
and union, respectively.
</p>


<h3>References</h3>

<p>E. F. Codd (1970),
A relational model of data for large shared data banks.
<em>Communications of the ACM</em>, <b>13</b>/6, 377&ndash;387.
<a href="https://doi.org/10.1145/362384.362685">doi:10.1145/362384.362685</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+relation">relation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## projection
Person &lt;-
    data.frame(Name = c("Harry", "Sally", "George", "Helena", "Peter"),
               Age = c(34, 28, 29, 54, 34),
               Weight = c(80, 64, 70, 54, 80),
               stringsAsFactors = FALSE)
Person &lt;- as.relation(Person)
relation_table(Person)
relation_table(relation_projection(Person, c("Age", "Weight")))

## selection
relation_table(R1 &lt;- relation_selection(Person, Age &lt; 29))
relation_table(R2 &lt;- relation_selection(Person, Age &gt;= 34))
relation_table(R3 &lt;- relation_selection(Person, Age == Weight))

## union
relation_table(R1 %U% R2)

## works only for the same domains:
relation_table(R2 | R3)

## complement
relation_table(Person - R2)

## intersection
relation_table(relation_intersection(R2, R3))

## works only for the same domains:
relation_table(R2 &amp; R3)

## symmetric difference
relation_table(relation_symdiff(R2, R3))

## Cartesian product
Employee &lt;-
    data.frame(Name =
               c("Harry", "Sally", "George", "Harriet", "John"),
               EmpId = c(3415, 2241, 3401, 2202, 3999),
               DeptName =
               c("Finance", "Sales", "Finance", "Sales", "N.N."),
	       stringsAsFactors = FALSE)
Employee &lt;- as.relation(Employee)
relation_table(Employee)
Dept &lt;- data.frame(DeptName = c("Finance", "Sales", "Production"),
                   Manager = c("George", "Harriet", "Charles"),
                   stringsAsFactors = FALSE)
Dept &lt;- as.relation(Dept)
relation_table(Dept)

relation_table(Employee %&gt;&lt;% Dept)

## Natural join
relation_table(Employee %|&gt;&lt;|% Dept)

## left (outer) join
relation_table(Employee %=&gt;&lt;% Dept)

## right (outer) join
relation_table(Employee %&gt;&lt;=% Dept)

## full outer join
relation_table(Employee %=&gt;&lt;=% Dept)

## antijoin
relation_table(Employee %|&gt;% Dept)
relation_table(Employee %&lt;|% Dept)

## semijoin
relation_table(Employee %|&gt;&lt;% Dept)
relation_table(Employee %&gt;&lt;|% Dept)

## division
Completed &lt;-
    data.frame(Student = c("Fred", "Fred", "Fred", "Eugene",
                           "Eugene", "Sara", "Sara"),
               Task = c("Database1", "Database2", "Compiler1",
                        "Database1", "Compiler1", "Database1",
                        "Database2"),
               stringsAsFactors = FALSE)
Completed &lt;- as.relation(Completed)
relation_table(Completed)
DBProject &lt;- data.frame(Task = c("Database1", "Database2"),
                        stringsAsFactors = FALSE)
DBProject &lt;- as.relation(DBProject)
relation_table(DBProject)

relation_table(Completed %/% DBProject)

## division remainder
relation_table(Completed %% DBProject)

</code></pre>

<hr>
<h2 id='Cetacea'>Cetacea Data</h2><span id='topic+Cetacea'></span>

<h3>Description</h3>

<p>A data set with 16 variables on 36 different types of cetacea.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Cetacea")
</code></pre>


<h3>Format</h3>

<p>A data frame with 36 observations on 16 categorical variables.  The
first 15 variables relate to morphology, osteology, or behavior, and
have both self-explanatory names and levels.  The last (<code>CLASS</code>)
gives a common zoological classification.
</p>


<h3>Source</h3>

<p>G. Vescia (1985).
Descriptive classification of Cetacea: Whales, porpoises, and
dolphins.
In: J. F. Marcotorchino, J. M. Proth, and J. Janssen (eds.),
Data analysis in real life environment: ins and outs of solving
problems.
Elsevier Science Publishers B.V.: Amsterdam, The Netherlands.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Cetacea")
summary(Cetacea)
## Show the cetacea types grouped by class.
split(rownames(Cetacea), Cetacea$CLASS)
</code></pre>

<hr>
<h2 id='charfun'>Relation Characteristic Functions</h2><span id='topic+relation_charfun'></span>

<h3>Description</h3>

<p>Determine the characteristic function of a relation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relation_charfun(x, components = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="charfun_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code><a href="#topic+relation">relation</a></code>.</p>
</td></tr>
<tr><td><code id="charfun_+3A_components">components</code></td>
<td>
<p>a logical indicating whether the characteristic
function created should take vectors
(each vector corresponding to one domain) as argument,
or a data frame (with the elements in the rows). In the former case,
all vectors are recycled to fit the longest vector in case of binary
relations.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+relation">relation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Relation 'a divides b':
divides &lt;- function(a, b) b %% a == 0
R &lt;- relation(domain = list(1 : 10, 1 : 10), charfun = divides)
R
## 'Recover' characteristic function:
"%|%" &lt;- relation_charfun(R)

## Use it.
2L %|% 6L
2:4 %|% 6L
2L %|% c(2:3, 6L)

## This also works:
"%|%"(2L, 6L)
## (and more generally does for arities &gt; 2).
</code></pre>

<hr>
<h2 id='choice'>Relation-Based Choices</h2><span id='topic+relation_choice'></span>

<h3>Description</h3>

<p>Choose objects based on an ensemble of relations between these.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relation_choice(x, method = "symdiff", weights = 1,
                control = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="choice_+3A_x">x</code></td>
<td>
<p>an ensemble of endorelations.</p>
</td></tr>
<tr><td><code id="choice_+3A_method">method</code></td>
<td>
<p>a character string specifying one of the built-in
methods, or a function to be taken as a user-defined method.
See <b>Details</b> for available built-in methods.</p>
</td></tr>
<tr><td><code id="choice_+3A_weights">weights</code></td>
<td>
<p>a numeric vector with non-negative case weights.
Recycled to the number of elements in the ensemble given by <code>x</code>
if necessary.</p>
</td></tr>
<tr><td><code id="choice_+3A_control">control</code></td>
<td>
<p>a list of control parameters.  See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="choice_+3A_...">...</code></td>
<td>
<p>a list of control parameters (overruling those specified
in <code>control</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A social choice function is a rule for <em>choosing</em> from a set
<code class="reqn">X</code> of objects, i.e., selecting suitable subsets of <code class="reqn">X</code>.
Voting rules used in elections are the most prominent example of such
functions, which typically aggregate individual preferences (e.g., of
voters).
</p>
<p>Choice methods <code>"symdiff"</code>, <code>"CKS"</code>, <code>"PC"</code> and
<code>"euclidean"</code> choose a given number <code class="reqn">k</code> of objects
(&ldquo;winners&rdquo;) by determining a relation <code class="reqn">R</code> minimizing
<code class="reqn">\sum_b w_b d(R_b, R)^e</code> over all relations for which winners are
always strictly preferred to losers, without any further constraints
on the relations between pairs of winners or pairs of losers, where
<code class="reqn">d</code> is symmetric difference (symdiff, &ldquo;Kemeny-Snell&rdquo;),
Cook-Kress-Seiford (CKS), generalized paired comparison, or 
Euclidean dissimilarity, respectively, and <code class="reqn">w_b</code> is the case
weight given to <code class="reqn">R_b</code>.
For symdiff, CKS and PC choice, the <code class="reqn">R_b</code> must be crisp
endorelations, and <code class="reqn">e = 1</code>; for Euclidean choice, the <code class="reqn">R_b</code>
can be crisp or fuzzy endorelations, and <code class="reqn">e = 2</code>. 
(Note that solving such a choice problem is different from computing
consensus preference relations.)
See <code><a href="#topic+relation_dissimilarity">relation_dissimilarity</a>()</code> for more information about
these dissimilarities.
</p>
<p>Available control options include:
</p>

<dl>
<dt><code>k</code></dt><dd><p>an integer giving the number of objects/winners to
be chosen.</p>
</dd>
<dt><code>n</code></dt><dd><p>the maximal number of optimal choices to be
obtained, with <code>NA</code> constants or <code>"all"</code> indicating to
obtain all optimal choices.  By default, only a single optimal
choice is computed.</p>
</dd>
</dl>

<p>For the general PC case, the discrepancies can be specified via the
<code>delta</code> control option.
</p>
<p>Choice method <code>"Schulze"</code> implements the Schulze method for
selecting winners from (votes expressing) preferences.  See e.g.
<a href="https://en.wikipedia.org/wiki/Schulze_method">https://en.wikipedia.org/wiki/Schulze_method</a> for details.
Currently, the Schulze heuristic is used, and the set of all possible
winners is returned.
</p>


<h3>Value</h3>

<p>A set with the chosen objects, or a list of such sets.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("SVM_Benchmarking_Classification")
## Determine the three best classification learners in the above sense.
if(requireNamespace("Rglpk", quietly = TRUE)) {
    relation_choice(SVM_Benchmarking_Classification, k = 3)
}
</code></pre>

<hr>
<h2 id='classes'>Relation Equivalence Classes</h2><span id='topic+relation_class_ids'></span><span id='topic+relation_classes'></span>

<h3>Description</h3>

<p>Provide class ids or classes, respectively, for an equivalence
relation or the indifference relation of a weak order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relation_class_ids(x)
relation_classes(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="classes_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code><a href="#topic+relation">relation</a></code>
representing a crisp endorelation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>relation_class_ids()</code>, a numeric vector with class ids
corresponding to the classes of the equivalence relation, or the
indifference relation of the weak order with ids ordered according to
increasing preference.
</p>
<p>For <code>relation_classes()</code>, an object of class
<code>relation_classes_of_objects</code>, which is a list of sets giving the
elements in the corresponding classes, named by the class ids.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Equivalence.
f &lt;- factor(rep(c("Good", "Bad", "Ugly"), c(3, 2, 1)))
R &lt;- as.relation(f)
relation_is(R, "equivalence")
table(ids = relation_class_ids(R), orig = f)

relation_classes(R)

## Weak order ("weak preference").
f &lt;- ordered(f, levels = c("Ugly", "Bad", "Good"))
R &lt;- as.relation(f)
relation_is(R, "weak_order")
table(ids = relation_class_ids(R), orig = f)

relation_classes(R)
</code></pre>

<hr>
<h2 id='closure'>Transitive and Reflexive Closure</h2><span id='topic+transitive_closure'></span><span id='topic+reflexive_closure'></span><span id='topic+closure.relation'></span>

<h3>Description</h3>

<p>Computes transitive and reflexive closure of an endorelation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transitive_closure(x)
reflexive_closure(x)
## S3 method for class 'relation'
closure(x, operation = c("transitive", "reflexive"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="closure_+3A_x">x</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object inheriting from class <code><a href="#topic+relation">relation</a></code>,
representing an endorelation.</p>
</td></tr>
<tr><td><code id="closure_+3A_operation">operation</code></td>
<td>
<p>character string indicating the kind of closure.</p>
</td></tr>
<tr><td><code id="closure_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">R</code> be an endorelation on <code class="reqn">X</code> and <code class="reqn">n</code> be the number of
elements in <code class="reqn">X</code>.
</p>
<p>The <em>transitive closure</em> of <code class="reqn">R</code> is the smallest transitive
relation on <code class="reqn">X</code> that contains <code class="reqn">R</code>.  The code implements
Warshall's Algorithm which is of complexity <code class="reqn">O(n^3)</code>.
</p>
<p>The <em>reflexive closure</em> of <code class="reqn">R</code> is computed by setting the
diagonal of the incidence matrix to 1.
</p>


<h3>References</h3>

<p>S. Warshall (1962),
A theorem on Boolean matrices.
<em>Journal of the ACM</em>, <b>9</b>/1, 11&ndash;12.
<a href="https://doi.org/10.1145/321105.321107">doi:10.1145/321105.321107</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+relation">relation</a>()</code>,
<code><a href="#topic+reflexive_reduction">reflexive_reduction</a>()</code>,
<code><a href="#topic+transitive_reduction">transitive_reduction</a>()</code>,
<code><a href="sets.html#topic+closure">closure</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>R &lt;- as.relation(1 : 5)
relation_incidence(R)

## transitive closure/reduction
RR &lt;- transitive_reduction(R)
relation_incidence(RR)
R == transitive_closure(RR)

## same
require("sets")				# closure() and reduction()
R == closure(reduction(R))

## reflexive closure/reduction

RR &lt;- reflexive_reduction(R)
relation_incidence(RR)
R == reflexive_closure(RR)
## same:
R == closure(reduction(R, "reflexive"), "reflexive")
</code></pre>

<hr>
<h2 id='components'>Connected components</h2><span id='topic+relation_connected_components'></span><span id='topic+relation_condensation'></span><span id='topic+relation_component_representation'></span>

<h3>Description</h3>

<p>Computes (strongly or weakly) connected components of an endorelation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relation_connected_components(x, type = c("strongly", "weakly"))
relation_condensation(x)
relation_component_representation(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="components_+3A_x">x</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object inheriting from class <code><a href="#topic+relation">relation</a></code>,
representing a crisp endorelation without missings.</p>
</td></tr>
<tr><td><code id="components_+3A_type">type</code></td>
<td>
<p>character string indicating the kind of components sought.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">G</code> be the graph of an endorelation <code class="reqn">R</code>.
</p>
<p>A <em>weakly</em> connected component of some node <code class="reqn">k</code> in <code class="reqn">G</code> is
the set of all nodes reachable from <code class="reqn">k</code>.  A <em>strongly</em>
connected component of some node <code class="reqn">k</code> is the set of all nodes
reachable from <code class="reqn">k</code>, from which <code class="reqn">k</code> can be reached. Each
component is represented by some element, the <em>leader</em>.
</p>
<p>The <em>component representation</em> graph of a cyclic endorelation
<code class="reqn">R</code> is composed of directed cycles, one for each strongly
connected component of <code class="reqn">R</code> containing more than one element,
linking all corresponding elements.
</p>
<p>The <em>condensation</em> of <code class="reqn">R</code> is the graph of all leaders of
<code class="reqn">R</code>.
</p>


<h3>Value</h3>

<p>For <code>relation_connected_components()</code>, an object of class
<code>relation_classes_of_objects</code>, i.e., a list of sets giving the
elements of the corresponding connected components, named by the
leaders' character representation. The list of leaders is added as a
<code>leaders</code> attribute.
</p>
<p>For <code>relation_condensation()</code>, an (acyclic) endorelation.
</p>
<p>For <code>relation_component_representation()</code>, an endorelation with
same domain as <code>x</code>.
</p>


<h3>References</h3>

<p>S. Warshall (1962),
A theorem on Boolean matrices.
<em>Journal of the ACM</em>, <b>9</b>/1, 11&ndash;12.
<a href="https://doi.org/10.1145/321105.321107">doi:10.1145/321105.321107</a>.
</p>
<p>J. A. La Poutré and J. van Leeuwen (1988),
Maintenance of Transitive Closures and Transitive Reductions of
Graphs.
<em>Proceedings of the International Workshop of Graph-Theoretic
Concepts in Computer Science</em>, Springer, London, 106&ndash;120.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.relation">plot.relation</a>()</code>,
<code><a href="#topic+transitive_reduction">transitive_reduction</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## example from La Poutre and van Leeuwen:

require("sets")				# set(), pair() etc.

G &lt;- set(pair(1L, 2L), pair(2L, 1L), pair(1L, 3L), pair(3L, 1L),
         pair(3L, 7L), pair(2L, 5L), pair(2L, 6L), pair(6L, 5L),
         pair(5L, 7L), pair(4L, 6L), pair(5L, 4L), pair(4L, 7L))

R &lt;- endorelation(graph = G)

relation_connected_components(R)
relation_graph(relation_condensation(R))
relation_graph(relation_component_representation(R))
</code></pre>

<hr>
<h2 id='consensus'>Consensus Relations</h2><span id='topic+relation_consensus'></span>

<h3>Description</h3>

<p>Compute consensus relations of a relation ensemble.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relation_consensus(x, method = NULL, weights = 1,
                   control = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="consensus_+3A_x">x</code></td>
<td>
<p>an ensemble of relations (see
<code><a href="#topic+relation_ensemble">relation_ensemble</a>()</code>),
or something which can be coerced to such.</p>
</td></tr>
<tr><td><code id="consensus_+3A_method">method</code></td>
<td>
<p>a character string specifying one of the built-in
methods for computing consensus relations, or a function to be
taken as a user-defined method, or <code>NULL</code> (default value).  If
a character string, its lower-cased version is matched against the
lower-cased names of the available built-in methods using
<code><a href="base.html#topic+pmatch">pmatch</a>()</code>.  See <b>Details</b> for available built-in
methods and defaults.</p>
</td></tr>
<tr><td><code id="consensus_+3A_weights">weights</code></td>
<td>
<p>a numeric vector with non-negative case weights.
Recycled to the number of elements in the ensemble given by <code>x</code>
if necessary.</p>
</td></tr>
<tr><td><code id="consensus_+3A_control">control</code></td>
<td>
<p>a list of control parameters.  See <b>Details</b>.</p>
</td></tr>
<tr><td><code id="consensus_+3A_...">...</code></td>
<td>
<p>a list of control parameters (overruling those specified
in <code>control</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consensus relations &ldquo;synthesize&rdquo; the information in the
elements of a relation ensemble into a single relation, often by
minimizing a criterion function measuring how dissimilar consensus
candidates are from the (elements of) the ensemble (the so-called
&ldquo;optimization approach&rdquo;), typically of the form
<code class="reqn">\Phi(R) = \sum w_b d(R_b, R) ^ e</code>, where <code class="reqn">d</code> is a suitable
dissimilarity measure (see <code><a href="#topic+relation_dissimilarity">relation_dissimilarity</a>()</code>),
<code class="reqn">w_b</code> is the case weight given to element <code class="reqn">R_b</code> of the
ensemble, and <code class="reqn">e \ge 1</code>.  Such consensus relations are called
&ldquo;central relations&rdquo; in Régnier (1965).  For <code class="reqn">e = 1</code>, we
obtain (generalized) medians; <code class="reqn">e = 2</code> gives (generalized) means
(least squares consensus relations).
</p>
<p>Available built-in methods are as follows.  Apart from Condorcet's and
the unrestricted Manhattan and Euclidean consensus methods, these are
applicable to ensembles of endorelations only. 
</p>

<dl>
<dt><code>"Borda"</code></dt><dd><p>the consensus method proposed by Borda (1781).
For each relation <code class="reqn">R_b</code> and object <code class="reqn">x</code>, one determines the
Borda/Kendall scores, i.e., the number of objects <code class="reqn">y</code> such
that <code class="reqn">y R_b x</code>.  These are then aggregated across relations
by weighted averaging.  Finally, objects are ordered according to
their aggregated scores. Note that this may result in a weak order
(i.e., with objects being tied).
</p>
<p>One can enforce a linear order by setting the control parameter
<code>L</code> to <code>TRUE</code>, and obtain a relation ensemble with up to
<em>n</em> or all such solutions by additionally setting the control
parameter <code>n</code> to some positive integer or <code>"all"</code>,
respectively.
</p>
</dd>
<dt><code>"Copeland"</code></dt><dd><p>the consensus method proposed by Copeland
(1951).  For each relation <code class="reqn">R_b</code> and object <code class="reqn">x</code>, one
determines the Copeland scores, i.e., the number of objects
<code class="reqn">y</code> such that <code class="reqn">y R_b x</code>, minus the number of objects
<code class="reqn">y</code> such that <code class="reqn">x R_b y</code>.  Like the Borda method, these are
then aggregated across relations by weighted averaging.  Finally,
objects are ordered according to their aggregated scores.
Note that this may result in a weak order
(i.e., with objects being tied).
</p>
<p>One can enforce a linear order by setting the control parameter
<code>L</code> to <code>TRUE</code>, and obtain a relation ensemble with up to
<em>n</em> or all such solutions by additionally setting the control
parameter <code>n</code> to some positive integer or <code>"all"</code>,
respectively.
</p>
</dd>
<dt><code>"Condorcet"</code></dt><dd><p>the consensus method proposed by Condorcet
(1785).  For a given ensemble of crisp relations, this minimizes
the criterion function <code class="reqn">\Phi</code> with <code class="reqn">d</code> as symmetric
difference distance and <code class="reqn">e = 1</code> over all possible crisp 
relations.  In the case of endorelations, consensus is obtained by
weighting voting, such that <code class="reqn">x R y</code> if the weighted number of
times that <code class="reqn">x R_b y</code> is no less than the weighted number of
times that this is not the case.  Even when aggregating linear
orders, this can lead to intransitive consensus solutions
(&ldquo;effet Condorcet&rdquo;).
</p>
<p>One can obtain a relation ensemble with up to <em>n</em> or all such
solutions consensus relations by setting the control parameter
<code>n</code> to some positive integer or <code>"all"</code>, respectively.
</p>
</dd> 
<dt><code>"CS"</code></dt><dd><p>the consensus method of Cook and Seiford (1978)
which determines a linear order minimizing the criterion function
<code class="reqn">\Phi</code> with <code class="reqn">d</code> as generalized Cook-Seiford (ranking)
distance and <code class="reqn">e = 1</code> via solving a linear sum assignment
problem.
</p>
<p>One can obtain a relation ensemble with up to <em>n</em> or all such
consensus relations by setting the control parameter <code>n</code> to
some positive integer or <code>"all"</code>, respectively.
</p>
</dd>
<dt><code>"symdiff/<var>F</var>"</code></dt><dd><p>an exact solver for determining the
consensus relation of an ensemble of crisp endorelations by
minimizing the criterion function <code class="reqn">\Phi</code> with <code class="reqn">d</code> as
symmetric difference (&ldquo;symdiff&rdquo;) distance and <code class="reqn">e = 1</code>
over a suitable class (&ldquo;Family&rdquo;) of crisp endorelations as
indicated by <var>F</var>, with values:
</p>

<dl>
<dt><code>G</code></dt><dd><p>general (crisp) endorelations.</p>
</dd>
<dt><code>A</code></dt><dd><p>antisymmetric relations.</p>
</dd>
<dt><code>C</code></dt><dd><p>complete relations.</p>
</dd>
<dt><code>E</code></dt><dd><p>equivalence relations: reflexive, symmetric, and
transitive.</p>
</dd>
<dt><code>L</code></dt><dd><p>linear orders: complete, reflexive,
antisymmetric, and transitive.</p>
</dd>
<dt><code>M</code></dt><dd><p>matches: complete and reflexive.</p>
</dd>
<dt><code>O</code></dt><dd><p>partial orders: reflexive, antisymmetric and
transitive.</p>
</dd>
<dt><code>S</code></dt><dd><p>symmetric relations.</p>
</dd>	
<dt><code>T</code></dt><dd><p>tournaments: complete, irreflexive and
antisymmetric (i.e., complete and asymmetric).</p>
</dd>
<dt><code>W</code></dt><dd><p>weak orders (complete preorders, preferences,
&ldquo;orderings&rdquo;): complete, reflexive and transitive.</p>
</dd> 
<dt><code>preorder</code></dt><dd><p>preorders: reflexive and transitive.</p>
</dd>
<dt><code>transitive</code></dt><dd><p>transitive relations.</p>
</dd>
</dl>

<p>Can also be referred to as <code>"SD/<var>F</var>"</code>.
</p>
<p>Consensus relations are determined by reformulating the consensus
problem as a binary program (for the relation incidences), see
Hornik and Meyer (2007) for details.  The solver employed can be
specified via the control argument <code>solver</code>, with currently
possible values <code>"glpk"</code>, <code>"lpsolve"</code>, <code>"symphony"</code>
or <code>"cplex"</code> or a unique abbreviation thereof, specifying to
use the solvers from packages <span class="pkg">Rglpk</span> (default),
<span class="pkg">lpSolve</span>, <span class="pkg">Rsymphony</span>, or <span class="pkg">Rcplex</span>, respectively.
Unless control option <code>sparse</code> is false, a sparse formulation
of the binary program is used, which is typically more efficient.
</p>
<p>For fitting equivalences and weak orders (cases <code>E</code> and
<code>W</code>) it is possible to specify the number of classes <code class="reqn">k</code>
using the control parameter <code>k</code>.  For fitting weak orders,
one can also specify the number of elements in the classes via
control parameter <code>l</code>.
</p>
<p>Additional constraints on the incidences of the consensus solution
can be given via the control parameter <code>constraints</code>, in the
form of a 3-column matrix whose rows give row and column indices
<code class="reqn">i</code> and <code class="reqn">j</code> and the corresponding incidence <code class="reqn">I_{ij}</code>.
(I.e., incidences can be constrained to be zero or one on an
object by object basis.)
</p>
<p>One can obtain a relation ensemble with up to <em>n</em> or all such
consensus relations by setting the control parameter <code>n</code> to
some positive integer or <code>"all"</code>, respectively.
(See the examples.)
</p>
</dd>
<dt><code>"manhattan"</code></dt><dd><p>the (unrestricted) median of the
ensemble, minimizing <code class="reqn">\Phi</code> with <code class="reqn">d</code> as Manhattan (symmetric
difference) distance and <code class="reqn">e = 1</code> over all (possibly fuzzy)
relations.</p>
</dd>
<dt><code>"euclidean"</code></dt><dd><p>the (unrestricted) mean of the ensemble,
minimizing <code class="reqn">\Phi</code> with <code class="reqn">d</code> as Euclidean distance and
<code class="reqn">e = 2</code> over all (possibly fuzzy) relations.</p>
</dd>
<dt><code>"euclidean/<var>F</var>"</code></dt><dd><p>an exact solver for determining
the restricted least squares Euclidean consensus relation of an
ensemble of endorelations by minimizing the criterion function
<code class="reqn">\Phi</code> with <code class="reqn">d</code> as Euclidean difference distance and
<code class="reqn">e = 2</code> over a suitable family of crisp endorelations as
indicated by <var>F</var>, with available families and control
parameters as for methods <code>"symdiff/<var>F</var>"</code>.
</p>
</dd>
<dt><code>"majority"</code></dt><dd><p>a generalized majority method for which the
consensus relation contains of all tuples occurring with a
relative frequency of more than <code class="reqn">100 p</code> percent (of 100
percent if <code class="reqn">p = 1</code>).  The fraction <code class="reqn">p</code> can be specified
via the control parameter <code>p</code>.  By default, <code class="reqn">p = 1/2</code> is
used.
</p>
</dd>
<dt><code>"CKS/<var>F</var>"</code></dt><dd><p>an exact solver for determining the
consensus relation of an ensemble of crisp endorelations by
minimizing the criterion function <code class="reqn">\Phi</code> with <code class="reqn">d</code> as
Cook-Kress-Seiford (&ldquo;CKS&rdquo;) distance and <code class="reqn">e = 1</code> over a
suitable class (&ldquo;Family&rdquo;) of crisp endorelations as
indicated by <var>F</var>, with available families and control
parameters as for methods <code>"symdiff/<var>F</var>"</code>.
</p>
<p>For fitting equivalences and weak orders (cases <code>E</code> and
<code>W</code>) it is possible to specify the number of classes <code class="reqn">k</code>
using the control parameter <code>k</code>.
</p>
<p>One can obtain a relation ensemble with up to <em>n</em> or all such
consensus relations by setting the control parameter <code>n</code> to
some positive integer or <code>"all"</code>, respectively.
</p>
</dd>
<dt><code>"PC/<var>F</var>"</code></dt><dd><p>an exact solver for determining the
consensus relation of an ensemble of crisp endorelations by
minimizing the criterion function <code class="reqn">\Phi</code> with <code class="reqn">d</code> as
(generalized) paired comparison (&ldquo;PC&rdquo;) distance and
<code class="reqn">e = 1</code> over a suitable class (&ldquo;Family&rdquo;) of crisp
endorelations as indicated by <var>F</var>, with available families and
control parameters as for methods <code>"symdiff/<var>F</var>"</code>, and
control option <code>delta</code> for specifying the paired comparison
discrepancies.
</p>
<p>For fitting equivalences and weak orders (cases <code>E</code> and
<code>W</code>) it is possible to specify the number of classes <code class="reqn">k</code>
using the control parameter <code>k</code>.
</p>
<p>One can obtain a relation ensemble with up to <em>n</em> or all such
consensus relations by setting the control parameter <code>n</code> to
some positive integer or <code>"all"</code>, respectively.
</p>
</dd>
</dl>



<h3>Value</h3>

<p>The consensus relation(s).
</p>


<h3>References</h3>

<p>J. C. Borda (1781),
Mémoire sur les élections au scrutin.
Histoire de l'Académie Royale des Sciences.
</p>
<p>W. D. Cook and M. Kress (1992),
<em>Ordinal information and preference structures: decision models and
applications</em>.
Prentice-Hall: New York.
ISBN: 0-13-630120-7.
</p>
<p>W. D. Cook and L. M. Seiford (1978),
Priority ranking and consensus formation.
<em>Management Science</em>, <b>24</b>/16, 1721&ndash;1732.
<a href="https://doi.org/10.1287/mnsc.24.16.1721">doi:10.1287/mnsc.24.16.1721</a>.
</p>
<p>M. J. A. de Condorcet (1785),
Essai sur l'application de l'analyse à la probabilité des décisions
rendues à la pluralité des voix. 
Paris.
</p>
<p>A. H. Copeland (1951),
A Reasonable Social Welfare Function.
<em>mimeo</em>, University of Michigan.
</p>
<p>E. J. Emond and D. W. Mason (2000),
<em>A new technique for high level decision support</em>.
Technical Report ORD Project Report PR2000/13, Operational
Research Division, Department of National Defence, Canada.

</p>
<p>K. Hornik and D. Meyer (2007),
Deriving consensus rankings from benchmarking experiments.
In R. Decker and H.-J. Lenz,
<em>Advances in Data Analysis</em>.
Studies in Classification, Data Analysis, and Knowledge Organization.
Springer-Verlag: Heidelberg, 163&ndash;170.
</p>
<p>F. Marcotorchino and P. Michaud (1982).
Agrégation de similarités en classification automatique.
<em>Revue de Statistique Appliquée</em>, <b>30</b>/2, 21&ndash;44.
<a href="https://eudml.org/doc/106132">https://eudml.org/doc/106132</a>.
</p>
<p>S. Régnier (1965),
Sur quelques aspects mathématiques des problèmes de classification
automatique.
<em>ICC Bulletin</em>, <b>4</b>, 175&ndash;191.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Consensus equivalence.
## (I.e., in fact, consensus partition.)
## Classification of 30 felines, see Marcotorchino and Michaud (1982).
data("Felines")
## Consider each variable an equivalence relation on the objects.
relations &lt;- as.relation_ensemble(Felines)
## This gives a relation ensemble of length 14 (number of variables in
## the data set).
if(requireNamespace("Rglpk", quietly = TRUE)) {
    ## Now fit an equivalence relation to this:
    E &lt;- relation_consensus(relations, "symdiff/E")
    ## And look at the equivalence classes:
    ids &lt;- relation_class_ids(E)
    ## Or, more nicely:
    split(rownames(Felines), ids)
    ## Which is the same as in the paper ...
}

## Consensus linear order.
## Example from Cook and Kress, pages 48ff.
## Relation from paired comparisons.
pm &lt;- matrix(c(0, 1, 0, 1, 1,
               0, 0, 0, 1, 1,
               1, 1, 0, 0, 0,
               0, 0, 1, 0, 0,
               0, 0, 1, 1, 0),
             nrow = 5,
             byrow = TRUE,
             dimnames = list(letters[1:5], letters[1:5]))
## Note that this is a Cook and Kress "preference matrix" where entry
## (i,j) is one iff object i is preferred to object j (i &gt; j).
## Set up the corresponding '&lt;' relation:
R &lt;- as.relation(t(pm))
relation_incidence(R)
relation_is(R, "tournament")
if(requireNamespace("Rglpk", quietly = TRUE)) {
    ## Closest linear order:
    L &lt;- relation_consensus(R, "symdiff/L")
    relation_incidence(L)
    ## Visualize provided that Rgraphviz is available.
    if(require("Rgraphviz")) plot(L)
    ## But note that this linear order is not unique.
    L &lt;- relation_consensus(R, "symdiff/L", control = list(n = "all"))
    print(L)
    if(require("Rgraphviz")) plot(L)
    ## (Oh no: c is once first and once last.)
    ## Closest weak order relation with at most 3 indifference classes:
    W3 &lt;- relation_consensus(R, "symdiff/W", control = list(k = 3))
    relation_incidence(W3)
}

## Consensus weak orders.
## Example from Emond and Mason, pages 28f.
## The reference provides 21 partial rankings of 15 objects,
## in 3 groups of 7 rankings (corresponding to three different
## ranking criteria) with respective weights 4, 5, and 7.
wei &lt;- rep.int(c(4, 5, 7), rep(7, 3))
## The rankings are written by listing the object labels from the
## best to the worst, with a leading minus indicating a tie with
## the previous object:
EM_inputs &lt;-
    c("6 1 -7 -9 10 3 8 11 5 -12 2 -4 -13",
      "6 10 9 3 4 -8 7 1 -5 -11 2 12 13 14 15",
      "6 10 3 7 8 11 5 14 15 12 1 -4 -13 2 -9",
      "6 9 -11 10 3 14 12 7 4 5 2 1 8 13 15",
      "10 6 7 1 11 -13 4 2 3 9 12 14 -15 8 5",
      "6 9 8 -10 11 4 1 5 7 15 2 12 14 13 3",
      "1 -6 -10 7 -12 9 3 4 -11 -14 -15 2 -13 8",
      "4 -10 1 -7 6 -9 -13 5 -14 3 12 8 11 -15 2",
      "4 -9 5 1 14 11 8 3 6 2 -13 10 12 7 15",
      "4 2 -5 8 15 7 11 -14 1 -12 -13 10 9 6",
      "2 -11 -12 -14 -15 6 -13 3 -4 9 8 -10 1 -5 -7",
      "4 14 10 2 5 3 1 13 12 7 15 8 11 6 9",
      "4 2 5 1 15 7 13 14 3 -12 8 11 6 9 10",
      "12 1 3 -4 2 11 -13 -15 9 14 6 8 7 -10 5",
      "5 4 9 2 -7 14 8 -11 3 1 15 12 6 10 13",
      "11 9 -14 15 12 3 4 13 8 6 7 10 5",
      "12 11 2 1 3 9 8 10 13 -14 6 4 -15 5 7",
      "4 -5 10 -12 3 8 -11 6 -7 -9 13 14 15",
      "12 5 -13 14 3 8 15 4 9 -10 11 6 7",
      "4 -5 -8 11 6 14 7 1 -2 -15 10 3 13 9 -12",
      "10 8 5 -11 6 -14 9 4 -13 -15 3 -12 2 1")
## Using the Emond-Mason paired comparison dissimilarity, there
## are three consensus rankings when using the above weights:
EM_solutions &lt;-
    c("4 10 5-11 1 -2-14 3-12 9 8 6 7 13-15",
      "4 10 5-11 1 -2 9 14 3-12 8 6 7 13-15",
      "4 10 5-11 2-14 1 3-12 9 8 6 7 13-15")
## We can reproduce this as follows.
## We first provide a reader for the rankings, and a maker for
## creating the (possibly partial) ranking with the appropriate
## domain:
reader &lt;- function(s) {
    strsplit(unlist(strsplit(gsub(" *-", "-", s),
                             " +")),
             "-",
             fixed = TRUE)
}
maker &lt;- function(s) {
    ranking(lapply(reader(s), as.numeric),
            domain = as.numeric(1 : 15))
}
EM_inputs &lt;- lapply(EM_inputs, maker)
EM_solutions &lt;- lapply(EM_solutions, maker)
## Package 'relations' uses NA for non-diagonal incidences
## featuring unranked objects.
## Following the reference, we impute these by zeroes:
ens &lt;- relation_impute(relation_ensemble(list = EM_inputs), "omit")
if(requireNamespace("Rglpk", quietly = TRUE)) {
    ## We can now obtain all consensus weak orders (corresponding to
    ## complete rankings) as follows:
    con &lt;- relation_consensus(ens, "PC/W", wei, delta = "EM", all = TRUE)
    ## To verify that these agree with the solutions given in the
    ## reference:
    sets::set_outer(con, relation_ensemble(list = EM_solutions), `==`)
}
</code></pre>

<hr>
<h2 id='cover'>Covering Relations</h2><span id='topic+relation_cover'></span>

<h3>Description</h3>

<p>Compute the covering relation of an endorelation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relation_cover(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cover_+3A_x">x</code></td>
<td>
<p>an endorelation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">R</code> be an endorelation with domain <code class="reqn">(X, X)</code> and <code class="reqn">P</code> be
the asymmetric part of <code class="reqn">R</code> for which <code class="reqn">x P y</code> iff <code class="reqn">x R y</code>
and not <code class="reqn">y R x</code>.  (If <code class="reqn">R</code> is a <code class="reqn">\le</code> order relation,
<code class="reqn">P</code> is the associated strict order.)  We say that <code class="reqn">x</code> is
covered by <code class="reqn">y</code> if <code class="reqn">x P y</code> and there is no <code class="reqn">z</code> such that
<code class="reqn">x P z</code> and <code class="reqn">z P y</code>.  One also says that <code class="reqn">y</code> covers
<code class="reqn">x</code>, or that it is a successor of <code class="reqn">x</code>.
</p>
<p>The covering relation of <code class="reqn">R</code> consists of all pairs <code class="reqn">(x, y)</code>
for which <code class="reqn">x</code> is covered by <code class="reqn">y</code>.
</p>

<hr>
<h2 id='dissimilarity'>Dissimilarity Between Relations</h2><span id='topic+relation_dissimilarity'></span>

<h3>Description</h3>

<p>Compute the dissimilarity between (ensembles of)
relations.</p>


<h3>Usage</h3>

<pre><code class='language-R'>relation_dissimilarity(x, y = NULL, method = "symdiff", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dissimilarity_+3A_x">x</code></td>
<td>
<p>an ensemble of relations (see
<code><a href="#topic+relation_ensemble">relation_ensemble</a>()</code>),
or something which can be coerced to such.</p>
</td></tr> 
<tr><td><code id="dissimilarity_+3A_y">y</code></td>
<td>
<p><code>NULL</code> (default), or as for <code>x</code>.</p>
</td></tr>
<tr><td><code id="dissimilarity_+3A_method">method</code></td>
<td>
<p>a character string specifying one of the built-in
methods for computing dissimilarity, or a function to be taken as
a user-defined method.  If a character string, its lower-cased
version is matched against the lower-cased names of the available
built-in methods using <code><a href="base.html#topic+pmatch">pmatch</a>()</code>.
See <b>Details</b> for available built-in methods.</p>
</td></tr>
<tr><td><code id="dissimilarity_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Available built-in methods are as follows.
</p>

<dl>
<dt><code>"symdiff"</code></dt><dd><p>symmetric difference distance.
This computes the cardinality of the symmetric difference of two
relations, i.e., the number of tuples contained in exactly one of
two relations.  For preference relations, this coincides with the
<em>Kemeny-Snell</em> metric (Kemeny and Snell, 1962).  For linear
orders, it gives Kendall's <code class="reqn">\tau</code> metric (Diaconis, 1988).
</p>
<p>Can also be referred to as <code>"SD"</code>.
</p>
<p>Only applicable to crisp relations.
</p>
</dd>
<dt><code>"manhattan"</code></dt><dd><p>the Manhattan distance between the
incidences.
</p>
</dd>
<dt><code>"euclidean"</code></dt><dd><p>the Euclidean distance between the
incidences.
</p>
</dd>
<dt><code>"CS"</code></dt><dd><p>Cook-Seiford distance, a generalization of the
distance function of Cook and Seiford (1978).  Let the generalized
ranks of an object <code class="reqn">a</code> in the (first) domain of an
endorelation <code class="reqn">R</code> be defined as the number of objects <code class="reqn">b</code>
dominating <code class="reqn">a</code> (i.e., for which <code class="reqn">a R b</code> and not <code class="reqn">b R
      a</code>), plus half the number of objects <code class="reqn">b</code> equivalent to <code class="reqn">a</code>
(i.e., for which <code class="reqn">a R b</code> and <code class="reqn">b R a</code>).  For preference
relations, this gives the usual Kendall ranks arranged according
to decreasing preference (and averaged for ties).  Then the
generalized Cook-Seiford distance is defined as the <code class="reqn">l_1</code>
distance between the generalized ranks.  For linear orders, this
gives Spearman's footrule metric (Diaconis, 1988).
</p>
<p>Only applicable to crisp endorelations.
</p>
</dd>
<dt><code>"CKS"</code></dt><dd><p>Cook-Kress-Seiford distance, a generalization of
the distance function of Cook, Kress and Seiford (1986).  For each
pair of objects <code class="reqn">a</code> and <code class="reqn">b</code> in an endorelation <code class="reqn">R</code>, we
can have <code class="reqn">a R b</code> and not <code class="reqn">b R a</code> or vice versa (cases of
&ldquo;strict preference&rdquo;), <code class="reqn">a R b</code> and <code class="reqn">b R a</code> (the case
of &ldquo;indifference&rdquo;), or neither <code class="reqn">a R b</code> nor <code class="reqn">b R a</code>
(the case of &ldquo;incomparability&rdquo;).  (Only the last two are
possible if <code class="reqn">a = b</code>.)  The distance by Cook, Kress and Seiford
puts indifference as the metric centroid between both preference
cases and incomparability (i.e., indifference is at distance one
from the other three, and each of the other three is at distance
two from the others).  The generalized Cook-Kress-Seiford distance
is the paired comparison distance (i.e., a metric) based on these
distances between the four paired comparison cases.  (Formula 3 in
the reference must be slightly modified for the generalization
from partial rankings to arbitrary endorelations.)
</p>
<p>Only applicable to crisp endorelations.
</p>
</dd>
<dt><code>"score"</code></dt><dd><p>score-based distance.  This computes
<code class="reqn">\Delta(s(x), s(y))</code> for suitable score and distance functions
<code class="reqn">s</code> and <code class="reqn">\Delta</code>, respectively.  These can be specified by
additional arguments <code>score</code> and <code>Delta</code>.  If
<code>score</code> is a character string, it is taken as the method for
<code><a href="#topic+relation_scores">relation_scores</a></code>.  Otherwise, if given it must be a
function giving the score function itself.  If <code>Delta</code> is a
number <code class="reqn">p \ge 1</code>, the usual <code class="reqn">l_p</code> distance is used.
Otherwise, it must be a function giving the distance function.
The defaults correspond to using the default relation scores and
<code class="reqn">p = 1</code>, which for linear orders gives Spearman's footrule
distance.
</p>
<p>Only applicable to endorelations.
</p>
</dd>
<dt><code>"Jaccard"</code></dt><dd><p>Jaccard distance: 1 minus the ratio of the
cardinalities of the intersection and the union of the relations.
</p>
</dd>
<dt><code>"PC"</code></dt><dd><p>(generalized) paired comparison distance.  This
generalizes the symdiff and CKS distances to use a general set of
discrepancies <code class="reqn">\delta_{kl}</code> between the possible paired
comparison results with <code class="reqn">a,b</code>/<code class="reqn">b,a</code> incidences 0/0, 1/0,
0/1, and 1/1 numbered from 1 to 4 (in a preference context with a
<code class="reqn">\le</code> encoding, these correspond to incompatibility, strict
<code class="reqn">&lt;</code> and <code class="reqn">&gt;</code> preference, and indifference), with
<code class="reqn">\delta_{kl}</code> the discrepancy between possible results <code class="reqn">k</code>
and <code class="reqn">l</code>.  The distance is then obtained as the sum of the
discrepancies from the paired comparisons of distinct objects,
plus half the sum of discrepancies from the comparisons of
identical objects (for which the only possible results are
incomparability and indifference). 
The distance is a metric provided that the <code class="reqn">\delta_{kl}</code>
satisfy the metric conditions (non-negativity and zero iff
<code class="reqn">k = l</code>, symmetry and sub-additivity).
</p>
<p>The discrepancies can be specified via the additional argument
<code>delta</code>, either as a numeric vector of length 6 with the
non-redundant values <code class="reqn">\delta_{21}, \delta_{31}, \delta_{41},
      \delta_{32}, \delta_{42}, \delta_{43}</code>, or as a character string
partially matching one of the following built-in discrepancies
with corresponding parameter vector <code class="reqn">\delta</code>:
</p>

<dl>
<dt><code>"symdiff"</code></dt><dd><p>symmetric difference distance, with
discrepancy between distinct results two between either
opposite strict preferences or indifference and
incomparability, and one otherwise:
<code class="reqn">\delta = (1, 1, 2, 2, 1, 1)</code>
(default).
</p>
<p>Can also be referred to as <code>"SD"</code>.	  
</p>
</dd>
<dt><code>"CKS"</code></dt><dd><p>Cook-Kress-Seiford distance, see above:
<code class="reqn">\delta = (2, 2, 1, 2, 1, 1)</code>.</p>
</dd>
<dt><code>"EM"</code></dt><dd><p>the distance obtained from the generalization
of the Kemeny-Snell distance for complete rankings to partial
rankings introduced in Emond and Mason (2000).  This uses a
discrepancy of two for opposite strict preferences, and one
for all other distinct results: 
<code class="reqn">\delta = (1, 1, 1, 2, 1, 1)</code>.</p>
</dd>
<dt><code>"JMB"</code></dt><dd><p>the distance with parameters as suggested by
Jabeur, Martel and Ben Khélifa (2004):
<code class="reqn">\delta = (4/3, 4/3, 4/3, 5/3, 1, 1)</code>.</p>
</dd>
<dt><code>"discrete"</code></dt><dd><p>the discrete metric on the set of paired
comparison results:
<code class="reqn">\delta = (1, 1, 1, 1, 1, 1)</code>.</p>
</dd>
</dl>

<p>Only applicable to crisp endorelations.
</p>
</dd>
</dl>

<p>Methods <code>"symdiff"</code>, <code>"manhattan"</code>, <code>"euclidean"</code> and
<code>"Jaccard"</code> take an additional logical argument <code>na.rm</code>: if
true (default: false), tuples with missing memberships are excluded in
the dissimilarity computations.
</p>


<h3>Value</h3>

<p>If <code>y</code> is <code>NULL</code>, an object of class <code><a href="stats.html#topic+dist">dist</a></code>
containing the dissimilarities between all pairs of elements of
<code>x</code>.  Otherwise, a matrix with the dissimilarities between the
elements of <code>x</code> and the elements of <code>y</code>.
</p>


<h3>References</h3>

<p>W. D. Cook, M. Kress and L. M. Seiford (1986),
Information and preference in partial orders: a bimatrix
representation.
<em>Psychometrika</em> <b>51</b>/2, 197&ndash;207.
<a href="https://doi.org/10.1007/BF02293980">doi:10.1007/BF02293980</a>.
</p>
<p>W. D. Cook and L. M. Seiford (1978),
Priority ranking and consensus formation.
<em>Management Science</em>, <b>24</b>/16, 1721&ndash;1732.
<a href="https://doi.org/10.1287/mnsc.24.16.1721">doi:10.1287/mnsc.24.16.1721</a>.
</p>
<p>P. Diaconis (1988),
<em>Group Representations in Probability and Statistics</em>.
Institute of Mathematical Statistics: Hayward, CA.
</p>
<p>E. J. Emond and D. W. Mason (2000),
<em>A new technique for high level decision support</em>.
Technical Report ORD Project Report PR2000/13, Operational
Research Division, Department of National Defence, Canada.

</p>
<p>K. Jabeur, J.-M. Martel and S. Ben Khélifa (2004).
A distance-based collective preorder integrating the relative
importance of the groups members.
<em>Group Decision and Negotiation</em>, <b>13</b>, 327&ndash;349.
<a href="https://doi.org/10.1023/B%3AGRUP.0000042894.00775.75">doi:10.1023/B:GRUP.0000042894.00775.75</a>.
</p>
<p>J. G. Kemeny and J. L. Snell (1962),
<em>Mathematical Models in the Social Sciences</em>,
chapter &ldquo;Preference Rankings: An Axiomatic Approach&rdquo;.
MIT Press: Cambridge.
</p>

<hr>
<h2 id='domain'>Relation Domain, Arity, and Size</h2><span id='topic+relation_arity'></span><span id='topic+relation_domain'></span><span id='topic+relation_domain_names'></span><span id='topic+relation_size'></span>

<h3>Description</h3>

<p>Determine the domain, domain names, arity, or size of a relation or a
relation ensemble.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relation_arity(x)
relation_domain(x)
relation_domain_names(x)
relation_size(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="domain_+3A_x">x</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object inheriting from class <code><a href="#topic+relation">relation</a></code> or
<code><a href="#topic+relation_ensemble">relation_ensemble</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For determining the domain, an object of class <code>relation_domain</code>,
inheriting from <code><a href="sets.html#topic+tuple">tuple</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="sets.html#topic+tuple">tuple</a>()</code>;
<code><a href="#topic+relation">relation</a>()</code>;
<code><a href="#topic+relation_domain+3C-">relation_domain&lt;-</a>()</code> and
<code><a href="#topic+relation_domain_names+3C-">relation_domain_names&lt;-</a>()</code>
for modifying the domain and domain names of a relation, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A simple relation:
R &lt;- as.relation(c(A = 1, B = 2, C = 3))
relation_incidence(R)
relation_arity(R)
relation_domain(R)
relation_domain_names(R)
relation_size(R)
</code></pre>

<hr>
<h2 id='elements'>Elements of Relation Domains</h2><span id='topic+relation_elements'></span>

<h3>Description</h3>

<p>Obtain elements of endorelation domains which have certain properties.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relation_elements(x, which, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="elements_+3A_x">x</code></td>
<td>
<p>an endorelation.</p>
</td></tr>
<tr><td><code id="elements_+3A_which">which</code></td>
<td>
<p>a character string specifying the property to be tested
for.  Currently, one of <code>"minimal"</code>, <code>"first"</code>,
<code>"last"</code>, or <code>"maximal"</code>, or a unique abbreviation
thereof.</p>
</td></tr>
<tr><td><code id="elements_+3A_...">...</code></td>
<td>
<p>additional arguments to be employed in the property tests.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">R</code> be an endorelation with domain <code class="reqn">(X, X)</code> and consider
elements <code class="reqn">x</code> and <code class="reqn">y</code> of <code class="reqn">X</code>.  We say that <code class="reqn">x</code> is
</p>

<dl>
<dt>minimal:</dt><dd><p>there is no <code class="reqn">y \ne x</code> with <code class="reqn">y R x</code>.</p>
</dd>
<dt>a first element:</dt><dd><p><code class="reqn">x R y</code> for all <code class="reqn">y \ne x</code>.</p>
</dd>
<dt>a last element:</dt><dd><p><code class="reqn">y R x</code> for all <code class="reqn">y \ne x</code>.</p>
</dd>
<dt>maximal:</dt><dd><p>there is no <code class="reqn">y \ne x</code> with <code class="reqn">x R y</code>.</p>
</dd>
</dl>

<p>When computing the tests for the above properties, an additional
<code>na.rm</code> argument can be given to control the handling of missing
incidences.  By default, these are treated as false, to the effect
that they invalidate &ldquo;for all&rdquo; tests (corresponding to
<code>na.rm = FALSE</code>) and pass the &ldquo;there is no&rdquo; tests
(corresponding to <code>na.rm = TRUE</code>).
</p>


<h3>Value</h3>

<p>A set with the elements having the specified property.
</p>

<hr>
<h2 id='ensemble'>Relation Ensembles</h2><span id='topic+relation_ensemble'></span><span id='topic+as.relation_ensemble'></span><span id='topic+is.relation_ensemble'></span>

<h3>Description</h3>

<p>Creation and manipulation of relation ensembles.</p>


<h3>Usage</h3>

<pre><code class='language-R'>relation_ensemble(..., list = NULL)
as.relation_ensemble(x)
is.relation_ensemble(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ensemble_+3A_...">...</code></td>
<td>
<p><span class="rlang"><b>R</b></span> objects representing relations, or coercible to such.</p>
</td></tr>
<tr><td><code id="ensemble_+3A_list">list</code></td>
<td>
<p>a list of <span class="rlang"><b>R</b></span> objects as in <code>...</code>.</p>
</td></tr>
<tr><td><code id="ensemble_+3A_x">x</code></td>
<td>
<p>for coercion with <code>as.relation_ensemble()</code>, an <span class="rlang"><b>R</b></span> object
as in <code>...</code>; for testing with <code>is.relation_ensemble()</code>,
an arbitrary <span class="rlang"><b>R</b></span> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>relation_ensemble()</code> creates non-empty &ldquo;relation
ensembles&rdquo;, i.e., collections of relations <code class="reqn">R_i = (D, G_i)</code> with
the same domain <code class="reqn">D</code> and possibly different graphs <code class="reqn">G_i</code>.
</p>
<p>Such ensembles are implemented as suitably classed lists of relation
objects, making it possible to use <code>lapply()</code> for computations on
the individual relations in the ensemble.  Available methods for
relation ensembles include those for subscripting, <code>c()</code>,
<code>t()</code>, <code>rep()</code>, and <code>print()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Cetacea")
## Consider each variable an equivalence relation on the objects.
## Note that 2 variables (LACHRYMAL_AND_JUGAL_BONES and HEAD_BONES) have
## missing values, and hence are excluded.
ind &lt;- sapply(Cetacea, function(s) all(!is.na(s)))
relations &lt;- as.relation_ensemble(Cetacea[, ind])
## This gives a relation ensemble of length 14 (number of complete
## variables in the data set).
print(relations)
## Are there any duplicated relations?
any(duplicated(relations))
## Replicate and combine ...
thrice &lt;- c(rep(relations, 2), relations)
## Extract unique elements again:
all.equal(unique(thrice), relations)
## Note that unique() does not preserve attributes, and hence names.
## In case we want otherwise:
all.equal(thrice[!duplicated(thrice)], relations)
## Subscripting:
relation_dissimilarity(relations[1 : 2], relations["CLASS"])
## Which relation is "closest" to the classification?
d &lt;- relation_dissimilarity(relations)
sort(as.matrix(d)[, "CLASS"])[-1]
</code></pre>

<hr>
<h2 id='Felines'>Felines Data</h2><span id='topic+Felines'></span>

<h3>Description</h3>

<p>A data set with 14 variables on 30 different types of felines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Felines")
</code></pre>


<h3>Format</h3>

<p>A data frame with 30 observations on 14 categorical variables (the
first 10 morphological, the last 4 behavioral), with names in French
and numeric levels as in the reference.  Names, descriptions in French
and English and the numbers of levels are as follows.
</p>

<dl>
<dt><code>TYPPEL</code>:</dt><dd><p>Aspect du pelage; coat; 4.</p>
</dd>
<dt><code>LONGPOIL</code>:</dt><dd><p>Fourrure; fur; 2.</p>
</dd>
<dt><code>OREILLES</code>:</dt><dd><p>Oreilles; ears; 2.</p>
</dd>
<dt><code>TAILLE</code>:</dt><dd><p>Taille au garrot; waist; 3.</p>
</dd>
<dt><code>POIDS</code>:</dt><dd><p>Poids; weight; 3.</p>
</dd>
<dt><code>LONGUEUR</code>:</dt><dd><p>Longueur du corps; body length; 3.</p>
</dd>
<dt><code>QUEUE</code>:</dt><dd><p>Longueur de la queue; tail length; 3.</p>
</dd>
<dt><code>DENTS</code>:</dt><dd><p>Canines développées; carnassials; 2.</p>
</dd>
<dt><code>LARYNX</code>:</dt><dd><p>Os hyaoide; larynx; 2.</p>
</dd>    
<dt><code>RETRACT</code>:</dt><dd><p>Griffes rétractiles; retractible claws; 2.</p>
</dd>
<dt><code>COMPORT</code>:</dt><dd><p>Comportement prédateur; predatory behavior;
3.</p>
</dd> 
<dt><code>TYPPROIE</code>:</dt><dd><p>Type de la proie; type of prey; 3.</p>
</dd>
<dt><code>ARBRES</code>:</dt><dd><p>Monte ou non aux arbres; climbs trees or not; 2.</p>
</dd>
<dt><code>CHASSE</code>:</dt><dd><p>Chasse (courre ou affut); chases via chivy or
ambush; 2.</p>
</dd>
</dl>



<h3>Source</h3>

<p>F. Marcotorchino and P. Michaud (1982),
Agregation de similarités en classification automatique.
<em>Revue de Statistique Appliquée</em>, <b>30</b>(2), 21&ndash;44.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Felines")
summary(Felines)
</code></pre>

<hr>
<h2 id='graph'>Relation Graph</h2><span id='topic+relation_graph'></span>

<h3>Description</h3>

<p>Determine the graph of a relation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relation_graph(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="graph_+3A_x">x</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object inheriting from class <code><a href="#topic+relation">relation</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>relation_graph</code>, inheriting from
<code><a href="sets.html#topic+set">set</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="sets.html#topic+set">set</a>()</code>;
<code><a href="#topic+relation">relation</a>()</code>;
<code><a href="#topic+relation_graph+3C-">relation_graph&lt;-</a>()</code> for modifying the graph.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## A simple relation:
R &lt;- as.relation(c(A = 1, B = 2, C = 3))
relation_graph(R)
</code></pre>

<hr>
<h2 id='impute'>Impute relations</h2><span id='topic+relation_impute'></span>

<h3>Description</h3>

<p>Impute missing incidences in relations by averaging all possible
completions within a specified family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relation_impute(x, method = NULL, control = list(), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="impute_+3A_x">x</code></td>
<td>
<p>an endorelation or an ensemble of endorelations.</p>
</td></tr>
<tr><td><code id="impute_+3A_method">method</code></td>
<td>
<p>character string specifying the method to be used (see
<b>Details</b>).  If <code>NULL</code>, it is guessed from the
relation with missing <em>objects</em> removed.</p>
</td></tr>
<tr><td><code id="impute_+3A_control">control</code></td>
<td>
<p>named list of control arguments. Currently, only
<code>n</code> is accepted by the <code>any/<var>F</var></code> methods, indicating
the number of solutions to be returned. Default is 1; <code>"all"</code>
or <code>NA</code> will generate all possible completions. Note that
<code>n</code> is currently ignored if <code>x</code> is a relation ensemble.</p>
</td></tr>
<tr><td><code id="impute_+3A_...">...</code></td>
<td>
<p>named list of control arguments, overriding the ones
in <code>control</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Endorelations with missing elements (i.e., whose incidence is
<code>NA</code>) are imputed using one of the methods described as follows.
</p>

<dl>
<dt><code>"omit"</code></dt><dd><p>Missing incidences are replaced by zeros, i.e.,
the corresponding elements are removed from the graph.</p>
</dd>
<dt><code>"any/<var>F</var>"</code></dt><dd><p>The incidences are replaced by
arbitrary values suitable for family <var>F</var>, with possible values:
</p>

<dl>
<dt><code>G</code></dt><dd><p>General (unrestricted) relations.</p>
</dd>
<dt><code>L</code></dt><dd><p>Linear orders.</p>
</dd>
<dt><code>W</code></dt><dd><p>Weak orders.</p>
</dd>
<dt><code>O</code></dt><dd><p>Partial orders.</p>
</dd>
</dl>

<p><code>L</code>, <code>W</code>, and <code>O</code> can optionally be complemented by
<code>/first</code> or <code>/last</code> to further restrict imputed elements
to be placed on top or bottom of the given ordering.
</p>
</dd>
<dt><code>"average/<var>F</var>"</code></dt><dd><p>Computes the relation with average
incidences, based on all possible completions as indicated for the
<code>any/<var>F</var></code> methods. Note that these completions are not
explicitly generated to compute the averages, and that the
resulting relation will typically be fuzzy.</p>
</dd>
</dl>



<h3>Value</h3>

<p>If <code>x</code> is an ensemble or more than one solution is requested
using the <code>n</code> control argument: an ensemble
of endorelations.  An endorelation otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create a relation with a missing object
R &lt;- ranking(1:2, 1:3)
print(R)
R &lt;- as.relation(R)

## find all suitable completions within L
ens &lt;- relation_impute(R, method = "any/L", n = "all")
lapply(ens, as.ranking)
if(require("Rgraphviz")) plot(ens)

## find 3 suitable partial orders
ens &lt;- relation_impute(R, method = "any/O", n = 3)
lapply(ens, relation_incidence)
if(require("Rgraphviz")) plot(ens)

## compute average completion
R1 &lt;- relation_impute(R, method = "average/O")
relation_incidence(R1)

## check correctness of averaging
R2 &lt;- mean(relation_impute(R, "any/O", n = "all"))
stopifnot(all.equal(R1, R2))
</code></pre>

<hr>
<h2 id='incidence'>Relation Incidences</h2><span id='topic+relation_incidence'></span>

<h3>Description</h3>

<p>Determine the incidences of a relation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relation_incidence(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="incidence_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code><a href="#topic+relation">relation</a></code>.</p>
</td></tr>
<tr><td><code id="incidence_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the labeling function used
for creating the dimnames of the incidence matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For a <code class="reqn">k</code>-ary relation, a <code class="reqn">k</code>-dimensional numeric array with
values in the unit interval inheriting from class
<code>relation_incidence</code> whose elements give the memberships of the
corresponding <code class="reqn">k</code>-tuples are contained in the relation (for a
crisp relation, a binary (0/1) array with elements indicating whether
the corresponding tuples are contained in the relation or not).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+relation">relation</a>()</code>;
<code><a href="#topic+relation_incidence+3C-">relation_incidence&lt;-</a>()</code> for modifying the incidences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>R &lt;- as.relation(c(A = 1, B = 2, C = 3))
relation_incidence(R)
</code></pre>

<hr>
<h2 id='pclust'>Prototype-Based Partitions of Relations</h2><span id='topic+relation_pclust'></span>

<h3>Description</h3>

<p>Compute prototype-based partitions of a relation ensemble by minimizing
<code class="reqn">\sum w_b u_{bj}^m d(x_b, p_j)^e</code>, the sum of the case-weighted and
membership-weighted <code class="reqn">e</code>-th powers of the dissimilarities between
the elements <code class="reqn">x_b</code> of the ensemble and the prototypes <code class="reqn">p_j</code>,
for suitable dissimilarities <code class="reqn">d</code> and exponents <code class="reqn">e</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relation_pclust(x, k, method, m = 1, weights = 1,
                control = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pclust_+3A_x">x</code></td>
<td>
<p>an ensemble of relations (see
<code><a href="#topic+relation_ensemble">relation_ensemble</a>()</code>),
or something which can be coerced to this.</p>
</td></tr>
<tr><td><code id="pclust_+3A_k">k</code></td>
<td>
<p>an integer giving the number of classes to be used in the
partition.</p>
</td></tr>
<tr><td><code id="pclust_+3A_method">method</code></td>
<td>
<p>the consensus method to be employed, see
<code><a href="#topic+relation_consensus">relation_consensus</a>()</code>.</p>
</td></tr>
<tr><td><code id="pclust_+3A_m">m</code></td>
<td>
<p>a number not less than 1 controlling the softness of the
partition (as the &ldquo;fuzzification parameter&rdquo; of the fuzzy
<code class="reqn">c</code>-means algorithm).  The default value of 1 corresponds to
hard partitions obtained from a generalized <code class="reqn">k</code>-means problem;
values greater than one give partitions of increasing softness
obtained from a generalized fuzzy <code class="reqn">c</code>-means problem.</p>
</td></tr>
<tr><td><code id="pclust_+3A_weights">weights</code></td>
<td>
<p>a numeric vector of non-negative case weights.
Recycled to the number of elements in the ensemble given by <code>x</code>
if necessary.</p>
</td></tr>
<tr><td><code id="pclust_+3A_control">control</code></td>
<td>
<p>a list of control parameters.  See <b>Details</b>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code class="reqn">m = 1</code>, a generalization of the Lloyd-Forgy variant of the
<code class="reqn">k</code>-means algorithm is used, which iterates between reclassifying
objects to their closest prototypes, and computing new prototypes as
consensus relations (generalized &ldquo;central relations&rdquo;, Régnier
(1965)) for the classes.  This procedure was proposed in Gaul and
Schader (1988) as the &ldquo;Clusterwise Aggregation of Relations&rdquo;
(CAR).
</p>
<p>For <code class="reqn">m &gt; 1</code>, a generalization of the fuzzy <code class="reqn">c</code>-means recipe
is used, which alternates between computing optimal memberships for
fixed prototypes, and computing new prototypes as the consensus
relations for the classes.
</p>
<p>This procedure is repeated until convergence occurs, or the maximal
number of iterations is reached.
</p>
<p>Consensus relations are computed using
<code><a href="#topic+relation_consensus">relation_consensus</a>()</code>.
</p>
<p>Available control parameters are as follows.
</p>

<dl>
<dt><code>maxiter</code></dt><dd><p>an integer giving the maximal number of
iterations to be performed.  Defaults to 100.</p>
</dd>
<dt><code>reltol</code></dt><dd><p>the relative convergence tolerance.  Defaults
to <code>sqrt(.Machine$double.eps)</code>.</p>
</dd>
<dt><code>control</code></dt><dd><p>control parameters to be used in
<code><a href="#topic+relation_consensus">relation_consensus</a>()</code>.</p>
</dd>
</dl>

<p>The dissimilarities <code class="reqn">d</code> and exponent <code class="reqn">e</code> are implied by the
consensus method employed, and inferred via a registration mechanism
currently only made available to built-in consensus methods.  For the
time being, all optimization-based consensus methods use the symmetric
difference dissimilarity (see <code><a href="#topic+relation_dissimilarity">relation_dissimilarity</a>()</code>)
for <code class="reqn">d</code> and <code class="reqn">e = 1</code>.
</p>
<p>The fixed point approach employed is a heuristic which cannot be
guaranteed to find the global minimum.  Standard practice would
recommend to use the best solution found in &ldquo;sufficiently many&rdquo;
replications of the base algorithm.
</p>


<h3>Value</h3>

<p>An object of class <code><a href="clue.html#topic+cl_partition">cl_partition</a></code>.
</p>


<h3>References</h3>

<p>S. Régnier (1965).
Sur quelques aspects mathématiques des problèmes de classification
automatique.
<em>ICC Bulletin</em>, <b>4</b>, 175&ndash;191.
</p>
<p>W. Gaul and M. Schader (1988).
Clusterwise aggregation of relations.
<em>Applied Stochastic Models and Data Analysis</em>, <b>4</b>, 273&ndash;282.
<a href="https://doi.org/10.1002/asm.3150040406">doi:10.1002/asm.3150040406</a>.
</p>

<hr>
<h2 id='plot'>Visualize Relations</h2><span id='topic+plot.relation'></span><span id='topic+plot.relation_ensemble'></span>

<h3>Description</h3>

<p>Visualize certain crisp endorelations by plotting a Hasse Diagram of
their transitive reduction. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'relation'
plot(x,
     attrs = list(graph = list(rankdir = "BT"),
                  edge = list(arrowsize = NULL),
                  node = list(shape = "rectangle",
                              fixedsize = FALSE)),
     limit = 6L,
     labels = NULL,
     main = NULL,
     type = c("simplified", "raw"),
     ...)

## S3 method for class 'relation_ensemble'
plot(x,
     attrs = list(list(graph = list(rankdir = "BT"),
                       edge = list(arrowsize = NULL),
                       node = list(shape = "rectangle",
                                   fixedsize = FALSE))),
     type = "simplified",
     limit = 6L,
     labels = NULL,
     ..., 
     layout = NULL, main = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object inheriting from class <code><a href="#topic+relation">relation</a></code> or
<code><a href="#topic+relation_ensemble">relation_ensemble</a></code>.</p>
</td></tr>
<tr><td><code id="plot_+3A_attrs">attrs</code></td>
<td>
<p>argument passed to the plot method for class
<code><a href="graph.html#topic+graphNEL">graphNEL</a></code>.
</p>
<p>Note that for the <code>relation_ensemble</code> method, it is a
<em>list</em> of such objects, recycled as needed.</p>
</td></tr>
<tr><td><code id="plot_+3A_type">type</code></td>
<td>
<p>character vector of either &quot;simplified&quot; or &quot;raw&quot;
strings, one for each relation plotted. (See details.)</p>
</td></tr>
<tr><td><code id="plot_+3A_limit">limit</code></td>
<td>
<p>Argument passed to the labeling function creating default
labels for the nodes (see <code><a href="sets.html#topic+LABELS">LABELS</a>()</code>).
Recycled as needed for relation ensembles.</p>
</td></tr>
<tr><td><code id="plot_+3A_labels">labels</code></td>
<td>
<p>Optional list of character vectors defining unique
labels for the nodes. List of such lists for relation ensembles.</p>
</td></tr>
<tr><td><code id="plot_+3A_layout">layout</code></td>
<td>
<p>integer vector of length 2 specifying the number of rows
and columns of the screen layout.  If <code>NULL</code>, the layout is
square.</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p>Other arguments passed to the
<code><a href="graph.html#topic+graphNEL">graphNEL</a></code> plot method.</p>
</td></tr>
<tr><td><code id="plot_+3A_main">main</code></td>
<td>
<p>character vector used for the main title(s). If <code>NULL</code>,
the title(s) is (are) set to the type of the visualized relation(s).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Visualization requires that package <span class="pkg">Rgraphviz</span> is available. If
type is &quot;simplified&quot; (default), the transitive reduction is
first computed to reduce visual complexity (especially for transitive
relations).
For partial orders, a Hasse diagram is plotted.  In case
of (acyclic) transitive complete relations (i.e., weak orders, preferences), the dual is plotted.
For all other acyclic relations, the asymmetric part is plotted. (Note that
the default settings in these cases create a diagram with nodes ordered bottom-up and
with no arrows.) For cyclic relations, a raw graph (with arrows) of
the corresponding transitive
reduction is computed. If type is &quot;raw&quot;, a directed graph without
any transformation is plotted from the relation.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+relation">relation</a>()</code>,
<code><a href="#topic+transitive_reduction">transitive_reduction</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require("sets")				# set() etc.
if(require("Rgraphviz")) {
  ## simple example
  plot(as.relation(1 : 5))

  ## inclusion on a power set:
  ps &lt;- 2 ^ set("a", "b", "c")
  inc &lt;- set_outer(ps, set_is_subset)
  R &lt;- relation(incidence = inc)
  plot(relation_ensemble(R, R), type = c("simplified", "raw"))
}
</code></pre>

<hr>
<h2 id='predicates'>Relation Predicates</h2><span id='topic+predicates'></span><span id='topic+relation_is'></span><span id='topic+relation_is_Euclidean'></span><span id='topic+relation_is_Ferrers'></span><span id='topic+relation_is_acyclic'></span><span id='topic+relation_is_antisymmetric'></span><span id='topic+relation_is_asymmetric'></span><span id='topic+relation_is_bijective'></span><span id='topic+relation_is_binary'></span><span id='topic+relation_is_complete'></span><span id='topic+relation_is_coreflexive'></span><span id='topic+relation_is_crisp'></span><span id='topic+relation_is_cyclic'></span><span id='topic+relation_is_endorelation'></span><span id='topic+relation_is_equivalence'></span><span id='topic+relation_is_functional'></span><span id='topic+relation_is_homogeneous'></span><span id='topic+relation_is_injective'></span><span id='topic+relation_is_interval_order'></span><span id='topic+relation_is_irreflexive'></span><span id='topic+relation_is_left_total'></span><span id='topic+relation_is_linear_order'></span><span id='topic+relation_is_match'></span><span id='topic+relation_is_negatively_transitive'></span><span id='topic+relation_is_partial_order'></span><span id='topic+relation_is_preference'></span><span id='topic+relation_is_preorder'></span><span id='topic+relation_is_quasiorder'></span><span id='topic+relation_is_quasitransitive'></span><span id='topic+relation_is_quaternary'></span><span id='topic+relation_is_reflexive'></span><span id='topic+relation_is_right_total'></span><span id='topic+relation_is_semiorder'></span><span id='topic+relation_is_semitransitive'></span><span id='topic+relation_is_strict_linear_order'></span><span id='topic+relation_is_strict_partial_order'></span><span id='topic+relation_is_strongly_complete'></span><span id='topic+relation_is_surjective'></span><span id='topic+relation_is_symmetric'></span><span id='topic+relation_is_ternary'></span><span id='topic+relation_is_tournament'></span><span id='topic+relation_is_transitive'></span><span id='topic+relation_is_trichotomous'></span><span id='topic+relation_is_weak_order'></span><span id='topic+relation_has_missings'></span>

<h3>Description</h3>

<p>Predicate functions for testing for binary relations and
endorelations, and special kinds thereof.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relation_is(x, predicate, ...)
relation_is_Euclidean(x, na.rm = FALSE)
relation_is_Ferrers(x, na.rm = FALSE)
relation_is_acyclic(x)
relation_is_antisymmetric(x, na.rm = FALSE)
relation_is_asymmetric(x, na.rm = FALSE)
relation_is_bijective(x)
relation_is_binary(x)
relation_is_complete(x, na.rm = FALSE)
relation_is_coreflexive(x, na.rm = FALSE)
relation_is_crisp(x, na.rm = FALSE)
relation_is_cyclic(x)
relation_is_endorelation(x)
relation_is_equivalence(x, na.rm = FALSE)
relation_is_functional(x)
relation_is_homogeneous(x)
relation_is_injective(x)
relation_is_interval_order(x, na.rm = FALSE)
relation_is_irreflexive(x, na.rm = FALSE)
relation_is_left_total(x)
relation_is_linear_order(x, na.rm = FALSE)
relation_is_match(x, na.rm = FALSE)
relation_is_negatively_transitive(x, na.rm = FALSE)
relation_is_partial_order(x, na.rm = FALSE)
relation_is_preference(x, na.rm = FALSE)
relation_is_preorder(x, na.rm = FALSE)
relation_is_quasiorder(x, na.rm = FALSE)
relation_is_quasitransitive(x, na.rm = FALSE)
relation_is_quaternary(x)
relation_is_reflexive(x, na.rm = FALSE)
relation_is_right_total(x)
relation_is_semiorder(x, na.rm = FALSE)
relation_is_semitransitive(x, na.rm = FALSE)
relation_is_strict_linear_order(x, na.rm = FALSE)
relation_is_strict_partial_order(x, na.rm = FALSE)
relation_is_strongly_complete(x, na.rm = FALSE)
relation_is_surjective(x)
relation_is_symmetric(x, na.rm = FALSE)
relation_is_ternary(x)
relation_is_tournament(x, na.rm = FALSE)
relation_is_transitive(x, na.rm = FALSE)
relation_is_trichotomous(x, na.rm = FALSE)
relation_is_weak_order(x, na.rm = FALSE)
relation_has_missings(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predicates_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code><a href="#topic+relation">relation</a></code>.</p>
</td></tr>
<tr><td><code id="predicates_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical indicating whether tuples with missing
memberships are excluded in the predicate computations.</p>
</td></tr>
<tr><td><code id="predicates_+3A_predicate">predicate</code></td>
<td>
<p>character vector matching one of the following (see <b>details</b>):
<code>"binary"</code>,
<code>"ternary"</code>,
<code>"quaternary"</code>,
<code>"left_total"</code>,
<code>"right_total"</code>,
<code>"surjective"</code>,
<code>"functional"</code>,
<code>"injective"</code>,
<code>"bijective"</code>,
<code>"endorelation"</code>,
<code>"homogeneous"</code>,
<code>"crisp"</code>,
<code>"complete"</code>,
<code>"match"</code>,
<code>"strongly_complete"</code>,
<code>"reflexive"</code>,
<code>"irreflexive"</code>,
<code>"coreflexive"</code>,
<code>"symmetric"</code>,
<code>"asymmetric"</code>,
<code>"antisymmetric"</code>,
<code>"transitive"</code>,
<code>"negatively_transitive"</code>,
<code>"quasitransitive"</code>,
<code>"Ferrers"</code>,
<code>"semitransitive"</code>,
<code>"trichotomous"</code>,
<code>"Euclidean"</code>,
<code>"equivalence"</code>,
<code>"weak_order"</code>,
<code>"preference"</code>,
<code>"preorder"</code>,
<code>"quasiorder"</code>,
<code>"partial_order"</code>,
<code>"linear_order"</code>,
<code>"strict_partial_order"</code>,
<code>"strict_linear_order"</code>,
<code>"tournament"</code>,
<code>"interval_order"</code>,
<code>"semiorder"</code>,
<code>"acyclic"</code>
<code>"cyclic"</code>
</p>
</td></tr>
<tr><td><code id="predicates_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the predicate functions
(currently, only <code>na.rm</code> for most predicates).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This help page documents the predicates currently available. Note that
the preferred way is to use the meta-predicate function
<code>relation_is(x, "FOO")</code> instead of the individual predicates
<code>relation_is_FOO(x)</code> since the latter will become deprecated in
future releases.
</p>
<p>A binary relation is a relation with arity 2.
</p>
<p>A relation <code class="reqn">R</code> on a set <code class="reqn">X</code> is called
<em>homogeneous</em> iff <code class="reqn">D(R) = (X, \dots, X)</code>.
</p>
<p>An <em>endorelation</em> is a binary homogeneous relation.
</p>
<p>For a crisp binary relation, let us write <code class="reqn">x R y</code> iff <code class="reqn">(x, y)</code>
is contained in <code class="reqn">R</code>.
</p>
<p>A crisp binary relation <code class="reqn">R</code> is called
</p>

<dl>
<dt>left-total:</dt><dd><p>for all <code class="reqn">x</code> there is at least one <code class="reqn">y</code>
such that <code class="reqn">x R y</code>.</p>
</dd>
<dt>right-total:</dt><dd><p>for all <code class="reqn">y</code> there is at least one <code class="reqn">x</code>
such that <code class="reqn">x R y</code>.</p>
</dd>
<dt>functional:</dt><dd><p>for all <code class="reqn">x</code> there is at most one <code class="reqn">y</code>
such that <code class="reqn">x R y</code>.</p>
</dd>
<dt>surjective:</dt><dd><p>the same as right-total.</p>
</dd>
<dt>injective:</dt><dd><p>for all <code class="reqn">y</code> there is at most one <code class="reqn">x</code>
such that <code class="reqn">x R y</code>.</p>
</dd>
<dt>bijective:</dt><dd><p>left-total, right-total, functional and
injective.</p>
</dd>
</dl>

<p>A crisp endorelation <code class="reqn">R</code> is called
</p>

<dl>
<dt>reflexive:</dt><dd><p><code class="reqn">x R x</code> for all <code class="reqn">x</code>.</p>
</dd>
<dt>irreflexive:</dt><dd><p>there is no <code class="reqn">x</code> such that <code class="reqn">x R x</code>.</p>
</dd>
<dt>coreflexive:</dt><dd><p><code class="reqn">x R y</code> implies <code class="reqn">x = y</code>.</p>
</dd>
<dt>symmetric:</dt><dd><p><code class="reqn">x R y</code> implies <code class="reqn">y R x</code>.</p>
</dd>
<dt>asymmetric:</dt><dd><p><code class="reqn">x R y</code> implies that not <code class="reqn">y R x</code>.</p>
</dd>
<dt>antisymmetric:</dt><dd><p><code class="reqn">x R y</code> and <code class="reqn">y R x</code> imply that
<code class="reqn">x = y</code>.</p>
</dd>
<dt>transitive:</dt><dd><p><code class="reqn">x R y</code> and <code class="reqn">y R z</code> imply that
<code class="reqn">x R z</code>.</p>
</dd>
<dt>complete:</dt><dd><p>for all distinct <code class="reqn">x</code> and <code class="reqn">y</code>, <code class="reqn">x R y</code>
or <code class="reqn">y R x</code>.</p>
</dd>
<dt>strongly complete:</dt><dd><p>for all <code class="reqn">x</code> and <code class="reqn">y</code>, <code class="reqn">x R y</code>
or <code class="reqn">y R x</code> (i.e., complete and reflexive).</p>
</dd>
<dt>negatively transitive:</dt><dd><p>not <code class="reqn">x R y</code> and not <code class="reqn">y R z</code>
imply that not <code class="reqn">x R z</code>.</p>
</dd>
<dt>Ferrers:</dt><dd><p><code class="reqn">x R y</code> and <code class="reqn">z R w</code> imply <code class="reqn">x R w</code> or
<code class="reqn">y R z</code>.</p>
</dd>
<dt>semitransitive:</dt><dd><p><code class="reqn">x R y</code> and <code class="reqn">y R z</code> imply <code class="reqn">x R w</code>
or <code class="reqn">w R z</code>.</p>
</dd>
<dt>quasitransitive:</dt><dd>
<p><code class="reqn">x R y</code> and not <code class="reqn">y R x</code> and
<code class="reqn">y R z</code> and not <code class="reqn">z R y</code> imply
<code class="reqn">x R z</code> and not <code class="reqn">z R x</code>
(i.e., the asymmetric part of <code class="reqn">R</code> is transitive).</p>
</dd>
<dt>trichotomous:</dt><dd><p>exactly one of <code class="reqn">x R y</code>, <code class="reqn">y R x</code>, or
<code class="reqn">x = y</code> holds.</p>
</dd>
<dt>Euclidean:</dt><dd><p><code class="reqn">x R y</code> and <code class="reqn">x R z</code> imply <code class="reqn">y R z</code>.</p>
</dd>
<dt>acyclic:</dt><dd><p>the transitive closure of R is antisymmetric.</p>
</dd>
<dt>cyclic:</dt><dd><p>R is not acyclic.</p>
</dd>
</dl>

<p>Some combinations of these basic properties have special names
because of their widespread use:
</p>

<dl>
<dt>preorder:</dt><dd><p>reflexive and transitive.</p>
</dd>
<dt>quasiorder:</dt><dd><p>the same as preorder.</p>
</dd>
<dt>equivalence:</dt><dd><p>a symmetric preorder (reflexive, symmetric, and
transitive).</p>
</dd>
<dt>weak order:</dt><dd><p>a complete preorder (complete, reflexive, and
transitive).</p>
</dd>
<dt>preference:</dt><dd><p>the same as weak order.</p>
</dd>
<dt>partial order:</dt><dd><p>an antisymmetric preorder (reflexive,
antisymmetric, and transitive).</p>
</dd>
<dt>strict partial order:</dt><dd><p>irreflexive, antisymmetric, and
transitive, or equivalently: asymmetric and transitive).</p>
</dd>
<dt>linear order:</dt><dd><p>a complete partial order.</p>
</dd>
<dt>strict linear order:</dt><dd><p>a complete strict partial order.</p>
</dd>
<dt>match:</dt><dd><p>strongly complete.</p>
</dd>
<dt>tournament:</dt><dd><p>complete and asymmetric.</p>
</dd>
<dt>interval order:</dt><dd><p>complete and Ferrers.</p>
</dd>
<dt>semiorder:</dt><dd><p>a semitransitive interval order.</p>
</dd>
</dl>

<p>If <code class="reqn">R</code> is a weak order (&ldquo;(weak) preference relation&rdquo;),
<code class="reqn">I = I(R)</code> defined by <code class="reqn">x I y</code> iff <code class="reqn">x R y</code> and <code class="reqn">y R x</code>
is an equivalence, the <em>indifference relation</em> corresponding to
<code class="reqn">R</code>.
</p>
<p>There seem to be no commonly agreed definitions for order relations:
e.g., Fishburn (1972) requires these to be irreflexive.
</p>
<p>For a fuzzy binary relation <code class="reqn">R</code>, let <code class="reqn">R(x, y)</code> denote the
membership of <code class="reqn">(x, y)</code> in the relation.  Write <code class="reqn">T</code> and <code class="reqn">S</code>
for the fuzzy t-norm (intersection) and t-conorm (disjunction),
respectively (min and max for the &ldquo;standard&rdquo; Zadeh family).
Then generalizations of the above basic endorelation predicates are as
follows.
</p>

<dl>
<dt>reflexive:</dt><dd><p><code class="reqn">R(x, x) = 1</code> for all <code class="reqn">x</code>.</p>
</dd>
<dt>irreflexive:</dt><dd><p><code class="reqn">R(x, x) = 0</code> for all <code class="reqn">x</code>.</p>
</dd>
<dt>coreflexive:</dt><dd><p><code class="reqn">R(x, y) &gt; 0</code> implies <code class="reqn">x = y</code>.</p>
</dd>
<dt>symmetric:</dt><dd>
<p><code class="reqn">R(x, y) = R(y, x)</code> for all <code class="reqn">x \ne y</code>.</p>
</dd>
<dt>asymmetric:</dt><dd>
<p><code class="reqn">T(R(x, y), R(y, x)) = 0</code> for all <code class="reqn">x, y</code>.</p>
</dd> 
<dt>antisymmetric:</dt><dd>
<p><code class="reqn">T(R(x, y), R(y, x)) = 0</code> for all <code class="reqn">x \ne y</code>.</p>
</dd>
<dt>transitive:</dt><dd><p><code class="reqn">T(R(x, y), R(y, z)) \le R(x, z)</code> for all
<code class="reqn">x, y, z</code>.</p>
</dd>
<dt>complete:</dt><dd>
<p><code class="reqn">S(R(x, y), R(y, x)) = 1</code> for all <code class="reqn">x \ne y</code>.</p>
</dd>
<dt>strongly complete:</dt><dd>
<p><code class="reqn">S(R(x, y), R(y, x)) = 1</code> for all <code class="reqn">x, y</code>.</p>
</dd>
<dt>negatively transitive:</dt><dd>
<p><code class="reqn">R(x, z) \le S(R(x, y), R(y, z))</code> for all <code class="reqn">x, y, z</code>.</p>
</dd>
<dt>Ferrers:</dt><dd>
<p><code class="reqn">T(R(x, y), R(z, w)) \le S(R(x, w), R(z, y))</code> for all
<code class="reqn">x, y, z, w</code>.</p>
</dd>
<dt>semitransitive:</dt><dd>
<p><code class="reqn">T(R(x, w), R(w, y)) \le S(R(x, z), R(z, y))</code> for all
<code class="reqn">x, y, z, w</code>.</p>
</dd>
</dl>

<p>The combined predicates are obtained by combining the basic predicates
as for crisp endorelations (see above).
</p>
<p>A relation has missings iff at least one cell in the incidence matrix
is <code>NA</code>. In addition to <code>relation_has_missings()</code>, an
<code>is.na</code> method for relations is available, returning a matrix of
logicals corresponding to the incidences tested for missingness.
</p>


<h3>References</h3>

<p>P. C. Fishburn (1972),
<em>Mathematics of decision theory</em>.
Methods and Models in the Social Sciences 3.
Mouton: The Hague.
</p>
<p>H. R. Varian (2002),
<em>Intermediate Microeconomics: A Modern Approach</em>.
6th Edition. W. W. Norton &amp; Company.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require("sets")
R &lt;- relation(domain = c(1, 2, 3), graph = set(c(1, 2), c(2, 3)))
summary(R)

## Note the possible effects of NA-handling:
relation_incidence(R)
relation_is(R, "transitive") ## clearly FALSE

relation_incidence(R)[1, 2] &lt;- NA
relation_incidence(R)
relation_is(R, "transitive") ## clearly NA

## The following gives TRUE, since NA gets replaced with 0:
relation_is(R, "transitive", na.rm = TRUE)
</code></pre>

<hr>
<h2 id='properties'>Relation Properties</h2><span id='topic+relation_properties'></span><span id='topic+relation_property'></span>

<h3>Description</h3>

<p>Retrieve relation properties.</p>


<h3>Usage</h3>

<pre><code class='language-R'>relation_properties(x)
relation_property(x, which)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="properties_+3A_x">x</code></td>
<td>
<p>A relation.</p>
</td></tr>
<tr><td><code id="properties_+3A_which">which</code></td>
<td>
<p>Property name (character string).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are used for the <em>extrinsic</em> properties of
relations. Others can be retrieved using the predicate functions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+relation">relation</a>()</code> and
<code><a href="#topic+relation_is">relation_is</a>()</code> for all
predicate functions defined on relations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- as.relation(1 : 3)
relation_properties(x)
relation_property(x, "is_endorelation")
</code></pre>

<hr>
<h2 id='ranking'>Rankings</h2><span id='topic+ranking'></span><span id='topic+as.ranking'></span><span id='topic+is.ranking'></span>

<h3>Description</h3>

<p>Creates a ranking object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ranking(x, domain = NULL, decreasing = TRUE, complete = FALSE)
as.ranking(x, ...)
is.ranking(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ranking_+3A_x">x</code></td>
<td>
<p>For <code>ranking()</code>: either an atomic vector interpreted as
labels of the ranked objects, or as their scores in case of a named
numeric vector (with the names giving the labels), or a list of
atomic vectors representing equivalence classes of labels.
For <code>as.ranking()</code>: an <span class="rlang"><b>R</b></span> object coercible to a ranking object
(including <code>relation</code> objects).</p>
</td></tr>
<tr><td><code id="ranking_+3A_domain">domain</code></td>
<td>
<p>object coercible to a set, from which the labels usable
in <code>x</code> are derived.  If <code>NULL</code>, it is created from
<code>x</code>.</p>
</td></tr>
<tr><td><code id="ranking_+3A_decreasing">decreasing</code></td>
<td>
<p>logical indicating whether the ranking orders objects
from the best to the worst (<code>TRUE</code>), or the other way round.</p>
</td></tr>
<tr><td><code id="ranking_+3A_complete">complete</code></td>
<td>
<p>logical specifying whether missing values should be
imputed, if any. Missing elements are those from <code>domain</code>
not used in <code>x</code>. If <code>decreasing</code> is <code>TRUE</code>
(<code>FALSE</code>), all missings are ranked tied behind (ahead) the
worst (best) ranked object.</p>
</td></tr>
<tr><td><code id="ranking_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>ranking</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+relation">relation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## simple rankings
OBJECTS &lt;- c("Apples", "Bananas", "Oranges", "Lemons")
print(R &lt;- ranking(OBJECTS))
ranking(OBJECTS[2:4], domain = OBJECTS)
ranking(OBJECTS[2:4], domain = OBJECTS, complete = TRUE)

## ranking with ties (weak orders)
ranking(list(c("PhD", "MD"), "MSc", c("BSc", "BA")))

## ranking A &gt; B ~ C with D missing:
ranking(c(A = 1, B = 2, C = 2, D = NA))

## coercion functions
identical(as.ranking(as.relation(R)), R)
</code></pre>

<hr>
<h2 id='reduction'>Transitive and Reflexive Reduction</h2><span id='topic+transitive_reduction'></span><span id='topic+reflexive_reduction'></span><span id='topic+reduction.relation'></span>

<h3>Description</h3>

<p>Computes transitive and reflexive reduction of an endorelation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transitive_reduction(x)
reflexive_reduction(x)
## S3 method for class 'relation'
reduction(x, operation = c("transitive", "reflexive"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reduction_+3A_x">x</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object inheriting from class <code><a href="#topic+relation">relation</a></code>,
representing an endorelation.</p>
</td></tr>
<tr><td><code id="reduction_+3A_operation">operation</code></td>
<td>
<p>character string indicating the kind of reduction.</p>
</td></tr>
<tr><td><code id="reduction_+3A_...">...</code></td>
<td>
<p>currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">R</code> be an endorelation on <code class="reqn">X</code> and <code class="reqn">n</code> be the number of
elements in <code class="reqn">X</code>.
</p>
<p>The <em>transitive reduction</em> of <code class="reqn">R</code> is the smallest relation
<code class="reqn">R'</code> on <code class="reqn">X</code> so that the transitive closure of <code class="reqn">R'</code> is the
same than the transitive closure of <code class="reqn">R</code>.
</p>
<p>The transitive reduction of an <em>acyclic</em> relation can be obtained
by subtracting from <code class="reqn">R</code> the composition of <code class="reqn">R</code> with its transitive closure.
</p>
<p>The transitive reduction of a <em>cyclic</em> relation is the transitive
reduction of the condensation, combined with the component
representation of <code class="reqn">R</code>. (Note that the transitive reduction of a
cyclic relation is cyclic.)
</p>
<p>The <em>reflexive reduction</em> of <code class="reqn">R</code> is computed by setting the
diagonal of the incidence matrix to 0.
</p>


<h3>References</h3>

<p>S. Warshall (1962),
A theorem on Boolean matrices.
<em>Journal of the ACM</em>, <b>9</b>/1, 11&ndash;12.
<a href="https://doi.org/10.1145/321105.321107">doi:10.1145/321105.321107</a>.
</p>
<p>J. A. La Poutré and J. van Leeuwen (1988),
Maintenance of Transitive Closures and Transitive Reductions of
Graphs.
<em>Proceedings of the International Workshop of Graph-Theoretic
Concepts in Computer Science</em>, Springer, London, 106&ndash;120.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+relation">relation</a>()</code>,<br />
<code><a href="#topic+reflexive_reduction">reflexive_reduction</a>()</code>,
<code><a href="#topic+transitive_reduction">transitive_reduction</a>()</code>,
<code><a href="sets.html#topic+reduction">reduction</a>()</code>,<br />
<code><a href="#topic+relation_condensation">relation_condensation</a>()</code>,
<code><a href="#topic+relation_component_representation">relation_component_representation</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>R &lt;- as.relation(1 : 5)
relation_incidence(R)

## transitive closure/reduction
RR &lt;- transitive_reduction(R)
relation_incidence(RR)
R == transitive_closure(RR)

## same
require("sets")				# closure() and reduction() etc.
R == closure(reduction(R))

## reflexive closure/reduction

RR &lt;- reflexive_reduction(R)
relation_incidence(RR)
R == reflexive_closure(RR)

## same:
R == closure(reduction(R, "reflexive"), "reflexive")

## transitive reduction of a cyclic relation:
## (example from La Poutre and van Leeuwen)

require("sets")				# set(), pair() etc.
if(require("Rgraphviz")) {
  G &lt;- set(pair(1L, 2L), pair(2L, 1L), pair(1L, 3L), pair(3L, 1L),
           pair(3L, 7L), pair(2L, 5L), pair(2L, 6L), pair(6L, 5L),
           pair(5L, 7L), pair(4L, 6L), pair(5L, 4L), pair(4L, 7L))
  R &lt;- endorelation(graph = G)
  plot(relation_ensemble(R, R), type = c("raw", "simplified"), main =
           c("original graph", "transitive reduction"))
  }
</code></pre>

<hr>
<h2 id='relation'>Relations</h2><span id='topic+relation'></span><span id='topic+endorelation'></span><span id='topic+homorelation'></span><span id='topic+as.relation'></span><span id='topic+is.relation'></span><span id='topic+codual'></span><span id='topic+codual.relation'></span><span id='topic+sym'></span><span id='topic+sym.relation'></span><span id='topic+asy'></span><span id='topic+asy.relation'></span>

<h3>Description</h3>

<p>Creation and manipulation of relations.</p>


<h3>Usage</h3>

<pre><code class='language-R'>relation(domain = NULL, incidence = NULL, graph = NULL,
         charfun = NULL)
endorelation(domain = NULL, incidence = NULL, graph = NULL,
             charfun = NULL)
homorelation(domain = NULL, incidence = NULL, graph = NULL,
             charfun = NULL)
as.relation(x, ...)
is.relation(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="relation_+3A_domain">domain</code></td>
<td>
<p>List (or tuple) of (possibly named) sets (or vectors)
used as the domain, recycled as needed to fit the arity of the relation.
If <code>domain</code> is not a list or tuple, it is converted to a list.</p>
</td></tr>
<tr><td><code id="relation_+3A_incidence">incidence</code></td>
<td>
<p>A numeric array with values in the unit interval, or
a logical array.  Note that one-dimensional incidences are also
accepted.  The <code>names</code>/<code>dimnames</code> attribute of
<code>incidence</code> is used as domain if this is not explicitly given
using the <code>domain</code> argument.</p>
</td></tr>
<tr><td><code id="relation_+3A_graph">graph</code></td>
<td>
<p>Either a set of equally sized tuples, or a list of
(possibly, generic) vectors of same length where each component
specifies one relation element, or a data frame where each row
specifies one relation element.  For the latter, the columns
correspond to the domain sets, and the colnames are used as their
labels if specified.</p>
</td></tr>
<tr><td><code id="relation_+3A_charfun">charfun</code></td>
<td>
<p>A characteristic function of the relation, i.e., a
predicate function taking <code class="reqn">k</code> arguments, with <code class="reqn">k</code> equal to
the arity of the relation.</p>
</td></tr>
<tr><td><code id="relation_+3A_x">x</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object.</p>
</td></tr>
<tr><td><code id="relation_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code>as.relation()</code>
methods (currently not used for those defined in the relations
package).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given <code class="reqn">k</code> sets of objects <code class="reqn">X_1</code>, ..., <code class="reqn">X_k</code>, a
<code class="reqn">k</code>-ary relation <code class="reqn">R</code> on <code class="reqn">D(R) = (X_1, \ldots, X_k)</code> is a
(possibly fuzzy) subset <code class="reqn">G(R)</code> of the Cartesian product <code class="reqn">X_1
    \times \cdots \times X_k</code>.  We refer to <code class="reqn">D(R)</code>
and <code class="reqn">G(R)</code> as the <em>domain</em> and the <em>graph</em> of the
relation, respectively (alternative notions are that of <em>ground</em>
and <em>figure</em>, respectively).  We also refer to <code class="reqn">s = (s_1,
    \ldots, s_k)</code>, where each <code class="reqn">s_i</code> gives the cardinality of
<code class="reqn">X_i</code>, as the <em>size</em> of the relation.
</p>
<p>Strictly speaking, the relation is the <em>pair</em> <code class="reqn">(D(R), G(R))</code>;
often, relations are identified with their graph.  If <code class="reqn">G(R)</code> is a
crisp subset of <code class="reqn">D(R)</code>, <code class="reqn">R</code> is a <em>crisp relation</em>.  In
this case, we say that a <code class="reqn">k</code>-tuple <code class="reqn">t</code> is <em>contained</em> in
the relation <code class="reqn">R</code> iff it is an element of <code class="reqn">G(R)</code>.
</p>
<p>The <em>characteristic function</em> <code class="reqn">f_R</code> of a relation <code class="reqn">R</code> is
the membership function of <code class="reqn">G(R)</code>, giving for each <code class="reqn">k</code>-tuple
<code class="reqn">t</code> in <code class="reqn">D(R)</code> the membership (amount of belongingness) of
<code class="reqn">t</code> to <code class="reqn">G(R)</code>.  In the crisp case, <code class="reqn">f_R</code> is also referred
to as the indicator function of the relation, and is a binary (0/1)
function such that <code class="reqn">f_R(t)</code> is one iff <code class="reqn">t</code> is in <code class="reqn">G(R)</code>.
</p>
<p>Relations with arity 2, 3, and 4 are typically referred to as
<em>binary</em>, <em>ternary</em>, and <em>quaternary</em> relations,
respectively.  A <em>homorelation</em> on <code class="reqn">X</code> is a relation with
homogeneous domain, i.e. <code class="reqn">(X, X, \dots, X)</code>.
An <em>endorelation</em> on <code class="reqn">X</code> (or binary relation
<em>over</em> <code class="reqn">X</code>) is a binary homorelation.
See <a href="#topic+relation_is">predicates</a> for the most important
types of endorelations.
</p>
<p>Relations with the same domain can naturally be ordered according to
their graphs.  I.e., <code class="reqn">R \le S</code> iff <code class="reqn">G(R)</code> is a subset of
<code class="reqn">G(S)</code>, or equivalently, iff <code class="reqn">f_R(t) \le f_S(t)</code> for every
<code class="reqn">k</code>-tuple <code class="reqn">t</code> (in the crisp case, iff every tuple contained in
<code class="reqn">R</code> is also contained in <code class="reqn">S</code>).  This induces a lattice
structure, with meet (greatest lower bound) and join (least upper
bound) the intersection and union of the graphs, respectively, also
known as the <em>intersection</em> and <em>union</em> of the relations.
The least element moves metric on this lattice is the
<em>symmetric difference metric</em>, i.e., the Manhattan distance
between the collections of membership values (incidences).  In the
crisp case, this gives the cardinality of the symmetric difference of
the graphs (the number of tuples in exactly one of the relation
graphs).
</p>
<p>The <em>complement</em> (or <em>negation</em>) <code class="reqn">R^c</code> of a relation
<code class="reqn">R</code> is the relation with domain <code class="reqn">D(R)</code> whose graph is the
complement of <code class="reqn">G(R)</code> (in the crisp case, containing exactly the
tuples not contained in <code class="reqn">R</code>).
</p>
<p>For binary crisp relations <code class="reqn">R</code>, it is customary to write
<code class="reqn">x R y</code> iff <code class="reqn">(x, y)</code> is contained in <code class="reqn">R</code>.  For binary
crisp relations <code class="reqn">R_1</code> and <code class="reqn">R_2</code> with domains <code class="reqn">(X, Y)</code> and 
<code class="reqn">(Y, Z)</code>, the <em>composition</em> <code class="reqn">T = R_1 * R_2</code> of <code class="reqn">R_1</code>
and <code class="reqn">R_2</code> is defined by taking <code class="reqn">x S z</code> iff there is an <code class="reqn">y</code>
such that <code class="reqn">x R_1 y</code> and <code class="reqn">y R_2 z</code>.  The <em>transpose</em> (or
<em>inverse</em>) <code class="reqn">R^{t}</code> of the relation <code class="reqn">R</code> with domain
<code class="reqn">(X, Y)</code> is the relation with domain <code class="reqn">(Y, X)</code> such that
<code class="reqn">y R^{t} x</code> iff <code class="reqn">x R y</code>.  The 
<em>codual</em> (Clark (1990), also known as the &lsquo;dual&rsquo; in the
fuzzy preference literature, e.g., Ovchinnikov (1991)) is the
complement of the transpose (equivalently, the transpose of the
complement).
</p>
<p>For binary fuzzy relations <code class="reqn">R</code>, one often writes <code class="reqn">R(x, y)</code> for
the membership of the pair <code class="reqn">(x, y)</code> in the relation.  The above
notions need to take the fuzzy logic employed (as described by the
fuzzy t-norm (intersection) <code class="reqn">T</code>, t-conorm (disjunction) <code class="reqn">S</code>,
and negation <code class="reqn">N</code>) into account.  Let <code class="reqn">R</code>, <code class="reqn">R_1</code> and
<code class="reqn">R_2</code> be binary relations with appropriate domains.  Then the
memberships for <code class="reqn">(x, y)</code> of the complement, transpose and codual of
<code class="reqn">R</code> are <code class="reqn">N(R(x, y))</code>, <code class="reqn">R(y, x)</code> and <code class="reqn">N(R(y, x))</code>,
respectively.  The membership of <code class="reqn">(x, y)</code> for the composition of
<code class="reqn">R_1</code> and <code class="reqn">R_2</code> is <code class="reqn">\max_z T(R_1(x, z), R_2(z, y))</code>.
</p>
<p>Package <span class="pkg">relations</span> implements finite relations as an S3 class
which allows for a variety of representations (even though currently,
typically dense array representations of the incidences are employed).
Other than by the generator,
relations can be obtained by coercion via the generic function
<code>as.relation()</code>, which has methods for at least logical and numeric
vectors, unordered and ordered factors, arrays including matrices, and
data frames.  Unordered factors are coerced to equivalence relations;
ordered factors and numeric vectors are coerced to order relations.
Logical vectors give unary relations (predicates).  A (feasible)
<code class="reqn">k</code>-dimensional array is taken as the incidence of a <code class="reqn">k</code>-ary
relation.  Finally, a data frame is taken as a relation table.  Note
that missing values will be propagated in the coercion.
</p>
<p><code>endorelation()</code> is a wrapper for <code>relation()</code>, trying to
guess a suitable domain from its arguments to create an
endorelation.  If a domain is given, all labels are combined and the
result (as a list) recycled as needed.
</p>
<p>Basic relation operations are available as group methods: <code>min()</code>
and <code>max()</code> give the meet and join, and <code>range()</code> a
<a href="#topic+relation_ensemble">relation ensemble</a> with these two.
Comparison operators implement the natural ordering in the relation
lattice.  Where applicable, <code>!</code> gives the complement (negation),
<code>&amp;</code> and <code>|</code> intersection and union, and <code>*</code>
composition, respectively.  Finally, <code>t()</code> gives the transpose
and <code>codual()</code> the codual.
</p>
<p>There is a <code><a href="#topic+plot.relation">plot</a>()</code> method for certain
crisp endorelations provided that package <span class="pkg">Rgraphviz</span> is
available.
</p>
<p>For crisp endorelations <code class="reqn">R</code>, <code>sym()</code> and <code>asy()</code> give
the symmetric and asymmetric parts of <code class="reqn">R</code>, defined as the
intersection of <code class="reqn">R</code> with its transpose, or, respectively, with its
codual (the complement of its transpose).
</p>
<p>The <code>summary()</code> method applies all <a href="#topic+predicates">predicates</a> available
and returns a logical vector with the corresponding results.
</p>


<h3>References</h3>

<p>S. A. Clark (1990),
A folk meta-theorem in the foundations of utility theory.
<em>Mathematical Social Sciences</em>, <b>19</b>/3, 253&ndash;267.
<a href="https://doi.org/10.1016/0165-4896%2890%2990065-F">doi:10.1016/0165-4896(90)90065-F</a>.
</p>
<p>S. Ovchinnikov (1991),
Similarity relations, fuzzy partitions, and fuzzy orderings.
<em>Fuzzy Sets and Systems</em>, <b>40</b>/1, 107&ndash;126.
<a href="https://doi.org/10.1016/0165-0114%2891%2990048-U">doi:10.1016/0165-0114(91)90048-U</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+relation_incidence">relation_incidence</a>()</code> for obtaining incidences;
<code><a href="#topic+relation_domain">relation_domain</a>()</code> for determining domain, arity, and
size;
<code><a href="#topic+relation_graph">relation_graph</a>()</code> for determining the graph of a relation;
<code><a href="#topic+relation_charfun">relation_charfun</a>()</code> for determining the characteristic
function;
<a href="#topic+predicates">predicates</a> for available predicate functions; and
<a href="#topic+algebra">algebra</a> for further operations defined on relations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require("sets")				# set(), tuple() etc.

## A relation created by specifying the graph:
R &lt;- relation(graph = data.frame(A = c(1, 1:3), B = c(2:4, 4)))
relation_incidence(R)
## extract domain
relation_domain(R)
## extract graph
relation_graph(R)
## both ("a pair of domain and graph" ...)
as.tuple(R)

## (Almost) the same using the set specification
## (the domain labels are missing).
R &lt;- relation(graph = set(tuple(1,2), tuple(1,3),
                          tuple(2,4), tuple(3,4)))
## equivalent to:
## relation(graph = list(c(1,2), c(1,3), c(2,4), c(3,4)))
relation_incidence(R)

## Explicitly specifying the domain:
R &lt;- relation(domain = list(A = letters[1:3], B = LETTERS[1:4]),
              graph = set(tuple("a","B"), tuple("a","C"),
                          tuple("b","D"), tuple("c","D")))
relation_incidence(R)

## Domains can be composed of arbitrary R objects:
R &lt;- relation(domain = set(c, "test"),
              graph = set(tuple(c, c), tuple(c, "test")))
relation_incidence(R)

## Characteristic function ("a divides b"):
R &lt;- relation(domain = list(1 : 10, 1 : 10),
              charfun = function(a, b) b %% a == 0)
relation_incidence(R)
## R is a partial order: plot the Hasse diagram provided that
## Rgraphviz is available:
if(require("Rgraphviz")) plot(R)

## conversions and operators
x &lt;- matrix(0, 3, 3)
R1 &lt;- as.relation(row(x) &gt;= col(x))
R2 &lt;- as.relation(row(x) &lt;= col(x))
R3 &lt;- as.relation(row(x) &lt;  col(x))
relation_incidence(max(R1, R2))
relation_incidence(min(R1, R2))
R3 &lt; R2
relation_incidence(R1 * R2)
relation_incidence(! R1)
relation_incidence(t(R2))

### endorelation
s &lt;- set(pair("a","b"), pair("c","d"))
relation_incidence(relation(graph = s))
relation_incidence(endorelation(graph = s))
</code></pre>

<hr>
<h2 id='scores'>Relation Scores</h2><span id='topic+relation_scores'></span><span id='topic+relation_scores.relation'></span><span id='topic+relation_scores.relation_ensemble'></span>

<h3>Description</h3>

<p>Compute scores for the tuples of (ensembles of) endorelations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'relation'
relation_scores(x,
                method = c("ranks", "Barthelemy/Monjardet",
                           "Borda", "Kendall", "Wei",
                           "differential", "Copeland"),
                normalize = FALSE, ...)
## S3 method for class 'relation_ensemble'
relation_scores(x,
                method = c("Borda", "Kendall", "differential",
                           "Copeland"),
                normalize = FALSE,
                weights = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="scores_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code><a href="#topic+relation">relation</a></code>,
representing an endorelation.</p>
</td></tr>
<tr><td><code id="scores_+3A_method">method</code></td>
<td>
<p>character string indicating the method (see
<b>Details</b>).</p>
</td></tr>
<tr><td><code id="scores_+3A_normalize">normalize</code></td>
<td>
<p>logical indicating whether the score vector should be
normalized to sum up to 1.</p>
</td></tr>
<tr><td><code id="scores_+3A_weights">weights</code></td>
<td>
<p>Numeric vector of weights used in incidence
aggregation, recycled as needed.</p>
</td></tr>
<tr><td><code id="scores_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the following, consider an endorelation <code class="reqn">R</code> on <code class="reqn">n</code> objects.
Let the <em>in-degree</em> <code class="reqn">I(x)</code> and <em>out-degree</em> <code class="reqn">O(x)</code>
of an object <code class="reqn">x</code> be defined as the numbers of objects <code class="reqn">y</code> such
that <code class="reqn">y R x</code> and, respectively, <code class="reqn">x R y</code>, and let <code class="reqn">D(x) =
    I(x) - O(x)</code> be the <em>differential</em> of <code class="reqn">x</code> (see Regenwetter
and Rykhlevskaia (2004)).  Note that <code class="reqn">I</code> and <code class="reqn">O</code> are given by
the column sums and row sums of the incidence matrix of <code class="reqn">R</code>.  If
<code class="reqn">R</code> is a preference relation with a <code class="reqn">\le</code> interpretation,
<code class="reqn">D(x)</code> is the difference between the numbers of objects dominated
by <code class="reqn">x</code> (i.e., <code class="reqn">&lt; x</code>) and dominating <code class="reqn">x</code> (i.e., <code class="reqn">&gt; x</code>),
as &ldquo;ties&rdquo; cancel out.
</p>
<p><code>relation_score()</code> is generic with methods for relations and
relation ensembles. Available built-in score methods for the
relation method are as follows:
</p>

<dl>
<dt><code>"ranks"</code></dt><dd><p>generalized ranks.  A linear transformation of
the differential <code class="reqn">D</code> to the range from 1 to <code class="reqn">n</code>.  An
additional argument <code>decreasing</code> can be used to specify the
order of the ranks.  By default, or if <code>decreasing</code> is true,
objects are ranked according to decreasing differential
(&ldquo;from the largest to the smallest&rdquo; in the <code class="reqn">\le</code>
preference context) using <code class="reqn">(n + 1 - D(x)) / 2</code>.
Otherwise, if <code>decreasing</code> is false, objects are ranked via
<code class="reqn">(n + 1 + D(x)) / 2</code> (&ldquo;from the smallest to the largest&rdquo;).
See Regenwetter and Rykhlevskaia (2004) for more details on
generalized ranks.
</p>
</dd>
<dt><code>"Barthelemy/Monjardet"</code></dt><dd><p><code class="reqn">(M(x) + N(x) - 1) / 2</code>,
where <code class="reqn">M(x)</code> and <code class="reqn">N(x)</code> are the numbers of objects <code class="reqn">y</code>
such that <code class="reqn">y R x</code>, and <code class="reqn">y R x</code> and not <code class="reqn">x R y</code>,
respectively.  If <code class="reqn">R</code> is a <code class="reqn">\le</code> preference relation, we
get the number of dominated objects plus half the number of the
equivalent objects minus 1 (the &ldquo;usual&rdquo; average ranks minus
one if the relation is complete).  See Barthélemy and Monjardet
(1981).
</p>
</dd>
<dt><code>"Borda"</code>, <code>"Kendall"</code></dt><dd><p>the out-degrees.
See Borda (1770) and Kendall (1955).
</p>
</dd>
<dt><code>"Wei"</code></dt><dd><p>the eigenvector corresponding to the greatest
eigenvalue of the incidence matrix of the complement of <code class="reqn">R</code>.
See Wei (1952).
</p>
</dd>
<dt><code>"differential"</code>, <code>"Copeland"</code></dt><dd><p>the differentials,
equivalent to the negative <em>net flow</em> of Bouyssou (1992), and
also to the Copeland scores.</p>
</dd>
</dl>

<p>For relation ensembles, currently only
<code>"differential"</code>/<code>"Copeland"</code> and
<code>"Borda"</code>/<code>"Kendall"</code> are implemented. They are computed on
the aggregated incidences of the ensembles' relations.
</p>
<p>Definitions of scores for &ldquo;preference relations&rdquo; <code class="reqn">R</code> are
somewhat ambiguous because <code class="reqn">R</code> can encode <code class="reqn">\le</code> or <code class="reqn">\ge</code>
(or strict variants thereof) relationships (and all such variants are
used in the literature).  Package <span class="pkg">relations</span> generally assumes a
<code class="reqn">\le</code> encoding, and that scores in the strict sense should
increase with preference (the most preferred get the highest scores)
whereas ranks decrease with preference (the most preferred get the
lowest ranks).
</p>


<h3>Value</h3>

<p>A vector of scores, with names taken from the relation domain labels.
</p>


<h3>References</h3>

<p>J.-P. Barthélemy and B. Monjardet (1981),
The median procedure in cluster analysis and social choice theory.
<em>Mathematical Social Sciences</em>, <b>1</b>, 235&ndash;267.
<a href="https://doi.org/10.1016/0165-4896%2881%2990041-X">doi:10.1016/0165-4896(81)90041-X</a>.
</p>
<p>J. C. Borda (1781),
Mémoire sur les élections au scrutin.
Histoire de l'Académie Royale des Sciences.
</p>
<p>D. Bouyssou (1992),
Ranking methods based on valued preference relations: A
characterization of the net flow network.
<em>European Journal of Operational Research</em>, <b>60</b>, 61&ndash;67.
<a href="https://doi.org/10.1016/0377-2217%2892%2990333-5">doi:10.1016/0377-2217(92)90333-5</a>.
</p>
<p>M. Kendall (1955),
Further contributions to the theory of paired comparisons.
<em>Biometrics</em>, <b>11</b>, 43&ndash;62.
<a href="https://doi.org/10.2307/3001479">doi:10.2307/3001479</a>.
</p>
<p>M. Regenwetter and E. Rykhlevskaia (2004),
On the (numerical) ranking associated with any finite binary relation.
<em>Journal of Mathematical Psychology</em>, <b>48</b>, 239&ndash;246.
<a href="https://doi.org/10.1016/j.jmp.2004.03.003">doi:10.1016/j.jmp.2004.03.003</a>.
</p>
<p>T. H. Wei (1952).
<em>The algebraic foundation of ranking theory</em>.
Unpublished thesis, Cambridge University.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example taken from Cook and Cress (1992, p.74)
I &lt;- matrix(c(0, 0, 1, 1, 1,
              1, 0, 0, 0, 1,
              0, 1, 0, 0, 1,
              0, 1, 1, 0, 0,
              0, 0, 0, 1, 0),
            ncol = 5,
            byrow = TRUE)
R &lt;- relation(domain = letters[1:5], incidence = I)

## Note that this is a "preference matrix", so take complement:
R &lt;- !R

## Compare Kendall and Wei scores
cbind(
      Kendall = relation_scores(R, method = "Kendall", normalize = TRUE),
      Wei = relation_scores(R, method = "Wei", normalize = TRUE)
     )

## Example taken from Cook and Cress (1992, p.136)
## Note that the results indicated for the Copeland scores have
## (erroneously?) been computed from the *unweighted* votes.
## Also, they report the votes as strict preferences, so we
## create the dual relations.

D &lt;- letters[1:5]
X &lt;- as.relation(ordered(D, levels = c("b", "c", "a", "d", "e")))
Y &lt;- as.relation(ordered(D, levels = c("d", "a", "e", "c", "b")))
Z &lt;- as.relation(ordered(D, levels = c("e", "c", "b", "a", "d")))
E &lt;- relation_ensemble(X, Y, Z)
relation_scores(E, "Copeland")
relation_scores(E, "Borda", weights = c(4, 3, 2))
</code></pre>

<hr>
<h2 id='setters'>Modify Relations</h2><span id='topic+relation_domain+3C-'></span><span id='topic+relation_domain_names+3C-'></span><span id='topic+relation_graph+3C-'></span><span id='topic+relation_incidence+3C-'></span>

<h3>Description</h3>

<p>Modify relations by (re)setting their domain, graph, or incidences.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relation_domain(x) &lt;- value
relation_domain_names(x) &lt;- value
relation_graph(x) &lt;- value
relation_incidence(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setters_+3A_x">x</code></td>
<td>
<p>an <span class="rlang"><b>R</b></span> object inheriting from class <code><a href="#topic+relation">relation</a></code>.</p>
</td></tr>
<tr><td><code id="setters_+3A_value">value</code></td>
<td>
<p>for setting the domain, a tuple (or list) as long as the
arity of the relation <code>x</code>, with sets of cardinality (for lists:
numbers of elements) identical to the size of <code>x</code>.
</p>
<p>For setting the graph, either a set of tuples of equal lengths
(arity of the relation) or a data frame or something coercible to
this, with the values of the components of the given tuples (rows)
always elements of the corresponding elements of the domain of
<code>x</code>.
</p>
<p>For setting incidences, a numeric array with values in the unit
interval or a logical array, with dimension the size of the relation
<code>x</code>.
</p>
<p>For setting the domain names, a character vector as long as the
arity of the relation <code>x</code>.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+relation_domain">relation_domain</a>()</code> for getting the domain of a relation;
<code><a href="#topic+relation_domain_names">relation_domain_names</a>()</code> for getting the domain names;
<code><a href="#topic+relation_graph">relation_graph</a>()</code> for getting the graph;
<code><a href="#topic+relation_incidence">relation_incidence</a>()</code> for getting the incidences;
<code><a href="#topic+relation">relation</a>()</code> for basic information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>R &lt;- as.relation(1 : 3)
print(R)

relation_domain(R)
## tuple format:
require("sets")				# set(), pair() etc.
relation_domain(R) &lt;- pair(X = set("a","b","c"), Y = set("A","B","C"))
relation_domain(R)
## the same in list format:
relation_domain(R) &lt;- list(X = letters[1:3], Y = LETTERS[1:3])
relation_domain(R)

relation_domain_names(R) &lt;- c("XX","YY")
relation_domain_names(R)

relation_incidence(R)
relation_incidence(R) &lt;- diag(1, 3, 3)
relation_incidence(R)

relation_graph(R)
## set format:
relation_graph(R) &lt;- set(pair("a","B"), pair("a","C"), pair("b","C"))
relation_graph(R)
## the same in data frame format:
relation_graph(R) &lt;-
    data.frame(c("a", "a", "b"), c("B", "C", "C"),
               stringsAsFactors = FALSE)
relation_graph(R)

</code></pre>

<hr>
<h2 id='SVMBench'>SVM Benchmarking Data and Consensus Relations</h2><span id='topic+SVM_Benchmarking_Classification'></span><span id='topic+SVM_Benchmarking_Regression'></span><span id='topic+SVM_Benchmarking_Classification_Consensus'></span><span id='topic+SVM_Benchmarking_Regression_Consensus'></span>

<h3>Description</h3>

<p><code>SVM_Benchmarking_Classification</code> and
<code>SVM_Benchmarking_Regression</code> represent the
results of a benchmark study (Meyer, Leisch and Hornik, 2003)
comparing Support Vector Machines to 
other predictive methods on real and artificial data sets
involving classification and regression
methods, respectively.
In addition,
<code>SVM_Benchmarking_Classification_Consensus</code>
and <code>SVM_Benchmarking_Regression_Consensus</code>
provide consensus rankings derived from these data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("SVM_Benchmarking_Classification")
data("SVM_Benchmarking_Regression")
data("SVM_Benchmarking_Classification_Consensus")
data("SVM_Benchmarking_Regression_Consensus")
</code></pre>


<h3>Format</h3>

<p><code>SVM_Benchmarking_Classification</code>
(<code>SVM_Benchmarking_Regression</code>) is an ensemble of 21 (12)
relations representing pairwise comparisons of 17 classification (10
regression) methods on 21 (12) data sets.  Each relation of the 
ensemble summarizes the results for a particular data set.  The
relations are reflexive endorelations on the set of methods
employed, with a pair <code class="reqn">(a, b)</code> of distinct methods contained in a
relation iff both delivered results on the corresponding data set and
<code class="reqn">a</code> did not perform significantly better than <code class="reqn">b</code> at the 5%
level.  Since some methods failed on some data sets, the relations are
not guaranteed to be complete or transitive.  See Meyer et al. (2003)
for details on the experimental design of the benchmark study, and
Hornik and Meyer (2007) for the pairwise comparisons.
</p>
<p>The corresponding consensus objects are lists of ensembles of
consensus relations fitted to the benchmark results.
For each of the following three endorelation families:
<code>SD/L</code> (&ldquo;linear orders&rdquo;),
<code>SD/O</code> (&ldquo;partial orders&rdquo;), and <code>SD/W</code>
(&ldquo;weak orders&rdquo;), <em>all</em> possible consensus
relations have been computed (see <code><a href="#topic+relation_consensus">relation_consensus</a></code>).
For both classification and regression,
the three relation ensembles obtained are provided as a named list of
length 3. See Hornik &amp; Meyer (2007) for details on the meta-analysis.
</p>


<h3>Source</h3>

<p>D. Meyer, F. Leisch, and K. Hornik (2003),
The support vector machine under test.
<em>Neurocomputing</em>, <b>55</b>, 169&ndash;186.
<a href="https://doi.org/10.1016/S0925-2312%2803%2900431-4">doi:10.1016/S0925-2312(03)00431-4</a>.
</p>
<p>K. Hornik and D. Meyer (2007),
Deriving consensus rankings from benchmarking experiments.
In R. Decker and H.-J. Lenz,
<em>Advances in Data Analysis</em>.
Studies in Classification, Data Analysis, and Knowledge Organization.
Springer-Verlag: Heidelberg, 163&ndash;170.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("SVM_Benchmarking_Classification")

## 21 data sets
names(SVM_Benchmarking_Classification)

## 17 methods
relation_domain(SVM_Benchmarking_Classification)

## select weak orders
weak_orders &lt;-
    Filter(relation_is_weak_order, SVM_Benchmarking_Classification)

## only the artifical data sets yield weak orders
names(weak_orders)

## visualize them using Hasse diagrams
if(require("Rgraphviz")) plot(weak_orders)

## Same for regression:
data("SVM_Benchmarking_Regression")

## 12 data sets
names(SVM_Benchmarking_Regression)

## 10 methods
relation_domain(SVM_Benchmarking_Regression)

## select weak orders
weak_orders &lt;-
    Filter(relation_is_weak_order, SVM_Benchmarking_Regression)

## only two of the artifical data sets yield weak orders
names(weak_orders)

## visualize them using Hasse diagrams
if(require("Rgraphviz")) plot(weak_orders)

## Consensus solutions:

data("SVM_Benchmarking_Classification_Consensus")
data("SVM_Benchmarking_Regression_Consensus")

## The solutions for the three families are not unique
print(SVM_Benchmarking_Classification_Consensus)
print(SVM_Benchmarking_Regression_Consensus)

## visualize the consensus weak orders
classW &lt;- SVM_Benchmarking_Classification_Consensus$W
regrW &lt;- SVM_Benchmarking_Regression_Consensus$W
if(require("Rgraphviz")) {
    plot(classW)
    plot(regrW)
}

## in tabular style:
ranking &lt;- function(x) rev(names(sort(relation_class_ids(x))))
sapply(classW, ranking)
sapply(regrW, ranking)

## (prettier and more informative:)
relation_classes(classW[[1L]])
</code></pre>

<hr>
<h2 id='table'>Relation Table</h2><span id='topic+relation_table'></span>

<h3>Description</h3>

<p>Returns a tabular representation of a relation like a
&ldquo;view&rdquo; of a relational database table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relation_table(x, memberships = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="table_+3A_x">x</code></td>
<td>
<p>an object inheriting from class <code><a href="#topic+relation">relation</a></code>.</p>
</td></tr>
<tr><td><code id="table_+3A_memberships">memberships</code></td>
<td>
<p>logical; should membership vector (if any) be added to the table?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>relation_table</code>, inheriting from class
<code><a href="base.html#topic+data.frame">data.frame</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+relation_join">relation_join</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>R &lt;- data.frame(Name = c("David", "John"),
                Age = c(33, 66),
                stringsAsFactors = FALSE)
R &lt;- as.relation(R)
relation_table(R)
</code></pre>

<hr>
<h2 id='trace'>Traces of Endorelations</h2><span id='topic+relation_trace'></span>

<h3>Description</h3>

<p>Compute the left or right trace of an endorelation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relation_trace(x, which)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="trace_+3A_x">x</code></td>
<td>
<p>an endorelation.</p>
</td></tr>
<tr><td><code id="trace_+3A_which">which</code></td>
<td>
<p>one of <code>"left"</code> or <code>"right"</code>, or a unique
abbreviation thereof.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">R</code> be a crisp endorelation.  The left and right trace of
<code class="reqn">R</code> contain all pairs <code class="reqn">x, y</code> for which <code class="reqn">z R x</code> implies
<code class="reqn">z R y</code> for all <code class="reqn">z</code> (left trace) or <code class="reqn">y R z</code> implies
<code class="reqn">x R z</code> for all <code class="reqn">z</code> (right trace), respectively.  These are
the largest (in the natural ordering of relations with the same
domain) relations such that <code class="reqn">R * S \le R</code> or <code class="reqn">S * R \le R</code>,
respectively (where <code class="reqn">*</code> denotes composition).  In the fuzzy case,
the memberships of the traces can be defined as the infima over the
corresponding fuzzy membership implications.  See Chapter 2.3 in Fodor
and Roubens (1994) for more information.
</p>


<h3>References</h3>

<p>J. Fodor and M. Roubens (1994),
<em>Fuzzy Preference Modelling and Multicriteria Decision Support</em>.
Kluwer Academic Publishers: Dordrecht.
</p>

<hr>
<h2 id='transform'>Transform incidences</h2><span id='topic+transform_incidences'></span>

<h3>Description</h3>

<p>Carry out transformations between incidence matrices from
endorelations and other codings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_incidences(x, from = c("PO", "SO", "01", "-1+1"),
                        to = c("PO", "SO", "01", "-1+1"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transform_+3A_x">x</code></td>
<td>
<p>An incidence matrix from an endorelation.</p>
</td></tr>
<tr><td><code id="transform_+3A_from">from</code>, <code id="transform_+3A_to">to</code></td>
<td>
<p>The coding scheme (see <b>Details</b>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the following, we consider an incidence matrix <code class="reqn">X</code> with cells
<code class="reqn">x_{jk}</code> of a relation <code class="reqn">R</code> with tuples <code class="reqn">(a_j, b_k)</code>.
</p>
<p>For the <code>"PO"</code> (&ldquo;Preference Order&rdquo;) coding,
<code class="reqn">X</code> is a 0/1 matrix, and 
<code class="reqn">a_j R b_k</code> iff <code class="reqn">x_{jk} = 1</code>. It follows in particular
that if both <code class="reqn">x_{jk}</code> and <code class="reqn">x_{kj}</code> are 0, the corresponding pair
<code class="reqn">(a_j, b_k)</code> is not contained in R, i.e., <code class="reqn">a_j</code> and <code class="reqn">b_k</code>
are unrelated.
</p>
<p>For the <code>"SO"</code> (&ldquo;&quot;Strict Order&quot;&rdquo;) coding,
<code class="reqn">X</code> is a 0/1 matrix with possible
<code>NA</code> values. As for <code>"PO"</code>, <code class="reqn">a_j R b_k</code> iff
<code class="reqn">x_{jk} = 1</code>, but at most one of <code class="reqn">x_{jk}</code> and <code class="reqn">x_{kj}</code> can
be 1. If both are missing (<code>NA</code>), <code class="reqn">a_j</code> and <code class="reqn">b_k</code>
are unrelated.
</p>
<p>For the <code>"01"</code> coding, <code class="reqn">X</code> is a matrix with values 0, 1, or
0.5. The coding is similar to <code>"SO"</code>, except that <code>NA</code> is
represented by 0.5.
</p>
<p>For the <code>"-1+1"</code> coding, <code class="reqn">X</code> is a matrix with values -1, 0, or 1.
The coding is similar to <code>"SO"</code>, except that <code>NA</code> is
represented by 0, and <code class="reqn">x_{jk} = -1</code> if <em>not</em> <code class="reqn">a_j R b_k</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+relation_incidence">relation_incidence</a>()</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require("sets")				# set(), pair() etc.
x &lt;- relation(domain = c(1,2,3,4),
              graph = set(pair(1,2), pair(4,2), pair(1,3), pair(1,4),
                          pair(3,2), pair(2,1)))
inc &lt;- relation_incidence(x)
print(inc)

transform_incidences(inc, to = "SO")
transform_incidences(inc, to = "01")
transform_incidences(inc, to = "-1+1")

## transformations should be loss-free:
inc2 &lt;- transform_incidences(inc, from = "PO", to = "-1+1")
inc2 &lt;- transform_incidences(inc2, from = "-1+1", to = "SO")
inc2 &lt;- transform_incidences(inc2, from = "SO", to = "01")
inc2 &lt;- transform_incidences(inc2, from = "01", to = "PO")
stopifnot(identical(inc, inc2))
</code></pre>

<hr>
<h2 id='violations'>Violations of Relation Properties</h2><span id='topic+relation_violations'></span>

<h3>Description</h3>

<p>Computes a measure of remoteness of a relation from a
specified property.</p>


<h3>Usage</h3>

<pre><code class='language-R'>relation_violations(x,
                    property =
                    c("complete", "match",
                      "reflexive", "irreflexive", "coreflexive",
                      "symmetric", "antisymmetric", "asymmetric",
                      "transitive", "negatively_transitive",
                      "Ferrers", "semitransitive",
                      "trichotomous",
                      "Euclidean"),
                    tuples = FALSE,
                    na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="violations_+3A_x">x</code></td>
<td>
<p>an endorelation.</p>
</td></tr>
<tr><td><code id="violations_+3A_property">property</code></td>
<td>
<p>a character string specifying one of the properties
for which the number of violations can be computed.</p>
</td></tr>
<tr><td><code id="violations_+3A_tuples">tuples</code></td>
<td>
<p>a logical indicating whether to return the amount of
violations (default), or the tuples for which the property is
violated.</p>
</td></tr>
<tr><td><code id="violations_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical indicating whether to remove tuples for which
the property information is not available (due to missing
memberships).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>tuples</code> is false (default), the amount of violations for the
specified property: for crisp relations, the minimum number of object
tuples involved in the definition of the property (e.g., singletons
for reflexivity, pairs for antisymmetry, and triples for transitivity)
that must be modified/added/removed to make the relation satisfy the
property.
</p>
<p>If <code>tuples</code> is true, a set of tuples of objects for which the
respective property is violated. 
</p>


<h3>See Also</h3>

<p><a href="#topic+predicates">predicates</a> for the definitions of the properties.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## partial order:
R &lt;- as.relation(1:3)
relation_incidence(R)
## R clearly is transitive, but not symmetric:
relation_violations(R, "transitive")
relation_violations(R, "symmetric")
## Pairs for which symmetry is violated:
relation_violations(R, "symmetric", TRUE)

## create a simple relation:
require("sets")				# set(), pair() etc.
R &lt;- relation(domain = letters[1:2],
              graph = set(pair("a","b"), pair("b","a")))
relation_incidence(R)
## R is clearly symmetric, but not antisymmetric:
relation_violations(R, "symmetric")
relation_violations(R, "antisymmetric")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
