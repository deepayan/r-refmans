<!DOCTYPE html><html><head><title>Help for package reproducible</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {reproducible}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#reproducible-package'><p>The <code>reproducible</code> package</p></a></li>
<li><a href='#.debugCache'><p>Attach debug info to return for Cache</p></a></li>
<li><a href='#.digest'><p>Calculate the hashes of multiple files</p></a></li>
<li><a href='#.file.move'><p>Move a file to a new location &ndash; Defunct &ndash; use <code>hardLinkOrCopy</code></p></a></li>
<li><a href='#.formalsNotInCurrentDots'><p>Identify which formals to a function are not in the current <code>...</code></p></a></li>
<li><a href='#.grepSysCalls'><p>Grep system calls</p></a></li>
<li><a href='#.isMemoised'><p>Evaluate whether a cacheId is memoised</p></a></li>
<li><a href='#.listFilesInArchive'><p>List files in either a <code>.zip</code> or or <code>.tar</code> file</p></a></li>
<li><a href='#.message'><p>The <code>reproducible</code> package environments</p></a></li>
<li><a href='#.prefix'><p>Add a prefix or suffix to the basename part of a file path</p></a></li>
<li><a href='#.prepareFileBackedRaster'><p>Copy the file-backing of a file-backed Raster* object</p></a></li>
<li><a href='#.purge'><p>Purge individual line items from checksums file</p></a></li>
<li><a href='#.removeCacheAtts'><p>Remove attributes that are highly varying</p></a></li>
<li><a href='#.requireNamespace'><p>Provide standard messaging for missing package dependencies</p></a></li>
<li><a href='#.robustDigest'><p>Create reproducible digests of objects in R</p></a></li>
<li><a href='#.setSubAttrInList'><p>Set subattributes within a list by reference</p></a></li>
<li><a href='#.sortDotsUnderscoreFirst'><p>Exported generics and methods</p></a></li>
<li><a href='#.wrap'><p>Deal with class for saving to and loading from Cache or Disk</p></a></li>
<li><a href='#archiveExtractBinary'><p>Tests if unrar or 7zip exist</p></a></li>
<li><a href='#assessDataType'><p>Assess the appropriate raster layer data type</p></a></li>
<li><a href='#basename2'><p>A version of <code>base::basename</code> that is <code>NULL</code> resistant</p></a></li>
<li><a href='#Cache'><p>Saves a wide variety function call outputs to disk and optionally RAM, for recovery later</p></a></li>
<li><a href='#CacheDigest'><p>The exact digest function that <code>Cache</code> uses</p></a></li>
<li><a href='#CacheGeo'><p>Cache-like function for spatial domains</p></a></li>
<li><a href='#checkAndMakeCloudFolderID'><p>Check for presence of <code>checkFolderID</code> (for <code>Cache(useCloud)</code>)</p></a></li>
<li><a href='#checkPath'><p>Check directory path</p></a></li>
<li><a href='#checkRelative'><p>An alternative to <code>basename</code> and <code>dirname</code> when there are sub-folders</p></a></li>
<li><a href='#Checksums'><p>Calculate checksum</p></a></li>
<li><a href='#cloudDownload'><p>Download from cloud, if necessary</p></a></li>
<li><a href='#cloudUploadFromCache'><p>Upload a file to cloud directly from local <code>cachePath</code></p></a></li>
<li><a href='#compareNA'><p><code>NA</code>-aware comparison of two vectors</p></a></li>
<li><a href='#convertPaths'><p>Change the absolute path of a file</p></a></li>
<li><a href='#Copy'><p>Recursive copying of nested environments, and other &quot;hard to copy&quot; objects</p></a></li>
<li><a href='#copySingleFile'><p>Copy a file using <code>robocopy</code> on Windows and <code>rsync</code> on Linux/macOS</p></a></li>
<li><a href='#createCache'><p>Low-level functions to create and work with a cache</p></a></li>
<li><a href='#deprecated'><p>Crop a <code style="white-space: pre;">&#8288;Spatial*&#8288;</code> or <code style="white-space: pre;">&#8288;Raster*&#8288;</code> object</p></a></li>
<li><a href='#determineFilename'><p>Determine filename, either automatically or manually</p></a></li>
<li><a href='#dlGeneric'><p>Download file from generic source url</p></a></li>
<li><a href='#dlGoogle'><p>Download file from Google Drive</p></a></li>
<li><a href='#downloadFile'><p>A wrapper around a set of downloading functions</p></a></li>
<li><a href='#downloadRemote'><p>Download a remote file</p></a></li>
<li><a href='#extractFromArchive'><p>Extract files from archive</p></a></li>
<li><a href='#fastMask'><p>Faster operations on rasters (DEPRECATED because <code>terra::mask</code> is fast)</p></a></li>
<li><a href='#Filenames'><p>Return the filename(s) from a <code style="white-space: pre;">&#8288;Raster*&#8288;</code> object</p></a></li>
<li><a href='#fixErrorsIn'><p>Fix common errors in GIS layers, using <code>terra</code></p></a></li>
<li><a href='#gdalProject'><p>3-Step postProcess sequence for SpatRasters using <code>gdalwarp</code></p></a></li>
<li><a href='#getRelative'><p>Relative paths</p></a></li>
<li><a href='#guessAtTarget'><p>Try to pick a file to load</p></a></li>
<li><a href='#internetExists'><p>Checks for existed of a url or the internet using <a href="https://CRAN.R-project.org">https://CRAN.R-project.org</a></p></a></li>
<li><a href='#isInteractive'><p>Alternative to <code>interactive()</code> for unit testing</p></a></li>
<li><a href='#isUpdated'><p>Has a cached object has been updated?</p></a></li>
<li><a href='#isWindows'><p>Test whether system is Windows</p></a></li>
<li><a href='#keepOrigGeom'><p>Keep original geometries of <code>sf</code> objects</p></a></li>
<li><a href='#linkOrCopy'><p>Hardlink, symlink, or copy a file</p></a></li>
<li><a href='#listNamed'><p>Create a list with names from object names</p></a></li>
<li><a href='#loadFile'><p>Load a file from the cache</p></a></li>
<li><a href='#mergeCache'><p>Merge two cache repositories together</p></a></li>
<li><a href='#messageDF'><p>Use <code>message</code> with a consistent use of <code>verbose</code></p></a></li>
<li><a href='#minFn'><p>Get min or maximum value of a (Spat)Raster</p></a></li>
<li><a href='#movedCache'><p>Deal with moved cache issues</p></a></li>
<li><a href='#normPath'><p>Normalize file paths</p></a></li>
<li><a href='#objSize'><p>Wrapper around <code>lobstr::obj_size</code></p></a></li>
<li><a href='#paddedFloatToChar'><p>Convert numeric to character with padding</p></a></li>
<li><a href='#Path-class'><p>Coerce a character string to a class &quot;Path&quot;</p></a></li>
<li><a href='#postProcess'><p>Generic function to post process objects</p></a></li>
<li><a href='#postProcessTo'><p>Transform a GIS dataset so it has the properties (extent, projection, mask) of another</p></a></li>
<li><a href='#prepInputs'><p>Download and optionally post-process files</p></a></li>
<li><a href='#preProcessParams'><p>Download, Checksum, Extract files</p></a></li>
<li><a href='#rasterRead'><p>A helper to <code>getOption("reproducible.rasterRead")</code></p></a></li>
<li><a href='#remapFilenames'><p>Remap file names</p></a></li>
<li><a href='#reproducibleOptions'><p><code>reproducible</code> options</p></a></li>
<li><a href='#retry'><p>A wrapper around <code>try</code> that retries on failure</p></a></li>
<li><a href='#saveToCache'><p>Save an object to Cache</p></a></li>
<li><a href='#searchFull'><p>Search up the full scope for functions</p></a></li>
<li><a href='#set.randomseed'><p>Set seed with a random value using Sys.time()</p></a></li>
<li><a href='#showCache'><p>Examining and modifying the cache</p></a></li>
<li><a href='#studyAreaName'><p>Get a unique name for a given study area</p></a></li>
<li><a href='#tempdir2'><p>Make a temporary (sub-)directory</p></a></li>
<li><a href='#tempfile2'><p>Make a temporary file in a temporary (sub-)directory</p></a></li>
<li><a href='#testForArchiveExtract'><p>Returns unrar path and creates a shortcut as .unrarPath</p>
Was not incorporated in previous function so it can be
used in the tests</a></li>
<li><a href='#unrarPath'><p>The known path for unrar or 7z</p></a></li>
<li><a href='#writeFuture'><p>Write to cache repository, using <code>future::future</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Enhance Reproducibility of R Code</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of high-level, machine- and OS-independent tools
    for making reproducible and reusable content in R.
    The two workhorse functions are Cache() and prepInputs(). Cache()
    allows for nested caching, is robust to environments and objects with
    environments (like functions), and has deals with some classes of 
    file-backed R objects e.g., from terra and raster packages. 
    Both functions have been developed to 
    be foundational components of data retrieval
    and processing in continuous workflow situations. In both functions,
    efforts are made to make the first and subsequent calls of functions have 
    the same result, but faster at subsequent times by way of checksums
    and digesting. Several features are still under development, including
    cloud storage of cached objects, allowing for sharing between users. Several
    advanced options are available, see ?reproducibleOptions().</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>'unrar' (Linux/macOS) or '7-Zip' (Windows) to work
with '.rar' files.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://reproducible.predictiveecology.org">https://reproducible.predictiveecology.org</a>,
<a href="https://github.com/PredictiveEcology/reproducible">https://github.com/PredictiveEcology/reproducible</a></td>
</tr>
<tr>
<td>Date:</td>
<td>2024-05-27</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.0</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table (&ge; 1.10.4), digest, filelock, fpCompare, fs,
lobstr, methods, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>archive, covr, crayon, DBI, future, geodata, glue,
googledrive, httr, knitr, parallel, qs, raster (&ge; 3.5-15),
RCurl (&ge; 1.95-4.8), rlang, rmarkdown, RSQLite, R.utils, sf, sp
(&ge; 1.4-2), terra (&ge; 1.7-20), testthat, withr</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://predictiveecology.r-universe.dev/">https://predictiveecology.r-universe.dev/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-CA</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/PredictiveEcology/reproducible/issues">https://github.com/PredictiveEcology/reproducible/issues</a></td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Collate:</td>
<td>'DBI.R' 'cache-helpers.R' 'cache-internals.R' 'robustDigest.R'
'cache.R' 'cacheGeo.R' 'checksums.R' 'cloud.R' 'convertPaths.R'
'copy.R' 'download.R' 'messages.R' 'exportedMethods.R' 'gis.R'
'helpers.R' 'listNamed.R' 'objectSize.R' 'options.R'
'packages.R' 'paths.R' 'pipe.R' 'postProcess.R'
'postProcessTo.R' 'preProcess.R' 'prepInputs.R'
'reproducible-deprecated.R' 'reproducible-package.R' 'search.R'
'showCacheEtc.R' 'spatialObjects-class.R' 'terra-migration.R'
'zzz.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-29 18:22:29 UTC; achubaty</td>
</tr>
<tr>
<td>Author:</td>
<td>Eliot J B McIntire
    <a href="https://orcid.org/0000-0002-6914-8316"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Alex M Chubaty <a href="https://orcid.org/0000-0001-7146-8135"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Tati Micheletti <a href="https://orcid.org/0000-0003-4838-8342"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Ceres Barros <a href="https://orcid.org/0000-0003-4036-977X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Ian Eddy <a href="https://orcid.org/0000-0001-7397-2116"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  His Majesty the King in Right of Canada, as represented by the Minister
    of Natural Resources Canada [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eliot J B McIntire &lt;eliot.mcintire@canada.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-30 00:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='reproducible-package'>The <code>reproducible</code> package</h2><span id='topic+reproducible'></span><span id='topic+reproducible-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/lifecycle-maturing.svg" alt="maturing" />
</p>
<p>This package aims at making
high-level, robust, machine and OS independent tools for making deeply
reproducible and reusable content in R. The core user functions are <code>Cache</code>
and <code>prepInputs</code>. Each of these is built around many core and edge cases
required to have reproducible code of arbitrary complexity.
</p>


<h3>Main Tools</h3>

<p>There are many elements within the reproducible package.
However, there are currently two main ones that are critical for reproducible research.
The key element for reproducible research is that the code must always return the same content
every time it is run, but it must be vastly faster the 2nd, 3rd, 4th etc, time it is run.
That way, the entire code sequence for a project of arbitrary size can be run
<em>from the start</em> every time.
</p>

<dl>
<dt><code><a href="#topic+Cache">Cache()</a></code>:</dt><dd><p>A robust wrapper for any function, including those with environments,
disk-backed storage (currently on <code>Raster</code>) class), operating-system independent,
whose first time called will execute the function, second time will compare the inputs to a
database of entries, and recover the first result if inputs are identical.
If <code>options("reproducible.useMemoise" = TRUE)</code>, the second time will be very fast as it
will recover the answer from RAM.</p>
</dd>
<dt><code><a href="#topic+prepInputs">prepInputs()</a></code>for other specifics for other classes.:</dt><dd><p> Download, or load objects, and possibly post-process them.
The main advantage to using this over more direct routes is that it will automatically build
checksums tables, use <code>Cache</code> internally where helpful, and possibly run a variety of
post-processing actions.
This means this function can also itself be cached for even more speed.
This allows all project data to be stored in custom cloud locations or in their original online
data repositories, <code style="white-space: pre;">&#8288;without altering code&#8288;</code> between the first, second, third, etc., times
the code is run.</p>
</dd>
</dl>



<h3>Package options</h3>

<p>See <code><a href="#topic+reproducibleOptions">reproducibleOptions()</a></code> for a complete description of package
<code><a href="base.html#topic+options">options()</a></code> to configure behaviour.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Eliot J B McIntire <a href="mailto:eliot.mcintire@canada.ca">eliot.mcintire@canada.ca</a> (<a href="https://orcid.org/0000-0002-6914-8316">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Alex M Chubaty <a href="mailto:achubaty@for-cast.ca">achubaty@for-cast.ca</a> (<a href="https://orcid.org/0000-0001-7146-8135">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Tati Micheletti <a href="mailto:tati.micheletti@gmail.com">tati.micheletti@gmail.com</a> (<a href="https://orcid.org/0000-0003-4838-8342">ORCID</a>) [contributor]
</p>
</li>
<li><p> Ceres Barros <a href="mailto:ceres.barros@ubc.ca">ceres.barros@ubc.ca</a> (<a href="https://orcid.org/0000-0003-4036-977X">ORCID</a>) [contributor]
</p>
</li>
<li><p> Ian Eddy <a href="mailto:ian.eddy@nrcan-rncan.gc.ca">ian.eddy@nrcan-rncan.gc.ca</a> (<a href="https://orcid.org/0000-0001-7397-2116">ORCID</a>) [contributor]
</p>
</li>
<li><p> His Majesty the King in Right of Canada, as represented by the Minister of Natural Resources Canada [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://reproducible.predictiveecology.org">https://reproducible.predictiveecology.org</a>
</p>
</li>
<li> <p><a href="https://github.com/PredictiveEcology/reproducible">https://github.com/PredictiveEcology/reproducible</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/PredictiveEcology/reproducible/issues">https://github.com/PredictiveEcology/reproducible/issues</a>
</p>
</li></ul>


<hr>
<h2 id='.debugCache'>Attach debug info to return for Cache</h2><span id='topic+.debugCache'></span>

<h3>Description</h3>

<p>Internal use only. Attaches an attribute to the output, usable for
debugging the Cache.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.debugCache(obj, preDigest, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".debugCache_+3A_obj">obj</code></td>
<td>
<p>An arbitrary R object.</p>
</td></tr>
<tr><td><code id=".debugCache_+3A_predigest">preDigest</code></td>
<td>
<p>A list of hashes.</p>
</td></tr>
<tr><td><code id=".debugCache_+3A_...">...</code></td>
<td>
<p>Dots passed from Cache</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same object as <code>obj</code>, but with 2 attributes set.
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>

<hr>
<h2 id='.digest'>Calculate the hashes of multiple files</h2><span id='topic+.digest'></span><span id='topic+.digest+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Internal function. Wrapper for <code><a href="digest.html#topic+digest">digest::digest()</a></code> using <code>xxhash64</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.digest(file, quickCheck, ...)

## S4 method for signature 'character'
.digest(file, quickCheck, algo = "xxhash64", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".digest_+3A_file">file</code></td>
<td>
<p>Character vector of file paths.</p>
</td></tr>
<tr><td><code id=".digest_+3A_quickcheck">quickCheck</code></td>
<td>
<p>Logical indicating whether to use a fast file size check as a heuristic
for determining changes to a file.</p>
</td></tr>
<tr><td><code id=".digest_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>digest::digest</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of hashes.
</p>


<h3>Author(s)</h3>

<p>Alex Chubaty
</p>

<hr>
<h2 id='.file.move'>Move a file to a new location &ndash; Defunct &ndash; use <code>hardLinkOrCopy</code></h2><span id='topic+.file.move'></span>

<h3>Description</h3>

<p>This will first try to <code>file.rename</code>, and if that fails, then it will
<code>file.copy</code> then <code>file.remove</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.file.move(from, to, overwrite = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".file.move_+3A_from">from</code>, <code id=".file.move_+3A_to">to</code></td>
<td>
<p>character vectors, containing file names or paths.</p>
</td></tr>
<tr><td><code id=".file.move_+3A_overwrite">overwrite</code></td>
<td>
<p>logical indicating whether to overwrite destination file if it exists.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical indicating whether operation succeeded.
</p>

<hr>
<h2 id='.formalsNotInCurrentDots'>Identify which formals to a function are not in the current <code>...</code></h2><span id='topic+.formalsNotInCurrentDots'></span>

<h3>Description</h3>

<p>Advanced use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.formalsNotInCurrentDots(fun, ..., dots, formalNames, signature = character())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".formalsNotInCurrentDots_+3A_fun">fun</code></td>
<td>
<p>A function</p>
</td></tr>
<tr><td><code id=".formalsNotInCurrentDots_+3A_...">...</code></td>
<td>
<p>The ... from inside a function. Will be ignored if <code>dots</code> is
provided explicitly.</p>
</td></tr>
<tr><td><code id=".formalsNotInCurrentDots_+3A_dots">dots</code></td>
<td>
<p>Optional. If this is provided via say <code>dots = list(...)</code>,
then this will cause the <code>...</code> to be ignored.</p>
</td></tr>
<tr><td><code id=".formalsNotInCurrentDots_+3A_formalnames">formalNames</code></td>
<td>
<p>Optional character vector. If provided then it will override the <code>fun</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the formals of the <code>fun</code> that are missing from the <code>...</code> or <code>dots</code>.
</p>

<hr>
<h2 id='.grepSysCalls'>Grep system calls</h2><span id='topic+.grepSysCalls'></span>

<h3>Description</h3>

<p>A faster way of grepping the system call stack than just
<code>grep(sys.calls(), pattern = "test")</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.grepSysCalls(sysCalls, pattern)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".grepSysCalls_+3A_syscalls">sysCalls</code></td>
<td>
<p>The return from <code>sys.calls()</code></p>
</td></tr>
<tr><td><code id=".grepSysCalls_+3A_pattern">pattern</code></td>
<td>
<p>Character, passed to grep</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector, equivalent to return from <code>grep(sys.calls(), pattern = "test")</code>,
but faster if <code>sys.calls()</code> is very big.
</p>

<hr>
<h2 id='.isMemoised'>Evaluate whether a cacheId is memoised</h2><span id='topic+.isMemoised'></span>

<h3>Description</h3>

<p>Intended for internal use. Exported so other packages can use this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.isMemoised(cacheId, cachePath = getOption("reproducible.cachePath"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".isMemoised_+3A_cacheid">cacheId</code></td>
<td>
<p>Character string. If passed, this will override the calculated hash
of the inputs, and return the result from this cacheId in the <code>cachePath</code>.
Setting this is equivalent to manually saving the output of this function, i.e.,
the object will be on disk, and will be recovered in subsequent
This may help in some particularly finicky situations
where Cache is not correctly detecting unchanged inputs. This will guarantee
the object will be identical each time; this may be useful in operational code.</p>
</td></tr>
<tr><td><code id=".isMemoised_+3A_cachepath">cachePath</code></td>
<td>
<p>A repository used for storing cached objects.
This is optional if <code>Cache</code> is used inside a SpaDES module.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical, length 1 indicating whether the <code>cacheId</code> is memoised.
</p>

<hr>
<h2 id='.listFilesInArchive'>List files in either a <code>.zip</code> or or <code>.tar</code> file</h2><span id='topic+.listFilesInArchive'></span>

<h3>Description</h3>

<p>Makes the outputs from<code style="white-space: pre;">&#8288;.tar``.zip&#8288;</code> the same, which they aren't by default.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.listFilesInArchive(archive)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".listFilesInArchive_+3A_archive">archive</code></td>
<td>
<p>A character string of a single file name to list files in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string of all files in the archive.
</p>

<hr>
<h2 id='.message'>The <code>reproducible</code> package environments</h2><span id='topic+.message'></span><span id='topic+.pkgEnv'></span>

<h3>Description</h3>

<p>Environment used internally to store internal package objects and methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.message

.pkgEnv
</code></pre>


<h3>Format</h3>

<p>An object of class <code>environment</code> of length 18.
</p>
<p>An object of class <code>environment</code> of length 2.
</p>


<h3>Details</h3>


<ul>
<li> <p><code>.message</code> is specifically for messages and message-generating functions;
</p>
</li>
<li> <p><code>.pkgEnv</code> is for general use within the package;
</p>
</li>
<li> <p><code>.reproEnv</code> is used for <code>Cache</code>-related objects;
</p>
</li></ul>


<hr>
<h2 id='.prefix'>Add a prefix or suffix to the basename part of a file path</h2><span id='topic+.prefix'></span><span id='topic+suffix'></span><span id='topic+.suffix'></span>

<h3>Description</h3>

<p>Prepend (or postpend) a filename with a prefix (or suffix).
If the directory name of the file cannot be ascertained from its path,
it is assumed to be in the current working directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.prefix(f, prefix = "")

.suffix(f, suffix = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".prefix_+3A_f">f</code></td>
<td>
<p>A character string giving the name/path of a file.</p>
</td></tr>
<tr><td><code id=".prefix_+3A_prefix">prefix</code></td>
<td>
<p>A character string to prepend to the filename.</p>
</td></tr>
<tr><td><code id=".prefix_+3A_suffix">suffix</code></td>
<td>
<p>A character string to postpend to the filename.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string or vector with the prefix pre-pended or suffix post-pended
on the <code>basename</code> of the <code>f</code>, before the file extension.
</p>


<h3>Author(s)</h3>

<p>Jean Marchal and Alex Chubaty
</p>


<h3>Examples</h3>

<pre><code class='language-R'># file's full path is specified (i.e., dirname is known)
myFile &lt;- file.path("~/data", "file.tif")
.prefix(myFile, "small_") ## "/home/username/data/small_file.tif"
.suffix(myFile, "_cropped") ## "/home/username/data/myFile_cropped.shp"

# file's full path is not specified
.prefix("myFile.shp", "small") ## "./small_myFile.shp"
.suffix("myFile.shp", "_cropped") ## "./myFile_cropped.shp"

</code></pre>

<hr>
<h2 id='.prepareFileBackedRaster'>Copy the file-backing of a file-backed Raster* object</h2><span id='topic+.prepareFileBackedRaster'></span>

<h3>Description</h3>

<p>Rasters are sometimes file-based, so the normal save and copy and assign
mechanisms in R don't work for saving, copying and assigning.
This function creates an explicit file copy of the file that is backing the raster,
and changes the pointer (i.e., <code>filename(object)</code>) so that it is pointing
to the new file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.prepareFileBackedRaster(
  obj,
  repoDir = NULL,
  overwrite = FALSE,
  drv = getDrv(getOption("reproducible.drv", NULL)),
  conn = getOption("reproducible.conn", NULL),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".prepareFileBackedRaster_+3A_obj">obj</code></td>
<td>
<p>The raster object to save to the repository.</p>
</td></tr>
<tr><td><code id=".prepareFileBackedRaster_+3A_repodir">repoDir</code></td>
<td>
<p>Character denoting an existing directory in which an artifact will be saved.</p>
</td></tr>
<tr><td><code id=".prepareFileBackedRaster_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical. Should the raster be saved to disk, overwriting existing file.</p>
</td></tr>
<tr><td><code id=".prepareFileBackedRaster_+3A_drv">drv</code></td>
<td>
<p>if using a database backend, drv must be an object that
inherits from DBIDriver e.g., from package RSQLite, e.g., SQLite</p>
</td></tr>
<tr><td><code id=".prepareFileBackedRaster_+3A_conn">conn</code></td>
<td>
<p>an optional DBIConnection object, as returned by dbConnect().</p>
</td></tr>
<tr><td><code id=".prepareFileBackedRaster_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A raster object and its newly located file backing.
Note that if this is a legitimate Cache repository, the new location
will be a subdirectory called &lsquo;<span class="file">rasters/</span>&rsquo; of &lsquo;<span class="file">repoDir/</span>&rsquo;.
If this is not a repository, the new location will be within <code>repoDir</code>.
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>

<hr>
<h2 id='.purge'>Purge individual line items from checksums file</h2><span id='topic+.purge'></span>

<h3>Description</h3>

<p>Purge individual line items from checksums file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.purge(
  checkSums,
  purge,
  targetFile,
  archive,
  alsoExtract,
  url,
  destinationPath
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".purge_+3A_checksums">checkSums</code></td>
<td>
<p>A checksums file, e.g., created by Checksums(..., write = TRUE)</p>
</td></tr>
<tr><td><code id=".purge_+3A_purge">purge</code></td>
<td>
<p>Logical or Integer. <code>0/FALSE</code> (default) keeps existing
<code>CHECKSUMS.txt</code> file and
<code>prepInputs</code> will write or append to it. <code>1/TRUE</code> will deleted the entire
<code>CHECKSUMS.txt</code> file. Other options, see details.</p>
</td></tr>
<tr><td><code id=".purge_+3A_targetfile">targetFile</code></td>
<td>
<p>Character string giving the filename (without relative or
absolute path) to the eventual file
(raster, shapefile, csv, etc.) after downloading and extracting from a zip
or tar archive. This is the file <em>before</em> it is passed to
<code>postProcess</code>. The internal checksumming does not checksum
the file after it is <code>postProcess</code>ed (e.g., cropped/reprojected/masked).
Using <code>Cache</code> around <code>prepInputs</code> will do a sufficient job in these cases.
See table in <code><a href="#topic+preProcess">preProcess()</a></code>.</p>
</td></tr>
<tr><td><code id=".purge_+3A_archive">archive</code></td>
<td>
<p>Optional character string giving the path of an archive
containing <code>targetFile</code>, or a vector giving a set of nested archives
(e.g., <code>c("xxx.tar", "inner.zip", "inner.rar")</code>). If there is/are (an) inner
archive(s), but they are unknown, the function will try all until it finds
the <code>targetFile</code>. See table in <code><a href="#topic+preProcess">preProcess()</a></code>. If it is <code>NA</code>,
then it will <em>not</em> attempt to see it as an archive, even if it has archive-like
file extension (e.g., <code>.zip</code>). This may be useful when an R function
is expecting an archive directly.</p>
</td></tr>
<tr><td><code id=".purge_+3A_url">url</code></td>
<td>
<p>Optional character string indicating the URL to download from.
If not specified, then no download will be attempted. If not entry
exists in the <code>CHECKSUMS.txt</code> (in <code>destinationPath</code>), an entry
will be created or appended to. This <code>CHECKSUMS.txt</code> entry will be used
in subsequent calls to
<code>prepInputs</code> or <code>preProcess</code>, comparing the file on hand with the ad hoc
<code>CHECKSUMS.txt</code>. See table in <code><a href="#topic+preProcess">preProcess()</a></code>.</p>
</td></tr>
<tr><td><code id=".purge_+3A_destinationpath">destinationPath</code></td>
<td>
<p>Character string of a directory in which to download
and save the file that comes from <code>url</code> and is also where the function
will look for <code>archive</code> or <code>targetFile</code>. NOTE (still experimental):
To prevent repeated downloads in different locations, the user can also set
<code>options("reproducible.inputPaths")</code> to one or more local file paths to
search for the file before attempting to download. Default for that option is
<code>NULL</code> meaning do not search locally.</p>
</td></tr>
</table>

<hr>
<h2 id='.removeCacheAtts'>Remove attributes that are highly varying</h2><span id='topic+.removeCacheAtts'></span>

<h3>Description</h3>

<p>Remove attributes that are highly varying
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.removeCacheAtts(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".removeCacheAtts_+3A_x">x</code></td>
<td>
<p>Any arbitrary R object that could have attributes</p>
</td></tr>
</table>

<hr>
<h2 id='.requireNamespace'>Provide standard messaging for missing package dependencies</h2><span id='topic+.requireNamespace'></span>

<h3>Description</h3>

<p>This provides a standard message format for missing packages, e.g.,
detected via <code>requireNamespace</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.requireNamespace(
  pkg = "methods",
  minVersion = NULL,
  stopOnFALSE = FALSE,
  messageStart = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".requireNamespace_+3A_pkg">pkg</code></td>
<td>
<p>Character string indicating name of package required</p>
</td></tr>
<tr><td><code id=".requireNamespace_+3A_minversion">minVersion</code></td>
<td>
<p>Character string indicating minimum version of package
that is needed</p>
</td></tr>
<tr><td><code id=".requireNamespace_+3A_stoponfalse">stopOnFALSE</code></td>
<td>
<p>Logical. If <code>TRUE</code>, this function will create an
error (i.e., <code>stop</code>) if the function returns <code>FALSE</code>; otherwise
it simply returns <code>FALSE</code></p>
</td></tr>
<tr><td><code id=".requireNamespace_+3A_messagestart">messageStart</code></td>
<td>
<p>A character string with a prefix of message to provide</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical or stop if the namespace is not available to be loaded.
</p>

<hr>
<h2 id='.robustDigest'>Create reproducible digests of objects in R</h2><span id='topic+.robustDigest'></span><span id='topic+.robustDigest+2CANY-method'></span><span id='topic+.robustDigest+2Cfunction-method'></span><span id='topic+.robustDigest+2Cexpression-method'></span><span id='topic+.robustDigest+2Clanguage-method'></span><span id='topic+.robustDigest+2Ccharacter-method'></span><span id='topic+.robustDigest+2CPath-method'></span><span id='topic+.robustDigest+2Cenvironment-method'></span><span id='topic+.robustDigest+2Clist-method'></span><span id='topic+.robustDigest+2Cdata.frame-method'></span><span id='topic+.robustDigest+2Cnumeric-method'></span><span id='topic+.robustDigest+2Cmatrix-method'></span><span id='topic+.robustDigest+2Cinteger-method'></span>

<h3>Description</h3>

<p>Not all aspects of R objects are captured by current hashing tools in R
(e.g. <code>digest::digest</code>, <code>knitr</code> caching, <code>archivist::cache</code>).
This is mostly because many objects have &quot;transient&quot;
(e.g., functions have environments), or &quot;disk-backed&quot; features.
Since the goal of using reproducibility is to have tools that are not session specific,
this function attempts to strip all session specific information so that the digest
works between sessions and operating systems.
It is tested under many conditions and object types, there are bound to be others that don't
work correctly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.robustDigest(
  object,
  .objects = NULL,
  length = getOption("reproducible.length", Inf),
  algo = "xxhash64",
  quick = getOption("reproducible.quick", FALSE),
  classOptions = list(),
  ...
)

## S4 method for signature 'ANY'
.robustDigest(object, .objects, length, algo, quick, classOptions)

## S4 method for signature 'function'
.robustDigest(object, .objects, length, algo, quick, classOptions)

## S4 method for signature 'expression'
.robustDigest(object, .objects, length, algo, quick, classOptions)

## S4 method for signature 'language'
.robustDigest(object, .objects, length, algo, quick, classOptions)

## S4 method for signature 'character'
.robustDigest(object, .objects, length, algo, quick, classOptions)

## S4 method for signature 'Path'
.robustDigest(object, .objects, length, algo, quick, classOptions)

## S4 method for signature 'environment'
.robustDigest(object, .objects, length, algo, quick, classOptions)

## S4 method for signature 'list'
.robustDigest(object, .objects, length, algo, quick, classOptions)

## S4 method for signature 'data.frame'
.robustDigest(object, .objects, length, algo, quick, classOptions)

## S4 method for signature 'numeric'
.robustDigest(object, .objects, length, algo, quick, classOptions)

## S4 method for signature 'matrix'
.robustDigest(object, .objects, length, algo, quick, classOptions)

## S4 method for signature 'integer'
.robustDigest(object, .objects, length, algo, quick, classOptions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".robustDigest_+3A_object">object</code></td>
<td>
<p>an object to digest.</p>
</td></tr>
<tr><td><code id=".robustDigest_+3A_.objects">.objects</code></td>
<td>
<p>Character vector of objects to be digested. This is only applicable
if there is a list, environment (or similar) with named objects
within it. Only this/these objects will be considered for caching,
i.e., only use a subset of
the list, environment or similar objects. In the case of nested list-type
objects, this will only be applied outermost first.</p>
</td></tr>
<tr><td><code id=".robustDigest_+3A_length">length</code></td>
<td>
<p>Numeric. If the element passed to Cache is a <code>Path</code> class
object (from e.g., <code>asPath(filename)</code>) or it is a <code>Raster</code> with
file-backing, then this will be
passed to <code>digest::digest</code>, essentially limiting the number of bytes
to digest (for speed). This will only be used if <code>quick = FALSE</code>.
Default is <code>getOption("reproducible.length")</code>, which is set to <code>Inf</code>.</p>
</td></tr>
<tr><td><code id=".robustDigest_+3A_algo">algo</code></td>
<td>
<p>The algorithms to be used; currently available choices are
<code>md5</code>, which is also the default, <code>sha1</code>, <code>crc32</code>,
<code>sha256</code>, <code>sha512</code>, <code>xxhash32</code>, <code>xxhash64</code>,
<code>murmur32</code>, <code>spookyhash</code>, <code>blake3</code>, <code>crc32c</code>,
<code>xxh3_64</code>, and <code>xxh3_128</code>.</p>
</td></tr>
<tr><td><code id=".robustDigest_+3A_quick">quick</code></td>
<td>
<p>Logical or character. If <code>TRUE</code>,
no disk-based information will be assessed, i.e., only
memory content. See Details section about <code>quick</code> in <code><a href="#topic+Cache">Cache()</a></code>.</p>
</td></tr>
<tr><td><code id=".robustDigest_+3A_classoptions">classOptions</code></td>
<td>
<p>Optional list. This will pass into <code>.robustDigest</code> for
specific classes. Should be options that the <code>.robustDigest</code> knows what
to do with.</p>
</td></tr>
<tr><td><code id=".robustDigest_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>FUN</code>, if <code>FUN</code> is not an expression.</p>
</td></tr>
<tr><td><code id=".robustDigest_+3A_objects">objects</code></td>
<td>
<p>Optional character vector indicating which objects are to
be considered while making digestible. This argument is not used
in the default cases; the only known method that uses this
in the default cases; the only known method that uses this
argument is the <code>simList</code> class from <code>SpaDES.core</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A hash i.e., digest of the object passed in.
</p>


<h3>Classes</h3>

<p><code style="white-space: pre;">&#8288;Raster*&#8288;</code> objects have the potential for disk-backed storage, thus, require more work.
Also, because <code style="white-space: pre;">&#8288;Raster*&#8288;</code> can have a built-in representation for having their data content
located on disk, this format will be maintained if the raster already is file-backed,
i.e., to create <code>.tif</code> or <code>.grd</code> backed rasters, use <code>writeRaster</code> first,
then <code>Cache</code>.
The &lsquo;<span class="file">.tif</span>&rsquo; or &lsquo;<span class="file">.grd</span>&rsquo; will be copied to the &lsquo;<span class="file">raster/</span>&rsquo; subdirectory of the
<code>cachePath</code>.
Their RAM representation (as an R object) will still be in the usual  &lsquo;<span class="file">cacheOutputs/</span>&rsquo;
(or formerly &lsquo;<span class="file">gallery/</span>&rsquo;) directory.
For <code>inMemory</code> raster objects, they will remain as binary <code>.RData</code> files.
</p>
<p>Functions (which are contained within environments) are
converted to a text representation via a call to <code>format(FUN)</code>.
</p>
<p>Objects contained within a list or environment are recursively hashed
using <code><a href="digest.html#topic+digest">digest::digest()</a></code>, while removing all references to
environments.
</p>
<p>Character strings are first assessed with <code>dir.exists</code> and <code>file.exists</code>
to check for paths. If they are found to be paths, then the path is hashed with
only its filename via <code>basename(filename)</code>. If it is actually a path, we suggest
using <code>asPath(thePath)</code>
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
a &lt;- 2
tmpfile1 &lt;- tempfile()
tmpfile2 &lt;- tempfile()
tmpfile3 &lt;- tempfile(fileext = ".grd")
tmpfile4 &lt;- tempfile(fileext = ".grd")
save(a, file = tmpfile1)
save(a, file = tmpfile2)

# treats as character string, so 2 filenames are different
digest::digest(tmpfile1)
digest::digest(tmpfile2)

# tests to see whether character string is representing a file
.robustDigest(tmpfile1)
.robustDigest(tmpfile2) # same

# if you tell it that it is a path, then you can decide if you want it to be
#  treated as a character string or as a file path
.robustDigest(asPath(tmpfile1), quick = TRUE)
.robustDigest(asPath(tmpfile2), quick = TRUE) # different because using file info

.robustDigest(asPath(tmpfile1), quick = FALSE)
.robustDigest(asPath(tmpfile2), quick = FALSE) # same because using file content

# SpatRasters are have pointers
if (requireNamespace("terra", quietly = TRUE)) {
  r &lt;- terra::rast(system.file("ex/elev.tif", package = "terra"))
  r3 &lt;- terra::deepcopy(r)
  r1 &lt;- terra::writeRaster(r, filename = tmpfile3)

  digest::digest(r)
  digest::digest(r3) # different but should be same
  .robustDigest(r1)
  .robustDigest(r3) # same... data &amp; metadata are the same

  # note, this is not true for comparing memory and file-backed rasters
  .robustDigest(r)
  .robustDigest(r1) # different
}

</code></pre>

<hr>
<h2 id='.setSubAttrInList'>Set subattributes within a list by reference</h2><span id='topic+.setSubAttrInList'></span>

<h3>Description</h3>

<p>Sets only a single element within a list attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.setSubAttrInList(object, attr, subAttr, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".setSubAttrInList_+3A_object">object</code></td>
<td>
<p>An arbitrary object</p>
</td></tr>
<tr><td><code id=".setSubAttrInList_+3A_attr">attr</code></td>
<td>
<p>The attribute name (that is a list object) to change</p>
</td></tr>
<tr><td><code id=".setSubAttrInList_+3A_subattr">subAttr</code></td>
<td>
<p>The list element name to change</p>
</td></tr>
<tr><td><code id=".setSubAttrInList_+3A_value">value</code></td>
<td>
<p>The new value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This sets or updates the <code>subAttr</code> element of a list that is located at
<code>attr(object, attr)</code>, with the <code>value</code>. This, therefore, updates a sub-element
of a list attribute and returns that same object with the updated attribute.
</p>

<hr>
<h2 id='.sortDotsUnderscoreFirst'>Exported generics and methods</h2><span id='topic+.sortDotsUnderscoreFirst'></span><span id='topic+.orderDotsUnderscoreFirst'></span><span id='topic+ExportedMethods'></span><span id='topic+.tagsByClass'></span><span id='topic+.tagsByClass+2CANY-method'></span><span id='topic+.cacheMessage'></span><span id='topic+.cacheMessage+2CANY-method'></span><span id='topic+.cacheMessageObjectToRetrieve'></span><span id='topic+.addTagsToOutput'></span><span id='topic+.addTagsToOutput+2CANY-method'></span><span id='topic+.preDigestByClass'></span><span id='topic+.preDigestByClass+2CANY-method'></span><span id='topic+.checkCacheRepo'></span><span id='topic+.checkCacheRepo+2CANY-method'></span><span id='topic+.prepareOutput'></span><span id='topic+.prepareOutput+2CANY-method'></span><span id='topic+.addChangedAttr'></span><span id='topic+.addChangedAttr+2CANY-method'></span><span id='topic+updateFilenameSlots'></span><span id='topic+updateFilenameSlots.default'></span><span id='topic+updateFilenameSlots.list'></span><span id='topic+updateFilenameSlots.environment'></span><span id='topic+makeMemoisable'></span><span id='topic+makeMemoisable.default'></span><span id='topic+makeMemoisable.data.table'></span><span id='topic+unmakeMemoisable'></span><span id='topic+unmakeMemoisable.default'></span>

<h3>Description</h3>

<p>There are a number of generics that are exported for other packages to use.
These are listed below. They are not intended for use by normal users; rather,
they are made available for package developers to build specific methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.sortDotsUnderscoreFirst(obj)

.orderDotsUnderscoreFirst(obj)

.tagsByClass(object)

## S4 method for signature 'ANY'
.tagsByClass(object)

.cacheMessage(
  object,
  functionName,
  fromMemoise = getOption("reproducible.useMemoise", TRUE),
  verbose = getOption("reproducible.verbose", 1)
)

## S4 method for signature 'ANY'
.cacheMessage(
  object,
  functionName,
  fromMemoise = getOption("reproducible.useMemoise", TRUE),
  verbose = getOption("reproducible.verbose", 1)
)

.cacheMessageObjectToRetrieve(
  functionName,
  fullCacheTableForObj,
  cachePath,
  cacheId,
  verbose
)

.addTagsToOutput(object, outputObjects, FUN, preDigestByClass)

## S4 method for signature 'ANY'
.addTagsToOutput(object, outputObjects, FUN, preDigestByClass)

.preDigestByClass(object)

## S4 method for signature 'ANY'
.preDigestByClass(object)

.checkCacheRepo(
  object,
  create = FALSE,
  verbose = getOption("reproducible.verbose", 1)
)

## S4 method for signature 'ANY'
.checkCacheRepo(
  object,
  create = FALSE,
  verbose = getOption("reproducible.verbose", 1)
)

.prepareOutput(object, cachePath, ...)

## S4 method for signature 'ANY'
.prepareOutput(object, cachePath, ...)

.addChangedAttr(object, preDigest, origArguments, ...)

## S4 method for signature 'ANY'
.addChangedAttr(object, preDigest, origArguments, ...)

updateFilenameSlots(obj, curFilenames, newFilenames, isStack = NULL)

## Default S3 method:
updateFilenameSlots(obj, curFilenames, newFilenames, isStack = NULL, ...)

## S3 method for class 'list'
updateFilenameSlots(obj, ...)

## S3 method for class 'environment'
updateFilenameSlots(obj, ...)

makeMemoisable(x)

## Default S3 method:
makeMemoisable(x)

## S3 method for class 'data.table'
makeMemoisable(x)

unmakeMemoisable(x)

## Default S3 method:
unmakeMemoisable(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".sortDotsUnderscoreFirst_+3A_obj">obj</code></td>
<td>
<p>An object. This function only has useful methods for <code style="white-space: pre;">&#8288;Raster*&#8288;</code>,
with all other classes being simply a pass-through</p>
</td></tr>
<tr><td><code id=".sortDotsUnderscoreFirst_+3A_object">object</code></td>
<td>
<p>Any R object returned from a function</p>
</td></tr>
<tr><td><code id=".sortDotsUnderscoreFirst_+3A_functionname">functionName</code></td>
<td>
<p>A character string indicating the function name</p>
</td></tr>
<tr><td><code id=".sortDotsUnderscoreFirst_+3A_frommemoise">fromMemoise</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the message will be about
recovery from memoised copy</p>
</td></tr>
<tr><td><code id=".sortDotsUnderscoreFirst_+3A_verbose">verbose</code></td>
<td>
<p>Numeric, -1 silent (where possible), 0 being very quiet,
1 showing more messaging, 2 being more messaging, etc.
Default is 1. Above 3 will output much more information about the internals of
Caching, which may help diagnose Caching challenges. Can set globally with an
option, e.g., <code style="white-space: pre;">&#8288;options('reproducible.verbose' = 0) to reduce to minimal&#8288;</code></p>
</td></tr>
<tr><td><code id=".sortDotsUnderscoreFirst_+3A_fullcachetableforobj">fullCacheTableForObj</code></td>
<td>
<p>The data.table entry from the Cache database for only
this <code>cacheId</code>, e.g., via <code>showCache()</code>.</p>
</td></tr>
<tr><td><code id=".sortDotsUnderscoreFirst_+3A_cachepath">cachePath</code></td>
<td>
<p>A repository used for storing cached objects.
This is optional if <code>Cache</code> is used inside a SpaDES module.</p>
</td></tr>
<tr><td><code id=".sortDotsUnderscoreFirst_+3A_cacheid">cacheId</code></td>
<td>
<p>Character string. If passed, this will override the calculated hash
of the inputs, and return the result from this cacheId in the <code>cachePath</code>.
Setting this is equivalent to manually saving the output of this function, i.e.,
the object will be on disk, and will be recovered in subsequent
This may help in some particularly finicky situations
where Cache is not correctly detecting unchanged inputs. This will guarantee
the object will be identical each time; this may be useful in operational code.</p>
</td></tr>
<tr><td><code id=".sortDotsUnderscoreFirst_+3A_outputobjects">outputObjects</code></td>
<td>
<p>Optional character vector indicating which objects to
return. This is only relevant for list, environment (or similar) objects</p>
</td></tr>
<tr><td><code id=".sortDotsUnderscoreFirst_+3A_fun">FUN</code></td>
<td>
<p>A function</p>
</td></tr>
<tr><td><code id=".sortDotsUnderscoreFirst_+3A_predigestbyclass">preDigestByClass</code></td>
<td>
<p>A list, usually from <code>.preDigestByClass</code></p>
</td></tr>
<tr><td><code id=".sortDotsUnderscoreFirst_+3A_create">create</code></td>
<td>
<p>Logical. If TRUE, then it will create the path for cache.</p>
</td></tr>
<tr><td><code id=".sortDotsUnderscoreFirst_+3A_...">...</code></td>
<td>
<p>Anything passed to methods.</p>
</td></tr>
<tr><td><code id=".sortDotsUnderscoreFirst_+3A_predigest">preDigest</code></td>
<td>
<p>The full, element by element hash of the input arguments to that same function,
e.g., from <code>.robustDigest</code></p>
</td></tr>
<tr><td><code id=".sortDotsUnderscoreFirst_+3A_origarguments">origArguments</code></td>
<td>
<p>These are the actual arguments (i.e., the values, not the names) that
were the source for <code>preDigest</code></p>
</td></tr>
<tr><td><code id=".sortDotsUnderscoreFirst_+3A_curfilenames">curFilenames</code></td>
<td>
<p>An optional character vector of filenames currently existing
and that are pointed to in the obj. If omitted, will take from the <code>obj</code>
using <code>Filenames(obj)</code></p>
</td></tr>
<tr><td><code id=".sortDotsUnderscoreFirst_+3A_newfilenames">newFilenames</code></td>
<td>
<p>An optional character vector of filenames to use instead of
the curFilenames. This can also be a single directory, in which case the
renaming will be given:
<code>file.path(newFilenames, basename(Filenames(obj, allowMultiple = FALSE)))</code></p>
</td></tr>
<tr><td><code id=".sortDotsUnderscoreFirst_+3A_x">x</code></td>
<td>
<p>An object to make memoisable.
See individual methods in other packages.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>.sortDotsUnderscoreFirst</code>: This exists so Windows, Linux, and Mac machines can have
the same order after a sort. It will put dots and underscores first
(with the sort key based on their second character, see examples.
It also sorts lower case before upper case.
</p>
<p>The methods should do as described below.
</p>
<p><code>.tagsByClass</code> should return a character vector, with a single colon (&quot;:&quot;) dividing
two parts: the tag type and tag value, for the specific class.
</p>
<p><code>.cacheMessage</code> should make a call to <code>message</code> that gives information about
the loaded cached object being returned.
</p>
<p><code>.objecxtToRetrieveMessage</code> is the messaging for recovering an object from Cache.
</p>
<p><code>.addTagsToOutput</code> should add one or more attributes to an object, named either
<code>"tags"</code>, <code>"call"</code> or <code>"function"</code>. It may be wise to do a &quot;deep&quot; copy within this
method, but it may not be necessary.
</p>
<p><code>.addChangedAttr</code> should return the same object, with this a very specific
attribute added: it must be named &quot;.Cache&quot;, and have a sub-list element named
&quot;changed&quot;, which must be a logical, <code>TRUE</code> or <code>FALSE</code>, to describe whether the object
has changed or not since last attempt to cache it. This is mostly useful when there
are only one or a few sub-elements of e.g., a large list, that are changed. <code>Cache</code>
will be able to only recover the changed parts, to reduce time required to
complete a call to <code>Cache</code>.
</p>
<p><code>updateFilenameSlots</code>: this exists because when copying file-backed rasters, the
usual mechanism of <code>writeRaster</code> can be very slow. This function allows
for a user to optionally create a hard link to the old file, give it a new
name, then update the filename slot(s) in the <code style="white-space: pre;">&#8288;Raster*&#8288;</code> class object. This
can be 100s of times faster for large rasters.
</p>
<p><code>makeMemoiseable</code> and <code>unmakeMemoisable</code> methods are run during <code>Cache</code>. The
methods should address any parts that will not successfully work for memoising,
most notably, <code>data.table</code> or other pass-by-reference objects likely need to
be deep copied, so that the memoised version doesn't get changed after being
stashed in the RAM cache (i.e., memoised)
</p>
<p><code>makeMemoiseable</code> and <code>unmakeMemoisable</code> are, by default, just a pass through
for most class. <code>reproducible</code> only has a method for <code>data.table</code> class objects.
</p>


<h3>Value</h3>

<p><code>.sortDotsUnderscoreFirst</code>: the same object as <code>obj</code>,
but sorted with dots and underscores first,
lower case before upper case.
</p>
<p><code>.tagsByClass</code> default method returns <code>NULL</code>.
</p>
<p><code>.cacheMessage</code>: nothing; called for its messaging side effect, which,
by default, just edits the name of the function into a generic &quot;loaded cached result&quot;
message.
</p>
<p><code>.addTagsToOutput</code>: The inputted object but with tags attached.
</p>
<p><code>.preDigestByClass</code>: A list with elements that have a difficult time
being digested correctly, e.g., an S4 object with some elements removed and
handled for digesting purposes. The default method for <code>preDigestByClass</code> and
simply returns <code>NULL</code>.
</p>
<p><code>.checkCacheRepo</code>: A character string with a path to a cache repository.
</p>
<p><code>.prepareOutput</code>: The object, modified
</p>
<p><code>.addChangedAttr</code>: the object, with an attribute &quot;.Cache&quot; and sub-element, &quot;changed&quot;,
added set to either <code>TRUE</code> or <code>FALSE</code>
</p>
<p><code>updateFilenameSlots</code>: The original object, but with its internal file pointer
updated to the <code>newFilenames</code>
</p>
<p>The same object, but with any modifications, especially
dealing with saving of environments, which memoising doesn't handle
correctly in some cases.
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>


<h3>Examples</h3>

<pre><code class='language-R'>items &lt;- c(A = "a", Z = "z", `.D` = ".d", `_C` = "_C")
.sortDotsUnderscoreFirst(items)

# dots &amp; underscore (using 2nd character), then all lower then all upper
items &lt;- c(B = "Upper", b = "lower", A = "a", `.D` = ".d", `_C` = "_C")
.sortDotsUnderscoreFirst(items)

# with a vector
.sortDotsUnderscoreFirst(c(".C", "_B", "A")) # _B is first

.tagsByClass(character())

a &lt;- 1
.cacheMessage(a, "mean")

a &lt;- 1
.preDigestByClass(a) # returns NULL in the simple case here.

a &lt;- normalizePath(file.path(tempdir(), "test"), mustWork = FALSE)
.checkCacheRepo(a, create = TRUE)

a &lt;- 1
.prepareOutput(a) # does nothing

b &lt;- "NULL"
.prepareOutput(b) # converts to NULL

if (requireNamespace("terra", quietly = TRUE)) {
  r &lt;- terra::rast(terra::ext(0, 10, 0, 10), vals = 1:100)

  # write to disk manually -- will be in tempdir()
  r &lt;- terra::writeRaster(r, filename = tempfile(fileext = ".tif"))

  # copy it to the cache repository
  r &lt;- .prepareOutput(r, tempdir())
}
a &lt;- 1
.addChangedAttr(a) # does nothing because default method is just a pass through
</code></pre>

<hr>
<h2 id='.wrap'>Deal with class for saving to and loading from Cache or Disk</h2><span id='topic+.wrap'></span><span id='topic+.wrap.list'></span><span id='topic+.wrap.environment'></span><span id='topic+.wrap.default'></span><span id='topic+.unwrap.default'></span><span id='topic+.unwrap'></span><span id='topic+.unwrap.environment'></span><span id='topic+.unwrap.list'></span>

<h3>Description</h3>

<p>This generic and some methods will do whatever is required to prepare an object for
saving to disk (or RAM) via e.g., <code>saveRDS</code>. Some objects (e.g., <code>terra</code>'s <code style="white-space: pre;">&#8288;Spat*&#8288;</code>)
cannot be saved without first wrapping them. Also, file-backed objects are similar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.wrap(
  obj,
  cachePath,
  preDigest,
  drv = getDrv(getOption("reproducible.drv", NULL)),
  conn = getOption("reproducible.conn", NULL),
  verbose = getOption("reproducible.verbose"),
  outputObjects = NULL,
  ...
)

## S3 method for class 'list'
.wrap(
  obj,
  cachePath,
  preDigest,
  drv = getDrv(getOption("reproducible.drv", NULL)),
  conn = getOption("reproducible.conn", NULL),
  verbose = getOption("reproducible.verbose"),
  outputObjects = NULL,
  ...
)

## S3 method for class 'environment'
.wrap(
  obj,
  cachePath,
  preDigest,
  drv = getDrv(getOption("reproducible.drv", NULL)),
  conn = getOption("reproducible.conn", NULL),
  verbose = getOption("reproducible.verbose"),
  outputObjects = NULL,
  ...
)

## Default S3 method:
.wrap(
  obj,
  cachePath,
  preDigest,
  drv = getDrv(getOption("reproducible.drv", NULL)),
  conn = getOption("reproducible.conn", NULL),
  verbose = getOption("reproducible.verbose"),
  ...
)

## Default S3 method:
.unwrap(
  obj,
  cachePath,
  cacheId,
  drv = getDrv(getOption("reproducible.drv", NULL)),
  conn = getOption("reproducible.conn", NULL),
  ...
)

.unwrap(
  obj,
  cachePath,
  cacheId,
  drv = getDrv(getOption("reproducible.drv", NULL)),
  conn = getOption("reproducible.conn", NULL),
  ...
)

## S3 method for class 'environment'
.unwrap(
  obj,
  cachePath,
  cacheId,
  drv = getDrv(getOption("reproducible.drv", NULL)),
  conn = getOption("reproducible.conn", NULL),
  ...
)

## S3 method for class 'list'
.unwrap(
  obj,
  cachePath,
  cacheId,
  drv = getDrv(getOption("reproducible.drv", NULL)),
  conn = getOption("reproducible.conn", NULL),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".wrap_+3A_obj">obj</code></td>
<td>
<p>Any arbitrary R object.</p>
</td></tr>
<tr><td><code id=".wrap_+3A_cachepath">cachePath</code></td>
<td>
<p>A repository used for storing cached objects.
This is optional if <code>Cache</code> is used inside a SpaDES module.</p>
</td></tr>
<tr><td><code id=".wrap_+3A_predigest">preDigest</code></td>
<td>
<p>The list of <code>preDigest</code> that comes from <code>CacheDigest</code> of an object</p>
</td></tr>
<tr><td><code id=".wrap_+3A_drv">drv</code></td>
<td>
<p>if using a database backend, drv must be an object that
inherits from DBIDriver e.g., from package RSQLite, e.g., SQLite</p>
</td></tr>
<tr><td><code id=".wrap_+3A_conn">conn</code></td>
<td>
<p>an optional DBIConnection object, as returned by dbConnect().</p>
</td></tr>
<tr><td><code id=".wrap_+3A_verbose">verbose</code></td>
<td>
<p>Numeric, -1 silent (where possible), 0 being very quiet,
1 showing more messaging, 2 being more messaging, etc.
Default is 1. Above 3 will output much more information about the internals of
Caching, which may help diagnose Caching challenges. Can set globally with an
option, e.g., <code style="white-space: pre;">&#8288;options('reproducible.verbose' = 0) to reduce to minimal&#8288;</code></p>
</td></tr>
<tr><td><code id=".wrap_+3A_outputobjects">outputObjects</code></td>
<td>
<p>Optional character vector indicating which objects to
return. This is only relevant for list, environment (or similar) objects</p>
</td></tr>
<tr><td><code id=".wrap_+3A_...">...</code></td>
<td>
<p>Arguments passed to methods; default does not use anything in <code>...</code>.</p>
</td></tr>
<tr><td><code id=".wrap_+3A_cacheid">cacheId</code></td>
<td>
<p>Used strictly for messaging. This should be the cacheId of the object being recovered.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object that can be saved to disk e.g., via <code>saveRDS</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># For SpatExtent
if (requireNamespace("terra")) {
  ex &lt;- terra::ext(c(0, 2, 0, 3))
  exWrapped &lt;- .wrap(ex)
  ex1 &lt;- .unwrap(exWrapped)
}

</code></pre>

<hr>
<h2 id='archiveExtractBinary'>Tests if unrar or 7zip exist</h2><span id='topic+archiveExtractBinary'></span><span id='topic+.archiveExtractBinary'></span>

<h3>Description</h3>

<p>Tests if unrar or 7zip exist
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.archiveExtractBinary(verbose = getOption("reproducible.verbose", 1))
</code></pre>


<h3>Value</h3>

<p>unrar or 7zip path if exist, or NULL
</p>


<h3>Author(s)</h3>

<p>Tati Micheletti
</p>

<hr>
<h2 id='assessDataType'>Assess the appropriate raster layer data type</h2><span id='topic+assessDataType'></span><span id='topic+assessDataType.default'></span>

<h3>Description</h3>

<p>When writing raster-type objects to disk, a <code>datatype</code> can be specified. These
functions help identify what smallest <code>datatype</code> can be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assessDataType(ras, type = "writeRaster")

## Default S3 method:
assessDataType(ras, type = "writeRaster")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assessDataType_+3A_ras">ras</code></td>
<td>
<p>The <code>RasterLayer</code> or <code>RasterStack</code> for which data type will be assessed.</p>
</td></tr>
<tr><td><code id="assessDataType_+3A_type">type</code></td>
<td>
<p>Character. <code>"writeRaster"</code> (default) or <code>"GDAL"</code> (defunct)
to return the recommended
data type for writing from the raster packages, respectively, or
<code>"projectRaster"</code> to return recommended resampling type.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string indicating the data type of the spatial layer
(e.g., &quot;INT2U&quot;). See <code>terra::datatype()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("terra", quietly = TRUE)) {
  ## LOG1S
  rasOrig &lt;- terra::rast(ncols = 10, nrows = 10)
  ras &lt;- rasOrig
  ras[] &lt;- rep(c(0,1),50)
  assessDataType(ras)

  ras &lt;- rasOrig
  ras[] &lt;- rep(c(0,1),50)
  assessDataType(ras)

  ras[] &lt;- rep(c(TRUE,FALSE),50)
  assessDataType(ras)

  ras[] &lt;- c(NA, NA, rep(c(0,1),49))
  assessDataType(ras)

  ras &lt;- rasOrig
  ras[] &lt;- c(0, NaN, rep(c(0,1),49))
  assessDataType(ras)


  ## INT1S
  ras[] &lt;- -1:98
  assessDataType(ras)

  ras[] &lt;- c(NA, -1:97)
  assessDataType(ras)

  ## INT1U
  ras &lt;- rasOrig
  ras[] &lt;- 1:100
  assessDataType(ras)

  ras[] &lt;- c(NA, 2:100)
  assessDataType(ras)

  ## INT2U
  ras &lt;- rasOrig
  ras[] &lt;- round(runif(100, min = 64000, max = 65000))
  assessDataType(ras)

  ## INT2S
  ras &lt;- rasOrig
  ras[] &lt;- round(runif(100, min = -32767, max = 32767))
  assessDataType(ras)

  ras[54] &lt;- NA
  assessDataType(ras)

  ## INT4U
  ras &lt;- rasOrig
  ras[] &lt;- round(runif(100, min = 0, max = 500000000))
  assessDataType(ras)

  ras[14] &lt;- NA
  assessDataType(ras)

  ## INT4S
  ras &lt;- rasOrig
  ras[] &lt;- round(runif(100, min = -200000000, max = 200000000))
  assessDataType(ras)

  ras[14] &lt;- NA
  assessDataType(ras)

  ## FLT4S
  ras &lt;- rasOrig
  ras[] &lt;- runif(100, min = -10, max = 87)
  assessDataType(ras)

  ras &lt;- rasOrig
  ras[] &lt;- round(runif(100, min = -3.4e+26, max = 3.4e+28))
  assessDataType(ras)

  ras &lt;- rasOrig
  ras[] &lt;- round(runif(100, min = 3.4e+26, max = 3.4e+28))
  assessDataType(ras)

  ras &lt;- rasOrig
  ras[] &lt;- round(runif(100, min = -3.4e+26, max = -1))
  assessDataType(ras)

  ## FLT8S
  ras &lt;- rasOrig
  ras[] &lt;- c(-Inf, 1, rep(c(0,1),49))
  assessDataType(ras)

  ras &lt;- rasOrig
  ras[] &lt;- c(Inf, 1, rep(c(0,1),49))
  assessDataType(ras)

  ras &lt;- rasOrig
  ras[] &lt;- round(runif(100, min = -1.7e+30, max = 1.7e+308))
  assessDataType(ras)

  ras &lt;- rasOrig
  ras[] &lt;- round(runif(100, min = 1.7e+30, max = 1.7e+308))
  assessDataType(ras)

  ras &lt;- rasOrig
  ras[] &lt;- round(runif(100, min = -1.7e+308, max = -1))
  assessDataType(ras)

  # 2 layer with different types LOG1S and FLT8S
  ras &lt;- rasOrig
  ras[] &lt;- rep(c(0,1),50)
  ras1 &lt;- rasOrig
  ras1[] &lt;- round(runif(100, min = -1.7e+308, max = -1))
  sta &lt;- c(ras, ras1)
  assessDataType(sta)

}
</code></pre>

<hr>
<h2 id='basename2'>A version of <code>base::basename</code> that is <code>NULL</code> resistant</h2><span id='topic+basename2'></span>

<h3>Description</h3>

<p>A version of <code>base::basename</code> that is <code>NULL</code> resistant
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basename2(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basename2_+3A_x">x</code></td>
<td>
<p>A character vector of paths</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code> if x is <code>NULL</code>, otherwise, as <code>basename</code>.
</p>
<p>Same as <code><a href="base.html#topic+basename">base::basename()</a></code>
</p>

<hr>
<h2 id='Cache'>Saves a wide variety function call outputs to disk and optionally RAM, for recovery later</h2><span id='topic+Cache'></span>

<h3>Description</h3>

<p><img src="../help/figures/lifecycle-maturing.svg" alt="maturing" />
</p>
<p>A function that can be used to wrap around other functions to cache function calls
for later use. This is normally most effective when the function to cache is
slow to run, yet the inputs and outputs are small. The benefit of caching, therefore,
will decline when the computational time of the &quot;first&quot; function call is fast and/or
the argument values and return objects are large. The default setting (and first
call to Cache) will always save to disk. The 2nd call to the same function will return
from disk, unless <code>options("reproducible.useMemoise" = TRUE)</code>, then the 2nd time
will recover the object from RAM and is normally much faster (at the expense of RAM use).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Cache(
  FUN,
  ...,
  notOlderThan = NULL,
  .objects = NULL,
  .cacheExtra = NULL,
  .functionName = NULL,
  outputObjects = NULL,
  algo = "xxhash64",
  cacheRepo = NULL,
  cachePath = NULL,
  length = getOption("reproducible.length", Inf),
  compareRasterFileLength,
  userTags = c(),
  omitArgs = NULL,
  classOptions = list(),
  debugCache = character(),
  sideEffect = FALSE,
  makeCopy = FALSE,
  quick = getOption("reproducible.quick", FALSE),
  verbose = getOption("reproducible.verbose", 1),
  cacheId = NULL,
  useCache = getOption("reproducible.useCache", TRUE),
  useCloud = FALSE,
  cloudFolderID = NULL,
  showSimilar = getOption("reproducible.showSimilar", FALSE),
  drv = getDrv(getOption("reproducible.drv", NULL)),
  conn = getOption("reproducible.conn", NULL)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Cache_+3A_fun">FUN</code></td>
<td>
<p>Either a function (e.g., <code>rnorm</code>), a function call (e.g., <code>rnorm(1)</code>),
or an unevaluated function call (e.g., using
<code>quote</code>).</p>
</td></tr>
<tr><td><code id="Cache_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>FUN</code>, if <code>FUN</code> is not an expression.</p>
</td></tr>
<tr><td><code id="Cache_+3A_notolderthan">notOlderThan</code></td>
<td>
<p>A time. Load an object from the Cache if it was created after this.</p>
</td></tr>
<tr><td><code id="Cache_+3A_.objects">.objects</code></td>
<td>
<p>Character vector of objects to be digested. This is only applicable
if there is a list, environment (or similar) with named objects
within it. Only this/these objects will be considered for caching,
i.e., only use a subset of
the list, environment or similar objects. In the case of nested list-type
objects, this will only be applied outermost first.</p>
</td></tr>
<tr><td><code id="Cache_+3A_.cacheextra">.cacheExtra</code></td>
<td>
<p>A an arbitrary R object that will be included in the <code>CacheDigest</code>,
but otherwise not passed into the <code>FUN</code>. If the user supplies a named list, then
<code>Cache</code> will report which individual elements of <code>.cacheExtra</code> have changed
when <code>options("reproducible.showSimilar" = TRUE)</code>. This can allow a user
more control and understanding for debugging.</p>
</td></tr>
<tr><td><code id="Cache_+3A_.functionname">.functionName</code></td>
<td>
<p>A an arbitrary character string that provides a name that is different
than the actual function name (e.g., &quot;rnorm&quot;) which will be used for messaging. This
can be useful when the actual function is not helpful for a user, such as <code>do.call</code>.</p>
</td></tr>
<tr><td><code id="Cache_+3A_outputobjects">outputObjects</code></td>
<td>
<p>Optional character vector indicating which objects to
return. This is only relevant for list, environment (or similar) objects</p>
</td></tr>
<tr><td><code id="Cache_+3A_algo">algo</code></td>
<td>
<p>The algorithms to be used; currently available choices are
<code>md5</code>, which is also the default, <code>sha1</code>, <code>crc32</code>,
<code>sha256</code>, <code>sha512</code>, <code>xxhash32</code>, <code>xxhash64</code>,
<code>murmur32</code>, <code>spookyhash</code>, <code>blake3</code>, <code>crc32c</code>,
<code>xxh3_64</code>, and <code>xxh3_128</code>.</p>
</td></tr>
<tr><td><code id="Cache_+3A_cacherepo">cacheRepo</code></td>
<td>
<p>Same as <code>cachePath</code>, but kept for backwards compatibility.</p>
</td></tr>
<tr><td><code id="Cache_+3A_cachepath">cachePath</code></td>
<td>
<p>A repository used for storing cached objects.
This is optional if <code>Cache</code> is used inside a SpaDES module.</p>
</td></tr>
<tr><td><code id="Cache_+3A_length">length</code></td>
<td>
<p>Numeric. If the element passed to Cache is a <code>Path</code> class
object (from e.g., <code>asPath(filename)</code>) or it is a <code>Raster</code> with
file-backing, then this will be
passed to <code>digest::digest</code>, essentially limiting the number of bytes
to digest (for speed). This will only be used if <code>quick = FALSE</code>.
Default is <code>getOption("reproducible.length")</code>, which is set to <code>Inf</code>.</p>
</td></tr>
<tr><td><code id="Cache_+3A_comparerasterfilelength">compareRasterFileLength</code></td>
<td>
<p>Being deprecated; use <code>length</code>.</p>
</td></tr>
<tr><td><code id="Cache_+3A_usertags">userTags</code></td>
<td>
<p>A character vector with descriptions of the Cache function call. These
will be added to the Cache so that this entry in the Cache can be found using
<code>userTags</code> e.g., via <code><a href="#topic+showCache">showCache()</a></code>.</p>
</td></tr>
<tr><td><code id="Cache_+3A_omitargs">omitArgs</code></td>
<td>
<p>Optional character string of arguments in the FUN to omit from the digest.</p>
</td></tr>
<tr><td><code id="Cache_+3A_classoptions">classOptions</code></td>
<td>
<p>Optional list. This will pass into <code>.robustDigest</code> for
specific classes. Should be options that the <code>.robustDigest</code> knows what
to do with.</p>
</td></tr>
<tr><td><code id="Cache_+3A_debugcache">debugCache</code></td>
<td>
<p>Character or Logical. Either <code>"complete"</code> or <code>"quick"</code> (uses
partial matching, so &quot;c&quot; or &quot;q&quot; work). <code>TRUE</code> is equivalent to <code>"complete"</code>.
If <code>"complete"</code>, then the returned object from the Cache
function will have two attributes, <code>debugCache1</code> and <code>debugCache2</code>,
which are the entire <code>list(...)</code> and that same object, but after all
<code>.robustDigest</code> calls, at the moment that it is digested using
<code>digest</code>, respectively. This <code>attr(mySimOut, "debugCache2")</code>
can then be compared to a subsequent call and individual items within
the object <code>attr(mySimOut, "debugCache1")</code> can be compared.
If <code>"quick"</code>, then it will return the same two objects directly,
without evalutating the <code>FUN(...)</code>.</p>
</td></tr>
<tr><td><code id="Cache_+3A_sideeffect">sideEffect</code></td>
<td>
<p>Now deprecated. Logical or path. Determines where the function will look for
new files following function completion. See Details.
<em>NOTE: this argument is experimental and may change in future releases.</em></p>
</td></tr>
<tr><td><code id="Cache_+3A_makecopy">makeCopy</code></td>
<td>
<p>Now deprecated. Ignored if used.</p>
</td></tr>
<tr><td><code id="Cache_+3A_quick">quick</code></td>
<td>
<p>Logical or character. If <code>TRUE</code>,
no disk-based information will be assessed, i.e., only
memory content. See Details section about <code>quick</code> in <code><a href="#topic+Cache">Cache()</a></code>.</p>
</td></tr>
<tr><td><code id="Cache_+3A_verbose">verbose</code></td>
<td>
<p>Numeric, -1 silent (where possible), 0 being very quiet,
1 showing more messaging, 2 being more messaging, etc.
Default is 1. Above 3 will output much more information about the internals of
Caching, which may help diagnose Caching challenges. Can set globally with an
option, e.g., <code style="white-space: pre;">&#8288;options('reproducible.verbose' = 0) to reduce to minimal&#8288;</code></p>
</td></tr>
<tr><td><code id="Cache_+3A_cacheid">cacheId</code></td>
<td>
<p>Character string. If passed, this will override the calculated hash
of the inputs, and return the result from this cacheId in the <code>cachePath</code>.
Setting this is equivalent to manually saving the output of this function, i.e.,
the object will be on disk, and will be recovered in subsequent
This may help in some particularly finicky situations
where Cache is not correctly detecting unchanged inputs. This will guarantee
the object will be identical each time; this may be useful in operational code.</p>
</td></tr>
<tr><td><code id="Cache_+3A_usecache">useCache</code></td>
<td>
<p>Logical, numeric or <code>"overwrite"</code> or <code>"devMode"</code>. See details.</p>
</td></tr>
<tr><td><code id="Cache_+3A_usecloud">useCloud</code></td>
<td>
<p>Logical. See Details.</p>
</td></tr>
<tr><td><code id="Cache_+3A_cloudfolderid">cloudFolderID</code></td>
<td>
<p>A googledrive dribble of a folder, e.g., using <code>drive_mkdir()</code>.
If left as <code>NULL</code>, the function will create a cloud folder with name from last
two folder levels of the <code>cachePath</code> path, :
<code>paste0(basename(dirname(cachePath)), "_", basename(cachePath))</code>.
This <code>cloudFolderID</code> will be added to <code>options("reproducible.cloudFolderID")</code>,
but this will not persist across sessions. If this is a character string, it will
treat this as a folder name to create or use on GoogleDrive.</p>
</td></tr>
<tr><td><code id="Cache_+3A_showsimilar">showSimilar</code></td>
<td>
<p>A logical or numeric. Useful for debugging.
If <code>TRUE</code> or <code>1</code>, then if the Cache
does not find an identical archive in the <code>cachePath</code>, it will report (via message)
the next most recent similar archive, and indicate which argument(s) is/are different.
If a number larger than <code>1</code>, then it will report the N most recent similar archived
objects.</p>
</td></tr>
<tr><td><code id="Cache_+3A_drv">drv</code></td>
<td>
<p>if using a database backend, drv must be an object that
inherits from DBIDriver e.g., from package RSQLite, e.g., SQLite</p>
</td></tr>
<tr><td><code id="Cache_+3A_conn">conn</code></td>
<td>
<p>an optional DBIConnection object, as returned by dbConnect().</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are other similar functions in the R universe. This version of Cache has
been used as part of a robust continuous workflow approach. As a result, we have
tested it with many &quot;non-standard&quot; R objects (e.g., RasterLayer, terra objects) and
environments (which are always unique, so do not cache readily).
</p>
<p>This version of the <code>Cache</code> function accommodates those four special,
though quite common, cases by:
</p>

<ol>
<li><p> converting any environments into list equivalents;
</p>
</li>
<li><p> identifying the dispatched S4 method (including those made through
inheritance) before hashing so the correct method is being cached;
</p>
</li>
<li><p> by hashing the linked file, rather than the Raster object.
Currently, only file-backed <code style="white-space: pre;">&#8288;Raster*&#8288;</code> or <code style="white-space: pre;">&#8288;terra*&#8288;</code> objects are digested
(e.g., not <code>ff</code> objects, or any other R object where the data
are on disk instead of in RAM);
</p>
</li>
<li><p> Uses <code><a href="digest.html#topic+digest">digest::digest()</a></code>
This is used for file-backed objects as well.
</p>
</li>
<li><p> Cache will save arguments passed by user in a hidden environment. Any
nested Cache functions will use arguments in this order 1) actual arguments
passed at each Cache call, 2) any inherited arguments from an outer Cache
call, 3) the default values of the Cache function. See section on <em>Nested
Caching</em>.
</p>
</li></ol>

<p><code>Cache</code> will add a tag to the entry in the cache database called <code>accessed</code>,
which will assign the time that it was accessed, either read or write.
That way, cached items can be shown (using <code>showCache</code>) or removed (using
<code>clearCache</code>) selectively, based on their access dates, rather than only
by their creation dates. See example in <code><a href="#topic+clearCache">clearCache()</a></code>.
</p>


<h3>Value</h3>

<p>Returns the value of the
function call or the cached version (i.e., the result from a previous call
to this same cached function with identical arguments).
</p>


<h3>Nested Caching</h3>

<p>Commonly, Caching is nested, i.e., an outer function is wrapped in a <code>Cache</code>
function call, and one or more inner functions are also wrapped in a <code>Cache</code>
function call. A user <em>can</em> always specify arguments in every Cache function
call, but this can get tedious and can be prone to errors. The normal way that
<em>R</em> handles arguments is it takes the user passed arguments if any, and
default arguments for all those that have no user passed arguments. We have inserted
a middle step. The order or precedence for any given <code>Cache</code> function call is
</p>

<ol>
<li><p> user arguments, 2. inherited arguments, 3. default arguments. At this time,
the top level <code>Cache</code> arguments will propagate to all inner functions unless
each individual <code>Cache</code> call has other arguments specified, i.e., &quot;middle&quot;
nested <code>Cache</code> function calls don't propagate their arguments to further &quot;inner&quot;
<code>Cache</code> function calls.  See example.
</p>
</li></ol>

<p><code>userTags</code> is unique of all arguments: its values will be appended to the
inherited <code>userTags</code>.
</p>


<h3>quick</h3>

<p>The <code>quick</code> argument is attempting to sort out an ambiguity with character strings:
are they file paths or are they simply character strings. When <code>quick = TRUE</code>,
<code>Cache</code> will treat these as character strings; when <code>quick = FALSE</code>,
they will be attempted to be treated as file paths first; if there is no file, then
it will revert to treating them as character strings. If user passes a
character vector to this, then this will behave like <code>omitArgs</code>:
<code>quick = "file"</code> will treat the argument <code>"file"</code> as character string.
</p>
<p>The most often encountered situation where this ambiguity matters is in arguments about
filenames: is the filename an input pointing to an object whose content we want to
assess (e.g., a file-backed raster), or an output (as in saveRDS) and it should not
be assessed. If only run once, the output file won't exist, so it will be treated
as a character string. However, once the function has been run once, the output file
will exist, and <code>Cache(...)</code> will assess it, which is incorrect. In these cases,
the user is advised to use <code>quick = "TheOutputFilenameArgument"</code> to
specify the argument whose content on disk should not be assessed, but whose
character string should be assessed (distinguishing it from <code>omitArgs = "TheOutputFilenameArgument"</code>, which will not assess the file content nor the
character string).
</p>
<p>This is relevant for objects of class <code>character</code>, <code>Path</code> and
<code>Raster</code> currently. For class <code>character</code>, it is ambiguous whether
this represents a character string or a vector of file paths. If it is known
that character strings should not be treated as paths, then <code>quick = TRUE</code> is appropriate, with no loss of information. If it is file or
directory, then it will digest the file content, or <code>basename(object)</code>.
For class <code>Path</code> objects, the file's metadata (i.e., filename and file
size) will be hashed instead of the file contents if <code>quick = TRUE</code>. If
set to <code>FALSE</code> (default), the contents of the file(s) are hashed. If
<code>quick = TRUE</code>, <code>length</code> is ignored. <code>Raster</code> objects are
treated as paths, if they are file-backed.
</p>


<h3>Caching Speed</h3>

<p>Caching speed may become a critical aspect of a final product. For example,
if the final product is a shiny app, rerunning the entire project may need
to take less then a few seconds at most. There are 3 arguments that affect
Cache speed: <code>quick</code>, <code>length</code>, and
<code>algo</code>. <code>quick</code> is passed to <code>.robustDigest</code>, which currently
only affects <code>Path</code> and <code style="white-space: pre;">&#8288;Raster*&#8288;</code> class objects. In both cases, <code>quick</code>
means that little or no disk-based information will be assessed.
</p>


<h3>Filepaths</h3>

<p>If a function has a path argument, there is some ambiguity about what should be
done. Possibilities include:
</p>

<ol>
<li><p> hash the string as is (this will be very system specific, meaning a
<code>Cache</code> call will not work if copied between systems or directories);
</p>
</li>
<li><p> hash the <code>basename(path)</code>;
</p>
</li>
<li><p> hash the contents of the file.
</p>
</li></ol>

<p>If paths are passed in as is (i.e,. character string), the result will not be predictable.
Instead, one should use the wrapper function <code>asPath(path)</code>, which sets the
class of the string to a <code>Path</code>, and one should decide whether one wants
to digest the content of the file (using <code>quick = FALSE</code>),
or just the filename (<code>(quick = TRUE)</code>). See examples.
</p>


<h3>Stochasticity or randomness</h3>

<p>In general, it is expected that caching will only be used when randomness is not
desired, e.g., <code>Cache(rnorm(1))</code> is unlikely to be useful in many cases. However,
<code>Cache</code> captures the call that is passed to it, leaving all functions unevaluated.
As a result <code>Cache(glm, x ~ y, rnorm(1))</code> will not work as a means of forcing
a new evaluation each time, as the <code>rnorm(1)</code> is not evaluated before the call
is assessed against the cache database. To force a new call each time, evaluate
the randomness prior to the Cache call, e.g., <code>ran = rnorm(1)</code> then pass this
to <code>.cacheExtra</code>, e.g., <code>Cache(glm, x ~ y, .cacheExtra = ran)</code>
</p>


<h3><code>drv</code> and <code>conn</code></h3>

<p>By default, <code>drv</code> uses an SQLite database. This can be sufficient for most cases.
However, if a user has dozens or more cores making requests to the Cache database,
it may be insufficient. A user can set up a different database backend, e.g.,
PostgreSQL that can handle multiple simultaneous read-write situations. See
<a href="https://github.com/PredictiveEcology/SpaDES/wiki/Using-alternate-database-backends-for-Cache">https://github.com/PredictiveEcology/SpaDES/wiki/Using-alternate-database-backends-for-Cache</a>.
</p>


<h3><code>useCache</code></h3>

<p>Logical or numeric. If <code>FALSE</code> or <code>0</code>, then the entire Caching
mechanism is bypassed and the
function is evaluated as if it was not being Cached. Default is
<code>getOption("reproducible.useCache")</code>), which is <code>TRUE</code> by default,
meaning use the Cache mechanism. This may be useful to turn all Caching on or
off in very complex scripts and nested functions. Increasing levels of numeric
values will cause deeper levels of Caching to occur (though this may not
work as expected in all cases). The following is no longer supported:
Currently, only implemented
in <code>postProcess</code>: to do both caching of inner <code>cropInputs</code>, <code>projectInputs</code>
and <code>maskInputs</code>, and caching of outer <code>postProcess</code>, use
<code>useCache = 2</code>; to skip the inner sequence of 3 functions, use <code>useCache = 1</code>.
For large objects, this may prevent many duplicated save to disk events.
</p>
<p>If <code>useCache = "overwrite"</code>
(which can be set with <code>options("reproducible.useCache" = "overwrite")</code>), then the function invoke the caching mechanism but will purge
any entry that is matched, and it will be replaced with the results of the
current call.
</p>
<p>If <code>useCache = "devMode"</code>: The point of this mode is to facilitate using the Cache when
functions and datasets are continually in flux, and old Cache entries are
likely stale very often. In <code>devMode</code>, the cache mechanism will work as
normal if the Cache call is the first time for a function OR if it
successfully finds a copy in the cache based on the normal Cache mechanism.
It <em>differs</em> from the normal Cache if the Cache call does <em>not</em> find a copy
in the <code>cachePath</code>, but it does find an entry that matches based on
<code>userTags</code>. In this case, it will delete the old entry in the <code>cachePath</code>
(identified based on matching <code>userTags</code>), then continue with normal <code>Cache</code>.
For this to work correctly, <code>userTags</code> must be unique for each function call.
This should be used with caution as it is still experimental. Currently, if
<code>userTags</code> are not unique to a single entry in the cachePath, it will
default to the behaviour of <code>useCache = TRUE</code> with a message. This means
that <code>"devMode"</code> is most useful if used from the start of a project.
</p>


<h3><code>useCloud</code></h3>

<p>This is experimental and there are many conditions under which this is known
to not work correctly. This is a way to store all or some of the local Cache in the cloud.
Currently, the only cloud option is Google Drive, via <span class="pkg">googledrive</span>.
For this to work, the user must be or be able to be authenticated
with <code>googledrive::drive_auth</code>. The principle behind this
<code>useCloud</code> is that it will be a full or partial mirror of a local Cache.
It is not intended to be used independently from a local Cache. To share
objects that are in the Cloud with another person, it requires 2 steps. 1)
share the <code>cloudFolderID$id</code>, which can be retrieved by
<code>getOption("reproducible.cloudFolderID")$id</code> after at least one Cache
call has been made. 2) The other user must then set their  <code>cacheFolderID</code> in a
<code style="white-space: pre;">&#8288;Cache\(..., reproducible.cloudFolderID = \"the ID here\"\)&#8288;</code> call or
set their option manually
<code style="white-space: pre;">&#8288;options\(\"reproducible.cloudFolderID\" = \"the ID here\"\)&#8288;</code>.
</p>
<p>If <code>TRUE</code>, then this Cache call will download
(if local copy doesn't exist, but cloud copy does exist), upload
(local copy does or doesn't exist and
cloud copy doesn't exist), or
will not download nor upload if object exists in both. If <code>TRUE</code> will be at
least 1 second slower than setting this to <code>FALSE</code>, and likely even slower as the
cloud folder gets large. If a user wishes to keep &quot;high-level&quot; control, set this to
<code>getOption("reproducible.useCloud", FALSE)</code> or
<code>getOption("reproducible.useCloud", TRUE)</code> (if the default behaviour should
be <code>FALSE</code> or <code>TRUE</code>, respectively) so it can be turned on and off with
this option. NOTE: <em>This argument will not be passed into inner/nested Cache calls.</em>)
</p>


<h3>Object attributes</h3>

<p>Users should be cautioned that object attributes may not be preserved, especially
in the case of objects that are file-backed, such as <code>Raster</code> or <code>SpatRaster</code> objects.
If a user needs to keep attributes, they may need to manually re-attach them to
the object after recovery. With the example of <code>SpatRaster</code> objects, saving
to disk requires <code>terra::wrap</code> if it is a memory-backed object. When running
<code>terra::unwrap</code> on this object, any attributes that a user had added are lost.
</p>


<h3><code>sideEffect</code></h3>

<p>This feature is now deprecated. Do not use as it is ignored.
</p>


<h3>Note</h3>

<p>As indicated above, several objects require pre-treatment before
caching will work as expected. The function <code>.robustDigest</code> accommodates this.
It is an S4 generic, meaning that developers can produce their own methods for
different classes of objects. Currently, there are methods for several types
of classes. See <code><a href="#topic+.robustDigest">.robustDigest()</a></code>.
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>


<h3>See Also</h3>

<p><code><a href="#topic+showCache">showCache()</a></code>, <code><a href="#topic+clearCache">clearCache()</a></code>, <code><a href="#topic+keepCache">keepCache()</a></code>,
<code><a href="#topic+CacheDigest">CacheDigest()</a></code> to determine the digest of a given function or expression,
as used internally within <code>Cache</code>, <code><a href="#topic+movedCache">movedCache()</a></code>, <code><a href="#topic+.robustDigest">.robustDigest()</a></code>, and
for more advanced uses there are several helper functions,
e.g., <code><a href="#topic+rmFromCache">rmFromCache()</a></code>, <code><a href="#topic+CacheStorageDir">CacheStorageDir()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(2)
tmpDir &lt;- file.path(tempdir())
opts &lt;- options(reproducible.cachePath = tmpDir)

# Usage -- All below are equivalent; even where args are missing or provided,
#   Cache evaluates using default values, if these are specified in formals(FUN)
a &lt;- list()
b &lt;- list(fun = rnorm)
bbb &lt;- 1
ee &lt;- new.env(parent = emptyenv())
ee$qq &lt;- bbb

a[[1]] &lt;- Cache(rnorm(1)) # no evaluation prior to Cache
a[[2]] &lt;- Cache(rnorm, 1) # no evaluation prior to Cache
a[[3]] &lt;- Cache(do.call, rnorm, list(1))
a[[4]] &lt;- Cache(do.call(rnorm, list(1)))
a[[5]] &lt;- Cache(do.call(b$fun, list(1)))
a[[6]] &lt;- Cache(do.call, b$fun, list(1))
a[[7]] &lt;- Cache(b$fun, 1)
a[[8]] &lt;- Cache(b$fun(1))
a[[10]] &lt;- Cache(quote(rnorm(1)))
a[[11]] &lt;- Cache(stats::rnorm(1))
a[[12]] &lt;- Cache(stats::rnorm, 1)
a[[13]] &lt;- Cache(rnorm(1, 0, get("bbb", inherits = FALSE)))
a[[14]] &lt;- Cache(rnorm(1, 0, get("qq", inherits = FALSE, envir = ee)))
a[[15]] &lt;- Cache(rnorm(1, bbb - bbb, get("bbb", inherits = FALSE)))
a[[16]] &lt;- Cache(rnorm(sd = 1, 0, n = get("bbb", inherits = FALSE))) # change order
a[[17]] &lt;- Cache(rnorm(1, sd = get("ee", inherits = FALSE)$qq), mean = 0)

# with base pipe -- this is put in quotes ('') because R version 4.0 can't understand this
#  if you are using R &gt;= 4.1 or R &gt;= 4.2 if using the _ placeholder,
#  then you can just use pipe normally
usingPipe1 &lt;- "b$fun(1) |&gt; Cache()"  # base pipe

# For long pipe, need to wrap sequence in { }, or else only last step is cached
usingPipe2 &lt;-
  '{"bbb" |&gt;
      parse(text = _) |&gt;
      eval() |&gt;
      rnorm()} |&gt;
    Cache()'
if (getRversion() &gt;= "4.1") {
  a[[9]] &lt;- eval(parse(text = usingPipe1)) # recovers cached copy
}
if (getRversion() &gt;= "4.2") { # uses the _ placeholder; only available in R &gt;= 4.2
  a[[18]] &lt;- eval(parse(text = usingPipe2)) # recovers cached copy
}

length(unique(a)) == 1 #  all same

### Pipe -- have to use { } or else only final function is Cached
if (getRversion() &gt;= "4.1") {
  b1a &lt;- 'sample(1e5, 1) |&gt; rnorm() |&gt; Cache()'
  b1b &lt;- 'sample(1e5, 1) |&gt; rnorm() |&gt; Cache()'
  b2a &lt;- '{sample(1e5, 1) |&gt; rnorm()} |&gt; Cache()'
  b2b &lt;- '{sample(1e5, 1) |&gt; rnorm()} |&gt; Cache()'
  b1a &lt;- eval(parse(text = b1a))
  b1b &lt;- eval(parse(text = b1b))
  b2a &lt;- eval(parse(text = b2a))
  b2b &lt;- eval(parse(text = b2b))
  all.equal(b1a, b1b) # Not TRUE because the sample is run first
  all.equal(b2a, b2b) # TRUE because of {  }
}

#########################
# Advanced examples
#########################

# .cacheExtra -- add something to digest
Cache(rnorm(1), .cacheExtra = "sfessee11") # adds something other than fn args
Cache(rnorm(1), .cacheExtra = "nothing") # even though fn is same, the extra is different

# omitArgs -- remove something from digest (kind of the opposite of .cacheExtra)
Cache(rnorm(2, sd = 1), omitArgs = "sd") # removes one or more args from cache digest
Cache(rnorm(2, sd = 2), omitArgs = "sd") # b/c sd is not used, this is same as previous

# cacheId -- force the use of a digest -- can give undesired consequences
Cache(rnorm(3), cacheId = "k323431232") # sets the cacheId for this call
Cache(runif(14), cacheId = "k323431232") # recovers same as above, i.e, rnorm(3)

# Turn off Caching session-wide
opts &lt;- options(reproducible.useCache = FALSE)
Cache(rnorm(3)) # doesn't cache
options(opts)

# showSimilar can help with debugging why a Cache call isn't picking up a cached copy
Cache(rnorm(4), showSimilar = TRUE) # shows that the argument `n` is different

###############################################
# devMode -- enables cache database to stay
#            small even when developing code
###############################################
opt &lt;- options("reproducible.useCache" = "devMode")
clearCache(tmpDir, ask = FALSE)
centralTendency &lt;- function(x) {
  mean(x)
}
funnyData &lt;- c(1, 1, 1, 1, 10)
uniqueUserTags &lt;- c("thisIsUnique", "reallyUnique")
ranNumsB &lt;- Cache(centralTendency, funnyData, cachePath = tmpDir,
                  userTags = uniqueUserTags) # sets new value to Cache
showCache(tmpDir) # 1 unique cacheId -- cacheId is 71cd24ec3b0d0cac

# During development, we often redefine function internals
centralTendency &lt;- function(x) {
  median(x)
}
# When we rerun, we don't want to keep the "old" cache because the function will
#   never again be defined that way. Here, because of userTags being the same,
#   it will replace the entry in the Cache, effetively overwriting it, even though
#   it has a different cacheId
ranNumsD &lt;- Cache(centralTendency, funnyData, cachePath = tmpDir, userTags = uniqueUserTags)
showCache(tmpDir) # 1 unique artifact -- cacheId is 632cd06f30e111be

# If it finds it by cacheID, doesn't matter what the userTags are
ranNumsD &lt;- Cache(centralTendency, funnyData, cachePath = tmpDir, userTags = "thisIsUnique")
options(opt)

#########################################
# For more in depth uses, see vignette
if (interactive())
  browseVignettes(package = "reproducible")
</code></pre>

<hr>
<h2 id='CacheDigest'>The exact digest function that <code>Cache</code> uses</h2><span id='topic+CacheDigest'></span>

<h3>Description</h3>

<p>This can be used by a user to pre-test their arguments before running
<code>Cache</code>, for example to determine whether there is a cached copy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CacheDigest(
  objsToDigest,
  ...,
  algo = "xxhash64",
  calledFrom = "CacheDigest",
  .functionName = NULL,
  quick = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CacheDigest_+3A_objstodigest">objsToDigest</code></td>
<td>
<p>A list of all the objects (e.g., arguments) to be digested</p>
</td></tr>
<tr><td><code id="CacheDigest_+3A_...">...</code></td>
<td>
<p>passed to <code>.robustDigest</code>.</p>
</td></tr>
<tr><td><code id="CacheDigest_+3A_algo">algo</code></td>
<td>
<p>The algorithms to be used; currently available choices are
<code>md5</code>, which is also the default, <code>sha1</code>, <code>crc32</code>,
<code>sha256</code>, <code>sha512</code>, <code>xxhash32</code>, <code>xxhash64</code>,
<code>murmur32</code>, <code>spookyhash</code>, <code>blake3</code>, <code>crc32c</code>,
<code>xxh3_64</code>, and <code>xxh3_128</code>.</p>
</td></tr>
<tr><td><code id="CacheDigest_+3A_calledfrom">calledFrom</code></td>
<td>
<p>a Character string, length 1, with the function to
compare with. Default is &quot;Cache&quot;. All other values may not produce
robust CacheDigest results.</p>
</td></tr>
<tr><td><code id="CacheDigest_+3A_.functionname">.functionName</code></td>
<td>
<p>A an arbitrary character string that provides a name that is different
than the actual function name (e.g., &quot;rnorm&quot;) which will be used for messaging. This
can be useful when the actual function is not helpful for a user, such as <code>do.call</code>.</p>
</td></tr>
<tr><td><code id="CacheDigest_+3A_quick">quick</code></td>
<td>
<p>Logical or character. If <code>TRUE</code>,
no disk-based information will be assessed, i.e., only
memory content. See Details section about <code>quick</code> in <code><a href="#topic+Cache">Cache()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of length 2 with the <code>outputHash</code>, which is the digest
that Cache uses for <code>cacheId</code> and also <code>preDigest</code>, which is
the digest of each sub-element in <code>objsToDigest</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(2)
a &lt;- Cache(rnorm, 1)

# like with Cache, user can pass function and args in a few ways
CacheDigest(rnorm(1)) # shows same cacheId as previous line
CacheDigest(rnorm, 1) # shows same cacheId as previous line

</code></pre>

<hr>
<h2 id='CacheGeo'>Cache-like function for spatial domains</h2><span id='topic+CacheGeo'></span>

<h3>Description</h3>

<p><img src="../help/figures/lifecycle-experimental.svg" alt="experimental" />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CacheGeo(
  targetFile = NULL,
  url = NULL,
  domain,
  FUN,
  destinationPath = getOption("reproducible.destinationPath", "."),
  useCloud = getOption("reproducible.useCloud", FALSE),
  cloudFolderID = NULL,
  purge = FALSE,
  useCache = getOption("reproducible.useCache"),
  overwrite = getOption("reproducible.overwrite"),
  action = c("nothing", "update", "replace", "append"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CacheGeo_+3A_targetfile">targetFile</code></td>
<td>
<p>The (optional) local file (or path to file)</p>
</td></tr>
<tr><td><code id="CacheGeo_+3A_url">url</code></td>
<td>
<p>The (optional) url of the object on Google Drive (the only option currently).
This is only for downloading and uploading to.</p>
</td></tr>
<tr><td><code id="CacheGeo_+3A_domain">domain</code></td>
<td>
<p>An sf polygon object that is the spatial area of interest. If <code>NULL</code>,
then this will return the whole object in <code>targetFile</code>.</p>
</td></tr>
<tr><td><code id="CacheGeo_+3A_fun">FUN</code></td>
<td>
<p>A function call that will be called if there is the <code>domain</code> is
not already contained within the <code>sf</code> object at <code>url</code> or <code>targetFile</code>. This function
call MUST return either a <code>sf</code> class object or a <code>data.frame</code> class object
that has a geometry column (which can then be converted to <code>sf</code> with <code>st_as_sf</code>)</p>
</td></tr>
<tr><td><code id="CacheGeo_+3A_destinationpath">destinationPath</code></td>
<td>
<p>Character string of a directory in which to download
and save the file that comes from <code>url</code> and is also where the function
will look for <code>archive</code> or <code>targetFile</code>. NOTE (still experimental):
To prevent repeated downloads in different locations, the user can also set
<code>options("reproducible.inputPaths")</code> to one or more local file paths to
search for the file before attempting to download. Default for that option is
<code>NULL</code> meaning do not search locally.</p>
</td></tr>
<tr><td><code id="CacheGeo_+3A_usecloud">useCloud</code></td>
<td>
<p>A logical.</p>
</td></tr>
<tr><td><code id="CacheGeo_+3A_cloudfolderid">cloudFolderID</code></td>
<td>
<p>If this is specified, then it must be either 1) a googledrive
url to a folder where the <code>targetFile</code> will be read from or written to, or
2) a googledrive id or 3) an absolute path to a (possibly non-existent yet)
folder on your google drive.</p>
</td></tr>
<tr><td><code id="CacheGeo_+3A_purge">purge</code></td>
<td>
<p>Logical or Integer. <code>0/FALSE</code> (default) keeps existing
<code>CHECKSUMS.txt</code> file and
<code>prepInputs</code> will write or append to it. <code>1/TRUE</code> will deleted the entire
<code>CHECKSUMS.txt</code> file. Other options, see details.</p>
</td></tr>
<tr><td><code id="CacheGeo_+3A_usecache">useCache</code></td>
<td>
<p>Passed to <code>Cache</code> in various places.
Defaults to <code>getOption("reproducible.useCache", 2L)</code> in <code>prepInputs</code>, and
<code>getOption("reproducible.useCache", FALSE)</code> if calling any of the inner
functions manually. For <code>prepInputs</code>, this mean it will use <code>Cache</code>
only up to 2 nested levels, which includes <code>preProcess</code>. <code>postProcess</code> and
its nested <code style="white-space: pre;">&#8288;*Input&#8288;</code> functions (e.g., <code>cropInputs</code>, <code>projectInputs</code>,
<code>maskInputs</code>) are no longer internally cached, as <code>terra</code> processing speeds
mean internal caching is more time consuming. We recommend caching the full
<code>prepInputs</code> call instead (e.g. <code>prepInputs(...) |&gt; Cache()</code>).</p>
</td></tr>
<tr><td><code id="CacheGeo_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical. Should downloading and all the other actions occur
even if they pass the checksums or the files are all there.</p>
</td></tr>
<tr><td><code id="CacheGeo_+3A_action">action</code></td>
<td>
<p>A character string, with one of c(&quot;nothing&quot;, &quot;update&quot;,
&quot;replace&quot;, &quot;append&quot;). Partial matching is used (&quot;n&quot; is sufficient).
<code>nothing</code> will prevent any updating of the <code>targetFile</code>,
i.e., &quot;read only&quot;. <code>append</code> will add the spatial elements in domain to
<code>targetFile</code> (and writing it back to disk). <code>update</code> will do the same as
<code>append</code>, but will also remove any identical geometries before appending.
<code>replace</code> does nothing currently.</p>
</td></tr>
<tr><td><code id="CacheGeo_+3A_...">...</code></td>
<td>
<p>Any named objects that are needed for FUN</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a combination of <code>Cache</code> and <code>prepInputs</code> but for spatial
domains. This differs from <code>Cache</code> in that the current function call doesn't
have to have an identical function call previously run. Instead, it needs
to have had a previous function call where the <code>domain</code> being passes is
<em>within</em> the geographic limits of the <code>targetFile</code> or file located at the <code>url</code>.
This is similar to a geospatial operation on a remote GIS server, with 2 differences:
</p>

<ol>
<li><p> This downloads the object first before doing the GIS locally, and 2. it will
optionally upload an updated object if the geographic area did not yet exist.
</p>
</li></ol>

<p>This has a very specific use case: assess whether an existing <code>sf</code> polygon
or multipolygon object (local or remote) covers the spatial
area of a <code>domain</code> of interest. If it does, then return only that
part of the <code>sf</code> object that completely covers the <code>domain</code>.
If it does not, then run <code>FUN</code>. It is expected that <code>FUN</code> will produce an <code>sf</code>
polygon or multipolygon class object. The result of <code>FUN</code> will then be
appended to the <code>sf</code> object as a new entry (feature) or it will replace
the existing &quot;same extent&quot; entry in the <code>sf</code> object.
</p>


<h3>Value</h3>

<p>Returns an object that results from <code>FUN</code>, which will possibly be a subset
of a larger spatial object that is specified with <code>targetFile</code> or <code>url</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

if (requireNamespace("sf", quietly = TRUE) &amp;&amp;
    requireNamespace("terra", quietly = TRUE)) {
dPath &lt;- checkPath(file.path(tempdir2()), create = TRUE)
localFileLux &lt;- system.file("ex/lux.shp", package = "terra")

  # 1 step for each layer
  # 1st step -- get study area
  full &lt;- prepInputs(localFileLux, destinationPath = dPath) # default is sf::st_read
  zoneA &lt;- full[3:6, ]
  zoneB &lt;- full[8, ] # not in A
  zoneC &lt;- full[3, ] # yes in A
  zoneD &lt;- full[7:8, ] # not in A, B or C
  zoneE &lt;- full[3:5, ] # yes in A
  # 2nd step: re-write to disk as read/write is lossy; want all "from disk" for this ex.
  writeTo(zoneA, writeTo = "zoneA.shp", destinationPath = dPath)
  writeTo(zoneB, writeTo = "zoneB.shp", destinationPath = dPath)
  writeTo(zoneC, writeTo = "zoneC.shp", destinationPath = dPath)
  writeTo(zoneD, writeTo = "zoneD.shp", destinationPath = dPath)
  writeTo(zoneE, writeTo = "zoneE.shp", destinationPath = dPath)
  # Must re-read to get identical columns
  zoneA &lt;- sf::st_read(file.path(dPath, "zoneA.shp"))
  zoneB &lt;- sf::st_read(file.path(dPath, "zoneB.shp"))
  zoneC &lt;- sf::st_read(file.path(dPath, "zoneC.shp"))
  zoneD &lt;- sf::st_read(file.path(dPath, "zoneD.shp"))
  zoneE &lt;- sf::st_read(file.path(dPath, "zoneE.shp"))

  # The function that is to be run. This example returns a data.frame because
  #    saving `sf` class objects with list-like columns does not work with
  #    many st_driver()
  fun &lt;- function(domain, newField) {
    domain |&gt;
      as.data.frame() |&gt;
      cbind(params = I(lapply(seq_len(NROW(domain)), function(x) newField)))
  }

  # Run sequence -- A, B will add new entries in targetFile, C will not,
  #                 D will, E will not
  for (z in list(zoneA, zoneB, zoneC, zoneD, zoneE)) {
    out &lt;- CacheGeo(
      targetFile = "fireSenseParams.rds",
      domain = z,
      FUN = fun(domain, newField = I(list(list(a = 1, b = 1:2, c = "D")))),
      fun = fun, # pass whatever is needed into the function
      destinationPath = dPath,
      action = "update"
      # , cloudFolderID = "cachedObjects" # to upload/download from cloud
    )
  }
}

</code></pre>

<hr>
<h2 id='checkAndMakeCloudFolderID'>Check for presence of <code>checkFolderID</code> (for <code>Cache(useCloud)</code>)</h2><span id='topic+checkAndMakeCloudFolderID'></span>

<h3>Description</h3>

<p>Will check for presence of a <code>cloudFolderID</code> and make a new one
if one not present on Google Drive, with a warning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkAndMakeCloudFolderID(
  cloudFolderID = getOption("reproducible.cloudFolderID", NULL),
  cachePath = NULL,
  create = FALSE,
  overwrite = FALSE,
  verbose = getOption("reproducible.verbose", 1),
  team_drive = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkAndMakeCloudFolderID_+3A_cloudfolderid">cloudFolderID</code></td>
<td>
<p>The google folder ID where cloud caching will occur.</p>
</td></tr>
<tr><td><code id="checkAndMakeCloudFolderID_+3A_cachepath">cachePath</code></td>
<td>
<p>A repository used for storing cached objects.
This is optional if <code>Cache</code> is used inside a SpaDES module.</p>
</td></tr>
<tr><td><code id="checkAndMakeCloudFolderID_+3A_create">create</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then the <code>cloudFolderID</code> will be created.
This should be used with caution as there are no checks for overwriting.
See <code>googledrive::drive_mkdir</code>. Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="checkAndMakeCloudFolderID_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical. Passed to <code>googledrive::drive_mkdir</code>.</p>
</td></tr>
<tr><td><code id="checkAndMakeCloudFolderID_+3A_verbose">verbose</code></td>
<td>
<p>Numeric, -1 silent (where possible), 0 being very quiet,
1 showing more messaging, 2 being more messaging, etc.
Default is 1. Above 3 will output much more information about the internals of
Caching, which may help diagnose Caching challenges. Can set globally with an
option, e.g., <code style="white-space: pre;">&#8288;options('reproducible.verbose' = 0) to reduce to minimal&#8288;</code></p>
</td></tr>
<tr><td><code id="checkAndMakeCloudFolderID_+3A_team_drive">team_drive</code></td>
<td>
<p>Logical indicating whether to check team drives.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the character string of the cloud folder ID created or reported
</p>

<hr>
<h2 id='checkPath'>Check directory path</h2><span id='topic+checkPath'></span><span id='topic+checkPath+2Ccharacter+2Clogical-method'></span><span id='topic+checkPath+2Ccharacter+2Cmissing-method'></span><span id='topic+checkPath+2CNULL+2CANY-method'></span><span id='topic+checkPath+2Cmissing+2CANY-method'></span>

<h3>Description</h3>

<p>Checks the specified path to a directory for formatting consistencies,
such as trailing slashes, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkPath(path, create)

## S4 method for signature 'character,logical'
checkPath(path, create)

## S4 method for signature 'character,missing'
checkPath(path)

## S4 method for signature 'NULL,ANY'
checkPath(path)

## S4 method for signature 'missing,ANY'
checkPath()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkPath_+3A_path">path</code></td>
<td>
<p>A character string corresponding to a directory path.</p>
</td></tr>
<tr><td><code id="checkPath_+3A_create">create</code></td>
<td>
<p>A logical indicating whether the path should
be created if it does not exist. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character string denoting the cleaned up filepath.
</p>


<h3>Note</h3>

<p>This will not work for paths to files.
To check for existence of files, use <code>file.exists()</code>.
To normalize a path to a file, use <code>normPath()</code> or <code>normalizePath()</code>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+file.exists">file.exists()</a></code>, <code><a href="base.html#topic+dir.create">dir.create()</a></code>, <code><a href="#topic+normPath">normPath()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## normalize file paths
paths &lt;- list("./aaa/zzz",
              "./aaa/zzz/",
              ".//aaa//zzz",
              ".//aaa//zzz/",
              ".\\\\aaa\\\\zzz",
              ".\\\\aaa\\\\zzz\\\\",
              file.path(".", "aaa", "zzz"))

checked &lt;- normPath(paths)
length(unique(checked)) ## 1; all of the above are equivalent

## check to see if a path exists
tmpdir &lt;- file.path(tempdir(), "example_checkPath")

dir.exists(tmpdir) ## FALSE
tryCatch(checkPath(tmpdir, create = FALSE), error = function(e) FALSE) ## FALSE

checkPath(tmpdir, create = TRUE)
dir.exists(tmpdir) ## TRUE

unlink(tmpdir, recursive = TRUE)
</code></pre>

<hr>
<h2 id='checkRelative'>An alternative to <code>basename</code> and <code>dirname</code> when there are sub-folders</h2><span id='topic+checkRelative'></span>

<h3>Description</h3>

<p>This confirms that the <code>files</code> which may be absolute actually
exist when compared <code>makeRelative(knownRelativeFiles, absolutePrefix)</code>.
This is different than just using <code>basename</code> because it will include any
sub-folder structure within the <code>knownRelativePaths</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>checkRelative(
  files,
  absolutePrefix,
  knownRelativeFiles,
  verbose = getOption("reproducible.verbose")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="checkRelative_+3A_files">files</code></td>
<td>
<p>A character vector of files to check to see if they are the same
as <code>knownRelativeFiles</code>, once the <code>absolutePrefix</code> is removed</p>
</td></tr>
<tr><td><code id="checkRelative_+3A_absoluteprefix">absolutePrefix</code></td>
<td>
<p>A directory to &quot;remove&quot; from <code>files</code> to compare
to <code>knownRelativeFiles</code></p>
</td></tr>
<tr><td><code id="checkRelative_+3A_knownrelativefiles">knownRelativeFiles</code></td>
<td>
<p>A character vector of relative filenames, that could
have sub-folder structure.</p>
</td></tr>
<tr><td><code id="checkRelative_+3A_verbose">verbose</code></td>
<td>
<p>Numeric, -1 silent (where possible), 0 being very quiet,
1 showing more messaging, 2 being more messaging, etc.
Default is 1. Above 3 will output much more information about the internals of
Caching, which may help diagnose Caching challenges. Can set globally with an
option, e.g., <code style="white-space: pre;">&#8288;options('reproducible.verbose' = 0) to reduce to minimal&#8288;</code></p>
</td></tr>
</table>

<hr>
<h2 id='Checksums'>Calculate checksum</h2><span id='topic+Checksums'></span><span id='topic+Checksums+2Ccharacter+2Clogical-method'></span><span id='topic+Checksums+2Ccharacter+2Cmissing-method'></span>

<h3>Description</h3>

<p>Verify (and optionally write) checksums.
Checksums are computed using <code><a href="#topic+.digest">.digest()</a></code>, which is simply a
wrapper around <code>digest::digest</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Checksums(
  path,
  write,
  quickCheck = getOption("reproducible.quickCheck", FALSE),
  checksumFile = identifyCHECKSUMStxtFile(path),
  files = NULL,
  verbose = getOption("reproducible.verbose", 1),
  ...
)

## S4 method for signature 'character,logical'
Checksums(
  path,
  write,
  quickCheck = getOption("reproducible.quickCheck", FALSE),
  checksumFile = identifyCHECKSUMStxtFile(path),
  files = NULL,
  verbose = getOption("reproducible.verbose", 1),
  ...
)

## S4 method for signature 'character,missing'
Checksums(
  path,
  write,
  quickCheck = getOption("reproducible.quickCheck", FALSE),
  checksumFile = identifyCHECKSUMStxtFile(path),
  files = NULL,
  verbose = getOption("reproducible.verbose", 1),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Checksums_+3A_path">path</code></td>
<td>
<p>Character string giving the directory path containing <code>CHECKSUMS.txt</code>
file, or where it will be written if <code>checksumFile = TRUE</code>.</p>
</td></tr>
<tr><td><code id="Checksums_+3A_write">write</code></td>
<td>
<p>Logical indicating whether to overwrite <code>CHECKSUMS.txt</code>.
Default is <code>FALSE</code>, as users should not change this file.
Module developers should write this file prior to distributing
their module code, and update accordingly when the data change.</p>
</td></tr>
<tr><td><code id="Checksums_+3A_quickcheck">quickCheck</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then this will only use file sizes,
rather than a digest::digest hash. This is generally faster,
but will be <em>much</em> less robust.</p>
</td></tr>
<tr><td><code id="Checksums_+3A_checksumfile">checksumFile</code></td>
<td>
<p>The filename of the checksums file to read or write to.
The default is &lsquo;<span class="file">CHECKSUMS.txt</span>&rsquo; located at
<code>file.path(path, module, "data", checksumFile)</code>.
It is likely not a good idea to change this, and should
only be used in cases such as <code>Cache</code>, which can
evaluate if the <code>checksumFile</code> has changed.</p>
</td></tr>
<tr><td><code id="Checksums_+3A_files">files</code></td>
<td>
<p>An optional character string or vector of specific files to checksum.
This may be very important if there are many files listed in a
<code>CHECKSUMS.txt</code> file, but only a few are to be checksummed.</p>
</td></tr>
<tr><td><code id="Checksums_+3A_verbose">verbose</code></td>
<td>
<p>Numeric, -1 silent (where possible), 0 being very quiet,
1 showing more messaging, 2 being more messaging, etc.
Default is 1. Above 3 will output much more information about the internals of
Caching, which may help diagnose Caching challenges. Can set globally with an
option, e.g., <code style="white-space: pre;">&#8288;options('reproducible.verbose' = 0) to reduce to minimal&#8288;</code></p>
</td></tr>
<tr><td><code id="Checksums_+3A_...">...</code></td>
<td>
<p>Passed to <code><a href="digest.html#topic+digest">digest::digest()</a></code> and <code><a href="utils.html#topic+write.table">utils::write.table()</a></code>.
For <code>digest</code>, the notable argument is <code>algo</code>. For <code>write.table</code>,
the notable argument is <code>append</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.table</code> with columns: <code>result</code>, <code>expectedFile</code>,
<code>actualFile</code>, <code>checksum.x</code>, <code>checksum.y</code>,
<code>algorithm.x</code>, <code>algorithm.y</code>, <code>filesize.x</code>, <code>filesize.y</code>
indicating the result of comparison between local file (<code>x</code>) and
expectation based on the <code>CHECKSUMS.txt</code> file.
</p>


<h3>Note</h3>

<p>In version 1.2.0 and earlier, two checksums per file were required
because of differences in the checksum hash values on Windows and Unix-like
platforms. Recent versions use a different (faster) algorithm and only require
one checksum value per file.
To update your &lsquo;<span class="file">CHECKSUMS.txt</span>&rsquo; files using the new algorithm, see
<a href="https://github.com/PredictiveEcology/SpaDES/issues/295#issuecomment-246513405">https://github.com/PredictiveEcology/SpaDES/issues/295#issuecomment-246513405</a>.
</p>


<h3>Author(s)</h3>

<p>Alex Chubaty
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
modulePath &lt;- file.path(tempdir(), "myModulePath")
dir.create(modulePath, recursive = TRUE, showWarnings = FALSE)
moduleName &lt;- "myModule"
cat("hi", file = file.path(modulePath, moduleName)) # put something there for this example

## verify checksums of all data files
Checksums(modulePath, files = moduleName)

## write new CHECKSUMS.txt file
Checksums(files = moduleName, modulePath, write = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='cloudDownload'>Download from cloud, if necessary</h2><span id='topic+cloudDownload'></span>

<h3>Description</h3>

<p>Meant for internal use, as there are internal objects as arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cloudDownload(
  outputHash,
  newFileName,
  gdriveLs,
  cachePath,
  cloudFolderID,
  drv = getDrv(getOption("reproducible.drv", NULL)),
  conn = getOption("reproducible.conn", NULL),
  verbose = getOption("reproducible.verbose")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cloudDownload_+3A_outputhash">outputHash</code></td>
<td>
<p>The <code>cacheId</code> of the object to upload</p>
</td></tr>
<tr><td><code id="cloudDownload_+3A_newfilename">newFileName</code></td>
<td>
<p>The character string of the local filename that the downloaded object will have</p>
</td></tr>
<tr><td><code id="cloudDownload_+3A_gdrivels">gdriveLs</code></td>
<td>
<p>The result of <code>googledrive::drive_ls(googledrive::as_id(cloudFolderID), pattern = "outputHash")</code></p>
</td></tr>
<tr><td><code id="cloudDownload_+3A_cachepath">cachePath</code></td>
<td>
<p>A repository used for storing cached objects.
This is optional if <code>Cache</code> is used inside a SpaDES module.</p>
</td></tr>
<tr><td><code id="cloudDownload_+3A_cloudfolderid">cloudFolderID</code></td>
<td>
<p>A googledrive dribble of a folder, e.g., using <code>drive_mkdir()</code>.
If left as <code>NULL</code>, the function will create a cloud folder with name from last
two folder levels of the <code>cachePath</code> path, :
<code>paste0(basename(dirname(cachePath)), "_", basename(cachePath))</code>.
This <code>cloudFolderID</code> will be added to <code>options("reproducible.cloudFolderID")</code>,
but this will not persist across sessions. If this is a character string, it will
treat this as a folder name to create or use on GoogleDrive.</p>
</td></tr>
<tr><td><code id="cloudDownload_+3A_drv">drv</code></td>
<td>
<p>if using a database backend, drv must be an object that
inherits from DBIDriver e.g., from package RSQLite, e.g., SQLite</p>
</td></tr>
<tr><td><code id="cloudDownload_+3A_conn">conn</code></td>
<td>
<p>an optional DBIConnection object, as returned by dbConnect().</p>
</td></tr>
<tr><td><code id="cloudDownload_+3A_verbose">verbose</code></td>
<td>
<p>Numeric, -1 silent (where possible), 0 being very quiet,
1 showing more messaging, 2 being more messaging, etc.
Default is 1. Above 3 will output much more information about the internals of
Caching, which may help diagnose Caching challenges. Can set globally with an
option, e.g., <code style="white-space: pre;">&#8288;options('reproducible.verbose' = 0) to reduce to minimal&#8288;</code></p>
</td></tr>
</table>

<hr>
<h2 id='cloudUploadFromCache'>Upload a file to cloud directly from local <code>cachePath</code></h2><span id='topic+cloudUploadFromCache'></span>

<h3>Description</h3>

<p>Meant for internal use, as there are internal objects as arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cloudUploadFromCache(
  isInCloud,
  outputHash,
  cachePath,
  cloudFolderID,
  outputToSave,
  rasters,
  verbose = getOption("reproducible.verbose")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cloudUploadFromCache_+3A_isincloud">isInCloud</code></td>
<td>
<p>A logical indicating whether an <code>outputHash</code> is in the cloud already.</p>
</td></tr>
<tr><td><code id="cloudUploadFromCache_+3A_outputhash">outputHash</code></td>
<td>
<p>The <code>cacheId</code> of the object to upload</p>
</td></tr>
<tr><td><code id="cloudUploadFromCache_+3A_cachepath">cachePath</code></td>
<td>
<p>A repository used for storing cached objects.
This is optional if <code>Cache</code> is used inside a SpaDES module.</p>
</td></tr>
<tr><td><code id="cloudUploadFromCache_+3A_cloudfolderid">cloudFolderID</code></td>
<td>
<p>A googledrive dribble of a folder, e.g., using <code>drive_mkdir()</code>.
If left as <code>NULL</code>, the function will create a cloud folder with name from last
two folder levels of the <code>cachePath</code> path, :
<code>paste0(basename(dirname(cachePath)), "_", basename(cachePath))</code>.
This <code>cloudFolderID</code> will be added to <code>options("reproducible.cloudFolderID")</code>,
but this will not persist across sessions. If this is a character string, it will
treat this as a folder name to create or use on GoogleDrive.</p>
</td></tr>
<tr><td><code id="cloudUploadFromCache_+3A_outputtosave">outputToSave</code></td>
<td>
<p>Only required if <code>any(rasters) == TRUE</code>.
This is the <code style="white-space: pre;">&#8288;Raster*&#8288;</code> object.</p>
</td></tr>
<tr><td><code id="cloudUploadFromCache_+3A_rasters">rasters</code></td>
<td>
<p>A logical vector of length &gt;= 1 indicating which elements in
<code>outputToSave</code> are <code style="white-space: pre;">&#8288;Raster*&#8288;</code> objects.</p>
</td></tr>
<tr><td><code id="cloudUploadFromCache_+3A_verbose">verbose</code></td>
<td>
<p>Numeric, -1 silent (where possible), 0 being very quiet,
1 showing more messaging, 2 being more messaging, etc.
Default is 1. Above 3 will output much more information about the internals of
Caching, which may help diagnose Caching challenges. Can set globally with an
option, e.g., <code style="white-space: pre;">&#8288;options('reproducible.verbose' = 0) to reduce to minimal&#8288;</code></p>
</td></tr>
</table>

<hr>
<h2 id='compareNA'><code>NA</code>-aware comparison of two vectors</h2><span id='topic+compareNA'></span>

<h3>Description</h3>

<p>Copied from
<a href="http://www.cookbook-r.com/Manipulating_data/Comparing_vectors_or_factors_with_NA/">http://www.cookbook-r.com/Manipulating_data/Comparing_vectors_or_factors_with_NA/</a>.
This function returns <code>TRUE</code> wherever elements are the same, including <code>NA</code>'s,
and <code>FALSE</code> everywhere else.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareNA(v1, v2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compareNA_+3A_v1">v1</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="compareNA_+3A_v2">v2</code></td>
<td>
<p>A vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector, indicating positions where two vectors are same or differ.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- c(NA, 1, 2, NA)
b &lt;- c(1, NA, 2, NA)
compareNA(a, b)

</code></pre>

<hr>
<h2 id='convertPaths'>Change the absolute path of a file</h2><span id='topic+convertPaths'></span><span id='topic+convertRasterPaths'></span>

<h3>Description</h3>

<p><code>convertPaths</code> is simply a wrapper around <code>gsub</code> for changing the
first part of a path.
<code>convertRasterPaths</code> is useful for changing the path to a file-backed
raster (e.g., after copying the file to a new location).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convertPaths(x, patterns, replacements)

convertRasterPaths(x, patterns, replacements)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convertPaths_+3A_x">x</code></td>
<td>
<p>For <code>convertPaths</code>, a character vector of file paths.
For <code>convertRasterPaths</code>, a disk-backed <code>RasterLayer</code>
object, or a list of such rasters.</p>
</td></tr>
<tr><td><code id="convertPaths_+3A_patterns">patterns</code></td>
<td>
<p>Character vector containing a pattern to match (see <code>?gsub</code>).</p>
</td></tr>
<tr><td><code id="convertPaths_+3A_replacements">replacements</code></td>
<td>
<p>Character vector of the same length of <code>patterns</code>
containing replacement text (see <code>?gsub</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A normalized path with the <code>patterns</code> replaced by <code>replacements</code>. Or a list of such
objects if <code>x</code> was a list.
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire and Alex Chubaty
</p>


<h3>Examples</h3>

<pre><code class='language-R'>filenames &lt;- c("/home/user1/Documents/file.txt", "/Users/user1/Documents/file.txt")
oldPaths &lt;- dirname(filenames)
newPaths &lt;- c("/home/user2/Desktop", "/Users/user2/Desktop")
convertPaths(filenames, oldPaths, newPaths)

</code></pre>

<hr>
<h2 id='Copy'>Recursive copying of nested environments, and other &quot;hard to copy&quot; objects</h2><span id='topic+Copy'></span><span id='topic+Copy+2CANY-method'></span><span id='topic+Copy+2Cdata.table-method'></span><span id='topic+Copy+2Clist-method'></span><span id='topic+Copy+2CrefClass-method'></span><span id='topic+Copy+2Cdata.frame-method'></span>

<h3>Description</h3>

<p>When copying environments and all the objects contained within them, there are
no copies made: it is a pass-by-reference operation. Sometimes, a deep copy is
needed, and sometimes, this must be recursive (i.e., environments inside
environments).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Copy(object, ...)

## S4 method for signature 'ANY'
Copy(
  object,
  filebackedDir,
  drv = getDrv(getOption("reproducible.drv", NULL)),
  conn = getOption("reproducible.conn", NULL),
  verbose = getOption("reproducible.verbose"),
  ...
)

## S4 method for signature 'data.table'
Copy(object, ...)

## S4 method for signature 'list'
Copy(object, ...)

## S4 method for signature 'refClass'
Copy(object, ...)

## S4 method for signature 'data.frame'
Copy(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Copy_+3A_object">object</code></td>
<td>
<p>An R object (likely containing environments) or an environment.</p>
</td></tr>
<tr><td><code id="Copy_+3A_...">...</code></td>
<td>
<p>Only used for custom Methods</p>
</td></tr>
<tr><td><code id="Copy_+3A_filebackeddir">filebackedDir</code></td>
<td>
<p>A directory to copy any files that are backing R objects,
currently only valid for <code>Raster</code> classes. Defaults
to <code>.reproducibleTempPath()</code>, which is unlikely to be very useful.
Can be <code>NULL</code>, which means that the file will not be
copied and could therefore cause a collision as the
pre-copied object and post-copied object would have the same
file backing them.</p>
</td></tr>
<tr><td><code id="Copy_+3A_drv">drv</code></td>
<td>
<p>if using a database backend, drv must be an object that
inherits from DBIDriver e.g., from package RSQLite, e.g., SQLite</p>
</td></tr>
<tr><td><code id="Copy_+3A_conn">conn</code></td>
<td>
<p>an optional DBIConnection object, as returned by dbConnect().</p>
</td></tr>
<tr><td><code id="Copy_+3A_verbose">verbose</code></td>
<td>
<p>Numeric, -1 silent (where possible), 0 being very quiet,
1 showing more messaging, 2 being more messaging, etc.
Default is 1. Above 3 will output much more information about the internals of
Caching, which may help diagnose Caching challenges. Can set globally with an
option, e.g., <code style="white-space: pre;">&#8288;options('reproducible.verbose' = 0) to reduce to minimal&#8288;</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>To create a new Copy method for a class that needs its own method, try something like
shown in example and put it in your package (or other R structure).
</p>


<h3>Value</h3>

<p>The same object as <code>object</code>, but with pass-by-reference class elements &quot;deep&quot; copied.
<code>reproducible</code> has methods for several classes.
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>


<h3>See Also</h3>

<p><code><a href="#topic+.robustDigest">.robustDigest()</a></code>, <code><a href="#topic+Filenames">Filenames()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>e &lt;- new.env()
e$abc &lt;- letters
e$one &lt;- 1L
e$lst &lt;- list(W = 1:10, X = runif(10), Y = rnorm(10), Z = LETTERS[1:10])
ls(e)

# 'normal' copy
f &lt;- e
ls(f)
f$one
f$one &lt;- 2L
f$one
e$one ## uh oh, e has changed!

# deep copy
e$one &lt;- 1L
g &lt;- Copy(e)
ls(g)
g$one
g$one &lt;- 3L
g$one
f$one
e$one
## To create a new deep copy method, use the following template
## setMethod("Copy", signature = "the class", # where = specify here if not in a package,
##           definition = function(object, filebackendDir, ...) {
##           # write deep copy code here
##           })

</code></pre>

<hr>
<h2 id='copySingleFile'>Copy a file using <code>robocopy</code> on Windows and <code>rsync</code> on Linux/macOS</h2><span id='topic+copySingleFile'></span><span id='topic+copyFile'></span>

<h3>Description</h3>

<p>This is replacement for <code>file.copy</code>, but for one file at a time.
The additional feature is that it will use <code>robocopy</code> (on Windows) or
<code>rsync</code> on Linux or Mac, if they exist.
It will default back to <code>file.copy</code> if none of these exists.
If there is a possibility that the file already exists, then this function
should be very fast as it will do &quot;update only&quot;, i.e., nothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copySingleFile(
  from = NULL,
  to = NULL,
  useRobocopy = TRUE,
  overwrite = TRUE,
  delDestination = FALSE,
  create = TRUE,
  silent = FALSE
)

copyFile(
  from = NULL,
  to = NULL,
  useRobocopy = TRUE,
  overwrite = TRUE,
  delDestination = FALSE,
  create = TRUE,
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="copySingleFile_+3A_from">from</code></td>
<td>
<p>The source file.</p>
</td></tr>
<tr><td><code id="copySingleFile_+3A_to">to</code></td>
<td>
<p>The new file.</p>
</td></tr>
<tr><td><code id="copySingleFile_+3A_userobocopy">useRobocopy</code></td>
<td>
<p>For Windows, this will use a system call to <code>robocopy</code>
which appears to be much faster than the internal <code>file.copy</code> function.
Uses <code style="white-space: pre;">&#8288;/MIR&#8288;</code> flag. Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="copySingleFile_+3A_overwrite">overwrite</code></td>
<td>
<p>Passed to <code>file.copy</code></p>
</td></tr>
<tr><td><code id="copySingleFile_+3A_deldestination">delDestination</code></td>
<td>
<p>Logical, whether the destination should have any files deleted,
if they don't exist in the source. This is <code style="white-space: pre;">&#8288;/purge&#8288;</code> for robocopy and &ndash;delete for
rsync.</p>
</td></tr>
<tr><td><code id="copySingleFile_+3A_create">create</code></td>
<td>
<p>Passed to <code>checkPath</code>.</p>
</td></tr>
<tr><td><code id="copySingleFile_+3A_silent">silent</code></td>
<td>
<p>Should a progress be printed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function is called for its side effect, i.e., a file is copied <code>from</code> to <code>to</code>.
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire and Alex Chubaty
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmpDirFrom &lt;- file.path(tempdir(), "example_fileCopy_from")
tmpDirTo &lt;- file.path(tempdir(), "example_fileCopy_to")
tmpFile1 &lt;- tempfile("file1", tmpDirFrom, ".csv")
tmpFile2 &lt;- tempfile("file2", tmpDirFrom, ".csv")
dir.create(tmpDirFrom, recursive = TRUE, showWarnings = FALSE)
dir.create(tmpDirTo, recursive = TRUE, showWarnings = FALSE)
f1 &lt;- normalizePath(tmpFile1, mustWork = FALSE)
f2 &lt;- normalizePath(tmpFile2, mustWork = FALSE)
t1 &lt;- normalizePath(file.path(tmpDirTo, basename(tmpFile1)), mustWork = FALSE)
t2 &lt;- normalizePath(file.path(tmpDirTo, basename(tmpFile2)), mustWork = FALSE)

write.csv(data.frame(a = 1:10, b = runif(10), c = letters[1:10]), f1)
write.csv(data.frame(c = 11:20, d = runif(10), e = letters[11:20]), f2)
copyFile(c(f1, f2), c(t1, t2))
file.exists(t1) ## TRUE
file.exists(t2) ## TRUE
identical(read.csv(f1), read.csv(f2)) ## FALSE
identical(read.csv(f1), read.csv(t1)) ## TRUE
identical(read.csv(f2), read.csv(t2)) ## TRUE

</code></pre>

<hr>
<h2 id='createCache'>Low-level functions to create and work with a cache</h2><span id='topic+createCache'></span><span id='topic+loadFromCache'></span><span id='topic+extractFromCache'></span><span id='topic+rmFromCache'></span><span id='topic+CacheDBFile'></span><span id='topic+CacheStorageDir'></span><span id='topic+CacheStoredFile'></span><span id='topic+CacheDBTableName'></span><span id='topic+CacheIsACache'></span>

<h3>Description</h3>

<p><strong>These are intended for advanced use only.</strong>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createCache(
  cachePath = getOption("reproducible.cachePath"),
  drv = getDrv(getOption("reproducible.drv", NULL)),
  conn = getOption("reproducible.conn", NULL),
  force = FALSE,
  verbose = getOption("reproducible.verbose")
)

loadFromCache(
  cachePath = getOption("reproducible.cachePath"),
  cacheId,
  preDigest,
  fullCacheTableForObj = NULL,
  format = getOption("reproducible.cacheSaveFormat", "rds"),
  .functionName = NULL,
  .dotsFromCache = NULL,
  drv = getDrv(getOption("reproducible.drv", NULL)),
  conn = getOption("reproducible.conn", NULL),
  verbose = getOption("reproducible.verbose")
)

extractFromCache(sc, elem, ifNot = NULL)

rmFromCache(
  cachePath = getOption("reproducible.cachePath"),
  cacheId,
  drv = getDrv(getOption("reproducible.drv", NULL)),
  conn = getOption("reproducible.conn", NULL),
  format = getOption("reproducible.cacheSaveFormat", "rds")
)

CacheDBFile(
  cachePath = getOption("reproducible.cachePath"),
  drv = getDrv(getOption("reproducible.drv", NULL)),
  conn = getOption("reproducible.conn", NULL)
)

CacheStorageDir(cachePath = getOption("reproducible.cachePath"))

CacheStoredFile(
  cachePath = getOption("reproducible.cachePath"),
  cacheId,
  format = NULL,
  obj = NULL
)

CacheDBTableName(
  cachePath = getOption("reproducible.cachePath"),
  drv = getDrv(getOption("reproducible.drv", NULL))
)

CacheIsACache(
  cachePath = getOption("reproducible.cachePath"),
  create = FALSE,
  drv = getDrv(getOption("reproducible.drv", NULL)),
  conn = getOption("reproducible.conn", NULL)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createCache_+3A_cachepath">cachePath</code></td>
<td>
<p>A path describing the directory in which to create
the database file(s)</p>
</td></tr>
<tr><td><code id="createCache_+3A_drv">drv</code></td>
<td>
<p>A driver, passed to <code>dbConnect</code></p>
</td></tr>
<tr><td><code id="createCache_+3A_conn">conn</code></td>
<td>
<p>an optional DBIConnection object, as returned by dbConnect().</p>
</td></tr>
<tr><td><code id="createCache_+3A_force">force</code></td>
<td>
<p>Logical. Should it create a cache in the <code>cachePath</code>,
even if it already exists, overwriting.</p>
</td></tr>
<tr><td><code id="createCache_+3A_verbose">verbose</code></td>
<td>
<p>Numeric, -1 silent (where possible), 0 being very quiet,
1 showing more messaging, 2 being more messaging, etc.
Default is 1. Above 3 will output much more information about the internals of
Caching, which may help diagnose Caching challenges. Can set globally with an
option, e.g., <code style="white-space: pre;">&#8288;options('reproducible.verbose' = 0) to reduce to minimal&#8288;</code></p>
</td></tr>
<tr><td><code id="createCache_+3A_cacheid">cacheId</code></td>
<td>
<p>The cacheId or otherwise digested hash value, as character string.</p>
</td></tr>
<tr><td><code id="createCache_+3A_predigest">preDigest</code></td>
<td>
<p>The list of <code>preDigest</code> that comes from <code>CacheDigest</code> of an object</p>
</td></tr>
<tr><td><code id="createCache_+3A_fullcachetableforobj">fullCacheTableForObj</code></td>
<td>
<p>The result of <code>showCache</code>, but subsetted for only
the <code>cacheId</code> being loaded or selected</p>
</td></tr>
<tr><td><code id="createCache_+3A_format">format</code></td>
<td>
<p>The text string representing the file extension used normally by
different save formats; currently only <code>"rds"</code> or <code>"qs"</code>. Defaults
to <code>getOption("reproducible.cacheSaveFormat", "rds")</code></p>
</td></tr>
<tr><td><code id="createCache_+3A_.functionname">.functionName</code></td>
<td>
<p>Optional. Used for messaging when this function is called from <code>Cache</code></p>
</td></tr>
<tr><td><code id="createCache_+3A_.dotsfromcache">.dotsFromCache</code></td>
<td>
<p>Optional. Used internally.</p>
</td></tr>
<tr><td><code id="createCache_+3A_sc">sc</code></td>
<td>
<p>a cache tags <code>data.table</code> object</p>
</td></tr>
<tr><td><code id="createCache_+3A_elem">elem</code></td>
<td>
<p>character string specifying a <code>tagKey</code> value to match</p>
</td></tr>
<tr><td><code id="createCache_+3A_ifnot">ifNot</code></td>
<td>
<p>character (or NULL) specifying the return value to use if <code>elem</code> not matched</p>
</td></tr>
<tr><td><code id="createCache_+3A_obj">obj</code></td>
<td>
<p>The optional object that is of interest; it may have an attribute &quot;saveRawFile&quot;
that would be important.</p>
</td></tr>
<tr><td><code id="createCache_+3A_create">create</code></td>
<td>
<p>Logical. Currently only affects non <span class="pkg">RSQLite</span> default drivers.
If <code>TRUE</code> and there is no Cache database, the function will create one.</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>createCache()</code> will create a Cache folder structure and necessary files, based on
the particular <code>drv</code> or <code>conn</code> provided;
</p>
</li></ul>


<ul>
<li> <p><code>loadFromCache()</code> retrieves a single object from the cache, given its <code>cacheId</code>;
</p>
</li></ul>


<ul>
<li> <p><code>extractFromCache()</code> retrieves a single <code>tagValue</code> from the cache based on
the <code>tagKey</code> of <code>elem</code>;
</p>
</li></ul>


<ul>
<li> <p><code>rmFromCache()</code> removes one or more items from the cache, and updates the cache
database files.
</p>
</li></ul>



<h3>Value</h3>


<ul>
<li> <p><code>createCache()</code> returns <code>NULL</code> (invisibly) and intended to be called for side effects;
</p>
</li></ul>


<ul>
<li> <p><code>loadFromCache()</code> returns the object from the cache that has the particular <code>cacheId</code>;
</p>
</li></ul>


<ul>
<li> <p><code>extractFromCache()</code> returns the <code>tagValue</code> from the cache corresponding to <code>elem</code> if found,
otherwise the value of <code>ifNot</code>;
</p>
</li></ul>


<ul>
<li> <p><code>rmFromCache()</code> returns <code>NULL</code> (invisibly) and is intended to be called for side effects;
</p>
</li></ul>


<ul>
<li> <p><code>CacheDBFile()</code> returns the name of the database file for a given Cache,
when <code>useDBI() == FALSE</code>, or <code>NULL</code> if <code>TRUE</code>;
</p>
</li>
<li> <p><code>CacheDBFiles()</code> (i.e,. plural) returns the name of all the database files for
a given Cache when <code>useDBI() == TRUE</code>, or <code>NULL</code> if <code>FALSE</code>;
</p>
</li>
<li> <p><code>CacheStoredFile()</code> returns the file path to the file with the specified hash value,
This can be loaded to memory with e.g., <code><a href="#topic+loadFile">loadFile()</a></code>.;
</p>
</li></ul>


<ul>
<li> <p><code>CacheStorageDir()</code> returns the name of the directory where cached objects are stored;
</p>
</li></ul>


<ul>
<li> <p><code>CacheStoredFile</code> returns the file path to the file with the specified hash value;
</p>
</li></ul>


<ul>
<li> <p><code>CacheDBTableName()</code> returns the name of the table inside the SQL database, if that
is being used;
</p>
</li></ul>


<ul>
<li> <p><code>CacheIsACache()</code> returns a logical indicating whether the <code>cachePath</code> is currently
a <code>reproducible</code> cache database;
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(2)
newCache &lt;- tempdir2()
createCache(newCache)

out &lt;- Cache(rnorm(1), cachePath = newCache)
cacheId &lt;- gsub("cacheId:", "", attr(out, "tags"))
loadFromCache(newCache, cacheId = cacheId)

rmFromCache(newCache, cacheId = cacheId)

# clean up
unlink(newCache, recursive = TRUE)

data.table::setDTthreads(2)
newCache &lt;- tempdir2()

# Given the drv and conn, creates the minimum infrastructure for a cache
createCache(newCache)

CacheDBFile(newCache) # identifies the database file
CacheStorageDir(newCache) # identifies the directory where cached objects are stored

out &lt;- Cache(rnorm(1), cachePath = newCache)
cacheId &lt;- gsub("cacheId:", "", attr(out, "tags"))
CacheStoredFile(newCache, cacheId = cacheId)

# The name of the table inside the SQL database
CacheDBTableName(newCache)

CacheIsACache(newCache) # returns TRUE

# clean up
unlink(newCache, recursive = TRUE)
</code></pre>

<hr>
<h2 id='deprecated'>Crop a <code style="white-space: pre;">&#8288;Spatial*&#8288;</code> or <code style="white-space: pre;">&#8288;Raster*&#8288;</code> object</h2><span id='topic+deprecated'></span><span id='topic+cropInputs'></span><span id='topic+cropInputs.default'></span><span id='topic+fixErrors'></span><span id='topic+fixErrors.default'></span><span id='topic+projectInputs'></span><span id='topic+projectInputs.default'></span><span id='topic+maskInputs'></span><span id='topic+writeOutputs'></span><span id='topic+writeOutputs.default'></span>

<h3>Description</h3>

<p>This function is deprecated. Use <code>cropTo</code>. If used, all arguments will be passed
to <code>cropTo</code> anyway.
</p>
<p><code>fixErrors</code> &ndash;&gt; <code>fixErrosTerra</code>
</p>
<p>Deprecated. Use <code><a href="#topic+projectTo">projectTo()</a></code>.
</p>
<p><code>maskInputs</code> is deprecated. Use <code><a href="#topic+maskTo">maskTo()</a></code>
</p>
<p>See <code><a href="#topic+writeTo">writeTo()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cropInputs(
  x,
  studyArea,
  rasterToMatch,
  verbose = getOption("reproducible.verbose", 1),
  ...
)

## Default S3 method:
cropInputs(x, ...)

fixErrors(
  x,
  objectName,
  attemptErrorFixes = TRUE,
  useCache = getOption("reproducible.useCache", FALSE),
  verbose = getOption("reproducible.verbose", 1),
  testValidity = getOption("reproducible.testValidity", TRUE),
  ...
)

## Default S3 method:
fixErrors(
  x,
  objectName,
  attemptErrorFixes = TRUE,
  useCache = getOption("reproducible.useCache", FALSE),
  verbose = getOption("reproducible.verbose", 1),
  testValidity = getOption("reproducible.testValidity", TRUE),
  ...
)

projectInputs(
  x,
  targetCRS,
  verbose = getOption("reproducible.verbose", 1),
  ...
)

## Default S3 method:
projectInputs(x, targetCRS, ...)

maskInputs(x, studyArea, ...)

writeOutputs(
  x,
  ...,
  overwrite = getOption("reproducible.overwrite", NULL),
  verbose = getOption("reproducible.verbose", 1)
)

## Default S3 method:
writeOutputs(
  x,
  ...,
  overwrite = getOption("reproducible.overwrite", FALSE),
  verbose = getOption("reproducible.verbose", 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deprecated_+3A_x">x</code></td>
<td>
<p>The object save to disk i.e., write outputs</p>
</td></tr>
<tr><td><code id="deprecated_+3A_studyarea">studyArea</code></td>
<td>
<p><code style="white-space: pre;">&#8288;SpatialPolygons*&#8288;</code> object used for masking and possibly cropping
if no <code>rasterToMatch</code> is provided.
If not in same CRS, then it will be <code>spTransform</code>ed to
CRS of <code>x</code> before masking. Currently, this function will not reproject the
<code>x</code>. Optional in <code>postProcess</code>.</p>
</td></tr>
<tr><td><code id="deprecated_+3A_rastertomatch">rasterToMatch</code></td>
<td>
<p>Template <code style="white-space: pre;">&#8288;Raster*&#8288;</code> object passed to the <code>to</code> argument of
<code><a href="#topic+projectTo">projectTo()</a></code>, thus will changing the
resolution and projection of <code>x</code>.
See details in <code><a href="#topic+postProcessTo">postProcessTo()</a></code>.</p>
</td></tr>
<tr><td><code id="deprecated_+3A_verbose">verbose</code></td>
<td>
<p>Numeric, -1 silent (where possible), 0 being very quiet,
1 showing more messaging, 2 being more messaging, etc.
Default is 1. Above 3 will output much more information about the internals of
Caching, which may help diagnose Caching challenges. Can set globally with an
option, e.g., <code style="white-space: pre;">&#8288;options('reproducible.verbose' = 0) to reduce to minimal&#8288;</code></p>
</td></tr>
<tr><td><code id="deprecated_+3A_...">...</code></td>
<td>
<p>Passed into <code><a href="#topic+writeTo">writeTo()</a></code></p>
</td></tr>
<tr><td><code id="deprecated_+3A_objectname">objectName</code></td>
<td>
<p>Optional. This is only for messaging; if provided, then messages relayed
to user will mention this.</p>
</td></tr>
<tr><td><code id="deprecated_+3A_attempterrorfixes">attemptErrorFixes</code></td>
<td>
<p>Will attempt to fix known errors. Currently only some failures
for <code style="white-space: pre;">&#8288;SpatialPolygons*&#8288;</code> are attempted.
Notably with <code>terra::buffer(..., width = 0)</code>.
Default <code>TRUE</code>, though this may not be the right action for all cases.</p>
</td></tr>
<tr><td><code id="deprecated_+3A_usecache">useCache</code></td>
<td>
<p>Logical, default <code>getOption("reproducible.useCache", FALSE)</code>, whether
Cache is used on the internal <code>terra::buffer</code> command.</p>
</td></tr>
<tr><td><code id="deprecated_+3A_testvalidity">testValidity</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the a test for validity will happen
before actually running buffering (which is the solution in most
cases). However, sometimes it takes longer to test for validity
than just buffer without testing (there are no consequences of
buffering if everything is valid). If <code>FALSE</code>, then the
test will be skipped and the buffering will happen regardless.
If <code>NA</code>, then all testing and buffering will be skipped.</p>
</td></tr>
<tr><td><code id="deprecated_+3A_targetcrs">targetCRS</code></td>
<td>
<p>The CRS of x at the end  of this function (i.e., the goal)</p>
</td></tr>
<tr><td><code id="deprecated_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical. Should file being written overwrite an existing file if it exists.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A GIS file (e.g., RasterLayer, SpatRaster etc.) that has been
appropriately cropped.
</p>
<p>A GIS file (e.g., RasterLayer, SpatRaster etc.) that has been
attempted to be fixed, if it finds errors.
</p>
<p>A file of the same type as starting, but with projection (and possibly
other characteristics, including resolution, origin, extent if changed).
</p>
<p>A GIS file (e.g., RasterLayer, SpatRaster etc.) that has been
appropriately reprojected.
</p>
<p>A GIS file (e.g., RasterLayer, SpatRaster etc.) that has been
appropriately masked.
</p>
<p>A GIS file (e.g., SpatRaster etc.) that has been
appropriately written to disk. In the case of vector datasets, this will
be a side effect. In the case of gridded objects (Raster*, SpatRaster), the
object will have a file-backing.
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire, Jean Marchal, Ian Eddy, and Tati Micheletti
</p>
<p>Eliot McIntire and Jean Marchal
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fixErrorsIn">fixErrorsIn()</a></code>, <code><a href="#topic+postProcessTo">postProcessTo()</a></code>, <code><a href="#topic+postProcess">postProcess()</a></code>
</p>
<p><code><a href="#topic+projectTo">projectTo()</a></code>
</p>
<p><code><a href="#topic+maskTo">maskTo()</a></code>, <code><a href="#topic+postProcessTo">postProcessTo()</a></code> for related examples
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("terra", quietly = TRUE)) {
  r &lt;- terra::rast(terra::ext(0, 100, 0, 100), vals = 1:1e2)

  tf &lt;- tempfile(fileext = ".tif")
  writeOutputs(r, tf)
}
</code></pre>

<hr>
<h2 id='determineFilename'>Determine filename, either automatically or manually</h2><span id='topic+determineFilename'></span>

<h3>Description</h3>

<p>Determine the filename, given various combinations of inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>determineFilename(
  filename2 = NULL,
  filename1 = NULL,
  destinationPath = getOption("reproducible.destinationPath", "."),
  verbose = getOption("reproducible.verbose", 1),
  prefix = "Small",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="determineFilename_+3A_filename2">filename2</code></td>
<td>
<p><code>filename2</code> is optional, and is either
NULL (no writing of outputs to disk), or several options
for writing the object to disk. If
<code>TRUE</code> (the default), it will give it a file name determined by
<code>.prefix(basename(filename1), prefix)</code>. If
a character string, it will use this as its file name. See
<code><a href="#topic+determineFilename">determineFilename()</a></code>.</p>
</td></tr>
<tr><td><code id="determineFilename_+3A_filename1">filename1</code></td>
<td>
<p>Character strings giving the file paths of
the <em>input</em> object (<code>filename1</code>) <code>filename1</code>
is only used for messaging (i.e., the object itself is passed
in as <code>x</code>) and possibly naming of output (see details
and <code>filename2</code>).</p>
</td></tr>
<tr><td><code id="determineFilename_+3A_destinationpath">destinationPath</code></td>
<td>
<p>Optional. If <code>filename2</code> is a relative file path, then this
will be the directory of the resulting absolute file path.</p>
</td></tr>
<tr><td><code id="determineFilename_+3A_verbose">verbose</code></td>
<td>
<p>Numeric, -1 silent (where possible), 0 being very quiet,
1 showing more messaging, 2 being more messaging, etc.
Default is 1. Above 3 will output much more information about the internals of
Caching, which may help diagnose Caching challenges. Can set globally with an
option, e.g., <code style="white-space: pre;">&#8288;options('reproducible.verbose' = 0) to reduce to minimal&#8288;</code></p>
</td></tr>
<tr><td><code id="determineFilename_+3A_prefix">prefix</code></td>
<td>
<p>The character string to prepend to <code>filename1</code>, if <code>filename2</code>
not provided.</p>
</td></tr>
<tr><td><code id="determineFilename_+3A_...">...</code></td>
<td>
<p>Passed into <code><a href="#topic+writeTo">writeTo()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The post processing workflow, which includes this function,
addresses several scenarios, and depending on which scenario, there are
several file names at play. For example, <code>Raster</code> objects may have
file-backed data, and so <em>possess a file name</em>, whereas <code>Spatial</code>
objects do not. Also, if post processing is part of a <code><a href="#topic+prepInputs">prepInputs()</a></code>
workflow, there will always be a file downloaded. From the perspective of
<code>postProcess</code>, these are the &quot;inputs&quot; or <code>filename1</code>.
Similarly, there may or may not be a desire to write an
object to disk after all post processing, <code>filename2</code>.
</p>
<p>This subtlety means that there are two file names that may be at play:
the &quot;input&quot; file name (<code>filename1</code>), and the &quot;output&quot; filename (<code>filename2</code>).
When this is used within <code>postProcess</code>, it is straight forward.
</p>
<p>However, when <code>postProcess</code> is used within a <code>prepInputs</code> call,
the <code>filename1</code> file is the file name of the downloaded file (usually
automatically known following the downloading, and refered to as <code>targetFile</code>)
and the <code>filename2</code> is the file name of the of post-processed file.
</p>
<p>If <code>filename2</code> is <code>TRUE</code>, i.e., not an actual file name, then the cropped/masked
raster will be written to disk with the original <code>filenam1/targetFile</code>
name, with <code>prefix</code> prefixed to the basename(<code>targetFile</code>).
</p>
<p>If <code>filename2</code> is a character string, it will be the path of the saved/written
object e.g., passed to <code>writeOutput</code>. It will be tested whether it is an
absolute or relative path and used as is if absolute or
prepended with <code>destinationPath</code> if relative.
</p>
<p>If <code>filename2</code> is <code>logical</code>, then the output
filename will be <code>prefix</code> prefixed to the basename(<code>filename1</code>).
If a character string, it
will be the path returned. It will be tested whether it is an
absolute or relative path and used as is if absolute or prepended with
<code>destinationPath</code> if provided, and if <code>filename2</code> is relative.
</p>

<hr>
<h2 id='dlGeneric'>Download file from generic source url</h2><span id='topic+dlGeneric'></span>

<h3>Description</h3>

<p>Download file from generic source url
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlGeneric(url, destinationPath, verbose = getOption("reproducible.verbose", 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dlGeneric_+3A_url">url</code></td>
<td>
<p>The url (link) to the file.</p>
</td></tr>
<tr><td><code id="dlGeneric_+3A_destinationpath">destinationPath</code></td>
<td>
<p>Character string of a directory in which to download
and save the file that comes from <code>url</code> and is also where the function
will look for <code>archive</code> or <code>targetFile</code>. NOTE (still experimental):
To prevent repeated downloads in different locations, the user can also set
<code>options("reproducible.inputPaths")</code> to one or more local file paths to
search for the file before attempting to download. Default for that option is
<code>NULL</code> meaning do not search locally.</p>
</td></tr>
<tr><td><code id="dlGeneric_+3A_verbose">verbose</code></td>
<td>
<p>Numeric, -1 silent (where possible), 0 being very quiet,
1 showing more messaging, 2 being more messaging, etc.
Default is 1. Above 3 will output much more information about the internals of
Caching, which may help diagnose Caching challenges. Can set globally with an
option, e.g., <code style="white-space: pre;">&#8288;options('reproducible.verbose' = 0) to reduce to minimal&#8288;</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eliot McIntire and Alex Chubaty
</p>

<hr>
<h2 id='dlGoogle'>Download file from Google Drive</h2><span id='topic+dlGoogle'></span>

<h3>Description</h3>

<p>Download file from Google Drive
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlGoogle(
  url,
  archive = NULL,
  targetFile = NULL,
  checkSums,
  messSkipDownload,
  destinationPath,
  type = NULL,
  overwrite,
  needChecksums,
  verbose = getOption("reproducible.verbose", 1),
  team_drive = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dlGoogle_+3A_url">url</code></td>
<td>
<p>The url (link) to the file.</p>
</td></tr>
<tr><td><code id="dlGoogle_+3A_archive">archive</code></td>
<td>
<p>Optional character string giving the path of an archive
containing <code>targetFile</code>, or a vector giving a set of nested archives
(e.g., <code>c("xxx.tar", "inner.zip", "inner.rar")</code>). If there is/are (an) inner
archive(s), but they are unknown, the function will try all until it finds
the <code>targetFile</code>. See table in <code><a href="#topic+preProcess">preProcess()</a></code>. If it is <code>NA</code>,
then it will <em>not</em> attempt to see it as an archive, even if it has archive-like
file extension (e.g., <code>.zip</code>). This may be useful when an R function
is expecting an archive directly.</p>
</td></tr>
<tr><td><code id="dlGoogle_+3A_targetfile">targetFile</code></td>
<td>
<p>Character string giving the filename (without relative or
absolute path) to the eventual file
(raster, shapefile, csv, etc.) after downloading and extracting from a zip
or tar archive. This is the file <em>before</em> it is passed to
<code>postProcess</code>. The internal checksumming does not checksum
the file after it is <code>postProcess</code>ed (e.g., cropped/reprojected/masked).
Using <code>Cache</code> around <code>prepInputs</code> will do a sufficient job in these cases.
See table in <code><a href="#topic+preProcess">preProcess()</a></code>.</p>
</td></tr>
<tr><td><code id="dlGoogle_+3A_destinationpath">destinationPath</code></td>
<td>
<p>Character string of a directory in which to download
and save the file that comes from <code>url</code> and is also where the function
will look for <code>archive</code> or <code>targetFile</code>. NOTE (still experimental):
To prevent repeated downloads in different locations, the user can also set
<code>options("reproducible.inputPaths")</code> to one or more local file paths to
search for the file before attempting to download. Default for that option is
<code>NULL</code> meaning do not search locally.</p>
</td></tr>
<tr><td><code id="dlGoogle_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical. Should downloading and all the other actions occur
even if they pass the checksums or the files are all there.</p>
</td></tr>
<tr><td><code id="dlGoogle_+3A_verbose">verbose</code></td>
<td>
<p>Numeric, -1 silent (where possible), 0 being very quiet,
1 showing more messaging, 2 being more messaging, etc.
Default is 1. Above 3 will output much more information about the internals of
Caching, which may help diagnose Caching challenges. Can set globally with an
option, e.g., <code style="white-space: pre;">&#8288;options('reproducible.verbose' = 0) to reduce to minimal&#8288;</code></p>
</td></tr>
<tr><td><code id="dlGoogle_+3A_...">...</code></td>
<td>
<p>Not used here. Only used to allow other arguments to other fns to not fail.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Eliot McIntire and Alex Chubaty
</p>

<hr>
<h2 id='downloadFile'>A wrapper around a set of downloading functions</h2><span id='topic+downloadFile'></span>

<h3>Description</h3>

<p>Currently, this only deals with <code>googledrive::drive_download</code>,
and <code><a href="utils.html#topic+download.file">utils::download.file()</a></code>. In general, this is not intended for use by a
user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>downloadFile(
  archive,
  targetFile,
  neededFiles,
  destinationPath = getOption("reproducible.destinationPath", "."),
  quick,
  checksumFile,
  dlFun = NULL,
  checkSums,
  url,
  needChecksums,
  preDigest,
  overwrite = getOption("reproducible.overwrite", TRUE),
  verbose = getOption("reproducible.verbose", 1),
  purge = FALSE,
  .tempPath,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="downloadFile_+3A_archive">archive</code></td>
<td>
<p>Optional character string giving the path of an archive
containing <code>targetFile</code>, or a vector giving a set of nested archives
(e.g., <code>c("xxx.tar", "inner.zip", "inner.rar")</code>). If there is/are (an) inner
archive(s), but they are unknown, the function will try all until it finds
the <code>targetFile</code>. See table in <code><a href="#topic+preProcess">preProcess()</a></code>. If it is <code>NA</code>,
then it will <em>not</em> attempt to see it as an archive, even if it has archive-like
file extension (e.g., <code>.zip</code>). This may be useful when an R function
is expecting an archive directly.</p>
</td></tr>
<tr><td><code id="downloadFile_+3A_targetfile">targetFile</code></td>
<td>
<p>Character string giving the filename (without relative or
absolute path) to the eventual file
(raster, shapefile, csv, etc.) after downloading and extracting from a zip
or tar archive. This is the file <em>before</em> it is passed to
<code>postProcess</code>. The internal checksumming does not checksum
the file after it is <code>postProcess</code>ed (e.g., cropped/reprojected/masked).
Using <code>Cache</code> around <code>prepInputs</code> will do a sufficient job in these cases.
See table in <code><a href="#topic+preProcess">preProcess()</a></code>.</p>
</td></tr>
<tr><td><code id="downloadFile_+3A_neededfiles">neededFiles</code></td>
<td>
<p>Character string giving the name of the file(s) to be extracted.</p>
</td></tr>
<tr><td><code id="downloadFile_+3A_destinationpath">destinationPath</code></td>
<td>
<p>Character string of a directory in which to download
and save the file that comes from <code>url</code> and is also where the function
will look for <code>archive</code> or <code>targetFile</code>. NOTE (still experimental):
To prevent repeated downloads in different locations, the user can also set
<code>options("reproducible.inputPaths")</code> to one or more local file paths to
search for the file before attempting to download. Default for that option is
<code>NULL</code> meaning do not search locally.</p>
</td></tr>
<tr><td><code id="downloadFile_+3A_quick">quick</code></td>
<td>
<p>Logical. This is passed internally to <code><a href="#topic+Checksums">Checksums()</a></code>
(the quickCheck argument), and to
<code><a href="#topic+Cache">Cache()</a></code> (the quick argument). This results in faster, though
less robust checking of inputs. See the respective functions.</p>
</td></tr>
<tr><td><code id="downloadFile_+3A_checksumfile">checksumFile</code></td>
<td>
<p>A character string indicating the absolute path to the <code>CHECKSUMS.txt</code>
file.</p>
</td></tr>
<tr><td><code id="downloadFile_+3A_dlfun">dlFun</code></td>
<td>
<p>Optional &quot;download function&quot; name, such as <code>"raster::getData"</code>, which does
custom downloading, in addition to loading into R. Still experimental.</p>
</td></tr>
<tr><td><code id="downloadFile_+3A_checksums">checkSums</code></td>
<td>
<p>A checksums file, e.g., created by Checksums(..., write = TRUE)</p>
</td></tr>
<tr><td><code id="downloadFile_+3A_url">url</code></td>
<td>
<p>Optional character string indicating the URL to download from.
If not specified, then no download will be attempted. If not entry
exists in the <code>CHECKSUMS.txt</code> (in <code>destinationPath</code>), an entry
will be created or appended to. This <code>CHECKSUMS.txt</code> entry will be used
in subsequent calls to
<code>prepInputs</code> or <code>preProcess</code>, comparing the file on hand with the ad hoc
<code>CHECKSUMS.txt</code>. See table in <code><a href="#topic+preProcess">preProcess()</a></code>.</p>
</td></tr>
<tr><td><code id="downloadFile_+3A_needchecksums">needChecksums</code></td>
<td>
<p>A numeric, with <code>0</code> indicating do not write a new checksums,
<code>1</code> write a new one,
<code>2</code> append new information to existing one.</p>
</td></tr>
<tr><td><code id="downloadFile_+3A_predigest">preDigest</code></td>
<td>
<p>The list of <code>preDigest</code> that comes from <code>CacheDigest</code> of an object</p>
</td></tr>
<tr><td><code id="downloadFile_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical. Should downloading and all the other actions occur
even if they pass the checksums or the files are all there.</p>
</td></tr>
<tr><td><code id="downloadFile_+3A_verbose">verbose</code></td>
<td>
<p>Numeric, -1 silent (where possible), 0 being very quiet,
1 showing more messaging, 2 being more messaging, etc.
Default is 1. Above 3 will output much more information about the internals of
Caching, which may help diagnose Caching challenges. Can set globally with an
option, e.g., <code style="white-space: pre;">&#8288;options('reproducible.verbose' = 0) to reduce to minimal&#8288;</code></p>
</td></tr>
<tr><td><code id="downloadFile_+3A_purge">purge</code></td>
<td>
<p>Logical or Integer. <code>0/FALSE</code> (default) keeps existing
<code>CHECKSUMS.txt</code> file and
<code>prepInputs</code> will write or append to it. <code>1/TRUE</code> will deleted the entire
<code>CHECKSUMS.txt</code> file. Other options, see details.</p>
</td></tr>
<tr><td><code id="downloadFile_+3A_.temppath">.tempPath</code></td>
<td>
<p>Optional temporary path for internal file intermediate steps.
Will be cleared on.exit from this function.</p>
</td></tr>
<tr><td><code id="downloadFile_+3A_...">...</code></td>
<td>
<p>Passed to <code>dlFun</code>. Still experimental. Can be e.g., <code>type</code> for google docs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function is called for its side effects, which will be a downloaded file
(<code>targetFile</code>), placed in <code>destinationPath</code>. This file will be checksummed, and
that checksum will be appended to the <code>checksumFile</code>.
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>

<hr>
<h2 id='downloadRemote'>Download a remote file</h2><span id='topic+downloadRemote'></span>

<h3>Description</h3>

<p>Download a remote file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>downloadRemote(
  url,
  archive,
  targetFile,
  checkSums,
  dlFun = NULL,
  fileToDownload,
  messSkipDownload,
  destinationPath,
  overwrite,
  needChecksums,
  .tempPath,
  preDigest,
  verbose = getOption("reproducible.verbose", 1),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="downloadRemote_+3A_url">url</code></td>
<td>
<p>Optional character string indicating the URL to download from.
If not specified, then no download will be attempted. If not entry
exists in the <code>CHECKSUMS.txt</code> (in <code>destinationPath</code>), an entry
will be created or appended to. This <code>CHECKSUMS.txt</code> entry will be used
in subsequent calls to
<code>prepInputs</code> or <code>preProcess</code>, comparing the file on hand with the ad hoc
<code>CHECKSUMS.txt</code>. See table in <code><a href="#topic+preProcess">preProcess()</a></code>.</p>
</td></tr>
<tr><td><code id="downloadRemote_+3A_archive">archive</code></td>
<td>
<p>Optional character string giving the path of an archive
containing <code>targetFile</code>, or a vector giving a set of nested archives
(e.g., <code>c("xxx.tar", "inner.zip", "inner.rar")</code>). If there is/are (an) inner
archive(s), but they are unknown, the function will try all until it finds
the <code>targetFile</code>. See table in <code><a href="#topic+preProcess">preProcess()</a></code>. If it is <code>NA</code>,
then it will <em>not</em> attempt to see it as an archive, even if it has archive-like
file extension (e.g., <code>.zip</code>). This may be useful when an R function
is expecting an archive directly.</p>
</td></tr>
<tr><td><code id="downloadRemote_+3A_targetfile">targetFile</code></td>
<td>
<p>Character string giving the filename (without relative or
absolute path) to the eventual file
(raster, shapefile, csv, etc.) after downloading and extracting from a zip
or tar archive. This is the file <em>before</em> it is passed to
<code>postProcess</code>. The internal checksumming does not checksum
the file after it is <code>postProcess</code>ed (e.g., cropped/reprojected/masked).
Using <code>Cache</code> around <code>prepInputs</code> will do a sufficient job in these cases.
See table in <code><a href="#topic+preProcess">preProcess()</a></code>.</p>
</td></tr>
<tr><td><code id="downloadRemote_+3A_checksums">checkSums</code></td>
<td>
<p>TODO</p>
</td></tr>
<tr><td><code id="downloadRemote_+3A_dlfun">dlFun</code></td>
<td>
<p>Optional &quot;download function&quot; name, such as <code>"raster::getData"</code>, which does
custom downloading, in addition to loading into R. Still experimental.</p>
</td></tr>
<tr><td><code id="downloadRemote_+3A_filetodownload">fileToDownload</code></td>
<td>
<p>TODO</p>
</td></tr>
<tr><td><code id="downloadRemote_+3A_messskipdownload">messSkipDownload</code></td>
<td>
<p>The character string text to pass to messaging if download skipped</p>
</td></tr>
<tr><td><code id="downloadRemote_+3A_destinationpath">destinationPath</code></td>
<td>
<p>Character string of a directory in which to download
and save the file that comes from <code>url</code> and is also where the function
will look for <code>archive</code> or <code>targetFile</code>. NOTE (still experimental):
To prevent repeated downloads in different locations, the user can also set
<code>options("reproducible.inputPaths")</code> to one or more local file paths to
search for the file before attempting to download. Default for that option is
<code>NULL</code> meaning do not search locally.</p>
</td></tr>
<tr><td><code id="downloadRemote_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical. Should downloading and all the other actions occur
even if they pass the checksums or the files are all there.</p>
</td></tr>
<tr><td><code id="downloadRemote_+3A_needchecksums">needChecksums</code></td>
<td>
<p>Logical indicating whether to generate checksums. ## TODO: add overwrite arg to the function?</p>
</td></tr>
<tr><td><code id="downloadRemote_+3A_.temppath">.tempPath</code></td>
<td>
<p>Optional temporary path for internal file intermediate steps.
Will be cleared on.exit from this function.</p>
</td></tr>
<tr><td><code id="downloadRemote_+3A_predigest">preDigest</code></td>
<td>
<p>The list of <code>preDigest</code> that comes from <code>CacheDigest</code> of an object</p>
</td></tr>
<tr><td><code id="downloadRemote_+3A_verbose">verbose</code></td>
<td>
<p>Numeric, -1 silent (where possible), 0 being very quiet,
1 showing more messaging, 2 being more messaging, etc.
Default is 1. Above 3 will output much more information about the internals of
Caching, which may help diagnose Caching challenges. Can set globally with an
option, e.g., <code style="white-space: pre;">&#8288;options('reproducible.verbose' = 0) to reduce to minimal&#8288;</code></p>
</td></tr>
<tr><td><code id="downloadRemote_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to
<code><a href="#topic+postProcess">postProcess()</a></code> and <code><a href="#topic+Cache">Cache()</a></code>.
Since <code>...</code> is passed to <code><a href="#topic+postProcess">postProcess()</a></code>, these will
<code>...</code> will also be passed into the inner
functions, e.g., <code><a href="#topic+cropInputs">cropInputs()</a></code>. Possibly useful other arguments include
<code>dlFun</code> which is passed to <code>preProcess</code>. See details and examples.</p>
</td></tr>
</table>

<hr>
<h2 id='extractFromArchive'>Extract files from archive</h2><span id='topic+extractFromArchive'></span>

<h3>Description</h3>

<p>Extract zip or tar archive files, possibly nested in other zip or tar archives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extractFromArchive(
  archive,
  destinationPath = getOption("reproducible.destinationPath", dirname(archive)),
  neededFiles = NULL,
  extractedArchives = NULL,
  checkSums = NULL,
  needChecksums = 0,
  filesExtracted = character(),
  checkSumFilePath = character(),
  quick = FALSE,
  verbose = getOption("reproducible.verbose", 1),
  .tempPath,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extractFromArchive_+3A_archive">archive</code></td>
<td>
<p>Character string giving the path of the archive
containing the <code>file</code> to be extracted. This path must exist or be <code>NULL</code></p>
</td></tr>
<tr><td><code id="extractFromArchive_+3A_destinationpath">destinationPath</code></td>
<td>
<p>Character string giving the path where <code>neededFiles</code> will be
extracted. Defaults to the archive directory.</p>
</td></tr>
<tr><td><code id="extractFromArchive_+3A_neededfiles">neededFiles</code></td>
<td>
<p>Character string giving the name of the file(s) to be extracted.</p>
</td></tr>
<tr><td><code id="extractFromArchive_+3A_extractedarchives">extractedArchives</code></td>
<td>
<p>Used internally to track archives that have been extracted from.</p>
</td></tr>
<tr><td><code id="extractFromArchive_+3A_checksums">checkSums</code></td>
<td>
<p>A checksums file, e.g., created by Checksums(..., write = TRUE)</p>
</td></tr>
<tr><td><code id="extractFromArchive_+3A_needchecksums">needChecksums</code></td>
<td>
<p>A numeric, with <code>0</code> indicating do not write a new checksums,
<code>1</code> write a new one,
<code>2</code> append new information to existing one.</p>
</td></tr>
<tr><td><code id="extractFromArchive_+3A_filesextracted">filesExtracted</code></td>
<td>
<p>Used internally to track files that have been extracted.</p>
</td></tr>
<tr><td><code id="extractFromArchive_+3A_checksumfilepath">checkSumFilePath</code></td>
<td>
<p>The full path to the checksum.txt file</p>
</td></tr>
<tr><td><code id="extractFromArchive_+3A_quick">quick</code></td>
<td>
<p>Passed to <code>Checksums</code></p>
</td></tr>
<tr><td><code id="extractFromArchive_+3A_verbose">verbose</code></td>
<td>
<p>Numeric, -1 silent (where possible), 0 being very quiet,
1 showing more messaging, 2 being more messaging, etc.
Default is 1. Above 3 will output much more information about the internals of
Caching, which may help diagnose Caching challenges. Can set globally with an
option, e.g., <code style="white-space: pre;">&#8288;options('reproducible.verbose' = 0) to reduce to minimal&#8288;</code></p>
</td></tr>
<tr><td><code id="extractFromArchive_+3A_.temppath">.tempPath</code></td>
<td>
<p>Optional temporary path for internal file intermediate steps.
Will be cleared on.exit from this function.</p>
</td></tr>
<tr><td><code id="extractFromArchive_+3A_...">...</code></td>
<td>
<p>Passed to <code>unzip</code> or <code>untar</code>, e.g., <code>overwrite</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector listing the paths of the extracted archives.
</p>


<h3>Author(s)</h3>

<p>Jean Marchal and Eliot McIntire
</p>

<hr>
<h2 id='fastMask'>Faster operations on rasters (DEPRECATED because <code>terra::mask</code> is fast)</h2><span id='topic+fastMask'></span>

<h3>Description</h3>

<p>Deprecated. Use <code><a href="#topic+maskTo">maskTo()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastMask(
  x,
  y,
  cores = NULL,
  useGDAL = FALSE,
  verbose = getOption("reproducible.verbose", 1),
  ...,
  messageSkipDeprecated = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fastMask_+3A_x">x</code></td>
<td>
<p>A <code style="white-space: pre;">&#8288;Raster*&#8288;</code> object.</p>
</td></tr>
<tr><td><code id="fastMask_+3A_y">y</code></td>
<td>
<p>A <code>SpatialPolygons</code> object. If it is not in the same projection
as <code>x</code>, it will be reprojected on the fly to that of <code>x</code></p>
</td></tr>
<tr><td><code id="fastMask_+3A_cores">cores</code></td>
<td>
<p>An <code style="white-space: pre;">&#8288;integer*&#8288;</code> or <code>'AUTO'</code>. This will be used if gdalwarp is
triggered. <code>'AUTO'</code> will calculate 90% of the total
number of cores in the system, while an integer or rounded
float will be passed as the exact number of cores to be used.</p>
</td></tr>
<tr><td><code id="fastMask_+3A_usegdal">useGDAL</code></td>
<td>
<p>Deprecated. Logical or <code>"force"</code>. This is defunct; internals now can use
<code>terra</code> if <code>options("reproducible.useTerra" = TRUE)</code>, which is not (yet) the default.</p>
</td></tr>
<tr><td><code id="fastMask_+3A_verbose">verbose</code></td>
<td>
<p>Numeric, -1 silent (where possible), 0 being very quiet,
1 showing more messaging, 2 being more messaging, etc.
Default is 1. Above 3 will output much more information about the internals of
Caching, which may help diagnose Caching challenges. Can set globally with an
option, e.g., <code style="white-space: pre;">&#8288;options('reproducible.verbose' = 0) to reduce to minimal&#8288;</code></p>
</td></tr>
<tr><td><code id="fastMask_+3A_...">...</code></td>
<td>
<p>Currently unused.</p>
</td></tr>
<tr><td><code id="fastMask_+3A_messageskipdeprecated">messageSkipDeprecated</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then the message about this function
being deprecated will be suppressed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code style="white-space: pre;">&#8288;Raster*&#8288;</code> object, masked (i.e., smaller extent and/or several pixels converted to NA)
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>

<hr>
<h2 id='Filenames'>Return the filename(s) from a <code style="white-space: pre;">&#8288;Raster*&#8288;</code> object</h2><span id='topic+Filenames'></span><span id='topic+Filenames+2CANY-method'></span><span id='topic+Filenames+2Cenvironment-method'></span><span id='topic+Filenames+2Clist-method'></span><span id='topic+Filenames+2Cdata.table-method'></span><span id='topic+Filenames+2CPath-method'></span>

<h3>Description</h3>

<p>This is mostly just a wrapper around <code>filename</code> from the <code>raster</code> package, except that
instead of returning an empty string for a <code>RasterStack</code> object, it will return a vector of
length &gt;1 for <code>RasterStack</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Filenames(obj, allowMultiple = TRUE, returnList = FALSE)

## S4 method for signature 'ANY'
Filenames(obj, allowMultiple = TRUE, returnList = FALSE)

## S4 method for signature 'environment'
Filenames(obj, allowMultiple = TRUE, returnList = FALSE)

## S4 method for signature 'list'
Filenames(obj, allowMultiple = TRUE, returnList = FALSE)

## S4 method for signature 'data.table'
Filenames(obj, allowMultiple = TRUE, returnList = FALSE)

## S4 method for signature 'Path'
Filenames(obj, allowMultiple = TRUE, returnList = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Filenames_+3A_obj">obj</code></td>
<td>
<p>A <code style="white-space: pre;">&#8288;Raster*&#8288;</code> object (i.e., <code>RasterLayer</code>, <code>RasterStack</code>, <code>RasterBrick</code>)</p>
</td></tr>
<tr><td><code id="Filenames_+3A_allowmultiple">allowMultiple</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the default, then all relevant
filenames will be returned, i.e., in cases such as <code>.grd</code> where multiple files
are required. If <code>FALSE</code>, then only the first file will be returned,
e.g., <code>filename.grd</code>, in the case of default Raster format in R.</p>
</td></tr>
<tr><td><code id="Filenames_+3A_returnlist">returnList</code></td>
<td>
<p>Default <code>FALSE</code>. If <code>FALSE</code>, then return format will be a
character vector. When <code>TRUE</code>, list or environment objects will return a list
of character strings or vectors. When returned as a character vector, then
the names of objects with &gt;1 filename associated with them will be given a numeric
suffix, which means the name in the returned vector does not match the object in
the list or environment. When returned as a list, their names are preserved.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>New methods can be made for this generic.
</p>


<h3>Value</h3>

<p>A character vector of filenames that are part of the objects passed to <code>obj</code>.
This returns <code>NULL</code> is the object is not file-backed or does not have a method
to recover the file-backed filename.
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>

<hr>
<h2 id='fixErrorsIn'>Fix common errors in GIS layers, using <code>terra</code></h2><span id='topic+fixErrorsIn'></span>

<h3>Description</h3>

<p>Currently, this only tests for validity of a SpatVect file, then if there is a problem,
it will run <code>terra::makeValid</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixErrorsIn(
  x,
  error = NULL,
  verbose = getOption("reproducible.verbose"),
  fromFnName = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixErrorsIn_+3A_x">x</code></td>
<td>
<p>The SpatStat or SpatVect object to try to fix.</p>
</td></tr>
<tr><td><code id="fixErrorsIn_+3A_error">error</code></td>
<td>
<p>The error message, e.g., coming from <code>try(...)</code></p>
</td></tr>
<tr><td><code id="fixErrorsIn_+3A_verbose">verbose</code></td>
<td>
<p>Numeric, -1 silent (where possible), 0 being very quiet,
1 showing more messaging, 2 being more messaging, etc.
Default is 1. Above 3 will output much more information about the internals of
Caching, which may help diagnose Caching challenges. Can set globally with an
option, e.g., <code style="white-space: pre;">&#8288;options('reproducible.verbose' = 0) to reduce to minimal&#8288;</code></p>
</td></tr>
<tr><td><code id="fixErrorsIn_+3A_fromfnname">fromFnName</code></td>
<td>
<p>The function name that produced the error, e.g., <code>maskTo</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of the same class as <code>x</code>, but with some errors fixed via <code>terra::makeValid()</code>
</p>

<hr>
<h2 id='gdalProject'>3-Step postProcess sequence for SpatRasters using <code>gdalwarp</code></h2><span id='topic+gdalProject'></span><span id='topic+gdalResample'></span><span id='topic+gdalMask'></span>

<h3>Description</h3>

<p><code>gdalProject</code> is a thin wrapper around <code>sf::gdal_utils('gdalwarp', ...)</code> with specific options
set, notably, <code>-r</code> to <code>method</code> (in the ...), <code>-t_srs</code> to the crs of the <code>toRas</code>,
<code>-te</code> to the extent of the <code>toRas</code>, <code>-te_srs</code> to the <code>crs</code> of the <code>toRas</code>,
<code>-dstnodata = NA</code>, and <code>-overwrite</code>.
</p>
<p><code>gdalResample</code> is a thin wrapper around <code>sf::gdal_utils('gdalwarp', ...)</code> with specific options
set, notably, <code style="white-space: pre;">&#8288;"-r", "near"&#8288;</code>, <code>-te</code>, <code>-te_srs</code>, <code>tr</code>, <code>-dstnodata = NA</code>, <code>-overwrite</code>.
</p>
<p><code>gdalMask</code> is a thin wrapper around <code>sf::gdal_utils('gdalwarp', ...)</code> with specific options
set, notably, <code>-cutline</code>, <code>-dstnodata = NA</code>, and <code>-overwrite</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gdalProject(
  fromRas,
  toRas,
  filenameDest,
  verbose = getOption("reproducible.verbose"),
  ...
)

gdalResample(
  fromRas,
  toRas,
  filenameDest,
  verbose = getOption("reproducible.verbose"),
  ...
)

gdalMask(
  fromRas,
  maskToVect,
  writeTo = NULL,
  verbose = getOption("reproducible.verbose"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gdalProject_+3A_fromras">fromRas</code></td>
<td>
<p>see <code>from</code> argument from <code><a href="#topic+postProcessTo">postProcessTo()</a></code>, but can only be a  <code>SpatRaster</code>.</p>
</td></tr>
<tr><td><code id="gdalProject_+3A_toras">toRas</code></td>
<td>
<p>see <code>to</code> argument from <code><a href="#topic+postProcessTo">postProcessTo()</a></code>, but can only be a  <code>SpatRaster</code>.</p>
</td></tr>
<tr><td><code id="gdalProject_+3A_filenamedest">filenameDest</code></td>
<td>
<p>A filename with an appropriate extension (e.g., <code>.tif</code>) for
<code>gdal</code> to write the output to. Since this function is conceived to be part of a
chain, and not the final step, this function does not use <code>writeTo</code>, which is
reserved for the final step in the chain.</p>
</td></tr>
<tr><td><code id="gdalProject_+3A_verbose">verbose</code></td>
<td>
<p>Numeric, -1 silent (where possible), 0 being very quiet,
1 showing more messaging, 2 being more messaging, etc.
Default is 1. Above 3 will output much more information about the internals of
Caching, which may help diagnose Caching challenges. Can set globally with an
option, e.g., <code style="white-space: pre;">&#8288;options('reproducible.verbose' = 0) to reduce to minimal&#8288;</code></p>
</td></tr>
<tr><td><code id="gdalProject_+3A_...">...</code></td>
<td>
<p>For <code>gdalProject</code>, this can be <code>method</code>. For <code>gdalMask</code> can be <code>destinationPath</code> and <code>touches</code>.
For all <code style="white-space: pre;">&#8288;gdal*&#8288;</code>, this can also be and <code>datatype</code>.</p>
</td></tr>
<tr><td><code id="gdalProject_+3A_masktovect">maskToVect</code></td>
<td>
<p>see <code>maskTo</code> argument from <code><a href="#topic+maskTo">maskTo()</a></code>, but can only be a <code>SpatVector</code></p>
</td></tr>
<tr><td><code id="gdalProject_+3A_writeto">writeTo</code></td>
<td>
<p>Optional character string of a filename to use <code>writeRaster</code> to save the final
object. Default is <code>NULL</code>, which means there is no <code>writeRaster</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>These three functions are used within <code>postProcessTo</code>, in the sequence:
<code>gdalProject</code>, <code>gdalResample</code> and <code>gdalMask</code>, when <code>from</code> and <code>projectTo</code> are <code>SpatRaster</code> and
<code>maskTo</code> is a <code>SpatVector</code>, but only if <code>options(reproducible.gdalwarp = TRUE)</code> is set.
</p>
<p>This sequence is a slightly different order than the sequence when <code>gdalwarp = FALSE</code> or
the arguments do not match the above. This sequence was determined to be faster and
more accurate than any other sequence, including running all three steps in one
<code>gdalwarp</code> call (which <code>gdalwarp</code> can do). Using one-step <code>gdalwarp</code> resulted in
very coarse pixelation when converting from a coarse resolution to fine resolution, which
visually was inappropriate in test cases.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gdalResample">gdalResample()</a></code>, and <code><a href="#topic+gdalMask">gdalMask()</a></code> and the overarching <code><a href="#topic+postProcessTo">postProcessTo()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># prepare dummy data -- 3 SpatRasters, 2 SpatVectors
# need 2 SpatRaster
rf &lt;- system.file("ex/elev.tif", package = "terra")
elev1 &lt;- terra::rast(rf)
#'
ras2 &lt;- terra::deepcopy(elev1)
ras2[ras2 &gt; 200 &amp; ras2 &lt; 300] &lt;- NA_integer_
terra::values(elev1) &lt;- rep(1L, terra::ncell(ras2))
#'
# a polygon vector
f &lt;- system.file("ex/lux.shp", package = "terra")
vOrig &lt;- terra::vect(f)
v &lt;- vOrig[1:2, ]
#'
utm &lt;- terra::crs("epsg:23028") # $wkt
vInUTM &lt;- terra::project(vOrig, utm)
vAsRasInLongLat &lt;- terra::rast(vOrig, resolution = 0.008333333)
res100 &lt;- 100
rInUTM &lt;- terra::rast(vInUTM, resolution = res100)
# crop, reproject, mask, crop a raster with a vector in a different projection
#  --&gt; gives message about not enough information
t1 &lt;- postProcessTo(elev1, to = vInUTM)
# crop, reproject, mask a raster to a different projection, then mask
t2a &lt;- postProcessTo(elev1, to = vAsRasInLongLat, maskTo = vInUTM)


# using gdal directly --&gt; slightly different mask
opts &lt;- options(reproducible.gdalwarp = TRUE)
t2b &lt;- postProcessTo(elev1, to = vAsRasInLongLat, maskTo = vInUTM)
t3b &lt;- postProcessTo(elev1, to = rInUTM, maskTo = vInUTM)
options(opts)
</code></pre>

<hr>
<h2 id='getRelative'>Relative paths</h2><span id='topic+getRelative'></span><span id='topic+makeRelative'></span>

<h3>Description</h3>

<p>Extracting relative file paths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRelative(path, relativeToPath)

makeRelative(files, absoluteBase)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRelative_+3A_path">path</code></td>
<td>
<p>character vector or list specifying file paths</p>
</td></tr>
<tr><td><code id="getRelative_+3A_relativetopath">relativeToPath</code></td>
<td>
<p>directory against which <code>path</code> will be relativized.</p>
</td></tr>
<tr><td><code id="getRelative_+3A_files">files</code></td>
<td>
<p>character vector or list specifying file paths</p>
</td></tr>
<tr><td><code id="getRelative_+3A_absolutebase">absoluteBase</code></td>
<td>
<p>base directory (as absolute path) to prepend to <code>files</code></p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>getRelative()</code> searches <code>path</code> &quot;from the right&quot; (instead of &quot;from the left&quot;)
and tries to reconstruct it relative to directory specified by <code>relativeToPath</code>.
This is useful when dealing with symlinked paths.
</p>
</li>
<li> <p><code>makeRelative()</code> checks to see if <code>files</code> and <code>normPath(absoluteBase)</code> share a common path
(i.e., &quot;from the left&quot;), otherwise it returns <code>files</code>.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>

## create a project directory (e.g., on a hard drive)
(tmp1 &lt;- tempdir2("myProject", create = TRUE))

## create a cache directory elsewhere (e.g., on an SSD)
(tmp2 &lt;- tempdir2("my_cache", create = TRUE))

## symlink the project cache directory to tmp2
## files created here are actually stored in tmp2
prjCache &lt;- file.path(tmp1, "cache")
file.symlink(tmp2, prjCache)

## create a dummy cache object file in the project cache dir
(tmpf &lt;- tempfile("cache_", prjCache))
cat(rnorm(100), file = tmpf)
file.exists(tmpf)
normPath(tmpf) ## note the 'real' location (i.e., symlink resolved)

getRelative(tmpf, prjCache) ## relative path
getRelative(tmpf, tmp2) ## relative path

makeRelative(tmpf, tmp2) ## abs path; tmpf and normPath(tmp2) don't share common path
makeRelative(tmpf, prjCache) ## abs path; tmpf and normPath(tmp2) don't share common path
makeRelative(normPath(tmpf), prjCache) ## rel path; share common path when both normPath-ed

unlink(tmp1, recursive = TRUE)
unlink(tmp2, recursive = TRUE)

</code></pre>

<hr>
<h2 id='guessAtTarget'>Try to pick a file to load</h2><span id='topic+guessAtTarget'></span><span id='topic+.guessAtTargetAndFun'></span>

<h3>Description</h3>

<p>Try to pick a file to load
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.guessAtTargetAndFun(
  targetFilePath,
  destinationPath = getOption("reproducible.destinationPath", "."),
  filesExtracted,
  fun = NULL,
  verbose = getOption("reproducible.verbose", 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guessAtTarget_+3A_destinationpath">destinationPath</code></td>
<td>
<p>Full path of the directory where the target file should be</p>
</td></tr>
<tr><td><code id="guessAtTarget_+3A_filesextracted">filesExtracted</code></td>
<td>
<p>A character vector of all files that have been extracted (e.g.,
from an archive)</p>
</td></tr>
</table>

<hr>
<h2 id='internetExists'>Checks for existed of a url or the internet using <a href="https://CRAN.R-project.org">https://CRAN.R-project.org</a></h2><span id='topic+internetExists'></span><span id='topic+urlExists'></span>

<h3>Description</h3>

<p>A lightweight function that may be less reliable than more purpose built solutions
such as checking a specific web page using <code>RCurl::url.exists</code>. However, this is
slightly faster and is sufficient for many uses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>internetExists()

urlExists(url)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="internetExists_+3A_url">url</code></td>
<td>
<p>A url of the form <code style="white-space: pre;">&#8288;https://...&#8288;</code> to test for existence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical, <code>TRUE</code> if internet site exists, <code>FALSE</code> otherwise
</p>
<p>Logical, <code>TRUE</code> if internet site exists, <code>FALSE</code> otherwise.
</p>

<hr>
<h2 id='isInteractive'>Alternative to <code>interactive()</code> for unit testing</h2><span id='topic+isInteractive'></span>

<h3>Description</h3>

<p>This is a suggestion from
<a href="https://github.com/MangoTheCat/blog-with-mock/blob/master/Blogpost1.Rmd">https://github.com/MangoTheCat/blog-with-mock/blob/master/Blogpost1.Rmd</a>
as a way to test interactive code in unit tests. Basically, in the unit tests,
we use <code>testthat::with_mock</code>, and inside that we redefine <code>isInteractive</code>
just for the test. In all other times, this returns the same things as
<code>interactive()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isInteractive()
</code></pre>

<hr>
<h2 id='isUpdated'>Has a cached object has been updated?</h2><span id='topic+isUpdated'></span>

<h3>Description</h3>

<p>Has a cached object has been updated?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isUpdated(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isUpdated_+3A_x">x</code></td>
<td>
<p>cached object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical
</p>

<hr>
<h2 id='isWindows'>Test whether system is Windows</h2><span id='topic+isWindows'></span>

<h3>Description</h3>

<p>This is used so that unit tests can override this using <code>testthat::with_mock</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isWindows()
</code></pre>

<hr>
<h2 id='keepOrigGeom'>Keep original geometries of <code>sf</code> objects</h2><span id='topic+keepOrigGeom'></span>

<h3>Description</h3>

<p>When intersections occur, what was originally 2 polygons features can become
<code>LINESTRING</code> and/or <code>POINT</code> and any <code>COLLECTIONS</code> or <code style="white-space: pre;">&#8288;MULTI-&#8288;</code> versions of these.
This function evaluates what the original geometry was and drops any newly created
<em>different</em> geometries. For example, if a <code>POLYGON</code> becomes a <code>COLLECTION</code> of
<code>MULTIPOLYGON</code>, <code>POLYGON</code> and <code>POINT</code> geometries, the <code>POINT</code> geometries will
be dropped. This function is used internally in <code><a href="#topic+postProcessTo">postProcessTo()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keepOrigGeom(newObj, origObj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="keepOrigGeom_+3A_newobj">newObj</code></td>
<td>
<p>The new, derived <code>sf</code> object</p>
</td></tr>
<tr><td><code id="keepOrigGeom_+3A_origobj">origObj</code></td>
<td>
<p>The previous, object whose geometries should be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The original <code>newObj</code>, but with only the type of geometry that entered
into the function.
</p>

<hr>
<h2 id='linkOrCopy'>Hardlink, symlink, or copy a file</h2><span id='topic+linkOrCopy'></span>

<h3>Description</h3>

<p>Attempt first to make a hardlink. If that fails, try to make
a symlink (on non-windows systems and <code>symlink = TRUE</code>).
If that fails, copy the file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linkOrCopy(
  from,
  to,
  symlink = TRUE,
  overwrite = TRUE,
  verbose = getOption("reproducible.verbose", 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linkOrCopy_+3A_from">from</code>, <code id="linkOrCopy_+3A_to">to</code></td>
<td>
<p>Character vectors, containing file names or paths.
<code>to</code> can alternatively be the path to a single existing directory.</p>
</td></tr>
<tr><td><code id="linkOrCopy_+3A_symlink">symlink</code></td>
<td>
<p>Logical indicating whether to use symlink (instead of hardlink).
Default <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="linkOrCopy_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical. Should downloading and all the other actions occur
even if they pass the checksums or the files are all there.</p>
</td></tr>
<tr><td><code id="linkOrCopy_+3A_verbose">verbose</code></td>
<td>
<p>Numeric, -1 silent (where possible), 0 being very quiet,
1 showing more messaging, 2 being more messaging, etc.
Default is 1. Above 3 will output much more information about the internals of
Caching, which may help diagnose Caching challenges. Can set globally with an
option, e.g., <code style="white-space: pre;">&#8288;options('reproducible.verbose' = 0) to reduce to minimal&#8288;</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function is called for its side effects, which will be a <code>file.link</code> is that
is available or <code>file.copy</code> if not (e.g., the two directories are not on the
same physical disk).
</p>


<h3>Note</h3>

<p>Use caution with files-backed objects (e.g., rasters). See examples.
</p>


<h3>Author(s)</h3>

<p>Alex Chubaty and Eliot McIntire
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+file.link">file.link()</a></code>, <code><a href="base.html#topic+file.symlink">file.symlink()</a></code>, <code><a href="base.html#topic+file.copy">file.copy()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tmpDir &lt;- file.path(tempdir(), "symlink-test")
tmpDir &lt;- normalizePath(tmpDir, winslash = "/", mustWork = FALSE)
dir.create(tmpDir)

f0 &lt;- file.path(tmpDir, "file0.csv")
write.csv(iris, f0)

d1 &lt;- file.path(tmpDir, "dir1")
dir.create(d1)
write.csv(iris, file.path(d1, "file1.csv"))

d2 &lt;- file.path(tmpDir, "dir2")
dir.create(d2)
f2 &lt;- file.path(tmpDir, "file2.csv")

## create link to a file
linkOrCopy(f0, f2)
file.exists(f2) ## TRUE
identical(read.table(f0), read.table(f2)) ## TRUE

## deleting the link shouldn't delete the original file
unlink(f0)
file.exists(f0) ## FALSE
file.exists(f2) ## TRUE

if (requireNamespace("terra", quietly = TRUE)) {
  ## using spatRasters and other file-backed objects
  f3a &lt;- system.file("ex/test.grd", package = "terra")
  f3b &lt;- system.file("ex/test.gri", package = "terra")
  r3a &lt;- terra::rast(f3a)
  f4a &lt;- file.path(tmpDir, "raster4.grd")
  f4b &lt;- file.path(tmpDir, "raster4.gri")
  linkOrCopy(f3a, f4a) ## hardlink
  linkOrCopy(f3b, f4b) ## hardlink
  r4a &lt;- terra::rast(f4a)

  isTRUE(all.equal(r3a, r4a)) # TRUE

  ## cleanup
  unlink(tmpDir, recursive = TRUE)
}
</code></pre>

<hr>
<h2 id='listNamed'>Create a list with names from object names</h2><span id='topic+listNamed'></span>

<h3>Description</h3>

<p>This is a convenience wrapper around <code style="white-space: pre;">&#8288;newList &lt;- list(a = 1); names(newList) &lt;- "a"&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>listNamed(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="listNamed_+3A_...">...</code></td>
<td>
<p>Any elements to add to a list, as in <code>base::list</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This will return a named list, where names are the object names, captured
internally in the function and assigned to the list. If a user manually supplies
names, these will be kept (i.e., not overwritten by the object name).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- 1
b &lt;- 2
d &lt;- 3
(newList &lt;- listNamed(a, b, dManual = d)) # "dManual" name kept


</code></pre>

<hr>
<h2 id='loadFile'>Load a file from the cache</h2><span id='topic+loadFile'></span>

<h3>Description</h3>

<p>Load a file from the cache
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadFile(file, format = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loadFile_+3A_file">file</code></td>
<td>
<p>character specifying the path to the file</p>
</td></tr>
<tr><td><code id="loadFile_+3A_format">format</code></td>
<td>
<p>(optional) character string specifying file extension (&quot;qs&quot; or &quot;rds&quot;) of <code>file</code>;
if not specified (i.e., NULL), will be deduced from the file extension of <code>file</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the object loaded from <code>file</code>
</p>

<hr>
<h2 id='mergeCache'>Merge two cache repositories together</h2><span id='topic+mergeCache'></span><span id='topic+mergeCache+2CANY-method'></span>

<h3>Description</h3>

<p><img src="../help/figures/lifecycle-experimental.svg" alt="experimental" />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeCache(
  cacheTo,
  cacheFrom,
  drvTo = getDrv(getOption("reproducible.drv", NULL)),
  drvFrom = getDrv(getOption("reproducible.drv", NULL)),
  connTo = NULL,
  connFrom = NULL,
  verbose = getOption("reproducible.verbose")
)

## S4 method for signature 'ANY'
mergeCache(
  cacheTo,
  cacheFrom,
  drvTo = getDrv(getOption("reproducible.drv", NULL)),
  drvFrom = getDrv(getOption("reproducible.drv", NULL)),
  connTo = NULL,
  connFrom = NULL,
  verbose = getOption("reproducible.verbose")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeCache_+3A_cacheto">cacheTo</code></td>
<td>
<p>The cache repository (character string of the file path)
that will become larger, i.e., merge into this</p>
</td></tr>
<tr><td><code id="mergeCache_+3A_cachefrom">cacheFrom</code></td>
<td>
<p>The cache repository (character string of the file path)
from which all objects will be taken and copied from</p>
</td></tr>
<tr><td><code id="mergeCache_+3A_drvto">drvTo</code></td>
<td>
<p>The database driver for the <code>cacheTo</code>.</p>
</td></tr>
<tr><td><code id="mergeCache_+3A_drvfrom">drvFrom</code></td>
<td>
<p>The database driver for the <code>cacheFrom</code></p>
</td></tr>
<tr><td><code id="mergeCache_+3A_connto">connTo</code></td>
<td>
<p>The connection for the <code>cacheTo</code>. If not provided, then
a new one will be made from <code>drvTo</code> and <code>cacheTo</code></p>
</td></tr>
<tr><td><code id="mergeCache_+3A_connfrom">connFrom</code></td>
<td>
<p>The database for the <code>cacheFrom</code>. If not provided, then
a new one will be made from <code>drvFrom</code> and <code>cacheFrom</code></p>
</td></tr>
<tr><td><code id="mergeCache_+3A_verbose">verbose</code></td>
<td>
<p>Numeric, -1 silent (where possible), 0 being very quiet,
1 showing more messaging, 2 being more messaging, etc.
Default is 1. Above 3 will output much more information about the internals of
Caching, which may help diagnose Caching challenges. Can set globally with an
option, e.g., <code style="white-space: pre;">&#8288;options('reproducible.verbose' = 0) to reduce to minimal&#8288;</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>All the <code>cacheFrom</code> artifacts will be put into <code>cacheTo</code>
repository. All <code>userTags</code> will be copied verbatim, including
<code>accessed</code>, with 1 exception: <code>date</code> will be the
current <code>Sys.time()</code> at the time of merging. The
<code>createdDate</code> column will be similarly the current time
of merging.
</p>


<h3>Value</h3>

<p>The character string of the path of <code>cacheTo</code>, i.e., not the
objects themselves.
</p>

<hr>
<h2 id='messageDF'>Use <code>message</code> with a consistent use of <code>verbose</code></h2><span id='topic+messageDF'></span><span id='topic+messagePrepInputs'></span><span id='topic+messagePreProcess'></span><span id='topic+messageCache'></span><span id='topic+messageQuestion'></span><span id='topic+.messageFunctionFn'></span><span id='topic+messageColoured'></span>

<h3>Description</h3>

<p>This family has a consistent use of <code>verbose</code> allowing messages to be
turned on or off or verbosity increased or decreased throughout the family of
messaging in <code>reproducible</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>messageDF(
  df,
  round,
  colour = NULL,
  colnames = NULL,
  indent = NULL,
  verbose = getOption("reproducible.verbose"),
  verboseLevel = 1,
  appendLF = TRUE
)

messagePrepInputs(
  ...,
  appendLF = TRUE,
  verbose = getOption("reproducible.verbose"),
  verboseLevel = 1
)

messagePreProcess(
  ...,
  appendLF = TRUE,
  verbose = getOption("reproducible.verbose"),
  verboseLevel = 1
)

messageCache(
  ...,
  colour = getOption("reproducible.messageColourCache"),
  verbose = getOption("reproducible.verbose"),
  verboseLevel = 1,
  appendLF = TRUE
)

messageQuestion(..., verboseLevel = 0, appendLF = TRUE)

.messageFunctionFn(
  ...,
  appendLF = TRUE,
  verbose = getOption("reproducible.verbose"),
  verboseLevel = 1
)

messageColoured(
  ...,
  colour = NULL,
  indent = NULL,
  hangingIndent = TRUE,
  verbose = getOption("reproducible.verbose", 1),
  verboseLevel = 1,
  appendLF = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="messageDF_+3A_df">df</code></td>
<td>
<p>A data.frame, data.table, matrix</p>
</td></tr>
<tr><td><code id="messageDF_+3A_round">round</code></td>
<td>
<p>An optional numeric to pass to <code>round</code></p>
</td></tr>
<tr><td><code id="messageDF_+3A_colour">colour</code></td>
<td>
<p>Any colour that can be understood by <code>crayon</code></p>
</td></tr>
<tr><td><code id="messageDF_+3A_colnames">colnames</code></td>
<td>
<p>Logical or <code>NULL</code>. If <code>TRUE</code>, then it will print
column names even if there aren't any in the <code>df</code> (i.e., they will)
be <code>V1</code> etc., <code>NULL</code> will print them if they exist, and <code>FALSE</code>
which will omit them.</p>
</td></tr>
<tr><td><code id="messageDF_+3A_indent">indent</code></td>
<td>
<p>An integer, indicating whether to indent each line</p>
</td></tr>
<tr><td><code id="messageDF_+3A_verbose">verbose</code></td>
<td>
<p>Numeric, -1 silent (where possible), 0 being very quiet,
1 showing more messaging, 2 being more messaging, etc.
Default is 1. Above 3 will output much more information about the internals of
Caching, which may help diagnose Caching challenges. Can set globally with an
option, e.g., <code style="white-space: pre;">&#8288;options('reproducible.verbose' = 0) to reduce to minimal&#8288;</code></p>
</td></tr>
<tr><td><code id="messageDF_+3A_verboselevel">verboseLevel</code></td>
<td>
<p>The numeric value for this <code style="white-space: pre;">&#8288;message*&#8288;</code> call, equal or above
which <code>verbose</code> must be. The higher this is set, the more unlikely the call
will show a message.</p>
</td></tr>
<tr><td><code id="messageDF_+3A_appendlf">appendLF</code></td>
<td>
<p>logical: should messages given as a character string
have a newline appended?</p>
</td></tr>
<tr><td><code id="messageDF_+3A_...">...</code></td>
<td>
<p>Any character vector, passed to <code>paste0(...)</code></p>
</td></tr>
<tr><td><code id="messageDF_+3A_hangingindent">hangingIndent</code></td>
<td>
<p>Logical. If there are <code style="white-space: pre;">&#8288;\n&#8288;</code>, should there be a handing indent of 2 spaces.
Default is <code>TRUE</code></p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>messageDF</code> uses <code>message</code> to print a clean square data structure.
</p>
</li>
<li> <p><code>messageColoured</code> allows specific colours to be used.
</p>
</li>
<li> <p><code>messageQuestion</code> sets a high level for <code>verbose</code> so that the message always gets asked.
</p>
</li></ul>



<h3>Value</h3>

<p>Used for side effects. This will produce a message of a structured <code>data.frame</code>.
</p>

<hr>
<h2 id='minFn'>Get min or maximum value of a (Spat)Raster</h2><span id='topic+minFn'></span><span id='topic+maxFn'></span><span id='topic+dataType2'></span><span id='topic+nlayers2'></span><span id='topic+values2'></span>

<h3>Description</h3>

<p>During the transition from raster to terra, some functions are not drop in
replacements, such as <code>minValue</code> and <code>maxValue</code> became <code>terra::minmax</code>. This
helper allows one function to be used, which calls the correct max or min
function, depending on whether the object is a <code>Raster</code> or <code>SpatRaster</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minFn(x)

maxFn(x)

dataType2(x, ...)

nlayers2(x)

values2(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minFn_+3A_x">x</code></td>
<td>
<p>A <code>Raster</code> or <code>SpatRaster</code> object.</p>
</td></tr>
<tr><td><code id="minFn_+3A_...">...</code></td>
<td>
<p>Passed to the functions in <code>raster</code> or <code>terra</code>, as needed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector (not matrix as in <code>terra::minmax</code>) with the minimum or maximum
value on the <code>Raster</code> or <code>SpatRaster</code>, one value per layer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("terra", quietly = TRUE)) {
  ras &lt;- terra::rast(terra::ext(0, 10, 0, 10), vals = 1:100)
  maxFn(ras)
  minFn(ras)
}
</code></pre>

<hr>
<h2 id='movedCache'>Deal with moved cache issues</h2><span id='topic+movedCache'></span>

<h3>Description</h3>

<p>If a user manually copies a complete Cache folder (including the db file and rasters folder),
there are issues that must be addressed, depending on the Cache backend used.
If using DBI (e.g., RSQLite or Postgres), the db table must be renamed. Run
this function after a manual copy of a cache folder. See examples for one way to do that.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>movedCache(
  new,
  old,
  drv = getDrv(getOption("reproducible.drv", NULL)),
  conn = getOption("reproducible.conn", NULL),
  verbose = getOption("reproducible.verbose")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="movedCache_+3A_new">new</code></td>
<td>
<p>Either the path of the new <code>cachePath</code> where the cache was moved or copied to, or
the new DB Table Name</p>
</td></tr>
<tr><td><code id="movedCache_+3A_old">old</code></td>
<td>
<p>Optional, if there is only one table in the <code>new</code> cache path.
Either the path of the previous <code>cachePath</code> where the cache was moved or copied from, or
the old DB Table Name</p>
</td></tr>
<tr><td><code id="movedCache_+3A_drv">drv</code></td>
<td>
<p>if using a database backend, drv must be an object that
inherits from DBIDriver e.g., from package RSQLite, e.g., SQLite</p>
</td></tr>
<tr><td><code id="movedCache_+3A_conn">conn</code></td>
<td>
<p>an optional DBIConnection object, as returned by dbConnect().</p>
</td></tr>
<tr><td><code id="movedCache_+3A_verbose">verbose</code></td>
<td>
<p>Numeric, -1 silent (where possible), 0 being very quiet,
1 showing more messaging, 2 being more messaging, etc.
Default is 1. Above 3 will output much more information about the internals of
Caching, which may help diagnose Caching challenges. Can set globally with an
option, e.g., <code style="white-space: pre;">&#8288;options('reproducible.verbose' = 0) to reduce to minimal&#8288;</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>When the backend database for a <code>reproducinle</code> cache is an SQL database, the files
on disk cannot be copied manually to a new location because they contain internal
tables. Because <code>reproducible</code> gives the main table a name based on the <code>cachePath</code>
path, calls to <code>Cache</code> will attempt to call this internally if it detects a
name mismatch.
</p>


<h3>Value</h3>

<p><code>movedCache</code> does not return anything; it is called for its side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(2)
tmpdir &lt;- "tmpdir"
tmpCache &lt;- "tmpCache"
tmpCacheDir &lt;- normalizePath(file.path(tempdir(), tmpCache), mustWork = FALSE)
tmpdirPath &lt;- normalizePath(file.path(tempdir(), tmpdir), mustWork = FALSE)
bb &lt;- Cache(rnorm, 1, cachePath = tmpCacheDir)

# Copy all files from tmpCache to tmpdir
froms &lt;- normalizePath(dir(tmpCacheDir, recursive = TRUE, full.names = TRUE),
  mustWork = FALSE
)
dir.create(file.path(tmpdirPath, "rasters"), recursive = TRUE, showWarnings = FALSE)
dir.create(file.path(tmpdirPath, "cacheOutputs"), recursive = TRUE, showWarnings = FALSE)
file.copy(
  from = froms, overwrite = TRUE,
  to = gsub(tmpCache, tmpdir, froms)
)

# Can use 'movedCache' to update the database table, though will generally
#   happen automatically, with message indicating so
movedCache(new = tmpdirPath, old = tmpCacheDir)
bb &lt;- Cache(rnorm, 1, cachePath = tmpdirPath) # should recover the previous call

</code></pre>

<hr>
<h2 id='normPath'>Normalize file paths</h2><span id='topic+normPath'></span><span id='topic+normPath+2Ccharacter-method'></span><span id='topic+normPath+2Clist-method'></span><span id='topic+normPath+2CNULL-method'></span><span id='topic+normPath+2Cmissing-method'></span><span id='topic+normPath+2Clogical-method'></span><span id='topic+normPathRel'></span>

<h3>Description</h3>

<p>Checks the specified path for formatting consistencies:
</p>

<ol>
<li><p> use slash instead of backslash;
</p>
</li>
<li><p> do tilde etc. expansion;
</p>
</li>
<li><p> remove trailing slash.
</p>
</li></ol>



<h3>Usage</h3>

<pre><code class='language-R'>normPath(path)

## S4 method for signature 'character'
normPath(path)

## S4 method for signature 'list'
normPath(path)

## S4 method for signature 'NULL'
normPath(path)

## S4 method for signature 'missing'
normPath()

## S4 method for signature 'logical'
normPath(path)

normPathRel(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normPath_+3A_path">path</code></td>
<td>
<p>A character vector of filepaths.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Additionally, <code>normPath()</code> attempts to create a absolute paths,
whereas <code>normPathRel()</code> maintains relative paths.
</p>
<div class="sourceCode"><pre>d&gt; getwd()
[1] "/home/achubaty/Documents/GitHub/PredictiveEcology/reproducible"
d&gt; normPathRel("potato/chips")
[1] "potato/chips"
d&gt; normPath("potato/chips")
[1] "/home/achubaty/Documents/GitHub/PredictiveEcology/reproducible/potato/chips"
</pre></div>


<h3>Value</h3>

<p>Character vector of cleaned up filepaths.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## normalize file paths
paths &lt;- list("./aaa/zzz",
              "./aaa/zzz/",
              ".//aaa//zzz",
              ".//aaa//zzz/",
              ".\\\\aaa\\\\zzz",
              ".\\\\aaa\\\\zzz\\\\",
              file.path(".", "aaa", "zzz"))

checked &lt;- normPath(paths)
length(unique(checked)) ## 1; all of the above are equivalent

## check to see if a path exists
tmpdir &lt;- file.path(tempdir(), "example_checkPath")

dir.exists(tmpdir) ## FALSE
tryCatch(checkPath(tmpdir, create = FALSE), error = function(e) FALSE) ## FALSE

checkPath(tmpdir, create = TRUE)
dir.exists(tmpdir) ## TRUE

unlink(tmpdir, recursive = TRUE)
</code></pre>

<hr>
<h2 id='objSize'>Wrapper around <code>lobstr::obj_size</code></h2><span id='topic+objSize'></span><span id='topic+objSizeSession'></span>

<h3>Description</h3>

<p>This function attempts to estimate the real object size of an object. If the object
has pass-by-reference semantics, it may not estimate the object size well without
a specific method developed. For the case of <code>terra</code> class objects, this will
be accurate (both RAM and file size), but only if it is not passed inside
a list or environment. To get an accurate size of these, they should be passed
individually.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>objSize(x, quick = FALSE, ...)

objSizeSession(sumLevel = Inf, enclosingEnvs = TRUE, .prevEnvirs = list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="objSize_+3A_x">x</code></td>
<td>
<p>An object</p>
</td></tr>
<tr><td><code id="objSize_+3A_quick">quick</code></td>
<td>
<p>Logical. If <code>FALSE</code>, then an attribute, &quot;objSize&quot; will be added to
the returned value, with each of the elements' object size returned also.</p>
</td></tr>
<tr><td><code id="objSize_+3A_...">...</code></td>
<td>
<p>Additional arguments (currently unused), enables backwards compatible use.</p>
</td></tr>
<tr><td><code id="objSize_+3A_sumlevel">sumLevel</code></td>
<td>
<p>Numeric, indicating at which depth in the list of objects should the
object sizes be summed (summarized). Default is <code>Inf</code>, meaning no sums. Currently,
the only option other than Inf is 1: <code>objSizeSession(1)</code>,
which gives the size of each package.</p>
</td></tr>
<tr><td><code id="objSize_+3A_enclosingenvs">enclosingEnvs</code></td>
<td>
<p>Logical indicating whether to include enclosing environments.
Default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="objSize_+3A_.prevenvirs">.prevEnvirs</code></td>
<td>
<p>For internal account keeping to identify and prevent duplicate counting</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For functions, a user can include the enclosing environment as described
<a href="https://www.r-bloggers.com/2015/03/using-closures-as-objects-in-r/">https://www.r-bloggers.com/2015/03/using-closures-as-objects-in-r/</a> and
<a href="http://adv-r.had.co.nz/memory.html">http://adv-r.had.co.nz/memory.html</a>.
It is not entirely clear which estimate is better.
However, if the enclosing environment is the <code>.GlobalEnv</code>, it will
not be included even though <code>enclosingEnvs = TRUE</code>.
</p>
<p><code>objSizeSession</code> will give the size of the whole session, including loaded packages.
Because of the difficulties in calculating the object size of <code>base</code>
and <code>methods</code> packages and <code>Autoloads</code>, these are omitted.
</p>


<h3>Value</h3>

<p>This will return the result from <code>lobstr::obj_size</code>, i.e., a <code>lobstr_bytes</code>
which is a <code>numeric</code>. If <code>quick = FALSE</code>, it will also have an attribute,
&quot;objSize&quot;, which will
be a list with each element being the <code>objSize</code> of the individual elements of <code>x</code>.
This is particularly useful if <code>x</code> is a <code>list</code> or <code>environment</code>.
However, because of the potential for shared memory, the sum of the individual
elements will generally not equal the value returned from this function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(utils)

foo &lt;- new.env()
foo$b &lt;- 1:10
foo$d &lt;- 1:10

objSize(foo) # all the elements in the environment
utils::object.size(foo) # different - only measuring the environment as an object

utils::object.size(prepInputs) # only the function, without its enclosing environment
objSize(prepInputs) # the function, plus its enclosing environment

os1 &lt;- utils::object.size(as.environment("package:reproducible"))
(os1) # very small -- just the environment container

</code></pre>

<hr>
<h2 id='paddedFloatToChar'>Convert numeric to character with padding</h2><span id='topic+paddedFloatToChar'></span>

<h3>Description</h3>

<p>This will pad floating point numbers, right or left. For integers, either class
integer or functionally integer (e.g., 1.0), it will not pad right of the decimal.
For more specific control or to get exact padding right and left of decimal,
try the <code>stringi</code> package. It will also not do any rounding. See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paddedFloatToChar(x, padL = ceiling(log10(x + 1)), padR = 3, pad = "0")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paddedFloatToChar_+3A_x">x</code></td>
<td>
<p>numeric. Number to be converted to character with padding</p>
</td></tr>
<tr><td><code id="paddedFloatToChar_+3A_padl">padL</code></td>
<td>
<p>numeric. Desired number of digits on left side of decimal.
If not enough, <code>pad</code> will be used to pad.</p>
</td></tr>
<tr><td><code id="paddedFloatToChar_+3A_padr">padR</code></td>
<td>
<p>numeric. Desired number of digits on right side of decimal.
If not enough, <code>pad</code> will be used to pad.</p>
</td></tr>
<tr><td><code id="paddedFloatToChar_+3A_pad">pad</code></td>
<td>
<p>character to use as padding (<code>nchar(pad) == 1</code> must be <code>TRUE</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character string representing the filename.
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire and Alex Chubaty
</p>


<h3>Examples</h3>

<pre><code class='language-R'>paddedFloatToChar(1.25)
paddedFloatToChar(1.25, padL = 3, padR = 5)
paddedFloatToChar(1.25, padL = 3, padR = 1) # no rounding, so keeps 2 right of decimal
</code></pre>

<hr>
<h2 id='Path-class'>Coerce a character string to a class &quot;Path&quot;</h2><span id='topic+Path-class'></span><span id='topic+asPath'></span><span id='topic+asPath.character'></span><span id='topic+asPath.null'></span>

<h3>Description</h3>

<p>Allows a user to specify that their character string is indeed a filepath.
Thus, methods that require only a filepath can be dispatched correctly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asPath(obj, nParentDirs = 0)

## S3 method for class 'character'
asPath(obj, nParentDirs = 0)

## S3 method for class 'null'
asPath(obj, nParentDirs = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Path-class_+3A_obj">obj</code></td>
<td>
<p>A character string to convert to a <code>Path</code>.</p>
</td></tr>
<tr><td><code id="Path-class_+3A_nparentdirs">nParentDirs</code></td>
<td>
<p>A numeric indicating the number of parent directories starting
from basename(obj) = 0 to keep for the digest</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is often difficult or impossible to know algorithmically whether a
character string corresponds to a valid filepath.
In the case where it is en existing file, <code>file.exists</code> can work.
But if it does not yet exist, e.g., for a <code>save</code>, it is difficult to know
whether it is a valid path before attempting to save to the path.
</p>
<p>This function can be used to remove any ambiguity about whether a character
string is a path. It is primarily useful for achieving repeatability with Caching.
Essentially, when Caching, arguments that are character strings should generally be
digested verbatim, i.e., it must be an exact copy for the Cache mechanism
to detect a candidate for recovery from the cache.
Paths, are different. While they are character strings, there are many ways to
write the same path. Examples of identical meaning, but different character strings are:
path expanding of <code>~</code> vs. not, double back slash vs. single forward slash,
relative path vs. absolute path.
All of these should be assessed for their actual file or directory location,
NOT their character string. By converting all character string that are actual
file or directory paths with this function, then <code>Cache</code> will correctly assess
the location, NOT the character string representation.
</p>


<h3>Value</h3>

<p>A vector of class <code>Path</code>, which is similar to a character, but
has an attribute indicating how deep the Path should be
considered &quot;digestible&quot;. In other words, most of the time, only some
component of an absolute path is relevant for evaluating its purpose in
a Cache situation. In general, this is usually equivalent to just the &quot;relative&quot; path
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tmpf &lt;- tempfile(fileext = ".csv")
file.exists(tmpf) ## FALSE
tmpfPath &lt;- asPath(tmpf)
is(tmpf, "Path") ## FALSE
is(tmpfPath, "Path") ## TRUE

</code></pre>

<hr>
<h2 id='postProcess'>Generic function to post process objects</h2><span id='topic+postProcess'></span><span id='topic+postProcess.list'></span><span id='topic+postProcess.default'></span>

<h3>Description</h3>

<p><img src="../help/figures/lifecycle-maturing.svg" alt="maturing" />
</p>
<p>The method for GIS objects (terra <code style="white-space: pre;">&#8288;Spat*&#8288;</code> &amp; sf classes) will
crop, reproject, and mask, in that order.
This is a wrapper for <code><a href="#topic+cropTo">cropTo()</a></code>, <code><a href="#topic+fixErrorsIn">fixErrorsIn()</a></code>,
<code><a href="#topic+projectTo">projectTo()</a></code>, <code><a href="#topic+maskTo">maskTo()</a></code> and <code><a href="#topic+writeTo">writeTo()</a></code>,
with a required amount of data manipulation between these calls so that the crs match.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>postProcess(x, ...)

## S3 method for class 'list'
postProcess(x, ...)

## Default S3 method:
postProcess(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="postProcess_+3A_x">x</code></td>
<td>
<p>A GIS object of postProcessing,
e.g., Spat* or sf*. This can be provided as a
<code>rlang::quosure</code> or a normal R object.</p>
</td></tr>
<tr><td><code id="postProcess_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to methods. For <code>spatialClasses</code>,
these are: <code><a href="#topic+cropTo">cropTo()</a></code>, <code><a href="#topic+fixErrorsIn">fixErrorsIn()</a></code>,
<code><a href="#topic+projectTo">projectTo()</a></code>, <code><a href="#topic+maskTo">maskTo()</a></code>,
<code><a href="#topic+determineFilename">determineFilename()</a></code>, and <code><a href="#topic+writeTo">writeTo()</a></code>.
Each of these may also pass <code>...</code> into other functions, like
<code><a href="#topic+writeTo">writeTo()</a></code>.
This might include potentially important arguments like <code>datatype</code>,
<code>format</code>. Also passed to <code>terra::project</code>,
with likely important arguments such as <code>method = "bilinear"</code>.
See details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A GIS file (e.g., <code>RasterLayer</code>, <code>SpatRaster</code> etc.) that has been
appropriately cropped, reprojected, masked, depending on the inputs.
</p>


<h3>Post processing sequence</h3>

<p>If the <code>rasterToMatch</code> or <code>studyArea</code> are passed, then
the following sequence will occur:
</p>

<ol>
<li><p> Fix errors <code><a href="#topic+fixErrorsIn">fixErrorsIn()</a></code>. Currently only errors fixed are for
<code>SpatialPolygons</code> using <code>buffer(..., width = 0)</code>.
</p>
</li>
<li><p> Crop using <code><a href="#topic+cropTo">cropTo()</a></code>
</p>
</li>
<li><p> Project using <code><a href="#topic+projectTo">projectTo()</a></code>
</p>
</li>
<li><p> Mask using <code><a href="#topic+maskTo">maskTo()</a></code>
</p>
</li>
<li><p> Determine file name <code><a href="#topic+determineFilename">determineFilename()</a></code>
</p>
</li>
<li><p> Write that file name to disk, optionally <code><a href="#topic+writeTo">writeTo()</a></code>
</p>
</li></ol>

<p>NOTE: checksumming does not occur during the post-processing stage, as
there are no file downloads. To achieve fast results, wrap
<code>prepInputs</code> with <code>Cache</code>
</p>


<h3>Backwards compatibility with <code>rasterToMatch</code> and/or <code>studyArea</code> arguments</h3>

<p>For backwards compatibility, <code>postProcess</code> will continue to allow passing
<code>rasterToMatch</code> and/or <code>studyArea</code> arguments. Depending on which of these
are passed, different things will happen to the <code>targetFile</code> located at <code>filename1</code>.
</p>
<p>See <em>Use cases</em> section in <code><a href="#topic+postProcessTo">postProcessTo()</a></code> for post processing behaviour with
the new <code>from</code> and <code>to</code> arguments.
</p>


<h4>If <code>targetFile</code> is a raster (<code style="white-space: pre;">&#8288;Raster*&#8288;</code>, or <code>SpatRaster</code>) object:</h4>


<table>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: center;"> <code>rasterToMatch</code>      </td><td style="text-align: center;"> <code>studyArea</code>  </td><td style="text-align: center;">  Both               </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>extent</code>     </td><td style="text-align: center;"> Yes                  </td><td style="text-align: center;">   Yes        </td><td style="text-align: center;"> <code>rasterToMatch</code>     </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>resolution</code> </td><td style="text-align: center;"> Yes                  </td><td style="text-align: center;">   No         </td><td style="text-align: center;"> <code>rasterToMatch</code>     </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>projection</code> </td><td style="text-align: center;"> Yes                  </td><td style="text-align: center;">   No*        </td><td style="text-align: center;"> <code>rasterToMatch</code>*    </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>alignment</code>  </td><td style="text-align: center;"> Yes                  </td><td style="text-align: center;">   No         </td><td style="text-align: center;"> <code>rasterToMatch</code>     </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>mask</code>       </td><td style="text-align: center;"> No**                 </td><td style="text-align: center;">   Yes        </td><td style="text-align: center;"> <code>studyArea</code>**       </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>*Can be overridden with <code>useSAcrs</code>.
</p>
<p>**Will mask with <code>NA</code>s from <code>rasterToMatch</code> if <code>maskWithRTM</code>.
</p>



<h4>If <code>targetFile</code> is a vector (<code style="white-space: pre;">&#8288;Spatial*&#8288;</code>, <code>sf</code> or <code>SpatVector</code>) object:</h4>


<table>
<tr>
 <td style="text-align: left;">
</td><td style="text-align: center;"> <code>rasterToMatch</code>      </td><td style="text-align: center;"> <code>studyArea</code>  </td><td style="text-align: center;"> Both               </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>extent</code>     </td><td style="text-align: center;"> Yes                  </td><td style="text-align: center;">   Yes        </td><td style="text-align: center;"> <code>rasterToMatch</code>    </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>resolution</code> </td><td style="text-align: center;"> NA                   </td><td style="text-align: center;">   NA         </td><td style="text-align: center;"> NA                 </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>projection</code> </td><td style="text-align: center;"> Yes                  </td><td style="text-align: center;">   No*        </td><td style="text-align: center;"> <code>rasterToMatch</code>*   </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>alignment</code>  </td><td style="text-align: center;"> NA                   </td><td style="text-align: center;">   NA         </td><td style="text-align: center;"> NA                 </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>mask</code>       </td><td style="text-align: center;"> No                   </td><td style="text-align: center;">   Yes        </td><td style="text-align: center;"> <code>studyArea</code>        </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>*Can be overridden with <code>useSAcrs</code>
</p>



<h3>See Also</h3>

<p><code>prepInputs</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (requireNamespace("terra", quietly = TRUE) &amp;&amp; requireNamespace("sf", quietly = TRUE)) {
  library(reproducible)
  od &lt;- setwd(tempdir2())
  # download a (spatial) file from remote url (which often is an archive) load into R
  # need 3 files for this example; 1 from remote, 2 local
  dPath &lt;- file.path(tempdir2())
  remoteTifUrl &lt;- "https://github.com/rspatial/terra/raw/master/inst/ex/elev.tif"

  localFileLuxSm &lt;- system.file("ex/luxSmall.shp", package = "reproducible")
  localFileLux &lt;- system.file("ex/lux.shp", package = "terra")

  # 1 step for each layer
  # 1st step -- get study area
  studyArea &lt;- prepInputs(localFileLuxSm, fun = "terra::vect") # default is sf::st_read

  # 2nd step: make the input data layer like the studyArea map
  # Test only relevant if connected to internet -- so using try just in case
  elevForStudy &lt;- try(prepInputs(url = remoteTifUrl, to = studyArea, res = 250,
                             destinationPath = dPath))

  # Alternate way, one step at a time. Must know each of these steps, and perform for each layer
  
    dir.create(dPath, recursive = TRUE, showWarnings = FALSE)
    file.copy(localFileLuxSm, file.path(dPath, basename(localFileLuxSm)))
    studyArea2 &lt;- terra::vect(localFileLuxSm)
    if (!all(terra::is.valid(studyArea2))) studyArea2 &lt;- terra::makeValid(studyArea2)
    tf &lt;- tempfile(fileext = ".tif")
    download.file(url = remoteTifUrl, destfile = tf, mode = "wb")
    Checksums(dPath, write = TRUE, files = tf)
    elevOrig &lt;- terra::rast(tf)
    elevForStudy2 &lt;- terra::project(elevOrig, terra::crs(studyArea2), res = 250) |&gt;
      terra::crop(studyArea2) |&gt;
      terra::mask(studyArea2)

    isTRUE(all.equal(studyArea, studyArea2)) # Yes!
  

  # sf class
  studyAreaSmall &lt;- prepInputs(localFileLuxSm)
  studyAreas &lt;- list()
  studyAreas[["orig"]] &lt;- prepInputs(localFileLux)
  studyAreas[["reprojected"]] &lt;- projectTo(studyAreas[["orig"]], studyAreaSmall)
  studyAreas[["cropped"]] &lt;- suppressWarnings(cropTo(studyAreas[["orig"]], studyAreaSmall))
  studyAreas[["masked"]] &lt;- suppressWarnings(maskTo(studyAreas[["orig"]], studyAreaSmall))

  # SpatVector-- note: doesn't matter what class the "to" object is, only the "from"
  studyAreas &lt;- list()
  studyAreas[["orig"]] &lt;- prepInputs(localFileLux, fun = "terra::vect")
  studyAreas[["reprojected"]] &lt;- projectTo(studyAreas[["orig"]], studyAreaSmall)
  studyAreas[["cropped"]] &lt;- suppressWarnings(cropTo(studyAreas[["orig"]], studyAreaSmall))
  studyAreas[["masked"]] &lt;- suppressWarnings(maskTo(studyAreas[["orig"]], studyAreaSmall))
  if (interactive()) {
    par(mfrow = c(2,2));
    out &lt;- lapply(studyAreas, function(x) terra::plot(x))
  }

  setwd(od)
}
</code></pre>

<hr>
<h2 id='postProcessTo'>Transform a GIS dataset so it has the properties (extent, projection, mask) of another</h2><span id='topic+postProcessTo'></span><span id='topic+postProcessTerra'></span><span id='topic+maskTo'></span><span id='topic+projectTo'></span><span id='topic+cropTo'></span><span id='topic+writeTo'></span>

<h3>Description</h3>

<p>This function provides a single step to achieve the GIS operations
&quot;pre-crop-with-buffer-to-speed-up-projection&quot;, &quot;project&quot;,
&quot;post-projection-crop&quot;, &quot;mask&quot; and possibly &quot;write&quot;.
It uses primarily the <code>terra</code> package internally
(with some minor functions from <code>sf</code>)
in an attempt to be as efficient as possible. Currently, this function is tested
with <code>sf</code>, <code>SpatVector</code>, <code>SpatRaster</code>, <code style="white-space: pre;">&#8288;Raster*&#8288;</code> and <code style="white-space: pre;">&#8288;Spatial*&#8288;</code> objects passed
to <code>from</code>, and the same plus <code>SpatExtent</code>, and <code>crs</code> passed to <code>to</code> or the
relevant <code style="white-space: pre;">&#8288;*to&#8288;</code> functions.
For this function, Gridded means a <code style="white-space: pre;">&#8288;Raster*&#8288;</code> class object from <code>raster</code> or
a <code>SpatRaster</code> class object from <code>terra</code>.
Vector means a <code style="white-space: pre;">&#8288;Spatial*&#8288;</code> class object from <code>sp</code>, a <code>sf</code> class object
from <code>sf</code>, or a <code>SpatVector</code> class object from <code>terra</code>.
This function is also used internally with the deprecated family <code><a href="#topic+postProcess">postProcess()</a></code>,
<code style="white-space: pre;">&#8288;*Inputs&#8288;</code>, such as <code><a href="#topic+cropInputs">cropInputs()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>postProcessTo(
  from,
  to,
  cropTo = NULL,
  projectTo = NULL,
  maskTo = NULL,
  writeTo = NULL,
  overwrite = TRUE,
  verbose = getOption("reproducible.verbose"),
  ...
)

postProcessTerra(
  from,
  to,
  cropTo = NULL,
  projectTo = NULL,
  maskTo = NULL,
  writeTo = NULL,
  overwrite = TRUE,
  verbose = getOption("reproducible.verbose"),
  ...
)

maskTo(
  from,
  maskTo,
  overwrite = FALSE,
  verbose = getOption("reproducible.verbose"),
  ...
)

projectTo(
  from,
  projectTo,
  overwrite = FALSE,
  verbose = getOption("reproducible.verbose"),
  ...
)

cropTo(
  from,
  cropTo = NULL,
  needBuffer = FALSE,
  overwrite = FALSE,
  verbose = getOption("reproducible.verbose"),
  ...
)

writeTo(
  from,
  writeTo,
  overwrite = getOption("reproducible.overwrite"),
  isStack = NULL,
  isBrick = NULL,
  isRaster = NULL,
  isSpatRaster = NULL,
  verbose = getOption("reproducible.verbose"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="postProcessTo_+3A_from">from</code></td>
<td>
<p>A Gridded or Vector dataset on which to do one or more of:
crop, project, mask, and write</p>
</td></tr>
<tr><td><code id="postProcessTo_+3A_to">to</code></td>
<td>
<p>A Gridded or Vector dataset which is the object
whose metadata will be the target for cropping, projecting, and masking of <code>from</code>.</p>
</td></tr>
<tr><td><code id="postProcessTo_+3A_cropto">cropTo</code></td>
<td>
<p>Optional Gridded or Vector dataset which,
if supplied, will supply the extent with which to crop <code>from</code>. To omit
cropping completely, set this to <code>NA</code>. If supplied, this will override <code>to</code>
for the cropping step. Defaults to <code>NULL</code>, which means use <code>to</code></p>
</td></tr>
<tr><td><code id="postProcessTo_+3A_projectto">projectTo</code></td>
<td>
<p>Optional Gridded or Vector dataset, or <code>crs</code> object (e.g., sf::st_crs).
If Gridded it will supply
the <code>crs</code>, <code>extent</code>, <code>res</code>, and <code>origin</code>
to project the <code>from</code> to. If Vector, it will provide the <code>crs</code> only.
The resolution and extent will be taken from <code>res(from)</code> (i.e. <code>ncol(from)*nrow(from)</code>).
If a Vector, the extent of the <code>projectTo</code> is not used (unless it is also passed to <code>cropTo</code>.
To omit projecting, set this to <code>NA</code>.
If supplied, this will override <code>to</code> for the projecting step.
Defaults to <code>NULL</code>, which means use <code>to</code>.
<strong>Attention.</strong> Conflicts may arise with when <code>projectTo</code> is a Vector/CRS object with a
distinct CRS from <code>to</code>. Because <code>to</code> is used for masking <em>after</em> <code>from</code> is re-projected using
<code>projectTo</code>, the extents of <code>to</code> and <code>from</code> may no longer overlap (as in <em>align</em>)
perfectly leading to failure during
the masking step. We  recommend passing a raster templates to <code>projectTo</code> whose extent and CRS
are both compatible with the object used later for masking (either <code>to</code> or <code>maskTo</code>).</p>
</td></tr>
<tr><td><code id="postProcessTo_+3A_maskto">maskTo</code></td>
<td>
<p>Optional Gridded or Vector dataset which,
if supplied, will supply the extent with which to mask <code>from</code>.
If Gridded, it will mask with the <code>NA</code> values on the <code>maskTo</code>;
if Vector, it will mask on the <code>terra::aggregate(maskTo)</code>.
To omit masking completely, set this to <code>NA</code>.
If supplied, this will override <code>to</code> for the masking step.
Defaults to <code>NULL</code>, which means use <code>to</code></p>
</td></tr>
<tr><td><code id="postProcessTo_+3A_writeto">writeTo</code></td>
<td>
<p>Optional character string of a filename to use <code>writeRaster</code> to save the final
object. Default is <code>NULL</code>, which means there is no <code>writeRaster</code></p>
</td></tr>
<tr><td><code id="postProcessTo_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical. Used if <code>writeTo</code> is not <code>NULL</code>; also if <code>terra</code> determines
that the object requires writing to disk during a <code>crop</code>, <code>mask</code> or <code>project</code> call
e.g., because it is too large.</p>
</td></tr>
<tr><td><code id="postProcessTo_+3A_verbose">verbose</code></td>
<td>
<p>Numeric, -1 silent (where possible), 0 being very quiet,
1 showing more messaging, 2 being more messaging, etc.
Default is 1. Above 3 will output much more information about the internals of
Caching, which may help diagnose Caching challenges. Can set globally with an
option, e.g., <code style="white-space: pre;">&#8288;options('reproducible.verbose' = 0) to reduce to minimal&#8288;</code></p>
</td></tr>
<tr><td><code id="postProcessTo_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code>terra::mask</code> (for <code>maskTo</code>), <code>terra::project</code> (for <code>projectTo</code>)
or <code>terra::writeRaster</code> (for <code>writeTo</code>) and not used for <code>cropTo</code>, as well <code>postProcess</code>'s
<code>rasterToMatch</code> and <code>studyArea</code> arguments (see below). Commonly used arguments might be
<code>method</code>, <code>touches</code>, and <code>datatype</code>. If <code>filename</code> is passed, it will be ignored; use
<code style="white-space: pre;">&#8288;writeTo = &#8288;</code>. If <code>reproducible.gdalwarp = TRUE</code>, then these will be passed to the
<code style="white-space: pre;">&#8288;gdal*&#8288;</code> functions. See them for details.</p>
</td></tr>
<tr><td><code id="postProcessTo_+3A_needbuffer">needBuffer</code></td>
<td>
<p>Logical. Defaults to <code>FALSE</code>, meaning nothing is done out
of the ordinary. If <code>TRUE</code>, then a buffer around the cropTo, so that if a reprojection
has to happen on the <code>cropTo</code> prior to using it as a crop layer, then a buffer
of 1.5 * res(cropTo) will occur prior, so that no edges are cut off.</p>
</td></tr>
<tr><td><code id="postProcessTo_+3A_isstack">isStack</code>, <code id="postProcessTo_+3A_isbrick">isBrick</code>, <code id="postProcessTo_+3A_israster">isRaster</code>, <code id="postProcessTo_+3A_isspatraster">isSpatRaster</code></td>
<td>
<p>Logical. Default <code>NULL</code>. Used to convert <code>from</code>
back to these classes prior to writing, if provided.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>postProcessTo</code> is a wrapper around (an initial &quot;wide&quot; crop for speed)
<code>cropTo(needBuffer = TRUE)</code>, <code>projectTo</code>,
<code>cropTo</code> (the actual crop for precision), <code>maskTo</code>, <code>writeTo</code>.
Users can call each of these individually.
</p>
<p><code>postProcessTerra</code> is the early name of this function that is now <code>postProcessTo</code>.
</p>
<p>This function is meant to replace <code><a href="#topic+postProcess">postProcess()</a></code> with the more efficient
and faster <code>terra</code> functions.
</p>


<h3>Value</h3>

<p>An object of the same class as <code>from</code>, but potentially cropped (via <code><a href="#topic+cropTo">cropTo()</a></code>),
projected (via <code><a href="#topic+projectTo">projectTo()</a></code>), masked (via <code><a href="#topic+maskTo">maskTo()</a></code>), and written to disk
(via <code><a href="#topic+writeTo">writeTo()</a></code>).
</p>


<h3>Use Cases</h3>

<p>The table below shows what will result from passing different classes to <code>from</code>
and <code>to</code>:
</p>

<table>
<tr>
 <td style="text-align: left;">
<strong><code>from</code></strong></td><td style="text-align: left;"> <strong><code>to</code></strong>   </td><td style="text-align: left;"> <strong><code>from</code></strong> will have:                             </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>Gridded</code> </td><td style="text-align: left;"> <code>Gridded</code>  </td><td style="text-align: left;"> the extent, projection, origin, resolution
and masking where there are <code>NA</code> from the <code>to</code>    </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>Gridded</code> </td><td style="text-align: left;"> <code>Vector</code>   </td><td style="text-align: left;"> the projection, origin, and mask from <code>to</code>, and
extent will be a round number of pixels that
fit within the extent of <code>to</code>. Resolution will
be the same as <code>from</code>.  See section
below about <code>projectTo</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
<code>Vector</code> </td><td style="text-align: left;"> <code>Vector</code>    </td><td style="text-align: left;"> the projection, origin, extent and mask from <code>to</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>If one or more of the <code style="white-space: pre;">&#8288;*To&#8288;</code> arguments are supplied, these will
override individual components of <code>to</code>. If <code>to</code> is omitted or <code>NULL</code>,
then only the <code style="white-space: pre;">&#8288;*To&#8288;</code> arguments that are used will be performed. In all cases,
setting a <code style="white-space: pre;">&#8288;*To&#8288;</code> argument to <code>NA</code> will prevent that step from happening.
</p>


<h3><code>projectTo</code></h3>

<p>Since these functions use the gis capabilities of <code>sf</code> and <code>terra</code>, they will only
be able to do things that those functions can do. One key caution, which is
stated clearly in <code>?terra::project</code> is that projection of a raster (i.e., gridded)
object should always be with another gridded object. If the user chooses to
supply a <code>projectTo</code> that is a vector object for a <code>from</code> that is gridded,
there may be unexpected failures due e.g., to extents not overlapping during
the <code>maskTo</code> stage.
</p>


<h3>Backwards compatibility with <code>postProcess</code></h3>



<h4><code>rasterToMatch</code> and <code>studyArea</code>:</h4>

<p>If these are supplied, <code>postProcessTo</code> will use them instead
of <code>to</code>. If only <code>rasterToMatch</code> is supplied, it will be assigned to
<code>to</code>. If only <code>studyArea</code> is supplied, it will be used for <code>cropTo</code>
and <code>maskTo</code>; it will only be used for <code>projectTo</code> if <code>useSAcrs = TRUE</code>.
If both <code>rasterToMatch</code> and <code>studyArea</code> are supplied,
<code>studyArea</code> will only be applied to <code>maskTo</code> (unless <code>maskWithRTM = TRUE</code>),
and, optionally, to <code>projectTo</code> (if <code>useSAcrs = TRUE</code>); everything else
will be from <code>rasterToMatch</code>.
</p>



<h4><code>targetCRS</code>, <code>filename2</code>, <code>useSAcrs</code>, <code>maskWithRTM</code>:</h4>

<p><code>targetCRS</code> if supplied will be assigned to <code>projectTo</code>. <code>filename2</code> will
be assigned to <code>writeTo</code>. If <code>useSAcrs</code> is set, then the <code>studyArea</code>
will be assigned to <code>projectTo</code>. If <code>maskWithRTM</code> is used, then the
<code>rasterToMath</code> will be assigned to <code>maskTo</code>. All of these will override
any existing values for these arguments.
</p>

<p>See also <code><a href="#topic+postProcess">postProcess()</a></code> documentation section on
<em>Backwards compatibility with <code>rasterToMatch</code> and/or <code>studyArea</code></em> for further
detail.
</p>


<h3>Cropping</h3>

<p>If <code>cropTo</code> is not <code>NA</code>, <code>postProcessTo</code> does cropping twice, both the first and last steps.
It does it first for speed, as cropping is a very fast algorithm. This will quickly remove
a bunch of pixels that are not necessary. But, to not create bias, this first crop is padded
by  <code>2 * res(from)[1]</code>), so that edge cells still have a complete set of neighbours.
The second crop is at the end, after projecting and masking. After the projection step,
the crop is no longer tight. Under some conditions, masking will effectively mask and crop in
one step, but under some conditions, this is not true, and the mask leaves padded NAs out to
the extent of the <code>from</code> (as it is after crop, project, mask). Thus the second
crop removes all NA cells so they are tight to the mask.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+maskTo">maskTo()</a></code>, <code><a href="#topic+cropTo">cropTo()</a></code>, <code><a href="#topic+projectTo">projectTo()</a></code>, <code><a href="#topic+writeTo">writeTo()</a></code>, and <code><a href="#topic+fixErrorsIn">fixErrorsIn()</a></code>.
Also the functions that
call <code>sf::gdal_utils(...)</code> directly: <code><a href="#topic+gdalProject">gdalProject()</a></code>, <code><a href="#topic+gdalResample">gdalResample()</a></code>, <code><a href="#topic+gdalMask">gdalMask()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># prepare dummy data -- 3 SpatRasters, 2 SpatVectors
# need 2 SpatRaster
rf &lt;- system.file("ex/elev.tif", package = "terra")
elev1 &lt;- terra::rast(rf)
#'
ras2 &lt;- terra::deepcopy(elev1)
ras2[ras2 &gt; 200 &amp; ras2 &lt; 300] &lt;- NA_integer_
terra::values(elev1) &lt;- rep(1L, terra::ncell(ras2))
#'
# a polygon vector
f &lt;- system.file("ex/lux.shp", package = "terra")
vOrig &lt;- terra::vect(f)
v &lt;- vOrig[1:2, ]
#'
utm &lt;- terra::crs("epsg:23028") # $wkt
vInUTM &lt;- terra::project(vOrig, utm)
vAsRasInLongLat &lt;- terra::rast(vOrig, resolution = 0.008333333)
res100 &lt;- 100
rInUTM &lt;- terra::rast(vInUTM, resolution = res100)
# crop, reproject, mask, crop a raster with a vector in a different projection
#  --&gt; gives message about not enough information
t1 &lt;- postProcessTo(elev1, to = vInUTM)
# crop, reproject, mask a raster to a different projection, then mask
t2a &lt;- postProcessTo(elev1, to = vAsRasInLongLat, maskTo = vInUTM)


# using gdal directly --&gt; slightly different mask
opts &lt;- options(reproducible.gdalwarp = TRUE)
t2b &lt;- postProcessTo(elev1, to = vAsRasInLongLat, maskTo = vInUTM)
t3b &lt;- postProcessTo(elev1, to = rInUTM, maskTo = vInUTM)
options(opts)
</code></pre>

<hr>
<h2 id='prepInputs'>Download and optionally post-process files</h2><span id='topic+prepInputs'></span>

<h3>Description</h3>

<p><img src="../help/figures/lifecycle-maturing.svg" alt="maturing" />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepInputs(
  targetFile = NULL,
  url = NULL,
  archive = NULL,
  alsoExtract = NULL,
  destinationPath = getOption("reproducible.destinationPath", "."),
  fun = NULL,
  quick = getOption("reproducible.quick"),
  overwrite = getOption("reproducible.overwrite", FALSE),
  purge = FALSE,
  useCache = getOption("reproducible.useCache", 2),
  .tempPath,
  verbose = getOption("reproducible.verbose", 1),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepInputs_+3A_targetfile">targetFile</code></td>
<td>
<p>Character string giving the filename (without relative or
absolute path) to the eventual file
(raster, shapefile, csv, etc.) after downloading and extracting from a zip
or tar archive. This is the file <em>before</em> it is passed to
<code>postProcess</code>. The internal checksumming does not checksum
the file after it is <code>postProcess</code>ed (e.g., cropped/reprojected/masked).
Using <code>Cache</code> around <code>prepInputs</code> will do a sufficient job in these cases.
See table in <code><a href="#topic+preProcess">preProcess()</a></code>.</p>
</td></tr>
<tr><td><code id="prepInputs_+3A_url">url</code></td>
<td>
<p>Optional character string indicating the URL to download from.
If not specified, then no download will be attempted. If not entry
exists in the <code>CHECKSUMS.txt</code> (in <code>destinationPath</code>), an entry
will be created or appended to. This <code>CHECKSUMS.txt</code> entry will be used
in subsequent calls to
<code>prepInputs</code> or <code>preProcess</code>, comparing the file on hand with the ad hoc
<code>CHECKSUMS.txt</code>. See table in <code><a href="#topic+preProcess">preProcess()</a></code>.</p>
</td></tr>
<tr><td><code id="prepInputs_+3A_archive">archive</code></td>
<td>
<p>Optional character string giving the path of an archive
containing <code>targetFile</code>, or a vector giving a set of nested archives
(e.g., <code>c("xxx.tar", "inner.zip", "inner.rar")</code>). If there is/are (an) inner
archive(s), but they are unknown, the function will try all until it finds
the <code>targetFile</code>. See table in <code><a href="#topic+preProcess">preProcess()</a></code>. If it is <code>NA</code>,
then it will <em>not</em> attempt to see it as an archive, even if it has archive-like
file extension (e.g., <code>.zip</code>). This may be useful when an R function
is expecting an archive directly.</p>
</td></tr>
<tr><td><code id="prepInputs_+3A_alsoextract">alsoExtract</code></td>
<td>
<p>Optional character string naming files other than
<code>targetFile</code> that must be extracted from the <code>archive</code>. If
<code>NULL</code>, the default, then it will extract all files. Other options:
<code>"similar"</code> will extract all files with the same filename without
file extension as <code>targetFile</code>. <code>NA</code> will extract nothing other
than <code>targetFile</code>. A character string of specific file names will cause
only those to be extracted. See table in <code><a href="#topic+preProcess">preProcess()</a></code>.</p>
</td></tr>
<tr><td><code id="prepInputs_+3A_destinationpath">destinationPath</code></td>
<td>
<p>Character string of a directory in which to download
and save the file that comes from <code>url</code> and is also where the function
will look for <code>archive</code> or <code>targetFile</code>. NOTE (still experimental):
To prevent repeated downloads in different locations, the user can also set
<code>options("reproducible.inputPaths")</code> to one or more local file paths to
search for the file before attempting to download. Default for that option is
<code>NULL</code> meaning do not search locally.</p>
</td></tr>
<tr><td><code id="prepInputs_+3A_fun">fun</code></td>
<td>
<p>Optional. If specified, this will attempt to load whatever
file was downloaded during <code>preProcess</code> via <code>dlFun</code>. This can be either a
function (e.g., sf::st_read), character string (e.g., &quot;base::load&quot;),
NA (for no loading, useful if <code>dlFun</code> already loaded the file) or
if extra arguments are required
in the function call, it must be a call naming
<code>targetFile</code> (e.g., <code>sf::st_read(targetFile, quiet = TRUE)</code>)
as the file path to the file to load. See details and examples below.</p>
</td></tr>
<tr><td><code id="prepInputs_+3A_quick">quick</code></td>
<td>
<p>Logical. This is passed internally to <code><a href="#topic+Checksums">Checksums()</a></code>
(the quickCheck argument), and to
<code><a href="#topic+Cache">Cache()</a></code> (the quick argument). This results in faster, though
less robust checking of inputs. See the respective functions.</p>
</td></tr>
<tr><td><code id="prepInputs_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical. Should downloading and all the other actions occur
even if they pass the checksums or the files are all there.</p>
</td></tr>
<tr><td><code id="prepInputs_+3A_purge">purge</code></td>
<td>
<p>Logical or Integer. <code>0/FALSE</code> (default) keeps existing
<code>CHECKSUMS.txt</code> file and
<code>prepInputs</code> will write or append to it. <code>1/TRUE</code> will deleted the entire
<code>CHECKSUMS.txt</code> file. Other options, see details.</p>
</td></tr>
<tr><td><code id="prepInputs_+3A_usecache">useCache</code></td>
<td>
<p>Passed to <code>Cache</code> in various places.
Defaults to <code>getOption("reproducible.useCache", 2L)</code> in <code>prepInputs</code>, and
<code>getOption("reproducible.useCache", FALSE)</code> if calling any of the inner
functions manually. For <code>prepInputs</code>, this mean it will use <code>Cache</code>
only up to 2 nested levels, which includes <code>preProcess</code>. <code>postProcess</code> and
its nested <code style="white-space: pre;">&#8288;*Input&#8288;</code> functions (e.g., <code>cropInputs</code>, <code>projectInputs</code>,
<code>maskInputs</code>) are no longer internally cached, as <code>terra</code> processing speeds
mean internal caching is more time consuming. We recommend caching the full
<code>prepInputs</code> call instead (e.g. <code>prepInputs(...) |&gt; Cache()</code>).</p>
</td></tr>
<tr><td><code id="prepInputs_+3A_.temppath">.tempPath</code></td>
<td>
<p>Optional temporary path for internal file intermediate steps.
Will be cleared on.exit from this function.</p>
</td></tr>
<tr><td><code id="prepInputs_+3A_verbose">verbose</code></td>
<td>
<p>Numeric, -1 silent (where possible), 0 being very quiet,
1 showing more messaging, 2 being more messaging, etc.
Default is 1. Above 3 will output much more information about the internals of
Caching, which may help diagnose Caching challenges. Can set globally with an
option, e.g., <code style="white-space: pre;">&#8288;options('reproducible.verbose' = 0) to reduce to minimal&#8288;</code></p>
</td></tr>
<tr><td><code id="prepInputs_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to
<code><a href="#topic+postProcess">postProcess()</a></code> and <code><a href="#topic+Cache">Cache()</a></code>.
Since <code>...</code> is passed to <code><a href="#topic+postProcess">postProcess()</a></code>, these will
<code>...</code> will also be passed into the inner
functions, e.g., <code><a href="#topic+cropInputs">cropInputs()</a></code>. Possibly useful other arguments include
<code>dlFun</code> which is passed to <code>preProcess</code>. See details and examples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to prepare R objects from remote or local data sources.
The object of this function is to provide a reproducible version of
a series of commonly used steps for getting, loading, and processing data.
This function has two stages: Getting data (download, extracting from archives,
loading into R) and post-processing (for <code style="white-space: pre;">&#8288;Spatial*&#8288;</code> and <code style="white-space: pre;">&#8288;Raster*&#8288;</code>
objects, this is crop, reproject, mask/intersect).
To trigger the first stage, provide <code>url</code> or <code>archive</code>.
To trigger the second stage, provide <code>studyArea</code> or <code>rasterToMatch</code>.
See examples.
</p>


<h3>Value</h3>

<p>This is an omnibus function that will return an R object that will have resulted from
the running of <code><a href="#topic+preProcess">preProcess()</a></code> and <code><a href="#topic+postProcess">postProcess()</a></code> or <code><a href="#topic+postProcessTo">postProcessTo()</a></code>. Thus,
if it is a GIS object, it may have been cropped, reprojected, &quot;fixed&quot;, masked, and
written to disk.
</p>


<h3>Stage 1 - Getting data</h3>

<p>See <code><a href="#topic+preProcess">preProcess()</a></code> for combinations of arguments.
</p>

<ol>
<li><p> Download from the web via either <code>googledrive::drive_download()</code>,
<code><a href="utils.html#topic+download.file">utils::download.file()</a></code>;
</p>
</li>
<li><p> Extract from archive using <code><a href="utils.html#topic+unzip">unzip()</a></code> or <code><a href="utils.html#topic+untar">untar()</a></code>;
</p>
</li>
<li><p> Load into R using <code>terra::rast</code>,
<code>sf::st_read</code>, or any other function passed in with <code>fun</code>;
</p>
</li>
<li><p> Checksumming of all files during this process. This is put into a
&lsquo;<span class="file">CHECKSUMS.txt</span>&rsquo; file in the <code>destinationPath</code>, appending if it is
already there, overwriting the entries for same files if entries already exist.
</p>
</li></ol>



<h3>Stage 2 - Post processing</h3>

<p>This will be triggered if either <code>rasterToMatch</code> or <code>studyArea</code>
is supplied.
</p>

<ol>
<li><p> Fix errors. Currently only errors fixed are for <code>SpatialPolygons</code>
using <code>buffer(..., width = 0)</code>;
</p>
</li>
<li><p> Crop using <code><a href="#topic+cropTo">cropTo()</a></code>;
</p>
</li>
<li><p> Project using <code><a href="#topic+projectTo">projectTo()</a></code>;
</p>
</li>
<li><p> Mask using <code><a href="#topic+maskTo">maskTo()</a></code>;
</p>
</li>
<li><p> Determine file name <code><a href="#topic+determineFilename">determineFilename()</a></code> via <code>filename2</code>;
</p>
</li>
<li><p> Optionally, write that file name to disk via <code><a href="#topic+writeTo">writeTo()</a></code>.
</p>
</li></ol>

<p>NOTE: checksumming does not occur during the post-processing stage, as
there are no file downloads. To achieve fast results, wrap
<code>prepInputs</code> with <code>Cache</code>.
</p>
<p>NOTE: <code>sf</code> objects are still very experimental.
</p>


<h4>postProcessing of <code style="white-space: pre;">&#8288;Spat*&#8288;</code>, <code>sf</code>, <code style="white-space: pre;">&#8288;Raster*&#8288;</code> and <code style="white-space: pre;">&#8288;Spatial*&#8288;</code> objects:</h4>

<p>The following has been DEPRECATED because there are a sufficient number of
ambiguities that this has been changed in favour of <code>from</code> and the <code style="white-space: pre;">&#8288;*to&#8288;</code> family.
See <code><a href="#topic+postProcessTo">postProcessTo()</a></code>.
</p>
<p>DEPRECATED: If <code>rasterToMatch</code> or <code>studyArea</code> are used, then this will
trigger several subsequent functions, specifically the sequence,
<em>Crop, reproject, mask</em>, which appears to be a common sequence while
preparing spatial data from diverse sources.
See <code><a href="#topic+postProcess">postProcess()</a></code> documentation section on
<em>Backwards compatibility with <code>rasterToMatch</code> and/or <code>studyArea</code> arguments</em>
to understand various combinations of <code>rasterToMatch</code> and/or <code>studyArea</code>.
</p>



<h3><code>fun</code></h3>

<p><code>fun</code> offers the ability to pass any custom function with which to load
the file obtained by <code>preProcess</code> into the session. There are two cases that are
dealt with: when the <code>preProcess</code> downloads a file (including via <code>dlFun</code>),
<code>fun</code> must deal with a file; and, when <code>preProcess</code> creates an R object
(e.g., raster::getData returns an object), <code>fun</code> must deal with an object.
</p>
<p><code>fun</code> can be supplied in three ways: a function, a character string
(i.e., a function name as a string), or an expression.
If a character string or function, is should have the package name e.g.,
<code>"terra::rast"</code> or as an actual function, e.g., <code>base::readRDS</code>.
In these cases, it will evaluate this function call while passing <code>targetFile</code>
as the first argument. These will only work in the simplest of cases.
</p>
<p>When more precision is required, the full call can be written and where the
filename can be referred to as <code>targetFile</code> if the function
is loading a file. If <code>preProcess</code> returns an object, <code>fun</code> should be set to
<code>fun = NA</code>.
</p>
<p>If there is a custom function call, is not in a package, <code>prepInputs</code> may not find it. In such
cases, simply pass the function as a named argument (with same name as function) to <code>prepInputs</code>.
See examples.
NOTE: passing <code>fun = NA</code> will skip loading object into R. Note this will essentially
replicate the functionality of simply calling <code>preProcess</code> directly.
</p>


<h3><code>purge</code></h3>

<p>In options for control of purging the <code>CHECKSUMS.txt</code> file are:
</p>

<dl>
<dt><code>0</code></dt><dd><p>keep file</p>
</dd>
<dt><code>1</code></dt><dd><p>delete file in <code>destinationPath</code>, all records of downloads need to be rebuilt</p>
</dd>
<dt><code>2</code></dt><dd><p>delete entry with same <code>targetFile</code></p>
</dd>
<dt><code>4</code></dt><dd><p>delete entry with same <code>alsoExtract</code></p>
</dd>
<dt><code>3</code></dt><dd><p>delete entry with same <code>archive</code></p>
</dd>
<dt><code>5</code></dt><dd><p>delete entry with same <code>targetFile</code> &amp; <code>alsoExtract</code></p>
</dd>
<dt><code>6</code></dt><dd><p>delete entry with same <code>targetFile</code>, <code>alsoExtract</code> &amp; <code>archive</code></p>
</dd>
<dt><code>7</code></dt><dd><p>delete entry that same <code>targetFile</code>, <code>alsoExtract</code> &amp; <code>archive</code> &amp; <code>url</code></p>
</dd>
</dl>

<p>will only remove entries in the <code>CHECKSUMS.txt</code> that are associated with
<code>targetFile</code>, <code>alsoExtract</code> or <code>archive</code> When <code>prepInputs</code> is called,
it will write or append to a (if already exists) <code>CHECKSUMS.txt</code> file.
If the <code>CHECKSUMS.txt</code> is not correct, use this argument to remove it.
</p>


<h3>Note</h3>

<p>This function is still experimental: use with caution.
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire, Jean Marchal, and Tati Micheletti
</p>


<h3>See Also</h3>

<p><code><a href="#topic+postProcessTo">postProcessTo()</a></code>, <code><a href="#topic+downloadFile">downloadFile()</a></code>, <code><a href="#topic+extractFromArchive">extractFromArchive()</a></code>,
<code><a href="#topic+postProcess">postProcess()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (requireNamespace("terra", quietly = TRUE) &amp;&amp;
  requireNamespace("sf", quietly = TRUE)) {
  library(reproducible)
  # Make a dummy study area map -- user would supply this normally
  coords &lt;- structure(c(-122.9, -116.1, -99.2, -106, -122.9, 59.9, 65.7, 63.6, 54.8, 59.9),
    .Dim = c(5L, 2L)
  )
  studyArea &lt;- terra::vect(coords, "polygons")
  terra::crs(studyArea) &lt;- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
  # Make dummy "large" map that must be cropped to the study area
  outerSA &lt;- terra::buffer(studyArea, 50000)
  terra::crs(outerSA) &lt;- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"
  tf &lt;- normPath(file.path(tempdir2("prepInputsEx"), "prepInputs2.shp"))
  terra::writeVector(outerSA, tf, overwrite = TRUE)

  # run prepInputs -- load file, postProcess it to the studyArea

  studyArea2 &lt;- prepInputs(
    targetFile = tf, to = studyArea,
    fun = "terra::vect",
    destinationPath = tempdir2()
  ) |&gt;
    suppressWarnings() # not relevant warning here

  # clean up
  unlink("CHECKSUMS.txt")

  ##########################################
  # Remote file using `url`
  ##########################################
  if (internetExists()) {
    data.table::setDTthreads(2)
    origDir &lt;- getwd()
    # download a zip file from internet, unzip all files, load as shapefile, Cache the call
    # First time: don't know all files - prepInputs will guess, if download file is an archive,
    #   then extract all files, then if there is a .shp, it will load with sf::st_read
    dPath &lt;- file.path(tempdir(), "ecozones")
    shpUrl &lt;- "http://sis.agr.gc.ca/cansis/nsdb/ecostrat/zone/ecozone_shp.zip"

    # Wrapped in a try because this particular url can be flaky
    shpEcozone &lt;- try(prepInputs(
      destinationPath = dPath,
      url = shpUrl
    ))
    if (!is(shpEcozone, "try-error")) {
      # Robust to partial file deletions:
      unlink(dir(dPath, full.names = TRUE)[1:3])
      shpEcozone &lt;- prepInputs(
        destinationPath = dPath,
        url = shpUrl
      )
      unlink(dPath, recursive = TRUE)

      # Once this is done, can be more precise in operational code:
      #  specify targetFile, alsoExtract, and fun, wrap with Cache
      ecozoneFilename &lt;- file.path(dPath, "ecozones.shp")
      ecozoneFiles &lt;- c(
        "ecozones.dbf", "ecozones.prj",
        "ecozones.sbn", "ecozones.sbx", "ecozones.shp", "ecozones.shx"
      )
      shpEcozone &lt;- prepInputs(
        targetFile = ecozoneFilename,
        url = shpUrl,
        fun = "terra::vect",
        alsoExtract = ecozoneFiles,
        destinationPath = dPath
      )
      unlink(dPath, recursive = TRUE)

      # Add a study area to Crop and Mask to
      # Create a "study area"
      coords &lt;- structure(c(-122.98, -116.1, -99.2, -106, -122.98, 59.9, 65.73, 63.58, 54.79, 59.9),
        .Dim = c(5L, 2L)
      )
      studyArea &lt;- terra::vect(coords, "polygons")
      terra::crs(studyArea) &lt;- "+proj=longlat +datum=WGS84 +no_defs +ellps=WGS84 +towgs84=0,0,0"

      #  specify targetFile, alsoExtract, and fun, wrap with Cache
      ecozoneFilename &lt;- file.path(dPath, "ecozones.shp")
      # Note, you don't need to "alsoExtract" the archive... if the archive is not there, but the
      #   targetFile is there, it will not redownload the archive.
      ecozoneFiles &lt;- c(
        "ecozones.dbf", "ecozones.prj",
        "ecozones.sbn", "ecozones.sbx", "ecozones.shp", "ecozones.shx"
      )
      shpEcozoneSm &lt;- Cache(prepInputs,
        url = shpUrl,
        targetFile = reproducible::asPath(ecozoneFilename),
        alsoExtract = reproducible::asPath(ecozoneFiles),
        studyArea = studyArea,
        fun = "terra::vect",
        destinationPath = dPath,
        filename2 = "EcozoneFile.shp"
      ) # passed to determineFilename

      terra::plot(shpEcozone[, 1])
      terra::plot(shpEcozoneSm[, 1], add = TRUE, col = "red")
      unlink(dPath)
    }
  }
}


## Using quoted dlFun and fun -- this is not intended to be run but used as a template
## prepInputs(..., fun = customFun(x = targetFile), customFun = customFun)
##   # or more complex
##  test5 &lt;- prepInputs(
##   targetFile = targetFileLuxRDS,
##   dlFun =
##     getDataFn(name = "GADM", country = "LUX", level = 0) # preProcess keeps file from this!
##   ,
##   fun = {
##     out &lt;- readRDS(targetFile)
##     sf::st_as_sf(out)}
##  )
</code></pre>

<hr>
<h2 id='preProcessParams'>Download, Checksum, Extract files</h2><span id='topic+preProcessParams'></span><span id='topic+preProcess'></span>

<h3>Description</h3>

<p>This does downloading (via <code>downloadFile</code>), checksumming (<code>Checksums</code>),
and extracting from archives (<code>extractFromArchive</code>), plus cleaning up of input
arguments (e.g., paths, function names).
This is the first stage of three used in <code>prepInputs</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preProcessParams(n = NULL)

preProcess(
  targetFile = NULL,
  url = NULL,
  archive = NULL,
  alsoExtract = NULL,
  destinationPath = getOption("reproducible.destinationPath", "."),
  fun = NULL,
  dlFun = NULL,
  quick = getOption("reproducible.quick"),
  overwrite = getOption("reproducible.overwrite", FALSE),
  purge = FALSE,
  verbose = getOption("reproducible.verbose", 1),
  .tempPath,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preProcessParams_+3A_n">n</code></td>
<td>
<p>Number of non-null arguments passed to <code>preProcess</code>.
E.g., passing <code>n = 1</code> returns combinations with only a single non-NULL parameter.
If <code>NULL</code> (default), all parameter combinations are returned.</p>
</td></tr>
<tr><td><code id="preProcessParams_+3A_targetfile">targetFile</code></td>
<td>
<p>Character string giving the filename (without relative or
absolute path) to the eventual file
(raster, shapefile, csv, etc.) after downloading and extracting from a zip
or tar archive. This is the file <em>before</em> it is passed to
<code>postProcess</code>. The internal checksumming does not checksum
the file after it is <code>postProcess</code>ed (e.g., cropped/reprojected/masked).
Using <code>Cache</code> around <code>prepInputs</code> will do a sufficient job in these cases.
See table in <code><a href="#topic+preProcess">preProcess()</a></code>.</p>
</td></tr>
<tr><td><code id="preProcessParams_+3A_url">url</code></td>
<td>
<p>Optional character string indicating the URL to download from.
If not specified, then no download will be attempted. If not entry
exists in the <code>CHECKSUMS.txt</code> (in <code>destinationPath</code>), an entry
will be created or appended to. This <code>CHECKSUMS.txt</code> entry will be used
in subsequent calls to
<code>prepInputs</code> or <code>preProcess</code>, comparing the file on hand with the ad hoc
<code>CHECKSUMS.txt</code>. See table in <code><a href="#topic+preProcess">preProcess()</a></code>.</p>
</td></tr>
<tr><td><code id="preProcessParams_+3A_archive">archive</code></td>
<td>
<p>Optional character string giving the path of an archive
containing <code>targetFile</code>, or a vector giving a set of nested archives
(e.g., <code>c("xxx.tar", "inner.zip", "inner.rar")</code>). If there is/are (an) inner
archive(s), but they are unknown, the function will try all until it finds
the <code>targetFile</code>. See table in <code><a href="#topic+preProcess">preProcess()</a></code>. If it is <code>NA</code>,
then it will <em>not</em> attempt to see it as an archive, even if it has archive-like
file extension (e.g., <code>.zip</code>). This may be useful when an R function
is expecting an archive directly.</p>
</td></tr>
<tr><td><code id="preProcessParams_+3A_alsoextract">alsoExtract</code></td>
<td>
<p>Optional character string naming files other than
<code>targetFile</code> that must be extracted from the <code>archive</code>. If
<code>NULL</code>, the default, then it will extract all files. Other options:
<code>"similar"</code> will extract all files with the same filename without
file extension as <code>targetFile</code>. <code>NA</code> will extract nothing other
than <code>targetFile</code>. A character string of specific file names will cause
only those to be extracted. See table in <code><a href="#topic+preProcess">preProcess()</a></code>.</p>
</td></tr>
<tr><td><code id="preProcessParams_+3A_destinationpath">destinationPath</code></td>
<td>
<p>Character string of a directory in which to download
and save the file that comes from <code>url</code> and is also where the function
will look for <code>archive</code> or <code>targetFile</code>. NOTE (still experimental):
To prevent repeated downloads in different locations, the user can also set
<code>options("reproducible.inputPaths")</code> to one or more local file paths to
search for the file before attempting to download. Default for that option is
<code>NULL</code> meaning do not search locally.</p>
</td></tr>
<tr><td><code id="preProcessParams_+3A_fun">fun</code></td>
<td>
<p>Optional. If specified, this will attempt to load whatever
file was downloaded during <code>preProcess</code> via <code>dlFun</code>. This can be either a
function (e.g., sf::st_read), character string (e.g., &quot;base::load&quot;),
NA (for no loading, useful if <code>dlFun</code> already loaded the file) or
if extra arguments are required
in the function call, it must be a call naming
<code>targetFile</code> (e.g., <code>sf::st_read(targetFile, quiet = TRUE)</code>)
as the file path to the file to load. See details and examples below.</p>
</td></tr>
<tr><td><code id="preProcessParams_+3A_dlfun">dlFun</code></td>
<td>
<p>Optional &quot;download function&quot; name, such as <code>"raster::getData"</code>, which does
custom downloading, in addition to loading into R. Still experimental.</p>
</td></tr>
<tr><td><code id="preProcessParams_+3A_quick">quick</code></td>
<td>
<p>Logical. This is passed internally to <code><a href="#topic+Checksums">Checksums()</a></code>
(the quickCheck argument), and to
<code><a href="#topic+Cache">Cache()</a></code> (the quick argument). This results in faster, though
less robust checking of inputs. See the respective functions.</p>
</td></tr>
<tr><td><code id="preProcessParams_+3A_overwrite">overwrite</code></td>
<td>
<p>Logical. Should downloading and all the other actions occur
even if they pass the checksums or the files are all there.</p>
</td></tr>
<tr><td><code id="preProcessParams_+3A_purge">purge</code></td>
<td>
<p>Logical or Integer. <code>0/FALSE</code> (default) keeps existing
<code>CHECKSUMS.txt</code> file and
<code>prepInputs</code> will write or append to it. <code>1/TRUE</code> will deleted the entire
<code>CHECKSUMS.txt</code> file. Other options, see details.</p>
</td></tr>
<tr><td><code id="preProcessParams_+3A_verbose">verbose</code></td>
<td>
<p>Numeric, -1 silent (where possible), 0 being very quiet,
1 showing more messaging, 2 being more messaging, etc.
Default is 1. Above 3 will output much more information about the internals of
Caching, which may help diagnose Caching challenges. Can set globally with an
option, e.g., <code style="white-space: pre;">&#8288;options('reproducible.verbose' = 0) to reduce to minimal&#8288;</code></p>
</td></tr>
<tr><td><code id="preProcessParams_+3A_.temppath">.tempPath</code></td>
<td>
<p>Optional temporary path for internal file intermediate steps.
Will be cleared on.exit from this function.</p>
</td></tr>
<tr><td><code id="preProcessParams_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to
<code><a href="#topic+postProcess">postProcess()</a></code> and <code><a href="#topic+Cache">Cache()</a></code>.
Since <code>...</code> is passed to <code><a href="#topic+postProcess">postProcess()</a></code>, these will
<code>...</code> will also be passed into the inner
functions, e.g., <code><a href="#topic+cropInputs">cropInputs()</a></code>. Possibly useful other arguments include
<code>dlFun</code> which is passed to <code>preProcess</code>. See details and examples.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with 5 elements: <code>checkSums</code> (the result of a <code>Checksums</code>
after downloading), <code>dots</code> (cleaned up <code>...</code>, including deprecated argument checks),
<code>fun</code> (the function to be used to load the <code>preProcess</code>ed object from disk),
and <code>targetFilePath</code> (the fully qualified path to the <code>targetFile</code>).
</p>


<h3>Combinations of <code>targetFile</code>, <code>url</code>, <code>archive</code>, <code>alsoExtract</code></h3>

<p>Use <code>preProcessParams()</code> for a table describing various parameter combinations and their
outcomes.
</p>
<p><code>*</code> If the <code>url</code> is a file on Google Drive, checksumming will work
even without a <code>targetFile</code> specified because there is an initial attempt
to get the remove file information (e.g., file name). With that, the connection
between the <code>url</code> and the filename used in the &lsquo;<span class="file">CHECKSUMS.txt</span>&rsquo; file can be made.
</p>


<h3>Author(s)</h3>

<p>Eliot McIntire
</p>

<hr>
<h2 id='rasterRead'>A helper to <code>getOption("reproducible.rasterRead")</code></h2><span id='topic+rasterRead'></span>

<h3>Description</h3>

<p>A helper to <code>getOption("reproducible.rasterRead")</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasterRead(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rasterRead_+3A_...">...</code></td>
<td>
<p>Passed to the function parsed and evaluated from
<code>getOption("reproducible.rasterRead")</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function, that will be the evaluated, parsed character
string, e.g., <code>eval(parse(text = "terra::rast"))</code>
</p>

<hr>
<h2 id='remapFilenames'>Remap file names</h2><span id='topic+remapFilenames'></span>

<h3>Description</h3>

<p>Update file path metadata for file-backed objects (e.g., <code>SpatRasters</code>).
Useful when moving saved objects between projects or machines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remapFilenames(obj, tags, cachePath, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remapFilenames_+3A_obj">obj</code></td>
<td>
<p>(optional) object whose file path metadata will be remapped</p>
</td></tr>
<tr><td><code id="remapFilenames_+3A_tags">tags</code></td>
<td>
<p>cache tags <code>data.table</code> object</p>
</td></tr>
<tr><td><code id="remapFilenames_+3A_cachepath">cachePath</code></td>
<td>
<p>character string specifying the path to the cache directory or <code>NULL</code></p>
</td></tr>
<tr><td><code id="remapFilenames_+3A_...">...</code></td>
<td>
<p>Additional path arguments, passed to <code>absoluteBase()</code> and <code>modifyListPaths()</code></p>
</td></tr>
</table>

<hr>
<h2 id='reproducibleOptions'><code>reproducible</code> options</h2><span id='topic+reproducibleOptions'></span>

<h3>Description</h3>

<p>These provide top-level, powerful settings for a comprehensive
reproducible workflow. To see defaults, run <code>reproducibleOptions()</code>.
See Details below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reproducibleOptions()
</code></pre>


<h3>Details</h3>

<p>Below are options that can be set with <code>options("reproducible.xxx" = newValue)</code>,
where <code>xxx</code> is one of the values below, and <code>newValue</code> is a new value to
give the option. Sometimes these options can be placed in the user's <code>.Rprofile</code>
file so they persist between sessions.
</p>
<p>The following options are likely of interest to most users:
</p>

<dl>
<dt><code>ask</code></dt><dd>
<p>Default: <code>TRUE</code>. Used in <code><a href="#topic+clearCache">clearCache()</a></code> and <code><a href="#topic+keepCache">keepCache()</a></code>.
</p>
</dd>
<dt><code>cachePath</code></dt><dd>
<p>Default: <code>.reproducibleTempCacheDir</code>. Used in <code><a href="#topic+Cache">Cache()</a></code> and many others.
The default path for repositories if not passed as an argument.
</p>
</dd>
<dt><code>cacheSaveFormat</code></dt><dd>
<p>Default: <code>"rds"</code>. What save format to use; currently, <code>"qs"</code> or <code>"rds"</code>.
</p>
</dd>
<dt><code>cacheSpeed</code></dt><dd>
<p>Default <code>"slow"</code>. One of <code>"slow"</code> or <code>"fast"</code> (1 or 2).
<code>"slow"</code> uses <code>digest::digest</code> internally, which is transferable across operating
systems, but much slower than <code style="white-space: pre;">&#8288;digest::digest(algo = "spooky)&#8288;</code>.
So, if all caching is happening on a single machine, <code>"fast"</code> would be a good setting.
</p>
</dd>
<dt><code>conn</code></dt><dd>
<p>Default: <code>NULL</code>. Sets a specific connection to a database, e.g.,
<code>dbConnect(drv = RSQLite::SQLite())</code> or <code style="white-space: pre;">&#8288;dbConnect(drv = RPostgres::Postgres()&#8288;</code>.
For remote database servers, setting one connection may be far faster than using
<code>drv</code> which must make a new connection every time.
</p>
</dd>
<dt><code>destinationPath</code></dt><dd>
<p>Default: <code>NULL</code>. Used in <code><a href="#topic+prepInputs">prepInputs()</a></code> and <code><a href="#topic+preProcess">preProcess()</a></code>.
Can be set globally here.
</p>
</dd>
<dt><code>drv</code></dt><dd>
<p>Default: <code>RSQLite::SQLite()</code>. Sets the default driver for the backend database system.
Only tested with <code>RSQLite::SQLite()</code> and <code>RPostgres::Postgres()</code>.
</p>
</dd>
<dt><code>futurePlan</code></dt><dd>
<p>Default: <code>FALSE</code>. On Linux OSes, <code>Cache</code> and <code>cloudCache</code> have some
functionality that uses the <code>future</code> package.
Default is to not use these, as they are experimental.
They may, however, be very effective in speeding up some things, specifically,
uploading cached elements via <code>googledrive</code> in <code>cloudCache</code>.
</p>
</dd>
<dt><code>gdalwarp</code></dt><dd>
<p>Default: <code>FALSE</code>. Experimental. During <code>postProcessTo</code> the standard approach
is to use <code>terra</code> functions directly, with several strategic uses of <code>sf</code>. However,
in the special case when <code>from</code> is a <code>SpatRaster</code> or <code>Raster</code>, <code>maskTo</code> is a
<code>SpatVector</code> or <code>SFC_POLYGON</code> and <code>projectTo</code> is a <code>SpatRaster</code> or <code>Raster</code>, setting
this option to <code>TRUE</code> will use <code>sf::gdal_utils("warp")</code>. In many test cases,
this is much faster than the <code>terra</code> sequence. The resulting <code>SpatRaster</code> is
not identical, but it is very similar.
</p>
</dd>
<dt><code>gdalwarpThreads</code></dt><dd>
<p>Default: <code>2</code>. This will set <code style="white-space: pre;">&#8288;-wo NUM_THREADS=&#8288;</code> to this number. Default is now <code>2</code>, meaning
<code>gdalwarp</code> will use 2 threads with <code>gdalProject</code>. To turn off threading, set to <code>0</code>, <code>1</code> or <code>NA</code>.
</p>
</dd>
<dt><code>inputPaths</code></dt><dd>
<p>Default: <code>NULL</code>. Used in <code><a href="#topic+prepInputs">prepInputs()</a></code> and <code><a href="#topic+preProcess">preProcess()</a></code>.
If set to a path, this will cause these functions to save their downloaded and preprocessed
file to this location, with a hardlink (via <code>file.link</code>) to the file created in the
<code>destinationPath</code>.
This can be used so that individual projects that use common data sets can maintain
modularity (by placing downloaded objects in their <code>destinationPath</code>, but also minimize
re-downloading the same (perhaps large) file over and over for each project.
Because the files are hardlinks, there is no extra space taken up by the apparently
duplicated files.
</p>
</dd>
<dt><code>inputPathsRecursive</code></dt><dd>
<p>Default: <code>FALSE</code>. Used in <code><a href="#topic+prepInputs">prepInputs()</a></code> and <code><a href="#topic+preProcess">preProcess()</a></code>.
Should the <code>reproducible.inputPaths</code> be searched recursively for existence of a file?
</p>
</dd>
<dt><code>memoisePersist</code></dt><dd>
<p>Default: <code>FALSE</code>. Used in <code><a href="#topic+Cache">Cache()</a></code>.
Should the memoised copy of the Cache objects persist even if <code>reproducible</code> reloads
e.g., via <code>devtools::load_all</code>? This is mostly useful for developers of
<code>reproducible</code>. If <code>TRUE</code>, a object named <code>paste0(".reproducibleMemoise_", cachePath)</code>
will be placed in the <code>.GlobalEnv</code>, i.e., one for each <code>cachePath</code>.
</p>
</dd>
<dt><code>nThreads</code></dt><dd>
<p>Default: <code>1</code>. The number of threads to use for reading/writing cache files.
</p>
</dd>
<dt><code>objSize</code></dt><dd>
<p>Default: <code>TRUE</code>. Logical. If <code>TRUE</code>, then object sizes will be included in
the cache database. Simplying calculating object size of large objects can
be time consuming, so setting this to <code>FALSE</code> will make caching up to 10%
faster, depending on the objects.
</p>
</dd>
<dt><code>overwrite</code></dt><dd>
<p>Default: <code>FALSE</code>. Used in <code><a href="#topic+prepInputs">prepInputs()</a></code>, <code><a href="#topic+preProcess">preProcess()</a></code>,
<code><a href="#topic+downloadFile">downloadFile()</a></code>, and <code><a href="#topic+postProcess">postProcess()</a></code>.
</p>
</dd>
<dt><code>quick</code></dt><dd>
<p>Default: <code>FALSE</code>. Used in <code><a href="#topic+Cache">Cache()</a></code>. This will cause <code>Cache</code> to use
<code>file.size(file)</code> instead of the <code>digest::digest(file)</code>.
Less robust to changes, but faster. <em>NOTE: this will only affect objects on disk</em>.
</p>
</dd>
<dt><code>rasterRead</code></dt><dd>
<p>Used during <code>prepInputs</code> when reading <code>.tif</code>, <code>.grd</code>, and <code>.asc</code> files.
Default: <code>terra::rast</code>. Can be <code>raster::raster</code> for backwards compatibility.
Can be set using environment variable <code>R_REPRODUCIBLE_RASTER_READ</code>.
</p>
</dd>
<dt><code>shapefileRead</code></dt><dd>
<p>Default <code>NULL</code>. Used during <code>prepInputs</code> when reading a <code>.shp</code> file.
If <code>NULL</code>, it will use <code>sf::st_read</code> if <code>sf</code> package is available; otherwise,
it will use <code>raster::shapefile</code>
</p>
</dd>
<dt><code>showSimilar</code></dt><dd>
<p>Default <code>FALSE</code>. Passed to <code>Cache</code>.
</p>
</dd>
<dt><code>timeout</code></dt><dd>
<p>Default <code>1200</code>. Used in <code>preProcess</code> when downloading occurs. If a user has <code>R.utils</code>
package installed, <code>R.utils::withTimeout(  , timeout = getOption("reproducible.timeout"))</code>
will be wrapped around the download so that it will timeout (and error) after this many
seconds.
</p>
</dd>
<dt><code>useCache</code></dt><dd>
<p>Default: <code>TRUE</code>. Used in <code><a href="#topic+Cache">Cache()</a></code>. If <code>FALSE</code>, then the entire
<code>Cache</code> machinery is skipped and the functions are run as if there was no Cache occurring.
Can also take 2 other values: <code>'overwrite'</code> and <code>'devMode'</code>.
<code>'overwrite'</code> will cause no recovery of objects from the cache repository, only new
ones will be created. If the hash is identical to a previous one, then this will overwrite
the previous one.
<code>'devMode'</code> will function as normally <code>Cache</code> except it will use the
<code>userTags</code> to determine if a previous function has been run. If the <code>userTags</code>
are identical, but the digest value is different, the old value will be deleted from the
cache repository and this new value will be added.
This addresses a common situation during the development stage: functions are changing
frequently, so any entry in the cache repository will be stale following changes to
functions, i.e., they will likely never be relevant again.
This will therefore keep the cache repository clean of stale objects.
If there is ambiguity in the <code>userTags</code>, i.e., they do not uniquely identify a single
entry in the <code>cachePath</code>, then this option will default back to the non-dev-mode
behaviour to avoid deleting objects.
This, therefore, is most useful if the user is using unique values for <code>userTags</code>.
</p>
</dd>
<dt><code>useCloud</code></dt><dd>
<p>Default <code>FALSE</code>. Passed to <code>Cache</code>.
</p>
</dd>
<dt><code>useDBI</code></dt><dd>
<p>Default: <code>TRUE</code> if <span class="pkg">DBI</span> is available.
Default value can be overridden by setting environment variable <code>R_REPRODUCIBLE_USE_DBI</code>.
As of version 0.3, the backend is now <span class="pkg">DBI</span> instead of <span class="pkg">archivist</span>.
</p>
</dd>
<dt><code>useGdown</code></dt><dd>
<p>Default: <code>FALSE</code>. If a user provides a Google Drive url to <code>preProcess</code>/<code>prepInputs</code>,
<code>reproducible</code> will use the <code>googledrive</code> package. This works reliably in most cases.
However, for large files on unstable internet connections, it will stall and
stop the download with no error. If a user is finding this behaviour, they can
install the <code>gdown</code> package, making sure it is available on the PATH. This call
to <code>gdown</code> will only work for files that do not need authentication. If authentication
is needed, <code>dlGoogle</code> will fall back to <code>googledrive::drive_download</code>, even
if this option is <code>TRUE</code>, with a message.
.
</p>
</dd>
<dt><code>useMemoise</code></dt><dd>
<p>Default: <code>FALSE</code>. Used in <code><a href="#topic+Cache">Cache()</a></code>. If <code>TRUE</code>, recovery of cached
elements from the <code>cachePath</code> will use <code>memoise::memoise</code>.
This means that the 2nd time running a function will be much faster than the first
in a session (which either will create a new cache entry to disk or read a cached
entry from disk).
<em>NOTE: memoised values are removed when the R session is restarted</em>.
<strong>This option will use more RAM</strong> and so may need to be turned off if RAM is limiting.
<code>clearCache</code> of any sort will cause all memoising to be 'forgotten' (<code>memoise::forget</code>).
</p>
</dd>
<dt><code>useNewDigestAlgorithm</code></dt><dd>
<p>Default: <code>1</code>. Option 1 is the version that has existed for sometime.
There is now an option <code>2</code> which is substantially faster.
It will, however, create Caches that are not compatible with previous ones.
Options <code>1</code> and <code>2</code> are not compatible with the earlier <code>0</code>.
<code>1</code> and <code>2</code> will make <code>Cache</code> less sensitive to minor but irrelevant changes
(like changing the order of arguments) and will work successfully across operating systems
(especially relevant for the new <code>cloudCache</code> function.
</p>
</dd>
<dt><code>useTerra</code></dt><dd>
<p>Default: <code>FALSE</code>. The GIS operations in postProcess, by default use primarily
the Raster package. The newer terra package does similar operations, but usually
faster. A user can now set this option to <code>TRUE</code> and <code>prepInputs</code>
and several components of <code>postProcess</code> will use <code>terra</code> internally.
</p>
</dd>
<dt><code>verbose</code></dt><dd>
<p>Default: <code>FALSE</code>. If set to <code>TRUE</code> then every <code>Cache</code> call will show a
summary of the objects being cached, their <code>object.size</code> and the time it took to digest
them and also the time it took to run the call and save the call to the cache repository or
load the cached copy from the repository.
This may help diagnosing some problems that may occur.
</p>
</dd>
</dl>



<h3>Value</h3>

<p>This function returns a list of all the options that the <code>reproducible</code> package
sets and uses. See below for details of each.
</p>


<h3>Advanced</h3>

<p>The following options are likely not needed by a user.
</p>

<dl>
<dt><code>cloudChecksumsFilename</code></dt><dd>
<p>Default: <code>file.path(dirname(.reproducibleTempCacheDir()), "checksums.rds")</code>.
Used as an experimental argument in <code><a href="#topic+Cache">Cache()</a></code>
</p>
</dd>
<dt><code>length</code></dt><dd>
<p>Default: <code>Inf</code>. Used in <code><a href="#topic+Cache">Cache()</a></code>, specifically to the internal
calls to <code><a href="#topic+CacheDigest">CacheDigest()</a></code>. This is passed to <code>digest::digest</code>.
Mostly this would be changed from default <code>Inf</code> if the digesting is taking too long.
Use this with caution, as some objects will have <em>many</em> <code>NA</code> values in their first
<em>many</em> elements
</p>
</dd>
<dt><code>useragent</code></dt><dd>
<p>Default: <code>"https://github.com/PredictiveEcology/reproducible"</code>.
User agent for downloads using this package.
</p>
</dd>
</dl>


<hr>
<h2 id='retry'>A wrapper around <code>try</code> that retries on failure</h2><span id='topic+retry'></span>

<h3>Description</h3>

<p>This is useful for functions that are &quot;flaky&quot;, such as <code>curl</code>, which may fail for unknown
reasons that do not persist.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>retry(
  expr,
  envir = parent.frame(),
  retries = 5,
  exponentialDecayBase = 1.3,
  silent = TRUE,
  exprBetween = NULL,
  messageFn = message
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="retry_+3A_expr">expr</code></td>
<td>
<p>An expression to run, i.e., <code>rnorm(1)</code>, similar to what is passed to <code>try</code></p>
</td></tr>
<tr><td><code id="retry_+3A_envir">envir</code></td>
<td>
<p>The environment in which to evaluate the quoted expression, default
to <code>parent.frame(1)</code></p>
</td></tr>
<tr><td><code id="retry_+3A_retries">retries</code></td>
<td>
<p>Numeric. The maximum number of retries.</p>
</td></tr>
<tr><td><code id="retry_+3A_exponentialdecaybase">exponentialDecayBase</code></td>
<td>
<p>Numeric &gt; 1.0. The delay between
successive retries will be <code>runif(1, min = 0, max = exponentialDecayBase ^ i - 1)</code>
where <code>i</code> is the retry number (i.e., follows <code>seq_len(retries)</code>)</p>
</td></tr>
<tr><td><code id="retry_+3A_silent">silent</code></td>
<td>
<p>Logical indicating whether to <code>try</code> silently.</p>
</td></tr>
<tr><td><code id="retry_+3A_exprbetween">exprBetween</code></td>
<td>
<p>Another expression that should be run after a failed attempt
of the <code>expr</code>. This should return a named list, where the names indicate the object names
to update in the main expr, and the return value is the new value. (previous versions allowed
a non-list return, but where the final line had to be an assignment operator,
specifying what object (that is used in <code>expr</code>) will be updated prior to running
the <code>expr</code> again. For backwards compatibility, this still works).</p>
</td></tr>
<tr><td><code id="retry_+3A_messagefn">messageFn</code></td>
<td>
<p>A function for messaging to console. Defaults to <code>message</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on <a href="https://github.com/jennybc/googlesheets/issues/219#issuecomment-195218525">https://github.com/jennybc/googlesheets/issues/219#issuecomment-195218525</a>.
</p>


<h3>Value</h3>

<p>As with <code>try</code>, so the successfully returned <code>return()</code> from the <code>expr</code> or a <code>try-error</code>.
</p>

<hr>
<h2 id='saveToCache'>Save an object to Cache</h2><span id='topic+saveToCache'></span>

<h3>Description</h3>

<p>This is not expected to be used by a user as it requires that the <code>cacheId</code> be
calculated in exactly the same as it calculated inside <code>Cache</code>
(which requires <code>match.call</code> to match arguments with their names, among other things).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveToCache(
  cachePath = getOption("reproducible.cachePath"),
  drv = getDrv(getOption("reproducible.drv", NULL)),
  conn = getOption("reproducible.conn", NULL),
  obj,
  userTags,
  cacheId,
  linkToCacheId = NULL,
  verbose = getOption("reproducible.verbose")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="saveToCache_+3A_cachepath">cachePath</code></td>
<td>
<p>A repository used for storing cached objects.
This is optional if <code>Cache</code> is used inside a SpaDES module.</p>
</td></tr>
<tr><td><code id="saveToCache_+3A_drv">drv</code></td>
<td>
<p>if using a database backend, drv must be an object that
inherits from DBIDriver e.g., from package RSQLite, e.g., SQLite</p>
</td></tr>
<tr><td><code id="saveToCache_+3A_conn">conn</code></td>
<td>
<p>an optional DBIConnection object, as returned by dbConnect().</p>
</td></tr>
<tr><td><code id="saveToCache_+3A_obj">obj</code></td>
<td>
<p>The R object to save to the cache</p>
</td></tr>
<tr><td><code id="saveToCache_+3A_usertags">userTags</code></td>
<td>
<p>A character vector with descriptions of the Cache function call. These
will be added to the Cache so that this entry in the Cache can be found using
<code>userTags</code> e.g., via <code><a href="#topic+showCache">showCache()</a></code>.</p>
</td></tr>
<tr><td><code id="saveToCache_+3A_cacheid">cacheId</code></td>
<td>
<p>The hash string representing the result of <code>.robustDigest</code></p>
</td></tr>
<tr><td><code id="saveToCache_+3A_linktocacheid">linkToCacheId</code></td>
<td>
<p>Optional. If a <code>cacheId</code> is provided here, then a <code>file.link</code>
will be made to the file with that <code>cacheId</code> name in the cache repo.
This is used when identical outputs exist in the cache. This will save disk space.</p>
</td></tr>
<tr><td><code id="saveToCache_+3A_verbose">verbose</code></td>
<td>
<p>Numeric, -1 silent (where possible), 0 being very quiet,
1 showing more messaging, 2 being more messaging, etc.
Default is 1. Above 3 will output much more information about the internals of
Caching, which may help diagnose Caching challenges. Can set globally with an
option, e.g., <code style="white-space: pre;">&#8288;options('reproducible.verbose' = 0) to reduce to minimal&#8288;</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>This is used for its side effects, namely, it will add the object to the cache and
cache database.
</p>

<hr>
<h2 id='searchFull'>Search up the full scope for functions</h2><span id='topic+searchFull'></span><span id='topic+searchFullEx'></span>

<h3>Description</h3>

<p>This is like <code>base::search</code> but when used inside a function, it will
show the full scope (see figure in the section <em>Binding environments</em>
on <a href="http://adv-r.had.co.nz/Environments.html">http://adv-r.had.co.nz/Environments.html</a>).
This full search path will be potentially much longer than
just <code>search()</code> (which always starts at <code>.GlobalEnv</code>).
</p>
<p><code>searchFullEx</code> shows an example function that is inside this package
whose only function is to show the Scope of a package function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>searchFull(env = parent.frame(), simplify = TRUE)

searchFullEx()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="searchFull_+3A_env">env</code></td>
<td>
<p>The environment to start searching at. Default is
calling environment, i.e., <code>parent.frame()</code></p>
</td></tr>
<tr><td><code id="searchFull_+3A_simplify">simplify</code></td>
<td>
<p>Logical. Should the output be simplified to character,
if possible (usually it is not possible because environments
don't always coerce correctly)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>searchFullEx</code> can be used to show an example of the use of <code>searchFull</code>.
</p>


<h3>Value</h3>

<p>A list of environments that is the actual search path, unlike <code>search()</code>
which only prints from <code>.GlobalEnv</code> up to <code>base</code> through user attached
packages.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+search">base::search()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>seeScope &lt;- function() {
  searchFull()
}
seeScope()
searchFull()
searchFullEx()
</code></pre>

<hr>
<h2 id='set.randomseed'>Set seed with a random value using Sys.time()</h2><span id='topic+set.randomseed'></span>

<h3>Description</h3>

<p>This will set a random seed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.randomseed(set.seed = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.randomseed_+3A_set.seed">set.seed</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the default, then the function will call
<code>set.seed</code> internally with the new random seed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses 6 decimal places of <code>Sys.time()</code>, i.e., microseconds. Due to
integer limits, it also truncates at 1000 seconds, so there is a possibility that
this will be non-unique after 1000 seconds (at the microsecond level). In
tests, this showed no duplicates after 1e7 draws in a loop, as expected.
</p>


<h3>Value</h3>

<p>This will return the new seed invisibly. However, this is also called for
its side effects, which is a new seed set using <code>set.seed</code>
</p>


<h3>Note</h3>

<p>This function does not appear to be as reliable on R &lt;= 4.1.3
</p>

<hr>
<h2 id='showCache'>Examining and modifying the cache</h2><span id='topic+showCache'></span><span id='topic+clearCache'></span><span id='topic+clearCache+2CANY-method'></span><span id='topic+cc'></span><span id='topic+showCache+2CANY-method'></span><span id='topic+keepCache'></span><span id='topic+keepCache+2CANY-method'></span>

<h3>Description</h3>

<p>These are convenience wrappers around <code>DBI</code> package functions.
They allow the user a bit of control over what is being cached.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clearCache(
  x,
  userTags = character(),
  after = NULL,
  before = NULL,
  fun = NULL,
  cacheId = NULL,
  ask = getOption("reproducible.ask"),
  useCloud = FALSE,
  cloudFolderID = getOption("reproducible.cloudFolderID", NULL),
  drv = getDrv(getOption("reproducible.drv", NULL)),
  conn = getOption("reproducible.conn", NULL),
  verbose = getOption("reproducible.verbose"),
  ...
)

## S4 method for signature 'ANY'
clearCache(
  x,
  userTags = character(),
  after = NULL,
  before = NULL,
  fun = NULL,
  cacheId = NULL,
  ask = getOption("reproducible.ask"),
  useCloud = FALSE,
  cloudFolderID = getOption("reproducible.cloudFolderID", NULL),
  drv = getDrv(getOption("reproducible.drv", NULL)),
  conn = getOption("reproducible.conn", NULL),
  verbose = getOption("reproducible.verbose"),
  ...
)

cc(secs, ..., verbose = getOption("reproducible.verbose"))

showCache(
  x,
  userTags = character(),
  after = NULL,
  before = NULL,
  fun = NULL,
  cacheId = NULL,
  drv = getDrv(getOption("reproducible.drv", NULL)),
  conn = getOption("reproducible.conn", NULL),
  verbose = getOption("reproducible.verbose"),
  ...
)

## S4 method for signature 'ANY'
showCache(
  x,
  userTags = character(),
  after = NULL,
  before = NULL,
  fun = NULL,
  cacheId = NULL,
  drv = getDrv(getOption("reproducible.drv", NULL)),
  conn = getOption("reproducible.conn", NULL),
  verbose = getOption("reproducible.verbose"),
  ...
)

keepCache(
  x,
  userTags = character(),
  after = NULL,
  before = NULL,
  ask = getOption("reproducible.ask"),
  drv = getDrv(getOption("reproducible.drv", NULL)),
  conn = getOption("reproducible.conn", NULL),
  verbose = getOption("reproducible.verbose"),
  ...
)

## S4 method for signature 'ANY'
keepCache(
  x,
  userTags = character(),
  after = NULL,
  before = NULL,
  ask = getOption("reproducible.ask"),
  drv = getDrv(getOption("reproducible.drv", NULL)),
  conn = getOption("reproducible.conn", NULL),
  verbose = getOption("reproducible.verbose"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="showCache_+3A_x">x</code></td>
<td>
<p>A simList or a directory containing a valid Cache repository. Note:
For compatibility with <code>Cache</code> argument, <code>cachePath</code> can also be
used instead of <code>x</code>, though <code>x</code> will take precedence.</p>
</td></tr>
<tr><td><code id="showCache_+3A_usertags">userTags</code></td>
<td>
<p>Character vector. If used, this will be used in place of the
<code>after</code> and <code>before</code>.
Specifying one or more <code>userTag</code> here will clear all
objects that match those tags.
Matching is via regular expression, meaning partial matches
will work unless strict beginning (<code>^</code>) and end (<code>$</code>) of string
characters are used.
Matching will be against any of the 3 columns returned by <code>showCache()</code>,
i.e., <code>artifact</code>, <code>tagValue</code> or <code>tagName</code>.
Also, if <code>length(userTags) &gt; 1</code>, then matching is by <code>and</code>.
For <code>or</code> matching, use <code>|</code> in a single character string.
See examples.</p>
</td></tr>
<tr><td><code id="showCache_+3A_after">after</code></td>
<td>
<p>A time (POSIX, character understandable by data.table).
Objects cached after this time will be shown or deleted.</p>
</td></tr>
<tr><td><code id="showCache_+3A_before">before</code></td>
<td>
<p>A time (POSIX, character understandable by data.table).
Objects cached before this time will be shown or deleted.</p>
</td></tr>
<tr><td><code id="showCache_+3A_fun">fun</code></td>
<td>
<p>An optional character vector describing the function name to extract.
Only functions with this/these functions will be returned.</p>
</td></tr>
<tr><td><code id="showCache_+3A_cacheid">cacheId</code></td>
<td>
<p>An optional character vector describing the <code>cacheId</code>s to extract.
Only entries with this/these <code>cacheId</code>s will be returned. If <code>useDBI(FALSE)</code>,
this will also be dramatically faster than using <code>userTags</code>, for a large
cache.</p>
</td></tr>
<tr><td><code id="showCache_+3A_ask">ask</code></td>
<td>
<p>Logical. If <code>FALSE</code>, then it will not ask to confirm deletions using
<code>clearCache</code> or <code>keepCache</code>. Default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="showCache_+3A_usecloud">useCloud</code></td>
<td>
<p>Logical. If <code>TRUE</code>, then every object that is deleted locally will
also be deleted in the <code>cloudFolderID</code>, if it is non-<code>NULL</code></p>
</td></tr>
<tr><td><code id="showCache_+3A_cloudfolderid">cloudFolderID</code></td>
<td>
<p>A googledrive dribble of a folder, e.g., using <code>drive_mkdir()</code>.
If left as <code>NULL</code>, the function will create a cloud folder with name from last
two folder levels of the <code>cachePath</code> path, :
<code>paste0(basename(dirname(cachePath)), "_", basename(cachePath))</code>.
This <code>cloudFolderID</code> will be added to <code>options("reproducible.cloudFolderID")</code>,
but this will not persist across sessions. If this is a character string, it will
treat this as a folder name to create or use on GoogleDrive.</p>
</td></tr>
<tr><td><code id="showCache_+3A_drv">drv</code></td>
<td>
<p>if using a database backend, drv must be an object that
inherits from DBIDriver e.g., from package RSQLite, e.g., SQLite</p>
</td></tr>
<tr><td><code id="showCache_+3A_conn">conn</code></td>
<td>
<p>an optional DBIConnection object, as returned by dbConnect().</p>
</td></tr>
<tr><td><code id="showCache_+3A_verbose">verbose</code></td>
<td>
<p>Numeric, -1 silent (where possible), 0 being very quiet,
1 showing more messaging, 2 being more messaging, etc.
Default is 1. Above 3 will output much more information about the internals of
Caching, which may help diagnose Caching challenges. Can set globally with an
option, e.g., <code style="white-space: pre;">&#8288;options('reproducible.verbose' = 0) to reduce to minimal&#8288;</code></p>
</td></tr>
<tr><td><code id="showCache_+3A_...">...</code></td>
<td>
<p>Other arguments. Can be in the form of <code>tagKey = tagValue</code>, such as,
<code>class = "numeric"</code> to find all entries that are numerics in the cache.
Note: the special cases of <code>cacheId</code> and <code>fun</code> have their own
named arguments in these functions.
Also can be <code>regexp = xx</code>, where <code>xx</code> is <code>TRUE</code> if the user
is passing a regular expression.
Otherwise, <code>userTags</code> will need to be exact matches. Default is
missing, which is the same as <code>TRUE</code>. If there are errors due
to regular expression problem, try <code>FALSE</code>. For <code>cc</code>, it is
passed to <code>clearCache</code>, e.g., <code>ask</code>, <code>userTags</code>. For <code>showCache</code>,
it can also be <code>sorted = FALSE</code> to return the object unsorted.</p>
</td></tr>
<tr><td><code id="showCache_+3A_secs">secs</code></td>
<td>
<p>Currently 3 options: the number of seconds to pass to <code>clearCache(after = secs)</code>,
a <code>POSIXct</code> time e.g., from <code>Sys.time()</code>, or missing. If missing,
the default, then it will delete the most recent entry in the Cache.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If neither <code>after</code> or <code>before</code> are provided, nor <code>userTags</code>,
then all objects will be removed.
If both <code>after</code> and <code>before</code> are specified, then all objects between
<code>after</code> and <code>before</code> will be deleted.
If <code>userTags</code> is used, this will override <code>after</code> or <code>before</code>.
</p>
<p><code>cc(secs)</code> is just a shortcut for <code>clearCache(repo = currentRepo, after = secs)</code>,
i.e., to remove any cache entries touched in the last <code>secs</code> seconds. Since, <code>secs</code>
can be missing, this is also be a shorthand for &quot;remove most recent entry from
the cache&quot;.
</p>

<dl>
<dt><code>clearCache</code></dt><dd><p>remove items from the cache based on their
<code>userTag</code> or <code>times</code> values.</p>
</dd>
<dt><code>keepCache</code></dt><dd><p>remove all cached items <em>except</em> those based on
certain <code>userTags</code> or <code>times</code> values.</p>
</dd>
<dt><code>showCache</code></dt><dd><p>display the contents of the cache.</p>
</dd>
</dl>

<p>By default the return of <code>showCache</code> is sorted by <code>cacheId</code>. For convenience,
a user can optionally have it unsorted (passing <code>sorted = FALSE</code>),
which may be noticeably faster when
the cache is large (<code style="white-space: pre;">&#8288;&gt; 1e4&#8288;</code> entries).
</p>


<h3>Value</h3>

<p>Will clear all objects (or those that match <code>userTags</code>, or those
between <code>after</code> or <code>before</code>) from the repository located at
<code>cachePath</code> of the sim object, if <code>sim</code> is provided, or located in
<code>cachePath</code>.
Invisibly returns a <code>data.table</code> of the removed items.
</p>


<h3>Note</h3>

<p>If the cache is larger than 10MB, and clearCache is used, there will be
a message and a pause, if interactive, to prevent accidentally deleting of a
large cache repository.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mergeCache">mergeCache()</a></code>. Many more examples in <code><a href="#topic+Cache">Cache()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data.table::setDTthreads(2)

tmpDir &lt;- file.path(tempdir(), "reproducible_examples", "Cache")
try(clearCache(tmpDir, ask = FALSE), silent = TRUE) # just to make sure it is clear

# Basic use
ranNumsA &lt;- Cache(rnorm, 10, 16, cachePath = tmpDir)

# All same
ranNumsB &lt;- Cache(rnorm, 10, 16, cachePath = tmpDir) # recovers cached copy
ranNumsD &lt;- Cache(quote(rnorm(n = 10, 16)), cachePath = tmpDir) # recovers cached copy

# Any minor change makes it different
ranNumsE &lt;- Cache(rnorm, 10, 6, cachePath = tmpDir) # different

## Example 1: basic cache use with tags
ranNumsA &lt;- Cache(rnorm, 4, cachePath = tmpDir, userTags = "objectName:a")
ranNumsB &lt;- Cache(runif, 4, cachePath = tmpDir, userTags = "objectName:b")
ranNumsC &lt;- Cache(runif, 40, cachePath = tmpDir, userTags = "objectName:b")

showCache(tmpDir, userTags = c("objectName"))
showCache(tmpDir, userTags = c("^a$")) # regular expression ... "a" exactly

# Fine control of cache elements -- pick out only the large runif object, and remove it
cache1 &lt;- showCache(tmpDir, userTags = c("runif")) # show only cached objects made during runif
toRemove &lt;- cache1[tagKey == "object.size"][as.numeric(tagValue) &gt; 700]$cacheId
clearCache(tmpDir, userTags = toRemove, ask = FALSE)
cacheAfter &lt;- showCache(tmpDir, userTags = c("runif")) # Only the small one is left

data.table::setDTthreads(2)
tmpDir &lt;- file.path(tempdir(), "reproducible_examples", "Cache")
try(clearCache(tmpDir, ask = FALSE), silent = TRUE) # just to make sure it is clear

Cache(rnorm, 1, cachePath = tmpDir)
thisTime &lt;- Sys.time()
Cache(rnorm, 2, cachePath = tmpDir)
Cache(rnorm, 3, cachePath = tmpDir)
Cache(rnorm, 4, cachePath = tmpDir)
showCache(x = tmpDir) # shows all 4 entries
cc(ask = FALSE, x = tmpDir)
showCache(x = tmpDir) # most recent is gone
cc(thisTime, ask = FALSE, x = tmpDir)
showCache(x = tmpDir) # all those after thisTime gone, i.e., only 1 left
cc(ask = FALSE, x = tmpDir) # Cache is
cc(ask = FALSE, x = tmpDir) # Cache is already empty
</code></pre>

<hr>
<h2 id='studyAreaName'>Get a unique name for a given study area</h2><span id='topic+studyAreaName'></span><span id='topic+studyAreaName+2Ccharacter-method'></span><span id='topic+studyAreaName+2CANY-method'></span>

<h3>Description</h3>

<p>Digest a spatial object to get a unique character string (hash) of the study area.
Use <code>.suffix()</code> to append the hash to a filename,
e.g., when using <code>filename2</code> in <code>prepInputs</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>studyAreaName(studyArea, ...)

## S4 method for signature 'character'
studyAreaName(studyArea, ...)

## S4 method for signature 'ANY'
studyAreaName(studyArea, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="studyAreaName_+3A_studyarea">studyArea</code></td>
<td>
<p>Spatial object.</p>
</td></tr>
<tr><td><code id="studyAreaName_+3A_...">...</code></td>
<td>
<p>Other arguments (not currently used)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string using the <code>.robustDigest</code> of the <code>studyArea</code>. This is only intended
for use with spatial objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>studyAreaName("Ontario")
</code></pre>

<hr>
<h2 id='tempdir2'>Make a temporary (sub-)directory</h2><span id='topic+tempdir2'></span>

<h3>Description</h3>

<p>Create a temporary subdirectory in <code>getOption("reproducible.tempPath")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tempdir2(
  sub = "",
  tempdir = getOption("reproducible.tempPath", .reproducibleTempPath()),
  create = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tempdir2_+3A_sub">sub</code></td>
<td>
<p>Character string, length 1. Can be a result of
<code>file.path("smth", "smth2")</code> for nested temporary subdirectories.
If the zero length character, then a random sub-directory will be created.</p>
</td></tr>
<tr><td><code id="tempdir2_+3A_tempdir">tempdir</code></td>
<td>
<p>Optional character string where the temporary
directory should be placed. Defaults to <code>getOption("reproducible.tempPath")</code>.</p>
</td></tr>
<tr><td><code id="tempdir2_+3A_create">create</code></td>
<td>
<p>Logical. Should the directory be created. Default <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string of a path (that will be created if <code>create = TRUE</code>) in a
sub-directory of the <code>tempdir()</code>.
</p>


<h3>See Also</h3>

<p><a href="#topic+tempfile2">tempfile2</a>
</p>

<hr>
<h2 id='tempfile2'>Make a temporary file in a temporary (sub-)directory</h2><span id='topic+tempfile2'></span>

<h3>Description</h3>

<p>Make a temporary file in a temporary (sub-)directory
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tempfile2(
  sub = "",
  tempdir = getOption("reproducible.tempPath", .reproducibleTempPath()),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tempfile2_+3A_sub">sub</code></td>
<td>
<p>Character string, length 1. Can be a result of
<code>file.path("smth", "smth2")</code> for nested temporary subdirectories.
If the zero length character, then a random sub-directory will be created.</p>
</td></tr>
<tr><td><code id="tempfile2_+3A_tempdir">tempdir</code></td>
<td>
<p>Optional character string where the temporary
directory should be placed. Defaults to <code>getOption("reproducible.tempPath")</code>.</p>
</td></tr>
<tr><td><code id="tempfile2_+3A_...">...</code></td>
<td>
<p>passed to <code>tempfile</code>, e.g., <code>fileext</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string of a path to a file in a
sub-directory of the <code>tempdir()</code>. This file will likely not exist yet.
</p>


<h3>See Also</h3>

<p><a href="#topic+tempdir2">tempdir2</a>
</p>

<hr>
<h2 id='testForArchiveExtract'>Returns unrar path and creates a shortcut as .unrarPath
Was not incorporated in previous function so it can be
used in the tests</h2><span id='topic+testForArchiveExtract'></span><span id='topic+.testForArchiveExtract'></span>

<h3>Description</h3>

<p>Returns unrar path and creates a shortcut as .unrarPath
Was not incorporated in previous function so it can be
used in the tests
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.testForArchiveExtract()
</code></pre>


<h3>Value</h3>

<p>unrar or 7zip path if exist, and assign it to .unrarPath
Stops and advise user to install it if unrar doesn't exist
</p>


<h3>Author(s)</h3>

<p>Tati Micheletti
</p>

<hr>
<h2 id='unrarPath'>The known path for unrar or 7z</h2><span id='topic+unrarPath'></span><span id='topic+.unrarPath'></span>

<h3>Description</h3>

<p>The known path for unrar or 7z
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.unrarPath
</code></pre>


<h3>Format</h3>

<p>An object of class <code>NULL</code> of length 0.
</p>

<hr>
<h2 id='writeFuture'>Write to cache repository, using <code>future::future</code></h2><span id='topic+writeFuture'></span>

<h3>Description</h3>

<p>This will be used internally if <code>options("reproducible.futurePlan" = TRUE)</code>.
This is still experimental.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeFuture(
  written,
  outputToSave,
  cachePath,
  userTags,
  drv = getDrv(getOption("reproducible.drv", NULL)),
  conn = getOption("reproducible.conn", NULL),
  cacheId,
  linkToCacheId = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeFuture_+3A_written">written</code></td>
<td>
<p>Integer. If zero or positive then it needs to be written still.
Should be 0 to start.</p>
</td></tr>
<tr><td><code id="writeFuture_+3A_outputtosave">outputToSave</code></td>
<td>
<p>The R object to save to repository</p>
</td></tr>
<tr><td><code id="writeFuture_+3A_cachepath">cachePath</code></td>
<td>
<p>The file path of the repository</p>
</td></tr>
<tr><td><code id="writeFuture_+3A_usertags">userTags</code></td>
<td>
<p>Character string of tags to attach to this <code>outputToSave</code> in
the <code>CacheRepo</code></p>
</td></tr>
<tr><td><code id="writeFuture_+3A_drv">drv</code></td>
<td>
<p>if using a database backend, drv must be an object that
inherits from DBIDriver e.g., from package RSQLite, e.g., SQLite</p>
</td></tr>
<tr><td><code id="writeFuture_+3A_conn">conn</code></td>
<td>
<p>an optional DBIConnection object, as returned by dbConnect().</p>
</td></tr>
<tr><td><code id="writeFuture_+3A_cacheid">cacheId</code></td>
<td>
<p>Character string. If passed, this will override the calculated hash
of the inputs, and return the result from this cacheId in the <code>cachePath</code>.
Setting this is equivalent to manually saving the output of this function, i.e.,
the object will be on disk, and will be recovered in subsequent
This may help in some particularly finicky situations
where Cache is not correctly detecting unchanged inputs. This will guarantee
the object will be identical each time; this may be useful in operational code.</p>
</td></tr>
<tr><td><code id="writeFuture_+3A_linktocacheid">linkToCacheId</code></td>
<td>
<p>Optional. If a <code>cacheId</code> is provided here, then a <code>file.link</code>
will be made to the file with that <code>cacheId</code> name in the cache repo.
This is used when identical outputs exist in the cache. This will save disk space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Run for its side effect.
This will add the <code>objectToSave</code> to the cache located at <code>cachePath</code>,
using <code>cacheId</code> as its id, while
updating the database entry. It will do this using the future package, so it is
written in a future.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
