<!DOCTYPE html><html><head><title>Help for package nanostringr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {nanostringr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#nanostringr-package'><p>nanostringr: Performs Quality Control, Data Normalization, and Batch Effect Correction for 'NanoString nCounter' Data</p></a></li>
<li><a href='#CCplot'><p>Concordance Correlation Plot</p></a></li>
<li><a href='#cohort'><p>NanoString Experiment Cohorts</p></a></li>
<li><a href='#expQC'><p>Expression QC data</p></a></li>
<li><a href='#HKnorm'><p>Normalization to Housekeeping Genes</p></a></li>
<li><a href='#NanoStringQC'><p>QC metrics for NanoString Data</p></a></li>
<li><a href='#normalize_pools'><p>Normalize data using common pools</p></a></li>
<li><a href='#normalize_random'><p>Normalize data using random reference samples</p></a></li>
<li><a href='#rcc'><p>Read NanoString RCC files</p></a></li>
<li><a href='#refMethod'><p>Reference-based approach for batch adjustment</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Performs Quality Control, Data Normalization, and Batch Effect
Correction for 'NanoString nCounter' Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides quality control (QC), normalization, and batch
    effect correction operations for 'NanoString nCounter' data, Talhouk
    et al. (2016) &lt;<a href="https://doi.org/10.1371%2Fjournal.pone.0153844">doi:10.1371/journal.pone.0153844</a>&gt;.  Various metrics are
    used to determine which samples passed or failed QC.  Gene expression
    should first be normalized to housekeeping genes, before a
    reference-based approach is used to adjust for batch effects.  Raw
    NanoString data can be imported in the form of Reporter Code Count
    (RCC) files.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/TalhoukLab/nanostringr/">https://github.com/TalhoukLab/nanostringr/</a>,
<a href="https://talhouklab.github.io/nanostringr/">https://talhouklab.github.io/nanostringr/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/TalhoukLab/nanostringr/issues">https://github.com/TalhoukLab/nanostringr/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>assertthat, ccaPP, dplyr, purrr, rlang, tidyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, knitr, magrittr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-15 16:36:01 UTC; derekchiu</td>
</tr>
<tr>
<td>Author:</td>
<td>Derek Chiu <a href="https://orcid.org/0000-0002-7591-4881"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Aline Talhouk <a href="https://orcid.org/0000-0001-7760-410X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Samuel Leung <a href="https://orcid.org/0000-0003-0138-7254"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Derek Chiu &lt;dchiu@bccrc.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-15 17:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='nanostringr-package'>nanostringr: Performs Quality Control, Data Normalization, and Batch Effect Correction for 'NanoString nCounter' Data</h2><span id='topic+nanostringr'></span><span id='topic+nanostringr-package'></span>

<h3>Description</h3>

<p>Provides quality control (QC), normalization, and batch effect correction operations for 'NanoString nCounter' data, Talhouk et al. (2016) <a href="https://doi.org/10.1371/journal.pone.0153844">doi:10.1371/journal.pone.0153844</a>. Various metrics are used to determine which samples passed or failed QC. Gene expression should first be normalized to housekeeping genes, before a reference-based approach is used to adjust for batch effects. Raw NanoString data can be imported in the form of Reporter Code Count (RCC) files.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Derek Chiu <a href="mailto:dchiu@bccrc.ca">dchiu@bccrc.ca</a> (<a href="https://orcid.org/0000-0002-7591-4881">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Aline Talhouk <a href="mailto:atalhouk@bccrc.ca">atalhouk@bccrc.ca</a> (<a href="https://orcid.org/0000-0001-7760-410X">ORCID</a>)
</p>
</li>
<li><p> Samuel Leung <a href="mailto:Samuel.Leung@vch.ca">Samuel.Leung@vch.ca</a> (<a href="https://orcid.org/0000-0003-0138-7254">ORCID</a>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/TalhoukLab/nanostringr/">https://github.com/TalhoukLab/nanostringr/</a>
</p>
</li>
<li> <p><a href="https://talhouklab.github.io/nanostringr/">https://talhouklab.github.io/nanostringr/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/TalhoukLab/nanostringr/issues">https://github.com/TalhoukLab/nanostringr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='CCplot'>Concordance Correlation Plot</h2><span id='topic+CCplot'></span>

<h3>Description</h3>

<p>Plotting function for reliability measure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CCplot(
  method1,
  method2,
  Ptype = "None",
  metrics = FALSE,
  xlabel = "",
  ylabel = "",
  title = "",
  subtitle = NULL,
  xrange = NULL,
  yrange = NULL,
  MArange = c(-3.5, 5.5)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CCplot_+3A_method1">method1</code></td>
<td>
<p>measurements obtained in batch 1 or using method 1</p>
</td></tr>
<tr><td><code id="CCplot_+3A_method2">method2</code></td>
<td>
<p>measurements obtained in batch 2 or using method 2</p>
</td></tr>
<tr><td><code id="CCplot_+3A_ptype">Ptype</code></td>
<td>
<p>type of plot to be outputted c(&quot;scatter&quot;, &quot;MAplot&quot;)</p>
</td></tr>
<tr><td><code id="CCplot_+3A_metrics">metrics</code></td>
<td>
<p>if <code>TRUE</code>, prints Rc, Ca, and R2 to console</p>
</td></tr>
<tr><td><code id="CCplot_+3A_xlabel">xlabel</code></td>
<td>
<p>x-axis label for scatterplot</p>
</td></tr>
<tr><td><code id="CCplot_+3A_ylabel">ylabel</code></td>
<td>
<p>y-axis label for scatterplot</p>
</td></tr>
<tr><td><code id="CCplot_+3A_title">title</code></td>
<td>
<p>title for the main plot</p>
</td></tr>
<tr><td><code id="CCplot_+3A_subtitle">subtitle</code></td>
<td>
<p>subtitle of plot</p>
</td></tr>
<tr><td><code id="CCplot_+3A_xrange">xrange</code></td>
<td>
<p>range of x axis</p>
</td></tr>
<tr><td><code id="CCplot_+3A_yrange">yrange</code></td>
<td>
<p>range of y axis</p>
</td></tr>
<tr><td><code id="CCplot_+3A_marange">MArange</code></td>
<td>
<p>MA range</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a scatterplot or MA plot showing concordance correlation.
</p>


<h3>Author(s)</h3>

<p>Aline Talhouk
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate normally distributed data
set.seed(12)
a1 &lt;- rnorm(20) + 2
a2 &lt;- a1 + rnorm(20, 0, 0.15)
a3 &lt;- a1 + rnorm(20, 0, 0.15) + 1.4
a4 &lt;- 1.5 * a1 + rnorm(20, 0, 0.15)
a5 &lt;- 1.3 * a1 + rnorm(20, 0, 0.15) + 1
a6 &lt;- a1 + rnorm(20, 0, 0.8)

# One scatterplot
CCplot(a1, a2, Ptype = "scatter")


m2 &lt;- list(a1, a2, a3, a4, a5, a6)
mains &lt;- c("Perfect Agreement", "Very Good Agreement", "Location Shift",
           "Scale Shift", "Location and Scale Shift", "Measurement Error")
subs &lt;- letters[1:6]
par(mfrow = c(3, 2), mar = c(5.1, 4.1, 1.5, 1.5))

# Scatterplots
mapply(function(y, t, s)
  CCplot(method1 = a1, method2 = y, Ptype = "scatter",
         xlabel = "X", ylabel = "Y", title = t, subtitle = s),
  y = m2, t = mains, s = subs)

# MAplots and show metrics
mapply(function(y, t, s)
  CCplot(method1 = a1, method2 = y, Ptype = "MAplot",
         title = t, subtitle = s, metrics = TRUE),
  y = m2, t = mains, s = subs)
</code></pre>

<hr>
<h2 id='cohort'>NanoString Experiment Cohorts</h2><span id='topic+cohort'></span><span id='topic+hld.r'></span><span id='topic+ovd.r'></span><span id='topic+ovc.r'></span><span id='topic+hlo.r'></span><span id='topic+ovo.r'></span>

<h3>Description</h3>

<p>There were five different cohorts used in NanoString experiments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hld.r

ovd.r

ovc.r

hlo.r

ovo.r
</code></pre>


<h3>Format</h3>


<ul>
<li> <p><code>hld.r</code> Hodgkin Lymphoma Clinical Samples: a data frame with 232 rows and
77 columns
</p>
</li>
<li> <p><code>ovd.r</code> Ovarian Cancer Clinical Samples: a data frame with 133 rows and 261
columns
</p>
</li>
<li> <p><code>ovc.r</code> Ovarian Cancer Cell Lines: a data frame with 133 rows and 29
columns
</p>
</li>
<li> <p><code>hlo.r</code> DNA Oligonucleotides for the HL CodeSet: a data frame with 40 rows
and 71 columns
</p>
</li>
<li> <p><code>ovo.r</code> DNA Oligonucleotides for the OC CodeSet: a data frame with 133 rows
and 138 columns
</p>
</li></ul>

<p>An object of class <code>data.frame</code> with 232 rows and 77 columns.
</p>
<p>An object of class <code>data.frame</code> with 133 rows and 261 columns.
</p>
<p>An object of class <code>data.frame</code> with 133 rows and 29 columns.
</p>
<p>An object of class <code>data.frame</code> with 40 rows and 71 columns.
</p>
<p>An object of class <code>data.frame</code> with 133 rows and 138 columns.
</p>


<h3>Details</h3>

<p>Each data object contains raw expression counts, so no normalization has been
applied. The format is a data frame with genes as rows, samples as columns.
Note that the first three columns contain gene metadata and are always
labelled &quot;Code.Class&quot;, &quot;Name&quot;, and &quot;Accession&quot;, and the rest are sample
names. Hence, for the <code>hld.r</code> data, the raw counts are contained in 232 genes
for 77 - 3 = 74 samples. The total number of samples is 74 + 258 + 26 + 68 +
135 = 561, which matches the number of rows in <a href="#topic+expQC">expQC</a>, the expression QC
data.
</p>


<h3>Source</h3>

<p>See Table 1 of
<a href="https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0153844">https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0153844</a>
for details.
</p>


<h3>See Also</h3>

<p><a href="#topic+expQC">expQC</a>
</p>

<hr>
<h2 id='expQC'>Expression QC data</h2><span id='topic+expQC'></span>

<h3>Description</h3>

<p>Quality control metrics for the five cohorts analyzed in NanoString
experiments.
</p>


<h3>Format</h3>

<p>A data frame with 561 rows and 23 columns.
</p>


<h3>Details</h3>

<p>The total number of samples from the five cohorts is 561.
</p>


<h3>See Also</h3>

<p><a href="#topic+cohort">cohort</a>
</p>

<hr>
<h2 id='HKnorm'>Normalization to Housekeeping Genes</h2><span id='topic+HKnorm'></span>

<h3>Description</h3>

<p>Normalizes the gene expression of NanoString nCounter data to housekeeping
genes. This is done by subtracting the average log housekeeping gene
expression from the expression level of every gene in each sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HKnorm(raw, is.logged = FALSE, corr = 1e-04)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HKnorm_+3A_raw">raw</code></td>
<td>
<p>data frame of raw counts obtained from nCounter (rows represent
genes, columns represent samples). The first three columns must be labeled:
<code>c("Code.Class", "Name", "Accession")</code> and contain that information.</p>
</td></tr>
<tr><td><code id="HKnorm_+3A_is.logged">is.logged</code></td>
<td>
<p>logical; If <code>TRUE</code>, normalization has already been done on
log base 2 scale, no need log the data</p>
</td></tr>
<tr><td><code id="HKnorm_+3A_corr">corr</code></td>
<td>
<p>small correction to avoid error</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame of log normalized data in the same format but without
reference genes
</p>


<h3>Author(s)</h3>

<p>Aline Talhouk, Derek Chiu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>HKnorm(ovd.r)
HKnorm(ovd.r, is.logged = TRUE)
</code></pre>

<hr>
<h2 id='NanoStringQC'>QC metrics for NanoString Data</h2><span id='topic+NanoStringQC'></span>

<h3>Description</h3>

<p>Computes and returns NanoString quality control metrics and flags.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NanoStringQC(raw, exp, detect = 80, sn = 150)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NanoStringQC_+3A_raw">raw</code></td>
<td>
<p>data frame of raw counts obtained from nCounter (rows represent
genes, columns represent samples). The first three columns must be labeled:
<code>c("Code.Class", "Name", "Accession")</code> and contain that information.</p>
</td></tr>
<tr><td><code id="NanoStringQC_+3A_exp">exp</code></td>
<td>
<p>data frame of annotations with rows in the same order as the
columns of <code>raw</code>. Requires a column labeled <code>"File.Name"</code> with entries
corresponding to sample names in <code>raw</code>, also needs columns
<code>c("fov.counted", "fov.count", "binding.density")</code>.These fields can be
extracted from the nanostring RCC files.</p>
</td></tr>
<tr><td><code id="NanoStringQC_+3A_detect">detect</code></td>
<td>
<p>threshold of percentage of genes expressed over limit of
detection (LOD) that we would like to detect (not decimal), defaults to 80
percent.</p>
</td></tr>
<tr><td><code id="NanoStringQC_+3A_sn">sn</code></td>
<td>
<p>signal to noise ratio of the housekeeping genes we are willing to
tolerate, defaults to 150.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame of annotations updated with normalization parameters
</p>


<h3>Author(s)</h3>

<p>Aline Talhouk, Derek Chiu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>exp.OVD &lt;- subset(expQC, OVD == "Yes")
expOVD &lt;- NanoStringQC(ovd.r, exp.OVD)
</code></pre>

<hr>
<h2 id='normalize_pools'>Normalize data using common pools</h2><span id='topic+normalize_pools'></span>

<h3>Description</h3>

<p>Normalize nanostring gene expression using common pools between two CodeSets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize_pools(x, ref, x_pools, ref_pools, p = 3, weigh = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalize_pools_+3A_x">x</code></td>
<td>
<p>target data</p>
</td></tr>
<tr><td><code id="normalize_pools_+3A_ref">ref</code></td>
<td>
<p>reference data</p>
</td></tr>
<tr><td><code id="normalize_pools_+3A_x_pools">x_pools</code></td>
<td>
<p>target pool samples</p>
</td></tr>
<tr><td><code id="normalize_pools_+3A_ref_pools">ref_pools</code></td>
<td>
<p>reference pool samples</p>
</td></tr>
<tr><td><code id="normalize_pools_+3A_p">p</code></td>
<td>
<p>number of pool sample sets. Defaults to 3.</p>
</td></tr>
<tr><td><code id="normalize_pools_+3A_weigh">weigh</code></td>
<td>
<p>logical; if <code>TRUE</code>, the average expression in <code>x_pools</code> is
reweighed by the distribution of the <code>p</code> pool sample sets in <code>ref_pools</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The target and reference expression samples, as well the target and reference
pool samples all need to be specified. We recommend reweighing the target
pool samples when calculating the average expression by the distribution of
reference pools.
</p>


<h3>Value</h3>

<p>normalized gene expression
</p>


<h3>Author(s)</h3>

<p>Derek Chiu
</p>

<hr>
<h2 id='normalize_random'>Normalize data using random reference samples</h2><span id='topic+normalize_random'></span>

<h3>Description</h3>

<p>Normalize nanostring gene expression using randomly chosen samples
for the reference-based approach for batch adjustment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize_random(x, ref, n = 1, strata = NULL, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalize_random_+3A_x">x</code></td>
<td>
<p>target data</p>
</td></tr>
<tr><td><code id="normalize_random_+3A_ref">ref</code></td>
<td>
<p>reference data</p>
</td></tr>
<tr><td><code id="normalize_random_+3A_n">n</code></td>
<td>
<p>number of random reference samples to select for normalization</p>
</td></tr>
<tr><td><code id="normalize_random_+3A_strata">strata</code></td>
<td>
<p>a grouping variable for stratified random sampling. If <code>strata</code>
has <code>k</code> levels, then <code>n * k</code> random samples are selected.</p>
</td></tr>
<tr><td><code id="normalize_random_+3A_seed">seed</code></td>
<td>
<p>random seed for reproducibility</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of randomly chosen numbers can be selected, and optionally a
<code>strata</code> can be specified such that <code>n</code> reference samples are selected from
each level (like a stratified bootstrap). In relation to the reference
method, the random samples removed from <code>ref</code> form <code>R1</code>, the random samples
removed from <code>x</code> form <code>R2</code>, and the remaining samples from <code>x</code> form <code>Y</code>. See
<code>refMethod()</code> for details.
</p>
<p>In subsequent analyses, we refer to a method using <code>normalize_random(n)</code> as
the &quot;Random n&quot; method.
</p>


<h3>Value</h3>

<p>normalized gene expression
</p>


<h3>Author(s)</h3>

<p>Derek Chiu
</p>

<hr>
<h2 id='rcc'>Read NanoString RCC files</h2><span id='topic+rcc'></span><span id='topic+read_rcc'></span><span id='topic+parse_counts'></span><span id='topic+parse_attributes'></span>

<h3>Description</h3>

<p>Read RCC files and extract count and attribute data. Use <code>read_rcc()</code> for
multiple files, and use the <code style="white-space: pre;">&#8288;parse_*()&#8288;</code> functions for single files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_rcc(path = ".")

parse_counts(file)

parse_attributes(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcc_+3A_path">path</code></td>
<td>
<p>directory path for multiple RCC files</p>
</td></tr>
<tr><td><code id="rcc_+3A_file">file</code></td>
<td>
<p>RCC file name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>RCC files for a sample are direct outputs from NanoString runs. We can
extract counts for each gene in a sample. Sample attributes include sample
ID, GeneRLF, date, cartridge ID, lane number, Fov count, Fov counted, and
binding density. <code>read_rcc()</code> merges both count and attribute data across
samples.
</p>
<p>If <code>path</code> points to a zipped RCC file with multiple samples, the zip file is
uncompressed and a directory of RCC sample files is created with the same
name. Only file extensions &quot;.RCC&quot; or &quot;.rcc&quot; are allowed.
</p>


<h3>Value</h3>

<p><code>read_rcc()</code> reads in a directory of RCC files and outputs a list
with two elements:
</p>

<ul>
<li> <p><code>raw</code>: A tibble of parsed counts for multiple RCC files created by calling
<code>parse_counts()</code> on each sample. Columns include &quot;Code.Class&quot;, &quot;Name&quot;,
&quot;Accession&quot;, and a column for each sample ID. There is one row per gene.
</p>
</li>
<li> <p><code>exp</code>: A tibble of parsed attributes for multiple RCC files created by
calling <code>parse_attributes()</code> on each sample. Columns include &quot;File.Name&quot;
(sample ID), &quot;geneRLF&quot;, &quot;nanostring.date&quot;, &quot;cartridgeID&quot;, &quot;lane.number&quot;,
fov.count&quot;, &quot;fov.counted&quot;, &quot;binding.density&quot;. There is one row per sample.
</p>
</li></ul>

<p><code>parse_counts()</code> reads a single RCC file and returns a tibble of
parsed counts.
</p>
<p><code>parse_attributes()</code> reads a single RCC file and returns a list of
parsed attributes.
</p>


<h3>Author(s)</h3>

<p>Derek Chiu
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rcc_file &lt;- system.file("extdata", "example.RCC", package = "nanostringr")
parse_counts(rcc_file)
parse_attributes(rcc_file)
</code></pre>

<hr>
<h2 id='refMethod'>Reference-based approach for batch adjustment</h2><span id='topic+refMethod'></span>

<h3>Description</h3>

<p>Batch adjustment by considering a measure relative to a reference sample
</p>


<h3>Usage</h3>

<pre><code class='language-R'>refMethod(Y, R1, R2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="refMethod_+3A_y">Y</code></td>
<td>
<p>data run in first or second batch, samples are rows and genes are
columns. If correcting one batch only R1 is needed and would correspond to
reference run in the same batch as Y, if calibrating one batch to the other
Y represents the data from batch 2 and R1 would be reference run in batch 1
and R2 would be reference from batch 2</p>
</td></tr>
<tr><td><code id="refMethod_+3A_r1">R1</code></td>
<td>
<p>reference data run in the first batch</p>
</td></tr>
<tr><td><code id="refMethod_+3A_r2">R2</code></td>
<td>
<p>reference data run in the second batch</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Y data adjusted calibrated to batch 1 (if two batches are
presented) or the data with reference sample expression removed if only one
data is provided
</p>


<h3>Author(s)</h3>

<p>Aline Talhouk
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12)
A &lt;- matrix(rnorm(120), ncol = 10)
B &lt;- matrix(rnorm(80), ncol = 10)
C &lt;- matrix(rnorm(50), ncol = 10)
refMethod(A, B, C)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
