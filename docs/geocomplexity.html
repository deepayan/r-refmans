<!DOCTYPE html><html lang="en"><head><title>Help for package geocomplexity</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {geocomplexity}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#geocd_raster'><p>geocomplexity for spatial raster data based on spatial dependence</p></a></li>
<li><a href='#geocd_swm'><p>constructing spatial weight matrix based on geocomplexity with spatial dependence</p></a></li>
<li><a href='#geocd_vector'><p>geocomplexity for spatial vector data based on spatial dependence</p></a></li>
<li><a href='#geocs_raster'><p>geocomplexity for spatial raster data based on geographical similarity</p></a></li>
<li><a href='#geocs_swm'><p>constructing spatial weight matrix based on geocomplexity with similar geographical configurations</p></a></li>
<li><a href='#geocs_vector'><p>geocomplexity for spatial vector data based on geographical similarity</p></a></li>
<li><a href='#gwr_geoc'><p>geographical complexity-geographically weighted regression</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Mitigating Spatial Bias Through Geographical Complexity</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>The geographical complexity of individual variables can be characterized by the differences in local attribute variables, while the common geographical complexity of multiple variables can be represented by fluctuations in the similarity of vectors composed of multiple variables. In spatial regression tasks, the goodness of fit can be improved by incorporating a geographical complexity representation vector during modeling, using a geographical complexity-weighted spatial weight matrix, or employing local geographical complexity kernel density. Similarly, in spatial sampling tasks, samples can be selected more effectively by using a method that weights based on geographical complexity. By optimizing performance in spatial regression and spatial sampling tasks, the spatial bias of the model can be effectively reduced.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://ausgis.github.io/geocomplexity/">https://ausgis.github.io/geocomplexity/</a>,
<a href="https://github.com/ausgis/geocomplexity">https://github.com/ausgis/geocomplexity</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ausgis/geocomplexity/issues">https://github.com/ausgis/geocomplexity/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, magrittr, purrr, sdsfun, sf, stats, terra, tibble</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, knitr, Rcpp, RcppArmadillo, rmarkdown, viridis</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-11 08:13:31 UTC; dell</td>
</tr>
<tr>
<td>Author:</td>
<td>Wenbo Lv <a href="https://orcid.org/0009-0002-6003-3800"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre, cph],
  Yongze Song <a href="https://orcid.org/0000-0003-3420-9622"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Zehua Zhang <a href="https://orcid.org/0000-0003-3462-4025"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Wenbo Lv &lt;lyu.geosocial@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-11 11:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Value</h3>

<p><code>NULL</code> (this is the magrittr pipe operator)
</p>

<hr>
<h2 id='geocd_raster'>geocomplexity for spatial raster data based on spatial dependence</h2><span id='topic+geocd_raster'></span>

<h3>Description</h3>

<p>This function calculates geocomplexity for spatial raster data based on spatial dependence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geocd_raster(r, order = 1, normalize = TRUE, method = "moran")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geocd_raster_+3A_r">r</code></td>
<td>
<p><code>SpatRaster</code> object or can be converted to <code>SpatRaster</code> by <code>terra::rast()</code>.</p>
</td></tr>
<tr><td><code id="geocd_raster_+3A_order">order</code></td>
<td>
<p>(optional) The order of the adjacency object. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="geocd_raster_+3A_normalize">normalize</code></td>
<td>
<p>(optional) Whether to further normalizes the calculated geocomplexity.
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="geocd_raster_+3A_method">method</code></td>
<td>
<p>(optional) In instances where the method is <code>moran</code>, geocomplexity is
determined using local moran measure method. Conversely, when the method is <code>spvar</code>,
the spatial variance of attribute data serves to characterize geocomplexity. For all
other methods, the shannon information entropy of attribute data is employed to represent
geocomplexity. The selection of the method can be made from any one of the three options:
<code>moran</code>, <code>spvar</code> or <code>entropy</code>. Default is <code>moran</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>SpatRaster</code> object
</p>


<h3>Note</h3>

<p>In contrast to the <code>geocd_vector()</code> function, the <code>geocd_raster()</code> performs operations
internally on raster data based on neighborhood operations(focal) without providing
additional wt object.
</p>


<h3>References</h3>

<p>Zehua Zhang, Yongze Song, Peng Luo &amp; Peng Wu (2023) Geocomplexity explains spatial errors,
International Journal of Geographical Information Science, 37:7, 1449-1469,
DOI: 10.1080/13658816.2023.2203212
</p>
<p>Anselin, L. (2019). A local indicator of multivariate spatial association: Extending
geary’s c. Geographical Analysis, 51(2), 133–150. https://doi.org/10.1111/gean.12164
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
m = matrix(c(3,3,3,3,1,3,
             3,3,3,2,1,2,
             3,3,3,1,2,1,
             1,3,2,2,2,2,
             2,2,2,1,1,2,
             1,2,1,1,1,1),
           nrow = 6,
           byrow = TRUE)
m = rast(m)
names(m) = 'sim'
plot(m, col = c("#d2eaac", "#a3dae1", "#8cc1e1"))
gc1 = geocd_raster(m,1)
gc2 = geocd_raster(m,2)
gc1
plot(gc1)
gc2
plot(gc2)

</code></pre>

<hr>
<h2 id='geocd_swm'>constructing spatial weight matrix based on geocomplexity with spatial dependence</h2><span id='topic+geocd_swm'></span>

<h3>Description</h3>

<p>constructing spatial weight matrix based on geocomplexity with spatial dependence
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geocd_swm(sfj, wt = NULL, style = "B", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geocd_swm_+3A_sfj">sfj</code></td>
<td>
<p>An <code>sf</code> object or spatial vector object that can be converted to <code>sf</code> by <code>sf::st_as_sf()</code>.</p>
</td></tr>
<tr><td><code id="geocd_swm_+3A_wt">wt</code></td>
<td>
<p>(optional) Spatial weight matrix based on spatial adjacency or spatial distance relationships.</p>
</td></tr>
<tr><td><code id="geocd_swm_+3A_style">style</code></td>
<td>
<p>(optional) A character that can be <code>B</code>,<code>W</code>,<code>C</code>.  More to see <code>spdep::nb2mat()</code>.
Default is <code>B</code>.</p>
</td></tr>
<tr><td><code id="geocd_swm_+3A_...">...</code></td>
<td>
<p>(optional) Other parameters passed to <code>geocomplexity::geocd_vector()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>econineq = sf::read_sf(system.file('extdata/econineq.gpkg',package = 'geocomplexity'))
wt_gc = geocd_swm(econineq)
wt_gc[1:5,1:5]

</code></pre>

<hr>
<h2 id='geocd_vector'>geocomplexity for spatial vector data based on spatial dependence</h2><span id='topic+geocd_vector'></span>

<h3>Description</h3>

<p>This function calculates geocomplexity for spatial vector data based on spatial dependence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geocd_vector(
  sfj,
  wt = NULL,
  method = "moran",
  normalize = TRUE,
  returnsf = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geocd_vector_+3A_sfj">sfj</code></td>
<td>
<p>An <code>sf</code> object or spatial vector object that can be converted to <code>sf</code> by <code>sf::st_as_sf()</code>.</p>
</td></tr>
<tr><td><code id="geocd_vector_+3A_wt">wt</code></td>
<td>
<p>(optional) Spatial weight matrix. Must be a <code>matrix</code> class.</p>
</td></tr>
<tr><td><code id="geocd_vector_+3A_method">method</code></td>
<td>
<p>(optional) In instances where the method is <code>moran</code>, geocomplexity is
determined using local moran measure method. Conversely, when the method is <code>spvar</code>,
the spatial variance of attribute data serves to characterize geocomplexity. For all
other methods, the shannon information entropy of attribute data is employed to represent
geocomplexity. The selection of the method can be made from any one of the three options:
<code>moran</code>, <code>spvar</code> or <code>entropy</code>. Default is <code>moran</code>.</p>
</td></tr>
<tr><td><code id="geocd_vector_+3A_normalize">normalize</code></td>
<td>
<p>(optional) Whether to further normalizes the calculated geocomplexity.
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="geocd_vector_+3A_returnsf">returnsf</code></td>
<td>
<p>(optional) When <code>returnsf</code> is <code>TRUE</code>, return an sf object, otherwise a tibble.
Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code> (<code>returnsf</code> is <code>FALSE</code>) or an <code>sf</code> object (<code>returnsf</code> is <code>TRUE</code>)
</p>


<h3>Note</h3>

<p>If <code>wt</code> is not provided, for polygon vector data, <code>geocomplexity</code> will use a first-order queen
adjacency binary matrix; for point vector data, the six nearest points are used as adjacency
objects to generate an adjacency binary matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>econineq = sf::read_sf(system.file('extdata/econineq.gpkg',package = 'geocomplexity'))
gc = geocd_vector(econineq)
gc

library(ggplot2)
library(viridis)
ggplot(gc) +
   geom_sf(aes(fill = GC_Gini)) +
   scale_fill_viridis(option = "mako", direction = -1) +
   theme_bw()

</code></pre>

<hr>
<h2 id='geocs_raster'>geocomplexity for spatial raster data based on geographical similarity</h2><span id='topic+geocs_raster'></span>

<h3>Description</h3>

<p>This function calculates geocomplexity for spatial raster data based on geographical similarity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geocs_raster(r, order = 1, normalize = TRUE, similarity = 1, method = "spvar")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geocs_raster_+3A_r">r</code></td>
<td>
<p><code>SpatRaster</code> object or can be converted to <code>SpatRaster</code> by <code>terra::rast()</code>.</p>
</td></tr>
<tr><td><code id="geocs_raster_+3A_order">order</code></td>
<td>
<p>(optional) The order of the adjacency object. Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="geocs_raster_+3A_normalize">normalize</code></td>
<td>
<p>(optional) Whether to further normalizes the calculated geocomplexity.
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="geocs_raster_+3A_similarity">similarity</code></td>
<td>
<p>(optional) When <code>similarity</code> is <code>1</code>, the similarity is calculated using
geographical configuration similarity, otherwise the cosine similarity is calculated.
Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="geocs_raster_+3A_method">method</code></td>
<td>
<p>(optional) When <code>method</code> is <code>spvar</code>, variation of the similarity vector is
represented using spatial variance, otherwise shannon information entropy is used. Default
is <code>spvar</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>SpatRaster</code> object
</p>


<h3>Note</h3>

<p>In contrast to the <code>geocs_vector()</code> function, the <code>geocs_raster()</code> performs operations
internally on raster data without providing additional wt object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(terra)
m1 = matrix(c(3,3,3,3,1,3,
              3,3,3,2,1,2,
              3,3,3,1,2,1,
              1,3,2,2,2,2,
              2,2,2,1,1,2,
              1,2,1,1,1,1),
           nrow = 6,
           byrow = TRUE)
m1 = rast(m1)
names(m1) = 'sim1'
m2 = m1
set.seed(123456789)
values(m2) = values(m1) + runif(ncell(m1),-1,1)
names(m2) = 'sim2'
m = c(m1,m2)
gc1 = geocs_raster(m,1)
gc2 = geocs_raster(m,2)
gc1
plot(gc1)
gc2
plot(gc2)

</code></pre>

<hr>
<h2 id='geocs_swm'>constructing spatial weight matrix based on geocomplexity with similar geographical configurations</h2><span id='topic+geocs_swm'></span>

<h3>Description</h3>

<p>constructing spatial weight matrix based on geocomplexity with similar geographical configurations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geocs_swm(sfj, wt = NULL, style = "B", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geocs_swm_+3A_sfj">sfj</code></td>
<td>
<p>An <code>sf</code> object or spatial vector object that can be converted to <code>sf</code> by <code>sf::st_as_sf()</code>.</p>
</td></tr>
<tr><td><code id="geocs_swm_+3A_wt">wt</code></td>
<td>
<p>(optional) Spatial weight matrix based on spatial adjacency or spatial distance relationships.</p>
</td></tr>
<tr><td><code id="geocs_swm_+3A_style">style</code></td>
<td>
<p>(optional) A character that can be <code>B</code>,<code>W</code>,<code>C</code>.  More to see <code>spdep::nb2mat()</code>.
Default is <code>B</code>.</p>
</td></tr>
<tr><td><code id="geocs_swm_+3A_...">...</code></td>
<td>
<p>(optional) Other parameters passed to <code>geocomplexity::geocs_vector()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>econineq = sf::read_sf(system.file('extdata/econineq.gpkg',package = 'geocomplexity'))
wt_gc = geocs_swm(econineq)
wt_gc[1:5,1:5]

</code></pre>

<hr>
<h2 id='geocs_vector'>geocomplexity for spatial vector data based on geographical similarity</h2><span id='topic+geocs_vector'></span>

<h3>Description</h3>

<p>This function calculates geocomplexity for in spatial vector data based on geographical similarity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geocs_vector(
  sfj,
  wt = NULL,
  method = "spvar",
  similarity = 1,
  normalize = TRUE,
  returnsf = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="geocs_vector_+3A_sfj">sfj</code></td>
<td>
<p>An <code>sf</code> object or spatial vector object that can be converted to <code>sf</code> by <code>sf::st_as_sf()</code>.</p>
</td></tr>
<tr><td><code id="geocs_vector_+3A_wt">wt</code></td>
<td>
<p>(optional) Spatial weight matrix. Must be a <code>matrix</code> class. If <code>wt</code> is not
provided, <code>geocomplexity</code> will use a first-order inverse distance weight matrix via
<code>sdsfun::inverse_distance_swm()</code> function.</p>
</td></tr>
<tr><td><code id="geocs_vector_+3A_method">method</code></td>
<td>
<p>(optional) When <code>method</code> is <code>spvar</code>, variation of the similarity vector is
represented using spatial variance, otherwise shannon information entropy is used. Default
is <code>spvar</code>.</p>
</td></tr>
<tr><td><code id="geocs_vector_+3A_similarity">similarity</code></td>
<td>
<p>(optional) When <code>similarity</code> is <code>1</code>, the similarity is calculated using
geographical configuration similarity, otherwise the cosine similarity is calculated.
Default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="geocs_vector_+3A_normalize">normalize</code></td>
<td>
<p>(optional) Whether to further normalizes the calculated geocomplexity.
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="geocs_vector_+3A_returnsf">returnsf</code></td>
<td>
<p>(optional) When <code>returnsf</code> is <code>TRUE</code>, return an sf object, otherwise a tibble.
Default is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>tibble</code> (<code>returnsf</code> is <code>FALSE</code>) or an <code>sf</code> object (<code>returnsf</code> is <code>TRUE</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>econineq = sf::read_sf(system.file('extdata/econineq.gpkg',package = 'geocomplexity'))
gc = geocs_vector(dplyr::select(econineq,-Gini))
gc

library(ggplot2)
library(viridis)
ggplot(gc) +
   geom_sf(aes(fill = GC)) +
   scale_fill_viridis(option = "mako", direction = -1) +
   theme_bw()

</code></pre>

<hr>
<h2 id='gwr_geoc'>geographical complexity-geographically weighted regression</h2><span id='topic+gwr_geoc'></span>

<h3>Description</h3>

<p>geographical complexity-geographically weighted regression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gwr_geoc(
  formula,
  data,
  gcs = NULL,
  alpha = seq(0.05, 1, 0.05),
  bw = "RMSE",
  adaptive = TRUE,
  kernel = "gaussian"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gwr_geoc_+3A_formula">formula</code></td>
<td>
<p>A formula of <code>GCGWR</code> model.</p>
</td></tr>
<tr><td><code id="gwr_geoc_+3A_data">data</code></td>
<td>
<p>An <code>sf</code> object or spatial vector object that can be converted to <code>sf</code> by <code>sf::st_as_sf()</code>.</p>
</td></tr>
<tr><td><code id="gwr_geoc_+3A_gcs">gcs</code></td>
<td>
<p>(optional) The geocomplexity matrix corresponding to each variable, which is calculated
by default using <code>geocd_vector()</code>.</p>
</td></tr>
<tr><td><code id="gwr_geoc_+3A_alpha">alpha</code></td>
<td>
<p>(optional) Balancing the weights of attribute similarity matrix and geographic distance matrix.</p>
</td></tr>
<tr><td><code id="gwr_geoc_+3A_bw">bw</code></td>
<td>
<p>(optional) The bandwidth used in selecting models. The optimal bandwidth can be selected using one
of three methods: <code>RMSE</code>, <code>AIC</code>, and <code>AICc</code>. Default will use <code>RMSE</code>.</p>
</td></tr>
<tr><td><code id="gwr_geoc_+3A_adaptive">adaptive</code></td>
<td>
<p>(optional) Whether the bandwidth value is adaptive or not. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="gwr_geoc_+3A_kernel">kernel</code></td>
<td>
<p>(optional) Kernel function. Default is <code>gaussian</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with GCGWR results.
</p>

<dl>
<dt><code>SDF</code></dt><dd><p>an sf tibble with coefficients, standard errors and t values</p>
</dd>
<dt><code>diagnostic</code></dt><dd><p>goodness of fit indicators</p>
</dd>
<dt><code>args</code></dt><dd><p>some key parameters</p>
</dd>
</dl>



<h3>Examples</h3>

<pre><code class='language-R'>
## The following code takes a long time to run:
econineq = sf::read_sf(system.file('extdata/econineq.gpkg',package = 'geocomplexity'))
g = gwr_geoc(formula = Gini ~ ., data = econineq,
             alpha = 0.5, bw = "AIC", adaptive = TRUE)
g

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
