<!DOCTYPE html><html><head><title>Help for package decisionSupport</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {decisionSupport}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#decisionSupport-package'><p>Quantitative Support of Decision Making under Uncertainty.</p></a></li>
<li><a href='#as.data.frame.mcSimulation'><p>Coerce Monte Carlo simulation results to a data frame.</p></a></li>
<li><a href='#chance_event'><p>simulate occurrence of random events</p></a></li>
<li><a href='#compound_figure'><p>Compound figure for decision support</p></a></li>
<li><a href='#corMat'><p>Return the Correlation Matrix.</p></a></li>
<li><a href='#corMat+26lt+3B-'><p>Replace correlation matrix.</p></a></li>
<li><a href='#decisionSupport'><p>Welfare Decision and Value of Information Analysis wrapper function.</p></a></li>
<li><a href='#discount'><p>Discount time series for Net Present Value (NPV) calculation</p></a></li>
<li><a href='#empirical_EVPI'><p>Expected value of perfect information (EVPI) for a simple</p>
model with the predictor variable sampled from a normal
distribution with.</a></li>
<li><a href='#estimate'><p>Create a multivariate estimate object.</p></a></li>
<li><a href='#estimate_read_csv'><p>Read an Estimate from CSV - File.</p></a></li>
<li><a href='#estimate_write_csv'><p>Write an Estimate to CSV - File.</p></a></li>
<li><a href='#estimate1d'><p>Create a 1-dimensional estimate object.</p></a></li>
<li><a href='#eviSimulation'><p>Expected Value of Information (EVI) Simulation.</p></a></li>
<li><a href='#gompertz_yield'><p>Gompertz function yield prediction for perennials</p></a></li>
<li><a href='#hist.eviSimulation'><p>Plot Histograms of results of an EVI simulation</p></a></li>
<li><a href='#hist.mcSimulation'><p>Plot Histogram of results of a Monte Carlo Simulation</p></a></li>
<li><a href='#hist.welfareDecisionAnalysis'><p>Plot Histogram of results of a Welfare Decision Analysis</p></a></li>
<li><a href='#individualEvpiSimulation'><p>Individual Expected Value of Perfect Information Simulation</p></a></li>
<li><a href='#make_CPT'><p>Make Conditional Probability tables using the likelihood method</p></a></li>
<li><a href='#mcSimulation'><p>Perform a Monte Carlo simulation.</p></a></li>
<li><a href='#multi_EVPI'><p>Expected value of perfect information (EVPI) for multiple variables. This</p>
is a wrapper for the empirical_EVPI function. See the documentation of the
<code>empirical_EVPI</code> function for more details.</a></li>
<li><a href='#paramtnormci_fit'><p>Fit parameters of truncated normal distribution based on a confidence interval.</p></a></li>
<li><a href='#paramtnormci_numeric'><p>Return parameters of truncated normal distribution based on a confidence interval.</p></a></li>
<li><a href='#plainNames2data.frameNames'><p>Transform model function variable names: plain to data.frame names.</p></a></li>
<li><a href='#plot_cashflow'><p>Cashflow plot for Monte Carlo simulation results</p></a></li>
<li><a href='#plot_distributions'><p>Probability distribution plots for various types of Monte Carlo simulation results</p></a></li>
<li><a href='#plot_evpi'><p>Visualizing the results of Expected Value of Perfect Information (EVPI) analysis for various types of Monte Carlo simulation results</p></a></li>
<li><a href='#plot_pls'><p>Visualizing Projection to Latent Structures (PLS) regression outputs for various types of Monte Carlo simulation results</p></a></li>
<li><a href='#plsr.mcSimulation'><p>Partial Least Squares Regression (PLSR) of Monte Carlo simulation results.</p></a></li>
<li><a href='#print.mcSimulation'><p>Print Basic Results from Monte Carlo Simulation.</p></a></li>
<li><a href='#print.summary.eviSimulation'><p>Print the Summarized EVI Simulation Results.</p></a></li>
<li><a href='#print.summary.mcSimulation'><p>Print the summary of a Monte Carlo simulation.</p></a></li>
<li><a href='#print.summary.welfareDecisionAnalysis'><p>Print the summarized Welfare Decision Analysis results.</p></a></li>
<li><a href='#random'><p>Quantiles or empirically based generic random number generation.</p></a></li>
<li><a href='#random_state'><p>Draw a random state for a categorical variable</p></a></li>
<li><a href='#random.estimate'><p>Generate random numbers for an estimate.</p></a></li>
<li><a href='#random.estimate1d'><p>Generate univariate random numbers defined by a 1-d estimate.</p></a></li>
<li><a href='#rdist90ci_exact'><p>90%-confidence interval based univariate random number generation (by exact parameter</p>
calculation).</a></li>
<li><a href='#rdistq_fit'><p>Quantiles based univariate random number generation (by parameter fitting).</p></a></li>
<li><a href='#rmvnorm90ci_exact'><p>90%-confidence interval multivariate normal random number generation.</p></a></li>
<li><a href='#row.names.estimate'><p>Get and set attributes of an <code>estimate</code> object.</p></a></li>
<li><a href='#rtnorm90ci'><p>90%-confidence interval based truncated normal random number generation.</p></a></li>
<li><a href='#sample_CPT'><p>Sample a Conditional Probability Table</p></a></li>
<li><a href='#sample_simple_CPT'><p>Make Conditional Probability tables using the likelihood method</p></a></li>
<li><a href='#scenario_mc'><p>Perform a Monte Carlo simulation for predefined scenarios.</p></a></li>
<li><a href='#sort.summary.eviSimulation'><p>Sort Summarized EVI Simulation Results..</p></a></li>
<li><a href='#summary.eviSimulation'><p>Summarize EVI Simulation Results</p></a></li>
<li><a href='#summary.mcSimulation'><p>Summarize results from Monte Carlo simulation.</p></a></li>
<li><a href='#summary.welfareDecisionAnalysis'><p>Summarize Welfare Decision Analysis results.</p></a></li>
<li><a href='#temp_situations'><p>Situation occurrence and resolution</p></a></li>
<li><a href='#vv'><p>value varier function</p></a></li>
<li><a href='#welfareDecisionAnalysis'><p>Analysis of the underlying welfare based decision problem.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Quantitative Support of Decision Making under Uncertainty</td>
</tr>
<tr>
<td>Version:</td>
<td>1.114</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-04-08</td>
</tr>
<tr>
<td>Description:</td>
<td>Supporting the quantitative analysis of binary welfare based
    decision making processes using Monte Carlo simulations. Decision support
    is given on two levels: (i) The actual decision level is to choose between
    two alternatives under probabilistic uncertainty. This package calculates
    the optimal decision based on maximizing expected welfare. (ii) The meta
    decision level is to allocate resources to reduce the uncertainty in the
    underlying decision problem, i.e to increase the current information to
    improve the actual decision making process. This problem is dealt with
    using the Value of Information Analysis. The Expected Value of
    Information for arbitrary prospective estimates can be calculated as
    well as Individual Expected Value of Perfect Information.
    The probabilistic calculations are done via Monte Carlo
    simulations. This Monte Carlo functionality can be used on its own.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.3)</td>
</tr>
<tr>
<td>Imports:</td>
<td>assertthat, chillR (&ge; 0.62), class, dplyr, fANCOVA (&ge; 0.5),
ggplot2 (&ge; 3.2.0), grDevices, magrittr, msm (&ge; 1.5), mvtnorm
(&ge; 1.0.2), nleqslv (&ge; 2.6), patchwork, rriskDistributions (&ge;
2.0), stats (&ge; 3.1.3), stringr, tidyr, tidyselect</td>
</tr>
<tr>
<td>Suggests:</td>
<td>eha (&ge; 2.4.2), knitr, mc2d (&ge; 0.1.15), pls (&ge; 2.4.3),
rmarkdown, scales, testthat (&ge; 0.9.1)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.worldagroforestry.org/">http://www.worldagroforestry.org/</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Classification/JEL:</td>
<td>I38, O16, O21, O22, O23</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Collate:</td>
<td>'as.data.frame.mcSimulation.R' 'chance_event.R'
'compound_figure.R' 'paramtnormci_fit.R'
'paramtnormci_numeric.R' 'rtnorm90ci.R' 'rdistq_fit.R'
'rdist90ci_exact.R' 'estimate1d.R' 'random.R'
'rmvnorm90ci_exact.R' 'estimate.R' 'mcSimulation.R'
'welfareDecisionAnalysis.R' 'eviSimulation.R'
'individualEvpiSimulation.R' 'estimate_read_csv_old.R'
'decisionSupport.R' 'decisionSupport-package.R' 'discount.R'
'empirical_EVPI.R' 'global_variables.R' 'gompertz_yield.R'
'hist.mcSimulation.R' 'make_CPT.R' 'multi_EVPI.R'
'plainNames2data.frameNames.R' 'plot_cashflow.R'
'plot_distributions.R' 'plot_evpi.R' 'plot_pls.R'
'plsr.mcSimulation.R' 'print.mcSimuation.R'
'print.summary.mcSimulation.R' 'random_state.R' 'sample_CPT.R'
'sample_simple_CPT.R' 'scenario_mc.R' 'summary.mcSimulation.R'
'temp_situations.R' 'vv.R'</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-08 14:59:39 UTC; luede</td>
</tr>
<tr>
<td>Author:</td>
<td>Eike Luedeling [cre, aut] (University of Bonn),
  Lutz Goehring [aut] (ICRAF and Lutz Goehring Consulting),
  Katja Schiffers [aut] (University of Bonn),
  Cory Whitney [aut] (University of Bonn),
  Eduardo Fernandez [aut] (University of Bonn)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Eike Luedeling &lt;eike@eikeluedeling.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-08 15:20:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='decisionSupport-package'>Quantitative Support of Decision Making under Uncertainty.</h2><span id='topic+decisionSupport-package'></span>

<h3>Description</h3>

<p>The <span class="pkg"><code>decisionSupport</code></span> package supports the quantitative analysis of 
welfare based decision making processes using Monte Carlo simulations. This
is an important part of the Applied Information Economics (AIE) approach
developed in Hubbard (2014). These decision making processes can be
categorized into two levels of decision making:
</p>
 
<ol>
<li><p> The actual problem of interest of a policy maker
which we call the <em>underlying welfare based decision</em> on how to influence an
ecological-economic system based on a particular information on the system
available to the decision maker and 
</p>
</li>
<li><p> the <em>meta decision</em> on how to allocate resources to reduce the
uncertainty in the underlying decision problem, i.e to increase the current
information to improve the underlying decision making process.
</p>
</li></ol>
 
<p>The first problem, i.e. the underlying problem, is the problem of choosing
the decision which maximizes expected welfare. The welfare function can be
interpreted as a von Neumann-Morgenstern utility function. Whereas, the
second problem, i.e. the meta decision problem, is dealt with using the
<em>Value of Information Analysis (VIA)</em>. Value of Information Analysis
seeks to assign a value to a certain reduction in uncertainty or,
equivalently, increase in information. Uncertainty is dealt with in a
probabilistic manner. Probabilities are transformed via Monte Carlo
simulations.
</p>


<h3>Details</h3>

<p>The functionality of this package is subdivided into three main parts: (i) the
welfare based analysis of the underlying decision, (ii) the meta decision of
reducing uncertainty and (iii) the Monte Carlo simulation for the
transformation of probabilities and calculation of expectation values. Furthermore, 
there is a wrapper function around these three parts which aims at providing an 
easy-to-use interface.
</p>


<h4>Welfare based Analysis of the Underlying Decision Problem</h4>

<p>Implementation: <code><a href="#topic+welfareDecisionAnalysis">welfareDecisionAnalysis</a></code>
</p>



<h4>The Meta Decision of Reducing Uncertainty</h4>

 
<p>The meta decision of how to allocate resources for uncertainty reduction can
be analyzed with this package in two different ways: via (i) Expected Value
of Information Analysis or (ii) via Partial Least Squares (PLS) analysis and
Variable Importance in Projection (VIP).
</p>


<h5>Expected Value of Information (EVI)</h5>

<p>Implementation: <code><a href="#topic+eviSimulation">eviSimulation</a></code>, <code><a href="#topic+individualEvpiSimulation">individualEvpiSimulation</a></code>
</p>



<h5>Partial Least Squares (PLS) analysis and Variable Importance in Projection (VIP)</h5>

<p>Implementation: <code><a href="#topic+plsr.mcSimulation">plsr.mcSimulation</a></code>, <code><a href="chillR.html#topic+VIP">VIP</a></code>
</p>




<h4>Solving the Practical Problem of Calculating Expectation Values by Monte Carlo Simulation</h4>



<h5>Estimates</h5>

<p>Implementation: <code><a href="#topic+estimate">estimate</a></code>
</p>



<h5>Multivariate Random Number Generation</h5>

<p>Implementation: <code><a href="#topic+random.estimate">random.estimate</a></code>
</p>



<h5>Monte Carlo Simulation</h5>

<p>Implementation: <code><a href="#topic+mcSimulation">mcSimulation</a></code>
</p>




<h4>Integrated Welfare Decision and Value of Information Analysis: A wrapper function</h4>

<p>The function <code><a href="#topic+decisionSupport">decisionSupport</a></code> integrates the most important features of this 
package into a single function. It is wrapped arround the functions 
<code><a href="#topic+welfareDecisionAnalysis">welfareDecisionAnalysis</a></code>, <code><a href="#topic+plsr.mcSimulation">plsr.mcSimulation</a></code>, 
<code><a href="chillR.html#topic+VIP">VIP</a></code> and <code><a href="#topic+individualEvpiSimulation">individualEvpiSimulation</a></code>.
</p>



<h3>Development history</h3>

<p>This package was initially developed at the
<a href="http://www.worldagroforestry.org/">World Agroforestry Centre (ICRAF)</a>.
Since April 2018, it is maintained by the
<a href="https://www.gartenbauwissenschaft.uni-bonn.de/">Horticultural Sciences group (HortiBonn)</a>
at the <a href="https://www.uni-bonn.de/en">University of Bonn</a>.
</p>


<h3>License</h3>

<p>The R-package <span class="pkg">decisionSupport</span> is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or
(at your option) any later version: 
<a href="http://www.gnu.org/licenses/gpl-3.0.html">GNU GENERAL PUBLIC LICENSE, Version 3 (GPL-3)</a>
</p>
<p>The R-package <span class="pkg">decisionSupport</span> is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.
</p>
<p>You should have received a copy of the GNU General Public License
along with the R-package decisionSupport.  If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling (<a href="http://www.eikeluedeling.com/index.html">personal website</a>) <a href="mailto:eike@eikeluedeling.com">eike@eikeluedeling.com</a>,
Lutz Göhring <a href="mailto:lutz.goehring@gmx.de">lutz.goehring@gmx.de</a>,
Katja Schiffers <a href="mailto:katja.schiffers@uni-bonn.de">katja.schiffers@uni-bonn.de</a>
</p>
<p>Maintainer: Eike Luedeling <a href="mailto:eike@eikeluedeling.com">eike@eikeluedeling.com</a>
</p>


<h3>References</h3>

<p>Hubbard, Douglas W., <em>How to Measure Anything? - Finding the Value of &quot;Intangibles&quot; in Business</em>,
John Wiley &amp; Sons, Hoboken, New Jersey, 2014, 3rd Ed, <a href="https://www.howtomeasureanything.com/">https://www.howtomeasureanything.com/</a>.
</p>
<p>Hugh Gravelle and Ray Rees, <em>Microeconomics</em>, Pearson Education Limited, 3rd edition, 2004.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+welfareDecisionAnalysis">welfareDecisionAnalysis</a></code>, <code><a href="#topic+eviSimulation">eviSimulation</a></code>, <code><a href="#topic+mcSimulation">mcSimulation</a></code>
</p>

<hr>
<h2 id='as.data.frame.mcSimulation'>Coerce Monte Carlo simulation results to a data frame.</h2><span id='topic+as.data.frame.mcSimulation'></span>

<h3>Description</h3>

<p>Coerces Monte Carlo simulation results to a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcSimulation'
as.data.frame(
  x,
  row.names = NULL,
  optional = FALSE,
  ...,
  stringsAsFactors = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.mcSimulation_+3A_x">x</code></td>
<td>
<p>An object of class <code>mcSimulation</code>.</p>
</td></tr>
<tr><td><code id="as.data.frame.mcSimulation_+3A_row.names">row.names</code></td>
<td>
<p><code>NULL</code> or a character vector giving the row
names for the data frame.  Missing values are not allowed.</p>
</td></tr>
<tr><td><code id="as.data.frame.mcSimulation_+3A_optional">optional</code></td>
<td>
<p>logical. If <code>TRUE</code>, setting row names and
converting column names (to syntactic names: see
<code><a href="base.html#topic+make.names">make.names</a></code>) is optional.  Note that all of <span class="rlang"><b>R</b></span>'s
<span class="pkg">base</span> package <code>as.data.frame()</code> methods use
<code>optional</code> only for column names treatment, basically with the
meaning of <code><a href="base.html#topic+data.frame">data.frame</a>(*, check.names = !optional)</code>.
See also the <code>make.names</code> argument of the <code>matrix</code> method.</p>
</td></tr>
<tr><td><code id="as.data.frame.mcSimulation_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="as.data.frame.mcSimulation_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>logical: should the character vector be converted
to a factor?</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+as.data.frame">as.data.frame</a></code>
</p>

<hr>
<h2 id='chance_event'>simulate occurrence of random events</h2><span id='topic+chance_event'></span>

<h3>Description</h3>

<p>In many simulations, certain events can either occur or not, and values for
dependent variables can depend on which of the cases occurs. This function
randomly simulates whether events occur and returns output values
accordingly. The outputs can be single values or series of values, with the
option of introducing artificial variation into this dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chance_event(
  chance,
  value_if = 1,
  value_if_not = 0,
  n = 1,
  CV_if = 0,
  CV_if_not = CV_if,
  one_draw = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chance_event_+3A_chance">chance</code></td>
<td>
<p>probability that the risky event will occur (between 0 and 1)</p>
</td></tr>
<tr><td><code id="chance_event_+3A_value_if">value_if</code></td>
<td>
<p>output value in case the event occurs. This can be either a
single numeric value or a numeric vector. Defaults to 1.</p>
</td></tr>
<tr><td><code id="chance_event_+3A_value_if_not">value_if_not</code></td>
<td>
<p>output value in case the event does not occur. This can
be either a single numeric value or a numeric vector. If it is a vector, it
must have the same length as value_if</p>
</td></tr>
<tr><td><code id="chance_event_+3A_n">n</code></td>
<td>
<p>number of times the risky event is simulated. This is ignored if
length(value_if)&gt;1.</p>
</td></tr>
<tr><td><code id="chance_event_+3A_cv_if">CV_if</code></td>
<td>
<p>coefficient of variation for introducing randomness into the
value_if data set. This defaults to 0 for no artificial variation. See
documentation for the vv function for details.</p>
</td></tr>
<tr><td><code id="chance_event_+3A_cv_if_not">CV_if_not</code></td>
<td>
<p>coefficient of variation for introducing randomness into
the value_if_not data set. This defaults to the value for CV_if. See
documentation for the vv function for details.</p>
</td></tr>
<tr><td><code id="chance_event_+3A_one_draw">one_draw</code></td>
<td>
<p>boolean coefficient indicating if event occurrence is
determined only once (TRUE) with results applying to all elements of the
results vector, or if event occurrence is determined independently for each
element (FALSE; the default)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector of the same length as value_if or, if
length(value_if)==1 of length n, containing outputs of a probabilistic
simulation that assigns value_if if the event occurs, or value_if_not if is
does not occur (both optionally with artificial variation)
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
chance_event(0.6,6)
 
chance_event(.5,c(0,5),c(5,6))

chance_event(chance=0.5,
             value_if=1,
             value_if_not=5,
             n=10,
             CV_if=20)

</code></pre>

<hr>
<h2 id='compound_figure'>Compound figure for decision support</h2><span id='topic+compound_figure'></span>

<h3>Description</h3>

<p>Simple compound figure of model results and analyses of a binary decision 
(do or do not do). The figure includes the distribution of the expected outcome, 
the expected cashflow, as well as the variable importance and the value of information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compound_figure(
  model = NULL,
  input_table,
  decision_var_name,
  cashflow_var_name,
  model_runs = 10000,
  distribution_method = "smooth_simple_overlay",
  mcSimulation_object = NULL,
  plsrResults = NULL,
  EVPIresults = NULL,
  x_axis_name_distribution = "Outcome distribution",
  y_axis_name_distribution = NULL,
  x_axis_name_cashflow = "Timeline of intervention",
  y_axis_name_cashflow = "Cashflow",
  legend_name_cashflow = "Quantiles (%)",
  legend_labels_cashflow = c("5 to 95", "25 to 75", "median"),
  x_axis_name_pls = "Variable Importance in Projection",
  y_axis_name_pls = NULL,
  legend_name_pls = "Coefficient",
  legend_labels_pls = c("Positive", "Negative"),
  x_axis_name_evpi = "Expected Value of Perfect Information",
  y_axis_name_evpi = NULL,
  base_size = 11
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compound_figure_+3A_model">model</code></td>
<td>
<p>is a user defined model function see the <code><a href="#topic+mcSimulation">mcSimulation</a></code> function. Either 'model' or 'mcSimulation_object' must be provided. If both are given then 'model' has precedence and the model will be calculated for the figure</p>
</td></tr>
<tr><td><code id="compound_figure_+3A_input_table">input_table</code></td>
<td>
<p>is a data frame with at least two columns named 'variable' and 'label'. The 'variable column should have one entry for the name of each variable contained in any of the plots. In preparing the figure, the function will replace the variable names with the labels. If the label is missing then the plot will show 'NA' in the place of the variable name. Default is NULL and uses the original variable names.</p>
</td></tr>
<tr><td><code id="compound_figure_+3A_decision_var_name">decision_var_name</code></td>
<td>
<p>is the name of the decision outcome named in the <code>return()</code> of 'model'. This will be used in all plots and analyses except for the cashflow plot. For now this is just one decision option</p>
</td></tr>
<tr><td><code id="compound_figure_+3A_cashflow_var_name">cashflow_var_name</code></td>
<td>
<p>is the name of the cashflow variable named in the <code>return()</code> of 'model'. This will be used in the cashflow plot</p>
</td></tr>
<tr><td><code id="compound_figure_+3A_model_runs">model_runs</code></td>
<td>
<p>is the number of time that the model should run. The default is 10,000</p>
</td></tr>
<tr><td><code id="compound_figure_+3A_distribution_method">distribution_method</code></td>
<td>
<p>is the method used in the distribution plot see the <code><a href="#topic+plot_distributions">plot_distributions</a></code> function</p>
</td></tr>
<tr><td><code id="compound_figure_+3A_mcsimulation_object">mcSimulation_object</code></td>
<td>
<p>is an object of Monte Carlo simulation outputs from the <code><a href="#topic+mcSimulation">mcSimulation</a></code> function</p>
</td></tr>
<tr><td><code id="compound_figure_+3A_plsrresults">plsrResults</code></td>
<td>
<p>is an object of Projection to Latent Structures (PLS) regression outputs from the <code><a href="#topic+plsr.mcSimulation">plsr.mcSimulation</a></code> function</p>
</td></tr>
<tr><td><code id="compound_figure_+3A_evpiresults">EVPIresults</code></td>
<td>
<p>are the results of the <code><a href="#topic+multi_EVPI">multi_EVPI</a></code> function</p>
</td></tr>
<tr><td><code id="compound_figure_+3A_x_axis_name_distribution">x_axis_name_distribution</code>, <code id="compound_figure_+3A_y_axis_name_distribution">y_axis_name_distribution</code>, <code id="compound_figure_+3A_x_axis_name_cashflow">x_axis_name_cashflow</code>, <code id="compound_figure_+3A_y_axis_name_cashflow">y_axis_name_cashflow</code>, <code id="compound_figure_+3A_x_axis_name_pls">x_axis_name_pls</code>, <code id="compound_figure_+3A_y_axis_name_pls">y_axis_name_pls</code>, <code id="compound_figure_+3A_x_axis_name_evpi">x_axis_name_evpi</code>, <code id="compound_figure_+3A_y_axis_name_evpi">y_axis_name_evpi</code></td>
<td>
<p>are the names (character strings) to pass to the axis titles for the respective plots (distribution, cashflow, pls, evpi)</p>
</td></tr>
<tr><td><code id="compound_figure_+3A_legend_name_cashflow">legend_name_cashflow</code>, <code id="compound_figure_+3A_legend_name_pls">legend_name_pls</code></td>
<td>
<p>are the names (character strings) representing the title of the legend</p>
</td></tr>
<tr><td><code id="compound_figure_+3A_legend_labels_cashflow">legend_labels_cashflow</code>, <code id="compound_figure_+3A_legend_labels_pls">legend_labels_pls</code></td>
<td>
<p>are the names (character strings) representing the labels of the legend</p>
</td></tr>
<tr><td><code id="compound_figure_+3A_base_size">base_size</code></td>
<td>
<p>is the base text size to be used for the plot. The default is 11, this is the <code><a href="ggplot2.html#topic+ggtheme">ggplot2::ggtheme</a></code> default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a plot of classes <code>'patchwork'</code>, <code>'gg'</code>, 
and <code>'ggplot'</code>. This allows the user to
continue editing some features of the plots through the syntax (i.e. <code>'&amp;'</code>,
and <code>'+'</code>) from both libraries.
</p>


<h3>Author(s)</h3>

<p>Eduardo Fernandez (<a href="mailto:efernand@uni-bonn.de">efernand@uni-bonn.de</a>)
</p>
<p>Cory Whitney (<a href="mailto:cory.whitney@uni-bonn.de">cory.whitney@uni-bonn.de</a>)
</p>


<h3>References</h3>

<p>Do, Hoa, Eike Luedeling, and Cory Whitney. “Decision Analysis of Agroforestry Options Reveals Adoption Risks for Resource-Poor Farmers.” Agronomy for Sustainable Development 40, no. 3 (June 2020): 20. <a href="https://doi.org/10.1007/s13593-020-00624-5">doi:10.1007/s13593-020-00624-5</a>.
Lanzanova, Denis, Cory Whitney, Keith Shepherd, and Eike Luedeling. “Improving Development Efficiency through Decision Analysis: Reservoir Protection in Burkina Faso.” Environmental Modelling &amp; Software 115 (May 1, 2019): 164–75. <a href="https://doi.org/10.1016/j.envsoft.2019.01.016">doi:10.1016/j.envsoft.2019.01.016</a>.
Ruett, Marius, Cory Whitney, and Eike Luedeling. “Model-Based Evaluation of Management Options in Ornamental Plant Nurseries.” Journal of Cleaner Production 271 (June 2020): 122653. <a href="https://doi.org/10.1016/j.jclepro.2020.122653">doi:10.1016/j.jclepro.2020.122653</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##############################################################
# Example 1 (Creating the estimate from the command line):
#############################################################
# Create the estimate object:

cost_benefit_table &lt;- data.frame(label = c("Revenue", "Costs"),
                                  variable = c("revenue", "costs"),
                                  distribution = c("norm", "norm"),
                                  lower = c(100,  500),
                                  median = c(NA, NA),
                                  upper = c(10000, 5000))

# (a) Define the model function without name for the return value:

profit1 &lt;- function() {
  Decision &lt;- revenue - costs
  cashflow &lt;- rnorm(rep(revenue, 20))
  return(list(Revenues = revenue,
              Costs = costs, 
              cashflow = cashflow, 
              Decision = Decision))
}

compound_figure(model = profit1, 
input_table = cost_benefit_table, 
decision_var_name = "Decision",
cashflow_var_name = "cashflow",
model_runs = 1e2, 
distribution_method = 'smooth_simple_overlay')

</code></pre>

<hr>
<h2 id='corMat'>Return the Correlation Matrix.</h2><span id='topic+corMat'></span>

<h3>Description</h3>

<p>Return the correlation matrix of rho.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corMat(rho)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corMat_+3A_rho">rho</code></td>
<td>
<p>a distribution.</p>
</td></tr>
</table>

<hr>
<h2 id='corMat+26lt+3B-'>Replace correlation matrix.</h2><span id='topic+corMat+3C-'></span>

<h3>Description</h3>

<p>Replace the correlation matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corMat(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corMat+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>a distribution.</p>
</td></tr>
<tr><td><code id="corMat+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p><code>numeric matrix</code>: new correlation matrix.</p>
</td></tr>
</table>

<hr>
<h2 id='decisionSupport'>Welfare Decision and Value of Information Analysis wrapper function.</h2><span id='topic+decisionSupport'></span>

<h3>Description</h3>

<p>This function performs a Welfare Decision Analysis via a Monte Carlo simulation from input files
and analyses the value of different information about the input variables. This value of
information analysis can be done via combined PLSR - VIP analysis or via IndividualEVPI
calculation. Results are saved as plots and tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decisionSupport(
  inputFilePath,
  outputPath,
  welfareFunction,
  numberOfModelRuns,
  randomMethod = "calculate",
  functionSyntax = "data.frameNames",
  relativeTolerance = 0.05,
  write_table = TRUE,
  plsrVipAnalysis = TRUE,
  individualEvpiNames = NULL,
  sortEvpiAlong = if (individualEvpiNames) individualEvpiNames[[1]] else NULL,
  oldInputStandard = FALSE,
  verbosity = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decisionSupport_+3A_inputfilepath">inputFilePath</code></td>
<td>
<p>Path to input csv file, which gives the input <code><a href="#topic+estimate">estimate</a></code>.</p>
</td></tr>
<tr><td><code id="decisionSupport_+3A_outputpath">outputPath</code></td>
<td>
<p>Path where the result plots and tables are saved.</p>
</td></tr>
<tr><td><code id="decisionSupport_+3A_welfarefunction">welfareFunction</code></td>
<td>
<p>The welfare function.</p>
</td></tr>
<tr><td><code id="decisionSupport_+3A_numberofmodelruns">numberOfModelRuns</code></td>
<td>
<p>The number of running the welfare model for the underlying Monte Carlo 
simulation.</p>
</td></tr>
<tr><td><code id="decisionSupport_+3A_randommethod">randomMethod</code></td>
<td>
<p><code>character</code>: The method to be used to sample the distribution
representing the input estimate. For details see option <code>method</code> in 
<code><a href="#topic+random.estimate">random.estimate</a></code>.</p>
</td></tr>
<tr><td><code id="decisionSupport_+3A_functionsyntax">functionSyntax</code></td>
<td>
<p><code>character</code>: function syntax used in the welfare function(s). For 
details see <code><a href="#topic+mcSimulation">mcSimulation</a></code>.</p>
</td></tr>
<tr><td><code id="decisionSupport_+3A_relativetolerance">relativeTolerance</code></td>
<td>
<p><code>numeric</code>: the relative tolerance level of deviation of the
generated confidence interval from the specified interval. If this deviation is greater than
<code>relativeTolerance</code> a warning is given.</p>
</td></tr>
<tr><td><code id="decisionSupport_+3A_write_table">write_table</code></td>
<td>
<p><code>logical</code>: If the full Monte Carlo simulation results and PLSR results should be
written to file.</p>
</td></tr>
<tr><td><code id="decisionSupport_+3A_plsrvipanalysis">plsrVipAnalysis</code></td>
<td>
<p><code>logical</code>: If PLSR-VIP analysis shall be performed.</p>
</td></tr>
<tr><td><code id="decisionSupport_+3A_individualevpinames">individualEvpiNames</code></td>
<td>
<p><code>character vector</code>: names of variables, which for the 
IndividualEVPI shall be obtained via Monte Carlo simulation. If <code>=NULL</code> (the default), no 
IndividualEVPI is calculated; if <code>="all"</code>, the IndividualEVPI is calculated for all
variables. <dfn>Note:</dfn> depending on <code>numberOfModelRuns</code> and the complexity of
<code>welfare</code> this might take a long time.</p>
</td></tr>
<tr><td><code id="decisionSupport_+3A_sortevpialong">sortEvpiAlong</code></td>
<td>
<p><code>character</code>: result name along which the summary of the IndividualEVPI
shall be sorted. Only relevant if <code>sortEvpiAlong!=NULL</code>.</p>
</td></tr>
<tr><td><code id="decisionSupport_+3A_oldinputstandard">oldInputStandard</code></td>
<td>
<p><code>logical</code>: If the old input standard should be used
(<code><a href="#topic+estimate_read_csv_old">estimate_read_csv_old</a></code>).</p>
</td></tr>
<tr><td><code id="decisionSupport_+3A_verbosity">verbosity</code></td>
<td>
<p><code>integer</code>: if <code>0</code> the function is silent; the larger the value the
more verbose is output information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function integrates the most important features of  
<a href="#topic+decisionSupport-package">this package</a> into a single function. It is wrapped arround the functions 
<code><a href="#topic+welfareDecisionAnalysis">welfareDecisionAnalysis</a></code>, <code><a href="#topic+plsr.mcSimulation">plsr.mcSimulation</a></code>, 
<code><a href="chillR.html#topic+VIP">VIP</a></code> and <code><a href="#topic+individualEvpiSimulation">individualEvpiSimulation</a></code>.
</p>


<h4>Combined PLSR - VIP Analysis</h4>

<p>The combined Partial Least Squares Regression (PLSR) and Variables Importance in Projection 
(VIP) analysis is implemented via: <code><a href="#topic+plsr.mcSimulation">plsr.mcSimulation</a></code> and 
<code><a href="chillR.html#topic+VIP">VIP</a></code>.
</p>



<h4>IndividualEVPI Calculation</h4>

<p>Implementation: <code><a href="#topic+individualEvpiSimulation">individualEvpiSimulation</a></code>
</p>



<h3>See Also</h3>

<p><code><a href="#topic+mcSimulation">mcSimulation</a></code>, <code><a href="#topic+estimate">estimate</a></code>, <code><a href="#topic+estimate_read_csv">estimate_read_csv</a></code>, 
<code><a href="#topic+plsr.mcSimulation">plsr.mcSimulation</a></code>, <code><a href="chillR.html#topic+VIP">VIP</a></code>, 
<code><a href="#topic+welfareDecisionAnalysis">welfareDecisionAnalysis</a></code>, <code><a href="#topic+individualEvpiSimulation">individualEvpiSimulation</a></code>, 
<code><a href="#topic+decisionSupport-package">decisionSupport-package</a></code>
</p>

<hr>
<h2 id='discount'>Discount time series for Net Present Value (NPV) calculation</h2><span id='topic+discount'></span>

<h3>Description</h3>

<p>This function discounts values along a time series, applying the specified
discount rate. It can also calculate the Net Present Value (NPV), which is
the sum of these discounted values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discount(x, discount_rate, calculate_NPV = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discount_+3A_x">x</code></td>
<td>
<p>numeric vector, typically containing time series data of costs or
benefits</p>
</td></tr>
<tr><td><code id="discount_+3A_discount_rate">discount_rate</code></td>
<td>
<p>numeric; the discount rate (in percent), expressing the
time preference of whoever is evaluating these data economically</p>
</td></tr>
<tr><td><code id="discount_+3A_calculate_npv">calculate_NPV</code></td>
<td>
<p>boolean; if set to TRUE, the discounted time values are
summed, otherwise, they are returned as a vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If calculate_NPV=TRUE, the function returns the Net Present Value
(NPV) as a numeric value. If calculate_NPV=FALSE, the time-discounted values
are returned as a numeric vector.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x&lt;-c(3,6,2,5,4,3,9,0,110)
discount_rate&lt;-5

discount(x,discount_rate)
discount(x,discount_rate,calculate_NPV=TRUE)


</code></pre>

<hr>
<h2 id='empirical_EVPI'>Expected value of perfect information (EVPI) for a simple
model with the predictor variable sampled from a normal
distribution with.</h2><span id='topic+empirical_EVPI'></span><span id='topic+summary.EVPI_res'></span><span id='topic+summary_empirical_EVPI'></span><span id='topic+plot.EVPI_res'></span><span id='topic+plot_empirical_EVPI'></span>

<h3>Description</h3>

<p>The Expected Value of Perfect Information is a concept in
decision analysis. It measures the expected loss of gain
(expected opportunity loss, EOL) that is incurred because
the decision-maker does not have perfect information
about a paricular variable. It is determined by examining
the influence of that variable on the output value of a
decision model. Its value is best illustrated by a plot
of weighed decision outcomes as a function of the
variable in question. If this curve intersects zero and
the recommendation without perfect information is to go
ahead with the project, the EVPI is the negative area
under the curve, or the positive area if the
recommendation is not to go ahead. If there is no
intersection point, the EVPI is zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>empirical_EVPI(mc, test_var_name, out_var_name)

## S3 method for class 'EVPI_res'
summary(object, ...)

## S3 method for class 'EVPI_res'
plot(x, res = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="empirical_EVPI_+3A_mc">mc</code></td>
<td>
<p>output table from a Monte Carlo simulation,
e.g. as realized with the decisionSupport package</p>
</td></tr>
<tr><td><code id="empirical_EVPI_+3A_test_var_name">test_var_name</code></td>
<td>
<p>character; name of an independent
variable in mc, sampled from a normal distribution</p>
</td></tr>
<tr><td><code id="empirical_EVPI_+3A_out_var_name">out_var_name</code></td>
<td>
<p>character; name of a dependent
variable in mc</p>
</td></tr>
<tr><td><code id="empirical_EVPI_+3A_object">object</code></td>
<td>
<p>EVPI_res object (produced with
empirical_EVPI) as input to the summary function.</p>
</td></tr>
<tr><td><code id="empirical_EVPI_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods, such as
graphical parameters (see par).</p>
</td></tr>
<tr><td><code id="empirical_EVPI_+3A_x">x</code></td>
<td>
<p>EVPI_res object (produced with empirical_EVPI)
as input to the plotting function.</p>
</td></tr>
<tr><td><code id="empirical_EVPI_+3A_res">res</code></td>
<td>
<p>boolean parameter indicating whether the plot
function should output a plot of opportunity losses and
gains  (res = TRUE) or a plot of the original data with
the loess prediction (res = FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The EVPI is often calculated by assuming that all
variables except the one being tested take their best
estimate. This makes it possible to calculate the EVPI
very quickly, but at a high price: the assumption that
many variables simply take their best value ignores
uncertainties about all these variables. In the present
implementation, this problem is addressed by using the
outputs of a Monte Carlo simulation and assessing the
EVPI empirically. In the first step, the output variable
is smoothed using a loess regression with an automated
optimization of the bandwidth parameter, based on a
generalized cross validation procedure. Then the values
are weighted according to the probability density
function that has been used for Monte Carlo sampling
(i.e. a normal distribution, with mean and standard
deviation being estimated automatically) and the
resulting positive and negative areas under the curve are
calculated. After this, the expected gain (exptected mean
value - EMV) without perfect information (PI) is
calculated, the recommendation whether to go ahead with
the project without PI determine and the EVPI returned by
the function.
</p>


<h3>Value</h3>

<p>list of 11 elements: 
(1) expected_gain: expected gain when project is
implemented, without knowing the value of the test
variable, equals NA when there is no variation in the
output variable (2) recommendation: should project be
implemented? Decision without knowing the value of the
test variable (3) EVPI_do: the Expected Value of
Perfect Information (EVPI) for this variable, if the
recommended decision is to implement the project. (4)
EVPI_dont: the Expected Value of Perfect Information
(EVPI) for this variable, if the recommended decision
is not to implement the project. (5) tests_var_data:
values of the test variable (6) out_var_data: values of
the outcome variable (7) out_var_sm: results of loess
regression = smoothed outcome variable (8) weight:
values by which smoothed outcome variable is weighted
(9) out_var_weight: smoothed and weighted outcome
variable (10) test_var_name: variable name of test data
(11) out_var_name: variable name of outcome data
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling, Katja Schiffers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

### In the following example, the sign of the calculation
### is entirely determined by the predictor variable
### 'indep1', so this should be expected to have a high
### EVPI.

montecarlo &lt;- data.frame(indep1 = rnorm(1000), indep2 = rlnorm(1000))
montecarlo[, 'output1'] &lt;- montecarlo[, 'indep1'] * montecarlo[, 'indep2']

evpi1 &lt;- empirical_EVPI(mc = montecarlo, test_var_name = 'indep1', out_var_name = 'output1')
summary(evpi1)
plot(evpi1, res = FALSE)
plot(evpi1, res = TRUE)


### In this example, the sign of the output variable does not change depending on the
### predictor variable 'indep1' so the EVPI should be zero.
montecarlo[, 'output2'] &lt;- (montecarlo[, 'indep1'] * (montecarlo[, 'indep2']) + 10)
evpi2 &lt;- empirical_EVPI(mc = montecarlo, test_var_name = 'indep1', out_var_name = 'output2')
summary(evpi2)
plot(evpi2, res = FALSE)
plot(evpi2, res = TRUE)
</code></pre>

<hr>
<h2 id='estimate'>Create a multivariate estimate object.</h2><span id='topic+estimate'></span><span id='topic+as.estimate'></span>

<h3>Description</h3>

<p><code>estimate</code> creates an object of <code>class estimate</code>. The concept of an estimate is 
extended from the 1-dimensional (cf. <code><a href="#topic+estimate1d">estimate1d</a></code>) to the multivariate case. This 
includes the description of correlations between the different variables. An estimate of an 
n-dimensional variable is at minimum defined by each component being a 1-dimensional estimate. 
This means, that for each component, at minimum, the  type of its univariate parametric 
distribution, its 5% - and 95% quantiles must be provided. In probability theoretic terms, 
these are the marginal distributions of the components. Optionally, the individual median 
and the correlations between the components can be supplied.
</p>
<p><code>as.estimate</code> tries to coerce a set of objects and transform them to <code>class estimate</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate(distribution, lower, upper, ..., correlation_matrix = NULL)

as.estimate(..., correlation_matrix = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_+3A_distribution">distribution</code></td>
<td>
<p><code>character vector</code>: defining the types of the univariate parametric 
distributions.</p>
</td></tr>
<tr><td><code id="estimate_+3A_lower">lower</code></td>
<td>
<p><code>numeric vector</code>: lower bounds of the 90% confidence intervals, i.e the 5%-quantiles 
of this estimates components.</p>
</td></tr>
<tr><td><code id="estimate_+3A_upper">upper</code></td>
<td>
<p><code>numeric vector</code>: upper bounds of the 90% confidence intervals, i.e the 95%-quantiles
of this estimates components.</p>
</td></tr>
<tr><td><code id="estimate_+3A_...">...</code></td>
<td>
<p>in <code>estimate</code>: optional arguments that can be coerced to a data frame comprising
further columns of the estimate (for details cf. below).<br />
in <code>as.estimate</code>: arguments that can be coerced to a data frame comprising the 
marginal distributions of the estimate components. Mandatory columns are <code>distribution</code>, <code>lower</code> and 
<code>upper</code>.</p>
</td></tr>
<tr><td><code id="estimate_+3A_correlation_matrix">correlation_matrix</code></td>
<td>
<p><code>numeric matrix</code>: containing the correlations of the variables 
(optional).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input arguments inform the estimate about its marginal distributions and joint distribution, i.e.
the correlation matrix.
</p>


<h4>The structure of the estimates marginal input information</h4>


<dl>
<dt>in <code>estimate</code></dt><dd>
<p>The marginal distributions are defined by the arguments <code>distribution</code>, <code>lower</code>
and <code>upper</code> and, optionally, by further columns supplied in <code>...</code> that can be 
coerced to a <code><a href="base.html#topic+data.frame">data.frame</a></code> with the same length as the mandatory arguments.
</p>
</dd>
<dt>in <code>as.estimate</code></dt><dd>
<p>The marginal distributions are completely defined in <code>...</code>. These arguments must be 
coercible to a data.frame, all having the same length. Mandatory columns are 
<code>distribution</code>, <code>lower</code> and  <code>upper</code>. 
</p>
</dd>
</dl>



<h5>Mandatory input columns</h5>


<table>
<tr>
 <td style="text-align: left;">
      <b>Column</b>       </td><td style="text-align: left;">  <b>R-type</b>    </td><td style="text-align: left;"> <b>Explanation</b></td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>distribution</code> </td><td style="text-align: left;">  <code>character vector</code> </td><td style="text-align: left;">  Marginal distribution types </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>lower</code>        </td><td style="text-align: left;">  <code>numeric vector</code>   </td><td style="text-align: left;">  Marginal 5%-quantiles </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>upper</code>        </td><td style="text-align: left;">  <code>numeric vector</code>   </td><td style="text-align: left;">  Marginal 95%-quantiles 
    </td>
</tr>

</table>

<p>It must hold that <code>lower &lt;= upper</code> for every component of the estimate.  
</p>



<h5>Optional input columns</h5>

<p>The optional parameters in <code>...</code> provide additional characteristics of the marginal 
distributions of the estimate. Frequent optional columns are:
</p>

<table>
<tr>
 <td style="text-align: left;">
      <b>Column</b>       </td><td style="text-align: left;">  <b>R-type</b>                 </td><td style="text-align: left;"> <b>Explanation</b></td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>variable</code>     </td><td style="text-align: left;">  <code>character vector</code>       </td><td style="text-align: left;">  Variable names</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>median</code>       </td><td style="text-align: left;">  cf. below                     </td><td style="text-align: left;">  Marginal 50%-quantiles </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>method</code>       </td><td style="text-align: left;">  <code>character vector</code>       </td><td style="text-align: left;">  Methods for calculation of marginal distribution parameters
   </td>
</tr>

</table>



<h6>The <code>median</code> column</h6>

 
<p>If supplied as input, any component of <code>median</code> can be either <code>NA</code>, <code>numeric</code>
(and not <code>NA</code>) or the character string <code>"mean"</code>. If it equals <code>"mean"</code> it is
set to <code>rowMeans(cbind(lower, upper))</code> of this component; if it is <code>numeric</code> it must
hold that <code>lower &lt;= median &lt;= upper</code> for this component. In case that no element 
<code>median</code> is provided, the default is <code>median=rep(NA, length(distribution))</code>.<br />
The <code>median</code> is important for the different methods possible in generating the random 
numbers (cf. <code><a href="#topic+random.estimate">random.estimate</a></code>).
</p>
 




<h4>The structure of the estimates correlation input information</h4>

<p>The argument <code>correlation_matrix</code> is the sub matrix of the full correlation matrix of 
the estimate containing all correlated elements. Thus, its row and column names must be a 
subset of the variable names of the marginal distributions. This means, that the information  
which variables are uncorrelated does not need to be provided explicitly.
</p>
<p><code>correlation_matrix</code> must have all the properties of a correlation matrix, viz. symmetry, 
all diagonal elements equal 1 and all of diagonal elements are between -1 and 1. 
</p>



<h3>Value</h3>

<p>An object of class <code>estimate</code> which is a list with components <code>$marginal</code> and 
<code>$correlation_matrix</code>:
</p>

<dl>
<dt><code>$marginal</code></dt><dd>
<p>is a <code><a href="base.html#topic+data.frame">data.frame</a></code> with mandatory columns:  
</p>

<table>
<tr>
 <td style="text-align: left;">
      <b>Mandatory column</b>      </td><td style="text-align: left;">  <b>R-type</b>                 </td><td style="text-align: left;"> <b>Explanation</b></td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>distribution</code> </td><td style="text-align: left;">  <code>character vector</code> </td><td style="text-align: left;">  Distribution types </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>lower</code>        </td><td style="text-align: left;">  <code>numeric vector</code>   </td><td style="text-align: left;">   5%-quantiles</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>median</code>       </td><td style="text-align: left;">  <code>numeric vector</code>   </td><td style="text-align: left;">  50%-quantiles or <code>NA</code></td>
</tr>
<tr>
 <td style="text-align: left;"> 
      <code>upper</code>        </td><td style="text-align: left;">  <code>numeric vector</code>   </td><td style="text-align: left;">  95%-quantiles 
    </td>
</tr>

</table>

<p>The <code><a href="base.html#topic+row.names">row.names</a></code> are the names of the variables. Each row has the properties of 
an <code><a href="#topic+estimate1d">estimate1d</a></code>. 
</p>
<p>Note that the <em><code>median</code></em> is a mandatory element of an <code>estimate</code>, although it
is not necessary as input. If a component of <code>median</code> is numeric and not <code>NA</code> it 
holds that: <code>lower &lt;= median &lt;= upper</code>. In any case an <code>estimate</code> object has the
property <code>any(lower &lt;= upper)</code>.     
</p>
</dd>
<dt><code>$correlation_matrix</code></dt><dd>
<p>is a symmetric matrix with row and column names being the subset of the variables supplied 
in <code>$marginal</code> which are correlated. Its elements are the corresponding correlations.
</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+estimate1d">estimate1d</a></code>, <code><a href="#topic+random.estimate">random.estimate</a></code>, 
<code><a href="#topic+row.names.estimate">row.names.estimate</a></code>, <code><a href="#topic+names.estimate">names.estimate</a></code>, <code><a href="#topic+corMat">corMat</a></code>, 
<code><a href="#topic+estimate_read_csv">estimate_read_csv</a></code> and <code><a href="#topic+estimate_write_csv">estimate_write_csv</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a minimum estimate (only mandatory marginal information supplied):
estimateMin&lt;-estimate(c("posnorm", "lnorm"),
                      c(        4,       4),
                      c(       50,      10))
print(estimateMin) 

# Create an estimate with optional columns (only marginal information supplied):
estimateMarg&lt;-estimate(           c("posnorm", "lnorm"),
                                  c(        4,       4),
                                  c(       50,      10),
                         variable=c("revenue", "costs"),
                         median = c(   "mean",      NA),
                         method = c(    "fit",      ""))
print(estimateMarg)
print(corMat(estimateMarg))

# Create a minimum estimate from text (only mandatory marginal information supplied):
estimateTextMin&lt;-"distribution, lower, upper
                  posnorm,      100,   1000
                  posnorm,      50,    2000
                  posnorm,      50,    2000
                  posnorm,      100,   1000"
estimateMin&lt;-as.estimate(read.csv(header=TRUE, text=estimateTextMin, 
                          strip.white=TRUE, stringsAsFactors=FALSE))
print(estimateMin) 

# Create an estimate from text (only marginal information supplied):
estimateText&lt;-"variable,  distribution, lower, upper, median, method
               revenue1,  posnorm,      100,   1000,  NA,        
               revenue2,  posnorm,      50,    2000,    ,     fit
               costs1,    posnorm,      50,    2000,  70,     calculate
               costs2,    posnorm,      100,   1000,  mean,             "
estimateMarg&lt;-as.estimate(read.csv(header=TRUE, text=estimateText, 
                          strip.white=TRUE, stringsAsFactors=FALSE))
print(estimateMarg)
print(corMat(estimateMarg))

# Create an estimate from text (with correlated components): 
estimateTextMarg&lt;-"variable,  distribution, lower, upper
                   revenue1,  posnorm,      100,   1000
                   revenue2,  posnorm,      50,    2000
                   costs1,    posnorm,      50,    2000
                   costs2,    posnorm,      100,   1000"
estimateTextCor&lt;-",         revenue1, costs2
                  revenue1,        1,   -0.3
                  costs2,       -0.3,      1"
estimateCor&lt;-as.estimate(read.csv(header=TRUE, text=estimateTextMarg, 
                          strip.white=TRUE, stringsAsFactors=FALSE),
                          correlation_matrix=data.matrix(read.csv(text=estimateTextCor, 
                                                                  row.names=1,
                                                                  strip.white=TRUE)))
print(estimateCor)
print(corMat(estimateCor))
</code></pre>

<hr>
<h2 id='estimate_read_csv'>Read an Estimate from CSV - File.</h2><span id='topic+estimate_read_csv'></span><span id='topic+estimate_read_csv_old'></span>

<h3>Description</h3>

<p>This function reads an <code><a href="#topic+estimate">estimate</a></code> from the specified csv files. In this context, an 
estimate of several variables is defined by its marginal distribution types, its marginal
90%-confidence intervals <code>[lower,upper]</code> and, optionally, its correlations.
</p>
<p><code>estimate_read_csv_old</code> reads an estimate from CSV file(s) according to the deprecated 
standard. This function is for backward compatibility only.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_read_csv(fileName, strip.white = TRUE, ...)

estimate_read_csv_old(fileName, strip.white = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_read_csv_+3A_filename">fileName</code></td>
<td>
<p>Name of the file containing the marginal information of the estimate that 
should be read.</p>
</td></tr>
<tr><td><code id="estimate_read_csv_+3A_strip.white">strip.white</code></td>
<td>
<p>logical. Used only when <code>sep</code> has
been specified, and allows the stripping of leading and trailing
white space from unquoted <code>character</code> fields (<code>numeric</code> fields
are always stripped).  See <code><a href="base.html#topic+scan">scan</a></code> for further details
(including the exact meaning of &lsquo;white space&rsquo;),
remembering that the columns may include the row names.</p>
</td></tr>
<tr><td><code id="estimate_read_csv_+3A_...">...</code></td>
<td>
<p>Further parameters to be passed to <code><a href="utils.html#topic+read.table">read.table</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An estimate might consists of uncorrelated and correlated variables. This is reflected
in the input file structure, which is described in the following.
</p>


<h4> CSV input file structures</h4>

<p>The estimate is read from one or two csv files: the marginal csv file which is mandatory and
the correlation csv file which is optional. The marginal csv file contains the definition of
the distribution of all variables ignoring potential correlations. The correlation csv file
only defines correlations. </p>


<h5>The structure of the marginal distributions input file
(mandatory)</h5>

<p>File name structure: <code>&lt;marginal-filename&gt;.csv</code>
</p>
<p>Mandatory columns:
</p>

<table>
<tr>
 <td style="text-align: left;">
      <b>Column name</b>       </td><td style="text-align: left;">  <b>R-type</b>    </td><td style="text-align: left;"> <b>Explanation</b></td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>variable</code>          </td><td style="text-align: left;">  <code>character vector</code>       </td><td style="text-align: left;">  Variable names</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>distribution</code>      </td><td style="text-align: left;">  <code>character vector</code> </td><td style="text-align: left;">  Marginal distribution types </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>lower</code>             </td><td style="text-align: left;">  <code>numeric vector</code>   </td><td style="text-align: left;">  Marginal 5%-quantiles </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>upper</code>             </td><td style="text-align: left;">  <code>numeric vector</code>   </td><td style="text-align: left;">  Marginal 95%-quantiles 
     </td>
</tr>

</table>

<p>Frequent optional columns are:
</p>

<table>
<tr>
 <td style="text-align: left;">
       <b>Column name</b>       </td><td style="text-align: left;">  <b>R-type</b>              </td><td style="text-align: left;"> <b>Explanation</b></td>
</tr>
<tr>
 <td style="text-align: left;">
       <code>description</code>       </td><td style="text-align: left;">  <code>character</code>           </td><td style="text-align: left;">  Short description of the variable.</td>
</tr>
<tr>
 <td style="text-align: left;">
       <code>median</code>            </td><td style="text-align: left;">  cf. <code><a href="#topic+estimate">estimate</a></code> </td><td style="text-align: left;">  Marginal 50%-quantiles </td>
</tr>
<tr>
 <td style="text-align: left;">
       <code>method</code>            </td><td style="text-align: left;">  <code>character vector</code>    </td><td style="text-align: left;">  Methods for calculation of marginal distribution parameters
     </td>
</tr>

</table>

<p>Columns without names are ignored. Rows where the <code>variable</code> field is empty are also dropped.
</p>



<h5>The structure of the correlation file (optional)</h5>

<p>File name structure: <code>&lt;marginal-filename&gt;_cor.csv</code>
</p>
<p>Columns and rows are named by the corresponding variables. Only those variables need to be 
present which are correlated with others.
</p>
<p>The element <code>["rowname","columnname"]</code> contains the correlation between the variables 
<code>rowname</code> and <code>columnname</code>. Uncorrelated elements have to be set to <code>0</code>. The
diagonal element <code>["name","name"]</code> has to be set to <code>1</code>.
</p>
<p>The matrix must be given in symmetric form.
</p>




<h4>Deprecated input standard (<code>estimate_read_csv_old</code>)</h4>

<p>File name structure of the correlation file: <code>&lt;marginal-filename&gt;.csv_correlations.csv</code><br />
</p>



<h3>Value</h3>

<p>An object of type <code><a href="#topic+estimate">estimate</a></code> which element <code>$marginal</code> is read from 
file <code>fileName</code> and which element <code>$correlation_matrix</code> is read from file
<code>gsub(".csv","_cor.csv",fileName)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate_write_csv">estimate_write_csv</a></code>, <code><a href="utils.html#topic+read.table">read.table</a></code>, <code><a href="#topic+estimate">estimate</a></code>
</p>
<p><code><a href="#topic+estimate_read_csv">estimate_read_csv</a></code>, <code><a href="utils.html#topic+read.table">read.table</a></code>, <code><a href="#topic+estimate">estimate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # Read the joint estimate information for the variables "sales", "productprice" and 
 # "costprice" from file:
 ## Get the path to the file with the marginal information:
 marginalFilePath=system.file("extdata","profit-4.csv",package="decisionSupport")
 ## Read the marginal information from file "profit-4.csv" and print it to the screen as
 ## illustration:
 read.csv(marginalFilePath, strip.white=TRUE)
 ## Read the correlation information from file "profit-4_cor.csv" and print it to the screen as
 ## illustration: 
 read.csv(gsub(".csv","_cor.csv",marginalFilePath), row.names=1)
 ## Now read marginal and correlation file straight into an estimate:
 parameterEstimate&lt;-estimate_read_csv(fileName=marginalFilePath)
 print(parameterEstimate)
</code></pre>

<hr>
<h2 id='estimate_write_csv'>Write an Estimate to CSV - File.</h2><span id='topic+estimate_write_csv'></span>

<h3>Description</h3>

<p>This function writes an <code><a href="#topic+estimate">estimate</a></code> to the specified csv file(s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_write_csv(
  estimate,
  fileName,
  varNamesAsColumn = TRUE,
  quote = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_write_csv_+3A_estimate">estimate</code></td>
<td>
<p><code>estimate</code>: Estimate object to write to file.</p>
</td></tr>
<tr><td><code id="estimate_write_csv_+3A_filename">fileName</code></td>
<td>
<p><code>character</code>: File name for the output of the marginal information of the 
estimate. It must end with <code>.csv</code>.</p>
</td></tr>
<tr><td><code id="estimate_write_csv_+3A_varnamesascolumn">varNamesAsColumn</code></td>
<td>
<p><code>logical</code>: If <code>TRUE</code> the variable names will be written as a
separate column, otherwise as row names.</p>
</td></tr>
<tr><td><code id="estimate_write_csv_+3A_quote">quote</code></td>
<td>
<p>a <code>logical</code> value (TRUE or FALSE) or a numeric vector. If
TRUE, any character or factor columns will be surrounded by double quotes.
If a numeric vector, its elements are taken as the indices of columns to
quote. In both cases, row and column names are quoted if they are written.
If FALSE, nothing is quoted. Parameter is passed on to <code><a href="utils.html#topic+write.table">write.table</a></code>.</p>
</td></tr>
<tr><td><code id="estimate_write_csv_+3A_...">...</code></td>
<td>
<p>Further parameters to be passed to <code><a href="utils.html#topic+write.table">write.table</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The marginal information of the <code>estimate</code> is written to file <code>fileName=&lt;marginal-filename&gt;.csv</code>. If 
the estimate contains correlated variables, the correlation matrix is written to the separate
file <code>&lt;marginal-filename&gt;_cor.csv</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+estimate_read_csv">estimate_read_csv</a></code>, <code><a href="#topic+estimate">estimate</a></code>, <code><a href="utils.html#topic+write.table">write.table</a></code>
</p>

<hr>
<h2 id='estimate1d'>Create a 1-dimensional estimate object.</h2><span id='topic+estimate1d'></span><span id='topic+as.estimate1d'></span>

<h3>Description</h3>

<p><code>estimate1d</code> creates an object of class <code>estimate1d</code>. The estimate of a one dimensional
variable is at minimum defined by the type of a univariate parametric distribution, the 5% - and
95% quantiles. Optionally, the median can be supplied.
</p>
<p><code>as.estimate1d</code> tries to transform an object to class <code>estimate1d</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate1d(distribution, lower, upper, ...)

as.estimate1d(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate1d_+3A_distribution">distribution</code></td>
<td>
<p><code>character</code>: A character string that defines the type of the univariate
parametric distribution.</p>
</td></tr>
<tr><td><code id="estimate1d_+3A_lower">lower</code></td>
<td>
<p><code>numeric</code>: lower bound of the 90% confidence interval, i.e the 5%-quantile 
of this estimate.</p>
</td></tr>
<tr><td><code id="estimate1d_+3A_upper">upper</code></td>
<td>
<p><code>numeric</code>: upper bound of the 90% confidence interval, i.e the 95%-quantile 
of this estimate.</p>
</td></tr>
<tr><td><code id="estimate1d_+3A_...">...</code></td>
<td>
<p>arguments that can be coerced to a list comprising further elements of the 1-d 
estimate (for details cf. below). Each element must be atomic and of length 1 (1-d property).</p>
</td></tr>
<tr><td><code id="estimate1d_+3A_x">x</code></td>
<td>
<p>an object to be transformed to class <code>estimate1d</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It must hold that <code>lower &lt;= upper</code>.
</p>


<h4>The structure of the input arguments</h4>



<h5>Mandatory input elements</h5>


<table>
<tr>
 <td style="text-align: left;">
      <b>Argument</b>    </td><td style="text-align: left;">  <b>R-type</b>     </td><td style="text-align: left;"> <b>Explanation</b></td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>distribution</code> </td><td style="text-align: left;">  <code>character</code> </td><td style="text-align: left;">  Distribution type of the estimate </td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>lower</code>        </td><td style="text-align: left;">  <code>numeric</code>   </td><td style="text-align: left;">   5%-quantile of the estimate</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>upper</code>        </td><td style="text-align: left;">  <code>numeric</code>   </td><td style="text-align: left;">  95%-quantile of the estimate
    </td>
</tr>

</table>




<h5>Optional input elements</h5>

<p>The optional parameters in <code>...</code> provide additional characteristics of the 1-d estimate. 
Frequent optional elements are:
</p>

<table>
<tr>
 <td style="text-align: left;">
      <b>Argument</b>     </td><td style="text-align: left;">  <b>R-type</b>                 </td><td style="text-align: left;"> <b>Explanation</b></td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>variable</code>     </td><td style="text-align: left;">  <code>character</code>              </td><td style="text-align: left;">  Variable name</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>median</code>       </td><td style="text-align: left;">  cf. below                     </td><td style="text-align: left;">  50%-quantile of the estimate</td>
</tr>
<tr>
 <td style="text-align: left;">
      <code>method</code>       </td><td style="text-align: left;">  <code>character</code>              </td><td style="text-align: left;">  Method for calculation of distribution parameters
   </td>
</tr>

</table>



<h6>The <code>median</code></h6>

<p>If supplied as input, <code>median</code> can be either <code>NULL</code>,  <code>numeric</code> or the
character string <code>"mean"</code>. If it is <code>NA</code> it is set to <code>NULL</code>; if it equals
<code>"mean"</code> it is set to <code>mean(c(lower, upper))</code>; if it is <code>numeric</code> it must 
hold that <code>lower &lt;= median &lt;= upper</code>. 
In case that no element <code>median</code> is provided, the default is <code>median=NULL</code>. 
</p>
    




<h3>Value</h3>

<p>An object of class <code>estimate1d</code> and <code>list</code> with at least (!) the elements:
</p>

<table>
<tr>
 <td style="text-align: left;">
     <b>Element</b>      </td><td style="text-align: left;">  <b>R-type</b>                 </td><td style="text-align: left;"> <b>Explanation</b></td>
</tr>
<tr>
 <td style="text-align: left;">
     <code>distribution</code> </td><td style="text-align: left;">  <code>character</code>              </td><td style="text-align: left;">  Distribution type of the estimate </td>
</tr>
<tr>
 <td style="text-align: left;">
     <code>lower</code>        </td><td style="text-align: left;">  <code>numeric</code>                </td><td style="text-align: left;">   5%-quantile of the estimate</td>
</tr>
<tr>
 <td style="text-align: left;">
     <code>median</code>       </td><td style="text-align: left;">  <code>numeric</code> or <code>NULL</code> </td><td style="text-align: left;">  50%-quantile of the estimate</td>
</tr>
<tr>
 <td style="text-align: left;">
     <code>upper</code>        </td><td style="text-align: left;">  <code>numeric</code>                </td><td style="text-align: left;">  95%-quantile of the estimate
   </td>
</tr>

</table>

<p>Note that the <em><code>median</code></em> is a mandatory element of an <code>estimate1d</code>, although it
is not necessary as input. If <code>median</code> is numeric it holds that:
<code>lower &lt;= median &lt;= upper</code>. In any case an <code>estimate1d</code> object has the property 
<code>lower &lt;= upper</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+random.estimate1d">random.estimate1d</a></code>
</p>

<hr>
<h2 id='eviSimulation'>Expected Value of Information (EVI) Simulation.</h2><span id='topic+eviSimulation'></span>

<h3>Description</h3>

<p>The Expected Value of Information (EVI) is calculated based on a Monte Carlo simulation of the
expected welfare (or values or benefits) of two different decision alternatives. The expected
welfare is calculated for the current estimate of variables determining welfare and a prospective
estimate of these variables. The prospective estimate resembles an improvement in information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eviSimulation(
  welfare,
  currentEstimate,
  prospectiveEstimate,
  numberOfModelRuns,
  randomMethod = "calculate",
  functionSyntax = "data.frameNames",
  relativeTolerance = 0.05,
  verbosity = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eviSimulation_+3A_welfare">welfare</code></td>
<td>
<p>either a <code>function</code> or a <code>list</code> with two <code>functions</code>, i.e.
<code>list(p1,p2)</code>. In the first case the function is the net benefit (or welfare) of project approval (PA) vs.
the status quo (SQ). In the second case the element <code>p1</code> is the function valuing the first
project and the element <code>p2</code> valuing the second project, viz. the welfare function of <code>p1</code>
and <code>p2</code> respectively.</p>
</td></tr>
<tr><td><code id="eviSimulation_+3A_currentestimate">currentEstimate</code></td>
<td>
<p><code><a href="#topic+estimate">estimate</a></code>: describing the distribution of the input variables
as currently being estimated.</p>
</td></tr>
<tr><td><code id="eviSimulation_+3A_prospectiveestimate">prospectiveEstimate</code></td>
<td>
<p><code><a href="#topic+estimate">estimate</a></code> or <code>list</code> of <code>estimate</code> objects:
describing the prospective distribution of the input variables which could hypothetically
be achieved by collecting more information, viz. improving the measurement.</p>
</td></tr>
<tr><td><code id="eviSimulation_+3A_numberofmodelruns">numberOfModelRuns</code></td>
<td>
<p><code>integer</code>: The number of running the welfare model for the 
underlying Monte Carlo simulation.</p>
</td></tr>
<tr><td><code id="eviSimulation_+3A_randommethod">randomMethod</code></td>
<td>
<p><code>character</code>: The method to be used to sample the distribution
representing the input estimate. For details see option <code>method</code> in 
<code><a href="#topic+random.estimate">random.estimate</a></code>.</p>
</td></tr>
<tr><td><code id="eviSimulation_+3A_functionsyntax">functionSyntax</code></td>
<td>
<p><code>character</code>: function syntax used in the welfare function(s). For 
details see <code><a href="#topic+mcSimulation">mcSimulation</a></code>.</p>
</td></tr>
<tr><td><code id="eviSimulation_+3A_relativetolerance">relativeTolerance</code></td>
<td>
<p><code>numeric</code>: the relative tolerance level of deviation of the
generated confidence interval from the specified interval. If this deviation is greater than
<code>relativeTolerance</code> a warning is given.</p>
</td></tr>
<tr><td><code id="eviSimulation_+3A_verbosity">verbosity</code></td>
<td>
<p><code>integer</code>: if <code>0</code> the function is silent; the larger the value the
more verbose is output information.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>The Expected Value of Information (EVI)</h4>

<p>The Expected Value of Information is the decrease in the <code class="reqn">\textrm{EOL}</code> for an information
improvement from the current (<code class="reqn">\rho_X^{current}</code>) to a better prospective (hypothetical)
information (<code class="reqn">\rho_X^{prospective}</code>):
</p>
<p style="text-align: center;"><code class="reqn">
      \textrm{EVI} := \textrm{EOL}(\rho_X^{current}) - \textrm{EOL}(\rho_X^{prospective}).
      </code>
</p>




<h3>Value</h3>

<p>An object of class <code>eviSimulation</code> with the following elements:
</p>

<dl>
<dt><code>$current</code></dt><dd>
<p><code><a href="#topic+welfareDecisionAnalysis">welfareDecisionAnalysis</a></code> object for <code>currentEstimate</code>
</p>
</dd>
<dt><code>$prospective</code></dt><dd>
<p><code><a href="#topic+welfareDecisionAnalysis">welfareDecisionAnalysis</a></code> object  for single <code>prospectiveEstimate</code> or a 
list of <code><a href="#topic+welfareDecisionAnalysis">welfareDecisionAnalysis</a></code> objects for <code>prospectiveEstimate</code> being
a list of <code>estimate</code>s.
</p>
</dd>
<dt><code>$evi</code></dt><dd>
<p>Expected Value of Information(s) (EVI)(s)  gained by the prospective estimate(s) w.r.t. the 
current estimate.
</p>
</dd>
</dl>



<h3>References</h3>

<p>Hubbard, Douglas W., <em>How to Measure Anything? - Finding the Value of &quot;Intangibles&quot; in Business</em>,
John Wiley &amp; Sons, Hoboken, New Jersey, 2014, 3rd Ed, <a href="https://www.howtomeasureanything.com/">https://www.howtomeasureanything.com/</a>.
</p>
<p>Gravelle, Hugh and Ray Rees, <em>Microeconomics</em>, Pearson Education Limited, 3rd edition, 2004.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+welfareDecisionAnalysis">welfareDecisionAnalysis</a></code>, <code><a href="#topic+mcSimulation">mcSimulation</a></code>, <code><a href="#topic+estimate">estimate</a></code>,
<code><a href="#topic+summary.eviSimulation">summary.eviSimulation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################
# Example 1 Only one prospective estimate:
#############################################################
numberOfModelRuns=10000
# Create the estimate object:
variable=c("revenue","costs")
distribution=c("posnorm","posnorm")
lower=c(10000,  5000)
upper=c(100000, 50000)
currentEstimate&lt;-as.estimate(variable, distribution, lower, upper)
prospectiveEstimate&lt;-currentEstimate
revenueConst&lt;-mean(c(currentEstimate$marginal["revenue","lower"],
                     currentEstimate$marginal["revenue","upper"]))
prospectiveEstimate$marginal["revenue","distribution"]&lt;-"const"
prospectiveEstimate$marginal["revenue","lower"]&lt;-revenueConst 
prospectiveEstimate$marginal["revenue","upper"]&lt;-revenueConst 
# (a) Define the welfare function without name for the return value:
profit&lt;-function(x){
	x$revenue-x$costs
}

# Calculate the Expected Value of Information:
eviSimulationResult&lt;-eviSimulation(welfare=profit,
                                   currentEstimate=currentEstimate,
                                   prospectiveEstimate=prospectiveEstimate,
                                   numberOfModelRuns=numberOfModelRuns,
                                   functionSyntax="data.frameNames")
# Show the simulation results:
print(summary(eviSimulationResult))
#############################################################
# (b) Define the welfare function with a name for the return value:
profit&lt;-function(x){
	list(Profit=x$revenue-x$costs)
}
# Calculate the Expected Value of Information:
eviSimulationResult&lt;-eviSimulation(welfare=profit,
                                   currentEstimate=currentEstimate,
                                   prospectiveEstimate=prospectiveEstimate,
                                   numberOfModelRuns=numberOfModelRuns,
                                   functionSyntax="data.frameNames")
# Show the simulation results:
print(summary((eviSimulationResult)))
#############################################################
# (c) Two decision variables:
decisionModel&lt;-function(x){
 list(Profit=x$revenue-x$costs,
      Costs=-x$costs)
}
# Calculate the Expected Value of Information:
eviSimulationResult&lt;-eviSimulation(welfare=decisionModel,
                                   currentEstimate=currentEstimate,
                                   prospectiveEstimate=prospectiveEstimate,
                                   numberOfModelRuns=numberOfModelRuns,
                                   functionSyntax="data.frameNames")
# Show the simulation results:
print(summary((eviSimulationResult)))
#############################################################
# Example 2 A list of prospective estimates:
#############################################################
numberOfModelRuns=10000
#  Define the welfare function with a name for the return value:
profit&lt;-function(x){
 list(Profit=x$revenue-x$costs)
}
# Create the estimate object:
variable=c("revenue","costs")
distribution=c("posnorm","posnorm")
lower=c(10000,  5000)
upper=c(100000, 50000)
currentEstimate&lt;-as.estimate(variable, distribution, lower, upper)
perfectInformationRevenue&lt;-currentEstimate
revenueConst&lt;-mean(c(currentEstimate$marginal["revenue","lower"],
                     currentEstimate$marginal["revenue","upper"]))
perfectInformationRevenue$marginal["revenue","distribution"]&lt;-"const"
perfectInformationRevenue$marginal["revenue","lower"]&lt;-revenueConst 
perfectInformationRevenue$marginal["revenue","upper"]&lt;-revenueConst
# (a) A list with one element
prospectiveEstimate&lt;-list(perfectInformationRevenue=perfectInformationRevenue)
# Calculate the Expected Value of Information:
eviSimulationResult&lt;-eviSimulation(welfare=profit,
                                   currentEstimate=currentEstimate,
                                   prospectiveEstimate=prospectiveEstimate,
                                   numberOfModelRuns=numberOfModelRuns,
                                   functionSyntax="data.frameNames")
# Show the simulation results:
print(summary(eviSimulationResult))
#############################################################
# (b) A list with two elements
perfectInformationCosts&lt;-currentEstimate
costsConst&lt;-mean(c(currentEstimate$marginal["costs","lower"], 
                   currentEstimate$marginal["costs","upper"]))
perfectInformationCosts$marginal["costs","distribution"]&lt;-"const"
perfectInformationCosts$marginal["costs","lower"]&lt;-costsConst 
perfectInformationCosts$marginal["costs","upper"]&lt;-costsConst
prospectiveEstimate&lt;-list(perfectInformationRevenue=perfectInformationRevenue,
                          perfectInformationCosts=perfectInformationCosts)
# Calculate the Expected Value of Information:
eviSimulationResult&lt;-eviSimulation(welfare=profit,
                                   currentEstimate=currentEstimate,
                                   prospectiveEstimate=prospectiveEstimate,
                                   numberOfModelRuns=numberOfModelRuns,
                                   functionSyntax="data.frameNames")
# Show the simulation results:
print(summary(eviSimulationResult))
#############################################################
# Example 3 A list of prospective estimates and two decision variables:
#############################################################
numberOfModelRuns=10000
# Create the current estimate object:
variable=c("revenue","costs")
distribution=c("posnorm","posnorm")
lower=c(10000,  5000)
upper=c(100000, 50000)
currentEstimate&lt;-as.estimate(variable, distribution, lower, upper)
# Create a list of two prospective estimates:
perfectInformationRevenue&lt;-currentEstimate
revenueConst&lt;-mean(c(currentEstimate$marginal["revenue","lower"],
                     currentEstimate$marginal["revenue","upper"]))
perfectInformationRevenue$marginal["revenue","distribution"]&lt;-"const"
perfectInformationRevenue$marginal["revenue","lower"]&lt;-revenueConst 
perfectInformationRevenue$marginal["revenue","upper"]&lt;-revenueConst
perfectInformationCosts&lt;-currentEstimate
costsConst&lt;-mean(c(currentEstimate$marginal["costs","lower"], 
                   currentEstimate$marginal["costs","upper"]))
perfectInformationCosts$marginal["costs","distribution"]&lt;-"const"
perfectInformationCosts$marginal["costs","lower"]&lt;-costsConst 
perfectInformationCosts$marginal["costs","upper"]&lt;-costsConst
prospectiveEstimate&lt;-list(perfectInformationRevenue=perfectInformationRevenue,
                          perfectInformationCosts=perfectInformationCosts)
# Define the welfare function with two decision variables:
decisionModel&lt;-function(x){
 list(Profit=x$revenue-x$costs,
      Costs=-x$costs)
}
# Calculate the Expected Value of Information:
eviSimulationResult&lt;-eviSimulation(welfare=decisionModel,
                                   currentEstimate=currentEstimate,
                                   prospectiveEstimate=prospectiveEstimate,
                                   numberOfModelRuns=numberOfModelRuns,
                                   functionSyntax="data.frameNames")
# Show the simulation results:
print(sort(summary(eviSimulationResult)),decreasing=TRUE,along="Profit")
</code></pre>

<hr>
<h2 id='gompertz_yield'>Gompertz function yield prediction for perennials</h2><span id='topic+gompertz_yield'></span>

<h3>Description</h3>

<p>Yields of trees or other perennial plants have to be simulated in order to
predict the outcomes of many interventions. Unlike annual crops, however,
trees normally yield nothing for a few years after planting, following which
yields gradually increase until they reach a tree-specific maximum. This is
simulated with this function, which assumes that a Gompertz function is a
good way to describe this (based on the general shape of the curve, not on
extensive research...). The function assumes that yields remain at the
maximum level, once this is reached. For long simulations, this may not be a
valid assumption!
The function parameters are estimated based on yield estimates for two
points in time, which the user can specify. They are described by a year
number and by a percentage of the maximum yield that is attained at that
time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gompertz_yield(
  max_harvest,
  time_to_first_yield_estimate,
  time_to_second_yield_estimate,
  first_yield_estimate_percent,
  second_yield_estimate_percent,
  n_years,
  var_CV = 0,
  no_yield_before_first_estimate = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gompertz_yield_+3A_max_harvest">max_harvest</code></td>
<td>
<p>maximum harvest from the tree (in number of fruits, kg or
other units)</p>
</td></tr>
<tr><td><code id="gompertz_yield_+3A_time_to_first_yield_estimate">time_to_first_yield_estimate</code></td>
<td>
<p>year (or other time unit) number, for
which the first yield estimate is provided by first_yield_estimate_percent</p>
</td></tr>
<tr><td><code id="gompertz_yield_+3A_time_to_second_yield_estimate">time_to_second_yield_estimate</code></td>
<td>
<p>year (or other time unit) number, for
which the second yield estimate is provided by second_yield_estimate_percent</p>
</td></tr>
<tr><td><code id="gompertz_yield_+3A_first_yield_estimate_percent">first_yield_estimate_percent</code></td>
<td>
<p>percentage of the maximum yield that is
attained in the year (or other time unit) given by
time_to_first_yield_estimate</p>
</td></tr>
<tr><td><code id="gompertz_yield_+3A_second_yield_estimate_percent">second_yield_estimate_percent</code></td>
<td>
<p>percentage of the maximum yield that is
attained in the year (or other time unit) given by
time_to_second_yield_estimate</p>
</td></tr>
<tr><td><code id="gompertz_yield_+3A_n_years">n_years</code></td>
<td>
<p>number of years to run the simulation</p>
</td></tr>
<tr><td><code id="gompertz_yield_+3A_var_cv">var_CV</code></td>
<td>
<p>coefficient indicating how much variation should be introduced
into the time series of n_targeted_per_year, annual_adoption_rate,
perc_disadopt and spontaneous adoption. If this is one numeric value, then
this value is used for all variables. If var_CV is a numeric vector with 4
elements, each of these is used to introduce variation in one of these
variables (in the sequence: n_targeted_per_year, annual_adoption_rate,
perc_disadopt and spontaneous adoption). The numbers correspond to the
coefficient of variation that the resulting time series should have. The
default is 0, for a time series with no artificially introduced variation.
See description of the vv function for more details on this.</p>
</td></tr>
<tr><td><code id="gompertz_yield_+3A_no_yield_before_first_estimate">no_yield_before_first_estimate</code></td>
<td>
<p>boolean variable indicating whether
yields before the time unit indicated by time_to_first_yield_estimate should
be 0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of n_years numeric values, describing the simulated yield of
the perennial. This starts at 0 and, if the simulation runs for a sufficient
number of years, approaches max_harvest. If var_CV&gt;0, this time series
includes artificial variation.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gompertz_yield(max_harvest=1000,
               time_to_first_yield_estimate=5,
               time_to_second_yield_estimate=15,
               first_yield_estimate_percent=10,
               second_yield_estimate_percent=90,
               n_years=30,
               var_CV=5,
               no_yield_before_first_estimate=TRUE)
</code></pre>

<hr>
<h2 id='hist.eviSimulation'>Plot Histograms of results of an EVI simulation</h2><span id='topic+hist.eviSimulation'></span>

<h3>Description</h3>

<p>This function plots the histograms of the results of
<code><a href="#topic+eviSimulation">eviSimulation</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'eviSimulation'
hist(
  x,
  breaks = 100,
  col = NULL,
  mainSuffix = " welfare simulation result",
  ...,
  colorQuantile = c("GREY", "YELLOW", "ORANGE", "DARK GREEN", "ORANGE", "YELLOW", "GREY"),
  colorProbability = c(1, 0.95, 0.75, 0.55, 0.45, 0.25, 0.05),
  resultName = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hist.eviSimulation_+3A_x">x</code></td>
<td>
<p>An object of class <code>eviSimulation</code>.</p>
</td></tr>
<tr><td><code id="hist.eviSimulation_+3A_breaks">breaks</code></td>
<td>
<p>one of:
</p>

<ul>
<li><p> a vector giving the breakpoints between histogram cells,
</p>
</li>
<li><p> a function to compute the vector of breakpoints,
</p>
</li>
<li><p> a single number giving the number of cells for the histogram,
</p>
</li>
<li><p> a character string naming an algorithm to compute the
number of cells (see &lsquo;Details&rsquo;),
</p>
</li>
<li><p> a function to compute the number of cells.
</p>
</li></ul>

<p>In the last three cases the number is a suggestion only; as the
breakpoints will be set to <code><a href="base.html#topic+pretty">pretty</a></code> values, the number
is limited to <code>1e6</code> (with a warning if it was larger).  If
<code>breaks</code> is a function, the <code>x</code> vector is supplied to it
as the only argument (and the number of breaks is only limited by
the amount of available memory).
</p>
</td></tr>
<tr><td><code id="hist.eviSimulation_+3A_col">col</code></td>
<td>
<p>a colour to be used to fill the bars.</p>
</td></tr>
<tr><td><code id="hist.eviSimulation_+3A_mainsuffix">mainSuffix</code></td>
<td>
<p><code>character</code>: Suffix of the main titles of the histograms.</p>
</td></tr>
<tr><td><code id="hist.eviSimulation_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code><a href="graphics.html#topic+hist">hist</a></code>.</p>
</td></tr>
<tr><td><code id="hist.eviSimulation_+3A_colorquantile">colorQuantile</code></td>
<td>
<p><code>character vector</code>: encoding the colors of the 
quantiles defined in argument <code>colorProbability</code>.</p>
</td></tr>
<tr><td><code id="hist.eviSimulation_+3A_colorprobability">colorProbability</code></td>
<td>
<p><code>numeric vector</code>: defines the quantiles that 
shall be distinguished by the colors chosen in argument 
<code>colorQuantile</code>. Must be of the same length as <code>colorQuantile</code>.</p>
</td></tr>
<tr><td><code id="hist.eviSimulation_+3A_resultname">resultName</code></td>
<td>
<p><code>character</code>: indicating the name of the component of
the simulation function (<code>model_function</code>) which results histogram
shall be generated. If <code>model_function</code> is single valued, no name
needs to be supplied. Otherwise, one valid name has to be specified.
Defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class &quot;<code>histogram</code>&quot;. For details see 
<code><a href="graphics.html#topic+hist">hist</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eviSimulation">eviSimulation</a></code>, <code><a href="graphics.html#topic+hist">hist</a></code>. For a list of colors
available in R see <code><a href="grDevices.html#topic+colors">colors</a></code>.
</p>

<hr>
<h2 id='hist.mcSimulation'>Plot Histogram of results of a Monte Carlo Simulation</h2><span id='topic+hist.mcSimulation'></span>

<h3>Description</h3>

<p>This function plots the histograms of the results of
<code><a href="#topic+mcSimulation">mcSimulation</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcSimulation'
hist(
  x,
  breaks = 100,
  col = NULL,
  xlab = NULL,
  main = paste("Histogram of ", xlab),
  ...,
  colorQuantile = c("GREY", "YELLOW", "ORANGE", "DARK GREEN", "ORANGE", "YELLOW", "GREY"),
  colorProbability = c(1, 0.95, 0.75, 0.55, 0.45, 0.25, 0.05),
  resultName = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hist.mcSimulation_+3A_x">x</code></td>
<td>
<p>An object of class <code>mcSimulation</code>.</p>
</td></tr>
<tr><td><code id="hist.mcSimulation_+3A_breaks">breaks</code></td>
<td>
<p>one of:
</p>

<ul>
<li><p> a vector giving the breakpoints between histogram cells,
</p>
</li>
<li><p> a function to compute the vector of breakpoints,
</p>
</li>
<li><p> a single number giving the number of cells for the histogram,
</p>
</li>
<li><p> a character string naming an algorithm to compute the
number of cells (see &lsquo;Details&rsquo;),
</p>
</li>
<li><p> a function to compute the number of cells.
</p>
</li></ul>

<p>In the last three cases the number is a suggestion only; as the
breakpoints will be set to <code><a href="base.html#topic+pretty">pretty</a></code> values, the number
is limited to <code>1e6</code> (with a warning if it was larger).  If
<code>breaks</code> is a function, the <code>x</code> vector is supplied to it
as the only argument (and the number of breaks is only limited by
the amount of available memory).
</p>
</td></tr>
<tr><td><code id="hist.mcSimulation_+3A_col">col</code></td>
<td>
<p>a colour to be used to fill the bars.</p>
</td></tr>
<tr><td><code id="hist.mcSimulation_+3A_xlab">xlab</code></td>
<td>
<p><code>character</code>: x label of the histogram. If it is not
provided, i.e. equals <code>NULL</code> the name of the chosen variable by
argument <code>resultName</code> is used.</p>
</td></tr>
<tr><td><code id="hist.mcSimulation_+3A_main">main</code></td>
<td>
<p><code>character</code>: main title of the histogram.</p>
</td></tr>
<tr><td><code id="hist.mcSimulation_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code><a href="graphics.html#topic+hist">hist</a></code>.</p>
</td></tr>
<tr><td><code id="hist.mcSimulation_+3A_colorquantile">colorQuantile</code></td>
<td>
<p><code>character vector</code>: encoding the colors of the 
quantiles defined in argument <code>colorProbability</code>.</p>
</td></tr>
<tr><td><code id="hist.mcSimulation_+3A_colorprobability">colorProbability</code></td>
<td>
<p><code>numeric vector</code>: defines the quantiles that 
shall be distinguished by the colors chosen in argument 
<code>colorQuantile</code>. Must be of the same length as <code>colorQuantile</code>.</p>
</td></tr>
<tr><td><code id="hist.mcSimulation_+3A_resultname">resultName</code></td>
<td>
<p><code>character</code>: indicating the name of the component of
the simulation function (<code>model_function</code>) which results histogram
shall be generated. If <code>model_function</code> is single valued, no name
needs to be supplied. Otherwise, one valid name has to be specified.
Defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class &quot;<code>histogram</code>&quot;. For details see 
<code><a href="graphics.html#topic+hist">hist</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcSimulation">mcSimulation</a></code>, <code><a href="graphics.html#topic+hist">hist</a></code>. For a list of colors
available in R see <code><a href="grDevices.html#topic+colors">colors</a></code>.
</p>

<hr>
<h2 id='hist.welfareDecisionAnalysis'>Plot Histogram of results of a Welfare Decision Analysis</h2><span id='topic+hist.welfareDecisionAnalysis'></span>

<h3>Description</h3>

<p>This function plots the histograms of the results of
<code><a href="#topic+welfareDecisionAnalysis">welfareDecisionAnalysis</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'welfareDecisionAnalysis'
hist(
  x,
  breaks = 100,
  col = NULL,
  xlab = NULL,
  main = paste("Histogram of ", xlab),
  ...,
  colorQuantile = c("GREY", "YELLOW", "ORANGE", "DARK GREEN", "ORANGE", "YELLOW", "GREY"),
  colorProbability = c(1, 0.95, 0.75, 0.55, 0.45, 0.25, 0.05),
  resultName = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hist.welfareDecisionAnalysis_+3A_x">x</code></td>
<td>
<p>An object of class <code>welfareDecisionAnalysis</code>.</p>
</td></tr>
<tr><td><code id="hist.welfareDecisionAnalysis_+3A_breaks">breaks</code></td>
<td>
<p>one of:
</p>

<ul>
<li><p> a vector giving the breakpoints between histogram cells,
</p>
</li>
<li><p> a function to compute the vector of breakpoints,
</p>
</li>
<li><p> a single number giving the number of cells for the histogram,
</p>
</li>
<li><p> a character string naming an algorithm to compute the
number of cells (see &lsquo;Details&rsquo;),
</p>
</li>
<li><p> a function to compute the number of cells.
</p>
</li></ul>

<p>In the last three cases the number is a suggestion only; as the
breakpoints will be set to <code><a href="base.html#topic+pretty">pretty</a></code> values, the number
is limited to <code>1e6</code> (with a warning if it was larger).  If
<code>breaks</code> is a function, the <code>x</code> vector is supplied to it
as the only argument (and the number of breaks is only limited by
the amount of available memory).
</p>
</td></tr>
<tr><td><code id="hist.welfareDecisionAnalysis_+3A_col">col</code></td>
<td>
<p>a colour to be used to fill the bars.</p>
</td></tr>
<tr><td><code id="hist.welfareDecisionAnalysis_+3A_xlab">xlab</code></td>
<td>
<p><code>character</code>: x label of the histogram. If it is not
provided, i.e. equals <code>NULL</code> the name of the chosen variable by
argument <code>resultName</code> is used.</p>
</td></tr>
<tr><td><code id="hist.welfareDecisionAnalysis_+3A_main">main</code></td>
<td>
<p><code>character</code>: main title of the histogram.</p>
</td></tr>
<tr><td><code id="hist.welfareDecisionAnalysis_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code><a href="graphics.html#topic+hist">hist</a></code>.</p>
</td></tr>
<tr><td><code id="hist.welfareDecisionAnalysis_+3A_colorquantile">colorQuantile</code></td>
<td>
<p><code>character vector</code>: encoding the colors of the 
quantiles defined in argument <code>colorProbability</code>.</p>
</td></tr>
<tr><td><code id="hist.welfareDecisionAnalysis_+3A_colorprobability">colorProbability</code></td>
<td>
<p><code>numeric vector</code>: defines the quantiles that 
shall be distinguished by the colors chosen in argument 
<code>colorQuantile</code>. Must be of the same length as <code>colorQuantile</code>.</p>
</td></tr>
<tr><td><code id="hist.welfareDecisionAnalysis_+3A_resultname">resultName</code></td>
<td>
<p><code>character</code>: indicating the name of the component of
the simulation function (<code>model_function</code>) which results histogram
shall be generated. If <code>model_function</code> is single valued, no name
needs to be supplied. Otherwise, one valid name has to be specified.
Defaults to <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class &quot;<code>histogram</code>&quot;. For details see 
<code><a href="graphics.html#topic+hist">hist</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+welfareDecisionAnalysis">welfareDecisionAnalysis</a></code>, <code><a href="graphics.html#topic+hist">hist</a></code>. For a list of colors
available in R see <code><a href="grDevices.html#topic+colors">colors</a></code>.
</p>

<hr>
<h2 id='individualEvpiSimulation'>Individual Expected Value of Perfect Information Simulation</h2><span id='topic+individualEvpiSimulation'></span>

<h3>Description</h3>

<p>The Individual Expected Value of Perfect Information (Individual EVPI) is calculated based on a
Monte Carlo simulation of the values of two different decision alternatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>individualEvpiSimulation(
  welfare,
  currentEstimate,
  perfectProspectiveNames = row.names(currentEstimate),
  perfectProspectiveValues = colMeans(as.data.frame(random(rho = currentEstimate, n =
    numberOfModelRuns, method = randomMethod, relativeTolerance =
    relativeTolerance))[perfectProspectiveNames]),
  numberOfModelRuns,
  randomMethod = "calculate",
  functionSyntax = "data.frameNames",
  relativeTolerance = 0.05,
  verbosity = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="individualEvpiSimulation_+3A_welfare">welfare</code></td>
<td>
<p>either a <code>function</code> or a <code>list</code> with two <code>functions</code>, i.e.
<code>list(p1,p2)</code>. In the first case the function is the net benefit (or welfare) of project approval (PA) vs.
the status quo (SQ). In the second case the element <code>p1</code> is the function valuing the first
project and the element <code>p2</code> valuing the second project, viz. the welfare function of <code>p1</code>
and <code>p2</code> respectively.</p>
</td></tr>
<tr><td><code id="individualEvpiSimulation_+3A_currentestimate">currentEstimate</code></td>
<td>
<p><code><a href="#topic+estimate">estimate</a></code>: describing the distribution of the input variables
as currently being estimated.</p>
</td></tr>
<tr><td><code id="individualEvpiSimulation_+3A_perfectprospectivenames">perfectProspectiveNames</code></td>
<td>
<p><code>character vector</code>: input variable names that are assumed to be known perfectly with 
prospective information.</p>
</td></tr>
<tr><td><code id="individualEvpiSimulation_+3A_perfectprospectivevalues">perfectProspectiveValues</code></td>
<td>
<p><code>numeric vector</code>: of the same length as <code>perfectProspectiveNames</code> with the corresponding
values assumed to be known perfectly.</p>
</td></tr>
<tr><td><code id="individualEvpiSimulation_+3A_numberofmodelruns">numberOfModelRuns</code></td>
<td>
<p><code>integer</code>: The number of running the welfare model for the 
underlying Monte Carlo simulation.</p>
</td></tr>
<tr><td><code id="individualEvpiSimulation_+3A_randommethod">randomMethod</code></td>
<td>
<p><code>character</code>: The method to be used to sample the distribution
representing the input estimate. For details see option <code>method</code> in 
<code><a href="#topic+random.estimate">random.estimate</a></code>.</p>
</td></tr>
<tr><td><code id="individualEvpiSimulation_+3A_functionsyntax">functionSyntax</code></td>
<td>
<p><code>character</code>: function syntax used in the welfare function(s). For 
details see <code><a href="#topic+mcSimulation">mcSimulation</a></code>.</p>
</td></tr>
<tr><td><code id="individualEvpiSimulation_+3A_relativetolerance">relativeTolerance</code></td>
<td>
<p><code>numeric</code>: the relative tolerance level of deviation of the
generated confidence interval from the specified interval. If this deviation is greater than
<code>relativeTolerance</code> a warning is given.</p>
</td></tr>
<tr><td><code id="individualEvpiSimulation_+3A_verbosity">verbosity</code></td>
<td>
<p><code>integer</code>: if <code>0</code> the function is silent; the larger the value the
more verbose is output information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Individual EVPI is defined as the EVI with respect to a prospective information 
that assumes perfect knowledge on one particular variable.
</p>


<h3>Value</h3>

<p>An object of class <code>eviSimulation</code> with the following elements:
</p>

<dl>
<dt><code>$current</code></dt><dd>
<p><code><a href="#topic+welfareDecisionAnalysis">welfareDecisionAnalysis</a></code> object for <code>currentEstimate</code>
</p>
</dd>
<dt><code>$prospective</code></dt><dd>
<p><code><a href="#topic+welfareDecisionAnalysis">welfareDecisionAnalysis</a></code> object  for single <code>perfectProspectiveNames</code> or a 
list of <code><a href="#topic+welfareDecisionAnalysis">welfareDecisionAnalysis</a></code> objects for several <code>perfectProspectiveNames</code>.
</p>
</dd>
<dt><code>$evi</code></dt><dd>
<p>Expected Value of Information(s) (EVI)(s) gained by the perfect knowledge of individual 
variable(s) w.r.t. the current estimate.
</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+eviSimulation">eviSimulation</a></code>, <code><a href="#topic+welfareDecisionAnalysis">welfareDecisionAnalysis</a></code>, <code><a href="#topic+mcSimulation">mcSimulation</a></code>, <code><a href="#topic+estimate">estimate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Number of running the underlying welfare model:
n=10000
# Create the current estimate from text:
estimateText&lt;-"variable,  distribution, lower, upper
               revenue1,  posnorm,      100,   1000
               revenue2,  posnorm,      50,    2000
               costs1,    posnorm,      50,    2000
               costs2,    posnorm,      100,   1000"
currentEstimate&lt;-as.estimate(read.csv(header=TRUE, text=estimateText, 
                          strip.white=TRUE, stringsAsFactors=FALSE))
# The welfare function:
profitModel &lt;- function(x){
 list(Profit=x$revenue1 + x$revenue2 - x$costs1 - x$costs2)
}
# Calculate the Individual EVPI:
individualEvpiResult&lt;-individualEvpiSimulation(welfare=profitModel,
                                               currentEstimate=currentEstimate,
                                               numberOfModelRuns=n,
                                               functionSyntax="data.frameNames")
# Show the simulation results:
print(sort(summary(individualEvpiResult)),decreasing=TRUE,along="Profit")
hist(individualEvpiResult, breaks=100)
</code></pre>

<hr>
<h2 id='make_CPT'>Make Conditional Probability tables using the likelihood method</h2><span id='topic+make_CPT'></span>

<h3>Description</h3>

<p>This function creates Conditional Probability Tables for
Bayesian Network nodes from parameters that (for complex nodes) can
be more easily elicited from experts than the full table. The function
uses the Likelihood method, as described by Sjoekvist S &amp; Hansson F, 2013.
Tables are created from three the relative weights of all parents, rankings
for all parents, a parameter (b) for the sensitivity of the child node and
a prior distribution (for the child node).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_CPT(
  parent_effects,
  parent_weights,
  b,
  child_prior,
  ranking_child = NULL,
  child_states = NULL,
  parent_names = NULL,
  parent_states = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_CPT_+3A_parent_effects">parent_effects</code></td>
<td>
<p>list of vectors describing the effects of all parent node
states on the value of the child variable. For example, if parent 1 has
four states, the respective vector might look like this: c(3,1,0,0). This
would imply that the first state of the parent is strongly associated with
high values for the child, the second less strongly, and the 3rd and
4th value are associated with equally low values.</p>
</td></tr>
<tr><td><code id="make_CPT_+3A_parent_weights">parent_weights</code></td>
<td>
<p>weight factors for the parent nodes</p>
</td></tr>
<tr><td><code id="make_CPT_+3A_b">b</code></td>
<td>
<p>parameter for the strength of the parent's influence on
the child node. A value of 1 causes no response; 3 is quite strong.</p>
</td></tr>
<tr><td><code id="make_CPT_+3A_child_prior">child_prior</code></td>
<td>
<p>prior distribution for the states of the child node.</p>
</td></tr>
<tr><td><code id="make_CPT_+3A_ranking_child">ranking_child</code></td>
<td>
<p>vector of length length(child_prior) containing rankings for
the child node states on a -1..1 scale. If this is null, evenly spaced rankings on
this -1..1 scale are assigned automatically.</p>
</td></tr>
<tr><td><code id="make_CPT_+3A_child_states">child_states</code></td>
<td>
<p>optional vector specifying the names of the child states.</p>
</td></tr>
<tr><td><code id="make_CPT_+3A_parent_names">parent_names</code></td>
<td>
<p>optional vector specifying parent node names.</p>
</td></tr>
<tr><td><code id="make_CPT_+3A_parent_states">parent_states</code></td>
<td>
<p>list of the same structure as parent_effects containing
names for all states of all parents.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of two data.frames: 1) Conditional Probability Table (CPT); 2) legend table
specifying which states of the parent nodes belong to which column in the CPT.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>References</h3>

<p>Sjoekvist S &amp; Hansson F, 2013. Modelling expert judgement into a Bayesian
Belief Network - a method for consistent and robust determination of conditional
probability tables. Master's thesis, Faculty of Engineering, Lund University;
http://lup.lub.lu.se/luur/download?func=downloadFile&amp;recordOId=3866733&amp;fileOId=3866740
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
make_CPT(parent_effects=list(c(-1,1),c(-0.5,0,0.5)),
  parent_weights=c(3,1),b=1.5,child_prior=c(.2,.6,.2),child_states=c("a","b","c"))

test_CPT&lt;-make_CPT(parent_effects=list(c(-1,3),c(-4,2),c(-2,3,4),c(1,2,3)),
                  parent_weights=c(1,1,1,1),b=2,child_prior=c(1,2,3,4,5),
                  child_states=c("a","b","c","d","e"),
                  parent_states=list(c("low","high"),c("A","B"),c(1,2,3),c("Hi","Lunch","Bye")))


</code></pre>

<hr>
<h2 id='mcSimulation'>Perform a Monte Carlo simulation.</h2><span id='topic+mcSimulation'></span>

<h3>Description</h3>

<p>This function generates a random sample of an output distribution defined as the transformation 
of an input distribution by a mathematical model, i.e. a mathematical function. This is called a
Monte Carlo simulation. For details cf. below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcSimulation(
  estimate,
  model_function,
  ...,
  numberOfModelRuns,
  randomMethod = "calculate",
  functionSyntax = "data.frameNames",
  relativeTolerance = 0.05,
  verbosity = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcSimulation_+3A_estimate">estimate</code></td>
<td>
<p><code>estimate</code>: estimate of the joint probability distribution of
the input variables. This can be read from a csv file and calculated with the <code><a href="#topic+estimate_read_csv">estimate_read_csv</a></code> function.</p>
</td></tr>
<tr><td><code id="mcSimulation_+3A_model_function">model_function</code></td>
<td>
<p><code>function</code>: The function that transforms the input distribution. It 
has to return a single <code>numeric</code> value or a <code>list</code> with named <code>numeric</code> values.</p>
</td></tr>
<tr><td><code id="mcSimulation_+3A_...">...</code></td>
<td>
<p>Optional arguments of <code>model_function</code>.</p>
</td></tr>
<tr><td><code id="mcSimulation_+3A_numberofmodelruns">numberOfModelRuns</code></td>
<td>
<p>The number of times running the model function.</p>
</td></tr>
<tr><td><code id="mcSimulation_+3A_randommethod">randomMethod</code></td>
<td>
<p><code>character</code>: The method to be used to sample the distribution
representing the input estimate. For details see option <code>method</code> in 
<code><a href="#topic+random.estimate">random.estimate</a></code>.</p>
</td></tr>
<tr><td><code id="mcSimulation_+3A_functionsyntax">functionSyntax</code></td>
<td>
<p><code>character</code>: The syntax which has to be used to implement the model
function. Possible values are <code>"data.frameNames"</code>,
<code>"matrixNames"</code> or <code>"plainNames"</code>. Details are given below.</p>
</td></tr>
<tr><td><code id="mcSimulation_+3A_relativetolerance">relativeTolerance</code></td>
<td>
<p><code>numeric</code>: the relative tolerance level of deviation of the
generated confidence interval from the specified interval. If this deviation is greater than
<code>relativeTolerance</code> a warning is given.</p>
</td></tr>
<tr><td><code id="mcSimulation_+3A_verbosity">verbosity</code></td>
<td>
<p><code>integer</code>: if <code>0</code> the function is silent; the larger the value the
more verbose is output information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method solves the following problem. Given a multivariate random variable <code class="reqn">x =
(x_1,\ldots,x_k)</code> with joint probability distribution <code class="reqn">P</code>, i.e. 
</p>
<p style="text-align: center;"><code class="reqn">x \sim P.</code>
</p>
 
<p>Then the continuous function 
</p>
<p style="text-align: center;"><code class="reqn">f:R^k \rightarrow R^l, y = f(x)</code>
</p>
 
<p>defines another random variable with distribution 
</p>
<p style="text-align: center;"><code class="reqn">y \sim f(P).</code>
</p>

<p>Given a probability density <code class="reqn">\rho</code> of x that defines <code class="reqn">P</code> the problem is the determination 
of the probability density <code class="reqn">\phi</code> that defines <code class="reqn">f(P)</code>. This method samples the 
probability density <code class="reqn">\phi</code> of <code class="reqn">y</code> as follows: The input distribution <code class="reqn">P</code> is provided 
as <code>estimate</code>. From <code>estimate</code> a sample <code>x</code> with <code>numberOfModelRuns</code> is  
generated using <code><a href="#topic+random.estimate">random.estimate</a></code>. Then the function values <code class="reqn">y=f(x)</code> are 
calculated, where <code class="reqn">f</code> is <code>model_function</code>.
</p>
<p><code>functionSyntax</code> defines the syntax of <code>model_function</code>, which has to be used, as 
follows:
</p>

<dl>
<dt><code>"data.frameNames"</code></dt><dd>
<p>The model function is constructed, e.g. like this:
</p>
<pre>
         profit&lt;-function(x){
           x[["revenue"]]-x[["costs"]]
         }
       </pre>
<p>or like this:
</p>
<pre>
         profit&lt;-function(x){
           x$revenue-x$costs
         }
       </pre>
</dd>
<dt><code>"matrixNames"</code></dt><dd>
<p>The model function is constructed, e.g. like this:
</p>
<pre>
           profit&lt;-function(x){
             x[,"revenue"]-x[,"costs"]
           }
        </pre>     
</dd>
<dt><code>"plainNames"</code></dt><dd>
<p><code>model_function</code> is constructed, e.g. like this:
</p>
<pre>
         profit&lt;-function(x){
           revenue-costs
         }
       </pre>
<p><dfn>Note</dfn>: this is the slowest of the possibilities for <code>functionSyntax</code>.
</p>
</dd>     
</dl>



<h3>Value</h3>

<p>An object of <code>class mcSimulation</code>, which is a <code>list</code> with elements:
</p>

<dl>
<dt><code>$x</code></dt><dd>
<p><code>data.frame</code> containing the sampled <code class="reqn">x -</code> (input) values which are generated 
from <code>estimate</code>.
</p>
</dd>
<dt><code>$y</code></dt><dd>
<p><code>data.frame</code> containing the simulated <code class="reqn">y -</code> (output) values, i.e. the model 
function values for <code>x</code>.The return of the decision model function may include the
assignment of names for the output variables, e.g. like this:
</p>
<pre>
           profit &lt;- function(x){
            revenue - costs
            return(list(Revenue = revenue,
                   Costs = cost))
         }
       </pre>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+print.mcSimulation">print.mcSimulation</a></code>, <code><a href="#topic+summary.mcSimulation">summary.mcSimulation</a></code>, <code><a href="#topic+hist.mcSimulation">hist.mcSimulation</a></code>, <code><a href="#topic+estimate">estimate</a></code>, <code><a href="#topic+random.estimate">random.estimate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> #############################################################
 # Example 1 (Creating the estimate from the command line):
 #############################################################
 # Create the estimate object:
 variable=c("revenue","costs")
 distribution=c("norm","norm")
 lower=c(10000,  5000)
 upper=c(100000, 50000)
 costBenefitEstimate&lt;-as.estimate(variable, distribution, lower, upper)
 # (a) Define the model function without name for the return value:
 profit1&lt;-function(x){
   x$revenue-x$costs
 }
 # Perform the Monte Carlo simulation:
 predictionProfit1&lt;-mcSimulation( estimate=costBenefitEstimate, 
                                 model_function=profit1, 
                                 numberOfModelRuns=10000,
                                 functionSyntax="data.frameNames")
 # Show the simulation results:
 print(summary(predictionProfit1))
 hist(predictionProfit1,xlab="Profit")
 #############################################################
 # (b) Define the model function with a name for the return value:
 profit1&lt;-function(x){
   list(Profit=x$revenue-x$costs)
 } 
 # Perform the Monte Carlo simulation:
 predictionProfit1&lt;-mcSimulation( estimate=costBenefitEstimate, 
                                 model_function=profit1, 
                                 numberOfModelRuns=10000,
                                 functionSyntax="data.frameNames")
 # Show the simulation results:
 print(summary(predictionProfit1, classicView=TRUE))
 hist(predictionProfit1) 
 #########################################################
 # (c) Using plain names in the model function syntax
 profit1&lt;-function(){
   list(Profit=revenue-costs)
 } 
 # Perform the Monte Carlo simulation:
 predictionProfit1&lt;-mcSimulation( estimate=costBenefitEstimate, 
                                 model_function=profit1, 
                                 numberOfModelRuns=1000,
                                 functionSyntax="plainNames")
 # Show the simulation results:
 print(summary(predictionProfit1, probs=c(0.05,0.50,0.95)))
 hist(predictionProfit1) 
 #########################################################
 # (d) Using plain names in the model function syntax and
 #     define the model function without name for the return value:
 profit1&lt;-function() revenue-costs
 # Perform the Monte Carlo simulation:
 predictionProfit1&lt;-mcSimulation( estimate=costBenefitEstimate,
                                  model_function=profit1,
                                  numberOfModelRuns=1000,
                                  functionSyntax="plainNames")
 # Show the simulation results:
 print(summary(predictionProfit1, probs=c(0.05,0.50,0.95)))
 hist(predictionProfit1, xlab="Profit")
 #############################################################
 # Example 2(Reading the estimate from file):
 #############################################################
 # Define the model function:
 profit2&lt;-function(x){
   Profit&lt;-x[["sales"]]*(x[["productprice"]] - x[["costprice"]])
   list(Profit=Profit)
 }  
 # Read the estimate of sales, productprice and costprice from file:
 inputFileName=system.file("extdata","profit-4.csv",package="decisionSupport")
 parameterEstimate&lt;-estimate_read_csv(fileName=inputFileName)
 print(parameterEstimate)
 # Perform the Monte Carlo simulation:
 predictionProfit2&lt;-mcSimulation( estimate=parameterEstimate, 
                                 model_function=profit2, 
                                 numberOfModelRuns=10000,
                                 functionSyntax="data.frameNames")
 # Show the simulation results:
 print(summary(predictionProfit2))
 hist(predictionProfit2) 
</code></pre>

<hr>
<h2 id='multi_EVPI'>Expected value of perfect information (EVPI) for multiple variables. This
is a wrapper for the empirical_EVPI function. See the documentation of the 
<code><a href="#topic+empirical_EVPI">empirical_EVPI</a></code> function for more details.</h2><span id='topic+multi_EVPI'></span><span id='topic+summary.EVPI_outputs'></span><span id='topic+summary_multi_EVPI'></span><span id='topic+plot.EVPI_outputs'></span><span id='topic+plot_multi_EVPI'></span>

<h3>Description</h3>

<p>Expected value of perfect information (EVPI) for multiple variables. This
is a wrapper for the empirical_EVPI function. See the documentation of the 
<code><a href="#topic+empirical_EVPI">empirical_EVPI</a></code> function for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>multi_EVPI(mc, first_out_var, write_table = FALSE, outfolder = NA)

## S3 method for class 'EVPI_outputs'
summary(object, ...)

## S3 method for class 'EVPI_outputs'
plot(
  x,
  out_var,
  fileformat = NA,
  outfolder = NA,
  scale_results = TRUE,
  legend_table = NULL,
  output_legend_table = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multi_EVPI_+3A_mc">mc</code></td>
<td>
<p>output table from a Monte Carlo simulation,
e.g. as realized with the decisionSupport package</p>
</td></tr>
<tr><td><code id="multi_EVPI_+3A_first_out_var">first_out_var</code></td>
<td>
<p>name of the column in the mc table that contains the first output
variable. Information Values are computed for variables in all earlier columns.</p>
</td></tr>
<tr><td><code id="multi_EVPI_+3A_write_table">write_table</code></td>
<td>
<p>boolean parameter indicating whether an output table should be written.</p>
</td></tr>
<tr><td><code id="multi_EVPI_+3A_outfolder">outfolder</code></td>
<td>
<p>folder where the outputs should be saved (this is optional).</p>
</td></tr>
<tr><td><code id="multi_EVPI_+3A_object">object</code></td>
<td>
<p>EVPI_res object (produced with multi_EVPI) as input to the
summary function plot.</p>
</td></tr>
<tr><td><code id="multi_EVPI_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods, such as graphical parameters (see par).</p>
</td></tr>
<tr><td><code id="multi_EVPI_+3A_x">x</code></td>
<td>
<p>object of class EVPI_outputs as produced with the multi_EVPI function</p>
</td></tr>
<tr><td><code id="multi_EVPI_+3A_out_var">out_var</code></td>
<td>
<p>name of the output variable to be plotted</p>
</td></tr>
<tr><td><code id="multi_EVPI_+3A_fileformat">fileformat</code></td>
<td>
<p>The file format to be used for the outputs. Currently only
NA (for R plot output) and &quot;png&quot; (for a PNG file) are implemented. Note that
when this is !NA, the outfolder parameter must point to a valid folder.</p>
</td></tr>
<tr><td><code id="multi_EVPI_+3A_scale_results">scale_results</code></td>
<td>
<p>boolean variable indicating if resulting high numbers
should be scaled to avoid numbers in the plot that cannot be read easily. If
this is TRUE, numbers are divided by an appropriate divisor and a suffix is
added to the number in the plot (e.g. &quot;in millions&quot;).</p>
</td></tr>
<tr><td><code id="multi_EVPI_+3A_legend_table">legend_table</code></td>
<td>
<p>a data.frame with two columns variable and label. The
variable column should contain the name of the independent variables as
listed in the Monte Carlo table. The label column should contain the label
to be used for this variable in the EVPI plot.</p>
</td></tr>
<tr><td><code id="multi_EVPI_+3A_output_legend_table">output_legend_table</code></td>
<td>
<p>a data.frame with two columns variable and label.
The variable column should contain the name of the dependent variables as
listed in the Monte Carlo table. The label column should contain the label
to be used for this variable in the EVPI plot. Note that labels for both
dependent and independent variables can be provided in the same table. Then
both parameters legend_table and output_legend_table can point to the same
table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>invisible list of as many elements as there are output variables 
in the Monte Carlo table:
each element refers to one of the output variables and contains a data.frame with five
columns:
(1) variable - the input variable names
(2) expected_gain - expected gain when project is
implemented, without knowing the value of the test
variable, equals NA in case there is no variation in the tested variable
(3) EVPI_do - the Expected Value of Perfect Information on the respective input variable,
if the analysis suggests that the expected value of the decision is likely positive
(e.g. the project should be done)
(4) EVPI_dont - the Expected Value of Perfect Information on the respective input variable,
if the analysis suggests that the expected value of the decision is likely negative
(e.g. the project should not be done)
(5) the decision whether to implement with the project based on imperfect information
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling, Katja Schiffers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

### In the following example, the sign of the calculation
### is entirely determined by the variable indep1, so
### this should be expected to have a high EVPI. Variable
### indep2 doesn't affect the sign of the output, so it
### should not have information value.

montecarlo &lt;- data.frame(indep1 = rnorm(1000), indep2 = rnorm(1000, 3))
montecarlo[, 'output1'] &lt;- montecarlo[, 'indep1'] * montecarlo[, 'indep2']
montecarlo[, 'output2'] &lt;- (montecarlo[, 'indep1'] * (montecarlo[, 'indep2']) + 10)

results_all &lt;- multi_EVPI(montecarlo,"output1")
summary(results_all)
plot(results_all, "output1")
plot(results_all, "output2")


### In the following example, the sign of the calculation is entirely
### determined by the variable indep1, so this should be expected to have
### a high EVPI. Variable indep2 doesn't affect the sign of the output,
### so it should not have information value.

montecarlo &lt;- data.frame(indep1 = rnorm(1000), indep2 = rnorm(1000, mean = 3))
montecarlo[, 'output1'] &lt;- montecarlo[, 'indep1'] * montecarlo[, 'indep2']
montecarlo[, 'output2'] &lt;- (montecarlo[, 'indep1'] * (montecarlo[, 'indep2']) + 10)

results_all &lt;- multi_EVPI(montecarlo,"output1")
summary(results_all)
plot(results_all, "output1")
plot(results_all, "output2")

</code></pre>

<hr>
<h2 id='paramtnormci_fit'>Fit parameters of truncated normal distribution based on a confidence interval.</h2><span id='topic+paramtnormci_fit'></span>

<h3>Description</h3>

<p>This function fits the distribution parameters, i.e. <code>mean</code> and <code>sd</code>, of a truncated
normal distribution from an arbitrary confidence interval and, optionally, the median.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paramtnormci_fit(
  p,
  ci,
  median = mean(ci),
  lowerTrunc = -Inf,
  upperTrunc = Inf,
  relativeTolerance = 0.05,
  fitMethod = "Nelder-Mead",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paramtnormci_fit_+3A_p">p</code></td>
<td>
<p><code>numeric</code> 2-dimensional vector; probabilities of upper and lower bound of the
corresponding confidence interval.</p>
</td></tr>
<tr><td><code id="paramtnormci_fit_+3A_ci">ci</code></td>
<td>
<p><code>numeric</code> 2-dimensional vector; lower, i.e <code>ci[[1]]</code>, and upper bound, i.e
<code>ci[[2]]</code>, of the  confidence interval.</p>
</td></tr>
<tr><td><code id="paramtnormci_fit_+3A_median">median</code></td>
<td>
<p>if <code>NULL</code>: truncated normal is fitted only to lower and upper value of the
confidence interval; if <code>numeric</code>: truncated normal is fitted on the confidence interval
and the median simultaneously. For details cf. below.</p>
</td></tr>
<tr><td><code id="paramtnormci_fit_+3A_lowertrunc">lowerTrunc</code></td>
<td>
<p><code>numeric</code>; lower truncation point of the distribution (&gt;= <code>-Inf</code>).</p>
</td></tr>
<tr><td><code id="paramtnormci_fit_+3A_uppertrunc">upperTrunc</code></td>
<td>
<p><code>numeric</code>; upper truncation point of the distribution (&lt;= <code>Inf</code>).</p>
</td></tr>
<tr><td><code id="paramtnormci_fit_+3A_relativetolerance">relativeTolerance</code></td>
<td>
<p><code>numeric</code>; the relative tolerance level of deviation of the
generated probability levels from the specified confidence interval. If the relative deviation
is greater than <code>relativeTolerance</code> a warning is given.</p>
</td></tr>
<tr><td><code id="paramtnormci_fit_+3A_fitmethod">fitMethod</code></td>
<td>
<p>optimization method used in <code><a href="stats.html#topic+constrOptim">constrOptim</a></code>.</p>
</td></tr>
<tr><td><code id="paramtnormci_fit_+3A_...">...</code></td>
<td>
<p>further parameters to be passed to <code><a href="stats.html#topic+constrOptim">constrOptim</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details of the truncated normal distribution see <code><a href="msm.html#topic+tnorm">tnorm</a></code>.
</p>
<p>The cumulative distribution of a truncated normal <code class="reqn">F_{\mu, \sigma}</code>(x) gives the
probability that a sampled value is less than <code class="reqn">x</code>. This is equivalent to saying that for
the vector of quantiles <code class="reqn">q=(q(p_1),
  \ldots, q(p_k))</code> at the corresponding probabilities <code class="reqn">p=(p_1, \ldots, p_k)</code> it holds that
</p>
<p style="text-align: center;"><code class="reqn">p_i = F_{\mu, \sigma}(q_{p_i}),~i = 1, \ldots, k</code>
</p>

<p>In the case of arbitrary postulated quantiles this system of equations might not have a
solution in <code class="reqn">\mu</code> and <code class="reqn">\sigma</code>. A least squares fit leads to an approximate solution:
</p>
<p style="text-align: center;"><code class="reqn">\sum_{i=1}^k (p_i - F_{\mu, \sigma}(q_{p_i}))^2 = \min</code>
</p>

<p>defines the parameters <code class="reqn">\mu</code> and <code class="reqn">\sigma</code> of the underlying normal distribution. This
method solves this minimization problem for two cases:
</p>

<ol>
<li> <p><code>ci[[1]] &lt; median &lt; ci[[2]]</code>: The parameters are fitted on the lower and upper value
of the confidence interval and the median, formally:<br />
<code class="reqn">k=3</code><br />
<code class="reqn">p_1</code>=<code>p[[1]]</code>, <code class="reqn">p_2</code>=<code>0.5</code> and <code class="reqn">p_3</code>=<code>p[[2]]</code>;<br />
<code class="reqn">q(p_1)</code>=<code>ci[[1]]</code>,
<code class="reqn">q(0.5)</code>=<code>median</code> and
<code class="reqn">q(p_3)</code>=<code>ci[[2]]</code>
</p>
</li>
<li> <p><code>median=NULL</code>: The parameters are fitted on the lower and upper value of the
confidence interval only, formally:<br />
<code class="reqn">k=2</code><br />
<code class="reqn">p_1</code>=<code>p[[1]]</code>, <code class="reqn">p_2</code>=<code>p[[2]]</code>;<br />
<code class="reqn">q(p_1)</code>=<code>ci[[1]]</code>,
<code class="reqn">q(p_2)</code>=<code>ci[[2]]</code>
</p>
</li></ol>

<p>The <code>(p[[2]]-p[[1]])</code> - confidence interval must be symmetric in the sense that
<code>p[[1]] + p[[2]] = 1</code>.
</p>


<h3>Value</h3>

<p>A list with elements <code>mean</code> and <code>sd</code>, i.e. the parameters of the underlying
normal distribution.
</p>


<h3>See Also</h3>

<p><code><a href="msm.html#topic+tnorm">tnorm</a></code>, <code><a href="stats.html#topic+constrOptim">constrOptim</a></code>
</p>

<hr>
<h2 id='paramtnormci_numeric'>Return parameters of truncated normal distribution based on a confidence interval.</h2><span id='topic+paramtnormci_numeric'></span>

<h3>Description</h3>

<p>This function calculates the distribution parameters, i.e. <code>mean</code> and <code>sd</code>, of a
truncated normal distribution from an arbitrary confidence interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>paramtnormci_numeric(
  p,
  ci,
  lowerTrunc = -Inf,
  upperTrunc = Inf,
  relativeTolerance = 0.05,
  rootMethod = "probability",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="paramtnormci_numeric_+3A_p">p</code></td>
<td>
<p><code>numeric</code> 2-dimensional vector; probabilities of lower and upper bound of the
corresponding confidence interval.</p>
</td></tr>
<tr><td><code id="paramtnormci_numeric_+3A_ci">ci</code></td>
<td>
<p><code>numeric</code> 2-dimensional vector; lower, i.e <code>ci[[1]]</code>, and upper bound, i.e
<code>ci[[2]]</code>, of the  confidence interval.</p>
</td></tr>
<tr><td><code id="paramtnormci_numeric_+3A_lowertrunc">lowerTrunc</code></td>
<td>
<p><code>numeric</code>; lower truncation point of the distribution (&gt;= <code>-Inf</code>).</p>
</td></tr>
<tr><td><code id="paramtnormci_numeric_+3A_uppertrunc">upperTrunc</code></td>
<td>
<p><code>numeric</code>; upper truncation point of the distribution (&lt;= <code>Inf</code>).</p>
</td></tr>
<tr><td><code id="paramtnormci_numeric_+3A_relativetolerance">relativeTolerance</code></td>
<td>
<p><code>numeric</code>; the relative tolerance level of deviation of the
generated confidence interval from the specified interval. If this deviation is greater than
<code>relativeTolerance</code> a warning is given.</p>
</td></tr>
<tr><td><code id="paramtnormci_numeric_+3A_rootmethod">rootMethod</code></td>
<td>
<p><code>character</code>; if <code>="probability"</code> the equation defining the parameters <code>mean</code> and
<code>sd</code> is the difference between calculated and given probabilities of the confidence
interval; if <code>="quantile"</code> the equation defining the parameters is the difference between
calculated and given upper and lower value of the confidence interval.</p>
</td></tr>
<tr><td><code id="paramtnormci_numeric_+3A_...">...</code></td>
<td>
<p>Further parameters passed to <code><a href="nleqslv.html#topic+nleqslv">nleqslv</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For details of the truncated normal distribution see <code><a href="msm.html#topic+tnorm">tnorm</a></code>.
#' @importFrom nleqslv nleqslv
</p>


<h3>Value</h3>

<p>A list with elements <code>mean</code> and <code>sd</code>, i.e. the parameters of the underlying
normal distribution.
</p>


<h3>See Also</h3>

<p><code><a href="msm.html#topic+tnorm">tnorm</a></code>, <code><a href="nleqslv.html#topic+nleqslv">nleqslv</a></code>
</p>

<hr>
<h2 id='plainNames2data.frameNames'>Transform model function variable names: plain to data.frame names.</h2><span id='topic+plainNames2data.frameNames'></span>

<h3>Description</h3>

<p>The variable names of a function are transformed from plain variable names to data.frame names
of the form <code>x$&lt;globalName&gt;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plainNames2data.frameNames(modelFunction, plainNames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plainNames2data.frameNames_+3A_modelfunction">modelFunction</code></td>
<td>
<p>a function whose body contains variables with plain names. The 
function must not contain any arguments.</p>
</td></tr>
<tr><td><code id="plainNames2data.frameNames_+3A_plainnames">plainNames</code></td>
<td>
<p>a <code>character</code> vector containing the names of the  variables that
shall be transformed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input function must be of the form:
</p>
<pre>
   modelFunction&lt;-function(){
     ...
     &lt;expression with variable1&gt;
     ...
   }
 </pre>


<h3>Value</h3>

<p>The transformed function which is of the form:
</p>
<pre>
   function(x){
     ...
     &lt;expression with x$variable1&gt;
     ...
   }
 </pre>


<h3>Warning</h3>

<p>If there are local functions within the function <code>modelFunction</code> defined, whose arguments
have identical names to any of the <code>plainNames</code> the function fails!
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcSimulation">mcSimulation</a></code>, <code><a href="#topic+estimate">estimate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> profit1&lt;-function(){
   list(Profit=revenue-costs)
 }
 profit2&lt;-plainNames2data.frameNames(modelFunction=profit1, 
                                               plainNames=c("revenue", "costs"))
 print(profit2)
 is.function(profit2)
 profit2(data.frame("revenue"=10,"costs"=2))
</code></pre>

<hr>
<h2 id='plot_cashflow'>Cashflow plot for Monte Carlo simulation results</h2><span id='topic+plot_cashflow'></span>

<h3>Description</h3>

<p>Creates a cashflow plot of the returned list of related outputs from the <code><a href="#topic+mcSimulation">mcSimulation</a></code> function using <code><a href="ggplot2.html#topic+ggplot2">ggplot2</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_cashflow(
  mcSimulation_object,
  cashflow_var_name,
  x_axis_name = "Timeline of intervention",
  y_axis_name = "Cashflow",
  legend_name = "Quantiles (%)",
  legend_labels = c("5 to 95", "25 to 75", "median"),
  color_25_75 = "grey40",
  color_5_95 = "grey70",
  color_median = "blue",
  facet_labels = cashflow_var_name,
  base_size = 11,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_cashflow_+3A_mcsimulation_object">mcSimulation_object</code></td>
<td>
<p>is a data frame of Monte Carlo simulations of cashflow outputs (in wide format, see example). Usually the &quot;mcSimulation_object.csv&quot; file generated by <code><a href="#topic+mcSimulation">mcSimulation</a></code> function.</p>
</td></tr>
<tr><td><code id="plot_cashflow_+3A_cashflow_var_name">cashflow_var_name</code></td>
<td>
<p>is the name (character string) for the variable name used to define cashflow in the returned list of outputs from the <code><a href="#topic+mcSimulation">mcSimulation</a></code> function. If multiple decision options are provided this will produce a comparative panel plot.</p>
</td></tr>
<tr><td><code id="plot_cashflow_+3A_x_axis_name">x_axis_name</code></td>
<td>
<p>is the name (character string) for the title of the timeline of the intervention to be printed on the x axis in quotes.</p>
</td></tr>
<tr><td><code id="plot_cashflow_+3A_y_axis_name">y_axis_name</code></td>
<td>
<p>is the name (character string) for the title of the units of the cashflow to be printed on the y axis.</p>
</td></tr>
<tr><td><code id="plot_cashflow_+3A_legend_name">legend_name</code></td>
<td>
<p>is the name (character string) for the title of the legend</p>
</td></tr>
<tr><td><code id="plot_cashflow_+3A_legend_labels">legend_labels</code></td>
<td>
<p>is the name (character string) for the labels of the legend. The default is inner, outer and median quantiles, i.e. 'c(&quot;5 to 95&quot;, &quot;25 to 75&quot;, &quot;median&quot;)' and replacements should follow the same order</p>
</td></tr>
<tr><td><code id="plot_cashflow_+3A_color_25_75">color_25_75</code></td>
<td>
<p>is the color for the shade fill of the 25-75% quantile from the grDevices colors. The default is &quot;grey40&quot;.</p>
</td></tr>
<tr><td><code id="plot_cashflow_+3A_color_5_95">color_5_95</code></td>
<td>
<p>is the color for the shade fill of the 5-95% quantile from the grDevices colors. The default is &quot;grey70&quot;.</p>
</td></tr>
<tr><td><code id="plot_cashflow_+3A_color_median">color_median</code></td>
<td>
<p>is the color for the median line from the grDevices colors. The default is  &quot;blue&quot;.</p>
</td></tr>
<tr><td><code id="plot_cashflow_+3A_facet_labels">facet_labels</code></td>
<td>
<p>are the names (character string) for the decisions. The default is the cashflow_var_name parameter.</p>
</td></tr>
<tr><td><code id="plot_cashflow_+3A_base_size">base_size</code></td>
<td>
<p>is the base text size to be used for the plot. The default is 11, this is the <code><a href="ggplot2.html#topic+ggtheme">ggplot2::ggtheme</a></code> default</p>
</td></tr>
<tr><td><code id="plot_cashflow_+3A_...">...</code></td>
<td>
<p>accepts arguments to be passed to <code><a href="ggplot2.html#topic+ggtheme">ggplot2::ggtheme</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function automatically defines quantiles (5 to 95% and 25 to 75%) as well as a value for the median.
</p>


<h3>Value</h3>

<p>This function returns a plot of classes <code>'gg'</code>, 
and <code>'ggplot'</code>. This allows the user to
continue editing some features of the plots through the syntax 
<code>'+'</code>.
</p>


<h3>Author(s)</h3>

<p>Eduardo Fernandez (<a href="mailto:efernand@uni-bonn.de">efernand@uni-bonn.de</a>)
</p>
<p>Cory Whitney (<a href="mailto:cory.whitney@uni-bonn.de">cory.whitney@uni-bonn.de</a>)
</p>


<h3>References</h3>

<p>Lanzanova Denis, Cory Whitney, Keith Shepherd, and Eike Luedeling. “Improving Development Efficiency through Decision Analysis: Reservoir Protection in Burkina Faso.” Environmental Modelling &amp; Software 115 (May 1, 2019): 164–75. <a href="https://doi.org/10.1016/j.envsoft.2019.01.016">doi:10.1016/j.envsoft.2019.01.016</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
# Plotting the cashflow:

# Create the estimate object (for multiple options):

variable = c("revenue_option1", "costs_option1", "n_years", 
             "revenue_option2", "costs_option2")
distribution = c("norm", "norm", "const", "norm", "norm")
lower = c(10000,  5000, 10, 8000,  500)
upper = c(100000, 50000, 10, 80000,  30000)

costBenefitEstimate &lt;- as.estimate(variable, distribution, lower, upper)

# Define the model function without name for the return value:

profit1 &lt;- function(x) {
  
cashflow_option1 &lt;- vv(revenue_option1 - costs_option1, n = n_years, var_CV = 100)
cashflow_option2 &lt;- vv(revenue_option2 - costs_option2, n = n_years, var_CV = 100)

return(list(Revenues_option1 = revenue_option1,
            Revenues_option2 = revenue_option2,
            Costs_option1 = costs_option1,
            Costs_option2 = costs_option2,
            Cashflow_option_one = cashflow_option1,
            Cashflow_option_two = cashflow_option2))
}

# Perform the Monte Carlo simulation:

predictionProfit1 &lt;- mcSimulation(estimate = costBenefitEstimate,
                                  model_function = profit1,
                                  numberOfModelRuns = 10000,
                                  functionSyntax = "plainNames")


# Plot the cashflow distribution over time

plot_cashflow(mcSimulation_object = predictionProfit1, 
              cashflow_var_name = "Cashflow_option_one",
              x_axis_name = "Years with intervention",
              y_axis_name = "Annual cashflow in USD",
              color_25_75 = "green4", color_5_95 = "green1",
              color_median = "red")

##############################################################
# Example 2 (Plotting the cashflow with panels for comparison):

# Compare the cashflow distribution over time for multiple decision options  

plot_cashflow(mcSimulation_object = predictionProfit1, 
              cashflow_var_name = c("Cashflow_option_one", "Cashflow_option_two"),
              x_axis_name = "Years with intervention",
              y_axis_name = "Annual cashflow in USD",
              color_25_75 = "green4", color_5_95 = "green1",
              color_median = "red", 
              facet_labels = c("Option 1", "Option 2"))
  
</code></pre>

<hr>
<h2 id='plot_distributions'>Probability distribution plots for various types of Monte Carlo simulation results</h2><span id='topic+plot_distributions'></span>

<h3>Description</h3>

<p>Several plotting options for distribution outputs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_distributions(
  mcSimulation_object,
  vars,
  method = "smooth_simple_overlay",
  bins = 150,
  binwidth = NULL,
  old_names = NULL,
  new_names = NULL,
  colors = NULL,
  outlier_shape = ".",
  x_axis_name = "Outcome distribution",
  y_axis_name = NULL,
  base_size = 11,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_distributions_+3A_mcsimulation_object">mcSimulation_object</code></td>
<td>
<p>is an object of Monte Carlo simulation outputs from the <code><a href="#topic+mcSimulation">mcSimulation</a></code> function</p>
</td></tr>
<tr><td><code id="plot_distributions_+3A_vars">vars</code></td>
<td>
<p>is a vector containing variable names from the <code>mcSimulation_object</code>. This can also be a single variable name</p>
</td></tr>
<tr><td><code id="plot_distributions_+3A_method">method</code></td>
<td>
<p>is the plot option to be used in <code>link{ggplot2}</code>: &quot;smooth_simple_overlay&quot; creates a density plot with <code><a href="ggplot2.html#topic+geom_density">geom_density</a></code>, &quot;hist_simple_overlay&quot; creates a histogram with <code><a href="ggplot2.html#topic+geom_histogram">geom_histogram</a></code>, &quot;boxplot&quot; creates a boxplot with <code><a href="ggplot2.html#topic+geom_boxplot">geom_boxplot</a></code> and &quot;boxplot_density&quot; creates a density plot with a boxplot using <code><a href="ggplot2.html#topic+geom_density">geom_density</a></code> and <code><a href="ggplot2.html#topic+geom_boxplot">geom_boxplot</a></code></p>
</td></tr>
<tr><td><code id="plot_distributions_+3A_bins">bins</code></td>
<td>
<p>are the number of bins to use for the <code><a href="ggplot2.html#topic+geom_histogram">geom_histogram</a></code>. Default number of bins is 150</p>
</td></tr>
<tr><td><code id="plot_distributions_+3A_binwidth">binwidth</code></td>
<td>
<p>is the width of the bins to use for the <code><a href="ggplot2.html#topic+geom_histogram">geom_histogram</a></code>. Default number is 1000. When both <code>bins</code> and <code>binwidth</code> are defined, the later overrides <code>bins</code></p>
</td></tr>
<tr><td><code id="plot_distributions_+3A_old_names">old_names</code></td>
<td>
<p>are the variable names from the MC simulation outputs that refer to the distribution values. This should be a vector of character strings. This is set to NULL with the assumption that the existing names for variables are preferred</p>
</td></tr>
<tr><td><code id="plot_distributions_+3A_new_names">new_names</code></td>
<td>
<p>are the variable names to replace the MC simulation outputs that refer to the distribution values. This should be a vector of character strings. This is set to NULL with the assumption that the existing names for variables are preferred</p>
</td></tr>
<tr><td><code id="plot_distributions_+3A_colors">colors</code></td>
<td>
<p>is the color palette to be used for the fill of distribution shapes and boxplots. The default is c(&quot;#009999&quot;, &quot;#0000FF&quot;, &quot;#56B4E9&quot;, &quot;#009E73&quot;,&quot;#F0E442&quot;, &quot;#0072B2&quot;, &quot;#D55E00&quot;, &quot;#CC79A7&quot;) assuming a maximum of eight variables to be compared</p>
</td></tr>
<tr><td><code id="plot_distributions_+3A_outlier_shape">outlier_shape</code></td>
<td>
<p>is the optional shape to replace the outliers in the boxplot. To show no outliers use NA. See <code><a href="ggplot2.html#topic+aes_linetype_size_shape">shape</a></code> for shape options</p>
</td></tr>
<tr><td><code id="plot_distributions_+3A_x_axis_name">x_axis_name</code></td>
<td>
<p>is the name (character string) to be passed to the x-axis title. Default is &quot;Outcome distribution&quot; and allows allow the user to add a customized axis title</p>
</td></tr>
<tr><td><code id="plot_distributions_+3A_y_axis_name">y_axis_name</code></td>
<td>
<p>is the name (character string) to be passed to the y-axis title. Default is NULL to allow the user to add a customized axis title. If a name is not provided the title will be &quot;Number of points in bin&quot; for the <code>hist_simple_overlay</code> method and &quot;Density estimate&quot; for all other plot options</p>
</td></tr>
<tr><td><code id="plot_distributions_+3A_base_size">base_size</code></td>
<td>
<p>is the base text size to be used for the plot. The default is 11, this is the <code><a href="ggplot2.html#topic+ggtheme">ggplot2::ggtheme</a></code> default</p>
</td></tr>
<tr><td><code id="plot_distributions_+3A_...">...</code></td>
<td>
<p>accepts arguments to be passed to <code><a href="ggplot2.html#topic+ggtheme">ggplot2::ggtheme</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a plot of classes <code>'gg'</code>, 
and <code>'ggplot'</code>. This allows the user to
continue editing some features of the plots through the syntax 
<code>'+'</code>.
</p>


<h3>Author(s)</h3>

<p>Eduardo Fernandez (<a href="mailto:efernand@uni-bonn.de">efernand@uni-bonn.de</a>)
</p>
<p>Cory Whitney (<a href="mailto:cory.whitney@uni-bonn.de">cory.whitney@uni-bonn.de</a>)
</p>


<h3>References</h3>

<p>Do, Hoa, Eike Luedeling, and Cory Whitney. “Decision Analysis of Agroforestry Options Reveals Adoption Risks for Resource-Poor Farmers.” Agronomy for Sustainable Development 40, no. 3 (June 2020): 20. <a href="https://doi.org/10.1007/s13593-020-00624-5">doi:10.1007/s13593-020-00624-5</a>.
Lanzanova, Denis, Cory Whitney, Keith Shepherd, and Eike Luedeling. “Improving Development Efficiency through Decision Analysis: Reservoir Protection in Burkina Faso.” Environmental Modelling &amp; Software 115 (May 1, 2019): 164–75. <a href="https://doi.org/10.1016/j.envsoft.2019.01.016">doi:10.1016/j.envsoft.2019.01.016</a>.
Ruett, Marius, Cory Whitney, and Eike Luedeling. “Model-Based Evaluation of Management Options in Ornamental Plant Nurseries.” Journal of Cleaner Production 271 (June 2020): 122653. <a href="https://doi.org/10.1016/j.jclepro.2020.122653">doi:10.1016/j.jclepro.2020.122653</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##############################################################
# Example 1 (Creating the estimate from the command line):
#############################################################
# Create the estimate object:

variable = c("revenue", "costs")
distribution = c("norm", "norm")
lower = c(10000,  5000)
upper = c(100000, 50000)
costBenefitEstimate &lt;- as.estimate(variable, distribution, lower, upper)

# (a) Define the model function without name for the return value:

profit1 &lt;- function(x) {
  x$revenue - x$costs
  return(list(Revenues = x$revenue,
              Costs = x$costs))
}

# Perform the Monte Carlo simulation:

predictionProfit1 &lt;- mcSimulation(estimate = costBenefitEstimate,
                                  model_function = profit1,
                                  numberOfModelRuns = 10000,
                                  functionSyntax = "data.frameNames")


# Plot the distributions

plot_distributions(mcSimulation_object = predictionProfit1, vars = c("Revenues", "Costs"),
         method = "smooth_simple_overlay")

plot_distributions(mcSimulation_object = predictionProfit1, vars = c("Revenues", "Costs"),
         method = "hist_simple_overlay", bins = 30)

plot_distributions(mcSimulation_object = predictionProfit1, vars = c("Costs"),
         method = "hist_simple_overlay", binwidth = 1000)

plot_distributions(mcSimulation_object = predictionProfit1, vars = c("Revenues", "Costs"),
         method = "boxplot_density", outlier_shape = 3)
 

</code></pre>

<hr>
<h2 id='plot_evpi'>Visualizing the results of Expected Value of Perfect Information (EVPI) analysis for various types of Monte Carlo simulation results</h2><span id='topic+plot_evpi'></span>

<h3>Description</h3>

<p>Plotting the Expected Value of Perfect Information (EVPI) of Monte Carlo outputs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_evpi(
  EVPIresults,
  decision_vars,
  input_table = NULL,
  new_names = NULL,
  unit = NULL,
  x_axis_name = "Expected Value of Perfect Information",
  y_axis_name = NULL,
  bar_color = "cadetblue",
  base_size = 11,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_evpi_+3A_evpiresults">EVPIresults</code></td>
<td>
<p>are the results of the <code><a href="#topic+multi_EVPI">multi_EVPI</a></code> function</p>
</td></tr>
<tr><td><code id="plot_evpi_+3A_decision_vars">decision_vars</code></td>
<td>
<p>are the names of the decision variables in the output of the <code><a href="#topic+mcSimulation">mcSimulation</a></code> function</p>
</td></tr>
<tr><td><code id="plot_evpi_+3A_input_table">input_table</code></td>
<td>
<p>is a data frame with at least two columns named 'variable' and 'label'. The 'variable column should have one entry for the name of each variable contained in any of the plots. In preparing the figure, the function will replace the variable names with the labels. If the label is missing then the plot will show 'NA' in the place of the variable name. Default is NULL and uses the original variable names.</p>
</td></tr>
<tr><td><code id="plot_evpi_+3A_new_names">new_names</code></td>
<td>
<p>are the reformatted replacement names of the decision variables in the output of the <code><a href="#topic+mcSimulation">mcSimulation</a></code> function</p>
</td></tr>
<tr><td><code id="plot_evpi_+3A_unit">unit</code></td>
<td>
<p>is the symbol to display before the evpi value on the x axis. It accepts text or (many) unicode formatted symbol text</p>
</td></tr>
<tr><td><code id="plot_evpi_+3A_x_axis_name">x_axis_name</code></td>
<td>
<p>is the name (character string) to be passed to the x-axis title. Default is &quot;Expected Value of Perfect Information&quot; and allows allow the user to add a customized axis title</p>
</td></tr>
<tr><td><code id="plot_evpi_+3A_y_axis_name">y_axis_name</code></td>
<td>
<p>is the name (character string) to be passed to the y-axis title. Default is NULL to allow the user to add a customized axis title</p>
</td></tr>
<tr><td><code id="plot_evpi_+3A_bar_color">bar_color</code></td>
<td>
<p>is the color to be used for the EVPI barplot. Default is &quot;cadetblue&quot;</p>
</td></tr>
<tr><td><code id="plot_evpi_+3A_base_size">base_size</code></td>
<td>
<p>is the base text size to be used for the plot. The default is 11, this is the <code><a href="ggplot2.html#topic+ggtheme">ggplot2::ggtheme</a></code> default</p>
</td></tr>
<tr><td><code id="plot_evpi_+3A_...">...</code></td>
<td>
<p>accepts arguments to be passed to <code><a href="ggplot2.html#topic+ggtheme">ggplot2::ggtheme</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a plot of classes <code>'gg'</code>, 
and <code>'ggplot'</code>. This allows the user to
continue editing some features of the plots through the syntax 
<code>'+'</code>.
</p>


<h3>Author(s)</h3>

<p>Eduardo Fernandez (<a href="mailto:efernand@uni-bonn.de">efernand@uni-bonn.de</a>)
</p>
<p>Cory Whitney (<a href="mailto:cory.whitney@uni-bonn.de">cory.whitney@uni-bonn.de</a>)
</p>


<h3>References</h3>

<p>Do, Hoa, Eike Luedeling, and Cory Whitney. “Decision Analysis of Agroforestry Options Reveals Adoption Risks for Resource-Poor Farmers.” Agronomy for Sustainable Development 40, no. 3 (June 2020): 20. <a href="https://doi.org/10.1007/s13593-020-00624-5">doi:10.1007/s13593-020-00624-5</a>.
Lanzanova, Denis, Cory Whitney, Keith Shepherd, and Eike Luedeling. “Improving Development Efficiency through Decision Analysis: Reservoir Protection in Burkina Faso.” Environmental Modelling &amp; Software 115 (May 1, 2019): 164–75. <a href="https://doi.org/10.1016/j.envsoft.2019.01.016">doi:10.1016/j.envsoft.2019.01.016</a>.
Luedeling, Eike, and Keith Shepherd. “Decision-Focused Agricultural Research.” Solutions 7, no. 5 (2016): 46–54. <a href="https://apps.worldagroforestry.org/downloads/Publications/PDFS/JA16154.pdf">https://apps.worldagroforestry.org/downloads/Publications/PDFS/JA16154.pdf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create a data.frame

montecarlo &lt;- data.frame(indep1 = rnorm(1000, sd = 50, mean = 100), 
                         indep2 = rnorm(1000, sd = 100, mean = 100))
montecarlo[, 'output1'] &lt;- montecarlo[, 'indep1'] * montecarlo[, 'indep2']
montecarlo[, 'output2'] &lt;- (montecarlo[, 'indep1'] * (montecarlo[, 'indep2']) + 10)

# Run the multi_EVPI function 
 
results_all &lt;- multi_EVPI(montecarlo,"output1")

plot_evpi(results_all, decision_vars = c("output1", "output2"), 
new_names = c("Decision option 1", "Decision option 2"))

</code></pre>

<hr>
<h2 id='plot_pls'>Visualizing Projection to Latent Structures (PLS) regression outputs for various types of Monte Carlo simulation results</h2><span id='topic+plot_pls'></span>

<h3>Description</h3>

<p>Plotting the Variable Importance in the Projection (VIP) statistic and coefficients of a PLS model of Monte Carlo outputs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_pls(
  plsrResults,
  input_table = NULL,
  cut_off_line = 1,
  threshold = 0.8,
  x_axis_name = "Variable Importance in Projection",
  y_axis_name = NULL,
  legend_name = "Coefficient",
  legend_labels = c("Positive", "Negative"),
  pos_color = "cadetblue",
  neg_color = "firebrick",
  base_size = 11,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_pls_+3A_plsrresults">plsrResults</code></td>
<td>
<p>is an object of Projection to Latent Structures (PLS) regression outputs from the <code><a href="#topic+plsr.mcSimulation">plsr.mcSimulation</a></code> function</p>
</td></tr>
<tr><td><code id="plot_pls_+3A_input_table">input_table</code></td>
<td>
<p>is a data frame with at least two columns named 'variable' and 'label'. The 'variable column should have one entry for the name of each variable contained in any of the plots. In preparing the figure, the function will replace the variable names with the labels. If the label is missing then the plot will show 'NA' in the place of the variable name. Default is NULL and uses the original variable names.</p>
</td></tr>
<tr><td><code id="plot_pls_+3A_cut_off_line">cut_off_line</code></td>
<td>
<p>is the vertical line for the VIP variable selection. The default is 1 on the x-axis, which is a standard cut-off for VIP used for variable selection</p>
</td></tr>
<tr><td><code id="plot_pls_+3A_threshold">threshold</code></td>
<td>
<p>is the filter for reducing the number of variables shown in the plot. With this set to 0 all variables with a VIP &gt; 0 will be shown (often a very long list). In the default setting the overall plot only shows those variables with a VIP &gt; 0.8, which is a common cut-off for variable selection.</p>
</td></tr>
<tr><td><code id="plot_pls_+3A_x_axis_name">x_axis_name</code></td>
<td>
<p>is the name (character string) for the title of the timeline of the intervention to be printed on the x axis in quotes.</p>
</td></tr>
<tr><td><code id="plot_pls_+3A_y_axis_name">y_axis_name</code></td>
<td>
<p>is the name (character string) for the title of the units of the cashflow to be printed on the y axis.</p>
</td></tr>
<tr><td><code id="plot_pls_+3A_legend_name">legend_name</code></td>
<td>
<p>is the name (character string) for the title of the legend</p>
</td></tr>
<tr><td><code id="plot_pls_+3A_legend_labels">legend_labels</code></td>
<td>
<p>is the name (character string) for the labels of the legend. The default is 'c(&quot;Positive&quot;, &quot;Negative&quot;)' and replacements should follow the same order</p>
</td></tr>
<tr><td><code id="plot_pls_+3A_pos_color">pos_color</code></td>
<td>
<p>is the color to be used for positive coefficient values, default is &quot;cadetblue&quot;</p>
</td></tr>
<tr><td><code id="plot_pls_+3A_neg_color">neg_color</code></td>
<td>
<p>is the color to be used for negative coefficient values, default is &quot;firebrick&quot;</p>
</td></tr>
<tr><td><code id="plot_pls_+3A_base_size">base_size</code></td>
<td>
<p>is the base text size to be used for the plot. The default is 11, this is the <code><a href="ggplot2.html#topic+ggtheme">ggplot2::ggtheme</a></code> default</p>
</td></tr>
<tr><td><code id="plot_pls_+3A_...">...</code></td>
<td>
<p>accepts arguments to be passed to <code><a href="ggplot2.html#topic+ggtheme">ggplot2::ggtheme</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function returns a plot of classes <code>'gg'</code>, 
and <code>'ggplot'</code>. This allows the user to
continue editing some features of the plots through the syntax 
<code>'+'</code>.
</p>


<h3>Author(s)</h3>

<p>Eduardo Fernandez (<a href="mailto:efernand@uni-bonn.de">efernand@uni-bonn.de</a>)
</p>
<p>Cory Whitney (<a href="mailto:cory.whitney@uni-bonn.de">cory.whitney@uni-bonn.de</a>)
</p>


<h3>References</h3>

<p>Do, Hoa, Eike Luedeling, and Cory Whitney. “Decision Analysis of Agroforestry Options Reveals Adoption Risks for Resource-Poor Farmers.” Agronomy for Sustainable Development 40, no. 3 (June 2020): 20. <a href="https://doi.org/10.1007/s13593-020-00624-5">doi:10.1007/s13593-020-00624-5</a>.
Lanzanova, Denis, Cory Whitney, Keith Shepherd, and Eike Luedeling. “Improving Development Efficiency through Decision Analysis: Reservoir Protection in Burkina Faso.” Environmental Modelling &amp; Software 115 (May 1, 2019): 164–75. <a href="https://doi.org/10.1016/j.envsoft.2019.01.016">doi:10.1016/j.envsoft.2019.01.016</a>.
Luedeling, Eike, and Keith Shepherd. “Decision-Focused Agricultural Research.” Solutions 7, no. 5 (2016): 46–54. <a href="https://apps.worldagroforestry.org/downloads/Publications/PDFS/JA16154.pdf">https://apps.worldagroforestry.org/downloads/Publications/PDFS/JA16154.pdf</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create the estimate object:

variable = c("labor_cost", "investment_cost", "yield", "market_price")
distribution = c("posnorm", "posnorm", "posnorm", "posnorm")
lower = c(200, 20000, 5000, 10)
upper = c(10000, 100000, 20000, 200)

costBenefitEstimate &lt;- as.estimate(variable, distribution, lower, upper)

# Define the model function without name for the return value:

profit1 &lt;- function(x) {
  income &lt;- x$yield * x$market_price
  costs &lt;- x$labor_cost + x$investment_cost
  profit &lt;- income - costs
  return(list(Revenues = profit))
}

# Perform the Monte Carlo simulation:

predictionProfit1 &lt;- mcSimulation(estimate = costBenefitEstimate,
                                  model_function = profit1,
                                  numberOfModelRuns = 10000,
                                  functionSyntax = "data.frameNames")


# Run the PLS analysis

pls &lt;- plsr.mcSimulation(object = predictionProfit1,
resultName = names(predictionProfit1$y))
 
 # Plot PLS results 
 
 plot_pls(pls)

</code></pre>

<hr>
<h2 id='plsr.mcSimulation'>Partial Least Squares Regression (PLSR) of Monte Carlo simulation results.</h2><span id='topic+plsr.mcSimulation'></span>

<h3>Description</h3>

<p>Perform a Partial Least Squares Regression (PLSR) of Monte Carlo simulation results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plsr.mcSimulation(
  object,
  resultName = NULL,
  variables.x = names(object$x),
  method = "oscorespls",
  scale = TRUE,
  ncomp = 2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plsr.mcSimulation_+3A_object">object</code></td>
<td>
<p>An object of class <code>mcSimulation</code>.</p>
</td></tr>
<tr><td><code id="plsr.mcSimulation_+3A_resultname">resultName</code></td>
<td>
<p><code>character</code>: indicating the name of the component of
the simulation function (<code>model_function</code>) whose results histogram
shall be generated. If <code>model_function</code> is single valued, no name
needs to be supplied. Otherwise, one valid name has to be specified.
Defaults to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="plsr.mcSimulation_+3A_variables.x">variables.x</code></td>
<td>
<p><code>character</code> or <code>character</code> vector: Names of the 
components of the input variables to the simulation function, i.e. the
names of the variables in the input <code>estimate</code> which random sampling
results shall be displayed. Defaults to all components.</p>
</td></tr>
<tr><td><code id="plsr.mcSimulation_+3A_method">method</code></td>
<td>
<p>the multivariate regression method to be used.  If
<code>"model.frame"</code>, the model frame is returned.</p>
</td></tr>
<tr><td><code id="plsr.mcSimulation_+3A_scale">scale</code></td>
<td>
<p>numeric vector, or logical.  If numeric vector, <code class="reqn">X</code> is
scaled by dividing each variable with the corresponding element of
<code>scale</code>.  If <code>scale</code> is <code>TRUE</code>, <code class="reqn">X</code> is scaled by dividing
each variable by its sample standard deviation.  If cross-validation is
selected, scaling by the standard deviation is done for every segment.</p>
</td></tr>
<tr><td><code id="plsr.mcSimulation_+3A_ncomp">ncomp</code></td>
<td>
<p>the number of components to include in the model (see below).</p>
</td></tr>
<tr><td><code id="plsr.mcSimulation_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="pls.html#topic+mvr">plsr</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code><a href="pls.html#topic+mvr">mvr</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcSimulation">mcSimulation</a></code>, <code><a href="pls.html#topic+mvr">plsr</a></code>, 
<code><a href="pls.html#topic+summary.mvr">summary.mvr</a></code>, <code><a href="pls.html#topic+biplot.mvr">biplot.mvr</a></code>, 
<code><a href="pls.html#topic+coef.mvr">coef.mvr</a></code>, <code><a href="pls.html#topic+plot.mvr">plot.mvr</a></code>,
</p>

<hr>
<h2 id='print.mcSimulation'>Print Basic Results from Monte Carlo Simulation.</h2><span id='topic+print.mcSimulation'></span>

<h3>Description</h3>

<p>This function prints basic results from Monte Carlo simulation  and returns it invisible.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcSimulation'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.mcSimulation_+3A_x">x</code></td>
<td>
<p>An object of class <code>mcSimulation</code>.</p>
</td></tr>
<tr><td><code id="print.mcSimulation_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code><a href="base.html#topic+print.data.frame">print.data.frame</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+mcSimulation">mcSimulation</a></code>, <code><a href="base.html#topic+print.data.frame">print.data.frame</a></code>
</p>

<hr>
<h2 id='print.summary.eviSimulation'>Print the Summarized EVI Simulation Results.</h2><span id='topic+print.summary.eviSimulation'></span>

<h3>Description</h3>

<p>This function prints the summary of <code>eviSimulation</code> generated by 
<code><a href="#topic+summary.eviSimulation">summary.eviSimulation</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.eviSimulation'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.eviSimulation_+3A_x">x</code></td>
<td>
<p>An object of class <code>summary.eviSimulation</code>.</p>
</td></tr>
<tr><td><code id="print.summary.eviSimulation_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code><a href="base.html#topic+print.default">print.default</a></code> and  
<code><a href="#topic+print.summary.welfareDecisionAnalysis">print.summary.welfareDecisionAnalysis</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+eviSimulation">eviSimulation</a></code>, <code><a href="#topic+print.summary.welfareDecisionAnalysis">print.summary.welfareDecisionAnalysis</a></code>.
</p>

<hr>
<h2 id='print.summary.mcSimulation'>Print the summary of a Monte Carlo simulation.</h2><span id='topic+print.summary.mcSimulation'></span>

<h3>Description</h3>

<p>This function prints the summary of of <code>mcSimulation</code> obtained by <code><a href="#topic+summary.mcSimulation">summary.mcSimulation</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.mcSimulation'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.mcSimulation_+3A_x">x</code></td>
<td>
<p>An object of class <code>mcSimulation</code>.</p>
</td></tr>
<tr><td><code id="print.summary.mcSimulation_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to <code><a href="base.html#topic+print.data.frame">print.data.frame</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+mcSimulation">mcSimulation</a></code>, <code><a href="#topic+summary.mcSimulation">summary.mcSimulation</a></code>, 
<code><a href="base.html#topic+print.data.frame">print.data.frame</a></code>
</p>

<hr>
<h2 id='print.summary.welfareDecisionAnalysis'>Print the summarized Welfare Decision Analysis results.</h2><span id='topic+print.summary.welfareDecisionAnalysis'></span>

<h3>Description</h3>

<p>This function prints the summary of a Welfare Decision Analysis generated by  
<code><a href="#topic+summary.welfareDecisionAnalysis">summary.welfareDecisionAnalysis</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.welfareDecisionAnalysis'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.summary.welfareDecisionAnalysis_+3A_x">x</code></td>
<td>
<p>An object of class <code>summary.welfareDecisionAnalysis</code>.</p>
</td></tr>
<tr><td><code id="print.summary.welfareDecisionAnalysis_+3A_...">...</code></td>
<td>
<p>Further arguments to <code><a href="base.html#topic+print.data.frame">print.data.frame</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+welfareDecisionAnalysis">welfareDecisionAnalysis</a></code>, <code><a href="#topic+summary.welfareDecisionAnalysis">summary.welfareDecisionAnalysis</a></code>, 
<code><a href="base.html#topic+print.data.frame">print.data.frame</a></code>.
</p>

<hr>
<h2 id='random'>Quantiles or empirically based generic random number generation.</h2><span id='topic+random'></span><span id='topic+random.default'></span><span id='topic+random.vector'></span><span id='topic+random.data.frame'></span>

<h3>Description</h3>

<p>These functions generate random numbers for parametric distributions, parameters of which are 
determined by given quantiles or for distributions purely defined empirically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random(rho, n, method, relativeTolerance, ...)

## Default S3 method:
random(
  rho = list(distribution = "norm", probabilities = c(0.05, 0.95), quantiles =
    c(-qnorm(0.95), qnorm(0.95))),
  n,
  method = "fit",
  relativeTolerance = 0.05,
  ...
)

## S3 method for class 'vector'
random(rho = runif(n = n), n, method = NULL, relativeTolerance = NULL, ...)

## S3 method for class 'data.frame'
random(
  rho = data.frame(uniform = runif(n = n)),
  n,
  method = NULL,
  relativeTolerance = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_+3A_rho">rho</code></td>
<td>
<p>Distribution to be randomly sampled.</p>
</td></tr>
<tr><td><code id="random_+3A_n">n</code></td>
<td>
<p><code>integer</code>: Number of observations to be generated</p>
</td></tr>
<tr><td><code id="random_+3A_method">method</code></td>
<td>
<p><code>character</code>: Particular method to be used for random number generation.</p>
</td></tr>
<tr><td><code id="random_+3A_relativetolerance">relativeTolerance</code></td>
<td>
<p><code>numeric</code>: the relative tolerance level of deviation of the
generated confidence interval from the specified interval. If this deviation is greater than
<code>relativeTolerance</code> a warning is given.</p>
</td></tr>
<tr><td><code id="random_+3A_...">...</code></td>
<td>
<p>Optional arguments to be passed to the particular random number
generating function.</p>
</td></tr>
</table>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>random(default)</code>: Quantiles based univariate random number generation.
</p>

<dl>
<dt><b>Arguments</b></dt><dd>
  
<dl>
<dt><code>rho</code> </dt><dd>
<p>rho <code>list</code>: Distribution to be randomly sampled. The list elements are 
<code>$distribution</code>, <code>$probabilities</code> and <code>$quantiles</code>. For details cf. below.
</p>
</dd>
<dt><code>method</code> </dt><dd>
<p><code>character</code>: Particular method to be used for random number 
generation. Currently only method <code><a href="#topic+rdistq_fit">rdistq_fit</a>{fit}</code> is implemented which is the 
default.
</p>
</dd>
<dt><code>relativeTolerance</code></dt><dd>
<p><code>numeric</code>: the relative tolerance level of deviation of the generated confidence 
interval from the specified interval. If this deviation is greater than 
<code>relativeTolerance</code> a warning is given.
</p>
</dd>
<dt><code>...</code></dt><dd>
<p>Optional arguments to be passed to the particular random number
generating function, i.e. <code><a href="#topic+rdistq_fit">rdistq_fit</a></code>.
</p>
</dd>
</dl>

</dd>
<dt><b>Details</b></dt><dd>

<p>The distribution family is determined by <code>rho[["distribution"]]</code>. For the  
possibilities cf. <code><a href="#topic+rdistq_fit">rdistq_fit</a></code>.
</p>
<p><code>rho[["probabilities"]]</code> and <code>[[rho"quantiles"]]</code> are numeric vectors of the same 
length. The first defines the probabilities of the quantiles, the second defines the quantiles 
values which determine the parametric distribution.

</p>
</dd>
<dt><b>Value</b></dt><dd>

<p>A numeric vector of length <code>n</code> containing the generated random numbers.

</p>
</dd>
<dt><b>See Also</b></dt><dd>

<p><code><a href="#topic+rdistq_fit">rdistq_fit</a></code>
</p>
 
</dd>
</dl>

</li>
<li> <p><code>random(vector)</code>: Univariate random number generation by drawing from a given 
empirical sample.
</p>

<dl>
<dt><b>Arguments</b></dt><dd>

<dl>
<dt><code>rho</code> </dt><dd>
<p><code>vector</code>: Univariate empirical sample to be sampled from.
</p>
</dd>
<dt><code>method</code> </dt><dd> 
<p>for this class no impact
</p>
</dd>
<dt><code>relativeTolerance</code></dt><dd>
<p>for this class no impact
</p>
</dd>
<dt><code>...</code></dt><dd>
<p>for this class no impact
</p>
</dd>
</dl>

</dd>
<dt><b>Value</b></dt><dd>

<p>A <code>numeric vector</code> of length <code>n</code> containing the generated random numbers.
</p>

</dd>
<dt><b>See Also</b></dt><dd>

<p><code><a href="base.html#topic+sample">sample</a></code>
</p>
 
</dd> 
</dl>

</li>
<li> <p><code>random(data.frame)</code>: Multivariate random number generation by drawing from a given empirical sample.
</p>

<dl>
<dt><b>Arguments</b></dt><dd>

<dl>
<dt><code>rho</code> </dt><dd>
<p><code>data.frame</code>: Multivariate empirical sample to be sampled from.
</p>
</dd>
<dt><code>method</code> </dt><dd> 
<p>for this class no impact
</p>
</dd>
<dt><code>relativeTolerance</code></dt><dd>
<p>for this class no impact
</p>
</dd>
<dt><code>...</code></dt><dd>
<p>for this class no impact
</p>
</dd>
</dl>

</dd>
<dt><b>Value</b></dt><dd>

<p>A <code>data.frame</code> with <code>n</code> rows containing the generated random numbers.  

</p>
</dd>
<dt><b>See Also</b></dt><dd>

<p><code><a href="base.html#topic+sample">sample</a></code>
  
</p>
</dd>
</dl>

</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'> x&lt;-random(n=10000)
 hist(x,breaks=100)
 mean(x)
 sd(x)
  
 rho&lt;-list(distribution="norm", 
           probabilities=c(0.05,0.4,0.8), 
           quantiles=c(-4, 20, 100))
 x&lt;-random(rho=rho, n=10000, tolConv=0.01)
 hist(x,breaks=100)
 quantile(x,p=rho[["probabilities"]])
</code></pre>

<hr>
<h2 id='random_state'>Draw a random state for a categorical variable</h2><span id='topic+random_state'></span>

<h3>Description</h3>

<p>This function draws a sample from a user-defined frequency distribution for a categorical
variable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_state(states, probs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_state_+3A_states">states</code></td>
<td>
<p>character vector containing state names.</p>
</td></tr>
<tr><td><code id="random_state_+3A_probs">probs</code></td>
<td>
<p>numeric vector containing probabilities for the states. If these do
not add up to 1, they are automatically normalized.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>one of the states, drawn randomly according to the specified probabilities.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
random_state(states=c("very low","low","medium","high","very high"),
  probs=c(1,1,2,1,1))

</code></pre>

<hr>
<h2 id='random.estimate'>Generate random numbers for an estimate.</h2><span id='topic+random.estimate'></span>

<h3>Description</h3>

<p>This function generates random numbers for general multivariate
distributions that are defined as an <code><a href="#topic+estimate">estimate</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'estimate'
random(rho, n, method = "calculate", relativeTolerance = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.estimate_+3A_rho">rho</code></td>
<td>
<p><code>estimate</code>: multivariate distribution to be randomly sampled.</p>
</td></tr>
<tr><td><code id="random.estimate_+3A_n">n</code></td>
<td>
<p><code>integer</code>:Number of observations to be generated.</p>
</td></tr>
<tr><td><code id="random.estimate_+3A_method">method</code></td>
<td>
<p><code>character</code>: Particular method to be used for random number generation.</p>
</td></tr>
<tr><td><code id="random.estimate_+3A_relativetolerance">relativeTolerance</code></td>
<td>
<p><code>numeric</code>: the relative tolerance level of deviation of the
generated confidence interval from the specified interval. If this deviation is greater than
<code>relativeTolerance</code> a warning is given.</p>
</td></tr>
<tr><td><code id="random.estimate_+3A_...">...</code></td>
<td>
<p>Optional arguments to be passed to the particular random number
generating function.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Generation of uncorrelated components</h4>

<p>Implementation: <code><a href="#topic+random.estimate1d">random.estimate1d</a></code>
</p>



<h4>Generation of correlated components</h4>

<p>Implementation: <code><a href="#topic+rmvnorm90ci_exact">rmvnorm90ci_exact</a></code>
</p>



<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>, <code><a href="#topic+random.estimate1d">random.estimate1d</a></code>, <code><a href="#topic+random">random</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>variable=c("revenue","costs")
distribution=c("norm","norm")
 lower=c(10000,  5000)
 upper=c(100000, 50000)
 estimateObject&lt;-as.estimate(variable, distribution, lower, upper)
 x&lt;-random(rho=estimateObject, n=10000)
 apply(X=x, MARGIN=2, FUN=quantile, probs=c(0.05, 0.95))
 cor(x)
 colnames(x)
 summary(x)
 hist(x[,"revenue"])
 hist(x[,"costs"])
 
 # Create an estimate with median and method information:
 estimateObject&lt;-estimate(         c("posnorm", "lnorm"),
                                   c(        4,       4),
                                   c(       50,      10),
                          variable=c("revenue", "costs"),
                          median = c(   "mean",      NA),
                          method = c(    "fit",      ""))
 # Sample random values for this estimate:
 x&lt;-random(rho=estimateObject, n=10000)
 # Check the results 
 apply(X=x, MARGIN=2, FUN=quantile, probs=c(0.05, 0.95))
 summary(x)
 hist(x[,"revenue"], breaks=100)
 hist(x[,"costs"], breaks=100)
 
</code></pre>

<hr>
<h2 id='random.estimate1d'>Generate univariate random numbers defined by a 1-d estimate.</h2><span id='topic+random.estimate1d'></span>

<h3>Description</h3>

<p>This function generates random numbers for univariate parametric distributions, whose  
parameters are determined by a one dimensional estimate (<code><a href="#topic+estimate1d">estimate1d</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'estimate1d'
random(rho, n, method = "calculate", relativeTolerance = 0.05, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random.estimate1d_+3A_rho">rho</code></td>
<td>
<p><code>estimate1d</code>: Univariate distribution to be randomly sampled.</p>
</td></tr>
<tr><td><code id="random.estimate1d_+3A_n">n</code></td>
<td>
<p><code>integer</code>: Number of observations to be generated</p>
</td></tr>
<tr><td><code id="random.estimate1d_+3A_method">method</code></td>
<td>
<p><code>character</code>: Particular method to be used for random number generation. It 
can be either <code>"calculate"</code> (the default) or <code>"fit"</code>. Details below.</p>
</td></tr>
<tr><td><code id="random.estimate1d_+3A_relativetolerance">relativeTolerance</code></td>
<td>
<p><code>numeric</code>: the relative tolerance level of deviation of the
generated confidence interval from the specified interval. If this deviation is greater than
<code>relativeTolerance</code> a warning is given.</p>
</td></tr>
<tr><td><code id="random.estimate1d_+3A_...">...</code></td>
<td>
<p>Optional arguments to be passed to the particular random number
generating function (cf. below).
@details
</p>

<dl>
<dt><code>rho[["distribution"]]</code>:</dt><dd>
<p>The follwing table shows the available distributions and the implemented generation method:
</p>

<table>
<tr>
 <td style="text-align: left;">
  <b><code>rho[["distribution"]]</code></b>  </td><td style="text-align: left;"><b>Distribution Name</b>                         </td><td style="text-align: left;"> <b><code>method</code></b> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>"const"</code>                </td><td style="text-align: left;"> Deterministic case                            </td><td style="text-align: left;"> not applicable</td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>"norm"</code>                 </td><td style="text-align: left;"> <a href="stats.html#topic+Normal">Normal</a>                                 </td><td style="text-align: left;"> <code><a href="#topic+rdist90ci_exact">calculate</a></code>, <code><a href="#topic+rdistq_fit">fit</a></code>  </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>"posnorm"</code>              </td><td style="text-align: left;"> <a href="#topic+rposnorm90ci">Positive normal</a>         </td><td style="text-align: left;"> <code><a href="#topic+paramtnormci_numeric">calculate</a></code>, <code><a href="#topic+paramtnormci_fit">fit</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>"tnorm_0_1"</code>            </td><td style="text-align: left;"> <a href="#topic+rtnorm_0_1_90ci">0-1-truncated normal</a> </td><td style="text-align: left;"> <code><a href="#topic+paramtnormci_numeric">calculate</a></code>, <code><a href="#topic+paramtnormci_fit">fit</a></code> </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>"beta"</code>                 </td><td style="text-align: left;"> <a href="stats.html#topic+Beta">Beta</a>                                   </td><td style="text-align: left;"> <code><a href="#topic+rdistq_fit">fit</a></code>  </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>"cauchy"</code>               </td><td style="text-align: left;"> <a href="stats.html#topic+Cauchy">Cauchy</a>                                 </td><td style="text-align: left;"> <code><a href="#topic+rdistq_fit">fit</a></code>  </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>"logis"</code>                </td><td style="text-align: left;"> <a href="stats.html#topic+Logistic">Logistic</a>                               </td><td style="text-align: left;"> <code><a href="#topic+rdistq_fit">fit</a></code>  </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>"t"</code>                    </td><td style="text-align: left;"> <a href="stats.html#topic+TDist">Student t</a>                      </td><td style="text-align: left;"> <code><a href="#topic+rdistq_fit">fit</a></code>  </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>"chisq"</code>                </td><td style="text-align: left;"> <a href="stats.html#topic+Chisquare">Central Chi-Squared</a>        </td><td style="text-align: left;"> <code><a href="#topic+rdistq_fit">fit</a></code>  </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>"chisqnc"</code>              </td><td style="text-align: left;"> <a href="stats.html#topic+Chisquare">Non-central Chi-Squared</a>    </td><td style="text-align: left;"> <code><a href="#topic+rdistq_fit">fit</a></code>  </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>"exp"</code>                  </td><td style="text-align: left;"> <a href="stats.html#topic+Exponential">Exponential</a>                            </td><td style="text-align: left;"> <code><a href="#topic+rdistq_fit">fit</a></code>  </td>
</tr>
<tr>
 <td style="text-align: left;">  
  <code>"f"</code>                    </td><td style="text-align: left;"> <a href="stats.html#topic+FDist">Central F</a>                      </td><td style="text-align: left;"> <code><a href="#topic+rdistq_fit">fit</a></code>  </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>"gamma"</code>                </td><td style="text-align: left;"> <a href="stats.html#topic+GammaDist">Gamma</a> with <code>scale=1/rate</code> </td><td style="text-align: left;"> <code><a href="#topic+rdistq_fit">fit</a></code>  </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>"lnorm"</code>                </td><td style="text-align: left;"> <a href="stats.html#topic+Lognormal">Log Normal</a>                 </td><td style="text-align: left;"> <code><a href="#topic+rdist90ci_exact">calculate</a></code>, <code><a href="#topic+rdistq_fit">fit</a></code>  </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>"unif"</code>                 </td><td style="text-align: left;"> <a href="stats.html#topic+Uniform">Uniform</a>                                </td><td style="text-align: left;"> <code><a href="#topic+rdist90ci_exact">calculate</a></code>, <code><a href="#topic+rdistq_fit">fit</a></code>  </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>"weibull"</code>              </td><td style="text-align: left;"> <a href="stats.html#topic+Weibull">Weibull</a>                                </td><td style="text-align: left;"> <code><a href="#topic+rdistq_fit">fit</a></code>  </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>"triang"</code>               </td><td style="text-align: left;"> <a href="mc2d.html#topic+triangular">Triangular</a>            </td><td style="text-align: left;"> <code><a href="#topic+rdistq_fit">fit</a></code>  </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>"gompertz"</code>             </td><td style="text-align: left;"> <a href="eha.html#topic+Gompertz">Gompertz</a>                 </td><td style="text-align: left;"> <code><a href="#topic+rdistq_fit">fit</a></code>  </td>
</tr>
<tr>
 <td style="text-align: left;">
  <code>"pert"</code>                 </td><td style="text-align: left;">  <a href="mc2d.html#topic+pert">(Modified) PERT</a>            </td><td style="text-align: left;"> <code><a href="#topic+rdistq_fit">fit</a></code>  </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>

<p>For <code>distribution="const"</code> the argument <code>method</code> is obsolete, as a constant is neither
fitted nor calculated.  
</p>
</dd>
<dt><code>rho[["method"]]</code></dt><dd>
<p>If supplied, i.e. <code>!is.null(rho[["method"]])</code>, this value overwrites the function 
argument <code>method</code>. 
</p>
</dd>
<dt><code>method</code></dt><dd>
<p>This parameter defines, how the parameters of the distribution to be sampled are derived from 
<code>rho[["lower"]]</code>, <code>rho[["upper"]]</code> and possibly <code>rho[["median"]]</code>.
Possibilities are <code>"calculate"</code> (the default) or <code>"fit"</code>:
</p>

<dl>
<dt><code>method="calculate"</code></dt><dd>
<p>The parameters are calculated if possible using the exact (analytical) formula or, otherwise,
numerically. This calculation of the distribution parameters is independent of 
<code>rho[["median"]]</code> being  supplied or not. For the implemented distributions, it only 
depends on <code>rho[["lower"]]</code> and <code>rho[["upper"]]</code>. However, if it is supplied, i.e. 
<code>is.numeric(rho[["median"]])</code>, a check is performed, if the relative deviation of the 
generated median from <code>rho[["median"]]</code> is greater than <code>relativeTolerance</code>. In 
this case a warning is given.
</p>
</dd>
<dt><code>method="fit"</code></dt><dd>
<p>The parameters are obtained by fitting the distribution on the supplied quantiles.
Given that <code>rho[["median"]]==NULL</code> the distribution is fitted only to <code>lower</code> and 
<code>upper</code> and a warning is given; due to the used numerical procedure, the calculated 
parameters might define a distribution which strongly deviates from the intended one. There is 
larger control on the shape of the distribution to be generated by supplying the estimate of the 
median. If <code>is.numeric(rho[["median"]])</code> the distribution is fitted to <code>lower</code>, 
<code>upper</code> and <code>median</code>. 
</p>
</dd>   
</dl>

</dd>
<dt><code>...</code></dt><dd>
<p>For passing further parameters to the function which generates the random numbers, cf. 
the above table and follow the link in the column <code>method</code>.
</p>
</dd>
</dl>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+estimate1d">estimate1d</a></code>; For <code>method="calculate"</code>: <code><a href="#topic+rdist90ci_exact">rdist90ci_exact</a></code>; for <code>method="fit"</code>: <code><a href="#topic+rdistq_fit">rdistq_fit</a></code>; for both
methods: <code><a href="#topic+rposnorm90ci">rposnorm90ci</a></code> and <code><a href="#topic+rtnorm_0_1_90ci">rtnorm_0_1_90ci</a></code>. For the default method: <code><a href="#topic+random">random</a></code>.
</p>

<hr>
<h2 id='rdist90ci_exact'>90%-confidence interval based univariate random number generation (by exact parameter 
calculation).</h2><span id='topic+rdist90ci_exact'></span>

<h3>Description</h3>

<p>This function generates random numbers for a set of univariate parametric distributions from  
given 90% confidence interval.  Internally, this is achieved by exact, i.e. analytic, calculation
of the parameters for the individual distribution from the given 90% confidence interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdist90ci_exact(distribution, n, lower, upper)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rdist90ci_exact_+3A_distribution">distribution</code></td>
<td>
<p><code>character</code>; A character string that defines the univariate distribution
to be randomly sampled. For possible options cf. section Details.</p>
</td></tr>
<tr><td><code id="rdist90ci_exact_+3A_n">n</code></td>
<td>
<p>Number of generated observations.</p>
</td></tr>
<tr><td><code id="rdist90ci_exact_+3A_lower">lower</code></td>
<td>
<p><code>numeric</code>; lower bound of the 90% confidence interval.</p>
</td></tr>
<tr><td><code id="rdist90ci_exact_+3A_upper">upper</code></td>
<td>
<p><code>numeric</code>; upper bound of the 90% confidence interval.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following table shows the available distributions and their identification 
(option: <code>distribution</code>) as a character string:
</p>

<table>
<tr>
 <td style="text-align: left;">
 <b><code>distribution</code></b> </td><td style="text-align: left;"> <b>Distribution Name</b>      </td><td style="text-align: left;"> <b>Requirements</b></td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>"const"</code>             </td><td style="text-align: left;"> Deterministic case            </td><td style="text-align: left;"> <code>lower == upper</code></td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>"norm"</code>              </td><td style="text-align: left;"> <a href="stats.html#topic+Normal">Normal</a>                 </td><td style="text-align: left;"> <code>lower &lt; upper</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>"lnorm"</code>             </td><td style="text-align: left;"> <a href="stats.html#topic+Lognormal">Log Normal</a> </td><td style="text-align: left;"> <code>0 &lt; lower &lt; upper</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>"unif"</code>              </td><td style="text-align: left;"> <a href="stats.html#topic+Uniform">Uniform</a>                </td><td style="text-align: left;"> <code>lower &lt; upper</code>
 </td>
</tr>

</table>



<h4>Parameter formulae</h4>

<p>We use the notation: <code class="reqn">l</code><code>=lower</code> and <code class="reqn">u</code>=<code>upper</code>; 
<code class="reqn">\Phi</code> is the cumulative distribution function of the standard normal distribution and 
<code class="reqn">\Phi^{-1}</code> its inverse, which is the quantile function of the standard normal 
distribution.
</p>

<dl>
<dt><code>distribution="norm":</code></dt><dd><p>The formulae for <code class="reqn">\mu</code> and <code class="reqn">\sigma</code>, viz. the 
mean and standard deviation, respectively, of the normal distribution are
<code class="reqn">\mu=\frac{l+u}{2}</code> and
<code class="reqn">\sigma=\frac{\mu - l}{\Phi^{-1}(0.95)}</code>.
</p>
</dd>
<dt><code>distribution="unif":</code></dt><dd><p>For the minimum <code class="reqn">a</code> and 
maximum <code class="reqn">b</code> of the uniform distribution <code class="reqn">U_{[a,b]}</code> it holds that
<code class="reqn">a = l - 0.05 (u - l)
                                             </code> and 
<code class="reqn">b= u + 0.05 (u - l)
                                             </code>.
</p>
</dd>
<dt><code>distribution="lnorm":</code></dt><dd><p>The density of the log normal distribution is 
<code class="reqn"> f(x) = \frac{1}{ \sqrt{2 \pi} \sigma x } \exp( - \frac{( \ln(x) - \mu )^2 %
            }{
            2 \sigma^2}) </code> for <code class="reqn">x &gt; 0</code> and <code class="reqn">f(x) = 0</code> otherwise.
Its parameters are determined by the confidence interval via 
<code class="reqn">\mu = \frac{\ln(l) + \ln(u)}{2}
            </code> and 
<code class="reqn">\sigma = \frac{1}{\Phi^{-1}(0.95)} ( \mu - \ln(l) )
            </code>. Note the correspondence to the formula for the normal distribution.
</p>
</dd>
</dl>




<h3>Value</h3>

<p>A numeric vector of length <code>n</code> with the sampled values according to the chosen 
distribution.
</p>
<p>In case of <code>distribution="const"</code>, viz. the deterministic case, the function returns: 
<code>rep(lower, n).</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate uniformly distributed random numbers:
lower=3
upper=6
hist(r&lt;-rdist90ci_exact(distribution="unif", n=10000, lower=lower, upper=upper),breaks=100)
print(quantile(x=r, probs=c(0.05,0.95)))
print(summary(r))

# Generate log normal distributed random numbers:
hist(r&lt;-rdist90ci_exact(distribution="lnorm", n=10000, lower=lower, upper=upper),breaks=100)
print(quantile(x=r, probs=c(0.05,0.95)))
print(summary(r))
</code></pre>

<hr>
<h2 id='rdistq_fit'>Quantiles based univariate random number generation (by parameter fitting).</h2><span id='topic+rdistq_fit'></span>

<h3>Description</h3>

<p>This function generates random numbers for a set of univariate parametric distributions from  
given quantiles. Internally, this is achieved by fitting the distribution function
to the given quantiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdistq_fit(
  distribution,
  n,
  percentiles = c(0.05, 0.5, 0.95),
  quantiles,
  relativeTolerance = 0.05,
  tolConv = 0.001,
  fit.weights = rep(1, length(percentiles)),
  verbosity = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rdistq_fit_+3A_distribution">distribution</code></td>
<td>
<p>A character string that defines the univariate distribution
to be randomly sampled.</p>
</td></tr>
<tr><td><code id="rdistq_fit_+3A_n">n</code></td>
<td>
<p>Number of generated observations.</p>
</td></tr>
<tr><td><code id="rdistq_fit_+3A_percentiles">percentiles</code></td>
<td>
<p>Numeric vector giving the percentiles.</p>
</td></tr>
<tr><td><code id="rdistq_fit_+3A_quantiles">quantiles</code></td>
<td>
<p>Numeric vector giving the quantiles.</p>
</td></tr>
<tr><td><code id="rdistq_fit_+3A_relativetolerance">relativeTolerance</code></td>
<td>
<p><code>numeric</code>; the relative tolerance level of deviation of the
generated individual percentiles from the specified percentiles. If any deviation is greater 
than <code>relativeTolerance</code> a warning is given.</p>
</td></tr>
<tr><td><code id="rdistq_fit_+3A_tolconv">tolConv</code></td>
<td>
<p>positive numerical value, the absolute convergence tolerance for reaching zero by fitting distributions
<code>get.norm.par</code> will be shown.</p>
</td></tr>
<tr><td><code id="rdistq_fit_+3A_fit.weights">fit.weights</code></td>
<td>
<p>numerical vector of the same length as a probabilities vector 
<code>p</code> containing positive values for weighting quantiles. By default all
quantiles will be weighted by 1.</p>
</td></tr>
<tr><td><code id="rdistq_fit_+3A_verbosity">verbosity</code></td>
<td>
<p><code>integer</code>; if <code>0</code> the function is silent; the larger the value the
more verbose is the output information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following table shows the available distributions and their identification 
(option: <code>distribution</code>) as a character string:
</p>

<table>
<tr>
 <td style="text-align: left;">
 <b><code>distribution</code></b>  </td><td style="text-align: left;">  <b>Distribution Name</b>                 </td><td style="text-align: left;"> <b><code>length(quantiles)</code></b> </td><td style="text-align: left;"> <b>Necessary Package</b></td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>"norm"</code>       </td><td style="text-align: left;">  <a href="stats.html#topic+Normal">Normal</a>                                    </td><td style="text-align: left;"> &gt;=2    </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>"beta"</code>       </td><td style="text-align: left;">  <a href="stats.html#topic+Beta">Beta</a>                                      </td><td style="text-align: left;"> &gt;=2    </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">  
 <code>"cauchy"</code>     </td><td style="text-align: left;">  <a href="stats.html#topic+Cauchy">Cauchy</a>                                    </td><td style="text-align: left;"> &gt;=2    </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>"logis"</code>      </td><td style="text-align: left;">  <a href="stats.html#topic+Logistic">Logistic</a>                                  </td><td style="text-align: left;"> &gt;=2    </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;"> 
 <code>"t"</code>          </td><td style="text-align: left;">  <a href="stats.html#topic+TDist">Student t</a>                         </td><td style="text-align: left;"> &gt;=1    </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;"> 
 <code>"chisq"</code>      </td><td style="text-align: left;">  <a href="stats.html#topic+Chisquare">Central Chi-Squared</a>           </td><td style="text-align: left;"> &gt;=1    </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;"> 
 <code>"chisqnc"</code>    </td><td style="text-align: left;">  <a href="stats.html#topic+Chisquare">Non-central Chi-Squared</a>       </td><td style="text-align: left;"> &gt;=2    </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;"> 
 <code>"exp"</code>        </td><td style="text-align: left;">  <a href="stats.html#topic+Exponential">Exponential</a>                               </td><td style="text-align: left;"> &gt;=1    </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">    
 <code>"f"</code>          </td><td style="text-align: left;">  <a href="stats.html#topic+FDist">Central F</a>                         </td><td style="text-align: left;"> &gt;=2    </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;"> 
 <code>"gamma"</code>      </td><td style="text-align: left;">  <a href="stats.html#topic+GammaDist">Gamma</a> with <code>scale=1/rate</code></td><td style="text-align: left;"> &gt;=2    </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>"lnorm"</code>      </td><td style="text-align: left;">  <a href="stats.html#topic+Lognormal">Log Normal</a>                    </td><td style="text-align: left;"> &gt;=2    </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>"unif"</code>       </td><td style="text-align: left;">  <a href="stats.html#topic+Uniform">Uniform</a>                                   </td><td style="text-align: left;"> ==2    </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>"weibull"</code>    </td><td style="text-align: left;">  <a href="stats.html#topic+Weibull">Weibull</a>                                   </td><td style="text-align: left;"> &gt;=2    </td><td style="text-align: left;"> </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>"triang"</code>     </td><td style="text-align: left;">  <a href="mc2d.html#topic+triangular">Triangular</a>               </td><td style="text-align: left;"> &gt;=3    </td><td style="text-align: left;"> <span class="pkg"><code>mc2d</code></span></td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>"gompertz"</code>   </td><td style="text-align: left;">  <a href="eha.html#topic+Gompertz">Gompertz</a>                    </td><td style="text-align: left;"> &gt;=2    </td><td style="text-align: left;"> <span class="pkg"><code>eha</code></span> </td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>"pert"</code>       </td><td style="text-align: left;">  <a href="mc2d.html#topic+pert">(Modified) PERT</a>                </td><td style="text-align: left;"> &gt;=4    </td><td style="text-align: left;"> <span class="pkg"><code>mc2d</code></span></td>
</tr>
<tr>
 <td style="text-align: left;">
 <code>"tnorm"</code>      </td><td style="text-align: left;">  <a href="msm.html#topic+tnorm">Truncated Normal</a>               </td><td style="text-align: left;"> &gt;=4    </td><td style="text-align: left;"> <span class="pkg"><code>msm</code></span>
 </td>
</tr>

</table>

<p><code>percentiles</code> and <code>quantiles</code> must be of the same length. <code>percentiles</code> must be 
<code>&gt;=0</code> and <code>&lt;=1</code>.
</p>
<p>The default for <code>percentiles</code> is 0.05, 0.5 and 0.95, so for the default, 
the quantiles argument should be a vector with 3 elements. If this is to be longer,
the percentiles argument has to be adjusted to match the length of quantiles.
</p>
<p>The fitting of the distribution parameters is done using 
<code><a href="rriskDistributions.html#topic+rriskFitdist.perc">rriskFitdist.perc</a></code>.
</p>


<h3>Value</h3>

<p>A numeric vector of length <code>n</code> with the sampled values according to the chosen 
distribution.
</p>


<h3>See Also</h3>

<p><code><a href="rriskDistributions.html#topic+rriskFitdist.perc">rriskFitdist.perc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Fit a log normal distribution to 3 quantiles:
if ( requireNamespace("rriskDistributions", quietly = TRUE) ){
  percentiles&lt;-c(0.05, 0.5, 0.95)
  quantiles=c(1,3,15)
  hist(r&lt;-rdistq_fit(distribution="lnorm", n=10000, quantiles=quantiles),breaks=100)
  print(quantile(x=r, probs=percentiles))
}
</code></pre>

<hr>
<h2 id='rmvnorm90ci_exact'>90%-confidence interval multivariate normal random number generation.</h2><span id='topic+rmvnorm90ci_exact'></span>

<h3>Description</h3>

<p>This function generates normally distributed multivariate random numbers which parameters are 
determined by the 90%-confidence interval. The calculation of <code>mean</code> and <code>sd</code> is 
exact.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmvnorm90ci_exact(n, lower, upper, correlationMatrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmvnorm90ci_exact_+3A_n">n</code></td>
<td>
<p><code>integer</code>: Number of observations to be generated.</p>
</td></tr>
<tr><td><code id="rmvnorm90ci_exact_+3A_lower">lower</code></td>
<td>
<p><code>numeric vector</code>: lower bound of the 90% confidence interval.</p>
</td></tr>
<tr><td><code id="rmvnorm90ci_exact_+3A_upper">upper</code></td>
<td>
<p><code>numeric vector</code>: upper bound of the 90% confidence interval.</p>
</td></tr>
<tr><td><code id="rmvnorm90ci_exact_+3A_correlationmatrix">correlationMatrix</code></td>
<td>
<p><code>numeric matrix</code>: symmetric matrix which is the correlation matrix of the 
multivariate normal distribution. In particular, all diagonal elements must be equal to 1.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+random">random</a></code>, <code><a href="mvtnorm.html#topic+Mvnorm">Mvnorm</a></code>
</p>

<hr>
<h2 id='row.names.estimate'>Get and set attributes of an <code>estimate</code> object.</h2><span id='topic+row.names.estimate'></span><span id='topic+names.estimate'></span><span id='topic+corMat.estimate'></span><span id='topic+corMat+3C-.estimate'></span>

<h3>Description</h3>

<p><code>row.names.estimate</code> returns the variable names of an <code><a href="#topic+estimate">estimate</a></code> object which 
is identical to <code>row.names(x$marginal)</code>.
</p>
<p><code>names.estimate</code> returns the column names of an <code><a href="#topic+estimate">estimate</a></code> object which is identical to
<code>names(x$marginal)</code>.
</p>
<p><code>corMat.estimate</code> returns the full correlation matrix of an <code><a href="#topic+estimate">estimate</a></code> object.
</p>
<p><code>'corMat&lt;-.estimate'</code> replaces the correlation matrix of an <code><a href="#topic+estimate">estimate</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'estimate'
row.names(x)

## S3 method for class 'estimate'
names(x)

## S3 method for class 'estimate'
corMat(rho)

## S3 replacement method for class 'estimate'
corMat(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="row.names.estimate_+3A_x">x</code></td>
<td>
<p>an <code><a href="#topic+estimate">estimate</a></code> object.</p>
</td></tr>
<tr><td><code id="row.names.estimate_+3A_rho">rho</code></td>
<td>
<p>an <code><a href="#topic+estimate">estimate</a></code> object.</p>
</td></tr>
<tr><td><code id="row.names.estimate_+3A_value">value</code></td>
<td>
<p><code>numeric matrix</code>: new correlation matrix. For details cf. 
<code><a href="#topic+estimate">estimate</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+estimate">estimate</a></code>, <code><a href="#topic+names.estimate">names.estimate</a></code>, <code><a href="#topic+corMat.estimate">corMat.estimate</a></code>, 
<code><a href="#topic+corMat">corMat</a></code>
</p>
<p><code><a href="#topic+corMat+3C-">corMat&lt;-</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # Read the joint estimate information for the variables "sales", "productprice" and 
 # "costprice" from file:
 ## Get the path to the file with the marginal information:
 marginalFilePath=system.file("extdata","profit-4.csv",package="decisionSupport")
 ## Read marginal and correlation file into an estimate:
 parameterEstimate&lt;-estimate_read_csv(fileName=marginalFilePath)
 print(parameterEstimate)
 ## Print the names of the variables of this estimate
 print(row.names(parameterEstimate))
 ## Print the names of the columns of this estimate
  print(names(parameterEstimate))
 ## Print the full correlation matrix of this estimate
  print(corMat(parameterEstimate))
</code></pre>

<hr>
<h2 id='rtnorm90ci'>90%-confidence interval based truncated normal random number generation.</h2><span id='topic+rtnorm90ci'></span><span id='topic+rposnorm90ci'></span><span id='topic+rtnorm_0_1_90ci'></span>

<h3>Description</h3>

<p><code>rtnorm90ci</code> generates truncated normal random numbers based on the 90% confidence interval
calculating the distribution parameter numerically from the  90%-confidence interval or via a 
fit on the 90%-confidence interval. The fit might include the median or not.
</p>
<p><code>rposnorm90ci</code> generates positive normal random numbers based on the 90% confidence interval. 
It is a wrapper function for <code>rtnorm90ci</code>.
</p>
<p><code>rtnorm_0_1_90ci</code> generates normal random numbers truncated to <code class="reqn">[0,1]</code> based on the 
90% confidence interval. It is a wrapper function for <code>rtnorm90ci</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rtnorm90ci(
  n,
  ci,
  median = mean(ci),
  lowerTrunc = -Inf,
  upperTrunc = Inf,
  method = "numeric",
  relativeTolerance = 0.05,
  ...
)

rposnorm90ci(
  n,
  lower,
  median = mean(c(lower, upper)),
  upper,
  method = "numeric",
  relativeTolerance = 0.05,
  ...
)

rtnorm_0_1_90ci(
  n,
  lower,
  median = mean(c(lower, upper)),
  upper,
  method = "numeric",
  relativeTolerance = 0.05,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rtnorm90ci_+3A_n">n</code></td>
<td>
<p>Number of generated observations.</p>
</td></tr>
<tr><td><code id="rtnorm90ci_+3A_ci">ci</code></td>
<td>
<p><code>numeric</code> 2-dimensional vector; lower, i.e <code>ci[[1]]</code>, and upper bound, i.e
<code>ci[[2]]</code>, of the  90%-confidence interval.</p>
</td></tr>
<tr><td><code id="rtnorm90ci_+3A_median">median</code></td>
<td>
<p>if <code>NULL</code>: truncated normal is fitted only to lower and upper value of the 
confidence interval; if <code>numeric</code>: truncated normal is fitted on the confidence interval 
and the median simultaneously. For details cf. below. This option is only relevant if 
<code>method="fit"</code>.</p>
</td></tr>
<tr><td><code id="rtnorm90ci_+3A_lowertrunc">lowerTrunc</code></td>
<td>
<p><code>numeric</code>; lower truncation point of the distribution (&gt;= <code>-Inf</code>).</p>
</td></tr>
<tr><td><code id="rtnorm90ci_+3A_uppertrunc">upperTrunc</code></td>
<td>
<p><code>numeric</code>; upper truncation point of the distribution (&lt;= <code>Inf</code>).</p>
</td></tr>
<tr><td><code id="rtnorm90ci_+3A_method">method</code></td>
<td>
<p>method used to determine the parameters of the truncated normal; possible methods 
are <code>"numeric"</code> (the default) and <code>"fit"</code>.</p>
</td></tr>
<tr><td><code id="rtnorm90ci_+3A_relativetolerance">relativeTolerance</code></td>
<td>
<p><code>numeric</code>; the relative tolerance level of deviation of the
generated confidence interval from the specified interval. If this deviation is greater than
<code>relativeTolerance</code> a warning is given.</p>
</td></tr>
<tr><td><code id="rtnorm90ci_+3A_...">...</code></td>
<td>
<p>further parameters to be passed to <code><a href="#topic+paramtnormci_numeric">paramtnormci_numeric</a></code> or 
<code><a href="#topic+paramtnormci_fit">paramtnormci_fit</a></code>, respectively.</p>
</td></tr>
<tr><td><code id="rtnorm90ci_+3A_lower">lower</code></td>
<td>
<p><code>numeric</code>; lower bound of the 90% confidence interval.</p>
</td></tr>
<tr><td><code id="rtnorm90ci_+3A_upper">upper</code></td>
<td>
<p><code>numeric</code>; upper bound of the 90% confidence interval.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>method="numeric"</code> is implemented by <code><a href="#topic+paramtnormci_numeric">paramtnormci_numeric</a></code> and 
<code>method="fit"</code> by <code><a href="#topic+paramtnormci_fit">paramtnormci_fit</a></code>.
</p>
<p>Positive normal random number generation: a positive normal distribution
is a truncated normal distribution with lower truncation point equal to zero and upper truncation
is infinity. <code>rposnorm90ci</code> implements this as a wrapper function for  
<code>rtnorm90ci(n, c(lower,upper), median, lowerTrunc=0, upperTrunc=Inf, method, relativeTolerance,...)</code>.
</p>
<p>0-1-(truncated) normal random number generation: a 0-1-normal distribution
is a truncated normal distribution with lower truncation point equal to zero and upper truncation
equal to 1. <code>rtnorm_0_1_90ci</code> implements this as a wrapper function for  
<code>rtnorm90ci(n, c(lower,upper), median, lowerTrunc=0, upperTrunc=1, method, relativeTolerance,...)</code>.
</p>


<h3>See Also</h3>

<p>For the implementation of <code>method="numeric"</code>: <code><a href="#topic+paramtnormci_numeric">paramtnormci_numeric</a></code>; 
for the implementation of <code>method="fit"</code>: <code><a href="#topic+paramtnormci_fit">paramtnormci_fit</a></code>.
</p>

<hr>
<h2 id='sample_CPT'>Sample a Conditional Probability Table</h2><span id='topic+sample_CPT'></span>

<h3>Description</h3>

<p>This function randomly chooses a state of a categorical variable, based on a Conditional
Probability Table (CPT; a component of Bayesian Network models) that expresses the probability
of each possible state in relation to the states of other categorical variables. Given
information on the state of all parent variables, the function uses the appropriate
probability distribution to draw a random sample for the state of the variable of interest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_CPT(CPT, states)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_CPT_+3A_cpt">CPT</code></td>
<td>
<p>list of two data.frames: 1) Conditional Probability Table (CPT); 2) legend table
specifying which states of the parent nodes belong to which column in the CPT. This can
be generated with the make_CPT function, or specified manually (which can be cumbersome).</p>
</td></tr>
<tr><td><code id="sample_CPT_+3A_states">states</code></td>
<td>
<p>character vector containing (in the right sequence) state values for all
parent variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>one of the states of the child node belonging to the CPT.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
test_CPT&lt;-make_CPT(parent_effects=list(c(-1,3),c(-4,2),c(-2,3,4),c(1,2,3)),
                  parent_weights=c(1,1,1,1),b=2,child_prior=c(1,2,3,4,5),
                  child_states=c("a","b","c","d","e"),
                  parent_states=list(c("low","high"),c("A","B"),c(1,2,3),
                  c("Left","Right","Center")))

sample_CPT(CPT=test_CPT,states=c("low","A","2","Left"))

</code></pre>

<hr>
<h2 id='sample_simple_CPT'>Make Conditional Probability tables using the likelihood method</h2><span id='topic+sample_simple_CPT'></span>

<h3>Description</h3>

<p>This function creates Conditional Probability Tables for
Bayesian Network nodes from parameters that (for complex nodes) can
be more easily elicited from experts than the full table. The function
uses the Likelihood method. The function combines the make_CPT and sample_CPT
functions, but only offers limited flexibility. Refer to the make_CPR and
sample_CPT descriptions for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sample_simple_CPT(
  parent_list,
  child_states_n,
  child_prior = NULL,
  b = 2,
  obs_states = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sample_simple_CPT_+3A_parent_list">parent_list</code></td>
<td>
<p>named list of parameters for the parent nodes containing a
name and a vector of two elements: c(number_of_states,parent_weight).</p>
</td></tr>
<tr><td><code id="sample_simple_CPT_+3A_child_states_n">child_states_n</code></td>
<td>
<p>number of states for the child node.</p>
</td></tr>
<tr><td><code id="sample_simple_CPT_+3A_child_prior">child_prior</code></td>
<td>
<p>prior distribution for the states of the child node.</p>
</td></tr>
<tr><td><code id="sample_simple_CPT_+3A_b">b</code></td>
<td>
<p>parameter for the strength of the parent's influence on
the child node. A value of 1 causes no response; 3 is quite strong. Defaults to 2.</p>
</td></tr>
<tr><td><code id="sample_simple_CPT_+3A_obs_states">obs_states</code></td>
<td>
<p>optional vector of observed states for all parents. This has to
be complete and names have to correspond exactly with the names of states of the parent
nodes. It's also important that the name are given in the exact same sequence as the
parents are listed in parent_list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of two data.frames: 1) Conditional Probability Table (CPT); 2) legend table
specifying which states of the parent nodes belong to which column in the CPT. If obs_states
are given, an additional attribute $sampled specified one random draw, according to the
CPT and the obs_states provided.
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
parent_list&lt;-list(pare1=c(5,3),parent2=c(3,2),PARE3=c(4,5))
sample_simple_CPT(parent_list,5)
sample_simple_CPT(parent_list,5,obs_states=c("very high","medium","high"))

sample_simple_CPT(parent_list=list(management_intensity=c(5,2),inputs=c(5,1)),5,
     obs_states=c("medium","very high"))$sampled

</code></pre>

<hr>
<h2 id='scenario_mc'>Perform a Monte Carlo simulation for predefined scenarios.</h2><span id='topic+scenario_mc'></span>

<h3>Description</h3>

<p>This function is a wrapper around the <code><a href="#topic+decisionSupport">mc_Simulation</a></code> function that facilitates
implementation of scenarios. The standard <code><a href="#topic+decisionSupport">mc_Simulation</a></code> function only allows
specifying one set of estimates (i.e. distribution, lower and upper bounds) for each random
variable. This is inconvenient when we want to run simulations for heterogeneous populations
that include subsets with particular characteristics, e.g. small and large farms. It may
then make sense to specify separate distributions for input variables for each of the subsets.
The <code>scenario_mc</code> function facilitates this.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scenario_mc(
  base_estimate,
  scenarios,
  model_function,
  ...,
  numberOfModelRuns = NA,
  randomMethod = "calculate",
  functionSyntax = "data.frameNames",
  relativeTolerance = 0.05,
  verbosity = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scenario_mc_+3A_base_estimate">base_estimate</code></td>
<td>
<p><code>estimate</code>: this object corresponds to the <code>estimate</code> object
in <code><a href="#topic+decisionSupport">mc_Simulation</a></code>. The distributions that are specified through <code>base_estimate</code>
are used as default distributions in the simulation, but their parameters can be overridden by
information in the <code>scenarios</code> data.frame. In brief, this is an estimate of the joint probability distribution of
the input variables. This can be read from a csv file and calculated with the
<code><a href="#topic+decisionSupport">estimate_read_csv</a></code> function. It can also be generated with the 
<code><a href="#topic+decisionSupport">as.estimate</a></code> function.</p>
</td></tr>
<tr><td><code id="scenario_mc_+3A_scenarios">scenarios</code></td>
<td>
<p><code>data.frame</code>: Specifies values that should be adjusted in each scenario.
Must contain columns <code>Variable</code> and <code>param</code> and one column for each scenario. The
<code>Variable</code> column can only contain variable names that appear in <code>base_estimate</code>, as well 
as a <code>Runs</code> element. The <code>param</code> column can only contain the strings <code>distribution</code>,
<code>lower</code> and <code>upper</code>, except for the row corresponding to <code>Runs</code> in the <code>Variable</code>
column (for this the entry doesn't matter). For each scenario column (whose name is the scenario
name), the scenario-specific values must be specified. If the value in the <code>Runs</code> row is NA,
the <code>numberOfModelRuns</code> object will be used instead (if that's also NA, you get an error). <code>param</code>
can also be &quot;both&quot;, in which case both lower and upper bounds are set to the respective number, and
the distribution is set to &quot;const&quot;.</p>
</td></tr>
<tr><td><code id="scenario_mc_+3A_model_function">model_function</code></td>
<td>
<p><code>function</code>: The function that transforms the input distribution. It 
has to return a single <code>numeric</code> value or a <code>list</code> with named <code>numeric</code> values.</p>
</td></tr>
<tr><td><code id="scenario_mc_+3A_...">...</code></td>
<td>
<p>Optional arguments of <code>model_function</code>.</p>
</td></tr>
<tr><td><code id="scenario_mc_+3A_numberofmodelruns">numberOfModelRuns</code></td>
<td>
<p>The number of times to run the model function. This doesn't need to be
provided when the <code>scenarios</code> data.frame contains a <code>Runs</code> line that specifies a
particular number of runs for each scenario.</p>
</td></tr>
<tr><td><code id="scenario_mc_+3A_randommethod">randomMethod</code></td>
<td>
<p><code>character</code>: The method to be used to sample the distribution
representing the input estimate. For details see option <code>method</code> in 
<code><a href="#topic+random.estimate">random.estimate</a></code>.</p>
</td></tr>
<tr><td><code id="scenario_mc_+3A_functionsyntax">functionSyntax</code></td>
<td>
<p><code>character</code>: The syntax which has to be used to implement the model
function. Possible values are <code>"data.frameNames"</code>,
<code>"matrixNames"</code> or <code>"plainNames"</code>. Details are given below.</p>
</td></tr>
<tr><td><code id="scenario_mc_+3A_relativetolerance">relativeTolerance</code></td>
<td>
<p><code>numeric</code>: the relative tolerance level of deviation of the
generated confidence interval from the specified interval. If this deviation is greater than
<code>relativeTolerance</code> a warning is given.</p>
</td></tr>
<tr><td><code id="scenario_mc_+3A_verbosity">verbosity</code></td>
<td>
<p><code>integer</code>: if <code>0</code> the function is silent; the larger the value the
more verbose is output information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See documentation of the <code><a href="#topic+decisionSupport">mc_Simulation</a></code> function.
</p>


<h3>Value</h3>

<p>An object of <code>class mcSimulation</code>, which is a <code>list</code> with elements:
</p>

<dl>
<dt><code>$x</code></dt><dd>
<p><code>data.frame</code> containing the sampled <code class="reqn">x -</code> (input) values which are generated 
from <code>base_estimate</code> and possibly modified by <code>scenarios</code>. To identify the scenario, the scenario name is provided in the
<code>scenario</code> column.
</p>
</dd>
<dt><code>$y</code></dt><dd>
<p><code>data.frame</code> containing the simulated <code class="reqn">y -</code> (output) values, i.e. the model 
function values for <code>x</code>.The return of the decision model function may include the
assignment of names for the output variables, e.g. like this:
</p>
<pre>
           profit &lt;- function(x){
            revenue - costs
            return(list(Revenue = revenue,
                   Costs = cost))
         }
       </pre>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+mcSimulation">mcSimulation</a></code>, <code><a href="#topic+print.mcSimulation">print.mcSimulation</a></code>, <code><a href="#topic+summary.mcSimulation">summary.mcSimulation</a></code>, <code><a href="#topic+hist.mcSimulation">hist.mcSimulation</a></code>, <code><a href="#topic+estimate">estimate</a></code>, <code><a href="#topic+random.estimate">random.estimate</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
 ### define a model_function
 
 profit&lt;-function(x)
 {profit&lt;-benefit_1+benefit_2-cost_1-cost_2
   return(Profit=profit)}
   
 ### define a base_estimate, to be used when no other information is provided
 # through the scenario data.frame
   
 base_estimate&lt;-as.estimate(variable=c("cost_1","cost_2","benefit_1","benefit_2"),
                              distribution=c("norm","posnorm","norm","posnorm"),
                              lower=c(40,10,50,30),
                              upper=c(100,200,300,100))
            
 ### define a scenario data.frame, which will override values in the base_estimate
                                     
 scenarios&lt;-data.frame(Variable=c("Runs","cost_1","cost_1","cost_1","cost_2","cost_2",
                                  "benefit_1","benefit_1","benefit_2"),
                       param=c("x","lower","upper","distribution","lower","upper",
                               "lower","upper","lower"),
                       Scenario_1=c(100,40,70,"posnorm",30,90,20,35,10),
                       Scenario_2=c(50,100,200,"norm",10,40,35,75,5),
                       Scenario_3=c(10,400,750,"norm",400,600,30,70,60))
                       
 ### run a simulation
              
 results&lt;-scenario_mc(base_estimate, scenarios, model_function=profit,
                      functionSyntax="plainNames")
                      
 ### plot and inspect results
 
 hist(results)
 summary(results)
 print(results)
 
 
 
</code></pre>

<hr>
<h2 id='sort.summary.eviSimulation'>Sort Summarized EVI Simulation Results..</h2><span id='topic+sort.summary.eviSimulation'></span>

<h3>Description</h3>

<p>Sort summarized EVI simulation results according to their EVI.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.eviSimulation'
sort(x, decreasing = TRUE, ..., along = row.names(x$summary$evi)[[1]])
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort.summary.eviSimulation_+3A_x">x</code></td>
<td>
<p>An object of class <code>summary.eviSimulation</code>.</p>
</td></tr>
<tr><td><code id="sort.summary.eviSimulation_+3A_decreasing">decreasing</code></td>
<td>
<p><code>logical</code>: if the EVI should be sorted in decreasing order.</p>
</td></tr>
<tr><td><code id="sort.summary.eviSimulation_+3A_...">...</code></td>
<td>
<p>currently not used</p>
</td></tr>
<tr><td><code id="sort.summary.eviSimulation_+3A_along">along</code></td>
<td>
<p><code>character</code>: the name of the valuation variable along which the EVI 
should be sorted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>summary.eviSimulation</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eviSimulation">eviSimulation</a></code>, <code><a href="#topic+summary.eviSimulation">summary.eviSimulation</a></code>, <code><a href="base.html#topic+sort">base::sort</a></code>
</p>

<hr>
<h2 id='summary.eviSimulation'>Summarize EVI Simulation Results</h2><span id='topic+summary.eviSimulation'></span>

<h3>Description</h3>

<p>Produces result summaries of an Expected Value of Information (EVI) simulation obtained by 
the function <code><a href="#topic+eviSimulation">eviSimulation</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'eviSimulation'
summary(object, ..., digits = max(3, getOption("digits") - 3))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.eviSimulation_+3A_object">object</code></td>
<td>
<p>An object of class <code>eviSimulation</code>.</p>
</td></tr>
<tr><td><code id="summary.eviSimulation_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+summary.welfareDecisionAnalysis">summary.welfareDecisionAnalysis</a></code>.</p>
</td></tr>
<tr><td><code id="summary.eviSimulation_+3A_digits">digits</code></td>
<td>
<p>how many significant digits are to be used for numeric and complex x.
The default, NULL, uses <code>getOption("digits")</code>. This is a suggestion: enough decimal places
will be used so that the smallest (in magnitude) number has this many significant digits,
and also to satisfy nsmall. (For the interpretation for complex numbers see <code><a href="base.html#topic+Round">signif</a></code>.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>summary.eviSimulation</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eviSimulation">eviSimulation</a></code>, <code><a href="#topic+print.summary.eviSimulation">print.summary.eviSimulation</a></code>, 
<code><a href="#topic+summary.welfareDecisionAnalysis">summary.welfareDecisionAnalysis</a></code>,  
<code><a href="#topic+sort.summary.eviSimulation">sort.summary.eviSimulation</a></code>
</p>

<hr>
<h2 id='summary.mcSimulation'>Summarize results from Monte Carlo simulation.</h2><span id='topic+summary.mcSimulation'></span>

<h3>Description</h3>

<p>A summary of the results of a Monte Carlo simulation obtained by the function 
<code><a href="#topic+mcSimulation">mcSimulation</a></code> is produced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mcSimulation'
summary(
  object,
  ...,
  digits = max(3, getOption("digits") - 3),
  variables.y = names(object$y),
  variables.x = if (classicView) names(object$x),
  classicView = FALSE,
  probs = c(0, 0.05, 0.1, 0.25, 0.5, 0.75, 0.9, 0.95, 1)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mcSimulation_+3A_object">object</code></td>
<td>
<p>An object of class <code>mcSimulation</code>.</p>
</td></tr>
<tr><td><code id="summary.mcSimulation_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="base.html#topic+summary.data.frame">summary.data.frame</a></code> (<code>classicView=TRUE</code>)
or <code><a href="base.html#topic+format">format</a></code> (<code>classicView=FALSE</code>).</p>
</td></tr>
<tr><td><code id="summary.mcSimulation_+3A_digits">digits</code></td>
<td>
<p>how many significant digits are to be used for numeric and complex x.
The default, NULL, uses <code>getOption("digits")</code>. This is a suggestion: enough decimal places
will be used so that the smallest (in magnitude) number has this many significant digits,
and also to satisfy nsmall. (For the interpretation for complex numbers see <code><a href="base.html#topic+Round">signif</a></code>.)</p>
</td></tr>
<tr><td><code id="summary.mcSimulation_+3A_variables.y">variables.y</code></td>
<td>
<p><code>character</code> or <code>character vector</code>: Names of the components of the
simulation function (<code>model_function</code>), whose results shall be displayed. Defaults to all
components.</p>
</td></tr>
<tr><td><code id="summary.mcSimulation_+3A_variables.x">variables.x</code></td>
<td>
<p><code>character</code> or <code>character vector</code>: Names of the components of the
input variables to the simulation function, i.e. the names of the variables in the input
<code>estimate</code>, whose random sampling results shall be displayed. Defaults to all components.</p>
</td></tr>
<tr><td><code id="summary.mcSimulation_+3A_classicview">classicView</code></td>
<td>
<p><code>logical</code>: if <code>TRUE</code> the results are summarized using
<code><a href="base.html#topic+summary.data.frame">summary.data.frame</a></code>, if <code>FALSE</code> further output is produced and the quantile
information can be chosen. Cf. section Value and argument <code>probs</code>. Default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="summary.mcSimulation_+3A_probs">probs</code></td>
<td>
<p><code>numeric vector</code>: quantiles that shall be displayed if 
<code>classicView=FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>summary.mcSimulation</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcSimulation">mcSimulation</a></code>, <code><a href="#topic+print.summary.mcSimulation">print.summary.mcSimulation</a></code>, <code><a href="base.html#topic+summary.data.frame">summary.data.frame</a></code>
</p>

<hr>
<h2 id='summary.welfareDecisionAnalysis'>Summarize Welfare Decision Analysis results.</h2><span id='topic+summary.welfareDecisionAnalysis'></span>

<h3>Description</h3>

<p>Produce a summary of the results of a welfare decision analysis obtained by the function
 <code><a href="#topic+welfareDecisionAnalysis">welfareDecisionAnalysis</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'welfareDecisionAnalysis'
summary(
  object,
  ...,
  digits = max(3, getOption("digits") - 3),
  probs = c(0.05, 0.5, 0.95)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.welfareDecisionAnalysis_+3A_object">object</code></td>
<td>
<p>An object of class <code>welfareDecisionAnalysis</code>.</p>
</td></tr>
<tr><td><code id="summary.welfareDecisionAnalysis_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="base.html#topic+format">format</a></code>.</p>
</td></tr>
<tr><td><code id="summary.welfareDecisionAnalysis_+3A_digits">digits</code></td>
<td>
<p>how many significant digits are to be used for numeric and complex x.
The default, NULL, uses <code>getOption("digits")</code>. This is a suggestion: enough decimal places
will be used so that the smallest (in magnitude) number has this many significant digits,
and also to satisfy nsmall. (For the interpretation for complex numbers see <code><a href="base.html#topic+Round">signif</a></code>.)</p>
</td></tr>
<tr><td><code id="summary.welfareDecisionAnalysis_+3A_probs">probs</code></td>
<td>
<p><code>numeric vector</code>: quantiles that shall be displayed; if <code>=NULL</code> no 
quantiles will be displayed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>summary.welfareDecisionAnalysis</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+welfareDecisionAnalysis">welfareDecisionAnalysis</a></code>, 
<code><a href="#topic+print.summary.welfareDecisionAnalysis">print.summary.welfareDecisionAnalysis</a></code>, <code><a href="base.html#topic+format">format</a></code>
</p>

<hr>
<h2 id='temp_situations'>Situation occurrence and resolution</h2><span id='topic+temp_situations'></span>

<h3>Description</h3>

<p>This function simulates a situation, e.g. a conflict, that arises with a certain probability,
generates an impact as long as it persists, and has a certain chance of being resolved.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>temp_situations(
  n,
  p_occurrence,
  p_resolution,
  normal_outcome = 1,
  situation_outcome = 0,
  var_CV_normal = 0,
  var_CV_situation = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="temp_situations_+3A_n">n</code></td>
<td>
<p>integer; number of values to produce</p>
</td></tr>
<tr><td><code id="temp_situations_+3A_p_occurrence">p_occurrence</code></td>
<td>
<p>chance that a situation (e.g. conflict) occurs (probability btw. 0 and 1)</p>
</td></tr>
<tr><td><code id="temp_situations_+3A_p_resolution">p_resolution</code></td>
<td>
<p>chance that the situation disappears
(e.g. the conflict gets resolved) (probability btw. 0 and 1)</p>
</td></tr>
<tr><td><code id="temp_situations_+3A_normal_outcome">normal_outcome</code></td>
<td>
<p>output value for vector elements that aren't affected by the 
situation (can be subject to random variation, if var_CV_normal is specified).
Defaults to 1.</p>
</td></tr>
<tr><td><code id="temp_situations_+3A_situation_outcome">situation_outcome</code></td>
<td>
<p>output value for vector elements that are affected by the 
situation (can be subject to random variation, if var_CV_situation is specified).
Defaults to 0.</p>
</td></tr>
<tr><td><code id="temp_situations_+3A_var_cv_normal">var_CV_normal</code></td>
<td>
<p>desired coefficient of variation for 'normal' vector elements (in percent).
Defaults to 0.</p>
</td></tr>
<tr><td><code id="temp_situations_+3A_var_cv_situation">var_CV_situation</code></td>
<td>
<p>desired coefficient of variation for elements of the vector
that are affected by the situation (in percent). Defaults to 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of n numeric values, representing a variable time series, which simulates
the effects of a situation that arises with a probability p_occurrence and disappears again
with a probability p_resolution
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
temp_situations(n=30,p_occurrence=0.2,p_resolution=0.5)

temp_situations(n=30,p_occurrence=0.2,p_resolution=0.5,
normal_outcome=10,situation_outcome=100,var_CV_normal=10,
var_CV_situation=40)

</code></pre>

<hr>
<h2 id='vv'>value varier function</h2><span id='topic+vv'></span>

<h3>Description</h3>

<p>Many variables vary over time and it may not be desirable to ignore this
variation in time series analyses. This function produces time series that
contain variation from a specified mean and a desired coefficient of
variation. A trend can be added to this time series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vv(
  var_mean,
  var_CV,
  n,
  distribution = "normal",
  absolute_trend = NA,
  relative_trend = NA,
  lower_limit = NA,
  upper_limit = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vv_+3A_var_mean">var_mean</code></td>
<td>
<p>mean of the variable to be varied</p>
</td></tr>
<tr><td><code id="vv_+3A_var_cv">var_CV</code></td>
<td>
<p>desired coefficient of variation (in percent)</p>
</td></tr>
<tr><td><code id="vv_+3A_n">n</code></td>
<td>
<p>integer; number of values to produce</p>
</td></tr>
<tr><td><code id="vv_+3A_distribution">distribution</code></td>
<td>
<p>probability distribution for the introducing variation.
Currently only implemented for &quot;normal&quot;</p>
</td></tr>
<tr><td><code id="vv_+3A_absolute_trend">absolute_trend</code></td>
<td>
<p>absolute increment in the var_mean in each time step.
Defaults to NA, which means no such absolute value trend is present. If both
absolute and relative trends are specified, only original means are used</p>
</td></tr>
<tr><td><code id="vv_+3A_relative_trend">relative_trend</code></td>
<td>
<p>relative trend in the var_mean in each time step (in
percent). Defaults to NA, which means no such relative value trend is
present. If both absolute and relative trends are specified, only original
means are used</p>
</td></tr>
<tr><td><code id="vv_+3A_lower_limit">lower_limit</code></td>
<td>
<p>lowest possible value for elements of the resulting vector</p>
</td></tr>
<tr><td><code id="vv_+3A_upper_limit">upper_limit</code></td>
<td>
<p>upper possible value for elements of the resulting vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that only one type of trend can be specified. If neither of the trend
parameters are NA, the function uses only the original means
</p>


<h3>Value</h3>

<p>vector of n numeric values, representing a variable time series,
which initially has the mean var_mean, and then increases according to the
specified trends. Variation is determined by the given coefficient of
variation var_CV
</p>


<h3>Author(s)</h3>

<p>Eike Luedeling
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
valvar&lt;-vv(100,10,30)
plot(valvar)

valvar&lt;-vv(100,10,30,absolute_trend=5)
plot(valvar)

valvar&lt;-vv(100,10,30,relative_trend=5)
plot(valvar)

</code></pre>

<hr>
<h2 id='welfareDecisionAnalysis'>Analysis of the underlying welfare based decision problem.</h2><span id='topic+welfareDecisionAnalysis'></span>

<h3>Description</h3>

<p>The optimal choice between two different opportunities is calculated. Optimality is taken as 
maximizing expected welfare. Furthermore, the Expected Opportunity Loss (EOL) is calculated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>welfareDecisionAnalysis(
  estimate,
  welfare,
  numberOfModelRuns,
  randomMethod = "calculate",
  functionSyntax = "data.frameNames",
  relativeTolerance = 0.05,
  verbosity = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="welfareDecisionAnalysis_+3A_estimate">estimate</code></td>
<td>
<p><code><a href="#topic+estimate">estimate</a></code> object describing the distribution of the input variables.</p>
</td></tr>
<tr><td><code id="welfareDecisionAnalysis_+3A_welfare">welfare</code></td>
<td>
<p>either a <code>function</code> or a <code>list</code> with two <code>functions</code>, i.e.
<code>list(p1,p2)</code>. In the first case the function is the net benefit (or welfare) of project approval (PA) vs.
the status quo (SQ). In the second case the element <code>p1</code> is the function valuing the first
project and the element <code>p2</code> valuing the second project, viz. the welfare function of <code>p1</code>
and <code>p2</code> respectively.</p>
</td></tr>
<tr><td><code id="welfareDecisionAnalysis_+3A_numberofmodelruns">numberOfModelRuns</code></td>
<td>
<p><code>integer</code>: The number of running the welfare model for the 
underlying Monte Carlo simulation.</p>
</td></tr>
<tr><td><code id="welfareDecisionAnalysis_+3A_randommethod">randomMethod</code></td>
<td>
<p><code>character</code>: The method to be used to sample the distribution
representing the input estimate. For details see option <code>method</code> in 
<code><a href="#topic+random.estimate">random.estimate</a></code>.</p>
</td></tr>
<tr><td><code id="welfareDecisionAnalysis_+3A_functionsyntax">functionSyntax</code></td>
<td>
<p><code>character</code>: function syntax used in the welfare function(s). For 
details see <code><a href="#topic+mcSimulation">mcSimulation</a></code>.</p>
</td></tr>
<tr><td><code id="welfareDecisionAnalysis_+3A_relativetolerance">relativeTolerance</code></td>
<td>
<p><code>numeric</code>: the relative tolerance level of deviation of the
generated confidence interval from the specified interval. If this deviation is greater than
<code>relativeTolerance</code> a warning is given.</p>
</td></tr>
<tr><td><code id="welfareDecisionAnalysis_+3A_verbosity">verbosity</code></td>
<td>
<p><code>integer</code>: if <code>0</code> the function is silent; the larger the value the
more verbose is output information.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>The underlying decision problem and its notational framework</h4>

 
<p>We are considering a
decision maker who can influence an ecological-economic system having two alternative decisions
<code class="reqn">d_1</code> and <code class="reqn">d_2</code> at hand. We assume, that the system can be characterized by the 
<code class="reqn">n-</code>dimensional
vector <code class="reqn">X</code>. The characteristics <code class="reqn">X</code>, are not necessarily known exactly to the decision maker.
However, we assume furthermore that she is able to quantify this uncertainty which we call an
<em><a href="#topic+estimate">estimate</a></em> of the characteristics. Mathematically, an estimate is a random variable with
probability density <code class="reqn">\rho_X</code>.
</p>
<p>Furthermore, the characteristics <code class="reqn">X</code> determine the welfare <code class="reqn">W(d)</code> according to the welfare
function <code class="reqn">w_d</code>: 
</p>
<p style="text-align: center;"><code class="reqn"> 
      W_d = w_d (X) 
  </code>
</p>
 
<p>Thus, the welfare of decision <code class="reqn">d</code> is also a random
variable whose probability distribution we call <code class="reqn">\rho_{W_d}</code>. The welfare function <code class="reqn">w_d</code> values
the decision <code class="reqn">d</code> given a certain state <code class="reqn">X</code> of the system. In other words, decision <code class="reqn">d_2</code> is
preferred over decision <code class="reqn">d_1</code>, if and only if, the expected welfare of decision <code class="reqn">d_2</code> is
greater than the expected welfare (For a comprehensive
discussion of the concept of social preference ordering and its representation by a welfare
function cf. Gravelle and Rees (2004)) of decsion <code class="reqn">d_1</code>, formally 
</p>
<p style="text-align: center;"><code class="reqn">
    d_1 \prec d_2 \Leftrightarrow \textrm{E}[W_{d_1}] &lt; \textrm{E}[W_{d_2}].
   </code>
</p>

<p>This means the best decision <code class="reqn">d^*</code> is the one which maximizes welfare: 
</p>
<p style="text-align: center;"><code class="reqn"> 
    d^* := \arg \max_{d=d_1,d_2} \textrm{E}[W_d]
  </code>
</p>

<p>This maximization principle has a dual minimization principle. We define the net benefit
<code class="reqn">\textrm{NB}_{d_1} := W_{d_1} - W_{d_2}</code> as the difference 
between the welfare of the two decision
alternatives. A loss <code class="reqn">L_d</code> is characterized if a decision <code class="reqn">d</code> produces a negative net benefit.
No loss occurs if the decision produces a positive net benefit. This is reflected in the formal
definition 
</p>
<p style="text-align: center;"><code class="reqn">
      L_d := - \textrm{NB}_d, \textrm{~if~} \textrm{NB}_d  &lt; 0, \textrm{~and~} L_d := 0  
         \textrm{~otherwise}.
  </code>
</p>

<p>Using this notion it can be shown that the maximization of
expected welfare is equivalent to the minimization of the expected loss 
<code class="reqn">\textrm{EL}_d := \textrm{E}[L_d]</code>. 
</p>


<h5>The Expected Opportunity Loss (EOL)</h5>

<p>The use of this concept, here, is in line as described in Hubbard (2014). The Expected
Opportunity Loss (<code class="reqn">\textrm{EOL}</code>) is defined as the expected loss for the best
decision. The best decision minimizes the expected loss:
</p>
<p style="text-align: center;"><code class="reqn">
      \textrm{EOL} := \min \left\{ \textrm{EL}_{d_1}, \textrm{EL}_{d_2}\right\}
     </code>
</p>

<p>The <code class="reqn">\textrm{EOL}</code> is always conditional on the available information which is
characterized by the probability distribution of <code class="reqn">X</code>
<code class="reqn">\rho_X</code>: <code class="reqn">\textrm{EOL} = \textrm{EOL}(\rho_X)</code>.
</p>



<h5>Special case: Status quo and project approval</h5>

<p>A very common actual binary decision problem is the question if a certain project shall be 
approved versus continuing with business as usual, i.e. the status quo. It appears to be 
natural to identify the status quo with zero welfare. This is a special case ( Actually, one
can show, that this special case is equivalent to the discussion above.) of the binary
decision problem that we are considering here. The two decision alternatives are
</p>

<dl>
<dt><code class="reqn">d_1:</code></dt><dd><p> project approval (PA) and </p>
</dd>
<dt><code class="reqn">d_2:</code></dt><dd><p> status quo (SQ),</p>
</dd>
</dl>

<p>and the welfare of the approved project (or project outcome or yield of the project) is the
random variable <code class="reqn">W_\textrm{PA}</code> with distribution 
<code class="reqn">P_{W_\textrm{PA}} = w_\textrm{PA}(P_X)</code>:
</p>
<p style="text-align: center;"><code class="reqn">
        W_\textrm{PA} \sim w_\textrm{PA}(P_X) = P_{W_\textrm{PA}}
       </code>
</p>

<p>and the welfare of the status quo serves as reference and is normalized to zero:
</p>
<p style="text-align: center;"><code class="reqn">
      W_\textrm{SQ} \equiv 0,
    </code>
</p>

<p>which implies zero expected welfare of the status quo:
</p>
<p style="text-align: center;"><code class="reqn">
      \textrm{E}[W]_\textrm{SQ} 	= 0.
    </code>
</p>





<h3>Value</h3>

<p>An object of class <code>welfareDecisionAnalysis</code> with the following elements:
</p>

<dl>
<dt><code>$mcResult</code></dt><dd><p>The results of the Monte Carlo analysis of <code>estimate</code> 
transformed by <code>welfare</code></p>
</dd></dl>
<p> (cf. <code><a href="#topic+mcSimulation">mcSimulation</a></code>).
</p>
<dl>
<dt><code>$enbPa</code></dt><dd><p>Expected Net Benefit of project approval: ENB(PA)</p>
</dd>
<dt><code>$elPa</code></dt><dd><p>Expected Loss in case of project approval: EL(PA)</p>
</dd>
<dt><code>$elSq</code></dt><dd><p>Expected Loss in case of status quo: EL(SQ)</p>
</dd>
<dt><code>$eol</code></dt><dd><p>Expected Opportunity Loss: EOL</p>
</dd>
<dt><code>$optimalChoice</code></dt><dd>
<p>The optimal choice, i.e. either project approval (PA) or the status quo (SQ).
</p>
</dd>
</dl>



<h3>References</h3>

<p>Hubbard, Douglas W., <em>How to Measure Anything? - Finding the Value of &quot;Intangibles&quot; in Business</em>,
John Wiley &amp; Sons, Hoboken, New Jersey, 2014, 3rd Ed, <a href="https://www.howtomeasureanything.com/">https://www.howtomeasureanything.com/</a>.
</p>
<p>Gravelle, Hugh and Ray Rees, <em>Microeconomics</em>, Pearson Education Limited, 3rd edition, 2004.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcSimulation">mcSimulation</a></code>, <code><a href="#topic+estimate">estimate</a></code>, <code><a href="#topic+summary.welfareDecisionAnalysis">summary.welfareDecisionAnalysis</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#############################################################
# Example 1 (Creating the estimate from the command line):
#############################################################
# Create the estimate object:
variable=c("revenue","costs")
distribution=c("posnorm","posnorm")
lower=c(10000,  5000)
upper=c(100000, 50000)
costBenefitEstimate&lt;-as.estimate(variable, distribution, lower, upper)
# (a) Define the welfare function without name for the return value:
profit&lt;-function(x){
 x$revenue-x$costs
}
# Perform the decision analysis:
myAnalysis&lt;-welfareDecisionAnalysis(estimate=costBenefitEstimate, 
                                    welfare=profit, 
                                    numberOfModelRuns=100000,
                                    functionSyntax="data.frameNames")
# Show the analysis results:
print(summary((myAnalysis)))
#############################################################
# (b) Define the welfare function with a name for the return value:
profit&lt;-function(x){
 list(Profit=x$revenue-x$costs)
}
# Perform the decision analysis:
myAnalysis&lt;-welfareDecisionAnalysis(estimate=costBenefitEstimate, 
                                    welfare=profit, 
                                    numberOfModelRuns=100000,
                                    functionSyntax="data.frameNames")
# Show the analysis results:
print(summary((myAnalysis)))
#############################################################
# (c) Two decsion variables:
welfareModel&lt;-function(x){
 list(Profit=x$revenue-x$costs,
   Costs=-x$costs)
}
# Perform the decision analysis:
myAnalysis&lt;-welfareDecisionAnalysis(estimate=costBenefitEstimate, 
                                    welfare=welfareModel, 
                                    numberOfModelRuns=100000,
                                    functionSyntax="data.frameNames")
# Show the analysis results:
print(summary((myAnalysis)))
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
