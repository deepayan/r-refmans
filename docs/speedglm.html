<!DOCTYPE html><html><head><title>Help for package speedglm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {speedglm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#add1.speedlm'><p>Wrappers to the <code>add1</code> and <code>drop1</code> methods for speedlm and speedglm objects</p></a></li>
<li><a href='#control'><p>Miscellanea of functions</p></a></li>
<li><a href='#data1'><p>A toy dataset</p></a></li>
<li><a href='#predict.speedglm'><p>Predict method for a speedglm object</p></a></li>
<li><a href='#predict.speedlm'><p>Predict method for a speedlm object</p></a></li>
<li><a href='#speedglm'><p>Fitting Generalized Linear Models for Large Data Sets</p></a></li>
<li><a href='#speedglm-package'>
<p>Fitting Linear and Generalized Linear Models to Large Data Sets</p></a></li>
<li><a href='#speedlm'><p>Fitting Linear Models to Large Data Sets</p></a></li>
<li><a href='#summary.speedglm'><p>Methods to summarize Generalized Linear Models fits</p></a></li>
<li><a href='#summary.speedlm'><p>Methods to summarize Linear Models fits</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fitting Linear and Generalized Linear Models to Large Data Sets</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3-5</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-04-20</td>
</tr>
<tr>
<td>Author:</td>
<td>Marco Enea [aut, cre],
  Ronen Meiri [ctb] (on behalf of DMWay Analytics LTD),
  Tomer Kalimi [ctb] (on behalf of DMWay Analytics LTD)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marco Enea &lt;marco.enea@unipa.it&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>Matrix, MASS, biglm</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, stats</td>
</tr>
<tr>
<td>Description:</td>
<td>Fitting linear models and generalized linear models to large data sets by updating algorithms, according to the method described in Enea (2009, ISBN: 9788861294257).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-04-20 14:31:45 UTC; Marco Enea</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-05-06 10:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='add1.speedlm'>Wrappers to the <code>add1</code> and <code>drop1</code> methods for speedlm and speedglm objects</h2><span id='topic+add1.speedlm'></span><span id='topic+drop1.speedlm'></span><span id='topic+extractAIC.speedlm'></span><span id='topic+nobs.speedlm'></span><span id='topic+add1.speedglm'></span><span id='topic+drop1.speedglm'></span><span id='topic+extractAIC.speedglm'></span><span id='topic+nobs.speedglm'></span>

<h3>Description</h3>

<p>These are adviced to be used for <code>speedlm</code> and <code>speedglm</code> models fitted on moderately large data sets. It is also possible to use <a href="MASS.html#topic+stepAIC">stepAIC</a> function from package <code>MASS</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'speedlm'
## S3 method for class 'speedlm'
add1(object, scope, scale = 0, test = c("none", "Chisq","F"), 
                       x = NULL, k = 2, data, ...)
## S3 method for class 'speedlm'
drop1(object, scope, scale = 0, all.cols = TRUE,
                        test = c("none","Chisq", "F"), k = 2, data, ...)
## S3 method for class 'speedlm'
extractAIC(fit, scale = 0, k=2,...)
## S3 method for class 'speedlm'
nobs(object, use.fallback = FALSE, ...)

## S3 method for class 'speedglm'
## S3 method for class 'speedglm'
add1(object, scope, scale = 0, test = c("none", "LRT", 
                         "Chisq", "F"), x = NULL, k = 2, ...) 
## S3 method for class 'speedglm'
drop1(object, scope, scale = 0, test = c("none", "LRT", 
                         "Chisq", "F"), k = 2, ...)
## S3 method for class 'speedglm'
extractAIC(fit, scale = 0, k=2,...)
## S3 method for class 'speedglm'
nobs(object, use.fallback = FALSE, ...) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add1.speedlm_+3A_object">object</code></td>
<td>
<p>a <code>speedlm</code> or <code>speedglm</code> object for which <code>model=TRUE</code> was previously set to.</p>
</td></tr>
<tr><td><code id="add1.speedlm_+3A_fit">fit</code></td>
<td>
<p>a <code>speedlm</code> or <code>speedglm</code> object</p>
</td></tr>
<tr><td><code id="add1.speedlm_+3A_scope">scope</code></td>
<td>
<p>see <a href="stats.html#topic+add1">add1</a> from package <code>stats</code>.</p>
</td></tr>
<tr><td><code id="add1.speedlm_+3A_scale">scale</code></td>
<td>
<p>see <a href="stats.html#topic+add1">add1</a> from package <code>stats</code>.</p>
</td></tr>
<tr><td><code id="add1.speedlm_+3A_all.cols">all.cols</code></td>
<td>
<p>see <a href="stats.html#topic+drop1">drop1</a> from package <code>stats</code>.</p>
</td></tr>
<tr><td><code id="add1.speedlm_+3A_test">test</code></td>
<td>
<p>see <a href="stats.html#topic+add1">add1</a> from package <code>stats</code>. Currently, test <code>"Rao"</code> is not implemented.</p>
</td></tr>
<tr><td><code id="add1.speedlm_+3A_x">x</code></td>
<td>
<p>see <a href="stats.html#topic+add1">add1</a> from package <code>stats</code>.</p>
</td></tr>
<tr><td><code id="add1.speedlm_+3A_k">k</code></td>
<td>
<p>see <a href="stats.html#topic+add1">add1</a> from package <code>stats</code>.</p>
</td></tr>
<tr><td><code id="add1.speedlm_+3A_data">data</code></td>
<td>
<p>the data that the model was previously fitted to. 
If not provided, these will be searched in the parent environment.</p>
</td></tr>
<tr><td><code id="add1.speedlm_+3A_use.fallback">use.fallback</code></td>
<td>
<p>logical. Should fallback methods be used to try to guess the value?</p>
</td></tr>
<tr><td><code id="add1.speedlm_+3A_...">...</code></td>
<td>
<p>further optional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is possible to use functions step() and stepAIC() for both speedlm and speedglm objects but objects fitted using updateWithMoreData().</p>


<h3>Value</h3>

<p>An object of classes &quot;<code>anova</code>&quot; and &quot;<code>data.frame</code>&quot; summarizing the differences in fit between the models.</p>


<h3>Warnings</h3>

<p>Note that these functions have been poorly tested and need to be checked out more carefully.</p>


<h3>Author(s)</h3>

<p>Ronen Meiri and Marco Enea
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(10)
n &lt;- 50
k &lt;- 3
x &lt;- round(matrix(rnorm(n * k), n, k), digits = 3)
beta &lt;- c(0.05,0.5,0.8,1.3,1.8)
y &lt;- drop(tcrossprod(cbind(1,x,x[,2]*x[,3]),t(beta))) + rnorm(n,,0.2)
colnames(x) &lt;- c("s1", "s2", "s3") 
da &lt;- data.frame(y, x)

m0 &lt;- speedlm(y ~ 1, data = da,model=TRUE, y=TRUE)
m0.1 &lt;- add1(m0,scope=~s1+s2+s3, data = da)
m1 &lt;- step(m0,scope=~s1+s2+s3)
m1

</code></pre>

<hr>
<h2 id='control'>Miscellanea of functions</h2><span id='topic+control'></span><span id='topic+cp'></span><span id='topic+is.sparse'></span>

<h3>Description</h3>

<p>Utility functions for least squares estimation in large data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>control(B, symmetric = TRUE, tol.values = 1e-7, tol.vectors = 1e-7,
       out.B = TRUE, method = c("eigen", "Cholesky"))
cp(X, w = NULL, row.chunk = NULL, sparse = FALSE)
is.sparse(X, sparselim = .9, camp = .05)               
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="control_+3A_b">B</code></td>
<td>
<p>a squared matrix.</p>
</td></tr>
<tr><td><code id="control_+3A_symmetric">symmetric</code></td>
<td>
<p>logical, is <code>B</code> symmetric?</p>
</td></tr>
<tr><td><code id="control_+3A_tol.values">tol.values</code></td>
<td>
<p>tolerance to be consider eigenvalues equals to zero.</p>
</td></tr>
<tr><td><code id="control_+3A_tol.vectors">tol.vectors</code></td>
<td>
<p>tolerance to be consider eigenvectors equals to zero.</p>
</td></tr>
<tr><td><code id="control_+3A_out.b">out.B</code></td>
<td>
<p>Have the matrix B to be returned?</p>
</td></tr>
<tr><td><code id="control_+3A_method">method</code></td>
<td>
<p>the method to check for singularity. By default is &quot;eigen&quot;, and
an eigendecomposition of X'X is made. The &quot;Cholesky&quot; method is 
faster than &quot;eigen&quot; and does not use tolerance, but the former 
seems to be more stable for opportune tolerance values.</p>
</td></tr>
<tr><td><code id="control_+3A_x">X</code></td>
<td>
<p>the model matrix.</p>
</td></tr>
<tr><td><code id="control_+3A_w">w</code></td>
<td>
<p>a weights vector.</p>
</td></tr>
<tr><td><code id="control_+3A_sparse">sparse</code></td>
<td>
<p>logical, is <code>X</code> sparse?</p>
</td></tr>  
<tr><td><code id="control_+3A_sparselim">sparselim</code></td>
<td>
<p>a real in the interval [0; 1]. It indicates 
the minimal proportion of zeroes in the data matrix X in order 
to consider X as sparse </p>
</td></tr> 
</table>
<p>eigendec Logical. Do you want to investigate on rank of X? You may set to
</p>
<table>
<tr><td><code id="control_+3A_row.chunk">row.chunk</code></td>
<td>
<p>an integer which indicates the total rows number 
compounding each of the first g-1 blocks. If <code>row.chunk</code> is not a divisor 
of nrow(X), the g-th block will be formed by the remaining data.</p>
</td></tr>
<tr><td><code id="control_+3A_camp">camp</code></td>
<td>
<p>the sample proportion of elements of X on which the survey will be based.</p>
</td></tr>       
</table>


<h3>Details</h3>

<p>Function <code>control</code> makes an eigendecomposition of B according established values of tolerance. 
Function <code>cp</code> makes the cross-product X'X by partitioning X in row-blocks. 
When an optimized BLAS, such as ATLAS, is not installed, the function represents an attempt 
to speed up the calculation and avoid overflows with medium-large data sets loaded in R memory.
The results depending on processor type. Good results are obtained, for example, with an AMD Athlon 
dual core 1.5 Gb RAM by setting <code>row.chunk</code> to some value less than 1000. Try the example below 
by changing the matrix size and the value of <code>row.chunk</code>. If the matrix X is sparse, it will have 
class &quot;dgCMatrix&quot; (the package Matrix is required) and the cross-product will be made without 
partitioning. However, good performances are usually obtained with a very 
high zeroes proportion. 
Function <code>is.sparse</code> makes a quick sample survey on sample proportion of zeroes in X.
</p>


<h3>Value</h3>

<p>for the function <code>control</code>, a list with the following elements:
</p>
<table>
<tr><td><code>XTX</code></td>
<td>
<p>the matrix product B without singularities (if there are).</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>the rank of B</p>
</td></tr>
<tr><td><code>pivot</code></td>
<td>
<p>an ordered set of column indeces of B with, if the case, the last <code class="reqn">rank+1,...,p</code>  
columns which indicate possible linear combinations.</p>
</td></tr>
</table>
<p>for the function <code>cp</code>:  
</p>
<table>
<tr><td><code>new.B</code></td>
<td>
<p>the matrix product X'X (weighted, if <code>w</code> is given).</p>
</td></tr>
</table>
<p>for the function <code>is.sparse</code>:  
</p>
<table>
<tr><td><code>sparse</code></td>
<td>
<p>a logical value which indicates if the sample proportion of zeroes is 
greater than <code>sparselim</code>, with the sample proportion as attribute.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Marco ENEA</p>


<h3>See Also</h3>

 <p><a href="base.html#topic+eigen">eigen</a>, <a href="Matrix.html#topic+chol">chol</a>, <a href="Matrix.html#topic+qr">qr</a>, <a href="Matrix.html#topic+crossprod">crossprod</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>#### example 1.

n &lt;- 100
k &lt;- 5
x &lt;- round(matrix(rnorm(n*k),n,k),digits=4)
y &lt;- rnorm(n)

# if an optimized BLAS is not installed, depending on processor type, cp() may be 
# faster than crossprod() for large matrices.

a1 &lt;- crossprod(x)
a2 &lt;- cp(x,,row.chunk = 50)
all.equal(a1, a2)  

#### example 2.1.
x[,2] &lt;- x[,1] + 2*x[,3]  # x has rank 9

# estimation by least squares 
A &lt;- function(){
  A1 &lt;- control(crossprod(x))
  ok &lt;- A1$pivot[1:A1$rank]
  as.vector(solve(A1$XTX,crossprod(x[,ok],y)))
}
# estimation by QR decomposition
B &lt;- function(){
  B1 &lt;- qr(x)
  qr.solve(x[,B1$pivot[1:B1$rank]],y)    
}  
a &lt;- A()
b &lt;- B()

all.equal(a,b)


### example 3. 
n &lt;- 1000
fat1 &lt;- gl(20,50)
y &lt;- rnorm(n)
da &lt;- data.frame(y,fat1)
m &lt;- model.matrix(y ~ factor(fat1),data = da)
is.sparse(m)





</code></pre>

<hr>
<h2 id='data1'>A toy dataset</h2><span id='topic+data1'></span>

<h3>Description</h3>

<p>The <code>data1</code> dataset has 100 rows and 4 columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data1)</code></pre>


<h3>Format</h3>

<p>A data frame with 100 observations on the following 4 variables.
</p>

<dl>
<dt><code>y</code></dt><dd><p>a gamma-distributed response variable</p>
</dd>
<dt><code>fat1</code></dt><dd><p>a four-level factor</p>
</dd>
<dt><code>x1</code></dt><dd><p>a numeric covariate</p>
</dd>
<dt><code>x2</code></dt><dd><p>a numeric covariate</p>
</dd>
</dl>



<h3>Details</h3>

<p>This is a toy dataset used to show how function <code>shglm</code> works.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(data1)
</code></pre>

<hr>
<h2 id='predict.speedglm'>Predict method for a speedglm object</h2><span id='topic+predict.speedglm'></span>

<h3>Description</h3>

<p><code>summary</code> The method is currently under construction but some functionalities are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'speedglm'
predict(object, newdata, type = c("link", "response"), 
                           na.action = na.pass, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.speedglm_+3A_object">object</code></td>
<td>
<p>an object of class 'speedlgm'.</p>
</td></tr>
<tr><td><code id="predict.speedglm_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame with new data or the original data.</p>
</td></tr>
<tr><td><code id="predict.speedglm_+3A_type">type</code></td>
<td>
<p>Type of prediction.</p>
</td></tr>
<tr><td><code id="predict.speedglm_+3A_na.action">na.action</code></td>
<td>
<p>function determining what should be done with missing values in <code>newdata</code>.</p>
</td></tr>
<tr><td><code id="predict.speedglm_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>newdata</code> is omitted prediction are based on the data used for the fit only if argument <code>fitted</code> was previously set to <code>TRUE</code> in the speedglm object.
Currently the method does not work for function <code>shglm</code>.</p>


<h3>Value</h3>

<table>
<tr><td><code>pred</code></td>
<td>
<p>a vector of predictions.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Tomer Kalimi and Marco Enea </p>


<h3>See Also</h3>

 <p><a href="#topic+speedglm">speedglm</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(data1)
mod &lt;- speedglm(y~x1+x2+factor(fat1), data=data1, family=Gamma(log), fitted=TRUE)
predict(mod)

</code></pre>

<hr>
<h2 id='predict.speedlm'>Predict method for a speedlm object</h2><span id='topic+predict.speedlm'></span>

<h3>Description</h3>

<p><code>summary</code> The method is currently under construction but some functionalities are available.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'speedlm'
predict(object, newdata, na.action = na.pass, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.speedlm_+3A_object">object</code></td>
<td>
<p>an object of class 'speedlm'.</p>
</td></tr>
<tr><td><code id="predict.speedlm_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame with new data or the original data.</p>
</td></tr>
<tr><td><code id="predict.speedlm_+3A_na.action">na.action</code></td>
<td>
<p>function determining what should be done with missing values in               
<code>newdata</code>.</p>
</td></tr>
<tr><td><code id="predict.speedlm_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>newdata</code> is omitted prediction are based on the data used for the fit only if argument <code>fitted</code> was previously set to <code>TRUE</code> in the speedlm object.</p>


<h3>Value</h3>

<table>
<tr><td><code>predictor</code></td>
<td>
<p>a vector of predictions.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Tomer Kalimi and Marco Enea </p>


<h3>See Also</h3>

 <p><a href="#topic+speedlm">speedlm</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(data1)
mod &lt;- speedglm(y~x1+x2+factor(fat1), data=data1, family=Gamma(log), fitted=TRUE)
predict(mod)

</code></pre>

<hr>
<h2 id='speedglm'>Fitting Generalized Linear Models for Large Data Sets</h2><span id='topic+speedglm.wfit'></span><span id='topic+speedglm'></span><span id='topic+shglm'></span>

<h3>Description</h3>

<p><code>speedglm</code> and <code>speedglm.wfit</code> fit GLMs to medium-large 
data sets, that is those storable into the R memory. The highest performances, in terms of computation time,
are obtained when R is linked against an optimized BLAS, such as ATLAS. The function <code>shglm</code> 
is for a data set stored into a file of size greater than the available memory, and takes as 
argument a function to manipulate connections. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.frame':
speedglm(formula,data,family=gaussian(),weights=NULL,start=NULL,
         etastart=NULL,mustart=NULL,offset=NULL,maxit=25, k=2, 
         sparse=NULL,set.default=list(), trace=FALSE,
         method=c('eigen','Cholesky','qr'), model=FALSE, y=FALSE, 
         fitted=FALSE,...)

## S3 method for class 'matrix':       
speedglm.wfit(y, X, intercept=TRUE, weights=NULL,row.chunk=NULL,
              family=gaussian(), start=NULL, etastart=NULL,
              mustart=NULL, offset=NULL, acc=1e-08, maxit=25, k=2,
              sparselim=.9,camp=.01, eigendec=TRUE, tol.values=1e-7,
              tol.vectors=1e-7, tol.solve=.Machine$double.eps,
              sparse=NULL,method = c('eigen','Cholesky','qr'), 
              trace=FALSE,...)
              
## S3 method for class 'function':              
shglm(formula, datafun, family = gaussian(), weights.fo = NULL, start = NULL, 
      etastart = NULL, mustart = NULL, offset = NULL, maxit = 25, k = 2, 
      chunksize = 5000, sparse = NULL, trace = FALSE, all.levels = FALSE,
      set.default = list(),...)
     
</code></pre>


<h3>Arguments</h3>

<p>Most of arguments are the same of <a href="stats.html#topic+glm">glm</a> or <a href="biglm.html#topic+bigglm">bigglm</a> 
but with some difference.     
</p>
<table>
<tr><td><code id="speedglm_+3A_formula">formula</code></td>
<td>
<p>the same of <code>glm</code>.</p>
</td></tr>
<tr><td><code id="speedglm_+3A_data">data</code></td>
<td>
<p>a data frame.</p>
</td></tr>
<tr><td><code id="speedglm_+3A_datafun">datafun</code></td>
<td>
<p>a function which uses connections. See the example below.</p>
</td></tr>     
<tr><td><code id="speedglm_+3A_family">family</code></td>
<td>
<p>the same of <code>glm</code>, but it must be specified with brackets.</p>
</td></tr>
<tr><td><code id="speedglm_+3A_start">start</code></td>
<td>
<p>the same of <code>glm</code>.</p>
</td></tr>
<tr><td><code id="speedglm_+3A_weights">weights</code></td>
<td>
<p>the same of <code>glm</code>.</p>
</td></tr>
<tr><td><code id="speedglm_+3A_weights.fo">weights.fo</code></td>
<td>
<p>weights for the response. It must be specified as a formula 
(see the example below).</p>
</td></tr>
<tr><td><code id="speedglm_+3A_etastart">etastart</code></td>
<td>
<p>the same of <code>glm</code>.</p>
</td></tr>
<tr><td><code id="speedglm_+3A_mustart">mustart</code></td>
<td>
<p>the same of <code>glm</code>.</p>
</td></tr>
<tr><td><code id="speedglm_+3A_offset">offset</code></td>
<td>
<p>the same of <code>glm</code>.</p>
</td></tr>
<tr><td><code id="speedglm_+3A_intercept">intercept</code></td>
<td>
<p>the same of <code>glm</code>.</p>
</td></tr>
<tr><td><code id="speedglm_+3A_x">X</code></td>
<td>
<p>the same of <code>x</code> in <code>glm.fit</code>.</p>
</td></tr>
<tr><td><code id="speedglm_+3A_y">y</code></td>
<td>
<p>the same of <code>glm</code> and <code>glm.fit</code>.</p>
</td></tr>
<tr><td><code id="speedglm_+3A_maxit">maxit</code></td>
<td>
<p>the same of <code>glm</code>.</p>
</td></tr>
<tr><td><code id="speedglm_+3A_k">k</code></td>
<td>
<p>numeric, the penalty per parameter to be used; the default k = 2 is
the classical AIC.</p>
</td></tr>
<tr><td><code id="speedglm_+3A_trace">trace</code></td>
<td>
<p>logical. Do you want to be informed about the model estimation 
progress?</p>
</td></tr>
<tr><td><code id="speedglm_+3A_sparse">sparse</code></td>
<td>
<p>logical. Is the model matrix sparse? By default is NULL, so a 
quickly sample survey will be made.</p>
</td></tr>
<tr><td><code id="speedglm_+3A_chunksize">chunksize</code></td>
<td>
<p>an integer indicates the number of rows of the data file to 
read at time.</p>
</td></tr>
<tr><td><code id="speedglm_+3A_all.levels">all.levels</code></td>
<td>
<p>logical, are all factor's levels present in each data chunk?</p>
</td></tr>
<tr><td><code id="speedglm_+3A_set.default">set.default</code></td>
<td>
<p>a list in which to specify the below parameters.</p>
</td></tr>
<tr><td><code id="speedglm_+3A_sparselim">sparselim</code></td>
<td>
<p>a real in the interval [0, 1]. It indicates the minimal 
proportion of zeroes in the data matrix X in order to consider X as sparse.</p>
</td></tr>   
<tr><td><code id="speedglm_+3A_camp">camp</code></td>
<td>
<p>see the function <a href="#topic+is.sparse">is.sparse</a>.</p>
</td></tr>
<tr><td><code id="speedglm_+3A_eigendec">eigendec</code></td>
<td>
<p>logical. Do you want to check the rank of X? You may set it to 
false if you are sure that X is full rank.</p>
</td></tr>  
<tr><td><code id="speedglm_+3A_row.chunk">row.chunk</code></td>
<td>
<p>an integer, see the function <a href="#topic+cp">cp</a> for details.</p>
</td></tr>
<tr><td><code id="speedglm_+3A_acc">acc</code></td>
<td>
<p>tolerance to be used for the estimation.</p>
</td></tr> 
<tr><td><code id="speedglm_+3A_tol.solve">tol.solve</code></td>
<td>
<p>see the function <a href="Matrix.html#topic+solve">solve</a>.</p>
</td></tr>
<tr><td><code id="speedglm_+3A_tol.values">tol.values</code></td>
<td>
<p>see the function <a href="#topic+control">control</a>.</p>
</td></tr>
<tr><td><code id="speedglm_+3A_tol.vectors">tol.vectors</code></td>
<td>
<p>see the function <a href="#topic+control">control</a>.</p>
</td></tr>
<tr><td><code id="speedglm_+3A_method">method</code></td>
<td>
<p>the method chosen to detect for singulatity.</p>
</td></tr>  
<tr><td><code id="speedglm_+3A_model">model</code></td>
<td>
<p>logical. If TRUE the model frame will be returned. </p>
</td></tr>  
<tr><td><code id="speedglm_+3A_fitted">fitted</code></td>
<td>
<p>logical. If TRUE the fitted values will be returned.</p>
</td></tr>  
<tr><td><code id="speedglm_+3A_...">...</code></td>
<td>
<p>further optional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>shglm</code> works like
<code>biglm</code>, but it checks for singularity and does not impose restrictions on 
factors. Since during the IWLS estimation <code>shglm</code> uses repeated accesses to 
data file stored, for example, into the hard disk, the estimation time could be very long. 
Unlike from <code>glm</code> or <code>biglm</code>, the functions of class 'speedglm' do not use 
the QR decomposition, but directly solve the equations in the form of Iterative(-ly) (Re-)Weighted Least Squares (IWLS). 
The memory size of an object of class 'speedglm' is <code class="reqn">O(p^2)</code>, where <code class="reqn">p</code> is the number of covariates, unless one or more of argument <code>model</code>, <code>y</code> and <code>fitted</code> are set to TRUE. If an optimized BLAS 
is not installed, an attempt to speed up calculations might be done by setting <code>row.chunk</code> 
to some value, usually less than 1000, in <code>set.default</code>. See the function <a href="#topic+cp">cp</a> for details.<br />
If the model matrix is (very) sparse, the package <code>Matrix</code> could be used.
Note that if method 'qr' is chosen, then the qr decomposition will not be applied on matrix X, as in <code>lm</code>, 
but on X'WX.   
</p>


<h3>Value</h3>

<table>
<tr><td><code>coefficients</code></td>
<td>
<p>the estimated coefficients.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>the log likelihood of the fitted model.</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>the number of iterations of IWLS used.</p>
</td></tr>
<tr><td><code>tol</code></td>
<td>
<p>the maximal value of tolerance reached.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>a logical value which indicates if convergence was reached.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>the family object used.</p>
</td></tr>
<tr><td><code>link</code></td>
<td>
<p>the link function used.</p>
</td></tr>
<tr><td><code>df</code></td>
<td>
<p>the degrees of freedom of the model.</p>
</td></tr>
<tr><td><code>XTX</code></td>
<td>
<p>the product X'X (weighted, if the case).</p>
</td></tr>
<tr><td><code>dispersion</code></td>
<td>
<p>the estimated dispersion parameter of the model.</p>
</td></tr>
<tr><td><code>ok</code></td>
<td>
<p>the set of column indeces of the model matrix where the model has
been fitted.</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>the rank of the model matrix.</p>
</td></tr>  
<tr><td><code>RSS</code></td>
<td>
<p>the estimated residual sum of squares of the fitted model.</p>
</td></tr>
<tr><td><code>aic</code></td>
<td>
<p>the estimated Akaike Information Criterion.</p>
</td></tr>
<tr><td><code>sparse</code></td>
<td>
<p>a logical value which indicates if the model matrix is sparse.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>the estimated deviance of the fitted model.</p>
</td></tr>
<tr><td><code>nulldf</code></td>
<td>
<p>the degrees of freedom of the null model.</p>
</td></tr>
<tr><td><code>nulldev</code></td>
<td>
<p>the estimated deviance of the null model.</p>
</td></tr>
<tr><td><code>ngoodobs</code></td>
<td>
<p>the number of non-zero weighted observations.</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>the number of observations.</p>
</td></tr>
<tr><td><code>intercept</code></td>
<td>
<p>a logical value which indicates if an intercept has been used.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the terms object used.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>Either NULL or, if <code>model</code> was previously set to TRUE, the model frame. </p>
</td></tr>  
<tr><td><code>y</code></td>
<td>
<p>Either NULL or, if <code>y</code> was previously set to TRUE, the response variable. </p>
</td></tr>  
<tr><td><code>linear.predictors</code></td>
<td>
<p>Either NULL or, if <code>fitted</code> was previously set to TRUE, the fitted values. </p>
</td></tr>    
<tr><td><code>offset</code></td>
<td>
<p>the model offset.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>All the above functions make an object of class 'speedglm'.<br />
In the current package version, arguments <code>start</code>, <code>mustart</code> and <code>etastart</code> of function <code>shglm</code> have been disabled. 
These will be restored in future.</p>


<h3>Author(s)</h3>

<p> Marco Enea. Ronen Meiri contributed with method 'qr'</p>


<h3>References</h3>

<p>Enea, M. (2009) Fitting Linear Models and Generalized Linear Models with large data sets in R.
In <em>book of short papers, conference on &ldquo;Statistical Methods for the analysis of large data-sets&rdquo;,
Italian Statistical Society</em>, Chieti-Pescara, 23-25 September 2009, 411-414. ISBN:978-88-6129-425-7<br />
</p>
<p>Bates, D. (2009) Comparing Least Square Calculations. Technical report. <br />
</p>
<p>Lumley, T. (2009) biglm: bounded memory linear and generalized linear models. <em>R package version 0.7</em>.
<a href="https://CRAN.R-project.org/package=biglm">https://CRAN.R-project.org/package=biglm</a>.
</p>


<h3>See Also</h3>

 <p><a href="#topic+speedlm">speedlm</a>, <a href="biglm.html#topic+bigglm">bigglm</a>, <a href="stats.html#topic+glm">glm</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>

# The following comparison among glm(), bigglm() and speedglm() cannot be considered rigorous 
# and exhaustive, but it is only to give an idea of the computation time. 
# It may take a long time.
library(biglm)
n&lt;-10000
k&lt;-70
y &lt;- rgamma(n,1.5,1)
x &lt;-round( matrix(rnorm(n*k),n,k),digits=3)
colnames(x) &lt;-paste("s",1:k,sep = "")
da&lt;- data.frame(y,x)
fo &lt;- as.formula(paste("y~",paste(paste("s",1:k,sep=""),collapse="+")))   

system.time(m1 &lt;- glm(fo,data=da,family=Gamma(log)))
system.time(m2 &lt;- bigglm(fo,data=da,family=Gamma(log)))
system.time(m3 &lt;- speedglm(fo,data=da,family=Gamma(log)))

# You may also try speedglm when R is linked against an optimized BLAS,
# otherwise try to run the following function. In some computers, it is
# faster for large data sets.
system.time(m4 &lt;- speedglm(fo,data=da,family=Gamma(log),set.default=list(row.chunk=50)))

##################

## An example of function using a connection to an out-memory file  
## This is a slightly modified version of the function from the bigglm's help page 
 make.data&lt;-function(filename, chunksize,...){       
     conn&lt;-NULL
     function(reset=FALSE){
     if(reset){
       if(!is.null(conn)) close(conn)
       conn&lt;&lt;-file(filename,open="r")
     } else{
       rval&lt;-read.table(conn, nrows=chunksize,...)
       if ((nrow(rval)==0)) {
            close(conn)
            conn&lt;&lt;-NULL
            rval&lt;-NULL
       }
       return(rval)
     }
  }
}


# data1 is a small toy dataset
data(data1)
tmp_data1&lt;-tempfile("data1",fileext=".txt")
write.table(data1,tmp_data1,row.names=FALSE,col.names=FALSE)

da&lt;-make.data(tmp_data1,chunksize=50,col.names=c("y","fat1","x1","x2"))

# Caution! make sure to close the connection once you have run command #1
da(reset=TRUE) #1: opens the connection to "data1.txt"
da(reset=FALSE) #2: reads the first 50 rows (out of 100) of the dataset
da(reset=FALSE) #3: reads the second 50 rows (out of 100) of the dataset
da(reset=FALSE) #4: is NULL: this latter command closes the connection

# fat1 is a factor with four levels                                    
b1&lt;-shglm(y~factor(fat1)+x1,weights=~I(x2^2),datafun=da,family=Gamma(log))
b2&lt;-bigglm(y~factor(fat1)+x1,weights=~I(x2^2),data=da,family=Gamma(log))
summary(b1) 
summary(b2) 

</code></pre>

<hr>
<h2 id='speedglm-package'>
Fitting Linear and Generalized Linear Models to Large Data Sets
</h2><span id='topic+speedglm-package'></span>

<h3>Description</h3>

<p>Fits Linear and Generalized Linear Models to large data sets. For data loaded in R memory the fitting is usually
fast, especially if R is linked against an optimized BLAS. For data sets of size larger than 
R memory, the fitting is made by an updating algorithm.</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> speedglm</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 0.3-5</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-04-20</td>
</tr>
<tr>
 <td style="text-align: left;">
Depends: </td><td style="text-align: left;"> Matrix, stats, MASS</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Marco Enea &lt;marco.enea@unipa.it&gt;, with contributions from Ronen Meiri and Tomer Kalimi (on behalf of DMWay Analytics LTD).
</p>
<p>Maintainer: Marco Enea &lt;marco.enea@unipa.it&gt; 
</p>

<hr>
<h2 id='speedlm'>Fitting Linear Models to Large Data Sets</h2><span id='topic+speedlm'></span><span id='topic+speedlm.fit'></span><span id='topic+speedlm.wfit'></span><span id='topic+update.speedlm'></span><span id='topic+updateWithMoreData'></span>

<h3>Description</h3>

<p>The functions of class 'speedlm' may speed up the fitting of LMs to large data
sets. High performances can be obtained especially if R is linked against an
optimized BLAS, such as ATLAS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'># S3 method of class 'data.frame'
speedlm(formula, data, weights = NULL, offset = NULL, sparse = NULL, 
        set.default = list(), method=c('eigen','Cholesky','qr'), 
        model = FALSE, y = FALSE, fitted = FALSE, subset=NULL, ...)

# S3 method of class 'matrix'
speedlm.fit(y, X, intercept = FALSE, offset = NULL, row.chunk = NULL, 
            sparselim = 0.9, camp = 0.01, eigendec = TRUE, 
            tol.solve = .Machine$double.eps, sparse = NULL, tol.values = 1e-07, 
            tol.vectors = 1e-07, method=c('eigen','Cholesky','qr'), ...)

speedlm.wfit(y, X, w, intercept = FALSE, offset = NULL, row.chunk = NULL, 
             sparselim = 0.9, camp = 0.01, eigendec = TRUE, 
             tol.solve = .Machine$double.eps, sparse = NULL, tol.values = 1e-07, 
             tol.vectors = 1e-07, method=c('eigen','Cholesky','qr'), ...)
                      
# S3 method of class 'speedlm' (object) and 'data.frame' (data)                    
## S3 method for class 'speedlm'
update(object, formula, data, add=TRUE, evaluate=TRUE, 
                           subset=NULL, offset=NULL, weights=NULL,...)

# S3 method of class 'speedlm' (object) and 'data.frame' (data)                    
updateWithMoreData(object, data, weights = NULL, offset = NULL, sparse = NULL, 
                   all.levels = FALSE, set.default = list(), subset=NULL,...)
</code></pre>


<h3>Arguments</h3>

<p>Most of arguments are the same of functions <a href="stats.html#topic+lm">lm</a> but with 
some difference.  
</p>
<table>
<tr><td><code id="speedlm_+3A_formula">formula</code></td>
<td>
<p>the same of function <code>lm</code>.</p>
</td></tr>
<tr><td><code id="speedlm_+3A_data">data</code></td>
<td>
<p>the same of function <code>lm</code>.</p>
</td></tr>
<tr><td><code id="speedlm_+3A_weights">weights</code></td>
<td>
<p>the same of function <code>lm</code>.</p>
</td></tr>
<tr><td><code id="speedlm_+3A_w">w</code></td>
<td>
<p>model weights.</p>
</td></tr>  
<tr><td><code id="speedlm_+3A_intercept">intercept</code></td>
<td>
<p>a logical value which indicates if an intercept is used.</p>
</td></tr> 
<tr><td><code id="speedlm_+3A_offset">offset</code></td>
<td>
<p>the same of function <code>lm</code>.</p>
</td></tr>
<tr><td><code id="speedlm_+3A_x">X</code></td>
<td>
<p>the same of <code>x</code> in function <code>lm</code>.</p>
</td></tr>
<tr><td><code id="speedlm_+3A_y">y</code></td>
<td>
<p>the same of <code>lm</code>,<code>lm.wfit</code> and <code>lm.fit</code> .</p>
</td></tr>
<tr><td><code id="speedlm_+3A_sparse">sparse</code></td>
<td>
<p>logical. Is the model matrix sparse? By default is NULL, so a
quickly sample survey will be made.</p>
</td></tr>
<tr><td><code id="speedlm_+3A_set.default">set.default</code></td>
<td>
<p>a list in which to specify the parameters to pass to the
functions <a href="#topic+cp">cp</a>, <a href="#topic+control">control</a> and <a href="#topic+is.sparse">is.sparse</a>.</p>
</td></tr>
<tr><td><code id="speedlm_+3A_sparselim">sparselim</code></td>
<td>
<p>a value in the interval [0, 1]. It indicates the minimal 
proportion of zeroes, in the model matrix X, in order to consider X as
sparse.</p>
</td></tr>
<tr><td><code id="speedlm_+3A_camp">camp</code></td>
<td>
<p>see function <code>is.sparse</code>.</p>
</td></tr>
<tr><td><code id="speedlm_+3A_eigendec">eigendec</code></td>
<td>
<p>logical. Do you want to investigate on rank of X? You may set
it to false if you are sure that X is full rank.</p>
</td></tr>
<tr><td><code id="speedlm_+3A_row.chunk">row.chunk</code></td>
<td>
<p>an integer, see the function <code>cp</code> for details.</p>
</td></tr>
<tr><td><code id="speedlm_+3A_tol.solve">tol.solve</code></td>
<td>
<p>see function <a href="Matrix.html#topic+solve">solve</a>.</p>
</td></tr>
<tr><td><code id="speedlm_+3A_tol.values">tol.values</code></td>
<td>
<p>see function <a href="#topic+control">control</a>.</p>
</td></tr>
<tr><td><code id="speedlm_+3A_tol.vectors">tol.vectors</code></td>
<td>
<p>see function <a href="#topic+control">control</a>.</p>
</td></tr>
<tr><td><code id="speedlm_+3A_method">method</code></td>
<td>
<p>the method used to check for singularity. The default is 'eigen'.
See details</p>
</td></tr>
<tr><td><code id="speedlm_+3A_object">object</code></td>
<td>
<p>an object of class 'speedlm'.</p>
</td></tr>
<tr><td><code id="speedlm_+3A_all.levels">all.levels</code></td>
<td>
<p>are all levels of eventual factors present in each data
chunk? If so, set <code>all.levels</code> to true to speed up the fitting.</p>
</td></tr>
<tr><td><code id="speedlm_+3A_model">model</code></td>
<td>
<p>logical. Should the model frame be returned?</p>
</td></tr>  
<tr><td><code id="speedlm_+3A_fitted">fitted</code></td>
<td>
<p>logical. Should the fitted values be returned? </p>
</td></tr>    
<tr><td><code id="speedlm_+3A_subset">subset</code></td>
<td>
<p>the same of function <code>lm</code></p>
</td></tr> 
<tr><td><code id="speedlm_+3A_add">add</code></td>
<td>
<p>logical. Are additional data coming from a new chunk provided?</p>
</td></tr>
<tr><td><code id="speedlm_+3A_evaluate">evaluate</code></td>
<td>
<p>logical. If true evaluate the new call else return the call.</p>
</td></tr>
<tr><td><code id="speedlm_+3A_...">...</code></td>
<td>
<p>further optional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlikely from <a href="stats.html#topic+lm">lm</a> or <a href="biglm.html#topic+biglm">biglm</a>, the functions of 
class 'speedlm' do not use the QR decomposition of the X-matrix, but directly 
solve the normal equations.  In some extreme case, this might have some problem 
of numerical stability, but it may take advantage from the use of 
an optimized BLAS. To check for singularity, three options are available. 
Method &quot;eigen&quot; performs an eigendecomposition of X'X. The 'Cholesky' method is 
faster than &quot;eigen&quot; and does not use tolerance, but the former 
seems to be more stable for opportune tolerance values. Method 'qr' does 
not perform a QR decomposition directly on matrix X, but on X'WX.   
The memory size of an object of class 'speedlm' is <code class="reqn">O(p^2)</code>, where <code class="reqn">p</code> 
is the number of covariates. If an optimized BLAS library is not installed, an 
attempt to speed up calculations may be done by setting <code>row.chunk</code> 
to some value, usually less than 1000, in <code>set.default</code>. See the function 
<a href="#topic+cp">cp</a> for details. Factors are permitted without limitations. <br />
In the most recent versions, function <code>update.speedlm</code> is now a wrapper to 
call either <code>updateWithMoreData</code>  (the new name of the old <code>update.speedlm</code>, 
for additional data chunks), or <a href="stats.html#topic+update">update</a> from package <code>stats</code>. 
</p>


<h3>Value</h3>

<table>
<tr><td><code>coefficients</code></td>
<td>
<p>the estimated coefficients.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>the residual degrees of freedom.</p>
</td></tr>
<tr><td><code>XTX</code></td>
<td>
<p>the product X'X (weighted, if the case).</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>the product X'X (weighted, if the case) not checked for singularity.</p>
</td></tr>
<tr><td><code>Xy</code></td>
<td>
<p>the product X'y (weighted, if the case).</p>
</td></tr>
<tr><td><code>ok</code></td>
<td>
<p>the set of column indeces of the model matrix where the model has
been fitted.</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>the numeric rank of the fitted linear model.</p>
</td></tr>
<tr><td><code>pivot</code></td>
<td>
<p>see the function <a href="#topic+control">control</a>.</p>
</td></tr>
<tr><td><code>RSS</code></td>
<td>
<p>the estimated residual sums of squares of the fitted model.</p>
</td></tr>
<tr><td><code>sparse</code></td>
<td>
<p>a logical value indicating if the model matrix is sparse.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>the estimated deviance of the fitted model.</p>
</td></tr>
<tr><td><code>weigths</code></td>
<td>
<p>the weights used in the last updating.</p>
</td></tr>
<tr><td><code>zero.w</code></td>
<td>
<p>the number of non-zero weighted observations.</p>
</td></tr>
<tr><td><code>nobs</code></td>
<td>
<p>the number of observations.</p>
</td></tr>
<tr><td><code>nvar</code></td>
<td>
<p>the number of independent variables.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>the <code>terms</code> object used.</p>
</td></tr>
<tr><td><code>intercept</code></td>
<td>
<p>a logical value which indicates if an intercept has been used.</p>
</td></tr> 
<tr><td><code>call</code></td>
<td>
<p>the matched call.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>Either NULL or the model frame, if <code>model</code> was previously set to TRUE. </p>
</td></tr>  
<tr><td><code>y</code></td>
<td>
<p>Either NULL or the response variable, if <code>y</code> was previously set to TRUE. </p>
</td></tr>  
<tr><td><code>fitted.values</code></td>
<td>
<p>Either NULL or the fitted values, if <code>fitted</code> was previously set to TRUE. </p>
</td></tr>    
<tr><td><code>offset</code></td>
<td>
<p>the model offset.</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>others values necessary to update the estimation.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>All the above functions make an object of class 'speedlm'.</p>


<h3>Author(s)</h3>

<p> Marco Enea, with contribution from Ronen Meiri.</p>


<h3>References</h3>

<p>Enea, M. (2009) Fitting Linear Models and Generalized Linear Models With Large Data Sets in R.
In <em>book of short papers, conference on &ldquo;Statistical Methods for the analysis of large data-sets&rdquo;,
Italian Statistical Society</em>, Chieti-Pescara, 23-25 September 2009, 411-414. ISBN:978-88-6129-425-7<br />
</p>
<p>Klotz, J.H. (1995) Updating Simple Linear Regression. <em>Statistica Sinica</em>, <b>5</b>, 399-403.<br />
</p>
<p>Bates, D. (2009) Comparing Least Square Calculations. Technical report.<br />
</p>
<p>Lumley, T. (2009) biglm: bounded memory linear and generalized linear models.<em> R package version 0.7</em>
<a href="https://CRAN.R-project.org/package=biglm">https://CRAN.R-project.org/package=biglm</a>.
</p>


<h3>See Also</h3>

 <p><a href="#topic+summary.speedlm">summary.speedlm</a>,<a href="#topic+speedglm">speedglm</a>, <a href="stats.html#topic+lm">lm</a>, and <a href="biglm.html#topic+biglm">biglm</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(data1)
da &lt;- data1
do1 &lt;- da[1:30,]
do2 &lt;- da[31:70,]
do3 &lt;- da[71:100,]

m1 &lt;- speedlm(y ~ factor(fat1) + x1 + x2, data = do1)
m1 &lt;- update(m1, data = do2)
m1 &lt;- update(m1, data = do3)

m2 &lt;- lm(y ~ factor(fat1) + x1 + x2, data = data1)
summary(m1)
summary(m2)



# as before but recursively
make.data &lt;- function(filename, chunksize,...){       
    conn &lt;- NULL
    function(reset=FALSE, header=TRUE){
      if(reset){
        if(!is.null(conn)) close(conn)
         conn&lt;&lt;-file(filename,open="r") 
      } else{
        rval &lt;- read.table(conn, nrows=chunksize,header=header,...)
        if (nrow(rval)==0) {
          close(conn)
          conn&lt;&lt;-NULL
          rval&lt;-NULL
        }
        return(rval)
      }
    }
}

tmp_da&lt;-tempfile("da",fileext=".txt")
write.table(da,tmp_da,col.names=TRUE,row.names=FALSE,quote=FALSE) 

dat &lt;- make.data(tmp_da,chunksize=30,col.names=c("y","fat1","x1", "x2"))
dat(reset=TRUE) 
da2 &lt;- dat(reset=FALSE)
  
# the first model runs on the first 30 rows.
m3 &lt;- speedlm(y ~ factor(fat1) + x1 + x2, data=da2)

# the last three models run on the subsequent 30, 30 and 10 rows, respectively
for (i in 1:3){
  da2 &lt;- dat(reset=FALSE, header=FALSE)
  m3 &lt;- update(m3, data=da2, add=TRUE)
}  
all.equal(coef(m1),coef(m3))  

</code></pre>

<hr>
<h2 id='summary.speedglm'>Methods to summarize Generalized Linear Models fits</h2><span id='topic+summary.speedglm'></span><span id='topic+coef.speedglm'></span><span id='topic+vcov.speedglm'></span><span id='topic+logLik.speedglm'></span><span id='topic+AIC.speedglm'></span>

<h3>Description</h3>

<p><code>summary</code> method for the class 'speedglm'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>
## S3 method for class 'speedglm'
summary(object,correlation=FALSE,...)
## S3 method for class 'speedglm'
coef(object,...)
## S3 method for class 'speedglm'
vcov(object,...)
## S3 method for class 'speedglm'
logLik(object,...)
## S3 method for class 'speedglm'
AIC(object,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.speedglm_+3A_object">object</code></td>
<td>
<p>an object of class 'speedglm'.</p>
</td></tr>
<tr><td><code id="summary.speedglm_+3A_correlation">correlation</code></td>
<td>
<p>logical. Do you want to print the correlation matrix? By default it is false.</p>
</td></tr>
<tr><td><code id="summary.speedglm_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>coefficients</code></td>
<td>
<p>the matrix of coefficients, standard errors, z-statistics and two-side p-values.</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>the component from object.</p>
</td></tr>
<tr><td><code>df.null</code></td>
<td>
<p>the component from object.</p>
</td></tr>
<tr><td><code>null.deviance</code></td>
<td>
<p>the component from object.</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>the component from object.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>the component from object.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the component from object.</p>
</td></tr>
<tr><td><code>AIC</code></td>
<td>
<p>the Akaike Information Criterion.</p>
</td></tr>
<tr><td><code>RSS</code></td>
<td>
<p>Residuals sums of squares.</p>
</td></tr>
<tr><td><code>correlation</code></td>
<td>
<p>(only if <code>correlation</code> is true.) The correlations of the estimated coefficients.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>the log-likelihood value.</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>the component from object.</p>
</td></tr>
<tr><td><code>dispersion</code></td>
<td>
<p>the estimated dispersion parameter of the fitted model.</p>
</td></tr>
<tr><td><code>convergence</code></td>
<td>
<p>the component from object.</p>
</td></tr>    
<tr><td><code>iter</code></td>
<td>
<p>the component from object.</p>
</td></tr>
<tr><td><code>tol</code></td>
<td>
<p>the component from object.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Marco ENEA </p>


<h3>See Also</h3>

 <p><a href="#topic+speedglm">speedglm</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(data1)
mod &lt;- speedglm(y~x1+x2+factor(fat1), data=data1, family=Gamma(log))
summary(mod)
</code></pre>

<hr>
<h2 id='summary.speedlm'>Methods to summarize Linear Models fits</h2><span id='topic+summary.speedlm'></span><span id='topic+coef.speedlm'></span><span id='topic+vcov.speedlm'></span><span id='topic+logLik.speedlm'></span><span id='topic+AIC.speedlm'></span>

<h3>Description</h3>

<p><code>summary</code> method for class 'speedlm'.   
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'speedlm'
summary(object, correlation = FALSE,...)
## S3 method for class 'speedlm'
coef(object,...)
## S3 method for class 'speedlm'
vcov(object,...)
## S3 method for class 'speedlm'
logLik(object,...)
## S3 method for class 'speedlm'
AIC(object,...,k = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.speedlm_+3A_object">object</code></td>
<td>
<p>an object of class 'speedlm'.</p>
</td></tr>
<tr><td><code id="summary.speedlm_+3A_correlation">correlation</code></td>
<td>
<p>logical. Do you want to print the correlation matrix? By default it is false.</p>
</td></tr>
<tr><td><code id="summary.speedlm_+3A_k">k</code></td>
<td>
<p>numeric, the penalty per parameter to be used; the default k = 2 is the classical AIC.</p>
</td></tr>
<tr><td><code id="summary.speedlm_+3A_...">...</code></td>
<td>
<p>further optional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>coefficients</code></td>
<td>
<p>the matrix of coefficients, standard errors, t-statistics and two-side p-values.</p>
</td></tr>
<tr><td><code>rdf</code></td>
<td>
<p>degrees of freedom of the fitted model. It is a component from <code>object</code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the component from <code>object</code>.</p>
</td></tr>
<tr><td><code>r.squared</code></td>
<td>
<p>R^2, the fraction of variance explained by the model.</p>
</td></tr>
<tr><td><code>adj.r.squared</code></td>
<td>
<p>the &quot;adjusted&quot; R^2 statistic, penalizing for higher p.</p>
</td></tr>
<tr><td><code>fstatistic</code></td>
<td>
<p>(for models including non-intercept terms) a 3-vector with the value of 
the F-statistic with its numerator and denominator degrees of freedom.</p>
</td></tr>
<tr><td><code>f.pvalue</code></td>
<td>
<p>p-value of the F-statistic.</p>
</td></tr>
<tr><td><code>RSS</code></td>
<td>
<p>Residual sum of squares.</p>
</td></tr>  
<tr><td><code>var.res</code></td>
<td>
<p>estimated variance of residuals.</p>
</td></tr>  
<tr><td><code>rank</code></td>
<td>
<p>the component from <code>object</code>.</p>
</td></tr>
<tr><td><code>correlation</code></td>
<td>
<p>(only if <code>correlation</code> is true) the correlations of the estimated parameters.</p>
</td></tr>
<tr><td><code>...</code></td>
<td>
<p>the results from the functions <code>logLik</code>, <code>AIC</code> and <code>vcov</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p> Marco ENEA </p>


<h3>See Also</h3>

 <p><a href="#topic+speedlm">speedlm</a> </p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(data1)
m &lt;- speedlm(y ~ x1 + x2 + factor(fat1), data1)
summary(m)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
