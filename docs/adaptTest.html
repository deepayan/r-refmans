<!DOCTYPE html><html><head><title>Help for package adaptTest</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {adaptTest}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adaptTest-package'>
<p>Adaptive two-stage tests</p></a></li>
<li><a href='#a1Table'><p>Function to produce tables of alpha1</p></a></li>
<li><a href='#CEF'><p>Function to specify a conditional error function</p></a></li>
<li><a href='#getpar'><p>Function to calculate the parameter that specifies the conditional error function running through a given point</p></a></li>
<li><a href='#OrderComparisons'><p>Functions to perform simple order comparisons</p></a></li>
<li><a href='#ovP'><p>Function to compute and visualize overall p-values</p></a></li>
<li><a href='#parconv'><p>Function to convert between two different parameterizations of a family of conditional error functions</p></a></li>
<li><a href='#pathCEF'><p>Function to plot several conditional error functions running through a &quot;path&quot; of given points</p></a></li>
<li><a href='#plotBounds'><p>Function to plot the stopping bounds of an adaptive two-stage test</p></a></li>
<li><a href='#plotCEF'><p>Function to plot a conditional error function</p></a></li>
<li><a href='#tsT'><p>Function to implement an adaptive two-stage test</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Adaptive Two-Stage Tests</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-10-05</td>
</tr>
<tr>
<td>Description:</td>
<td>The functions defined in this program serve for implementing adaptive
    two-stage tests. Currently, four tests are included: Bauer and Koehne (1994),
    Lehmacher and Wassmer (1999), Vandemeulebroecke (2006), and the horizontal conditional
    error function. User-defined tests can also be implemented. Reference: Vandemeulebroecke,
    An investigation of two-stage tests, Statistica Sinica 2006.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, lattice, stats</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-05 19:51:17 UTC; mirshar1</td>
</tr>
<tr>
<td>Author:</td>
<td>Marc Vandemeulebroecke [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Marc Vandemeulebroecke &lt;vandemem@gmx.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-06 14:20:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='adaptTest-package'>
Adaptive two-stage tests
</h2><span id='topic+adaptTest-package'></span><span id='topic+adaptTest'></span>

<h3>Description</h3>

<p>The functions defined in this program serve for implementing adaptive two-stage tests.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> adaptTest</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.2</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-10-05</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL (version 2 or later)</td>
</tr>
<tr>
 <td style="text-align: left;">
LazyLoad: </td><td style="text-align: left;"> yes</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>An adaptive two-stage test can be considered as a family of decreasing functions <code class="reqn">f[c](p_1)</code> in the unit square. Each of these functions is a conditional error function, specifying the type I error conditional on the p-value <code class="reqn">p_1</code> of the first stage. For example, <code class="reqn">f[c](p_1) = \min(1, c/p_1)</code> corresponds to Fisher's combination test (Bauer and Koehne, 1994). Based on this function family, the test can be put into practice by specifying the desired overall level <code class="reqn">\alpha</code>, stopping bounds <code class="reqn">\alpha_1 &lt;= \alpha_0</code> and a parameter <code class="reqn">\alpha_2</code>. After computing <code class="reqn">p_1</code>, the test stops with or without rejection of the null hypothesis if <code class="reqn">p_1 &lt;= \alpha_1</code> or <code class="reqn">p_1 &gt; \alpha_0</code>, respectively. Otherwise, the null hypothesis is rejected if and only if <code class="reqn">p_2 &lt;= f[c](p_1)</code> holds for the p-value <code class="reqn">p_2</code> of the second stage, where <code class="reqn">c</code> is such that the local level of this latter test is <code class="reqn">\alpha_2</code> (e.g., <code class="reqn">c = c(\alpha_2) = \exp(-\chi^2_{4,\alpha_2}/2)</code> for Fisher's combination test).
</p>
<p>This package provides functions for handling conditional error functions, performing calculations among the different parameters (<code class="reqn">\alpha</code>, <code class="reqn">\alpha_0</code>, <code class="reqn">\alpha_1</code>, <code class="reqn">\alpha_2</code> and <code class="reqn">c</code>) and computing overall p-values, in addition to graphical visualization routines. Currently, four predefined tests are included: Bauer and Koehne (1994), Lehmacher and Wassmer (1999), Vandemeulebroecke (2006), and the horizontal conditional error function. User-defined tests can also be implemented.
</p>
<p>This package contains the following functions:
</p>

<ul>
<li><p> Key functions are <code><a href="#topic+CEF">CEF</a></code>, <code><a href="#topic+plotCEF">plotCEF</a></code>, <code><a href="#topic+tsT">tsT</a></code>, <code><a href="#topic+ovP">ovP</a></code>.
</p>
</li>
<li><p> Further functions are <code><a href="#topic+a1Table">a1Table</a></code>, <code><a href="#topic+getpar">getpar</a></code>, <code><a href="#topic+parconv">parconv</a></code>, <code><a href="#topic+pathCEF">pathCEF</a></code>, <code><a href="#topic+plotBounds">plotBounds</a></code>, <code><a href="#topic+eq">eq</a></code>, <code><a href="#topic+ne">ne</a></code>, <code><a href="#topic+ge">ge</a></code>, <code><a href="#topic+gt">gt</a></code>, <code><a href="#topic+le">le</a></code>, <code><a href="#topic+lt">lt</a></code>.
</p>
</li></ul>

<p>The functions <code><a href="#topic+a1Table">a1Table</a></code>, <code><a href="#topic+getpar">getpar</a></code>, <code><a href="#topic+parconv">parconv</a></code> and <code><a href="#topic+tsT">tsT</a></code> can handle the four predefined tests mentioned above. The functions <code><a href="#topic+CEF">CEF</a></code>, <code><a href="#topic+plotCEF">plotCEF</a></code>, <code><a href="#topic+pathCEF">pathCEF</a></code> and <code><a href="#topic+ovP">ovP</a></code> can also handle these, and user-defined tests in addition. The functions <code><a href="#topic+plotBounds">plotBounds</a></code>, <code><a href="#topic+eq">eq</a></code>, <code><a href="#topic+ne">ne</a></code>, <code><a href="#topic+ge">ge</a></code>, <code><a href="#topic+gt">gt</a></code>, <code><a href="#topic+le">le</a></code> and <code><a href="#topic+lt">lt</a></code> do not directly handle tests.
</p>


<h3>Note</h3>

<p>Note that a family of conditional error functions can be parameterized in two alternative ways: more &quot;traditionally&quot; by some parameter <code class="reqn">c</code> that, in turn, depends on the local level <code class="reqn">\alpha_2</code> of the test after the second stage, or - perhaps more conveniently - by <code class="reqn">\alpha_2</code> itself.
</p>
<p>In this implementation, early stopping bounds are <em>not</em> part of the conditional error function. Rather, they are specified separately and &quot;imposed&quot; on it.
</p>
<p>I want to thank Niklas Hack for technical support.
</p>


<h3>Author(s)</h3>

<p>Marc Vandemeulebroecke
</p>
<p>Maintainer: Marc Vandemeulebroecke &lt;vandemem(at)gmx.de&gt;
</p>


<h3>References</h3>

<p>Bauer, P., Koehne, K. (1994). Evaluation of experiments with adaptive interim analyses. <em>Biometrics</em> 50, 1029-1041.
</p>
<p>Brannath, W., Posch, M., Bauer, P. (2002). Recursive combination tests. <em>J. Amer. Statist. Assoc.</em> 97, 236-244.
</p>
<p>Lehmacher, W., Wassmer, G. (1999). Adaptive sample size calculations in group sequential trials. <em>Biometrics</em> 55, 1286-1290.
</p>
<p>Vandemeulebroecke, M. (2006). An investigation of two-stage tests. <em>Statistica Sinica</em> 16, 933-951.
</p>
<p>Vandemeulebroecke, M. (2006). <em>A general approach to two-stage tests.</em> Doctoral thesis, Otto-von-Guericke-Universitaet Magdeburg, <code>http://www.dissertation.de</code>.
</p>
<p>Vandemeulebroecke, M. (2008). Group sequential and adaptive designs - a review of basic concepts and points of discussion. <em>Biometrical Journal</em> 50, 541-557.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CEF">CEF</a></code>, <code><a href="#topic+tsT">tsT</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from Bauer and Koehne (1994)
alpha  &lt;- 0.1
alpha2 &lt;- 0.1
alpha0 &lt;- 0.5
alpha1 &lt;- tsT(typ="b", a=alpha, a0=alpha0, a2=alpha2)
plotCEF(typ="b", a2=alpha2, add=FALSE)
plotBounds(alpha1, alpha0)
CEF(typ="b", a2=alpha2)
</code></pre>

<hr>
<h2 id='a1Table'>Function to produce tables of alpha1</h2><span id='topic+a1Table'></span>

<h3>Description</h3>

<p>This function produces tables of <code class="reqn">\alpha_1</code> for a grid of different choices of <code class="reqn">\alpha</code> and <code class="reqn">\alpha_0</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>a1Table(typ, a = NA, a0 = NA, Pocock = FALSE, round = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="a1Table_+3A_typ">typ</code></td>
<td>
<p>type of test: <code>"b"</code> for Bauer and Koehne (1994), <code>"l"</code> for Lehmacher and Wassmer (1999), <code>"v"</code> for Vandemeulebroecke (2006) and <code>"h"</code> for the horizontal conditional error function</p>
</td></tr>
<tr><td><code id="a1Table_+3A_a">a</code></td>
<td>
<p><em>vector</em> of different choices of <code class="reqn">\alpha</code>, the overall test level</p>
</td></tr>
<tr><td><code id="a1Table_+3A_a0">a0</code></td>
<td>
<p><em>vector</em> of different choices of <code class="reqn">\alpha_0</code>, the futility stopping bound</p>
</td></tr>
<tr><td><code id="a1Table_+3A_pocock">Pocock</code></td>
<td>
<p>logical determining whether the &quot;Pocock-type&quot; should be calculated or the full level should be applied after the second stage (see details; default: full level after second stage).</p>
</td></tr>
<tr><td><code id="a1Table_+3A_round">round</code></td>
<td>
<p>rounding specification, logical or integer (see details; default: no rounding)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function produces tables of <code class="reqn">\alpha_1</code> on a grid spanned by the <em>vectors</em> <code>a</code> and <code>a0</code> (i.e., <code class="reqn">\alpha</code> and <code class="reqn">\alpha_0</code>). This is done either for the &quot;Pocock-type&quot; (i.e., under the condition <code class="reqn">\alpha_1 = \alpha_2</code>: <code>Pocock = TRUE</code>) or using the full level after the second stage (<code class="reqn">\alpha = \alpha_2</code>: <code>Pocock = FALSE</code> (the default)). The function <code>a1Table</code> can be a convenient shortcut for a repeated use of <code><a href="#topic+tsT">tsT</a></code>; see this latter function for further details.
</p>
<p>The result is rounded to <code>round</code> digits after the comma (<code>round = TRUE</code> rounds to 1 digit; <code>round = FALSE</code> and <code>round = 0</code> prevent rounding).
</p>


<h3>Value</h3>

<p><code>a1Table</code> returns a matrix of <code class="reqn">\alpha_1</code> values, with the corresponding <code class="reqn">\alpha</code> and <code class="reqn">\alpha_0</code> values being displayed as dimnames.
</p>


<h3>Author(s)</h3>

<p>Marc Vandemeulebroecke</p>


<h3>References</h3>

<p>Bauer, P., Koehne, K. (1994). Evaluation of experiments with adaptive interim analyses. <em>Biometrics</em> 50, 1029-1041.
</p>
<p>Lehmacher, W., Wassmer, G. (1999). Adaptive sample size calculations in group sequential trials. <em>Biometrics</em> 55, 1286-1290.
</p>
<p>Vandemeulebroecke, M. (2006). An investigation of two-stage tests. <em>Statistica Sinica</em> 16, 933-951.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+adaptTest">adaptTest</a></code> package description, <code><a href="#topic+tsT">tsT</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Produce basic reference tables for the test by Vandemeulebroecke (2006)
alpha  &lt;- c(0.1, 0.05, 0.025, 0.01)
alpha0 &lt;- 1:10/10
a1Table(typ="v", a=alpha, a0=alpha0, Pocock=FALSE)
a1Table(typ="v", a=alpha, a0=alpha0, Pocock=TRUE)
</code></pre>

<hr>
<h2 id='CEF'>Function to specify a conditional error function</h2><span id='topic+CEF'></span>

<h3>Description</h3>

<p>This function returns a conditional error function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CEF(typ = NA, fun = NA, dis = NA, a2 = NA, c = NA, p1 = NA, p2 = p1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CEF_+3A_typ">typ</code></td>
<td>
<p>type of test: <code>"b"</code> for Bauer and Koehne (1994), <code>"l"</code> for Lehmacher and Wassmer (1999), <code>"v"</code> for Vandemeulebroecke (2006) and <code>"h"</code> for the horizontal conditional error function</p>
</td></tr>
<tr><td><code id="CEF_+3A_c">c</code></td>
<td>
<p>the parameter <code class="reqn">c</code></p>
</td></tr>
<tr><td><code id="CEF_+3A_a2">a2</code></td>
<td>
<p><code class="reqn">\alpha_2</code>, the local level of the test after the second stage</p>
</td></tr>
<tr><td><code id="CEF_+3A_p1">p1</code></td>
<td>
<p>the p-value <code class="reqn">p_1</code> of the test after the first stage</p>
</td></tr>
<tr><td><code id="CEF_+3A_p2">p2</code></td>
<td>
<p>the p-value <code class="reqn">p_2</code> of the test after the second stage, defaults to <code>p1</code></p>
</td></tr>
<tr><td><code id="CEF_+3A_fun">fun</code></td>
<td>
<p>a conditional error function</p>
</td></tr>
<tr><td><code id="CEF_+3A_dis">dis</code></td>
<td>
<p>a distortion method for a supplied conditional error function (see details): <code>"pl"</code> for power lines, <code>"vt"</code> for vertical translation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two alternative ways of specifying the desired conditional error function:
</p>

<ul>
<li><p> through a type <code>typ</code>, and either a parameter (either <code>a2</code> or <code>c</code>) or a point <code>(p1,p2)</code>, OR
</p>
</li>
<li><p> through an initial conditional error function <code>fun</code>, and possibly a distortion method <code>dis</code> together with either the parameter <code>a2</code> or a point <code>(p1,p2)</code>
</p>
</li></ul>

<p>Most people will only need the first of these two ways; the second leads to user-defined non-standard tests.
</p>
<p>If <code>typ</code> is specified, a parameter <code>a2</code> or <code>c</code> or the point <code>(p1,p2)</code> must be provided. In this case, <code>CEF</code> returns the conditional error function of the chosen type with the given parameter or running through the given point.
</p>
<p>If <code>typ</code> is not specified, a conditional error function (i.e., a nonincreasing function defined on [0,1] with values in [0,1]) <code>fun</code> must be provided. If no distortion method is selected (<code>dis = NA</code>), <code>fun</code> is returned unchanged. Otherwise, the function is distorted using the chosen distortion method, either to match a desired second stage level <code>a2</code> or to run through a specified point <code>(p1,p2)</code> (one of which must be provided). Currently, two distortion methods are implemented:
</p>

<ul>
<li> <p><code>dis = "pl"</code>, Power lines: For an initial function <code class="reqn">f</code>, define <code class="reqn">f[r](x) = (f(x^r))^(1/r)</code>, r&gt;0. Note that if <code class="reqn">f</code> is a conditional error function of type <code>"b"</code> (Bauer and Koehne, 1994), so is <code class="reqn">f[r]</code>.
</p>
</li>
<li> <p><code>dis = "pl"</code>, Vertical translation: The initial function is shifted vertically.
</p>
</li></ul>

<p>See <code><a href="#topic+parconv">parconv</a></code> for more information on the two alternative parameterizations by <code class="reqn">\alpha_2</code> and <code class="reqn">c</code>.
</p>


<h3>Value</h3>

<p>These functions return a conditional error <em>function</em> (see details).
</p>


<h3>Note</h3>

<p>Provide either <code>typ</code> or <code>fun</code>, not both! If <code>typ</code> is provided, then also specify <code>a2</code>, <code>c</code>, or <code>p1</code> (and possibly <code>p2</code>). If <code>fun</code> is provided, then also specify <code>dis</code> and <code>a2</code>, or <code>dis</code> and <code>p1</code> (and possibly <code>p2</code>), or none of these.
</p>
<p>Warning: Values of <code>a2</code> close to 0 or 1 may not work for <code>dis = "pl"</code>. 
</p>
<p>Note that in this implementation of adaptive two-stage tests, early stopping bounds are <em>not</em> part of the conditional error function. Rather, they are specified separately (see also <code><a href="#topic+tsT">tsT</a></code>).
</p>


<h3>Author(s)</h3>

<p>Marc Vandemeulebroecke</p>


<h3>References</h3>

<p>Bauer, P., Koehne, K. (1994). Evaluation of experiments with adaptive interim analyses. <em>Biometrics</em> 50, 1029-1041.
</p>
<p>Lehmacher, W., Wassmer, G. (1999). Adaptive sample size calculations in group sequential trials. <em>Biometrics</em> 55, 1286-1290.
</p>
<p>Vandemeulebroecke, M. (2006). An investigation of two-stage tests. <em>Statistica Sinica</em> 16, 933-951.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+adaptTest">adaptTest</a></code> package description, <code><a href="#topic+parconv">parconv</a></code>, <code><a href="#topic+plotCEF">plotCEF</a></code>, <code><a href="#topic+tsT">tsT</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Plot two conditional error functions of the Lehmacher-Wassmer (1999) type:
## one to the local level alpha2=0.1, and one that runs through (p1,p2)=(0.3,0.7)
foo1 &lt;- CEF(typ="l", a2=0.1)
foo2 &lt;- CEF(typ="l", p1=0.3, p2=0.7)
plot(foo1, xlim=0:1)
plot(foo2, add=TRUE)

## A different way of doing the same
plotCEF(typ="l", a2=0.1, add=FALSE)
plotCEF(typ="l", p1=0.3, p2=0.7, plt.pt=FALSE)
</code></pre>

<hr>
<h2 id='getpar'>Function to calculate the parameter that specifies the conditional error function running through a given point</h2><span id='topic+getpar'></span>

<h3>Description</h3>

<p>This function calculates the parameter that specifies the conditional error function running through a given point <code class="reqn">(p_1,p_2)</code>, based on a chosen family of conditional error functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getpar(typ, p1 = NA, p2 = p1, c = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getpar_+3A_typ">typ</code></td>
<td>
<p>type of test: <code>"b"</code> for Bauer and Koehne (1994), <code>"l"</code> for Lehmacher and Wassmer (1999), <code>"v"</code> for Vandemeulebroecke (2006) and <code>"h"</code> for the horizontal conditional error function</p>
</td></tr>
<tr><td><code id="getpar_+3A_p1">p1</code></td>
<td>
<p>the p-value <code class="reqn">p_1</code> of the test after the first stage</p>
</td></tr>
<tr><td><code id="getpar_+3A_p2">p2</code></td>
<td>
<p>the p-value <code class="reqn">p_2</code> of the test after the second stage, defaults to <code>p1</code></p>
</td></tr>
<tr><td><code id="getpar_+3A_c">c</code></td>
<td>
<p>logical determining whether the parameter <code class="reqn">\alpha_2</code> or the parameter <code class="reqn">c</code> is returned (<code class="reqn">\alpha_2</code> is the default).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="#topic+parconv">parconv</a></code> for more information on the two alternative parameterizations by <code class="reqn">\alpha_2</code> and <code class="reqn">c</code>.
</p>


<h3>Value</h3>

<p><code>getpar</code> returns the parameter (either <code class="reqn">\alpha_2</code> or <code class="reqn">c</code>, depending on the chosen parameterization) that specifies the conditional error function running through <code class="reqn">(p_1,p_2)</code>.
</p>


<h3>Author(s)</h3>

<p>Marc Vandemeulebroecke</p>


<h3>References</h3>

<p>Bauer, P., Koehne, K. (1994). Evaluation of experiments with adaptive interim analyses. <em>Biometrics</em> 50, 1029-1041.
</p>
<p>Lehmacher, W., Wassmer, G. (1999). Adaptive sample size calculations in group sequential trials. <em>Biometrics</em> 55, 1286-1290.
</p>
<p>Vandemeulebroecke, M. (2006). An investigation of two-stage tests. <em>Statistica Sinica</em> 16, 933-951.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+adaptTest">adaptTest</a></code> package description, <code><a href="#topic+parconv">parconv</a></code>, <code><a href="#topic+CEF">CEF</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Plot the conditional error function of the Lehmacher-Wassmer (1999)
##  type that runs through (p1,p2)=(0.3,0.7)
alpha2 &lt;- getpar(typ="l", p1=0.3, p2=0.7)
plotCEF(typ="l", a2=alpha2, add=FALSE)

## Other ways of doing the same as above
plotCEF(typ="l", p1=0.3, p2=0.7, add=FALSE)
plot(CEF(typ="l", p1=0.3, p2=0.7), xlim=0:1)
</code></pre>

<hr>
<h2 id='OrderComparisons'>Functions to perform simple order comparisons</h2><span id='topic+OrderComparisons'></span><span id='topic+eq'></span><span id='topic+ne'></span><span id='topic+ge'></span><span id='topic+gt'></span><span id='topic+le'></span><span id='topic+lt'></span>

<h3>Description</h3>

<p>These functions perform simple order comparisons for two arguments, dealing with the machine inaccuracy for floating point arithmetics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eq(x, y, tol = .Machine$double.eps^0.5)
ne(x, y, tol = .Machine$double.eps^0.5)
ge(x, y, tol = .Machine$double.eps^0.5)
gt(x, y, tol = .Machine$double.eps^0.5)
le(x, y, tol = .Machine$double.eps^0.5)
lt(x, y, tol = .Machine$double.eps^0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OrderComparisons_+3A_x">x</code></td>
<td>
<p>first argument (must be a numeric scalar)</p>
</td></tr>
<tr><td><code id="OrderComparisons_+3A_y">y</code></td>
<td>
<p>second argument (must be a numeric scalar)</p>
</td></tr>
<tr><td><code id="OrderComparisons_+3A_tol">tol</code></td>
<td>
<p>comparison tolerance; differences smaller than <code>tol</code> are not considered.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When comparing two numeric scalars (e.g., for equality), machine inaccuracy can be the source of obviously erroneous results. These functions perform binary order comparisons that are tolerant towards machine inaccuracy, as an alternative to the standard comparators <code>==</code>, <code>!=</code>, <code>&gt;=</code>, <code>&gt;</code>, <code>&lt;=</code> and <code>&lt;</code>.
</p>


<h3>Value</h3>

<p>The functions return a logical <code>TRUE</code> if their condition holds, and a logical <code>FALSE</code> otherwise.
</p>
<p><code>eq(x, y)</code> checks whether <code>x</code> is equal to <code>y</code>
</p>
<p><code>ne(x, y)</code> checks whether <code>x</code> is not equal to <code>y</code>
</p>
<p><code>ge(x, y)</code> checks whether <code>x</code> is greater than or equal to <code>y</code>
</p>
<p><code>gt(x, y)</code> checks whether <code>x</code> is greater than <code>y</code>
</p>
<p><code>le(x, y)</code> checks whether <code>x</code> is less than or equal to <code>y</code>
</p>
<p><code>lt(x, y)</code> checks whether <code>x</code> is less than <code>y</code>
</p>


<h3>Note</h3>

<p>These functions cannot be used in a vectorized fashion.
</p>


<h3>Author(s)</h3>

<p>Marc Vandemeulebroecke</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+identical">identical</a></code>, <code><a href="Matrix.html#topic+all.equal">all.equal</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  v &lt;- seq(0.7, 0.8, by=0.1)
  v[2]==0.8
  eq(v[2], 0.8)
</code></pre>

<hr>
<h2 id='ovP'>Function to compute and visualize overall p-values</h2><span id='topic+ovP'></span>

<h3>Description</h3>

<p>This function computes and plots overall p-values for adaptive two-stage tests.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ovP(typ = NA, fun = NA, dis = NA, p1 = 1:49/50, p2 = p1,
    a1 = 0, a0 = 1, grid = FALSE, plt = FALSE,
    invisible = FALSE, wire = FALSE, round = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ovP_+3A_typ">typ</code></td>
<td>
<p>type of test: <code>"b"</code> for Bauer and Koehne (1994), <code>"l"</code> for Lehmacher and Wassmer (1999), <code>"v"</code> for Vandemeulebroecke (2006) and <code>"h"</code> for the horizontal conditional error function</p>
</td></tr>
<tr><td><code id="ovP_+3A_fun">fun</code></td>
<td>
<p>a conditional error function</p>
</td></tr>
<tr><td><code id="ovP_+3A_dis">dis</code></td>
<td>
<p>a distortion method for a supplied conditional error function (see details): <code>"pl"</code> for power lines, <code>"vt"</code> for vertical translation</p>
</td></tr>
<tr><td><code id="ovP_+3A_p1">p1</code></td>
<td>
<p>the p-value <code class="reqn">p_1</code> of the test after the first stage, or a vector of such p-values</p>
</td></tr>
<tr><td><code id="ovP_+3A_p2">p2</code></td>
<td>
<p>the p-value <code class="reqn">p_2</code> of the test after the second stage, or a vector of such p-values; defaults to <code>p1</code></p>
</td></tr>
<tr><td><code id="ovP_+3A_a1">a1</code></td>
<td>
<p><code class="reqn">\alpha_1</code>, the efficacy stopping bound and local level of the test after the first stage (default: no stopping for efficacy)</p>
</td></tr>
<tr><td><code id="ovP_+3A_a0">a0</code></td>
<td>
<p><code class="reqn">\alpha_0</code>, the futility stopping bound (default: no stopping for futility)</p>
</td></tr>
<tr><td><code id="ovP_+3A_grid">grid</code></td>
<td>
<p>logical determining whether a grid should be spanned by <code>p1</code> and <code>p2</code> (default: no grid is spanned)</p>
</td></tr>
<tr><td><code id="ovP_+3A_plt">plt</code></td>
<td>
<p>logical determining whether the overall p-values should be plotted or not (default: not)</p>
</td></tr>
<tr><td><code id="ovP_+3A_invisible">invisible</code></td>
<td>
<p>logical determining whether the printing of the overall p-values should be suppressed or not (default: not)</p>
</td></tr>
<tr><td><code id="ovP_+3A_wire">wire</code></td>
<td>
<p>logical determining whether the overall p-values should be plotted in wireframe-style or in cloud-style (default: cloud-style)</p>
</td></tr>
<tr><td><code id="ovP_+3A_round">round</code></td>
<td>
<p>rounding specification, logical or integer (see details; default: no rounding)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The overall p-value for an adaptive two-stage test is computed as <code class="reqn">p_1</code> if <code class="reqn">p_1 &lt;= \alpha_1</code> or <code class="reqn">p_1 &gt; \alpha_0</code>, and as </p>
<p style="text-align: center;"><code class="reqn">\alpha_1 + \int_{\alpha_1}^{\alpha_0} cef_{(p_1,p_2)}(x) d x</code>
</p>
<p> otherwise, where <code class="reqn">cef_{(p_1,p_2)}</code> is the conditional error function (of a specified family) running through the observed pair of p-values <code>(p1,p2)</code>.
</p>
<p>There are two alternative ways of specifying the family of conditional error functions (i.e., the test): through a type <code>typ</code>, or through an initial conditional error function <code>fun</code> and a distortion method <code>dis</code>; see <code><a href="#topic+CEF">CEF</a></code> for details.
</p>
<p>If p1 and p2 are of length 1, a single overall p-value is computed (and not plotted). Otherwise, the behavior of <code>ovP</code> depends on <code>grid</code>:
</p>

<ul>
<li><p> If <code>grid = FALSE</code>, overall p-values are computed (and not plotted) for the elementwise pairs of <code>p1</code> and <code>p2</code>. Here, <code>p1</code> and <code>p2</code> must be of the same length. 
</p>
</li>
<li><p> If <code>grid = TRUE</code>, a grid is spanned by <code>p1</code> and <code>p2</code>, and p-values are computed (and possibly plotted) over this grid. Here, <code>p1</code> and <code>p2</code> may be of different length. Plotting is triggered by <code>plt = TRUE</code>, and the style of the plot (wireframe or cloud) is determined by <code>wire</code>. <code>invisible = TRUE</code> suppresses the printing of the p-values.
</p>
</li></ul>

<p>The p-values are rounded to <code>round</code> digits after the comma (<code>round = TRUE</code> rounds to 1 digit; <code>round = FALSE</code> and <code>round = 0</code> prevent rounding). The plot always shows unrounded values.
</p>


<h3>Value</h3>

<p>A p-value, a vector of p-values or a matrix of p-values.
</p>


<h3>Note</h3>

<p>Provide either <code>typ</code> or <code>fun</code>, not both! If <code>fun</code> is provided, then also specify <code>dis</code>.
</p>


<h3>Author(s)</h3>

<p>Marc Vandemeulebroecke</p>


<h3>References</h3>

<p>Bauer, P., Koehne, K. (1994). Evaluation of experiments with adaptive interim analyses. <em>Biometrics</em> 50, 1029-1041.
</p>
<p>Brannath, W., Posch, M., Bauer, P. (2002). Recursive combination tests. <em>J. Amer. Statist. Assoc.</em> 97, 236-244.
</p>
<p>Lehmacher, W., Wassmer, G. (1999). Adaptive sample size calculations in group sequential trials. <em>Biometrics</em> 55, 1286-1290.
</p>
<p>Vandemeulebroecke, M. (2006). An investigation of two-stage tests. <em>Statistica Sinica</em> 16, 933-951.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+adaptTest">adaptTest</a></code> package description, <code><a href="#topic+CEF">CEF</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Visualize a Lehmacher Wassmer (1999) test to the overall level 0.1
## and compute and visualize the overall p-value for an observed (p1,p2)=(0.3,0.7)
alpha  &lt;- .1
alpha0 &lt;- .5
alpha1 &lt;- .05
plotBounds(a1=alpha1, a0=alpha0, add=FALSE)
plotCEF(typ="l", a2=tsT(typ="l", a=alpha, a0=alpha0, a1=alpha1))
plotCEF(typ="l", p1=.3, p2=.7)
ovP(typ="l", p1=.3, p2=.7, a1=alpha1, a0=alpha0)
# The overall p-value is the area left of alpha1, plus the area below the 
# conditional error function running though (0.3,0.7) between alpha1 and alpha0.

## Investigate the p-values of the Lehmacher Wassmer (1999) test from above
ovP(typ="l", a1=alpha1, a0=alpha0, grid=TRUE, p1=1:9/10, round=3)
ovP(typ="l", a1=alpha1, a0=alpha0, grid=TRUE, plt=TRUE, invisible=TRUE, wire=TRUE)
</code></pre>

<hr>
<h2 id='parconv'>Function to convert between two different parameterizations of a family of conditional error functions</h2><span id='topic+parconv'></span>

<h3>Description</h3>

<p>This function converts between two different parameterizations of a family of conditional error functions: a (more &lsquo;traditional&rsquo;) parameter <code class="reqn">c</code>, and a (more convenient) parameter <code class="reqn">\alpha_2</code> specifying the local level of the test after the second stage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parconv(typ, a2 = NA, c = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parconv_+3A_typ">typ</code></td>
<td>
<p>type of test: <code>"b"</code> for Bauer and Koehne (1994), <code>"l"</code> for Lehmacher and Wassmer (1999), <code>"v"</code> for Vandemeulebroecke (2006) and <code>"h"</code> for the horizontal conditional error function</p>
</td></tr>
<tr><td><code id="parconv_+3A_a2">a2</code></td>
<td>
<p><code class="reqn">\alpha_2</code>, the local level of the test after the second stage (see details)</p>
</td></tr>
<tr><td><code id="parconv_+3A_c">c</code></td>
<td>
<p>the parameter <code class="reqn">c</code> (see details)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Traditionally, a family of conditional error functions is often parameterized by some parameter <code class="reqn">c</code> that, in turn, depends on the local level <code class="reqn">\alpha_2</code> of the test after the second stage. However, it can be convenient to parameterize the family directly by <code class="reqn">\alpha_2</code>. The function <code>parconv</code> converts one parameter into the other: provide one, and it returns the other.
</p>
<p>Essentially, the relation between the two parameterizations is implemented as:
</p>

<ul>
<li> <p><code class="reqn">c = \exp(-\chi^2_{4,\alpha_2}/2)</code> for Fisher's combination test (Bauer and Koehne, 1994)
</p>
</li>
<li> <p><code class="reqn">c = \Phi^{-1}(1-\alpha_2)</code> for the inverse normal method (Lehmacher and Wassmer, 1999)
</p>
</li>
<li> <p><code class="reqn">\alpha_2 = {(\Gamma(1+1/r))^2}/{\Gamma(1+2/r)}</code> for Vandemeulebroecke (2006)
</p>
</li>
<li> <p><code class="reqn">c = \alpha_2</code> for the family of horizontal conditional error functions
</p>
</li></ul>



<h3>Value</h3>

<p><code>parconv</code> returns <code class="reqn">\alpha_2</code> corresponding to the supplied <code class="reqn">c</code>, or <code class="reqn">c</code> corresponding to the supplied <code class="reqn">\alpha_2</code>.
</p>


<h3>Note</h3>

<p>Provide either <code>a2</code> or <code>c</code>, not both!
</p>
<p><code class="reqn">\alpha_2</code> is the local level of the test after the second stage, and it equals the integral under the corresponding conditional error function: </p>
<p style="text-align: center;"><code class="reqn">\alpha_2 = \int_0^1 cef_{\alpha_2}(p_1) d p_1,</code>
</p>
<p> where <code class="reqn">cef_{\alpha_2}</code> is the conditional error function (of a specified family) with parameter <code class="reqn">\alpha_2</code>.
</p>
<p>Note that in this implementation of adaptive two-stage tests, early stopping bounds are <em>not</em> part of the conditional error function. Rather, they are specified separately (see also <code><a href="#topic+tsT">tsT</a></code>).
</p>
<p><code class="reqn">\alpha_2</code> can take any value in <code class="reqn">[0,1]</code>; <code class="reqn">c</code> can take values in
</p>

<ul>
<li> <p><code class="reqn">[0,1]</code> for Fisher's combination test (Bauer and Koehne, 1994)
</p>
</li>
<li> <p><code class="reqn">(-\infty, \infty)</code> for the inverse normal method (Lehmacher and Wassmer, 1999)
</p>
</li>
<li> <p><code class="reqn">[0,\infty)</code> for Vandemeulebroecke (2006)
</p>
</li>
<li> <p><code class="reqn">[0,1]</code> for the family of horizontal conditional error functions
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Marc Vandemeulebroecke</p>


<h3>References</h3>

<p>Bauer, P., Koehne, K. (1994). Evaluation of experiments with adaptive interim analyses. <em>Biometrics</em> 50, 1029-1041.
</p>
<p>Lehmacher, W., Wassmer, G. (1999). Adaptive sample size calculations in group sequential trials. <em>Biometrics</em> 55, 1286-1290.
</p>
<p>Vandemeulebroecke, M. (2006). An investigation of two-stage tests. <em>Statistica Sinica</em> 16, 933-951.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+adaptTest">adaptTest</a></code> package description, <code><a href="#topic+getpar">getpar</a></code>, <code><a href="#topic+CEF">CEF</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Obtain the parameter c for Fisher's combination test, using
##  the local level 0.05 for the test after the second stage
parconv(typ="b", a2=0.05)
</code></pre>

<hr>
<h2 id='pathCEF'>Function to plot several conditional error functions running through a &quot;path&quot; of given points</h2><span id='topic+pathCEF'></span>

<h3>Description</h3>

<p>This function plots several conditional error functions of the same family such that each one runs through one of several given points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pathCEF(typ = NA, fun = NA, dis = NA, p1 = 1:49/50, p2 = p1,
        x = 0:200/200, plt.pt = FALSE, plt.ptann = FALSE, xlab = NA, ylab = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pathCEF_+3A_typ">typ</code></td>
<td>
<p>type of test: <code>"b"</code> for Bauer and Koehne (1994), <code>"l"</code> for Lehmacher and Wassmer (1999), <code>"v"</code> for Vandemeulebroecke (2006) and <code>"h"</code> for the horizontal conditional error function</p>
</td></tr>
<tr><td><code id="pathCEF_+3A_fun">fun</code></td>
<td>
<p>a conditional error function</p>
</td></tr>
<tr><td><code id="pathCEF_+3A_dis">dis</code></td>
<td>
<p>a distortion method for a supplied conditional error function (see details): <code>"pl"</code> for power lines, <code>"vt"</code> for vertical translation</p>
</td></tr>
<tr><td><code id="pathCEF_+3A_p1">p1</code></td>
<td>
<p>a vector (at least of length 2) of p-values <code class="reqn">p_1</code> of the test after the first stage</p>
</td></tr>
<tr><td><code id="pathCEF_+3A_p2">p2</code></td>
<td>
<p>a vector (at least of length 2) of p-values <code class="reqn">p_2</code> of the test after the second stage, defaults to <code>p1</code>; must be of same length as <code>p1</code></p>
</td></tr>
<tr><td><code id="pathCEF_+3A_x">x</code></td>
<td>
<p>vector on which the conditional error functions are plotted (should be relatively dense in [0,1])</p>
</td></tr>
<tr><td><code id="pathCEF_+3A_plt.pt">plt.pt</code></td>
<td>
<p>logical determining whether the points that the conditional error functions are made to run through should be plotted or not (default: not)</p>
</td></tr>
<tr><td><code id="pathCEF_+3A_plt.ptann">plt.ptann</code></td>
<td>
<p>logical determining whether the points that the conditional error functions are made to run through should be annotated or not (default: not)</p>
</td></tr>
<tr><td><code id="pathCEF_+3A_xlab">xlab</code></td>
<td>
<p>a label for the x axis (default: no label)</p>
</td></tr>
<tr><td><code id="pathCEF_+3A_ylab">ylab</code></td>
<td>
<p>a label for the y axis (default: no label)</p>
</td></tr>
<tr><td><code id="pathCEF_+3A_...">...</code></td>
<td>
<p>arguments to be passed on to the underlying <code>plot</code> and <code>points</code> functions (e.g., graphical parameters)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It can be instructive to plot not only one conditional error function, but to visualize a whole family. This can easily be done with <code>pathCEF</code>. The function is used in a similar way as <code><a href="#topic+plotCEF">plotCEF</a></code>, but <code>p1</code> and <code>p2</code> are now vectors (of the same length, at least of length 2). Conditional error functions are plotted that run through the specified elementwise points <code>(p1,p2)</code> (which by default lie on the main diagonal).
</p>
<p>Internally, <code>pathCEF</code> uses <code><a href="#topic+plotCEF">plotCEF</a></code> to plot the individual conditional error functions; see this latter function for further details.
</p>


<h3>Value</h3>

<p>The function <code>pathCEF</code> is invoked for its plotting effect; it returns no meaningful value.
</p>


<h3>Note</h3>

<p>Provide either <code>typ</code> or <code>fun</code>, not both! If <code>fun</code> is provided, then also specify <code>dis</code>.
</p>
<p>Unlike <code>plotCEF</code>, it is not possible with <code>pathCEF</code> to specify the conditional error functions by the parameter <code class="reqn">\alpha_2</code> or the parameter <code class="reqn">c</code>.
</p>
<p><code>plt.ptann</code> is not considered if <code>plt.pt = FALSE</code>.
</p>


<h3>Author(s)</h3>

<p>Marc Vandemeulebroecke</p>


<h3>References</h3>

<p>Bauer, P., Koehne, K. (1994). Evaluation of experiments with adaptive interim analyses. <em>Biometrics</em> 50, 1029-1041.
</p>
<p>Lehmacher, W., Wassmer, G. (1999). Adaptive sample size calculations in group sequential trials. <em>Biometrics</em> 55, 1286-1290.
</p>
<p>Vandemeulebroecke, M. (2006). An investigation of two-stage tests. <em>Statistica Sinica</em> 16, 933-951.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+adaptTest">adaptTest</a></code> package description, <code><a href="#topic+CEF">CEF</a></code>, <code><a href="#topic+plotCEF">plotCEF</a></code>, <code><a href="#topic+tsT">tsT</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Compare the tests by Bauer and Koehne (1994),
##  Lehmacher and Wassmer (1999) and Vandemeulebroecke (2006)
oldmfcol &lt;- par(mfcol=c(1,3))
pathCEF(typ="b", main="BK 94")
pathCEF(typ="l", main="LW 99")
pathCEF(typ="v", main="V 06")
par(oldmfcol)
</code></pre>

<hr>
<h2 id='plotBounds'>Function to plot the stopping bounds of an adaptive two-stage test</h2><span id='topic+plotBounds'></span>

<h3>Description</h3>

<p>This function plots the stopping bounds of an adaptive two-stage test.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotBounds(a1 = 0, a0 = 1, add = TRUE, xlab = NA, ylab = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotBounds_+3A_a1">a1</code></td>
<td>
<p><code class="reqn">\alpha_1</code>, the efficacy stopping bound and local level of the test after the first stage (default: no stopping for efficacy)</p>
</td></tr>
<tr><td><code id="plotBounds_+3A_a0">a0</code></td>
<td>
<p><code class="reqn">\alpha_0</code>, the futility stopping bound (default: no stopping for futility)</p>
</td></tr>
<tr><td><code id="plotBounds_+3A_add">add</code></td>
<td>
<p>logical determining whether the bounds should be added to an existing plot (default) or a new plot should be opened</p>
</td></tr>
<tr><td><code id="plotBounds_+3A_xlab">xlab</code></td>
<td>
<p>a label for the x axis (default: no label)</p>
</td></tr>
<tr><td><code id="plotBounds_+3A_ylab">ylab</code></td>
<td>
<p>a label for the y axis (default: no label)</p>
</td></tr>
<tr><td><code id="plotBounds_+3A_...">...</code></td>
<td>
<p>arguments to be passed on to the underlying <code>lines</code> functions (e.g., graphical parameters)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots the stopping bounds <code class="reqn">\alpha_1</code> and <code class="reqn">\alpha_0</code> of an adaptive two-stage test, either onto an existing plot or into a new plot.
</p>


<h3>Value</h3>

<p>The function <code>plotBounds</code> is invoked for its plotting effect; it returns no meaningful value.
</p>


<h3>Note</h3>

<p>Note that in this implementation of adaptive two-stage tests, early stopping bounds are <em>not</em> part of the conditional error function. Rather, they are specified separately (see also <code><a href="#topic+tsT">tsT</a></code>).
</p>


<h3>Author(s)</h3>

<p>Marc Vandemeulebroecke</p>


<h3>See Also</h3>

<p><code><a href="#topic+adaptTest">adaptTest</a></code> package description, <code><a href="#topic+plotCEF">plotCEF</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from Bauer and Koehne (1994): full level after final stage, alpha0 = 0.5
alpha  &lt;- 0.1
alpha2 &lt;- 0.1
alpha0 &lt;- 0.5
alpha1 &lt;- tsT(typ="b", a=alpha, a0=alpha0, a2=alpha2)
plotCEF(typ="b", a2=alpha2, add=FALSE)
plotBounds(alpha1, alpha0)
</code></pre>

<hr>
<h2 id='plotCEF'>Function to plot a conditional error function</h2><span id='topic+plotCEF'></span>

<h3>Description</h3>

<p>This function plots a conditional error function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCEF(typ = NA, fun = NA, dis = NA, a2 = NA, c = NA, p1 = NA, p2 = p1,
        x = 0:200/200, add = TRUE, xlim = c(0, 1), ylim = c(0, 1),
        plt.pt = TRUE, plt.ptann = TRUE, xlab = NA, ylab = NA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCEF_+3A_typ">typ</code></td>
<td>
<p>type of test: <code>"b"</code> for Bauer and Koehne (1994), <code>"l"</code> for Lehmacher and Wassmer (1999), <code>"v"</code> for Vandemeulebroecke (2006) and <code>"h"</code> for the horizontal conditional error function</p>
</td></tr>
<tr><td><code id="plotCEF_+3A_fun">fun</code></td>
<td>
<p>a conditional error function</p>
</td></tr>
<tr><td><code id="plotCEF_+3A_dis">dis</code></td>
<td>
<p>a distortion method for a supplied conditional error function (see details): <code>"pl"</code> for power lines, <code>"vt"</code> for vertical translation</p>
</td></tr>
<tr><td><code id="plotCEF_+3A_a2">a2</code></td>
<td>
<p><code class="reqn">\alpha_2</code>, the local level of the test after the second stage</p>
</td></tr>
<tr><td><code id="plotCEF_+3A_c">c</code></td>
<td>
<p>the parameter <code class="reqn">c</code></p>
</td></tr>
<tr><td><code id="plotCEF_+3A_p1">p1</code></td>
<td>
<p>the p-value <code class="reqn">p_1</code> of the test after the first stage</p>
</td></tr>
<tr><td><code id="plotCEF_+3A_p2">p2</code></td>
<td>
<p>the p-value <code class="reqn">p_2</code> of the test after the second stage, defaults to <code>p1</code></p>
</td></tr>
<tr><td><code id="plotCEF_+3A_x">x</code></td>
<td>
<p>vector on which the conditional error function is plotted (should be relatively dense in [0,1])</p>
</td></tr>
<tr><td><code id="plotCEF_+3A_add">add</code></td>
<td>
<p>logical determining whether the bounds should be added to an existing plot (default) or a new plot should be opened</p>
</td></tr>
<tr><td><code id="plotCEF_+3A_xlim">xlim</code></td>
<td>
<p>the x limits of the plot (default: <code>c(0, 1)</code>; other choices can be used to &quot;zoom in&quot;)</p>
</td></tr>
<tr><td><code id="plotCEF_+3A_ylim">ylim</code></td>
<td>
<p>the y limits of the plot (default: <code>c(0, 1)</code>; other choices can be used to &quot;zoom in&quot;)</p>
</td></tr>
<tr><td><code id="plotCEF_+3A_plt.pt">plt.pt</code></td>
<td>
<p>logical determining whether the point that the conditional error function is made to run through should be plotted or not (default: yes)</p>
</td></tr>
<tr><td><code id="plotCEF_+3A_plt.ptann">plt.ptann</code></td>
<td>
<p>logical determining whether the point that the conditional error function is made to run through should be annotated or not (default: yes)</p>
</td></tr>
<tr><td><code id="plotCEF_+3A_xlab">xlab</code></td>
<td>
<p>a label for the x axis (default: no label)</p>
</td></tr>
<tr><td><code id="plotCEF_+3A_ylab">ylab</code></td>
<td>
<p>a label for the y axis (default: no label)</p>
</td></tr>
<tr><td><code id="plotCEF_+3A_...">...</code></td>
<td>
<p>arguments to be passed on to the underlying <code>plot</code> and <code>points</code> functions (e.g., graphical parameters)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are two alternative ways of specifying the desired conditional error function:
</p>

<ul>
<li><p> through a type <code>typ</code>, and either a parameter (either <code>a2</code> or <code>c</code>) or a point <code>(p1,p2)</code>, OR
</p>
</li>
<li><p> through an initial conditional error function <code>fun</code>, and possibly a distortion method <code>dis</code> together with either the parameter <code>a2</code> or a point <code>(p1,p2)</code>
</p>
</li></ul>

<p>Most people will only need the first of these two ways; the second leads to user-defined non-standard tests.
</p>
<p>If <code>typ</code> is specified, a parameter <code>a2</code> or <code>c</code> or the point <code>(p1,p2)</code> must be provided. In this case, <code>plotCEF</code> plots the conditional error function of the chosen type with the given parameter or running through the given point.
</p>
<p>If <code>typ</code> is not specified, a conditional error function (i.e., a nonincreasing function defined on [0,1] with values in [0,1]) <code>fun</code> must be provided. If no distortion method is selected (<code>dis = NA</code>), <code>fun</code> is plotted unchanged. Otherwise, the function is distorted using the chosen distortion method, either to match a desired second stage level <code>a2</code> or to run through a specified point <code>(p1,p2)</code> (one of which must be provided). Currently, two distortion methods are implemented:
</p>

<ul>
<li> <p><code>dis = "pl"</code>, Power lines: For an initial function <code>fun</code>, define <code class="reqn">f[r](x) = (f(x^r))^(1/r)</code>, r&gt;0. Note that if <code>fun</code> is a conditional error function of type <code>"b"</code> (Bauer and Koehne, 1994), so is f[r].
</p>
</li>
<li> <p><code>dis = "pl"</code>, Vertical translation: The initial function <code>fun</code> is shifted vertically.
</p>
</li></ul>

<p>See <code><a href="#topic+parconv">parconv</a></code> for more information on the two alternative parameterizations by <code class="reqn">\alpha_2</code> and <code class="reqn">c</code>.
</p>
<p>Internally, <code>plotCEF</code> uses <code><a href="#topic+CEF">CEF</a></code> to compute the conditional error function that is to be plotted.
</p>


<h3>Value</h3>

<p>The function <code>plotCEF</code> is invoked for its plotting effect; it returns no meaningful value.
</p>


<h3>Note</h3>

<p>Provide either <code>typ</code> or <code>fun</code>, not both! If <code>typ</code> is provided, then also specify <code>a2</code>, <code>c</code>, or <code>p1</code> (and possibly <code>p2</code>). If <code>fun</code> is provided, then also specify <code>dis</code> and <code>a2</code>, or <code>dis</code> and <code>p1</code> (and possibly <code>p2</code>), or none of these.
</p>
<p>Warning: Values of <code>a2</code> close to 0 or 1 may not work for <code>dis = "pl"</code>. 
</p>
<p><code>plt.pt</code> and <code>plt.ptann</code> are not considered if <code>p1 = NA</code>. <code>plt.ptann</code> is not considered if <code>plt.pt = FALSE</code>.
</p>
<p>Note that in this implementation of adaptive two-stage tests, early stopping bounds are <em>not</em> part of the conditional error function. Rather, they are specified separately (see also <code><a href="#topic+tsT">tsT</a></code>).
</p>


<h3>Author(s)</h3>

<p>Marc Vandemeulebroecke</p>


<h3>References</h3>

<p>Bauer, P., Koehne, K. (1994). Evaluation of experiments with adaptive interim analyses. <em>Biometrics</em> 50, 1029-1041.
</p>
<p>Lehmacher, W., Wassmer, G. (1999). Adaptive sample size calculations in group sequential trials. <em>Biometrics</em> 55, 1286-1290.
</p>
<p>Vandemeulebroecke, M. (2006). An investigation of two-stage tests. <em>Statistica Sinica</em> 16, 933-951.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+adaptTest">adaptTest</a></code> package description, <code><a href="#topic+parconv">parconv</a></code>, <code><a href="#topic+CEF">CEF</a></code>, <code><a href="#topic+tsT">tsT</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>## Plot two conditional error functions of the Lehmacher-Wassmer (1999) type:
## one to the local level alpha2=0.1, and one that runs through (p1,p2)=(0.3,0.7)
plotCEF(typ="l", a2=0.1, add=FALSE)
plotCEF(typ="l", p1=0.3, p2=0.7)

## Plot an explicitly defined conditional error function, and distort it
plotCEF(fun=function(x) ifelse(x&lt;.5,(1-x)^2, (1-x)/2), add=FALSE)
plotCEF(fun=function(x) ifelse(x&lt;.5,(1-x)^2, (1-x)/2), dis="pl", a2=.5)
foo &lt;- CEF(fun=function(x) ifelse(x&lt;.5,(1-x)^2, (1-x)/2), dis="pl", a2=.5)
plotCEF(fun=foo, col="red")
</code></pre>

<hr>
<h2 id='tsT'>Function to implement an adaptive two-stage test</h2><span id='topic+tsT'></span>

<h3>Description</h3>

<p>There are four key quantities for the specification of an adaptive two-stage test: the overall test level <code class="reqn">\alpha</code>, stopping bounds <code class="reqn">\alpha_1 &lt;= \alpha_0</code> and the local level <code class="reqn">\alpha_2</code> of the test after the second stage. These quantities are interrelated through the overall level condition. The function <code>tsT</code> calculates any of these quantities based on the others.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tsT(typ, a = NA, a0 = NA, a1 = NA, a2 = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tsT_+3A_typ">typ</code></td>
<td>
<p>type of test: <code>"b"</code> for Bauer and Koehne (1994), <code>"l"</code> for Lehmacher and Wassmer (1999), <code>"v"</code> for Vandemeulebroecke (2006) and <code>"h"</code> for the horizontal conditional error function</p>
</td></tr>
<tr><td><code id="tsT_+3A_a">a</code></td>
<td>
<p><code class="reqn">\alpha</code>, the overall test level</p>
</td></tr>
<tr><td><code id="tsT_+3A_a0">a0</code></td>
<td>
<p><code class="reqn">\alpha_0</code>, the futility stopping bound</p>
</td></tr>
<tr><td><code id="tsT_+3A_a1">a1</code></td>
<td>
<p><code class="reqn">\alpha_1</code>, the efficacy stopping bound and local level of the test after the first stage</p>
</td></tr>
<tr><td><code id="tsT_+3A_a2">a2</code></td>
<td>
<p><code class="reqn">\alpha_2</code>, the local level of the test after the second stage</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An adaptive two-stage test can be viewed as a family of decreasing functions <code class="reqn">f[c](p_1)</code> in the unit square. Each of these functions is a conditional error function, specifying the type I error conditional on the p-value <code class="reqn">p_1</code> of the first stage. For example, <code class="reqn">f[c](p_1) = \min(1, c/p_1)</code> corresponds to Fisher's combination test (Bauer and Koehne, 1994). Based on this function family, the test can be put into practice by specifying the desired overall level <code class="reqn">\alpha</code>, stopping bounds <code class="reqn">\alpha_1 &lt;= \alpha_0</code> and a parameter <code class="reqn">\alpha_2</code>. After computing <code class="reqn">p_1</code>, the test stops with or without rejection of the null hypothesis if <code class="reqn">p_1 &lt;= \alpha_1</code> or <code class="reqn">p_1 &gt; \alpha_0</code>, respectively. Otherwise, the null hypothesis is rejected if and only if <code class="reqn">p_2 &lt;= f[c](p_1)</code> holds for the p-value <code class="reqn">p_2</code> of the second stage, where <code class="reqn">c</code> is such that the local level of this latter test is <code class="reqn">\alpha_2</code> (e.g., <code class="reqn">c = c(\alpha_2) = \exp(-\chi^2_{4,\alpha_2}/2)</code> for Fisher's combination test).
</p>
<p>The four parameters <code class="reqn">\alpha</code>, <code class="reqn">\alpha_0</code>, <code class="reqn">\alpha_1</code> and <code class="reqn">\alpha_2</code> are interdependent: they must satisfy the level condition </p>
<p style="text-align: center;"><code class="reqn">\alpha_1 + \int_{\alpha_1}^{\alpha_0} cef_{\alpha_2}(p_1) d p_1 = \alpha,</code>
</p>
<p> where <code class="reqn">cef_{\alpha_2}</code> is the conditional error function (of a specified family) with parameter <code class="reqn">\alpha_2</code>. For example, this conditon translates to </p>
<p style="text-align: center;"><code class="reqn">\alpha = \alpha_1 + c(\alpha_2) * (\log(\alpha_0) - \log(\alpha_1))</code>
</p>
<p> for Fisher's combination test (assuming that <code class="reqn">c(\alpha_2) &lt; \alpha_1</code>; Bauer and Koehne, 1994). The function <code>tsT</code> calculates any of the four parameters based on the remaining ones. Currently, this is implemented for the following four tests: Bauer and Koehne (1994), Lehmacher and Wassmer (1999), Vandemeulebroecke (2006), and the horizontal conditional error function.
</p>


<h3>Value</h3>

<p>If three of the four quantities <code class="reqn">\alpha</code>, <code class="reqn">\alpha_0</code>, <code class="reqn">\alpha_1</code> and <code class="reqn">\alpha_2</code> are provided, <code>tsT</code> returns the fourth. If only <code class="reqn">\alpha</code> and <code class="reqn">\alpha_0</code> are provided, <code>tsT</code> returns <code class="reqn">\alpha_1</code> under the condition <code class="reqn">\alpha_1 = \alpha_2</code> (the so-called &quot;Pocock-type&quot;).
</p>
<p>If the choice of arguments is not allowed (e.g., <code class="reqn">\alpha_0 &lt; \alpha_1</code>) or when a test cannot be constructed with this choice of arguments (e.g., <code class="reqn">\alpha_0 = 1</code> and <code class="reqn">\alpha &lt; \alpha_2</code>), <code>tsT</code> returns <code>NA</code>.
</p>
<p>IMPORTANT: When the result is (theoretically) not unique, <code>tsT</code> returns the maximal <code class="reqn">\alpha_1</code>, maximal <code class="reqn">\alpha_2</code> or minimal <code class="reqn">\alpha_0</code>.
</p>
<p>In all cases, <code>tsT</code> returns the result for the test specified by <code>typ</code>.
</p>


<h3>Note</h3>

<p>The argument <code>typ</code>, and either exactly three of <code class="reqn">\alpha</code>, <code class="reqn">\alpha_0</code>, <code class="reqn">\alpha_1</code> and <code class="reqn">\alpha_2</code>, or only <code class="reqn">\alpha</code> and <code class="reqn">\alpha_0</code>, must be provided to <code>tsT</code>.
</p>


<h3>Author(s)</h3>

<p>Marc Vandemeulebroecke</p>


<h3>References</h3>

<p>Bauer, P., Koehne, K. (1994). Evaluation of experiments with adaptive interim analyses. <em>Biometrics</em> 50, 1029-1041.
</p>
<p>Lehmacher, W., Wassmer, G. (1999). Adaptive sample size calculations in group sequential trials. <em>Biometrics</em> 55, 1286-1290.
</p>
<p>Vandemeulebroecke, M. (2006). An investigation of two-stage tests. <em>Statistica Sinica</em> 16, 933-951.
</p>
<p>Vandemeulebroecke, M. (2008). Group sequential and adaptive designs - a review of basic concepts and points of discussion. <em>Biometrical Journal</em> 50, 541-557.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+adaptTest">adaptTest</a></code> package description</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from Bauer and Koehne (1994): full level after final stage, alpha0 = 0.5
alpha  &lt;- 0.1
alpha2 &lt;- 0.1
alpha0 &lt;- 0.5
alpha1 &lt;- tsT(typ="b", a=alpha, a0=alpha0, a2=alpha2)
plotCEF(typ="b", a2=alpha2, add=FALSE)
plotBounds(alpha1, alpha0)

## See how similar Lehmacher and Wassmer (1999) and Vandemeulebroecke (2006) are
alpha  &lt;- 0.1
alpha1 &lt;- 0.05
alpha0 &lt;- 0.5
alpha2l &lt;- tsT(typ="l", a=alpha, a0=alpha0, a1=alpha1)
alpha2v &lt;- tsT(typ="v", a=alpha, a0=alpha0, a1=alpha1)
plotCEF(typ="l", a2=alpha2l, add=FALSE)
plotCEF(typ="v", a2=alpha2v, col="red")
plotBounds(alpha1, alpha0)

## A remark about numerics
tsT(typ="b", a=0.1, a1=0.05, a0=0.5)
tsT(typ="b", a=0.1, a2=0.104877, a0=0.5)
tsT(typ="b", a=0.1, a2=tsT(typ="b", a=0.1, a1=0.05, a0=0.5), a0=0.5)

## An example of non-uniqueness: the maximal alpha1 is returned; any
##  smaller value would also be valid
alpha  &lt;- 0.05
alpha0 &lt;- 1
alpha2 &lt;- 0.05
alpha1 &lt;- tsT(typ="b", a=alpha, a0=alpha0, a2=alpha2)
tsT(typ="b", a0=alpha0, a1=alpha1, a2=alpha2)
tsT(typ="b", a0=alpha0, a1=alpha1/2, a2=alpha2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
