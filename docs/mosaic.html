<!DOCTYPE html><html><head><title>Help for package mosaic</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mosaic}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mosaic-package'><p>mosaic: the Project MOSAIC package</p></a></li>
<li><a href='#.is.formula'><p>Check if formula</p></a></li>
<li><a href='#adapt_seq'><p>Adaptively generate sequences in an interval</p></a></li>
<li><a href='#aggregatingFunction1'><p>1-ary Aggregating functions</p></a></li>
<li><a href='#aggregatingFunction1or2'><p>1- or 2-ary aggregating functions</p></a></li>
<li><a href='#aggregatingFunction2'><p>2-ary aggregating functions</p></a></li>
<li><a href='#as.xtabs'><p>Convert objects to xtabs format</p></a></li>
<li><a href='#ashplot'><p>Average Shifted Histograms</p></a></li>
<li><a href='#bargraph'><p>Create bar graphs from raw data</p></a></li>
<li><a href='#binom.test'><p>Exact Tests for Proportions</p></a></li>
<li><a href='#Broyden'><p>Multi-Dimensional Root Finding</p></a></li>
<li><a href='#cdist'><p>Central portion of a distribution</p></a></li>
<li><a href='#chisq'><p>Extract Chi-squared statistic</p></a></li>
<li><a href='#CIAdata'><p>Return a dataset based on the CIA World Factbook</p></a></li>
<li><a href='#CIsim'><p>Compute confidence intervals from (multiple) simulated data sets</p></a></li>
<li><a href='#cnorm'><p>Central Probability in a Normal or T Distribution</p></a></li>
<li><a href='#compareMean'><p>Defunct functions</p></a></li>
<li><a href='#confint'><p>Confidence interval methods for output of resampling</p></a></li>
<li><a href='#confint.htest'><p>Extract summary statistics</p></a></li>
<li><a href='#cor_test.formula'><p>Alternative formula interface for cor.test</p></a></li>
<li><a href='#cross'><p>Factor cross products</p></a></li>
<li><a href='#cull_for_do'><p>Cull objects used with do()</p></a></li>
<li><a href='#deg2rad'><p>Convert between degrees and radians</p></a></li>
<li><a href='#derivedVariable'><p>Create new variables from logicals</p></a></li>
<li><a href='#design_plot'><p>Interactively design plots</p></a></li>
<li><a href='#diffmean'><p>Difference in means and proportions</p></a></li>
<li><a href='#do'><p>Do Things Repeatedly</p></a></li>
<li><a href='#docFile'><p>Return the path to a documentation file in a package</p></a></li>
<li><a href='#dotPlot'><p>Dotplots</p></a></li>
<li><a href='#dpqrdist'><p>Distribution wrapper</p></a></li>
<li><a href='#expandFun'><p>Expand the left-hand side of a formula</p></a></li>
<li><a href='#factorize'><p>Conditionally convert vectors to factors</p></a></li>
<li><a href='#fav_stats'><p>Some favorite statistical summaries</p></a></li>
<li><a href='#fetchData'><p>Defunct functions now in the fetch package</p></a></li>
<li><a href='#findZeros'><p>Find zeros of functions</p></a></li>
<li><a href='#findZerosMult'><p>Find the zeros of a function of two or more variables</p></a></li>
<li><a href='#fitModel'><p>Fit a nonlinear least squares model</p></a></li>
<li><a href='#fitSpline'><p>Fit splines to data</p></a></li>
<li><a href='#fortify.hclust'><p>mosaic tools for clustering</p></a></li>
<li><a href='#fortify.summary.lm'><p>Extract data from R objects</p></a></li>
<li><a href='#freqpoly'><p>Turn histograms into frequency polygons</p></a></li>
<li><a href='#freqpolygon'><p>Frequency Polygons</p></a></li>
<li><a href='#FunctionsFromData'><p>Create function from data</p></a></li>
<li><a href='#getVarFormula'><p>Extract data from a data frame using a formula interface</p></a></li>
<li><a href='#googleMap'><p>Display a point on earth on a Google Map</p></a></li>
<li><a href='#inferArgs'><p>Infer arguments</p></a></li>
<li><a href='#is.wholenumber'><p>Check for whole number values</p></a></li>
<li><a href='#ladd'><p>Add to Lattice Plots</p></a></li>
<li><a href='#leaflet_map'><p>Simple Leaflet Maps</p></a></li>
<li><a href='#linear.algebra'><p>Functions for teaching linear algebra.</p></a></li>
<li><a href='#MAD'><p>All pairs mean and sum of absolute differences</p></a></li>
<li><a href='#MAD_'><p>All pairs mean and sum of absolute differences</p></a></li>
<li><a href='#maggregate'><p>Aggregate for mosaic</p></a></li>
<li><a href='#makeColorscheme'><p>Create a color generating function from a vector of colors</p></a></li>
<li><a href='#makeMap'><p>Make a map with <code>ggplot2</code></p></a></li>
<li><a href='#mean_'><p>Aggregating functions</p></a></li>
<li><a href='#mid'><p>midpoints along a sequence</p></a></li>
<li><a href='#mosaic.options'><p>Setting options for mosaic package functions</p></a></li>
<li><a href='#mplot'><p>Generic plotting</p></a></li>
<li><a href='#mPlot'><p>Interactive plotting</p></a></li>
<li><a href='#mUSMap'><p>Make a US map with <code>ggplot2</code></p></a></li>
<li><a href='#Mustangs'><p>Mustang Prices</p></a></li>
<li><a href='#mWorldMap'><p>Make a world map with <code>ggplot2</code></p></a></li>
<li><a href='#ntiles'><p>Create vector based on roughly equally sized groups</p></a></li>
<li><a href='#orrr'><p>Odds Ratio and Relative Risk for 2 x 2 Contingency Tables</p></a></li>
<li><a href='#panel.levelcontourplot'><p>Lattice plot that draws a filled contour plot</p></a></li>
<li><a href='#panel.lmbands'><p>show confidence and prediction bands on plots</p></a></li>
<li><a href='#panel.plotFun'><p>Panel function for plotting functions</p></a></li>
<li><a href='#panel.plotFun1'><p>Panel function for plotting functions</p></a></li>
<li><a href='#pdist'><p>Illustrated probability calculations from distributions</p></a></li>
<li><a href='#plotCumfreq'><p>Cumulative frequency plots</p></a></li>
<li><a href='#plotDist'><p>Plots of Discrete and Continuous Distributions</p></a></li>
<li><a href='#plotFun'><p>Plotting mathematical expressions</p></a></li>
<li><a href='#plotModel'><p>Plot a regression model</p></a></li>
<li><a href='#plotPoints'><p>Scatter plot of points</p></a></li>
<li><a href='#project'><p>Projections</p></a></li>
<li><a href='#prop_test'><p>Internal function for testing proportion</p></a></li>
<li><a href='#prop.test'><p>Exact and Approximate Tests for Proportions</p></a></li>
<li><a href='#qdata'><p>The Data Distribution</p></a></li>
<li><a href='#qdata_v'><p>The Data Distribution</p></a></li>
<li><a href='#qdist'><p>Illustrated quantile calculations from distributions</p></a></li>
<li><a href='#rand'><p>Random Regressors</p></a></li>
<li><a href='#read.file'><p>Read data files</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#relm'><p>Resample a Linear Model</p></a></li>
<li><a href='#repeater-class'><p>Repeater objects</p></a></li>
<li><a href='#resample'><p>More Random Samples</p></a></li>
<li><a href='#rescale'><p>Rescale</p></a></li>
<li><a href='#rflip'><p>Tossing Coins</p></a></li>
<li><a href='#rfun'><p>Generate a natural-looking function</p></a></li>
<li><a href='#rgeo-internals'><p>rgeo internal functions</p></a></li>
<li><a href='#rlatlon'><p>Sample longitude and latitude on a sphere</p></a></li>
<li><a href='#rspin'><p>Simulate spinning a spinner</p></a></li>
<li><a href='#rsquared'><p>Extract r-squared value</p></a></li>
<li><a href='#rstudio_is_available'><p>Check whether RStudio is in use</p></a></li>
<li><a href='#set.rseed'><p>Set seed in parallel compatible way</p></a></li>
<li><a href='#Sleep'><p>Sleep and Memory</p></a></li>
<li><a href='#sp2df'><p>Transforms a shapefile into a dataframe</p></a></li>
<li><a href='#standardName'><p>Standardization of Geographic Names</p></a></li>
<li><a href='#statTally'><p>Tally test statistics</p></a></li>
<li><a href='#surround'><p>Format strings for pretty output</p></a></li>
<li><a href='#swap'><p>Swap values among columns of a data frame</p></a></li>
<li><a href='#t_test'><p>Student's t-Test</p></a></li>
<li><a href='#theme_map'><p>ggplot2 theme for maps</p></a></li>
<li><a href='#theme.mosaic'><p>Lattice Theme</p></a></li>
<li><a href='#TukeyHSD.lm'><p>Additional interfaces to TukeyHSD</p></a></li>
<li><a href='#update_ci'><p>Update confidence interval</p></a></li>
<li><a href='#value'><p>Extract value from an object</p></a></li>
<li><a href='#xchisq.test'><p>Augmented Chi-squared test</p></a></li>
<li><a href='#xhistogramBreaks'><p>Augmented histograms</p></a></li>
<li><a href='#xpnorm'><p>Augmented versions of pnorm and qnorm</p></a></li>
<li><a href='#xqqmath'><p>Augmented version of <code>qqmath</code></p></a></li>
<li><a href='#xyz2latlon'><p>Convert back and forth between latitude/longitude and XYZ-space</p></a></li>
<li><a href='#zscore'><p>Compute z-scores</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Project MOSAIC Statistics and Mathematics Teaching Utilities</td>
</tr>
<tr>
<td>Version:</td>
<td>1.9.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Data sets and utilities from Project MOSAIC (<a href="http://www.mosaic-web.org">http://www.mosaic-web.org</a>) used
    to teach mathematics, statistics, computation and modeling.  Funded by the
    NSF, Project MOSAIC is a community of educators working to tie together
    aspects of quantitative work that students in science, technology,
    engineering and mathematics will need in their professional lives, but
    which are usually taught in isolation, if at all.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1),</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr, tibble, lattice (&ge; 0.20-21), ggformula, mosaicData,
Matrix, mosaicCore (&ge; 0.7.0), ggplot2, rlang (&ge; 0.4.7),
purrr, MASS, grid, tidyr, methods, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggstance, ggridges, vdiffr, lubridate, magrittr, NHANES,
RCurl, sp, vcd, testthat (&ge; 3.0.0), knitr, tools, parallel,
mapproj, rgl, rmarkdown, covr, formatR, palmerpenguins,
ggrepel, readr, ggdendro, gridExtra, splines, latticeExtra,
glue, broom, leaflet</td>
</tr>
<tr>
<td>Enhances:</td>
<td>manipulate</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ProjectMOSAIC/mosaic">https://github.com/ProjectMOSAIC/mosaic</a>,
<a href="https://www.mosaic-web.org/mosaic/">https://www.mosaic-web.org/mosaic/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ProjectMOSAIC/mosaic/issues">https://github.com/ProjectMOSAIC/mosaic/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-18 03:47:21 UTC; rpruim</td>
</tr>
<tr>
<td>Author:</td>
<td>Randall Pruim [aut, cre],
  Daniel T. Kaplan [aut],
  Nicholas J. Horton [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Randall Pruim &lt;rpruim@calvin.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-23 14:30:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='mosaic-package'>mosaic: the Project MOSAIC package</h2><span id='topic+mosaic-package'></span><span id='topic+mosaic'></span>

<h3>Description</h3>

<p>mosaic
</p>


<h3>Details</h3>

<p>Data sets and utilities from Project MOSAIC (mosaic-web.org) used to teach mathematics,
statistics, computation and modeling.  Funded by the NSF, Project MOSAIC is a
community of educators working to tie together aspects of quantitative work that students
in science, technology, engineering and mathematics will need in their professional lives,
but which are usually taught in isolation, if at all.
</p>


<h3>Author(s)</h3>

<p>Randall Pruim (<a href="mailto:rpruim@calvin.edu">rpruim@calvin.edu</a>), Daniel Kaplan (<a href="mailto:kaplan@macalester.edu">kaplan@macalester.edu</a>), Nicholas Horton (<a href="mailto:nhorton@smith.edu">nhorton@smith.edu</a>)
</p>


<h3>References</h3>

<p><a href="http://www.mosaic-web.org">http://www.mosaic-web.org</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/ProjectMOSAIC/mosaic">https://github.com/ProjectMOSAIC/mosaic</a>
</p>
</li>
<li> <p><a href="https://www.mosaic-web.org/mosaic/">https://www.mosaic-web.org/mosaic/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ProjectMOSAIC/mosaic/issues">https://github.com/ProjectMOSAIC/mosaic/issues</a>
</p>
</li></ul>


<hr>
<h2 id='.is.formula'>Check if formula</h2><span id='topic+.is.formula'></span><span id='topic+.is.simple.formula'></span><span id='topic+.simple.part'></span><span id='topic+.make.data.frame'></span><span id='topic+.merge_data_frames'></span><span id='topic+.squash_names'></span><span id='topic+.do.safe.call'></span>

<h3>Description</h3>

<p>Check if formula
</p>
<p>Check for simple formula
</p>
<p>Extract simple part from formula
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.is.formula(x)

.is.simple.formula(x)

.simple.part(x)

.make.data.frame(x)

.merge_data_frames(a, b)

.squash_names(object, sep = ":")

.do.safe.call(what, args, quote = FALSE, envir = parent.frame(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".is.formula_+3A_x">x</code></td>
<td>
<p>object to be converted</p>
</td></tr>
<tr><td><code id=".is.formula_+3A_a">a</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id=".is.formula_+3A_b">b</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id=".is.formula_+3A_object">object</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id=".is.formula_+3A_sep">sep</code></td>
<td>
<p>a character</p>
</td></tr>
<tr><td><code id=".is.formula_+3A_what">what</code></td>
<td>
<p>either a function or a non-empty character string naming the function to be called.</p>
</td></tr>
<tr><td><code id=".is.formula_+3A_args">args</code></td>
<td>
<p>a list of arguments to the function call. The names attribute of args gives the argument names.</p>
</td></tr>
<tr><td><code id=".is.formula_+3A_quote">quote</code></td>
<td>
<p>a logical value indicating whether to quote the arguments.</p>
</td></tr>
<tr><td><code id=".is.formula_+3A_envir">envir</code></td>
<td>
<p>an environment within which to evaluate the call.
This will be most useful if what is a character string and the arguments are symbols or quoted expressions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>.make.data.frame</code> converts things to a data frame
</p>
<p><code>.merge_data_frames</code> is a wrapper around merge
</p>
<p><code>.squash_names</code> squashes names of a data frame into a single string
</p>
<p><code>.do.safe.call</code> avoids conflicts between named arguments and ... by taking named arguments
preferentially.
</p>


<h3>Value</h3>

<p>TRUE for a formula, FALSE otherwise, even if evaluation throws an error
</p>
<p>TRUE if formula has no left-hand side or a simple right-hand side
(e.g., <code>NULL</code>, ., 1,  or 0)
</p>
<p>simple part of formula or NULL if formula is not simple
</p>
<p>a data frame
</p>
<p>a data frame
</p>
<p>a character vector
</p>
<p>The result of the (evaluated) function call.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+do.call">do.call()</a></code>
</p>

<hr>
<h2 id='adapt_seq'>Adaptively generate sequences in an interval</h2><span id='topic+adapt_seq'></span>

<h3>Description</h3>

<p><code>adapt_seq</code> is similar to <code>seq</code> except that instead of
selecting points equally spaced along an interval, it selects points
such that the values of a function applied at those points are
(very) roughly equally spaced.  This can be useful for sampling
a function in such a way that it can be plotted more smoothly,
for example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adapt_seq(
  from,
  to,
  length.out = 200,
  f = function(x, ...) {
     1
 },
  args = list(),
  quiet = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adapt_seq_+3A_from">from</code></td>
<td>
<p>start of interval</p>
</td></tr>
<tr><td><code id="adapt_seq_+3A_to">to</code></td>
<td>
<p>end of interval</p>
</td></tr>
<tr><td><code id="adapt_seq_+3A_length.out">length.out</code></td>
<td>
<p>desired length of sequence</p>
</td></tr>
<tr><td><code id="adapt_seq_+3A_f">f</code></td>
<td>
<p>a function</p>
</td></tr>
<tr><td><code id="adapt_seq_+3A_args">args</code></td>
<td>
<p>arguments passed to <code>f</code></p>
</td></tr>
<tr><td><code id="adapt_seq_+3A_quiet">quiet</code></td>
<td>
<p>suppress warnings about NaNs, etc.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numerical vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>adapt_seq(0, pi, 25, sin)

</code></pre>

<hr>
<h2 id='aggregatingFunction1'>1-ary Aggregating functions</h2><span id='topic+aggregatingFunction1'></span>

<h3>Description</h3>

<p><code>aggregatinFuntion1</code> creates statistical summaries of one numerical vector that are formula aware.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregatingFunction1(
  fun,
  output.multiple = FALSE,
  envir = parent.frame(),
  na.rm = getOption("na.rm", FALSE),
  style = c("formula1st", "formula", "flexible")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregatingFunction1_+3A_fun">fun</code></td>
<td>
<p>a function that takes a numeric vector and computes a summary statistic,
returning a numeric vector.</p>
</td></tr>
<tr><td><code id="aggregatingFunction1_+3A_output.multiple">output.multiple</code></td>
<td>
<p>a boolean indicating whether <code>fun</code> returns multiple values</p>
</td></tr>
<tr><td><code id="aggregatingFunction1_+3A_envir">envir</code></td>
<td>
<p>an environment in which evaluation takes place.</p>
</td></tr>
<tr><td><code id="aggregatingFunction1_+3A_na.rm">na.rm</code></td>
<td>
<p>the default value for na.rm in the resulting function.</p>
</td></tr>
<tr><td><code id="aggregatingFunction1_+3A_style">style</code></td>
<td>
<p>one of <code>"formula1st"</code>, <code>"formula2nd"</code> or <code>"flexible"</code>.  In the first
two cases, the first argument must be a formula or evaluate to an object.  In the latter case,
bare names will be converted into formulas.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The logic of the resulting function is this: 1) If the first argument is a formula,
use that formula and <code>data</code> to create the necessary call(s) to <code>fun</code>; (2) Else simply
pass everything to <code>fun</code> for evaluation.
</p>


<h3>Value</h3>

<p>a function that generalizes <code>fun</code> to handle a formula/data frame interface.
</p>


<h3>Note</h3>

<p>Earlier versions of this function supported a &quot;bare name + data frame&quot; interface.  This
functionality has been removed since it was (a) ambiguous in some cases, (b) unnecessary, and (c)
difficult to maintain.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(mosaicData)) {
  foo &lt;- aggregatingFunction1(base::mean)
  foo( ~ length, data = KidsFeet)
  base::mean(KidsFeet$length)
  foo(length ~ sex, data = KidsFeet)
} 
</code></pre>

<hr>
<h2 id='aggregatingFunction1or2'>1- or 2-ary aggregating functions</h2><span id='topic+aggregatingFunction1or2'></span>

<h3>Description</h3>

<p><code>aggregatingFunction1or2()</code> creates statistical summaries for functions like
<code><a href="#topic+var">var()</a></code> that can have either 1 or 2 numeric vector inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregatingFunction1or2(
  fun,
  output.multiple = FALSE,
  na.rm = getOption("na.rm", FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregatingFunction1or2_+3A_fun">fun</code></td>
<td>
<p>a function that takes 1 or 2 numeric vectors and computes a summary statistic,
returning a numeric vector of length 1.</p>
</td></tr>
<tr><td><code id="aggregatingFunction1or2_+3A_output.multiple">output.multiple</code></td>
<td>
<p>a boolean indicating whether <code>fun</code> returns multiple values</p>
</td></tr>
<tr><td><code id="aggregatingFunction1or2_+3A_na.rm">na.rm</code></td>
<td>
<p>the default value for na.rm in the resulting function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This was designed primarily to support <code>var</code> which can be used to compute
either the variance of one variable or the covariance of two variables.
The logic of the resulting function is this: 1) If the first two arguments are both formulas,
then those formulas are evaluated (with <code>data</code>) to compute the covariance;
(2) If the first argument is a formula, and the second is <code>NULL</code>,
then the formula and <code>data</code> are used to create the necessary call(s) to <code>fun</code>;
(3) Else everything is simply passed to <code>fun</code> for evaluation.
</p>


<h3>Note</h3>

<p>Earlier versions of this function supported a &quot;bare name + data frame&quot; interface.  This
functionality has been removed since it was (a) ambiguous in some cases, (b) unnecessary,
and (c) difficult to maintain.
</p>

<hr>
<h2 id='aggregatingFunction2'>2-ary aggregating functions</h2><span id='topic+aggregatingFunction2'></span>

<h3>Description</h3>

<p><code>aggregatinFuntion2</code> creates statistical summaries of two numerical vectors that
are formula aware.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>aggregatingFunction2(fun)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="aggregatingFunction2_+3A_fun">fun</code></td>
<td>
<p>a function that takes two numeric vectors and computes a summary statistic,
returning a numeric vector of length 1.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This was designed to support functions like <code>cov()</code> which can be used to compute
numerical summaries from two numeric vectors.
The logic of the resulting function is this: 1) If the first two arguments are both formulas,
then those formulas are evaluated (with <code>data</code>) to compute the covariance;
(2) If the first argument is a formula, and the second is <code>NULL</code>,
then the left and ride sides of the formula and <code>data</code> are used to create the
vectors passed to <code>fun</code>;
(3) Else everything is simply passed to <code>fun</code> for evaluation.
</p>


<h3>Value</h3>

<p>a function that generalizes <code>fun</code> to handle a formula/data frame interface.
</p>


<h3>Note</h3>

<p>Earlier versions of this function supported a &quot;bare name + data frame&quot; interface.  This
functionality has been removed since it was (a) ambiguous in some cases, (b) unnecessary,
and (c) difficult to maintain.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(require(mosaicData)) {
  foo &lt;- aggregatingFunction2(stats::cor)
  foo(length ~ width, data = KidsFeet)
  stats::cor(KidsFeet$length, KidsFeet$width)
}
</code></pre>

<hr>
<h2 id='as.xtabs'>Convert objects to xtabs format</h2><span id='topic+as.xtabs'></span><span id='topic+as.xtabs.data.frame'></span><span id='topic+as.xtabs.matrix'></span>

<h3>Description</h3>

<p>Convert a data frame or a matrix into an <code>xtabs</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.xtabs(x, ...)

## S3 method for class 'data.frame'
as.xtabs(x, rowvar = NULL, colvar = NULL, labels = 1, ...)

## S3 method for class 'matrix'
as.xtabs(x, rowvar = NULL, colvar = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.xtabs_+3A_x">x</code></td>
<td>
<p>object (typically a data frame) to be converted to <code>xtabs</code>
format</p>
</td></tr>
<tr><td><code id="as.xtabs_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="as.xtabs_+3A_rowvar">rowvar</code></td>
<td>
<p>name of the row variable as character string</p>
</td></tr>
<tr><td><code id="as.xtabs_+3A_colvar">colvar</code></td>
<td>
<p>name of the column variable as character string</p>
</td></tr>
<tr><td><code id="as.xtabs_+3A_labels">labels</code></td>
<td>
<p>column of data frame that contains the labels of the row
variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The intended use is to convert a two-way contingency table stored in a data
frame or a matrix into an <code>xtabs</code> object.
</p>


<h3>Value</h3>

<p>An <code>xtabs</code> object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example from example(fisher.test)
df &lt;- data.frame( X=c('Tea','Milk'), Tea=c(3,1), Milk=c(1,3) )
xt &lt;- as.xtabs(df, rowvar="Guess", colvar="Truth"); xt
if (require(vcd)) { mosaic(xt) }
</code></pre>

<hr>
<h2 id='ashplot'>Average Shifted Histograms</h2><span id='topic+ashplot'></span><span id='topic+prepanel.default.ashplot'></span><span id='topic+panel.ashplot'></span>

<h3>Description</h3>

<p>An ASH plot is the average over all histograms of a fixed bin width.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ashplot(
  x,
  data = data,
  ...,
  width = NULL,
  adjust = NULL,
  panel = panel.ashplot,
  prepanel = prepanel.default.ashplot
)

prepanel.default.ashplot(x, darg, groups = NULL, subscripts = TRUE, ...)

panel.ashplot(
  x,
  darg = list(),
  plot.points = FALSE,
  ref = FALSE,
  groups = NULL,
  jitter.amount = 0.01 * diff(current.panel.limits()$ylim),
  type = "p",
  ...,
  identifier = "ash"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ashplot_+3A_x">x</code></td>
<td>
<p>A formula or numeric vector.</p>
</td></tr>
<tr><td><code id="ashplot_+3A_data">data</code></td>
<td>
<p>A data frame.</p>
</td></tr>
<tr><td><code id="ashplot_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to panel and prepanel functions or <code>data</code>, a
data frame in which to find the variables used for the plot.</p>
</td></tr>
<tr><td><code id="ashplot_+3A_width">width</code></td>
<td>
<p>The histogram bin width.</p>
</td></tr>
<tr><td><code id="ashplot_+3A_adjust">adjust</code></td>
<td>
<p>A numeric adjustment to <code>width</code>.  Primarily useful when <code>width</code> is
not specified.  Increasing <code>adjust</code> makes the plot smoother.</p>
</td></tr>
<tr><td><code id="ashplot_+3A_panel">panel</code></td>
<td>
<p>A panel function.</p>
</td></tr>
<tr><td><code id="ashplot_+3A_prepanel">prepanel</code></td>
<td>
<p>A prepanel function.</p>
</td></tr>
<tr><td><code id="ashplot_+3A_darg">darg</code></td>
<td>
<p>a list of arguments for the function computing the ASH.</p>
</td></tr>
<tr><td><code id="ashplot_+3A_groups">groups</code></td>
<td>
<p>as in other lattice plots</p>
</td></tr>
<tr><td><code id="ashplot_+3A_subscripts">subscripts</code></td>
<td>
<p>as in other lattice prepanel functions</p>
</td></tr>
<tr><td><code id="ashplot_+3A_plot.points">plot.points</code></td>
<td>
<p>One of <code>TRUE</code>, <code>FALSE</code>, <code>"jitter"</code>, or <code>"rug"</code></p>
</td></tr>
<tr><td><code id="ashplot_+3A_ref">ref</code></td>
<td>
<p>a logical indicating whether a reference line should be displayed</p>
</td></tr>
<tr><td><code id="ashplot_+3A_jitter.amount">jitter.amount</code></td>
<td>
<p>when <code>plot.points="jitter"</code>, the value to use as the amount
argument to <code><a href="base.html#topic+jitter">jitter()</a></code>.</p>
</td></tr>
<tr><td><code id="ashplot_+3A_type">type</code></td>
<td>
<p>type argument used to plot points, if requested.
This is not expected to be useful, it is available mostly to protect a <code>type</code> argument,
if specified, from affecting the display of the ASH.</p>
</td></tr>
<tr><td><code id="ashplot_+3A_identifier">identifier</code></td>
<td>
<p>A character string that is prepended to the names of i
grobs that are created by this panel function.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ashplot( ~age | substance, groups = sex, data = HELPrct)
</code></pre>

<hr>
<h2 id='bargraph'>Create bar graphs from raw data</h2><span id='topic+bargraph'></span>

<h3>Description</h3>

<p><code><a href="lattice.html#topic+xyplot">lattice::barchart()</a></code> from the <code>lattice</code> package makes bar graphs from
pre-tabulated data.  Raw data can be tabulated using <code><a href="stats.html#topic+xtabs">xtabs()</a></code>, but the syntax
is unusual compared to the other lattice plotting functions.  <code>bargraph</code> provides
an interface that is consistent with the other <code>lattice</code> functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bargraph(
  x,
  data = parent.frame(),
  groups = NULL,
  horizontal = FALSE,
  origin = 0,
  ylab = ifelse(horizontal, "", type),
  xlab = ifelse(horizontal, type, ""),
  type = c("count", "frequency", "proportion", "percent"),
  auto.key = TRUE,
  scales = list(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bargraph_+3A_x">x</code></td>
<td>
<p>a formula describing the plot</p>
</td></tr>
<tr><td><code id="bargraph_+3A_data">data</code></td>
<td>
<p>a data frame in which the formula <code>x</code> is evaluated</p>
</td></tr>
<tr><td><code id="bargraph_+3A_groups">groups</code></td>
<td>
<p>a variable or expression used for grouping.  See <code><a href="lattice.html#topic+xyplot">lattice::barchart()</a></code>.</p>
</td></tr>
<tr><td><code id="bargraph_+3A_horizontal">horizontal</code></td>
<td>
<p>a logical indicating whether bars should be horizontal</p>
</td></tr>
<tr><td><code id="bargraph_+3A_origin">origin</code></td>
<td>
<p>beginning point for bars.  For the default behavior used by
<code><a href="lattice.html#topic+xyplot">lattice::barchart()</a></code> set <code>origin</code> to <code>NULL</code>, but
0 is often a better default. If 0 is not good, perhaps you should use
a different kind of plot as the results may be misleading.</p>
</td></tr>
<tr><td><code id="bargraph_+3A_ylab">ylab</code></td>
<td>
<p>a character vector of length one used for the y-axis label</p>
</td></tr>
<tr><td><code id="bargraph_+3A_xlab">xlab</code></td>
<td>
<p>a character vector of length one used for the x-axis label</p>
</td></tr>
<tr><td><code id="bargraph_+3A_type">type</code></td>
<td>
<p>one of <code>"frequency"</code>, <code>"count"</code>, <code>"percent"</code>, or <code>"proportion"</code>
indicating what type of scale to use.  Unique prefixes are sufficient.</p>
</td></tr>
<tr><td><code id="bargraph_+3A_auto.key">auto.key</code></td>
<td>
<p>a logical expression indicating whether a legend should be automatically produced</p>
</td></tr>
<tr><td><code id="bargraph_+3A_scales">scales</code></td>
<td>
<p>is a list determining how the x- and y-axes are drawn</p>
</td></tr>
<tr><td><code id="bargraph_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="lattice.html#topic+xyplot">lattice::barchart()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bargraph(formula, data=data, ...)</code> works by creating a new data frame from <code>xtabs(formula, data=data)</code>
and then calling <code><a href="lattice.html#topic+xyplot">lattice::barchart()</a></code> using modified version of the formula and this
new data frame as inputs.  This has implications on, for example, conditional plots where
one desires to condition on some expression that will be evaluated in <code>data</code>.  This typically
does not work because the required variables do not exist in the output of <code>xtabs</code>.  One solution
is to first add a new variable to <code>data</code> first and then to condition using this new variable.
See the examples.
</p>


<h3>Value</h3>

<p>a trellis object describing the plot
</p>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+xyplot">lattice::barchart()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(mosaicData)) {
data(HELPrct)
bargraph( ~ substance, data = HELPrct)
bargraph( ~ substance, data = HELPrct, horizontal = TRUE)
bargraph( ~ substance | sex, groups = homeless, auto.key = TRUE, data = HELPrct)
bargraph( ~ substance, groups = homeless, auto.key=TRUE, 
            data = HELPrct |&gt; filter(sex == "male"))
HELPrct2 &lt;- mutate(HELPrct, older = age &gt; 40)
bargraph( ~ substance | older, data = HELPrct2)
}
</code></pre>

<hr>
<h2 id='binom.test'>Exact Tests for Proportions</h2><span id='topic+binom.test'></span>

<h3>Description</h3>

<p>The <code>binom.test()</code> function
performs an exact test of a simple null hypothesis about the probability of success in a
Bernoulli experiment from summarized data or from raw data.
The mosaic <code>binom.test</code> provides wrapper functions around the function of the same name in <span class="pkg">stats</span>.
These wrappers provide an extended interface (including formulas).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binom.test(
  x,
  n = NULL,
  p = 0.5,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95,
  ci.method = c("Clopper-Pearson", "binom.test", "Score", "Wilson", "prop.test", "Wald",
    "Agresti-Coull", "Plus4"),
  data = NULL,
  success = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binom.test_+3A_x">x</code></td>
<td>
<p>count of successes, length 2 vector of success and failure counts, a formula,
or a character, numeric, or factor vector containing raw data.</p>
</td></tr>
<tr><td><code id="binom.test_+3A_n">n</code></td>
<td>
<p>sample size (successes + failures) or a data frame
(for the formula interface)</p>
</td></tr>
<tr><td><code id="binom.test_+3A_p">p</code></td>
<td>
<p>probability for null hypothesis</p>
</td></tr>
<tr><td><code id="binom.test_+3A_alternative">alternative</code></td>
<td>
<p>type of alternative hypothesis</p>
</td></tr>
<tr><td><code id="binom.test_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level for confidence interval</p>
</td></tr>
<tr><td><code id="binom.test_+3A_ci.method">ci.method</code></td>
<td>
<p>a method to use for computing the confidence interval
(case insensitive and may be abbreviated).  See details below.</p>
</td></tr>
<tr><td><code id="binom.test_+3A_data">data</code></td>
<td>
<p>a data frame (if missing, <code>n</code> may be a data frame)</p>
</td></tr>
<tr><td><code id="binom.test_+3A_success">success</code></td>
<td>
<p>level of variable to be considered success.  All other levels are
considered failure.</p>
</td></tr>
<tr><td><code id="binom.test_+3A_...">...</code></td>
<td>
<p>additional arguments (often ignored)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>binom.test()</code> is a wrapper around <code><a href="stats.html#topic+binom.test">stats::binom.test()</a></code> from the stats
package to simplify its use when the raw data are available, in which case
an extended syntax for <code>binom.test()</code> is provided.  See the examples.
</p>
<p>Also, five confidence interval methods are provided:
*
<code style="white-space: pre;">&#8288;"Clopper-Pearson", "binom.test"&#8288;</code>: This is the interval produced when using
<code><a href="stats.html#topic+binom.test">stats::binom.test()</a></code>
from the stats package.  It guarantees a coverage rate at least as large as
the nominal coverage rate, but may produce wider intervals than some of the methods
below, which may either under- or over-cover depending on the data.
</p>

<ul>
<li><p> '&quot;Score&quot;, &quot;Wilson&quot;, &quot;prop.test&quot;:  This is the usual method used by <code><a href="stats.html#topic+prop.test">stats::prop.test()</a></code>
and is computed by inverting p-values from score tests. It is often attributed to
Edwin Wilson.  If specified with <code>"prop.test"</code>, the continuity correction is applied
(as is the default in <code><a href="#topic+prop.test">prop.test</a>()</code>), else the continuity correction is not
applied.
</p>

<ul>
<li> <p><code>"Wald"</code> This is the interval traditionally taught in entry level statistics courses.
It uses the sample proportion to estimate the standard error and uses normal
theory to determine how many standard deviations to add and/or subtract from
the sample proportion to determine an interval.
</p>
</li>
<li><p> \&quot;Agresti-Coull&quot;'
This is the Wald method after setting <code class="reqn">n' = n + z^2</code> and
<code class="reqn">p'= (x + z^2/2) / n</code>' and using <code class="reqn">x' = n' p'</code> and <code class="reqn">n'</code>
in place of <code class="reqn">x</code> and <code class="reqn">n</code>.
</p>
</li>
<li> <p><code>"Plus4"</code>
This is Wald after adding in two artificial success and two artificial failures.  It
is nearly the same as the Agresti-Coull method when the confidence level is 95%. since
<code class="reqn">z^2</code> is approximately 4 and <code class="reqn">z^2/2</code> is approximately 2.
</p>
</li></ul>

</li></ul>



<h3>Value</h3>

<p>an object of class <code>htest</code>
</p>


<h3>Note</h3>

<p>When <code>x</code> is a 0-1 vector, 0 is treated as failure and 1 as success. Similarly,
for a logical vector <code>TRUE</code> is treated as success and <code>FALSE</code> as failure.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prop.test">prop.test()</a></code>, <code><a href="stats.html#topic+binom.test">stats::binom.test()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Several ways to get a confidence interval for the proportion of Old Faithful
# eruptions lasting more than 3 minutes.
data(faithful)
binom.test(faithful$eruptions &gt; 3)
binom.test(97, 272)
binom.test(c(97, 272-97))
faithful$long &lt;- faithful$eruptions &gt; 3
binom.test(faithful$long)
binom.test(resample(1:4, 400), p=.25)
binom.test(~ long, data = faithful)
binom.test(~ long, data = faithful, ci.method = "Wald")
binom.test(~ long, data = faithful, ci.method = "Plus4")
with(faithful, binom.test(~long))
with(faithful, binom.test(long))

</code></pre>

<hr>
<h2 id='Broyden'>Multi-Dimensional Root Finding</h2><span id='topic+Broyden'></span>

<h3>Description</h3>

<p>Implementation of Broyden's root finding function to numerically compute the root of
a system of nonlinear equations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Broyden(system, vars, x = 0, tol = .Machine$double.eps^0.4, maxiters = 10000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Broyden_+3A_system">system</code></td>
<td>
<p>A list of functions</p>
</td></tr>
<tr><td><code id="Broyden_+3A_vars">vars</code></td>
<td>
<p>A character string list of variables that appear in the functions</p>
</td></tr>
<tr><td><code id="Broyden_+3A_x">x</code></td>
<td>
<p>A starting vector</p>
</td></tr>
<tr><td><code id="Broyden_+3A_tol">tol</code></td>
<td>
<p>The tolerance for the function specifying how precise it will be</p>
</td></tr>
<tr><td><code id="Broyden_+3A_maxiters">maxiters</code></td>
<td>
<p>maximum number of iterations.</p>
</td></tr>
</table>

<hr>
<h2 id='cdist'>Central portion of a distribution</h2><span id='topic+cdist'></span><span id='topic+xcgamma'></span><span id='topic+xct'></span><span id='topic+xcchisq'></span><span id='topic+xcf'></span><span id='topic+xcbinom'></span><span id='topic+xcpois'></span><span id='topic+xcgeom'></span><span id='topic+xcnbinom'></span><span id='topic+xcbeta'></span>

<h3>Description</h3>

<p>This function determines the critical values for isolating
a central portion of a distribution with a specified probability.
This is designed to work especially well for symmetric distributions,
but it can be used with any distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cdist(
  dist = "norm",
  p,
  plot = TRUE,
  verbose = FALSE,
  invisible = FALSE,
  digits = 3L,
  xlim = NULL,
  ylim = NULL,
  resolution = 500L,
  return = c("values", "plot"),
  pattern = c("rings", "stripes"),
  ...,
  refinements = list()
)

xcgamma(
  p,
  shape,
  rate = 1,
  scale = 1/rate,
  lower.tail = TRUE,
  log.p = FALSE,
  ...
)

xct(p, df, ncp, lower.tail = TRUE, log.p = FALSE, ...)

xcchisq(p, df, ncp = 0, lower.tail = TRUE, log.p = FALSE, ...)

xcf(p, df1, df2, lower.tail = TRUE, log.p = FALSE, ...)

xcbinom(p, size, prob, lower.tail = TRUE, log.p = FALSE, ...)

xcpois(p, lambda, lower.tail = TRUE, log.p = FALSE, ...)

xcgeom(p, prob, lower.tail = TRUE, log.p = FALSE, ...)

xcnbinom(p, size, prob, mu, lower.tail = TRUE, log.p = FALSE, ...)

xcbeta(p, shape1, shape2, ncp = 0, lower.tail = TRUE, log.p = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cdist_+3A_dist">dist</code></td>
<td>
<p>a character string naming a distribution family (e.g., &quot;norm&quot;).
This will work for any family for which the usual d/p/q functions exist.</p>
</td></tr>
<tr><td><code id="cdist_+3A_p">p</code></td>
<td>
<p>the proportion to be in the central region, with equal proportions
in either &quot;tail&quot;.</p>
</td></tr>
<tr><td><code id="cdist_+3A_plot">plot</code></td>
<td>
<p>a logical indicating whether a plot should be created</p>
</td></tr>
<tr><td><code id="cdist_+3A_verbose">verbose</code></td>
<td>
<p>a logical indicating whether a more verbose output value should be returned.</p>
</td></tr>
<tr><td><code id="cdist_+3A_invisible">invisible</code></td>
<td>
<p>a logical</p>
</td></tr>
<tr><td><code id="cdist_+3A_digits">digits</code></td>
<td>
<p>the number of digits desired</p>
</td></tr>
<tr><td><code id="cdist_+3A_xlim">xlim</code></td>
<td>
<p>x limits.  By default, these are chosen to show the central 99.8\
of the distribution.</p>
</td></tr>
<tr><td><code id="cdist_+3A_ylim">ylim</code></td>
<td>
<p>y limits</p>
</td></tr>
<tr><td><code id="cdist_+3A_resolution">resolution</code></td>
<td>
<p>number of points used for detecting discreteness and generating plots.
The default value of 5000 should work well except for discrete distributions
that have many distinct values, especially if these values are not evenly spaced.</p>
</td></tr>
<tr><td><code id="cdist_+3A_return">return</code></td>
<td>
<p>If <code>"plot"</code>, return a plot.  If <code>"values"</code>, return a vector of numerical values.</p>
</td></tr>
<tr><td><code id="cdist_+3A_pattern">pattern</code></td>
<td>
<p>One of <code>"stripes"</code> or <code>"rings"</code>.
In the latter case, pairs of regions (from the outside to the inside)
are grouped together for coloring and probability calculation.</p>
</td></tr>
<tr><td><code id="cdist_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the distribution functions.  Typically
these specify the parameters of the particular distribution desired.  See the examples.</p>
</td></tr>
<tr><td><code id="cdist_+3A_refinements">refinements</code></td>
<td>
<p>A list of refinements to the plot.  See <code><a href="ggformula.html#topic+gf_aux">ggformula::gf_refine()</a></code>.</p>
</td></tr>
<tr><td><code id="cdist_+3A_shape">shape</code>, <code id="cdist_+3A_scale">scale</code></td>
<td>
<p>shape and scale parameters.  Must be positive,
<code>scale</code> strictly.</p>
</td></tr>
<tr><td><code id="cdist_+3A_rate">rate</code></td>
<td>
<p>an alternative way to specify the scale.</p>
</td></tr>
<tr><td><code id="cdist_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="cdist_+3A_log.p">log.p</code></td>
<td>
<p>A logical indicating whether probabilities should be
returned on the log scale.</p>
</td></tr>
<tr><td><code id="cdist_+3A_df">df</code></td>
<td>
<p>degrees of freedom (<code class="reqn">&gt; 0</code>, maybe non-integer).  <code>df
      = Inf</code> is allowed.</p>
</td></tr>
<tr><td><code id="cdist_+3A_ncp">ncp</code></td>
<td>
<p>non-centrality parameter <code class="reqn">\delta</code>;
currently except for <code>rt()</code>, only for <code>abs(ncp) &lt;= 37.62</code>.
If omitted, use the central t distribution.</p>
</td></tr>
<tr><td><code id="cdist_+3A_df1">df1</code>, <code id="cdist_+3A_df2">df2</code></td>
<td>
<p>degrees of freedom.  <code>Inf</code> is allowed.</p>
</td></tr>
<tr><td><code id="cdist_+3A_size">size</code></td>
<td>
<p>number of trials (zero or more).</p>
</td></tr>
<tr><td><code id="cdist_+3A_prob">prob</code></td>
<td>
<p>probability of success on each trial.</p>
</td></tr>
<tr><td><code id="cdist_+3A_lambda">lambda</code></td>
<td>
<p>vector of (non-negative) means.</p>
</td></tr>
<tr><td><code id="cdist_+3A_mu">mu</code></td>
<td>
<p>alternative parametrization via mean: see &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="cdist_+3A_shape1">shape1</code>, <code id="cdist_+3A_shape2">shape2</code></td>
<td>
<p>non-negative parameters of the Beta distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a pair of numbers indicating the upper and lower bounds, unless <code>verbose</code> is
<code>TRUE</code>, in which case a 1-row data frame is returned containing these bounds,
the central probability, the tail probabilities, and the name of the distribution.
</p>


<h3>Note</h3>

<p>This function is still experimental and changes the input or output
formats are possible in future versions of the package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cdist( "norm", .95)
cdist( "t", c(.90, .95, .99), df=5)
cdist( "t", c(.90, .95, .99), df=50)
# plotting doesn't work well when the parameters are not constant
cdist( "t", .95, df=c(3,5,10,20), plot = FALSE)
cdist( "norm", .95, mean=500, sd=100 )
cdist( "chisq", c(.90, .95), df=3 )
# CI
x &lt;- rnorm(23, mean = 10, sd = 2)
cdist("t", p = 0.95, df=22)
mean(x) + cdist("t", p = 0.95, df=22) * sd(x) / sqrt(23)
confint(t.test(x))
cdist("t", p = 0.95, df=22, verbose = TRUE)
</code></pre>

<hr>
<h2 id='chisq'>Extract Chi-squared statistic</h2><span id='topic+chisq'></span><span id='topic+chisq.htest'></span><span id='topic+chisq.table'></span><span id='topic+chisq.default'></span>

<h3>Description</h3>

<p>Extract Chi-squared statistic
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chisq(x, ...)

## S3 method for class 'htest'
chisq(x, ...)

## S3 method for class 'table'
chisq(x, correct = FALSE, ...)

## Default S3 method:
chisq(x, correct = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chisq_+3A_x">x</code></td>
<td>
<p>An object of class <code>"htest"</code> a coming from a Chi-squared test,
an object of class <code>"table"</code>, or
the inputs to <code><a href="#topic+tally">tally()</a></code>.</p>
</td></tr>
<tr><td><code id="chisq_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to <code>tally</code> or <code>chisq.test</code>.</p>
</td></tr>
<tr><td><code id="chisq_+3A_correct">correct</code></td>
<td>
<p>a logical indicating whether a continuity correction should be
applied.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="ggplot2.html#topic+after_stat">after_stat()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if(require(mosaicData)) {
  Mites.table &lt;- tally( ~ outcome + treatment, data=Mites )
  Mites.table 
  chisq.test(Mites.table)
  chisq(Mites.table)
  chisq(chisq.test(Mites.table))
  ## Randomization test.  Increase replications to decrease Monte Carlo error.
  do(3) * chisq( tally( ~ outcome + shuffle(treatment),  data=Mites ) )
  Mites.rand &lt;- do(1000) * chisq( tally( ~ outcome + shuffle(treatment),  data=Mites ) )
  tally( ~(X.squared &gt;= chisq(Mites.table)), data=Mites.rand, format="proportion")
}
  
</code></pre>

<hr>
<h2 id='CIAdata'>Return a dataset based on the CIA World Factbook</h2><span id='topic+CIAdata'></span>

<h3>Description</h3>

<p>This function can be used in two different ways. Without an argument, it returns a reference
table that includes information about all the CIA World Factbook tables that are available
through this function. Note the  <code>Name</code> column that indicates a unique name for each
available dataset. If this name is passed as an argument to the function, the function
will return the corresponding dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CIAdata(name = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CIAdata_+3A_name">name</code></td>
<td>
<p>An optional parameter specifying the name of the desired dataset.
If multiple names are given, a merge will be attempted on the individual data
sets.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
head(CIAdata())
Population &lt;- CIAdata("pop")
nrow(Population)
head(Population)

PopArea &lt;- 
  CIAdata(c("pop","area")) |&gt; 
  mutate(density = pop / area)
nrow(PopArea)
head(PopArea)
PopArea |&gt; 
  filter(!is.na(density)) |&gt;
  arrange(density) |&gt; 
  tail()

## End(Not run)
</code></pre>

<hr>
<h2 id='CIsim'>Compute confidence intervals from (multiple) simulated data sets</h2><span id='topic+CIsim'></span>

<h3>Description</h3>

<p>This function automates the calculation of coverage rates for exploring
the robustness of confidence interval methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CIsim(
  n,
  samples = 100,
  rdist = rnorm,
  args = list(),
  plot = if (samples &lt;= 200) "draw" else "none",
  estimand = 0,
  conf.level = 0.95,
  method = t.test,
  method.args = list(),
  interval = function(x) {
     do.call(method, c(list(x, conf.level = conf.level),
    method.args))$conf.int
 },
  estimate = function(x) {
     do.call(method, c(list(x, conf.level = conf.level),
    method.args))$estimate
 },
  verbose = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CIsim_+3A_n">n</code></td>
<td>
<p>size of each sample</p>
</td></tr>
<tr><td><code id="CIsim_+3A_samples">samples</code></td>
<td>
<p>number of samples to simulate</p>
</td></tr>
<tr><td><code id="CIsim_+3A_rdist">rdist</code></td>
<td>
<p>function used to draw random samples</p>
</td></tr>
<tr><td><code id="CIsim_+3A_args">args</code></td>
<td>
<p>arguments required by <code>rdist</code></p>
</td></tr>
<tr><td><code id="CIsim_+3A_plot">plot</code></td>
<td>
<p>one of <code>"print"</code>, <code>"return"</code>, <code>"horizontal"</code>, or <code>"none"</code>
describing whether a plot should be printed, returned, printed with horizontal intervals,
or not generated at all.</p>
</td></tr>
<tr><td><code id="CIsim_+3A_estimand">estimand</code></td>
<td>
<p>true value of the parameter being estimated</p>
</td></tr>
<tr><td><code id="CIsim_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level for intervals</p>
</td></tr>
<tr><td><code id="CIsim_+3A_method">method</code></td>
<td>
<p>function used to compute intervals.  Standard functions that
produce an object of class <code>htest</code> can be used here.</p>
</td></tr>
<tr><td><code id="CIsim_+3A_method.args">method.args</code></td>
<td>
<p>arguments required by <code>method</code></p>
</td></tr>
<tr><td><code id="CIsim_+3A_interval">interval</code></td>
<td>
<p>a function that computes a confidence interval from data.  Function
should return a vector of length 2.</p>
</td></tr>
<tr><td><code id="CIsim_+3A_estimate">estimate</code></td>
<td>
<p>a function that computes an estimate from data</p>
</td></tr>
<tr><td><code id="CIsim_+3A_verbose">verbose</code></td>
<td>
<p>print summary to screen?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with variables
<code>lower</code>,
<code>upper</code>,
<code>estimate</code>,
<code>cover</code> ('Yes' or 'No'),
and
<code>sample</code>
is returned invisibly.  See the examples for a way to use this to display the intervals
graphically.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1000 95% intervals using t.test; population is N(0,1)
CIsim(n = 10, samples = 1000)    
# this time population is Exp(1); fewer samples, so we get a plot 
CIsim(n = 10, samples = 100, rdist = rexp, estimand = 1) 
# Binomial treats 1 like success, 0 like failure
CIsim(n = 30, samples = 100, rdist = rbinom, args = list(size = 1, prob = .7), 
       estimand = .7, method = binom.test, method.args = list(ci = "Plus4"))  

</code></pre>

<hr>
<h2 id='cnorm'>Central Probability in a Normal or T Distribution</h2><span id='topic+cnorm'></span><span id='topic+ct'></span>

<h3>Description</h3>

<p>These versions of the quantile functions take a vector of
<em>central</em> probabilities as its first argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cnorm(p, mean = 0, sd = 1, log.p = FALSE, side = c("both", "upper", "lower"))

ct(p, df, ncp, log.p = FALSE, side = c("upper", "lower", "both"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cnorm_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="cnorm_+3A_mean">mean</code></td>
<td>
<p>vector of means.</p>
</td></tr>
<tr><td><code id="cnorm_+3A_sd">sd</code></td>
<td>
<p>vector of standard deviations.</p>
</td></tr>
<tr><td><code id="cnorm_+3A_log.p">log.p</code></td>
<td>
<p>logical.  If TRUE, uses the log of probabilities.</p>
</td></tr>
<tr><td><code id="cnorm_+3A_side">side</code></td>
<td>
<p>One of &quot;upper&quot;, &quot;lower&quot;, or &quot;both&quot; indicating
whether a vector of upper or lower quantiles or a matrix of
both should be returned.</p>
</td></tr>
<tr><td><code id="cnorm_+3A_df">df</code></td>
<td>
<p>degrees of freedom (<code class="reqn">&gt; 0</code>, maybe non-integer).  <code>df
      = Inf</code> is allowed.</p>
</td></tr>
<tr><td><code id="cnorm_+3A_ncp">ncp</code></td>
<td>
<p>non-centrality parameter <code class="reqn">\delta</code>;
currently except for <code>rt()</code>, only for <code>abs(ncp) &lt;= 37.62</code>.
If omitted, use the central t distribution.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+Normal">stats::qnorm()</a></code>, <code><a href="#topic+cdist">cdist()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qnorm(.975)
cnorm(.95)
xcnorm(.95)
xcnorm(.95, verbose = FALSE, return = "plot") |&gt;
  gf_refine(
  scale_fill_manual( values = c("navy", "limegreen")),
  scale_color_manual(values = c("black", "black")))
cnorm(.95, mean = 100, sd = 10)
xcnorm(.95, mean = 100, sd = 10)

</code></pre>

<hr>
<h2 id='compareMean'>Defunct functions</h2><span id='topic+compareMean'></span><span id='topic+compareProportion'></span><span id='topic+deltaMethod'></span><span id='topic+gwm'></span><span id='topic+r.squared'></span><span id='topic+mm'></span><span id='topic+perctable'></span><span id='topic+proptable'></span><span id='topic+xhistogram'></span>

<h3>Description</h3>

<p>The following functions were once a part of the mosaic pacakge but have
been removed.  In some cases, an alternative is available and is suggested
if you attempt to execute the function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compareMean(...)

compareProportion(...)

deltaMethod(...)

gwm(...)

r.squared(...)

mm(...)

perctable(...)

proptable(...)

xhistogram(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compareMean_+3A_...">...</code></td>
<td>
<p>arguments, ignored since the function is defunct</p>
</td></tr>
</table>

<hr>
<h2 id='confint'>Confidence interval methods for output of resampling</h2><span id='topic+confint'></span><span id='topic+confint.numeric'></span><span id='topic+confint.do.tbl_df'></span><span id='topic+confint.do.data.frame'></span><span id='topic+confint.data.frame'></span><span id='topic+confint.summary.lm'></span>

<h3>Description</h3>

<p>Methods for <code>confint</code> to compute confidence intervals
on numerical vectors and numerical components of data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'numeric'
confint(
  object,
  parm,
  level = 0.95,
  ...,
  method = "percentile",
  margin.of.error = "stderr" %in% method == "stderr"
)

## S3 method for class 'do.tbl_df'
confint(
  object,
  parm,
  level = 0.95,
  ...,
  method = "percentile",
  margin.of.error = "stderr" %in% method,
  df = NULL
)

## S3 method for class 'do.data.frame'
confint(
  object,
  parm,
  level = 0.95,
  ...,
  method = "percentile",
  margin.of.error = "stderr" %in% method,
  df = NULL
)

## S3 method for class 'data.frame'
confint(object, parm, level = 0.95, ...)

## S3 method for class 'summary.lm'
confint(object, parm, level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint_+3A_object">object</code></td>
<td>
<p>and R object</p>
</td></tr>
<tr><td><code id="confint_+3A_parm">parm</code></td>
<td>
<p>a vector of parameters</p>
</td></tr>
<tr><td><code id="confint_+3A_level">level</code></td>
<td>
<p>a confidence level</p>
</td></tr>
<tr><td><code id="confint_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="confint_+3A_method">method</code></td>
<td>
<p>a character vector of methods to use for creating confidence
intervals.  Choices are &quot;percentile&quot; (or &quot;quantile&quot;) which is the default,
&quot;stderr&quot; (or &quot;se&quot;), &quot;bootstrap-t&quot;, and
&quot;reverse&quot; (or &quot;basic&quot;))</p>
</td></tr>
<tr><td><code id="confint_+3A_margin.of.error">margin.of.error</code></td>
<td>
<p>if true, report intervals as a center and margin of error.</p>
</td></tr>
<tr><td><code id="confint_+3A_df">df</code></td>
<td>
<p>degrees for freedom. This is required when <code>object</code> was produced using
<code>link{do}</code> when
using the standard error to compute the confidence interval since
typically this information is not recorded in these objects.  The default (<code>Inf</code>)
uses a normal critical value rather than a one derived from a t-distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The methods of producing confidence intervals from bootstrap distributions are currently
quite naive.  In particular, when using the standard error, assistance may be required with the
degrees of freedom, and it may not be possible to provide a correct value in all situations.
None of the methods include explicit bias correction.
Let <code class="reqn">q_a</code> be the <code class="reqn">a</code> quantile of the bootstrap distribution,
let <code class="reqn">t_a, df</code> be the <code class="reqn">a</code> quantile of the t distribution with <code class="reqn">df</code>
degrees of freedom,
let <code class="reqn">SE_b</code> be the standard deviation of the bootstrap distribution,
and let <code class="reqn">\hat{\theta}</code> be the estimate computed from the original data.
Then the confidence intervals with confidence level <code class="reqn">1 - 2a</code> are
</p>

<dl>
<dt>quantile</dt><dd><p><code class="reqn">(q_a, q_{1-a}) </code> </p>
</dd>
<dt>reverse</dt><dd> <p><code class="reqn">( 2 \hat{\theta} - q_{1-a}, 2\hat{\theta} - q_{a} )</code></p>
</dd>
<dt>stderr</dt><dd><p><code class="reqn">(\hat{\theta} - t_{1-a,df} SE_b, \hat{\theta} + t_{1-a,df} SE_b) </code>.
When <code>df</code> is not provided,
at attempt is made to determine an appropriate value, but this should be double checked.
In particular, missing data an lead to unreliable results.
</p>
</dd>
</dl>
<p>The bootstrap-t confidence interval is computed much like the reverse confidence interval
but the bootstrap t distribution is used in place of a theoretical t distribution.
This interval has much better properties than the reverse (or basic) method, which
is here for comparison purposes only and is not recommended.  The t-statistic
is computed from a mean, a standard deviation, a sample size which much be named
<code>"mean"</code>, <code>"sd"</code>, and <code>"n"</code> as they are when using <code><a href="#topic+favstats">favstats()</a></code>.

</p>


<h3>Value</h3>

<p>When applied to a data frame, returns a data frame giving the
confidence interval for each variable in the data frame using
<code>t.test</code> or <code>binom.test</code>, unless the data frame was produced using <code>do</code>, in which case
it is assumed that each variable contains resampled statistics that serve as an estimated sampling
distribution from which a confidence interval can be computed using either a central proportion
of this distribution or using the standard error as estimated by the standard deviation of the
estimated sampling distribution.  For the standard error method, the user must supply the correct
degrees of freedom for the t distribution since this information is typically not available in
the output of <code><a href="#topic+do">do()</a></code>.
</p>
<p>When applied to a numerical vector, returns a vector.
</p>


<h3>References</h3>

<p>Tim C. Hesterberg (2015): What Teachers Should Know about the Bootstrap:
Resampling in the Undergraduate Statistics Curriculum,
The American Statistician,
<a href="https://www.tandfonline.com/doi/full/10.1080/00031305.2015.1089789">https://www.tandfonline.com/doi/full/10.1080/00031305.2015.1089789</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(mosaicData)) {
  bootstrap &lt;- do(500) * diffmean( age ~ sex, data = resample(HELPrct) )
  confint(bootstrap)
  confint(bootstrap, method = "percentile")
  confint(bootstrap, method = "boot")
  confint(bootstrap, method = "se", df = nrow(HELPrct) - 1)
  confint(bootstrap, margin.of.error = FALSE)
  confint(bootstrap, margin.of.error = TRUE, level = 0.99, 
    method = c("se", "perc") )
    
  # bootstrap t method requires both mean and sd
  bootstrap2 &lt;- do(500) * favstats(resample(1:10)) 
  confint(bootstrap2, method = "boot")
}
lm(width ~ length * sex, data = KidsFeet) |&gt;
  summary() |&gt;
  confint()
</code></pre>

<hr>
<h2 id='confint.htest'>Extract summary statistics</h2><span id='topic+confint.htest'></span><span id='topic+pval'></span><span id='topic+pval.htest'></span><span id='topic+stat'></span><span id='topic+stat.htest'></span><span id='topic+stat.uneval'></span>

<h3>Description</h3>

<p>Extract confidence intervals, test statistics or p-values from an
<code>htest</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'htest'
confint(object, parm, level, ...)

pval(x, ...)

## S3 method for class 'htest'
pval(x, digits = 4, verbose = FALSE, ...)

stat(x, ...)

## S3 method for class 'htest'
stat(x, ...)

## S3 method for class 'uneval'
stat(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="confint.htest_+3A_object">object</code></td>
<td>
<p>a fitted model object or an htest object.</p>
</td></tr>
<tr><td><code id="confint.htest_+3A_parm">parm</code></td>
<td>
<p>a specification of which parameters are to be given confidence intervals,
either a vector of numbers or a vector of names. If missing, all parameters are considered.</p>
</td></tr>
<tr><td><code id="confint.htest_+3A_level">level</code></td>
<td>
<p>the confidence level required.</p>
</td></tr>
<tr><td><code id="confint.htest_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
<tr><td><code id="confint.htest_+3A_x">x</code></td>
<td>
<p>An object of class <code>htest</code>.</p>
</td></tr>
<tr><td><code id="confint.htest_+3A_digits">digits</code></td>
<td>
<p>number of digits to display in verbose output</p>
</td></tr>
<tr><td><code id="confint.htest_+3A_verbose">verbose</code></td>
<td>
<p>a logical</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the extracted p-value, confidence interval, or test statistic
</p>


<h3>Examples</h3>

<pre><code class='language-R'>confint(t.test(rnorm(100)))
pval(t.test(rnorm(100)))
stat(t.test(rnorm(100)))
confint(var.test(rnorm(10,sd=1), rnorm(20, sd=2)))
pval(var.test(rnorm(10,sd=1), rnorm(20, sd=2)))
if (require(mosaicData)) {
data(HELPrct)
stat(t.test (age ~ shuffle(sex), data=HELPrct))
# Compare to test statistic computed with permuted values of sex.
do(10) * stat(t.test (age ~ shuffle(sex), data=HELPrct))
}
</code></pre>

<hr>
<h2 id='cor_test.formula'>Alternative formula interface for cor.test</h2><span id='topic+cor_test.formula'></span><span id='topic+cor.test'></span><span id='topic+cor_test'></span><span id='topic+cor_test.default'></span>

<h3>Description</h3>

<p><code><a href="stats.html#topic+cor.test">stats::cor.test()</a></code> in <span class="pkg">stats</span> accepts formulas of the
shape <code>~ y + x</code>.  The <span class="pkg">mosaic</span> package allows the use
of <code>y ~ x</code> as an alternative formula shape.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
cor_test(formula, ...)

cor.test(x, ...)

cor_test(x, ...)

## Default S3 method:
cor_test(x, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor_test.formula_+3A_formula">formula</code></td>
<td>
<p>a formula</p>
</td></tr>
<tr><td><code id="cor_test.formula_+3A_...">...</code></td>
<td>
<p>other arguments passed to <code><a href="stats.html#topic+cor.test">stats::cor.test()</a></code>.</p>
</td></tr>
<tr><td><code id="cor_test.formula_+3A_x">x</code>, <code id="cor_test.formula_+3A_y">y</code></td>
<td>
<p>numeric vectors of data values. x and y must have the same length.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+cor.test">stats::cor.test()</a></code> in the <span class="pkg">stats</span> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># This is an example from example(stats::cor.test) done in old and new style
require(graphics)
cor.test(~ CONT + INTG, data = USJudgeRatings)
cor.test(CONT ~ INTG, data = USJudgeRatings)
</code></pre>

<hr>
<h2 id='cross'>Factor cross products</h2><span id='topic+cross'></span>

<h3>Description</h3>

<p>Construct a product of factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cross(..., sep = ":", drop.unused.levels = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cross_+3A_...">...</code></td>
<td>
<p>factors to be crossed.</p>
</td></tr>
<tr><td><code id="cross_+3A_sep">sep</code></td>
<td>
<p>separator between levels</p>
</td></tr>
<tr><td><code id="cross_+3A_drop.unused.levels">drop.unused.levels</code></td>
<td>
<p>should levels that do not appear in cross product be dropped?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a factor
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- letters[1:3]
y &lt;- c(1,2,1,1,3,1,3)
cross(x, y)
cross(x, y, drop.unused.levels=TRUE)

</code></pre>

<hr>
<h2 id='cull_for_do'>Cull objects used with do()</h2><span id='topic+cull_for_do'></span>

<h3>Description</h3>

<p>The <code><a href="#topic+do">do()</a></code> function facilitates easy replication for
randomization tests and bootstrapping (among other things).  Part of what
makes this particularly useful is the ability to cull from the objects
produced those elements that are useful for subsequent analysis.
<code>cull_for_do</code> does this culling.  It is generic, and users
can add new methods to either change behavior or to handle additional
classes of objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cull_for_do(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cull_for_do_+3A_object">object</code></td>
<td>
<p>an object to be culled</p>
</td></tr>
<tr><td><code id="cull_for_do_+3A_...">...</code></td>
<td>
<p>additional arguments (currently ignored)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>do(n) * expression</code> is evaluated, <code>expression</code>
is evaluated <code>n</code> times to produce a list of <code>n</code> result objects.
<code>cull_for_do</code> is then applied to each element of this list to
extract from it the information that should be stored.  For example,
when applied to a object of class <code>"lm"</code>,
the default <code>cull_for_do</code> extracts the coefficients, coefficient
of determinism, an the estimate for the variance, etc.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cull_for_do(lm(length ~ width, data = KidsFeet))
do(1) * lm(length ~ width, data = KidsFeet)
</code></pre>

<hr>
<h2 id='deg2rad'>Convert between degrees and radians</h2><span id='topic+deg2rad'></span><span id='topic+rad2deg'></span>

<h3>Description</h3>

<p>Facilitates conversion between degrees and radians.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deg2rad(x)

rad2deg(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deg2rad_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a numeric vector
</p>


<h3>See Also</h3>

<p><code><a href="#topic+latlon2xyz">latlon2xyz()</a></code>, <code><a href="#topic+googleMap">googleMap()</a></code>, and <code><a href="#topic+rgeo">rgeo()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>deg2rad(180)
rad2deg(2*pi)
</code></pre>

<hr>
<h2 id='derivedVariable'>Create new variables from logicals</h2><span id='topic+derivedVariable'></span><span id='topic+derivedFactor'></span>

<h3>Description</h3>

<p>Utility functions for creating new variables from logicals describing the levels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derivedVariable(
  ...,
  .ordered = FALSE,
  .method = c("unique", "first", "last"),
  .debug = c("default", "always", "never"),
  .sort = c("given", "alpha"),
  .default = NULL,
  .asFactor = FALSE
)

derivedFactor(..., .asFactor = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derivedVariable_+3A_...">...</code></td>
<td>
<p>named logical &quot;rules&quot; defining the levels.</p>
</td></tr>
<tr><td><code id="derivedVariable_+3A_.ordered">.ordered</code></td>
<td>
<p>a logical indicating whether the resulting factored should be ordered
Ignored if <code>.asFactor</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="derivedVariable_+3A_.method">.method</code></td>
<td>
<p>one of <code>"unique"</code>, <code>"first"</code>, and <code>"last"</code>.
If <code>"unique"</code>, exactly one rule must be <code>TRUE</code> for each position.
If <code>"first"</code>, the first <code>TRUE</code> rule defines the level.
If <code>"last"</code>, the last <code>TRUE</code> rule defines the level.</p>
</td></tr>
<tr><td><code id="derivedVariable_+3A_.debug">.debug</code></td>
<td>
<p>one of <code>"default"</code>, <code>"always"</code>, and <code>"never"</code>, indicating
whether debugging information should be printed.  If <code>"default"</code>, debugging
information is printed only when multiple rules give conflicting definitions
for some positions.</p>
</td></tr>
<tr><td><code id="derivedVariable_+3A_.sort">.sort</code></td>
<td>
<p>One of <code>"given"</code> (the default) or <code>"alpha"</code> or
a vector of integers the same length as the number of levels indicating the
order in which the levels should appear in the resulting factor.
Ignored if <code>.asFactor</code> is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="derivedVariable_+3A_.default">.default</code></td>
<td>
<p>character vector of length 1 giving name of default level or
<code>NULL</code> for no default.</p>
</td></tr>
<tr><td><code id="derivedVariable_+3A_.asfactor">.asFactor</code></td>
<td>
<p>A logical indicating whether the returned value should be a factor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each logical &quot;rule&quot; corresponds to a level in the resulting variable.
If <code>.default</code> is defined, an implicit rule is added that is <code>TRUE</code>
whenever all other rules are <code>FALSE</code>.
When there are multiple <code>TRUE</code> rules for a slot, the first or last such is used
or an error is generated, depending on the value of <code>method</code>.
</p>
<p><code>derivedVariable</code> is designed to be used with <code><a href="base.html#topic+transform">transform()</a></code> or
<code><a href="dplyr.html#topic+mutate">dplyr::mutate()</a></code> to add new
variables to a data frame.  <code>derivedFactor</code>() is the same but that the
default value for <code>.asFactor</code> is <code>TRUE</code>.  See the examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Kf &lt;- mutate(KidsFeet, biggerfoot2 = derivedFactor(
                   dom = biggerfoot == domhand,
                   nondom = biggerfoot != domhand)
                   )
tally( ~ biggerfoot + biggerfoot2, data = Kf)
tally( ~ biggerfoot + domhand, data = Kf)

# Three equivalent ways to define a new variable
# Method 1: explicitly define all levels
modHELP &lt;- mutate(HELPrct, drink_status = derivedFactor( 
  abstinent = i1 == 0,
  moderate = (i1&gt;0 &amp; i1&lt;=1 &amp; i2&lt;=3 &amp; sex=='female') |
     (i1&gt;0 &amp; i1&lt;=2 &amp; i2&lt;=4 &amp; sex=='male'),
  highrisk = ((i1&gt;1 | i2&gt;3) &amp; sex=='female') | 
      ((i1&gt;2 | i2&gt;4) &amp; sex=='male'),
  .ordered = TRUE)
)
tally( ~ drink_status, data = modHELP)

# Method 2: Use .default for last level
modHELP &lt;- mutate(HELPrct, drink_status = derivedFactor( 
  abstinent = i1 == 0,
  moderate = (i1&lt;=1 &amp; i2&lt;=3 &amp; sex=='female') |
     (i1&lt;=2 &amp; i2&lt;=4 &amp; sex=='male'),
  .ordered = TRUE,
  .method = "first",
  .default = "highrisk")
)
tally( ~ drink_status, data = modHELP)

# Method 3: use TRUE to catch any fall through slots
modHELP &lt;- mutate(HELPrct, drink_status = derivedFactor( 
  abstinent = i1 == 0,
  moderate = (i1&lt;=1 &amp; i2&lt;=3 &amp; sex=='female') |
     (i1&lt;=2 &amp; i2&lt;=4 &amp; sex=='male'),
  highrisk=TRUE,
  .ordered = TRUE,
  .method = "first"
  )
)
tally( ~ drink_status, data = modHELP)
is.factor(modHELP$drink_status)

modHELP &lt;- mutate(HELPrct, drink_status = derivedVariable( 
  abstinent = i1 == 0,
  moderate = (i1&lt;=1 &amp; i2&lt;=3 &amp; sex=='female') |
     (i1&lt;=2 &amp; i2&lt;=4 &amp; sex=='male'),
  highrisk=TRUE,
  .ordered = TRUE,
  .method = "first"
  )
)
is.factor(modHELP$drink_status)
</code></pre>

<hr>
<h2 id='design_plot'>Interactively design plots</h2><span id='topic+design_plot'></span>

<h3>Description</h3>

<p>Proves a simple interface to let users interactively design plots in <span class="pkg">ggformula</span>, <span class="pkg">lattice</span>, or <span class="pkg">ggplot2</span>.
An option is available to show the code used to create the plot.
This can be copied and pasted elsewhere to (into an RMarkdown document, for example) to recreate the plot.
Only works in RStudio. Requires the <span class="pkg">manipulate</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>design_plot(
  data,
  format,
  default = format,
  system = system_choices()[1],
  show = FALSE,
  title = "",
  data_text = rlang::expr_deparse(substitute(data)),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="design_plot_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables that might be used in the plot.
Note that for maps, the data frame must contain coordinates of the polygons
comprising the map and a variable for determining which coordinates are part
of the same region.  See <code><a href="#topic+sp2df">sp2df()</a></code> for one way to create such
a data frame.  Typically <code><a href="base.html#topic+merge">merge()</a></code> will be used to combine the map
data with some auxiliary data to be displayed as fill color on the map, although
this is not necessary if all one wants is a map.</p>
</td></tr>
<tr><td><code id="design_plot_+3A_format">format</code></td>
<td>
<p>a synonym for <code>default</code>.</p>
</td></tr>
<tr><td><code id="design_plot_+3A_default">default</code></td>
<td>
<p>default type of plot to create; one of
<code>"scatter"</code>,
<code>"jitter"</code>,
<code>"boxplot"</code>,
<code>"violin"</code>,
<code>"sina"</code>,
<code>"histogram"</code>,
<code>"density"</code>,
<code>"density (contours)"</code>,
<code>"density (filled)"</code>,
<code>"frequency polygon"</code>,
<code>"xyplot"</code>,
or
<code>"map"</code>.  Unique prefixes suffice.</p>
</td></tr>
<tr><td><code id="design_plot_+3A_system">system</code></td>
<td>
<p>which graphics system to use (initially) for plotting (<span class="pkg">ggplot2</span>
or <span class="pkg">lattice</span>).  A check box will allow on the fly change of plotting system.</p>
</td></tr>
<tr><td><code id="design_plot_+3A_show">show</code></td>
<td>
<p>a logical, if <code>TRUE</code>, the code will be displayed each time the plot is
changed.</p>
</td></tr>
<tr><td><code id="design_plot_+3A_title">title</code></td>
<td>
<p>a title for the plot</p>
</td></tr>
<tr><td><code id="design_plot_+3A_data_text">data_text</code></td>
<td>
<p>A text string describing the data.  It must be possible to recover the data
from this string using <code><a href="base.html#topic+eval">eval()</a></code>.  Typically users will not need to
modify this from the default value.</p>
</td></tr>
<tr><td><code id="design_plot_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently maps are only supported in <span class="pkg">ggplot2</span> and not in <span class="pkg">lattice</span>.
</p>
<p>Due to an unresolved issue with RStudio, the first time this function is called, and additional
plot is created to correctily initialize the mainipulate frameowrk.
</p>


<h3>Value</h3>

<p>Nothing.  Used for side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  mtcars2 &lt;- 
    mtcars |&gt; 
      mutate(
        cyl2 = factor(cyl), 
        carb2 = factor(carb),
        shape = c("V-shaped", "straight")[1 + vs], 
        gear2 = factor(gear), 
        transmission = c("automatic", "manual")[1 + am])
  design_plot(mtcars2)

## End(Not run)
</code></pre>

<hr>
<h2 id='diffmean'>Difference in means and proportions</h2><span id='topic+diffmean'></span><span id='topic+diffprop'></span>

<h3>Description</h3>

<p>Wrappers around <code>diff(mean(...))</code> and <code>diff(prop(...))</code> that
facilitate better naming of the result
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diffmean(x, ..., data = parent.frame(), only.2 = TRUE)

diffprop(x, ..., data = parent.frame(), only.2 = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diffmean_+3A_x">x</code>, <code id="diffmean_+3A_data">data</code>, <code id="diffmean_+3A_...">...</code></td>
<td>
<p>as in <code><a href="#topic+mean">mean()</a></code> or <code><a href="#topic+prop">prop()</a></code></p>
</td></tr>
<tr><td><code id="diffmean_+3A_only.2">only.2</code></td>
<td>
<p>a logical indicating whether differences should only be computed
between two groups.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(mosaicData)) {
diffprop( homeless ~ sex , data=HELPrct)
do(3) * diffprop( homeless ~ shuffle(sex) , data=HELPrct)
diffmean( age ~ substance, data=HELPrct, only.2=FALSE)
do(3) * diffmean(age ~ shuffle(substance), data=HELPrct, only.2=FALSE)
diffmean( age ~ sex, data=HELPrct)
do(3) * diffmean(age ~ shuffle(sex), data=HELPrct)
}
</code></pre>

<hr>
<h2 id='do'>Do Things Repeatedly</h2><span id='topic+do'></span><span id='topic+do.numeric'></span><span id='topic+do.default'></span><span id='topic+Do'></span><span id='topic+print.repeater'></span><span id='topic++2A+2Crepeater+2CANY-method'></span>

<h3>Description</h3>

<p><code>do()</code> provides a natural syntax for repetition tuned to assist
with replication and resampling methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>do(object, ...)

## S3 method for class 'numeric'
do(object, ...)

## Default S3 method:
do(object, ...)

Do(n = 1L, cull = NULL, mode = "default", algorithm = 1, parallel = TRUE)

## S3 method for class 'repeater'
print(x, ...)

## S4 method for signature 'repeater,ANY'
e1 * e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="do_+3A_object">object</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="do_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="do_+3A_n">n</code></td>
<td>
<p>number of times to repeat</p>
</td></tr>
<tr><td><code id="do_+3A_cull">cull</code></td>
<td>
<p>function for culling output of objects being repeated.  If NULL,
a default culling function is used.  The default culling function is
currently aware of objects of types
<code>lme</code>,
<code>lm</code>,
<code>htest</code>,
<code>table</code>,
<code>cointoss</code>, and
<code>matrix</code>.</p>
</td></tr>
<tr><td><code id="do_+3A_mode">mode</code></td>
<td>
<p>target mode for value returned</p>
</td></tr>
<tr><td><code id="do_+3A_algorithm">algorithm</code></td>
<td>
<p>a number used to select the algorithm used.  Currently numbers below 1
use an older algorithm and numbers &gt;=1 use a newer algorithm which is faster in some
situations.</p>
</td></tr>
<tr><td><code id="do_+3A_parallel">parallel</code></td>
<td>
<p>a logical indicating whether parallel computation should be attempted
using the <span class="pkg">parallel</span> package (if it is installed and loaded).</p>
</td></tr>
<tr><td><code id="do_+3A_x">x</code></td>
<td>
<p>an object created by <code>do</code>.</p>
</td></tr>
<tr><td><code id="do_+3A_e1">e1</code></td>
<td>
<p>an object (in cases documented here, the result of running <code>do</code>)</p>
</td></tr>
<tr><td><code id="do_+3A_e2">e2</code></td>
<td>
<p>an object (in cases documented here, an expression to be repeated)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>do</code> returns an object of class <code>repeater</code> which is only useful in
the context of the operator <code>*</code>.  See the examples.
</p>


<h3>Naming</h3>

<p>The names used in the object returned from <code>do()</code> are inferred from the
objects created in each replication.  Roughly, this the strategy employed.
</p>

<ul>
<li><p> If the objects have names, those names are inherited, if possible.
</p>
</li>
<li><p> If the objects do not have names, but <code>do()</code> is used with a simple
function call, the name of that function is used.
Example: <code>do(3) * mean(~height, data = Galton)</code> produces a data frame with
a variable named <code>mean</code>.
</p>
</li>
<li><p> In cases where names are not easily inferred and a single result is produced,
it is named <code>result</code>.
</p>
</li></ul>

<p>To get different names, one can rename the objects as they are created, or
rename the result returned from <code>do()</code>.  Example of the former:
<code>do(3) * c(mean_height = mean(~height, data = resample(Galton)))</code>.
</p>


<h3>Note</h3>

<p><code>do</code> is a thin wrapper around <code>Do</code> to avoid collision with
<code><a href="dplyr.html#topic+do">dplyr::do()</a></code> from the <span class="pkg">dplyr</span> package.
</p>


<h3>Author(s)</h3>

<p>Daniel Kaplan (<a href="mailto:kaplan@macalaster.edu">kaplan@macalaster.edu</a>)
and Randall Pruim (<a href="mailto:rpruim@calvin.edu">rpruim@calvin.edu</a>)
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+replicate">replicate()</a></code>, <code><a href="#topic+set.rseed">set.rseed()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>do(3) * rnorm(1)
do(3) * "hello"
do(3) * 1:4
do(3) * mean(rnorm(25))
do(3) * lm(shuffle(height) ~ sex + mother, Galton)
do(3) * anova(lm(shuffle(height) ~ sex + mother, Galton))
do(3) * c(sample.mean = mean(rnorm(25)))
# change the names on the fly
do(3) * mean(~height, data = resample(Galton))
do(3) * c(mean_height = mean(~height, data = resample(Galton)))
set.rseed(1234)
do(3) * tally( ~sex|treat, data=resample(HELPrct))
set.rseed(1234)  # re-using seed gives same results again
do(3) * tally( ~sex|treat, data=resample(HELPrct))
</code></pre>

<hr>
<h2 id='docFile'>Return the path to a documentation file in a package</h2><span id='topic+docFile'></span>

<h3>Description</h3>

<p>Return the path to a documentation file in a package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>docFile(file, package = "mosaic", character.only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="docFile_+3A_file">file</code></td>
<td>
<p>the name of a file</p>
</td></tr>
<tr><td><code id="docFile_+3A_package">package</code></td>
<td>
<p>the name of a package</p>
</td></tr>
<tr><td><code id="docFile_+3A_character.only">character.only</code></td>
<td>
<p>a logical. If <code>TRUE</code> package names must be
specified as character, else names will be converted as a convenience
as is <code><a href="base.html#topic+library">library()</a></code> and <code><a href="base.html#topic+library">library()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector specifying the path to the file on the user's system.
</p>

<hr>
<h2 id='dotPlot'>Dotplots</h2><span id='topic+dotPlot'></span><span id='topic+panel.dotPlot'></span>

<h3>Description</h3>

<p>A high level function and panel function for producing
a variant of a histogram called a dotplot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dotPlot(x, breaks, ..., panel = panel.dotPlot)

panel.dotPlot(
  x,
  breaks,
  equal.widths = TRUE,
  groups = NULL,
  nint = if (is.factor(x)) nlevels(x) else round(1.3 * log2(length(x)) + 4),
  pch,
  col,
  lty = trellis.par.get("dot.line")$lty,
  lwd = trellis.par.get("dot.line")$lwd,
  col.line = trellis.par.get("dot.line")$col,
  alpha = trellis.par.get("dot.symbol")$alpha,
  cex = 1,
  type = "count",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dotPlot_+3A_x">x</code></td>
<td>
<p>a vector of values or a formula</p>
</td></tr>
<tr><td><code id="dotPlot_+3A_breaks">breaks</code>, <code id="dotPlot_+3A_equal.widths">equal.widths</code>, <code id="dotPlot_+3A_groups">groups</code>, <code id="dotPlot_+3A_pch">pch</code>, <code id="dotPlot_+3A_col">col</code>, <code id="dotPlot_+3A_lty">lty</code>, <code id="dotPlot_+3A_lwd">lwd</code>, <code id="dotPlot_+3A_col.line">col.line</code>, <code id="dotPlot_+3A_type">type</code>, <code id="dotPlot_+3A_alpha">alpha</code></td>
<td>
<p>as in <code><a href="#topic+histogram">histogram()</a></code></p>
</td></tr>
<tr><td><code id="dotPlot_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="dotPlot_+3A_panel">panel</code></td>
<td>
<p>a panel function</p>
</td></tr>
<tr><td><code id="dotPlot_+3A_nint">nint</code></td>
<td>
<p>the number of intervals to use</p>
</td></tr>
<tr><td><code id="dotPlot_+3A_cex">cex</code></td>
<td>
<p>a ratio by which to increase or decrease the dot size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a trellis object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+histogram">histogram()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(mosaicData)) {
dotPlot( ~ age, data = HELPrct)
dotPlot( ~ age, nint=42, data = HELPrct)
dotPlot( ~ height | voice.part, data = singer, nint = 17,
          endpoints = c(59.5, 76.5), layout = c(4,2), aspect = 1,
          xlab = "Height (inches)")
}
</code></pre>

<hr>
<h2 id='dpqrdist'>Distribution wrapper</h2><span id='topic+dpqrdist'></span>

<h3>Description</h3>

<p>Utility function wrapping up the d/p/q/r distribution functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpqrdist(dist, type = c("d", "p", "q", "r"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dpqrdist_+3A_dist">dist</code></td>
<td>
<p>a character description of a distribution, for example
<code>"norm"</code>, <code>"t"</code>, or <code>"chisq"</code></p>
</td></tr>
<tr><td><code id="dpqrdist_+3A_type">type</code></td>
<td>
<p>one of <code>"x"</code>, <code>"p"</code>, <code>"q"</code>, or <code>"r"</code></p>
</td></tr>
<tr><td><code id="dpqrdist_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to underlying distribution function.
Note that one of <code>d</code>, <code>p</code>, <code>q</code>, or <code>n</code> must
be a named argument in ...</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># 3 random draws from N(1,2)
dpqrdist("norm", "r", n = 3, mean = 1, sd = 2)
# These should all be the same
dpqrdist("norm", "d", x = 0) == dnorm(x = 0)
dpqrdist("norm", "p", q = 0, mean = 1, sd = 2) == pnorm(q = 0, mean = 1, sd = 2)
dpqrdist("norm", "q", p = 0.5, mean = 1, sd = 2) == qnorm(p = 0.5, mean = 1, sd = 2)
</code></pre>

<hr>
<h2 id='expandFun'>Expand the left-hand side of a formula</h2><span id='topic+expandFun'></span>

<h3>Description</h3>

<p>Expands the contents of functions used in a formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expandFun(formula, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expandFun_+3A_formula">formula</code></td>
<td>
<p>A mathematical expression (see examples and <code><a href="#topic+plotFun">plotFun()</a></code>)</p>
</td></tr>
<tr><td><code id="expandFun_+3A_...">...</code></td>
<td>
<p>additional parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the new expanded formula and the combined formals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f=makeFun(x^2~x)
expandFun(f(z)~z) #Returns z^2~z
</code></pre>

<hr>
<h2 id='factorize'>Conditionally convert vectors to factors</h2><span id='topic+factorize'></span><span id='topic+factorize.default'></span><span id='topic+factorize.numeric'></span><span id='topic+factorize.character'></span><span id='topic+factorize.data.frame'></span><span id='topic+factorise'></span>

<h3>Description</h3>

<p>A generic function and several instances for creating factors from
other sorts of data.  The primary use case is for vectors that contain
few unique values and might be better considered as factors.  When
applied to a data frame, this is applied to each variable in the data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>factorize(x, ...)

## Default S3 method:
factorize(x, ...)

## S3 method for class 'numeric'
factorize(x, max.levels = 5L, ...)

## S3 method for class 'character'
factorize(x, max.levels = 5L, ...)

## S3 method for class 'data.frame'
factorize(x, max.levels = 5L, ...)

factorise(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="factorize_+3A_x">x</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="factorize_+3A_...">...</code></td>
<td>
<p>additional arguments (currently ignored)</p>
</td></tr>
<tr><td><code id="factorize_+3A_max.levels">max.levels</code></td>
<td>
<p>an integer.  Only convert if the number of unique values is no
more than <code>max.levels</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(KidsFeet, package="mosaicData")
str(KidsFeet)
factorize(KidsFeet$birthyear)
str(factorize(KidsFeet))
# alternative spelling
str(factorise(KidsFeet))
</code></pre>

<hr>
<h2 id='fav_stats'>Some favorite statistical summaries</h2><span id='topic+fav_stats'></span>

<h3>Description</h3>

<p>Likely you mean to be using <code><a href="#topic+favstats">favstats()</a></code>.  Each of these computes the
mean, standard deviation, quartiles, sample size and number of missing values for a numeric vector,
but <code><a href="#topic+favstats">favstats()</a></code> can take a formula describing how these summary statistics
should be aggregated across various subsets of the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fav_stats(x, ..., na.rm = TRUE, type = 7)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fav_stats_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
<tr><td><code id="fav_stats_+3A_...">...</code></td>
<td>
<p>additional arguments (currently ignored)</p>
</td></tr>
<tr><td><code id="fav_stats_+3A_na.rm">na.rm</code></td>
<td>
<p>boolean indicating whether missing data should be ignored</p>
</td></tr>
<tr><td><code id="fav_stats_+3A_type">type</code></td>
<td>
<p>an integer between 1 and 9 selecting one of the nine quantile algorithms detailed
in the documentation for <code><a href="stats.html#topic+quantile">stats::quantile()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of statistical summaries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fav_stats(1:10)
fav_stats(faithful$eruptions)
data(penguins, package = "palmerpenguins")

# Note: this is favstats() rather than fav_stats()
favstats(bill_length_mm ~ species, data = penguins)  
</code></pre>

<hr>
<h2 id='fetchData'>Defunct functions now in the fetch package</h2><span id='topic+fetchData'></span><span id='topic+fetchGapminder1'></span><span id='topic+fetchGapminder'></span><span id='topic+fetchGoogle'></span>

<h3>Description</h3>

<p>These functions have been moved to the fetch package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fetchData(...)

fetchGapminder1(...)

fetchGapminder(...)

fetchGoogle(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fetchData_+3A_...">...</code></td>
<td>
<p>arguments</p>
</td></tr>
</table>

<hr>
<h2 id='findZeros'>Find zeros of functions</h2><span id='topic+findZeros'></span><span id='topic+solve.formula'></span>

<h3>Description</h3>

<p>Compute numerically zeros of a function or simultaneous zeros of multiple functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findZeros(
  expr,
  ...,
  xlim = c(near - within, near + within),
  near = 0,
  within = Inf,
  nearest = 10,
  npts = 1000,
  iterate = 1,
  sortBy = c("byx", "byy", "radial")
)

## S3 method for class 'formula'
solve(
  form,
  ...,
  near = 0,
  within = Inf,
  nearest = 10,
  npts = 1000,
  iterate = 1,
  sortBy = c("byx", "byy", "radial")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findZeros_+3A_expr">expr</code></td>
<td>
<p>A formula.  The right side names the variable with respect to which the zeros should be found.
The left side is an expression, e.g. <code>sin(x) ~ x</code>.
All free variables (all but the variable on the right side) named in the expression must be assigned
a value via <code style="white-space: pre;">&#8288;\ldots&#8288;</code></p>
</td></tr>
<tr><td><code id="findZeros_+3A_...">...</code></td>
<td>
<p>Formulas corresponding to additional functions to use in simultaneous zero finding
and/or specific numerical values for the free variables in the expression.</p>
</td></tr>
<tr><td><code id="findZeros_+3A_xlim">xlim</code></td>
<td>
<p>The range of the dependent variable to search for zeros. <code>Inf</code> is a legitimate value,
but is interpreted in the numerical sense as the non-Inf largest floating point number.  This can also
be specified replacing <code>x</code> with the name of the variable.  See the examples.</p>
</td></tr>
<tr><td><code id="findZeros_+3A_near">near</code></td>
<td>
<p>a value near which zeros are desired</p>
</td></tr>
<tr><td><code id="findZeros_+3A_within">within</code></td>
<td>
<p>only look for zeros at least this close to near.  <code>near</code> and <code>within</code> provide an
alternative to using <code>xlim</code> to specify the search space.</p>
</td></tr>
<tr><td><code id="findZeros_+3A_nearest">nearest</code></td>
<td>
<p>the number of nearest zeros to return.  Fewer are returned if fewer are found.</p>
</td></tr>
<tr><td><code id="findZeros_+3A_npts">npts</code></td>
<td>
<p>How many sub-intervals to divide the <code>xlim</code> into when looking for candidates for zeros.
The default is usually good enough.
If <code>Inf</code> is involved, the intervals are logarithmically spaced up to the largest finite floating point number.
There is no guarantee that all the roots will be found.</p>
</td></tr>
<tr><td><code id="findZeros_+3A_iterate">iterate</code></td>
<td>
<p>maximum number of times to iterate the search. Subsequent searches take place with the range
of previously found zeros.  Choosing a large number here is likely to kill performance without
improving results, but a value of 1 (the default) or 2 works well when searching in <code>c(-Inf,Inf)</code> for
a modest number of zeros near <code>near</code>.</p>
</td></tr>
<tr><td><code id="findZeros_+3A_sortby">sortBy</code></td>
<td>
<p>specifies how the zeros found will be sorted. Options are 'byx', 'byy', or 'radial'.</p>
</td></tr>
<tr><td><code id="findZeros_+3A_form">form</code></td>
<td>
<p>Expression to be solved</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Searches numerically using <code>uniroot</code>.
</p>
<p>Uses findZerosMult of findZeros to solve the given expression
</p>


<h3>Value</h3>

<p>A dataframe of zero or more numerical values.  Plugging these into the
expression on the left side of the formula should result in values near zero.
</p>
<p>a dataframe with solutions to the expression.
</p>


<h3>Author(s)</h3>

<p>Daniel Kaplan (<a href="mailto:kaplan@macalester.edu">kaplan@macalester.edu</a>)
</p>
<p>Cecylia Bocovich
</p>


<h3>Examples</h3>

<pre><code class='language-R'>findZeros( sin(t) ~ t, xlim=c(-10,10) )
# Can use tlim or t.lim instead of xlim if we prefer
findZeros( sin(t) ~ t, tlim=c(-10,10) )
findZeros( sin(theta) ~ theta, near=0, nearest=20)
findZeros( A*sin(2*pi*t/P) ~ t, xlim=c(0,100), P=50, A=2)
# Interval of a normal at half its maximum height.
findZeros( dnorm(x,mean=0,sd=10) - 0.5*dnorm(0,mean=0,sd=10) ~ x )
# A pathological example
# There are no "neareset" zeros for this function.  Each iteration finds new zeros.
f &lt;- function(x) { if (x==0) 0 else sin(1/x) }
findZeros( f(x) ~ x, near=0 )
# Better to look nearer to 0
findZeros( f(x) ~ x, near=0, within=100 )
findZeros( f(x) ~ x, near=0, within=100, iterate=0 )
findZeros( f(x) ~ x, near=0, within=100, iterate=3 )
# Zeros in multiple dimensions (not run: these take a long time)
# findZeros(x^2+y^2+z^2-5~x&amp;y&amp;z, nearest=3000, within = 5)
# findZeros(x*y+z^2~z&amp;y&amp;z, z+y~x&amp;y&amp;z, npts=10)
solve(3*x==3~x)

# plot out sphere (not run)
# sphere = solve(x^2+y^2+z^2==5~x&amp;y&amp;z, within=5, nearest=1000)
# cloud(z~x+y, data=sphere)
</code></pre>

<hr>
<h2 id='findZerosMult'>Find the zeros of a function of two or more variables</h2><span id='topic+findZerosMult'></span>

<h3>Description</h3>

<p>Compute numerically zeros of a function of two or more variables.
All free variables (all but the variable on the right side) named in the expression must be assigned
a value via <code style="white-space: pre;">&#8288;\ldots&#8288;</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findZerosMult(..., npts = 10, rad = 5, near = 0, sortBy = "byx")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findZerosMult_+3A_...">...</code></td>
<td>
<p>arguments for values NOTE: if the system has more than one equation and the rhs
variables do not match up, there will be an error.</p>
</td></tr>
<tr><td><code id="findZerosMult_+3A_npts">npts</code></td>
<td>
<p>number of desired zeros to return</p>
</td></tr>
<tr><td><code id="findZerosMult_+3A_rad">rad</code></td>
<td>
<p>radius around near in which to look for zeros</p>
</td></tr>
<tr><td><code id="findZerosMult_+3A_near">near</code></td>
<td>
<p>center of search for zeros</p>
</td></tr>
<tr><td><code id="findZerosMult_+3A_sortby">sortBy</code></td>
<td>
<p>options for sorting zeros for plotting.  Options are 'byx', 'byy' and 'radial'.  The
default value is 'byx'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>sorts points in the domain according to the sign of the function value at respective points.
Use continuity and uniroot to find zeros between points of opposite signs.  Returns any number of
points which may be sorted and plotted according to x, y, or radial values.
</p>


<h3>Value</h3>

<p>A data frame of numerical values which should all result in a value of zero when input into
original function
</p>


<h3>Author(s)</h3>

<p>Cecylia Bocovich
</p>


<h3>Examples</h3>

<pre><code class='language-R'>findZerosMult(a*x^2-8~a&amp;x, npts = 50)
findZerosMult(a^2+x^2-8~a&amp;x, npts = 100, sortBy='radial')
## Not run: findZerosMult(a^2+x^2-8~a&amp;x, npts = 1000, sortBy='radial')
</code></pre>

<hr>
<h2 id='fitModel'>Fit a nonlinear least squares model</h2><span id='topic+fitModel'></span><span id='topic+model'></span><span id='topic+model.nlsfunction'></span><span id='topic+summary.nlsfunction'></span><span id='topic+coef.nlsfunction'></span>

<h3>Description</h3>

<p>Allows you to specify a formula with parameters, along with starting
guesses for the parameters.  Refines those guesses to find the
least-squares fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitModel(formula, data = parent.frame(), start = list(), ...)

model(object, ...)

## S3 method for class 'nlsfunction'
model(object, ...)

## S3 method for class 'nlsfunction'
summary(object, ...)

## S3 method for class 'nlsfunction'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitModel_+3A_formula">formula</code></td>
<td>
<p>formula specifying the model</p>
</td></tr>
<tr><td><code id="fitModel_+3A_data">data</code></td>
<td>
<p>dataframe containing the data to be used</p>
</td></tr>
<tr><td><code id="fitModel_+3A_start">start</code></td>
<td>
<p>passed as <code>start</code> to <code><a href="stats.html#topic+nls">nls()</a></code>.  If and empty list,
a simple starting point is used (thus avoiding the usual warning message).</p>
</td></tr>
<tr><td><code id="fitModel_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="stats.html#topic+nls">nls()</a></code></p>
</td></tr>
<tr><td><code id="fitModel_+3A_object">object</code></td>
<td>
<p>an R object (typically a the result of fitModel)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fits a nonlinear least squares model to data.  In contrast
to linear models, all the parameters (including linear ones)
need to be named in the formula.  The function returned
simply contains the formula together with pre-assigned
arguments setting the parameter value.  Variables used in the
fitting (as opposed to parameters) are unassigned arguments
to the returned function.
</p>


<h3>Value</h3>

<p>a function
</p>


<h3>Note</h3>

<p>This doesn't work with categorical explanatory variables.  Also,
this does not work with synthetic data that fit the model perfectly.
See <code>link{nls}</code> for details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linearModel">linearModel()</a></code>, <code><a href="stats.html#topic+nls">nls()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(mosaicData)) {
f &lt;- fitModel(temp ~ A+B*exp(-k*time), data=CoolingWater, start=list(A=50,B=50,k=1/20))
f(time=50)
coef(f)
summary(f)
model(f)
}
</code></pre>

<hr>
<h2 id='fitSpline'>Fit splines to data</h2><span id='topic+fitSpline'></span>

<h3>Description</h3>

<p>These functions create mathematical functions from data, using splines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fitSpline(
  formula,
  data = parent.frame(),
  df = NULL,
  knots = NULL,
  degree = 3,
  type = c("natural", "linear", "cubic", "polynomial"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitSpline_+3A_formula">formula</code></td>
<td>
<p>a formula.  Only one quantity is allowed on the left-hand side, the
output quantity</p>
</td></tr>
<tr><td><code id="fitSpline_+3A_data">data</code></td>
<td>
<p>a data frame in which <code>formula</code> is evaluated.</p>
</td></tr>
<tr><td><code id="fitSpline_+3A_df">df</code></td>
<td>
<p>degrees of freedom (used to determine how many knots should be used)</p>
</td></tr>
<tr><td><code id="fitSpline_+3A_knots">knots</code></td>
<td>
<p>a vector of knots</p>
</td></tr>
<tr><td><code id="fitSpline_+3A_degree">degree</code></td>
<td>
<p>parameter for splines when <code>type</code> is <code>"polynomial"</code>.
1 is locally linear, 2 is locally quadratic, etc.</p>
</td></tr>
<tr><td><code id="fitSpline_+3A_type">type</code></td>
<td>
<p>type of splines to use; one of
<code>"linear"</code>, <code>"cubic"</code>, <code>"natural"</code> (cubic with linear tails, the default),
or <code>"polynomial"</code>.</p>
</td></tr>
<tr><td><code id="fitSpline_+3A_...">...</code></td>
<td>
<p>additional arguments passed to spline basis functions
(<code><a href="splines.html#topic+ns">splines::ns()</a></code> and <code><a href="splines.html#topic+bs">splines::bs()</a></code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function of the explanatory variable
</p>


<h3>See Also</h3>

<p><code><a href="splines.html#topic+bs">splines::bs()</a></code>  and <code><a href="splines.html#topic+ns">splines::ns()</a></code> for the bases used to generate the splines.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- fitSpline( weight ~ height, data=women, df=5 )
xyplot( weight ~ height, data=women )
plotFun(f(height) ~ height, add=TRUE)

g &lt;- fitSpline( length ~ width, data = KidsFeet, type='natural', df=5 )
h &lt;- fitSpline( length ~ width, data = KidsFeet, type='linear', df=5 )
xyplot( length ~ width, data = KidsFeet, col='gray70', pch=16)
plotFun(g, add=TRUE, col='navy')
plotFun(h, add=TRUE, col='red')
</code></pre>

<hr>
<h2 id='fortify.hclust'>mosaic tools for clustering</h2><span id='topic+fortify.hclust'></span><span id='topic+mplot.hclust'></span>

<h3>Description</h3>

<p>mosaic tools for clustering
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hclust'
fortify(
  model,
  data,
  which = c("segments", "heatmap", "leaves", "labels", "data"),
  k = 1,
  ...
)

## S3 method for class 'hclust'
mplot(
  object,
  data,
  colorize = TRUE,
  k = 1,
  labels = FALSE,
  heatmap = 0,
  enumerate = "white",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fortify.hclust_+3A_model">model</code></td>
<td>
<p>a model</p>
</td></tr>
<tr><td><code id="fortify.hclust_+3A_data">data</code></td>
<td>
<p>a data-like object</p>
</td></tr>
<tr><td><code id="fortify.hclust_+3A_which">which</code></td>
<td>
<p>which kind of fortification to compute</p>
</td></tr>
<tr><td><code id="fortify.hclust_+3A_k">k</code></td>
<td>
<p>number of clusters</p>
</td></tr>
<tr><td><code id="fortify.hclust_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to <code>link{dendro_data}</code></p>
</td></tr>
<tr><td><code id="fortify.hclust_+3A_object">object</code></td>
<td>
<p>an object of class <code>"hclust"</code></p>
</td></tr>
<tr><td><code id="fortify.hclust_+3A_colorize">colorize</code></td>
<td>
<p>whether to show clusters in different colors</p>
</td></tr>
<tr><td><code id="fortify.hclust_+3A_labels">labels</code></td>
<td>
<p>a logical indicating whether labels should be used
to identify leaves of the tree.</p>
</td></tr>
<tr><td><code id="fortify.hclust_+3A_heatmap">heatmap</code></td>
<td>
<p>the ratio of size of heatmap to size of dendrogram.
Use <code>0</code> or <code>FALSE</code> to omit the heatmap.</p>
</td></tr>
<tr><td><code id="fortify.hclust_+3A_enumerate">enumerate</code></td>
<td>
<p>a color used for numbers within heatmap.  Use
<code>"transparent"</code> to hide.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>KidsFeet |&gt; select(-name, -birthmonth) |&gt; rescale() -&gt; KidsFeet2
  M &lt;- dist(KidsFeet2)
  Cl &lt;- hclust(M)
  fortify(Cl, k=5) |&gt; head(3)
  fortify(Cl, which="heatmap", data=KidsFeet2) |&gt; head(3)
  fortify(Cl, which="data", data=KidsFeet2) |&gt; head(3)
  fortify(Cl, which="labels") |&gt; head(3)
  mplot(Cl, data=KidsFeet2, k=4, heatmap=2)
  mplot(Cl, data=KidsFeet2, k=4, heatmap=0.5, enumerate="transparent")
  mplot(Cl, data=KidsFeet2, k=4, heatmap=2, type="triangle")
  mplot(Cl, data=KidsFeet2, k=4, heatmap=0, type="triangle")
</code></pre>

<hr>
<h2 id='fortify.summary.lm'>Extract data from R objects</h2><span id='topic+fortify.summary.lm'></span><span id='topic+fortify.summary.glm'></span><span id='topic+fortify.TukeyHSD'></span>

<h3>Description</h3>

<p>Extract data from R objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'summary.lm'
fortify(model, data = NULL, level = 0.95, ...)

## S3 method for class 'summary.glm'
fortify(model, data = NULL, level = 0.95, ...)

## S3 method for class 'TukeyHSD'
fortify(model, data, order = c("asis", "pval", "difference"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fortify.summary.lm_+3A_model">model</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="fortify.summary.lm_+3A_data">data</code></td>
<td>
<p>original data set, if needed</p>
</td></tr>
<tr><td><code id="fortify.summary.lm_+3A_level">level</code></td>
<td>
<p>confidence level</p>
</td></tr>
<tr><td><code id="fortify.summary.lm_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="fortify.summary.lm_+3A_order">order</code></td>
<td>
<p>one of <code>"pval"</code>, <code>"diff"</code>, or <code>"asis"</code> determining the
order of the <code>pair</code> factor, which determines the order in which the differences
are displayed on the plot.</p>
</td></tr>
</table>

<hr>
<h2 id='freqpoly'>Turn histograms into frequency polygons</h2><span id='topic+freqpoly'></span><span id='topic+hist2freqpolygon'></span><span id='topic+plot.freqpolygon'></span>

<h3>Description</h3>

<p>Turn histograms into frequency polygons
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freqpoly(x, plot = TRUE, ...)

hist2freqpolygon(hist)

## S3 method for class 'freqpolygon'
plot(
  x,
  freq = equidist,
  col = graphics::par("fg"),
  lty = NULL,
  lwd = 1,
  main = paste("Frequency polygon of", paste(x$xname, collapse = "\n")),
  sub = NULL,
  xlab = x$xname,
  ylab,
  xlim = range(x$x),
  ylim = NULL,
  axes = TRUE,
  labels = FALSE,
  add = FALSE,
  ann = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freqpoly_+3A_x">x</code></td>
<td>
<p>a vector of values for which a frequency polygon is desired.</p>
</td></tr>
<tr><td><code id="freqpoly_+3A_plot">plot</code></td>
<td>
<p>a logical indicating if a plot should be generated.</p>
</td></tr>
<tr><td><code id="freqpoly_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to <code><a href="graphics.html#topic+hist">hist()</a></code>.</p>
</td></tr>
<tr><td><code id="freqpoly_+3A_hist">hist</code></td>
<td>
<p>a histogram object produced by <code>link{hist}()</code>.</p>
</td></tr>
<tr><td><code id="freqpoly_+3A_freq">freq</code></td>
<td>
<p>A logical indicating whether the vertical scale should be frequency (count).</p>
</td></tr>
<tr><td><code id="freqpoly_+3A_col">col</code></td>
<td>
<p>A color for the frequency polygon.</p>
</td></tr>
<tr><td><code id="freqpoly_+3A_lty">lty</code></td>
<td>
<p>An integer indicating the line type.</p>
</td></tr>
<tr><td><code id="freqpoly_+3A_lwd">lwd</code></td>
<td>
<p>An integer indicating the line width.</p>
</td></tr>
<tr><td><code id="freqpoly_+3A_main">main</code></td>
<td>
<p>A title for the plot.</p>
</td></tr>
<tr><td><code id="freqpoly_+3A_sub">sub</code></td>
<td>
<p>A sub-title for the plot.</p>
</td></tr>
<tr><td><code id="freqpoly_+3A_xlab">xlab</code></td>
<td>
<p>Label for the horizontal axis.</p>
</td></tr>
<tr><td><code id="freqpoly_+3A_ylab">ylab</code></td>
<td>
<p>Label for the vertical axis.</p>
</td></tr>
<tr><td><code id="freqpoly_+3A_xlim">xlim</code></td>
<td>
<p>A numeric vector of length 2.</p>
</td></tr>
<tr><td><code id="freqpoly_+3A_ylim">ylim</code></td>
<td>
<p>A numeric vector of length 2.</p>
</td></tr>
<tr><td><code id="freqpoly_+3A_axes">axes</code></td>
<td>
<p>A logical indicating whether axes should be drawn.</p>
</td></tr>
<tr><td><code id="freqpoly_+3A_labels">labels</code></td>
<td>
<p>A logical indicating whether labels should be printed or a character
vector of labels to add.</p>
</td></tr>
<tr><td><code id="freqpoly_+3A_add">add</code></td>
<td>
<p>A logical indicating whether the plot should be added to the current plot</p>
</td></tr>
<tr><td><code id="freqpoly_+3A_ann">ann</code></td>
<td>
<p>A logical indicating whether annotations (titles and axis titles) should be plotted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"freqpoly"</code> (invisibly).  Additionally, if <code>plot</code> is
<code>TRUE</code>, a plot is generated.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>freqpoly(faithful$eruptions)
bks &lt;- c(0, 1, 1.5, 2, 3, 3.5, 4, 4.5, 5, 7)
hist(faithful$eruptions, breaks = bks)
freqpoly(faithful$eruptions, col = rgb(0,0,1,.5), lwd = 5, breaks = bks, add = TRUE)

</code></pre>

<hr>
<h2 id='freqpolygon'>Frequency Polygons</h2><span id='topic+freqpolygon'></span><span id='topic+prepanel.default.freqpolygon'></span><span id='topic+panel.freqpolygon'></span>

<h3>Description</h3>

<p>Frequency polygons are an alternative to histograms that make it simpler to overlay multiple
distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>freqpolygon(
  x,
  ...,
  panel = "panel.freqpolygon",
  prepanel = "prepanel.default.freqpolygon"
)

prepanel.default.freqpolygon(
  x,
  darg = list(),
  plot.points = FALSE,
  ref = FALSE,
  groups = NULL,
  subscripts = TRUE,
  jitter.amount = 0.01 * diff(current.panel.limits()$ylim),
  center = NULL,
  nint = NULL,
  breaks = NULL,
  width = darg$width,
  type = "density",
  ...
)

panel.freqpolygon(
  x,
  darg = list(),
  plot.points = FALSE,
  ref = FALSE,
  groups = NULL,
  weights = NULL,
  jitter.amount = 0.01 * diff(current.panel.limits()$ylim),
  type = "density",
  breaks = NULL,
  nint = NULL,
  center = NULL,
  width = darg$width,
  gcol = trellis.par.get("reference.line")$col,
  glwd = trellis.par.get("reference.line")$lwd,
  h,
  v,
  ...,
  identifier = "freqpoly"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="freqpolygon_+3A_x">x</code></td>
<td>
<p>a formula or a numeric vector</p>
</td></tr>
<tr><td><code id="freqpolygon_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to <code><a href="#topic+histogram">histogram()</a></code>
and <code>panel</code>.</p>
</td></tr>
<tr><td><code id="freqpolygon_+3A_panel">panel</code></td>
<td>
<p>a panel function</p>
</td></tr>
<tr><td><code id="freqpolygon_+3A_prepanel">prepanel</code></td>
<td>
<p>a prepanel function</p>
</td></tr>
<tr><td><code id="freqpolygon_+3A_darg">darg</code></td>
<td>
<p>a list of arguments for the function computing the frequency polygon.
This exists primarily for compatibility with <code>densityplot</code> and is unlikely
to be needed by the end user.</p>
</td></tr>
<tr><td><code id="freqpolygon_+3A_plot.points">plot.points</code></td>
<td>
<p>one of <code>TRUE</code>, <code>FALSE</code>, <code>"jitter"</code>, or <code>"rug"</code> indicating
how points are to be displayed</p>
</td></tr>
<tr><td><code id="freqpolygon_+3A_ref">ref</code></td>
<td>
<p>a logical indicating whether a horizontal reference line should be
added (roughly equivalent to <code>h=0</code>)</p>
</td></tr>
<tr><td><code id="freqpolygon_+3A_groups">groups</code>, <code id="freqpolygon_+3A_weights">weights</code>, <code id="freqpolygon_+3A_jitter.amount">jitter.amount</code>, <code id="freqpolygon_+3A_identifier">identifier</code></td>
<td>
<p>as in <code><a href="lattice.html#topic+densityplot">densityplot()</a></code>
or <code><a href="#topic+histogram">histogram()</a></code></p>
</td></tr>
<tr><td><code id="freqpolygon_+3A_subscripts">subscripts</code></td>
<td>
<p>as in other lattice prepanel functions</p>
</td></tr>
<tr><td><code id="freqpolygon_+3A_center">center</code></td>
<td>
<p>center of one of the bins</p>
</td></tr>
<tr><td><code id="freqpolygon_+3A_nint">nint</code></td>
<td>
<p>an approximate number of bins for the frequency polygon</p>
</td></tr>
<tr><td><code id="freqpolygon_+3A_breaks">breaks</code></td>
<td>
<p>a vector of breaks for the frequency polygon bins</p>
</td></tr>
<tr><td><code id="freqpolygon_+3A_width">width</code></td>
<td>
<p>width of the bins</p>
</td></tr>
<tr><td><code id="freqpolygon_+3A_type">type</code></td>
<td>
<p>one of <code>'density'</code>, <code>'percent'</code>, or <code>'count'</code></p>
</td></tr>
<tr><td><code id="freqpolygon_+3A_gcol">gcol</code></td>
<td>
<p>color of guidelines</p>
</td></tr>
<tr><td><code id="freqpolygon_+3A_glwd">glwd</code></td>
<td>
<p>width of guidelines</p>
</td></tr>
<tr><td><code id="freqpolygon_+3A_h">h</code>, <code id="freqpolygon_+3A_v">v</code></td>
<td>
<p>a vector of values for additional horizontal and vertical lines</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a trellis object
</p>


<h3>Note</h3>

<p>This function make use of <code>histogram</code> to determine overall layout.  Often
this works reasonably well but sometimes it does not. In particular, when <code>groups</code> is
used to overlay multiple frequency polygons, there is often too little head room.
In the latter cases, it may be
necessary to use <code>ylim</code> to determine an appropriate viewing rectangle for the
plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>freqpolygon(~age | substance, data=HELPrct, v=35)
freqpolygon(~age, data=HELPrct, labels=TRUE, type='count')
freqpolygon(~age | substance, data=HELPrct, groups=sex)
freqpolygon(~age | substance, data=HELPrct, groups=sex, ylim=c(0,0.11))
## comparison of histogram and frequency polygon
histogram(~eruptions, faithful, type='density', width=.5)
ladd( panel.freqpolygon(faithful$eruptions, width=.5 ))
</code></pre>

<hr>
<h2 id='FunctionsFromData'>Create function from data</h2><span id='topic+FunctionsFromData'></span><span id='topic+spliner'></span><span id='topic+smoother'></span><span id='topic+linearModel'></span><span id='topic+connector'></span>

<h3>Description</h3>

<p>These functions create mathematical functions from data, by smoothing, splining, or linear
combination (fitting).  Each of them takes a formula and a data frame as an argument
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spliner(formula, data = NULL, method = "fmm", monotonic = FALSE)

connector(formula, data = NULL, method = "linear")

smoother(formula, data, span = 0.5, degree = 2, ...)

linearModel(formula, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FunctionsFromData_+3A_formula">formula</code></td>
<td>
<p>a formula.  Only one quantity is allowed on the left-hand side, the
output quantity</p>
</td></tr>
<tr><td><code id="FunctionsFromData_+3A_data">data</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="FunctionsFromData_+3A_method">method</code></td>
<td>
<p>a method for splining.  See <code><a href="stats.html#topic+spline">spline()</a></code>.</p>
</td></tr>
<tr><td><code id="FunctionsFromData_+3A_monotonic">monotonic</code></td>
<td>
<p>a <code>TRUE/FALSE</code> flag specifying whether the spline should
respect monotonicity in the data</p>
</td></tr>
<tr><td><code id="FunctionsFromData_+3A_span">span</code></td>
<td>
<p>parameter to smoother.  How smooth it should be.</p>
</td></tr>
<tr><td><code id="FunctionsFromData_+3A_degree">degree</code></td>
<td>
<p>parameter to smoother. 1 is locally linear, 2 is locally quadratic.</p>
</td></tr>
<tr><td><code id="FunctionsFromData_+3A_...">...</code></td>
<td>
<p>additional arguments to <code><a href="stats.html#topic+loess">stats::loess()</a></code> or <code><a href="stats.html#topic+lm">stats::lm()</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions use data to create a mathematical, single-valued function of the inputs.
All return a function whose arguments are the variables used on the right-hand side of the formula.
If the formula involves a transformation, e.g. <code>sqrt(age)</code> or <code>log(income)</code>,
only the variable itself, e.g. <code>age</code> or <code>income</code>, is an argument to the function.
</p>
<p><code>linearModel</code> takes a linear combination of the vectors specified on the right-hand side.
It differs from <code>project</code> in that <code>linearModel</code> returns a function
whereas <code>project</code> returns the coefficients.  NOTE: An intercept term is not included
unless that is explicitly part of the formula with <code>+1</code>.  This conflicts with the
standard usage of formulas as found in <code>lm</code>.  Another option for creating
such functions is to combine <code><a href="stats.html#topic+lm">lm()</a></code> and <code><a href="#topic+makeFun">makeFun()</a></code>.
</p>
<p><code>spliner</code> and <code>connector</code> currently work for only one input variable.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+project">project()</a></code> method for formulas
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(mosaicData)) {
data(CPS85)
f &lt;- smoother(wage ~ age, span=.9, data=CPS85)
f(40)
g &lt;- linearModel(log(wage) ~ age + educ + 1, data=CPS85)
g(age=40, educ=12)
# an alternative way to define g (Note: + 1 is the default for lm().)
g2 &lt;- makeFun(lm(log(wage) ~ age + educ, data=CPS85))
g2(age=40, educ=12)
x&lt;-1:5; y=c(1, 2, 4, 8, 8.2)
f1 &lt;- spliner(y ~ x)
f1(x=8:10)
f2 &lt;- connector(x~y)
}
</code></pre>

<hr>
<h2 id='getVarFormula'>Extract data from a data frame using a formula interface</h2><span id='topic+getVarFormula'></span>

<h3>Description</h3>

<p>Uses the full model syntax.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getVarFormula(formula, data = parent.frame(), intercept = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getVarFormula_+3A_formula">formula</code></td>
<td>
<p>a formula.
The right-hand side selects variables;
the left-hand side, if present, is used to set row names.
A <code>.</code> on the right-hand side
indicates to use all variables not in the LHS.</p>
</td></tr>
<tr><td><code id="getVarFormula_+3A_data">data</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="getVarFormula_+3A_intercept">intercept</code></td>
<td>
<p>a logical indicating whether to include the intercept in the
model default: FALSE (no intercept)</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>getVarFormula( ~ wt + mpg, data = mtcars)
</code></pre>

<hr>
<h2 id='googleMap'>Display a point on earth on a Google Map</h2><span id='topic+googleMap'></span>

<h3>Description</h3>

<p>Creates a URL for Google Maps for a particular latitude and
longitude position.  This function has been deprecated due to changes in
Google's access policies.  Give <code><a href="#topic+leaflet_map">leaflet_map()</a></code> a try as an alternative.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>googleMap(
  latitude,
  longitude,
  position = NULL,
  zoom = 12,
  maptype = c("roadmap", "satellite", "terrain", "hybrid"),
  mark = FALSE,
  radius = 0,
  browse = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="googleMap_+3A_latitude">latitude</code>, <code id="googleMap_+3A_longitude">longitude</code></td>
<td>
<p>vectors of latitude and longitude values</p>
</td></tr>
<tr><td><code id="googleMap_+3A_position">position</code></td>
<td>
<p>a data frame containing latitude and longitude positions</p>
</td></tr>
<tr><td><code id="googleMap_+3A_zoom">zoom</code></td>
<td>
<p>zoom level for initial map (1-20)</p>
</td></tr>
<tr><td><code id="googleMap_+3A_maptype">maptype</code></td>
<td>
<p>one of <code>'roadmap'</code>, <code>'satellite'</code>, <code>'terrain'</code>, and <code>'hybrid'</code></p>
</td></tr>
<tr><td><code id="googleMap_+3A_mark">mark</code></td>
<td>
<p>a logical indicating whether the location should be marked with a pin</p>
</td></tr>
<tr><td><code id="googleMap_+3A_radius">radius</code></td>
<td>
<p>a vector of radii of circles centered at position that are displayed on the map</p>
</td></tr>
<tr><td><code id="googleMap_+3A_browse">browse</code></td>
<td>
<p>a logical indicating whether the URL should be browsed (else only returned as a string)</p>
</td></tr>
<tr><td><code id="googleMap_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>browseURL</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a string containing a URL.  Optionally, as a side-effect, the URL is visited in a browser
</p>


<h3>See Also</h3>

<p><code><a href="#topic+leaflet_map">leaflet_map()</a></code>, <code><a href="#topic+deg2rad">deg2rad()</a></code>, <code><a href="#topic+latlon2xyz">latlon2xyz()</a></code> and <code><a href="#topic+rgeo">rgeo()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
googleMap(40.7566, -73.9863, radius=1)   # Times Square
googleMap(position=rgeo(2), radius=1)    # 2 random locations

## End(Not run)
</code></pre>

<hr>
<h2 id='inferArgs'>Infer arguments</h2><span id='topic+inferArgs'></span>

<h3>Description</h3>

<p>The primary purpose is for inferring argument settings from names derived from variables
occurring in a formula.  For example, the default use is to infer limits for variables
without having to call them <code>xlim</code> and <code>ylim</code> when the variables in the formula
have other names.  Other uses could easily be devised by specifying different <code>variants</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inferArgs(
  vars,
  dots,
  defaults = alist(xlim = , ylim = , zlim = ),
  variants = c(".lim", "lim")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inferArgs_+3A_vars">vars</code></td>
<td>
<p>a vector of variable names to look for</p>
</td></tr>
<tr><td><code id="inferArgs_+3A_dots">dots</code></td>
<td>
<p>a named list of argument values</p>
</td></tr>
<tr><td><code id="inferArgs_+3A_defaults">defaults</code></td>
<td>
<p>named list or alist of default values for limits</p>
</td></tr>
<tr><td><code id="inferArgs_+3A_variants">variants</code></td>
<td>
<p>a vector of optional postfixes for limit-specifying variable names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named list or alist of limits.  The names are determined by the names in <code>defaults</code>.
</p>
<p>If multiple <code>variants</code> are matched, the first is used.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>inferArgs(c('x','u','t'), list(t=c(1,3), x.lim=c(1,10), u=c(1,3), u.lim=c(2,4)))
inferArgs(c('x','u'), list(u=c(1,3)), defaults=list(xlim=c(0,1), ylim=NULL)) 
</code></pre>

<hr>
<h2 id='is.wholenumber'>Check for whole number values</h2><span id='topic+is.wholenumber'></span>

<h3>Description</h3>

<p>Unlike <code><a href="base.html#topic+is.integer">is.integer()</a></code>, which checks the type of argument is <code>integer</code>,
this function checks whether the value of the argument is an integer
(within a specified tolerance).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.wholenumber(x, tol = .Machine$double.eps^0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.wholenumber_+3A_x">x</code></td>
<td>
<p>a vector</p>
</td></tr>
<tr><td><code id="is.wholenumber_+3A_tol">tol</code></td>
<td>
<p>a numeric tolerance</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is borrowed from the examples for <code><a href="base.html#topic+is.integer">is.integer()</a></code>
</p>


<h3>Value</h3>

<p>a logical vector indicating whether <code>x</code> has a whole number value
</p>


<h3>Examples</h3>

<pre><code class='language-R'>is.wholenumber(1)
all(is.wholenumber(rbinom(100,10,.5)))
is.wholenumber((1:10)/2)
</code></pre>

<hr>
<h2 id='ladd'>Add to Lattice Plots</h2><span id='topic+ladd'></span>

<h3>Description</h3>

<p>Simplified lattice plotting by adding additional elements to existing plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ladd(x, data = NULL, ..., plot = trellis.last.object())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ladd_+3A_x">x</code></td>
<td>
<p>callable graphical element to be added to a panel or panels in a lattice plot</p>
</td></tr>
<tr><td><code id="ladd_+3A_data">data</code></td>
<td>
<p>a list containing objects that can be referred to in <code>x</code>.  Panel functions also
have access to the data already used in the panel by the underlying lattice plot.  See
<code><a href="latticeExtra.html#topic+layer">latticeExtra::layer()</a></code> for details.</p>
</td></tr>
<tr><td><code id="ladd_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="latticeExtra.html#topic+layer">latticeExtra::layer()</a></code>.</p>
</td></tr>
<tr><td><code id="ladd_+3A_plot">plot</code></td>
<td>
<p>a lattice plot to add to.  Defaults to previous lattice plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ladd</code> is a wrapper around <code><a href="latticeExtra.html#topic+layer">latticeExtra::layer()</a></code> that simplifies
certain common plotting additions.  The same caveats that apply to that function
apply here as well.  In particular, <code>ladd</code> uses non-standard evaluation.
For this reason care must be taken if trying to use <code>ladd</code> within other functions
and the use of <code>data</code> may be required to pass information into the environment
in which <code>x</code> will be evaluated.
</p>


<h3>Value</h3>

<p>a trellis object
</p>


<h3>Author(s)</h3>

<p>Randall Pruim (<a href="mailto:rpruim@calvin.edu">rpruim@calvin.edu</a>)
</p>


<h3>See Also</h3>

<p><code><a href="latticeExtra.html#topic+layer">latticeExtra::layer()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p &lt;- xyplot(rnorm(100) ~rnorm(100))
print(p)
ladd(panel.abline(a=0,b=1))
ladd(panel.abline(h=0,col='blue'))
ladd(grid.text('Hello'))
ladd(grid.text(x=.95,y=.05,'text here',just=c('right','bottom')))
q &lt;- xyplot(rnorm(100) ~rnorm(100)|factor(rbinom(100,4,.5)))
q &lt;- update(q, layout=c(3,2))
ladd(panel.abline(a=0,b=1), plot=q)
ladd(panel.abline(h=0,col='blue'))
ladd( grid.text("(2,1)",gp=gpar(cex=3,alpha=.5)), columns=2, rows=1)
ladd( grid.text("p5",gp=gpar(cex=3,alpha=.5)), packets=5)
q
ladd( grid.text(paste(current.column(), current.row(),sep=','), gp=gpar(cex=3,alpha=.5)) )
histogram( ~eruptions, data=faithful )
# over would probably be better here, but the demonstrates what under=TRUE does.
ladd(panel.densityplot(faithful$eruptions, lwd=4), under=TRUE) 

</code></pre>

<hr>
<h2 id='leaflet_map'>Simple Leaflet Maps</h2><span id='topic+leaflet_map'></span>

<h3>Description</h3>

<p>Primarily designed to work with <code><a href="#topic+rgeo">rgeo()</a></code> to display randomly sampled
points on the globe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>leaflet_map(
  latitude = NULL,
  longitude = NULL,
  position = NULL,
  zoom = 12,
  mark = FALSE,
  radius = 0,
  units = c("km", "miles", "meters", "feet"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="leaflet_map_+3A_latitude">latitude</code>, <code id="leaflet_map_+3A_longitude">longitude</code></td>
<td>
<p>vectors of latitude and longitude values.
If <code>latitude</code> is a data frame, then it is treated as <code>position</code>.
This facilitates &quot;piping&quot; from <code><a href="#topic+rgeo">rgeo()</a></code>.  See examples.</p>
</td></tr>
<tr><td><code id="leaflet_map_+3A_position">position</code></td>
<td>
<p>a data frame containing latitude and longitude positions</p>
</td></tr>
<tr><td><code id="leaflet_map_+3A_zoom">zoom</code></td>
<td>
<p>zoom level for initial map (1-20)</p>
</td></tr>
<tr><td><code id="leaflet_map_+3A_mark">mark</code></td>
<td>
<p>a logical indicating whether the location should be marked with a pin</p>
</td></tr>
<tr><td><code id="leaflet_map_+3A_radius">radius</code></td>
<td>
<p>a vector of radii of circles (in miles) centered at position that are displayed on the map</p>
</td></tr>
<tr><td><code id="leaflet_map_+3A_units">units</code></td>
<td>
<p>units for radii of circles (km, miles, meters, or feet).</p>
</td></tr>
<tr><td><code id="leaflet_map_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="leaflet.html#topic+map-layers">leaflet::addCircles()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a leaflet map
</p>


<h3>See Also</h3>

<p><code><a href="#topic+deg2rad">deg2rad()</a></code>, <code><a href="#topic+latlon2xyz">latlon2xyz()</a></code> and <code><a href="#topic+rgeo">rgeo()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># the leaflet package is required
if (require(leaflet)) {
  # Times Square
  leaflet_map(40.7566, -73.9863, radius = 1, units = "miles")  
  # 3 random locations; 5 km circles
  leaflet_map(position = rgeo(3), radius = 5, mark = TRUE, color = "red") 
  # using pipes
  rgeo(4, latlim = c(25,50), lonlim = c(-65, -125)) |&gt;
    leaflet_map(radius = 5, mark = TRUE, color = "purple")
}
</code></pre>

<hr>
<h2 id='linear.algebra'>Functions for teaching linear algebra.</h2><span id='topic+linear.algebra'></span><span id='topic+mat'></span><span id='topic+singvals'></span>

<h3>Description</h3>

<p>These functions provide a formula based interface to the construction
of matrices from data and for fitting.  You can use them both for numerical vectors
and for functions of variables in data frames.
These functions are intended to support teaching basic linear algebra
with a particular connection to statistics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat(formula, data = parent.frame(), A = formula)

singvals(formula, data = parent.frame(), A = formula)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linear.algebra_+3A_formula">formula</code></td>
<td>
<p>a formula.  In <code>mat</code> and <code>singvals</code>,
only the right-hand side is used.</p>
</td></tr>
<tr><td><code id="linear.algebra_+3A_data">data</code></td>
<td>
<p>a data frame from which to pull out numerical values
for the variables in the formula</p>
</td></tr>
<tr><td><code id="linear.algebra_+3A_a">A</code></td>
<td>
<p>an alias for <code>formula</code> for backward compatibility.
</p>
<p><code>mat</code> returns a model matrix
</p>
<p>To demonstrate singularity, use <code>singvals</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>mat</code> returns a matrix
</p>
<p><code>singvals</code> gives singular values for each column in the model matrix
</p>


<h3>See Also</h3>

<p><code><a href="#topic+project">project()</a></code>
</p>
<p><code><a href="#topic+linearModel">linearModel()</a></code>, which returns a function.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- c(1,0,0); b &lt;- c(1,2,3); c &lt;- c(4,5,6); x &lt;- rnorm(3)
# Formula interface
mat(~a+b)
mat(~a+b+1)
if (require(mosaicData)) {
mat(~length+sex, data=KidsFeet)
singvals(~length*sex*width, data=KidsFeet)
}
</code></pre>

<hr>
<h2 id='MAD'>All pairs mean and sum of absolute differences</h2><span id='topic+MAD'></span><span id='topic+SAD'></span>

<h3>Description</h3>

<p>The functions compute the sum or mean of all pairwise absolute
differences.  This differs from <code><a href="stats.html#topic+mad">stats::mad()</a></code>, which computes
the median absolute difference of each value from the median of
all the values.  See the <code>ISIwithR</code> package (and the textbook it
accompanies) for examples using these functions in the context of
simulation-based inference.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MAD(x, ..., data = NULL, groups = NULL, na.rm = getOption("na.rm", FALSE))

SAD(x, ..., data = NULL, groups = NULL, na.rm = getOption("na.rm", FALSE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MAD_+3A_x">x</code></td>
<td>
<p>a numeric vector or a formula.</p>
</td></tr>
<tr><td><code id="MAD_+3A_...">...</code></td>
<td>
<p>additional arguments passed through to <code>MAD_</code>
or <code>SAD_</code>.  If <code>x</code> is a formula, <code>...</code> should
include an argument named <code>data</code> if the intent is to
interpret the formula in a data frame.</p>
</td></tr>
<tr><td><code id="MAD_+3A_data">data</code></td>
<td>
<p>a data frame in which to evaluate formulas (or bare names).
Note that the default is <code>data = parent.frame()</code>.  This makes it convenient to
use this function interactively by treating the working environment as if it were
a data frame.  But this may not be appropriate for programming uses.
When programming, it is best to use an explicit <code>data</code> argument
&ndash; ideally supplying a data frame that contains the variables mentioned.</p>
</td></tr>
<tr><td><code id="MAD_+3A_groups">groups</code></td>
<td>
<p>a grouping variable, typically a name of a variable in <code>data</code></p>
</td></tr>
<tr><td><code id="MAD_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical indicating whether NAs should be removed before
calculating.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the mean or sum of the absolute differences between each pair
of values in <code>c(x,...)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+mad">mad()</a></code>, <code><a href="#topic+MAD_">MAD_()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>SAD(1:3)
MAD(1:3)
MAD(~eruptions, data = faithful)
</code></pre>

<hr>
<h2 id='MAD_'>All pairs mean and sum of absolute differences</h2><span id='topic+MAD_'></span><span id='topic+SAD_'></span>

<h3>Description</h3>

<p>All pairs mean and sum of absolute differences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MAD_(x, ..., na.rm = getOption("na.omit", FALSE))

SAD_(x, ..., na.rm = getOption("na.omit", FALSE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MAD__+3A_x">x</code></td>
<td>
<p>a numeric vector or a formula.</p>
</td></tr>
<tr><td><code id="MAD__+3A_...">...</code></td>
<td>
<p>additional arguments appended to <code>x</code></p>
</td></tr>
<tr><td><code id="MAD__+3A_na.rm">na.rm</code></td>
<td>
<p>a logical indicating whether NAs should be removed before
calculating.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the mean or sum of the absolute differences between each pair
of values in <code>c(x,...)</code>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+mad">mad()</a></code>
</p>

<hr>
<h2 id='maggregate'>Aggregate for mosaic</h2><span id='topic+maggregate'></span>

<h3>Description</h3>

<p>Compute function on subsets of a variable in a data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maggregate(
  formula,
  data = parent.frame(),
  FUN,
  groups = NULL,
  subset,
  drop = FALSE,
  ...,
  .format = c("default", "table", "flat"),
  .overall = mosaic.par.get("aggregate.overall"),
  .multiple = FALSE,
  .name = deparse(substitute(FUN)),
  .envir = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maggregate_+3A_formula">formula</code></td>
<td>
<p>a formula.  Left side provides variable to be summarized.  Right side and condition
describe subsets.  If the left side is empty, right side and condition are
shifted over as a convenience.</p>
</td></tr>
<tr><td><code id="maggregate_+3A_data">data</code></td>
<td>
<p>a data frame.
Note that the default is <code>data = parent.frame()</code>.  This makes it convenient to
use this function interactively by treating the working environment as if it were
a data frame.  But this may not be appropriate for programming uses.
When programming, it is best to use an explicit <code>data</code> argument
&ndash; ideally supplying a data frame that contains the variables mentioned
in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="maggregate_+3A_fun">FUN</code></td>
<td>
<p>a function to apply to each subset</p>
</td></tr>
<tr><td><code id="maggregate_+3A_groups">groups</code></td>
<td>
<p>grouping variable that will be folded into the formula (if there is room for it).
This offers some additional flexibility in how formulas can be specified.</p>
</td></tr>
<tr><td><code id="maggregate_+3A_subset">subset</code></td>
<td>
<p>a logical indicating a subset of <code>data</code> to be processed.</p>
</td></tr>
<tr><td><code id="maggregate_+3A_drop">drop</code></td>
<td>
<p>a logical indicating whether unused levels should be dropped.</p>
</td></tr>
<tr><td><code id="maggregate_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>FUN</code></p>
</td></tr>
<tr><td><code id="maggregate_+3A_.format">.format</code></td>
<td>
<p>format used for aggregation. <code>"default"</code> and <code>"flat"</code> are equivalent.</p>
</td></tr>
<tr><td><code id="maggregate_+3A_.overall">.overall</code></td>
<td>
<p>currently unused</p>
</td></tr>
<tr><td><code id="maggregate_+3A_.multiple">.multiple</code></td>
<td>
<p>a logical indicating whether FUN returns multiple values
Ignored if <code>.multiple</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="maggregate_+3A_.name">.name</code></td>
<td>
<p>a name used for the resulting object</p>
</td></tr>
<tr><td><code id="maggregate_+3A_.envir">.envir</code></td>
<td>
<p>an environment in which to evaluate expressions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(mosaicData)) {
maggregate( cesd ~ sex, HELPrct, FUN = mean )
# using groups instead
maggregate( ~ cesd, groups = sex, HELPrct, FUN = sd )
# the next four all do the same thing
maggregate( cesd ~ sex + homeless, HELPrct, FUN = mean )
maggregate( cesd ~ sex | homeless, HELPrct, FUN = sd )
maggregate( ~ cesd | sex , groups= homeless, HELPrct, FUN = sd )
maggregate( cesd ~ sex, groups = homeless, HELPrct, FUN = sd )
# this is unusual, but also works.
maggregate( cesd ~ NULL , groups = sex, HELPrct, FUN = sd )
}

</code></pre>

<hr>
<h2 id='makeColorscheme'>Create a color generating function from a vector of colors</h2><span id='topic+makeColorscheme'></span>

<h3>Description</h3>

<p>Create a color generating function from a vector of colors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeColorscheme(col)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeColorscheme_+3A_col">col</code></td>
<td>
<p>a vector of colors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a function that generates a vector of colors interpolated among the colors in <code>col</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>cs &lt;- makeColorscheme( c('red','white','blue') )
cs(10)
cs(10, alpha=.5)
</code></pre>

<hr>
<h2 id='makeMap'>Make a map with <code>ggplot2</code></h2><span id='topic+makeMap'></span>

<h3>Description</h3>

<p><code>makeMap</code> takes in two sources of data that refer to geographical
regions and merges them together. Depending on the arguments passed,
it returns this merged data or a ggplot object constructed with the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>makeMap(
  data = NULL,
  map = NULL,
  key = c(key.data, key.map),
  key.data,
  key.map,
  tr.data = identity,
  tr.map = identity,
  plot = c("borders", "frame", "none")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="makeMap_+3A_data">data</code></td>
<td>
<p>A dataframe with regions as cases</p>
</td></tr>
<tr><td><code id="makeMap_+3A_map">map</code></td>
<td>
<p>An object that can be fortified to a dataframe (ex: a dataframe itself,
or a SpatialPolygonsDataFrame)</p>
</td></tr>
<tr><td><code id="makeMap_+3A_key">key</code></td>
<td>
<p>The combination of <code>key.data</code> and <code>key.map</code></p>
</td></tr>
<tr><td><code id="makeMap_+3A_key.data">key.data</code></td>
<td>
<p>The column name in the <code>data</code> that holds the
unique names of each region</p>
</td></tr>
<tr><td><code id="makeMap_+3A_key.map">key.map</code></td>
<td>
<p>The column name in the <code>map</code> that holds the
unique names of each region</p>
</td></tr>
<tr><td><code id="makeMap_+3A_tr.data">tr.data</code></td>
<td>
<p>A function of the transformation to be performed to
the <code>key.data</code> column</p>
</td></tr>
<tr><td><code id="makeMap_+3A_tr.map">tr.map</code></td>
<td>
<p>A function of the transformation to be performed to
the <code>key.map</code> column</p>
</td></tr>
<tr><td><code id="makeMap_+3A_plot">plot</code></td>
<td>
<p>The plot desired for the output. <code>plot</code> = &quot;none&quot;
returns the merged data that is the result of merging the <code>data</code>
and <code>map</code> together; <code>plot</code>=&quot;frame&quot; returns an empty
(unplottable) ggplot object; <code>plot</code> = &quot;border&quot; (the default)
returns a ggplot object with one geom_polygon layer that shows the
borders of the regions.</p>
</td></tr>
</table>

<hr>
<h2 id='mean_'>Aggregating functions</h2><span id='topic+mean_'></span><span id='topic+sum'></span><span id='topic+min'></span><span id='topic+max'></span><span id='topic+mean'></span><span id='topic+median'></span><span id='topic+sd'></span><span id='topic+var'></span><span id='topic+cov'></span><span id='topic+cor'></span><span id='topic+favstats'></span><span id='topic+range'></span><span id='topic+IQR'></span><span id='topic+fivenum'></span><span id='topic+iqr'></span><span id='topic+prod'></span><span id='topic+quantile'></span>

<h3>Description</h3>

<p>The <code>mosaic</code> package makes several summary statistic functions (like <code>mean</code> and <code>sd</code>)
formula aware.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_(x, ..., data = NULL, groups = NULL, na.rm = getOption("na.rm", FALSE))

mean(x, ...)

median(x, ..., data = NULL, groups = NULL, na.rm = getOption("na.rm", FALSE))

range(x, ..., data = NULL, groups = NULL, na.rm = getOption("na.rm", FALSE))

sd(x, ..., data = NULL, groups = NULL, na.rm = getOption("na.rm", FALSE))

max(x, ..., data = NULL, groups = NULL, na.rm = getOption("na.rm", FALSE))

min(x, ..., data = NULL, groups = NULL, na.rm = getOption("na.rm", FALSE))

sum(x, ..., data = NULL, groups = NULL, na.rm = getOption("na.rm", FALSE))

IQR(x, ..., data = NULL, groups = NULL, na.rm = getOption("na.rm", FALSE))

fivenum(x, ..., data = NULL, groups = NULL, na.rm = getOption("na.rm", FALSE))

iqr(x, ..., data = NULL, groups = NULL, na.rm = getOption("na.rm", FALSE))

prod(x, ..., data = NULL, groups = NULL, na.rm = getOption("na.rm", FALSE))

sum(x, ..., data = NULL, groups = NULL, na.rm = getOption("na.rm", FALSE))

favstats(x, ..., data = NULL, groups = NULL, na.rm = TRUE)

quantile(x, ..., data = NULL, groups = NULL, na.rm = getOption("na.rm", FALSE))

var(x, y = NULL, na.rm = getOption("na.rm", FALSE), ..., data = NULL)

cor(x, y = NULL, ..., data = NULL)

cov(x, y = NULL, ..., data = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean__+3A_x">x</code></td>
<td>
<p>a numeric vector or a formula</p>
</td></tr>
<tr><td><code id="mean__+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="mean__+3A_data">data</code></td>
<td>
<p>a data frame in which to evaluate formulas (or bare names).
Note that the default is <code>data = parent.frame()</code>.  This makes it convenient to
use this function interactively by treating the working environment as if it were
a data frame.  But this may not be appropriate for programming uses.
When programming, it is best to use an explicit <code>data</code> argument
&ndash; ideally supplying a data frame that contains the variables mentioned.</p>
</td></tr>
<tr><td><code id="mean__+3A_groups">groups</code></td>
<td>
<p>a grouping variable, typically a name of a variable in <code>data</code></p>
</td></tr>
<tr><td><code id="mean__+3A_na.rm">na.rm</code></td>
<td>
<p>a logical indicating whether <code>NA</code>s should be removed before computing</p>
</td></tr>
<tr><td><code id="mean__+3A_y">y</code></td>
<td>
<p>a numeric vector or a formula</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Many of these functions mask core R functions to provide an additional formula
interface.  Old behavior should be unchanged.  But if the first argument is a formula,
that formula, together with <code>data</code> are used to generate the numeric vector(s)
to be summarized.  Formulas of the shape <code>x ~ a</code> or <code>~ x | a</code> can be used to
produce summaries of <code>x</code> for each subset defined by <code>a</code>.  Two-way aggregation
can be achieved using formulas of the form <code>x ~ a + b</code> or <code> x ~ a | b</code>.  See
the examples.
</p>


<h3>Note</h3>

<p>Earlier versions of these functions supported a &quot;bare name + data frame&quot; interface.  This
functionality has been removed since it was (a) ambiguous in some cases, (b) unnecessary,
and (c) difficult to maintain.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mean(HELPrct$age)
mean( ~ age, data = HELPrct)
mean( ~ drugrisk, na.rm = TRUE, data = HELPrct)
mean(age ~ shuffle(sex), data = HELPrct)
mean(age ~ shuffle(sex), data = HELPrct, .format = "table")
# wrap in data.frame() to auto-convert awkward variable names
data.frame(mean(age ~ shuffle(sex), data = HELPrct, .format = "table"))
mean(age ~ sex + substance, data = HELPrct)
mean( ~ age | sex + substance, data = HELPrct)
mean( ~ sqrt(age), data = HELPrct)
sum( ~ age, data = HELPrct)
sd(HELPrct$age)
sd( ~ age, data = HELPrct)
sd(age ~ sex + substance, data = HELPrct)
var(HELPrct$age)
var( ~ age, data = HELPrct)
var(age ~ sex + substance, data = HELPrct)
IQR(width ~ sex, data = KidsFeet)
iqr(width ~ sex, data = KidsFeet)
favstats(width ~ sex, data = KidsFeet)

cor(length ~ width, data = KidsFeet)
cov(length ~ width, data = KidsFeet)
tally(is.na(mcs) ~ is.na(pcs), data = HELPmiss)
cov(mcs ~ pcs, data = HELPmiss)             # NA because of missing data
cov(mcs ~ pcs, data = HELPmiss, use = "complete")  # ignore missing data
# alternative approach using filter explicitly
cov(mcs ~ pcs, data = HELPmiss |&gt; filter(!is.na(mcs) &amp; !is.na(pcs)))    
</code></pre>

<hr>
<h2 id='mid'>midpoints along a sequence</h2><span id='topic+mid'></span>

<h3>Description</h3>

<p>Compute a vector of midpoints between values in a numeric vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mid(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mid_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of length 1 less than <code>x</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mid(1:5)
mid((1:5)^2)
</code></pre>

<hr>
<h2 id='mosaic.options'>Setting options for mosaic package functions</h2><span id='topic+mosaic.options'></span><span id='topic+mosaicGetOption'></span><span id='topic+mosaic.par.set'></span><span id='topic+mosaic.getOption'></span><span id='topic+mosaic.par.get'></span><span id='topic+restoreLatticeOptions'></span><span id='topic+mosaicLatticeOptions'></span>

<h3>Description</h3>

<p>A mechanism for setting options in the mosaic package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mosaic.options(...)

mosaic.getOption(name)

mosaic.par.set(name, value, ..., theme, warn = TRUE, strict = FALSE)

mosaic.par.get(name = NULL)

restoreLatticeOptions()

mosaicLatticeOptions()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mosaic.options_+3A_...">...</code></td>
<td>
<p>additional arguments that are turned into a list if a list cannot be inferred from
<code>theme</code>, <code>name</code>, and <code>value</code>.</p>
</td></tr>
<tr><td><code id="mosaic.options_+3A_name">name</code></td>
<td>
<p>the name of the option being set</p>
</td></tr>
<tr><td><code id="mosaic.options_+3A_value">value</code></td>
<td>
<p>the value to which to set the option</p>
</td></tr>
<tr><td><code id="mosaic.options_+3A_theme">theme</code></td>
<td>
<p>a list appropriate for a mosaic theme</p>
</td></tr>
<tr><td><code id="mosaic.options_+3A_warn">warn</code></td>
<td>
<p>a logical.  UNUSED at present.</p>
</td></tr>
<tr><td><code id="mosaic.options_+3A_strict">strict</code></td>
<td>
<p>a logical or numeric.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>restoreLatticeOptions</code> returns any lattice
options that were changed when the mosaic package was loaded
back to their pre-mosaic state.
</p>
<p><code>mosaicLatticeOptions</code> sets a number
of defaults for lattice graphics.
</p>

<hr>
<h2 id='mplot'>Generic plotting</h2><span id='topic+mplot'></span><span id='topic+mplot.default'></span><span id='topic+mplot.lm'></span><span id='topic+mplot.data.frame'></span><span id='topic+mplot.summary.lm'></span><span id='topic+mplot.TukeyHSD'></span>

<h3>Description</h3>

<p>Generic function plotting for R objects.  Currently plots exist for
<code>data.frame</code>s, <code>lm</code>s, (including <code>glm</code>s).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mplot(object, ...)

## Default S3 method:
mplot(object, ...)

## S3 method for class 'lm'
mplot(
  object,
  which = c(1:3, 7),
  system = c("ggplot2", "lattice", "base"),
  ask = FALSE,
  multiplot = "package:gridExtra" %in% search(),
  par.settings = theme.mosaic(),
  level = 0.95,
  title = paste("model: ", deparse(object$call), "\n"),
  rows = TRUE,
  id.n = 3L,
  id.size = 5,
  id.color = "red",
  id.nudge = 1,
  add.smooth = TRUE,
  smooth.color = "red",
  smooth.alpha = 0.6,
  smooth.size = 0.7,
  span = 3/4,
  ...
)

## S3 method for class 'data.frame'
mplot(
  object,
  format,
  default = format,
  system = c("ggformula", "ggplot2", "lattice"),
  show = FALSE,
  data_text = rlang::expr_deparse(substitute(object)),
  title = "",
  ...
)

## S3 method for class 'summary.lm'
mplot(
  object,
  system = c("ggplot2", "lattice"),
  level = 0.95,
  par.settings = trellis.par.get(),
  rows = TRUE,
  ...
)

## S3 method for class 'TukeyHSD'
mplot(
  object,
  system = c("ggplot2", "lattice"),
  ylab = "",
  xlab = "difference in means",
  title = paste0(attr(object, "conf.level") * 100, "% family-wise confidence level"),
  par.settings = trellis.par.get(),
  order = c("asis", "pval", "difference"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mplot_+3A_object">object</code></td>
<td>
<p>an R object from which a plot will be constructed.</p>
</td></tr>
<tr><td><code id="mplot_+3A_...">...</code></td>
<td>
<p>additional arguments.  If <code>object</code> is an <code>lm</code>, subsets
of these arguments are passed to <code>gridExtra::grid.arrange</code> and to the
<span class="pkg">lattice</span> plotting routines; in particular,
<code>nrow</code> and <code>ncol</code> can be used to control the number of rows
and columns used.</p>
</td></tr>
<tr><td><code id="mplot_+3A_which">which</code></td>
<td>
<p>a numeric vector used to select from 7 potential plots</p>
</td></tr>
<tr><td><code id="mplot_+3A_system">system</code></td>
<td>
<p>which graphics system to use (initially) for plotting (<span class="pkg">ggplot2</span>
or <span class="pkg">lattice</span>).  A check box will allow on the fly change of plotting system.</p>
</td></tr>
<tr><td><code id="mplot_+3A_ask">ask</code></td>
<td>
<p>if TRUE, each plot will be displayed separately after the user
responds to a prompt.</p>
</td></tr>
<tr><td><code id="mplot_+3A_multiplot">multiplot</code></td>
<td>
<p>if TRUE and <code>ask == FALSE</code>, all plots will be
displayed together.</p>
</td></tr>
<tr><td><code id="mplot_+3A_par.settings">par.settings</code></td>
<td>
<p><span class="pkg">lattice</span> theme settings</p>
</td></tr>
<tr><td><code id="mplot_+3A_level">level</code></td>
<td>
<p>a confidence level</p>
</td></tr>
<tr><td><code id="mplot_+3A_title">title</code></td>
<td>
<p>title for plot</p>
</td></tr>
<tr><td><code id="mplot_+3A_rows">rows</code></td>
<td>
<p>rows to show.  This may be a numeric vector,
<code>TRUE</code> (for all rows), or a character vector of row names.</p>
</td></tr>
<tr><td><code id="mplot_+3A_id.n">id.n</code></td>
<td>
<p>Number of id labels to display.</p>
</td></tr>
<tr><td><code id="mplot_+3A_id.size">id.size</code></td>
<td>
<p>Size of id labels.</p>
</td></tr>
<tr><td><code id="mplot_+3A_id.color">id.color</code></td>
<td>
<p>Color of id labels.</p>
</td></tr>
<tr><td><code id="mplot_+3A_id.nudge">id.nudge</code></td>
<td>
<p>a numeric used to increase (&gt;1) or decrease (&lt;1) the amount that observation labels are
nudged.  Use a negative value to nudge down instead of up.</p>
</td></tr>
<tr><td><code id="mplot_+3A_add.smooth">add.smooth</code></td>
<td>
<p>A logicial indicating whether a LOESS smooth should be added
(where this makes sense to do).
Currently ignored for lattice plots.</p>
</td></tr>
<tr><td><code id="mplot_+3A_smooth.color">smooth.color</code>, <code id="mplot_+3A_smooth.size">smooth.size</code>, <code id="mplot_+3A_smooth.alpha">smooth.alpha</code></td>
<td>
<p>Color, size, and alpha used for
LOESS curve.  Currently ignored for lattice plots.</p>
</td></tr>
<tr><td><code id="mplot_+3A_span">span</code></td>
<td>
<p>A positive number indicating the amount of smoothing.
A larger number indicates more smoothing. See <code><a href="stats.html#topic+loess">stats::loess()</a></code> for details.
Currently ignored for lattice plots.</p>
</td></tr>
<tr><td><code id="mplot_+3A_format">format</code>, <code id="mplot_+3A_default">default</code></td>
<td>
<p>default type of plot to create; one of
<code>"scatter"</code>,
<code>"jitter"</code>,
<code>"boxplot"</code>,
<code>"violin"</code>,
<code>"histogram"</code>,
<code>"density"</code>,
<code>"frequency polygon"</code>,
or
<code>"map"</code>.
Unique prefixes suffice.</p>
</td></tr>
<tr><td><code id="mplot_+3A_show">show</code></td>
<td>
<p>a logical, if <code>TRUE</code>, the code will be displayed each time the plot is
changed.</p>
</td></tr>
<tr><td><code id="mplot_+3A_data_text">data_text</code></td>
<td>
<p>text representation of the data set.  In typical use cases, the default value should suffice.</p>
</td></tr>
<tr><td><code id="mplot_+3A_ylab">ylab</code></td>
<td>
<p>label for y-axis</p>
</td></tr>
<tr><td><code id="mplot_+3A_xlab">xlab</code></td>
<td>
<p>label for x-axis</p>
</td></tr>
<tr><td><code id="mplot_+3A_order">order</code></td>
<td>
<p>one of <code>"pval"</code>, <code>"diff"</code>, or <code>"asis"</code> determining the
order of the <code>pair</code> factor, which determines the order in which the differences
are displayed on the plot.</p>
</td></tr>
<tr><td><code id="mplot_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables that might be used in the plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method for models (lm and glm) is still a work in progress, but should be usable for
relatively simple models.  When the results for a logistic regression model created with
<code><a href="stats.html#topic+glm">glm()</a></code> are satisfactory will depend on the format and structure of the data
used to fit the model.
</p>
<p>Due to a bug in RStudio 1.3, the method for data frames may not display the controls
consistently.  We have found that executing this code usually fixes the problem:
</p>
<div class="sourceCode"><pre>library(manipulate) 
manipulate(plot(A), A = slider(1, 10))
</pre></div>


<h3>Value</h3>

<p>Nothing.  Just for side effects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lm( width ~ length * sex, data = KidsFeet) |&gt;
  mplot(which = 1:3, id.n = 5)
lm( width ~ length * sex, data = KidsFeet) |&gt;
  mplot(smooth.color = "blue", smooth.size = 1.2, smooth.alpha = 0.3, id.size = 3)
lm(width ~ length * sex, data = KidsFeet) |&gt;
  mplot(rows = 2:3, which = 7)
## Not run: 
mplot( HELPrct )
mplot( HELPrct, "histogram" )

## End(Not run)
lm(width ~ length * sex, data = KidsFeet) |&gt;
  summary() |&gt;
  mplot()
  
lm(width ~ length * sex, data = KidsFeet) |&gt;
  summary() |&gt;
  mplot(rows = c("sex", "length"))
  
lm(width ~ length * sex, data = KidsFeet) |&gt;
  summary() |&gt;
  mplot(rows = TRUE)
lm(age ~ substance, data = HELPrct) |&gt;
  TukeyHSD() |&gt;
  mplot()
lm(age ~ substance, data = HELPrct) |&gt;
  TukeyHSD() |&gt;
  mplot(system = "lattice")
</code></pre>

<hr>
<h2 id='mPlot'>Interactive plotting</h2><span id='topic+mPlot'></span><span id='topic+mMap'></span><span id='topic+mScatter'></span><span id='topic+mUniplot'></span>

<h3>Description</h3>

<p>These functions provide a menu selection system (via <span class="pkg">manipulate</span>) so that
different aspects of a plot can be selected interactively.
The <span class="pkg">ggplot2</span> or <span class="pkg">lattice</span>
command for generating the plot currently being displayed can be copied to the
console, whence it can be copied to a document for later direct, non-interactive
use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mPlot(
  data,
  format,
  default = format,
  system = system_choices()[1],
  show = FALSE,
  title = "",
  data_text = rlang::expr_deparse(substitute(data)),
  ...
)

mMap(
  data,
  default = "map",
  system = "ggplot2",
  show = FALSE,
  title = title,
  data_text = rlang::expr_deparse(substitute(data)),
  ...
)

mScatter(
  data,
  default = c("scatter", "jitter", "boxplot", "violin", "line", "sina",
    "density (contours)", "density (filled)"),
  system = "ggformula",
  show = FALSE,
  title = "",
  data_text = rlang::expr_deparse(substitute(data))
)

mUniplot(
  data,
  default = c("histogram", "density", "frequency polygon", "ASH plot"),
  system = system_choices()[1],
  show = FALSE,
  title = "",
  data_text = rlang::expr_deparse(substitute(data))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mPlot_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables that might be used in the plot.
Note that for maps, the data frame must contain coordinates of the polygons
comprising the map and a variable for determining which coordinates are part
of the same region.  See <code><a href="#topic+sp2df">sp2df()</a></code> for one way to create such
a data frame.  Typically <code><a href="base.html#topic+merge">merge()</a></code> will be used to combine the map
data with some auxiliary data to be displayed as fill color on the map, although
this is not necessary if all one wants is a map.</p>
</td></tr>
<tr><td><code id="mPlot_+3A_format">format</code></td>
<td>
<p>a synonym for <code>default</code>.</p>
</td></tr>
<tr><td><code id="mPlot_+3A_default">default</code></td>
<td>
<p>default type of plot to create; one of
<code>"scatter"</code>,
<code>"jitter"</code>,
<code>"boxplot"</code>,
<code>"violin"</code>,
<code>"sina"</code>,
<code>"histogram"</code>,
<code>"density"</code>,
<code>"density (contours)"</code>,
<code>"density (filled)"</code>,
<code>"frequency polygon"</code>,
<code>"xyplot"</code>,
or
<code>"map"</code>.  Unique prefixes suffice.</p>
</td></tr>
<tr><td><code id="mPlot_+3A_system">system</code></td>
<td>
<p>which graphics system to use (initially) for plotting (<span class="pkg">ggplot2</span>
or <span class="pkg">lattice</span>).  A check box will allow on the fly change of plotting system.</p>
</td></tr>
<tr><td><code id="mPlot_+3A_show">show</code></td>
<td>
<p>a logical, if <code>TRUE</code>, the code will be displayed each time the plot is
changed.</p>
</td></tr>
<tr><td><code id="mPlot_+3A_title">title</code></td>
<td>
<p>a title for the plot</p>
</td></tr>
<tr><td><code id="mPlot_+3A_data_text">data_text</code></td>
<td>
<p>A text string describing the data.  It must be possible to recover the data
from this string using <code><a href="base.html#topic+eval">eval()</a></code>.  Typically users will not need to
modify this from the default value.</p>
</td></tr>
<tr><td><code id="mPlot_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only <code>mPlot</code> is required by end users.  The other plotting functions
are dispatched based on the value of <code>default</code>.  Furthermore, <code><a href="#topic+mplot">mplot()</a></code>
will dispatch <code>mPlot</code> when provided a data frame.
</p>
<p>Currently maps are only supported in <span class="pkg">ggplot2</span> and not in <span class="pkg">lattice</span>.
</p>
<p>Due to an unresolved issue with RStudio, the first time this function is called, and additional
plot is created to correctily initialize the mainipulate frameowrk.
</p>


<h3>Value</h3>

<p>Nothing.  Just for side effects.
</p>


<h3>Note</h3>

<p>Due to an unresolved issue with RStudio, the first time this function is called, and additional
plot is created to correctily initialize the mainipulate frameowrk.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
mPlot(HELPrct, format = "scatter")
mPlot(HELPrct, format = "density")

## End(Not run)
</code></pre>

<hr>
<h2 id='mUSMap'>Make a US map with <code>ggplot2</code></h2><span id='topic+mUSMap'></span>

<h3>Description</h3>

<p><code>mUSMap</code> takes in one dataframe that includes information
about different US states. It merges this dataframe with a dataframe
that includes geographical coordinate information. Depending on the
arguments passed, it returns this data or a ggplot object constructed
with the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mUSMap(
  data = NULL,
  key,
  fill = NULL,
  plot = c("borders", "frame", "none"),
  style = c("compact", "real")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mUSMap_+3A_data">data</code></td>
<td>
<p>A dataframe with US states as cases</p>
</td></tr>
<tr><td><code id="mUSMap_+3A_key">key</code></td>
<td>
<p>The column name in the <code>data</code> that holds the unique
names of each state</p>
</td></tr>
<tr><td><code id="mUSMap_+3A_fill">fill</code></td>
<td>
<p>A variable in the <code>data</code> used to specify the fill
color of states in the map (note: if <code>fill</code> is not null, then
<code>plot</code> cannot be set to &quot;none&quot;)</p>
</td></tr>
<tr><td><code id="mUSMap_+3A_plot">plot</code></td>
<td>
<p>The plot desired for the output. <code>plot</code> = &quot;none&quot;
returns the merged data that is the result of merging the <code>data</code>
and the dataframe with the geographical coordinate information;
<code>plot</code> = &quot;frame&quot; returns an empty (unplottable) ggplot object;
<code>plot</code> = &quot;border&quot; (the default) returns a ggplot object with
one geom_polygon layer that shows the borders of the states</p>
</td></tr>
<tr><td><code id="mUSMap_+3A_style">style</code></td>
<td>
<p>The style in which to display the map. <code>compact</code> gives
a polyconic projection with Alaska and Hawaii on the lower left corner;
<code>real</code> gives the real size and position of all states without any
projection.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>USArrests2 &lt;- USArrests |&gt; tibble::rownames_to_column("state")
mUSMap(USArrests2, key="state", fill = "UrbanPop") 
</code></pre>

<hr>
<h2 id='Mustangs'>Mustang Prices</h2><span id='topic+Mustangs'></span>

<h3>Description</h3>

<p>Mustang Prices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Mustangs)
</code></pre>


<h3>Format</h3>

<p>A data frame with 25 observations on the following 3 variables.
</p>

<dl>
<dt><code>Age </code></dt><dd><p>age of vehicle in years</p>
</dd>
<dt><code>Miles </code></dt><dd><p>1000s of miles driven</p>
</dd>
<dt><code>Price </code></dt><dd><p>selling price in 1000s USD</p>
</dd>
</dl>



<h3>Details</h3>

<p>#' @docType data
</p>
<p>A student collected data on the selling prices for a sample of used Mustang
cars being offered for sale at an internet website.
</p>


<h3>Source</h3>

<p>These data were used in a &quot;resampling bake-off&quot; hosted by Robin Lock.
</p>

<hr>
<h2 id='mWorldMap'>Make a world map with <code>ggplot2</code></h2><span id='topic+mWorldMap'></span>

<h3>Description</h3>

<p><code>mWorldMap</code> takes in one dataframe that includes information
about different countries. It merges this dataframe with a dataframe
that includes geographical coordinate information. Depending on the
arguments passed, it returns this data or a ggplot object constructed
with the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mWorldMap(
  data = NULL,
  key = NA,
  fill = NULL,
  plot = c("borders", "frame", "none")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mWorldMap_+3A_data">data</code></td>
<td>
<p>A dataframe with countries as cases</p>
</td></tr>
<tr><td><code id="mWorldMap_+3A_key">key</code></td>
<td>
<p>The column name in the <code>data</code> that holds
the unique names of each country</p>
</td></tr>
<tr><td><code id="mWorldMap_+3A_fill">fill</code></td>
<td>
<p>A variable in the <code>data</code> used to specify the fill
color of countries in the map (note: if <code>fill</code> is not null, then
<code>plot</code> cannot be set to &quot;none&quot;)</p>
</td></tr>
<tr><td><code id="mWorldMap_+3A_plot">plot</code></td>
<td>
<p>The plot desired for the output. <code>plot</code> = &quot;none&quot;
returns the merged data that is the result of merging the <code>data</code>
and the dataframe with the geographical coordinate information;
<code>plot</code> = &quot;frame&quot; returns an empty (unplottable) ggplot object;
<code>plot</code> = &quot;border&quot; (the default) returns a ggplot object with
one geom_polygon layer that shows the borders of the countries</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
gdpData &lt;- CIAdata("GDP")      # load some world data

mWorldMap(gdpData, key="country", fill="GDP")

gdpData &lt;- gdpData |&gt; mutate(GDP5 = ntiles(-GDP, 5, format="rank")) 
mWorldMap(gdpData, key="country", fill="GDP5")

mWorldMap(gdpData, key="country", plot="frame") +
geom_point()

mergedData &lt;- mWorldMap(gdpData, key="country", plot="none")

ggplot(mergedData, aes(x=long, y=lat, group=group, order=order)) +
geom_polygon(aes(fill=GDP5), color="gray70", size=.5) + guides(fill=FALSE)  

## End(Not run)
</code></pre>

<hr>
<h2 id='ntiles'>Create vector based on roughly equally sized groups</h2><span id='topic+ntiles'></span>

<h3>Description</h3>

<p>Create vector based on roughly equally sized groups
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ntiles(
  x,
  n = 3,
  format = c("rank", "interval", "mean", "median", "center", "left", "right"),
  digits = 3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ntiles_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="ntiles_+3A_n">n</code></td>
<td>
<p>(approximate) number of quantiles</p>
</td></tr>
<tr><td><code id="ntiles_+3A_format">format</code></td>
<td>
<p>a specification of desired output format.</p>
</td></tr>
<tr><td><code id="ntiles_+3A_digits">digits</code></td>
<td>
<p>desired number of digits for labeling of factors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector.  The type of vector will depend on <code>format</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(mosaicData)) {
tally( ~ ntiles(age, 4), data=HELPrct)
tally( ~ ntiles(age, 4, format="center"), data=HELPrct)
tally( ~ ntiles(age, 4, format="interval"), data=HELPrct)
tally( ~ ntiles(age, 4, format="left"), data=HELPrct)
tally( ~ ntiles(age, 4, format="right"), data=HELPrct)
tally( ~ ntiles(age, 4, format="mean"), data=HELPrct)
tally( ~ ntiles(age, 4, format="median"), data=HELPrct)
bwplot( i2 ~ ntiles(age, n=5, format="interval"), data=HELPrct)
}
</code></pre>

<hr>
<h2 id='orrr'>Odds Ratio and Relative Risk for 2 x 2 Contingency Tables</h2><span id='topic+orrr'></span><span id='topic+oddsRatio'></span><span id='topic+relrisk'></span><span id='topic+print.oddsRatio'></span><span id='topic+print.relrisk'></span><span id='topic+summary.oddsRatio'></span><span id='topic+summary.relrisk'></span>

<h3>Description</h3>

<p>This function calculates the odds ratio and relative risk for a 2 x 2
contingency table and a
confidence interval (default <code>conf.level</code> is 95 percent) for the
each estimate. <code>x</code> should be a matrix, data frame or table. &quot;Successes&quot;
should be located in column 1 of <code>x</code>, and the treatment of interest
should be located in row 2. The odds ratio is calculated as (Odds row 2) /
(Odds row 1). The confidence interval is calculated from the log(OR) and
backtransformed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orrr(
  x,
  conf.level = 0.95,
  verbose = !quiet,
  quiet = TRUE,
  digits = 3,
  relrisk = FALSE
)

oddsRatio(x, conf.level = 0.95, verbose = !quiet, quiet = TRUE, digits = 3)

relrisk(x, conf.level = 0.95, verbose = !quiet, quiet = TRUE, digits = 3)

## S3 method for class 'oddsRatio'
print(x, digits = 4, ...)

## S3 method for class 'relrisk'
print(x, digits = 4, ...)

## S3 method for class 'oddsRatio'
summary(object, digits = 4, ...)

## S3 method for class 'relrisk'
summary(object, digits = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orrr_+3A_x">x</code></td>
<td>
<p>a 2 x 2 matrix, data frame, or table of counts</p>
</td></tr>
<tr><td><code id="orrr_+3A_conf.level">conf.level</code></td>
<td>
<p>the confidence interval level</p>
</td></tr>
<tr><td><code id="orrr_+3A_verbose">verbose</code></td>
<td>
<p>a logical indicating whether verbose output should be displayed</p>
</td></tr>
<tr><td><code id="orrr_+3A_quiet">quiet</code></td>
<td>
<p>a logical indicating whether verbose output should be suppressed</p>
</td></tr>
<tr><td><code id="orrr_+3A_digits">digits</code></td>
<td>
<p>number of digits to display</p>
</td></tr>
<tr><td><code id="orrr_+3A_relrisk">relrisk</code></td>
<td>
<p>a logical indicating whether the relative risk should be returned
instead of the odds ratio</p>
</td></tr>
<tr><td><code id="orrr_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="orrr_+3A_object">object</code></td>
<td>
<p>an R object to print or summarise.  Here an object of class
<code>"oddsRatio"</code> or <code>"relrisk"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an odds ratio or relative risk.  If <code>verpose</code> is true,
more details and the confidence intervals are displayed.
</p>


<h3>Author(s)</h3>

<p>Kevin Middleton (<a href="mailto:kmm@csusb.edu">kmm@csusb.edu</a>); modified by
R Pruim.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+chisq.test">chisq.test()</a></code>, <code><a href="stats.html#topic+fisher.test">fisher.test()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M1 &lt;- matrix(c(14, 38, 51, 11), nrow = 2)
M1
oddsRatio(M1)

M2 &lt;- matrix(c(18515, 18496, 1427, 1438), nrow = 2)
rownames(M2) &lt;- c("Placebo", "Aspirin")
colnames(M2) &lt;- c("No", "Yes")
M2
oddsRatio(M2)
oddsRatio(M2, verbose = TRUE)
relrisk(M2, verbose = TRUE)
if (require(mosaicData)) {
relrisk(tally(~ homeless + sex, data = HELPrct) )
do(3) * relrisk( tally( ~ homeless + shuffle(sex), data = HELPrct) )
}
</code></pre>

<hr>
<h2 id='panel.levelcontourplot'>Lattice plot that draws a filled contour plot</h2><span id='topic+panel.levelcontourplot'></span>

<h3>Description</h3>

<p>Used within plotFun
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.levelcontourplot(
  x,
  y,
  z,
  subscripts = 1,
  at,
  shrink,
  labels = TRUE,
  label.style = c("mixed", "flat", "align"),
  contour = FALSE,
  region = TRUE,
  col = add.line$col,
  lty = add.line$lty,
  lwd = add.line$lwd,
  border = "transparent",
  ...,
  col.regions = regions$col,
  filled = TRUE,
  alpha.regions = regions$alpha
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panel.levelcontourplot_+3A_x">x</code></td>
<td>
<p>x on a grid</p>
</td></tr>
<tr><td><code id="panel.levelcontourplot_+3A_y">y</code></td>
<td>
<p>y on a grid</p>
</td></tr>
<tr><td><code id="panel.levelcontourplot_+3A_z">z</code></td>
<td>
<p>zvalues for the x and y</p>
</td></tr>
<tr><td><code id="panel.levelcontourplot_+3A_subscripts">subscripts</code></td>
<td>
<p>which points to plot</p>
</td></tr>
<tr><td><code id="panel.levelcontourplot_+3A_at">at</code></td>
<td>
<p>cuts for the contours</p>
</td></tr>
<tr><td><code id="panel.levelcontourplot_+3A_shrink">shrink</code></td>
<td>
<p>what does this do?</p>
</td></tr>
<tr><td><code id="panel.levelcontourplot_+3A_labels">labels</code></td>
<td>
<p>draw the contour labels</p>
</td></tr>
<tr><td><code id="panel.levelcontourplot_+3A_label.style">label.style</code></td>
<td>
<p>where to put the labels</p>
</td></tr>
<tr><td><code id="panel.levelcontourplot_+3A_contour">contour</code></td>
<td>
<p>logical draw the contours</p>
</td></tr>
<tr><td><code id="panel.levelcontourplot_+3A_region">region</code></td>
<td>
<p>logical color the regions</p>
</td></tr>
<tr><td><code id="panel.levelcontourplot_+3A_col">col</code></td>
<td>
<p>color for contours</p>
</td></tr>
<tr><td><code id="panel.levelcontourplot_+3A_lty">lty</code></td>
<td>
<p>type for contours</p>
</td></tr>
<tr><td><code id="panel.levelcontourplot_+3A_lwd">lwd</code></td>
<td>
<p>width for contour</p>
</td></tr>
<tr><td><code id="panel.levelcontourplot_+3A_border">border</code></td>
<td>
<p>type of border</p>
</td></tr>
<tr><td><code id="panel.levelcontourplot_+3A_...">...</code></td>
<td>
<p>dots additional arguments</p>
</td></tr>
<tr><td><code id="panel.levelcontourplot_+3A_col.regions">col.regions</code></td>
<td>
<p>a vector of colors or a function (<code>topo.colors</code> by default) for generating such</p>
</td></tr>
<tr><td><code id="panel.levelcontourplot_+3A_filled">filled</code></td>
<td>
<p>whether to fill the contours with color</p>
</td></tr>
<tr><td><code id="panel.levelcontourplot_+3A_alpha.regions">alpha.regions</code></td>
<td>
<p>transparency of regions</p>
</td></tr>
</table>

<hr>
<h2 id='panel.lmbands'>show confidence and prediction bands on plots</h2><span id='topic+panel.lmbands'></span>

<h3>Description</h3>

<p>show confidence and prediction bands on plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.lmbands(
  x,
  y,
  interval = "confidence",
  level = 0.95,
  model = lm(y ~ x),
  band.col = c(conf = slcol[3], pred = slcol[2]),
  band.lty = c(conf = slty[3], pred = slty[2]),
  band.show = TRUE,
  fit.show = TRUE,
  band.alpha = 0.6,
  band.lwd = 1,
  npts = 100,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panel.lmbands_+3A_x">x</code>, <code id="panel.lmbands_+3A_y">y</code></td>
<td>
<p>numeric vectors</p>
</td></tr>
<tr><td><code id="panel.lmbands_+3A_interval">interval</code></td>
<td>
<p>a vector subset of <code>'confidence'</code> and <code>'prediction'</code></p>
</td></tr>
<tr><td><code id="panel.lmbands_+3A_level">level</code></td>
<td>
<p>confidence level</p>
</td></tr>
<tr><td><code id="panel.lmbands_+3A_model">model</code></td>
<td>
<p>model to be used for generating bands</p>
</td></tr>
<tr><td><code id="panel.lmbands_+3A_band.col">band.col</code></td>
<td>
<p>a vector of length 1 or 2 giving the color of bands</p>
</td></tr>
<tr><td><code id="panel.lmbands_+3A_band.lty">band.lty</code></td>
<td>
<p>a vector of length 1 or 2 giving the line type for bands</p>
</td></tr>
<tr><td><code id="panel.lmbands_+3A_band.show">band.show</code></td>
<td>
<p>logical vector of length 1 or 2 indicating whether
confidence and prediction bands should be shown</p>
</td></tr>
<tr><td><code id="panel.lmbands_+3A_fit.show">fit.show</code></td>
<td>
<p>logical indicating whether the model fit should be shown</p>
</td></tr>
<tr><td><code id="panel.lmbands_+3A_band.alpha">band.alpha</code></td>
<td>
<p>a vector of length 1 or 2 alpha level for bands</p>
</td></tr>
<tr><td><code id="panel.lmbands_+3A_band.lwd">band.lwd</code></td>
<td>
<p>a vector of length 1 or 2 giving line width for bands</p>
</td></tr>
<tr><td><code id="panel.lmbands_+3A_npts">npts</code></td>
<td>
<p>resolution parameter for bands (increase to get better resolution)</p>
</td></tr>
<tr><td><code id="panel.lmbands_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>

<hr>
<h2 id='panel.plotFun'>Panel function for plotting functions</h2><span id='topic+panel.plotFun'></span>

<h3>Description</h3>

<p>Panel function for plotting functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.plotFun(
  object,
  ...,
  type = "l",
  npts = NULL,
  zlab = NULL,
  filled = TRUE,
  levels = NULL,
  nlevels = 10,
  surface = FALSE,
  col.regions = topo.colors,
  lwd = trellis.par.get("superpose.line")$lwd,
  lty = trellis.par.get("superpose.line")$lty,
  alpha = NULL,
  discontinuity = NULL,
  discontinuities = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panel.plotFun_+3A_object">object</code></td>
<td>
<p>an object (e.g., a formula) describing a function</p>
</td></tr>
<tr><td><code id="panel.plotFun_+3A_...">...</code></td>
<td>
<p>additional arguments, typically processed by <code>lattice</code> panel functions
such as <code><a href="lattice.html#topic+panel.xyplot">lattice::panel.xyplot()</a></code> or <code><a href="lattice.html#topic+panel.levelplot">lattice::panel.levelplot()</a></code>.
Frequently used arguments include
</p>

<dl>
<dt><code>lwd</code></dt><dd><p>line width</p>
</dd>
<dt><code>lty</code></dt><dd><p>line type</p>
</dd>
<dt><code>col</code></dt><dd><p>a color</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="panel.plotFun_+3A_type">type</code></td>
<td>
<p>type of plot (<code>"l"</code> by default)</p>
</td></tr>
<tr><td><code id="panel.plotFun_+3A_npts">npts</code></td>
<td>
<p>an integer giving the number of points (in each dimension) to sample the function</p>
</td></tr>
<tr><td><code id="panel.plotFun_+3A_zlab">zlab</code></td>
<td>
<p>label for z axis (when in surface-plot mode)</p>
</td></tr>
<tr><td><code id="panel.plotFun_+3A_filled">filled</code></td>
<td>
<p>fill with color between the contours (<code>TRUE</code> by default)</p>
</td></tr>
<tr><td><code id="panel.plotFun_+3A_levels">levels</code></td>
<td>
<p>levels at which to draw contours</p>
</td></tr>
<tr><td><code id="panel.plotFun_+3A_nlevels">nlevels</code></td>
<td>
<p>number of contours to draw (if <code>levels</code> not specified)</p>
</td></tr>
<tr><td><code id="panel.plotFun_+3A_surface">surface</code></td>
<td>
<p>a logical indicating whether to draw a surface plot rather than a contour plot</p>
</td></tr>
<tr><td><code id="panel.plotFun_+3A_col.regions">col.regions</code></td>
<td>
<p>a vector of colors or a function (<code>topo.colors</code> by default) for generating such</p>
</td></tr>
<tr><td><code id="panel.plotFun_+3A_lwd">lwd</code></td>
<td>
<p>width of the line</p>
</td></tr>
<tr><td><code id="panel.plotFun_+3A_lty">lty</code></td>
<td>
<p>line type</p>
</td></tr>
<tr><td><code id="panel.plotFun_+3A_alpha">alpha</code></td>
<td>
<p>number from 0 (transparent) to 1 (opaque) for the fill colors</p>
</td></tr>
<tr><td><code id="panel.plotFun_+3A_discontinuity">discontinuity</code></td>
<td>
<p>a positive number determining how sensitive the plot is to
potential discontinuity.  Larger values result in less sensitivity.  The default is 1.
Use <code>discontinuity = Inf</code> to disable discontinuity detection.  Discontinuity detection
uses a crude numerical heuristic and may not give the desired results in all cases.</p>
</td></tr>
<tr><td><code id="panel.plotFun_+3A_discontinuities">discontinuities</code></td>
<td>
<p>a vector of input values at which a function is
discontinuous or <code>NULL</code> to use
a heuristic to auto-detect.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>plotFun
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(30,0,2*pi) 
d &lt;- data.frame( x = x,  y = sin(x) + rnorm(30,sd=.2) )
xyplot( y ~ x, data=d )
ladd(panel.plotFun( sin(x) ~ x, col='red' ) )
xyplot( y ~ x | rbinom(30,1,.5), data=d )
ladd(panel.plotFun( sin(x) ~ x, col='red', lty=2 ) )    # plots sin(x) in each panel
</code></pre>

<hr>
<h2 id='panel.plotFun1'>Panel function for plotting functions</h2><span id='topic+panel.plotFun1'></span>

<h3>Description</h3>

<p>Panel function for plotting functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>panel.plotFun1(
  ..f..,
  ...,
  x,
  y,
  type = "l",
  lwd = trellis.par.get("superpose.line")$lwd,
  lty = trellis.par.get("superpose.line")$lty,
  col = trellis.par.get("superpose.line")$col,
  npts = NULL,
  zlab = NULL,
  filled = TRUE,
  levels = NULL,
  nlevels = 10,
  surface = FALSE,
  alpha = NULL,
  discontinuity = NULL,
  discontinuities = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="panel.plotFun1_+3A_..f..">..f..</code></td>
<td>
<p>an object (e.g., a formula) describing a function</p>
</td></tr>
<tr><td><code id="panel.plotFun1_+3A_...">...</code></td>
<td>
<p>additional arguments, typically processed by <code>lattice</code> panel functions
such as <code><a href="lattice.html#topic+panel.xyplot">lattice::panel.xyplot()</a></code> or <code><a href="lattice.html#topic+panel.levelplot">lattice::panel.levelplot()</a></code>.
Frequently used arguments include
</p>

<dl>
<dt><code>lwd</code></dt><dd><p>line width</p>
</dd>
<dt><code>lty</code></dt><dd><p>line type</p>
</dd>
<dt><code>col</code></dt><dd><p>a color</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="panel.plotFun1_+3A_x">x</code>, <code id="panel.plotFun1_+3A_y">y</code></td>
<td>
<p>ignored, but there for compatibility with other lattice panel functions</p>
</td></tr>
<tr><td><code id="panel.plotFun1_+3A_type">type</code></td>
<td>
<p>type of plot (<code>"l"</code> by default)</p>
</td></tr>
<tr><td><code id="panel.plotFun1_+3A_lwd">lwd</code></td>
<td>
<p>width of the line</p>
</td></tr>
<tr><td><code id="panel.plotFun1_+3A_lty">lty</code></td>
<td>
<p>line type</p>
</td></tr>
<tr><td><code id="panel.plotFun1_+3A_col">col</code></td>
<td>
<p>a vector of colors</p>
</td></tr>
<tr><td><code id="panel.plotFun1_+3A_npts">npts</code></td>
<td>
<p>an integer giving the number of points (in each dimension) to sample the function</p>
</td></tr>
<tr><td><code id="panel.plotFun1_+3A_zlab">zlab</code></td>
<td>
<p>label for z axis (when in surface-plot mode)</p>
</td></tr>
<tr><td><code id="panel.plotFun1_+3A_filled">filled</code></td>
<td>
<p>fill with color between the contours (<code>TRUE</code> by default)</p>
</td></tr>
<tr><td><code id="panel.plotFun1_+3A_levels">levels</code></td>
<td>
<p>levels at which to draw contours</p>
</td></tr>
<tr><td><code id="panel.plotFun1_+3A_nlevels">nlevels</code></td>
<td>
<p>number of contours to draw (if <code>levels</code> not specified)</p>
</td></tr>
<tr><td><code id="panel.plotFun1_+3A_surface">surface</code></td>
<td>
<p>a logical indicating whether to draw a surface plot rather than a contour plot</p>
</td></tr>
<tr><td><code id="panel.plotFun1_+3A_alpha">alpha</code></td>
<td>
<p>number from 0 (transparent) to 1 (opaque) for the fill colors</p>
</td></tr>
<tr><td><code id="panel.plotFun1_+3A_discontinuity">discontinuity</code></td>
<td>
<p>a positive number determining how sensitive the plot is to
potential discontinuity.  Larger values result in less sensitivity.  The default is 1.
Use <code>discontinuity = Inf</code> to disable discontinuity detection.  Discontinuity detection
uses a crude numerical heuristic and may not give the desired results in all cases.</p>
</td></tr>
<tr><td><code id="panel.plotFun1_+3A_discontinuities">discontinuities</code></td>
<td>
<p>a vector of input values at which a function is
discontinuous or <code>NULL</code> to use
a heuristic to auto-detect.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>plotFun
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- runif(30,0,2*pi) 
d &lt;- data.frame( x = x,  y = sin(x) + rnorm(30,sd=.2) )
xyplot( y ~ x, data=d )
ladd(panel.plotFun1( sin, col='red' ) )
xyplot( y ~ x | rbinom(30,1,.5), data=d )
ladd(panel.plotFun1( sin, col='red', lty=2 ) )    # plots sin(x) in each panel
</code></pre>

<hr>
<h2 id='pdist'>Illustrated probability calculations from distributions</h2><span id='topic+pdist'></span><span id='topic+xpgamma'></span><span id='topic+xpt'></span><span id='topic+xpchisq'></span><span id='topic+xpf'></span><span id='topic+xpbinom'></span><span id='topic+xppois'></span><span id='topic+xpgeom'></span><span id='topic+xpnbinom'></span><span id='topic+xpbeta'></span>

<h3>Description</h3>

<p>Illustrated probability calculations from distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pdist(
  dist = "norm",
  q,
  plot = TRUE,
  verbose = FALSE,
  invisible = FALSE,
  digits = 3L,
  xlim,
  ylim,
  resolution = 500L,
  return = c("values", "plot"),
  ...,
  refinements = list()
)

xpgamma(
  q,
  shape,
  rate = 1,
  scale = 1/rate,
  lower.tail = TRUE,
  log.p = FALSE,
  ...
)

xpt(q, df, ncp, lower.tail = TRUE, log.p = FALSE, ...)

xpchisq(q, df, ncp = 0, lower.tail = TRUE, log.p = FALSE, ...)

xpf(q, df1, df2, lower.tail = TRUE, log.p = FALSE, ...)

xpbinom(q, size, prob, lower.tail = TRUE, log.p = FALSE, ...)

xppois(q, lambda, lower.tail = TRUE, log.p = FALSE, ...)

xpgeom(q, prob, lower.tail = TRUE, log.p = FALSE, ...)

xpnbinom(q, size, prob, mu, lower.tail = TRUE, log.p = FALSE, ...)

xpbeta(q, shape1, shape2, ncp = 0, lower.tail = TRUE, log.p = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pdist_+3A_dist">dist</code></td>
<td>
<p>a character description of a distribution, for example
<code>"norm"</code>, <code>"t"</code>, or <code>"chisq"</code></p>
</td></tr>
<tr><td><code id="pdist_+3A_q">q</code></td>
<td>
<p>a vector of quantiles</p>
</td></tr>
<tr><td><code id="pdist_+3A_plot">plot</code></td>
<td>
<p>a logical indicating whether a plot should be created</p>
</td></tr>
<tr><td><code id="pdist_+3A_verbose">verbose</code></td>
<td>
<p>a logical</p>
</td></tr>
<tr><td><code id="pdist_+3A_invisible">invisible</code></td>
<td>
<p>a logical</p>
</td></tr>
<tr><td><code id="pdist_+3A_digits">digits</code></td>
<td>
<p>the number of digits desired</p>
</td></tr>
<tr><td><code id="pdist_+3A_xlim">xlim</code></td>
<td>
<p>x limits</p>
</td></tr>
<tr><td><code id="pdist_+3A_ylim">ylim</code></td>
<td>
<p>y limits</p>
</td></tr>
<tr><td><code id="pdist_+3A_resolution">resolution</code></td>
<td>
<p>Number of points used for detecting discreteness and generating plots.
The default value of 5000 should work well except for discrete distributions
that have many distinct values, especially if these values are not evenly spaced.</p>
</td></tr>
<tr><td><code id="pdist_+3A_return">return</code></td>
<td>
<p>If <code>"plot"</code>, return a plot.  If <code>"values"</code>, return a vector of numerical values.</p>
</td></tr>
<tr><td><code id="pdist_+3A_...">...</code></td>
<td>
<p>Additional arguments, typically for fine tuning the plot.</p>
</td></tr>
<tr><td><code id="pdist_+3A_refinements">refinements</code></td>
<td>
<p>A list of refinements to the plot.  See <code><a href="ggformula.html#topic+gf_aux">ggformula::gf_refine()</a></code>.</p>
</td></tr>
<tr><td><code id="pdist_+3A_shape">shape</code>, <code id="pdist_+3A_scale">scale</code></td>
<td>
<p>shape and scale parameters.  Must be positive,
<code>scale</code> strictly.</p>
</td></tr>
<tr><td><code id="pdist_+3A_rate">rate</code></td>
<td>
<p>an alternative way to specify the scale.</p>
</td></tr>
<tr><td><code id="pdist_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="pdist_+3A_log.p">log.p</code></td>
<td>
<p>A logical indicating whether probabilities should be
returned on the log scale.</p>
</td></tr>
<tr><td><code id="pdist_+3A_df">df</code></td>
<td>
<p>degrees of freedom (<code class="reqn">&gt; 0</code>, maybe non-integer).  <code>df
      = Inf</code> is allowed.</p>
</td></tr>
<tr><td><code id="pdist_+3A_ncp">ncp</code></td>
<td>
<p>non-centrality parameter <code class="reqn">\delta</code>;
currently except for <code>rt()</code>, only for <code>abs(ncp) &lt;= 37.62</code>.
If omitted, use the central t distribution.</p>
</td></tr>
<tr><td><code id="pdist_+3A_df1">df1</code>, <code id="pdist_+3A_df2">df2</code></td>
<td>
<p>degrees of freedom.  <code>Inf</code> is allowed.</p>
</td></tr>
<tr><td><code id="pdist_+3A_size">size</code></td>
<td>
<p>number of trials (zero or more).</p>
</td></tr>
<tr><td><code id="pdist_+3A_prob">prob</code></td>
<td>
<p>probability of success on each trial.</p>
</td></tr>
<tr><td><code id="pdist_+3A_lambda">lambda</code></td>
<td>
<p>vector of (non-negative) means.</p>
</td></tr>
<tr><td><code id="pdist_+3A_mu">mu</code></td>
<td>
<p>alternative parametrization via mean: see &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="pdist_+3A_shape1">shape1</code>, <code id="pdist_+3A_shape2">shape2</code></td>
<td>
<p>non-negative parameters of the Beta distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The most general function is <code>pdist</code> which can work with
any distribution for which a p-function exists.  As a convenience, wrappers are
provided for several common distributions.
</p>


<h3>Value</h3>

<p>A vector of probabilities; a plot is printed as a side effect.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+qdist">qdist()</a></code>, <code><a href="#topic+xpnorm">xpnorm()</a></code>, <code><a href="#topic+xqnorm">xqnorm()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pdist("norm", -2:2)
pdist("norm", seq(80,120, by = 10), mean = 100, sd = 10)
pdist("chisq", 2:4, df = 3)
pdist("f", 1, df1 = 2, df2 = 10)
pdist("gamma", 2, shape = 3, rate = 4)
</code></pre>

<hr>
<h2 id='plotCumfreq'>Cumulative frequency plots</h2><span id='topic+plotCumfreq'></span><span id='topic+plotCumfreq.formula'></span><span id='topic+plotCumfreq.default'></span><span id='topic+prepanel.cumfreq'></span><span id='topic+panel.cumfreq'></span>

<h3>Description</h3>

<p>A high-level function for producing a cumulative frequency plot using
<code>lattice</code> graphics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotCumfreq(x, data, ...)

## S3 method for class 'formula'
plotCumfreq(x, data = NULL, subscripts, ...)

## Default S3 method:
plotCumfreq(x, ...)

prepanel.cumfreq(x, ...)

panel.cumfreq(x, type = c("smooth", "step"), groups = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotCumfreq_+3A_x">x</code></td>
<td>
<p>a formula or numeric vector</p>
</td></tr>
<tr><td><code id="plotCumfreq_+3A_data">data</code></td>
<td>
<p>a data frame in which <code>x</code> is evaluated if <code>x</code> is a
formula.</p>
</td></tr>
<tr><td><code id="plotCumfreq_+3A_...">...</code></td>
<td>
<p>other lattice arguments</p>
</td></tr>
<tr><td><code id="plotCumfreq_+3A_subscripts">subscripts</code></td>
<td>
<p>as in lattice plots</p>
</td></tr>
<tr><td><code id="plotCumfreq_+3A_type">type</code></td>
<td>
<p>smooth or step-function?</p>
</td></tr>
<tr><td><code id="plotCumfreq_+3A_groups">groups</code></td>
<td>
<p>grouping variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A plot of the empirical cumulative distribution function for sample values specified in <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+histogram">histogram()</a></code>, <code><a href="lattice.html#topic+densityplot">densityplot()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plotCumfreq(~eruptions, faithful, xlab = 'duration of eruptions')
</code></pre>

<hr>
<h2 id='plotDist'>Plots of Discrete and Continuous Distributions</h2><span id='topic+plotDist'></span>

<h3>Description</h3>

<p>Provides a simple way to generate plots of pdfs, probability mass functions,
cdfs, probability histograms, and normal-quantile plots for distributions
known to R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDist(
  dist,
  ...,
  xlim = NULL,
  ylim = NULL,
  add,
  under = FALSE,
  packets = NULL,
  rows = NULL,
  columns = NULL,
  kind = c("density", "cdf", "qq", "histogram"),
  xlab = "",
  ylab = "",
  breaks = NULL,
  type,
  resolution = 5000L,
  params = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDist_+3A_dist">dist</code></td>
<td>
<p>A string identifying the distribution.  This should work
with any distribution that has associated functions beginning
with 'd', 'p', and 'q' (e.g,
<code><a href="stats.html#topic+dnorm">dnorm()</a></code>,
<code><a href="stats.html#topic+pnorm">pnorm()</a></code>, and
<code><a href="stats.html#topic+qnorm">qnorm()</a></code>).  <code>dist</code> should match the name of the
distribution with the initial 'd', 'p', or 'q' removed.</p>
</td></tr>
<tr><td><code id="plotDist_+3A_...">...</code></td>
<td>
<p>other arguments passed along to lattice graphing routines</p>
</td></tr>
<tr><td><code id="plotDist_+3A_xlim">xlim</code></td>
<td>
<p>a numeric vector of length 2 or <code>NULL</code>, in which case
the central 99.8 of the distribution is used.</p>
</td></tr>
<tr><td><code id="plotDist_+3A_ylim">ylim</code></td>
<td>
<p>a numeric vector of length 2 or <code>NULL</code>, in which case
a heuristic is used to avoid chasing asymptotes in distributions like
the F distributions with 1 numerator degree of freedom.</p>
</td></tr>
<tr><td><code id="plotDist_+3A_add">add</code></td>
<td>
<p>a logical indicating whether the plot should be added to the previous lattice plot.
If missing, it will be set to match <code>under</code>.</p>
</td></tr>
<tr><td><code id="plotDist_+3A_under">under</code></td>
<td>
<p>a logical indicating whether adding should be done in a layer under or over the existing
layers when <code>add = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotDist_+3A_packets">packets</code>, <code id="plotDist_+3A_rows">rows</code>, <code id="plotDist_+3A_columns">columns</code></td>
<td>
<p>specification of which panels will be added to when
<code>add</code> is <code>TRUE</code>.  See <code><a href="latticeExtra.html#topic+layer">latticeExtra::layer()</a></code>.</p>
</td></tr>
<tr><td><code id="plotDist_+3A_kind">kind</code></td>
<td>
<p>one of &quot;density&quot;, &quot;cdf&quot;, &quot;qq&quot;, or &quot;histogram&quot; (or prefix
of any of these)</p>
</td></tr>
<tr><td><code id="plotDist_+3A_xlab">xlab</code>, <code id="plotDist_+3A_ylab">ylab</code></td>
<td>
<p>as per other lattice functions</p>
</td></tr>
<tr><td><code id="plotDist_+3A_breaks">breaks</code></td>
<td>
<p>a vector of break points for bins of histograms,
as in <code><a href="#topic+histogram">histogram()</a></code></p>
</td></tr>
<tr><td><code id="plotDist_+3A_type">type</code></td>
<td>
<p>passed along to various lattice graphing functions</p>
</td></tr>
<tr><td><code id="plotDist_+3A_resolution">resolution</code></td>
<td>
<p>number of points to sample when generating the plots</p>
</td></tr>
<tr><td><code id="plotDist_+3A_params">params</code></td>
<td>
<p>a list containing parameters for the distribution.  If <code>NULL</code> (the default),
this list is created from elements of <code style="white-space: pre;">&#8288;\dots&#8288;</code> that are either unnamed or have names among
the formals of the appropriate distribution function.  See the examples.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plotDist()</code> determines whether the distribution
is continuous or discrete by seeing if all the sampled quantiles are
unique.  A discrete random variable with many possible values could
fool this algorithm and be considered continuous.
</p>
<p>The plots are done referencing a data frame with variables
<code>x</code> and <code>y</code> giving points on the graph of the
pdf, pmf, or cdf for the distribution.  This can be useful in conjunction
with the <code>groups</code> argument.  See the examples.
</p>


<h3>See Also</h3>

<p><code><a href="ggformula.html#topic+gf_dist">ggformula::gf_dist()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plotDist('norm')
plotDist('norm', type='h')
plotDist('norm', kind='cdf')
plotDist('exp',  kind='histogram')
plotDist('binom', params=list( 25, .25))       # explicit params
plotDist('binom', 25, .25)                     # params inferred
plotDist('norm', mean=100, sd=10, kind='cdf')  # params inferred
plotDist('binom', 25, .25, xlim=c(-1,26) )     # params inferred
plotDist('binom', params=list( 25, .25), kind='cdf')
plotDist('beta', params=list( 3, 10), kind='density')
plotDist('beta', params=list( 3, 10), kind='cdf')
plotDist( "binom", params=list(35,.25), 
           groups= y &lt; dbinom(qbinom(0.05, 35, .25), 35,.25) )
plotDist( "binom", params=list(35,.25), 
           groups= y &lt; dbinom(qbinom(0.05, 35, .25), 35,.25), 
           kind='hist')
plotDist("norm", mean=10, sd=2, col="blue", type="h")
plotDist("norm", mean=12, sd=2, col="red", type="h", under=TRUE)
plotDist("binom", size=100, prob=.30) +
  plotDist("norm", mean=30, sd=sqrt(100 * .3 * .7))
plotDist("chisq", df=4, groups = x &gt; 6, type="h")
plotDist("f", df1=1, df2 = 99)
if (require(mosaicData)) {
histogram( ~age|sex, data=HELPrct)
m &lt;- mean( ~age|sex, data=HELPrct)
s &lt;- sd(~age|sex, data=HELPrct)
plotDist( "norm", mean=m[1], sd=s[1], col="red", add=TRUE, packets=1)
plotDist( "norm", mean=m[2], sd=s[2], col="blue", under=TRUE, packets=2)
}

</code></pre>

<hr>
<h2 id='plotFun'>Plotting mathematical expressions</h2><span id='topic+plotFun'></span>

<h3>Description</h3>

<p>Plots mathematical expressions in one and two variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotFun(
  object,
  ...,
  plot = trellis.last.object(),
  add = NULL,
  under = FALSE,
  xlim = NULL,
  ylim = NULL,
  npts = NULL,
  ylab = NULL,
  xlab = NULL,
  zlab = NULL,
  filled = TRUE,
  levels = NULL,
  nlevels = 10,
  labels = TRUE,
  surface = FALSE,
  groups = NULL,
  col = trellis.par.get("superpose.line")$col,
  col.regions = topo.colors,
  type = "l",
  lwd = trellis.par.get("superpose.line")$lwd,
  lty = trellis.par.get("superpose.line")$lty,
  alpha = NULL,
  discontinuities = NULL,
  discontinuity = 1,
  interactive = rstudio_is_available()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotFun_+3A_object">object</code></td>
<td>
<p>a mathematical expression or a function &quot;of one variable&quot; which will
converted to something intuitively equivalent to <code>object(x) ~ x</code>. (See examples)</p>
</td></tr>
<tr><td><code id="plotFun_+3A_...">...</code></td>
<td>
<p>additional parameters, typically processed by <code>lattice</code> functions such as
<code><a href="lattice.html#topic+xyplot">lattice::xyplot()</a></code>, <code><a href="lattice.html#topic+levelplot">lattice::levelplot()</a></code> or their panel functions.
Frequently used parameters include
</p>

<dl>
<dt><code>main</code></dt><dd><p>main title for plot </p>
</dd>
<dt><code>sub</code></dt><dd><p>subtitle for plot </p>
</dd>
<dt><code>lwd</code></dt><dd><p>line width </p>
</dd>
<dt><code>lty</code></dt><dd><p>line type </p>
</dd>
<dt><code>col</code></dt><dd><p>a color or a (small) integer indicating which color in the current
color scheme is desired.</p>
</dd>
</dl>

<p>Additionally, these arguments can be used to specify parameters for the function being
plotted and to specify the plotting window with natural names.  See the examples for such usage.</p>
</td></tr>
<tr><td><code id="plotFun_+3A_plot">plot</code></td>
<td>
<p>a trellis object; by default, the most recently created trellis plot.
When <code>add</code> is <code>TRUE</code>, the new function will
be plotted into a layer added to this object.</p>
</td></tr>
<tr><td><code id="plotFun_+3A_add">add</code></td>
<td>
<p>if <code>TRUE</code>, then add a layer to an existing plot rather than creating a new plot.
If <code>NULL</code>, this will be determined by the value of <code>under</code>.</p>
</td></tr>
<tr><td><code id="plotFun_+3A_under">under</code></td>
<td>
<p>if <code>TRUE</code>, then new layer is added beneath existing layers</p>
</td></tr>
<tr><td><code id="plotFun_+3A_xlim">xlim</code></td>
<td>
<p>limits for x axis (or use variable names, see examples)</p>
</td></tr>
<tr><td><code id="plotFun_+3A_ylim">ylim</code></td>
<td>
<p>limits for y axis (or use variable names, see examples)</p>
</td></tr>
<tr><td><code id="plotFun_+3A_npts">npts</code></td>
<td>
<p>number of points for plotting.</p>
</td></tr>
<tr><td><code id="plotFun_+3A_ylab">ylab</code></td>
<td>
<p>label for y axis</p>
</td></tr>
<tr><td><code id="plotFun_+3A_xlab">xlab</code></td>
<td>
<p>label for x axis</p>
</td></tr>
<tr><td><code id="plotFun_+3A_zlab">zlab</code></td>
<td>
<p>label for z axis (when in surface-plot mode)</p>
</td></tr>
<tr><td><code id="plotFun_+3A_filled">filled</code></td>
<td>
<p>fill with color between the contours (<code>TRUE</code> by default)</p>
</td></tr>
<tr><td><code id="plotFun_+3A_levels">levels</code></td>
<td>
<p>levels at which to draw contours</p>
</td></tr>
<tr><td><code id="plotFun_+3A_nlevels">nlevels</code></td>
<td>
<p>number of contours to draw (if <code>levels</code> not specified)</p>
</td></tr>
<tr><td><code id="plotFun_+3A_labels">labels</code></td>
<td>
<p>if <code>FALSE</code>, don't label contours</p>
</td></tr>
<tr><td><code id="plotFun_+3A_surface">surface</code></td>
<td>
<p>draw a surface plot rather than a contour plot</p>
</td></tr>
<tr><td><code id="plotFun_+3A_groups">groups</code></td>
<td>
<p>grouping argument ala lattice graphics</p>
</td></tr>
<tr><td><code id="plotFun_+3A_col">col</code></td>
<td>
<p>vector of colors for line graphs and contours</p>
</td></tr>
<tr><td><code id="plotFun_+3A_col.regions">col.regions</code></td>
<td>
<p>a vector of colors or a function (<code>topo.colors</code> by default) for generating such</p>
</td></tr>
<tr><td><code id="plotFun_+3A_type">type</code></td>
<td>
<p>type of plot (<code>"l"</code> by default)</p>
</td></tr>
<tr><td><code id="plotFun_+3A_lwd">lwd</code></td>
<td>
<p>vector of line widths for line graphs</p>
</td></tr>
<tr><td><code id="plotFun_+3A_lty">lty</code></td>
<td>
<p>vector of line types for line graphs</p>
</td></tr>
<tr><td><code id="plotFun_+3A_alpha">alpha</code></td>
<td>
<p>number from 0 (transparent) to 1 (opaque) for the fill colors</p>
</td></tr>
<tr><td><code id="plotFun_+3A_discontinuities">discontinuities</code></td>
<td>
<p>a vector of input values at which a function is
discontinuous or <code>NULL</code> to use
a heuristic to auto-detect.</p>
</td></tr>
<tr><td><code id="plotFun_+3A_discontinuity">discontinuity</code></td>
<td>
<p>a positive number determining how sensitive the plot is to
potential discontinuity.  Larger values result in less sensitivity.  The default is 1.
Use <code>discontinuity = Inf</code> to disable discontinuity detection.  Discontinuity detection
uses a crude numerical heuristic and may not give the desired results in all cases.</p>
</td></tr>
<tr><td><code id="plotFun_+3A_interactive">interactive</code></td>
<td>
<p>a logical indicating whether the surface plot should be
interactive.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>makes plots of mathematical expressions using the formula syntax.  Will
draw both line plots and contour/surface plots (for functions of two variables).
In RStudio, the surface plot comes with sliders to set orientation.
If the colors in filled surface plots are too blocky, increase <code>npts</code>
beyond the default of 50, though <code>npts=300</code> is as much as you're likely to ever need.
See examples for overplotting a constraint function on an objective function.
</p>


<h3>Value</h3>

<p>a <code>trellis</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plotFun( a*sin(x^2)~x, xlim=range(-5,5), a=2 )  # setting parameter value
plotFun( u^2 ~ u, ulim=c(-4,4) )                # limits in terms of u
# Note roles of ylim and y.lim in this example
plotFun( y^2 ~ y, ylim=c(-2,20), y.lim=c(-4,4) )    
# Combining plot elements to show the solution to an inequality
plotFun( x^2 -3 ~ x, xlim=c(-4,4), grid=TRUE )
ladd( panel.abline(h=0,v=0,col='gray50') )
plotFun( (x^2 -3) * (x^2 &gt; 3) ~ x, type='h', alpha=.1, lwd=4, col='lightblue', add=TRUE )
plotFun( sin(x) ~ x, 
   groups=cut(x, findZeros(sin(x) ~ x, within=10)$x), 
   col=c('blue','green'), lty=2, lwd=3, xlim=c(-10,10) )
plotFun( sin(x) ~ x, 
   groups=cut(x, findZeros(sin(x) ~ x, within=10)$x), 
   col=c(1,2), lty=2, lwd=3, xlim=c(-10,10) )
## plotFun( sin(2*pi*x/P)*exp(-k*t)~x+t, k=2, P=.3)
f &lt;- rfun( ~ u &amp; v )
plotFun( f(u=u,v=v) ~ u &amp; v, u.lim=range(-3,3), v.lim=range(-3,3) )
plotFun( u^2 + v &lt; 3 ~ u &amp; v, add=TRUE, npts=200 )
if (require(mosaicData)) {
# display a linear model using a formula interface
model &lt;- lm(wage ~ poly(exper,degree=2), data=CPS85)
fit &lt;- makeFun(model)
xyplot(wage ~ exper, data=CPS85)
plotFun(fit(exper) ~ exper, add=TRUE, lwd=3, col="red")
# Can also just give fit since it is a "function of one variable"
plotFun(fit, add=TRUE, lwd=2, col='white')
}
# Attempts to find sensible axis limits by default
plotFun( sin(k*x)~x, k=0.01 )
# Plotting a linear model with multiple predictors.
mod &lt;- lm(length ~ width * sex, data=KidsFeet)
fitted.length &lt;- makeFun(mod)
xyplot(length ~ width, groups=sex, data=KidsFeet, auto.key=TRUE)
plotFun(fitted.length(width, sex="B") ~ width, add=TRUE, col=1)
plotFun(fitted.length(width, sex="G") ~ width, add=TRUE, col=2)
</code></pre>

<hr>
<h2 id='plotModel'>Plot a regression model</h2><span id='topic+plotModel'></span><span id='topic+plotModel.default'></span><span id='topic+plotModel.parsedModel'></span>

<h3>Description</h3>

<p>Visualize a regression model amid the data that generated it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotModel(mod, ...)

## Default S3 method:
plotModel(mod, ...)

## S3 method for class 'parsedModel'
plotModel(
  mod,
  formula = NULL,
  ...,
  auto.key = NULL,
  drop = TRUE,
  max.levels = 9L,
  system = c("ggplot2", "lattice")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotModel_+3A_mod">mod</code></td>
<td>
<p>A model of type <code><a href="stats.html#topic+lm">lm()</a></code> or <code><a href="stats.html#topic+glm">glm()</a></code></p>
</td></tr>
<tr><td><code id="plotModel_+3A_...">...</code></td>
<td>
<p>arguments passed to <code><a href="lattice.html#topic+xyplot">xyplot()</a></code> or <code>rgl::plot3d</code>.</p>
</td></tr>
<tr><td><code id="plotModel_+3A_formula">formula</code></td>
<td>
<p>a formula indicating how the variables are to be displayed.  In the style of
<code>lattice</code> and <code>ggformula</code>.</p>
</td></tr>
<tr><td><code id="plotModel_+3A_auto.key">auto.key</code></td>
<td>
<p>If TRUE, automatically generate a key.</p>
</td></tr>
<tr><td><code id="plotModel_+3A_drop">drop</code></td>
<td>
<p>If TRUE, unused factor levels are dropped from <code>interaction()</code>.</p>
</td></tr>
<tr><td><code id="plotModel_+3A_max.levels">max.levels</code></td>
<td>
<p>currently unused</p>
</td></tr>
<tr><td><code id="plotModel_+3A_system">system</code></td>
<td>
<p>which of <code>ggplot2</code> or <code>lattice</code> to use for plotting</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The goal of this function is to assist with visualization
of statistical models. Namely, to plot the model on top of the data
from which the model was fit.
</p>
<p>The primary plot type is a scatter plot.  The x-axis can be assigned
to one of the predictors in the model.  Additional predictors are thought
of as co-variates.  The data and fitted curves are partitioned by
these covariates.  When the number of components to this partition is large,
a random subset of the fitted curves is displayed to avoid visual clutter.
</p>
<p>If the model was fit on one quantitative variable (e.g. SLR), then
a scatter plot is drawn, and the model is realized as parallel or
non-parallel lines, depending on whether interaction terms are present.
</p>
<p>Eventually we hope to support 3-d visualizations of models with 2 quantitative
predictors using the <code>rgl</code> package.
</p>
<p>Currently, only linear regression models and
generalized linear regression models are supported.
</p>


<h3>Value</h3>

<p>A lattice or ggplot2 graphics object.
</p>


<h3>Caution</h3>

<p>This is still underdevelopment.  The API is subject to change, and some
use cases may not work yet.  Watch for improvements in subsequent versions of the package.
</p>


<h3>Author(s)</h3>

<p>Ben Baumer, Galen Long, Randall Pruim
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotPoints">plotPoints()</a></code>, <code><a href="#topic+plotFun">plotFun()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
require(mosaic)

mod &lt;- lm( mpg ~ factor(cyl), data = mtcars)
plotModel(mod)

# SLR
mod &lt;- lm( mpg ~ wt, data = mtcars)
plotModel(mod, pch = 19)

# parallel slopes
mod &lt;- lm( mpg ~ wt + factor(cyl), data=mtcars)
plotModel(mod)

## Not run:  
# multiple categorical vars
mod &lt;- lm( mpg ~ wt + factor(cyl) + factor(vs) + factor(am), data = mtcars)
plotModel(mod)
plotModel(mod, mpg ~ am)

# interaction
mod &lt;- lm( mpg ~ wt + factor(cyl) + wt:factor(cyl), data = mtcars)
plotModel(mod)

# polynomial terms
mod &lt;- lm( mpg ~ wt + I(wt^2), data = mtcars)
plotModel(mod)

# GLM
mod &lt;- glm(vs ~ wt, data=mtcars, family = 'binomial')
plotModel(mod)

# GLM with interaction
mod &lt;- glm(vs ~ wt + factor(cyl), data=mtcars, family = 'binomial')
plotModel(mod)
# 3D model
mod &lt;- lm( mpg ~ wt + hp, data = mtcars)
plotModel(mod)

# parallel planes
mod &lt;- lm( mpg ~ wt + hp + factor(cyl) + factor(vs), data = mtcars)
plotModel(mod)

# interaction planes
mod &lt;- lm( mpg ~ wt + hp + wt * factor(cyl), data = mtcars)
plotModel(mod)
plotModel(mod, system="g") + facet_wrap( ~ cyl )

## End(Not run)
</code></pre>

<hr>
<h2 id='plotPoints'>Scatter plot of points</h2><span id='topic+plotPoints'></span>

<h3>Description</h3>

<p>Make or add a scatter plot in a manner coordinated with <code>plotFun</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotPoints(
  x,
  data = parent.frame(),
  add = NULL,
  under = FALSE,
  panelfun = panel.xyplot,
  plotfun = xyplot,
  ...,
  plot = trellis.last.object()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotPoints_+3A_x">x</code></td>
<td>
<p>A formula specifying y ~ x or z ~ x&amp;y</p>
</td></tr>
<tr><td><code id="plotPoints_+3A_data">data</code></td>
<td>
<p>Data frame containing the variables to be plotted.  If not specified,
the variables will be looked up in the local environment</p>
</td></tr>
<tr><td><code id="plotPoints_+3A_add">add</code></td>
<td>
<p>If <code>TRUE</code>, add points as a new layer to an existing plot.
If <code>NULL</code>, the value of <code>under</code> will be used.</p>
</td></tr>
<tr><td><code id="plotPoints_+3A_under">under</code></td>
<td>
<p>If <code>TRUE</code>, the new layer will be underneath existing layers.</p>
</td></tr>
<tr><td><code id="plotPoints_+3A_panelfun">panelfun</code></td>
<td>
<p>Lattice panel function to be used for adding.  Set only if you want something other
than a scatter plot.  Mainly, this is intended to add new functionality through other functions.</p>
</td></tr>
<tr><td><code id="plotPoints_+3A_plotfun">plotfun</code></td>
<td>
<p>Lattice function to be used for initial plot creation. Set only
if you want something other than a scatter plot. Mainly, this is intended to add new functionality through
other functions.</p>
</td></tr>
<tr><td><code id="plotPoints_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="plotPoints_+3A_plot">plot</code></td>
<td>
<p>a trellis plot, by default the most recently created one.  If <code>add</code> is <code>TRUE</code>,
new points will be added as a new layer to <code>plot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A trellis graphics object
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plotFun">plotFun()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(mosaicData)) {
plotPoints( width ~ length, data=KidsFeet, groups=sex, pch=20)
f &lt;- makeFun( lm( width ~ length * sex, data=KidsFeet))
plotFun( f(length=length,sex="G")~length, add=TRUE, col="pink")
plotFun( f(length=length,sex="B")~length, add=TRUE)
}
</code></pre>

<hr>
<h2 id='project'>Projections</h2><span id='topic+project'></span><span id='topic+project+2Cformula-method'></span><span id='topic+project+2Cnumeric-method'></span><span id='topic+project+2Cmatrix-method'></span><span id='topic+vlength'></span><span id='topic+dot'></span>

<h3>Description</h3>

<p>Compute projections onto the span of a vector or a model space, dot products, and
vector lengths in Euclidean space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project(x, ...)

## S4 method for signature 'formula'
project(x, u = NULL, data = parent.frame(2), coefficients = TRUE, ...)

## S4 method for signature 'numeric'
project(x, u = rep(1, length(x)), type = c("vector", "length", "coef"), ...)

## S4 method for signature 'matrix'
project(x, u, data = parent.frame())

vlength(x, ...)

dot(u, v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="project_+3A_x">x</code></td>
<td>
<p>a numeric vector (all functions) or a formula (only for <code>project</code>).
Left-hand sides of formulas should be a single quantity</p>
</td></tr>
<tr><td><code id="project_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="project_+3A_u">u</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="project_+3A_data">data</code></td>
<td>
<p>a data frame.</p>
</td></tr>
<tr><td><code id="project_+3A_coefficients">coefficients</code></td>
<td>
<p>For <code>project(y ~ x)</code> indicates whether the projection
coefficents should be returned or the projection vector.</p>
</td></tr>
<tr><td><code id="project_+3A_type">type</code></td>
<td>
<p>one of <code>"length"</code> or <code>"vector"</code> determining the type of the
returned value</p>
</td></tr>
<tr><td><code id="project_+3A_v">v</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>project</code> (preferably pronounced &quot;pro-JECT&quot; as in &quot;projection&quot;)
does either of two related things:
(1) Given two vectors as arguments, it will project the first onto the
second, returning the point in the subspace of the second that is as
close as possible to the first vector.  (2) Given a formula as an argument,
will work very much like <code>lm()</code>, constructing a model matrix from
the right-hand side of the formula and projecting the vector on the
left-hand side onto the subspace of that model matrix.
</p>
<p>In (2), rather than
returning the projected vector, <code>project()</code> returns the coefficients
on each of the vectors in the model matrix.
UNLIKE <code>lm()</code>, the intercept vector is NOT included by default.  If
you want an intercept vector, include <code>+1</code> in your formula.
</p>


<h3>Value</h3>

<p><code>project</code> returns the projection of <code>x</code> onto <code>u</code>
(or its length if <code>u</code> and <code>v</code> are numeric vectors and <code>type == "length"</code>)
</p>
<p><code>vlength</code> returns the length of the vector
(i.e., the square root of the sum of the squares of the components)
</p>
<p><code>dot</code> returns the dot product of <code>u</code> and <code>v</code>
</p>


<h3>See Also</h3>

<p><code>link{project}</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x1 &lt;- c(1,0,0); x2 &lt;- c(1,2,3); y1 &lt;- c(3,4,5); y2 &lt;- rnorm(3)
# projection onto the 1 vector gives the mean vector
mean(y2)            
project(y2, 1)
# return the length of the vector, rather than the vector itself
project(y2, 1, type='length')
project(y1 ~ x1 + x2) -&gt; pr; pr
# recover the projected vector 
cbind(x1,x2) %*% pr -&gt; v; v
project( y1 ~ x1 + x2, coefficients=FALSE )
dot( y1 - v, v ) # left over should be orthogonal to projection, so this should be ~ 0
if (require(mosaicData)) {
project(width~length+sex, data=KidsFeet)
}
vlength(rep(1,4))
if (require(mosaicData)) {
m &lt;- lm( length ~ width, data=KidsFeet )
# These should be the same
vlength( m$effects )  
vlength( KidsFeet$length)
# So should these
vlength( tail(m$effects, -2) )
sqrt(sum(resid(m)^2))
}
v &lt;- c(1,1,1); w &lt;- c(1,2,3)
u &lt;- v / vlength(v)  # make a unit vector
# The following should be the same:
project(w,v, type="coef") * v 
project(w,v)
# The following are equivalent
abs(dot( w, u ))
vlength( project( w, u) )
vlength( project( w, v) )
project( w, v, type='length' )
</code></pre>

<hr>
<h2 id='prop_test'>Internal function for testing proportion</h2><span id='topic+prop_test'></span>

<h3>Description</h3>

<p>This function is wrapped by <code><a href="#topic+prop.test">prop.test()</a></code>, which most users should use instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prop_test(
  x,
  n,
  p = NULL,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prop_test_+3A_x">x</code></td>
<td>
<p>a vector, count, or formula.</p>
</td></tr>
<tr><td><code id="prop_test_+3A_n">n</code></td>
<td>
<p>a vector of counts of trials (not needed when <code>x</code> is a table or matrix).</p>
</td></tr>
<tr><td><code id="prop_test_+3A_p">p</code></td>
<td>
<p>a vector of probabilities of success (for the null hypothesis).
The length must be the same as the number of groups specified by <code>x</code>.</p>
</td></tr>
<tr><td><code id="prop_test_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative
hypothesis, must be one of <code>"two.sided"</code> (default),
<code>"greater"</code> or <code>"less"</code>.  You can specify just the initial
letter.  Only used for testing the null that a single proportion
equals a given value, or that two proportions are equal; ignored
otherwise.</p>
</td></tr>
<tr><td><code id="prop_test_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of the returned confidence
interval.  Must be a single number between 0 and 1.  Only used
when testing the null that a single proportion equals a given
value, or that two proportions are equal; ignored otherwise.</p>
</td></tr>
<tr><td><code id="prop_test_+3A_...">...</code></td>
<td>
<p>additional arguments passed to methods.</p>
</td></tr>
</table>

<hr>
<h2 id='prop.test'>Exact and Approximate Tests for Proportions</h2><span id='topic+prop.test'></span>

<h3>Description</h3>

<p>The mosaic <code>prop.test</code> provides wrapper functions around the function of the same name in <span class="pkg">stats</span>.
These wrappers provide an extended interface (including formulas).
<code>prop.test</code> performs an approximate test of a simple null hypothesis about the
probability of success in a Bernoulli or multinomial experiment
from summarized data or from raw data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prop.test(
  x,
  n,
  p = NULL,
  alternative = c("two.sided", "less", "greater"),
  conf.level = 0.95,
  data = NULL,
  success = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prop.test_+3A_x">x</code></td>
<td>
<p>count of successes, length 2 vector of success and failure counts, a formula,
or a character, numeric, or factor vector containing raw data.</p>
</td></tr>
<tr><td><code id="prop.test_+3A_n">n</code></td>
<td>
<p>sample size (successes + failures) or a data frame
(for the formula interface)</p>
</td></tr>
<tr><td><code id="prop.test_+3A_p">p</code></td>
<td>
<p>a vector of probabilities of success.
The length of p must be the same as the number of groups specified by x,
and its elements must be greater than 0 and less than 1.</p>
</td></tr>
<tr><td><code id="prop.test_+3A_alternative">alternative</code></td>
<td>
<p>character string specifying the alternative hypothesis, must be one of
<code>"two.sided"</code> (default), <code>"greater"</code> or <code>"less"</code>. You can specify just the initial letter.
Only used for testing the null that a single proportion equals a given value, or that two proportions
are equal; ignored otherwise.</p>
</td></tr>
<tr><td><code id="prop.test_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of the returned confidence interval. Must be a single number
between 0 and 1. Only used when testing the null that a single proportion equals a given value,
or that two proportions are equal; ignored otherwise.</p>
</td></tr>
<tr><td><code id="prop.test_+3A_data">data</code></td>
<td>
<p>a data frame (if missing, <code>n</code> may be a data frame)</p>
</td></tr>
<tr><td><code id="prop.test_+3A_success">success</code></td>
<td>
<p>level of variable to be considered success.  All other levels are
considered failure.</p>
</td></tr>
<tr><td><code id="prop.test_+3A_...">...</code></td>
<td>
<p>additional arguments (often ignored).
When <code>x</code> is a formula, <code>groups</code> can be used to compare groups:
<code style="white-space: pre;">&#8288;x = ~ var, groups=g&#8288;</code> is equivalent to <code>x = var ~ g</code>. <code>na.rm</code> can be a logical
or an integer vector of length 1 or 2 to indicate dimension along which NA's are
removed before coputing the test.
See the examples.</p>
</td></tr>
</table>


<h3>Details</h3>

<div class="sourceCode"><pre>				conf.level = 0.95, ...)
</pre></div>
<p>This is a wrapper around <code><a href="#topic+prop.test">prop.test()</a></code> to simplify its use
when the raw data are available, in which case
an extended syntax for <code>prop.test</code> is provided.
</p>


<h3>Value</h3>

<p>an <code>htest</code> object
</p>


<h3>Note</h3>

<p>When <code>x</code> is a 0-1 vector, 0 is treated as failure and 1 as success. Similarly,
for a logical vector <code>TRUE</code> is treated as success and <code>FALSE</code> as failure.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+binom.test">binom.test()</a></code>, <code><a href="stats.html#topic+prop.test">stats::prop.test()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Several ways to get a confidence interval for the proportion of Old Faithful
# eruptions lasting more than 3 minutes.
prop.test( faithful$eruptions &gt; 3 )
prop.test(97,272)
faithful$long &lt;- faithful$eruptions &gt; 3
prop.test( faithful$long )
prop.test( ~long , data = faithful )
prop.test( homeless ~ sex, data = HELPrct )
prop.test( ~ homeless | sex, data = HELPrct )
prop.test( ~ homeless, groups = sex, data = HELPrct )
prop.test(anysub ~ link, data = HELPrct, na.rm = TRUE)
prop.test(link ~ anysub, data = HELPrct, na.rm = 1)
prop.test(link ~ anysub, data = HELPrct, na.rm = TRUE)

</code></pre>

<hr>
<h2 id='qdata'>The Data Distribution</h2><span id='topic+qdata'></span><span id='topic+cdata'></span><span id='topic+pdata'></span><span id='topic+rdata'></span><span id='topic+ddata'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function, and random generation
from data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qdata(formula, p = seq(0, 1, 0.25), data = NULL, ...)

cdata(formula, p = 0.95, data = NULL, ...)

pdata(formula, q, data = NULL, ...)

rdata(formula, n, data = NULL, ...)

ddata(formula, q, data = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qdata_+3A_formula">formula</code></td>
<td>
<p>a formula or a vector</p>
</td></tr>
<tr><td><code id="qdata_+3A_p">p</code></td>
<td>
<p>a vector of probabilities</p>
</td></tr>
<tr><td><code id="qdata_+3A_data">data</code></td>
<td>
<p>a data frame in which to evaluate <code>formula</code></p>
</td></tr>
<tr><td><code id="qdata_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>quantile</code> or <code>sample</code></p>
</td></tr>
<tr><td><code id="qdata_+3A_q">q</code></td>
<td>
<p>a vector of quantiles</p>
</td></tr>
<tr><td><code id="qdata_+3A_n">n</code></td>
<td>
<p>number of values to sample</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>qdata</code>, a vector of quantiles
</p>
<p>for <code>cdata</code>, a data frame giving
upper and lower limits and the central proportion requested
</p>
<p>For <code>pdata</code>, a vector of probabilities
</p>
<p>For <code>rdata</code>, a vector of sampled values.
</p>
<p>For <code>ddata</code>, a vector of probabilities (empirical densities)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(penguins, package = "palmerpenguins")
qdata(flipper_length_mm ~ species, 0.5, data = penguins)
qdata( ~ flipper_length_mm, p = 0.5, groups = species, data = penguins)
qdata(penguins$flipper_length_mm, p = 0.5)
qdata( ~ flipper_length_mm, p = 0.5, data = penguins)
qdata( ~ flipper_length_mm, p = 0.5, groups = species, data = penguins)
data(penguins, package = 'palmerpenguins')
cdata(penguins$flipper_length_mm, 0.5)
cdata( ~ flipper_length_mm, 0.5, data = penguins)
cdata( ~ flipper_length_mm, 0.5, data = penguins)
cdata( ~ flipper_length_mm | species, data = penguins, p = .5)
data(penguins, package = 'palmerpenguins')
pdata(penguins$flipper_length_mm, 3:6)
pdata( ~ flipper_length_mm, 3:6, data = penguins)
data(penguins, package = 'palmerpenguins')
rdata(penguins$species, 10)
rdata( ~ species, n = 10, data = penguins)
rdata(flipper_length_mm ~ species,  n = 5, data = penguins)
data(penguins, package = 'palmerpenguins')
ddata(penguins$species, 'setosa')
ddata( ~ species, 'setosa', data = penguins)
</code></pre>

<hr>
<h2 id='qdata_v'>The Data Distribution</h2><span id='topic+qdata_v'></span><span id='topic+qdata_f'></span><span id='topic+cdata_v'></span><span id='topic+cdata_f'></span><span id='topic+pdata_v'></span><span id='topic+pdata_f'></span><span id='topic+rdata_v'></span><span id='topic+rdata_f'></span><span id='topic+ddata_v'></span><span id='topic+ddata_f'></span>

<h3>Description</h3>

<p>Utility functions for density, distribution function, quantile function,
and random generation from data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qdata_v(x, p = seq(0, 1, 0.25), na.rm = TRUE, ...)

qdata_f(x, ..., data = NULL, groups = NULL, na.rm = TRUE)

cdata_v(x, p = 0.95, na.rm = TRUE, ...)

cdata_f(x, ..., data = NULL, groups = NULL, na.rm = TRUE)

pdata_v(x, q, lower.tail = TRUE, ...)

pdata_f(x, ..., data = NULL, groups = NULL, na.rm = TRUE)

rdata_v(x, n, replace = TRUE, ...)

rdata_f(x, ..., data = NULL, groups = NULL, na.rm = TRUE)

ddata_v(x, q, ..., data = NULL, log = FALSE, na.rm = TRUE)

ddata_f(x, ..., data = NULL, groups = NULL, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qdata_v_+3A_x">x</code></td>
<td>
<p>a vector containing the data</p>
</td></tr>
<tr><td><code id="qdata_v_+3A_p">p</code></td>
<td>
<p>a vector of probabilities</p>
</td></tr>
<tr><td><code id="qdata_v_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical indicating whether <code>NA</code>s should be removed before computing.</p>
</td></tr>
<tr><td><code id="qdata_v_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code>quantile</code> or <code>sample</code></p>
</td></tr>
<tr><td><code id="qdata_v_+3A_data">data</code></td>
<td>
<p>a data frame in which to evaluate <code>formula</code></p>
</td></tr>
<tr><td><code id="qdata_v_+3A_groups">groups</code></td>
<td>
<p>a grouping variable, typically the name of a variable in <code>data</code></p>
</td></tr>
<tr><td><code id="qdata_v_+3A_q">q</code></td>
<td>
<p>a vector of quantiles</p>
</td></tr>
<tr><td><code id="qdata_v_+3A_lower.tail">lower.tail</code></td>
<td>
<p>a logical indicating whether to use the lower or upper tail probability</p>
</td></tr>
<tr><td><code id="qdata_v_+3A_n">n</code></td>
<td>
<p>number of values to sample</p>
</td></tr>
<tr><td><code id="qdata_v_+3A_replace">replace</code></td>
<td>
<p>a logical indicating whether to sample with replacement</p>
</td></tr>
<tr><td><code id="qdata_v_+3A_log">log</code></td>
<td>
<p>a logical indicating whether the result should be log transformed</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+ddata">ddata()</a></code>, <code><a href="#topic+pdata">pdata()</a></code>, <code><a href="#topic+qdata">qdata()</a></code>,
<code><a href="#topic+rdata">rdata()</a></code>, <code><a href="#topic+cdata">cdata()</a></code>
</p>

<hr>
<h2 id='qdist'>Illustrated quantile calculations from distributions</h2><span id='topic+qdist'></span><span id='topic+xqgamma'></span><span id='topic+xqt'></span><span id='topic+xqchisq'></span><span id='topic+xqf'></span><span id='topic+xqbinom'></span><span id='topic+xqpois'></span><span id='topic+xqgeom'></span><span id='topic+xqnbinom'></span><span id='topic+xqbeta'></span>

<h3>Description</h3>

<p>Illustrated quantile calculations from distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qdist(
  dist = "norm",
  p,
  plot = TRUE,
  verbose = FALSE,
  invisible = FALSE,
  resolution = 500L,
  digits = 3L,
  xlim,
  ylim,
  return = c("values", "plot"),
  refinements = list(),
  ...
)

xqgamma(
  p,
  shape,
  rate = 1,
  scale = 1/rate,
  lower.tail = TRUE,
  log.p = FALSE,
  ...
)

xqt(p, df, ncp, lower.tail = TRUE, log.p = FALSE, ...)

xqchisq(p, df, ncp = 0, lower.tail = TRUE, log.p = FALSE, ...)

xqf(p, df1, df2, lower.tail = TRUE, log.p = FALSE, ...)

xqbinom(p, size, prob, lower.tail = TRUE, log.p = FALSE, ...)

xqpois(p, lambda, lower.tail = TRUE, log.p = FALSE, ...)

xqgeom(p, prob, lower.tail = TRUE, log.p = FALSE, ...)

xqnbinom(p, size, prob, mu, lower.tail = TRUE, log.p = FALSE, ...)

xqbeta(p, shape1, shape2, ncp = 0, lower.tail = TRUE, log.p = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qdist_+3A_dist">dist</code></td>
<td>
<p>a character description of a distribution, for example
<code>"norm"</code>, <code>"t"</code>, or <code>"chisq"</code></p>
</td></tr>
<tr><td><code id="qdist_+3A_p">p</code></td>
<td>
<p>a vector of probabilities</p>
</td></tr>
<tr><td><code id="qdist_+3A_plot">plot</code></td>
<td>
<p>a logical indicating whether a plot should be created</p>
</td></tr>
<tr><td><code id="qdist_+3A_verbose">verbose</code></td>
<td>
<p>a logical</p>
</td></tr>
<tr><td><code id="qdist_+3A_invisible">invisible</code></td>
<td>
<p>a logical</p>
</td></tr>
<tr><td><code id="qdist_+3A_resolution">resolution</code></td>
<td>
<p>number of points used for detecting discreteness and generating plots.
The default value of 5000 should work well except for discrete distributions
that have many distinct values, especially if these values are not evenly spaced.</p>
</td></tr>
<tr><td><code id="qdist_+3A_digits">digits</code></td>
<td>
<p>the number of digits desired</p>
</td></tr>
<tr><td><code id="qdist_+3A_xlim">xlim</code></td>
<td>
<p>x limits.  By default, these are chosen to show the central 99.8\
of the distribution.</p>
</td></tr>
<tr><td><code id="qdist_+3A_ylim">ylim</code></td>
<td>
<p>y limits</p>
</td></tr>
<tr><td><code id="qdist_+3A_return">return</code></td>
<td>
<p>If <code>"plot"</code>, return a plot.  If <code>"values"</code>, return a vector of numerical values.</p>
</td></tr>
<tr><td><code id="qdist_+3A_refinements">refinements</code></td>
<td>
<p>A list of refinements to the plot.  See <code><a href="ggformula.html#topic+gf_aux">ggformula::gf_refine()</a></code>.</p>
</td></tr>
<tr><td><code id="qdist_+3A_...">...</code></td>
<td>
<p>additional arguments, including parameters of the distribution
and additional options for the plot.  To help with name collisions (eg <code>size</code> for binomial
distributions and <code>shape</code> for gamma distributions), argument names beginning <code>plot_</code> will
be renamed to remove <code>plot_</code> and passed only to the plot.  The unprefixed version will
used as a parameter for the the distribution.</p>
</td></tr>
<tr><td><code id="qdist_+3A_shape">shape</code>, <code id="qdist_+3A_scale">scale</code></td>
<td>
<p>shape and scale parameters.  Must be positive,
<code>scale</code> strictly.</p>
</td></tr>
<tr><td><code id="qdist_+3A_rate">rate</code></td>
<td>
<p>an alternative way to specify the scale.</p>
</td></tr>
<tr><td><code id="qdist_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if TRUE (default), probabilities are
<code class="reqn">P[X \le x]</code>, otherwise, <code class="reqn">P[X &gt; x]</code>.</p>
</td></tr>
<tr><td><code id="qdist_+3A_log.p">log.p</code></td>
<td>
<p>A logical indicating whether probabilities should be
returned on the log scale.</p>
</td></tr>
<tr><td><code id="qdist_+3A_df">df</code></td>
<td>
<p>degrees of freedom (<code class="reqn">&gt; 0</code>, maybe non-integer).  <code>df
      = Inf</code> is allowed.</p>
</td></tr>
<tr><td><code id="qdist_+3A_ncp">ncp</code></td>
<td>
<p>non-centrality parameter <code class="reqn">\delta</code>;
currently except for <code>rt()</code>, only for <code>abs(ncp) &lt;= 37.62</code>.
If omitted, use the central t distribution.</p>
</td></tr>
<tr><td><code id="qdist_+3A_df1">df1</code>, <code id="qdist_+3A_df2">df2</code></td>
<td>
<p>degrees of freedom.  <code>Inf</code> is allowed.</p>
</td></tr>
<tr><td><code id="qdist_+3A_size">size</code></td>
<td>
<p>number of trials (zero or more).</p>
</td></tr>
<tr><td><code id="qdist_+3A_prob">prob</code></td>
<td>
<p>probability of success on each trial.</p>
</td></tr>
<tr><td><code id="qdist_+3A_lambda">lambda</code></td>
<td>
<p>vector of (non-negative) means.</p>
</td></tr>
<tr><td><code id="qdist_+3A_mu">mu</code></td>
<td>
<p>alternative parametrization via mean: see &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="qdist_+3A_shape1">shape1</code>, <code id="qdist_+3A_shape2">shape2</code></td>
<td>
<p>non-negative parameters of the Beta distribution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The most general function is <code>qdist</code> which can work with
any distribution for which a q-function exists.  As a convenience, wrappers are
provided for several common distributions.
</p>


<h3>Value</h3>

<p>a vector of quantiles; a plot is printed as a side effect
</p>


<h3>Examples</h3>

<pre><code class='language-R'>qdist("norm", seq(.1, .9, by = 0.10), 
      title = "Deciles of a normal distribution", show.legend = FALSE,
      pattern = "rings")
xqnorm(seq(.2, .8, by = 0.20), mean = 100, sd = 10)
qdist("unif", .5)
xqgamma(.5, shape = 3, scale = 4)
xqgamma(.5, shape = 3, scale = 4, color = "black")
xqbeta(.5, shape1 = .9, shape2 = 1.4, dlwd = 1)
xqchisq(c(.25,.5,.75), df = 3)
xcbinom(c(0.80, 0.90), size = 1000, prob = 0.40)
# displayed as if continuous
xcbinom(c(0.80, 0.90), size = 5000, prob = 0.40)
xpbinom(c(480, 500, 520), size = 1000, prob = 0.48)
xpbinom(c(40, 60), size = 100, prob = 0.5)
xqpois(c(0.25, 0.5, 0.75), lambda = 12)
xcpois(0.50, lambda = 12)
xcpois(0.50, lambda = 12, refinements = list(scale_color_brewer(type = "qual", palette = 5)))
</code></pre>

<hr>
<h2 id='rand'>Random Regressors</h2><span id='topic+rand'></span>

<h3>Description</h3>

<p>A utility function for producing random regressors with a specified
number of degrees of freedom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rand(df = 1, rdist = rnorm, args = list(), nrow, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rand_+3A_df">df</code></td>
<td>
<p>degrees of freedom, i.e., number of random regressors</p>
</td></tr>
<tr><td><code id="rand_+3A_rdist">rdist</code></td>
<td>
<p>random distribution function for sampling</p>
</td></tr>
<tr><td><code id="rand_+3A_args">args</code></td>
<td>
<p>arguments for <code>rdist</code></p>
</td></tr>
<tr><td><code id="rand_+3A_nrow">nrow</code></td>
<td>
<p>number of rows in resulting matrix.  This can often be omitted in
the context of functions like <code>lm</code> where it is inferred from the data frame,
if one is provided.</p>
</td></tr>
<tr><td><code id="rand_+3A_seed">seed</code></td>
<td>
<p>seed for random number generation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of random variates with <code>df</code> columns.
In its intended use, the number of rows will be selected to match the
size of the data frame supplied to <code>lm</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rand(2,nrow=4)
rand(2,rdist=rpois, args=list(lambda=3), nrow=4)
summary(lm( waiting ~ eruptions + rand(1), faithful))
</code></pre>

<hr>
<h2 id='read.file'>Read data files</h2><span id='topic+read.file'></span>

<h3>Description</h3>

<p>A wrapper around various file reading functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read.file(
  file,
  header = T,
  na.strings = "NA",
  comment.char = NULL,
  filetype = c("default", "csv", "txt", "tsv", "fw", "rdata"),
  stringsAsFactors = FALSE,
  readr = FALSE,
  package = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.file_+3A_file">file</code></td>
<td>
<p>character:
The name of the file which the data are to be read from.
This may also be a complete URL or a path to a compressed file.
If it does not contain an absolute path, the file name is
relative to the current working directory,
<code>getwd()</code>.  Tilde-expansion is performed where supported.
See <code><a href="utils.html#topic+read.table">read.table()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="read.file_+3A_header">header</code></td>
<td>
<p>logical;
For <code>.txt</code> and <code>.csv</code> files, this indicates whether the first line of the file includes variables names.</p>
</td></tr>
<tr><td><code id="read.file_+3A_na.strings">na.strings</code></td>
<td>
<p>character: strings that indicate missing data.</p>
</td></tr>
<tr><td><code id="read.file_+3A_comment.char">comment.char</code></td>
<td>
<p>character: a character vector of length one containing a single character or an empty string. Use &quot;&quot; to turn
off the interpretation of comments altogether.</p>
</td></tr>
<tr><td><code id="read.file_+3A_filetype">filetype</code></td>
<td>
<p>one of <code>"default"</code>, <code>"csv"</code>, <code>"txt"</code>, or <code>"rdata"</code>
indicating the type of file being loaded.  The default is to use the filename
to guess the type of file.</p>
</td></tr>
<tr><td><code id="read.file_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>a logical indicating whether strings should be converted to factors.
This has no affect when using <code>readr</code>.</p>
</td></tr>
<tr><td><code id="read.file_+3A_readr">readr</code></td>
<td>
<p>a logical indicating whether functions from the <code>readr</code> package should be
used, if available.</p>
</td></tr>
<tr><td><code id="read.file_+3A_package">package</code></td>
<td>
<p>if specified, files will be searched for among the documentation
files provided by the package.</p>
</td></tr>
<tr><td><code id="read.file_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to
<code><a href="utils.html#topic+read.table">read.table()</a></code>, or <code><a href="base.html#topic+load">load()</a></code> or one of the functions
in the <code>readr</code> package.  Note that a message will indicate which
underlying function is being used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unless <code>filetype</code> is specified,
<code>read.file</code> uses the (case insensitive) file extension to determine how to read
data from the file.  If <code>file</code> ends in <code>.rda</code> or <code>.rdata</code>, then
<code><a href="base.html#topic+load">load()</a></code> is used to load the file.  If <code>file</code>
ends in <code>.csv</code>, then <code><a href="readr.html#topic+read_delim">readr::read_csv()</a></code> or <code><a href="utils.html#topic+read.csv">read.csv()</a></code> is used.
Otherwise, <code><a href="utils.html#topic+read.table">read.table()</a></code> is used.
</p>


<h3>Value</h3>

<p>A data frame, unless <code>file</code> unless <code>filetype</code> is <code>"rdata"</code>,
in which  case arbitrary objects may be loaded and a character vector
holding the names of the loaded objects is returned invisibly.
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+read.csv">read.csv()</a></code>, <code><a href="utils.html#topic+read.table">read.table()</a></code>,
<code><a href="readr.html#topic+read_table">readr::read_table()</a></code>, <code><a href="readr.html#topic+read_delim">readr::read_csv()</a></code>,
<code><a href="base.html#topic+load">load()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
Dome &lt;- read.file("http://www.mosaic-web.org/go/datasets/Dome.csv")

## End(Not run)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+makeFun'></span><span id='topic+fitdistr'></span><span id='topic+fractions'></span><span id='topic+lhs'></span><span id='topic+rhs'></span><span id='topic+condition'></span><span id='topic+counts'></span><span id='topic+props'></span><span id='topic+prop'></span><span id='topic+prop1'></span><span id='topic+perc'></span><span id='topic+percs'></span><span id='topic+count'></span><span id='topic+tally'></span><span id='topic+dfapply'></span><span id='topic+ediff'></span><span id='topic+inspect'></span><span id='topic+msummary'></span><span id='topic+n_missing'></span><span id='topic+logit'></span><span id='topic+ilogit'></span><span id='topic+compare'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>MASS</dt><dd><p><code><a href="MASS.html#topic+fitdistr">fitdistr</a></code>, <code><a href="MASS.html#topic+fractions">fractions</a></code></p>
</dd>
<dt>mosaicCore</dt><dd><p><code><a href="mosaicCore.html#topic+compare">compare</a></code>, <code><a href="mosaicCore.html#topic+parseFormula">condition</a></code>, <code><a href="mosaicCore.html#topic+prop">count</a></code>, <code><a href="mosaicCore.html#topic+props">counts</a></code>, <code><a href="mosaicCore.html#topic+props">counts</a></code>, <code><a href="mosaicCore.html#topic+dfapply">dfapply</a></code>, <code><a href="mosaicCore.html#topic+ediff">ediff</a></code>, <code><a href="mosaicCore.html#topic+logit">ilogit</a></code>, <code><a href="mosaicCore.html#topic+inspect">inspect</a></code>, <code><a href="mosaicCore.html#topic+parseFormula">lhs</a></code>, <code><a href="mosaicCore.html#topic+logit">logit</a></code>, <code><a href="mosaicCore.html#topic+makeFun">makeFun</a></code>, <code><a href="mosaicCore.html#topic+makeFun">makeFun</a></code>, <code><a href="mosaicCore.html#topic+msummary">msummary</a></code>, <code><a href="mosaicCore.html#topic+n_missing">n_missing</a></code>, <code><a href="mosaicCore.html#topic+prop">perc</a></code>, <code><a href="mosaicCore.html#topic+props">percs</a></code>, <code><a href="mosaicCore.html#topic+prop">prop</a></code>, <code><a href="mosaicCore.html#topic+prop">prop1</a></code>, <code><a href="mosaicCore.html#topic+props">props</a></code>, <code><a href="mosaicCore.html#topic+parseFormula">rhs</a></code>, <code><a href="mosaicCore.html#topic+tally">tally</a></code></p>
</dd>
</dl>

<hr>
<h2 id='relm'>Resample a Linear Model</h2><span id='topic+relm'></span>

<h3>Description</h3>

<p>Fit a new model to data created using <code>resample(model)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relm(model, ..., envir = environment(formula(model)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relm_+3A_model">model</code></td>
<td>
<p>a linear model object produced using <code><a href="stats.html#topic+lm">lm()</a></code>.</p>
</td></tr>
<tr><td><code id="relm_+3A_...">...</code></td>
<td>
<p>additional arguments passed through to <code><a href="#topic+resample">resample()</a></code>.</p>
</td></tr>
<tr><td><code id="relm_+3A_envir">envir</code></td>
<td>
<p>an environment in which to (re)evaluate the linear model.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code>resample()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod &lt;- lm(length ~ width, data = KidsFeet)
do(1) * mod 
do(3) * relm(mod) 
# use residual resampling to estimate standard error (very crude because so few replications)
Boot &lt;- do(100) * relm(mod)
sd(~ width, data = Boot)
# standard error as produced by summary() for comparison
mod |&gt; summary() |&gt; coef() 

</code></pre>

<hr>
<h2 id='repeater-class'>Repeater objects</h2><span id='topic+repeater-class'></span>

<h3>Description</h3>

<p>Repeater objects can be used with the <code>*</code> operator to repeat
things multiple time using a different syntax and different output
format from that used by, for example, <code><a href="base.html#topic+replicate">replicate()</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>n</code>:</dt><dd><p>Object of class <code>"numeric"</code> indicating how many times to repeat something.</p>
</dd>
<dt><code>cull</code>:</dt><dd><p>Object of class <code>"function"</code> that culls the output from each repetition.</p>
</dd>
<dt><code>mode</code>:</dt><dd><p>Object of class <code>"character"</code> indicating the output mode
('default', 'data.frame', 'matrix', 'vector', or 'list').  For most purposes 'default' (the default)
should suffice.</p>
</dd>
<dt><code>algorithm</code>:</dt><dd><p>an algorithm number.</p>
</dd>
<dt><code>parallel</code>:</dt><dd><p>a logical indicating whether to attempt parallel execution.</p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+do">do()</a></code>
</p>

<hr>
<h2 id='resample'>More Random Samples</h2><span id='topic+resample'></span><span id='topic+deal'></span><span id='topic+shuffle'></span><span id='topic+sample'></span><span id='topic+sample.default'></span><span id='topic+sample.data.frame'></span><span id='topic+sample.matrix'></span><span id='topic+sample.factor'></span><span id='topic+sample.lm'></span>

<h3>Description</h3>

<p>These functions simplify and unify sampling in various ways.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample(..., replace = TRUE)

deal(...)

shuffle(x, replace = FALSE, prob = NULL, groups = NULL, orig.ids = FALSE)

sample(x, size, replace = FALSE, ...)

## Default S3 method:
sample(
  x,
  size,
  replace = FALSE,
  prob = NULL,
  groups = NULL,
  orig.ids = FALSE,
  ...
)

## S3 method for class 'data.frame'
sample(
  x,
  size,
  replace = FALSE,
  prob = NULL,
  groups = NULL,
  orig.ids = TRUE,
  fixed = names(x),
  shuffled = c(),
  invisibly.return = NULL,
  ...
)

## S3 method for class 'matrix'
sample(
  x,
  size,
  replace = FALSE,
  prob = NULL,
  groups = NULL,
  orig.ids = FALSE,
  ...
)

## S3 method for class 'factor'
sample(
  x,
  size,
  replace = FALSE,
  prob = NULL,
  groups = NULL,
  orig.ids = FALSE,
  drop.unused.levels = FALSE,
  ...
)

## S3 method for class 'lm'
sample(
  x,
  size,
  replace = FALSE,
  prob = NULL,
  groups = NULL,
  orig.ids = FALSE,
  drop.unused.levels = FALSE,
  parametric = FALSE,
  transformation = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_+3A_...">...</code></td>
<td>
<p>additional arguments passed to
<code><a href="base.html#topic+sample">base::sample()</a></code>
or <code><a href="#topic+sample">sample()</a></code>.</p>
</td></tr>
<tr><td><code id="resample_+3A_replace">replace</code></td>
<td>
<p>Should sampling be with replacement?</p>
</td></tr>
<tr><td><code id="resample_+3A_x">x</code></td>
<td>
<p>Either a vector of one or more elements from which to choose, or a positive integer.</p>
</td></tr>
<tr><td><code id="resample_+3A_prob">prob</code></td>
<td>
<p>A vector of probability weights for obtaining the elements of the vector being sampled.</p>
</td></tr>
<tr><td><code id="resample_+3A_groups">groups</code></td>
<td>
<p>a vector (or variable in a data frame) specifying
groups to sample within. This will be recycled if necessary.</p>
</td></tr>
<tr><td><code id="resample_+3A_orig.ids">orig.ids</code></td>
<td>
<p>a logical; should original ids be included in returned data frame?</p>
</td></tr>
<tr><td><code id="resample_+3A_size">size</code></td>
<td>
<p>a non-negative integer giving the number of items to choose.</p>
</td></tr>
<tr><td><code id="resample_+3A_fixed">fixed</code></td>
<td>
<p>a vector of column names.  These variables are shuffled en masse,
preserving associations among these columns.</p>
</td></tr>
<tr><td><code id="resample_+3A_shuffled">shuffled</code></td>
<td>
<p>a vector of column names.
these variables are reshuffled individually (within groups if <code>groups</code> is
specified), breaking associations among these columns.
examples.</p>
</td></tr>
<tr><td><code id="resample_+3A_invisibly.return">invisibly.return</code></td>
<td>
<p>a logical, should return be invisible?</p>
</td></tr>
<tr><td><code id="resample_+3A_drop.unused.levels">drop.unused.levels</code></td>
<td>
<p>a logical, should unused levels be dropped?</p>
</td></tr>
<tr><td><code id="resample_+3A_parametric">parametric</code></td>
<td>
<p>A logical indicating whether the resampling should be done parametrically.</p>
</td></tr>
<tr><td><code id="resample_+3A_transformation">transformation</code></td>
<td>
<p>NULL or a function providing a transformation to be applied to the
synthetic responses.  If NULL, an attempt it made to infer the appropriate transformation
from the original call as recorded in <code>x</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions are wrappers around <code><a href="#topic+sample">sample()</a></code> providing different defaults and
natural names.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 100 Bernoulli trials -- no need for replace=TRUE
resample(0:1, 100)
tally(resample(0:1, 100))
if (require(mosaicData)) {
Small &lt;- sample(KidsFeet, 10)
resample(Small)
tally(~ sex, data=resample(Small))
tally(~ sex, data=resample(Small))
# fixed marginals for sex
tally(~ sex, data=Small)
tally(~ sex, data=resample(Small, groups=sex)) 
# shuffled can be used to reshuffle some variables within groups
# orig.id shows where the values were in original data frame.
Small &lt;- mutate(Small, 
   id1 = paste(sex,1:10, sep=":"),  
   id2 = paste(sex,1:10, sep=":"))
resample(Small, groups=sex, shuffled=c("id1","id2"))
}
deal(Cards, 13)    # A Bridge hand
shuffle(Cards)
model &lt;- lm(width ~length * sex, data = KidsFeet)
KidsFeet |&gt; head()
resample(model) |&gt; head()
Boot &lt;- do(500) * lm(width ~ length * sex, data = resample(KidsFeet))
df_stats(~ Intercept + length + sexG + length.sexG, data = Boot, sd)
head(Boot)
summary(coef(model))


</code></pre>

<hr>
<h2 id='rescale'>Rescale</h2><span id='topic+rescale'></span><span id='topic+rescale.data.frame'></span><span id='topic+rescale.factor'></span><span id='topic+rescale.numeric'></span><span id='topic+rescale.default'></span><span id='topic+rescale.character'></span>

<h3>Description</h3>

<p>Rescale vectors or variables within data frames.  This can be useful
for comparing vectors that are on different scales, for example in
parallel plots or heatmaps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rescale(x, range, domain = NULL, ...)

## S3 method for class 'data.frame'
rescale(x, range = c(0, 1), domain = NULL, ...)

## S3 method for class 'factor'
rescale(x, range, domain = NULL, ...)

## S3 method for class 'numeric'
rescale(x, range = c(0, 1), domain = NULL, ...)

## Default S3 method:
rescale(x, range = c(0, 1), domain = NULL, ...)

## S3 method for class 'character'
rescale(x, range = c(0, 1), domain = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rescale_+3A_x">x</code></td>
<td>
<p>an R object to rescale</p>
</td></tr>
<tr><td><code id="rescale_+3A_range">range</code></td>
<td>
<p>a numeric vector of length 2</p>
</td></tr>
<tr><td><code id="rescale_+3A_domain">domain</code></td>
<td>
<p>a numeric vector of length 2 or <code>NULL</code></p>
</td></tr>
<tr><td><code id="rescale_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>

<hr>
<h2 id='rflip'>Tossing Coins</h2><span id='topic+rflip'></span><span id='topic+print.cointoss'></span><span id='topic+nflip'></span>

<h3>Description</h3>

<p>These functions simplify simulating coin tosses for those (students primarily)
who are not yet familiar with the binomial distributions or just like this syntax
and verbosity better.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rflip(
  n = 1,
  prob = 0.5,
  quiet = FALSE,
  verbose = !quiet,
  summarize = FALSE,
  summarise = summarize
)

## S3 method for class 'cointoss'
print(x, ...)

nflip(n = 1, prob = 0.5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rflip_+3A_n">n</code></td>
<td>
<p>the number of coins to toss</p>
</td></tr>
<tr><td><code id="rflip_+3A_prob">prob</code></td>
<td>
<p>probability of heads on each toss</p>
</td></tr>
<tr><td><code id="rflip_+3A_quiet">quiet</code></td>
<td>
<p>a logical.  If <code>TRUE</code>, less verbose output is used.</p>
</td></tr>
<tr><td><code id="rflip_+3A_verbose">verbose</code></td>
<td>
<p>a logical.  If <code>TRUE</code>, more verbose output is used.</p>
</td></tr>
<tr><td><code id="rflip_+3A_summarize">summarize</code></td>
<td>
<p>if <code>TRUE</code>, return a summary (as a data frame).</p>
</td></tr>
<tr><td><code id="rflip_+3A_summarise">summarise</code></td>
<td>
<p>alternative spelling for <code>summarize</code>.</p>
</td></tr>
<tr><td><code id="rflip_+3A_x">x</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="rflip_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>for <code>rflip</code>, a cointoss object
</p>
<p>for <code>nflip</code>, a numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rflip(10)
rflip(10, prob = 1/6, quiet = TRUE)
rflip(10, prob = 1/6, summarize = TRUE)
do(5) * rflip(10)
as.numeric(rflip(10))
nflip(10)
</code></pre>

<hr>
<h2 id='rfun'>Generate a natural-looking function</h2><span id='topic+rfun'></span><span id='topic+rpoly2'></span>

<h3>Description</h3>

<p>Produce a random function that is the sum of Gaussian random variables
</p>
<p><code>rpoly2</code> generates a random 2nd degree polynomial  (as a function)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rfun(vars = ~x &amp; y, seed = NULL, n = 0)

rpoly2(vars = ~x &amp; y, seed = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rfun_+3A_vars">vars</code></td>
<td>
<p>a formula; the LHS is empty and the RHS indicates the variables used
for input to the function (separated by &amp;)</p>
</td></tr>
<tr><td><code id="rfun_+3A_seed">seed</code></td>
<td>
<p>seed for random number generator, passed to <code><a href="base.html#topic+set.seed">set.seed()</a></code>.</p>
</td></tr>
<tr><td><code id="rfun_+3A_n">n</code></td>
<td>
<p>the number of Gaussians.  By default, this will be selected randomly.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rfun</code> is an easy way to generate a natural-looking but random function with ups and downs
much as you might draw on paper.  In two variables, it provides a good way to produce
a random landscape that is smooth.
Things happen in the domain -5 to 5. The function is pretty flat outside of that.
Use <code>seed</code> to create a fixed function that will be the same for everybody
</p>
<p>These functions are particularly useful for teaching calculus.
</p>


<h3>Value</h3>

<p>a function with the appropriate number of inputs
</p>
<p>a function defined by a 2nd degree polynomial
with coefficients selected randomly according to a Unif(-1,1) distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- rfun( ~ u &amp; v)
plotFun(f(u,v)~u&amp;v,u=range(-5,5),v=range(-5,5))
myfun &lt;- rfun(~ u &amp; v, seed=1959)
g &lt;- rpoly2( ~ x&amp;y&amp;z, seed=1964)
plotFun(g(x,y,z=2)~x&amp;y,xlim=range(-5,5),ylim=range(-5,5))
</code></pre>

<hr>
<h2 id='rgeo-internals'>rgeo internal functions</h2><span id='topic+rgeo-internals'></span><span id='topic+.googleMapURL'></span>

<h3>Description</h3>

<p>These are not really intended for public consumption.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.googleMapURL(
  latitude,
  longitude,
  position = NULL,
  zoom = 11,
  maptype = c("roadmap", "satellite", "terrain", "hybrid"),
  mark = FALSE,
  radius = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rgeo-internals_+3A_latitude">latitude</code>, <code id="rgeo-internals_+3A_longitude">longitude</code></td>
<td>
<p>vectors of latitude and longitude values</p>
</td></tr>
<tr><td><code id="rgeo-internals_+3A_position">position</code></td>
<td>
<p>a data frame containing latitude and longitude positions</p>
</td></tr>
<tr><td><code id="rgeo-internals_+3A_zoom">zoom</code></td>
<td>
<p>zoom level for initial map (1-20)</p>
</td></tr>
<tr><td><code id="rgeo-internals_+3A_maptype">maptype</code></td>
<td>
<p>one of <code>'roadmap'</code>, <code>'satellite'</code>, <code>'terrain'</code>, and <code>'hybrid'</code></p>
</td></tr>
<tr><td><code id="rgeo-internals_+3A_mark">mark</code></td>
<td>
<p>a logical indicating whether the location should be marked with a pin</p>
</td></tr>
<tr><td><code id="rgeo-internals_+3A_radius">radius</code></td>
<td>
<p>a vector of radii of circles centered at position that are displayed on the map</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a URL as a string
</p>

<hr>
<h2 id='rlatlon'>Sample longitude and latitude on a sphere</h2><span id='topic+rlatlon'></span><span id='topic+rlonlat'></span><span id='topic+rgeo'></span><span id='topic+rgeo2'></span>

<h3>Description</h3>

<p>Randomly samples longitude and latitude on earth so that equal areas are
(approximately) equally likely to be sampled.
(Approximation assumes earth as a perfect sphere.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rlatlon(...)

rlonlat(...)

rgeo(n = 1, latlim = c(-90, 90), lonlim = c(-180, 180), verbose = FALSE)

rgeo2(n = 1, latlim = c(-90, 90), lonlim = c(-180, 180), verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rlatlon_+3A_...">...</code></td>
<td>
<p>arguments passed through to other functions</p>
</td></tr>
<tr><td><code id="rlatlon_+3A_n">n</code></td>
<td>
<p>number of random locations</p>
</td></tr>
<tr><td><code id="rlatlon_+3A_latlim">latlim</code>, <code id="rlatlon_+3A_lonlim">lonlim</code></td>
<td>
<p>range of latitudes and longitudes to sample within, only implemented for <code>rgeo</code>.</p>
</td></tr>
<tr><td><code id="rlatlon_+3A_verbose">verbose</code></td>
<td>
<p>return verbose output that includes Euclidean coordinates on unit sphere as well as
longitude and latitude.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rgeo</code> and <code>rgeo2</code> differ in the algorithms used to generate random positions.
Each assumes a spherical globe.  <code>rgeo</code> uses that fact that each of the x, y and z
coordinates is uniformly distributed (but not independent of each other).  Furthermore, the
angle about the z-axis is uniformly distributed and independent of z.  This provides
a straightforward way to generate Euclidean coordinates using <code>runif</code>.  These are then
translated into latitude and longitude.
</p>
<p><code>rlatlon</code> is an alias for <code>rgeo</code> and
<code>rlonlat</code> is too, expect that it reverses the
order in which the latitude and longitude values are
returned.
</p>
<p><code>rgeo2</code> samples points in a cube by independently sampling each coordinate.  It then
discards any point outside the sphere contained in the cube and projects the non-discarded points
to the sphere.  This method must oversample to allow for the discarded points.
</p>


<h3>Value</h3>

<p>a data frame with variables <code>long</code> and <code>lat</code>.  If <code>verbose</code> is
TRUE, then x, y, and z coordinates are also included in the data frame.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+deg2rad">deg2rad()</a></code>, <code><a href="#topic+googleMap">googleMap()</a></code> and <code><a href="#topic+latlon2xyz">latlon2xyz()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rgeo(4)
# sample from a region that contains the continental US
rgeo(4, latlim = c(25,50), lonlim = c(-65, -125))
rgeo2(4)
</code></pre>

<hr>
<h2 id='rspin'>Simulate spinning a spinner</h2><span id='topic+rspin'></span>

<h3>Description</h3>

<p>This is essentially <code>rmultinom</code> with a different interface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rspin(n, probs, labels = 1:length(probs))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rspin_+3A_n">n</code></td>
<td>
<p>number of spins of spinner</p>
</td></tr>
<tr><td><code id="rspin_+3A_probs">probs</code></td>
<td>
<p>a vector of probabilities.  If the sum is not 1, the
probabilities will be rescaled.</p>
</td></tr>
<tr><td><code id="rspin_+3A_labels">labels</code></td>
<td>
<p>a character vector of labels for the categories</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>rspin(20, prob=c(1,2,3), labels=c("Red", "Blue", "Green"))
do(2) * rspin(20, prob=c(1,2,3), labels=c("Red", "Blue", "Green"))
</code></pre>

<hr>
<h2 id='rsquared'>Extract r-squared value</h2><span id='topic+rsquared'></span>

<h3>Description</h3>

<p>Attempts to extract an r-squared value from a model or model-like object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsquared(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsquared_+3A_x">x</code></td>
<td>
<p>an object</p>
</td></tr>
<tr><td><code id="rsquared_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>

<hr>
<h2 id='rstudio_is_available'>Check whether RStudio is in use</h2><span id='topic+rstudio_is_available'></span>

<h3>Description</h3>

<p>This functions checks that RStudio is in use.  It will likely be removed
from this package once the versions of RStudio in popular use rely on the
manipulate package on CRAN which will provide its own version.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rstudio_is_available()
</code></pre>


<h3>Value</h3>

<p>a logical
</p>

<hr>
<h2 id='set.rseed'>Set seed in parallel compatible way</h2><span id='topic+set.rseed'></span>

<h3>Description</h3>

<p>When the parallel package is used, setting the RNG seed for reproducibility
involves more than simply calling <code><a href="base.html#topic+set.seed">set.seed()</a></code>. <code>set.rseed</code> takes
care of the additional overhead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set.rseed(seed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set.rseed_+3A_seed">seed</code></td>
<td>
<p>seed for the random number generator</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the <code>parallel</code> package is not on the search path, then <code><a href="base.html#topic+set.seed">set.seed()</a></code> is called.
If <code>parallel</code> is on the search path, then the RNG kind is set to <code>"L'Ecuyer-CMRG"</code>,
the seed is set and <code>mc.reset.stream</code> is called.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># These should give identical results, even if the `parallel' package is loaded.
set.rseed(123); do(3) * resample(1:10, 2)
set.rseed(123); do(3) * resample(1:10, 2)
</code></pre>

<hr>
<h2 id='Sleep'>Sleep and Memory</h2><span id='topic+Sleep'></span>

<h3>Description</h3>

<p>Sleep and Memory
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Sleep)
</code></pre>


<h3>Format</h3>

<p>A data.frame with 24 observations on the following 2 variables.
</p>

<dl>
<dt><code>Group </code></dt><dd><p>treatment group of the subject</p>
</dd>
<dt><code>Words </code></dt><dd><p>number of words recalled</p>
</dd>
</dl>



<h3>Details</h3>

<p>In an experiment on memory (Mednicj et al, 2008), students were given lists
of 24 words to memorize.  After hearing the words they were assigned at
random to different groups. One group of 12 students took a nap for 1.5 hours
while a second group of 12 students stayed awake and was given a caffeine
pill.  The data set records the number of words each participant was
able to recall after the break.
</p>


<h3>Source</h3>

<p>These data were used in a &quot;resampling bake-off&quot; hosted by Robin Lock.
</p>

<hr>
<h2 id='sp2df'>Transforms a shapefile into a dataframe</h2><span id='topic+sp2df'></span>

<h3>Description</h3>

<p>This function takes in a shapefile (formal class of
<code>SpatialPolygonsDataFrame</code>) and transforms it into a dataframe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sp2df(map, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sp2df_+3A_map">map</code></td>
<td>
<p>A map object of class <code>SpatialPolygonsDataFrame</code></p>
</td></tr>
<tr><td><code id="sp2df_+3A_...">...</code></td>
<td>
<p>Other arguments, currently ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A dataframe, in which the first 7 columns hold geographical
information (ex: <code>long</code> and <code>lat</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
if(require(maptools)) {
  data(wrld_simpl)
  worldmap &lt;- sp2df(wrld_simpl)
}

if ( require(ggplot2) &amp;&amp; require(maptools) ) {
  data(wrld_simpl)
  World &lt;- sp2df(wrld_simpl)
  World2 &lt;- merge(World, Countries, by.x="NAME", by.y="maptools", all.y=FALSE)
  Mdata &lt;- merge(Alcohol, World2, by.x="country", by.y="gapminder", all.y=FALSE)
  Mdata &lt;- Mdata[order(Mdata$order),]
  qplot( x=long, y=lat, fill=ntiles(alcohol,5),
         data=subset(Mdata, year==2008), group = group,
                     geom="polygon")
}

## End(Not run)
</code></pre>

<hr>
<h2 id='standardName'>Standardization of Geographic Names</h2><span id='topic+standardName'></span><span id='topic+standardCountry'></span><span id='topic+standardState'></span>

<h3>Description</h3>

<p>Often different sources of geographical data will use different names for
the same region.  These utilities make it easier to merge data from different
sources by converting names to standardized forms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardName(
  x,
  standard,
  ignore.case = TRUE,
  returnAlternatives = FALSE,
  quiet = FALSE
)

standardCountry(
  x,
  ignore.case = TRUE,
  returnAlternatives = FALSE,
  quiet = FALSE
)

standardState(x, ignore.case = TRUE, returnAlternatives = FALSE, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="standardName_+3A_x">x</code></td>
<td>
<p>A vector with the region names to standardize</p>
</td></tr>
<tr><td><code id="standardName_+3A_standard">standard</code></td>
<td>
<p>a named vector providing the map from
non-standard names (names of vector) to standard names (values of vector)</p>
</td></tr>
<tr><td><code id="standardName_+3A_ignore.case">ignore.case</code></td>
<td>
<p>a logical indicating whether case should be ignored
when matching.</p>
</td></tr>
<tr><td><code id="standardName_+3A_returnalternatives">returnAlternatives</code></td>
<td>
<p>a logical indicating whether all alternatives should
be returned in addition to the standard name.</p>
</td></tr>
<tr><td><code id="standardName_+3A_quiet">quiet</code></td>
<td>
<p>a logical indicating whether warnings should be suppressed</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt>standardName</dt><dd><p>This is the most general standardizing function.
In addition to <code>x</code>, this function requires another argument:
<code>standard</code> - a named vector in which each name is a particular
spelling of the region name in question and the corresponding value
is the standardized version of that region name</p>
</dd>
<dt>standardCountry</dt><dd><p>This function will standardize the country
names in <code>x</code> to the standard ISO_a3 country code format. If
<code>returnAlternatives</code> is set to <code>TRUE</code>, this function will also
return the the named vector used to standardize the country names</p>
</dd>
<dt>standardState</dt><dd><p>This function will standardize the US state
names in <code>x</code> to the standard two-letter abbreviations. If
<code>returnAlternatives</code> is set to <code>TRUE</code>, this function will also
return the the named vector used to standardize the state names</p>
</dd>
</dl>

<p>In all three cases, any names not found in <code>standard</code>
will be left unaltered.  Unless supressed, a warning message will
indicate the number of such cases, if there are any.
</p>

<hr>
<h2 id='statTally'>Tally test statistics</h2><span id='topic+statTally'></span>

<h3>Description</h3>

<p>Tally test statistics from data and from multiple draws
from a simulated null distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>statTally(
  sample,
  rdata,
  FUN,
  direction = NULL,
  alternative = c("default", "two.sided", "less", "greater"),
  sig.level = 0.1,
  system = c("gg", "lattice"),
  shade = "navy",
  alpha = 0.1,
  binwidth = NULL,
  bins = NULL,
  fill = "gray80",
  color = "black",
  center = NULL,
  stemplot = dim(rdata)[direction] &lt; 201,
  q = c(0.5, 0.9, 0.95, 0.99),
  fun = function(x) x,
  xlim,
  quiet = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="statTally_+3A_sample">sample</code></td>
<td>
<p>sample data</p>
</td></tr>
<tr><td><code id="statTally_+3A_rdata">rdata</code></td>
<td>
<p>a matrix of randomly generated data under
null hypothesis.</p>
</td></tr>
<tr><td><code id="statTally_+3A_fun">FUN</code></td>
<td>
<p>a function that computes the test statistic from
a data set.  The default value does nothing, making it easy to
use this to tabulate precomputed statistics into a null distribution.
See the examples.</p>
</td></tr>
<tr><td><code id="statTally_+3A_direction">direction</code></td>
<td>
<p>1 or 2 indicating whether samples in <code>rdata</code>
are in rows (1) or columns (2).</p>
</td></tr>
<tr><td><code id="statTally_+3A_alternative">alternative</code></td>
<td>
<p>one of <code>default</code>, <code>two.sided</code>, <code>less</code>, or <code>greater</code></p>
</td></tr>
<tr><td><code id="statTally_+3A_sig.level">sig.level</code></td>
<td>
<p>significance threshold for <code>wilcox.test</code> used to detect lack of symmetry</p>
</td></tr>
<tr><td><code id="statTally_+3A_system">system</code></td>
<td>
<p>graphics system to use for the plot</p>
</td></tr>
<tr><td><code id="statTally_+3A_shade">shade</code></td>
<td>
<p>a color to use for shading.</p>
</td></tr>
<tr><td><code id="statTally_+3A_alpha">alpha</code></td>
<td>
<p>opacity of shading.</p>
</td></tr>
<tr><td><code id="statTally_+3A_binwidth">binwidth</code></td>
<td>
<p>bin width for histogram.</p>
</td></tr>
<tr><td><code id="statTally_+3A_bins">bins</code></td>
<td>
<p>number of bins for histogram.</p>
</td></tr>
<tr><td><code id="statTally_+3A_fill">fill</code></td>
<td>
<p>fill color for histogram.</p>
</td></tr>
<tr><td><code id="statTally_+3A_color">color</code></td>
<td>
<p>border color for histogram.</p>
</td></tr>
<tr><td><code id="statTally_+3A_center">center</code></td>
<td>
<p>center of null distribution</p>
</td></tr>
<tr><td><code id="statTally_+3A_stemplot">stemplot</code></td>
<td>
<p>indicates whether a stem plot should be displayed</p>
</td></tr>
<tr><td><code id="statTally_+3A_q">q</code></td>
<td>
<p>quantiles of sampling distribution to display</p>
</td></tr>
<tr><td><code id="statTally_+3A_fun">fun</code></td>
<td>
<p>same as <code>FUN</code> so you don't have to remember if it
should be capitalized</p>
</td></tr>
<tr><td><code id="statTally_+3A_xlim">xlim</code></td>
<td>
<p>limits for the horizontal axis of the plot.</p>
</td></tr>
<tr><td><code id="statTally_+3A_quiet">quiet</code></td>
<td>
<p>a logicial indicating whether the text output should be suppressed</p>
</td></tr>
<tr><td><code id="statTally_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="lattice.html#topic+histogram">lattice::histogram()</a></code> or <code><a href="ggplot2.html#topic+geom_histogram">ggplot2::geom_histogram()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A lattice or ggplot showing the sampling distribution.
</p>
<p>As side effects, information
about the empirical sampling distribution and (optionally) a stem plot are
printed to the screen.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># is my spinner fair?
x &lt;- c(10, 18, 9, 15)   # counts in four cells
rdata &lt;- rmultinom(999, sum(x), prob = rep(.25, 4))
statTally(x, rdata, fun = max, binwidth = 1)  # unusual test statistic
statTally(x, rdata, fun = var, shade = "red", binwidth = 2)  # equivalent to chi-squared test
# Can also be used with test stats that are precomputed.
if (require(mosaicData)) {
D &lt;- diffmean( age ~ sex, data = HELPrct); D
nullDist &lt;- do(999) * diffmean( age ~ shuffle(sex), data = HELPrct)
statTally(D, nullDist)
statTally(D, nullDist, system = "lattice")
}

</code></pre>

<hr>
<h2 id='surround'>Format strings for pretty output</h2><span id='topic+surround'></span>

<h3>Description</h3>

<p>Format strings for pretty output
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surround(x, pre = " ", post = " ", width = 8, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surround_+3A_x">x</code></td>
<td>
<p>a vector</p>
</td></tr>
<tr><td><code id="surround_+3A_pre">pre</code></td>
<td>
<p>text to prepend onto string</p>
</td></tr>
<tr><td><code id="surround_+3A_post">post</code></td>
<td>
<p>text to postpend onto string</p>
</td></tr>
<tr><td><code id="surround_+3A_width">width</code></td>
<td>
<p>desired width of string</p>
</td></tr>
<tr><td><code id="surround_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="base.html#topic+format">format()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of strings padded to the desired width
</p>


<h3>Examples</h3>

<pre><code class='language-R'>surround(rbinom(10,20,.5), " ", " ", width=4)
surround(rnorm(10), " ", " ", width=8, digits = 2, nsmall = 2)
</code></pre>

<hr>
<h2 id='swap'>Swap values among columns of a data frame</h2><span id='topic+swap'></span>

<h3>Description</h3>

<p>Swap values among columns of a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swap(data, which)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swap_+3A_data">data</code></td>
<td>
<p>a data frame</p>
</td></tr>
<tr><td><code id="swap_+3A_which">which</code></td>
<td>
<p>a formula or an integer or character vector specifying columns in
<code>data</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>swap</code> is not a particularly speedy function.  It is intended primarily
as an aid for teaching randomization for paired designs.  Used this way, the number of
randomizations should be kept modest (approximately 1000) unless you are very patient.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(tidyr)) {
  Sleep2 &lt;- sleep |&gt; spread( key=group, val=extra )
  names(Sleep2) &lt;- c("subject", "drug1", "drug2")
  swap(Sleep2, drug1 ~ drug2)
  mean( ~(drug1 - drug2), data=Sleep2)
  do(3) * mean( ~(drug1 - drug2), data=Sleep2 |&gt; swap(drug1 ~ drug2) ) 
} 
</code></pre>

<hr>
<h2 id='t_test'>Student's t-Test</h2><span id='topic+t_test'></span><span id='topic+t.test'></span><span id='topic+t_test.formula'></span><span id='topic+t_test.default'></span>

<h3>Description</h3>

<p>Performs one and two sample t-tests.
The mosaic <code>t.test</code> provides wrapper functions around the function
of the same name in <span class="pkg">stats</span>.
These wrappers provide an extended interface that allows for a more systematic
use of the formula interface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>t_test(x, ...)

t.test(x, ...)

## S3 method for class 'formula'
t_test(formula, data, ..., groups = NULL)

## Default S3 method:
t_test(
  x,
  y = NULL,
  alternative = c("two.sided", "less", "greater"),
  mu = 0,
  paired = FALSE,
  var.equal = FALSE,
  conf.level = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="t_test_+3A_x">x</code></td>
<td>
<p>a (non-empty) numeric vector of data values.</p>
</td></tr>
<tr><td><code id="t_test_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to or from methods.</p>
</td></tr>
<tr><td><code id="t_test_+3A_formula">formula</code></td>
<td>
<p>a formula of the form <code>lhs ~ rhs</code> where <code>lhs</code>
is a numeric variable giving the data values and <code>rhs</code> either 
<code>1</code> for a one-sample or paired test or a factor
with two levels giving the corresponding groups. If <code>lhs</code> is of 
class <code>"Pair"</code> and <code>rhs</code> is <code>1</code>, a paired test is done</p>
</td></tr>
<tr><td><code id="t_test_+3A_data">data</code></td>
<td>
<p>an optional matrix or data frame (or similar: see
<code><a href="stats.html#topic+model.frame">model.frame</a></code>) containing the variables in the
formula <code>formula</code>.  By default the variables are taken from
<code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="t_test_+3A_groups">groups</code></td>
<td>
<p>When <code>x</code> is a formula, <code>groups</code> can be used to compare groups:
<code style="white-space: pre;">&#8288;x = ~ var, groups = g&#8288;</code> is equivalent to <code>x = var ~ g</code>.
See the examples.</p>
</td></tr>
<tr><td><code id="t_test_+3A_y">y</code></td>
<td>
<p>an optional (non-empty) numeric vector of data values.</p>
</td></tr>
<tr><td><code id="t_test_+3A_alternative">alternative</code></td>
<td>
<p>a character string specifying the alternative
hypothesis, must be one of <code>"two.sided"</code> (default),
<code>"greater"</code> or <code>"less"</code>.  You can specify just the initial
letter.</p>
</td></tr>
<tr><td><code id="t_test_+3A_mu">mu</code></td>
<td>
<p>a number indicating the true value of the mean (or
difference in means if you are performing a two sample test).</p>
</td></tr>
<tr><td><code id="t_test_+3A_paired">paired</code></td>
<td>
<p>a logical indicating whether you want a paired
t-test.</p>
</td></tr>
<tr><td><code id="t_test_+3A_var.equal">var.equal</code></td>
<td>
<p>a logical variable indicating whether to treat the
two variances as being equal. If <code>TRUE</code> then the pooled
variance is used to estimate the variance otherwise the Welch
(or Satterthwaite) approximation to the degrees of freedom is used.</p>
</td></tr>
<tr><td><code id="t_test_+3A_conf.level">conf.level</code></td>
<td>
<p>confidence level of the interval.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a wrapper around <code><a href="stats.html#topic+t.test">stats::t.test()</a></code> from the <span class="pkg">stats</span> package
to extend the functionality of the formula interface.  In particular, one can
now use the formula interface for a 1-sample t-test.  Before, the formula interface
was only permitted for a 2-sample test.  The type of formula that can be used
for the 2-sample test has also be broadened.  See the examples.
</p>


<h3>Value</h3>

<p>an object of class <code>htest</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+prop.test">prop.test()</a></code>, <code><a href="#topic+binom.test">binom.test()</a></code>,
<code><a href="stats.html#topic+t.test">stats::t.test()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  t.test(HELPrct$age)
  # We can now do this with a formula
  t.test(~ age, data = HELPrct)
  # data = can be omitted, but it is better to use it
  t.test(~ age, HELPrct)
  # the original 2-sample formula
  t.test(age ~ sex, data = HELPrct)
  # alternative 2-sample formulas
  t.test(~ age | sex, data = HELPrct)
  t.test(~ age, groups = sex, data = HELPrct)
  # 2-sample t from vectors
  with(HELPrct, t.test(age[sex == "male"], age[sex == "female"]))
  # just the means
  mean(age ~ sex, data = HELPrct)
</code></pre>

<hr>
<h2 id='theme_map'>ggplot2 theme for maps</h2><span id='topic+theme_map'></span>

<h3>Description</h3>

<p>A very plain <span class="pkg">ggplot2</span> theme that is good for maps.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theme_map(base_size = 12)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theme_map_+3A_base_size">base_size</code></td>
<td>
<p>the base font size for the theme.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This theme is largely based on an example posted by
Winston Chang at the <span class="pkg">ggplot2</span> Google group forum.
</p>

<hr>
<h2 id='theme.mosaic'>Lattice Theme</h2><span id='topic+theme.mosaic'></span><span id='topic+col.mosaic'></span>

<h3>Description</h3>

<p>A theme for use with lattice graphics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theme.mosaic(bw = FALSE, lty = if (bw) 1:7 else 1, lwd = 2, ...)

col.mosaic(bw = FALSE, lty = if (bw) 1:7 else 1, lwd = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theme.mosaic_+3A_bw">bw</code></td>
<td>
<p>whether color scheme should be &quot;black and white&quot;</p>
</td></tr>
<tr><td><code id="theme.mosaic_+3A_lty">lty</code></td>
<td>
<p>vector of line type codes</p>
</td></tr>
<tr><td><code id="theme.mosaic_+3A_lwd">lwd</code></td>
<td>
<p>vector of line widths</p>
</td></tr>
<tr><td><code id="theme.mosaic_+3A_...">...</code></td>
<td>
<p>additional named arguments passed to
<code><a href="lattice.html#topic+trellis.par.set">trellis.par.set()</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list that can be supplied as the <code>theme</code> to
<code><a href="lattice.html#topic+trellis.par.set">trellis.par.set()</a></code>.
</p>


<h3>Note</h3>

<p>These two functions are identical.  <code>col.mosaic</code> is named
similarly to <code><a href="lattice.html#topic+standard.theme">lattice::col.whitebg()</a></code>, but since more
than just colors are set, <code>theme.mosaic</code> is a preferable name.
</p>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+trellis.par.set">trellis.par.set()</a></code>, <code><a href="lattice.html#topic+show.settings">show.settings()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trellis.par.set(theme=theme.mosaic())
show.settings()
trellis.par.set(theme=theme.mosaic(bw=TRUE))
show.settings()

</code></pre>

<hr>
<h2 id='TukeyHSD.lm'>Additional interfaces to TukeyHSD</h2><span id='topic+TukeyHSD.lm'></span><span id='topic+TukeyHSD.formula'></span>

<h3>Description</h3>

<p><code><a href="stats.html#topic+TukeyHSD">TukeyHSD()</a></code> requires use of <code><a href="stats.html#topic+aov">aov()</a></code>.
Since this is a hindrance for beginners, wrappers
have been provided to remove this need.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lm'
TukeyHSD(x, which, ordered = FALSE, conf.level = 0.95, ...)

## S3 method for class 'formula'
TukeyHSD(
  x,
  which,
  ordered = FALSE,
  conf.level = 0.95,
  data = parent.frame(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TukeyHSD.lm_+3A_x">x</code></td>
<td>
<p>an object, for example of class <code>lm</code> or <code>formula</code></p>
</td></tr>
<tr><td><code id="TukeyHSD.lm_+3A_which">which</code>, <code id="TukeyHSD.lm_+3A_ordered">ordered</code>, <code id="TukeyHSD.lm_+3A_conf.level">conf.level</code>, <code id="TukeyHSD.lm_+3A_...">...</code></td>
<td>
<p>just as in <code><a href="stats.html#topic+TukeyHSD">TukeyHSD()</a></code> from the <code>base</code> package</p>
</td></tr>
<tr><td><code id="TukeyHSD.lm_+3A_data">data</code></td>
<td>
<p>a data frame.  NB: This does not come second in the argument list.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## These should all give the same results
if (require(mosaicData)) {
  model &lt;- lm(age ~ substance, data=HELPrct)
  TukeyHSD(model)
  TukeyHSD( age ~ substance, data=HELPrct)
  TukeyHSD(aov(age ~ substance, data=HELPrct))
}
</code></pre>

<hr>
<h2 id='update_ci'>Update confidence interval</h2><span id='topic+update_ci'></span>

<h3>Description</h3>

<p>Update the confidence interval portion of an object returned from
<code>binom.test</code> using one of several alternative methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_ci(
  object,
  method = c("clopper-pearson", "wald", "agresti-coull", "plus4", "score", "prop.test")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_ci_+3A_object">object</code></td>
<td>
<p>An <code>"htest"</code> object produced by <code><a href="#topic+binom.test">binom.test()</a></code></p>
</td></tr>
<tr><td><code id="update_ci_+3A_method">method</code></td>
<td>
<p>a method for computing a confidence interval for a proportion.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an <code>"htest"</code> object with an updated confidence interval
</p>


<h3>See Also</h3>

<p><code><a href="#topic+binom.test">binom.test()</a></code>
</p>

<hr>
<h2 id='value'>Extract value from an object</h2><span id='topic+value'></span><span id='topic+value.integrate'></span><span id='topic+value.default'></span>

<h3>Description</h3>

<p>Functions like <code><a href="stats.html#topic+integrate">integrate()</a></code> and <code><a href="stats.html#topic+nlm">nlm()</a></code> return objects that contain more
information that simply the value of the integration or optimization.  <code>value()</code> extracts
the primary value from such objects.  Currently implemented situations include the output from
<code><a href="stats.html#topic+integrate">integrate()</a></code>,
<code><a href="stats.html#topic+nlm">nlm()</a></code>,
<code><a href="cubature.html#topic+hcubature">cubature::adaptIntegrate()</a></code>, and
<code><a href="stats.html#topic+uniroot">uniroot()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>value(object, ...)

## S3 method for class 'integrate'
value(object, ...)

## Default S3 method:
value(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="value_+3A_object">object</code></td>
<td>
<p>an object from which a &quot;value&quot; is to be extracted.</p>
</td></tr>
<tr><td><code id="value_+3A_...">...</code></td>
<td>
<p>additional arguments (currently ignored).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>integrate(sin, 0, 1) |&gt; value()
nlm(cos, p = 0) |&gt; value()
uniroot(cos, c(0, 2)) |&gt; value()
</code></pre>

<hr>
<h2 id='xchisq.test'>Augmented Chi-squared test</h2><span id='topic+xchisq.test'></span>

<h3>Description</h3>

<p>This augmented version of <code><a href="stats.html#topic+chisq.test">chisq.test()</a></code> provides more verbose
output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xchisq.test(
  x,
  y = NULL,
  correct = TRUE,
  p = rep(1/length(x), length(x)),
  rescale.p = FALSE,
  simulate.p.value = FALSE,
  B = 2000,
  data = environment(x)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xchisq.test_+3A_x">x</code>, <code id="xchisq.test_+3A_y">y</code>, <code id="xchisq.test_+3A_correct">correct</code>, <code id="xchisq.test_+3A_p">p</code>, <code id="xchisq.test_+3A_rescale.p">rescale.p</code>, <code id="xchisq.test_+3A_simulate.p.value">simulate.p.value</code>, <code id="xchisq.test_+3A_b">B</code></td>
<td>
<p>as in <code><a href="stats.html#topic+chisq.test">chisq.test()</a></code>, but
<code>x</code> may also be a formula, in which case <code>x</code> is replaced by <code>tally(x, data)</code>
prior to the call to <code><a href="stats.html#topic+chisq.test">chisq.test()</a></code>.</p>
</td></tr>
<tr><td><code id="xchisq.test_+3A_data">data</code></td>
<td>
<p>a data frame for use when <code>x</code> is a formula.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+chisq.test">chisq.test()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Physicians' Health Study data
phs &lt;- cbind(c(104,189),c(10933,10845)) 
rownames(phs) &lt;- c("aspirin","placebo") 
colnames(phs) &lt;- c("heart attack","no heart attack") 
phs 
xchisq.test(phs) 
xchisq.test(sex ~ substance, data = HELPrct)
</code></pre>

<hr>
<h2 id='xhistogramBreaks'>Augmented histograms</h2><span id='topic+xhistogramBreaks'></span><span id='topic+histogram'></span><span id='topic+prepanel.xhistogram'></span><span id='topic+panel.xhistogram'></span>

<h3>Description</h3>

<p>The <span class="pkg">mosaic</span> package adds some additional functionality to
<code><a href="lattice.html#topic+histogram">lattice::histogram()</a></code>, making it simpler to obtain certain common
histogram adornments.  This is done be resetting the default panel
and prepanel functions used by histogram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xhistogramBreaks(x, center = NULL, width = NULL, nint, ...)

prepanel.xhistogram(x, breaks = xhistogramBreaks, ...)

panel.xhistogram(
  x,
  dcol = trellis.par.get("plot.line")$col,
  dalpha = 1,
  dlwd = 2,
  gcol = trellis.par.get("add.line")$col,
  glwd = 2,
  fcol = trellis.par.get("superpose.polygon")$col,
  dmath = dnorm,
  verbose = FALSE,
  dn = 100,
  args = NULL,
  labels = FALSE,
  density = NULL,
  under = FALSE,
  fit = NULL,
  start = NULL,
  type = "density",
  v,
  h,
  groups = NULL,
  center = NULL,
  width = NULL,
  breaks,
  nint = round(1.5 * log2(length(x)) + 1),
  stripes = c("vertical", "horizontal", "none"),
  alpha = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xhistogramBreaks_+3A_x">x</code></td>
<td>
<p>a formula or a numeric vector</p>
</td></tr>
<tr><td><code id="xhistogramBreaks_+3A_center">center</code></td>
<td>
<p>center of one of the bins</p>
</td></tr>
<tr><td><code id="xhistogramBreaks_+3A_width">width</code></td>
<td>
<p>width of the bins</p>
</td></tr>
<tr><td><code id="xhistogramBreaks_+3A_nint">nint</code></td>
<td>
<p>approximate number of bins</p>
</td></tr>
<tr><td><code id="xhistogramBreaks_+3A_...">...</code></td>
<td>
<p>additional arguments passed from <code><a href="lattice.html#topic+histogram">lattice::histogram()</a></code>
to the panel function; by default when the <span class="pkg">mosaic</span> package has been loaded this
will be <code><a href="#topic+panel.xhistogram">panel.xhistogram()</a></code>.</p>
</td></tr>
<tr><td><code id="xhistogramBreaks_+3A_breaks">breaks</code></td>
<td>
<p>break points for histogram bins, a function for computing such,
or a method <code><a href="graphics.html#topic+hist">hist()</a></code> knows about given as a character string.
When using the <span class="pkg">mosaic</span> package defaults,
<code><a href="#topic+xhistogramBreaks">xhistogramBreaks()</a></code> is used.</p>
</td></tr>
<tr><td><code id="xhistogramBreaks_+3A_dcol">dcol</code></td>
<td>
<p>color of density curve</p>
</td></tr>
<tr><td><code id="xhistogramBreaks_+3A_dalpha">dalpha</code></td>
<td>
<p>alpha for density curve</p>
</td></tr>
<tr><td><code id="xhistogramBreaks_+3A_dlwd">dlwd</code>, <code id="xhistogramBreaks_+3A_glwd">glwd</code></td>
<td>
<p>like <code>lwd</code> but affecting the density line and guide lines, respectively</p>
</td></tr>
<tr><td><code id="xhistogramBreaks_+3A_gcol">gcol</code></td>
<td>
<p>color of guidelines</p>
</td></tr>
<tr><td><code id="xhistogramBreaks_+3A_fcol">fcol</code></td>
<td>
<p>fill colors for histogram rectangles when using <code>groups</code>.
(Use <code>col</code>, which is passed through to the histogram panel function,
when not using <code>groups</code>.)</p>
</td></tr>
<tr><td><code id="xhistogramBreaks_+3A_dmath">dmath</code></td>
<td>
<p>density function for density curve overlay</p>
</td></tr>
<tr><td><code id="xhistogramBreaks_+3A_verbose">verbose</code></td>
<td>
<p>be verbose?</p>
</td></tr>
<tr><td><code id="xhistogramBreaks_+3A_dn">dn</code></td>
<td>
<p>number of points to sample from density curve</p>
</td></tr>
<tr><td><code id="xhistogramBreaks_+3A_args">args</code></td>
<td>
<p>a list of additional arguments for <code>dmath</code></p>
</td></tr>
<tr><td><code id="xhistogramBreaks_+3A_labels">labels</code></td>
<td>
<p>should counts/densities/percents be displayed or each bin?</p>
</td></tr>
<tr><td><code id="xhistogramBreaks_+3A_density">density</code></td>
<td>
<p>a logical indicating whether to overlay a density curve</p>
</td></tr>
<tr><td><code id="xhistogramBreaks_+3A_under">under</code></td>
<td>
<p>a logical indicating whether the density layers should be under or
over other layers of the plot.</p>
</td></tr>
<tr><td><code id="xhistogramBreaks_+3A_fit">fit</code></td>
<td>
<p>a character string describing the distribution to fit.  Known distributions include
<code>"exponential"</code>, <code>"normal"</code>, <code>"lognormal" </code>, <code>"poisson"</code>, <code>"beta"</code>, <code>"geometric"</code>,
<code>"t"</code>, <code>"weibull"</code>, <code>"cauchy"</code>, <code>"gamma"</code>, <code>"chisq"</code>, and <code>"chi-squared"</code></p>
</td></tr>
<tr><td><code id="xhistogramBreaks_+3A_start">start</code></td>
<td>
<p>numeric value passed to <code><a href="MASS.html#topic+fitdistr">MASS::fitdistr()</a></code></p>
</td></tr>
<tr><td><code id="xhistogramBreaks_+3A_type">type</code></td>
<td>
<p>one of <code>'density'</code>, <code>'count'</code>, or <code>'percent'</code></p>
</td></tr>
<tr><td><code id="xhistogramBreaks_+3A_h">h</code>, <code id="xhistogramBreaks_+3A_v">v</code></td>
<td>
<p>a vector of values for additional horizontal and vertical lines</p>
</td></tr>
<tr><td><code id="xhistogramBreaks_+3A_groups">groups</code></td>
<td>
<p>as per <code><a href="lattice.html#topic+histogram">lattice::histogram()</a></code></p>
</td></tr>
<tr><td><code id="xhistogramBreaks_+3A_stripes">stripes</code></td>
<td>
<p>one of <code>"vertical"</code>, <code>"horizontal"</code>, or <code>"none"</code>, indicating
how bins should be striped when <code>groups</code> is not <code>NULL</code></p>
</td></tr>
<tr><td><code id="xhistogramBreaks_+3A_alpha">alpha</code></td>
<td>
<p>transparency level</p>
</td></tr>
<tr><td><code id="xhistogramBreaks_+3A_panel">panel</code></td>
<td>
<p>a panel function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The primary additional functionality added to <code><a href="#topic+histogram">histogram()</a></code>
are the arguments <code>width</code> and <code>center</code> which provide a simple
way of describing equal-sized bins, and <code>fit</code> which can be used to
overlay the density curve for one of several distributions.  The
<code>groups</code> argument can be used to color the bins.  The primary use
for this is to shade tails of histograms, but there may be other uses
as well.
</p>


<h3>Value</h3>

<p><code>xhistogramBreaks</code> returns a vector of break points
</p>


<h3>Note</h3>

<p>Versions of <span class="pkg">lattice</span> since 0.20-21 support setting custom defaults
for <code>breaks</code>, <code>panel</code>, and <code>prepanel</code> used by
<code>histogram()</code>, so <code>xhistogram()</code> is no longer needed.
As a result, <code>xhistogram()</code>
(which was required in earlier versions of <span class="pkg">mosaic</span>
is no longer needed and has been removed.
</p>


<h3>See Also</h3>

<p><code><a href="lattice.html#topic+histogram">lattice::histogram()</a></code>, <code><a href="#topic+mosaicLatticeOptions">mosaicLatticeOptions()</a></code>,
and <code><a href="#topic+restoreLatticeOptions">restoreLatticeOptions()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(mosaicData)) {
histogram(~age | substance, HELPrct, v=35, fit='normal')
histogram(~age, HELPrct, labels=TRUE, type='count')
histogram(~age, HELPrct, groups=cut(age, seq(10,80,by=10)))
histogram(~age, HELPrct, groups=sex, stripes='horizontal')
histogram(~racegrp, HELPrct, groups=substance,auto.key=TRUE)
xhistogramBreaks(1:10, center=5, width=1)
xhistogramBreaks(1:10, center=5, width=2)
xhistogramBreaks(0:10, center=15, width=3)
xhistogramBreaks(1:100, center=50, width=3)
xhistogramBreaks(0:10, center=5, nint=5)
}
</code></pre>

<hr>
<h2 id='xpnorm'>Augmented versions of pnorm and qnorm</h2><span id='topic+xpnorm'></span><span id='topic+xqnorm'></span><span id='topic+xcnorm'></span>

<h3>Description</h3>

<p>These functions behave similarly to the functions with the initial <code>x</code>
removed from their names but add more verbose output and graphics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xpnorm(
  q,
  mean = 0,
  sd = 1,
  plot = TRUE,
  verbose = TRUE,
  invisible = FALSE,
  digits = 4,
  lower.tail = TRUE,
  log.p = FALSE,
  xlim = mean + c(-4, 4) * sd,
  ylim = c(0, 1.4 * dnorm(mean, mean, sd)),
  manipulate = FALSE,
  ...,
  return = c("value", "plot")
)

xqnorm(
  p,
  mean = 0,
  sd = 1,
  plot = TRUE,
  verbose = TRUE,
  digits = getOption("digits"),
  lower.tail = TRUE,
  log.p = FALSE,
  xlim,
  ylim,
  invisible = FALSE,
  ...,
  return = c("value", "plot"),
  pattern = c("stripes", "rings")
)

xcnorm(
  p,
  mean = 0,
  sd = 1,
  plot = TRUE,
  verbose = TRUE,
  digits = getOption("digits"),
  lower.tail = TRUE,
  log.p = FALSE,
  xlim,
  ylim,
  invisible = FALSE,
  ...,
  return = c("value", "plot"),
  pattern = "rings"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xpnorm_+3A_q">q</code></td>
<td>
<p>quantile</p>
</td></tr>
<tr><td><code id="xpnorm_+3A_mean">mean</code>, <code id="xpnorm_+3A_sd">sd</code></td>
<td>
<p>parameters of normal distribution.</p>
</td></tr>
<tr><td><code id="xpnorm_+3A_plot">plot</code></td>
<td>
<p>logical.  If TRUE, show an illustrative plot.</p>
</td></tr>
<tr><td><code id="xpnorm_+3A_verbose">verbose</code></td>
<td>
<p>logical.  If TRUE, display verbose output.</p>
</td></tr>
<tr><td><code id="xpnorm_+3A_invisible">invisible</code></td>
<td>
<p>logical.  If TRUE, return value invisibly.</p>
</td></tr>
<tr><td><code id="xpnorm_+3A_digits">digits</code></td>
<td>
<p>number of digits to display in output.</p>
</td></tr>
<tr><td><code id="xpnorm_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical.  If FALSE, use upper tail probabilities.</p>
</td></tr>
<tr><td><code id="xpnorm_+3A_log.p">log.p</code></td>
<td>
<p>logical.  If TRUE, uses the log of probabilities.</p>
</td></tr>
<tr><td><code id="xpnorm_+3A_xlim">xlim</code>, <code id="xpnorm_+3A_ylim">ylim</code></td>
<td>
<p>limits for plotting.</p>
</td></tr>
<tr><td><code id="xpnorm_+3A_manipulate">manipulate</code></td>
<td>
<p>logical.  If TRUE and in RStudio,
then sliders are added for interactivity.</p>
</td></tr>
<tr><td><code id="xpnorm_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
<tr><td><code id="xpnorm_+3A_return">return</code></td>
<td>
<p>If <code>"plot"</code>, return a plot.  If <code>"values"</code>, return a vector of numerical values.</p>
</td></tr>
<tr><td><code id="xpnorm_+3A_p">p</code></td>
<td>
<p>probability</p>
</td></tr>
<tr><td><code id="xpnorm_+3A_pattern">pattern</code></td>
<td>
<p>One of <code>"stripes"</code> or <code>"rings"</code>.  In the latter case, pairs of regions
(from inside to outside) are grouped together for coloring and probability calculation.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+histogram">histogram()</a></code>,
<code><a href="stats.html#topic+chisq.test">chisq.test()</a></code>,
<code><a href="stats.html#topic+pnorm">pnorm()</a></code>,
<code><a href="stats.html#topic+qnorm">qnorm()</a></code>,
<code><a href="lattice.html#topic+qqmath">qqmath()</a></code>, and
<code><a href="graphics.html#topic+plot">plot()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xpnorm(650, 500, 100)
xqnorm(.75, 500, 100)
xpnorm(-3:3, return = "plot", system = "gg") |&gt; 
  gf_labs(title = "My Plot", x = "") |&gt; 
  gf_theme(theme_bw())

## Not run: 
if (rstudio_is_available() &amp; require(manipulate)) {
  manipulate(xpnorm(score, 500, 100, verbose = verbose),
    score = slider(200, 800),
	   verbose = checkbox(TRUE, label = "Verbose Output")
  )
}

## End(Not run)
</code></pre>

<hr>
<h2 id='xqqmath'>Augmented version of <code>qqmath</code></h2><span id='topic+xqqmath'></span><span id='topic+panel.xqqmath'></span>

<h3>Description</h3>

<p>Augmented version of <code>qqmath</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xqqmath(x, data = NULL, panel = "panel.xqqmath", ...)

panel.xqqmath(
  x,
  qqmathline = !(fitline || idline),
  idline = FALSE,
  fitline = NULL,
  slope = NULL,
  intercept = NULL,
  overlines = FALSE,
  groups = NULL,
  ...,
  col.line = trellis.par.get("add.line")$col,
  pch = 16,
  lwd = 2,
  lty = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xqqmath_+3A_x">x</code>, <code id="xqqmath_+3A_data">data</code>, <code id="xqqmath_+3A_panel">panel</code>, <code id="xqqmath_+3A_...">...</code></td>
<td>
<p>as in <code><a href="lattice.html#topic+qqmath">lattice::qqmath()</a></code></p>
</td></tr>
<tr><td><code id="xqqmath_+3A_qqmathline">qqmathline</code></td>
<td>
<p>a logical: should line be displayed passing through first and third quartiles?</p>
</td></tr>
<tr><td><code id="xqqmath_+3A_idline">idline</code></td>
<td>
<p>a logical; should the line y=x be added to the plot?</p>
</td></tr>
<tr><td><code id="xqqmath_+3A_fitline">fitline</code></td>
<td>
<p>a logical; should a fitted line be added to plot?  Such a line will use <code>slope</code>
and <code>intercept</code> if provided, else the standard deviation and mean of the data.
If <code>slope</code> is specified, the line will be added unless <code>fitline</code> is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="xqqmath_+3A_slope">slope</code></td>
<td>
<p>slope for added line</p>
</td></tr>
<tr><td><code id="xqqmath_+3A_intercept">intercept</code></td>
<td>
<p>intercept for added line</p>
</td></tr>
<tr><td><code id="xqqmath_+3A_overlines">overlines</code></td>
<td>
<p>a logical: should lines be on top of qq plot?</p>
</td></tr>
<tr><td><code id="xqqmath_+3A_groups">groups</code>, <code id="xqqmath_+3A_pch">pch</code>, <code id="xqqmath_+3A_lwd">lwd</code>, <code id="xqqmath_+3A_lty">lty</code></td>
<td>
<p>as in lattice plots</p>
</td></tr>
<tr><td><code id="xqqmath_+3A_col.line">col.line</code></td>
<td>
<p>color to use for added lines</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a trellis object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100)
xqqmath( ~ x)                  # with quartile line
xqqmath( ~ x, fitline = TRUE)  # with fitted line
xqqmath( ~ x, idline = TRUE)   # with y = x
x &lt;- rexp(100, rate = 10)
xqqmath( ~ x, distribution = qexp)     # with quartile line
xqqmath( ~ x, distribution = qexp, slope = 1/10) 
xqqmath( ~ x, distribution = qexp, slope = mean(x)) 
</code></pre>

<hr>
<h2 id='xyz2latlon'>Convert back and forth between latitude/longitude and XYZ-space</h2><span id='topic+xyz2latlon'></span><span id='topic+latlon2xyz'></span><span id='topic+lonlat2xyz'></span>

<h3>Description</h3>

<p>Convert back and forth between latitude/longitude and XYZ-space
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xyz2latlon(x, y, z)

latlon2xyz(latitude, longitude)

lonlat2xyz(longitude, latitude)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xyz2latlon_+3A_x">x</code>, <code id="xyz2latlon_+3A_y">y</code>, <code id="xyz2latlon_+3A_z">z</code></td>
<td>
<p>numeric vectors</p>
</td></tr>
<tr><td><code id="xyz2latlon_+3A_latitude">latitude</code>, <code id="xyz2latlon_+3A_longitude">longitude</code></td>
<td>
<p>vectors of latitude and longitude values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix each row of which describes the latitudes and longitudes
</p>
<p>a matrix each row of which contains the x, y, and z coordinates of a point on a unit sphere
</p>


<h3>See Also</h3>

<p><code><a href="#topic+deg2rad">deg2rad()</a></code>, <code><a href="#topic+googleMap">googleMap()</a></code>, and <code><a href="#topic+rgeo">rgeo()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>xyz2latlon(1, 1, 1)     # point may be on sphere of any radius
xyz2latlon(0, 0, 0)     # this produces a NaN for latitude
latlon2xyz(30, 45)
lonlat2xyz(45, 30)
</code></pre>

<hr>
<h2 id='zscore'>Compute z-scores</h2><span id='topic+zscore'></span>

<h3>Description</h3>

<p>Compute z-scores
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zscore(x, na.rm = getOption("na.rm", FALSE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zscore_+3A_x">x</code></td>
<td>
<p>a numeric vector</p>
</td></tr>
<tr><td><code id="zscore_+3A_na.rm">na.rm</code></td>
<td>
<p>a logical indicating whether missing values should be removed</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(penguins, package = "palmerpenguins")
penguins |&gt; 
  group_by(species) |&gt; 
  mutate(zbill_length_mm = zscore(bill_length_mm, na.rm = TRUE)) |&gt; 
  head()
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
