<!DOCTYPE html><html lang="en"><head><title>Help for package bestNormalize</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bestNormalize}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bestNormalize-package'><p>bestNormalize: Flexibly calculate the best normalizing transformation for a</p>
vector</a></li>
<li><a href='#arcsinh_x'><p>arcsinh(x) Transformation</p></a></li>
<li><a href='#autotrader'><p>Prices of 6,283 cars listed on Autotrader</p></a></li>
<li><a href='#bestLogConstant'><p>Calculate and perform best normalizing log transformation (experimental)</p></a></li>
<li><a href='#bestNormalize'><p>Calculate and perform best normalizing transformation</p></a></li>
<li><a href='#binarize'><p>Binarize</p></a></li>
<li><a href='#boxcox'><p>Box-Cox Normalization</p></a></li>
<li><a href='#double_reverse_log'><p>Double Reverse Log(x + a) Transformation</p></a></li>
<li><a href='#exp_x'><p>exp(x) Transformation</p></a></li>
<li><a href='#lambert'><p>Lambert W x F Normalization</p></a></li>
<li><a href='#log_x'><p>Log(x + a) Transformation</p></a></li>
<li><a href='#no_transform'><p>Identity transformation and center/scale transform</p></a></li>
<li><a href='#orderNorm'><p>Calculate and perform Ordered Quantile normalizing transformation</p></a></li>
<li><a href='#plot.bestNormalize'><p>Transformation plotting</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#sqrt_x'><p>sqrt(x + a) Normalization</p></a></li>
<li><a href='#step_best_normalize'><p>Run bestNormalize transformation for <code>recipes</code> implementation</p></a></li>
<li><a href='#step_orderNorm'><p>ORQ normalization (orderNorm) for <code>recipes</code> implementation</p></a></li>
<li><a href='#yeojohnson'><p>Yeo-Johnson Normalization</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Normalizing Transformation Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>1.9.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-17</td>
</tr>
<tr>
<td>Description:</td>
<td>Estimate a suite of normalizing transformations, including 
    a new adaptation of a technique based on ranks which can guarantee 
    normally distributed transformed data if there are no ties: ordered 
    quantile normalization (ORQ). ORQ normalization combines a rank-mapping
    approach with a shifted logit approximation that allows
    the transformation to work on data outside the original domain. It is 
    also able to handle new data within the original domain via linear 
    interpolation. The package is built to estimate the best normalizing 
    transformation for a vector consistently and accurately. It implements 
    the Box-Cox transformation, the Yeo-Johnson transformation, three types 
    of Lambert WxF transformations, and the ordered quantile normalization 
    transformation. It estimates the normalization efficacy of other
    commonly used transformations, and it allows users to specify 
    custom transformations or normalization statistics. Finally, functionality
    can be integrated into a machine learning workflow via recipes. </td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://petersonr.github.io/bestNormalize/">https://petersonr.github.io/bestNormalize/</a>,
<a href="https://github.com/petersonR/bestNormalize">https://github.com/petersonR/bestNormalize</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>LambertW (&ge; 0.6.5), nortest, dplyr, doParallel, foreach,
doRNG, recipes, tibble, methods, butcher, purrr, generics</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, MASS, testthat, mgcv, parallel, ggplot2,
scales, rlang, covr</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-17 20:58:25 UTC; ryanpeterson</td>
</tr>
<tr>
<td>Author:</td>
<td>Ryan Andrew Peterson
    <a href="https://orcid.org/0000-0002-4650-5798"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ryan Andrew Peterson &lt;ryan.a.peterson@cuanschutz.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-18 08:42:33 UTC</td>
</tr>
</table>
<hr>
<h2 id='bestNormalize-package'>bestNormalize: Flexibly calculate the best normalizing transformation for a
vector</h2><span id='topic+bestNormalize-package'></span><span id='topic+_PACKAGE'></span>

<h3>Description</h3>

<p>The <code>bestNormalize</code> package provides several normalizing transformations, and introduces a
new transformation based off of the order statistics, <code>orderNorm</code>.
Perhaps the most useful function is <code>bestNormalize</code>, which attempts all
of these transformations and picks the best one based off of a goodness of
fit statistic.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Ryan Andrew Peterson <a href="mailto:ryan.a.peterson@cuanschutz.edu">ryan.a.peterson@cuanschutz.edu</a> (<a href="https://orcid.org/0000-0002-4650-5798">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://petersonr.github.io/bestNormalize/">https://petersonr.github.io/bestNormalize/</a>
</p>
</li>
<li> <p><a href="https://github.com/petersonR/bestNormalize">https://github.com/petersonR/bestNormalize</a>
</p>
</li></ul>


<hr>
<h2 id='arcsinh_x'>arcsinh(x) Transformation</h2><span id='topic+arcsinh_x'></span><span id='topic+predict.arcsinh_x'></span><span id='topic+print.arcsinh_x'></span>

<h3>Description</h3>

<p>Perform a arcsinh(x) transformation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>arcsinh_x(x, standardize = TRUE, ...)

## S3 method for class 'arcsinh_x'
predict(object, newdata = NULL, inverse = FALSE, ...)

## S3 method for class 'arcsinh_x'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="arcsinh_x_+3A_x">x</code></td>
<td>
<p>A vector to normalize with with x</p>
</td></tr>
<tr><td><code id="arcsinh_x_+3A_standardize">standardize</code></td>
<td>
<p>If TRUE, the transformed values are also centered and
scaled, such that the transformation attempts a standard normal</p>
</td></tr>
<tr><td><code id="arcsinh_x_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="arcsinh_x_+3A_object">object</code></td>
<td>
<p>an object of class 'arcsinh_x'</p>
</td></tr>
<tr><td><code id="arcsinh_x_+3A_newdata">newdata</code></td>
<td>
<p>a vector of data to be (potentially reverse) transformed</p>
</td></tr>
<tr><td><code id="arcsinh_x_+3A_inverse">inverse</code></td>
<td>
<p>if TRUE, performs reverse transformation</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>arcsinh_x</code> performs an arcsinh transformation in the context of 
bestNormalize, such that it creates a transformation that can be estimated
and applied to new data via the <code>predict</code> function. 
</p>
<p>The function is explicitly: log(x + sqrt(x^2 + 1))
</p>


<h3>Value</h3>

<p>A list of class <code>arcsinh_x</code> with elements 
</p>
<table role = "presentation">
<tr><td><code>x.t</code></td>
<td>
<p>transformed 
original data</p>
</td></tr> 
<tr><td><code>x</code></td>
<td>
<p>original data</p>
</td></tr> 
<tr><td><code>mean</code></td>
<td>
<p>mean after transformation but prior to standardization</p>
</td></tr> 
<tr><td><code>sd</code></td>
<td>
<p>sd after transformation but prior to standardization</p>
</td></tr> 
<tr><td><code>n</code></td>
<td>
<p>number of nonmissing observations</p>
</td></tr>
<tr><td><code>norm_stat</code></td>
<td>
<p>Pearson's P / degrees of freedom</p>
</td></tr>
<tr><td><code>standardize</code></td>
<td>
<p>was the transformation standardized</p>
</td></tr>
</table>
<p>The <code>predict</code> function returns the numeric value of the transformation
performed on new data, and allows for the inverse transformation as well.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rgamma(100, 1, 1)

arcsinh_x_obj &lt;- arcsinh_x(x)
arcsinh_x_obj
p &lt;- predict(arcsinh_x_obj)
x2 &lt;- predict(arcsinh_x_obj, newdata = p, inverse = TRUE)

all.equal(x2, x)

</code></pre>

<hr>
<h2 id='autotrader'>Prices of 6,283 cars listed on Autotrader</h2><span id='topic+autotrader'></span>

<h3>Description</h3>

<p>A dataset containing the prices and other attributes of over 6000 cars in the Minneapolis area.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autotrader
</code></pre>


<h3>Format</h3>

<p>A data frame with 6283 rows and 10 variables:
</p>

<dl>
<dt>price</dt><dd><p>price, in US dollars</p>
</dd>
<dt>Car_Info</dt><dd><p>Raw description from website</p>
</dd>
<dt>Link</dt><dd><p>hyperlink to listing (must be appended to https://www.autotrader.com/)</p>
</dd>
<dt>Make</dt><dd><p>Car manufacturer</p>
</dd>
<dt>Year</dt><dd><p>Year car manufactured</p>
</dd>
<dt>Location</dt><dd><p>Location of listing</p>
</dd>
<dt>Radius</dt><dd><p>Radius chosen for search</p>
</dd>
<dt>mileage</dt><dd><p>mileage on vehicle</p>
</dd>
<dt>status</dt><dd><p>used/new/certified</p>
</dd>
<dt>model</dt><dd><p>make and model, separated by space</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.autotrader.com/">https://www.autotrader.com/</a>
</p>

<hr>
<h2 id='bestLogConstant'>Calculate and perform best normalizing log transformation (experimental)</h2><span id='topic+bestLogConstant'></span><span id='topic+predict.bestLogConstant'></span><span id='topic+print.bestLogConstant'></span>

<h3>Description</h3>

<p>Similar to bestNormalize, this selects the
best candidate constant for a log transformation on the basis 
of the Pearson P test statistic for normality. The
transformation that has the lowest P (calculated on the transformed data)
is selected. This function is currently in development and may not behave 
as expected. 
</p>
<p>See details for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bestLogConstant(x, a, standardize = TRUE, ...)

## S3 method for class 'bestLogConstant'
predict(object, newdata = NULL, inverse = FALSE, ...)

## S3 method for class 'bestLogConstant'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bestLogConstant_+3A_x">x</code></td>
<td>
<p>A vector to normalize</p>
</td></tr>
<tr><td><code id="bestLogConstant_+3A_a">a</code></td>
<td>
<p>(optional) a list of candidate constants to choose from</p>
</td></tr>
<tr><td><code id="bestLogConstant_+3A_standardize">standardize</code></td>
<td>
<p>If TRUE, the transformed values are also centered and
scaled, such that the transformation attempts a standard normal. This will
not change the normality statistic.</p>
</td></tr>
<tr><td><code id="bestLogConstant_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
<tr><td><code id="bestLogConstant_+3A_object">object</code></td>
<td>
<p>an object of class 'bestLogConstant'</p>
</td></tr>
<tr><td><code id="bestLogConstant_+3A_newdata">newdata</code></td>
<td>
<p>a vector of data to be (reverse) transformed</p>
</td></tr>
<tr><td><code id="bestLogConstant_+3A_inverse">inverse</code></td>
<td>
<p>if TRUE, performs reverse transformation</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bestLogConstant</code> estimates the optimal normalizing constant 
for a log transformation. This transformation can be performed on new data, and
inverted, via the <code>predict</code> function.
</p>


<h3>Value</h3>

<p>A list of class <code>bestLogConstant</code> with elements
</p>
<table role = "presentation">
<tr><td><code>x.t</code></td>
<td>
<p>transformed original data</p>
</td></tr> <tr><td><code>x</code></td>
<td>
<p>original data</p>
</td></tr>
<tr><td><code>norm_stats</code></td>
<td>
<p>Pearson's Pearson's P / degrees of freedom</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>out-of-sample or in-sample, number of folds + repeats</p>
</td></tr>
<tr><td><code>chosen_constant</code></td>
<td>
<p>the chosen constant transformation (of class 'log_x')</p>
</td></tr>
<tr><td><code>other_transforms</code></td>
<td>
<p>the other transformations (of class 'log_x')</p>
</td></tr>
</table>
<p>The <code>predict</code> function returns the numeric value of the transformation
performed on new data, and allows for the inverse transformation as well.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bestNormalize">bestNormalize</a></code>, <code><a href="#topic+log_x">log_x</a></code>,
</p>

<hr>
<h2 id='bestNormalize'>Calculate and perform best normalizing transformation</h2><span id='topic+bestNormalize'></span><span id='topic+predict.bestNormalize'></span><span id='topic+print.bestNormalize'></span><span id='topic+tidy.bestNormalize'></span>

<h3>Description</h3>

<p>Performs a suite of normalizing transformations, and selects the
best one on the basis of the Pearson P test statistic for normality. The
transformation that has the lowest P (calculated on the transformed data)
is selected. See details for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bestNormalize(
  x,
  standardize = TRUE,
  allow_orderNorm = TRUE,
  allow_lambert_s = FALSE,
  allow_lambert_h = FALSE,
  allow_exp = TRUE,
  out_of_sample = TRUE,
  cluster = NULL,
  k = 10,
  r = 5,
  loo = FALSE,
  warn = FALSE,
  quiet = FALSE,
  tr_opts = list(),
  new_transforms = list(),
  norm_stat_fn = NULL,
  ...
)

## S3 method for class 'bestNormalize'
predict(object, newdata = NULL, inverse = FALSE, ...)

## S3 method for class 'bestNormalize'
print(x, ...)

## S3 method for class 'bestNormalize'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bestNormalize_+3A_x">x</code></td>
<td>
<p>A 'bestNormalize' object.</p>
</td></tr>
<tr><td><code id="bestNormalize_+3A_standardize">standardize</code></td>
<td>
<p>If TRUE, the transformed values are also centered and
scaled, such that the transformation attempts a standard normal. This will
not change the normality statistic.</p>
</td></tr>
<tr><td><code id="bestNormalize_+3A_allow_ordernorm">allow_orderNorm</code></td>
<td>
<p>set to FALSE if orderNorm should not be applied</p>
</td></tr>
<tr><td><code id="bestNormalize_+3A_allow_lambert_s">allow_lambert_s</code></td>
<td>
<p>Set to FALSE if the lambertW of type &quot;s&quot;  should not be
applied (see details). Expect about 2-3x elapsed computing time if TRUE.</p>
</td></tr>
<tr><td><code id="bestNormalize_+3A_allow_lambert_h">allow_lambert_h</code></td>
<td>
<p>Set to TRUE if the lambertW of type &quot;h&quot;  should be
applied (see details). Expect about 2-3x elapsed computing time.</p>
</td></tr>
<tr><td><code id="bestNormalize_+3A_allow_exp">allow_exp</code></td>
<td>
<p>Set to TRUE if the exponential transformation should be
applied (sometimes this will cause errors with heavy right skew)</p>
</td></tr>
<tr><td><code id="bestNormalize_+3A_out_of_sample">out_of_sample</code></td>
<td>
<p>if FALSE, estimates quickly in-sample performance</p>
</td></tr>
<tr><td><code id="bestNormalize_+3A_cluster">cluster</code></td>
<td>
<p>name of cluster set using <code>makeCluster</code></p>
</td></tr>
<tr><td><code id="bestNormalize_+3A_k">k</code></td>
<td>
<p>number of folds</p>
</td></tr>
<tr><td><code id="bestNormalize_+3A_r">r</code></td>
<td>
<p>number of repeats</p>
</td></tr>
<tr><td><code id="bestNormalize_+3A_loo">loo</code></td>
<td>
<p>should leave-one-out CV be used instead of repeated CV? (see
details)</p>
</td></tr>
<tr><td><code id="bestNormalize_+3A_warn">warn</code></td>
<td>
<p>Should bestNormalize warn when a method doesn't work?</p>
</td></tr>
<tr><td><code id="bestNormalize_+3A_quiet">quiet</code></td>
<td>
<p>Should a progress-bar not be displayed for cross-validation
progress?</p>
</td></tr>
<tr><td><code id="bestNormalize_+3A_tr_opts">tr_opts</code></td>
<td>
<p>a list (of lists), specifying options to be passed to each
transformation (see details)</p>
</td></tr>
<tr><td><code id="bestNormalize_+3A_new_transforms">new_transforms</code></td>
<td>
<p>a named list of new transformation functions and their
predict methods (see details)</p>
</td></tr>
<tr><td><code id="bestNormalize_+3A_norm_stat_fn">norm_stat_fn</code></td>
<td>
<p>if specified, a function to calculate to assess normality
(default is the Pearson chi-squared statistic divided by its d.f.)</p>
</td></tr>
<tr><td><code id="bestNormalize_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="bestNormalize_+3A_object">object</code></td>
<td>
<p>an object of class 'bestNormalize'</p>
</td></tr>
<tr><td><code id="bestNormalize_+3A_newdata">newdata</code></td>
<td>
<p>a vector of data to be (reverse) transformed</p>
</td></tr>
<tr><td><code id="bestNormalize_+3A_inverse">inverse</code></td>
<td>
<p>if TRUE, performs reverse transformation</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bestNormalize</code> estimates the optimal normalizing
transformation. This transformation can be performed on new data, and
inverted, via the <code>predict</code> function.
</p>
<p>This function currently estimates the Yeo-Johnson transformation,
the Box Cox transformation (if the data is positive), the log_10(x+a)
transformation, the square-root (x+a) transformation, and the arcsinh
transformation. a is set to max(0, -min(x) + eps) by default.  If
allow_orderNorm == TRUE and if out_of_sample == FALSE then the ordered
quantile normalization technique will likely be chosen since it essentially
forces the data to follow a normal distribution. More information on the
orderNorm technique can be found in the package vignette, or using
<code>?orderNorm</code>.
</p>
<p>Repeated cross-validation is used by default to estimate the out-of-sample
performance of each transformation if out_of_sample = TRUE. While this can
take some time, users can speed it up by creating a cluster via the
<code>parallel</code> package's <code>makeCluster</code> function, and passing the name
of this cluster to <code>bestNormalize</code> via the cl argument. For best
performance, we recommend the number of clusters to be set to the number of
repeats r. Care should be taken to account for the number of observations
per fold; too small a number and the estimated normality statistic could be
inaccurate, or at least suffer from high variability.
</p>
<p>As of version 1.3, users can use leave-one-out cross-validation as well for
each method by setting <code>loo</code> to <code>TRUE</code>.  This will take a lot of
time for bigger vectors, but it will have the most accurate estimate of
normalization efficacy. Note that if this method is selected, arguments
<code>k, r</code> are ignored. This method will still work in parallel with the
<code>cl</code> argument.
</p>
<p>Note that the Lambert transformation of type &quot;h&quot; can be done by setting
allow_lambert_h = TRUE, however this can take significantly longer to run.
</p>
<p>Use <code>tr_opts</code> in order to set options for each transformation. For
instance, if you want to overide the default a selection for <code>log_x</code>,
set <code>tr_opts$log_x = list(a = 1)</code>.
</p>
<p>See the package's vignette on how to use custom functions with
bestNormalize. All it takes is to create an S3 class and predict method for
the new transformation and load it into the environment, then the new
custom function (and its predict method) can be passed to bestNormalize
with <code>new_transform</code>.
</p>


<h3>Value</h3>

<p>A list of class <code>bestNormalize</code> with elements
</p>
<table role = "presentation">
<tr><td><code>x.t</code></td>
<td>
<p>transformed original data</p>
</td></tr> <tr><td><code>x</code></td>
<td>
<p>original data</p>
</td></tr>
<tr><td><code>norm_stats</code></td>
<td>
<p>Pearson's Pearson's P / degrees of freedom</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>out-of-sample or in-sample, number of folds + repeats</p>
</td></tr>
<tr><td><code>chosen_transform</code></td>
<td>
<p>the chosen transformation (of appropriate class)</p>
</td></tr>
<tr><td><code>other_transforms</code></td>
<td>
<p>the other transformations (of appropriate class)</p>
</td></tr>
<tr><td><code>oos_preds</code></td>
<td>
<p>Out-of-sample predictions (if loo == TRUE) or
normalization stats</p>
</td></tr>
</table>
<p>The <code>predict</code> function returns the numeric value of the transformation
performed on new data, and allows for the inverse transformation as well.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+boxcox">boxcox</a></code>, <code><a href="#topic+orderNorm">orderNorm</a></code>,
<code><a href="#topic+yeojohnson">yeojohnson</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rgamma(100, 1, 1)

## Not run: 
# With Repeated CV
BN_obj &lt;- bestNormalize(x)
BN_obj
p &lt;- predict(BN_obj)
x2 &lt;- predict(BN_obj, newdata = p, inverse = TRUE)

all.equal(x2, x)

## End(Not run)


## Not run: 
# With leave-one-out CV
BN_obj &lt;- bestNormalize(x, loo = TRUE)
BN_obj
p &lt;- predict(BN_obj)
x2 &lt;- predict(BN_obj, newdata = p, inverse = TRUE)

all.equal(x2, x)

## End(Not run)

# Without CV
BN_obj &lt;- bestNormalize(x, allow_orderNorm = FALSE, out_of_sample = FALSE)
BN_obj
p &lt;- predict(BN_obj)
x2 &lt;- predict(BN_obj, newdata = p, inverse = TRUE)

all.equal(x2, x)

</code></pre>

<hr>
<h2 id='binarize'>Binarize</h2><span id='topic+binarize'></span><span id='topic+predict.binarize'></span><span id='topic+print.binarize'></span>

<h3>Description</h3>

<p>This function will perform a binarizing transformation, which
could be used as a last resort if the data cannot be adequately normalized.
This may be useful when accidentally attempting normalization of a binary
vector (which could occur if implementing bestNormalize in an automated
fashion).
</p>
<p>Note that the transformation is not one-to-one, in contrast to the other
functions in this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binarize(x, location_measure = "median")

## S3 method for class 'binarize'
predict(object, newdata = NULL, inverse = FALSE, ...)

## S3 method for class 'binarize'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="binarize_+3A_x">x</code></td>
<td>
<p>A vector to binarize</p>
</td></tr>
<tr><td><code id="binarize_+3A_location_measure">location_measure</code></td>
<td>
<p>which location measure should be used? can either be
&quot;median&quot;, &quot;mean&quot;, &quot;mode&quot;, a number, or a function.</p>
</td></tr>
<tr><td><code id="binarize_+3A_object">object</code></td>
<td>
<p>an object of class 'binarize'</p>
</td></tr>
<tr><td><code id="binarize_+3A_newdata">newdata</code></td>
<td>
<p>a vector of data to be (reverse) transformed</p>
</td></tr>
<tr><td><code id="binarize_+3A_inverse">inverse</code></td>
<td>
<p>if TRUE, performs reverse transformation</p>
</td></tr>
<tr><td><code id="binarize_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>binarize</code> with elements 
</p>
<table role = "presentation">
<tr><td><code>x.t</code></td>
<td>
<p>transformed original data</p>
</td></tr> 
<tr><td><code>x</code></td>
<td>
<p>original data</p>
</td></tr> 
<tr><td><code>method</code></td>
<td>
<p>location_measure used for original fitting</p>
</td></tr> 
<tr><td><code>location</code></td>
<td>
<p>estimated location_measure</p>
</td></tr> 
<tr><td><code>n</code></td>
<td>
<p>number of nonmissing observations</p>
</td></tr>
<tr><td><code>norm_stat</code></td>
<td>
<p>Pearson's P / degrees of freedom</p>
</td></tr>
</table>
<p>The <code>predict</code> function with <code>inverse = FALSE</code> returns the numeric
value (0 or 1) of the transformation on <code>newdata</code> (which defaults to
the original data).
</p>
<p>If <code>inverse = TRUE</code>, since the transform is not 1-1, it will create
and return a factor that indicates where the original data was cut.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rgamma(100, 1, 1)
binarize_obj &lt;- binarize(x)
(p &lt;- predict(binarize_obj))

predict(binarize_obj, newdata = p, inverse = TRUE)
</code></pre>

<hr>
<h2 id='boxcox'>Box-Cox Normalization</h2><span id='topic+boxcox'></span><span id='topic+predict.boxcox'></span><span id='topic+print.boxcox'></span>

<h3>Description</h3>

<p>Perform a Box-Cox transformation and center/scale a vector to
attempt normalization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boxcox(x, standardize = TRUE, ...)

## S3 method for class 'boxcox'
predict(object, newdata = NULL, inverse = FALSE, ...)

## S3 method for class 'boxcox'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="boxcox_+3A_x">x</code></td>
<td>
<p>A vector to normalize with Box-Cox</p>
</td></tr>
<tr><td><code id="boxcox_+3A_standardize">standardize</code></td>
<td>
<p>If TRUE, the transformed values are also centered and
scaled, such that the transformation attempts a standard normal</p>
</td></tr>
<tr><td><code id="boxcox_+3A_...">...</code></td>
<td>
<p>Additional arguments that can be passed to the estimation of the
lambda parameter (lower, upper, epsilon)</p>
</td></tr>
<tr><td><code id="boxcox_+3A_object">object</code></td>
<td>
<p>an object of class 'boxcox'</p>
</td></tr>
<tr><td><code id="boxcox_+3A_newdata">newdata</code></td>
<td>
<p>a vector of data to be (reverse) transformed</p>
</td></tr>
<tr><td><code id="boxcox_+3A_inverse">inverse</code></td>
<td>
<p>if TRUE, performs reverse transformation</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>boxcox</code> estimates the optimal value of lambda for the Box-Cox
transformation. This transformation can be performed on new data, and
inverted, via the <code>predict</code> function.
</p>
<p>The function will return an error if a user attempt to transform nonpositive
data.
</p>


<h3>Value</h3>

<p>A list of class <code>boxcox</code> with elements 
</p>
<table role = "presentation">
<tr><td><code>x.t</code></td>
<td>
<p>transformed 
original data</p>
</td></tr> 
<tr><td><code>x</code></td>
<td>
<p>original data</p>
</td></tr> 
<tr><td><code>mean</code></td>
<td>
<p>mean after transformation but prior to standardization</p>
</td></tr> 
<tr><td><code>sd</code></td>
<td>
<p>sd after transformation but prior to standardization</p>
</td></tr> 
<tr><td><code>lambda</code></td>
<td>
<p>estimated lambda value for skew transformation</p>
</td></tr> 
<tr><td><code>n</code></td>
<td>
<p>number of nonmissing observations</p>
</td></tr>
<tr><td><code>norm_stat</code></td>
<td>
<p>Pearson's P / degrees of freedom</p>
</td></tr>
<tr><td><code>standardize</code></td>
<td>
<p>was the transformation standardized</p>
</td></tr>
</table>
<p>The <code>predict</code> function returns the numeric value of the transformation
performed on new data, and allows for the inverse transformation as well.
</p>


<h3>References</h3>

<p>Box, G. E. P. and Cox, D. R. (1964) An analysis of
transformations. Journal of the Royal Statistical Society B, 26, 211-252.
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+boxcox">boxcox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rgamma(100, 1, 1)

bc_obj &lt;- boxcox(x)
bc_obj
p &lt;- predict(bc_obj)
x2 &lt;- predict(bc_obj, newdata = p, inverse = TRUE)

all.equal(x2, x)
</code></pre>

<hr>
<h2 id='double_reverse_log'>Double Reverse Log(x + a) Transformation</h2><span id='topic+double_reverse_log'></span><span id='topic+predict.double_reverse_log'></span><span id='topic+print.double_reverse_log'></span>

<h3>Description</h3>

<p>First reverses scores, then perform a log_b(x) 
normalization transformation, and then reverses scores again.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>double_reverse_log(
  x,
  b = 10,
  standardize = TRUE,
  eps = diff(range(x, na.rm = TRUE))/10,
  warn = TRUE,
  ...
)

## S3 method for class 'double_reverse_log'
predict(object, newdata = NULL, inverse = FALSE, ...)

## S3 method for class 'double_reverse_log'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="double_reverse_log_+3A_x">x</code></td>
<td>
<p>A vector to normalize with with x</p>
</td></tr>
<tr><td><code id="double_reverse_log_+3A_b">b</code></td>
<td>
<p>The base of the log (defaults to 10)</p>
</td></tr>
<tr><td><code id="double_reverse_log_+3A_standardize">standardize</code></td>
<td>
<p>If TRUE, the transformed values are also centered and
scaled, such that the transformation attempts a standard normal</p>
</td></tr>
<tr><td><code id="double_reverse_log_+3A_eps">eps</code></td>
<td>
<p>The cushion for the transformation range (defaults to 10 percent)</p>
</td></tr>
<tr><td><code id="double_reverse_log_+3A_warn">warn</code></td>
<td>
<p>Should a warning result from infinite values?</p>
</td></tr>
<tr><td><code id="double_reverse_log_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="double_reverse_log_+3A_object">object</code></td>
<td>
<p>an object of class 'double_reverse_log'</p>
</td></tr>
<tr><td><code id="double_reverse_log_+3A_newdata">newdata</code></td>
<td>
<p>a vector of data to be (potentially reverse) transformed</p>
</td></tr>
<tr><td><code id="double_reverse_log_+3A_inverse">inverse</code></td>
<td>
<p>if TRUE, performs reverse transformation</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>double_reverse_log</code> performs a simple log transformation in the 
context of bestNormalize, such that it creates a transformation that can be 
estimated and applied to new data via the <code>predict</code> function. The parameter 
a is essentially estimated by the training set by default (estimated as the 
minimum possible to some extent epsilon), while the base must be specified 
beforehand.
</p>


<h3>Value</h3>

<p>A list of class <code>double_reverse_log</code> with elements 
</p>
<table role = "presentation">
<tr><td><code>x.t</code></td>
<td>
<p>transformed 
original data</p>
</td></tr> 
<tr><td><code>x</code></td>
<td>
<p>original data</p>
</td></tr> 
<tr><td><code>mean</code></td>
<td>
<p>mean after transformation but prior to standardization</p>
</td></tr> 
<tr><td><code>sd</code></td>
<td>
<p>sd after transformation but prior to standardization</p>
</td></tr> 
<tr><td><code>b</code></td>
<td>
<p>estimated base b value</p>
</td></tr> 
<tr><td><code>n</code></td>
<td>
<p>number of nonmissing observations</p>
</td></tr>
<tr><td><code>norm_stat</code></td>
<td>
<p>Pearson's P / degrees of freedom</p>
</td></tr>
<tr><td><code>standardize</code></td>
<td>
<p>was the transformation standardized</p>
</td></tr>
</table>
<p>The <code>predict</code> function returns the numeric value of the transformation
performed on new data, and allows for the inverse transformation as well.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rgamma(100, 1, 1)

double_reverse_log_obj &lt;- double_reverse_log(x)
double_reverse_log_obj
p &lt;- predict(double_reverse_log_obj)
x2 &lt;- predict(double_reverse_log_obj, newdata = p, inverse = TRUE)

all.equal(x2, x)

</code></pre>

<hr>
<h2 id='exp_x'>exp(x) Transformation</h2><span id='topic+exp_x'></span><span id='topic+predict.exp_x'></span><span id='topic+print.exp_x'></span>

<h3>Description</h3>

<p>Perform a exp(x) transformation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exp_x(x, standardize = TRUE, warn = TRUE, ...)

## S3 method for class 'exp_x'
predict(object, newdata = NULL, inverse = FALSE, ...)

## S3 method for class 'exp_x'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="exp_x_+3A_x">x</code></td>
<td>
<p>A vector to normalize with with x</p>
</td></tr>
<tr><td><code id="exp_x_+3A_standardize">standardize</code></td>
<td>
<p>If TRUE, the transformed values are also centered and
scaled, such that the transformation attempts a standard normal</p>
</td></tr>
<tr><td><code id="exp_x_+3A_warn">warn</code></td>
<td>
<p>Should a warning result from infinite values?</p>
</td></tr>
<tr><td><code id="exp_x_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="exp_x_+3A_object">object</code></td>
<td>
<p>an object of class 'exp_x'</p>
</td></tr>
<tr><td><code id="exp_x_+3A_newdata">newdata</code></td>
<td>
<p>a vector of data to be (potentially reverse) transformed</p>
</td></tr>
<tr><td><code id="exp_x_+3A_inverse">inverse</code></td>
<td>
<p>if TRUE, performs reverse transformation</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>exp_x</code> performs a simple exponential transformation in the context of 
bestNormalize, such that it creates a transformation that can be estimated
and applied to new data via the <code>predict</code> function.
</p>


<h3>Value</h3>

<p>A list of class <code>exp_x</code> with elements 
</p>
<table role = "presentation">
<tr><td><code>x.t</code></td>
<td>
<p>transformed 
original data</p>
</td></tr> 
<tr><td><code>x</code></td>
<td>
<p>original data</p>
</td></tr> 
<tr><td><code>mean</code></td>
<td>
<p>mean after transformation but prior to standardization</p>
</td></tr> 
<tr><td><code>sd</code></td>
<td>
<p>sd after transformation but prior to standardization</p>
</td></tr> 
<tr><td><code>n</code></td>
<td>
<p>number of nonmissing observations</p>
</td></tr>
<tr><td><code>norm_stat</code></td>
<td>
<p>Pearson's P / degrees of freedom</p>
</td></tr>
<tr><td><code>standardize</code></td>
<td>
<p>was the transformation standardized</p>
</td></tr>
</table>
<p>The <code>predict</code> function returns the numeric value of the transformation
performed on new data, and allows for the inverse transformation as well.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rgamma(100, 1, 1)

exp_x_obj &lt;- exp_x(x)
exp_x_obj
p &lt;- predict(exp_x_obj)
x2 &lt;- predict(exp_x_obj, newdata = p, inverse = TRUE)

all.equal(x2, x)

</code></pre>

<hr>
<h2 id='lambert'>Lambert W x F Normalization</h2><span id='topic+lambert'></span><span id='topic+predict.lambert'></span><span id='topic+print.lambert'></span>

<h3>Description</h3>

<p>Perform Lambert's W x F transformation and center/scale a vector
to attempt normalization via the <code>LambertW</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambert(x, type = "s", standardize = TRUE, warn = FALSE, ...)

## S3 method for class 'lambert'
predict(object, newdata = NULL, inverse = FALSE, ...)

## S3 method for class 'lambert'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lambert_+3A_x">x</code></td>
<td>
<p>A vector to normalize with Box-Cox</p>
</td></tr>
<tr><td><code id="lambert_+3A_type">type</code></td>
<td>
<p>a character indicating which transformation to perform (options 
are &quot;s&quot;, &quot;h&quot;, and &quot;hh&quot;, see details)</p>
</td></tr>
<tr><td><code id="lambert_+3A_standardize">standardize</code></td>
<td>
<p>If TRUE, the transformed values are also centered and
scaled, such that the transformation attempts a standard normal</p>
</td></tr>
<tr><td><code id="lambert_+3A_warn">warn</code></td>
<td>
<p>should the function show warnings</p>
</td></tr>
<tr><td><code id="lambert_+3A_...">...</code></td>
<td>
<p>Additional arguments that can be passed to the 
LambertW::Gaussianize function</p>
</td></tr>
<tr><td><code id="lambert_+3A_object">object</code></td>
<td>
<p>an object of class 'lambert'</p>
</td></tr>
<tr><td><code id="lambert_+3A_newdata">newdata</code></td>
<td>
<p>a vector of data to be (reverse) transformed</p>
</td></tr>
<tr><td><code id="lambert_+3A_inverse">inverse</code></td>
<td>
<p>if TRUE, performs reverse transformation</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>lambert</code> uses the <code>LambertW</code> package to estimate a 
normalizing (or &quot;Gaussianizing&quot;) transformation. This transformation can be
performed on new data, and inverted, via the <code>predict</code> function.
</p>
<p>NOTE: The type = &quot;s&quot; argument is the only one that does the 1-1 transform
consistently, and so it is the only method currently used in
<code>bestNormalize()</code>. Use type = &quot;h&quot; or type = 'hh' at risk of not having
this estimate 1-1 transform. These alternative types are effective when the
data has exceptionally heavy tails, e.g. the Cauchy distribution.
</p>
<p>Additionally, sometimes (depending on the distribution) this method will be
unable to extrapolate beyond the observed bounds. In these cases, NaN is
returned.
</p>


<h3>Value</h3>

<p>A list of class <code>lambert</code> with elements 
</p>
<table role = "presentation">
<tr><td><code>x.t</code></td>
<td>
<p>transformed original data</p>
</td></tr> 
<tr><td><code>x</code></td>
<td>
<p>original data</p>
</td></tr> 
<tr><td><code>mean</code></td>
<td>
<p>mean after transformation but prior to standardization</p>
</td></tr> 
<tr><td><code>sd</code></td>
<td>
<p>sd after transformation but prior to standardization</p>
</td></tr> 
<tr><td><code>tau.mat</code></td>
<td>
<p>estimated parameters of LambertW::Gaussianize</p>
</td></tr> 
<tr><td><code>n</code></td>
<td>
<p>number of nonmissing observations</p>
</td></tr>
<tr><td><code>norm_stat</code></td>
<td>
<p>Pearson's P / degrees of freedom</p>
</td></tr>
<tr><td><code>standardize</code></td>
<td>
<p>was the transformation standardized</p>
</td></tr>
</table>
<p>The <code>predict</code> function returns the numeric value of the transformation 
performed on new data, and allows for the inverse transformation as well.
</p>


<h3>References</h3>

<p>Georg M. Goerg (2016). LambertW: An R package for Lambert W x F 
Random Variables. R package version 0.6.4.
</p>
<p>Georg M. Goerg (2011): Lambert W random variables - a new family of 
generalized skewed distributions with applications to risk estimation. 
Annals of Applied Statistics 3(5). 2197-2230.
</p>
<p>Georg M. Goerg (2014): The Lambert Way to Gaussianize heavy-tailed data 
with the inverse of Tukey's h transformation as a special case. The 
Scientific World Journal.
</p>


<h3>See Also</h3>

<p><code><a href="LambertW.html#topic+Gaussianize">Gaussianize</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- rgamma(100, 1, 1)

lambert_obj &lt;- lambert(x)
lambert_obj
p &lt;- predict(lambert_obj)
x2 &lt;- predict(lambert_obj, newdata = p, inverse = TRUE)

all.equal(x2, x)

## End(Not run)

</code></pre>

<hr>
<h2 id='log_x'>Log(x + a) Transformation</h2><span id='topic+log_x'></span><span id='topic+predict.log_x'></span><span id='topic+print.log_x'></span>

<h3>Description</h3>

<p>Perform a log_b (x+a) normalization transformation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>log_x(x, a = NULL, b = 10, standardize = TRUE, eps = 0.001, warn = TRUE, ...)

## S3 method for class 'log_x'
predict(object, newdata = NULL, inverse = FALSE, ...)

## S3 method for class 'log_x'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="log_x_+3A_x">x</code></td>
<td>
<p>A vector to normalize with with x</p>
</td></tr>
<tr><td><code id="log_x_+3A_a">a</code></td>
<td>
<p>The constant to add to x (defaults to max(0, -min(x) + eps));
see <code>bestLogConstant</code></p>
</td></tr>
<tr><td><code id="log_x_+3A_b">b</code></td>
<td>
<p>The base of the log (defaults to 10)</p>
</td></tr>
<tr><td><code id="log_x_+3A_standardize">standardize</code></td>
<td>
<p>If TRUE, the transformed values are also centered and
scaled, such that the transformation attempts a standard normal</p>
</td></tr>
<tr><td><code id="log_x_+3A_eps">eps</code></td>
<td>
<p>The allowed error in the expression for the selected a</p>
</td></tr>
<tr><td><code id="log_x_+3A_warn">warn</code></td>
<td>
<p>Should a warning result from infinite values?</p>
</td></tr>
<tr><td><code id="log_x_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="log_x_+3A_object">object</code></td>
<td>
<p>an object of class 'log_x'</p>
</td></tr>
<tr><td><code id="log_x_+3A_newdata">newdata</code></td>
<td>
<p>a vector of data to be (potentially reverse) transformed</p>
</td></tr>
<tr><td><code id="log_x_+3A_inverse">inverse</code></td>
<td>
<p>if TRUE, performs reverse transformation</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>log_x</code> performs a simple log transformation in the context of 
bestNormalize, such that it creates a transformation that can be estimated
and applied to new data via the <code>predict</code> function. The parameter a is
essentially estimated by the training set by default (estimated as the minimum
possible to some extent epsilon), while the base must be 
specified beforehand.
</p>


<h3>Value</h3>

<p>A list of class <code>log_x</code> with elements 
</p>
<table role = "presentation">
<tr><td><code>x.t</code></td>
<td>
<p>transformed 
original data</p>
</td></tr> 
<tr><td><code>x</code></td>
<td>
<p>original data</p>
</td></tr> 
<tr><td><code>mean</code></td>
<td>
<p>mean after transformation but prior to standardization</p>
</td></tr> 
<tr><td><code>sd</code></td>
<td>
<p>sd after transformation but prior to standardization</p>
</td></tr> 
<tr><td><code>a</code></td>
<td>
<p>estimated a value</p>
</td></tr> 
<tr><td><code>b</code></td>
<td>
<p>estimated base b value</p>
</td></tr> 
<tr><td><code>n</code></td>
<td>
<p>number of nonmissing observations</p>
</td></tr>
<tr><td><code>norm_stat</code></td>
<td>
<p>Pearson's P / degrees of freedom</p>
</td></tr>
<tr><td><code>standardize</code></td>
<td>
<p>was the transformation standardized</p>
</td></tr>
</table>
<p>The <code>predict</code> function returns the numeric value of the transformation
performed on new data, and allows for the inverse transformation as well.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rgamma(100, 1, 1)

log_x_obj &lt;- log_x(x)
log_x_obj
p &lt;- predict(log_x_obj)
x2 &lt;- predict(log_x_obj, newdata = p, inverse = TRUE)

all.equal(x2, x)

</code></pre>

<hr>
<h2 id='no_transform'>Identity transformation and center/scale transform</h2><span id='topic+no_transform'></span><span id='topic+predict.no_transform'></span><span id='topic+center_scale'></span><span id='topic+print.no_transform'></span><span id='topic+predict.center_scale'></span><span id='topic+print.center_scale'></span><span id='topic+tidy.no_transform'></span>

<h3>Description</h3>

<p>Perform an identity transformation. Admittedly it seems odd to
have a dedicated function to essentially do I(x), but it makes sense to
keep the same syntax as the other transformations so it plays nicely
with them. As a benefit, the bestNormalize function will also show
a comparable normalization statistic for the untransformed data. If 
<code>standardize == TRUE</code>, <code>center_scale</code> passes to bestNormalize instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>no_transform(x, warn = TRUE, ...)

## S3 method for class 'no_transform'
predict(object, newdata = NULL, inverse = FALSE, ...)

## S3 method for class 'no_transform'
print(x, ...)

center_scale(x, warn = TRUE, ...)

## S3 method for class 'center_scale'
predict(object, newdata = NULL, inverse = FALSE, ...)

## S3 method for class 'center_scale'
print(x, ...)

## S3 method for class 'no_transform'
tidy(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="no_transform_+3A_x">x</code></td>
<td>
<p>A 'no_transform' object.</p>
</td></tr>
<tr><td><code id="no_transform_+3A_warn">warn</code></td>
<td>
<p>Should a warning result from infinite values?</p>
</td></tr>
<tr><td><code id="no_transform_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="no_transform_+3A_object">object</code></td>
<td>
<p>an object of class 'no_transform'</p>
</td></tr>
<tr><td><code id="no_transform_+3A_newdata">newdata</code></td>
<td>
<p>a vector of data to be (potentially reverse) transformed</p>
</td></tr>
<tr><td><code id="no_transform_+3A_inverse">inverse</code></td>
<td>
<p>if TRUE, performs reverse transformation</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>no_transform</code> creates a identity transformation object 
that can be applied to new data via the <code>predict</code> function.
</p>


<h3>Value</h3>

<p>A list of class <code>no_transform</code> with elements
</p>
<table role = "presentation">
<tr><td><code>x.t</code></td>
<td>
<p>transformed original data</p>
</td></tr> 
<tr><td><code>x</code></td>
<td>
<p>original data</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>number of nonmissing observations</p>
</td></tr>
<tr><td><code>norm_stat</code></td>
<td>
<p>Pearson's P / degrees of freedom</p>
</td></tr> 
</table>
<p>The <code>predict</code> function returns the numeric value of the transformation
performed on new data, and allows for the inverse transformation as well.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rgamma(100, 1, 1)

no_transform_obj &lt;- no_transform(x)
no_transform_obj
p &lt;- predict(no_transform_obj)
x2 &lt;- predict(no_transform_obj, newdata = p, inverse = TRUE)

all.equal(x2, x)

</code></pre>

<hr>
<h2 id='orderNorm'>Calculate and perform Ordered Quantile normalizing transformation</h2><span id='topic+orderNorm'></span><span id='topic+predict.orderNorm'></span><span id='topic+print.orderNorm'></span>

<h3>Description</h3>

<p>The Ordered Quantile (ORQ) normalization transformation,
<code>orderNorm()</code>, is a rank-based procedure by which the values of a
vector are mapped to their percentile, which is then mapped to the same
percentile of the normal distribution. Without the presence of ties, this
essentially guarantees that the transformation leads to a uniform
distribution.
</p>
<p>The transformation is: </p>
<p style="text-align: center;"><code class="reqn">g(x) = \Phi ^ {-1} ((rank(x) - .5) /
  (length(x)))</code>
</p>

<p>Where <code class="reqn">\Phi</code> refers to the standard normal cdf, rank(x) refers to each
observation's rank, and length(x) refers to the number of observations.
</p>
<p>By itself, this method is certainly not new; the earliest mention of it
that I could find is in a 1947 paper by Bartlett (see references). This
formula was outlined explicitly in Van der Waerden, and expounded upon in
Beasley (2009). However there is a key difference to this version of it, as
explained below.
</p>
<p>Using linear interpolation between these percentiles, the ORQ normalization
becomes a 1-1 transformation that can be applied to new data. However,
outside of the observed domain of x, it is unclear how to extrapolate the
transformation. In the ORQ normalization procedure, a binomial glm with a
logit link is used on the ranks in order to extrapolate beyond the bounds
of the original domain of x. The inverse normal CDF is then applied to
these extrapolated predictions in order to extrapolate the transformation.
This mitigates the influence of heavy-tailed distributions while preserving
the 1-1 nature of the transformation. The extrapolation will provide a
warning unless warn = FALSE.) However, we found that the extrapolation was
able to perform very well even on data as heavy-tailed as a Cauchy
distribution (paper to be published).
</p>
<p>The fit used to perform the extrapolation uses a default of 10000
observations (or length(x) if that is less). This added approximation
improves the scalability, both computationally and in terms of memory used.
Do not set this value to be too low (e.g. &lt;100), as there is no benefit to
doing so. Increase if your test data set is large relative to 10000 and/or 
if you are worried about losing signal in the extremes of the range.
</p>
<p>This transformation can be performed on new data and inverted via the
<code>predict</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderNorm(x, n_logit_fit = min(length(x), 10000), ..., warn = TRUE)

## S3 method for class 'orderNorm'
predict(object, newdata = NULL, inverse = FALSE, warn = TRUE, ...)

## S3 method for class 'orderNorm'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderNorm_+3A_x">x</code></td>
<td>
<p>A vector to normalize</p>
</td></tr>
<tr><td><code id="orderNorm_+3A_n_logit_fit">n_logit_fit</code></td>
<td>
<p>Number of points used to fit logit approximation</p>
</td></tr>
<tr><td><code id="orderNorm_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="orderNorm_+3A_warn">warn</code></td>
<td>
<p>transforms outside observed range or ties will yield warning</p>
</td></tr>
<tr><td><code id="orderNorm_+3A_object">object</code></td>
<td>
<p>an object of class 'orderNorm'</p>
</td></tr>
<tr><td><code id="orderNorm_+3A_newdata">newdata</code></td>
<td>
<p>a vector of data to be (reverse) transformed</p>
</td></tr>
<tr><td><code id="orderNorm_+3A_inverse">inverse</code></td>
<td>
<p>if TRUE, performs reverse transformation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>orderNorm</code> with elements
</p>
<table role = "presentation">
<tr><td><code>x.t</code></td>
<td>
<p>transformed original data</p>
</td></tr> <tr><td><code>x</code></td>
<td>
<p>original data</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>number of nonmissing observations</p>
</td></tr> <tr><td><code>ties_status</code></td>
<td>
<p>indicator if
ties are present</p>
</td></tr> <tr><td><code>fit</code></td>
<td>
<p>fit to be used for extrapolation, if needed</p>
</td></tr>
<tr><td><code>norm_stat</code></td>
<td>
<p>Pearson's P / degrees of freedom</p>
</td></tr>
</table>
<p>The <code>predict</code> function returns the numeric value of the transformation
performed on new data, and allows for the inverse transformation as well.
</p>


<h3>References</h3>

<p>Bartlett, M. S. &quot;The Use of Transformations.&quot; Biometrics, vol. 3, no. 1,
1947, pp. 39-52. JSTOR www.jstor.org/stable/3001536.
</p>
<p>Van der Waerden BL. Order tests for the two-sample problem and their power.
1952;55:453-458. Ser A.
</p>
<p>Beasley TM, Erickson S, Allison DB. Rank-based inverse normal transformations
are increasingly used, but are they merited? Behav. Genet. 2009;39(5):
580-595. pmid:19526352
</p>


<h3>See Also</h3>

<p><code><a href="#topic+boxcox">boxcox</a></code>, <code><a href="#topic+lambert">lambert</a></code>,
<code><a href="#topic+bestNormalize">bestNormalize</a></code>, <code><a href="#topic+yeojohnson">yeojohnson</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rgamma(100, 1, 1)

orderNorm_obj &lt;- orderNorm(x)
orderNorm_obj
p &lt;- predict(orderNorm_obj)
x2 &lt;- predict(orderNorm_obj, newdata = p, inverse = TRUE)

all.equal(x2, x)
</code></pre>

<hr>
<h2 id='plot.bestNormalize'>Transformation plotting</h2><span id='topic+plot.bestNormalize'></span><span id='topic+plot.orderNorm'></span><span id='topic+plot.boxcox'></span><span id='topic+plot.yeojohnson'></span><span id='topic+plot.lambert'></span>

<h3>Description</h3>

<p>Plots transformation functions for objects produced by the bestNormalize
package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bestNormalize'
plot(
  x,
  inverse = FALSE,
  bounds = NULL,
  cols = NULL,
  methods = NULL,
  leg_loc = "top",
  ...
)

## S3 method for class 'orderNorm'
plot(x, inverse = FALSE, bounds = NULL, ...)

## S3 method for class 'boxcox'
plot(x, inverse = FALSE, bounds = NULL, ...)

## S3 method for class 'yeojohnson'
plot(x, inverse = FALSE, bounds = NULL, ...)

## S3 method for class 'lambert'
plot(x, inverse = FALSE, bounds = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.bestNormalize_+3A_x">x</code></td>
<td>
<p>a fitted transformation</p>
</td></tr>
<tr><td><code id="plot.bestNormalize_+3A_inverse">inverse</code></td>
<td>
<p>if TRUE, plots the inverse transformation</p>
</td></tr>
<tr><td><code id="plot.bestNormalize_+3A_bounds">bounds</code></td>
<td>
<p>a vector of bounds to plot for the transformation</p>
</td></tr>
<tr><td><code id="plot.bestNormalize_+3A_cols">cols</code></td>
<td>
<p>a vector of colors to use for the transforms (see details)</p>
</td></tr>
<tr><td><code id="plot.bestNormalize_+3A_methods">methods</code></td>
<td>
<p>a vector of transformations to plot</p>
</td></tr>
<tr><td><code id="plot.bestNormalize_+3A_leg_loc">leg_loc</code></td>
<td>
<p>the location of the legend on the plot</p>
</td></tr>
<tr><td><code id="plot.bestNormalize_+3A_...">...</code></td>
<td>
<p>further parameters to be passed to <code>plot</code> and <code>lines</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plots produced by the individual transformations are simply
plots of the original values by the newly transformed values, with a line
denoting where transformations would take place for new data.
</p>
<p>For the bestNormalize object, this plots each of the possible
transformations run by the original call to bestNormalize. The first
argument in the &quot;cols&quot; parameter refers to the color of the chosen
transformation.
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+required_pkgs'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>generics</dt><dd><p><code><a href="generics.html#topic+required_pkgs">required_pkgs</a></code></p>
</dd>
</dl>

<hr>
<h2 id='sqrt_x'>sqrt(x + a) Normalization</h2><span id='topic+sqrt_x'></span><span id='topic+predict.sqrt_x'></span><span id='topic+print.sqrt_x'></span>

<h3>Description</h3>

<p>Perform a sqrt (x+a) normalization transformation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sqrt_x(x, a = NULL, standardize = TRUE, ...)

## S3 method for class 'sqrt_x'
predict(object, newdata = NULL, inverse = FALSE, ...)

## S3 method for class 'sqrt_x'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sqrt_x_+3A_x">x</code></td>
<td>
<p>A vector to normalize with with x</p>
</td></tr>
<tr><td><code id="sqrt_x_+3A_a">a</code></td>
<td>
<p>The constant to add to x (defaults to max(0, -min(x)))</p>
</td></tr>
<tr><td><code id="sqrt_x_+3A_standardize">standardize</code></td>
<td>
<p>If TRUE, the transformed values are also centered and
scaled, such that the transformation attempts a standard normal</p>
</td></tr>
<tr><td><code id="sqrt_x_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
<tr><td><code id="sqrt_x_+3A_object">object</code></td>
<td>
<p>an object of class 'sqrt_x'</p>
</td></tr>
<tr><td><code id="sqrt_x_+3A_newdata">newdata</code></td>
<td>
<p>a vector of data to be (potentially reverse) transformed</p>
</td></tr>
<tr><td><code id="sqrt_x_+3A_inverse">inverse</code></td>
<td>
<p>if TRUE, performs reverse transformation</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sqrt_x</code> performs a simple square-root transformation in the
context of bestNormalize, such that it creates a transformation that can be
estimated and applied to new data via the <code>predict</code> function. The
parameter a is essentially estimated by the training set by default
(estimated as the minimum possible), while the base
must be specified beforehand.
</p>


<h3>Value</h3>

<p>A list of class <code>sqrt_x</code> with elements </p>
<table role = "presentation">
<tr><td><code>x.t</code></td>
<td>
<p>transformed
original data</p>
</td></tr> 
<tr><td><code>x</code></td>
<td>
<p>original data</p>
</td></tr> 
<tr><td><code>mean</code></td>
<td>
<p>mean after transformation but prior to standardization</p>
</td></tr> 
<tr><td><code>sd</code></td>
<td>
<p>sd after transformation but prior to standardization</p>
</td></tr> 
<tr><td><code>n</code></td>
<td>
<p>number of nonmissing observations</p>
</td></tr> 
<tr><td><code>norm_stat</code></td>
<td>
<p>Pearson's P / degrees of freedom</p>
</td></tr> 
<tr><td><code>standardize</code></td>
<td>
<p>was the transformation standardized</p>
</td></tr>
</table>
<p>The <code>predict</code> function returns the numeric value of the transformation
performed on new data, and allows for the inverse transformation as well.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rgamma(100, 1, 1)

sqrt_x_obj &lt;- sqrt_x(x)
sqrt_x_obj
p &lt;- predict(sqrt_x_obj)
x2 &lt;- predict(sqrt_x_obj, newdata = p, inverse = TRUE)

all.equal(x2, x)

</code></pre>

<hr>
<h2 id='step_best_normalize'>Run bestNormalize transformation for <code>recipes</code> implementation</h2><span id='topic+step_best_normalize'></span><span id='topic+step_bestNormalize'></span><span id='topic+step_bestNormalize_new'></span><span id='topic+tidy.step_best_normalize'></span><span id='topic+axe_env.step_best_normalize'></span>

<h3>Description</h3>

<p>'step_best_normalize' creates a specification of a recipe step
(see 'recipes' package) that will transform data using the best of a suite
of normalization transformations estimated (by default) using
cross-validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_best_normalize(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  transform_info = NULL,
  transform_options = list(),
  num_unique = 5,
  skip = FALSE,
  id = rand_id("best_normalize")
)

## S3 method for class 'step_best_normalize'
tidy(x, ...)

## S3 method for class 'step_best_normalize'
axe_env(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="step_best_normalize_+3A_recipe">recipe</code></td>
<td>
<p>A formula or recipe</p>
</td></tr>
<tr><td><code id="step_best_normalize_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose which variables are
affected by the step. See [selections()] for more details. For the 'tidy'
method, these are not currently used.</p>
</td></tr>
<tr><td><code id="step_best_normalize_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are created.</p>
</td></tr>
<tr><td><code id="step_best_normalize_+3A_trained">trained</code></td>
<td>
<p>For recipes functionality</p>
</td></tr>
<tr><td><code id="step_best_normalize_+3A_transform_info">transform_info</code></td>
<td>
<p>A numeric vector of transformation values. This (was
transform_info) is 'NULL' until computed by [prep.recipe()].</p>
</td></tr>
<tr><td><code id="step_best_normalize_+3A_transform_options">transform_options</code></td>
<td>
<p>options to be passed to bestNormalize</p>
</td></tr>
<tr><td><code id="step_best_normalize_+3A_num_unique">num_unique</code></td>
<td>
<p>An integer where data that have less possible values will
not be evaluate for a transformation.</p>
</td></tr>
<tr><td><code id="step_best_normalize_+3A_skip">skip</code></td>
<td>
<p>For recipes functionality</p>
</td></tr>
<tr><td><code id="step_best_normalize_+3A_id">id</code></td>
<td>
<p>For recipes functionality</p>
</td></tr>
<tr><td><code id="step_best_normalize_+3A_x">x</code></td>
<td>
<p>A 'step_best_normalize' object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The bestnormalize transformation can be used to rescale a variable
to be more similar to a normal distribution. See '?bestNormalize' for more
information; 'step_best_normalize' is the implementation of 'bestNormalize'
in the 'recipes' context. 
</p>
<p>As of version 1.7, the 'butcher' package can be used to (hopefully) improve 
scalability of this function on bigger data sets.
</p>


<h3>Value</h3>

<p>An updated version of 'recipe' with the new step added to the
sequence of existing steps (if any). For the 'tidy' method, a tibble with
columns 'terms' (the selectors or variables selected) and 'value' (the
lambda estimate).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bestNormalize">bestNormalize</a></code> <code><a href="#topic+orderNorm">orderNorm</a></code>,
[recipe()] [prep.recipe()] [bake.recipe()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(recipes)
rec &lt;- recipe(~ ., data = as.data.frame(iris))

bn_trans &lt;- step_best_normalize(rec, all_numeric())

bn_estimates &lt;- prep(bn_trans, training = as.data.frame(iris))

bn_data &lt;- bake(bn_estimates, as.data.frame(iris))

plot(density(iris[, "Petal.Length"]), main = "before")
plot(density(bn_data$Petal.Length), main = "after")

tidy(bn_trans, number = 1)
tidy(bn_estimates, number = 1)

</code></pre>

<hr>
<h2 id='step_orderNorm'>ORQ normalization (orderNorm) for <code>recipes</code> implementation</h2><span id='topic+step_orderNorm'></span><span id='topic+tidy.step_orderNorm'></span><span id='topic+axe_env.step_orderNorm'></span>

<h3>Description</h3>

<p>'step_orderNorm' creates a specification of a recipe step (see
'recipes' package) that will transform data using the ORQ (orderNorm)
transformation, which approximates the &quot;true&quot; normalizing transformation if
one exists. This is considerably faster than 'step_bestNormalize'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>step_orderNorm(
  recipe,
  ...,
  role = NA,
  trained = FALSE,
  transform_info = NULL,
  transform_options = list(),
  num_unique = 5,
  skip = FALSE,
  id = rand_id("orderNorm")
)

## S3 method for class 'step_orderNorm'
tidy(x, ...)

## S3 method for class 'step_orderNorm'
axe_env(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="step_orderNorm_+3A_recipe">recipe</code></td>
<td>
<p>A formula or recipe</p>
</td></tr>
<tr><td><code id="step_orderNorm_+3A_...">...</code></td>
<td>
<p>One or more selector functions to choose which variables are
affected by the step. See [selections()] for more details. For the 'tidy'
method, these are not currently used.</p>
</td></tr>
<tr><td><code id="step_orderNorm_+3A_role">role</code></td>
<td>
<p>Not used by this step since no new variables are created.</p>
</td></tr>
<tr><td><code id="step_orderNorm_+3A_trained">trained</code></td>
<td>
<p>For recipes functionality</p>
</td></tr>
<tr><td><code id="step_orderNorm_+3A_transform_info">transform_info</code></td>
<td>
<p>A numeric vector of transformation values. This (was
transform_info) is 'NULL' until computed by [prep.recipe()].</p>
</td></tr>
<tr><td><code id="step_orderNorm_+3A_transform_options">transform_options</code></td>
<td>
<p>options to be passed to orderNorm</p>
</td></tr>
<tr><td><code id="step_orderNorm_+3A_num_unique">num_unique</code></td>
<td>
<p>An integer where data that have less possible values will
not be evaluate for a transformation.</p>
</td></tr>
<tr><td><code id="step_orderNorm_+3A_skip">skip</code></td>
<td>
<p>For recipes functionality</p>
</td></tr>
<tr><td><code id="step_orderNorm_+3A_id">id</code></td>
<td>
<p>For recipes functionality</p>
</td></tr>
<tr><td><code id="step_orderNorm_+3A_x">x</code></td>
<td>
<p>A 'step_orderNorm' object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The orderNorm transformation can be used to rescale a variable to be
more similar to a normal distribution. See '?orderNorm' for more
information; 'step_orderNorm' is the implementation of 'orderNorm' in the
'recipes' context.
</p>
<p>As of version 1.7, the 'butcher' package can be used to (hopefully) improve 
scalability of this function on bigger data sets.
</p>


<h3>Value</h3>

<p>An updated version of 'recipe' with the new step added to the
sequence of existing steps (if any). For the 'tidy' method, a tibble with
columns 'terms' (the selectors or variables selected) and 'value' (the
lambda estimate).
</p>


<h3>References</h3>

<p>Ryan A. Peterson (2019). Ordered quantile normalization: a
semiparametric transformation built for the cross-validation era. Journal
of Applied Statistics, 1-16.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+orderNorm">orderNorm</a></code> <code><a href="#topic+bestNormalize">bestNormalize</a></code>,
[recipe()] [prep.recipe()] [bake.recipe()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(recipes)
rec &lt;- recipe(~ ., data = as.data.frame(iris))

orq_trans &lt;- step_orderNorm(rec, all_numeric())

orq_estimates &lt;- prep(orq_trans, training = as.data.frame(iris))

orq_data &lt;- bake(orq_estimates, as.data.frame(iris))

plot(density(iris[, "Petal.Length"]), main = "before")
plot(density(orq_data$Petal.Length), main = "after")

tidy(orq_trans, number = 1)
tidy(orq_estimates, number = 1)


</code></pre>

<hr>
<h2 id='yeojohnson'>Yeo-Johnson Normalization</h2><span id='topic+yeojohnson'></span><span id='topic+predict.yeojohnson'></span><span id='topic+print.yeojohnson'></span>

<h3>Description</h3>

<p>Perform a Yeo-Johnson Transformation and center/scale a vector to
attempt normalization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>yeojohnson(x, eps = 0.001, standardize = TRUE, ...)

## S3 method for class 'yeojohnson'
predict(object, newdata = NULL, inverse = FALSE, ...)

## S3 method for class 'yeojohnson'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="yeojohnson_+3A_x">x</code></td>
<td>
<p>A vector to normalize with Yeo-Johnson</p>
</td></tr>
<tr><td><code id="yeojohnson_+3A_eps">eps</code></td>
<td>
<p>A value to compare lambda against to see if it is equal to zero</p>
</td></tr>
<tr><td><code id="yeojohnson_+3A_standardize">standardize</code></td>
<td>
<p>If TRUE, the transformed values are also centered and
scaled, such that the transformation attempts a standard normal</p>
</td></tr>
<tr><td><code id="yeojohnson_+3A_...">...</code></td>
<td>
<p>Additional arguments that can be passed to the estimation of the
lambda parameter (lower, upper)</p>
</td></tr>
<tr><td><code id="yeojohnson_+3A_object">object</code></td>
<td>
<p>an object of class 'yeojohnson'</p>
</td></tr>
<tr><td><code id="yeojohnson_+3A_newdata">newdata</code></td>
<td>
<p>a vector of data to be (reverse) transformed</p>
</td></tr>
<tr><td><code id="yeojohnson_+3A_inverse">inverse</code></td>
<td>
<p>if TRUE, performs reverse transformation</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>yeojohnson</code> estimates the optimal value of lambda for the
Yeo-Johnson transformation. This transformation can be performed on new
data, and inverted, via the <code>predict</code> function.
</p>
<p>The Yeo-Johnson is similar to the Box-Cox method, however it allows for the
transformation of nonpositive data as well. The <code>step_YeoJohnson</code>
function in the <code>recipes</code> package is another useful resource (see
references).
</p>


<h3>Value</h3>

<p>A list of class <code>yeojohnson</code> with elements
</p>
<table role = "presentation">
<tr><td><code>x.t</code></td>
<td>
<p>transformed original data</p>
</td></tr> 
<tr><td><code>x</code></td>
<td>
<p>original data</p>
</td></tr>
<tr><td><code>mean</code></td>
<td>
<p>mean after transformation but prior to standardization</p>
</td></tr> 
<tr><td><code>sd</code></td>
<td>
<p>sd after transformation but prior to standardization</p>
</td></tr> 
<tr><td><code>lambda</code></td>
<td>
<p>estimated lambda value for skew transformation</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>number of nonmissing observations</p>
</td></tr> 
<tr><td><code>norm_stat</code></td>
<td>
<p>Pearson's P / degrees of freedom</p>
</td></tr> 
<tr><td><code>standardize</code></td>
<td>
<p>Was the transformation standardized</p>
</td></tr>
</table>
<p>The <code>predict</code> function returns the numeric value of the transformation
performed on new data, and allows for the inverse transformation as well.
</p>


<h3>References</h3>

<p>Yeo, I. K., &amp; Johnson, R. A. (2000). A new family of power
transformations to improve normality or symmetry. Biometrika.
</p>
<p>Max Kuhn and Hadley Wickham (2017). recipes: Preprocessing Tools to Create
Design Matrices. R package version 0.1.0.9000.
https://github.com/topepo/recipes
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- rgamma(100, 1, 1)

yeojohnson_obj &lt;- yeojohnson(x)
yeojohnson_obj
p &lt;- predict(yeojohnson_obj)
x2 &lt;- predict(yeojohnson_obj, newdata = p, inverse = TRUE)

all.equal(x2, x)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
