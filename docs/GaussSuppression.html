<!DOCTYPE html><html><head><title>Help for package GaussSuppression</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GaussSuppression}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AdditionalSuppression'><p>GaussSuppression from data and suppressed data</p></a></li>
<li><a href='#CandidatesDefault'><p>Candidates functions</p></a></li>
<li><a href='#ChainedSuppression'><p>Repeated GaussSuppression  with forwarding of previous results</p></a></li>
<li><a href='#ComputeIntervals'><p>Function for calculating intervals for suppressed tables.</p></a></li>
<li><a href='#FindDominantCells'><p>Method for finding dominant cells according to (possibly multiple) n,k</p>
dominance rules.</a></li>
<li><a href='#FixRiskyIntervals'><p>New primary cells to fix risky intervals</p></a></li>
<li><a href='#GaussSuppressDec'><p>Cell suppression with synthetic decimal numbers</p></a></li>
<li><a href='#GaussSuppressionFromData'><p>Cell suppression from input data containing inner cells</p></a></li>
<li><a href='#GaussSuppressionTwoWay'><p>Two-way iteration variant of <code>GaussSuppressionFromData</code></p></a></li>
<li><a href='#GetDefault'><p>Get default value of a function</p></a></li>
<li><a href='#HierarchyContributors'><p>Counts of input code contributions</p></a></li>
<li><a href='#IncrementalTimeSuppression'><p>Incremental Time Suppression</p></a></li>
<li><a href='#KDisclosurePrimary'><p>Construct primary suppressed difference matrix</p></a></li>
<li><a href='#LazyLinkedTables'><p>Linked tables by full <code>GaussSuppressionFromData</code> iterations</p></a></li>
<li><a href='#MagnitudeRule'><p>Dominance <code style="white-space: pre;">&#8288;(n,k)&#8288;</code> or p% rule for magnitude tables</p></a></li>
<li><a href='#MaxContribution'><p>Find major contributions to aggregates</p></a></li>
<li><a href='#Ncontributors'><p>Find the number of unique groups contributing to aggregates</p></a></li>
<li><a href='#NcontributorsHolding'><p><code>Ncontributors</code> with holding-indicator</p></a></li>
<li><a href='#NcontributorsRule'><p>Identical to ´NContributorsRule´</p></a></li>
<li><a href='#NContributorsRule'><p>Number of contributors suppression rule</p></a></li>
<li><a href='#PackageSpecs'><p>Function for viewing built-in GaussSuppression specs</p></a></li>
<li><a href='#PrimaryDefault'><p>Default primary function</p></a></li>
<li><a href='#PrimaryFromRiskyDefault'><p>Additional primary cells based on risky primary cells</p></a></li>
<li><a href='#PrimaryFromSuppressedData'><p><code>primary</code> and <code>forced</code> from suppressed data</p></a></li>
<li><a href='#PrimaryRemoveWg'><p>Special functions for the avoidance of suppression</p></a></li>
<li><a href='#RangeLimitsDefault'><p>Default range limit function</p></a></li>
<li><a href='#RangeOutputFunction'><p>Function used in RangeLimitsDefault example</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#SingletonDefault'><p>Default singleton function</p></a></li>
<li><a href='#SingletonUniqueContributor'><p>Unique contributor singleton function</p></a></li>
<li><a href='#SuppressDirectDisclosure'><p>Suppression of directly-disclosive cells</p></a></li>
<li><a href='#SuppressDominantCells'><p>Suppress volume tables using dominant cell primary suppression.</p></a></li>
<li><a href='#SuppressFewContributors'><p>Few contributors suppression</p></a></li>
<li><a href='#SuppressionFromDecimals'><p>Cell suppression from synthetic decimal numbers</p></a></li>
<li><a href='#SuppressKDisclosure'><p>K-disclosure suppression</p></a></li>
<li><a href='#SuppressSmallCounts'><p>Small count frequency table suppression.</p></a></li>
<li><a href='#X_from_mc'><p>Function to be used within <code>KDisclosurePrimary</code></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Tabular Data Suppression using Gaussian Elimination</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-22</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Øyvind Langsrud &lt;oyl@ssb.no&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>Matrix</td>
</tr>
<tr>
<td>Imports:</td>
<td>SSBtools (&ge; 1.5.0), RegSDC (&ge; 0.7.0), stats, methods, utils</td>
</tr>
<tr>
<td>Description:</td>
<td>A statistical disclosure control tool to protect tables by suppression 
    using the Gaussian elimination secondary suppression algorithm. A suggestion is 
    to start by working with functions SuppressSmallCounts() and 
    SuppressDominantCells(). These functions use primary suppression functions for 
    the minimum frequency rule and the dominance rule, respectively. Novel 
    functionality for suppression of disclosive cells is also included. General 
    primary suppression functions can be supplied as input to the general working 
    horse function, GaussSuppressionFromData(). Suppressed frequencies can be 
    replaced by synthetic decimal numbers as described in 
    Langsrud (2019) &lt;<a href="https://doi.org/10.1007%2Fs11222-018-9848-9">doi:10.1007/s11222-018-9848-9</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/statisticsnorway/GaussSuppression">https://github.com/statisticsnorway/GaussSuppression</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/statisticsnorway/GaussSuppression/issues">https://github.com/statisticsnorway/GaussSuppression/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>formattable, kableExtra, knitr, rmarkdown, testthat (&ge;
3.0.0), lpSolve, Rsymphony, Rglpk, slam, highs</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-22 11:46:31 UTC; oyl</td>
</tr>
<tr>
<td>Author:</td>
<td>Øyvind Langsrud [aut, cre],
  Daniel Lupp [aut],
  Hege Bøvelstad [ctb],
  Statistics Norway [cph]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-22 13:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='AdditionalSuppression'>GaussSuppression from data and suppressed data</h2><span id='topic+AdditionalSuppression'></span>

<h3>Description</h3>

<p>Extended version of <code><a href="#topic+GaussSuppressionFromData">GaussSuppressionFromData</a></code> that takes into account suppression pattern in suppressed data sent as input
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AdditionalSuppression(
  data,
  ...,
  fun = GaussSuppressionFromData,
  primary = GetDefault(fun, "primary"),
  suppressedData = NULL,
  makePrimary = TRUE,
  makeForced = TRUE,
  forceNotPrimary = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AdditionalSuppression_+3A_data">data</code></td>
<td>
<p>Input data as a data frame</p>
</td></tr>
<tr><td><code id="AdditionalSuppression_+3A_...">...</code></td>
<td>
<p>Further parameters to <code><a href="#topic+GaussSuppressionFromData">GaussSuppressionFromData</a></code></p>
</td></tr>
<tr><td><code id="AdditionalSuppression_+3A_fun">fun</code></td>
<td>
<p>A function: <code><a href="#topic+GaussSuppressionFromData">GaussSuppressionFromData</a></code> or one of its wrappers such as
<code><a href="#topic+SuppressSmallCounts">SuppressSmallCounts</a></code> and <code><a href="#topic+SuppressDominantCells">SuppressDominantCells</a></code>.</p>
</td></tr>
<tr><td><code id="AdditionalSuppression_+3A_primary">primary</code></td>
<td>
<p>As input to <code><a href="#topic+GaussSuppressionFromData">GaussSuppressionFromData</a></code> before possible extension caused by <code>suppressedData</code>.
Supply <code>NULL</code> if all primary suppressions are retrieved form <code>suppressedData</code>.</p>
</td></tr>
<tr><td><code id="AdditionalSuppression_+3A_suppresseddata">suppressedData</code></td>
<td>
<p>A data frame or a list of data frames as output from <code><a href="#topic+GaussSuppressionFromData">GaussSuppressionFromData</a></code>.</p>
</td></tr>
<tr><td><code id="AdditionalSuppression_+3A_makeprimary">makePrimary</code></td>
<td>
<p>When <code>TRUE</code>, suppression in <code>suppressedData</code> is preserved.</p>
</td></tr>
<tr><td><code id="AdditionalSuppression_+3A_makeforced">makeForced</code></td>
<td>
<p>When TRUE, non-suppression in <code>suppressedData</code> is preserved. An exception is possible primary suppression which has priority over <code>forced</code>. Use forceNotPrimary to avoid this exception.</p>
</td></tr>
<tr><td><code id="AdditionalSuppression_+3A_forcenotprimary">forceNotPrimary</code></td>
<td>
<p>When TRUE, non-suppression in <code>suppressedData</code> is forced to be not primary suppressed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is an easy alternative to using <code>PrimaryFromSuppressedData</code> and the relating functions manually.
See the examples of <code><a href="#topic+PrimaryFromSuppressedData">PrimaryFromSuppressedData</a></code>.
By default, the suppression pattern in <code>suppressedData</code> is preserved. The behavior can be tuned by the parameters.
</p>
<p>Note that the variables used in <code>suppressedData</code> in addition to <code>"suppressed"</code> are those with matching names in <code>crossTable</code>.
Others are ignored. See examples (d3, d4, d5).
NOW A FIX IS INCLUDED by attribute totCode. EXAMPLES NOT YET CHANGED.
</p>


<h3>Value</h3>

<p>Aggregated data with suppression information
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
z1 &lt;- SSBtoolsData("z1")
z2 &lt;- SSBtoolsData("z2")
z3 &lt;- SSBtoolsData("z3")

# Ordinary suppressions
a &lt;- GaussSuppressionFromData(z1, 1:2, 3, maxN = 5)
b &lt;- GaussSuppressionFromData(z2, 1:4, 5, maxN = 1)

# As b and also suppression pattern in a preserved 
b1 &lt;- AdditionalSuppression(z2, 1:4, 5, maxN = 1, suppressedData = a)

# Rows with differences
cbind(b, b1)[b1$suppressed != b$suppressed, ]

# All primary from a 
b2 &lt;- AdditionalSuppression(z2, 1:4, 5, suppressedData = a, primary = NULL, singleton = NULL)

# Rows with suppression 
b2[b2$suppressed, ]

# All primary from b2
d1 &lt;- AdditionalSuppression(data = z3, 1:6, 7, suppressedData = b2, primary = NULL, 
                            singleton = NULL)

# No suppression since no common codes 
d1[d1$suppressed, ]

# Use another coding of fylke
z3$fylke_ &lt;- z3$fylke - 4
d2 &lt;- AdditionalSuppression(data = z3, c(1, 3:6, 8), 7, suppressedData = b2, primary = NULL, 
                            singleton = NULL)

# Two primary found in b2 -&gt; several secondary
d2[d2$suppressed,]


# Examples demonstrating limitations of AdditionalSuppression
# Variable mnd in suppressedData is not used 

# No suppression since unsuppressed rows used by makeForced and forceNotPrimary
d3 &lt;- AdditionalSuppression(data = z3, c(1, 3:4, 8), 7, suppressedData = d2, primary = NULL, 
                            singleton = NULL)
d3[d3$suppressed, ]

# Now suppression, but not too much
d4 &lt;- AdditionalSuppression(data = z3, c(1, 3:4, 8), 7, suppressedData = d2, 
                            forceNotPrimary = FALSE, primary = NULL, singleton = NULL)
d4[d4$suppressed, ]

# The correct way is to limit the input
d5 &lt;- AdditionalSuppression(data = z3, c(1, 3:4, 8), 7, suppressedData = d2[d2$mnd == "Total", ], 
                            primary = NULL, singleton = NULL)
d5[d5$suppressed, ]

</code></pre>

<hr>
<h2 id='CandidatesDefault'>Candidates functions</h2><span id='topic+CandidatesDefault'></span><span id='topic+CandidatesNum'></span>

<h3>Description</h3>

<p>Function for <code><a href="#topic+GaussSuppressionFromData">GaussSuppressionFromData</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CandidatesDefault(freq, x, secondaryZeros = FALSE, weight, ...)

CandidatesNum(
  secondaryZeros = FALSE,
  freq = NULL,
  num,
  weight,
  x,
  candidatesVar = NULL,
  removeCodes = character(0),
  removeCodesForCandidates = TRUE,
  data,
  charVar,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CandidatesDefault_+3A_freq">freq</code></td>
<td>
<p>Vector of output frequencies</p>
</td></tr>
<tr><td><code id="CandidatesDefault_+3A_x">x</code></td>
<td>
<p>The model matrix</p>
</td></tr>
<tr><td><code id="CandidatesDefault_+3A_secondaryzeros">secondaryZeros</code></td>
<td>
<p>When <code>TRUE</code>, cells with zero frequency or value are prioritized to
be published so that they are not secondary suppressed.
This is achieved by this function by having the zero frequency indices first in the retuned order.</p>
</td></tr>
<tr><td><code id="CandidatesDefault_+3A_weight">weight</code></td>
<td>
<p>Vector of output weights</p>
</td></tr>
<tr><td><code id="CandidatesDefault_+3A_...">...</code></td>
<td>
<p>Unused parameters</p>
</td></tr>
<tr><td><code id="CandidatesDefault_+3A_num">num</code></td>
<td>
<p>Data frame of output aggregates calculated from <code>numVar</code>. When several variables,
and without specifying <code>candidatesVar</code>,  only first is used.</p>
</td></tr>
<tr><td><code id="CandidatesDefault_+3A_candidatesvar">candidatesVar</code></td>
<td>
<p>One of the variable names from <code>numVar</code> to be used in the calculations.
Specifying <code>candidatesVar</code> helps avoid warnings when multiple <code>numVar</code> variables are present.</p>
</td></tr>
<tr><td><code id="CandidatesDefault_+3A_removecodes">removeCodes</code></td>
<td>
<p>Same parameter as used in suppression rules, e.g. <code><a href="#topic+NContributorsRule">NContributorsRule</a></code>.
It is often assumed that cells where all contributors (<code>charVar</code>)  are present in
<code>removeCodes</code> should be published. Here, such cells will be prioritized to achieve
this. Note that this functionality is redundant if the same cells are specified by <code>forced</code>.</p>
</td></tr>
<tr><td><code id="CandidatesDefault_+3A_removecodesforcandidates">removeCodesForCandidates</code></td>
<td>
<p><code>removeCodes</code> ignored when set to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="CandidatesDefault_+3A_data">data</code></td>
<td>
<p>Input data as a data frame (needed for <code>removeCodes</code> calculations)</p>
</td></tr>
<tr><td><code id="CandidatesDefault_+3A_charvar">charVar</code></td>
<td>
<p>Variable(s) with contributor codes (needed for <code>removeCodes</code> calculations)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>CandidatesDefault</code> orders the indices decreasingly according to <code>freq</code> or,
when <code>weight</code> is non-NULL,  <code>(freq+1)*weight</code>. Ties are handled by prioritizing output cells
that are calculated from many input cells. In addition, zeros are handled according to parameter <code>secondaryZeros</code>.
When <code>freq</code> is negative (special hierarchy), <code>abs(freq)*weight</code> is used.
</p>
<p><code>CandidatesNum</code> orders the indices decreasingly according to absolute values of the numeric variable (according to  <code>abs(num[[1]])</code>).
In practice this is done by running <code>CandidatesDefault</code> with manipulated weights.
</p>


<h3>Value</h3>

<p>candidates, <code><a href="#topic+GaussSuppression">GaussSuppression</a></code> input
</p>

<hr>
<h2 id='ChainedSuppression'>Repeated GaussSuppression  with forwarding of previous results</h2><span id='topic+ChainedSuppression'></span><span id='topic+ChainedSuppressionHi'></span><span id='topic+ChainedSuppressionHi1'></span>

<h3>Description</h3>

<p><code><a href="#topic+AdditionalSuppression">AdditionalSuppression</a></code> is called several times. Each time with all previous  results as <code>suppressedData</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ChainedSuppression(..., withinArg = NULL)

ChainedSuppressionHi(..., hierarchies)

ChainedSuppressionHi1(..., hierarchies)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ChainedSuppression_+3A_...">...</code></td>
<td>
<p>Arguments to <code>AdditionalSuppression</code>/<code>GaussSuppressionFromData</code> that are kept constant.</p>
</td></tr>
<tr><td><code id="ChainedSuppression_+3A_withinarg">withinArg</code></td>
<td>
<p>A list of named lists. Arguments to <code>AdditionalSuppression</code>/<code>GaussSuppressionFromData</code> that are not kept constant.
List elements with suppressed data are also allowed.</p>
</td></tr>
<tr><td><code id="ChainedSuppression_+3A_hierarchies">hierarchies</code></td>
<td>
<p>In the wrapper <code>ChainedSuppressionHi</code>, this argument will be used to generate the
<code>withinArg</code> to <code>ChainedSuppression</code> with the same length (see examples).
Then, element number <code>i</code> of <code>withinArg</code> is <code>list(hierarchies = hierarchies[1:i])</code>.
In the similar wrapper, <code>ChainedSuppressionHi1</code>, <code>withinArg</code> has always two elements:
<code>list(hierarchies = hierarchies[1])</code> and
<code>list(hierarchies = hierarchies)</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of data frames. The wrappers, <code>ChainedSuppressionHi</code> and <code>ChainedSuppressionHi1</code>,
return a single data frame, which is the last list item.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
z1 &lt;- SSBtoolsData("z1")
z2 &lt;- SSBtoolsData("z2")
z2b &lt;- z2[3:5]
names(z2b)[1] &lt;- "region"

# As GaussSuppressionFromData when a single element within withinArg
a1 &lt;- ChainedSuppression(z1, 1:2, 3, maxN = 5)
a2 &lt;- ChainedSuppression(z1, withinArg = list(list(dimVar = 1:2, freqVar = 3, maxN = 5)))
identical(a1, a2[[1]])

# b[[3]] include results from b[[1]] and b[[2]]
b &lt;- ChainedSuppression(z1, freqVar = 3, withinArg = list(
       list(dimVar = 1,   maxN = 55), 
       list(dimVar = 2,   maxN = 55), 
       list(dimVar = 1:2, maxN = 5)))

# d[[2]] is same as b1 in AdditionalSuppression examples
d &lt;- ChainedSuppression(withinArg = list(
       list(data = z1,  dimVar = 1:2, freqVar = 3, maxN = 5), 
       list(data = z2,  dimVar = 1:4, freqVar = 5, maxN = 1)))

# Common variable names important. 
# Therefore kostragr renamed to region in z2b. 
f &lt;- ChainedSuppression(withinArg = list(
       list(data = z1,  dimVar = 1:2, freqVar = 3, maxN = 5), 
       list(data = z2b, dimVar = 1:2, freqVar = 3, maxN = 5), 
       list(data = z2,  dimVar = 1:4, freqVar = 5, maxN = 1)))

# Parameters so that only suppressions are forwarded. 
# This is first iteration in linked tables by iterations. 
e &lt;- ChainedSuppression(withinArg = list(
       list(data = z1,  dimVar = 1:2, freqVar = 3, maxN = 5), 
       list(data = z2b, dimVar = 1:2, freqVar = 3, maxN = 5), 
       list(data = z2,  dimVar = 1:4, freqVar = 5, maxN = 1)), 
       makeForced = FALSE, forceNotPrimary = FALSE)
       
# "A" "annet"/"arbeid" could be suppressed here, but not in f since f[[1]]      
e[[3]][which(e[[3]]$suppressed != f[[3]]$suppressed), ]  


#### Demonstrate SuppressionByChainedHierarchies

dimLists &lt;- SSBtools::FindDimLists(z2[, 4:1])


# Two ways of doing the same calculations
g1 &lt;- ChainedSuppressionHi(z2, c(1, 3), 5, maxN = 1, hierarchies = dimLists)
g1b &lt;-  ChainedSuppression(z2, c(1, 3), 5, maxN = 1, withinArg = list(
         list(hierarchies = dimLists[1]),
         list(hierarchies = dimLists[1:2]),
         list(hierarchies = dimLists[1:3])))[[3]]      
       
# Results different after combining hierarchies      
g2 &lt;- ChainedSuppressionHi(z2, c(1, 3), 5, maxN = 1, 
         hierarchies = SSBtools::AutoHierarchies(dimLists))        
       
# In this case, the same results can be obtained by:         
g3 &lt;- ChainedSuppressionHi1(z2, c(1, 3), 5, maxN = 1, hierarchies = dimLists)        
       
</code></pre>

<hr>
<h2 id='ComputeIntervals'>Function for calculating intervals for suppressed tables.</h2><span id='topic+ComputeIntervals'></span>

<h3>Description</h3>

<p>This function solves linear programs to determine interval boundaries
for suppressed cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ComputeIntervals(
  x,
  z,
  primary,
  suppressed,
  minVal = NULL,
  lpPackage = "lpSolve",
  gaussI = TRUE,
  allInt = FALSE,
  sparseConstraints = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ComputeIntervals_+3A_x">x</code></td>
<td>
<p>ModelMatrix, as output from SSBtools::ModelMatrix</p>
</td></tr>
<tr><td><code id="ComputeIntervals_+3A_z">z</code></td>
<td>
<p>numerical vector with length ncol(x). Corresponds to table cell values</p>
</td></tr>
<tr><td><code id="ComputeIntervals_+3A_primary">primary</code></td>
<td>
<p>Vector indicating primary suppressed cells. Can be logical or
integer. If integer vector, indicates the columns of x which are considered
primary suppressed.</p>
</td></tr>
<tr><td><code id="ComputeIntervals_+3A_suppressed">suppressed</code></td>
<td>
<p>Vector indicating all suppressed cells. Can be logical or
integer. If integer vector, indicates the columns of x which are considered
suppressed.</p>
</td></tr>
<tr><td><code id="ComputeIntervals_+3A_minval">minVal</code></td>
<td>
<p>a known minimum value for table cells. Default NULL.
Note that 'minVal' is interpreted as the limiting value for all suppressed cells.
Specifying 'minVal=0' would be redundant, as a minimum value of 0 is anyway
assumed for inner cells (see details).</p>
</td></tr>
<tr><td><code id="ComputeIntervals_+3A_lppackage">lpPackage</code></td>
<td>
<p>The name of the package used to solve linear programs. Currently,
'lpSolve' (default), 'Rsymphony',  'Rglpk' and 'highs'  are supported.</p>
</td></tr>
<tr><td><code id="ComputeIntervals_+3A_gaussi">gaussI</code></td>
<td>
<p>Boolean vector. If TRUE (default), GaussIndependent is used to
reduce size of linear program.</p>
</td></tr>
<tr><td><code id="ComputeIntervals_+3A_allint">allInt</code></td>
<td>
<p>Integer variables when TRUE.
See <code>all.int</code> parameter in <code>lpSolve</code> and <code>types</code> parameter in <code>Rsymphony</code> and <code>Rglpk</code>.</p>
</td></tr>
<tr><td><code id="ComputeIntervals_+3A_sparseconstraints">sparseConstraints</code></td>
<td>
<p>When TRUE, a sparse constraint matrix will be input to the
solver. In the case of <code>lpSolve</code>, the sparse matrix is represented in triplet form
as a dense matrix with three columns, and the <code>dense.const</code> parameter is utilized.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is still experimental.
</p>
<p>Default in for <code>bounds</code> parameter in <code>Rsymphony_solve_LP</code> and <code>Rglpk_solve_LP</code>:
<em>The default for each variable is a bound between 0 and <code>Inf</code>.</em>
Details in <code>lpSolve</code>: <em>Note that every variable is assumed to be <code style="white-space: pre;">&#8288;&gt;= 0&#8288;</code>!</em>
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud and Daniel Lupp
</p>

<hr>
<h2 id='FindDominantCells'>Method for finding dominant cells according to (possibly multiple) n,k
dominance rules.</h2><span id='topic+FindDominantCells'></span>

<h3>Description</h3>

<p>Supports functionality for grouping contributions according to holding
variables, as well as calculating dominance in surveys with a given sampling
weight. Two methods are implemented, depending on whether the sampling
weights sum to total population. The parameter <code>tauArgusDominance</code>
determines this. If <code>FALSE</code>, unweighted contributions are compared to weighted
cell values. If <code>TRUE</code>, the method described in  in the
book &quot;Statistical Disclosure Control&quot; (Hundepool et al 2012, p. 151) is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FindDominantCells(
  x,
  inputnum,
  num,
  n,
  k,
  charVar_groups,
  samplingWeight,
  tauArgusDominance = FALSE,
  returnContrib = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FindDominantCells_+3A_x">x</code></td>
<td>
<p>model matrix describing relationship between input and published
cells</p>
</td></tr>
<tr><td><code id="FindDominantCells_+3A_inputnum">inputnum</code></td>
<td>
<p>vector of numeric contributions for each of the input records</p>
</td></tr>
<tr><td><code id="FindDominantCells_+3A_num">num</code></td>
<td>
<p>vector of numeric values for each of the published cells</p>
</td></tr>
<tr><td><code id="FindDominantCells_+3A_n">n</code></td>
<td>
<p>vector of integers describing n parameters in n,k rules. Must be
same length as <code>k</code> parameter.</p>
</td></tr>
<tr><td><code id="FindDominantCells_+3A_k">k</code></td>
<td>
<p>vector of numeric values describing k parameters in n,k rules, where
percentages are described as numbers less than 100. Must be same length as
<code>n</code> parameter.</p>
</td></tr>
<tr><td><code id="FindDominantCells_+3A_charvar_groups">charVar_groups</code></td>
<td>
<p>vector describing which input records should be grouped</p>
</td></tr>
<tr><td><code id="FindDominantCells_+3A_samplingweight">samplingWeight</code></td>
<td>
<p>vector of sampling weights associated to input records</p>
</td></tr>
<tr><td><code id="FindDominantCells_+3A_tauargusdominance">tauArgusDominance</code></td>
<td>
<p>logical value, default <code>FALSE</code>. determines how to
handle sampling weights in the dominance rule (see details).</p>
</td></tr>
<tr><td><code id="FindDominantCells_+3A_returncontrib">returnContrib</code></td>
<td>
<p>logical value, default <code>FALSE</code>. If <code>TRUE</code> return value is
the percentage of the first n contributors</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical vector describing which publish-cells need to be suppressed.
</p>

<hr>
<h2 id='FixRiskyIntervals'>New primary cells to fix risky intervals</h2><span id='topic+FixRiskyIntervals'></span>

<h3>Description</h3>

<p>Indices to new primary cells are returned
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FixRiskyIntervals(
  x,
  z,
  primary,
  suppressed,
  candidates = NULL,
  minVal = NULL,
  lpPackage = "lpSolve",
  gaussI = FALSE,
  allInt = FALSE,
  sparseConstraints = TRUE,
  rangeLimits
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FixRiskyIntervals_+3A_x">x</code></td>
<td>
<p>ModelMatrix, as output from SSBtools::ModelMatrix</p>
</td></tr>
<tr><td><code id="FixRiskyIntervals_+3A_z">z</code></td>
<td>
<p>numerical vector with length ncol(x). Corresponds to table cell values</p>
</td></tr>
<tr><td><code id="FixRiskyIntervals_+3A_primary">primary</code></td>
<td>
<p>Vector indicating primary suppressed cells. Can be logical or
integer. If integer vector, indicates the columns of x which are considered
primary suppressed.</p>
</td></tr>
<tr><td><code id="FixRiskyIntervals_+3A_suppressed">suppressed</code></td>
<td>
<p>Vector indicating all suppressed cells. Can be logical or
integer. If integer vector, indicates the columns of x which are considered
suppressed.</p>
</td></tr>
<tr><td><code id="FixRiskyIntervals_+3A_candidates">candidates</code></td>
<td>
<p><code>candidates</code> as indices</p>
</td></tr>
<tr><td><code id="FixRiskyIntervals_+3A_minval">minVal</code></td>
<td>
<p>a known minimum value for table cells. Default NULL.
Note that 'minVal' is interpreted as the limiting value for all suppressed cells.
Specifying 'minVal=0' would be redundant, as a minimum value of 0 is anyway
assumed for inner cells (see details).</p>
</td></tr>
<tr><td><code id="FixRiskyIntervals_+3A_lppackage">lpPackage</code></td>
<td>
<p>The name of the package used to solve linear programs. Currently,
'lpSolve' (default), 'Rsymphony',  'Rglpk' and 'highs'  are supported.</p>
</td></tr>
<tr><td><code id="FixRiskyIntervals_+3A_gaussi">gaussI</code></td>
<td>
<p>Boolean vector. If TRUE (default), GaussIndependent is used to
reduce size of linear program.</p>
</td></tr>
<tr><td><code id="FixRiskyIntervals_+3A_allint">allInt</code></td>
<td>
<p>Integer variables when TRUE.
See <code>all.int</code> parameter in <code>lpSolve</code> and <code>types</code> parameter in <code>Rsymphony</code> and <code>Rglpk</code>.</p>
</td></tr>
<tr><td><code id="FixRiskyIntervals_+3A_sparseconstraints">sparseConstraints</code></td>
<td>
<p>When TRUE, a sparse constraint matrix will be input to the
solver. In the case of <code>lpSolve</code>, the sparse matrix is represented in triplet form
as a dense matrix with three columns, and the <code>dense.const</code> parameter is utilized.</p>
</td></tr>
<tr><td><code id="FixRiskyIntervals_+3A_rangelimits">rangeLimits</code></td>
<td>
<p>As computed by <code><a href="#topic+RangeLimitsDefault">RangeLimitsDefault</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Code in this function started from a copy of <code><a href="#topic+ComputeIntervals">ComputeIntervals</a></code>
</p>

<hr>
<h2 id='GaussSuppressDec'>Cell suppression with synthetic decimal numbers</h2><span id='topic+GaussSuppressDec'></span>

<h3>Description</h3>

<p><code><a href="#topic+GaussSuppressionFromData">GaussSuppressionFromData</a></code> is run and decimal numbers are added to output by
a modified (for sparse matrix efficiency) version of <code>SuppressDec</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GaussSuppressDec(
  data,
  ...,
  output = NULL,
  digits = 9,
  nRep = NULL,
  rmse = pi/3,
  sparseLimit = 500,
  rndSeed = 123,
  runIpf = FALSE,
  eps = 0.01,
  iter = 100,
  mismatchWarning = TRUE,
  whenDuplicatedInner = NULL,
  whenMixedDuplicatedInner = warning
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GaussSuppressDec_+3A_data">data</code></td>
<td>
<p>Input daata as a data frame</p>
</td></tr>
<tr><td><code id="GaussSuppressDec_+3A_...">...</code></td>
<td>
<p>Further parameters to <code><a href="#topic+GaussSuppressionFromData">GaussSuppressionFromData</a></code></p>
</td></tr>
<tr><td><code id="GaussSuppressDec_+3A_output">output</code></td>
<td>
<p>NULL (default), <code>"publish"</code>, <code>"inner"</code>, <code>"publish_inner"</code>, or <code>"publish_inner_x"</code> (x also).</p>
</td></tr>
<tr><td><code id="GaussSuppressDec_+3A_digits">digits</code></td>
<td>
<p>Parameter to <code>RoundWhole</code>. Values close to whole numbers will be rounded.</p>
</td></tr>
<tr><td><code id="GaussSuppressDec_+3A_nrep">nRep</code></td>
<td>
<p>NULL or an integer. When &gt;1, several decimal numbers will be generated.</p>
</td></tr>
<tr><td><code id="GaussSuppressDec_+3A_rmse">rmse</code></td>
<td>
<p>Desired root mean square error of decimal numbers.
Variability around the expected, according to the linear model, inner frequencies.
The expected frequencies are calculated from the non-suppressed publishable frequencies.</p>
</td></tr>
<tr><td><code id="GaussSuppressDec_+3A_sparselimit">sparseLimit</code></td>
<td>
<p>Limit for the number of rows of a reduced x-matrix within the algorithm. When exceeded, a new sparse algorithm is used.</p>
</td></tr>
<tr><td><code id="GaussSuppressDec_+3A_rndseed">rndSeed</code></td>
<td>
<p>If non-NULL, a random generator seed to be used locally within the function without affecting the random value stream in R.</p>
</td></tr>
<tr><td><code id="GaussSuppressDec_+3A_runipf">runIpf</code></td>
<td>
<p>When TRUE, additional frequencies are generated by iterative proportional fitting using <code>Mipf</code>.</p>
</td></tr>
<tr><td><code id="GaussSuppressDec_+3A_eps">eps</code></td>
<td>
<p>Parameter to <code>Mipf</code>.</p>
</td></tr>
<tr><td><code id="GaussSuppressDec_+3A_iter">iter</code></td>
<td>
<p>Parameter to <code>Mipf</code>.</p>
</td></tr>
<tr><td><code id="GaussSuppressDec_+3A_mismatchwarning">mismatchWarning</code></td>
<td>
<p>Whether to produce the warning &quot;<code style="white-space: pre;">&#8288;Mismatch between whole numbers and suppression&#8288;</code>&quot;, when relevant.
When <code>nRep&gt;1</code>, all replicates must satisfy the whole number requirement for non-suppressed cells.
When <code>mismatchWarning</code> is integer (<code style="white-space: pre;">&#8288;&gt;0&#8288;</code>), this will be used as parameter <code>digits</code> to <code>RoundWhole</code>
when doing mismatch checking (can be quite low when <code>nRep&gt;1</code>).</p>
</td></tr>
<tr><td><code id="GaussSuppressDec_+3A_whenduplicatedinner">whenDuplicatedInner</code></td>
<td>
<p>Function to be called when default output and when cells marked as inner correspond to
several input cells (aggregated) since they correspond to published cells.</p>
</td></tr>
<tr><td><code id="GaussSuppressDec_+3A_whenmixedduplicatedinner">whenMixedDuplicatedInner</code></td>
<td>
<p>Function to be called in the case above when some inner cells correspond
to published cells (aggregated) and some not (not aggregated).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame where inner cells and cells to be published are combined or output according to parameter <code>output</code>.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langrsud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z1 &lt;- SSBtoolsData("z1")
GaussSuppressDec(z1, 1:2, 3)
GaussSuppressDec(z1, freqVar = "ant", formula = ~ region + hovedint, maxN = 10)
</code></pre>

<hr>
<h2 id='GaussSuppressionFromData'>Cell suppression from input data containing inner cells</h2><span id='topic+GaussSuppressionFromData'></span>

<h3>Description</h3>

<p>Aggregates are generated followed by
primary suppression followed by
secondary suppression by Gaussian elimination by <code><a href="#topic+GaussSuppression">GaussSuppression</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GaussSuppressionFromData(
  data,
  dimVar = NULL,
  freqVar = NULL,
  ...,
  numVar = NULL,
  weightVar = NULL,
  charVar = NULL,
  hierarchies = NULL,
  formula = NULL,
  maxN = suppressWarnings(formals(c(primary)[[1]])$maxN),
  protectZeros = suppressWarnings(formals(c(primary)[[1]])$protectZeros),
  secondaryZeros = suppressWarnings(formals(candidates)$secondaryZeros),
  candidates = CandidatesDefault,
  primary = PrimaryDefault,
  forced = NULL,
  hidden = NULL,
  singleton = SingletonDefault,
  singletonMethod = ifelse(secondaryZeros, "anySumNOTprimary", "anySum"),
  printInc = TRUE,
  output = "publish",
  x = NULL,
  crossTable = NULL,
  preAggregate = is.null(freqVar),
  extraAggregate = preAggregate &amp; !is.null(charVar),
  structuralEmpty = FALSE,
  extend0 = FALSE,
  spec = NULL,
  specLock = FALSE,
  freqVarNew = rev(make.unique(c(names(data), "freq")))[1],
  nUniqueVar = rev(make.unique(c(names(data), "nUnique")))[1],
  forcedInOutput = "ifNonNULL",
  unsafeInOutput = "ifForcedInOutput",
  lpPackage = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GaussSuppressionFromData_+3A_data">data</code></td>
<td>
<p>Input data as a data frame</p>
</td></tr>
<tr><td><code id="GaussSuppressionFromData_+3A_dimvar">dimVar</code></td>
<td>
<p>The main dimensional variables and additional aggregating variables. This parameter can be  useful when hierarchies and formula are unspecified.</p>
</td></tr>
<tr><td><code id="GaussSuppressionFromData_+3A_freqvar">freqVar</code></td>
<td>
<p>A single variable holding counts (name or number).</p>
</td></tr>
<tr><td><code id="GaussSuppressionFromData_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the supplied functions and to <code>ModelMatrix</code> (such as <code>inputInOutput</code> and <code>removeEmpty</code>).</p>
</td></tr>
<tr><td><code id="GaussSuppressionFromData_+3A_numvar">numVar</code></td>
<td>
<p>Other numerical variables to be aggregated</p>
</td></tr>
<tr><td><code id="GaussSuppressionFromData_+3A_weightvar">weightVar</code></td>
<td>
<p>weightVar Weights (costs) to be used to order candidates for secondary suppression</p>
</td></tr>
<tr><td><code id="GaussSuppressionFromData_+3A_charvar">charVar</code></td>
<td>
<p>Other variables possibly to be used within the supplied functions</p>
</td></tr>
<tr><td><code id="GaussSuppressionFromData_+3A_hierarchies">hierarchies</code></td>
<td>
<p>List of hierarchies, which can be converted by <code>AutoHierarchies</code>.
Thus, the variables can also be coded by <code>"rowFactor"</code> or <code>""</code>, which correspond to using the categories in the data.</p>
</td></tr>
<tr><td><code id="GaussSuppressionFromData_+3A_formula">formula</code></td>
<td>
<p>A model formula</p>
</td></tr>
<tr><td><code id="GaussSuppressionFromData_+3A_maxn">maxN</code></td>
<td>
<p>Suppression parameter. Cells with frequency <code style="white-space: pre;">&#8288;&lt;= maxN&#8288;</code> are set as primary suppressed.
Using the default <code>primary</code> function, <code>maxN</code> is by default set to <code>3</code>. See details.</p>
</td></tr>
<tr><td><code id="GaussSuppressionFromData_+3A_protectzeros">protectZeros</code></td>
<td>
<p>Suppression parameter.
When <code>TRUE</code>, cells with zero frequency or value are set as primary suppressed.
Using the default <code>primary</code> function, <code>protectZeros</code> is by default set to <code>TRUE</code>. See details.</p>
</td></tr>
<tr><td><code id="GaussSuppressionFromData_+3A_secondaryzeros">secondaryZeros</code></td>
<td>
<p>Suppression parameter.
When <code>TRUE</code>, cells with zero frequency or value are prioritized to be published so that they are not secondary suppressed.
Using the default <code>candidates</code> function, <code>secondaryZeros</code> is by default set to <code>FALSE</code>.
See details.</p>
</td></tr>
<tr><td><code id="GaussSuppressionFromData_+3A_candidates">candidates</code></td>
<td>
<p>GaussSuppression input or a function generating it (see details) Default: <code><a href="#topic+CandidatesDefault">CandidatesDefault</a></code></p>
</td></tr>
<tr><td><code id="GaussSuppressionFromData_+3A_primary">primary</code></td>
<td>
<p>GaussSuppression input or a function generating it (see details) Default: <code><a href="#topic+PrimaryDefault">PrimaryDefault</a></code></p>
</td></tr>
<tr><td><code id="GaussSuppressionFromData_+3A_forced">forced</code></td>
<td>
<p>GaussSuppression input or a function generating it (see details)</p>
</td></tr>
<tr><td><code id="GaussSuppressionFromData_+3A_hidden">hidden</code></td>
<td>
<p>GaussSuppression input or a function generating it (see details)</p>
</td></tr>
<tr><td><code id="GaussSuppressionFromData_+3A_singleton">singleton</code></td>
<td>
<p>GaussSuppression input or a function generating it (see details) Default: <code><a href="#topic+SingletonDefault">SingletonDefault</a></code></p>
</td></tr>
<tr><td><code id="GaussSuppressionFromData_+3A_singletonmethod">singletonMethod</code></td>
<td>
<p><code><a href="#topic+GaussSuppression">GaussSuppression</a></code> input. The default value depends on parameter <code>secondaryZeros</code> which depends on <code>candidates</code> (see details).</p>
</td></tr>
<tr><td><code id="GaussSuppressionFromData_+3A_printinc">printInc</code></td>
<td>
<p><code><a href="#topic+GaussSuppression">GaussSuppression</a></code> input</p>
</td></tr>
<tr><td><code id="GaussSuppressionFromData_+3A_output">output</code></td>
<td>
<p>One of <code>"publish"</code> (default), <code>"inner"</code>, <code>"publish_inner"</code>, <code>"publish_inner_x"</code>, <code>"publish_x"</code>,
<code>"inner_x"</code>, <code>"input2functions"</code> (input to supplied functions),
<code>"inputGaussSuppression"</code>, <code>"inputGaussSuppression_x"</code>,
<code>"outputGaussSuppression"</code>  <code>"outputGaussSuppression_x"</code>,
<code>"primary"</code>,  <code>"secondary"</code> and <code>"all"</code>.
Here &quot;inner&quot; means input data (possibly pre-aggregated) and
&quot;x&quot; means dummy matrix (as input parameter x).
All input to and output from <code><a href="#topic+GaussSuppression">GaussSuppression</a></code>, except <code>...</code>, are returned when <code>"outputGaussSuppression_x"</code>.
Excluding x and only input are also possible.
The code <code>"all"</code> means all relevant output after all the calculations.
Currently, this means the same as <code>"publish_inner_x"</code> extended with the matrices (or NULL) <code>xExtraPrimary</code>  and <code>unsafe</code>.
The former matrix is usually made by <code><a href="#topic+KDisclosurePrimary">KDisclosurePrimary</a></code>.
This latter matrix contains the columns representing unsafe primary suppressions.
In addition to <code>x</code> columns corresponding to unsafe in ordinary output (see parameter <code>unsafeInOutput</code> below),
possible columns from  <code>xExtraPrimary</code> may also be included in the unsafe matrix (see details).</p>
</td></tr>
<tr><td><code id="GaussSuppressionFromData_+3A_x">x</code></td>
<td>
<p><code>x</code> (<code>modelMatrix</code>) and <code>crossTable</code> can be supplied as input instead of generating it from  <code>ModelMatrix</code></p>
</td></tr>
<tr><td><code id="GaussSuppressionFromData_+3A_crosstable">crossTable</code></td>
<td>
<p>See above.</p>
</td></tr>
<tr><td><code id="GaussSuppressionFromData_+3A_preaggregate">preAggregate</code></td>
<td>
<p>When <code>TRUE</code>, the data will be aggregated within the function to an appropriate level.
This is defined by the dimensional variables according to <code>dimVar</code>, <code>hierarchies</code> or <code>formula</code> and in addition <code>charVar</code>.</p>
</td></tr>
<tr><td><code id="GaussSuppressionFromData_+3A_extraaggregate">extraAggregate</code></td>
<td>
<p>When <code>TRUE</code>, the data will be aggregated by the dimensional variables according to <code>dimVar</code>, <code>hierarchies</code> or <code>formula</code>.
The aggregated data and the corresponding x-matrix will only be used as input to the singleton
function and <code><a href="#topic+GaussSuppression">GaussSuppression</a></code>.
This extra aggregation is useful when parameter <code>charVar</code> is used.
Supply <code>"publish_inner"</code>, <code>"publish_inner_x"</code>, <code>"publish_x"</code> or <code>"inner_x"</code> as <code>output</code> to obtain extra aggregated results.
Supply <code>"inner"</code> or <code>"input2functions"</code> to obtain other results.</p>
</td></tr>
<tr><td><code id="GaussSuppressionFromData_+3A_structuralempty">structuralEmpty</code></td>
<td>
<p>When <code>TRUE</code>, output cells with no contributing inner cells (only zeros in column of <code>x</code>)
are forced to be not primary suppressed.
Thus, these cells are considered as structural zeros.
When <code>structuralEmpty</code> is <code>TRUE</code>, the following error message is avoided:
<code>Suppressed</code> <code>cells</code> <code>with</code> <code>empty</code> <code>input</code> <code>will</code> <code>not</code> <code>be</code> <code>protected.</code>
<code>Extend</code> <code>input</code> <code>data</code> <code>with</code> <code style="white-space: pre;">&#8288;zeros?&#8288;</code>.
When <code>removeEmpty</code> is <code>TRUE</code> (see &quot;<code>...</code>&quot; below), <code>structuralEmpty</code> is superfluous</p>
</td></tr>
<tr><td><code id="GaussSuppressionFromData_+3A_extend0">extend0</code></td>
<td>
<p>Data is automatically extended by <code>Extend0</code> when <code>TRUE</code>.
Can also be set to <code>"all"</code> which means that input codes in hierarchies are considered in addition to those in data.
Parameter <code>extend0</code> can also be specified as a list meaning parameter <code>varGroups</code> to <code>Extend0</code>.</p>
</td></tr>
<tr><td><code id="GaussSuppressionFromData_+3A_spec">spec</code></td>
<td>
<p><code>NULL</code> or a named list of arguments that will act as default values.</p>
</td></tr>
<tr><td><code id="GaussSuppressionFromData_+3A_speclock">specLock</code></td>
<td>
<p>When <code>TRUE</code>, arguments in <code>spec</code> cannot be changed.</p>
</td></tr>
<tr><td><code id="GaussSuppressionFromData_+3A_freqvarnew">freqVarNew</code></td>
<td>
<p>Name of new frequency variable generated when input <code>freqVar</code> is NULL and <code>preAggregate</code> is TRUE.
Default is <code>"freq"</code> provided this is not found in <code>names(data)</code>.</p>
</td></tr>
<tr><td><code id="GaussSuppressionFromData_+3A_nuniquevar">nUniqueVar</code></td>
<td>
<p>Name of variable holding the number of unique contributors.
This variable will be generated in the <code>extraAggregate</code> step.
Default is <code>"nUnique"</code> provided this is not found in <code>names(data)</code>.
If an existing variable is passed as input,
this variable will apply only when <code>preAggregate</code>/<code>extraAggregate</code> is not done.</p>
</td></tr>
<tr><td><code id="GaussSuppressionFromData_+3A_forcedinoutput">forcedInOutput</code></td>
<td>
<p>Whether to include <code>forced</code> as an output column.
One of <code>"ifNonNULL"</code> (default), <code>"always"</code>, <code>"ifany"</code> and <code>"no"</code>.
In addition, <code>TRUE</code> and <code>FALSE</code> are allowed as alternatives to  <code>"always"</code> and <code>"no"</code>.</p>
</td></tr>
<tr><td><code id="GaussSuppressionFromData_+3A_unsafeinoutput">unsafeInOutput</code></td>
<td>
<p>Whether to include <code>usafe</code> as an output column.
One of <code>"ifForcedInOutput"</code> (default), <code>"always"</code>, <code>"ifany"</code> and <code>"no"</code>.
In addition, <code>TRUE</code> and <code>FALSE</code> are allowed as alternatives to  <code>"always"</code> and <code>"no"</code>.
see details.</p>
</td></tr>
<tr><td><code id="GaussSuppressionFromData_+3A_lppackage">lpPackage</code></td>
<td>

<ul>
<li> <p><strong><code>lpPackage</code>:</strong>
When non-NULL, intervals by <code><a href="#topic+ComputeIntervals">ComputeIntervals</a></code>
will be included in the output.
See its documentation for valid parameter values for 'lpPackage'.
If, additionally, at least one of the two <code><a href="#topic+RangeLimitsDefault">RangeLimitsDefault</a></code> parameters below is specified,
further suppression will be performed to satisfy the interval width requirements.
Then, the values in the output variable <code>suppressed_integer</code> means:
no suppression (0),
primary suppression (1),
secondary suppression (2),
additional suppression applied by an interval algorithm limited to linearly independent cells (3),
and further suppression according to the final gauss algorithm (4).
Intervals, <code style="white-space: pre;">&#8288;[lo_1, up_1]&#8288;</code>, are intervals calculated prior to additional suppression.
</p>

<ul>
<li> <p><strong><code>rangePercent</code>:</strong> Required interval width expressed as a percentage
</p>
</li>
<li> <p><strong><code>rangeMin</code>:</strong> Minimum required width of the interval
</p>
<div class="sourceCode"><pre>         Please note that interval calculations may have a 
         different interface in future versions.
</pre></div>
</li></ul>

</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>The supplied functions for generating <code><a href="#topic+GaussSuppression">GaussSuppression</a></code> input takes the following arguments:
<code>crossTable</code>,  <code>x</code>, <code>freq</code>, <code>num</code>, <code>weight</code>, <code>maxN</code>, <code>protectZeros</code>, <code>secondaryZeros</code>, <code>data</code>, <code>freqVar</code>, <code>numVar</code>, <code>weightVar</code>, <code>charVar</code>, <code>dimVar</code> and <code>...</code>.
where the two first are  <code>ModelMatrix</code> outputs (<code>modelMatrix</code> renamed to <code>x</code>).
The vector, <code>freq</code>, is aggregated counts (<code>t(x) %*% data[[freqVar]]</code>).
In addition, the supplied <code>singleton</code> function also takes <code>nUniqueVar</code> and (output from) <code>primary</code> as input.
</p>
<p>Similarly, <code>num</code>, is a data frame of aggregated numerical variables.
It is possible to supply several primary functions joined by <code>c</code>, e.g. (<code>c(FunPrim1, FunPrim2)</code>).
All <code>NA</code>s returned from any of the functions force the corresponding cells not to be primary suppressed.
</p>
<p>The effect of <code>maxN</code> , <code>protectZeros</code> and <code>secondaryZeros</code> depends on the supplied functions where these parameters are used.
Their default values are inherited from the default values of the first <code>primary</code> function (several possible) or,
in the case of <code>secondaryZeros</code>, the <code>candidates</code> function.
When defaults cannot be inherited, they are set to <code>NULL</code>.
In practice the function <code>formals</code> are still used to generate the defaults when <code>primary</code> and/or <code>candidates</code> are not functions.
Then <code>NULL</code> is correctly returned, but <code>suppressWarnings</code> are needed.
</p>
<p>Singleton handling can be turned off by <code>singleton = NULL</code> or <code>singletonMethod = "none"</code>.
Both of these choices are identical in the sense that <code>singletonMethod</code> is set to <code>"none"</code> whenever <code>singleton</code> is <code>NULL</code> and vice versa.
</p>
<p>Information about uncertain primary suppressions due to forced cells can be found
as described by parameters <code>unsafeInOutput</code> and <code>output</code>  (<code style="white-space: pre;">&#8288;= "all"&#8288;</code>).
When forced cells affect singleton problems, this is not implemented.
Some information can be seen from warnings.
This can also be seen by choosing <code>output = "secondary"</code> together
with <code>unsafeInOutput = "ifany"</code> or <code>unsafeInOutput = "always"</code>.
Then, negative indices from <code><a href="#topic+GaussSuppression">GaussSuppression</a></code> using
<code>unsafeAsNegative = TRUE</code> will be included in the output.
Singleton problems may, however, be present even if it cannot be seen as warning/output.
In some cases, the problems can be detected by <code><a href="#topic+GaussSuppressDec">GaussSuppressDec</a></code>.
</p>
<p>In some cases, cells that are forced, hidden, or primary suppressed can overlap.
For these situations, forced has precedence over hidden and primary.
That is, if a cell is both forced and hidden, it will be treated as a forced cell and thus published.
Similarly, any primary suppression of a forced cell will be ignored
(see parameter <code>whenPrimaryForced</code> to <code><a href="#topic+GaussSuppression">GaussSuppression</a></code>).
It is, however, meaningful to combine primary and hidden.
Such cells will be protected while also being assigned the <code>NA</code> value in the <code>suppressed</code> output variable.
</p>


<h3>Value</h3>

<p>Aggregated data with suppression information
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud and Daniel Lupp
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
z1 &lt;- SSBtoolsData("z1")
GaussSuppressionFromData(z1, 1:2, 3)

z2 &lt;- SSBtoolsData("z2")
GaussSuppressionFromData(z2, 1:4, 5, protectZeros = FALSE)


# Data as in GaussSuppression examples
df &lt;- data.frame(values = c(1, 1, 1, 5, 5, 9, 9, 9, 9, 9, 0, 0, 0, 7, 7), 
                 var1 = rep(1:3, each = 5), var2 = c("A", "B", "C", "D", "E"))

GaussSuppressionFromData(df, c("var1", "var2"), "values")
GaussSuppressionFromData(df, c("var1", "var2"), "values", formula = ~var1 + var2, maxN = 10)
GaussSuppressionFromData(df, c("var1", "var2"), "values", formula = ~var1 + var2, maxN = 10,
      protectZeros = TRUE, # Parameter needed by SingletonDefault and default not in primary  
      primary = function(freq, crossTable, maxN, ...) 
                   which(freq &lt;= maxN &amp; crossTable[[2]] != "A" &amp; crossTable[, 2] != "C"))
                   
# Combining several primary functions 
# Note that NA &amp; c(TRUE, FALSE) equals c(NA, FALSE)                      
GaussSuppressionFromData(df, c("var1", "var2"), "values", formula = ~var1 + var2, maxN = 10, 
       primary = c(function(freq, maxN, protectZeros = TRUE, ...) freq &gt;= 45,
                   function(freq, maxN, ...) freq &lt;= maxN,
                   function(crossTable, ...) NA &amp; crossTable[[2]] == "C",  
                   function(crossTable, ...) NA &amp; crossTable[[1]]== "Total" 
                                                &amp; crossTable[[2]]== "Total"))                    
                   
# Similar to GaussSuppression examples
GaussSuppressionFromData(df, c("var1", "var2"), "values", formula = ~var1 * var2, 
       candidates = NULL, singleton = NULL, protectZeros = FALSE, secondaryZeros = TRUE)
GaussSuppressionFromData(df, c("var1", "var2"), "values", formula = ~var1 * var2, 
       singleton = NULL, protectZeros = FALSE, secondaryZeros = FALSE)
GaussSuppressionFromData(df, c("var1", "var2"), "values", formula = ~var1 * var2, 
       protectZeros = FALSE, secondaryZeros = FALSE)

              
# Examples with zeros as singletons
z &lt;- data.frame(row = rep(1:3, each = 3), col = 1:3, freq = c(0, 2, 5, 0, 0, 6:9))
GaussSuppressionFromData(z, 1:2, 3, singleton = NULL) 
GaussSuppressionFromData(z, 1:2, 3, singletonMethod = "none") # as above 
GaussSuppressionFromData(z, 1:2, 3)
GaussSuppressionFromData(z, 1:2, 3, protectZeros = FALSE, secondaryZeros = TRUE, singleton = NULL)
GaussSuppressionFromData(z, 1:2, 3, protectZeros = FALSE, secondaryZeros = TRUE)      
</code></pre>

<hr>
<h2 id='GaussSuppressionTwoWay'>Two-way iteration variant of <code><a href="#topic+GaussSuppressionFromData">GaussSuppressionFromData</a></code></h2><span id='topic+GaussSuppressionTwoWay'></span>

<h3>Description</h3>

<p>Internally, data is organized in a two-way table.
</p>
<p>Use parameter <code>colVar</code> to choose hierarchies for columns (others will be rows). Iterations start by column by column suppression.
The algorithm utilizes <code>HierarchyCompute2</code>.
</p>
<p>With two-way iterations, larger data can be handled, but there is a residual risk.
The method is a special form of linked-table iteration.
Separately, the rows and columns are protected by <code><a href="#topic+GaussSuppression">GaussSuppression</a></code> and they have common suppressed cells.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GaussSuppressionTwoWay(
  data,
  dimVar = NULL,
  freqVar = NULL,
  numVar = NULL,
  weightVar = NULL,
  charVar = NULL,
  hierarchies,
  formula = NULL,
  maxN = suppressWarnings(formals(c(primary)[[1]])$maxN),
  protectZeros = suppressWarnings(formals(c(primary)[[1]])$protectZeros),
  secondaryZeros = suppressWarnings(formals(candidates)$secondaryZeros),
  candidates = CandidatesDefault,
  primary = PrimaryDefault,
  forced = NULL,
  hidden = NULL,
  singleton = SingletonDefault,
  singletonMethod = ifelse(secondaryZeros, "anySumNOTprimary", "anySum"),
  printInc = TRUE,
  output = "publish",
  preAggregate = is.null(freqVar),
  colVar = names(hierarchies)[1],
  removeEmpty = TRUE,
  inputInOutput = TRUE,
  candidatesFromTotal = TRUE,
  structuralEmpty = FALSE,
  freqVarNew = rev(make.unique(c(names(data), "freq")))[1],
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GaussSuppressionTwoWay_+3A_data">data</code></td>
<td>
<p>Input data as a data frame</p>
</td></tr>
<tr><td><code id="GaussSuppressionTwoWay_+3A_dimvar">dimVar</code></td>
<td>
<p>The main dimensional variables and additional aggregating variables. This parameter can be  useful when hierarchies and formula are unspecified.</p>
</td></tr>
<tr><td><code id="GaussSuppressionTwoWay_+3A_freqvar">freqVar</code></td>
<td>
<p>A single variable holding counts (name or number).</p>
</td></tr>
<tr><td><code id="GaussSuppressionTwoWay_+3A_numvar">numVar</code></td>
<td>
<p>Other numerical variables to be aggregated</p>
</td></tr>
<tr><td><code id="GaussSuppressionTwoWay_+3A_weightvar">weightVar</code></td>
<td>
<p>weightVar Weights (costs) to be used to order candidates for secondary suppression</p>
</td></tr>
<tr><td><code id="GaussSuppressionTwoWay_+3A_charvar">charVar</code></td>
<td>
<p>Other variables possibly to be used within the supplied functions</p>
</td></tr>
<tr><td><code id="GaussSuppressionTwoWay_+3A_hierarchies">hierarchies</code></td>
<td>
<p>List of hierarchies, which can be converted by <code>AutoHierarchies</code>.
Thus, the variables can also be coded by <code>"rowFactor"</code> or <code>""</code>, which correspond to using the categories in the data.</p>
</td></tr>
<tr><td><code id="GaussSuppressionTwoWay_+3A_formula">formula</code></td>
<td>
<p>A model formula</p>
</td></tr>
<tr><td><code id="GaussSuppressionTwoWay_+3A_maxn">maxN</code></td>
<td>
<p>Suppression parameter. See <code>GaussSuppressionFromData</code>.</p>
</td></tr>
<tr><td><code id="GaussSuppressionTwoWay_+3A_protectzeros">protectZeros</code></td>
<td>
<p>Suppression parameter. See <code>GaussSuppressionFromData</code>.</p>
</td></tr>
<tr><td><code id="GaussSuppressionTwoWay_+3A_secondaryzeros">secondaryZeros</code></td>
<td>
<p>Suppression parameter. See <code>GaussSuppressionFromData</code>.</p>
</td></tr>
<tr><td><code id="GaussSuppressionTwoWay_+3A_candidates">candidates</code></td>
<td>
<p>GaussSuppression input or a function generating it (see details) Default: <code><a href="#topic+CandidatesDefault">CandidatesDefault</a></code></p>
</td></tr>
<tr><td><code id="GaussSuppressionTwoWay_+3A_primary">primary</code></td>
<td>
<p>GaussSuppression input or a function generating it (see details) Default: <code><a href="#topic+PrimaryDefault">PrimaryDefault</a></code></p>
</td></tr>
<tr><td><code id="GaussSuppressionTwoWay_+3A_forced">forced</code></td>
<td>
<p>GaussSuppression input or a function generating it (see details)</p>
</td></tr>
<tr><td><code id="GaussSuppressionTwoWay_+3A_hidden">hidden</code></td>
<td>
<p>GaussSuppression input or a function generating it (see details)</p>
</td></tr>
<tr><td><code id="GaussSuppressionTwoWay_+3A_singleton">singleton</code></td>
<td>
<p>NULL or a function generating GaussSuppression input (logical vector not possible) Default: <code><a href="#topic+SingletonDefault">SingletonDefault</a></code></p>
</td></tr>
<tr><td><code id="GaussSuppressionTwoWay_+3A_singletonmethod">singletonMethod</code></td>
<td>
<p><code><a href="#topic+GaussSuppression">GaussSuppression</a></code> input</p>
</td></tr>
<tr><td><code id="GaussSuppressionTwoWay_+3A_printinc">printInc</code></td>
<td>
<p><code><a href="#topic+GaussSuppression">GaussSuppression</a></code> input</p>
</td></tr>
<tr><td><code id="GaussSuppressionTwoWay_+3A_output">output</code></td>
<td>
<p>One of <code>"publish"</code> (default), <code>"inner"</code>.
Here &quot;inner&quot; means input data (possibly pre-aggregated).</p>
</td></tr>
<tr><td><code id="GaussSuppressionTwoWay_+3A_preaggregate">preAggregate</code></td>
<td>
<p>When <code>TRUE</code>, the data will be aggregated within the function to an appropriate level.
This is defined by the dimensional variables according to <code>dimVar</code>, <code>hierarchies</code> or <code>formula</code> and in addition <code>charVar</code>.</p>
</td></tr>
<tr><td><code id="GaussSuppressionTwoWay_+3A_colvar">colVar</code></td>
<td>
<p>Hierarchy variables for the column groups (others in row group).</p>
</td></tr>
<tr><td><code id="GaussSuppressionTwoWay_+3A_removeempty">removeEmpty</code></td>
<td>
<p>When TRUE (default) empty output corresponding to empty input is removed.
When NULL, removal only within the algorithm (x  matrices) so that such empty outputs are never secondary suppressed.</p>
</td></tr>
<tr><td><code id="GaussSuppressionTwoWay_+3A_inputinoutput">inputInOutput</code></td>
<td>
<p>Logical vector (possibly recycled) for each element of hierarchies.
TRUE means that codes from input are included in output. Values corresponding to <code>"rowFactor"</code> or <code>""</code> are ignored.</p>
</td></tr>
<tr><td><code id="GaussSuppressionTwoWay_+3A_candidatesfromtotal">candidatesFromTotal</code></td>
<td>
<p>When TRUE (default), same candidates for all rows and for all columns, computed from row/column totals.</p>
</td></tr>
<tr><td><code id="GaussSuppressionTwoWay_+3A_structuralempty">structuralEmpty</code></td>
<td>
<p>See <code>GaussSuppressionFromData</code>.</p>
</td></tr>
<tr><td><code id="GaussSuppressionTwoWay_+3A_freqvarnew">freqVarNew</code></td>
<td>
<p>Name of new frequency variable generated when input <code>freqVar</code> is NULL and <code>preAggregate</code> is TRUE.
Default is <code>"freq"</code> provided this is not found in <code>names(data)</code>.</p>
</td></tr>
<tr><td><code id="GaussSuppressionTwoWay_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the supplied functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The supplied functions for generating <code><a href="#topic+GaussSuppression">GaussSuppression</a></code> input behave as in <code><a href="#topic+GaussSuppressionFromData">GaussSuppressionFromData</a></code> with some exceptions.
When <code>candidatesFromTotal</code> is <code>TRUE</code> (default) the candidate function will be run locally once for rows and once for columns. Each time based on column or row totals.
The global x-matrix will only be generated if one of the functions supplied needs it.
Non-NULL singleton can only be supplied as a function. This function will be run locally within the algorithm before each call to <code><a href="#topic+GaussSuppression">GaussSuppression</a></code>.
</p>
<p>Note that a difference from <code>GaussSuppressionFromData</code> is that parameter <code>removeEmpty</code> is set to <code>TRUE</code> by default.
</p>
<p>Another difference is that duplicated combinations is not allowed. Normally duplicates are avoided by setting <code>preAggregate</code> to <code>TRUE</code>.
When the <code>charVar</code> parameter is used, this can still be a problem. See the examples for a possible workaround.
</p>


<h3>Value</h3>

<p>Aggregated data with suppression information
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z3 &lt;- SSBtoolsData("z3")

dimListsA &lt;- SSBtools::FindDimLists(z3[, 1:6])
dimListsB &lt;- SSBtools::FindDimLists(z3[, c(1, 4, 5)])

set.seed(123)
z &lt;- z3[sample(nrow(z3),250),]

## Not run: 
out1 &lt;- GaussSuppressionTwoWay(z, freqVar = "ant", hierarchies = dimListsA, 
                               colVar = c("hovedint"))

## End(Not run)                                
out2 &lt;- GaussSuppressionTwoWay(z, freqVar = "ant", hierarchies = dimListsA, 
                               colVar = c("hovedint", "mnd"))
out3 &lt;- GaussSuppressionTwoWay(z, freqVar = "ant", hierarchies = dimListsB, 
                               colVar = c("region"))
out4 &lt;- GaussSuppressionTwoWay(z, freqVar = "ant", hierarchies = dimListsB, 
                               colVar = c("hovedint", "region"))
                               
# "mnd" not in  hierarchies -&gt; duplicated combinations in input 
# Error when  preAggregate is FALSE: Index method failed. Duplicated combinations?
out5 &lt;- GaussSuppressionTwoWay(z, freqVar = "ant", hierarchies = dimListsA[1:3], 
                               protectZeros = FALSE, colVar = c("hovedint"), preAggregate = TRUE)


# charVar needed -&gt; Still problem when preAggregate is TRUE
# Possible workaround by extra hierarchy 
out6 &lt;- GaussSuppressionTwoWay(z, freqVar = "ant", charVar = "mnd2",
                               hierarchies = c(dimListsA[1:3], mnd2 = "Total"), # include charVar 
                               inputInOutput = c(TRUE, TRUE, FALSE),  # FALSE -&gt; only Total 
                               protectZeros = FALSE, colVar = c("hovedint"),
                               preAggregate = TRUE,  
                               hidden = function(x, data, charVar, ...) 
                                 as.vector((t(x) %*% as.numeric(data[[charVar]] == "M06M12")) == 0))                                
</code></pre>

<hr>
<h2 id='GetDefault'>Get default value of a function</h2><span id='topic+GetDefault'></span>

<h3>Description</h3>

<p>The value may be found in a spec.
See <code><a href="#topic+PackageSpecs">PackageSpecs</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetDefault(fun, parameter, ifnotfound = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetDefault_+3A_fun">fun</code></td>
<td>
<p>A function</p>
</td></tr>
<tr><td><code id="GetDefault_+3A_parameter">parameter</code></td>
<td>
<p>parameter name</p>
</td></tr>
<tr><td><code id="GetDefault_+3A_ifnotfound">ifnotfound</code></td>
<td>
</td></tr>
</table>


<h3>Details</h3>

<p>The result is evaluated if <code><a href="base.html#topic+is.name">is.name</a></code> returns <code>TRUE</code>.
</p>


<h3>Value</h3>

<p>The default parameter, possibly evaluated.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fun1 &lt;- GetDefault(GaussSuppressionFromData, "candidates")
fun2 &lt;- GetDefault(SuppressFewContributors, "primary")
fun3 &lt;- GetDefault(SuppressDominantCells, "primary") 
</code></pre>

<hr>
<h2 id='HierarchyContributors'>Counts of input code contributions</h2><span id='topic+HierarchyContributors'></span>

<h3>Description</h3>

<p>Counts of input code contributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HierarchyContributors(data, x, crossTable, hierarchies, inputInOutput = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HierarchyContributors_+3A_data">data</code></td>
<td>
<p>input data</p>
</td></tr>
<tr><td><code id="HierarchyContributors_+3A_x">x</code></td>
<td>
<p>model matrix as created by <code>ModelMatrix</code> with <code>data</code>, <code>hierarchies</code> and <code>inputInOutput</code> as input</p>
</td></tr>
<tr><td><code id="HierarchyContributors_+3A_crosstable">crossTable</code></td>
<td>
<p><code>crossTable</code> as created by <code>ModelMatrix</code> with <code>data</code>, <code>hierarchies</code> and <code>inputInOutput</code> as input</p>
</td></tr>
<tr><td><code id="HierarchyContributors_+3A_hierarchies">hierarchies</code></td>
<td>
<p>Standardized hierarchies.  That is, output from <code>AutoHierarchies</code>.</p>
</td></tr>
<tr><td><code id="HierarchyContributors_+3A_inputinoutput">inputInOutput</code></td>
<td>
<p><code>ModelMatrix</code> input.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of data frames of counts associated with <code>crossTable</code>
</p>

<ul>
<li> <p><strong><code>min</code>:</strong> Minimum number of times a contributing input code contributes
</p>
</li>
<li> <p><strong><code>max</code>:</strong> Maximum number of times a contributing input code contributes
</p>
</li>
<li> <p><strong><code>n</code>:</strong>   Number of contributing input codes
</p>
</li>
<li> <p><strong><code>ac</code>:</strong>  Theoretical number of contributing input codes according to the hierarchy
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- SSBtoolsData("sprt_emp_withEU")[-(1:3), ]
z$age[z$age == "Y15-29"] &lt;- "young"
z$age[z$age == "Y30-64"] &lt;- "old"
hi &lt;- SSBtools::FindHierarchies(z[, -4])
inputInOutput &lt;- c(TRUE, FALSE, FALSE)
mm &lt;- SSBtools::ModelMatrix(z, hi, crossTable = TRUE, inputInOutput = inputInOutput)

out &lt;- HierarchyContributors(z, mm$modelMatrix, mm$crossTable, hi, inputInOutput)

# The nonzero values are caused by the removed three data rows
cbind(mm$crossTable, out$max - out$min)
cbind(mm$crossTable, out$ac - out$n)

</code></pre>

<hr>
<h2 id='IncrementalTimeSuppression'>Incremental Time Suppression</h2><span id='topic+IncrementalTimeSuppression'></span>

<h3>Description</h3>

<p>Suppression function useful for sequential calculations over successive time periods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IncrementalTimeSuppression(
  data,
  fun,
  timeVar,
  formula,
  suppressedData = NULL,
  subTotals = FALSE,
  finalTotal = FALSE,
  totalPriority = !isFALSE(finalTotal),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IncrementalTimeSuppression_+3A_data">data</code></td>
<td>
<p>Input data as a data frame</p>
</td></tr>
<tr><td><code id="IncrementalTimeSuppression_+3A_fun">fun</code></td>
<td>
<p>A function: <code><a href="#topic+GaussSuppressionFromData">GaussSuppressionFromData</a></code> or one of its wrappers such as
<code><a href="#topic+SuppressSmallCounts">SuppressSmallCounts</a></code> and <code><a href="#topic+SuppressDominantCells">SuppressDominantCells</a></code>.</p>
</td></tr>
<tr><td><code id="IncrementalTimeSuppression_+3A_timevar">timeVar</code></td>
<td>
<p>The time period variable</p>
</td></tr>
<tr><td><code id="IncrementalTimeSuppression_+3A_formula">formula</code></td>
<td>
<p>formula A formula defining tables within the time periods.
Therefore, the variable <code>timeVar</code>  should not be included.</p>
</td></tr>
<tr><td><code id="IncrementalTimeSuppression_+3A_suppresseddata">suppressedData</code></td>
<td>
<p>A data frame or a list of data frames as output from <code><a href="#topic+GaussSuppressionFromData">GaussSuppressionFromData</a></code>.</p>
</td></tr>
<tr><td><code id="IncrementalTimeSuppression_+3A_subtotals">subTotals</code></td>
<td>
<p>Whether all cumulative totals over time should be included.</p>
</td></tr>
<tr><td><code id="IncrementalTimeSuppression_+3A_finaltotal">finalTotal</code></td>
<td>
<p>When <code>FALSE</code>, the <code>timeVar</code> total is named according to time period categories.</p>
</td></tr>
<tr><td><code id="IncrementalTimeSuppression_+3A_totalpriority">totalPriority</code></td>
<td>
<p>When <code>FALSE</code>, the <code>timeVar</code>  totals are not prioritized
for publication. In other words, these totals are preferred for secondary suppression.</p>
</td></tr>
<tr><td><code id="IncrementalTimeSuppression_+3A_...">...</code></td>
<td>
<p>Further parameters to <code><a href="#topic+GaussSuppressionFromData">GaussSuppressionFromData</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame
</p>


<h3>Note</h3>

<p>This function has been made internal since it is new and future non-backward compatible changes may occur.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+AdditionalSuppression">AdditionalSuppression</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generating a dataset spanning four quarters 
d2s &lt;- SSBtoolsData("d2s")
d &lt;- rbind(d2s, d2s, d2s, d2s)
set.seed(10)
d$freq[25:96] &lt;- round(d$freq[25:96] + 9 * rnorm(72))
d$freq[d$freq &lt; 0] &lt;- 0
d$quarter &lt;- rep(c("Q1", "Q2", "Q3", "Q4"), each = 24)

# Redefine the function so that several parameters are preset. 
# Also, a simpler function name.   
STS &lt;- function(data, ...) {
  IncrementalTimeSuppression(data, 
          fun = SuppressSmallCounts, 
          timeVar = "quarter", 
          formula = ~main_income * size, 
          maxN = 15, freqVar = "freq", ...)}
          
          
# Default settings without suppressedData as input
a1 &lt;- STS(d[1:24, ])   
a2 &lt;- STS(d[1:48, ])
a3 &lt;- STS(d[1:72, ])
a4 &lt;- STS(d, finalTotal = TRUE)

# The quarters and named totals
unique(a1$quarter)
unique(a2$quarter)
unique(a3$quarter)
unique(a4$quarter)

# Default settings with suppressedData as input
b2 &lt;- STS(d[1:48, ], suppressedData = a1)
b3 &lt;- STS(d[1:72, ], suppressedData = b2)
b4 &lt;- STS(d, finalTotal = TRUE, suppressedData = b3)

# Without totalPriority, suppression will be the same as before. 
# suppressedData makes no difference.
# However, if, for example, there is a changed version of the suppression 
# algorithm, it may be important to use suppressedData 
identical(a2$suppressed, b2$suppressed)
identical(a3$suppressed, b3$suppressed)
identical(a4$suppressed, b4$suppressed) # totalPriority here, since finalTotal 

# With totalPriority and  all the subtotals 
# Note: subtotals are not prioritized
c2 &lt;- STS(d[1:48, ], subTotals = TRUE, totalPriority = TRUE)
c3 &lt;- STS(d[1:72, ], subTotals = TRUE, totalPriority = TRUE)
c4 &lt;- STS(d, subTotals = TRUE, finalTotal = TRUE)
unique(c2$quarter)
unique(c3$quarter)
unique(c4$quarter)

# With such a method, we can see that is important to take into account 
# previously published results.
# Here this is not done and we see differences.
a2[a2$suppressed | c2$suppressed, ]
c2[a2$suppressed | c2$suppressed, ]
c3[SSBtools::Match( c2[a2$suppressed | c2$suppressed, 1:4], c3[1:4]), ]
c4[SSBtools::Match( c2[a2$suppressed | c2$suppressed, 1:4], c4[1:4]), ]


# Here we take into account previously published results.
d2 &lt;- STS(d[1:48, ], subTotals = TRUE, totalPriority = TRUE, suppressedData = a1)
d3 &lt;- STS(d[1:72, ], subTotals = TRUE, totalPriority = TRUE, suppressedData = d2)
d4 &lt;- STS(d, subTotals = TRUE, finalTotal = TRUE, suppressedData = d3)

SSBtools::SortRows(d2[d2$suppressed, ])
SSBtools::SortRows(d3[d3$suppressed, ])

# With such a method, some annual totals must be suppressed
SSBtools::SortRows(d4[d4$suppressed, ]) 

# If necessary, several suppressed data sets can be taken into account
e4 &lt;- STS(d, finalTotal = TRUE, suppressedData = list(a1, a2))

</code></pre>

<hr>
<h2 id='KDisclosurePrimary'>Construct primary suppressed difference matrix</h2><span id='topic+KDisclosurePrimary'></span>

<h3>Description</h3>

<p>Function for constructing model matrix columns representing primary suppressed
difference cells
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KDisclosurePrimary(
  data,
  x,
  crossTable,
  freqVar,
  mc_hierarchies = NULL,
  coalition = 1,
  upper_bound = Inf,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KDisclosurePrimary_+3A_data">data</code></td>
<td>
<p>a data.frame representing the data set</p>
</td></tr>
<tr><td><code id="KDisclosurePrimary_+3A_x">x</code></td>
<td>
<p>ModelMatrix generated by parent function</p>
</td></tr>
<tr><td><code id="KDisclosurePrimary_+3A_crosstable">crossTable</code></td>
<td>
<p>crossTable generated by parent function</p>
</td></tr>
<tr><td><code id="KDisclosurePrimary_+3A_freqvar">freqVar</code></td>
<td>
<p>name of the frequency variable in <code>data</code></p>
</td></tr>
<tr><td><code id="KDisclosurePrimary_+3A_mc_hierarchies">mc_hierarchies</code></td>
<td>
<p>a hierarchy representing meaningful combinations to be
protected. Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="KDisclosurePrimary_+3A_coalition">coalition</code></td>
<td>
<p>numeric vector of length one, representing possible size of an
attacking coalition. This parameter corresponds to the parameter k in the
definition of k-disclosure.</p>
</td></tr>
<tr><td><code id="KDisclosurePrimary_+3A_upper_bound">upper_bound</code></td>
<td>
<p>numeric value representing minimum count considered safe.
Default set to <code>Inf</code></p>
</td></tr>
<tr><td><code id="KDisclosurePrimary_+3A_...">...</code></td>
<td>
<p>parameters passed to children functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dgCMatrix corresponding to primary suppressed cells
</p>


<h3>Author(s)</h3>

<p>Daniel P. Lupp
</p>

<hr>
<h2 id='LazyLinkedTables'>Linked tables by full <code><a href="#topic+GaussSuppressionFromData">GaussSuppressionFromData</a></code> iterations</h2><span id='topic+LazyLinkedTables'></span>

<h3>Description</h3>

<p><code><a href="#topic+AdditionalSuppression">AdditionalSuppression</a></code> is called several times as in <code><a href="#topic+ChainedSuppression">ChainedSuppression</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LazyLinkedTables(..., withinArg = NULL, maxIterLinked = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LazyLinkedTables_+3A_...">...</code></td>
<td>
<p>Arguments to <code>GaussSuppressionFromData</code> that are kept constant.</p>
</td></tr>
<tr><td><code id="LazyLinkedTables_+3A_withinarg">withinArg</code></td>
<td>
<p>A list of named lists. Arguments to <code>GaussSuppressionFromData</code> that are not kept constant.</p>
</td></tr>
<tr><td><code id="LazyLinkedTables_+3A_maxiterlinked">maxIterLinked</code></td>
<td>
<p>Maximum number of <code>GaussSuppressionFromData</code> calls for each table.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is created as a spin-off from <code>AdditionalSuppression</code> and <code>ChainedSuppression</code>.
The calculations run <code>GaussSuppressionFromData</code> from the input each time.
There is no doubt that this can be done more efficiently.
</p>
<p>A consequence of this lazy implementation is that, in output, <code>primary</code> and <code>suppressed</code> are identical.
</p>
<p>Note that there is a residual risk when suppression linked tables by iterations.
</p>


<h3>Value</h3>

<p>List of data frames
</p>


<h3>Note</h3>

<p>In this function, the parameters <code>makeForced</code>  and <code>forceNotPrimary</code> to  <code>AdditionalSuppression</code> are forced to be <code>FALSE</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
z1 &lt;- SSBtoolsData("z1")
z2 &lt;- SSBtoolsData("z2")
z2b &lt;- z2[3:5]  # As in ChainedSuppression example 
names(z2b)[1] &lt;- "region"

# The two region hierarchies as two linked tables
a &lt;- LazyLinkedTables(z2, freqVar = 5, withinArg = list(
       list(dimVar = c(1, 2, 4)), 
       list(dimVar = c(1, 3, 4))))

# As 'f' and 'e' in ChainedSuppression example. 
# 'A' 'annet'/'arbeid' suppressed in b[[1]], since suppressed in b[[3]].
b &lt;- LazyLinkedTables(withinArg = list(
       list(data = z1, dimVar = 1:2, freqVar = 3, maxN = 5), 
       list(data = z2b, dimVar = 1:2, freqVar = 3, maxN = 5), 
       list(data = z2, dimVar = 1:4, freqVar = 5, maxN = 1)))

</code></pre>

<hr>
<h2 id='MagnitudeRule'>Dominance <code style="white-space: pre;">&#8288;(n,k)&#8288;</code> or p% rule for magnitude tables</h2><span id='topic+MagnitudeRule'></span><span id='topic+DominanceRule'></span><span id='topic+PPercentRule'></span>

<h3>Description</h3>

<p>Supports application of multiple values for <code>n</code> and <code>k</code>. The function works
on magnitude tables containing negative cell values by calculating
contribution based on absolute values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MagnitudeRule(
  data,
  x,
  numVar,
  n = NULL,
  k = NULL,
  pPercent = NULL,
  protectZeros = FALSE,
  charVar = NULL,
  removeCodes = character(0),
  sWeightVar = NULL,
  domWeightMethod = "default",
  allDominance = FALSE,
  outputWeightedNum = !is.null(sWeightVar),
  dominanceVar = NULL,
  ...
)

DominanceRule(data, n, k, protectZeros = FALSE, ...)

PPercentRule(data, pPercent, protectZeros = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MagnitudeRule_+3A_data">data</code></td>
<td>
<p>the dataset</p>
</td></tr>
<tr><td><code id="MagnitudeRule_+3A_x">x</code></td>
<td>
<p>ModelMatrix generated by parent function</p>
</td></tr>
<tr><td><code id="MagnitudeRule_+3A_numvar">numVar</code></td>
<td>
<p>vector containing numeric values in the data set</p>
</td></tr>
<tr><td><code id="MagnitudeRule_+3A_n">n</code></td>
<td>
<p>parameter <code>n</code> in dominance rule.</p>
</td></tr>
<tr><td><code id="MagnitudeRule_+3A_k">k</code></td>
<td>
<p>parameter <code>k</code> in dominance rule.</p>
</td></tr>
<tr><td><code id="MagnitudeRule_+3A_ppercent">pPercent</code></td>
<td>
<p>Parameter in the p% rule, when non-NULL.
Parameters <code>n</code> and  <code>k</code> will then be ignored.
Technically, calculations are performed internally as if
<code>n = 1:2</code>. The results of these intermediate calculations can
be viewed by setting <code>allDominance = TRUE</code>.</p>
</td></tr>
<tr><td><code id="MagnitudeRule_+3A_protectzeros">protectZeros</code></td>
<td>
<p>parameter determining whether cells with value 0 should
be suppressed.</p>
</td></tr>
<tr><td><code id="MagnitudeRule_+3A_charvar">charVar</code></td>
<td>
<p>Variable in data holding grouping information. Dominance will
be calculated after aggregation within these groups.</p>
</td></tr>
<tr><td><code id="MagnitudeRule_+3A_removecodes">removeCodes</code></td>
<td>
<p>A vector of <code>charVar</code> codes that are to be excluded when
calculating dominance percentages. Essentially, the corresponding numeric
values from <code>dominanceVar</code> or <code>numVar</code> are set to zero before proceeding
with the dominance calculations. With empty <code>charVar</code> row indices are
assumed and conversion to integer is performed.</p>
</td></tr>
<tr><td><code id="MagnitudeRule_+3A_sweightvar">sWeightVar</code></td>
<td>
<p>variable with sampling weights to be used in dominance rule</p>
</td></tr>
<tr><td><code id="MagnitudeRule_+3A_domweightmethod">domWeightMethod</code></td>
<td>
<p>character representing how weights should be treated
in the dominance rule. See Details.</p>
</td></tr>
<tr><td><code id="MagnitudeRule_+3A_alldominance">allDominance</code></td>
<td>
<p>Logical parameter. If <code>TRUE</code>, adds primary columns for each
pair of parameters n,k in the dominance rules</p>
</td></tr>
<tr><td><code id="MagnitudeRule_+3A_outputweightednum">outputWeightedNum</code></td>
<td>
<p>logical value to determine whether weighted numerical
value should be included in output. Default is <code>TRUE</code> if <code>sWeightVar</code> is provided.</p>
</td></tr>
<tr><td><code id="MagnitudeRule_+3A_dominancevar">dominanceVar</code></td>
<td>
<p>When specified, <code>dominanceVar</code> is used in place of <code>numVar</code>.
Specifying <code>dominanceVar</code> is beneficial for avoiding warnings when there
are multiple <code>numVar</code> variables. Typically, <code>dominanceVar</code> will be one
of the variables already included in <code>numVar</code>.</p>
</td></tr>
<tr><td><code id="MagnitudeRule_+3A_...">...</code></td>
<td>
<p>unused parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method only supports suppressing a single numeric variable. There are
multiple ways of handling sampling weights in the dominance rule. the default
method implemented here compares unweighted sample values with the corresponding
weighted cell totals. if <code>domWeightMethod</code> is set to <code>"tauargus"</code>, the
method implemented in tauArgus is used. For more information on this
method, see &quot;Statistical Disclosure Control&quot; by Hundepool et al (2012,
p. 151).
</p>


<h3>Value</h3>

<p>logical vector that is <code>TRUE</code> in positions corresponding to cells
breaching the dominance rules.
</p>


<h3>Note</h3>

<p>Explicit  <code>protectZeros</code> in wrappers
since default needed by <code><a href="#topic+GaussSuppressionFromData">GaussSuppressionFromData</a></code>
</p>


<h3>Author(s)</h3>

<p>Daniel Lupp and Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  set.seed(123)
z &lt;- SSBtools::MakeMicro(SSBtoolsData("z2"), "ant")
z$value &lt;- sample(1:1000, nrow(z), replace = TRUE)

GaussSuppressionFromData(z, dimVar = c("region", "fylke", "kostragr", "hovedint"), 
numVar = "value", candidates = CandidatesNum, primary = DominanceRule, preAggregate = FALSE,
singletonMethod = "sub2Sum", n = c(1, 2), k = c(65, 85), allDominance = TRUE)


num &lt;- c(100,
         90, 10,
         80, 20,
         70, 30,
         50, 25, 25,
         40, 20, 20, 20,
         25, 25, 25, 25)
v1 &lt;- c("v1",
        rep(c("v2", "v3", "v4"), each = 2),
        rep("v5", 3),
        rep(c("v6", "v7"), each = 4))
sw &lt;- c(1, 2, 1, 2, 1, 2, 1, 2, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1)
d &lt;- data.frame(v1 = v1, num = num, sw = sw)

# without weights
GaussSuppressionFromData(d, formula = ~v1 - 1, 
 numVar = "num",  n = c(1,2), k = c(80,70),
  preAggregate = FALSE, allDominance = TRUE, candidates = CandidatesNum,
  primary = DominanceRule)

# with weights, standard method
GaussSuppressionFromData(d, formula = ~v1 - 1,
 numVar = "num",  n = c(1,2), k = c(80,70), sWeightVar = "sw",
 preAggregate = FALSE, allDominance = TRUE, candidates = CandidatesNum,
 primary = DominanceRule)

# with weights, tauargus method
GaussSuppressionFromData(d, formula = ~v1 - 1,
 numVar = "num",  n = c(1,2), k = c(80,70), sWeightVar = "sw",
 preAggregate = FALSE, allDominance = TRUE, candidates = CandidatesNum,
 primary = DominanceRule, domWeightMethod = "tauargus")

</code></pre>

<hr>
<h2 id='MaxContribution'>Find major contributions to aggregates</h2><span id='topic+MaxContribution'></span>

<h3>Description</h3>

<p>Assuming aggregates are calculated via a dummy matrix by
<code>z = t(x) %*% y</code>,
the <code>n</code> largest contributions are found (value or index) for each aggregate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MaxContribution(
  x,
  y,
  n = 1,
  decreasing = TRUE,
  index = FALSE,
  groups = NULL,
  return2 = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MaxContribution_+3A_x">x</code></td>
<td>
<p>A (sparse) dummy matrix</p>
</td></tr>
<tr><td><code id="MaxContribution_+3A_y">y</code></td>
<td>
<p>Vector of input values (contributors)</p>
</td></tr>
<tr><td><code id="MaxContribution_+3A_n">n</code></td>
<td>
<p>Number of contributors to be found</p>
</td></tr>
<tr><td><code id="MaxContribution_+3A_decreasing">decreasing</code></td>
<td>
<p>Ordering parameter. Smallest contributors found when <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="MaxContribution_+3A_index">index</code></td>
<td>
<p>Indices to <code>y</code> returned when TRUE</p>
</td></tr>
<tr><td><code id="MaxContribution_+3A_groups">groups</code></td>
<td>
<p>When non-NULL, major contributions after aggregation within groups.
Cannot be combined with <code>index = TRUE</code>.
The missing group category is excluded.</p>
</td></tr>
<tr><td><code id="MaxContribution_+3A_return2">return2</code></td>
<td>
<p>When <code>TRUE</code>, two matrices are returned, <code>value</code> and <code>id</code>.
The latter contains indices when <code>group</code> is <code>NULL</code> and otherwise a character matrix of groups.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix with lagest contributions in first column, second largest in second column and so on.
Alternative output when using parameters <code>index</code> or <code>return2</code>.
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>See Also</h3>

<p><code>ModelMatrix</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(SSBtools)

z &lt;- SSBtoolsData("sprt_emp_withEU")
z$age[z$age == "Y15-29"] &lt;- "young"
z$age[z$age == "Y30-64"] &lt;- "old"

a &lt;- ModelMatrix(z, formula = ~age + geo, crossTable = TRUE)

cbind(as.data.frame(a$crossTable), MaxContribution(a$modelMatrix, z$ths_per, 1))
cbind(a$crossTable, MaxContribution(a$modelMatrix, z$ths_per, 10))
cbind(a$crossTable, MaxContribution(a$modelMatrix, z$ths_per, 10, index = TRUE))

# Both types of output can be achieved with return2 = TRUE)
identical(MaxContribution(a$modelMatrix, z$ths_per, 10, return2 = TRUE),
          list(value =  MaxContribution(a$modelMatrix, z$ths_per, 10), 
               id =  MaxContribution(a$modelMatrix, z$ths_per, 10, index = TRUE)))

b &lt;- ModelMatrix(z[, -4], crossTable = TRUE, inputInOutput = c(TRUE, FALSE, TRUE))

k &lt;- cbind(b$crossTable, MaxContribution(b$modelMatrix, z$ths_per, 10))

gr18 &lt;- paste0("g", 1:18)                          # Each row is a group
k18 &lt;- cbind(b$crossTable, MaxContribution(b$modelMatrix, z$ths_per, 10, groups = gr18))
identical(k, k18) # TRUE

gr9 &lt;- paste0("g", as.integer(10 * z$ths_per)%%10) # 9 groups from decimal
k9 &lt;- cbind(b$crossTable, MaxContribution(b$modelMatrix, z$ths_per, 10, groups = gr9))

k18[c(4, 13, 17, 33), ]
k9[c(4, 13, 17, 33), ]

# Group info obtained with return2 = TRUE
k9_id &lt;- cbind(b$crossTable, MaxContribution(b$modelMatrix, z$ths_per, 10, groups = gr9, 
                                             return2 = TRUE)$id)
k9_id[c(4, 13, 17, 33), ]


# Verify similarity
z$y &lt;- z$ths_per + (1:nrow(z))/100  # to avoid equal values
id1 &lt;- MaxContribution(b$modelMatrix, z$y, 10, index = TRUE)
id1[!is.na(id1)] &lt;- paste0("g", id1[!is.na(id1)])
mc2 &lt;- MaxContribution(b$modelMatrix, z$y, 10, groups = gr18, return2 = TRUE)
id2 &lt;- mc2$id
identical(id1, id2)

</code></pre>

<hr>
<h2 id='Ncontributors'>Find the number of unique groups contributing to aggregates</h2><span id='topic+Ncontributors'></span>

<h3>Description</h3>

<p>Assuming aggregates are calculated via a dummy matrix by
<code>z = t(x) %*% y</code>, the the number of unique contributing groups,
according to a grouping variable, are found for each aggregate.
The missing group category is not counted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ncontributors(x, groups)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ncontributors_+3A_x">x</code></td>
<td>
<p>A (sparse) dummy matrix</p>
</td></tr>
<tr><td><code id="Ncontributors_+3A_groups">groups</code></td>
<td>
<p>Vector of group categories</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of numbers of unique groups
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>See Also</h3>

<p><code>ModelMatrix</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(SSBtools)

z &lt;- SSBtoolsData("sprt_emp_withEU")
z$age[z$age == "Y15-29"] &lt;- "young"
z$age[z$age == "Y30-64"] &lt;- "old"
z$groups &lt;- c("A", "A", "B", "A", "B", "C")

a &lt;- ModelMatrix(z, formula = ~age*eu + geo + year, crossTable = TRUE)

cbind(as.data.frame(a$crossTable), nGroups = Ncontributors(a$modelMatrix, z$groups))
cbind(as.data.frame(a$crossTable), nYears = Ncontributors(a$modelMatrix, z$year))
cbind(as.data.frame(a$crossTable), nUnique_ths_per = Ncontributors(a$modelMatrix, z$ths_per))

</code></pre>

<hr>
<h2 id='NcontributorsHolding'><code><a href="#topic+Ncontributors">Ncontributors</a></code> with holding-indicator</h2><span id='topic+NcontributorsHolding'></span>

<h3>Description</h3>

<p>The aggregates (columns of <code>x</code>) are grouped by a holding indicator.
Within each holding group, the number of unique groups (output) is set to be equal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NcontributorsHolding(x, groups, holdingInd = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NcontributorsHolding_+3A_x">x</code></td>
<td>
<p>A (sparse) dummy matrix</p>
</td></tr>
<tr><td><code id="NcontributorsHolding_+3A_groups">groups</code></td>
<td>
<p>Vector of group categories</p>
</td></tr>
<tr><td><code id="NcontributorsHolding_+3A_holdingind">holdingInd</code></td>
<td>
<p>Vector of holding group categories</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A representative within the holding group is used to calculate output by <code><a href="#topic+Ncontributors">Ncontributors</a></code>.
The one with maximal column sum of <code>x</code> is chosen as the representative.
Normally this will be an aggregate representing the holding group total.
When holdingInd is NULL (default), the function is equivalent to <code><a href="#topic+Ncontributors">Ncontributors</a></code>.
</p>


<h3>Value</h3>

<p>Vector of numbers of unique groups
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>

<hr>
<h2 id='NcontributorsRule'>Identical to ´NContributorsRule´</h2><span id='topic+NcontributorsRule'></span>

<h3>Description</h3>

<p>The function is included for compatibility after changing the name to
<code><a href="#topic+NContributorsRule">NContributorsRule</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NcontributorsRule(
  data,
  freq,
  numVar,
  x,
  maxN = 3,
  protectZeros = FALSE,
  charVar = NULL,
  removeCodes = character(0),
  remove0 = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NcontributorsRule_+3A_data">data</code></td>
<td>
<p>Input data as a data frame</p>
</td></tr>
<tr><td><code id="NcontributorsRule_+3A_freq">freq</code></td>
<td>
<p>Vector of aggregate frequencies</p>
</td></tr>
<tr><td><code id="NcontributorsRule_+3A_numvar">numVar</code></td>
<td>
<p>Numerical variables. When several variables, only first is used.</p>
</td></tr>
<tr><td><code id="NcontributorsRule_+3A_x">x</code></td>
<td>
<p>Model matrix generated by parent function</p>
</td></tr>
<tr><td><code id="NcontributorsRule_+3A_maxn">maxN</code></td>
<td>
<p>Primary suppression when number of contributors <code style="white-space: pre;">&#8288;&lt;= maxN&#8288;</code>.</p>
</td></tr>
<tr><td><code id="NcontributorsRule_+3A_protectzeros">protectZeros</code></td>
<td>
<p>Suppression parameter. Only TRUE (default) is used implemented.</p>
</td></tr>
<tr><td><code id="NcontributorsRule_+3A_charvar">charVar</code></td>
<td>
<p>Variable(s) with contributor codes.
When empty, unique contributor in each row is assumed.
When several variables, see details.</p>
</td></tr>
<tr><td><code id="NcontributorsRule_+3A_removecodes">removeCodes</code></td>
<td>
<p>Vector of codes to be omitted when counting contributors.
With empty <code>charVar</code> row indices are assumed
and conversion to integer is performed.</p>
</td></tr>
<tr><td><code id="NcontributorsRule_+3A_remove0">remove0</code></td>
<td>
<p>When set to <code>TRUE</code> (default), data rows in which the first <code>numVar</code> (if any) is zero
are excluded from the count of contributors.
Alternatively, <code>remove0</code> can be specified as one or more variable names.
In this case, all data rows with a zero in any of the specified variables
are omitted from the contributor count.
Specifying <code>remove0</code> as variable name(s) is useful for avoiding warning when there
are multiple <code>numVar</code> variables.</p>
</td></tr>
<tr><td><code id="NcontributorsRule_+3A_...">...</code></td>
<td>
<p>unused parameters</p>
</td></tr>
</table>

<hr>
<h2 id='NContributorsRule'>Number of contributors suppression rule</h2><span id='topic+NContributorsRule'></span>

<h3>Description</h3>

<p>The number of contributors is the number unique contributing 'charVar' codes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NContributorsRule(
  data,
  freq,
  numVar,
  x,
  maxN = 3,
  protectZeros = FALSE,
  charVar = NULL,
  removeCodes = character(0),
  remove0 = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NContributorsRule_+3A_data">data</code></td>
<td>
<p>Input data as a data frame</p>
</td></tr>
<tr><td><code id="NContributorsRule_+3A_freq">freq</code></td>
<td>
<p>Vector of aggregate frequencies</p>
</td></tr>
<tr><td><code id="NContributorsRule_+3A_numvar">numVar</code></td>
<td>
<p>Numerical variables. When several variables, only first is used.</p>
</td></tr>
<tr><td><code id="NContributorsRule_+3A_x">x</code></td>
<td>
<p>Model matrix generated by parent function</p>
</td></tr>
<tr><td><code id="NContributorsRule_+3A_maxn">maxN</code></td>
<td>
<p>Primary suppression when number of contributors <code style="white-space: pre;">&#8288;&lt;= maxN&#8288;</code>.</p>
</td></tr>
<tr><td><code id="NContributorsRule_+3A_protectzeros">protectZeros</code></td>
<td>
<p>Suppression parameter. Only TRUE (default) is used implemented.</p>
</td></tr>
<tr><td><code id="NContributorsRule_+3A_charvar">charVar</code></td>
<td>
<p>Variable(s) with contributor codes.
When empty, unique contributor in each row is assumed.
When several variables, see details.</p>
</td></tr>
<tr><td><code id="NContributorsRule_+3A_removecodes">removeCodes</code></td>
<td>
<p>Vector of codes to be omitted when counting contributors.
With empty <code>charVar</code> row indices are assumed
and conversion to integer is performed.</p>
</td></tr>
<tr><td><code id="NContributorsRule_+3A_remove0">remove0</code></td>
<td>
<p>When set to <code>TRUE</code> (default), data rows in which the first <code>numVar</code> (if any) is zero
are excluded from the count of contributors.
Alternatively, <code>remove0</code> can be specified as one or more variable names.
In this case, all data rows with a zero in any of the specified variables
are omitted from the contributor count.
Specifying <code>remove0</code> as variable name(s) is useful for avoiding warning when there
are multiple <code>numVar</code> variables.</p>
</td></tr>
<tr><td><code id="NContributorsRule_+3A_...">...</code></td>
<td>
<p>unused parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When several <code>charVar</code> variables, the rule is applied independently to each variable.
Primary suppression in at least one case results in  primary suppression in the output.
It is possible to specify <code>maxN</code> and <code>removeCodes</code> independently for each <code>charVar</code> by using a
named list as input with <code>charVar</code> as names. E.g. <code>maxN = list(char1 = 3, char2 = 2)</code>.
</p>


<h3>Value</h3>

<p>List where first element is logical vector defining primary suppressions.
The second element is data frame where <code>nRule</code> is number contributors used
in rule and where <code>nAll</code> is similar, but without omitting codes in <code>removeCodes</code>.
</p>

<hr>
<h2 id='PackageSpecs'>Function for viewing built-in GaussSuppression specs</h2><span id='topic+PackageSpecs'></span>

<h3>Description</h3>

<p>Functions to retrieve the built-in specs. These can be retrieved using either
numerical indices or by specifying the spec name, see Details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PackageSpecs(x = NULL, printTable = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PackageSpecs_+3A_x">x</code></td>
<td>
<p>the character name or index of the spec to be returned. If <code>NULL</code> (default),
returns list of all specs</p>
</td></tr>
<tr><td><code id="PackageSpecs_+3A_printtable">printTable</code></td>
<td>
<p>Logical value (default <code>FALSE</code>). If <code>TRUE</code>, prints a table
description of all specs. Primarily used for documentation purposes.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following table summarizes the built-in specs. Columns represent
different specs, and rows represent the parameter settings.</p>

<table>
<tr>
 <td style="text-align: left;">
    </td><td style="text-align: left;"> <strong>smallCountSpec</strong> </td><td style="text-align: left;"> <strong>dominanceSpec</strong> </td><td style="text-align: left;"> <strong>fewContributorsSpec</strong> </td><td style="text-align: left;"> <strong>kDisclosureSpec</strong> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>primary</strong> </td><td style="text-align: left;"> PrimaryDefault </td><td style="text-align: left;"> DominanceRule </td><td style="text-align: left;"> NContributorsRule </td><td style="text-align: left;"> KDisclosurePrimary </td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>protectZeros</strong> </td><td style="text-align: left;"> TRUE </td><td style="text-align: left;"> FALSE </td><td style="text-align: left;"> FALSE </td><td style="text-align: left;"> FALSE </td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>candidates</strong> </td><td style="text-align: left;"> CandidatesDefault </td><td style="text-align: left;"> CandidatesNum </td><td style="text-align: left;"> CandidatesNum </td><td style="text-align: left;"> DirectDisclosureCandidates </td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>singleton</strong> </td><td style="text-align: left;"> SingletonDefault </td><td style="text-align: left;"> SingletonUniqueContributor </td><td style="text-align: left;"> SingletonUniqueContributor </td><td style="text-align: left;"> SingletonDefault </td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>extend0</strong> </td><td style="text-align: left;"> TRUE </td><td style="text-align: left;"> FALSE </td><td style="text-align: left;"> FALSE </td><td style="text-align: left;"> TRUE </td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>preAggregate</strong> </td><td style="text-align: left;"> is.null(freqVar) </td><td style="text-align: left;"> !is.null(charVar) </td><td style="text-align: left;"> !is.null(charVar) </td><td style="text-align: left;"> is.null(freqVar) </td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>extraAggregate</strong> </td><td style="text-align: left;"> FALSE </td><td style="text-align: left;"> TRUE </td><td style="text-align: left;"> TRUE </td><td style="text-align: left;"> FALSE </td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>secondaryZeros</strong> </td><td style="text-align: left;"> FALSE </td><td style="text-align: left;"> FALSE </td><td style="text-align: left;"> FALSE </td><td style="text-align: left;"> 1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>domWeightMethod</strong> </td><td style="text-align: left;">  </td><td style="text-align: left;"> "default" </td><td style="text-align: left;">  </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   <strong>singletonMethod</strong> </td><td style="text-align: left;">  </td><td style="text-align: left;"> "numttHTT" </td><td style="text-align: left;"> "numttHTT" </td><td style="text-align: left;"> "anySumNOTprimary" </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>returns a spec (if <code>!is.null(x)</code>), list of all specs (if <code>is.null(x)</code>
and <code>printTable = FALSE</code>), or markdown table describing all specs (if <code>printTable = TRUE</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>PackageSpecs()
PackageSpecs(1)
PackageSpecs("smallCountSpec")
PackageSpecs(printTable = TRUE)
</code></pre>

<hr>
<h2 id='PrimaryDefault'>Default primary function</h2><span id='topic+PrimaryDefault'></span>

<h3>Description</h3>

<p>Function for <code><a href="#topic+GaussSuppressionFromData">GaussSuppressionFromData</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PrimaryDefault(freq, maxN = 3, protectZeros = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PrimaryDefault_+3A_freq">freq</code></td>
<td>
<p>Vector of output frequencies</p>
</td></tr>
<tr><td><code id="PrimaryDefault_+3A_maxn">maxN</code></td>
<td>
<p>Cells with frequency <code style="white-space: pre;">&#8288;&lt;= maxN&#8288;</code> are set as primary suppressed.</p>
</td></tr>
<tr><td><code id="PrimaryDefault_+3A_protectzeros">protectZeros</code></td>
<td>
<p>When <code>TRUE</code>, cells with zero frequency are set as primary suppressed.</p>
</td></tr>
<tr><td><code id="PrimaryDefault_+3A_...">...</code></td>
<td>
<p>Unused parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>primary, <code><a href="#topic+GaussSuppression">GaussSuppression</a></code> input
</p>

<hr>
<h2 id='PrimaryFromRiskyDefault'>Additional primary cells based on risky primary cells</h2><span id='topic+PrimaryFromRiskyDefault'></span>

<h3>Description</h3>

<p>The algorithm uses parent-child relationships found from the model matrix (<code>x</code>)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PrimaryFromRiskyDefault(x, y, risky, candidates, allDims = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PrimaryFromRiskyDefault_+3A_x">x</code></td>
<td>
<p>The model matrix</p>
</td></tr>
<tr><td><code id="PrimaryFromRiskyDefault_+3A_y">y</code></td>
<td>
<p>A vector of numeric values with a length equal to <code>nrow(x)</code></p>
</td></tr>
<tr><td><code id="PrimaryFromRiskyDefault_+3A_risky">risky</code></td>
<td>
<p>Indices to columns in <code>x</code> corresponding to primary cells classified
as risky (interval limits not reached)</p>
</td></tr>
<tr><td><code id="PrimaryFromRiskyDefault_+3A_candidates">candidates</code></td>
<td>
<p>Indices to columns in <code>x</code> that are candidates for becoming
additional primary cells. Higher order cells must be included
so that parent-child relationships are seen.</p>
</td></tr>
<tr><td><code id="PrimaryFromRiskyDefault_+3A_alldims">allDims</code></td>
<td>
<p>When TRUE, a primary cell is added for each dimension.
can be specified as a vector of length  <code>length(risky)</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a single <code>risky</code> cell,  the algorithm can be formulated as:
</p>

<ul>
<li><p> Consider this cell as a <code>child</code> and identify all <code>parents</code> that are present in <code>candidates</code>.
</p>
</li>
<li><p> Remove parents who are also parents of other parents (i.e., eliminate higher-level parents).
</p>
</li>
<li><p> Identify the children of these remaining parents that are included in <code>candidates</code>.
</p>
</li>
<li><p> Select the child that has the smallest value in the numeric variable (<code>y</code>).
</p>
</li></ul>

<p>For several <code>risky</code> cells, coordination takes place. See the comment below the examples.
</p>


<h3>Value</h3>

<p>Additional primary cells as indices to columns in <code>x</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example inspired by suppression with maxN = 5
d1 &lt;- SSBtoolsData("d1")
mm &lt;- SSBtools::ModelMatrix(d1, dimVar = 1:2, crossTable = TRUE)
x &lt;- mm$modelMatrix
y &lt;- t(x) %*% d1$freq

risky &lt;- c(13, 15, 40, 45)
candidates &lt;- c(1:12, 14, 16, 17, 19, 21, 21, 24, 26:37, 39, 42, 44)

info &lt;- rep("", length(y))
info[risky ] &lt;- "risky"
info[candidates] &lt;- "c"
cbind(mm$crossTable, y=as.vector(y), info)

PrimaryFromRiskyDefault(x = x, y = y, risky = risky, candidates = candidates)
PrimaryFromRiskyDefault(x = x, y = y, risky = 40, candidates = candidates)

# The last solution (39) is not included in the first (28, 35). 
# This is because 39 is not needed when 35 is already included.

</code></pre>

<hr>
<h2 id='PrimaryFromSuppressedData'><code>primary</code> and <code>forced</code> from suppressed data</h2><span id='topic+PrimaryFromSuppressedData'></span><span id='topic+ForcedFromSuppressedData'></span><span id='topic+NotPrimaryFromSuppressedData'></span>

<h3>Description</h3>

<p>Function for <code><a href="#topic+GaussSuppressionFromData">GaussSuppressionFromData</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PrimaryFromSuppressedData(
  x,
  crossTable,
  suppressedData,
  forcedData = FALSE,
  totCode = FindTotCode2(x, crossTable),
  ...
)

ForcedFromSuppressedData(..., forcedData = TRUE)

NotPrimaryFromSuppressedData(..., forcedData = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PrimaryFromSuppressedData_+3A_x">x</code></td>
<td>
<p>A (sparse) dummy matrix</p>
</td></tr>
<tr><td><code id="PrimaryFromSuppressedData_+3A_crosstable">crossTable</code></td>
<td>
<p>crossTable generated by parent function</p>
</td></tr>
<tr><td><code id="PrimaryFromSuppressedData_+3A_suppresseddata">suppressedData</code></td>
<td>
<p>A data frame or a list of data frames as output from <code><a href="#topic+GaussSuppressionFromData">GaussSuppressionFromData</a></code>.
If the variable <code>suppressed</code> is not included, all rows are considered suppressed.</p>
</td></tr>
<tr><td><code id="PrimaryFromSuppressedData_+3A_forceddata">forcedData</code></td>
<td>
<p>When <code>TRUE</code>, the suppressed coding is swapped.</p>
</td></tr>
<tr><td><code id="PrimaryFromSuppressedData_+3A_totcode">totCode</code></td>
<td>
<p>A named list of totals codes</p>
</td></tr>
<tr><td><code id="PrimaryFromSuppressedData_+3A_...">...</code></td>
<td>
<p>Unused parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ForcedFromSuppressedData</code>  uses <code>forcedData = TRUE</code> and hence a  vector to be use as forced is generated.
<code>NotPrimaryFromSuppressedData</code> is similar, but <code>TRUE</code> elements are replaced by <code>NA</code>'s.
Hence the result can be used as an extra primary vector to ensure that code combinations
not suppressed according to <code>suppressedData</code> are forced not to be primary suppressed.
</p>
<p>The variables used in <code>suppressedData</code> in addition to <code>"suppressed"</code> are those with matching names in <code>crossTable</code>. Others are ignored.
For variables in <code>crossTable</code> not in <code>suppressedData</code>, only totals are considered.
Others rows are ignored when mathing with <code>suppressedData</code>.
</p>
<p>When suppressedData is a list, the final result is the union of individual results of each data frame.
</p>


<h3>Value</h3>

<p>Logical vector to be used as <code><a href="#topic+GaussSuppression">GaussSuppression</a></code> input
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
z2 &lt;- SSBtoolsData("z2")

# Data to be used as suppressedData
a &lt;- GaussSuppressionFromData(z2, c(1, 3, 4), 5, protectZeros = FALSE)

# For alternative ways to suppress the same table
b1 &lt;- GaussSuppressionFromData(z2, 1:4, 5)
b2 &lt;- GaussSuppressionFromData(z2, 1:4, 5, primary = c(PrimaryDefault, PrimaryFromSuppressedData),
                               suppressedData = a)
b3 &lt;- GaussSuppressionFromData(z2, 1:4, 5, primary = c(PrimaryDefault, PrimaryFromSuppressedData),
                               suppressedData = a, forced = ForcedFromSuppressedData)
b4 &lt;- GaussSuppressionFromData(z2, 1:4, 5, 
             primary = c(PrimaryDefault, PrimaryFromSuppressedData, NotPrimaryFromSuppressedData),
                               suppressedData = a, forced = ForcedFromSuppressedData)

# Reducing data to rows mathing a
b1r &lt;- b1[SSBtools::Match(a[1:2], b1[1:2]), ]
b2r &lt;- b2[SSBtools::Match(a[1:2], b2[1:2]), ]
b3r &lt;- b3[SSBtools::Match(a[1:2], b3[1:2]), ]
b4r &lt;- b4[SSBtools::Match(a[1:2], b4[1:2]), ]


# Look at rows where new suppression is different from that in a  

# Both TRUE and FALSE changed
cbind(a, b1r)[b1r$suppressed != a$suppressed, c(1:5, 9:10)]

# Only  FALSE changed to TRUE (suppression is preserved)
cbind(a, b2r)[b2r$suppressed != a$suppressed, c(1:5, 9:10)]

# Only change is due to new primary suppression rule (protectZeros = TRUE) 
cbind(a, b3r)[b3r$suppressed != a$suppressed, c(1:5, 9:10)]

# No changes 
cbind(a, b4r)[b4r$suppressed != a$suppressed, c(1:5, 9:10)]


</code></pre>

<hr>
<h2 id='PrimaryRemoveWg'>Special functions for the avoidance of suppression</h2><span id='topic+PrimaryRemoveWg'></span><span id='topic+CandidatesNumWg'></span><span id='topic+ForcedWg'></span>

<h3>Description</h3>

<p>The SSBtools function <code>WildcardGlobbing</code> is utilized
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PrimaryRemoveWg(wg = NULL, ..., crossTable)

CandidatesNumWg(wg = NULL, ..., crossTable)

ForcedWg(crossTable, wg = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PrimaryRemoveWg_+3A_wg">wg</code></td>
<td>
<p>data.frame with wildcard/globbing.
A parameter to <code>WildcardGlobbing</code></p>
</td></tr>
<tr><td><code id="PrimaryRemoveWg_+3A_...">...</code></td>
<td>
<p>unused parameters</p>
</td></tr>
<tr><td><code id="PrimaryRemoveWg_+3A_crosstable">crossTable</code></td>
<td>
<p>crossTable generated by parent function</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>CandidatesNumWg</code> is a generalization of <code><a href="#topic+CandidatesNumWg">CandidatesNumWg</a></code>
</p>


<h3>Value</h3>

<p>logical vector or row indices
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dataset &lt;- SSBtoolsData("magnitude1")

a1 &lt;- SuppressDominantCells(data = dataset, numVar = "value", 
       dimVar = c("sector4", "geo"), n = 1:2, k = c(77, 99))

a1

wg &lt;- data.frame(sector4 = "Ind*", geo = c("Ice????", "Portugal"))
wg

# Industry:Portugal not primary, but suppressed
a2 &lt;- SuppressDominantCells(data = dataset, numVar = "value", 
       dimVar = c("sector4", "geo"), n = 1:2, k = c(77, 99), 
       wg = wg, primary = c(DominanceRule, PrimaryRemoveWg))

a2

# Industry:Portugal not primary and not suppressed
a3 &lt;- SuppressDominantCells(data = dataset, numVar = "value", 
       dimVar = c("sector4", "geo"), n = 1:2, k = c(77, 99), 
       wg = wg, primary = c(DominanceRule, PrimaryRemoveWg), 
       candidates = CandidatesNumWg)
a3

# Industry:Portugal primary, but not suppressed
a4 &lt;- SuppressDominantCells(data = dataset, numVar = "value", 
       dimVar = c("sector4", "geo"), n = 1:2, k = c(77, 99), 
       wg = wg, forced = ForcedWg, whenPrimaryForced = message)
a4
</code></pre>

<hr>
<h2 id='RangeLimitsDefault'>Default range limit function</h2><span id='topic+RangeLimitsDefault'></span>

<h3>Description</h3>

<p>Preliminary function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RangeLimitsDefault(
  ...,
  rangePercent = 0,
  rangeMin = 0,
  primary,
  num,
  freq,
  freqVar,
  dominanceVar = NULL,
  intervalVar = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RangeLimitsDefault_+3A_...">...</code></td>
<td>
<p>Unused parameters</p>
</td></tr>
<tr><td><code id="RangeLimitsDefault_+3A_rangepercent">rangePercent</code></td>
<td>
<p>Required interval width expressed as a percentage</p>
</td></tr>
<tr><td><code id="RangeLimitsDefault_+3A_rangemin">rangeMin</code></td>
<td>
<p>Minimum required width of the interval</p>
</td></tr>
<tr><td><code id="RangeLimitsDefault_+3A_primary">primary</code></td>
<td>
<p>primary</p>
</td></tr>
<tr><td><code id="RangeLimitsDefault_+3A_num">num</code></td>
<td>
<p>num</p>
</td></tr>
<tr><td><code id="RangeLimitsDefault_+3A_freq">freq</code></td>
<td>
<p>freq</p>
</td></tr>
<tr><td><code id="RangeLimitsDefault_+3A_freqvar">freqVar</code></td>
<td>
<p>freqVar</p>
</td></tr>
<tr><td><code id="RangeLimitsDefault_+3A_dominancevar">dominanceVar</code></td>
<td>
<p>dominanceVar</p>
</td></tr>
<tr><td><code id="RangeLimitsDefault_+3A_intervalvar">intervalVar</code></td>
<td>
<p>Numerical variable(s) for interval calculations.
When <code>NULL</code>, <code>dominanceVar</code>, first <code>numVar</code> or <code>freqVar</code> will be used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with named columns
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- SSBtoolsData("magnitude1")
dat["num2"] &lt;- 1:nrow(dat)

SuppressDominantCells(data = dat, 
    numVar = "value", 
    formula = ~sector2 * geo + sector4 * eu, 
    contributorVar = "company", 
    n = 1:2, k = c(80, 99), 
    output = RangeOutputFunction, rangePercent = 10, rangeMin = 1)

SuppressDominantCells(data = dat, 
    numVar = c("value", "num2"), 
    formula = ~sector2 * geo + sector4 * eu, 
    contributorVar = "company", 
    n = 1:2, k = c(80, 99), 
    output = RangeOutputFunction, 
    intervalVar = c("value","freq", "num2"), 
    rangePercent = c(10, 10, 30), rangeMin = c(1, 0.2222, 2.222))

</code></pre>

<hr>
<h2 id='RangeOutputFunction'>Function used in RangeLimitsDefault example</h2><span id='topic+RangeOutputFunction'></span>

<h3>Description</h3>

<p>Function used in RangeLimitsDefault example
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RangeOutputFunction(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RangeOutputFunction_+3A_...">...</code></td>
<td>
<p>parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Aggregated data with suppression information
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+GaussSuppression'></span><span id='topic+SSBtoolsData'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>SSBtools</dt><dd><p><code><a href="SSBtools.html#topic+GaussSuppression">GaussSuppression</a></code>, <code><a href="SSBtools.html#topic+SSBtoolsData">SSBtoolsData</a></code></p>
</dd>
</dl>

<hr>
<h2 id='SingletonDefault'>Default singleton function</h2><span id='topic+SingletonDefault'></span>

<h3>Description</h3>

<p>Function for <code><a href="#topic+GaussSuppressionFromData">GaussSuppressionFromData</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SingletonDefault(data, freqVar, protectZeros, secondaryZeros, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SingletonDefault_+3A_data">data</code></td>
<td>
<p>Input data, possibly pre-aggregated within <code>GaussSuppressionFromData</code></p>
</td></tr>
<tr><td><code id="SingletonDefault_+3A_freqvar">freqVar</code></td>
<td>
<p>A single variable holding counts (input to <code>GaussSuppressionFromData</code>)</p>
</td></tr>
<tr><td><code id="SingletonDefault_+3A_protectzeros">protectZeros</code></td>
<td>
<p>Suppression parameter (see <code>GaussSuppressionFromData</code>)</p>
</td></tr>
<tr><td><code id="SingletonDefault_+3A_secondaryzeros">secondaryZeros</code></td>
<td>
<p>Suppression parameter (see <code>GaussSuppressionFromData</code>)</p>
</td></tr>
<tr><td><code id="SingletonDefault_+3A_...">...</code></td>
<td>
<p>Unused parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function marks input cells as singletons according to the input frequencies (<code>freqVar</code>).
Zero frequencies are set to singletons when <code>protectZeros</code> or <code>secondaryZeros</code> is <code>TRUE</code>.
Otherwise, ones are set to singletons.
Empty <code>freqVar</code> is treated as all frequencies being ones.
</p>


<h3>Value</h3>

<p>singleton, <code><a href="#topic+GaussSuppression">GaussSuppression</a></code> input
</p>

<hr>
<h2 id='SingletonUniqueContributor'>Unique contributor singleton function</h2><span id='topic+SingletonUniqueContributor'></span><span id='topic+SingletonUniqueContributor0'></span>

<h3>Description</h3>

<p>Function for <code><a href="#topic+GaussSuppressionFromData">GaussSuppressionFromData</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SingletonUniqueContributor(
  data,
  freqVar = NULL,
  nUniqueVar = NULL,
  charVar = NULL,
  removeCodes = character(0),
  integerSingleton = length(charVar) &gt; 0,
  x,
  primary = integer(0),
  whenPrimaryMatters = warning,
  whenNoVar = TRUE,
  specialMultiple = TRUE,
  ...
)

SingletonUniqueContributor0(data, numVar, dominanceVar = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SingletonUniqueContributor_+3A_data">data</code></td>
<td>
<p>Input data, possibly pre-aggregated within <code>GaussSuppressionFromData</code></p>
</td></tr>
<tr><td><code id="SingletonUniqueContributor_+3A_freqvar">freqVar</code></td>
<td>
<p>A single variable holding counts (input to <code>GaussSuppressionFromData</code>)</p>
</td></tr>
<tr><td><code id="SingletonUniqueContributor_+3A_nuniquevar">nUniqueVar</code></td>
<td>
<p>A single variable holding the number of unique contributors.</p>
</td></tr>
<tr><td><code id="SingletonUniqueContributor_+3A_charvar">charVar</code></td>
<td>
<p>Variable with contributor codes.</p>
</td></tr>
<tr><td><code id="SingletonUniqueContributor_+3A_removecodes">removeCodes</code></td>
<td>
<p>Vector, list or data frame of codes considered non-singletons.
Single element lists and single column data frames behave just like vectors.
In other cases, <code>charVar</code>-names must be used.
With empty <code>charVar</code> a vector of row indices is assumed and conversion to integer is performed.
See examples.</p>
</td></tr>
<tr><td><code id="SingletonUniqueContributor_+3A_integersingleton">integerSingleton</code></td>
<td>
<p>Integer output when <code>TRUE</code>. See details.</p>
</td></tr>
<tr><td><code id="SingletonUniqueContributor_+3A_x">x</code></td>
<td>
<p>ModelMatrix generated by parent function</p>
</td></tr>
<tr><td><code id="SingletonUniqueContributor_+3A_primary">primary</code></td>
<td>
<p>Vector (integer or logical) specifying primary suppressed cells.
It will be ensured that any non-suppressed inner cell is not considered a singleton.</p>
</td></tr>
<tr><td><code id="SingletonUniqueContributor_+3A_whenprimarymatters">whenPrimaryMatters</code></td>
<td>
<p>Function to be called when <code>primary</code> caused non-singleton. Supply <code>NULL</code> to do nothing.</p>
</td></tr>
<tr><td><code id="SingletonUniqueContributor_+3A_whennovar">whenNoVar</code></td>
<td>
<p>When <code>TRUE</code>, and without <code>nUniqueVar</code> and <code>freqVar</code> in input,
all cells will be marked as singletons.</p>
</td></tr>
<tr><td><code id="SingletonUniqueContributor_+3A_specialmultiple">specialMultiple</code></td>
<td>
<p>When <code>TRUE</code>, and when <code style="white-space: pre;">&#8288;integerSingleton &amp;&#8288;</code> <code>length(charVar) &gt; 1</code> <code style="white-space: pre;">&#8288;&amp; length(nUniqueVar)&#8288;</code>,
a special method is used.
By re-coding to single <code>charVar</code> and by re-calculating <code>nUnique</code>.
To be unique (<code>nUnique=1</code>), uniqueness is only required for a single <code>charvar</code>.
Otherwise, the <code>charvar</code> combination must be unique.</p>
</td></tr>
<tr><td><code id="SingletonUniqueContributor_+3A_...">...</code></td>
<td>
<p>Unused parameters</p>
</td></tr>
<tr><td><code id="SingletonUniqueContributor_+3A_numvar">numVar</code></td>
<td>
<p>vector containing numeric values in the data set</p>
</td></tr>
<tr><td><code id="SingletonUniqueContributor_+3A_dominancevar">dominanceVar</code></td>
<td>
<p>When specified, <code>dominanceVar</code> is used in place of <code>numVar</code>.
Specifying <code>dominanceVar</code> is beneficial for avoiding warnings when there
are multiple <code>numVar</code> variables. Typically, <code>dominanceVar</code> will be one
of the variables already included in <code>numVar</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function marks input cells as singletons according to ones in
<code>data[[nUniqueVar]]</code>, if available, and otherwise according to <code>data[[freqVar]]</code>.
The output vector can be logical or integer. When, integer, singletons are given as positive values.
Their unique values represent the unique values/combinations of <code>data[[charVar]]</code>.
</p>


<h3>Value</h3>

<p>logical or integer vector
</p>


<h3>Note</h3>

<p><code>SingletonUniqueContributor0</code> is a special version that produces singleton as
a two-element list.
See <code><a href="#topic+GaussSuppression">GaussSuppression</a></code> and <code><a href="#topic+SuppressDominantCells">SuppressDominantCells</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>S &lt;- function(data, ...) {
  cbind(data, singleton = SingletonUniqueContributor(data, ...))
}
d2 &lt;- SSBtoolsData("d2")
d &lt;- d2[d2$freq &lt; 5, ]
d$nUnique &lt;- round((5 - d$freq)/3)
d$freq &lt;- round(d$freq/2)
d[7:8, 2:4] &lt;- NA
rownames(d) &lt;- NULL

S(d, freqVar = "freq", integerSingleton = FALSE)
S(d, freqVar = "freq", nUniqueVar = "nUnique", integerSingleton = TRUE, charVar = "main_income")
S(d, nUniqueVar = "nUnique", integerSingleton = TRUE, charVar = c("main_income", "k_group"))
S(d, freqVar = "freq", nUniqueVar = "nUnique", integerSingleton = FALSE, 
  charVar = "main_income", removeCodes = "other")
S(d, nUniqueVar = "nUnique", integerSingleton = FALSE, charVar = c("main_income", "k_group"), 
  removeCodes = c("other", "400"))
S(d, nUniqueVar = "nUnique", integerSingleton = FALSE, charVar = c("main_income", "k_group"), 
  removeCodes = data.frame(anyname = c("other", "400")))
S(d, nUniqueVar = "nUnique", integerSingleton = FALSE, charVar = c("main_income", "k_group"), 
  removeCodes = list(main_income = c("other", "pensions"), k_group = "300"))
S(d, nUniqueVar = "nUnique", integerSingleton = FALSE, charVar = c("main_income", "k_group"), 
  removeCodes = data.frame(main_income = "other", k_group = "400"))
S(d, nUniqueVar = "nUnique", integerSingleton = FALSE, removeCodes = 1:5)

x &lt;- SSBtools::ModelMatrix(d, hierarchies = list(region = "Total"))
which(colSums(x) == 1)
which(rowSums(x[, colSums(x) == 1]) &gt; 0)
# columns 2, 3, 4, 5, 7 correspond to inner cells: rows 3, 4, 5, 6, 8 
# with 2:4 not primary rows 3:5 are forced non-singleton
S(d, freqVar = "freq", nUniqueVar = "nUnique", integerSingleton = FALSE, x = x, primary = 5:8)

</code></pre>

<hr>
<h2 id='SuppressDirectDisclosure'>Suppression of directly-disclosive cells</h2><span id='topic+SuppressDirectDisclosure'></span>

<h3>Description</h3>

<p>Function for suppressing directly-disclosive cells in frequency tables. The method
detects and primary suppresses directly-disclosive cells with the
<a href="SSBtools.html#topic+FindDisclosiveCells">FindDisclosiveCells</a> function, and applies a secondary suppression
using Gauss suppression (see <a href="#topic+GaussSuppressionFromData">GaussSuppressionFromData</a>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SuppressDirectDisclosure(
  data,
  dimVar,
  freqVar,
  coalition = 1,
  secondaryZeros = coalition,
  candidates = DirectDisclosureCandidates,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SuppressDirectDisclosure_+3A_data">data</code></td>
<td>
<p>the input data</p>
</td></tr>
<tr><td><code id="SuppressDirectDisclosure_+3A_dimvar">dimVar</code></td>
<td>
<p>main dimensional variables for the output table</p>
</td></tr>
<tr><td><code id="SuppressDirectDisclosure_+3A_freqvar">freqVar</code></td>
<td>
<p>variable containing frequency counts</p>
</td></tr>
<tr><td><code id="SuppressDirectDisclosure_+3A_coalition">coalition</code></td>
<td>
<p>numeric variable, parameter for primary suppression. Default value is 1.</p>
</td></tr>
<tr><td><code id="SuppressDirectDisclosure_+3A_secondaryzeros">secondaryZeros</code></td>
<td>
<p>logical or numeric value for secondary suppression. If logical, it is converted to resp numeric value (0 or 1). If numeric, it describes the largest number that is prioritized over zeroes in secondary suppression. Default value is equal to coalition.</p>
</td></tr>
<tr><td><code id="SuppressDirectDisclosure_+3A_candidates">candidates</code></td>
<td>
<p>function parameter for gauss suppression.</p>
</td></tr>
<tr><td><code id="SuppressDirectDisclosure_+3A_...">...</code></td>
<td>
<p>optional parameters that can be passed to the primary suppression
method. See <a href="SSBtools.html#topic+FindDisclosiveCells">FindDisclosiveCells</a> for details.
In the case of SuppressDirectDisclosure2, <code>...</code> are parameters to GaussSuppressionFromData.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>SuppressDirectDisclosure has no support for hierarchical data.
SuppressDirectDisclosure2 has, but is less general in other ways.
</p>


<h3>Value</h3>

<p>data.frame containing the result of the suppression
</p>


<h3>Author(s)</h3>

<p>Daniel Lupp
</p>


<h3>Examples</h3>

<pre><code class='language-R'>tex &lt;- data.frame(v1 = rep(c('a', 'b', 'c'), times = 4),
                  v2 = c('i','i', 'i','h','h','h','i','i','i','h','h','h'),
                  v3 = c('y', 'y', 'y', 'y', 'y', 'y','z','z', 'z', 'z', 'z', 'z'),
                  freq = c(0,0,5,0,2,3,1,0,3,1,1,2))
SuppressDirectDisclosure(tex, c("v1", "v2", "v3"), "freq")
SuppressDirectDisclosure(tex, c("v1", "v2", "v3"), "freq", coalition = 2, unknown.threshold = 10)

z3 &lt;- SSBtools::SSBtoolsData("z3")
a1 &lt;- SuppressDirectDisclosure(z3, c(1, 4, 5), 7)
b1 &lt;- try(SuppressDirectDisclosure(z3, 1:6, 7))

</code></pre>

<hr>
<h2 id='SuppressDominantCells'>Suppress volume tables using dominant cell primary suppression.</h2><span id='topic+SuppressDominantCells'></span>

<h3>Description</h3>

<p>Suppress volume tables using dominant cell primary suppression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SuppressDominantCells(
  data,
  n,
  k,
  allDominance = FALSE,
  dominanceVar = NULL,
  numVar = NULL,
  dimVar = NULL,
  hierarchies = NULL,
  formula = NULL,
  contributorVar = NULL,
  sWeightVar = NULL,
  ...,
  candidatesVar = NULL,
  singletonZeros = FALSE,
  spec = PackageSpecs("dominanceSpec")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SuppressDominantCells_+3A_data">data</code></td>
<td>
<p>Input data as a data frame</p>
</td></tr>
<tr><td><code id="SuppressDominantCells_+3A_n">n</code></td>
<td>
<p>parameter <code>n</code> in dominance rule.</p>
</td></tr>
<tr><td><code id="SuppressDominantCells_+3A_k">k</code></td>
<td>
<p>parameter <code>k</code> in dominance rule.</p>
</td></tr>
<tr><td><code id="SuppressDominantCells_+3A_alldominance">allDominance</code></td>
<td>
<p>Logical parameter. If <code>TRUE</code>, adds primary columns for each
pair of parameters n,k in the dominance rules</p>
</td></tr>
<tr><td><code id="SuppressDominantCells_+3A_dominancevar">dominanceVar</code></td>
<td>
<p>Numerical variable to be used in dominance rule.
The first <code>numVar</code> variable will be used if it is not specified.</p>
</td></tr>
<tr><td><code id="SuppressDominantCells_+3A_numvar">numVar</code></td>
<td>
<p>Numerical variable to be aggregated.
Any <code>dominanceVar</code> and <code>candidatesVar</code> that are specified and
not included in <code>numVar</code> will be aggregated accordingly.</p>
</td></tr>
<tr><td><code id="SuppressDominantCells_+3A_dimvar">dimVar</code></td>
<td>
<p>The main dimensional variables and additional aggregating variables. This parameter can be  useful when hierarchies and formula are unspecified.</p>
</td></tr>
<tr><td><code id="SuppressDominantCells_+3A_hierarchies">hierarchies</code></td>
<td>
<p>List of hierarchies, which can be converted by <code>AutoHierarchies</code>.
Thus, the variables can also be coded by <code>"rowFactor"</code> or <code>""</code>, which correspond to using the categories in the data.</p>
</td></tr>
<tr><td><code id="SuppressDominantCells_+3A_formula">formula</code></td>
<td>
<p>A model formula</p>
</td></tr>
<tr><td><code id="SuppressDominantCells_+3A_contributorvar">contributorVar</code></td>
<td>
<p>Extra variables to be used as grouping elements in the dominance rule.
Typically, the variable contains the contributor IDs.</p>
</td></tr>
<tr><td><code id="SuppressDominantCells_+3A_sweightvar">sWeightVar</code></td>
<td>
<p>Name of variable which represents sampling weights to be used
in dominance rule</p>
</td></tr>
<tr><td><code id="SuppressDominantCells_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the supplied functions and to <code>ModelMatrix</code> (such as <code>inputInOutput</code> and <code>removeEmpty</code>).</p>
</td></tr>
<tr><td><code id="SuppressDominantCells_+3A_candidatesvar">candidatesVar</code></td>
<td>
<p>Variable to be used in the candidate function to prioritize cells for
publication and thus not suppression. If not specified, the same variable that is
used for the dominance rule will be applied (see <code>dominanceVar</code> and <code>numVar</code>).</p>
</td></tr>
<tr><td><code id="SuppressDominantCells_+3A_singletonzeros">singletonZeros</code></td>
<td>
<p>When negative values cannot occur, one can determine from a
non-suppressed marginal cell with the value 0 that all underlying cells also have the
value 0. The use of <code>singletonZeros = TRUE</code> is intended to prevent this phenomenon from
causing suppressed cells to be revealable. It is the zeros in the <code>dominanceVar</code> variable
that are examined. Specifically, the ordinary singleton method is combined with a method
that is actually designed for frequency tables. This approach also works for volume
tables when <code><a href="#topic+SingletonUniqueContributor0">SingletonUniqueContributor0</a></code> is utilized.</p>
</td></tr>
<tr><td><code id="SuppressDominantCells_+3A_spec">spec</code></td>
<td>
<p><code>NULL</code> or a named list of arguments that will act as default values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame containing aggregated data and suppression information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>num &lt;- c(100,
         90, 10,
         80, 20,
         70, 30,
         50, 25, 25,
         40, 20, 20, 20,
         25, 25, 25, 25)
v1 &lt;- c("v1",
        rep(c("v2", "v3", "v4"), each = 2),
        rep("v5", 3),
        rep(c("v6", "v7"), each = 4))
sweight &lt;- c(1, 2, 1, 2, 1, 2, 1, 2, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1)
d &lt;- data.frame(v1 = v1, num = num, sweight = sweight)

# basic use
SuppressDominantCells(d, n = c(1,2), k = c(80,70), numVar = "num", formula = ~v1 -1)

# with weights
SuppressDominantCells(d, n = c(1,2), k = c(80,70), numVar = "num",
dimVar = "v1", sWeightVar = "sweight")

# overwriting some parameters in default spec
SuppressDominantCells(d, n = c(1,2), k = c(80,70), numVar = "num",
dimVar = "v1", sWeightVar = "sweight", domWeightMethod = "tauargus")

# using dominance and few contributors rule together, see second example compared to first
SuppressDominantCells(d, n = c(1,2), k = c(80,70), numVar = "num", formula = ~v1 -1,
primary = c(DominanceRule, NContributorsRule), maxN = 3, allDominance = TRUE)

SuppressDominantCells(d, n = c(1,2), k = c(80,70), numVar = "num", formula = ~v1 -1,
primary = c(DominanceRule, NContributorsRule), maxN = 4, allDominance = TRUE)


d2 &lt;- SSBtoolsData("d2")
set.seed(123)
d2$v &lt;- rnorm(nrow(d2))^2

# Hierarchical region variables are detected automatically -&gt; same output column
SuppressDominantCells(data = d2, n = c(1, 2), k = c(70, 95), numVar = "v", 
                      dimVar = c("region", "county", "k_group"), allDominance = TRUE)

# Formula. Hierarchical variables still detected automatically.
SuppressDominantCells(data = d2, n = c(1, 2), k = c(70, 95), numVar = "v", 
                      formula = ~main_income * k_group + region + county - k_group)

# With hierarchies created manually
ml &lt;- data.frame(levels = c("@", "@@", "@@@", "@@@", "@@@", "@@"), 
        codes = c("Total", "not_assistance", "other", "pensions", "wages", "assistance"))
SuppressDominantCells(data = d2, n = c(1, 2), k = c(70, 95), numVar = "v", 
                      hierarchies = list(main_income = ml, k_group = "Total_Norway"))
</code></pre>

<hr>
<h2 id='SuppressFewContributors'>Few contributors suppression</h2><span id='topic+SuppressFewContributors'></span>

<h3>Description</h3>

<p>This function provides functionality for suppressing volume tables based on
the few contributors rule (<code><a href="#topic+NContributorsRule">NContributorsRule</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SuppressFewContributors(
  data,
  maxN,
  numVar = NULL,
  dimVar = NULL,
  hierarchies = NULL,
  formula = NULL,
  contributorVar = NULL,
  removeCodes = character(0),
  remove0 = TRUE,
  candidatesVar = NULL,
  ...,
  spec = PackageSpecs("fewContributorsSpec")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SuppressFewContributors_+3A_data">data</code></td>
<td>
<p>Input data as a data frame</p>
</td></tr>
<tr><td><code id="SuppressFewContributors_+3A_maxn">maxN</code></td>
<td>
<p>Suppression parameter. Cells with frequency <code style="white-space: pre;">&#8288;&lt;= maxN&#8288;</code> are set as primary suppressed.
Using the default <code>primary</code> function, <code>maxN</code> is by default set to <code>3</code>. See details.</p>
</td></tr>
<tr><td><code id="SuppressFewContributors_+3A_numvar">numVar</code></td>
<td>
<p>Numerical variable to be aggregated.
Any <code>candidatesVar</code> that is specified and
not included in <code>numVar</code> will be aggregated accordingly.
Additionally, if <code>remove0</code> is specified as a variable name and it is
not included in <code>numVar</code>, it will also be aggregated accordingly.
See parameters <code>candidatesVar</code> and <code>remove0</code> below.</p>
</td></tr>
<tr><td><code id="SuppressFewContributors_+3A_dimvar">dimVar</code></td>
<td>
<p>The main dimensional variables and additional aggregating variables. This parameter can be  useful when hierarchies and formula are unspecified.</p>
</td></tr>
<tr><td><code id="SuppressFewContributors_+3A_hierarchies">hierarchies</code></td>
<td>
<p>List of hierarchies, which can be converted by <code>AutoHierarchies</code>.
Thus, the variables can also be coded by <code>"rowFactor"</code> or <code>""</code>, which correspond to using the categories in the data.</p>
</td></tr>
<tr><td><code id="SuppressFewContributors_+3A_formula">formula</code></td>
<td>
<p>A model formula</p>
</td></tr>
<tr><td><code id="SuppressFewContributors_+3A_contributorvar">contributorVar</code></td>
<td>
<p>Extra variables to be used as grouping elements when counting contributors.
Typically, the variable contains the contributor IDs.</p>
</td></tr>
<tr><td><code id="SuppressFewContributors_+3A_removecodes">removeCodes</code></td>
<td>
<p>Vector of codes to be omitted when counting contributors.
With empty <code>contributorVar</code> row indices are assumed
and conversion to integer is performed.</p>
</td></tr>
<tr><td><code id="SuppressFewContributors_+3A_remove0">remove0</code></td>
<td>
<p>When set to <code>TRUE</code> (default), data rows in which the first <code>numVar</code> (if any) is zero
are excluded from the count of contributors.
Alternatively, <code>remove0</code> can be specified as one or more variable names.
In this case, all data rows with a zero in any of the specified variables
are omitted from the contributor count.
Specifying <code>remove0</code> as variable name(s) is useful for avoiding warning when there
are multiple <code>numVar</code> variables.</p>
</td></tr>
<tr><td><code id="SuppressFewContributors_+3A_candidatesvar">candidatesVar</code></td>
<td>
<p>Variable to be used in the candidate function to prioritize cells for
publication and thus not suppression.
The first <code>numVar</code> variable will be used if it is not specified.</p>
</td></tr>
<tr><td><code id="SuppressFewContributors_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the supplied functions and to <code>ModelMatrix</code> (such as <code>inputInOutput</code> and <code>removeEmpty</code>).</p>
</td></tr>
<tr><td><code id="SuppressFewContributors_+3A_spec">spec</code></td>
<td>
<p><code>NULL</code> or a named list of arguments that will act as default values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame containing aggregated data and supppression information.
Columns <code>nRule</code> and <code>nAll</code> contain the number of contributors.
In the former, <code>removeCodes</code> is taken into account.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>num &lt;- c(100,
         90, 10,
         80, 20,
         70, 30,
         50, 25, 25,
         40, 20, 20, 20,
         25, 25, 25, 25)
v1 &lt;- c("v1",
        rep(c("v2", "v3", "v4"), each = 2),
        rep("v5", 3),
        rep(c("v6", "v7"), each = 4))
sweight &lt;- c(1, 2, 1, 2, 1, 2, 1, 2, 1, 1, 2, 1, 1, 1, 2, 1, 1, 1)
d &lt;- data.frame(v1 = v1, num = num, sweight = sweight)

SuppressFewContributors(d, formula = ~v1, maxN = 1, numVar = "num")
SuppressFewContributors(d, formula = ~v1, maxN = 2, numVar = "num")
SuppressFewContributors(d, formula = ~v1, maxN = 3, numVar = "num")


d2 &lt;- SSBtoolsData("d2")[-5]
set.seed(123)
d2$v &lt;- round(rnorm(nrow(d2))^2, 1)
d2$family_id &lt;- round(2*as.integer(factor(d2$region)) + runif(nrow(d2)))

# Hierarchical region variables are detected automatically -&gt; same output column
SuppressFewContributors(data = d2, maxN = 2, numVar = "v", contributorVar = "family_id",
                      dimVar = c("region", "county", "k_group"))

# Formula. Hierarchical variables still detected automatically.
# And codes 1:9 not counted 
SuppressFewContributors(data = d2, maxN = 1, numVar = "v", contributorVar = "family_id",
                      formula = ~main_income * k_group + region + county - k_group,
                      removeCodes = 1:9)

# With hierarchies created manually
ml &lt;- data.frame(levels = c("@", "@@", "@@@", "@@@", "@@@", "@@"), 
        codes = c("Total", "not_assistance", "other", "pensions", "wages", "assistance"))
SuppressFewContributors(data = d2, maxN = 2, numVar = "v", contributorVar = "family_id",
                      hierarchies = list(main_income = ml, k_group = "Total_Norway"))
                      
                      
</code></pre>

<hr>
<h2 id='SuppressionFromDecimals'>Cell suppression from synthetic decimal numbers</h2><span id='topic+SuppressionFromDecimals'></span>

<h3>Description</h3>

<p>Decimal numbers, as calculated by <code><a href="#topic+GaussSuppressDec">GaussSuppressDec</a></code>, are used to decide suppression (whole numbers or not).
Technically, the calculations are done via <code><a href="#topic+GaussSuppressionFromData">GaussSuppressionFromData</a></code>,
but without running <code><a href="#topic+GaussSuppression">GaussSuppression</a></code>.
All suppressed cells are primary suppressed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SuppressionFromDecimals(
  data,
  decVar,
  freqVar = NULL,
  numVar = NULL,
  preAggregate = FALSE,
  digits = 9,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SuppressionFromDecimals_+3A_data">data</code></td>
<td>
<p>Input data as a data frame</p>
</td></tr>
<tr><td><code id="SuppressionFromDecimals_+3A_decvar">decVar</code></td>
<td>
<p>One ore several (<code>nRep&gt;1</code>) decimal number variables.</p>
</td></tr>
<tr><td><code id="SuppressionFromDecimals_+3A_freqvar">freqVar</code></td>
<td>
<p>A single variable holding counts (not needed)</p>
</td></tr>
<tr><td><code id="SuppressionFromDecimals_+3A_numvar">numVar</code></td>
<td>
<p>Other numerical variables to be aggregated</p>
</td></tr>
<tr><td><code id="SuppressionFromDecimals_+3A_preaggregate">preAggregate</code></td>
<td>
<p>Parameter to <code><a href="#topic+GaussSuppressionFromData">GaussSuppressionFromData</a></code></p>
</td></tr>
<tr><td><code id="SuppressionFromDecimals_+3A_digits">digits</code></td>
<td>
<p>Parameter to <code>RoundWhole</code>. Values close to whole numbers will be rounded.</p>
</td></tr>
<tr><td><code id="SuppressionFromDecimals_+3A_...">...</code></td>
<td>
<p>Other parameters to <code><a href="#topic+GaussSuppressionFromData">GaussSuppressionFromData</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Several decimal number variables reduce the probability of obtaining whole numbers by chance.
</p>


<h3>Value</h3>

<p>Aggregated data with suppression information
</p>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z2 &lt;- SSBtoolsData("z2")

# Find suppression and decimal numbers with "fylke" in model 
a &lt;- GaussSuppressDec(z2, dimVar = c("region", "fylke", "hovedint"), 
                      freqVar = "ant", protectZeros = FALSE, maxN = 2, 
                      output = "inner")

# Add decimal numbers to data 
z2$freqDec &lt;- a$freqDec

# Find suppression with "kostragr" in model 
b &lt;- SuppressionFromDecimals(z2, dimVar = c("region", "kostragr", "hovedint"), 
                             freqVar = "ant", decVar = "freqDec")
</code></pre>

<hr>
<h2 id='SuppressKDisclosure'>K-disclosure suppression</h2><span id='topic+SuppressKDisclosure'></span>

<h3>Description</h3>

<p>A function for suppressing frequency tables using the k-disclosure method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SuppressKDisclosure(
  data,
  coalition = 0,
  mc_hierarchies = NULL,
  upper_bound = Inf,
  dimVar = NULL,
  formula = NULL,
  hierarchies = NULL,
  freqVar = NULL,
  ...,
  spec = PackageSpecs("kDisclosureSpec")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SuppressKDisclosure_+3A_data">data</code></td>
<td>
<p>a data.frame representing the data set</p>
</td></tr>
<tr><td><code id="SuppressKDisclosure_+3A_coalition">coalition</code></td>
<td>
<p>numeric vector of length one, representing possible size of an
attacking coalition. This parameter corresponds to the parameter k in the
definition of k-disclosure.</p>
</td></tr>
<tr><td><code id="SuppressKDisclosure_+3A_mc_hierarchies">mc_hierarchies</code></td>
<td>
<p>a hierarchy representing meaningful combinations to be
protected. Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="SuppressKDisclosure_+3A_upper_bound">upper_bound</code></td>
<td>
<p>numeric value representing minimum count considered safe.
Default set to <code>Inf</code></p>
</td></tr>
<tr><td><code id="SuppressKDisclosure_+3A_dimvar">dimVar</code></td>
<td>
<p>The main dimensional variables and additional aggregating
variables. This parameter can be  useful when hierarchies and formula are
unspecified.</p>
</td></tr>
<tr><td><code id="SuppressKDisclosure_+3A_formula">formula</code></td>
<td>
<p>A model formula</p>
</td></tr>
<tr><td><code id="SuppressKDisclosure_+3A_hierarchies">hierarchies</code></td>
<td>
<p>List of hierarchies, which can be converted by
<code>AutoHierarchies</code>. Thus, the variables can also be coded by
<code>"rowFactor"</code> or <code>""</code>, which correspond to using the categories in the data.</p>
</td></tr>
<tr><td><code id="SuppressKDisclosure_+3A_freqvar">freqVar</code></td>
<td>
<p>name of the frequency variable in <code>data</code></p>
</td></tr>
<tr><td><code id="SuppressKDisclosure_+3A_...">...</code></td>
<td>
<p>parameters passed to children functions</p>
</td></tr>
<tr><td><code id="SuppressKDisclosure_+3A_spec">spec</code></td>
<td>
<p><code>NULL</code> or a named list of arguments that will act as default values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame containing the publishable data set, with a boolean
variable <code style="white-space: pre;">&#8288;$suppressed&#8288;</code> representing cell suppressions.
</p>


<h3>Author(s)</h3>

<p>Daniel P. Lupp
</p>


<h3>Examples</h3>

<pre><code class='language-R'># data
data &lt;- SSBtools::SSBtoolsData("mun_accidents")

# hierarchies as DimLists
mun &lt;- data.frame(levels = c("@", rep("@@", 6)),
codes = c("Total", paste("k", 1:6, sep = "")))
inj &lt;- data.frame(levels = c("@", "@@" ,"@@", "@@", "@@"),
codes = c("Total", "serious", "light", "none", "unknown"))
dimlists &lt;- list(mun = mun, inj = inj)

inj2 &lt;- data.frame(levels = c("@", "@@", "@@@" ,"@@@", "@@", "@@"),
codes = c("Total", "injured", "serious", "light", "none", "unknown"))
inj3 &lt;- data.frame(levels = c("@", "@@", "@@" ,"@@", "@@"),
codes = c( "shadowtotal", "serious", "light", "none", "unknown"))
mc_dimlist &lt;- list(inj = inj2)
mc_nomargs &lt;- list(inj = inj3)

#' # Example with formula, no meaningful combination
out &lt;- SuppressKDisclosure(data, coalition = 1, freqVar = "freq", formula = ~mun*inj)

# Example with hierarchy and meaningful combination
out2 &lt;- SuppressKDisclosure(data, coalition = 1, freqVar = "freq",
hierarchies = dimlists, mc_hierarchies = mc_dimlist)

#' # Example of table without mariginals, and mc_hierarchies to protect
out3 &lt;- SuppressKDisclosure(data, coalition = 1, freqVar = "freq",
formula = ~mun:inj, mc_hierarchies = mc_nomargs )
</code></pre>

<hr>
<h2 id='SuppressSmallCounts'>Small count frequency table suppression.</h2><span id='topic+SuppressSmallCounts'></span>

<h3>Description</h3>

<p>This is a wrapper function of <code><a href="#topic+GaussSuppressionFromData">GaussSuppressionFromData</a></code>
for small count frequency suppression. For common applications, the <code>spec</code>
parameter can be adjusted, see <code><a href="#topic+PackageSpecs">PackageSpecs</a></code> for more
information. See Details for more information on function call customization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SuppressSmallCounts(
  data,
  maxN,
  freqVar = NULL,
  dimVar = NULL,
  hierarchies = NULL,
  formula = NULL,
  ...,
  spec = PackageSpecs("smallCountSpec")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SuppressSmallCounts_+3A_data">data</code></td>
<td>
<p>Input data as a data frame</p>
</td></tr>
<tr><td><code id="SuppressSmallCounts_+3A_maxn">maxN</code></td>
<td>
<p>Suppression parameter. Cells with frequency <code style="white-space: pre;">&#8288;&lt;= maxN&#8288;</code> are set as primary suppressed.
Using the default <code>primary</code> function, <code>maxN</code> is by default set to <code>3</code>. See details.</p>
</td></tr>
<tr><td><code id="SuppressSmallCounts_+3A_freqvar">freqVar</code></td>
<td>
<p>A single variable holding counts (name or number).</p>
</td></tr>
<tr><td><code id="SuppressSmallCounts_+3A_dimvar">dimVar</code></td>
<td>
<p>The main dimensional variables and additional aggregating variables. This parameter can be  useful when hierarchies and formula are unspecified.</p>
</td></tr>
<tr><td><code id="SuppressSmallCounts_+3A_hierarchies">hierarchies</code></td>
<td>
<p>List of hierarchies, which can be converted by <code>AutoHierarchies</code>.
Thus, the variables can also be coded by <code>"rowFactor"</code> or <code>""</code>, which correspond to using the categories in the data.</p>
</td></tr>
<tr><td><code id="SuppressSmallCounts_+3A_formula">formula</code></td>
<td>
<p>A model formula</p>
</td></tr>
<tr><td><code id="SuppressSmallCounts_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the supplied functions and to <code>ModelMatrix</code> (such as <code>inputInOutput</code> and <code>removeEmpty</code>).</p>
</td></tr>
<tr><td><code id="SuppressSmallCounts_+3A_spec">spec</code></td>
<td>
<p><code>NULL</code> or a named list of arguments that will act as default values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The specs provided in the package (see <code><a href="#topic+PackageSpecs">PackageSpecs</a></code>)
provide common parameter setups for small count suppression. However, it might
be necessary to customize the parameters further. In this case, certain
parameters from <code><a href="#topic+GaussSuppressionFromData">GaussSuppressionFromData</a></code>
might need adjusting from the values provided by the package specs. In
particular, the parameters <code>protectZeros</code> (should zeros be primary
suppressed), <code>extend0</code> (should empty cells be added before primary
suppression), and <code>secondaryZeros</code> (should zero frequency cells be
candidates for secondary suppression) might be of interest. The examples
below illustrate how to override parameters specified by a spec. Note
that this is only possible if <code>specLock = FALSE</code>.
</p>


<h3>Value</h3>

<p>data frame containing aggregated data and suppression information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mun_accidents &lt;- SSBtoolsData("mun_accidents")

SuppressSmallCounts(data = mun_accidents, maxN = 3, dimVar = 1:2, freqVar = 3)
# override default spec
SuppressSmallCounts(data = mun_accidents, maxN = 3, dimVar = 1:2, freqVar = 3, 
                    protectZeros = FALSE)
                    
                    
d2 &lt;- SSBtoolsData("d2")
d2$f &lt;- round(d2$freq/10)  # tenth as frequency in examples

# Hierarchical region variables are detected automatically -&gt; same output column
SuppressSmallCounts(data = d2, maxN = 2, freqVar = "f", 
                    dimVar = c("region", "county", "k_group"))

# Formula. Hierarchical variables still detected automatically.
SuppressSmallCounts(data = d2, maxN = 3, freqVar = "f", 
                    formula = ~main_income * k_group + region + county - k_group)

# With hierarchies created manually
ml &lt;- data.frame(levels = c("@", "@@", "@@@", "@@@", "@@@", "@@"), 
        codes = c("Total", "not_assistance", "other", "pensions", "wages", "assistance"))
SuppressSmallCounts(data = d2, maxN = 2, freqVar = "f", 
                    hierarchies = list(main_income = ml, k_group = "Total_Norway"))


# Data without pensions in k_group 400 
# And assume these are structural zeros (will not be suppressed)
SuppressSmallCounts(data = d2[1:41, ], maxN = 3, freqVar = "f", 
                    hierarchies = list(main_income = ml, k_group = "Total_Norway"), 
                    extend0 = FALSE, structuralEmpty = TRUE)
# -- Note for the example above -- 
# With protectZeros = FALSE 
#   - No zeros suppressed
# With extend0 = FALSE and structuralEmpty = FALSE 
#   - Primary suppression without protection (with warning) 
# With extend0 = TRUE and structuralEmpty = TRUE 
#   - As default behavior. Suppression/protection of all zeros (since nothing empty)
# With formula instead of hierarchies: Extra parameter needed when extend0 = FALSE.
#   - removeEmpty = FALSE,  to include empty zeros in output.                      
</code></pre>

<hr>
<h2 id='X_from_mc'>Function to be used within <code>KDisclosurePrimary</code></h2><span id='topic+X_from_mc'></span><span id='topic+X_from_mc_remove'></span><span id='topic+X_from_mc_noinner'></span><span id='topic+X_from_mc_remove_noinner'></span>

<h3>Description</h3>

<p>Function to be used within <code>KDisclosurePrimary</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>X_from_mc(
  x,
  crossTable,
  mc_hierarchies,
  removeIncomplete = FALSE,
  returnNewCrossTable = FALSE,
  noInner = FALSE,
  ...
)

X_from_mc_remove(..., removeIncomplete = TRUE)

X_from_mc_noinner(..., noInner = TRUE)

X_from_mc_remove_noinner(..., removeIncomplete = TRUE, noInner = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="X_from_mc_+3A_x">x</code></td>
<td>
<p>ModelMatrix generated by parent function</p>
</td></tr>
<tr><td><code id="X_from_mc_+3A_crosstable">crossTable</code></td>
<td>
<p>crossTable generated by parent function</p>
</td></tr>
<tr><td><code id="X_from_mc_+3A_mc_hierarchies">mc_hierarchies</code></td>
<td>
<p>a hierarchy representing meaningful combinations to be
protected. Default value is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="X_from_mc_+3A_removeincomplete">removeIncomplete</code></td>
<td>
<p>When <code>TRUE</code>,  the input code contributions are checked and incomplete entries are removed.</p>
</td></tr>
<tr><td><code id="X_from_mc_+3A_returnnewcrosstable">returnNewCrossTable</code></td>
<td>
<p>When <code>TRUE</code>, the crossTable corresponding to the created x-matrix is also returned (in a list)</p>
</td></tr>
<tr><td><code id="X_from_mc_+3A_noinner">noInner</code></td>
<td>
<p>When <code>TRUE</code>,  more efficient generation of model matrix.  (removing inner cells according to colSums not needed)</p>
</td></tr>
<tr><td><code id="X_from_mc_+3A_...">...</code></td>
<td>
<p>parameters passed to children functions</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Øyvind Langsrud
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
