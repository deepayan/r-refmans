<!DOCTYPE html><html><head><title>Help for package gstsm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gstsm}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#find'><p>Find - definition</p></a></li>
<li><a href='#find_kernel_ranged_group'><p>Find Kernel Ranged Group</p></a></li>
<li><a href='#find.default'><p>Find - default</p></a></li>
<li><a href='#find.gstsm'><p>Find - GSTSM implementation</p></a></li>
<li><a href='#generate_adjacency_matrix'><p>Generate Adjacency Matrix</p></a></li>
<li><a href='#generate_candidates'><p>Generate Candidates - definition</p></a></li>
<li><a href='#generate_candidates.default'><p>Generate Candidates - default</p></a></li>
<li><a href='#generate_candidates.gstsm'><p>Generate Candidates - GSTSM implementation</p></a></li>
<li><a href='#gstsm'><p>GSTSM</p></a></li>
<li><a href='#merge'><p>Merge - definition</p></a></li>
<li><a href='#merge_kernel_ranged_groups'><p>Merge Kernel Ranged Groups</p></a></li>
<li><a href='#merge_open_kernel_ranged_groups'><p>Merge Kernel Ranged Groups</p></a></li>
<li><a href='#merge.default'><p>Merge - default</p></a></li>
<li><a href='#merge.gstsm'><p>Merge - GSTSM implementation</p></a></li>
<li><a href='#mine'><p>Mine - definition</p></a></li>
<li><a href='#mine.default'><p>Mine - default</p></a></li>
<li><a href='#mine.gstsm'><p>Mine - GSTSM implementation</p></a></li>
<li><a href='#split_groups'><p>Split Groups</p></a></li>
<li><a href='#validate_and_close'><p>Validate and Close</p></a></li>
<li><a href='#validate_kernel_ranged_groups'><p>Validate Kernel Ranged Groups</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Generalized Spatial-Time Sequence Miner</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Implementations of the algorithms present article 
    Generalized Spatial-Time Sequence Miner, original title
    (Castro, Antonio; Borges, Heraldo ; Pacitti, Esther ; Porto, Fabio
    ; Coutinho, Rafaelli ; Ogasawara, Eduardo . Generalização de Mineração de
    Sequências Restritas no Espaço e no Tempo. In: XXXVI SBBD -
    Simpósio Brasileiro de Banco de Dados, 2021 &lt;<a href="https://doi.org/10.5753%2Fsbbd.2021.17891">doi:10.5753/sbbd.2021.17891</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Imports:</td>
<td>digest</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-10-17 20:49:46 UTC; cassio</td>
</tr>
<tr>
<td>Author:</td>
<td>Antonio Castro [aut, cre],
  Cássio Souza [aut, ctb],
  Jorge Rodrigues [aut, ctb],
  Esther Pacitti [aut],
  Fábio Porto [aut],
  Florent Masseglia [aut],
  Rafaelli Coutinho [aut, ths],
  Eduardo Ogasawara <a href="https://orcid.org/0000-0002-0466-0626"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, ths],
  Federal Center for Technological Education of Rio de Janeiro [cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Antonio Castro &lt;gstsm@eic.cefet-rj.br&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-10-19 20:05:12 UTC</td>
</tr>
</table>
<hr>
<h2 id='find'>Find - definition</h2><span id='topic+find'></span>

<h3>Description</h3>

<p>S3 class definition for find method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find(object, ck)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_+3A_object">object</code></td>
<td>
<p>a GSTSM object</p>
</td></tr>
<tr><td><code id="find_+3A_ck">ck</code></td>
<td>
<p>set of candidates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Solid Ranged-Group(s) of all candidate sequences
</p>

<hr>
<h2 id='find_kernel_ranged_group'>Find Kernel Ranged Group</h2><span id='topic+find_kernel_ranged_group'></span>

<h3>Description</h3>

<p>The goal is to find the Kernel Ranged Group information for a candidate c.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_kernel_ranged_group(c, d, gamma, beta, adjacency_matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_kernel_ranged_group_+3A_c">c</code></td>
<td>
<p>candidate</p>
</td></tr>
<tr><td><code id="find_kernel_ranged_group_+3A_d">d</code></td>
<td>
<p>set of transactions</p>
</td></tr>
<tr><td><code id="find_kernel_ranged_group_+3A_gamma">gamma</code></td>
<td>
<p>minimum temporal frequency</p>
</td></tr>
<tr><td><code id="find_kernel_ranged_group_+3A_beta">beta</code></td>
<td>
<p>minimum group size</p>
</td></tr>
<tr><td><code id="find_kernel_ranged_group_+3A_adjacency_matrix">adjacency_matrix</code></td>
<td>
<p>adjacency matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Kernel Ranged-Group(s) of c updated
</p>

<hr>
<h2 id='find.default'>Find - default</h2><span id='topic+find.default'></span>

<h3>Description</h3>

<p>Default method for find. Does nothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
find(object, ck)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find.default_+3A_object">object</code></td>
<td>
<p>a GSTSM object</p>
</td></tr>
<tr><td><code id="find.default_+3A_ck">ck</code></td>
<td>
<p>set of candidates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Solid Ranged-Group(s) of all candidate sequences
</p>

<hr>
<h2 id='find.gstsm'>Find - GSTSM implementation</h2><span id='topic+find.gstsm'></span>

<h3>Description</h3>

<p>GSTSM implementationfor for find method. Does nothing.
The goal is to find the Ranged Groups information for a candidate c.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gstsm'
find(object, ck)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find.gstsm_+3A_object">object</code></td>
<td>
<p>a GSTSM object</p>
</td></tr>
<tr><td><code id="find.gstsm_+3A_ck">ck</code></td>
<td>
<p>set of candidates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Solid Ranged-Group(s) of all candidate sequences
</p>

<hr>
<h2 id='generate_adjacency_matrix'>Generate Adjacency Matrix</h2><span id='topic+generate_adjacency_matrix'></span>

<h3>Description</h3>

<p>Helper function that generates an adjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_adjacency_matrix(spatial_positions, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_adjacency_matrix_+3A_spatial_positions">spatial_positions</code></td>
<td>
<p>set of spatial positions</p>
</td></tr>
<tr><td><code id="generate_adjacency_matrix_+3A_sigma">sigma</code></td>
<td>
<p>max distance between group points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Adjacency Matrix
</p>

<hr>
<h2 id='generate_candidates'>Generate Candidates - definition</h2><span id='topic+generate_candidates'></span>

<h3>Description</h3>

<p>S3 class definition for generate_candidates method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_candidates(object, srg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_candidates_+3A_object">object</code></td>
<td>
<p>a GSTSM object</p>
</td></tr>
<tr><td><code id="generate_candidates_+3A_srg">srg</code></td>
<td>
<p>set of Solid Ranged Groups</p>
</td></tr>
</table>


<h3>Value</h3>

<p>candidate sequences of size k + 1
</p>

<hr>
<h2 id='generate_candidates.default'>Generate Candidates - default</h2><span id='topic+generate_candidates.default'></span>

<h3>Description</h3>

<p>Default method for generate_candidates. Does nothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
generate_candidates(object, srg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_candidates.default_+3A_object">object</code></td>
<td>
<p>a GSTSM object</p>
</td></tr>
<tr><td><code id="generate_candidates.default_+3A_srg">srg</code></td>
<td>
<p>set of Solid Ranged Groups</p>
</td></tr>
</table>


<h3>Value</h3>

<p>candidate sequences of size k + 1
</p>

<hr>
<h2 id='generate_candidates.gstsm'>Generate Candidates - GSTSM implementation</h2><span id='topic+generate_candidates.gstsm'></span>

<h3>Description</h3>

<p>The algorithm combines SRGs that have sequences of size k, received as
input, to generate candidates with sequences of size k + 1. Let x and y be
SRGs, the conditions for this to occur are: that we have an
intersection of candidates over the time range,
intersection over the set of spatial positions (x.g n y.g), and
a common subsequence: &lt;x.s2, . . . , x.sk&gt;=&lt;y.s1, . . . , y.sk-1&gt;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gstsm'
generate_candidates(object, srg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_candidates.gstsm_+3A_object">object</code></td>
<td>
<p>a GSTSM object</p>
</td></tr>
<tr><td><code id="generate_candidates.gstsm_+3A_srg">srg</code></td>
<td>
<p>set of Solid Ranged Groups</p>
</td></tr>
</table>


<h3>Value</h3>

<p>candidate sequences of size k + 1
</p>

<hr>
<h2 id='gstsm'>GSTSM</h2><span id='topic+gstsm'></span>

<h3>Description</h3>

<p>S3 class definition for GSTSM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gstsm(sts_dataset, spatial_positions, gamma, beta, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gstsm_+3A_sts_dataset">sts_dataset</code></td>
<td>
<p>STS dataset</p>
</td></tr>
<tr><td><code id="gstsm_+3A_spatial_positions">spatial_positions</code></td>
<td>
<p>set of spatial positions</p>
</td></tr>
<tr><td><code id="gstsm_+3A_gamma">gamma</code></td>
<td>
<p>minimum temporal frequency</p>
</td></tr>
<tr><td><code id="gstsm_+3A_beta">beta</code></td>
<td>
<p>minimum group size</p>
</td></tr>
<tr><td><code id="gstsm_+3A_sigma">sigma</code></td>
<td>
<p>maximum distance between group points</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm is designed to the identification of frequent sequences in
STS datasets from the concept of Solid Ranged Groups (SRG).
GSTSM is based on the candidate-generating principle.
The goal is to start finding SRGs for sequences of size one.
Then it explores the support and the number of occurrences of SRGs for
larger sequences with a limited number of scans over the database.
</p>


<h3>Value</h3>

<p>a GSTSM object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("gstsm")

D &lt;- as.data.frame(matrix(c("B", "B", "A", "C", "A",
              "C", "B", "C", "A", "B",
              "C", "C", "A", "C", "A",
              "B", "B", "D", "A", "B",
              "B", "D", "D", "B", "D"
            ), nrow = 5, ncol = 5, byrow = TRUE))

ponto &lt;- c("p1", "p2", "p3", "p4", "p5")
x &lt;- c(1, 2, 3, 4, 5)
y &lt;- c(0, 0, 0, 0, 0)
z &lt;- y
P &lt;- data.frame(ponto=ponto, x=x, y=y, z=z, stringsAsFactors = FALSE)

gamma &lt;- 0.8
beta &lt;- 2
sigma &lt;- 1

gstsm_object &lt;- gstsm(D, P, gamma, beta, sigma)

result &lt;- mine(gstsm_object)

</code></pre>

<hr>
<h2 id='merge'>Merge - definition</h2><span id='topic+merge'></span>

<h3>Description</h3>

<p>S3 class definition for merge method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge(object, ck)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_+3A_object">object</code></td>
<td>
<p>a GSTSM object</p>
</td></tr>
<tr><td><code id="merge_+3A_ck">ck</code></td>
<td>
<p>set of candidates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Solid Ranged-Group(s) of all candidate sequences
</p>

<hr>
<h2 id='merge_kernel_ranged_groups'>Merge Kernel Ranged Groups</h2><span id='topic+merge_kernel_ranged_groups'></span>

<h3>Description</h3>

<p>The goal is to merge KRGs.
Let q and u be two different KRGs from the same candidate sequence.
They can be merged into a group qu = q U u as long as they have an
intersection and qu has a frequency greater than or equal to the minimum
frequency defined by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_kernel_ranged_groups(c, gamma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_kernel_ranged_groups_+3A_c">c</code></td>
<td>
<p>candidate</p>
</td></tr>
<tr><td><code id="merge_kernel_ranged_groups_+3A_gamma">gamma</code></td>
<td>
<p>minimum temporal frequency</p>
</td></tr>
</table>


<h3>Value</h3>

<p>KRG
</p>

<hr>
<h2 id='merge_open_kernel_ranged_groups'>Merge Kernel Ranged Groups</h2><span id='topic+merge_open_kernel_ranged_groups'></span>

<h3>Description</h3>

<p>The goal of is to stretch KRGs of the same candidate sequence.
Its possible if two KRGs have intersection in space and
the resulting KRG keeps its frequency equal to or greater than beta.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merge_open_kernel_ranged_groups(c, timestamp, gamma, beta, adjacency_matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge_open_kernel_ranged_groups_+3A_c">c</code></td>
<td>
<p>candidate.</p>
</td></tr>
<tr><td><code id="merge_open_kernel_ranged_groups_+3A_timestamp">timestamp</code></td>
<td>
<p>current timestamp</p>
</td></tr>
<tr><td><code id="merge_open_kernel_ranged_groups_+3A_gamma">gamma</code></td>
<td>
<p>minimum temporal frequency</p>
</td></tr>
<tr><td><code id="merge_open_kernel_ranged_groups_+3A_beta">beta</code></td>
<td>
<p>minimum group size</p>
</td></tr>
<tr><td><code id="merge_open_kernel_ranged_groups_+3A_adjacency_matrix">adjacency_matrix</code></td>
<td>
<p>adjacency matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Set of updated KRGs
</p>

<hr>
<h2 id='merge.default'>Merge - default</h2><span id='topic+merge.default'></span>

<h3>Description</h3>

<p>Default method for merge. Does nothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
merge(object, ck)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge.default_+3A_object">object</code></td>
<td>
<p>a GSTSM object</p>
</td></tr>
<tr><td><code id="merge.default_+3A_ck">ck</code></td>
<td>
<p>set of candidates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Solid Ranged-Group(s) of all candidate sequences
</p>

<hr>
<h2 id='merge.gstsm'>Merge - GSTSM implementation</h2><span id='topic+merge.gstsm'></span>

<h3>Description</h3>

<p>Merge - GSTSM implementation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gstsm'
merge(object, ck)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge.gstsm_+3A_object">object</code></td>
<td>
<p>a GSTSM object</p>
</td></tr>
<tr><td><code id="merge.gstsm_+3A_ck">ck</code></td>
<td>
<p>set of candidates</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Solid Ranged-Group(s) of all candidate sequences
</p>

<hr>
<h2 id='mine'>Mine - definition</h2><span id='topic+mine'></span>

<h3>Description</h3>

<p>S3 class definition for mine method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mine(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mine_+3A_object">object</code></td>
<td>
<p>a GSTSM object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>all Solid Ranged Group(s) found, of all sizes
</p>

<hr>
<h2 id='mine.default'>Mine - default</h2><span id='topic+mine.default'></span>

<h3>Description</h3>

<p>Default method for mine. Does nothing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Default S3 method:
mine(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mine.default_+3A_object">object</code></td>
<td>
<p>a GSTSM object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>all Solid Ranged Group(s) found, of all sizes
</p>

<hr>
<h2 id='mine.gstsm'>Mine - GSTSM implementation</h2><span id='topic+mine.gstsm'></span>

<h3>Description</h3>

<p>Mine - GSTSM implementation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gstsm'
mine(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mine.gstsm_+3A_object">object</code></td>
<td>
<p>a GSTSM object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>all Solid Ranged Group(s) found, of all sizes
</p>

<hr>
<h2 id='split_groups'>Split Groups</h2><span id='topic+split_groups'></span>

<h3>Description</h3>

<p>Helper function that splits groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>split_groups(pos, adjacency_matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="split_groups_+3A_pos">pos</code></td>
<td>
<p>sequence occurrence index</p>
</td></tr>
<tr><td><code id="split_groups_+3A_adjacency_matrix">adjacency_matrix</code></td>
<td>
<p>possible connection between positions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>new set based on candidate c found in d.
</p>

<hr>
<h2 id='validate_and_close'>Validate and Close</h2><span id='topic+validate_and_close'></span>

<h3>Description</h3>

<p>The function receives as input the set of RGs (RG) from a candidate and the
minimum size of a group (beta).
It starts defining a set of elements that will be removed from the
set of RGs, if it does not have the minimum group size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_and_close(c, gamma, beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_and_close_+3A_c">c</code></td>
<td>
<p>candidate</p>
</td></tr>
<tr><td><code id="validate_and_close_+3A_gamma">gamma</code></td>
<td>
<p>minimum temporal frequency</p>
</td></tr>
<tr><td><code id="validate_and_close_+3A_beta">beta</code></td>
<td>
<p>minimum group size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>validated Greedy-Ranged-Groups.
</p>

<hr>
<h2 id='validate_kernel_ranged_groups'>Validate Kernel Ranged Groups</h2><span id='topic+validate_kernel_ranged_groups'></span>

<h3>Description</h3>

<p>Its objective is to verify that the user thresholds were observed
in each RGs, checking if they can still be stretched by keeping
the frequency greater than or equal to the minimum gamma and if
the minimum group size beta occurs.
It takes as input a set of RGs RG of a candidate sequence, the timestamp
of the start of the current sliding window timestamp, the user-defined
thresholds gamma and beta.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate_kernel_ranged_groups(c, timestamp, gamma, beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate_kernel_ranged_groups_+3A_c">c</code></td>
<td>
<p>candidate</p>
</td></tr>
<tr><td><code id="validate_kernel_ranged_groups_+3A_timestamp">timestamp</code></td>
<td>
<p>current timestamp</p>
</td></tr>
<tr><td><code id="validate_kernel_ranged_groups_+3A_gamma">gamma</code></td>
<td>
<p>minimum temporal frequency</p>
</td></tr>
<tr><td><code id="validate_kernel_ranged_groups_+3A_beta">beta</code></td>
<td>
<p>minimum group size</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Validated Kernel-Ranged-Groups.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
