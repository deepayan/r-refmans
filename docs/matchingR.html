<!DOCTYPE html><html><head><title>Help for package matchingR</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {matchingR}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#cpp_wrapper_galeshapley'><p>C++ wrapper for Gale-Shapley Algorithm</p></a></li>
<li><a href='#cpp_wrapper_galeshapley_check_stability'><p>C++ Wrapper to Check Stability of Two-sided Matching</p></a></li>
<li><a href='#cpp_wrapper_irving'><p>Computes a stable roommate matching</p></a></li>
<li><a href='#cpp_wrapper_irving_check_stability'><p>Check if a matching solves the stable roommate problem</p></a></li>
<li><a href='#cpp_wrapper_ttc'><p>Computes the top trading cycle algorithm</p></a></li>
<li><a href='#cpp_wrapper_ttc_check_stability'><p>Check if a one-sided matching for the top trading cycle algorithm is stable</p></a></li>
<li><a href='#galeShapley.checkPreferences'><p>Check if preference order is complete</p></a></li>
<li><a href='#galeShapley.checkStability'><p>Check if a two-sided matching is stable</p></a></li>
<li><a href='#galeShapley.collegeAdmissions'><p>Gale-Shapley Algorithm: College Admissions Problem</p></a></li>
<li><a href='#galeShapley.marriageMarket'><p>Gale-Shapley Algorithm: Stable Marriage Problem</p></a></li>
<li><a href='#galeShapley.validate'><p>Input validation of preferences</p></a></li>
<li><a href='#matchingR-deprecated'><p>Deprecated Functions in matchingR</p></a></li>
<li><a href='#matchingR-package'><p>matchingR: Matching Algorithms in R and C++</p></a></li>
<li><a href='#rankIndex'><p>Rank elements within column of a matrix</p></a></li>
<li><a href='#repcol'><p>Repeat each column of a matrix n times</p></a></li>
<li><a href='#reprow'><p>Repeat each row of a matrix n times</p></a></li>
<li><a href='#roommate'><p>Compute matching for one-sided markets</p></a></li>
<li><a href='#roommate.checkPreferences'><p>Check if preference order for a one-sided market is complete</p></a></li>
<li><a href='#roommate.checkStability'><p>Check if a roommate matching is stable</p></a></li>
<li><a href='#roommate.validate'><p>Input validation for one-sided markets</p></a></li>
<li><a href='#sortIndex'><p>Sort indices of a matrix within a column</p></a></li>
<li><a href='#sortIndexOneSided'><p>Ranks elements with column of a matrix, assuming a one-sided market.</p></a></li>
<li><a href='#toptrading'><p>Compute the top trading cycle algorithm</p></a></li>
<li><a href='#toptrading.checkStability'><p>Check if there are any pairs of agents who would rather swap houses with</p>
each other rather than be with their own two current respective partners.</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Matching Algorithms in R and C++</td>
</tr>
<tr>
<td>Version:</td>
<td>1.3.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2021-05-25</td>
</tr>
<tr>
<td>Author:</td>
<td>Jan Tilly, Nick Janetos</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jan Tilly &lt;jantilly@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Computes matching algorithms quickly using Rcpp.
    Implements the Gale-Shapley Algorithm to compute the stable
    matching for two-sided markets, such as the stable marriage
    problem and the college-admissions problem. Implements Irving's
    Algorithm for the stable roommate problem. Implements the top
    trading cycle algorithm for the indivisible goods trading problem.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jtilly/matchingR/">https://github.com/jtilly/matchingR/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jtilly/matchingR/issues/">https://github.com/jtilly/matchingR/issues/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-05-25 07:34:20 UTC; jtilly</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-05-25 08:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='cpp_wrapper_galeshapley'>C++ wrapper for Gale-Shapley Algorithm</h2><span id='topic+cpp_wrapper_galeshapley'></span>

<h3>Description</h3>

<p>This function provides an R wrapper for the C++ backend. Users should not
call this function directly and instead use
<code><a href="#topic+galeShapley.marriageMarket">galeShapley.marriageMarket</a></code> or
<code><a href="#topic+galeShapley.collegeAdmissions">galeShapley.collegeAdmissions</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpp_wrapper_galeshapley(proposerPref, reviewerUtils)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_wrapper_galeshapley_+3A_proposerpref">proposerPref</code></td>
<td>
<p>is a matrix with the preference order of the proposing
side of the market. If there are <code>n</code> proposers and <code>m</code> reviewers
in the market, then this matrix will be of dimension <code>m</code> by <code>n</code>.
The <code>i,j</code>th element refers to <code>j</code>'s <code>i</code>th most favorite
partner. Preference orders must be complete and specified using C++
indexing (starting at 0).</p>
</td></tr>
<tr><td><code id="cpp_wrapper_galeshapley_+3A_reviewerutils">reviewerUtils</code></td>
<td>
<p>is a matrix with cardinal utilities of the courted side
of the market. If there are <code>n</code> proposers and <code>m</code> reviewers, then
this matrix will be of dimension <code>n</code> by <code>m</code>. The <code>i,j</code>th
element refers to the payoff that individual <code>j</code> receives from being
matched to individual <code>i</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with elements that specify who is matched to whom. Suppose
there are <code>n</code> proposers and <code>m</code> reviewers. The list contains
the following items:
</p>

<ul>
<li><p><code>proposals</code> is a vector of length <code>n</code> whose <code>i</code>th
element contains the number of the reviewer that proposer <code>i</code> is
matched to using C++ indexing. Proposers that remain unmatched will be
listed as being matched to <code>m</code>.
</p>
</li>
<li><p><code>engagements</code> is a vector of length <code>m</code> whose <code>j</code>th
element contains the number of the proposer that reviewer <code>j</code> is
matched to using C++ indexing. Reviwers that remain unmatched will be
listed as being matched to <code>n</code>.
</p>
</li></ul>


<hr>
<h2 id='cpp_wrapper_galeshapley_check_stability'>C++ Wrapper to Check Stability of Two-sided Matching</h2><span id='topic+cpp_wrapper_galeshapley_check_stability'></span>

<h3>Description</h3>

<p>This function checks if a given matching is stable for a particular set of
preferences. This function provides an R wrapper for the C++ backend. Users
should not call this function directly and instead use
<code><a href="#topic+galeShapley.checkStability">galeShapley.checkStability</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpp_wrapper_galeshapley_check_stability(
  proposerUtils,
  reviewerUtils,
  proposals,
  engagements
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_wrapper_galeshapley_check_stability_+3A_proposerutils">proposerUtils</code></td>
<td>
<p>is a matrix with cardinal utilities of the proposing
side of the market. If there are <code>n</code> proposers and <code>m</code> reviewers,
then this matrix will be of dimension <code>m</code> by <code>n</code>. The
<code>i,j</code>th element refers to the payoff that individual <code>j</code> receives
from being matched to individual <code>i</code>.</p>
</td></tr>
<tr><td><code id="cpp_wrapper_galeshapley_check_stability_+3A_reviewerutils">reviewerUtils</code></td>
<td>
<p>is a matrix with cardinal utilities of the courted side
of the market. If there are <code>n</code> proposers and <code>m</code> reviewers, then
this matrix will be of dimension <code>n</code> by <code>m</code>. The <code>i,j</code>th
element refers to the payoff that individual <code>j</code> receives from being
matched to individual <code>i</code>.</p>
</td></tr>
<tr><td><code id="cpp_wrapper_galeshapley_check_stability_+3A_proposals">proposals</code></td>
<td>
<p>is a matrix that contains the number of the reviewer that a
given proposer is matched to: the first row contains the number of the
reviewer that is matched with the first proposer (using C++ indexing), the
second row contains the id of the reviewer that is matched with the second
proposer, etc. The column dimension accommodates proposers with multiple
slots.</p>
</td></tr>
<tr><td><code id="cpp_wrapper_galeshapley_check_stability_+3A_engagements">engagements</code></td>
<td>
<p>is a matrix that contains the number of the proposer that
a given reviewer is matched to (using C++ indexing). The column dimension
accommodates reviewers with multiple slots.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>true if the matching is stable, false otherwise
</p>

<hr>
<h2 id='cpp_wrapper_irving'>Computes a stable roommate matching</h2><span id='topic+cpp_wrapper_irving'></span>

<h3>Description</h3>

<p>This is the C++ wrapper for the stable roommate problem. Users should not
call this function directly, but instead use
<code><a href="#topic+roommate">roommate</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpp_wrapper_irving(pref)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_wrapper_irving_+3A_pref">pref</code></td>
<td>
<p>is a matrix with the preference order of each individual in the
market. If there are <code>n</code> individuals, then this matrix will be of
dimension <code>n-1</code> by <code>n</code>. The <code>i,j</code>th element refers to
<code>j</code>'s <code>i</code>th most favorite partner. Preference orders must be
specified using C++ indexing (starting at 0). The matrix <code>pref</code> must
be of dimension <code>n-1</code> by <code>n</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of length <code>n</code> corresponding to the matchings that were
formed (using C++ indexing). E.g. if the <code>4</code>th element of this vector
is <code>0</code> then individual <code>4</code> was matched with individual <code>1</code>.
If no stable matching exists, then this function returns a vector of
zeros.
@export
</p>

<hr>
<h2 id='cpp_wrapper_irving_check_stability'>Check if a matching solves the stable roommate problem</h2><span id='topic+cpp_wrapper_irving_check_stability'></span>

<h3>Description</h3>

<p>This function checks if a given matching is stable for a particular set of
preferences. This function checks if there's an unmatched pair that would
rather be matched with each other than with their assigned partners.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpp_wrapper_irving_check_stability(pref, matchings)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_wrapper_irving_check_stability_+3A_pref">pref</code></td>
<td>
<p>is a matrix with the preference order of each individual in the
market. If there are <code>n</code> individuals, then this matrix will be of
dimension <code>n-1</code> by <code>n</code>. The <code>i,j</code>th element refers to
<code>j</code>'s <code>i</code>th most favorite partner. Preference orders must be
specified using C++ indexing (starting at 0). The matrix <code>pref</code> must
be of dimension <code>n-1</code> by <code>n</code>.</p>
</td></tr>
<tr><td><code id="cpp_wrapper_irving_check_stability_+3A_matchings">matchings</code></td>
<td>
<p>is a vector of length <code>n</code> corresponding to the
matchings that were formed (using C++ indexing). E.g. if the <code>4</code>th
element of this vector is <code>0</code> then individual <code>4</code> was matched
with individual <code>1</code>. If no stable matching exists, then this function
returns a vector of zeros.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>true if the matching is stable, false otherwise
@export
</p>

<hr>
<h2 id='cpp_wrapper_ttc'>Computes the top trading cycle algorithm</h2><span id='topic+cpp_wrapper_ttc'></span>

<h3>Description</h3>

<p>This is the C++ wrapper for the top trading cycle algorithm. Users should not
call this function directly, but instead use
<code><a href="#topic+toptrading">toptrading</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpp_wrapper_ttc(pref)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_wrapper_ttc_+3A_pref">pref</code></td>
<td>
<p>is a matrix with the preference order of all individuals in the
market. If there are <code>n</code> individuals, then this matrix will be of
dimension <code>n</code> by <code>n</code>. The <code>i,j</code>th element refers to
<code>j</code>'s <code>i</code>th most favorite partner. Preference orders must be
specified using C++ indexing (starting at 0).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the top trading cycle algorithm to find a stable trade
between agents, each with some indivisible good, and with preferences over
the goods of other agents. Each agent is matched to one other agent, and
matchings are not necessarily two-way. Agents may be matched with
themselves.
</p>


<h3>Value</h3>

<p>A vector of length <code>n</code> corresponding to the matchings being
made, so that e.g. if the <code>4</code>th element is <code>5</code> then agent
<code>4</code> was matched to agent <code>6</code>. This vector uses C++ indexing that
starts at 0.
</p>

<hr>
<h2 id='cpp_wrapper_ttc_check_stability'>Check if a one-sided matching for the top trading cycle algorithm is stable</h2><span id='topic+cpp_wrapper_ttc_check_stability'></span>

<h3>Description</h3>

<p>Check if a one-sided matching for the top trading cycle algorithm is stable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cpp_wrapper_ttc_check_stability(pref, matchings)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cpp_wrapper_ttc_check_stability_+3A_pref">pref</code></td>
<td>
<p>is a matrix with the preference order of all individuals in the
market. If there are <code>n</code> individuals, then this matrix will be of
dimension <code>n</code> by <code>n</code>. The <code>i,j</code>th element refers to
<code>j</code>'s <code>i</code>th most favorite partner. Preference orders must be
specified using C++ indexing (starting at 0).</p>
</td></tr>
<tr><td><code id="cpp_wrapper_ttc_check_stability_+3A_matchings">matchings</code></td>
<td>
<p>is a vector of length <code>n</code> corresponding to the
matchings being made, so that e.g. if the <code>4</code>th element is <code>5</code>
then agent <code>4</code> was matched to agent <code>6</code>. This vector uses C++
indexing that starts at 0.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>true if the matching is stable, false otherwise
</p>

<hr>
<h2 id='galeShapley.checkPreferences'>Check if preference order is complete</h2><span id='topic+galeShapley.checkPreferences'></span>

<h3>Description</h3>

<p>This function checks if a given preference ordering is complete. If needed,
it transforms the indices from R indices (starting at 1) to C++ indices
(starting at zero).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>galeShapley.checkPreferences(pref)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="galeShapley.checkPreferences_+3A_pref">pref</code></td>
<td>
<p>is a matrix with ordinal preference orderings for one side of the
market. Suppose that <code>pref</code> refers to the preferences of <code>n</code>
women over <code>m</code> men. In that case, <code>pref</code> will be of dimension
<code>m</code> by <code>n</code>.  The <code>i,j</code>th element refers to woman <code>j</code>'s
<code>i</code>th most favorite man. Preference orders can either be specified
using R-indexing (starting at 1) or C++ indexing (starting at 0).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with ordinal preference orderings with proper C++ indices or
NULL if the preference order is not complete.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># preferences in proper C++ indexing: galeShapley.checkPreferences(pref)
# will return pref
pref &lt;- matrix(c(
  0, 1, 0,
  1, 0, 1
), nrow = 2, ncol = 3, byrow = TRUE)
pref
galeShapley.checkPreferences(pref)

# preferences in R indexing: galeShapley.checkPreferences(pref)
# will return pref-1
pref &lt;- matrix(c(
  1, 2, 1,
  2, 1, 2
), nrow = 2, ncol = 3, byrow = TRUE)
pref
galeShapley.checkPreferences(pref)

# incomplete preferences: galeShapley.checkPreferences(pref)
# will return NULL
pref &lt;- matrix(c(
  3, 2, 1,
  2, 1, 2
), nrow = 2, ncol = 3, byrow = TRUE)
pref
galeShapley.checkPreferences(pref)
</code></pre>

<hr>
<h2 id='galeShapley.checkStability'>Check if a two-sided matching is stable</h2><span id='topic+galeShapley.checkStability'></span>

<h3>Description</h3>

<p>This function checks if a given matching is stable for a particular set of
preferences. This stability check can be applied to both the stable marriage
problem and the college admission problem. The function requires preferences
to be specified in cardinal form. If necessary, the function
<code><a href="#topic+rankIndex">rankIndex</a></code> can be used to turn ordinal preferences into cardinal
utilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>galeShapley.checkStability(
  proposerUtils,
  reviewerUtils,
  proposals,
  engagements
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="galeShapley.checkStability_+3A_proposerutils">proposerUtils</code></td>
<td>
<p>is a matrix with cardinal utilities of the proposing
side of the market. If there are <code>n</code> proposers and <code>m</code> reviewers,
then this matrix will be of dimension <code>m</code> by <code>n</code>. The
<code>i,j</code>th element refers to the payoff that proposer <code>j</code> receives
from being matched to reviewer <code>i</code>.</p>
</td></tr>
<tr><td><code id="galeShapley.checkStability_+3A_reviewerutils">reviewerUtils</code></td>
<td>
<p>is a matrix with cardinal utilities of the courted side
of the market. If there are <code>n</code> proposers and <code>m</code> reviewers, then
this matrix will be of dimension <code>n</code> by <code>m</code>. The <code>i,j</code>th
element refers to the payoff that reviewer <code>j</code> receives from being
matched to proposer <code>i</code>.</p>
</td></tr>
<tr><td><code id="galeShapley.checkStability_+3A_proposals">proposals</code></td>
<td>
<p>is a matrix that contains the number of the reviewer that a
given proposer is matched to: the first row contains the reviewer that is
matched to the first proposer, the second row contains the reviewer that is
matched to the second proposer, etc. The column dimension accommodates
proposers with multiple slots.</p>
</td></tr>
<tr><td><code id="galeShapley.checkStability_+3A_engagements">engagements</code></td>
<td>
<p>is a matrix that contains the number of the proposer that
a given reviewer is matched to. The column dimension accommodates reviewers
with multiple slots.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>true if the matching is stable, false otherwise
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define cardinal utilities
uM &lt;- matrix(c(
  0.52, 0.85,
  0.96, 0.63,
  0.82, 0.08,
  0.55, 0.34
), nrow = 4, byrow = TRUE)
uW &lt;- matrix(c(
  0.76, 0.88, 0.74, 0.02,
  0.32, 0.21, 0.02, 0.79
), ncol = 4, byrow = TRUE)
# define matching
results &lt;- list(
  proposals = matrix(c(2, 1), ncol = 1),
  engagements = matrix(c(2, 1, NA, NA), ncol = 1)
)
# check stability
galeShapley.checkStability(uM, uW, results$proposals, results$engagements)

# if preferences are in ordinal form, we can use galeShapley.validate
# to transform them into cardinal form and then use checkStability()
prefM &lt;- matrix(c(
  2, 1,
  3, 2,
  4, 4,
  1, 3
), nrow = 4, byrow = TRUE)
prefW &lt;- matrix(c(
  1, 1, 1, 2,
  2, 2, 2, 1
), ncol = 4, byrow = TRUE)
# define matching
results &lt;- list(
  proposals = matrix(c(2, 1), ncol = 1),
  engagements = matrix(c(2, 1, NA, NA), ncol = 1)
)
# check stability
pref.validated &lt;- galeShapley.validate(
  proposerPref = prefM,
  reviewerPref = prefW
)
galeShapley.checkStability(
  pref.validated$proposerUtils,
  pref.validated$reviewerUtils,
  results$proposals,
  results$engagements
)
</code></pre>

<hr>
<h2 id='galeShapley.collegeAdmissions'>Gale-Shapley Algorithm: College Admissions Problem</h2><span id='topic+galeShapley.collegeAdmissions'></span>

<h3>Description</h3>

<p>This function computes the Gale-Shapley algorithm and finds a solution to the
college admissions problem. In the student-optimal college admissions
problem, <code>n</code> students apply to <code>m</code> colleges, where each college has
<code>s</code> slots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>galeShapley.collegeAdmissions(
  studentUtils = NULL,
  collegeUtils = NULL,
  studentPref = NULL,
  collegePref = NULL,
  slots = 1,
  studentOptimal = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="galeShapley.collegeAdmissions_+3A_studentutils">studentUtils</code></td>
<td>
<p>is a matrix with cardinal utilities of the students. If
there are <code>n</code> students and <code>m</code> colleges, then this matrix will be
of dimension <code>m</code> by <code>n</code>. The <code>i,j</code>th element refers to the
payoff that student <code>j</code> receives from being matched to college
<code>i</code>.</p>
</td></tr>
<tr><td><code id="galeShapley.collegeAdmissions_+3A_collegeutils">collegeUtils</code></td>
<td>
<p>is a matrix with cardinal utilities of colleges. If there
are <code>n</code> students and <code>m</code> colleges, then this matrix will be of
dimension <code>n</code> by <code>m</code>. The <code>i,j</code>th element refers to the
payoff that college <code>j</code> receives from being matched to student
<code>i</code>.</p>
</td></tr>
<tr><td><code id="galeShapley.collegeAdmissions_+3A_studentpref">studentPref</code></td>
<td>
<p>is a matrix with the preference order of the proposing
side of the market (only required when <code>studentUtils</code> is not
provided). If there are <code>n</code> students and <code>m</code> colleges in the
market, then this matrix will be of dimension <code>m</code> by <code>n</code>. The
<code>i,j</code>th element refers to student <code>j</code>'s <code>i</code>th most favorite
college. Preference orders can either be specified using R-indexing
(starting at 1) or C++ indexing (starting at 0).</p>
</td></tr>
<tr><td><code id="galeShapley.collegeAdmissions_+3A_collegepref">collegePref</code></td>
<td>
<p>is a matrix with the preference order of the courted side
of the market (only required when <code>collegeUtils</code> is not provided). If
there are <code>n</code> students and <code>m</code> colleges in the market, then this
matrix will be of dimension <code>n</code> by <code>m</code>. The <code>i,j</code>th element
refers to individual <code>j</code>'s <code>i</code>th most favorite partner.
Preference orders can either be specified using R-indexing (starting at 1)
or C++ indexing (starting at 0).</p>
</td></tr>
<tr><td><code id="galeShapley.collegeAdmissions_+3A_slots">slots</code></td>
<td>
<p>is the number of slots that each college has available. If this
is 1, then the algorithm is identical to
<code><a href="#topic+galeShapley.marriageMarket">galeShapley.marriageMarket</a></code>. <code>slots</code> can either be a
integer or a vector. If it is an integer, then all colleges have the
same number of slots. If it is a vector, it must have as many elements
as there are colleges where each element refers to the number of slots
at a particular college.</p>
</td></tr>
<tr><td><code id="galeShapley.collegeAdmissions_+3A_studentoptimal">studentOptimal</code></td>
<td>
<p>is <code>TRUE</code> if students apply to colleges. The
resulting match is student-optimal. <code>studentOptimal</code> is <code>FALSE</code>
if colleges apply to students. The resulting match is college-optimal.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm works analogously to <a href="#topic+galeShapley.marriageMarket">galeShapley.marriageMarket</a>. The
Gale-Shapley algorithm works as follows: Students (&quot;the proposers&quot;)
sequentially make proposals to each of their most preferred available
colleges (&quot;the reviewers&quot;). A college can hold on to at most <code>s</code>
proposals at a time. A college with an open slot will accept any application
that it receives. A college that already holds on to <code>s</code> applications
will reject any application by a student that it values less than her current
set of applicants. If a college receives an application from a student that
it values more than its current set of applicants, then it will accept the
application and drop its least preferred current applicant. This process
continues until all students are matched to colleges.
</p>
<p>The Gale-Shapley Algorithm requires a complete specification of students' and
colleges' preferences over each other. Preferences can be passed on to the
algorithm in ordinal form (e.g. student 3 prefers college 1 over college 3
over college 2) or in cardinal form (e.g. student 3 receives payoff 3.14 from
being matched to college 1, payoff 2.51 from being matched to college 3 and
payoff 2.13 from being matched to college 2). Preferences must be complete,
i.e. all students must have fully specified preferences over all colleges and
vice versa.
</p>
<p>In the version of the algorithm that is implemented here, all individuals &ndash;
colleges and students &ndash; prefer being matched to anyone to not being matched
at all.
</p>
<p>The algorithm still works with an unequal number of students and slots. In
that case some students will remain unmatched or some slots will remain open.
</p>


<h3>Value</h3>

<p>A list with elements that specify which student is matched to which
college and who remains unmatched. Suppose there are <code>n</code> students and
<code>m</code> colleges with <code>s</code> slots. The list contains the following
items:
</p>

<ul>
<li><p><code>matched.students</code> is a vector of length <code>n</code> whose <code>i</code>th
element contains college that student <code>i</code> is
matched to. Students that remain unmatched will be listed as being
matched to college <code>NA</code>.
</p>
</li>
<li><p><code>matched.colleges</code> is a matrix of dimension <code>m</code> by
<code>s</code> whose <code>j</code>th row contains the students that were admitted to
college <code>j</code>. Slots that remain open show up as being matched to
student to <code>NA</code>.
</p>
</li>
<li><p><code>unmatched.students</code> is a vector that lists the remaining unmatched
students This vector will be empty when all students get matched.
</p>
</li>
<li><p><code>unmatched.colleges</code> is a vector that lists colleges with open
slots. If a college has multiple open slots, it will show up multiple
times. This vector will be empty whenever all college slots get filled.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>ncolleges &lt;- 10
nstudents &lt;- 25

# randomly generate cardinal preferences of colleges and students
collegeUtils &lt;- matrix(runif(ncolleges * nstudents), nrow = nstudents, ncol = ncolleges)
studentUtils &lt;- matrix(runif(ncolleges * nstudents), nrow = ncolleges, ncol = nstudents)

# run the student-optimal algorithm
results.studentoptimal &lt;- galeShapley.collegeAdmissions(
  studentUtils = studentUtils,
  collegeUtils = collegeUtils,
  slots = 2,
  studentOptimal = TRUE
)
results.studentoptimal

# run the college-optimal algorithm
results.collegeoptimal &lt;- galeShapley.collegeAdmissions(
  studentUtils = studentUtils,
  collegeUtils = collegeUtils,
  slots = 2,
  studentOptimal = FALSE
)
results.collegeoptimal

# transform the cardinal utilities into preference orders
collegePref &lt;- sortIndex(collegeUtils)
studentPref &lt;- sortIndex(studentUtils)

# run the student-optimal algorithm
results.studentoptimal &lt;- galeShapley.collegeAdmissions(
  studentPref = studentPref,
  collegePref = collegePref,
  slots = 2,
  studentOptimal = TRUE
)
results.studentoptimal

# run the college-optimal algorithm
results.collegeoptimal &lt;- galeShapley.collegeAdmissions(
  studentPref = studentPref,
  collegePref = collegePref,
  slots = 2,
  studentOptimal = FALSE
)
results.collegeoptimal
</code></pre>

<hr>
<h2 id='galeShapley.marriageMarket'>Gale-Shapley Algorithm: Stable Marriage Problem</h2><span id='topic+galeShapley.marriageMarket'></span><span id='topic+galeShapley'></span>

<h3>Description</h3>

<p>This function computes the Gale-Shapley algorithm and finds a solution to the
stable marriage problem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>galeShapley.marriageMarket(
  proposerUtils = NULL,
  reviewerUtils = NULL,
  proposerPref = NULL,
  reviewerPref = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="galeShapley.marriageMarket_+3A_proposerutils">proposerUtils</code></td>
<td>
<p>is a matrix with cardinal utilities of the proposing
side of the market. If there are <code>n</code> proposers and <code>m</code> reviewers,
then this matrix will be of dimension <code>m</code> by <code>n</code>. The
<code>i,j</code>th element refers to the payoff that proposer <code>j</code> receives
from being matched to proposer <code>i</code>.</p>
</td></tr>
<tr><td><code id="galeShapley.marriageMarket_+3A_reviewerutils">reviewerUtils</code></td>
<td>
<p>is a matrix with cardinal utilities of the courted side
of the market. If there are <code>n</code> proposers and <code>m</code> reviewers, then
this matrix will be of dimension <code>n</code> by <code>m</code>. The <code>i,j</code>th
element refers to the payoff that reviewer <code>j</code> receives from being
matched to proposer <code>i</code>.</p>
</td></tr>
<tr><td><code id="galeShapley.marriageMarket_+3A_proposerpref">proposerPref</code></td>
<td>
<p>is a matrix with the preference order of the proposing
side of the market. This argument is only required when
<code>proposerUtils</code> is not provided. If there are <code>n</code> proposers and
<code>m</code> reviewers in the market, then this matrix will be of dimension
<code>m</code> by <code>n</code>. The <code>i,j</code>th element refers to proposer <code>j</code>'s
<code>i</code>th most favorite reviewer. Preference orders can either be specified
using R-indexing (starting at 1) or C++ indexing (starting at 0).</p>
</td></tr>
<tr><td><code id="galeShapley.marriageMarket_+3A_reviewerpref">reviewerPref</code></td>
<td>
<p>is a matrix with the preference order of the courted side
of the market. This argument is only required when <code>reviewerUtils</code> is
not provided. If there are <code>n</code> proposers and <code>m</code> reviewers in the
market, then this matrix will be of dimension <code>n</code> by <code>m</code>. The
<code>i,j</code>th element refers to reviewer <code>j</code>'s <code>i</code>th most
favorite proposer. Preference orders can either be specified using
R-indexing (starting at 1) or C++ indexing (starting at 0).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Gale-Shapley algorithm works as follows: Single men (&quot;the proposers&quot;)
sequentially make proposals to each of their most preferred available women
(&quot;the reviewers&quot;). A woman can hold on to at most one proposal at a time. A
single woman will accept any proposal that is made to her. A woman that
already holds on to a proposal will reject any proposal by a man that she
values less than her current match. If a woman receives a proposal from a man
that she values more than her current match, then she will accept the
proposal and her previous match will join the line of bachelors. This process
continues until all men are matched to women.
</p>
<p>The Gale-Shapley Algorithm requires a complete specification of proposers'
and reviewers' preferences over each other. Preferences can be
passed on to the algorithm in ordinal form (e.g. man 3 prefers woman 1 over
woman 3 over woman 2) or in cardinal form (e.g. man 3 receives payoff 3.14 from
being matched to woman 1, payoff 2.51 from being matched to woman 3, and payoff
2.15 from being matched to woman 2). Preferences must be complete, i.e.
all proposers must have fully specified preferences over all reviewers and
vice versa.
</p>
<p>In the version of the algorithm that is implemented here, all individuals &ndash;
proposers and reviewers &ndash; prefer being matched to anyone to not being
matched at all.
</p>
<p>The algorithm still works with an unequal number of proposers and reviewers.
In that case some agents will remain unmatched.
</p>
<p>This function can also be called using <code>galeShapley</code>.
</p>


<h3>Value</h3>

<p>A list with elements that specify who is matched to whom and who
remains unmatched. Suppose there are <code>n</code> proposers and <code>m</code>
reviewers. The list contains the following items:
</p>

<ul>
<li><p><code>proposals</code> is a vector of length <code>n</code> whose <code>i</code>th
element contains the number of the reviewer that proposer <code>i</code> is
matched to. Proposers that remain unmatched will be listed as being
matched to <code>NA</code>.
</p>
</li>
<li><p><code>engagements</code> is a vector of length <code>m</code> whose <code>j</code>th
element contains the number of the proposer that reviewer <code>j</code> is
matched to. Reviwers that remain unmatched will be listed as being matched
to <code>NA</code>.
</p>
</li>
<li><p><code>single.proposers</code> is a vector that lists the remaining single
proposers. This vector will be empty whenever <code>n&lt;=m</code>.
</p>
</li>
<li><p><code>single.reviewers</code> is a vector that lists the remaining single
reviewers. This vector will be empty whenever <code>m&lt;=n</code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+galeShapley.collegeAdmissions">galeShapley.collegeAdmissions</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nmen &lt;- 5
nwomen &lt;- 4
# generate cardinal utilities
uM &lt;- matrix(runif(nmen * nwomen), nrow = nwomen, ncol = nmen)
uW &lt;- matrix(runif(nwomen * nmen), nrow = nmen, ncol = nwomen)
# run the algorithm using cardinal utilities as inputs
results &lt;- galeShapley.marriageMarket(uM, uW)
results

# transform the cardinal utilities into preference orders
prefM &lt;- sortIndex(uM)
prefW &lt;- sortIndex(uW)
# run the algorithm using preference orders as inputs
results &lt;- galeShapley.marriageMarket(proposerPref = prefM, reviewerPref = prefW)
results
</code></pre>

<hr>
<h2 id='galeShapley.validate'>Input validation of preferences</h2><span id='topic+galeShapley.validate'></span>

<h3>Description</h3>

<p>This function parses and validates the arguments that are passed on to the
Gale-Shapley Algorithm. In particular, it checks if user-defined preference
orders are complete and returns an error otherwise. If user-defined orderings
are given in terms of R indices (starting at 1), then these are transformed
into C++ indices (starting at zero).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>galeShapley.validate(
  proposerUtils = NULL,
  reviewerUtils = NULL,
  proposerPref = NULL,
  reviewerPref = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="galeShapley.validate_+3A_proposerutils">proposerUtils</code></td>
<td>
<p>is a matrix with cardinal utilities of the proposing
side of the market. If there are <code>n</code> proposers and <code>m</code> reviewers,
then this matrix will be of dimension <code>m</code> by <code>n</code>. The
<code>i,j</code>th element refers to the payoff that proposer <code>j</code> receives
from being matched to reviewer <code>i</code>.</p>
</td></tr>
<tr><td><code id="galeShapley.validate_+3A_reviewerutils">reviewerUtils</code></td>
<td>
<p>is a matrix with cardinal utilities of the courted side
of the market. If there are <code>n</code> proposers and <code>m</code> reviewers, then
this matrix will be of dimension <code>n</code> by <code>m</code>. The <code>i,j</code>th
element refers to the payoff that reviewer <code>j</code> receives from being
matched to proposer <code>i</code>.</p>
</td></tr>
<tr><td><code id="galeShapley.validate_+3A_proposerpref">proposerPref</code></td>
<td>
<p>is a matrix with the preference order of the proposing
side of the market (only required when <code>proposerUtils</code> is not
provided). If there are <code>n</code> proposers and <code>m</code> reviewers in the
market, then this matrix will be of dimension <code>m</code> by <code>n</code>. The
<code>i,j</code>th element refers to proposer <code>j</code>'s <code>i</code>th most favorite
reviewer. Preference orders can either be specified using R-indexing
(starting at 1) or C++ indexing (starting at 0).</p>
</td></tr>
<tr><td><code id="galeShapley.validate_+3A_reviewerpref">reviewerPref</code></td>
<td>
<p>is a matrix with the preference order of the courted side
of the market (only required when <code>reviewerUtils</code> is not provided). If
there are <code>n</code> proposers and <code>m</code> reviewers in the market, then
this matrix will be of dimension <code>n</code> by <code>m</code>. The <code>i,j</code>th
element refers to reviewer <code>j</code>'s <code>i</code>th most favorite proposer.
Preference orders can either be specified using R-indexing (starting at 1)
or C++ indexing (starting at 0).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing <code>proposerUtils</code>, <code>reviewerUtils</code>,
<code>proposerPref</code> (<code>reviewerPref</code> are not required after they are
translated into <code>reviewerUtils</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'># market size
nmen &lt;- 5
nwomen &lt;- 4

# generate cardinal utilities
uM &lt;- matrix(runif(nmen * nwomen), nrow = nwomen, ncol = nmen)
uW &lt;- matrix(runif(nwomen * nmen), nrow = nmen, ncol = nwomen)

# turn cardinal utilities into ordinal preferences
prefM &lt;- sortIndex(uM)
prefW &lt;- sortIndex(uW)

# validate cardinal preferences
preferences &lt;- galeShapley.validate(uM, uW)
preferences

# validate ordinal preferences
preferences &lt;- galeShapley.validate(proposerPref = prefM, reviewerPref = prefW)
preferences

# validate ordinal preferences when these are in R style indexing
# (instead of C++ style indexing)
preferences &lt;- galeShapley.validate(proposerPref = prefM + 1, reviewerPref = prefW + 1)
preferences

# validate preferences when proposer-side is cardinal and reviewer-side is ordinal
preferences &lt;- galeShapley.validate(proposerUtils = uM, reviewerPref = prefW)
preferences
</code></pre>

<hr>
<h2 id='matchingR-deprecated'>Deprecated Functions in matchingR</h2><span id='topic+matchingR-deprecated'></span><span id='topic+validateInputs'></span><span id='topic+checkStability'></span><span id='topic+checkPreferenceOrder'></span><span id='topic+one2many'></span><span id='topic+many2one'></span><span id='topic+one2one'></span><span id='topic+galeShapleyMatching'></span><span id='topic+stableRoommateMatching'></span><span id='topic+onesided'></span><span id='topic+checkStabilityRoommate'></span><span id='topic+validateInputsOneSided'></span><span id='topic+checkPreferenceOrderOnesided'></span><span id='topic+topTradingCycle'></span><span id='topic+checkStabilityTopTradingCycle'></span>

<h3>Description</h3>

<p>These functions are provided for compatibility with older version of
the matchingR package. Eventually, these functions will be removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validateInputs(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matchingR-deprecated_+3A_...">...</code></td>
<td>
<p>generic set of parameters &mdash; see documentation of new functions</p>
</td></tr>
</table>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: right;">
  <code>validateInputs</code> </td><td style="text-align: left;"> was replaced by <code><a href="#topic+galeShapley.validate">galeShapley.validate</a></code></td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>checkStability</code> </td><td style="text-align: left;"> was replaced by <code><a href="#topic+galeShapley.checkStability">galeShapley.checkStability</a></code></td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>checkPreferenceOrder</code> </td><td style="text-align: left;"> was replaced by <code><a href="#topic+galeShapley.checkPreferences">galeShapley.checkPreferences</a></code></td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>one2many</code> </td><td style="text-align: left;"> now mapped into <code><a href="#topic+galeShapley.collegeAdmissions">galeShapley.collegeAdmissions</a></code></td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>many2one</code> </td><td style="text-align: left;"> now mapped into <code><a href="#topic+galeShapley.collegeAdmissions">galeShapley.collegeAdmissions</a></code></td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>one2one</code> </td><td style="text-align: left;"> was replaced by <code><a href="#topic+galeShapley.marriageMarket">galeShapley.marriageMarket</a></code></td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>galeShapleyMatching</code> </td><td style="text-align: left;"> was replaced by <code><a href="#topic+cpp_wrapper_galeshapley">cpp_wrapper_galeshapley</a></code></td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>stableRoommateMatching</code> </td><td style="text-align: left;"> was replaced by <code><a href="#topic+cpp_wrapper_irving">cpp_wrapper_irving</a></code></td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>onesided</code> </td><td style="text-align: left;"> was replaced by <code><a href="#topic+roommate">roommate</a></code></td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>checkStabilityRoommate</code> </td><td style="text-align: left;"> was replaced by <code><a href="#topic+cpp_wrapper_irving_check_stability">cpp_wrapper_irving_check_stability</a></code></td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>validateInputsOneSided</code> </td><td style="text-align: left;"> was replaced by <code><a href="#topic+roommate.validate">roommate.validate</a></code></td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>checkPreferenceOrderOnesided</code> </td><td style="text-align: left;"> was replaced by <code><a href="#topic+roommate.checkPreferences">roommate.checkPreferences</a></code></td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>topTradingCycle</code> </td><td style="text-align: left;"> was replaced by <code><a href="#topic+cpp_wrapper_ttc">cpp_wrapper_ttc</a></code></td>
</tr>
<tr>
 <td style="text-align: right;">
  <code>checkStabilityTopTradingCycle</code> </td><td style="text-align: left;"> was replaced by <code><a href="#topic+cpp_wrapper_ttc_check_stability">cpp_wrapper_ttc_check_stability</a></code></td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>


<hr>
<h2 id='matchingR-package'>matchingR: Matching Algorithms in R and C++</h2><span id='topic+matchingR'></span><span id='topic+matchingR-package'></span>

<h3>Description</h3>

<p>matchingR is an R package which quickly computes a variety of
matching algorithms for one-sided and two-sided markets. This package
implements
</p>

<ul>
<li><p>the Gale-Shapley Algorithm to compute the stable matching for
two-sided markets, such as the stable marriage problem and the
college-admissions problem
</p>
</li>
<li><p>Irving's Algorithm to compute the stable matching for one-sided
markets such as the stable roommates problem
</p>
</li>
<li><p>the top trading cycle algorithm for the indivisible goods trading
problem.
</p>
</li></ul>

<p>All matching algorithms are implemented in <code>C++</code> and can therefore be
computed quickly. The package may be useful when the number of market
participants is large or when many matchings need to be computed (e.g. for
extensive simulations or for estimation purposes). The Gale-Shapley
function of this package has successfully been used to simulate preferences
and compute the matching with 30,000 participants on each side of the
market.
</p>
<p>Matching markets are common in practice and widely studied by
economists. Popular examples include
</p>

<ul>
<li><p>the National Resident Matching Program that matches graduates from
medical school to residency programs at teaching hospitals throughout the
United States
</p>
</li>
<li><p>the matching of students to schools including the New York City High
School Match or the the Boston Public School Match (and many more)
</p>
</li>
<li><p>the matching of kidney donors to recipients in kidney exchanges.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Jan Tilly, Nick Janetos
</p>


<h3>References</h3>

<p>Gale, D. and Shapley, L.S. (1962). College admissions and the
stability of marriage. <em>The American Mathematical Monthly</em>, 69(1):
9&ndash;15.
</p>
<p>Irving, R. W. (1985). An efficient algorithm for the &quot;stable
roommates&quot; problem. <em>Journal of Algorithms</em>, 6(4): 577&ndash;595
</p>
<p>Shapley, L., &amp; Scarf, H. (1974). On cores and indivisibility.
<em>Journal of Mathematical Economics</em>, 1(1), 23-37.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/jtilly/matchingR/">https://github.com/jtilly/matchingR/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/jtilly/matchingR/issues/">https://github.com/jtilly/matchingR/issues/</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># stable marriage problem
set.seed(1)
nmen &lt;- 25
nwomen &lt;- 20
uM &lt;- matrix(runif(nmen * nwomen), nrow = nwomen, ncol = nmen)
uW &lt;- matrix(runif(nwomen * nmen), nrow = nmen, ncol = nwomen)
results &lt;- galeShapley.marriageMarket(uM, uW)
galeShapley.checkStability(uM, uW, results$proposals, results$engagements)

# college admissions problem
nstudents &lt;- 25
ncolleges &lt;- 5
uStudents &lt;- matrix(runif(nstudents * ncolleges), nrow = ncolleges, ncol = nstudents)
uColleges &lt;- matrix(runif(nstudents * ncolleges), nrow = nstudents, ncol = ncolleges)
results &lt;- galeShapley.collegeAdmissions(
  studentUtils = uStudents,
  collegeUtils = uColleges,
  slots = 4
)
results
# check stability
galeShapley.checkStability(
  uStudents,
  uColleges,
  results$matched.students,
  results$matched.colleges
)

# stable roommate problem
set.seed(2)
N &lt;- 10
u &lt;- matrix(runif(N^2), nrow = N, ncol = N)
results &lt;- roommate(utils = u)
results
# check stability
roommate.checkStability(utils = u, matching = results)

# top trading cycle algorithm
N &lt;- 10
u &lt;- matrix(runif(N^2), nrow = N, ncol = N)
results &lt;- toptrading(utils = u)
results
# check stability
toptrading.checkStability(utils = u, matching = results)
</code></pre>

<hr>
<h2 id='rankIndex'>Rank elements within column of a matrix</h2><span id='topic+rankIndex'></span>

<h3>Description</h3>

<p>This function returns the rank of each element within each column of a
matrix. The highest element receives the highest rank.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rankIndex(sortedIdx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rankIndex_+3A_sortedidx">sortedIdx</code></td>
<td>
<p>is the input matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a rank matrix
</p>

<hr>
<h2 id='repcol'>Repeat each column of a matrix n times</h2><span id='topic+repcol'></span>

<h3>Description</h3>

<p>This function repeats each column of a matrix n times
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repcol(x, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repcol_+3A_x">x</code></td>
<td>
<p>is the input matrix</p>
</td></tr>
<tr><td><code id="repcol_+3A_n">n</code></td>
<td>
<p>is the number of repetitions (can be a vector)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with repeated columns
</p>

<hr>
<h2 id='reprow'>Repeat each row of a matrix n times</h2><span id='topic+reprow'></span>

<h3>Description</h3>

<p>This function repeats each row of a matrix n times
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reprow(x, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reprow_+3A_x">x</code></td>
<td>
<p>is the input matrix</p>
</td></tr>
<tr><td><code id="reprow_+3A_n">n</code></td>
<td>
<p>is the number of repetitions (can be a vector)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with repeated rows
</p>

<hr>
<h2 id='roommate'>Compute matching for one-sided markets</h2><span id='topic+roommate'></span>

<h3>Description</h3>

<p>This function computes the Irving (1985) algorithm for finding a stable
matching in a one-sided matching market.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roommate(utils = NULL, pref = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roommate_+3A_utils">utils</code></td>
<td>
<p>is a matrix with cardinal utilities for each individual in the
market. If there are <code>n</code> individuals, then this matrix will be of
dimension <code>n-1</code> by <code>n</code>. Column <code>j</code> refers to the payoff that
individual <code>j</code> receives from being matched to individual <code>1, 2,
..., j-1, j+1, ...n</code>. If a square matrix is passed as <code>utils</code>, then
the main diagonal will be removed.</p>
</td></tr>
<tr><td><code id="roommate_+3A_pref">pref</code></td>
<td>
<p>is a matrix with the preference order of each individual in the
market. This argument is only required when <code>utils</code> is not provided.
If there are <code>n</code> individuals, then this matrix will be of dimension
<code>n-1</code> by <code>n</code>. The <code>i,j</code>th element refers to <code>j</code>'s
<code>i</code>th most favorite partner. Preference orders can either be specified
using R-indexing (starting at 1) or C++ indexing (starting at 0). The
matrix <code>pref</code> must be of dimension <code>n-1</code> by <code>n</code>. Otherwise,
the function will throw an error.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Consider the following example: A set of <code>n</code> potential roommates, each
with ranked preferences over all the other potential roommates, are to be
matched to rooms, two roommates per room. A matching is stable if there is no
roommate <code>r1</code> that would rather be matched to some other roommate
<code>d2</code> than to his current roommate <code>r2</code> and the other roommate
<code>d2</code> would rather be matched to <code>r1</code> than to his current roommate
<code>d1</code>.
</p>
<p>The algorithm works in two stages. In the first stage, all participants begin
unmatched, then, in sequence, begin making proposals to other potential roommates,
beginning with their most preferred roommate. If a roommate receives a proposal,
he either accepts it if he has no other proposal which is better, or rejects it
otherwise. If this stage ends with a roommate who has no proposals, then there
is no stable matching and the algorithm terminates.
</p>
<p>In the second stage, the algorithm proceeds by finding and eliminating
rotations. Roughly speaking, a rotation is a sequence of pairs of agents,
such that the first agent in each pair is least preferred by the second
agent in that pair (of all the agents remaining to be matched), the second
agent in each pair is most preferred by the first agent in each pair (of
all the agents remaining to be matched) and the second agent in the
successive pair is the second most preferred agent (of the agents
remaining to be matched) of the first agent in the succeeding
pair, where here 'successive' is taken to mean 'modulo <code>m</code>',
where <code>m</code> is the length of the rotation. Once a rotation has been
identified, it can be eliminated in the following way: For each pair, the
second agent in the pair rejects the first agent in the pair (recall that the
second agent hates the first agent, while the first agent loves the second
agent), and the first agent then proceeds to propose to the second agent
in the succeeding pair. If at any point during this process, an agent
no longer has any agents left to propose to or be proposed to from, then
there is no stable matching and the algorithm terminates.
</p>
<p>Otherwise, at the end, every agent is left proposing to an agent who is also
proposing back to them, which results in a stable matching.
</p>
<p>Note that neither existence nor uniqueness is guaranteed, this algorithm
finds one matching, not all of them. If no matching exists, this function
returns <code>NULL</code>.
</p>


<h3>Value</h3>

<p>A vector of length <code>n</code> corresponding to the matchings that were
formed. E.g. if the <code>4</code>th element of this vector is <code>6</code> then
individual <code>4</code> was matched with individual <code>6</code>. If no stable
matching exists, then this function returns <code>NULL</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example using cardinal utilities
utils &lt;- matrix(c(
  -1.63, 0.69, -1.38, -0.03,
  2.91, -0.52, 0.52, 0.22,
  0.53, -0.52, -1.18, 0.53
), byrow = TRUE, ncol = 4, nrow = 3)
utils
results &lt;- roommate(utils = utils)
results

# example using preference orders
pref &lt;- matrix(c(
  3, 1, 2, 3,
  4, 3, 4, 2,
  2, 4, 1, 1
), byrow = TRUE, ncol = 4)
pref
results &lt;- roommate(pref = pref)
results
</code></pre>

<hr>
<h2 id='roommate.checkPreferences'>Check if preference order for a one-sided market is complete</h2><span id='topic+roommate.checkPreferences'></span>

<h3>Description</h3>

<p>Check if preference order for a one-sided market is complete
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roommate.checkPreferences(pref)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roommate.checkPreferences_+3A_pref">pref</code></td>
<td>
<p>is a matrix with the preference order of each individual in the
market. This argument is only required when <code>utils</code> is not provided.
If there are <code>n</code> individuals, then this matrix will be of dimension
<code>n-1</code> by <code>n</code>. The <code>i,j</code>th element refers to <code>j</code>'s
<code>i</code>th most favorite partner. Preference orders can either be specified
using R-indexing (starting at 1) or C++ indexing (starting at 0). The
matrix <code>pref</code> must be of dimension <code>n-1</code> by <code>n</code>. Otherwise,
the function will throw an error.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with preference orderings with proper C++ indices or NULL if
the preference order is not complete.
</p>

<hr>
<h2 id='roommate.checkStability'>Check if a roommate matching is stable</h2><span id='topic+roommate.checkStability'></span>

<h3>Description</h3>

<p>This function checks if a particular roommate matching is stable. A matching
is stable if there is no roommate <code>r1</code> that would rather be matched to
some other roommate <code>d2</code> than to his current roommate <code>r2</code> and the
other roommate <code>d2</code> would rather be matched to <code>r1</code> than to his
current roommate <code>d1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roommate.checkStability(utils = NULL, pref = NULL, matching)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roommate.checkStability_+3A_utils">utils</code></td>
<td>
<p>is a matrix with cardinal utilities for each individual in the
market. If there are <code>n</code> individuals, then this matrix will be of
dimension <code>n-1</code> by <code>n</code>. Column <code>j</code> refers to the payoff that
individual <code>j</code> receives from being matched to individual <code>1, 2,
..., j-1, j+1, ...n</code>. If a square matrix is passed as <code>utils</code>, then
the main diagonal will be removed.</p>
</td></tr>
<tr><td><code id="roommate.checkStability_+3A_pref">pref</code></td>
<td>
<p>is a matrix with the preference order of each individual in the
market. This argument is only required when <code>utils</code> is not provided.
If there are <code>n</code> individuals, then this matrix will be of dimension
<code>n-1</code> by <code>n</code>. The <code>i,j</code>th element refers to <code>j</code>'s
<code>i</code>th most favorite partner. Preference orders can either be specified
using R-indexing (starting at 1) or C++ indexing (starting at 0). The
matrix <code>pref</code> must be of dimension <code>n-1</code> by <code>n</code>. Otherwise,
the function will throw an error.</p>
</td></tr>
<tr><td><code id="roommate.checkStability_+3A_matching">matching</code></td>
<td>
<p>is a vector of length <code>n</code> corresponding to the matchings
that were formed. E.g. if the <code>4</code>th element of this vector is <code>6</code>
then individual <code>4</code> was matched with individual <code>6</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>true if stable, false if not
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define preferences
pref &lt;- matrix(c(
  3, 1, 2, 3,
  4, 3, 4, 2,
  2, 4, 1, 1
), byrow = TRUE, ncol = 4)
pref
# compute matching
results &lt;- roommate(pref = pref)
results
# check if matching is stable
roommate.checkStability(pref = pref, matching = results)
</code></pre>

<hr>
<h2 id='roommate.validate'>Input validation for one-sided markets</h2><span id='topic+roommate.validate'></span>

<h3>Description</h3>

<p>This function parses and validates the arguments for the function
<code><a href="#topic+roommate">roommate</a></code>. It returns the validates arguments. This function
is called as part of <code><a href="#topic+roommate">roommate</a></code>. Only one of the
arguments needs to be provided.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roommate.validate(utils = NULL, pref = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roommate.validate_+3A_utils">utils</code></td>
<td>
<p>is a matrix with cardinal utilities for each individual in the
market. If there are <code>n</code> individuals, then this matrix will be of
dimension <code>n-1</code> by <code>n</code>. Column <code>j</code> refers to the payoff that
individual <code>j</code> receives from being matched to individual <code>1, 2,
..., j-1, j+1, ...n</code>. If a square matrix is passed as <code>utils</code>, then
the main diagonal will be removed.</p>
</td></tr>
<tr><td><code id="roommate.validate_+3A_pref">pref</code></td>
<td>
<p>is a matrix with the preference order of each individual in the
market. This argument is only required when <code>utils</code> is not provided.
If there are <code>n</code> individuals, then this matrix will be of dimension
<code>n-1</code> by <code>n</code>. The <code>i,j</code>th element refers to <code>j</code>'s
<code>i</code>th most favorite partner. Preference orders can either be specified
using R-indexing (starting at 1) or C++ indexing (starting at 0). The
matrix <code>pref</code> must be of dimension <code>n-1</code> by <code>n</code>. Otherwise,
the function will throw an error.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The validated preference ordering using C++ indexing.
</p>

<hr>
<h2 id='sortIndex'>Sort indices of a matrix within a column</h2><span id='topic+sortIndex'></span>

<h3>Description</h3>

<p>Within each column of a matrix, this function returns the indices of each
element in descending order
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sortIndex(u)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sortIndex_+3A_u">u</code></td>
<td>
<p>is the input matrix with cardinal preferences</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with sorted indices (the agents' ordinal preferences)
</p>

<hr>
<h2 id='sortIndexOneSided'>Ranks elements with column of a matrix, assuming a one-sided market.</h2><span id='topic+sortIndexOneSided'></span>

<h3>Description</h3>

<p>Returns the rank of each element with each column of a matrix. So, if row 34
is the highest number for column 3, then the first row of column 3 will be
34 &ndash; unless it is column 34, in which case it will be 35, to adjust for the
fact that this is a single-sided market.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sortIndexOneSided(u)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sortIndexOneSided_+3A_u">u</code></td>
<td>
<p>A matrix with agents' cardinal preferences. Column i is agent i's
preferences.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix with the agents' ordinal preferences
</p>

<hr>
<h2 id='toptrading'>Compute the top trading cycle algorithm</h2><span id='topic+toptrading'></span>

<h3>Description</h3>

<p>This package implements the top trading cycle algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toptrading(utils = NULL, pref = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toptrading_+3A_utils">utils</code></td>
<td>
<p>is a matrix with cardinal utilities of all individuals in the
market. If there are <code>n</code> individuals, then this matrix will be of
dimension <code>n</code> by <code>n</code>. The <code>i,j</code>th element refers to the
payoff that individual <code>j</code> receives from being matched to individual
<code>i</code>.</p>
</td></tr>
<tr><td><code id="toptrading_+3A_pref">pref</code></td>
<td>
<p>is a matrix with the preference order of all individuals in the
market. This argument is only required when <code>utils</code> is not provided.
If there are <code>n</code> individuals, then this matrix will be of dimension
<code>n</code> by <code>n</code>. The <code>i,j</code>th element refers to <code>j</code>'s
<code>i</code>th most favorite partner. Preference orders can either be specified
using R-indexing (starting at 1) or C++ indexing (starting at 0).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The top trading algorithm solves the following problem: A set of <code>n</code> agents
each currently own their own home, and have preferences over the homes of other
agents. The agents may trade their homes in some way, the problem is to identify
a set of trades between agents so that no subset of agents can defect from the
rest of the group, and by trading within themselves improve their own payoffs.
</p>
<p>Roughly speaking, the top trading cycle proceeds by identifying cycles of
agents, then eliminating those cycles until no agents remain. A cycle is a
sequence of agents such that each agent most prefers the next agent's home
(out of the remaining unmatched agents), and the last agent in the sequence
most prefers the first agent in the sequence's home.
</p>
<p>The top trading cycle is guaranteed to produce a unique outcome, and that
outcome is the unique outcome in the core, meaning there is no other outcome
with the stability property described above.
</p>


<h3>Value</h3>

<p>A vector of length <code>n</code> corresponding to the matchings being
made, so that e.g. if the <code>4</code>th element is <code>6</code> then agent
<code>4</code> was matched to agent <code>6</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example using cardinal utilities
utils &lt;- matrix(c(
  -1.4, -0.66, -0.45, 0.03,
  0.72, 1.71, 0.59, 0.07,
  0.44, 1.76, 1.71, -0.27,
  0.26, 2.18, 1.4, 0.12
), byrow = TRUE, nrow = 4)
utils
results &lt;- toptrading(utils = utils)
results

# example using ordinal preferences
pref &lt;- matrix(c(
  2, 4, 3, 4,
  3, 3, 4, 2,
  4, 2, 2, 1,
  1, 1, 1, 3
), byrow = TRUE, nrow = 4)
pref
results &lt;- toptrading(pref = pref)
results
</code></pre>

<hr>
<h2 id='toptrading.checkStability'>Check if there are any pairs of agents who would rather swap houses with
each other rather than be with their own two current respective partners.</h2><span id='topic+toptrading.checkStability'></span>

<h3>Description</h3>

<p>Check if there are any pairs of agents who would rather swap houses with
each other rather than be with their own two current respective partners.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toptrading.checkStability(utils = NULL, pref = NULL, matchings)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="toptrading.checkStability_+3A_utils">utils</code></td>
<td>
<p>is a matrix with cardinal utilities of all individuals in the
market. If there are <code>n</code> individuals, then this matrix will be of
dimension <code>n</code> by <code>n</code>. The <code>i,j</code>th element refers to the
payoff that individual <code>j</code> receives from being matched to individual
<code>i</code>.</p>
</td></tr>
<tr><td><code id="toptrading.checkStability_+3A_pref">pref</code></td>
<td>
<p>is a matrix with the preference order of all individuals in the
market. This argument is only required when <code>utils</code> is not provided.
If there are <code>n</code> individuals, then this matrix will be of dimension
<code>n</code> by <code>n</code>. The <code>i,j</code>th element refers to <code>j</code>'s
<code>i</code>th most favorite partner. Preference orders can either be specified
using R-indexing (starting at 1) or C++ indexing (starting at 0).</p>
</td></tr>
<tr><td><code id="toptrading.checkStability_+3A_matchings">matchings</code></td>
<td>
<p>is a vector of length <code>n</code> corresponding to the
matchings being made, so that e.g. if the <code>4</code>th element is <code>6</code>
then agent <code>4</code> was matched to agent <code>6</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>true if the matching is stable, false otherwise
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pref &lt;- matrix(c(
  2, 4, 3, 4,
  3, 3, 4, 2,
  4, 2, 2, 1,
  1, 1, 1, 3
), byrow = TRUE, nrow = 4)
pref
results &lt;- toptrading(pref = pref)
results
toptrading.checkStability(pref = pref, matchings = results)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
