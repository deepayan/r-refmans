<!DOCTYPE html><html lang="en"><head><title>Help for package gremlin</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gremlin}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#gremlin-package'><p>Mixed-Effects REML Incorporating Generalized Inverses</p></a></li>
<li><a href='#algChk'><p>Optimization Algorithm Checks.</p></a></li>
<li><a href='#anova.gremlin'><p>anova() for gremlin objects</p></a></li>
<li><a href='#ccFun'><p>Convergence Criteria Checks for REML.</p></a></li>
<li><a href='#chol2inv_ii'><p>Partial sparse matrix inverse from a Cholesky factorization.</p></a></li>
<li><a href='#covFun'><p>(Co)variance parameter transformations.</p></a></li>
<li><a href='#deltaSE'><p>Delta Method to Calculate Standard Errors for Functions of (Co)variances.</p></a></li>
<li><a href='#fixef.gremlin'><p>Fixed Effect Estimates of <code>class</code> &lsquo;gremlin&rsquo;</p></a></li>
<li><a href='#gremlin'><p>Mixed-effect modeling functions.</p></a></li>
<li><a href='#gremlinControl'><p>Advanced Options for Mixed-effect modeling functions.</p></a></li>
<li><a href='#logLik.gremlin'><p>Methods to extract log-likelihood and information criterion of a gremlin</p>
model.</a></li>
<li><a href='#Mrode11'><p>Weight gain data.</p></a></li>
<li><a href='#nobs.gremlin'><p>Number of observations in data from gremlin model fit objects</p></a></li>
<li><a href='#reml'><p>REML optimization algorithms for mixed-effect models.</p></a></li>
<li><a href='#remlIt'><p>Mixed-effect model Restricted Maximum Likelihood (REML) iterations.</p></a></li>
<li><a href='#residuals.gremlin'><p>Residuals of <code>class</code> &lsquo;gremlin&rsquo;</p></a></li>
<li><a href='#runtime'><p>Time to execute the gremlin model</p></a></li>
<li><a href='#summary.gremlin'><p>Gremlin model summary.</p></a></li>
<li><a href='#tr'><p>Matrix trace methods.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Mixed-Effects REML Incorporating Generalized Inverses</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.0</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/matthewwolak/gremlin">https://github.com/matthewwolak/gremlin</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/matthewwolak/gremlin/issues">https://github.com/matthewwolak/gremlin/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>Matrix</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, nlme</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit linear mixed-effects models using restricted (or residual)
    maximum likelihood (REML) and with generalized inverse matrices to specify
    covariance structures for random effects. In particular, the package is
    suited to fit quantitative genetic mixed models, often referred to as
    'animal models'. Implements the average information algorithm as the main
    tool to maximize the restricted log-likelihood, but with other algorithms
    available.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> | file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-11-04 17:08:12 UTC; mew0099</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthew Wolak <a href="https://orcid.org/0000-0002-7962-0071"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthew Wolak &lt;matthewwolak@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-11-04 18:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='gremlin-package'>Mixed-Effects REML Incorporating Generalized Inverses</h2><span id='topic+gremlin-package'></span>

<h3>Description</h3>

<p>Fit linear mixed-effects models using restricted (or residual) maximum
likelihood (REML) and with generalized inverse matrices to specify covariance
structures for random effects. In particular, the package is suited to fit
quantitative genetic mixed models, often referred to as 'animal models'
(Henderson 1973). Implements the average information algorithm (Johnson &amp;
Thompson 1995; Gilmour et al. 1995; Meyer &amp; Smith 1996) as the main tool to
maximize the restricted log-likelihood, but with other algorithms available.
</p>


<h3>Details</h3>

<p>The average information algorithm combined with sparse matrix techniques can
potentially make model fitting very efficient.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Matthew Wolak <a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a> (<a href="https://orcid.org/0000-0002-7962-0071">ORCID</a>)
</p>


<h3>References</h3>

<p>Henderson, C.R. 1973. Sire evaluation and genetic trends. Journal of Animal
Science 1973:10-41. 
</p>
<p>Johnson, D.L. and R. Thompson. 1995. Restricted maximum likelihood
estimation of variance components for univariate animal models using sparse
matrix techniques and average information. Journal of Dairy Science
78:449-456.
</p>
<p>Gilmour, A.R., R. Thompson, and B.R. Cullis. 1995. Average information
REML: An efficient algorithm for variance parameter estimation in linear
mixed models. Biometrics 51:1440-1450.
</p>
<p>Meyer, K. and S.P. Smith. 1996. Restricted maximum likelihood estimation for
animal models using derivatives of the likelihood. Genetics, Selection, and
Evolution 28:23-49.
</p>
<p>Mrode, R.A. 2005. Linear Models for the Prediction of Animal Breeding
Values, 2nd ed. CABI Publishing, Cambridge, MA, USA.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/matthewwolak/gremlin">https://github.com/matthewwolak/gremlin</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/matthewwolak/gremlin/issues">https://github.com/matthewwolak/gremlin/issues</a>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
  # Following the example from Mrode 2005, chapter 11.
  library(nadiv)  #&lt;-- to construct inverse of the numerator relatedness matrix
  pedMrode11 &lt;- prepPed(Mrode11[, 1:3])
  Ainv &lt;- makeAinv(pedMrode11)$Ainv

  gr11lmm &lt;- gremlin(WWG11 ~ sex - 1,
random = ~ calf,
data = Mrode11,
ginverse = list(calf = Ainv),
Gstart = matrix(0.2), Rstart = matrix(0.4),  #&lt;-- specify starting values
maxit = 15,    #&lt;-- maximum iterations
     v = 2, vit = 1,  #&lt;-- moderate screen output (`v`) every iteration (`vit`)
     algit = "AI")  #&lt;-- only use Average Information algorithm iterations
  summary(gr11lmm)

  # Compare the model to a Linear Model with no random effects
  ## Use `update()` to update the model
  gr11lm &lt;- update(gr11lmm, random = ~ 1)  #&lt;-- `~1`=drop all random effects
  summary(gr11lm)

  # Do analysis of variance between the two models
  ## See AIC or evaluate likelihood ratio against a Chi-squared distribution
  anova(gr11lm, gr11lmm)

## End(Not run)
</code></pre>

<hr>
<h2 id='algChk'>Optimization Algorithm Checks.</h2><span id='topic+algChk'></span>

<h3>Description</h3>

<p>Check and/or set optimization algorithms to use. Intended for internal use
within gremlin
</p>


<h3>Usage</h3>

<pre><code class='language-R'>algChk(algit, maxit, ctrl, mc)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="algChk_+3A_algit">algit</code></td>
<td>
<p>A character <code>vector</code> of algorithms for each iteration.</p>
</td></tr>
<tr><td><code id="algChk_+3A_maxit">maxit</code></td>
<td>
<p>An <code>integer</code> indicating the number of REML iterations.</p>
</td></tr>
<tr><td><code id="algChk_+3A_ctrl">ctrl</code></td>
<td>
<p>A <code>list</code> of arguments set by <code>gremlinControl</code>.</p>
</td></tr>
<tr><td><code id="algChk_+3A_mc">mc</code></td>
<td>
<p>A model <code>call</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> containing a vector <code>algit</code> specifying the currently
implemented optimization algorithms for each iteration along with a vector
each containing the type of first (<code>fdit</code>) and second (<code>sdit</code>)
derivatives for each iteration (else <code>NA</code> if either is not applicable).
</p>


<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>

<hr>
<h2 id='anova.gremlin'>anova() for gremlin objects</h2><span id='topic+anova.gremlin'></span>

<h3>Description</h3>

<p>REML Likelihood Ratio Tests for gremlin models using anova()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gremlin'
anova(object, ..., model.names = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="anova.gremlin_+3A_object">object</code></td>
<td>
<p>An object of <code>class</code> &lsquo;gremlin&rsquo;.</p>
</td></tr>
<tr><td><code id="anova.gremlin_+3A_...">...</code></td>
<td>
<p>Additional objects of <code>class</code> &lsquo;gremlin&rsquo;.</p>
</td></tr>
<tr><td><code id="anova.gremlin_+3A_model.names">model.names</code></td>
<td>
<p>Optional character vector with model names to be used in
the anova table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> containing the nested comparison of model
<code>object</code>s via a REML likelihood ratio test.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mod11 &lt;- gremlin(WWG11 ~ sex - 1,
random = ~ sire,
data = Mrode11)
mod11red &lt;- gremlinR(WWG11 ~ sex - 1, data = Mrode11)
anova(mod11, mod11red)
</code></pre>

<hr>
<h2 id='ccFun'>Convergence Criteria Checks for REML.</h2><span id='topic+ccFun'></span><span id='topic+ccFun+2C'></span><span id='topic+ccFun1+2C'></span><span id='topic+ccFun2+2C'></span><span id='topic+ccFun3+2C'></span><span id='topic+ccFun4'></span><span id='topic+ccFun1'></span><span id='topic+ccFun2'></span><span id='topic+ccFun3'></span>

<h3>Description</h3>

<p>Determine whether the optimization has converged on a maximum of the 
log-likelihood function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ccFun(obj = NULL)

ccFun1(obj = NULL)

ccFun2(obj = NULL)

ccFun3(obj = NULL)

ccFun4(obj = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ccFun_+3A_obj">obj</code></td>
<td>
<p>Optional gremlin model object. If <code>NULL</code> then the necessary
variables are taken from the parent environment, if present</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>logical</code> value whether the current REML iteration has passed
the convergence criteria
</p>


<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>


<h3>References</h3>

<p>Meyer, K. 2019. WOMBAT A program for mixed model analyses by restricted
maximum likelihood. User Notes. 27 September 2019.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  grS2 &lt;- gremlinR(WWG11 ~ sex, random = ~ sire, data = Mrode11, maxit = 2)
    ccFun1(grS2)
    ccFun2(grS2)
  grS &lt;- gremlinR(WWG11 ~ sex, random = ~ sire, data = Mrode11)
    ccFun(grS)

</code></pre>

<hr>
<h2 id='chol2inv_ii'>Partial sparse matrix inverse from a Cholesky factorization.</h2><span id='topic+chol2inv_ii'></span>

<h3>Description</h3>

<p>Only calculate values of a sparse matrix inverse corresponding to non-zero
locations for the Cholesky factorization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chol2inv_ii(L, Z = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="chol2inv_ii_+3A_l">L</code></td>
<td>
<p>A lower-triangle Cholesky factorization ($<strong>L L'</strong> = <strong>C</strong>$).</p>
</td></tr>
<tr><td><code id="chol2inv_ii_+3A_z">Z</code></td>
<td>
<p>A sparse matrix containing the partial inverse of $<strong>L L'</strong>$
from a previous call to the function. Must contain the &ldquo;Zdiagp&rdquo;
attribute.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If $<strong>L L'</strong> = <strong>C</strong>$, function efficiently gives diag(Cinv) by only
calculating elements of Cinv based on non-zero elements of $<strong>L</strong>$ and
$<strong>L</strong>$. Follows the method and equations by Takahashi et al. (1973).
</p>


<h3>Value</h3>

<p>A sparse matrix containing the partial inverse of C ($<strong>L L'</strong>$)
along with attribute &ldquo;Zdiagp&rdquo; indicating the location for diagonals
of Z in <code>slot x</code> of the object <code>Z</code>.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>


<h3>References</h3>

<p>Takahashi, Fagan, &amp; Chin. 1973. Formation of a sparse bus impedance matrix
and its application to short circuit study. 8th PICA Conference Proceedings,
Minneapolis, MN.
</p>

<hr>
<h2 id='covFun'>(Co)variance parameter transformations.</h2><span id='topic+covFun'></span><span id='topic+stTrans'></span><span id='topic+conTrans'></span><span id='topic+vech2matlist'></span><span id='topic+start2theta'></span><span id='topic+matlist2vech'></span><span id='topic+theta2nu_trans'></span><span id='topic+nu2theta_trans'></span><span id='topic+theta2nu_lambda'></span><span id='topic+nu2theta_lambda'></span><span id='topic+nuVar2thetaVar_lambda'></span><span id='topic+nuAI2thetaAIinv_lambda'></span><span id='topic+nu2theta_noTrans'></span>

<h3>Description</h3>

<p>Converts lists of (co)variance parameters either between <code>list</code> and 
<code>vector</code> format or between the theta and nu scales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stTrans(x)

conTrans(Gcon, Rcon)

start2theta(Gstart, Rstart, name = NULL)

matlist2vech(theta)

vech2matlist(vech, skeleton)

theta2nu_trans(theta)

nu2theta_trans(nu)

theta2nu_lambda(theta, thetaG, thetaR)

nu2theta_lambda(nu, sigma2e, thetaG, thetaR)

nuVar2thetaVar_lambda(object)

nuAI2thetaAIinv_lambda(object)

nu2theta_noTrans(nu, thetaG, thetaR)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="covFun_+3A_x">x</code>, <code id="covFun_+3A_theta">theta</code>, <code id="covFun_+3A_nu">nu</code></td>
<td>
<p>A <code>list</code> of matrices containing the (co)variance
parameters of the model.</p>
</td></tr>
<tr><td><code id="covFun_+3A_gcon">Gcon</code>, <code id="covFun_+3A_rcon">Rcon</code></td>
<td>
<p>A <code>list</code> of starting (co)variance constraints for the
G-structure (random effects terms) or R-structure (residual).</p>
</td></tr>
<tr><td><code id="covFun_+3A_gstart">Gstart</code>, <code id="covFun_+3A_rstart">Rstart</code></td>
<td>
<p>A <code>list</code> of starting (co)variance values for the
G-structure (random effects terms) or R-structure (residual).</p>
</td></tr>
<tr><td><code id="covFun_+3A_name">name</code></td>
<td>
<p>An (optional) character <code>vector</code> containing the (co)variance
component names.</p>
</td></tr>
<tr><td><code id="covFun_+3A_vech">vech</code></td>
<td>
<p>A <code>vector</code> of (co)variance parameters.</p>
</td></tr>
<tr><td><code id="covFun_+3A_skeleton">skeleton</code></td>
<td>
<p>An example structure to map <code>vech</code> onto.</p>
</td></tr>
<tr><td><code id="covFun_+3A_thetag">thetaG</code>, <code id="covFun_+3A_thetar">thetaR</code></td>
<td>
<p>A <code>vector</code> indexing the G-structure or R-structure
components, respectively.</p>
</td></tr>
<tr><td><code id="covFun_+3A_sigma2e">sigma2e</code></td>
<td>
<p>A <code>numeric</code> estimate of the factored out residual
variance from the mixed model equations (i.e., the &lsquo;lambda&rsquo; scale)
<code class="reqn">\sigma^{2}_{e}</code>.</p>
</td></tr>
<tr><td><code id="covFun_+3A_object">object</code></td>
<td>
<p>An object of <code>class</code> &lsquo;gremlin&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>


<dl>
<dt><code>stTrans</code> </dt><dd><p>Transform start parameters into lower triangle
matrices of class <code>dsCMatrix</code>.</p>
</dd>
<dt><code>conTrans</code> </dt><dd><p>Transformation of starting constraints to correct
format.</p>
</dd>
<dt><code>start2theta</code> </dt><dd><p>Converts lists of starting values for (co)variance
parameters to a theta object used to structure the (co)variance components
within gremlin.</p>
</dd>
<dt><code>matlist2vech</code> </dt><dd><p>Converts a <code>list</code> of (co)variance parameter
matrices to a vector with a &ldquo;skel&rdquo; attribute.</p>
</dd>
<dt><code>vech2matlist</code> </dt><dd><p>Converts a vector of (co)variance parameters to
a list of covariance matrices.</p>
</dd>
<dt><code>theta2nu_trans</code> </dt><dd><p>Transforms theta to nu scale by taking the
Cholesky factor of each covariance matrix and then replacing the diagonals
with  their (natural) logarithms. Done to ensure matrices are positive
definite.</p>
</dd>
<dt><code>nu2theta_trans</code> </dt><dd><p>Back transformation from
<code>theta2nu_trans</code>: exponentiates the diagonal elements of each matrix
then calculates the cross-product.</p>
</dd>
<dt><code>theta2nu_lambda</code> </dt><dd><p>Transformation that factors out a residual
variance so that <code>nu</code> contains the &lsquo;lambda&rsquo; parameterization:
ratios of variance parameters with the residual variance.</p>
</dd>
<dt><code>nu2theta_lambda</code> </dt><dd><p>Back transformation from
<code>theta2nu_lambda</code>.</p>
</dd>
<dt><code>nuVar2thetaVar_lambda</code> </dt><dd><p>Transformation of Sampling Variances
from <code>lambda</code> Scale for <code>theta</code>.</p>
</dd>
<dt><code>nuAI2thetaAIinv_lambda</code> </dt><dd><p>Transform AI matrix from <code>lambda</code>
Scale to AI-inverse of <code>theta</code>.</p>
</dd>
<dt><code>nu2theta_noTrans</code> </dt><dd><p>Structures <code>theta</code> when not
transformed.</p>
</dd>
</dl>



<h3>Value</h3>

<p>Functions are specified to mostly return either a <code>list</code> of
matrices (structure as defined by the &ldquo;skel&rdquo; attribute or in
the <code>skeleton</code> object) or a <code>vector</code> containing the (co)variance
parameters of the model. Additional list elements returned can be:
</p>

<dl>
<dt>thetaG </dt><dd><p>A <code>vector</code> indexing the G-structure components.</p>
</dd>
<dt>thetaR </dt><dd><p>A <code>vector</code> indexing the R-structure components.</p>
</dd>
</dl>

<p>Alternatively, <code>nuVar2thetaVar_lambda</code> and <code>nuAI2thetaAIinv_lambda</code>
return a <code>vector</code> and <code>matrix</code>, respectively, holding the sampling
(co)variances of the model (co)variance parameters both on the <code>theta</code>
scale. These are elements of the inverse Average Information matrix.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # User-specified starting parameters
  thetaOut &lt;- start2theta(Gstart = list(matrix(1), matrix(2)),
    Rstart = matrix(3))
  ## convert to a vector and then back into a matrix list
  thetav &lt;- matlist2vech(thetaOut$theta)
  theta &lt;- vech2matlist(thetav, attr(thetav, "skel"))
    identical(thetaOut$theta, theta)  #&lt;-- should be TRUE
  # lambda parameterization transformation
  nu &lt;- theta2nu_lambda(theta, thetaOut$thetaG, thetaOut$thetaR)
  # back-transform from (lambda scale) nu to theta
  ## For example, when the sigma2e estimate=0.5
  theta2 &lt;- nu2theta_lambda(nu, sigma2e = 0.5, thetaOut$thetaG, thetaOut$thetaR)
</code></pre>

<hr>
<h2 id='deltaSE'>Delta Method to Calculate Standard Errors for Functions of (Co)variances.</h2><span id='topic+deltaSE'></span><span id='topic+deltaSE.default'></span><span id='topic+deltaSE.formula'></span><span id='topic+deltaSE.list'></span>

<h3>Description</h3>

<p>Calculates the standard error for results of simple mathematical functions of
(co)variance parameters using the delta method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deltaSE(calc, object, scale = c("theta", "nu"))

## Default S3 method:
deltaSE(calc, object, scale = c("theta", "nu"))

## S3 method for class 'formula'
deltaSE(calc, object, scale = c("theta", "nu"))

## S3 method for class 'list'
deltaSE(calc, object, scale = c("theta", "nu"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deltaSE_+3A_calc">calc</code></td>
<td>
<p>A character <code>expression</code>, <code>formula</code>, or list (of
<code>formula</code> or <code>expression</code>) expressing the mathematical function
of (co)variance component for which to calculate standard errors.</p>
</td></tr>
<tr><td><code id="deltaSE_+3A_object">object</code></td>
<td>
<p>A fitted model object of <code>class</code> &lsquo;gremlin&rsquo;.</p>
</td></tr>
<tr><td><code id="deltaSE_+3A_scale">scale</code></td>
<td>
<p>A <code>character</code> indicating whether to calculate the function
and standard error on the original data scale (&ldquo;theta&rdquo;) or
on the underlying scale to which (co)variance components are transformed
for the model fitting calculations (&ldquo;nu&rdquo;). Defaults to
&ldquo;theta&rdquo; if not specified.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The delta method (e.g., Lynch and Walsh 1998, Appendix 1; Ver Hoef 2012) uses
a Taylor series expansion to approximate the moments of a function of
parameters. Here, a second-order Taylor series expansion is implemented to
approximate the standard error for a function of (co)variance parameters.
Partial first derivatives of the function are calculated by algorithmic
differentiation with <code><a href="stats.html#topic+deriv">deriv</a></code>.
</p>
<p>Though <code>deltaSE</code> can calculate standard errors for non-linear functions
of (co)variance parameters from a fitted <code>gremlin</code> model, it is limited
to non-linear functions constructed by mathematical operations such as the
arithmetic operators <code>+</code>, <code>-</code>, <code>*</code>, <code>/</code> and <code>^</code>,
and single-variable functions such as  <code>exp</code> and <code>log</code>. See 
<code><a href="stats.html#topic+deriv">deriv</a></code> for more information.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> containing the &ldquo;Estimate&rdquo; and
&ldquo;Std. Error&rdquo; for the mathematical function(s) of (co)variance
components.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>deltaSE(default)</code>: Default method
</p>
</li>
<li> <p><code>deltaSE(formula)</code>: Formula method
</p>
</li>
<li> <p><code>deltaSE(list)</code>: List method
</p>
</li></ul>


<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>


<h3>References</h3>

<p>Lynch, M. and B. Walsh 1998. Genetics and Analysis of Quantitative Traits.
Sinauer Associates, Inc., Sunderland, MA, USA.
</p>
<p>Ver Hoef, J.M. 2012. Who invented the delta method? The American
Statistician 66:124-127. DOI: 10.1080/00031305.2012.687494
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+deriv">deriv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Calculate the sum of the variance components 
    grS &lt;- gremlin(WWG11 ~ sex - 1, random = ~ sire, data = Mrode11)
    deltaSE(Vsum ~ V1 + V2, grS)
    deltaSE("V1 + V2", grS)  #&lt;-- alternative

  # Calculate standard deviations (with standard errors) from variances
    ## Uses a `list` as the first (`calc`) argument
    ### All 3 below: different formats to calculate the same values
    deltaSE(list(SD1 ~ sqrt(V1), SDresid ~ sqrt(V2)), grS)  #&lt;-- formulas
    deltaSE(list(SD1 ~ sqrt(G.sire), SDresid ~ sqrt(ResVar1)), grS) 
    deltaSE(list("sqrt(V1)", "sqrt(V2)"), grS)  #&lt;-- list of character expressions

  # Additive Genetic Variance calculated from observed Sire Variance
    ## First simulate Full-sib data
    set.seed(359)
    noff &lt;- 5     #&lt;-- number of offspring in each full-sib family
    ns &lt;- 100     #&lt;-- number of sires/full-sib families
    VA &lt;- 1       #&lt;-- additive genetic variance
    VR &lt;- 1       #&lt;-- residual variance
    datFS &lt;- data.frame(id = paste0("o", seq(ns*noff)),
      sire = rep(paste0("s", seq(ns)), each = noff))
    ## simulate mid-parent breeding value (i.e., average of sire and dam BV)
    ### mid-parent breeding value = 0.5 BV_sire + 0.5 BV_dam
    #### var(mid-parent BV) = 0.25 var(BV_sire) + 0.25 var(BV_dam) = 0.5 var(BV) 
    datFS$midParBV &lt;- rep(rnorm(ns, 0, sqrt(0.5*VA)), each = noff)
    ## add to this a Mendelian sampling deviation to get each offspring BV
    datFS$BV &lt;- rnorm(nrow(datFS), datFS$midParBV, sqrt(0.5*VA))
    datFS$r &lt;- rnorm(nrow(datFS), 0, sqrt(VR))  #&lt;-- residual deviation
    datFS$pheno &lt;- rowSums(datFS[, c("BV", "r")]) 
    # Analyze with a sire model
    grFS &lt;- gremlin(pheno ~ 1, random = ~ sire, data = datFS)
    # calculate VA as 2 times the full-sib/sire variance
    deltaSE(VAest ~ 2*V1, grFS)
    # compare to expected value and simulated value
    VA  #&lt;-- expected
    var(datFS$BV)  #&lt;-- simulated (includes Monte Carlo error)

  # Example with `deltaSE(..., scale = "nu")
  ## use to demonstrate alternative way to do same calculation of inverse
  ## Average Information matrix of theta scale parameters when lambda = TRUE
  ### what is done inside gremlin::nuVar2thetaVar_lambda 
    grSlambda &lt;- gremlin(WWG11 ~ sex - 1, random = ~ sire, data = Mrode11,
      control = gremlinControl(lambda = TRUE))
    dOut &lt;- deltaSE(thetaV1 ~ V1*V2, grSlambda, "nu")  #&lt;-- V2 is sigma2e
    aiFnOut &lt;- nuVar2thetaVar_lambda(grSlambda)[1] #&lt;--variance (sqrt below)
    stopifnot(abs(dOut[, "Std. Error"] - sqrt(aiFnOut)) &lt; 1e-10)

</code></pre>

<hr>
<h2 id='fixef.gremlin'>Fixed Effect Estimates of <code>class</code> &lsquo;gremlin&rsquo;</h2><span id='topic+fixef.gremlin'></span><span id='topic+fixef'></span><span id='topic+fixed.effects'></span>

<h3>Description</h3>

<p>Extracts the fixed effect estimates from a model of <code>class</code> &lsquo;gremlin&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gremlin'
fixef(object, add.dropped = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fixef.gremlin_+3A_object">object</code></td>
<td>
<p>An object of <code>class</code> &lsquo;gremlin&rsquo;.</p>
</td></tr>
<tr><td><code id="fixef.gremlin_+3A_add.dropped">add.dropped</code></td>
<td>
<p>A <code>logical</code> value indicating whether fixed effects dropped by
gremlin, due to rank deficiencies in the fixed effect design matrix, should
be included with <code>NA</code> values.</p>
</td></tr>
<tr><td><code id="fixef.gremlin_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>numeric</code> vector of fixed effect estimates.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fixef(gremlin(WWG11 ~ sex - 1, random = ~ sire, data = Mrode11))
</code></pre>

<hr>
<h2 id='gremlin'>Mixed-effect modeling functions.</h2><span id='topic+gremlin'></span><span id='topic+gremlinR'></span><span id='topic+gremlinSetup'></span><span id='topic+mkModMats'></span><span id='topic+update'></span><span id='topic+getCall.gremlin'></span><span id='topic+update.gremlin'></span>

<h3>Description</h3>

<p>Fit and setup functions for linear mixed-effect model (Gaussian responses).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gremlin(
  formula,
  random = NULL,
  rcov = ~units,
  data = NULL,
  ginverse = NULL,
  Gstart = NULL,
  Rstart = NULL,
  Bp = NULL,
  Gcon = NULL,
  Rcon = NULL,
  maxit = 20,
  algit = NULL,
  vit = 1,
  v = 1,
  control = gremlinControl(),
  ...
)

gremlinR(
  formula,
  random = NULL,
  rcov = ~units,
  data = NULL,
  ginverse = NULL,
  Gstart = NULL,
  Rstart = NULL,
  Bp = NULL,
  Gcon = NULL,
  Rcon = NULL,
  maxit = 20,
  algit = NULL,
  vit = 1,
  v = 1,
  control = gremlinControl(),
  ...
)

## S3 method for class 'gremlin'
getCall(x, ...)

## S3 method for class 'gremlin'
update(object, ...)

gremlinSetup(
  formula,
  random = NULL,
  rcov = ~units,
  data = NULL,
  ginverse = NULL,
  Gstart = NULL,
  Rstart = NULL,
  Bp = NULL,
  Gcon = NULL,
  Rcon = NULL,
  maxit = 20,
  algit = NULL,
  vit = 1,
  v = 1,
  control = gremlinControl(),
  ...
)

mkModMats(
  formula,
  random = NULL,
  rcov = ~units,
  data = NULL,
  subset = NULL,
  ginverse = NULL,
  na.action = na.pass,
  offset = NULL,
  contrasts = NULL,
  Xsparse = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gremlin_+3A_formula">formula</code></td>
<td>
<p>A <code>formula</code> for the response variable(s) and fixed effects.</p>
</td></tr>
<tr><td><code id="gremlin_+3A_random">random</code></td>
<td>
<p>A <code>formula</code> for the random effects.</p>
</td></tr>
<tr><td><code id="gremlin_+3A_rcov">rcov</code></td>
<td>
<p>A <code>formula</code> for the residual covariance structure.</p>
</td></tr>
<tr><td><code id="gremlin_+3A_data">data</code></td>
<td>
<p>A <code>data.frame</code> in which to look for the terms in
<code>formula</code>, <code>random</code>, and <code>rcov</code>.</p>
</td></tr>
<tr><td><code id="gremlin_+3A_ginverse">ginverse</code></td>
<td>
<p>A <code>list</code> of (preferably sparse) inverse matrices that
are proportional to the covariance structure of the random effects.
The name of each element in the list should match a column in <code>data</code>
that is associated with a random term. All levels of the random term should
appear as <code>rownames</code> for the matrices.</p>
</td></tr>
<tr><td><code id="gremlin_+3A_gstart">Gstart</code></td>
<td>
<p>A <code>list</code> of matrices with starting (co)variance values for
the G-structure or random effects terms.</p>
</td></tr>
<tr><td><code id="gremlin_+3A_rstart">Rstart</code></td>
<td>
<p>A <code>list</code> of matrices with starting (co)variance values for
the R-structure or residual terms.</p>
</td></tr>
<tr><td><code id="gremlin_+3A_bp">Bp</code></td>
<td>
<p>A prior specification for fixed effects.</p>
</td></tr>
<tr><td><code id="gremlin_+3A_gcon">Gcon</code>, <code id="gremlin_+3A_rcon">Rcon</code></td>
<td>
<p>A <code>list</code> of matrices with constraint codes for the
G-structure/random effects or R-structure/residual effects terms,
respectively. Must be a <code>character</code> of either <code>"F"</code> for fixed,
<code>"P"</code> for positive, or <code>"U"</code> for unbounded.</p>
</td></tr>
<tr><td><code id="gremlin_+3A_maxit">maxit</code></td>
<td>
<p>An <code>integer</code> specifying the maximum number of likelihood
iterations.</p>
</td></tr>
<tr><td><code id="gremlin_+3A_algit">algit</code></td>
<td>
<p>A <code>character</code> vector of length 1 or more or an expression
to be evaluated that specifies the algorithm to use for proposing
(co)variances in the next likelihood iteration. Mainly used to switch
between Expectation Maximization (<code>"EM"</code>), or Average Information
second derivatives with either (1) analytical first derivatives
(specifically <code>"AItr"</code>) or (2) first derivatives using a finite
difference method (backward <code>"AIbfd"</code>, central <code>"AIcfd"</code>, or
forward <code>"AIffd"</code> finite differences).</p>
</td></tr>
<tr><td><code id="gremlin_+3A_vit">vit</code></td>
<td>
<p>An <code>integer</code> value specifying the verbosity of screen output
on each iteration. A value of zero gives no iteration specific output and
larger values increase the amount of information printed on the screen.</p>
</td></tr>
<tr><td><code id="gremlin_+3A_v">v</code></td>
<td>
<p>An <code>integer</code> value specifying the verbosity of screen output
regarding the model fitting process. A value of zero gives no details and
larger values increase the amount of information printed on the screen.</p>
</td></tr>
<tr><td><code id="gremlin_+3A_control">control</code></td>
<td>
<p>A <code>list</code> returned by <code>gremlinControl</code> containing
specific named values from that function. See <code><a href="#topic+gremlinControl">gremlinControl</a></code>.</p>
</td></tr>
<tr><td><code id="gremlin_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to control the model fitting.</p>
</td></tr>
<tr><td><code id="gremlin_+3A_x">x</code>, <code id="gremlin_+3A_object">object</code></td>
<td>
<p>An object of class <code>gremlin</code>.</p>
</td></tr>
<tr><td><code id="gremlin_+3A_subset">subset</code></td>
<td>
<p>An expression for the subset of <code>data</code> to use.</p>
</td></tr>
<tr><td><code id="gremlin_+3A_na.action">na.action</code></td>
<td>
<p>What to do with NAs.</p>
</td></tr>
<tr><td><code id="gremlin_+3A_offset">offset</code></td>
<td>
<p>Should an offset be specified.</p>
</td></tr>
<tr><td><code id="gremlin_+3A_contrasts">contrasts</code></td>
<td>
<p>Specify the type of contrasts for the fixed effects.</p>
</td></tr>
<tr><td><code id="gremlin_+3A_xsparse">Xsparse</code></td>
<td>
<p>Should sparse matrices be used for the fixed effects design
matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> containing an object of class <code>grMod</code> and, if a 
model was fit (<code>gremlin</code> or <code>gremlinR</code>) then an object containing
details of the REML iterations (object <code>itMat</code>). An object of class
<code>grMod</code> contains:
</p>

<dl>
<dt>call </dt><dd><p>The model <code>call</code>.</p>
</dd>
<dt>modMats </dt><dd><p>A <code>list</code> of the model matrices used to construct the
mixed model equations.</p>
</dd>
<dt>y </dt><dd><p>The response vector.</p>
</dd>
<dt>ny </dt><dd><p>The number of responses.</p>
</dd>
<dt>ncy </dt><dd><p>The number of columns of the original response.</p>
</dd>
<dt>X </dt><dd><p> The fixed effects design matrix.</p>
</dd>
<dt>nb </dt><dd><p>The number of columns in X.</p>
</dd>
<dt>Zr </dt><dd><p>The residual design matrix.</p>
</dd>
<dt>Zg </dt><dd><p>A list of the design matrices for each random term.</p>
</dd>
<dt>nG </dt><dd><p>The number of parameters in the G structure.</p>
</dd>
<dt>listGeninv </dt><dd><p>A list of generalized inverse matrices.</p>
</dd>
<dt>logDetG </dt><dd><p>The log-determinants of the generalized inverse 
matrices - necessary to calculate the log-likelihood.</p>
</dd>
<dt>rfxIncContrib2loglik </dt><dd><p>A <code>numeric</code> value containing the sum
of the log determinants of the random effects that do not change between
log-likelihood iterations (i.e., the part of the log determinants of 
(co)variance matrices to be estimated that have been factored out).</p>
</dd>
<dt>ndgeninv </dt><dd><p>A <code>logical</code> indicating which terms in the random
formula have generalized inverses associated with them (non-diagonal 
matrices in the Kronecker product).</p>
</dd>
<dt>dimsZg, nminffx, rfxlvls, nminfrfx </dt><dd><p><code>Numeric</code> vectors or scalars
describing the numbers of random effects or some function of random and
fixed effects.</p>
</dd>
<dt>conv, bounds </dt><dd><p>(Co)variance component constraints and boundaries
of the allowable parameter space for each component.</p>
</dd>
<dt>thetav </dt><dd><p>A <code>vector</code> of the (co)variance parameters to
be estimated by REML withe the attribute &ldquo;skel&rdquo; giving the
skeleton to recreate a list of <code>matrices</code> from this vector.</p>
</dd>
<dt>thetaG, thetaR </dt><dd><p><code>Vectors</code> indexing the random and residual
(co)variances, respectively, in a list of (co)variance matrices (i.e.,
<code>theta</code>).</p>
</dd>
<dt>nu </dt><dd><p>A <code>list</code> of transformed (co)variance matrices
to be fit by REML. If a residual variance has been factored out of the
mixed model equations, <code>nu</code> contains the &lsquo;lambda&rsquo;
parameterization with expresses the (co)variance components as ratios
of variance parameters with the residual variance. The &lsquo;nu&rsquo; scale
(co)variances are the ones actually fit by REML.</p>
</dd>
<dt>sigma2e </dt><dd><p>The estimate of the factored out residual variance from
the mixed model equations (i.e., the &lsquo;lambda&rsquo; scale)
<code class="reqn">\sigma^{2}_{e}</code>.</p>
</dd>
<dt>p </dt><dd><p>An <code>integer</code> for the total number of (co)variances to be
estimated.</p>
</dd>
<dt>lambda </dt><dd><p>A <code>logical</code> indicating whether the &lsquo;lambda&rsquo;
scale parameterization has been used.</p>
</dd>
<dt>uni </dt><dd><p>A <code>logical</code> to indicate if the model is univariate or not.</p>
</dd>
<dt>W, tWW, RHS, Bpinv </dt><dd><p>Sparse matrices of class <code>Matrix</code> that 
form the mixed model equations and do not change between iterations of
REML. These are the column bound &lsquo;X&rsquo; and &lsquo;Z&rsquo; design
matrices for fixed and random effects, the cross-product of <code>W</code>,
the Right-Hand Side of the mixed model equations, and the inverse of
the fixed effect prior matrix (zeroes on the diagonal if no priors have
been specified). Note, these may be <code>NULL</code> if <code>lambda=FALSE</code>,
because the <code>NULL</code> objects are not used or do change between
REML iterations.</p>
</dd>
<dt>sLc </dt><dd><p>A <code>Matrix</code> containing the symbolic Cholesky factorization
of the coefficient matrix of the Mixed Model Equations.</p>
</dd>
<dt>sln </dt><dd><p>A one column <code>matrix</code> of solutions in the mixed model
equations.</p>
</dd>
<dt>Cinv_ii </dt><dd><p>A one column <code>matrix</code> of variances for the solutions
to the mixed model equations. These are obtained from the diagonal of
the inverse Coefficient matrix in the mixed model equations. If lambda
is <code>TRUE</code> then these are on the lambda scale and must be
multiplied by <code>sigma2e</code> to be converted to the original data scale.</p>
</dd>
<dt>r </dt><dd><p>A one column <code>matrix</code> of residual deviations, response minus
the values expected based on the solutions, corresponding to the order
in <code>modMats$y</code>.</p>
</dd> 
<dt>AI </dt><dd><p>A <code>matrix</code> of values containing the Average Information
matrix, or second partial derivatives of the likelihood with respect to
the transformed (co)variance components (&lsquo;nu&rsquo;). The inverse of
this matrix gives the sampling (co)variances of these transformed
(co)variance components.</p>
</dd>
<dt>dLdnu </dt><dd><p>A single column <code>matrix</code> of first derivatives of
the transformed (co)variance parameters (&lsquo;nu&rsquo;) with respect to
the log-Likelihood.</p>
</dd>
<dt>maxit </dt><dd><p>See the parameter described above.</p>
</dd>
<dt>algit </dt><dd><p>A <code>character</code> vector of REML algorithms to use in each
iteration.</p>
</dd>
<dt>fdit </dt><dd><p>A <code>character</code> vector of which first derivative/gradient
algorithm to use each iteration (if first derivatives of the likelihood
function are to be calculated).</p>
</dd>
<dt>sdit </dt><dd><p>A <code>character</code> vector of which second derivative/hessian
algorithm to use each iteration (if second derivatives of the likelihood
function are to be calculated).</p>
</dd>
<dt>vit </dt><dd><p>See the parameter described above.</p>
</dd>
<dt>v </dt><dd><p>See the parameter described above.</p>
</dd>
<dt>cctol </dt><dd><p>A <code>numeric</code> vector of convergence criteria thresholds.
See <code><a href="#topic+gremlinControl">gremlinControl</a></code> and <code><a href="#topic+ccFun">ccFun</a></code> for details.</p>
</dd>
<dt>ezero, einf </dt><dd><p><code>numeric</code> values for the effective numbers to
use as &ldquo;zero&rdquo; and maximum negative or positive numbers. Values
less than <code>ezero</code> are treated as zero and fixed to this value.
Values less than <code>-1*einf</code> or greater than <code>einf</code> are
restricted to these values. See <code><a href="#topic+gremlinControl">gremlinControl</a></code> for more
details.</p>
</dd>
<dt>step </dt><dd><p>A <code>numeric</code> value indicating the step-reduction to use.
See <code><a href="#topic+gremlinControl">gremlinControl</a></code> for more details.</p>
</dd>
<dt>h </dt><dd><p>A <code>numeric</code> value indicating the increment used in the
first derivative (gradient) finite difference method.</p>
</dd>
<dt>itMat </dt><dd><p>A <code>matrix</code> of details about each iteration. Rows
indicate each REML iteration (rownames reflect the REML algorithm used)
and columns contain:
</p>

<dl>
<dt>nu, theta</dt><dd><p>(Co)variance parameters.</p>
</dd>
<dt>sigma2e </dt><dd><p>See &lsquo;sigma2e&rsquo; described above.</p>
</dd>
<dt>tyPy, logDetC </dt><dd><p>Estimates for two these two components of the
log of the REML likelihoods. These are obtained from Cholesky
factorization of the coefficient matrix of the mixed model equations.</p>
</dd>
<dt>loglik </dt><dd><p>The REML log-likelihood.</p>
</dd>
<dt>itTime </dt><dd><p>Time elapsed for each REML iteration.</p>
</dd>
</dl>

</dd>
</dl>



<h3>Functions</h3>


<ul>
<li> <p><code>mkModMats()</code>: Generates model matrices.
</p>
</li></ul>


<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  grSire &lt;- gremlin(WWG11 ~ sex, random = ~ sire, data = Mrode11)
  # Now drop sire random effects and use the `anova` method to compare models
  grLM &lt;- update(grSire, random = ~ 1)  #&lt;-- use `~1` to drop all random effects
    anova(grSire, grLM)

  # Modular functions
  ## get model matrices for a mixed model
  mM11 &lt;- mkModMats(WWG11 ~ sex - 1, random = ~ sire, data = Mrode11)

  ## setup model, but do not evaluate the log-likelihood
  grSetup &lt;- gremlinSetup(WWG11 ~ sex - 1, random = ~ sire, data = Mrode11)
  ## maximize the restricted maximum likelihood
  grOut &lt;- remlIt(grSetup)
  summary(grOut)

## Not run: 
  # Following the example from Mrode 2005, chapter 11.
  library(nadiv)  #&lt;-- to construct inverse of the numerator relatedness matrix
  pedMrode11 &lt;- prepPed(Mrode11[, 1:3])
  Ainv &lt;- makeAinv(pedMrode11)$Ainv

  gr11lmm &lt;- gremlin(WWG11 ~ sex - 1,
random = ~ calf,
data = Mrode11,
ginverse = list(calf = Ainv),
Gstart = matrix(0.2), Rstart = matrix(0.4),  #&lt;-- specify starting values
maxit = 15,    #&lt;-- maximum iterations
     v = 2, vit = 1,  #&lt;-- moderate screen output (`v`) every iteration (`vit`)
     algit = "AI")  #&lt;-- only use Average Information algorithm iterations
  summary(gr11lmm)

  # Compare the model to a Linear Model with no random effects
  ## Use `update()` to update the model
  gr11lm &lt;- update(gr11lmm, random = ~ 1)  #&lt;-- `~1`=drop all random effects
  summary(gr11lm)

  # Do analysis of variance between the two models
  ## See AIC or evaluate likelihood ratio against a Chi-squared distribution
  anova(gr11lm, gr11lmm)

## End(Not run)
</code></pre>

<hr>
<h2 id='gremlinControl'>Advanced Options for Mixed-effect modeling functions.</h2><span id='topic+gremlinControl'></span>

<h3>Description</h3>

<p>Change default settings for gremlin models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gremlinControl(
  cctol = c(5e-04, 1e-05, 0.01, NULL),
  ezero = 1e-08,
  einf = 1e+30,
  step = 0.3,
  h = .Machine$double.eps^(1/3),
  lambda = FALSE,
  algorithm = NULL,
  algArgs = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gremlinControl_+3A_cctol">cctol</code></td>
<td>
<p>Convergence criteria tolerances (Meyer 2007, 2019). See details
about the convergence checks in <code><a href="#topic+ccFun">ccFun</a></code>.</p>
</td></tr>
<tr><td><code id="gremlinControl_+3A_ezero">ezero</code></td>
<td>
<p>Effective zero to be used, values less than this number are
treated as zero and fixed to this value.</p>
</td></tr>
<tr><td><code id="gremlinControl_+3A_einf">einf</code></td>
<td>
<p>Effective infinite value to be used, values are limited to a
to this variable as a maximum.</p>
</td></tr>
<tr><td><code id="gremlinControl_+3A_step">step</code></td>
<td>
<p>A <code>numeric</code> value for scaling the proposed parameter updates.</p>
</td></tr>
<tr><td><code id="gremlinControl_+3A_h">h</code></td>
<td>
<p>A <code>numeric</code> value for finite difference algorithm of partial
first derivatives for the likelihood function. Specifies the amount to add
to parameter value to calculate the change in log-likelihood.</p>
</td></tr>
<tr><td><code id="gremlinControl_+3A_lambda">lambda</code></td>
<td>
<p>A <code>logical</code> indicating whether a residual variance should
be factored out of the mixed model equations.</p>
</td></tr>
<tr><td><code id="gremlinControl_+3A_algorithm">algorithm</code></td>
<td>
<p>A <code>character</code> naming the function to use to decide
subsequent parameters in the REML iterations.</p>
</td></tr>
<tr><td><code id="gremlinControl_+3A_algargs">algArgs</code></td>
<td>
<p>A <code>list</code> of function arguments to be given to functions
named in the <code>algorithm</code> argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> of class <code>gremlinControl</code> to be used by
<code>gremlinSetup</code> and later functions when fitting the model.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>


<h3>References</h3>

<p>Meyer, K. 2007. WOMBAT - a tool for mixed model analyses in quantitative
genetics by restricted maximum likelihood (REML). Journal of Zhejiang
University SCIENCE B 8(11):815-821.
</p>
<p>Meyer, K. 2019. WOMBAT A program for mixed model analyses by restricted
maximum likelihood. User Notes. 27 September 2019.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  str(gremlinControl())

</code></pre>

<hr>
<h2 id='logLik.gremlin'>Methods to extract log-likelihood and information criterion of a gremlin
model.</h2><span id='topic+logLik.gremlin'></span><span id='topic+npar.gremlin'></span><span id='topic+AIC.gremlin'></span>

<h3>Description</h3>

<p>Extracts the log-likelihood or AIC from a gremlin model fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gremlin'
logLik(object, ...)

npar.gremlin(object)

## S3 method for class 'gremlin'
AIC(object, ..., k = 2, fxdDf = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik.gremlin_+3A_object">object</code></td>
<td>
<p>An object of <code>class</code> &lsquo;gremlin&rsquo;.</p>
</td></tr>
<tr><td><code id="logLik.gremlin_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
<tr><td><code id="logLik.gremlin_+3A_k">k</code></td>
<td>
<p>A numeric value for the penalty per parameter. Default is 2, as in
classic AIC.</p>
</td></tr>
<tr><td><code id="logLik.gremlin_+3A_fxddf">fxdDf</code></td>
<td>
<p>A logical indicating whether to penalize according to the number
of fixed effect parameters. Since only models fit by REML can be compared,
these must always be the same and so become a constant. Hence, the default
is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>npar.gremlin</code> returns an object with attributes <code>n.fxd</code>
and <code>n.bndry</code> which give additional information about the parameters
estimated and contributing to the overall <code>df</code> of the model. <code>n.fxd</code>
returns the total number of parameters (No. fixed effects + No. (co)variance
components) minus the number of parameters constrained to a certain value. Thus,
<code>n.fxd</code> represents the number of parameters that can vary and, as a 
consequence, affect the log-likelihood.
</p>
<p>The attribute <code>n.bndry</code> reports the number of parameters that were
restrained to stay inside the boundaries of allowable parameter space (e.g.,
a variance that was not allowed to be negative).
</p>


<h3>Value</h3>

<p><code>numeric</code> values for the log-likelihood, the number of
parameters estimated by the model (sum of fixed effects and random effect
(co)variance components), and Akaike's Information Criterion.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grS &lt;- gremlin(WWG11 ~ sex - 1, random = ~ sire, data = Mrode11)
logLik(grS)
AIC(grS)
</code></pre>

<hr>
<h2 id='Mrode11'>Weight gain data.</h2><span id='topic+Mrode11'></span>

<h3>Description</h3>

<p>Data from chapter 11 in Mrode 2005. The variables are as follows:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mrode11
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 5 rows and 5 columns.
</p>


<h3>Details</h3>


<ul>
<li><p> calf. a factor with levels <code>4</code> <code>5</code> <code>6</code> <code>7</code> <code>8</code>
</p>
</li>
<li><p> dam. a factor with levels <code>2</code> <code>5</code> <code>6</code>
</p>
</li>
<li><p> sire. a factor with levels <code>1</code> <code>3</code> <code>4</code>
</p>
</li>
<li><p> sex. a factor with levels <code>male</code> <code>female</code>
</p>
</li>
<li><p> WWG11. a numeric vector
</p>
</li></ul>



<h3>Source</h3>

<p>Mrode, R.A. 2005. Linear Models for the Prediction of Animal Breeding
Values, 2nd ed. CABI Publishing, Cambridge, MA, USA.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Mrode11)
</code></pre>

<hr>
<h2 id='nobs.gremlin'>Number of observations in data from gremlin model fit objects</h2><span id='topic+nobs.gremlin'></span>

<h3>Description</h3>

<p>Extract the number of 'observations' in a gremlin model fit.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gremlin'
nobs(object, use.fallback = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="nobs.gremlin_+3A_object">object</code></td>
<td>
<p>An object of <code>class</code> &lsquo;gremlin&rsquo;.</p>
</td></tr>
<tr><td><code id="nobs.gremlin_+3A_use.fallback">use.fallback</code></td>
<td>
<p>logical: should fallback methods be used to try to guess
the value? Included for compatibility.</p>
</td></tr>
<tr><td><code id="nobs.gremlin_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single number, usually an <code>integer</code>, but can be <code>NA</code>.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grS &lt;- gremlin(WWG11 ~ sex - 1, random = ~ sire, data = Mrode11)
nobs(grS)
</code></pre>

<hr>
<h2 id='reml'>REML optimization algorithms for mixed-effect models.</h2><span id='topic+reml'></span><span id='topic+ai'></span><span id='topic+em'></span><span id='topic+gradFun'></span><span id='topic+tugug_trace'></span><span id='topic+gradFun_fd'></span>

<h3>Description</h3>

<p>Evaluate the REML likelihood and algorithms for iterating to find maximum 
REML estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reml(
  nu,
  skel,
  thetaG,
  sLc,
  modMats,
  W,
  Bpinv,
  nminffx,
  nminfrfx,
  rfxlvls,
  rfxIncContrib2loglik,
  thetaR = NULL,
  tWW = NULL,
  RHS = NULL
)

em(
  nuvin,
  thetaG,
  thetaR,
  conv,
  rfxlvls,
  tugug,
  trace,
  y = NULL,
  r = NULL,
  nminffx = NULL
)

ai(nuvin, skel, thetaG, modMats, W, sLc, sln, r, thetaR = NULL, sigma2e = NULL)

tugug_trace(thetaG, nb, rfxlvls, listGeninv, Cinv, sln, pinv = NULL)

gradFun(
  nuvin,
  thetaG,
  rfxlvls,
  sln,
  tugug,
  trace,
  sigma2e = NULL,
  r = NULL,
  nminfrfx = NULL
)

gradFun_fd(nuvin, grObj, lL, fd = c("fdiff", "cdiff", "bdiff"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="reml_+3A_nu">nu</code>, <code id="reml_+3A_nuvin">nuvin</code></td>
<td>
<p>A <code>list</code> or <code>vector</code> of (co)variance parameters to
estimate on the transformed, or nu, scale.</p>
</td></tr>
<tr><td><code id="reml_+3A_skel">skel</code></td>
<td>
<p>A skeleton for reconstructing the list of (co)variance parameters.</p>
</td></tr>
<tr><td><code id="reml_+3A_thetag">thetaG</code>, <code id="reml_+3A_thetar">thetaR</code></td>
<td>
<p><code>Integer</code> vectors indexing the G-structure or
R-structure of the (co)variance parameters.</p>
</td></tr>
<tr><td><code id="reml_+3A_slc">sLc</code></td>
<td>
<p>A sparse <code>Matrix</code> containing the symbolic Cholesky
factorization of the coefficient matrix of the Mixed Model Equations.</p>
</td></tr>
<tr><td><code id="reml_+3A_modmats">modMats</code></td>
<td>
<p>A <code>list</code> of the model matrices used to construct the
mixed model equations.</p>
</td></tr>
<tr><td><code id="reml_+3A_w">W</code>, <code id="reml_+3A_tww">tWW</code></td>
<td>
<p>A sparse <code>Matrix</code> containing the design matrices for the fixed
and random effects (<code>W</code>) and the cross-product of this (<code>tWW</code>).</p>
</td></tr>
<tr><td><code id="reml_+3A_bpinv">Bpinv</code></td>
<td>
<p>A matrix inverse of the matrix containing the prior specification
for fixed effects.</p>
</td></tr>
<tr><td><code id="reml_+3A_nminffx">nminffx</code>, <code id="reml_+3A_nminfrfx">nminfrfx</code>, <code id="reml_+3A_rfxlvls">rfxlvls</code></td>
<td>
<p><code>Integers</code> specifying: (1) the difference
between the number of observations and fixed effects (of the full rank fixed
effects design matrix (X), (2) <code>nminffx</code> minus the total number of
random effects, and (3) a <code>vector</code> of levels for each term in the 
random effects.</p>
</td></tr>
<tr><td><code id="reml_+3A_rfxinccontrib2loglik">rfxIncContrib2loglik</code></td>
<td>
<p>A <code>numeric</code> indicating the sum of constraint
contributions to the log-likelihood across all terms in the random effects
that have non-diagonal generalized inverse matrices (<code>ginverse</code>).
associated with a generalized inverse (<code>ginverse</code>).</p>
</td></tr>
<tr><td><code id="reml_+3A_rhs">RHS</code></td>
<td>
<p>A sparse <code>Matrix</code> containing the Right-Hand Side to the 
Mixed Model Equations.</p>
</td></tr>
<tr><td><code id="reml_+3A_conv">conv</code></td>
<td>
<p>A <code>character</code> vector of (co)variance parameter constraints.</p>
</td></tr>
<tr><td><code id="reml_+3A_tugug">tugug</code></td>
<td>
<p>A list of numeric values for the $u_g' u_g$ products of the
solution vector for each of the <code>g</code> variance parameters.</p>
</td></tr>
<tr><td><code id="reml_+3A_trace">trace</code></td>
<td>
<p>A list of traces of the inverse coefficient matrix for each of
of the <code>g</code> variance parameters.</p>
</td></tr>
<tr><td><code id="reml_+3A_y">y</code></td>
<td>
<p>The response vector.</p>
</td></tr>
<tr><td><code id="reml_+3A_sln">sln</code>, <code id="reml_+3A_r">r</code></td>
<td>
<p>Sparse <code>Matrices</code> containing the solutions or residuals
of the Mixed Model Equations.</p>
</td></tr>
<tr><td><code id="reml_+3A_sigma2e">sigma2e</code></td>
<td>
<p>A <code>numeric</code> value for the residual variance estimate
when it has been factored out of the Coefficient matrix of the Mixed Model
Equations, thus converting the (co)variance components to ratios
(represented by the variable lambda).</p>
</td></tr>
<tr><td><code id="reml_+3A_nb">nb</code></td>
<td>
<p>The number of columns in X.</p>
</td></tr>
<tr><td><code id="reml_+3A_listgeninv">listGeninv</code></td>
<td>
<p>A list of generalized inverse matrices.</p>
</td></tr>
<tr><td><code id="reml_+3A_cinv">Cinv</code></td>
<td>
<p>A sparse <code>Matrix</code> containing the inverse of the Coefficient
matrix to the Mixed Model Equations.</p>
</td></tr>
<tr><td><code id="reml_+3A_pinv">pinv</code></td>
<td>
<p>An integer vector of the matrix permutation.</p>
</td></tr>
<tr><td><code id="reml_+3A_grobj">grObj</code></td>
<td>
<p>An list of class <code>grMod</code>.</p>
</td></tr>
<tr><td><code id="reml_+3A_ll">lL</code></td>
<td>
<p>A numeric value for REML log-likelihood value.</p>
</td></tr>
<tr><td><code id="reml_+3A_fd">fd</code></td>
<td>
<p>A character indicating whether forward, combined, or backward finite
differences (&ldquo;fdiff&rdquo;, &ldquo;cdiff&rdquo;, or &ldquo;bdiff&rdquo;, respectively)
are to be calculated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> or <code>matrix</code> containing any of the previous
parameters described above, or the following that are in addition to or
instead of parameters above:
</p>

<dl>
<dt>loglik </dt><dd><p>The REML log-likelihood.</p>
</dd>
<dt>tyPy,logDetC </dt><dd><p>Components of the REML log-likelihood derived from the 
Cholesky factor of the Coefficient matrix to the Mixed Model Equations.</p>
</dd>
<dt>Cinv_ii </dt><dd><p>A vector containing the diagonal elements of the inverse
of the Coefficient matrix to the Mixed Model Equations (i.e., the
diagonal entries of <code>Cinv</code>).</p>
</dd>
<dt>AI </dt><dd><p>A <code>matrix</code> of values containing the Average Information
matrix, or second partial derivatives of the likelihood with respect to
the transformed (co)variance components (nu). The inverse of this matrix
gives the sampling variances of these transformed (co)variance components.</p>
</dd>
<dt>dLdnu </dt><dd><p>A single column <code>matrix</code> of first derivatives of
the transformed (co)variance parameters (nu) with respect to the
log-Likelihood.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>

<hr>
<h2 id='remlIt'>Mixed-effect model Restricted Maximum Likelihood (REML) iterations.</h2><span id='topic+remlIt'></span><span id='topic+remlIt.default'></span><span id='topic+remlIt.gremlinR'></span>

<h3>Description</h3>

<p>Conduct REML iterations to estimate (co)variance parameters of a linear
mixed-effect model (Gaussian responses).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remlIt(grMod, ...)

## Default S3 method:
remlIt(grMod, ...)

## S3 method for class 'gremlinR'
remlIt(grMod, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remlIt_+3A_grmod">grMod</code></td>
<td>
<p>A gremlin model of class <code>grMod</code>. See <code><a href="#topic+gremlin">gremlin</a></code>
or <code><a href="#topic+gremlinSetup">gremlinSetup</a></code> for the functions constructing an object
of class <code>grMod</code>.</p>
</td></tr>
<tr><td><code id="remlIt_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to control the model fitting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> containing an object of class <code>grMod</code> and
<code>matrix</code> containing details of the REML iterations (object
<code>itMat</code>). See <code><a href="#topic+gremlin">gremlin</a></code> for descriptions of <code>grMod</code>
and <code>itMat</code> objects.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>remlIt(default)</code>: Default method
</p>
</li>
<li> <p><code>remlIt(gremlinR)</code>: gremlinR method
</p>
</li></ul>


<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  grSsetp &lt;- gremlinSetup(WWG11 ~ sex - 1, random = ~ sire, data = Mrode11)
  grS &lt;- remlIt(grSsetp)

</code></pre>

<hr>
<h2 id='residuals.gremlin'>Residuals of <code>class</code> &lsquo;gremlin&rsquo;</h2><span id='topic+residuals.gremlin'></span><span id='topic+resid.gremlin'></span>

<h3>Description</h3>

<p>Residuals of <code>class</code> &lsquo;gremlin&rsquo;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gremlin'
residuals(object, type = "response", scaled = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.gremlin_+3A_object">object</code></td>
<td>
<p>An object of <code>class</code> &lsquo;gremlin&rsquo;.</p>
</td></tr>
<tr><td><code id="residuals.gremlin_+3A_type">type</code></td>
<td>
<p>The type of residuals which should be returned. Only implement
&ldquo;response&rdquo; currently. Can be abbreviated.</p>
</td></tr>
<tr><td><code id="residuals.gremlin_+3A_scaled">scaled</code></td>
<td>
<p>Logical value indicating whether to scale residuals by the
residual standard deviation.</p>
</td></tr>
<tr><td><code id="residuals.gremlin_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>numeric</code> vector of residuals.
</p>


<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grS &lt;- gremlin(WWG11 ~ sex - 1, random = ~ sire, data = Mrode11)
residuals(grS)
</code></pre>

<hr>
<h2 id='runtime'>Time to execute the gremlin model</h2><span id='topic+runtime'></span>

<h3>Description</h3>

<p>Extract the length of time to fit the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runtime(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="runtime_+3A_object">object</code></td>
<td>
<p>An object of <code>class</code> &lsquo;gremlin&rsquo;.</p>
</td></tr>
<tr><td><code id="runtime_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to the methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric of class &lsquo;difftime&rsquo; with an attribute of units
(e.g., seconds or minutes).
</p>


<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>

<hr>
<h2 id='summary.gremlin'>Gremlin model summary.</h2><span id='topic+summary.gremlin'></span><span id='topic+print.summary.gremlin'></span>

<h3>Description</h3>

<p>Summarize and print results of linear mixed model fitted with gremlin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gremlin'
summary(object, ...)

## S3 method for class 'summary.gremlin'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.gremlin_+3A_object">object</code>, <code id="summary.gremlin_+3A_x">x</code></td>
<td>
<p>An object of <code>class</code> &lsquo;gremlin&rsquo; or
&lsquo;summary.gremlin&rsquo;.</p>
</td></tr>
<tr><td><code id="summary.gremlin_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to control the output.</p>
</td></tr>
<tr><td><code id="summary.gremlin_+3A_digits">digits</code></td>
<td>
<p>An <code>integer</code> used for number formatting with
&lsquo;signif()&rsquo;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> of class <code>summary.gremlin</code> or a printed value
to the screen with no return values.
</p>

<dl>
<dt>logLik </dt><dd><p>Model log-likelihood.</p>
</dd>
<dt>formulae </dt><dd><p>Function call and model fixed, random, and residual
formulae.</p>
</dd>
<dt>runtime </dt><dd><p>A <code>numeric</code> of class &lsquo;difftime&rsquo; containing
the length of time to run the model. See how this is handled in
<code><a href="#topic+update.gremlin">update.gremlin</a></code>.</p>
</dd>
<dt>lambda </dt><dd><p>A <code>logical</code> indicating if the model was transformed
to the variance ratio, or <code>lambda</code> scale.</p>
</dd>
<dt>residQuants </dt><dd><p>A named <code>vector</code> listing summary output for the
model residuals.</p>
</dd>
<dt>varcompSummary </dt><dd><p>Table of variance components and approximate
standard errors (calculated from the inverse of the average information
matrix). If a (co)variance component is fixed or at the boundary of
its parameter space then an <code>NA</code> is returned for the standard error
and a column with constraint types is added to the table. Alternative
methods (e.g., profile likelihood CIs) should be pursued for obtaining
uncertainties associated with fixed or boundary parameters.</p>
</dd>
<dt>varcompSampCor </dt><dd><p>A <code>matrix</code> containing the sampling correlations
of the (co)variance components. Note this is on the underlying <code>nu</code>
scale that the model is fitting.</p>
</dd>
<dt>coefficients </dt><dd><p>Table of fixed effects and standard errors (calculated
from the corresponding diagonal elements of the inverse of the
coefficient matrix, transformed where necessary).</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gremlin">gremlin</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>grS &lt;- gremlin(WWG11 ~ sex - 1, random = ~ sire, data = Mrode11)
summary(grS)
</code></pre>

<hr>
<h2 id='tr'>Matrix trace methods.</h2><span id='topic+tr'></span><span id='topic+tr.default'></span><span id='topic+tr.dgCMatrix'></span><span id='topic+tr.dsCMatrix'></span>

<h3>Description</h3>

<p>Methods to efficiently calculate a matrix trace depending on the class of matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tr(X, ...)

## Default S3 method:
tr(X, ...)

## S3 method for class 'dgCMatrix'
tr(X, ...)

## S3 method for class 'dsCMatrix'
tr(X, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tr_+3A_x">X</code></td>
<td>
<p>A matrix.</p>
</td></tr>
<tr><td><code id="tr_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>numeric</code> value for the sum of the diagonal elements.
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>tr(default)</code>: Default method
</p>
</li>
<li> <p><code>tr(dgCMatrix)</code>: Method for matrix <code>X</code> of class Matrix:::dgCMatrix
</p>
</li>
<li> <p><code>tr(dsCMatrix)</code>: Method for matrix <code>X</code> of class Matrix:::dsCMatrix
</p>
</li></ul>


<h3>Author(s)</h3>

<p><a href="mailto:matthewwolak@gmail.com">matthewwolak@gmail.com</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
