<!DOCTYPE html><html><head><title>Help for package SiZer</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SiZer}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Arkansas'><p>Time Series of Macroinvertabrates Abundance in the Arkansas River.</p></a></li>
<li><a href='#as.data.frame.SiZer'><p>Coerce SiZer object to a Data Frame</p></a></li>
<li><a href='#bent.cable'><p>Fits a bent-cable model to the given data</p>
Fits a bent-cable model to the given data by exhaustively searching
the 2-dimensional parameter space to find the maximum likelihood
estimators for <code class="reqn">\alpha</code> and <code class="reqn">\gamma</code>.</a></li>
<li><a href='#ggplot_SiZer'><p>Plot a SiZer map using 'ggplot2'</p></a></li>
<li><a href='#locally.weighted.polynomial'><p>Smoothes the given bivariate data using kernel regression.</p></a></li>
<li><a href='#logLik.bent_cable'><p>Return the log-Likelihood value for a fitted bent-cable model.</p></a></li>
<li><a href='#logLik.PiecewiseLinear'><p>Calculates the log-Likelihood value</p></a></li>
<li><a href='#piecewise.linear'><p>Creates a piecewise linear model</p></a></li>
<li><a href='#plot.LocallyWeightedPolynomial'><p>Creates a plot of an object created by <code>locally.weighted.polynomial</code>.</p></a></li>
<li><a href='#plot.PiecewiseLinear'><p>Plots a piecewise linear model</p></a></li>
<li><a href='#plot.SiZer'><p>Plot a SiZer map</p>
Plot a <code>SiZer</code> object that was created using <code>SiZer()</code></a></li>
<li><a href='#predict.bent_cable'><p>Return model predictions for fitted bent-cable model</p></a></li>
<li><a href='#predict.PiecewiseLinear'><p>Calculates predicted values from a piecewise linear object</p></a></li>
<li><a href='#print.PiecewiseLinear'><p>Prints out the model form for a Piecewise linear model</p></a></li>
<li><a href='#SiZer'><p>Calculate SiZer Map</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.1-8</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-7-09</td>
</tr>
<tr>
<td>Title:</td>
<td>Significant Zero Crossings</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, graphics, splines, boot, ggplot2, dplyr, tidyr, rlang</td>
</tr>
<tr>
<td>Description:</td>
<td>Calculates and plots the SiZer map for scatterplot data.  A 
  SiZer map is a way of examining when the p-th derivative of a 
  scatterplot-smoother is significantly negative, possibly zero or 
  significantly positive across a range of smoothing bandwidths.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/dereksonderegger/SiZer">https://github.com/dereksonderegger/SiZer</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.0</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-07-09 19:18:21 UTC; dls354</td>
</tr>
<tr>
<td>Author:</td>
<td>Derek Sonderegger [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Derek Sonderegger &lt;derek.sonderegger@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-07-09 19:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='Arkansas'>Time Series of Macroinvertabrates Abundance in the Arkansas River.</h2><span id='topic+Arkansas'></span>

<h3>Description</h3>

<p>A time series of 16 years (5 replicates per year) of mayfly 
(Ephemeroptera:Heptageniidae) abundance in the fall at the monitoring station AR1
on the Arkansas River in Colorado, USA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Arkansas, package='SiZer')
</code></pre>


<h3>Format</h3>

<p>A data frame with 90 observations on the following 2 variables.
</p>

<dl>
<dt>year</dt><dd><p>The year of observation</p>
</dd>
<dt>sqrt.mayflies</dt><dd><p>The Square root of observed abundance.</p>
</dd>
</dl>



<h3>Source</h3>

<p>Sonderegger, D.L., Wang, H., Clements, W.H., and Noon, B.R. 2009. 
Using SiZer to detect thresholds in ecological data. Frontiers in Ecology and 
the Environment 7:190-195.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(ggplot2)

data(Arkansas)
ggplot(Arkansas, aes(x=year, y=sqrt.mayflies)) + 
   geom_point()

</code></pre>

<hr>
<h2 id='as.data.frame.SiZer'>Coerce SiZer object to a Data Frame</h2><span id='topic+as.data.frame.SiZer'></span>

<h3>Description</h3>

<p>Coerce SiZer object to a Data Frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SiZer'
as.data.frame(x, row.names = NULL, optional = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.SiZer_+3A_x">x</code></td>
<td>
<p>An object produced by 'SiZer()'.</p>
</td></tr>
<tr><td><code id="as.data.frame.SiZer_+3A_row.names">row.names</code></td>
<td>
<p>Required for generic compatibility. Not used.</p>
</td></tr>
<tr><td><code id="as.data.frame.SiZer_+3A_optional">optional</code></td>
<td>
<p>Required for generic compatibility. Not used.</p>
</td></tr>
<tr><td><code id="as.data.frame.SiZer_+3A_...">...</code></td>
<td>
<p>Required for generic compatibility. Not used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data('Arkansas')
x &lt;- Arkansas$year
y &lt;- Arkansas$sqrt.mayflies

plot(x,y)

# Calculate the SiZer map for the first derivative
SiZer.1 &lt;- SiZer(x, y, h=c(.5,10), degree=1, derv=1, grid.length=21)
as.data.frame(SiZer.1)
</code></pre>

<hr>
<h2 id='bent.cable'>Fits a bent-cable model to the given data
Fits a bent-cable model to the given data by exhaustively searching
the 2-dimensional parameter space to find the maximum likelihood
estimators for <code class="reqn">\alpha</code> and <code class="reqn">\gamma</code>.</h2><span id='topic+bent.cable'></span>

<h3>Description</h3>

<p>Fits a bent-cable model to the given data
Fits a bent-cable model to the given data by exhaustively searching
the 2-dimensional parameter space to find the maximum likelihood
estimators for <code class="reqn">\alpha</code> and <code class="reqn">\gamma</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bent.cable(x, y, grid.size = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bent.cable_+3A_x">x</code></td>
<td>
<p>The independent variable</p>
</td></tr>
<tr><td><code id="bent.cable_+3A_y">y</code></td>
<td>
<p>The dependent variable</p>
</td></tr>
<tr><td><code id="bent.cable_+3A_grid.size">grid.size</code></td>
<td>
<p>How many <code class="reqn">\alpha</code> and <code class="reqn">gamma</code> values to examine.
The total number of parameter combinations examined is 
<code>grid.size</code> squared.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fit the model which is essentially a piecewise linear model with a 
quadratic curve of length <code class="reqn">2\gamma</code> connecting the two linear pieces.
</p>
<p>The reason for searching the space exhaustively is because the bent-cable 
model often has a likelihood surface with a very flat ridge instead of 
definite peak.  While the exhaustive search is slow, at least it is possible 
to examine the contour plot of the likelihood surface.
</p>
<p>@return 	A list of 7 elements: </p>

<dl>
<dt>log.likelihood</dt><dd><p>A matrix of log-likelihood values.</p>
</dd>
<dt>SSE</dt><dd><p>A matrix of sum-of-square-error values.</p>
</dd>
<dt>alphas</dt><dd><p>A vector of alpha values examined.</p>
</dd>
<dt>gammas</dt><dd><p>A vector of gamma values examined.</p>
</dd>
<dt>alpha</dt><dd><p>The MLE estimate of alpha.</p>
</dd>
<dt>gamma</dt><dd><p>The MLE estimate of gamma.</p>
</dd>
<dt>model</dt><dd><p>The <code>lm</code> fit after <code class="reqn">alpha</code> and <code class="reqn">gamma</code> are known. </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Derek Sonderegger
</p>


<h3>References</h3>

<p>Chiu, G. S., R. Lockhart, and R. Routledge. 2006. Bent-cable regression 
theory and applications. Journal of the American Statistical Association 
101:542-553.
</p>
<p>Toms, J. D., and M. L. Lesperance. 2003. Piecewise regression: a tool for 
identifying ecological thresholds. Ecology 84:2034-2041.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+piecewise.linear">piecewise.linear</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Arkansas)
x &lt;- Arkansas$year
y &lt;- Arkansas$sqrt.mayflies

# For a more accurate estimate, increase grid.size
model &lt;- bent.cable(x,y, grid.size=20)
plot(x,y)
x.grid &lt;- seq(min(x), max(x), length=200)
lines(x.grid, predict(model, x.grid), col='red')

</code></pre>

<hr>
<h2 id='ggplot_SiZer'>Plot a SiZer map using 'ggplot2'</h2><span id='topic+ggplot_SiZer'></span>

<h3>Description</h3>

<p>Plot a 'SiZer' object that was created using 'SiZer()'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggplot_SiZer(x, colorlist = c("red", "purple", "blue", "grey"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ggplot_SiZer_+3A_x">x</code></td>
<td>
<p>An object created using 'SiZer()'</p>
</td></tr>
<tr><td><code id="ggplot_SiZer_+3A_colorlist">colorlist</code></td>
<td>
<p>What colors should be used.  This is a vector that 
corresponds to 'decreasing', 'possibley zero', 'increasing', 
and 'insufficient data'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The white lines in the SiZer map give a graphical representation 
of the bandwidth.  The horizontal distance between the lines is <code class="reqn">2h</code>.
</p>


<h3>Author(s)</h3>

<p>Derek Sonderegger
</p>


<h3>References</h3>

<p>Chaudhuri, P., and J. S. Marron. 1999. SiZer for exploration of structures
in curves. Journal of the American Statistical Association 94:807-823. 
</p>
<p>Hannig, J., and J. S. Marron. 2006. Advanced distribution theory for SiZer. 
Journal of the American Statistical Association 101:484-499.
</p>
<p>Sonderegger, D.L., Wang, H., Clements, W.H., and Noon, B.R. 2009. Using SiZer to detect
thresholds in ecological data. Frontiers in Ecology and the Environment 7:190-195.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.SiZer">plot.SiZer</a></code>, <code><a href="#topic+locally.weighted.polynomial">locally.weighted.polynomial</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data('Arkansas')
x &lt;- Arkansas$year
y &lt;- Arkansas$sqrt.mayflies

plot(x,y)

# Calculate the SiZer map for the first derivative
SiZer.1 &lt;- SiZer(x, y, h=c(.5,10), degree=1, derv=1, grid.length=21)
plot(SiZer.1)
plot(SiZer.1, ggplot2=TRUE)
ggplot_SiZer(SiZer.1)

# Calculate the SiZer map for the second derivative
SiZer.2 &lt;- SiZer(x, y, h=c(.5,10), degree=2, derv=2, grid.length=21);
plot(SiZer.2)
plot(SiZer.2, ggplot2=TRUE)
ggplot_SiZer(SiZer.2)


# By setting the grid.length larger, we get a more detailed SiZer
# map but it takes longer to compute. 
#
# SiZer.3 &lt;- SiZer(x, y, h=c(.5,10), grid.length=100, degree=1, derv=1)
# plot(SiZer.3)  
  
</code></pre>

<hr>
<h2 id='locally.weighted.polynomial'>Smoothes the given bivariate data using kernel regression.</h2><span id='topic+locally.weighted.polynomial'></span>

<h3>Description</h3>

<p>Smoothes the given bivariate data using kernel regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locally.weighted.polynomial(
  x,
  y,
  h = NA,
  x.grid = NA,
  degree = 1,
  kernel.type = "Normal"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locally.weighted.polynomial_+3A_x">x</code></td>
<td>
<p>Vector of data for the independent variable</p>
</td></tr>
<tr><td><code id="locally.weighted.polynomial_+3A_y">y</code></td>
<td>
<p>Vector of data for the dependent variable</p>
</td></tr>
<tr><td><code id="locally.weighted.polynomial_+3A_h">h</code></td>
<td>
<p>The bandwidth for the kernel</p>
</td></tr>
<tr><td><code id="locally.weighted.polynomial_+3A_x.grid">x.grid</code></td>
<td>
<p>What x-values should the value of the smoother be calculated at.</p>
</td></tr>
<tr><td><code id="locally.weighted.polynomial_+3A_degree">degree</code></td>
<td>
<p>The degree of the polynomial to be fit at each x-value. The default 
is to fit a linear regression, ie degree=1.</p>
</td></tr>
<tr><td><code id="locally.weighted.polynomial_+3A_kernel.type">kernel.type</code></td>
<td>
<p>What kernel to use.  Valid choices are 'Normal',
'Epanechnikov', 'biweight', and 'triweight'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The confidence intervals are created using the row-wise method of 
Hannig and Marron (2006).
</p>
<p>Notice that the derivative to be estimated must be less than or equal to 
the degree of the polynomial initially fit to the data.
</p>
<p>If the bandwidth is not given, the Sheather-Jones bandwidth selection method is used.
</p>


<h3>Value</h3>

<p>Returns a <code>LocallyWeightedPolynomial</code> object that has the following elements:
</p>

<dl>
<dt>data</dt><dd><p>A structure of the data used to generate the smoothing curve</p>
</dd>
<dt>h</dt><dd><p>The bandwidth used to generate the smoothing curve.</p>
</dd>
<dt>x.grid</dt><dd><p>The grid of x-values that we have estimated function value 
and derivative(s) for.</p>
</dd>
<dt>degrees.freedom</dt><dd><p>The effective sample size at each grid point</p>
</dd>
<dt>Beta</dt><dd><p>A matrix of estimated beta values.  The number of rows is
degrees+1, while the number of columns is the same as the length
of x.grid. Notice that 
</p>
<p style="text-align: center;"><code class="reqn"> \hat{f}(x_i)   = \beta[1,i] </code>
</p>

<p style="text-align: center;"><code class="reqn"> \hat{f'}(x_i)  = \beta[2,i]*1! </code>
</p>

<p style="text-align: center;"><code class="reqn"> \hat{f''}(x_i) = \beta[3,i]*2! </code>
</p>
  
<p>and so on...</p>
</dd>
<dt>Beta.var</dt><dd><p>Matrix of estimated variances for <code>Beta</code>.  Same structure as <code>Beta</code>.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Derek Sonderegger
</p>


<h3>References</h3>

<p>Chaudhuri, P., and J. S. Marron. 1999. SiZer for exploration of structures in curves. 
Journal of the American Statistical Association 94 807-823. 
</p>
<p>Hannig, J., and J. S. Marron. 2006. Advanced distribution theory for SiZer. 
Journal of the American Statistical Association 101 484-499.
</p>
<p>Sonderegger, D.L., Wang, H., Clements, W.H., and Noon, B.R. 2009. Using SiZer to detect
thresholds in ecological data. Frontiers in Ecology and the Environment 7:190-195
</p>


<h3>See Also</h3>

<p><code><a href="#topic+SiZer">SiZer</a></code>, <code><a href="#topic+plot.LocallyWeightedPolynomial">plot.LocallyWeightedPolynomial</a></code>,  
<code>spm</code> in package 'SemiPar', <code><a href="stats.html#topic+loess">loess</a></code>, <code><a href="stats.html#topic+smooth.spline">smooth.spline</a></code>, 
<code><a href="splines.html#topic+interpSpline">interpSpline</a></code> in the <code>splines</code> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Arkansas)
x &lt;- Arkansas$year
y &lt;- Arkansas$sqrt.mayflies
layout(cbind(1,2,3))
model &lt;- locally.weighted.polynomial(x,y)
plot(model, main='Smoothed Function', xlab='Year', ylab='Sqrt.Mayflies')

model2 &lt;- locally.weighted.polynomial(x,y,h=.5)
plot(model2, main='Smoothed Function', xlab='Year', ylab='Sqrt.Mayflies')

model3 &lt;- locally.weighted.polynomial(x,y, degree=1)
plot(model3, derv=1, main='First Derivative', xlab='Year', ylab='1st Derivative')

</code></pre>

<hr>
<h2 id='logLik.bent_cable'>Return the log-Likelihood value for a fitted bent-cable model.</h2><span id='topic+logLik.bent_cable'></span>

<h3>Description</h3>

<p>Return the log-Likelihood value for a fitted bent-cable model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bent_cable'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.bent_cable_+3A_object">object</code></td>
<td>
<p>A bent-cable model</p>
</td></tr>
<tr><td><code id="logLik.bent_cable_+3A_...">...</code></td>
<td>
<p>Unused at this time.</p>
</td></tr>
</table>

<hr>
<h2 id='logLik.PiecewiseLinear'>Calculates the log-Likelihood value</h2><span id='topic+logLik.PiecewiseLinear'></span>

<h3>Description</h3>

<p>Calculates the log-Likelihood value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PiecewiseLinear'
logLik(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logLik.PiecewiseLinear_+3A_object">object</code></td>
<td>
<p>A <code>PiecewiseLinear</code> object</p>
</td></tr>
<tr><td><code id="logLik.PiecewiseLinear_+3A_...">...</code></td>
<td>
<p>Unused at this time.</p>
</td></tr>
</table>

<hr>
<h2 id='piecewise.linear'>Creates a piecewise linear model</h2><span id='topic+piecewise.linear'></span>

<h3>Description</h3>

<p>Fit a degree 1 spline with 1 knot point where the location of the 
knot point is unknown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>piecewise.linear(
  x,
  y,
  middle = 1,
  CI = FALSE,
  bootstrap.samples = 1000,
  sig.level = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="piecewise.linear_+3A_x">x</code></td>
<td>
<p>Vector of data for the x-axis.</p>
</td></tr>
<tr><td><code id="piecewise.linear_+3A_y">y</code></td>
<td>
<p>Vector of data for the y-axis</p>
</td></tr>
<tr><td><code id="piecewise.linear_+3A_middle">middle</code></td>
<td>
<p>A scalar in <code class="reqn">[0,1]</code>. This represents the range that the change-point
can occur in.  <code class="reqn">0</code> means the change-point must occur at the middle of the range of 
x-values.  <code class="reqn">1</code> means that the change-point can occur anywhere along the range of the 
x-values.</p>
</td></tr>
<tr><td><code id="piecewise.linear_+3A_ci">CI</code></td>
<td>
<p>Whether or not a bootstrap confidence interval should be calculated. Defaults to
FALSE because the interval takes a non-trivial amount of time to calculate</p>
</td></tr>
<tr><td><code id="piecewise.linear_+3A_bootstrap.samples">bootstrap.samples</code></td>
<td>
<p>The number of bootstrap samples to take when calculating the CI.</p>
</td></tr>
<tr><td><code id="piecewise.linear_+3A_sig.level">sig.level</code></td>
<td>
<p>What significance level to use for the confidence intervals.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The bootstrap samples are taken by resampling the raw data points.  
Sometimes a more appropriate bootstrap sample would be to calculate the residuals and 
then add a randomly selected residual to each y-value.
</p>


<h3>Value</h3>

<p>A list of 5 elements is returned: </p>

<dl>
<dt>change.point</dt><dd><p>The estimate of <code class="reqn">\alpha</code>.</p>
</dd>
<dt>model</dt><dd><p>The resulting <code>lm</code> object once <code class="reqn">\alpha</code> is known. </p>
</dd>
<dt>x</dt><dd><p>The x-values used.</p>
</dd>
<dt>y</dt><dd><p>The y-values used.</p>
</dd>
<dt>CI</dt><dd><p>Whether or not the confidence interval was calculated.</p>
</dd>
<dt>intervals</dt><dd><p>If the CIs where calculated, this is a matrix of the
upper and lower intervals.</p>
</dd>
</dl>



<h3>References</h3>

<p>Chiu, G. S., R. Lockhart, and R. Routledge. 2006. Bent-cable regression 
theory and applications. Journal of the American Statistical Association 
101:542-553.
</p>
<p>Toms, J. D., and M. L. Lesperance. 2003. Piecewise regression: a tool for 
identifying ecological thresholds. Ecology 84:2034-2041.
</p>


<h3>See Also</h3>

<p>The package <code>segmented</code> has a much more general implementation
of this analysis and users should preferentially use that package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Arkansas)
x &lt;- Arkansas$year
y &lt;- Arkansas$sqrt.mayflies

model &lt;- piecewise.linear(x,y, CI=FALSE)
plot(model)
print(model)
predict(model, 2001)
</code></pre>

<hr>
<h2 id='plot.LocallyWeightedPolynomial'>Creates a plot of an object created by <code>locally.weighted.polynomial</code>.</h2><span id='topic+plot.LocallyWeightedPolynomial'></span>

<h3>Description</h3>

<p>Creates a plot of an object created by <code>locally.weighted.polynomial</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LocallyWeightedPolynomial'
plot(
  x,
  derv = 0,
  CI.method = 2,
  alpha = 0.05,
  use.ess = TRUE,
  draw.points = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.LocallyWeightedPolynomial_+3A_x">x</code></td>
<td>
<p>LocallyWeightedPolynomial object</p>
</td></tr>
<tr><td><code id="plot.LocallyWeightedPolynomial_+3A_derv">derv</code></td>
<td>
<p>Derivative to be plotted.  Default is 0 - which plots the smoothed function.</p>
</td></tr>
<tr><td><code id="plot.LocallyWeightedPolynomial_+3A_ci.method">CI.method</code></td>
<td>
<p>What method should be used to calculate the confidence interval about the estimated line.
The methods are from Hannig and Marron (2006), where 1 is the point-wise estimate, and 2 is 
the row-wise estimate.</p>
</td></tr>
<tr><td><code id="plot.LocallyWeightedPolynomial_+3A_alpha">alpha</code></td>
<td>
<p>The alpha level such that the CI has a 1-alpha/2 level of significance.</p>
</td></tr>
<tr><td><code id="plot.LocallyWeightedPolynomial_+3A_use.ess">use.ess</code></td>
<td>
<p>ESS stands for the estimated sample size.  If at any point along the x-axis, the ESS is 
too small, then we will not plot unless use.ess=FALSE.</p>
</td></tr>
<tr><td><code id="plot.LocallyWeightedPolynomial_+3A_draw.points">draw.points</code></td>
<td>
<p>Should the data points be included in the graph? Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="plot.LocallyWeightedPolynomial_+3A_...">...</code></td>
<td>
<p>Additional arguments to be passed to the graphing functions.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.PiecewiseLinear'>Plots a piecewise linear model</h2><span id='topic+plot.PiecewiseLinear'></span>

<h3>Description</h3>

<p>Plots a piecewise linear model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PiecewiseLinear'
plot(x, xlab = "X", ylab = "Y", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.PiecewiseLinear_+3A_x">x</code></td>
<td>
<p>A <code>PiecewiseLinear</code> object</p>
</td></tr>
<tr><td><code id="plot.PiecewiseLinear_+3A_xlab">xlab</code></td>
<td>
<p>The label for the x-axis</p>
</td></tr>
<tr><td><code id="plot.PiecewiseLinear_+3A_ylab">ylab</code></td>
<td>
<p>The label for the y-axis</p>
</td></tr>
<tr><td><code id="plot.PiecewiseLinear_+3A_...">...</code></td>
<td>
<p>Any further options to be passed to the <code>plot</code> function</p>
</td></tr>
</table>

<hr>
<h2 id='plot.SiZer'>Plot a SiZer map
Plot a <code>SiZer</code> object that was created using <code>SiZer()</code></h2><span id='topic+plot.SiZer'></span>

<h3>Description</h3>

<p>Plot a SiZer map
Plot a <code>SiZer</code> object that was created using <code>SiZer()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SiZer'
plot(
  x,
  ylab = expression(log[10](h)),
  colorlist = c("red", "purple", "blue", "grey"),
  ggplot2 = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.SiZer_+3A_x">x</code></td>
<td>
<p>An object created using <code>SiZer()</code></p>
</td></tr>
<tr><td><code id="plot.SiZer_+3A_ylab">ylab</code></td>
<td>
<p>What the y-axis should be labled.</p>
</td></tr>
<tr><td><code id="plot.SiZer_+3A_colorlist">colorlist</code></td>
<td>
<p>What colors should be used.  This is a vector that 
corresponds to 'decreasing', 'possibley zero', 'increasing', 
and 'insufficient data'.</p>
</td></tr>
<tr><td><code id="plot.SiZer_+3A_ggplot2">ggplot2</code></td>
<td>
<p>Should the graphing be done using 'ggplot2'? Defaults to 
FALSE for backwards compatibility.</p>
</td></tr>
<tr><td><code id="plot.SiZer_+3A_...">...</code></td>
<td>
<p>Any other parameters to be passed to the function <code>image</code>. 
Ignored if 'ggplot2' is TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The white lines in the SiZer map give a graphical representation 
of the bandwidth.  The horizontal distance between the lines is <code class="reqn">2h</code>.
</p>


<h3>Author(s)</h3>

<p>Derek Sonderegger
</p>


<h3>References</h3>

<p>Chaudhuri, P., and J. S. Marron. 1999. SiZer for exploration of structures
in curves. Journal of the American Statistical Association 94:807-823. 
</p>
<p>Hannig, J., and J. S. Marron. 2006. Advanced distribution theory for SiZer. 
Journal of the American Statistical Association 101:484-499.
</p>
<p>Sonderegger, D.L., Wang, H., Clements, W.H., and Noon, B.R. 2009. Using SiZer to detect
thresholds in ecological data. Frontiers in Ecology and the Environment 7:190-195.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.SiZer">plot.SiZer</a></code>, <code><a href="#topic+locally.weighted.polynomial">locally.weighted.polynomial</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data('Arkansas')
x &lt;- Arkansas$year
y &lt;- Arkansas$sqrt.mayflies

plot(x,y)

# Calculate the SiZer map for the first derivative
SiZer.1 &lt;- SiZer(x, y, h=c(.5,10), degree=1, derv=1, grid.length=21)
plot(SiZer.1)
plot(SiZer.1, ggplot2=TRUE)

# Calculate the SiZer map for the second derivative
SiZer.2 &lt;- SiZer(x, y, h=c(.5,10), degree=2, derv=2, grid.length=21);
plot(SiZer.2)

# By setting the grid.length larger, we get a more detailed SiZer
# map but it takes longer to compute. 
#
# SiZer.3 &lt;- SiZer(x, y, h=c(.5,10), grid.length=100, degree=1, derv=1)
# plot(SiZer.3)  
  
</code></pre>

<hr>
<h2 id='predict.bent_cable'>Return model predictions for fitted bent-cable model</h2><span id='topic+predict.bent_cable'></span>

<h3>Description</h3>

<p>Return model predictions for fitted bent-cable model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bent_cable'
predict(object, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.bent_cable_+3A_object">object</code></td>
<td>
<p>A bent-cable model</p>
</td></tr>
<tr><td><code id="predict.bent_cable_+3A_x">x</code></td>
<td>
<p>The set x-values for which predictions are desired</p>
</td></tr>
<tr><td><code id="predict.bent_cable_+3A_...">...</code></td>
<td>
<p>A placeholder that is currently ignored.</p>
</td></tr>
</table>

<hr>
<h2 id='predict.PiecewiseLinear'>Calculates predicted values from a piecewise linear object</h2><span id='topic+predict.PiecewiseLinear'></span>

<h3>Description</h3>

<p>Calculates predicted values from a piecewise linear object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PiecewiseLinear'
predict(object, x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.PiecewiseLinear_+3A_object">object</code></td>
<td>
<p>A <code>PiecewiseLinear</code> object</p>
</td></tr>
<tr><td><code id="predict.PiecewiseLinear_+3A_x">x</code></td>
<td>
<p>A vector of x-values in which to calculate the y.</p>
</td></tr>
<tr><td><code id="predict.PiecewiseLinear_+3A_...">...</code></td>
<td>
<p>Unused at this time.</p>
</td></tr>
</table>

<hr>
<h2 id='print.PiecewiseLinear'>Prints out the model form for a Piecewise linear model</h2><span id='topic+print.PiecewiseLinear'></span>

<h3>Description</h3>

<p>Prints out the model form for a Piecewise linear model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'PiecewiseLinear'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.PiecewiseLinear_+3A_x">x</code></td>
<td>
<p>A <code>PiecewiseLinear</code> object</p>
</td></tr>
<tr><td><code id="print.PiecewiseLinear_+3A_...">...</code></td>
<td>
<p>Unused at this time.</p>
</td></tr>
</table>

<hr>
<h2 id='SiZer'>Calculate SiZer Map</h2><span id='topic+SiZer'></span>

<h3>Description</h3>

<p>Calculates the SiZer map from a given set of X and Y variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SiZer(
  x,
  y,
  h = NA,
  x.grid = NA,
  degree = NA,
  derv = 1,
  grid.length = 41,
  quiet = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SiZer_+3A_x">x</code></td>
<td>
<p>data vector for the independent axis</p>
</td></tr>
<tr><td><code id="SiZer_+3A_y">y</code></td>
<td>
<p>data vector for the dependent axis</p>
</td></tr>
<tr><td><code id="SiZer_+3A_h">h</code></td>
<td>
<p>An integer representing how many bandwidths should be considered, or
vector of length 2 representing the upper and lower limits h should take,
or a vector of length greater than two indicating which bandwidths to examine.</p>
</td></tr>
<tr><td><code id="SiZer_+3A_x.grid">x.grid</code></td>
<td>
<p>An integer representing how many bins to use along the x-axis, or
a vector of length 2 representing the upper and lower limits the x-axis
should take, or a vector of length greater than two indicating which 
x-values the derivative should be evaluated at</p>
</td></tr>
<tr><td><code id="SiZer_+3A_degree">degree</code></td>
<td>
<p>The degree of the local weighted polynomial used to smooth the data.
This must be greater than or equal to <code>derv</code>.</p>
</td></tr>
<tr><td><code id="SiZer_+3A_derv">derv</code></td>
<td>
<p>The order of derivative for which to make the SiZer map.</p>
</td></tr>
<tr><td><code id="SiZer_+3A_grid.length">grid.length</code></td>
<td>
<p>The default length of the <code>h.grid</code> or <code>x.grid</code> 
if the length of either is not given.</p>
</td></tr>
<tr><td><code id="SiZer_+3A_quiet">quiet</code></td>
<td>
<p>Should diagnostic messages be suppressed? Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>SiZer stands for the Significant Zero crossings of the derivative.  There are two 
dominate approaches in smoothing bivariate data: locally weighted regression or penalized splines.
Both approaches require the use of a 'bandwidth' parameter that controls how much smoothing
should be done.  Unfortunately there is no uniformly best bandwidth selection procedure.
SiZer (Chaudhuri and Marron, 1999) is a procedure that looks across a range of bandwidths
and classifies the p-th derivative of the smoother into one of three states: significantly
increasing (blue), possibly zero (purple), or significantly negative (red).
</p>


<h3>Value</h3>

<p>Returns list object of type SiZer which has the following components:
</p>

<dl>
<dt>x.grid</dt><dd><p>Vector of x-values at which the derivative was evaluated.</p>
</dd>
<dt>h.grid</dt><dd><p>Vector of bandwidth values for which a smoothing function was calculated.</p>
</dd> 
<dt>slopes</dt><dd><p>Matrix of what category a particular x-value and bandwidth falls into 
(Increasing=1, Possibly Zero=0, Decreasing=-1, Not Enough Data=2).</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Derek Sonderegger
</p>


<h3>References</h3>

<p>Chaudhuri, P., and J. S. Marron. 1999. SiZer for exploration of structures
in curves. Journal of the American Statistical Association 94:807-823. 
</p>
<p>Hannig, J., and J. S. Marron. 2006. Advanced distribution theory for SiZer. 
Journal of the American Statistical Association 101:484-499.
</p>
<p>Sonderegger, D.L., Wang, H., Clements, W.H., and Noon, B.R. 2009. Using SiZer to detect
thresholds in ecological data. Frontiers in Ecology and the Environment 7:190-195.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.SiZer">plot.SiZer</a></code>, <code><a href="#topic+locally.weighted.polynomial">locally.weighted.polynomial</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data('Arkansas')
x &lt;- Arkansas$year
y &lt;- Arkansas$sqrt.mayflies

plot(x,y)

# Calculate the SiZer map for the first derivative
SiZer.1 &lt;- SiZer(x, y, h=c(.5,10), degree=1, derv=1, grid.length=21)
plot(SiZer.1)
plot(SiZer.1, ggplot2=TRUE)

# Calculate the SiZer map for the second derivative
SiZer.2 &lt;- SiZer(x, y, h=c(.5,10), degree=2, derv=2, grid.length=21);
plot(SiZer.2)

# By setting the grid.length larger, we get a more detailed SiZer
# map but it takes longer to compute. 
#
# SiZer.3 &lt;- SiZer(x, y, h=c(.5,10), grid.length=100, degree=1, derv=1)
# plot(SiZer.3)  
  
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
