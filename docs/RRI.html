<!DOCTYPE html><html><head><title>Help for package RRI</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RRI}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#check_model'><p>Checks whether the input <code>model</code> is valid.</p></a></li>
<li><a href='#example_clustering'><p>An example <code>clustering</code> object. A clustering is a <code>List</code> that</p>
splits indexes 1..#num_datapoints to clusters. Each <code>List</code> element corresponds to one cluster.
The clustering is not necessarily a partition but it usually is.</a></li>
<li><a href='#example_model'><p>Example regression model and H0.</p></a></li>
<li><a href='#fastLm'><p>Fast least squares</p></a></li>
<li><a href='#get_clustered_eps'><p>Calculate residuals restricted under H0</p></a></li>
<li><a href='#OLS_c'><p>Fast least squares</p></a></li>
<li><a href='#one_sided_test'><p>One-sided testing</p></a></li>
<li><a href='#out_pval'><p>Calculates p-value or test decision</p></a></li>
<li><a href='#r_test_c'><p>Residual randomization test</p></a></li>
<li><a href='#restricted_OLS_c'><p>Fast least squares with linear constraint</p></a></li>
<li><a href='#rrinf'><p>Generic residual randomization confidence intervals</p></a></li>
<li><a href='#rrinf_clust'><p>Residual randomization inference based on cluster invariances</p></a></li>
<li><a href='#rrinfBase'><p>Generic residual randomization inference</p>
This function provides the basis for all other rrinf* functions.</a></li>
<li><a href='#rrtest'><p>Generic residual randomization test</p></a></li>
<li><a href='#rrtest_clust'><p>Residual randomization test under cluster invariances</p></a></li>
<li><a href='#two_sided_test'><p>Two-sided testing</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Residual Randomization Inference for Regression Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Panos Toulis</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Panos Toulis &lt;panos.toulis@chicagobooth.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Testing and inference for regression models using residual randomization methods. The basis of inference is an invariance assumption on the regression errors, e.g., clustered errors, or doubly-clustered errors.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.1)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-12-19 05:34:16 UTC; ptoulis</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-12-19 06:40:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='check_model'>Checks whether the input <code>model</code> is valid.</h2><span id='topic+check_model'></span>

<h3>Description</h3>

<p>Checks whether the input <code>model</code> is valid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_model(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_model_+3A_model">model</code></td>
<td>
<p>A <code>model</code> object. See <a href="#topic+example_model">example_model</a> for details.</p>
</td></tr>
</table>

<hr>
<h2 id='example_clustering'>An example <code>clustering</code> object. A clustering is a <code>List</code> that
splits indexes 1..#num_datapoints to clusters. Each <code>List</code> element corresponds to one cluster.
The clustering is not necessarily a partition but it usually is.</h2><span id='topic+example_clustering'></span>

<h3>Description</h3>

<p>An example <code>clustering</code> object. A clustering is a <code>List</code> that
splits indexes 1..#num_datapoints to clusters. Each <code>List</code> element corresponds to one cluster.
The clustering is not necessarily a partition but it usually is.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_clustering()
</code></pre>


<h3>Value</h3>

<p>A <code>List</code> for the clustering of indexes 1..#num_datapoints.
</p>

<hr>
<h2 id='example_model'>Example regression model and H0.</h2><span id='topic+example_model'></span>

<h3>Description</h3>

<p>Example regression model and H0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>example_model(n = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="example_model_+3A_n">n</code></td>
<td>
<p>Number of datapoints.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of (y, X, lam, lam0) that corresponds to regression model and null hypothesis:
</p>

<ul>
<li><p> y = n-length vector of outcomes
</p>
</li>
<li><p> X = n x p covariate matrix;
</p>
</li>
<li><p> lam = p-vector of coefficients
</p>
</li>
<li><p> lam0 = real number.
</p>
</li></ul>

<p>The null we are testing through this specification is
</p>
<p>H0: lam' beta = lam[1] * beta[1] + ... + lam[p] * beta[p] = lam0,
</p>
<p>where beta are the model parameters in the regression, y = X beta + e.
By default this example sets p = 2-dim model, lam = (0, 1) and lam0 = 0. In this specification, H0: beta[2] = 0.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model = example_model()
lm(model$y ~ model$X + 0)
</code></pre>

<hr>
<h2 id='fastLm'>Fast least squares</h2><span id='topic+fastLm'></span>

<h3>Description</h3>

<p>This functions fits the regression y ~ X using Armadillo <code>solve</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fastLm(y, X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fastLm_+3A_y">y</code></td>
<td>
<p>Vector of outcomes.</p>
</td></tr>
<tr><td><code id="fastLm_+3A_x">X</code></td>
<td>
<p>Matrix of covariates (first column should be 1's)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>List</code> of regression output with elements <code>coef</code>, <code>stderr</code>.
</p>

<hr>
<h2 id='get_clustered_eps'>Calculate residuals restricted under H0</h2><span id='topic+get_clustered_eps'></span>

<h3>Description</h3>

<p>Given regression <code>model</code> and <code>clustering</code>, this function calculates the OLS residuals
under the linear null hypothesis, and assigns them to the specified clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_clustered_eps(model, clustering)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_clustered_eps_+3A_model">model</code></td>
<td>
<p>A regression <code>model</code>. See <a href="#topic+example_model">example_model</a> for details.</p>
</td></tr>
<tr><td><code id="get_clustered_eps_+3A_clustering">clustering</code></td>
<td>
<p>A <code>List</code> that specifies a clustering of indexes 1...n (#datapoints).
See <a href="#topic+example_clustering">example_clustering</a> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>List</code> of the restricted residuals clustered according to <code>clustering</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m = example_model(n=100)
cl = list(1:50, 51:100)
er = get_clustered_eps(m, cl)
stopifnot(length(er) == length(cl))
stopifnot(length(er[[1]]) == 50)
</code></pre>

<hr>
<h2 id='OLS_c'>Fast least squares</h2><span id='topic+OLS_c'></span>

<h3>Description</h3>

<p>Fast OLS as in <a href="#topic+fastLm">fastLm</a> but returns only the fitted coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OLS_c(y, X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OLS_c_+3A_y">y</code></td>
<td>
<p>Vector of outcomes.</p>
</td></tr>
<tr><td><code id="OLS_c_+3A_x">X</code></td>
<td>
<p>Matrix of covariates (first column should be 1's)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of coefficients.
</p>

<hr>
<h2 id='one_sided_test'>One-sided testing</h2><span id='topic+one_sided_test'></span>

<h3>Description</h3>

<p>Decides to reject or not based on observed test statistic value <code>tobs</code> and randomization values <code>tvals</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>one_sided_test(tobs, tvals, alpha, tol = 1e-14)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="one_sided_test_+3A_tobs">tobs</code></td>
<td>
<p>The observed value of the test statistic (scalar).</p>
</td></tr>
<tr><td><code id="one_sided_test_+3A_tvals">tvals</code></td>
<td>
<p>Vector of randomization values of the test statistic (to compare with <code>tobs</code>).</p>
</td></tr>
<tr><td><code id="one_sided_test_+3A_alpha">alpha</code></td>
<td>
<p>Desired level of the test (between 0 to 1).</p>
</td></tr>
<tr><td><code id="one_sided_test_+3A_tol">tol</code></td>
<td>
<p>Used to check whether <code>tobs</code> is equal to the 1-<code>alpha</code> quantile of <code>tvals</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The test may randomize to achieve the specified level <code>alpha</code>
when there are very few randomization values.
</p>


<h3>Value</h3>

<p>Test decision (binary).
</p>


<h3>See Also</h3>

<p>Testing Statistical Hypotheses (Ch. 15, Lehman and Romano, 2006)
</p>

<hr>
<h2 id='out_pval'>Calculates p-value or test decision</h2><span id='topic+out_pval'></span>

<h3>Description</h3>

<p>Depending on <code>ret_pval</code> this function returns either a p-value for the test or the binary decision.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>out_pval(rtest_out, ret_pval, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="out_pval_+3A_rtest_out">rtest_out</code></td>
<td>
<p>A <code>List</code> with elements <code>tobs</code>, <code>tvals</code> (see <a href="#topic+one_sided_test">one_sided_test</a> for details.)</p>
</td></tr>
<tr><td><code id="out_pval_+3A_ret_pval">ret_pval</code></td>
<td>
<p>A <code>Boolean</code> indicating whether to return a p-value (TRUE) or not.</p>
</td></tr>
<tr><td><code id="out_pval_+3A_alpha">alpha</code></td>
<td>
<p>Desired test level (from 0 to 1).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns 1 if the test rejects, 0 otherwise.
</p>


<h3>Value</h3>

<p>Binary decision if <code>ret_pval</code> is TRUE, or the p-value otherwise.
</p>

<hr>
<h2 id='r_test_c'>Residual randomization test</h2><span id='topic+r_test_c'></span>

<h3>Description</h3>

<p>Implements the residual randomization test. The hypothesis tested is
</p>


<h3>Usage</h3>

<pre><code class='language-R'>r_test_c(y, X, lam, lam0, cluster_eps_r, use_perm, use_sign, num_R)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="r_test_c_+3A_y">y</code></td>
<td>
<p>Vector of outcomes (n x 1).</p>
</td></tr>
<tr><td><code id="r_test_c_+3A_x">X</code></td>
<td>
<p>Matrix of covariates (n x p). First column should be 1's.</p>
</td></tr>
<tr><td><code id="r_test_c_+3A_lam">lam</code></td>
<td>
<p>Vector of coefficients in linear H0 (p x 1).</p>
</td></tr>
<tr><td><code id="r_test_c_+3A_lam0">lam0</code></td>
<td>
<p>Scalar value for linear H0.</p>
</td></tr>
<tr><td><code id="r_test_c_+3A_cluster_eps_r">cluster_eps_r</code></td>
<td>
<p>A <code>List</code> with restricted residuals. See <a href="#topic+get_clustered_eps">get_clustered_eps</a>.</p>
</td></tr>
<tr><td><code id="r_test_c_+3A_use_perm">use_perm</code></td>
<td>
<p><code>Boolean</code> flag whether to use permutations within clusters.</p>
</td></tr>
<tr><td><code id="r_test_c_+3A_use_sign">use_sign</code></td>
<td>
<p><code>Boolean</code> flag whether to use sign flips across clusters.</p>
</td></tr>
<tr><td><code id="r_test_c_+3A_num_r">num_R</code></td>
<td>
<p>Integer of how many randomization values to calculate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>H0: lam' beta = lam[1] * beta[1] + ... + lam[p] * beta[p] = lam0.
</p>


<h3>Value</h3>

<p>A <code>List</code> with the observed test statistic value (<code>tobs</code>), and the randomization values (<code>tvals</code>)
</p>

<hr>
<h2 id='restricted_OLS_c'>Fast least squares with linear constraint</h2><span id='topic+restricted_OLS_c'></span>

<h3>Description</h3>

<p>This functions fits the regression y ~ X under a linear constraint on the
model parameters. The constraint is  <code>Q</code> * beta = <code>c</code> where beta
are the regression model parameters, and <code>Q, c</code> are inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>restricted_OLS_c(y, X, bhat, Q, c)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="restricted_OLS_c_+3A_y">y</code></td>
<td>
<p>Vector of outcomes.</p>
</td></tr>
<tr><td><code id="restricted_OLS_c_+3A_x">X</code></td>
<td>
<p>Matrix of covariates (first column should be 1's)</p>
</td></tr>
<tr><td><code id="restricted_OLS_c_+3A_bhat">bhat</code></td>
<td>
<p>Unconstrained OLS-fitted coefficients.</p>
</td></tr>
<tr><td><code id="restricted_OLS_c_+3A_q">Q</code></td>
<td>
<p>Matrix of linear constraints (k x p).</p>
</td></tr>
<tr><td><code id="restricted_OLS_c_+3A_c">c</code></td>
<td>
<p>Vector of constraint values (k x 1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of fitted OLS coefficients under linear constraint.
</p>


<h3>See Also</h3>

<p>Advanced Econometrics (Section 1.4, Takeshi Amemiya, 1985)
</p>

<hr>
<h2 id='rrinf'>Generic residual randomization confidence intervals</h2><span id='topic+rrinf'></span>

<h3>Description</h3>

<p>This function is a wrapper over <a href="#topic+rrtest">rrtest</a> and gives confidence intervals for all parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rrinf(
  y,
  X,
  g_invar,
  cover = 0.95,
  num_R = 999,
  control = list(num_se = 6, num_breaks = 60)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rrinf_+3A_y">y</code></td>
<td>
<p>Vector of outcomes (length n)</p>
</td></tr>
<tr><td><code id="rrinf_+3A_x">X</code></td>
<td>
<p>Covariate matrix (n x p). First column should be ones to include intercept.</p>
</td></tr>
<tr><td><code id="rrinf_+3A_g_invar">g_invar</code></td>
<td>
<p>Function that transforms residuals. Accepts n-vector and returns n-vector.</p>
</td></tr>
<tr><td><code id="rrinf_+3A_cover">cover</code></td>
<td>
<p>Number from [0, 1] that denotes the confidence interval coverage (e.g., 0.95 denotes 95%)</p>
</td></tr>
<tr><td><code id="rrinf_+3A_num_r">num_R</code></td>
<td>
<p>Number of test statistic values to calculate in the randomization test (similar to no. of bootstrap samples).</p>
</td></tr>
<tr><td><code id="rrinf_+3A_control">control</code></td>
<td>
<p>A <code>List</code> that constrols the scope of the test inversion.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function has similar funtionality as standard <a href="stats.html#topic+confint">confint</a>.
It generates confidence intervals by testing plausible values for each parameter.
The plausible values are generated as follows.
For some parameter beta_i we test successively
</p>
<p>H0: beta_i = hat_beta_i - <code>num_se</code> * se_i
</p>
<p>...up to...
</p>
<p>H0: beta_i = hat_beta_i + <code>num_se</code> * se_i
</p>
<p>broken in <code>num_breaks</code> intervals. Here, hat_beta_i is the OLS estimate of beta_i and se_i is the standard error.
We then report the minimum and maximum values in this search space which we cannot reject
at level <code>alpha</code>. This forms the desired confidence interval.
</p>


<h3>Value</h3>

<p>Matrix that includes the confidence interval endpoints, and the interval midpoint estimate.
</p>


<h3>Note</h3>

<p>If the confidence interval appears to be a point or is empty, then this means
that the nulls we consider are implausible.
We can try to improve the search through <code>control.tinv</code>.
For example, we can both increase <code>num_se</code> to increase the width of search,
and increase <code>num_breaks</code> to make the search space finer.
</p>


<h3>See Also</h3>

<p>Life after bootstrap: residual randomization inference in regression models (Toulis, 2019)
</p>
<p><a href="https://www.ptoulis.com/residual-randomization">https://www.ptoulis.com/residual-randomization</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
X = cbind(rep(1, 100), runif(100))
beta = c(-1, 1)
y = X %*% beta + rnorm(100)
g_invar = function(e) sample(e)  # Assume exchangeable errors.
M = rrinf(y, X, g_invar, control=list(num_se=4, num_breaks=20))
M  # Intervals cover true values
</code></pre>

<hr>
<h2 id='rrinf_clust'>Residual randomization inference based on cluster invariances</h2><span id='topic+rrinf_clust'></span>

<h3>Description</h3>

<p>This function is a wrapper over <a href="#topic+rrtest_clust">rrtest_clust</a> and gives confidence intervals for all parameters
assuming a particular cluster invariance on the errors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rrinf_clust(
  y,
  X,
  type,
  clustering = NULL,
  cover = 0.95,
  num_R = 999,
  control = list(num_se = 6, num_breaks = 60)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rrinf_clust_+3A_y">y</code></td>
<td>
<p>Vector of outcomes (length n)</p>
</td></tr>
<tr><td><code id="rrinf_clust_+3A_x">X</code></td>
<td>
<p>Covariate matrix (n x p). First column should be ones to include intercept.</p>
</td></tr>
<tr><td><code id="rrinf_clust_+3A_type">type</code></td>
<td>
<p>A string, either &quot;perm&quot;, &quot;sign&quot; or &quot;double&quot;.</p>
</td></tr>
<tr><td><code id="rrinf_clust_+3A_clustering">clustering</code></td>
<td>
<p>A <code>List</code> that specifies a clustering of datapoint indexes 1, ..., n. See <a href="#topic+example_clustering">example_clustering</a> for details.</p>
</td></tr>
<tr><td><code id="rrinf_clust_+3A_cover">cover</code></td>
<td>
<p>Number from [0, 1] that denotes the confidence interval coverage (e.g., 0.95 denotes 95%)</p>
</td></tr>
<tr><td><code id="rrinf_clust_+3A_num_r">num_R</code></td>
<td>
<p>Number of test statistic values to calculate in the randomization test (similar to no. of bootstrap samples).</p>
</td></tr>
<tr><td><code id="rrinf_clust_+3A_control">control</code></td>
<td>
<p>A <code>List</code> that controls the scope of the test inversion.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function has similar funtionality as standard <a href="stats.html#topic+confint">confint</a>.
It generates confidence intervals by testing plausible values for each parameter.
The plausible values are generated as follows.
For some parameter beta_i we test successively
</p>
<p>H0: beta_i = hat_beta_i - <code>num_se</code> * se_i
</p>
<p>...up to...
</p>
<p>H0: beta_i = hat_beta_i + <code>num_se</code> * se_i
</p>
<p>broken in <code>num_breaks</code> intervals. Here, hat_beta_i is the OLS estimate of beta_i and se_i is the standard error.
We then report the minimum and maximum values in this search space which we cannot reject
at level <code>alpha</code>. This forms the desired confidence interval.
</p>


<h3>Value</h3>

<p>Matrix that includes the OLS estimate, and confidence interval endpoints.
</p>


<h3>Note</h3>

<p>If the confidence interval appears to be a point or is empty, then this means
that the nulls we consider are implausible.
We can try to improve the search through <code>control.tinv</code>.
For example, we can both increase <code>num_se</code> to increase the width of search,
and increase <code>num_breaks</code> to make the search space finer.
</p>
<p>See <a href="#topic+rrtest_clust">rrtest_clust</a> for a description of <code>type</code> and <code>clustering</code>.
</p>


<h3>See Also</h3>

<p>Life after bootstrap: residual randomization inference in regression models (Toulis, 2019)
</p>
<p><a href="https://www.ptoulis.com/residual-randomization">https://www.ptoulis.com/residual-randomization</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Heterogeneous example
set.seed(123)
n = 200
X = cbind(rep(1, n), 1:n/n)
beta = c(-1, 0.2)
ind = c(rep(0, 0.9*n), rep(1, .1*n))  # cluster indicator
y = X %*% beta + rnorm(n, sd= (1-ind) * 0.1 + ind * 5) # heteroskedastic
confint(lm(y ~ X + 0))  # normal OLS CI is imprecise

cl = list(which(ind==0), which(ind==1))  #  define the clustering
rrinf_clust(y, X, "perm", cl)  # improved CI through clustered errors

</code></pre>

<hr>
<h2 id='rrinfBase'>Generic residual randomization inference
This function provides the basis for all other rrinf* functions.</h2><span id='topic+rrinfBase'></span>

<h3>Description</h3>

<p>Generic residual randomization inference
This function provides the basis for all other rrinf* functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rrinfBase(y, X, g_or_clust, cover, num_R, control.tinv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rrinfBase_+3A_y">y</code></td>
<td>
<p>Vector of outcomes (length n)</p>
</td></tr>
<tr><td><code id="rrinfBase_+3A_x">X</code></td>
<td>
<p>Covariate matrix (n x p). First column should be ones to include intercept.</p>
</td></tr>
<tr><td><code id="rrinfBase_+3A_g_or_clust">g_or_clust</code></td>
<td>
<p>Either <code>clustering</code> or an invariance function that transforms residuals.</p>
</td></tr>
<tr><td><code id="rrinfBase_+3A_cover">cover</code></td>
<td>
<p>Number from [0, 1] that denotes the confidence interval coverage (e.g., 0.95 denotes 95%)</p>
</td></tr>
<tr><td><code id="rrinfBase_+3A_num_r">num_R</code></td>
<td>
<p>Number of test statistic values to calculate in the randomization test (similar to no. of bootstrap samples).</p>
</td></tr>
<tr><td><code id="rrinfBase_+3A_control.tinv">control.tinv</code></td>
<td>
<p>A <code>List</code> that determines the test inversion.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function has similar funtionality as standard <a href="stats.html#topic+confint">confint</a>.
It does so by testing plausible values for each parameter. The plausible values can be controlled as follows.
For some parameter beta_i we will test successively
</p>
<p>H0: beta_i = hat_beta_i - <code>num_se</code> * se_i
</p>
<p>...up to...
</p>
<p>H0: beta_i = hat_beta_i + <code>num_se</code> * se_i
</p>
<p>broken in <code>num_breaks</code> intervals. Here, hat_beta_i is the OLS estimate of beta_i and se_i is the standard error.
</p>
<p>The <code>g_or_clust</code> object should either be (i) a g-invariance function R^n -&gt; R^n; or (ii)
a list(type, cl) where type=c(&quot;perm&quot;, &quot;sign&quot;, &quot;double&quot;) and cl=<code>clustering</code> (see <a href="#topic+example_clustering">example_clustering</a> for details).
</p>
<p><a href="https://www.ptoulis.com/residual-randomization">https://www.ptoulis.com/residual-randomization</a>
</p>


<h3>Value</h3>

<p>Matrix that includes the confidence interval endpoints, and the interval midpoint estimate.
</p>

<hr>
<h2 id='rrtest'>Generic residual randomization test</h2><span id='topic+rrtest'></span>

<h3>Description</h3>

<p>This function tests the specified linear hypothesis in <code>model</code> assuming the errors are distributionally invariant
with respect to stochastic function <code>g_invar</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rrtest(model, g_invar, num_R = 999, alpha = 0.05, val_type = "decision")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rrtest_+3A_model">model</code></td>
<td>
<p>Regression model and hypothesis. See <a href="#topic+example_model">example_model</a> for details.</p>
</td></tr>
<tr><td><code id="rrtest_+3A_g_invar">g_invar</code></td>
<td>
<p>Stochastic function that transforms residuals. Accepts n-vector and returns n-vector.</p>
</td></tr>
<tr><td><code id="rrtest_+3A_num_r">num_R</code></td>
<td>
<p>Number of test statistic values to calculate in the randomization test.</p>
</td></tr>
<tr><td><code id="rrtest_+3A_alpha">alpha</code></td>
<td>
<p>Nominal test level (between 0 to 1).</p>
</td></tr>
<tr><td><code id="rrtest_+3A_val_type">val_type</code></td>
<td>
<p>The type of return value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the regression y = X * beta + e, this function is testing the following linear null hypothesis:
</p>
<p>H0: lam' beta = lam[1] * beta[1] + ... + lam[p] * beta[p] = lam0,
</p>
<p>where y, X, lam, lam0 are specified in <code>model</code>.
The assumption is that the errors, e, have some form of cluster invariance.
Specifically:
</p>
<p>(e_1, e_2, ..., e_n) ~  g_invar(e_1, e_2, ..., e_n),
</p>
<p>where ~ denotes equality in distribution, and <code>g_invar</code> is the supplied
invariance function.
</p>


<h3>Value</h3>

<p>If <code>val_type</code> = &quot;decision&quot; (default) we get the test binary decision (1=REJECT H0).
</p>
<p>If <code>val_type</code> = &quot;pval&quot; we get the test p-value.
</p>
<p>If  <code>val_type</code> = &quot;full&quot; we get the full test output, i.e., a <code>List</code> with elements <code>tobs</code>, <code>tvals</code>,
the observed and randomization values of the test statistic, respectively.
</p>


<h3>Note</h3>

<p>There is no guarantee that an arbitrary <code>g_invar</code> will produce valid tests.
The <a href="#topic+rrtest_clust">rrtest_clust</a> function has such guarantees under mild assumptions.
</p>


<h3>See Also</h3>

<p>Life after bootstrap: residual randomization inference in regression models (Toulis, 2019)
</p>
<p><a href="https://www.ptoulis.com/residual-randomization">https://www.ptoulis.com/residual-randomization</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>model = example_model(n = 100)  # test H0: beta2 = 0 (here, H0 is true)
g_invar = function(e) sample(e)   # Assume errors are exchangeable.
rrtest(model, g_invar) # same as rrtest_clust(model, "perm")

</code></pre>

<hr>
<h2 id='rrtest_clust'>Residual randomization test under cluster invariances</h2><span id='topic+rrtest_clust'></span>

<h3>Description</h3>

<p>This function tests the specified linear hypothesis in <code>model</code>
assuming that the errors have some form of cluster invariance determined by <code>type</code>
within the clusters determined by <code>clustering</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rrtest_clust(
  model,
  type,
  clustering = NULL,
  num_R = 999,
  alpha = 0.05,
  val_type = "decision"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rrtest_clust_+3A_model">model</code></td>
<td>
<p>Regression model and hypothesis. See <a href="#topic+example_model">example_model</a> for details.</p>
</td></tr>
<tr><td><code id="rrtest_clust_+3A_type">type</code></td>
<td>
<p>A <code>character</code>, either &quot;perm&quot;, &quot;sign&quot; or &quot;double&quot;.</p>
</td></tr>
<tr><td><code id="rrtest_clust_+3A_clustering">clustering</code></td>
<td>
<p>A <code>List</code> that specifies a clustering of datapoint indexes 1, ..., n.
See <a href="#topic+example_clustering">example_clustering</a>. If NULL it takes default value according to <code>type</code> (see Note)</p>
</td></tr>
<tr><td><code id="rrtest_clust_+3A_num_r">num_R</code></td>
<td>
<p>Number of test statistic values to calculate in the test.</p>
</td></tr>
<tr><td><code id="rrtest_clust_+3A_alpha">alpha</code></td>
<td>
<p>Nominal test level (between 0 to 1).</p>
</td></tr>
<tr><td><code id="rrtest_clust_+3A_val_type">val_type</code></td>
<td>
<p>The type of return value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For the regression y = X * beta + e, this function is testing the following linear null hypothesis:
</p>
<p>H0: lam' beta = lam[1] * beta[1] + ... + lam[p] * beta[p] = lam0,
</p>
<p>where y, X, lam, lam0 are specified in <code>model</code>.
The assumption is that the errors, e, have some form of cluster invariance.
Specifically:
</p>

<ul>
<li><p> If <code>type</code> = &quot;perm&quot; then the errors are assumed exchangeable within the specified clusters:
</p>
<p>(e_1, e_2, ..., e_n) ~ cluster_perm(e_1, e_2, ..., e_n),
</p>
<p>where ~ denotes equality in distribution, and cluster_perm is any random permutation
within the clusters defined by <code>clustering</code>. Internally, the test repeatedly calculates a test statistic
by randomly permuting the residuals within clusters.
</p>
</li>
<li><p> If <code>type</code> = &quot;sign&quot; then the errors are assumed sign-symmetric within the specified clusters:
</p>
<p>(e_1, e_2, ..., e_n) ~ cluster_signs(e_1, e_2, ..., e_n),
</p>
<p>where cluster_signs is a random signs flip of residuals on the cluster level.
Internally, the test repeatedly calculates a test statistic by randomly flipping the signs of cluster residuals.
</p>
</li>
<li><p> If <code>type</code> = &quot;double&quot; then the errors are assumed both exchangeable and sign symmetric
within the specified clusters:
</p>
<p>(e_1, e_2, ..., e_n) ~ cluster_signs(cluster_perm(e_1, e_2, ..., e_n)),
</p>
<p>Internally, the test repeatedly calculates a test statistic by permuting and randomly flipping the signs of residuals on the cluster level.
</p>
</li></ul>



<h3>Value</h3>

<p>If <code>val_type</code> = &quot;decision&quot; (default) we get the test binary decision (1=REJECT H0).
</p>
<p>If <code>val_type</code> = &quot;pval&quot; we get the test p-value.
</p>
<p>If  <code>val_type</code> = &quot;full&quot; we get the full test output, i.e., a <code>List</code> with elements <code>tobs</code>, <code>tvals</code>,
the observed and randomization values of the test statistic, respectively.
</p>


<h3>Note</h3>

<p>If <code>clustering</code> is NULL then it will be assigned a default value:
</p>

<ul>
<li> <p><code>list(1:n)</code>if <code>type</code> = &quot;perm&quot;, where n is the number of datapoints;
</p>
</li>
<li> <p><code>as.list(1:n)</code> if <code>type</code> = &quot;sign&quot; or &quot;double&quot;.
</p>
</li></ul>

<p>As in bootstrap <code>num_R</code> is usually between 1000-5000.
</p>


<h3>See Also</h3>

<p>Life after bootstrap: residual randomization inference in regression models (Toulis, 2019)
</p>
<p><a href="https://www.ptoulis.com/residual-randomization">https://www.ptoulis.com/residual-randomization</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 1. Validity example
set.seed(123)
n = 50
X = cbind(rep(1, n), 1:n/n)
beta = c(0, 0)
rej = replicate(200, {
  y = X %*% beta  + rt(n, df=5)
  model = list(y=y, X=X, lam=c(0, 1), lam0=0)  # H0: beta2 = 0
  rrtest_clust(model, "perm")
})
mean(rej)  # Should be ~ 5% since H0 is true.

# 2. Heteroskedastic example
set.seed(123)
n = 200
X = cbind(rep(1, n), 1:n/n)
beta = c(-1, 0.2)
ind = c(rep(0, 0.9*n), rep(1, .1*n))  # cluster indicator
y = X %*% beta + rnorm(n, sd= (1-ind) * 0.1 + ind * 5) # heteroskedastic
confint(lm(y ~ X + 0))  # normal OLS does not reject H0: beta2 = 0
cl = list(which(ind==0), which(ind==1))
model = list(y=y, X=X, lam=c(0, 1), lam0=0)

rrtest_clust(model, "sign")  # errors are sign symmetric regardless of cluster.
# Cluster sign test does not reject because of noise.

rrtest_clust(model, "perm", cl)  # errors are exchangeable within clusters
# Cluster permutation test rejects because inference is sharper.
</code></pre>

<hr>
<h2 id='two_sided_test'>Two-sided testing</h2><span id='topic+two_sided_test'></span>

<h3>Description</h3>

<p>Decides to reject or not based on observed test statistic value <code>tobs</code>
and randomization values <code>tvals</code>. The test may randomize to achieve the specified level <code>alpha</code>
when there are very few randomization values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>two_sided_test(tobs, tvals, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="two_sided_test_+3A_tobs">tobs</code></td>
<td>
<p>The observed value of the test statistic (scalar).</p>
</td></tr>
<tr><td><code id="two_sided_test_+3A_tvals">tvals</code></td>
<td>
<p>Vector of randomization values of the test statistic (to compare with <code>tobs</code>).</p>
</td></tr>
<tr><td><code id="two_sided_test_+3A_alpha">alpha</code></td>
<td>
<p>Desired level of the test (between 0 to 1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Test decision (binary).
</p>


<h3>See Also</h3>

<p>Testing Statistical Hypotheses (Ch. 15, Lehman and Romano, 2006)
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
