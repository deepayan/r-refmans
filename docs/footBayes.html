<!DOCTYPE html><html lang="en"><head><title>Help for package footBayes</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {footBayes}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#btd_foot'><p>Bayesian Bradley-Terry-Davidson Model</p></a></li>
<li><a href='#compare_foot'><p>Compare Football Models using Various Metrics</p></a></li>
<li><a href='#england'><p>English league results 1888-2022</p></a></li>
<li><a href='#foot_abilities'><p>Plot football abilities from Stan and MLE models</p></a></li>
<li><a href='#foot_prob'><p>Plot football matches probabilities for out-of-sample football matches.</p></a></li>
<li><a href='#foot_rank'><p>Rank and points predictions</p></a></li>
<li><a href='#foot_round_robin'><p>Round-robin for football leagues</p></a></li>
<li><a href='#italy'><p>Italy league results 1934-2022</p></a></li>
<li><a href='#mle_foot'><p>Fit football models with Maximum Likelihood</p></a></li>
<li><a href='#plot_btdPosterior'><p>Plot Posterior Distributions for <code>btdFoot</code> Objects</p></a></li>
<li><a href='#plot_logStrength'><p>Plot Rankings for btdFoot Objects</p></a></li>
<li><a href='#pp_foot'><p>Posterior predictive checks for football models</p></a></li>
<li><a href='#print.btdFoot'><p>Print Method for btdFoot Objects</p></a></li>
<li><a href='#print.compareFoot'><p>Print method for compareFoot objects</p></a></li>
<li><a href='#print.stanFoot'><p>Print Method for stanFoot Objects</p></a></li>
<li><a href='#priors'><p>Football priors distributions and options</p></a></li>
<li><a href='#stan_foot'><p>Fit football models  with Stan</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Fitting Bayesian and MLE Football Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-01-09</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Leonardo Egidi &lt;legidi@units.it&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Description:</td>
<td>This is the first package allowing for the estimation,
             visualization and prediction of the most well-known 
             football models: double Poisson, bivariate Poisson,
             Skellam, student_t, diagonal-inflated bivariate Poisson, and
             zero-inflated Skellam. The package allows Hamiltonian
             Monte Carlo (HMC) estimation through the underlying Stan
             environment and Maximum Likelihood estimation (MLE, for 
             'static' models only). The model construction relies on
             the most well-known football references, such as 
             Dixon and Coles (1997) &lt;<a href="https://doi.org/10.1111%2F1467-9876.00065">doi:10.1111/1467-9876.00065</a>&gt;,
             Karlis and Ntzoufras (2003) &lt;<a href="https://doi.org/10.1111%2F1467-9884.00366">doi:10.1111/1467-9884.00366</a>&gt; and
             Egidi, Pauli and Torelli (2018) &lt;<a href="https://doi.org/10.1177%2F1471082X18798414">doi:10.1177/1471082X18798414</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/leoegidi/footbayes">https://github.com/leoegidi/footbayes</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>pandoc (&gt;= 1.12.3), pandoc-citeproc</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>rstan (&ge; 2.18.1), arm, reshape2, ggplot2, ggridges,
bayesplot, matrixStats, extraDistr, parallel, metRology, dplyr,
tidyr, numDeriv, magrittr, rlang</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr (&ge; 1.37), rmarkdown (&ge; 2.10), loo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>BuildManual:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-09 15:07:52 UTC; 17245</td>
</tr>
<tr>
<td>Author:</td>
<td>Leonardo Egidi [aut, cre],
  Roberto Macrì Demartino [aut],
  Vasilis Palaskas. [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-09 15:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='btd_foot'>Bayesian Bradley-Terry-Davidson Model</h2><span id='topic+btd_foot'></span>

<h3>Description</h3>

<p>Fits a Bayesian Bradley-Terry-Davidson model using Stan. Supports both static and dynamic ranking models, allowing for the estimation of team strengths over time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>btd_foot(
  data,
  dynamic_rank = FALSE,
  home_effect = FALSE,
  prior_par = list(logStrength = normal(0, 3), logTie = normal(0, 0.3), home = normal(0,
    5)),
  rank_measure = "median",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="btd_foot_+3A_data">data</code></td>
<td>
<p>A data frame containing the observations with columns:
</p>

<ul>
<li> <p><code>periods</code>: Time point of each observation (integer &gt;= 1).
</p>
</li>
<li> <p><code>home_team</code>: Home team's name (character string).
</p>
</li>
<li> <p><code>away_team</code>: Away team's name (character string).
</p>
</li>
<li> <p><code>match_outcome</code>: Outcome (1 if home team beats away team, 2 for tie, and 3 if away team beats home team).
</p>
</li></ul>

<p>The data frame must not contain missing values.</p>
</td></tr>
<tr><td><code id="btd_foot_+3A_dynamic_rank">dynamic_rank</code></td>
<td>
<p>A logical value indicating whether a dynamic ranking model is used (default is <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="btd_foot_+3A_home_effect">home_effect</code></td>
<td>
<p>A logical value indicating the inclusion of a home effect in the model. (default is <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="btd_foot_+3A_prior_par">prior_par</code></td>
<td>
<p>A list specifying the prior distributions for the parameters of interest, using the <code>normal</code> function:
</p>

<ul>
<li> <p><code>logStrength</code>: Prior for the team log-strengths. Default is <code>normal(0, 3)</code>.
</p>
</li>
<li> <p><code>logTie</code>: Prior for the tie parameter. Default is <code>normal(0, 0.3)</code>.
</p>
</li>
<li> <p><code>home</code>: Prior for the home effect (<code>home</code>). Applicable only if <code>home_effect = TRUE</code>. Default is <code>normal(0, 5)</code>.
</p>
</li></ul>

<p>Only normal priors are allowed for this model.</p>
</td></tr>
<tr><td><code id="btd_foot_+3A_rank_measure">rank_measure</code></td>
<td>
<p>A character string specifying the method used to summarize the posterior distributions of the team strengths. Options are:
</p>

<ul>
<li> <p><code>"median"</code>: Uses the median of the posterior samples (default).
</p>
</li>
<li> <p><code>"mean"</code>: Uses the mean of the posterior samples.
</p>
</li>
<li> <p><code>"map"</code>: Uses the Maximum A Posteriori estimate, calculated as the mode of the posterior distribution.
</p>
</li></ul>
</td></tr>
<tr><td><code id="btd_foot_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="rstan.html#topic+stan">stan</a></code> (e.g., <code>iter</code>, <code>chains</code>, <code>control</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>"btdFoot"</code> containing:
</p>

<ul>
<li> <p><code>fit</code>: The fitted <code>stanfit</code> object returned by <code><a href="rstan.html#topic+stan">stan</a></code>.
</p>
</li>
<li> <p><code>rank</code>: A data frame with the rankings, including columns:
</p>

<ul>
<li> <p><code>periods</code>: The time period.
</p>
</li>
<li> <p><code>team</code>: The team name.
</p>
</li>
<li> <p><code>rank_points</code>: The estimated strength of the team based on the chosen <code>rank_measure</code>.
</p>
</li></ul>

</li>
<li> <p><code>data</code>: The input data.
</p>
</li>
<li> <p><code>stan_data</code>: The data list prepared for Stan.
</p>
</li>
<li> <p><code>stan_code</code>: The path to the Stan model code used.
</p>
</li>
<li> <p><code>stan_args</code>: The optional parameters passed to (<code>...</code>).
</p>
</li>
<li> <p><code>rank_measure</code>: The method used to compute the rankings.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Roberto Macrì Demartino <a href="mailto:roberto.macridemartino@phd.unipd.it">roberto.macridemartino@phd.unipd.it</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

library(dplyr)

data("italy")

italy_2020_2021 &lt;- italy %&gt;%
  dplyr::select(Season, home, visitor, hgoal, vgoal) %&gt;%
  dplyr::filter(Season == "2020" | Season == "2021") %&gt;%
  dplyr::mutate(match_outcome = dplyr::case_when(
    hgoal &gt; vgoal ~ 1,        # Home team wins
    hgoal == vgoal ~ 2,       # Draw
    hgoal &lt; vgoal ~ 3         # Away team wins
  )) %&gt;%
  dplyr::mutate(periods = dplyr::case_when(
    dplyr::row_number() &lt;= 190 ~ 1,
    dplyr::row_number() &lt;= 380 ~ 2,
    dplyr::row_number() &lt;= 570 ~ 3,
    TRUE ~ 4
  )) %&gt;%  # Assign periods based on match number
  dplyr::select(periods, home_team = home,
   away_team = visitor, match_outcome)

# Dynamic Ranking Example with Median Rank Measure
fit_result_dyn &lt;- btd_foot(
  data = italy_2020_2021,
  dynamic_rank = TRUE,
  home_effect = TRUE,
  prior_par = list(
    logStrength = normal(0, 10),
    logTie = normal(0, 5),
    home = normal(0, 5)
  ),
  rank_measure = "median",
  iter = 1000,
  cores = 2,
  chains = 2
)

print(fit_result_dyn)

print(fit_result_dyn, pars = c("logStrength", "home"), teams = c("AC Milan", "AS Roma"))

# Static Ranking Example with MAP Rank Measure
fit_result_stat &lt;- btd_foot(
  data = italy_2020_2021,
  dynamic_rank = FALSE,
  prior_par = list(
    logStrength = normal(0, 10),
    logTie = normal(0, 5),
    home = normal(0, 5)
  ),
  rank_measure = "map",
  iter = 1000,
  chains = 2
)

print(fit_result_stat)

## End(Not run)
</code></pre>

<hr>
<h2 id='compare_foot'>Compare Football Models using Various Metrics</h2><span id='topic+compare_foot'></span>

<h3>Description</h3>

<p>Compares multiple football models or directly provided probability matrices based on specified metrics (accuracy, Brier score, ranked probability score, Pseudo <code class="reqn">R^2</code>, average coverage probability), using a test dataset. Additionally, computes the confusion matrices. The function returns an object of class <code>compareFoot</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_foot(
  source,
  test_data,
  metric = c("accuracy", "brier", "ACP", "pseudoR2", "RPS"),
  conf_matrix = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare_foot_+3A_source">source</code></td>
<td>
<p>A named list containing either:
</p>

<ul>
<li><p> Fitted model objects (of class <code>stanFoot</code> or <code>stanfit</code>), each representing a football model.
</p>
</li>
<li><p> Matrices where each matrix contains the estimated probabilities for &quot;Home Win,&quot; &quot;Draw,&quot; and &quot;Away Win&quot; in its columns.
</p>
</li></ul>
</td></tr>
<tr><td><code id="compare_foot_+3A_test_data">test_data</code></td>
<td>
<p>A data frame containing the test dataset, with columns:
</p>

<ul>
<li> <p><code>home_team</code>: Home team's name (character string).
</p>
</li>
<li> <p><code>away_team</code>: Away team's name (character string).
</p>
</li>
<li> <p><code>home_goals</code>: Goals scored by the home team (integer &gt;= 0).
</p>
</li>
<li> <p><code>away_goals</code>: Goals scored by the away team (integer &gt;= 0).
</p>
</li></ul>
</td></tr>
<tr><td><code id="compare_foot_+3A_metric">metric</code></td>
<td>
<p>A character vector specifying the metrics to use for comparison. Options are:
</p>

<ul>
<li> <p><code>"accuracy"</code>: Computes the accuracy of each model.
</p>
</li>
<li> <p><code>"brier"</code>: Computes the Brier score of each model.
</p>
</li>
<li> <p><code>"RPS"</code>: Computes the ranked probability score (RPS) for each model.
</p>
</li>
<li> <p><code>"ACP"</code>: Computes the average coverage probability (ACP) for each model.
</p>
</li>
<li> <p><code>"pseudoR2"</code>: Computes the Pseudo <code class="reqn">R^2</code>, defined as the geometric mean of the probabilities assigned to the actual results.
</p>
</li></ul>

<p>Default is <code>c("accuracy", "brier", "ACP", "pseudoR2", "RPS")</code>, computing the specified metrics.</p>
</td></tr>
<tr><td><code id="compare_foot_+3A_conf_matrix">conf_matrix</code></td>
<td>
<p>A logical value indicating whether to generate a confusion matrix comparing predicted outcomes against actual outcomes for each model or probability matrix. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function extracts predictions from each model or directly uses the provided probability matrices and computes the chosen metrics on the test dataset. It also possible to compute confusion matrices.
</p>


<h3>Value</h3>

<p>An object of class <code>compare_foot_output</code>, which is a list containing:
</p>

<ul>
<li> <p><code>metrics</code>: A data frame containing the metric values for each model or probability matrix.
</p>
</li>
<li> <p><code>confusion_matrix</code>: Confusion matrices for each model or probability matrix.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Roberto Macrì Demartino <a href="mailto:roberto.macridemartino@phd.unipd.it">roberto.macridemartino@phd.unipd.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(dplyr)

data("italy")
italy_2000 &lt;- italy %&gt;%
  dplyr::select(Season, home, visitor, hgoal, vgoal) %&gt;%
  dplyr::filter(Season == "2000")

colnames(italy_2000) &lt;- c("periods", "home_team", "away_team", "home_goals", "away_goals")

# Example with fitted models
fit_1 &lt;- stan_foot(data = italy_2000,
                   model = "double_pois", predict = 18)  # Double Poisson model
fit_2 &lt;- stan_foot(data = italy_2000,
                   model = "biv_pois", predict = 18)     # Bivariate Poisson model

italy_2000_test &lt;- italy_2000[289:306, ]


compare_results_models &lt;- compare_foot(
  source = list(double_poisson = fit_1,
                bivariate_poisson = fit_2),
  test_data = italy_2000_test,
  metric = c("accuracy", "brier", "ACP", "pseudoR2", "RPS"),
  conf_matrix = TRUE
)

print(compare_results_models)

## End(Not run)
</code></pre>

<hr>
<h2 id='england'>English league results 1888-2022</h2><span id='topic+england'></span>

<h3>Description</h3>

<p>All results for English soccer games in the top 4 tiers
from 1888/89 season to 2021/22 season.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>england
</code></pre>


<h3>Format</h3>

<p>A data frame with 203956 rows and 12 variables:
</p>

<dl>
<dt>Date</dt><dd><p>Date of match</p>
</dd>
<dt>Season</dt><dd><p>Season of match - refers to starting year</p>
</dd>
<dt>home</dt><dd><p>Home team</p>
</dd>
<dt>visitor</dt><dd><p>Visiting team</p>
</dd>
<dt>FT</dt><dd><p>Full-time result</p>
</dd>
<dt>hgoal</dt><dd><p>Goals scored by home team</p>
</dd>
<dt>vgoal</dt><dd><p>Goals scored by visiting team</p>
</dd>
<dt>division</dt><dd><p>Division: 1,2,3,4 or 3N (Old 3-North) or 3S (Old 3-South)</p>
</dd>
<dt>tier</dt><dd><p>Tier of football pyramid: 1,2,3,4</p>
</dd>
<dt>totgoal</dt><dd><p>Total goals in game</p>
</dd>
<dt>goaldif</dt><dd><p>Goal difference in game home goals - visitor goals</p>
</dd>
<dt>result</dt><dd><p>Result: H-Home Win, A-Away Win, D-Draw</p>
</dd>
</dl>


<hr>
<h2 id='foot_abilities'>Plot football abilities from Stan and MLE models</h2><span id='topic+foot_abilities'></span>

<h3>Description</h3>

<p>Depicts teams' abilities either from the Stan models fitted via the <code>stan_foot</code> function
or from MLE models fitted via the <code>mle_foot</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>foot_abilities(
  object,
  data,
  type = c("attack", "defense", "both"),
  teams = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="foot_abilities_+3A_object">object</code></td>
<td>
<p>An object either of class <code>stanfit</code> or <code>stanFoot</code> as given by <code>stan_foot</code> function, or class
<code><a href="base.html#topic+list">list</a></code> containing the Maximum Likelihood Estimates (MLE) for the model parameters fitted
with <code>mle_foot</code>.</p>
</td></tr>
<tr><td><code id="foot_abilities_+3A_data">data</code></td>
<td>
<p>A data frame containing match data with columns:
</p>

<ul>
<li> <p><code>periods</code>:  Time point of each observation (integer &gt;= 1).
</p>
</li>
<li> <p><code>home_team</code>: Home team's name (character string).
</p>
</li>
<li> <p><code>away_team</code>: Away team's name (character string).
</p>
</li>
<li> <p><code>home_goals</code>: Goals scored by the home team (integer &gt;= 0).
</p>
</li>
<li> <p><code>away_goals</code>: Goals scored by the away team (integer &gt;= 0).
</p>
</li></ul>
</td></tr>
<tr><td><code id="foot_abilities_+3A_type">type</code></td>
<td>
<p>Type of ability in Poisson models: one among <code>"defense"</code>, <code>"attack"</code> or <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="foot_abilities_+3A_teams">teams</code></td>
<td>
<p>An optional character vector specifying team names to include. If <code>NULL</code>, all teams are included.</p>
</td></tr>
<tr><td><code id="foot_abilities_+3A_...">...</code></td>
<td>
<p>Optional graphical parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Abilities plots for the selected teams: for Poisson models only, red denotes the attack,
blue the defense.
</p>


<h3>Author(s)</h3>

<p>Leonardo Egidi <a href="mailto:legidi@units.it">legidi@units.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(dplyr)

data("italy")
italy &lt;- as_tibble(italy)

### no dynamics, no prediction

italy_2000_2002 &lt;- italy %&gt;%
 dplyr::select(Season, home, visitor, hgoal, vgoal) %&gt;%
 dplyr::filter(Season=="2000" |  Season=="2001" | Season =="2002")

colnames(italy_2000_2002) &lt;- c("periods", "home_team", "away_team", "home_goals", "away_goals")

fit1 &lt;- stan_foot(data = italy_2000_2002,
                  model="double_pois") # double poisson

fit2 &lt;- stan_foot(data = italy_2000_2002,
                  model="biv_pois")    # bivariate poisson

fit3 &lt;- stan_foot(data = italy_2000_2002,
                  model="skellam")     # skellam

fit4 &lt;- stan_foot(data = italy_2000_2002,
                  model="student_t")   # student_t

foot_abilities(fit1, italy_2000_2002)
foot_abilities(fit2, italy_2000_2002)
foot_abilities(fit3, italy_2000_2002)
foot_abilities(fit4, italy_2000_2002)

### seasonal dynamics, predict the last season

fit5 &lt;-stan_foot(data = italy_2000_2002,
                 model = "biv_pois",
                 predict = 180,
                 dynamic_type = "seasonal")   # bivariate poisson
foot_abilities(fit5, italy_2000_2002)


## End(Not run)
</code></pre>

<hr>
<h2 id='foot_prob'>Plot football matches probabilities for out-of-sample football matches.</h2><span id='topic+foot_prob'></span>

<h3>Description</h3>

<p>The function provides a table containing the home win, draw and away win probabilities for a bunch of
out-of-sample matches as specified by <code>stan_foot</code> or <code>mle_foot</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>foot_prob(object, data, home_team, away_team)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="foot_prob_+3A_object">object</code></td>
<td>
<p>An object either of class <code><a href="rstan.html#topic+stanfit">stanfit</a></code> and <code>stanFoot</code> as given by <code>stan_foot</code> function or
<code><a href="base.html#topic+list">list</a></code> as given by <code>mle_foot</code>.</p>
</td></tr>
<tr><td><code id="foot_prob_+3A_data">data</code></td>
<td>
<p>A data frame containing match data with columns:
</p>

<ul>
<li> <p><code>periods</code>:  Time point of each observation (integer &gt;= 1).
</p>
</li>
<li> <p><code>home_team</code>: Home team's name (character string).
</p>
</li>
<li> <p><code>away_team</code>: Away team's name (character string).
</p>
</li>
<li> <p><code>home_goals</code>: Goals scored by the home team (integer &gt;= 0).
</p>
</li>
<li> <p><code>away_goals</code>: Goals scored by the away team (integer &gt;= 0).
</p>
</li></ul>
</td></tr>
<tr><td><code id="foot_prob_+3A_home_team">home_team</code></td>
<td>
<p>The home team(s) for the predicted matches.</p>
</td></tr>
<tr><td><code id="foot_prob_+3A_away_team">away_team</code></td>
<td>
<p>The away team(s) for the predicted matches.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For Bayesian models fitted via <code>stan_foot</code> the results probabilities are computed according to the
simulation from the posterior predictive distribution of future (out-of-sample) matches. For MLE models
fitted via the <code>mle_foot</code> the probabilities are computed by simulating from the MLE estimates.
</p>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the number of out-of-sample matches specified through the
argument <code>predict</code>  passed either in the <code>mle_foot</code> or in the <code>stan_foot</code> function.
For Bayesian Poisson models the function returns also the most likely outcome (mlo) and a posterior
probability plot for the exact results, where matches are sorted by the degree of favoritism.
Specifically, matches are ordered from those in which the favorite team has the highest posterior probability
of winning to those where the underdog is more likely to win.
</p>


<h3>Author(s)</h3>

<p>Leonardo Egidi <a href="mailto:legidi@units.it">legidi@units.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(tidyverse)
library(dplyr)

data("italy")
italy_2000 &lt;- italy %&gt;%
 dplyr::select(Season, home, visitor, hgoal,vgoal) %&gt;%
 dplyr::filter(Season=="2000")

colnames(italy_2000) &lt;- c("periods", "home_team", "away_team", "home_goals", "away_goals")



fit &lt;- stan_foot(data = italy_2000,
                 model="double_pois",
                 predict = 18)  # double pois

foot_prob(fit, italy_2000, "Inter",
          "Bologna FC")

foot_prob(fit, italy_2000) # all the out-of-sample matches

## End(Not run)
</code></pre>

<hr>
<h2 id='foot_rank'>Rank and points predictions</h2><span id='topic+foot_rank'></span>

<h3>Description</h3>

<p>Posterior predictive plots and final rank table for football seasons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>foot_rank(
  object,
  data,
  teams = NULL,
  visualize = c("aggregated", "individual")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="foot_rank_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="rstan.html#topic+stanfit">stanfit</a></code> or <code>stanFoot</code> as given by <code>stan_foot</code> function.</p>
</td></tr>
<tr><td><code id="foot_rank_+3A_data">data</code></td>
<td>
<p>A data frame containing match data with columns:
</p>

<ul>
<li> <p><code>periods</code>:  Time point of each observation (integer &gt;= 1).
</p>
</li>
<li> <p><code>home_team</code>: Home team's name (character string).
</p>
</li>
<li> <p><code>away_team</code>: Away team's name (character string).
</p>
</li>
<li> <p><code>home_goals</code>: Goals scored by the home team (integer &gt;= 0).
</p>
</li>
<li> <p><code>away_goals</code>: Goals scored by the away team (integer &gt;= 0).
</p>
</li></ul>
</td></tr>
<tr><td><code id="foot_rank_+3A_teams">teams</code></td>
<td>
<p>An optional character vector specifying team names to include. If <code>NULL</code>, all teams are included.</p>
</td></tr>
<tr><td><code id="foot_rank_+3A_visualize">visualize</code></td>
<td>
<p>Type of plot, default is <code>"aggregated"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For Bayesian models fitted via <code>stan_foot</code> the final rank tables are computed according to the
simulation from the posterior predictive distribution of future (out-of-sample) matches.
The dataset should refer to one or more seasons from a given national football league (Premier League, Serie A, La Liga, etc.).
</p>


<h3>Value</h3>

<p>Final rank tables and plots with the predicted points for the selected teams as given by the models fitted via the <code>stan_foot</code>
function.
</p>


<h3>Author(s)</h3>

<p>Leonardo Egidi <a href="mailto:legidi@units.it">legidi@units.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
library(dplyr)

data("italy")
italy_1999_2000&lt;- italy %&gt;%
dplyr::select(Season, home, visitor, hgoal,vgoal) %&gt;%
dplyr::filter(Season == "1999"|Season=="2000")

colnames(italy_1999_2000) &lt;- c("periods", "home_team", "away_team", "home_goals", "away_goals")

fit &lt;- stan_foot(italy_1999_2000, "double_pois", iter = 200)
foot_rank(fit, italy_1999_2000)
foot_rank(fit, italy_1999_2000, visualize =  "individual")
 
## End(Not run)

</code></pre>

<hr>
<h2 id='foot_round_robin'>Round-robin for football leagues</h2><span id='topic+foot_round_robin'></span>

<h3>Description</h3>

<p>Posterior predictive probabilities for a football season in a round-robin format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>foot_round_robin(object, data, teams = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="foot_round_robin_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="rstan.html#topic+stanfit">stanfit</a></code> or <code>stanFoot</code> as given by <code>stan_foot</code> function.</p>
</td></tr>
<tr><td><code id="foot_round_robin_+3A_data">data</code></td>
<td>
<p>A data frame containing match data with columns:
</p>

<ul>
<li> <p><code>periods</code>:  Time point of each observation (integer &gt;= 1).
</p>
</li>
<li> <p><code>home_team</code>: Home team's name (character string).
</p>
</li>
<li> <p><code>away_team</code>: Away team's name (character string).
</p>
</li>
<li> <p><code>home_goals</code>: Goals scored by the home team (integer &gt;= 0).
</p>
</li>
<li> <p><code>away_goals</code>: Goals scored by the away team (integer &gt;= 0).
</p>
</li></ul>
</td></tr>
<tr><td><code id="foot_round_robin_+3A_teams">teams</code></td>
<td>
<p>An optional character vector specifying team names to include. If <code>NULL</code>, all teams are included.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For Bayesian models fitted via <code>stan_foot</code> the round-robin table is computed according to the
simulation from the posterior predictive distribution of future (out-of-sample) matches.
The dataset should refer to one or more seasons from a given national football league (Premier League, Serie A, La Liga, etc.).
</p>


<h3>Value</h3>

<p>Round-robin plot with the home-win posterior probabilities computed from the ppd of the fitted model via the <code>stan_foot</code> function.
</p>


<h3>Author(s)</h3>

<p>Leonardo Egidi <a href="mailto:legidi@units.it">legidi@units.it</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
library(dplyr)

data("italy")
italy_1999_2000&lt;- italy %&gt;%
dplyr::select(Season, home, visitor, hgoal,vgoal) %&gt;%
dplyr::filter(Season == "1999"|Season=="2000")

colnames(italy_1999_2000) &lt;- c("periods", "home_team", "away_team", "home_goals", "away_goals")

fit &lt;- stan_foot(italy_1999_2000, "double_pois", predict = 45, iter = 200)

foot_round_robin(fit, italy_1999_2000)
foot_round_robin(fit, italy_1999_2000, c("Parma AC", "AS Roma"))


## End(Not run)
</code></pre>

<hr>
<h2 id='italy'>Italy league results 1934-2022</h2><span id='topic+italy'></span>

<h3>Description</h3>

<p>All results for Italian soccer games in the top tier
from 1934/35 season to 2021/22 season.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>italy
</code></pre>


<h3>Format</h3>

<p>A data frame with 27684 rows and 8 variables:
</p>

<dl>
<dt>Date</dt><dd><p>Date of match</p>
</dd>
<dt>Season</dt><dd><p>Season of match - refers to starting year</p>
</dd>
<dt>home</dt><dd><p>Home team</p>
</dd>
<dt>visitor</dt><dd><p>Visiting team</p>
</dd>
<dt>FT</dt><dd><p>Full-time result</p>
</dd>
<dt>hgoal</dt><dd><p>Goals scored by home team</p>
</dd>
<dt>vgoal</dt><dd><p>Goals scored by visiting team</p>
</dd>
<dt>tier</dt><dd><p>Tier of football pyramid: 1</p>
</dd>
</dl>


<hr>
<h2 id='mle_foot'>Fit football models with Maximum Likelihood</h2><span id='topic+mle_foot'></span>

<h3>Description</h3>

<p>ML football modelling for the most famous models:
double Poisson, bivariate Poisson, Skellam and student t.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mle_foot(data, model, predict, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mle_foot_+3A_data">data</code></td>
<td>
<p>A data frame, or a matrix containing the following mandatory items: season, home team, away team,
home goals, away goals.</p>
</td></tr>
<tr><td><code id="mle_foot_+3A_model">model</code></td>
<td>
<p>The type of model used to fit the data.
One among the following: <code>"double_pois"</code>,
<code>"biv_pois"</code>, <code>"skellam"</code>, <code>"student_t"</code>.</p>
</td></tr>
<tr><td><code id="mle_foot_+3A_predict">predict</code></td>
<td>
<p>The number of out-of-sample matches. If missing, the function returns
the fit for the training set only.</p>
</td></tr>
<tr><td><code id="mle_foot_+3A_...">...</code></td>
<td>
<p>Optional arguments for MLE fit algorithms.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See documentation of <code>stan_foot</code> function for model details.
MLE can be obtained only for static models, with no time-dependence.
Likelihood optimization is performed via the <code>BFGS</code> method
of the <code><a href="stats.html#topic+optim">optim</a></code> function.
</p>


<h3>Value</h3>

<p>MLE and 95% profile likelihood deviance confidence intervals for the
model's parameters: attack, defence, home effect and goals' correlation.
</p>


<h3>Author(s)</h3>

<p>Leonardo Egidi <a href="mailto:legidi@units.it">legidi@units.it</a>
</p>


<h3>References</h3>

<p>Baio, G. and Blangiardo, M. (2010). Bayesian hierarchical model for the prediction of football
results. Journal of Applied Statistics 37(2), 253-264.
</p>
<p>Egidi, L., Pauli, F., and Torelli, N. (2018). Combining historical data
and bookmakers' odds in modelling football scores. Statistical Modelling, 18(5-6), 436-459.
</p>
<p>Gelman, A. (2014). Stan goes to the World Cup. From
&quot;Statistical Modeling, Causal Inference, and Social Science&quot; blog.
</p>
<p>Karlis, D. and Ntzoufras, I. (2003). Analysis of sports data by using bivariate poisson models.
Journal of the Royal Statistical Society: Series D (The Statistician) 52(3), 381-393.
</p>
<p>Karlis, D. and Ntzoufras,I. (2009).  Bayesian modelling of football outcomes: Using
the Skellam's distribution for the goal difference. IMA Journal of Management Mathematics 20(2), 133-145.
</p>
<p>Owen, A. (2011). Dynamic Bayesian forecasting models
of football match outcomes with estimation of the
evolution variance parameter. IMA Journal of Management Mathematics, 22(2), 99-113.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
require(tidyverse)
require(dplyr)

data("italy")
italy &lt;- as_tibble(italy)
italy_2008&lt;- italy %&gt;%
   dplyr::select(Season, home, visitor, hgoal,vgoal) %&gt;%
   dplyr::filter( Season=="2008")

mle_fit &lt;- mle_foot(data  = italy_2008,
                   model = "double_pois")

## End(Not run)


</code></pre>

<hr>
<h2 id='plot_btdPosterior'>Plot Posterior Distributions for <code>btdFoot</code> Objects</h2><span id='topic+plot_btdPosterior'></span>

<h3>Description</h3>

<p>Plots for the posterior distributions of team log-strengths and other parameters with customizable plot types and facets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_btdPosterior(
  x,
  pars = "logStrength",
  plot_type = "boxplot",
  teams = NULL,
  ncol = NULL,
  scales = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_btdPosterior_+3A_x">x</code></td>
<td>
<p>An object of class <code>btdFoot</code>.</p>
</td></tr>
<tr><td><code id="plot_btdPosterior_+3A_pars">pars</code></td>
<td>
<p>A character string specifying the parameter to plot.
Choices are <code>"logStrength"</code>, <code>"logTie"</code>, and <code>"home"</code>.
Default is <code>"logStrength"</code>.</p>
</td></tr>
<tr><td><code id="plot_btdPosterior_+3A_plot_type">plot_type</code></td>
<td>
<p>A character string specifying the type of plot.
Choices are <code>"boxplot"</code> and <code>"density"</code>.
Default is <code>"boxplot"</code>.</p>
</td></tr>
<tr><td><code id="plot_btdPosterior_+3A_teams">teams</code></td>
<td>
<p>An optional character vector specifying team names to include in the posterior
boxplots or density plots. If <code>NULL</code>, all teams are included.</p>
</td></tr>
<tr><td><code id="plot_btdPosterior_+3A_ncol">ncol</code></td>
<td>
<p>An optional integer specifying the number of columns in the facet wrap
when using a dynamic Bayesian Bradley-Terry-Davidson model.
Default is <code>8</code>.</p>
</td></tr>
<tr><td><code id="plot_btdPosterior_+3A_scales">scales</code></td>
<td>
<p>An optional character string specifying the scales for the facets
when using a dynamic Bayesian Bradley-Terry-Davidson model.
Options include <code>"free"</code>, <code>"fixed"</code>, <code>"free_x"</code>, and <code>"free_y"</code>.
Default is <code>"free_x"</code>.</p>
</td></tr>
<tr><td><code id="plot_btdPosterior_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>geom_boxplot()</code>, <code>geom_density_ridges()</code>,
or other geoms for customization (e.g., <code>size</code>, <code>alpha</code>, <code>color</code>).</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><strong>Dynamic Ranking</strong>: Faceted boxplots or density plots (including the 95% credible interval) of posterior log-strengths by team and period.
</p>
</li>
<li> <p><strong>Static Ranking</strong>: Boxplots or density plots (including the 95% credible interval) of posterior log-strengths for each team.
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>ggplot</code> object representing the posterior distributions plot.
</p>


<h3>Author(s)</h3>

<p>Roberto Macrì Demartino <a href="mailto:roberto.macridemartino@phd.unipd.it">roberto.macridemartino@phd.unipd.it</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(dplyr)

# Load example data
data("italy")

# Prepare the data
italy_2020_2021_rank &lt;- italy %&gt;%
  select(Season, home, visitor, hgoal, vgoal) %&gt;%
  filter(Season %in% c("2020", "2021")) %&gt;%
  mutate(match_outcome = case_when(
    hgoal &gt; vgoal ~ 1,        # Home team wins
    hgoal == vgoal ~ 2,       # Draw
    hgoal &lt; vgoal ~ 3         # Away team wins
  )) %&gt;%
  mutate(periods = case_when(
    row_number() &lt;= 190 ~ 1,
    row_number() &lt;= 380 ~ 2,
    row_number() &lt;= 570 ~ 3,
    TRUE ~ 4
  )) %&gt;%  # Assign periods based on match number
  select(periods, home_team = home,
         away_team = visitor, match_outcome)

# Fit the Bayesian Bradley-Terry-Davidson model with dynamic ranking
fit_rank_dyn &lt;- btd_foot(
  data = italy_2020_2021_rank,
  dynamic_rank = TRUE,
  rank_measure = "median",
  iter = 1000,
  cores = 2,
  chains = 2
)

# Plot posterior distributions with default settings
plot_btdPosterior(fit_rank_dyn)

# Plot posterior distributions for specific teams with customized facets
plot_btdPosterior(
  fit_rank_dyn,
  teams = c("AC Milan", "AS Roma", "Juventus", "Inter"),
  ncol = 2
)

plot_btdPosterior(
  fit_rank_dyn,
  plot_type = "density",
  teams = c("AC Milan", "AS Roma", "Juventus", "Inter"),
  ncol = 2
)

## End(Not run)

</code></pre>

<hr>
<h2 id='plot_logStrength'>Plot Rankings for btdFoot Objects</h2><span id='topic+plot_logStrength'></span>

<h3>Description</h3>

<p>Visualizes team rankings based on whether the ranking is dynamic or static.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_logStrength(x, teams = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_logStrength_+3A_x">x</code></td>
<td>
<p>An object of class <code>btdFoot</code>.</p>
</td></tr>
<tr><td><code id="plot_logStrength_+3A_teams">teams</code></td>
<td>
<p>An optional character vector specifying team names to include in the rankings plot. If <code>NULL</code>, all teams are included.</p>
</td></tr>
<tr><td><code id="plot_logStrength_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>geom_line()</code>, <code>geom_point()</code>, and <code>geom_segment()</code> for customization (e.g., <code>size</code>, <code>alpha</code>, <code>color</code>).</p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> Dynamic Ranking: Plots Rank Points over Periods for each team with lines and points.
</p>
</li>
<li><p> Static Ranking: Plots Rank Points on the x-axis against Team Names on the y-axis with horizontal lines and points.
</p>
</li></ul>



<h3>Value</h3>

<p>A ggplot object representing the rankings plot.
</p>


<h3>Author(s)</h3>

<p>Roberto Macrì Demartino <a href="mailto:roberto.macridemartino@phd.unipd.it">roberto.macridemartino@phd.unipd.it</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
library(dplyr)

data("italy")

italy_2020_2021_rank &lt;- italy %&gt;%
 select(Season, home, visitor, hgoal, vgoal) %&gt;%
 filter(Season == "2020" | Season == "2021") %&gt;%
 mutate(match_outcome = case_when(
   hgoal &gt; vgoal ~ 1,        # Home team wins
   hgoal == vgoal ~ 2,       # Draw
   hgoal &lt; vgoal ~ 3         # Away team wins
 )) %&gt;%
 mutate(periods = case_when(
   row_number() &lt;= 190 ~ 1,
   row_number() &lt;= 380 ~ 2,
   row_number() &lt;= 570 ~ 3,
   TRUE ~ 4
 )) %&gt;%  # Assign periods based on match number
 select(periods, home_team = home,
               away_team = visitor, match_outcome)

fit_rank_dyn &lt;- btd_foot(
 data = italy_2020_2021_rank,
 dynamic_rank = TRUE,
 rank_measure = "median",
 iter = 1000,
 cores = 2,
 chains = 2)

plot_logStrength(fit_rank_dyn)

plot_logStrength(fit_rank_dyn, teams = c("AC Milan", "AS Roma", "Juventus", "Inter"))



## End(Not run)
</code></pre>

<hr>
<h2 id='pp_foot'>Posterior predictive checks for football models</h2><span id='topic+pp_foot'></span>

<h3>Description</h3>

<p>The function provides posterior predictive plots to check the adequacy of the Bayesian models as
returned by the <code>stan_foot</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pp_foot(object, data, type = c("aggregated", "matches"), coverage = 0.95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pp_foot_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="rstan.html#topic+stanfit">stanfit</a></code> or <code>stanFoot</code> as given by <code>stan_foot</code> function.</p>
</td></tr>
<tr><td><code id="pp_foot_+3A_data">data</code></td>
<td>
<p>A data frame containing match data with columns:
</p>

<ul>
<li> <p><code>periods</code>:  Time point of each observation (integer &gt;= 1).
</p>
</li>
<li> <p><code>home_team</code>: Home team's name (character string).
</p>
</li>
<li> <p><code>away_team</code>: Away team's name (character string).
</p>
</li>
<li> <p><code>home_goals</code>: Goals scored by the home team (integer &gt;= 0).
</p>
</li>
<li> <p><code>away_goals</code>: Goals scored by the away team (integer &gt;= 0).
</p>
</li></ul>
</td></tr>
<tr><td><code id="pp_foot_+3A_type">type</code></td>
<td>
<p>Type of plots, one among <code>"aggregated"</code> or <code>"matches"</code>.</p>
</td></tr>
<tr><td><code id="pp_foot_+3A_coverage">coverage</code></td>
<td>
<p>Argument to specify the width <code class="reqn">1-\alpha</code> of posterior probability intervals. Default is 0.95.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Posterior predictive plots: when <code>"aggregated"</code> (default) is selected, the function
returns a frequency plot for some pre-selected goal-difference values,
along with their correspondent Bayesian p-values, computed as
<code class="reqn">Pr(y_rep \ge y)|y)</code>, where <code class="reqn">y_rep</code> is a data replication from the
posterior predictive distribution (more details in Gelman et al., 2013).
Bayesian p-values very close to 0 or 1 could exhibit
possible model misfits.
</p>
<p>When <code>"matches"</code> is selected an ordered-frequency plot for all the
goal-differences in the considered matches is provided, along with the
empirical Bayesian coverage at level <code class="reqn">1-\alpha</code>.
</p>


<h3>Author(s)</h3>

<p>Leonardo Egidi <a href="mailto:legidi@units.it">legidi@units.it</a>
</p>


<h3>References</h3>

<p>Gelman, A., Carlin, J. B., Stern, H. S., Dunson, D. B., Vehtari, A., &amp; Rubin, D. B. (2013). Bayesian data analysis. CRC press.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
library(dplyr)

data("italy")
italy_2000 &lt;- italy %&gt;%
 dplyr::select(Season, home, visitor, hgoal,vgoal) %&gt;%
 dplyr::filter(Season=="2000")

colnames(italy_2000) &lt;- c("periods", "home_team", "away_team", "home_goals", "away_goals")

fit &lt;- stan_foot(italy_2000, "double_pois", iter = 200)

pp_foot(fit, italy_2000)


## End(Not run)
</code></pre>

<hr>
<h2 id='print.btdFoot'>Print Method for btdFoot Objects</h2><span id='topic+print.btdFoot'></span>

<h3>Description</h3>

<p>Provides detailed posterior summaries for the Bayesian Bradley-Terry-Davidson model parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'btdFoot'
print(
  x,
  pars = NULL,
  teams = NULL,
  digits = 3,
  true_names = TRUE,
  display = c("both", "rankings", "parameters"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.btdFoot_+3A_x">x</code></td>
<td>
<p>An object of class <code>btdFoot</code>.</p>
</td></tr>
<tr><td><code id="print.btdFoot_+3A_pars">pars</code></td>
<td>
<p>Optional character vector specifying parameters to include in the summary (e.g., <code>"logStrength"</code>, <code>"logTie"</code>, <code>"home"</code>, <code>"log_lik"</code>, and <code>"y_rep"</code>).</p>
</td></tr>
<tr><td><code id="print.btdFoot_+3A_teams">teams</code></td>
<td>
<p>Optional character vector specifying team names whose <code>logStrength</code> parameters should be displayed.</p>
</td></tr>
<tr><td><code id="print.btdFoot_+3A_digits">digits</code></td>
<td>
<p>Number of digits to use when printing numeric values. Default is <code>3</code>.</p>
</td></tr>
<tr><td><code id="print.btdFoot_+3A_true_names">true_names</code></td>
<td>
<p>Logical value indicating whether to display team names in parameter summaries. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="print.btdFoot_+3A_display">display</code></td>
<td>
<p>Character string specifying which parts of the output to display. Options are <code>"both"</code>, <code>"rankings"</code>, or <code>"parameters"</code>. Default is <code>"both"</code>.</p>
</td></tr>
<tr><td><code id="print.btdFoot_+3A_...">...</code></td>
<td>
<p>Additional arguments passed.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Roberto Macrì Demartino <a href="mailto:roberto.macridemartino@phd.unipd.it">roberto.macridemartino@phd.unipd.it</a>
</p>

<hr>
<h2 id='print.compareFoot'>Print method for compareFoot objects</h2><span id='topic+print.compareFoot'></span>

<h3>Description</h3>

<p>Provides a formatted output when printing objects of class <code>compareFoot</code>, displaying the predictive performance metrics and, if available, the confusion matrices for each model or probability matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'compareFoot'
print(x, digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.compareFoot_+3A_x">x</code></td>
<td>
<p>An object of class <code>compareFoot</code> returned by <code><a href="#topic+compare_foot">compare_foot</a></code>.</p>
</td></tr>
<tr><td><code id="print.compareFoot_+3A_digits">digits</code></td>
<td>
<p>Number of digits to use when printing numeric values for the metrics. Default is <code>3</code>.</p>
</td></tr>
<tr><td><code id="print.compareFoot_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code>print</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Roberto Macrì Demartino <a href="mailto:roberto.macridemartino@phd.unipd.it">roberto.macridemartino@phd.unipd.it</a>
</p>

<hr>
<h2 id='print.stanFoot'>Print Method for stanFoot Objects</h2><span id='topic+print.stanFoot'></span>

<h3>Description</h3>

<p>Provides detailed posterior summaries for the Stan football model parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'stanFoot'
print(x, pars = NULL, teams = NULL, digits = 3, true_names = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.stanFoot_+3A_x">x</code></td>
<td>
<p>An object of class <code>stanFoot</code>.</p>
</td></tr>
<tr><td><code id="print.stanFoot_+3A_pars">pars</code></td>
<td>
<p>Optional character vector specifying parameters to include in the summary. This can be specific parameter names (e.g., <code>"att"</code>, <code>"def"</code>, <code>"att_raw"</code>, <code>"def_raw"</code>, <code>"home"</code>, <code>"sigma_att"</code>, <code>"sigma_def"</code>, <code>"rho"</code>, and <code>"beta"</code>). If <code>NULL</code>, all parameters are included.</p>
</td></tr>
<tr><td><code id="print.stanFoot_+3A_teams">teams</code></td>
<td>
<p>Optional character vector specifying team names whose <code>"att"</code>, <code>"def"</code>, <code>"att_raw"</code>, <code>"def_raw"</code> parameters should be displayed.</p>
</td></tr>
<tr><td><code id="print.stanFoot_+3A_digits">digits</code></td>
<td>
<p>Number of digits to use when printing numeric values. Default is <code>3</code>.</p>
</td></tr>
<tr><td><code id="print.stanFoot_+3A_true_names">true_names</code></td>
<td>
<p>Logical value indicating whether to display team names in parameter summaries. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="print.stanFoot_+3A_...">...</code></td>
<td>
<p>Additional arguments passed.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Roberto Macrì Demartino <a href="mailto:roberto.macridemartino@phd.unipd.it">roberto.macridemartino@phd.unipd.it</a>
</p>

<hr>
<h2 id='priors'>Football priors distributions and options</h2><span id='topic+priors'></span><span id='topic+normal'></span><span id='topic+student_t'></span><span id='topic+cauchy'></span><span id='topic+laplace'></span>

<h3>Description</h3>

<p>This prior specification is just a duplicate
of some of the priors used by the <span class="pkg">rstanarm</span> package.
</p>
<p>These prior distributions can be passed to the
<code>stan_foot</code> function, through the arguments <code>prior</code> and <code>prior_sd</code>.
See  the vignette <a href="http://mc-stan.org/rstanarm/articles/priors.html"><em>Prior
Distributions for rstanarm Models</em></a> for further details (to view the priors used for an existing model see
<a href="https://mc-stan.org/rstanarm/reference/prior_summary.stanreg.html">prior_summary</a>).
The default priors used in the <span class="pkg">stan_foot</span> modeling function
are intended to be <em>weakly informative</em> in that they provide moderate
regularlization and help stabilize computation.
</p>
<p>You can choose between: <code>normal</code>, <code>cauchy</code>, <code>laplace</code>, <code>student_t</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normal(location = 0, scale = NULL, autoscale = TRUE)

student_t(df = 1, location = 0, scale = NULL, autoscale = TRUE)

cauchy(location = 0, scale = NULL, autoscale = TRUE)

laplace(location = 0, scale = NULL, autoscale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="priors_+3A_location">location</code></td>
<td>
<p>Prior location. In most cases, this is the prior mean, but
for <code>cauchy</code> (which is equivalent to <code>student_t</code> with
<code>df=1</code>), the mean does not exist and <code>location</code> is the prior
median. The default value is <code class="reqn">0</code>.</p>
</td></tr>
<tr><td><code id="priors_+3A_scale">scale</code></td>
<td>
<p>Prior scale. The default depends on the family (see
<strong>Details</strong>).</p>
</td></tr>
<tr><td><code id="priors_+3A_autoscale">autoscale</code></td>
<td>
<p>A logical scalar, defaulting to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="priors_+3A_df">df</code></td>
<td>
<p>Prior degrees of freedom. The default is <code class="reqn">1</code> for
<code>student_t</code>, in which case it is equivalent to <code>cauchy</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The details depend on the family of the prior being used:
</p>


<h4>Student t family</h4>

<p>Family members:
</p>

<ul>
<li> <p><code>normal(location, scale)</code>
</p>
</li>
<li> <p><code>student_t(df, location, scale)</code>
</p>
</li>
<li> <p><code>cauchy(location, scale)</code>
</p>
</li></ul>

<p>Each of these functions also takes an argument <code>autoscale</code>.
</p>
<p>For the prior distribution for the intercept, <code>location</code>,
<code>scale</code>, and <code>df</code> should be scalars. For the prior for the other
coefficients they can either be vectors of length equal to the number of
coefficients (not including the intercept), or they can be scalars, in
which case they will be recycled to the appropriate length. As the
degrees of freedom approaches infinity, the Student t distribution
approaches the normal distribution and if the degrees of freedom are one,
then the Student t distribution is the Cauchy distribution.
</p>
<p>If <code>scale</code> is not specified it will default to <code class="reqn">10</code> for the
intercept and <code class="reqn">2.5</code> for the other coefficients.
</p>
<p>If the <code>autoscale</code> argument is <code>TRUE</code> (the default), then the
scales will be further adjusted as described above in the documentation of
the <code>autoscale</code> argument in the <strong>Arguments</strong> section.
</p>



<h4>Laplace family</h4>

<p>Family members:
</p>

<ul>
<li> <p><code>laplace(location, scale)</code>
</p>
</li></ul>

<p>Each of these functions also takes an argument <code>autoscale</code>.
</p>
<p>The Laplace distribution is also known as the double-exponential
distribution. It is a symmetric distribution with a sharp peak at its mean
/ median / mode and fairly long tails. This distribution can be motivated
as a scale mixture of normal distributions and the remarks above about the
normal distribution apply here as well.
</p>



<h3>Value</h3>

<p>A named list to be used internally by the
<code>stan_foot</code> model fitting function.
</p>


<h3>Author(s)</h3>

<p>Leonardo Egidi <a href="mailto:legidi@units.it">legidi@units.it</a>
</p>


<h3>References</h3>

<p>Gelman, A., Jakulin, A., Pittau, M. G., and Su, Y. (2008). A weakly
informative default prior distribution for logistic and other regression
models. <em>Annals of Applied Statistics</em>. 2(4), 1360&ndash;1383.
</p>


<h3>See Also</h3>

<p>The various vignettes for the <span class="pkg">rstanarm</span> package also discuss
and demonstrate the use of some of the supported prior distributions.
</p>

<hr>
<h2 id='stan_foot'>Fit football models  with Stan</h2><span id='topic+stan_foot'></span>

<h3>Description</h3>

<p>Stan football modelling for the most famous models:
double Poisson, bivariate Poisson, Skellam, student t, diagonal-inflated bivariate Poisson and zero-inflated Skellam.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stan_foot(
  data,
  model,
  predict = 0,
  ranking,
  dynamic_type,
  prior_par = list(ability = normal(0, NULL), ability_sd = cauchy(0, 5), home = normal(0,
    5)),
  home_effect = TRUE,
  norm_method = "none",
  ranking_map = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stan_foot_+3A_data">data</code></td>
<td>
<p>A data frame containing match data with columns:
</p>

<ul>
<li> <p><code>periods</code>:  Time point of each observation (integer &gt;= 1).
</p>
</li>
<li> <p><code>home_team</code>: Home team's name (character string).
</p>
</li>
<li> <p><code>away_team</code>: Away team's name (character string).
</p>
</li>
<li> <p><code>home_goals</code>: Goals scored by the home team (integer &gt;= 0).
</p>
</li>
<li> <p><code>away_goals</code>: Goals scored by the away team (integer &gt;= 0).
</p>
</li></ul>
</td></tr>
<tr><td><code id="stan_foot_+3A_model">model</code></td>
<td>
<p>A character string specifying the Stan model to fit. Options are:
</p>

<ul>
<li> <p><code>"double_pois"</code>: Double Poisson model.
</p>
</li>
<li> <p><code>"biv_pois"</code>: Bivariate Poisson model.
</p>
</li>
<li> <p><code>"skellam"</code>: Skellam model.
</p>
</li>
<li> <p><code>"student_t"</code>: Student's t model.
</p>
</li>
<li> <p><code>"diag_infl_biv_pois"</code>: Diagonal-inflated bivariate Poisson model.
</p>
</li>
<li> <p><code>"zero_infl_skellam"</code>: Zero-inflated Skellam model.
</p>
</li></ul>
</td></tr>
<tr><td><code id="stan_foot_+3A_predict">predict</code></td>
<td>
<p>An integer specifying the number of out-of-sample matches for prediction. If missing, the function fits the model to the entire dataset without making predictions.</p>
</td></tr>
<tr><td><code id="stan_foot_+3A_ranking">ranking</code></td>
<td>
<p>An optional <code>"btdFoot"</code> class element or a data frame containing ranking points for teams with the following columns:
</p>

<ul>
<li> <p><code>periods</code>: Time periods corresponding to the rankings (integer &gt;= 1).
</p>
</li>
<li> <p><code>team</code>: Team names matching those in <code>data</code> (character string).
</p>
</li>
<li> <p><code>rank_points</code>: Ranking points for each team (numeric).
</p>
</li></ul>
</td></tr>
<tr><td><code id="stan_foot_+3A_dynamic_type">dynamic_type</code></td>
<td>
<p>A character string specifying the type of dynamics in the model. Options are:
</p>

<ul>
<li> <p><code>"weekly"</code>: Weekly dynamic parameters.
</p>
</li>
<li> <p><code>"seasonal"</code>: Seasonal dynamic parameters.
</p>
</li></ul>
</td></tr>
<tr><td><code id="stan_foot_+3A_prior_par">prior_par</code></td>
<td>
<p>A list specifying the prior distributions for the parameters of interest:
</p>

<ul>
<li> <p><code>ability</code>: Prior distribution for team-specific abilities. Possible distributions are <code>normal</code>, <code>student_t</code>, <code>cauchy</code>, <code>laplace</code>. Default is <code>normal(0, NULL)</code>.
</p>
</li>
<li> <p><code>ability_sd</code>:  Prior distribution for the team-specific standard deviations. See the <code>prior</code> argument for more details. Default is <code>cauchy(0, 5)</code>.
</p>
</li>
<li> <p><code>home</code>: Prior distribution for the home effect (<code>home</code>). Applicable only if <code>home_effect = TRUE</code>. Only normal priors are allowed. Default is <code>normal(0, 5)</code>.
</p>
</li></ul>

<p>See the <span class="pkg">rstanarm</span> package for more details on specifying priors.</p>
</td></tr>
<tr><td><code id="stan_foot_+3A_home_effect">home_effect</code></td>
<td>
<p>A logical value indicating the inclusion of a home effect in the model. (default is <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="stan_foot_+3A_norm_method">norm_method</code></td>
<td>
<p>A character string specifying the method used to normalize team-specific ranking points. Options are:
</p>

<ul>
<li> <p><code>"none"</code>: No normalization (default).
</p>
</li>
<li> <p><code>"standard"</code>: Standardization (mean 0, standard deviation 1).
</p>
</li>
<li> <p><code>"mad"</code>: Median Absolute Deviation normalization.
</p>
</li>
<li> <p><code>"min_max"</code>: Min-max scaling to [0,1].
</p>
</li></ul>
</td></tr>
<tr><td><code id="stan_foot_+3A_ranking_map">ranking_map</code></td>
<td>
<p>An optional vector mapping ranking periods to data periods. If not provided and the number of ranking periods matches the number of data periods, a direct mapping is assumed.</p>
</td></tr>
<tr><td><code id="stan_foot_+3A_...">...</code></td>
<td>
<p>Optional parameters passed to <code><a href="rstan.html#topic+stan">stan</a></code> (e.g., <code>iter</code>, <code>chains</code>, <code>cores</code>, <code>control</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">(y^{H}_{n}, y^{A}_{n})</code> denote the
observed number of goals scored by the home
and the away team in the <code class="reqn">n</code>-th game,
respectively. A general bivariate Poisson model
allowing for goals' correlation
(Karlis &amp; Ntzoufras, 2003) is the following:
</p>
<p style="text-align: center;"><code class="reqn"> Y^H_n, Y^A_n| \lambda_{1n}, \lambda_{2n}, \lambda_{3n}  \sim \mathsf{BivPoisson}(\lambda_{1n}, \lambda_{2n}, \lambda_{3n})</code>
</p>

<p style="text-align: center;"><code class="reqn">\log(\lambda_{1n})  = \mu+att_{h_n} + def_{a_n}</code>
</p>

<p style="text-align: center;"><code class="reqn">\log(\lambda_{2n})  = att_{a_n} + def_{h_n}</code>
</p>

<p style="text-align: center;"><code class="reqn">\log(\lambda_{3n})  =\beta_0,</code>
</p>

<p>where the case <code class="reqn">\lambda_{3n}=0</code> reduces to
the double Poisson model (Baio &amp; Blangiardo, 2010).
<code class="reqn">\lambda_{1n}, \lambda_{2n}</code> represent the
scoring rates for the home and the away team,
respectively, where: <code class="reqn">\mu</code> is the home effect;
the parameters <code class="reqn">att_T</code> and
<code class="reqn">def_T</code> represent the attack and the
defence abilities,
respectively, for each team <code class="reqn">T</code>, <code class="reqn">T=1,\ldots,N_T</code>;
the nested indexes <code class="reqn">h_{n}, a_{n}=1,\ldots,N_T</code>
denote the home and the away team playing in the <code class="reqn">n</code>-th game,
respectively. Attack/defence parameters are imposed a
sum-to-zero constraint to achieve identifiability and
assigned some weakly-informative prior distributions:
</p>
<p style="text-align: center;"><code class="reqn">att_T \sim \mathcal{N}(\mu_{att}, \sigma_{att})</code>
</p>

<p style="text-align: center;"><code class="reqn">def_T \sim \mathcal{N}(\mu_{def}, \sigma_{def}),</code>
</p>

<p>with hyperparameters <code class="reqn">\mu_{att}, \sigma_{att}, \mu_{def}, \sigma_{def}</code>.
</p>
<p>Instead of using the marginal number of goals,
another alternative is to modelling directly
the score difference <code class="reqn">(y^{H}_{n}- y^{A}_{n})</code>.
We can use the Poisson-difference distribution
(or Skellam distribution) to model goal
difference in the <code class="reqn">n</code>-th match (Karlis &amp; Ntzoufras, 2009):
</p>
<p style="text-align: center;"><code class="reqn">y^{H}_{n}- y^{A}_{n}| \lambda_{1n}, \lambda_{2n} \sim PD(\lambda_{1n}, \lambda_{2n}),</code>
</p>

<p>and the scoring rates <code class="reqn">\lambda_{1n}, \lambda_{2n}</code> are
unchanged with respect to the bivariate/double Poisson model.
If we want to use a continue distribution, we can
use a student t distribution with 7 degrees of
freedom (Gelman, 2014):
</p>
<p style="text-align: center;"><code class="reqn">y^{H}_{n}- y^{A}_{n} \sim t(7, ab_{h_{n}}-ab_{a(n)}, \sigma_y)</code>
</p>

<p style="text-align: center;"><code class="reqn">ab_t \sim \mathcal{N}(\mu + b \times {prior\_score}_t, sigma_{ab}),</code>
</p>

<p>where <code class="reqn">ab_t</code> is the overall ability for
the <code class="reqn">t</code>-th team, whereas <code class="reqn">prior\_score_t</code>
is a prior measure of team's strength (for instance a
ranking).
</p>
<p>These model rely on the assumption of static parameters.
However, we could assume dynamics in the attach/defence
abilities (Owen, 2011; Egidi et al., 2018) in terms of weeks or seasons through the argument
<code>dynamic_type</code>. In such a framework, for a given
number of times <code class="reqn">1, \ldots, \mathcal{T}</code>, the models
above would be unchanged, but the priors for the abilities
parameters at each time <code class="reqn">\tau, \tau=2,\ldots, \mathcal{T},</code> would be:
</p>
<p style="text-align: center;"><code class="reqn">att_{T, \tau} \sim \mathcal{N}({att}_{T, \tau-1}, \sigma_{att})</code>
</p>

<p style="text-align: center;"><code class="reqn">def_{T, \tau} \sim \mathcal{N}({def}_{T, \tau-1}, \sigma_{def}),</code>
</p>

<p>whereas for <code class="reqn">\tau=1</code> we have:
</p>
<p style="text-align: center;"><code class="reqn">att_{T, 1} \sim \mathcal{N}(\mu_{att}, \sigma_{att})</code>
</p>

<p style="text-align: center;"><code class="reqn">def_{T, 1} \sim \mathcal{N}(\mu_{def}, \sigma_{def}).</code>
</p>

<p>Of course, the identifiability constraint must be imposed for
each time <code class="reqn">\tau</code>.
</p>
<p>The current version of the package allows for the fit of a
diagonal-inflated bivariate Poisson and a zero-inflated Skellam model in the
spirit of (Karlis &amp; Ntzoufras, 2003) to better capture draw occurrences. See the vignette for further details.
</p>


<h3>Value</h3>

<p>A list of class <code>"stanFoot"</code> containing:
</p>

<ul>
<li> <p><code>fit</code>: The fitted <code>stanfit</code> object returned by <code><a href="rstan.html#topic+stan">stan</a></code>.
</p>
</li>
<li> <p><code>data</code>: The input data.
</p>
</li>
<li> <p><code>stan_data</code>: The data list for Stan.
</p>
</li>
<li> <p><code>stan_code</code>: The Stan code of the underline model.
</p>
</li>
<li> <p><code>stan_args</code>: The optional parameters passed to (<code>...</code>).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Leonardo Egidi <a href="mailto:legidi@units.it">legidi@units.it</a>, Roberto Macrì Demartino <a href="mailto:roberto.macridemartino@phd.unipd.it">roberto.macridemartino@phd.unipd.it</a>, and Vasilis Palaskas <a href="mailto:vasilis.palaskas94@gmail.com">vasilis.palaskas94@gmail.com</a>.
</p>


<h3>References</h3>

<p>Baio, G. and Blangiardo, M. (2010). Bayesian hierarchical model for the prediction of football
results. Journal of Applied Statistics 37(2), 253-264.
</p>
<p>Egidi, L., Pauli, F., and Torelli, N. (2018). Combining historical data
and bookmakers' odds in modelling football scores. Statistical Modelling, 18(5-6), 436-459.
</p>
<p>Gelman, A. (2014). Stan goes to the World Cup. From
&quot;Statistical Modeling, Causal Inference, and Social Science&quot; blog.
</p>
<p>Karlis, D. and Ntzoufras, I. (2003). Analysis of sports data by using bivariate poisson models.
Journal of the Royal Statistical Society: Series D (The Statistician) 52(3), 381-393.
</p>
<p>Karlis, D. and Ntzoufras,I. (2009).  Bayesian modelling of football outcomes: Using
the Skellam's distribution for the goal difference. IMA Journal of Management Mathematics 20(2), 133-145.
</p>
<p>Owen, A. (2011). Dynamic Bayesian forecasting models
of football match outcomes with estimation of the
evolution variance parameter. IMA Journal of Management Mathematics, 22(2), 99-113.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(dplyr)



# Example usage with ranking
data("italy")
italy &lt;- as_tibble(italy)
italy_2021 &lt;- italy %&gt;%
  select(Season, home, visitor, hgoal, vgoal) %&gt;%
  filter(Season == "2021")


teams &lt;- unique(italy_2021$home)
n_rows &lt;- 20

# Create fake ranking
ranking &lt;- data.frame(
  periods = rep(1, n_rows),
  team = sample(teams, n_rows, replace = FALSE),
  rank_points = sample(0:60, n_rows, replace = FALSE)
)

ranking &lt;- ranking %&gt;%
  arrange(periods, desc(rank_points))


colnames(italy_2021) &lt;- c("periods", "home_team", "away_team", "home_goals", "away_goals")

fit_with_ranking &lt;- stan_foot(
  data = italy_2021
  model = "diag_infl_biv_pois",
  ranking = ranking,
  home_effect = TRUE,
  prior_par = list(
    ability = student_t(4, 0, NULL),
    ability_sd = cauchy(0, 3),
    home = normal(1, 10)
  ),
  norm_method = "mad",
  iter = 1000,
  chains = 2,
  cores = 2,
  control = list(adapt_delta = 0.95, max_treedepth = 15)
)

# Print a summary of the model fit
print(fit_with_ranking, pars = c("att","def"))



### Use Italian Serie A from 2000 to 2002

data("italy")
italy &lt;- as_tibble(italy)
italy_2000_2002&lt;- italy %&gt;%
 dplyr::select(Season, home, visitor, hgoal,vgoal) %&gt;%
 dplyr::filter(Season=="2000" |  Season=="2001"| Season=="2002")

colnames(italy_2000_2002) &lt;- c("periods", "home_team", "away_team", "home_goals", "away_goals")

### Fit Stan models
## no dynamics, no predictions

fit_1 &lt;- stan_foot(data = italy_2000_2002,
                  model = "double_pois") # double poisson
print(fit_1, pars = c("home", "sigma_att",
                    "sigma_def"))

fit_2 &lt;- stan_foot(data = italy_2000_2002,
                  model = "biv_pois")    # bivariate poisson
print(fit_2, pars = c("home", "rho",
                    "sigma_att", "sigma_def"))

fit_3 &lt;- stan_foot(data = italy_2000_2002,
                  mode ="skellam")     # skellam
print(fit_3, pars = c("home", "sigma_att",
                    "sigma_def"))

fit_4 &lt;- stan_foot(data = italy_2000_2002,
                  model = "student_t")   # student_t
print(fit_4, pars = c("beta"))

## seasonal dynamics, no prediction

fit_5 &lt;- stan_foot(data = italy_2000_2002,
                  model = "double_pois",
                  dynamic_type = "seasonal") # double poisson
print(fit_5, pars = c("home", "sigma_att",
                    "sigma_def"))

## seasonal dynamics, prediction for the last season

fit_6 &lt;- stan_foot(data = italy_2000_2002,
                  model = "double_pois",
                  dynamic_type = "seasonal",
                  predict = 170) # double poisson
print(fit_6, pars = c("home", "sigma_att",
                    "sigma_def"))

## other priors' options
# double poisson with
# student_t priors for teams abilities
# and laplace prior for the hyper sds

fit_p &lt;- stan_foot(data = italy_2000_2002,
                   model = "double_pois",
                   prior_par = list(ability = student_t(4, 0, NULL),
                                    ability_sd = laplace(0,1),
                                    home = normal(1, 10)
                                    ))

print(fit_p,  pars = c("home", "sigma_att",
                    "sigma_def"))

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
