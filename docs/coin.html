<!DOCTYPE html><html lang="en"><head><title>Help for package coin</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {coin}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coin-package'><p>General Information on the <span class="pkg">coin</span> Package</p></a></li>
<li><a href='#alpha'><p>Genetic Components of Alcoholism</p></a></li>
<li><a href='#alzheimer'><p>Smoking and Alzheimer's Disease</p></a></li>
<li><a href='#asat'><p>Toxicological Study on Female Wistar Rats</p></a></li>
<li><a href='#ContingencyTests'><p>Tests of Independence in Two- or Three-Way Contingency Tables</p></a></li>
<li><a href='#CorrelationTests'><p>Correlation Tests</p></a></li>
<li><a href='#CWD'><p>Coarse Woody Debris</p></a></li>
<li><a href='#expectation-methods'><p>Extraction of the Expectation, Variance and Covariance of the Linear</p>
Statistic</a></li>
<li><a href='#glioma'><p>Malignant Glioma Pilot Study</p></a></li>
<li><a href='#GTSG'><p>Gastrointestinal Tumor Study Group</p></a></li>
<li><a href='#hohnloser'><p>Left Ventricular Ejection Fraction</p></a></li>
<li><a href='#IndependenceLinearStatistic-class'><p>Class <code>"IndependenceLinearStatistic"</code></p></a></li>
<li><a href='#IndependenceProblem-class'><p>Class <code>"IndependenceProblem"</code></p></a></li>
<li><a href='#IndependenceTest'><p>General Independence Test</p></a></li>
<li><a href='#IndependenceTest-class'><p>Class <code>"IndependenceTest"</code> and Its Subclasses</p></a></li>
<li><a href='#IndependenceTestProblem-class'><p>Class <code>"IndependenceTestProblem"</code></p></a></li>
<li><a href='#IndependenceTestStatistic-class'><p>Class <code>"IndependenceTestStatistic"</code> and Its Subclasses</p></a></li>
<li><a href='#jobsatisfaction'><p>Income and Job Satisfaction</p></a></li>
<li><a href='#LocationTests'><p>Two- and <code class="reqn">K</code>-Sample Location Tests</p></a></li>
<li><a href='#malformations'><p>Maternal Drinking and Congenital Sex Organ Malformation</p></a></li>
<li><a href='#MarginalHomogeneityTests'><p>Marginal Homogeneity Tests</p></a></li>
<li><a href='#MaximallySelectedStatisticsTests'><p>Generalized Maximally Selected Statistics</p></a></li>
<li><a href='#mercuryfish'><p>Chromosomal Effects of Mercury-Contaminated Fish Consumption</p></a></li>
<li><a href='#neuropathy'><p>Acute Painful Diabetic Neuropathy</p></a></li>
<li><a href='#NullDistribution'><p>Specification of the Reference Distribution</p></a></li>
<li><a href='#NullDistribution-class'><p>Class <code>"NullDistribution"</code> and Its Subclasses</p></a></li>
<li><a href='#NullDistribution-methods'><p>Computation of the Reference Distribution</p></a></li>
<li><a href='#ocarcinoma'><p>Ovarian Carcinoma</p></a></li>
<li><a href='#PermutationDistribution-methods'><p>Computation of the Permutation Distribution</p></a></li>
<li><a href='#photocar'><p>Multiple Dosing Photococarcinogenicity Experiment</p></a></li>
<li><a href='#PValue-class'><p>Class <code>"PValue"</code></p></a></li>
<li><a href='#pvalue-methods'><p>Computation of the <code class="reqn">p</code>-Value, Mid-<code class="reqn">p</code>-Value, <code class="reqn">p</code>-Value</p>
Interval and Test Size</a></li>
<li><a href='#rotarod'><p>Rotating Rats</p></a></li>
<li><a href='#ScaleTests'><p>Two- and <code class="reqn">K</code>-Sample Scale Tests</p></a></li>
<li><a href='#statistic-methods'><p>Extraction of the Test Statistic and the Linear Statistic</p></a></li>
<li><a href='#SurvivalTests'><p>Two- and <code class="reqn">K</code>-Sample Tests for Censored Data</p></a></li>
<li><a href='#SymmetryProblem-class'><p>Class <code>"SymmetryProblem"</code></p></a></li>
<li><a href='#SymmetryTest'><p>General Symmetry Test</p></a></li>
<li><a href='#SymmetryTests'><p>Symmetry Tests</p></a></li>
<li><a href='#Transformations'><p>Functions for Data Transformation</p></a></li>
<li><a href='#treepipit'><p>Tree Pipits in Franconian Oak Forests</p></a></li>
<li><a href='#VarCovar-class'><p>Class <code>"VarCovar"</code> and its subclasses</p></a></li>
<li><a href='#vision'><p>Unaided Distance Vision</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>1.4-3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-26</td>
</tr>
<tr>
<td>Title:</td>
<td>Conditional Inference Procedures in a Permutation Test Framework</td>
</tr>
<tr>
<td>Description:</td>
<td>Conditional inference procedures for the general independence
             problem including two-sample, K-sample (non-parametric ANOVA),
             correlation, censored, ordered and multivariate problems described
             in &lt;<a href="https://doi.org/10.18637%2Fjss.v028.i08">doi:10.18637/jss.v028.i08</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), survival</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, parallel, stats, stats4, utils, libcoin (&ge; 1.0-9),
matrixStats (&ge; 0.54.0), modeltools (&ge; 0.2-9), mvtnorm (&ge;
1.0-5), multcomp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>xtable, e1071, vcd, TH.data (&ge; 1.0-7)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>libcoin (&ge; 1.0-9)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://coin.r-forge.r-project.org">http://coin.r-forge.r-project.org</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-27 09:53:17 UTC; hothorn</td>
</tr>
<tr>
<td>Author:</td>
<td>Torsten Hothorn <a href="https://orcid.org/0000-0001-8301-0471"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Henric Winell <a href="https://orcid.org/0000-0001-7995-3047"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Kurt Hornik <a href="https://orcid.org/0000-0003-4198-9911"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Mark A. van de Wiel
    <a href="https://orcid.org/0000-0003-4780-8472"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Achim Zeileis <a href="https://orcid.org/0000-0003-0918-3766"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Torsten Hothorn &lt;Torsten.Hothorn@R-project.org&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-27 16:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='coin-package'>General Information on the <span class="pkg">coin</span> Package</h2><span id='topic+coin-package'></span><span id='topic+coin'></span>

<h3>Description</h3>

<p>The <span class="pkg">coin</span> package provides an implementation of a general framework for
conditional inference procedures commonly known as <em>permutation tests</em>.
The framework was developed by Strasser and Weber (1999) and is based on a
multivariate linear statistic and its conditional expectation, covariance and
limiting distribution.  These results are utilized to construct tests of
independence between two sets of variables.
</p>
<p>The package does not only provide a flexible implementation of the abstract
framework, but also provides a large set of convenience functions implementing
well-known as well as lesser-known classical and non-classical test procedures
within the framework.  Many of the tests presented in prominent text books,
such as Hollander and Wolfe (1999) or Agresti (2002), are immediately
available or can be implemented without much effort.  Examples include linear
rank statistics for the two- and <code class="reqn">K</code>-sample location and scale problem
against ordered and unordered alternatives including post-hoc tests for
arbitrary contrasts, tests of independence for contingency tables, two- and
<code class="reqn">K</code>-sample tests for censored data, tests of independence between two
continuous variables as well as tests of marginal homogeneity and symmetry.
Approximations of the exact null distribution via the limiting distribution or
conditional Monte Carlo resampling are available for every test procedure,
while the exact null distribution is currently available for univariate
two-sample problems only.
</p>
<p>The salient parts of the Strasser-Weber framework are elucidated by Hothorn
<em>et al.</em> (2006) and a thorough description of the software implementation
is given by Hothorn <em>et al.</em> (2008).
</p>


<h3>Author(s)</h3>

<p>This package is authored by <br />
Torsten Hothorn &lt;Torsten.Hothorn@R-project.org&gt;, <br />
Kurt Hornik &lt;Kurt.Hornik@R-project.org&gt;, <br />
Mark A. van de Wiel &lt;Mark.vdWiel@vumc.nl&gt;, <br />
Henric Winell &lt;Henric.Winell@statistics.uu.se&gt; and <br />
Achim Zeileis &lt;Achim.Zeileis@R-project.org&gt;.
</p>


<h3>References</h3>

<p>Agresti, A.  (2002).  <em>Categorical Data Analysis</em>, Second Edition.
Hoboken, New Jersey: John Wiley &amp; Sons.
</p>
<p>Hollander, M. and Wolfe, D. A.  (1999).  <em>Nonparametric Statistical
Methods</em>, Second Edition.  New York: John Wiley &amp; Sons.
</p>
<p>Hothorn, T., Hornik, K., van de Wiel, M. A. and Zeileis, A.  (2006).  A Lego
system for conditional inference.  <em>The American Statistician</em>
<b>60</b>(3), 257&ndash;263.  <a href="https://doi.org/10.1198/000313006X118430">doi:10.1198/000313006X118430</a>
</p>
<p>Hothorn, T., Hornik, K., van de Wiel, M. A. and Zeileis, A.  (2008).
Implementing a class of permutation tests: The coin package.  <em>Journal of
Statistical Software</em> <b>28</b>(8), 1&ndash;23.  <a href="https://doi.org/10.18637/jss.v028.i08">doi:10.18637/jss.v028.i08</a>
</p>
<p>Strasser, H. and Weber, C.  (1999).  On the asymptotic theory of permutation
statistics.  <em>Mathematical Methods of Statistics</em> <b>8</b>(2), 220&ndash;250.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Generate doxygen documentation if you are interested in the internals:
## Download source package into a temporary directory
tmpdir &lt;- tempdir()
tgz &lt;- download.packages("coin", destdir = tmpdir, type = "source")[2]
## Extract contents
untar(tgz, exdir = tmpdir)
## Run doxygen (assuming it is installed)
wd &lt;- setwd(file.path(tmpdir, "coin"))
system("doxygen inst/doxygen.cfg")
setwd(wd)
## Have fun!
browseURL(file.path(tmpdir, "coin", "inst",
                    "documentation", "html", "index.html"))
## End(Not run)
</code></pre>

<hr>
<h2 id='alpha'>Genetic Components of Alcoholism</h2><span id='topic+alpha'></span>

<h3>Description</h3>

<p>Levels of expressed alpha synuclein mRNA in three groups of allele lengths of
NACP-REP1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alpha</code></pre>


<h3>Format</h3>

<p>A data frame with 97 observations on 2 variables.
</p>

<dl>
<dt><code>alength</code></dt><dd>
<p>allele length, a factor with levels <code>"short"</code>, <code>"intermediate"</code>
and <code>"long"</code>.
</p>
</dd>
<dt><code>elevel</code></dt><dd>
<p>expression levels of alpha synuclein mRNA.
</p>
</dd>
</dl>



<h3>Details</h3>

<p>Various studies have linked alcohol dependence phenotypes to chromosome 4.
One candidate gene is NACP (non-amyloid component of plaques), coding for
alpha synuclein.  Bönsch <em>et al.</em> (2005) found longer
alleles of NACP-REP1 in alcohol-dependent patients compared with healthy
controls and reported that the allele lengths show some association with
levels of expressed alpha synuclein mRNA.
</p>


<h3>Source</h3>

<p>Bönsch, D., Lederer, T., Reulbach, U., Hothorn, T., Kornhuber,
J. and Bleich, S.  (2005).  Joint analysis of the <em>NACP</em>-REP1 marker
within the alpha synuclein gene concludes association with alcohol dependence.
<em>Human Molecular Genetics</em> <b>14</b>(7), 967&ndash;971.
<a href="https://doi.org/10.1093/hmg/ddi090">doi:10.1093/hmg/ddi090</a>
</p>


<h3>References</h3>

<p>Hothorn, T., Hornik, K., van de Wiel, M. A. and Zeileis, A.  (2006).  A Lego
system for conditional inference.  <em>The American Statistician</em>
<b>60</b>(3), 257&ndash;263.  <a href="https://doi.org/10.1198/000313006X118430">doi:10.1198/000313006X118430</a>
</p>
<p>Winell, H. and Lindbäck, J.  (2018).  A general
score-independent test for order-restricted inference.  <em>Statistics in
Medicine</em> <b>37</b>(21), 3078&ndash;3090.  <a href="https://doi.org/10.1002/sim.7690">doi:10.1002/sim.7690</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Boxplots
boxplot(elevel ~ alength, data = alpha)

## Asymptotic Kruskal-Wallis test
kruskal_test(elevel ~ alength, data = alpha)

## Asymptotic Kruskal-Wallis test using midpoint scores
kruskal_test(elevel ~ alength, data = alpha,
             scores = list(alength = c(2, 7, 11)))

## Asymptotic score-independent test
## Winell and Lindbaeck (2018)
(it &lt;- independence_test(elevel ~ alength, data = alpha,
                         ytrafo = function(data)
                             trafo(data, numeric_trafo = rank_trafo), 
                         xtrafo = function(data)
                             trafo(data, factor_trafo = function(x)
                                 zheng_trafo(as.ordered(x)))))

## Extract the "best" set of scores
ss &lt;- statistic(it, type = "standardized")
idx &lt;- which(abs(ss) == max(abs(ss)), arr.ind = TRUE)
ss[idx[1], idx[2], drop = FALSE]
</code></pre>

<hr>
<h2 id='alzheimer'>Smoking and Alzheimer's Disease</h2><span id='topic+alzheimer'></span>

<h3>Description</h3>

<p>A case-control study of smoking and Alzheimer's disease.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alzheimer</code></pre>


<h3>Format</h3>

<p>A data frame with 538 observations on 3 variables.
</p>

<dl>
<dt><code>smoking</code></dt><dd>
<p>a factor with levels <code>"None"</code>, <code>"&lt;10"</code>, <code>"10-20"</code> and
<code>"&gt;20"</code> (cigarettes per day).
</p>
</dd>
<dt><code>disease</code></dt><dd>
<p>a factor with levels <code>"Alzheimer"</code>, <code>"Other dementias"</code> and
<code>"Other diagnoses"</code>.
</p>
</dd>
<dt><code>gender</code></dt><dd>
<p>a factor with levels <code>"Female"</code> and <code>"Male"</code>.
</p>
</dd>
</dl>



<h3>Details</h3>

<p>Subjects with Alzheimer's disease are compared to two different control groups
with respect to smoking history.  The data are given in Salib and Hillier
(1997, Tab. 4).
</p>


<h3>Source</h3>

<p>Salib, E. and Hillier, V.  (1997).  A case-control study of smoking and
Alzheimer's disease.  <em>International Journal of Geriatric Psychiatry</em>
<b>12</b>(3), 295&ndash;300.
<a href="https://doi.org/10.1002/%28SICI%291099-1166%28199703%2912%3A3%3C295%3A%3AAID-GPS476%3E3.0.CO%3B2-3">doi:10.1002/(SICI)1099-1166(199703)12:3&lt;295::AID-GPS476&gt;3.0.CO;2-3</a>
</p>


<h3>References</h3>

<p>Hothorn, T., Hornik, K., van de Wiel, M. A. and Zeileis, A.  (2006).  A Lego
system for conditional inference.  <em>The American Statistician</em>
<b>60</b>(3), 257&ndash;263.  <a href="https://doi.org/10.1198/000313006X118430">doi:10.1198/000313006X118430</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Spineplots
op &lt;- par(no.readonly = TRUE) # save current settings
layout(matrix(1:2, ncol = 2))
spineplot(disease ~ smoking, data = alzheimer,
          subset = gender == "Male", main = "Male")
spineplot(disease ~ smoking, data = alzheimer,
          subset = gender == "Female", main = "Female")
par(op) # reset

## Asymptotic Cochran-Mantel-Haenszel test
cmh_test(disease ~ smoking | gender, data = alzheimer)
</code></pre>

<hr>
<h2 id='asat'>Toxicological Study on Female Wistar Rats</h2><span id='topic+asat'></span>

<h3>Description</h3>

<p>Measurements of the liver enzyme aspartate aminotransferase (ASAT) for a new
compound and a control group of 34 female Wistar rats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asat</code></pre>


<h3>Format</h3>

<p>A data frame with 34 observations on 2 variables.
</p>

<dl>
<dt><code>asat</code></dt><dd>
<p>ASAT values.
</p>
</dd>
<dt><code>group</code></dt><dd>
<p>a factor with levels <code>"Compound"</code> and <code>"Control"</code>.
</p>
</dd>
</dl>



<h3>Details</h3>

<p>The aim of this toxicological study is the proof of safety for the new
compound.  The data were originally given in Hothorn (1992) and later
reproduced by Hauschke, Kieser and Hothorn (1999).
</p>


<h3>Source</h3>

<p>Hauschke, D., Kieser, M. and Hothorn, L. A.  (1999).  Proof of safety in
toxicology based on the ratio of two means for normally distributed data.
<em>Biometrical Journal</em> <b>41</b>(3), 295&ndash;304.
<a href="https://doi.org/10.1002/%28SICI%291521-4036%28199906%2941%3A3%3C295%3A%3AAID-BIMJ295%3E3.0.CO%3B2-2">doi:10.1002/(SICI)1521-4036(199906)41:3&lt;295::AID-BIMJ295&gt;3.0.CO;2-2</a>
</p>
<p>Hothorn, L. A.  (1992).  Biometrische analyse toxikologischer untersuchungen.
In J. Adam (Ed.), <em>Statistisches Know-How in der Medizinischen
Forschung</em>, pp. 475&ndash;590.  Berlin: Ullstein Mosby.
</p>


<h3>References</h3>

<p>Pflüger, R. and Hothorn, T.  (2002).  Assessing equivalence
tests with respect to their expected <code class="reqn">p</code>-value.  <em>Biometrical
Journal</em> <b>44</b>(8), 1015&ndash;1027.  <a href="https://doi.org/10.1002/bimj.200290001">doi:10.1002/bimj.200290001</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Proof-of-safety based on ratio of medians (Pflueger and Hothorn, 2002)
## One-sided exact Wilcoxon-Mann-Whitney test
wt &lt;- wilcox_test(I(log(asat)) ~ group, data = asat,
                  distribution = "exact", alternative = "less",
                  conf.int = TRUE)

## One-sided confidence set
## Note: Safety cannot be concluded since the effect of the compound
##       exceeds 20 % of the control median
exp(confint(wt)$conf.int)
</code></pre>

<hr>
<h2 id='ContingencyTests'>Tests of Independence in Two- or Three-Way Contingency Tables</h2><span id='topic+chisq_test'></span><span id='topic+chisq_test.formula'></span><span id='topic+chisq_test.table'></span><span id='topic+chisq_test.IndependenceProblem'></span><span id='topic+cmh_test'></span><span id='topic+cmh_test.formula'></span><span id='topic+cmh_test.table'></span><span id='topic+cmh_test.IndependenceProblem'></span><span id='topic+lbl_test'></span><span id='topic+lbl_test.formula'></span><span id='topic+lbl_test.table'></span><span id='topic+lbl_test.IndependenceProblem'></span>

<h3>Description</h3>

<p>Testing the independence of two nominal or ordered factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
chisq_test(formula, data, subset = NULL, weights = NULL, ...)
## S3 method for class 'table'
chisq_test(object, ...)
## S3 method for class 'IndependenceProblem'
chisq_test(object, ...)

## S3 method for class 'formula'
cmh_test(formula, data, subset = NULL, weights = NULL, ...)
## S3 method for class 'table'
cmh_test(object, ...)
## S3 method for class 'IndependenceProblem'
cmh_test(object, ...)

## S3 method for class 'formula'
lbl_test(formula, data, subset = NULL, weights = NULL, ...)
## S3 method for class 'table'
lbl_test(object, ...)
## S3 method for class 'IndependenceProblem'
lbl_test(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ContingencyTests_+3A_formula">formula</code></td>
<td>

<p>a formula of the form <code>y ~ x | block</code> where <code>y</code> and <code>x</code> are
factors and <code>block</code> is an optional factor for stratification.
</p>
</td></tr>
<tr><td><code id="ContingencyTests_+3A_data">data</code></td>
<td>

<p>an optional data frame containing the variables in the model formula.
</p>
</td></tr>
<tr><td><code id="ContingencyTests_+3A_subset">subset</code></td>
<td>

<p>an optional vector specifying a subset of observations to be used.  Defaults
to <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="ContingencyTests_+3A_weights">weights</code></td>
<td>

<p>an optional formula of the form <code>~ w</code> defining integer valued case
weights for each observation.  Defaults to <code>NULL</code>, implying equal
weight for all observations.
</p>
</td></tr>
<tr><td><code id="ContingencyTests_+3A_object">object</code></td>
<td>

<p>an object inheriting from classes <code>"table"</code> or
<code>"<a href="#topic+IndependenceProblem-class">IndependenceProblem</a>"</code>.
</p>
</td></tr>
<tr><td><code id="ContingencyTests_+3A_...">...</code></td>
<td>

<p>further arguments to be passed to <code><a href="#topic+independence_test">independence_test</a>()</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>chisq_test()</code>, <code>cmh_test()</code> and <code>lbl_test()</code> provide the
Pearson chi-squared test, the generalized Cochran-Mantel-Haenszel test and the
linear-by-linear association test.  A general description of these methods is
given by Agresti (2002).
</p>
<p>The null hypothesis of independence, or conditional independence given
<code>block</code>, between <code>y</code> and <code>x</code> is tested.
</p>
<p>If <code>y</code> and/or <code>x</code> are ordered factors, the default scores,
<code>1:nlevels(y)</code> and <code>1:nlevels(x)</code>, respectively, can be altered
using the <code>scores</code> argument (see <code><a href="#topic+independence_test">independence_test</a>()</code>); this
argument can also be used to coerce nominal factors to class <code>"ordered"</code>.
(<code>lbl_test()</code> coerces to class <code>"ordered"</code> under any circumstances.)
If both <code>y</code> and <code>x</code> are ordered factors, a linear-by-linear
association test is computed and the direction of the alternative hypothesis
can be specified using the <code>alternative</code> argument.  For the Pearson
chi-squared test, this extension was given by Yates (1948) who also discussed
the situation when either the response or the covariate is an ordered factor;
see also Cochran (1954) and Armitage (1955) for the particular case when
<code>y</code> is a binary factor and <code>x</code> is ordered.  The Mantel-Haenszel
statistic (Mantel and Haenszel, 1959) was similarly extended by Mantel (1963)
and Landis, Heyman and Koch (1978).
</p>
<p>The conditional null distribution of the test statistic is used to obtain
<code class="reqn">p</code>-values and an asymptotic approximation of the exact distribution is
used by default (<code>distribution = "asymptotic"</code>).  Alternatively, the
distribution can be approximated via Monte Carlo resampling or computed
exactly for univariate two-sample problems by setting <code>distribution</code> to
<code>"approximate"</code> or <code>"exact"</code>, respectively.  See
<code><a href="#topic+asymptotic">asymptotic</a>()</code>, <code><a href="#topic+approximate">approximate</a>()</code> and
<code><a href="#topic+exact">exact</a>()</code> for details.
</p>


<h3>Value</h3>

<p>An object inheriting from class <code>"<a href="#topic+IndependenceTest-class">IndependenceTest</a>"</code>.
</p>


<h3>Note</h3>

<p>The exact versions of the Pearson chi-squared test and the generalized
Cochran-Mantel-Haenszel test do not necessarily result in the same
<code class="reqn">p</code>-value as Fisher's exact test (Davis, 1986).
</p>


<h3>References</h3>

<p>Agresti, A.  (2002).  <em>Categorical Data Analysis</em>, Second Edition.
Hoboken, New Jersey: John Wiley &amp; Sons.
</p>
<p>Armitage, P.  (1955).  Tests for linear trends in proportions and frequencies.
<em>Biometrics</em> <b>11</b>(3), 375&ndash;386.  <a href="https://doi.org/10.2307/3001775">doi:10.2307/3001775</a>
</p>
<p>Cochran, W.G.  (1954). Some methods for strengthening the common <code class="reqn">\chi^2</code>
tests.  <em>Biometrics</em> <b>10</b>(4), 417&ndash;451.  <a href="https://doi.org/10.2307/3001616">doi:10.2307/3001616</a>
</p>
<p>Davis, L. J.  (1986).  Exact tests for <code class="reqn">2 \times 2</code> contingency
tables.  <em>The American Statistician</em> <b>40</b>(2), 139&ndash;141.
<a href="https://doi.org/10.1080/00031305.1986.10475377">doi:10.1080/00031305.1986.10475377</a>
</p>
<p>Landis, J. R., Heyman, E. R. and Koch, G. G.  (1978).  Average partial
association in three-way contingency tables: a review and discussion of
alternative tests.  <em>International Statistical Review</em> <b>46</b>(3),
237&ndash;254.  <a href="https://doi.org/10.2307/1402373">doi:10.2307/1402373</a>
</p>
<p>Mantel, N. and Haenszel, W.  (1959).  Statistical aspects of the analysis of
data from retrospective studies of disease.  <em>Journal of the National
Cancer Institute</em> <b>22</b>(4), 719&ndash;748.  <a href="https://doi.org/10.1093/jnci/22.4.719">doi:10.1093/jnci/22.4.719</a>
</p>
<p>Mantel, N.  (1963).  Chi-square tests with one degree of freedom: extensions
of the Mantel-Haenszel procedure.  <em>Journal of the American Statistical
Association</em> <b>58</b>(303), 690&ndash;700.  <a href="https://doi.org/10.1080/01621459.1963.10500879">doi:10.1080/01621459.1963.10500879</a>
</p>
<p>Yates, F.  (1948).  The analysis of contingency tables with groupings based on
quantitative characters.  <em>Biometrika</em> <b>35</b>(1/2), 176&ndash;181.
<a href="https://doi.org/10.1093/biomet/35.1-2.176">doi:10.1093/biomet/35.1-2.176</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example data
## Davis (1986, p. 140)
davis &lt;- matrix(
    c(3,  6,
      2, 19),
    nrow = 2, byrow = TRUE
)
davis &lt;- as.table(davis)

## Asymptotic Pearson chi-squared test
chisq_test(davis)
chisq.test(davis, correct = FALSE) # same as above

## Approximative (Monte Carlo) Pearson chi-squared test
ct &lt;- chisq_test(davis,
                 distribution = approximate(nresample = 10000))
pvalue(ct)             # standard p-value
midpvalue(ct)          # mid-p-value
pvalue_interval(ct)    # p-value interval
size(ct, alpha = 0.05) # test size at alpha = 0.05 using the p-value

## Exact Pearson chi-squared test (Davis, 1986)
## Note: disagrees with Fisher's exact test
ct &lt;- chisq_test(davis,
                 distribution = "exact")
pvalue(ct)             # standard p-value
midpvalue(ct)          # mid-p-value
pvalue_interval(ct)    # p-value interval
size(ct, alpha = 0.05) # test size at alpha = 0.05 using the p-value
fisher.test(davis)


## Laryngeal cancer data
## Agresti (2002, p. 107, Tab. 3.13)
cancer &lt;- matrix(
    c(21, 2,
      15, 3),
    nrow = 2, byrow = TRUE,
    dimnames = list(
        "Treatment" = c("Surgery", "Radiation"),
           "Cancer" = c("Controlled", "Not Controlled")
    )
)
cancer &lt;- as.table(cancer)

## Exact Pearson chi-squared test (Agresti, 2002, p. 108, Tab. 3.14)
## Note: agrees with Fishers's exact test
(ct &lt;- chisq_test(cancer,
                  distribution = "exact"))
midpvalue(ct)          # mid-p-value
pvalue_interval(ct)    # p-value interval
size(ct, alpha = 0.05) # test size at alpha = 0.05 using the p-value
fisher.test(cancer)


## Homework conditions and teacher's rating
## Yates (1948, Tab. 1)
yates &lt;- matrix(
    c(141, 67, 114, 79, 39,
      131, 66, 143, 72, 35,
       36, 14,  38, 28, 16),
    byrow = TRUE, ncol = 5,
    dimnames = list(
           "Rating" = c("A", "B", "C"),
        "Condition" = c("A", "B", "C", "D", "E")
    )
)
yates &lt;- as.table(yates)

## Asymptotic Pearson chi-squared test (Yates, 1948, p. 176)
chisq_test(yates)

## Asymptotic Pearson-Yates chi-squared test (Yates, 1948, pp. 180-181)
## Note: 'Rating' and 'Condition' as ordinal
(ct &lt;- chisq_test(yates,
                  alternative = "less",
                  scores = list("Rating" = c(-1, 0, 1),
                                "Condition" = c(2, 1, 0, -1, -2))))
statistic(ct)^2 # chi^2 = 2.332

## Asymptotic Pearson-Yates chi-squared test (Yates, 1948, p. 181)
## Note: 'Rating' as ordinal
chisq_test(yates,
           scores = list("Rating" = c(-1, 0, 1))) # Q = 3.825


## Change in clinical condition and degree of infiltration
## Cochran (1954, Tab. 6)
cochran &lt;- matrix(
    c(11,  7,
      27, 15,
      42, 16,
      53, 13,
      11,  1),
    byrow = TRUE, ncol = 2,
    dimnames = list(
              "Change" = c("Marked", "Moderate", "Slight",
                           "Stationary", "Worse"),
        "Infiltration" = c("0-7", "8-15")
    )
)
cochran &lt;- as.table(cochran)

## Asymptotic Pearson chi-squared test (Cochran, 1954, p. 435)
chisq_test(cochran) # X^2 = 6.88

## Asymptotic Cochran-Armitage test (Cochran, 1954, p. 436)
## Note: 'Change' as ordinal
(ct &lt;- chisq_test(cochran,
                  scores = list("Change" = c(3, 2, 1, 0, -1))))
statistic(ct)^2 # X^2 = 6.66


## Change in size of ulcer crater for two treatment groups
## Armitage (1955, Tab. 2)
armitage &lt;- matrix(
    c( 6, 4, 10, 12,
      11, 8,  8,  5),
    byrow = TRUE, ncol = 4,
    dimnames = list(
        "Treatment" = c("A", "B"),
           "Crater" = c("Larger", "&lt; 2/3 healed",
                        "&gt;= 2/3 healed", "Healed")
    )
)
armitage &lt;- as.table(armitage)

## Approximative (Monte Carlo) Pearson chi-squared test (Armitage, 1955, p. 379)
chisq_test(armitage,
           distribution = approximate(nresample = 10000)) # chi^2 = 5.91

## Approximative (Monte Carlo) Cochran-Armitage test (Armitage, 1955, p. 379)
(ct &lt;- chisq_test(armitage,
                  distribution = approximate(nresample = 10000),
                  scores = list("Crater" = c(-1.5, -0.5, 0.5, 1.5))))
statistic(ct)^2 # chi_0^2 = 5.26


## Relationship between job satisfaction and income stratified by gender
## Agresti (2002, p. 288, Tab. 7.8)

## Asymptotic generalized Cochran-Mantel-Haenszel test (Agresti, p. 297)
(ct &lt;- cmh_test(jobsatisfaction)) # CMH = 10.2001

## The standardized linear statistic
statistic(ct, type = "standardized")

## The standardized linear statistic for each block
statistic(ct, type = "standardized", partial = TRUE)

## Asymptotic generalized Cochran-Mantel-Haenszel test (Agresti, p. 297)
## Note: 'Job.Satisfaction' as ordinal
cmh_test(jobsatisfaction,
         scores = list("Job.Satisfaction" = c(1, 3, 4, 5))) # L^2 = 9.0342

## Asymptotic linear-by-linear association test (Agresti, p. 297)
## Note: 'Job.Satisfaction' and 'Income' as ordinal
(lt &lt;- lbl_test(jobsatisfaction,
                scores = list("Job.Satisfaction" = c(1, 3, 4, 5),
                              "Income" = c(3, 10, 20, 35))))
statistic(lt)^2 # M^2 = 6.1563

## The standardized linear statistic
statistic(lt, type = "standardized")

## The standardized linear statistic for each block
statistic(lt, type = "standardized", partial = TRUE)
</code></pre>

<hr>
<h2 id='CorrelationTests'>Correlation Tests</h2><span id='topic+spearman_test'></span><span id='topic+spearman_test.formula'></span><span id='topic+spearman_test.IndependenceProblem'></span><span id='topic+fisyat_test'></span><span id='topic+fisyat_test.formula'></span><span id='topic+fisyat_test.IndependenceProblem'></span><span id='topic+quadrant_test'></span><span id='topic+quadrant_test.formula'></span><span id='topic+quadrant_test.IndependenceProblem'></span><span id='topic+koziol_test'></span><span id='topic+koziol_test.formula'></span><span id='topic+koziol_test.IndependenceProblem'></span>

<h3>Description</h3>

<p>Testing the independence of two numeric variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
spearman_test(formula, data, subset = NULL, weights = NULL, ...)
## S3 method for class 'IndependenceProblem'
spearman_test(object, distribution = c("asymptotic", "approximate", "none"), ...)

## S3 method for class 'formula'
fisyat_test(formula, data, subset = NULL, weights = NULL, ...)
## S3 method for class 'IndependenceProblem'
fisyat_test(object, distribution = c("asymptotic", "approximate", "none"),
            ties.method = c("mid-ranks", "average-scores"), ...)

## S3 method for class 'formula'
quadrant_test(formula, data, subset = NULL, weights = NULL, ...)
## S3 method for class 'IndependenceProblem'
quadrant_test(object, distribution = c("asymptotic", "approximate", "none"),
              mid.score = c("0", "0.5", "1"), ...)

## S3 method for class 'formula'
koziol_test(formula, data, subset = NULL, weights = NULL, ...)
## S3 method for class 'IndependenceProblem'
koziol_test(object, distribution = c("asymptotic", "approximate", "none"),
            ties.method = c("mid-ranks", "average-scores"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="CorrelationTests_+3A_formula">formula</code></td>
<td>

<p>a formula of the form <code>y ~ x | block</code> where <code>y</code> and <code>x</code> are
numeric variables and <code>block</code> is an optional factor for stratification.
</p>
</td></tr>
<tr><td><code id="CorrelationTests_+3A_data">data</code></td>
<td>

<p>an optional data frame containing the variables in the model formula.
</p>
</td></tr>
<tr><td><code id="CorrelationTests_+3A_subset">subset</code></td>
<td>

<p>an optional vector specifying a subset of observations to be used.  Defaults
to <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="CorrelationTests_+3A_weights">weights</code></td>
<td>

<p>an optional formula of the form <code>~ w</code> defining integer valued case
weights for each observation.  Defaults to <code>NULL</code>, implying equal
weight for all observations.
</p>
</td></tr>
<tr><td><code id="CorrelationTests_+3A_object">object</code></td>
<td>

<p>an object inheriting from class <code>"<a href="#topic+IndependenceProblem-class">IndependenceProblem</a>"</code>.
</p>
</td></tr>
<tr><td><code id="CorrelationTests_+3A_distribution">distribution</code></td>
<td>

<p>a character, the conditional null distribution of the test statistic can be
approximated by its asymptotic distribution (<code>"asymptotic"</code>, default)
or via Monte Carlo resampling (<code>"approximate"</code>).  Alternatively, the
functions <code><a href="#topic+asymptotic">asymptotic</a></code> or <code><a href="#topic+approximate">approximate</a></code> can be used.
Computation of the null distribution can be suppressed by specifying
<code>"none"</code>.
</p>
</td></tr>
<tr><td><code id="CorrelationTests_+3A_ties.method">ties.method</code></td>
<td>

<p>a character, the method used to handle ties: the score generating function
either uses mid-ranks (<code>"mid-ranks"</code>, default) or averages the scores
of randomly broken ties (<code>"average-scores"</code>).
</p>
</td></tr>
<tr><td><code id="CorrelationTests_+3A_mid.score">mid.score</code></td>
<td>

<p>a character, the score assigned to observations exactly equal to the median:
either 0 (<code>"0"</code>, default), 0.5 (<code>"0.5"</code>) or 1 (<code>"1"</code>); see
<code><a href="#topic+median_test">median_test</a>()</code>.
</p>
</td></tr>
<tr><td><code id="CorrelationTests_+3A_...">...</code></td>
<td>

<p>further arguments to be passed to <code><a href="#topic+independence_test">independence_test</a>()</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>spearman_test()</code>, <code>fisyat_test()</code>, <code>quadrant_test()</code> and
<code>koziol_test()</code> provide the Spearman correlation test, the Fisher-Yates
correlation test using van der Waerden scores, the quadrant test and the
Koziol-Nemec test.  A general description of these methods is given by
Hájek, Šidák and Sen (1999, Sec. 4.6).  The
Koziol-Nemec test was suggested by Koziol and Nemec (1979).  For the
adjustment of scores for tied values see Hájek,
Šidák and Sen (1999, pp. 133&ndash;135).
</p>
<p>The null hypothesis of independence, or conditional independence given
<code>block</code>, between <code>y</code> and <code>x</code> is tested.
</p>
<p>The conditional null distribution of the test statistic is used to obtain
<code class="reqn">p</code>-values and an asymptotic approximation of the exact distribution is
used by default (<code>distribution = "asymptotic"</code>).  Alternatively, the
distribution can be approximated via Monte Carlo resampling by setting
<code>distribution</code> to <code>"approximate"</code>.  See <code><a href="#topic+asymptotic">asymptotic</a>()</code>
and <code><a href="#topic+approximate">approximate</a>()</code> for details.
</p>


<h3>Value</h3>

<p>An object inheriting from class <code>"<a href="#topic+IndependenceTest-class">IndependenceTest</a>"</code>.
</p>


<h3>References</h3>

<p>Hájek, J., Šidák, Z. and Sen, P. K.  (1999).
<em>Theory of Rank Tests</em>, Second Edition.  San Diego: Academic Press.
</p>
<p>Koziol, J. A. and Nemec, A. F.  (1979).  On a Cramér-von Mises
type statistic for testing bivariate independence.  <em>The Canadian Journal
of Statistics</em> <b>7</b>(1), 43&ndash;52.  <a href="https://doi.org/10.2307/3315014">doi:10.2307/3315014</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Asymptotic Spearman test
spearman_test(CONT ~ INTG, data = USJudgeRatings)

## Asymptotic Fisher-Yates test
fisyat_test(CONT ~ INTG, data = USJudgeRatings)

## Asymptotic quadrant test
quadrant_test(CONT ~ INTG, data = USJudgeRatings)

## Asymptotic Koziol-Nemec test
koziol_test(CONT ~ INTG, data = USJudgeRatings)
</code></pre>

<hr>
<h2 id='CWD'>Coarse Woody Debris</h2><span id='topic+CWD'></span>

<h3>Description</h3>

<p>Carbon flux on six pieces of wood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CWD</code></pre>


<h3>Format</h3>

<p>A data frame with 13 observations on 8 variables.
</p>

<dl>
<dt><code>sample2</code></dt><dd>
<p>carbon flux measurement for 2nd piece of wood.
</p>
</dd>
<dt><code>sample3</code></dt><dd>
<p>carbon flux measurement for 3rd piece of wood.
</p>
</dd>
<dt><code>sample4</code></dt><dd>
<p>carbon flux measurement for 4th piece of wood.
</p>
</dd>
<dt><code>sample6</code></dt><dd>
<p>carbon flux measurement for 6th piece of wood.
</p>
</dd>
<dt><code>sample7</code></dt><dd>
<p>carbon flux measurement for 7th piece of wood.
</p>
</dd>
<dt><code>sample8</code></dt><dd>
<p>carbon flux measurement for 8th piece of wood.
</p>
</dd>
<dt><code>trend</code></dt><dd>
<p>measurement day (in days from beginning).
</p>
</dd>
<dt><code>time</code></dt><dd>
<p>date of measurement.
</p>
</dd>
</dl>



<h3>Details</h3>

<p>Coarse woody debris (CWD, dead wood greater than 10 cm in diameter) is
a large stock of carbon in tropical forests, yet the flux of carbon
out of this pool, via respiration, is poorly resolved (Chambers,
Schimel and Nobre, 2001).  The heterotrophic process involved in CWD
respiration should respond to reductions in moisture availability,
which occurs during dry season (Chambers, Schimel and Nobre, 2001).
</p>
<p>CWD respiration measurements were taken in a tropical forest in west French
Guiana, which experiences extreme contrasts in wet and dry season (Bonal
<em>et al.</em>, 2008).  An infrared gas analyzer and a clear chamber sealed to
the wood surface were used to measure the flux of carbon out of the wood
(Stahl <em>et al.</em>, 2011).  Measurements were repeated 13 times, from July
to November 2011, on six pieces of wood during the transition into and out of
the dry season.  The aim is to assess if there were shifts in the CWD
respiration of any of the pieces in response to the transition into (early
August) and out of (late October) the dry season.
</p>
<p>Zeileis and Hothorn (2013) investigated the six-variate series of CO<code class="reqn">_2</code>
reflux, aiming to find out whether the reflux had changed over the sampling
period in at least one of the six wood pieces.
</p>


<h3>Source</h3>

<p>The coarse woody debris respiration data were kindly provided by Lucy Rowland
(School of GeoSciences, University of Edinburgh).
</p>


<h3>References</h3>

<p>Bonal, D., Bosc, A., Ponton, S., Goret, J.-Y., Burban, B., Gross, P.,
Bonnefond, J.-M., Elbers, J., Longdoz, B., Epron, D., Guehl, J.-M. and
Granier, A.  (2008).  Impact of severe dry season on net ecosystem exchange in
the Neotropical rainforest of French Guiana.  <em>Global Change Biology</em>
<b>14</b>(8), 1917&ndash;1933.  <a href="https://doi.org/10.1111/j.1365-2486.2008.01610.x">doi:10.1111/j.1365-2486.2008.01610.x</a>
</p>
<p>Chambers, J. Q., Schimel, J. P. and Nobre, A. D.  (2001).  Respiration from
coarse wood litter in central Amazon forests.  <em>Biogeochemistry</em>
<b>52</b>(2), 115&ndash;131.  <a href="https://doi.org/10.1023/A%3A1006473530673">doi:10.1023/A:1006473530673</a>
</p>
<p>Stahl, C., Burban, B., Goret, J.-Y. and Bonal, D.  (2011).  Seasonal
variations in stem CO<code class="reqn">\mathrm{_2}</code> efflux in the Neotropical rainforest of
French Guiana.  <em>Annals of Forest Science</em> <b>68</b>(4), 771&ndash;782.
<a href="https://doi.org/10.1007/s13595-011-0074-2">doi:10.1007/s13595-011-0074-2</a>
</p>
<p>Zeileis, A. and Hothorn, T.  (2013).  A toolbox of permutation tests for
structural change.  <em>Statistical Papers</em> <b>54</b>(4), 931&ndash;954.
<a href="https://doi.org/10.1007/s00362-013-0503-4">doi:10.1007/s00362-013-0503-4</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Zeileis and Hothorn (2013, pp. 942-944)
## Approximative (Monte Carlo) maximally selected statistics
CWD[1:6] &lt;- 100 * CWD[1:6] # scaling (to avoid harmless warning)
mt &lt;- maxstat_test(sample2 + sample3 + sample4 +
                   sample6 + sample7 + sample8 ~ trend, data = CWD,
                   distribution = approximate(nresample = 100000))

## Absolute maximum of standardized statistics (t = 3.08)
statistic(mt)

## 5% critical value (t_0.05 = 2.86)
(c &lt;- qperm(mt, 0.95))

## Only 'sample8' exceeds the 5% critical value
sts &lt;- statistic(mt, type = "standardized")
idx &lt;- which(sts &gt; c, arr.ind = TRUE)
sts[unique(idx[, 1]), unique(idx[, 2]), drop = FALSE]
</code></pre>

<hr>
<h2 id='expectation-methods'>Extraction of the Expectation, Variance and Covariance of the Linear
Statistic</h2><span id='topic+expectation'></span><span id='topic+expectation-methods'></span><span id='topic+expectation+2CIndependenceLinearStatistic-method'></span><span id='topic+expectation+2CIndependenceTest-method'></span><span id='topic+variance'></span><span id='topic+variance-methods'></span><span id='topic+variance+2CVariance-method'></span><span id='topic+variance+2CCovarianceMatrix-method'></span><span id='topic+variance+2CIndependenceLinearStatistic-method'></span><span id='topic+variance+2CIndependenceTest-method'></span><span id='topic+covariance'></span><span id='topic+covariance-methods'></span><span id='topic+covariance+2CCovarianceMatrix-method'></span><span id='topic+covariance+2CIndependenceLinearStatistic-method'></span><span id='topic+covariance+2CQuadTypeIndependenceTestStatistic-method'></span><span id='topic+covariance+2CIndependenceTest-method'></span>

<h3>Description</h3>

<p>Methods for extraction of the expectation, variance and covariance of the
linear statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'IndependenceLinearStatistic'
expectation(object, partial = FALSE, ...)
## S4 method for signature 'IndependenceTest'
expectation(object, partial = FALSE, ...)

## S4 method for signature 'Variance'
variance(object, ...)
## S4 method for signature 'CovarianceMatrix'
variance(object, ...)
## S4 method for signature 'IndependenceLinearStatistic'
variance(object, partial = FALSE, ...)
## S4 method for signature 'IndependenceTest'
variance(object, partial = FALSE, ...)

## S4 method for signature 'CovarianceMatrix'
covariance(object, ...)
## S4 method for signature 'IndependenceLinearStatistic'
covariance(object, invert = FALSE, partial = FALSE, ...)
## S4 method for signature 'QuadTypeIndependenceTestStatistic'
covariance(object, invert = FALSE, partial = FALSE, ...)
## S4 method for signature 'IndependenceTest'
covariance(object, invert = FALSE, partial = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="expectation-methods_+3A_object">object</code></td>
<td>

<p>an object from which the expectation, variance or covariance of the linear
statistic can be extracted.
</p>
</td></tr>
<tr><td><code id="expectation-methods_+3A_partial">partial</code></td>
<td>

<p>a logical indicating that the partial result for each block should be
extracted.  Defaults to <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="expectation-methods_+3A_invert">invert</code></td>
<td>

<p>a logical indicating that the Moore-Penrose inverse of the covariance should
be extracted.  Defaults to <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="expectation-methods_+3A_...">...</code></td>
<td>

<p>further arguments (currently ignored).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The methods <code>expectation</code>, <code>variance</code> and <code>covariance</code> extract
the expectation, variance and covariance, respectively, of the linear
statistic.
</p>
<p>For tests of conditional independence within blocks, the partial result for
each block is obtained by setting <code>partial = TRUE</code>.
</p>


<h3>Value</h3>

<p>The expectation, variance or covariance of the linear statistic extracted from
<code>object</code>.  A matrix or array.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example data
dta &lt;- data.frame(
    y = gl(3, 2),
    x = sample(gl(3, 2))
)

## Asymptotic Cochran-Mantel-Haenszel Test
ct &lt;- cmh_test(y ~ x, data = dta)

## The linear statistic, i.e., the contingency table...
(T &lt;- statistic(ct, type = "linear"))

## ...and its expectation...
(mu &lt;- expectation(ct))

## ...and variance...
(sigma &lt;- variance(ct))

## ...and covariance...
(Sigma &lt;- covariance(ct))

## ...and its inverse
(SigmaPlus &lt;- covariance(ct, invert = TRUE))

## The standardized contingency table...
(T - mu) / sqrt(sigma)

## ...is identical to the standardized linear statistic
statistic(ct, type = "standardized")

## The quadratic form...
U &lt;- as.vector(T - mu)
U %*% SigmaPlus %*% U

## ...is identical to the test statistic
statistic(ct, type = "test")
</code></pre>

<hr>
<h2 id='glioma'>Malignant Glioma Pilot Study</h2><span id='topic+glioma'></span>

<h3>Description</h3>

<p>A non-randomized pilot study on malignant glioma patients with pretargeted
adjuvant radioimmunotherapy using yttrium-90-biotin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glioma</code></pre>


<h3>Format</h3>

<p>A data frame with 37 observations on 7 variables.
</p>

<dl>
<dt><code>no.</code></dt><dd>
<p>patient number.
</p>
</dd>
<dt><code>age</code></dt><dd>
<p>patient age (years).
</p>
</dd>
<dt><code>sex</code></dt><dd>
<p>a factor with levels <code>"F"</code> (Female) and <code>"M"</code> (Male).
</p>
</dd>
<dt><code>histology</code></dt><dd>
<p>a factor with levels <code>"GBM"</code> (grade IV) and <code>"Grade3"</code> (grade
III).
</p>
</dd>
<dt><code>group</code></dt><dd>
<p>a factor with levels <code>"Control"</code> and <code>"RIT"</code>.
</p>
</dd>
<dt><code>event</code></dt><dd>
<p>status indicator for <code>time</code>: <code>FALSE</code> for right-censored
observations and <code>TRUE</code> otherwise.
</p>
</dd>
<dt><code>time</code></dt><dd>
<p>survival time (months).
</p>
</dd>
</dl>



<h3>Details</h3>

<p>The primary endpoint of this small pilot study is survival.  Since the
survival times are tied, the classical asymptotic logrank test may be
inadequate in this setup.  Therefore, a permutation test using Monte Carlo
resampling was computed in the original paper.  The data are taken from Tables
1 and 2 of Grana <em>et al.</em> (2002).
</p>


<h3>Source</h3>

<p>Grana, C., Chinol, M., Robertson, C., Mazzetta, C., Bartolomei, M., De Cicco,
C., Fiorenza, M., Gatti, M., Caliceti, P. and Paganelli, G.  (2002).
Pretargeted adjuvant radioimmunotherapy with Yttrium-90-biotin in malignant
glioma patients: A pilot study.  <em>British Journal of Cancer</em>
<b>86</b>(2), 207&ndash;212.  <a href="https://doi.org/10.1038/sj.bjc.6600047">doi:10.1038/sj.bjc.6600047</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Grade III glioma
g3 &lt;- subset(glioma, histology == "Grade3")

## Plot Kaplan-Meier estimates
op &lt;- par(no.readonly = TRUE) # save current settings
layout(matrix(1:2, ncol = 2))
plot(survfit(Surv(time, event) ~ group, data = g3),
     main = "Grade III Glioma", lty = 2:1,
     ylab = "Probability", xlab = "Survival Time in Month",
     xlim = c(-2, 72))
legend("bottomleft", lty = 2:1, c("Control", "Treated"), bty = "n")

## Exact logrank test
logrank_test(Surv(time, event) ~ group, data = g3,
             distribution = "exact")


## Grade IV glioma
gbm &lt;- subset(glioma, histology == "GBM")

## Plot Kaplan-Meier estimates
plot(survfit(Surv(time, event) ~ group, data = gbm),
     main = "Grade IV Glioma", lty = 2:1,
     ylab = "Probability", xlab = "Survival Time in Month",
     xlim = c(-2, 72))
legend("topright", lty = 2:1, c("Control", "Treated"), bty = "n")
par(op) # reset

## Exact logrank test
logrank_test(Surv(time, event) ~ group, data = gbm,
             distribution = "exact")


## Stratified approximative (Monte Carlo) logrank test
logrank_test(Surv(time, event) ~ group | histology, data = glioma,
             distribution = approximate(nresample = 10000))
</code></pre>

<hr>
<h2 id='GTSG'>Gastrointestinal Tumor Study Group</h2><span id='topic+GTSG'></span>

<h3>Description</h3>

<p>A randomized clinical trial in gastric cancer.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GTSG</code></pre>


<h3>Format</h3>

<p>A data frame with 90 observations on 3 variables.
</p>

<dl>
<dt><code>time</code></dt><dd>
<p>survival time (days).
</p>
</dd>
<dt><code>event</code></dt><dd>
<p>status indicator for <code>time</code>: <code>0</code> for right-censored observations
and <code>1</code> otherwise.
</p>
</dd>
<dt><code>group</code></dt><dd>
<p>a factor with levels <code>"Chemotherapy+Radiation"</code> and
<code>"Chemotherapy"</code>.
</p>
</dd>
</dl>



<h3>Details</h3>

<p>A clinical trial comparing chemotherapy alone versus a combination of
chemotherapy and radiation therapy in the treatment of locally advanced,
nonresectable gastric carcinoma.
</p>


<h3>Note</h3>

<p>There is substantial separation between the estimated survival distributions
at 8 to 10 months, but by month 26 the distributions intersect.
</p>


<h3>Source</h3>

<p>Stablein, D. M., Carter, W. H., Jr. and Novak, J. W.  (1981).  Analysis of
survival data with nonproportional hazard functions.  <em>Controlled
Clinical Trials</em> <b>2</b>(2), 149&ndash;159.  <a href="https://doi.org/10.1016/0197-2456%2881%2990005-2">doi:10.1016/0197-2456(81)90005-2</a>
</p>


<h3>References</h3>

<p>Moreau, T., Maccario, J., Lellouch, J. and Huber, C.  (1992).  Weighted log
rank statistics for comparing two distributions.  <em>Biometrika</em>
<b>79</b>(1), 195&ndash;198.  <a href="https://doi.org/10.1093/biomet/79.1.195">doi:10.1093/biomet/79.1.195</a>
</p>
<p>Shen, W. and Le, C. T.  (2000).  Linear rank tests for censored survival data.
<em>Communications in Statistics &ndash; Simulation and Computation</em>
<b>29</b>(1), 21&ndash;36.  <a href="https://doi.org/10.1080/03610910008813599">doi:10.1080/03610910008813599</a>
</p>
<p>Tubert-Bitter, P., Kramar, A., Chalé, J. J. and Moureau, T.
(1994).  Linear rank tests for comparing survival in two groups with crossing
hazards.  <em>Computational Statistics &amp; Data Analysis</em> <b>18</b>(5),
547&ndash;559.  <a href="https://doi.org/10.1016/0167-9473%2894%2990084-1">doi:10.1016/0167-9473(94)90084-1</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Plot Kaplan-Meier estimates
plot(survfit(Surv(time / (365.25 / 12), event) ~ group, data = GTSG),
     lty = 1:2, ylab = "% Survival", xlab = "Survival Time in Months")
legend("topright", lty = 1:2,
       c("Chemotherapy+Radiation", "Chemotherapy"), bty = "n")

## Asymptotic logrank test
logrank_test(Surv(time, event) ~ group, data = GTSG)

## Asymptotic Prentice test
logrank_test(Surv(time, event) ~ group, data = GTSG, type = "Prentice")

## Asymptotic test against Weibull-type alternatives (Moreau et al., 1992)
moreau_weight &lt;- function(time, n.risk, n.event)
    1 + log(-log(cumprod(n.risk / (n.risk + n.event))))

independence_test(Surv(time, event) ~ group, data = GTSG,
                  ytrafo = function(data)
                      trafo(data, surv_trafo = function(y)
                          logrank_trafo(y, weight = moreau_weight)))

## Asymptotic test against crossing-curve alternatives (Shen and Le, 2000)
shen_trafo &lt;- function(x)
    ansari_trafo(logrank_trafo(x, type = "Prentice"))

independence_test(Surv(time, event) ~ group, data = GTSG,
                  ytrafo = function(data)
                      trafo(data, surv_trafo = shen_trafo))
</code></pre>

<hr>
<h2 id='hohnloser'>Left Ventricular Ejection Fraction</h2><span id='topic+hohnloser'></span>

<h3>Description</h3>

<p>Left ventricular ejection fraction in patients with malignant ventricular
tachyarrhythmias including recurrence-free month and censoring.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hohnloser</code></pre>


<h3>Format</h3>

<p>A data frame with 94 observations on 3 variables.
</p>

<dl>
<dt><code>EF</code></dt><dd>
<p>ejection fraction (%).
</p>
</dd>
<dt><code>time</code></dt><dd>
<p>recurrence-free month.
</p>
</dd>
<dt><code>event</code></dt><dd>
<p>status indicator for <code>time</code>: <code>0</code> for right-censored observations
and <code>1</code> otherwise.
</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data was used by Lausen and Schumacher (1992) to illustrate the use of
maximally selected statistics.
</p>


<h3>Source</h3>

<p>Hohnloser, S. H., Raeder, E. A., Podrid, P. J., Graboys, T. B. and Lown, B.
(1987).  Predictors of antiarrhythmic drug efficacy in patients with malignant
ventricular tachyarrhythmias.  <em>American Heart Journal</em> <b>114</b>(1 Pt
1), 1&ndash;7.  <a href="https://doi.org/10.1016/0002-8703%2887%2990299-7">doi:10.1016/0002-8703(87)90299-7</a>
</p>


<h3>References</h3>

<p>Lausen, B. and Schumacher, M.  (1992).  Maximally selected rank statistics.
<em>Biometrics</em> <b>48</b>(1), 73&ndash;85.  <a href="https://doi.org/10.2307/2532740">doi:10.2307/2532740</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Asymptotic maximally selected logrank statistics
maxstat_test(Surv(time, event) ~ EF, data = hohnloser)
</code></pre>

<hr>
<h2 id='IndependenceLinearStatistic-class'>Class <code>"IndependenceLinearStatistic"</code></h2><span id='topic+IndependenceLinearStatistic-class'></span><span id='topic+initialize+2CIndependenceLinearStatistic-method'></span>

<h3>Description</h3>

<p>Objects of class <code>"IndependenceLinearStatistic"</code> represent the linear
statistic and the transformed and original data structures corresponding to an
independence problem.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form </p>
<pre>     new("IndependenceLinearStatistic", object, ...)</pre>
<p>where <code>object</code> is an object of class
<code>"<a href="#topic+IndependenceTestProblem-class">IndependenceTestProblem</a>"</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>linearstatistic</code>:</dt><dd>
<p>Object of class <code>"matrix"</code>.  The linear statistic for each block.
</p>
</dd>
<dt><code>expectation</code>:</dt><dd>
<p>Object of class <code>"matrix"</code>.  The expectation of the linear statistic
for each block.
</p>
</dd>
<dt><code>covariance</code>:</dt><dd>
<p>Object of class <code>"matrix"</code>.  The lower triangular elements of the
covariance of the linear statistic for each block.
</p>
</dd>
<dt><code>xtrans</code>:</dt><dd>
<p>Object of class <code>"matrix"</code>.  The transformed <code>x</code>.
</p>
</dd>
<dt><code>ytrans</code>:</dt><dd>
<p>Object of class <code>"matrix"</code>.  The transformed <code>y</code>.
</p>
</dd>
<dt><code>xtrafo</code>:</dt><dd>
<p>Object of class <code>"function"</code>.  The regression function for <code>x</code>.
</p>
</dd>
<dt><code>ytrafo</code>:</dt><dd>
<p>Object of class <code>"function"</code>.  The influence function for <code>y</code>.
</p>
</dd>
<dt><code>x</code>:</dt><dd>
<p>Object of class <code>"data.frame"</code>.  The variables <code>x</code>.
</p>
</dd>
<dt><code>y</code>:</dt><dd>
<p>Object of class <code>"data.frame"</code>.  The variables <code>y</code>.
</p>
</dd>
<dt><code>block</code>:</dt><dd>
<p>Object of class <code>"factor"</code>.  The block structure.
</p>
</dd>
<dt><code>weights</code>:</dt><dd>
<p>Object of class <code>"numeric"</code>.  The case weights.
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+IndependenceTestProblem-class">IndependenceTestProblem</a>"</code>, directly. <br />
Class <code>"<a href="#topic+IndependenceProblem-class">IndependenceProblem</a>"</code>, by class
<code>"<a href="#topic+IndependenceTestProblem-class">IndependenceTestProblem</a>"</code>, distance 2.
</p>


<h3>Known Subclasses</h3>

<p>Class <code>"<a href="#topic+IndependenceTestStatistic-class">IndependenceTestStatistic</a>"</code>, directly.<br />
Class <code>"<a href="#topic+MaxTypeIndependenceTestStatistic-class">MaxTypeIndependenceTestStatistic</a>"</code>, by class
<code>"<a href="#topic+IndependenceTestStatistic-class">IndependenceTestStatistic</a>"</code>, distance 2. <br />
Class <code>"<a href="#topic+QuadTypeIndependenceTestStatistic-class">QuadTypeIndependenceTestStatistic</a>"</code>, by class
<code>"<a href="#topic+IndependenceTestStatistic-class">IndependenceTestStatistic</a>"</code>, distance 2. <br />
Class <code>"<a href="#topic+ScalarIndependenceTestStatistic-class">ScalarIndependenceTestStatistic</a>"</code>, by class
<code>"<a href="#topic+IndependenceTestStatistic-class">IndependenceTestStatistic</a>"</code>, distance 2.
</p>


<h3>Methods</h3>


<dl>
<dt>covariance</dt><dd>
<p><code>signature(object = "IndependenceLinearStatistic")</code>: See the
documentation for <code><a href="#topic+covariance">covariance</a>()</code> for details.
</p>
</dd>
<dt>expectation</dt><dd>
<p><code>signature(object = "IndependenceLinearStatistic")</code>: See the
documentation for <code><a href="#topic+expectation">expectation</a>()</code> for details.
</p>
</dd>
<dt>initialize</dt><dd>
<p><code>signature(.Object = "IndependenceLinearStatistic")</code>: See the
documentation for <code><a href="methods.html#topic+new">initialize</a>()</code> (in package
<span class="pkg">methods</span>) for details.
</p>
</dd>
<dt>statistic</dt><dd>
<p><code>signature(object = "IndependenceLinearStatistic")</code>: See the
documentation for <code><a href="#topic+statistic">statistic</a>()</code> for details.
</p>
</dd>
<dt>variance</dt><dd>
<p><code>signature(object = "IndependenceLinearStatistic")</code>: See the
documentation for <code><a href="#topic+variance">variance</a>()</code> for details.
</p>
</dd>
</dl>


<hr>
<h2 id='IndependenceProblem-class'>Class <code>"IndependenceProblem"</code></h2><span id='topic+IndependenceProblem-class'></span><span id='topic+initialize+2CIndependenceProblem-method'></span>

<h3>Description</h3>

<p>Objects of class <code>"IndependenceProblem"</code> represent the data structure
corresponding to an independence problem.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form </p>
<pre>     new("IndependenceProblem", x, y, block = NULL, weights = NULL, ...)</pre>
<p>where <code>x</code> and <code>y</code> are data frames containing the variables
<code class="reqn">\mathbf{X}</code> and <code class="reqn">\mathbf{Y}</code>, respectively, <code>block</code> is an
optional factor representing the block structure <code class="reqn">b</code> and <code>weights</code> is
an optional integer vector corresponding to the case weights <code class="reqn">w</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>x</code>:</dt><dd>
<p>Object of class <code>"data.frame"</code>.  The variables <code>x</code>.
</p>
</dd>
<dt><code>y</code>:</dt><dd>
<p>Object of class <code>"data.frame"</code>.  The variables <code>y</code>.
</p>
</dd>
<dt><code>block</code>:</dt><dd>
<p>Object of class <code>"factor"</code>.  The block structure.
</p>
</dd>
<dt><code>weights</code>:</dt><dd>
<p>Object of class <code>"numeric"</code>.  The case weights.
</p>
</dd>
</dl>



<h3>Known Subclasses</h3>

<p>Class <code>"<a href="#topic+IndependenceTestProblem-class">IndependenceTestProblem</a>"</code>, directly. <br />
Class <code>"<a href="#topic+SymmetryProblem-class">SymmetryProblem</a>"</code>, directly. <br />
Class <code>"<a href="#topic+IndependenceLinearStatistic-class">IndependenceLinearStatistic</a>"</code>, by class
<code>"<a href="#topic+IndependenceTestProblem-class">IndependenceTestProblem</a>"</code>, distance 2. <br />
Class <code>"<a href="#topic+IndependenceTestStatistic-class">IndependenceTestStatistic</a>"</code>, by class
<code>"<a href="#topic+IndependenceTestProblem-class">IndependenceTestProblem</a>"</code>, distance 3. <br />
Class <code>"<a href="#topic+MaxTypeIndependenceTestStatistic-class">MaxTypeIndependenceTestStatistic</a>"</code>, by class
<code>"<a href="#topic+IndependenceTestProblem-class">IndependenceTestProblem</a>"</code>, distance 4. <br />
Class <code>"<a href="#topic+QuadTypeIndependenceTestStatistic-class">QuadTypeIndependenceTestStatistic</a>"</code>, by class
<code>"<a href="#topic+IndependenceTestProblem-class">IndependenceTestProblem</a>"</code>, distance 4. <br />
Class <code>"<a href="#topic+ScalarIndependenceTestStatistic-class">ScalarIndependenceTestStatistic</a>"</code>, by class
<code>"<a href="#topic+IndependenceTestProblem-class">IndependenceTestProblem</a>"</code>, distance 4.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd>
<p><code>signature(.Object = "IndependenceProblem")</code>: See the documentation
for <code><a href="methods.html#topic+new">initialize</a>()</code> (in package <span class="pkg">methods</span>) for
details.
</p>
</dd>
</dl>


<hr>
<h2 id='IndependenceTest'>General Independence Test</h2><span id='topic+independence_test'></span><span id='topic+independence_test.formula'></span><span id='topic+independence_test.table'></span><span id='topic+independence_test.IndependenceProblem'></span>

<h3>Description</h3>

<p>Testing the independence of two sets of variables measured on arbitrary scales.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
independence_test(formula, data, subset = NULL, weights = NULL, ...)
## S3 method for class 'table'
independence_test(object, ...)
## S3 method for class 'IndependenceProblem'
independence_test(object, teststat = c("maximum", "quadratic", "scalar"),
                  distribution = c("asymptotic", "approximate",
                                   "exact", "none"),
                  alternative = c("two.sided", "less", "greater"),
                  xtrafo = trafo, ytrafo = trafo, scores = NULL,
                  check = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IndependenceTest_+3A_formula">formula</code></td>
<td>

<p>a formula of the form <code>y1 + ... + yq ~ x1 + ... + xp | block</code> where
<code>y1</code>, ..., <code>yq</code> and <code>x1</code>, ..., <code>xp</code> are measured
on arbitrary scales (nominal, ordinal or continuous with or without
censoring) and <code>block</code> is an optional factor for stratification.
</p>
</td></tr>
<tr><td><code id="IndependenceTest_+3A_data">data</code></td>
<td>

<p>an optional data frame containing the variables in the model formula.
</p>
</td></tr>
<tr><td><code id="IndependenceTest_+3A_subset">subset</code></td>
<td>

<p>an optional vector specifying a subset of observations to be used.  Defaults
to <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="IndependenceTest_+3A_weights">weights</code></td>
<td>

<p>an optional formula of the form <code>~ w</code> defining integer valued case
weights for each observation.  Defaults to <code>NULL</code>, implying equal
weight for all observations.
</p>
</td></tr>
<tr><td><code id="IndependenceTest_+3A_object">object</code></td>
<td>

<p>an object inheriting from classes <code>"table"</code> or
<code>"<a href="#topic+IndependenceProblem-class">IndependenceProblem</a>"</code>.
</p>
</td></tr>
<tr><td><code id="IndependenceTest_+3A_teststat">teststat</code></td>
<td>

<p>a character, the type of test statistic to be applied: either a maximum
statistic (<code>"maximum"</code>, default), a quadratic form (<code>"quadratic"</code>)
or a standardized scalar test statistic (<code>"scalar"</code>).
</p>
</td></tr>
<tr><td><code id="IndependenceTest_+3A_distribution">distribution</code></td>
<td>

<p>a character, the conditional null distribution of the test statistic can be
approximated by its asymptotic distribution (<code>"asymptotic"</code>, default)
or via Monte Carlo resampling (<code>"approximate"</code>).  Alternatively, the
functions <code><a href="#topic+asymptotic">asymptotic</a></code> or <code><a href="#topic+approximate">approximate</a></code> can be used.
For univariate two-sample problems, <code>"exact"</code> or use of the function
<code><a href="#topic+exact">exact</a></code> computes the exact distribution.  Computation of the
null distribution can be suppressed by specifying <code>"none"</code>.  It is also
possible to specify a function with one argument (an object inheriting from
<code>"<a href="#topic+IndependenceTestStatistic-class">IndependenceTestStatistic</a>"</code>) that returns an object of
class <code>"<a href="#topic+NullDistribution-class">NullDistribution</a>"</code>.
</p>
</td></tr>
<tr><td><code id="IndependenceTest_+3A_alternative">alternative</code></td>
<td>

<p>a character, the alternative hypothesis: either <code>"two.sided"</code>
(default), <code>"greater"</code> or <code>"less"</code>.
</p>
</td></tr>
<tr><td><code id="IndependenceTest_+3A_xtrafo">xtrafo</code></td>
<td>

<p>a function of transformations to be applied to the variables <code>x1</code>,
..., <code>xp</code> supplied in <code>formula</code>; see &lsquo;Details&rsquo;.
Defaults to <code><a href="#topic+trafo">trafo</a>()</code>.
</p>
</td></tr>
<tr><td><code id="IndependenceTest_+3A_ytrafo">ytrafo</code></td>
<td>

<p>a function of transformations to be applied to the variables <code>y1</code>,
..., <code>yq</code> supplied in <code>formula</code>; see &lsquo;Details&rsquo;.
Defaults to <code><a href="#topic+trafo">trafo</a>()</code>.
</p>
</td></tr>
<tr><td><code id="IndependenceTest_+3A_scores">scores</code></td>
<td>

<p>a named list of scores to be attached to ordered factors; see
&lsquo;Details&rsquo;.  Defaults to <code>NULL</code>, implying equally spaced scores.
</p>
</td></tr>
<tr><td><code id="IndependenceTest_+3A_check">check</code></td>
<td>

<p>a function to be applied to objects of class
<code>"<a href="#topic+IndependenceTest-class">IndependenceTest</a>"</code> in order to check for specific
properties of the data.  Defaults to <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="IndependenceTest_+3A_...">...</code></td>
<td>

<p>further arguments to be passed to or from other methods (currently ignored).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>independence_test()</code> provides a general independence test for two sets
of variables measured on arbitrary scales.  This function is based on the
general framework for conditional inference procedures proposed by Strasser
and Weber (1999).  The salient parts of the Strasser-Weber framework are
elucidated by Hothorn <em>et al.</em> (2006) and a thorough description of the
software implementation is given by Hothorn <em>et al.</em> (2008).
</p>
<p>The null hypothesis of independence, or conditional independence given
<code>block</code>, between <code>y1</code>, ..., <code>yq</code> and <code>x1</code>, ...,
<code>xp</code> is tested.
</p>
<p>A vector of case weights, e.g., observation counts, can be supplied through
the <code>weights</code> argument and the type of test statistic is specified by the
<code>teststat</code> argument.  Influence and regression functions, i.e.,
transformations of <code>y1</code>, ..., <code>yq</code> and <code>x1</code>, ...,
<code>xp</code>, are specified by the <code>ytrafo</code> and <code>xtrafo</code> arguments,
respectively; see <code><a href="#topic+trafo">trafo</a>()</code> for the collection of transformation
functions currently available.  This allows for implementation of both novel
and familiar test statistics, e.g., the Pearson <code class="reqn">\chi^2</code> test, the
generalized Cochran-Mantel-Haenszel test, the Spearman correlation test, the
Fisher-Pitman permutation test, the Wilcoxon-Mann-Whitney test, the
Kruskal-Wallis test and the family of weighted logrank tests for censored
data.  Furthermore, multivariate extensions such as the multivariate
Kruskal-Wallis test (Puri and Sen, 1966, 1971) can be implemented without much
effort (see &lsquo;Examples&rsquo;).
</p>
<p>If, say, <code>y1</code> and/or <code>x1</code> are ordered factors, the default scores,
<code>1:nlevels(y1)</code> and <code>1:nlevels(x1)</code>, respectively, can be altered
using the <code>scores</code> argument; this argument can also be used to coerce
nominal factors to class <code>"ordered"</code>.  For example, when <code>y1</code> is an
ordered factor with four levels and <code>x1</code> is a nominal factor with three
levels, <code>scores = list(y1 = c(1, 3:5), x1 = c(1:2, 4))</code> supplies the
scores to be used.  For ordered alternatives the scores must be monotonic, but
non-monotonic scores are also allowed for testing against, e.g., umbrella
alternatives.  The length of the score vector must be equal to the number of
factor levels.
</p>
<p>The conditional null distribution of the test statistic is used to obtain
<code class="reqn">p</code>-values and an asymptotic approximation of the exact distribution is
used by default (<code>distribution = "asymptotic"</code>).  Alternatively, the
distribution can be approximated via Monte Carlo resampling or computed
exactly for univariate two-sample problems by setting <code>distribution</code> to
<code>"approximate"</code> or <code>"exact"</code>, respectively.  See
<code><a href="#topic+asymptotic">asymptotic</a>()</code>, <code><a href="#topic+approximate">approximate</a>()</code> and
<code><a href="#topic+exact">exact</a>()</code> for details.
</p>


<h3>Value</h3>

<p>An object inheriting from class <code>"<a href="#topic+IndependenceTest-class">IndependenceTest</a>"</code>.
</p>


<h3>Note</h3>

<p>Starting with <span class="pkg">coin</span> version 1.1-0, maximum statistics and quadratic forms
can no longer be specified using <code>teststat = "maxtype"</code> and
<code>teststat = "quadtype"</code>, respectively (as was used in versions prior to
0.4-5).
</p>


<h3>References</h3>

<p>Hothorn, T., Hornik, K., van de Wiel, M. A. and Zeileis, A.  (2006).  A Lego
system for conditional inference.  <em>The American Statistician</em>
<b>60</b>(3), 257&ndash;263.  <a href="https://doi.org/10.1198/000313006X118430">doi:10.1198/000313006X118430</a>
</p>
<p>Hothorn, T., Hornik, K., van de Wiel, M. A. and Zeileis, A.  (2008).
Implementing a class of permutation tests: The coin package.  <em>Journal of
Statistical Software</em> <b>28</b>(8), 1&ndash;23.  <a href="https://doi.org/10.18637/jss.v028.i08">doi:10.18637/jss.v028.i08</a>
</p>
<p>Johnson, W. D., Mercante, D. E. and May, W. L.  (1993).  A computer package
for the multivariate nonparametric rank test in completely randomized
experimental designs.  <em>Computer Methods and Programs in Biomedicine</em>
<b>40</b>(3), 217&ndash;225.  <a href="https://doi.org/10.1016/0169-2607%2893%2990059-T">doi:10.1016/0169-2607(93)90059-T</a>
</p>
<p>Puri, M. L. and Sen, P. K.  (1966).  On a class of multivariate multisample
rank order tests.  <em>Sankhya</em> A <b>28</b>(4), 353&ndash;376.
</p>
<p>Puri, M. L. and Sen, P. K.  (1971).  <em>Nonparametric Methods in
Multivariate Analysis</em>.  New York: John Wiley &amp; Sons.
</p>
<p>Strasser, H. and Weber, C.  (1999).  On the asymptotic theory of permutation
statistics.  <em>Mathematical Methods of Statistics</em> <b>8</b>(2), 220&ndash;250.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## One-sided exact van der Waerden (normal scores) test...
independence_test(asat ~ group, data = asat,
                  ## exact null distribution
                  distribution = "exact",
                  ## one-sided test
                  alternative = "greater",
                  ## apply normal scores to asat$asat
                  ytrafo = function(data)
                      trafo(data, numeric_trafo = normal_trafo),
                  ## indicator matrix of 1st level of asat$group
                  xtrafo = function(data)
                      trafo(data, factor_trafo = function(x)
                          matrix(x == levels(x)[1], ncol = 1)))

## ...or more conveniently
normal_test(asat ~ group, data = asat,
            ## exact null distribution
            distribution = "exact",
            ## one-sided test
            alternative = "greater")


## Receptor binding assay of benzodiazepines
## Johnson, Mercante and May (1993, Tab. 1)
benzos &lt;- data.frame(
      cerebellum = c( 3.41,  3.50,  2.85,  4.43,
                      4.04,  7.40,  5.63, 12.86,
                      6.03,  6.08,  5.75,  8.09,  7.56),
       brainstem = c( 3.46,  2.73,  2.22,  3.16,
                      2.59,  4.18,  3.10,  4.49,
                      6.78,  7.54,  5.29,  4.57,  5.39),
          cortex = c(10.52,  7.52,  4.57,  5.48,
                      7.16, 12.00,  9.36,  9.35,
                     11.54, 11.05,  9.92, 13.59, 13.21),
    hypothalamus = c(19.51, 10.00,  8.27, 10.26,
                     11.43, 19.13, 14.03, 15.59,
                     24.87, 14.16, 22.68, 19.93, 29.32),
        striatum = c( 6.98,  5.07,  3.57,  5.34,
                      4.57,  8.82,  5.76, 11.72,
                      6.98,  7.54,  7.66,  9.69,  8.09),
     hippocampus = c(20.31, 13.20,  8.58, 11.42,
                     13.79, 23.71, 18.35, 38.52,
                     21.56, 18.66, 19.24, 27.39, 26.55),
       treatment = factor(rep(c("Lorazepam", "Alprazolam", "Saline"),
                          c(4, 4, 5)))
)

## Approximative (Monte Carlo) multivariate Kruskal-Wallis test
## Johnson, Mercante and May (1993, Tab. 2)
independence_test(cerebellum + brainstem + cortex +
                  hypothalamus + striatum + hippocampus ~ treatment,
                  data = benzos,
                  teststat = "quadratic",
                  distribution = approximate(nresample = 10000),
                  ytrafo = function(data)
                      trafo(data, numeric_trafo = rank_trafo)) # Q = 16.129
</code></pre>

<hr>
<h2 id='IndependenceTest-class'>Class <code>"IndependenceTest"</code> and Its Subclasses</h2><span id='topic+IndependenceTest-class'></span><span id='topic+MaxTypeIndependenceTest-class'></span><span id='topic+QuadTypeIndependenceTest-class'></span><span id='topic+ScalarIndependenceTest-class'></span><span id='topic+ScalarIndependenceTestConfint-class'></span><span id='topic+confint+2CIndependenceTest-method'></span><span id='topic+confint+2CScalarIndependenceTestConfint-method'></span><span id='topic+show+2CIndependenceTest-method'></span><span id='topic+show+2CMaxTypeIndependenceTest-method'></span><span id='topic+show+2CQuadTypeIndependenceTest-method'></span><span id='topic+show+2CScalarIndependenceTest-method'></span><span id='topic+show+2CScalarIndependenceTestConfint-method'></span>

<h3>Description</h3>

<p>Objects of class <code>"IndependenceTest"</code> and its subclasses
<code>"MaxTypeIndependenceTest"</code>, <code>"QuadTypeIndependenceTest"</code>,
<code>"ScalarIndependenceTest"</code> and <code>"ScalarIndependenceTestConfint"</code>
represent an independence test including its original and transformed data
structure, linear statistic, test statistic and reference distribution.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form </p>
<pre>    new("IndependenceTest", ...),

    new("MaxTypeIndependenceTest", ...),

    new("QuadTypeIndependenceTest", ...),

    new("ScalarIndependenceTest", ...)</pre>
<p>and </p>
<pre>    new("ScalarIndependenceTestConfint", ...).</pre>


<h3>Slots</h3>

<p>For objects of classes <code>"IndependenceTest"</code>,
<code>"MaxTypeIndependenceTest"</code>, <code>"QuadTypeIndependenceTest"</code>,
<code>"ScalarIndependenceTest"</code> or <code>"ScalarIndependenceTestConfint"</code>:
</p>

<dl>
<dt><code>distribution</code>:</dt><dd>
<p>Object of class <code>"<a href="#topic+PValue-class">PValue</a>"</code>.  The reference
distribution.
</p>
</dd>
<dt><code>statistic</code>:</dt><dd>
<p>Object of class <code>"<a href="#topic+IndependenceTestStatistic-class">IndependenceTestStatistic</a>"</code>.  The
test statistic, the linear statistic, and the transformed and original
data structures.
</p>
</dd>
<dt><code>estimates</code>:</dt><dd>
<p>Object of class <code>"list"</code>.  The estimated parameters.
</p>
</dd>
<dt><code>method</code>:</dt><dd>
<p>Object of class <code>"character"</code>.  The test method.
</p>
</dd>
<dt><code>call</code>:</dt><dd>
<p>Object of class <code>"call"</code>.  The matched call.
</p>
</dd>
</dl>

<p>Additionally, for objects of classes <code>"ScalarIndependenceTest"</code> or
<code>"ScalarIndependenceTestConfint"</code>:
</p>

<dl>
<dt><code>parameter</code>:</dt><dd>
<p>Object of class <code>"character"</code>.  The tested parameter.
</p>
</dd>
<dt><code>nullvalue</code>:</dt><dd>
<p>Object of class <code>"numeric"</code>.  The hypothesized value of the null
hypothesis.
</p>
</dd>
</dl>

<p>Additionally, for objects of class <code>"ScalarIndependenceTestConfint"</code>:
</p>

<dl>
<dt><code>confint</code>:</dt><dd>
<p>Object of class <code>"function"</code>.  The confidence interval function.
</p>
</dd>
<dt><code>conf.level</code>:</dt><dd>
<p>Object of class <code>"numeric"</code>.  The confidence level.
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>For objects of classes <code>"MaxTypeIndependenceTest"</code>,
<code>"QuadTypeIndependenceTest"</code> or <code>"ScalarIndependenceTest"</code>: <br />
Class <code>"IndependenceTest"</code>, directly.
</p>
<p>For objects of class <code>"ScalarIndependenceTestConfint"</code>: <br />
Class <code>"ScalarIndependenceTest"</code>, directly. <br />
Class <code>"IndependenceTest"</code>, by class <code>"ScalarIndependenceTest"</code>,
distance 2.
</p>


<h3>Known Subclasses</h3>

<p>For objects of class <code>"IndependenceTest"</code>: <br />
Class <code>"MaxTypeIndependenceTest"</code>, directly. <br />
Class <code>"QuadTypeIndependenceTest"</code>, directly. <br />
Class <code>"ScalarIndependenceTest"</code>, directly. <br />
Class <code>"ScalarIndependenceTestConfint"</code>, by class
<code>"ScalarIndependenceTest"</code>, distance 2.
</p>
<p>For objects of class <code>"ScalarIndependenceTest"</code>: <br />
Class <code>"ScalarIndependenceTestConfint"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>confint</dt><dd>
<p><code>signature(object = "IndependenceTest")</code>: See the documentation for
<code><a href="stats4.html#topic+confint-methods">confint-methods</a></code> (in package <span class="pkg">stats4</span>) for details.
</p>
</dd>
<dt>confint</dt><dd>
<p><code>signature(object = "ScalarIndependenceTestConfint")</code>: See the
documentation for <code><a href="stats4.html#topic+confint-methods">confint-methods</a></code> (in package
<span class="pkg">stats4</span>) for details.
</p>
</dd>
<dt>covariance</dt><dd>
<p><code>signature(object = "IndependenceTest")</code>: See the documentation for
<code><a href="#topic+covariance">covariance</a>()</code> for details.
</p>
</dd>
<dt>dperm</dt><dd>
<p><code>signature(object = "IndependenceTest")</code>: See the documentation for
<code><a href="#topic+dperm">dperm</a>()</code> for details.
</p>
</dd>
<dt>expectation</dt><dd>
<p><code>signature(object = "IndependenceTest")</code>: See the documentation for
<code><a href="#topic+expectation">expectation</a>()</code> for details.
</p>
</dd>
<dt>midpvalue</dt><dd>
<p><code>signature(object = "IndependenceTest")</code>: See the documentation for
<code><a href="#topic+midpvalue">midpvalue</a>()</code> for details.
</p>
</dd>
<dt>pperm</dt><dd>
<p><code>signature(object = "IndependenceTest")</code>: See the documentation for
<code><a href="#topic+pperm">pperm</a>()</code> for details.
</p>
</dd>
<dt>pvalue</dt><dd>
<p><code>signature(object = "IndependenceTest")</code>: See the documentation for
<code><a href="#topic+pvalue">pvalue</a>()</code> for details.
</p>
</dd>
<dt>pvalue</dt><dd>
<p><code>signature(object = "MaxTypeIndependenceTest")</code>: See the
documentation for <code><a href="#topic+pvalue">pvalue</a>()</code> for details.
</p>
</dd>
<dt>pvalue_interval</dt><dd>
<p><code>signature(object = "IndependenceTest")</code>: See the documentation for
<code><a href="#topic+pvalue_interval">pvalue_interval</a>()</code> for details.
</p>
</dd>
<dt>qperm</dt><dd>
<p><code>signature(object = "IndependenceTest")</code>: See the documentation for
<code><a href="#topic+qperm">qperm</a>()</code> for details.
</p>
</dd>
<dt>rperm</dt><dd>
<p><code>signature(object = "IndependenceTest")</code>: See the documentation for
<code><a href="#topic+rperm">rperm</a>()</code> for details.
</p>
</dd>
<dt>show</dt><dd>
<p><code>signature(object = "IndependenceTest")</code>: See the documentation for
<code><a href="methods.html#topic+show">show</a>()</code> (in package <span class="pkg">methods</span>) for details.
</p>
</dd>
<dt>show</dt><dd>
<p><code>signature(object = "MaxTypeIndependenceTest")</code>: See the
documentation for <code><a href="methods.html#topic+show">show</a>()</code> (in package <span class="pkg">methods</span>)
for details.
</p>
</dd>
<dt>show</dt><dd>
<p><code>signature(object = "QuadTypeIndependenceTest")</code>: See the
documentation for <code><a href="methods.html#topic+show">show</a>()</code> (in package <span class="pkg">methods</span>)
for details.
</p>
</dd>
<dt>show</dt><dd>
<p><code>signature(object = "ScalarIndependenceTest")</code>: See the documentation
for <code><a href="methods.html#topic+show">show</a>()</code> (in package <span class="pkg">methods</span>) for details.
</p>
</dd>
<dt>show</dt><dd>
<p><code>signature(object = "ScalarIndependenceTestConfint")</code>: See the
documentation for <code><a href="methods.html#topic+show">show</a>()</code> (in package <span class="pkg">methods</span>)
for details.
</p>
</dd>
<dt>size</dt><dd>
<p><code>signature(object = "IndependenceTest")</code>: See the documentation for
<code><a href="#topic+size">size</a>()</code> for details.
</p>
</dd>
<dt>statistic</dt><dd>
<p><code>signature(object = "IndependenceTest")</code>: See the documentation for
<code><a href="#topic+statistic">statistic</a>()</code> for details.
</p>
</dd>
<dt>support</dt><dd>
<p><code>signature(object = "IndependenceTest")</code>: See the documentation for
<code><a href="#topic+support">support</a>()</code> for details.
</p>
</dd>
<dt>variance</dt><dd>
<p><code>signature(object = "IndependenceTest")</code>: See the documentation for
<code><a href="#topic+variance">variance</a>()</code> for details.
</p>
</dd>
</dl>


<hr>
<h2 id='IndependenceTestProblem-class'>Class <code>"IndependenceTestProblem"</code></h2><span id='topic+IndependenceTestProblem-class'></span><span id='topic+initialize+2CIndependenceTestProblem-method'></span>

<h3>Description</h3>

<p>Objects of class <code>"IndependenceTestProblem"</code> represent the transformed
and original data structures corresponding to an independence problem.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form </p>
<pre>     new("IndependenceTestProblem", object, xtrafo = trafo, ytrafo = trafo, ...)</pre>
<p>where <code>object</code> is an object of class
<code>"<a href="#topic+IndependenceProblem-class">IndependenceProblem</a>"</code>, <code>xtrafo</code> is the regression
function <code class="reqn">g(\mathbf{X})</code> and <code>ytrafo</code> is the influence function
<code class="reqn">h(\mathbf{Y})</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>xtrans</code>:</dt><dd>
<p>Object of class <code>"matrix"</code>.  The transformed <code>x</code>.
</p>
</dd>
<dt><code>ytrans</code>:</dt><dd>
<p>Object of class <code>"matrix"</code>.  The transformed <code>y</code>.
</p>
</dd>
<dt><code>xtrafo</code>:</dt><dd>
<p>Object of class <code>"function"</code>.  The regression function for <code>x</code>.
</p>
</dd>
<dt><code>ytrafo</code>:</dt><dd>
<p>Object of class <code>"function"</code>.  The influence function for <code>y</code>.
</p>
</dd>
<dt><code>x</code>:</dt><dd>
<p>Object of class <code>"data.frame"</code>.  The variables <code>x</code>.
</p>
</dd>
<dt><code>y</code>:</dt><dd>
<p>Object of class <code>"data.frame"</code>.  The variables <code>y</code>.
</p>
</dd>
<dt><code>block</code>:</dt><dd>
<p>Object of class <code>"factor"</code>.  The block structure.
</p>
</dd>
<dt><code>weights</code>:</dt><dd>
<p>Object of class <code>"numeric"</code>.  The case weights.
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+IndependenceProblem-class">IndependenceProblem</a>"</code>, directly.
</p>


<h3>Known Subclasses</h3>

<p>Class <code>"<a href="#topic+IndependenceLinearStatistic-class">IndependenceLinearStatistic</a>"</code>, directly. <br />
Class <code>"<a href="#topic+IndependenceTestStatistic-class">IndependenceTestStatistic</a>"</code>, by class
<code>"<a href="#topic+IndependenceLinearStatistic-class">IndependenceLinearStatistic</a>"</code>, distance 2. <br />
Class <code>"<a href="#topic+MaxTypeIndependenceTestStatistic-class">MaxTypeIndependenceTestStatistic</a>"</code>, by class
<code>"<a href="#topic+IndependenceTestStatistic-class">IndependenceTestStatistic</a>"</code>, distance 3. <br />
Class <code>"<a href="#topic+QuadTypeIndependenceTestStatistic-class">QuadTypeIndependenceTestStatistic</a>"</code>, by class
<code>"<a href="#topic+IndependenceTestStatistic-class">IndependenceTestStatistic</a>"</code>, distance 3. <br />
Class <code>"<a href="#topic+ScalarIndependenceTestStatistic-class">ScalarIndependenceTestStatistic</a>"</code>, by class
<code>"<a href="#topic+IndependenceTestStatistic-class">IndependenceTestStatistic</a>"</code>, distance 3.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd>
<p><code>signature(.Object = "IndependenceTestProblem")</code>: See the
documentation for <code><a href="methods.html#topic+new">initialize</a>()</code> (in
package <span class="pkg">methods</span>) for details.
</p>
</dd>
</dl>


<hr>
<h2 id='IndependenceTestStatistic-class'>Class <code>"IndependenceTestStatistic"</code> and Its Subclasses</h2><span id='topic+IndependenceTestStatistic-class'></span><span id='topic+MaxTypeIndependenceTestStatistic-class'></span><span id='topic+QuadTypeIndependenceTestStatistic-class'></span><span id='topic+ScalarIndependenceTestStatistic-class'></span><span id='topic+initialize+2CIndependenceTestStatistic-method'></span><span id='topic+initialize+2CMaxTypeIndependenceTestStatistic-method'></span><span id='topic+initialize+2CQuadTypeIndependenceTestStatistic-method'></span><span id='topic+initialize+2CScalarIndependenceTestStatistic-method'></span>

<h3>Description</h3>

<p>Objects of class <code>"IndependenceTestStatistic"</code> and its subclasses
<code>"MaxTypeIndependenceTestStatistic"</code>,
<code>"QuadTypeIndependenceTestStatistic"</code> and
<code>"ScalarIndependenceTestStatistic"</code> represent the test statistic, the
linear statistic, and the transformed and original data structures
corresponding to an independence problem.
</p>


<h3>Objects from the Class</h3>

<p>Class <code>"IndependenceTestStatistic"</code> is a <em>virtual</em> class, so objects
cannot be created from it directly.
</p>
<p>Objects can be created by calls of the form </p>
<pre>     new("MaxTypeIndependenceTestStatistic", object,
         alternative = c("two.sided", "less", "greater"), ...),

     new("QuadTypeIndependenceTestStatistic", object, paired = FALSE, ...)</pre>
<p>and </p>
<pre>     new("ScalarIndependenceTestStatistic", object,
         alternative = c("two.sided", "less", "greater"), paired = FALSE, ...)</pre>
<p>where <code>object</code> is an object of class
<code>"IndependenceLinearStatistic"</code>, <code>alternative</code> is a character
specifying the direction of the alternative hypothesis and <code>paired</code> is a
logical indicating that paired data have been transformed in such a way that
the (unstandardized) linear statistic is the sum of the absolute values of the
positive differences between the paired observations.
</p>


<h3>Slots</h3>

<p>For objects of classes <code>"IndependenceTestStatistic"</code>,
<code>"MaxTypeIndependenceTestStatistic"</code>,
<code>"QuadTypeIndependenceTestStatistic"</code> or
<code>"ScalarIndependenceTestStatistic"</code>:
</p>

<dl>
<dt><code>teststatistic</code>:</dt><dd>
<p>Object of class <code>"numeric"</code>.  The test statistic.
</p>
</dd>
<dt><code>standardizedlinearstatistic</code>:</dt><dd>
<p>Object of class <code>"numeric"</code>.  The standardized linear statistic.
</p>
</dd>
<dt><code>linearstatistic</code>:</dt><dd>
<p>Object of class <code>"matrix"</code>.  The linear statistic for each block.
</p>
</dd>
<dt><code>expectation</code>:</dt><dd>
<p>Object of class <code>"matrix"</code>.  The expectation of the linear statistic
for each block.
</p>
</dd>
<dt><code>covariance</code>:</dt><dd>
<p>Object of class <code>"matrix"</code>.  The lower triangular elements of the
covariance of the linear statistic for each block.
</p>
</dd>
<dt><code>xtrans</code>:</dt><dd>
<p>Object of class <code>"matrix"</code>.  The transformed <code>x</code>.
</p>
</dd>
<dt><code>ytrans</code>:</dt><dd>
<p>Object of class <code>"matrix"</code>.  The transformed <code>y</code>.
</p>
</dd>
<dt><code>xtrafo</code>:</dt><dd>
<p>Object of class <code>"function"</code>.  The regression function for <code>x</code>.
</p>
</dd>
<dt><code>ytrafo</code>:</dt><dd>
<p>Object of class <code>"function"</code>.  The influence function for <code>y</code>.
</p>
</dd>
<dt><code>x</code>:</dt><dd>
<p>Object of class <code>"data.frame"</code>.  The variables <code>x</code>.
</p>
</dd>
<dt><code>y</code>:</dt><dd>
<p>Object of class <code>"data.frame"</code>.  The variables <code>y</code>.
</p>
</dd>
<dt><code>block</code>:</dt><dd>
<p>Object of class <code>"factor"</code>.  The block structure.
</p>
</dd>
<dt><code>weights</code>:</dt><dd>
<p>Object of class <code>"numeric"</code>.  The case weights.
</p>
</dd>
</dl>

<p>Additionally, for objects of classes <code>"MaxTypeIndependenceTest"</code> or
<code>"ScalarIndependenceTest"</code>:
</p>

<dl>
<dt><code>alternative</code>:</dt><dd>
<p>Object of class <code>"character"</code>.  The direction of the alternative
hypothesis.
</p>
</dd>
</dl>

<p>Additionally, for objects of class <code>"QuadTypeIndependenceTest"</code>:
</p>

<dl>
<dt><code>covarianceplus</code>:</dt><dd>
<p>Object of class <code>"numeric"</code>.  The lower triangular elements of the
Moore-Penrose inverse of the covariance of the linear statistic.
</p>
</dd>
<dt><code>df</code>:</dt><dd>
<p>Object of class <code>"numeric"</code>.  The rank of the covariance matrix.
</p>
</dd>
</dl>

<p>Additionally, for objects of classes <code>"QuadTypeIndependenceTest"</code> or
<code>"ScalarIndependenceTest"</code>:
</p>

<dl>
<dt><code>paired</code>:</dt><dd>
<p>Object of class <code>"logical"</code>.  The indicator for paired test
statistics.
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>For objects of class <code>"IndependenceTestStatistic"</code>: <br />
Class <code>"<a href="#topic+IndependenceLinearStatistic-class">IndependenceLinearStatistic</a>"</code>, directly. <br />
Class <code>"<a href="#topic+IndependenceTestProblem-class">IndependenceTestProblem</a>"</code>, by class
<code>"<a href="#topic+IndependenceLinearStatistic-class">IndependenceLinearStatistic</a>"</code>, distance 2. <br />
Class <code>"<a href="#topic+IndependenceProblem-class">IndependenceProblem</a>"</code>, by class
<code>"<a href="#topic+IndependenceLinearStatistic-class">IndependenceLinearStatistic</a>"</code>, distance 3.
</p>
<p>For objects of classes <code>"MaxTypeIndependenceTestStatistic"</code>,
<code>"QuadTypeIndependenceTestStatistic"</code> or
<code>"ScalarIndependenceTestStatistic"</code>: <br />
Class <code>"<a href="#topic+IndependenceTestStatistic-class">IndependenceTestStatistic</a>"</code>, directly. <br />
Class <code>"<a href="#topic+IndependenceLinearStatistic-class">IndependenceLinearStatistic</a>"</code>, by class
<code>"<a href="#topic+IndependenceTestStatistic-class">IndependenceTestStatistic</a>"</code>, distance 2. <br />
Class <code>"<a href="#topic+IndependenceTestProblem-class">IndependenceTestProblem</a>"</code>, by class
<code>"<a href="#topic+IndependenceTestStatistic-class">IndependenceTestStatistic</a>"</code>, distance 3. <br />
Class <code>"<a href="#topic+IndependenceProblem-class">IndependenceProblem</a>"</code>, by class
<code>"<a href="#topic+IndependenceTestStatistic-class">IndependenceTestStatistic</a>"</code>, distance 4.
</p>


<h3>Known Subclasses</h3>

<p>For objects of class <code>"IndependenceTestStatistic"</code>: <br />
Class <code>"MaxTypeIndependenceTestStatistic"</code>, directly. <br />
Class <code>"QuadTypeIndependenceTestStatistic"</code>, directly. <br />
Class <code>"ScalarIndependenceTestStatistic"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>ApproxNullDistribution</dt><dd>
<p><code>signature(object = "MaxTypeIndependenceTestStatistic")</code>: See the
documentation for <code><a href="#topic+ApproxNullDistribution">ApproxNullDistribution</a>()</code> for details.
</p>
</dd>
<dt>ApproxNullDistribution</dt><dd>
<p><code>signature(object = "QuadTypeIndependenceTestStatistic")</code>: See the
documentation for <code><a href="#topic+ApproxNullDistribution">ApproxNullDistribution</a>()</code> for details.
</p>
</dd>
<dt>ApproxNullDistribution</dt><dd>
<p><code>signature(object = "ScalarIndependenceTestStatistic")</code>: See the
documentation for <code><a href="#topic+ApproxNullDistribution">ApproxNullDistribution</a>()</code> for details.
</p>
</dd>
<dt>AsymptNullDistribution</dt><dd>
<p><code>signature(object = "MaxTypeIndependenceTestStatistic")</code>: See the
documentation for <code><a href="#topic+AsymptNullDistribution">AsymptNullDistribution</a>()</code> for details.
</p>
</dd>
<dt>AsymptNullDistribution</dt><dd>
<p><code>signature(object = "QuadTypeIndependenceTestStatistic")</code>: See the
documentation for <code><a href="#topic+AsymptNullDistribution">AsymptNullDistribution</a>()</code> for details.
</p>
</dd>
<dt>AsymptNullDistribution</dt><dd>
<p><code>signature(object = "ScalarIndependenceTestStatistic")</code>: See the
documentation for <code><a href="#topic+AsymptNullDistribution">AsymptNullDistribution</a>()</code> for details.
</p>
</dd>
<dt>ExactNullDistribution</dt><dd>
<p><code>signature(object = "QuadTypeIndependenceTestStatistic")</code>: See the
documentation for <code><a href="#topic+ExactNullDistribution">ExactNullDistribution</a>()</code> for details.
</p>
</dd>
<dt>ExactNullDistribution</dt><dd>
<p><code>signature(object = "ScalarIndependenceTestStatistic")</code>: See the
documentation for <code><a href="#topic+ExactNullDistribution">ExactNullDistribution</a>()</code> for details.
</p>
</dd>
<dt>covariance</dt><dd>
<p><code>signature(object = "QuadTypeIndependenceTestStatistic")</code>: See the
documentation for <code><a href="#topic+covariance">covariance</a>()</code> for details.
</p>
</dd>
<dt>initialize</dt><dd>
<p><code>signature(.Object = "IndependenceTestStatistic")</code>: See the
documentation for <code><a href="methods.html#topic+new">initialize</a>()</code> (in package
<span class="pkg">methods</span>) for details.
</p>
</dd>
<dt>initialize</dt><dd>
<p><code>signature(.Object = "MaxTypeIndependenceTestStatistic")</code>: See the
documentation for <code><a href="methods.html#topic+new">initialize</a>()</code> (in package
<span class="pkg">methods</span>) for details.
</p>
</dd>
<dt>initialize</dt><dd>
<p><code>signature(.Object = "QuadTypeIndependenceTestStatistic")</code>: See the
documentation for <code><a href="methods.html#topic+new">initialize</a>()</code> (in package
<span class="pkg">methods</span>) for details.
</p>
</dd>
<dt>initialize</dt><dd>
<p><code>signature(.Object = "ScalarIndependenceTestStatistic")</code>: See the
documentation for <code><a href="methods.html#topic+new">initialize</a>()</code> (in package
<span class="pkg">methods</span>) for details.
</p>
</dd>
<dt>statistic</dt><dd>
<p><code>signature(object = "IndependenceTestStatistic")</code>: See the
documentation for <code><a href="#topic+statistic">statistic</a>()</code> for details.
</p>
</dd>
</dl>


<hr>
<h2 id='jobsatisfaction'>Income and Job Satisfaction</h2><span id='topic+jobsatisfaction'></span>

<h3>Description</h3>

<p>Income and job satisfaction by gender.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jobsatisfaction</code></pre>


<h3>Format</h3>

<p>A contingency table with 104 observations on 3 variables.
</p>

<dl>
<dt><code>Income</code></dt><dd>
<p>a factor with levels <code>"&lt;5000"</code>, <code>"5000-15000"</code>,
<code>"15000-25000"</code> and <code>"&gt;25000"</code>.
</p>
</dd>
<dt><code>Job.Satisfaction</code></dt><dd>
<p>a factor with levels <code>"Very Dissatisfied"</code>,
<code>"A Little Satisfied"</code>, <code>"Moderately Satisfied"</code> and
<code>"Very Satisfied"</code>.
</p>
</dd>
<dt><code>Gender</code></dt><dd>
<p>a factor with levels <code>"Female"</code> and <code>"Male"</code>.
</p>
</dd>
</dl>



<h3>Details</h3>

<p>This data set was given in Agresti (2002, p. 288, Tab. 7.8).  Winell and
Lindbäck (2018) used the data to demonstrate a
score-independent test for ordered categorical data.
</p>


<h3>Source</h3>

<p>Agresti, A.  (2002).  <em>Categorical Data Analysis</em>, Second Edition.
Hoboken, New Jersey: John Wiley &amp; Sons.
</p>


<h3>References</h3>

<p>Winell, H. and Lindbäck, J.  (2018).  A general
score-independent test for order-restricted inference.  <em>Statistics in
Medicine</em> <b>37</b>(21), 3078&ndash;3090.  <a href="https://doi.org/10.1002/sim.7690">doi:10.1002/sim.7690</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Approximative (Monte Carlo) linear-by-linear association test
lbl_test(jobsatisfaction, distribution = approximate(nresample = 10000))

## Not run: 
## Approximative (Monte Carlo) score-independent test
## Winell and Lindbaeck (2018)
(it &lt;- independence_test(jobsatisfaction,
                         distribution = approximate(nresample = 10000),
                         xtrafo = function(data)
                             trafo(data, factor_trafo = function(x)
                                 zheng_trafo(as.ordered(x))),
                         ytrafo = function(data)
                             trafo(data, factor_trafo = function(y)
                                 zheng_trafo(as.ordered(y)))))

## Extract the "best" set of scores
ss &lt;- statistic(it, type = "standardized")
idx &lt;- which(abs(ss) == max(abs(ss)), arr.ind = TRUE)
ss[idx[1], idx[2], drop = FALSE]
## End(Not run)
</code></pre>

<hr>
<h2 id='LocationTests'>Two- and <code class="reqn">K</code>-Sample Location Tests</h2><span id='topic+oneway_test'></span><span id='topic+oneway_test.formula'></span><span id='topic+oneway_test.IndependenceProblem'></span><span id='topic+wilcox_test'></span><span id='topic+wilcox_test.formula'></span><span id='topic+wilcox_test.IndependenceProblem'></span><span id='topic+kruskal_test'></span><span id='topic+kruskal_test.formula'></span><span id='topic+kruskal_test.IndependenceProblem'></span><span id='topic+normal_test'></span><span id='topic+normal_test.formula'></span><span id='topic+normal_test.IndependenceProblem'></span><span id='topic+median_test'></span><span id='topic+median_test.formula'></span><span id='topic+median_test.IndependenceProblem'></span><span id='topic+savage_test'></span><span id='topic+savage_test.formula'></span><span id='topic+savage_test.IndependenceProblem'></span>

<h3>Description</h3>

<p>Testing the equality of the distributions of a numeric response variable in
two or more independent groups against shift alternatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
oneway_test(formula, data, subset = NULL, weights = NULL, ...)
## S3 method for class 'IndependenceProblem'
oneway_test(object, ...)

## S3 method for class 'formula'
wilcox_test(formula, data, subset = NULL, weights = NULL, ...)
## S3 method for class 'IndependenceProblem'
wilcox_test(object, conf.int = FALSE, conf.level = 0.95, ...)

## S3 method for class 'formula'
kruskal_test(formula, data, subset = NULL, weights = NULL, ...)
## S3 method for class 'IndependenceProblem'
kruskal_test(object, ...)

## S3 method for class 'formula'
normal_test(formula, data, subset = NULL, weights = NULL, ...)
## S3 method for class 'IndependenceProblem'
normal_test(object, ties.method = c("mid-ranks", "average-scores"),
            conf.int = FALSE, conf.level = 0.95, ...)

## S3 method for class 'formula'
median_test(formula, data, subset = NULL, weights = NULL, ...)
## S3 method for class 'IndependenceProblem'
median_test(object, mid.score = c("0", "0.5", "1"),
            conf.int = FALSE, conf.level = 0.95, ...)

## S3 method for class 'formula'
savage_test(formula, data, subset = NULL, weights = NULL, ...)
## S3 method for class 'IndependenceProblem'
savage_test(object, ties.method = c("mid-ranks", "average-scores"),
            conf.int = FALSE, conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="LocationTests_+3A_formula">formula</code></td>
<td>

<p>a formula of the form <code>y ~ x | block</code> where <code>y</code> is a numeric
variable, <code>x</code> is a factor and <code>block</code> is an optional factor for
stratification.
</p>
</td></tr>
<tr><td><code id="LocationTests_+3A_data">data</code></td>
<td>

<p>an optional data frame containing the variables in the model formula.
</p>
</td></tr>
<tr><td><code id="LocationTests_+3A_subset">subset</code></td>
<td>

<p>an optional vector specifying a subset of observations to be used.  Defaults
to <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="LocationTests_+3A_weights">weights</code></td>
<td>

<p>an optional formula of the form <code>~ w</code> defining integer valued case
weights for each observation.  Defaults to <code>NULL</code>, implying equal
weight for all observations.
</p>
</td></tr>
<tr><td><code id="LocationTests_+3A_object">object</code></td>
<td>

<p>an object inheriting from class <code>"<a href="#topic+IndependenceProblem-class">IndependenceProblem</a>"</code>.
</p>
</td></tr>
<tr><td><code id="LocationTests_+3A_conf.int">conf.int</code></td>
<td>

<p>a logical indicating whether a confidence interval for the difference in
location should be computed.  Defaults to <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="LocationTests_+3A_conf.level">conf.level</code></td>
<td>

<p>a numeric, confidence level of the interval.  Defaults to <code>0.95</code>.
</p>
</td></tr>
<tr><td><code id="LocationTests_+3A_ties.method">ties.method</code></td>
<td>

<p>a character, the method used to handle ties: the score generating function
either uses mid-ranks (<code>"mid-ranks"</code>, default) or averages the scores
of randomly broken ties (<code>"average-scores"</code>).
</p>
</td></tr>
<tr><td><code id="LocationTests_+3A_mid.score">mid.score</code></td>
<td>

<p>a character, the score assigned to observations exactly equal to the median:
either 0 (<code>"0"</code>, default), 0.5 (<code>"0.5"</code>) or 1 (<code>"1"</code>); see
&lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="LocationTests_+3A_...">...</code></td>
<td>

<p>further arguments to be passed to <code><a href="#topic+independence_test">independence_test</a>()</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>oneway_test()</code>, <code>wilcox_test()</code>, <code>kruskal_test()</code>,
<code>normal_test()</code>, <code>median_test()</code> and <code>savage_test()</code> provide
the Fisher-Pitman permutation test, the Wilcoxon-Mann-Whitney test, the
Kruskal-Wallis test, the van der Waerden test, the Brown-Mood median test and
the Savage test.  A general description of these methods is given by Hollander
and Wolfe (1999). For the adjustment of scores for tied values see
Hájek, Šidák and Sen (1999, pp. 133&ndash;135).
</p>
<p>The null hypothesis of equality, or conditional equality given <code>block</code>,
of the distribution of <code>y</code> in the groups defined by <code>x</code> is tested
against shift alternatives.  In the two-sample case, the two-sided null
hypothesis is <code class="reqn">H_0\!: \mu = 0</code>, where <code class="reqn">\mu = Y_1 - Y_2</code>
and <code class="reqn">Y_s</code> is the median of the responses in the <code class="reqn">s</code>th sample.  In case
<code>alternative = "less"</code>, the null hypothesis is <code class="reqn">H_0\!: \mu \ge
    0</code>.  When <code>alternative = "greater"</code>, the null hypothesis
is <code class="reqn">H_0\!: \mu \le 0</code>.  Confidence intervals for the
difference in location are available (except for <code>oneway_test()</code>) and
computed according to Bauer (1972).
</p>
<p>If <code>x</code> is an ordered factor, the default scores, <code>1:nlevels(x)</code>, can
be altered using the <code>scores</code> argument (see
<code><a href="#topic+independence_test">independence_test</a>()</code>); this argument can also be used to coerce
nominal factors to class <code>"ordered"</code>.  In this case, a linear-by-linear
association test is computed and the direction of the alternative hypothesis
can be specified using the <code>alternative</code> argument.
</p>
<p>The Brown-Mood median test offers a choice of mid-score, i.e., the score
assigned to observations exactly equal to the median.  In the two-sample case,
<code>mid-score = "0"</code> implies that the linear test statistic is simply the
number of subjects in the second sample with observations greater than the
median of the pooled sample.  Similarly, the linear test statistic for the
last alternative, <code>mid-score = "1"</code>, is the number of subjects in the
second sample with observations greater than or equal to the median of the
pooled sample.  If <code>mid-score = "0.5"</code> is selected, the linear test
statistic is the mean of the test statistics corresponding to the first and
last alternatives and has a symmetric distribution, or at least approximately
so, under the null hypothesis (see Hájek, Šidák
and Sen, 1999, pp. 97&ndash;98).
</p>
<p>The conditional null distribution of the test statistic is used to obtain
<code class="reqn">p</code>-values and an asymptotic approximation of the exact distribution is
used by default (<code>distribution = "asymptotic"</code>).  Alternatively, the
distribution can be approximated via Monte Carlo resampling or computed
exactly for univariate two-sample problems by setting <code>distribution</code> to
<code>"approximate"</code> or <code>"exact"</code>, respectively.  See
<code><a href="#topic+asymptotic">asymptotic</a>()</code>, <code><a href="#topic+approximate">approximate</a>()</code> and
<code><a href="#topic+exact">exact</a>()</code> for details.
</p>


<h3>Value</h3>

<p>An object inheriting from class <code>"<a href="#topic+IndependenceTest-class">IndependenceTest</a>"</code>.
Confidence intervals can be extracted by <code><a href="stats.html#topic+confint">confint</a>()</code>.
</p>


<h3>Note</h3>

<p>Starting with <span class="pkg">coin</span> version 1.1-0, <code>oneway_test()</code> no longer allows
the test statistic to be specified; a quadratic form is now used in the
<code class="reqn">K</code>-sample case.  Please use <code><a href="#topic+independence_test">independence_test</a>()</code> if more
control is desired.
</p>


<h3>References</h3>

<p>Bauer, D. F.  (1972).  Constructing confidence sets using rank statistics.
<em>Journal of the American Statistical Association</em> <b>67</b>(339),
687&ndash;690.  <a href="https://doi.org/10.1080/01621459.1972.10481279">doi:10.1080/01621459.1972.10481279</a>
</p>
<p>Hájek, J., Šidák, Z. and Sen, P. K.  (1999).
<em>Theory of Rank Tests</em>, Second Edition.  San Diego: Academic Press.
</p>
<p>Hollander, M. and Wolfe, D. A.  (1999).  <em>Nonparametric Statistical
Methods</em>, Second Edition.  New York: John Wiley &amp; Sons.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Tritiated Water Diffusion Across Human Chorioamnion
## Hollander and Wolfe (1999, p. 110, Tab. 4.1)
diffusion &lt;- data.frame(
    pd = c(0.80, 0.83, 1.89, 1.04, 1.45, 1.38, 1.91, 1.64, 0.73, 1.46,
           1.15, 0.88, 0.90, 0.74, 1.21),
    age = factor(rep(c("At term", "12-26 Weeks"), c(10, 5)))
)

## Exact Wilcoxon-Mann-Whitney test
## Hollander and Wolfe (1999, p. 111)
## (At term - 12-26 Weeks)
(wt &lt;- wilcox_test(pd ~ age, data = diffusion,
                   distribution = "exact", conf.int = TRUE))

## Extract observed Wilcoxon statistic
## Note: this is the sum of the ranks for age = "12-26 Weeks"
statistic(wt, type = "linear")

## Expectation, variance, two-sided pvalue and confidence interval
expectation(wt)
covariance(wt)
pvalue(wt)
confint(wt)

## For two samples, the Kruskal-Wallis test is equivalent to the W-M-W test
kruskal_test(pd ~ age, data = diffusion,
             distribution = "exact")

## Asymptotic Fisher-Pitman test
oneway_test(pd ~ age, data = diffusion)

## Approximative (Monte Carlo) Fisher-Pitman test
pvalue(oneway_test(pd ~ age, data = diffusion,
                   distribution = approximate(nresample = 10000)))

## Exact Fisher-Pitman test
pvalue(ot &lt;- oneway_test(pd ~ age, data = diffusion,
                         distribution = "exact"))

## Plot density and distribution of the standardized test statistic
op &lt;- par(no.readonly = TRUE) # save current settings
layout(matrix(1:2, nrow = 2))
s &lt;- support(ot)
d &lt;- dperm(ot, s)
p &lt;- pperm(ot, s)
plot(s, d, type = "S", xlab = "Test Statistic", ylab = "Density")
plot(s, p, type = "S", xlab = "Test Statistic", ylab = "Cum. Probability")
par(op) # reset


## Example data
ex &lt;- data.frame(
    y = c(3, 4, 8, 9, 1, 2, 5, 6, 7),
    x = factor(rep(c("no", "yes"), c(4, 5)))
)

## Boxplots
boxplot(y ~ x, data = ex)

## Exact Brown-Mood median test with different mid-scores
(mt1 &lt;- median_test(y ~ x, data = ex, distribution = "exact"))
(mt2 &lt;- median_test(y ~ x, data = ex, distribution = "exact",
                    mid.score = "0.5"))
(mt3 &lt;- median_test(y ~ x, data = ex, distribution = "exact",
                    mid.score = "1")) # sign change!

## Plot density and distribution of the standardized test statistics
op &lt;- par(no.readonly = TRUE) # save current settings
layout(matrix(1:3, nrow = 3))
s1 &lt;- support(mt1); d1 &lt;- dperm(mt1, s1)
plot(s1, d1, type = "h", main = "Mid-score: 0",
     xlab = "Test Statistic", ylab = "Density")
s2 &lt;- support(mt2); d2 &lt;- dperm(mt2, s2)
plot(s2, d2, type = "h", main = "Mid-score: 0.5",
     xlab = "Test Statistic", ylab = "Density")
s3 &lt;- support(mt3); d3 &lt;- dperm(mt3, s3)
plot(s3, d3, type = "h", main = "Mid-score: 1",
     xlab = "Test Statistic", ylab = "Density")
par(op) # reset


## Length of YOY Gizzard Shad
## Hollander and Wolfe (1999, p. 200, Tab. 6.3)
yoy &lt;- data.frame(
    length = c(46, 28, 46, 37, 32, 41, 42, 45, 38, 44,
               42, 60, 32, 42, 45, 58, 27, 51, 42, 52,
               38, 33, 26, 25, 28, 28, 26, 27, 27, 27,
               31, 30, 27, 29, 30, 25, 25, 24, 27, 30),
    site = gl(4, 10, labels = as.roman(1:4))
)

## Approximative (Monte Carlo) Kruskal-Wallis test
kruskal_test(length ~ site, data = yoy,
             distribution = approximate(nresample = 10000))

## Approximative (Monte Carlo) Nemenyi-Damico-Wolfe-Dunn test (joint ranking)
## Hollander and Wolfe (1999, p. 244)
## (where Steel-Dwass results are given)
it &lt;- independence_test(length ~ site, data = yoy,
                        distribution = approximate(nresample = 50000),
                        ytrafo = function(data)
                            trafo(data, numeric_trafo = rank_trafo),
                        xtrafo = mcp_trafo(site = "Tukey"))

## Global p-value
pvalue(it)

## Sites (I = II) != (III = IV) at alpha = 0.01 (p. 244)
pvalue(it, method = "single-step") # subset pivotality is violated
</code></pre>

<hr>
<h2 id='malformations'>Maternal Drinking and Congenital Sex Organ Malformation</h2><span id='topic+malformations'></span>

<h3>Description</h3>

<p>A subset of data from a study on the relationship between maternal alcohol
consumption and congenital malformations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>malformations</code></pre>


<h3>Format</h3>

<p>A data frame with 32574 observations on 2 variables.
</p>

<dl>
<dt><code>consumption</code></dt><dd>
<p>alcohol consumption, an ordered factor with levels <code>"0"</code>,
<code>"&lt;1"</code>, <code>"1-2"</code>, <code>"3-5"</code> and <code>"&gt;=6"</code>.
</p>
</dd>
<dt><code>malformation</code></dt><dd>
<p>congenital sex organ malformation, a factor with levels <code>"Present"</code>
and <code>"Absent"</code>.
</p>
</dd>
</dl>



<h3>Details</h3>

<p>Data from a prospective study undertaken to determine whether moderate or
light drinking during the first trimester of pregnancy increases the risk for
congenital malformations (Mills and Graubard, 1987).  The subset given here
concerns only sex organ malformation (Mills and Graubard, 1987, Tab. 4).
</p>
<p>This data set was used by Graubard and Korn (1987) to illustrate that
different choices of scores for ordinal variables can lead to conflicting
conclusions.  Zheng (2008) also used the data, demonstrating two different
score-independent tests for ordered categorical data; see also Winell and
Lindbäck (2018).
</p>


<h3>Source</h3>

<p>Mills, J. L. and Graubard, B. I.  (1987).  Is moderate drinking during
pregnancy associated with an increased risk for malformations?
<em>Pediatrics</em> <b>80</b>(3), 309&ndash;314.
</p>


<h3>References</h3>

<p>Graubard, B. I. and Korn, E. L.  (1987).  Choice of column scores for testing
independence in ordered <code class="reqn">2 \times K</code> contingency tables.
<em>Biometrics</em> <b>43</b>(2), 471&ndash;476.  <a href="https://doi.org/10.2307/2531828">doi:10.2307/2531828</a>
</p>
<p>Winell, H. and Lindbäck, J.  (2018).  A general
score-independent test for order-restricted inference.  <em>Statistics in
Medicine</em> <b>37</b>(21), 3078&ndash;3090.  <a href="https://doi.org/10.1002/sim.7690">doi:10.1002/sim.7690</a>
</p>
<p>Zheng, G.  (2008).  Analysis of ordered categorical data: Two
score-independent approaches.  <em>Biometrics</em> <b>64</b>(4), 1276–-1279.
<a href="https://doi.org/10.1111/j.1541-0420.2008.00992.x">doi:10.1111/j.1541-0420.2008.00992.x</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Graubard and Korn (1987, Tab. 3)

## One-sided approximative (Monte Carlo) Cochran-Armitage test
## Note: midpoint scores (p &lt; 0.05)
midpoints &lt;- c(0, 0.5, 1.5, 4.0, 7.0)
chisq_test(malformation ~ consumption, data = malformations,
           distribution = approximate(nresample = 1000),
           alternative = "greater",
           scores = list(consumption = midpoints))

## One-sided approximative (Monte Carlo) Cochran-Armitage test
## Note: midrank scores (p &gt; 0.05)
midranks &lt;- c(8557.5, 24375.5, 32013.0, 32473.0, 32555.5)
chisq_test(malformation ~ consumption, data = malformations,
           distribution = approximate(nresample = 1000),
           alternative = "greater",
           scores = list(consumption = midranks))

## One-sided approximative (Monte Carlo) Cochran-Armitage test
## Note: equally spaced scores (p &gt; 0.05)
chisq_test(malformation ~ consumption, data = malformations,
           distribution = approximate(nresample = 1000),
           alternative = "greater")

## Not run: 
## One-sided approximative (Monte Carlo) score-independent test
## Winell and Lindbaeck (2018)
(it &lt;- independence_test(malformation ~ consumption, data = malformations,
                         distribution = approximate(nresample = 1000,
                                                    parallel = "snow",
                                                    ncpus = 8),
                         alternative = "greater",
                         xtrafo = function(data)
                             trafo(data, ordered_trafo = zheng_trafo)))

## Extract the "best" set of scores
ss &lt;- statistic(it, type = "standardized")
idx &lt;- which(ss == max(ss), arr.ind = TRUE)
ss[idx[1], idx[2], drop = FALSE]
## End(Not run)
</code></pre>

<hr>
<h2 id='MarginalHomogeneityTests'>Marginal Homogeneity Tests</h2><span id='topic+mh_test'></span><span id='topic+mh_test.formula'></span><span id='topic+mh_test.table'></span><span id='topic+mh_test.SymmetryProblem'></span>

<h3>Description</h3>

<p>Testing the marginal homogeneity of a repeated measurements factor in a
complete block design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
mh_test(formula, data, subset = NULL, ...)
## S3 method for class 'table'
mh_test(object, ...)
## S3 method for class 'SymmetryProblem'
mh_test(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MarginalHomogeneityTests_+3A_formula">formula</code></td>
<td>

<p>a formula of the form <code>y ~ x | block</code> where <code>y</code> and <code>x</code> are
factors and <code>block</code> is an optional factor (which is generated
automatically if omitted).
</p>
</td></tr>
<tr><td><code id="MarginalHomogeneityTests_+3A_data">data</code></td>
<td>

<p>an optional data frame containing the variables in the model formula.
</p>
</td></tr>
<tr><td><code id="MarginalHomogeneityTests_+3A_subset">subset</code></td>
<td>

<p>an optional vector specifying a subset of observations to be used.  Defaults
to <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="MarginalHomogeneityTests_+3A_object">object</code></td>
<td>

<p>an object inheriting from classes <code>"table"</code> (with identical
<code>dimnames</code> components) or <code>"<a href="#topic+SymmetryProblem-class">SymmetryProblem</a>"</code>.
</p>
</td></tr>
<tr><td><code id="MarginalHomogeneityTests_+3A_...">...</code></td>
<td>

<p>further arguments to be passed to <code><a href="#topic+symmetry_test">symmetry_test</a>()</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mh_test()</code> provides the McNemar test, the Cochran <code class="reqn">Q</code> test, the
Stuart(-Maxwell) test and the Madansky test of interchangeability.  A general
description of these methods is given by Agresti (2002).
</p>
<p>The null hypothesis of marginal homogeneity is tested.  The response variable
and the measurement conditions are given by <code>y</code> and <code>x</code>,
respectively, and <code>block</code> is a factor where each level corresponds to
exactly one subject with repeated measurements.
</p>
<p>This procedure is known as the McNemar test (McNemar, 1947) when both <code>y</code>
and <code>x</code> are binary factors, as the Cochran <code class="reqn">Q</code> test (Cochran, 1950)
when <code>y</code> is a binary factor and <code>x</code> is a factor with an arbitrary
number of levels, as the Stuart(-Maxwell) test (Stuart, 1955; Maxwell, 1970)
when <code>y</code> is a factor with an arbitrary number of levels and <code>x</code> is a
binary factor, and as the Madansky test of interchangeability (Madansky, 1963),
which implies marginal homogeneity, when both <code>y</code> and <code>x</code> are
factors with an arbitrary number of levels.




</p>
<p>If <code>y</code> and/or <code>x</code> are ordered factors, the default scores,
<code>1:nlevels(y)</code> and <code>1:nlevels(x)</code>, respectively, can be altered
using the <code>scores</code> argument (see <code><a href="#topic+symmetry_test">symmetry_test</a>()</code>); this
argument can also be used to coerce nominal factors to class <code>"ordered"</code>.
If both <code>y</code> and <code>x</code> are ordered factors, a linear-by-linear
association test is computed and the direction of the alternative hypothesis
can be specified using the <code>alternative</code> argument.  This extension was
given by Birch (1965) who also discussed the situation when either the
response or the measurement condition is an ordered factor; see also White,
Landis and Cooper (1982).
</p>
<p>The conditional null distribution of the test statistic is used to obtain
<code class="reqn">p</code>-values and an asymptotic approximation of the exact distribution is
used by default (<code>distribution = "asymptotic"</code>).  Alternatively, the
distribution can be approximated via Monte Carlo resampling or computed
exactly for univariate two-sample problems by setting <code>distribution</code> to
<code>"approximate"</code> or <code>"exact"</code>, respectively.  See
<code><a href="#topic+asymptotic">asymptotic</a>()</code>, <code><a href="#topic+approximate">approximate</a>()</code> and
<code><a href="#topic+exact">exact</a>()</code> for details.
</p>


<h3>Value</h3>

<p>An object inheriting from class <code>"<a href="#topic+IndependenceTest-class">IndependenceTest</a>"</code>.
</p>


<h3>Note</h3>

<p>This function is currently computationally inefficient for data with a large
number of pairs or sets.
</p>


<h3>References</h3>

<p>Agresti, A.  (2002).  <em>Categorical Data Analysis</em>, Second Edition.
Hoboken, New Jersey: John Wiley &amp; Sons.
</p>



<p>Birch, M. W.  (1965).  The detection of partial association, II: The general
case.  <em>Journal of the Royal Statistical Society</em> B <b>27</b>(1),
111&ndash;124.  <a href="https://doi.org/10.1111/j.2517-6161.1965.tb00593.x">doi:10.1111/j.2517-6161.1965.tb00593.x</a>
</p>
<p>Cochran, W. G.  (1950).  The comparison of percentages in matched
samples.  <em>Biometrika</em> <b>37</b>(3/4), 256&ndash;266.
<a href="https://doi.org/10.1093/biomet/37.3-4.256">doi:10.1093/biomet/37.3-4.256</a>
</p>




<p>Madansky, A.  (1963).  Tests of homogeneity for correlated samples.
<em>Journal of the American Statistical Association</em> <b>58</b>(301),
97&ndash;119.  <a href="https://doi.org/10.1080/01621459.1963.10500835">doi:10.1080/01621459.1963.10500835</a>
</p>
<p>Maxwell, A. E.  (1970).  Comparing the classification of subjects by two
independent judges.  <em>British Journal of Psychiatry</em> <b>116</b>(535),
651&ndash;655.  <a href="https://doi.org/10.1192/bjp.116.535.651">doi:10.1192/bjp.116.535.651</a>
</p>
<p>McNemar, Q.  (1947).  Note on the sampling error of the difference between
correlated proportions or percentages.  <em>Psychometrika</em> <b>12</b>(2),
153&ndash;157.  <a href="https://doi.org/10.1007/BF02295996">doi:10.1007/BF02295996</a>
</p>
<p>Stuart, A.  (1955).  A test for homogeneity of the marginal distributions in a
two-way classification.  <em>Biometrika</em> <b>42</b>(3/4), 412&ndash;416.
<a href="https://doi.org/10.1093/biomet/42.3-4.412">doi:10.1093/biomet/42.3-4.412</a>
</p>
<p>White, A. A., Landis, J. R. and Cooper, M. M.  (1982).  A note on the
equivalence of several marginal homogeneity test criteria for categorical
data.  <em>International Statistical Review</em> <b>50</b>(1), 27&ndash;34.
<a href="https://doi.org/10.2307/1402457">doi:10.2307/1402457</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Performance of prime minister
## Agresti (2002, p. 409)
performance &lt;- matrix(
    c(794, 150,
       86, 570),
    nrow = 2, byrow = TRUE,
    dimnames = list(
         "First" = c("Approve", "Disprove"),
        "Second" = c("Approve", "Disprove")
    )
)
performance &lt;- as.table(performance)
diag(performance) &lt;- 0 # speed-up: only off-diagonal elements contribute

## Asymptotic McNemar Test
mh_test(performance)

## Exact McNemar Test
mh_test(performance, distribution = "exact")


## Effectiveness of different media for the growth of diphtheria
## Cochran (1950, Tab. 2)
cases &lt;- c(4, 2, 3, 1, 59)
n &lt;- sum(cases)
cochran &lt;- data.frame(
    diphtheria = factor(
        unlist(rep(list(c(1, 1, 1, 1),
                        c(1, 1, 0, 1),
                        c(0, 1, 1, 1),
                        c(0, 1, 0, 1),
                        c(0, 0, 0, 0)),
                   cases))
    ),
    media = factor(rep(LETTERS[1:4], n)),
    case =  factor(rep(seq_len(n), each = 4))
)

## Asymptotic Cochran Q test (Cochran, 1950, p. 260)
mh_test(diphtheria ~ media | case, data = cochran) # Q = 8.05

## Approximative Cochran Q test
mt &lt;- mh_test(diphtheria ~ media | case, data = cochran,
              distribution = approximate(nresample = 10000))
pvalue(mt)             # standard p-value
midpvalue(mt)          # mid-p-value
pvalue_interval(mt)    # p-value interval
size(mt, alpha = 0.05) # test size at alpha = 0.05 using the p-value


## Opinions on Pre- and Extramarital Sex
## Agresti (2002, p. 421)
opinions &lt;- c("Always wrong", "Almost always wrong",
              "Wrong only sometimes", "Not wrong at all")
PreExSex &lt;- matrix(
    c(144, 33, 84, 126,
        2,  4, 14,  29,
        0,  2,  6,  25,
        0,  0,  1,   5),
    nrow = 4,
    dimnames = list(
          "Premarital Sex" = opinions,
        "Extramarital Sex" = opinions
    )
)
PreExSex &lt;- as.table(PreExSex)

## Asymptotic Stuart test
mh_test(PreExSex)

## Asymptotic Stuart-Birch test
## Note: response as ordinal
mh_test(PreExSex, scores = list(response = 1:length(opinions)))


## Vote intention
## Madansky (1963, pp. 107-108)
vote &lt;- array(
    c(120, 1,  8, 2,   2,  1, 2, 1,  7,
        6, 2,  1, 1, 103,  5, 1, 4,  8,
       20, 3, 31, 1,   6, 30, 2, 1, 81),
    dim = c(3, 3, 3),
    dimnames = list(
          "July" = c("Republican", "Democratic", "Uncertain"),
        "August" = c("Republican", "Democratic", "Uncertain"),
          "June" = c("Republican", "Democratic", "Uncertain")
    )
)
vote &lt;- as.table(vote)

## Asymptotic Madansky test (Q = 70.77)
mh_test(vote)


## Cross-over study
## http://www.nesug.org/proceedings/nesug00/st/st9005.pdf
dysmenorrhea &lt;- array(
    c(6, 2, 1,  3, 1, 0,  1, 2, 1,
      4, 3, 0, 13, 3, 0,  8, 1, 1,
      5, 2, 2, 10, 1, 0, 14, 2, 0),
    dim = c(3, 3, 3),
    dimnames =  list(
          "Placebo" = c("None", "Moderate", "Complete"),
         "Low dose" = c("None", "Moderate", "Complete"),
        "High dose" = c("None", "Moderate", "Complete")
    )
)
dysmenorrhea &lt;- as.table(dysmenorrhea)

## Asymptotic Madansky-Birch test (Q = 53.76)
## Note: response as ordinal
mh_test(dysmenorrhea, scores = list(response = 1:3))

## Asymptotic Madansky-Birch test (Q = 47.29)
## Note: response and measurement conditions as ordinal
mh_test(dysmenorrhea, scores = list(response = 1:3,
                                    conditions = 1:3))
</code></pre>

<hr>
<h2 id='MaximallySelectedStatisticsTests'>Generalized Maximally Selected Statistics</h2><span id='topic+maxstat_test'></span><span id='topic+maxstat_test.formula'></span><span id='topic+maxstat_test.table'></span><span id='topic+maxstat_test.IndependenceProblem'></span>

<h3>Description</h3>

<p>Testing the independence of two sets of variables measured on arbitrary scales
against cutpoint alternatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
maxstat_test(formula, data, subset = NULL, weights = NULL, ...)
## S3 method for class 'table'
maxstat_test(object, ...)
## S3 method for class 'IndependenceProblem'
maxstat_test(object, teststat = c("maximum", "quadratic"),
             distribution = c("asymptotic", "approximate", "none"),
             minprob = 0.1, maxprob = 1 - minprob, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="MaximallySelectedStatisticsTests_+3A_formula">formula</code></td>
<td>

<p>a formula of the form <code>y1 + ... + yq ~ x1 + ... + xp | block</code> where
<code>y1</code>, ..., <code>yq</code> and <code>x1</code>, ..., <code>xp</code> are measured
on arbitrary scales (nominal, ordinal or continuous with or without
censoring) and <code>block</code> is an optional factor for stratification.
</p>
</td></tr>
<tr><td><code id="MaximallySelectedStatisticsTests_+3A_data">data</code></td>
<td>

<p>an optional data frame containing the variables in the model formula.
</p>
</td></tr>
<tr><td><code id="MaximallySelectedStatisticsTests_+3A_subset">subset</code></td>
<td>

<p>an optional vector specifying a subset of observations to be used.  Defaults
to <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="MaximallySelectedStatisticsTests_+3A_weights">weights</code></td>
<td>

<p>an optional formula of the form <code>~ w</code> defining integer valued case
weights for each observation.  Defaults to <code>NULL</code>, implying equal
weight for all observations.
</p>
</td></tr>
<tr><td><code id="MaximallySelectedStatisticsTests_+3A_object">object</code></td>
<td>

<p>an object inheriting from classes <code>"table"</code> or
<code>"<a href="#topic+IndependenceProblem-class">IndependenceProblem</a>"</code>.
</p>
</td></tr>
<tr><td><code id="MaximallySelectedStatisticsTests_+3A_teststat">teststat</code></td>
<td>

<p>a character, the type of test statistic to be applied: either a maximum
statistic (<code>"maximum"</code>, default) or a quadratic form
(<code>"quadratic"</code>).
</p>
</td></tr>
<tr><td><code id="MaximallySelectedStatisticsTests_+3A_distribution">distribution</code></td>
<td>

<p>a character, the conditional null distribution of the test statistic can be
approximated by its asymptotic distribution (<code>"asymptotic"</code>, default)
or via Monte Carlo resampling (<code>"approximate"</code>).  Alternatively, the
functions <code><a href="#topic+asymptotic">asymptotic</a></code> or <code><a href="#topic+approximate">approximate</a></code> can be used.
Computation of the null distribution can be suppressed by specifying
<code>"none"</code>.
</p>
</td></tr>
<tr><td><code id="MaximallySelectedStatisticsTests_+3A_minprob">minprob</code></td>
<td>

<p>a numeric, a fraction between 0 and 0.5 specifying that cutpoints only
greater than the <code>minprob</code> <code class="reqn">\cdot</code> 100% quantile of <code>x1</code>,
..., <code>xp</code> are considered.  Defaults to <code>0.1</code>.
</p>
</td></tr>
<tr><td><code id="MaximallySelectedStatisticsTests_+3A_maxprob">maxprob</code></td>
<td>

<p>a numeric, a fraction between 0.5 and 1 specifying that cutpoints only
smaller than the <code>maxprob</code> <code class="reqn">\cdot</code> 100% quantile of <code>x1</code>,
..., <code>xp</code> are considered.  Defaults to <code>1 - minprob</code>.
</p>
</td></tr>
<tr><td><code id="MaximallySelectedStatisticsTests_+3A_...">...</code></td>
<td>

<p>further arguments to be passed to <code><a href="#topic+independence_test">independence_test</a>()</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>maxstat_test()</code> provides generalized maximally selected statistics.  The
family of maximally selected statistics encompasses a large collection of
procedures used for the estimation of simple cutpoint models including, but
not limited to, maximally selected <code class="reqn">\chi^2</code> statistics, maximally
selected Cochran-Armitage statistics, maximally selected rank statistics and
maximally selected statistics for multiple covariates.  A general description
of these methods is given by Hothorn and Zeileis (2008).
</p>
<p>The null hypothesis of independence, or conditional independence given
<code>block</code>, between <code>y1</code>, ..., <code>yq</code> and <code>x1</code>, ...,
<code>xp</code> is tested against cutpoint alternatives.  All possible partitions
into two groups are evaluated for each unordered covariate <code>x1</code>, ...,
<code>xp</code>, whereas only order-preserving binary partitions are evaluated for
ordered or numeric covariates.  The cutpoint is then a set of levels defining
one of the two groups.
</p>
<p>If both response and covariate is univariable, say <code>y1</code> and <code>x1</code>,
this procedure is known as maximally selected <code class="reqn">\chi^2</code> statistics
(Miller and Siegmund, 1982) when <code>y1</code> is a binary factor and <code>x1</code> is
a numeric variable, and as maximally selected rank statistics when <code>y1</code>
is a rank transformed numeric variable and <code>x1</code> is a numeric variable
(Lausen and Schumacher, 1992).  Lausen <em>et al.</em> (2004) introduced
maximally selected statistics for a univariable numeric response and multiple
numeric covariates <code>x1</code>, ..., <code>xp</code>.
</p>
<p>If, say, <code>y1</code> and/or <code>x1</code> are ordered factors, the default scores,
<code>1:nlevels(y1)</code> and <code>1:nlevels(x1)</code>, respectively, can be altered
using the <code>scores</code> argument (see <code><a href="#topic+independence_test">independence_test</a>()</code>); this
argument can also be used to coerce nominal factors to class <code>"ordered"</code>.
If both, say, <code>y1</code> and <code>x1</code> are ordered factors, a linear-by-linear
association test is computed and the direction of the alternative hypothesis
can be specified using the <code>alternative</code> argument.  The particular
extension to the case of a univariable ordered response and a univariable
numeric covariate was given by Betensky and Rabinowitz (1999) and
is known as maximally selected Cochran-Armitage statistics.
</p>
<p>The conditional null distribution of the test statistic is used to obtain
<code class="reqn">p</code>-values and an asymptotic approximation of the exact distribution is
used by default (<code>distribution = "asymptotic"</code>).  Alternatively, the
distribution can be approximated via Monte Carlo resampling by setting
<code>distribution</code> to <code>"approximate"</code>.  See <code><a href="#topic+asymptotic">asymptotic</a>()</code>
and <code><a href="#topic+approximate">approximate</a>()</code> for details.
</p>


<h3>Value</h3>

<p>An object inheriting from class <code>"<a href="#topic+IndependenceTest-class">IndependenceTest</a>"</code>.
</p>


<h3>Note</h3>

<p>Starting with <span class="pkg">coin</span> version 1.1-0, maximum statistics and quadratic forms
can no longer be specified using <code>teststat = "maxtype"</code> and
<code>teststat = "quadtype"</code>, respectively (as was used in versions prior to
0.4-5).
</p>


<h3>References</h3>

<p>Betensky, R. A. and Rabinowitz, D.  (1999).  Maximally selected
<code class="reqn">\chi^2</code> statistics for <code class="reqn">k \times 2</code> tables.
<em>Biometrics</em> <b>55</b>(1), 317&ndash;320.
<a href="https://doi.org/10.1111/j.0006-341X.1999.00317.x">doi:10.1111/j.0006-341X.1999.00317.x</a>
</p>
<p>Hothorn, T. and Lausen, B.  (2003).  On the exact distribution of maximally
selected rank statistics.  <em>Computational Statistics &amp; Data Analysis</em>
<b>43</b>(2), 121&ndash;137.  <a href="https://doi.org/10.1016/S0167-9473%2802%2900225-6">doi:10.1016/S0167-9473(02)00225-6</a>
</p>
<p>Hothorn, T. and Zeileis, A.  (2008).  Generalized maximally selected
statistics.  <em>Biometrics</em> <b>64</b>(4), 1263&ndash;1269.
<a href="https://doi.org/10.1111/j.1541-0420.2008.00995.x">doi:10.1111/j.1541-0420.2008.00995.x</a>
</p>
<p>Lausen, B., Hothorn, T., Bretz, F. and Schumacher, M.  (2004).  Assessment of
optimal selected prognostic factors.  <em>Biometrical Journal</em> <b>46</b>(3),
364&ndash;374.  <a href="https://doi.org/10.1002/bimj.200310030">doi:10.1002/bimj.200310030</a>
</p>
<p>Lausen, B. and Schumacher, M.  (1992).  Maximally selected rank statistics.
<em>Biometrics</em> <b>48</b>(1), 73&ndash;85.  <a href="https://doi.org/10.2307/2532740">doi:10.2307/2532740</a>
</p>
<p>Miller, R. and Siegmund, D.  (1982).  Maximally selected chi square
statistics.  <em>Biometrics</em> <b>38</b>(4), 1011&ndash;1016.
<a href="https://doi.org/10.2307/2529881">doi:10.2307/2529881</a>
</p>
<p>Müller, J. and Hothorn, T.  (2004).  Maximally selected
two-sample statistics as a new tool for the identification and assessment of
habitat factors with an application to breeding bird communities in oak
forests.  <em>European Journal of Forest Research</em> <b>123</b>(3), 219&ndash;228.
<a href="https://doi.org/10.1007/s10342-004-0035-5">doi:10.1007/s10342-004-0035-5</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Tree pipit data (Mueller and Hothorn, 2004)
## Asymptotic maximally selected statistics
maxstat_test(counts ~ coverstorey, data = treepipit)

## Asymptotic maximally selected statistics
## Note: all covariates simultaneously
mt &lt;- maxstat_test(counts ~ ., data = treepipit)
mt@estimates$estimate


## Malignant arrythmias data (Hothorn and Lausen, 2003, Sec. 7.2)
## Asymptotic maximally selected statistics
maxstat_test(Surv(time, event) ~  EF, data = hohnloser,
             ytrafo = function(data)
                 trafo(data, surv_trafo = function(y)
                     logrank_trafo(y, ties.method = "Hothorn-Lausen")))


## Breast cancer data (Hothorn and Lausen, 2003, Sec. 7.3)
## Asymptotic maximally selected statistics
data("sphase", package = "TH.data")
maxstat_test(Surv(RFS, event) ~  SPF, data = sphase,
             ytrafo = function(data)
                 trafo(data, surv_trafo = function(y)
                     logrank_trafo(y, ties.method = "Hothorn-Lausen")))


## Job satisfaction data (Agresti, 2002, p. 288, Tab. 7.8)
## Asymptotic maximally selected statistics
maxstat_test(jobsatisfaction)

## Asymptotic maximally selected statistics
## Note: 'Job.Satisfaction' and 'Income' as ordinal
maxstat_test(jobsatisfaction,
             scores = list("Job.Satisfaction" = 1:4,
                           "Income" = 1:4))
</code></pre>

<hr>
<h2 id='mercuryfish'>Chromosomal Effects of Mercury-Contaminated Fish Consumption</h2><span id='topic+mercuryfish'></span>

<h3>Description</h3>

<p>The mercury level in blood, the proportion of cells with abnormalities, and
the proportion of cells with chromosome aberrations in consumers of
mercury-contaminated fish and a control group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mercuryfish</code></pre>


<h3>Format</h3>

<p>A data frame with 39 observations on 4 variables.
</p>

<dl>
<dt><code>group</code></dt><dd>
<p>a factor with levels <code>"control"</code> and <code>"exposed"</code>.
</p>
</dd>
<dt><code>mercury</code></dt><dd>
<p>mercury level in blood.
</p>
</dd>
<dt><code>abnormal</code></dt><dd>
<p>the proportion of cells with structural abnormalities.
</p>
</dd>
<dt><code>ccells</code></dt><dd>
<p>the proportion of <code class="reqn">C_u</code> cells, i.e., cells with asymmetrical or
incomplete-symmetrical chromosome aberrations.
</p>
</dd>
</dl>



<h3>Details</h3>

<p>Control subjects (<code>"control"</code>) and subjects who ate contaminated fish for
more than three years (<code>"exposed"</code>) are under study.
</p>
<p>Rosenbaum (1994) proposed a coherence criterion defining a partial ordering,
i.e., an observation is smaller than another when all responses are smaller,
and a score reflecting the &ldquo;ranking&rdquo; is attached to each observation.
The corresponding partially ordered set (POSET) test can be used to test if
the distribution of the scores differ between the groups.  Alternatively, a
multivariate test can be applied.
</p>


<h3>Source</h3>

<p>Skerfving, S., Hansson, K., Mangs, C., Lindsten, J. and Ryman, N.  (1974).
Methylmercury-induced chromosome damage in men.  <em>Environmental Research</em>
<b>7</b>(1), 83&ndash;98.  <a href="https://doi.org/10.1016/0013-9351%2874%2990078-4">doi:10.1016/0013-9351(74)90078-4</a>
</p>


<h3>References</h3>

<p>Hothorn, T., Hornik, K., van de Wiel, M. A. and Zeileis, A.  (2006).  A Lego
system for conditional inference.  <em>The American Statistician</em>
<b>60</b>(3), 257&ndash;263.  <a href="https://doi.org/10.1198/000313006X118430">doi:10.1198/000313006X118430</a>
</p>
<p>Rosenbaum, P. R. (1994).  Coherence in observational studies.
<em>Biometrics</em> <b>50</b>(2), 368&ndash;374.  <a href="https://doi.org/10.2307/2533380">doi:10.2307/2533380</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Coherence criterion
coherence &lt;- function(data) {
    x &lt;- as.matrix(data)
    matrix(apply(x, 1, function(y)
        sum(colSums(t(x) &lt; y) == ncol(x)) -
            sum(colSums(t(x) &gt; y) == ncol(x))), ncol = 1)
}

## Asymptotic POSET test
poset &lt;- independence_test(mercury + abnormal + ccells ~ group,
                           data = mercuryfish, ytrafo = coherence)

## Linear statistic (T in the notation of Rosenbaum, 1994)
statistic(poset, type = "linear")

## Expectation
expectation(poset)

## Variance
## Note: typo in Rosenbaum (1994, p. 371, Sec. 2, last paragraph)
variance(poset)

## Standardized statistic
statistic(poset)

## P-value
pvalue(poset)

## Exact POSET test
independence_test(mercury + abnormal + ccells ~ group,
                  data = mercuryfish, ytrafo = coherence,
                  distribution = "exact")

## Asymptotic multivariate test
mvtest &lt;- independence_test(mercury + abnormal + ccells ~ group,
                            data = mercuryfish)

## Global p-value
pvalue(mvtest)

## Single-step adjusted p-values
pvalue(mvtest, method = "single-step")

## Step-down adjusted p-values
pvalue(mvtest, method = "step-down")
</code></pre>

<hr>
<h2 id='neuropathy'>Acute Painful Diabetic Neuropathy</h2><span id='topic+neuropathy'></span>

<h3>Description</h3>

<p>The logarithm of the ratio of pain scores measured at baseline and after four
weeks in a control group and a treatment group.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>neuropathy</code></pre>


<h3>Format</h3>

<p>A data frame with 58 observations on 2 variables.
</p>

<dl>
<dt><code>pain</code></dt><dd>
<p>pain scores: ln(baseline / final).
</p>
</dd>
<dt><code>group</code></dt><dd>
<p>a factor with levels <code>"control"</code> and <code>"treat"</code>.
</p>
</dd>
</dl>



<h3>Details</h3>

<p>Data from Conover and Salsburg (1988, Tab. 1).
</p>


<h3>Source</h3>

<p>Conover, W. J. and Salsburg, D. S.  (1988).  Locally most powerful tests for
detecting treatment effects when only a subset of patients can be expected to
&ldquo;respond&rdquo; to treatment.  <em>Biometrics</em> <b>44</b>(1), 189&ndash;196.
<a href="https://doi.org/10.2307/2531906">doi:10.2307/2531906</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Conover and Salsburg (1988, Tab. 2)

## One-sided approximative Fisher-Pitman test
oneway_test(pain ~ group, data = neuropathy,
            alternative = "less",
            distribution = approximate(nresample = 10000))

## One-sided approximative Wilcoxon-Mann-Whitney test
wilcox_test(pain ~ group, data = neuropathy,
            alternative = "less",
            distribution = approximate(nresample = 10000))

## One-sided approximative Conover-Salsburg test
oneway_test(pain ~ group, data = neuropathy,
            alternative = "less",
            distribution = approximate(nresample = 10000),
            ytrafo = function(data)
                trafo(data, numeric_trafo = consal_trafo))

## One-sided approximative maximum test for a range of 'a' values
it &lt;- independence_test(pain ~ group, data = neuropathy,
                        alternative = "less",
                        distribution = approximate(nresample = 10000),
                        ytrafo = function(data)
                            trafo(data, numeric_trafo = function(y)
                                consal_trafo(y, a = 2:7)))
pvalue(it, method = "single-step")
</code></pre>

<hr>
<h2 id='NullDistribution'>Specification of the Reference Distribution</h2><span id='topic+asymptotic'></span><span id='topic+approximate'></span><span id='topic+exact'></span>

<h3>Description</h3>

<p>Specification of the asymptotic, approximative (Monte Carlo) and exact
reference distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asymptotic(maxpts = 25000, abseps = 0.001, releps = 0)
approximate(nresample = 10000L, parallel = c("no", "multicore", "snow"),
            ncpus = 1L, cl = NULL, B)
exact(algorithm = c("auto", "shift", "split-up"), fact = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NullDistribution_+3A_maxpts">maxpts</code></td>
<td>

<p>an integer, the maximum number of function values.  Defaults to
<code>25000</code>.
</p>
</td></tr>
<tr><td><code id="NullDistribution_+3A_abseps">abseps</code></td>
<td>

<p>a numeric, the absolute error tolerance.  Defaults to <code>0.001</code>.
</p>
</td></tr>
<tr><td><code id="NullDistribution_+3A_releps">releps</code></td>
<td>

<p>a numeric, the relative error tolerance.  Defaults to <code>0</code>.
</p>
</td></tr>
<tr><td><code id="NullDistribution_+3A_nresample">nresample</code></td>
<td>

<p>a positive integer, the number of Monte Carlo replicates used for the
computation of the approximative reference distribution.  Defaults to
<code>10000L</code>.
</p>
</td></tr>
<tr><td><code id="NullDistribution_+3A_parallel">parallel</code></td>
<td>

<p>a character, the type of parallel operation: either <code>"no"</code> (default),
<code>"multicore"</code> or <code>"snow"</code>.
</p>
</td></tr>
<tr><td><code id="NullDistribution_+3A_ncpus">ncpus</code></td>
<td>

<p>an integer, the number of processes to be used in parallel operation.
Defaults to <code>1L</code>.
</p>
</td></tr>
<tr><td><code id="NullDistribution_+3A_cl">cl</code></td>
<td>

<p>an object inheriting from class <code>"cluster"</code>, specifying an optional
<span class="pkg">parallel</span> or <span class="pkg">snow</span> cluster if <code>parallel = "snow"</code>.  Defaults
to <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="NullDistribution_+3A_b">B</code></td>
<td>

<p>deprecated, use <code>nresample</code> instead.
</p>
</td></tr>
<tr><td><code id="NullDistribution_+3A_algorithm">algorithm</code></td>
<td>

<p>a character, the algorithm used for the computation of the exact reference
distribution: either <code>"auto"</code> (default), <code>"shift"</code> or
<code>"split-up"</code>.
</p>
</td></tr>
<tr><td><code id="NullDistribution_+3A_fact">fact</code></td>
<td>

<p>an integer to multiply the response values with.  Defaults to <code>NULL</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>asymptotic()</code>, <code>approximate()</code> and <code>exact()</code> can be supplied
to the <code>distribution</code> argument of, e.g.,
<code><a href="#topic+independence_test">independence_test</a>()</code> to provide control of the specification of
the asymptotic, approximative (Monte Carlo) and exact reference distribution,
respectively.
</p>
<p>The asymptotic reference distribution is computed using a randomised
quasi-Monte Carlo method (Genz and Bretz, 2009) and is applicable to arbitrary
covariance structures with dimensions up to 1000.  See
<code><a href="mvtnorm.html#topic+algorithms">GenzBretz</a>()</code> in package <span class="pkg">mvtnorm</span> for
details on <code>maxpts</code>, <code>abseps</code> and <code>releps</code>.
</p>
<p>The approximative (Monte Carlo) reference distribution is obtained by a
conditional Monte Carlo procedure, i.e., by computing the test statistic for
<code>nresample</code> random samples from all admissible permutations of the
response <code class="reqn">\bf{Y}</code> within each block (Hothorn <em>et al.</em>, 2008).  By
default, the distribution is computed using serial operation
(<code>parallel = "no"</code>).  The use of parallel operation is specified by
setting <code>parallel</code> to either <code>"multicore"</code> (not available for MS
Windows) or <code>"snow"</code>.  In the latter case, if <code>cl = NULL</code> (default)
a cluster with <code>ncpus</code> processes is created on the local machine unless a
default cluster has been registered (see
<code><a href="parallel.html#topic+makeCluster">setDefaultCluster</a>()</code> in package
<span class="pkg">parallel</span>) in which case that gets used instead.  Alternatively, the use
of an optional <span class="pkg">parallel</span> or <span class="pkg">snow</span> cluster can be specified by
<code>cl</code>.  See &lsquo;Examples&rsquo; and package <span class="pkg">parallel</span> for details on
parallel operation.
</p>
<p>The exact reference distribution, currently available for univariate
two-sample problems only, is computed using either the shift algorithm
(Streitberg and Röhmel, 1984, 1986, 1987) or the split-up
algorithm (van de Wiel, 2001).  The shift algorithm handles blocks pertaining
to, e.g., pre- and post-stratification, but can only be used with positive
integer-valued scores <code class="reqn">h(\bf{Y})</code>.  The split-up algorithm can be
used with non-integer scores, but does not handle blocks.  By default, an
automatic choice is made (<code>algorithm = "auto"</code>) but the shift and
split-up algorithms can be selected by setting <code>algorithm</code> to
<code>"shift"</code> or <code>"split-up"</code>, respectively.
</p>


<h3>Note</h3>

<p>Starting with <span class="pkg">coin</span> version 1.1-0, the default for <code>algorithm</code> is
<code>"auto"</code>, having identical behaviour to <code>"shift"</code> in previous
versions.  In earlier versions of the package, <code>algorithm = "shift"</code>
silently switched to the split-up algorithm if non-integer scores were
detected, whereas the current version exits with a warning.
</p>
<p>In versions of <span class="pkg">coin</span> prior to 1.3-0, the number of Monte Carlo replicates
in <code>approximate()</code> was specified using the now deprecated <code>B</code>
argument.  <strong>This will be made defunct and removed in a future release.</strong>
It has been replaced by the <code>nresample</code> argument (for conformity with the
<span class="pkg">libcoin</span>, <span class="pkg">party</span> and <span class="pkg">partykit</span> packages).
</p>


<h3>References</h3>

<p>Genz, A. and Bretz, F.  (2009).  <em>Computation of Multivariate Normal and
t Probabilities</em>.  Heidelberg: Springer-Verlag.
</p>
<p>Hothorn, T., Hornik, K., van de Wiel, M. A. and Zeileis, A.  (2008).
Implementing a class of permutation tests: The coin package.  <em>Journal of
Statistical Software</em> <b>28</b>(8), 1&ndash;23.  <a href="https://doi.org/10.18637/jss.v028.i08">doi:10.18637/jss.v028.i08</a>
</p>
<p>Streitberg, B. and Röhmel, J.  (1984).  Exact nonparametrics
in APL.  <em>APL Quote Quad</em> <b>14</b>(4), 313&ndash;325.
<a href="https://doi.org/10.1145/384283.801115">doi:10.1145/384283.801115</a>
</p>
<p>Streitberg, B. and Röhmel, J.  (1986).  Exact distributions
for permutations and rank tests: an introduction to some recently published
algorithms.  <em>Statistical Software Newsletter</em> <b>12</b>(1), 10&ndash;17.
</p>
<p>Streitberg, B. and Röhmel, J.  (1987).  Exakte verteilungen
für rang- und randomisierungstests im allgemeinen
c-stichprobenfall.  <em>EDV in Medizin und Biologie</em> <b>18</b>(1), 12&ndash;19.
</p>
<p>van de Wiel, M. A.  (2001).  The split-up algorithm: a fast symbolic method
for computing p-values of distribution-free statistics.  <em>Computational
Statistics</em> <b>16</b>(4), 519&ndash;538.  <a href="https://doi.org/10.1007/s180-001-8328-6">doi:10.1007/s180-001-8328-6</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Approximative (Monte Carlo) Cochran-Mantel-Haenszel test

## Serial operation
set.seed(123)
cmh_test(disease ~ smoking | gender, data = alzheimer,
         distribution = approximate(nresample = 100000))

## Not run: 
## Multicore with 8 processes (not for MS Windows)
set.seed(123, kind = "L'Ecuyer-CMRG")
cmh_test(disease ~ smoking | gender, data = alzheimer,
         distribution = approximate(nresample = 100000,
                                    parallel = "multicore", ncpus = 8))

## Automatic PSOCK cluster with 4 processes
set.seed(123, kind = "L'Ecuyer-CMRG")
cmh_test(disease ~ smoking | gender, data = alzheimer,
         distribution = approximate(nresample = 100000,
                                    parallel = "snow", ncpus = 4))

## Registered FORK cluster with 12 processes (not for MS Windows)
fork12 &lt;- parallel::makeCluster(12, "FORK") # set-up cluster
parallel::setDefaultCluster(fork12) # register default cluster
set.seed(123, kind = "L'Ecuyer-CMRG")
cmh_test(disease ~ smoking | gender, data = alzheimer,
         distribution = approximate(nresample = 100000,
                                    parallel = "snow"))
parallel::stopCluster(fork12) # clean-up

## User-specified PSOCK cluster with 8 processes
psock8 &lt;- parallel::makeCluster(8, "PSOCK") # set-up cluster
set.seed(123, kind = "L'Ecuyer-CMRG")
cmh_test(disease ~ smoking | gender, data = alzheimer,
         distribution = approximate(nresample = 100000,
                                    parallel = "snow", cl = psock8))
parallel::stopCluster(psock8) # clean-up
## End(Not run)
</code></pre>

<hr>
<h2 id='NullDistribution-class'>Class <code>"NullDistribution"</code> and Its Subclasses</h2><span id='topic+NullDistribution-class'></span><span id='topic+ApproxNullDistribution-class'></span><span id='topic+AsymptNullDistribution-class'></span><span id='topic+ExactNullDistribution-class'></span>

<h3>Description</h3>

<p>Objects of class <code>"NullDistribution"</code> and its subclasses
<code>"ApproxNullDistribution"</code>, <code>"AsymptNullDistribution"</code> and
<code>"ExactNullDistribution"</code> represent the reference distribution.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form </p>
<pre>     new("NullDistribution", ...),

     new("ApproxNullDistribution", ...),

     new("AsymptNullDistribution", ...)</pre>
<p>and </p>
<pre>     new("ExactNullDistribution", ...).</pre>


<h3>Slots</h3>

<p>For objects of classes <code>"NullDistribution"</code>,
<code>"ApproxNullDistribution"</code>, <code>"AsymptNullDistribution"</code> or
<code>"ExactNullDistribution"</code>:
</p>

<dl>
<dt><code>name</code>:</dt><dd>
<p>Object of class <code>"character"</code>.  The name of the reference
distribution.
</p>
</dd>
<dt><code>p</code>:</dt><dd>
<p>Object of class <code>"function"</code>.  The distribution function of the
reference distribution.
</p>
</dd>
<dt><code>pvalue</code>:</dt><dd>
<p>Object of class <code>"function"</code>.  The <code class="reqn">p</code>-value function of the
reference distribution.
</p>
</dd>
<dt><code>parameters</code>:</dt><dd>
<p>Object of class <code>"list"</code>.  Additional parameters.
</p>
</dd>
<dt><code>support</code>:</dt><dd>
<p>Object of class <code>"function"</code>.  The support of the reference
distribution.
</p>
</dd>
<dt><code>d</code>:</dt><dd>
<p>Object of class <code>"function"</code>.  The density function of the reference
distribution.
</p>
</dd>
<dt><code>q</code>:</dt><dd>
<p>Object of class <code>"function"</code>.  The quantile function of the reference
distribution.
</p>
</dd>
<dt><code>midpvalue</code>:</dt><dd>
<p>Object of class <code>"function"</code>.  The mid-<code class="reqn">p</code>-value function of the
reference distribution.
</p>
</dd>
<dt><code>pvalueinterval</code>:</dt><dd>
<p>Object of class <code>"function"</code>.  The <code class="reqn">p</code>-value interval function of
the reference distribution.
</p>
</dd>
<dt><code>size</code>:</dt><dd>
<p>Object of class <code>"function"</code>.  The size function of the reference
distribution.
</p>
</dd>
</dl>

<p>Additionally, for objects of classes <code>"ApproxNullDistribution"</code> or
<code>"AsymptNullDistribution"</code>:
</p>

<dl>
<dt><code>seed</code>:</dt><dd>
<p>Object of class <code>"integer"</code>.  The random number generator state
(i.e., the value of <code>.Random.seed</code>).
</p>
</dd>
</dl>

<p>Additionally, for objects of class <code>"ApproxNullDistribution"</code>:
</p>

<dl>
<dt><code>nresample</code>:</dt><dd>
<p>Object of class <code>"numeric"</code>.  The number of Monte Carlo replicates.
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>For objects of class <code>"NullDistribution"</code>: <br />
Class <code>"<a href="#topic+PValue-class">PValue</a>"</code>, directly.
</p>
<p>For objects of classes <code>"ApproxNullDistribution"</code>,
<code>"AsymptNullDistribution"</code> or <code>"ExactNullDistribution"</code>: <br />
Class <code>"NullDistribution"</code>, directly. <br />
Class <code>"<a href="#topic+PValue-class">PValue</a>"</code>, by class <code>"NullDistribution"</code>,
distance 2.
</p>


<h3>Known Subclasses</h3>

<p>For objects of class <code>"NullDistribution"</code>: <br />
Class <code>"ApproxNullDistribution"</code>, directly. <br />
Class <code>"AsymptNullDistribution"</code>, directly. <br />
Class <code>"ExactNullDistribution"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>dperm</dt><dd>
<p><code>signature(object = "NullDistribution")</code>: See the documentation for
<code><a href="#topic+dperm">dperm</a>()</code> for details.
</p>
</dd>
<dt>midpvalue</dt><dd>
<p><code>signature(object = "NullDistribution")</code>: See the documentation for
<code><a href="#topic+midpvalue">midpvalue</a>()</code> for details.
</p>
</dd>
<dt>midpvalue</dt><dd>
<p><code>signature(object = "ApproxNullDistribution")</code>: See the documentation
for <code><a href="#topic+midpvalue">midpvalue</a>()</code> for details.
</p>
</dd>
<dt>pperm</dt><dd>
<p><code>signature(object = "NullDistribution")</code>: See the documentation for
<code><a href="#topic+pperm">pperm</a>()</code> for details.
</p>
</dd>
<dt>pvalue</dt><dd>
<p><code>signature(object = "NullDistribution")</code>: See the documentation for
<code><a href="#topic+pvalue">pvalue</a>()</code> for details.
</p>
</dd>
<dt>pvalue</dt><dd>
<p><code>signature(object = "ApproxNullDistribution")</code>: See the documentation
for <code><a href="#topic+pvalue">pvalue</a>()</code> for details.
</p>
</dd>
<dt>pvalue_interval</dt><dd>
<p><code>signature(object = "NullDistribution")</code>: See the documentation for
<code><a href="#topic+pvalue_interval">pvalue_interval</a>()</code> for details.
</p>
</dd>
<dt>qperm</dt><dd>
<p><code>signature(object = "NullDistribution")</code>: See the documentation for
<code><a href="#topic+qperm">qperm</a>()</code> for details.
</p>
</dd>
<dt>rperm</dt><dd>
<p><code>signature(object = "NullDistribution")</code>: See the documentation for
<code><a href="#topic+rperm">rperm</a>()</code> for details.
</p>
</dd>
<dt>size</dt><dd>
<p><code>signature(object = "NullDistribution")</code>: See the documentation for
<code><a href="#topic+size">size</a>()</code> for details.
</p>
</dd>
<dt>support</dt><dd>
<p><code>signature(object = "NullDistribution")</code>: See the documentation for
<code><a href="#topic+support">support</a>()</code> for details.
</p>
</dd>
</dl>


<hr>
<h2 id='NullDistribution-methods'>Computation of the Reference Distribution</h2><span id='topic+AsymptNullDistribution'></span><span id='topic+AsymptNullDistribution-methods'></span><span id='topic+AsymptNullDistribution+2CMaxTypeIndependenceTestStatistic-method'></span><span id='topic+AsymptNullDistribution+2CQuadTypeIndependenceTestStatistic-method'></span><span id='topic+AsymptNullDistribution+2CScalarIndependenceTestStatistic-method'></span><span id='topic+ApproxNullDistribution'></span><span id='topic+ApproxNullDistribution-methods'></span><span id='topic+ApproxNullDistribution+2CMaxTypeIndependenceTestStatistic-method'></span><span id='topic+ApproxNullDistribution+2CQuadTypeIndependenceTestStatistic-method'></span><span id='topic+ApproxNullDistribution+2CScalarIndependenceTestStatistic-method'></span><span id='topic+ExactNullDistribution'></span><span id='topic+ExactNullDistribution-methods'></span><span id='topic+ExactNullDistribution+2CQuadTypeIndependenceTestStatistic-method'></span><span id='topic+ExactNullDistribution+2CScalarIndependenceTestStatistic-method'></span>

<h3>Description</h3>

<p>Methods for computation of the asymptotic, approximative (Monte Carlo) and
exact reference distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'MaxTypeIndependenceTestStatistic'
AsymptNullDistribution(object, ...)
## S4 method for signature 'QuadTypeIndependenceTestStatistic'
AsymptNullDistribution(object, ...)
## S4 method for signature 'ScalarIndependenceTestStatistic'
AsymptNullDistribution(object, ...)

## S4 method for signature 'MaxTypeIndependenceTestStatistic'
ApproxNullDistribution(object, nresample = 10000L, B, ...)
## S4 method for signature 'QuadTypeIndependenceTestStatistic'
ApproxNullDistribution(object, nresample = 10000L, B, ...)
## S4 method for signature 'ScalarIndependenceTestStatistic'
ApproxNullDistribution(object, nresample = 10000L, B, ...)

## S4 method for signature 'QuadTypeIndependenceTestStatistic'
ExactNullDistribution(object, algorithm = c("auto", "shift", "split-up"), ...)
## S4 method for signature 'ScalarIndependenceTestStatistic'
ExactNullDistribution(object, algorithm = c("auto", "shift", "split-up"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NullDistribution-methods_+3A_object">object</code></td>
<td>

<p>an object from which the asymptotic, approximative (Monte Carlo) or exact
reference distribution can be computed.
</p>
</td></tr>
<tr><td><code id="NullDistribution-methods_+3A_nresample">nresample</code></td>
<td>

<p>a positive integer, the number of Monte Carlo replicates used for the
computation of the approximative reference distribution.  Defaults to
<code>10000L</code>.
</p>
</td></tr>
<tr><td><code id="NullDistribution-methods_+3A_b">B</code></td>
<td>

<p>deprecated, use <code>nresample</code> instead.
</p>
</td></tr>
<tr><td><code id="NullDistribution-methods_+3A_algorithm">algorithm</code></td>
<td>

<p>a character, the algorithm used for the computation of the exact reference
distribution: either <code>"auto"</code> (default), <code>"shift"</code> or
<code>"split-up"</code>.
</p>
</td></tr>
<tr><td><code id="NullDistribution-methods_+3A_...">...</code></td>
<td>

<p>further arguments to be passed to or from methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The methods <code>AsymptNullDistribution</code>, <code>ApproxNullDistribution</code> and
<code>ExactNullDistribution</code> compute the asymptotic, approximative (Monte
Carlo) and exact reference distribution, respectively.
</p>


<h3>Value</h3>

<p>An object of class <code>"<a href="#topic+AsymptNullDistribution-class">AsymptNullDistribution</a>"</code>,
<code>"<a href="#topic+ApproxNullDistribution-class">ApproxNullDistribution</a>"</code> or
<code>"<a href="#topic+ExactNullDistribution-class">ExactNullDistribution</a>"</code>.
</p>


<h3>Note</h3>

<p>In versions of <span class="pkg">coin</span> prior to 1.3-0, the number of Monte Carlo replicates
in <code>ApproxNullDistribution()</code> was specified using the now deprecated
<code>B</code> argument.  <strong>This will be made defunct and removed in a future
release.</strong>  It has been replaced by the <code>nresample</code> argument (for
conformity with the <span class="pkg">libcoin</span>, <span class="pkg">party</span> and <span class="pkg">partykit</span> packages).
</p>

<hr>
<h2 id='ocarcinoma'>Ovarian Carcinoma</h2><span id='topic+ocarcinoma'></span>

<h3>Description</h3>

<p>Survival times of 35 women suffering from ovarian carcinoma at stadium II and
IIA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ocarcinoma</code></pre>


<h3>Format</h3>

<p>A data frame with 35 observations on 3 variables.
</p>

<dl>
<dt><code>time</code></dt><dd>
<p>time (days).
</p>
</dd>
<dt><code>stadium</code></dt><dd>
<p>a factor with levels <code>"II"</code> and <code>"IIA"</code>.
</p>
</dd>
<dt><code>event</code></dt><dd>
<p>status indicator for <code>time</code>: <code>FALSE</code> for right-censored
observations and <code>TRUE</code> otherwise.
</p>
</dd>
</dl>



<h3>Details</h3>

<p>Data from Fleming <em>et al.</em> (1980) and Fleming, Green and Harrington
(1984).  Reanalysed in Schumacher and Schulgen (2002).
</p>


<h3>Source</h3>

<p>Fleming, T. R., Green, S. J. and Harrington, D. P.  (1984).  Considerations
for monitoring and evaluating treatment effects in clinical trials.
<em>Controlled Clinical Trials</em> <b>5</b>(1), 55&ndash;66.
<a href="https://doi.org/10.1016/0197-2456%2884%2990150-8">doi:10.1016/0197-2456(84)90150-8</a>
</p>
<p>Fleming, T. R., O'Fallon, J. R., O'Brien, P. C. and Harrington, D. P.  (1980).
Modified Kolmogorov-Smirnov test procedures with application to arbitrarily
right-censored data.  <em>Biometrics</em> <b>36</b>(4), 607&ndash;625.
<a href="https://doi.org/10.2307/2556114">doi:10.2307/2556114</a>
</p>


<h3>References</h3>

<p>Schumacher, M. and Schulgen, G.  (2002).  <em>Methodik Klinischer Studien:
Methodische Grundlagen der Planung, Durchführung und
Auswertung</em>.  Heidelberg: Springer.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Exact logrank test
lt &lt;- logrank_test(Surv(time, event) ~ stadium, data = ocarcinoma,
                   distribution = "exact")

## Test statistic
statistic(lt)

## P-value
pvalue(lt)
</code></pre>

<hr>
<h2 id='PermutationDistribution-methods'>Computation of the Permutation Distribution</h2><span id='topic+dperm'></span><span id='topic+dperm-methods'></span><span id='topic+dperm+2CNullDistribution-method'></span><span id='topic+dperm+2CIndependenceTest-method'></span><span id='topic+pperm'></span><span id='topic+pperm-methods'></span><span id='topic+pperm+2CNullDistribution-method'></span><span id='topic+pperm+2CIndependenceTest-method'></span><span id='topic+qperm'></span><span id='topic+qperm-methods'></span><span id='topic+qperm+2CNullDistribution-method'></span><span id='topic+qperm+2CIndependenceTest-method'></span><span id='topic+rperm'></span><span id='topic+rperm-methods'></span><span id='topic+rperm+2CNullDistribution-method'></span><span id='topic+rperm+2CIndependenceTest-method'></span><span id='topic+support'></span><span id='topic+support-methods'></span><span id='topic+support+2CNullDistribution-method'></span><span id='topic+support+2CIndependenceTest-method'></span>

<h3>Description</h3>

<p>Methods for computation of the density function, distribution function,
quantile function, random numbers and support of the permutation distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'NullDistribution'
dperm(object, x, ...)
## S4 method for signature 'IndependenceTest'
dperm(object, x, ...)

## S4 method for signature 'NullDistribution'
pperm(object, q, ...)
## S4 method for signature 'IndependenceTest'
pperm(object, q, ...)

## S4 method for signature 'NullDistribution'
qperm(object, p, ...)
## S4 method for signature 'IndependenceTest'
qperm(object, p, ...)

## S4 method for signature 'NullDistribution'
rperm(object, n, ...)
## S4 method for signature 'IndependenceTest'
rperm(object, n, ...)

## S4 method for signature 'NullDistribution'
support(object, ...)
## S4 method for signature 'IndependenceTest'
support(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PermutationDistribution-methods_+3A_object">object</code></td>
<td>

<p>an object from which the density function, distribution function, quantile
function, random numbers or support of the permutation distribution can be
computed.
</p>
</td></tr>
<tr><td><code id="PermutationDistribution-methods_+3A_x">x</code>, <code id="PermutationDistribution-methods_+3A_q">q</code></td>
<td>

<p>a numeric vector, the quantiles for which the density function or
distribution function is computed.
</p>
</td></tr>
<tr><td><code id="PermutationDistribution-methods_+3A_p">p</code></td>
<td>

<p>a numeric vector, the probabilities for which the quantile function is
computed.
</p>
</td></tr>
<tr><td><code id="PermutationDistribution-methods_+3A_n">n</code></td>
<td>

<p>a numeric vector, the number of observations.  If <code>length(n) &gt; 1</code>, the
length is taken to be the number required.
</p>
</td></tr>
<tr><td><code id="PermutationDistribution-methods_+3A_...">...</code></td>
<td>

<p>further arguments to be passed to methods.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The methods <code>dperm</code>, <code>pperm</code>, <code>qperm</code>, <code>rperm</code> and
<code>support</code> compute the density function, distribution function, quantile
function, random deviates and support, respectively, of the permutation
distribution.
</p>


<h3>Value</h3>

<p>The density function, distribution function, quantile function, random
deviates or support of the permutation distribution computed from
<code>object</code>.  A numeric vector.
</p>


<h3>Note</h3>

<p>The density of asymptotic permutation distributions for maximum-type tests or
exact permutation distributions obtained by the split-up algorithm is reported
as <code>NA</code>.  The quantile function of asymptotic permutation distributions
for maximum-type tests cannot be computed for <code>p</code> less than 0.5, due to
limitations in the <span class="pkg">mvtnorm</span> package.  The support of exact permutation
distributions obtained by the split-up algorithm is reported as <code>NA</code>.
</p>
<p>In versions of <span class="pkg">coin</span> prior to 1.1-0, the support of asymptotic
permutation distributions was given as an interval containing 99.999 % of the
probability mass.  It is now reported as <code>NA</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Two-sample problem
dta &lt;- data.frame(
    y = rnorm(20),
    x = gl(2, 10)
)

## Exact Ansari-Bradley test
at &lt;- ansari_test(y ~ x, data = dta, distribution = "exact")

## Support of the exact distribution of the Ansari-Bradley statistic
supp &lt;- support(at)

## Density of the exact distribution of the Ansari-Bradley statistic
dens &lt;- dperm(at, x = supp)

## Plotting the density
plot(supp, dens, type = "s")

## 95% quantile
qperm(at, p = 0.95)

## One-sided p-value
pperm(at, q = statistic(at))

## Random number generation
rperm(at, n = 5)
</code></pre>

<hr>
<h2 id='photocar'>Multiple Dosing Photococarcinogenicity Experiment</h2><span id='topic+photocar'></span>

<h3>Description</h3>

<p>Survival time, time to first tumor, and total number of tumors in three groups
of animals in a photococarcinogenicity study.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>photocar</code></pre>


<h3>Format</h3>

<p>A data frame with 108 observations on 6 variables.
</p>

<dl>
<dt><code>group</code></dt><dd>
<p>a factor with levels <code>"A"</code>, <code>"B"</code>, and <code>"C"</code>.
</p>
</dd>
<dt><code>ntumor</code></dt><dd>
<p>total number of tumors.
</p>
</dd>
<dt><code>time</code></dt><dd>
<p>survival time.
</p>
</dd>
<dt><code>event</code></dt><dd>
<p>status indicator for <code>time</code>: <code>FALSE</code> for right-censored
observations and <code>TRUE</code> otherwise.
</p>
</dd>
<dt><code>dmin</code></dt><dd>
<p>time to first tumor.
</p>
</dd>
<dt><code>tumor</code></dt><dd>
<p>status indicator for <code>dmin</code>: <code>FALSE</code> when no tumor was observed
and <code>TRUE</code> otherwise.
</p>
</dd>
</dl>



<h3>Details</h3>

<p>The animals were exposed to different levels of ultraviolet radiation (UVR)
exposure (group A: topical vehicle and 600 Robertson&ndash;Berger units of UVR,
group B: no topical vehicle and 600 Robertson&ndash;Berger units of UVR and group
C: no topical vehicle and 1200 Robertson&ndash;Berger units of UVR).  The data are
taken from Tables 1 to 3 in Molefe <em>et al.</em> (2005).
</p>
<p>The main interest is testing the global null hypothesis of no treatment effect
with respect to survival time, time to first tumor and number of tumors.
(Molefe <em>et al.</em>, 2005, also analyzed the detection time of tumors, but
that data is not given here.)  In case the global null hypothesis can be
rejected, the deviations from the partial null hypotheses are of special
interest.
</p>


<h3>Source</h3>

<p>Molefe, D. F., Chen, J. J., Howard, P. C., Miller, B. J., Sambuco, C. P.,
Forbes, P. D. and Kodell, R. L.  (2005).  Tests for effects on tumor frequency
and latency in multiple dosing photococarcinogenicity experiments.
<em>Journal of Statistical Planning and Inference</em> <b>129</b>(1&ndash;2), 39&ndash;58.
<a href="https://doi.org/10.1016/j.jspi.2004.06.038">doi:10.1016/j.jspi.2004.06.038</a>
</p>


<h3>References</h3>

<p>Hothorn, T., Hornik, K., van de Wiel, M. A. and Zeileis, A.  (2006).  A Lego
system for conditional inference.  <em>The American Statistician</em>
<b>60</b>(3), 257&ndash;263.  <a href="https://doi.org/10.1198/000313006X118430">doi:10.1198/000313006X118430</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Plotting data
op &lt;- par(no.readonly = TRUE) # save current settings
layout(matrix(1:3, ncol = 3))
with(photocar, {
    plot(survfit(Surv(time, event) ~ group),
         lty =  1:3, xmax = 50, main = "Survival Time")
    legend("bottomleft", lty = 1:3, levels(group), bty = "n")
    plot(survfit(Surv(dmin, tumor) ~ group),
         lty = 1:3, xmax = 50, main = "Time to First Tumor")
    legend("bottomleft", lty = 1:3, levels(group), bty = "n")
    boxplot(ntumor ~ group, main = "Number of Tumors")
})
par(op) # reset

## Approximative multivariate (all three responses) test
it &lt;- independence_test(Surv(time, event) + Surv(dmin, tumor) + ntumor ~ group,
                        data = photocar,
                        distribution = approximate(nresample = 10000))

## Global p-value
pvalue(it)

## Why was the global null hypothesis rejected?
statistic(it, type = "standardized")
pvalue(it, method = "single-step")
</code></pre>

<hr>
<h2 id='PValue-class'>Class <code>"PValue"</code></h2><span id='topic+PValue-class'></span>

<h3>Description</h3>

<p>Objects of class <code>"PValue"</code> represent the <code class="reqn">p</code>-value,
mid-<code class="reqn">p</code>-value and <code class="reqn">p</code>-value interval of the reference distribution.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form </p>
<pre>     new("PValue", \dots).</pre>


<h3>Slots</h3>


<dl>
<dt><code>name</code>:</dt><dd>
<p>Object of class <code>"character"</code>.  The name of the reference
distribution.
</p>
</dd>
<dt><code>p</code>:</dt><dd>
<p>Object of class <code>"function"</code>.  The distribution function of the
reference distribution.
</p>
</dd>
<dt><code>pvalue</code>:</dt><dd>
<p>Object of class <code>"function"</code>.  The <code class="reqn">p</code>-value function of the
reference distribution.
</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>pvalue</dt><dd>
<p><code>signature(object = "PValue")</code>: See the documentation for
<code><a href="#topic+pvalue">pvalue</a></code> for details.
</p>
</dd>
</dl>



<h3>Note</h3>

<p>Starting with <span class="pkg">coin</span> version 1.3-0, this class is deprecated and will be
replaced by class <code>"NullDistribution"</code>.  <strong>It will be made defunct
and removed in a future release.</strong>
</p>

<hr>
<h2 id='pvalue-methods'>Computation of the <code class="reqn">p</code>-Value, Mid-<code class="reqn">p</code>-Value, <code class="reqn">p</code>-Value
Interval and Test Size</h2><span id='topic+pvalue'></span><span id='topic+pvalue-methods'></span><span id='topic+pvalue+2CPValue-method'></span><span id='topic+pvalue+2CNullDistribution-method'></span><span id='topic+pvalue+2CApproxNullDistribution-method'></span><span id='topic+pvalue+2CIndependenceTest-method'></span><span id='topic+pvalue+2CMaxTypeIndependenceTest-method'></span><span id='topic+midpvalue'></span><span id='topic+midpvalue-methods'></span><span id='topic+midpvalue+2CNullDistribution-method'></span><span id='topic+midpvalue+2CApproxNullDistribution-method'></span><span id='topic+midpvalue+2CIndependenceTest-method'></span><span id='topic+pvalue_interval'></span><span id='topic+pvalue_interval-methods'></span><span id='topic+pvalue_interval+2CNullDistribution-method'></span><span id='topic+pvalue_interval+2CIndependenceTest-method'></span><span id='topic+size'></span><span id='topic+size-methods'></span><span id='topic+size+2CNullDistribution-method'></span><span id='topic+size+2CIndependenceTest-method'></span>

<h3>Description</h3>

<p>Methods for computation of the <code class="reqn">p</code>-value, mid-<code class="reqn">p</code>-value, <code class="reqn">p</code>-value
interval and test size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'PValue'
pvalue(object, q, ...)
## S4 method for signature 'NullDistribution'
pvalue(object, q, ...)
## S4 method for signature 'ApproxNullDistribution'
pvalue(object, q, ...)
## S4 method for signature 'IndependenceTest'
pvalue(object, ...)
## S4 method for signature 'MaxTypeIndependenceTest'
pvalue(object, method = c("global", "single-step",
                          "step-down", "unadjusted"),
       distribution = c("joint", "marginal"),
       type = c("Bonferroni", "Sidak"), ...)

## S4 method for signature 'NullDistribution'
midpvalue(object, q, ...)
## S4 method for signature 'ApproxNullDistribution'
midpvalue(object, q, ...)
## S4 method for signature 'IndependenceTest'
midpvalue(object, ...)

## S4 method for signature 'NullDistribution'
pvalue_interval(object, q, ...)
## S4 method for signature 'IndependenceTest'
pvalue_interval(object, ...)

## S4 method for signature 'NullDistribution'
size(object, alpha, type = c("p-value", "mid-p-value"), ...)
## S4 method for signature 'IndependenceTest'
size(object, alpha, type = c("p-value", "mid-p-value"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pvalue-methods_+3A_object">object</code></td>
<td>

<p>an object from which the <code class="reqn">p</code>-value, mid-<code class="reqn">p</code>-value, <code class="reqn">p</code>-value
interval or test size can be computed.
</p>
</td></tr>
<tr><td><code id="pvalue-methods_+3A_q">q</code></td>
<td>

<p>a numeric, the quantile for which the <code class="reqn">p</code>-value, mid-<code class="reqn">p</code>-value or
<code class="reqn">p</code>-value interval is computed.
</p>
</td></tr>
<tr><td><code id="pvalue-methods_+3A_method">method</code></td>
<td>

<p>a character, the method used for the <code class="reqn">p</code>-value computation: either
<code>"global"</code> (default), <code>"single-step"</code>, <code>"step-down"</code> or
<code>"unadjusted"</code>.
</p>
</td></tr>
<tr><td><code id="pvalue-methods_+3A_distribution">distribution</code></td>
<td>

<p>a character, the distribution used for the computation of adjusted
<code class="reqn">p</code>-values: either <code>"joint"</code> (default) or <code>"marginal"</code>.
</p>
</td></tr>
<tr><td><code id="pvalue-methods_+3A_type">type</code></td>
<td>

<p><code>pvalue()</code>: a character, the type of <code class="reqn">p</code>-value adjustment when the
marginal distributions are used: either <code>"Bonferroni"</code> (default) or
<code>"Sidak"</code>.

<code>size()</code>: a character, the type of rejection region used when computing
the test size: either <code>"p-value"</code> (default) or <code>"mid-p-value"</code>.
</p>
</td></tr>
<tr><td><code id="pvalue-methods_+3A_alpha">alpha</code></td>
<td>

<p>a numeric, the nominal significance level <code class="reqn">\alpha</code> at which the test size
is computed.
</p>
</td></tr>
<tr><td><code id="pvalue-methods_+3A_...">...</code></td>
<td>

<p>further arguments (currently ignored).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The methods <code>pvalue</code>, <code>midpvalue</code>, <code>pvalue_interval</code> and
<code>size</code> compute the <code class="reqn">p</code>-value, mid-<code class="reqn">p</code>-value, <code class="reqn">p</code>-value
interval and test size, respectively.
</p>
<p>For <code>pvalue()</code>, the global <code class="reqn">p</code>-value (<code>method = "global"</code>) is
returned by default and is given with an associated 99% confidence interval
when resampling is used to determine the null distribution (which for maximum
statistics may be true even in the asymptotic case).
</p>
<p>The familywise error rate (FWER) is always controlled under the global null
hypothesis, i.e., in the <em>weak</em> sense, implying that the smallest
adjusted <code class="reqn">p</code>-value is valid without further assumptions.  Control of the
FWER under any partial configuration of the null hypotheses, i.e., in the
<em>strong</em> sense, as is typically desired for multiple tests and
comparisons, requires that the <em>subset pivotality</em> condition holds
(Westfall and Young, 1993, pp. 42&ndash;43; Bretz, Hothorn and Westfall, 2011,
pp. 136&ndash;137).  In addition, for methods based on the joint distribution of
the test statistics, failure of the <em>joint exchangeability</em> assumption
(Westfall and Troendle, 2008; Bretz, Hothorn and Westfall, 2011, pp. 129&ndash;130)
may cause excess Type I errors.
</p>
<p>Assuming <em>subset pivotality</em>, single-step or <em>free</em> step-down
adjusted <code class="reqn">p</code>-values using max-<code class="reqn">T</code> procedures are obtained by setting
<code>method</code> to <code>"single-step"</code> or <code>"step-down"</code>, respectively.  In
both cases, the <code>distribution</code> argument specifies whether the adjustment
is based on the joint distribution (<code>"joint"</code>) or the marginal
distributions (<code>"marginal"</code>) of the test statistics.  For procedures
based on the marginal distributions, Bonferroni- or Šidák-type
adjustment can be specified through the <code>type</code> argument by setting it to
<code>"Bonferroni"</code> or <code>"Sidak"</code>, respectively.
</p>
<p>The <code class="reqn">p</code>-value adjustment procedures based on the joint distribution of the
test statistics fully utilizes distributional characteristics, such as
discreteness and dependence structure, whereas procedures using the marginal
distributions only incorporate discreteness.  Hence, the joint
distribution-based procedures are typically more powerful.  Details regarding
the single-step and <em>free</em> step-down procedures based on the joint
distribution can be found in Westfall and Young (1993); in particular, this
implementation uses Equation 2.8 with Algorithm 2.5 and 2.8, respectively.
Westfall and Wolfinger (1997) provide details of the marginal
distributions-based single-step and <em>free</em> step-down procedures.  The
generalization of Westfall and Wolfinger (1997) to arbitrary test statistics,
as implemented here, is given by Westfall and Troendle (2008).
</p>
<p>Unadjusted <code class="reqn">p</code>-values are obtained using <code>method = "unadjusted"</code>.
</p>
<p>For <code>midpvalue()</code>, the global mid-<code class="reqn">p</code>-value is given with an
associated 99% mid-<code class="reqn">p</code> confidence interval when resampling is used to
determine the null distribution.  The two-sided mid-<code class="reqn">p</code>-value is computed
according to the minimum likelihood method (Hirji <em>et al.</em>, 1991).
</p>
<p>The <code class="reqn">p</code>-value interval <code class="reqn">(p_0, p_1]</code> obtained by
<code>pvalue_interval()</code> was proposed by Berger (2000, 2001), where the upper
endpoint <code class="reqn">p_1</code> is the conventional <code class="reqn">p</code>-value and the mid-point, i.e.,
<code class="reqn">p_{0.5}</code>, is the mid-<code class="reqn">p</code>-value.  The lower endpoint <code class="reqn">p_0</code>
is the smallest <code class="reqn">p</code>-value attainable if no conservatism attributable to
the discreteness of the null distribution is present.  The length of the
<code class="reqn">p</code>-value interval is the null probability of the observed outcome and
provides a data-dependent measure of conservatism that is completely
independent of the nominal significance level.
</p>
<p>For <code>size()</code>, the test size, i.e., the actual significance level, at the
nominal significance level <code class="reqn">\alpha</code> is computed using either the rejection
region corresponding to the <code class="reqn">p</code>-value (<code>type = "p-value"</code>, default)
or the mid-<code class="reqn">p</code>-value (<code>type = "mid-p-value"</code>).  The test size is, in
contrast to the <code class="reqn">p</code>-value interval, a data-independent measure of
conservatism that depends on the nominal significance level.  A test size
smaller or larger than the nominal significance level indicates that the test
procedure is conservative or anti-conservative, respectively, at that
particular nominal significance level.  However, as pointed out by Berger
(2001), even when the actual and nominal significance levels are identical,
conservatism may still affect the <code class="reqn">p</code>-value.
</p>


<h3>Value</h3>

<p>The <code class="reqn">p</code>-value, mid-<code class="reqn">p</code>-value, <code class="reqn">p</code>-value interval or test size
computed from <code>object</code>.  A numeric vector or matrix.
</p>


<h3>Note</h3>

<p>The mid-<code class="reqn">p</code>-value, <code class="reqn">p</code>-value interval and test size of asymptotic
permutation distributions or exact permutation distributions obtained by the
split-up algorithm is reported as <code>NA</code>.
</p>
<p>In versions of <span class="pkg">coin</span> prior to 1.1-0, a min-<code class="reqn">P</code> procedure computing
Šidák single-step adjusted <code class="reqn">p</code>-values accounting for
discreteness was available when specifying <code>method = "discrete"</code>.  This
was made <strong>defunct</strong> in version 1.2-0 due to the introduction of a more
general max-<code class="reqn">T</code> version of the same algorithm.
</p>


<h3>References</h3>

<p>Berger, V. W.  (2000).  Pros and cons of permutation tests in clinical trials.
<em>Statistics in Medicine</em> <b>19</b>(10), 1319&ndash;1328.
<a href="https://doi.org/10.1002/%28SICI%291097-0258%2820000530%2919%3A10%3C1319%3A%3AAID-SIM490%3E3.0.CO%3B2-0">doi:10.1002/(SICI)1097-0258(20000530)19:10&lt;1319::AID-SIM490&gt;3.0.CO;2-0</a>
</p>
<p>Berger, V. W.  (2001).  The <code class="reqn">p</code>-value interval as an inferential tool.
<em>The Statistician</em> <b>50</b>(1), 79&ndash;85.  <a href="https://doi.org/10.1111/1467-9884.00262">doi:10.1111/1467-9884.00262</a>
</p>
<p>Bretz, F., Hothorn, T. and Westfall, P.  (2011).  <em>Multiple Comparisons
Using R</em>.  Boca Raton: CRC Press.
</p>
<p>Hirji, K. F., Tan, S.-J. and Elashoff, R. M.  (1991).  A quasi-exact test for
comparing two binomial proportions.  <em>Statistics in Medicine</em>
<b>10</b>(7), 1137&ndash;1153.  <a href="https://doi.org/10.1002/sim.4780100713">doi:10.1002/sim.4780100713</a>
</p>
<p>Westfall, P. H. and Troendle, J. F.  (2008).  Multiple testing with minimal
assumptions.  <em>Biometrical Journal</em> <b>50</b>(5), 745&ndash;755.
<a href="https://doi.org/10.1002/bimj.200710456">doi:10.1002/bimj.200710456</a>
</p>
<p>Westfall, P. H. and Wolfinger, R. D.  (1997).  Multiple tests with discrete
distributions.  <em>The American Statistician</em> <b>51</b>(1), 3&ndash;8.
<a href="https://doi.org/10.1080/00031305.1997.10473577">doi:10.1080/00031305.1997.10473577</a>
</p>
<p>Westfall, P. H. and Young, S. S.  (1993).  <em>Resampling-Based Multiple
Testing: Examples and Methods for <code class="reqn">p</code>-Value Adjustment</em>.  New York: John
Wiley &amp; Sons.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Two-sample problem
dta &lt;- data.frame(
    y = rnorm(20),
    x = gl(2, 10)
)

## Exact Ansari-Bradley test
(at &lt;- ansari_test(y ~ x, data = dta, distribution = "exact"))
pvalue(at)
midpvalue(at)
pvalue_interval(at)
size(at, alpha = 0.05)
size(at, alpha = 0.05, type = "mid-p-value")


## Bivariate two-sample problem
dta2 &lt;- data.frame(
    y1 = rnorm(20) + rep(0:1, each = 10),
    y2 = rnorm(20),
    x = gl(2, 10)
)

## Approximative (Monte Carlo) bivariate Fisher-Pitman test
(it &lt;- independence_test(y1 + y2 ~ x, data = dta2,
                         distribution = approximate(nresample = 10000)))

## Global p-value
pvalue(it)

## Joint distribution single-step p-values
pvalue(it, method = "single-step")

## Joint distribution step-down p-values
pvalue(it, method = "step-down")

## Sidak step-down p-values
pvalue(it, method = "step-down", distribution = "marginal", type = "Sidak")

## Unadjusted p-values
pvalue(it, method = "unadjusted")


## Length of YOY Gizzard Shad (Hollander and Wolfe, 1999, p. 200, Tab. 6.3)
yoy &lt;- data.frame(
    length = c(46, 28, 46, 37, 32, 41, 42, 45, 38, 44,
               42, 60, 32, 42, 45, 58, 27, 51, 42, 52,
               38, 33, 26, 25, 28, 28, 26, 27, 27, 27,
               31, 30, 27, 29, 30, 25, 25, 24, 27, 30),
    site = gl(4, 10, labels = as.roman(1:4))
)

## Approximative (Monte Carlo) Fisher-Pitman test with contrasts
## Note: all pairwise comparisons
(it &lt;- independence_test(length ~ site, data = yoy,
                         distribution = approximate(nresample = 10000),
                         xtrafo = mcp_trafo(site = "Tukey")))

## Joint distribution step-down p-values
pvalue(it, method = "step-down") # subset pivotality is violated
</code></pre>

<hr>
<h2 id='rotarod'>Rotating Rats</h2><span id='topic+rotarod'></span>

<h3>Description</h3>

<p>The endurance time of 24 rats in two groups on a rotating cylinder.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotarod</code></pre>


<h3>Format</h3>

<p>A data frame with 24 observations on 2 variables.
</p>

<dl>
<dt><code>time</code></dt><dd>
<p>endurance time (seconds).
</p>
</dd>
<dt><code>group</code></dt><dd>
<p>a factor with levels <code>"control"</code> and <code>"treatment"</code>.
</p>
</dd>
</dl>



<h3>Details</h3>

<p>The rats were randomly assigned to receive a fixed oral dose of a centrally
acting muscle relaxant (<code>"treatment"</code>) or a saline solvent
(<code>"control"</code>).  The animals were placed on a rotating cylinder and the
endurance time of each rat, i.e., the length of time each rat remained on the
cylinder, was measured up to a maximum of 300 seconds.
</p>
<p>This dataset is the basis of a comparison of 11 different software
implementations of the Wilcoxon-Mann-Whitney test presented in Bergmann,
Ludbrook and Spooren (2000).
</p>


<h3>Note</h3>

<p>The empirical variance in the control group is 0 and the group medians are
identical.  The exact conditional <code class="reqn">p</code>-values are 0.0373 (two-sided) and
0.0186 (one-sided).  The asymptotic two-sided <code class="reqn">p</code>-value (corrected for
ties) is 0.0147.
</p>


<h3>Source</h3>

<p>Bergmann, R., Ludbrook, J. and Spooren, W. P. J. M.  (2000).  Different
outcomes of the Wilcoxon-Mann-Whitney test from different statistics packages.
<em>The American Statistician</em> <b>54</b>(1), 72&ndash;77.
<a href="https://doi.org/10.1080/00031305.2000.10474513">doi:10.1080/00031305.2000.10474513</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## One-sided exact Wilcoxon-Mann-Whitney test (p = 0.0186)
wilcox_test(time ~ group, data = rotarod, distribution = "exact",
            alternative = "greater")

## Two-sided exact Wilcoxon-Mann-Whitney test (p = 0.0373)
wilcox_test(time ~ group, data = rotarod, distribution = "exact")

## Two-sided asymptotic Wilcoxon-Mann-Whitney test (p = 0.0147)
wilcox_test(time ~ group, data = rotarod)
</code></pre>

<hr>
<h2 id='ScaleTests'>Two- and <code class="reqn">K</code>-Sample Scale Tests</h2><span id='topic+taha_test'></span><span id='topic+taha_test.formula'></span><span id='topic+taha_test.IndependenceProblem'></span><span id='topic+klotz_test'></span><span id='topic+klotz_test.formula'></span><span id='topic+klotz_test.IndependenceProblem'></span><span id='topic+mood_test'></span><span id='topic+mood_test.formula'></span><span id='topic+mood_test.IndependenceProblem'></span><span id='topic+ansari_test'></span><span id='topic+ansari_test.formula'></span><span id='topic+ansari_test.IndependenceProblem'></span><span id='topic+fligner_test'></span><span id='topic+fligner_test.formula'></span><span id='topic+fligner_test.IndependenceProblem'></span><span id='topic+conover_test'></span><span id='topic+conover_test.formula'></span><span id='topic+conover_test.IndependenceProblem'></span>

<h3>Description</h3>

<p>Testing the equality of the distributions of a numeric response variable in
two or more independent groups against scale alternatives.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
taha_test(formula, data, subset = NULL, weights = NULL, ...)
## S3 method for class 'IndependenceProblem'
taha_test(object, conf.int = FALSE, conf.level = 0.95, ...)

## S3 method for class 'formula'
klotz_test(formula, data, subset = NULL, weights = NULL, ...)
## S3 method for class 'IndependenceProblem'
klotz_test(object, ties.method = c("mid-ranks", "average-scores"),
           conf.int = FALSE, conf.level = 0.95, ...)

## S3 method for class 'formula'
mood_test(formula, data, subset = NULL, weights = NULL, ...)
## S3 method for class 'IndependenceProblem'
mood_test(object, ties.method = c("mid-ranks", "average-scores"),
          conf.int = FALSE, conf.level = 0.95, ...)

## S3 method for class 'formula'
ansari_test(formula, data, subset = NULL, weights = NULL, ...)
## S3 method for class 'IndependenceProblem'
ansari_test(object, ties.method = c("mid-ranks", "average-scores"),
            conf.int = FALSE, conf.level = 0.95, ...)

## S3 method for class 'formula'
fligner_test(formula, data, subset = NULL, weights = NULL, ...)
## S3 method for class 'IndependenceProblem'
fligner_test(object, ties.method = c("mid-ranks", "average-scores"),
             conf.int = FALSE, conf.level = 0.95, ...)

## S3 method for class 'formula'
conover_test(formula, data, subset = NULL, weights = NULL, ...)
## S3 method for class 'IndependenceProblem'
conover_test(object, conf.int = FALSE, conf.level = 0.95, ...)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ScaleTests_+3A_formula">formula</code></td>
<td>

<p>a formula of the form <code>y ~ x | block</code> where <code>y</code> is a numeric
variable, <code>x</code> is a factor and <code>block</code> is an optional factor for
stratification.
</p>
</td></tr>
<tr><td><code id="ScaleTests_+3A_data">data</code></td>
<td>

<p>an optional data frame containing the variables in the model formula.
</p>
</td></tr>
<tr><td><code id="ScaleTests_+3A_subset">subset</code></td>
<td>

<p>an optional vector specifying a subset of observations to be used.  Defaults
to <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="ScaleTests_+3A_weights">weights</code></td>
<td>

<p>an optional formula of the form <code>~ w</code> defining integer valued case
weights for each observation.  Defaults to <code>NULL</code>, implying equal
weight for all observations.
</p>
</td></tr>
<tr><td><code id="ScaleTests_+3A_object">object</code></td>
<td>

<p>an object inheriting from class <code>"<a href="#topic+IndependenceProblem-class">IndependenceProblem</a>"</code>.
</p>
</td></tr>
<tr><td><code id="ScaleTests_+3A_conf.int">conf.int</code></td>
<td>

<p>a logical indicating whether a confidence interval for the ratio of scales
should be computed.  Defaults to <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="ScaleTests_+3A_conf.level">conf.level</code></td>
<td>

<p>a numeric, confidence level of the interval.  Defaults to <code>0.95</code>.
</p>
</td></tr>
<tr><td><code id="ScaleTests_+3A_ties.method">ties.method</code></td>
<td>

<p>a character, the method used to handle ties: the score generating function
either uses mid-ranks (<code>"mid-ranks"</code>, default) or averages the scores
of randomly broken ties (<code>"average-scores"</code>).
</p>
</td></tr>
<tr><td><code id="ScaleTests_+3A_...">...</code></td>
<td>

<p>further arguments to be passed to <code><a href="#topic+independence_test">independence_test</a>()</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>taha_test()</code>, <code>klotz_test()</code>, <code>mood_test()</code>,
<code>ansari_test()</code>, <code>fligner_test()</code> and <code>conover_test()</code> provide
the Taha test, the Klotz test, the Mood test, the Ansari-Bradley test, the
Fligner-Killeen test and the Conover-Iman test.  A general description of
these methods is given by Hollander and Wolfe (1999).  For the adjustment of
scores for tied values see Hájek, Šidák and Sen
(1999, pp. 133&ndash;135).
</p>
<p>The null hypothesis of equality, or conditional equality given <code>block</code>,
of the distribution of <code>y</code> in the groups defined by <code>x</code> is tested
against scale alternatives.  In the two-sample case, the two-sided null
hypothesis is <code class="reqn">H_0\!: V(Y_1) / V(Y_2) = 1</code>,
where <code class="reqn">V(Y_s)</code> is the variance of the responses in the <code class="reqn">s</code>th sample.
In case <code>alternative = "less"</code>, the null hypothesis is <code class="reqn">H_0\!: V(Y_1)
    / V(Y_2) \ge 1</code>.  When
<code>alternative = "greater"</code>, the null hypothesis is <code class="reqn">H_0\!: V(Y_1) /
    V(Y_2) \le 1</code>.  Confidence intervals for the
ratio of scales are available and computed according to Bauer (1972).
</p>
<p>The Fligner-Killeen test uses median centering in each of the samples, as
suggested by Conover, Johnson and Johnson (1981), whereas the Conover-Iman
test, following Conover and Iman (1978), uses mean centering in each of the
samples.
</p>
<p>The conditional null distribution of the test statistic is used to obtain
<code class="reqn">p</code>-values and an asymptotic approximation of the exact distribution is
used by default (<code>distribution = "asymptotic"</code>).  Alternatively, the
distribution can be approximated via Monte Carlo resampling or computed
exactly for univariate two-sample problems by setting <code>distribution</code> to
<code>"approximate"</code> or <code>"exact"</code>, respectively.  See
<code><a href="#topic+asymptotic">asymptotic</a>()</code>, <code><a href="#topic+approximate">approximate</a>()</code> and
<code><a href="#topic+exact">exact</a>()</code> for details.
</p>


<h3>Value</h3>

<p>An object inheriting from class <code>"<a href="#topic+IndependenceTest-class">IndependenceTest</a>"</code>.
Confidence intervals can be extracted by <code><a href="stats.html#topic+confint">confint</a>()</code>.
</p>


<h3>Note</h3>

<p>In the two-sample case, a <em>large</em> value of the Ansari-Bradley
statistic indicates that sample 1 is <em>less</em> variable than sample
2, whereas a <em>large</em> value of the statistics due to Taha, Klotz,
Mood, Fligner-Killeen, and Conover-Iman indicate that sample 1 is
<em>more</em> variable than sample 2.
</p>


<h3>References</h3>

<p>Bauer, D. F.  (1972).  Constructing confidence sets using rank statistics.
<em>Journal of the American Statistical Association</em> <b>67</b>(339),
687&ndash;690.  <a href="https://doi.org/10.1080/01621459.1972.10481279">doi:10.1080/01621459.1972.10481279</a>
</p>
<p>Conover, W. J. and Iman, R. L.  (1978).  Some exact tables for the squared
ranks test.  <em>Communications in Statistics &ndash; Simulation and Computation</em>
<b>7</b>(5), 491&ndash;513.  <a href="https://doi.org/10.1080/03610917808812093">doi:10.1080/03610917808812093</a>
</p>
<p>Conover, W. J., Johnson, M. E. and Johnson, M. M.  (1981).  A comparative
study of tests for homogeneity of variances, with applications to the outer
continental shelf bidding data.  <em>Technometrics</em> <b>23</b>(4), 351&ndash;361.
<a href="https://doi.org/10.1080/00401706.1981.10487680">doi:10.1080/00401706.1981.10487680</a>
</p>
<p>Hájek, J., Šidák, Z. and Sen, P. K.  (1999).
<em>Theory of Rank Tests</em>, Second Edition.  San Diego: Academic Press.
</p>
<p>Hollander, M. and Wolfe, D. A.  (1999).  <em>Nonparametric Statistical
Methods</em>, Second Edition.   York: John Wiley &amp; Sons.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Serum Iron Determination Using Hyland Control Sera
## Hollander and Wolfe (1999, p. 147, Tab 5.1)
sid &lt;- data.frame(
    serum = c(111, 107, 100, 99, 102, 106, 109, 108, 104, 99,
              101, 96, 97, 102, 107, 113, 116, 113, 110, 98,
              107, 108, 106, 98, 105, 103, 110, 105, 104,
              100, 96, 108, 103, 104, 114, 114, 113, 108, 106, 99),
    method = gl(2, 20, labels = c("Ramsay", "Jung-Parekh"))
)

## Asymptotic Ansari-Bradley test
ansari_test(serum ~ method, data = sid)

## Exact Ansari-Bradley test
pvalue(ansari_test(serum ~ method, data = sid,
                   distribution = "exact"))


## Platelet Counts of Newborn Infants
## Hollander and Wolfe (1999, p. 171, Tab. 5.4)
platelet &lt;- data.frame(
    counts = c(120, 124, 215, 90, 67, 95, 190, 180, 135, 399,
               12, 20, 112, 32, 60, 40),
    treatment = factor(rep(c("Prednisone", "Control"), c(10, 6)))
)

## Approximative (Monte Carlo) Lepage test
## Hollander and Wolfe (1999, p. 172)
lepage_trafo &lt;- function(y)
    cbind("Location" = rank_trafo(y), "Scale" = ansari_trafo(y))

independence_test(counts ~ treatment, data = platelet,
                  distribution = approximate(nresample = 10000),
                  ytrafo = function(data)
                      trafo(data, numeric_trafo = lepage_trafo),
                  teststat = "quadratic")

## Why was the null hypothesis rejected?
## Note: maximum statistic instead of quadratic form
ltm &lt;- independence_test(counts ~ treatment, data = platelet,
                         distribution = approximate(nresample = 10000),
                         ytrafo = function(data)
                             trafo(data, numeric_trafo = lepage_trafo))

## Step-down adjustment suggests a difference in location
pvalue(ltm, method = "step-down")

## The same results are obtained from the simple Sidak-Holm procedure since the
## correlation between Wilcoxon and Ansari-Bradley test statistics is zero
cov2cor(covariance(ltm))
pvalue(ltm, method = "step-down", distribution = "marginal", type = "Sidak")
</code></pre>

<hr>
<h2 id='statistic-methods'>Extraction of the Test Statistic and the Linear Statistic</h2><span id='topic+statistic'></span><span id='topic+statistic-methods'></span><span id='topic+statistic+2CIndependenceLinearStatistic-method'></span><span id='topic+statistic+2CIndependenceTestStatistic-method'></span><span id='topic+statistic+2CIndependenceTest-method'></span>

<h3>Description</h3>

<p>Methods for extraction of the test statistic and the linear statistic.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'IndependenceLinearStatistic'
statistic(object, type = c("test", "linear", "centered", "standardized"),
          partial = FALSE, ...)
## S4 method for signature 'IndependenceTestStatistic'
statistic(object, type = c("test", "linear", "centered", "standardized"),
          partial = FALSE, ...)
## S4 method for signature 'IndependenceTest'
statistic(object, type = c("test", "linear", "centered", "standardized"),
          partial = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="statistic-methods_+3A_object">object</code></td>
<td>

<p>an object from which the test statistic or the linear statistic can be
extracted.
</p>
</td></tr>
<tr><td><code id="statistic-methods_+3A_type">type</code></td>
<td>

<p>a character string indicating the type of statistic: either <code>"test"</code>
(default) for the test statistic, <code>"linear"</code> for the unstandardized
linear statistic, <code>"centered"</code> for the centered linear statistic or
<code>"standardized"</code> for the standardized linear statistic.
</p>
</td></tr>
<tr><td><code id="statistic-methods_+3A_partial">partial</code></td>
<td>

<p>a logical indicating that the partial linear statistic for each block should
be extracted.  Defaults to <code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="statistic-methods_+3A_...">...</code></td>
<td>

<p>further arguments (currently ignored).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The method <code>statistic</code> extracts the univariate test statistic or the,
possibly multivariate, linear statistic in its unstandardized, centered or
standardized form.
</p>
<p>The test statistic (<code>type = "test"</code>) is returned by default.  The
unstandardized, centered or standardized linear statistic is obtained by
setting <code>type</code> to <code>"linear"</code>, <code>"centered"</code> or
<code>"standardized"</code>, respectively.  For tests of conditional independence
within blocks, the partial linear statistic for each block is obtained by
setting <code>partial = TRUE</code>.
</p>


<h3>Value</h3>

<p>The test statistic or the unstandardized, centered or standardized linear
statistic extracted from <code>object</code>.  A numeric vector, matrix or array.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example data
dta &lt;- data.frame(
    y = gl(4, 5),
    x = gl(5, 4)
)

## Asymptotic Cochran-Mantel-Haenszel Test
ct &lt;- cmh_test(y ~ x, data = dta)

## Test statistic
statistic(ct)

## The unstandardized linear statistic...
statistic(ct, type = "linear")

## ...is identical to the contingency table
xtabs(~ x + y, data = dta)

## The centered linear statistic...
statistic(ct, type = "centered")

## ...is identical to
statistic(ct, type = "linear") - expectation(ct)

## The standardized linear statistic, illustrating departures from the null
## hypothesis of independence...
statistic(ct, type = "standardized")

## ...is identical to
(statistic(ct, type = "linear") - expectation(ct)) / sqrt(variance(ct))
</code></pre>

<hr>
<h2 id='SurvivalTests'>Two- and <code class="reqn">K</code>-Sample Tests for Censored Data</h2><span id='topic+surv_test'></span><span id='topic+logrank_test'></span><span id='topic+logrank_test.formula'></span><span id='topic+logrank_test.IndependenceProblem'></span>

<h3>Description</h3>

<p>Testing the equality of the survival distributions in two or more independent
groups.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
logrank_test(formula, data, subset = NULL, weights = NULL, ...)
## S3 method for class 'IndependenceProblem'
logrank_test(object, ties.method = c("mid-ranks", "Hothorn-Lausen",
                                     "average-scores"),
             type = c("logrank", "Gehan-Breslow", "Tarone-Ware",
                      "Peto-Peto", "Prentice", "Prentice-Marek",
                      "Andersen-Borgan-Gill-Keiding",
                      "Fleming-Harrington", "Gaugler-Kim-Liao", "Self"),
             rho = NULL, gamma = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SurvivalTests_+3A_formula">formula</code></td>
<td>

<p>a formula of the form <code>y ~ x | block</code> where <code>y</code> is a survival
object (see <code><a href="survival.html#topic+Surv">Surv</a></code> in package <span class="pkg">survival</span>),
<code>x</code> is a factor and <code>block</code> is an optional factor for
stratification.
</p>
</td></tr>
<tr><td><code id="SurvivalTests_+3A_data">data</code></td>
<td>

<p>an optional data frame containing the variables in the model formula.
</p>
</td></tr>
<tr><td><code id="SurvivalTests_+3A_subset">subset</code></td>
<td>

<p>an optional vector specifying a subset of observations to be used.  Defaults
to <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="SurvivalTests_+3A_weights">weights</code></td>
<td>

<p>an optional formula of the form <code>~ w</code> defining integer valued case
weights for each observation.  Defaults to <code>NULL</code>, implying equal
weight for all observations.
</p>
</td></tr>
<tr><td><code id="SurvivalTests_+3A_object">object</code></td>
<td>

<p>an object inheriting from class <code>"<a href="#topic+IndependenceProblem-class">IndependenceProblem</a>"</code>.
</p>
</td></tr>
<tr><td><code id="SurvivalTests_+3A_ties.method">ties.method</code></td>
<td>

<p>a character, the method used to handle ties: the score generating function
either uses mid-ranks (<code>"mid-ranks"</code>, default), the Hothorn-Lausen
method (<code>"Hothorn-Lausen"</code>) or averages the scores of randomly broken
ties (<code>"average-scores"</code>); see &lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="SurvivalTests_+3A_type">type</code></td>
<td>

<p>a character, the type of test: either <code>"logrank"</code> (default),
<code>"Gehan-Breslow"</code>, <code>"Tarone-Ware"</code>, <code>"Peto-Peto"</code>,
<code>"Prentice"</code>, <code>"Prentice-Marek"</code>,
<code>"Andersen-Borgan-Gill-Keiding"</code>, <code>"Fleming-Harrington"</code>,
<code>"Gaugler-Kim-Liao"</code> or <code>"Self"</code>; see
&lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="SurvivalTests_+3A_rho">rho</code></td>
<td>

<p>a numeric, the <code class="reqn">\rho</code> constant when <code>type</code> is <code>"Tarone-Ware"</code>,
<code>"Fleming-Harrington"</code>, <code>"Gaugler-Kim-Liao"</code> or <code>"Self"</code>; see
&lsquo;Details&rsquo;.  Defaults to <code>NULL</code>, implying <code>0.5</code> for
<code>type = "Tarone-Ware"</code> and <code>0</code> otherwise.
</p>
</td></tr>
<tr><td><code id="SurvivalTests_+3A_gamma">gamma</code></td>
<td>

<p>a numeric, the <code class="reqn">\gamma</code> constant when <code>type</code> is
<code>"Fleming-Harrington"</code>, <code>"Gaugler-Kim-Liao"</code> or <code>"Self"</code>; see
&lsquo;Details&rsquo;.  Defaults to <code>NULL</code>, implying <code>0</code>.
</p>
</td></tr>
<tr><td><code id="SurvivalTests_+3A_...">...</code></td>
<td>

<p>further arguments to be passed to <code><a href="#topic+independence_test">independence_test</a>()</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>logrank_test()</code> provides the weighted logrank test reformulated as a
linear rank test.  The family of weighted logrank tests encompasses a large
collection of tests commonly used in the analysis of survival data including,
but not limited to, the standard (unweighted) logrank test, the Gehan-Breslow
test, the Tarone-Ware class of tests, the Peto-Peto test, the Prentice test,
the Prentice-Marek test, the Andersen-Borgan-Gill-Keiding test, the
Fleming-Harrington class of tests, the Gaugler-Kim-Liao class of tests and the
Self class of tests.  A general description of these methods is given by Klein
and Moeschberger (2003, Ch. 7).  See Letón and Zuluaga (2001) for
the linear rank test formulation.
</p>
<p>The null hypothesis of equality, or conditional equality given <code>block</code>,
of the survival distribution of <code>y</code> in the groups defined by <code>x</code> is
tested.  In the two-sample case, the two-sided null hypothesis is <code class="reqn">H_0\!:
    \theta = 1</code>, where <code class="reqn">\theta = \lambda_2 / \lambda_1</code>
and <code class="reqn">\lambda_s</code> is the hazard rate in the <code class="reqn">s</code>th sample.  In case
<code>alternative = "less"</code>, the null hypothesis is <code class="reqn">H_0\!: \theta \ge
    1</code>, i.e., the survival is lower in sample 1 than in sample
2.  When <code>alternative = "greater"</code>, the null hypothesis is <code class="reqn">H_0\!:
    \theta \le 1</code>, i.e., the survival is higher in sample 1
than in sample 2.
</p>
<p>If <code>x</code> is an ordered factor, the default scores, <code>1:nlevels(x)</code>, can
be altered using the <code>scores</code> argument (see
<code><a href="#topic+independence_test">independence_test</a>()</code>); this argument can also be used to coerce
nominal factors to class <code>"ordered"</code>.  In this case, a linear-by-linear
association test is computed and the direction of the alternative hypothesis
can be specified using the <code>alternative</code> argument.  This type of
extension of the standard logrank test was given by Tarone (1975) and later
generalized to general weights by Tarone and Ware (1977).
</p>
<p>Let <code class="reqn">(t_i, \delta_i)</code>, <code class="reqn">i = 1, 2, \ldots, n</code>, represent a
right-censored random sample of size <code class="reqn">n</code>, where <code class="reqn">t_i</code> is the observed
survival time and <code class="reqn">\delta_i</code> is the status indicator (<code class="reqn">\delta_i</code> is 0
for right-censored observations and 1 otherwise).  To allow for ties in the
data, let <code class="reqn">t_{(1)} &lt; t_{(2)} &lt; \cdots &lt; t_{(m)}</code> represent the <code class="reqn">m</code>, <code class="reqn">m \le n</code>, ordered distinct event times.
At time <code class="reqn">t_{(k)}</code>, <code class="reqn">k = 1, 2, \ldots, m</code>, the number of events
and the number of subjects at risk are given by <code class="reqn">d_k = \sum_{i = 1}^n
    I\!\left(t_i = t_{(k)}\,|\, \delta_i = 1\right)</code> and <code class="reqn">n_k = n - r_k</code>, respectively, where
<code class="reqn">r_k</code> depends on the ties handling method.
</p>
<p>Three different methods of handling ties are available using
<code>ties.method</code>: mid-ranks (<code>"mid-ranks"</code>, default), the
Hothorn-Lausen method (<code>"Hothorn-Lausen"</code>) and average-scores
(<code>"average-scores"</code>).  The first and last method are discussed and
contrasted by Callaert (2003), whereas the second method is defined in Hothorn
and Lausen (2003).  The mid-ranks method leads to
</p>
<p style="text-align: center;"><code class="reqn">
    r_k = \sum_{i = 1}^n I\!\left(t_i &lt; t_{(k)}\right)
  </code>
</p>

<p>whereas the Hothorn-Lausen method uses
</p>
<p style="text-align: center;"><code class="reqn">
    r_k = \sum_{i = 1}^n I\!\left(t_i \le t_{(k)}\right) - 1.
  </code>
</p>

<p>The scores assigned to right-censored and uncensored observations at the
<code class="reqn">k</code>th event time are given by
</p>
<p style="text-align: center;"><code class="reqn">
    C_k = \sum_{j = 1}^k w_j \frac{d_j}{n_j}
    \quad \mathrm{and} \quad
    c_k = C_k - w_k,
  </code>
</p>

<p>respectively, where <code class="reqn">w</code> is the logrank weight.  For the average-scores
method, used by, e.g., the software package StatXact, the <code class="reqn">d_k</code> events
observed at the <code class="reqn">k</code>th event time are arbitrarily ordered by assigning them
distinct values <code class="reqn">t_{(k_l)}</code>, <code class="reqn">l = 1, 2, \ldots, d_k</code>,
infinitesimally to the left of <code class="reqn">t_{(k)}</code>.  Then scores
<code class="reqn">C_{k_l}</code> and <code class="reqn">c_{k_l}</code> are computed as indicated above,
effectively assuming that no event times are tied.  The scores <code class="reqn">C_k</code> and
<code class="reqn">c_k</code> are assigned the average of the scores <code class="reqn">C_{k_l}</code> and
<code class="reqn">c_{k_l}</code>, respectively.  It then follows that the score for the
<code class="reqn">i</code>th subject is
</p>
<p style="text-align: center;"><code class="reqn">
    a_i = \left\{
      \begin{array}{ll}
        C_{k'} &amp; \mathrm{if}~\delta_i = 0 \\
        c_{k'} &amp; \mathrm{otherwise}
      \end{array}
    \right.
  </code>
</p>

<p>where <code class="reqn">k' = \max \{k: t_i \ge t_{(k)}\}</code>.
</p>
<p>The <code>type</code> argument allows for a choice between some of the most
well-known members of the family of weighted logrank tests, each corresponding
to a particular weight function.  The standard logrank test (<code>"logrank"</code>,
default) was suggested by Mantel (1966), Peto and Peto (1972) and Cox (1972)
and has <code class="reqn">w_k = 1</code>.  The Gehan-Breslow test (<code>"Gehan-Breslow"</code>)
proposed by Gehan (1965) and later extended to <code class="reqn">K</code> samples by Breslow
(1970) is a generalization of the Wilcoxon rank-sum test, where <code class="reqn">w_k =
    n_k</code>.  The Tarone-Ware class of tests (<code>"Tarone-Ware"</code>) discussed by
Tarone and Ware (1977) has <code class="reqn">w_k = n_k^\rho</code>, where <code class="reqn">\rho</code> is a
constant; <code class="reqn">\rho = 0.5</code> (default) was suggested by Tarone and Ware (1977),
but note that <code class="reqn">\rho = 0</code> and <code class="reqn">\rho = 1</code> lead to the standard logrank
test and Gehan-Breslow test, respectively.  The Peto-Peto test
(<code>"Peto-Peto"</code>) suggested by Peto and Peto (1972) is another
generalization of the Wilcoxon rank-sum test, where
</p>
<p style="text-align: center;"><code class="reqn">
    w_k = \hat{S}_k = \prod_{j = 0}^{k - 1} \frac{n_j - d_j}{n_j}
  </code>
</p>

<p>is the <em>left-continuous</em> Kaplan-Meier estimator of the survival function,
<code class="reqn">n_0 \equiv n</code> and <code class="reqn">d_0 \equiv 0</code>.  The Prentice
test (<code>"Prentice"</code>) is also a generalization of the Wilcoxon rank-sum
test proposed by Prentice (1978), where
</p>
<p style="text-align: center;"><code class="reqn">
    w_k = \prod_{j = 1}^k \frac{n_j}{n_j + d_j}.
  </code>
</p>

<p>The Prentice-Marek test (<code>"Prentice-Marek"</code>) is yet another
generalization of the Wilcoxon rank-sum test discussed by Prentice and Marek
(1979), with
</p>
<p style="text-align: center;"><code class="reqn">
    w_k = \tilde{S}_k = \prod_{j = 1}^k \frac{n_j + 1 - d_j}{n_j + 1}.
  </code>
</p>

<p>The Andersen-Borgan-Gill-Keiding test (<code>"Andersen-Borgan-Gill-Keiding"</code>)
suggested by Andersen <em>et al.</em> (1982) is a modified version of the
Prentice-Marek test using
</p>
<p style="text-align: center;"><code class="reqn">
    w_k = \frac{n_k}{n_k + 1} \prod_{j = 0}^{k - 1} \frac{n_j + 1 - d_j}{n_j + 1},
  </code>
</p>

<p>where, again, <code class="reqn">n_0 \equiv n</code> and <code class="reqn">d_0 \equiv 0</code>.
The Fleming-Harrington class of tests (<code>"Fleming-Harrington"</code>) proposed
by Fleming and Harrington (1991) uses <code class="reqn">w_k = \hat{S}_k^\rho (1 -
    \hat{S}_k)^\gamma</code>, where <code class="reqn">\rho</code>
and <code class="reqn">\gamma</code> are constants; <code class="reqn">\rho = 0</code> and <code class="reqn">\gamma = 0</code> lead to
the standard logrank test, while <code class="reqn">\rho = 1</code> and <code class="reqn">\gamma = 0</code> result in
the Peto-Peto test.  The Gaugler-Kim-Liao class of tests
(<code>"Gaugler-Kim-Liao"</code>) discussed by Gaugler <em>et al.</em> (2007) is a
modified version of the Fleming-Harrington class of tests, replacing
<code class="reqn">\hat{S}_k</code> with <code class="reqn">\tilde{S}_k</code> so that <code class="reqn">w_k =
    \tilde{S}_k^\rho (1 - \tilde{S}_k)^\gamma</code>, where <code class="reqn">\rho</code> and <code class="reqn">\gamma</code> are constants; <code class="reqn">\rho
    = 0</code> and <code class="reqn">\gamma = 0</code> lead to the standard logrank test, whereas
<code class="reqn">\rho = 1</code> and <code class="reqn">\gamma = 0</code> result in the Prentice-Marek test.  The
Self class of tests (<code>"Self"</code>) suggested by Self (1991) has <code class="reqn">w_k =
    v_k^\rho (1 - v_k)^\gamma</code>, where
</p>
<p style="text-align: center;"><code class="reqn">
    v_k = \frac{1}{2} \frac{t_{(k-1)} + t_{(k)}}{t_{(m)}},
    \quad
    t_{(0)} \equiv 0
  </code>
</p>

<p>is the standardized mid-point between the <code class="reqn">(k - 1)</code>th and the <code class="reqn">k</code>th
event time.  (This is a slight generalization of Self's original proposal in
order to allow for non-integer follow-up times.)  Again, <code class="reqn">\rho</code> and
<code class="reqn">\gamma</code> are constants and <code class="reqn">\rho = 0</code> and <code class="reqn">\gamma = 0</code> lead to
the standard logrank test.
</p>
<p>The conditional null distribution of the test statistic is used to obtain
<code class="reqn">p</code>-values and an asymptotic approximation of the exact distribution is
used by default (<code>distribution = "asymptotic"</code>).  Alternatively, the
distribution can be approximated via Monte Carlo resampling or computed
exactly for univariate two-sample problems by setting <code>distribution</code> to
<code>"approximate"</code> or <code>"exact"</code>, respectively.  See
<code><a href="#topic+asymptotic">asymptotic</a>()</code>, <code><a href="#topic+approximate">approximate</a>()</code> and
<code><a href="#topic+exact">exact</a>()</code> for details.
</p>


<h3>Value</h3>

<p>An object inheriting from class <code>"<a href="#topic+IndependenceTest-class">IndependenceTest</a>"</code>.
</p>


<h3>Note</h3>

<p>Peto and Peto (1972) proposed the test statistic implemented in
<code>logrank_test()</code> and named it the <em>logrank test</em>.  However, the
Mantel-Cox test (Mantel, 1966; Cox, 1972), as implemented in
<code><a href="survival.html#topic+survdiff">survdiff</a>()</code> (in package <span class="pkg">survival</span>), is also known
as the logrank test.  These tests are similar, but differ in the choice of
probability model: the (Peto-Peto) logrank test uses the permutational
variance, whereas the Mantel-Cox test is based on the hypergeometric variance.
</p>
<p>Combining <code><a href="#topic+independence_test">independence_test</a>()</code> or <code><a href="#topic+symmetry_test">symmetry_test</a>()</code>
with <code><a href="#topic+logrank_trafo">logrank_trafo</a>()</code> offers more flexibility than
<code>logrank_test()</code> and allows for, among other things, maximum-type
versatile test procedures (e.g., Lee, 1996; see &lsquo;Examples&rsquo;) and
user-supplied logrank weights (see <code><a href="#topic+GTSG">GTSG</a></code> for tests against
Weibull-type or crossing-curve alternatives).
</p>
<p>Starting with <span class="pkg">coin</span> version 1.1-0, <code>logrank_test()</code> replaced
<code>surv_test()</code> which was made <strong>defunct</strong> in version 1.2-0.
Furthermore, <code>logrank_trafo()</code> is now an increasing function for all
choices of <code>ties.method</code>, implying that the test statistic has the same
sign irrespective of the ties handling method.  Consequently, the sign of the
test statistic will now be the opposite of what it was in earlier versions
unless <code>ties.method = "average-scores"</code>.  (In versions of <span class="pkg">coin</span>
prior to 1.1-0, <code>logrank_trafo()</code> was a decreasing function when
<code>ties.method</code> was other than <code>"average-scores"</code>.)
</p>
<p>Starting with <span class="pkg">coin</span> version 1.2-0, mid-ranks and the Hothorn-Lausen
method can no longer be specified with <code>ties.method = "logrank"</code> and
<code>ties-method = "HL"</code> respectively.
</p>


<h3>References</h3>

<p>Andersen, P. K., Borgan, Ø., Gill, R. and Keiding, N.  (1982).
Linear nonparametric tests for comparison of counting processes, with
applications to censored survival data (with discussion).  <em>International
Statistical Review</em> <b>50</b>(3), 219&ndash;258.  <a href="https://doi.org/10.2307/1402489">doi:10.2307/1402489</a>
</p>
<p>Breslow, N.  (1970).  A generalized Kruskal-Wallis test for comparing <code class="reqn">K</code>
samples subject to unequal patterns of censorship.  <em>Biometrika</em>
<b>57</b>(3), 579&ndash;594.  <a href="https://doi.org/10.1093/biomet/57.3.579">doi:10.1093/biomet/57.3.579</a>
</p>
<p>Callaert, H.  (2003).  Comparing statistical software packages: The case of
the logrank test in StatXact.  <em>The American Statistician</em> <b>57</b>(3),
214&ndash;217.  <a href="https://doi.org/10.1198/0003130031900">doi:10.1198/0003130031900</a>
</p>
<p>Cox, D. R. (1972).  Regression models and life-tables (with discussion).
<em>Journal of the Royal Statistical Society</em> B <b>34</b>(2), 187&ndash;220.
<a href="https://doi.org/10.1111/j.2517-6161.1972.tb00899.x">doi:10.1111/j.2517-6161.1972.tb00899.x</a>
</p>
<p>Fleming, T. R. and Harrington, D. P.  (1991).  <em>Counting Processes and
Survival Analysis</em>.  New York: John Wiley &amp; Sons.
</p>
<p>Gaugler, T., Kim, D. and Liao, S.  (2007).  Comparing two survival time
distributions: An investigation of several weight functions for the weighted
logrank statistic.  <em>Communications in Statistics &ndash; Simulation and
Computation</em> <b>36</b>(2), 423&ndash;435.  <a href="https://doi.org/10.1080/03610910601161272">doi:10.1080/03610910601161272</a>
</p>
<p>Gehan, E. A.  (1965).  A generalized Wilcoxon test for comparing arbitrarily
single-censored samples.  <em>Biometrika</em> <b>52</b>(1&ndash;2), 203&ndash;223.
<a href="https://doi.org/10.1093/biomet/52.1-2.203">doi:10.1093/biomet/52.1-2.203</a>
</p>
<p>Hothorn, T. and Lausen, B.  (2003).  On the exact distribution of maximally
selected rank statistics.  <em>Computational Statistics &amp; Data Analysis</em>
<b>43</b>(2), 121&ndash;137.  <a href="https://doi.org/10.1016/S0167-9473%2802%2900225-6">doi:10.1016/S0167-9473(02)00225-6</a>
</p>
<p>Klein, J. P. and Moeschberger, M. L.  (2003).  <em>Survival Analysis:
Techniques for Censored and Truncated Data</em>, Second Edition.  New York:
Springer.
</p>
<p>Lee, J. W.  (1996).  Some versatile tests based on the simultaneous use of
weighted log-rank statistics.  <em>Biometrics</em> <b>52</b>(2), 721&ndash;725.
<a href="https://doi.org/10.2307/2532911">doi:10.2307/2532911</a>
</p>
<p>Letón, E. and Zuluaga, P.  (2001).  Equivalence between score
and weighted tests for survival curves.  <em>Communications in Statistics &ndash;
Theory and Methods</em> <b>30</b>(4), 591&ndash;608.  <a href="https://doi.org/10.1081/STA-100002138">doi:10.1081/STA-100002138</a>
</p>
<p>Mantel, N.  (1966).  Evaluation of survival data and two new rank order
statistics arising in its consideration.  <em>Cancer Chemotherapy Reports</em>
<b>50</b>(3), 163&ndash;170.
</p>
<p>Peto, R. and Peto, J.  (1972).  Asymptotic efficient rank invariant test
procedures (with discussion).  <em>Journal of the Royal Statistical Society</em>
A <b>135</b>(2), 185&ndash;207.  <a href="https://doi.org/10.2307/2344317">doi:10.2307/2344317</a>
</p>
<p>Prentice, R. L.  (1978).  Linear rank tests with right censored data.
<em>Biometrika</em> <b>65</b>(1), 167&ndash;179.  <a href="https://doi.org/10.1093/biomet/65.1.167">doi:10.1093/biomet/65.1.167</a>
</p>
<p>Prentice, R. L. and Marek, P.  (1979).  A qualitative discrepancy between
censored data rank tests.  <em>Biometrics</em> <b>35</b>(4), 861&ndash;867.
<a href="https://doi.org/10.2307/2530120">doi:10.2307/2530120</a>
</p>
<p>Self, S. G.  (1991).  An adaptive weighted log-rank test with application to
cancer prevention and screening trials.  <em>Biometrics</em> <b>47</b>(3),
975&ndash;986.  <a href="https://doi.org/10.2307/2532653">doi:10.2307/2532653</a>
</p>
<p>Tarone, R. E.  (1975).  Tests for trend in life table analysis.
<em>Biometrika</em> <b>62</b>(3), 679&ndash;682.  <a href="https://doi.org/10.1093/biomet/62.3.679">doi:10.1093/biomet/62.3.679</a>
</p>
<p>Tarone, R. E. and Ware, J.  (1977).  On distribution-free tests for equality
of survival distributions.  <em>Biometrika</em> <b>64</b>(1), 156&ndash;160.
<a href="https://doi.org/10.1093/biomet/64.1.156">doi:10.1093/biomet/64.1.156</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example data (Callaert, 2003, Tab. 1)
callaert &lt;- data.frame(
    time = c(1, 1, 5, 6, 6, 6, 6, 2, 2, 2, 3, 4, 4, 5, 5),
    group = factor(rep(0:1, c(7, 8)))
)

## Logrank scores using mid-ranks (Callaert, 2003, Tab. 2)
with(callaert,
     logrank_trafo(Surv(time)))

## Asymptotic Mantel-Cox test (p = 0.0523)
survdiff(Surv(time) ~ group, data = callaert)

## Exact logrank test using mid-ranks (p = 0.0505)
logrank_test(Surv(time) ~ group, data = callaert, distribution = "exact")

## Exact logrank test using average-scores (p = 0.0468)
logrank_test(Surv(time) ~ group, data = callaert, distribution = "exact",
             ties.method = "average-scores")


## Lung cancer data (StatXact 9 manual, p. 213, Tab. 7.19)
lungcancer &lt;- data.frame(
    time = c(257, 476, 355, 1779, 355,
             191, 563, 242, 285, 16, 16, 16, 257, 16),
    event = c(0, 0, 1, 1, 0,
              1, 1, 1, 1, 1, 1, 1, 1, 1),
    group = factor(rep(1:2, c(5, 9)),
                   labels = c("newdrug", "control"))
)

## Logrank scores using average-scores (StatXact 9 manual, p. 214)
with(lungcancer,
     logrank_trafo(Surv(time, event), ties.method = "average-scores"))

## Exact logrank test using average-scores (StatXact 9 manual, p. 215)
logrank_test(Surv(time, event) ~ group, data = lungcancer,
             distribution = "exact", ties.method = "average-scores")

## Exact Prentice test using average-scores (StatXact 9 manual, p. 222)
logrank_test(Surv(time, event) ~ group, data = lungcancer,
             distribution = "exact", ties.method = "average-scores",
             type = "Prentice")


## Approximative (Monte Carlo) versatile test (Lee, 1996)
rho.gamma &lt;- expand.grid(rho = seq(0, 2, 1), gamma = seq(0, 2, 1))
lee_trafo &lt;- function(y)
    logrank_trafo(y, ties.method = "average-scores",
                  type = "Fleming-Harrington",
                  rho = rho.gamma["rho"], gamma = rho.gamma["gamma"])

it &lt;- independence_test(Surv(time, event) ~ group, data = lungcancer,
                        distribution = approximate(nresample = 10000),
                        ytrafo = function(data)
                            trafo(data, surv_trafo = lee_trafo))
pvalue(it, method = "step-down")
</code></pre>

<hr>
<h2 id='SymmetryProblem-class'>Class <code>"SymmetryProblem"</code></h2><span id='topic+SymmetryProblem-class'></span><span id='topic+initialize+2CSymmetryProblem-method'></span>

<h3>Description</h3>

<p>Objects of class <code>"SymmetryProblem"</code> represent the data structure
corresponding to a symmetry problem.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form </p>
<pre>     new("SymmetryProblem", x, y, block = NULL, weights = NULL, ...)</pre>
<p>where <code>x</code> and <code>y</code> are data frames containing the variables
<code class="reqn">\mathbf{X}</code> and <code class="reqn">\mathbf{Y}</code>, respectively, <code>block</code> is an
optional factor representing the block structure <code class="reqn">b</code> and <code>weights</code> is
an optional integer vector corresponding to the case weights <code class="reqn">w</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>x</code>:</dt><dd>
<p>Object of class <code>"data.frame"</code>.  The variables <code>x</code>.
</p>
</dd>
<dt><code>y</code>:</dt><dd>
<p>Object of class <code>"data.frame"</code>.  The variables <code>y</code>.
</p>
</dd>
<dt><code>block</code>:</dt><dd>
<p>Object of class <code>"factor"</code>.  The block structure.
</p>
</dd>
<dt><code>weights</code>:</dt><dd>
<p>Object of class <code>"numeric"</code>.  The case weights.  (Not yet
implemented!)
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+IndependenceProblem-class">IndependenceProblem</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>initialize</dt><dd>
<p><code>signature(.Object = "SymmetryProblem")</code>: See the documentation for
<code><a href="methods.html#topic+new">initialize</a>()</code> (in package <span class="pkg">methods</span>) for
details.
</p>
</dd>
</dl>


<hr>
<h2 id='SymmetryTest'>General Symmetry Test</h2><span id='topic+symmetry_test'></span><span id='topic+symmetry_test.formula'></span><span id='topic+symmetry_test.table'></span><span id='topic+symmetry_test.SymmetryProblem'></span>

<h3>Description</h3>

<p>Testing the symmetry of set of repeated measurements variables measured on
arbitrary scales in a complete block design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
symmetry_test(formula, data, subset = NULL, weights = NULL, ...)
## S3 method for class 'table'
symmetry_test(object, ...)
## S3 method for class 'SymmetryProblem'
symmetry_test(object, teststat = c("maximum", "quadratic", "scalar"),
              distribution = c("asymptotic", "approximate",
                               "exact", "none"),
              alternative = c("two.sided", "less", "greater"),
              xtrafo = trafo, ytrafo = trafo, scores = NULL,
              check = NULL, paired = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SymmetryTest_+3A_formula">formula</code></td>
<td>

<p>a formula of the form <code>y1 + ... + yq ~ x | block</code> where <code>y1</code>,
..., <code>yq</code> are measured on arbitrary scales (nominal, ordinal or
continuous with or without censoring), <code>x</code> is a factor and <code>block</code>
is an optional factor (which is generated automatically if omitted).
</p>
</td></tr>
<tr><td><code id="SymmetryTest_+3A_data">data</code></td>
<td>

<p>an optional data frame containing the variables in the model formula.
</p>
</td></tr>
<tr><td><code id="SymmetryTest_+3A_subset">subset</code></td>
<td>

<p>an optional vector specifying a subset of observations to be used.  Defaults
to <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="SymmetryTest_+3A_weights">weights</code></td>
<td>

<p>an optional formula of the form <code>~ w</code> defining integer valued case
weights for each observation.  Defaults to <code>NULL</code>, implying equal
weight for all observations.  (Not yet implemented!)
</p>
</td></tr>
<tr><td><code id="SymmetryTest_+3A_object">object</code></td>
<td>

<p>an object inheriting from classes <code>"table"</code> (with identical
<code>dimnames</code> components) or <code>"<a href="#topic+SymmetryProblem-class">SymmetryProblem</a>"</code>.
</p>
</td></tr>
<tr><td><code id="SymmetryTest_+3A_teststat">teststat</code></td>
<td>

<p>a character, the type of test statistic to be applied: either a maximum
statistic (<code>"maximum"</code>, default), a quadratic form (<code>"quadratic"</code>)
or a standardized scalar test statistic (<code>"scalar"</code>).
</p>
</td></tr>
<tr><td><code id="SymmetryTest_+3A_distribution">distribution</code></td>
<td>

<p>a character, the conditional null distribution of the test statistic can be
approximated by its asymptotic distribution (<code>"asymptotic"</code>, default)
or via Monte Carlo resampling (<code>"approximate"</code>).  Alternatively, the
functions <code><a href="#topic+asymptotic">asymptotic</a></code> or <code><a href="#topic+approximate">approximate</a></code> can be used.
For univariate two-sample problems, <code>"exact"</code> or use of the function
<code><a href="#topic+exact">exact</a></code> computes the exact distribution.  Computation of the
null distribution can be suppressed by specifying <code>"none"</code>.  It is also
possible to specify a function with one argument (an object inheriting from
<code>"<a href="#topic+IndependenceTestStatistic-class">IndependenceTestStatistic</a>"</code>) that returns an object of
class <code>"<a href="#topic+NullDistribution-class">NullDistribution</a>"</code>.
</p>
</td></tr>
<tr><td><code id="SymmetryTest_+3A_alternative">alternative</code></td>
<td>

<p>a character, the alternative hypothesis: either <code>"two.sided"</code>
(default), <code>"greater"</code> or <code>"less"</code>.
</p>
</td></tr>
<tr><td><code id="SymmetryTest_+3A_xtrafo">xtrafo</code></td>
<td>

<p>a function of transformations to be applied to the factor <code>x</code> supplied
in <code>formula</code>; see &lsquo;Details&rsquo;.  Defaults to <code><a href="#topic+trafo">trafo</a>()</code>.
</p>
</td></tr>
<tr><td><code id="SymmetryTest_+3A_ytrafo">ytrafo</code></td>
<td>

<p>a function of transformations to be applied to the variables <code>y1</code>,
..., <code>yq</code> supplied in <code>formula</code>; see &lsquo;Details&rsquo;.
Defaults to <code><a href="#topic+trafo">trafo</a>()</code>.
</p>
</td></tr>
<tr><td><code id="SymmetryTest_+3A_scores">scores</code></td>
<td>

<p>a named list of scores to be attached to ordered factors; see
&lsquo;Details&rsquo;.  Defaults to <code>NULL</code>, implying equally spaced scores.
</p>
</td></tr>
<tr><td><code id="SymmetryTest_+3A_check">check</code></td>
<td>

<p>a function to be applied to objects of class
<code>"<a href="#topic+IndependenceTest-class">IndependenceTest</a>"</code> in order to check for specific
properties of the data.  Defaults to <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="SymmetryTest_+3A_paired">paired</code></td>
<td>

<p>a logical, indicating that paired data have been transformed in such a way
that the (unstandardized) linear statistic is the sum of the absolute values
of the positive differences between the paired observations.  Defaults to
<code>FALSE</code>.
</p>
</td></tr>
<tr><td><code id="SymmetryTest_+3A_...">...</code></td>
<td>

<p>further arguments to be passed to or from other methods (currently ignored).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>symmetry_test()</code> provides a general symmetry test for a set of variables
measured on arbitrary scales.  This function is based on the general framework
for conditional inference procedures proposed by Strasser and Weber (1999).
The salient parts of the Strasser-Weber framework are elucidated by Hothorn
<em>et al.</em> (2006) and a thorough description of the software implementation
is given by Hothorn <em>et al.</em> (2008).
</p>
<p>The null hypothesis of symmetry is tested.  The response variables and the
measurement conditions are given by <code>y1</code>, ..., <code>yq</code> and <code>x</code>,
respectively, and <code>block</code> is a factor where each level corresponds to
exactly one subject with repeated measurements.
</p>
<p>A vector of case weights, e.g., observation counts, can be supplied through
the <code>weights</code> argument and the type of test statistic is specified by
the <code>teststat</code> argument.  Influence and regression functions, i.e.,
transformations of <code>y1</code>, ..., <code>yq</code> and <code>x</code>, are specified by
the <code>ytrafo</code> and <code>xtrafo</code> arguments, respectively; see
<code><a href="#topic+trafo">trafo</a>()</code> for the collection of transformation functions currently
available.  This allows for implementation of both novel and familiar test
statistics, e.g., the McNemar test, the Cochran <code class="reqn">Q</code> test, the Wilcoxon
signed-rank test and the Friedman test.  Furthermore, multivariate extensions
such as the multivariate Friedman test (Gerig, 1969; Puri and Sen, 1971) can
be implemented without much effort (see &lsquo;Examples&rsquo;).
</p>
<p>If, say, <code>y1</code> and/or <code>x</code> are ordered factors, the default scores,
<code>1:nlevels(y1)</code> and <code>1:nlevels(x)</code>, respectively, can be altered
using the <code>scores</code> argument; this argument can also be used to coerce
nominal factors to class <code>"ordered"</code>.  For example, when <code>y1</code> is an
ordered factor with four levels and <code>x</code> is a nominal factor with three
levels, <code>scores = list(y1 = c(1, 3:5), x = c(1:2, 4))</code> supplies the
scores to be used.  For ordered alternatives the scores must be monotonic, but
non-monotonic scores are also allowed for testing against, e.g., umbrella
alternatives.  The length of the score vector must be equal to the number of
factor levels.
</p>
<p>The conditional null distribution of the test statistic is used to obtain
<code class="reqn">p</code>-values and an asymptotic approximation of the exact distribution is
used by default (<code>distribution = "asymptotic"</code>).  Alternatively, the
distribution can be approximated via Monte Carlo resampling or computed
exactly for univariate two-sample problems by setting <code>distribution</code> to
<code>"approximate"</code> or <code>"exact"</code>, respectively.  See
<code><a href="#topic+asymptotic">asymptotic</a>()</code>, <code><a href="#topic+approximate">approximate</a>()</code> and
<code><a href="#topic+exact">exact</a>()</code> for details.
</p>


<h3>Value</h3>

<p>An object inheriting from class <code>"<a href="#topic+IndependenceTest-class">IndependenceTest</a>"</code>.
</p>


<h3>Note</h3>

<p>Starting with <span class="pkg">coin</span> version 1.1-0, maximum statistics and quadratic forms
can no longer be specified using <code>teststat = "maxtype"</code> and
<code>teststat = "quadtype"</code> respectively (as was used in versions prior to
0.4-5).
</p>


<h3>References</h3>

<p>Gerig, T.  (1969).  A multivariate extension of Friedman's
<code class="reqn">\chi^2_r</code>-test.  <em>Journal of the American Statistical
Association</em> <b>64</b>(328), 1595&ndash;1608.
<a href="https://doi.org/10.1080/01621459.1969.10501079">doi:10.1080/01621459.1969.10501079</a>
</p>
<p>Hothorn, T., Hornik, K., van de Wiel, M. A. and Zeileis, A.  (2006).  A Lego
system for conditional inference.  <em>The American Statistician</em>
<b>60</b>(3), 257&ndash;263.  <a href="https://doi.org/10.1198/000313006X118430">doi:10.1198/000313006X118430</a>
</p>
<p>Hothorn, T., Hornik, K., van de Wiel, M. A. and Zeileis, A.  (2008).
Implementing a class of permutation tests: The coin package.  <em>Journal of
Statistical Software</em> <b>28</b>(8), 1&ndash;23.  <a href="https://doi.org/10.18637/jss.v028.i08">doi:10.18637/jss.v028.i08</a>
</p>
<p>Puri, M. L. and Sen, P. K.  (1971).  <em>Nonparametric Methods in
Multivariate Analysis</em>.  New York: John Wiley &amp; Sons.
</p>
<p>Strasser, H. and Weber, C.  (1999).  On the asymptotic theory of permutation
statistics.  <em>Mathematical Methods of Statistics</em> <b>8</b>(2), 220&ndash;250.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## One-sided exact Fisher-Pitman test for paired observations
y1 &lt;- c(1.83,  0.50,  1.62,  2.48, 1.68, 1.88, 1.55, 3.06, 1.30)
y2 &lt;- c(0.878, 0.647, 0.598, 2.05, 1.06, 1.29, 1.06, 3.14, 1.29)
dta &lt;- data.frame(
    y = c(y1, y2),
    x = gl(2, length(y1)),
    block = factor(rep(seq_along(y1), 2))
)

symmetry_test(y ~ x | block, data = dta,
              distribution = "exact", alternative = "greater")

## Alternatively: transform data and set 'paired = TRUE'
delta &lt;- y1 - y2
y &lt;- as.vector(rbind(abs(delta) * (delta &gt;= 0), abs(delta) * (delta &lt; 0)))
x &lt;- factor(rep(0:1, length(delta)), labels = c("pos", "neg"))
block &lt;- gl(length(delta), 2)

symmetry_test(y ~ x | block,
              distribution = "exact", alternative = "greater",
              paired = TRUE)


### Example data
### Gerig (1969, p. 1597)
gerig &lt;- data.frame(
    y1 = c( 0.547, 1.811, 2.561,
            1.706, 2.509, 1.414,
           -0.288, 2.524, 3.310,
            1.417, 0.703, 0.961,
            0.878, 0.094, 1.682,
           -0.680, 2.077, 3.181,
            0.056, 0.542, 2.983,
            0.711, 0.269, 1.662,
           -1.335, 1.545, 2.920,
            1.635, 0.200, 2.065),
    y2 = c(-0.575, 1.840, 2.399,
            1.252, 1.574, 3.059,
           -0.310, 1.553, 0.560,
            0.932, 1.390, 3.083,
            0.819, 0.045, 3.348,
            0.497, 1.747, 1.355,
           -0.285, 0.760, 2.332,
            0.089, 1.076, 0.960,
           -0.349, 1.471, 4.121,
            0.845, 1.480, 3.391),
    x = factor(rep(1:3, 10)),
    b = factor(rep(1:10, each = 3))
)

### Asymptotic multivariate Friedman test
### Gerig (1969, p. 1599)
symmetry_test(y1 + y2 ~ x | b, data = gerig, teststat = "quadratic",
              ytrafo = function(data)
                  trafo(data, numeric_trafo = rank_trafo,
                        block = gerig$b)) # L_n = 17.238

### Asymptotic multivariate Page test
(st &lt;- symmetry_test(y1 + y2 ~ x | b, data = gerig,
                     ytrafo = function(data)
                         trafo(data, numeric_trafo = rank_trafo,
                               block = gerig$b),
                     scores = list(x = 1:3)))
pvalue(st, method = "step-down")
</code></pre>

<hr>
<h2 id='SymmetryTests'>Symmetry Tests</h2><span id='topic+sign_test'></span><span id='topic+sign_test.formula'></span><span id='topic+sign_test.SymmetryProblem'></span><span id='topic+wilcoxsign_test'></span><span id='topic+wilcoxsign_test.formula'></span><span id='topic+wilcoxsign_test.SymmetryProblem'></span><span id='topic+friedman_test'></span><span id='topic+friedman_test.formula'></span><span id='topic+friedman_test.SymmetryProblem'></span><span id='topic+quade_test'></span><span id='topic+quade_test.formula'></span><span id='topic+quade_test.SymmetryProblem'></span>

<h3>Description</h3>

<p>Testing the symmetry of a numeric repeated measurements variable in a complete
block design.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'formula'
sign_test(formula, data, subset = NULL, ...)
## S3 method for class 'SymmetryProblem'
sign_test(object, ...)

## S3 method for class 'formula'
wilcoxsign_test(formula, data, subset = NULL, ...)
## S3 method for class 'SymmetryProblem'
wilcoxsign_test(object, zero.method = c("Pratt", "Wilcoxon"), ...)

## S3 method for class 'formula'
friedman_test(formula, data, subset = NULL, ...)
## S3 method for class 'SymmetryProblem'
friedman_test(object, ...)

## S3 method for class 'formula'
quade_test(formula, data, subset = NULL, ...)
## S3 method for class 'SymmetryProblem'
quade_test(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SymmetryTests_+3A_formula">formula</code></td>
<td>

<p>a formula of the form <code>y ~ x | block</code> where <code>y</code> is a numeric
variable, <code>x</code> is a factor with two (<code>sign_test</code> and
<code>wilcoxsign_test</code>) or more levels and <code>block</code> is an optional
factor (which is generated automatically if omitted).
</p>
</td></tr>
<tr><td><code id="SymmetryTests_+3A_data">data</code></td>
<td>

<p>an optional data frame containing the variables in the model formula.
</p>
</td></tr>
<tr><td><code id="SymmetryTests_+3A_subset">subset</code></td>
<td>

<p>an optional vector specifying a subset of observations to be used.  Defaults
to <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="SymmetryTests_+3A_object">object</code></td>
<td>

<p>an object inheriting from class <code>"<a href="#topic+SymmetryProblem-class">SymmetryProblem</a>"</code>.
</p>
</td></tr>
<tr><td><code id="SymmetryTests_+3A_zero.method">zero.method</code></td>
<td>

<p>a character, the method used to handle zeros: either <code>"Pratt"</code>
(default) or <code>"Wilcoxon"</code>; see &lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="SymmetryTests_+3A_...">...</code></td>
<td>

<p>further arguments to be passed to <code><a href="#topic+symmetry_test">symmetry_test</a>()</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sign_test()</code>, <code>wilcoxsign_test()</code>, <code>friedman_test()</code> and
<code>quade_test()</code> provide the sign test, the Wilcoxon signed-rank test, the
Friedman test, the Page test and the Quade test.  A general description of
these methods is given by Hollander and Wolfe (1999).
</p>
<p>The null hypothesis of symmetry is tested.  The response variable and the
measurement conditions are given by <code>y</code> and <code>x</code>, respectively, and
<code>block</code> is a factor where each level corresponds to exactly one subject
with repeated measurements.  For <code>sign_test</code> and <code>wilcoxsign_test</code>,
formulae of the form <code>y ~ x | block</code> and <code>y ~ x</code> are allowed.  The
latter form is interpreted as <code>y</code> is the first and <code>x</code> the second
measurement on the same subject.
</p>
<p>If <code>x</code> is an ordered factor, the default scores, <code>1:nlevels(x)</code>, can
be altered using the <code>scores</code> argument (see <code><a href="#topic+symmetry_test">symmetry_test</a>()</code>);
this argument can also be used to coerce nominal factors to class
<code>"ordered"</code>.  In this case, a linear-by-linear association test is
computed and the direction of the alternative hypothesis can be specified
using the <code>alternative</code> argument.  For the Friedman test, this extension
was given by Page (1963) and is known as the Page test.
</p>
<p>For <code>wilcoxsign_test()</code>, the default method of handling zeros
(<code>zero.method = "Pratt"</code>), due to Pratt (1959), first rank-transforms the
absolute differences (including zeros) and then discards the ranks
corresponding to the zero-differences.  The proposal by Wilcoxon (1949, p. 6)
first discards the zero-differences and then rank-transforms the remaining
absolute differences (<code>zero.method = "Wilcoxon"</code>).
</p>
<p>The conditional null distribution of the test statistic is used to obtain
<code class="reqn">p</code>-values and an asymptotic approximation of the exact distribution is
used by default (<code>distribution = "asymptotic"</code>).  Alternatively, the
distribution can be approximated via Monte Carlo resampling or computed
exactly for univariate two-sample problems by setting <code>distribution</code> to
<code>"approximate"</code> or <code>"exact"</code>, respectively.  See
<code><a href="#topic+asymptotic">asymptotic</a>()</code>, <code><a href="#topic+approximate">approximate</a>()</code> and
<code><a href="#topic+exact">exact</a>()</code> for details.
</p>


<h3>Value</h3>

<p>An object inheriting from class <code>"<a href="#topic+IndependenceTest-class">IndependenceTest</a>"</code>.
</p>


<h3>Note</h3>

<p>Starting with <span class="pkg">coin</span> version 1.0-16, the <code>zero.method</code> argument
replaced the (now removed) <code>ties.method</code> argument.  The current default
is <code>zero.method = "Pratt"</code> whereas earlier versions had
<code>ties.method = "HollanderWolfe"</code>, which is equivalent to
<code>zero.method = "Wilcoxon"</code>.
</p>


<h3>References</h3>

<p>Hollander, M. and Wolfe, D. A.  (1999).  <em>Nonparametric Statistical
Methods</em>, Second Edition.  New York: John Wiley &amp; Sons.
</p>
<p>Page, E. B.  (1963).  Ordered hypotheses for multiple treatments: a
significance test for linear ranks.  <em>Journal of the American Statistical
Association</em> <b>58</b>(301), 216&ndash;230.  <a href="https://doi.org/10.1080/01621459.1963.10500843">doi:10.1080/01621459.1963.10500843</a>
</p>
<p>Pratt, J. W.  (1959).  Remarks on zeros and ties in the Wilcoxon signed rank
procedures.  <em>Journal of the American Statistical Association</em>
<b>54</b>(287), 655&ndash;667.  <a href="https://doi.org/10.1080/01621459.1959.10501526">doi:10.1080/01621459.1959.10501526</a>
</p>
<p>Quade, D.  (1979).  Using weighted rankings in the analysis of complete blocks
with additive block effects.  <em>Journal of the American Statistical
Association</em> <b>74</b>(367), 680&ndash;683.  <a href="https://doi.org/10.1080/01621459.1979.10481670">doi:10.1080/01621459.1979.10481670</a>
</p>
<p>Wilcoxon, F.  (1949).  <em>Some Rapid Approximate Statistical Procedures</em>.
New York: American Cyanamid Company.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example data from ?wilcox.test
y1 &lt;- c(1.83,  0.50,  1.62,  2.48, 1.68, 1.88, 1.55, 3.06, 1.30)
y2 &lt;- c(0.878, 0.647, 0.598, 2.05, 1.06, 1.29, 1.06, 3.14, 1.29)

## One-sided exact sign test
(st &lt;- sign_test(y1 ~ y2, distribution = "exact",
                 alternative = "greater"))
midpvalue(st) # mid-p-value

## One-sided exact Wilcoxon signed-rank test
(wt &lt;- wilcoxsign_test(y1 ~ y2, distribution = "exact",
                       alternative = "greater"))
statistic(wt, type = "linear")
midpvalue(wt) # mid-p-value

## Comparison with R's wilcox.test() function
wilcox.test(y1, y2, paired = TRUE, alternative = "greater")


## Data with explicit group and block information
dta &lt;- data.frame(y = c(y1, y2), x = gl(2, length(y1)),
                  block = factor(rep(seq_along(y1), 2)))

## For two samples, the sign test is equivalent to the Friedman test...
sign_test(y ~ x | block, data = dta, distribution = "exact")
friedman_test(y ~ x | block, data = dta, distribution = "exact")

## ...and the signed-rank test is equivalent to the Quade test
wilcoxsign_test(y ~ x | block, data = dta, distribution = "exact")
quade_test(y ~ x | block, data = dta, distribution = "exact")


## Comparison of three methods ("round out", "narrow angle", and "wide angle")
## for rounding first base.
## Hollander and Wolfe (1999, p. 274, Tab. 7.1)
rounding &lt;- data.frame(
    times = c(5.40, 5.50, 5.55,
              5.85, 5.70, 5.75,
              5.20, 5.60, 5.50,
              5.55, 5.50, 5.40,
              5.90, 5.85, 5.70,
              5.45, 5.55, 5.60,
              5.40, 5.40, 5.35,
              5.45, 5.50, 5.35,
              5.25, 5.15, 5.00,
              5.85, 5.80, 5.70,
              5.25, 5.20, 5.10,
              5.65, 5.55, 5.45,
              5.60, 5.35, 5.45,
              5.05, 5.00, 4.95,
              5.50, 5.50, 5.40,
              5.45, 5.55, 5.50,
              5.55, 5.55, 5.35,
              5.45, 5.50, 5.55,
              5.50, 5.45, 5.25,
              5.65, 5.60, 5.40,
              5.70, 5.65, 5.55,
              6.30, 6.30, 6.25),
    methods = factor(rep(1:3, 22),
                     labels = c("Round Out", "Narrow Angle", "Wide Angle")),
    block = gl(22, 3)
)

## Asymptotic Friedman test
friedman_test(times ~ methods | block, data = rounding)

## Parallel coordinates plot
with(rounding, {
    matplot(t(matrix(times, ncol = 3, byrow = TRUE)),
            type = "l", lty = 1, col = 1, ylab = "Time", xlim = c(0.5, 3.5),
            axes = FALSE)
    axis(1, at = 1:3, labels = levels(methods))
    axis(2)
})

## Where do the differences come from?
## Wilcoxon-Nemenyi-McDonald-Thompson test (Hollander and Wolfe, 1999, p. 295)
## Note: all pairwise comparisons
(st &lt;- symmetry_test(times ~ methods | block, data = rounding,
                     ytrafo = function(data)
                         trafo(data, numeric_trafo = rank_trafo,
                               block = rounding$block),
                     xtrafo = mcp_trafo(methods = "Tukey")))

## Simultaneous test of all pairwise comparisons
## Wide Angle vs. Round Out differ (Hollander and Wolfe, 1999, p. 296)
pvalue(st, method = "single-step") # subset pivotality is violated


## Strength Index of Cotton
## Hollander and Wolfe (1999, p. 286, Tab. 7.5)
cotton &lt;- data.frame(
    strength = c(7.46, 7.17, 7.76, 8.14, 7.63,
                 7.68, 7.57, 7.73, 8.15, 8.00,
                 7.21, 7.80, 7.74, 7.87, 7.93),
    potash = ordered(rep(c(144, 108, 72, 54, 36), 3),
                     levels = c(144, 108, 72, 54, 36)),
    block = gl(3, 5)
)

## One-sided asymptotic Page test
friedman_test(strength ~ potash | block, data = cotton, alternative = "greater")

## One-sided approximative (Monte Carlo) Page test
friedman_test(strength ~ potash | block, data = cotton, alternative = "greater",
              distribution = approximate(nresample = 10000))


## Data from Quade (1979, p. 683)
dta &lt;- data.frame(
    y = c(52, 45, 38,
          63, 79, 50,
          45, 57, 39,
          53, 51, 43,
          47, 50, 56,
          62, 72, 49,
          49, 52, 40),
     x = factor(rep(LETTERS[1:3], 7)),
     b = factor(rep(1:7, each = 3))
)

## Approximative (Monte Carlo) Friedman test
## Quade (1979, p. 683)
friedman_test(y ~ x | b, data = dta,
              distribution = approximate(nresample = 10000)) # chi^2 = 6.000

## Approximative (Monte Carlo) Quade test
## Quade (1979, p. 683)
(qt &lt;- quade_test(y ~ x | b, data = dta,
                  distribution = approximate(nresample = 10000))) # W = 8.157

## Comparison with R's quade.test() function
quade.test(y ~ x | b, data = dta)

## quade.test() uses an F-statistic
b &lt;- nlevels(qt@statistic@block)
A &lt;- sum(qt@statistic@ytrans^2)
B &lt;- sum(statistic(qt, type = "linear")^2) / b
(b - 1) * B / (A - B) # F = 8.3765
</code></pre>

<hr>
<h2 id='Transformations'>Functions for Data Transformation</h2><span id='topic+id_trafo'></span><span id='topic+rank_trafo'></span><span id='topic+normal_trafo'></span><span id='topic+median_trafo'></span><span id='topic+savage_trafo'></span><span id='topic+consal_trafo'></span><span id='topic+koziol_trafo'></span><span id='topic+klotz_trafo'></span><span id='topic+mood_trafo'></span><span id='topic+ansari_trafo'></span><span id='topic+fligner_trafo'></span><span id='topic+logrank_trafo'></span><span id='topic+logrank_weight'></span><span id='topic+maxstat_trafo'></span><span id='topic+fmaxstat_trafo'></span><span id='topic+ofmaxstat_trafo'></span><span id='topic+f_trafo'></span><span id='topic+of_trafo'></span><span id='topic+zheng_trafo'></span><span id='topic+trafo'></span><span id='topic+mcp_trafo'></span>

<h3>Description</h3>

<p>Transformations for factors and numeric variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>id_trafo(x)
rank_trafo(x, ties.method = c("mid-ranks", "random"))
normal_trafo(x, ties.method = c("mid-ranks", "average-scores"))
median_trafo(x, mid.score = c("0", "0.5", "1"))
savage_trafo(x, ties.method = c("mid-ranks", "average-scores"))
consal_trafo(x, ties.method = c("mid-ranks", "average-scores"), a = 5)
koziol_trafo(x, ties.method = c("mid-ranks", "average-scores"), j = 1)
klotz_trafo(x, ties.method = c("mid-ranks", "average-scores"))
mood_trafo(x, ties.method = c("mid-ranks", "average-scores"))
ansari_trafo(x, ties.method = c("mid-ranks", "average-scores"))
fligner_trafo(x, ties.method = c("mid-ranks", "average-scores"))
logrank_trafo(x, ties.method = c("mid-ranks", "Hothorn-Lausen",
                                 "average-scores"),
              weight = logrank_weight, ...)
logrank_weight(time, n.risk, n.event,
               type = c("logrank", "Gehan-Breslow", "Tarone-Ware",
                        "Peto-Peto", "Prentice", "Prentice-Marek",
                        "Andersen-Borgan-Gill-Keiding", "Fleming-Harrington",
                        "Gaugler-Kim-Liao", "Self"),
               rho = NULL, gamma = NULL)
f_trafo(x)
of_trafo(x, scores = NULL)
zheng_trafo(x, increment = 0.1)
maxstat_trafo(x, minprob = 0.1, maxprob = 1 - minprob)
fmaxstat_trafo(x, minprob = 0.1, maxprob = 1 - minprob)
ofmaxstat_trafo(x, minprob = 0.1, maxprob = 1 - minprob)
trafo(data, numeric_trafo = id_trafo, factor_trafo = f_trafo,
      ordered_trafo = of_trafo, surv_trafo = logrank_trafo,
      var_trafo = NULL, block = NULL)
mcp_trafo(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Transformations_+3A_x">x</code></td>
<td>

<p>an object of class <code>"numeric"</code>, <code>"factor"</code>, <code>"ordered"</code> or
<code>"Surv"</code>.
</p>
</td></tr>
<tr><td><code id="Transformations_+3A_ties.method">ties.method</code></td>
<td>

<p>a character, the method used to handle ties.  The score generating function
either uses the mid-ranks (<code>"mid-ranks"</code>, default) or, in the case of
<code>rank_trafo()</code>, randomly broken ties (<code>"random"</code>).  Alternatively,
the average of the scores resulting from applying the score generating
function to randomly broken ties are used (<code>"average-scores"</code>).  See
<code><a href="#topic+logrank_test">logrank_test</a>()</code> for a detailed description of the methods used
in <code>logrank_trafo()</code>.
</p>
</td></tr>
<tr><td><code id="Transformations_+3A_mid.score">mid.score</code></td>
<td>

<p>a character, the score assigned to observations exactly equal to the median:
either 0 (<code>"0"</code>, default), 0.5 (<code>"0.5"</code>) or 1 (<code>"1"</code>); see
<code><a href="#topic+median_test">median_test</a>()</code>.
</p>
</td></tr>
<tr><td><code id="Transformations_+3A_a">a</code></td>
<td>

<p>a numeric vector, the values taken as the constant <code class="reqn">a</code> in the
Conover-Salsburg scores.  Defaults to <code>5</code>.
</p>
</td></tr>
<tr><td><code id="Transformations_+3A_j">j</code></td>
<td>

<p>a numeric, the value taken as the constant <code class="reqn">j</code> in the Koziol-Nemec
scores.  Defaults to <code>1</code>.
</p>
</td></tr>
<tr><td><code id="Transformations_+3A_weight">weight</code></td>
<td>

<p>a function where the first three arguments must correspond to <code>time</code>,
<code>n.risk</code>, and <code>n.event</code> given below.  Defaults to
<code>logrank_weight</code>.
</p>
</td></tr>
<tr><td><code id="Transformations_+3A_time">time</code></td>
<td>

<p>a numeric vector, the ordered distinct time points.
</p>
</td></tr>
<tr><td><code id="Transformations_+3A_n.risk">n.risk</code></td>
<td>

<p>a numeric vector, the number of subjects at risk at each time point
specified in <code>time</code>.
</p>
</td></tr>
<tr><td><code id="Transformations_+3A_n.event">n.event</code></td>
<td>

<p>a numeric vector, the number of events at each time point specified in
<code>time</code>.
</p>
</td></tr>
<tr><td><code id="Transformations_+3A_type">type</code></td>
<td>

<p>a character, one of <code>"logrank"</code> (default), <code>"Gehan-Breslow"</code>,
<code>"Tarone-Ware"</code>, <code>"Peto-Peto"</code>, <code>"Prentice"</code>,
<code>"Prentice-Marek"</code>, <code>"Andersen-Borgan-Gill-Keiding"</code>,
<code>"Fleming-Harrington"</code>, <code>"Gaugler-Kim-Liao"</code> or <code>"Self"</code>; see
<code><a href="#topic+logrank_test">logrank_test</a>()</code>.
</p>
</td></tr>
<tr><td><code id="Transformations_+3A_rho">rho</code></td>
<td>

<p>a numeric vector, the <code class="reqn">\rho</code> constant when <code>type</code> is
<code>"Tarone-Ware"</code>, <code>"Fleming-Harrington"</code>, <code>"Gaugler-Kim-Liao"</code>
or <code>"Self"</code>; see <code><a href="#topic+logrank_test">logrank_test</a>()</code>.  Defaults to
<code>NULL</code>, implying <code>0.5</code> for <code>type = "Tarone-Ware"</code> and
<code>0</code> otherwise.
</p>
</td></tr>
<tr><td><code id="Transformations_+3A_gamma">gamma</code></td>
<td>

<p>a numeric vector, the <code class="reqn">\gamma</code> constant when <code>type</code> is
<code>"Fleming-Harrington"</code>, <code>"Gaugler-Kim-Liao"</code> or <code>"Self"</code>; see
<code><a href="#topic+logrank_test">logrank_test</a>()</code>.  Defaults to <code>NULL</code>, implying <code>0</code>.
</p>
</td></tr>
<tr><td><code id="Transformations_+3A_scores">scores</code></td>
<td>

<p>a numeric vector or list, the scores corresponding to each level of an
ordered factor.  Defaults to <code>NULL</code>, implying <code>1:nlevels(x)</code>.
</p>
</td></tr>
<tr><td><code id="Transformations_+3A_increment">increment</code></td>
<td>

<p>a numeric, the score increment between the order-restricted sets of scores.
A fraction greater than 0, but smaller than or equal to 1.  Defaults to
<code>0.1</code>.
</p>
</td></tr>
<tr><td><code id="Transformations_+3A_minprob">minprob</code></td>
<td>

<p>a numeric, a fraction between 0 and 0.5; see <code><a href="#topic+maxstat_test">maxstat_test</a>()</code>.
Defaults to <code>0.1</code>.
</p>
</td></tr>
<tr><td><code id="Transformations_+3A_maxprob">maxprob</code></td>
<td>

<p>a numeric, a fraction between 0.5 and 1; see <code><a href="#topic+maxstat_test">maxstat_test</a>()</code>.
Defaults to <code>1 - minprob</code>.
</p>
</td></tr>
<tr><td><code id="Transformations_+3A_data">data</code></td>
<td>

<p>an object of class <code>"data.frame"</code>.
</p>
</td></tr>
<tr><td><code id="Transformations_+3A_numeric_trafo">numeric_trafo</code></td>
<td>

<p>a function to be applied to elements of class <code>"numeric"</code> in
<code>data</code>, returning a matrix with <code>nrow(data)</code> rows and an arbitrary
number of columns.  Defaults to <code>id_trafo</code>.
</p>
</td></tr>
<tr><td><code id="Transformations_+3A_factor_trafo">factor_trafo</code></td>
<td>

<p>a function to be applied to elements of class <code>"factor"</code> in
<code>data</code>, returning a matrix with <code>nrow(data)</code> rows and an arbitrary
number of columns.  Defaults to <code>f_trafo</code>.
</p>
</td></tr>
<tr><td><code id="Transformations_+3A_ordered_trafo">ordered_trafo</code></td>
<td>

<p>a function to be applied to elements of class <code>"ordered"</code> in
<code>data</code>, returning a matrix with <code>nrow(data)</code> rows and an arbitrary
number of columns.  Defaults to <code>of_trafo</code>.
</p>
</td></tr>
<tr><td><code id="Transformations_+3A_surv_trafo">surv_trafo</code></td>
<td>

<p>a function to be applied to elements of class <code>"Surv"</code> in <code>data</code>,
returning a matrix with <code>nrow(data)</code> rows and an arbitrary number of
columns.  Defaults to <code>logrank_trafo</code>.
</p>
</td></tr>
<tr><td><code id="Transformations_+3A_var_trafo">var_trafo</code></td>
<td>

<p>an optional named list of functions to be applied to the corresponding
variables in <code>data</code>.  Defaults to <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="Transformations_+3A_block">block</code></td>
<td>

<p>an optional factor whose levels are interpreted as blocks.  <code>trafo</code> is
applied to each level of <code>block</code> separately.  Defaults to <code>NULL</code>.
</p>
</td></tr>
<tr><td><code id="Transformations_+3A_...">...</code></td>
<td>

<p><code>logrank_trafo()</code>: further arguments to be passed to <code>weight</code>.

<code>mcp_trafo()</code>: factor name and contrast matrix (as matrix or character)
in a &lsquo;<span class="samp">&#8288;tag = value&#8288;</span>&rsquo; format for multiple comparisons based on a single
unordered factor; see <code><a href="multcomp.html#topic+glht">mcp</a>()</code> in package
<span class="pkg">multcomp</span>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The utility functions documented here are used to define specialized test
procedures.
</p>
<p><code>id_trafo()</code> is the identity transformation.
</p>
<p><code>rank_trafo()</code>, <code>normal_trafo()</code>, <code>median_trafo()</code>,
<code>savage_trafo()</code>, <code>consal_trafo()</code> and <code>koziol_trafo()</code> compute
rank (Wilcoxon) scores, normal (van der Waerden) scores, median (Mood-Brown)
scores, Savage scores, Conover-Salsburg scores (see <code><a href="#topic+neuropathy">neuropathy</a></code>)
and Koziol-Nemec scores, respectively, for location problems.
</p>
<p><code>klotz_trafo()</code>, <code>mood_trafo()</code>, <code>ansari_trafo()</code> and
<code>fligner_trafo()</code> compute Klotz scores, Mood scores, Ansari-Bradley
scores and Fligner-Killeen scores, respectively, for scale problems.
</p>
<p><code>logrank_trafo()</code> computes weighted logrank scores for right-censored
data, allowing for a user-defined weight function through the <code>weight</code>
argument (see <code><a href="#topic+GTSG">GTSG</a></code>).
</p>
<p><code>f_trafo()</code> computes dummy matrices for factors and <code>of_trafo()</code>
assigns scores to ordered factors.  For ordered factors with two levels, the
scores are normalized to the <code class="reqn">[0, 1]</code> range.  <code>zheng_trafo()</code>
computes a finite collection of order-restricted scores for ordered factors
(see <code><a href="#topic+jobsatisfaction">jobsatisfaction</a></code>, <code><a href="#topic+malformations">malformations</a></code> and
<code><a href="#topic+vision">vision</a></code>).
</p>
<p><code>maxstat_trafo()</code>, <code>fmaxstat_trafo()</code> and <code>ofmaxstat_trafo()</code>
compute scores for cutpoint problems (see <code><a href="#topic+maxstat_test">maxstat_test</a>()</code>).
</p>
<p><code>trafo()</code> applies its arguments to the elements of <code>data</code> according
to the classes of the elements.  A <code>trafo()</code> function with modified
default arguments is usually supplied to <code><a href="#topic+independence_test">independence_test</a>()</code> via
the <code>xtrafo</code> or <code>ytrafo</code> arguments.  Fine tuning, i.e., different
transformations for different variables, is possible by supplying a named list
of functions to the <code>var_trafo</code> argument.
</p>
<p><code>mcp_trafo()</code> computes contrast matrices for factors.
</p>


<h3>Value</h3>

<p>A numeric vector or matrix with <code>nrow(x)</code> rows and an arbitrary number of
columns.  For <code>trafo()</code>, a named matrix with <code>nrow(data)</code> rows and an
arbitrary number of columns.
</p>


<h3>Note</h3>

<p>Starting with <span class="pkg">coin</span> version 1.1-0, all transformation functions are now
passing through missing values (i.e., <code><a href="base.html#topic+NA">NA</a></code>s).  Furthermore,
<code>median_trafo()</code> and <code>logrank_trafo()</code> are now <em>increasing</em>
functions (in conformity with most other transformations in this package).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Dummy matrix, two-sample problem (only one column)
f_trafo(gl(2, 3))

## Dummy matrix, K-sample problem (K columns)
x &lt;- gl(3, 2)
f_trafo(x)

## Score matrix
ox &lt;- as.ordered(x)
of_trafo(ox)
of_trafo(ox, scores = c(1, 3:4))
of_trafo(ox, scores = list(s1 = 1:3, s2 = c(1, 3:4)))
zheng_trafo(ox, increment = 1/3)

## Normal scores
y &lt;- runif(6)
normal_trafo(y)

## All together now
trafo(data.frame(x = x, ox = ox, y = y), numeric_trafo = normal_trafo)

## The same, but allows for fine-tuning
trafo(data.frame(x = x, ox = ox, y = y), var_trafo = list(y = normal_trafo))

## Transformations for maximally selected statistics
maxstat_trafo(y)
fmaxstat_trafo(x)
ofmaxstat_trafo(ox)

## Apply transformation blockwise (as in the Friedman test)
trafo(data.frame(y = 1:20), numeric_trafo = rank_trafo, block = gl(4, 5))

## Multiple comparisons
dta &lt;- data.frame(x)
mcp_trafo(x = "Tukey")(dta)

## The same, but useful when specific contrasts are desired
K &lt;- rbind("2 - 1" = c(-1,  1, 0),
           "3 - 1" = c(-1,  0, 1),
           "3 - 2" = c( 0, -1, 1))
mcp_trafo(x = K)(dta)
</code></pre>

<hr>
<h2 id='treepipit'>Tree Pipits in Franconian Oak Forests</h2><span id='topic+treepipit'></span>

<h3>Description</h3>

<p>Data on the population density of tree pipits, <em>Anthus trivialis</em>, in
Franconian oak forests including variables describing the forest ecosystem.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>treepipit</code></pre>


<h3>Format</h3>

<p>A data frame with 86 observations on 10 variables.
</p>

<dl>
<dt><code>counts</code></dt><dd>
<p>the number of tree pipits observed.
</p>
</dd>
<dt><code>age</code></dt><dd>
<p>age of the overstorey oaks taken from forest data.
</p>
</dd>
<dt><code>coverstorey</code></dt><dd>
<p>cover of canopy overstorey (%).  The crown cover is described relative to
a fully stocked stand.  Very dense overstorey with multiple crown cover
could reach values greater than 100%.
</p>
</dd>
<dt><code>coverregen</code></dt><dd>
<p>cover of regeneration and shrubs (%).
</p>
</dd>
<dt><code>meanregen</code></dt><dd>
<p>mean height of regeneration and shrubs.
</p>
</dd>
<dt><code>coniferous</code></dt><dd>
<p>coniferous trees (% per hectare).
</p>
</dd>
<dt><code>deadtree</code></dt><dd>
<p>number of dead trees (per hectare).
</p>
</dd>
<dt><code>cbpiles</code></dt><dd>
<p>number of crowns and branch piles (per hectare).  All laying crowns and
branch piles were counted.  These were induced by logging and the creation
of wind breaks.
</p>
</dd>
<dt><code>ivytree</code></dt><dd>
<p>number of ivied trees (per hectare).
</p>
</dd>
<dt><code>fdist</code></dt><dd>
<p>distance to the forest edge.  The closest distance to the forest edge was
measured from the centre of each grid.
</p>
</dd>
</dl>



<h3>Details</h3>

<p>This study is based on fieldwork conducted in three lowland oak forests in the
Franconian region of northern Bavaria close to Uffenheim, Germany.  Diurnal
breeding birds were sampled five times, from March to June 2002, using a
quantitative grid mapping.  Each grid was a one-hectare square.  In total, 86
sample sites were established in 9 stands.  All individuals were counted in
time intervals of 7 min/grid during slow walks along the middle of the grid
with a stop in the centre.  Environmental factors were measured for each
grid.
</p>


<h3>References</h3>

<p>Müller, J. and Hothorn, T.  (2004).  Maximally selected
two-sample statistics as a new tool for the identification and assessment of
habitat factors with an application to breeding bird communities in oak
forests.  <em>European Journal of Forest Research</em> <b>123</b>(3), 219&ndash;228.
<a href="https://doi.org/10.1007/s10342-004-0035-5">doi:10.1007/s10342-004-0035-5</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Asymptotic maximally selected statistics
maxstat_test(counts ~ age + coverstorey + coverregen + meanregen +
                      coniferous + deadtree + cbpiles + ivytree,
             data = treepipit)
</code></pre>

<hr>
<h2 id='VarCovar-class'>Class <code>"VarCovar"</code> and its subclasses</h2><span id='topic+VarCovar-class'></span><span id='topic+CovarianceMatrix-class'></span><span id='topic+Variance-class'></span><span id='topic+initialize+2CCovarianceMatrix-method'></span><span id='topic+initialize+2CVariance-method'></span>

<h3>Description</h3>

<p>Objects of class <code>"VarCovar"</code> and its subclasses
<code>"CovarianceMatrix"</code> and <code>"Variance"</code> represent the covariance and
variance, respectively, of the linear statistic.
</p>


<h3>Objects from the Class</h3>

<p>Class <code>"VarCovar"</code> is a <em>virtual</em> class defined as the class union
of <code>"CovarianceMatrix"</code> and <code>"Variance"</code>, so objects cannot be
created from it directly.
</p>
<p>Objects can be created by calls of the form </p>
<pre>     new("CovarianceMatrix", covariance, \dots)</pre>
<p>and </p>
<pre>     new("Variance", variance, \dots)</pre>
<p>where <code>covariance</code> is a covariance matrix and <code>variance</code> is numeric
vector containing the diagonal elements of the covariance matrix.
</p>


<h3>Slots</h3>

<p>For objects of class <code>"CovarianceMatrix"</code>:
</p>

<dl>
<dt><code>covariance</code>:</dt><dd>
<p>Object of class <code>"matrix"</code>.  The covariance matrix.
</p>
</dd>
</dl>

<p>For objects of class <code>"Variance"</code>:
</p>

<dl>
<dt><code>variance</code>:</dt><dd>
<p>Object of class <code>"numeric"</code>.  The diagonal elements of the
covariance matrix.
</p>
</dd>
</dl>



<h3>Extends</h3>

<p>For objects of classes <code>"CovarianceMatrix"</code> or <code>"Variance"</code>: <br />
Class <code>"VarCovar"</code>, directly.
</p>


<h3>Known Subclasses</h3>

<p>For objects of class <code>"VarCovar"</code>: <br />
Class <code>"CovarianceMatrix"</code>, directly. <br />
Class <code>"Variance"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>covariance</dt><dd>
<p><code>signature(object = "CovarianceMatrix")</code>: See the documentation for
<code><a href="#topic+covariance">covariance</a></code> for details.
</p>
</dd>
<dt>initialize</dt><dd>
<p><code>signature(.Object = "CovarianceMatrix")</code>: See the documentation for
<code><a href="methods.html#topic+new">initialize</a></code> (in package <span class="pkg">methods</span>) for
details.
</p>
</dd>
<dt>initialize</dt><dd>
<p><code>signature(.Object = "Variance")</code>: See the documentation for
<code><a href="methods.html#topic+new">initialize</a></code> (in package <span class="pkg">methods</span>) for
details.
</p>
</dd>
<dt>variance</dt><dd>
<p><code>signature(object = "CovarianceMatrix")</code>: See the documentation for
<code><a href="#topic+variance">variance</a></code> for details.
</p>
</dd>
<dt>variance</dt><dd>
<p><code>signature(object = "Variance")</code>: See the documentation for
<code><a href="#topic+variance">variance</a></code> for details.
</p>
</dd>
</dl>



<h3>Note</h3>

<p>Starting with <span class="pkg">coin</span> version 1.4-0, this class is deprecated.  <strong>It
will be made defunct and removed in a future release.</strong>
</p>

<hr>
<h2 id='vision'>Unaided Distance Vision</h2><span id='topic+vision'></span>

<h3>Description</h3>

<p>Assessment of unaided distance vision of women in Britain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vision</code></pre>


<h3>Format</h3>

<p>A contingency table with 7477 observations on 2 variables.
</p>

<dl>
<dt><code>Right.Eye</code></dt><dd>
<p>a factor with levels <code>"Highest Grade"</code>, <code>"Second Grade"</code>,
<code>"Third Grade"</code> and <code>"Lowest Grade"</code>.
</p>
</dd>
<dt><code>Left.Eye</code></dt><dd>
<p>a factor with levels <code>"Highest Grade"</code>,  <code>"Second Grade"</code>,
<code>"Third Grade"</code> and <code>"Lowest Grade"</code>.
</p>
</dd>
</dl>



<h3>Details</h3>

<p>Paired ordered categorical data from case-records of eye-testing of 7477 women
aged 30&ndash;39 years employed by Royal Ordnance Factories in Britain during
1943&ndash;46, as given by Stuart (1953).
</p>
<p>This data set was used by Stuart (1955) to illustrate a test of marginal
homogeneity.  Winell and Lindbäck (2018) also used the data,
demonstrating a score-independent test for ordered categorical data.
</p>


<h3>Source</h3>

<p>Stuart, A.  (1953).  The estimation and comparison of strengths of association
in contingency tables.  <em>Biometrika</em> <b>40</b>(1/2), 105&ndash;110.
<a href="https://doi.org/10.2307/2333101">doi:10.2307/2333101</a>
</p>


<h3>References</h3>

<p>Stuart, A.  (1955).  A test for homogeneity of the marginal distributions in a
two-way classification.  <em>Biometrika</em> <b>42</b>(3/4), 412&ndash;416.
<a href="https://doi.org/10.1093/biomet/42.3-4.412">doi:10.1093/biomet/42.3-4.412</a>
</p>
<p>Winell, H. and Lindbäck, J.  (2018).  A general
score-independent test for order-restricted inference.  <em>Statistics in
Medicine</em> <b>37</b>(21), 3078&ndash;3090.  <a href="https://doi.org/10.1002/sim.7690">doi:10.1002/sim.7690</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Asymptotic Stuart test (Q = 11.96)
diag(vision) &lt;- 0 # speed-up
mh_test(vision)

## Asymptotic score-independent test
## Winell and Lindbaeck (2018)
(st &lt;- symmetry_test(vision,
                     ytrafo = function(data)
                         trafo(data, factor_trafo = function(y)
                             zheng_trafo(as.ordered(y)))))
ss &lt;- statistic(st, type = "standardized")
idx &lt;- which(abs(ss) == max(abs(ss)), arr.ind = TRUE)
ss[idx[1], idx[2], drop = FALSE]
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
