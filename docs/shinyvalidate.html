<!DOCTYPE html><html><head><title>Help for package shinyvalidate</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {shinyvalidate}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#compose_rules'><p>Combine shinyvalidate rule functions</p></a></li>
<li><a href='#input_provided'><p>Check whether an input value has been provided</p></a></li>
<li><a href='#InputValidator'><p>Shiny validation object</p></a></li>
<li><a href='#skip_validation'><p>Skip any normal validation performed by a rule</p></a></li>
<li><a href='#sv_between'><p>Validate that a field is a number bounded by minimum and maximum values</p></a></li>
<li><a href='#sv_email'><p>Validate that a field contains an email address</p></a></li>
<li><a href='#sv_equal'><p>Validate that a field is equal to a specified value</p></a></li>
<li><a href='#sv_gt'><p>Validate that a field is greater than a specified value</p></a></li>
<li><a href='#sv_gte'><p>Validate that a field is greater than or equal to a specified value</p></a></li>
<li><a href='#sv_in_set'><p>Validate that a field is part of a defined set</p></a></li>
<li><a href='#sv_integer'><p>Validate that a field is a number that is integer-like</p></a></li>
<li><a href='#sv_lt'><p>Validate that a field is less than a specified value</p></a></li>
<li><a href='#sv_lte'><p>Validate that a field is less than or equal to a specified value</p></a></li>
<li><a href='#sv_not_equal'><p>Validate that a field is not equal to a specified value</p></a></li>
<li><a href='#sv_numeric'><p>Validate that a field is a number</p></a></li>
<li><a href='#sv_optional'><p>Indicate that a field is optional</p></a></li>
<li><a href='#sv_regex'><p>Validate that a field matches a regular expression</p></a></li>
<li><a href='#sv_required'><p>Validate that the field is present</p></a></li>
<li><a href='#sv_url'><p>Validate that a field contains a URL</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Input Validation for Shiny Apps</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Improves the user experience of Shiny apps by helping to
    provide feedback when required inputs are missing, or input values
    are not valid.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://rstudio.github.io/shinyvalidate/">https://rstudio.github.io/shinyvalidate/</a>,
<a href="https://github.com/rstudio/shinyvalidate">https://github.com/rstudio/shinyvalidate</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/rstudio/shinyvalidate/issues">https://github.com/rstudio/shinyvalidate/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>shiny (&ge; 1.6), htmltools (&ge; 0.5.1.1), rlang (&ge; 0.4.10),
glue (&ge; 1.4.2)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, covr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-03 21:59:53 UTC; cpsievert</td>
</tr>
<tr>
<td>Author:</td>
<td>Carson Sievert <a href="https://orcid.org/0000-0002-4958-2844"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Richard Iannone <a href="https://orcid.org/0000-0003-3925-190X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Joe Cheng [aut],
  Posit Software, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Carson Sievert &lt;carson@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-04 15:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='compose_rules'>Combine shinyvalidate rule functions</h2><span id='topic+compose_rules'></span>

<h3>Description</h3>

<p>Takes multiple shinyvalidate rule functions, and returns a shinyvalidate rule
function. When this resulting rule function is invoked, it will try each of
its constituent rule functions in order; the first validation error that is
detected will be returned immediately and the remaining rules will not be
tried.
</p>
<p>This function is not intended to be used by Shiny app authors (i.e. not for
<code>InputValidator$add_rule("x", compose_rules(...))</code>), but for developers of
reusable shinyvalidate rule functions. See examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compose_rules(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compose_rules_+3A_...">...</code></td>
<td>
<p>Any number of shinyvalidate rule functions; earlier rules will be
attempted before later rules. Argument names are ignored. Single-sided
formulas are also accepted instead of a function, using <code>.</code> as the variable
name for the input value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function suitable for use as an
<code><a href="#topic+InputValidator">InputValidator$add_rule()</a></code> rule.
</p>


<h3>See Also</h3>

<p>Other rule functions: 
<code><a href="#topic+sv_between">sv_between</a>()</code>,
<code><a href="#topic+sv_email">sv_email</a>()</code>,
<code><a href="#topic+sv_equal">sv_equal</a>()</code>,
<code><a href="#topic+sv_gte">sv_gte</a>()</code>,
<code><a href="#topic+sv_gt">sv_gt</a>()</code>,
<code><a href="#topic+sv_in_set">sv_in_set</a>()</code>,
<code><a href="#topic+sv_integer">sv_integer</a>()</code>,
<code><a href="#topic+sv_lte">sv_lte</a>()</code>,
<code><a href="#topic+sv_lt">sv_lt</a>()</code>,
<code><a href="#topic+sv_not_equal">sv_not_equal</a>()</code>,
<code><a href="#topic+sv_numeric">sv_numeric</a>()</code>,
<code><a href="#topic+sv_optional">sv_optional</a>()</code>,
<code><a href="#topic+sv_regex">sv_regex</a>()</code>,
<code><a href="#topic+sv_required">sv_required</a>()</code>,
<code><a href="#topic+sv_url">sv_url</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Create a new shinyvalidate rule that is composed
# of two `sv_*()` rule functions (`sv_integer()` and
# `sv_gt()`, and a custom function for ensuring
# a number is even)
positive_even_integer &lt;- function() {
  compose_rules(
    sv_integer(),
    sv_gt(0),
    ~ if (. %% 2 == 1) "Must be an even number"
  )
}

# Use the `positive_even_integer()` rule function
# to check that a supplied value is an integer, greater
# than zero, and even (in that order)

## Only run examples in interactive R sessions
if (interactive()) {

library(shiny)
library(shinyvalidate)

ui &lt;- fluidPage(
  textInput("value", "Value")
)

server &lt;- function(input, output, session) {
  
  # Validation rules are set in the server, start by
  # making a new instance of an `InputValidator()`
  iv &lt;- InputValidator$new()

  # Add two `add_rule()` statements: one that
  # combines `sv_required()` and `sv_numeric()` in
  # single rule, and another that is defined
  # through the use of `compose_rules()`
  iv$add_rule("value", compose_rules(sv_required(), sv_numeric()))
  iv$add_rule("value", positive_even_integer())

  # Finally, `enable()` the validation rules
  iv$enable()
}

shinyApp(ui, server)

}

</code></pre>

<hr>
<h2 id='input_provided'>Check whether an input value has been provided</h2><span id='topic+input_provided'></span>

<h3>Description</h3>

<p>This function takes an input value and uses heuristics to guess whether it
represents an &quot;empty&quot; input vs. one that the user has provided. This will
vary by input type; for example, a <code><a href="shiny.html#topic+textInput">shiny::textInput()</a></code> is <code>""</code> when empty,
while a <code><a href="shiny.html#topic+numericInput">shiny::numericInput()</a></code> is <code>NA</code>.
</p>
<p><code>input_provided</code> returns <code>TRUE</code> for all values except:
</p>

<ul>
<li> <p><code>NULL</code>
</p>
</li>
<li> <p><code>""</code>
</p>
</li>
<li><p> An empty atomic vector or list
</p>
</li>
<li><p> An atomic vector that contains only missing (<code>NA</code>) values
</p>
</li>
<li><p> A character vector that contains only missing and/or <code>""</code> values
</p>
</li>
<li><p> An object of class <code>"try-error"</code>
</p>
</li>
<li><p> A value that represents an unclicked <code><a href="shiny.html#topic+actionButton">shiny::actionButton()</a></code>
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>input_provided(val)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="input_provided_+3A_val">val</code></td>
<td>
<p>Values to test for availability in a Shiny context.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is based on <code><a href="shiny.html#topic+isTruthy">shiny::isTruthy()</a></code> but tweaked here in
shinyvalidate to change the treatment of <code>FALSE</code> values: <code>isTruthy(FALSE)</code>
returns <code>FALSE</code>, but <code>input_provided(FALSE)</code> returns <code>TRUE</code>. This difference
is motivated by <code>shiny::checkboxInput()</code>, where <code>isTruthy()</code> answers the
question of &quot;is the input present <em>and checked</em>&quot; while <code>input_provided</code> is
just &quot;is the input present&quot;.
</p>


<h3>Value</h3>

<p>A logical vector of length 1.
</p>

<hr>
<h2 id='InputValidator'>Shiny validation object</h2><span id='topic+InputValidator'></span>

<h3>Description</h3>

<p>An R6 class for adding realtime input validation to Shiny apps.
</p>
<p><code>InputValidator</code> objects are designed to be created as local variables in
Shiny server functions and Shiny module server functions. The Shiny app
author can register zero, one, or multiple validation rules for each input
field in their UI, using the <code>InputValidator$add_rule()</code> method.
</p>
<p>Once an <code>InputValidator</code> object is created and populated with rules, it can
be used in a few ways:
</p>

<ol>
<li><p> The <code>InputValidator$enable()</code> method can be called to display real-time
feedback to users about what inputs are failing validation, and why.
</p>
</li>
<li><p> The <code>InputValidator$is_valid()</code> method returns <code>TRUE</code> if and only if all
of the validation rules are passing; this can be checked before
executing actions that depend on the inputs being valid.
</p>
</li>
<li><p> The <code>InputValidator$validate()</code> method is a lower-level feature that
directly returns information about what fields failed validation, and
why.
</p>
</li></ol>

<p>It's possible to have multiple <code>InputValidator</code> objects for each Shiny app.
One scenario where this makes sense is if an app contains multiple forms
that are completely unrelated to each other; each form would have its own
<code>InputValidator</code> instance with a distinct set of rules.
</p>


<h3>Methods</h3>



<h4>Public methods</h4>


<ul>
<li> <p><a href="#method-InputValidator-new"><code>InputValidator$new()</code></a>
</p>
</li>
<li> <p><a href="#method-InputValidator-parent"><code>InputValidator$parent()</code></a>
</p>
</li>
<li> <p><a href="#method-InputValidator-condition"><code>InputValidator$condition()</code></a>
</p>
</li>
<li> <p><a href="#method-InputValidator-add_validator"><code>InputValidator$add_validator()</code></a>
</p>
</li>
<li> <p><a href="#method-InputValidator-add_rule"><code>InputValidator$add_rule()</code></a>
</p>
</li>
<li> <p><a href="#method-InputValidator-enable"><code>InputValidator$enable()</code></a>
</p>
</li>
<li> <p><a href="#method-InputValidator-disable"><code>InputValidator$disable()</code></a>
</p>
</li>
<li> <p><a href="#method-InputValidator-fields"><code>InputValidator$fields()</code></a>
</p>
</li>
<li> <p><a href="#method-InputValidator-is_valid"><code>InputValidator$is_valid()</code></a>
</p>
</li>
<li> <p><a href="#method-InputValidator-validate"><code>InputValidator$validate()</code></a>
</p>
</li>
<li> <p><a href="#method-InputValidator-_validate_impl"><code>InputValidator$_validate_impl()</code></a>
</p>
</li></ul>


<hr>
<a id="method-InputValidator-new"></a>



<h4>Method <code>new()</code></h4>

<p>Create a new validator object.
</p>


<h5>Usage</h5>

<div class="r"><pre>InputValidator$new(
  priority = 1000,
  session = shiny::getDefaultReactiveDomain()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>priority</code></dt><dd><p>When a validator object is enabled, it creates an
internal <code><a href="shiny.html#topic+observe">shiny::observe()</a></code> to keep validation feedback in the UI
up-to-date. This parameter controls the priority of that observer. It's
highly recommended to keep this value higher than the priorities of any
observers that do actual work, so users see validation updates quickly.</p>
</dd>
<dt><code>session</code></dt><dd><p>The Shiny <code>session</code> object. (You should probably just use
the default.)</p>
</dd>
</dl>

</div>


<hr>
<a id="method-InputValidator-parent"></a>



<h4>Method <code>parent()</code></h4>

<p>For internal use only.
</p>


<h5>Usage</h5>

<div class="r"><pre>InputValidator$parent(validator)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>validator</code></dt><dd><p>An <code>InputValidator</code> object.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-InputValidator-condition"></a>



<h4>Method <code>condition()</code></h4>

<p>Gets or sets a condition that overrides all of the rules in
this validator. Before performing validation, this validator will
execute the <code>cond</code> function. If <code>cond</code> returns <code>TRUE</code>, then
validation continues as normal; if <code>FALSE</code>, then the validation rules
will be skipped and treated as if they are all passing.
</p>


<h5>Usage</h5>

<div class="r"><pre>InputValidator$condition(cond)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>cond</code></dt><dd><p>If this argument is missing, then the method returns the
currently set condition function. If not missing, then <code>cond</code> must
be either a zero-argument function that returns <code>TRUE</code> or <code>FALSE</code>; a
single-sided formula that results in <code>TRUE</code> or <code>FALSE</code>; or <code>NULL</code>
(which is equivalent to <code>~ TRUE</code>).</p>
</dd>
</dl>

</div>



<h5>Returns</h5>

<p>If <code>cond</code> is missing, then either <code>NULL</code> or a zero-argument
function; if <code>cond</code> is provided, then nothing of consequence is
returned.
</p>


<hr>
<a id="method-InputValidator-add_validator"></a>



<h4>Method <code>add_validator()</code></h4>

<p>Add another <code>InputValidator</code> object to this one, as a
&quot;child&quot;. Any time this validator object is asked for its validity, it
will only return <code>TRUE</code> if all of its child validators are also valid;
and when this validator object is enabled (or disabled), then all of
its child validators are enabled (or disabled) as well.
</p>
<p>This is intended to help with validating Shiny modules. Each module can
create its own <code>InputValidator</code> object and populate it with rules, then
return that object to the caller.
</p>


<h5>Usage</h5>

<div class="r"><pre>InputValidator$add_validator(validator, label = deparse(substitute(validator)))</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>validator</code></dt><dd><p>An <code>InputValidator</code> object.</p>
</dd>
<dt><code>label</code></dt><dd><p>An optional label for the <code>InputValidator</code> object. By
default, a label will be automatically generated.</p>
</dd>
</dl>

</div>


<hr>
<a id="method-InputValidator-add_rule"></a>



<h4>Method <code>add_rule()</code></h4>

<p>Add an input validation rule. Each input validation rule
applies to a single input. You can add multiple validation rules for a
single input by calling <code>add_rule()</code> multiple times; the first
validation rule for an input that fails will be used, and will prevent
subsequent rules for that input from executing.
</p>


<h5>Usage</h5>

<div class="r"><pre>InputValidator$add_rule(
  inputId,
  rule,
  ...,
  session. = shiny::getDefaultReactiveDomain()
)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>inputId</code></dt><dd><p>A single-element character vector indicating the ID of the
input that this rule applies to. (Note that this name should <em>not</em> be
qualified by a module namespace; e.g. pass <code>"x"</code> and not
<code>session$ns("x")</code>.)</p>
</dd>
<dt><code>rule</code></dt><dd><p>A function that takes (at least) one argument: the input's
value. The function should return <code>NULL</code> if it passes validation, and
if not, a single-element character vector or HTML tag containing an
error message to display to the user near the input. You can
alternatively provide a single-sided formula instead of a function,
using <code>.</code> as the variable name for the input value being validated.</p>
</dd>
<dt><code>...</code></dt><dd><p>Optional: Additional arguments to pass to the <code>rule</code> function
whenever it is invoked.</p>
</dd>
<dt><code>session.</code></dt><dd><p>The session object to which the input belongs. (There's
almost never a reason to change this from the default.)</p>
</dd>
</dl>

</div>


<hr>
<a id="method-InputValidator-enable"></a>



<h4>Method <code>enable()</code></h4>

<p>Begin displaying input validation feedback in the user
interface. Once enabled, this validator object will automatically keep
the feedback up-to-date. (It's safe to call the <code>enable()</code> method
on an already-enabled validator.) If this validator object has been
added to another validator object using <code>InputValidator$add_validator</code>,
calls to <code>enable()</code> on this validator will be ignored.
</p>


<h5>Usage</h5>

<div class="r"><pre>InputValidator$enable()</pre></div>


<hr>
<a id="method-InputValidator-disable"></a>



<h4>Method <code>disable()</code></h4>

<p>Clear existing input validation feedback in the user
interface for all inputs represented in this validator's ruleset, and
stop providing feedback going forward. Once disabled, <code>enable()</code> can be
called to resume input validation.
</p>


<h5>Usage</h5>

<div class="r"><pre>InputValidator$disable()</pre></div>


<hr>
<a id="method-InputValidator-fields"></a>



<h4>Method <code>fields()</code></h4>

<p>Returns <code>TRUE</code> if all input validation rules currently pass,
<code>FALSE</code> if not.
</p>


<h5>Usage</h5>

<div class="r"><pre>InputValidator$fields()</pre></div>


<hr>
<a id="method-InputValidator-is_valid"></a>



<h4>Method <code>is_valid()</code></h4>

<p>Returns <code>TRUE</code> if all input validation rules currently pass,
<code>FALSE</code> if not.
</p>


<h5>Usage</h5>

<div class="r"><pre>InputValidator$is_valid()</pre></div>


<hr>
<a id="method-InputValidator-validate"></a>



<h4>Method <code>validate()</code></h4>

<p>Run validation rules and gather results. For advanced usage
only; most apps should use the <code>is_valid()</code> and <code>enable()</code> methods
instead. The return value of this method is a named list, where the
names are (fully namespace qualified) input IDs, and the values are
either <code>NULL</code> (if the input value is passing) or a single-element
character vector describing a validation problem.
</p>


<h5>Usage</h5>

<div class="r"><pre>InputValidator$validate()</pre></div>


<hr>
<a id="method-InputValidator-_validate_impl"></a>



<h4>Method <code>_validate_impl()</code></h4>

<p>For internal use only.
</p>


<h5>Usage</h5>

<div class="r"><pre>InputValidator$_validate_impl(indent)</pre></div>



<h5>Arguments</h5>

<div class="arguments">

<dl>
<dt><code>indent</code></dt><dd><p>For internal use only.</p>
</dd>
</dl>

</div>



<hr>
<h2 id='skip_validation'>Skip any normal validation performed by a rule</h2><span id='topic+skip_validation'></span>

<h3>Description</h3>

<p>While the predominant role of the <code>skip_validation()</code> function is tied to the
<code><a href="#topic+sv_optional">sv_optional()</a></code> function (where it's used internally), you can also return
<code>skip_validation()</code> from custom validation rules. When returned, all
subsequent validation rules defined for the input will be skipped.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>skip_validation()
</code></pre>


<h3>Value</h3>

<p>A function that returns a sentinel value, signaling to shinyvalidate
that any further validation rules for an input are to be skipped.
</p>

<hr>
<h2 id='sv_between'>Validate that a field is a number bounded by minimum and maximum values</h2><span id='topic+sv_between'></span>

<h3>Description</h3>

<p>The <code>sv_between()</code> function validates that a field has values between left
and right boundary values. Both bounds are inclusive by default, but both can
be set as either inclusive or exclusive with the <code>inclusive</code> argument. In its
default mode, the validation check will effectively be of the form <code style="white-space: pre;">&#8288;&lt;left&gt; &lt;= &lt;field&gt; &lt;= &lt;right&gt;&#8288;</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sv_between(
  left,
  right,
  inclusive = c(TRUE, TRUE),
  message_fmt = "Must be between {left} and {right}.",
  allow_na = FALSE,
  allow_nan = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sv_between_+3A_left">left</code>, <code id="sv_between_+3A_right">right</code></td>
<td>
<p>The left and right boundary values. Inclusively for each of
the boundaries is set with the <code>inclusive</code> argument; the defaults are set
for inclusive bounds.</p>
</td></tr>
<tr><td><code id="sv_between_+3A_inclusive">inclusive</code></td>
<td>
<p>A two-element logical vector that indicates whether the
<code>left</code> and <code>right</code> bounds, respectively, should be inclusive. Both bounds
are by default are inclusive, using <code>c(TRUE, TRUE)</code>.</p>
</td></tr>
<tr><td><code id="sv_between_+3A_message_fmt">message_fmt</code></td>
<td>
<p>The validation error message to use if a value fails to
match the rule. The message can be customized by using the <code>"{left}"</code> and
<code>"{right}"</code> string parameters, which allows for the insertion of the <code>left</code>
and <code>right</code> values. While the default message uses both of these string
parameters, they are not required in a user-defined <code>message_fmt</code> string.</p>
</td></tr>
<tr><td><code id="sv_between_+3A_allow_na">allow_na</code>, <code id="sv_between_+3A_allow_nan">allow_nan</code></td>
<td>
<p>If <code>FALSE</code> (the default for both options), then any
<code>NA</code> or <code>NaN</code> element will cause validation to fail.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function suitable for use as an
<code><a href="#topic+InputValidator">InputValidator$add_rule()</a></code> rule.
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+sv_in_set">sv_in_set()</a></code> function, which tests whether a field values are
part of a specified set.
</p>
<p>Other rule functions: 
<code><a href="#topic+compose_rules">compose_rules</a>()</code>,
<code><a href="#topic+sv_email">sv_email</a>()</code>,
<code><a href="#topic+sv_equal">sv_equal</a>()</code>,
<code><a href="#topic+sv_gte">sv_gte</a>()</code>,
<code><a href="#topic+sv_gt">sv_gt</a>()</code>,
<code><a href="#topic+sv_in_set">sv_in_set</a>()</code>,
<code><a href="#topic+sv_integer">sv_integer</a>()</code>,
<code><a href="#topic+sv_lte">sv_lte</a>()</code>,
<code><a href="#topic+sv_lt">sv_lt</a>()</code>,
<code><a href="#topic+sv_not_equal">sv_not_equal</a>()</code>,
<code><a href="#topic+sv_numeric">sv_numeric</a>()</code>,
<code><a href="#topic+sv_optional">sv_optional</a>()</code>,
<code><a href="#topic+sv_regex">sv_regex</a>()</code>,
<code><a href="#topic+sv_required">sv_required</a>()</code>,
<code><a href="#topic+sv_url">sv_url</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Only run examples in interactive R sessions
if (interactive()) {

library(shiny)
library(shinyvalidate)

ui &lt;- fluidPage(
  textInput("count", "Count")
)

server &lt;- function(input, output, session) {
  
  # Validation rules are set in the server, start by
  # making a new instance of an `InputValidator()`
  iv &lt;- InputValidator$new()

  # Basic usage: `sv_between()` requires `left` and
  # `right` boundary values; a message will be
  # displayed if the validation of `input$count` fails
  iv$add_rule("count", sv_between(10, 100))

  # Finally, `enable()` the validation rules
  iv$enable()
}

shinyApp(ui, server)

}

</code></pre>

<hr>
<h2 id='sv_email'>Validate that a field contains an email address</h2><span id='topic+sv_email'></span>

<h3>Description</h3>

<p>A validation function, suitable for use with <code>InputValidator$add_rule()</code>,
that checks whether an input value looks like a valid email address.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sv_email(
  message = "Not a valid email address",
  allow_multiple = FALSE,
  allow_na = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sv_email_+3A_message">message</code></td>
<td>
<p>The validation error message to use if a value doesn't match a
regex pattern for email address detection.</p>
</td></tr>
<tr><td><code id="sv_email_+3A_allow_multiple">allow_multiple</code></td>
<td>
<p>If <code>FALSE</code> (the default), then the length of the input
vector must be exactly one; if <code>TRUE</code>, then any length is allowed
(including a length of zero; use <code><a href="#topic+sv_required">sv_required()</a></code> if one or more values
should be required).</p>
</td></tr>
<tr><td><code id="sv_email_+3A_allow_na">allow_na</code></td>
<td>
<p>If <code>FALSE</code>, then any <code>NA</code> element will cause validation to
fail.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function suitable for use as an
<code><a href="#topic+InputValidator">InputValidator$add_rule()</a></code> rule.
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+sv_url">sv_url()</a></code> function, another specialized regex-based function
for validating URLs. For general regex-based validation the <code><a href="#topic+sv_regex">sv_regex()</a></code>
function is useful.
</p>
<p>Other rule functions: 
<code><a href="#topic+compose_rules">compose_rules</a>()</code>,
<code><a href="#topic+sv_between">sv_between</a>()</code>,
<code><a href="#topic+sv_equal">sv_equal</a>()</code>,
<code><a href="#topic+sv_gte">sv_gte</a>()</code>,
<code><a href="#topic+sv_gt">sv_gt</a>()</code>,
<code><a href="#topic+sv_in_set">sv_in_set</a>()</code>,
<code><a href="#topic+sv_integer">sv_integer</a>()</code>,
<code><a href="#topic+sv_lte">sv_lte</a>()</code>,
<code><a href="#topic+sv_lt">sv_lt</a>()</code>,
<code><a href="#topic+sv_not_equal">sv_not_equal</a>()</code>,
<code><a href="#topic+sv_numeric">sv_numeric</a>()</code>,
<code><a href="#topic+sv_optional">sv_optional</a>()</code>,
<code><a href="#topic+sv_regex">sv_regex</a>()</code>,
<code><a href="#topic+sv_required">sv_required</a>()</code>,
<code><a href="#topic+sv_url">sv_url</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Only run examples in interactive R sessions
if (interactive()) {

library(shiny)
library(shinyvalidate)

ui &lt;- fluidPage(
  textInput("email", "Email")
)

server &lt;- function(input, output, session) {
  
  # Validation rules are set in the server, start by
  # making a new instance of an `InputValidator()`
  iv &lt;- InputValidator$new()

  # Basic usage: `sv_email()` works well with its
  # defaults; a message will be displayed if the
  # validation of `input$email` fails
  iv$add_rule("email", sv_email())

  # Finally, `enable()` the validation rules
  iv$enable()
}

shinyApp(ui, server)

}

</code></pre>

<hr>
<h2 id='sv_equal'>Validate that a field is equal to a specified value</h2><span id='topic+sv_equal'></span>

<h3>Description</h3>

<p>The <code>sv_equal()</code> function compares the field value to a specified value with
the <code>==</code> operator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sv_equal(
  rhs,
  message_fmt = "Must be equal to {rhs}.",
  allow_multiple = FALSE,
  allow_na = FALSE,
  allow_nan = FALSE,
  allow_inf = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sv_equal_+3A_rhs">rhs</code></td>
<td>
<p>The right hand side (RHS) value is to be used for the comparison
with the field value. The validation check will effectively be of the form
<code style="white-space: pre;">&#8288;&lt;field&gt; == &lt;rhs&gt;&#8288;</code>.</p>
</td></tr>
<tr><td><code id="sv_equal_+3A_message_fmt">message_fmt</code></td>
<td>
<p>The validation error message to use if the field fails the
validation test. Use the <code>"{rhs}"</code> string parameter to customize the
message, including what was set in <code>rhs</code>. While the default message uses
this string parameter, it is not required in a user-defined <code>message_fmt</code>
string.</p>
</td></tr>
<tr><td><code id="sv_equal_+3A_allow_multiple">allow_multiple</code></td>
<td>
<p>If <code>FALSE</code> (the default), then the length of the input
vector must be exactly one; if <code>TRUE</code>, then any length is allowed
(including a length of zero; use <code><a href="#topic+sv_required">sv_required()</a></code> if one or more values
should be required).</p>
</td></tr>
<tr><td><code id="sv_equal_+3A_allow_na">allow_na</code>, <code id="sv_equal_+3A_allow_nan">allow_nan</code></td>
<td>
<p>If <code>FALSE</code> (the default for both options), then any
<code>NA</code> or <code>NaN</code> element will cause validation to fail.</p>
</td></tr>
<tr><td><code id="sv_equal_+3A_allow_inf">allow_inf</code></td>
<td>
<p>If <code>FALSE</code> (the default), then any <code>Inf</code> or <code>-Inf</code> element
will cause validation to fail.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function suitable for use as an
<code><a href="#topic+InputValidator">InputValidator$add_rule()</a></code> rule.
</p>


<h3>See Also</h3>

<p>The other comparison-based rule functions: <code><a href="#topic+sv_gt">sv_gt()</a></code>, <code><a href="#topic+sv_gte">sv_gte()</a></code>,
<code><a href="#topic+sv_lt">sv_lt()</a></code>, <code><a href="#topic+sv_lte">sv_lte()</a></code>, and <code><a href="#topic+sv_not_equal">sv_not_equal()</a></code> (which serves as the opposite
function to <code>sv_equal()</code>).
</p>
<p>Other rule functions: 
<code><a href="#topic+compose_rules">compose_rules</a>()</code>,
<code><a href="#topic+sv_between">sv_between</a>()</code>,
<code><a href="#topic+sv_email">sv_email</a>()</code>,
<code><a href="#topic+sv_gte">sv_gte</a>()</code>,
<code><a href="#topic+sv_gt">sv_gt</a>()</code>,
<code><a href="#topic+sv_in_set">sv_in_set</a>()</code>,
<code><a href="#topic+sv_integer">sv_integer</a>()</code>,
<code><a href="#topic+sv_lte">sv_lte</a>()</code>,
<code><a href="#topic+sv_lt">sv_lt</a>()</code>,
<code><a href="#topic+sv_not_equal">sv_not_equal</a>()</code>,
<code><a href="#topic+sv_numeric">sv_numeric</a>()</code>,
<code><a href="#topic+sv_optional">sv_optional</a>()</code>,
<code><a href="#topic+sv_regex">sv_regex</a>()</code>,
<code><a href="#topic+sv_required">sv_required</a>()</code>,
<code><a href="#topic+sv_url">sv_url</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Only run examples in interactive R sessions
if (interactive()) {

library(shiny)
library(shinyvalidate)

ui &lt;- fluidPage(
  textInput("number", "Number")
)

server &lt;- function(input, output, session) {
  
  # Validation rules are set in the server, start by
  # making a new instance of an `InputValidator()`
  iv &lt;- InputValidator$new()

  # Basic usage: `sv_equal()` requires a value
  # to compare against the field value; a message
  # will be shown if the validation of
  # `input$number` fails
  iv$add_rule("number", sv_equal(1))

  # Finally, `enable()` the validation rules
  iv$enable()
}

shinyApp(ui, server)

}

</code></pre>

<hr>
<h2 id='sv_gt'>Validate that a field is greater than a specified value</h2><span id='topic+sv_gt'></span>

<h3>Description</h3>

<p>The <code>sv_gt()</code> function compares the field value to a specified value with the
<code>&gt;</code> operator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sv_gt(
  rhs,
  message_fmt = "Must be greater than {rhs}.",
  allow_multiple = FALSE,
  allow_na = FALSE,
  allow_nan = FALSE,
  allow_inf = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sv_gt_+3A_rhs">rhs</code></td>
<td>
<p>The right hand side (RHS) value is to be used for the comparison
with the field value. The validation check will effectively be of the form
<code style="white-space: pre;">&#8288;&lt;field&gt; &gt; &lt;rhs&gt;&#8288;</code>.</p>
</td></tr>
<tr><td><code id="sv_gt_+3A_message_fmt">message_fmt</code></td>
<td>
<p>The validation error message to use if the field fails the
validation test. Use the <code>"{rhs}"</code> string parameter to customize the
message, including what was set in <code>rhs</code>. While the default message uses
this string parameter, it is not required in a user-defined <code>message_fmt</code>
string.</p>
</td></tr>
<tr><td><code id="sv_gt_+3A_allow_multiple">allow_multiple</code></td>
<td>
<p>If <code>FALSE</code> (the default), then the length of the input
vector must be exactly one; if <code>TRUE</code>, then any length is allowed
(including a length of zero; use <code><a href="#topic+sv_required">sv_required()</a></code> if one or more values
should be required).</p>
</td></tr>
<tr><td><code id="sv_gt_+3A_allow_na">allow_na</code>, <code id="sv_gt_+3A_allow_nan">allow_nan</code></td>
<td>
<p>If <code>FALSE</code> (the default for both options), then any
<code>NA</code> or <code>NaN</code> element will cause validation to fail.</p>
</td></tr>
<tr><td><code id="sv_gt_+3A_allow_inf">allow_inf</code></td>
<td>
<p>If <code>FALSE</code> (the default), then any <code>Inf</code> or <code>-Inf</code> element
will cause validation to fail.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function suitable for use as an
<code><a href="#topic+InputValidator">InputValidator$add_rule()</a></code> rule.
</p>


<h3>See Also</h3>

<p>The other comparison-based rule functions: <code><a href="#topic+sv_gte">sv_gte()</a></code>, <code><a href="#topic+sv_lt">sv_lt()</a></code>,
<code><a href="#topic+sv_lte">sv_lte()</a></code>, <code><a href="#topic+sv_equal">sv_equal()</a></code>, and <code><a href="#topic+sv_not_equal">sv_not_equal()</a></code>. The <code><a href="#topic+sv_gte">sv_gte()</a></code> function may
be needed if the field value should also pass validation when equal to the
comparison value.
</p>
<p>Other rule functions: 
<code><a href="#topic+compose_rules">compose_rules</a>()</code>,
<code><a href="#topic+sv_between">sv_between</a>()</code>,
<code><a href="#topic+sv_email">sv_email</a>()</code>,
<code><a href="#topic+sv_equal">sv_equal</a>()</code>,
<code><a href="#topic+sv_gte">sv_gte</a>()</code>,
<code><a href="#topic+sv_in_set">sv_in_set</a>()</code>,
<code><a href="#topic+sv_integer">sv_integer</a>()</code>,
<code><a href="#topic+sv_lte">sv_lte</a>()</code>,
<code><a href="#topic+sv_lt">sv_lt</a>()</code>,
<code><a href="#topic+sv_not_equal">sv_not_equal</a>()</code>,
<code><a href="#topic+sv_numeric">sv_numeric</a>()</code>,
<code><a href="#topic+sv_optional">sv_optional</a>()</code>,
<code><a href="#topic+sv_regex">sv_regex</a>()</code>,
<code><a href="#topic+sv_required">sv_required</a>()</code>,
<code><a href="#topic+sv_url">sv_url</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Only run examples in interactive R sessions
if (interactive()) {

library(shiny)
library(shinyvalidate)

ui &lt;- fluidPage(
  textInput("number", "Number")
)

server &lt;- function(input, output, session) {
  
  # Validation rules are set in the server, start by
  # making a new instance of an `InputValidator()`
  iv &lt;- InputValidator$new()

  # Basic usage: `sv_gt()` requires a value
  # to compare against the field value; a message
  # will be shown if the validation of
  # `input$number` fails
  iv$add_rule("number", sv_gt(0))

  # Finally, `enable()` the validation rules
  iv$enable()
}

shinyApp(ui, server)

}

</code></pre>

<hr>
<h2 id='sv_gte'>Validate that a field is greater than or equal to a specified value</h2><span id='topic+sv_gte'></span>

<h3>Description</h3>

<p>The <code>sv_gte()</code> function compares the field value to a specified value with
the <code>&gt;=</code> operator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sv_gte(
  rhs,
  message_fmt = "Must be greater than or equal to {rhs}.",
  allow_multiple = FALSE,
  allow_na = FALSE,
  allow_nan = FALSE,
  allow_inf = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sv_gte_+3A_rhs">rhs</code></td>
<td>
<p>The right hand side (RHS) value is to be used for the comparison
with the field value. The validation check will effectively be of the form
<code style="white-space: pre;">&#8288;&lt;field&gt; &gt;= &lt;rhs&gt;&#8288;</code>.</p>
</td></tr>
<tr><td><code id="sv_gte_+3A_message_fmt">message_fmt</code></td>
<td>
<p>The validation error message to use if the field fails the
validation test. Use the <code>"{rhs}"</code> string parameter to customize the
message, including what was set in <code>rhs</code>. While the default message uses
this string parameter, it is not required in a user-defined <code>message_fmt</code>
string.</p>
</td></tr>
<tr><td><code id="sv_gte_+3A_allow_multiple">allow_multiple</code></td>
<td>
<p>If <code>FALSE</code> (the default), then the length of the input
vector must be exactly one; if <code>TRUE</code>, then any length is allowed
(including a length of zero; use <code><a href="#topic+sv_required">sv_required()</a></code> if one or more values
should be required).</p>
</td></tr>
<tr><td><code id="sv_gte_+3A_allow_na">allow_na</code>, <code id="sv_gte_+3A_allow_nan">allow_nan</code></td>
<td>
<p>If <code>FALSE</code> (the default for both options), then any
<code>NA</code> or <code>NaN</code> element will cause validation to fail.</p>
</td></tr>
<tr><td><code id="sv_gte_+3A_allow_inf">allow_inf</code></td>
<td>
<p>If <code>FALSE</code> (the default), then any <code>Inf</code> or <code>-Inf</code> element
will cause validation to fail.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function suitable for use as an
<code><a href="#topic+InputValidator">InputValidator$add_rule()</a></code> rule.
</p>


<h3>See Also</h3>

<p>The other comparison-based rule functions: <code><a href="#topic+sv_gt">sv_gt()</a></code>, <code><a href="#topic+sv_lt">sv_lt()</a></code>,
<code><a href="#topic+sv_lte">sv_lte()</a></code>, <code><a href="#topic+sv_equal">sv_equal()</a></code>, and <code><a href="#topic+sv_not_equal">sv_not_equal()</a></code>. The <code><a href="#topic+sv_gt">sv_gt()</a></code> function may
be needed if the field value should not pass validation when it is equal to
the comparison value.
</p>
<p>Other rule functions: 
<code><a href="#topic+compose_rules">compose_rules</a>()</code>,
<code><a href="#topic+sv_between">sv_between</a>()</code>,
<code><a href="#topic+sv_email">sv_email</a>()</code>,
<code><a href="#topic+sv_equal">sv_equal</a>()</code>,
<code><a href="#topic+sv_gt">sv_gt</a>()</code>,
<code><a href="#topic+sv_in_set">sv_in_set</a>()</code>,
<code><a href="#topic+sv_integer">sv_integer</a>()</code>,
<code><a href="#topic+sv_lte">sv_lte</a>()</code>,
<code><a href="#topic+sv_lt">sv_lt</a>()</code>,
<code><a href="#topic+sv_not_equal">sv_not_equal</a>()</code>,
<code><a href="#topic+sv_numeric">sv_numeric</a>()</code>,
<code><a href="#topic+sv_optional">sv_optional</a>()</code>,
<code><a href="#topic+sv_regex">sv_regex</a>()</code>,
<code><a href="#topic+sv_required">sv_required</a>()</code>,
<code><a href="#topic+sv_url">sv_url</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Only run examples in interactive R sessions
if (interactive()) {

library(shiny)
library(shinyvalidate)

ui &lt;- fluidPage(
  textInput("number", "Number")
)

server &lt;- function(input, output, session) {
  
  # Validation rules are set in the server, start by
  # making a new instance of an `InputValidator()`
  iv &lt;- InputValidator$new()

  # Basic usage: `sv_gte()` requires a value
  # to compare against the field value; a message
  # will be shown if the validation of
  # `input$number` fails
  iv$add_rule("number", sv_gte(1))

  # Finally, `enable()` the validation rules
  iv$enable()
}

shinyApp(ui, server)

}

</code></pre>

<hr>
<h2 id='sv_in_set'>Validate that a field is part of a defined set</h2><span id='topic+sv_in_set'></span>

<h3>Description</h3>

<p>The <code>sv_in_set()</code> function checks whether the field value is a member of a
specified set of values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sv_in_set(
  set,
  message_fmt = "Must be in the set of {values_text}.",
  set_limit = 3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sv_in_set_+3A_set">set</code></td>
<td>
<p>A vector or list of elements for which the field value must be a
part of (<code>value %in% set</code> must be <code>TRUE</code>) to pass validation. To allow an
empty field, <code>NA</code> should be included in the <code>set</code> vector. Optionally, <code>NaN</code>
can be included as well.</p>
</td></tr>
<tr><td><code id="sv_in_set_+3A_message_fmt">message_fmt</code></td>
<td>
<p>The validation error message to use if a value fails to
match the rule. The message can be customized by using the
<code>"{values_text}"</code> string parameter, which allows for the insertion of <code>set</code>
values (formatted internally as a text list and controlled via the
<code>set_limit</code> parameter). While the default message uses this string
parameter, it is not required in a user-defined <code>message_fmt</code> string.</p>
</td></tr>
<tr><td><code id="sv_in_set_+3A_set_limit">set_limit</code></td>
<td>
<p>The limit of <code>set</code> values to include in the
automatically-generated error message (i.e., when <code>message = NULL</code>, the
default). If the number of elements provided in <code>set</code> is greater than
<code>set_limit</code> then only the first <code style="white-space: pre;">&#8288;&lt;message_limit&gt;&#8288;</code> set elements will be
echoed along with text that states how many extra elements are part of the
<code>set</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function suitable for use as an
<code><a href="#topic+InputValidator">InputValidator$add_rule()</a></code> rule.
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+sv_between">sv_between()</a></code> function, which tests whether a field values
between two boundary values.
</p>
<p>Other rule functions: 
<code><a href="#topic+compose_rules">compose_rules</a>()</code>,
<code><a href="#topic+sv_between">sv_between</a>()</code>,
<code><a href="#topic+sv_email">sv_email</a>()</code>,
<code><a href="#topic+sv_equal">sv_equal</a>()</code>,
<code><a href="#topic+sv_gte">sv_gte</a>()</code>,
<code><a href="#topic+sv_gt">sv_gt</a>()</code>,
<code><a href="#topic+sv_integer">sv_integer</a>()</code>,
<code><a href="#topic+sv_lte">sv_lte</a>()</code>,
<code><a href="#topic+sv_lt">sv_lt</a>()</code>,
<code><a href="#topic+sv_not_equal">sv_not_equal</a>()</code>,
<code><a href="#topic+sv_numeric">sv_numeric</a>()</code>,
<code><a href="#topic+sv_optional">sv_optional</a>()</code>,
<code><a href="#topic+sv_regex">sv_regex</a>()</code>,
<code><a href="#topic+sv_required">sv_required</a>()</code>,
<code><a href="#topic+sv_url">sv_url</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Only run examples in interactive R sessions
if (interactive()) {

library(shiny)
library(shinyvalidate)

ui &lt;- fluidPage(
  textInput("rating", "Rating")
)

server &lt;- function(input, output, session) {
  
  # Validation rules are set in the server, start by
  # making a new instance of an `InputValidator()`
  iv &lt;- InputValidator$new()

  # Basic usage: `sv_in_set()` requires a value
  # set given as a vector; a message will be
  # shown if the validation of `input$rating` fails
  iv$add_rule("rating", sv_in_set(1:5))

  # Finally, `enable()` the validation rules
  iv$enable()
}

shinyApp(ui, server)

}

</code></pre>

<hr>
<h2 id='sv_integer'>Validate that a field is a number that is integer-like</h2><span id='topic+sv_integer'></span>

<h3>Description</h3>

<p>The <code>sv_integer()</code> function validates that a field is 'integer-like' with the
<code>{value} %% 1 == 0</code> test. Very large values (generally with absolute exponent
values greater than 15) won't be validated correctly due to floating point
imprecision. By default, only a single, finite, not-missing, valid numbers
are allowed, but each of those criteria can be controlled via arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sv_integer(
  message = "An integer is required",
  allow_multiple = FALSE,
  allow_na = FALSE,
  allow_nan = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sv_integer_+3A_message">message</code></td>
<td>
<p>The validation error message to use if a value is not an
integer.</p>
</td></tr>
<tr><td><code id="sv_integer_+3A_allow_multiple">allow_multiple</code></td>
<td>
<p>If <code>FALSE</code> (the default), then the length of the input
vector must be exactly one; if <code>TRUE</code>, then any length is allowed
(including a length of zero; use <code><a href="#topic+sv_required">sv_required()</a></code> if one or more values
should be required).</p>
</td></tr>
<tr><td><code id="sv_integer_+3A_allow_na">allow_na</code>, <code id="sv_integer_+3A_allow_nan">allow_nan</code></td>
<td>
<p>If <code>FALSE</code> (the default for both options), then any
<code>NA</code> or <code>NaN</code> element will cause validation to fail.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function suitable for use as an
<code><a href="#topic+InputValidator">InputValidator$add_rule()</a></code> rule.
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+sv_numeric">sv_numeric()</a></code> function, which tests whether a field value is
simply numeric.
</p>
<p>Other rule functions: 
<code><a href="#topic+compose_rules">compose_rules</a>()</code>,
<code><a href="#topic+sv_between">sv_between</a>()</code>,
<code><a href="#topic+sv_email">sv_email</a>()</code>,
<code><a href="#topic+sv_equal">sv_equal</a>()</code>,
<code><a href="#topic+sv_gte">sv_gte</a>()</code>,
<code><a href="#topic+sv_gt">sv_gt</a>()</code>,
<code><a href="#topic+sv_in_set">sv_in_set</a>()</code>,
<code><a href="#topic+sv_lte">sv_lte</a>()</code>,
<code><a href="#topic+sv_lt">sv_lt</a>()</code>,
<code><a href="#topic+sv_not_equal">sv_not_equal</a>()</code>,
<code><a href="#topic+sv_numeric">sv_numeric</a>()</code>,
<code><a href="#topic+sv_optional">sv_optional</a>()</code>,
<code><a href="#topic+sv_regex">sv_regex</a>()</code>,
<code><a href="#topic+sv_required">sv_required</a>()</code>,
<code><a href="#topic+sv_url">sv_url</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Only run examples in interactive R sessions
if (interactive()) {

library(shiny)
library(shinyvalidate)

ui &lt;- fluidPage(
  textInput("count", "Count")
)

server &lt;- function(input, output, session) {
  
  # Validation rules are set in the server, start by
  # making a new instance of an `InputValidator()`
  iv &lt;- InputValidator$new()

  # Basic usage: `sv_integer()` works well with its
  # defaults; a message will be displayed if the
  # validation of `input$count` fails
  iv$add_rule("count", sv_integer())

  # Finally, `enable()` the validation rules
  iv$enable()
}

shinyApp(ui, server)

}

</code></pre>

<hr>
<h2 id='sv_lt'>Validate that a field is less than a specified value</h2><span id='topic+sv_lt'></span>

<h3>Description</h3>

<p>The <code>sv_lt()</code> function compares the field value to a specified value with the
<code>&lt;</code> operator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sv_lt(
  rhs,
  message_fmt = "Must be less than {rhs}.",
  allow_multiple = FALSE,
  allow_na = FALSE,
  allow_nan = FALSE,
  allow_inf = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sv_lt_+3A_rhs">rhs</code></td>
<td>
<p>The right hand side (RHS) value is to be used for the comparison
with the field value. The validation check will effectively be of the form
<code style="white-space: pre;">&#8288;&lt;field&gt; &lt; &lt;rhs&gt;&#8288;</code>.</p>
</td></tr>
<tr><td><code id="sv_lt_+3A_message_fmt">message_fmt</code></td>
<td>
<p>The validation error message to use if the field fails the
validation test. Use the <code>"{rhs}"</code> string parameter to customize the
message, including what was set in <code>rhs</code>. While the default message uses
this string parameter, it is not required in a user-defined <code>message_fmt</code>
string.</p>
</td></tr>
<tr><td><code id="sv_lt_+3A_allow_multiple">allow_multiple</code></td>
<td>
<p>If <code>FALSE</code> (the default), then the length of the input
vector must be exactly one; if <code>TRUE</code>, then any length is allowed
(including a length of zero; use <code><a href="#topic+sv_required">sv_required()</a></code> if one or more values
should be required).</p>
</td></tr>
<tr><td><code id="sv_lt_+3A_allow_na">allow_na</code>, <code id="sv_lt_+3A_allow_nan">allow_nan</code></td>
<td>
<p>If <code>FALSE</code> (the default for both options), then any
<code>NA</code> or <code>NaN</code> element will cause validation to fail.</p>
</td></tr>
<tr><td><code id="sv_lt_+3A_allow_inf">allow_inf</code></td>
<td>
<p>If <code>FALSE</code> (the default), then any <code>Inf</code> or <code>-Inf</code> element
will cause validation to fail.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function suitable for use as an
<code><a href="#topic+InputValidator">InputValidator$add_rule()</a></code> rule.
</p>


<h3>See Also</h3>

<p>The other comparison-based rule functions: <code><a href="#topic+sv_gt">sv_gt()</a></code>, <code><a href="#topic+sv_gte">sv_gte()</a></code>,
<code><a href="#topic+sv_lte">sv_lte()</a></code>, <code><a href="#topic+sv_equal">sv_equal()</a></code>, and <code><a href="#topic+sv_not_equal">sv_not_equal()</a></code>. The <code><a href="#topic+sv_lte">sv_lte()</a></code> function may
be needed if the field value should also pass validation when equal to the
comparison value.
</p>
<p>Other rule functions: 
<code><a href="#topic+compose_rules">compose_rules</a>()</code>,
<code><a href="#topic+sv_between">sv_between</a>()</code>,
<code><a href="#topic+sv_email">sv_email</a>()</code>,
<code><a href="#topic+sv_equal">sv_equal</a>()</code>,
<code><a href="#topic+sv_gte">sv_gte</a>()</code>,
<code><a href="#topic+sv_gt">sv_gt</a>()</code>,
<code><a href="#topic+sv_in_set">sv_in_set</a>()</code>,
<code><a href="#topic+sv_integer">sv_integer</a>()</code>,
<code><a href="#topic+sv_lte">sv_lte</a>()</code>,
<code><a href="#topic+sv_not_equal">sv_not_equal</a>()</code>,
<code><a href="#topic+sv_numeric">sv_numeric</a>()</code>,
<code><a href="#topic+sv_optional">sv_optional</a>()</code>,
<code><a href="#topic+sv_regex">sv_regex</a>()</code>,
<code><a href="#topic+sv_required">sv_required</a>()</code>,
<code><a href="#topic+sv_url">sv_url</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Only run examples in interactive R sessions
if (interactive()) {

library(shiny)
library(shinyvalidate)

ui &lt;- fluidPage(
  textInput("number", "Number")
)

server &lt;- function(input, output, session) {
  
  # Validation rules are set in the server, start by
  # making a new instance of an `InputValidator()`
  iv &lt;- InputValidator$new()

  # Basic usage: `sv_lt()` requires a value
  # to compare against the field value; a message
  # will be shown if the validation of
  # `input$number` fails
  iv$add_rule("number", sv_lt(10))

  # Finally, `enable()` the validation rules
  iv$enable()
}

shinyApp(ui, server)

}

</code></pre>

<hr>
<h2 id='sv_lte'>Validate that a field is less than or equal to a specified value</h2><span id='topic+sv_lte'></span>

<h3>Description</h3>

<p>The <code>sv_lte()</code> function compares the field value to a specified value with
the <code>&lt;=</code> operator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sv_lte(
  rhs,
  message_fmt = "Must be less than or equal to {rhs}.",
  allow_multiple = FALSE,
  allow_na = FALSE,
  allow_nan = FALSE,
  allow_inf = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sv_lte_+3A_rhs">rhs</code></td>
<td>
<p>The right hand side (RHS) value is to be used for the comparison
with the field value. The validation check will effectively be of the form
<code style="white-space: pre;">&#8288;&lt;field&gt; &lt;= &lt;rhs&gt;&#8288;</code>.</p>
</td></tr>
<tr><td><code id="sv_lte_+3A_message_fmt">message_fmt</code></td>
<td>
<p>The validation error message to use if the field fails the
validation test. Use the <code>"{rhs}"</code> string parameter to customize the
message, including what was set in <code>rhs</code>. While the default message uses
this string parameter, it is not required in a user-defined <code>message_fmt</code>
string.</p>
</td></tr>
<tr><td><code id="sv_lte_+3A_allow_multiple">allow_multiple</code></td>
<td>
<p>If <code>FALSE</code> (the default), then the length of the input
vector must be exactly one; if <code>TRUE</code>, then any length is allowed
(including a length of zero; use <code><a href="#topic+sv_required">sv_required()</a></code> if one or more values
should be required).</p>
</td></tr>
<tr><td><code id="sv_lte_+3A_allow_na">allow_na</code>, <code id="sv_lte_+3A_allow_nan">allow_nan</code></td>
<td>
<p>If <code>FALSE</code> (the default for both options), then any
<code>NA</code> or <code>NaN</code> element will cause validation to fail.</p>
</td></tr>
<tr><td><code id="sv_lte_+3A_allow_inf">allow_inf</code></td>
<td>
<p>If <code>FALSE</code> (the default), then any <code>Inf</code> or <code>-Inf</code> element
will cause validation to fail.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function suitable for use as an
<code><a href="#topic+InputValidator">InputValidator$add_rule()</a></code> rule.
</p>


<h3>See Also</h3>

<p>The other comparison-based rule functions: <code><a href="#topic+sv_gt">sv_gt()</a></code>, <code><a href="#topic+sv_gte">sv_gte()</a></code>,
<code><a href="#topic+sv_lt">sv_lt()</a></code>, <code><a href="#topic+sv_equal">sv_equal()</a></code>, and <code><a href="#topic+sv_not_equal">sv_not_equal()</a></code>. The <code><a href="#topic+sv_lt">sv_lt()</a></code> function may
be needed if the field value should not pass validation when it is equal to
the comparison value.
</p>
<p>Other rule functions: 
<code><a href="#topic+compose_rules">compose_rules</a>()</code>,
<code><a href="#topic+sv_between">sv_between</a>()</code>,
<code><a href="#topic+sv_email">sv_email</a>()</code>,
<code><a href="#topic+sv_equal">sv_equal</a>()</code>,
<code><a href="#topic+sv_gte">sv_gte</a>()</code>,
<code><a href="#topic+sv_gt">sv_gt</a>()</code>,
<code><a href="#topic+sv_in_set">sv_in_set</a>()</code>,
<code><a href="#topic+sv_integer">sv_integer</a>()</code>,
<code><a href="#topic+sv_lt">sv_lt</a>()</code>,
<code><a href="#topic+sv_not_equal">sv_not_equal</a>()</code>,
<code><a href="#topic+sv_numeric">sv_numeric</a>()</code>,
<code><a href="#topic+sv_optional">sv_optional</a>()</code>,
<code><a href="#topic+sv_regex">sv_regex</a>()</code>,
<code><a href="#topic+sv_required">sv_required</a>()</code>,
<code><a href="#topic+sv_url">sv_url</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Only run examples in interactive R sessions
if (interactive()) {

library(shiny)
library(shinyvalidate)

ui &lt;- fluidPage(
  textInput("number", "Number")
)

server &lt;- function(input, output, session) {
  
  # Validation rules are set in the server, start by
  # making a new instance of an `InputValidator()`
  iv &lt;- InputValidator$new()

  # Basic usage: `sv_lte()` requires a value
  # to compare against the field value; a message
  # will be shown if the validation of
  # `input$number` fails
  iv$add_rule("number", sv_lte(0))

  # Finally, `enable()` the validation rules
  iv$enable()
}

shinyApp(ui, server)

}

</code></pre>

<hr>
<h2 id='sv_not_equal'>Validate that a field is not equal to a specified value</h2><span id='topic+sv_not_equal'></span>

<h3>Description</h3>

<p>The <code>sv_not_equal()</code> function compares the field value to a specified value
with the <code>!=</code> operator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sv_not_equal(
  rhs,
  message_fmt = "Must not be equal to {rhs}.",
  allow_multiple = FALSE,
  allow_na = FALSE,
  allow_nan = FALSE,
  allow_inf = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sv_not_equal_+3A_rhs">rhs</code></td>
<td>
<p>The right hand side (RHS) value is to be used for the comparison
with the field value. The validation check will effectively be of the form
<code style="white-space: pre;">&#8288;&lt;field&gt; != &lt;rhs&gt;&#8288;</code>.</p>
</td></tr>
<tr><td><code id="sv_not_equal_+3A_message_fmt">message_fmt</code></td>
<td>
<p>The validation error message to use if the field fails the
validation test. Use the <code>"{rhs}"</code> string parameter to customize the
message, including what was set in <code>rhs</code>. While the default message uses
this string parameter, it is not required in a user-defined <code>message_fmt</code>
string.</p>
</td></tr>
<tr><td><code id="sv_not_equal_+3A_allow_multiple">allow_multiple</code></td>
<td>
<p>If <code>FALSE</code> (the default), then the length of the input
vector must be exactly one; if <code>TRUE</code>, then any length is allowed
(including a length of zero; use <code><a href="#topic+sv_required">sv_required()</a></code> if one or more values
should be required).</p>
</td></tr>
<tr><td><code id="sv_not_equal_+3A_allow_na">allow_na</code>, <code id="sv_not_equal_+3A_allow_nan">allow_nan</code></td>
<td>
<p>If <code>FALSE</code> (the default for both options), then any
<code>NA</code> or <code>NaN</code> element will cause validation to fail.</p>
</td></tr>
<tr><td><code id="sv_not_equal_+3A_allow_inf">allow_inf</code></td>
<td>
<p>If <code>FALSE</code> (the default), then any <code>Inf</code> or <code>-Inf</code> element
will cause validation to fail.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function suitable for use as an
<code><a href="#topic+InputValidator">InputValidator$add_rule()</a></code> rule.
</p>


<h3>See Also</h3>

<p>The other comparison-based rule functions: <code><a href="#topic+sv_gt">sv_gt()</a></code>, <code><a href="#topic+sv_gte">sv_gte()</a></code>,
<code><a href="#topic+sv_lt">sv_lt()</a></code>, <code><a href="#topic+sv_lte">sv_lte()</a></code>, and <code><a href="#topic+sv_equal">sv_equal()</a></code> (which serves as the opposite
function to <code>sv_not_equal()</code>).
</p>
<p>Other rule functions: 
<code><a href="#topic+compose_rules">compose_rules</a>()</code>,
<code><a href="#topic+sv_between">sv_between</a>()</code>,
<code><a href="#topic+sv_email">sv_email</a>()</code>,
<code><a href="#topic+sv_equal">sv_equal</a>()</code>,
<code><a href="#topic+sv_gte">sv_gte</a>()</code>,
<code><a href="#topic+sv_gt">sv_gt</a>()</code>,
<code><a href="#topic+sv_in_set">sv_in_set</a>()</code>,
<code><a href="#topic+sv_integer">sv_integer</a>()</code>,
<code><a href="#topic+sv_lte">sv_lte</a>()</code>,
<code><a href="#topic+sv_lt">sv_lt</a>()</code>,
<code><a href="#topic+sv_numeric">sv_numeric</a>()</code>,
<code><a href="#topic+sv_optional">sv_optional</a>()</code>,
<code><a href="#topic+sv_regex">sv_regex</a>()</code>,
<code><a href="#topic+sv_required">sv_required</a>()</code>,
<code><a href="#topic+sv_url">sv_url</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Only run examples in interactive R sessions
if (interactive()) {

library(shiny)
library(shinyvalidate)

ui &lt;- fluidPage(
  textInput("score", "Number")
)

server &lt;- function(input, output, session) {
  
  # Validation rules are set in the server, start by
  # making a new instance of an `InputValidator()`
  iv &lt;- InputValidator$new()

  # Basic usage: `sv_not_equal()` requires a value
  # to compare against the field value; a message
  # will be shown if the validation of
  # `input$score` fails
  iv$add_rule("score", sv_not_equal(0))

  # Finally, `enable()` the validation rules
  iv$enable()
}

shinyApp(ui, server)

}

</code></pre>

<hr>
<h2 id='sv_numeric'>Validate that a field is a number</h2><span id='topic+sv_numeric'></span>

<h3>Description</h3>

<p>The <code>sv_numeric()</code> function validates that a field is numeric with the
<code><a href="base.html#topic+numeric">base::is.numeric()</a></code> function. By default, only a single, finite,
not-missing, valid number is allowed, but each of those criteria can be
controlled via arguments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sv_numeric(
  message = "A number is required",
  allow_multiple = FALSE,
  allow_na = FALSE,
  allow_nan = FALSE,
  allow_inf = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sv_numeric_+3A_message">message</code></td>
<td>
<p>The validation error message to use if a value is not numeric.</p>
</td></tr>
<tr><td><code id="sv_numeric_+3A_allow_multiple">allow_multiple</code></td>
<td>
<p>If <code>FALSE</code> (the default), then the length of the input
vector must be exactly one; if <code>TRUE</code>, then any length is allowed
(including a length of zero; use <code><a href="#topic+sv_required">sv_required()</a></code> if one or more values
should be required).</p>
</td></tr>
<tr><td><code id="sv_numeric_+3A_allow_na">allow_na</code>, <code id="sv_numeric_+3A_allow_nan">allow_nan</code></td>
<td>
<p>If <code>FALSE</code> (the default for both options), then any
<code>NA</code> or <code>NaN</code> element will cause validation to fail.</p>
</td></tr>
<tr><td><code id="sv_numeric_+3A_allow_inf">allow_inf</code></td>
<td>
<p>If <code>FALSE</code> (the default), then any <code>Inf</code> or <code>-Inf</code> element
will cause validation to fail.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function suitable for use as an
<code><a href="#topic+InputValidator">InputValidator$add_rule()</a></code> rule.
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+sv_integer">sv_integer()</a></code> function, which tests whether a field value is a
number that is integer-like.
</p>
<p>Other rule functions: 
<code><a href="#topic+compose_rules">compose_rules</a>()</code>,
<code><a href="#topic+sv_between">sv_between</a>()</code>,
<code><a href="#topic+sv_email">sv_email</a>()</code>,
<code><a href="#topic+sv_equal">sv_equal</a>()</code>,
<code><a href="#topic+sv_gte">sv_gte</a>()</code>,
<code><a href="#topic+sv_gt">sv_gt</a>()</code>,
<code><a href="#topic+sv_in_set">sv_in_set</a>()</code>,
<code><a href="#topic+sv_integer">sv_integer</a>()</code>,
<code><a href="#topic+sv_lte">sv_lte</a>()</code>,
<code><a href="#topic+sv_lt">sv_lt</a>()</code>,
<code><a href="#topic+sv_not_equal">sv_not_equal</a>()</code>,
<code><a href="#topic+sv_optional">sv_optional</a>()</code>,
<code><a href="#topic+sv_regex">sv_regex</a>()</code>,
<code><a href="#topic+sv_required">sv_required</a>()</code>,
<code><a href="#topic+sv_url">sv_url</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Only run examples in interactive R sessions
if (interactive()) {

library(shiny)
library(shinyvalidate)

ui &lt;- fluidPage(
  textInput("rating", "Rating")
)

server &lt;- function(input, output, session) {
  
  # Validation rules are set in the server, start by
  # making a new instance of an `InputValidator()`
  iv &lt;- InputValidator$new()

  # Basic usage: `sv_numeric()` works well with its
  # defaults; a message will be displayed if the
  # validation of `input$rating` fails
  iv$add_rule("rating", sv_numeric())

  # Finally, `enable()` the validation rules
  iv$enable()
}

shinyApp(ui, server)

}

</code></pre>

<hr>
<h2 id='sv_optional'>Indicate that a field is optional</h2><span id='topic+sv_optional'></span>

<h3>Description</h3>

<p>Call <code>sv_optional()</code> to generate a validation function that indicates an
input is allowed to <em>not</em> be present. If an <code>sv_optional()</code> rule sees that an
input is not present, subsequent rules for that input are skipped and the
input is considered valid. Otherwise, the rule simply passes.
(<code>sv_optional()</code> will never return a validation error/message.)
</p>
<p>By default, the definition of &quot;is present&quot; is based on <code><a href="#topic+input_provided">input_provided()</a></code>.
</p>
<p>Child validators (see <code><a href="#topic+InputValidator">InputValidator$add_validator()</a></code>) are
not affected by <code>sv_optional()</code> rules in parent validators; only rules in the
same validator instance as the <code>sv_optional()</code> will be skipped.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sv_optional(test = input_provided)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sv_optional_+3A_test">test</code></td>
<td>
<p>A single-argument function, or single-sided formula (using <code>.</code> to
access the value to test), that returns <code>TRUE</code> for success and <code>FALSE</code> for
failure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function suitable for use as an
<code><a href="#topic+InputValidator">InputValidator$add_rule()</a></code> rule.
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+sv_required">sv_required()</a></code> function, which takes a different approach to
field presence.
</p>
<p>Other rule functions: 
<code><a href="#topic+compose_rules">compose_rules</a>()</code>,
<code><a href="#topic+sv_between">sv_between</a>()</code>,
<code><a href="#topic+sv_email">sv_email</a>()</code>,
<code><a href="#topic+sv_equal">sv_equal</a>()</code>,
<code><a href="#topic+sv_gte">sv_gte</a>()</code>,
<code><a href="#topic+sv_gt">sv_gt</a>()</code>,
<code><a href="#topic+sv_in_set">sv_in_set</a>()</code>,
<code><a href="#topic+sv_integer">sv_integer</a>()</code>,
<code><a href="#topic+sv_lte">sv_lte</a>()</code>,
<code><a href="#topic+sv_lt">sv_lt</a>()</code>,
<code><a href="#topic+sv_not_equal">sv_not_equal</a>()</code>,
<code><a href="#topic+sv_numeric">sv_numeric</a>()</code>,
<code><a href="#topic+sv_regex">sv_regex</a>()</code>,
<code><a href="#topic+sv_required">sv_required</a>()</code>,
<code><a href="#topic+sv_url">sv_url</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Only run examples in interactive R sessions
if (interactive()) {

library(shiny)
library(shinyvalidate)

ui &lt;- fluidPage(
  textInput("email", "Email")
)

server &lt;- function(input, output, session) {
  
  # Validation rules are set in the server, start by
  # making a new instance of an `InputValidator()`
  iv &lt;- InputValidator$new()

  # Basic usage: `sv_optional()` is often paired with
  # another `sv_*()` function; below, an email in
  # `input$email` is not required, but if present, it
  # must be valid
  iv$add_rule("email", sv_optional())
  iv$add_rule("email", sv_email())

  # Finally, `enable()` the validation rules
  iv$enable()
}

shinyApp(ui, server)

}

</code></pre>

<hr>
<h2 id='sv_regex'>Validate that a field matches a regular expression</h2><span id='topic+sv_regex'></span>

<h3>Description</h3>

<p>A validation function, suitable for use with <code>InputValidator$add_rule()</code>,
that checks whether input values match the specified regular expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sv_regex(
  pattern,
  message,
  ignore.case = FALSE,
  perl = FALSE,
  fixed = FALSE,
  useBytes = FALSE,
  invert = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sv_regex_+3A_pattern">pattern</code></td>
<td>
<p>Character string containing a regular expression (or character
string if <code>fixed = TRUE</code>) to be tested against. If a character vector of
length 2 or more is supplied, the first element is used with a warning.</p>
</td></tr>
<tr><td><code id="sv_regex_+3A_message">message</code></td>
<td>
<p>The validation error message to use if a value fails to match
the pattern.</p>
</td></tr>
<tr><td><code id="sv_regex_+3A_ignore.case">ignore.case</code>, <code id="sv_regex_+3A_perl">perl</code>, <code id="sv_regex_+3A_fixed">fixed</code>, <code id="sv_regex_+3A_usebytes">useBytes</code>, <code id="sv_regex_+3A_invert">invert</code></td>
<td>
<p>Options passed through to
<code><a href="base.html#topic+grep">base::grepl()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function suitable for use as an
<code><a href="#topic+InputValidator">InputValidator$add_rule()</a></code> rule.
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+sv_email">sv_email()</a></code> and <code><a href="#topic+sv_url">sv_url()</a></code> functions, which are specialized
regex-based functions for validating email addresses and URLs.
</p>
<p>Other rule functions: 
<code><a href="#topic+compose_rules">compose_rules</a>()</code>,
<code><a href="#topic+sv_between">sv_between</a>()</code>,
<code><a href="#topic+sv_email">sv_email</a>()</code>,
<code><a href="#topic+sv_equal">sv_equal</a>()</code>,
<code><a href="#topic+sv_gte">sv_gte</a>()</code>,
<code><a href="#topic+sv_gt">sv_gt</a>()</code>,
<code><a href="#topic+sv_in_set">sv_in_set</a>()</code>,
<code><a href="#topic+sv_integer">sv_integer</a>()</code>,
<code><a href="#topic+sv_lte">sv_lte</a>()</code>,
<code><a href="#topic+sv_lt">sv_lt</a>()</code>,
<code><a href="#topic+sv_not_equal">sv_not_equal</a>()</code>,
<code><a href="#topic+sv_numeric">sv_numeric</a>()</code>,
<code><a href="#topic+sv_optional">sv_optional</a>()</code>,
<code><a href="#topic+sv_required">sv_required</a>()</code>,
<code><a href="#topic+sv_url">sv_url</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Only run examples in interactive R sessions
if (interactive()) {

library(shiny)
library(shinyvalidate)

ui &lt;- fluidPage(
  textInput("lookup_id", "Lookup ID")
)

server &lt;- function(input, output, session) {
  
  # Validation rules are set in the server, start by
  # making a new instance of an `InputValidator()`
  iv &lt;- InputValidator$new()

  # Basic usage: `sv_regex()` requires both a regex
  # pattern and message to display if the validation
  # of `input$lookup_id` fails
  iv$add_rule(
    "lookup_id",
    sv_regex("^[a-zA-Z0-9]*$", "Only alphanumeric characters allowed")
  )

  # Finally, `enable()` the validation rules
  iv$enable()
}

shinyApp(ui, server)

}

# As an alternative to the above example, the
# following snippet can serve to replace the
# `iv$add_rule(...)` statement

# If you're more comfortable with wildcards
# (i.e., globbing) than with regular expressions,
# use `glob2rx()` in `pattern`

# iv$add_rule(
#   "lookup_id",
#   sv_regex(
#     pattern = glob2rx("*.png"),
#     message = "A filename ending in 'png' was expected",
#     ignore.case = TRUE
#   )
# )

</code></pre>

<hr>
<h2 id='sv_required'>Validate that the field is present</h2><span id='topic+sv_required'></span>

<h3>Description</h3>

<p>Call <code>sv_required()</code> to generate a validation function that ensures an input
value is present. By default, the definition of &quot;is present&quot; is based on
<code><a href="#topic+input_provided">input_provided()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sv_required(message = "Required", test = input_provided)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sv_required_+3A_message">message</code></td>
<td>
<p>The validation error message to be displayed if the test does
not pass.</p>
</td></tr>
<tr><td><code id="sv_required_+3A_test">test</code></td>
<td>
<p>A single-argument function, or single-sided formula (using <code>.</code> to
access the value to test), that returns <code>TRUE</code> for success and <code>FALSE</code> for
failure.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function suitable for use as an
<code><a href="#topic+InputValidator">InputValidator$add_rule()</a></code> rule.
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+sv_optional">sv_optional()</a></code> function, which takes a different approach to
field presence.
</p>
<p>Other rule functions: 
<code><a href="#topic+compose_rules">compose_rules</a>()</code>,
<code><a href="#topic+sv_between">sv_between</a>()</code>,
<code><a href="#topic+sv_email">sv_email</a>()</code>,
<code><a href="#topic+sv_equal">sv_equal</a>()</code>,
<code><a href="#topic+sv_gte">sv_gte</a>()</code>,
<code><a href="#topic+sv_gt">sv_gt</a>()</code>,
<code><a href="#topic+sv_in_set">sv_in_set</a>()</code>,
<code><a href="#topic+sv_integer">sv_integer</a>()</code>,
<code><a href="#topic+sv_lte">sv_lte</a>()</code>,
<code><a href="#topic+sv_lt">sv_lt</a>()</code>,
<code><a href="#topic+sv_not_equal">sv_not_equal</a>()</code>,
<code><a href="#topic+sv_numeric">sv_numeric</a>()</code>,
<code><a href="#topic+sv_optional">sv_optional</a>()</code>,
<code><a href="#topic+sv_regex">sv_regex</a>()</code>,
<code><a href="#topic+sv_url">sv_url</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Only run examples in interactive R sessions
if (interactive()) {

library(shiny)
library(shinyvalidate)

ui &lt;- fluidPage(
  textInput("name", "Name")
)

server &lt;- function(input, output, session) {
  
  # Validation rules are set in the server, start by
  # making a new instance of an `InputValidator()`
  iv &lt;- InputValidator$new()

  # Basic usage: ensure that `input$name` is present,
  # and return a terse validation message if not
  iv$add_rule("name", sv_required())

  # Finally, `enable()` the validation rules
  iv$enable()
}

shinyApp(ui, server)

}

# There are some alternatives to the above example,
# and the following snippets can serve to replace
# the `iv$add_rule(...)` statement

# (1) Providing a custom message to display
# when validation fails:

# iv$add_rule("email", sv_required("An email is required"))

# (2) Providing a `test` argument to change
# the definition of "is present"; in this
# snippet, any non-NULL value will be accepted:

# iv$add_rule("choices", sv_required(test = is.null))

</code></pre>

<hr>
<h2 id='sv_url'>Validate that a field contains a URL</h2><span id='topic+sv_url'></span>

<h3>Description</h3>

<p>A validation function, suitable for use with <code>InputValidator$add_rule()</code>,
that checks whether an input value is a valid URL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sv_url(message = "Not a valid URL", allow_multiple = FALSE, allow_na = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sv_url_+3A_message">message</code></td>
<td>
<p>The validation error message to use if a value doesn't match a
regex pattern for URL detection.</p>
</td></tr>
<tr><td><code id="sv_url_+3A_allow_multiple">allow_multiple</code></td>
<td>
<p>If <code>FALSE</code> (the default), then the length of the input
vector must be exactly one; if <code>TRUE</code>, then any length is allowed
(including a length of zero; use <code><a href="#topic+sv_required">sv_required()</a></code> if one or more values
should be required).</p>
</td></tr>
<tr><td><code id="sv_url_+3A_allow_na">allow_na</code></td>
<td>
<p>If <code>FALSE</code>, then any <code>NA</code> element will cause validation to
fail.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A function suitable for use as an
<code><a href="#topic+InputValidator">InputValidator$add_rule()</a></code> rule.
</p>


<h3>See Also</h3>

<p>The <code><a href="#topic+sv_email">sv_email()</a></code> function, another specialized regex-based function
for validating email addresses. For general regex-based validation the
<code><a href="#topic+sv_regex">sv_regex()</a></code> function is useful.
</p>
<p>Other rule functions: 
<code><a href="#topic+compose_rules">compose_rules</a>()</code>,
<code><a href="#topic+sv_between">sv_between</a>()</code>,
<code><a href="#topic+sv_email">sv_email</a>()</code>,
<code><a href="#topic+sv_equal">sv_equal</a>()</code>,
<code><a href="#topic+sv_gte">sv_gte</a>()</code>,
<code><a href="#topic+sv_gt">sv_gt</a>()</code>,
<code><a href="#topic+sv_in_set">sv_in_set</a>()</code>,
<code><a href="#topic+sv_integer">sv_integer</a>()</code>,
<code><a href="#topic+sv_lte">sv_lte</a>()</code>,
<code><a href="#topic+sv_lt">sv_lt</a>()</code>,
<code><a href="#topic+sv_not_equal">sv_not_equal</a>()</code>,
<code><a href="#topic+sv_numeric">sv_numeric</a>()</code>,
<code><a href="#topic+sv_optional">sv_optional</a>()</code>,
<code><a href="#topic+sv_regex">sv_regex</a>()</code>,
<code><a href="#topic+sv_required">sv_required</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Only run examples in interactive R sessions
if (interactive()) {

library(shiny)
library(shinyvalidate)

ui &lt;- fluidPage(
  textInput("url", "URL")
)

server &lt;- function(input, output, session) {
  
  # Validation rules are set in the server, start by
  # making a new instance of an `InputValidator()`
  iv &lt;- InputValidator$new()

  # Basic usage: `sv_url()` works well with its
  # defaults; a message will be displayed if the
  # validation of `input$address` fails
  iv$add_rule("url", sv_url())

  # Finally, `enable()` the validation rules
  iv$enable()
}

shinyApp(ui, server)

}

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
