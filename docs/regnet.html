<!DOCTYPE html><html><head><title>Help for package regnet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {regnet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#regnet-package'><p>regnet: Network-Based Regularization for Generalized Linear Models</p></a></li>
<li><a href='#cv.regnet'><p>k-folds cross-validation for regnet</p></a></li>
<li><a href='#plot.regnet'><p>plot a regnet object</p></a></li>
<li><a href='#print.cv.regnet'><p>print a cv.regnet object</p></a></li>
<li><a href='#print.regnet'><p>print a regnet object</p></a></li>
<li><a href='#regnet'><p>fit a regression for given lambda with network-based regularization</p></a></li>
<li><a href='#rgn'><p>Example datasets for demonstrating the features of regnet</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Network-Based Regularization for Generalized Linear Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Jie Ren, Luann C. Jung, Yinhao Du, Cen Wu, Yu Jiang, Junhao Liu</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jie Ren &lt;jieren@ksu.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Network-based regularization has achieved success in variable selection for 
    high-dimensional biological data due to its ability to incorporate correlations among 
    genomic features. This package provides procedures of network-based variable selection 
    for generalized linear models (Ren et al. (2017) &lt;<a href="https://doi.org/10.1186%2Fs12863-017-0495-5">doi:10.1186/s12863-017-0495-5</a>&gt; and 
	Ren et al.(2019) &lt;<a href="https://doi.org/10.1002%2Fgepi.22194">doi:10.1002/gepi.22194</a>&gt;). Continuous, binary, and survival response 
	are supported. Robust network-based methods are available for continuous and survival 
	responses. </td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>glmnet, stats, Rcpp, igraph, utils</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/jrhub/regnet">https://github.com/jrhub/regnet</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/jrhub/regnet/issues">https://github.com/jrhub/regnet/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, covr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-22 02:04:56 UTC; 17854</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-22 03:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='regnet-package'>regnet: Network-Based Regularization for Generalized Linear Models</h2><span id='topic+regnet-package'></span>

<h3>Description</h3>

<p>Network-based regularization has achieved success in variable selection for high-dimensional biological data due to its ability to incorporate correlations among genomic features. This package provides procedures of network-based variable selection for generalized linear models (Ren et al. (2017) <a href="https://doi.org/10.1186/s12863-017-0495-5">doi:10.1186/s12863-017-0495-5</a> and Ren et al.(2019) <a href="https://doi.org/10.1002/gepi.22194">doi:10.1002/gepi.22194</a>). Continuous, binary, and survival response are supported. Robust network-based methods are available for continuous and survival responses.
</p>
<p>This package provides the implementation of the network-based variable selection method in Ren et al (2017) and the robust network-based method in Ren et al (2019). In addition to the network penalty, regnet allows users to use classical LASSO and MCP penalties.
</p>


<h3>Details</h3>

<p>Two easy-to-use, integrated interfaces, cv.regnet() and regnet() allow users to flexibly choose the method that they want to use.
There are three arguments to control the fitting method
</p>

<table>
<tr>
 <td style="text-align: right;">
response: </td><td style="text-align: left;"> three types of response are supported: "binary", "continuous" </td>
</tr>
<tr>
 <td style="text-align: right;"> </td><td style="text-align: left;"> and "survival". </td>
</tr>
<tr>
 <td style="text-align: right;"></td>
</tr>
<tr>
 <td style="text-align: right;">
penalty: </td><td style="text-align: left;"> three choices of the penalty functions are available: "network", </td>
</tr>
<tr>
 <td style="text-align: right;"> </td><td style="text-align: left;">"mcp" and "lasso".</td>
</tr>
<tr>
 <td style="text-align: right;"></td>
</tr>
<tr>
 <td style="text-align: right;">
robust: </td><td style="text-align: left;"> whether to use robust methods for modeling. Robust methods </td>
</tr>
<tr>
 <td style="text-align: right;"> </td><td style="text-align: left;"> are available for survival and continuous responses.
</td>
</tr>

</table>

<p>In penalized regression, the tuning parameter <code class="reqn">\lambda_{1}</code> controls the sparsity of the coefficient profile. For network-based methods, an additional tuning parameter <code class="reqn">\lambda_{2}</code> is needed for controlling the smoothness among coefficients. Typical usage of the package is to have the cv.regnet() compute the optimal values of lambdas, then provide them to the regnet() function for estimating the coefficients.
</p>
<p>If the users want to include clinical variables that are not subject to the penalty in the model, the argument 'clv' can be used to indicate the positions of clinical variables in the X matrix. e.g. 'clv=(1:5)' meaning that the first five variables in X will not be penalized. It is recommended to put the clinical variables at the beginning of the X matrix in a contiguous way (see the 'Value' section of the regnet() function). However, non-contiguous indices, e.g. 'clv=(2,4,6)', are also allowed.
</p>


<h3>References</h3>

<p>Ren, J., Du, Y., Li, S., Ma, S., Jiang,Y. and Wu, C. (2019). Robust network-based regularization
and variable selection for high dimensional genomics data in cancer prognosis.
<em>Genet. Epidemiol.</em>, 43:276-291 <a href="https://doi.org/10.1002/gepi.22194">doi:10.1002/gepi.22194</a>
</p>
<p>Wu, C., Zhang, Q., Jiang,Y. and Ma, S. (2018). Robust network-based analysis of the associations between (epi)genetic measurements.
<em>J Multivar Anal.</em>, 168:119-130 <a href="https://doi.org/10.1016/j.jmva.2018.06.009">doi:10.1016/j.jmva.2018.06.009</a>
</p>
<p>Wu, C., Jiang, Y., Ren, J., Cui, Y. and Ma, S. (2018). Dissecting gene-environment interactions: A penalized robust approach accounting for hierarchical structures.
<em>Statistics in Medicine</em>, 37:437–456 <a href="https://doi.org/10.1002/sim.7518">doi:10.1002/sim.7518</a>
</p>
<p>Ren, J., He, T., Li, Y., Liu, S., Du, Y., Jiang, Y., and Wu, C. (2017).
Network-based regularization for high dimensional SNP data in the case-control study of
Type 2 diabetes. <em>BMC Genetics</em>, 18(1):44 <a href="https://doi.org/10.1186/s12863-017-0495-5">doi:10.1186/s12863-017-0495-5</a>
</p>
<p>Wu, C., and Ma, S. (2015). A selective review of robust variable selection with applications in bioinformatics.
<em>Briefings in Bioinformatics</em>, 16(5), 873–883 <a href="https://doi.org/10.1093/bib/bbu046">doi:10.1093/bib/bbu046</a>
</p>
<p>Wu, C., Shi, X., Cui, Y. and Ma, S. (2015). A penalized robust semiparametric approach for gene-environment interactions.
<em>Statistics in Medicine</em>, 34 (30): 4016–4030 <a href="https://doi.org/10.1002/sim.6609">doi:10.1002/sim.6609</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/jrhub/regnet">https://github.com/jrhub/regnet</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/jrhub/regnet/issues">https://github.com/jrhub/regnet/issues</a>
</p>
</li></ul>

<p><code><a href="#topic+cv.regnet">cv.regnet</a></code> <code><a href="#topic+regnet">regnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Survival response using robust network method
data(SurvExample)
X = rgn.surv$X
Y = rgn.surv$Y
clv = c(1:5) # variables 1 to 5 are treated as clinical variables, we choose not to penalize them.
out = cv.regnet(X, Y, response="survival", penalty="network", clv=clv, robust=TRUE, verbo = TRUE)
out$lambda

fit = regnet(X, Y, "survival", "network", out$lambda[1,1], out$lambda[1,2], clv=clv, robust=TRUE)
index = which(rgn.surv$beta[-(1:6)] != 0)  # [-(1:6)] removes the intercept and clinical variables
pos = which(fit$coeff[-(1:6)] != 0)
tp = length(intersect(index, pos))
fp = length(pos) - tp
list(tp=tp, fp=fp)


</code></pre>

<hr>
<h2 id='cv.regnet'>k-folds cross-validation for regnet</h2><span id='topic+cv.regnet'></span>

<h3>Description</h3>

<p>This function does k-fold cross-validation for regnet and returns the optimal value(s) of lambda.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.regnet(
  X,
  Y,
  response = c("binary", "continuous", "survival"),
  penalty = c("network", "mcp", "lasso"),
  lamb.1 = NULL,
  lamb.2 = NULL,
  folds = 5,
  r = NULL,
  clv = NULL,
  initiation = NULL,
  alpha.i = 1,
  robust = FALSE,
  verbo = FALSE,
  debugging = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.regnet_+3A_x">X</code></td>
<td>
<p>X matrix without intercept (see <code><a href="#topic+regnet">regnet</a></code>).</p>
</td></tr>
<tr><td><code id="cv.regnet_+3A_y">Y</code></td>
<td>
<p>the response variable Y (see <code><a href="#topic+regnet">regnet</a></code>).</p>
</td></tr>
<tr><td><code id="cv.regnet_+3A_response">response</code></td>
<td>
<p>the response type. regnet supports three types of response: &quot;binary&quot;, &quot;continuous&quot; and &quot;survival&quot;.</p>
</td></tr>
<tr><td><code id="cv.regnet_+3A_penalty">penalty</code></td>
<td>
<p>the penalty type. regnet provides three choices for the penalty function: &quot;network&quot;, &quot;mcp&quot; and &quot;lasso&quot;.</p>
</td></tr>
<tr><td><code id="cv.regnet_+3A_lamb.1">lamb.1</code></td>
<td>
<p>a user-supplied sequence of <code class="reqn">\lambda_{1}</code> values, which serves as a tuning parameter to impose sparsity.
If it is left as NULL, regnet will compute its own sequence.</p>
</td></tr>
<tr><td><code id="cv.regnet_+3A_lamb.2">lamb.2</code></td>
<td>
<p>a user-supplied sequence of <code class="reqn">\lambda_{2}</code> values for network method. <code class="reqn">\lambda_{2}</code> controls the smoothness
among coefficient profiles. If it is left as NULL, a default sequence will be used.</p>
</td></tr>
<tr><td><code id="cv.regnet_+3A_folds">folds</code></td>
<td>
<p>the number of folds for cross-validation; the default is 5.</p>
</td></tr>
<tr><td><code id="cv.regnet_+3A_r">r</code></td>
<td>
<p>the regularization parameter in MCP; default is 5. For binary response, r should be larger than 4.</p>
</td></tr>
<tr><td><code id="cv.regnet_+3A_clv">clv</code></td>
<td>
<p>a value or a vector, indexing variables that are not subject to penalty. clv only works for continuous and survival responses in the current version of regnet,
and will be ignored for other types of responses.</p>
</td></tr>
<tr><td><code id="cv.regnet_+3A_initiation">initiation</code></td>
<td>
<p>the method for initiating the coefficient vector. The default method is elastic-net.</p>
</td></tr>
<tr><td><code id="cv.regnet_+3A_alpha.i">alpha.i</code></td>
<td>
<p>the elastic-net mixing parameter. The program can use the elastic-net for choosing initial values of
the coefficient vector. alpha.i is the elastic-net mixing parameter, with 0 <code class="reqn">\le</code> alpha.i <code class="reqn">\le</code> 1. alpha.i=1 is the
lasso penalty, and alpha.i=0 is the ridge penalty. If the user chooses a method other than elastic-net for initializing
coefficients, alpha.i will be ignored.</p>
</td></tr>
<tr><td><code id="cv.regnet_+3A_robust">robust</code></td>
<td>
<p>a logical flag. Whether or not to use robust methods. Robust methods are available for survival and continuous response.</p>
</td></tr>
<tr><td><code id="cv.regnet_+3A_verbo">verbo</code></td>
<td>
<p>output progress to the console.</p>
</td></tr>
<tr><td><code id="cv.regnet_+3A_debugging">debugging</code></td>
<td>
<p>a logical flag. If TRUE, extra information will be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When lamb.1 is left as NULL, regnet computes its own sequence. You can find the lamb.1 sequence used by the program in
the returned CVM matrix (see the 'Value' section). If you find the default sequence does not work well, you can try (1) standardizing
the response vector Y; or (2) providing a customized lamb.1 sequence for your data.
</p>
<p>Sometimes multiple optimal values(pairs) of lambda(s) can be found (see 'Value'). This is usually normal when the response is binary.
However, if the response is survival or continuous, you may want to check (1) if the sequence of lambda is too large
(i.e. all coefficients are shrunken to zero under all values of lambda) ; or (2) if the sequence is too small
(i.e. all coefficients are non-zero under all values of lambda). If neither, simply choose the value(pair) of lambda based on your preference.
</p>


<h3>Value</h3>

<p>an object of class &quot;cv.regnet&quot; is returned, which is a list with components:
</p>
<table>
<tr><td><code>lambda</code></td>
<td>
<p>the optimal value(s) of <code class="reqn">\lambda</code>. More than one value will be returned, if multiple lambdas have the cross-validated error =
min(cross-validated errors). If the network penalty is used, lambda contains optimal pair(s) of <code class="reqn">\lambda_{1}</code> and <code class="reqn">\lambda_{2}</code>.</p>
</td></tr>
<tr><td><code>mcvm</code></td>
<td>
<p>the cross-validated error of the optimal <code class="reqn">\lambda</code>. For binary response, the error is the misclassification rate.
For continuous response, mean squared error (MSE) is used. For survival response,
the MSE is used for non-robust methods, and the criterion for robust methods is the least absolute deviation (LAD).</p>
</td></tr>
<tr><td><code>CVM</code></td>
<td>
<p>a matrix of the mean cross-validated errors of all lambdas used in the fits. The row names of CVM are the values of <code class="reqn">\lambda_{1}</code>.
If the network penalty was used, the column names are the values of <code class="reqn">\lambda_{2}</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Ren, J., Du, Y., Li, S., Ma, S., Jiang,Y. and Wu, C. (2019). Robust network-based regularization
and variable selection for high dimensional genomics data in cancer prognosis.
<em>Genet. Epidemiol.</em>, 43:276-291 <a href="https://doi.org/10.1002/gepi.22194">doi:10.1002/gepi.22194</a>
</p>
<p>Ren, J., He, T., Li, Y., Liu, S., Du, Y., Jiang, Y., and Wu, C. (2017).
Network-based regularization for high dimensional SNP data in the case-control study of
Type 2 diabetes. <em>BMC Genetics</em>, 18(1):44 <a href="https://doi.org/10.1186/s12863-017-0495-5">doi:10.1186/s12863-017-0495-5</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regnet">regnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Binary response using network method
data(LogisticExample)
X = rgn.logi$X
Y = rgn.logi$Y
out = cv.regnet(X, Y, response="binary", penalty="network", folds=5, r = 4.5)
out$lambda
fit = regnet(X, Y, "binary", "network", out$lambda[1,1], out$lambda[1,2], r = 4.5)
index = which(rgn.logi$beta != 0)
pos = which(fit$coeff != 0)
tp = length(intersect(index, pos))
fp = length(pos) - tp
list(tp=tp, fp=fp)

## Binary response using MCP method
out = cv.regnet(X, Y, response="binary", penalty="mcp", folds=5, r = 4.5)
out$lambda
fit = regnet(X, Y, "binary", "mcp", out$lambda[1], r = 4.5)
index = which(rgn.logi$beta != 0)
pos = which(fit$coeff != 0)
tp = length(intersect(index, pos))
fp = length(pos) - tp
list(tp=tp, fp=fp)


</code></pre>

<hr>
<h2 id='plot.regnet'>plot a regnet object</h2><span id='topic+plot.regnet'></span>

<h3>Description</h3>

<p>plot the network structures of the identified genetic variants.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'regnet'
plot(x, subnetworks=FALSE, vsize=10, labelDist=2, minVertices=2, theta=5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.regnet_+3A_x">x</code></td>
<td>
<p>a regnet object.</p>
</td></tr>
<tr><td><code id="plot.regnet_+3A_subnetworks">subnetworks</code></td>
<td>
<p>whether to plot sub-networks</p>
</td></tr>
<tr><td><code id="plot.regnet_+3A_vsize">vsize</code></td>
<td>
<p>the size of the vertex</p>
</td></tr>
<tr><td><code id="plot.regnet_+3A_labeldist">labelDist</code></td>
<td>
<p>the distance of the label from the center of the vertex.</p>
</td></tr>
<tr><td><code id="plot.regnet_+3A_minvertices">minVertices</code></td>
<td>
<p>the minimum number of vertices a sub-network should contain.</p>
</td></tr>
<tr><td><code id="plot.regnet_+3A_theta">theta</code></td>
<td>
<p>the multiplier for the width of the edge. Specifically, <code class="reqn">edge.width=\theta\times adjacency</code>. The default is 5.</p>
</td></tr>
<tr><td><code id="plot.regnet_+3A_...">...</code></td>
<td>
<p>other plot arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function depends on the &quot;igraph&quot; package in generating the network graphs. It returns a (list of) igraph object(s),
on which users can do further modification on the network graphs.
</p>


<h3>Value</h3>

<p>an object of class &quot;igraph&quot; is returned in default.
When <em>subnetworks=TRUE</em>, a list of &quot;igraph&quot; objects (sub-networks) is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+regnet">regnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(ContExample)
X = rgn.tcga$X
Y = rgn.tcga$Y
clv = (1:2)
fit = regnet(X, Y, "continuous", "network", rgn.tcga$lamb1, rgn.tcga$lamb2, clv =clv, alpha.i=0.5)

plot(fit)
plot(fit, subnetworks = TRUE, vsize=20, labelDist = 3, theta = 5)


</code></pre>

<hr>
<h2 id='print.cv.regnet'>print a cv.regnet object</h2><span id='topic+print.cv.regnet'></span>

<h3>Description</h3>

<p>Print a summary of a cv.regnet object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cv.regnet'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.cv.regnet_+3A_x">x</code></td>
<td>
<p>a cv.regnet object.</p>
</td></tr>
<tr><td><code id="print.cv.regnet_+3A_digits">digits</code></td>
<td>
<p>significant digits in the printout.</p>
</td></tr>
<tr><td><code id="print.cv.regnet_+3A_...">...</code></td>
<td>
<p>other print arguments</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+cv.regnet">cv.regnet</a></code>
</p>

<hr>
<h2 id='print.regnet'>print a regnet object</h2><span id='topic+print.regnet'></span>

<h3>Description</h3>

<p>Print a summary of a regnet object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'regnet'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.regnet_+3A_x">x</code></td>
<td>
<p>a regnet object.</p>
</td></tr>
<tr><td><code id="print.regnet_+3A_digits">digits</code></td>
<td>
<p>significant digits in the printout.</p>
</td></tr>
<tr><td><code id="print.regnet_+3A_...">...</code></td>
<td>
<p>other print arguments</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+regnet">regnet</a></code>
</p>

<hr>
<h2 id='regnet'>fit a regression for given lambda with network-based regularization</h2><span id='topic+regnet'></span>

<h3>Description</h3>

<p>Network-based penalization regression for given values of <code class="reqn">\lambda_{1}</code> and <code class="reqn">\lambda_{2}</code>.
Typical usage is to have the cv.regnet function compute the optimal lambdas, then provide them to the
regnet function. Users could also use MCP or Lasso.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>regnet(
  X,
  Y,
  response = c("binary", "continuous", "survival"),
  penalty = c("network", "mcp", "lasso"),
  lamb.1 = NULL,
  lamb.2 = NULL,
  r = NULL,
  clv = NULL,
  initiation = NULL,
  alpha.i = 1,
  robust = FALSE,
  debugging = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="regnet_+3A_x">X</code></td>
<td>
<p>a matrix of predictors without intercept. Each row should be an observation vector. A column of 1 will be added to the X matrix
by the program as the intercept.</p>
</td></tr>
<tr><td><code id="regnet_+3A_y">Y</code></td>
<td>
<p>the response variable. For response=&quot;binary&quot;, Y should be a numeric vector with zeros and ones. For response=&quot;survival&quot;, Y should be a
two-column matrix with columns named 'time' and 'status'. The latter is a binary variable, with '1' indicating an event, and '0'
indicating censoring.</p>
</td></tr>
<tr><td><code id="regnet_+3A_response">response</code></td>
<td>
<p>the response type. regnet supports three types of response: &quot;binary&quot;, &quot;continuous&quot; and &quot;survival&quot;.</p>
</td></tr>
<tr><td><code id="regnet_+3A_penalty">penalty</code></td>
<td>
<p>the penalty type. regnet provides three choices for the penalty function: &quot;network&quot;, &quot;mcp&quot; and &quot;lasso&quot;.</p>
</td></tr>
<tr><td><code id="regnet_+3A_lamb.1">lamb.1</code></td>
<td>
<p>the tuning parameter <code class="reqn">\lambda_{1}</code> that imposes sparsity.</p>
</td></tr>
<tr><td><code id="regnet_+3A_lamb.2">lamb.2</code></td>
<td>
<p>the tuning parameter <code class="reqn">\lambda_{2}</code> that controls the smoothness among coefficient profiles. <code class="reqn">\lambda_{2}</code> is  needed
for network penalty.</p>
</td></tr>
<tr><td><code id="regnet_+3A_r">r</code></td>
<td>
<p>the regularization parameter in MCP. For binary response, r should be larger than 4.</p>
</td></tr>
<tr><td><code id="regnet_+3A_clv">clv</code></td>
<td>
<p>a value or a vector, indexing variables that are not subject to penalty. clv only works for continuous and survival responses
for now, and will be ignored for other types of responses.</p>
</td></tr>
<tr><td><code id="regnet_+3A_initiation">initiation</code></td>
<td>
<p>the method for initiating the coefficient vector. The default method is elastic-net.</p>
</td></tr>
<tr><td><code id="regnet_+3A_alpha.i">alpha.i</code></td>
<td>
<p>the elastic-net mixing parameter. The program can use the elastic-net for choosing initial values of
the coefficient vector. alpha.i is the elastic-net mixing parameter, with 0 <code class="reqn">\le</code> alpha.i <code class="reqn">\le</code> 1. alpha.i=1 is the
lasso penalty, and alpha.i=0 is the ridge penalty. If the user chooses a method other than elastic-net for initializing
coefficients, alpha.i will be ignored.</p>
</td></tr>
<tr><td><code id="regnet_+3A_robust">robust</code></td>
<td>
<p>a logical flag. Whether or not to use robust methods. Robust methods are available for survival and continuous response.</p>
</td></tr>
<tr><td><code id="regnet_+3A_debugging">debugging</code></td>
<td>
<p>a logical flag. If TRUE, extra information will be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The current version of regnet supports three types of responses: “binary”, &quot;continuous&quot; and “survival”.
</p>

<ul>
<li><p> regnet(…, response=&quot;binary&quot;, penalty=&quot;network&quot;) fits a network-based penalized logistic regression.
</p>
</li>
<li><p> regnet(…, response=&quot;continuous&quot;, penalty=&quot;network&quot;) fits a network-based least square regression.
</p>
</li>
<li><p> regnet(…, response=&quot;survival&quot;, penalty=&quot;network&quot;, robust=TRUE) fits a robust regularized AFT model using network penalty.
</p>
</li></ul>

<p>By default, regnet uses non-robust methods for all types of responses. To use robust methods, simply set robust=TRUE. It is recommended to use robust methods for survival response. Please see the references for more details about the models. Users could also use MCP or Lasso penalty.
</p>
<p>The coefficients are always estimated on a standardized X matrix. regnet standardizes each column of X to have unit variance
(using 1/n rather than 1/(n-1) formula). If the coefficients on the original scale are needed, the user can refit a standard model
using the subset of variables that have non-zero coefficients.
</p>


<h3>Value</h3>

<p>an object of class &quot;regnet&quot; is returned, which is a list with components:
</p>

<ul>
<li><p> coeff: a vector of estimated coefficients. Please note that, if there are variables not subject to penalty (indicated by clv),
the order of returned vector is c(Intercept, unpenalized coefficients of clv variables, penalized coefficients of other variables).
</p>
</li>
<li><p> Adj: a matrix of adjacency measures of the identified genetic variants. Identified genetic variants are those that have non-zero estimated coefficients.
</p>
</li></ul>



<h3>References</h3>

<p>Ren, J., He, T., Li, Y., Liu, S., Du, Y., Jiang, Y., and Wu, C. (2017).
Network-based regularization for high dimensional SNP data in the case-control study of
Type 2 diabetes. <em>BMC Genetics</em>, 18(1):44 <a href="https://doi.org/10.1186/s12863-017-0495-5">doi:10.1186/s12863-017-0495-5</a>
</p>
<p>Ren, J., Du, Y., Li, S., Ma, S., Jiang,Y. and Wu, C. (2019). Robust network-based regularization
and variable selection for high dimensional genomics data in cancer prognosis.
<em>Genet. Epidemiol.</em>, 43:276-291 <a href="https://doi.org/10.1002/gepi.22194">doi:10.1002/gepi.22194</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.regnet">cv.regnet</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Survival response
data(SurvExample)
X = rgn.surv$X
Y = rgn.surv$Y
clv = c(1:5) # variables 1 to 5 are clinical variables which we choose not to penalize.
penalty = "network"
fit = regnet(X, Y, "survival", penalty, rgn.surv$lamb1, rgn.surv$lamb2, clv=clv, robust=TRUE)
index = which(rgn.surv$beta != 0)
pos = which(fit$coeff != 0)
tp = length(intersect(index, pos))
fp = length(pos) - tp
list(tp=tp, fp=fp)

</code></pre>

<hr>
<h2 id='rgn'>Example datasets for demonstrating the features of regnet</h2><span id='topic+rgn'></span><span id='topic+rgn.logi'></span><span id='topic+rgn.surv'></span><span id='topic+rgn.tcga'></span><span id='topic+rgn.htr'></span>

<h3>Description</h3>

<p>Example datasets for demonstrating the features of regnet.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("LogisticExample")
data("SurvExample")
data("ContExample")
data("HeteroExample")
</code></pre>


<h3>Format</h3>

<p>&quot;LogisticExample&quot;, &quot;SurvExample&quot; and &quot;HeteroExample&quot; are simulated data. Each data includes three main components: X, Y, and beta; beta is a vector of the
true coefficients used to generate Y.
</p>
<p>&quot;ContExample&quot; is a subset of the skin cutaneous melanoma data from the Cancer Genome Atlas (TCGA). The response variable Y is
the log-transformed Breslow’s depth. X is a matrix of gene expression data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("LogisticExample")
lapply(rgn.logi, class)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
