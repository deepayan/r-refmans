<!DOCTYPE html><html><head><title>Help for package filehash</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="/home/deepayan/Rinstall/R-devel/lib/R/doc/html/R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {filehash}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#coerceDB1list'><p>Coerce a filehash database</p></a></li>
<li><a href='#coerceDB1RDS'><p>Coerce a filehash database</p></a></li>
<li><a href='#coercelist'><p>Coerce a filehash database</p></a></li>
<li><a href='#dbLoad'><p>Load a Database</p></a></li>
<li><a href='#dumpEnv'><p>Dump Environment</p></a></li>
<li><a href='#filehash-class'><p>Filehash Class</p></a></li>
<li><a href='#filehashDB1-class'><p>Filehash DB1 Class</p></a></li>
<li><a href='#filehashFormats'><p>List and register filehash formats</p></a></li>
<li><a href='#filehashOption'><p>Set Filehash Options</p></a></li>
<li><a href='#filehashRDS-class'><p>Filehash RDS Class</p></a></li>
<li><a href='#queue-class'><p>A Queue Class</p></a></li>
<li><a href='#registerFormatDB'><p>Register Database Format</p></a></li>
<li><a href='#stack-class'><p>Stack Class</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.4-5</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>digest, methods</td>
</tr>
<tr>
<td>Collate:</td>
<td>filehash.R filehash-DB1.R filehash-RDS.R coerce.R dump.R
hash.R queue.R stack.R zzz.R</td>
</tr>
<tr>
<td>Title:</td>
<td>Simple Key-Value Database</td>
</tr>
<tr>
<td>Author:</td>
<td>Roger D. Peng &lt;rdpeng@jhu.edu&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Roger D. Peng &lt;rdpeng@jhu.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements a simple key-value style database where character string keys
  are associated with data values that are stored on the disk. A simple interface is provided for inserting,
  retrieving, and deleting data from the database. Utilities are provided that allow 'filehash' databases to be
  treated much like environments and lists are already used in R. These utilities are provided to encourage
  interactive and exploratory analysis on large datasets. Three different file formats for representing the
  database are currently available and new formats can easily be incorporated by third parties for use in the
  'filehash' framework.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/rdpeng/filehash">https://github.com/rdpeng/filehash</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-09 18:18:57 UTC; rp34949</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-09 18:40:02 UTC</td>
</tr>
<tr>
<td>Built:</td>
<td>R 4.4.0; x86_64-pc-linux-gnu; 2024-03-18 06:07:34 UTC; unix</td>
</tr>
</table>
<hr>
<h2 id='coerceDB1list'>Coerce a filehash database</h2><span id='topic+coerceDB1list'></span><span id='topic+coerce+2CfilehashDB1+2Clist-method'></span>

<h3>Description</h3>

<p>Coerce a filehashDB1 database to a list object
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="coerceDB1list_+3A_from">from</code></td>
<td>
<p>a filehashDB1 database object</p>
</td></tr>
</table>

<hr>
<h2 id='coerceDB1RDS'>Coerce a filehash database</h2><span id='topic+coerceDB1RDS'></span><span id='topic+coerce+2CfilehashDB1+2CfilehashRDS-method'></span>

<h3>Description</h3>

<p>Coerce a filehashDB1 database to filehashRDS format
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="coerceDB1RDS_+3A_from">from</code></td>
<td>
<p>a filehashDB1 database object</p>
</td></tr>
</table>

<hr>
<h2 id='coercelist'>Coerce a filehash database</h2><span id='topic+coercelist'></span><span id='topic+coerce+2Cfilehash+2Clist-method'></span>

<h3>Description</h3>

<p>Coerce a filehash database to a list object
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="coercelist_+3A_from">from</code></td>
<td>
<p>a filehash database object</p>
</td></tr>
</table>

<hr>
<h2 id='dbLoad'>Load a Database</h2><span id='topic+dbLoad'></span><span id='topic+dbLoad+2Cfilehash-method'></span><span id='topic+dbLazyLoad'></span><span id='topic+dbLazyLoad+2Cfilehash-method'></span><span id='topic+db2env'></span>

<h3>Description</h3>

<p>Load entire database into an environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dbLoad(db, ...)

## S4 method for signature 'filehash'
dbLoad(db, env = parent.frame(2), keys = NULL, ...)

dbLazyLoad(db, ...)

## S4 method for signature 'filehash'
dbLazyLoad(db, env = parent.frame(2), keys = NULL, ...)

db2env(db)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dbLoad_+3A_db">db</code></td>
<td>
<p>filehash database object</p>
</td></tr>
<tr><td><code id="dbLoad_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
<tr><td><code id="dbLoad_+3A_env">env</code></td>
<td>
<p>environment into which objects should be loaded</p>
</td></tr>
<tr><td><code id="dbLoad_+3A_keys">keys</code></td>
<td>
<p>specific keys to be loaded (if NULL then all keys are loaded)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>dbLoad</code> loads objects in the database directly into the 
environment specified, like <code>load</code> does except with active bindings. 
<code>dbLoad</code> takes a second argument <code>env</code>, which is an 
environment, and the default for <code>env</code> is <code>parent.frame()</code>.
</p>
<p>The use of <code>makeActiveBinding</code> in <code>db2env</code> and 
<code>dbLoad</code> allows for potentially large databases to, at least 
conceptually, be used in R, as long as you don't need simultaneous access to 
all of the elements in the database.
</p>
<p><code>dbLazyLoad</code> loads objects in the database directly into the
environment specified, like <code>load</code> does except with promises. 
<code>dbLazyLoad</code> takes a second argument <code>env</code>, which is an 
environment, and the default for <code>env</code> is <code>parent.frame()</code>.
</p>
<p>With <code>dbLazyLoad</code> database objects are &quot;lazy-loaded&quot; into 
the environment. Promises to load the objects are created in the environment 
specified by <code>env</code>.  Upon first access, those objects are copied into 
the environment and will from then on reside in memory.  Changes to the
database will not be reflected in the object residing in the environment 
after first access.  Conversely, changes to the object in the environment 
will not be reflected in the database.  This type of loading is useful for 
read-only databases.
</p>
<p><code>db2env</code> loads the entire database <code>db</code> into an 
environment via calls to <code>makeActiveBinding</code>.  Therefore, the data 
themselves are not stored in the environment, but a function pointing to 
the data in the database is stored.  When an element of the environment is 
accessed, the function is called to retrieve the data from the database.  
If the data in the database is changed, the changes will be reflected in the 
environment.
</p>


<h3>Value</h3>

<p>dbLoad, dbLazyLoad: a character vector is returned (invisibly) containing the keys associated with the values loaded into the environment.
</p>
<p>db2env: environment containing database keys
</p>


<h3>Methods (by class)</h3>


<ul>
<li> <p><code>dbLoad(filehash)</code>: Method for filehash databases
</p>
</li>
<li> <p><code>dbLazyLoad(filehash)</code>: Method for filehash databases
</p>
</li></ul>


<h3>Functions</h3>


<ul>
<li> <p><code>dbLazyLoad()</code>: Lazy load a filehash database
</p>
</li>
<li> <p><code>db2env()</code>: Load active bindings into an environment and return the environment
</p>
</li></ul>


<h3>See Also</h3>

<p><code><a href="filehash.html#topic+dbLoad">dbLoad</a></code>, <code><a href="filehash.html#topic+dbLazyLoad">dbLazyLoad</a></code>
</p>

<hr>
<h2 id='dumpEnv'>Dump Environment</h2><span id='topic+dumpEnv'></span><span id='topic+dumpImage'></span><span id='topic+dumpObjects'></span><span id='topic+dumpDF'></span><span id='topic+dumpList'></span>

<h3>Description</h3>

<p>Dump an enviroment to a filehash database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dumpEnv(env, dbName)

dumpImage(dbName = "Rworkspace", type = NULL)

dumpObjects(
  ...,
  list = character(0),
  dbName,
  type = NULL,
  envir = parent.frame()
)

dumpDF(data, dbName = NULL, type = NULL)

dumpList(data, dbName = NULL, type = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dumpEnv_+3A_env">env</code></td>
<td>
<p>an environment</p>
</td></tr>
<tr><td><code id="dumpEnv_+3A_dbname">dbName</code></td>
<td>
<p>character, name of the filehash database</p>
</td></tr>
<tr><td><code id="dumpEnv_+3A_type">type</code></td>
<td>
<p>type of filehash database to create</p>
</td></tr>
<tr><td><code id="dumpEnv_+3A_...">...</code></td>
<td>
<p>R objects to be dumped to a filehash database</p>
</td></tr>
<tr><td><code id="dumpEnv_+3A_list">list</code></td>
<td>
<p>character vector of object names to be dumped</p>
</td></tr>
<tr><td><code id="dumpEnv_+3A_envir">envir</code></td>
<td>
<p>environment from which objects are dumped</p>
</td></tr>
<tr><td><code id="dumpEnv_+3A_data">data</code></td>
<td>
<p>a data frame</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>dumpEnv</code> function takes an environment and stores each element of the environment in a <code>filehash</code> database. Objects dumped to a database can later be loaded via <code>dbLoad</code> or can be accessed with <code>dbFetch</code>, <code>dbList</code>, etc. Alternatively, the <code>with</code> method can be used to evaluate code in the context of a database.  If a database with name <code>dbName</code> already exists, objects will be inserted into the existing database (and values for already-existing keys will be overwritten).
</p>
<p><code>dumpDF</code> is different in that each variable in the data frame is stored as a separate object in the database.  So each variable can be read from the database separately rather than having to load the entire data frame into memory.  <code>dumpList</code> works in a simlar way.
</p>


<h3>Value</h3>

<p>An object of class <code>"filehash"</code> is returned and a database is created.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>dumpImage()</code>: Dump the Global Environment (analogous to <code>save.image</code>)
</p>
</li>
<li> <p><code>dumpObjects()</code>: Dump named objects to a filehash database (analogous to <code>save</code>)
</p>
</li>
<li> <p><code>dumpDF()</code>: Dump data frame columns to a filehash database
</p>
</li>
<li> <p><code>dumpList()</code>: Dump elements of a list to a filehash database
</p>
</li></ul>

<hr>
<h2 id='filehash-class'>Filehash Class</h2><span id='topic+filehash-class'></span><span id='topic+show+2Cfilehash-method'></span><span id='topic+dbCreate+2CANY-method'></span><span id='topic+dbCreate'></span><span id='topic+dbInit+2CANY-method'></span><span id='topic+dbInit'></span><span id='topic+names+2Cfilehash-method'></span><span id='topic+length+2Cfilehash-method'></span><span id='topic+with+2Cfilehash-method'></span><span id='topic+lapply+2Cfilehash-method'></span><span id='topic+dbMultiFetch'></span><span id='topic+dbInsert'></span><span id='topic+dbFetch'></span><span id='topic+dbExists'></span><span id='topic+dbList'></span><span id='topic+dbDelete'></span><span id='topic+dbReorganize'></span><span id='topic+dbUnlink'></span><span id='topic++5B+5B+2Cfilehash+2Ccharacter+2Cmissing-method'></span><span id='topic++60+5B+5B+2Cfilehash+2Ccharacter+2Cmissing-method+60'></span><span id='topic++24+2Cfilehash-method'></span><span id='topic++5B+5B+3C-+2Cfilehash+2Ccharacter+2Cmissing-method'></span><span id='topic++24+3C-+2Cfilehash-method'></span><span id='topic++5B+2Cfilehash+2Ccharacter+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>These functions form the interface for a simple file-based key-value database (i.e. hash table).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'filehash'
show(object)

## S4 method for signature 'ANY'
dbCreate(db, type = NULL, ...)

## S4 method for signature 'ANY'
dbInit(db, type = NULL, ...)

## S4 method for signature 'filehash'
names(x)

## S4 method for signature 'filehash'
length(x)

## S4 method for signature 'filehash'
with(data, expr, ...)

## S4 method for signature 'filehash'
lapply(X, FUN, ..., keep.names = TRUE)

dbMultiFetch(db, key, ...)

dbInsert(db, key, value, ...)

dbFetch(db, key, ...)

dbExists(db, key, ...)

dbList(db, ...)

dbDelete(db, key, ...)

dbReorganize(db, ...)

dbUnlink(db, ...)

## S4 method for signature 'filehash,character,missing'
x[[i, j]]

## S4 method for signature 'filehash'
x$name

## S4 replacement method for signature 'filehash,character,missing'
x[[i, j]] &lt;- value

## S4 replacement method for signature 'filehash'
x$name &lt;- value

## S4 method for signature 'filehash,character,missing,missing'
x[i, j, drop]
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filehash-class_+3A_object">object</code></td>
<td>
<p>a filehash object</p>
</td></tr>
<tr><td><code id="filehash-class_+3A_db">db</code></td>
<td>
<p>a filehash object</p>
</td></tr>
<tr><td><code id="filehash-class_+3A_type">type</code></td>
<td>
<p>filehash database type</p>
</td></tr>
<tr><td><code id="filehash-class_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
<tr><td><code id="filehash-class_+3A_x">x</code></td>
<td>
<p>a filehash object</p>
</td></tr>
<tr><td><code id="filehash-class_+3A_data">data</code></td>
<td>
<p>a filehash object</p>
</td></tr>
<tr><td><code id="filehash-class_+3A_expr">expr</code></td>
<td>
<p>an R expression to be evaluated</p>
</td></tr>
<tr><td><code id="filehash-class_+3A_x">X</code></td>
<td>
<p>a filehash object</p>
</td></tr>
<tr><td><code id="filehash-class_+3A_fun">FUN</code></td>
<td>
<p>a function to be applied</p>
</td></tr>
<tr><td><code id="filehash-class_+3A_keep.names">keep.names</code></td>
<td>
<p>Should the key names be returned in the resulting list?</p>
</td></tr>
<tr><td><code id="filehash-class_+3A_key">key</code></td>
<td>
<p>a character vector indicating a key (or keys) to retreive</p>
</td></tr>
<tr><td><code id="filehash-class_+3A_value">value</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="filehash-class_+3A_i">i</code></td>
<td>
<p>a character index</p>
</td></tr>
<tr><td><code id="filehash-class_+3A_j">j</code></td>
<td>
<p>not used</p>
</td></tr>
<tr><td><code id="filehash-class_+3A_name">name</code></td>
<td>
<p>the name of the element in the filehash database</p>
</td></tr>
<tr><td><code id="filehash-class_+3A_drop">drop</code></td>
<td>
<p>should dimensions be dropped? (not used)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objects can be created by calls of the form <code>new("filehash", ...)</code>.
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>show(filehash)</code>: Print a filehash object
</p>
</li>
<li> <p><code>dbCreate(ANY)</code>: Create a filehash database
</p>
</li>
<li> <p><code>dbInit(ANY)</code>: Initialize an existing filehash database
</p>
</li>
<li> <p><code>names(filehash)</code>: Return the keys stored in a filehash database
</p>
</li>
<li> <p><code>length(filehash)</code>: Return the number of objects in a filehash database
</p>
</li>
<li> <p><code>with(filehash)</code>: Use a filehash database as an evaluation environment
</p>
</li>
<li> <p><code>lapply(filehash)</code>: Apply a function over the elements of a filehash database
</p>
</li>
<li> <p><code>x[[i</code>: Extract elements of a filehash database using character names
</p>
</li>
<li> <p><code>$</code>: Extract elements of a filehash database using character names
</p>
</li>
<li> <p><code>`[[`(x = filehash, i = character, j = missing) &lt;- value</code>: Replace elements of a filehash database
</p>
</li>
<li> <p><code>`$`(filehash) &lt;- value</code>: Replace elements of a filehash database
</p>
</li>
<li> <p><code>x[i</code>: Retrieve multiple elements of a filehash database
</p>
</li></ul>


<h3>Functions</h3>


<ul>
<li> <p><code>dbMultiFetch()</code>: Retrieve values associated with multiple keys (a list of those values is returned).
</p>
</li>
<li> <p><code>dbInsert()</code>: Insert a key-value pair into the database.  If that key already exists, its associated value is overwritten. For <code>"RDS"</code> type databases, there is a <code>safe</code> option (defaults to <code>TRUE</code>) which allows the user to insert objects somewhat more safely (objects should not be lost in the event of an interrupt).
</p>
</li>
<li> <p><code>dbFetch()</code>: Retrieve the value associated with a given key.
</p>
</li>
<li> <p><code>dbExists()</code>: Check to see if a key exists.
</p>
</li>
<li> <p><code>dbList()</code>: List all keys in the database.
</p>
</li>
<li> <p><code>dbDelete()</code>: The <code>dbDelete</code> function is for deleting elements, but for the <code>"DB1"</code> format all it does is remove the key from the lookup table. The actual data are still in the database (but inaccessible).  If you reinsert data for the same key, the new data are simply appended on to the end of the file.  Therefore, it's possible to have multiple copies of data lying around after a while, potentially making the database file big.  The <code>"RDS"</code> format does not have this problem.
</p>
</li>
<li> <p><code>dbReorganize()</code>: The <code>dbReorganize</code> function is there for the purpose of rewriting the database to remove all of the stale entries.  Basically, this function creates a new copy of the database and then overwrites the old copy.  This function has not been tested extensively and so should be considered <em>experimental</em>.  <code>dbReorganize</code> is not needed when using the <code>"RDS"</code> format.
</p>
</li>
<li> <p><code>dbUnlink()</code>: Delete an entire database from the disk.
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>, name of the database.</p>
</dd>
</dl>

<hr>
<h2 id='filehashDB1-class'>Filehash DB1 Class</h2><span id='topic+filehashDB1-class'></span><span id='topic+dbInsert+2CfilehashDB1+2Ccharacter-method'></span><span id='topic+dbFetch+2CfilehashDB1+2Ccharacter-method'></span><span id='topic+dbMultiFetch+2CfilehashDB1+2Ccharacter-method'></span><span id='topic+dbExists+2CfilehashDB1+2Ccharacter-method'></span><span id='topic+dbList+2CfilehashDB1-method'></span><span id='topic+dbDelete+2CfilehashDB1+2Ccharacter-method'></span><span id='topic+dbUnlink+2CfilehashDB1-method'></span><span id='topic+dbReorganize+2CfilehashDB1-method'></span>

<h3>Description</h3>

<p>An implementation of filehash databases using a single large file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'filehashDB1,character'
dbInsert(db, key, value, ...)

## S4 method for signature 'filehashDB1,character'
dbFetch(db, key, ...)

## S4 method for signature 'filehashDB1,character'
dbMultiFetch(db, key, ...)

## S4 method for signature 'filehashDB1,character'
dbExists(db, key, ...)

## S4 method for signature 'filehashDB1'
dbList(db, ...)

## S4 method for signature 'filehashDB1,character'
dbDelete(db, key, ...)

## S4 method for signature 'filehashDB1'
dbUnlink(db, ...)

## S4 method for signature 'filehashDB1'
dbReorganize(db, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filehashDB1-class_+3A_db">db</code></td>
<td>
<p>a filehashDB1 object</p>
</td></tr>
<tr><td><code id="filehashDB1-class_+3A_key">key</code></td>
<td>
<p>character, the name of an R object in the database</p>
</td></tr>
<tr><td><code id="filehashDB1-class_+3A_value">value</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="filehashDB1-class_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>dbMultiFetch</code>, <code>key</code> is a character vector of keys.
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>dbInsert(db = filehashDB1, key = character)</code>: Insert an R object into a filehashDB1 database
</p>
</li>
<li> <p><code>dbFetch(db = filehashDB1, key = character)</code>: Retrieve an object from a filehash DB1 database
</p>
</li>
<li> <p><code>dbMultiFetch(db = filehashDB1, key = character)</code>: Retrieve multiple objects from a filehash DB1 database
</p>
</li>
<li> <p><code>dbExists(db = filehashDB1, key = character)</code>: Determine if a key exists in a filehash DB1 database
</p>
</li>
<li> <p><code>dbList(filehashDB1)</code>: Return a character vector containing all keys in a database
</p>
</li>
<li> <p><code>dbDelete(db = filehashDB1, key = character)</code>: Delete a key and it's corresponding object from a filehashDB1 database
</p>
</li>
<li> <p><code>dbUnlink(filehashDB1)</code>: Delete an entire filehashDB1 database
</p>
</li>
<li> <p><code>dbReorganize(filehashDB1)</code>: Reorganize and compactify a filehahsDB1 database
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>datafile</code></dt><dd><p>full path to the database file (filehashDB1 only)</p>
</dd>
<dt><code>meta</code></dt><dd><p>list containing an environment for database metadata (filehashDB1 only)</p>
</dd>
</dl>

<hr>
<h2 id='filehashFormats'>List and register filehash formats</h2><span id='topic+filehashFormats'></span>

<h3>Description</h3>

<p>List and register filehash backend database formats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filehashFormats(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filehashFormats_+3A_...">...</code></td>
<td>
<p>list of functions for registering a new database format</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>filehashFormats</code> can be used to register new filehash backend database formats.  <code>filehashFormats</code> called with no arguments lists information on available formats
</p>


<h3>Value</h3>

<p>A list containing information on the available filehash formats
</p>

<hr>
<h2 id='filehashOption'>Set Filehash Options</h2><span id='topic+filehashOption'></span>

<h3>Description</h3>

<p>Set global filehash options
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filehashOption(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filehashOption_+3A_...">...</code></td>
<td>
<p>name-value pairs for options</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, the only option that can be set is the default database type (<code>defaultType</code>) which can be &quot;DB1&quot;, &quot;RDS&quot; or &quot;DB&quot;.
</p>


<h3>Value</h3>

<p><code>filehashOptions</code> returns a list of current settings for all options.
</p>

<hr>
<h2 id='filehashRDS-class'>Filehash RDS Class</h2><span id='topic+filehashRDS-class'></span><span id='topic+dbInsert+2CfilehashRDS+2Ccharacter-method'></span><span id='topic+dbFetch+2CfilehashRDS+2Ccharacter-method'></span><span id='topic+dbMultiFetch+2CfilehashRDS+2Ccharacter-method'></span><span id='topic+dbExists+2CfilehashRDS+2Ccharacter-method'></span><span id='topic+dbList+2CfilehashRDS-method'></span><span id='topic+dbDelete+2CfilehashRDS+2Ccharacter-method'></span><span id='topic+dbUnlink+2CfilehashRDS-method'></span>

<h3>Description</h3>

<p>An implementation of filehash databases using diretories and separate files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'filehashRDS,character'
dbInsert(db, key, value, safe = TRUE, ...)

## S4 method for signature 'filehashRDS,character'
dbFetch(db, key, ...)

## S4 method for signature 'filehashRDS,character'
dbMultiFetch(db, key, ...)

## S4 method for signature 'filehashRDS,character'
dbExists(db, key, ...)

## S4 method for signature 'filehashRDS'
dbList(db, ...)

## S4 method for signature 'filehashRDS,character'
dbDelete(db, key, ...)

## S4 method for signature 'filehashRDS'
dbUnlink(db, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="filehashRDS-class_+3A_db">db</code></td>
<td>
<p>a filehashRDS object</p>
</td></tr>
<tr><td><code id="filehashRDS-class_+3A_key">key</code></td>
<td>
<p>character, the name of an R object</p>
</td></tr>
<tr><td><code id="filehashRDS-class_+3A_value">value</code></td>
<td>
<p>an R object</p>
</td></tr>
<tr><td><code id="filehashRDS-class_+3A_safe">safe</code></td>
<td>
<p>Should the operation be done safely?</p>
</td></tr>
<tr><td><code id="filehashRDS-class_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When <code>safe = TRUE</code> in <code>dbInsert</code>, objects are written to a temp file before replacing any existing objects. This way, if the operation is interrupted, the original data are not corrupted.
</p>
<p>For <code>dbMultiFetch</code>, <code>key</code> is a character vector of keys.
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>dbInsert(db = filehashRDS, key = character)</code>: Insert an R object into a filehashRDS database
</p>
</li>
<li> <p><code>dbFetch(db = filehashRDS, key = character)</code>: Retrieve a value from a filehashRDS database
</p>
</li>
<li> <p><code>dbMultiFetch(db = filehashRDS, key = character)</code>: Retrieve multiple objects from a filehashRDS database
</p>
</li>
<li> <p><code>dbExists(db = filehashRDS, key = character)</code>: Determine if a key exists in a filehashRDS database
</p>
</li>
<li> <p><code>dbList(filehashRDS)</code>: Return a character vector of all key stored in a database
</p>
</li>
<li> <p><code>dbDelete(db = filehashRDS, key = character)</code>: Delete a key and its corresponding object from a filehashRDS database
</p>
</li>
<li> <p><code>dbUnlink(filehashRDS)</code>: Delete an entire filehashRDS database
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>dir</code></dt><dd><p>Directory where files are stored (filehashRDS only)</p>
</dd>
</dl>

<hr>
<h2 id='queue-class'>A Queue Class</h2><span id='topic+queue-class'></span><span id='topic+createQ'></span><span id='topic+initQ'></span><span id='topic+pop'></span><span id='topic+push'></span><span id='topic+isEmpty'></span><span id='topic+top'></span><span id='topic+show+2Cqueue-method'></span><span id='topic+push+2Cqueue-method'></span><span id='topic+isEmpty+2Cqueue-method'></span><span id='topic+top+2Cqueue-method'></span><span id='topic+pop+2Cqueue-method'></span>

<h3>Description</h3>

<p>A queue implementation using a <code>filehash</code> database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createQ(filename)

initQ(filename)

pop(db, ...)

push(db, val, ...)

isEmpty(db, ...)

top(db, ...)

## S4 method for signature 'queue'
show(object)

## S4 method for signature 'queue'
push(db, val, ...)

## S4 method for signature 'queue'
isEmpty(db)

## S4 method for signature 'queue'
top(db, ...)

## S4 method for signature 'queue'
pop(db, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="queue-class_+3A_filename">filename</code></td>
<td>
<p>name of queue file</p>
</td></tr>
<tr><td><code id="queue-class_+3A_db">db</code></td>
<td>
<p>a queue object</p>
</td></tr>
<tr><td><code id="queue-class_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
<tr><td><code id="queue-class_+3A_val">val</code></td>
<td>
<p>an R object to be added to the tail queue</p>
</td></tr>
<tr><td><code id="queue-class_+3A_object">object</code></td>
<td>
<p>a queue object</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objects can be created by calls of the form <code>new("queue", ...)</code> or by calling <code>createQ</code>.  Existing queues can be initialized with <code>initQ</code>.
</p>


<h3>Value</h3>

<p><code>createQ</code> and <code>initQ</code> return a <code>queue</code> object
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>show(queue)</code>: Print a queue object
</p>
</li>
<li> <p><code>push(queue)</code>: adds an element to the tail (&quot;bottom&quot;) of the queue
</p>
</li>
<li> <p><code>isEmpty(queue)</code>: returns <code>TRUE</code>/<code>FALSE</code> depending on whether there are elements in the queue.
</p>
</li>
<li> <p><code>top(queue)</code>: returns the value of the &quot;top&quot; (i.e. head) of the queue; an error is signaled if the queue is empty
</p>
</li>
<li> <p><code>pop(queue)</code>: returns the value of the &quot;top&quot; (i.e. head) of the queue and subsequently removes that element from the queue; an error is signaled if the queue is empty
</p>
</li></ul>


<h3>Functions</h3>


<ul>
<li> <p><code>createQ()</code>: Create a file-based queue object
</p>
</li>
<li> <p><code>initQ()</code>: Intialize an existing queue object
</p>
</li>
<li> <p><code>pop()</code>: Return (and remove) the top element of a queue
</p>
</li>
<li> <p><code>push()</code>: Push an R object on to the tail of a queue
</p>
</li>
<li> <p><code>isEmpty()</code>: Check if a queue is empty or not
</p>
</li>
<li> <p><code>top()</code>: Return the top of the queue
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>queue</code></dt><dd><p>Object of class <code>"filehashDB1"</code></p>
</dd>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>: the name of the queue (default is the file name in which the queue data are stored)</p>
</dd>
</dl>

<hr>
<h2 id='registerFormatDB'>Register Database Format</h2><span id='topic+registerFormatDB'></span>

<h3>Description</h3>

<p>Register Database Format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>registerFormatDB(name, funlist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="registerFormatDB_+3A_name">name</code></td>
<td>
<p>character, name of database format</p>
</td></tr>
<tr><td><code id="registerFormatDB_+3A_funlist">funlist</code></td>
<td>
<p>list of functions for creating and initializing a database format</p>
</td></tr>
</table>

<hr>
<h2 id='stack-class'>Stack Class</h2><span id='topic+stack-class'></span><span id='topic+show+2Cstack-method'></span><span id='topic+createS'></span><span id='topic+initS'></span><span id='topic+push+2Cstack-method'></span><span id='topic+mpush'></span><span id='topic+mpush+2Cstack-method'></span><span id='topic+isEmpty+2Cstack-method'></span><span id='topic+top+2Cstack-method'></span><span id='topic+pop+2Cstack-method'></span>

<h3>Description</h3>

<p>A stack implementation using a <code>filehash</code> database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'stack'
show(object)

createS(filename)

initS(filename)

## S4 method for signature 'stack'
push(db, val, ...)

mpush(db, vals, ...)

## S4 method for signature 'stack'
mpush(db, vals, ...)

## S4 method for signature 'stack'
isEmpty(db, ...)

## S4 method for signature 'stack'
top(db, ...)

## S4 method for signature 'stack'
pop(db, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stack-class_+3A_object">object</code></td>
<td>
<p>a stack object</p>
</td></tr>
<tr><td><code id="stack-class_+3A_filename">filename</code></td>
<td>
<p>name of file where stack is stored</p>
</td></tr>
<tr><td><code id="stack-class_+3A_db">db</code></td>
<td>
<p>a stack object</p>
</td></tr>
<tr><td><code id="stack-class_+3A_val">val</code></td>
<td>
<p>an R object to be added to the stack</p>
</td></tr>
<tr><td><code id="stack-class_+3A_...">...</code></td>
<td>
<p>arguments passed to other methods</p>
</td></tr>
<tr><td><code id="stack-class_+3A_vals">vals</code></td>
<td>
<p>a list of R objects</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objects can be created by calls of the form <code>new("stack", ...)</code> or by calling <code>createS</code>.  Existing queues can be initialized with <code>initS</code>.
</p>


<h3>Value</h3>

<p>a stack object
</p>


<h3>Methods (by generic)</h3>


<ul>
<li> <p><code>show(stack)</code>: Print a stack object.
</p>
</li>
<li> <p><code>push(stack)</code>: Push an object on to the stack
</p>
</li>
<li> <p><code>mpush(stack)</code>: Push a list of R objects on to the stack
</p>
</li>
<li> <p><code>isEmpty(stack)</code>: Indicate whether the stack is empty or not
</p>
</li>
<li> <p><code>top(stack)</code>: Return the top element of the stack
</p>
</li>
<li> <p><code>pop(stack)</code>: Return the top element of the stack and remove that element from the stack
</p>
</li></ul>


<h3>Functions</h3>


<ul>
<li> <p><code>createS()</code>: Create a filehash Stack
</p>
</li>
<li> <p><code>initS()</code>: Initialize and existing filehash stack
</p>
</li>
<li> <p><code>mpush()</code>: Push multiple R objects on to a stack
</p>
</li></ul>


<h3>Slots</h3>


<dl>
<dt><code>stack</code></dt><dd><p>Object of class <code>"filehashDB1"</code></p>
</dd>
<dt><code>name</code></dt><dd><p>Object of class <code>"character"</code>: the name of the stack (default is the file name in which the stack data are stored)</p>
</dd>
</dl>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
