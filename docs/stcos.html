<!DOCTYPE html><html><head><title>Help for package stcos</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {stcos}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#stcos'><p>stcos: Space-Time Change of Support</p></a></li>
<li><a href='#acs_sf'><p>Shapes and ACS estimates for Boone County, MO.</p></a></li>
<li><a href='#adjacency_matrix'><p>Sparse adjacency matrix between two sets of areas.</p></a></li>
<li><a href='#areal_spacetime_bisquare'><p>Areal Space-Time Bisquare Basis</p></a></li>
<li><a href='#areal_spatial_bisquare'><p>Areal Spatial Bisquare Basis</p></a></li>
<li><a href='#autocov_VAR1'><p>Compute the autocovariance matrix for a VAR(1) process.</p></a></li>
<li><a href='#car_precision'><p>CAR Precision Matrix</p></a></li>
<li><a href='#columbia_neighbs'><p>City of Columbia neighborhoods.</p></a></li>
<li><a href='#Covariance+20Approximation'><p>Best Approximation to Covariance Structure</p></a></li>
<li><a href='#DIC'><p>Deviance Information Criterion</p></a></li>
<li><a href='#gibbs_stcos'><p>Gibbs Sampler for STCOS Model</p></a></li>
<li><a href='#licols'><p>licols</p></a></li>
<li><a href='#mle_stcos'><p>MLE for STCOS Model</p></a></li>
<li><a href='#overlap_matrix'><p>Matrix of overlaps between two sets of areas.</p></a></li>
<li><a href='#prepare_stcos_demo'><p>Prepare Demo Data for STCOS Model</p></a></li>
<li><a href='#rdomain'><p>Draw uniformly distributed points from a set of areas</p></a></li>
<li><a href='#spacetime_bisquare'><p>Space-Time Bisquare Basis</p></a></li>
<li><a href='#spatial_bisquare'><p>Spatial Bisquare Basis</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Space-Time Change of Support</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.1</td>
</tr>
<tr>
<td>Author:</td>
<td>Andrew M. Raim [aut, cre],
  Scott H. Holan [aut, res],
  Jonathan R. Bradley [aut, res],
  Christopher K. Wikle [aut, res]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Andrew M. Raim &lt;andrew.raim@gmail.com&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/holans/ST-COS">https://github.com/holans/ST-COS</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Spatio-temporal change of support (STCOS) methods are designed for statistical inference
	on geographic and time domains which differ from those on which the data were observed. In
	particular, a parsimonious class of STCOS models supporting Gaussian outcomes was introduced
	by Bradley, Wikle, and Holan &lt;<a href="https://doi.org/10.1002%2Fsta4.94">doi:10.1002/sta4.94</a>&gt;. The 'stcos' package contains tools which
	facilitate use of STCOS models.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3), Rcpp, Matrix, sf, dplyr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-21 12:33:10 UTC; araim</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-21 14:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='stcos'>stcos: Space-Time Change of Support</h2><span id='topic+stcos'></span><span id='topic+stcos-package'></span>

<h3>Description</h3>

<p>An R Package for Space-Time Change of Support (STCOS) modeling.
</p>


<h3>Details</h3>

<p>Supports building and running STCOS and related models. A guide
on package use is given in &lt;arXiv:1904.12092&gt;.
</p>


<h3>References</h3>

<p>Jonathan R. Bradley, Christopher K. Wikle, and Scott H. Holan (2015).
Spatio-temporal change of support with application to American Community
Survey multi-year period estimates. STAT 4 pp.255-270.
<a href="https://doi.org/10.1002/sta4.94">doi:10.1002/sta4.94</a>.
</p>
<p>Andrew M. Raim, Scott H. Holan, Jonathan R. Bradley, and Christopher K.
Wikle (2017). A model selection study for spatio-temporal change of
support. In JSM Proceedings, Government Statistics Section. Alexandria,
VA: American Statistical Association, pp.1524-1540.
</p>
<p>Andrew M. Raim, Scott H. Holan, Jonathan R. Bradley, and Christopher K.
Wikle (2020+). Spatio-Temporal Change of Support Modeling with R.
<a href="https://arxiv.org/abs/1904.12092">https://arxiv.org/abs/1904.12092</a>.
</p>

<hr>
<h2 id='acs_sf'>Shapes and ACS estimates for Boone County, MO.</h2><span id='topic+acs_sf'></span><span id='topic+acs5_2013'></span><span id='topic+acs5_2014'></span><span id='topic+acs5_2015'></span><span id='topic+acs5_2016'></span><span id='topic+acs5_2017'></span>

<h3>Description</h3>

<p>An <code>sf</code> object with ACS estimates for:
</p>

<ul>
<li><p> Boone County, Missouri
</p>
</li>
<li><p> Table B19013
</p>
</li>
<li><p> Block group level geography
</p>
</li>
<li><p> Years 2013 - 2017
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>acs5_2013

acs5_2014

acs5_2015

acs5_2016

acs5_2017
</code></pre>


<h3>Format</h3>

<p><code>sf</code> objects.
</p>
<p>An object of class <code>sf</code> (inherits from <code>data.frame</code>) with 87 rows and 9 columns.
</p>
<p>An object of class <code>sf</code> (inherits from <code>data.frame</code>) with 87 rows and 9 columns.
</p>
<p>An object of class <code>sf</code> (inherits from <code>data.frame</code>) with 85 rows and 9 columns.
</p>
<p>An object of class <code>sf</code> (inherits from <code>data.frame</code>) with 87 rows and 9 columns.
</p>
<p>An object of class <code>sf</code> (inherits from <code>data.frame</code>) with 87 rows and 9 columns.
</p>


<h3>Details</h3>

<p>This dataset was assembled using shapefiles from the <code>tigris</code> package
and ACS estimates from the American FactFinder website on 2/28/2019.
See <code>data-prep-aff.R</code> in the Columbia example code for details.
American FactFinder has since been deprecated, and similar data are
available at <a href="http://data.census.gov">http://data.census.gov</a>.
</p>

<hr>
<h2 id='adjacency_matrix'>Sparse adjacency matrix between two sets of areas.</h2><span id='topic+adjacency_matrix'></span>

<h3>Description</h3>

<p>A convenience function to convert output from <code>sf::st_touches</code>
to a sparse matrix as defined in the <code>Matrix</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjacency_matrix(dom)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjacency_matrix_+3A_dom">dom</code></td>
<td>
<p>An <code>sf</code> object representing a domain of areal units.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a matrix <code>A</code> whose (i,j)th entry contains a 1 if
areal units <code>dom[i,]</code> and <code>dom[j,]</code> are adjacent;
0 otherwise.
</p>


<h3>Value</h3>

<p>An adjacency matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("acs_sf")
dom = acs5_2013[1:4,]
A = adjacency_matrix(dom)

</code></pre>

<hr>
<h2 id='areal_spacetime_bisquare'>Areal Space-Time Bisquare Basis</h2><span id='topic+areal_spacetime_bisquare'></span>

<h3>Description</h3>

<p>Space-Time bisquare basis on areal data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>areal_spacetime_bisquare(dom, period, knots, w_s, w_t, control = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="areal_spacetime_bisquare_+3A_dom">dom</code></td>
<td>
<p>An <code>sf</code> or <code>sfc</code> object with areas
<code class="reqn">A_1, \ldots, A_n</code> to evaluate.</p>
</td></tr>
<tr><td><code id="areal_spacetime_bisquare_+3A_period">period</code></td>
<td>
<p>A numeric vector of time periods <code class="reqn">v_1, \ldots, v_m</code>
to evaluate for each area.</p>
</td></tr>
<tr><td><code id="areal_spacetime_bisquare_+3A_knots">knots</code></td>
<td>
<p>Spatio-temporal knots
<code class="reqn">(\bm{c}_1,g_1), \ldots, (\bm{c}_r,g_r)</code>
for the basis. See &quot;Details&quot;.</p>
</td></tr>
<tr><td><code id="areal_spacetime_bisquare_+3A_w_s">w_s</code></td>
<td>
<p>Spatial radius for the basis.</p>
</td></tr>
<tr><td><code id="areal_spacetime_bisquare_+3A_w_t">w_t</code></td>
<td>
<p>Temporal radius for the basis.</p>
</td></tr>
<tr><td><code id="areal_spacetime_bisquare_+3A_control">control</code></td>
<td>
<p>A <code>list</code> of control arguments. See &quot;Details&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Notes about arguments:
</p>

<ul>
<li> <p><code>knots</code> may be provided as either an <code>sf</code> or <code>sfc</code> object, or as a
matrix of points.
</p>
</li>
<li><p> If an <code>sf</code> or <code>sfc</code> object is provided for <code>knots</code>, <code class="reqn">r</code>
three-dimensional <code>POINT</code> entries are expected in <code>st_geometry(knots)</code>.
Otherwise, <code>knots</code> will be interpreted as an <code class="reqn">r \times 3</code> numeric matrix.
</p>
</li>
<li><p> If <code>knots</code> is an <code>sf</code> or <code>sfc</code> object, it is checked
to ensure the coordinate system matches <code>dom</code>.
</p>
</li></ul>

<p>For each area <code class="reqn">A</code> in the given domain, and time period
<code class="reqn">\bm{v} = (v_1, \ldots, v_m)</code> compute the basis
functions
</p>
<p style="text-align: center;"><code class="reqn">
\psi_j^{(m)}(A, \bm{v}) = \frac{1}{m} \sum_{k=1}^m \frac{1}{|A|} \int_A \psi_j(\bm{u},v_k) d\bm{u},
</code>
</p>

<p>for <code class="reqn">j = 1, \ldots, r</code>. Here, <code class="reqn">\varphi_j{(\bm{u},v)}</code>
represent <a href="#topic+spacetime_bisquare">spacetime_bisquare</a> basis functions defined at the point
level using <code class="reqn">\bm{c}_j</code>, <code class="reqn">g_j</code>, <code class="reqn">w_s</code>, and <code class="reqn">w_t</code>.
</p>
<p>The basis requires an integration which may be computed using one
of two methods. The <code>mc</code> method uses a Monte Carlo approximation
</p>
<p style="text-align: center;"><code class="reqn">
\psi_j^{(m)}(A, \bm{v}) \approx \frac{1}{m} \sum_{k=1}^m 
\frac{1}{Q} \sum_{q=1}^Q \psi_j(\bm{u}_q, v_k),
</code>
</p>

<p>based on a random sample of locations <code class="reqn">\bm{u}_1, \ldots, \bm{u}_Q</code> from
a uniform distribution on area <code class="reqn">A</code>. The <code>rect</code> method uses
a simple quadrature approximation
</p>
<p style="text-align: center;"><code class="reqn">
\psi_j^{(m)}(A, \bm{v}) \approx \frac{1}{m} \sum_{k=1}^m 
\frac{1}{|A|}  \sum_{a=1}^{n_x} \sum_{b=1}^{n_y} \psi_j(\bm{u}_{ab}, v_k)
I(\bm{u}_{ab} \in A) \Delta_x \Delta_y.
</code>
</p>

<p>Here, the bounding box <code>st_bbox(A)</code> is divided evenly into a grid of
<code class="reqn">n_x \times n_y</code> rectangles, each of size <code class="reqn">\Delta_x \times \Delta_y</code>.
Each <code class="reqn">\bm{u}_{ab} = (u_a, u_b)</code> is a point from the <code class="reqn">(a,b)</code>th
rectangle, for <code class="reqn">a = 1, \ldots, n_x</code> and <code class="reqn">b = 1, \ldots, n_y</code>.
</p>
<p>Due to the treatment of <code class="reqn">A_i</code> and <code class="reqn">\bm{c}_j</code> as objects in a
Euclidean space, this basis is more suitable for coordinates from a map
projection than coordinates based on a globe representation.
</p>
<p>The <code>control</code> argument is a list which may provide any of the following:
</p>

<ul>
<li> <p><code>method</code> specifies computation method: <code>mc</code> or <code>rect</code>.
Default is <code>mc</code>.
</p>
</li>
<li> <p><code>mc_reps</code> is number of repetitions to use for <code>mc</code>.
Default is 1000.
</p>
</li>
<li> <p><code>nx</code> is number of x-axis points to use for <code>rect</code>
method. Default is 50.
</p>
</li>
<li> <p><code>ny</code> is number of y-axis points to use for <code>rect</code>
method. Default is 50.
</p>
</li>
<li> <p><code>report_period</code> is an integer; print a message with progress each
time this many areas are processed. Default is <code>Inf</code> so that message
is suppressed.
</p>
</li>
<li> <p><code>verbose</code> is a logical; if <code>TRUE</code> print descriptive
messages about the computation. Default is <code>FALSE</code>.
</p>
</li>
<li> <p><code>mc_sampling_factor</code> is a positive number; an oversampling factor
used to compute <code>blocksize</code> in the <a href="#topic+rdomain">rdomain</a> function. I.e.,
<code>blocksize = ceiling(mc_sampling_factor * mc_reps)</code>. Default
is 1.2.
</p>
</li></ul>



<h3>Value</h3>

<p>A sparse <code class="reqn">n \times r</code> matrix whose <code class="reqn">i</code>th row
is
<code class="reqn">
\bm{s}_i^\top =
\Big(
\psi_1^{(m)}(A_i), \ldots, \psi_r^{(m)}(A_i)
\Big).
</code>
</p>


<h3>See Also</h3>

<p>Other bisquare: 
<code><a href="#topic+areal_spatial_bisquare">areal_spatial_bisquare</a>()</code>,
<code><a href="#topic+spacetime_bisquare">spacetime_bisquare</a>()</code>,
<code><a href="#topic+spatial_bisquare">spatial_bisquare</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)

# Create knot points
seq_x = seq(0, 1, length.out = 3)
seq_y = seq(0, 1, length.out = 3)
seq_t = seq(0, 1, length.out = 3)
knots = expand.grid(x = seq_x, y = seq_y, t = seq_t)
knots_sf = st_as_sf(knots, coords = c("x","y","t"), crs = NA, dim = "XYM", agr = "constant")

# Create a simple domain (of rectangles) to evaluate
shape1 = matrix(c(0.0,0.0, 0.5,0.0, 0.5,0.5, 0.0,0.5, 0.0,0.0), ncol=2, byrow=TRUE)
shape2 = shape1 + cbind(rep(0.5,5), rep(0.0,5))
shape3 = shape1 + cbind(rep(0.0,5), rep(0.5,5))
shape4 = shape1 + cbind(rep(0.5,5), rep(0.5,5))
sfc = st_sfc(
   st_polygon(list(shape1)),
   st_polygon(list(shape2)),
   st_polygon(list(shape3)),
   st_polygon(list(shape4))
)
dom = st_sf(data.frame(geoid = 1:length(sfc), geom = sfc))

rad = 0.5
period = c(0.4, 0.7)
areal_spacetime_bisquare(dom, period, knots, w = rad, w_t = 1)
areal_spacetime_bisquare(dom, period, knots_sf, w_s = rad, w_t = 1)

# Plot the (spatial) knots and the (spatial) domain at which we evaluated
# the basis.
plot(knots[,1], knots[,2], pch = 4, cex = 1.5, col = "red")
plot(dom[,1], col = NA, add = TRUE)

# Draw a circle representing the basis' radius around one of the knot points
tseq = seq(0, 2*pi, length=100) 
coords = cbind(rad * cos(tseq) + seq_x[2], rad * sin(tseq) + seq_y[2])
lines(coords, col = "red")

</code></pre>

<hr>
<h2 id='areal_spatial_bisquare'>Areal Spatial Bisquare Basis</h2><span id='topic+areal_spatial_bisquare'></span>

<h3>Description</h3>

<p>Spatial bisquare basis on areal data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>areal_spatial_bisquare(dom, knots, w, control = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="areal_spatial_bisquare_+3A_dom">dom</code></td>
<td>
<p>An <code>sf</code> or <code>sfc</code> object with areas
<code class="reqn">A_1, \ldots, A_n</code> to evaluate.</p>
</td></tr>
<tr><td><code id="areal_spatial_bisquare_+3A_knots">knots</code></td>
<td>
<p>Knots <code class="reqn">\bm{c}_1, \ldots, \bm{c}_r</code> for the basis.
See &quot;Details&quot;.</p>
</td></tr>
<tr><td><code id="areal_spatial_bisquare_+3A_w">w</code></td>
<td>
<p>Radius for the basis.</p>
</td></tr>
<tr><td><code id="areal_spatial_bisquare_+3A_control">control</code></td>
<td>
<p>A <code>list</code> of control arguments. See &quot;Details&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Notes about arguments:
</p>

<ul>
<li> <p><code>knots</code> may be provided as either an <code>sf</code> or <code>sfc</code> object, or as a
matrix of points.
</p>
</li>
<li><p> If an <code>sf</code> or <code>sfc</code> object is provided for <code>knots</code>, <code class="reqn">r</code>
two-dimensional <code>POINT</code> entries are expected in <code>st_geometry(knots)</code>.
Otherwise, <code>knots</code> will be interpreted as an <code class="reqn">r \times 2</code> numeric matrix.
</p>
</li>
<li><p> If <code>knots</code> is an <code>sf</code> or <code>sfc</code> object, it is checked
to ensure the coordinate system matches <code>dom</code>.
</p>
</li></ul>

<p>For each area <code class="reqn">A</code> in the given domain, compute an the basis functions
</p>
<p style="text-align: center;"><code class="reqn">
\bar{\varphi}_j(A) = \frac{1}{|A|} \int_A \varphi_j(\bm{u}) d\bm{u}
</code>
</p>

<p>for <code class="reqn">j = 1, \ldots, r</code>. Here, <code class="reqn">\varphi_j(\bm{u})</code> represent
<a href="#topic+spatial_bisquare">spatial_bisquare</a> basis functions defined at the point level
using <code class="reqn">\bm{c}_j</code> and <code class="reqn">w</code>.
</p>
<p>The basis requires an integration which may be computed using one
of two methods. The <code>mc</code> method uses
</p>
<p style="text-align: center;"><code class="reqn">
\bar{\varphi}_j(A) \approx
\frac{1}{Q} \sum_{q=1}^Q \varphi_j(\bm{u}_q),
</code>
</p>

<p>based on a random sample of locations <code class="reqn">\bm{u}_1, \ldots, \bm{u}_Q</code> from
a uniform distribution on area <code class="reqn">A</code>. The <code>rect</code> method uses
a simple quadrature approximation
</p>
<p style="text-align: center;"><code class="reqn">
\bar{\varphi}_j(A) \approx
\frac{1}{|A|}  \sum_{a=1}^{n_x} \sum_{b=1}^{n_y} \varphi_j(\bm{u}_{ab})
I(\bm{u}_{ab} \in A) \Delta_x \Delta_y.
</code>
</p>

<p>Here, the bounding box <code>st_bbox(A)</code> is divided evenly into a grid of
<code class="reqn">n_x \times n_y</code> rectangles, each of size <code class="reqn">\Delta_x \times \Delta_y</code>.
Each <code class="reqn">\bm{u}_{ab} = (u_a, u_b)</code> is a point from the <code class="reqn">(a,b)</code>th
rectangle, for <code class="reqn">a = 1, \ldots, n_x</code> and <code class="reqn">b = 1, \ldots, n_y</code>.
</p>
<p>Due to the treatment of <code class="reqn">A_i</code> and <code class="reqn">\bm{c}_j</code> as objects in a
Euclidean space, this basis is more suitable for coordinates from a map
projection than coordinates based on a globe representation.
</p>
<p>The <code>control</code> argument is a list which may provide any of the following:
</p>

<ul>
<li> <p><code>method</code> specifies computation method: <code>mc</code> or <code>rect</code>.
Default is <code>mc</code>.
</p>
</li>
<li> <p><code>mc_reps</code> is number of repetitions to use for <code>mc</code>.
Default is 1000.
</p>
</li>
<li> <p><code>nx</code> is number of x-axis points to use for <code>rect</code>
method. Default is 50.
</p>
</li>
<li> <p><code>ny</code> is number of y-axis oints to use for <code>rect</code>
method. Default is 50.
</p>
</li>
<li> <p><code>report_period</code> is an integer; print a message with progress each
time this many areas are processed. Default is <code>Inf</code> so that message
is suppressed.
</p>
</li>
<li> <p><code>verbose</code> is a logical; if <code>TRUE</code> print descriptive
messages about the computation. Default is <code>FALSE</code>.
</p>
</li>
<li> <p><code>mc_sampling_factor</code> is a positive number; an oversampling factor
used to compute <code>blocksize</code> in the <a href="#topic+rdomain">rdomain</a> function. I.e.,
<code>blocksize = ceiling(mc_sampling_factor * mc_reps)</code>. Default
is 1.2.
</p>
</li></ul>



<h3>Value</h3>

<p>A sparse <code class="reqn">n \times r</code> matrix whose <code class="reqn">i</code>th row
is
<code class="reqn">
\bm{s}_i^\top =
\Big(
\bar{\varphi}_1(A_i), \ldots, \bar{\varphi}_r(A_i)
\Big).
</code>
</p>


<h3>See Also</h3>

<p>Other bisquare: 
<code><a href="#topic+areal_spacetime_bisquare">areal_spacetime_bisquare</a>()</code>,
<code><a href="#topic+spacetime_bisquare">spacetime_bisquare</a>()</code>,
<code><a href="#topic+spatial_bisquare">spatial_bisquare</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)

# Create knot points
seq_x = seq(0, 1, length.out = 3)
seq_y = seq(0, 1, length.out = 3)
knots = expand.grid(x = seq_x, y = seq_y)
knots_sf = st_as_sf(knots, coords = c("x","y"), crs = NA, agr = "constant")

# Create a simple domain (of rectangles) to evaluate
shape1 = matrix(c(0.0,0.0, 0.5,0.0, 0.5,0.5, 0.0,0.5, 0.0,0.0), ncol=2, byrow=TRUE)
shape2 = shape1 + cbind(rep(0.5,5), rep(0.0,5))
shape3 = shape1 + cbind(rep(0.0,5), rep(0.5,5))
shape4 = shape1 + cbind(rep(0.5,5), rep(0.5,5))
sfc = st_sfc(
   st_polygon(list(shape1)),
   st_polygon(list(shape2)),
   st_polygon(list(shape3)),
   st_polygon(list(shape4))
)
dom = st_sf(data.frame(geoid = 1:length(sfc), geom = sfc))

rad = 0.5
areal_spatial_bisquare(dom, knots, rad)
areal_spatial_bisquare(dom, knots_sf, rad)

# Plot the knots and the points at which we evaluated the basis
plot(knots[,1], knots[,2], pch = 4, cex = 1.5, col = "red")
plot(dom[,1], col = NA, add = TRUE)

# Draw a circle representing the basis' radius around one of the knot points
tseq = seq(0, 2*pi, length=100) 
coords = cbind(rad * cos(tseq) + seq_x[2], rad * sin(tseq) + seq_y[2])
lines(coords, col = "red")

</code></pre>

<hr>
<h2 id='autocov_VAR1'>Compute the autocovariance matrix for a VAR(1) process.</h2><span id='topic+autocov_VAR1'></span>

<h3>Description</h3>

<p>Compute the autocovariance matrix for a VAR(1) process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>autocov_VAR1(A, Sigma, lag_max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="autocov_VAR1_+3A_a">A</code></td>
<td>
<p>Coefficient matrix <code class="reqn">A</code> of the autoregression term.</p>
</td></tr>
<tr><td><code id="autocov_VAR1_+3A_sigma">Sigma</code></td>
<td>
<p>Covariance matrix  <code class="reqn">\bm{\Sigma}</code> of the errors.</p>
</td></tr>
<tr><td><code id="autocov_VAR1_+3A_lag_max">lag_max</code></td>
<td>
<p>maximum number of lags to compute.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes the autocovariance matrix <code class="reqn">\bm{\Gamma}(h)</code> of the
<code class="reqn">m</code>-dimensional VAR(1) process
</p>
<p style="text-align: center;"><code class="reqn">
  \bm{Y}_t = \bm{A} \bm{Y}_{t-1} + \bm{\epsilon}_t, \quad
  \bm{\epsilon}_t \sim \textrm{N}(\bm{0}, \bm{\Sigma})
</code>
</p>

<p>For the required computation of <code class="reqn">\bm{\Gamma}(0)</code>, this function
solves the <code class="reqn">m^2 \times m^2</code> system
</p>
<p style="text-align: center;"><code class="reqn">
\textrm{vec}(\bm{\Gamma}(0)) = [\bm{I} - \bm{A} \otimes \bm{A}]^{-1} \textrm{vec}(\bm{\Sigma}).
</code>
</p>

<p>without directly computing <code class="reqn">m^2 \times m^2</code> matrices.
</p>


<h3>Value</h3>

<p>An array <code>Gamma</code> of dimension <code>c(m, m, lag_max + 1)</code>,
where the slice <code>Gamma[,,h]</code> represents the autocovariance at lag
<code>h = 0, 1, ..., lag_max</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>U = matrix(NA, 3, 3)
U[,1] = c(1, 1, 1) / sqrt(3)
U[,2] = c(1, 0, -1) / sqrt(2)
U[,3] = c(0, 1, -1) / sqrt(2)
B = U %*% diag(c(0.5, 0.2, 0.1)) %*% t(U)
A = (B + t(B)) / 2
Sigma = diag(x = 2, nrow = 3)
autocov_VAR1(A, Sigma, lag_max = 5)

</code></pre>

<hr>
<h2 id='car_precision'>CAR Precision Matrix</h2><span id='topic+car_precision'></span>

<h3>Description</h3>

<p>A convenience function to compute the CAR precision matrix
based on a given adjacency matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>car_precision(A, tau = 1, scale = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="car_precision_+3A_a">A</code></td>
<td>
<p>An adjacency matrix.</p>
</td></tr>
<tr><td><code id="car_precision_+3A_tau">tau</code></td>
<td>
<p>The CAR dependency parameter <code class="reqn">\tau \in [0,1]</code>.
See &quot;Value&quot;. Default: <code>1</code>.</p>
</td></tr>
<tr><td><code id="car_precision_+3A_scale">scale</code></td>
<td>
<p>Whether to scale matrix entries. See &quot;Value&quot;.
Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suppose <code class="reqn">\bm{A}</code> is an <code class="reqn">n \times n</code> adjacency matrix and
<code class="reqn">
  \bm{D} = \textrm{Diag}(\bm{A} \bm{1})
  = \textrm{Diag}(a_{1+}, \ldots, a_{n+}).
</code>
If <code>scale</code> is <code>FALSE</code>, return the CAR precision matrix
</p>
<p style="text-align: center;"><code class="reqn">
  \bm{Q} = \bm{D} - \tau \bm{A}.
</code>
</p>

<p>If <code>scale</code> is <code>TRUE</code>, return a scaled version
</p>
<p style="text-align: center;"><code class="reqn">
  \tilde{\bm{Q}} = \bm{D}^{-1} \bm{Q}.
</code>
</p>

<p>An error is thrown if <code>scale = TRUE</code> and any of
<code class="reqn">\{ a_{1+}, \ldots, a_{n+} \}</code> are equal to 0.
Taking <code class="reqn">\tau = 1</code> corresponds to the Intrinsic CAR
precision matrix.
</p>
<p>Typically in a modeling context, the precision matrix will be
multiplied by a scaling parameter; e.g., a CAR model for
random effects <code class="reqn">\bm{\phi}</code> could be
</p>
<p style="text-align: center;"><code class="reqn">
  f(\bm{\phi} \mid \alpha) \propto
  \alpha^{-q} \exp\left\{ -\frac{1}{2 \alpha^2}
  \bm{\phi}^\top \bm{Q} \bm{\phi} \right\}.
</code>
</p>

<p>where <code class="reqn">q = \textrm{rank}(Q)</code>.
</p>


<h3>Value</h3>

<p>CAR precision matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("acs_sf")
dom = acs5_2013[1:4,]
A = adjacency_matrix(dom)
Q = car_precision(A)

</code></pre>

<hr>
<h2 id='columbia_neighbs'>City of Columbia neighborhoods.</h2><span id='topic+columbia_neighbs'></span>

<h3>Description</h3>

<p>An <code>sf</code> object containing the geometry of four neighborhoods in the
City of Columbia, Boone County, Missouri. Based on shapefiles provided by
the Office of Information Technology / GIS, City of Columbia, Missouri.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>columbia_neighbs
</code></pre>


<h3>Format</h3>

<p>An <code>sf</code> object with 4 features (neighborhoods).
</p>

<hr>
<h2 id='Covariance+20Approximation'>Best Approximation to Covariance Structure</h2><span id='topic+Covariance+20Approximation'></span><span id='topic+cov_approx_randwalk'></span><span id='topic+cov_approx_blockdiag'></span>

<h3>Description</h3>

<p>Compute the best positive approximant for use in the STCOS
model, under several prespecified covariance structures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cov_approx_randwalk(Delta, S)

cov_approx_blockdiag(Delta, S)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Covariance+2B20Approximation_+3A_delta">Delta</code></td>
<td>
<p>Covariance (<code class="reqn">n \times n</code>) for observations within a time
point for the process whose variance we wish to approximate.</p>
</td></tr>
<tr><td><code id="Covariance+2B20Approximation_+3A_s">S</code></td>
<td>
<p>Design matrix (<code class="reqn">N \times r</code>) of basis functions evaluated on
the fine-level process over <code class="reqn">T = N / n</code> time points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Let <code class="reqn">\bm{\Sigma}</code> be an <code class="reqn">N \times N</code> symmetric and positive-definite
covariance matrix and <code class="reqn">\bm{S}</code> be an <code class="reqn">N \times r</code> matrix with
rank <code class="reqn">r</code>. The objective is to compute a matrix <code class="reqn">\bm{K}</code> which minimizes
the Frobenius norm
</p>
<p style="text-align: center;"><code class="reqn">
  \Vert \bm{\Sigma} - \bm{S} \bm{C} \bm{S}^\top {\Vert}_\textrm{F},
</code>
</p>

<p>over symmetric positive-definite matrices <code class="reqn">\bm{C}</code>. The
solution is given by
</p>
<p style="text-align: center;"><code class="reqn">
  \bm{K} = (\bm{S}^\top \bm{S})^{-1} \bm{S}^\top \bm{\Sigma} \bm{S} (\bm{S}^\top \bm{S})^{-1}.
</code>
</p>

<p>In the STCOS model, <code class="reqn">\bm{S}</code> represents the design matrix from a basis
function computed from a fine-level support having <code class="reqn">n</code> areas, using
<code class="reqn">T</code> time steps. Therefore <code class="reqn">N = n T</code> represents the dimension of
covariance for the fine-level support.
</p>
<p>We provide functions to handle some possible structures for target
covariance matrices of the form
</p>
<p style="text-align: center;"><code class="reqn">
  \bm{\Sigma} =
  \left(
  \begin{array}{ccc}
  \bm{\Gamma}(1,1) &amp; \cdots &amp; \bm{\Gamma}(1,T) \\
  \vdots           &amp; \ddots &amp; \vdots \\
  \bm{\Gamma}(T,1) &amp; \cdots &amp; \bm{\Gamma}(T,T)
  \end{array}
  \right),
</code>
</p>

<p>where each <code class="reqn">\bm{\Gamma}(s,t)</code> is an <code class="reqn">n \times n</code> matrix.
</p>

<ul>
<li> <p><code>cov_approx_randwalk</code> assumes <code class="reqn">\bm{\Sigma}</code> is based on the
autocovariance function of a random walk
</p>
<p style="text-align: center;"><code class="reqn">
  \bm{Y}_{t+1} = \bm{Y}_{t} + \bm{\epsilon}_t, \quad \bm{\epsilon}_t \sim \textrm{N}(\bm{0}, \bm{\Delta}).
</code>
</p>

<p>so that
</p>
<p style="text-align: center;"><code class="reqn">
  \bm{\Gamma}(s,t) = \min(s,t) \bm{\Delta}.
</code>
</p>

</li>
<li> <p><code>cov_approx_blockdiag</code> assumes <code class="reqn">\bm{\Sigma}</code> is based on
</p>
<p style="text-align: center;"><code class="reqn">
  \bm{Y}_{t+1} = \bm{Y}_{t} + \bm{\epsilon}_t, \quad \bm{\epsilon}_t \sim \textrm{N}(\bm{0}, \bm{\Delta}).
</code>
</p>

<p>which are independent across <code class="reqn">t</code>, so that
</p>
<p style="text-align: center;"><code class="reqn">
  \bm{\Gamma}(s,t) = I(s = t) \bm{\Delta},
</code>
</p>

</li></ul>

<p>The block structure is used to reduce the computational burden, as <code class="reqn">N</code>
may be large.
</p>

<hr>
<h2 id='DIC'>Deviance Information Criterion</h2><span id='topic+DIC'></span>

<h3>Description</h3>

<p>Generic function to calculate Deviance Information Criterion (DIC) for a
given model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DIC_+3A_object">object</code></td>
<td>
<p>A fitted model object.</p>
</td></tr>
<tr><td><code id="DIC_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value of the DIC.
</p>

<hr>
<h2 id='gibbs_stcos'>Gibbs Sampler for STCOS Model</h2><span id='topic+gibbs_stcos'></span><span id='topic+logLik.stcos_gibbs'></span><span id='topic+DIC.stcos_gibbs'></span><span id='topic+print.stcos_gibbs'></span><span id='topic+fitted.stcos_gibbs'></span><span id='topic+predict.stcos_gibbs'></span>

<h3>Description</h3>

<p>Gibbs Sampler for STCOS Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gibbs_stcos(
  z,
  v,
  H,
  S,
  Kinv,
  R,
  report_period = R + 1,
  burn = 0,
  thin = 1,
  init = NULL,
  fixed = NULL,
  hyper = NULL
)

## S3 method for class 'stcos_gibbs'
logLik(object, ...)

## S3 method for class 'stcos_gibbs'
DIC(object, ...)

## S3 method for class 'stcos_gibbs'
print(x, ...)

## S3 method for class 'stcos_gibbs'
fitted(object, H, S, ...)

## S3 method for class 'stcos_gibbs'
predict(object, H, S, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gibbs_stcos_+3A_z">z</code></td>
<td>
<p>Vector which represents the outcome; assumed to be direct
estimates from the survey.</p>
</td></tr>
<tr><td><code id="gibbs_stcos_+3A_v">v</code></td>
<td>
<p>Vector which represents direct variance estimates from the survey.</p>
</td></tr>
<tr><td><code id="gibbs_stcos_+3A_h">H</code></td>
<td>
<p>Matrix of overlaps between source and fine-level supports.</p>
</td></tr>
<tr><td><code id="gibbs_stcos_+3A_s">S</code></td>
<td>
<p>Design matrix for basis decomposition.</p>
</td></tr>
<tr><td><code id="gibbs_stcos_+3A_kinv">Kinv</code></td>
<td>
<p>The precision matrix <code class="reqn">\bm{K}^{-1}</code> of the
random coefficient <code class="reqn">\bm{\eta}</code></p>
</td></tr>
<tr><td><code id="gibbs_stcos_+3A_r">R</code></td>
<td>
<p>Number of MCMC reps.</p>
</td></tr>
<tr><td><code id="gibbs_stcos_+3A_report_period">report_period</code></td>
<td>
<p>Gibbs sampler will report progress each time this many
iterations are completed.</p>
</td></tr>
<tr><td><code id="gibbs_stcos_+3A_burn">burn</code></td>
<td>
<p>Number of the <code>R</code> draws to discard at the beginning of the
chain.</p>
</td></tr>
<tr><td><code id="gibbs_stcos_+3A_thin">thin</code></td>
<td>
<p>After burn-in period, save one out of every <code>thin</code> draws.</p>
</td></tr>
<tr><td><code id="gibbs_stcos_+3A_init">init</code></td>
<td>
<p>A list containing the following initial values for the MCMC:
<code>sig2mu</code>, <code>sig2xi</code>, <code>sig2K</code>, <code>muB</code>, <code>eta</code>,
<code>xi</code>. Any values which are not specified are set to arbitrary
choices.</p>
</td></tr>
<tr><td><code id="gibbs_stcos_+3A_fixed">fixed</code></td>
<td>
<p>A list specifying which parameters to keep fixed in the MCMC.
This can normally be left blank. If elements <code>sig2mu</code>,
<code>sig2xi</code>, or <code>sig2K</code> are specified they should be boolean,
where TRUE means fixed (i.e. not drawn). If elements <code>muB</code>,
<code>eta</code>, or <code>xi</code> are specified, they should each be a vector
of indicies; the specified indices are to be treated as fixed (i.e.
not drawn).</p>
</td></tr>
<tr><td><code id="gibbs_stcos_+3A_hyper">hyper</code></td>
<td>
<p>A list containing the following hyperparameter values:
<code>a_sig2mu</code>, <code>a_sig2K</code>, <code>a_sig2xi</code>, <code>b_sig2mu</code>,
<code>b_sig2K</code>, <code>b_sig2xi</code>. Any hyperparameters which are not
specified are set to a default value of 2.</p>
</td></tr>
<tr><td><code id="gibbs_stcos_+3A_object">object</code></td>
<td>
<p>A result from <code>gibbs_stcos</code>.</p>
</td></tr>
<tr><td><code id="gibbs_stcos_+3A_...">...</code></td>
<td>
<p>Additional arguments.</p>
</td></tr>
<tr><td><code id="gibbs_stcos_+3A_x">x</code></td>
<td>
<p>A result from <code>gibbs_stcos</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fits the model
</p>
<p style="text-align: center;"><code class="reqn">
  \bm{Z} = \bm{H} \bm{\mu}_B + \bm{S} \bm{\eta} + \bm{\xi} + \bm{\varepsilon}, \quad
  \bm{\varepsilon} \sim \textrm{N}(0, \bm{V}),
</code>
</p>

<p style="text-align: center;"><code class="reqn">
  \bm{\eta} \sim \textrm{N}(\bm{0}, \sigma_K^2 \bm{K}), \quad
  \bm{\xi} \sim \textrm{N}(0, \sigma_{\xi}^2 \bm{I}),
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\bm{\mu}_B \sim \textrm{N}(\bm{0}, \sigma_\mu^2 \bm{I}), \quad
\sigma_\mu^2 \sim \textrm{IG}(a_\mu, b_\mu),
</code>
</p>

<p style="text-align: center;"><code class="reqn">
\sigma_K^2 \sim \textrm{IG}(a_K, b_K), \quad
\sigma_\xi^2 \sim \textrm{IG}(a_\xi, b_\xi),
</code>
</p>

<p>using a Gibbs sampler with closed-form draws.
</p>
<p>Helper functions produce the following outputs:
</p>

<ul>
<li> <p><code>logLik</code> computes the log-likelihood for each saved draw.
</p>
</li>
<li> <p><code>DIC</code> computes the Deviance information criterion for each saved draw.
</p>
</li>
<li> <p><code>print</code> displays a summary of the draws.
</p>
</li>
<li> <p><code>fitted</code> computes the mean <code class="reqn">E(Y_i)</code> for each observation
<code class="reqn">i = 1, \ldots, n</code>, for each saved draw.
</p>
</li>
<li> <p><code>predict</code> draws <code class="reqn">Y_i</code> for each observation
<code class="reqn">i = 1, \ldots, n</code>, using the parameter values for each saved
Gibbs sampler draw.
</p>
</li></ul>



<h3>Value</h3>

<p><code>gibbs_stcos</code> returns an <code>stcos</code> object which contains
draws from the sampler. Helper functions take this object as an input
and produce various outputs (see details).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
demo = prepare_stcos_demo()
out = gibbs_stcos(demo$z, demo$v, demo$H, demo$S, solve(demo$K),
    R = 100, burn = 0, thin = 1)
print(out)
logLik(out)
DIC(out)
fitted(out, demo$H, demo$S)
predict(out, demo$H, demo$S)

## End(Not run)
</code></pre>

<hr>
<h2 id='licols'>licols</h2><span id='topic+licols'></span>

<h3>Description</h3>

<p>Extract a linearly independent set of columns of a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>licols(X, tol = 1e-10, quiet = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="licols_+3A_x">X</code></td>
<td>
<p>A matrix.</p>
</td></tr>
<tr><td><code id="licols_+3A_tol">tol</code></td>
<td>
<p>A tolerance for rank estimation. Default is 1e-10.</p>
</td></tr>
<tr><td><code id="licols_+3A_quiet">quiet</code></td>
<td>
<p>logical; if FALSE, print a warning about computation time if <code>X</code> is large.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>An R version of a Matlab <code>licols</code> function given in
<a href="https://www.mathworks.com/matlabcentral/answers/108835-how-to-get-only-linearly-independent-rows-in-a-matrix-or-to-remove-linear-dependency-b-w-rows-in-a-m#answer_117458">this MathWorks forum post</a>.
</p>


<h3>Value</h3>

<p><code>Xsub</code> contains the extracted columns of <code>X</code> and <code>idx</code>
contains the indices (into X) of those columns. The elapsed time is stored in
<code>elapsed.sec</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x = 0:19 %% 3 + 1
Z = model.matrix(~ as.factor(x) - 1)
X = cbind(1, Z)
licols(X)

</code></pre>

<hr>
<h2 id='mle_stcos'>MLE for STCOS Model</h2><span id='topic+mle_stcos'></span>

<h3>Description</h3>

<p>MLE for STCOS Model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mle_stcos(
  z,
  v,
  H,
  S,
  K,
  init = NULL,
  optim_control = list(),
  optim_method = "L-BFGS-B"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mle_stcos_+3A_z">z</code></td>
<td>
<p>Vector which represents the outcome; assumed to be direct
estimates from the survey.</p>
</td></tr>
<tr><td><code id="mle_stcos_+3A_v">v</code></td>
<td>
<p>Vector which represents direct variance estimates from the survey.
The diagonal of the matrix <code class="reqn">\bm{V}</code> described in the details.</p>
</td></tr>
<tr><td><code id="mle_stcos_+3A_h">H</code></td>
<td>
<p>Matrix of overlaps between source and fine-level supports.</p>
</td></tr>
<tr><td><code id="mle_stcos_+3A_s">S</code></td>
<td>
<p>Design matrix for basis decomposition.</p>
</td></tr>
<tr><td><code id="mle_stcos_+3A_k">K</code></td>
<td>
<p>Variance of the random coefficient <code class="reqn">\bm{\eta}</code></p>
</td></tr>
<tr><td><code id="mle_stcos_+3A_init">init</code></td>
<td>
<p>A list containing the initial values in the MCMC for
<code>sig2xi</code> and <code>sig2K</code>. If not specified, we select an
arbitrary initial value.</p>
</td></tr>
<tr><td><code id="mle_stcos_+3A_optim_control">optim_control</code></td>
<td>
<p>This is passed as the <code>control</code> argument to
<code>optim</code>. Note that the value <code>fnscale</code> is ignored if
specified.</p>
</td></tr>
<tr><td><code id="mle_stcos_+3A_optim_method">optim_method</code></td>
<td>
<p>Method to be used for likelihood maximization by
<code>optim</code>. Default is <code>L-BFGS-B</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Maximize the likelihood of the STCOS model
</p>
<p style="text-align: center;"><code class="reqn">
  f(\bm{z} \mid \bm{\mu}_B, \sigma_K^2, \sigma_\xi^2)
  = \textrm{N}(\bm{z} \mid \bm{H} \bm{\mu}_B, \bm{\Delta}
  ),
  \quad \bm{\Delta} = \sigma_\xi^2 \bm{I} + \bm{V} + \sigma_K^2 \bm{S} \bm{K} \bm{S}^\top,
</code>
</p>

<p>by numerical maximization of the profile likelihood
</p>
<p style="text-align: center;"><code class="reqn">
  \ell(\sigma_K^2, \sigma_\xi^2) =
  -\frac{N}{2} \log(2 \pi) -\frac{1}{2} \log |\bm{\Delta}| -\frac{1}{2} (\bm{z} -
  \bm{H} \hat{\bm{\mu}}_B)^\top \bm{\Delta}^{-1} (\bm{z} - \bm{H} \hat{\bm{\mu}}_B)
</code>
</p>

<p>using
<code class="reqn">
  \hat{\bm{\mu}}_B = (\bm{H}^\top \bm{\Delta}^{-1} \bm{H})^{-1}
  \bm{H}^\top \bm{\Delta}^{-1} \bm{z}.
</code>
</p>


<h3>Value</h3>

<p>A list containing maximum likelihood estimates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
demo = prepare_stcos_demo()
mle_out = mle_stcos(demo$z, demo$v, demo$S, demo$H, demo$K)
sig2K_hat = mle_out$sig2K_hat
sig2xi_hat = mle_out$sig2xi_hat
mu_hat = mle_out$mu_hat

## End(Not run)
</code></pre>

<hr>
<h2 id='overlap_matrix'>Matrix of overlaps between two sets of areas.</h2><span id='topic+overlap_matrix'></span>

<h3>Description</h3>

<p>A convenience function to convert output from <code>sf::st_intersection</code>
to a sparse matrix as defined in the <code>Matrix</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>overlap_matrix(dom1, dom2, proportion = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="overlap_matrix_+3A_dom1">dom1</code></td>
<td>
<p>An <code>sf</code> object representing a domain of areal units.</p>
</td></tr>
<tr><td><code id="overlap_matrix_+3A_dom2">dom2</code></td>
<td>
<p>An <code>sf</code> object representing a domain of areal units.</p>
</td></tr>
<tr><td><code id="overlap_matrix_+3A_proportion">proportion</code></td>
<td>
<p>Logical; if <code>TRUE</code>, normalize so that rows sum to 1.
Otherwise areas are returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a matrix <code>H</code> whose (i,j)th entry represent the area of the overlap
between areal units <code>dom1[i,]</code> and <code>dom2[j,]</code>.
</p>


<h3>Value</h3>

<p>An matrix of overlaps.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("acs_sf")
dom1 = acs5_2013[1:10,]
dom2 = acs5_2016[1:10,]
H1 = overlap_matrix(dom1, dom2)
H2 = overlap_matrix(dom1, dom2, proportion = FALSE)

</code></pre>

<hr>
<h2 id='prepare_stcos_demo'>Prepare Demo Data for STCOS Model</h2><span id='topic+prepare_stcos_demo'></span>

<h3>Description</h3>

<p>Create demo data based on ACS example, making a few simple model choices.
The purpose of this function is to facilitate examples in other functions.
Uses functions in the package to create model terms from shapefiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_stcos_demo(num_knots_sp = 200, basis_mc_reps = 200, eigval_prop = 0.65)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare_stcos_demo_+3A_num_knots_sp">num_knots_sp</code></td>
<td>
<p>Number of spatial knots to use in areal space-time
basis.</p>
</td></tr>
<tr><td><code id="prepare_stcos_demo_+3A_basis_mc_reps">basis_mc_reps</code></td>
<td>
<p>Number of monte carlo reps to use in areal space-time
basis.</p>
</td></tr>
<tr><td><code id="prepare_stcos_demo_+3A_eigval_prop">eigval_prop</code></td>
<td>
<p>Proportion of variability to keep in dimension reduction
of basis expansions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following:
</p>

<ul>
<li> <p><code>z</code> direct estimates.
</p>
</li>
<li> <p><code>v</code> direct variance estimates.
</p>
</li>
<li> <p><code>H</code> overlap matrix.
</p>
</li>
<li> <p><code>S</code> design matrix of basis expansion.
</p>
</li>
<li> <p><code>K</code> covariance matrix of the random effect.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
out = prepare_stcos_demo()

## End(Not run)
</code></pre>

<hr>
<h2 id='rdomain'>Draw uniformly distributed points from a set of areas</h2><span id='topic+rdomain'></span>

<h3>Description</h3>

<p>An alternative to <code>sf::st_sample</code> which draws uniformly distributed
points using a simple accept-reject method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rdomain(n, dom, blocksize = n, itmax = Inf)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rdomain_+3A_n">n</code></td>
<td>
<p>Number of points desired in the final sample.</p>
</td></tr>
<tr><td><code id="rdomain_+3A_dom">dom</code></td>
<td>
<p>An <code>sf</code> object representing a domain of areal units.</p>
</td></tr>
<tr><td><code id="rdomain_+3A_blocksize">blocksize</code></td>
<td>
<p>Number of candidate points to draw on each pass of
accept-reject sampling (see details). Defaults to <code>n</code>.</p>
</td></tr>
<tr><td><code id="rdomain_+3A_itmax">itmax</code></td>
<td>
<p>Maximum number of accept-reject samples to attempt. Defaults
to <code>Inf</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Draws a sample of <code>blocksize</code> points uniformly from a bounding box on
<code>dom</code>, and accepts only the points which belong to <code>dom</code>. This
yields a uniform sample on <code>dom</code>. The process is repeated until <code>n</code>
accepted draws are obtained, or until it has been attempted <code>itmax</code>
times. If <code>itmax</code> iterations are reached without accepting <code>n</code>
draws, an error is thrown.
</p>
<p>This seems to be an order of magnitude faster than the current
implementation of <code>st_sample</code>, although the latter can accomplish
the same objective and is more general. The improved performance is
worthwhile when used in the areal basis functions,
which sample repeatedly from the domain.
</p>
<p>Performance will degrade when areal units have small area relative to their
bounding box, as many candidate points may need to be discarded. For
example, this will occur if <code>dom</code> contains a set of small scattered
islands in an ocean. In this case, it would be more efficient to sample
from each island at a time.
</p>


<h3>Value</h3>

<p>An <code>sf</code> object with 2-dimensional points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dom = acs5_2013[c(1,5,8,12),]
pts = rdomain(10000, dom)

</code></pre>

<hr>
<h2 id='spacetime_bisquare'>Space-Time Bisquare Basis</h2><span id='topic+spacetime_bisquare'></span>

<h3>Description</h3>

<p>Space-time bisquare basis on point data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spacetime_bisquare(dom, knots, w_s, w_t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spacetime_bisquare_+3A_dom">dom</code></td>
<td>
<p>Space-time points <code class="reqn">(\bm{u}_1,v_1), \ldots, (\bm{u}_n,v_n)</code>
to evaluate. See &quot;Details&quot;.</p>
</td></tr>
<tr><td><code id="spacetime_bisquare_+3A_knots">knots</code></td>
<td>
<p>Spatio-temporal knots
<code class="reqn">(\bm{c}_1,g_1), \ldots, (\bm{c}_r,g_r)</code>
for the basis. See &quot;Details&quot;.</p>
</td></tr>
<tr><td><code id="spacetime_bisquare_+3A_w_s">w_s</code></td>
<td>
<p>Spatial radius for the basis.</p>
</td></tr>
<tr><td><code id="spacetime_bisquare_+3A_w_t">w_t</code></td>
<td>
<p>Temporal radius for the basis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Notes about arguments:
</p>

<ul>
<li><p> Both <code>dom</code> and <code>knots</code> may be provided as either <code>sf</code> or
<code>sfc</code> objects, or as matrices of points.
</p>
</li>
<li><p> If an <code>sf</code> or <code>sfc</code> object is provided for <code>dom</code>, <code class="reqn">n</code>
three-dimensional <code>POINT</code> entries are expected in <code>st_geometry(dom)</code>.
Otherwise, <code>dom</code> will be interpreted as an <code class="reqn">n \times 3</code> numeric matrix.
</p>
</li>
<li><p> If an <code>sf</code> or <code>sfc</code> object is provided for <code>knots</code>, <code class="reqn">r</code>
three-dimensional <code>POINT</code> entries are expected in <code>st_geometry(knots)</code>.
Otherwise, <code>knots</code> will be interpreted as an <code class="reqn">r \times 3</code> numeric matrix.
</p>
</li>
<li><p> If both <code>dom</code> and <code>knots_s</code> are given as <code>sf</code> or <code>sfc</code> objects,
they will be checked to ensure a common coordinate system.
</p>
</li></ul>

<p>For each <code class="reqn">(\bm{u}_i,v_i)</code>, compute the basis functions
</p>
<p style="text-align: center;"><code class="reqn">
\psi_j(\bm{u},v) =
\left[ 2 - \frac{\Vert \bm{u} - \bm{c}_j \Vert^2}{w_s^2}- \frac{|v - g_j|^2}{w_t^2} \right]^2  \cdot
I(\Vert \bm{u} - \bm{c}_j \Vert \leq w_s) \cdot
I(|v - g_j| \leq w_t)
</code>
</p>

<p>for <code class="reqn">j = 1, \ldots, r</code>.
</p>
<p>Due to the treatment of <code class="reqn">\bm{u}_i</code> and <code class="reqn">\bm{c}_j</code> as points in a
Euclidean space, this basis is more suitable for coordinates from a map
projection than coordinates based on a globe representation.
</p>


<h3>Value</h3>

<p>A sparse <code class="reqn">n \times r</code> matrix whose <code class="reqn">i</code>th row
is
</p>
<p style="text-align: center;"><code class="reqn">
\bm{s}_i^\top =
\Big(
\psi_1(\bm{u}_i,v_i), \ldots, \psi_r(\bm{u}_i,v_i)
\Big).
</code>
</p>



<h3>See Also</h3>

<p>Other bisquare: 
<code><a href="#topic+areal_spacetime_bisquare">areal_spacetime_bisquare</a>()</code>,
<code><a href="#topic+areal_spatial_bisquare">areal_spatial_bisquare</a>()</code>,
<code><a href="#topic+spatial_bisquare">spatial_bisquare</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)

# Create knot points
seq_x = seq(0, 1, length.out = 3)
seq_y = seq(0, 1, length.out = 3)
seq_t = seq(0, 1, length.out = 3)
knots = expand.grid(x = seq_x, y = seq_y, t = seq_t)
knots_sf = st_as_sf(knots, coords = c("x","y","t"), crs = NA, dim = "XYM", agr = "constant")

# Points to evaluate
x = runif(50)
y = runif(50)
t = sample(1:3, size = 50, replace = TRUE)
pts = data.frame(x = x, y = y, t = t)
dom = st_as_sf(pts, coords = c("x","y","t"), crs = NA, dim = "XYM", agr = "constant")

rad = 0.5
spacetime_bisquare(cbind(x,y,t), knots, w_s = rad, w_t = 1)
spacetime_bisquare(dom, knots_sf, w_s = rad, w_t = 1)

# Plot the (spatial) knots and the points at which we evaluated the basis
plot(knots[,1], knots[,2], pch = 4, cex = 1.5, col = "red")
text(x, y, labels = t, cex = 0.75)

# Draw a circle representing the basis' radius around one of the knot points
tseq = seq(0, 2*pi, length=100) 
coords = cbind(rad * cos(tseq) + seq_x[2], rad * sin(tseq) + seq_y[2])
lines(coords, col = "red")

</code></pre>

<hr>
<h2 id='spatial_bisquare'>Spatial Bisquare Basis</h2><span id='topic+spatial_bisquare'></span>

<h3>Description</h3>

<p>Spatial bisquare basis on point data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spatial_bisquare(dom, knots, w)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spatial_bisquare_+3A_dom">dom</code></td>
<td>
<p>Points <code class="reqn">\bm{u}_1, \ldots, \bm{u}_n</code> to evaluate. See
&quot;Details&quot;.</p>
</td></tr>
<tr><td><code id="spatial_bisquare_+3A_knots">knots</code></td>
<td>
<p>Knots <code class="reqn">\bm{c}_1, \ldots, \bm{c}_r</code> for the basis.
See &quot;Details&quot;.</p>
</td></tr>
<tr><td><code id="spatial_bisquare_+3A_w">w</code></td>
<td>
<p>Radius for the basis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Notes about arguments:
</p>

<ul>
<li><p> Both <code>dom</code> and <code>knots</code> may be provided as either <code>sf</code> or
<code>sfc</code> objects, or as matrices of points.
</p>
</li>
<li><p> If an <code>sf</code> or <code>sfc</code> object is provided for <code>dom</code>, <code class="reqn">n</code>
two-dimensional <code>POINT</code> entries are expected in <code>st_geometry(dom)</code>.
Otherwise, <code>dom</code> will be interpreted as an <code class="reqn">n \times 2</code> numeric matrix.
</p>
</li>
<li><p> If an <code>sf</code> or <code>sfc</code> object is provided for <code>knots</code>, <code class="reqn">r</code>
two-dimensional <code>POINT</code> entries are expected in <code>st_geometry(knots)</code>.
Otherwise, <code>knots</code> will be interpreted as an <code class="reqn">r \times 2</code> numeric matrix.
</p>
</li>
<li><p> If both <code>dom</code> and <code>knots</code> are given as <code>sf</code> or <code>sfc</code> objects,
they will be checked to ensure a common coordinate system.
</p>
</li></ul>

<p>For each <code class="reqn">\bm{u}_i</code>, compute the basis functions
</p>
<p style="text-align: center;"><code class="reqn">
\varphi_j(\bm{u}) =
\left[ 1 - \frac{\Vert\bm{u} - \bm{c}_j \Vert^2}{w^2} \right]^2  \cdot
I(\Vert \bm{u} - \bm{c}_j \Vert \leq w)
</code>
</p>

<p>for <code class="reqn">j = 1, \ldots, r</code>.
</p>
<p>Due to the treatment of <code class="reqn">\bm{u}_i</code> and <code class="reqn">\bm{c}_j</code> as points in a
Euclidean space, this basis is more suitable for coordinates from a map
projection than coordinates based on a globe representation.
</p>


<h3>Value</h3>

<p>A sparse <code class="reqn">n \times r</code> matrix whose <code class="reqn">i</code>th row
is
<code class="reqn">
\bm{s}_i^\top =
\Big(
\varphi_1(\bm{u}_i), \ldots, \varphi_r(\bm{u}_i)
\Big).
</code>
</p>


<h3>See Also</h3>

<p>Other bisquare: 
<code><a href="#topic+areal_spacetime_bisquare">areal_spacetime_bisquare</a>()</code>,
<code><a href="#topic+areal_spatial_bisquare">areal_spatial_bisquare</a>()</code>,
<code><a href="#topic+spacetime_bisquare">spacetime_bisquare</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1234)

# Create knot points
seq_x = seq(0, 1, length.out = 3)
seq_y = seq(0, 1, length.out = 3)
knots = expand.grid(x = seq_x, y = seq_y)
knots_sf = st_as_sf(knots, coords = c("x","y"), crs = NA, agr = "constant")

# Points to evaluate
x = runif(50)
y = runif(50)
pts = data.frame(x = x, y = y)
dom = st_as_sf(pts, coords = c("x","y"), crs = NA, agr = "constant")

rad = 0.5
spatial_bisquare(cbind(x,y), knots, rad)
spatial_bisquare(dom, knots, rad)

# Plot the knots and the points at which we evaluated the basis
plot(knots[,1], knots[,2], pch = 4, cex = 1.5, col = "red")
points(x, y, cex = 0.5)

# Draw a circle representing the basis' radius around one of the knot points
tseq = seq(0, 2*pi, length=100) 
coords = cbind(rad * cos(tseq) + seq_x[2], rad * sin(tseq) + seq_y[2])
lines(coords, col = "red")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
