<!DOCTYPE html><html><head><title>Help for package bdc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bdc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#%&gt;%'><p>Pipe operator</p></a></li>
<li><a href='#bdc_basisOfRecords_notStandard'><p>Identify records from doubtful source (e.g., 'fossil', MachineObservation')</p></a></li>
<li><a href='#bdc_clean_names'><p>Clean and parse scientific names</p></a></li>
<li><a href='#bdc_coordinates_country_inconsistent'><p>Identify records within a reference country</p></a></li>
<li><a href='#bdc_coordinates_empty'><p>Identify records with empty geographic coordinates</p></a></li>
<li><a href='#bdc_coordinates_from_locality'><p>Identify records lacking or with invalid coordinates but containing locality</p>
information</a></li>
<li><a href='#bdc_coordinates_outOfRange'><p>Identify records with out-of-range geographic coordinates</p></a></li>
<li><a href='#bdc_coordinates_precision'><p>Flag low-precise geographic coordinates</p></a></li>
<li><a href='#bdc_coordinates_transposed'><p>Identify transposed geographic coordinates</p></a></li>
<li><a href='#bdc_country_from_coordinates'><p>Get country names from coordinates</p></a></li>
<li><a href='#bdc_country_standardized'><p>Standardizes country names and gets country code</p></a></li>
<li><a href='#bdc_create_figures'><p>Create figures reporting the results of the bdc package</p></a></li>
<li><a href='#bdc_create_report'><p>Create a report summarizing the results of data quality tests</p></a></li>
<li><a href='#bdc_eventDate_empty'><p>Identify records with empty event date</p></a></li>
<li><a href='#bdc_filter_out_flags'><p>Remove columns with the results of data quality tests</p></a></li>
<li><a href='#bdc_filter_out_names'><p>Filter out records according to their taxonomic status</p></a></li>
<li><a href='#bdc_query_names_taxadb'><p>Harmonizing taxon names against local stored taxonomic databases</p></a></li>
<li><a href='#bdc_quickmap'><p>Create a map of points using ggplot2</p></a></li>
<li><a href='#bdc_scientificName_empty'><p>Identify records with empty scientific names</p></a></li>
<li><a href='#bdc_standardize_datasets'><p>Standardize datasets columns based on metadata</p></a></li>
<li><a href='#bdc_summary_col'><p>Create or update the column summarizing the results of data quality tests</p></a></li>
<li><a href='#bdc_year_from_eventDate'><p>Extract year from eventDate</p></a></li>
<li><a href='#bdc_year_outOfRange'><p>Identify records with year out-of-range</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Biodiversity Data Cleaning</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.4</td>
</tr>
<tr>
<td>Description:</td>
<td>It brings together several aspects of biodiversity
    data-cleaning in one place. 'bdc' is organized in thematic modules
    related to different biodiversity dimensions, including 1) Merge
    datasets: standardization and integration of different datasets; 2)
    Pre-filter: flagging and removal of invalid or non-interpretable
    information, followed by data amendments; 3) Taxonomy: cleaning,
    parsing, and harmonization of scientific names from several taxonomic
    groups against taxonomic databases locally stored through the
    application of exact and partial matching algorithms; 4) Space:
    flagging of erroneous, suspect, and low-precision geographic
    coordinates; and 5) Time: flagging and, whenever possible, correction
    of inconsistent collection date. In addition, it contains
    features to visualize, document, and report data quality – which is
    essential for making data quality assessment transparent and
    reproducible. The reference for the methodology is Bruno et al. (2022)
    &lt;<a href="https://doi.org/10.1111%2F2041-210X.13868">doi:10.1111/2041-210X.13868</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://brunobrr.github.io/bdc/">https://brunobrr.github.io/bdc/</a> (website)
<a href="https://github.com/brunobrr/bdc">https://github.com/brunobrr/bdc</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/brunobrr/bdc/issues">https://github.com/brunobrr/bdc/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>CoordinateCleaner, dplyr, DT, foreach, fs, ggplot2, here,
magrittr, purrr, qs, readr, rgnparser, rnaturalearth, sf (&ge;
1.0.5), stringdist, stringi, stringr, taxadb (&ge; 0.1.3),
tibble, tidyselect</td>
</tr>
<tr>
<td>Suggests:</td>
<td>contentid (&ge; 0.0.15), covr, cowplot, DBI, doParallel, duckdb
(&ge; 0.3.2), knitr (&ge; 1.31), maps, markdown, rappdirs, raster,
remotes, rlang (&ge; 1.0.1), rmarkdown, rnaturalearthdata, rvest,
sp, testthat (&ge; 3.0.0), xml2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-gb</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-13 12:42:38 UTC; ribei</td>
</tr>
<tr>
<td>Author:</td>
<td>Bruno Ribeiro <a href="https://orcid.org/0000-0002-7755-6715"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Santiago Velazco <a href="https://orcid.org/0000-0002-7527-0967"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Karlo Guidoni-Martins
    <a href="https://orcid.org/0000-0002-8458-8467"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Geiziane Tessarolo
    <a href="https://orcid.org/0000-0003-1361-0062"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Lucas Jardim <a href="https://orcid.org/0000-0003-2602-5575"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Steven Bachman <a href="https://orcid.org/0000-0003-1085-6075"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Rafael Loyola <a href="https://orcid.org/0000-0001-5323-2735"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Bruno Ribeiro &lt;ribeiro.brr@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-13 13:50:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='bdc_basisOfRecords_notStandard'>Identify records from doubtful source (e.g., 'fossil', MachineObservation')</h2><span id='topic+bdc_basisOfRecords_notStandard'></span>

<h3>Description</h3>

<p>This function flags records with an informed basis of records (i.e., the
records type, for example, a specimen, a human observation, or a fossil
specimen) not interpretable, which does not comply with Darwin Core
vocabulary, or unreliable or unsuitable for specific analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdc_basisOfRecords_notStandard(
  data,
  basisOfRecord = "basisOfRecord",
  names_to_keep = "all"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdc_basisOfRecords_notStandard_+3A_data">data</code></td>
<td>
<p>data.frame. Containing information about the basis of records.</p>
</td></tr>
<tr><td><code id="bdc_basisOfRecords_notStandard_+3A_basisofrecord">basisOfRecord</code></td>
<td>
<p>character string. The column name with information about
basis of records. Default = &quot;basisOfRecord&quot;.</p>
</td></tr>
<tr><td><code id="bdc_basisOfRecords_notStandard_+3A_names_to_keep">names_to_keep</code></td>
<td>
<p>character string. Elements of the column BasisOfRecords
to keep. Default is &quot;all&quot;, which considers a selected list of recommended
standard Darwin Core classes (and their spelling variations, see details).
By default, records missing (i.e., NA) or with &quot;unknown&quot; information about
basis of records are kept.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Users are encourage to select the set of basis of records classes
to keep. Default = c(&quot;Event&quot;,&quot;HUMAN_OBSERVATION&quot;, &quot;HumanObservation&quot;,
&quot;LIVING_SPECIMEN&quot;, &quot;LivingSpecimen&quot;, &quot;MACHINE_OBSERVATION&quot;,
&quot;MachineObservation&quot;, &quot;MATERIAL_SAMPLE&quot;, &quot;O&quot;, &quot;Occurrence&quot;,
&quot;MaterialSample&quot;, &quot;OBSERVATION&quot;, &quot;Preserved Specimen&quot;,
&quot;PRESERVED_SPECIMEN&quot;, &quot;preservedspecimen Specimen&quot;, &quot;Preservedspecimen&quot;,
&quot;PreservedSpecimen&quot;, &quot;preservedspecimen&quot;, &quot;S&quot;, &quot;Specimen&quot;, &quot;Taxon&quot;,
&quot;UNKNOWN&quot;, &quot;&quot;, NA)
</p>


<h3>Value</h3>

<p>A data.frame containing the column &quot;.basisOfRecords_notStandard&quot;
.Compliant (TRUE) if 'basisOfRecord' is standard; otherwise &quot;FALSE&quot;.
</p>


<h3>See Also</h3>

<p>Other prefilter: 
<code><a href="#topic+bdc_coordinates_country_inconsistent">bdc_coordinates_country_inconsistent</a>()</code>,
<code><a href="#topic+bdc_coordinates_empty">bdc_coordinates_empty</a>()</code>,
<code><a href="#topic+bdc_coordinates_from_locality">bdc_coordinates_from_locality</a>()</code>,
<code><a href="#topic+bdc_coordinates_outOfRange">bdc_coordinates_outOfRange</a>()</code>,
<code><a href="#topic+bdc_coordinates_transposed">bdc_coordinates_transposed</a>()</code>,
<code><a href="#topic+bdc_country_standardized">bdc_country_standardized</a>()</code>,
<code><a href="#topic+bdc_scientificName_empty">bdc_scientificName_empty</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(basisOfRecord = c(
  "FOSSIL_SPECIMEN", "UNKNOWN",
  "RON", NA, "Specimen", "PRESERVED_SPECIMEN"
))

bdc_basisOfRecords_notStandard(
  data = x, 
  basisOfRecord = "basisOfRecord",
  names_to_keep = "all"
)
</code></pre>

<hr>
<h2 id='bdc_clean_names'>Clean and parse scientific names</h2><span id='topic+bdc_clean_names'></span>

<h3>Description</h3>

<p>This function is composed of a series of name-checking routines for cleaning
and parsing scientific names; i.e., unify writing style. It removes 1) family
names of animals or plants pre-pended to species names, 2) qualifiers
denoting the uncertain or provisional status of taxonomic identification
(e.g., confer, species, affinis), and 3) infraspecific terms, for example,
variety (var.), subspecies (subsp), forma (f.), and their spelling
variations. It also includes applications to 4) standardize names, i.e.,
capitalize only the first letter of the genus name and remove extra
whitespaces), and 5) parse names, i.e., separate author, date, annotations
from taxon name.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdc_clean_names(sci_names, save_outputs = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdc_clean_names_+3A_sci_names">sci_names</code></td>
<td>
<p>character string. Containing scientific names.</p>
</td></tr>
<tr><td><code id="bdc_clean_names_+3A_save_outputs">save_outputs</code></td>
<td>
<p>logical. Should the outputs be saved? Default = FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Terms denoting uncertainty or provisional status of taxonomic
identification as well as infraspecific terms were obtained from Sigoviniet
al. (2016; doi: 10.1111/2041-210X.12594). More details about the names
parse process can be found in
<a href="https://github.com/gnames/gnparser">gnparser</a>.
</p>


<h3>Value</h3>

<p>A five-column data.frame including
</p>

<ul>
<li><p> scientificName: original names supplied
</p>
</li>
<li><p> .uncer_terms: indicates the presence of taxonomic uncertainty terms
</p>
</li>
<li><p> .infraesp_names: indicates the presence of infraspecific terms
</p>
</li>
<li><p> name_clean: scientific names resulting from the cleaning and parsing
processes
</p>
</li>
<li><p> quality: an index indicating the quality of parsing process. It
ranges from 0 to 4, being 1 no problem detected, 4 serious problems detected;
a value of 0 indicates no interpretable name that was not parsed).
</p>
</li></ul>

<p>If save_outputs == TRUE, a data.frame containing all tests of the cleaning
names process and the results of the parsing names process is saved in
&quot;Output/Check/02_parse_names.csv&quot;.
</p>


<h3>See Also</h3>

<p>Other taxonomy: 
<code><a href="#topic+bdc_filter_out_names">bdc_filter_out_names</a>()</code>,
<code><a href="#topic+bdc_query_names_taxadb">bdc_query_names_taxadb</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
scientificName &lt;- c(
  "Fridericia bahiensis (Schauer ex. DC.) L.G.Lohmann",
  "Peltophorum dubium (Spreng.) Taub. (Griseb.) Barneby",
  "Gymnanthes edwalliana (Pax &amp; K.Hoffm.) Laurenio-Melo &amp; M.F.Sales",
  "LEGUMINOSAE Senna aff. organensis (Glaz. ex Harms) H.S.Irwin &amp; Barneby"
)

bdc_clean_names(scientificName, save_outputs = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='bdc_coordinates_country_inconsistent'>Identify records within a reference country</h2><span id='topic+bdc_coordinates_country_inconsistent'></span>

<h3>Description</h3>

<p>This function flags geographic coordinates within a reference country. A
spatial buffer can be added to the reference country to ensure that
records in mangroves, marshes, estuaries, and records with low
coordinate precision are not flagged as invalid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdc_coordinates_country_inconsistent(
  data,
  country_name,
  country = "country_suggested",
  lat = "decimalLatitude",
  lon = "decimalLongitude",
  dist = 0.1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdc_coordinates_country_inconsistent_+3A_data">data</code></td>
<td>
<p>data.frame. Containing longitude and latitude. Coordinates must
be expressed in decimal degrees and WGS84.</p>
</td></tr>
<tr><td><code id="bdc_coordinates_country_inconsistent_+3A_country_name">country_name</code></td>
<td>
<p>character string. Name of the country or countries to be
considered.</p>
</td></tr>
<tr><td><code id="bdc_coordinates_country_inconsistent_+3A_country">country</code></td>
<td>
<p>character string. The column name with the country assignment
of each record. It is
recommended use a column with corrected and homogenized country names.
Default = &quot;country_suggested&quot;.</p>
</td></tr>
<tr><td><code id="bdc_coordinates_country_inconsistent_+3A_lat">lat</code></td>
<td>
<p>character string. The column name with the latitude coordinates.
Default = “decimallatitude”.</p>
</td></tr>
<tr><td><code id="bdc_coordinates_country_inconsistent_+3A_lon">lon</code></td>
<td>
<p>character string. The column name with the longitude coordinates.
Default = “decimallongitude”.</p>
</td></tr>
<tr><td><code id="bdc_coordinates_country_inconsistent_+3A_dist">dist</code></td>
<td>
<p>numeric. The distance in decimal degrees used to created a buffer
around the country. Default = 0.1 (~11 km at the equator).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Multiple countries can be informed, but they are tested separately.
The distance reported in the argument 'dist' is used to create a
buffer around the reference country. Records within the reference country
or at a specified distance from the coastline of the reference country
(i.e., records within the buffer) are flagged as valid (TRUE). Note that
records within the buffer but in other countries are flagged as invalid
(FALSE). Records with invalid (e.g., NA or empty) and out-of-range
coordinates are not tested and returned as TRUE.
</p>


<h3>Value</h3>

<p>A data.frame containing the column
'.coordinates_country_inconsistent'. Compliant (TRUE) if coordinates fall
within the boundaries plus a specified distance (if 'dist' is supplied) of
'country_name'; otherwise &quot;FALSE&quot;.
</p>


<h3>See Also</h3>

<p>Other prefilter: 
<code><a href="#topic+bdc_basisOfRecords_notStandard">bdc_basisOfRecords_notStandard</a>()</code>,
<code><a href="#topic+bdc_coordinates_empty">bdc_coordinates_empty</a>()</code>,
<code><a href="#topic+bdc_coordinates_from_locality">bdc_coordinates_from_locality</a>()</code>,
<code><a href="#topic+bdc_coordinates_outOfRange">bdc_coordinates_outOfRange</a>()</code>,
<code><a href="#topic+bdc_coordinates_transposed">bdc_coordinates_transposed</a>()</code>,
<code><a href="#topic+bdc_country_standardized">bdc_country_standardized</a>()</code>,
<code><a href="#topic+bdc_scientificName_empty">bdc_scientificName_empty</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- data.frame(
  country = c("Brazil", "Brazil", "Bolivia", "Argentina", "Peru"),
  decimalLongitude = c(-40.6003, -39.6, -77.689288, NA, -76.352930),
  decimalLatitude = c(-19.9358, -13.016667, -20.5243, -35.345940, -11.851872)
)

bdc_coordinates_country_inconsistent(
  data = x,
  country_name = c("Brazil", "Peru", "Argentina"),
  country = "country",
  lon = "decimalLongitude",
  lat = "decimalLatitude",
  dist = 0.1 
)

## End(Not run)
</code></pre>

<hr>
<h2 id='bdc_coordinates_empty'>Identify records with empty geographic coordinates</h2><span id='topic+bdc_coordinates_empty'></span>

<h3>Description</h3>

<p>This function flags records missing latitude or longitude coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdc_coordinates_empty(data, lat = "decimalLatitude", lon = "decimalLongitude")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdc_coordinates_empty_+3A_data">data</code></td>
<td>
<p>data.frame. Containing geographical coordinates.</p>
</td></tr>
<tr><td><code id="bdc_coordinates_empty_+3A_lat">lat</code></td>
<td>
<p>character string. The column name with latitude in decimal degrees
and WGS84. Default = &quot;decimalLatitude&quot;.</p>
</td></tr>
<tr><td><code id="bdc_coordinates_empty_+3A_lon">lon</code></td>
<td>
<p>character string. The column with longitude in decimal degrees and
WGS84. Default = &quot;decimalLongitude&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This test identifies records missing geographic coordinates (i.e.,
empty or not applicable <a href="base.html#topic+NA">NA</a> longitude or latitude)
</p>


<h3>Value</h3>

<p>A data.frame containing the column &quot;.coordinates_empty&quot;. Compliant
(TRUE) if 'lat' and 'lon' are not empty; otherwise &quot;FALSE&quot;.
</p>


<h3>See Also</h3>

<p>Other prefilter: 
<code><a href="#topic+bdc_basisOfRecords_notStandard">bdc_basisOfRecords_notStandard</a>()</code>,
<code><a href="#topic+bdc_coordinates_country_inconsistent">bdc_coordinates_country_inconsistent</a>()</code>,
<code><a href="#topic+bdc_coordinates_from_locality">bdc_coordinates_from_locality</a>()</code>,
<code><a href="#topic+bdc_coordinates_outOfRange">bdc_coordinates_outOfRange</a>()</code>,
<code><a href="#topic+bdc_coordinates_transposed">bdc_coordinates_transposed</a>()</code>,
<code><a href="#topic+bdc_country_standardized">bdc_country_standardized</a>()</code>,
<code><a href="#topic+bdc_scientificName_empty">bdc_scientificName_empty</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(
  decimalLatitude = c(19.9358, -13.016667, NA, ""),
  decimalLongitude = c(-40.6003, -39.6, -20.5243, NA)
)

bdc_coordinates_empty(
  data = x,
  lat = "decimalLatitude",
  lon = "decimalLongitude"
)

</code></pre>

<hr>
<h2 id='bdc_coordinates_from_locality'>Identify records lacking or with invalid coordinates but containing locality
information</h2><span id='topic+bdc_coordinates_from_locality'></span>

<h3>Description</h3>

<p>This function Identifies records whose coordinates can potentially be
extracted from locality information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdc_coordinates_from_locality(
  data,
  lat = "decimalLatitude",
  lon = "decimalLongitude",
  locality = "locality",
  save_outputs = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdc_coordinates_from_locality_+3A_data">data</code></td>
<td>
<p>data.frame. Containing geographical coordinates and the column
&quot;locality'.</p>
</td></tr>
<tr><td><code id="bdc_coordinates_from_locality_+3A_lat">lat</code></td>
<td>
<p>character string. The column name with latitude in decimal degrees
and WGS84. Default = &quot;decimalLatitude&quot;.</p>
</td></tr>
<tr><td><code id="bdc_coordinates_from_locality_+3A_lon">lon</code></td>
<td>
<p>character string. The column with longitude in decimal degrees and
WGS84. Default = &quot;decimalLongitude&quot;.</p>
</td></tr>
<tr><td><code id="bdc_coordinates_from_locality_+3A_locality">locality</code></td>
<td>
<p>character string. The column name with locality information.
Default = &quot;locality&quot;.</p>
</td></tr>
<tr><td><code id="bdc_coordinates_from_locality_+3A_save_outputs">save_outputs</code></td>
<td>
<p>logical. Should a table containing transposed coordinates
saved for further inspection? Default = FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>According to DarwinCore terminology, locality refers to &quot;the
specific description of the place&quot; where an organism was recorded.
</p>


<h3>Value</h3>

<p>A data.frame containing records missing or with invalid coordinates
but with potentially useful locality information. When save_outputs = FALSE
the data.frame is saved in Output/Check/01_coordinates_from_locality.csv
</p>


<h3>See Also</h3>

<p>Other prefilter: 
<code><a href="#topic+bdc_basisOfRecords_notStandard">bdc_basisOfRecords_notStandard</a>()</code>,
<code><a href="#topic+bdc_coordinates_country_inconsistent">bdc_coordinates_country_inconsistent</a>()</code>,
<code><a href="#topic+bdc_coordinates_empty">bdc_coordinates_empty</a>()</code>,
<code><a href="#topic+bdc_coordinates_outOfRange">bdc_coordinates_outOfRange</a>()</code>,
<code><a href="#topic+bdc_coordinates_transposed">bdc_coordinates_transposed</a>()</code>,
<code><a href="#topic+bdc_country_standardized">bdc_country_standardized</a>()</code>,
<code><a href="#topic+bdc_scientificName_empty">bdc_scientificName_empty</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(
  lat = c(NA, NA, ""), 
  lon = c("", NA, NA), 
  locality = c("PARAGUAY: ALTO PARAGUAY: CO.; 64KM W PUERTO SASTRE", 
               "Parque Estadual da Serra de Caldas Novas, Goias, Brazil", 
               "Parque Nacional Iguazu"))

bdc_coordinates_from_locality(
data = x, 
lat = "lat", 
lon = "lon", 
locality = "locality", 
save_outputs = FALSE)

</code></pre>

<hr>
<h2 id='bdc_coordinates_outOfRange'>Identify records with out-of-range geographic coordinates</h2><span id='topic+bdc_coordinates_outOfRange'></span>

<h3>Description</h3>

<p>This function identifies records with out-of-range coordinates (not between
-90 and 90 for latitude; between -180 and 180 for longitude).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdc_coordinates_outOfRange(
  data,
  lat = "decimalLatitude",
  lon = "decimalLongitude"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdc_coordinates_outOfRange_+3A_data">data</code></td>
<td>
<p>data.frame. Containing geographical coordinates. Coordinates must
be expressed in decimal degrees and WGS84.</p>
</td></tr>
<tr><td><code id="bdc_coordinates_outOfRange_+3A_lat">lat</code></td>
<td>
<p>character string. The column name with latitude in decimal degree
and in WGS84. Default = &quot;decimalLatitude&quot;.</p>
</td></tr>
<tr><td><code id="bdc_coordinates_outOfRange_+3A_lon">lon</code></td>
<td>
<p>character string. The column with longitude in decimal degree and
in WGS84. Default = &quot;decimalLongitude&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame containing the column &quot;.coordinates_outOfRange&quot;.
Compliant (TRUE) if 'lat' and 'lon' are not out-of-range; otherwise
&quot;FALSE&quot;.
</p>


<h3>See Also</h3>

<p>Other prefilter: 
<code><a href="#topic+bdc_basisOfRecords_notStandard">bdc_basisOfRecords_notStandard</a>()</code>,
<code><a href="#topic+bdc_coordinates_country_inconsistent">bdc_coordinates_country_inconsistent</a>()</code>,
<code><a href="#topic+bdc_coordinates_empty">bdc_coordinates_empty</a>()</code>,
<code><a href="#topic+bdc_coordinates_from_locality">bdc_coordinates_from_locality</a>()</code>,
<code><a href="#topic+bdc_coordinates_transposed">bdc_coordinates_transposed</a>()</code>,
<code><a href="#topic+bdc_country_standardized">bdc_country_standardized</a>()</code>,
<code><a href="#topic+bdc_scientificName_empty">bdc_scientificName_empty</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(
  decimalLatitude = c(-185.111, -43.34, "", -21.8069444),
  decimalLongitude = c(-45.4, -39.6, -20.5243, -440.9055555)
)

bdc_coordinates_outOfRange(
  data = x,
  lat = "decimalLatitude",
  lon = "decimalLongitude"
)

</code></pre>

<hr>
<h2 id='bdc_coordinates_precision'>Flag low-precise geographic coordinates</h2><span id='topic+bdc_coordinates_precision'></span>

<h3>Description</h3>

<p>This function flags records with a coordinate precision below a
specified number of decimal places. Coordinates with one, two, or three
decimal places present a precision of~11.1 km, ~1.1 km, and ~111 m at the
equator, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdc_coordinates_precision(
  data,
  lat = "decimalLatitude",
  lon = "decimalLongitude",
  ndec = c(0, 1, 2)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdc_coordinates_precision_+3A_data">data</code></td>
<td>
<p>data.frame. A data.frame containing geographic coordinates.</p>
</td></tr>
<tr><td><code id="bdc_coordinates_precision_+3A_lat">lat</code></td>
<td>
<p>character string. The column with latitude in decimal degrees and
WGS84. Default = &quot;decimalLatitude&quot;.</p>
</td></tr>
<tr><td><code id="bdc_coordinates_precision_+3A_lon">lon</code></td>
<td>
<p>character string. The column with longitude in decimal degrees and
WGS84. Default = &quot;decimalLongitude&quot;.</p>
</td></tr>
<tr><td><code id="bdc_coordinates_precision_+3A_ndec">ndec</code></td>
<td>
<p>numeric. The minimum number of decimal places that the
coordinates should
have to be considered valid. Default = 2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with logical values indicating whether values are equal
or higher than the specified minimum decimal number (ndec). Coordinates
flagged as FALSE in .rou column are considered imprecise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(
  lat = c(-21.34, 23.567, 16.798, -10.468),
  lon = c(-55.38, -13.897, 30.8, 90.675)
)

bdc_coordinates_precision(
  data = x,
  lat = "lat",
  lon = "lon",
  ndec = 3
)

</code></pre>

<hr>
<h2 id='bdc_coordinates_transposed'>Identify transposed geographic coordinates</h2><span id='topic+bdc_coordinates_transposed'></span>

<h3>Description</h3>

<p>This function flags and corrects records when latitude and longitude appear
to be transposed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdc_coordinates_transposed(
  data,
  id = "database_id",
  sci_names = "scientificName",
  lat = "decimalLatitude",
  lon = "decimalLongitude",
  country = "country",
  countryCode = "countryCode",
  border_buffer = 0.2,
  save_outputs = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdc_coordinates_transposed_+3A_data">data</code></td>
<td>
<p>data.frame. Containing a unique identifier for each record,
geographical coordinates, and country names. Coordinates must be expressed
in decimal degrees and WGS84.</p>
</td></tr>
<tr><td><code id="bdc_coordinates_transposed_+3A_id">id</code></td>
<td>
<p>character string. The column name with a unique record identifier.
Default = &quot;database_id&quot;.</p>
</td></tr>
<tr><td><code id="bdc_coordinates_transposed_+3A_sci_names">sci_names</code></td>
<td>
<p>character string. The column name with species scientific
name. Default = &quot;scientificName&quot;.</p>
</td></tr>
<tr><td><code id="bdc_coordinates_transposed_+3A_lat">lat</code></td>
<td>
<p>character string. The column name with latitude. Coordinates must
be expressed in decimal degrees and WGS84. Default = &quot;decimalLatitude&quot;.</p>
</td></tr>
<tr><td><code id="bdc_coordinates_transposed_+3A_lon">lon</code></td>
<td>
<p>character string. The column with longitude. Coordinates must be
expressed in decimal degrees and WGS84. Default = &quot;decimalLongitude&quot;.</p>
</td></tr>
<tr><td><code id="bdc_coordinates_transposed_+3A_country">country</code></td>
<td>
<p>character string. The column name with the country
assignment of each record. Default = &quot;country&quot;.</p>
</td></tr>
<tr><td><code id="bdc_coordinates_transposed_+3A_countrycode">countryCode</code></td>
<td>
<p>character string. The column name with an ISO-2 country
code.</p>
</td></tr>
<tr><td><code id="bdc_coordinates_transposed_+3A_border_buffer">border_buffer</code></td>
<td>
<p>numeric &gt;= 0. A distance in decimal degrees used to
created a buffer around the country. Records within a given country and at
a specified distance from the border will be not be corrected.
Default = 0.2 (~22 km at the equator).</p>
</td></tr>
<tr><td><code id="bdc_coordinates_transposed_+3A_save_outputs">save_outputs</code></td>
<td>
<p>logical. Should a table containing transposed coordinates
saved for further inspection? Default = FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This test identifies transposed coordinates resulted from mismatches
between the country informed for a record and coordinates. Transposed
coordinates often fall outside of the indicated country (i.e., in other
countries or in the sea). Different coordinate transformations are
performed to correct country/coordinates mismatches. Importantly, verbatim
coordinates are replaced by the corrected ones in the returned database. A
database containing verbatim and corrected coordinates is created in
&quot;Output/Check/01_coordinates_transposed.csv&quot; if save_outputs == TRUE. The
columns &quot;country&quot; and &quot;countryCode&quot; can be retrieved by using the function
<code><a href="#topic+bdc_country_standardized">bdc_country_standardized</a></code>.
</p>


<h3>Value</h3>

<p>A data.frame containing the column &quot;coordinates_transposed&quot;
indicating if verbatim coordinates were not transposed (TRUE). Otherwise
records are flagged as (FALSE) and, in this case, verbatim coordinates are
replaced by corrected coordinates.
</p>


<h3>See Also</h3>

<p>Other prefilter: 
<code><a href="#topic+bdc_basisOfRecords_notStandard">bdc_basisOfRecords_notStandard</a>()</code>,
<code><a href="#topic+bdc_coordinates_country_inconsistent">bdc_coordinates_country_inconsistent</a>()</code>,
<code><a href="#topic+bdc_coordinates_empty">bdc_coordinates_empty</a>()</code>,
<code><a href="#topic+bdc_coordinates_from_locality">bdc_coordinates_from_locality</a>()</code>,
<code><a href="#topic+bdc_coordinates_outOfRange">bdc_coordinates_outOfRange</a>()</code>,
<code><a href="#topic+bdc_country_standardized">bdc_country_standardized</a>()</code>,
<code><a href="#topic+bdc_scientificName_empty">bdc_scientificName_empty</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
id &lt;- c(1, 2, 3, 4)
scientificName &lt;- c(
  "Rhinella major", "Scinax ruber",
  "Siparuna guianensis", "Psychotria vellosiana"
)
decimalLatitude &lt;- c(63.43333, -14.43333, -41.90000, -46.69778)
decimalLongitude &lt;- c(-17.90000, -67.91667, -13.25000, -13.82444)
country &lt;- c("BOLIVIA", "bolivia", "Brasil", "Brazil")

x &lt;- data.frame(
  id, scientificName, decimalLatitude,
  decimalLongitude, country
)

# Get country code
x &lt;- bdc_country_standardized(data = x, country = "country")

bdc_coordinates_transposed(
  data = x,
  id = "id",
  sci_names = "scientificName",
  lat = "decimalLatitude",
  lon = "decimalLongitude",
  country = "country_suggested",
  countryCode = "countryCode",
  border_buffer = 0.2,
  save_outputs = FALSE 
) 

## End(Not run)

</code></pre>

<hr>
<h2 id='bdc_country_from_coordinates'>Get country names from coordinates</h2><span id='topic+bdc_country_from_coordinates'></span>

<h3>Description</h3>

<p>Country names derived from valid geographic coordinates are added to records
missing country names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdc_country_from_coordinates(
  data,
  lat = "decimalLatitude",
  lon = "decimalLongitude",
  country = "country"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdc_country_from_coordinates_+3A_data">data</code></td>
<td>
<p>data.frame. Containing geographical coordinates and country
names.</p>
</td></tr>
<tr><td><code id="bdc_country_from_coordinates_+3A_lat">lat</code></td>
<td>
<p>character string. The column name with latitude in decimal
degrees
and WGS84. Default = &quot;decimalLatitude&quot;.</p>
</td></tr>
<tr><td><code id="bdc_country_from_coordinates_+3A_lon">lon</code></td>
<td>
<p>character string. The column with longitude in decimal degrees and
WGS84. Default = &quot;decimalLongitude&quot;.</p>
</td></tr>
<tr><td><code id="bdc_country_from_coordinates_+3A_country">country</code></td>
<td>
<p>character string. The column name with the country assignment
of each record. Default = &quot;country&quot;. If no column name is provided a new
column &quot;country&quot; is created.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function assigns a country name for records missing such
information. Country names are extracted from valid geographic coordinates
using a high-quality map of the world (rnaturalearth package). No
country name is added to records whose coordinates are in the sea.
</p>


<h3>Value</h3>

<p>A tibble containing country names for records missing such
information.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
x &lt;- data.frame(
  decimalLatitude = c(-22.9834, -39.857030, -17.06811, -46.69778),
  decimalLongitude = c(-69.095, -68.443588, 37.438108, -13.82444),
  country = c("", NA, NA, "Brazil"))

bdc_country_from_coordinates(
  data = x,
  lat = "decimalLatitude",
  lon = "decimalLongitude",
  country = "country"
)

## End(Not run)
</code></pre>

<hr>
<h2 id='bdc_country_standardized'>Standardizes country names and gets country code</h2><span id='topic+bdc_country_standardized'></span>

<h3>Description</h3>

<p>This function standardizes country names and adds a new column to the
database containing two-letter country codes (ISO 3166-1 alpha-2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdc_country_standardized(data, country = "country")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdc_country_standardized_+3A_data">data</code></td>
<td>
<p>data.frame. Containing country names</p>
</td></tr>
<tr><td><code id="bdc_country_standardized_+3A_country">country</code></td>
<td>
<p>character string. The column name with the country assignment
of each record. Default = &quot;country&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Country names are standardized using an exact matching against a
list of country names in several languages from International Organization for Standardization. If any unmatched
names remain,  a fuzzy matching algorithm is used to find potential
candidates for each misspelled countries names.
</p>


<h3>Value</h3>

<p>A data.frame containing two columns: country_suggested (standardized
country names) and country_code (two-letter country codes; more details in
<a href="https://github.com/stefangabos/world_countries/">World Countries, International Organization for Standardization</a>).
</p>


<h3>See Also</h3>

<p>Other prefilter: 
<code><a href="#topic+bdc_basisOfRecords_notStandard">bdc_basisOfRecords_notStandard</a>()</code>,
<code><a href="#topic+bdc_coordinates_country_inconsistent">bdc_coordinates_country_inconsistent</a>()</code>,
<code><a href="#topic+bdc_coordinates_empty">bdc_coordinates_empty</a>()</code>,
<code><a href="#topic+bdc_coordinates_from_locality">bdc_coordinates_from_locality</a>()</code>,
<code><a href="#topic+bdc_coordinates_outOfRange">bdc_coordinates_outOfRange</a>()</code>,
<code><a href="#topic+bdc_coordinates_transposed">bdc_coordinates_transposed</a>()</code>,
<code><a href="#topic+bdc_scientificName_empty">bdc_scientificName_empty</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
country &lt;- c("BOLIVIA", "bolivia", "Brasil", "Brazil", "BREZIL")
x &lt;- data.frame(country)

bdc_country_standardized(
  data = x,
  country = "country"
)

## End(Not run)

</code></pre>

<hr>
<h2 id='bdc_create_figures'>Create figures reporting the results of the bdc package</h2><span id='topic+bdc_create_figures'></span>

<h3>Description</h3>

<p>Creates figures (i.e., bar plots, maps, and histograms) reporting the results
of data quality tests implemented in the bdc package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdc_create_figures(
  data,
  database_id = "database_id",
  workflow_step = NULL,
  save_figures = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdc_create_figures_+3A_data">data</code></td>
<td>
<p>data.frame. Containing the results of data quality tests; that
is, columns starting wit &quot;.&quot;.</p>
</td></tr>
<tr><td><code id="bdc_create_figures_+3A_database_id">database_id</code></td>
<td>
<p>character string. The column name with a unique record
identifier. Default = &quot;database_id&quot;.</p>
</td></tr>
<tr><td><code id="bdc_create_figures_+3A_workflow_step">workflow_step</code></td>
<td>
<p>character string. Name of the workflow step. Options
available are &quot;prefilter&quot;, &quot;space&quot;, and &quot;time&quot;.</p>
</td></tr>
<tr><td><code id="bdc_create_figures_+3A_save_figures">save_figures</code></td>
<td>
<p>logical. Should the figures be saved for further
inspection? Default = FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function creates figures based on the results of data quality
tests implemented. A pre-defined list of test names is used for creating
figures depending on the name of the workflow step informed. Figures are
saved in &quot;Output/Figures&quot; if save_figures == TRUE.
</p>


<h3>Value</h3>

<p>List containing figures showing the results of data quality test
implemented in one module of bdc. When save_figures = TRUE, figures are
also saved locally in a png format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
database_id &lt;- c("GBIF_01", "GBIF_02", "GBIF_03", "FISH_04", "FISH_05")
lat &lt;- c(-19.93580, -13.01667, -22.34161, -6.75000, -15.15806)
lon &lt;- c(-40.60030, -39.60000, -49.61017, -35.63330, -39.52861)
.scientificName_emptys &lt;- c(TRUE, TRUE, TRUE, FALSE, FALSE)
.coordinates_empty &lt;- c(TRUE, TRUE, TRUE, TRUE, TRUE)
.invalid_basis_of_records &lt;- c(TRUE, FALSE, TRUE, FALSE, TRUE)
.summary &lt;- c(TRUE, FALSE, TRUE, FALSE, FALSE)

x &lt;- data.frame(
  database_id,
  lat,
  lon,
  .scientificName_emptys,
  .coordinates_empty,
  .invalid_basis_of_records,
  .summary
)

figures &lt;- 
bdc_create_figures(
  data = x, 
  database_id = "database_id",
  workflow_step = "prefilter",
  save_figures = FALSE
)

## End(Not run)
</code></pre>

<hr>
<h2 id='bdc_create_report'>Create a report summarizing the results of data quality tests</h2><span id='topic+bdc_create_report'></span>

<h3>Description</h3>

<p>Create a report summarizing the results of data quality tests
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdc_create_report(
  data,
  database_id = "database_id",
  workflow_step,
  save_report = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdc_create_report_+3A_data">data</code></td>
<td>
<p>data.frame. Containing a unique identifier for each record and
the results of data quality tests.</p>
</td></tr>
<tr><td><code id="bdc_create_report_+3A_database_id">database_id</code></td>
<td>
<p>character string. The column name with a unique record
identifier.Default = &quot;database_id&quot;.</p>
</td></tr>
<tr><td><code id="bdc_create_report_+3A_workflow_step">workflow_step</code></td>
<td>
<p>character string containing the following
options(&quot;prefilter&quot;, &quot;taxonomy&quot;, &quot;space&quot; or &quot;time&quot;).</p>
</td></tr>
<tr><td><code id="bdc_create_report_+3A_save_report">save_report</code></td>
<td>
<p>logical. Should the report be saved for further
inspection? Default = FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame containing a report summarizing the results of data
quality assessment.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
database_id &lt;- c("test_1", "test_2", "test_3", "test_4", "test_5")
.missing_names &lt;- c(TRUE, TRUE, TRUE, FALSE, FALSE)
.missing_coordinates &lt;- c(TRUE, FALSE, FALSE, TRUE, FALSE)
.basisOfRecords_notStandard &lt;- c(TRUE, TRUE, FALSE, TRUE, TRUE)
.summary &lt;- c(TRUE, FALSE, FALSE, FALSE, FALSE)

x &lt;- data.frame(
  database_id,
  .missing_names,
  .missing_coordinates,
  .basisOfRecords_notStandard,
  .summary
)

report &lt;- 
bdc_create_report(
  data = x,
  database_id = "database_id",
  workflow_step = "prefilter",
  save_report = FALSE
)

## End(Not run)

</code></pre>

<hr>
<h2 id='bdc_eventDate_empty'>Identify records with empty event date</h2><span id='topic+bdc_eventDate_empty'></span>

<h3>Description</h3>

<p>This function identifies records missing information on an event date (i.e.,
when a record was collected or observed).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdc_eventDate_empty(data, eventDate = "eventDate")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdc_eventDate_empty_+3A_data">data</code></td>
<td>
<p>A data frame containing column with event date information.</p>
</td></tr>
<tr><td><code id="bdc_eventDate_empty_+3A_eventdate">eventDate</code></td>
<td>
<p>Numeric or date. The column with event date information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This test identifies records missing event date information (i.e.,
empty or not applicable <a href="base.html#topic+NA">NA</a>).
</p>


<h3>Value</h3>

<p>A data.frame containing the column &quot;.eventDate_empty&quot;. Compliant
(TRUE) if 'eventDate' is not empty; otherwise &quot;FALSE&quot;.
</p>


<h3>See Also</h3>

<p>Other time: 
<code><a href="#topic+bdc_year_from_eventDate">bdc_year_from_eventDate</a>()</code>,
<code><a href="#topic+bdc_year_outOfRange">bdc_year_outOfRange</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>collection_date &lt;- c(
  NA, "31/12/2015", "2013-06-13T00:00:00Z", "2013-06-20",
  "", "2013", "0001-01-00"
)
x &lt;- data.frame(collection_date)

bdc_eventDate_empty(data = x, eventDate = "collection_date")

</code></pre>

<hr>
<h2 id='bdc_filter_out_flags'>Remove columns with the results of data quality tests</h2><span id='topic+bdc_filter_out_flags'></span>

<h3>Description</h3>

<p>This function filters out columns containing the results of data quality
tests (i.e., columns starting with '.') or other columns specified.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdc_filter_out_flags(data, col_to_remove = "all")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdc_filter_out_flags_+3A_data">data</code></td>
<td>
<p>data.frame. Containing columns to be removed.</p>
</td></tr>
<tr><td><code id="bdc_filter_out_flags_+3A_col_to_remove">col_to_remove</code></td>
<td>
<p>logical. Which columns should be removed? Default =
&quot;all&quot;, which means that all columns containing the results of data quality
tests are removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame without columns specified in 'col_to_remove'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(
  database_id = c("test_1", "test_2", "test_3", "test_4", "test_5"),
   kindom = c("Plantae", "Plantae", "Animalia", "Animalia", "Plantae"),
  .bdc_scientificName_empty = c(TRUE, TRUE, TRUE, FALSE, FALSE),
  .bdc_coordinates_empty = c(TRUE, FALSE, FALSE, FALSE, FALSE),
  .bdc_coordinates_outOfRange = c(TRUE, FALSE, FALSE, FALSE, FALSE),
  .summary = c(TRUE, FALSE, FALSE, FALSE, FALSE)
)

bdc_filter_out_flags(
  data = x,
  col_to_remove = "all"
)

</code></pre>

<hr>
<h2 id='bdc_filter_out_names'>Filter out records according to their taxonomic status</h2><span id='topic+bdc_filter_out_names'></span>

<h3>Description</h3>

<p>This function is useful for selecting records according to their taxonomic
status.  By default, only records with accepted scientific names are
returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdc_filter_out_names(
  data,
  col_name = "notes",
  taxonomic_status = "accepted",
  opposite = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdc_filter_out_names_+3A_data">data</code></td>
<td>
<p>data.frame. Containing the column &quot;notes&quot; with information on the
taxonomic status of scientific names.</p>
</td></tr>
<tr><td><code id="bdc_filter_out_names_+3A_col_name">col_name</code></td>
<td>
<p>character string. The column name containing notes
about the taxonomic status of a name. Default = &quot;notes&quot;.</p>
</td></tr>
<tr><td><code id="bdc_filter_out_names_+3A_taxonomic_status">taxonomic_status</code></td>
<td>
<p>character string. Taxonomic status of a name. Default
= &quot;accepted&quot;.</p>
</td></tr>
<tr><td><code id="bdc_filter_out_names_+3A_opposite">opposite</code></td>
<td>
<p>logical. Should taxonomic status different from those listed
in 'taxonomic_status' be returned? Default = FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default, only records with accepted scientific names are kept in
the database. Such records are listed in the column 'taxonomic_status' as
&quot;accepted&quot;, &quot;accepted | replaceSynonym&quot;,  &quot;accepted | wasMisspelled&quot; or
&quot;accepted | wasMisspelled | replaceSynonym&quot;. It is also possible to
customize the list of taxonomic notes to be kept in the argument
'taxonomic_status'. See 'notes' in the data.frame resulted from the function
<code><a href="#topic+bdc_create_report">bdc_create_report</a></code>. If 'opposite' is TRUE, records with notes
different from names listed in 'taxonomic_status' are returned.
</p>


<h3>Value</h3>

<p>A data.frame filtered out according to names listed in
'taxonomic_status'.
</p>


<h3>See Also</h3>

<p>Other taxonomy: 
<code><a href="#topic+bdc_clean_names">bdc_clean_names</a>()</code>,
<code><a href="#topic+bdc_query_names_taxadb">bdc_query_names_taxadb</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df_notes &lt;-
  data.frame(
    notes = c(
      "notFound", "accepted", "accepted | replaceSynonym",
      "accepted | wasMisspelled",
      "accepted | wasMisspelled | replaceSynonym",
      "multipleAccepted",
      "heterotypic synonym"
    )
  )

bdc_filter_out_names(
  data = df_notes,
  taxonomic_status = "accepted",
  col_name = "notes",
  opposite = FALSE
)

</code></pre>

<hr>
<h2 id='bdc_query_names_taxadb'>Harmonizing taxon names against local stored taxonomic databases</h2><span id='topic+bdc_query_names_taxadb'></span>

<h3>Description</h3>

<p>Harmonizing taxon names against local stored taxonomic databases
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdc_query_names_taxadb(
  sci_name,
  replace_synonyms = TRUE,
  suggest_names = TRUE,
  suggestion_distance = 0.9,
  db = "gbif",
  rank_name = NULL,
  rank = NULL,
  parallel = FALSE,
  ncores = 2,
  export_accepted = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdc_query_names_taxadb_+3A_sci_name">sci_name</code></td>
<td>
<p>character string. Containing scientific names to be queried.</p>
</td></tr>
<tr><td><code id="bdc_query_names_taxadb_+3A_replace_synonyms">replace_synonyms</code></td>
<td>
<p>logical. Should synonyms be replaced by accepted
names? Default = TRUE.</p>
</td></tr>
<tr><td><code id="bdc_query_names_taxadb_+3A_suggest_names">suggest_names</code></td>
<td>
<p>logical. Tries to find potential candidate names for
misspelled names not resolved by an exact match. Default = TRUE.</p>
</td></tr>
<tr><td><code id="bdc_query_names_taxadb_+3A_suggestion_distance">suggestion_distance</code></td>
<td>
<p>numeric. A threshold value determining the
acceptable orthographical distance between searched and candidate names.
Names with matching distance value lower threshold informed are returned as
NA. Default = 0.9.</p>
</td></tr>
<tr><td><code id="bdc_query_names_taxadb_+3A_db">db</code></td>
<td>
<p>character string. The name of the taxonomic database to
be used in harmonizing taxon names. Default = &quot;gbif&quot;.
Use &quot;all&quot; to install all available taxonomic databases automatically.</p>
</td></tr>
<tr><td><code id="bdc_query_names_taxadb_+3A_rank_name">rank_name</code></td>
<td>
<p>character string. Taxonomic rank name (e.g. &quot;Plantae&quot;,
&quot;Animalia&quot;, &quot;Aves&quot;, &quot;Carnivora&quot;. Default = NULL.</p>
</td></tr>
<tr><td><code id="bdc_query_names_taxadb_+3A_rank">rank</code></td>
<td>
<p>character string. A taxonomic rank used to filter the
taxonomic database. Options available are: &quot;kingdom&quot;, &quot;phylum&quot;, &quot;class&quot;,
&quot;order&quot;, &quot;family&quot;, and &quot;genus&quot;.</p>
</td></tr>
<tr><td><code id="bdc_query_names_taxadb_+3A_parallel">parallel</code></td>
<td>
<p>logical. Should a parallelization process be used?
Default=FALSE</p>
</td></tr>
<tr><td><code id="bdc_query_names_taxadb_+3A_ncores">ncores</code></td>
<td>
<p>numeric. The number of cores to run in parallel.</p>
</td></tr>
<tr><td><code id="bdc_query_names_taxadb_+3A_export_accepted">export_accepted</code></td>
<td>
<p>logical. Should a table containing records
with names linked to multiple accepted names saved for further
inspection. Default = FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The taxonomic harmonization is based upon one taxonomic authority database.
The lastest version of each database is used to perform queries, but
note that only older versions are available for some taxonomic databases. The
database version is shown in parenthesis. Note that some databases are
momentary unavailable in taxadb.
</p>

<ul>
<li> <p><strong>itis</strong>: Integrated Taxonomic Information System (v. 2022)
</p>
</li>
<li> <p><strong>ncbi</strong>: National Center for Biotechnology Information (v. 2022)
</p>
</li>
<li> <p><strong>col</strong>: Catalogue of Life (v. 2022)
</p>
</li>
<li> <p><strong>tpl</strong>: The Plant List (v. 2019)
</p>
</li>
<li> <p><strong>gbif</strong>: Global Biodiversity Information Facility (v. 2022)
</p>
</li>
<li> <p><strong>fb</strong>: FishBase (v. 2019)
</p>
</li>
<li> <p><strong>slb</strong>: SeaLifeBase (unavailable)
</p>
</li>
<li> <p><strong>wd</strong>: Wikidata (unavailable)
</p>
</li>
<li> <p><strong>ott</strong>: OpenTree Taxonomy (v. 2021)
</p>
</li>
<li> <p><strong>iucn</strong>: International Union for Conservation of Nature (v. 2019)
</p>
</li></ul>

<p>The bdc_query_names_taxadb processes as this:
</p>
<p><strong>Creation of a local taxonomic database</strong>
</p>
<p>This is a one-time setup used to download, extract, and import the taxonomic
databases specified in the argument &quot;db&quot;. The downloading process may take a
few minutes depending on your connection and database size. By default, the
&quot;gbif&quot; database following a Darwin Core schema is installed. (see
?taxadb::td_create for details).
</p>
<p><strong>Taxonomic harmonization</strong>
</p>
<p>The taxonomic harmonization is divided into two distinct phases according to
the matching type to be undertaken.
</p>
<p><strong>Exact matching</strong>
</p>
<p>Firstly, the algorithm attempts to find an exact matching
for each original scientific name supplied using the function &quot;filter_name&quot;
from taxadb package. If an exact matching cannot be found, names are returned
as Not Available (NA). Also, it is possible that a scientific name match
multiple accepted names. In such cases, the &quot;bdc_clean_duplicates&quot; function
is used to flag and remove names with multiple accepted names.
</p>
<p>Information on higher taxa (e.g., kingdom or phylum) can be used to
disambiguate names linked to multiple accepted names. For example, the genus
&quot;Casearia&quot; is present in both Animalia and Plantae kingdoms. When handling
names of Plantae, it would be helpful to get rid of names belonging to the
Animalia to avoid flagging &quot;Caseria&quot; as having multiple accepted names.
Following Norman et al. (2020), such cases are left to be fixed by the user.
If &quot;export_accepted&quot; = TRUE a database containing a list of all records with
names linked to multiple accepted names is saved in the &quot;Output&quot; folder.
</p>
<p><strong>Fuzzy matching</strong>
</p>
<p>Fuzzy matching will be applied when &quot;suggest_names&quot; is TRUE and only for
names not resolved by an exact match. In such cases, a fuzzy matching
algorithm processes name-matching queries to find a potential matching
candidate from the specified taxonomic database. Fuzzy matching identifies
probable names (here identified as suggested names) for original names via a
measure of orthographic similarity (i.e., distance). Orthographic distance is
calculated by optimal string alignment (restricted Damerau-Levenshtein
distance) that counts the number of deletions, insertions, substitutions, and
adjacent characters' transpositions. It ranges from 0 to 1, being 1 an
indicative of a perfect match. A threshold distance, i.e. the lower value of
match acceptable, can be informed by user (in the &quot;suggest_distance&quot;
argument). If the distance of a candidate name is equal or higher than the
distance informed by user, the candidate name is returned as suggested name.
Otherwise, names are returned as NA.
</p>
<p>To increase the probability of finding a potential match candidate and to
save time, two steps are taken before conducting fuzzy matching. First, if
supplied, information on higher taxon (e.g., kingdom, family) is used to
filter the taxonomic database. This step removes matching ambiguity by
avoiding matching names from unrelated taxonomic ranks (e.g., match a plant
species against a taxonomic database containing animal names) and decreases
the number of names in the taxonomic database used to calculate the matching
distance. Then, the taxonomic database is filtered according to a set of
firsts letters of all input names. This process reduces the number of names
in the taxonomic database to which each original name should be compared When
a same suggested name is returned for different input names, a warning is
returned asking users to check whether the suggested name is valid.
</p>
<p><strong>Report</strong>
</p>
<p>The name harmonization processes' quality can be accessed in the column
&quot;notes&quot; placed in the table resulting from the name harmonization process.
The column &quot;notes&quot; contains assertions on the name harmonization process
based on Carvalho (2017). The notes can be grouped in two categories:
accepted names and those with a taxonomic issue or warning, needing further
inspections. Accepted names can be returned as &quot;accepted&quot; (valid accepted
name), &quot;replaceSynonym&quot; (a synonym replaced by an accepted name),
&quot;wasMisspelled&quot; (original name was misspelled), &quot;wasMisspelled |
replaceSynonym&quot; (misspelled synonym replaced by an accepted name), and
&quot;synonym&quot; (original names is a synonym without accepted names in the
database). Similarly, the following notes are used to flag taxonomic issues:
&quot;notFound&quot; (no matching name found), &quot;multipleAccepted&quot; (name with multiple
accepted names), &quot;noAcceptedName&quot; (no accepted name found), and ambiguous
synonyms such as &quot;heterotypic synonym&quot;, &quot;homotypic synonym&quot;, and &quot;pro-parte
synonym&quot;. Ambiguous synonyms, names that have been published more than once
describing different species, have more than one accepted name and cannot be
resolved. Such cases are flagged and left to be determined by the user.
</p>


<h3>Value</h3>

<p>This function returns data.frame containing the results of the
taxonomic harmonization process. The database is returned in the same order
of sci_name.
</p>


<h3>See Also</h3>

<p>Other taxonomy: 
<code><a href="#topic+bdc_clean_names">bdc_clean_names</a>()</code>,
<code><a href="#topic+bdc_filter_out_names">bdc_filter_out_names</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
if (interactive()) {
  sci_name &lt;- c(
    "Polystachya estrellensis",
    "Tachigali rubiginosa",
    "Oxalis rhombeo ovata",
    "Axonopus canescens",
    "Prosopis",
    "Haematococcus salinus",
    "Monas pulvisculus",
    "Cryptomonas lenticulari",
    "Poincianella pyramidalis",
    "Hymenophyllum polyanthos"
  )

  names_harmonization &lt;-
    bdc_query_names_taxadb(
      sci_name,
      replace_synonyms = TRUE,
      suggest_names = TRUE,
      suggestion_distance = 0.9,
      db = "gbif",
      parallel = TRUE,
      ncores = 2,
      export_accepted = FALSE
    )
}

</code></pre>

<hr>
<h2 id='bdc_quickmap'>Create a map of points using ggplot2</h2><span id='topic+bdc_quickmap'></span>

<h3>Description</h3>

<p>Creates a map of points using ggplot2 useful for inspecting the results of
tests implemented in the bdc package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdc_quickmap(
  data,
  lat = "decimalLatitude",
  lon = "decimalLongitude",
  col_to_map = "red",
  size = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdc_quickmap_+3A_data">data</code></td>
<td>
<p>data.frame. Containing geographical coordinates. Coordinates must
be expressed in decimal degree and in WGS84.</p>
</td></tr>
<tr><td><code id="bdc_quickmap_+3A_lat">lat</code></td>
<td>
<p>character string. The column name with latitude. Coordinates must
be expressed in decimal degree and in WGS84. Default = &quot;decimalLatitude&quot;.</p>
</td></tr>
<tr><td><code id="bdc_quickmap_+3A_lon">lon</code></td>
<td>
<p>character string. The column with longitude. Coordinates must be
expressed in decimal degree and in WGS84. Default = &quot;decimalLongitude&quot;.</p>
</td></tr>
<tr><td><code id="bdc_quickmap_+3A_col_to_map">col_to_map</code></td>
<td>
<p>character string. Defining the column or color used to map.
It can be a color name (e.g., &quot;red&quot;) or the name of a column of data. Default
= &quot;blue&quot;</p>
</td></tr>
<tr><td><code id="bdc_quickmap_+3A_size">size</code></td>
<td>
<p>numeric. The size of the points.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only records with valid coordinates can be plotted. Records missing
or containing invalid coordinates are removed prior creating the map.
</p>


<h3>Value</h3>

<p>A map of points created using ggplot2.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
decimalLatitude &lt;- c(19.9358, -13.016667, -19.935800)
decimalLongitude &lt;- c(-40.6003, -39.6, -40.60030)
.coordinates_out_country &lt;- c(FALSE, TRUE, TRUE)
x &lt;- data.frame(decimalLatitude, decimalLongitude, .coordinates_out_country)

bdc_quickmap(
  data = x,
  lat = "decimalLatitude",
  lon = "decimalLongitude",
  col_to_map = ".coordinates_out_country",
  size = 1
)

</code></pre>

<hr>
<h2 id='bdc_scientificName_empty'>Identify records with empty scientific names</h2><span id='topic+bdc_scientificName_empty'></span>

<h3>Description</h3>

<p>Flags records with empty or not interpretable scientific names.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdc_scientificName_empty(data, sci_names = "scientificName")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdc_scientificName_empty_+3A_data">data</code></td>
<td>
<p>data.frame. Containing the species scientific names.</p>
</td></tr>
<tr><td><code id="bdc_scientificName_empty_+3A_sci_names">sci_names</code></td>
<td>
<p>character string. The column name with the species
scientific name. Default = &quot;scientificName&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This test identifies records missing scientific names (i.e., empty
or not applicable <a href="base.html#topic+NA">NA</a> names)
</p>


<h3>Value</h3>

<p>A data.frame containing the column &quot;.scientificName_empty&quot;. Compliant
(TRUE) if 'sci_names' is not empty; otherwise &quot;FALSE&quot;.
</p>


<h3>See Also</h3>

<p>Other prefilter: 
<code><a href="#topic+bdc_basisOfRecords_notStandard">bdc_basisOfRecords_notStandard</a>()</code>,
<code><a href="#topic+bdc_coordinates_country_inconsistent">bdc_coordinates_country_inconsistent</a>()</code>,
<code><a href="#topic+bdc_coordinates_empty">bdc_coordinates_empty</a>()</code>,
<code><a href="#topic+bdc_coordinates_from_locality">bdc_coordinates_from_locality</a>()</code>,
<code><a href="#topic+bdc_coordinates_outOfRange">bdc_coordinates_outOfRange</a>()</code>,
<code><a href="#topic+bdc_coordinates_transposed">bdc_coordinates_transposed</a>()</code>,
<code><a href="#topic+bdc_country_standardized">bdc_country_standardized</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- data.frame(scientificName = c("Ocotea odorifera", NA, "Panthera onca", ""))
bdc_scientificName_empty(data = x, sci_names = "scientificName")

</code></pre>

<hr>
<h2 id='bdc_standardize_datasets'>Standardize datasets columns based on metadata</h2><span id='topic+bdc_standardize_datasets'></span>

<h3>Description</h3>

<p>This function's main goal is to merge and standardize different
datasets into a new dataset with column names following the Darwin
Core terminology. All the process is based on a metadata file
provided by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdc_standardize_datasets(
  metadata,
  format = "csv",
  overwrite = FALSE,
  save_database = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdc_standardize_datasets_+3A_metadata">metadata</code></td>
<td>
<p>A data frame with metadata containing information about the
name, path, and columns of the original data set which need to be
renamed. See @details.</p>
</td></tr>
<tr><td><code id="bdc_standardize_datasets_+3A_format">format</code></td>
<td>
<p>a character setting the output file type. Option available are
&quot;csv&quot; and &quot;qs&quot; (recommenced to save large datasets). Default == &quot;csv&quot;.</p>
</td></tr>
<tr><td><code id="bdc_standardize_datasets_+3A_overwrite">overwrite</code></td>
<td>
<p>A logical vector indicating whether the final merged dataset
should be overwritten. The default is FALSE.</p>
</td></tr>
<tr><td><code id="bdc_standardize_datasets_+3A_save_database">save_database</code></td>
<td>
<p>logical. Should the standardized database be locally
saved? Default = FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>bdc_standardize_datasets()</code> facilitate the standardization of datasets with
different column names by converting them into a new dataset following the
Darwin Core terminology. The standardization process relies on a metadata
file containing the name, path, and columns that need to be renamed. The
metadata file can be constructed using built-in functions (e.g.,
<code>data.frame()</code>) or storing the information in a CSV file and importing it
into R. Regardless of the method chosen, the data frame with metadata needs
to contain the following column names (this is a list of required column
names; for a comprehensive list of column names following Darwin Core
terminology, see
<a href="https://brunobrr.github.io/bdc/articles/integrate_datasets.html">here</a>
</p>

<ul>
<li> <p><code>datasetName</code>: A short name identifying the dataset (e.g., GBIF)
</p>
</li>
<li> <p><code>fileName</code>: The relative path containing the name of the input dataset
(e.g., Input_files/GBIF.csv)
</p>
</li>
<li> <p><code>scientificName</code>: Name of the column in the original database presenting
the taxon scientific names with or without authorship information, depending
on the format of the source dataset (e.g., Myrcia acuminata)
</p>
</li>
<li> <p><code>decimalLatitude</code>: Name of the column in the original database presenting
the geographic latitude in decimal degrees (e.g., -6.370833)
</p>
</li>
<li> <p><code>decimalLongitude</code>: Name of the column in the original database presenting
the geographic longitude in decimal degrees (e.g., -3.25500)
</p>
</li></ul>



<h3>Value</h3>

<p>A merged data.frame with column names following Darwin Core
terminology.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
metadata &lt;- readr::read_csv(system.file("extdata/Config/DatabaseInfo.csv",
            package = "bdc"))

db_standardized &lt;-
bdc_standardize_datasets(
  metadata = metadata,
  format = "csv",
  overwrite = TRUE,
  save_database = FALSE)

## End(Not run)
</code></pre>

<hr>
<h2 id='bdc_summary_col'>Create or update the column summarizing the results of data quality tests</h2><span id='topic+bdc_summary_col'></span>

<h3>Description</h3>

<p>This function creates or updates the column &quot;.summary&quot; summarizing the
results of data quality tests (i.e., columns starting with &quot;.&quot;). Records that
have failed in at least one test are flagged for further inspection (i.e.,
flagged as &quot;FALSE&quot;) in the &quot;.summary&quot; column.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdc_summary_col(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdc_summary_col_+3A_data">data</code></td>
<td>
<p>data.frame. Containing the results of data quality tests (i.e.,
columns starting with &quot;.&quot;).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If existing, the column &quot;.summary&quot; will be removed and then updated
considering all test names available in the supplied database.
</p>


<h3>Value</h3>

<p>A data.frame containing a new or an updated column &quot;.summary&quot;.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.missing_names &lt;- c(TRUE, TRUE, TRUE, FALSE, FALSE)
.missing_coordinates &lt;- c(TRUE, FALSE, FALSE, TRUE, FALSE)
x &lt;- data.frame(.missing_names, .missing_coordinates)

bdc_summary_col(data = x)

</code></pre>

<hr>
<h2 id='bdc_year_from_eventDate'>Extract year from eventDate</h2><span id='topic+bdc_year_from_eventDate'></span>

<h3>Description</h3>

<p>This function extracts a four-digit year from unambiguously interpretable
collecting dates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdc_year_from_eventDate(data, eventDate = "eventDate")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdc_year_from_eventDate_+3A_data">data</code></td>
<td>
<p>A data frame containing a column with event date information.</p>
</td></tr>
<tr><td><code id="bdc_year_from_eventDate_+3A_eventdate">eventDate</code></td>
<td>
<p>Numeric or date. The column with event date information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame containing the column &quot;year&quot;. Year information is
returned only if &quot;eventDate&quot; can be unambiguously interpretable from
&quot;eventDate&quot;. Years in the future (e.g., 2050) are returned as NA as well as
years before 1600, which is the lower limit for collecting dates of
biological specimens.
</p>


<h3>See Also</h3>

<p>Other time: 
<code><a href="#topic+bdc_eventDate_empty">bdc_eventDate_empty</a>()</code>,
<code><a href="#topic+bdc_year_outOfRange">bdc_year_outOfRange</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>collection_date &lt;- c(
  NA, "31/12/2015", "2013-06-13T00:00:00Z", "2019-05-20",
  "", "2013", "0001-01-00", "20", "1200"
)
x &lt;- data.frame(collection_date)

bdc_year_from_eventDate(data = x, eventDate = "collection_date")

</code></pre>

<hr>
<h2 id='bdc_year_outOfRange'>Identify records with year out-of-range</h2><span id='topic+bdc_year_outOfRange'></span>

<h3>Description</h3>

<p>This function identifies records out-of-range collecting year (e.g., in the
future) or old records collected before a year informed in 'year_threshold'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bdc_year_outOfRange(data, eventDate, year_threshold = 1900)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bdc_year_outOfRange_+3A_data">data</code></td>
<td>
<p>A data frame containing a column with event date information.</p>
</td></tr>
<tr><td><code id="bdc_year_outOfRange_+3A_eventdate">eventDate</code></td>
<td>
<p>numeric or date. The column containing event date
information.</p>
</td></tr>
<tr><td><code id="bdc_year_outOfRange_+3A_year_threshold">year_threshold</code></td>
<td>
<p>numeric. A four-digit year threshold used to flag old
(potentially invalid) records. Default = 1900</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Following the &quot;VALIDATION:YEAR_OUTOFRANGE&quot;
<a href="https://github.com/tdwg/bdq/projects/2">Biodiversity data quality
group</a>, the results of this test are time-dependent. While the user may
provide a lower limit to the year, the upper limit is defined based on the
year when the test is run. Lower limits can be used to flag old, often
imprecise, records. For example, records collected before GPS advent
(1980). If 'year_threshold' is not provided, the lower limit to the year is
by default 1600, a lower limit for collecting dates of biological specimens.
Records with empty or NA 'eventDate' are not tested and returned as NA.
</p>


<h3>Value</h3>

<p>A data.frame containing the column &quot;.year_outOfRange&quot;. Compliant
(TRUE) if 'eventDate' is not out-of-range; otherwise &quot;FALSE&quot;.
</p>


<h3>See Also</h3>

<p>Other time: 
<code><a href="#topic+bdc_eventDate_empty">bdc_eventDate_empty</a>()</code>,
<code><a href="#topic+bdc_year_from_eventDate">bdc_year_from_eventDate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>collection_date &lt;- c(
  NA, "31/12/2029", "2013-06-13T00:00:00Z", "2013-06-20",
  "", "2013", 1650, "0001-01-00"
)
x &lt;- data.frame(collection_date)

bdc_year_outOfRange(
data = x, 
eventDate = "collection_date", 
year_threshold = 1900)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
