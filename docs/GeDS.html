<!DOCTYPE html><html><head><title>Help for package GeDS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GeDS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#GeDS-package'><p>GeDS</p></a></li>
<li><a href='#BaFe2As2'><p>Barium-Ferrum-Arsenide Powder Diffraction Data</p></a></li>
<li><a href='#BivariateFitters'><p>Fitter function for GeD Spline Regression for bivariate data</p></a></li>
<li><a href='#bl_imp.GeDSboost'><p>Base Learner Importance for GeDSboost objects</p></a></li>
<li><a href='#coalMining'><p>Coal Mining Disasters data</p></a></li>
<li><a href='#coef.GeDS'><p>Coef method for GeDS objects</p></a></li>
<li><a href='#coef.GeDSboost+2Cgam'><p>Coef method for GeDSboost, GeDSgam</p></a></li>
<li><a href='#crossv_GeDS'><p>k-fold cross-validation</p></a></li>
<li><a href='#Derive'><p>Derivative of GeDS objects</p></a></li>
<li><a href='#deviance.GeDS'><p>Deviance method for GeDS, GeDSboost, GeDSgam</p></a></li>
<li><a href='#EWmortality'><p>Death counts in England and Wales</p></a></li>
<li><a href='#f'><p>Defining the covariates for the spline component in a GeDS formula.</p></a></li>
<li><a href='#formula.GeDS'><p>Formula for the predictor model</p></a></li>
<li><a href='#GeDS-class'><p>GeDS Class</p></a></li>
<li><a href='#GeDSboost-class'><p>GeDSboost Class</p></a></li>
<li><a href='#GeDSgam-class'><p>GeDSgam Class</p></a></li>
<li><a href='#GGeDS'><p>Generalized Geometrically Designed Spline regression estimation</p></a></li>
<li><a href='#Integrate'><p>Defined integral of GeDS objects</p></a></li>
<li><a href='#IRLSfit'><p>IRLS Estimation</p></a></li>
<li><a href='#knots.GeDS'><p>Knots method for GeDS, GeDSboost, GeDSgam</p></a></li>
<li><a href='#lines+2CGeDS-method'><p>Lines method for GeDS objects.</p></a></li>
<li><a href='#NGeDS'><p>Geometrically Designed Spline regression estimation</p></a></li>
<li><a href='#NGeDSboost'><p>Component-wise gradient boosting with NGeDS base-learners</p></a></li>
<li><a href='#NGeDSgam'><p>NGeDSgam: Local Scoring Algorithm with GeD Splines in Backfitting</p></a></li>
<li><a href='#plot+2CGeDS-method'><p>Plot method for GeDS objects.</p></a></li>
<li><a href='#PPolyRep'><p>Piecewise Polynomial Spline Representation</p></a></li>
<li><a href='#predict.GeDS'><p>Predict method for GeDS objects</p></a></li>
<li><a href='#predict.GeDSboost+2Cgam'><p>Predict method for GeDSboost, GeDSgam</p></a></li>
<li><a href='#print.GeDS'><p>Print method for GeDS, GeDSboost, GeDSgam</p></a></li>
<li><a href='#SplineReg'><p>Estimation of the coefficients of a predictor model with spline and</p>
possibly parametric components.</a></li>
<li><a href='#UnivariateFitters'><p>Functions used to fit GeDS objects w/univariate spline regression</p>
component</a></li>
<li><a href='#visualize_boosting'><p>Visualize Boosting Iterations</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Geometrically Designed Spline Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-04-24</td>
</tr>
<tr>
<td>Author:</td>
<td>Dimitrina S. Dimitrova &lt;D.Dimitrova@city.ac.uk&gt;,
  Emilio S. Guillen &lt;Emilio.Saenz-Guillen@bayes.city.ac.uk&gt;,
  Vladimir K. Kaishev &lt;V.Kaishev@city.ac.uk&gt;,
  Andrea Lattuada &lt;andrea.lattuada@hotmail.com&gt; and
  Richard J. Verrall &lt;R.J.Verrall@city.ac.uk&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Emilio S. Guillen &lt;Emilio.Saenz-Guillen@bayes.city.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Spline Regression, Generalized Additive Models, and Component-wise Gradient
  Boosting, utilizing Geometrically Designed (GeD) Splines. GeDS regression is a
  non-parametric method inspired by geometric principles, for fitting spline regression
  models with variable knots in one or two independent variables. It efficiently estimates
  the number of knots and their positions, as well as the spline order, assuming the
  response variable follows a distribution from the exponential family. GeDS models
  integrate the broader category of Generalized (Non-)Linear Models, offering a flexible
  approach to modeling complex relationships. A description of the method can be found in
  Kaishev et al. (2016) &lt;<a href="https://doi.org/10.1007%2Fs00180-015-0621-7">doi:10.1007/s00180-015-0621-7</a>&gt; and Dimitrova et al. (2023)
  &lt;<a href="https://doi.org/10.1016%2Fj.amc.2022.127493">doi:10.1016/j.amc.2022.127493</a>&gt;. Further extending its capabilities, GeDS's implementation
  includes Generalized Additive Models (GAM) and Functional Gradient Boosting (FGB),
  enabling versatile multivariate predictor modeling, as discussed in the forthcoming work of
  Dimitrova et al. (2024).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/emilioluissaenzguillen/GeDS">https://github.com/emilioluissaenzguillen/GeDS</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/emilioluissaenzguillen/GeDS/issues">https://github.com/emilioluissaenzguillen/GeDS/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.1), Rcpp (&ge; 0.12.1), splines, stats, utils, Matrix,
methods, Rmpfr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>doFuture, doParallel, doRNG, foreach, future, MASS, mboost,
parallel, plot3D, TH.data</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-24 16:38:36 UTC; ESaenz</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-24 17:20:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='GeDS-package'>GeDS</h2><span id='topic+GeDS-package'></span><span id='topic+GeDS'></span>

<h3>Description</h3>

<p>Geometrically Designed Splines (GeDS) regression is a non-parametric method
inspired by geometric principles, which is designed for fitting spline 
predictor models with variable knots. This method falls within the domain of
generalized non-linear models (GNM), which include generalized linear models
(GLM) as a special case. GeDS regression is fitted  based on a sample of
<code class="reqn">N</code> observations of a response variable <code class="reqn">y</code>, dependent on a set of
(currently up to two) covariates, assuming <code class="reqn">y</code> has a distribution from
the exponential family. In addition, GeDS methodology is
implemented both in the context of Generalized Additive Models (GAM) and
Functional Gradient Boosting (FGB). On the one hand, GAM consist of an 
additive modeling technique where the impact of the predictor variables is
captured through smooth (GeDS, in this case) functions. On the other hand,
GeDS incorporates gradient boosting machine learning technique by
implementing functional gradient descent algorithm to optimize general risk
functions utilizing component-wise GeDS estimates.
</p>


<h3>Details</h3>

<p>The GeDS estimation method is based on: first constructing a piecewise linear
fit (spline fit of order 2) at stage A  which captures the shape of the data
and; second approximating this fit with shape preserving (variation
diminishing) spline fits of higher orders 3, 4,<code class="reqn">\dots</code> (i.e., degrees 2,
3,<code class="reqn">\dots</code>) at stage B. As a result of this,  GeDS estimates the number
and location of the knots and the order of the spline fit in a fast and
efficient way.
</p>
<p>The GeDS method was originally developed by Kaishev et al. (2016) assuming
the response variable <code class="reqn">y</code> to be normally distributed and a corresponding
<em>Mathematica</em> code was provided.
</p>
<p>The GeDS method was extended by Dimitrova et al. (2023) to cover any
distribution from the exponential family. The <span class="pkg">GeDS</span> <span class="rlang"><b>R</b></span> package presented
here includes an enhanced <span class="rlang"><b>R</b></span> implementation of the original Normal GeDS 
<em>Mathematica</em> code due to Kaishev et al. (2016), implemented as the
<code><a href="#topic+NGeDS">NGeDS</a></code> function and a generalization of it in the function
<code><a href="#topic+GGeDS">GGeDS</a></code> which covers the case of any distribution from the
exponential family.
</p>
<p>The <span class="pkg">GeDS</span> package allows also to fit two dimensional response surfaces
and to construct multivariate (predictor) models with a GeD spline component
and a parametric component (see the functions <code><a href="#topic+f">f</a></code>,
<code><a href="#topic+formula.GeDS">formula</a></code>, <code><a href="#topic+NGeDS">NGeDS</a></code> and
<code><a href="#topic+GGeDS">GGeDS</a></code> for details).
</p>
<p>Dimitrova et al. (2024) have recently made significant enhancements to the
<span class="pkg">GeDS</span> methodology, to incorporate generalized additive models (GAM) and
functional gradient boosting (FGB). On the one hand, generalized additive
models are encompassed by implementing the <em>local-scoring</em> algorithm
using normal GeD splines (i.e., <code><a href="#topic+NGeDS">NGeDS</a></code>) as function smoothers
within the <em>backfitting</em> iterations. This is implemented via the function
<code><a href="#topic+NGeDSgam">NGeDSgam</a></code>. On the other hand, the <span class="pkg">GeDS</span> package incorporates
the functional gradient descent algorithm by utilizing normal GeD splines (i.e.,
<code><a href="#topic+NGeDS">NGeDS</a></code>) as base learners. This is implemented via the function
<code><a href="#topic+NGeDSboost">NGeDSboost</a></code>.
</p>
<p>The outputs of both <code><a href="#topic+NGeDS">NGeDS</a></code> and <code><a href="#topic+GGeDS">GGeDS</a></code> functions are
<code><a href="#topic+GeDS-class">GeDS-class</a></code> objects, while the outputs of <code><a href="#topic+NGeDSgam">NGeDSgam</a></code>
and <code><a href="#topic+NGeDSboost">NGeDSboost</a></code> are <code><a href="#topic+GeDSgam-class">GeDSgam-class</a></code> and
<code><a href="#topic+GeDSboost-class">GeDSboost-class</a></code> objects, respectively. As described in
Kaishev et al. (2016), Dimitrova et al. (2023) and  Dimitrova et al. (2024),
the final GeDS fit is the one whose order is chosen according to a strategy
described in stage B of the algorithm. However, <code><a href="#topic+GeDS-class">GeDS-class</a></code>,
<code><a href="#topic+GeDSgam-class">GeDSgam-class</a></code> and <code><a href="#topic+GeDSboost-class">GeDSboost-class</a></code> objects contain
second, third and fourth order spline fits and the user has the possibility
to choose among them.
</p>
<p>The <span class="pkg">GeDS</span> package also includes some datasets where GeDS regression
proves to be very efficient and some user friendly functions that are designed
to easily extract required information. Several methods are also provided to
handle GeDS, GAM-GeDS and FGB-GeDS output results (see <code><a href="#topic+GeDS-class">GeDS-class</a></code>,
<code><a href="#topic+GeDSgam-class">GeDSgam-class</a></code> and <code><a href="#topic+GeDSboost-class">GeDSboost-class</a></code>, respectively).
</p>
<p>Throughout this document, we use the terms GeDS predictor model, GeDS
regression and GeDS fit interchangeably.
</p>
<p>Please report any issue arising or bug in the code to
<a href="mailto:emilio.saenz-guillen@bayes.city.ac.uk">emilio.saenz-guillen@bayes.city.ac.uk</a>.
</p>

<table>
<tr>
 <td style="text-align: right;">
Package: </td><td style="text-align: left;"> GeDS</td>
</tr>
<tr>
 <td style="text-align: right;">
Version: </td><td style="text-align: left;"> 0.2.0 </td>
</tr>
<tr>
 <td style="text-align: right;">
Date: </td><td style="text-align: left;"> 2024-01-28</td>
</tr>
<tr>
 <td style="text-align: right;">
License: </td><td style="text-align: left;"> GPL-3 </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Dimitrina S. Dimitrova &lt;D.Dimitrova@city.ac.uk&gt;,
Emilio S. Guillen &lt;emilio.saenz-guillen@bayes.city.ac.uk&gt;,
Vladimir K. Kaishev &lt;V.Kaishev@city.ac.uk&gt;,
Andrea Lattuada &lt;Andrea.Lattuada@unicatt.it&gt; and
Richard J. Verrall &lt;R.J.Verrall@city.ac.uk&gt;
</p>


<h3>References</h3>

<p>Kaishev, V.K., Dimitrova, D.S., Haberman, S., &amp; Verrall, R.J. (2016).
Geometrically designed, variable knot regression splines.
<em>Computational Statistics</em>, <strong>31</strong>, 1079&ndash;1105. <br />
DOI: <a href="https://doi.org/10.1007/s00180-015-0621-7">doi:10.1007/s00180-015-0621-7</a>
</p>
<p>Dimitrova, D. S., Kaishev, V. K., Lattuada, A. and Verrall, R. J.  (2023).
Geometrically designed variable knot splines in generalized (non-)linear
models.
<em>Applied Mathematics and Computation</em>, <strong>436</strong>. <br />
DOI: <a href="https://doi.org/10.1016/j.amc.2022.127493">doi:10.1016/j.amc.2022.127493</a>
</p>
<p>Dimitrova, D. S., Guillen, E. S. and Kaishev, V. K.  (2024).
<span class="pkg">GeDS</span>: An R Package for Regression, Generalized Additive
Models and Functional Gradient Boosting, based on Geometrically Designed
(GeD) Splines. <em>Manuscript submitted for publication.</em>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/emilioluissaenzguillen/GeDS">https://github.com/emilioluissaenzguillen/GeDS</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/emilioluissaenzguillen/GeDS/issues">https://github.com/emilioluissaenzguillen/GeDS/issues</a>
</p>
</li></ul>


<hr>
<h2 id='BaFe2As2'>Barium-Ferrum-Arsenide Powder Diffraction Data</h2><span id='topic+BaFe2As2'></span>

<h3>Description</h3>

<p>This dataset contains the results of a neutron diffraction experiment on
Barium-Ferrum-Arsenide (<code class="reqn">\mathrm{Ba Fe_2 As_2}</code>) powder carried out by
Kimber et al. (2009) and used in Kaishev et al. (2016). The neutron
diffraction intensity was measured at 1,151 different dispersion angles in
order to model the diffraction profile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(BaFe2As2)
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 1151 cases and 2 variables:
</p>

<dl>
<dt>angle</dt><dd><p> the dispersion angle, viewed as the independent variable.</p>
</dd>
<dt>intensity</dt><dd><p> the neutron diffraction intensity, viewed as the response variable.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://openaccess.city.ac.uk/12418/">openaccess.city.ac.uk</a>
</p>


<h3>References</h3>

<p>Kimber, S.A.J., Kreyssig, A., Zhang, Y.Z., Jeschke, H.O., Valenti, R.,
Yokaichiya, F., Colombier, E., Yan, J., Hansen, T.C., Chatterji, T.,
McQueeney, R.J., Canfield, P.C., Goldman, A.I. and Argyriou, D.N. (2009).
Similarities between structural distortions under pressure and chemical
doping in superconducting <code class="reqn">\mathrm{Ba Fe_2 As_2}</code>. <em>Nat Mater</em>,
<strong>8</strong>, 471&ndash;475.
</p>
<p>Kaishev, V.K., Dimitrova, D.S., Haberman, S. and Verrall, R.J. (2016).
Geometrically designed, variable knot regression splines.
<em>Computational Statistics</em>, <strong>31</strong>, 1079&ndash;1105. <br />
DOI: <a href="https://doi.org/10.1007/s00180-015-0621-7">doi:10.1007/s00180-015-0621-7</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# to load the data
data('BaFe2As2')

# fit a GeDS regression and produce a simple plot of the result. See ?NGeDS
# c.f. Kaishev et al. (2016), section 4.2
(Gmod &lt;- NGeDS(intensity ~ f(angle), data = BaFe2As2, beta = 0.6, phi = 0.99,
               q = 3, show.iters = T))
plot(Gmod)

## End(Not run)

</code></pre>

<hr>
<h2 id='BivariateFitters'>Fitter function for GeD Spline Regression for bivariate data</h2><span id='topic+BivariateFitters'></span><span id='topic+BivariateFitter'></span><span id='topic+GenBivariateFitter'></span>

<h3>Description</h3>

<p>These are computing engines called by <code><a href="#topic+NGeDS">NGeDS</a></code>, needed for the
underlying fitting procedures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BivariateFitter(
  X,
  Y,
  Z,
  W,
  weights = rep(1, length(X)),
  Indicator,
  beta = 0.5,
  phi = 0.99,
  min.intknots = 0,
  max.intknots = 300,
  q = 2,
  Xextr = range(X),
  Yextr = range(Y),
  show.iters = TRUE,
  tol = as.double(1e-12),
  stoptype = c("SR", "RD", "LR"),
  higher_order = TRUE
)

GenBivariateFitter(
  X,
  Y,
  Z,
  W,
  family = family,
  weights = rep(1, length(X)),
  Indicator,
  beta = 0.5,
  phi = 0.5,
  min.intknots = 0,
  max.intknots = 300,
  q = 2,
  Xextr = range(X),
  Yextr = range(Y),
  show.iters = TRUE,
  tol = as.double(1e-12),
  stoptype = c("SR", "RD", "LR"),
  higher_order = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BivariateFitters_+3A_x">X</code></td>
<td>
<p>a numeric vector containing <code class="reqn">N</code> sample values of the first
independent variable chosen to enter the spline regression component of the
predictor model.</p>
</td></tr>
<tr><td><code id="BivariateFitters_+3A_y">Y</code></td>
<td>
<p>a numeric vector containing <code class="reqn">N</code> sample values of the second
independent variable chosen to enter the spline regression component of the
predictor model.</p>
</td></tr>
<tr><td><code id="BivariateFitters_+3A_z">Z</code></td>
<td>
<p>a vector of size <code class="reqn">N</code> containing the observed values of the
response variable.</p>
</td></tr>
<tr><td><code id="BivariateFitters_+3A_w">W</code></td>
<td>
<p>a design matrix with <code class="reqn">N</code> rows containing other covariates
selected to enter the parametric component of the predictor model (see
<code><a href="#topic+formula.GeDS">formula</a></code>). If no such covariates are selected, it
is set to <code>NULL</code> by default.</p>
</td></tr>
<tr><td><code id="BivariateFitters_+3A_weights">weights</code></td>
<td>
<p>an optional vector of size <code class="reqn">N</code> of &lsquo;prior weights&rsquo; to be
put on the observations in the fitting process in case the user requires
weighted GeDS fitting. It is <code>NULL</code> by default.</p>
</td></tr>
<tr><td><code id="BivariateFitters_+3A_indicator">Indicator</code></td>
<td>
<p>contingency table of <code>X</code> and <code>Y</code>.</p>
</td></tr>
<tr><td><code id="BivariateFitters_+3A_beta">beta</code></td>
<td>
<p>numeric parameter in the interval <code class="reqn">[0,1]</code> tuning the knot
placement in stage A of GeDS. See the description of <code><a href="#topic+NGeDS">NGeDS</a></code> or
<code><a href="#topic+GGeDS">GGeDS</a></code>.</p>
</td></tr>
<tr><td><code id="BivariateFitters_+3A_phi">phi</code></td>
<td>
<p>numeric parameter in the interval <code class="reqn">[0,1]</code> specifying the
threshold for the stopping rule  (model selector) in stage A of GeDS. See
also <code>stoptype</code> and details in the description of <code><a href="#topic+NGeDS">NGeDS</a></code> or
<code><a href="#topic+GGeDS">GGeDS</a></code>.</p>
</td></tr>
<tr><td><code id="BivariateFitters_+3A_min.intknots">min.intknots</code></td>
<td>
<p>optional parameter allowing the user to set a minimum
number of internal knots required. By default equal to zero.</p>
</td></tr>
<tr><td><code id="BivariateFitters_+3A_max.intknots">max.intknots</code></td>
<td>
<p>optional parameter allowing the user to set a maximum
number of internal knots to be added by the GeDS estimation algorithm. By
default equal to the number of internal knots <code class="reqn">\kappa</code> for the saturated
GeDS model (i.e. <code class="reqn">\kappa=N-2</code>).</p>
</td></tr>
<tr><td><code id="BivariateFitters_+3A_q">q</code></td>
<td>
<p>numeric parameter which allows to fine-tune the stopping rule of
stage A of GeDS, by default equal to 2. See details in the description of
<code><a href="#topic+NGeDS">NGeDS</a></code> or <code><a href="#topic+GGeDS">GGeDS</a></code>.</p>
</td></tr>
<tr><td><code id="BivariateFitters_+3A_xextr">Xextr</code></td>
<td>
<p>boundary knots in the <code>X</code> direction. By default equal to
the range of <code>X</code>.</p>
</td></tr>
<tr><td><code id="BivariateFitters_+3A_yextr">Yextr</code></td>
<td>
<p>boundary knots in the <code>Y</code> direction. By default equal to
the range of <code>Y</code>.</p>
</td></tr>
<tr><td><code id="BivariateFitters_+3A_show.iters">show.iters</code></td>
<td>
<p>logical variable indicating whether or not to print 
information at each step. By default equal to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="BivariateFitters_+3A_tol">tol</code></td>
<td>
<p>numeric value indicating the tolerance to be used in checking
whether two knots should be considered different during the knot placement
steps in stage A.</p>
</td></tr>
<tr><td><code id="BivariateFitters_+3A_stoptype">stoptype</code></td>
<td>
<p>a character string indicating the type of GeDS stopping rule
to be used. It should be either <code>"SR"</code>, <code>"RD"</code> or <code>"LR"</code>,
partial match allowed. See details of <code><a href="#topic+NGeDS">NGeDS</a></code> or
<code><a href="#topic+GGeDS">GGeDS</a></code>.</p>
</td></tr>
<tr><td><code id="BivariateFitters_+3A_higher_order">higher_order</code></td>
<td>
<p>a logical that defines whether to compute the higher
order fits (quadratic and cubic) after stage A is run. Default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="BivariateFitters_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to be
used in the model. This can be a character string naming a family function
(e.g. <code>"gaussian"</code>), the family function itself (e.g.
<code><a href="stats.html#topic+gaussian">gaussian</a></code>) or the result of a call to a family function
(e.g. <code>gaussian()</code>). See <a href="stats.html#topic+family">family</a> for details on family
functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+GeDS-Class">GeDS-Class</a></code> object, but without the <code>Formula</code>,
<code>extcall</code>, <code>terms</code> and <code>znames</code> slots.
</p>


<h3>References</h3>

<p>Dimitrova, D. S., Kaishev, V. K., Lattuada, A. and Verrall, R. J.  (2023).
Geometrically designed variable knot splines in generalized (non-)linear
models.
<em>Applied Mathematics and Computation</em>, <strong>436</strong>. <br />
DOI: <a href="https://doi.org/10.1016/j.amc.2022.127493">doi:10.1016/j.amc.2022.127493</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NGeDS">NGeDS</a></code> and <code><a href="#topic+UnivariateFitters">UnivariateFitters</a></code>.
</p>

<hr>
<h2 id='bl_imp.GeDSboost'>Base Learner Importance for GeDSboost objects</h2><span id='topic+bl_imp.GeDSboost'></span><span id='topic+bl_imp'></span>

<h3>Description</h3>

<p>This function calculates the in-bag mean squared error (MSE) reduction
ascribable to each of the base-learners with regards to the final prediction
of the component-wise gradient boosted model encapsulated in a
<code><a href="#topic+GeDSboost-Class">GeDSboost-Class</a></code> object. Essentially, it measures the decrease
in MSE attributable to each base-learner for every time it is selected across
the boosting iterations, and aggregates them. This provides a measure on how
much each base-learner contributes to the overall improvement in the model's
accuracy, as reflected by the decrease in MSE. This function is adapted from
<code><a href="mboost.html#topic+varimp">varimp</a></code> and is compatible with the available
<code><a href="mboost.html#topic+mboost-package">mboost-package</a></code> methods for <code><a href="mboost.html#topic+varimp">varimp</a></code>,
including <code>plot</code>, <code>print</code> and <code>as.data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GeDSboost'
bl_imp(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bl_imp.GeDSboost_+3A_object">object</code></td>
<td>
<p>An object of class <code><a href="#topic+GeDSboost-Class">GeDSboost-Class</a></code>.</p>
</td></tr>
<tr><td><code id="bl_imp.GeDSboost_+3A_...">...</code></td>
<td>
<p>potentially further arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="mboost.html#topic+varimp">varimp</a></code> for details.
</p>


<h3>Value</h3>

<p>An object of class <code>varimp</code> with available <code>plot</code>,
<code>print</code> and <code>as.data.frame</code> methods.
</p>


<h3>References</h3>

<p>Hothorn T., Buehlmann P., Kneib T., Schmid M. and Hofner B. (2022).
mboost: Model-Based Boosting. R package version 2.9-7, <a href="https://CRAN.R-project.org/package=mboost">https://CRAN.R-project.org/package=mboost</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(GeDS)
library(TH.data)
set.seed(290875)
data("bodyfat", package = "TH.data")
data = bodyfat
Gmodboost &lt;- NGeDSboost(formula = DEXfat ~ f(hipcirc) + f(kneebreadth) + f(anthro3a),
                        data = data, initial_learner = FALSE)
MSE_Gmodboost_linear &lt;- mean((data$DEXfat - Gmodboost$predictions$pred_linear)^2)
MSE_Gmodboost_quadratic &lt;- mean((data$DEXfat - Gmodboost$predictions$pred_quadratic)^2)
MSE_Gmodboost_cubic &lt;- mean((data$DEXfat - Gmodboost$predictions$pred_cubic)^2)

# Print MSE
cat("\n", "MEAN SQUARED ERROR", "\n",
    "Linear NGeDSboost:", MSE_Gmodboost_linear, "\n",
    "Quadratic NGeDSboost:", MSE_Gmodboost_quadratic, "\n",
    "Cubic NGeDSboost:", MSE_Gmodboost_cubic, "\n")

# Base Learner Importance
bl_imp &lt;- bl_imp(Gmodboost)
print(bl_imp)
plot(bl_imp)

</code></pre>

<hr>
<h2 id='coalMining'>Coal Mining Disasters data</h2><span id='topic+coalMining'></span>

<h3>Description</h3>

<p>A dataset with 112 entries containing annual numbers of accidents due to
disasters in British coal mines for years from 1850 to 1962, considered in
Carlin et al. (1992) and also in Eilers and Marx (1996).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(coalMining)
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 112 entries, corresponding to the
years from 1850 to 1962. Each entry has:
</p>

<dl>
<dt>accidents</dt><dd><p> number of severe accidents that have occurred each year.</p>
</dd>
<dt>years</dt><dd><p> year during which accidents occurred.</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://people.reed.edu/~jones/141/Coal.html">https://people.reed.edu/~jones/141/Coal.html</a>
</p>


<h3>References</h3>

<p>Carlin, B.P., Gelfand, A.E. and Smith, A.F.M. (1992).
Hierarchical Bayesian analysis of changepoint problems.
<em>Applied Statistics</em>, <strong>41</strong>(2), 389&ndash;405.
</p>
<p>Eilers, P.H.C. and Marx, B.D. (1996). Flexible Smoothing with B-splines
and Penalties. <em>Statistical Science</em>, <strong>11</strong>(2), 89&ndash;121.
</p>

<hr>
<h2 id='coef.GeDS'>Coef method for GeDS objects</h2><span id='topic+coef.GeDS'></span><span id='topic+coefficients.GeDS'></span>

<h3>Description</h3>

<p>Methods for the functions <code><a href="stats.html#topic+coef">coef</a></code> and
<code><a href="stats.html#topic+coefficients">coefficients</a></code> that allow to extract the estimated
coefficients of a fitted GeDS regression from a <code><a href="#topic+GeDS-Class">GeDS-Class</a></code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GeDS'
coef(object, n = 3L, onlySpline = TRUE, ...)

## S3 method for class 'GeDS'
coefficients(object, n = 3L, onlySpline = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.GeDS_+3A_object">object</code></td>
<td>
<p>the  <code><a href="#topic+GeDS-class">GeDS-class</a></code> object from which the
coefficients of the selected GeDS regression should be extracted.</p>
</td></tr>
<tr><td><code id="coef.GeDS_+3A_n">n</code></td>
<td>
<p>integer value (2, 3 or 4) specifying the order (<code class="reqn">=</code> degree
<code class="reqn">+ 1</code>) of the GeDS fit whose coefficients should be extracted. By default
equal to <code>3L</code>. Non-integer values will be passed to the function
<code><a href="base.html#topic+as.integer">as.integer</a></code>.</p>
</td></tr>
<tr><td><code id="coef.GeDS_+3A_onlyspline">onlySpline</code></td>
<td>
<p>logical variable specifying whether only the coefficients
for the GeDS  component of the fitted multivariate regression model should be
extracted or alternatively also the coefficients of the parametric component
should also be extracted.</p>
</td></tr>
<tr><td><code id="coef.GeDS_+3A_...">...</code></td>
<td>
<p>potentially further arguments (required by the definition of the
generic function). They will be ignored, but with a warning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are simple methods for the functions <code><a href="stats.html#topic+coef">coef</a></code> and
<code><a href="stats.html#topic+coefficients">coefficients</a></code>.
</p>
<p>As <code><a href="#topic+GeDS-class">GeDS-class</a></code> objects contain three different fits (linear,
quadratic and cubic), it is possible to specify the order of the fit for
which GeDS regression coefficients are required via the input argument
<code>n</code>.
</p>
<p>As mentioned in the details of <code><a href="#topic+formula.GeDS">formula</a></code>, the
predictor model may be multivariate and it may include a GeD spline component
whereas the remaining variables may be part of a parametric component. If the
<code>onlySpline</code> argument is set to <code>TRUE</code> (the default value), only
the coefficients corresponding to the GeD spline component of order <code>n</code>
of the multivariate predictor model are extracted.
</p>


<h3>Value</h3>

<p>A named vector containing the required coefficients of the fitted
multivariate predictor model. The coefficients corresponding to the variables
that enter the parametric component of the fitted multivariate predictor model
are named as the variables themselves. The  coefficients of the GeDS component
are coded as &quot;<code>N</code>&quot; followed by the index of the corresponding B-spline.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+coef">coef</a></code> for the standard definition;
<code><a href="#topic+NGeDS">NGeDS</a></code> for examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a data sample for the response variable
# and the covariates
set.seed(123)
N &lt;- 500
f_1 &lt;- function(x) (10*x/(1+100*x^2))*4+4
X &lt;- sort(runif(N ,min = -2, max = 2))
Z &lt;- runif(N)
# Specify a model for the mean of the response Y to be a superposition of
# a non-linear component f_1(X), a linear component 2*Z and a
# free term 1, i.e.
means &lt;- f_1(X) + 2*Z + 1
# Add normal noise to the mean of y
Y &lt;- rnorm(N, means, sd = 0.1)

# Fit to this sample a predictor model of the form f(X) + Z, where
# f(X) is the GeDS component and Z is the linear (additive) component
# see ?formula.GeDS for details
(Gmod &lt;- NGeDS(Y ~ f(X) + Z, beta = 0.6, phi = 0.995, Xextr = c(-2,2)))

# Extract the GeD spline regression coefficients
coef(Gmod, n = 3)

# Extract all the coefficients, including the one for the linear component
coef(Gmod, onlySpline = FALSE, n = 3)

</code></pre>

<hr>
<h2 id='coef.GeDSboost+2Cgam'>Coef method for GeDSboost, GeDSgam</h2><span id='topic+coef.GeDSboost+2Cgam'></span><span id='topic+coef.GeDSboost'></span><span id='topic+coef.GeDSboost+2C'></span><span id='topic+coef.GeDSgam'></span><span id='topic+coefficients.GeDSboost'></span><span id='topic+coefficients.GeDSgam'></span>

<h3>Description</h3>

<p>Methods for the functions <code><a href="stats.html#topic+coef">coef</a></code> and
<code><a href="stats.html#topic+coefficients">coefficients</a></code> that allow to extract the estimated
coefficients of <code><a href="#topic+GeDSboost-Class">GeDSboost-Class</a></code> or <code><a href="#topic+GeDSgam-Class">GeDSgam-Class</a></code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GeDSboost'
coef(object, n = 3L, ...)

## S3 method for class 'GeDSboost'
coefficients(object, n = 3L, ...)

## S3 method for class 'GeDSgam'
coef(object, n = 3L, ...)

## S3 method for class 'GeDSgam'
coefficients(object, n = 3L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.GeDSboost+2B2Cgam_+3A_object">object</code></td>
<td>
<p>the  <code><a href="#topic+GeDSboost-class">GeDSboost-class</a></code> or
<code><a href="#topic+GeDSgam-Class">GeDSgam-Class</a></code> object from which the coefficients should be
extracted.</p>
</td></tr>
<tr><td><code id="coef.GeDSboost+2B2Cgam_+3A_n">n</code></td>
<td>
<p>integer value (2, 3 or 4) specifying the order (<code class="reqn">=</code> degree
<code class="reqn">+ 1</code>) of the FGB-GeDS/GAM-GeDS fit whose coefficients should be
extracted. If <code>n = 2L</code> piecewise polynomial coefficients of the
univariate GeDS base-learners are provided. In the case of bivariate GeDS
base learners and <code>class(object) == "GeDSboost"</code>, the B-spline
coefficients for each iteration where a particular base-learner was selected
are provided. In the case of bivariate base learners and
<code>class(object) == "GeDSgam"</code>, the final local-scoring B-spline
coefficients for each base-learner are provided. If <code>n = 3L</code> or
<code>n = 4L</code> B-spline coefficients are provided. By default <code>n</code> is
equal to <code>3L</code>. Non-integer values will be passed to the function
<code><a href="base.html#topic+as.integer">as.integer</a></code>.</p>
</td></tr>
<tr><td><code id="coef.GeDSboost+2B2Cgam_+3A_...">...</code></td>
<td>
<p>potentially further arguments (required by the definition of the
generic function). They will be ignored, but with a warning.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector containing the required coefficients of the fitted
multivariate predictor model.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+coef">coef</a></code> for the standard definition;
<code><a href="#topic+NGeDSboost">NGeDSboost</a></code> and <code><a href="#topic+NGeDSgam">NGeDSgam</a></code> for examples.
</p>

<hr>
<h2 id='crossv_GeDS'>k-fold cross-validation</h2><span id='topic+crossv_GeDS'></span>

<h3>Description</h3>

<p><code>crossv_GeDS</code> implements k-fold cross-validation for the relevant
parameters of <code>NGeDS</code>,
<code>GGeDS</code>, <code>NGeDSgam</code> and <code>NGeDSboost</code>
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossv_GeDS_+3A_formula">formula</code></td>
<td>
<p>a description of the structure of the model to be fitted,
including the dependent and independent variables.</p>
</td></tr>
<tr><td><code id="crossv_GeDS_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables referenced in the formula.</p>
</td></tr>
<tr><td><code id="crossv_GeDS_+3A_model_fun">model_fun</code></td>
<td>
<p>the GeDS model to be fitted, that is, <code>NGeDS</code>,
<code>GGeDS</code>, <code>NGeDSgam</code> or <code>NGeDSboost</code>.</p>
</td></tr>
<tr><td><code id="crossv_GeDS_+3A_parameters">parameters</code></td>
<td>
<p>to cross-validate. <code>beta</code>, <code>phi</code> and <code>q</code> in
the case of <code>NGeDS</code>, <code>GGeDS</code> and <code>NGeDSgam</code>. In addition, for
<code>NGeDSboost</code>, <code>int.knots_init</code>, <code>shrinkage</code> can also be tuned.
Default values are <code>int.knots_init_grid = c(0, 1, 2)</code>,
<code>shrinkage_grid = c(0.1, 0.5, 1)</code>, <code>beta_grid = c(0.3, 0.5, 0.7)</code>,
<code>phi_grid = c(0.9, 0.95, 0.99)</code>, <code>q_grid = c(2, 3))</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Two data frames, <code>best_params</code> and <code>results</code>.
<code>best_params</code> contains the best combination of parameters according to
the cross-validated MSE. <code>results</code> presents the results for each of the
possible combinations of parameters, given the input <code>paramters</code>.
</p>

<hr>
<h2 id='Derive'>Derivative of GeDS objects</h2><span id='topic+Derive'></span>

<h3>Description</h3>

<p>This function computes derivatives of a fitted GeDS regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Derive(object, order = 1L, x, n = 3L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Derive_+3A_object">object</code></td>
<td>
<p>the <code><a href="#topic+GeDS-Class">GeDS-Class</a></code> object containing the GeDS fit
which should be differentiated. It should be the result of fitting a 
univariate GeDS regression via <code><a href="#topic+NGeDS">NGeDS</a></code> or <code><a href="#topic+GGeDS">GGeDS</a></code>.</p>
</td></tr>
<tr><td><code id="Derive_+3A_order">order</code></td>
<td>
<p>integer value indicating the order of differentiation required
(e.g. first, second or higher derivatives). Note that <code>order</code> should be
lower than <code>n</code> and that non-integer values will be passed to the
function <code><a href="base.html#topic+as.integer">as.integer</a></code>.</p>
</td></tr>
<tr><td><code id="Derive_+3A_x">x</code></td>
<td>
<p>numeric vector containing values of the independent variable at
which the derivatives of order <code>order</code> should be computed.</p>
</td></tr>
<tr><td><code id="Derive_+3A_n">n</code></td>
<td>
<p>integer value (2, 3 or 4) specifying the order (<code class="reqn">=</code> degree
<code class="reqn">+ 1</code>) of the GeDS fit to be differentiated. By default equal to
<code>3L</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is based on <code><a href="splines.html#topic+splineDesign">splineDesign</a></code> and it
computes the exact derivative of the fitted GeDS regression.
</p>
<p>The function uses the property that the <code class="reqn">m</code>-th derivative of a spline,
<code class="reqn">m= 1,2,...</code>, expressed in terms of B-splines can be computed by
differentiating the corresponding B-spline coefficients (see e.g.
De Boor, 2001, Chapter X, formula (15)). Since the GeDS fit is a B-spline
representation of the predictor, it cannot work on the response scale in the
GNM (GLM) framework.
</p>


<h3>References</h3>

<p>De Boor, C. (2001). <em>A Practical Guide to Splines (Revised Edition)</em>.
Springer, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate a data sample for the response variable
# Y and the covariate X
set.seed(123)
N &lt;- 500
f_1 &lt;- function(x) (10*x/(1+100*x^2))*4+4
X &lt;- sort(runif(N, min = -2, max = 2))
# Specify a model for the mean of Y to include only
# a component non-linear in X, defined by the function f_1
means &lt;- f_1(X)
# Add (Normal) noise to the mean of Y
Y &lt;- rnorm(N, means, sd = 0.1)

# Fit GeDS regression with only a spline component in the predictor model
Gmod &lt;- NGeDS(Y ~ f(X), beta = 0.6, phi = 0.995, Xextr = c(-2,2))

# Compute the second derivative of the cubic GeDS fit
# at the points 0, -1 and 1
Derive(Gmod, x = c(0, -1, 1), order = 2, n = 4)

</code></pre>

<hr>
<h2 id='deviance.GeDS'>Deviance method for GeDS, GeDSboost, GeDSgam</h2><span id='topic+deviance.GeDS'></span><span id='topic+deviance.GeDSboost'></span><span id='topic+deviance.GeDSgam'></span>

<h3>Description</h3>

<p>Method for the function <code><a href="stats.html#topic+deviance">deviance</a></code> that allows the user to
extract  the value of the deviance corresponding to a selected GeDS, GeDSboost
or GeDSgam fit from a <code><a href="#topic+GeDS-Class">GeDS-Class</a></code>,
<code><a href="#topic+GeDSboost-Class">GeDSboost-Class</a></code> or <code><a href="#topic+GeDSgam-Class">GeDSgam-Class</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GeDS'
deviance(object, n = 3L, ...)

## S3 method for class 'GeDSboost'
deviance(object, n = 3L, ...)

## S3 method for class 'GeDSgam'
deviance(object, n = 3L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deviance.GeDS_+3A_object">object</code></td>
<td>
<p>the <code><a href="#topic+GeDS-class">GeDS-class</a></code>, <code><a href="#topic+GeDSboost-class">GeDSboost-class</a></code> or
<code><a href="#topic+GeDSgam-class">GeDSgam-class</a></code> object from which the deviance should be extracted.</p>
</td></tr>
<tr><td><code id="deviance.GeDS_+3A_n">n</code></td>
<td>
<p>integer value (2, 3 or 4) specifying the order (<code class="reqn">=</code> degree
<code class="reqn">+ 1</code>) of the GeDS/GeDSboost/GeDSgam fit whose deviance should be
extracted. By default equal to <code>3L</code>. Non-integer values will be passed
to the function <code><a href="base.html#topic+as.integer">as.integer</a></code>.</p>
</td></tr>
<tr><td><code id="deviance.GeDS_+3A_...">...</code></td>
<td>
<p>potentially further arguments (required by the definition of the
generic function). They will be ignored, but with a warning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the function <code><a href="stats.html#topic+deviance">deviance</a></code>. As
<code><a href="#topic+GeDS-class">GeDS-class</a></code>, <code><a href="#topic+GeDSboost-class">GeDSboost-class</a></code> and
<code><a href="#topic+GeDSgam-class">GeDSgam-class</a></code> objects contain three different fits (linear,
quadratic and cubic), it is possible to specify the order of the GeDS fit
for which the deviance is required via the input argument <code>n</code>.
</p>


<h3>Value</h3>

<p>A numeric value corresponding to the  deviance of the selected
GeDS/GeDSboost/GeDSgam fit.
#'
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+deviance">deviance</a></code> for the standard definition;
<code><a href="#topic+GGeDS">GGeDS</a></code> for examples.
</p>

<hr>
<h2 id='EWmortality'>Death counts in England and Wales</h2><span id='topic+EWmortality'></span>

<h3>Description</h3>

<p>The dataset consists of information about the mortality of the English and
Welsh male population aggregated over the years 2000, 2001 and 2002.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(EWmortality)
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 109 entries and 3 variables: <code>Age</code>,
<code>Deaths</code> and <code>Exposure</code>. <code>Exposure</code> is a mid-year estimate of
the population exposed to risk.
</p>

<hr>
<h2 id='f'>Defining the covariates for the spline component in a GeDS formula.</h2><span id='topic+f'></span>

<h3>Description</h3>

<p>In general the GeDS predictor model may include a GeD spline regression
component with respect to part of the independent variables and a parametric
component in which the remaining covariates may enter as additive terms.
</p>
<p>The function <code>f</code> is to be used in the
<code><a href="#topic+formula.GeDS">formula</a></code> argument of <code><a href="#topic+NGeDS">NGeDS</a></code> or
<code><a href="#topic+GGeDS">GGeDS</a></code> in order to specify which independent variables
(covariates) should be included in the GeD spline regression component of the
predictor model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f(x, xx = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="f_+3A_x">x</code></td>
<td>
<p>numeric vector containing <code class="reqn">N</code> sample values of the covariate
chosen to enter the spline
regression component of the predictor model.</p>
</td></tr>
<tr><td><code id="f_+3A_xx">xx</code></td>
<td>
<p>numeric vector containing <code class="reqn">N</code> sample values for the second
covariate (in case <code><a href="#topic+NGeDS">NGeDS</a></code> is run for two dimensions). It has to
be either <code>NULL</code> (the default) or a vector of size <code class="reqn">N</code>, same as
<code>x</code>.</p>
</td></tr>
<tr><td><code id="f_+3A_...">...</code></td>
<td>
<p>further arguments. As GeDS currently allows for up to two
covariates, specification of further arguments will return an error.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is intended to be used only as part of the
<code><a href="#topic+formula.GeDS">formula</a></code> in a GeDS regression via
<code><a href="#topic+NGeDS">NGeDS</a></code> or <code><a href="#topic+GGeDS">GGeDS</a></code> and not to be called in other
cases by the user.
</p>


<h3>See Also</h3>

<p><a href="#topic+NGeDS">NGeDS</a>; <a href="#topic+GGeDS">GGeDS</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a data sample for the response variable Y and
# the covariates X, reg1, reg2 and off
set.seed(123)
N &lt;- 500
f_1 &lt;- function(x) (10*x/(1+100*x^2))*4+4
X &lt;- sort(runif(N ,min = -2, max = 2))
reg1 &lt;- runif(500, min = -0.1, max = 0.1)
reg2 &lt;- runif(500, min = -0.2, max = 0.2)
off &lt;- runif(500, min = -1, max = 1)
# Specify a model for the mean of Y to include a component non linear
# in X defined by the function f_1 and a linear one in the other covariates
means &lt;- f_1(X) + 2*reg1 + 0.5*reg2 + off
# Add Normal noise to the mean of Y
Y &lt;- rnorm(N, means, sd = 0.1)

# Specify a formula that will be used to model Y as a
# function of X, reg1, reg2 and off.
# The covariate X is for the spline component modeled as GeDS,
# reg1 and reg2 enter linearly, off is an offset, i.e. no coefficient
# will be estimated for it
formula &lt;- Y ~ f(X) + reg1 + reg2 + offset(off)

# Fit a GeDS model specified in formula using NGeDS
(Gmod &lt;- NGeDS(formula, beta = 0.6, phi = 0.995, Xextr = c(-2,2)))


</code></pre>

<hr>
<h2 id='formula.GeDS'>Formula for the predictor model</h2><span id='topic+formula.GeDS'></span>

<h3>Description</h3>

<p>A description of the structure of a predictor model to be fitted using
<code><a href="#topic+NGeDS">NGeDS</a></code> and/or <code><a href="#topic+GGeDS">GGeDS</a></code> and how this information can
be extracted from a <code><a href="#topic+GeDS-class">GeDS-class</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GeDS'
formula(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="formula.GeDS_+3A_x">x</code></td>
<td>
<p>Fitted <code><a href="#topic+GeDS-class">GeDS-class</a></code> object, tipically produced by
<code><a href="#topic+NGeDS">NGeDS</a></code> or <code><a href="#topic+GGeDS">GGeDS</a></code> from which the predictor model
<code><a href="stats.html#topic+formula">formula</a></code> should be extracted.</p>
</td></tr>
<tr><td><code id="formula.GeDS_+3A_...">...</code></td>
<td>
<p>Unused in this case.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the GeDS GNM (GLM) regression, implemented in <code><a href="#topic+NGeDS">NGeDS</a></code> and
<code><a href="#topic+GGeDS">GGeDS</a></code>, it is assumed that the mean of the response variable
transformed using an appropriate link function is modelled through a possibly
multivariate predictor model involving two components: a GeD variable knot
spline regression component involving up to two of the independent variables
and a parametric component with respect to  the remaining independent
variables. The formula is used to specify the structure of such a possibly
multivariate predictor model.
</p>
<p>The formulae that are input in <code><a href="#topic+NGeDS">NGeDS</a></code> and <code><a href="#topic+GGeDS">GGeDS</a></code>
are similar to those input in <code><a href="stats.html#topic+lm">lm</a></code> or
<code><a href="stats.html#topic+glm">glm</a></code> except that the function <code><a href="#topic+f">f</a></code> should be
specified in order to identify which of the covariates enter the GeD spline
regression part of the predictor model. For example,  if the predictor model
is univariate and it links the transformed means of <code>y</code> to <code>x1</code>,
the predictor has only a GeD spline component and the
<code><a href="stats.html#topic+formula">formula</a></code> should be in the form <code>y ~ f(x1)</code>.
</p>
<p>As noted, there may be additional independent variables, <code>x2</code>,
<code>x3</code>, ... which may enter linearly into the parametric component of the
predictor model and not be part of the GeD spline regression component. For
example one may use the formula <code>y ~ f(x1) + x2 + x3</code> which assumes a
spline regression only between the transformed mean of <code>y</code> and <code>x1</code>,
while <code>x2</code> and <code>x3</code> enter the predictor model just linearly.
</p>
<p>In the current version of the package, <code><a href="#topic+GGeDS">GGeDS</a></code> is univariate,
therefore only one covariate which enters the spline regression component can
be specified.
</p>
<p>In contrast, the function <code><a href="#topic+NGeDS">NGeDS</a></code>, generates also bivariate GeDS
regression models. Therefore, if the functional dependence of the mean of the
response variable <code>y</code> on <code>x1</code> and <code>x2</code> needs to be jointly
modelled and there are no other covariates, the formula for the corresponding
two dimensional predictor model should be specified as <code>y ~ f(x1,x2)</code>.
</p>
<p>Within the argument <code>formula</code>, similarly as in other <span class="rlang"><b>R</b></span> functions, it is
possible to specify one or more offset variables, i.e. known terms with fixed
regression coefficients equal to 1. These terms should be identified via the
function <code><a href="stats.html#topic+offset">offset</a></code>.
</p>

<hr>
<h2 id='GeDS-class'>GeDS Class</h2><span id='topic+GeDS-class'></span><span id='topic+GeDS-Class'></span>

<h3>Description</h3>

<p>A fitted GeDS object returned by the functions <code><a href="#topic+NGeDS">NGeDS</a></code> or
<code><a href="#topic+GGeDS">GGeDS</a></code> inheriting the methods from class <code>"GeDS"</code>. Methods
for functions <code>coef</code>, <code>knots</code>, <code>print</code>, <code>predict</code>,
<code>plot</code>, and <code>lines</code> are available.
</p>


<h3>Slots</h3>


<dl>
<dt><code>Type</code></dt><dd><p>Character string indicating the type of the regression performed.
One of <code>"LM - Univ"</code>, <code>"LM - Biv"</code> or <code>"GLM - Univ"</code>
corresponding to the Normal univariate GeDS, the Normal bivariate GeDS
performed by <code><a href="#topic+NGeDS">NGeDS</a></code> and the generalized (GNM-GLM) univariate
GeDS performed by <code><a href="#topic+GGeDS">GGeDS</a></code>.</p>
</dd>
<dt><code>Linear.Knots</code></dt><dd><p>Vector containing the locations of the knots of the
second order GeDS spline fit generated at stage A.</p>
</dd>
<dt><code>Quadratic.Knots</code></dt><dd><p>Vector containing the locations of the knots of the
third order GeDS spline fitted in stage B.</p>
</dd>
<dt><code>Cubic.knots</code></dt><dd><p>Vector containing the locations of the knots of the fourth
order GeDS spline fitted in stage B.</p>
</dd>
<dt><code>Dev.Linear</code></dt><dd><p>Deviance of the second order GeD spline fit of stage A.</p>
</dd>
<dt><code>Dev.Quadratic</code></dt><dd><p>Deviance of the third order GeD spline fit of stage B.</p>
</dd>
<dt><code>Dev.Cubic</code></dt><dd><p>Deviance of the fourth order GeD spline fit of stage B.</p>
</dd>
<dt><code>RSS</code></dt><dd><p>Vector containing the deviances of the second order spline
fits computed at each GeDS iteration in stage A.</p>
</dd>
<dt><code>Linear</code></dt><dd><p>List containing the results from running a <code><a href="#topic+SplineReg">SplineReg</a></code>
function used to fit the second order spline of stage A.</p>
</dd>
<dt><code>Quadratic</code></dt><dd><p>List containing the results from running <code><a href="#topic+SplineReg">SplineReg</a></code>
function used to fit the third order spline in stage B.</p>
</dd>
<dt><code>Cubic</code></dt><dd><p>List containing the results from a <code><a href="#topic+SplineReg">SplineReg</a></code>
function used to fit the fourth order spline in stage B.</p>
</dd>
<dt><code>Stored</code></dt><dd><p>Matrix containing the knot locations estimated at each step of
stage A.</p>
</dd>
<dt><code>Args</code></dt><dd><p>List containing the input arguments passed on the
<code><a href="#topic+Fitters">Fitters</a></code> functions.</p>
</dd>
<dt><code>Call</code></dt><dd><p><code>call</code> to the <code><a href="#topic+Fitters">Fitters</a></code> functions.</p>
</dd>
<dt><code>Nintknots</code></dt><dd><p>The final number of internal knots of the second order GeD
spline fit of stage A.</p>
</dd>
<dt><code>iters</code></dt><dd><p>Number of iterations performed in stage A  of the GeDS fitting
procedure.</p>
</dd>
<dt><code>Guesses</code></dt><dd><p>Initial values for the coefficients used at each iteration of
stage A in order to estimate the spline coefficients. Since the initial
values are used only in the IRLS procedure, this slot is empty if the object
is not created by <code><a href="#topic+GGeDS">GGeDS</a></code> or <code><a href="#topic+GenUnivariateFitter">GenUnivariateFitter</a></code>
functions.</p>
</dd>
<dt><code>Coefficients</code></dt><dd><p>Matrix containing the fitted coefficients of the GeD
spline regression  component and the parametric component at each iteration
of stage A.</p>
</dd>
<dt><code>deviance</code></dt><dd><p>Vector containing the deviances of the second order spline
fits computed at each IRLS iteration in stage A.  Since the IRLS procedure is
used only in <code><a href="#topic+GGeDS">GGeDS</a></code> or <code><a href="#topic+GenUnivariateFitter">GenUnivariateFitter</a></code>, this
slot is empty if the object is not created by one of these functions.</p>
</dd>
<dt><code>iterIrls</code></dt><dd><p>Vector containing the numbers of IRLS iterations for all
iterations of stage A cumulatively. Since the IRLS procedure is used only in
<code><a href="#topic+GGeDS">GGeDS</a></code> or <code><a href="#topic+GenUnivariateFitter">GenUnivariateFitter</a></code>, this slot is empty
if the object is not created by one of these functions.</p>
</dd>
<dt><code>stopinfo</code></dt><dd><p>List of values providing information related to the stopping
rule of stage A of GeDS. The sub-slots of <code>stopinfo</code> are <code>phis</code>,
<code>phis_star</code>, <code>oldintc</code> and <code>oldslp</code>. The sub-slot <code>phis</code>
is a vector containing the values of the ratios of deviances (or the
difference of deviances if the <code>LR</code> stopping rule was chosen). The
sub-slots <code>phis_star</code>, <code>oldintc</code> and <code>oldslp</code> are non-empty
slots if the <code>SR</code> stopping rule was chosen. They contain respectively
<code class="reqn">\hat{\phi}_{\kappa}</code>, <code class="reqn">\hat{\gamma}_0</code> and <code class="reqn">\hat{\gamma}_1</code>
computed at each iteration of stage A, see Dimitrova et al. (2023).</p>
</dd>
<dt><code>Formula</code></dt><dd><p>The model <code><a href="#topic+formula.GeDS">formula</a></code>.</p>
</dd>
<dt><code>extcall</code></dt><dd><p><code>call</code> to the <code><a href="#topic+NGeDS">NGeDS</a></code> or <code><a href="#topic+GGeDS">GGeDS</a></code>
functions.</p>
</dd>
<dt><code>terms</code></dt><dd><p><code>terms</code> object containing information on the model frame.</p>
</dd>
</dl>


<h3>References</h3>

<p>Dimitrova, D. S., Kaishev, V. K., Lattuada, A. and Verrall, R. J.  (2023).
Geometrically designed variable knot splines in generalized (non-)linear
models.
<em>Applied Mathematics and Computation</em>, <strong>436</strong>. <br />
DOI: <a href="https://doi.org/10.1016/j.amc.2022.127493">doi:10.1016/j.amc.2022.127493</a>
</p>

<hr>
<h2 id='GeDSboost-class'>GeDSboost Class</h2><span id='topic+GeDSboost-class'></span><span id='topic+GeDSboost-Class'></span>

<h3>Description</h3>

<p>A fitted GeDSboost object returned by the function <code><a href="#topic+NGeDSboost">NGeDSboost</a></code>
inheriting the methods from class <code>"GeDSboost"</code>. Methods for functions
<code>coef</code>, <code>knots</code>, <code>print</code>, <code>predict</code>,
<code>visualize_boosting</code>, and <code>bl_imp</code> are available.
</p>


<h3>Slots</h3>


<dl>
<dt><code>extcall</code></dt><dd><p>call to the <code><a href="#topic+NGeDSboost">NGeDSboost</a></code> function.</p>
</dd>
<dt><code>formula</code></dt><dd><p>A formula object representing the model to be fitted.</p>
</dd>
<dt><code>args</code></dt><dd><p>A list containing the arguments passed to the <code><a href="#topic+NGeDSboost">NGeDSboost</a></code>
function. This list includes:
</p>

<ul>
<li> <p><code>response</code>: <code>data.frame</code> containing observations of the
response variable.
</p>
</li>
<li> <p><code>predictors</code>: <code>data.frame</code> containing observations of the
vector of predictor variables included in the model.
</p>
</li>
<li> <p><code>base_learners</code>: description of model's base learners.
</p>
</li>
<li> <p><code>family</code>: the statistical family. The possible options are
</p>

<ul>
<li> <p><code>mboost::AdaExp()</code>
</p>
</li>
<li> <p><code>mboost::AUC()</code>
</p>
</li>
<li> <p><code>mboost::Binomial(type = c("adaboost", "glm"),
  link = c("logit", "probit", "cloglog", "cauchit", "log"), ...)</code>
</p>
</li>
<li> <p><code>mboost::Gaussian()</code>
</p>
</li>
<li> <p><code>mboost::Huber(d = NULL)</code>
</p>
</li>
<li> <p><code>mboost::Laplace()</code>
</p>
</li>
<li> <p><code>mboost::Poisson()</code>
</p>
</li>
<li> <p><code>mboost::GammaReg(nuirange = c(0, 100))</code>
</p>
</li>
<li> <p><code>mboost::CoxPH()</code>
</p>
</li>
<li> <p><code>mboost::QuantReg(tau = 0.5, qoffset = 0.5)</code>
</p>
</li>
<li> <p><code>mboost::ExpectReg(tau = 0.5)</code>
</p>
</li>
<li> <p><code>mboost::NBinomial(nuirange = c(0, 100))</code>
</p>
</li>
<li> <p><code>mboost::PropOdds(nuirange = c(-0.5, -1), offrange = c(-5, 5))</code>
</p>
</li>
<li> <p><code>mboost::Weibull(nuirange = c(0, 100))</code>
</p>
</li>
<li> <p><code>mboost::Loglog(nuirange = c(0, 100))</code>
</p>
</li>
<li> <p><code>mboost::Lognormal(nuirange = c(0, 100))</code>
</p>
</li>
<li> <p><code>mboost::Gehan()</code>
</p>
</li>
<li> <p><code>mboost::Hurdle(nuirange = c(0, 100))</code>
</p>
</li>
<li> <p><code>mboost::Multinomial()</code>
</p>
</li>
<li> <p><code>mboost::Cindex(sigma = 0.1, ipcw = 1)</code>
</p>
</li>
<li> <p><code>mboost::RCG(nuirange = c(0, 1), offrange = c(-5, 5))</code>   
</p>
</li></ul>
   
</li>
<li> <p><code>initial_learner</code>: if <code>TRUE</code> a <code><a href="#topic+NGeDS">NGeDS</a></code> fit was
used as initial learner; otherwise, the empirical risk minimizer
corresponding to the selected <code>family</code> was employed.
</p>
</li>
<li> <p><code>int.knots_init</code>: if <code>initial_learner = TRUE</code> the maximum
number of internal knots set to the <code><a href="#topic+NGeDS">NGeDS</a></code> function before the
initial learner fit.
</p>
</li>
<li> <p><code>shrinkage</code>: shrinkage/step-length/learning rate utilized
throughout the boosting iterations.
</p>
</li>
<li> <p><code>normalize_data</code>: if <code>TRUE</code>, then response and predictors
were standardized before running the FGB algorithm.
</p>
</li>
<li> <p><code>X_mean</code>: mean of the predictor variables (only if
<code>normalize_data = TRUE</code>).
</p>
</li>
<li> <p><code>X_sd</code>: standard deviation of the predictors (only if
<code>normalize_data = TRUE</code>).
</p>
</li>
<li> <p><code>Y_mean</code>: mean of the response variable (only if
<code>normalize_data = TRUE</code>).
</p>
</li>
<li> <p><code>Y_sd</code>: standard deviation of the response variable (only if
<code>normalize_data = TRUE</code>).
</p>
</li></ul>
</dd>
<dt><code>models</code></dt><dd><p>A list containing the 'model' generated at each boosting
iteration. Each of these models includes:
</p>

<ul>
<li> <p><code>best_bl</code>: fit of the base learner that minimized the residual
sum of squares (RSS) in fitting the gradient at the <em>i</em>-th boosting
iteration.
</p>
</li>
<li> <p><code>Y_hat</code>: model fitted values at the <em>i</em>-th boosting
iteration.
</p>
</li>
<li> <p><code>base_learners</code>: knots and coefficients for each of the
base-learners at the <em>i</em>-th boosting iteration.  
</p>
</li></ul>
</dd>
<dt><code>final_model</code></dt><dd><p>A list detailing the final GeDSboost model after the
gradient descent algorithm is run. Apart of the components present in any
model it includes the quadratic and cubic fits obtained through Schoenberg
variation diminishing spline approximation. These include the same elements
as <code>Quadratic</code> and <code>Cubic</code> in a <code><a href="#topic+GeDS-class">GeDS-class</a></code> object
(see <code><a href="#topic+SplineReg">SplineReg</a></code> for details). <code>best_bl</code> is eliminated to
simplify the output.</p>
</dd>
<dt><code>predictions</code></dt><dd><p>A list containing the predicted values obtained (linear,
quadratic, and cubic).</p>
</dd>
<dt><code>internal_knots</code></dt><dd><p>A list detailing the internal knots obtained for the fits
of different order (linear, quadratic, and cubic).</p>
</dd>
</dl>


<h3>References</h3>

<p>Dimitrova, D. S., Kaishev, V. K., Lattuada, A. and Verrall, R. J.  (2023).
Geometrically designed variable knot splines in generalized (non-)linear
models.
<em>Applied Mathematics and Computation</em>, <strong>436</strong>. <br />
DOI: <a href="https://doi.org/10.1016/j.amc.2022.127493">doi:10.1016/j.amc.2022.127493</a>
</p>
<p>Dimitrova, D. S., Guillen, E. S. and Kaishev, V. K.  (2024).
<span class="pkg">GeDS</span>: An R Package for Regression, Generalized Additive
Models and Functional Gradient Boosting, based on Geometrically Designed
(GeD) Splines. <em>Manuscript submitted for publication.</em>
</p>

<hr>
<h2 id='GeDSgam-class'>GeDSgam Class</h2><span id='topic+GeDSgam-class'></span><span id='topic+GeDSgam-Class'></span>

<h3>Description</h3>

<p>A fitted GeDSgam object returned by the function <code><a href="#topic+NGeDSgam">NGeDSgam</a></code>
inheriting the methods from class <code>"GeDSgam"</code>. Methods for functions
<code>coef</code>, <code>knots</code>, <code>print</code> and <code>predict</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>extcall</code></dt><dd><p>call to the <code><a href="#topic+NGeDSgam">NGeDSgam</a></code> function.</p>
</dd>
<dt><code>formula</code></dt><dd><p>A formula object representing the model to be fitted.</p>
</dd>
<dt><code>args</code></dt><dd><p>A list containing the arguments passed to the <code><a href="#topic+NGeDSgam">NGeDSgam</a></code>
function. This list includes:
</p>

<ul>
<li> <p><code>response</code>: <code>data.frame</code> containing observations of the
response variable.
</p>
</li>
<li> <p><code>predictors</code>: <code>data.frame</code> containing observations of the
vector of predictor variables included in the model.
</p>
</li>
<li> <p><code>base_learners</code>: description of the model's base learners
('smooth functions').
</p>
</li>
<li> <p><code>family</code>: the statistical family. The possible options are
</p>

<ul>
<li> <p><code>binomial(link = "logit", "probit", "cauchit", "log", "cloglog")</code>
</p>
</li>
<li> <p><code>gaussian(link = "identity", "log", "inverse")</code>
</p>
</li>
<li> <p><code>Gamma(link = "inverse", "identity", "log")</code>
</p>
</li>
<li> <p><code>inverse.gaussian(link = "1/mu^2", "inverse", "identity", "log")</code>
</p>
</li>
<li> <p><code>poisson(link = "log", "identity", "sqrt")</code>
</p>
</li>
<li> <p><code>quasi(link = "identity", variance = "constant")</code>
</p>
</li>
<li> <p><code>quasibinomial(link = "logit", "probit", "cloglog", "identity", "inverse", "log", "1/mu^2", "sqrt")</code>
</p>
</li>
<li> <p><code>quasipoisson(llink = "logit", "probit", "cloglog", "identity", "inverse", "log", "1/mu^2", "sqrt")</code>   
</p>
</li></ul>

</li>
<li> <p><code>normalize_data</code>: if <code>TRUE</code>, then response and predictors
were standardized before running the local-scoring algorithm.
</p>
</li>
<li> <p><code>X_mean</code>: mean of the predictor variables (only if
<code>normalize_data = TRUE</code>).
</p>
</li>
<li> <p><code>X_sd</code>: standard deviation of the predictors (only if
<code>normalize_data = TRUE</code>).
</p>
</li>
<li> <p><code>Y_mean</code>: mean of the response variable (only if
<code>normalize_data = TRUE</code>).
</p>
</li>
<li> <p><code>Y_sd</code>: standard deviation of the response variable (only if
<code>normalize_data = TRUE</code>).
</p>
</li></ul>
</dd>
<dt><code>final_model</code></dt><dd><p>A list detailing the final GeDSgam model selected after
running the local scoring algorithm. The chosen model minimizes deviance
across all models generated by each local-scoring iteration. This list
includes:
</p>

<ul>
<li> <p><code>model_name</code>: local-scoring iteration that yielded the best
model. Note that when <code>family = "gaussian"</code>, it will always correspond
to <code>iter1</code>, as only one local-scoring iteration is conducted in this
scenario. This occurs because, with <code>family = "gaussian"</code>, the
algorithm is equivalent to simply backfitting.
</p>
</li>
<li> <p><code>DEV</code>: the deviance for the fitted predictor model, defined as
in Dimitrova et al. (2023), which for <code>family = "gaussian"</code> coincides
with the Residual Sum of Squares.
</p>
</li>
<li> <p><code>Y_hat</code>: fitted values.
</p>

<ul>
<li> <p><code>eta</code>: additive predictor.
</p>
</li>
<li> <p><code>mu</code>: vector of means.
</p>
</li>
<li> <p><code>z</code>: adjusted dependent variable.      
</p>
</li></ul>

</li>
<li> <p><code>base_learners</code>: internal knots and coefficients of the final
model for each of the base-learners.
</p>
</li>
<li> <p><code>Quadratic.Fit</code>: quadratic fit obtained via Schoenberg variation
diminishing spline approximation. See for details <code><a href="#topic+SplineReg">SplineReg</a></code>.
</p>
</li>
<li> <p><code>Cubic.Fit</code>: cubic fit obtained via Schoenberg variation
diminishing spline approximation. See for details <code><a href="#topic+SplineReg">SplineReg</a></code>.
</p>
</li></ul>
</dd>
<dt><code>predictions</code></dt><dd><p>A list containing the predicted values obtained (linear,
quadratic, and cubic). Each of the predictions contains both the additive
predictor <code>eta</code> and the vector of means <code>mu</code>.</p>
</dd>
<dt><code>internal_knots</code></dt><dd><p>A list detailing the internal knots obtained for the fits
of different order (linear, quadratic, and cubic).</p>
</dd>
</dl>


<h3>References</h3>

<p>Dimitrova, D. S., Kaishev, V. K., Lattuada, A. and Verrall, R. J.  (2023).
Geometrically designed variable knot splines in generalized (non-)linear
models.
<em>Applied Mathematics and Computation</em>, <strong>436</strong>. <br />
DOI: <a href="https://doi.org/10.1016/j.amc.2022.127493">doi:10.1016/j.amc.2022.127493</a>
</p>
<p>Dimitrova, D. S., Guillen, E. S. and Kaishev, V. K.  (2024).
<span class="pkg">GeDS</span>: An R Package for Regression, Generalized Additive
Models and Functional Gradient Boosting, based on Geometrically Designed
(GeD) Splines. <em>Manuscript submitted for publication.</em>
</p>

<hr>
<h2 id='GGeDS'>Generalized Geometrically Designed Spline regression estimation</h2><span id='topic+GGeDS'></span>

<h3>Description</h3>

<p><code>GGeDS</code> constructs a Geometrically Designed (univariate) variable knots
spline regression model for the predictor  in the context of Generalized
(Non-)Linear Models, referred to as a GeDS model, for a response with a
pre-specified distribution from the Exponential Family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GGeDS(
  formula,
  data,
  family = gaussian(),
  weights,
  beta,
  phi = 0.99,
  min.intknots,
  max.intknots,
  q = 2L,
  Xextr = NULL,
  Yextr = NULL,
  show.iters = FALSE,
  stoptype = "SR",
  higher_order = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GGeDS_+3A_formula">formula</code></td>
<td>
<p>a description of the structure of the predictor model to be
fitted, including the dependent and independent variables. See
<code><a href="#topic+formula.GeDS">formula</a></code> for details.</p>
</td></tr>
<tr><td><code id="GGeDS_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment containing the
variables of the predictor model. In case the variables are not found in
<code>data</code>, they are taken from <code>environment(formula)</code>, typically the
environment from which <code>GGeDS</code> is called.</p>
</td></tr>
<tr><td><code id="GGeDS_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to be
used in the model. This can be a character string naming a family function
(e.g. <code>"gaussian"</code>), the family function itself (e.g.
<code><a href="stats.html#topic+gaussian">gaussian</a></code>) or the result of a call to a family function
(e.g. <code>gaussian()</code>). See <a href="stats.html#topic+family">family</a> for details on family
functions.</p>
</td></tr>
<tr><td><code id="GGeDS_+3A_weights">weights</code></td>
<td>
<p>an optional vector of &lsquo;prior weights&rsquo; to be put on the
observations in the fitting process in case the user requires weighted GeDS
fitting. It is <code>NULL</code> by default.</p>
</td></tr>
<tr><td><code id="GGeDS_+3A_beta">beta</code></td>
<td>
<p>numeric parameter in the interval <code class="reqn">[0,1]</code> tuning the knot
placement in stage A of GeDS. See details below.</p>
</td></tr>
<tr><td><code id="GGeDS_+3A_phi">phi</code></td>
<td>
<p>numeric parameter in the interval <code class="reqn">[0,1]</code> specifying the
threshold for the stopping rule  (model selector) in stage A of GeDS. See
also <code>stoptype</code> and details below.</p>
</td></tr>
<tr><td><code id="GGeDS_+3A_min.intknots">min.intknots</code></td>
<td>
<p>optional parameter allowing the user to set a minimum
number of internal knots required. By default equal to zero.</p>
</td></tr>
<tr><td><code id="GGeDS_+3A_max.intknots">max.intknots</code></td>
<td>
<p>optional parameter allowing the user to set a maximum
number of internal knots to be added by the GeDS estimation algorithm. By
default equal to the number of knots for the saturated GeDS model (i.e.
<code class="reqn">N-2</code>, where <code class="reqn">N</code> is the number of observations).</p>
</td></tr>
<tr><td><code id="GGeDS_+3A_q">q</code></td>
<td>
<p>numeric parameter which allows to fine-tune the stopping rule of
stage A of GeDS, by default equal to 2. See details below.</p>
</td></tr>
<tr><td><code id="GGeDS_+3A_xextr">Xextr</code></td>
<td>
<p>numeric vector of 2 elements representing the left-most and
right-most limits of the interval embedding the observations of the
independent variable. See details.</p>
</td></tr>
<tr><td><code id="GGeDS_+3A_yextr">Yextr</code></td>
<td>
<p>numeric vector of 2 elements representing the left-most and
right-most limits of the interval embedding the observations of the second
independent variable (if the bivariate GeDS is run). See details.</p>
</td></tr>
<tr><td><code id="GGeDS_+3A_show.iters">show.iters</code></td>
<td>
<p>logical variable indicating whether or not to print
information at each step. By default equal to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="GGeDS_+3A_stoptype">stoptype</code></td>
<td>
<p>a character string indicating the type of GeDS stopping rule
to be used. It should be either one of <code>"SR"</code>, <code>"RD"</code> or 
<code>"LR"</code>, partial match allowed. See details below.</p>
</td></tr>
<tr><td><code id="GGeDS_+3A_higher_order">higher_order</code></td>
<td>
<p>a logical that defines whether to compute the higher
order fits (quadratic and cubic) after stage A is run. Default is
<code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The  <code>GGeDS</code> function extends the GeDS methodology, recently developed
by Kaishev et al. (2016) and implemented in the <code><a href="#topic+NGeDS">NGeDS</a></code> function
for the Normal case, to the more general GNM (GLM) context, allowing for the
response to have any distribution from the Exponential Family. Under the
GeDS-GNM approach the (non-)linear predictor is viewed as a spline with 
variable knots which are estimated along with the regression coefficients and
the order of the spline, using a two stage procedure. In stage A, a linear
variable-knot spline is fitted to the data applying iteratively re-weighted
least squares (see <code><a href="#topic+IRLSfit">IRLSfit</a></code> function). In stage B, a Schoenberg
variation diminishing spline approximation to the fit from stage A is
constructed, thus simultaneously producing spline fits of order 2, 3 and 4,
all of which are included in the output, a <code><a href="#topic+GeDS-Class">GeDS-Class</a></code> object.
A detailed description of the underlying algorithm can be found in
Dimitrova et al. (2023).
</p>
<p>As noted in <code><a href="#topic+formula.GeDS">formula</a></code>, the argument <code>formula</code>
allows the user to specify predictor models with two components, a spline
regression (non-parametric) component involving part of the independent
variables identified through the function <code>f</code> and an optional parametric
component involving the remaining independent variables. For <code>GGeDS</code>
only one independent variable is allowed for the spline component and
arbitrary many independent variables for the parametric component of the
predictor. Failure to specify the independent variable for the  spline
regression component through the function <code>f</code> will return an error.
See <code><a href="#topic+formula.GeDS">formula</a></code>.
</p>
<p>Within the argument <code>formula</code>, similarly as in other <span class="rlang"><b>R</b></span> functions, it is
possible to specify one or more offset variables, i.e. known terms with fixed
regression coefficients equal to 1. These terms should be identified via the
function <code><a href="stats.html#topic+offset">offset</a></code>.
</p>
<p>The parameter <code>beta</code> tunes the placement of a new knot in stage A of the
algorithm. Once a current second-order  spline is fitted to the data the
'working' residuals (see <code><a href="#topic+IRLSfit">IRLSfit</a></code>) are computed and grouped by
their sign. A new knot is placed  at a location defined by the group for
which a certain measure attains its maximum. The latter measure is defined as
a weighted linear combination of the range of each group and the  mean of the
absolute residuals within it. The parameter <code>beta</code> determines the
weights in this measure correspondingly as  <code>beta</code> and <code>1 - beta</code>.
The  higher it is, the more weight is put to the mean of the residuals and
the less to the range of their corresponding x-values (see
Kaishev et al., 2016, for further details).
</p>
<p>The default values of <code>beta</code> are <code>beta = 0.5</code> if the response is
assumed to be Gaussian, <code>beta = 0.2</code> if it is Poisson (or Quasipoisson),
while if it is Binomial, Quasibinomial or Gamma <code>beta = 0.1</code>, which
reflect our experience of running GeDS for different underlying functional
dependencies.
</p>
<p>The argument <code>stoptype</code> allows to choose between three alternative
stopping rules for the knot selection in stage A of GeDS, the <code>"RD"</code>,
that stands for <em>Ratio of Deviances</em>, the <code>"SR"</code>, that stands for
<em>Smoothed Ratio</em> of deviances and the <code>"LR"</code>, that stands for
<em>Likelihood Ratio</em>. The latter is based on the difference of deviances
rather than on their ratio as in the case of <code>"RD"</code> and <code>"SR"</code>.
Therefore <code>"LR"</code> can be viewed as a log likelihood ratio test performed
at each iteration of the knot placement. In each of these cases the
corresponding stopping criterion is compared with a threshold value 
<code>phi</code> (see below).
</p>
<p>The argument <code>phi</code> provides a threshold value required for the stopping
rule to exit the knot placement in stage A of GeDS. The higher the value of
<code>phi</code>, the more knots are added under the <code>"RD"</code> and <code>"SR"</code>
stopping rules contrary to the case of the stopping rule <code>"LR"</code> where
the lower <code>phi</code> is, more knots are included in the spline regression.
Further details for each of the three alternative stopping rules can be found
in Dimitrova et al. (2023).
</p>
<p>The argument <code>q</code> is an input parameter that allows to fine-tune the
stopping rule in stage A. It identifies the number of consecutive iterations
over which the deviance should exhibit stable convergence so as the knot
placement in stage A is terminated. More precisely, under any of the rules
<code>"RD"</code>, <code>"SR"</code> or <code>"LR"</code> the deviance at the current iteration
is compared to the deviance computed <code>q</code> iterations before, i.e. before
selecting the last <code>q</code> knots. Setting a higher <code>q</code> will lead to
more knots being added before exiting stage A of GeDS.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+GeDS-Class">GeDS-Class</a></code> object, i.e. a list of items that
summarizes  the main details of the fitted GeDS regression. See
<code><a href="#topic+GeDS-Class">GeDS-Class</a></code> for details. Some S3 methods are available in order
to make these objects tractable, such as <code><a href="#topic+coef.GeDS">coef</a></code>,
<code><a href="#topic+deviance.GeDS">deviance</a></code>, <code><a href="#topic+knots.GeDS">knots</a></code>,
<code><a href="#topic+predict.GeDS">predict</a></code> and <code><a href="#topic+print.GeDS">print</a></code>
as well as S4 methods for <code><a href="#topic+lines.GeDS">lines</a></code> and
<code><a href="#topic+plot.GeDS">plot</a></code>.
</p>


<h3>References</h3>

<p>Kaishev, V.K., Dimitrova, D.S., Haberman, S. and Verrall, R.J. (2016).
Geometrically designed, variable knot regression splines.
<em>Computational Statistics</em>, <strong>31</strong>, 1079&ndash;1105. <br />
DOI: <a href="https://doi.org/10.1007/s00180-015-0621-7">doi:10.1007/s00180-015-0621-7</a>
</p>
<p>Dimitrova, D. S., Kaishev, V. K., Lattuada, A. and Verrall, R. J.  (2023).
Geometrically designed variable knot splines in generalized (non-)linear
models.
<em>Applied Mathematics and Computation</em>, <strong>436</strong>. <br />
DOI: <a href="https://doi.org/10.1016/j.amc.2022.127493">doi:10.1016/j.amc.2022.127493</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NGeDS">NGeDS</a></code>; <code><a href="#topic+GeDS-Class">GeDS-Class</a></code>; S3 methods such as
<code><a href="#topic+coef.GeDS">coef.GeDS</a></code>, <code><a href="#topic+deviance.GeDS">deviance.GeDS</a></code>, 
<code><a href="#topic+knots.GeDS">knots.GeDS</a></code>, <code><a href="#topic+print.GeDS">print.GeDS</a></code> and
<code><a href="#topic+predict.GeDS">predict.GeDS</a></code>; <code><a href="#topic+Integrate">Integrate</a></code> and <code><a href="#topic+Derive">Derive</a></code>;
<code><a href="#topic+PPolyRep">PPolyRep</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>######################################################################
# Generate a data sample for the response variable Y and the covariate X
# assuming Poisson distributed error and log link function
# See section 4.1 in Dimitrova et al. (2023)
set.seed(123)
N &lt;- 500
f_1 &lt;- function(x) (10*x/(1+100*x^2))*4+4
X &lt;- sort(runif(N, min = -2, max = 2))
# Specify a model for the mean of Y to include only a component
# non-linear in X, defined by the function f_1
means &lt;- exp(f_1(X))

#############
## POISSON ##
#############
# Generate Poisson distributed Y according to the mean model
Y &lt;- rpois(N, means)

# Fit a Poisson GeDS regression using GGeDS
(Gmod &lt;- GGeDS(Y ~ f(X), beta = 0.2, phi = 0.995, family = poisson(),
                Xextr = c(-2,2)))

# Plot the quadratic and cubic GeDS fits
plot(X,log(Y),xlab = "x", ylab = expression(f[1](x)))
lines(Gmod, n = 3, col = "red")
lines(Gmod, n = 4, col = "blue", lty = 2)
legend("topleft", c("Quadratic", "Cubic"),
       col = c("red", "blue"), lty = c(1,2))

# Generate GeDS prediction at X=0, first on the response scale and then on
# the predictor scale
predict(Gmod, n = 3, newdata = data.frame(X = 0))
predict(Gmod, n = 3, newdata = data.frame(X = 0), type = "link")

# Apply some of the other available methods, e.g.
# knots, coefficients and deviance extractions for the
# quadratic GeDS fit
knots(Gmod)
coef(Gmod)
deviance(Gmod)

# the same but for the cubic GeDS fit
knots(Gmod, n = 4)
coef(Gmod, n = 4)
deviance(Gmod, n = 4)

###########
## GAMMA ##
###########
# Generate Gamma distributed Y according to the mean model
Y &lt;- rgamma(N, shape = means, rate = 0.1)
# Fit a Gamma GeDS regression using GGeDS
Gmod &lt;- GGeDS(Y ~ f(X), beta = 0.1, phi = 0.995, family =  Gamma(log),
              Xextr = c(-2,2))
plot(Gmod, f = function(x) exp(f_1(x))/0.1)

##############
## BINOMIAL ##
##############
# Generate Binomial distributed Y according to the mean model
eta &lt;- f_1(X) - 4
means &lt;- exp(eta)/(1+exp(eta))
Y &lt;- rbinom(N, size = 50, prob = means) / 50
# Fit a Binomial GeDS regression using GGeDS
Gmod &lt;- GGeDS(Y ~ f(X), beta = 0.1, phi = 0.995, family =  "binomial",
              Xextr = c(-2,2))
plot(Gmod, f = function(x) exp(f_1(x) - 4)/(1 + exp(f_1(x) - 4)))


##########################################
# A real data example
# See Dimitrova et al. (2023), Section 4.2

data("coalMining")
(Gmod2 &lt;- GGeDS(formula = accidents ~ f(years), beta = 0.1, phi = 0.98,
                 family = poisson(), data = coalMining))
(Gmod3 &lt;- GGeDS(formula = accidents ~ f(years), beta = 0.1, phi = 0.985,
                 family = poisson(), data = coalMining))
plot(coalMining$years, coalMining$accidents, type = "h", xlab = "Years",
     ylab = "Accidents")
lines(Gmod2, tr = exp, n = 4, col = "red")
lines(Gmod3, tr = exp, n = 4, col = "blue", lty = 2)
legend("topright", c("phi = 0.98","phi = 0.985"), col = c("red", "blue"),
       lty=c(1, 2))


## Not run: 
##########################################
# The same regression in the example of GeDS
# but assuming Gamma and Poisson responses
# See Dimitrova et al. (2023), Section 4.2

data('BaFe2As2')
(Gmod4 &lt;- GGeDS(intensity ~ f(angle), data = BaFe2As2, beta = 0.6, phi = 0.995, q = 3,
                family = Gamma(log), stoptype = "RD"))
plot(Gmod4)

(Gmod5 &lt;- GGeDS(intensity ~ f(angle), data = BaFe2As2, beta = 0.1, phi = 0.995, q = 3,
                family = poisson(), stoptype = "SR"))
plot(Gmod5)

## End(Not run)

##########################################
# Life tables
# See Dimitrova et al. (2023), Section 4.2

data(EWmortality)
attach(EWmortality)
(M1 &lt;- GGeDS(formula = Deaths ~ f(Age) + offset(log(Exposure)),
              family = poisson(), phi = 0.99, beta = 0.1, q = 3,
              stoptype = "LR"))

Exposure_init &lt;- Exposure + 0.5 * Deaths
Rate &lt;- Deaths / Exposure_init
(M2 &lt;- GGeDS(formula = Rate ~ f(Age), weights = Exposure_init,
              family = quasibinomial(), phi = 0.99, beta = 0.1,
              q = 3, stoptype = "LR"))


op &lt;- par(mfrow=c(2,2))
plot(Age, Deaths/Exposure, ylab = expression(mu[x]), xlab = "Age")
lines(M1, n = 3, tr = exp, lwd = 1, col = "red")
plot(Age, Rate, ylab = expression(q[x]), xlab = "Age")
lines(M2, n = 3, tr = quasibinomial()$linkinv, lwd = 1, col = "red")
plot(Age, log(Deaths/Exposure), ylab = expression(log(mu[x])), xlab = "Age")
lines(M1, n = 3, lwd = 1, col = "red")
plot(Age, quasibinomial()$linkfun(Rate), ylab = expression(logit(q[x])), xlab = "Age")
lines(M2, n = 3, lwd = 1, col = "red")
par(op)

#########################################
# bivariate example
set.seed(123)
doublesin &lt;- function(x) {
# Adjusting the output to ensure it's positive
exp(sin(2*x[,1]) + sin(2*x[,2]))
}
X &lt;- round(runif(400, min = 0, max = 3), 2)
Y &lt;- round(runif(400, min = 0, max = 3), 2)
# Calculate lambda for Poisson distribution
lambda &lt;- doublesin(cbind(X,Y))
# Generate Z from Poisson distribution
Z &lt;- rpois(400, lambda)
data &lt;- data.frame(X, Y, Z)

# Fit a Poisson GeDS regression using GGeDS
BivGeDS &lt;- GGeDS(Z ~ f(X,Y), beta = 0.2, phi = 0.995, family = "poisson",
Xextr = c(0, 3), Yextr = c(0, 3))

# MSEs w.r.t data
mean((Z-BivGeDS$Linear$Predicted)^2)
mean((Z-BivGeDS$Quadratic$Predicted)^2)
mean((Z-BivGeDS$Cubic$Predicted)^2)

# MSEs w.r.t true function
f_XY &lt;- apply(cbind(X, Y), 1, function(row) doublesin(matrix(row, ncol = 2)))
mean((f_XY - BivGeDS$Linear$Predicted)^2)
mean((f_XY - BivGeDS$Quadratic$Predicted)^2)
mean((f_XY - BivGeDS$Cubic$Predicted)^2)

# Surface plot of the generating function (doublesin)
plot(BivGeDS, f = doublesin)
# Surface plot of the fitted model
plot(BivGeDS)

</code></pre>

<hr>
<h2 id='Integrate'>Defined integral of GeDS objects</h2><span id='topic+Integrate'></span>

<h3>Description</h3>

<p>This function computes defined integrals of a fitted GeDS regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Integrate(object, to, from, n = 3L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Integrate_+3A_object">object</code></td>
<td>
<p>the <code><a href="#topic+GeDS-class">GeDS-class</a></code> object containing the  GeDS fit
which should be integrated. It should be the result of fitting a univariate
GeDS regression via <code><a href="#topic+NGeDS">NGeDS</a></code> or <code><a href="#topic+GGeDS">GGeDS</a></code>.</p>
</td></tr>
<tr><td><code id="Integrate_+3A_to">to</code></td>
<td>
<p>numeric vector containing the upper limit(s) of integration.</p>
</td></tr>
<tr><td><code id="Integrate_+3A_from">from</code></td>
<td>
<p>optional numeric vector containing the lower limit(s) of
integration. It should be either of size one or of the same size as the
argument <code>to</code>. If left unspecified, by default it is set to the left-most
limit of the interval embedding the observations of the independent variable.</p>
</td></tr>
<tr><td><code id="Integrate_+3A_n">n</code></td>
<td>
<p>integer value (2, 3 or 4) specifying the order (<code class="reqn">=</code> degree
<code class="reqn">+ 1</code>) of the GeDS fit to be integrated. By default equal to <code>3L</code>.
Non-integer values will be passed to the function <code><a href="base.html#topic+as.integer">as.integer</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is based on the well known property (c.f. De Boor, 2001, Chapter
X, formula (33)) that the integral of a linear combination of appropriately
normalized B-splines is equal to the sum of its corresponding coefficients,
noting that the GeDS regression is in fact such a linear combination.
</p>
<p>Since the function is based on this property, it is designed to work only on
the predictor scale in the GNM (GLM) framework.
</p>
<p>If the argument <code>from</code> is a single value, then it is taken as the lower
limit of integration for all the defined integrals required, whereas the upper
limits of integration are the values contained in the argument <code>to</code>. If
the arguments <code>from</code> and <code>to</code> are of similar size, the integrals
(as many as the size) are computed by sequentially taking the pairs of values
in the <code>from</code> and <code>to</code> vectors as limits of integration.
</p>


<h3>References</h3>

<p>De Boor, C. (2001). <em>A Practical Guide to Splines (Revised Edition)</em>.
Springer, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate a data sample for the response variable
# Y and the single covariate X
# see Dimitrova et al. (2023), section 4.1
set.seed(123)
N &lt;- 500
f_1 &lt;- function(x) (10*x/(1+100*x^2))*4+4
X &lt;- sort(runif(N, min = -2, max = 2))
# Specify a model for the mean of Y to include only
# a component non-linear in X, defined by the function f_1
means &lt;- f_1(X)
# Add (Normal) noise to the mean of Y
Y &lt;- rnorm(N, means, sd = 0.1)

# Fit GeDS regression using NGeDS
Gmod &lt;- NGeDS(Y ~ f(X), beta = 0.6, phi = .995, Xextr = c(-2,2))

# Compute defined integrals (in TeX style) $\int_{1}^{-1} f(x)dx$
# and $\int_{1}^{1} f(x)dx$
# $f$ being the quadratic fit
Integrate(Gmod, to = c(-1,1), from = 1, n = 3)

# Compute defined integrals (in TeX style) $\int_{1}^{-1} f(x)dx$
# and $\int_{-1}^{1} f(x)dx$
# $f$ being the quadratic fit
Integrate(Gmod, to = c(-1,1), from = c(1,-1), n = 3)

## Not run: 
## This gives an error
Integrate(Gmod, to = 1, from = c(1,-1), n = 3)

## End(Not run)

</code></pre>

<hr>
<h2 id='IRLSfit'>IRLS Estimation</h2><span id='topic+IRLSfit'></span>

<h3>Description</h3>

<p>This function is an implementation of the IRLS estimation algorithm adjusted
to the specific usage in the function <code><a href="#topic+SplineReg_GLM">SplineReg_GLM</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IRLSfit(
  x,
  y,
  weights = rep(1, nobs),
  mustart = NULL,
  offset = rep(0, nobs),
  family = gaussian(),
  control = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IRLSfit_+3A_x">x</code></td>
<td>
<p>a matrix of regression functions (e.g. B-splines and/or terms of the
parametric part) evaluated at the sample values of the covariate(s).</p>
</td></tr>
<tr><td><code id="IRLSfit_+3A_y">y</code></td>
<td>
<p>a vector of size <code class="reqn">N</code> containing the observed values of the
response variable <code class="reqn">y</code>.</p>
</td></tr>
<tr><td><code id="IRLSfit_+3A_weights">weights</code></td>
<td>
<p>an optional vector of &lsquo;prior weights&rsquo; to be put on the
observations in case the user requires weighted IRLS fitting. It is a vector
of 1s by default.</p>
</td></tr>
<tr><td><code id="IRLSfit_+3A_mustart">mustart</code></td>
<td>
<p>initial values for the vector of means of the response
variable in the IRLS regression estimation. Must be a vector of length <code class="reqn">N</code>.</p>
</td></tr>
<tr><td><code id="IRLSfit_+3A_offset">offset</code></td>
<td>
<p>a vector of size <code class="reqn">N</code> that can be used to specify a fixed
covariate to be included in the predictor model  avoiding the estimation of
its corresponding regression coefficient. In case  more than one covariate is
fixed, the user should sum the corresponding coordinates of the fixed
covariates to produce one common <code class="reqn">N</code>-vector of coordinates.</p>
</td></tr>
<tr><td><code id="IRLSfit_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to be
used in the model. This can be a character string naming a family function
(e.g. <code>"gaussian"</code>), the family function itself (e.g.
<code><a href="stats.html#topic+gaussian">gaussian</a></code>) or the result of a call to a family function
(e.g. <code>gaussian()</code>). See <a href="stats.html#topic+family">family</a> for details on family
functions.</p>
</td></tr>
<tr><td><code id="IRLSfit_+3A_control">control</code></td>
<td>
<p>a list of parameters for controlling the IRLS fitting process
to be passed on to <code><a href="stats.html#topic+glm.control">glm.control</a></code>. See
<code><a href="stats.html#topic+glm.fit">glm.fit</a></code> for further details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a slightly modified version of the
<code><a href="stats.html#topic+glm.fit">glm.fit</a></code> from the package <span class="pkg">stats</span> to which we refer
for further details. The difference in the inputs of <code>IRLSfit</code> and
<code><a href="stats.html#topic+glm.fit">glm.fit</a></code> is that the former admits initial values only
for the vector of means.
</p>
<p>The output from <code>IRLSfit</code> has some additional slots compared to
<code><a href="stats.html#topic+glm.fit">glm.fit</a></code>. We note that the slots <code>weights</code>,
<code>res2</code> and <code>z</code> contain values of the IRLS weights, &ldquo;working
residuals&quot; and transformed responses computed <em>after</em> the last IRLS
iteration, i.e. they are based on the estimated coefficients that are
returned by <code>IRLSfit</code>.
</p>
<p>The source code of <code>IRLSfit</code> contains also some commented lines that
produce useful plots at each IRLS iteration. Normally, printing these plots
is time consuming, but they could be run for inspection purposes.
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector containing the estimated regression
coefficients;</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the &lsquo;working&rsquo; residuals, that are the residuals in the final
iteration of the IRLS fit. Since cases with zero weights are omitted, their
working residuals are <code>NA</code>;</p>
</td></tr>
<tr><td><code>res2</code></td>
<td>
<p>the working residuals after the final IRLS iteration. They are
used within the  knot placement steps of stage A of GeDS;</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the fitted mean values, obtained by transforming the
predictor by the inverse of the link function;</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>the numeric rank of the fitted linear model;</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>the <code><a href="stats.html#topic+family">family</a></code> object used;</p>
</td></tr>
<tr><td><code>linear.predictors</code></td>
<td>
<p>the fitted predictor;</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>a vector containing the deviances obtained at each IRLS
iteration;</p>
</td></tr>
<tr><td><code>lastdeviance</code></td>
<td>
<p>the deviance at the last IRLS iteration;</p>
</td></tr>
<tr><td><code>null.deviance</code></td>
<td>
<p>The deviance for the null model (see
<code><a href="stats.html#topic+glm">glm</a></code> documentation);</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>the number of IRLS iterations performed;</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the working weights after the last IRLS iteration;</p>
</td></tr>
<tr><td><code>prior.weights</code></td>
<td>
<p>the &ldquo;prior weights&quot; (see the <code>weights</code> argument);</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>the residual degrees of freedom;</p>
</td></tr>
<tr><td><code>df.null</code></td>
<td>
<p>the residual degrees of freedom for the null model;</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the vector of values of the response variable used in the fitting;</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>the transformed responses computed after the last IRLS iteration;</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>logical. Was the IRLS algorithm judged to have converged?</p>
</td></tr>
<tr><td><code>boundary</code></td>
<td>
<p>logical. Is the fitted value on the boundary of the
attainable values?</p>
</td></tr>
</table>
<p>In addition, non-empty fits will have components <code>qr</code>, <code>R</code> and
<code>effects</code> relating to the final weighted linear fit, see
<code><a href="stats.html#topic+lm.fit">lm.fit</a></code> documentation.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+glm.fit">glm.fit</a></code>
</p>

<hr>
<h2 id='knots.GeDS'>Knots method for GeDS, GeDSboost, GeDSgam</h2><span id='topic+knots.GeDS'></span><span id='topic+knots.GeDSboost+2C'></span><span id='topic+knots.GeDSgam'></span><span id='topic+knots.GeDSboost'></span>

<h3>Description</h3>

<p>Method for the generic function <code><a href="stats.html#topic+knots">knots</a></code> that allows the
user to extract the vector of knots of a GeDS, GeDSboost or GeDSgam fit of a
specified order contained in a <code><a href="#topic+GeDS-class">GeDS-class</a></code>,
<code><a href="#topic+GeDSboost-class">GeDSboost-class</a></code> or <code><a href="#topic+GeDSgam-class">GeDSgam-class</a></code> object,
respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GeDS'
knots(Fn, n = 3L, options = c("all", "internal"), ...)

## S3 method for class 'GeDSboost'
knots(Fn, n = 3L, options = c("all", "internal"), ...)

## S3 method for class 'GeDSgam'
knots(Fn, n = 3L, options = c("all", "internal"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knots.GeDS_+3A_fn">Fn</code></td>
<td>
<p>the <code><a href="#topic+GeDS-class">GeDS-class</a></code>, <code><a href="#topic+GeDSboost-class">GeDSboost-class</a></code> or
<code><a href="#topic+GeDSgam-class">GeDSgam-class</a></code> object from which the vector of knots for the
specified GeDS, FGB-GeDS or GAM-GeDS fit should be extracted.</p>
</td></tr>
<tr><td><code id="knots.GeDS_+3A_n">n</code></td>
<td>
<p>integer value (2, 3 or 4) specifying the order (<code class="reqn">=</code> degree
<code class="reqn">+ 1</code>) of the GeDS, FGB-GeDS or GAM-GeDS fit whose knots should be
extracted. By default equal to <code>3L</code>. Non-integer values will be passed
to the function <code><a href="base.html#topic+as.integer">as.integer</a></code>.</p>
</td></tr>
<tr><td><code id="knots.GeDS_+3A_options">options</code></td>
<td>
<p>a character string specifying whether &quot;<code>all</code>&quot; knots,
including the left-most and the right-most limits of the interval embedding
the observations (the default) or only the &quot;<code>internal</code>&quot; knots should be
extracted.</p>
</td></tr>
<tr><td><code id="knots.GeDS_+3A_...">...</code></td>
<td>
<p>potentially further arguments (required for compatibility with the
definition of the generic function). Currently ignored, but with a warning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the function <code><a href="stats.html#topic+knots">knots</a></code> in the
<span class="pkg">stats</span> package.
</p>
<p>As <code><a href="#topic+GeDS-class">GeDS-class</a></code>, <code><a href="#topic+GeDSboost-class">GeDSboost-class</a></code> and
<code><a href="#topic+GeDSgam-class">GeDSgam-class</a></code> objects contain three different fits (linear,
quadratic and cubic), it is possible to specify the order of the GeDS fit
whose knots are required via the input argument <code>n</code>.
</p>


<h3>Value</h3>

<p>A vector in which each element represents a knot of the GeDS/FGB-GeDS/GAM-GeDS fit of the required order.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+knots">knots</a></code> for the definition of the generic function; <code><a href="#topic+NGeDS">NGeDS</a></code>, <code><a href="#topic+GGeDS">GGeDS</a></code>,
<code><a href="#topic+NGeDSboost">NGeDSboost</a></code> and <code><a href="#topic+NGeDSgam">NGeDSgam</a></code> for examples.
</p>

<hr>
<h2 id='lines+2CGeDS-method'>Lines method for GeDS objects.</h2><span id='topic+lines+2CGeDS-method'></span><span id='topic+lines.GeDS'></span>

<h3>Description</h3>

<p>Lines method for GeDS objects. Adds a GeDS curve to an existing plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GeDS'
lines(
  x,
  n = 3L,
  transform = function(x) x,
  onlySpline = TRUE,
  data = data.frame(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lines+2B2CGeDS-method_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+GeDS-Class">GeDS-Class</a></code> object from which the GeDS fit should be
extracted.</p>
</td></tr>
<tr><td><code id="lines+2B2CGeDS-method_+3A_n">n</code></td>
<td>
<p>integer value (2, 3 or 4) specifying the order (<code class="reqn">=</code> degree
<code class="reqn">+ 1</code>) of the GeDS fit that should be plotted. By default equal to
<code>3L</code>. Non-integer values will be passed to the function
<code><a href="base.html#topic+as.integer">as.integer</a></code>.</p>
</td></tr>
<tr><td><code id="lines+2B2CGeDS-method_+3A_transform">transform</code></td>
<td>
<p>a function that can be used to transform the scale of the Y
axis. Typically it can be the inverse of the link function if the plot is on
the scale of the response variable.</p>
</td></tr>
<tr><td><code id="lines+2B2CGeDS-method_+3A_onlyspline">onlySpline</code></td>
<td>
<p>logical variable specifying whether only the spline
component of the fitted GeDS predictor model  should be plotted or
alternatively also the parametric component (see
<code><a href="#topic+formula.GeDS">formula</a></code>) should be plotted.</p>
</td></tr>
<tr><td><code id="lines+2B2CGeDS-method_+3A_data">data</code></td>
<td>
<p>an optional <code>data.frame</code>, <code>list</code> or <code>environment</code>
containing values of the independent variables for  which the GeDS predicted
values should be plotted. If left empty the values are extracted from the
object <code>x</code> itself.</p>
</td></tr>
<tr><td><code id="lines+2B2CGeDS-method_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the default
<code><a href="graphics.html#topic+lines">lines</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method can be used to add a curve corresponding to a particular GeDS fit
to an active plot.
</p>
<p>As GeDS objects contain three different fits (linear, quadratic and cubic),
it is possible to specify the order of the GeDS regression to be plotted via
the input argument <code>n</code>.
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+lines">lines</a></code> for the definition of the generic
function; <code><a href="#topic+NGeDS">NGeDS</a></code> and <code><a href="#topic+GGeDS">GGeDS</a></code> for examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate a data sample for the response variable
# Y and the single covariate X
set.seed(123)
N &lt;- 500
f_1 &lt;- function(x) (10*x/(1+100*x^2))*4+4
X &lt;- sort(runif(N, min = -2, max = 2))
# Specify a model for the mean of Y to include only a component
# non-linear in X, defined by the function f_1
means &lt;- f_1(X)
# Add (Normal) noise to the mean of Y
Y &lt;- rnorm(N, means, sd = 0.1)

# Fit a GeDS regression model using NGeDS
(Gmod &lt;- NGeDS(Y ~ f(X), beta = 0.6, phi = 0.995, Xextr = c(-2,2)))

# Plot the GeDS third order fit (the quadratic one)
# without its corresponding Polygon
plot(Gmod, type = "none")

# Add a curve corresponding to the second order fit (the linear one)
lines(Gmod, n = 2, col = "green", lwd = 2, lty = 3)

</code></pre>

<hr>
<h2 id='NGeDS'>Geometrically Designed Spline regression estimation</h2><span id='topic+NGeDS'></span>

<h3>Description</h3>

<p><code>NGeDS</code> constructs a Geometrically Designed  variable knots spline
regression model  referred to as a GeDS model, for a response having a Normal
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NGeDS(
  formula,
  data,
  weights,
  beta = 0.5,
  phi = 0.99,
  min.intknots = 0,
  max.intknots = 500,
  q = 2,
  Xextr = NULL,
  Yextr = NULL,
  show.iters = FALSE,
  stoptype = "RD",
  higher_order = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NGeDS_+3A_formula">formula</code></td>
<td>
<p>a description of the structure of the model to be fitted,
including the dependent and independent variables. See
<code><a href="#topic+formula.GeDS">formula</a></code> for details.</p>
</td></tr>
<tr><td><code id="NGeDS_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment containing the
variables of the model. If not found in <code>data</code>, the variables are taken
from <code>environment(formula)</code>, typically the environment from which
<code>NGeDS</code> is called.</p>
</td></tr>
<tr><td><code id="NGeDS_+3A_weights">weights</code></td>
<td>
<p>an optional vector of &lsquo;prior weights&rsquo; to be put on the
observations in the fitting process in case the user requires weighted GeDS
fitting. It should be <code>NULL</code> or a numeric vector of the same length as
the response variable in the argument <code><a href="#topic+formula.GeDS">formula</a></code>.</p>
</td></tr>
<tr><td><code id="NGeDS_+3A_beta">beta</code></td>
<td>
<p>numeric parameter in the interval <code class="reqn">[0,1]</code> tuning the knot
placement in stage A of GeDS. See details.</p>
</td></tr>
<tr><td><code id="NGeDS_+3A_phi">phi</code></td>
<td>
<p>numeric parameter in the interval <code class="reqn">[0,1]</code> specifying the
threshold for the stopping rule  (model selector) in stage A of GeDS. See
also <code>stoptype</code> and details below.</p>
</td></tr>
<tr><td><code id="NGeDS_+3A_min.intknots">min.intknots</code></td>
<td>
<p>optional parameter allowing the user to set a minimum
number of internal knots required. By default equal to zero.</p>
</td></tr>
<tr><td><code id="NGeDS_+3A_max.intknots">max.intknots</code></td>
<td>
<p>optional parameter allowing the user to set a maximum
number of internal knots to be added by the GeDS estimation algorithm. By
default equal to the number of knots for the saturated GeDS model.</p>
</td></tr>
<tr><td><code id="NGeDS_+3A_q">q</code></td>
<td>
<p>numeric parameter which allows to fine-tune the stopping rule of
stage A of GeDS, by default equal to 2. See details.</p>
</td></tr>
<tr><td><code id="NGeDS_+3A_xextr">Xextr</code></td>
<td>
<p>numeric vector of 2 elements representing the left-most and
right-most limits of the interval embedding the observations of the first
independent variable. See details.</p>
</td></tr>
<tr><td><code id="NGeDS_+3A_yextr">Yextr</code></td>
<td>
<p>numeric vector of 2 elements representing the left-most and
right-most limits of the interval embedding the observations of the second
independent variable (if the bivariate GeDS is run). See details.</p>
</td></tr>
<tr><td><code id="NGeDS_+3A_show.iters">show.iters</code></td>
<td>
<p>logical variable indicating whether or not to print 
information at each step.</p>
</td></tr>
<tr><td><code id="NGeDS_+3A_stoptype">stoptype</code></td>
<td>
<p>a character string indicating the type of GeDS stopping rule
to be used. It should be either one of <code>"SR"</code>, <code>"RD"</code> or 
<code>"LR"</code>, partial match allowed. See details.</p>
</td></tr>
<tr><td><code id="NGeDS_+3A_higher_order">higher_order</code></td>
<td>
<p>a logical that defines whether to compute the higher
order fits (quadratic and cubic) after stage A is run. Default is
<code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The  <code>NGeDS</code> function implements the GeDS methodology, recently
developed by Kaishev et al. (2016) and extended in the <code><a href="#topic+GGeDS">GGeDS</a></code>
function for the more general GNM, (GLM) context, allowing for the response
to have any distribution from the Exponential Family. Under the GeDS approach
the (non-)linear predictor is viewed as a spline with variable knots which
are estimated along with the regression coefficients and the order of the
spline, using a two stage algorithm. In stage A, a linear variable-knot
spline is fitted to the data applying iteratively least squares  regression
(see <code><a href="stats.html#topic+lm">lm</a></code> function). In stage B, a Schoenberg variation
diminishing spline approximation to the fit from stage A is constructed, thus
simultaneously producing spline fits of order 2, 3 and 4, all of which are
included in the output, a <code><a href="#topic+GeDS-Class">GeDS-Class</a></code> object.
</p>
<p>As noted in <code><a href="#topic+formula.GeDS">formula</a></code>, the argument <code>formula</code>
allows the user to specify models with two components, a spline regression
(non-parametric) component involving part of the independent variables
identified through the function <code>f</code> and an optional  parametric
component involving the remaining independent variables. For <code>NGeDS</code> one
or two independent variables are allowed for the spline component and
arbitrary many independent variables for the parametric component. Failure to
specify the independent variable for the  spline regression component through
the function <code>f</code> will return an error. See
<code><a href="#topic+formula.GeDS">formula</a></code>.
</p>
<p>Within the argument <code>formula</code>, similarly as in other R functions, it is
possible to specify one or more offset variables, i.e. known terms with fixed
regression coefficients equal to 1. These terms should be identified via the
function <code><a href="stats.html#topic+offset">offset</a></code>.
</p>
<p>The parameter <code>beta</code> tunes the placement of a new knot in stage A of the
algorithm. Once a current second-order  spline is fitted to the data the
regression residuals are computed and grouped by their sign. A new knot is
placed  at a location defined by the group for which a certain measure
attains its maximum. The latter measure is defined as a weighted linear
combination of the range of each group and the  mean of the absolute
residuals within it. The parameter <code>beta</code> determines the weights in this
measure correspondingly as <code>beta</code> and <code>1 - beta</code>. The  higher it
is, the more weight is put to the mean of the residuals and the less to the
range of their corresponding x-values. The default value of <code>beta</code> is
<code>0.5</code>.
</p>
<p>The argument <code>stoptype</code> allows to choose between three alternative
stopping rules for the knot selection in stage A of GeDS, the <code>"RD"</code>,
that stands for <em>Ratio of Deviances</em>, the <code>"SR"</code>, that stands for
<em>Smoothed Ratio</em> of deviances and the <code>"LR"</code>, that stands for
<em>Likelihood Ratio</em>. The latter is based on the difference of deviances
rather than on their ratio as in the case of <code>"RD"</code> and <code>"SR"</code>.
Therefore <code>"LR"</code> can be viewed as a log likelihood ratio test performed
at each iteration of the knot placement. In each of these cases the
corresponding stopping criterion is compared with a threshold value
<code>phi</code> (see below).
</p>
<p>The argument <code>phi</code> provides a threshold value required for the stopping
rule to exit the knot placement in stage A of GeDS. The higher the value of
<code>phi</code>, the more knots are added under the <code>"RD"</code> and <code>"SR"</code>
stopping rules contrary to the case of the stopping rule <code>"LR"</code> where
the lower <code>phi</code> is, more knots are included in the spline regression.
Further details for each of the three alternative stopping rules can be found
in Dimitrova et al. (2023).
</p>
<p>The argument <code>q</code> is an input parameter that allows to fine-tune the
stopping rule in stage A. It identifies the number of consecutive iterations
over which the deviance should exhibit stable convergence so as the knot
placement in stage A is terminated. More precisely, under any of the rules
<code>"RD"</code>, <code>"SR"</code>, or <code>"LR"</code>, the deviance at the current
iteration is compared to the deviance computed <code>q</code> iterations before,
i.e., before selecting the last <code>q</code> knots. Setting a higher <code>q</code>
will lead to more knots being added before exiting stage A of GeDS.
</p>


<h3>Value</h3>

<p><code><a href="#topic+GeDS-Class">GeDS-Class</a></code> object, i.e. a list of items that summarizes
the main details of the fitted GeDS regression. See <code><a href="#topic+GeDS-Class">GeDS-Class</a></code>
for details. Some S3 methods are available in order to make these objects
tractable, such as <code><a href="#topic+coef.GeDS">coef</a></code>,
<code><a href="#topic+deviance.GeDS">deviance</a></code>, <code><a href="#topic+knots.GeDS">knots</a></code>,
<code><a href="#topic+predict.GeDS">predict</a></code> and <code><a href="#topic+print.GeDS">print</a></code> as
well as S4 methods for <code><a href="#topic+lines.GeDS">lines</a></code> and
<code><a href="#topic+plot.GeDS">plot</a></code>.
</p>


<h3>References</h3>

<p>Kaishev, V.K., Dimitrova, D.S., Haberman, S. and Verrall, R.J. (2016).
Geometrically designed, variable knot regression splines.
<em>Computational Statistics</em>, <strong>31</strong>, 1079&ndash;1105. <br />
DOI: <a href="https://doi.org/10.1007/s00180-015-0621-7">doi:10.1007/s00180-015-0621-7</a>
</p>
<p>Dimitrova, D. S., Kaishev, V. K., Lattuada, A. and Verrall, R. J.  (2023).
Geometrically designed variable knot splines in generalized (non-)linear
models.
<em>Applied Mathematics and Computation</em>, <strong>436</strong>. <br />
DOI: <a href="https://doi.org/10.1016/j.amc.2022.127493">doi:10.1016/j.amc.2022.127493</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+GGeDS">GGeDS</a>; <a href="#topic+GeDS-Class">GeDS-Class</a>; S3 methods such as <a href="#topic+coef.GeDS">coef.GeDS</a>,
<a href="#topic+deviance.GeDS">deviance.GeDS</a>, <a href="#topic+knots.GeDS">knots.GeDS</a>, <a href="#topic+print.GeDS">print.GeDS</a> and
<a href="#topic+predict.GeDS">predict.GeDS</a>; <a href="#topic+Integrate">Integrate</a> and <a href="#topic+Derive">Derive</a>; <a href="#topic+PPolyRep">PPolyRep</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
###################################################
# Generate a data sample for the response variable
# Y and the single covariate X
set.seed(123)
N &lt;- 500
f_1 &lt;- function(x) (10*x/(1+100*x^2))*4+4
X &lt;- sort(runif(N, min = -2, max = 2))
# Specify a model for the mean of Y to include only a component
# non-linear in X, defined by the function f_1
means &lt;- f_1(X)
# Add (Normal) noise to the mean of Y
Y &lt;- rnorm(N, means, sd = 0.1)

# Fit a Normal GeDS regression using NGeDS
(Gmod &lt;- NGeDS(Y ~ f(X), beta = 0.6, phi = 0.995, Xextr = c(-2,2)))

# Apply some of the available methods, e.g.
# coefficients, knots and deviance extractions for the
# quadratic GeDS fit
# Note that the first call to the function knots returns
# also the left and right limits of the interval containing
# the data
coef(Gmod, n = 3)
knots(Gmod, n = 3)
knots(Gmod, n = 3, options = "internal")
deviance(Gmod, n = 3)

# Add a covariate, Z, that enters linearly
Z &lt;- runif(N)
Y2 &lt;- Y + 2*Z + 1
# Re-fit the data using NGeDS
(Gmod2 &lt;- NGeDS(Y2 ~ f(X) + Z, beta = 0.6, phi = 0.995, Xextr = c(-2,2)))
coef(Gmod2, n = 3)
coef(Gmod2, onlySpline = FALSE, n = 3)

## Not run: 
##########################################
# Real data example
# See Kaishev et al. (2016), section 4.2
data('BaFe2As2')
(Gmod2 &lt;- NGeDS(intensity ~ f(angle), data = BaFe2As2, beta = 0.6, phi = 0.99, q = 3))
plot(Gmod2)

## End(Not run)

#########################################
# bivariate example
# See Dimitrova et al. (2023), section 5

# Generate a data sample for the response variable
# Z and the covariates X and Y assuming Normal noise
set.seed(123)
doublesin &lt;- function(x){
 sin(2*x[,1])*sin(2*x[,2])
}

X &lt;- (round(runif(400, min = 0, max = 3),2))
Y &lt;- (round(runif(400, min = 0, max = 3),2))
Z &lt;- doublesin(cbind(X,Y))
Z &lt;- Z+rnorm(400, 0, sd = 0.1)
# Fit a two dimensional GeDS model using NGeDS
(BivGeDS &lt;- NGeDS(Z ~ f(X, Y) , phi = 0.9, beta = 0.3,
Xextr = c(0, 3), Yextr = c(0, 3)))

# Extract quadratic coefficients/knots/deviance
coef(BivGeDS, n = 3)
knots(BivGeDS, n = 3)
deviance(BivGeDS, n = 3)

# Surface plot of the generating function (doublesin)
plot(BivGeDS, f = doublesin)
# Surface plot of the fitted model
plot(BivGeDS)

</code></pre>

<hr>
<h2 id='NGeDSboost'>Component-wise gradient boosting with NGeDS base-learners</h2><span id='topic+NGeDSboost'></span>

<h3>Description</h3>

<p><code>NGeDSboost</code> performs component-wise gradient boosting (Bhlmann and Yu
(2003), Bhlmann and Hothorn (2007)) using normal GeD splines (i.e., fitted
with <code><a href="#topic+NGeDS">NGeDS</a></code> function) as base-learners (see Dimitrova et al. (2024)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NGeDSboost(
  formula,
  data,
  weights = NULL,
  normalize_data = FALSE,
  family = mboost::Gaussian(),
  initial_learner = TRUE,
  int.knots_init = 2L,
  min_iterations,
  max_iterations,
  shrinkage = 1,
  phi_boost_exit = 0.995,
  q_boost = 2L,
  beta = 0.5,
  phi = 0.99,
  internal_knots = 500L,
  q = 2L,
  higher_order = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NGeDSboost_+3A_formula">formula</code></td>
<td>
<p>a description of the structure of the model to be fitted,
including the dependent and independent variables. Unlike <code><a href="#topic+NGeDS">NGeDS</a></code>
and <code><a href="#topic+GGeDS">GGeDS</a></code>, the formula specified allows for multiple additive
GeD spline regression components (as well as linear components) to be
included (e.g., <code>Y ~ f(X1) + f(X2) + X3</code>).
See <code><a href="#topic+formula.GeDS">formula</a></code> for further details.</p>
</td></tr>
<tr><td><code id="NGeDSboost_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables referenced in the formula.</p>
</td></tr>
<tr><td><code id="NGeDSboost_+3A_weights">weights</code></td>
<td>
<p>an optional vector of &lsquo;prior weights&rsquo; to be put on the
observations during the fitting process. It should be <code>NULL</code> or a
numeric vector of the same length as the response variable defined in the
formula.</p>
</td></tr>
<tr><td><code id="NGeDSboost_+3A_normalize_data">normalize_data</code></td>
<td>
<p>a logical that defines whether the data should be
normalized (standardized) before fitting the baseline linear model, i.e.,
before running the FGB algorithm. Normalizing the data involves scaling the
predictor variables to have a mean of 0 and a standard deviation of 1. This
process alters the scale and interpretation of the knots and coefficients
estimated. Default is equal to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="NGeDSboost_+3A_family">family</code></td>
<td>
<p>determines the loss function to be optimized by the boosting
algorithm. In case <code>initial_learner = FALSE</code> it also determines the
corresponding empirical risk minimizer to be used as offset initial learner.
By default, it is set to <code>mboost::Gaussian()</code>. Users can specify any
<code><a href="mboost.html#topic+Family">Family</a></code> object from the <span class="pkg">mboost</span> package.</p>
</td></tr>
<tr><td><code id="NGeDSboost_+3A_initial_learner">initial_learner</code></td>
<td>
<p>a logical value. If set to <code>TRUE</code>, the model's
initial learner will be a normal GeD spline. If set to FALSE, then the
initial predictor will consist of the empirical risk minimizer corresponding
to the specified family. Note that if <code>initial_learner = TRUE</code>,
<code>family</code> must be <code>mboost::Gaussian()</code>.</p>
</td></tr>
<tr><td><code id="NGeDSboost_+3A_int.knots_init">int.knots_init</code></td>
<td>
<p>optional parameter allowing the user to set a
maximum number of internal knots to be added by the initial GeDS learner in
case <code>initial_learner = TRUE</code>. Default is equal to <code>2L</code>.</p>
</td></tr>
<tr><td><code id="NGeDSboost_+3A_min_iterations">min_iterations</code></td>
<td>
<p>optional parameter to manually set a minimum number of
boosting iterations to be run. If not specified, it defaults to 0L.</p>
</td></tr>
<tr><td><code id="NGeDSboost_+3A_max_iterations">max_iterations</code></td>
<td>
<p>optional parameter to manually set the maximum number
of boosting iterations to be run. If not specified, it defaults to 100L.
This setting serves as a fallback when the stopping rule, based on
consecutive deviances and tuned by <code>phi_boost_exit</code> and <code>q_boost</code>,
does not trigger an earlier termination (see Dimitrova et al. (2024)).
Therefore, users can increase/decrease the number of boosting iterations,
by increasing/decreasing the value <code>phi_boost_exit</code> and/or#
<code>q_boost</code>, or directly specify <code>max_iterations</code>.</p>
</td></tr>
<tr><td><code id="NGeDSboost_+3A_shrinkage">shrinkage</code></td>
<td>
<p>numeric parameter in the interval <code class="reqn">[0,1]</code> defining the
step size or shrinkage parameter. This controls the size of the steps taken
in the direction of the gradient of the loss function. In other words, the
magnitude of the update each new iteration contributes to the final model.
Default is equal to <code>1</code>.</p>
</td></tr>
<tr><td><code id="NGeDSboost_+3A_phi_boost_exit">phi_boost_exit</code></td>
<td>
<p>numeric parameter in the interval <code class="reqn">[0,1]</code>
specifying the threshold for the boosting iterations stopping rule. Default
is equal to <code>0.995</code>.</p>
</td></tr>
<tr><td><code id="NGeDSboost_+3A_q_boost">q_boost</code></td>
<td>
<p>numeric parameter which allows to fine-tune the boosting
iterations stopping rule, by default equal to <code>2L</code>.</p>
</td></tr>
<tr><td><code id="NGeDSboost_+3A_beta">beta</code></td>
<td>
<p>numeric parameter in the interval <code class="reqn">[0,1]</code> tuning the knot
placement in stage A of GeDS. Default is equal to <code>0.5</code>. See details in
<code><a href="#topic+NGeDS">NGeDS</a></code>.</p>
</td></tr>
<tr><td><code id="NGeDSboost_+3A_phi">phi</code></td>
<td>
<p>numeric parameter in the interval <code class="reqn">[0,1]</code> specifying the
threshold for the stopping rule  (model selector) in stage A of GeDS.
Default is equal to <code>0.99</code>. See details in <code><a href="#topic+NGeDS">NGeDS</a></code>.</p>
</td></tr>
<tr><td><code id="NGeDSboost_+3A_internal_knots">internal_knots</code></td>
<td>
<p>The maximum number of internal knots that can be added
by the GeDS base-learners in each boosting iteration, effectively setting the
value of <code>max.intknots</code> in <code><a href="#topic+NGeDS">NGeDS</a></code> at each boosting
iteration. Default is <code>500L</code>.</p>
</td></tr>
<tr><td><code id="NGeDSboost_+3A_q">q</code></td>
<td>
<p>numeric parameter which allows to fine-tune the stopping rule of
stage A of GeDS, by default equal to <code>2L</code>. See details in
<code><a href="#topic+NGeDS">NGeDS</a></code>.</p>
</td></tr>
<tr><td><code id="NGeDSboost_+3A_higher_order">higher_order</code></td>
<td>
<p>a logical that defines whether to compute the higher
order fits (quadratic and cubic) after the FGB algorithm is run. Default is
<code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The  <code>NGeDSboost</code> function implements functional gradient boosting
algorithm for some pre-defined loss function, using linear GeD splines as
base learners. At each boosting iteration, the negative gradient vector is
fitted through the base procedure encapsulated within the <code><a href="#topic+NGeDS">NGeDS</a></code>
function. The latter constructs a Geometrically Designed variable knots
spline regression model for a response having a Normal distribution. The FGB
algorithm yields a final linear fit. Higher order fits (quadratic and cubic)
are then computed by calculating the Schoenbergs variation diminishing
spline (VDS) approximation of the linear fit.
</p>
<p>On the one hand, <code>NGeDSboost</code> includes all the parameters of
<code><a href="#topic+NGeDS">NGeDS</a></code>, which in this case tune the base-learner fit at each
boosting iteration. On the other hand, <code>NGeDSboost</code> includes some
additional parameters proper to the FGB procedure. We describe the main ones
as follows. 
</p>
<p>First, <code>family</code> allows to specify the loss function and corresponding
risk function to be optimized by the boosting algorithm. If
<code>initial_learner = FALSE</code>, the initial learner employed will be the
empirical risk minimizer corresponding to the family chosen. If
<code>initial_learner = TRUE</code> then the initial learner will be an
<code><a href="#topic+NGeDS">NGeDS</a></code> fit with maximum number of internal knots equal to
<code>int.knots_init</code>.
</p>
<p><code>shrinkage</code> tunes the step length/shrinkage parameter which helps to 
control the learning rate of the model. In other words, when a new base
learner is added to the ensemble, its contribution to the final prediction is
multiplied by the shrinkage parameter. The smaller <code>shrinkage</code> is, the
slower/more gradual the learning process will be, and viceversa.
</p>
<p>The number of boosting iterations is controlled by a
<em>Ratio of Deviances</em> stopping rule similar to the one presented for
<code><a href="#topic+GGeDS">GGeDS</a></code>. In the same way <code>phi</code> and <code>q</code> tune the
stopping rule of <code><a href="#topic+GGeDS">GGeDS</a></code>, <code>phi_boost_exit</code> and
<code>q_boost</code> tune the stopping rule of <code>NGeDSboost</code>. The user can also
manually control the number of boosting iterations through
<code>min_iterations</code> and <code>max_iterations</code>.
</p>


<h3>Value</h3>

<p><code><a href="#topic+GeDSboost-Class">GeDSboost-Class</a></code> object, i.e. a list of items that
summarizes the main details of the fitted FGB-GeDS model. See
<code><a href="#topic+GeDSboost-Class">GeDSboost-Class</a></code> for details. Some S3 methods are available in
order to make these objects tractable, such as
<code><a href="#topic+coef.GeDSboost">coef</a></code>, <code><a href="#topic+knots.GeDSboost">knots</a></code>,
<code><a href="#topic+print.GeDSboost">print</a></code> and
<code><a href="#topic+predict.GeDSboost">predict</a></code>. Also variable importance measures
(<code><a href="#topic+bl_imp.GeDSboost">bl_imp</a></code>) and improved plotting facilities
(<code><a href="#topic+visualize_boosting.GeDSboost">visualize_boosting</a></code>).
</p>


<h3>References</h3>

<p>Friedman, J.H. (2001).
Greedy function approximation: A gradient boosting machine.
<em>The Annals of Statistics</em>, <strong>29 (5)</strong>, 1189&ndash;1232. <br />
DOI: <a href="https://doi.org/10.1214/aos/1013203451">doi:10.1214/aos/1013203451</a>
</p>
<p>Bhlmann P., Yu B. (2003).
Boosting With the L2 Loss.
<em>Journal of the American Statistical Association</em>,
<strong>98(462)</strong>, 324339.
<a href="https://doi.org/10.1198/016214503000125">doi:10.1198/016214503000125</a>
</p>
<p>Bhlmann P., Hothorn T. (2007).
Boosting Algorithms: Regularization, Prediction and Model Fitting.
<em>Statistical Science</em>, <strong>22(4)</strong>, 477  505. <br />
DOI: <a href="https://doi.org/10.1214/07-STS242">doi:10.1214/07-STS242</a>
</p>
<p>Kaishev, V.K., Dimitrova, D.S., Haberman, S. and Verrall, R.J. (2016).
Geometrically designed, variable knot regression splines.
<em>Computational Statistics</em>, <strong>31</strong>, 1079&ndash;1105. <br />
DOI: <a href="https://doi.org/10.1007/s00180-015-0621-7">doi:10.1007/s00180-015-0621-7</a>
</p>
<p>Dimitrova, D. S., Kaishev, V. K., Lattuada, A. and Verrall, R. J.  (2023).
Geometrically designed variable knot splines in generalized (non-)linear
models.
<em>Applied Mathematics and Computation</em>, <strong>436</strong>. <br />
DOI: <a href="https://doi.org/10.1016/j.amc.2022.127493">doi:10.1016/j.amc.2022.127493</a>
</p>
<p>Dimitrova, D. S., Guillen, E. S. and Kaishev, V. K.  (2024).
<span class="pkg">GeDS</span>: An R Package for Regression, Generalized Additive
Models and Functional Gradient Boosting, based on Geometrically Designed
(GeD) Splines. <em>Manuscript submitted for publication.</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NGeDS">NGeDS</a></code>; <code><a href="#topic+GGeDS">GGeDS</a></code>; <code><a href="#topic+GeDSboost-Class">GeDSboost-Class</a></code>;
S3 methods such as <code><a href="#topic+knots.GeDSboost">knots.GeDSboost</a></code>; <code><a href="#topic+coef.GeDSboost">coef.GeDSboost</a></code>;
<code><a href="#topic+deviance.GeDSboost">deviance.GeDSboost</a></code>; <code><a href="#topic+predict.GeDSboost">predict.GeDSboost</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
################################# Example 1 #################################
# Generate a data sample for the response variable
# Y and the single covariate X
set.seed(123)
N &lt;- 500
f_1 &lt;- function(x) (10*x/(1+100*x^2))*4+4
X &lt;- sort(runif(N, min = -2, max = 2))
# Specify a model for the mean of Y to include only a component
# non-linear in X, defined by the function f_1
means &lt;- f_1(X)
# Add (Normal) noise to the mean of Y
Y &lt;- rnorm(N, means, sd = 0.2)
data = data.frame(X, Y)

# Fit a Normal FGB-GeDS regression using NGeDSboost

Gmodboost &lt;- NGeDSboost(Y ~ f(X), data = data)
MSE_Gmodboost_linear &lt;- mean((sapply(X, f_1) - Gmodboost$predictions$pred_linear)^2)
MSE_Gmodboost_quadratic &lt;- mean((sapply(X, f_1) - Gmodboost$predictions$pred_quadratic)^2)
MSE_Gmodboost_cubic &lt;- mean((sapply(X, f_1) - Gmodboost$predictions$pred_cubic)^2)

cat("\n", "MEAN SQUARED ERROR", "\n",
    "Linear NGeDSboost:", MSE_Gmodboost_linear, "\n",
    "Quadratic NGeDSboost:", MSE_Gmodboost_quadratic, "\n",
    "Cubic NGeDSboost:", MSE_Gmodboost_cubic, "\n")

# Compute predictions on new randomly generated data
X &lt;- sort(runif(100, min = -2, max = 2))

pred_linear &lt;- predict(Gmodboost, newdata = data.frame(X), n = 2L)
pred_quadratic &lt;- predict(Gmodboost, newdata = data.frame(X), n = 3L)
pred_cubic &lt;- predict(Gmodboost, newdata = data.frame(X), n = 4L)

MSE_Gmodboost_linear &lt;- mean((sapply(X, f_1) - pred_linear)^2)
MSE_Gmodboost_quadratic &lt;- mean((sapply(X, f_1) - pred_quadratic)^2)
MSE_Gmodboost_cubic &lt;- mean((sapply(X, f_1) - pred_cubic)^2)
cat("\n", "MEAN SQUARED ERROR", "\n",
    "Linear NGeDSboost:", MSE_Gmodboost_linear, "\n",
    "Quadratic NGeDSboost:", MSE_Gmodboost_quadratic, "\n",
    "Cubic NGeDSboost:", MSE_Gmodboost_cubic, "\n")

## S3 methods for class 'GeDSboost'
# Print 
print(Gmodboost)
# Knots
knots(Gmodboost, n = 2L)
knots(Gmodboost, n = 3L)
knots(Gmodboost, n = 4L)
# Coefficients
coef(Gmodboost, n = 2L)
coef(Gmodboost, n = 3L)
coef(Gmodboost, n = 4L)
# Deviances
deviance(Gmodboost, n = 2L)
deviance(Gmodboost, n = 3L)
deviance(Gmodboost, n = 4L)

############################ Example 2 - Bodyfat ############################
library(TH.data)
data("bodyfat", package = "TH.data")

Gmodboost &lt;- NGeDSboost(formula = DEXfat ~ age + f(hipcirc, waistcirc) + f(kneebreadth),
data = bodyfat)

MSE_Gmodboost_linear &lt;- mean((bodyfat$DEXfat - Gmodboost$predictions$pred_linear)^2)
MSE_Gmodboost_quadratic &lt;- mean((bodyfat$DEXfat - Gmodboost$predictions$pred_quadratic)^2)
MSE_Gmodboost_cubic &lt;- mean((bodyfat$DEXfat - Gmodboost$predictions$pred_cubic)^2)
# Comparison
cat("\n", "MSE", "\n",
    "Linear NGeDSboost:", MSE_Gmodboost_linear, "\n",
    "Quadratic NGeDSboost:", MSE_Gmodboost_quadratic, "\n",
    "Cubic NGeDSboost:", MSE_Gmodboost_cubic, "\n")

</code></pre>

<hr>
<h2 id='NGeDSgam'>NGeDSgam: Local Scoring Algorithm with GeD Splines in Backfitting</h2><span id='topic+NGeDSgam'></span>

<h3>Description</h3>

<p>Implements the Local Scoring Algorithm (Hastie and Tibshirani
(1986)), applying normal GeD splines (i.e., <code><a href="#topic+NGeDS">NGeDS</a></code> function) to
fit the targets within the backfitting iterations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NGeDSgam(
  formula,
  data,
  weights = NULL,
  normalize_data = FALSE,
  family = "gaussian",
  min_iterations,
  max_iterations,
  phi_gam_exit = 0.995,
  q_gam = 2,
  beta = 0.5,
  phi = 0.99,
  internal_knots = 500,
  q = 2,
  higher_order = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NGeDSgam_+3A_formula">formula</code></td>
<td>
<p>a description of the structure of the model to be fitted,
including the dependent and independent variables. Unlike <code><a href="#topic+NGeDS">NGeDS</a></code>
and <code><a href="#topic+GGeDS">GGeDS</a></code>, the formula specified allows for multiple additive
GeD spline regression components (as well as linear components) to be included
(e.g., <code>Y ~ f(X1) + f(X2) + X3</code>). See <code><a href="#topic+formula.GeDS">formula</a></code>
for further details.</p>
</td></tr>
<tr><td><code id="NGeDSgam_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables referenced in the formula.</p>
</td></tr>
<tr><td><code id="NGeDSgam_+3A_weights">weights</code></td>
<td>
<p>an optional vector of &lsquo;prior weights&rsquo; to be put on the
observations during the fitting process. It should be <code>NULL</code> or a numeric
vector of the same length as the response variable defined in the formula.</p>
</td></tr>
<tr><td><code id="NGeDSgam_+3A_normalize_data">normalize_data</code></td>
<td>
<p>a logical that defines whether the data should be
normalized (standardized) before fitting the baseline linear model, i.e.,
before running the local-scoring algorithm. Normalizing the data involves
scaling the predictor variables to have a mean of 0 and a standard deviation
of 1. This process alters the scale and interpretation of the knots and
coefficients estimated. Default is equal to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="NGeDSgam_+3A_family">family</code></td>
<td>
<p>a character string indicating the response variable distribution
and link function to be used. Default is <code>"gaussian"</code>. This should be a
character or a family object.</p>
</td></tr>
<tr><td><code id="NGeDSgam_+3A_min_iterations">min_iterations</code></td>
<td>
<p>optional parameter to manually set a minimum number of
boosting iterations to be run. If not specified, it defaults to 0L.</p>
</td></tr>
<tr><td><code id="NGeDSgam_+3A_max_iterations">max_iterations</code></td>
<td>
<p>optional parameter to manually set the maximum number
of boosting iterations to be run. If not specified, it defaults to 100L.
This setting serves as a fallback when the stopping rule, based on
consecutive deviances and tuned by <code>phi_gam_exit</code> and <code>q_gam</code>,
does not trigger an earlier termination (see Dimitrova et al. (2024)).
Therefore, users can increase/decrease the number of boosting iterations,
by increasing/decreasing the value <code>phi_gam_exit</code> and/or <code>q_gam</code>,
or directly specify <code>max_iterations</code>.</p>
</td></tr>
<tr><td><code id="NGeDSgam_+3A_phi_gam_exit">phi_gam_exit</code></td>
<td>
<p>Convergence threshold for local-scoring and backfitting.
Both algorithms stop when the relative change in the deviance is below this
threshold. Default is <code>0.995</code>.</p>
</td></tr>
<tr><td><code id="NGeDSgam_+3A_q_gam">q_gam</code></td>
<td>
<p>numeric parameter which allows to fine-tune the stopping rule of
local-scoring/backfitting, by default equal to <code>2L</code>.</p>
</td></tr>
<tr><td><code id="NGeDSgam_+3A_beta">beta</code></td>
<td>
<p>numeric parameter in the interval <code class="reqn">[0,1]</code>
tuning the knot placement in stage A of GeDS. Default is equal to <code>0.5</code>.
See details in <code><a href="#topic+NGeDS">NGeDS</a></code>.</p>
</td></tr>
<tr><td><code id="NGeDSgam_+3A_phi">phi</code></td>
<td>
<p>numeric parameter in the interval <code class="reqn">[0,1]</code> specifying the
threshold for the stopping rule  (model selector) in stage A of GeDS. Default
is equal to <code>0.99</code>. See details in <code><a href="#topic+NGeDS">NGeDS</a></code>.</p>
</td></tr>
<tr><td><code id="NGeDSgam_+3A_internal_knots">internal_knots</code></td>
<td>
<p>The maximum number of internal knots that can be added
by the GeDS base-learners in each boosting iteration, effectively setting the
value of <code>max.intknots</code> in <code><a href="#topic+NGeDS">NGeDS</a></code> at each backfitting
iteration. Default is <code>500L</code>.</p>
</td></tr>
<tr><td><code id="NGeDSgam_+3A_q">q</code></td>
<td>
<p>numeric parameter which allows to fine-tune the stopping rule of
stage A of GeDS, by default equal to <code>2L</code>. See details in <code><a href="#topic+NGeDS">NGeDS</a></code>.</p>
</td></tr>
<tr><td><code id="NGeDSgam_+3A_higher_order">higher_order</code></td>
<td>
<p>a logical that defines whether to compute the higher order
fits (quadratic and cubic) after the local-scoring algorithm is run. Default
is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The  <code>NGeDSgam</code> function employs the local scoring algorithm to fit a
Generalized Additive Model (GAM). This algorithm iteratively fits weighted
additive models by backfitting. Normal linear GeD splines, as well as linear
learners, are supported as function smoothers within the backfitting
algorithm. The local-scoring algorithm ultimately produces a linear fit.
Higher order fits (quadratic and cubic) are then computed by calculating the
Schoenbergs variation diminishing spline (VDS) approximation of the linear
fit.
</p>
<p>On the one hand, <code>NGeDSgam</code> includes all the parameters of
<code><a href="#topic+NGeDS">NGeDS</a></code>, which in this case tune the smoother fit at each
backfitting iteration. On the other hand, <code>NGeDSgam</code> includes some
additional parameters proper to the local-scoring procedure. We describe
the main ones as follows. 
</p>
<p>The <code>family</code> chosen determines the link function, adjusted dependent
variable and weights to be used in the local-scoring algorithm. The number of
local-scoring and backfitting iterations is controlled by a
<em>Ratio of Deviances</em> stopping rule similar to the one presented for
<code><a href="#topic+GGeDS">GGeDS</a></code>. In the same way <code>phi</code> and <code>q</code> tune the stopping
rule of <code><a href="#topic+GGeDS">GGeDS</a></code>, <code>phi_boost_exit</code> and <code>q_boost</code> tune the
stopping rule of <code>NGeDSgam</code>. The user can also manually control the number
of local-scoring iterations through <code>min_iterations</code> and 
<code>max_iterations</code>.
</p>


<h3>Value</h3>

<p><code><a href="#topic+GeDSgam-Class">GeDSgam-Class</a></code> object, i.e. a list of items that
summarizes the main details of the fitted GAM-GeDS model. See
<code><a href="#topic+GeDSgam-Class">GeDSgam-Class</a></code> for details. Some S3 methods are available in
order to make these objects tractable, such as
<code><a href="#topic+coef.GeDSgam">coef</a></code>, <code><a href="#topic+knots.GeDSgam">knots</a></code>,
<code><a href="#topic+print.GeDSgam">print</a></code> and <code><a href="#topic+predict.GeDSgam">predict</a></code>.
</p>


<h3>References</h3>

<p>Hastie, T. and Tibshirani, R. (1986). Generalized Additive Models.
<em>Statistical Science</em> <strong>1 (3)</strong> 297 - 310. <br />
DOI: <a href="https://doi.org/10.1214/ss/1177013604">doi:10.1214/ss/1177013604</a>
</p>
<p>Kaishev, V.K., Dimitrova, D.S., Haberman, S. and Verrall, R.J. (2016).
Geometrically designed, variable knot regression splines.
<em>Computational Statistics</em>, <strong>31</strong>, 1079&ndash;1105. <br />
DOI: <a href="https://doi.org/10.1007/s00180-015-0621-7">doi:10.1007/s00180-015-0621-7</a>
</p>
<p>Dimitrova, D. S., Kaishev, V. K., Lattuada, A. and Verrall, R. J.  (2023).
Geometrically designed variable knot splines in generalized (non-)linear
models.
<em>Applied Mathematics and Computation</em>, <strong>436</strong>. <br />
DOI: <a href="https://doi.org/10.1016/j.amc.2022.127493">doi:10.1016/j.amc.2022.127493</a>
</p>
<p>Dimitrova, D. S., Guillen, E. S. and Kaishev, V. K.  (2024).
<span class="pkg">GeDS</span>: An R Package for Regression, Generalized Additive
Models and Functional Gradient Boosting, based on Geometrically Designed
(GeD) Splines. <em>Manuscript submitted for publication.</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NGeDS">NGeDS</a></code>; <code><a href="#topic+GGeDS">GGeDS</a></code>; <code><a href="#topic+GeDSgam-Class">GeDSgam-Class</a></code>;
S3 methods such as <code><a href="#topic+knots.GeDSgam">knots.GeDSgam</a></code>; <code><a href="#topic+coef.GeDSgam">coef.GeDSgam</a></code>;
<code><a href="#topic+deviance.GeDSgam">deviance.GeDSgam</a></code>; <code><a href="#topic+predict.GeDSgam">predict.GeDSgam</a></code>
</p>
<p>gam, <a href="stats.html#topic+glm">glm</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load package
library(GeDS) 

data(airquality) 
data = na.omit(airquality)
data$Ozone &lt;- data$Ozone^(1/3)

formula = Ozone ~ f(Solar.R) + f(Wind, Temp)
Gmodgam &lt;- NGeDSgam(formula = formula, data = data,
phi_gam_exit = 0.995, phi = 0.995, q = 2)
MSE_Gmodgam_linear &lt;- mean((data$Ozone - Gmodgam$predictions$pred_linear)^2)
MSE_Gmodgam_quadratic &lt;- mean((data$Ozone - Gmodgam$predictions$pred_quadratic)^2)
MSE_Gmodgam_cubic &lt;- mean((data$Ozone - Gmodgam$predictions$pred_cubic)^2)

cat("\n", "MEAN SQUARED ERROR", "\n",
"Linear NGeDSgam:", MSE_Gmodgam_linear, "\n",
"Quadratic NGeDSgam:", MSE_Gmodgam_quadratic, "\n",
"Cubic NGeDSgam:", MSE_Gmodgam_cubic, "\n")

## S3 methods for class 'GeDSboost'
# Print 
print(Gmodgam)
# Knots
knots(Gmodgam, n = 2L)
knots(Gmodgam, n = 3L)
knots(Gmodgam, n = 4L)
# Coefficients
coef(Gmodgam, n = 2L)
coef(Gmodgam, n = 3L)
coef(Gmodgam, n = 4L)
# Deviances
deviance(Gmodgam, n = 2L)
deviance(Gmodgam, n = 3L)
deviance(Gmodgam, n = 4L)

</code></pre>

<hr>
<h2 id='plot+2CGeDS-method'>Plot method for GeDS objects.</h2><span id='topic+plot+2CGeDS-method'></span><span id='topic+plot.GeDS'></span><span id='topic+plot+2CGeDS+2CANY-method'></span>

<h3>Description</h3>

<p>Plot method for GeDS objects. Plots GeDS fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GeDS'
plot(
  x,
  f = NULL,
  which,
  DEV = FALSE,
  ask = FALSE,
  main,
  legend.pos = "topright",
  new.window = FALSE,
  wait = 0.5,
  n = 3L,
  type = c("none", "Polygon", "NCI", "ACI"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot+2B2CGeDS-method_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+GeDS-Class">GeDS-Class</a></code> object from which the GeDS fit(s) should
be extracted.</p>
</td></tr>
<tr><td><code id="plot+2B2CGeDS-method_+3A_f">f</code></td>
<td>
<p>(optional) specifies the underlying function or generating process
to which the model was fit. This parameter is useful if the user wishes to
plot the specified function/process alongside the model fit and the data</p>
</td></tr>
<tr><td><code id="plot+2B2CGeDS-method_+3A_which">which</code></td>
<td>
<p>a numeric vector specifying the iterations of stage A for which
the corresponding GeDS fits should be plotted.
It has to be a subset of  <code>1:nrow(x$stored)</code>. See details.</p>
</td></tr>
<tr><td><code id="plot+2B2CGeDS-method_+3A_dev">DEV</code></td>
<td>
<p>logical variable specifying whether a plot representing the
deviance at each iteration of stage A should be produced or not.</p>
</td></tr>
<tr><td><code id="plot+2B2CGeDS-method_+3A_ask">ask</code></td>
<td>
<p>logical variable specifying whether the user should be prompted
before changing the plot page.</p>
</td></tr>
<tr><td><code id="plot+2B2CGeDS-method_+3A_main">main</code></td>
<td>
<p>optional character string to be used as a title of the plot.</p>
</td></tr>
<tr><td><code id="plot+2B2CGeDS-method_+3A_legend.pos">legend.pos</code></td>
<td>
<p>the position of the legend within the panel. See
<a href="graphics.html#topic+legend">legend</a> for details.</p>
</td></tr>
<tr><td><code id="plot+2B2CGeDS-method_+3A_new.window">new.window</code></td>
<td>
<p>logical variable specifying whether the plot should be
shown in a new window or in the active one.</p>
</td></tr>
<tr><td><code id="plot+2B2CGeDS-method_+3A_wait">wait</code></td>
<td>
<p>time, in seconds, the system should wait before plotting a new
page. Ignored if <code>ask = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot+2B2CGeDS-method_+3A_n">n</code></td>
<td>
<p>integer value (2, 3 or 4) specifying the order (<code class="reqn">=</code> degree
<code class="reqn">+ 1</code>) of the GeDS fit that should be plotted. By default equal to
<code>3L</code>. Non-integer values will be passed to the function
<code><a href="base.html#topic+as.integer">as.integer</a></code>.</p>
</td></tr>
<tr><td><code id="plot+2B2CGeDS-method_+3A_type">type</code></td>
<td>
<p>character string specifying the type of plot required. Should be
set either to &quot;<code>Polygon</code>&quot; if the user wants to get also the control
polygon of the GeDS fit,  <code>"NCI"</code> or  <code>"ACI"</code> if 95% confidence
bands for the predictions should be plotted (see details) or <code>"none"</code> if
only the fitted GeDS curve should be plotted. Applies only when plotting a
univariate spline regression.</p>
</td></tr>
<tr><td><code id="plot+2B2CGeDS-method_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the
<code><a href="graphics.html#topic+plot.default">plot.default</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method is provided in order to allow the user to plot the GeDS  fits
contained in the <code><a href="#topic+GeDS-Class">GeDS-Class</a></code> objects.
</p>
<p>Since in Stage A of the GeDS algorithm the knots of a linear spline fit are
sequentially located, one at a time, the user may wish to visually inspect
this process using the argument <code>which</code>. The latter specifies a
particular iteration number (or a vector of such numbers) for which the
corresponding linear fit(s) should be plotted. The <code>ask</code> and <code>wait</code>
arguments can help the user to manage these pages.
</p>
<p>By means of <code>ask</code> the user can determine for how long each page should
appear on the screen. Pages are sequentially replaced by pressing the enter
button.
</p>
<p>Note that, in order to ensure stability, if the object was produced by the
function <code><a href="#topic+GGeDS">GGeDS</a></code>, plotting intermediate fits of stage A is
allowed  only if <code>n = 2</code>, in contrast to objects produced by 
<code><a href="#topic+NGeDS">NGeDS</a></code> for which plotting intermediate results is allowed also
for <code>n = </code>2 or 3 results.
</p>
<p>The confidence intervals obtained by setting <code>type = "NCI"</code> are
approximate local bands obtained considering the knots as fixed constants.
Hence the columns of the design matrix are seen as covariates and standard
methodology relying on the <code>se.fit</code> option of <code>predict.lm</code> or
<code>predict.glm</code> is applied.
</p>
<p>Setting <code>type = "ACI"</code>, asymptotic confidence intervals are plotted.
This option is applicable only if the canonical link function has been used
in the fitting procedure.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NGeDS">NGeDS</a></code> and <code><a href="#topic+GGeDS">GGeDS</a></code>;
<code><a href="graphics.html#topic+plot">plot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###################################################
# Generate a data sample for the response variable
# Y and the single covariate X, assuming Normal noise
set.seed(123)
N &lt;- 500
f_1 &lt;- function(x) (10*x/(1+100*x^2))*4+4
X &lt;- sort(runif(N, min = -2, max = 2))
# Specify a model for the mean of Y to include only a component
# non-linear in X, defined by the function f_1
means &lt;- f_1(X)
# Add (Normal) noise to the mean of Y
Y &lt;- rnorm(N, means, sd = 0.1)

# Fit a Normal GeDS regression using NGeDS
(Gmod &lt;- NGeDS(Y ~ f(X), beta = 0.6, phi = 0.995, Xextr = c(-2,2)))

# Plot the final quadratic GeDS fit (red solid line)
# with its control polygon (blue dashed line)
plot(Gmod)

# Plot the quadratic fit obtained from the linear fit at the 10th
# iteration of stage A i.e. after 9 internal knots have been inserted
# by the GeDS procedure
plot(Gmod, which=10)

# Generate plots of all the intermediate fits obtained
# by running the GeDS procedure
## Not run: 
plot(Gmod, which=1:16)

## End(Not run)

###################################################
# Generate a data sample for the response variable Y and the covariate
# X assuming Poisson distributed error and a log link function

set.seed(123)
N &lt;- 500
f_1 &lt;- function(x) (10*x/(1+100*x^2))*4+4
X &lt;- sort(runif(N ,min = -2, max = 2))
# Specify a model for the mean of Y to include only a component
# non-linear in X, defined by the function f_1
means &lt;- exp(f_1(X))
# Generate Poisson distributed Y according to the mean model
Y &lt;- rpois(N,means)

# Fit a Poisson GeDS regression model using GGeDS
(Gmod2 &lt;- GGeDS(Y ~ f(X), beta = 0.2, phi = 0.995, family = poisson(),
                Xextr = c(-2,2)))

# similar plots as before, but for the linear fit
plot(Gmod2, n = 2)
plot(Gmod2, which = 10, n = 2)
## Not run: 
plot(Gmod2, which = 1:16, n = 2)
plot(Gmod2, which = 1:16, n = 2, ask = T)

## End(Not run)

</code></pre>

<hr>
<h2 id='PPolyRep'>Piecewise Polynomial Spline Representation</h2><span id='topic+PPolyRep'></span>

<h3>Description</h3>

<p>The function converts a GeDS fit which has a  B-spline representation to a
piecewise polynomial form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PPolyRep(object, n = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PPolyRep_+3A_object">object</code></td>
<td>
<p>the <code><a href="#topic+GeDS-class">GeDS-class</a></code> where the GeDS fit to be
converted is found.</p>
</td></tr>
<tr><td><code id="PPolyRep_+3A_n">n</code></td>
<td>
<p>integer value (2, 3 or 4) specifying the order (<code class="reqn">=</code> degree
<code class="reqn">+ 1</code>) of the GeDS fit which should be converted to a piecewise
polynomial form. By default equal to <code>3L</code>. Non-integer values will be
passed to the function <code><a href="base.html#topic+as.integer">as.integer</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts a selected GeDS fit from a <code><a href="#topic+GeDS-class">GeDS-class</a></code>
object represented in terms of B-splines into an object where the fit is
represented in terms of piecewise polynomials.
</p>
<p>The function  wraps <code><a href="splines.html#topic+polySpline">polySpline</a></code> in order to let it 
accept <code><a href="#topic+GeDS-class">GeDS-class</a></code> objects as input. Hence the function provides
a useful link between the package <span class="pkg">GeDS</span> and the package <span class="pkg">splines</span>,
allowing the user to take advantage of the functions provided in the
<span class="pkg">splines</span> package.
</p>


<h3>Value</h3>

<p>An object that inherits from classes  <code>"spline"</code> and
<code>"polySpline"</code>. It is a list whose arguments are:
</p>
<table>
<tr><td><code>knots</code></td>
<td>
<p> a vector of size  <code class="reqn">k + 2</code> containing the complete set of 
knots (internal knots plus the limits of the interval) of the GeDS fit.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p> a <code class="reqn">(k + 2) \times n</code> matrix containing the
coefficients of the  polynomials in the required piecewise polynomial
representation. </p>
</td></tr>
</table>


<h3>Note</h3>

<p>Let us note that the first <code class="reqn">k+1</code> rows of the matrix contain the
<code>n</code> coefficients of the <code class="reqn">k+1</code> consecutive pieces of the piecewise
polynomial representation. The last <code class="reqn">(k+2)</code>-th row is extraneous and it
appears as a result of the use of the function
<code><a href="splines.html#topic+polySpline">polySpline</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a data sample for the response variable
# Y and the single covariate X
set.seed(123)
N &lt;- 500
f_1 &lt;- function(x) (10*x/(1+100*x^2))*4+4
X &lt;- sort(runif(N, min = -2, max = 2))
# Specify a model for the mean of Y to include only
# a component non-linear in X, defined by the function f_1
means &lt;- f_1(X)
# Add (Normal) noise to the mean of Y
Y &lt;- rnorm(N, means, sd = 0.1)

# Fit a Normal GeDS regression using NGeDS
Gmod &lt;- NGeDS(Y ~ f(X), beta = 0.6, phi = 0.995, Xextr = c(-2,2))

# construct the PP representation of the cubic GeDS fit
# and apply some functions of the package splines
Polymod &lt;- PPolyRep(Gmod, 4)
require(splines)
class(Polymod)
splineKnots(Polymod)
knots(Gmod, n = 4)
plot(Polymod)


# Generate a plot showing the PP representation
# based on the same example
knt &lt;- splineKnots(Polymod)
coeffs &lt;- coef(Polymod)
plot(Gmod, n = 4, legend = FALSE, main = "Cubic Curves")
cols &lt;- sample(heat.colors(length(knt)), length(knt))
for(i in 1:(length(knt))){
  curve(coeffs[i,1] + coeffs[i,2]*(x - knt[i])+
          coeffs[i,3]*(x - knt[i])^2+
        coeffs[i,4]*(x - knt[i])^3,
        add = TRUE, col = cols[i])
  abline(v = knt[i])
}

</code></pre>

<hr>
<h2 id='predict.GeDS'>Predict method for GeDS objects</h2><span id='topic+predict.GeDS'></span>

<h3>Description</h3>

<p>This is a user friendly method to compute predictions from GeDS objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GeDS'
predict(object, newdata, type = c("response", "link", "terms"), n = 3L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.GeDS_+3A_object">object</code></td>
<td>
<p>the <code><a href="#topic+GeDS-class">GeDS-class</a></code> object for which the
computation of the predicted values is required.</p>
</td></tr>
<tr><td><code id="predict.GeDS_+3A_newdata">newdata</code></td>
<td>
<p>an optional <code>data.frame</code>, <code>list</code> or
<code>environment</code> containing values of the independent variables for  which
predicted values of the predictor model (including the GeDS and the
parametric components) should be computed. If left empty the values are
extracted from the object <code>x</code> itself.</p>
</td></tr>
<tr><td><code id="predict.GeDS_+3A_type">type</code></td>
<td>
<p>character string indicating the type of prediction required. By
default it is equal to <code>"response"</code>, i.e. the result is on the scale of
the response variable. See details for the other options.</p>
</td></tr>
<tr><td><code id="predict.GeDS_+3A_n">n</code></td>
<td>
<p>integer value (2, 3 or 4) specifying the order (<code class="reqn">=</code> degree
<code class="reqn">+ 1</code>) of the GeDS fit whose predicted values should be computed. By
default equal to <code>3L</code>. Non-integer values will be passed to the function
<code><a href="base.html#topic+as.integer">as.integer</a></code>.</p>
</td></tr>
<tr><td><code id="predict.GeDS_+3A_...">...</code></td>
<td>
<p>potentially further arguments (required by the definition of the
generic function). They are ignored, but with a warning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the function <code><a href="stats.html#topic+predict">predict</a></code> that allows
the user to handle <code><a href="#topic+GeDS-Class">GeDS-Class</a></code> objects.
</p>
<p>In analogy with the function <code><a href="stats.html#topic+predict.glm">predict.glm</a></code> in the
<span class="pkg">stats</span> package, the user can specify the scale on which the predictions
should be computed through the argument <code>type</code>. If the predictions are
required to be on the scale of the response variable, the user should set
<code>type = "response"</code>, which is the default. Alternatively if one wants
the predictions to be on the predictor scale, it is necessary to set
<code>type = "link"</code>.
By specifying <code>type = "terms"</code>, it is possible to inspect the predicted
values separately for each single independent variable which enter either the
GeD spline component or the parametric component of the predictor model. In
this case the returned result is a matrix whose columns correspond to the
terms supplied via <code>newdata</code> or extracted from the <code>object</code>.
</p>
<p>As GeDS objects contain three different fits (linear, quadratic and cubic),
it is possible to specify the order for which GeDS predictions are required
via the input argument <code>n</code>.
</p>


<h3>Value</h3>

<p>A numeric vector corresponding to the predicted values (if
<code>type = "link"</code> or <code>type = "response"</code>). If <code>type = "terms"</code> a
numeric matrix with a column per term.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+predict">predict</a></code> for the standard definition;
<code><a href="#topic+GGeDS">GGeDS</a></code> for examples.
</p>

<hr>
<h2 id='predict.GeDSboost+2Cgam'>Predict method for GeDSboost, GeDSgam</h2><span id='topic+predict.GeDSboost+2Cgam'></span><span id='topic+predict.GeDSboost'></span><span id='topic+predict.GeDSboost+2C'></span><span id='topic+predict.GeDSgam'></span>

<h3>Description</h3>

<p>This method computes predictions from GeDSboost and GeDSgam objects. 
It is designed to be user-friendly and accommodate different orders of the
GeDSboost or GeDSgam fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GeDSboost'
predict(object, newdata, n = 2L, ...)

## S3 method for class 'GeDSgam'
predict(object, newdata, n = 2L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.GeDSboost+2B2Cgam_+3A_object">object</code></td>
<td>
<p>The <code><a href="#topic+GeDSboost-class">GeDSboost-class</a></code> or
<code><a href="#topic+GeDSgam-class">GeDSgam-class</a></code> object.</p>
</td></tr>
<tr><td><code id="predict.GeDSboost+2B2Cgam_+3A_newdata">newdata</code></td>
<td>
<p>An optional data frame for prediction.</p>
</td></tr>
<tr><td><code id="predict.GeDSboost+2B2Cgam_+3A_n">n</code></td>
<td>
<p>The order of the GeDS fit (2 for linear, 3 for quadratic, and 4 for
cubic). 
Default is 2.</p>
</td></tr>
<tr><td><code id="predict.GeDSboost+2B2Cgam_+3A_...">...</code></td>
<td>
<p>potentially further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of predictions (vector of means).
</p>

<hr>
<h2 id='print.GeDS'>Print method for GeDS, GeDSboost, GeDSgam</h2><span id='topic+print.GeDS'></span><span id='topic+print.GeDSboost'></span><span id='topic+print.GeDSgam'></span>

<h3>Description</h3>

<p>Method for the generic function <code><a href="base.html#topic+print">print</a></code> that allows to
print on screen the main information related to the fitted predictor model
that can be extracted from a <code><a href="#topic+GeDS-class">GeDS-class</a></code>,
<code><a href="#topic+GeDSboost-class">GeDSboost-class</a></code> or <code><a href="#topic+GeDSgam-class">GeDSgam-class</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GeDS'
print(x, digits = max(3L, getOption("digits") - 3L), ...)

## S3 method for class 'GeDSboost'
print(x, digits = max(3L, getOption("digits") - 3L), ...)

## S3 method for class 'GeDSgam'
print(x, digits = max(3L, getOption("digits") - 3L), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.GeDS_+3A_x">x</code></td>
<td>
<p>the <code><a href="#topic+GeDS-class">GeDS-class</a></code>, <code><a href="#topic+GeDSboost-class">GeDSboost-class</a></code> or
<code><a href="#topic+GeDSgam-class">GeDSgam-class</a></code> object for which the main information should be
printed on screen.</p>
</td></tr>
<tr><td><code id="print.GeDS_+3A_digits">digits</code></td>
<td>
<p>number of digits to be printed.</p>
</td></tr>
<tr><td><code id="print.GeDS_+3A_...">...</code></td>
<td>
<p>potentially further arguments (required by the definition of the
generic function).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method allows to print on screen basic information related to the fitted
predictor model such as the function <code>call</code>, the number of internal
knots for the linear GeDS/FGB-GeDS/GAM-GeDS fit and the deviances for the
three (linear, quadratic and cubic) fitted predictor models embedded in the
<code><a href="#topic+GeDSboost-class">GeDSboost-class</a></code> or <code><a href="#topic+GeDSgam-class">GeDSgam-class</a></code> object.
</p>


<h3>Value</h3>

<p>This function returns (invisibly) the same input object, but adding
the slot <code>Print</code> that contains the three sub-slots:
</p>
<table>
<tr><td><code>Nknots</code></td>
<td>
<p> the number of internal knots of the linear
GeDS/FGB-GeDS/GAM-GeDS fit</p>
</td></tr>
<tr><td><code>Deviances</code></td>
<td>
<p> the deviances of the three (linear, quadratic and cubic)
GeDS/FGB-GeDS/GAM-GeDS fits</p>
</td></tr>
<tr><td><code>Call</code></td>
<td>
<p> the <code>call</code> to the function that produced the <code>x</code>
object</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print">print</a></code> for the standard definition.
</p>

<hr>
<h2 id='SplineReg'>Estimation of the coefficients of a predictor model with spline and
possibly parametric components.</h2><span id='topic+SplineReg'></span><span id='topic+SplineReg_LM'></span><span id='topic+SplineReg_GLM'></span>

<h3>Description</h3>

<p>Functions that estimate the coefficients of a predictor model involving a
spline component and possibly a parametric component applying (Iteratively
Re-weighted) Least Squares (IR)LS iteration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SplineReg_LM(
  X,
  Y,
  Z = NULL,
  offset = rep(0, NROW(X)),
  weights = rep(1, length(Y)),
  InterKnots,
  n,
  extr = range(X),
  prob = 0.95,
  coefficients = NULL
)

SplineReg_GLM(
  X,
  Y,
  Z,
  offset = rep(0, nobs),
  weights = rep(1, length(Y)),
  InterKnots,
  n,
  extr = range(X),
  family,
  mustart,
  inits = NULL,
  etastart = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SplineReg_+3A_x">X</code></td>
<td>
<p>a numeric vector containing <code class="reqn">N</code> sample values of the covariate
chosen to enter the spline regression component of the predictor model.</p>
</td></tr>
<tr><td><code id="SplineReg_+3A_y">Y</code></td>
<td>
<p>a vector of size <code class="reqn">N</code> containing the observed values of the
response variable <code class="reqn">y</code>.</p>
</td></tr>
<tr><td><code id="SplineReg_+3A_z">Z</code></td>
<td>
<p>a design matrix with <code class="reqn">N</code> rows containing other covariates
selected to enter the parametric component of the predictor model (see
<code><a href="#topic+formula.GeDS">formula</a></code>). If no such covariates are selected,
it is set to <code>NULL</code> by default.</p>
</td></tr>
<tr><td><code id="SplineReg_+3A_offset">offset</code></td>
<td>
<p>a vector of size <code class="reqn">N</code> that can be used to specify a fixed
covariate to be included in the predictor model avoiding the estimation of
its corresponding regression coefficient. In case  more than one covariate is
fixed, the user should sum the corresponding coordinates of the fixed
covariates to produce one common <code class="reqn">N</code>-vector of coordinates. The argument
<code>offset</code> is particularly useful in <code>Splinereg_GLM</code> if the link
function used is not the identity.</p>
</td></tr>
<tr><td><code id="SplineReg_+3A_weights">weights</code></td>
<td>
<p>an optional vector of &lsquo;prior weights&rsquo; to be put on the
observations in the fitting process in case the user requires weighted
fitting. It is a vector of 1s by default.</p>
</td></tr>
<tr><td><code id="SplineReg_+3A_interknots">InterKnots</code></td>
<td>
<p>a numeric vector containing the locations of the internal
knots necessary to compute the B-splines. In GeDS these are the internal
knots in a current iteration of stage A.</p>
</td></tr>
<tr><td><code id="SplineReg_+3A_n">n</code></td>
<td>
<p>integer value specifying  the order of the spline to be evaluated.
It should be 2 (linear spline), 3 (quadratic spline) or 4 (cubic spline).
Non-integer values will be passed to the function <code><a href="base.html#topic+as.integer">as.integer</a></code>.</p>
</td></tr>
<tr><td><code id="SplineReg_+3A_extr">extr</code></td>
<td>
<p>optional numeric vector of 2 elements representing the left-most
and right-most limits of the interval embedding the sample values of
<code>X</code>. By default equal correspondingly to the smallest and largest values
of <code>X</code>.</p>
</td></tr>
<tr><td><code id="SplineReg_+3A_prob">prob</code></td>
<td>
<p>the confidence level to be used for the confidence bands in the
<code>SplineReg_LM</code> fit. See details below.</p>
</td></tr>
<tr><td><code id="SplineReg_+3A_coefficients">coefficients</code></td>
<td>
<p>optional vector of spline coefficients. If provided,
<code>SplineReg</code> computes only the corresponding predicted values.</p>
</td></tr>
<tr><td><code id="SplineReg_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to be
used in the model. This can be a character string naming a family function, a
family function or the result of a call to a family function. See
<code><a href="stats.html#topic+family">family</a></code> for details of family functions.</p>
</td></tr>
<tr><td><code id="SplineReg_+3A_mustart">mustart</code></td>
<td>
<p>initial values for the vector of means in the IRLS estimation.
Must be a vector of length <code class="reqn">N</code>.</p>
</td></tr>
<tr><td><code id="SplineReg_+3A_inits">inits</code></td>
<td>
<p>a numeric vector of length
<code>length(InterKnots) + n + NCOL(Z)</code> providing initial values for the
coefficients, to be used in the IRLS estimation (alternative to providing the
<code>mustart</code> vector).</p>
</td></tr>
<tr><td><code id="SplineReg_+3A_etastart">etastart</code></td>
<td>
<p>initial values for the predictor in the IRLS estimation
(alternative to providing either <code>inits</code> or <code>mustart</code>). Must be a
vector of length <code class="reqn">N</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions estimate the coefficients of a predictor model with a spline
component (and possibly a parametric component) for a given, fixed order and
vector of knots of the spline and a specified distribution of the response
variable (from the Exponential Family). The functions <code>SplineReg_LM</code> and
<code>SplineReg_GLM</code> are based correspondingly on LS and IRLS and used
correspondingly in <code><a href="#topic+NGeDS">NGeDS</a></code> and <code><a href="#topic+GGeDS">GGeDS</a></code>, to estimate
the coefficients of the final GeDS fits of stage B, after their knots have
been positioned to coincide with the Greville abscissas of the knots of the
linear fit from stage A (see Dimitrova et al. 2023). Additional inference
related quantities are also computed (see Value below). The function
<code>SplineReg_GLM</code> is also used to estimate the coefficients of the linear
GeDS fit of stage A within <code><a href="#topic+GGeDS">GGeDS</a></code>, whereas in
<code><a href="#topic+NGeDS">NGeDS</a></code> this estimation is performed internally leading to faster
R code.
</p>
<p>In addition <code>SplineReg_LM</code> computes some useful quantities among which
confidence intervals and the Control Polygon (see Section 2 of
Kaishev et al. 2016).
</p>
<p>The confidence intervals contained in the output slot <code>NCI</code> are
approximate local bands obtained considering the knots as fixed constants.
Hence the columns of the design matrix are seen as covariates and standard
methodology relying on the <code>se.fit</code> option of <code>predict.lm</code> or
<code>predict.glm</code> is used. In the <code>ACI</code> slot, asymptotic confidence
intervals are provided, following Kaishev et al (2006).
</p>
<p>As mentioned, <code>SplineReg_GLM</code> is intensively used in Stage A of the GeDS
algorithm implemented in <code><a href="#topic+GGeDS">GGeDS</a></code> and in order to make it as fast
as possible input data validation is mild. Hence it is expected that the user
checks carefully the input parameters before using <code>SplineReg_GLM</code>. The
&quot;<code>Residuals</code>&quot; in the output of this function are similar to the so
called &ldquo;working residuals&quot; in the <code><a href="stats.html#topic+glm">glm</a></code> function. 
&quot;<code>Residuals</code>&quot;  are the residuals <code class="reqn">r_i</code> used in the knot placement
procedure, i.e. </p>
<p style="text-align: center;"><code class="reqn">r_i= (y_i - \hat{\mu}_i){d \mu_i \over d \eta_i },</code>
</p>
<p> but
in contrast to <code><a href="stats.html#topic+glm">glm</a></code> &ldquo;working residuals&quot;, they are
computed using the final IRLS fitted <code class="reqn">\hat{\mu}_i</code>. &quot;<code>Residuals</code>&quot;
are then used in locating the knots of the linear spline fit of Stage A.
</p>
<p>In <code>SplineReg_GLM</code> confidence intervals are not computed.
</p>


<h3>Value</h3>

<p>A <code>list</code> containing:
</p>
<table>
<tr><td><code>Theta</code></td>
<td>
<p> a vector containing the fitted coefficients of the spline
regression component and the parametric component of the predictor model.</p>
</td></tr>
<tr><td><code>Predicted</code></td>
<td>
<p> a vector of <code class="reqn">N</code> predicted mean values of the response
variable computed at the sample values of the covariate(s).</p>
</td></tr>
<tr><td><code>Residuals</code></td>
<td>
<p> a vector containing the normal regression residuals if
<code>SplineReg_LM</code> is called or the residuals described in Details if
<code>SplineReg_GLM</code> is called.</p>
</td></tr>
<tr><td><code>RSS</code></td>
<td>
<p> the deviance for the fitted predictor model, defined as in
Dimitrova et al. (2023), which for <code>SplineReg_LM</code> coincides with the
Residual Sum of Squares.</p>
</td></tr>
<tr><td><code>NCI</code></td>
<td>
<p> a list containing the lower (<code>Low</code>) and upper (<code>Upp</code>)
limits of the approximate confidence intervals computed at the sample values
of the covariate(s). See  details above.</p>
</td></tr>
<tr><td><code>Basis</code></td>
<td>
<p> the matrix of B-spline regression functions and the covariates
of the parametric part evaluated at the sample values of the covariate(s).</p>
</td></tr>
<tr><td><code>Polygon</code></td>
<td>
<p> a list containing x-y coordinates (&quot;<code>Kn</code>&quot; and
&quot;<code>Thetas</code>&quot;) of the vertices of the Control Polygon, see
Dimitrova et al. (2023).</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p> a vector containing deviances computed at each IRLS step
(computed only with the <code>SplineReg_GLM</code>).</p>
</td></tr>
<tr><td><code>temporary</code></td>
<td>
<p> the result of the function <code><a href="stats.html#topic+lm">lm</a></code> if
<code>SplineReg_LM</code> is used or the output of the function
<code><a href="#topic+IRLSfit">IRLSfit</a></code> (which is similar to the output from
<code><a href="stats.html#topic+glm.fit">glm.fit</a></code>), if <code>SplineReg_GLM</code> is used.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Kaishev, V. K., Dimitrova, D. S., Haberman, S. &amp; Verrall, R. J. (2006).
Geometrically designed, variable know regression splines: asymptotics and
inference <em>(Statistical Research Paper No. 28)</em>.
London, UK: Faculty of Actuarial Science &amp; Insurance, City University London. <br />
URL: <a href="https://openaccess.city.ac.uk/id/eprint/2372">openaccess.city.ac.uk</a>
</p>
<p>Kaishev, V.K., Dimitrova, D.S., Haberman, S., &amp; Verrall, R.J. (2016).
Geometrically designed, variable knot regression splines.
<em>Computational Statistics</em>, <strong>31</strong>, 1079&ndash;1105. <br />
DOI: <a href="https://doi.org/10.1007/s00180-015-0621-7">doi:10.1007/s00180-015-0621-7</a>
</p>
<p>Dimitrova, D. S., Kaishev, V. K., Lattuada, A. and Verrall, R. J.  (2023).
Geometrically designed variable knot splines in generalized (non-)linear
models. <em>Applied Mathematics and Computation</em>, <strong>436</strong>. <br />
DOI: <a href="https://doi.org/10.1016/j.amc.2022.127493">doi:10.1016/j.amc.2022.127493</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NGeDS">NGeDS</a></code>, <code><a href="#topic+GGeDS">GGeDS</a></code>, <code><a href="#topic+Fitters">Fitters</a></code>,
<code><a href="#topic+IRLSfit">IRLSfit</a></code>, <code><a href="stats.html#topic+lm">lm</a></code> and
<code><a href="stats.html#topic+glm.fit">glm.fit</a></code>.
</p>

<hr>
<h2 id='UnivariateFitters'>Functions used to fit GeDS objects w/univariate spline regression
component</h2><span id='topic+UnivariateFitters'></span><span id='topic+UnivariateFitter'></span><span id='topic+Fitters'></span><span id='topic+GenUnivariateFitter'></span>

<h3>Description</h3>

<p>These are computing engines called by <code><a href="#topic+NGeDS">NGeDS</a></code> and
<code><a href="#topic+GGeDS">GGeDS</a></code>, needed for the underlying fitting procedures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UnivariateFitter(
  X,
  Y,
  Z = NULL,
  offset = rep(0, NROW(Y)),
  weights = rep(1, length(X)),
  beta = 0.5,
  phi = 0.5,
  min.intknots = 0,
  max.intknots = 300,
  q = 2,
  extr = range(X),
  show.iters = FALSE,
  tol = as.double(1e-12),
  stoptype = c("SR", "RD", "LR"),
  higher_order = TRUE
)

GenUnivariateFitter(
  X,
  Y,
  Z = NULL,
  offset = rep(0, NROW(Y)),
  weights = rep(1, length(X)),
  family = gaussian(),
  beta = 0.5,
  phi = 0.5,
  min.intknots = 0,
  max.intknots = 300,
  q = 2,
  extr = range(X),
  show.iters = F,
  tol = as.double(1e-12),
  stoptype = c("SR", "RD", "LR"),
  higher_order = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UnivariateFitters_+3A_x">X</code></td>
<td>
<p>a numeric vector containing <code class="reqn">N</code> sample values of the covariate
chosen to enter the spline regression component of the predictor model.</p>
</td></tr>
<tr><td><code id="UnivariateFitters_+3A_y">Y</code></td>
<td>
<p>a vector of size <code class="reqn">N</code> containing the observed values of the
response variable <code class="reqn">y</code>.</p>
</td></tr>
<tr><td><code id="UnivariateFitters_+3A_z">Z</code></td>
<td>
<p>a design matrix with <code class="reqn">N</code> rows containing other covariates
selected to enter the parametric component of the predictor model (see
<code><a href="#topic+formula.GeDS">formula</a></code>). If no such covariates are selected, it
is set to <code>NULL</code> by default.</p>
</td></tr>
<tr><td><code id="UnivariateFitters_+3A_offset">offset</code></td>
<td>
<p>a vector of size <code class="reqn">N</code> that can be used to specify a fixed
covariate to be included in the predictor model  avoiding the estimation of
its corresponding regression coefficient. In case  more than one covariate is
fixed, the user should sum the corresponding coordinates of the fixed
covariates to produce one common <code class="reqn">N</code>-vector of coordinates. The
<code>offset</code> argument is particularly useful when using 
<code>GenUnivariateFitter</code> if the link function used is not the identity.</p>
</td></tr>
<tr><td><code id="UnivariateFitters_+3A_weights">weights</code></td>
<td>
<p>an optional vector of size <code class="reqn">N</code> of &lsquo;prior weights&rsquo; to be
put on the observations in the fitting process in case the user requires
weighted GeDS fitting. It is <code>NULL</code> by default.</p>
</td></tr>
<tr><td><code id="UnivariateFitters_+3A_beta">beta</code></td>
<td>
<p>numeric parameter in the interval <code class="reqn">[0,1]</code> tuning the knot
placement in stage A of GeDS. See the description of <code><a href="#topic+NGeDS">NGeDS</a></code> or
<code><a href="#topic+GGeDS">GGeDS</a></code>.</p>
</td></tr>
<tr><td><code id="UnivariateFitters_+3A_phi">phi</code></td>
<td>
<p>numeric parameter in the interval <code class="reqn">[0,1]</code> specifying the
threshold for the stopping rule  (model selector) in stage A of GeDS. See
also <code>stoptype</code> and details in the description of <code><a href="#topic+NGeDS">NGeDS</a></code> or
<code><a href="#topic+GGeDS">GGeDS</a></code>.</p>
</td></tr>
<tr><td><code id="UnivariateFitters_+3A_min.intknots">min.intknots</code></td>
<td>
<p>optional parameter allowing the user to set a minimum
number of internal knots required. By default equal to zero.</p>
</td></tr>
<tr><td><code id="UnivariateFitters_+3A_max.intknots">max.intknots</code></td>
<td>
<p>optional parameter allowing the user to set a maximum
number of internal knots to be added by the GeDS estimation algorithm. By
default equal to the number of internal knots <code class="reqn">\kappa</code> for the saturated
GeDS model (i.e. <code class="reqn">\kappa=N-2</code>).</p>
</td></tr>
<tr><td><code id="UnivariateFitters_+3A_q">q</code></td>
<td>
<p>numeric parameter which allows to fine-tune the stopping rule of
stage A of GeDS, by default equal to 2. See details in the description of
<code><a href="#topic+NGeDS">NGeDS</a></code> or <code><a href="#topic+GGeDS">GGeDS</a></code>.</p>
</td></tr>
<tr><td><code id="UnivariateFitters_+3A_extr">extr</code></td>
<td>
<p>numeric vector of 2 elements representing the left-most and
right-most limits of the interval embedding the sample values of <code>X</code>. By
default equal correspondingly to the smallest and largest values of <code>X</code>.</p>
</td></tr>
<tr><td><code id="UnivariateFitters_+3A_show.iters">show.iters</code></td>
<td>
<p>logical variable indicating whether or not to print 
information at each step. By default equal to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="UnivariateFitters_+3A_tol">tol</code></td>
<td>
<p>numeric value indicating the tolerance to be used in the knot
placement steps in stage A. By default equal to 1E-12. See details below.</p>
</td></tr>
<tr><td><code id="UnivariateFitters_+3A_stoptype">stoptype</code></td>
<td>
<p>a character string indicating the type of GeDS stopping rule
to be used. It should be either <code>"SR"</code>, <code>"RD"</code> or <code>"LR"</code>,
partial match allowed. See details of <code><a href="#topic+NGeDS">NGeDS</a></code> or
<code><a href="#topic+GGeDS">GGeDS</a></code>.</p>
</td></tr>
<tr><td><code id="UnivariateFitters_+3A_higher_order">higher_order</code></td>
<td>
<p>a logical that defines whether to compute the higher
order fits (quadratic and cubic) after stage A is run. Default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="UnivariateFitters_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to be
used in the model. This can be a character string naming a family function
(e.g. <code>"gaussian"</code>), the family function itself (e.g.
<code><a href="stats.html#topic+gaussian">gaussian</a></code>) or the result of a call to a family function
(e.g. <code>gaussian()</code>). See <a href="stats.html#topic+family">family</a> for details on family
functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>UnivariateFitter</code> and <code>GenUnivariateFitter</code> are in
general not intended to be used directly, they should be called through
<code><a href="#topic+NGeDS">NGeDS</a></code> and <code><a href="#topic+GGeDS">GGeDS</a></code>. However, in case there is a need
for multiple GeDS fitting (as may be the case e.g. in Monte Carlo simulations)
it may be efficient to use the fitters outside the main functions.
</p>
<p>The argument <code>tol</code> is used in the knot placement procedure of stage A of
the GeDS algorithm in order to check whether the current knot <code class="reqn">\delta^*</code> 
is set at an acceptable location or not. If there exists a knot <code class="reqn">\delta_i</code>
such that <code class="reqn">|\delta^* - \delta_i| &lt; </code><code>tol</code>, <code class="reqn">\delta^*</code>, then the
new knot is considered to be coalescent with an existing one, it is discarded
and the algorithm seeks alternative knot locations. By default it is equal to
1e-12.
</p>
<p>See <code><a href="#topic+NGeDS">NGeDS</a></code> and <code><a href="#topic+GGeDS">GGeDS</a></code>, Kaishev et al. (2016) and
Dimitrova et al. (2023) for further details.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+GeDS-Class">GeDS-Class</a></code> object, but without the <code>Formula</code>,
<code>extcall</code>, <code>terms</code> and <code>znames</code> slots.
</p>


<h3>References</h3>

<p>Kaishev, V.K., Dimitrova, D.S., Haberman, S., &amp; Verrall, R.J. (2016).
Geometrically designed, variable knot regression splines.
<em>Computational Statistics</em>, <strong>31</strong>, 1079&ndash;1105. <br />
DOI: <a href="https://doi.org/10.1007/s00180-015-0621-7">doi:10.1007/s00180-015-0621-7</a>
</p>
<p>Dimitrova, D. S., Kaishev, V. K., Lattuada, A. and Verrall, R. J.  (2023).
Geometrically designed variable knot splines in generalized (non-)linear
models.
<em>Applied Mathematics and Computation</em>, <strong>436</strong>. <br />
DOI: <a href="https://doi.org/10.1016/j.amc.2022.127493">doi:10.1016/j.amc.2022.127493</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NGeDS">NGeDS</a></code> and <code><a href="#topic+GGeDS">GGeDS</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Examples similar to the ones
# presented in NGeDS and in GGeDS

# Generate a data sample for the response variable
# Y and the covariate X
set.seed(123)
N &lt;- 500
f_1 &lt;- function(x) (10*x/(1+100*x^2))*4+4
X &lt;- sort(runif(N ,min = -2, max = 2))
# Specify a model for the mean of Y to include only
# a component non-linear in X, defined by the function f_1
means &lt;- f_1(X)
# Add (Normal) noise to the mean of Y
Y &lt;- rnorm(N, means, sd = 0.1)

# Fit a Normal GeDS regression model using the fitter function
(Gmod &lt;- UnivariateFitter(X, Y, beta = 0.6, phi = 0.995,
           extr = c(-2,2)))

##############################################################
# second: very similar example, but based on Poisson data
set.seed(123)
X &lt;- sort(runif(N , min = -2, max = 2))
means &lt;- exp(f_1(X))
Y &lt;- rpois(N,means)
(Gmod2 &lt;- GenUnivariateFitter(X, Y, beta = 0.2,
            phi = 0.995, family = poisson(), extr = c(-2,2)))

# a plot showing quadratic and cubic fits,
# in the predictor scale
plot(X,log(Y), xlab = "x", ylab = expression(f[1](x)))
lines(Gmod2, n = 3, col = "red")
lines(Gmod2, n = 4, col = "blue", lty = 2)
legend("topleft", c("Quadratic","Cubic"),
     col = c("red","blue"), lty = c(1,2))

</code></pre>

<hr>
<h2 id='visualize_boosting'>Visualize Boosting Iterations</h2><span id='topic+visualize_boosting'></span><span id='topic+visualize_boosting.GeDSboost'></span>

<h3>Description</h3>

<p>This function plots the <code><a href="#topic+NGeDSboost">NGeDSboost</a></code> fit to the data at the
beginning of a given boosting iteration and then plots the subsequent
<code><a href="#topic+NGeDS">NGeDS</a></code> fit on the corresponding residual (negative gradient).
Note: Applicable only for <code><a href="#topic+NGeDSboost">NGeDSboost</a></code> models with one covariate
and <code>family = mboost::Gaussian()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GeDSboost'
visualize_boosting(M, object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="visualize_boosting_+3A_m">M</code></td>
<td>
<p>Numeric, specifies the iteration number.</p>
</td></tr>
<tr><td><code id="visualize_boosting_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+GeDSboost-Class">GeDSboost-Class</a></code> object.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Load packages
library(GeDS)

# Generate a data sample for the response variable
# Y and the single covariate X
set.seed(123)
N &lt;- 500
f_1 &lt;- function(x) (10*x/(1+100*x^2))*4+4
X &lt;- sort(runif(N, min = -2, max = 2))
# Specify a model for the mean of Y to include only a component
# non-linear in X, defined by the function f_1
means &lt;- f_1(X)
# Add (Normal) noise to the mean of Y
Y &lt;- rnorm(N, means, sd = 0.2)
data = data.frame(X, Y)
object &lt;- NGeDSboost(Y ~ f(X), data = data, normalize_data = TRUE)

# Plot
plot(X, Y, pch=20, col=c("darkgrey"))
lines(X, sapply(X, f_1), col = "black", lwd = 2)
lines(X, object$predictions$pred_linear, col = "green4", lwd = 2)
lines(X, object$predictions$pred_quadratic, col="red", lwd=2)
lines(X, object$predictions$pred_cubic, col="purple", lwd=2)
legend("topright",
legend = c("Order 2 (degree=1)", "Order 3 (degree=2)", "Order 4 (degree=3)"),
col = c("green4", "red", "purple"),
lty = c(1, 1),
lwd = c(2, 2, 2),
cex = 0.75,
bty="n",
bg = "white")
# Visualize boosting iterations
par(mfrow=c(2,2))
visualize_boosting(0, object)
visualize_boosting(1, object)
par(mfrow=c(1,1))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
