<!DOCTYPE html><html lang="en"><head><title>Help for package GeDS</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GeDS}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#GeDS-package'><p>GeDS</p></a></li>
<li><a href='#BaFe2As2'><p>Barium-Ferrum-Arsenide Powder Diffraction Data</p></a></li>
<li><a href='#BivariateFitters'><p>Fitter function for GeD Spline Regression for bivariate data</p></a></li>
<li><a href='#bl_imp.GeDSboost'><p>Base Learner Importance for GeDSboost objects</p></a></li>
<li><a href='#coalMining'><p>Coal Mining Disasters data</p></a></li>
<li><a href='#coef.GeDS'><p>Coef method for GeDS objects</p></a></li>
<li><a href='#coef.GeDSboost+2Cgam'><p>Coef method for GeDSboost, GeDSgam</p></a></li>
<li><a href='#crossv_GeDS'><p>k-fold cross-validation</p></a></li>
<li><a href='#CrystalData'><p>Crystallographic Scattering Data</p></a></li>
<li><a href='#Derive'><p>Derivative of GeDS objects</p></a></li>
<li><a href='#deviance.GeDS'><p>Deviance method for GeDS, GeDSboost, GeDSgam</p></a></li>
<li><a href='#EWmortality'><p>Death counts in England and Wales</p></a></li>
<li><a href='#f'><p>Defining the covariates for the spline component in a GeDS formula.</p></a></li>
<li><a href='#formula.GeDS'><p>Formula for the predictor model</p></a></li>
<li><a href='#GeDS-class'><p>GeDS Class</p></a></li>
<li><a href='#GeDSboost-class'><p>GeDSboost Class</p></a></li>
<li><a href='#GeDSgam-class'><p>GeDSgam Class</p></a></li>
<li><a href='#GGeDS'><p>Generalized Geometrically Designed Spline regression estimation</p></a></li>
<li><a href='#Integrate'><p>Defined integral of GeDS objects</p></a></li>
<li><a href='#IRLSfit'><p>IRLS Estimation</p></a></li>
<li><a href='#knots.GeDS'><p>Knots method for GeDS, GeDSboost, GeDSgam</p></a></li>
<li><a href='#lines+2CGeDS-method'><p>Lines method for GeDS objects.</p></a></li>
<li><a href='#NGeDS'><p>Geometrically Designed Spline regression estimation</p></a></li>
<li><a href='#NGeDSboost'><p>Component-wise gradient boosting with NGeDS base-learners</p></a></li>
<li><a href='#NGeDSgam'><p>NGeDSgam: Local Scoring Algorithm with GeD Splines in Backfitting</p></a></li>
<li><a href='#plot+2CGeDS-method'><p>Plot method for GeDS objects.</p></a></li>
<li><a href='#plot+2CGeDSboost-method'><p>Plot method for GeDSboost objects.</p></a></li>
<li><a href='#plot+2CGeDSgam-method'><p>Plot method for GeDSgam objects.</p></a></li>
<li><a href='#PPolyInv'><p>Inversion the piecewise polynomial representation of a spline object</p></a></li>
<li><a href='#PPolyRep'><p>Piecewise Polynomial Spline Representation</p></a></li>
<li><a href='#predict.GeDS'><p>Predict method for GeDS objects</p></a></li>
<li><a href='#predict.GeDSboost+2Cgam'><p>Predict method for GeDSboost, GeDSgam</p></a></li>
<li><a href='#print.GeDS'><p>Print method for GeDS, GeDSboost, GeDSgam</p></a></li>
<li><a href='#SplineReg'><p>Estimation of the coefficients of a predictor model with spline and</p>
possibly parametric components.</a></li>
<li><a href='#UnivariateFitters'><p>Functions used to fit GeDS objects with an univariate spline regression</p>
component</a></li>
<li><a href='#visualize_boosting'><p>Visualize Boosting Iterations</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Geometrically Designed Spline Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-03-10</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Emilio L. Sáenz Guillén &lt;Emilio.Saenz-Guillen@bayes.city.ac.uk&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Spline Regression, Generalized Additive Models, and Component-wise Gradient
  Boosting, utilizing Geometrically Designed (GeD) Splines. GeDS regression is a
  non-parametric method inspired by geometric principles, for fitting spline regression
  models with variable knots in one or two independent variables. It efficiently estimates
  the number of knots and their positions, as well as the spline order, assuming the
  response variable follows a distribution from the exponential family. GeDS models
  integrate the broader category of Generalized (Non-)Linear Models, offering a flexible
  approach to modeling complex relationships. A description of the method can be found in
  Kaishev et al. (2016) &lt;<a href="https://doi.org/10.1007%2Fs00180-015-0621-7">doi:10.1007/s00180-015-0621-7</a>&gt; and Dimitrova et al. (2023)
  &lt;<a href="https://doi.org/10.1016%2Fj.amc.2022.127493">doi:10.1016/j.amc.2022.127493</a>&gt;. Further extending its capabilities, GeDS's implementation
  includes Generalized Additive Models (GAM) and Functional Gradient Boosting (FGB),
  enabling versatile multivariate predictor modeling, as discussed in the forthcoming work of
  Dimitrova et al. (2025).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/emilioluissaenzguillen/GeDS">https://github.com/emilioluissaenzguillen/GeDS</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/emilioluissaenzguillen/GeDS/issues">https://github.com/emilioluissaenzguillen/GeDS/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.1), Rcpp (&ge; 1.0.0), splines, stats, utils, Matrix,
methods, mi, Rmpfr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>doFuture, doParallel, doRNG, foreach, future, MASS, mboost,
parallel, plot3D, TH.data</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-13 16:31:12 UTC; emili</td>
</tr>
<tr>
<td>Author:</td>
<td>Dimitrina S. Dimitrova [aut],
  Vladimir K. Kaishev [aut],
  Andrea Lattuada [aut],
  Emilio L. Sáenz Guillén [aut, cre],
  Richard J. Verrall [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-14 10:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='GeDS-package'>GeDS</h2><span id='topic+GeDS-package'></span><span id='topic+GeDS'></span>

<h3>Description</h3>

<p>Geometrically Designed Splines (GeDS) regression is a non-parametric method
for fitting spline regression models with variable knots. The GeDS technique
is inspired by geometric principles and falls within the domain of
generalized non-linear models (GNM), which include generalized linear models
(GLM) as a special case. GeDS regression is fitted  based on a sample of
<code class="reqn">N</code> observations of a response variable <code class="reqn">y</code>, dependent on a set of
(currently up to two) covariates, assuming <code class="reqn">y</code> has a distribution from
the exponential family. In addition, GeDS methodology is implemented both in
the context of Generalized Additive Models (GAM) and Functional Gradient
Boosting (FGB). On the one hand, GAM consist of an additive modeling
technique where the impact of the predictor variables is captured through
smooth (GeDS, in this case) functions. On the other hand, GeDS incorporates
gradient boosting machine learning technique by implementing functional
gradient descent algorithm to optimize general risk functions utilizing
component-wise GeDS estimates.
</p>


<h3>Details</h3>

<p>GeDS provides a novel solution to the spline regression problem and in
particular, to the problem of estimating the number and position of the knots.
The GeDS estimation method is based on: first, constructing a piecewise linear
fit (spline fit of order 2) which captures the underlying functional shape of
determined by the data (Stage A); second, approximating the latter fit through
shape preserving (variation diminishing) spline fits of higher orders
<code class="reqn">n = 3</code>, <code class="reqn">n = 4</code>,<code class="reqn">\dots</code> (i.e., degrees 2, 3,<code class="reqn">\dots</code>) at
stage B. As a result, GeDS simultaneously produces a linear, a quadratic and
a cubic spline fit.
</p>
<p>The GeDS method was originally developed by Kaishev et al. (2016) assuming
the response variable <code class="reqn">y</code> to be normally distributed and a corresponding
<em>Mathematica</em> code was provided.
</p>
<p>The GeDS method was extended by Dimitrova et al. (2023) to cover any
distribution from the exponential family. The <span class="pkg">GeDS</span> <span class="rlang"><b>R</b></span> package presented
here includes an enhanced <span class="rlang"><b>R</b></span> implementation of the original Normal GeDS 
<em>Mathematica</em> code due to Kaishev et al. (2016), implemented as the
<code><a href="#topic+NGeDS">NGeDS</a></code> function and a generalization of it in the function
<code><a href="#topic+GGeDS">GGeDS</a></code> which covers the case of any distribution from the
exponential family.
</p>
<p>The <span class="pkg">GeDS</span> package allows also to fit two dimensional response surfaces
and to construct multivariate (predictor) models with a GeD spline component
and a parametric component (see the functions <code><a href="#topic+f">f</a></code>,
<code><a href="#topic+formula.GeDS">formula</a></code>, <code><a href="#topic+NGeDS">NGeDS</a></code> and
<code><a href="#topic+GGeDS">GGeDS</a></code> for details).
</p>
<p>Dimitrova et al. (2025) have recently made significant enhancements to the
<span class="pkg">GeDS</span> methodology, by incorporating generalized additive models (GAM) and
functional gradient boosting (FGB). On the one hand, generalized additive
models are encompassed by implementing the <em>local-scoring</em> algorithm
using normal GeD splines (i.e., <code><a href="#topic+NGeDS">NGeDS</a></code>) as function smoothers
within the <em>backfitting</em> iterations. This is implemented via the function
<code><a href="#topic+NGeDSgam">NGeDSgam</a></code>. On the other hand, the <span class="pkg">GeDS</span> package incorporates
the functional gradient descent algorithm by utilizing normal GeD splines (i.e.,
<code><a href="#topic+NGeDS">NGeDS</a></code>) as base learners. This is implemented via the function
<code><a href="#topic+NGeDSboost">NGeDSboost</a></code>.
</p>
<p>The outputs of both <code><a href="#topic+NGeDS">NGeDS</a></code> and <code><a href="#topic+GGeDS">GGeDS</a></code> functions are
<code><a href="#topic+GeDS-class">GeDS-class</a></code> objects, while the outputs of <code><a href="#topic+NGeDSgam">NGeDSgam</a></code>
and <code><a href="#topic+NGeDSboost">NGeDSboost</a></code> functions are <code><a href="#topic+GeDSgam-class">GeDSgam-class</a></code> and
<code><a href="#topic+GeDSboost-class">GeDSboost-class</a></code> objects, respectively. <code><a href="#topic+GeDS-class">GeDS-class</a></code>,
<code><a href="#topic+GeDSgam-class">GeDSgam-class</a></code> and <code><a href="#topic+GeDSboost-class">GeDSboost-class</a></code> objects contain
second, third and fourth order spline fits. As described in 
Kaishev et al. (2016), Dimitrova et al. (2023) and  Dimitrova et al. (2025),
the &quot;final&quot; GeDS fit is the one minimizing the empirical deviance. Nevertheless,
the user can choose to use any of the available fits.
</p>
<p>The <span class="pkg">GeDS</span> package also includes some datasets where GeDS regression
proves to be very efficient and some user friendly functions that are designed
to easily extract required information. Several methods are also provided to
handle GeDS, GAM-GeDS and FGB-GeDS output results (see <code><a href="#topic+GeDS-class">GeDS-class</a></code>,
<code><a href="#topic+GeDSgam-class">GeDSgam-class</a></code> and <code><a href="#topic+GeDSboost-class">GeDSboost-class</a></code>, respectively).
</p>
<p>Throughout this document, we use the terms GeDS predictor model, GeDS
regression and GeDS fit interchangeably.
</p>
<p>Please report any issue arising or bug in the code to
<a href="mailto:emilio.saenz-guillen@bayes.city.ac.uk">emilio.saenz-guillen@bayes.city.ac.uk</a>.
</p>

<table>
<tr>
 <td style="text-align: right;">
Package: </td><td style="text-align: left;"> GeDS</td>
</tr>
<tr>
 <td style="text-align: right;">
Version: </td><td style="text-align: left;"> 0.2.6 </td>
</tr>
<tr>
 <td style="text-align: right;">
Date: </td><td style="text-align: left;"> 2025-02-10</td>
</tr>
<tr>
 <td style="text-align: right;">
License: </td><td style="text-align: left;"> GPL-3 </td>
</tr>
<tr>
 <td style="text-align: right;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Dimitrina S. Dimitrova &lt;D.Dimitrova@city.ac.uk&gt;,#' 
Vladimir K. Kaishev &lt;V.Kaishev@city.ac.uk&gt;,
Andrea Lattuada &lt;Andrea.Lattuada@unicatt.it&gt;,
Emilio L. Sáenz Guillén &lt;Emilio.Saenz-Guillen@bayes.city.ac.uk&gt; and
Richard J. Verrall &lt;R.J.Verrall@city.ac.uk&gt;
</p>


<h3>References</h3>

<p>Kaishev, V.K., Dimitrova, D.S., Haberman, S., &amp; Verrall, R.J. (2016).
Geometrically designed, variable knot regression splines.
<em>Computational Statistics</em>, <strong>31</strong>, 1079&ndash;1105. <br />
DOI: <a href="https://doi.org/10.1007/s00180-015-0621-7">doi:10.1007/s00180-015-0621-7</a>
</p>
<p>Dimitrova, D. S., Kaishev, V. K., Lattuada, A. and Verrall, R. J.  (2023).
Geometrically designed variable knot splines in generalized (non-)linear
models.
<em>Applied Mathematics and Computation</em>, <strong>436</strong>. <br />
DOI: <a href="https://doi.org/10.1016/j.amc.2022.127493">doi:10.1016/j.amc.2022.127493</a>
</p>
<p>Dimitrova, D. S., Kaishev, V. K. and Saenz Guillen, E. L. (2025).
<span class="pkg">GeDS</span>: An R Package for Regression, Generalized Additive
Models and Functional Gradient Boosting, based on Geometrically Designed
(GeD) Splines. <em>Manuscript submitted for publication.</em>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/emilioluissaenzguillen/GeDS">https://github.com/emilioluissaenzguillen/GeDS</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/emilioluissaenzguillen/GeDS/issues">https://github.com/emilioluissaenzguillen/GeDS/issues</a>
</p>
</li></ul>


<hr>
<h2 id='BaFe2As2'>Barium-Ferrum-Arsenide Powder Diffraction Data</h2><span id='topic+BaFe2As2'></span>

<h3>Description</h3>

<p>This dataset contains the results of a neutron diffraction experiment on
Barium-Ferrum-Arsenide (<code class="reqn">\mathrm{Ba Fe_2 As_2}</code>) powder carried out by
Kimber et al. (2009) and used in Kaishev et al. (2016). The neutron
diffraction intensity was measured at 1,151 different dispersion angles in
order to model the diffraction profile.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(BaFe2As2)
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 1151 cases and 2 variables:
</p>

<ul>
<li><p>angle: the dispersion angle, viewed as the independent variable.
</p>
</li>
<li><p>intensity: the neutron diffraction intensity, viewed as the response
variable.
</p>
</li></ul>



<h3>Source</h3>

<p><a href="https://openaccess.city.ac.uk/12418/">openaccess.city.ac.uk</a>
</p>


<h3>References</h3>

<p>Kimber, S.A.J., Kreyssig, A., Zhang, Y.Z., Jeschke, H.O., Valenti, R.,
Yokaichiya, F., Colombier, E., Yan, J., Hansen, T.C., Chatterji, T.,
McQueeney, R.J., Canfield, P.C., Goldman, A.I. and Argyriou, D.N. (2009).
Similarities between structural distortions under pressure and chemical
doping in superconducting <code class="reqn">\mathrm{Ba Fe_2 As_2}</code>. <em>Nat Mater</em>,
<strong>8</strong>, 471&ndash;475.
</p>
<p>Kaishev, V.K., Dimitrova, D.S., Haberman, S. and Verrall, R.J. (2016).
Geometrically designed, variable knot regression splines.
<em>Computational Statistics</em>, <strong>31</strong>, 1079&ndash;1105. <br />
DOI: <a href="https://doi.org/10.1007/s00180-015-0621-7">doi:10.1007/s00180-015-0621-7</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# to load the data
data('BaFe2As2')

# fit a GeDS regression and produce a simple plot of the result. See ?NGeDS
# c.f. Kaishev et al. (2016), section 4.2
(Gmod &lt;- NGeDS(intensity ~ f(angle), data = BaFe2As2, beta = 0.6, phi = 0.99,
               q = 3, show.iters = T))
plot(Gmod)

## End(Not run)

</code></pre>

<hr>
<h2 id='BivariateFitters'>Fitter function for GeD Spline Regression for bivariate data</h2><span id='topic+BivariateFitters'></span><span id='topic+BivariateFitter'></span><span id='topic+GenBivariateFitter'></span>

<h3>Description</h3>

<p>These are computing engines called by <code><a href="#topic+NGeDS">NGeDS</a></code> and
<code><a href="#topic+GGeDS">GGeDS</a></code>, needed for the underlying fitting procedures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BivariateFitter(
  X,
  Y,
  Z,
  W,
  weights = rep(1, length(X)),
  Indicator,
  beta = 0.5,
  phi = 0.99,
  min.intknots = 0,
  max.intknots = 300,
  q = 2,
  Xextr = range(X),
  Yextr = range(Y),
  show.iters = TRUE,
  tol = as.double(1e-12),
  stoptype = c("SR", "RD", "LR"),
  higher_order = TRUE,
  Xintknots = NULL,
  Yintknots = NULL
)

GenBivariateFitter(
  X,
  Y,
  Z,
  W,
  family = family,
  weights = rep(1, length(X)),
  Indicator,
  beta = 0.5,
  phi = 0.5,
  min.intknots = 0,
  max.intknots = 300,
  q = 2,
  Xextr = range(X),
  Yextr = range(Y),
  show.iters = TRUE,
  tol = as.double(1e-12),
  stoptype = c("SR", "RD", "LR"),
  higher_order = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BivariateFitters_+3A_x">X</code></td>
<td>
<p>a numeric vector containing <code class="reqn">N</code> sample values of the first
independent variable chosen to enter the spline regression component of the
predictor model.</p>
</td></tr>
<tr><td><code id="BivariateFitters_+3A_y">Y</code></td>
<td>
<p>a numeric vector containing <code class="reqn">N</code> sample values of the second
independent variable chosen to enter the spline regression component of the
predictor model.</p>
</td></tr>
<tr><td><code id="BivariateFitters_+3A_z">Z</code></td>
<td>
<p>a vector of size <code class="reqn">N</code> containing the observed values of the
response variable.</p>
</td></tr>
<tr><td><code id="BivariateFitters_+3A_w">W</code></td>
<td>
<p>a design matrix with <code class="reqn">N</code> rows containing other covariates
selected to enter the parametric component of the predictor model (see
<code><a href="#topic+formula.GeDS">formula</a></code>). If no such covariates are selected, it
is set to <code>NULL</code> by default.</p>
</td></tr>
<tr><td><code id="BivariateFitters_+3A_weights">weights</code></td>
<td>
<p>an optional vector of size <code class="reqn">N</code> of &lsquo;prior weights&rsquo; to be
put on the observations in the fitting process in case the user requires
weighted GeDS fitting. It is <code>NULL</code> by default.</p>
</td></tr>
<tr><td><code id="BivariateFitters_+3A_indicator">Indicator</code></td>
<td>
<p>contingency table (i.e., frequency of observations) for the
independent variables <code>X</code> and <code>Y</code>.</p>
</td></tr>
<tr><td><code id="BivariateFitters_+3A_beta">beta</code></td>
<td>
<p>numeric parameter in the interval <code class="reqn">[0,1]</code> tuning the knot
placement in stage A of GeDS. See the description of <code><a href="#topic+NGeDS">NGeDS</a></code> or
<code><a href="#topic+GGeDS">GGeDS</a></code>.</p>
</td></tr>
<tr><td><code id="BivariateFitters_+3A_phi">phi</code></td>
<td>
<p>numeric parameter in the interval <code class="reqn">[0,1]</code> specifying the
threshold for the stopping rule  (model selector) in stage A of GeDS. See
also <code>stoptype</code> and details in the description of <code><a href="#topic+NGeDS">NGeDS</a></code> or
<code><a href="#topic+GGeDS">GGeDS</a></code>.</p>
</td></tr>
<tr><td><code id="BivariateFitters_+3A_min.intknots">min.intknots</code></td>
<td>
<p>optional parameter specifying the minimum number of
internal knots required in Stage A's fit. Default is zero.</p>
</td></tr>
<tr><td><code id="BivariateFitters_+3A_max.intknots">max.intknots</code></td>
<td>
<p>optional parameter allowing the user to set a maximum
number of internal knots to be added in Stage A by the GeDS estimation
algorithm. Default equals the number of internal knots <code class="reqn">\kappa</code> for the
saturated GeDS model (i.e. <code class="reqn">\kappa=N-2</code>).</p>
</td></tr>
<tr><td><code id="BivariateFitters_+3A_q">q</code></td>
<td>
<p>numeric parameter which allows to fine-tune the stopping rule of
stage A of GeDS, by default equal to 2. See details in the description of
<code><a href="#topic+NGeDS">NGeDS</a></code> or <code><a href="#topic+GGeDS">GGeDS</a></code>.</p>
</td></tr>
<tr><td><code id="BivariateFitters_+3A_xextr">Xextr</code></td>
<td>
<p>boundary knots in the <code>X</code> direction. By default equal to
the range of <code>X</code>.</p>
</td></tr>
<tr><td><code id="BivariateFitters_+3A_yextr">Yextr</code></td>
<td>
<p>boundary knots in the <code>Y</code> direction. By default equal to
the range of <code>Y</code>.</p>
</td></tr>
<tr><td><code id="BivariateFitters_+3A_show.iters">show.iters</code></td>
<td>
<p>logical variable indicating whether or not to print fitting
information at each step. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="BivariateFitters_+3A_tol">tol</code></td>
<td>
<p>numeric value indicating the tolerance to be used in checking
whether two knots should be considered different during the knot placement
steps in stage A.</p>
</td></tr>
<tr><td><code id="BivariateFitters_+3A_stoptype">stoptype</code></td>
<td>
<p>a character string indicating the type of GeDS stopping rule
to be used. It should be either <code>"SR"</code>, <code>"RD"</code> or <code>"LR"</code>,
partial match allowed. See details of <code><a href="#topic+NGeDS">NGeDS</a></code> or
<code><a href="#topic+GGeDS">GGeDS</a></code>.</p>
</td></tr>
<tr><td><code id="BivariateFitters_+3A_higher_order">higher_order</code></td>
<td>
<p>a logical defining whether to compute the higher
order fits (quadratic and cubic) after stage A is run. Default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="BivariateFitters_+3A_xintknots">Xintknots</code></td>
<td>
<p>a vector of starting internal knots in the <code>X</code> direction. 
Allows the user to begin Stage A's GeDS algorithm with a linear spline fit
using a predefined vector of internal <code>X</code> knots, instead of starting with
a straight line fit. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="BivariateFitters_+3A_yintknots">Yintknots</code></td>
<td>
<p>a vector of starting internal knots in the <code>Y</code> direction. 
Allows the user to begin Stage A's GeDS algorithm with a linear spline fit
using a predefined vector of internal <code>X</code> knots, instead of starting with
a straight line fit. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="BivariateFitters_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to be
used in the model. This can be a character string naming a family function
(e.g. <code>"gaussian"</code>), the family function itself (e.g.
<code><a href="stats.html#topic+gaussian">gaussian</a></code>) or the result of a call to a family function
(e.g. <code>gaussian()</code>). See <a href="stats.html#topic+family">family</a> for details on family
functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+GeDS-Class">GeDS-Class</a></code> object, but without the <code>Formula</code>,
<code>extcall</code>, <code>terms</code> and <code>znames</code> slots.
</p>


<h3>References</h3>

<p>Dimitrova, D. S., Kaishev, V. K., Lattuada, A. and Verrall, R. J.  (2023).
Geometrically designed variable knot splines in generalized (non-)linear
models.
<em>Applied Mathematics and Computation</em>, <strong>436</strong>. <br />
DOI: <a href="https://doi.org/10.1016/j.amc.2022.127493">doi:10.1016/j.amc.2022.127493</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NGeDS">NGeDS</a></code>, <code><a href="#topic+GGeDS">GGeDS</a></code> and <code><a href="#topic+UnivariateFitters">UnivariateFitters</a></code>.
</p>

<hr>
<h2 id='bl_imp.GeDSboost'>Base Learner Importance for GeDSboost objects</h2><span id='topic+bl_imp.GeDSboost'></span><span id='topic+bl_imp'></span>

<h3>Description</h3>

<p>S3 method for <code><a href="#topic+GeDSboost-class">GeDSboost-class</a></code> objects that calculates the
in-bag risk reduction ascribable to each base-learner of an FGB-GeDS model.
Essentially, it measures and aggregates the decrease in the empirical risk
attributable to each base-learner for every time it is selected across the
boosting iterations. This provides a measure on how much each base-learner
contributes to the overall improvement in the model's accuracy, as reflectedp
by the decrease in the empiral risk (loss function). This function is adapted
from <code><a href="mboost.html#topic+varimp">varimp</a></code> and is compatible with the available
<code><a href="mboost.html#topic+mboost-package">mboost-package</a></code> methods for <code><a href="mboost.html#topic+varimp">varimp</a></code>,
including <code>plot</code>, <code>print</code> and <code>as.data.frame</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GeDSboost'
bl_imp(object, boosting_iter_only = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bl_imp.GeDSboost_+3A_object">object</code></td>
<td>
<p>an object of class <code><a href="#topic+GeDSboost-class">GeDSboost-class</a></code>.</p>
</td></tr>
<tr><td><code id="bl_imp.GeDSboost_+3A_boosting_iter_only">boosting_iter_only</code></td>
<td>
<p>logical value, if <code>TRUE</code> then base-learner
in-bag risk reduction is only computed across boosting iterations, i.e.,
without taking into account a potential initial GeDS learner.</p>
</td></tr>
<tr><td><code id="bl_imp.GeDSboost_+3A_...">...</code></td>
<td>
<p>potentially further arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See <code><a href="mboost.html#topic+varimp">varimp</a></code> for details.
</p>


<h3>Value</h3>

<p>An object of class <code>varimp</code> with available <code>plot</code>,
<code>print</code> and <code>as.data.frame</code> methods.
</p>


<h3>References</h3>

<p>Hothorn T., Buehlmann P., Kneib T., Schmid M. and Hofner B. (2022).
mboost: Model-Based Boosting. R package version 2.9-7, <a href="https://CRAN.R-project.org/package=mboost">https://CRAN.R-project.org/package=mboost</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(GeDS)
library(TH.data)
set.seed(290875)
data("bodyfat", package = "TH.data")
data = bodyfat
Gmodboost &lt;- NGeDSboost(formula = DEXfat ~ f(hipcirc) + f(kneebreadth) + f(anthro3a),
                        data = data, initial_learner = FALSE)
MSE_Gmodboost_linear &lt;- mean((data$DEXfat - Gmodboost$predictions$pred_linear)^2)
MSE_Gmodboost_quadratic &lt;- mean((data$DEXfat - Gmodboost$predictions$pred_quadratic)^2)
MSE_Gmodboost_cubic &lt;- mean((data$DEXfat - Gmodboost$predictions$pred_cubic)^2)

# Print MSE
cat("\n", "MEAN SQUARED ERROR", "\n",
    "Linear NGeDSboost:", MSE_Gmodboost_linear, "\n",
    "Quadratic NGeDSboost:", MSE_Gmodboost_quadratic, "\n",
    "Cubic NGeDSboost:", MSE_Gmodboost_cubic, "\n")

# Base Learner Importance
bl_imp &lt;- bl_imp(Gmodboost)
print(bl_imp)
plot(bl_imp)

</code></pre>

<hr>
<h2 id='coalMining'>Coal Mining Disasters data</h2><span id='topic+coalMining'></span>

<h3>Description</h3>

<p>A dataset with 112 entries containing annual numbers of accidents due to
disasters in British coal mines for years from 1850 to 1962, considered in
Carlin et al. (1992) and also in Eilers and Marx (1996).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(coalMining)
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 112 entries, corresponding to the
years from 1850 to 1962. Each entry has:
</p>

<ul>
<li><p>accidents: number of severe accidents that have occurred each year.
</p>
</li>
<li><p>years: year during which the accidents occurred.
</p>
</li></ul>



<h3>Source</h3>

<p><a href="https://people.reed.edu/~jones/141/Coal.html">https://people.reed.edu/~jones/141/Coal.html</a>
</p>


<h3>References</h3>

<p>Carlin, B.P., Gelfand, A.E. and Smith, A.F.M. (1992).
Hierarchical Bayesian analysis of changepoint problems.
<em>Applied Statistics</em>, <strong>41</strong>(2), 389&ndash;405.
</p>
<p>Eilers, P.H.C. and Marx, B.D. (1996). Flexible Smoothing with B-splines
and Penalties. <em>Statistical Science</em>, <strong>11</strong>(2), 89&ndash;121.
</p>

<hr>
<h2 id='coef.GeDS'>Coef method for GeDS objects</h2><span id='topic+coef.GeDS'></span><span id='topic+coefficients.GeDS'></span>

<h3>Description</h3>

<p>Methods for the functions <code><a href="stats.html#topic+coef">coef</a></code> and
<code><a href="stats.html#topic+coefficients">coefficients</a></code> that allow to extract the estimated
coefficients of a fitted GeDS regression from a <code><a href="#topic+GeDS-Class">GeDS-Class</a></code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GeDS'
coef(object, n = 3L, onlySpline = TRUE, ...)

## S3 method for class 'GeDS'
coefficients(object, n = 3L, onlySpline = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.GeDS_+3A_object">object</code></td>
<td>
<p>the  <code><a href="#topic+GeDS-class">GeDS-class</a></code> object from which the
coefficients of the selected GeDS regression should be extracted.</p>
</td></tr>
<tr><td><code id="coef.GeDS_+3A_n">n</code></td>
<td>
<p>integer value (2, 3 or 4) specifying the order (<code class="reqn">=</code> degree
<code class="reqn">+ 1</code>) of the GeDS fit whose coefficients should be extracted. By default
equal to <code>3L</code>. Non-integer values will be passed to the function
<code><a href="base.html#topic+as.integer">as.integer</a></code>.</p>
</td></tr>
<tr><td><code id="coef.GeDS_+3A_onlyspline">onlySpline</code></td>
<td>
<p>logical variable specifying whether only the coefficients
for the GeDS  component of a fitted multivariate regression model should be
extracted or if, alternatively, also the coefficients of the parametric component
should also be extracted.</p>
</td></tr>
<tr><td><code id="coef.GeDS_+3A_...">...</code></td>
<td>
<p>potentially further arguments (required by the definition of the
generic function). These will be ignored, but with a warning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are simple methods for the functions <code><a href="stats.html#topic+coef">coef</a></code> and
<code><a href="stats.html#topic+coefficients">coefficients</a></code>.
</p>
<p>As <code><a href="#topic+GeDS-class">GeDS-class</a></code> objects contain three different fits (linear,
quadratic and cubic), it is possible to specify the order of the fit for
which GeDS regression coefficients are required via the input argument
<code>n</code>.
</p>
<p>As mentioned in the details of <code><a href="#topic+formula.GeDS">formula</a></code>, the
predictor model may be multivariate and it may include a (univariate or
bivariate) GeD spline component whereas the remaining variables may be part
of a parametric component. If the <code>onlySpline</code> argument is set to
<code>TRUE</code> (the default value), only the coefficients corresponding to the
GeD spline component of order <code>n</code> of the multivariate predictor model 
are extracted.
</p>


<h3>Value</h3>

<p>A named vector containing the required coefficients of the fitted
univariate or multivariate predictor model. The coefficients corresponding to
the variables that enter the parametric component of the fitted multivariate
predictor model are named as the variables themselves. The  coefficients of
the GeDS component are coded as &quot;<code>N</code>&quot; followed by the index of the
corresponding B-spline.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+coef">coef</a></code> for the standard definition;
<code><a href="#topic+NGeDS">NGeDS</a></code> for examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a data sample for the response variable
# and the covariates
set.seed(123)
N &lt;- 500
f_1 &lt;- function(x) (10*x/(1+100*x^2))*4+4
X &lt;- sort(runif(N ,min = -2, max = 2))
Z &lt;- runif(N)
# Specify a model for the mean of the response Y to be a superposition of
# a non-linear component f_1(X), a linear component 2*Z and a
# free term 1, i.e.
means &lt;- f_1(X) + 2*Z + 1
# Add normal noise to the mean of y
Y &lt;- rnorm(N, means, sd = 0.1)

# Fit to this sample a predictor model of the form f(X) + Z, where
# f(X) is the GeDS component and Z is the linear (additive) component
# see ?formula.GeDS for details
(Gmod &lt;- NGeDS(Y ~ f(X) + Z, beta = 0.6, phi = 0.995, Xextr = c(-2,2)))

# Extract the GeD spline regression coefficients
coef(Gmod, n = 3)

# Extract all the coefficients, including the one for the linear component
coef(Gmod, onlySpline = FALSE, n = 3)

</code></pre>

<hr>
<h2 id='coef.GeDSboost+2Cgam'>Coef method for GeDSboost, GeDSgam</h2><span id='topic+coef.GeDSboost+2Cgam'></span><span id='topic+coef.GeDSboost'></span><span id='topic+coef.GeDSboost+2C'></span><span id='topic+coef.GeDSgam'></span><span id='topic+coefficients.GeDSboost'></span><span id='topic+coefficients.GeDSgam'></span>

<h3>Description</h3>

<p>Methods for the functions <code><a href="stats.html#topic+coef">coef</a></code> and
<code><a href="stats.html#topic+coefficients">coefficients</a></code> that allow to extract the estimated
coefficients of a <code><a href="#topic+GeDSboost-class">GeDSboost-class</a></code> or <code><a href="#topic+GeDSgam-class">GeDSgam-class</a></code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GeDSboost'
coef(object, n = 3L, ...)

## S3 method for class 'GeDSboost'
coefficients(object, n = 3L, ...)

## S3 method for class 'GeDSgam'
coef(object, n = 3L, ...)

## S3 method for class 'GeDSgam'
coefficients(object, n = 3L, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.GeDSboost+2B2Cgam_+3A_object">object</code></td>
<td>
<p>the <code><a href="#topic+GeDSboost-class">GeDSboost-class</a></code> or
<code><a href="#topic+GeDSgam-class">GeDSgam-class</a></code> object from which the coefficients should be
extracted.</p>
</td></tr>
<tr><td><code id="coef.GeDSboost+2B2Cgam_+3A_n">n</code></td>
<td>
<p>integer value (2, 3 or 4) specifying the order (<code class="reqn">=</code> degree
<code class="reqn"> + 1</code>) of the FGB-GeDS/GAM-GeDS fit whose coefficients should be
extracted. 
</p>

<ul>
<li><p> If <code>n = 2L</code> the piecewise polynomial coefficients of the univariate
GeDS base-learners are provided. For bivariate GeDS base-learners, and if
<code>class(object) == "GeDSboost"</code>, the B-spline coefficients for each
iteration where the corresponding bivariate base-learner was selected are
provided. For bivariate base-learners, and if
<code>class(object) == "GeDSgam"</code>, the final local-scoring B-spline
coefficients are provided.
</p>
</li>
<li><p> If <code>n = 3L</code> or <code>n = 4L</code> B-spline coefficients are provided
for both univariate and bivariate GeDS learners.
</p>
</li></ul>

<p>By default <code>n</code> is equal to <code>3L</code>. Non-integer values will be passed
to the function <code><a href="base.html#topic+as.integer">as.integer</a></code>.</p>
</td></tr>
<tr><td><code id="coef.GeDSboost+2B2Cgam_+3A_...">...</code></td>
<td>
<p>potentially further arguments (required by the definition of the
generic function). These will be ignored, but with a warning.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector containing the required coefficients of the fitted
multivariate predictor model.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+coef">coef</a></code> for the standard definition;
<code><a href="#topic+NGeDSboost">NGeDSboost</a></code> and <code><a href="#topic+NGeDSgam">NGeDSgam</a></code> for examples.
</p>

<hr>
<h2 id='crossv_GeDS'>k-fold cross-validation</h2><span id='topic+crossv_GeDS'></span>

<h3>Description</h3>

<p><code>crossv_GeDS</code> performs k-fold cross-validation for tuning the relevant
parameters of the <code>NGeDS</code>, <code>GGeDS</code>, <code>NGeDSgam</code>, and
<code>NGeDSboost</code> models.
</p>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="crossv_GeDS_+3A_formula">formula</code></td>
<td>
<p>a description of the structure of the model structure,
including the dependent and independent variables.</p>
</td></tr>
<tr><td><code id="crossv_GeDS_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables referenced in the formula.</p>
</td></tr>
<tr><td><code id="crossv_GeDS_+3A_model_fun">model_fun</code></td>
<td>
<p>the GeDS model to be fitted, that is, <code>NGeDS</code>,
<code>GGeDS</code>, <code>NGeDSgam</code> or <code>NGeDSboost</code>.</p>
</td></tr>
<tr><td><code id="crossv_GeDS_+3A_parameters">parameters</code></td>
<td>
<p>to tune via cross-validation. These are: <code>beta</code>, <code>phi</code> and
<code>q</code> in the case of <code>NGeDS</code>, <code>GGeDS</code> and <code>NGeDSgam</code>. In
addition, for <code>NGeDSboost</code>, <code>int.knots_init</code> and <code>shrinkage</code>
can also be tuned. Default values are <code>int.knots_init_grid = c(0, 1, 2)</code>,
<code>shrinkage_grid = c(0.1, 0.5, 1)</code>, <code>beta_grid = c(0.3, 0.5, 0.7)</code>,
<code>phi_grid = c(0.9, 0.95, 0.99)</code>, <code>q_grid = c(2, 3))</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Two data frames, <code>best_params</code> and <code>results</code>.
<code>best_params</code> contains the best combination of parameters according to
the cross-validated MSE. <code>results</code> presents the cross-validated MSE and 
the average number of internal knots across the folds for each possible 
combination of parameters, given the input <code>parameters</code>. In the case of
<code>model_fun = NGeDSboost</code>, it also provides the cross-validated number of
boosting iterations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###################################################
# Generate a data sample for the response variable
# Y and the single covariate X
set.seed(123)
N &lt;- 500
f_1 &lt;- function(x) (10*x/(1+100*x^2))*4+4
X &lt;- sort(runif(N, min = -2, max = 2))
# Specify a model for the mean of Y to include only a component
# non-linear in X, defined by the function f_1
means &lt;- f_1(X)
# Add (Normal) noise to the mean of Y
Y &lt;- rnorm(N, means, sd = 0.1)
data = data.frame(X = X, Y = Y)

## Not run: 
## NGeDS
# Define different combinations of parameters to cross-validate
param = list(beta_grid = c(0.5),
             phi_grid = c(0.9, 0.95),
             q_grid = c(2))

cv_NGeDS &lt;- crossv_GeDS(Y ~ f(X), data = data, NGeDS, n = 3L,
                        parameters = param)

print(cv_NGeDS$best_params)
View(cv_NGeDS$results)

## NGeDSboost
param = list(int.knots_init_grid = c(1, 2),
             shrinkage_grid = 1,
             beta_grid = c(0.3, 0.5),
             phi_grid = c(0.95, 0.99),
             q_grid = 2)

cv_NGeDSboost &lt;- crossv_GeDS(Y ~ f(X), data = data, NGeDSboost, n = 2L,
                             n_folds = 2L, parameters = param)

print(cv_NGeDSboost$best_params)
View(cv_NGeDSboost$results)

## End(Not run)

</code></pre>

<hr>
<h2 id='CrystalData'>Crystallographic Scattering Data</h2><span id='topic+CrystalData'></span><span id='topic+CrystalData10k'></span><span id='topic+CrystalData300k'></span>

<h3>Description</h3>

<p>This dataset contains crystallographic measurements obtained from a particle 
accelerator experiment. The measurements correspond to the function <code class="reqn">F(Q)</code> 
at various <code class="reqn">Q</code> values, which are used to analyze the scattering properties 
of an unknown crystalline material. The dataset is available in two versions 
based on the precision of the measurements:
</p>
<p>- **'CrystalData10k'** (lower precision);
- **'CrystalData300k'** (higher precision).
</p>
<p>The goal of the experiment is to estimate <code class="reqn">F(Q)</code> from noisy data using 
a GeDS model and compute its Fourier transform, which provides valuable insights 
into the structure of the material.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(CrystalData10k)

data(CrystalData300k)
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 1721 observations and 2 variables:
</p>

<ul>
<li><p><code>Q</code> (<code class="reqn">\text{Å}^{-1}</code>): The scattering vector, measured in inverse angstroms (<code class="reqn">\text{Å}^{-1}</code>).
</p>
</li>
<li><p><code>FQ</code> (a.u.): The measured function <code class="reqn">F(Q)</code>, given in arbitrary units (a.u.).
</p>
</li></ul>



<h3>Source</h3>

<p>Data collected from a particle accelerator experiment.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Load the dataset (choose 10k or 300k version)
data('CrystalData10k')

# Fit a GeDS/GeDSboost model and compare how well the intensity peaks are captured
Gmod &lt;- NGeDS(F_Q ~ f(Q), data = CrystalData10k, phi = 0.999, q = 3)
# for CrystalData300k set int.knots_init = 1, phi = 0.999, q = 4, instead
Gmodboost &lt;- NGeDSboost(F_Q ~ f(Q), data = CrystalData10k, phi = 0.9975, q = 4) 

par(mfrow = c(1,2))
plot(Gmod, n = 2)
plot(Gmodboost, n = 2) 

## End(Not run)

</code></pre>

<hr>
<h2 id='Derive'>Derivative of GeDS objects</h2><span id='topic+Derive'></span>

<h3>Description</h3>

<p>This function computes derivatives of a fitted GeDS regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Derive(object, order = 1L, x, n = 3L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Derive_+3A_object">object</code></td>
<td>
<p>the <code><a href="#topic+GeDS-Class">GeDS-Class</a></code> object containing the GeDS fit
which should be differentiated. It should be the result of fitting a 
univariate GeDS regression via <code><a href="#topic+NGeDS">NGeDS</a></code> or <code><a href="#topic+GGeDS">GGeDS</a></code>.</p>
</td></tr>
<tr><td><code id="Derive_+3A_order">order</code></td>
<td>
<p>integer value indicating the order of differentiation required
(e.g. first, second or higher derivatives). Note that <code>order</code> should be
lower than <code>n</code> and that non-integer values will be passed to the
function <code><a href="base.html#topic+as.integer">as.integer</a></code>.</p>
</td></tr>
<tr><td><code id="Derive_+3A_x">x</code></td>
<td>
<p>numeric vector containing values of the independent variable at
which the derivatives of order <code>order</code> should be computed.</p>
</td></tr>
<tr><td><code id="Derive_+3A_n">n</code></td>
<td>
<p>integer value (2, 3 or 4) specifying the order (<code class="reqn">=</code> degree
<code class="reqn"> + 1</code>) of the GeDS fit to be differentiated. By default equal to
<code>3L</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is based on <code><a href="splines.html#topic+splineDesign">splineDesign</a></code> and it
computes the exact derivative of the fitted GeDS regression.
</p>
<p>The function uses the property that the <code class="reqn">m</code>-th derivative of a spline,
<code class="reqn">m= 1,2,...</code>, expressed in terms of B-splines can be computed by
differentiating the corresponding B-spline coefficients (see e.g.
De Boor, 2001, Chapter X, formula (15)). Since the GeDS fit is a B-spline
representation of the predictor, it cannot work on the response scale in the
GNM (GLM) framework.
</p>


<h3>References</h3>

<p>De Boor, C. (2001). <em>A Practical Guide to Splines (Revised Edition)</em>.
Springer, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate a data sample for the response variable
# Y and the covariate X
set.seed(123)
N &lt;- 500
f_1 &lt;- function(x) (10*x/(1+100*x^2))*4+4
X &lt;- sort(runif(N, min = -2, max = 2))
# Specify a model for the mean of Y to include only
# a component non-linear in X, defined by the function f_1
means &lt;- f_1(X)
# Add (Normal) noise to the mean of Y
Y &lt;- rnorm(N, means, sd = 0.1)

# Fit GeDS regression with only a spline component in the predictor model
Gmod &lt;- NGeDS(Y ~ f(X), beta = 0.6, phi = 0.995, Xextr = c(-2,2))

# Compute the second derivative of the cubic GeDS fit
# at the points 0, -1 and 1
Derive(Gmod, x = c(0, -1, 1), order = 2, n = 4)

</code></pre>

<hr>
<h2 id='deviance.GeDS'>Deviance method for GeDS, GeDSboost, GeDSgam</h2><span id='topic+deviance.GeDS'></span><span id='topic+deviance.GeDSboost'></span><span id='topic+deviance.GeDSgam'></span>

<h3>Description</h3>

<p>Method for the function <code><a href="stats.html#topic+deviance">deviance</a></code> that allows the user to
extract  the value of the deviance corresponding to a selected GeDS, GeDSboost
or GeDSgam fit from a <code><a href="#topic+GeDS-Class">GeDS-Class</a></code>,
<code><a href="#topic+GeDSboost-Class">GeDSboost-Class</a></code> or <code><a href="#topic+GeDSgam-Class">GeDSgam-Class</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GeDS'
deviance(object, n = 3L, ...)

## S3 method for class 'GeDSboost'
deviance(object, n = 3L, ...)

## S3 method for class 'GeDSgam'
deviance(object, n = 3L, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="deviance.GeDS_+3A_object">object</code></td>
<td>
<p>the <code><a href="#topic+GeDS-class">GeDS-class</a></code>, <code><a href="#topic+GeDSboost-class">GeDSboost-class</a></code> or
<code><a href="#topic+GeDSgam-class">GeDSgam-class</a></code> object from which the deviance should be extracted.</p>
</td></tr>
<tr><td><code id="deviance.GeDS_+3A_n">n</code></td>
<td>
<p>integer value (2, 3 or 4) specifying the order (<code class="reqn">=</code> degree
<code class="reqn">+ 1</code>) of the GeDS/GeDSboost/GeDSgam fit whose deviance should be
extracted. By default equal to <code>3L</code>. Non-integer values will be passed
to the function <code><a href="base.html#topic+as.integer">as.integer</a></code>.</p>
</td></tr>
<tr><td><code id="deviance.GeDS_+3A_...">...</code></td>
<td>
<p>potentially further arguments (required by the definition of the
generic function). These will be ignored, but with a warning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the function <code><a href="stats.html#topic+deviance">deviance</a></code>. As
<code><a href="#topic+GeDS-class">GeDS-class</a></code>, <code><a href="#topic+GeDSboost-class">GeDSboost-class</a></code> and
<code><a href="#topic+GeDSgam-class">GeDSgam-class</a></code> objects contain three different fits (linear,
quadratic and cubic), it is possible to specify the order of the GeDS fit
for which the deviance is required via the input argument <code>n</code>.
</p>


<h3>Value</h3>

<p>A numeric value corresponding to the  deviance of the selected
GeDS/GeDSboost/GeDSgam fit.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+deviance">deviance</a></code> for the standard definition;
<code><a href="#topic+GGeDS">GGeDS</a></code> for examples.
</p>

<hr>
<h2 id='EWmortality'>Death counts in England and Wales</h2><span id='topic+EWmortality'></span>

<h3>Description</h3>

<p>The dataset consists of information about the mortality of the English and
Welsh male population aggregated over the years 2000, 2001 and 2002.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(EWmortality)
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> with 109 entries and 3 variables: <code>Age</code>,
<code>Deaths</code> and <code>Exposure</code>. <code>Exposure</code> is a mid-year estimate of
the population exposed to risk.
</p>

<hr>
<h2 id='f'>Defining the covariates for the spline component in a GeDS formula.</h2><span id='topic+f'></span>

<h3>Description</h3>

<p>In general the GeDS predictor model may include a GeD spline regression
component with respect to one or two independent variables and a parametric
component in which the remaining covariates may enter as additive terms.
</p>
<p>The function <code>f</code> is to be used in the
<code><a href="#topic+formula.GeDS">formula</a></code> argument of <code><a href="#topic+NGeDS">NGeDS</a></code> or
<code><a href="#topic+GGeDS">GGeDS</a></code> in order to specify which independent variables
(covariates) should be included in the GeD spline regression component of the
predictor model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>f(x, xx = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="f_+3A_x">x</code></td>
<td>
<p>numeric vector containing <code class="reqn">N</code> sample values of the covariate
chosen to enter the spline
regression component of the predictor model.</p>
</td></tr>
<tr><td><code id="f_+3A_xx">xx</code></td>
<td>
<p>numeric vector containing <code class="reqn">N</code> sample values for the second
covariate (in case <code><a href="#topic+NGeDS">NGeDS</a></code> is run for two dimensions). It has to
be either <code>NULL</code> (the default) or a vector of size <code class="reqn">N</code>, same as
<code>x</code>.</p>
</td></tr>
<tr><td><code id="f_+3A_...">...</code></td>
<td>
<p>further arguments. As GeDS currently allows for up to two
covariates, specification of further arguments will return an error.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is intended to be used only as part of the
<code><a href="#topic+formula.GeDS">formula</a></code> in a GeDS regression via
<code><a href="#topic+NGeDS">NGeDS</a></code> or <code><a href="#topic+GGeDS">GGeDS</a></code> and not to be called in other
cases by the user.
</p>


<h3>See Also</h3>

<p><a href="#topic+NGeDS">NGeDS</a>; <a href="#topic+GGeDS">GGeDS</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a data sample for the response variable Y and
# the covariates X, reg1, reg2 and off
set.seed(123)
N &lt;- 500
f_1 &lt;- function(x) (10*x/(1+100*x^2))*4+4
X &lt;- sort(runif(N ,min = -2, max = 2))
reg1 &lt;- runif(500, min = -0.1, max = 0.1)
reg2 &lt;- runif(500, min = -0.2, max = 0.2)
off &lt;- runif(500, min = -1, max = 1)
# Specify a model for the mean of Y to include a component non linear
# in X defined by the function f_1 and a linear one in the other covariates
means &lt;- f_1(X) + 2*reg1 + 0.5*reg2 + off
# Add Normal noise to the mean of Y
Y &lt;- rnorm(N, means, sd = 0.1)

# Specify a formula that will be used to model Y as a
# function of X, reg1, reg2 and off.
# The covariate X is for the spline component modeled as GeDS,
# reg1 and reg2 enter linearly, off is an offset, i.e. no coefficient
# will be estimated for it
formula &lt;- Y ~ f(X) + reg1 + reg2 + offset(off)

# Fit a GeDS model specified in formula using NGeDS
(Gmod &lt;- NGeDS(formula, beta = 0.6, phi = 0.995, Xextr = c(-2,2)))


</code></pre>

<hr>
<h2 id='formula.GeDS'>Formula for the predictor model</h2><span id='topic+formula.GeDS'></span>

<h3>Description</h3>

<p>A description of the structure of the predictor model fitted using
<code><a href="#topic+NGeDS">NGeDS</a></code> or <code><a href="#topic+GGeDS">GGeDS</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GeDS'
formula(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="formula.GeDS_+3A_x">x</code></td>
<td>
<p>fitted <code><a href="#topic+GeDS-class">GeDS-class</a></code> object, produced by 
<code><a href="#topic+NGeDS">NGeDS</a></code> or <code><a href="#topic+GGeDS">GGeDS</a></code>, from which the predictor model
<code><a href="stats.html#topic+formula">formula</a></code> should be extracted.</p>
</td></tr>
<tr><td><code id="formula.GeDS_+3A_...">...</code></td>
<td>
<p>unused in this case.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In GeDS GNM (GLM) regression, implemented with <code><a href="#topic+NGeDS">NGeDS</a></code> and
<code><a href="#topic+GGeDS">GGeDS</a></code>, the mean of the response variable, correspondingly
transformed through an appropriate link function, is modeled using a
potentially multivariate predictor model. The latter comprises two components:
a GeD variable-knot spline regression involving up to two of the independent
variables, and a parametric component for the remaining independent variables.
The formula defines the structure of this potentially multivariate predictor.
</p>
<p>The formulae that are input in <code><a href="#topic+NGeDS">NGeDS</a></code> and <code><a href="#topic+GGeDS">GGeDS</a></code>
are similar to those input in <code><a href="stats.html#topic+lm">lm</a></code> or
<code><a href="stats.html#topic+glm">glm</a></code> except that the function <code><a href="#topic+f">f</a></code> should be
specified in order to identify which of the covariates enter the GeD spline
regression part of the predictor model. For example, if the predictor model
is univariate and it links the transformed mean of <code>y</code> to <code>x1</code>,
the predictor has only a GeD spline component and the
<code><a href="stats.html#topic+formula">formula</a></code> should be in the form <code>y ~ f(x1)</code>.
</p>
<p>As noted, there may be additional independent variables, <code>x2</code>,
<code>x3</code>, ... which may enter linearly into the parametric component of the
predictor model and not be part of the GeD spline regression component. For
example one may use the formula <code>y ~ f(x1) + x2 + x3</code> which assumes a
spline regression only between the transformed mean of <code>y</code> and <code>x1</code>,
while <code>x2</code> and <code>x3</code> enter the predictor model linearly.
</p>
<p>Both function <code><a href="#topic+NGeDS">NGeDS</a></code> and function <code><a href="#topic+GGeDS">GGeDS</a></code>, generate
bivariate GeDS regression models. Therefore, if the functional dependence of
the mean of the response variable <code>y</code> on <code>x1</code> and <code>x2</code> needs
to be jointly modeled and there are no other covariates, the formula for the
corresponding two dimensional predictor model should be specified as
<code>y ~ f(x1,x2)</code>.
</p>
<p>Within the argument <code>formula</code>, similarly as in other <span class="rlang"><b>R</b></span> functions, it is
possible to specify one or more offset variables, i.e. known terms with fixed
regression coefficients equal to 1. These terms should be identified via the
function <code><a href="stats.html#topic+offset">offset</a></code>.
</p>

<hr>
<h2 id='GeDS-class'>GeDS Class</h2><span id='topic+GeDS-class'></span><span id='topic+GeDS-Class'></span>

<h3>Description</h3>

<p>A fitted GeDS object returned by the function <code><a href="#topic+NGeDS">NGeDS</a></code> or
<code><a href="#topic+GGeDS">GGeDS</a></code>, inheriting the methods for class <code>"GeDS"</code>.
Methods for functions <code>coef</code>, <code>knots</code>, <code>print</code>, <code>predict</code>,
<code>plot</code>, and <code>lines</code> are available.
</p>


<h3>Slots</h3>


<dl>
<dt><code>Type</code></dt><dd><p>Character string indicating the type of regression performed.
This can be <code>"LM - Univ"</code>/<code>"LM - Biv"</code> or
<code>"GLM - Univ"</code>/<code>"GLM - Biv"</code>, respectively corresponding to Normal
univariate/bivariate GeDS (implemented by <code><a href="#topic+NGeDS">NGeDS</a></code>), and to
generalized (GNM-GLM) univariate/bivariate GeDS (implemented by
<code><a href="#topic+GGeDS">GGeDS</a></code>).</p>
</dd>
<dt><code>Linear.Knots</code></dt><dd><p>vector containing the locations of the knots of the
second order GeD spline fit produced at stage A.</p>
</dd>
<dt><code>Quadratic.Knots</code></dt><dd><p>vector containing the locations of the knots of the
third order GeD spline fit produced in stage B.</p>
</dd>
<dt><code>Cubic.knots</code></dt><dd><p>Vector containing the locations of the knots of the fourth
order GeD spline fit produced in stage B.</p>
</dd>
<dt><code>Dev.Linear</code></dt><dd><p>deviance of the second order GeD spline fit, produced in
stage A.</p>
</dd>
<dt><code>Dev.Quadratic</code></dt><dd><p>deviance of the third order GeD spline fit, produced in
stage B.</p>
</dd>
<dt><code>Dev.Cubic</code></dt><dd><p>deviance of the fourth order GeD spline fit, produced in
stage B.</p>
</dd>
<dt><code>RSS</code></dt><dd><p>vector containing the deviances of the second order spline
fits computed at each stage A's GeDS iteration.</p>
</dd>
<dt><code>Linear</code></dt><dd><p>list containing the results from running <code><a href="#topic+SplineReg">SplineReg</a></code>
function to fit the second order spline fit of stage A.</p>
</dd>
<dt><code>Quadratic</code></dt><dd><p>list containing the results from running <code><a href="#topic+SplineReg">SplineReg</a></code>
function used to fit the third order spline fit in stage B.</p>
</dd>
<dt><code>Cubic</code></dt><dd><p>list containing the results from a <code><a href="#topic+SplineReg">SplineReg</a></code>
function used to fit the fourth order spline fit in stage B.</p>
</dd>
<dt><code>Stored</code></dt><dd><p>Matrix containing the knot locations estimated at each iteration
of stage A.</p>
</dd>
<dt><code>Args</code></dt><dd><p>list containing the input arguments passed on the
<code><a href="#topic+Fitters">Fitters</a></code> functions.</p>
</dd>
<dt><code>Call</code></dt><dd><p><code>call</code> to the <code><a href="#topic+Fitters">Fitters</a></code> functions.</p>
</dd>
<dt><code>Nintknots</code></dt><dd><p>the final number of internal knots of the second order GeD
spline fit produced in stage A.</p>
</dd>
<dt><code>iters</code></dt><dd><p>number of iterations performed during stage A of the GeDS fitting
procedure.</p>
</dd>
<dt><code>Guesses</code></dt><dd><p>initial values for the coefficients used at each iteration of
stage A in order to estimate the spline coefficients. Since the initial
values are used only in the IRLS procedure, this slot is empty if the object
is not created by <code><a href="#topic+GGeDS">GGeDS</a></code> or <code><a href="#topic+GenUnivariateFitter">GenUnivariateFitter</a></code>
functions.</p>
</dd>
<dt><code>Coefficients</code></dt><dd><p>matrix containing the fitted coefficients of the GeD
spline regression component and the parametric component at each iteration
of stage A.</p>
</dd>
<dt><code>deviance</code></dt><dd><p>vector containing the deviances of the second order spline
fits computed at each IRLS iteration in stage A. Since the IRLS procedure is
used only in <code><a href="#topic+GGeDS">GGeDS</a></code> or <code><a href="#topic+GenUnivariateFitter">GenUnivariateFitter</a></code>, this
slot is empty if the object is not created by one of these functions.</p>
</dd>
<dt><code>iterIrls</code></dt><dd><p>vector containing the numbers of IRLS iterations for all
iterations of stage A cumulatively. Since the IRLS procedure is used only in
<code><a href="#topic+GGeDS">GGeDS</a></code> or <code><a href="#topic+GenUnivariateFitter">GenUnivariateFitter</a></code>, this slot is empty
if the object is not created by one of these functions.</p>
</dd>
<dt><code>stopinfo</code></dt><dd><p>list of values providing information related to the stopping
rule of stage A of GeDS. The sub-slots of <code>stopinfo</code> are <code>phis</code>,
<code>phis_star</code>, <code>oldintc</code> and <code>oldslp</code>. The sub-slot <code>phis</code>
is a vector containing the values of the ratios of deviances (or the
difference of deviances if the <code>LR</code> stopping rule was chosen). The
sub-slots <code>phis_star</code>, <code>oldintc</code> and <code>oldslp</code> are non-empty
slots if the <code>SR</code> stopping rule was chosen. These respectively contain
the values at each iteration of stage A of <code class="reqn">\hat{\phi}_{\kappa}</code>,
<code class="reqn">\hat{\gamma}_0</code> and <code class="reqn">\hat{\gamma}_1</code>. See Dimitrova et al. (2023)
for further details on these parameters.</p>
</dd>
<dt><code>Formula</code></dt><dd><p>the model <code><a href="#topic+formula.GeDS">formula</a></code>.</p>
</dd>
<dt><code>extcall</code></dt><dd><p><code>call</code> to the <code><a href="#topic+NGeDS">NGeDS</a></code> or <code><a href="#topic+GGeDS">GGeDS</a></code>
functions.</p>
</dd>
<dt><code>terms</code></dt><dd><p><code>terms</code> object containing information on the model frame.</p>
</dd>
</dl>


<h3>References</h3>

<p>Dimitrova, D. S., Kaishev, V. K., Lattuada, A. and Verrall, R. J.  (2023).
Geometrically designed variable knot splines in generalized (non-)linear
models.
<em>Applied Mathematics and Computation</em>, <strong>436</strong>. <br />
DOI: <a href="https://doi.org/10.1016/j.amc.2022.127493">doi:10.1016/j.amc.2022.127493</a>
</p>

<hr>
<h2 id='GeDSboost-class'>GeDSboost Class</h2><span id='topic+GeDSboost-class'></span><span id='topic+GeDSboost-Class'></span>

<h3>Description</h3>

<p>A fitted GeDSboost object returned by the function <code><a href="#topic+NGeDSboost">NGeDSboost</a></code>,
inheriting the methods for class <code>"GeDSboost"</code>. Methods for functions
<code>coef</code>, <code>knots</code>, <code>plot</code>, <code>print</code>, <code>predict</code>,
<code>visualize_boosting</code>, and <code>bl_imp</code> are available.
</p>


<h3>Slots</h3>


<dl>
<dt><code>extcall</code></dt><dd><p>call to the <code><a href="#topic+NGeDSboost">NGeDSboost</a></code> function.</p>
</dd>
<dt><code>formula</code></dt><dd><p>a formula object representing the model to be fitted.</p>
</dd>
<dt><code>args</code></dt><dd><p>a list containing the arguments passed to the <code><a href="#topic+NGeDSboost">NGeDSboost</a></code>
function. This list includes:
</p>

<ul>
<li> <p><code>response</code>: <code>data.frame</code> containing the response variable
observations.
</p>
</li>
<li> <p><code>predictors</code>: <code>data.frame</code> containing the observations
corresponding to the predictor variables included in the model.
</p>
</li>
<li> <p><code>base_learners</code>: description of model's base learners.
</p>
</li>
<li> <p><code>family</code>: the statistical family; the possible options are
</p>

<ul>
<li> <p><code>mboost::Binomial(type = c("adaboost", "glm"),
  link = c("logit", "probit", "cloglog", "cauchit", "log"), ...)</code>
</p>
</li>
<li> <p><code>mboost::Gaussian()</code>
</p>
</li>
<li> <p><code>mboost::Poisson()</code>
</p>
</li>
<li> <p><code>mboost::GammaReg(nuirange = c(0, 100))</code>
</p>
</li></ul>

<p>Other <code>mboost</code> families may be suitable; however, these have not yet
been thoroughly tested and are therefore not recommended for use.
</p>
</li>
<li> <p><code>initial_learner</code>: if <code>TRUE</code> a <code><a href="#topic+NGeDS">NGeDS</a></code> or
<code><a href="#topic+GGeDS">GGeDS</a></code> fit was used as the initial learner; otherwise, the
empirical risk minimizer corresponding to the selected <code>family</code>
was employed.
</p>
</li>
<li> <p><code>int.knots_init</code>: if <code>initial_learner = TRUE</code>, this
corresponds to the maximum number of internal knots set in the
<code><a href="#topic+NGeDS">NGeDS</a></code>/<code><a href="#topic+GGeDS">GGeDS</a></code> function before the initial learner
fit.
</p>
</li>
<li> <p><code>shrinkage</code>: shrinkage/step-length/learning rate utilized
throughout the boosting iterations.
</p>
</li>
<li> <p><code>normalize_data</code>: if <code>TRUE</code>, then response and predictors
were standardized before running the FGB algorithm.
</p>
</li>
<li> <p><code>X_mean</code>: mean of the predictor variables (only if
<code>normalize_data = TRUE</code>, otherwise this is <code>NULL</code>).
</p>
</li>
<li> <p><code>X_sd</code>: standard deviation of the predictors (only if
<code>normalize_data = TRUE</code>, otherwise this is <code>NULL</code>).
</p>
</li>
<li> <p><code>Y_mean</code>: mean of the response variable (only if
<code>normalize_data = TRUE</code>, otherwise this is <code>NULL</code>).
</p>
</li>
<li> <p><code>Y_sd</code>: standard deviation of the response variable (only if
<code>normalize_data = TRUE</code>, otherwise this is <code>NULL</code>).
</p>
</li></ul>
</dd>
<dt><code>models</code></dt><dd><p>A list containing the 'model' generated at each boosting
iteration. Each of these <code>models</code> includes:
</p>

<ul>
<li> <p><code>best_bl</code>: fit of the base learner that minimized the residual
sum of squares (RSS) in fitting the gradient at the <em>i</em>-th boosting
iteration.
</p>
</li>
<li> <p><code>Y_hat</code>: model fitted values at the <em>i</em>-th boosting
iteration.
</p>
</li>
<li> <p><code>base_learners</code>: knots and polynomial coefficients for each of the
base-learners at the <em>i</em>-th boosting iteration.  
</p>
</li></ul>
</dd>
<dt><code>final_model</code></dt><dd><p>A list detailing the final GeDSboost model after the
gradient descent algorithm is run:
</p>

<ul>
<li> <p><code>model_name</code>: the boosting iteration corresponding to the final
model.
</p>
</li>
<li> <p><code>DEV</code>: deviance of the final model.
</p>
</li>
<li> <p><code>Y_hat</code>: fitted values.
</p>
</li>
<li> <p><code>base_learners</code>: a list containing, for each base-learner, the
intervals defined by the piecewise linear fit and its corresponding
polynomial coefficients. It also includes the knots corresponding to each
order fit, which result from computing the corresponding averaging knot
location. See Kaishev et al. (2016) for details. If the number of internal
knots of the final linear fit is less than $n-1$, the averaging knot location
is not computed.
</p>
</li>
<li> <p><code>Linear.Fit</code>/<code>Quadratic.Fit</code>/<code>Cubic.Fit</code>: final linear,
quadratic and cubic fits in B-spline form. These include the same elements
as <code>Linear</code>, <code>Quadratic</code> and <code>Cubic</code> in a <code><a href="#topic+GeDS-class">GeDS-class</a></code>
object (see <code><a href="#topic+SplineReg">SplineReg</a></code> for details).
</p>
</li></ul>
</dd>
<dt><code>predictions</code></dt><dd><p>a list containing the predicted values obtained for each of
the fits (linear, quadratic and cubic).</p>
</dd>
<dt><code>internal_knots</code></dt><dd><p>a list detailing the internal knots obtained for each of
the different order fits (linear, quadratic, and cubic).</p>
</dd>
</dl>


<h3>References</h3>

<p>Dimitrova, D. S., Kaishev, V. K., Lattuada, A. and Verrall, R. J.  (2023).
Geometrically designed variable knot splines in generalized (non-)linear
models.
<em>Applied Mathematics and Computation</em>, <strong>436</strong>. <br />
DOI: <a href="https://doi.org/10.1016/j.amc.2022.127493">doi:10.1016/j.amc.2022.127493</a>
</p>
<p>Dimitrova, D. S., Kaishev, V. K. and Saenz Guillen, E. L. (2025).
<span class="pkg">GeDS</span>: An R Package for Regression, Generalized Additive
Models and Functional Gradient Boosting, based on Geometrically Designed
(GeD) Splines. <em>Manuscript submitted for publication.</em>
</p>

<hr>
<h2 id='GeDSgam-class'>GeDSgam Class</h2><span id='topic+GeDSgam-class'></span><span id='topic+GeDSgam-Class'></span>

<h3>Description</h3>

<p>A fitted GeDSgam object returned by the function <code><a href="#topic+NGeDSgam">NGeDSgam</a></code>,
inheriting the methods for class <code>"GeDSgam"</code>. Methods for functions
<code>coef</code>, <code>knots</code>, <code>plot</code>, <code>print</code> and <code>predict</code> are 
available.
</p>


<h3>Slots</h3>


<dl>
<dt><code>extcall</code></dt><dd><p>call to the <code><a href="#topic+NGeDSgam">NGeDSgam</a></code> function.</p>
</dd>
<dt><code>formula</code></dt><dd><p>a formula object representing the model to be fitted.</p>
</dd>
<dt><code>args</code></dt><dd><p>a list containing the arguments passed to the <code><a href="#topic+NGeDSgam">NGeDSgam</a></code>
function. This list includes:
</p>

<ul>
<li> <p><code>response</code>: <code>data.frame</code> containing the response variable
observations.
</p>
</li>
<li> <p><code>predictors</code>: <code>data.frame</code> containing the corresponding 
observations of the predictor variables included in the model.
</p>
</li>
<li> <p><code>base_learners</code>: description of the model's base learners
('smooth functions').
</p>
</li>
<li> <p><code>family</code>: the statistical family. The possible options are
</p>

<ul>
<li> <p><code>binomial(link = "logit", "probit", "cauchit", "log", "cloglog")</code>
</p>
</li>
<li> <p><code>gaussian(link = "identity", "log", "inverse")</code>
</p>
</li>
<li> <p><code>Gamma(link = "inverse", "identity", "log")</code>
</p>
</li>
<li> <p><code>inverse.gaussian(link = "1/mu^2", "inverse", "identity", "log")</code>
</p>
</li>
<li> <p><code>poisson(link = "log", "identity", "sqrt")</code>
</p>
</li>
<li> <p><code>quasi(link = "identity", variance = "constant")</code>
</p>
</li>
<li> <p><code>quasibinomial(link = "logit", "probit", "cloglog", "identity", "inverse", "log", "1/mu^2", "sqrt")</code>
</p>
</li>
<li> <p><code>quasipoisson(llink = "logit", "probit", "cloglog", "identity", "inverse", "log", "1/mu^2", "sqrt")</code>   
</p>
</li></ul>

</li>
<li> <p><code>normalize_data</code>: if <code>TRUE</code>, then response and predictors
were standardized before running the local-scoring algorithm.
</p>
</li>
<li> <p><code>X_mean</code>: mean of the predictor variables (only if
<code>normalize_data = TRUE</code>).
</p>
</li>
<li> <p><code>X_sd</code>: standard deviation of the predictors (only if
<code>normalize_data = TRUE</code>, else is <code>NULL</code>).
</p>
</li>
<li> <p><code>Y_mean</code>: mean of the response variable (only if
<code>normalize_data = TRUE</code>, else is <code>NULL</code>).
</p>
</li>
<li> <p><code>Y_sd</code>: standard deviation of the response variable (only if
<code>normalize_data = TRUE</code>, else is <code>NULL</code>).
</p>
</li></ul>
</dd>
<dt><code>final_model</code></dt><dd><p>A list detailing the final GeDSgam model selected after
running the local scoring algorithm. The chosen model minimizes deviance
across all models generated by each local-scoring iteration. This list
includes:
</p>

<ul>
<li> <p><code>model_name</code>: local-scoring iteration that yielded the &quot;best&quot;
model. Note that when <code>family = "gaussian"</code>, it will always correspond
to <code>iter1</code>, as only one local-scoring iteration is conducted in this
scenario. This occurs because, with <code>family = "gaussian"</code>, the
algorithm is tantamount to directly implementing backfitting.
</p>
</li>
<li> <p><code>DEV</code>: the deviance for the fitted predictor model, defined as
in Dimitrova et al. (2023), which for <code>family = "gaussian"</code> coincides
with the Residual Sum of Squares.
</p>
</li>
<li> <p><code>Y_hat</code>: fitted values.
</p>

<ul>
<li> <p><code>eta</code>: additive predictor.
</p>
</li>
<li> <p><code>mu</code>: vector of means.
</p>
</li>
<li> <p><code>z</code>: adjusted dependent variable.      
</p>
</li></ul>

</li>
<li> <p><code>base_learners</code>: a list containing, for each base-learner, the
corresponding linear fit piecewise polynomial coefficients. It includes the
knots for each order fit, resulting from computing the averaging knot
location. Although if the number of internal knots of the final linear fit
is less than $n-1$, the averaging knot location is not computed.
</p>
</li>
<li> <p><code>Linear.Fit</code>: final model linear fit in B-spline form.
See <code><a href="#topic+SplineReg">SplineReg</a></code> for details.
</p>
</li>
<li> <p><code>Quadratic.Fit</code>: quadratic fit obtained via Schoenberg variation
diminishing spline approximation. See <code><a href="#topic+SplineReg">SplineReg</a></code> for details.
</p>
</li>
<li> <p><code>Cubic.Fit</code>: cubic fit obtained via Schoenberg variation
diminishing spline approximation. See <code><a href="#topic+SplineReg">SplineReg</a></code> for details.
</p>
</li></ul>
</dd>
<dt><code>predictions</code></dt><dd><p>A list containing the predicted values obtained for each of
the fits (linear, quadratic, and cubic). Each of the predictions contains
both the additive predictor <code>eta</code> and the vector of means <code>mu</code>.</p>
</dd>
<dt><code>internal_knots</code></dt><dd><p>A list detailing the internal knots obtained for the fits
of different order (linear, quadratic, and cubic).</p>
</dd>
</dl>


<h3>References</h3>

<p>Dimitrova, D. S., Kaishev, V. K., Lattuada, A. and Verrall, R. J.  (2023).
Geometrically designed variable knot splines in generalized (non-)linear
models.
<em>Applied Mathematics and Computation</em>, <strong>436</strong>. <br />
DOI: <a href="https://doi.org/10.1016/j.amc.2022.127493">doi:10.1016/j.amc.2022.127493</a>
</p>
<p>Dimitrova, D. S., Kaishev, V. K. and Saenz Guillen, E. L. (2025).
<span class="pkg">GeDS</span>: An R Package for Regression, Generalized Additive
Models and Functional Gradient Boosting, based on Geometrically Designed
(GeD) Splines. <em>Manuscript submitted for publication.</em>
</p>

<hr>
<h2 id='GGeDS'>Generalized Geometrically Designed Spline regression estimation</h2><span id='topic+GGeDS'></span>

<h3>Description</h3>

<p><code>GGeDS</code> constructs a Geometrically Designed (univariate or bivariate)
variable knots spline regression model for the predictor in the context of
Generalized (Non-)Linear Models. This is referred to as a GeDS model for a
response with a distribution from the Exponential Family.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GGeDS(
  formula,
  family = gaussian(),
  data,
  weights,
  beta,
  phi = 0.99,
  min.intknots,
  max.intknots,
  q = 2L,
  Xextr = NULL,
  Yextr = NULL,
  show.iters = FALSE,
  stoptype = "SR",
  higher_order = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GGeDS_+3A_formula">formula</code></td>
<td>
<p>a description of the structure of the predictor model to be
fitted, including the dependent and independent variables. See
<code><a href="#topic+formula.GeDS">formula</a></code> for details.</p>
</td></tr>
<tr><td><code id="GGeDS_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to be
used in the model. This can be a character string naming a family function
(e.g. <code>"gaussian"</code>), the family function itself (e.g.
<code><a href="stats.html#topic+gaussian">gaussian</a></code>) or the result of a call to a family function
(e.g. <code>gaussian()</code>). See <a href="stats.html#topic+family">family</a> for details on family
functions.</p>
</td></tr>
<tr><td><code id="GGeDS_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment containing the
variables of the predictor model. If the formula variables are not found in
<code>data</code>, they are taken from <code>environment(formula)</code>, typically the
environment from which <code>GGeDS</code> is called.</p>
</td></tr>
<tr><td><code id="GGeDS_+3A_weights">weights</code></td>
<td>
<p>an optional vector of &lsquo;prior weights&rsquo; to be put on the
observations during the fitting process in case the user requires weighted GeDS
fitting. It is <code>NULL</code> by default.</p>
</td></tr>
<tr><td><code id="GGeDS_+3A_beta">beta</code></td>
<td>
<p>numeric parameter in the interval <code class="reqn">[0,1]</code> tuning the knot
placement in stage A of GeDS. See details below.</p>
</td></tr>
<tr><td><code id="GGeDS_+3A_phi">phi</code></td>
<td>
<p>numeric parameter in the interval <code class="reqn">[0,1]</code> specifying the
threshold for the stopping rule  (model selector) in stage A of GeDS. See
also <code>stoptype</code> and details below.</p>
</td></tr>
<tr><td><code id="GGeDS_+3A_min.intknots">min.intknots</code></td>
<td>
<p>optional parameter allowing the user to set a minimum
number of internal knots to be fit in stage A. By default equal to zero.</p>
</td></tr>
<tr><td><code id="GGeDS_+3A_max.intknots">max.intknots</code></td>
<td>
<p>optional parameter allowing the user to set a maximum
number of internal knots to be added by the stage A's GeDS estimation
algorithm. By default equal to the number of knots for the saturated GeDS
model (i.e. <code class="reqn">N-2</code>, where <code class="reqn">N</code> is the number of observations).</p>
</td></tr>
<tr><td><code id="GGeDS_+3A_q">q</code></td>
<td>
<p>numeric parameter which allows to fine-tune the stopping rule of
stage A of GeDS, by default equal to 2. See details below.</p>
</td></tr>
<tr><td><code id="GGeDS_+3A_xextr">Xextr</code></td>
<td>
<p>numeric vector of 2 elements representing the left-most and
right-most limits of the interval embedding the observations of the
independent variable. See details.</p>
</td></tr>
<tr><td><code id="GGeDS_+3A_yextr">Yextr</code></td>
<td>
<p>numeric vector of 2 elements representing the left-most and
right-most limits of the interval embedding the observations of the second
independent variable (if bivariate GeDS is run). See details.</p>
</td></tr>
<tr><td><code id="GGeDS_+3A_show.iters">show.iters</code></td>
<td>
<p>logical variable indicating whether or not to print
information of the fit at each GeDS iteration. By default equal to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="GGeDS_+3A_stoptype">stoptype</code></td>
<td>
<p>a character string indicating the type of GeDS stopping rule
to be used. It should be either one of <code>"SR"</code>, <code>"RD"</code> or 
<code>"LR"</code>, partial match allowed. See details below.</p>
</td></tr>
<tr><td><code id="GGeDS_+3A_higher_order">higher_order</code></td>
<td>
<p>a logical that defines whether to compute the higher
order fits (quadratic and cubic) after stage A is run. Default is
<code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The  <code>GGeDS</code> function extends the GeDS methodology, developed by
Kaishev et al. (2016) and implemented in the <code><a href="#topic+NGeDS">NGeDS</a></code> function
for the Normal case, to the more general GNM (GLM) context, allowing for the
response to have any distribution from the Exponential Family. Under the
GeDS-GNM approach the (non-)linear predictor is viewed as a spline with 
variable knots that are estimated along with the regression coefficients and
the order of the spline, using a two stage procedure. In stage A, a linear
variable-knot spline is fitted to the data applying iteratively re-weighted
least squares (see <code><a href="#topic+IRLSfit">IRLSfit</a></code> function). In stage B, a Schoenberg
variation diminishing spline approximation to the fit from stage A is
constructed, thus simultaneously producing spline fits of order 2, 3 and 4,
all of which are included in the output, a <code><a href="#topic+GeDS-Class">GeDS-Class</a></code> object.
A detailed description of the underlying algorithm can be found in
Dimitrova et al. (2023).
</p>
<p>As noted in <code><a href="#topic+formula.GeDS">formula</a></code>, the argument <code>formula</code>
allows the user to specify predictor models with two components: a spline
regression (non-parametric) component involving part of the independent
variables identified through the function <code>f</code>, and an optional parametric
component involving the remaining independent variables. For <code>GGeDS</code>
only one or two independent variables are allowed for the spline component and
arbitrary many independent variables for the parametric component of the
predictor. Failure to specify the independent variable for the  spline
regression component through the function <code>f</code> will return an error.
See <code><a href="#topic+formula.GeDS">formula</a></code>.
</p>
<p>Within the argument <code>formula</code>, similarly as in other <span class="rlang"><b>R</b></span> functions, it is
possible to specify one or more offset variables, i.e. known terms with fixed
regression coefficients equal to 1. These terms should be identified via the
function <code><a href="stats.html#topic+offset">offset</a></code>.
</p>
<p>The parameter <code>beta</code> tunes the placement of a new knot in stage A of the
algorithm. At the beginning of each GeDS iteration, a second-order spline is 
fitted to the data. As follows, the 'working' residuals
(see <code><a href="#topic+IRLSfit">IRLSfit</a></code>) are computed and grouped by their sign. A new knot
is then placed at a location defined by the cluster that maximizes a certain
measure. This measure is defined as a weighted linear combination of the range
of the independent variable at each cluster and the  mean of the
absolute residuals within it. The parameter <code>beta</code> determines the
weights in this measure correspondingly: <code>beta</code> and <code>1 - beta</code>.
The higher <code>beta</code> is, the more weight is put to the mean of the
residuals and the less to the range of their corresponding x-values (see
Kaishev et al., 2016, for further details).
</p>
<p>The default values of <code>beta</code> are <code>beta = 0.5</code> if the response is
assumed to be Gaussian, <code>beta = 0.2</code> if it is Poisson (or Quasipoisson),
while if it is Binomial, Quasibinomial or Gamma <code>beta = 0.1</code>, which
reflect our experience of running GeDS for different underlying functional
dependencies.
</p>
<p>The argument <code>stoptype</code> allows to choose between three alternative
stopping rules for the knot selection in stage A of GeDS: <code>"RD"</code>,
that stands for <em>Ratio of Deviances</em>; <code>"SR"</code>, that stands for
<em>Smoothed Ratio</em> of deviances; and <code>"LR"</code>, that stands for
<em>Likelihood Ratio</em>. The latter is based on the difference of deviances
rather than on their ratio as in the case of <code>"RD"</code> and <code>"SR"</code>.
Therefore <code>"LR"</code> can be viewed as a log likelihood ratio test performed
at each iteration of the knot placement. In each of these cases the
corresponding stopping criterion is compared with a threshold value 
<code>phi</code> (see below).
</p>
<p>The argument <code>phi</code> provides a threshold value required for the stopping
rule to exit the knot placement in stage A of GeDS. The higher the value of
<code>phi</code>, the more knots are added under the <code>"RD"</code> and <code>"SR"</code>
stopping rules contrary to the case of the stopping rule <code>"LR"</code> where
the lower <code>phi</code> is, more knots are included in the spline regression.
Further details for each of the three alternative stopping rules can be found
in Dimitrova et al. (2023).
</p>
<p>The argument <code>q</code> is an input parameter that fine-tunes the stopping rule
in stage A. It specifies the number of consecutive iterations over which the
deviance must exhibit stable convergence to terminate knot placement in stage
A. Specifically, under any of the rules <code>"RD"</code>, <code>"SR"</code> or
<code>"LR"</code> the deviance at the current iteration is compared to the deviance
computed <code>q</code> iterations before, i.e. before
introducing the last <code>q</code> knots.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+GeDS-Class">GeDS-Class</a></code> object, i.e. a list of items that
summarizes  the main details of the fitted GeDS regression. See
<code><a href="#topic+GeDS-Class">GeDS-Class</a></code> for details. Some S3 methods are available in order
to make these objects tractable, such as <code><a href="#topic+coef.GeDS">coef</a></code>,
<code><a href="#topic+deviance.GeDS">deviance</a></code>, <code><a href="#topic+knots.GeDS">knots</a></code>,
<code><a href="#topic+predict.GeDS">predict</a></code> and <code><a href="#topic+print.GeDS">print</a></code>
as well as S4 methods for <code><a href="#topic+lines.GeDS">lines</a></code> and
<code><a href="#topic+plot.GeDS">plot</a></code>.
</p>


<h3>References</h3>

<p>Kaishev, V.K., Dimitrova, D.S., Haberman, S. and Verrall, R.J. (2016).
Geometrically designed, variable knot regression splines.
<em>Computational Statistics</em>, <strong>31</strong>, 1079&ndash;1105. <br />
DOI: <a href="https://doi.org/10.1007/s00180-015-0621-7">doi:10.1007/s00180-015-0621-7</a>
</p>
<p>Dimitrova, D. S., Kaishev, V. K., Lattuada, A. and Verrall, R. J.  (2023).
Geometrically designed variable knot splines in generalized (non-)linear
models.
<em>Applied Mathematics and Computation</em>, <strong>436</strong>. <br />
DOI: <a href="https://doi.org/10.1016/j.amc.2022.127493">doi:10.1016/j.amc.2022.127493</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NGeDS">NGeDS</a></code>; <code><a href="#topic+GeDS-Class">GeDS-Class</a></code>; S3 methods such as
<code><a href="#topic+coef.GeDS">coef.GeDS</a></code>, <code><a href="#topic+deviance.GeDS">deviance.GeDS</a></code>, 
<code><a href="#topic+knots.GeDS">knots.GeDS</a></code>, <code><a href="#topic+print.GeDS">print.GeDS</a></code> and
<code><a href="#topic+predict.GeDS">predict.GeDS</a></code>; <code><a href="#topic+Integrate">Integrate</a></code> and <code><a href="#topic+Derive">Derive</a></code>;
<code><a href="#topic+PPolyRep">PPolyRep</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>######################################################################
# Generate a data sample for the response variable Y and the covariate X
# assuming Poisson distributed error and log link function
# See section 4.1 in Dimitrova et al. (2023)
set.seed(123)
N &lt;- 500
f_1 &lt;- function(x) (10*x/(1+100*x^2))*4+4
X &lt;- sort(runif(N, min = -2, max = 2))
# Specify a model for the mean of Y to include only a component
# non-linear in X, defined by the function f_1
means &lt;- exp(f_1(X))

#############
## POISSON ##
#############
# Generate Poisson distributed Y according to the mean model
Y &lt;- rpois(N, means)

# Fit a Poisson GeDS regression using GGeDS
(Gmod &lt;- GGeDS(Y ~ f(X), beta = 0.2, phi = 0.99, q = 2, family = poisson(),
               Xextr = c(-2,2)))
# Plot the quadratic and cubic GeDS fits
plot(X, log(Y), xlab = "x", ylab = expression(f[1](x)))
lines(X, sapply(X, f_1), lwd = 2)
lines(Gmod, n = 3, col = "red")
lines(Gmod, n = 4, col = "blue", lty = 2)
legend("topleft",
       legend = expression(f[1](x), "Quadratic", "Cubic"),
       col = c("black", "red", "blue"),
       lty = c(1, 1, 2),
       lwd = c(2, 1, 1),
       bty = "n")

# Generate GeDS prediction at X=0, first on the response scale and then on
# the predictor scale
predict(Gmod, n = 3, newdata = data.frame(X = 0))
predict(Gmod, n = 3, newdata = data.frame(X = 0), type = "link")

# Apply some of the other available methods, e.g.
# knots, coefficients and deviance extractions for the
# quadratic GeDS fit
knots(Gmod)
coef(Gmod)
deviance(Gmod)

# the same but for the cubic GeDS fit
knots(Gmod, n = 4)
coef(Gmod, n = 4)
deviance(Gmod, n = 4)

###########
## GAMMA ##
###########
# Generate Gamma distributed Y according to the mean model
Y &lt;- rgamma(N, shape = means, rate = 0.1)
# Fit a Gamma GeDS regression using GGeDS
Gmod &lt;- GGeDS(Y ~ f(X), beta = 0.1, phi = 0.99, q = 2, family = Gamma(log),
              Xextr = c(-2,2))
plot(Gmod, f = function(x) exp(f_1(x))/0.1)

##############
## BINOMIAL ##
##############
# Generate Binomial distributed Y according to the mean model
eta &lt;- f_1(X) - 4
means &lt;- exp(eta)/(1+exp(eta))
Y &lt;- rbinom(N, size = 50, prob = means) / 50
# Fit a Binomial GeDS regression using GGeDS
Gmod &lt;- GGeDS(Y ~ f(X), beta = 0.1, phi = 0.99, family = "quasibinomial",
              Xextr = c(-2,2))
plot(Gmod, f = function(x) exp(f_1(x) - 4)/(1 + exp(f_1(x) - 4)))


##########################################
# A real data example
# See Dimitrova et al. (2023), Section 4.2

data("coalMining")
(Gmod2 &lt;- GGeDS(formula = accidents ~ f(years), beta = 0.1, phi = 0.98,
                 family = poisson(), data = coalMining))
(Gmod3 &lt;- GGeDS(formula = accidents ~ f(years), beta = 0.1, phi = 0.985,
                 family = poisson(), data = coalMining))
plot(coalMining$years, coalMining$accidents, type = "h", xlab = "Years",
     ylab = "Accidents")
lines(Gmod2, tr = exp, n = 4, col = "red")
lines(Gmod3, tr = exp, n = 4, col = "blue", lty = 2)
legend("topright", c("phi = 0.98","phi = 0.985"), col = c("red", "blue"),
       lty=c(1, 2))


## Not run: 
##########################################
# The same regression in the example of GeDS
# but assuming Gamma and Poisson responses
# See Dimitrova et al. (2023), Section 4.2

data('BaFe2As2')
(Gmod4 &lt;- GGeDS(intensity ~ f(angle), data = BaFe2As2, beta = 0.6, phi = 0.995, q = 3,
                family = Gamma(log), stoptype = "RD"))
plot(Gmod4)

(Gmod5 &lt;- GGeDS(intensity ~ f(angle), data = BaFe2As2, beta = 0.1, phi = 0.995, q = 3,
                family = poisson(), stoptype = "SR"))
plot(Gmod5)

## End(Not run)

##########################################
# Life tables
# See Dimitrova et al. (2023), Section 4.2

data(EWmortality)
attach(EWmortality)
(M1 &lt;- GGeDS(formula = Deaths ~ f(Age) + offset(log(Exposure)),
              family = quasipoisson(), phi = 0.99, beta = 0.1, q = 3,
              stoptype = "LR"))

Exposure_init &lt;- Exposure + 0.5 * Deaths
Rate &lt;- Deaths / Exposure_init
(M2 &lt;- GGeDS(formula = Rate ~ f(Age), weights = Exposure_init,
              family = quasibinomial(), phi = 0.99, beta = 0.1,
              q = 3, stoptype = "LR"))


op &lt;- par(mfrow=c(2,2))
plot(Age, Deaths/Exposure, ylab = expression(mu[x]), xlab = "Age")
lines(M1, n = 3, tr = exp, lwd = 1, col = "red")
plot(Age, Rate, ylab = expression(q[x]), xlab = "Age")
lines(M2, n = 3, tr = quasibinomial()$linkinv, lwd = 1, col = "red")
plot(Age, log(Deaths/Exposure), ylab = expression(log(mu[x])), xlab = "Age")
lines(M1, n = 3, lwd = 1, col = "red")
plot(Age, quasibinomial()$linkfun(Rate), ylab = expression(logit(q[x])), xlab = "Age")
lines(M2, n = 3, lwd = 1, col = "red")
par(op)

#########################################
# bivariate example
set.seed(123)
doublesin &lt;- function(x) {
# Adjusting the output to ensure it's positive
exp(sin(2*x[,1]) + sin(2*x[,2]))
}
X &lt;- round(runif(400, min = 0, max = 3), 2)
Y &lt;- round(runif(400, min = 0, max = 3), 2)
# Calculate lambda for Poisson distribution
lambda &lt;- doublesin(cbind(X,Y))
# Generate Z from Poisson distribution
Z &lt;- rpois(400, lambda)
data &lt;- data.frame(X, Y, Z)

# Fit a Poisson GeDS regression using GGeDS
BivGeDS &lt;- GGeDS(Z ~ f(X,Y), beta = 0.2, phi = 0.99, family = "poisson")

# Poisson mean deviance w.r.t data
deviance(BivGeDS, n = 2) # or sum(poisson()$dev.resids(Z, BivGeDS$Linear.Fit$Predicted, wt = 1))
deviance(BivGeDS, n = 3)
deviance(BivGeDS, n = 4)

# Poisson mean deviance w.r.t true function#' 
f_XY &lt;- apply(cbind(X, Y), 1, function(row) doublesin(matrix(row, ncol = 2)))
mean(poisson()$dev.resids(f_XY, BivGeDS$Linear.Fit$Predicted, wt = 1))
mean(poisson()$dev.resids(f_XY, BivGeDS$Quadratic.Fit$Predicted, wt = 1))
mean(poisson()$dev.resids(f_XY, BivGeDS$Cubic.Fit$Predicted, wt = 1))

# Surface plot of the generating function (doublesin)
plot(BivGeDS, f = doublesin)
# Surface plot of the fitted model
plot(BivGeDS)

</code></pre>

<hr>
<h2 id='Integrate'>Defined integral of GeDS objects</h2><span id='topic+Integrate'></span>

<h3>Description</h3>

<p>This function computes defined integrals of a fitted GeDS regression model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Integrate(object = NULL, knots = NULL, coef = NULL, from, to, n = 3L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Integrate_+3A_object">object</code></td>
<td>
<p>the <code><a href="#topic+GeDS-class">GeDS-class</a></code> object containing the  GeDS fit
which should be integrated. It should be the result of fitting a univariate
GeDS regression via <code><a href="#topic+NGeDS">NGeDS</a></code> or <code><a href="#topic+GGeDS">GGeDS</a></code>. If this is
provided, the <code>knots</code> and <code>coef</code> parameters will be automatically
extracted from the <code>GeDS</code> object. If <code>object</code> is <code>NULL</code>, the
user must provide the <code>knots</code> and <code>coef</code> vectors explicitly.</p>
</td></tr>
<tr><td><code id="Integrate_+3A_knots">knots</code></td>
<td>
<p>a numeric vector of knots. This is required if <code>object</code> is 
<code>NULL</code>. If a <code>GeDS</code> object is provided, this parameter is ignored.</p>
</td></tr>
<tr><td><code id="Integrate_+3A_coef">coef</code></td>
<td>
<p>a numeric vector of coefficients. This is required if <code>object</code> is 
<code>NULL</code>. If a <code>GeDS</code> object is provided, this parameter is ignored</p>
</td></tr>
<tr><td><code id="Integrate_+3A_from">from</code></td>
<td>
<p>optional numeric vector containing the lower limit(s) of
integration. It should be either of size one or of the same size as the
argument <code>to</code>. If left unspecified, by default it is set to the left-most
limit of the interval embedding the observations of the independent variable.</p>
</td></tr>
<tr><td><code id="Integrate_+3A_to">to</code></td>
<td>
<p>numeric vector containing the upper limit(s) of integration.</p>
</td></tr>
<tr><td><code id="Integrate_+3A_n">n</code></td>
<td>
<p>integer value (2, 3 or 4) specifying the order (<code class="reqn">=</code> degree
<code class="reqn"> + 1</code>) of the GeDS fit to be integrated. By default equal to <code>3L</code>.
Non-integer values will be passed to the function <code><a href="base.html#topic+as.integer">as.integer</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is based on the well known property (c.f. De Boor, 2001, Chapter
X, formula (33)) that the integral of a linear combination of appropriately
normalized B-splines is equal to the sum of its corresponding coefficients,
noting that the GeDS regression is in fact such a linear combination.
</p>
<p>Since the function is based on this property, it is designed to work only on
the predictor scale in the GNM (GLM) framework.
</p>
<p>If the argument <code>from</code> is a single value, then it is taken as the lower
limit of integration for all the defined integrals required, whereas the upper
limits of integration are the values contained in the argument <code>to</code>. If
the arguments <code>from</code> and <code>to</code> are of similar size, the integrals
(as many as the size) are computed by sequentially taking the pairs of values
in the <code>from</code> and <code>to</code> vectors as limits of integration.
</p>


<h3>References</h3>

<p>De Boor, C. (2001). <em>A Practical Guide to Splines (Revised Edition)</em>.
Springer, New York.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate a data sample for the response variable
# Y and the single covariate X
# see Dimitrova et al. (2023), section 4.1
set.seed(123)
N &lt;- 500
f_1 &lt;- function(x) (10*x/(1+100*x^2))*4+4
X &lt;- sort(runif(N, min = -2, max = 2))
# Specify a model for the mean of Y to include only
# a component non-linear in X, defined by the function f_1
means &lt;- f_1(X)
# Add (Normal) noise to the mean of Y
Y &lt;- rnorm(N, means, sd = 0.1)
# Fit GeDS regression using NGeDS
Gmod &lt;- NGeDS(Y ~ f(X), beta = 0.6, phi = .995, Xextr = c(-2,2))
# Compute defined integrals (in TeX style) $\int_{1}^{-1} f(x)dx$
# and $\int_{1}^{1} f(x)dx$
# $f$ being the quadratic fit
Integrate(Gmod, from = 1, to = c(-1,1), n = 3)
# Compute defined integrals (in TeX style) $\int_{1}^{-1} f(x)dx$
# and $\int_{-1}^{1} f(x)dx$
# $f$ being the quadratic fit
Integrate(Gmod, from = c(1,-1), to = c(-1,1), n = 3)
## Not run:
## This gives an error
Integrate(Gmod, from = c(1,-1), to = c(1,1), n = 3)

</code></pre>

<hr>
<h2 id='IRLSfit'>IRLS Estimation</h2><span id='topic+IRLSfit'></span>

<h3>Description</h3>

<p>This function is an implementation of the IRLS estimation algorithm adjusted
to the specific usage within the function <code><a href="#topic+SplineReg_GLM">SplineReg_GLM</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IRLSfit(
  x,
  y,
  weights = rep(1, nobs),
  mustart = NULL,
  offset = rep(0, nobs),
  family = gaussian(),
  control = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IRLSfit_+3A_x">x</code></td>
<td>
<p>a matrix of regression functions (e.g. B-splines and/or terms of the
parametric part) evaluated at the sample values of the covariate(s).</p>
</td></tr>
<tr><td><code id="IRLSfit_+3A_y">y</code></td>
<td>
<p>a vector of size <code class="reqn">N</code> containing the observed values of the
response variable <code class="reqn">y</code>.</p>
</td></tr>
<tr><td><code id="IRLSfit_+3A_weights">weights</code></td>
<td>
<p>an optional vector of prior weights for the observations,
used when weighted IRLS fitting is required. By default, this is a vector of
1s.</p>
</td></tr>
<tr><td><code id="IRLSfit_+3A_mustart">mustart</code></td>
<td>
<p>initial values for the vector of means of the response
variable in the IRLS regression estimation. Must be a vector of length <code class="reqn">N</code>.</p>
</td></tr>
<tr><td><code id="IRLSfit_+3A_offset">offset</code></td>
<td>
<p>a vector of size <code class="reqn">N</code> that can be used to specify a fixed
covariate to be included in the predictor model  avoiding the estimation of
its corresponding regression coefficient. In the case that more than one
covariate is fixed, the user should sum the corresponding coordinates of the
fixed covariates to produce one common <code class="reqn">N</code>-vector of coordinates.</p>
</td></tr>
<tr><td><code id="IRLSfit_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to be
used in the model. This can be a character string naming a family function
(e.g. <code>"gaussian"</code>), the family function itself (e.g.
<code><a href="stats.html#topic+gaussian">gaussian</a></code>) or the result of a call to a family function
(e.g. <code>gaussian()</code>). See <a href="stats.html#topic+family">family</a> for details on family
functions.</p>
</td></tr>
<tr><td><code id="IRLSfit_+3A_control">control</code></td>
<td>
<p>a list of parameters for controlling the IRLS fitting process
to be passed on to <code><a href="stats.html#topic+glm.control">glm.control</a></code>. See
<code><a href="stats.html#topic+glm.fit">glm.fit</a></code> for further details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a slightly modified version of the
<code><a href="stats.html#topic+glm.fit">glm.fit</a></code> from the package <span class="pkg">stats</span> to which we refer
for further details. The difference in the inputs of <code>IRLSfit</code> and
<code><a href="stats.html#topic+glm.fit">glm.fit</a></code> is that the former admits initial values only
for the vector of means.
</p>
<p>The output from <code>IRLSfit</code> has some additional slots compared to
<code><a href="stats.html#topic+glm.fit">glm.fit</a></code>. We note that the slots <code>weights</code>,
<code>res2</code> and <code>z</code> contain values of the IRLS weights, &ldquo;working
residuals&quot; and transformed responses computed <em>after</em> the last IRLS
iteration, i.e. they are based on the estimated coefficients that are
returned by <code>IRLSfit</code>.
</p>
<p>The source code of <code>IRLSfit</code> contains also some commented lines that
produce useful plots at each IRLS iteration. Normally, printing these plots
is time consuming, but they could be run for inspection purposes.
</p>


<h3>Value</h3>

<p>A list containing:
</p>
<table role = "presentation">
<tr><td><code>coefficients</code></td>
<td>
<p>a named vector containing the estimated regression
coefficients;</p>
</td></tr>
<tr><td><code>residuals</code></td>
<td>
<p>the working residuals, which are the residuals from the 
final iteration of the IRLS fit. Cases with zero weights are omitted, and
their working residuals are <code>NA</code>;</p>
</td></tr>
<tr><td><code>res2</code></td>
<td>
<p>the working residuals after the final IRLS iteration. They are
used within the knot placement steps of stage A of GeDS;</p>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>the fitted mean values, obtained by transforming the
predictor by the inverse of the link function;</p>
</td></tr>
<tr><td><code>rank</code></td>
<td>
<p>the numeric rank of the fitted linear model;</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>the <code><a href="stats.html#topic+family">family</a></code> object used;</p>
</td></tr>
<tr><td><code>linear.predictors</code></td>
<td>
<p>the fitted predictor;</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p>a vector containing the deviances obtained at each IRLS
iteration;</p>
</td></tr>
<tr><td><code>lastdeviance</code></td>
<td>
<p>the deviance at the last IRLS iteration;</p>
</td></tr>
<tr><td><code>null.deviance</code></td>
<td>
<p>The deviance for the null model (see
<code><a href="stats.html#topic+glm">glm</a></code> documentation);</p>
</td></tr>
<tr><td><code>iter</code></td>
<td>
<p>the number of IRLS iterations performed;</p>
</td></tr>
<tr><td><code>weights</code></td>
<td>
<p>the working weights after the last IRLS iteration;</p>
</td></tr>
<tr><td><code>prior.weights</code></td>
<td>
<p>the &ldquo;prior weights&quot; (see the <code>weights</code> argument);</p>
</td></tr>
<tr><td><code>df.residual</code></td>
<td>
<p>the residual degrees of freedom;</p>
</td></tr>
<tr><td><code>df.null</code></td>
<td>
<p>the residual degrees of freedom for the null model;</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the vector of values of the response variable used in the fitting;</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>the transformed responses computed after the last IRLS iteration;</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>logical. Was the IRLS algorithm judged to have converged?</p>
</td></tr>
<tr><td><code>boundary</code></td>
<td>
<p>logical. Is the fitted value on the boundary of the
attainable values?</p>
</td></tr>
</table>
<p>In addition, non-empty fits will have components <code>qr</code>, <code>R</code> and
<code>effects</code> relating to the final weighted linear fit, see
<code><a href="stats.html#topic+lm.fit">lm.fit</a></code> documentation.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+glm.fit">glm.fit</a></code>
</p>

<hr>
<h2 id='knots.GeDS'>Knots method for GeDS, GeDSboost, GeDSgam</h2><span id='topic+knots.GeDS'></span><span id='topic+knots.GeDSboost+2C'></span><span id='topic+knots.GeDSgam'></span><span id='topic+knots.GeDSboost'></span>

<h3>Description</h3>

<p>Method for the generic function <code><a href="stats.html#topic+knots">knots</a></code> that allows the
user to extract the vector of knots of a GeDS, GeDSboost or GeDSgam fit of a
specified order contained in a <code><a href="#topic+GeDS-class">GeDS-class</a></code>,
<code><a href="#topic+GeDSboost-class">GeDSboost-class</a></code> or <code><a href="#topic+GeDSgam-class">GeDSgam-class</a></code> object,
respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GeDS'
knots(Fn, n = 3L, options = c("all", "internal"), ...)

## S3 method for class 'GeDSboost'
knots(Fn, n = 3L, options = c("all", "internal"), ...)

## S3 method for class 'GeDSgam'
knots(Fn, n = 3L, options = c("all", "internal"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="knots.GeDS_+3A_fn">Fn</code></td>
<td>
<p>the <code><a href="#topic+GeDS-class">GeDS-class</a></code>, <code><a href="#topic+GeDSboost-class">GeDSboost-class</a></code> or
<code><a href="#topic+GeDSgam-class">GeDSgam-class</a></code> object from which the vector of knots for the
specified GeDS, FGB-GeDS or GAM-GeDS fit should be extracted.</p>
</td></tr>
<tr><td><code id="knots.GeDS_+3A_n">n</code></td>
<td>
<p>integer value (2, 3 or 4) specifying the order (<code class="reqn">=</code> degree
<code class="reqn">+ 1</code>) of the GeDS, FGB-GeDS or GAM-GeDS fit whose knots should be
extracted. By default equal to <code>3L</code>. Non-integer values will be passed
to the function <code><a href="base.html#topic+as.integer">as.integer</a></code>.</p>
</td></tr>
<tr><td><code id="knots.GeDS_+3A_options">options</code></td>
<td>
<p>a character string specifying whether &quot;<code>all</code>&quot; knots,
including the left-most and the right-most limits of the interval embedding
the observations (the default) or only the &quot;<code>internal</code>&quot; knots should be
extracted.</p>
</td></tr>
<tr><td><code id="knots.GeDS_+3A_...">...</code></td>
<td>
<p>potentially further arguments (required for compatibility with the
definition of the generic function). Currently ignored, but with a warning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the function <code><a href="stats.html#topic+knots">knots</a></code> in the
<span class="pkg">stats</span> package.
</p>
<p>As <code><a href="#topic+GeDS-class">GeDS-class</a></code>, <code><a href="#topic+GeDSboost-class">GeDSboost-class</a></code> and
<code><a href="#topic+GeDSgam-class">GeDSgam-class</a></code> objects contain three different fits (linear,
quadratic and cubic), it is possible to specify the order of the GeDS fit
whose knots are required via the input argument <code>n</code>.
</p>


<h3>Value</h3>

<p>A vector in which each element represents a knot of the GeDS/FGB-GeDS/GAM-GeDS fit of the required order.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+knots">knots</a></code> for the definition of the generic function; <code><a href="#topic+NGeDS">NGeDS</a></code>, <code><a href="#topic+GGeDS">GGeDS</a></code>,
<code><a href="#topic+NGeDSboost">NGeDSboost</a></code> and <code><a href="#topic+NGeDSgam">NGeDSgam</a></code> for examples.
</p>

<hr>
<h2 id='lines+2CGeDS-method'>Lines method for GeDS objects.</h2><span id='topic+lines+2CGeDS-method'></span><span id='topic+lines.GeDS'></span>

<h3>Description</h3>

<p>Lines method for GeDS objects. Adds a GeDS curve to an existing plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GeDS'
lines(
  x,
  n = 3L,
  transform = function(x) x,
  onlySpline = TRUE,
  data = data.frame(),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lines+2B2CGeDS-method_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+GeDS-Class">GeDS-Class</a></code> object from which the GeDS fit should be
extracted.</p>
</td></tr>
<tr><td><code id="lines+2B2CGeDS-method_+3A_n">n</code></td>
<td>
<p>integer value (2, 3 or 4) specifying the order (<code class="reqn">=</code> degree
<code class="reqn">+ 1</code>) of the GeDS fit that should be plotted. By default equal to
<code>3L</code>. Non-integer values will be passed to the function
<code><a href="base.html#topic+as.integer">as.integer</a></code>.</p>
</td></tr>
<tr><td><code id="lines+2B2CGeDS-method_+3A_transform">transform</code></td>
<td>
<p>a function that can be used to transform the scale of the Y
axis. Typically it can be the inverse of the link function if the plot is on
the scale of the response variable.</p>
</td></tr>
<tr><td><code id="lines+2B2CGeDS-method_+3A_onlyspline">onlySpline</code></td>
<td>
<p>logical variable specifying whether only the spline
component of the fitted GeDS predictor model  should be plotted or
alternatively also the parametric component (see
<code><a href="#topic+formula.GeDS">formula</a></code>) should be plotted.</p>
</td></tr>
<tr><td><code id="lines+2B2CGeDS-method_+3A_data">data</code></td>
<td>
<p>an optional <code>data.frame</code>, <code>list</code> or <code>environment</code>
containing values of the independent variables for  which the GeDS predicted
values should be plotted. If left empty the values are extracted from the
object <code>x</code> itself.</p>
</td></tr>
<tr><td><code id="lines+2B2CGeDS-method_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the default
<code><a href="graphics.html#topic+lines">lines</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method can be used to add a curve corresponding to a particular GeDS fit
to an active plot.
</p>
<p>As GeDS objects contain three different fits (linear, quadratic and cubic),
it is possible to specify the order of the GeDS regression to be plotted via
the input argument <code>n</code>.
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+lines">lines</a></code> for the definition of the generic
function; <code><a href="#topic+NGeDS">NGeDS</a></code> and <code><a href="#topic+GGeDS">GGeDS</a></code> for examples.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Generate a data sample for the response variable
# Y and the single covariate X
set.seed(123)
N &lt;- 500
f_1 &lt;- function(x) (10*x/(1+100*x^2))*4+4
X &lt;- sort(runif(N, min = -2, max = 2))
# Specify a model for the mean of Y to include only a component
# non-linear in X, defined by the function f_1
means &lt;- f_1(X)
# Add (Normal) noise to the mean of Y
Y &lt;- rnorm(N, means, sd = 0.1)

# Fit a GeDS regression model using NGeDS
(Gmod &lt;- NGeDS(Y ~ f(X), beta = 0.6, phi = 0.995, Xextr = c(-2,2)))

# Plot the GeDS third order fit (the quadratic one)
# without its corresponding Polygon
plot(Gmod, type = "none")

# Add a curve corresponding to the second order fit (the linear one)
lines(Gmod, n = 2, col = "green", lwd = 2, lty = 3)

</code></pre>

<hr>
<h2 id='NGeDS'>Geometrically Designed Spline regression estimation</h2><span id='topic+NGeDS'></span>

<h3>Description</h3>

<p><code>NGeDS</code> constructs a Geometrically Designed  variable knots spline
regression model  referred to as a GeDS model, for a response having a Normal
distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NGeDS(
  formula,
  data,
  weights,
  beta = 0.5,
  phi = 0.99,
  min.intknots = 0,
  max.intknots = 500,
  q = 2,
  Xextr = NULL,
  Yextr = NULL,
  show.iters = FALSE,
  stoptype = "RD",
  higher_order = TRUE,
  intknots_init = NULL,
  fit_init = NULL,
  only_pred = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NGeDS_+3A_formula">formula</code></td>
<td>
<p>a description of the structure of the model to be fitted,
including the dependent and independent variables. See
<code><a href="#topic+formula.GeDS">formula</a></code> for details.</p>
</td></tr>
<tr><td><code id="NGeDS_+3A_data">data</code></td>
<td>
<p>an optional data frame, list or environment containing the
variables of the model. If not found in <code>data</code>, the variables are taken
from <code>environment(formula)</code>, typically the environment from which
<code>NGeDS</code> is called.</p>
</td></tr>
<tr><td><code id="NGeDS_+3A_weights">weights</code></td>
<td>
<p>an optional vector of &lsquo;prior weights&rsquo; to be put on the
observations in the fitting process in case the user requires weighted GeDS
fitting. It should be <code>NULL</code> or a numeric vector of the same length as
the response variable in the argument <code><a href="#topic+formula.GeDS">formula</a></code>.</p>
</td></tr>
<tr><td><code id="NGeDS_+3A_beta">beta</code></td>
<td>
<p>numeric parameter in the interval <code class="reqn">[0,1]</code> tuning the knot
placement in stage A of GeDS. See details.</p>
</td></tr>
<tr><td><code id="NGeDS_+3A_phi">phi</code></td>
<td>
<p>numeric parameter in the interval <code class="reqn">[0,1]</code> specifying the
threshold for the stopping rule  (model selector) in stage A of GeDS. See
also <code>stoptype</code> and details below.</p>
</td></tr>
<tr><td><code id="NGeDS_+3A_min.intknots">min.intknots</code></td>
<td>
<p>optional parameter allowing the user to set a minimum
number of internal knots required. By default equal to zero.</p>
</td></tr>
<tr><td><code id="NGeDS_+3A_max.intknots">max.intknots</code></td>
<td>
<p>optional parameter allowing the user to set a maximum
number of internal knots to be added by the GeDS estimation algorithm. By
default equal to the number of knots for the saturated GeDS model.</p>
</td></tr>
<tr><td><code id="NGeDS_+3A_q">q</code></td>
<td>
<p>numeric parameter which allows to fine-tune the stopping rule of
stage A of GeDS, by default equal to 2. See details.</p>
</td></tr>
<tr><td><code id="NGeDS_+3A_xextr">Xextr</code></td>
<td>
<p>numeric vector of 2 elements representing the left-most and
right-most limits of the interval embedding the observations of the first
independent variable. See details.</p>
</td></tr>
<tr><td><code id="NGeDS_+3A_yextr">Yextr</code></td>
<td>
<p>numeric vector of 2 elements representing the left-most and
right-most limits of the interval embedding the observations of the second
independent variable (if the bivariate GeDS is run). See details.</p>
</td></tr>
<tr><td><code id="NGeDS_+3A_show.iters">show.iters</code></td>
<td>
<p>logical variable indicating whether or not to print 
information at each step.</p>
</td></tr>
<tr><td><code id="NGeDS_+3A_stoptype">stoptype</code></td>
<td>
<p>a character string indicating the type of GeDS stopping rule
to be used. It should be either one of <code>"SR"</code>, <code>"RD"</code> or 
<code>"LR"</code>, partial match allowed. See details.</p>
</td></tr>
<tr><td><code id="NGeDS_+3A_higher_order">higher_order</code></td>
<td>
<p>a logical that defines whether to compute the higher
order fits (quadratic and cubic) after stage A is run. Default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="NGeDS_+3A_intknots_init">intknots_init</code></td>
<td>
<p>vector of starting internal knots. Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="NGeDS_+3A_fit_init">fit_init</code></td>
<td>
<p>A list containing fitted values <code>pred</code>, along with
corresponding <code>intknots</code> and <code>coef</code>, representing the initial fit from
which to begin Stage A GeDS iteration (i.e. departing from step 2).</p>
</td></tr>
<tr><td><code id="NGeDS_+3A_only_pred">only_pred</code></td>
<td>
<p>logical, if <code>TRUE</code> only predictions are computed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The  <code>NGeDS</code> function implements the GeDS methodology, recently
developed by Kaishev et al. (2016) and extended in the <code><a href="#topic+GGeDS">GGeDS</a></code>
function for the more general GNM, (GLM) context, allowing for the response
to have any distribution from the Exponential Family. Under the GeDS approach
the (non-)linear predictor is viewed as a spline with variable knots which
are estimated along with the regression coefficients and the order of the
spline, using a two stage algorithm. In stage A, a linear variable-knot
spline is fitted to the data applying iteratively least squares  regression
(see <code><a href="stats.html#topic+lm">lm</a></code> function). In stage B, a Schoenberg variation
diminishing spline approximation to the fit from stage A is constructed, thus
simultaneously producing spline fits of order 2, 3 and 4, all of which are
included in the output, a <code><a href="#topic+GeDS-Class">GeDS-Class</a></code> object.
</p>
<p>As noted in <code><a href="#topic+formula.GeDS">formula</a></code>, the argument <code>formula</code>
allows the user to specify models with two components, a spline regression
(non-parametric) component involving part of the independent variables
identified through the function <code>f</code> and an optional  parametric
component involving the remaining independent variables. For <code>NGeDS</code> one
or two independent variables are allowed for the spline component and
arbitrary many independent variables for the parametric component. Failure to
specify the independent variable for the  spline regression component through
the function <code>f</code> will return an error. See
<code><a href="#topic+formula.GeDS">formula</a></code>.
</p>
<p>Within the argument <code>formula</code>, similarly as in other R functions, it is
possible to specify one or more offset variables, i.e. known terms with fixed
regression coefficients equal to 1. These terms should be identified via the
function <code><a href="stats.html#topic+offset">offset</a></code>.
</p>
<p>The parameter <code>beta</code> tunes the placement of a new knot in stage A of the
algorithm. Once a current second-order  spline is fitted to the data the
regression residuals are computed and grouped by their sign. A new knot is
placed  at a location defined by the group for which a certain measure
attains its maximum. The latter measure is defined as a weighted linear
combination of the range of each group and the  mean of the absolute
residuals within it. The parameter <code>beta</code> determines the weights in this
measure correspondingly as <code>beta</code> and <code>1 - beta</code>. The  higher it
is, the more weight is put to the mean of the residuals and the less to the
range of their corresponding x-values. The default value of <code>beta</code> is
<code>0.5</code>.
</p>
<p>The argument <code>stoptype</code> allows to choose between three alternative
stopping rules for the knot selection in stage A of GeDS, the <code>"RD"</code>,
that stands for <em>Ratio of Deviances</em>, the <code>"SR"</code>, that stands for
<em>Smoothed Ratio</em> of deviances and the <code>"LR"</code>, that stands for
<em>Likelihood Ratio</em>. The latter is based on the difference of deviances
rather than on their ratio as in the case of <code>"RD"</code> and <code>"SR"</code>.
Therefore <code>"LR"</code> can be viewed as a log likelihood ratio test performed
at each iteration of the knot placement. In each of these cases the
corresponding stopping criterion is compared with a threshold value
<code>phi</code> (see below).
</p>
<p>The argument <code>phi</code> provides a threshold value required for the stopping
rule to exit the knot placement in stage A of GeDS. The higher the value of
<code>phi</code>, the more knots are added under the <code>"RD"</code> and <code>"SR"</code>
stopping rules contrary to the case of the stopping rule <code>"LR"</code> where
the lower <code>phi</code> is, more knots are included in the spline regression.
Further details for each of the three alternative stopping rules can be found
in Dimitrova et al. (2023).
</p>
<p>The argument <code>q</code> is an input parameter that allows to fine-tune the
stopping rule in stage A. It identifies the number of consecutive iterations
over which the deviance should exhibit stable convergence so as the knot
placement in stage A is terminated. More precisely, under any of the rules
<code>"RD"</code>, <code>"SR"</code>, or <code>"LR"</code>, the deviance at the current
iteration is compared to the deviance computed <code>q</code> iterations before,
i.e., before selecting the last <code>q</code> knots. Setting a higher <code>q</code>
will lead to more knots being added before exiting stage A of GeDS.
</p>


<h3>Value</h3>

<p><code><a href="#topic+GeDS-Class">GeDS-Class</a></code> object, i.e. a list of items that summarizes
the main details of the fitted GeDS regression. See <code><a href="#topic+GeDS-Class">GeDS-Class</a></code>
for details. Some S3 methods are available in order to make these objects
tractable, such as <code><a href="#topic+coef.GeDS">coef</a></code>,
<code><a href="#topic+deviance.GeDS">deviance</a></code>, <code><a href="#topic+knots.GeDS">knots</a></code>,
<code><a href="#topic+predict.GeDS">predict</a></code> and <code><a href="#topic+print.GeDS">print</a></code> as
well as S4 methods for <code><a href="#topic+lines.GeDS">lines</a></code> and
<code><a href="#topic+plot.GeDS">plot</a></code>.
</p>


<h3>References</h3>

<p>Kaishev, V.K., Dimitrova, D.S., Haberman, S. and Verrall, R.J. (2016).
Geometrically designed, variable knot regression splines.
<em>Computational Statistics</em>, <strong>31</strong>, 1079&ndash;1105. <br />
DOI: <a href="https://doi.org/10.1007/s00180-015-0621-7">doi:10.1007/s00180-015-0621-7</a>
</p>
<p>Dimitrova, D. S., Kaishev, V. K., Lattuada, A. and Verrall, R. J.  (2023).
Geometrically designed variable knot splines in generalized (non-)linear
models.
<em>Applied Mathematics and Computation</em>, <strong>436</strong>. <br />
DOI: <a href="https://doi.org/10.1016/j.amc.2022.127493">doi:10.1016/j.amc.2022.127493</a>
</p>


<h3>See Also</h3>

<p><a href="#topic+GGeDS">GGeDS</a>; <a href="#topic+GeDS-Class">GeDS-Class</a>; S3 methods such as <a href="#topic+coef.GeDS">coef.GeDS</a>,
<a href="#topic+deviance.GeDS">deviance.GeDS</a>, <a href="#topic+knots.GeDS">knots.GeDS</a>, <a href="#topic+print.GeDS">print.GeDS</a> and
<a href="#topic+predict.GeDS">predict.GeDS</a>; <a href="#topic+Integrate">Integrate</a> and <a href="#topic+Derive">Derive</a>; <a href="#topic+PPolyRep">PPolyRep</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
###################################################
# Generate a data sample for the response variable
# Y and the single covariate X
set.seed(123)
N &lt;- 500
f_1 &lt;- function(x) (10*x/(1+100*x^2))*4+4
X &lt;- sort(runif(N, min = -2, max = 2))
# Specify a model for the mean of Y to include only a component
# non-linear in X, defined by the function f_1
means &lt;- f_1(X)
# Add (Normal) noise to the mean of Y
Y &lt;- rnorm(N, means, sd = 0.1)

# Fit a Normal GeDS regression using NGeDS
(Gmod &lt;- NGeDS(Y ~ f(X), beta = 0.6, phi = 0.995, Xextr = c(-2,2)))

# Apply some of the available methods, e.g.
# coefficients, knots and deviance extractions for the
# quadratic GeDS fit
# Note that the first call to the function knots returns
# also the left and right limits of the interval containing
# the data
coef(Gmod, n = 3)
knots(Gmod, n = 3)
knots(Gmod, n = 3, options = "internal")
deviance(Gmod, n = 3)

# Add a covariate, Z, that enters linearly
Z &lt;- runif(N)
Y2 &lt;- Y + 2*Z + 1
# Re-fit the data using NGeDS
(Gmod2 &lt;- NGeDS(Y2 ~ f(X) + Z, beta = 0.6, phi = 0.995, Xextr = c(-2,2)))
coef(Gmod2, n = 3)
coef(Gmod2, onlySpline = FALSE, n = 3)

## Not run: 
##########################################
# Real data example
# See Kaishev et al. (2016), section 4.2
data('BaFe2As2')
(Gmod2 &lt;- NGeDS(intensity ~ f(angle), data = BaFe2As2, beta = 0.6, phi = 0.99, q = 3))
plot(Gmod2)

## End(Not run)

#########################################
# bivariate example
# See Dimitrova et al. (2023), section 5

# Generate a data sample for the response variable
# Z and the covariates X and Y assuming Normal noise
set.seed(123)
doublesin &lt;- function(x){
 sin(2*x[,1])*sin(2*x[,2])
}

X &lt;- (round(runif(400, min = 0, max = 3),2))
Y &lt;- (round(runif(400, min = 0, max = 3),2))
Z &lt;- doublesin(cbind(X,Y))
Z &lt;- Z+rnorm(400, 0, sd = 0.1)
# Fit a two dimensional GeDS model using NGeDS
(BivGeDS &lt;- NGeDS(Z ~ f(X, Y), phi = 0.9))

# Extract quadratic coefficients/knots/deviance
coef(BivGeDS, n = 3)
knots(BivGeDS, n = 3)
deviance(BivGeDS, n = 3)

# Surface plot of the generating function (doublesin)
plot(BivGeDS, f = doublesin)
# Surface plot of the fitted model
plot(BivGeDS)

</code></pre>

<hr>
<h2 id='NGeDSboost'>Component-wise gradient boosting with NGeDS base-learners</h2><span id='topic+NGeDSboost'></span>

<h3>Description</h3>

<p><code>NGeDSboost</code> implements component-wise gradient boosting (Bühlmann and Yu
(2003), Bühlmann and Hothorn (2007)) using normal GeD splines (i.e., fitted
with <code><a href="#topic+NGeDS">NGeDS</a></code> function) as base-learners (see Dimitrova et al. (2025)).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NGeDSboost(
  formula,
  data,
  weights = NULL,
  normalize_data = FALSE,
  family = mboost::Gaussian(),
  link = NULL,
  initial_learner = TRUE,
  int.knots_init = 2L,
  min_iterations,
  max_iterations,
  shrinkage = 1,
  phi_boost_exit = 0.99,
  q_boost = 2L,
  beta = 0.5,
  phi = 0.99,
  int.knots_boost = 500L,
  q = 2L,
  higher_order = TRUE,
  boosting_with_memory = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NGeDSboost_+3A_formula">formula</code></td>
<td>
<p>a description of the structure of the model to be fitted,
including the dependent and independent variables. Unlike <code><a href="#topic+NGeDS">NGeDS</a></code>
and <code><a href="#topic+GGeDS">GGeDS</a></code>, the formula specified allows for multiple additive
GeD spline regression components (as well as linear components) to be
included (e.g., <code>Y ~ f(X1) + f(X2) + X3</code>).</p>
</td></tr>
<tr><td><code id="NGeDSboost_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables referenced in the formula.</p>
</td></tr>
<tr><td><code id="NGeDSboost_+3A_weights">weights</code></td>
<td>
<p>an optional vector of &lsquo;prior weights&rsquo; to be put on the
observations during the fitting process. It should be <code>NULL</code> or a
numeric vector of the same length as the response variable defined in the
formula.</p>
</td></tr>
<tr><td><code id="NGeDSboost_+3A_normalize_data">normalize_data</code></td>
<td>
<p>a logical that defines whether the data should be
normalized (standardized) before fitting the baseline linear model, i.e.,
before running the FGB algorithm. Normalizing the data involves scaling the
predictor variables to have a mean of 0 and a standard deviation of 1. Note
that this process alters the scale and interpretation of the knots and
coefficients estimated. Default is equal to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="NGeDSboost_+3A_family">family</code></td>
<td>
<p>determines the loss function to be optimized by the boosting
algorithm. In case <code>initial_learner = FALSE</code> it also determines the
corresponding empirical risk minimizer to be used as offset initial learner.
By default, it is set to <code>mboost::Gaussian()</code>. Users can specify any
<code><a href="mboost.html#topic+Family">Family</a></code> object from the <span class="pkg">mboost</span> package.</p>
</td></tr>
<tr><td><code id="NGeDSboost_+3A_link">link</code></td>
<td>
<p>in case the <code><a href="mboost.html#topic+Family">Family</a></code> object has not
the desired link function you can specify it here.</p>
</td></tr>
<tr><td><code id="NGeDSboost_+3A_initial_learner">initial_learner</code></td>
<td>
<p>a logical value. If set to <code>TRUE</code>, the model's
initial learner will be a GeD spline. If set to <code>FALSE</code>, then the
initial predictor will consist of the empirical risk minimizer corresponding
to the specified <code>family</code>.</p>
</td></tr>
<tr><td><code id="NGeDSboost_+3A_int.knots_init">int.knots_init</code></td>
<td>
<p>optional parameter allowing the user to set a
maximum number of internal knots to be added by the initial GeDS learner in
case <code>initial_learner = TRUE</code>. Default is equal to <code>2L</code>.</p>
</td></tr>
<tr><td><code id="NGeDSboost_+3A_min_iterations">min_iterations</code></td>
<td>
<p>optional parameter to manually set a minimum number of
boosting iterations to be run. If not specified, it defaults to 0L.</p>
</td></tr>
<tr><td><code id="NGeDSboost_+3A_max_iterations">max_iterations</code></td>
<td>
<p>optional parameter to manually set the maximum number
of boosting iterations to be run. If not specified, it defaults to 100L.
This setting serves as a fallback when the stopping rule, based on
consecutive deviances and tuned by <code>phi_boost_exit</code> and <code>q_boost</code>,
does not trigger an earlier termination (see Dimitrova et al. (2025)).
Therefore, users can increase/decrease the number of boosting iterations,
by increasing/decreasing the value <code>phi_boost_exit</code> and/or
<code>q_boost</code>, or directly specify <code>max_iterations</code>.</p>
</td></tr>
<tr><td><code id="NGeDSboost_+3A_shrinkage">shrinkage</code></td>
<td>
<p>numeric parameter in the interval <code class="reqn">[0,1]</code> defining the
step size or shrinkage parameter. This controls the size of the steps taken
in the direction of the gradient of the loss function. In other words, the
magnitude of the update each new iteration contributes to the final model.
Default is equal to <code>1</code>.</p>
</td></tr>
<tr><td><code id="NGeDSboost_+3A_phi_boost_exit">phi_boost_exit</code></td>
<td>
<p>numeric parameter in the interval <code class="reqn">[0,1]</code>
specifying the threshold for the boosting iterations stopping rule. Default
is equal to <code>0.99</code>.</p>
</td></tr>
<tr><td><code id="NGeDSboost_+3A_q_boost">q_boost</code></td>
<td>
<p>numeric parameter which allows to fine-tune the boosting
iterations stopping rule, by default equal to <code>2L</code>.</p>
</td></tr>
<tr><td><code id="NGeDSboost_+3A_beta">beta</code></td>
<td>
<p>numeric parameter in the interval <code class="reqn">[0,1]</code> tuning the knot
placement in stage A of GeDS. Default is equal to <code>0.5</code>. See details in
<code><a href="#topic+NGeDS">NGeDS</a></code>.</p>
</td></tr>
<tr><td><code id="NGeDSboost_+3A_phi">phi</code></td>
<td>
<p>numeric parameter in the interval <code class="reqn">[0,1]</code> specifying the
threshold for the stopping rule  (model selector) in stage A of GeDS.
Default is equal to <code>0.99</code>. See details in <code><a href="#topic+NGeDS">NGeDS</a></code>.</p>
</td></tr>
<tr><td><code id="NGeDSboost_+3A_int.knots_boost">int.knots_boost</code></td>
<td>
<p>The maximum number of internal knots that can be added
by the GeDS base-learners in each boosting iteration, effectively setting the
value of <code>max.intknots</code> in <code><a href="#topic+NGeDS">NGeDS</a></code> at each boosting
iteration. Default is <code>500L</code>.</p>
</td></tr>
<tr><td><code id="NGeDSboost_+3A_q">q</code></td>
<td>
<p>numeric parameter which allows to fine-tune the stopping rule of
stage A of GeDS, by default equal to <code>2L</code>. See details in
<code><a href="#topic+NGeDS">NGeDS</a></code>.</p>
</td></tr>
<tr><td><code id="NGeDSboost_+3A_higher_order">higher_order</code></td>
<td>
<p>a logical that defines whether to compute the higher
order fits (quadratic and cubic) after the FGB algorithm is run. Default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="NGeDSboost_+3A_boosting_with_memory">boosting_with_memory</code></td>
<td>
<p>logical value. If <code>TRUE</code>, boosting is
performed taking into account previously fitted knots when fitting a GeDS
learner at each new boosting iteration. If <code>boosting_with_memory</code> is
<code>TRUE</code>, we recommend setting <code>int.knots_init = 1</code> and
<code>int.knots_boost = 1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The  <code>NGeDSboost</code> function implements functional gradient boosting
algorithm for some pre-defined loss function, using linear GeD splines as
base learners. At each boosting iteration, the negative gradient vector is
fitted through the base procedure encapsulated within the <code><a href="#topic+NGeDS">NGeDS</a></code>
function. The latter constructs a Geometrically Designed variable knots
spline regression model for a response having a Normal distribution. The FGB
algorithm yields a final linear fit. Higher order fits (quadratic and cubic)
are then computed by calculating the Schoenberg’s variation diminishing
spline (VDS) approximation of the linear fit.
</p>
<p>On the one hand, <code>NGeDSboost</code> includes all the parameters of
<code><a href="#topic+NGeDS">NGeDS</a></code>, which in this case tune the base-learner fit at each
boosting iteration. On the other hand, <code>NGeDSboost</code> includes some
additional parameters proper to the FGB procedure. We describe the main ones
as follows. 
</p>
<p>First, <code>family</code> allows to specify the loss function and corresponding
risk function to be optimized by the boosting algorithm. If
<code>initial_learner = FALSE</code>, the initial learner employed will be the
empirical risk minimizer corresponding to the family chosen. If
<code>initial_learner = TRUE</code> then the initial learner will be an
<code><a href="#topic+NGeDS">NGeDS</a></code> fit with maximum number of internal knots equal to
<code>int.knots_init</code>.
</p>
<p><code>shrinkage</code> tunes the step length/shrinkage parameter which helps to 
control the learning rate of the model. In other words, when a new base
learner is added to the ensemble, its contribution to the final prediction is
multiplied by the shrinkage parameter. The smaller <code>shrinkage</code> is, the
slower/more gradual the learning process will be, and viceversa.
</p>
<p>The number of boosting iterations is controlled by a
<em>Ratio of Deviances</em> stopping rule similar to the one presented for
<code><a href="#topic+GGeDS">GGeDS</a></code>. In the same way <code>phi</code> and <code>q</code> tune the
stopping rule of <code><a href="#topic+GGeDS">GGeDS</a></code>, <code>phi_boost_exit</code> and
<code>q_boost</code> tune the stopping rule of <code>NGeDSboost</code>. The user can also
manually control the number of boosting iterations through
<code>min_iterations</code> and <code>max_iterations</code>.
</p>


<h3>Value</h3>

<p><code><a href="#topic+GeDSboost-Class">GeDSboost-Class</a></code> object, i.e. a list of items that
summarizes the main details of the fitted FGB-GeDS model. See
<code><a href="#topic+GeDSboost-Class">GeDSboost-Class</a></code> for details. Some S3 methods are available in
order to make these objects tractable, such as
<code><a href="#topic+coef.GeDSboost">coef</a></code>, <code><a href="#topic+knots.GeDSboost">knots</a></code>,
<code><a href="#topic+print.GeDSboost">print</a></code> and
<code><a href="#topic+predict.GeDSboost">predict</a></code>. Also variable importance measures
(<code><a href="#topic+bl_imp.GeDSboost">bl_imp</a></code>) and improved plotting facilities
(<code><a href="#topic+visualize_boosting.GeDSboost">visualize_boosting</a></code>).
</p>


<h3>References</h3>

<p>Friedman, J.H. (2001).
Greedy function approximation: A gradient boosting machine.
<em>The Annals of Statistics</em>, <strong>29 (5)</strong>, 1189&ndash;1232. <br />
DOI: <a href="https://doi.org/10.1214/aos/1013203451">doi:10.1214/aos/1013203451</a>
</p>
<p>Bühlmann P., Yu B. (2003).
Boosting With the L2 Loss.
<em>Journal of the American Statistical Association</em>,
<strong>98(462)</strong>, 324–339.
<a href="https://doi.org/10.1198/016214503000125">doi:10.1198/016214503000125</a>
</p>
<p>Bühlmann P., Hothorn T. (2007).
Boosting Algorithms: Regularization, Prediction and Model Fitting.
<em>Statistical Science</em>, <strong>22(4)</strong>, 477 – 505. <br />
DOI: <a href="https://doi.org/10.1214/07-STS242">doi:10.1214/07-STS242</a>
</p>
<p>Kaishev, V.K., Dimitrova, D.S., Haberman, S. and Verrall, R.J. (2016).
Geometrically designed, variable knot regression splines.
<em>Computational Statistics</em>, <strong>31</strong>, 1079&ndash;1105. <br />
DOI: <a href="https://doi.org/10.1007/s00180-015-0621-7">doi:10.1007/s00180-015-0621-7</a>
</p>
<p>Dimitrova, D. S., Kaishev, V. K., Lattuada, A. and Verrall, R. J.  (2023).
Geometrically designed variable knot splines in generalized (non-)linear
models.
<em>Applied Mathematics and Computation</em>, <strong>436</strong>. <br />
DOI: <a href="https://doi.org/10.1016/j.amc.2022.127493">doi:10.1016/j.amc.2022.127493</a>
</p>
<p>Dimitrova, D. S., Kaishev, V. K. and Saenz Guillen, E. L. (2025).
<span class="pkg">GeDS</span>: An R Package for Regression, Generalized Additive
Models and Functional Gradient Boosting, based on Geometrically Designed
(GeD) Splines. <em>Manuscript submitted for publication.</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NGeDS">NGeDS</a></code>; <code><a href="#topic+GGeDS">GGeDS</a></code>; <code><a href="#topic+GeDSboost-Class">GeDSboost-Class</a></code>;
S3 methods such as <code><a href="#topic+knots.GeDSboost">knots.GeDSboost</a></code>; <code><a href="#topic+coef.GeDSboost">coef.GeDSboost</a></code>;
<code><a href="#topic+deviance.GeDSboost">deviance.GeDSboost</a></code>; <code><a href="#topic+predict.GeDSboost">predict.GeDSboost</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
################################# Example 1 #################################
# Generate a data sample for the response variable
# Y and the single covariate X
set.seed(123)
N &lt;- 500
f_1 &lt;- function(x) (10*x/(1+100*x^2))*4+4
X &lt;- sort(runif(N, min = -2, max = 2))
# Specify a model for the mean of Y to include only a component
# non-linear in X, defined by the function f_1
means &lt;- f_1(X)
# Add (Normal) noise to the mean of Y
Y &lt;- rnorm(N, means, sd = 0.2)
data = data.frame(X, Y)

# Fit a Normal FGB-GeDS regression using NGeDSboost

Gmodboost &lt;- NGeDSboost(Y ~ f(X), data = data)
MSE_Gmodboost_linear &lt;- mean((sapply(X, f_1) - Gmodboost$predictions$pred_linear)^2)
MSE_Gmodboost_quadratic &lt;- mean((sapply(X, f_1) - Gmodboost$predictions$pred_quadratic)^2)
MSE_Gmodboost_cubic &lt;- mean((sapply(X, f_1) - Gmodboost$predictions$pred_cubic)^2)

cat("\n", "MEAN SQUARED ERROR", "\n",
    "Linear NGeDSboost:", MSE_Gmodboost_linear, "\n",
    "Quadratic NGeDSboost:", MSE_Gmodboost_quadratic, "\n",
    "Cubic NGeDSboost:", MSE_Gmodboost_cubic, "\n")

# Compute predictions on new randomly generated data
X &lt;- sort(runif(100, min = -2, max = 2))

pred_linear &lt;- predict(Gmodboost, newdata = data.frame(X), n = 2L)
pred_quadratic &lt;- predict(Gmodboost, newdata = data.frame(X), n = 3L)
pred_cubic &lt;- predict(Gmodboost, newdata = data.frame(X), n = 4L)

MSE_Gmodboost_linear &lt;- mean((sapply(X, f_1) - pred_linear)^2)
MSE_Gmodboost_quadratic &lt;- mean((sapply(X, f_1) - pred_quadratic)^2)
MSE_Gmodboost_cubic &lt;- mean((sapply(X, f_1) - pred_cubic)^2)
cat("\n", "MEAN SQUARED ERROR", "\n",
    "Linear NGeDSboost:", MSE_Gmodboost_linear, "\n",
    "Quadratic NGeDSboost:", MSE_Gmodboost_quadratic, "\n",
    "Cubic NGeDSboost:", MSE_Gmodboost_cubic, "\n")

## S3 methods for class 'GeDSboost'
# Print 
print(Gmodboost)
# Knots
knots(Gmodboost, n = 2L)
knots(Gmodboost, n = 3L)
knots(Gmodboost, n = 4L)
# Coefficients
coef(Gmodboost, n = 2L)
coef(Gmodboost, n = 3L)
coef(Gmodboost, n = 4L)
# Deviances
deviance(Gmodboost, n = 2L)
deviance(Gmodboost, n = 3L)
deviance(Gmodboost, n = 4L)

############################ Example 2 - Bodyfat ############################
library(TH.data)
data("bodyfat", package = "TH.data")

Gmodboost &lt;- NGeDSboost(formula = DEXfat ~ age + f(hipcirc, waistcirc) + f(kneebreadth),
data = bodyfat, phi_boost_exit = 0.9, q_boost = 1, phi = 0.9, q = 1)

MSE_Gmodboost_linear &lt;- mean((bodyfat$DEXfat - Gmodboost$predictions$pred_linear)^2)
MSE_Gmodboost_quadratic &lt;- mean((bodyfat$DEXfat - Gmodboost$predictions$pred_quadratic)^2)
MSE_Gmodboost_cubic &lt;- mean((bodyfat$DEXfat - Gmodboost$predictions$pred_cubic)^2)
# Comparison
cat("\n", "MSE", "\n",
    "Linear NGeDSboost:", MSE_Gmodboost_linear, "\n",
    "Quadratic NGeDSboost:", MSE_Gmodboost_quadratic, "\n",
    "Cubic NGeDSboost:", MSE_Gmodboost_cubic, "\n")

</code></pre>

<hr>
<h2 id='NGeDSgam'>NGeDSgam: Local Scoring Algorithm with GeD Splines in Backfitting</h2><span id='topic+NGeDSgam'></span>

<h3>Description</h3>

<p>Implements the Local Scoring Algorithm (Hastie and Tibshirani
(1986)), applying normal linear GeD splines (i.e., <code><a href="#topic+NGeDS">NGeDS</a></code>
function) to fit the targets within each backfitting iteration. Higher order 
fits are computed by pursuing stage B of GeDS after the local-scoring algorithm
is run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NGeDSgam(
  formula,
  family = "gaussian",
  data,
  weights = NULL,
  offset = NULL,
  normalize_data = FALSE,
  min_iterations,
  max_iterations,
  phi_gam_exit = 0.99,
  q_gam = 2,
  beta = 0.5,
  phi = 0.99,
  internal_knots = 500,
  q = 2,
  higher_order = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="NGeDSgam_+3A_formula">formula</code></td>
<td>
<p>a description of the model structure to be fitted,
specifying both the dependent and independent variables. Unlike <code><a href="#topic+NGeDS">NGeDS</a></code>
and <code><a href="#topic+GGeDS">GGeDS</a></code>, this formula supports multiple additive (normal) GeD
spline regression components as well as linear components. For example, setting
<code>formula = Y ~ f(X1) + f(X2) + X3</code> implies using a normal linear GeD
spline as the smoother for <code>X1</code> and for <code>X2</code>, while for <code>X3</code> a
linear model would be used.</p>
</td></tr>
<tr><td><code id="NGeDSgam_+3A_family">family</code></td>
<td>
<p>a character string indicating the response variable distribution
and link function to be used. Default is <code>"gaussian"</code>. This should be a
character or a family object.</p>
</td></tr>
<tr><td><code id="NGeDSgam_+3A_data">data</code></td>
<td>
<p>a data frame containing the variables referenced in the formula.</p>
</td></tr>
<tr><td><code id="NGeDSgam_+3A_weights">weights</code></td>
<td>
<p>an optional vector of &lsquo;prior weights&rsquo; to be put on the
observations during the fitting process. It should be <code>NULL</code> or a numeric
vector of the same length as the response variable defined in the formula.</p>
</td></tr>
<tr><td><code id="NGeDSgam_+3A_offset">offset</code></td>
<td>
<p>a vector of size <code class="reqn">N</code> that can be used to specify a fixed
component to be included in the linear predictor during fitting. In case
more than one covariate is fixed, the user should sum the corresponding
coordinates of the fixed covariates to produce one common <code class="reqn">N</code>-vector of
coordinates.</p>
</td></tr>
<tr><td><code id="NGeDSgam_+3A_normalize_data">normalize_data</code></td>
<td>
<p>a logical that defines whether the data should be
normalized (standardized) before fitting the baseline linear model, i.e.,
before running the local-scoring algorithm. Normalizing the data involves
scaling the predictor variables to have a mean of 0 and a standard deviation
of 1. This process alters the scale and interpretation of the knots and
coefficients estimated. Default is equal to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="NGeDSgam_+3A_min_iterations">min_iterations</code></td>
<td>
<p>optional parameter to manually set a minimum number of
boosting iterations to be run. If not specified, it defaults to 0L.</p>
</td></tr>
<tr><td><code id="NGeDSgam_+3A_max_iterations">max_iterations</code></td>
<td>
<p>optional parameter to manually set the maximum number
of boosting iterations to be run. If not specified, it defaults to 100L.
This setting serves as a fallback when the stopping rule, based on
consecutive deviances and tuned by <code>phi_gam_exit</code> and <code>q_gam</code>,
does not trigger an earlier termination (see Dimitrova et al. (2025)).
Therefore, users can increase/decrease the number of boosting iterations,
by increasing/decreasing the value <code>phi_gam_exit</code> and/or <code>q_gam</code>,
or directly specify <code>max_iterations</code>.</p>
</td></tr>
<tr><td><code id="NGeDSgam_+3A_phi_gam_exit">phi_gam_exit</code></td>
<td>
<p>Convergence threshold for local-scoring and backfitting.
Both algorithms stop when the relative change in the deviance is below this
threshold. Default is <code>0.99</code>.</p>
</td></tr>
<tr><td><code id="NGeDSgam_+3A_q_gam">q_gam</code></td>
<td>
<p>numeric parameter which allows to fine-tune the stopping rule of
the local-scoring and backfitting iterations. By default equal to <code>2L</code>.</p>
</td></tr>
<tr><td><code id="NGeDSgam_+3A_beta">beta</code></td>
<td>
<p>numeric parameter in the interval <code class="reqn">[0,1]</code>
tuning the knot placement in stage A of GeDS, for each of the GeD spline
components of the model. Default is equal to <code>0.5</code>.
See details in <code><a href="#topic+NGeDS">NGeDS</a></code>.</p>
</td></tr>
<tr><td><code id="NGeDSgam_+3A_phi">phi</code></td>
<td>
<p>numeric parameter in the interval <code class="reqn">[0,1]</code> specifying the
threshold for the stopping rule  (model selector) in stage A of GeDS, for each
of the GeD spline components of the model. Default is equal to <code>0.99</code>.
See details in <code><a href="#topic+NGeDS">NGeDS</a></code>.</p>
</td></tr>
<tr><td><code id="NGeDSgam_+3A_internal_knots">internal_knots</code></td>
<td>
<p>The maximum number of internal knots that can be added
by the GeDS base-learners in each boosting iteration, effectively setting the
value of <code>max.intknots</code> in <code><a href="#topic+NGeDS">NGeDS</a></code> at each backfitting
iteration. Default is <code>500L</code>.</p>
</td></tr>
<tr><td><code id="NGeDSgam_+3A_q">q</code></td>
<td>
<p>numeric parameter which allows to fine-tune the stopping rule of
stage A of GeDS, for each of the GeD spline components of the model. By
default equal to <code>2L</code>. See details in <code><a href="#topic+NGeDS">NGeDS</a></code>.</p>
</td></tr>
<tr><td><code id="NGeDSgam_+3A_higher_order">higher_order</code></td>
<td>
<p>a logical that defines whether to compute the higher order
fits (quadratic and cubic) after the local-scoring algorithm is run. Default
is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The  <code>NGeDSgam</code> function employs the local scoring algorithm to fit a
Generalized Additive Model (GAM). This algorithm iteratively fits weighted
additive models by backfitting. Normal linear GeD splines, as well as linear
learners, are supported as function smoothers within the backfitting
algorithm. The local-scoring algorithm ultimately produces a linear fit.
Higher order fits (quadratic and cubic) are then computed by calculating the
Schoenberg’s variation diminishing spline (VDS) approximation of the linear
fit.
</p>
<p>On the one hand, <code>NGeDSgam</code> includes all the parameters of
<code><a href="#topic+NGeDS">NGeDS</a></code>, which in this case tune the function smoother fit at each
backfitting iteration. On the other hand, <code>NGeDSgam</code> includes some
additional parameters proper to the local-scoring procedure. We describe
the main ones as follows. 
</p>
<p>The <code>family</code> chosen determines the link function, adjusted dependent
variable and weights to be used in the local-scoring algorithm. The number of
local-scoring and backfitting iterations is controlled by a
<em>Ratio of Deviances</em> stopping rule similar to the one presented for
<code><a href="#topic+GGeDS">GGeDS</a></code>. In the same way <code>phi</code> and <code>q</code> tune the stopping
rule of <code><a href="#topic+GGeDS">GGeDS</a></code>, <code>phi_boost_exit</code> and <code>q_boost</code> tune the
stopping rule of <code>NGeDSgam</code>. The user can also manually control the number
of local-scoring iterations through <code>min_iterations</code> and 
<code>max_iterations</code>.
</p>


<h3>Value</h3>

<p><code><a href="#topic+GeDSgam-Class">GeDSgam-Class</a></code> object, i.e. a list of items that
summarizes the main details of the fitted GAM-GeDS model. See
<code><a href="#topic+GeDSgam-Class">GeDSgam-Class</a></code> for details. Some S3 methods are available in
order to make these objects tractable, such as
<code><a href="#topic+coef.GeDSgam">coef</a></code>, <code><a href="#topic+knots.GeDSgam">knots</a></code>,
<code><a href="#topic+print.GeDSgam">print</a></code> and <code><a href="#topic+predict.GeDSgam">predict</a></code>.
</p>


<h3>References</h3>

<p>Hastie, T. and Tibshirani, R. (1986). Generalized Additive Models.
<em>Statistical Science</em> <strong>1 (3)</strong> 297 - 310. <br />
DOI: <a href="https://doi.org/10.1214/ss/1177013604">doi:10.1214/ss/1177013604</a>
</p>
<p>Kaishev, V.K., Dimitrova, D.S., Haberman, S. and Verrall, R.J. (2016).
Geometrically designed, variable knot regression splines.
<em>Computational Statistics</em>, <strong>31</strong>, 1079&ndash;1105. <br />
DOI: <a href="https://doi.org/10.1007/s00180-015-0621-7">doi:10.1007/s00180-015-0621-7</a>
</p>
<p>Dimitrova, D. S., Kaishev, V. K., Lattuada, A. and Verrall, R. J.  (2023).
Geometrically designed variable knot splines in generalized (non-)linear
models.
<em>Applied Mathematics and Computation</em>, <strong>436</strong>. <br />
DOI: <a href="https://doi.org/10.1016/j.amc.2022.127493">doi:10.1016/j.amc.2022.127493</a>
</p>
<p>Dimitrova, D. S., Kaishev, V. K. and Saenz Guillen, E. L. (2025).
<span class="pkg">GeDS</span>: An R Package for Regression, Generalized Additive
Models and Functional Gradient Boosting, based on Geometrically Designed
(GeD) Splines. <em>Manuscript submitted for publication.</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NGeDS">NGeDS</a></code>; <code><a href="#topic+GGeDS">GGeDS</a></code>; <code><a href="#topic+GeDSgam-Class">GeDSgam-Class</a></code>;
S3 methods such as <code><a href="#topic+knots.GeDSgam">knots.GeDSgam</a></code>; <code><a href="#topic+coef.GeDSgam">coef.GeDSgam</a></code>;
<code><a href="#topic+deviance.GeDSgam">deviance.GeDSgam</a></code>; <code><a href="#topic+predict.GeDSgam">predict.GeDSgam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Load package
library(GeDS) 

data(airquality) 
data = na.omit(airquality)
data$Ozone &lt;- data$Ozone^(1/3)

formula = Ozone ~ f(Solar.R) + f(Wind, Temp)
Gmodgam &lt;- NGeDSgam(formula = formula, data = data,
phi = 0.8)
MSE_Gmodgam_linear &lt;- mean((data$Ozone - Gmodgam$predictions$pred_linear)^2)
MSE_Gmodgam_quadratic &lt;- mean((data$Ozone - Gmodgam$predictions$pred_quadratic)^2)
MSE_Gmodgam_cubic &lt;- mean((data$Ozone - Gmodgam$predictions$pred_cubic)^2)

cat("\n", "MEAN SQUARED ERROR", "\n",
"Linear NGeDSgam:", MSE_Gmodgam_linear, "\n",
"Quadratic NGeDSgam:", MSE_Gmodgam_quadratic, "\n",
"Cubic NGeDSgam:", MSE_Gmodgam_cubic, "\n")

## S3 methods for class 'GeDSboost'
# Print 
print(Gmodgam)
# Knots
knots(Gmodgam, n = 2L)
knots(Gmodgam, n = 3L)
knots(Gmodgam, n = 4L)
# Coefficients
coef(Gmodgam, n = 2L)
coef(Gmodgam, n = 3L)
coef(Gmodgam, n = 4L)
# Deviances
deviance(Gmodgam, n = 2L)
deviance(Gmodgam, n = 3L)
deviance(Gmodgam, n = 4L)

</code></pre>

<hr>
<h2 id='plot+2CGeDS-method'>Plot method for GeDS objects.</h2><span id='topic+plot+2CGeDS-method'></span><span id='topic+plot.GeDS'></span><span id='topic+plot+2CGeDS+2CANY-method'></span>

<h3>Description</h3>

<p>Plot method for GeDS objects. Plots GeDS fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GeDS,ANY'
plot(
  x,
  f = NULL,
  which,
  DEV = FALSE,
  ask = FALSE,
  main,
  legend.pos = "topright",
  legend.text = NULL,
  new.window = FALSE,
  wait = 0.5,
  n = 3L,
  type = c("none", "Polygon", "NCI", "ACI"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot+2B2CGeDS-method_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+GeDS-class">GeDS-class</a></code> object from which the GeDS fit(s) should
be extracted.</p>
</td></tr>
<tr><td><code id="plot+2B2CGeDS-method_+3A_f">f</code></td>
<td>
<p>(optional) specifies the underlying function or generating process
to which the model was fit. This parameter is useful if the user wishes to
plot the specified function/process alongside the model fit and the data</p>
</td></tr>
<tr><td><code id="plot+2B2CGeDS-method_+3A_which">which</code></td>
<td>
<p>a numeric vector specifying the iterations of stage A for which
the corresponding GeDS fits should be plotted.
It has to be a subset of  <code>1:nrow(x$stored)</code>. See details.</p>
</td></tr>
<tr><td><code id="plot+2B2CGeDS-method_+3A_dev">DEV</code></td>
<td>
<p>logical variable specifying whether a plot representing the
deviance at each iteration of stage A should be produced or not.</p>
</td></tr>
<tr><td><code id="plot+2B2CGeDS-method_+3A_ask">ask</code></td>
<td>
<p>logical variable specifying whether the user should be prompted
before changing the plot page.</p>
</td></tr>
<tr><td><code id="plot+2B2CGeDS-method_+3A_main">main</code></td>
<td>
<p>an optional character string used as the plot title. If set to
'&quot;detail&quot;', the knots vector will be displayed on the plot.</p>
</td></tr>
<tr><td><code id="plot+2B2CGeDS-method_+3A_legend.pos">legend.pos</code></td>
<td>
<p>the position of the legend within the panel. See
<a href="graphics.html#topic+legend">legend</a> for details.</p>
</td></tr>
<tr><td><code id="plot+2B2CGeDS-method_+3A_legend.text">legend.text</code></td>
<td>
<p>a character vector specifying the legend text.</p>
</td></tr>
<tr><td><code id="plot+2B2CGeDS-method_+3A_new.window">new.window</code></td>
<td>
<p>logical variable specifying whether the plot should be
shown in a new window or in the active one.</p>
</td></tr>
<tr><td><code id="plot+2B2CGeDS-method_+3A_wait">wait</code></td>
<td>
<p>time, in seconds, the system should wait before plotting a new
page. Ignored if <code>ask = TRUE</code>.</p>
</td></tr>
<tr><td><code id="plot+2B2CGeDS-method_+3A_n">n</code></td>
<td>
<p>integer value (2, 3 or 4) specifying the order (<code class="reqn">=</code> degree
<code class="reqn">+ 1</code>) of the GeDS fit that should be plotted. By default equal to
<code>3L</code>. Non-integer values will be passed to the function
<code><a href="base.html#topic+as.integer">as.integer</a></code>.</p>
</td></tr>
<tr><td><code id="plot+2B2CGeDS-method_+3A_type">type</code></td>
<td>
<p>character string specifying the type of plot required. Should be
set either to <code>"Polygon"</code> if the user wants to get also the control
polygon of the GeDS fit,  <code>"NCI"</code> or  <code>"ACI"</code> if 95% confidence
bands for the predictions should be plotted (see details) or <code>"none"</code> if
only the fitted GeDS curve should be plotted. Applies only when plotting a
univariate spline regression.</p>
</td></tr>
<tr><td><code id="plot+2B2CGeDS-method_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the
<code><a href="graphics.html#topic+plot.default">plot.default</a></code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method is provided in order to allow the user to plot the GeDS  fits
contained in the <code><a href="#topic+GeDS-Class">GeDS-Class</a></code> objects.
</p>
<p>Since in Stage A of the GeDS algorithm the knots of a linear spline fit are
sequentially located, one at a time, the user may wish to visually inspect
this process using the argument <code>which</code>. The latter specifies a
particular iteration number (or a vector of such numbers) for which the
corresponding linear fit(s) should be plotted. The <code>ask</code> and <code>wait</code>
arguments can help the user to manage these pages.
</p>
<p>By means of <code>ask</code> the user can determine for how long each page should
appear on the screen. Pages are sequentially replaced by pressing the enter
button.
</p>
<p>Note that, in order to ensure stability, if the object was produced by the
function <code><a href="#topic+GGeDS">GGeDS</a></code>, plotting intermediate fits of stage A is
allowed  only if <code>n = 2</code>, in contrast to objects produced by 
<code><a href="#topic+NGeDS">NGeDS</a></code> for which plotting intermediate results is allowed also
for <code>n = </code>2 or 3 results.
</p>
<p>The confidence intervals obtained by setting <code>type = "NCI"</code> are
approximate local bands obtained considering the knots as fixed constants.
Hence the columns of the design matrix are seen as covariates and standard
methodology relying on the <code>se.fit</code> option of <code>predict.lm</code> or
<code>predict.glm</code> is applied.
</p>
<p>Setting <code>type = "ACI"</code>, asymptotic confidence intervals are plotted.
This option is applicable only if the canonical link function has been used
in the fitting procedure.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NGeDS">NGeDS</a></code> and <code><a href="#topic+GGeDS">GGeDS</a></code>;
<code><a href="graphics.html#topic+plot">plot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###################################################
# Generate a data sample for the response variable
# Y and the single covariate X, assuming Normal noise
set.seed(123)
N &lt;- 500
f_1 &lt;- function(x) (10*x/(1+100*x^2))*4+4
X &lt;- sort(runif(N, min = -2, max = 2))
# Specify a model for the mean of Y to include only a component
# non-linear in X, defined by the function f_1
means &lt;- f_1(X)
# Add (Normal) noise to the mean of Y
Y &lt;- rnorm(N, means, sd = 0.1)

# Fit a Normal GeDS regression using NGeDS
(Gmod &lt;- NGeDS(Y ~ f(X), beta = 0.6, phi = 0.995, Xextr = c(-2,2)))

# Plot the final quadratic GeDS fit (red solid line)
# with its control polygon (blue dashed line)
plot(Gmod)

# Plot the quadratic fit obtained from the linear fit at the 10th
# iteration of stage A i.e. after 9 internal knots have been inserted
# by the GeDS procedure
plot(Gmod, which=10)

# Generate plots of all the intermediate fits obtained
# by running the GeDS procedure
## Not run: 
plot(Gmod, which=1:16)

## End(Not run)

###################################################
# Generate a data sample for the response variable Y and the covariate
# X assuming Poisson distributed error and a log link function

set.seed(123)
N &lt;- 500
f_1 &lt;- function(x) (10*x/(1+100*x^2))*4+4
X &lt;- sort(runif(N ,min = -2, max = 2))
# Specify a model for the mean of Y to include only a component
# non-linear in X, defined by the function f_1
means &lt;- exp(f_1(X))
# Generate Poisson distributed Y according to the mean model
Y &lt;- rpois(N,means)

# Fit a Poisson GeDS regression model using GGeDS
(Gmod2 &lt;- GGeDS(Y ~ f(X), beta = 0.2, phi = 0.995, family = poisson(),
                Xextr = c(-2,2)))

# similar plots as before, but for the linear fit
plot(Gmod2, n = 2)
plot(Gmod2, which = 10, n = 2)
## Not run: 
plot(Gmod2, which = 1:16, n = 2)
plot(Gmod2, which = 1:16, n = 2, ask = T)

## End(Not run)

</code></pre>

<hr>
<h2 id='plot+2CGeDSboost-method'>Plot method for GeDSboost objects.</h2><span id='topic+plot+2CGeDSboost-method'></span><span id='topic+plot.GeDSboost'></span><span id='topic+plot+2CGeDSboost+2CANY-method'></span>

<h3>Description</h3>

<p>Plots the component functions of a GeDSboost object fitted using
<code><a href="#topic+NGeDSboost">NGeDSboost</a></code>. If the model has a single base-learner, the plot
will be returned on the response scale. Otherwise, plots are produced on the
linear predictor scale. Note that only univariate base-learner plots are
returned, as representation of the boosted model as a single spline model is
available only for univariate base-learners (see Dimitrova et al. (2025)). In
addition since component-wise gradient boosting inherently performs base-learner
selection, you should only expect plots for the base-learners that where selected
across the boosting iterations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GeDSboost,ANY'
plot(x, n = 3L, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot+2B2CGeDSboost-method_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+GeDSboost-class">GeDSboost-class</a></code> object from which the GeDSboost fit
should be extracted.</p>
</td></tr>
<tr><td><code id="plot+2B2CGeDSboost-method_+3A_n">n</code></td>
<td>
<p>integer value (2, 3 or 4) specifying the order (<code class="reqn">=</code> degree
<code class="reqn">+ 1</code>) of the FGB-GeDS fit to be extracted.</p>
</td></tr>
<tr><td><code id="plot+2B2CGeDSboost-method_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the
<code><a href="graphics.html#topic+plot.default">plot.default</a></code> function.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Dimitrova, D. S., Kaishev, V. K. and Saenz Guillen, E. L. (2025).
<span class="pkg">GeDS</span>: An R Package for Regression, Generalized Additive
Models and Functional Gradient Boosting, based on Geometrically Designed
(GeD) Splines. <em>Manuscript submitted for publication.</em>
</p>

<hr>
<h2 id='plot+2CGeDSgam-method'>Plot method for GeDSgam objects.</h2><span id='topic+plot+2CGeDSgam-method'></span><span id='topic+plot.GeDSgam'></span><span id='topic+plot+2CGeDSgam+2CANY-method'></span>

<h3>Description</h3>

<p>Plots on the linear predictor scale the component functions of a GeDSgam
object fitted using <code><a href="#topic+NGeDSgam">NGeDSgam</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'GeDSgam,ANY'
plot(x, base_learners = NULL, f = NULL, n = 3L, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot+2B2CGeDSgam-method_+3A_x">x</code></td>
<td>
<p>a <code><a href="#topic+GeDSgam-class">GeDSgam-class</a></code> object from which the GeDSgam fit(s) should
be extracted.</p>
</td></tr>
<tr><td><code id="plot+2B2CGeDSgam-method_+3A_base_learners">base_learners</code></td>
<td>
<p>either NULL or a vector of character string specifying
the base-learners of the model for which predictions should be plotted. Note
that single base-learner predictions are provided on the linear predictor scale.</p>
</td></tr>
<tr><td><code id="plot+2B2CGeDSgam-method_+3A_f">f</code></td>
<td>
<p>(optional) specifies the underlying component function or generating
process to which the model was fit. This parameter is useful if the user wishes
to plot the specified function/process alongside the model fit and the data.</p>
</td></tr>
<tr><td><code id="plot+2B2CGeDSgam-method_+3A_n">n</code></td>
<td>
<p>integer value (2, 3 or 4) specifying the order (<code class="reqn">=</code> degree
<code class="reqn">+ 1</code>) of the GAM-GeDS fit.</p>
</td></tr>
<tr><td><code id="plot+2B2CGeDSgam-method_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to the
<code><a href="graphics.html#topic+plot.default">plot.default</a></code> function.</p>
</td></tr>
</table>

<hr>
<h2 id='PPolyInv'>Inversion the piecewise polynomial representation of a spline object</h2><span id='topic+PPolyInv'></span>

<h3>Description</h3>

<p>Computes the inverse mapping of a piecewise polynomial spline object. Given a
strictly monotonic spline (produced by <code><a href="#topic+PPolyRep">PPolyRep</a></code> or similar),
the function returns the corresponding predictor values for a new set of
response values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PPolyInv(ppoly, y_new)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PPolyInv_+3A_ppoly">ppoly</code></td>
<td>
<p>A spline object of class <code>"npolySpline"</code>, <code>"polySpline"</code>,
or <code>"spline"</code> that represents a piecewise polynomial form. The spline must be
strictly monotonic (either increasing or decreasing) to allow for inversion.</p>
</td></tr>
<tr><td><code id="PPolyInv_+3A_y_new">y_new</code></td>
<td>
<p>A numeric vector of response values for which the corresponding predictor
values are sought.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>PPolyInv</code> first verifies that the supplied <code>ppoly</code> object is
invertible by checking its strict monotonicity via the helper function
<code>is_invertible</code>. If the spline is not strictly monotonic, the function
stops with an error.
</p>
<p>The function extracts the knot locations and polynomial coefficients from
<code>ppoly</code> to build a data frame of polynomial segments. For each value in
<code>y_new</code>, it identifies the correct interval and uses the helper function
<code>solve_x</code> to solve the corresponding polynomial equation for the
predictor value.
</p>


<h3>Value</h3>

<p>A numeric vector (or column matrix) of predictor values corresponding to the
input <code>y_new</code> values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a data sample for the response variable
# Y and the single covariate X
set.seed(123)
N &lt;- 1000
f_1 &lt;- function(x) x^3
X &lt;- sort(runif(N, min = -5, max = -3))
# Specify a model for the mean of Y to include only a component
# non-linear in X, defined by the function f_1
means &lt;- f_1(X)
# Add (Normal) noise to the mean of Y
Y &lt;- rnorm(N, means, sd = 0.2)

Gmod &lt;- NGeDS(Y ~ f(X), phi = 0.9)

plot(Gmod)

# Convert GeDS fit to a cubic piecewise polynomial representation
ppoly &lt;- PPolyRep(Gmod, n = 4)
# Invert the spline using predicted values to recover predictor values
pred_new &lt;- Gmod$Cubic.Fit$Predicted
X_new &lt;- PPolyInv(ppoly, pred_new)
# Compare recovered predictors to original values (differences should be near 0)
as.numeric(round(X_new - X, 4)) 

</code></pre>

<hr>
<h2 id='PPolyRep'>Piecewise Polynomial Spline Representation</h2><span id='topic+PPolyRep'></span>

<h3>Description</h3>

<p>The function converts a GeDS fit which has a  B-spline representation to a
piecewise polynomial form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PPolyRep(object, n = 3)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PPolyRep_+3A_object">object</code></td>
<td>
<p>the <code><a href="#topic+GeDS-class">GeDS-class</a></code> where the GeDS fit to be
converted is found.</p>
</td></tr>
<tr><td><code id="PPolyRep_+3A_n">n</code></td>
<td>
<p>integer value (2, 3 or 4) specifying the order (<code class="reqn">=</code> degree
<code class="reqn">+ 1</code>) of the GeDS fit which should be converted to a piecewise
polynomial form. By default equal to <code>3L</code>. Non-integer values will be
passed to the function <code><a href="base.html#topic+as.integer">as.integer</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function converts a selected GeDS fit from a <code><a href="#topic+GeDS-class">GeDS-class</a></code>
object represented in terms of B-splines into an object where the fit is
represented in terms of piecewise polynomials.
</p>
<p>The function  wraps <code><a href="splines.html#topic+polySpline">polySpline</a></code> in order to let it 
accept <code><a href="#topic+GeDS-class">GeDS-class</a></code> objects as input. Hence the function provides
a useful link between the package <span class="pkg">GeDS</span> and the package <span class="pkg">splines</span>,
allowing the user to take advantage of the functions provided in the
<span class="pkg">splines</span> package.
</p>


<h3>Value</h3>

<p>An object that inherits from classes  <code>"spline"</code> and
<code>"polySpline"</code>. It is a list whose arguments are:
</p>
<table role = "presentation">
<tr><td><code>knots</code></td>
<td>
<p> a vector of size  <code class="reqn">k + 2</code> containing the complete set of 
knots (internal knots plus the limits of the interval) of the GeDS fit.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p> a <code class="reqn">(k + 2) \times n</code> matrix containing the
coefficients of the  polynomials in the required piecewise polynomial
representation. </p>
</td></tr>
</table>


<h3>Note</h3>

<p>Let us note that the first <code class="reqn">k+1</code> rows of the matrix contain the
<code>n</code> coefficients of the <code class="reqn">k+1</code> consecutive pieces of the piecewise
polynomial representation. The last <code class="reqn">(k+2)</code>-th row is extraneous and it
appears as a result of the use of the function
<code><a href="splines.html#topic+polySpline">polySpline</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate a data sample for the response variable
# Y and the single covariate X
set.seed(123)
N &lt;- 500
f_1 &lt;- function(x) (10*x/(1+100*x^2))*4+4
X &lt;- sort(runif(N, min = -2, max = 2))
# Specify a model for the mean of Y to include only
# a component non-linear in X, defined by the function f_1
means &lt;- f_1(X)
# Add (Normal) noise to the mean of Y
Y &lt;- rnorm(N, means, sd = 0.1)

# Fit a Normal GeDS regression using NGeDS
Gmod &lt;- NGeDS(Y ~ f(X), beta = 0.6, phi = 0.995, Xextr = c(-2,2))

# construct the PP representation of the cubic GeDS fit
# and apply some functions of the package splines
Polymod &lt;- PPolyRep(Gmod, 4)
require(splines)
class(Polymod)
splineKnots(Polymod)
knots(Gmod, n = 4)
plot(Polymod)


# Generate a plot showing the PP representation
# based on the same example
knt &lt;- splineKnots(Polymod)
coeffs &lt;- coef(Polymod)
plot(Gmod, n = 4, legend.pos = FALSE, main = "Cubic Curves")
cols &lt;- sample(heat.colors(length(knt)), length(knt))
for(i in 1:(length(knt))){
  curve(coeffs[i,1] + coeffs[i,2]*(x - knt[i])+
          coeffs[i,3]*(x - knt[i])^2+
        coeffs[i,4]*(x - knt[i])^3,
        add = TRUE, col = cols[i])
  abline(v = knt[i])
}

</code></pre>

<hr>
<h2 id='predict.GeDS'>Predict method for GeDS objects</h2><span id='topic+predict.GeDS'></span>

<h3>Description</h3>

<p>This is a user friendly method to compute predictions from GeDS objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GeDS'
predict(object, newdata, type = c("response", "link", "terms"), n = 3L, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.GeDS_+3A_object">object</code></td>
<td>
<p>the <code><a href="#topic+GeDS-class">GeDS-class</a></code> object for which the
computation of the predicted values is required.</p>
</td></tr>
<tr><td><code id="predict.GeDS_+3A_newdata">newdata</code></td>
<td>
<p>an optional <code>data.frame</code>, <code>list</code> or
<code>environment</code> containing values of the independent variables for  which
predicted values of the predictor model (including the GeDS and the
parametric components) should be computed. If left empty the values are
extracted from the object <code>x</code> itself.</p>
</td></tr>
<tr><td><code id="predict.GeDS_+3A_type">type</code></td>
<td>
<p>character string indicating the type of prediction required. By
default it is equal to <code>"response"</code>, i.e. the result is on the scale of
the response variable. See details for the other options.</p>
</td></tr>
<tr><td><code id="predict.GeDS_+3A_n">n</code></td>
<td>
<p>integer value (2, 3 or 4) specifying the order (<code class="reqn">=</code> degree
<code class="reqn"> + 1</code>) of the GeDS fit whose predicted values should be computed. By
default equal to <code>3L</code>. Non-integer values will be passed to the function
<code><a href="base.html#topic+as.integer">as.integer</a></code>.</p>
</td></tr>
<tr><td><code id="predict.GeDS_+3A_...">...</code></td>
<td>
<p>potentially further arguments (required by the definition of the
generic function). They are ignored, but with a warning.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a method for the function <code><a href="stats.html#topic+predict">predict</a></code> that allows
the user to handle <code><a href="#topic+GeDS-Class">GeDS-Class</a></code> objects.
</p>
<p>In analogy with the function <code><a href="stats.html#topic+predict.glm">predict.glm</a></code> in the
<span class="pkg">stats</span> package, the user can specify the scale on which the predictions
should be computed through the argument <code>type</code>. If the predictions are
required to be on the scale of the response variable, the user should set
<code>type = "response"</code>, which is the default. Alternatively if one wants
the predictions to be on the predictor scale, it is necessary to set
<code>type = "link"</code>.
By specifying <code>type = "terms"</code>, it is possible to inspect the predicted
values separately for each single independent variable which enter either the
GeD spline component or the parametric component of the predictor model. In
this case the returned result is a matrix whose columns correspond to the
terms supplied via <code>newdata</code> or extracted from the <code>object</code>.
</p>
<p>As GeDS objects contain three different fits (linear, quadratic and cubic),
it is possible to specify the order for which GeDS predictions are required
via the input argument <code>n</code>.
</p>


<h3>Value</h3>

<p>A numeric vector corresponding to the predicted values (if
<code>type = "link"</code> or <code>type = "response"</code>). If <code>type = "terms"</code> a
numeric matrix with a column per term.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+predict">predict</a></code> for the standard definition;
<code><a href="#topic+GGeDS">GGeDS</a></code> for examples.
</p>

<hr>
<h2 id='predict.GeDSboost+2Cgam'>Predict method for GeDSboost, GeDSgam</h2><span id='topic+predict.GeDSboost+2Cgam'></span><span id='topic+predict.GeDSboost'></span><span id='topic+predict.GeDSboost+2C'></span><span id='topic+predict.GeDSgam'></span>

<h3>Description</h3>

<p>This method computes predictions from GeDSboost and GeDSgam objects. 
It is designed to be user-friendly and accommodate different orders of the
GeDSboost or GeDSgam fits.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GeDSboost'
predict(object, newdata, n = 3L, base_learner = NULL, ...)

## S3 method for class 'GeDSgam'
predict(object, newdata, n = 3L, base_learner = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.GeDSboost+2B2Cgam_+3A_object">object</code></td>
<td>
<p>the <code><a href="#topic+GeDSboost-class">GeDSboost-class</a></code> or
<code><a href="#topic+GeDSgam-class">GeDSgam-class</a></code> object.</p>
</td></tr>
<tr><td><code id="predict.GeDSboost+2B2Cgam_+3A_newdata">newdata</code></td>
<td>
<p>an optional data frame for prediction.</p>
</td></tr>
<tr><td><code id="predict.GeDSboost+2B2Cgam_+3A_n">n</code></td>
<td>
<p>the order of the GeDS fit (<code>2L</code> for linear, <code>3L</code> for
quadratic, and <code>4L</code> for cubic). Default is <code>3L</code>.</p>
</td></tr>
<tr><td><code id="predict.GeDSboost+2B2Cgam_+3A_base_learner">base_learner</code></td>
<td>
<p>either <code>NULL</code> or a <code>character</code> string specifying
the base-learner of the model for which predictions should be computed. Note
that single base-learner predictions are provided on the linear predictor scale.</p>
</td></tr>
<tr><td><code id="predict.GeDSboost+2B2Cgam_+3A_...">...</code></td>
<td>
<p>potentially further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector of predictions (vector of means).
</p>


<h3>References</h3>

<p>Gu, C. and Wahba, G. (1991).
Minimizing GCV/GML Scores with Multiple Smoothing Parameters via the Newton Method.
<em>SIAM J. Sci. Comput.</em>, <strong>12</strong>, 383&ndash;398.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Gu and Wahba 4 univariate term example ##
# Generate a data sample for the response variable
# y and the covariates x0, x1 and x2; include a noise predictor x3
set.seed(123)
N &lt;- 400
f_x0x1x2 &lt;- function(x0,x1,x2) {
  f0 &lt;- function(x0) 2 * sin(pi * x0)
  f1 &lt;- function(x1) exp(2 * x1)
  f2 &lt;- function(x2) 0.2 * x2^11 * (10 * (1 - x2))^6 + 10 * (10 * x2)^3 * (1 - x2)^10
  f &lt;- f0(x0) + f1(x1) + f2(x2)
  return(f)
}
x0 &lt;- runif(N, 0, 1)
x1 &lt;- runif(N, 0, 1)
x2 &lt;- runif(N, 0, 1)
x3 &lt;- runif(N, 0, 1)
# Specify a model for the mean of y
f &lt;- f_x0x1x2(x0 = x0, x1 = x1, x2 = x2)
# Add (Normal) noise to the mean of y
y &lt;- rnorm(N, mean = f, sd = 0.2)
data &lt;- data.frame(y = y, x0 = x0, x1 = x1, x2 = x2, x3 = x3)

# Fit a GeDSgam model
Gmodgam &lt;- NGeDSgam(y ~ f(x0) + f(x1) + f(x2) + f(x3), data = data)
# Check that the sum of the individual base-learner predictions equals the final
# model prediction

pred0 &lt;- predict(Gmodgam, n = 2, newdata = data, base_learner = "f(x0)")
pred1 &lt;- predict(Gmodgam, n = 2, newdata = data, base_learner = "f(x2)")
pred2 &lt;- predict(Gmodgam, n = 2, newdata = data, base_learner = "f(x1)")
pred3 &lt;- predict(Gmodgam, n = 2, newdata = data, base_learner = "f(x3)")
round(predict(Gmodgam, n = 2, newdata = data) -
(mean(predict(Gmodgam, n = 2, newdata = data)) + pred0 + pred1 + pred2 + pred3), 12)

pred0 &lt;- predict(Gmodgam, n = 3, newdata = data, base_learner = "f(x0)")
pred1 &lt;- predict(Gmodgam, n = 3, newdata = data, base_learner = "f(x2)")
pred2 &lt;- predict(Gmodgam, n = 3, newdata = data, base_learner = "f(x1)")
pred3 &lt;- predict(Gmodgam, n = 3, newdata = data, base_learner = "f(x3)")

round(predict(Gmodgam, n = 3, newdata = data) - (pred0 + pred1 + pred2 + pred3), 12)

pred0 &lt;- predict(Gmodgam, n = 4, newdata = data, base_learner = "f(x0)")
pred1 &lt;- predict(Gmodgam, n = 4, newdata = data, base_learner = "f(x2)")
pred2 &lt;- predict(Gmodgam, n = 4, newdata = data, base_learner = "f(x1)")
pred3 &lt;- predict(Gmodgam, n = 4, newdata = data, base_learner = "f(x3)")

round(predict(Gmodgam, n = 4, newdata = data) - (pred0 + pred1 + pred2 + pred3), 12)

# Plot GeDSgam partial fits to f(x0), f(x1), f(x2)
par(mfrow = c(1,3))
for (i in 1:3) {
  # Plot the base learner
  plot(Gmodgam, n = 3, base_learners = paste0("f(x", i-1, ")"), col = "seagreen",
       cex.lab = 1.5, cex.axis = 1.5)
  # Add legend
  if (i == 2) {
    position &lt;- "topleft"
    } else if (i == 3) {
      position &lt;- "topright"
      } else {
        position &lt;- "bottom"
      }
  legend(position, legend = c("GAM-GeDS Quadratic", paste0("f(x", i-1, ")")),
         col = c("seagreen", "darkgray"),
         lwd = c(2, 2),
         bty = "n",
         cex = 1.5)
}

</code></pre>

<hr>
<h2 id='print.GeDS'>Print method for GeDS, GeDSboost, GeDSgam</h2><span id='topic+print.GeDS'></span><span id='topic+print.GeDSboost'></span><span id='topic+print.GeDSgam'></span>

<h3>Description</h3>

<p>Method for the generic function <code><a href="base.html#topic+print">print</a></code> that allows to
print on screen the main information related to the fitted predictor model
that can be extracted from a <code><a href="#topic+GeDS-class">GeDS-class</a></code>,
<code><a href="#topic+GeDSboost-class">GeDSboost-class</a></code> or <code><a href="#topic+GeDSgam-class">GeDSgam-class</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GeDS'
print(x, digits = max(3L, getOption("digits") - 3L), ...)

## S3 method for class 'GeDSboost'
print(x, digits = max(3L, getOption("digits") - 3L), ...)

## S3 method for class 'GeDSgam'
print(x, digits = max(3L, getOption("digits") - 3L), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.GeDS_+3A_x">x</code></td>
<td>
<p>the <code><a href="#topic+GeDS-class">GeDS-class</a></code>, <code><a href="#topic+GeDSboost-class">GeDSboost-class</a></code> or
<code><a href="#topic+GeDSgam-class">GeDSgam-class</a></code> object for which the main information should be
printed on screen.</p>
</td></tr>
<tr><td><code id="print.GeDS_+3A_digits">digits</code></td>
<td>
<p>number of digits to be printed.</p>
</td></tr>
<tr><td><code id="print.GeDS_+3A_...">...</code></td>
<td>
<p>potentially further arguments (required by the definition of the
generic function).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method allows to print on screen basic information related to the fitted
predictor model such as the function <code>call</code>, the number of internal
knots for the linear GeDS/FGB-GeDS/GAM-GeDS fit and the deviances for the
three (linear, quadratic and cubic) fitted predictor models embedded in the
<code><a href="#topic+GeDSboost-class">GeDSboost-class</a></code> or <code><a href="#topic+GeDSgam-class">GeDSgam-class</a></code> object.
</p>


<h3>Value</h3>

<p>This function returns (invisibly) the same input object, but adding
the slot <code>Print</code> that contains the three sub-slots:
</p>
<table role = "presentation">
<tr><td><code>Nknots</code></td>
<td>
<p> the number of internal knots of the linear
GeDS/FGB-GeDS/GAM-GeDS fit</p>
</td></tr>
<tr><td><code>Deviances</code></td>
<td>
<p> the deviances of the three (linear, quadratic and cubic)
GeDS/FGB-GeDS/GAM-GeDS fits</p>
</td></tr>
<tr><td><code>Call</code></td>
<td>
<p> the <code>call</code> to the function that produced the <code>x</code>
object</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print">print</a></code> for the standard definition.
</p>

<hr>
<h2 id='SplineReg'>Estimation of the coefficients of a predictor model with spline and
possibly parametric components.</h2><span id='topic+SplineReg'></span><span id='topic+SplineReg_LM'></span><span id='topic+SplineReg_GLM'></span>

<h3>Description</h3>

<p>Functions that estimate the coefficients of a predictor model involving a
spline component and possibly a parametric component applying (Iteratively
Re-weighted) Least Squares (IR)LS iteration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SplineReg_LM(
  X,
  Y,
  Z = NULL,
  offset = rep(0, length(X)),
  weights = rep(1, length(X)),
  InterKnots,
  n,
  extr = range(X),
  prob = 0.95,
  coefficients = NULL,
  only_pred = FALSE
)

SplineReg_GLM(
  X,
  Y,
  Z,
  offset = rep(0, nobs),
  weights = rep(1, length(X)),
  InterKnots,
  n,
  extr = range(X),
  family,
  mustart,
  inits = NULL,
  etastart = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SplineReg_+3A_x">X</code></td>
<td>
<p>a numeric vector containing <code class="reqn">N</code> sample values of the covariate
chosen to enter the spline regression component of the predictor model.</p>
</td></tr>
<tr><td><code id="SplineReg_+3A_y">Y</code></td>
<td>
<p>a vector of size <code class="reqn">N</code> containing the observed values of the
response variable <code class="reqn">y</code>.</p>
</td></tr>
<tr><td><code id="SplineReg_+3A_z">Z</code></td>
<td>
<p>a design matrix with <code class="reqn">N</code> rows containing other covariates
selected to enter the parametric component of the predictor model (see
<code><a href="#topic+formula.GeDS">formula</a></code>). If no such covariates are selected,
it is set to <code>NULL</code> by default.</p>
</td></tr>
<tr><td><code id="SplineReg_+3A_offset">offset</code></td>
<td>
<p>a vector of size <code class="reqn">N</code> that can be used to specify a fixed
covariate to be included in the predictor model avoiding the estimation of
its corresponding regression coefficient. In case  more than one covariate is
fixed, the user should sum the corresponding coordinates of the fixed
covariates to produce one common <code class="reqn">N</code>-vector of coordinates. The argument
<code>offset</code> is particularly useful in <code>Splinereg_GLM</code> if the link
function used is not the identity.</p>
</td></tr>
<tr><td><code id="SplineReg_+3A_weights">weights</code></td>
<td>
<p>an optional vector of &lsquo;prior weights&rsquo; to be put on the
observations in the fitting process in case the user requires weighted
fitting. It is a vector of 1s by default.</p>
</td></tr>
<tr><td><code id="SplineReg_+3A_interknots">InterKnots</code></td>
<td>
<p>a numeric vector containing the locations of the internal
knots necessary to compute the B-splines. In GeDS these are the internal
knots in a current iteration of stage A.</p>
</td></tr>
<tr><td><code id="SplineReg_+3A_n">n</code></td>
<td>
<p>integer value specifying  the order of the spline to be evaluated.
It should be 2 (linear spline), 3 (quadratic spline) or 4 (cubic spline).
Non-integer values will be passed to the function <code><a href="base.html#topic+as.integer">as.integer</a></code>.</p>
</td></tr>
<tr><td><code id="SplineReg_+3A_extr">extr</code></td>
<td>
<p>optional numeric vector of 2 elements representing the left-most
and right-most limits of the interval embedding the sample values of
<code>X</code>. By default equal correspondingly to the smallest and largest values
of <code>X</code>.</p>
</td></tr>
<tr><td><code id="SplineReg_+3A_prob">prob</code></td>
<td>
<p>the confidence level to be used for the confidence bands in the
<code>SplineReg_LM</code> fit. See details below.</p>
</td></tr>
<tr><td><code id="SplineReg_+3A_coefficients">coefficients</code></td>
<td>
<p>optional vector of spline coefficients. If provided,
<code>SplineReg</code> computes only the corresponding predicted values.</p>
</td></tr>
<tr><td><code id="SplineReg_+3A_only_pred">only_pred</code></td>
<td>
<p>logical, if <code>TRUE</code> only <code>Theta</code>,
<code>Predicted</code>, <code>Residuals</code> and <code>RSS</code> will be computed.</p>
</td></tr>
<tr><td><code id="SplineReg_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to be
used in the model. This can be a character string naming a family function, a
family function or the result of a call to a family function. See
<code><a href="stats.html#topic+family">family</a></code> for details of family functions.</p>
</td></tr>
<tr><td><code id="SplineReg_+3A_mustart">mustart</code></td>
<td>
<p>initial values for the vector of means in the IRLS estimation.
Must be a vector of length <code class="reqn">N</code>.</p>
</td></tr>
<tr><td><code id="SplineReg_+3A_inits">inits</code></td>
<td>
<p>a numeric vector of length
<code>length(InterKnots) + n + NCOL(Z)</code> providing initial values for the
coefficients, to be used in the IRLS estimation (alternative to providing the
<code>mustart</code> vector).</p>
</td></tr>
<tr><td><code id="SplineReg_+3A_etastart">etastart</code></td>
<td>
<p>initial values for the predictor in the IRLS estimation
(alternative to providing either <code>inits</code> or <code>mustart</code>). Must be a
vector of length <code class="reqn">N</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions estimate the coefficients of a predictor model with a spline
component (and possibly a parametric component) for a given, fixed order and
vector of knots of the spline and a specified distribution of the response
variable (from the Exponential Family). The functions <code>SplineReg_LM</code> and
<code>SplineReg_GLM</code> are based correspondingly on LS and IRLS and used
correspondingly in <code><a href="#topic+NGeDS">NGeDS</a></code> and <code><a href="#topic+GGeDS">GGeDS</a></code>, to estimate
the coefficients of the final GeDS fits of stage B, after their knots have
been positioned to coincide with the Greville abscissas of the knots of the
linear fit from stage A (see Dimitrova et al. 2023). Additional inference
related quantities are also computed (see Value below). The function
<code>SplineReg_GLM</code> is also used to estimate the coefficients of the linear
GeDS fit of stage A within <code><a href="#topic+GGeDS">GGeDS</a></code>, whereas in
<code><a href="#topic+NGeDS">NGeDS</a></code> this estimation is performed internally leading to faster
R code.
</p>
<p>In addition <code>SplineReg_LM</code> computes some useful quantities among which
confidence intervals and the Control Polygon (see Section 2 of
Kaishev et al. 2016).
</p>
<p>The confidence intervals contained in the output slot <code>NCI</code> are
approximate local bands obtained considering the knots as fixed constants.
Hence the columns of the design matrix are seen as covariates and standard
methodology relying on the <code>se.fit</code> option of <code>predict.lm</code> or
<code>predict.glm</code> is used. In the <code>ACI</code> slot, asymptotic confidence
intervals are provided, following Kaishev et al (2006). If the variance
matrix is singular the Moore-Penrose pseudo-inverse is computed instead.
</p>
<p>As mentioned, <code>SplineReg_GLM</code> is intensively used in Stage A of the GeDS
algorithm implemented in <code><a href="#topic+GGeDS">GGeDS</a></code> and in order to make it as fast
as possible input data validation is mild. Hence it is expected that the user
checks carefully the input parameters before using <code>SplineReg_GLM</code>. The
&quot;<code>Residuals</code>&quot; in the output of this function are similar to the so
called &ldquo;working residuals&quot; in the <code><a href="stats.html#topic+glm">glm</a></code> function. 
&quot;<code>Residuals</code>&quot;  are the residuals <code class="reqn">r_i</code> used in the knot placement
procedure, i.e. </p>
<p style="text-align: center;"><code class="reqn">r_i= (y_i - \hat{\mu}_i){d \mu_i \over d \eta_i },</code>
</p>
<p> but
in contrast to <code><a href="stats.html#topic+glm">glm</a></code> &ldquo;working residuals&quot;, they are
computed using the final IRLS fitted <code class="reqn">\hat{\mu}_i</code>. &quot;<code>Residuals</code>&quot;
are then used in locating the knots of the linear spline fit of Stage A.
</p>
<p>In <code>SplineReg_GLM</code> confidence intervals are not computed.
</p>


<h3>Value</h3>

<p>A <code>list</code> containing:
</p>
<table role = "presentation">
<tr><td><code>Theta</code></td>
<td>
<p> a vector containing the fitted coefficients of the spline
regression component and the parametric component of the predictor model.</p>
</td></tr>
<tr><td><code>Predicted</code></td>
<td>
<p> a vector of <code class="reqn">N</code> predicted mean values of the response
variable computed at the sample values of the covariate(s).</p>
</td></tr>
<tr><td><code>Residuals</code></td>
<td>
<p> a vector containing the normal regression residuals if
<code>SplineReg_LM</code> is called or the residuals described in Details if
<code>SplineReg_GLM</code> is called.</p>
</td></tr>
<tr><td><code>RSS</code></td>
<td>
<p> the deviance for the fitted predictor model, defined as in
Dimitrova et al. (2023), which for <code>SplineReg_LM</code> coincides with the
Residual Sum of Squares.</p>
</td></tr>
<tr><td><code>NCI</code></td>
<td>
<p> a list containing the lower (<code>Low</code>) and upper (<code>Upp</code>)
limits of the approximate confidence intervals computed at the sample values
of the covariate(s). See  details above.</p>
</td></tr>
<tr><td><code>Basis</code></td>
<td>
<p> the matrix of B-spline regression functions and the covariates
of the parametric part evaluated at the sample values of the covariate(s).</p>
</td></tr>
<tr><td><code>Polygon</code></td>
<td>
<p> a list containing x-y coordinates (&quot;<code>Kn</code>&quot; and
&quot;<code>Thetas</code>&quot;) of the vertices of the Control Polygon, see
Dimitrova et al. (2023).</p>
</td></tr>
<tr><td><code>deviance</code></td>
<td>
<p> a vector containing deviances computed at each IRLS step
(computed only with the <code>SplineReg_GLM</code>).</p>
</td></tr>
<tr><td><code>temporary</code></td>
<td>
<p> the result of the function <code><a href="stats.html#topic+lm">lm</a></code> if
<code>SplineReg_LM</code> is used or the output of the function
<code><a href="#topic+IRLSfit">IRLSfit</a></code> (which is similar to the output from
<code><a href="stats.html#topic+glm.fit">glm.fit</a></code>), if <code>SplineReg_GLM</code> is used.</p>
</td></tr>
<tr><td><code>ACI</code></td>
<td>
<p> a list containing the lower (<code>Low</code>) and upper (<code>Upp</code>)
limits of the asymptotic confidence intervals computed at the sample values
of the covariate(s).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Kaishev, V. K., Dimitrova, D. S., Haberman, S. &amp; Verrall, R. J. (2006).
Geometrically designed, variable know regression splines: asymptotics and
inference <em>(Statistical Research Paper No. 28)</em>.
London, UK: Faculty of Actuarial Science &amp; Insurance, City University London. <br />
URL: <a href="https://openaccess.city.ac.uk/id/eprint/2372">openaccess.city.ac.uk</a>
</p>
<p>Kaishev, V.K., Dimitrova, D.S., Haberman, S., &amp; Verrall, R.J. (2016).
Geometrically designed, variable knot regression splines.
<em>Computational Statistics</em>, <strong>31</strong>, 1079&ndash;1105. <br />
DOI: <a href="https://doi.org/10.1007/s00180-015-0621-7">doi:10.1007/s00180-015-0621-7</a>
</p>
<p>Dimitrova, D. S., Kaishev, V. K., Lattuada, A. and Verrall, R. J.  (2023).
Geometrically designed variable knot splines in generalized (non-)linear
models. <em>Applied Mathematics and Computation</em>, <strong>436</strong>. <br />
DOI: <a href="https://doi.org/10.1016/j.amc.2022.127493">doi:10.1016/j.amc.2022.127493</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NGeDS">NGeDS</a></code>, <code><a href="#topic+GGeDS">GGeDS</a></code>, <code><a href="#topic+Fitters">Fitters</a></code>,
<code><a href="#topic+IRLSfit">IRLSfit</a></code>, <code><a href="stats.html#topic+lm">lm</a></code> and
<code><a href="stats.html#topic+glm.fit">glm.fit</a></code>.
</p>

<hr>
<h2 id='UnivariateFitters'>Functions used to fit GeDS objects with an univariate spline regression
component</h2><span id='topic+UnivariateFitters'></span><span id='topic+UnivariateFitter'></span><span id='topic+Fitters'></span><span id='topic+GenUnivariateFitter'></span>

<h3>Description</h3>

<p>These are computing engines called by <code><a href="#topic+NGeDS">NGeDS</a></code> and
<code><a href="#topic+GGeDS">GGeDS</a></code>, needed for the underlying fitting procedures.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UnivariateFitter(
  X,
  Y,
  Z = NULL,
  offset = rep(0, NROW(Y)),
  weights = rep(1, length(X)),
  beta = 0.5,
  phi = 0.5,
  min.intknots = 0,
  max.intknots = 300,
  q = 2,
  extr = range(X),
  show.iters = FALSE,
  tol = as.double(1e-12),
  stoptype = c("SR", "RD", "LR"),
  higher_order = TRUE,
  intknots_init = NULL,
  fit_init = NULL,
  only_pred = FALSE
)

GenUnivariateFitter(
  X,
  Y,
  Z = NULL,
  offset = rep(0, NROW(Y)),
  weights = rep(1, length(X)),
  family = gaussian(),
  beta = 0.5,
  phi = 0.5,
  min.intknots = 0,
  max.intknots = 300,
  q = 2,
  extr = range(X),
  show.iters = F,
  tol = as.double(1e-12),
  stoptype = c("SR", "RD", "LR"),
  higher_order = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="UnivariateFitters_+3A_x">X</code></td>
<td>
<p>a numeric vector containing <code class="reqn">N</code> sample values of the covariate
chosen to enter the spline regression component of the predictor model.</p>
</td></tr>
<tr><td><code id="UnivariateFitters_+3A_y">Y</code></td>
<td>
<p>a vector of size <code class="reqn">N</code> containing the observed values of the
response variable <code class="reqn">y</code>.</p>
</td></tr>
<tr><td><code id="UnivariateFitters_+3A_z">Z</code></td>
<td>
<p>a design matrix with <code class="reqn">N</code> rows containing other covariates
selected to enter the parametric component of the predictor model (see
<code><a href="#topic+formula.GeDS">formula</a></code>). If no such covariates are selected, it
is set to <code>NULL</code> by default.</p>
</td></tr>
<tr><td><code id="UnivariateFitters_+3A_offset">offset</code></td>
<td>
<p>a vector of size <code class="reqn">N</code> that can be used to specify a fixed
covariate to be included in the predictor model avoiding the estimation of
its corresponding regression coefficient. In case more than one covariate is
fixed, the user should sum the corresponding coordinates of the fixed
covariates to produce one common <code class="reqn">N</code>-vector of coordinates. The
<code>offset</code> argument is particularly useful when using 
<code>GenUnivariateFitter</code> if the link function used is not the identity.</p>
</td></tr>
<tr><td><code id="UnivariateFitters_+3A_weights">weights</code></td>
<td>
<p>an optional vector of size <code class="reqn">N</code> of &lsquo;prior weights&rsquo; to be
put on the observations in the fitting process in case the user requires
weighted GeDS fitting. It is <code>NULL</code> by default.</p>
</td></tr>
<tr><td><code id="UnivariateFitters_+3A_beta">beta</code></td>
<td>
<p>numeric parameter in the interval <code class="reqn">[0,1]</code> tuning the knot
placement in stage A of GeDS. See the description of <code><a href="#topic+NGeDS">NGeDS</a></code> or
<code><a href="#topic+GGeDS">GGeDS</a></code>.</p>
</td></tr>
<tr><td><code id="UnivariateFitters_+3A_phi">phi</code></td>
<td>
<p>numeric parameter in the interval <code class="reqn">[0,1]</code> specifying the
threshold for the stopping rule  (model selector) in stage A of GeDS. See
also <code>stoptype</code> and details in the description of <code><a href="#topic+NGeDS">NGeDS</a></code> or
<code><a href="#topic+GGeDS">GGeDS</a></code>.</p>
</td></tr>
<tr><td><code id="UnivariateFitters_+3A_min.intknots">min.intknots</code></td>
<td>
<p>optional parameter allowing the user to set a minimum
number of internal knots required. By default equal to zero.</p>
</td></tr>
<tr><td><code id="UnivariateFitters_+3A_max.intknots">max.intknots</code></td>
<td>
<p>optional parameter allowing the user to set a maximum
number of internal knots to be added by the GeDS estimation algorithm. By
default equal to the number of internal knots <code class="reqn">\kappa</code> for the saturated
GeDS model (i.e. <code class="reqn">\kappa=N-2</code>).</p>
</td></tr>
<tr><td><code id="UnivariateFitters_+3A_q">q</code></td>
<td>
<p>numeric parameter which allows to fine-tune the stopping rule of
stage A of GeDS, by default equal to 2. See details in the description of
<code><a href="#topic+NGeDS">NGeDS</a></code> or <code><a href="#topic+GGeDS">GGeDS</a></code>.</p>
</td></tr>
<tr><td><code id="UnivariateFitters_+3A_extr">extr</code></td>
<td>
<p>numeric vector of 2 elements representing the left-most and
right-most limits of the interval embedding the sample values of <code>X</code>. By
default equal correspondingly to the smallest and largest values of <code>X</code>.</p>
</td></tr>
<tr><td><code id="UnivariateFitters_+3A_show.iters">show.iters</code></td>
<td>
<p>logical variable indicating whether or not to print 
information at each step. By default equal to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="UnivariateFitters_+3A_tol">tol</code></td>
<td>
<p>numeric value indicating the tolerance to be used in the knot
placement steps in stage A. By default equal to 1E-12. See details below.</p>
</td></tr>
<tr><td><code id="UnivariateFitters_+3A_stoptype">stoptype</code></td>
<td>
<p>a character string indicating the type of GeDS stopping rule
to be used. It should be either <code>"SR"</code>, <code>"RD"</code> or <code>"LR"</code>,
partial match allowed. See details of <code><a href="#topic+NGeDS">NGeDS</a></code> or
<code><a href="#topic+GGeDS">GGeDS</a></code>.</p>
</td></tr>
<tr><td><code id="UnivariateFitters_+3A_higher_order">higher_order</code></td>
<td>
<p>a logical that defines whether to compute the higher
order fits (quadratic and cubic) after stage A is run. Default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="UnivariateFitters_+3A_intknots_init">intknots_init</code></td>
<td>
<p>vector of initial internal knots from which to start the GeDS
Stage A iterations. See Section 3 of Kaishev et al. (2016). Default is <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="UnivariateFitters_+3A_fit_init">fit_init</code></td>
<td>
<p>A list containing fitted values <code>pred</code>, along with
corresponding <code>intknots</code> and <code>coef</code>, representing the initial fit from
which to begin Stage A GeDS iteration (i.e. departing from step 2).</p>
</td></tr>
<tr><td><code id="UnivariateFitters_+3A_only_pred">only_pred</code></td>
<td>
<p>logical, if <code>TRUE</code> only predictions are computed.</p>
</td></tr>
<tr><td><code id="UnivariateFitters_+3A_family">family</code></td>
<td>
<p>a description of the error distribution and link function to be
used in the model. This can be a character string naming a family function
(e.g. <code>"gaussian"</code>), the family function itself (e.g.
<code><a href="stats.html#topic+gaussian">gaussian</a></code>) or the result of a call to a family function
(e.g. <code>gaussian()</code>). See <a href="stats.html#topic+family">family</a> for details on family
functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions <code>UnivariateFitter</code> and <code>GenUnivariateFitter</code> are in
general not intended to be used directly, they should be called through
<code><a href="#topic+NGeDS">NGeDS</a></code> and <code><a href="#topic+GGeDS">GGeDS</a></code>. However, in case there is a need
for multiple GeDS fitting (as may be the case e.g. in Monte Carlo simulations)
it may be efficient to use the fitters outside the main functions.
</p>
<p>The argument <code>tol</code> is used in the knot placement procedure of stage A of
the GeDS algorithm in order to check whether the current knot <code class="reqn">\delta^*</code> 
is set at an acceptable location or not. If there exists a knot <code class="reqn">\delta_i</code>
such that <code class="reqn">|\delta^* - \delta_i| &lt; </code><code>tol</code>, <code class="reqn">\delta^*</code>, then the
new knot is considered to be coalescent with an existing one, it is discarded
and the algorithm seeks alternative knot locations. By default it is equal to
1e-12.
</p>
<p>See <code><a href="#topic+NGeDS">NGeDS</a></code> and <code><a href="#topic+GGeDS">GGeDS</a></code>, Kaishev et al. (2016) and
Dimitrova et al. (2023) for further details.
</p>


<h3>Value</h3>

<p>A <code><a href="#topic+GeDS-Class">GeDS-Class</a></code> object, but without the <code>Formula</code>,
<code>extcall</code>, <code>terms</code> and <code>znames</code> slots.
</p>


<h3>References</h3>

<p>Kaishev, V.K., Dimitrova, D.S., Haberman, S., &amp; Verrall, R.J. (2016).
Geometrically designed, variable knot regression splines.
<em>Computational Statistics</em>, <strong>31</strong>, 1079&ndash;1105. <br />
DOI: <a href="https://doi.org/10.1007/s00180-015-0621-7">doi:10.1007/s00180-015-0621-7</a>
</p>
<p>Dimitrova, D. S., Kaishev, V. K., Lattuada, A. and Verrall, R. J.  (2023).
Geometrically designed variable knot splines in generalized (non-)linear
models.
<em>Applied Mathematics and Computation</em>, <strong>436</strong>. <br />
DOI: <a href="https://doi.org/10.1016/j.amc.2022.127493">doi:10.1016/j.amc.2022.127493</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+NGeDS">NGeDS</a></code> and <code><a href="#topic+GGeDS">GGeDS</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Examples similar to the ones
# presented in NGeDS and in GGeDS

# Generate a data sample for the response variable
# Y and the covariate X
set.seed(123)
N &lt;- 500
f_1 &lt;- function(x) (10*x/(1+100*x^2))*4+4
X &lt;- sort(runif(N ,min = -2, max = 2))
# Specify a model for the mean of Y to include only
# a component non-linear in X, defined by the function f_1
means &lt;- f_1(X)
# Add (Normal) noise to the mean of Y
Y &lt;- rnorm(N, means, sd = 0.1)

# Fit a Normal GeDS regression model using the fitter function
(Gmod &lt;- UnivariateFitter(X, Y, beta = 0.6, phi = 0.995,
           extr = c(-2,2)))

##############################################################
# second: very similar example, but based on Poisson data
set.seed(123)
X &lt;- sort(runif(N , min = -2, max = 2))
means &lt;- exp(f_1(X))
Y &lt;- rpois(N,means)
(Gmod2 &lt;- GenUnivariateFitter(X, Y, beta = 0.2,
            phi = 0.995, family = poisson(), extr = c(-2,2)))

# a plot showing quadratic and cubic fits,
# in the predictor scale
plot(X,log(Y), xlab = "x", ylab = expression(f[1](x)))
lines(Gmod2, n = 3, col = "red")
lines(Gmod2, n = 4, col = "blue", lty = 2)
legend("topleft", c("Quadratic", "Cubic"),
       col = c("red", "blue"),
       lty = c(1,2))

</code></pre>

<hr>
<h2 id='visualize_boosting'>Visualize Boosting Iterations</h2><span id='topic+visualize_boosting'></span><span id='topic+visualize_boosting.GeDSboost'></span>

<h3>Description</h3>

<p>This function plots the <code><a href="#topic+NGeDSboost">NGeDSboost</a></code> fit to the data at the
beginning of a given boosting iteration and then plots the subsequent
<code><a href="#topic+NGeDS">NGeDS</a></code> fit on the corresponding negative gradient.
Note: Applicable only for <code><a href="#topic+NGeDSboost">NGeDSboost</a></code> models with a single
univariate base-learner.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'GeDSboost'
visualize_boosting(object, iters = NULL, final_fits = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="visualize_boosting_+3A_object">object</code></td>
<td>
<p>a <code><a href="#topic+GeDSboost-class">GeDSboost-class</a></code> object.</p>
</td></tr>
<tr><td><code id="visualize_boosting_+3A_iters">iters</code></td>
<td>
<p>numeric, specifies the iteration(s) number.</p>
</td></tr>
<tr><td><code id="visualize_boosting_+3A_final_fits">final_fits</code></td>
<td>
<p>logical indicating whether the final linear, quadratic and
cubic fits should be plotted.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Load packages
library(GeDS)

# Generate a data sample for the response variable
# Y and the single covariate X
set.seed(123)
N &lt;- 500
f_1 &lt;- function(x) (10*x/(1+100*x^2))*4+4
X &lt;- sort(runif(N, min = -2, max = 2))
# Specify a model for the mean of Y to include only a component
# non-linear in X, defined by the function f_1
means &lt;- f_1(X)
# Add (Normal) noise to the mean of Y
Y &lt;- rnorm(N, means, sd = 0.2)
data = data.frame(X, Y)
Gmodboost &lt;- NGeDSboost(Y ~ f(X), data = data, normalize_data = TRUE)

# Plot
plot(X, Y, pch=20, col=c("darkgrey"))
lines(X, sapply(X, f_1), col = "black", lwd = 2)
lines(X, Gmodboost$predictions$pred_linear, col = "green4", lwd = 2)
lines(X, Gmodboost$predictions$pred_quadratic, col="red", lwd=2)
lines(X, Gmodboost$predictions$pred_cubic, col="purple", lwd=2)
legend("topright",
legend = c("Order 2 (degree=1)", "Order 3 (degree=2)", "Order 4 (degree=3)"),
col = c("green4", "red", "purple"),
lty = c(1, 1),
lwd = c(2, 2, 2),
cex = 0.75,
bty="n",
bg = "white")
# Visualize boosting iterations + final fits
par(mfrow=c(4,2))
visualize_boosting(Gmodboost, iters = 0:3, final_fits = TRUE)
par(mfrow=c(1,1))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
