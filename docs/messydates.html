<!DOCTYPE html><html><head><title>Help for package messydates</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {messydates}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#annotate'><p>Annotates dates as censored, uncertain, or approximate</p></a></li>
<li><a href='#battles'><p>Dates of battles in 2001</p></a></li>
<li><a href='#class'><p>A flexible date class for messy dates</p></a></li>
<li><a href='#contract'><p>Contract lists of dates into messy dates</p></a></li>
<li><a href='#defunct'><p>Functions that have been renamed, superseded, or are no longer working</p></a></li>
<li><a href='#duration_class'><p>A duration class for mdates</p></a></li>
<li><a href='#expand'><p>Expand messy dates to lists of dates</p></a></li>
<li><a href='#extract'><p>Extracting components from messy dates</p></a></li>
<li><a href='#from_messydate'><p>Coercion from messy dates</p></a></li>
<li><a href='#logical_tests'><p>Logical tests on messy dates</p></a></li>
<li><a href='#messydate'><p>Coercion from regular date classes to mdate</p></a></li>
<li><a href='#mreport'><p>Data report for datasets with 'mdate' variables</p></a></li>
<li><a href='#operate'><p>Arithmetic operations for messydates</p></a></li>
<li><a href='#proportional'><p>Proportion of messy dates meeting logical test</p></a></li>
<li><a href='#resolve'><p>Resolves messy dates into a single value</p></a></li>
<li><a href='#set'><p>Set operations for messy dates</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>A Flexible Class for Messy Dates</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains a set of tools for constructing and coercing
  into and from the "mdate" class. 
  This date class implements ISO 8601-2:2019(E) and
  allows regular dates to be annotated 
  to express unspecified date components,
  approximate or uncertain date components, 
  date ranges, and sets of dates. 
  This is useful for describing and analysing temporal information,
  whether historical or recent, where date precision may vary.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-04-18</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>stringr, purrr, lubridate, tibble, dplyr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), covr, rmarkdown, knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://globalgov.github.io/messydates/">https://globalgov.github.io/messydates/</a>,
<a href="https://github.com/globalgov/messydates">https://github.com/globalgov/messydates</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/globalgov/messydates/issues">https://github.com/globalgov/messydates/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-04-19 07:20:57 UTC; henriquesposito</td>
</tr>
<tr>
<td>Author:</td>
<td>James Hollway <a href="https://orcid.org/0000-0002-8361-9647"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut, ctb] (IHEID),
  Henrique Sposito <a href="https://orcid.org/0000-0003-3420-6085"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb] (IHEID),
  Jael Tan <a href="https://orcid.org/0000-0002-6234-9764"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]
    (IHEID),
  Nathan Werth [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>James Hollway &lt;james.hollway@graduateinstitute.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-04-19 07:52:36 UTC</td>
</tr>
</table>
<hr>
<h2 id='annotate'>Annotates dates as censored, uncertain, or approximate</h2><span id='topic+annotate'></span><span id='topic+on_or_before'></span><span id='topic+on_or_after'></span><span id='topic+as_approximate'></span><span id='topic+as_uncertain'></span>

<h3>Description</h3>

<p>Some datasets have for example an arbitrary cut off point
for start and end points, but these are often coded as precise dates
when they are not necessarily the real start or end dates.
This collection of functions helps annotate uncertainty and
approximation to dates according to ISO2019E standards.
Inaccurate start or end dates can be represented by an affix
indicating &quot;on or before&quot;, if used as a prefix (e.g. <code>..1816-01-01</code>),
or indicating &quot;on or after&quot;, if used as a suffix (e.g. <code style="white-space: pre;">&#8288;2016-12-31..&#8288;</code>).
Approximate dates are indicated by adding a tilde to year,
month, or day components, as well as groups of components or whole dates
to estimate values that are possibly correct (e.g. <code style="white-space: pre;">&#8288;2003-03-03~&#8288;</code>).
Day, month, or year, uncertainty can be indicated by adding a question mark
to a possibly dubious date (e.g. <code style="white-space: pre;">&#8288;1916-10-10?&#8288;</code>) or date
component (e.g. <code>1916-?10-10</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>on_or_before(x)

on_or_after(x)

as_approximate(x, component = NULL)

as_uncertain(x, component = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="annotate_+3A_x">x</code></td>
<td>
<p>A date vector</p>
</td></tr>
<tr><td><code id="annotate_+3A_component">component</code></td>
<td>
<p>Annotation can be added on specific date components
(&quot;year&quot;, &quot;month&quot; or &quot;day&quot;), or to groups of date components (month and
day (&quot;md&quot;), or year and month (&quot;ym&quot;)). This must be specified.
If unspecified, annotation will be added after the date (e.g. <code style="white-space: pre;">&#8288;1916-10-10?&#8288;</code>),
indicating the whole date is uncertain or approximate.
For specific date components, uncertainty or approximation is annotated to
the left of the date component.
E.g. for &quot;day&quot;: <code>1916-10-?10</code> or <code>1916-10-~10</code>.
For groups of date components, uncertainty or approximation is annotated to
the right of the group (&quot;ym&quot;) or to both components (&quot;md&quot;).
E.g. for &quot;ym&quot;: <code>1916-10~-10</code>; for &quot;md&quot;: <code>1916-?10-?10</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>mdate</code> object with annotated date(s)
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>on_or_before()</code>: prefixes dates with &quot;..&quot; where start date is uncertain
</p>
</li>
<li> <p><code>on_or_after()</code>: suffixes dates with &quot;..&quot; where end date is uncertain
</p>
</li>
<li> <p><code>as_approximate()</code>: adds tildes to indicate approximate dates/date components
</p>
</li>
<li> <p><code>as_uncertain()</code>: adds question marks to indicate dubious dates/date components.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>data &lt;- data.frame(Beg = c("1816-01-01", "1916-01-01", "2016-01-01"),
  End = c("1816-12-31", "1916-12-31", "2016-12-31"))
dplyr::mutate(data, Beg = ifelse(Beg &lt;= "1816-01-01",
  on_or_before(Beg), Beg))
dplyr::mutate(data, End = ifelse(End &gt;= "2016-01-01",
  on_or_after(End), End))
dplyr::mutate(data, Beg = ifelse(Beg == "1916-01-01",
  as_approximate(Beg), Beg))
dplyr::mutate(data, End = ifelse(End == "1916-12-31",
  as_uncertain(End), End))
</code></pre>

<hr>
<h2 id='battles'>Dates of battles in 2001</h2><span id='topic+battles'></span>

<h3>Description</h3>

<p>A dataset containing the names and dates of battles in 2001,
according to Wikipedia (https://en.wikipedia.org/wiki/List_of_battles_in_the_21st_century).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>battles
</code></pre>


<h3>Format</h3>

<p>A data frame with 20 rows and 2 variables:
</p>

<dl>
<dt>Battle</dt><dd><p>name of the battle, character</p>
</dd>
<dt>Date</dt><dd><p>date or date range, a mdate class vector</p>
</dd>
<dt>Parties</dt><dd><p>parties to the conflict, character</p>
</dd>
<dt>US_party</dt><dd><p>is the US a party to the battle, numeric</p>
</dd>
<dt>N_actors</dt><dd><p>number of actors to conflict, numeric</p>
</dd>
</dl>



<h3>Details</h3>

<div class="sourceCode"><pre>#&gt; ----------------------------------------------------------------------------
#&gt; |  Column Name  |  Data Type  |  Observations  |  Missing  |  Missing (%)  |
#&gt; ----------------------------------------------------------------------------
#&gt; |    Battle     |  character  |              20|     0     |       0       |
#&gt; |     Date      |    mdate    |              20|     0     |       0       |
#&gt; |    Parties    |  character  |              20|     0     |       0       |
#&gt; |   US_party    |   numeric   |              20|     0     |       0       |
#&gt; |   N_actors    |   numeric   |              20|     0     |       0       |
#&gt; ----------------------------------------------------------------------------
</pre></div>

<hr>
<h2 id='class'>A flexible date class for messy dates</h2><span id='topic+class'></span><span id='topic+new_messydate'></span><span id='topic+validate_messydate'></span>

<h3>Description</h3>

<p>Recent extensions to standardised date notation in
<a href="https://www.iso.org/standard/70908.html">ISO 8601-2_2019(E)</a>
create space for unspecified, uncertain, and approximate dates,
as well as succinct representation of ranges of dates.
These functions create and validate a new date class for R
that can contain and parse these annotations,
and are not typically user-facing.
Please see <code>as_messydate()</code> for the user-facing coercion function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_messydate(x = character())

validate_messydate(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="class_+3A_x">x</code></td>
<td>
<p>A character scalar or vector in the expected <code>"yyyy-mm-dd"</code> format
annotated, as necessary, according to ISO 8601-2_2019(E).</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Date annotations</h4>

<p><em>Unspecified date components</em>, such as when the day is unknown,
can be represented by one or more <code>X</code>s in place of the digits.
The modifier <code>*</code> is recommended to indicate that the entire
time scale component value is unspecified, e.g. <code>X*-03-03</code>,
however this is not implemented here.
Please be explicit about the digits that are unspecified,
e.g. <code>XXXX-03-03</code> expresses 3rd March in some unspecified year,
whereas <code>2003-XX-03</code> expresses the 3rd of some month in 2003.
If time components are not given, they are expanded to this.
</p>
<p><em>Approximate date components</em>, modified by <code>~</code>,
represent an estimate whose value is asserted
to be possibly correct.
For example, <code>2003~-03-03</code>
The degree of confidence in approximation
depends on the application.
</p>
<p><em>Uncertain date components</em>, modified by <code style="white-space: pre;">&#8288;?&#8288;</code>,
represent a date component whose source is considered
to be dubious and therefore not to be relied upon.
An additional modifier, <code style="white-space: pre;">&#8288;%&#8288;</code>, is used to indicate
a value that is both uncertain and approximate.
</p>



<h4>Date sets</h4>

<p>These functions also introduce standard notation
for ranges of dates.
Rather than the typical R notation for ranges,
<code>:</code>, ISO 8601-2_2019(E) recommends <code>..</code>.
This then can be applied between two time scale
components to create a standard range between
these dates (inclusive), e.g. <code style="white-space: pre;">&#8288;2009-01-01..2019-01-01&#8288;</code>.
But it can also be used as an affix,
indicating &quot;on or before&quot; if used as a prefix,
e.g. <code>..2019-01-01</code>,
or indicating &quot;on or after&quot; if used as a suffix,
e.g. <code style="white-space: pre;">&#8288;2009-01-01..&#8288;</code>.
</p>
<p>And lastly, notation for sets of dates is also included.
Here braces, <code>{}</code>, are used to mean &quot;all members of the set&quot;,
while brackets, <code style="white-space: pre;">&#8288;[]&#8288;</code>, are used to mean &quot;one member of the set&quot;.
</p>



<h3>Value</h3>

<p>Object of class <code>mdate</code>
</p>


<h3>See Also</h3>

<p>messydate
</p>

<hr>
<h2 id='contract'>Contract lists of dates into messy dates</h2><span id='topic+contract'></span>

<h3>Description</h3>

<p>This function operates as the opposite of <code>expand()</code>.
It contracts a list of dates into the abbreviated annotation
of messy dates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contract(x, collapse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contract_+3A_x">x</code></td>
<td>
<p>A list of dates</p>
</td></tr>
<tr><td><code id="contract_+3A_collapse">collapse</code></td>
<td>
<p>Do you want ranges to be collapsed?
TRUE by default.
If FALSE ranges are returned in compact format.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ´contract()´ function first <code>expand()</code> 'mdate' objects
to then display their most succinct representation.
</p>


<h3>Value</h3>

<p>A <code>mdate</code> vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- as_messydate(c("2001-01-01", "2001-01", "2001",
"2001-01-01..2001-02-02", "{2001-10-01,2001-10-04}",
"{2001-01,2001-02-02}", "28 BC", "-2000-01-01",
"{2001-01-01, 2001-01-02, 2001-01-03}"))
tibble::tibble(d, contract(d))
</code></pre>

<hr>
<h2 id='defunct'>Functions that have been renamed, superseded, or are no longer working</h2><span id='topic+defunct'></span><span id='topic+is_element'></span><span id='topic+md_intersect'></span><span id='topic+md_union'></span><span id='topic+md_multiset'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
Generally these functions have been superseded or renamed.
Upon using them, a message is provided directing the user to the new function.
However, at this stage of package development,
we generally clear older defunct functions at each minor release,
and so you are strongly encouraged to use the new functions/names/syntax
wherever possible and update your scripts accordingly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_element(.data)

md_intersect(.data)

md_union(.data)

md_multiset(.data)
</code></pre>


<h3>Functions</h3>


<ul>
<li> <p><code>is_element()</code>: Deprecated on 2023-08-25.
</p>
</li>
<li> <p><code>md_intersect()</code>: Deprecated on 2023-08-25.
</p>
</li>
<li> <p><code>md_union()</code>: Deprecated on 2023-08-25.
</p>
</li>
<li> <p><code>md_multiset()</code>: Deprecated on 2023-08-25.
</p>
</li></ul>

<hr>
<h2 id='duration_class'>A duration class for mdates</h2><span id='topic+duration_class'></span><span id='topic+new_messyduration'></span><span id='topic+messyduration'></span><span id='topic+validate_messyduration'></span><span id='topic+messyduration.character'></span><span id='topic+messyduration.mdate'></span>

<h3>Description</h3>

<p>The <code>mdates_duration</code> class introduces methods that annotate a duration or
period with representations of its uncertainty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>new_messyduration(x = character())

messyduration(x, approx_range = 0)

validate_messyduration(x, approx_range = 0)

## S3 method for class 'character'
messyduration(x, approx_range = 0)

## S3 method for class 'mdate'
messyduration(x, approx_range = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="duration_class_+3A_x">x</code></td>
<td>
<p>An <code>mdate</code> variable with ranges.</p>
</td></tr>
<tr><td><code id="duration_class_+3A_approx_range">approx_range</code></td>
<td>
<p>Range to expand approximate dates, in days.
If 3, for example, adds 3 days; if -3, removes 3 days from both sides.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most R packages handle duration and periods as exact time or date intervals.
However, this is not possible for 'messy' dates where uncertainty or
approximation might be present.
The <code>mdates_duration</code> class accounts for uncertainty and approximation
in <code>mdate</code> objects to return their duration as a range of possible dates.
</p>


<h3>Value</h3>

<p>Object of class <code>description</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>messyduration(as_messydate(c("2010-01-01..2010-12-31", "2010-01..2010-12")))
</code></pre>

<hr>
<h2 id='expand'>Expand messy dates to lists of dates</h2><span id='topic+expand'></span>

<h3>Description</h3>

<p>These functions expand on date ranges, sets of dates, and unspecified or
approximate dates (annotated with '..', '', 'XX' or '~').
As these messydates may refer to several possible dates,
the function &quot;opens&quot; these values to reveal a vector of all the possible
dates implied.
Imprecise dates (dates only containing information on year and/or month)
are also expanded to include possible dates within that year and/or month.
The function removes the annotation from dates with unreliable sources ('?'),
before being expanded normally as though they were incomplete.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand(x, approx_range = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_+3A_x">x</code></td>
<td>
<p>A <code>mdate</code> object.
If not an 'mdate' object, conversion is handled first with ´as_messydate()´.</p>
</td></tr>
<tr><td><code id="expand_+3A_approx_range">approx_range</code></td>
<td>
<p>Range to expand approximate dates,
or date components, annotated with '~', by default 0.
That is, removes signs for approximate dates and
treats these dates as precise dates.
If 3, for example, adds 3 days for day approximation,
3 months for month approximation,
3 years for year/whole date approximation,
3 years and 3 months for year-month approximation,
and 3 months and 3 days for month-day approximation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of dates, including all dates in each range or set.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- as_messydate(c("2008-03-25", "-2012-02-27", "2001-01?", "~2001",
"2001-01-01..2001-02-02", "{2001-01-01,2001-02-02}", "{2001-01,2001-02-02}",
"2008-XX-31", "..2002-02-03", "2001-01-03..", "28 BC"))
expand(d)
</code></pre>

<hr>
<h2 id='extract'>Extracting components from messy dates</h2><span id='topic+extract'></span><span id='topic+year'></span><span id='topic+month'></span><span id='topic+day'></span><span id='topic+precision'></span>

<h3>Description</h3>

<p>These functions allow the extraction of particular date components
from messy dates, such as the <code>year()</code>, <code>month()</code>, and <code>day()</code>.
<code>precision()</code> allows for the identification of the greatest level of
precision in (currently) the first element of each date.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>year(x)

month(x)

day(x)

precision(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_+3A_x">x</code></td>
<td>
<p>A <code>mdate</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>year()</code>, <code>month()</code>, and <code>day()</code> extraction return the integer
for the requested date component.
<code>precision()</code> returns the level of greatest precision for each date.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>year(as_messydate(c("2012-02-03","2012","2012-02")))
month(as_messydate(c("2012-02-03","2012","2012-02")))
day(as_messydate(c("2012-02-03","2012","2012-02")))
precision(as_messydate(c("2012-02-03","2012","2012-02")))
</code></pre>

<hr>
<h2 id='from_messydate'>Coercion from messy dates</h2><span id='topic+from_messydate'></span><span id='topic+as.Date.mdate'></span><span id='topic+as.POSIXct.mdate'></span><span id='topic+as.POSIXlt.mdate'></span>

<h3>Description</h3>

<p>These functions coerce objects of <code>mdate</code> class to
common date classes such as <code>Date</code>, <code>POSIXct</code>, and <code>POSIXlt</code>.
Since <code>mdate</code> objects can hold multiple individual dates,
however, an additional function must be passed as an argument
so that these functions know how to coerce resolve multiple dates
into a single date.
</p>
<p>For example, one might wish to use the earliest possible date
in any ranges of dates (<code>min</code>), the latest possible date (<code>max</code>),
some notion of a central tendency (<code>mean</code>, <code>median</code>, or <code>modal</code>),
or even a <code>random</code> selection from among the candidate dates.
</p>
<p>These functions then, building on <code>expand()</code> and the resolve functions,
are particularly useful in converting back out of the <code>mdate</code> class
for use with existing methods and models,
especially for checking the robustness of results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mdate'
as.Date(x, ..., FUN)

## S3 method for class 'mdate'
as.POSIXct(x, ..., FUN)

## S3 method for class 'mdate'
as.POSIXlt(x, ..., FUN)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="from_messydate_+3A_x">x</code></td>
<td>
<p>A <code>mdate</code> object</p>
</td></tr>
<tr><td><code id="from_messydate_+3A_...">...</code></td>
<td>
<p>Arguments passed on to the S3 generics.</p>
</td></tr>
<tr><td><code id="from_messydate_+3A_fun">FUN</code></td>
<td>
<p>A function that can be used to resolve expanded messy dates
into a single date.
For example, <code>min()</code>, <code>max()</code>, <code>mean()</code>, <code>median()</code>,
<code>modal()</code>, and <code>random()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A date object of <code>Date</code>, <code>POSIXct</code>, or <code>POSIXlt</code> class
</p>


<h3>Examples</h3>

<pre><code class='language-R'>as.Date(as_messydate("2012-01"), min)
as.Date(as_messydate("2012-01-01"), mean)
as.Date(as_messydate("2012-01"), max)
as.Date(as_messydate("2012-01"), median)
as.Date(as_messydate("2012-01"), modal)
as.Date(as_messydate("2012-01"), random)
as.Date(as_messydate("1000 BC"), max)
as.Date(as_messydate("1000 BC"), mean)
as.Date(as_messydate("1000 BC"), median)
as.Date(as_messydate(c("-1000", "2020")), min)
</code></pre>

<hr>
<h2 id='logical_tests'>Logical tests on messy dates</h2><span id='topic+logical_tests'></span><span id='topic+is_messydate'></span><span id='topic+is_intersecting'></span><span id='topic+is_subset'></span><span id='topic+is_similar'></span><span id='topic+is_precise'></span><span id='topic+is_uncertain'></span><span id='topic+is_approximate'></span><span id='topic++3C.mdate'></span><span id='topic++3E.mdate'></span><span id='topic++3C+3D.mdate'></span><span id='topic++3E+3D.mdate'></span>

<h3>Description</h3>

<p>These functions provide various logical tests for messy date objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_messydate(x)

is_intersecting(x, y)

is_subset(x, y)

is_similar(x, y)

is_precise(x)

is_uncertain(x)

is_approximate(x)

## S3 method for class 'mdate'
e1 &lt; e2

## S3 method for class 'mdate'
e1 &gt; e2

## S3 method for class 'mdate'
e1 &lt;= e2

## S3 method for class 'mdate'
e1 &gt;= e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logical_tests_+3A_x">x</code>, <code id="logical_tests_+3A_y">y</code>, <code id="logical_tests_+3A_e1">e1</code>, <code id="logical_tests_+3A_e2">e2</code></td>
<td>
<p><code>mdate</code> or other class objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical vector the same length as the <code>mdate</code> passed.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>is_messydate()</code>: tests whether the object inherits the <code>mdate</code> class.
If more rigorous validation is required, see <code>validate_messydate()</code>.
</p>
</li>
<li> <p><code>is_intersecting()</code>: tests whether there is any intersection between
two messy dates, leveraging <code>intersect()</code>.
</p>
</li>
<li> <p><code>is_subset()</code>: tests whether one or more messy date can be found
within a messy date range or set.
</p>
</li>
<li> <p><code>is_similar()</code>: tests whether two dates contain similar components.
This can be useful for identifying dates that may be typos of one another.
</p>
</li>
<li> <p><code>is_precise()</code>: tests whether a date is precise (i.e. an 8 digit date).
Non-precise dates contain markers that they are approximate (i.e. ~),
unreliable (i.e. ?), are incomplete dates (i.e. year only),
or date ranges and sets.
</p>
</li>
<li> <p><code>is_uncertain()</code>: tests whether a date is uncertain (i.e. contains ?).
</p>
</li>
<li> <p><code>is_approximate()</code>: tests whether a date is approximate (i.e. contains ~).
</p>
</li>
<li> <p><code> &lt; </code>: tests whether the dates in the first vector precede
the dates in the second vector.
Returns <code>NA</code> when the date order can't be determined.
</p>
</li>
<li> <p><code> &gt; </code>: tests whether the dates in the first vector
succeed the dates in the second vector.
Returns <code>NA</code> when the date order can't be determined.
</p>
</li>
<li> <p><code> &lt;= </code>: tests whether the dates in the first vector are
equal to or precede the dates in the second vector.
Returns <code>NA</code> when the date order can't be determined.
</p>
</li>
<li> <p><code> &gt;= </code>: tests whether the dates in the first vector are equal to
or succeed the dates in the second vector.
Returns <code>NA</code> when the date order can't be determined.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>is_messydate(as_messydate("2012-01-01"))
is_messydate(as.Date("2012-01-01"))
is_intersecting(as_messydate("2012-01"),
as_messydate("2012-01-01..2012-02-22"))
is_intersecting(as_messydate("2012-01"),
as_messydate("2012-02-01..2012-02-22"))
is_subset(as_messydate("2012-01-01"), as_messydate("2012-01"))
is_subset(as_messydate("2012-01-01..2012-01-03"), as_messydate("2012-01"))
is_subset(as_messydate("2012-01-01"), as_messydate("2012-02"))
is_similar(as_messydate("2012-06-02"), as_messydate("2012-02-06"))
is_similar(as_messydate("2012-06-22"), as_messydate("2012-02-06"))
is_precise(as_messydate(c("2012-06-02", "2012-06")))
is_uncertain(as_messydate(c("2012-06-02", "2012-06-02?")))
is_approximate(as_messydate(c("2012-06-02~", "2012-06-02")))
as_messydate("2012-06-02") &gt; as.Date("2012-06-01") # TRUE
# 2012-06-XX could mean 2012-06-03, so unknown if it comes before 2012-06-02
as_messydate("2012-06-XX") &lt; as.Date("2012-06-02") # NA
# But 2012-06-XX cannot be before 2012-06-01
as_messydate("2012-06-XX") &gt;= as.Date("2012-06-01") # TRUE
</code></pre>

<hr>
<h2 id='messydate'>Coercion from regular date classes to mdate</h2><span id='topic+messydate'></span><span id='topic+as_messydate'></span><span id='topic+as_messydate.Date'></span><span id='topic+as_messydate.POSIXct'></span><span id='topic+as_messydate.POSIXlt'></span><span id='topic+as_messydate.character'></span><span id='topic+as_messydate.list'></span><span id='topic+mdate'></span><span id='topic+make_messydate'></span>

<h3>Description</h3>

<p>These methods coerce various date classes into the <code>mdate</code> class.
They represent the main user-facing class-creating functions in the package.
In addition to the typical date classes in R (<code>Date</code>, <code>POSIXct</code>, and <code>POSIXlt</code>),
there is also a direct method for converting text or character strings to <code>mdate</code>.
The function can also extract dates from text,
though this is a work-in-progress and currently only works in English.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_messydate(x, resequence = FALSE)

## S3 method for class 'Date'
as_messydate(x, resequence = FALSE)

## S3 method for class 'POSIXct'
as_messydate(x, resequence = FALSE)

## S3 method for class 'POSIXlt'
as_messydate(x, resequence = FALSE)

## S3 method for class 'character'
as_messydate(x, resequence = NULL)

## S3 method for class 'list'
as_messydate(x, resequence = FALSE)

mdate(x, resequence = FALSE)

make_messydate(..., resequence = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="messydate_+3A_x">x</code></td>
<td>
<p>A scalar or vector of a class that can be coerced into <code>mdate</code>,
such as <code>Date</code>, <code>POSIXct</code>, <code>POSIXlt</code>, or character.</p>
</td></tr>
<tr><td><code id="messydate_+3A_resequence">resequence</code></td>
<td>
<p>Users have the option to choose the order for
ambiguous dates with or without separators (e.g. &quot;11-01-12&quot; or &quot;20112112&quot;).
<code>NULL</code> by default.
Other options include: 'dmy', 'ymd', 'mdy', 'ym', 'my' and 'interactive'
If 'dmy', dates are converted from DDMMYY format for 6 digit dates,
or DDMMYYYY format for 8 digit dates.
If 'ymd', dates are converted from YYMMDD format for 6 digit dates,
or YYYYMMDD format for 8 digit dates.
If 'mdy', dates are converted from MMDDYY format for 6 digit dates
or MMDDYYYY format for 8 digit dates.
For these three options, ambiguous dates are converted to YY-MM-DD format
for 6 digit dates, or YYYY-MM-DD format for 8 digit dates.
If 'my', ambiguous 6 digit dates are converted from MM-YYYY format
to YYYY-MM.
If 'ym', ambiguous 6 digit dates are converted to YYYY-MM format.
If 'interactive', it prompts users to select the existing
component order of ambiguous dates,
based on which the date is reordered into YYYY-MM-DD format
and further completed to YYYY-MM-DD format if they choose to do so.</p>
</td></tr>
<tr><td><code id="messydate_+3A_...">...</code></td>
<td>
<p>One (yyyy-mm-dd), two (yyyy-mm-dd, yyyy-mm-dd),
or three (yyyy, mm, dd) variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If three date variables are passed to <code>make_messydate()</code>,
function will create a single date (yyyy-mm-dd) from it.
If two date variables are passed to <code>make_messydate()</code>,
function will create a range of dates from it (yyyy-mm-dd..yyyy-mm-dd).
If one date variable is passed to <code>make_messydate()</code>,
function defaults to <code>as_messydate()</code>.
</p>


<h3>Value</h3>

<p>A <code>mdate</code> class object
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>as_messydate()</code>: Core <code>mdate</code> class coercion function
</p>
</li>
<li> <p><code>as_messydate(Date)</code>: Coerce from <code>Date</code> to <code>mdate</code> class
</p>
</li>
<li> <p><code>as_messydate(POSIXct)</code>: Coerce from <code>POSIXct</code> to <code>mdate</code> class
</p>
</li>
<li> <p><code>as_messydate(POSIXlt)</code>: Coerce from <code>POSIXlt</code> to <code>mdate</code> class
</p>
</li>
<li> <p><code>as_messydate(character)</code>: Coerce character date objects to <code>mdate</code> class
</p>
</li>
<li> <p><code>as_messydate(list)</code>: Coerce list date objects to the most concise
representation of <code>mdate</code> class
</p>
</li>
<li> <p><code>make_messydate()</code>: Composes <code>mdate</code> from multiple variables
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>as_messydate("2021")
as_messydate("2021-02")
as_messydate("2021-02-01")
as_messydate("01-02-2021")
as_messydate("1 February 2021")
as_messydate("First of February, two thousand and twenty-one")
as_messydate("2021-02-01?")
as_messydate("2021-02-01~")
as_messydate("2021-02-01%")
as_messydate("2021-02-01..2021-02-28")
as_messydate("{2021-02-01,2021-02-28}")
as_messydate(c("-2021", "2021 BC", "-2021-02-01"))
as_messydate(c("210201", "20210201"), resequence = "ymd")
as_messydate(c("010221", "01022021"), resequence = "dmy")
# as_messydate(c("01-02-21", "01-02-2021", "01-02-91", "01-02-1991"),
# resequence = "interactive")
as_messydate(list(c("2012-06-01", "2012-06-02", "2012-06-03")))
as_messydate(list(c("2012-06-01", "2012-06-02", "2012-06-03",
"{2012-06-01, 2012-06-02, 2012-06-03}", "2012-06-01", "2012-06-03")))
make_messydate("2010", "10", "10")
</code></pre>

<hr>
<h2 id='mreport'>Data report for datasets with 'mdate' variables</h2><span id='topic+mreport'></span>

<h3>Description</h3>

<p>Create a properly formatted data report for datasets which contain 'mdate'
class objects, alongside other object classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mreport(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mreport_+3A_data">data</code></td>
<td>
<p>A <code>{tibble}</code> or a <code>{data.frame}</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>'mreport' displays the variable's name,
the variable type, the number of observations per variable,
the number of missing observations for variable,
and the percentage of missing observations in variable.
</p>


<h3>Value</h3>

<p>A data report of class 'mreport'.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mreport(battles)
</code></pre>

<hr>
<h2 id='operate'>Arithmetic operations for messydates</h2><span id='topic+operate'></span><span id='topic++2B.mdate'></span><span id='topic+-.mdate'></span>

<h3>Description</h3>

<p>These operations allow users to add or subtract dates messydate objects.
Messydate objects include incomplete or uncertain dates,
ranges of dates, negative dates, and date sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mdate'
e1 + e2

## S3 method for class 'mdate'
e1 - e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="operate_+3A_e1">e1</code></td>
<td>
<p>An <code>mdate</code> or date object.</p>
</td></tr>
<tr><td><code id="operate_+3A_e2">e2</code></td>
<td>
<p>An <code>mdate</code>, date, or numeric object. Must be a scalar.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A messydates vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
d &lt;- as_messydate(c("2008-03-25", "-2012-02-27", "2001-01?", "~2001",
"2001-01-01..2001-02-02", "{2001-01-01,2001-02-02}",
"2008-XX-31", "..2002-02-03", "2001-01-03..", "28 BC"))
tibble::tibble(date = d, add = d + 1, subtract = d - 1)
tibble::tibble(date = d, add = d + "1 year", subtract = d - "1 year")
as_messydate("2001-01-01") + as_messydate("2001-01-02..2001-01-04")
as_messydate("2001-01-01") + as_messydate("2001-01-03")
as_messydate("2001-01-01..2001-01-04") - as_messydate("2001-01-02")
#as_messydate("2001-01-01") - as_messydate("2001-01-03")

</code></pre>

<hr>
<h2 id='proportional'>Proportion of messy dates meeting logical test</h2><span id='topic+proportional'></span><span id='topic++25l+25'></span><span id='topic++25l+25.mdate'></span><span id='topic++25g+25'></span><span id='topic++25g+25.mdate'></span><span id='topic++25ge+25'></span><span id='topic++25ge+25.mdate'></span><span id='topic++25le+25'></span><span id='topic++25le+25.mdate'></span><span id='topic++25+3E+3C+25'></span><span id='topic++25+3E+3C+25.mdate'></span><span id='topic++25+3E+3D+3C+25'></span><span id='topic++25+3E+3D+3C+25.mdate'></span>

<h3>Description</h3>

<p>These functions provide various proportional tests for messy date objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e1 %l% e2

## S3 method for class 'mdate'
e1 %l% e2

e1 %g% e2

## S3 method for class 'mdate'
e1 %g% e2

e1 %ge% e2

## S3 method for class 'mdate'
e1 %ge% e2

e1 %le% e2

## S3 method for class 'mdate'
e1 %le% e2

e1 %&gt;&lt;% e2

## S3 method for class 'mdate'
e1 %&gt;&lt;% e2

e1 %&gt;=&lt;% e2

## S3 method for class 'mdate'
e1 %&gt;=&lt;% e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proportional_+3A_e1">e1</code>, <code id="proportional_+3A_e2">e2</code></td>
<td>
<p><code>mdate</code> or other class objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The proportion that the comparison is true.
</p>
<p>A logical vector the same length as the <code>mdate</code> passed.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code> %l% </code>: Tests proportion of dates in the first vector
that precede the minimum in the second vector.
</p>
</li>
<li> <p><code> %g% </code>: Tests proportion of dates in the first vector
that follow the maximum in the second vector.
</p>
</li>
<li> <p><code> %ge% </code>: Tests proportion of dates in the first vector
that follow or are equal to the maximum in the second vector.
</p>
</li>
<li> <p><code> %le% </code>: Tests proportion of dates in the first vector
that precede or are equal to the minimum in the second vector.
</p>
</li>
<li> <p><code> %&gt;&lt;% </code>: Tests proportion of dates in the first vector
that are between the minimum and maximum dates in the second vector.
</p>
</li>
<li> <p><code> %&gt;=&lt;% </code>: Tests proportion of dates in the first vector that
are between the minimum and maximum dates in the second vector, inclusive.
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>  as_messydate("2012-06") &lt; as.Date("2012-06-02")
  as_messydate("2012-06") %l% as_messydate("2012-06-02")
  as_messydate("2012-06") &gt; as.Date("2012-06-02")
  as_messydate("2012-06") %g% as_messydate("2012-06-02")
  as_messydate("2012-06") &gt;= as.Date("2012-06-02")
  as_messydate("2012-06") %ge% as_messydate("2012-06-02")
  as_messydate("2012-06") &lt;= as.Date("2012-06-02")
  as_messydate("2012-06") %le% "2012-06-02"
  as_messydate("2012-06") %&gt;&lt;% as_messydate("2012-06-15..2012-07-15")
  as_messydate("2012-06") %&gt;=&lt;% as_messydate("2012-06-15..2012-07-15")
</code></pre>

<hr>
<h2 id='resolve'>Resolves messy dates into a single value</h2><span id='topic+resolve'></span><span id='topic+min.mdate'></span><span id='topic+max.mdate'></span><span id='topic+median.mdate'></span><span id='topic+mean.mdate'></span><span id='topic+modal'></span><span id='topic+modal.mdate'></span><span id='topic+random'></span><span id='topic+random.mdate'></span>

<h3>Description</h3>

<p>This collection of S3 methods 'resolve' messy dates into a single date
according to some explicit bias,
such as returning the minimum or maximum date,
the mean, median, or modal date,
or a random date from among the possible resolutions for each messy date.
If the date is not 'messy' (i.e. has no annotations)
then just that precise date is returned.
This can be useful for various descriptive or inferential projects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mdate'
min(..., na.rm = TRUE)

## S3 method for class 'mdate'
max(..., na.rm = TRUE)

## S3 method for class 'mdate'
median(..., na.rm = TRUE)

## S3 method for class 'mdate'
mean(..., trim = 0, na.rm = TRUE)

modal(..., na.rm = FALSE)

## S3 method for class 'mdate'
modal(..., na.rm = TRUE)

random(..., size, replace = FALSE, prob = NULL)

## S3 method for class 'mdate'
random(..., size, replace = FALSE, prob = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resolve_+3A_...">...</code></td>
<td>
<p>a mdate object</p>
</td></tr>
<tr><td><code id="resolve_+3A_na.rm">na.rm</code></td>
<td>
<p>Should NAs be removed? True by default.</p>
</td></tr>
<tr><td><code id="resolve_+3A_trim">trim</code></td>
<td>
<p>the fraction (0 to 0.5) of observations to be trimmed
from each end of x before the mean is computed.
Values of trim outside that range are taken as the nearest endpoint.</p>
</td></tr>
<tr><td><code id="resolve_+3A_size">size</code></td>
<td>
<p>a non-negative integer giving the number of items to choose.</p>
</td></tr>
<tr><td><code id="resolve_+3A_replace">replace</code></td>
<td>
<p>should sampling be with replacement?</p>
</td></tr>
<tr><td><code id="resolve_+3A_prob">prob</code></td>
<td>
<p>a vector of probability weights
for obtaining the elements of the vector being sampled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single scalar or vector of dates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- as_messydate(c("2008-03-25", "?2012-02-27", "2001-01?", "2001~",
"2001-01-01..2001-02-02", "{2001-01-01,2001-02-02}",
"{2001-01,2001-02-02}", "2008-XX-31"))
d
min(d)
max(d)
mean(d)
median(d)
modal(d)
random(d)
</code></pre>

<hr>
<h2 id='set'>Set operations for messy dates</h2><span id='topic+set'></span><span id='topic++25intersect+25'></span><span id='topic++25intersect+25.mdate'></span><span id='topic++25union+25'></span><span id='topic++25union+25.mdate'></span>

<h3>Description</h3>

<p>Performs intersection (<code>md_intersect()</code>) and union (<code>md_union()</code>) on,
inter alia, messy date class objects.
For a more typical 'join' that retains all elements, even if duplicated,
please use <code>md_multiset</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>e1 %intersect% e2

## S3 method for class 'mdate'
e1 %intersect% e2

e1 %union% e2

## S3 method for class 'mdate'
e1 %union% e2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_+3A_e1">e1</code>, <code id="set_+3A_e2">e2</code></td>
<td>
<p>Messy date or other class objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of the same mode for <code>intersect</code>,
or a common mode for union.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code> %intersect% </code>: Find intersection of sets of messy dates
</p>
</li>
<li> <p><code> %union% </code>: Find intersection of sets of messy dates
</p>
</li></ul>


<h3>Examples</h3>

<pre><code class='language-R'>as_messydate("2012-01-01..2012-01-20") %intersect% as_messydate("2012-01")
as_messydate("2012-01-01..2012-01-20") %union% as_messydate("2012-01")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
