<!DOCTYPE html><html lang="en"><head><title>Help for package admix</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {admix}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#admix-package'><p>admix: Package Admix for Admixture (aka Contamination) Models</p></a></li>
<li><a href='#admix_cluster'><p>Clustering of K populations following admixture models</p></a></li>
<li><a href='#admix_estim'><p>Estimate the unknown parameters of the admixture model(s)</p></a></li>
<li><a href='#admix_model'><p>Create an object of class 'admix_model'</p></a></li>
<li><a href='#admix_test'><p>Equality test for the unknown components of admixture models</p></a></li>
<li><a href='#allGalaxies'><p>Measurements of heliocentric velocities in four galaxies</p></a></li>
<li><a href='#decontaminated_cdf'><p>Estimates the decontaminated CDF of the unknown component in an admixture</p></a></li>
<li><a href='#decontaminated_density'><p>Estimates the decontaminated density of the unknown component in an admixture</p></a></li>
<li><a href='#estim_BVdk'><p>Estimation of the admixture parameters by Bordes &amp; Vandekerkhove (2010)</p></a></li>
<li><a href='#estim_IBM'><p>Estimates weights of unknown components from 2 admixtures using IBM</p></a></li>
<li><a href='#estim_PS'><p>Estimates in an admixture using Patra and Sen approach</p></a></li>
<li><a href='#gaussianity_test'><p>Gaussianity test in an admixture model</p></a></li>
<li><a href='#getmixingWeight'><p>Extractor for object of class 'admix_estim'</p></a></li>
<li><a href='#getmixtData'><p>Extractor for object of class 'twoComp_mixt'</p></a></li>
<li><a href='#IBM_k_samples_test'><p>Equality test of K unknown component distributions</p></a></li>
<li><a href='#IBM_tabul_stochasticInteg'><p>Simulated distribution of the contrast using IBM</p></a></li>
<li><a href='#milkyWay'><p>Heliocentric velocity for the Milky Way</p></a></li>
<li><a href='#mortality_sample'><p>Deaths statistics in 11 european countries</p></a></li>
<li><a href='#orthobasis_test'><p>Equality test of two unknown component distributions using polynomial expansions</p></a></li>
<li><a href='#plot.decontaminated_density'><p>Plot method for class 'decontaminated_density'</p></a></li>
<li><a href='#plot.twoComp_mixt'><p>Plots several mixture densities on the same graph</p></a></li>
<li><a href='#print.admix_cluster'><p>Print method for object of class 'admix_cluster'</p></a></li>
<li><a href='#print.admix_estim'><p>Print the estimated parameters from K admixture models</p></a></li>
<li><a href='#print.admix_model'><p>Print method for objects of class 'admix_model'</p></a></li>
<li><a href='#print.admix_test'><p>Print method for objects 'admix_test'</p></a></li>
<li><a href='#print.decontaminated_density'><p>Print method for object of class 'decontaminated_density'</p></a></li>
<li><a href='#print.estim_BVdk'><p>Print method for objects 'estim_BVdk'</p></a></li>
<li><a href='#print.estim_IBM'><p>Print method for objects of class 'estim_IBM'</p></a></li>
<li><a href='#print.estim_PS'><p>Print method for objects of class 'estim_PS'</p></a></li>
<li><a href='#print.gaussianity_test'><p>Print method for objects 'gaussianity_test'</p></a></li>
<li><a href='#print.IBM_test'><p>Print method for objects 'IBM_test'</p></a></li>
<li><a href='#print.orthobasis_test'><p>Print method for objects of class 'orthobasis_test'</p></a></li>
<li><a href='#print.twoComp_mixt'><p>Print method for objects 'twoComp_mixt'</p></a></li>
<li><a href='#stmf_small'><p>Short-term Mortality Fluctuations (STMF) data</p></a></li>
<li><a href='#summary.admix_cluster'><p>Summary method for object of class 'admix_cluster'</p></a></li>
<li><a href='#summary.admix_estim'><p>Results of estimated parameters from K admixture models</p></a></li>
<li><a href='#summary.admix_test'><p>Summary method for 'admix_test' objects</p></a></li>
<li><a href='#summary.estim_BVdk'><p>Summary method for objects 'estim_BVdk'</p></a></li>
<li><a href='#summary.estim_IBM'><p>Summary method for objects 'estim_IBM'</p></a></li>
<li><a href='#summary.estim_PS'><p>Summary method for objects 'estim_PS'</p></a></li>
<li><a href='#summary.gaussianity_test'><p>Summary method for objects 'gaussianity_test'</p></a></li>
<li><a href='#summary.IBM_test'><p>Summary method for objects 'IBM_test'</p></a></li>
<li><a href='#summary.orthobasis_test'><p>Summary method for objects of class 'orthobasis_test'</p></a></li>
<li><a href='#twoComp_mixt'><p>Simulation of a two-component mixture model</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Package Admix for Admixture (aka Contamination) Models</td>
</tr>
<tr>
<td>Version:</td>
<td>2.3.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements techniques to estimate the unknown quantities
    related to two-component admixture models, where the two components
    can belong to any distribution (note that in the case of multinomial
    mixtures, the two components must belong to the same family).
    Estimation methods depend on the assumptions made on the unknown
    component density; see Bordes and Vandekerkhove (2010)
    &lt;<a href="https://doi.org/10.3103%2FS1066530710010023">doi:10.3103/S1066530710010023</a>&gt;, Patra and Sen (2016)
    &lt;<a href="https://doi.org/10.1111%2Frssb.12148">doi:10.1111/rssb.12148</a>&gt;, and Milhaud, Pommeret, Salhi, Vandekerkhove
    (2024) &lt;<a href="https://doi.org/10.3150%2F23-BEJ1593">doi:10.3150/23-BEJ1593</a>&gt;. In practice, one can estimate both
    the mixture weight and the unknown component density in a wide variety
    of frameworks. On top of that, hypothesis tests can be performed in
    one and two-sample contexts to test the unknown component density (see
    Milhaud, Pommeret, Salhi and Vandekerkhove (2022)
    &lt;<a href="https://doi.org/10.1016%2Fj.jspi.2021.05.010">doi:10.1016/j.jspi.2021.05.010</a>&gt;, and Milhaud, Pommeret, Salhi,
    Vandekerkhove (2024) &lt;<a href="https://doi.org/10.3150%2F23-BEJ1593">doi:10.3150/23-BEJ1593</a>&gt;). Finally, clustering of
    unknown mixture components is also feasible in a K-sample setting (see
    Milhaud, Pommeret, Salhi, Vandekerkhove (2024) 
    <a href="https://jmlr.org/papers/v25/23-0914.html">https://jmlr.org/papers/v25/23-0914.html</a>).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/XavierMilhaud/admix-Rpackage">https://github.com/XavierMilhaud/admix-Rpackage</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/XavierMilhaud/admix-Rpackage/issues">https://github.com/XavierMilhaud/admix-Rpackage/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>base, cubature, EnvStats, fdrtool, graphics, Iso, MASS,
orthopolynom, pracma, Rcpp, Rdpack, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>doParallel, doRNG, evd, flexsurv, foreach, gridExtra, knitr,
lattice, logitnorm, plyr, reshape2, rmarkdown, rmutil, testthat
(&ge; 3.0.0)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RdMacros:</td>
<td>Rdpack</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-07 09:49:32 UTC; XM</td>
</tr>
<tr>
<td>Author:</td>
<td>Xavier Milhaud [aut, cre],
  Pierre Vandekerkhove [ctb],
  Denys Pommeret [ctb],
  Yahia Salhi [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Xavier Milhaud &lt;xavier.milhaud.research@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-07 10:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='admix-package'>admix: Package Admix for Admixture (aka Contamination) Models</h2><span id='topic+admix'></span><span id='topic+admix-package'></span>

<h3>Description</h3>

<p>Implements techniques to estimate the unknown quantities related to two-component admixture models, where the two components can belong to any distribution (note that in the case of multinomial mixtures, the two components must belong to the same family). Estimation methods depend on the assumptions made on the unknown component density; see Bordes and Vandekerkhove (2010) <a href="https://doi.org/10.3103/S1066530710010023">doi:10.3103/S1066530710010023</a>, Patra and Sen (2016) <a href="https://doi.org/10.1111/rssb.12148">doi:10.1111/rssb.12148</a>, and Milhaud, Pommeret, Salhi, Vandekerkhove (2024) <a href="https://doi.org/10.3150/23-BEJ1593">doi:10.3150/23-BEJ1593</a>. In practice, one can estimate both the mixture weight and the unknown component density in a wide variety of frameworks. On top of that, hypothesis tests can be performed in one and two-sample contexts to test the unknown component density (see Milhaud, Pommeret, Salhi and Vandekerkhove (2022) <a href="https://doi.org/10.1016/j.jspi.2021.05.010">doi:10.1016/j.jspi.2021.05.010</a>, and Milhaud, Pommeret, Salhi, Vandekerkhove (2024) <a href="https://doi.org/10.3150/23-BEJ1593">doi:10.3150/23-BEJ1593</a>). Finally, clustering of unknown mixture components is also feasible in a K-sample setting (see Milhaud, Pommeret, Salhi, Vandekerkhove (2024) <a href="https://jmlr.org/papers/v25/23-0914.html">https://jmlr.org/papers/v25/23-0914.html</a>).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Pierre Vandekerkhove [contributor]
</p>
</li>
<li><p> Denys Pommeret [contributor]
</p>
</li>
<li><p> Yahia Salhi [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/XavierMilhaud/admix-Rpackage">https://github.com/XavierMilhaud/admix-Rpackage</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/XavierMilhaud/admix-Rpackage/issues">https://github.com/XavierMilhaud/admix-Rpackage/issues</a>
</p>
</li></ul>


<hr>
<h2 id='admix_cluster'>Clustering of K populations following admixture models</h2><span id='topic+admix_cluster'></span>

<h3>Description</h3>

<p>Create clusters on the unknown components related to the K populations following admixture models. Based on the K-sample test
using Inversion - Best Matching (IBM) approach, see 'Details' below for further information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>admix_cluster(
  samples,
  admixMod,
  conf_level = 0.95,
  tune_penalty = TRUE,
  tabul_dist = NULL,
  echo = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="admix_cluster_+3A_samples">samples</code></td>
<td>
<p>A list of the K (K&gt;1) samples to be studied, all following admixture distributions.</p>
</td></tr>
<tr><td><code id="admix_cluster_+3A_admixmod">admixMod</code></td>
<td>
<p>A list of objects of class <a href="#topic+admix_model">admix_model</a>, containing useful information about distributions and parameters.</p>
</td></tr>
<tr><td><code id="admix_cluster_+3A_conf_level">conf_level</code></td>
<td>
<p>(default to 0.95) The confidence level of the k-sample tests used in the clustering procedure.</p>
</td></tr>
<tr><td><code id="admix_cluster_+3A_tune_penalty">tune_penalty</code></td>
<td>
<p>(default to TRUE) A boolean that allows to choose between a classical penalty term or an optimized penalty (embedding
some tuning parameters, automatically optimized). Optimized penalty is particularly useful for low/mid-sized samples,
or unbalanced sample sizes to detect alternatives to the null hypothesis (H0). It is recommended to use it.</p>
</td></tr>
<tr><td><code id="admix_cluster_+3A_tabul_dist">tabul_dist</code></td>
<td>
<p>(default to NULL) Only useful for comparisons of detected clusters at different confidence levels. A list of
the tabulated distributions of the stochastic integral used in the k-sample test, each element for each
cluster previously detected.</p>
</td></tr>
<tr><td><code id="admix_cluster_+3A_echo">echo</code></td>
<td>
<p>(default to TRUE) Display the remaining computation time.</p>
</td></tr>
<tr><td><code id="admix_cluster_+3A_...">...</code></td>
<td>
<p>Optional arguments to <a href="#topic+IBM_k_samples_test">IBM_k_samples_test</a>; namely 'n_sim_tab', 'parallel' and 'n_cpu'. These are crucial
to speed-up the building of clusters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="#topic+admix_cluster">admix_cluster</a>, containing 12 attributes: 1) the number of samples under study; 2) the sizes of samples;
3) the information about mixture components in each sample (distributions and parameters); 4) the number of detected clusters;
5) the list of p-values for each k-sample test at the origin of detected clusters; 6) the cluster affiliation for each sample;
7) the confidence level of statistical tests; 8) which samples in which cluster; 9) the size of clusters; 10) the estimated
weights of the unknown component distributions inside each cluster (remind that estimated weights are consistent only if
unknown components are tested to be identical, which is the case inside clusters); 11) the matrix of pairwise discrepancies
across all samples; 12) the list of tabulated distributions used for statistical tests involved in building the clusters.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>References</h3>

<p>Milhaud X, Pommeret D, Salhi Y, Vandekerkhove P (2024).
&ldquo;Contamination-source based K-sample clustering.&rdquo;
<em>Journal of Machine Learning Research</em>, <b>25</b>(287), 1&ndash;32.
<a href="https://jmlr.org/papers/v25/23-0914.html">https://jmlr.org/papers/v25/23-0914.html</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Simulate mixture data:
mixt1 &lt;- twoComp_mixt(n = 2600, weight = 0.8,
                      comp.dist = list("gamma", "exp"),
                      comp.param = list(list("shape" = 16, "scale" = 1/4),
                                        list("rate" = 1/3.5)))
mixt2 &lt;- twoComp_mixt(n = 3000, weight = 0.7,
                      comp.dist = list("gamma", "exp"),
                      comp.param = list(list("shape" = 14, "scale" = 1/2),
                                        list("rate" = 1/5)))
mixt3 &lt;- twoComp_mixt(n = 3500, weight = 0.6,
                      comp.dist = list("gamma", "gamma"),
                      comp.param = list(list("shape" = 16, "scale" = 1/4),
                                        list("shape" = 12, "scale" = 1/2)))
mixt4 &lt;- twoComp_mixt(n = 4800, weight = 0.5,
                      comp.dist = list("gamma", "exp"),
                      comp.param = list(list("shape" = 14, "scale" = 1/2),
                                        list("rate" = 1/7)))
data1 &lt;- getmixtData(mixt1)
data2 &lt;- getmixtData(mixt2)
data3 &lt;- getmixtData(mixt3)
data4 &lt;- getmixtData(mixt4)
## Define the admixture models:
admixMod1 &lt;- admix_model(knownComp_dist = mixt1$comp.dist[[2]],
                         knownComp_param = mixt1$comp.param[[2]])
admixMod2 &lt;- admix_model(knownComp_dist = mixt2$comp.dist[[2]],
                         knownComp_param = mixt2$comp.param[[2]])
admixMod3 &lt;- admix_model(knownComp_dist = mixt3$comp.dist[[2]],
                         knownComp_param = mixt3$comp.param[[2]])
admixMod4 &lt;- admix_model(knownComp_dist = mixt4$comp.dist[[2]],
                         knownComp_param = mixt4$comp.param[[2]])
## Clustering procedure:
admix_cluster(samples = list(data1, data2, data3, data4),
              admixMod = list(admixMod1, admixMod2, admixMod3, admixMod4),
              conf_level = 0.95, tune_penalty = TRUE, n_sim_tab = 30)


</code></pre>

<hr>
<h2 id='admix_estim'>Estimate the unknown parameters of the admixture model(s)</h2><span id='topic+admix_estim'></span>

<h3>Description</h3>

<p>Estimate the component weights, the location shift parameter (in case of a symmetric unknown component density),
and the unknown component distribution using different estimation techniques. We remind that the i-th admixture
model has probability density function (pdf) l_i such that:
l_i = p_i * f_i + (1-p_i) * g_i, where g_i is the known component density.
The unknown quantities p_i and f_i then have to be estimated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>admix_estim(samples, admixMod, est_method = c("PS", "BVdk", "IBM"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="admix_estim_+3A_samples">samples</code></td>
<td>
<p>A list of the K (K&gt;0) samples to be studied, all following admixture distributions.</p>
</td></tr>
<tr><td><code id="admix_estim_+3A_admixmod">admixMod</code></td>
<td>
<p>A list of objects of class <a href="#topic+admix_model">admix_model</a>, containing useful information about distributions and parameters.</p>
</td></tr>
<tr><td><code id="admix_estim_+3A_est_method">est_method</code></td>
<td>
<p>The estimation method to be applied. Can be one of 'BVdk' (Bordes and Vandekerkhove estimator), 'PS' (Patra and Sen
estimator), or 'IBM' (Inversion Best-Matching approach) in the continuous case (continuous random variable). Only 'IBM' for
discrete random variables. The same estimation method is performed on each sample if several samples are provided.</p>
</td></tr>
<tr><td><code id="admix_estim_+3A_...">...</code></td>
<td>
<p>Optional arguments to <a href="#topic+estim_PS">estim_PS</a>, <a href="#topic+estim_BVdk">estim_BVdk</a> or <a href="#topic+estim_IBM">estim_IBM</a> depending on the
choice made by the user for the estimation method.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For further details on the different estimation techniques, see references below on i) Patra and Sen estimator ;
ii) Bordes and Vandekerkhove estimator ; iii) Inversion Best-Matching approach. Important note: estimation by 'IBM'
requires at least two samples at hand, and provides unbiased estimators only if the distributions of unknown components
are equal (meaning that it requires to perform previously this test between the pairs of samples, see ?admix_test).
</p>


<h3>Value</h3>

<p>An object of class <a href="#topic+admix_estim">admix_estim</a>, containing at least 5 attributes: 1) the number of samples under study; 2) the information
about the mixture components (distributions and parameters); 3) the sizes of the samples; 4) the chosen estimation technique
(one of 'BVdk', 'PS' or 'IBM'); 5) the estimated mixing proportions (weights of the unknown component distributions in the
mixture model). In case of 'BVdk' estimation, one additional attribute corresponding to the estimated location shift parameter
is included.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>References</h3>

<p>Patra RK, Sen B (2016).
&ldquo;Estimation of a two-component mixture model with applications to multiple testing.&rdquo;
<em>Journal of the Royal Statistical Society Series B</em>, <b>78</b>(4), 869-893.
Bordes L, Delmas C, Vandekerkhove P (2006).
&ldquo;Semiparametric Estimation of a Two-Component Mixture Model Where One Component Is Known.&rdquo;
<em>Scandinavian Journal of Statistics</em>, <b>33</b>(4), 733&ndash;752.
ISSN 03036898, 14679469, <a href="http://www.jstor.org/stable/4616955">http://www.jstor.org/stable/4616955</a>.
Bordes L, Vandekerkhove P (2010).
&ldquo;Semiparametric two-component mixture model with a known component: An asymptotically normal estimator.&rdquo;
<em>Mathematical Methods of Statistics</em>, <b>19</b>(1), 22&ndash;41.
<a href="https://doi.org/10.3103/S1066530710010023">doi:10.3103/S1066530710010023</a>.
Milhaud X, Pommeret D, Salhi Y, Vandekerkhove P (2024).
&ldquo;Two-sample contamination model test.&rdquo;
<em>Bernoulli</em>, <b>30</b>(1), 170&ndash;197.
<a href="https://doi.org/10.3150/23-BEJ1593">doi:10.3150/23-BEJ1593</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate mixture data:
mixt1 &lt;- twoComp_mixt(n = 300, weight = 0.7,
                      comp.dist = list("norm", "norm"),
                      comp.param = list(list("mean" = -2, "sd" = 0.5),
                                        list("mean" = 0, "sd" = 1)))
mixt2 &lt;- twoComp_mixt(n = 250, weight = 0.85,
                      comp.dist = list("norm", "exp"),
                      comp.param = list(list("mean" = -2, "sd" = 0.5),
                                        list("rate" = 1)))
data1 &lt;- getmixtData(mixt1)
data2 &lt;- getmixtData(mixt2)
## Define the admixture models:
admixMod1 &lt;- admix_model(knownComp_dist = mixt1$comp.dist[[2]],
                         knownComp_param = mixt1$comp.param[[2]])
admixMod2 &lt;- admix_model(knownComp_dist = mixt2$comp.dist[[2]],
                         knownComp_param = mixt2$comp.param[[2]])
# Estimation by different methods:
admix_estim(samples=list(data1), admixMod=list(admixMod1), est_method = "BVdk")
admix_estim(samples=list(data1,data2), admixMod=list(admixMod1,admixMod2), est_method = "PS")
admix_estim(samples=list(data1,data2), admixMod=list(admixMod1,admixMod2), est_method = "IBM")

</code></pre>

<hr>
<h2 id='admix_model'>Create an object of class 'admix_model'</h2><span id='topic+admix_model'></span>

<h3>Description</h3>

<p>Create an admixture model, also known as (aka) a contamination model. Such a model is a two-component
mixture model with one known component. Both the second component distribution and the mixing weight
are unknown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>admix_model(knownComp_dist, knownComp_param)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="admix_model_+3A_knowncomp_dist">knownComp_dist</code></td>
<td>
<p>(Character) The name of the distribution (specified as in R glossary) of the known component
of the admixture model</p>
</td></tr>
<tr><td><code id="admix_model_+3A_knowncomp_param">knownComp_param</code></td>
<td>
<p>(Character) A vector of the names of the parameters (specified as in R glossary) involved in
the chosen known distribution, with their values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="#topic+admix_model">admix_model</a>, containing 2 attributes: 1) a list that gives the information about the distributions
involved in the two-component mixture model (the unknown and the known ones); 2) a list that gives the information about
the corresponding parameters of those distributions.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>admix_model(knownComp_dist = "norm", knownComp_param = list("mean"=0, "sd"=1))
admix_model(knownComp_dist = "exp", knownComp_param = list("rate"=2))
admix_model(knownComp_dist = "multinom", knownComp_param = list("size"=1, "prob"=c(0.2,0.8,0.1)))

</code></pre>

<hr>
<h2 id='admix_test'>Equality test for the unknown components of admixture models</h2><span id='topic+admix_test'></span>

<h3>Description</h3>

<p>Perform hypothesis test between unknown components of a list of admixture models, where we remind that the i-th admixture
model has probability density function (pdf) l_i such that:
l_i = p_i * f_i + (1-p_i) * g_i, with g_i the known component density.
The unknown quantities p_i and f_i are thus estimated, leading to the test given by the following null and alternative hypothesis:
H0: f_i = f_j for all i != j   against H1 : there exists at least i != j such that f_i differs from f_j.
The test can be performed using two methods, either the comparison of coefficients obtained through polynomial basis expansions
of the component densities, or by the inner-convergence property obtained using the IBM approach. See 'Details' below for further information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>admix_test(
  samples,
  admixMod,
  test_method = c("poly", "icv"),
  conf_level = 0.95,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="admix_test_+3A_samples">samples</code></td>
<td>
<p>A list of the K (K &gt; 0) samples to be studied, each one assumed to follow a mixture distribution.</p>
</td></tr>
<tr><td><code id="admix_test_+3A_admixmod">admixMod</code></td>
<td>
<p>A list of objects of class <a href="#topic+admix_model">admix_model</a>, containing useful information about distributions and parameters
of the contamination / admixture models under study.</p>
</td></tr>
<tr><td><code id="admix_test_+3A_test_method">test_method</code></td>
<td>
<p>The testing method to be applied. Can be either 'poly' (polynomial basis expansion) or 'icv' (inner
convergence from IBM). The same testing method is performed between all samples. In the one-sample case,
only 'Poly' is available and the test is a gaussianity test. For further details, see section 'Details' below.</p>
</td></tr>
<tr><td><code id="admix_test_+3A_conf_level">conf_level</code></td>
<td>
<p>The confidence level of the K-sample test.</p>
</td></tr>
<tr><td><code id="admix_test_+3A_...">...</code></td>
<td>
<p>Depending on the choice made by the user for the test method ('poly' or 'icv'), optional arguments to
<a href="#topic+gaussianity_test">gaussianity_test</a> or <a href="#topic+orthobasis_test">orthobasis_test</a> (in case of 'poly'), and to <a href="#topic+IBM_k_samples_test">IBM_k_samples_test</a>
in case of 'icv'.
.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For further details on implemented hypothesis tests, see the references hereafter.
.
</p>


<h3>Value</h3>

<p>An object of class <a href="#topic+admix_test">admix_test</a>, containing 8 attributes: 1) the test decision (reject the null hypothesis or not);
2) the p-value of the test; 3) the confidence level of the test (1-alpha, where alpha denotes the level of the test
or equivalently the type-I error); 4) the value of the test statistic; 5) the number of samples under study; 6) the
respective size of each sample; 7) the information about mixture components (distributions and parameters); 8) the
chosen testing method (either based on polynomial basis expansions, or on the inner convergence property; see given
references).
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>References</h3>

<p>Milhaud X, Pommeret D, Salhi Y, Vandekerkhove P (2024).
&ldquo;Contamination-source based K-sample clustering.&rdquo;
<em>Journal of Machine Learning Research</em>, <b>25</b>(287), 1&ndash;32.
<a href="https://jmlr.org/papers/v25/23-0914.html">https://jmlr.org/papers/v25/23-0914.html</a>.
Milhaud X, Pommeret D, Salhi Y, Vandekerkhove P (2022).
&ldquo;Semiparametric two-sample admixture components comparison test: The symmetric case.&rdquo;
<em>Journal of Statistical Planning and Inference</em>, <b>216</b>, 135-150.
ISSN 0378-3758, <a href="https://doi.org/10.1016/j.jspi.2021.05.010">doi:10.1016/j.jspi.2021.05.010</a>.
Pommeret D, Vandekerkhove P (2019).
&ldquo;Semiparametric density testing in the contamination model.&rdquo;
<em>Electronic Journal of Statistics</em>, 4743&ndash;4793.
<a href="https://doi.org/10.1214/19-EJS1650">doi:10.1214/19-EJS1650</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>####### Example with 2 samples
mixt1 &lt;- twoComp_mixt(n = 380, weight = 0.7,
                      comp.dist = list("norm", "norm"),
                      comp.param = list(list("mean" = -2, "sd" = 0.5),
                                        list("mean" = 0, "sd" = 1)))
mixt2 &lt;- twoComp_mixt(n = 350, weight = 0.85,
                      comp.dist = list("norm", "norm"),
                      comp.param = list(list("mean" = -2, "sd" = 0.5),
                                        list("mean" = -1, "sd" = 1)))
data1 &lt;- getmixtData(mixt1)
data2 &lt;- getmixtData(mixt2)
admixMod1 &lt;- admix_model(knownComp_dist = mixt1$comp.dist[[2]],
                         knownComp_param = mixt1$comp.param[[2]])
admixMod2 &lt;- admix_model(knownComp_dist = mixt2$comp.dist[[2]],
                         knownComp_param = mixt2$comp.param[[2]])
admix_test(samples = list(data1,data2), admixMod = list(admixMod1,admixMod2),
           conf_level = 0.95, test_method = "poly", ask_poly_param = FALSE, support = "Real")

</code></pre>

<hr>
<h2 id='allGalaxies'>Measurements of heliocentric velocities in four galaxies</h2><span id='topic+allGalaxies'></span>

<h3>Description</h3>

<p>An evolving data frame of velocities for 4 dSph galaxies (namely Carina, Sextans, Sculptor and Fornax),
from SIMBAD astronomical database.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allGalaxies
</code></pre>


<h3>Format</h3>

<p>Currently contains 8,862 rows and 3 columns, with information on:
</p>

<dl>
<dt>Target</dt><dd><p>Target identification; Galaxy-ID number</p>
</dd>
<dt>HV</dt><dd><p>Weighted mean Heliocentric rest frame velocity</p>
</dd>
<dt>Name</dt><dd><p>The name of the galaxy</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://vizier.u-strasbg.fr/viz-bin/VizieR-3?-source=J/AJ/137/3100/stars&amp;-out.max=50&amp;-out.form=HTML%20Table&amp;-out.add=_r&amp;-out.add=_RAJ,_DEJ&amp;-out.add=_RA%2a-c.eq,_DE%2a-c.eq&amp;-sort=_r&amp;-oc.form=sexa">https://vizier.u-strasbg.fr/viz-bin/VizieR-3?-source=J/AJ/137/3100/stars&amp;-out.max=50&amp;-out.form=HTML%20Table&amp;-out.add=_r&amp;-out.add=_RAJ,_DEJ&amp;-out.add=_RA%2a-c.eq,_DE%2a-c.eq&amp;-sort=_r&amp;-oc.form=sexa</a>
</p>

<hr>
<h2 id='decontaminated_cdf'>Estimates the decontaminated CDF of the unknown component in an admixture</h2><span id='topic+decontaminated_cdf'></span>

<h3>Description</h3>

<p>Estimates the decontaminated cumulative distribution function (CDF) of the unknown component in an admixture model, using inversion of the admixture
CDF. Recall that an admixture model follows the cumulative distribution function (CDF) L, where
L = p*F + (1-p)*G, with g a known CDF and p and f unknown quantities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decontaminated_cdf(sample1, estim.p, admixMod)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="decontaminated_cdf_+3A_sample1">sample1</code></td>
<td>
<p>Observations of the sample under study.</p>
</td></tr>
<tr><td><code id="decontaminated_cdf_+3A_estim.p">estim.p</code></td>
<td>
<p>The estimated weight of the unknown component distribution, related to the proportion of the unknown component
in the admixture model studied.</p>
</td></tr>
<tr><td><code id="decontaminated_cdf_+3A_admixmod">admixMod</code></td>
<td>
<p>An object of class 'admix_model', containing useful information about distributions and parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The decontaminated CDF is obtained by inverting the admixture CDF, given by L = p*F + (1-p)*G, to isolate the
unknown component F after having estimated p. This means that F = (1/hat(p)) * (hat(L)-(1-p)*G).
</p>


<h3>Value</h3>

<p>The decontaminated CDF F of the admixture model, of class 'stepfun' (step function).
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate mixture data:
mixt1 &lt;- twoComp_mixt(n = 400, weight = 0.4,
                      comp.dist = list("norm", "norm"),
                      comp.param = list(list("mean" = 3, "sd" = 0.5),
                                        list("mean" = 0, "sd" = 1)))
mixt2 &lt;- twoComp_mixt(n = 300, weight = 0.6,
                      comp.dist = list("norm", "norm"),
                      comp.param = list(list("mean" = 3, "sd" = 0.5),
                                        list("mean" = 5, "sd" = 2)))
data1 &lt;- getmixtData(mixt1)
data2 &lt;- getmixtData(mixt2)
## Define the admixture models:
admixMod1 &lt;- admix_model(knownComp_dist = mixt1$comp.dist[[2]],
                         knownComp_param = mixt1$comp.param[[2]])
admixMod2 &lt;- admix_model(knownComp_dist = mixt2$comp.dist[[2]],
                         knownComp_param = mixt2$comp.param[[2]])
## Estimation:
est &lt;- admix_estim(samples = list(data1,data2),
                   admixMod = list(admixMod1,admixMod2), est_method = 'PS')
prop &lt;- getmixingWeight(est)
## Determine the decontaminated version of the unknown CDF by inversion:
F1 &lt;- decontaminated_cdf(sample1 = data1, estim.p = prop[1], admixMod = admixMod1)
F2 &lt;- decontaminated_cdf(sample1 = data2, estim.p = prop[2], admixMod = admixMod2)
abs &lt;- seq(from=-1, to=4, length.out=100)
plot(x=abs, y=F1(abs), xlim=c(-1,4), ylim=c(0,1), type="l")
par(new = TRUE)
plot(x=abs, y=F2(abs), xlim=c(-1,4), ylim=c(0,1), type="l", col="red")

</code></pre>

<hr>
<h2 id='decontaminated_density'>Estimates the decontaminated density of the unknown component in an admixture</h2><span id='topic+decontaminated_density'></span>

<h3>Description</h3>

<p>Estimate the decontaminated density of the unknown component in the admixture model under study, after inversion of the admixture
cumulative distribution function. Recall that an admixture model follows the cumulative distribution function (CDF) L, where
L = p*F + (1-p)*G, with g a known CDF and p and f unknown quantities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decontaminated_density(sample1, estim.p, admixMod)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="decontaminated_density_+3A_sample1">sample1</code></td>
<td>
<p>Sample under study.</p>
</td></tr>
<tr><td><code id="decontaminated_density_+3A_estim.p">estim.p</code></td>
<td>
<p>The estimated weight of the unknown component distribution, related to the proportion of the unknown component
in the admixture model studied.</p>
</td></tr>
<tr><td><code id="decontaminated_density_+3A_admixmod">admixMod</code></td>
<td>
<p>An object of class 'admix_model', containing useful information about distributions and parameters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The decontaminated density is obtained by inverting the admixture density, given by l = p*f + (1-p)*g, to isolate the
unknown component f after having estimated p.
</p>


<h3>Value</h3>

<p>An object of class 'decontaminated_density', containing 2 attributes: 1) the decontaminated density function;
2) the type of support for the underlying distribution (either discrete or continuous, useful for plots).
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate mixture data:
mixt1 &lt;- twoComp_mixt(n = 400, weight = 0.4,
                      comp.dist = list("norm", "norm"),
                      comp.param = list(list("mean" = -2, "sd" = 0.5),
                                        list("mean" = 0, "sd" = 1)))
data1 &lt;- getmixtData(mixt1)
## Define the admixture models:
admixMod1 &lt;- admix_model(knownComp_dist = mixt1$comp.dist[[2]],
                         knownComp_param = mixt1$comp.param[[2]])
## Estimation:
est &lt;- admix_estim(samples = list(data1), admixMod = list(admixMod1),
                   est_method = 'PS')
## Determine the decontaminated version of the unknown density by inversion:
decontaminated_density(sample1 = data1, estim.p = est$estimated_mixing_weights[1],
                       admixMod = admixMod1)

####### Discrete support:
mixt1 &lt;- twoComp_mixt(n = 5000, weight = 0.6,
                      comp.dist = list("pois", "pois"),
                      comp.param = list(list("lambda" = 3),
                                        list("lambda" = 2)))
mixt2 &lt;- twoComp_mixt(n = 4000, weight = 0.8,
                      comp.dist = list("pois", "pois"),
                      comp.param = list(list("lambda" = 3),
                                        list("lambda" = 4)))
data1 &lt;- getmixtData(mixt1)
data2 &lt;- getmixtData(mixt2)
## Define the admixture models:
admixMod1 &lt;- admix_model(knownComp_dist = mixt1$comp.dist[[2]],
                         knownComp_param = mixt1$comp.param[[2]])
admixMod2 &lt;- admix_model(knownComp_dist = mixt2$comp.dist[[2]],
                         knownComp_param = mixt2$comp.param[[2]])
## Estimation:
est &lt;- admix_estim(samples = list(data1, data2),
                   admixMod = list(admixMod1, admixMod2), est_method = 'IBM')
## Determine the decontaminated version of the unknown density by inversion:
decontaminated_density(sample1 = data1, estim.p = est$estimated_mixing_weights[1],
                       admixMod = admixMod1)

####### Finite discrete support:
mixt1 &lt;- twoComp_mixt(n = 12000, weight = 0.6,
                      comp.dist = list("multinom", "multinom"),
                      comp.param = list(list("size" = 1, "prob" = c(0.3,0.4,0.3)),
                                        list("size" = 1, "prob" = c(0.6,0.3,0.1))))
mixt2 &lt;- twoComp_mixt(n = 10000, weight = 0.8,
                      comp.dist = list("multinom", "multinom"),
                      comp.param = list(list("size" = 1, "prob" = c(0.3,0.4,0.3)),
                                        list("size" = 1, "prob" = c(0.2,0.6,0.2))))
data1 &lt;- getmixtData(mixt1)
data2 &lt;- getmixtData(mixt2)
## Define the admixture models:
admixMod1 &lt;- admix_model(knownComp_dist = mixt1$comp.dist[[2]],
                         knownComp_param = mixt1$comp.param[[2]])
admixMod2 &lt;- admix_model(knownComp_dist = mixt2$comp.dist[[2]],
                         knownComp_param = mixt2$comp.param[[2]])
## Estimation:
est &lt;- admix_estim(samples = list(data1, data2),
                   admixMod = list(admixMod1, admixMod2), est_method = 'IBM')
## Determine the decontaminated version of the unknown density by inversion:
decontaminated_density(sample1 = data1, estim.p = est$estimated_mixing_weights[1],
                       admixMod = admixMod1)

</code></pre>

<hr>
<h2 id='estim_BVdk'>Estimation of the admixture parameters by Bordes &amp; Vandekerkhove (2010)</h2><span id='topic+estim_BVdk'></span>

<h3>Description</h3>

<p>Estimates parameters in an admixture model where the unknown component is assumed to have a symmetric density.
More precisely, estimates the two parameters (mixture weight and location shift) in the admixture model with pdf:
l(x) = p*f(x-mu) + (1-p)*g(x), x in R,
where g is the known component, p is the proportion and f is the unknown component with symmetric density.
The localization shift parameter is denoted mu, and the component weight p.
See the reference below for further details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estim_BVdk(
  samples,
  admixMod,
  method = c("L-BFGS-B", "Nelder-Mead"),
  compute_var = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estim_BVdk_+3A_samples">samples</code></td>
<td>
<p>The observed sample under study.</p>
</td></tr>
<tr><td><code id="estim_BVdk_+3A_admixmod">admixMod</code></td>
<td>
<p>An object of class <a href="#topic+admix_model">admix_model</a>, containing useful information about distributions and parameters.</p>
</td></tr>
<tr><td><code id="estim_BVdk_+3A_method">method</code></td>
<td>
<p>The method used throughout the optimization process, either 'L-BFGS-B' or 'Nelder-Mead' (see ?optim).</p>
</td></tr>
<tr><td><code id="estim_BVdk_+3A_compute_var">compute_var</code></td>
<td>
<p>(default to FALSE) A boolean that indicates whether one computes the variance
of the estimators of unknown mixing proportions and location shift parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="#topic+estim_BVdk">estim_BVdk</a>, containing 8 attributes: 1) the number of sample under study (set to 1 here);
2) the sample size; 3) the information about mixture components (distributions and parameters); 4) the estimation
method (Bordes and Vandekerkhove here, see the given reference); 5) the estimated mixing proportion (weight of the
unknown component distribution); 6) the estimated location parameter of the unknown component distribution (with symetric
density); 7) the variance of the two estimators (respectively the mixing proportion and location shift); 8) the optimization
method that was used.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>References</h3>

<p>Bordes L, Vandekerkhove P (2010).
&ldquo;Semiparametric two-component mixture model with a known component: An asymptotically normal estimator.&rdquo;
<em>Mathematical Methods of Statistics</em>, <b>19</b>(1), 22&ndash;41.
<a href="https://doi.org/10.3103/S1066530710010023">doi:10.3103/S1066530710010023</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate mixture data:
mixt1 &lt;- twoComp_mixt(n = 200, weight = 0.4,
                      comp.dist = list("norm", "norm"),
                      comp.param = list(list("mean" = -2, "sd" = 0.5),
                                        list("mean" = 0, "sd" = 1)))
## Retrieves the mixture data:
data1 &lt;- getmixtData(mixt1)
## Define the admixture model:
admixMod &lt;- admix_model(knownComp_dist = mixt1$comp.dist[[2]],
                        knownComp_param = mixt1$comp.param[[2]])
## Perform the estimation of parameters in real-life:
estim_BVdk(samples = data1, admixMod = admixMod, method = 'L-BFGS-B')

## Second example:
mixt2 &lt;- twoComp_mixt(n = 200, weight = 0.65,
                      comp.dist = list("norm", "exp"),
                      comp.param = list(list("mean" = -1, "sd" = 0.5),
                                        list("rate" = 1)))
data2 &lt;- getmixtData(mixt2)
admixMod2 &lt;- admix_model(knownComp_dist = mixt2$comp.dist[[2]],
                        knownComp_param = mixt2$comp.param[[2]])
## Perform the estimation of parameters in real-life:
estim_BVdk(samples = data2, admixMod = admixMod2, method = 'L-BFGS-B',
           compute_var = TRUE)

</code></pre>

<hr>
<h2 id='estim_IBM'>Estimates weights of unknown components from 2 admixtures using IBM</h2><span id='topic+estim_IBM'></span>

<h3>Description</h3>

<p>Estimation of the component weights from the Inversion - Best Matching (IBM) method, related to two admixture models
with respective probability density function (pdf) l1 and l2, such that:
l1 = p1*f1 + (1-p1)<em>g1 and l2 = p2</em>f2 + (1-p2)*g2, where g1 and g2 are the known component densities.
For further details about IBM approach, see 'Details' below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estim_IBM(samples, admixMod, n.integ = 1000, compute_var = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estim_IBM_+3A_samples">samples</code></td>
<td>
<p>A list of the two considered samples.</p>
</td></tr>
<tr><td><code id="estim_IBM_+3A_admixmod">admixMod</code></td>
<td>
<p>A list of two objects of class <a href="#topic+admix_model">admix_model</a>, one for each sample.</p>
</td></tr>
<tr><td><code id="estim_IBM_+3A_n.integ">n.integ</code></td>
<td>
<p>Number of data points generated for the distribution on which to integrate.</p>
</td></tr>
<tr><td><code id="estim_IBM_+3A_compute_var">compute_var</code></td>
<td>
<p>(default to FALSE) A boolean that indicates whether one computes the variance
of the estimators of unknown mixing proportions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="#topic+estim_IBM">estim_IBM</a>, containing 7 attributes: 1) the number of samples under study; 2) the sizes of samples;
3) the information about mixture components (distributions and parameters) for each sample; 4) the estimation
method (Inversion Best Matching here, see the given reference); 5) the estimated mixing proportions (weights of the
unknown component distributions in each sample); 6) the arbitrary value of the mixing weight in the first admixture sample
(in case of equal known components, see the given reference); 7) the support of integration that was used in the computations.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>References</h3>

<p>Milhaud X, Pommeret D, Salhi Y, Vandekerkhove P (2024).
&ldquo;Two-sample contamination model test.&rdquo;
<em>Bernoulli</em>, <b>30</b>(1), 170&ndash;197.
<a href="https://doi.org/10.3150/23-BEJ1593">doi:10.3150/23-BEJ1593</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Continuous support: simulate mixture data.
mixt1 &lt;- twoComp_mixt(n = 1500, weight = 0.5,
                      comp.dist = list("norm", "norm"),
                      comp.param = list(list("mean" = 3, "sd" = 0.5),
                                        list("mean" = 0, "sd" = 1)))
data1 &lt;- getmixtData(mixt1)
mixt2 &lt;- twoComp_mixt(n = 2000, weight = 0.7,
                      comp.dist = list("norm", "norm"),
                      comp.param = list(list("mean" = 3, "sd" = 0.5),
                                        list("mean" = 5, "sd" = 2)))
data2 &lt;- getmixtData(mixt2)
## Define the admixture models:
admixMod1 &lt;- admix_model(knownComp_dist = mixt1$comp.dist[[2]],
                         knownComp_param = mixt1$comp.param[[2]])
admixMod2 &lt;- admix_model(knownComp_dist = mixt2$comp.dist[[2]],
                         knownComp_param = mixt2$comp.param[[2]])
## Estimate the mixture weights of the two admixture models (provide only hat(theta)_n):
estim_IBM(samples = list(data1,data2),
          admixMod = list(admixMod1,admixMod2), n.integ = 1000)

## Example 2: multinomial distribution (discrete case).
mixt1 &lt;- twoComp_mixt(n = 1500, weight = 0.8,
                      comp.dist = list("multinom", "multinom"),
                      comp.param = list(list("size" = 1, "prob" = c(0.2,0.3,0.5)),
                                        list("size" = 1, "prob" = c(0.1,0.6,0.3))))
data1 &lt;- getmixtData(mixt1)
mixt2 &lt;- twoComp_mixt(n = 2000, weight = 0.3,
                      comp.dist = list("multinom", "multinom"),
                      comp.param = list(list("size" = 1, "prob" = c(0.2,0.3,0.5)),
                                        list("size" = 1, "prob" = c(0.7,0.1,0.2))))
data2 &lt;- getmixtData(mixt2)
## Define the admixture models:
admixMod1 &lt;- admix_model(knownComp_dist = mixt1$comp.dist[[2]],
                         knownComp_param = mixt1$comp.param[[2]])
admixMod2 &lt;- admix_model(knownComp_dist = mixt2$comp.dist[[2]],
                         knownComp_param = mixt2$comp.param[[2]])
## Estimate the mixture weights of the two admixture models (provide only hat(theta)_n):
estim_IBM(samples = list(data1,data2), admixMod = list(admixMod1,admixMod2),
          compute_var = TRUE)

</code></pre>

<hr>
<h2 id='estim_PS'>Estimates in an admixture using Patra and Sen approach</h2><span id='topic+estim_PS'></span>

<h3>Description</h3>

<p>Estimation of both the weight and the distribution of the unknown component in an admixture model, by Patra and Sen approach.
Remind that the admixture probability density function (pdf) l is given by
l = p*f + (1-p)*g,
where g is the known component of the two-component mixture, p is the unknown proportion of the unknown component distribution f.
More information in 'Details' below concerning the estimation method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estim_PS(
  samples,
  admixMod,
  method = c("fixed", "lwr.bnd", "cv"),
  c.n = 0.1 * log(log(length(samples))),
  folds = 10,
  reps = 1,
  cn.s = NULL,
  cn.length = 100,
  gridsize = 1200
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="estim_PS_+3A_samples">samples</code></td>
<td>
<p>Sample to be studied.</p>
</td></tr>
<tr><td><code id="estim_PS_+3A_admixmod">admixMod</code></td>
<td>
<p>An object of class <a href="#topic+admix_model">admix_model</a>, containing information about the known component distribution and its parameter(s).</p>
</td></tr>
<tr><td><code id="estim_PS_+3A_method">method</code></td>
<td>
<p>One of 'lwr.bnd', fixed' or 'cv': depending on whether compute some lower bound of the mixing proportion, the estimate
based on the value of 'c.n' or use cross-validation for choosing 'c.n' (tuning parameter).</p>
</td></tr>
<tr><td><code id="estim_PS_+3A_c.n">c.n</code></td>
<td>
<p>(default to NULL) A positive number for the penalization, see reference below. If NULL, equals to 0.1*log(log(n)).</p>
</td></tr>
<tr><td><code id="estim_PS_+3A_folds">folds</code></td>
<td>
<p>(optional, default to 10) Number of folds used for cross-validation.</p>
</td></tr>
<tr><td><code id="estim_PS_+3A_reps">reps</code></td>
<td>
<p>(optional, default to 1) Number of replications for cross-validation.</p>
</td></tr>
<tr><td><code id="estim_PS_+3A_cn.s">cn.s</code></td>
<td>
<p>(optional) A sequence of 'c.n' to be used for cross-validation (vector of values). Default is equally
spaced grid of 100 values between .001 x log(log(n)) and 0.2 x log(log(n)).</p>
</td></tr>
<tr><td><code id="estim_PS_+3A_cn.length">cn.length</code></td>
<td>
<p>(optional, default to 100) Number of equally spaced tuning parameter (between .001 x log(log(n)) and 0.2 x log(log(n))).
Values to search from.</p>
</td></tr>
<tr><td><code id="estim_PS_+3A_gridsize">gridsize</code></td>
<td>
<p>(default to 600) Number of equally spaced points (between 0 and 1) to evaluate the distance function.
Larger values are more computationally intensive but also lead to more accurate estimates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="#topic+estim_PS">estim_PS</a>, containing 10 attributes: 1) the number of samples studied (1 in this case); 2) the sample
size; 3) the information about component distributions of the admixture model; 4) the estimation method 5patra and Sen here);
5) the estimated mixing weight (estimate of the unknown component proportion); 6) the estimated decontaminated CDF;
7) an object of the class 'dist.fun' (that gives the distance); 8) the tuning parameter 'c.n'; 9) the lower bound of the
estimated mixing proportion (if such an option has been chosen); 10) the number of observations.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>References</h3>

<p>Patra RK, Sen B (2016).
&ldquo;Estimation of a two-component mixture model with applications to multiple testing.&rdquo;
<em>Journal of the Royal Statistical Society Series B</em>, <b>78</b>(4), 869-893.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate mixture data:
mixt1 &lt;- twoComp_mixt(n = 800, weight = 0.33,
                      comp.dist = list("gamma", "exp"),
                      comp.param = list(list("shape" = 2, "scale" = 0.5),
                                        list("rate" = 0.25)))
data1 &lt;- getmixtData(mixt1)
## Define the admixture model:
admixMod1 &lt;- admix_model(knownComp_dist = mixt1$comp.dist[[2]],
                         knownComp_param = mixt1$comp.param[[2]])
## Estimation step:
estim_PS(samples = data1, admixMod = admixMod1, method = 'fixed')


</code></pre>

<hr>
<h2 id='gaussianity_test'>Gaussianity test in an admixture model</h2><span id='topic+gaussianity_test'></span>

<h3>Description</h3>

<p>Performs an hypothesis test to check for the gaussianity of the unknown mixture component, given that the known component
has support on the real line. Recall that an admixture model has probability density function (pdf) l = p*f + (1-p)*g, where g is
the known pdf and l is observed (others are unknown). This test requires optimization (to estimate the unknown parameters) as
defined by Bordes &amp; Vandekerkhove (2010), which means that the unknown mixture component must have a symmetric density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussianity_test(
  samples,
  admixMod,
  conf_level = 0.95,
  ask_poly_param = FALSE,
  K = 3,
  s = 0.25,
  support = c("Real", "Integer", "Positive", "Bounded.continuous"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gaussianity_test_+3A_samples">samples</code></td>
<td>
<p>Sample under study.</p>
</td></tr>
<tr><td><code id="gaussianity_test_+3A_admixmod">admixMod</code></td>
<td>
<p>An object of class <a href="#topic+admix_model">admix_model</a>, containing useful information about distributions and parameters.</p>
</td></tr>
<tr><td><code id="gaussianity_test_+3A_conf_level">conf_level</code></td>
<td>
<p>(default to 0.95) The confidence level. Equals 1-alpha, where alpha is the level of the test (type-I error).</p>
</td></tr>
<tr><td><code id="gaussianity_test_+3A_ask_poly_param">ask_poly_param</code></td>
<td>
<p>(default to FALSE) If TRUE, ask the user to choose both the order 'K' of expansion coefficients in the
orthonormal polynomial basis, and the penalization rate 's' involved on the penalization rule for the test.</p>
</td></tr>
<tr><td><code id="gaussianity_test_+3A_k">K</code></td>
<td>
<p>(K &gt; 0, default to 3) If not asked (see the previous argument), number of coefficients considered for the polynomial basis expansion.</p>
</td></tr>
<tr><td><code id="gaussianity_test_+3A_s">s</code></td>
<td>
<p>(in ]0,1/2[, default to 0.25) If not asked (see the previous argument), normalization rate involved in the penalization rule
for model selection. See the reference below.</p>
</td></tr>
<tr><td><code id="gaussianity_test_+3A_support">support</code></td>
<td>
<p>Support of the probability distributions, useful to choose the appropriate polynomial orthonormal basis. One of 'Real',
'Integer', 'Positive', or 'Bounded.continuous'.</p>
</td></tr>
<tr><td><code id="gaussianity_test_+3A_...">...</code></td>
<td>
<p>Optional arguments to <a href="#topic+estim_BVdk">estim_BVdk</a>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Extensions to the case of non-Gaussian known components can be overcome thanks to basic transformations using cdf.
</p>


<h3>Value</h3>

<p>An object of class <a href="#topic+gaussianity_test">gaussianity_test</a>, containing 10 elements: 1) the number of populations under study (1 in this case);
2) the sample size; 3) the information about the known component distribution; 4) the reject decision of the test; 5) the
confidence level of the test, 6) the p-value of the test; 7) the value of the test statistic; 8) the variance of the test
statistic at each order in the polynomial orthobasis expansion; 9) the selected rank (order) for the test statistic;
10) a list of estimates (mixing weight, mean and standard deviation of the Gaussian unknown distribution).
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>References</h3>

<p>Pommeret D, Vandekerkhove P (2019).
&ldquo;Semiparametric density testing in the contamination model.&rdquo;
<em>Electronic Journal of Statistics</em>, 4743&ndash;4793.
<a href="https://doi.org/10.1214/19-EJS1650">doi:10.1214/19-EJS1650</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>####### Under the null hypothesis H0.
## Simulate mixture data:
mixt1 &lt;- twoComp_mixt(n = 250, weight = 0.4,
                      comp.dist = list("norm", "exp"),
                      comp.param = list(list("mean" = -2, "sd" = 0.5),
                                        list("rate" = 1)))
data1 &lt;- getmixtData(mixt1)
## Define the admixture models:
admixMod1 &lt;- admix_model(knownComp_dist = mixt1$comp.dist[[2]],
                         knownComp_param = mixt1$comp.param[[2]])
## Performs the test:
gaussianity_test(samples = data1, admixMod = admixMod1,
                 conf_level = 0.95, K = 3, s = 0.1, support = "Real")

</code></pre>

<hr>
<h2 id='getmixingWeight'>Extractor for object of class 'admix_estim'</h2><span id='topic+getmixingWeight'></span>

<h3>Description</h3>

<p>Get the estimated unknown mixing proportion related to the weight of
the unknown component distribution of the admixture model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getmixingWeight(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getmixingWeight_+3A_x">x</code></td>
<td>
<p>An object of class 'admix_estim'.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>

<hr>
<h2 id='getmixtData'>Extractor for object of class 'twoComp_mixt'</h2><span id='topic+getmixtData'></span>

<h3>Description</h3>

<p>Get the mixture data generated from method 'twoComp_mixt'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getmixtData(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getmixtData_+3A_x">x</code></td>
<td>
<p>An object of class 'twoComp_mixt'.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>

<hr>
<h2 id='IBM_k_samples_test'>Equality test of K unknown component distributions</h2><span id='topic+IBM_k_samples_test'></span>

<h3>Description</h3>

<p>Equality test of the unknown component distributions coming from K (K &gt; 1) admixture models, based on the Inversion - Best
Matching (IBM) approach. Recall that we have K populations following admixture models, each one with probability
density functions (pdf) l_k = p_k*f_k + (1-p_k)*g_k, where g_k is the known pdf and l_k corresponds to the
observed sample. Perform the following hypothesis test:
H0 : f_1 = ... = f_K  against  H1 : f_i differs from f_j (i different from j, and i,j in 1,...,K).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IBM_k_samples_test(
  samples,
  admixMod,
  conf_level = 0.95,
  sim_U = NULL,
  tune_penalty = TRUE,
  n_sim_tab = 100,
  parallel = FALSE,
  n_cpu = 2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IBM_k_samples_test_+3A_samples">samples</code></td>
<td>
<p>A list of the K samples to be studied, all following admixture distributions.</p>
</td></tr>
<tr><td><code id="IBM_k_samples_test_+3A_admixmod">admixMod</code></td>
<td>
<p>A list of objects of class class <a href="#topic+admix_model">admix_model</a>, containing useful information about distributions and parameters.</p>
</td></tr>
<tr><td><code id="IBM_k_samples_test_+3A_conf_level">conf_level</code></td>
<td>
<p>The confidence level of the K-sample test.</p>
</td></tr>
<tr><td><code id="IBM_k_samples_test_+3A_sim_u">sim_U</code></td>
<td>
<p>(default to NULL) Random draws of the inner convergence part of the contrast as defined in the IBM approach (see 'Details' below).</p>
</td></tr>
<tr><td><code id="IBM_k_samples_test_+3A_tune_penalty">tune_penalty</code></td>
<td>
<p>(default to TRUE) A boolean that allows to choose between a classical penalty term or an optimized penalty (embedding
some tuning parameters, automatically optimized). Optimized penalty is particularly useful for low or unbalanced sample sizes
to detect alternatives to the null hypothesis (H0). It is recommended to set it to TRUE.</p>
</td></tr>
<tr><td><code id="IBM_k_samples_test_+3A_n_sim_tab">n_sim_tab</code></td>
<td>
<p>(default to 100) Number of simulated Gaussian processes when tabulating the inner convergence distribution
in the 'icv' testing method using the IBM estimation approach.</p>
</td></tr>
<tr><td><code id="IBM_k_samples_test_+3A_parallel">parallel</code></td>
<td>
<p>(default to FALSE) Boolean to indicate whether parallel computations are performed (speed-up the tabulation).</p>
</td></tr>
<tr><td><code id="IBM_k_samples_test_+3A_n_cpu">n_cpu</code></td>
<td>
<p>(default to 2) Number of cores used when paralleling computations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="#topic+admix_test">admix_test</a>, containing 17 attributes: 1) the number of samples for the test; 2) the sizes of each sample;
3) the information about component distributions for each sample; 4) the reject decision of the test; 5) the confidence level
of the test (1-alpha, where alpha refers to the first-type error); 6) the test p-value; 7) the 95th-percentile of the contrast
tabulated distribution; 8) the test statistic value; 9) the selected rank (number of terms involved in the test statistic);
10) the terms (pairwise contrasts) involved in the test statistic; 11) A boolean indicating whether the penalization corresponds
to the null hypothesis has been considered; 12) the value of penalized test statistics; 13) the selected optimal 'gamma' parameter
(see reference below); 14) the selected optimal constant involved in the penalization process (see also the reference); 15) the
tabulated distribution of the contrast; 16) the estimated mixing proportions (not implemented yet, since that makes sense only
in case of equal unknown component distributions); 17) the matrix of pairwise contrasts (distance between two samples).
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>References</h3>

<p>Milhaud X, Pommeret D, Salhi Y, Vandekerkhove P (2024).
&ldquo;Contamination-source based K-sample clustering.&rdquo;
<em>Journal of Machine Learning Research</em>, <b>25</b>(287), 1&ndash;32.
<a href="https://jmlr.org/papers/v25/23-0914.html">https://jmlr.org/papers/v25/23-0914.html</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
####### Under the null hypothesis H0 (with K=3 populations):
## Simulate mixture data:
mixt1 &lt;- twoComp_mixt(n = 450, weight = 0.4,
                      comp.dist = list("norm", "norm"),
                      comp.param = list(list("mean" = -2, "sd" = 0.5),
                                        list("mean" = 0, "sd" = 1)))
mixt2 &lt;- twoComp_mixt(n = 380, weight = 0.7,
                      comp.dist = list("norm", "norm"),
                      comp.param = list(list("mean" = -2, "sd" = 0.5),
                                        list("mean" = 1, "sd" = 1)))
mixt3 &lt;- twoComp_mixt(n = 400, weight = 0.8,
                      comp.dist = list("norm", "exp"),
                      comp.param = list(list("mean" = -2, "sd" = 0.5),
                                        list("rate" = 1)))
data1 &lt;- getmixtData(mixt1)
data2 &lt;- getmixtData(mixt2)
data3 &lt;- getmixtData(mixt3)
## Define the admixture models:
admixMod1 &lt;- admix_model(knownComp_dist = mixt1$comp.dist[[2]],
                         knownComp_param = mixt1$comp.param[[2]])
admixMod2 &lt;- admix_model(knownComp_dist = mixt2$comp.dist[[2]],
                         knownComp_param = mixt2$comp.param[[2]])
admixMod3 &lt;- admix_model(knownComp_dist = mixt3$comp.dist[[2]],
                         knownComp_param = mixt3$comp.param[[2]])
## Perform the 3-samples test:
IBM_k_samples_test(samples = list(data1, data2, data3),
                   admixMod = list(admixMod1, admixMod2, admixMod3),
                   conf_level = 0.95, sim_U = NULL, n_sim_tab = 8,
                   tune_penalty = FALSE, parallel = FALSE, n_cpu = 2)


</code></pre>

<hr>
<h2 id='IBM_tabul_stochasticInteg'>Simulated distribution of the contrast using IBM</h2><span id='topic+IBM_tabul_stochasticInteg'></span>

<h3>Description</h3>

<p>Tabulate the distribution related to the inner convergence part of the contrast, by simulating trajectories of Gaussian
processes and applying some transformations. Useful to perform the test hypothesis, by retrieving the (1-alpha)-quantile
of interest. See 'Details' below and the cited paper therein for further information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IBM_tabul_stochasticInteg(
  samples,
  admixMod,
  min_size = NULL,
  n.varCovMat = 80,
  n_sim_tab = 100,
  parallel = FALSE,
  n_cpu = 2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="IBM_tabul_stochasticInteg_+3A_samples">samples</code></td>
<td>
<p>A list of the two samples under study.</p>
</td></tr>
<tr><td><code id="IBM_tabul_stochasticInteg_+3A_admixmod">admixMod</code></td>
<td>
<p>A list of two objects of class 'admix_model', with information about distributions and parameters.</p>
</td></tr>
<tr><td><code id="IBM_tabul_stochasticInteg_+3A_min_size">min_size</code></td>
<td>
<p>(optional, NULL by default) In the k-sample case, useful to provide the minimal size among all samples
(needed to take into account the correction factor for variance-covariance assessment). Otherwise, useless.</p>
</td></tr>
<tr><td><code id="IBM_tabul_stochasticInteg_+3A_n.varcovmat">n.varCovMat</code></td>
<td>
<p>(default to 80) Number of time points at which the Gaussian processes are simulated.</p>
</td></tr>
<tr><td><code id="IBM_tabul_stochasticInteg_+3A_n_sim_tab">n_sim_tab</code></td>
<td>
<p>(default to 100) Number of simulated Gaussian processes when tabulating the inner convergence distribution
in the 'icv' testing method using the IBM estimation approach.</p>
</td></tr>
<tr><td><code id="IBM_tabul_stochasticInteg_+3A_parallel">parallel</code></td>
<td>
<p>(default to FALSE) Boolean to indicate whether parallel computations are performed (speed-up the tabulation).</p>
</td></tr>
<tr><td><code id="IBM_tabul_stochasticInteg_+3A_n_cpu">n_cpu</code></td>
<td>
<p>(default to 2) Number of cores used when paralleling computations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with four elements, containing: 1) random draws of the contrast as defined in the reference given here;
2) estimated unknown component weights for the two admixture models; 3) the value of the the empirical contrast;
4) support that was used to evaluate the variance-covariance matrix of the empirical processes.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>References</h3>

<p>Milhaud X, Pommeret D, Salhi Y, Vandekerkhove P (2024).
&ldquo;Two-sample contamination model test.&rdquo;
<em>Bernoulli</em>, <b>30</b>(1), 170&ndash;197.
<a href="https://doi.org/10.3150/23-BEJ1593">doi:10.3150/23-BEJ1593</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Simulate mixture data:
mixt1 &lt;- twoComp_mixt(n = 1200, weight = 0.4,
                      comp.dist = list("norm", "norm"),
                      comp.param = list(list("mean" = -2, "sd" = 0.5),
                                        list("mean" = 0, "sd" = 1)))
mixt2 &lt;- twoComp_mixt(n = 1000, weight = 0.7,
                      comp.dist = list("norm", "norm"),
                      comp.param = list(list("mean" = -2, "sd" = 0.5),
                                        list("mean" = 1, "sd" = 1)))
data1 &lt;- getmixtData(mixt1)
data2 &lt;- getmixtData(mixt2)
## Define the admixture models:
admixMod1 &lt;- admix_model(knownComp_dist = mixt1$comp.dist[[2]],
                         knownComp_param = mixt1$comp.param[[2]])
admixMod2 &lt;- admix_model(knownComp_dist = mixt2$comp.dist[[2]],
                         knownComp_param = mixt2$comp.param[[2]])
IBM_tabul_stochasticInteg(samples = list(data1, data2), admixMod = list(admixMod1, admixMod2),
                          min_size=NULL, n.varCovMat=20, n_sim_tab=2, parallel=FALSE, n_cpu=2)


</code></pre>

<hr>
<h2 id='milkyWay'>Heliocentric velocity for the Milky Way</h2><span id='topic+milkyWay'></span>

<h3>Description</h3>

<p>Heliocentric velocity for the Milky Way
</p>


<h3>Usage</h3>

<pre><code class='language-R'>milkyWay
</code></pre>


<h3>Format</h3>

<p>A data frame with 170,601 rows and 1 column:
</p>

<dl>
<dt>V1</dt><dd><p>Heliocentric velocity measurements of the Milky way</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.aanda.org/articles/aa/full_html/2018/08/aa32905-18/aa32905-18.html">https://www.aanda.org/articles/aa/full_html/2018/08/aa32905-18/aa32905-18.html</a>
</p>


<h3>References</h3>

<p>Walker MG, Mateo M, Olszewski EW, Gnedin OY, Wang X, Sen B, Woodroofe M (2007).
&ldquo;Velocity Dispersion Profiles of Seven Dwarf Spheroidal Galaxies.&rdquo;
<em>The Astrophysical Journal</em>, <b>667</b>(1), L53L56.
ISSN 1538-4357, <a href="https://doi.org/10.1086/521998">doi:10.1086/521998</a>, <a href="http://dx.doi.org/10.1086/521998">http://dx.doi.org/10.1086/521998</a>.
</p>

<hr>
<h2 id='mortality_sample'>Deaths statistics in 11 european countries</h2><span id='topic+mortality_sample'></span>

<h3>Description</h3>

<p>Deaths statistics in 11 european countries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mortality_sample
</code></pre>


<h3>Format</h3>

<p>Dataset providing the exposure-to-death (population size) and number of deaths for males in 11 european countries,
between 1908 and 2020, with ages ranging from 30 years old to 85 years old. Exported from the Human Mortality Database (HMD).
The two first lists relate to some subsample of the population size and number of deaths in those countries, with
random sampling from the original dataset.
</p>
<p>An evolving data frame of exposure-to-death and number of deaths in Belgium, Switzerland, Denmark, Spain, Finland,
France, United Kingdom, Italia, The Netherlands, Norway and Sweden.
</p>

<dl>
<dt>XP</dt><dd><p>A list of eleven elements (one for each country) giving a subset of the exposure-to-death (or reduced population size),
each element having 56 rows (ages 30-85) and 113 columns (period 1908-2020)</p>
</dd>
<dt>DX</dt><dd><p>A list of eleven elements (one for each country) giving a subset of the number of deaths, each element having 56 rows
(ages 30-85) and 113 columns (period 1908-2020)</p>
</dd>
<dt>names</dt><dd><p>A list of eleven elements giving the names of the countries, in the same order as the elements in other lists</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.mortality.org">https://www.mortality.org</a>
</p>

<hr>
<h2 id='orthobasis_test'>Equality test of two unknown component distributions using polynomial expansions</h2><span id='topic+orthobasis_test'></span>

<h3>Description</h3>

<p>Tests the null hypothesis (H0: f1=f2) using the decomposition of unknown component densities of two admixture distributions in
an adequate orthonormal polynomial basis. Recall that we have two admixture models with respective probability density
functions (pdf) l1 = p1*f1 + (1-p1)<em>g1 and l2 = p2</em>f2 + (1-p2)*g2, where g1 and g2 are the only known elements and l1 and l2
are observed. The admixture weights p1 and p2 thus have to be estimated. For further information on this method, see 'Details' below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orthobasis_test(
  samples,
  admixMod,
  conf_level = 0.95,
  est_method = c("BVdk", "PS"),
  ask_poly_param = FALSE,
  K = 3,
  s = 0.25,
  nb_echBoot = 100,
  support = c("Real", "Integer", "Positive", "Bounded.continuous", "Bounded.discrete"),
  bounds_supp = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orthobasis_test_+3A_samples">samples</code></td>
<td>
<p>List of the two samples, each one following the mixture distribution given by l = p*f + (1-p)*g,
with f and p unknown and g known.</p>
</td></tr>
<tr><td><code id="orthobasis_test_+3A_admixmod">admixMod</code></td>
<td>
<p>An object of class <a href="#topic+admix_model">admix_model</a>, containing useful information about distributions and parameters.</p>
</td></tr>
<tr><td><code id="orthobasis_test_+3A_conf_level">conf_level</code></td>
<td>
<p>The confidence level, default to 95 percent. Equals 1-alpha, where alpha is the level of the test (type-I error).</p>
</td></tr>
<tr><td><code id="orthobasis_test_+3A_est_method">est_method</code></td>
<td>
<p>Estimation method to get the component weights, either 'PS' (Patra and Sen estimation) or 'BVdk'
(Bordes and Vendekerkhove estimation). Choosing 'PS' requires to specify the number of bootstrap samples.</p>
</td></tr>
<tr><td><code id="orthobasis_test_+3A_ask_poly_param">ask_poly_param</code></td>
<td>
<p>(default to FALSE) If TRUE, ask the user to choose both the order 'K' of expansion coefficients in the
orthonormal polynomial basis, and the penalization rate 's' involved on the penalization rule for the test.</p>
</td></tr>
<tr><td><code id="orthobasis_test_+3A_k">K</code></td>
<td>
<p>(K &gt; 0, default to 3) If not asked (see the previous argument), number of coefficients considered for the polynomial basis expansion.</p>
</td></tr>
<tr><td><code id="orthobasis_test_+3A_s">s</code></td>
<td>
<p>(in ]0,1/2[, default to 0.25) If not asked (see the previous argument), rate at which the normalization factor is set in
the penalization rule for model selection (in ]0,1/2[). Low values of 's' favors the detection of alternative hypothesis.
See reference below.
</p>
<p>[, default to 0.25) If not asked (see the previous argument), rate at which the normalization factor is set in
the penalization rule for model selection (in ]: R:,%20default%20to%200.25)%20If%20not%20asked%20(see%20the%20previous%20argument),%20rate%20at%20which%20the%20normalization%20factor%20is%20set%20in%0A%20%20%20%20%20%20%20%20%20%20the%20penalization%20rule%20for%20model%20selection%20(in%20</p>
</td></tr>
<tr><td><code id="orthobasis_test_+3A_nb_echboot">nb_echBoot</code></td>
<td>
<p>(default to 100) Number of bootstrap samples, useful when choosing 'PS' estimation method.</p>
</td></tr>
<tr><td><code id="orthobasis_test_+3A_support">support</code></td>
<td>
<p>Support of the probability distributions, useful to choose the appropriate polynomial orthonormal basis. One of 'Real',
'Integer', 'Positive', or 'Bounded.continuous'.</p>
</td></tr>
<tr><td><code id="orthobasis_test_+3A_bounds_supp">bounds_supp</code></td>
<td>
<p>(default to NULL) Useful if support = 'Bounded.continuous', a list of minimum and maximum bounds, specified as
following: list( list(min.f1,min.g1,min.f2,min.g2) , list(max.f1,max.g1,max.f2,max.g2) )</p>
</td></tr>
<tr><td><code id="orthobasis_test_+3A_...">...</code></td>
<td>
<p>Optional arguments to <a href="#topic+estim_BVdk">estim_BVdk</a> or <a href="#topic+estim_PS">estim_PS</a>, depending on the chosen argument 'est_method' (see above).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="#topic+orthobasis_test">orthobasis_test</a>, containing ten attributes: 1) the number of populations under study (2 in this case);
2) the sizes of samples; 3) the information about the known component distribution; 4) the reject decision of the test; 5) the
confidence level of the test, 6) the p-value of the test; 7) the value of the test statistic; 8) the variance of the test
statistic at each order in the polynomial orthobasis expansion; 9) the selected rank (order) for the test statistic;
10) a vector of estimates, related to the estimated mixing proportions in the two samples.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>References</h3>

<p>Milhaud X, Pommeret D, Salhi Y, Vandekerkhove P (2022).
&ldquo;Semiparametric two-sample admixture components comparison test: The symmetric case.&rdquo;
<em>Journal of Statistical Planning and Inference</em>, <b>216</b>, 135-150.
ISSN 0378-3758, <a href="https://doi.org/10.1016/j.jspi.2021.05.010">doi:10.1016/j.jspi.2021.05.010</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#### Under the null hypothesis H0.
mixt1 &lt;- twoComp_mixt(n = 300, weight = 0.77,
                      comp.dist = list("norm", "exp"),
                      comp.param = list(list("mean" = 1, "sd" = 1),
                                        list("rate" = 0.33)))
data1 &lt;- getmixtData(mixt1)
admixMod1 &lt;- admix_model(knownComp_dist = mixt1$comp.dist[[2]],
                        knownComp_param = mixt1$comp.param[[2]])
mixt2 &lt;- twoComp_mixt(n = 500, weight = 0.62,
                      comp.dist = list("norm", "norm"),
                      comp.param = list(list("mean" = 1, "sd" = 1),
                                        list("mean" = -2, "sd" = 0.5)))
data2 &lt;- getmixtData(mixt2)
admixMod2 &lt;- admix_model(knownComp_dist = mixt2$comp.dist[[2]],
                        knownComp_param = mixt2$comp.param[[2]])
## Test procedure:
orthobasis_test(samples = list(data1,data2), admixMod = list(admixMod1,admixMod2),
                conf_level = 0.95, est_method = 'BVdk', support = 'Real')


</code></pre>

<hr>
<h2 id='plot.decontaminated_density'>Plot method for class 'decontaminated_density'</h2><span id='topic+plot.decontaminated_density'></span>

<h3>Description</h3>

<p>Plot the decontaminated density of the unknown component from some admixture model, after inversion of the admixture
cumulative distribution functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'decontaminated_density'
plot(x, x_val, add_plot = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.decontaminated_density_+3A_x">x</code></td>
<td>
<p>An object of class 'decontaminated_density' (see ?decontaminated_density).</p>
</td></tr>
<tr><td><code id="plot.decontaminated_density_+3A_x_val">x_val</code></td>
<td>
<p>(numeric) A vector of points at which to evaluate the probability mass/density function.</p>
</td></tr>
<tr><td><code id="plot.decontaminated_density_+3A_add_plot">add_plot</code></td>
<td>
<p>(default to FALSE) A boolean specifying if one plots the decontaminated density over an existing plot. Used for visual
comparison purpose.</p>
</td></tr>
<tr><td><code id="plot.decontaminated_density_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to generic method 'plot', such as graphical parameters (see par).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The decontaminated density is obtained by inverting the admixture density, given by l = p*f + (1-p)*g, to isolate the
unknown component f after having estimated p and l.
</p>


<h3>Value</h3>

<p>The plot of the decontaminated density.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>####### Continuous support:
## Simulate mixture data:
mixt1 &lt;- twoComp_mixt(n = 400, weight = 0.4,
                      comp.dist = list("norm", "norm"),
                      comp.param = list(list("mean" = 3, "sd" = 0.5),
                                        list("mean" = 0, "sd" = 1)))
mixt2 &lt;- twoComp_mixt(n = 350, weight = 0.6,
                      comp.dist = list("norm", "norm"),
                      comp.param = list(list("mean" = 3, "sd" = 0.5),
                                        list("mean" = 5, "sd" = 2)))
data1 &lt;- getmixtData(mixt1)
data2 &lt;- getmixtData(mixt2)
## Define the admixture models:
admixMod1 &lt;- admix_model(knownComp_dist = mixt1$comp.dist[[2]],
                         knownComp_param = mixt1$comp.param[[2]])
admixMod2 &lt;- admix_model(knownComp_dist = mixt2$comp.dist[[2]],
                         knownComp_param = mixt2$comp.param[[2]])
## Estimation:
est &lt;- admix_estim(samples = list(data1,data2),
                   admixMod = list(admixMod1,admixMod2), est_method = 'PS')
prop &lt;- getmixingWeight(est)
## Determine the decontaminated version of the unknown density by inversion:
res1 &lt;- decontaminated_density(sample1 = data1, estim.p = prop[1],
                               admixMod = admixMod1)
res2 &lt;- decontaminated_density(sample1 = data2, estim.p = prop[2],
                               admixMod = admixMod2)
## Use appropriate sequence of x values:
plot(x = res1, x_val = seq(from = 0, to = 6, length.out = 100), add_plot = FALSE)
plot(x = res2, col = "red", x_val = seq(from = 0, to = 6, length.out = 100), add_plot = TRUE)

####### Countable discrete support:
mixt1 &lt;- twoComp_mixt(n = 4000, weight = 0.7,
                      comp.dist = list("pois", "pois"),
                      comp.param = list(list("lambda" = 3),
                                        list("lambda" = 2)))
mixt2 &lt;- twoComp_mixt(n = 3500, weight = 0.85,
                      comp.dist = list("pois", "pois"),
                      comp.param = list(list("lambda" = 3),
                                        list("lambda" = 4)))
data1 &lt;- getmixtData(mixt1)
data2 &lt;- getmixtData(mixt2)
## Define the admixture models:
admixMod1 &lt;- admix_model(knownComp_dist = mixt1$comp.dist[[2]],
                         knownComp_param = mixt1$comp.param[[2]])
admixMod2 &lt;- admix_model(knownComp_dist = mixt2$comp.dist[[2]],
                         knownComp_param = mixt2$comp.param[[2]])
## Estimation:
est &lt;- admix_estim(samples = list(data1,data2),
                   admixMod = list(admixMod1,admixMod2), est_method = "IBM")
prop &lt;- getmixingWeight(est)
## Determine the decontaminated version of the unknown density by inversion:
res1 &lt;- decontaminated_density(sample1 = data1, estim.p = prop[1],
                               admixMod = admixMod1)
res2 &lt;- decontaminated_density(sample1 = data2, estim.p = prop[2],
                               admixMod = admixMod2)
## Use appropriate sequence of x values:
plot(x = res1, x_val = seq(from = 0, to = 15, by = 1), add_plot = FALSE)
plot(x = res2, x_val = seq(from = 0, to = 15, by = 1), add_plot = TRUE, col = "red")

####### Finite discrete support:
mixt1 &lt;- twoComp_mixt(n = 4000, weight = 0.7,
                      comp.dist = list("multinom", "multinom"),
                      comp.param = list(list("size" = 1, "prob" = c(0.3,0.4,0.3)),
                                        list("size" = 1, "prob" = c(0.6,0.3,0.1))))
mixt2 &lt;- twoComp_mixt(n = 3500, weight = 0.85,
                      comp.dist = list("multinom", "multinom"),
                      comp.param = list(list("size" = 1, "prob" = c(0.3,0.4,0.3)),
                                        list("size" = 1, "prob" = c(0.2,0.6,0.2))))
data1 &lt;- getmixtData(mixt1)
data2 &lt;- getmixtData(mixt2)
## Define the admixture models:
admixMod1 &lt;- admix_model(knownComp_dist = mixt1$comp.dist[[2]],
                         knownComp_param = mixt1$comp.param[[2]])
admixMod2 &lt;- admix_model(knownComp_dist = mixt2$comp.dist[[2]],
                         knownComp_param = mixt2$comp.param[[2]])
## Estimation:
est &lt;- admix_estim(samples = list(data1,data2),
                   admixMod = list(admixMod1,admixMod2), est_method = "IBM")
prop &lt;- getmixingWeight(est)
## Determine the decontaminated version of the unknown density by inversion:
res1 &lt;- decontaminated_density(sample1 = data1, estim.p = prop[1],
                               admixMod = admixMod1)
res2 &lt;- decontaminated_density(sample1 = data2, estim.p = prop[2],
                               admixMod = admixMod2)
## Use appropriate sequence of x values:
plot(x = res1, x_val = seq(from=1, to=3, by=1), add_plot = FALSE)
plot(x = res2, x_val = seq(from=1, to=3, by=1), add_plot = TRUE, col = "red")

</code></pre>

<hr>
<h2 id='plot.twoComp_mixt'>Plots several mixture densities on the same graph</h2><span id='topic+plot.twoComp_mixt'></span>

<h3>Description</h3>

<p>Plots the empirical densities of the samples with optional arguments to improve the visualization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'twoComp_mixt'
plot(x, add.plot = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.twoComp_mixt_+3A_x">x</code></td>
<td>
<p>Object of class 'twoComp_mixt' from which the density will be plotted.</p>
</td></tr>
<tr><td><code id="plot.twoComp_mixt_+3A_add.plot">add.plot</code></td>
<td>
<p>(default to FALSE) Option to plot another mixture distribution on the same graph.</p>
</td></tr>
<tr><td><code id="plot.twoComp_mixt_+3A_...">...</code></td>
<td>
<p>further classical arguments and graphical parameters for methods plot and hist.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot with the densities of the samples provided as inputs.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>

<hr>
<h2 id='print.admix_cluster'>Print method for object of class 'admix_cluster'</h2><span id='topic+print.admix_cluster'></span>

<h3>Description</h3>

<p>Print the main results when clustering the unknown component distributions coming from various
admixture samples, i.e. the obtained clusters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'admix_cluster'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.admix_cluster_+3A_x">x</code></td>
<td>
<p>An object of class 'admix_cluster' (see ?admix_clustering).</p>
</td></tr>
<tr><td><code id="print.admix_cluster_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>

<hr>
<h2 id='print.admix_estim'>Print the estimated parameters from K admixture models</h2><span id='topic+print.admix_estim'></span>

<h3>Description</h3>

<p>Print the estimated parameters from K admixture models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'admix_estim'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.admix_estim_+3A_x">x</code></td>
<td>
<p>An object of class 'admix_estim' (see ?admix_estim).</p>
</td></tr>
<tr><td><code id="print.admix_estim_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>

<hr>
<h2 id='print.admix_model'>Print method for objects of class 'admix_model'</h2><span id='topic+print.admix_model'></span>

<h3>Description</h3>

<p>Print an object of class 'admix_mod'. An admixture model has probability density function (pdf) l_i such that:
l_i = p_i * f_i + (1-p_i) * g_i, with g_i the known component density.
The unknown quantities are therefore p_i and f_i.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'admix_model'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.admix_model_+3A_x">x</code></td>
<td>
<p>An object of class 'admix_model'.</p>
</td></tr>
<tr><td><code id="print.admix_model_+3A_...">...</code></td>
<td>
<p>A list of additional parameters belonging to the default method.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>

<hr>
<h2 id='print.admix_test'>Print method for objects 'admix_test'</h2><span id='topic+print.admix_test'></span>

<h3>Description</h3>

<p>Print method for objects 'admix_test'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'admix_test'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.admix_test_+3A_x">x</code></td>
<td>
<p>An object of class 'admix_test'.</p>
</td></tr>
<tr><td><code id="print.admix_test_+3A_...">...</code></td>
<td>
<p>A list of additional parameters belonging to the default method.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>

<hr>
<h2 id='print.decontaminated_density'>Print method for object of class 'decontaminated_density'</h2><span id='topic+print.decontaminated_density'></span>

<h3>Description</h3>

<p>Print some overview of the decontaminated density function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'decontaminated_density'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.decontaminated_density_+3A_x">x</code></td>
<td>
<p>An object of class 'decontaminated_density' (see ?decontaminated_density).</p>
</td></tr>
<tr><td><code id="print.decontaminated_density_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to generic method 'plot', such as graphical parameters (see par).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>More important information about the decontaminated density.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>

<hr>
<h2 id='print.estim_BVdk'>Print method for objects 'estim_BVdk'</h2><span id='topic+print.estim_BVdk'></span>

<h3>Description</h3>

<p>Print the results stored in an object of class 'estim_BVdk'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'estim_BVdk'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.estim_BVdk_+3A_x">x</code></td>
<td>
<p>An object of class 'estim_BVdk'.</p>
</td></tr>
<tr><td><code id="print.estim_BVdk_+3A_...">...</code></td>
<td>
<p>A list of additional parameters belonging to the default method.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>

<hr>
<h2 id='print.estim_IBM'>Print method for objects of class 'estim_IBM'</h2><span id='topic+print.estim_IBM'></span>

<h3>Description</h3>

<p>Print the results stored in an object of class 'estim_IBM'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'estim_IBM'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.estim_IBM_+3A_x">x</code></td>
<td>
<p>An object of class 'estim_IBM'.</p>
</td></tr>
<tr><td><code id="print.estim_IBM_+3A_...">...</code></td>
<td>
<p>A list of additional parameters belonging to the default method.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>

<hr>
<h2 id='print.estim_PS'>Print method for objects of class 'estim_PS'</h2><span id='topic+print.estim_PS'></span>

<h3>Description</h3>

<p>Print all the attributes of objects of class 'estim_PS'. Results of estimated quantities in an admixture
using Patra and Sen approach
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'estim_PS'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.estim_PS_+3A_x">x</code></td>
<td>
<p>An object of class 'estim_PS'.</p>
</td></tr>
<tr><td><code id="print.estim_PS_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>

<hr>
<h2 id='print.gaussianity_test'>Print method for objects 'gaussianity_test'</h2><span id='topic+print.gaussianity_test'></span>

<h3>Description</h3>

<p>Print method for objects 'gaussianity_test'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gaussianity_test'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.gaussianity_test_+3A_x">x</code></td>
<td>
<p>An object of class 'gaussianity_test'.</p>
</td></tr>
<tr><td><code id="print.gaussianity_test_+3A_...">...</code></td>
<td>
<p>A list of additional parameters belonging to the default method.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>

<hr>
<h2 id='print.IBM_test'>Print method for objects 'IBM_test'</h2><span id='topic+print.IBM_test'></span>

<h3>Description</h3>

<p>Print method for objects 'IBM_test'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'IBM_test'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.IBM_test_+3A_x">x</code></td>
<td>
<p>An object of class 'IBM_test'.</p>
</td></tr>
<tr><td><code id="print.IBM_test_+3A_...">...</code></td>
<td>
<p>A list of additional parameters belonging to the default method.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>

<hr>
<h2 id='print.orthobasis_test'>Print method for objects of class 'orthobasis_test'</h2><span id='topic+print.orthobasis_test'></span>

<h3>Description</h3>

<p>Print method for objects of class 'orthobasis_test'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'orthobasis_test'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.orthobasis_test_+3A_x">x</code></td>
<td>
<p>An object of class 'orthobasis_test'.</p>
</td></tr>
<tr><td><code id="print.orthobasis_test_+3A_...">...</code></td>
<td>
<p>A list of additional parameters belonging to the default method.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>

<hr>
<h2 id='print.twoComp_mixt'>Print method for objects 'twoComp_mixt'</h2><span id='topic+print.twoComp_mixt'></span>

<h3>Description</h3>

<p>Print an object of class 'twoComp_mixt'. A two-component mixture model has probability density function (pdf) l such that:
l = p * f + (1-p) * g,
where p is the mixing proportion, and f and g are the component distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'twoComp_mixt'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.twoComp_mixt_+3A_x">x</code></td>
<td>
<p>An object of class 'twoComp_mixt'.</p>
</td></tr>
<tr><td><code id="print.twoComp_mixt_+3A_...">...</code></td>
<td>
<p>A list of additional parameters belonging to the default method.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>

<hr>
<h2 id='stmf_small'>Short-term Mortality Fluctuations (STMF) data</h2><span id='topic+stmf_small'></span>

<h3>Description</h3>

<p>Restricted to 6 countries: Belgium, France, Italy, Netherlands, Spain, Germany. Weekly death counts provide the
most objective and comparable way of assessing the scale of short-term mortality elevations across countries and time.
Extraction date from the Human Mortality Database (HMD): 09/21/2020.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stmf_small
</code></pre>


<h3>Format</h3>

<p>A data frame with 88146 rows and 19 variables:
</p>

<dl>
<dt>CountryCode</dt><dd><p>Mortality database country code</p>
</dd>
<dt>Year</dt><dd><p>Year</p>
</dd>
<dt>Week</dt><dd><p>Week number</p>
</dd>
<dt>Sex</dt><dd><p>Gender ('m': male, 'f': female, 'b': both)</p>
</dd>
<dt>D0_14</dt><dd><p>Age range 0-14</p>
</dd>
<dt>D15_64</dt><dd><p>Age range 15-64</p>
</dd>
<dt>D65_74</dt><dd><p>Age range 65-74</p>
</dd>
<dt>D75_84</dt><dd><p>Age range 75-84</p>
</dd>
<dt>D85p</dt><dd><p>Age range 85-+</p>
</dd>
<dt>DTotal</dt><dd><p>Count of deaths for all ages combined</p>
</dd>
<dt>R0_14</dt><dd><p>Crude death rate for age range 0-14</p>
</dd>
<dt>R15_64</dt><dd><p>Crude death rate for age range 15-64</p>
</dd>
<dt>R65_74</dt><dd><p>Crude death rate for age range 65-74</p>
</dd>
<dt>R75_84</dt><dd><p>Crude death rate for age range 75-84</p>
</dd>
<dt>R85p</dt><dd><p>Crude death rate for age range 85-+</p>
</dd>
<dt>RTotal</dt><dd><p>Crude death rate for all ages combined</p>
</dd>
<dt>Split</dt><dd><p>Indicates if data were split from aggregated age groups (0 if the original data has necessary detailed age scale).
For example, if the original age scale was 0-4, 5-29, 30-65, 65+, then split will be equal to 1</p>
</dd>
<dt>SplitSex</dt><dd><p>Indicates if the original data are available by sex (0) or data are interpolated (1)</p>
</dd>
<dt>Forecast</dt><dd><p>Equals 1 for all years where forecasted population exposures were used to calculate weekly death rates</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.mortality.org">https://www.mortality.org</a>
</p>

<hr>
<h2 id='summary.admix_cluster'>Summary method for object of class 'admix_cluster'</h2><span id='topic+summary.admix_cluster'></span>

<h3>Description</h3>

<p>Summarizes the results obtained when clustering the unknown component distributions coming from various
admixture samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'admix_cluster'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.admix_cluster_+3A_object">object</code></td>
<td>
<p>An object of class 'admix_cluster' (see ?admix_clustering).</p>
</td></tr>
<tr><td><code id="summary.admix_cluster_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>

<hr>
<h2 id='summary.admix_estim'>Results of estimated parameters from K admixture models</h2><span id='topic+summary.admix_estim'></span>

<h3>Description</h3>

<p>Summarize the estimated weight(s) of the unknown component(s) in the admixture model(s) under study.
Recall that an admixture model follows the cumulative distribution function (CDF) L, where
L = p*F + (1-p)*G, with G a known CDF, and p and F unknown quantities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'admix_estim'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.admix_estim_+3A_object">object</code></td>
<td>
<p>An object of class 'admix_estim' (see ?admix_estim).</p>
</td></tr>
<tr><td><code id="summary.admix_estim_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>

<hr>
<h2 id='summary.admix_test'>Summary method for 'admix_test' objects</h2><span id='topic+summary.admix_test'></span>

<h3>Description</h3>

<p>Print the decision (as well as other useful information) of the statistical test with null hypothesis corresponding to
the equality of unknown component distributions in admixture models. More precisely, given two (or more) admixture models
with cumulative distribution functions (CDF) L1 and L2, where Li = pi*Fi + (1-pi)*Gi i=1,2 and Gi are the known CDFs, the
function performs the test: H0: F1 = F2 versus H1: F1 != F2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'admix_test'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.admix_test_+3A_object">object</code></td>
<td>
<p>An object of class 'admix_test' (see ?admix_test).</p>
</td></tr>
<tr><td><code id="summary.admix_test_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>

<hr>
<h2 id='summary.estim_BVdk'>Summary method for objects 'estim_BVdk'</h2><span id='topic+summary.estim_BVdk'></span>

<h3>Description</h3>

<p>Summarizes the results stored in an object of class 'estim_BVdk'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'estim_BVdk'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.estim_BVdk_+3A_object">object</code></td>
<td>
<p>An object of class 'estim_BVdk'.</p>
</td></tr>
<tr><td><code id="summary.estim_BVdk_+3A_...">...</code></td>
<td>
<p>A list of additional parameters belonging to the default method.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>

<hr>
<h2 id='summary.estim_IBM'>Summary method for objects 'estim_IBM'</h2><span id='topic+summary.estim_IBM'></span>

<h3>Description</h3>

<p>Summarizes the results stored in an object of class 'estim_IBM'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'estim_IBM'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.estim_IBM_+3A_object">object</code></td>
<td>
<p>An object of class 'estim_IBM'.</p>
</td></tr>
<tr><td><code id="summary.estim_IBM_+3A_...">...</code></td>
<td>
<p>A list of additional parameters belonging to the default method.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>

<hr>
<h2 id='summary.estim_PS'>Summary method for objects 'estim_PS'</h2><span id='topic+summary.estim_PS'></span>

<h3>Description</h3>

<p>Summarizes the results stored in an object of class 'estim_PS'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'estim_PS'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.estim_PS_+3A_object">object</code></td>
<td>
<p>An object of class 'estim_PS'.</p>
</td></tr>
<tr><td><code id="summary.estim_PS_+3A_...">...</code></td>
<td>
<p>A list of additional parameters belonging to the default method.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>

<hr>
<h2 id='summary.gaussianity_test'>Summary method for objects 'gaussianity_test'</h2><span id='topic+summary.gaussianity_test'></span>

<h3>Description</h3>

<p>Summary method for objects 'gaussianity_test'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'gaussianity_test'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.gaussianity_test_+3A_object">object</code></td>
<td>
<p>An object of class 'gaussianity_test'.</p>
</td></tr>
<tr><td><code id="summary.gaussianity_test_+3A_...">...</code></td>
<td>
<p>A list of additional parameters belonging to the default method.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>

<hr>
<h2 id='summary.IBM_test'>Summary method for objects 'IBM_test'</h2><span id='topic+summary.IBM_test'></span>

<h3>Description</h3>

<p>Summary method for objects 'IBM_test'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'IBM_test'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.IBM_test_+3A_object">object</code></td>
<td>
<p>An object of class 'IBM_test'.</p>
</td></tr>
<tr><td><code id="summary.IBM_test_+3A_...">...</code></td>
<td>
<p>A list of additional parameters belonging to the default method.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>

<hr>
<h2 id='summary.orthobasis_test'>Summary method for objects of class 'orthobasis_test'</h2><span id='topic+summary.orthobasis_test'></span>

<h3>Description</h3>

<p>Summary method for objects of class 'orthobasis_test'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'orthobasis_test'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.orthobasis_test_+3A_object">object</code></td>
<td>
<p>An object of class 'orthobasis_test'.</p>
</td></tr>
<tr><td><code id="summary.orthobasis_test_+3A_...">...</code></td>
<td>
<p>A list of additional parameters belonging to the default method.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>

<hr>
<h2 id='twoComp_mixt'>Simulation of a two-component mixture model</h2><span id='topic+twoComp_mixt'></span>

<h3>Description</h3>

<p>Simulate a two-component mixture model following the probability density function (pdf) l such that l = p*f + (1-p)*g,
with f and g the mixture component distributions, and p the mixing weight.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>twoComp_mixt(
  n = 1000,
  weight = 0.5,
  comp.dist = list("norm", "norm"),
  comp.param = list(list(mean = 0, sd = 1), list(mean = 2, sd = 1))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="twoComp_mixt_+3A_n">n</code></td>
<td>
<p>Number of observations to be simulated.</p>
</td></tr>
<tr><td><code id="twoComp_mixt_+3A_weight">weight</code></td>
<td>
<p>Weight of the first component distribution (distribution f) in the mixture.</p>
</td></tr>
<tr><td><code id="twoComp_mixt_+3A_comp.dist">comp.dist</code></td>
<td>
<p>A list of two elements corresponding to the component distributions (specified with R native names)
involved in the mixture model. These elements respectively refer to the two component distributions f and g.</p>
</td></tr>
<tr><td><code id="twoComp_mixt_+3A_comp.param">comp.param</code></td>
<td>
<p>A list of two elements corresponding to the parameters of the component distributions, each element being a list
itself. The names used in each list must correspond to the native R argument names for these distributions.
These elements respectively refer to the parameters of f and g distributions of the mixture model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <a href="#topic+twoComp_mixt">twoComp_mixt</a>, containing eight attributes: 1) the number of simulated observations, 2) the simulated mixture
data, 3) the support of the distributions, 4) the name of the component distributions, 5) the name of the parameters of the
component distributions and their values, 6) the mixing proportion, 7) the observations coming from the first component,
8) the observations coming from the second component.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Mixture of continuous random variables:
sim.X &lt;- twoComp_mixt(n = 2000, weight = 0.5,
                      comp.dist = list("norm", "norm"),
                      comp.param = list(list("mean"=3, "sd"=0.5),
                                        list("mean"=0, "sd"=1)))
sim.Y &lt;- twoComp_mixt(n = 1200, weight = 0.7,
                      comp.dist = list("norm", "exp"),
                      comp.param = list(list("mean"=-3, "sd"=0.5),
                                        list("rate"=1)))
print(sim.X)
plot(sim.X, xlim=c(-5,5), ylim=c(0,0.5))
plot(sim.Y, add.plot = TRUE, xlim=c(-5,5), ylim=c(0,0.5), col = "red")

## Mixture of discrete random variables:
sim.X &lt;- twoComp_mixt(n = 2000, weight = 0.5,
                      comp.dist = list("multinom", "multinom"),
                      comp.param = list(list("size"=1, "prob"=c(0.3,0.4,0.3)),
                                        list("size"=1, "prob"=c(0.1,0.2,0.7))))
print(sim.X)
plot(sim.X)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
