<!DOCTYPE html><html><head><title>Help for package admix</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {admix}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#admix-package'><p>admix: Package Admix for Admixture (aka Contamination) Models</p></a></li>
<li><a href='#admix_clustering'><p>Clustering of K populations following admixture models</p></a></li>
<li><a href='#admix_estim'><p>Estimate the unknown parameters of the admixture model(s) under study</p></a></li>
<li><a href='#admix_test'><p>Hypothesis test between unknown components of the admixture models under study</p></a></li>
<li><a href='#allGalaxies'><p>Four galaxies (Carina, Sextans, Sculptor, Fornax) measurements of heliocentric velocities from SIMBAD astronomical database</p></a></li>
<li><a href='#BVdk_contrast'><p>Contrast as defined in Bordes &amp; Vandekerkhove (2010)</p></a></li>
<li><a href='#BVdk_contrast_gradient'><p>Gradient of the contrast as defined in Bordes &amp; Vandekerkhove (2010)</p></a></li>
<li><a href='#BVdk_estimParam'><p>Estimation of the parameters in a two-component admixture model with symmetric unknown density</p></a></li>
<li><a href='#BVdk_ML_varCov_estimators'><p>Maximum Likelihood estimation of the variance of the unknown density variance estimator in an admixture model</p></a></li>
<li><a href='#BVdk_varCov_estimators'><p>Estimation of the variance of the estimators in admixture models with symmetric unknown density.</p></a></li>
<li><a href='#decontaminated_cdf'><p>Provide the decontaminated cumulative distribution function (CDF) of the unknown component in an admixture model</p></a></li>
<li><a href='#decontaminated_density'><p>Provide the decontaminated density of the unknown component in an admixture model.</p></a></li>
<li><a href='#detect_support_type'><p>Detect the support of the random variables under study</p></a></li>
<li><a href='#estimVarCov_empProcess'><p>Variance-covariance matrix of the empirical process in an admixture model</p></a></li>
<li><a href='#gaussianity_test'><p>One-sample gaussianity test in admixture models using Bordes and Vandekerkhove estimation method</p></a></li>
<li><a href='#IBM_2samples_test'><p>Equality test of unknown component distributions in two admixture models with IBM approach</p></a></li>
<li><a href='#IBM_empirical_contrast'><p>Empirical computation of the contrast in the Inversion - Best Matching (IBM) method</p></a></li>
<li><a href='#IBM_estimProp'><p>Estimate the weights related to the proportions of the unknown components of the two admixture models</p></a></li>
<li><a href='#IBM_estimVarCov_gaussVect'><p>Nonparametric estimation of the variance-covariance matrix of the gaussian vector in IBM approach</p></a></li>
<li><a href='#IBM_gap'><p>Difference between the unknown empirical cumulative distribution functions in two admixture models</p></a></li>
<li><a href='#IBM_greenLight_criterion'><p>Green-light criterion to decide whether to perform full equality test between unknown components between two admixture models</p></a></li>
<li><a href='#IBM_hessian_contrast'><p>Hessian matrix of the contrast function in the Inversion - Best Matching (IBM) method</p></a></li>
<li><a href='#IBM_k_samples_test'><p>Equality test of unknown component distributions in K admixture models, with IBM approach</p></a></li>
<li><a href='#IBM_tabul_stochasticInteg'><p>Distribution of the contrast in the Inversion - Best Matching (IBM) method</p></a></li>
<li><a href='#IBM_theoretical_contrast'><p>Theoretical contrast in the Inversion - Best Matching (IBM) method</p></a></li>
<li><a href='#IBM_theoretical_gap'><p>Difference between unknown cumulative distribution functions of admixture models at some given point</p></a></li>
<li><a href='#is_equal_knownComp'><p>Test for equality of the known components between two admixture models</p></a></li>
<li><a href='#kernel_cdf'><p>Kernel estimation</p></a></li>
<li><a href='#kernel_density'><p>Kernel estimation</p></a></li>
<li><a href='#knownComp_to_uniform'><p>Transforms the known component of the admixture distribution to a Uniform distribution</p></a></li>
<li><a href='#milkyWay'><p>Heliocentric velocity measured for the Milky Way (from Walker, M. G., M. Mateo, E. W. Olszewski, O. Y. Gnedin, X. Wang,</p>
B. Sen, and M. Woodroofe (2007). Velocity dispersion profiles of seven dwarf spheroidal galaxies. Astrophysical J. 667(1), L53â€“L56).</a></li>
<li><a href='#orthoBasis_coef'><p>Compute expansion coefficients in a given orthonormal polynomial basis.</p></a></li>
<li><a href='#orthoBasis_test_H0'><p>Equality test of unknown components between two admixture models using polynomial basis expansions</p></a></li>
<li><a href='#PatraSen_cv_mixmodel'><p>Cross-validation estimate (by Patra and Sen) of the unknown component weight as well as the unknown distribution in an admixture model</p></a></li>
<li><a href='#PatraSen_density_est'><p>Compute the estimate of the density of the unknown component in an admixture model</p></a></li>
<li><a href='#PatraSen_dist_calc'><p>Compute the distance to be minimized using Patra and Sen estimation technique in admixture models</p></a></li>
<li><a href='#PatraSen_est_mix_model'><p>Estimate by Patra and Sen the unknown component weight as well as the unknown distribution in admixture models</p></a></li>
<li><a href='#plot_mixt_density'><p>Plot the density of some given sample(s) with mixture distributions.</p></a></li>
<li><a href='#plot.decontaminated_density'><p>Plot the decontaminated density of the unknown component for an estimated admixture model</p></a></li>
<li><a href='#poly_orthonormal_basis'><p>Build an orthonormal basis to decompose some given probability density function</p></a></li>
<li><a href='#print.admix_cluster'><p>Results of the clustering algorithm performed over the K populations following admixture models.</p></a></li>
<li><a href='#print.admix_estim'><p>Print the results of estimated parameters from K admixture models</p></a></li>
<li><a href='#print.admix_test'><p>Print the results of statistical test for equality of unknown component distributions in admixture models</p></a></li>
<li><a href='#rsimmix'><p>Simulation of a two-component mixture model</p></a></li>
<li><a href='#rsimmix_mix'><p>Simulation of a two-component gaussian mixture with one component following a two-component gaussian mixture</p></a></li>
<li><a href='#sim_gaussianProcess'><p>Simulation of a Gaussian process</p></a></li>
<li><a href='#stmf_small'><p>Short-term Mortality Fluctuations (STMF) data series, restricted to 6 countries (Belgium, France, Italy, Netherlands, Spain, Germany).</p></a></li>
<li><a href='#two_samples_test'><p>Two-samples hypothesis test on the unknown component in admixture models</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Package Admix for Admixture (aka Contamination) Models</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1-2</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-07-11</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements techniques to estimate the unknown quantities related 
    to two-component admixture models, where the two components can belong to any
    distribution (note that in the case of multinomial mixtures, the two components
    must belong to the same family). Estimation methods depend on the assumptions 
    made on the unknown component density (see Bordes and Vandekerkhove (2010) &lt;<a href="https://doi.org/10.3103%2FS1066530710010023">doi:10.3103/S1066530710010023</a>&gt;; 
    Patra and Sen (2016) &lt;<a href="https://doi.org/10.1111%2Frssb.12148">doi:10.1111/rssb.12148</a>&gt;); Milhaud, Pommeret, Salhi and Vandekerkhove 
    (2022) &lt;<a href="https://doi.org/10.1016%2Fj.jspi.2021.05.010">doi:10.1016/j.jspi.2021.05.010</a>&gt;). In practice, one can estimate both the 
    mixture weight and the unknown component density in a wide variety of frameworks.
    On top of that, hypothesis tests can be performed in one and two-sample contexts 
    to test the unknown component density (see Milhaud, Pommeret, Salhi, Vandekerkhove (2023)).
    Finally, clustering of unknown mixture components is also feasible in a K-samples setting.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/XavierMilhaud/admix">https://github.com/XavierMilhaud/admix</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/XavierMilhaud/admix/issues">https://github.com/XavierMilhaud/admix/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>base, cubature, fdrtool, graphics, Iso, MASS, methods,
orthopolynom, pracma, Rcpp, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>rmutil, doParallel, foreach, evd, logitnorm, flexsurv, plyr,
reshape2, gridExtra, lattice, testthat (&ge; 3.0.0), knitr,
rmarkdown, markdown, spelling</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-11 12:53:51 UTC; XM</td>
</tr>
<tr>
<td>Author:</td>
<td>Xavier Milhaud [aut, cre],
  Pierre Vandekerkhove [ctb],
  Denys Pommeret [ctb],
  Yahia Salhi [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Xavier Milhaud &lt;xavier.milhaud.research@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-07-12 22:50:15 UTC</td>
</tr>
</table>
<hr>
<h2 id='admix-package'>admix: Package Admix for Admixture (aka Contamination) Models</h2><span id='topic+admix'></span><span id='topic+admix-package'></span>

<h3>Description</h3>

<p>Implements techniques to estimate the unknown quantities related to two-component admixture models, where the two components can belong to any distribution (note that in the case of multinomial mixtures, the two components must belong to the same family). Estimation methods depend on the assumptions made on the unknown component density (see Bordes and Vandekerkhove (2010) <a href="https://doi.org/10.3103/S1066530710010023">doi:10.3103/S1066530710010023</a>; Patra and Sen (2016) <a href="https://doi.org/10.1111/rssb.12148">doi:10.1111/rssb.12148</a>); Milhaud, Pommeret, Salhi and Vandekerkhove (2022) <a href="https://doi.org/10.1016/j.jspi.2021.05.010">doi:10.1016/j.jspi.2021.05.010</a>). In practice, one can estimate both the mixture weight and the unknown component density in a wide variety of frameworks. On top of that, hypothesis tests can be performed in one and two-sample contexts to test the unknown component density (see Milhaud, Pommeret, Salhi, Vandekerkhove (2023)). Finally, clustering of unknown mixture components is also feasible in a K-samples setting.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Pierre Vandekerkhove [contributor]
</p>
</li>
<li><p> Denys Pommeret [contributor]
</p>
</li>
<li><p> Yahia Salhi [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/XavierMilhaud/admix">https://github.com/XavierMilhaud/admix</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/XavierMilhaud/admix/issues">https://github.com/XavierMilhaud/admix/issues</a>
</p>
</li></ul>


<hr>
<h2 id='admix_clustering'>Clustering of K populations following admixture models</h2><span id='topic+admix_clustering'></span>

<h3>Description</h3>

<p>Create clusters on the unknown components related to the K populations following admixture models. Based on the K-sample test
using Inversion - Best Matching (IBM) approach, see 'Details' below for further information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>admix_clustering(
  samples = NULL,
  n_sim_tab = 100,
  comp.dist = NULL,
  comp.param = NULL,
  tabul.dist = NULL,
  conf.level = 0.95,
  parallel = FALSE,
  n_cpu = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="admix_clustering_+3A_samples">samples</code></td>
<td>
<p>A list of the K observed samples to be clustered, all following admixture distributions.</p>
</td></tr>
<tr><td><code id="admix_clustering_+3A_n_sim_tab">n_sim_tab</code></td>
<td>
<p>Number of simulated gaussian processes used in the tabulation of the inner convergence distribution in the IBM approach.</p>
</td></tr>
<tr><td><code id="admix_clustering_+3A_comp.dist">comp.dist</code></td>
<td>
<p>A list with 2*K elements corresponding to the component distributions (specified with R native names for these distributions)
involved in the K admixture models. Elements, grouped by 2, refer to the unknown and known components of each admixture model,
If there are unknown elements, they must be specified as 'NULL' objects. For instance, 'comp.dist' could be specified
as follows with K = 3: list(f1 = NULL, g1 = 'norm', f2 = NULL, g2 = 'norm', f3 = NULL, g3 = 'rnorm').</p>
</td></tr>
<tr><td><code id="admix_clustering_+3A_comp.param">comp.param</code></td>
<td>
<p>A list with 2*K elements corresponding to the parameters of the component distributions, each element being a list
itself. The names used in this list must correspond to the native R argument names for these distributions.
Elements, grouped by 2, refer to the parameters of unknown and known components of each admixture model.
If there are unknown elements, they must be specified as 'NULL' objects. For instance, 'comp.param' could
be specified as follows (with K = 3):
list(f1 = NULL, g1 = list(mean=0,sd=1), f2 = NULL, g2 = list(mean=3,sd=1.1), f3 = NULL, g3 = list(mean=-2,sd=0.6)).</p>
</td></tr>
<tr><td><code id="admix_clustering_+3A_tabul.dist">tabul.dist</code></td>
<td>
<p>Only useful for comparisons of detected clusters at different confidence levels. Is a list of the tabulated distributions
of the stochastic integral for each cluster previously detected.</p>
</td></tr>
<tr><td><code id="admix_clustering_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level of the K-sample test used in the clustering procedure.</p>
</td></tr>
<tr><td><code id="admix_clustering_+3A_parallel">parallel</code></td>
<td>
<p>(default to FALSE) Boolean to indicate whether parallel computations are performed (speed-up the tabulation).</p>
</td></tr>
<tr><td><code id="admix_clustering_+3A_n_cpu">n_cpu</code></td>
<td>
<p>(default to 2) Number of cores used when parallelizing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the paper at the following HAL weblink: https://hal.science/hal-04129130
</p>


<h3>Value</h3>

<p>A list with eight elements: 1) the number of populations under consideration; 2) the number of detected clusters;
3) the list of p-values for each test performed; 4) the cluster affiliation for each population; 5) the chosen confidence
level of statistical tests; 6) the cluster components; 7) the estimated weights of the unknown component distributions inside
each cluster (remind that estimated weights are consistent only under the null); 8) the matrix of pairwise discrepancies
among all populations.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Simulate data (chosen parameters indicate 2 clusters (populations (1,3), and (2,4)):
list.comp &lt;- list(f1 = "gamma", g1 = "exp",
                  f2 = "gamma", g2 = "exp",
                  f3 = "gamma", g3 = "gamma",
                  f4 = "gamma", g4 = "exp")
list.param &lt;- list(f1 = list(shape = 16, rate = 4), g1 = list(rate = 1/3.5),
                   f2 = list(shape = 14, rate = 2), g2 = list(rate = 1/5),
                   f3 = list(shape = 16, rate = 4), g3 = list(shape = 12, rate = 2),
                   f4 = list(shape = 14, rate = 2), g4 = list(rate = 1/7))
A.sim &lt;- rsimmix(n=2600, unknownComp_weight=0.8, comp.dist = list(list.comp$f1,list.comp$g1),
                 comp.param = list(list.param$f1, list.param$g1))$mixt.data
B.sim &lt;- rsimmix(n=3000, unknownComp_weight=0.7, comp.dist = list(list.comp$f2,list.comp$g2),
                 comp.param = list(list.param$f2, list.param$g2))$mixt.data
C.sim &lt;- rsimmix(n=3500, unknownComp_weight=0.6, comp.dist = list(list.comp$f3,list.comp$g3),
                 comp.param = list(list.param$f3, list.param$g3))$mixt.data
D.sim &lt;- rsimmix(n=4800, unknownComp_weight=0.5, comp.dist = list(list.comp$f4,list.comp$g4),
                 comp.param = list(list.param$f4, list.param$g4))$mixt.data
## Look for the clusters:
list.comp &lt;- list(f1 = NULL, g1 = "exp",
                  f2 = NULL, g2 = "exp",
                  f3 = NULL, g3 = "gamma",
                  f4 = NULL, g4 = "exp")
list.param &lt;- list(f1 = NULL, g1 = list(rate = 1/3.5),
                   f2 = NULL, g2 = list(rate = 1/5),
                   f3 = NULL, g3 = list(shape = 12, rate = 2),
                   f4 = NULL, g4 = list(rate = 1/7))
clusters &lt;- admix_clustering(samples = list(A.sim,B.sim,C.sim,D.sim), n_sim_tab = 8,
                             comp.dist=list.comp, comp.param=list.param, conf.level = 0.95,
                             parallel = FALSE, n_cpu = 2)
clusters


</code></pre>

<hr>
<h2 id='admix_estim'>Estimate the unknown parameters of the admixture model(s) under study</h2><span id='topic+admix_estim'></span>

<h3>Description</h3>

<p>Estimate the component weights, the location shift parameter (in case of a symmetric unknown component density),
and the unknown component distribution using different estimation techniques. We remind that the i-th admixture
model has probability density function (pdf) l_i such that:
l_i = p_i * f_i + (1-p_i) * g_i, where g_i is the known component density.
The unknown quantities p_i and f_i then have to be estimated.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>admix_estim(
  samples = NULL,
  sym.f = FALSE,
  est.method = c("PS", "BVdk", "IBM"),
  comp.dist = NULL,
  comp.param = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="admix_estim_+3A_samples">samples</code></td>
<td>
<p>A list of the K samples to be studied, all following admixture distributions.</p>
</td></tr>
<tr><td><code id="admix_estim_+3A_sym.f">sym.f</code></td>
<td>
<p>A boolean indicating whether the unknown component densities are assumed to be symmetric or not.</p>
</td></tr>
<tr><td><code id="admix_estim_+3A_est.method">est.method</code></td>
<td>
<p>The estimation method to be applied. Can be one of 'BVdk' (Bordes and Vandekerkhove estimator), 'PS' (Patra and Sen
estimator), or 'IBM' (Inversion Best-Matching approach). The same estimation method is performed on each sample.
Important note: estimation by 'IBM' is unbiased only under H0, meaning that choosing this method requires to perform
previously the test hypothesis between the pairs of samples. For further details, see section 'Details' below.</p>
</td></tr>
<tr><td><code id="admix_estim_+3A_comp.dist">comp.dist</code></td>
<td>
<p>A list with 2*K elements corresponding to the component distributions (specified with R native names for these distributions)
involved in the K admixture models. Elements, grouped by 2, refer to the unknown and known components of each admixture model,
If there are unknown elements, they must be specified as 'NULL' objects. For instance, 'comp.dist' could be specified
as follows with K = 3: list(f1 = NULL, g1 = 'norm', f2 = NULL, g2 = 'norm', f3 = NULL, g3 = 'norm').</p>
</td></tr>
<tr><td><code id="admix_estim_+3A_comp.param">comp.param</code></td>
<td>
<p>A list with 2*K elements corresponding to the parameters of the component distributions, each element being a list
itself. The names used in this list must correspond to the native R argument names for these distributions.
Elements, grouped by 2, refer to the parameters of unknown and known components of each admixture model.
If there are unknown elements, they must be specified as 'NULL' objects. For instance, 'comp.param' could
be specified as follows (with K = 3):
list(f1 = NULL, g1 = list(mean=0,sd=1), f2 = NULL, g2 = list(mean=3,sd=1.1), f3 = NULL, g3 = list(mean=-2,sd=0.6)).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For further details on the different estimation techniques, see i) IBM approach at https://hal.science/hal-03201760 ;
ii) Patra and Sen estimator: Patra, R.K. and Sen, B. (2016); Estimation of a Two-component Mixture Model with Applications to
Multiple Testing; JRSS Series B, 78, pp. 869&ndash;893. ; iii) BVdk estimator: Bordes, L. and Vandekerkhove, P. (2010);
Semiparametric two-component mixture model when a component is known: an asymptotically normal estimator; Math. Meth. Stat.; 19, pp. 22&ndash;41.
</p>


<h3>Value</h3>

<p>A list containing the estimated weight of every unknown component distribution among admixture samples.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##### On a simulated example to see whether the true parameters are well estimated.
list.comp &lt;- list(f1 = "norm", g1 = "norm",
                  f2 = "norm", g2 = "norm")
list.param &lt;- list(f1 = list(mean = 0, sd = 1), g1 = list(mean = 2, sd = 0.7),
                   f2 = list(mean = 0, sd = 1), g2 = list(mean = -3, sd = 1.1))
## Simulate data:
sim1 &lt;- rsimmix(n = 2100, unknownComp_weight = 0.8, comp.dist = list(list.comp$f1,list.comp$g1),
                comp.param = list(list.param$f1, list.param$g1))$mixt.data
sim2 &lt;- rsimmix(n= 2000, unknownComp_weight = 0.85, comp.dist = list(list.comp$f2,list.comp$g2),
                comp.param = list(list.param$f2, list.param$g2))$mixt.data
## Estimate the mixture weights of the admixture models:
list.comp &lt;- list(f1 = NULL, g1 = "norm",
                  f2 = NULL, g2 = "norm")
list.param &lt;- list(f1 = NULL, g1 = list(mean = 2, sd = 0.7),
                   f2 = NULL, g2 = list(mean = -3, sd = 1.1))
estim &lt;- admix_estim(samples = list(sim1,sim2), sym.f = TRUE, est.method = 'IBM',
                     comp.dist = list.comp, comp.param = list.param)

</code></pre>

<hr>
<h2 id='admix_test'>Hypothesis test between unknown components of the admixture models under study</h2><span id='topic+admix_test'></span>

<h3>Description</h3>

<p>Perform hypothesis test between unknown components of a list of admixture models, where we remind that the i-th admixture
model has probability density function (pdf) l_i such that:
l_i = p_i * f_i + (1-p_i) * g_i, with g_i the known component density.
The unknown quantities p_i and f_i are thus estimated, leading to the test given by the following null and alternative hypothesis:
H0: f_i = f_j for all i != j   against H1 : there exists at least i != j such that f_i differs from f_j.
The test can be performed using two methods, either the comparison of coefficients obtained through polynomial basis expansions
of the component densities, or by the inner-convergence property obtained using the IBM approach. See 'Details' below for further information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>admix_test(
  samples = NULL,
  sym.f = FALSE,
  test.method = c("Poly", "ICV"),
  sim_U = NULL,
  n_sim_tab = 50,
  comp.dist = NULL,
  comp.param = NULL,
  support = c("Real", "Integer", "Positive", "Bounded.continuous"),
  conf.level = 0.95,
  parallel = FALSE,
  n_cpu = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="admix_test_+3A_samples">samples</code></td>
<td>
<p>A list of the K samples to be studied, all following admixture distributions.</p>
</td></tr>
<tr><td><code id="admix_test_+3A_sym.f">sym.f</code></td>
<td>
<p>A boolean indicating whether the unknown component densities are assumed to be symmetric or not.</p>
</td></tr>
<tr><td><code id="admix_test_+3A_test.method">test.method</code></td>
<td>
<p>The testing method to be applied. Can be either 'Poly' (polynomial basis expansion) or 'ICV' (inner
convergence from IBM). The same testing method is performed between all samples. In the one-sample case,
only 'Poly' is available and the test is a gaussianity test. For further details, see section 'Details' below.</p>
</td></tr>
<tr><td><code id="admix_test_+3A_sim_u">sim_U</code></td>
<td>
<p>(Used only with 'ICV' testing method, otherwise useless) Random draws of the inner convergence part of the contrast
as defined in the IBM approach (see 'Details' below).</p>
</td></tr>
<tr><td><code id="admix_test_+3A_n_sim_tab">n_sim_tab</code></td>
<td>
<p>(Used only with 'ICV' testing method, otherwise useless) Number of simulated gaussian processes used in the
tabulation of the inner convergence distribution in the IBM approach.</p>
</td></tr>
<tr><td><code id="admix_test_+3A_comp.dist">comp.dist</code></td>
<td>
<p>A list with 2*K elements corresponding to the component distributions (specified with R native names for these distributions)
involved in the K admixture models. Elements, grouped by 2, refer to the unknown and known components of each admixture model,
If there are unknown elements, they must be specified as 'NULL' objects. For instance, 'comp.dist' could be specified
as follows with K = 3: list(f1 = NULL, g1 = 'norm', f2 = NULL, g2 = 'norm', f3 = NULL, g3 = 'rnorm').</p>
</td></tr>
<tr><td><code id="admix_test_+3A_comp.param">comp.param</code></td>
<td>
<p>A list with 2*K elements corresponding to the parameters of the component distributions, each element being a list
itself. The names used in this list must correspond to the native R argument names for these distributions.
Elements, grouped by 2, refer to the parameters of unknown and known components of each admixture model.
If there are unknown elements, they must be specified as 'NULL' objects. For instance, 'comp.param' could
be specified as follows (with K = 3):
list(f1 = NULL, g1 = list(mean=0,sd=1), f2 = NULL, g2 = list(mean=3,sd=1.1), f3 = NULL, g3 = list(mean=-2,sd=0.6)).</p>
</td></tr>
<tr><td><code id="admix_test_+3A_support">support</code></td>
<td>
<p>(Potentially used with 'Poly' testing method, otherwise useless) The support of the observations; one of &quot;Real&quot;,
&quot;Integer&quot;, &quot;Positive&quot;, or &quot;Bounded.continuous&quot;.</p>
</td></tr>
<tr><td><code id="admix_test_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level of the K-sample test.</p>
</td></tr>
<tr><td><code id="admix_test_+3A_parallel">parallel</code></td>
<td>
<p>(default to FALSE) Boolean indicating whether parallel computations are performed (speed-up the tabulation).</p>
</td></tr>
<tr><td><code id="admix_test_+3A_n_cpu">n_cpu</code></td>
<td>
<p>(default to 2) Number of cores used when parallelizing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For further details on hypothesis techniques, see i) Inner convergence through IBM approach at
https://hal.science/hal-03201760 ; ii) Polynomial expansions at 'False Discovery Rate model
Gaussianity test' (EJS, Pommeret &amp; Vanderkerkhove, 2017), or 'Semiparametric two-sample admixture components comparison test:
the symmetric case' (JSPI, Milhaud &amp; al., 2021).
</p>


<h3>Value</h3>

<p>A list containing the decision of the test (reject or not), the confidence level at which the test is performed,
the p-value of the test, and the value of the test statistic (following a chi2 distribution with one degree of freedom
under the null).
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##### On a simulated example, with 1 sample (gaussianity test):
list.comp &lt;- list(f1 = "norm", g1 = "norm")
list.param &lt;- list(f1 = list(mean = 0, sd = 1), g1 = list(mean = 2, sd = 0.7))
## Simulate data:
sim1 &lt;- rsimmix(n = 300, unknownComp_weight = 0.85, comp.dist = list(list.comp$f1,list.comp$g1),
                comp.param = list(list.param$f1, list.param$g1))$mixt.data
## Perform the test hypothesis:
list.comp &lt;- list(f1 = NULL, g1 = "norm")
list.param &lt;- list(f1 = NULL, g1 = list(mean = 2, sd = 0.7))
gaussTest &lt;- admix_test(samples = list(sim1), sym.f = TRUE, test.method = 'Poly', sim_U = NULL,
                        n_sim_tab = 50, comp.dist = list.comp, comp.param = list.param,
                        support = "Real", conf.level = 0.95, parallel = FALSE, n_cpu = 2)

</code></pre>

<hr>
<h2 id='allGalaxies'>Four galaxies (Carina, Sextans, Sculptor, Fornax) measurements of heliocentric velocities from SIMBAD astronomical database</h2><span id='topic+allGalaxies'></span>

<h3>Description</h3>

<p>Four galaxies (Carina, Sextans, Sculptor, Fornax) measurements of heliocentric velocities from SIMBAD astronomical database
</p>


<h3>Usage</h3>

<pre><code class='language-R'>allGalaxies
</code></pre>


<h3>Format</h3>

<p>An evolving data frame of velocities for 4 dSph galaxies; namely Carina, Sextans, Sculptor and Fornax.
Currently contains 8,862 rows and 3 columns, with information on:
</p>

<dl>
<dt>Target</dt><dd><p>Target identification; Galaxy-ID number</p>
</dd>
<dt>HV</dt><dd><p>Weighted mean Heliocentric rest frame velocity</p>
</dd>
<dt>Name</dt><dd><p>The name of the galaxy</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://vizier.u-strasbg.fr/viz-bin/VizieR-3?-source=J/AJ/137/3100/stars&amp;-out.max=50&amp;-out.form=HTML%20Table&amp;-out.add=_r&amp;-out.add=_RAJ,_DEJ&amp;-out.add=_RA%2a-c.eq,_DE%2a-c.eq&amp;-sort=_r&amp;-oc.form=sexa">https://vizier.u-strasbg.fr/viz-bin/VizieR-3?-source=J/AJ/137/3100/stars&amp;-out.max=50&amp;-out.form=HTML%20Table&amp;-out.add=_r&amp;-out.add=_RAJ,_DEJ&amp;-out.add=_RA%2a-c.eq,_DE%2a-c.eq&amp;-sort=_r&amp;-oc.form=sexa</a>
</p>

<hr>
<h2 id='BVdk_contrast'>Contrast as defined in Bordes &amp; Vandekerkhove (2010)</h2><span id='topic+BVdk_contrast'></span>

<h3>Description</h3>

<p>Compute the contrast as defined in Bordes &amp; Vandekerkhove (2010) (see below in section 'Details'), needed for
optimization purpose. Remind that one considers an admixture model with symmetric unknown density, i.e.
l(x) = p*f(x-mu) + (1-p)*g(x),
where l denotes the probability density function (pdf) of the mixture with known component pdf g, p is the unknown mixture
weight, f relates to the unknown symmetric component pdf f, and mu is the location shift parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BVdk_contrast(param, data, h, comp.dist, comp.param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BVdk_contrast_+3A_param">param</code></td>
<td>
<p>Numeric vector of two elements, corresponding to the two parameters (first the unknown component weight, and
then the location shift parameter of the symmetric unknown component distribution).</p>
</td></tr>
<tr><td><code id="BVdk_contrast_+3A_data">data</code></td>
<td>
<p>Numeric vector of observations following the admixture model given by the pdf l.</p>
</td></tr>
<tr><td><code id="BVdk_contrast_+3A_h">h</code></td>
<td>
<p>Width of the window used in the kernel estimations.</p>
</td></tr>
<tr><td><code id="BVdk_contrast_+3A_comp.dist">comp.dist</code></td>
<td>
<p>A list with two elements corresponding to component distributions (specified with R native names for these distributions) involved
in the admixture model. Unknown elements must be specified as 'NULL' objects, e.g. when 'f' is unknown: list(f=NULL, g='norm').</p>
</td></tr>
<tr><td><code id="BVdk_contrast_+3A_comp.param">comp.param</code></td>
<td>
<p>A list with two elements corresponding to the parameters of the component distributions, each element being a list
itself. The names used in this list must correspond to the native R argument names for these distributions.
Unknown elements must be specified as 'NULL' objects, e.g. if 'f' is unknown: list(f=NULL, g=list(mean=0,sd=1)).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The contrast is defined in Bordes, L. and Vandekerkhove, P. (2010); Semiparametric two-component mixture model
when a component is known: an asymptotically normal estimator; Math. Meth. Stat.; 19, pp. 22&ndash;41.
</p>


<h3>Value</h3>

<p>The value of the contrast.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate data:
comp.dist &lt;- list(f = 'norm', g = 'norm')
comp.param &lt;- list(f = list(mean = 3, sd = 0.5), g = list(mean = 0, sd = 1))
data1 &lt;- rsimmix(n = 1000, unknownComp_weight = 0.6, comp.dist, comp.param)[['mixt.data']]
## Compute the contrast value for some given parameter vector in real-life framework:
comp.dist &lt;- list(f = NULL, g = 'norm')
comp.param &lt;- list(f = NULL, g = list(mean = 0, sd = 1))
BVdk_contrast(c(0.3,2), data1, density(data1)$bw, comp.dist, comp.param)

</code></pre>

<hr>
<h2 id='BVdk_contrast_gradient'>Gradient of the contrast as defined in Bordes &amp; Vandekerkhove (2010)</h2><span id='topic+BVdk_contrast_gradient'></span>

<h3>Description</h3>

<p>Compute the gradient of the contrast as defined in Bordes &amp; Vandekerkhove (2010) (see below in section 'Details'), needed for optimization purpose. Remind
that one considers an admixture model, i.e. l = p*f + (1-p)*g ; where l denotes the probability density function (pdf) of
the mixture with known component pdf g, p is the unknown mixture weight, and f relates to the  unknown symmetric
component pdf f.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BVdk_contrast_gradient(param, data, h, comp.dist, comp.param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BVdk_contrast_gradient_+3A_param">param</code></td>
<td>
<p>A numeric vector with two elements corresponding to the parameters to be estimated. First the unknown component
weight, and second the location shift parameter of the symmetric unknown component distribution.</p>
</td></tr>
<tr><td><code id="BVdk_contrast_gradient_+3A_data">data</code></td>
<td>
<p>A vector of observations following the admixture model given by the pdf l.</p>
</td></tr>
<tr><td><code id="BVdk_contrast_gradient_+3A_h">h</code></td>
<td>
<p>The window width used in the kernel estimations.</p>
</td></tr>
<tr><td><code id="BVdk_contrast_gradient_+3A_comp.dist">comp.dist</code></td>
<td>
<p>A list with two elements corresponding to component distributions (specified with R native names for these distributions) involved
in the admixture model. Unknown elements must be specified as 'NULL' objects, e.g. when 'f' is unknown: list(f=NULL, g='norm').</p>
</td></tr>
<tr><td><code id="BVdk_contrast_gradient_+3A_comp.param">comp.param</code></td>
<td>
<p>A list with two elements corresponding to the parameters of the component distributions, each element being a list
itself. The names used in this list must correspond to the native R argument names for these distributions.
Unknown elements must be specified as 'NULL' objects, e.g. if 'f' is unknown: list(f=NULL, g=list(mean=0,sd=1)).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The contrast is defined in Bordes, L. and Vandekerkhove, P. (2010); Semiparametric two-component mixture model
when a component is known: an asymptotically normal estimator; Math. Meth. Stat.; 19, pp. 22&ndash;41.
</p>


<h3>Value</h3>

<p>A numeric vector composed of the two partial derivatives w.r.t. the two parameters on which to optimize the contrast.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate data:
comp.dist &lt;- list(f = 'norm', g = 'norm')
comp.param &lt;- list(f = list(mean = 3, sd = 0.5), g = list(mean = 0, sd = 1))
data1 &lt;- rsimmix(n = 1000, unknownComp_weight = 0.6, comp.dist, comp.param)[['mixt.data']]
## Compute the contrast gradient for some given parameter vector in real-life framework:
comp.dist &lt;- list(f = NULL, g = 'norm')
comp.param &lt;- list(f = NULL, g = list(mean = 0, sd = 1))
BVdk_contrast_gradient(c(0.3,2), data1, density(data1)$bw, comp.dist, comp.param)

</code></pre>

<hr>
<h2 id='BVdk_estimParam'>Estimation of the parameters in a two-component admixture model with symmetric unknown density</h2><span id='topic+BVdk_estimParam'></span>

<h3>Description</h3>

<p>Estimation of the two parameters (mixture weight as well as location shift) in the admixture model with pdf:
l(x) = p*f(x-mu) + (1-p)*g(x), x in R,
where g is the known component, p is the proportion and f is the unknown component with symmetric density.
The localization shift parameter is thus denoted mu, and the component weight p.
See 'Details' below for further information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BVdk_estimParam(
  data,
  method = c("L-BFGS-B", "Nelder-Mead"),
  comp.dist,
  comp.param
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BVdk_estimParam_+3A_data">data</code></td>
<td>
<p>The observed sample under study.</p>
</td></tr>
<tr><td><code id="BVdk_estimParam_+3A_method">method</code></td>
<td>
<p>The method used throughout the optimization process, either 'L-BFGS-B' or 'Nelder-Mead' (see ?optim).</p>
</td></tr>
<tr><td><code id="BVdk_estimParam_+3A_comp.dist">comp.dist</code></td>
<td>
<p>A list with two elements corresponding to component distributions (specified with R native names for these distributions) involved
in the admixture model. Unknown elements must be specified as 'NULL' objects, e.g. when 'f' is unknown: list(f=NULL, g='norm').</p>
</td></tr>
<tr><td><code id="BVdk_estimParam_+3A_comp.param">comp.param</code></td>
<td>
<p>A list with two elements corresponding to the parameters of the component distributions, each element being a list
itself. The names used in this list must correspond to the native R argument names for these distributions.
Unknown elements must be specified as 'NULL' objects, e.g. if 'f' is unknown: list(f=NULL, g=list(mean=0,sd=1)).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parameters are estimated by minimization of the contrast function, where the contrast is defined in
Bordes, L. and Vandekerkhove, P. (2010); Semiparametric two-component mixture model when a component is known:
an asymptotically normal estimator; Math. Meth. Stat.; 19, pp. 22&ndash;41.
</p>


<h3>Value</h3>

<p>A numeric vector with the two estimated parameters (proportion first, and then location shift).
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate data:
list.comp &lt;- list(f = 'norm', g = 'norm')
list.param &lt;- list(f = list(mean = -2, sd = 0.5),
                   g = list(mean = 0, sd = 1))
data1 &lt;- rsimmix(n = 200, unknownComp_weight = 0.4, list.comp, list.param)[['mixt.data']]
## Perform the estimation of parameters in real-life:
list.comp &lt;- list(f = NULL, g = 'norm')
list.param &lt;- list(f = NULL, g = list(mean = 0, sd = 1))
BVdk_estimParam(data1, method = 'L-BFGS-B', list.comp, list.param)

</code></pre>

<hr>
<h2 id='BVdk_ML_varCov_estimators'>Maximum Likelihood estimation of the variance of the unknown density variance estimator in an admixture model</h2><span id='topic+BVdk_ML_varCov_estimators'></span>

<h3>Description</h3>

<p>Parametric estimation of the variance of the variance parameter in Bordes &amp; Vandekerkhove (2010) setting, i.e. considering the
admixture model with probability density function (pdf) l:
l(x) = p*f(x-mu) + (1-p)*g,
where g is the known component of the two-component mixture, p is the mixture proportion, f is the unknown component with
symmetric density, and mu is the location shift parameter. The estimation of the variance of the variance related to the density
f is made by maximum likelihood optimization through the information matrix, with the assumption that the unknown f is gaussian.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BVdk_ML_varCov_estimators(data, hat_w, hat_loc, hat_var, comp.dist, comp.param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BVdk_ML_varCov_estimators_+3A_data">data</code></td>
<td>
<p>The observed sample under study.</p>
</td></tr>
<tr><td><code id="BVdk_ML_varCov_estimators_+3A_hat_w">hat_w</code></td>
<td>
<p>Estimate of the unknown component weight.</p>
</td></tr>
<tr><td><code id="BVdk_ML_varCov_estimators_+3A_hat_loc">hat_loc</code></td>
<td>
<p>Estimate of the location shift parameter.</p>
</td></tr>
<tr><td><code id="BVdk_ML_varCov_estimators_+3A_hat_var">hat_var</code></td>
<td>
<p>Estimate of the variance of the symmetric density f, obtained by plugging-in the previous estimates. See 'Details'
below for further information.</p>
</td></tr>
<tr><td><code id="BVdk_ML_varCov_estimators_+3A_comp.dist">comp.dist</code></td>
<td>
<p>A list with two elements corresponding to component distributions (specified with R native names for these distributions) involved
in the admixture model. Unknown elements must be specified as 'NULL' objects, e.g. when 'f' is unknown: list(f=NULL, g='norm').</p>
</td></tr>
<tr><td><code id="BVdk_ML_varCov_estimators_+3A_comp.param">comp.param</code></td>
<td>
<p>A list with two elements corresponding to the parameters of the component distributions, each element being a list
itself. The names used in this list must correspond to the native R argument names for these distributions.
Unknown elements must be specified as 'NULL' objects, e.g. if 'f' is unknown: list(f=NULL, g=list(mean=0,sd=1)).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plug-in strategy is defined in Pommeret, D. and Vandekerkhove, P. (2019); Semiparametric density testing in the contamination model;
Electronic Journal of Statistics, 13, pp. 4743&ndash;4793. The variance of the estimator variance of the unknown density f
is needed in a testing perspective, since included in the variance of the test statistic. Other details about the information
matrix can be found in Bordes, L. and Vandekerkhove, P. (2010); Semiparametric two-component mixture model when a component is known:
an asymptotically normal estimator; Math. Meth. Stat.; 19, pp. 22&ndash;41.
</p>


<h3>Value</h3>

<p>The variance of the estimator of the variance of the unknown component density f.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Simulate data:
list.comp &lt;- list(f = "norm", g = "norm")
list.param &lt;- list(f = c(mean = 4, sd = 1), g = c(mean = 7, sd = 0.5))
sim.data &lt;- rsimmix(n = 400, unknownComp_weight = 0.9, list.comp, list.param)$mixt.data
## Estimate mixture weight and location shift parameters in real-life:
list.comp &lt;- list(f = NULL, g = "norm")
list.param &lt;- list(f = NULL, g = c(mean = 7, sd = 0.5))
estim &lt;- BVdk_estimParam(data = sim.data, method = "L-BFGS-B",
                         comp.dist = list.comp, comp.param = list.param)
## Estimation of the second-order moment of the known component distribution:
m2_knownComp &lt;- mean(rnorm(n = 1000000, mean = 7, sd = 0.5)^2)
hat_s2 &lt;- (1/estim[1]) * (mean(sim.data^2) - ((1-estim[1])*m2_knownComp)) - estim[2]^2
## Estimated variance of variance estimator related to the unknown symmetric component density:
BVdk_ML_varCov_estimators(data = sim.data, hat_w = estim[1], hat_loc = estim[2],
                          hat_var = hat_s2, comp.dist = list.comp, comp.param = list.param)


</code></pre>

<hr>
<h2 id='BVdk_varCov_estimators'>Estimation of the variance of the estimators in admixture models with symmetric unknown density.</h2><span id='topic+BVdk_varCov_estimators'></span>

<h3>Description</h3>

<p>Semiparametric estimation of the variance of the estimators, i.e. the mixture weight p and the location shift parameter mu
considering the admixture model with probability density function l:
l(x) = p*f(x-mu) + (1-p)*g(x), x in R,
where g is the known component of the two-component mixture, p is the unknown proportion, f is the unknown component density and
mu is the location shift. See 'Details' below for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BVdk_varCov_estimators(data, loc, p, comp.dist, comp.param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BVdk_varCov_estimators_+3A_data">data</code></td>
<td>
<p>The observed sample under study.</p>
</td></tr>
<tr><td><code id="BVdk_varCov_estimators_+3A_loc">loc</code></td>
<td>
<p>The estimated location shift parameter, related to the unknown symmetric density.</p>
</td></tr>
<tr><td><code id="BVdk_varCov_estimators_+3A_p">p</code></td>
<td>
<p>The estimated unknown component weight.</p>
</td></tr>
<tr><td><code id="BVdk_varCov_estimators_+3A_comp.dist">comp.dist</code></td>
<td>
<p>A list with two elements corresponding to component distributions (specified with R native names for these distributions) involved
in the admixture model. Unknown elements must be specified as 'NULL' objects, e.g. when 'f' is unknown: list(f=NULL, g='norm').</p>
</td></tr>
<tr><td><code id="BVdk_varCov_estimators_+3A_comp.param">comp.param</code></td>
<td>
<p>A list with two elements corresponding to the parameters of the component distributions, each element being a list
itself. The names used in this list must correspond to the native R argument names for these distributions.
Unknown elements must be specified as 'NULL' objects, e.g. if 'f' is unknown: list(f=NULL, g=list(mean=0,sd=1)).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See formulas pp.28&ndash;30 in Appendix of Bordes, L. and Vandekerkhove, P. (2010); Semiparametric two-component mixture
model when a component is known: an asymptotically normal estimator; Math. Meth. Stat.; 19, pp. 22&ndash;41.
</p>


<h3>Value</h3>

<p>A list containing 1) the variance-covariance matrix of the estimators (assessed at the specific time points 'u' and 'v'
such that u=v=mean(data)); 2) the variance of the mixture weight estimator; 3) the variance
of the location shift estimator; 4) the variance of the unknown component cumulative distribution
function at points 'u' and 'v' (useless for most of applications, explaining why 'u' and 'v'
are set equal to mean(data) by default, with no corresponding arguments here).
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate data:
list.comp &lt;- list(f = 'norm', g = 'norm')
list.param &lt;- list(f = c(mean = 4, sd = 1), g = c(mean = 7, sd = 0.5))
sim.data &lt;- rsimmix(n=140, unknownComp_weight=0.9, comp.dist=list.comp, comp.param=list.param)
## Estimate the location shift and mixture weight parameters in real-life setting:
list.comp &lt;- list(f = NULL, g = 'norm')
list.param &lt;- list(f = NULL, g = c(mean = 7, sd = 0.5))
estimators &lt;- BVdk_estimParam(data = sim.data[['mixt.data']], method = "L-BFGS-B",
                              comp.dist = list.comp, comp.param = list.param)
## Estimate the variance of the two estimators (first mixture weight, then location shift):
BVdk_varCov_estimators(data = sim.data[['mixt.data']], loc = estimators[2], p = estimators[1],
                       comp.dist = list.comp, comp.param = list.param)

</code></pre>

<hr>
<h2 id='decontaminated_cdf'>Provide the decontaminated cumulative distribution function (CDF) of the unknown component in an admixture model</h2><span id='topic+decontaminated_cdf'></span>

<h3>Description</h3>

<p>Estimate the decontaminated CDF of the unknown component in the admixture model under study, after inversion of the admixture
cumulative distribution function. Recall that an admixture model follows the cumulative distribution function (CDF) L, where
L = p*F + (1-p)*G, with g a known CDF and p and f unknown quantities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decontaminated_cdf(sample1, comp.dist, comp.param, estim.p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decontaminated_cdf_+3A_sample1">sample1</code></td>
<td>
<p>Observations of the sample under study.</p>
</td></tr>
<tr><td><code id="decontaminated_cdf_+3A_comp.dist">comp.dist</code></td>
<td>
<p>A list with two elements corresponding to the component distributions (specified with R native names for these distributions)
involved in the admixture model. The two elements refer to the unknown and known components of the admixture model,
If there are unknown elements, they must be specified as 'NULL' objects (e.g. 'comp.dist' could be set to list(f1=NULL, g1='norm')).</p>
</td></tr>
<tr><td><code id="decontaminated_cdf_+3A_comp.param">comp.param</code></td>
<td>
<p>A list with two elements corresponding to the parameters of the component distributions, each element being a list
itself. The names used in this list must correspond to the native R argument names for these distributions.
The two elements refer to the parameters of unknown and known components of the admixture model. If there are unknown
elements, they must be specified as 'NULL' objects (e.g. 'comp.param' could be set to list(f1=NULL, g1=list(mean=0,sd=1))).</p>
</td></tr>
<tr><td><code id="decontaminated_cdf_+3A_estim.p">estim.p</code></td>
<td>
<p>The estimated weight of the unknown component distribution, related to the proportion of the unknown component
in the admixture model studied.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The decontaminated CDF is obtained by inverting the admixture CDF, given by L = p*F + (1-p)*G, to isolate the
unknown component F after having estimated p. This means that F = (1/hat(p)) * (hat(L)-(1-p)*G).
</p>


<h3>Value</h3>

<p>The decontaminated CDF F of the admixture model, as an of class 'stepfun' (step function).
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>####### Continuous support:
## Simulate data:
list.comp &lt;- list(f1 = 'norm', g1 = 'norm',
                  f2 = 'norm', g2 = 'norm')
list.param &lt;- list(f1 = list(mean = 3, sd = 0.5), g1 = list(mean = 0, sd = 1),
                   f2 = list(mean = 3, sd = 0.5), g2 = list(mean = 5, sd = 2))
sample1 &lt;- rsimmix(n=3500, unknownComp_weight=0.5, comp.dist = list(list.comp$f1,list.comp$g1),
                                                   comp.param=list(list.param$f1,list.param$g1))
sample2 &lt;- rsimmix(n=3000, unknownComp_weight=0.7, comp.dist = list(list.comp$f2,list.comp$g2),
                                                   comp.param=list(list.param$f2,list.param$g2))
## Estimate the mixture weight in each of the sample in real-life setting:
list.comp &lt;- list(f1 = NULL, g1 = 'norm',
                  f2 = NULL, g2 = 'norm')
list.param &lt;- list(f1 = NULL, g1 = list(mean = 0, sd = 1),
                   f2 = NULL, g2 = list(mean = 5, sd = 2))
estimate &lt;- IBM_estimProp(sample1[['mixt.data']], sample2[['mixt.data']], comp.dist = list.comp,
                          comp.param = list.param, with.correction = FALSE, n.integ = 1000)
## Determine the decontaminated version of the unknown CDF by inversion:
decontaminated_cdf(sample1 = sample1[['mixt.data']], comp.dist = list.comp[1:2],
                    comp.param = list.param[1:2], estim.p = estimate$prop.estim[1])
####### Countable discrete support:
list.comp &lt;- list(f1 = 'pois', g1 = 'pois',
                  f2 = 'pois', g2 = 'pois')
list.param &lt;- list(f1 = list(lambda = 3), g1 = list(lambda = 2),
                   f2 = list(lambda = 3), g2 = list(lambda = 4))
sample1 &lt;- rsimmix(n=6000, unknownComp_weight=0.6, comp.dist = list(list.comp$f1,list.comp$g1),
                                                   comp.param=list(list.param$f1,list.param$g1))
sample2 &lt;- rsimmix(n=4500, unknownComp_weight=0.8, comp.dist = list(list.comp$f2,list.comp$g2),
                                                   comp.param=list(list.param$f2,list.param$g2))
## Estimate the mixture weight in each of the sample in real-life setting:
list.comp &lt;- list(f1 = NULL, g1 = 'pois',
                  f2 = NULL, g2 = 'pois')
list.param &lt;- list(f1 = NULL, g1 = list(lambda = 2),
                   f2 = NULL, g2 = list(lambda = 4))
estimate &lt;- IBM_estimProp(sample1[['mixt.data']], sample2[['mixt.data']], comp.dist = list.comp,
                          comp.param = list.param, with.correction = FALSE, n.integ = 1000)
decontaminated_cdf(sample1 = sample1[['mixt.data']], comp.dist = list.comp[1:2],
                   comp.param = list.param[1:2], estim.p = estimate$prop.estim[1])
####### Finite discrete support:
list.comp &lt;- list(f1 = 'multinom', g1 = 'multinom',
                  f2 = 'multinom', g2 = 'multinom')
list.param &lt;- list(f1 = list(size=1, prob=c(0.3,0.4,0.3)), g1 = list(size=1, prob=c(0.6,0.3,0.1)),
                   f2 = list(size=1, prob=c(0.3,0.4,0.3)), g2 = list(size=1, prob=c(0.2,0.6,0.2)))
sample1 &lt;- rsimmix(n=8000, unknownComp_weight=0.6, comp.dist = list(list.comp$f1,list.comp$g1),
                                                   comp.param=list(list.param$f1,list.param$g1))
sample2 &lt;- rsimmix(n=6000, unknownComp_weight=0.8, comp.dist = list(list.comp$f2,list.comp$g2),
                                                   comp.param=list(list.param$f2,list.param$g2))
list.comp &lt;- list(f1 = NULL, g1 = 'multinom',
                  f2 = NULL, g2 = 'multinom')
list.param &lt;- list(f1 = NULL, g1 = list(size=1, prob=c(0.6,0.3,0.1)),
                   f2 = NULL, g2 = list(size=1, prob=c(0.2,0.6,0.2)))
estimate &lt;- IBM_estimProp(sample1[['mixt.data']], sample2[['mixt.data']], comp.dist = list.comp,
                          comp.param = list.param, with.correction = FALSE, n.integ = 1000)
decontaminated_cdf(sample1 = sample1[['mixt.data']], comp.dist = list.comp[1:2],
                    comp.param = list.param[1:2], estim.p = estimate$prop.estim[1])

</code></pre>

<hr>
<h2 id='decontaminated_density'>Provide the decontaminated density of the unknown component in an admixture model.</h2><span id='topic+decontaminated_density'></span>

<h3>Description</h3>

<p>Estimate the decontaminated density of the unknown component in the admixture model under study, after inversion of the admixture
cumulative distribution function. Recall that an admixture model follows the cumulative distribution function (CDF) L, where
L = p*F + (1-p)*G, with g a known CDF and p and f unknown quantities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decontaminated_density(sample1, comp.dist, comp.param, estim.p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decontaminated_density_+3A_sample1">sample1</code></td>
<td>
<p>Observations of the first sample under study.</p>
</td></tr>
<tr><td><code id="decontaminated_density_+3A_comp.dist">comp.dist</code></td>
<td>
<p>A list with two elements corresponding to the component distributions (specified with R native names for these distributions)
involved in the admixture model. The two elements refer to the unknown and known components of the admixture model,
If there are unknown elements, they must be specified as 'NULL' objects (e.g. 'comp.dist' could be set to list(f1=NULL, g1='norm')).</p>
</td></tr>
<tr><td><code id="decontaminated_density_+3A_comp.param">comp.param</code></td>
<td>
<p>A list with two elements corresponding to the parameters of the component distributions, each element being a list
itself. The names used in this list must correspond to the native R argument names for these distributions.
The two elements refer to the parameters of unknown and known components of the admixture model. If there are unknown
elements, they must be specified as 'NULL' objects (e.g. 'comp.param' could be set to list(f1=NULL, g1=list(mean=0,sd=1))).</p>
</td></tr>
<tr><td><code id="decontaminated_density_+3A_estim.p">estim.p</code></td>
<td>
<p>The estimated weight of the unknown component distribution, related to the proportion of the unknown component
in the admixture model studied.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The decontaminated density is obtained by inverting the admixture density, given by l = p*f + (1-p)*g, to isolate the
unknown component f after having estimated p.
</p>


<h3>Value</h3>

<p>A list containing the decontaminated density of the admixture model (of class 'function'),
and the support of the observations (either discrete or continuous).
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate data:

####### Continuous support:
list.comp &lt;- list(f1 = 'norm', g1 = 'norm',
                  f2 = 'norm', g2 = 'norm')
list.param &lt;- list(f1 = list(mean = 3, sd = 0.5), g1 = list(mean = 0, sd = 1),
                   f2 = list(mean = 3, sd = 0.5), g2 = list(mean = 5, sd = 2))
sample1 &lt;- rsimmix(n=8000, unknownComp_weight=0.5, comp.dist = list(list.comp$f1,list.comp$g1),
                                                   comp.param=list(list.param$f1,list.param$g1))
sample2 &lt;- rsimmix(n=7000, unknownComp_weight=0.7, comp.dist = list(list.comp$f2,list.comp$g2),
                                                   comp.param=list(list.param$f2,list.param$g2))
## Estimate the mixture weight in each of the sample in real-life setting:
list.comp &lt;- list(f1 = NULL, g1 = 'norm',
                  f2 = NULL, g2 = 'norm')
list.param &lt;- list(f1 = NULL, g1 = list(mean = 0, sd = 1),
                   f2 = NULL, g2 = list(mean = 5, sd = 2))
estimate &lt;- IBM_estimProp(sample1[['mixt.data']], sample2[['mixt.data']], comp.dist = list.comp,
                          comp.param = list.param, with.correction = FALSE, n.integ = 1000)
## Determine the decontaminated version of the unknown density by inversion:
decontaminated_density(sample1 = sample1[['mixt.data']], comp.dist = list.comp[1:2],
                       comp.param = list.param[1:2], estim.p = estimate$prop.estim[1])

####### Discrete support:
list.comp &lt;- list(f1 = 'pois', g1 = 'pois',
                  f2 = 'pois', g2 = 'pois')
list.param &lt;- list(f1 = list(lambda = 3), g1 = list(lambda = 2),
                   f2 = list(lambda = 3), g2 = list(lambda = 4))
sample1 &lt;- rsimmix(n=7000, unknownComp_weight=0.6, comp.dist = list(list.comp$f1,list.comp$g1),
                                                   comp.param=list(list.param$f1,list.param$g1))
sample2 &lt;- rsimmix(n=6000, unknownComp_weight=0.8, comp.dist = list(list.comp$f2,list.comp$g2),
                                                   comp.param=list(list.param$f2,list.param$g2))
## Estimate the mixture weight in each of the sample in real-life setting:
list.comp &lt;- list(f1 = NULL, g1 = 'pois',
                  f2 = NULL, g2 = 'pois')
list.param &lt;- list(f1 = NULL, g1 = list(lambda = 2),
                   f2 = NULL, g2 = list(lambda = 4))
estimate &lt;- IBM_estimProp(sample1[['mixt.data']], sample2[['mixt.data']], comp.dist = list.comp,
                          comp.param = list.param, with.correction = FALSE, n.integ = 1000)
## Determine the decontaminated version of the unknown density by inversion:
decontaminated_density(sample1 = sample1[['mixt.data']], comp.dist = list.comp[1:2],
                       comp.param = list.param[1:2], estim.p = estimate$prop.estim[1])
####### Finite discrete support:
list.comp &lt;- list(f1 = 'multinom', g1 = 'multinom',
                  f2 = 'multinom', g2 = 'multinom')
list.param &lt;- list(f1 = list(size=1, prob=c(0.3,0.4,0.3)), g1 = list(size=1, prob=c(0.6,0.3,0.1)),
                   f2 = list(size=1, prob=c(0.3,0.4,0.3)), g2 = list(size=1, prob=c(0.2,0.6,0.2)))
sample1 &lt;- rsimmix(n=12000, unknownComp_weight=0.6, comp.dist = list(list.comp$f1,list.comp$g1),
                                                   comp.param=list(list.param$f1,list.param$g1))
sample2 &lt;- rsimmix(n=10000, unknownComp_weight=0.8, comp.dist = list(list.comp$f2,list.comp$g2),
                                                   comp.param=list(list.param$f2,list.param$g2))
## Estimate the mixture weight in each of the sample in real-life setting:
list.comp &lt;- list(f1 = NULL, g1 = 'multinom',
                  f2 = NULL, g2 = 'multinom')
list.param &lt;- list(f1 = NULL, g1 = list(size=1, prob=c(0.6,0.3,0.1)),
                   f2 = NULL, g2 = list(size=1, prob=c(0.2,0.6,0.2)))
estimate &lt;- IBM_estimProp(sample1[['mixt.data']], sample2[['mixt.data']], comp.dist = list.comp,
                          comp.param = list.param, with.correction = FALSE, n.integ = 1000)
## Determine the decontaminated version of the unknown density by inversion:
decontaminated_density(sample1 = sample1[['mixt.data']], comp.dist = list.comp[1:2],
                       comp.param = list.param[1:2], estim.p = estimate$prop.estim[1])

</code></pre>

<hr>
<h2 id='detect_support_type'>Detect the support of the random variables under study</h2><span id='topic+detect_support_type'></span>

<h3>Description</h3>

<p>Given one or two sets of observations (two samples), the function provides with the most plausible type of support for the
underlying random variables to be studied. Basically, if less than 3 percent of the observations have different values,
we consider that the support is discrete. Otherwise, we consider it as a continuous support.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>detect_support_type(sample1, sample2 = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="detect_support_type_+3A_sample1">sample1</code></td>
<td>
<p>The first sample of observations under study.</p>
</td></tr>
<tr><td><code id="detect_support_type_+3A_sample2">sample2</code></td>
<td>
<p>The second sample of observations under study.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The type of support, either discrete or continuous.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate the two mixture samples:
list.comp &lt;- list(f1 = 'norm', g1 = 'norm',
                  f2 = 'norm', g2 = 'norm')
list.param &lt;- list(f1 = list(mean = 3, sd = 0.5), g1 = list(mean = 0, sd = 1),
                    f2 = list(mean = 1, sd = 0.1), g2 = list(mean = 5, sd = 2))
sample1 &lt;- rsimmix(n=1500, unknownComp_weight=0.5, comp.dist = list(list.comp$f1,list.comp$g1),
                   comp.param=list(list.param$f1,list.param$g1))
sample2 &lt;- rsimmix(n=2000, unknownComp_weight=0.7, comp.dist = list(list.comp$f2,list.comp$g2),
                   comp.param=list(list.param$f2,list.param$g2))
## Test the type of support:
detect_support_type(sample1[['mixt.data']], sample2[['mixt.data']])

</code></pre>

<hr>
<h2 id='estimVarCov_empProcess'>Variance-covariance matrix of the empirical process in an admixture model</h2><span id='topic+estimVarCov_empProcess'></span>

<h3>Description</h3>

<p>Estimate the variance-covariance matrix of some given empirical process, based on the Donsker correlation.
Compute Donsker correlation between two time points (x,y) for some given empirical process with R code
(another implementation in C++ is also available to speed up this computation).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimVarCov_empProcess(
  x,
  y,
  obs.data,
  known.p = NULL,
  comp.dist = NULL,
  comp.param = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimVarCov_empProcess_+3A_x">x</code></td>
<td>
<p>First time point considered for the computation of the correlation given the empirical process.</p>
</td></tr>
<tr><td><code id="estimVarCov_empProcess_+3A_y">y</code></td>
<td>
<p>Second time point considered for the computation of the correlation given the same empirical process.</p>
</td></tr>
<tr><td><code id="estimVarCov_empProcess_+3A_obs.data">obs.data</code></td>
<td>
<p>Sample that permits to estimate the cumulative distribution function (cdf).</p>
</td></tr>
<tr><td><code id="estimVarCov_empProcess_+3A_known.p">known.p</code></td>
<td>
<p>NULL by default (only useful to compute the exact Donsker correlation). The component weight dedicated to
the unknown mixture component if available (in case of simulation studies)</p>
</td></tr>
<tr><td><code id="estimVarCov_empProcess_+3A_comp.dist">comp.dist</code></td>
<td>
<p>NULL by default (only useful to compute the exact Donsker correlation). Otherwise, a list with two elements
corresponding to component distributions (specified with R native names for these distributions) involved
in the admixture model. All elements must be specified, for instance list(f='norm', g='norm').</p>
</td></tr>
<tr><td><code id="estimVarCov_empProcess_+3A_comp.param">comp.param</code></td>
<td>
<p>NULL by default (only useful to compute the exact Donsker correlation). Otherwise, a list with two elements
corresponding to the parameters of the component distributions, each element being a list itself. The names
used in this list must correspond to the native R argument names for these distributions.
All elements must be specified, for instance list(f=NULL, g=list(mean=0,sd=1)).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The estimated variance-covariance matrix.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate data:
list.comp &lt;- list(f1 = 'norm', g1 = 'norm')
list.param &lt;- list(f1 = list(mean = 12, sd = 0.4),
                   g1 = list(mean = 16, sd = 0.7))
obs.data &lt;- rsimmix(n=2500, unknownComp_weight=0.5, comp.dist=list.comp, comp.param= list.param)
## Compute the variance-covariance matrix of the corresponding empirical process:
t &lt;- seq(from = min(obs.data$mixt.data), to = max(obs.data$mixt.data), length = 50)
S2 &lt;- sapply(t, function(s1) {
                sapply(t, function(s2) {
                     estimVarCov_empProcess(x = s1, y = s2, obs.data = obs.data$mixt.data) })
                })
lattice::wireframe(S2)

</code></pre>

<hr>
<h2 id='gaussianity_test'>One-sample gaussianity test in admixture models using Bordes and Vandekerkhove estimation method</h2><span id='topic+gaussianity_test'></span>

<h3>Description</h3>

<p>Perform the hypothesis test to know whether the unknown mixture component is gaussian or not, knowing that the known one
has support on the real line (R). The case of non-gaussian known component can be overcome thanks to the basic
transformation by cdf. Recall that an admixture model has probability density function (pdf) l = p*f + (1-p)*g, where g is
the known pdf and l is observed (others are unknown). Requires optimization (to estimate the unknown parameters) as defined
by Bordes &amp; Vandekerkhove (2010), which means that the unknown mixture component must have a symmetric density.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gaussianity_test(
  sample1,
  comp.dist,
  comp.param,
  K = 3,
  lambda = 0.2,
  conf.level = 0.95,
  support = c("Real", "Integer", "Positive", "Bounded.continuous")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gaussianity_test_+3A_sample1">sample1</code></td>
<td>
<p>Observed sample with mixture distribution given by l = p*f + (1-p)*g, where f and p are unknown and g is known.</p>
</td></tr>
<tr><td><code id="gaussianity_test_+3A_comp.dist">comp.dist</code></td>
<td>
<p>List with two elements corresponding to the component distributions involved in the admixture model. Unknown
elements must be specified as 'NULL' objects. For instance if 'f' is unknown: list(f = NULL, g = 'norm').</p>
</td></tr>
<tr><td><code id="gaussianity_test_+3A_comp.param">comp.param</code></td>
<td>
<p>List with two elements corresponding to the parameters of the component distributions, each element being a list
itself. The names used in this list must correspond to the native R names for distributions.
Unknown elements must be specified as 'NULL' objects (e.g. if 'f' is unknown: list(f=NULL, g=list(mean=0,sd=1)).</p>
</td></tr>
<tr><td><code id="gaussianity_test_+3A_k">K</code></td>
<td>
<p>Number of coefficients considered for the polynomial basis expansion.</p>
</td></tr>
<tr><td><code id="gaussianity_test_+3A_lambda">lambda</code></td>
<td>
<p>Rate at which the normalization factor is set in the penalization rule for model selection (in ]0,1/2[). See 'Details' below.</p>
</td></tr>
<tr><td><code id="gaussianity_test_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level, default to 95 percent. Equals 1-alpha, where alpha is the level of the test (type-I error).</p>
</td></tr>
<tr><td><code id="gaussianity_test_+3A_support">support</code></td>
<td>
<p>Support of the densities under consideration, useful to choose the polynomial orthonormal basis. One of 'Real',
'Integer', 'Positive', or 'Bounded.continuous'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the paper 'False Discovery Rate model Gaussianity test' (Pommeret &amp; Vanderkerkhove, 2017).
</p>


<h3>Value</h3>

<p>A list of 6 elements, containing: 1) the rejection decision; 2) the p-value of the test; 3) the test statistic; 4) the
variance-covariance matrix of the test statistic; 5) the selected rank for testing; and 6) a list of the estimates
(unknown component weight 'p', shift location parameter 'mu' and standard deviation 's' of the symmetric unknown distribution).
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>####### Under the null hypothesis H0.
## Parameters of the gaussian distribution to be tested:
list.comp &lt;- list(f = "norm", g = "norm")
list.param &lt;- list(f = c(mean = 2, sd = 0.5),
                   g = c(mean = 0, sd = 1))
## Simulate and plot the data at hand:
obs.data &lt;- rsimmix(n = 150, unknownComp_weight = 0.9, comp.dist = list.comp,
                    comp.param = list.param)[['mixt.data']]
plot(density(obs.data))
## Performs the test:
list.comp &lt;- list(f = NULL, g = "norm")
list.param &lt;- list(f = NULL, g = c(mean = 0, sd = 1))
gaussianity_test(sample1 = obs.data, comp.dist = list.comp, comp.param = list.param,
                 K = 3, lambda = 0.1, conf.level = 0.95, support = 'Real')

</code></pre>

<hr>
<h2 id='IBM_2samples_test'>Equality test of unknown component distributions in two admixture models with IBM approach</h2><span id='topic+IBM_2samples_test'></span>

<h3>Description</h3>

<p>Two-sample test of the unknown component distribution in admixture models using Inversion - Best Matching
(IBM) method. Recall that we have two admixture models with respective probability density functions (pdf)
l1 = p1 f1 + (1-p1) g1 and l2 = p2 f2 + (1-p2) g2, where g1 and g2 are known pdf and l1 and l2 are observed.
Perform the following hypothesis test: H0 : f1 = f2 versus H1 : f1 differs from f2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IBM_2samples_test(
  samples,
  known.p = NULL,
  comp.dist = NULL,
  comp.param = NULL,
  sim_U = NULL,
  n_sim_tab = 50,
  min_size = NULL,
  conf.level = 0.95,
  parallel = FALSE,
  n_cpu = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IBM_2samples_test_+3A_samples">samples</code></td>
<td>
<p>A list of the two observed samples, where each sample follows the mixture distribution given by l = p*f + (1-p)*g,
with f and p unknown and g known.</p>
</td></tr>
<tr><td><code id="IBM_2samples_test_+3A_known.p">known.p</code></td>
<td>
<p>(default to NULL) Numeric vector with two elements, the known (true) mixture weights.</p>
</td></tr>
<tr><td><code id="IBM_2samples_test_+3A_comp.dist">comp.dist</code></td>
<td>
<p>A list with four elements corresponding to the component distributions (specified with R native names for these distributions)
involved in the two admixture models. The two first elements refer to the unknown and known components of the 1st admixture model,
and the last two ones to those of the second admixture model. If there are unknown elements, they must be specified as 'NULL' objects.
For instance, 'comp.dist' could be specified as follows: list(f1=NULL, g1='norm', f2=NULL, g2='norm').</p>
</td></tr>
<tr><td><code id="IBM_2samples_test_+3A_comp.param">comp.param</code></td>
<td>
<p>A list with four elements corresponding to the parameters of the component distributions, each element being a list
itself. The names used in this list must correspond to the native R argument names for these distributions.
The two first elements refer to the parameters of unknown and known components of the 1st admixture model, and the last
two ones to those of the second admixture model. If there are unknown elements, they must be specified as 'NULL' objects.
For instance, 'comp.param' could be specified as follows: : list(f1=NULL, g1=list(mean=0,sd=1), f2=NULL, g2=list(mean=3,sd=1.1)).</p>
</td></tr>
<tr><td><code id="IBM_2samples_test_+3A_sim_u">sim_U</code></td>
<td>
<p>Random draws of the inner convergence part of the contrast as defined in the IBM approach (see 'Details' below).</p>
</td></tr>
<tr><td><code id="IBM_2samples_test_+3A_n_sim_tab">n_sim_tab</code></td>
<td>
<p>Number of simulated gaussian processes used in the tabulation of the inner convergence distribution in the IBM approach.</p>
</td></tr>
<tr><td><code id="IBM_2samples_test_+3A_min_size">min_size</code></td>
<td>
<p>(default to NULL, only used with 'ICV' testing method in the k-sample case, otherwise useless) Minimal size among all samples (needed
to take into account the correction factor for the variance-covariance assessment).</p>
</td></tr>
<tr><td><code id="IBM_2samples_test_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level of the 2-samples test, i.e. the quantile level to which the test statistic is compared.</p>
</td></tr>
<tr><td><code id="IBM_2samples_test_+3A_parallel">parallel</code></td>
<td>
<p>(default to FALSE) Boolean to indicate whether parallel computations are performed (speed-up the tabulation).</p>
</td></tr>
<tr><td><code id="IBM_2samples_test_+3A_n_cpu">n_cpu</code></td>
<td>
<p>(default to 2) Number of cores used when parallelizing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the paper presenting the IBM approach at the following HAL weblink: https://hal.science/hal-03201760
</p>


<h3>Value</h3>

<p>A list of five elements, containing : 1) the test statistic value; 2) the rejection decision; 3) the p-value of the
test, 4) the estimated weights of the unknown component for each of the two admixture models, 5) the simulated distribution
of the inner convergence regime (useful to perform the test when comparing to the extreme quantile of this distribution).
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
####### Under the null hypothesis H0 :
## Simulate data:
list.comp &lt;- list(f1 = "norm", g1 = "norm",
                  f2 = "norm", g2 = "norm")
list.param &lt;- list(f1 = list(mean = 1, sd = 1), g1 = list(mean = 2, sd = 0.7),
                   f2 = list(mean = 1, sd = 1), g2 = list(mean = 3, sd = 1.2))
X.sim &lt;- rsimmix(n= 1100, unknownComp_weight=0.85, comp.dist = list(list.comp$f1,list.comp$g1),
                 comp.param = list(list.param$f1, list.param$g1))$mixt.data
Y.sim &lt;- rsimmix(n= 1200, unknownComp_weight=0.75, comp.dist = list(list.comp$f2,list.comp$g2),
                 comp.param = list(list.param$f2, list.param$g2))$mixt.data
list.comp &lt;- list(f1 = NULL, g1 = "norm",
                  f2 = NULL, g2 = "norm")
list.param &lt;- list(f1 = NULL, g1 = list(mean = 2, sd = 0.7),
                   f2 = NULL, g2 = list(mean = 3, sd = 1.2))
IBM_2samples_test(samples = list(X.sim, Y.sim), known.p = NULL, comp.dist = list.comp,
                  comp.param = list.param, sim_U = NULL, n_sim_tab = 6, min_size = NULL,
                  conf.level = 0.95, parallel = FALSE, n_cpu = 2)

####### Under the alternative H1 :
## Simulate data:
list.comp &lt;- list(f1 = "norm", g1 = "norm",
                  f2 = "norm", g2 = "norm")
list.param &lt;- list(f1 = list(mean = 1, sd = 1), g1 = list(mean = 2, sd = 0.7),
                   f2 = list(mean = 2, sd = 1), g2 = list(mean = 3, sd = 1.2))
X.sim &lt;- rsimmix(n= 1100, unknownComp_weight=0.85, comp.dist = list(list.comp$f1,list.comp$g1),
                 comp.param = list(list.param$f1, list.param$g1))$mixt.data
Y.sim &lt;- rsimmix(n= 1200, unknownComp_weight=0.75, comp.dist = list(list.comp$f2,list.comp$g2),
                 comp.param = list(list.param$f2, list.param$g2))$mixt.data
list.comp &lt;- list(f1 = NULL, g1 = "norm",
                  f2 = NULL, g2 = "norm")
list.param &lt;- list(f1 = NULL, g1 = list(mean = 2, sd = 0.7),
                   f2 = NULL, g2 = list(mean = 3, sd = 1.2))
IBM_2samples_test(samples = list(X.sim, Y.sim), known.p = NULL, comp.dist = list.comp,
                  comp.param = list.param, sim_U = NULL, n_sim_tab = 6, min_size = NULL,
                  conf.level = 0.95, parallel = FALSE, n_cpu = 2)


</code></pre>

<hr>
<h2 id='IBM_empirical_contrast'>Empirical computation of the contrast in the Inversion - Best Matching (IBM) method</h2><span id='topic+IBM_empirical_contrast'></span>

<h3>Description</h3>

<p>Defines the empirical version of the contrast in the IBM method, to be minimized in the optimization process. For further details
about the contrast definition, see 'Details' below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IBM_empirical_contrast(
  par,
  fixed.p.X = NULL,
  sample1,
  sample2,
  G,
  comp.dist,
  comp.param
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IBM_empirical_contrast_+3A_par">par</code></td>
<td>
<p>Numeric vector with two elements, corresponding to the two parameter values at which to compute the contrast. In practice
the component weights for the two admixture models.</p>
</td></tr>
<tr><td><code id="IBM_empirical_contrast_+3A_fixed.p.x">fixed.p.X</code></td>
<td>
<p>Arbitrary value chosen by the user for the component weight related to the unknown component of the first
admixture model. Only useful for optimization when the known components of the two models are identical
(G1=G2, leading to unidimensional optimization).</p>
</td></tr>
<tr><td><code id="IBM_empirical_contrast_+3A_sample1">sample1</code></td>
<td>
<p>Observations of the first sample under study.</p>
</td></tr>
<tr><td><code id="IBM_empirical_contrast_+3A_sample2">sample2</code></td>
<td>
<p>Observations of the second sample under study.</p>
</td></tr>
<tr><td><code id="IBM_empirical_contrast_+3A_g">G</code></td>
<td>
<p>Distribution on which to integrate when calculating the contrast.</p>
</td></tr>
<tr><td><code id="IBM_empirical_contrast_+3A_comp.dist">comp.dist</code></td>
<td>
<p>A list with four elements corresponding to the component distributions (specified with R native names for these distributions)
involved in the two admixture models. The two first elements refer to the unknown and known components of the 1st admixture model,
and the last two ones to those of the second admixture model. If there are unknown elements, they must be specified as 'NULL' objects.
For instance, 'comp.dist' could be specified as follows: list(f1=NULL, g1='norm', f2=NULL, g2='norm').</p>
</td></tr>
<tr><td><code id="IBM_empirical_contrast_+3A_comp.param">comp.param</code></td>
<td>
<p>A list with four elements corresponding to the parameters of the component distributions, each element being a list
itself. The names used in this list must correspond to the native R argument names for these distributions.
The two first elements refer to the parameters of unknown and known components of the 1st admixture model, and the last
two ones to those of the second admixture model. If there are unknown elements, they must be specified as 'NULL' objects.
For instance, 'comp.param' could be specified as follows: : list(f1=NULL, g1=list(mean=0,sd=1), f2=NULL, g2=list(mean=3,sd=1.1)).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the paper presenting the IBM approach at the following HAL weblink: https://hal.science/hal-03201760
</p>


<h3>Value</h3>

<p>The empirical contrast value evaluated at parameter values.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate data:
list.comp &lt;- list(f1 = 'norm', g1 = 'norm',
                  f2 = 'norm', g2 = 'norm')
list.param &lt;- list(f1 = list(mean = 3, sd = 0.5), g1 = list(mean = 0, sd = 1),
                   f2 = list(mean = 1, sd = 0.1), g2 = list(mean = 5, sd = 2))
sample1 &lt;- rsimmix(n=1500, unknownComp_weight=0.5, comp.dist = list(list.comp$f1,list.comp$g1),
                                               comp.param = list(list.param$f1,list.param$g1))
sample2 &lt;- rsimmix(n=2000, unknownComp_weight=0.7, comp.dist = list(list.comp$f2,list.comp$g2),
                                               comp.param = list(list.param$f2,list.param$g2))
## Create the distribution on which the contrast will be integrated:
G &lt;- stats::rnorm(n = 1000, mean = sample(c(sample1[['mixt.data']], sample2[['mixt.data']]),
                                          size = 1000, replace = TRUE),
                  sd = density(c(sample1[['mixt.data']], sample2[['mixt.data']]))$bw)
## Compute the empirical contrast at parameters (p1,p2) = (0.2,0.7) in a real-life setting:
list.comp &lt;- list(f1 = NULL, g1 = 'norm',
                  f2 = NULL, g2 = 'norm')
list.param &lt;- list(f1 = NULL, g1 = list(mean = 0, sd = 1),
                   f2 = NULL, g2 = list(mean = 5, sd = 2))
IBM_empirical_contrast(par = c(0.2,0.7), fixed.p.X = NULL, sample1 = sample1[['mixt.data']],
           sample2= sample2[['mixt.data']], G=G, comp.dist = list.comp, comp.param = list.param)

</code></pre>

<hr>
<h2 id='IBM_estimProp'>Estimate the weights related to the proportions of the unknown components of the two admixture models</h2><span id='topic+IBM_estimProp'></span>

<h3>Description</h3>

<p>Estimate the component weights from the Inversion - Best Matching (IBM) method, related to the two admixture models
with respective probability density function (pdf) l1 and l2, such that:
l1 = p1*f1 + (1-p1)<em>g1 and l2 = p2</em>f2 + (1-p2)*g2, where g1 and g2 are the known component densities.
For further details about IBM approach, see 'Details' below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IBM_estimProp(
  sample1,
  sample2,
  known.prop = NULL,
  comp.dist = NULL,
  comp.param = NULL,
  with.correction = TRUE,
  n.integ = 1000
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IBM_estimProp_+3A_sample1">sample1</code></td>
<td>
<p>Observations of the first sample under study.</p>
</td></tr>
<tr><td><code id="IBM_estimProp_+3A_sample2">sample2</code></td>
<td>
<p>Observations of the second sample under study.</p>
</td></tr>
<tr><td><code id="IBM_estimProp_+3A_known.prop">known.prop</code></td>
<td>
<p>(optional) Numeric vector with two elements, respectively the component weight for the unknown component in the first and in the second samples.</p>
</td></tr>
<tr><td><code id="IBM_estimProp_+3A_comp.dist">comp.dist</code></td>
<td>
<p>A list with four elements corresponding to the component distributions (specified with R native names for these distributions)
involved in the two admixture models. The two first elements refer to the unknown and known components of the 1st admixture model,
and the last two ones to those of the second admixture model. If there are unknown elements, they must be specified as 'NULL' objects.
For instance, 'comp.dist' could be specified as follows: list(f1=NULL, g1='norm', f2=NULL, g2='norm').</p>
</td></tr>
<tr><td><code id="IBM_estimProp_+3A_comp.param">comp.param</code></td>
<td>
<p>A list with four elements corresponding to the parameters of the component distributions, each element being a list
itself. The names used in this list must correspond to the native R argument names for these distributions.
The two first elements refer to the parameters of unknown and known components of the 1st admixture model, and the last
two ones to those of the second admixture model. If there are unknown elements, they must be specified as 'NULL' objects.
For instance, 'comp.param' could be specified as follows: : list(f1=NULL, g1=list(mean=0,sd=1), f2=NULL, g2=list(mean=3,sd=1.1)).</p>
</td></tr>
<tr><td><code id="IBM_estimProp_+3A_with.correction">with.correction</code></td>
<td>
<p>Boolean indicating whether the solution (estimated proportions) should be adjusted or not
(with the constant determined thanks to the exact proportion, usually unknown except in case of simulations).</p>
</td></tr>
<tr><td><code id="IBM_estimProp_+3A_n.integ">n.integ</code></td>
<td>
<p>Number of data points generated for the distribution on which to integrate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the paper presenting the IBM approach at the following HAL weblink: https://hal.science/hal-03201760
</p>


<h3>Value</h3>

<p>A list with the two estimates of the component weights for each of the admixture model, plus that of the theoretical model if specified.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##### On a simulated example to see whether the true parameters are well estimated.
## Simulate data:
list.comp &lt;- list(f1 = 'norm', g1 = 'norm',
                  f2 = 'norm', g2 = 'norm')
list.param &lt;- list(f1 = list(mean = 3, sd = 0.5), g1 = list(mean = 0, sd = 1),
                   f2 = list(mean = 3, sd = 0.5), g2 = list(mean = 5, sd = 2))
sample1 &lt;- rsimmix(n=1500, unknownComp_weight=0.5, comp.dist = list(list.comp$f1,list.comp$g1),
                                                 comp.param=list(list.param$f1,list.param$g1))
sample2 &lt;- rsimmix(n=2000, unknownComp_weight=0.7, comp.dist = list(list.comp$f2,list.comp$g2),
                                                 comp.param=list(list.param$f2,list.param$g2))
## Estimate the mixture weights of the two admixture models (provide hat(theta)_n and theta^c):
estim &lt;- IBM_estimProp(sample1 = sample1[['mixt.data']], sample2 = sample2[['mixt.data']],
                       known.prop = c(0.5,0.7), comp.dist = list.comp, comp.param = list.param,
                       with.correction = FALSE, n.integ = 1000)
estim[['prop.estim']]
estim[['theo.prop.estim']]
##### On a real-life example (unknown component densities, unknown mixture weights).
list.comp &lt;- list(f1 = NULL, g1 = 'norm',
                  f2 = NULL, g2 = 'norm')
list.param &lt;- list(f1 = NULL, g1 = list(mean = 0, sd = 1),
                   f2 = NULL, g2 = list(mean = 5, sd = 2))
## Estimate the mixture weights of the two admixture models (provide only hat(theta)_n):
estim &lt;- IBM_estimProp(sample1 = sample1[['mixt.data']], sample2 = sample2[['mixt.data']],
                       known.prop = NULL, comp.dist = list.comp, comp.param = list.param,
                       with.correction = FALSE, n.integ = 1000)
estim[['prop.estim']]
estim[['theo.prop.estim']]

</code></pre>

<hr>
<h2 id='IBM_estimVarCov_gaussVect'>Nonparametric estimation of the variance-covariance matrix of the gaussian vector in IBM approach</h2><span id='topic+IBM_estimVarCov_gaussVect'></span>

<h3>Description</h3>

<p>Estimate the variance-covariance matrix of the gaussian vector at point 'z', considering the use of Inversion - Best
Matching (IBM) method to estimate the model parameters in two-sample admixture models.
Recall that the two admixture models have respective probability density functions (pdf) l1 and l2, such that:
l1 = p1*f1 + (1-p1)<em>g1 and l2 = p2</em>f2 + (1-p2)*g2, where g1 and g2 are the known component densities.
Further information for the IBM approach are given in 'Details' below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IBM_estimVarCov_gaussVect(
  x,
  y,
  estim.obj,
  fixed.p1 = NULL,
  known.p = NULL,
  sample1,
  sample2,
  min_size = NULL,
  comp.dist = NULL,
  comp.param = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IBM_estimVarCov_gaussVect_+3A_x">x</code></td>
<td>
<p>Time point at which the first (related to the first parameter) underlying empirical process is looked through.</p>
</td></tr>
<tr><td><code id="IBM_estimVarCov_gaussVect_+3A_y">y</code></td>
<td>
<p>Time point at which the second (related to the second parameter) underlying empirical process is looked through.</p>
</td></tr>
<tr><td><code id="IBM_estimVarCov_gaussVect_+3A_estim.obj">estim.obj</code></td>
<td>
<p>Object obtained from the estimation of the component weights related to the proportions of the
unknown component in each of the two admixture models.</p>
</td></tr>
<tr><td><code id="IBM_estimVarCov_gaussVect_+3A_fixed.p1">fixed.p1</code></td>
<td>
<p>Arbitrary value chosen by the user for the component weight related to the unknown component of the first
admixture model. Only useful for optimization when the known components of the two models are identical
(G1=G2, leading to unidimensional optimization).</p>
</td></tr>
<tr><td><code id="IBM_estimVarCov_gaussVect_+3A_known.p">known.p</code></td>
<td>
<p>(optional, NULL by default) Numeric vector with two elements, the known (true) mixture weights.</p>
</td></tr>
<tr><td><code id="IBM_estimVarCov_gaussVect_+3A_sample1">sample1</code></td>
<td>
<p>Observations of the first sample under study.</p>
</td></tr>
<tr><td><code id="IBM_estimVarCov_gaussVect_+3A_sample2">sample2</code></td>
<td>
<p>Observations of the second sample under study.</p>
</td></tr>
<tr><td><code id="IBM_estimVarCov_gaussVect_+3A_min_size">min_size</code></td>
<td>
<p>(optional, NULL by default) in the k-sample case, useful to provide the minimal size among all samples
(needed to take into account the correction factor in variance-covariance assessment). Otherwise, useless.</p>
</td></tr>
<tr><td><code id="IBM_estimVarCov_gaussVect_+3A_comp.dist">comp.dist</code></td>
<td>
<p>A list with four elements corresponding to the component distributions (specified with R native names for these distributions)
involved in the two admixture models. The two first elements refer to the unknown and known components of the 1st admixture model,
and the last two ones to those of the second admixture model. If there are unknown elements, they must be specified as 'NULL' objects.
For instance, 'comp.dist' could be specified as follows: list(f1=NULL, g1='norm', f2=NULL, g2='norm').</p>
</td></tr>
<tr><td><code id="IBM_estimVarCov_gaussVect_+3A_comp.param">comp.param</code></td>
<td>
<p>A list with four elements corresponding to the parameters of the component distributions, each element being a list
itself. The names used in this list must correspond to the native R argument names for these distributions.
The two first elements refer to the parameters of unknown and known components of the 1st admixture model, and the last
two ones to those of the second admixture model. If there are unknown elements, they must be specified as 'NULL' objects.
For instance, 'comp.param' could be specified as follows: : list(f1=NULL, g1=list(mean=0,sd=1), f2=NULL, g2=list(mean=3,sd=1.1)).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the paper presenting the IBM approach at the following HAL weblink: https://hal.science/hal-03201760
</p>


<h3>Value</h3>

<p>The estimated variance-covariance matrix of the gaussian vector Z = (hat(p1),(hat(p2),Dn(z)), at location '(x,y)'.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
######## Analysis by simulated data:
## Simulate Gamma - Exponential admixtures :
list.comp &lt;- list(f1 = "gamma", g1 = "exp",
                  f2 = "gamma", g2 = "exp")
list.param &lt;- list(f1 = list(shape = 2, scale = 3), g1 = list(rate = 1/3),
                   f2 = list(shape = 2, scale = 3), g2 = list(rate = 1/5))
X.sim &lt;- rsimmix(n=400, unknownComp_weight=0.8, comp.dist = list(list.comp$f1,list.comp$g1),
                 comp.param = list(list.param$f1, list.param$g1))$mixt.data
Y.sim &lt;- rsimmix(n=350, unknownComp_weight=0.9, comp.dist = list(list.comp$f2,list.comp$g2),
                 comp.param = list(list.param$f2, list.param$g2))$mixt.data
## Real-life setting:
list.comp &lt;- list(f1 = NULL, g1 = "exp",
                  f2 = NULL, g2 = "exp")
list.param &lt;- list(f1 = NULL, g1 = list(rate = 1/3),
                   f2 = NULL, g2 = list(rate = 1/5))
## Estimate the unknown component weights in the two admixture models:
estim &lt;- IBM_estimProp(sample1 =X.sim, sample2 =Y.sim, known.prop = NULL, comp.dist = list.comp,
                       comp.param = list.param, with.correction = FALSE, n.integ = 1000)
IBM_estimVarCov_gaussVect(x = mean(X.sim), y = mean(Y.sim), estim.obj = estim,
                          fixed.p1 = estim[["p.X.fixed"]], known.p = NULL, sample1=X.sim,
                          sample2 = Y.sim, min_size = NULL,
                          comp.dist = list.comp, comp.param = list.param)


</code></pre>

<hr>
<h2 id='IBM_gap'>Difference between the unknown empirical cumulative distribution functions in two admixture models</h2><span id='topic+IBM_gap'></span>

<h3>Description</h3>

<p>Compute the 'gap' between two unknown cumulative distribution functions (ecdf) at some given point, in admixture models
with probability distribution function (pdf) given by l where l = p*f + (1-p)*g.
Uses the inversion method to do so, i.e. f = (1/p) (l - (1-p)*g), where g represents the known component of the admixture
model and p is the unknown proportion of the unknown component. Therefore, compute:
D(z,L1,L2,p1,p2) = F1(z,L1,p1) - F2(z,L2,p2)
This measure should be integrated over some domain to compute the global discrepancy, see further information in 'Details' below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IBM_gap(z, par, fixed.p1 = NULL, sample1, sample2, comp.dist, comp.param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IBM_gap_+3A_z">z</code></td>
<td>
<p>the point at which the difference between both unknown (estimated) component distributions is computed.</p>
</td></tr>
<tr><td><code id="IBM_gap_+3A_par">par</code></td>
<td>
<p>Numeric vector with two elements, corresponding to the weights of the unknown component for the two admixture models.</p>
</td></tr>
<tr><td><code id="IBM_gap_+3A_fixed.p1">fixed.p1</code></td>
<td>
<p>(optional, NULL by default) Arbitrary value chosen by the user for the component weight related to the unknown
component of the first admixture model. Only useful for optimization when the known components of the two
models are identical (G1=G2, leading to unidimensional optimization).</p>
</td></tr>
<tr><td><code id="IBM_gap_+3A_sample1">sample1</code></td>
<td>
<p>Observations of the first sample under study.</p>
</td></tr>
<tr><td><code id="IBM_gap_+3A_sample2">sample2</code></td>
<td>
<p>Observations of the second sample under study.</p>
</td></tr>
<tr><td><code id="IBM_gap_+3A_comp.dist">comp.dist</code></td>
<td>
<p>A list with four elements corresponding to the component distributions (specified with R native names for these distributions)
involved in the two admixture models. The two first elements refer to the unknown and known components of the 1st admixture model,
and the last two ones to those of the second admixture model. If there are unknown elements, they must be specified as 'NULL' objects.
For instance, 'comp.dist' could be specified as follows: list(f1=NULL, g1='norm', f2=NULL, g2='norm').</p>
</td></tr>
<tr><td><code id="IBM_gap_+3A_comp.param">comp.param</code></td>
<td>
<p>A list with four elements corresponding to the parameters of the component distributions, each element being a list
itself. The names used in this list must correspond to the native R argument names for these distributions.
The two first elements refer to the parameters of unknown and known components of the 1st admixture model, and the last
two ones to those of the second admixture model. If there are unknown elements, they must be specified as 'NULL' objects.
For instance, 'comp.param' could be specified as follows: : list(f1=NULL, g1=list(mean=0,sd=1), f2=NULL, g2=list(mean=3,sd=1.1)).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the paper presenting the IBM approach at the following HAL weblink: https://hal.science/hal-03201760
</p>


<h3>Value</h3>

<p>the gap evaluated at the specified point between the unknown components of the two observed samples.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>list.comp &lt;- list(f1 = 'norm', g1 = 'norm',
                  f2 = 'norm', g2 = 'norm')
list.param &lt;- list(f1 = list(mean = 3, sd = 0.5), g1 = list(mean = 0, sd = 1),
                   f2 = list(mean = 1, sd = 0.1), g2 = list(mean = 5, sd = 2))
sample1 &lt;- rsimmix(n=1500, unknownComp_weight=0.5, comp.dist = list(list.comp$f1,list.comp$g1),
                                                   comp.param=list(list.param$f1,list.param$g1))
sample2 &lt;- rsimmix(n=2000, unknownComp_weight=0.7, comp.dist = list(list.comp$f2,list.comp$g2),
                                                   comp.param=list(list.param$f2,list.param$g2))
IBM_gap(z = 2.8, par = c(0.3,0.6), fixed.p1 = NULL, sample1 = sample1[['mixt.data']],
        sample2 = sample2[['mixt.data']], comp.dist = list.comp, comp.param = list.param)

</code></pre>

<hr>
<h2 id='IBM_greenLight_criterion'>Green-light criterion to decide whether to perform full equality test between unknown components between two admixture models</h2><span id='topic+IBM_greenLight_criterion'></span>

<h3>Description</h3>

<p>Indicate whether there is need to perform the statistical test of equality between unknown components when comparing the unknown
components of two samples following admixture models. Based on the IBM approach, see more in 'Details' below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IBM_greenLight_criterion(
  estim.obj,
  sample1,
  sample2,
  comp.dist = NULL,
  comp.param = NULL,
  min_size = NULL,
  alpha = 0.05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IBM_greenLight_criterion_+3A_estim.obj">estim.obj</code></td>
<td>
<p>Object obtained from the estimation of the component weights related to the proportions of the unknown component
in each of the two admixture models studied.</p>
</td></tr>
<tr><td><code id="IBM_greenLight_criterion_+3A_sample1">sample1</code></td>
<td>
<p>Observations of the first sample under study.</p>
</td></tr>
<tr><td><code id="IBM_greenLight_criterion_+3A_sample2">sample2</code></td>
<td>
<p>Observations of the second sample under study.</p>
</td></tr>
<tr><td><code id="IBM_greenLight_criterion_+3A_comp.dist">comp.dist</code></td>
<td>
<p>A list with four elements corresponding to the component distributions (specified with R native names for these distributions)
involved in the two admixture models. The two first elements refer to the unknown and known components of the 1st admixture model,
and the last two ones to those of the second admixture model. If there are unknown elements, they must be specified as 'NULL' objects.
For instance, 'comp.dist' could be specified as follows: list(f1=NULL, g1='norm', f2=NULL, g2='norm').</p>
</td></tr>
<tr><td><code id="IBM_greenLight_criterion_+3A_comp.param">comp.param</code></td>
<td>
<p>A list with four elements corresponding to the parameters of the component distributions, each element being a list
itself. The names used in this list must correspond to the native R argument names for these distributions.
The two first elements refer to the parameters of unknown and known components of the 1st admixture model, and the last
two ones to those of the second admixture model. If there are unknown elements, they must be specified as 'NULL' objects.
For instance, 'comp.param' could be specified as follows: : list(f1=NULL, g1=list(mean=0,sd=1), f2=NULL, g2=list(mean=3,sd=1.1)).</p>
</td></tr>
<tr><td><code id="IBM_greenLight_criterion_+3A_min_size">min_size</code></td>
<td>
<p>(optional, NULL by default) In the k-sample case, useful to provide the minimal size among all samples
(needed to take into account the correction factor for variance-covariance assessment). Otherwise, useless.</p>
</td></tr>
<tr><td><code id="IBM_greenLight_criterion_+3A_alpha">alpha</code></td>
<td>
<p>Confidence level at which the criterion is assessed (used to compute the confidence bands of the estimators
of the unknown component weights).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the paper presenting the IBM approach at the following HAL weblink: https://hal.science/hal-03201760
</p>


<h3>Value</h3>

<p>A boolean indicating whether it is useful or useless to tabulate the contrast distribution in order to answer
the testing problem (f1 = f2).
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Simulate data:
list.comp &lt;- list(f1 = 'norm', g1 = 'norm',
                  f2 = 'norm', g2 = 'norm')
list.param &lt;- list(f1 = list(mean = 3, sd = 0.5), g1 = list(mean = 0, sd = 1),
                   f2 = list(mean = 3, sd = 0.5), g2 = list(mean = 5, sd = 2))
sample1 &lt;- rsimmix(n=550, unknownComp_weight=0.7, comp.dist = list(list.comp$f1,list.comp$g1),
                                                   comp.param=list(list.param$f1,list.param$g1))
sample2 &lt;- rsimmix(n=450, unknownComp_weight=0.8, comp.dist = list(list.comp$f2,list.comp$g2),
                                                   comp.param=list(list.param$f2,list.param$g2))
## Estimate the unknown component weights in the two admixture models in real-life setting:
list.comp &lt;- list(f1 = NULL, g1 = 'norm',
                  f2 = NULL, g2 = 'norm')
list.param &lt;- list(f1 = NULL, g1 = list(mean = 0, sd = 1),
                   f2 = NULL, g2 = list(mean = 5, sd = 2))
estim &lt;- IBM_estimProp(sample1[['mixt.data']], sample2[['mixt.data']], known.prop = NULL,
                       comp.dist = list.comp, comp.param = list.param,
                       with.correction = FALSE, n.integ = 1000)
IBM_greenLight_criterion(estim.obj = estim, sample1 = sample1[['mixt.data']],
                        sample2 = sample2[['mixt.data']], comp.dist = list.comp,
                        comp.param = list.param, min_size = NULL, alpha = 0.05)


</code></pre>

<hr>
<h2 id='IBM_hessian_contrast'>Hessian matrix of the contrast function in the Inversion - Best Matching (IBM) method</h2><span id='topic+IBM_hessian_contrast'></span>

<h3>Description</h3>

<p>Compute the hessian matrix of the contrast as defined in the IBM approach, at point (p1,p2). Here, based on
two samples following admixture models, where we recall that admixture models have probability distribution function
(pdf) given by l where l = p*f + (1-p)*g, where g represents the only known quantity and l is the pdf of the observed sample.
See 'Details' below for further information about the definition of the contrast.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IBM_hessian_contrast(
  par,
  fixed.p1 = NULL,
  known.p = NULL,
  sample1,
  sample2,
  G,
  comp.dist = NULL,
  comp.param = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IBM_hessian_contrast_+3A_par">par</code></td>
<td>
<p>Numeric vector with two elements (corresponding to the two unknown component weights) at which the hessian is computed.</p>
</td></tr>
<tr><td><code id="IBM_hessian_contrast_+3A_fixed.p1">fixed.p1</code></td>
<td>
<p>(optional, NULL by default) Arbitrary value chosen by the user for the component weight related to the unknown
component of the first admixture model. Only useful for optimization when the known components of the two
models are identical (G1=G2, leading to unidimensional optimization).</p>
</td></tr>
<tr><td><code id="IBM_hessian_contrast_+3A_known.p">known.p</code></td>
<td>
<p>(optional, NULL by default) Numeric vector with two elements, the known (true) mixture weights.</p>
</td></tr>
<tr><td><code id="IBM_hessian_contrast_+3A_sample1">sample1</code></td>
<td>
<p>Observations of the first sample under study.</p>
</td></tr>
<tr><td><code id="IBM_hessian_contrast_+3A_sample2">sample2</code></td>
<td>
<p>Observations of the second sample under study.</p>
</td></tr>
<tr><td><code id="IBM_hessian_contrast_+3A_g">G</code></td>
<td>
<p>Distribution on which to integrate when calculating the contrast.</p>
</td></tr>
<tr><td><code id="IBM_hessian_contrast_+3A_comp.dist">comp.dist</code></td>
<td>
<p>A list with four elements corresponding to the component distributions (specified with R native names for these distributions)
involved in the two admixture models. The two first elements refer to the unknown and known components of the 1st admixture model,
and the last two ones to those of the second admixture model. If there are unknown elements, they must be specified as 'NULL' objects.
For instance, 'comp.dist' could be specified as follows: list(f1=NULL, g1='norm', f2=NULL, g2='norm').</p>
</td></tr>
<tr><td><code id="IBM_hessian_contrast_+3A_comp.param">comp.param</code></td>
<td>
<p>A list with four elements corresponding to the parameters of the component distributions, each element being a list
itself. The names used in this list must correspond to the native R argument names for these distributions.
The two first elements refer to the parameters of unknown and known components of the 1st admixture model, and the last
two ones to those of the second admixture model. If there are unknown elements, they must be specified as 'NULL' objects.
For instance, 'comp.param' could be specified as follows: : list(f1=NULL, g1=list(mean=0,sd=1), f2=NULL, g2=list(mean=3,sd=1.1)).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the paper presenting the IBM approach at the following HAL weblink: https://hal.science/hal-03201760
</p>


<h3>Value</h3>

<p>the hessian matrix of the contrast.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate data:
list.comp &lt;- list(f1 = 'norm', g1 = 'norm',
                  f2 = 'norm', g2 = 'norm')
list.param &lt;- list(f1 = list(mean = 3, sd = 0.5), g1 = list(mean = 0, sd = 1),
                   f2 = list(mean = 1, sd = 0.1), g2 = list(mean = 5, sd = 2))
sample1 &lt;- rsimmix(n=1500, unknownComp_weight=0.5, comp.dist = list(list.comp$f1,list.comp$g1),
                                                   comp.param=list(list.param$f1,list.param$g1))
sample2 &lt;- rsimmix(n=2000, unknownComp_weight=0.7, comp.dist = list(list.comp$f2,list.comp$g2),
                                                   comp.param=list(list.param$f2,list.param$g2))
## Define the distribution over which to integrate:
fit.all &lt;- stats::density(x = c(sample1[['mixt.data']],sample2[['mixt.data']]))
G &lt;- stats::rnorm(n = 1000, mean = sample(c(sample1[['mixt.data']], sample2[['mixt.data']]),
                                          size = 1000, replace = TRUE), sd = fit.all$bw)
## Evaluate the hessian matrix at point (p1,p2) = (0.3,0.6):
list.comp &lt;- list(f1 = NULL, g1 = 'norm',
                  f2 = NULL, g2 = 'norm')
list.param &lt;- list(f1 = NULL, g1 = list(mean = 0, sd = 1),
                   f2 = NULL, g2 = list(mean = 5, sd = 2))
IBM_hessian_contrast(par = c(0.3,0.6), fixed.p1 = NULL, known.p = NULL,
                     sample1 = sample1[['mixt.data']],  sample2 = sample2[['mixt.data']], G = G,
                     comp.dist = list.comp, comp.param = list.param)

</code></pre>

<hr>
<h2 id='IBM_k_samples_test'>Equality test of unknown component distributions in K admixture models, with IBM approach</h2><span id='topic+IBM_k_samples_test'></span>

<h3>Description</h3>

<p>Test hypothesis on the unknown component of K (K &gt; 1) admixture models using Inversion - Best Matching method.
K-samples test of the unknown component distribution in admixture models using Inversion - Best Matching
(IBM) method. Recall that we have K populations following admixture models, each one with probability
density functions (pdf) l_k = p_k*f_k + (1-p_k)*g_k, where g_k is the known pdf and l_k corresponds to the
observed sample. Perform the following hypothesis test:
H0 : f_1 = ... = f_K  against  H1 : f_i differs from f_j (i different from j, and i,j in 1,...,K).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IBM_k_samples_test(
  samples = NULL,
  sim_U = NULL,
  n_sim_tab = 100,
  comp.dist = NULL,
  comp.param = NULL,
  conf.level = 0.95,
  tune.penalty = TRUE,
  parallel = FALSE,
  n_cpu = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IBM_k_samples_test_+3A_samples">samples</code></td>
<td>
<p>A list of the K samples to be studied, all following admixture distributions.</p>
</td></tr>
<tr><td><code id="IBM_k_samples_test_+3A_sim_u">sim_U</code></td>
<td>
<p>(default to NULL) Random draws of the inner convergence part of the contrast as defined in the IBM approach (see 'Details' below).</p>
</td></tr>
<tr><td><code id="IBM_k_samples_test_+3A_n_sim_tab">n_sim_tab</code></td>
<td>
<p>Number of simulated gaussian processes when tabulating the inner convergence distribution in the IBM approach.</p>
</td></tr>
<tr><td><code id="IBM_k_samples_test_+3A_comp.dist">comp.dist</code></td>
<td>
<p>A list with 2*K elements corresponding to the component distributions (specified with R native names for these distributions)
involved in the K admixture models. Elements, grouped by 2, refer to the unknown and known components of each admixture model,
If there are unknown elements, they must be specified as 'NULL' objects. For instance, 'comp.dist' could be specified
as follows with K = 3: list(f1 = NULL, g1 = 'norm', f2 = NULL, g2 = 'norm', f3 = NULL, g3 = 'rnorm').</p>
</td></tr>
<tr><td><code id="IBM_k_samples_test_+3A_comp.param">comp.param</code></td>
<td>
<p>A list with 2*K elements corresponding to the parameters of the component distributions, each element being a list
itself. The names used in this list must correspond to the native R argument names for these distributions.
Elements, grouped by 2, refer to the parameters of unknown and known components of each admixture model.
If there are unknown elements, they must be specified as 'NULL' objects. For instance, 'comp.param' could
be specified as follows (with K = 3):
list(f1 = NULL, g1 = list(mean=0,sd=1), f2 = NULL, g2 = list(mean=3,sd=1.1), f3 = NULL, g3 = list(mean=-2,sd=0.6)).</p>
</td></tr>
<tr><td><code id="IBM_k_samples_test_+3A_conf.level">conf.level</code></td>
<td>
<p>The confidence level of the K-sample test.</p>
</td></tr>
<tr><td><code id="IBM_k_samples_test_+3A_tune.penalty">tune.penalty</code></td>
<td>
<p>A boolean that allows to choose between a classical penalty term or an optimized penalty embedding some tuning parameters
(automatically optimized). Optimized penalty is particularly useful for low sample size.</p>
</td></tr>
<tr><td><code id="IBM_k_samples_test_+3A_parallel">parallel</code></td>
<td>
<p>(default to FALSE) Boolean indicating whether parallel computations are performed.</p>
</td></tr>
<tr><td><code id="IBM_k_samples_test_+3A_n_cpu">n_cpu</code></td>
<td>
<p>(default to 2) Number of cores used when parallelizing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the paper at the following HAL weblink: https://hal.science/hal-04129130
</p>


<h3>Value</h3>

<p>A list of ten elements, containing: 1) the rejection decision; 2) the test p-value; 3) the terms involved in
the test statistic; 4) the test statistic value; 5) the selected rank (number of terms involved in the test statistic);
6) the value of the penalized test statistic; 7) a boolean indicating whether the applied penalty rule is that under
the null H0; 8) the sorted contrast values; 9) the 95th-quantile of the contrast distribution; 10) the final terms of
the statistic; and 11) the contrast matrix.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
####### Under the null hypothesis H0 (with K=3 populations):
## Specify the parameters of the mixture models for simulation:
list.comp &lt;- list(f1 = "norm", g1 = "norm",
                  f2 = "norm", g2 = "norm",
                  f3 = "norm", g3 = "norm")
list.param &lt;- list(f1 = list(mean = 0, sd = 1), g1 = list(mean = 2, sd = 0.7),
                   f2 = list(mean = 0, sd = 1), g2 = list(mean = 4, sd = 1.1),
                   f3 = list(mean = 0, sd = 1), g3 = list(mean = -3, sd = 0.8))
## Simulate the data:
sim1 &lt;- rsimmix(n = 1000, unknownComp_weight = 0.8, comp.dist = list(list.comp$f1,list.comp$g1),
                comp.param = list(list.param$f1, list.param$g1))$mixt.data
sim2 &lt;- rsimmix(n= 1300, unknownComp_weight = 0.6, comp.dist = list(list.comp$f2,list.comp$g2),
                comp.param = list(list.param$f2, list.param$g2))$mixt.data
sim3 &lt;- rsimmix(n = 1100, unknownComp_weight = 0.7, comp.dist = list(list.comp$f3,list.comp$g3),
                comp.param = list(list.param$f3, list.param$g3))$mixt.data
## Back to the context of admixture models, where one mixture component is unknown:
list.comp &lt;- list(f1 = NULL, g1 = "norm",
                  f2 = NULL, g2 = "norm",
                  f3 = NULL, g3 = "norm")
list.param &lt;- list(f1 = NULL, g1 = list(mean = 2, sd = 0.7),
                   f2 = NULL, g2 = list(mean = 4, sd = 1.1),
                   f3 = NULL, g3 = list(mean = -3, sd = 0.8))
## Perform the 3-samples test:
IBM_k_samples_test(samples = list(sim1,sim2,sim3), sim_U= NULL, n_sim_tab = 20,
                   comp.dist = list.comp, comp.param = list.param, conf.level = 0.95,
                   tune.penalty = FALSE, parallel = FALSE, n_cpu = 2)

####### Now under the alternative H1:
list.comp &lt;- list(f1 = "norm", g1 = "norm",
                  f2 = "norm", g2 = "norm",
                  f3 = "norm", g3 = "norm")
list.param &lt;- list(f1 = list(mean = 0, sd = 1), g1 = list(mean = 2, sd = 0.7),
                   f2 = list(mean = 0, sd = 1), g2 = list(mean = 4, sd = 1.1),
                   f3 = list(mean = 2, sd = 0.7), g3 = list(mean = 3, sd = 0.8))
sim1 &lt;- rsimmix(n = 3000, unknownComp_weight = 0.8, comp.dist = list(list.comp$f1,list.comp$g1),
                comp.param = list(list.param$f1, list.param$g1))$mixt.data
sim2 &lt;- rsimmix(n= 3300, unknownComp_weight = 0.6, comp.dist = list(list.comp$f2,list.comp$g2),
                comp.param = list(list.param$f2, list.param$g2))$mixt.data
sim3 &lt;- rsimmix(n = 3100, unknownComp_weight = 0.7, comp.dist = list(list.comp$f3,list.comp$g3),
                comp.param = list(list.param$f3, list.param$g3))$mixt.data
list.comp &lt;- list(f1 = NULL, g1 = "norm",
                  f2 = NULL, g2 = "norm",
                  f3 = NULL, g3 = "norm")
list.param &lt;- list(f1 = NULL, g1 = list(mean = 2, sd = 0.7),
                   f2 = NULL, g2 = list(mean = 4, sd = 1.1),
                   f3 = NULL, g3 = list(mean = 3, sd = 0.8))
IBM_k_samples_test(samples = list(sim1,sim2,sim3), sim_U= NULL, n_sim_tab = 20,
                   comp.dist = list.comp, comp.param = list.param, conf.level = 0.95,
                   tune.penalty = FALSE, parallel = FALSE, n_cpu = 2)


</code></pre>

<hr>
<h2 id='IBM_tabul_stochasticInteg'>Distribution of the contrast in the Inversion - Best Matching (IBM) method</h2><span id='topic+IBM_tabul_stochasticInteg'></span>

<h3>Description</h3>

<p>Tabulate the distribution related to the inner convergence part of the contrast, by simulating trajectories of gaussian
processes and applying some transformations. Useful to perform the test hypothesis then, by retrieving the (1-alpha)-quantile
of interest. See 'Details' below and the cited paper therein for further information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IBM_tabul_stochasticInteg(
  n.sim = 200,
  n.varCovMat = 100,
  sample1 = NULL,
  sample2 = NULL,
  min_size = NULL,
  comp.dist = NULL,
  comp.param = NULL,
  parallel = FALSE,
  n_cpu = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IBM_tabul_stochasticInteg_+3A_n.sim">n.sim</code></td>
<td>
<p>Number of trajectories of simulated gaussian processes (number of random draws for tabulation).</p>
</td></tr>
<tr><td><code id="IBM_tabul_stochasticInteg_+3A_n.varcovmat">n.varCovMat</code></td>
<td>
<p>Number of time points on which gaussian processes are simulated.</p>
</td></tr>
<tr><td><code id="IBM_tabul_stochasticInteg_+3A_sample1">sample1</code></td>
<td>
<p>Observations of the first sample under study.</p>
</td></tr>
<tr><td><code id="IBM_tabul_stochasticInteg_+3A_sample2">sample2</code></td>
<td>
<p>Observations of the second sample under study.</p>
</td></tr>
<tr><td><code id="IBM_tabul_stochasticInteg_+3A_min_size">min_size</code></td>
<td>
<p>(default to NULL) In the k-sample case, useful to provide the minimal size among all samples. Otherwise, useless.</p>
</td></tr>
<tr><td><code id="IBM_tabul_stochasticInteg_+3A_comp.dist">comp.dist</code></td>
<td>
<p>A list with four elements corresponding to the component distributions (specified with R native names for these distributions)
involved in the two admixture models. The two first elements refer to the unknown and known components of the 1st admixture model,
and the last two ones to those of the second admixture model. If there are unknown elements, they must be specified as 'NULL' objects.
For instance, 'comp.dist' could be specified as follows: list(f1=NULL, g1='norm', f2=NULL, g2='norm').</p>
</td></tr>
<tr><td><code id="IBM_tabul_stochasticInteg_+3A_comp.param">comp.param</code></td>
<td>
<p>A list with four elements corresponding to the parameters of the component distributions, each element being a list
itself. The names used in this list must correspond to the native R argument names for these distributions.
The two first elements refer to the parameters of unknown and known components of the 1st admixture model, and the last
two ones to those of the second admixture model. If there are unknown elements, they must be specified as 'NULL' objects.
For instance, 'comp.param' could be specified as follows: : list(f1=NULL, g1=list(mean=0,sd=1), f2=NULL, g2=list(mean=3,sd=1.1)).</p>
</td></tr>
<tr><td><code id="IBM_tabul_stochasticInteg_+3A_parallel">parallel</code></td>
<td>
<p>(default to FALSE) Boolean to indicate whether parallel computations are performed (speed-up the tabulation).</p>
</td></tr>
<tr><td><code id="IBM_tabul_stochasticInteg_+3A_n_cpu">n_cpu</code></td>
<td>
<p>(default to 2) Number of cores used for computations when parallelizing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the paper presenting the IBM approach at the following HAL weblink: https://hal.science/hal-03201760
</p>


<h3>Value</h3>

<p>A list with four elements, containing: 1) random draws of the quantity 'sample size times the empirical contrast',
as defined in the IBM approach (see 'Details' above); 2) the estimated unknown component weights for the two admixture
models; 3) the value of the quantity 'sample size times the empirical contrast'; 4) the sequence of points in the
support that were used to evaluate the variance-covariance matrix of empirical processes.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Simulate data:
list.comp &lt;- list(f1 = 'norm', g1 = 'norm',
                  f2 = 'norm', g2 = 'norm')
list.param &lt;- list(f1 = list(mean = 1, sd = 1), g1 = list(mean = 2, sd = 0.7),
                   f2 = list(mean = 1, sd = 1), g2 = list(mean = 3, sd = 1.2))
X.sim &lt;- rsimmix(n=1000, unknownComp_weight=0.7, comp.dist = list(list.comp$f1,list.comp$g1),
                 comp.param = list(list.param$f1, list.param$g1))$mixt.data
Y.sim &lt;- rsimmix(n=1200, unknownComp_weight=0.6, comp.dist = list(list.comp$f2,list.comp$g2),
                 comp.param = list(list.param$f2, list.param$g2))$mixt.data
## Tabulate 1st term of stochastic integral (inner convergence) in a real-life setting:
list.comp &lt;- list(f1 = NULL, g1 = 'norm',
                  f2 = NULL, g2 = 'norm')
list.param &lt;- list(f1 = NULL, g1 = list(mean = 2, sd = 0.7),
                   f2 = NULL, g2 = list(mean = 3, sd = 1.2))
U &lt;- IBM_tabul_stochasticInteg(n.sim = 2, n.varCovMat = 20, sample1 = X.sim, sample2 = Y.sim,
                               min_size = NULL, comp.dist = list.comp, comp.param = list.param,
                               parallel = FALSE, n_cpu = 2)


</code></pre>

<hr>
<h2 id='IBM_theoretical_contrast'>Theoretical contrast in the Inversion - Best Matching (IBM) method</h2><span id='topic+IBM_theoretical_contrast'></span>

<h3>Description</h3>

<p>Defines the theoretical contrast in the IBM approach. Useful in case of simulation studies, since all parameters are
known to the user. For further information about the considered contrast in the IBM approach, see 'Details' below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IBM_theoretical_contrast(
  par,
  theo.par,
  fixed.p.X = NULL,
  G = NULL,
  comp.dist,
  comp.param,
  sample1,
  sample2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IBM_theoretical_contrast_+3A_par">par</code></td>
<td>
<p>Numeric vector with two elements, corresponding to the two parameter values at which to compute the contrast. In practice
the component weights for the two admixture models.</p>
</td></tr>
<tr><td><code id="IBM_theoretical_contrast_+3A_theo.par">theo.par</code></td>
<td>
<p>Numeric vector with two elements, the known (true) mixture weights.</p>
</td></tr>
<tr><td><code id="IBM_theoretical_contrast_+3A_fixed.p.x">fixed.p.X</code></td>
<td>
<p>Arbitrary value chosen by the user for the component weight related to the unknown component of the first
admixture model. Only useful for optimization when the known components of the two models are identical
(G1=G2, leading to unidimensional optimization).</p>
</td></tr>
<tr><td><code id="IBM_theoretical_contrast_+3A_g">G</code></td>
<td>
<p>Distribution on which to integrate when calculating the contrast.</p>
</td></tr>
<tr><td><code id="IBM_theoretical_contrast_+3A_comp.dist">comp.dist</code></td>
<td>
<p>A list with four elements corresponding to the component distributions (specified with R native names for these distributions)
involved in the two admixture models. The two first elements refer to the unknown and known components of the 1st admixture model,
and the last two ones to those of the second admixture model. No unknown elements permitted.
For instance, 'comp.dist' could be specified as follows: list(f1='rnorm', g1='norm', f2='rnorm', g2='norm').</p>
</td></tr>
<tr><td><code id="IBM_theoretical_contrast_+3A_comp.param">comp.param</code></td>
<td>
<p>A list with four elements corresponding to the parameters of the component distributions, each element being a list
itself. The names used in this list must correspond to the native R argument names for these distributions.
The two first elements refer to the parameters of unknown and known components of the 1st admixture model, and the last
two ones to those of the second admixture model. No unknown elements permitted. For instance, 'comp.param' could be specified
as follows: : list(f1 = list(mean=2,sd=0.3), g1 = list(mean=0,sd=1), f2 = list(mean=2,sd=0.3), g2 = list(mean=3,sd=1.1)).</p>
</td></tr>
<tr><td><code id="IBM_theoretical_contrast_+3A_sample1">sample1</code></td>
<td>
<p>Observations of the first sample under study.</p>
</td></tr>
<tr><td><code id="IBM_theoretical_contrast_+3A_sample2">sample2</code></td>
<td>
<p>Observations of the second sample under study.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the paper presenting the IBM approach at the following HAL weblink: https://hal.science/hal-03201760
</p>


<h3>Value</h3>

<p>The theoretical contrast value evaluated at parameter values.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate data:
list.comp &lt;- list(f1 = 'norm', g1 = 'norm',
                  f2 = 'norm', g2 = 'norm')
list.param &lt;- list(f1 = list(mean = 3, sd = 0.5), g1 = list(mean = 0, sd = 1),
                   f2 = list(mean = 1, sd = 0.1), g2 = list(mean = 5, sd = 2))
sample1 &lt;- rsimmix(n=1500, unknownComp_weight=0.5, comp.dist = list(list.comp$f1,list.comp$g1),
                                                   comp.param=list(list.param$f1,list.param$g1))
sample2 &lt;- rsimmix(n=2000, unknownComp_weight=0.7, comp.dist = list(list.comp$f2,list.comp$g2),
                                                   comp.param=list(list.param$f2,list.param$g2))
## Create the distribution on which the contrast will be integrated:
G &lt;- stats::rnorm(n = 1000, mean = sample(c(sample1[['mixt.data']],sample2[['mixt.data']]),
                                          size = 1000, replace = TRUE),
                  sd = stats::density(c(sample1[['mixt.data']],sample2[['mixt.data']]))$bw)
## Compute the theoretical contrast at parameters (p1,p2) = (0.2,0.7):
IBM_theoretical_contrast(par = c(0.2,0.7), theo.par = c(0.5,0.7), fixed.p.X = NULL, G = G,
                         comp.dist = list.comp, comp.param = list.param,
                         sample1 = sample1[['mixt.data']], sample2 = sample2[['mixt.data']])

</code></pre>

<hr>
<h2 id='IBM_theoretical_gap'>Difference between unknown cumulative distribution functions of admixture models at some given point</h2><span id='topic+IBM_theoretical_gap'></span>

<h3>Description</h3>

<p>Compute the gap between the unknown cumulative distribution functions of the two considered admixture models at some given point,
where each admixture model has probability distribution function (pdf) given by l where l = p*f + (1-p)*g.
Uses the inversion method to do so, i.e. f = (1/p) (l - (1-p)g), where g represents the known component of the admixture
model and p is the proportion of the unknown component. This difference must be integrated over some domain to compute the
global discrepancy, as introduced in the paper presenting the IBM approach (see 'Details' below).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IBM_theoretical_gap(z, par, known.p = c(0.5, 0.5), comp.dist, comp.param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IBM_theoretical_gap_+3A_z">z</code></td>
<td>
<p>Point at which the difference between the unknown component distributions of the two considered admixture models is computed.</p>
</td></tr>
<tr><td><code id="IBM_theoretical_gap_+3A_par">par</code></td>
<td>
<p>Numeric vector with two elements, corresponding to the two parameter values at which to compute the gap. In practice
the component weights for the two admixture models.</p>
</td></tr>
<tr><td><code id="IBM_theoretical_gap_+3A_known.p">known.p</code></td>
<td>
<p>Numeric vector with two elements, the known (true) mixture weights.</p>
</td></tr>
<tr><td><code id="IBM_theoretical_gap_+3A_comp.dist">comp.dist</code></td>
<td>
<p>A list with four elements corresponding to the component distributions (specified with R native names for these distributions)
involved in the two admixture models. The two first elements refer to the unknown and known components of the 1st admixture model,
and the last two ones to those of the second admixture model. No unknown elements permitted.
For instance, 'comp.dist' could be specified as follows: list(f1='rnorm', g1='norm', f2='rnorm', g2='norm').</p>
</td></tr>
<tr><td><code id="IBM_theoretical_gap_+3A_comp.param">comp.param</code></td>
<td>
<p>A list with four elements corresponding to the parameters of the component distributions, each element being a list
itself. The names used in this list must correspond to the native R argument names for these distributions.
The two first elements refer to the parameters of unknown and known components of the 1st admixture model, and the last
two ones to those of the second admixture model. No unknown elements permitted. For instance, 'comp.param' could be specified
as follows: : list(f1 = list(mean=2,sd=0.3), g1 = list(mean=0,sd=1), f2 = list(mean=2,sd=0.3), g2 = list(mean=3,sd=1.1)).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the paper presenting the IBM approach at the following HAL weblink: https://hal.science/hal-03201760
</p>


<h3>Value</h3>

<p>The gap between F1 and F2 (unknown components of the two admixture models), evaluated at the specified point.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>list.comp &lt;- list(f1 = 'norm', g1 = 'norm',
                  f2 = 'norm', g2 = 'norm')
list.param &lt;- list(f1 = list(mean = 3, sd = 0.5), g1 = list(mean = 0, sd = 1),
                   f2 = list(mean = 1, sd = 0.1), g2 = list(mean = 5, sd = 2))
IBM_theoretical_gap(z = 2.8, par = c(0.3,0.6), known.p = c(0.5,0.5),
                    comp.dist = list.comp, comp.param = list.param)

</code></pre>

<hr>
<h2 id='is_equal_knownComp'>Test for equality of the known components between two admixture models</h2><span id='topic+is_equal_knownComp'></span>

<h3>Description</h3>

<p>Test if the known components coming from the two two-components admixture models are the same.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_equal_knownComp(comp.dist, comp.param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_equal_knownComp_+3A_comp.dist">comp.dist</code></td>
<td>
<p>A list with four elements corresponding to the component distributions (specified with R native names for these distributions)
involved in the two admixture models. The two first elements refer to the unknown and known components of the 1st admixture model,
and the last two ones to those of the second admixture model. If there are unknown elements, they must be specified as 'NULL' objects.
For instance, 'comp.dist' could be specified as follows: list(f1=NULL, g1='norm', f2=NULL, g2='norm').</p>
</td></tr>
<tr><td><code id="is_equal_knownComp_+3A_comp.param">comp.param</code></td>
<td>
<p>A list with four elements corresponding to the parameters of the component distributions, each element being a list
itself. The names used in this list must correspond to the native R argument names for these distributions.
The two first elements refer to the parameters of unknown and known components of the 1st admixture model, and the last
two ones to those of the second admixture model. If there are unknown elements, they must be specified as 'NULL' objects.
For instance, 'comp.param' could be specified as follows: : list(f1=NULL, g1=list(mean=0,sd=1), f2=NULL, g2=list(mean=3,sd=1.1)).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean (TRUE if the known components are the same, otherwise FALSE).
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>list.comp &lt;- list(f1 = 'norm', g1 = 'norm',
                  f2 = 'norm', g2 = 'norm')
list.param &lt;- list(f1 = list(mean = 3, sd = 0.5), g1 = list(mean = 0, sd = 1),
                   f2 = list(mean = 2, sd = 0.3), g2 = list(mean = 0, sd = 1))
is_equal_knownComp(comp.dist = list.comp, comp.param = list.param)

</code></pre>

<hr>
<h2 id='kernel_cdf'>Kernel estimation</h2><span id='topic+kernel_cdf'></span>

<h3>Description</h3>

<p>Functions to perform the estimation of cumulative distribution function (cdf) by kernel estimators
(with a non-gaussian kernel).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel_cdf(u, h)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel_cdf_+3A_u">u</code></td>
<td>
<p>the point at which the estimation is made.</p>
</td></tr>
<tr><td><code id="kernel_cdf_+3A_h">h</code></td>
<td>
<p>window of the kernel estimation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the estimated value of the cdf.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kernel_cdf(0.4,0.5)

</code></pre>

<hr>
<h2 id='kernel_density'>Kernel estimation</h2><span id='topic+kernel_density'></span>

<h3>Description</h3>

<p>Functions to perform the estimation of probability density function (pdf) by kernel estimators (with a non-gaussian kernel).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kernel_density(u, h)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kernel_density_+3A_u">u</code></td>
<td>
<p>the point at which the estimation is made.</p>
</td></tr>
<tr><td><code id="kernel_density_+3A_h">h</code></td>
<td>
<p>window of the kernel estimation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the estimated value of the pdf.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kernel_density(0.4,0.5)

</code></pre>

<hr>
<h2 id='knownComp_to_uniform'>Transforms the known component of the admixture distribution to a Uniform distribution</h2><span id='topic+knownComp_to_uniform'></span>

<h3>Description</h3>

<p>In admixture such that the probability density function (pdf) follows l = p*f + (1-p)*g, where p is the unknown
weight and f is the unknown component distribution: transforms g of the two-component mixture ditribution to a
Uniform distribution. Useful to use Patra and Sen estimator for the estimation of the unknown weight p.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>knownComp_to_uniform(data, comp.dist, comp.param)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="knownComp_to_uniform_+3A_data">data</code></td>
<td>
<p>Observations of the sample under study, following an admixture distribution.</p>
</td></tr>
<tr><td><code id="knownComp_to_uniform_+3A_comp.dist">comp.dist</code></td>
<td>
<p>A list with two elements corresponding to component distributions (specified with R native names for these distributions) involved
in the admixture model. Unknown elements must be specified as 'NULL' objects, e.g. when 'f' is unknown: list(f=NULL, g='norm').</p>
</td></tr>
<tr><td><code id="knownComp_to_uniform_+3A_comp.param">comp.param</code></td>
<td>
<p>A list with two elements corresponding to the parameters of the component distributions, each element being a list
itself. The names used in this list must correspond to the native R argument names for these distributions.
Unknown elements must be specified as 'NULL' objects, e.g. if 'f' is unknown: list(f=NULL, g=list(mean=0,sd=1)).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The transformed data, i.e. the transformed mixture distribution where the known component g now follows a
Uniform(0,1) distribution.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate data:
list.comp &lt;- list(f1 = 'norm', g1 = 'norm')
list.param &lt;- list(f1 = list(mean = 3, sd = 0.5),
                   g1 = list(mean = 0, sd = 1))
sample1 &lt;- rsimmix(n=1500, unknownComp_weight=0.5, comp.dist = list(list.comp$f1,list.comp$g1),
                                                   comp.param=list(list.param$f1,list.param$g1))
plot_mixt_density(samples = list(sample1[['mixt.data']]), support = 'continuous')
## Transform the known component into a Uniform(0,1) distribution:
list.comp &lt;- list(f1 = NULL, g1 = 'norm')
list.param &lt;- list(f1 = NULL, g1 = list(mean = 0, sd = 1))
transformed_data &lt;- knownComp_to_uniform(data = sample1[['mixt.data']],
                                         comp.dist = list.comp, comp.param = list.param)
plot_mixt_density(samples = list(transformed_data), support = 'continuous')

</code></pre>

<hr>
<h2 id='milkyWay'>Heliocentric velocity measured for the Milky Way (from Walker, M. G., M. Mateo, E. W. Olszewski, O. Y. Gnedin, X. Wang,
B. Sen, and M. Woodroofe (2007). Velocity dispersion profiles of seven dwarf spheroidal galaxies. Astrophysical J. 667(1), L53â€“L56).</h2><span id='topic+milkyWay'></span>

<h3>Description</h3>

<p>Heliocentric velocity measured for the Milky Way (from Walker, M. G., M. Mateo, E. W. Olszewski, O. Y. Gnedin, X. Wang,
B. Sen, and M. Woodroofe (2007). Velocity dispersion profiles of seven dwarf spheroidal galaxies. Astrophysical J. 667(1), L53â€“L56).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>milkyWay
</code></pre>


<h3>Format</h3>

<p>A data frame with 170,601 rows and 1 column:
</p>

<dl>
<dt>V1</dt><dd><p>Heliocentric velocity measurements of the Milky way</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.aanda.org/articles/aa/full_html/2018/08/aa32905-18/aa32905-18.html">https://www.aanda.org/articles/aa/full_html/2018/08/aa32905-18/aa32905-18.html</a>
</p>

<hr>
<h2 id='orthoBasis_coef'>Compute expansion coefficients in a given orthonormal polynomial basis.</h2><span id='topic+orthoBasis_coef'></span>

<h3>Description</h3>

<p>Compute the coefficients corresponding to the decomposition of some density in a given orthonormal polynomial basis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orthoBasis_coef(
  data,
  comp.dist = NULL,
  comp.param = NULL,
  supp = c("Real", "Integer", "Positive", "Bounded.continuous"),
  degree,
  m = 3,
  other = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orthoBasis_coef_+3A_data">data</code></td>
<td>
<p>Observed sample from which the coefficients are calculated. Can be NULL if 'comp.dist' and 'comp.param' are specified.</p>
</td></tr>
<tr><td><code id="orthoBasis_coef_+3A_comp.dist">comp.dist</code></td>
<td>
<p>(default to NULL) A list with two elements corresponding to component distributions (specified with
R native names for these distributions) involved in the admixture model.
Unknown elements must be specified as 'NULL' objects (for instance unknown 'f': list(f=NULL, g='norm')).</p>
</td></tr>
<tr><td><code id="orthoBasis_coef_+3A_comp.param">comp.param</code></td>
<td>
<p>(default to NULL) A list with two elements corresponding to the parameters of the component distributions, each
element being a list itself. The names used in this list must correspond to the native R argument names
for these distributions. Unknown elements must be specified as 'NULL' objects.
For instance if 'f' is unknown: list(f = NULL, g = list(mean=0,sd=1)).</p>
</td></tr>
<tr><td><code id="orthoBasis_coef_+3A_supp">supp</code></td>
<td>
<p>Support of the density considered.</p>
</td></tr>
<tr><td><code id="orthoBasis_coef_+3A_degree">degree</code></td>
<td>
<p>Degree up to which the polynomial basis is built.</p>
</td></tr>
<tr><td><code id="orthoBasis_coef_+3A_m">m</code></td>
<td>
<p>(default to 3) Only used when support is 'Integer'. Corresponds to the mean of the reference measure, i.e. Poisson(m).</p>
</td></tr>
<tr><td><code id="orthoBasis_coef_+3A_other">other</code></td>
<td>
<p>(default to NULL) A list to precise bounds when the support is bounded, where the second and fourth elements give bounds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The list composed of 'degree' elements, each element being a numeric vector (with sample size) where each value represents
the k-th order coefficient found when decomposing the density in the orthonormal polynomial basis.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate data:
sample1 &lt;- rnorm(n = 7000, mean = 3, sd = 1)
## Compute the expansion coefficients in the orthonormal polynomial basis:
coeff &lt;- orthoBasis_coef(data = sample1, comp.dist = NULL, comp.param = NULL, supp = 'Real',
                         degree = 3, m = 3, other = NULL)
sapply(coeff, mean)
## No observed data and decomposition of the known component of the admixture model:
coeff &lt;- orthoBasis_coef(data = NULL, comp.dist = list(NULL, 'norm'),
            comp.param=list(NULL,list(mean=3,sd=1)), supp = 'Real', degree=3, m=3, other = NULL)
sapply(coeff, mean)

</code></pre>

<hr>
<h2 id='orthoBasis_test_H0'>Equality test of unknown components between two admixture models using polynomial basis expansions</h2><span id='topic+orthoBasis_test_H0'></span>

<h3>Description</h3>

<p>Test the null hypothesis (H0: f1=f2) using the decomposition of unknown densities of the two admixture distributions in
an adequate orthonormal polynomial basis. Recall that we have two admixture models with respective probability density
functions (pdf) l1 = p1*f1 + (1-p1)<em>g1 and l2 = p2</em>f2 + (1-p2)*g2, where g1 and g2 are the only known elements.
The admixture weights p1 and p2 thus have to be estimated. For further information on this method, see 'Details' below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orthoBasis_test_H0(
  samples,
  known.p = NULL,
  comp.dist = NULL,
  comp.param = NULL,
  known.coef = NULL,
  K = 3,
  nb.ssEch = 2,
  s = 0.49,
  var.explicit = FALSE,
  nb.echBoot = NULL,
  support = c("Real", "Integer", "Positive", "Bounded.continuous", "Bounded.discrete"),
  bounds.supp = NULL,
  est.method = c("BVdk", "PS"),
  uniformized.knownComp_data = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="orthoBasis_test_H0_+3A_samples">samples</code></td>
<td>
<p>A list of the two observed samples, where each sample follows the mixture distribution given by l = p*f + (1-p)*g,
with f and p unknown and g known.</p>
</td></tr>
<tr><td><code id="orthoBasis_test_H0_+3A_known.p">known.p</code></td>
<td>
<p>(default to NULL) Numeric vector with two elements, respectively the component weight for the unknown component
in the first and in the second samples.</p>
</td></tr>
<tr><td><code id="orthoBasis_test_H0_+3A_comp.dist">comp.dist</code></td>
<td>
<p>A list with four elements corresponding to the component distributions (specified with R native names for these distributions)
involved in the two admixture models. The two first elements refer to the unknown and known components of the 1st admixture model,
and the last two ones to those of the second admixture model. If there are unknown elements, they must be specified as 'NULL' objects.
For instance, 'comp.dist' could be specified as follows: list(f1=NULL, g1='norm', f2=NULL, g2='norm').</p>
</td></tr>
<tr><td><code id="orthoBasis_test_H0_+3A_comp.param">comp.param</code></td>
<td>
<p>A list with four elements corresponding to the parameters of the component distributions, each element being a list
itself. The names used in this list must correspond to the native R argument names for these distributions.
The two first elements refer to the parameters of unknown and known components of the 1st admixture model, and the last
two ones to those of the second admixture model. If there are unknown elements, they must be specified as 'NULL' objects.
For instance, 'comp.param' could be specified as follows: : list(f1=NULL, g1=list(mean=0,sd=1), f2=NULL, g2=list(mean=3,sd=1.1)).</p>
</td></tr>
<tr><td><code id="orthoBasis_test_H0_+3A_known.coef">known.coef</code></td>
<td>
<p>Coefficients in the polynomial basis expansion, corresponding to the known component densities g1 and g2.</p>
</td></tr>
<tr><td><code id="orthoBasis_test_H0_+3A_k">K</code></td>
<td>
<p>Number of coefficients considered for the polynomial basis expansion.</p>
</td></tr>
<tr><td><code id="orthoBasis_test_H0_+3A_nb.ssech">nb.ssEch</code></td>
<td>
<p>Number of subsamples created from the original data to decorrelate the estimation of the different parameters.</p>
</td></tr>
<tr><td><code id="orthoBasis_test_H0_+3A_s">s</code></td>
<td>
<p>Rate at which the normalization factor is set in the penalization rule for model selection (in ]0,1/2[), see 'Details'.</p>
</td></tr>
<tr><td><code id="orthoBasis_test_H0_+3A_var.explicit">var.explicit</code></td>
<td>
<p>Boolean that allows to choose between explicit assessment of the variance of the test statistic or not (FALSE=bootstrap),
FIXME : it seems that bootstrap procedure does not work in the context of admixtures.</p>
</td></tr>
<tr><td><code id="orthoBasis_test_H0_+3A_nb.echboot">nb.echBoot</code></td>
<td>
<p>number of bootstrap samples if 'var.explicit' is set to FALSE.</p>
</td></tr>
<tr><td><code id="orthoBasis_test_H0_+3A_support">support</code></td>
<td>
<p>support of the densities under consideration, useful to choose the polynomial orthonormal basis.</p>
</td></tr>
<tr><td><code id="orthoBasis_test_H0_+3A_bounds.supp">bounds.supp</code></td>
<td>
<p>(default to NULL) useful if support = 'bounded', a list of minimum and maximum bounds, specified as
following: list( list(min.f1,min.g1,min.f2,min.g2) , list(max.f1,max.g1,max.f2,max.g2) )</p>
</td></tr>
<tr><td><code id="orthoBasis_test_H0_+3A_est.method">est.method</code></td>
<td>
<p>Estimation method to get the component weights, either 'PS' (Patra and Sen estimation) or 'BVdk' (Bordes and Vendekerkhove estimation).</p>
</td></tr>
<tr><td><code id="orthoBasis_test_H0_+3A_uniformized.knowncomp_data">uniformized.knownComp_data</code></td>
<td>
<p>(default to NULL) Only useful if 'est.method' has been set to 'PS', and for real-life applications
where the distribution of the known component of the admixture model is also unknown. In this
case, this known component is previously made uniformly(0,1)-distributed by applying the empirical
cumulative distribution of the known component function on the data. This means that
all 'comp.dist' and 'comp.param' must be set to NULL.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See the paper on HAL website: https://hal.science/hal-03692868
</p>


<h3>Value</h3>

<p>A list with six elements containing: 1) the rejection decision; 2) the p-value of the test; 3) the test statistic; 4) the
variance-covariance matrix of the test statistic; 5) selected rank for testing, and 6) estimates of the two component weights.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
###### Using Bordes and Vandekerkhove estimation (valid if symetric unknown component densities).
#### Under the null hypothesis H0.
## Simulate data:
list.comp &lt;- list(f1 = "norm", g1 = "norm",
                  f2 = "norm", g2 = "norm")
list.param &lt;- list(f1 = c(mean = 1, sd = 1), g1 = c(mean = 4, sd = 1),
                   f2 = c(mean = 1, sd = 1), g2 = c(mean = 5, sd = 0.5))
sim.X &lt;- rsimmix(n = 250, unknownComp_weight=0.9, comp.dist = list(list.comp$f1,list.comp$g1),
                 comp.param = list(list.param$f1, list.param$g1))$mixt.data
sim.Y &lt;- rsimmix(n = 300, unknownComp_weight=0.8, comp.dist = list(list.comp$f2,list.comp$g2),
                 comp.param = list(list.param$f2, list.param$g2))$mixt.data
plot_mixt_density(samples = list(sim.X, sim.Y), support = "continuous")
## Perform the hypothesis test in real-life conditions:
list.comp &lt;- list(f1 = NULL, g1 = "norm",
                  f2 = NULL, g2 = "norm")
list.param &lt;- list(f1 = NULL, g1 = c(mean = 4, sd = 1),
                   f2 = NULL, g2 = c(mean = 5, sd = 0.5))
test &lt;- orthoBasis_test_H0(samples = list(sim.X, sim.Y),
             known.p=NULL, comp.dist = list.comp, comp.param = list.param, known.coef=NULL, K=3,
             nb.ssEch = 2, s = 0.25, var.explicit=TRUE, nb.echBoot=NULL, support = 'Real',
             bounds.supp = NULL, est.method = 'BVdk', uniformized.knownComp_data = NULL)
test$decision


</code></pre>

<hr>
<h2 id='PatraSen_cv_mixmodel'>Cross-validation estimate (by Patra and Sen) of the unknown component weight as well as the unknown distribution in an admixture model</h2><span id='topic+PatraSen_cv_mixmodel'></span>

<h3>Description</h3>

<p>Estimation of unknown elements (by Patra and Sen method) under the admixture model with probability density function l:
l = p*f + (1-p)*g,
where g is the known component of the two-component admixture, p is the unknown proportion of the unknown component distribution f.
The estimated unknown component weight p is selected using a cross-validation technique that helps to choose the right penalization, see
'Details' below for further information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PatraSen_cv_mixmodel(
  data,
  folds = 10,
  reps = 1,
  cn.s = NULL,
  cn.length = NULL,
  gridsize = 200
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PatraSen_cv_mixmodel_+3A_data">data</code></td>
<td>
<p>Sample where the known component density of the admixture model has been transformed into a Uniform(0,1) distribution.</p>
</td></tr>
<tr><td><code id="PatraSen_cv_mixmodel_+3A_folds">folds</code></td>
<td>
<p>(default to 10) Number of folds used for cross-validation.</p>
</td></tr>
<tr><td><code id="PatraSen_cv_mixmodel_+3A_reps">reps</code></td>
<td>
<p>(default to 1) Number of replications for cross-validation.</p>
</td></tr>
<tr><td><code id="PatraSen_cv_mixmodel_+3A_cn.s">cn.s</code></td>
<td>
<p>(default to NULL) A sequence of 'c.n' to be used for cross-validation (vector of values).</p>
</td></tr>
<tr><td><code id="PatraSen_cv_mixmodel_+3A_cn.length">cn.length</code></td>
<td>
<p>(default to NULL) Number of equally spaced tuning parameter (between .001 x log(log(n)) and 0.2 x log(log(n))).
Values to search from.</p>
</td></tr>
<tr><td><code id="PatraSen_cv_mixmodel_+3A_gridsize">gridsize</code></td>
<td>
<p>(default to 200) Number of equally spaced points (between 0 and 1) to evaluate the distance function.
Larger values are more computationally intensive but also lead to more accurate estimates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Patra, R.K. and Sen, B. (2016); Estimation of a Two-component Mixture Model with Applications to Multiple Testing;
JRSS Series B, 78, pp. 869&ndash;893.
</p>


<h3>Value</h3>

<p>A list containing 'alp.hat' (estimate of the unknown component weight), 'Fs.hat' (list with elements 'x' and 'y' values for the function estimate
of the unknown cumultaive distribution function), 'dist.out' which is an object of the class 'dist.fun'
using the complete data.gen, 'c.n' the value of the tuning parameter used to compute the final estimate,
and finally 'cv.out' which is an object of class 'cv.mixmodel'. The object is NULL if method is &quot;fixed&quot;.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate data:
comp.dist &lt;- list(f = 'norm', g = 'norm')
comp.param &lt;- list(f = list(mean = 3, sd = 0.5),
                   g = list(mean = 0, sd = 1))
data1 &lt;- rsimmix(n = 2000, unknownComp_weight = 0.3, comp.dist, comp.param)[['mixt.data']]
## Transform the known component of the admixture model into a Uniform(0,1) distribution:
comp.dist &lt;- list(f = NULL, g = 'norm')
comp.param &lt;- list(f = NULL, g = list(mean = 0, sd = 1))
data1_transfo &lt;- knownComp_to_uniform(data = data1, comp.dist = list(comp.dist$f, comp.dist$g),
                                      comp.param = list(comp.param$f, comp.param$g))
plot(density(data1_transfo))
## Estimate the proportion of the unknown component of the admixture model:
PatraSen_cv_mixmodel(data = data1_transfo, folds = 3, reps = 1, cn.s = NULL,
                               cn.length = 3, gridsize = 100)$alp.hat

</code></pre>

<hr>
<h2 id='PatraSen_density_est'>Compute the estimate of the density of the unknown component in an admixture model</h2><span id='topic+PatraSen_density_est'></span>

<h3>Description</h3>

<p>Compute by Patra and Sen technique the estimate of f.s (density corresponding to F.s) when f.s is known to
be either decreasing or increasing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PatraSen_density_est(input, dec.density = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PatraSen_density_est_+3A_input">input</code></td>
<td>
<p>an R object of class 'cv.mixmodel' or 'mixmodel'.</p>
</td></tr>
<tr><td><code id="PatraSen_density_est_+3A_dec.density">dec.density</code></td>
<td>
<p>a boolean indicating whether the density is increasing or decreasing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Patra, R.K. and Sen, B. (2016); Estimation of a Two-component Mixture Model with Applications to Multiple Testing;
JRSS Series B, 78, pp. 869&ndash;893.
</p>


<h3>Value</h3>

<p>an estimator of the unknown component density.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comp.dist &lt;- list(f = 'norm', g = 'norm')
comp.param &lt;- list(f = list(mean = 3, sd = 0.5), g = list(mean = 0, sd = 1))
data1 &lt;- rsimmix(n = 2000, unknownComp_weight = 0.6, comp.dist, comp.param)[['mixt.data']]
data1_transfo &lt;- knownComp_to_uniform(data = data1, comp.dist = list(comp.dist$f, comp.dist$g),
                                      comp.param = list(comp.param$f, comp.param$g))
res &lt;- PatraSen_cv_mixmodel(data = data1_transfo, folds = 3, reps = 1, cn.s = NULL,
                            cn.length = 3, gridsize = 200)
PatraSen_density_est(res, dec.density = TRUE)

</code></pre>

<hr>
<h2 id='PatraSen_dist_calc'>Compute the distance to be minimized using Patra and Sen estimation technique in admixture models</h2><span id='topic+PatraSen_dist_calc'></span>

<h3>Description</h3>

<p>Compute the distance to be minimized using Patra and Sen estimation technique by integrating along some given grid
the appropriate distance. For further developments, see 'Details' below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PatraSen_dist_calc(data, gridsize = 200)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PatraSen_dist_calc_+3A_data">data</code></td>
<td>
<p>Sample where the known component density of the admixture model has been transformed into a Uniform(0,1) distribution.</p>
</td></tr>
<tr><td><code id="PatraSen_dist_calc_+3A_gridsize">gridsize</code></td>
<td>
<p>Gridsize to make the computations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Patra, R.K. and Sen, B. (2016); Estimation of a Two-component Mixture Model with Applications to Multiple Testing;
JRSS Series B, 78, pp. 869&ndash;893.
</p>


<h3>Value</h3>

<p>a list containing the evaluated distance and some additional information.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>comp.dist &lt;- list(f = 'norm', g = 'norm')
comp.param &lt;- list(f = list(mean = 3, sd = 0.5), g = list(mean = 0, sd = 1))
data1 &lt;- rsimmix(n = 3000, unknownComp_weight = 0.6, comp.dist, comp.param)[['mixt.data']]
data1_transfo &lt;- knownComp_to_uniform(data = data1, comp.dist = list(comp.dist$f, comp.dist$g),
                                      comp.param = list(comp.param$f, comp.param$g))
PatraSen_dist_calc(data = data1_transfo, gridsize = 200)

</code></pre>

<hr>
<h2 id='PatraSen_est_mix_model'>Estimate by Patra and Sen the unknown component weight as well as the unknown distribution in admixture models</h2><span id='topic+PatraSen_est_mix_model'></span>

<h3>Description</h3>

<p>Estimation of unknown elements (by Patra and Sen method) under the admixture model with probability density function l:
l = p*f + (1-p)*g,
where g is the known component of the two-component mixture, p is the unknown proportion of the unknown component distribution f.
More information in 'Details' below concerning the estimation method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PatraSen_est_mix_model(
  data,
  method = c("lwr.bnd", "fixed", "cv"),
  c.n = NULL,
  folds = 10,
  reps = 1,
  cn.s = NULL,
  cn.length = 100,
  gridsize = 600
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PatraSen_est_mix_model_+3A_data">data</code></td>
<td>
<p>Sample where the known component density of the admixture model has been transformed into a Uniform(0,1) distribution.</p>
</td></tr>
<tr><td><code id="PatraSen_est_mix_model_+3A_method">method</code></td>
<td>
<p>Either 'fixed' or 'cv', depending on whether compute the estimate based on the value of 'c.n' or
use cross-validation for choosing 'c.n' (tuning parameter).</p>
</td></tr>
<tr><td><code id="PatraSen_est_mix_model_+3A_c.n">c.n</code></td>
<td>
<p>A positive number, with default value equal to 0.1 log(log(n)), where 'n' is the length of the observed sample.</p>
</td></tr>
<tr><td><code id="PatraSen_est_mix_model_+3A_folds">folds</code></td>
<td>
<p>Number of folds used for cross-validation, default is 10.</p>
</td></tr>
<tr><td><code id="PatraSen_est_mix_model_+3A_reps">reps</code></td>
<td>
<p>Number of replications for cross-validation, default is 1.</p>
</td></tr>
<tr><td><code id="PatraSen_est_mix_model_+3A_cn.s">cn.s</code></td>
<td>
<p>A sequence of 'c.n' to be used for cross-validation (vector of values). Default is equally
spaced grid of 100 values between .001 x log(log(n)) and 0.2 x log(log(n)).</p>
</td></tr>
<tr><td><code id="PatraSen_est_mix_model_+3A_cn.length">cn.length</code></td>
<td>
<p>(default to 100) Number of equally spaced tuning parameter (between .001 x log(log(n)) and 0.2 x log(log(n))).
Values to search from.</p>
</td></tr>
<tr><td><code id="PatraSen_est_mix_model_+3A_gridsize">gridsize</code></td>
<td>
<p>(default to 600) Number of equally spaced points (between 0 and 1) to evaluate the distance function.
Larger values are more computationally intensive but also lead to more accurate estimates.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>See Patra, R.K. and Sen, B. (2016); Estimation of a Two-component Mixture Model with Applications to Multiple Testing;
JRSS Series B, 78, pp. 869&ndash;893.
</p>


<h3>Value</h3>

<p>A list containing 'alp.hat' (estimate of the unknown component weight), 'Fs.hat' (list with elements 'x' and 'y' values for the function estimate
of the unknown cumulative distribution function), 'dist.out' which is an object of the class 'dist.fun'
using the complete data.gen, 'c.n' the value of the tuning parameter used to compute the final estimate,
and finally 'cv.out' which is an object of class 'cv.mixmodel'. The object is NULL if method is &quot;fixed&quot;.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate data:
list.comp &lt;- list(f = 'norm', g = 'norm')
list.param &lt;- list(f = list(mean = 3, sd = 0.5),
                   g = list(mean = 0, sd = 1))
data1 &lt;- rsimmix(n = 1500, unknownComp_weight = 0.8, list.comp, list.param)[['mixt.data']]
## Transform the known component of the admixture model into a Uniform(O,1) distribution:
list.comp &lt;- list(f = NULL, g = 'norm')
list.param &lt;- list(f = NULL, g = list(mean = 0, sd = 1))
data1_transfo &lt;- knownComp_to_uniform(data = data1, comp.dist=list.comp, comp.param=list.param)
PatraSen_est_mix_model(data = data1_transfo, method = 'fixed',
                       c.n = 0.1*log(log(length(data1_transfo))), gridsize = 1000)$alp.hat

</code></pre>

<hr>
<h2 id='plot_mixt_density'>Plot the density of some given sample(s) with mixture distributions.</h2><span id='topic+plot_mixt_density'></span>

<h3>Description</h3>

<p>Plot the density of the sample(s) with optional arguments to improve the visualization.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_mixt_density(
  samples,
  user.bounds = NULL,
  support = c("continuous", "discrete"),
  main = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_mixt_density_+3A_samples">samples</code></td>
<td>
<p>Observed samples (mixture distributions) from which the density will be plotted.</p>
</td></tr>
<tr><td><code id="plot_mixt_density_+3A_user.bounds">user.bounds</code></td>
<td>
<p>(default to NULL) Bounds to limit the range of x-axis when plotting.</p>
</td></tr>
<tr><td><code id="plot_mixt_density_+3A_support">support</code></td>
<td>
<p>Support of the distributions, to know whether density plot or histogram should be displayed.</p>
</td></tr>
<tr><td><code id="plot_mixt_density_+3A_main">main</code></td>
<td>
<p>Title for the plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a plot with the densities of the samples provided as inputs.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##### Continuous support:
list.comp &lt;- list(f1 = "norm", g1 = "norm",
                  f2 = "norm", g2 = "norm",
                  f3 = "norm", g3 = "norm")
list.param &lt;- list(f1 = list(mean = 5, sd = 1), g1 = list(mean = 2, sd = 0.7),
                   f2 = list(mean = 0, sd = 1), g2 = list(mean = -3, sd = 1.1),
                   f3 = list(mean = 9, sd = 1), g3 = list(mean = 6, sd = 2))
## Simulate data:
sim1 &lt;- rsimmix(n = 300, unknownComp_weight = 0.8, comp.dist = list(list.comp$f1,list.comp$g1),
                comp.param = list(list.param$f1, list.param$g1))$mixt.data
sim2 &lt;- rsimmix(n= 250, unknownComp_weight = 0.85, comp.dist = list(list.comp$f2,list.comp$g2),
                comp.param = list(list.param$f2, list.param$g2))$mixt.data
sim3 &lt;- rsimmix(n= 400, unknownComp_weight = 0.6, comp.dist = list(list.comp$f3,list.comp$g3),
                comp.param = list(list.param$f3, list.param$g3))$mixt.data
plot_mixt_density(samples = list(sim1,sim2,sim3), user.bounds = NULL, support = "continuous")

####### Countable discrete support:
list.comp &lt;- list(f1 = 'pois', g1 = 'pois',
                  f2 = 'pois', g2 = 'pois')
list.param &lt;- list(f1 = list(lambda = 7), g1 = list(lambda = 1),
                   f2 = list(lambda = 2), g2 = list(lambda = 15))
sim1 &lt;- rsimmix(n=4000, unknownComp_weight=0.5, comp.dist = list(list.comp$f1,list.comp$g1),
                comp.param=list(list.param$f1,list.param$g1))$mixt.data
sim2 &lt;- rsimmix(n=3500, unknownComp_weight=0.3, comp.dist = list(list.comp$f2,list.comp$g2),
                comp.param=list(list.param$f2,list.param$g2))$mixt.data
plot_mixt_density(samples = list(sim1,sim2), user.bounds = NULL, support = "discrete")

</code></pre>

<hr>
<h2 id='plot.decontaminated_density'>Plot the decontaminated density of the unknown component for an estimated admixture model</h2><span id='topic+plot.decontaminated_density'></span>

<h3>Description</h3>

<p>Plot the decontaminated density of the unknown component in the admixture model under study, after inversion of the admixture
cumulative distribution function. Recall that an admixture model follows the cumulative distribution function (CDF) L, where
L = p*F + (1-p)*G, with g a known CDF and p and f unknown quantities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'decontaminated_density'
plot(x, ..., x_val, add_plot = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.decontaminated_density_+3A_x">x</code></td>
<td>
<p>An object of class 'decontamin_dens' (see ?decontaminated_density).</p>
</td></tr>
<tr><td><code id="plot.decontaminated_density_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to methods, such as graphical parameters (see par).</p>
</td></tr>
<tr><td><code id="plot.decontaminated_density_+3A_x_val">x_val</code></td>
<td>
<p>A vector of X-axis values at which to plot the decontaminated density f.</p>
</td></tr>
<tr><td><code id="plot.decontaminated_density_+3A_add_plot">add_plot</code></td>
<td>
<p>(default to FALSE) A boolean specifying if one plots the decontaminated density over an existing plot. Used for visual
comparison purpose.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The decontaminated density is obtained by inverting the admixture density, given by l = p*f + (1-p)*g, to isolate the
unknown component f after having estimated p.
</p>


<h3>Value</h3>

<p>The plot of the decontaminated density.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>####### Continuous support:
## Simulate data:
list.comp &lt;- list(f1 = 'norm', g1 = 'norm',
                  f2 = 'norm', g2 = 'norm')
list.param &lt;- list(f1 = list(mean = 3, sd = 0.5), g1 = list(mean = 0, sd = 1),
                   f2 = list(mean = 3, sd = 0.5), g2 = list(mean = 5, sd = 2))
sample1 &lt;- rsimmix(n=3000, unknownComp_weight=0.7, comp.dist = list(list.comp$f1,list.comp$g1),
                                                   comp.param=list(list.param$f1,list.param$g1))
sample2 &lt;- rsimmix(n=2500, unknownComp_weight=0.8, comp.dist = list(list.comp$f2,list.comp$g2),
                                                   comp.param=list(list.param$f2,list.param$g2))
## Estimate the mixture weight in each of the sample in real-life setting:
list.comp &lt;- list(f1 = NULL, g1 = 'norm',
                  f2 = NULL, g2 = 'norm')
list.param &lt;- list(f1 = NULL, g1 = list(mean = 0, sd = 1),
                   f2 = NULL, g2 = list(mean = 5, sd = 2))
estimate &lt;- IBM_estimProp(sample1[['mixt.data']], sample2[['mixt.data']], comp.dist = list.comp,
                          comp.param = list.param, with.correction = FALSE, n.integ = 1000)
## Determine the decontaminated version of the unknown density by inversion:
res1 &lt;- decontaminated_density(sample1 = sample1[['mixt.data']], comp.dist = list.comp[1:2],
                               comp.param = list.param[1:2], estim.p = estimate$prop.estim[1])
res2 &lt;- decontaminated_density(sample1 = sample2[['mixt.data']], comp.dist = list.comp[3:4],
                               comp.param = list.param[3:4], estim.p = estimate$prop.estim[2])
## Use appropriate sequence of x values:
plot(x = res1, x_val = seq(from = 0, to = 6, length.out = 100), add_plot = FALSE)
plot(x = res2, col = "red", x_val = seq(from = 0, to = 6, length.out = 100), add_plot = TRUE)

####### Countable discrete support:
list.comp &lt;- list(f1 = 'pois', g1 = 'pois',
                  f2 = 'pois', g2 = 'pois')
list.param &lt;- list(f1 = list(lambda = 3), g1 = list(lambda = 2),
                   f2 = list(lambda = 3), g2 = list(lambda = 4))
sample1 &lt;- rsimmix(n=4000, unknownComp_weight=0.7, comp.dist = list(list.comp$f1,list.comp$g1),
                                                   comp.param=list(list.param$f1,list.param$g1))
sample2 &lt;- rsimmix(n=3500, unknownComp_weight=0.85, comp.dist = list(list.comp$f2,list.comp$g2),
                                                   comp.param=list(list.param$f2,list.param$g2))
## Estimate the mixture weight in each of the sample in real-life setting:
list.comp &lt;- list(f1 = NULL, g1 = 'pois',
                  f2 = NULL, g2 = 'pois')
list.param &lt;- list(f1 = NULL, g1 = list(lambda = 2),
                   f2 = NULL, g2 = list(lambda = 4))
estimate &lt;- IBM_estimProp(sample1[['mixt.data']], sample2[['mixt.data']], comp.dist = list.comp,
                          comp.param = list.param, with.correction = FALSE, n.integ = 1000)
## Determine the decontaminated version of the unknown density by inversion:
res1 &lt;- decontaminated_density(sample1 = sample1[['mixt.data']], comp.dist = list.comp[1:2],
                               comp.param = list.param[1:2], estim.p = estimate$prop.estim[1])
res2 &lt;- decontaminated_density(sample1 = sample2[['mixt.data']], comp.dist = list.comp[3:4],
                               comp.param = list.param[3:4], estim.p = estimate$prop.estim[2])
## Use appropriate sequence of x values:
plot(x = res1, x_val = seq(from = 0, to = 15, by = 1), add_plot = FALSE)
plot(x = res2, col = "red", x_val= seq(from=0,to=15,by=1), add_plot = TRUE)

####### Finite discrete support:
list.comp &lt;- list(f1 = 'multinom', g1 = 'multinom',
                  f2 = 'multinom', g2 = 'multinom')
list.param &lt;- list(f1 = list(size=1, prob=c(0.3,0.4,0.3)), g1 = list(size=1, prob=c(0.6,0.3,0.1)),
                   f2 = list(size=1, prob=c(0.3,0.4,0.3)), g2 = list(size=1, prob=c(0.2,0.6,0.2)))
sample1 &lt;- rsimmix(n=4000, unknownComp_weight=0.8, comp.dist = list(list.comp$f1,list.comp$g1),
                                                   comp.param=list(list.param$f1,list.param$g1))
sample2 &lt;- rsimmix(n=3500, unknownComp_weight=0.9, comp.dist = list(list.comp$f2,list.comp$g2),
                                                   comp.param=list(list.param$f2,list.param$g2))
## Estimate the mixture weight in each of the sample in real-life setting:
list.comp &lt;- list(f1 = NULL, g1 = 'multinom',
                  f2 = NULL, g2 = 'multinom')
list.param &lt;- list(f1 = NULL, g1 = list(size=1, prob=c(0.6,0.3,0.1)),
                   f2 = NULL, g2 = list(size=1, prob=c(0.2,0.6,0.2)))
estimate &lt;- IBM_estimProp(sample1[['mixt.data']], sample2[['mixt.data']], comp.dist = list.comp,
                          comp.param = list.param, with.correction = FALSE, n.integ = 1000)
## Determine the decontaminated version of the unknown density by inversion:
res1 &lt;- decontaminated_density(sample1 = sample1[['mixt.data']], comp.dist = list.comp[1:2],
                               comp.param = list.param[1:2], estim.p = estimate$prop.estim[1])
res2 &lt;- decontaminated_density(sample1 = sample2[['mixt.data']], comp.dist = list.comp[3:4],
                               comp.param = list.param[3:4], estim.p = estimate$prop.estim[2])
## Use appropriate sequence of x values:
plot(x = res1, x_val = seq(from = 0, to=6, by = 1), add_plot = FALSE)
plot(x = res2, col = "red", x_val = seq(from = 0, to = 6, by = 1), add_plot = TRUE)

</code></pre>

<hr>
<h2 id='poly_orthonormal_basis'>Build an orthonormal basis to decompose some given probability density function</h2><span id='topic+poly_orthonormal_basis'></span>

<h3>Description</h3>

<p>Build an orthonormal basis, needed to decompose the probability density function (pdf) of the unknown component
from the admixture, depending on the support under consideration.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poly_orthonormal_basis(
  support = c("Real", "Integer", "Positive", "Bounded.continuous", "Bounded.discrete"),
  deg,
  x,
  m
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poly_orthonormal_basis_+3A_support">support</code></td>
<td>
<p>Support of the random variables implied in the two-component mixture distribution.</p>
</td></tr>
<tr><td><code id="poly_orthonormal_basis_+3A_deg">deg</code></td>
<td>
<p>Degree up to which the basis is built.</p>
</td></tr>
<tr><td><code id="poly_orthonormal_basis_+3A_x">x</code></td>
<td>
<p>(NULL by default) Only used when support is 'Integer'. The point at which the polynomial value will be evaluated.</p>
</td></tr>
<tr><td><code id="poly_orthonormal_basis_+3A_m">m</code></td>
<td>
<p>(NULL by default) Only used when support is 'Integer'. Corresponds to the mean of the reference measure, i.e. Poisson(m).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the orthonormal polynomial basis used to decompose the density of the unknown component of the mixture distribution.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>poly_orthonormal_basis(support = 'Real', deg = 10, x = NULL, m = NULL)

</code></pre>

<hr>
<h2 id='print.admix_cluster'>Results of the clustering algorithm performed over the K populations following admixture models.</h2><span id='topic+print.admix_cluster'></span>

<h3>Description</h3>

<p>Print the detected clusters among the populations under study. This method also prints the number of clusters,
the p-values of statistical tests performed when building the clusters, the estimated weights of the unknown component
distributions inside each cluster, and the discrepancy matrix. The latter represents some kind of distance between the populations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'admix_cluster'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.admix_cluster_+3A_x">x</code></td>
<td>
<p>An object of class 'admix_cluster' (see ?admix_clustering).</p>
</td></tr>
<tr><td><code id="print.admix_cluster_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Simulate data (chosen parameters indicate 2 clusters (populations (1,3), (2,4))!):
list.comp &lt;- list(f1 = "gamma", g1 = "exp",
                  f2 = "gamma", g2 = "exp",
                  f3 = "gamma", g3 = "gamma",
                  f4 = "gamma", g4 = "exp")
list.param &lt;- list(f1 = list(shape = 16, rate = 4), g1 = list(rate = 1/3.5),
                   f2 = list(shape = 14, rate = 2), g2 = list(rate = 1/5),
                   f3 = list(shape = 16, rate = 4), g3 = list(shape = 12, rate = 2),
                   f4 = list(shape = 14, rate = 2), g4 = list(rate = 1/7))
A.sim &lt;- rsimmix(n=2600, unknownComp_weight=0.8, comp.dist = list(list.comp$f1,list.comp$g1),
                 comp.param = list(list.param$f1, list.param$g1))$mixt.data
B.sim &lt;- rsimmix(n=3000, unknownComp_weight=0.7, comp.dist = list(list.comp$f2,list.comp$g2),
                 comp.param = list(list.param$f2, list.param$g2))$mixt.data
C.sim &lt;- rsimmix(n=3500, unknownComp_weight=0.6, comp.dist = list(list.comp$f3,list.comp$g3),
                 comp.param = list(list.param$f3, list.param$g3))$mixt.data
D.sim &lt;- rsimmix(n=4800, unknownComp_weight=0.5, comp.dist = list(list.comp$f4,list.comp$g4),
                 comp.param = list(list.param$f4, list.param$g4))$mixt.data
## Look for the clusters:
list.comp &lt;- list(f1 = NULL, g1 = "exp",
                  f2 = NULL, g2 = "exp",
                  f3 = NULL, g3 = "gamma",
                  f4 = NULL, g4 = "exp")
list.param &lt;- list(f1 = NULL, g1 = list(rate = 1/3.5),
                   f2 = NULL, g2 = list(rate = 1/5),
                   f3 = NULL, g3 = list(shape = 12, rate = 2),
                   f4 = NULL, g4 = list(rate = 1/7))
clusters &lt;- admix_clustering(samples = list(A.sim,B.sim,C.sim,D.sim), n_sim_tab = 8,
                             comp.dist=list.comp, comp.param=list.param, conf.level = 0.95,
                             parallel=FALSE, n_cpu=2)
print(clusters)


</code></pre>

<hr>
<h2 id='print.admix_estim'>Print the results of estimated parameters from K admixture models</h2><span id='topic+print.admix_estim'></span>

<h3>Description</h3>

<p>Print the estimated weight p of the unknown component in the admixture model under study Recall that an admixture model
follows the cumulative distribution function (CDF) L, where L = p*F + (1-p)*G, with g a known CDF and p and f unknown quantities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'admix_estim'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.admix_estim_+3A_x">x</code></td>
<td>
<p>An object of class 'admix_estim' (see ?admix_estim).</p>
</td></tr>
<tr><td><code id="print.admix_estim_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##### On a simulated example to see whether the true parameters are well estimated.
list.comp &lt;- list(f1 = "norm", g1 = "norm",
                  f2 = "norm", g2 = "norm")
list.param &lt;- list(f1 = list(mean = 0, sd = 1), g1 = list(mean = 2, sd = 0.7),
                   f2 = list(mean = 0, sd = 1), g2 = list(mean = -3, sd = 1.1))
## Simulate data:
sim1 &lt;- rsimmix(n = 2100, unknownComp_weight = 0.8, comp.dist = list(list.comp$f1,list.comp$g1),
                comp.param = list(list.param$f1, list.param$g1))$mixt.data
sim2 &lt;- rsimmix(n= 2000, unknownComp_weight = 0.85, comp.dist = list(list.comp$f2,list.comp$g2),
                comp.param = list(list.param$f2, list.param$g2))$mixt.data
## Estimate the mixture weights of the admixture models:
list.comp &lt;- list(f1 = NULL, g1 = "norm",
                  f2 = NULL, g2 = "norm")
list.param &lt;- list(f1 = NULL, g1 = list(mean = 2, sd = 0.7),
                   f2 = NULL, g2 = list(mean = -3, sd = 1.1))
estim &lt;- admix_estim(samples = list(sim1,sim2), sym.f = TRUE, est.method = 'IBM',
                     comp.dist = list.comp, comp.param = list.param)
print(x = estim)

</code></pre>

<hr>
<h2 id='print.admix_test'>Print the results of statistical test for equality of unknown component distributions in admixture models</h2><span id='topic+print.admix_test'></span>

<h3>Description</h3>

<p>Print the decision (as well as other useful information) of the statistical test with null hypothesis corresponding to
the equality of unknown component distributions in admixture models. More precisely, given two (or more) admixture models
with cumulative distribution functions (CDF) L1 and L2, where Li = pi*Fi + (1-pi)*Gi i=1,2 and Gi are the known CDFs, the
function performs the test: H0: F1 = F2 versus H1: F1 != F2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'admix_test'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.admix_test_+3A_x">x</code></td>
<td>
<p>An object of class 'admix_test' (see ?admix_test).</p>
</td></tr>
<tr><td><code id="print.admix_test_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##### On a simulated example, with 1 sample (gaussianity test):
list.comp &lt;- list(f1 = "norm", g1 = "norm")
list.param &lt;- list(f1 = list(mean = 0, sd = 1), g1 = list(mean = 2, sd = 0.7))
## Simulate data:
sim1 &lt;- rsimmix(n = 300, unknownComp_weight = 0.85, comp.dist = list(list.comp$f1,list.comp$g1),
                comp.param = list(list.param$f1, list.param$g1))$mixt.data
## Perform the test hypothesis:
list.comp &lt;- list(f1 = NULL, g1 = "norm")
list.param &lt;- list(f1 = NULL, g1 = list(mean = 2, sd = 0.7))
gaussTest &lt;- admix_test(samples = list(sim1), sym.f = TRUE, test.method = 'Poly', sim_U = NULL,
                        n_sim_tab = 50, comp.dist = list.comp, comp.param = list.param,
                        support = "Real", conf.level = 0.95, parallel = FALSE, n_cpu = 2)
print(gaussTest)

</code></pre>

<hr>
<h2 id='rsimmix'>Simulation of a two-component mixture model</h2><span id='topic+rsimmix'></span>

<h3>Description</h3>

<p>Simulate a two-component mixture model following the probability density function (pdf) l such that l = p*f + (1-p)*g,
with f and g mixture component distributions, and p the mixture weight.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsimmix(
  n = 1000,
  unknownComp_weight = 0.5,
  comp.dist = list(f = "norm", g = "norm"),
  comp.param = list(f = c(mean = 0, sd = 1), g = c(mean = 2, sd = 1))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsimmix_+3A_n">n</code></td>
<td>
<p>Number of observations to be drawn.</p>
</td></tr>
<tr><td><code id="rsimmix_+3A_unknowncomp_weight">unknownComp_weight</code></td>
<td>
<p>Weight of the component distribution f (representing the unknown component in admixture models).</p>
</td></tr>
<tr><td><code id="rsimmix_+3A_comp.dist">comp.dist</code></td>
<td>
<p>A list with two elements corresponding to the component distributions (specified with R native names for these distributions)
involved in the mixture model. These elements respectively refer to the two components f and g.
No unknown elements permitted. For instance, 'comp.dist' could be set equal to list(f = 'rnorm', g = 'norm').</p>
</td></tr>
<tr><td><code id="rsimmix_+3A_comp.param">comp.param</code></td>
<td>
<p>A list with two elements corresponding to the parameters of the component distributions, each element being a list
itself. The names used in this list must correspond to the native R argument names for these distributions.
These elements respectively refer to the parameters of f and g distributions of the mixture model. No unknown elements permitted.
For instance, 'comp.param' could be set equal to list(f=list(mean=2,sd=0.3), g=list(mean=0,sd=1)).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of three components. The first, named 'mixt.data', is the simulated sample from the specified mixture distribution.
The second, named 'unknown.data', refers to the data simulated corresponding to the distribution f. The third, named 'known.data',
corresponds to the observations affiliated to the known component g.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim.X &lt;- rsimmix(n = 2000, unknownComp_weight = 0.7, comp.dist = list(f = 'norm', g = 'norm'),
                 comp.param = list(f = list(mean = 3, sd = 0.5), g = list(mean = 0, sd = 1)))
class(sim.X)
attributes(sim.X)
plot_mixt_density(samples = list(sim.X$mixt.data), user.bounds = NULL, support = 'continuous')

</code></pre>

<hr>
<h2 id='rsimmix_mix'>Simulation of a two-component gaussian mixture with one component following a two-component gaussian mixture</h2><span id='topic+rsimmix_mix'></span>

<h3>Description</h3>

<p>Simulate a two-component gaussian admixture model, where the first component is a gaussian mixture itself
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsimmix_mix(n, m, s, p, a)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsimmix_mix_+3A_n">n</code></td>
<td>
<p>is the number of observations to be drawn</p>
</td></tr>
<tr><td><code id="rsimmix_mix_+3A_m">m</code></td>
<td>
<p>the mean (up to the shift a) of the unknown components</p>
</td></tr>
<tr><td><code id="rsimmix_mix_+3A_s">s</code></td>
<td>
<p>the standard deviation of the unknown components</p>
</td></tr>
<tr><td><code id="rsimmix_mix_+3A_p">p</code></td>
<td>
<p>the weight of the unknown component (itself a mixture).</p>
</td></tr>
<tr><td><code id="rsimmix_mix_+3A_a">a</code></td>
<td>
<p>the shift of the mean for the two distributions that are embedded in the unknown component</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the data generated from a mixture of mixture distribution, the data where the known component density has
been made uniform(0,1), and the known data (corresponding to the part of data generated from the known component density).
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sample1 &lt;- rsimmix_mix(n = 3000, m = 5, s = 0.5, p = 0.3, a = 2)[['mixt.data']]
plot(stats::density(sample1))

</code></pre>

<hr>
<h2 id='sim_gaussianProcess'>Simulation of a Gaussian process</h2><span id='topic+sim_gaussianProcess'></span>

<h3>Description</h3>

<p>Simulate the trajectory of a Gaussian process, given a mean vector and a variance-covariance structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_gaussianProcess(
  mean_vec,
  varCov_mat,
  from = 0,
  to = 1,
  start = 0,
  nb.points = 10
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_gaussianProcess_+3A_mean_vec">mean_vec</code></td>
<td>
<p>Vector (if multimensional) of means for the increments following gaussian distribution.</p>
</td></tr>
<tr><td><code id="sim_gaussianProcess_+3A_varcov_mat">varCov_mat</code></td>
<td>
<p>Corresponding variance-covariance structure.</p>
</td></tr>
<tr><td><code id="sim_gaussianProcess_+3A_from">from</code></td>
<td>
<p>Initial time point at which the process is simulated.</p>
</td></tr>
<tr><td><code id="sim_gaussianProcess_+3A_to">to</code></td>
<td>
<p>Last time point at which the process is simulated.</p>
</td></tr>
<tr><td><code id="sim_gaussianProcess_+3A_start">start</code></td>
<td>
<p>Useful if the user wants to make the trajectory start from some given value.</p>
</td></tr>
<tr><td><code id="sim_gaussianProcess_+3A_nb.points">nb.points</code></td>
<td>
<p>Number of points at which the process is simulated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The trajectory of the Gaussian processes after simulating the multivariate Gaussian distributions with
specified variance-covariance structure.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>list.comp &lt;- list(f1 = "norm", g1 = "norm")
list.param &lt;- list(f1 = list(mean = 12, sd = 0.4),
                   g1 = list(mean = 16, sd = 0.7))
sample1 &lt;- rsimmix(n = 2000, unknownComp_weight = 0.5, comp.dist = list.comp,
                   comp.param = list.param)$mixt.data
## First get the variance-covariance matrix of the empirical process (Donsker correlation):
cov_mat &lt;- .Call('_admix_estimVarCov_empProcess_Rcpp', PACKAGE = 'admix',
                  seq(from = min(sample1), to = max(sample1), length.out = 100), sample1)
## Plug it into the simulation of the gaussian process:
B1 &lt;- sim_gaussianProcess(mean_vec=rep(0,nrow(cov_mat)), varCov_mat=cov_mat, from=min(sample1),
                          to = max(sample1), start = 0, nb.points = nrow(cov_mat))
plot(x = B1$dates, y = B1$traj1, type="l", xlim = c(min(sample1),max(sample1)), ylim = c(-1,1))

</code></pre>

<hr>
<h2 id='stmf_small'>Short-term Mortality Fluctuations (STMF) data series, restricted to 6 countries (Belgium, France, Italy, Netherlands, Spain, Germany).</h2><span id='topic+stmf_small'></span>

<h3>Description</h3>

<p>Weekly death counts provide the most objective and comparable way of assessing the scale of short-term mortality
elevations across countries (32 countries) and time. Extraction date: 09/21/2020.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stmf_small
</code></pre>


<h3>Format</h3>

<p>A data frame with 88146 rows and 19 variables:
</p>

<dl>
<dt>CountryCode</dt><dd><p>Mortality database country code</p>
</dd>
<dt>Year</dt><dd><p>Year</p>
</dd>
<dt>Week</dt><dd><p>Week number</p>
</dd>
<dt>Sex</dt><dd><p>Gender ('m': male, 'f': female, 'b': both)</p>
</dd>
<dt>D0_14</dt><dd><p>Age range 0-14</p>
</dd>
<dt>D15_64</dt><dd><p>Age range 15-64</p>
</dd>
<dt>D65_74</dt><dd><p>Age range 65-74</p>
</dd>
<dt>D75_84</dt><dd><p>Age range 75-84</p>
</dd>
<dt>D85p</dt><dd><p>Age range 85-+</p>
</dd>
<dt>DTotal</dt><dd><p>Count of deaths for all ages combined</p>
</dd>
<dt>R0_14</dt><dd><p>Crude death rate for age range 0-14</p>
</dd>
<dt>R15_64</dt><dd><p>Crude death rate for age range 15-64</p>
</dd>
<dt>R65_74</dt><dd><p>Crude death rate for age range 65-74</p>
</dd>
<dt>R75_84</dt><dd><p>Crude death rate for age range 75-84</p>
</dd>
<dt>R85p</dt><dd><p>Crude death rate for age range 85-+</p>
</dd>
<dt>RTotal</dt><dd><p>Crude death rate for all ages combined</p>
</dd>
<dt>Split</dt><dd><p>Indicates if data were split from aggregated age groups (0 if the original data has necessary detailed age scale).
For example, if the original age scale was 0-4, 5-29, 30-65, 65+, then split will be equal to 1</p>
</dd>
<dt>SplitSex</dt><dd><p>Indicates if the original data are available by sex (0) or data are interpolated (1)</p>
</dd>
<dt>Forecast</dt><dd><p>Equals 1 for all years where forecasted population exposures were used to calculate weekly death rates</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.mortality.org">https://www.mortality.org</a>
</p>

<hr>
<h2 id='two_samples_test'>Two-samples hypothesis test on the unknown component in admixture models</h2><span id='topic+two_samples_test'></span>

<h3>Description</h3>

<p>Test hypothesis on the unknown component of admixture models using different estimation techniques, and different
testing strategies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>two_samples_test(
  samples,
  known.p = NULL,
  comp.dist = NULL,
  comp.param = NULL,
  method = c("ICV", "Poly"),
  n_sim_tab = NULL,
  K = 3,
  support = c("Real", "Positive", "Integer", "Bounded.continuous"),
  est.method = c("BVdk", "PS"),
  s = 0.49,
  nb.ssEch = 2,
  var.explicit = F,
  nb.echBoot = NULL,
  bounds.supp = NULL,
  parallel = FALSE,
  n_cpu = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="two_samples_test_+3A_samples">samples</code></td>
<td>
<p>A list of the two observed samples, where each sample follows the mixture distribution given by l = p*f + (1-p)*g,
with f and p unknown and g known.</p>
</td></tr>
<tr><td><code id="two_samples_test_+3A_known.p">known.p</code></td>
<td>
<p>(default to NULL) The true component weights p1 and p2 if known, only useful in simulation studies.</p>
</td></tr>
<tr><td><code id="two_samples_test_+3A_comp.dist">comp.dist</code></td>
<td>
<p>A list with four elements corresponding to the component distributions (specified with R native names for these distributions)
involved in the two admixture models. The two first elements refer to the unknown and known components of the 1st admixture model,
and the last two ones to those of the second admixture model. If there are unknown elements, they must be specified as 'NULL' objects.
For instance, 'comp.dist' could be specified as follows: list(f1=NULL, g1='norm', f2=NULL, g2='norm').</p>
</td></tr>
<tr><td><code id="two_samples_test_+3A_comp.param">comp.param</code></td>
<td>
<p>A list with four elements corresponding to the parameters of the component distributions, each element being a list
itself. The names used in this list must correspond to the native R argument names for these distributions.
The two first elements refer to the parameters of unknown and known components of the 1st admixture model, and the last
two ones to those of the second admixture model. If there are unknown elements, they must be specified as 'NULL' objects.
For instance, 'comp.param' could be specified as follows: : list(f1=NULL, g1=list(mean=0,sd=1), f2=NULL, g2=list(mean=3,sd=1.1)).</p>
</td></tr>
<tr><td><code id="two_samples_test_+3A_method">method</code></td>
<td>
<p>Method used for testing. Choose either 'Poly' or 'ICV'. 'Poly' refers to comparison of expansion coefficients in polynomial
orthonormal basis, whereas 'ICV' refers to the Inner Convergence property obtained when using the IBM approach.
More details are provided below in 'Details'.</p>
</td></tr>
<tr><td><code id="two_samples_test_+3A_n_sim_tab">n_sim_tab</code></td>
<td>
<p>(Only with 'ICV' method) Number of simulated gaussian processes used for the tabulation of the Inner Convergence distribution in IBM approach.</p>
</td></tr>
<tr><td><code id="two_samples_test_+3A_k">K</code></td>
<td>
<p>(Only for 'Poly' method) Number of coefficients considered for the polynomial basis expansion.</p>
</td></tr>
<tr><td><code id="two_samples_test_+3A_support">support</code></td>
<td>
<p>(Only for 'Poly' method) Support of the densities under consideration, useful to choose the polynomial orthonormal basis.
One of 'Real', 'Integer', 'Positive', or 'Bounded.continuous'.</p>
</td></tr>
<tr><td><code id="two_samples_test_+3A_est.method">est.method</code></td>
<td>
<p>(Only for 'Poly' method) Either 'BVdk' (Bordes and Valdekerkhove estimation technique) or 'PS' (Patra and Sen estimation
technique). The latter should not be used since the estimators plugged into the test statistic are not square-root n
consistent. More details are given in Section 'Details' below.</p>
</td></tr>
<tr><td><code id="two_samples_test_+3A_s">s</code></td>
<td>
<p>(Only for 'Poly' method) Rate at which the normalization factor is set in the penalization rule for model selection (in ]0,1/2[).</p>
</td></tr>
<tr><td><code id="two_samples_test_+3A_nb.ssech">nb.ssEch</code></td>
<td>
<p>(Only with 'Poly' method) Number of subsamples created from original data to decorrelate the estimation of the parameters.</p>
</td></tr>
<tr><td><code id="two_samples_test_+3A_var.explicit">var.explicit</code></td>
<td>
<p>(Only with 'Poly' method) Boolean that enables to choose between explicit evaluation of the variance of the test
statistic or not (FALSE=bootstrap). FIXME: it seems that bootstrap procedure does not work in the context of admixtures.</p>
</td></tr>
<tr><td><code id="two_samples_test_+3A_nb.echboot">nb.echBoot</code></td>
<td>
<p>(Only with 'Poly' method) Number of bootstrap samples if 'var.explicit' is set to FALSE.</p>
</td></tr>
<tr><td><code id="two_samples_test_+3A_bounds.supp">bounds.supp</code></td>
<td>
<p>(Only with 'Poly' method) default to NULL. Useful if support = 'bounded.continuous', a list of minimum and maximum bounds,
specified as follows: list( list(min.f1,min.g1,min.f2,min.g2) , list(max.f1,max.g1,max.f2,max.g2) )</p>
</td></tr>
<tr><td><code id="two_samples_test_+3A_parallel">parallel</code></td>
<td>
<p>Boolean to indicate whether parallel computations are performed (speed-up the tabulation).</p>
</td></tr>
<tr><td><code id="two_samples_test_+3A_n_cpu">n_cpu</code></td>
<td>
<p>Number of cores used when parallelizing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Here as some details concerning the different methods that can be choosen: i) 'Poly' relies on two-sample testing strategy
where each unknown component density is decomposed in an orthonormal polynomial basis, and the estimation of the component
weights related to the two two-component admixture models can be performed either using Patra and Sen estimator (despite
the latter is not square-root n consistent and thus should not be used in such hypothesis tests), or by Bordes and Vandekerkhove
estimation technique (if the unknown component density is symmetric); ii) 'ICV' refers to Inversion - Best Matching strategy
which has no constraints except that we need to handle two samples.
</p>


<h3>Value</h3>

<p>The decision of the test with further information such as p-value and others, depending on the method used.
</p>


<h3>Author(s)</h3>

<p>Xavier Milhaud <a href="mailto:xavier.milhaud.research@gmail.com">xavier.milhaud.research@gmail.com</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##### Under the null hypothesis H0 :
## Simulate data:
list.comp &lt;- list(f1 = "norm", g1 = "norm",
                  f2 = "norm", g2 = "norm")
list.param &lt;- list(f1 = list(mean = 3, sd = 0.5), g1 = list(mean = 0, sd = 1),
                   f2 = list(mean = 3, sd = 0.5), g2 = list(mean = 6, sd = 1.2))
sample1 &lt;- rsimmix(n=250, unknownComp_weight=0.85, comp.dist = list(list.comp$f1,list.comp$g1),
                   comp.param = list(list.param$f1,list.param$g1))[['mixt.data']]
sample2 &lt;- rsimmix(n=300, unknownComp_weight=0.8, comp.dist = list(list.comp$f2,list.comp$g2),
                   comp.param = list(list.param$f2,list.param$g2))[['mixt.data']]
plot_mixt_density(samples = list(sample1,sample2), user.bounds=NULL, support='continuous')
##### Performs the test by the different methods :
list.comp &lt;- list(f1 = NULL, g1 = "norm",
                  f2 = NULL, g2 = "norm")
list.param &lt;- list(f1 = NULL, g1 = list(mean = 0, sd = 1),
                   f2 = NULL, g2 = list(mean = 6, sd = 1.2))
## Using expansion coefficients in orthonormal polynomial basis:
two_samples_test(samples = list(sample1, sample2), comp.dist=list.comp, comp.param=list.param,
                 method = 'Poly', K = 3, support = 'Real', est.method = 'BVdk', s = 0.4,
                 nb.ssEch = 2, var.explicit = TRUE)


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
