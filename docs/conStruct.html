<!DOCTYPE html><html><head><title>Help for package conStruct</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {conStruct}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#conStruct-package'><p>The 'conStruct' package.</p></a></li>
<li><a href='#calculate.layer.contribution'><p>Calculate layer contribution</p></a></li>
<li><a href='#compare.two.runs'><p>Compare two conStruct runs</p></a></li>
<li><a href='#conStruct'><p>Run a conStruct analysis.</p></a></li>
<li><a href='#conStruct.data'><p>Example dataset used in a <code>conStruct</code> analysis</p></a></li>
<li><a href='#data.block'><p>Example <code>data.block</code> generated by a <code>conStruct</code> analysis</p></a></li>
<li><a href='#make.admix.pie.plot'><p>Make admixture pie plot</p></a></li>
<li><a href='#make.all.the.plots'><p>Make output plots</p></a></li>
<li><a href='#make.structure.plot'><p>Make STRUCTURE output plot</p></a></li>
<li><a href='#match.layers.x.runs'><p>Match layers up across independent conStruct runs</p></a></li>
<li><a href='#print.conStruct.results'><p>An S3 print method for class conStruct.results</p></a></li>
<li><a href='#print.data.block'><p>An S3 print method for class data.block</p></a></li>
<li><a href='#print.freq.data'><p>An S3 print method for class freq.data</p></a></li>
<li><a href='#print.layer.params'><p>An S3 print method for class layer.params</p></a></li>
<li><a href='#structure2conStruct'><p>Convert a dataset from STRUCTURE to conStruct format</p></a></li>
<li><a href='#x.validation'><p>Run a conStruct cross-validation analysis</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.0.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-1-08</td>
</tr>
<tr>
<td>Title:</td>
<td>Models Spatially Continuous and Discrete Population Genetic
Structure</td>
</tr>
<tr>
<td>Description:</td>
<td>A method for modeling genetic data as a combination of discrete
    layers, within each of which relatedness may decay continuously with geographic
    distance. This package contains code for running analyses (which are implemented
    in the modeling language 'rstan') and visualizing and interpreting output. See the
    paper for more details on the model and its utility.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0), Rcpp (&ge; 0.12.0), methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>rstan (&ge; 2.26.0), rstantools (&ge; 1.5.0), caroline, gtools,
foreach, parallel, doParallel</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>StanHeaders (&ge; 2.26.0), rstan (&ge; 2.26.0), BH (&ge; 1.66.0),
Rcpp (&ge; 0.12.0), RcppEigen (&ge; 0.3.3.3.0), RcppParallel (&ge;
5.0.1)</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>GNU make</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, maps</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-08 15:10:10 UTC; bradburd</td>
</tr>
<tr>
<td>Author:</td>
<td>Gideon Bradburd [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Gideon Bradburd &lt;bradburd@umich.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-08 22:00:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='conStruct-package'>The 'conStruct' package.</h2><span id='topic+conStruct-package'></span>

<h3>Description</h3>

<p>A method for modeling genetic data as a combination of discrete
layers, within each of which relatedness may decay continuously with geographic
distance. This package contains code for running analyses (which are implemented
in the modeling language 'rstan') and visualizing and interpreting output. See the
associated paper for more details on the model and its utility.
</p>


<h3>References</h3>

<p>G.S. Bradburd, G.M. Coop, and P.L. Ralph (2018) &lt;doi: 10.1534/genetics.118.301333&gt;.
</p>
<p>Stan Development Team (2018). RStan: the R interface to Stan. R package version 2.17.3. http://mc-stan.org
</p>

<hr>
<h2 id='calculate.layer.contribution'>Calculate layer contribution</h2><span id='topic+calculate.layer.contribution'></span>

<h3>Description</h3>

<p><code>calculate.layer.contribution</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate.layer.contribution(conStruct.results, data.block, layer.order = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate.layer.contribution_+3A_construct.results">conStruct.results</code></td>
<td>
<p>The list output by a 
<code>conStruct</code> run for a given MCMC chain.</p>
</td></tr>
<tr><td><code id="calculate.layer.contribution_+3A_data.block">data.block</code></td>
<td>
<p>A <code>data.block</code> list saved during a 
<code>conStruct</code> run.</p>
</td></tr>
<tr><td><code id="calculate.layer.contribution_+3A_layer.order">layer.order</code></td>
<td>
<p>An optional <code>vector</code> giving the
order in which the layers of <code>conStruct.results</code> are 
read.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes the results of a <code>conStruct</code> 
analysis and calculates the relative contributions of 
each layer to total covariance.
</p>
<p>This function calculates the contribution of each layer to
total covariance by multiplying the within-layer covariance 
in a given layer by the admixture proportions samples draw 
from that layer. The relative contribution of that layer 
is this absolute contribution divided by the sum of those of 
all other layers. 
A layer can have a large contribution if many samples draw 
large amounts of admixture from it, or if it has a very large 
within-layer covariance parameter (phi), or some combination 
of the two. Layer contribution can be useful for evaluating 
an appropriate level of model complexity for the data (e.g., 
choosing a value of <code>K</code> or comparing the spatial and 
nonspatial models).
</p>


<h3>Value</h3>

<p>This function returns a <code>vector</code> giving the 
relative contributions of the layers 
in the analysis.
</p>

<hr>
<h2 id='compare.two.runs'>Compare two conStruct runs</h2><span id='topic+compare.two.runs'></span>

<h3>Description</h3>

<p><code>compare.two.runs</code> makes figures comparing the output 
from two conStruct analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare.two.runs(
  conStruct.results1,
  data.block1,
  conStruct.results2,
  data.block2,
  prefix,
  layer.colors = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare.two.runs_+3A_construct.results1">conStruct.results1</code></td>
<td>
<p>The list output by a 
<code>conStruct</code> run.</p>
</td></tr>
<tr><td><code id="compare.two.runs_+3A_data.block1">data.block1</code></td>
<td>
<p>A <code>data.block</code> list saved during a 
<code>conStruct</code> run.</p>
</td></tr>
<tr><td><code id="compare.two.runs_+3A_construct.results2">conStruct.results2</code></td>
<td>
<p>The list output by a second
<code>conStruct</code> run.</p>
</td></tr>
<tr><td><code id="compare.two.runs_+3A_data.block2">data.block2</code></td>
<td>
<p>A <code>data.block</code> list saved during a 
second <code>conStruct</code> run.</p>
</td></tr>
<tr><td><code id="compare.two.runs_+3A_prefix">prefix</code></td>
<td>
<p>A character vector to be prepended to all figures.</p>
</td></tr>
<tr><td><code id="compare.two.runs_+3A_layer.colors">layer.colors</code></td>
<td>
<p>A <code>vector</code> of colors to be used in 
plotting results for different layers. Users must 
specify one color per layer.  If <code>NULL</code>, plots 
will use a pre-specified vector of colors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes the outputs from two conStruct analyses and 
generates a number of plots for comparing results and 
diagnosing MCMC performance.
</p>
<p>This function produces a variety of plots that can be 
useful for comparing results from two <code>conStruct</code> analyses.
The runs must have the same number of independent MCMC chains, 
but may have different values of <code>K</code>. The spatial and 
nonspatial models can be compared. If the runs were executed 
with different values of <code>K</code>, the run with the smaller 
value of <code>K</code> should be specified in the first set of 
arguments (<code>conStruct.results1</code> and <code>data.block1</code>).
</p>
<p>The plots made are by no means an exhaustive, and users are 
encouraged to make further plots, or customize these plots as they 
see fit.  For each plot, one file is generated for each MCMC chain 
in each analysis (specified with the <code>n.chains</code> argument in 
the function <code>conStruct</code>. For clarity, the layers in the second 
are matched to those in the first using the function 
<code>match.clusters.x.runs</code> The plots generated (as .pdf files) are:
</p>

<ul>
<li><p> Structure plot - STRUCTURE-style plot, where each sample 
is represented as a stacked bar plot, and the length of the 
bar plot segments of each color represent that sample's 
admixture proportion in that layer. Described further 
in the help page for <code>make.structure.plot</code>.
</p>
</li>
<li><p> Admixture pie plot - A map of samples in which each sample's 
location is denoted with a pie chart, and the proportion 
of a pie chart of each color represents that sample's 
admixture in each layer. Described further in the help 
page for <code>make.admix.pie.plot</code>
</p>
</li>
<li><p> model.fit.CIs - A plot of the sample allelic covariance 
shown with the 95% credible interval of the parametric 
covariance for each entry in the matrix.
</p>
</li>
<li><p> layer.covariances - A plot of the layer-specific 
covariances overlain unto the sample allelic covariance.
</p>
</li>
<li><p> Trace plots - Plots of parameter values over the MCMC.
</p>

<ul>
<li><p> lpd - A plot of the log posterior probability over the MCMC.
</p>
</li>
<li><p> nuggets - A plot of estimates of the nugget parameters 
over the MCMC.
</p>
</li>
<li><p> gamma - A plot of estimates of the gamma parameter 
over the MCMC.
</p>
</li>
<li><p> layer.cov.params - Plots of estimates of the 
layer-specific parameters over the MCMC.
</p>
</li>
<li><p> admix.props - A plot of estimates of the admixture proportions 
over the MCMC.
</p>
</li></ul>

</li></ul>



<h3>Value</h3>

<p>This function has only invisible return values.
</p>

<hr>
<h2 id='conStruct'>Run a conStruct analysis.</h2><span id='topic+conStruct'></span>

<h3>Description</h3>

<p><code>conStruct</code> runs a conStruct analysis of genetic data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conStruct(
  spatial = TRUE,
  K,
  freqs,
  geoDist = NULL,
  coords,
  prefix = "",
  n.chains = 1,
  n.iter = 1000,
  make.figs = TRUE,
  save.files = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conStruct_+3A_spatial">spatial</code></td>
<td>
<p>A logical indicating whether to perform a spatial analysis. 
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="conStruct_+3A_k">K</code></td>
<td>
<p>An <code>integer</code> that indicates the number of layers to be 
included in the analysis.</p>
</td></tr>
<tr><td><code id="conStruct_+3A_freqs">freqs</code></td>
<td>
<p>A <code>matrix</code> of allele frequencies with one column per 
locus and one row per sample.
Missing data should be indicated with <code>NA</code>.</p>
</td></tr>
<tr><td><code id="conStruct_+3A_geodist">geoDist</code></td>
<td>
<p>A full <code>matrix</code> of geographic distance between samples. 
If <code>NULL</code>, user can only run the nonspatial model.</p>
</td></tr>
<tr><td><code id="conStruct_+3A_coords">coords</code></td>
<td>
<p>A <code>matrix</code> giving the longitude and latitude 
(or X and Y coordinates) of the samples.</p>
</td></tr>
<tr><td><code id="conStruct_+3A_prefix">prefix</code></td>
<td>
<p>A character <code>vector</code> giving the prefix to be attached 
to all output files.</p>
</td></tr>
<tr><td><code id="conStruct_+3A_n.chains">n.chains</code></td>
<td>
<p>An integer indicating the number of MCMC chains to be run 
in the analysis. Default is 1.</p>
</td></tr>
<tr><td><code id="conStruct_+3A_n.iter">n.iter</code></td>
<td>
<p>An <code>integer</code> giving the number of iterations each MCMC 
chain is run. Default is 1e3.  If the number of iterations 
is greater than 500, the MCMC is thinned so that the number 
of retained iterations is 500 (before burn-in).</p>
</td></tr>
<tr><td><code id="conStruct_+3A_make.figs">make.figs</code></td>
<td>
<p>A <code>logical</code> value indicating whether to automatically 
make figures once the analysis is complete. Default is 
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="conStruct_+3A_save.files">save.files</code></td>
<td>
<p>A <code>logical</code> value indicating whether to automatically 
save output and intermediate files once the analysis is
complete. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="conStruct_+3A_...">...</code></td>
<td>
<p>Further options to be passed to rstan::sampling (e.g., adapt_delta).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function initiates an analysis that uses  
geographic and genetic relationships between samples 
to estimate sample membership (admixture proportions) across 
a user-specified number of layers.
</p>
<p>This function acts as a wrapper around a STAN model block determined 
by the user-specified model (e.g., a spatial model with 3 layers, 
or a nonspatial model with 5 layers).
User-specified data are checked for appropriate format and consistent dimensions,
then formatted into a <code>data.block</code>,
which is then passed to the STAN model block.
Along with the <code>conStruct.results</code> output described above, 
several objects are saved during the course of a <code>conStruct</code> call
(if <code>save.files=TRUE</code>).
These are the <code>data.block</code>, which contains all data passed to the STAN model block,
<code>model.fit</code>, which is unprocessed results of the STAN run in <code>stanfit</code> format,
and the <code>conStruct.results</code>, which are saved in the course of the function call
in addition to being returned.
If <code>make.figs=TRUE</code>, running <code>conStruct</code> will also generate many output figures, 
which are detailed in the function <code>make.all.the.plots</code> in this package.
</p>


<h3>Value</h3>

<p>This function returns a list with one entry for each chain run 
(specified with <code>n.chains</code>). The entry for each chain is named 
&quot;chain_X&quot; for the Xth chain.  The components of the entries for each 
are detailed below: 
</p>

<ul>
<li> <p><code>posterior</code> gives parameter estimates over the posterior 
distribution of the MCMC.
</p>

<ul>
<li> <p><code>n.iter</code> number of MCMC iterations retained for 
analysis (half of the <code>n.iter</code> argument 
specified in the function call).
</p>
</li>
<li> <p><code>lpd</code> vector of log posterior density over the retained 
MCMC iterations.
</p>
</li>
<li> <p><code>nuggets</code> matrix of estimated nugget parameters with 
one row per MCMC iteration and one column per sample.
</p>
</li>
<li> <p><code>par.cov</code> array of estimated parametric covariance matrices, 
for which the first dimension is the number of MCMC iterations.
</p>
</li>
<li> <p><code>gamma</code> vector of estimated gamma parameter.
</p>
</li>
<li> <p><code>layer.params</code> list summarizing estimates of layer-specific 
parameters. There is one entry for each layer specified, and the 
entry for the kth layer is named &quot;Layer_k&quot;.
</p>

<ul>
<li> <p><code>alpha0</code> vector of estimated alpha0 parameter in the 
kth layer.
</p>
</li>
<li> <p><code>alphaD</code> vector of estimated alphaD parameter in the 
kth layer.
</p>
</li>
<li> <p><code>alpha2</code> vector of estimated alpha2 parameter in the 
kth layer.
</p>
</li>
<li> <p><code>mu</code> vector of estimated mu parameter in the 
kth layer.
</p>
</li>
<li> <p><code>layer.cov</code> vector of estimated layer-specific 
covariance parameter in the kth layer.
</p>
</li></ul>

</li>
<li> <p><code>admix.proportions</code> array of estimated admixture proportions.
The first dimension is the number of MCMC iterations, 
the second is the number of samples, 
and the third is the number of layers.
</p>
</li></ul>

</li>
<li> <p><code>MAP</code> gives point estimates of the parameters listed in the <code>posterior</code>
list described above. Values are indexed at the MCMC iteration 
with the greatest posterior probability.
</p>

<ul>
<li> <p><code>index.iter</code> the iteration of the MCMC with the highest 
posterior probability, which is used to index all parameters 
included in the <code>MAP</code> list
</p>
</li>
<li> <p><code>lpd</code> the greatest value of the posterior probability
</p>
</li>
<li> <p><code>nuggets</code> point estimate of nugget parameters
</p>
</li>
<li> <p><code>par.cov</code> point estimate of parametric covariance
</p>
</li>
<li> <p><code>gamma</code> point estimate of gamma parameter
</p>
</li>
<li> <p><code>layer.params</code> point estimates of all layer-specific parameters 
</p>
</li>
<li> <p><code>admix.proportions</code> point estimates of admixture proportions.
</p>
</li></ul>

</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># load example dataset
data(conStruct.data)

# run example spatial analysis with K=1
	#	
# for this example, make.figs and save.files
#	are set to FALSE, but most users will want them 
#	set to TRUE
my.run &lt;- conStruct(spatial = TRUE,
		 			K = 1,
		 			freqs = conStruct.data$allele.frequencies,
		 			geoDist = conStruct.data$geoDist,
		 			coords = conStruct.data$coords,
		 			prefix = "test",
		 			n.chains = 1,
		 			n.iter = 1e3,
		 			make.figs = FALSE,
		 			save.files = FALSE)

</code></pre>

<hr>
<h2 id='conStruct.data'>Example dataset used in a <code>conStruct</code> analysis</h2><span id='topic+conStruct.data'></span>

<h3>Description</h3>

<p>A simulated dataset containing the allele frequency 
and sampling coordinate data necessary to run a 
<code>conStruct</code> analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conStruct.data
</code></pre>


<h3>Format</h3>

<p>A list with two elements:
</p>

<dl>
<dt>allele.frequencies</dt><dd><p>a matrix with one row for each of 
the 16 samples and one column for each of 10,000 loci, 
giving the frequency of the counted allele at each locus 
in each sample</p>
</dd>
<dt>coords</dt><dd><p>a matrix with one row for each of the 16 samples, 
in the same order as that of the allele frequency matrix, 
and two columns, the first giving the x-coordinate 
(or longitude), the second giving the y-coordinate (or latitude)</p>
</dd>
</dl>


<hr>
<h2 id='data.block'>Example <code>data.block</code> generated by a <code>conStruct</code> analysis</h2><span id='topic+data.block'></span>

<h3>Description</h3>

<p>An example <code>data.block</code> object generated in a <code>conStruct</code> 
analysis from the raw data supplied by the user. This object is 
automatically saved and is used in several subsequent plotting functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data.block
</code></pre>


<h3>Format</h3>

<p>A list with 7 elements:
</p>

<dl>
<dt><code>N</code></dt><dd><p>the number of samples included in the analysis</p>
</dd>
<dt><code>K</code></dt><dd><p>the number of clusters/layers included in the model</p>
</dd>
<dt><code>spatial</code></dt><dd><p>a boolean indicating whether the spatial
model has been specified</p>
</dd>
<dt><code>L</code></dt><dd><p>the number of loci included in the analysis</p>
</dd>
<dt><code>coords</code></dt><dd><p>a matrix with one row for each of the <code>N</code> samples, 
in the same order as that of the <code>obsCov</code> matrix, 
and two columns, the first giving the x-coordinate 
(or longitude), the second giving the y-coordinate (or latitude)</p>
</dd>
<dt><code>obsCov</code></dt><dd><p>the sample allelic covariance matrix, 
in the same order as that of the <code>coords</code> matrix, 
with <code>N</code> rows and columns</p>
</dd>
<dt><code>geoDist</code></dt><dd><p>a matrix of pairwise geographic distance between , 
samples in the same order as that of the <code>obsCov</code>, 
with <code>N</code> rows and columns</p>
</dd>
<dt><code>sd.geoDist</code></dt><dd><p>the standard deviation of the raw geographic 
distance matrix, used for normalizing <code>geoDist</code> within the 
stan model</p>
</dd>
<dt><code>varMeanFreqs</code></dt><dd><p>the variance of the mean allele frequencies, 
averaged over choice of counted allele (passed to the model 
as a prior on the global covariance parameter)</p>
</dd>
</dl>


<hr>
<h2 id='make.admix.pie.plot'>Make admixture pie plot</h2><span id='topic+make.admix.pie.plot'></span>

<h3>Description</h3>

<p><code>make.structure.plot</code> makes a map of pie plots showing admixture 
proportions across layers.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.admix.pie.plot(
  admix.proportions,
  coords,
  layer.colors = NULL,
  radii = 2.7,
  add = FALSE,
  x.lim = NULL,
  y.lim = NULL,
  mar = c(2, 2, 2, 2)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.admix.pie.plot_+3A_admix.proportions">admix.proportions</code></td>
<td>
<p>A <code>matrix</code> of admixture proportions, 
with one row per sample and one column per layer.</p>
</td></tr>
<tr><td><code id="make.admix.pie.plot_+3A_coords">coords</code></td>
<td>
<p><code>matrix</code> of sample coordinates, with one row 
per sample and two columns giving (respectively) the X 
and Y plotting coordinates.</p>
</td></tr>
<tr><td><code id="make.admix.pie.plot_+3A_layer.colors">layer.colors</code></td>
<td>
<p>A <code>vector</code> of colors to be used in 
plotting results for different layers. Users must 
specify one color per layer.  If <code>NULL</code>, the plot 
will use a pre-specified vector of colors.</p>
</td></tr>
<tr><td><code id="make.admix.pie.plot_+3A_radii">radii</code></td>
<td>
<p>A <code>vector</code> of numeric values giving the radii to be 
used in plotting admixture pie plots. If the number of values 
specified is smaller than the number of samples, radii values 
will be recycled across samples. The default is 2.7.</p>
</td></tr>
<tr><td><code id="make.admix.pie.plot_+3A_add">add</code></td>
<td>
<p>A <code>logical</code> value indicating whether to add the pie plots 
to an existing plot.  Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="make.admix.pie.plot_+3A_x.lim">x.lim</code></td>
<td>
<p>A <code>vector</code> giving the x limits of the plot. The default
value is <code>NULL</code>, which indicates that the range of values 
given in the first column of <code>coords</code> should be used.</p>
</td></tr>
<tr><td><code id="make.admix.pie.plot_+3A_y.lim">y.lim</code></td>
<td>
<p>A <code>vector</code> giving the y limits of the plot. The default
value is <code>NULL</code>, which indicates that the range of values 
given in the second column of <code>coords</code> should be used.</p>
</td></tr>
<tr><td><code id="make.admix.pie.plot_+3A_mar">mar</code></td>
<td>
<p>A <code>vector</code> giving the number of lines of margin specified 
for the four sides of the plotting window (passed to <code>par</code>). 
Default value, which is only used if <code>add=FALSE</code>, is 
<code>c(2,2,2,2)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes the output from a conStruct analysis and 
makes a map of pie plots showing admixture proportions across layers, 
where each sample is represented as a pie chart, and the proportion of 
the pie of each color represent that sample's 
admixture proportion in that layer.
</p>


<h3>Value</h3>

<p>This function has only invisible return values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
# make admixture pie plot
make.admix.pie.plot(admix.proportions = admix.props,coords = coords)

</code></pre>

<hr>
<h2 id='make.all.the.plots'>Make output plots</h2><span id='topic+make.all.the.plots'></span>

<h3>Description</h3>

<p><code>make.all.the.plots</code> makes figures from the output from a 
conStruct analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.all.the.plots(conStruct.results, data.block, prefix, layer.colors = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.all.the.plots_+3A_construct.results">conStruct.results</code></td>
<td>
<p>The list output by a 
<code>conStruct</code> run.</p>
</td></tr>
<tr><td><code id="make.all.the.plots_+3A_data.block">data.block</code></td>
<td>
<p>A <code>data.block</code> list saved during a 
<code>conStruct</code> run.</p>
</td></tr>
<tr><td><code id="make.all.the.plots_+3A_prefix">prefix</code></td>
<td>
<p>A character vector to be prepended to all figures.</p>
</td></tr>
<tr><td><code id="make.all.the.plots_+3A_layer.colors">layer.colors</code></td>
<td>
<p>A <code>vector</code> of colors to be used in 
plotting results for different layers. Users must 
specify one color per layer.  If <code>NULL</code>, plots 
will use a pre-specified vector of colors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes the output from a conStruct analysis and 
generates a number of plots for visualizing results and 
diagnosing MCMC performance.
</p>
<p>This function produces a variety of plots that can be 
useful for visualizing results or diagnosing MCMC performance. 
The plots made are by no means exhaustive, and users are 
encouraged to make further plots, or customize these plots as they 
see fit.  For each plot, one file is generated for each MCMC chain 
(specified with the <code>n.chains</code> argument in the function 
<code>conStruct</code>. The plots generated (as .pdf files) are:
</p>

<ul>
<li><p> Structure plot - STRUCTURE-style plot, where each sample 
is represented as a stacked bar plot, and the length of the 
bar plot segments of each color represent that sample's 
admixture proportion in that layer. Described further 
in the help page for <code>make.structure.plot</code>.
</p>
</li>
<li><p> Admixture pie plot - A map of samples in which each sample's 
location is denoted with a pie chart, and the proportion 
of a pie chart of each color represents that sample's 
admixture in each layer. Described further in the help 
page for <code>make.admix.pie.plot</code>
</p>
</li>
<li><p> model.fit.CIs - A plot of the sample allelic covariance 
shown with the 95% credible interval of the parametric 
covariance for each entry in the matrix.
</p>
</li>
<li><p> layer.covariances - A plot of the layer-specific 
covariances overlain unto the sample allelic covariance.
</p>
</li>
<li><p> Trace plots - Plots of parameter values over the MCMC.
</p>

<ul>
<li><p> lpd - A plot of the log posterior probability over the MCMC.
</p>
</li>
<li><p> nuggets - A plot of estimates of the nugget parameters 
over the MCMC.
</p>
</li>
<li><p> gamma - A plot of estimates of the gamma parameter 
over the MCMC.
</p>
</li>
<li><p> layer.cov.params - Plots of estimates of the 
layer-specific parameters over the MCMC.
</p>
</li>
<li><p> admix.props - A plot of estimates of the admixture proportions 
over the MCMC.
</p>
</li></ul>

</li></ul>



<h3>Value</h3>

<p>This function has only invisible return values.
</p>

<hr>
<h2 id='make.structure.plot'>Make STRUCTURE output plot</h2><span id='topic+make.structure.plot'></span>

<h3>Description</h3>

<p><code>make.structure.plot</code> makes a STRUCTURE-style plot from the output from a 
conStruct analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make.structure.plot(
  admix.proportions,
  mar = c(2, 4, 2, 2),
  sample.order = NULL,
  layer.order = NULL,
  sample.names = NULL,
  sort.by = NULL,
  layer.colors = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make.structure.plot_+3A_admix.proportions">admix.proportions</code></td>
<td>
<p>A <code>matrix</code> of admixture proportions, 
with one row per sample and one column per layer.</p>
</td></tr>
<tr><td><code id="make.structure.plot_+3A_mar">mar</code></td>
<td>
<p>A <code>vector</code> of plotting margins passed to <code>par</code>.
Default is <code>c(2,4,2,2)</code>, which tends to look good.</p>
</td></tr>
<tr><td><code id="make.structure.plot_+3A_sample.order">sample.order</code></td>
<td>
<p>A <code>vector</code> giving the order in which sample 
admixture proportions are to be plotted, left to right.  If 
<code>NULL</code>, samples are plotted in the order they occur in 
<code>admix.proportions</code>.</p>
</td></tr>
<tr><td><code id="make.structure.plot_+3A_layer.order">layer.order</code></td>
<td>
<p>A <code>vector</code> giving the order in which layers 
are plotted, bottom to top. If <code>NULL</code>, layers are plotted 
in the order they occur in <code>admix.proportions</code>.</p>
</td></tr>
<tr><td><code id="make.structure.plot_+3A_sample.names">sample.names</code></td>
<td>
<p>Vector of names to be plotted under each sample's 
admixture proportion bar plot. The index of a sample's name 
should be the same as the index of the sample's row in 
<code>admix.proportions</code>. If <code>NULL</code>, no names 
are printed.</p>
</td></tr>
<tr><td><code id="make.structure.plot_+3A_sort.by">sort.by</code></td>
<td>
<p>An <code>integer</code> giving the column index of the <code>admix.proportions</code> 
matrix to be used in determining sample plotting order.  If specified, 
samples are plotted from left to right in increasing order of their 
membership in that layer.  If <code>NULL</code>, samples are plotted 
in the order they occur in <code>admix.proportions</code>.</p>
</td></tr>
<tr><td><code id="make.structure.plot_+3A_layer.colors">layer.colors</code></td>
<td>
<p>A <code>vector</code> of colors to be used in plotting 
results for different layers. Users must specify one 
color per layer.  If <code>NULL</code>, the plot will use 
a pre-specified vector of colors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes the output from a conStruct analysis and 
makes a STRUCTURE-style plot, where each sample 
is represented as a stacked bar plot, and the length of the 
bar plot segments of each color represent that sample's 
admixture proportion in that layer.
</p>


<h3>Value</h3>

<p>This function has only invisible return values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>	
# make STRUCTURE-style plot
	make.structure.plot(admix.proportions = admix.props)

# make STRUCTURE-style plot, sorted by membership in layer 1
make.structure.plot(admix.proportions = admix.props,sort.by=1) 

</code></pre>

<hr>
<h2 id='match.layers.x.runs'>Match layers up across independent conStruct runs</h2><span id='topic+match.layers.x.runs'></span>

<h3>Description</h3>

<p><code>match.layers.x.runs</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match.layers.x.runs(admix.mat1, admix.mat2, admix.mat1.order = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match.layers.x.runs_+3A_admix.mat1">admix.mat1</code></td>
<td>
<p>A <code>matrix</code> of estimated admixture proportions
from the original <code>conStruct</code> analysis, with one row 
per sample and one column per layer.</p>
</td></tr>
<tr><td><code id="match.layers.x.runs_+3A_admix.mat2">admix.mat2</code></td>
<td>
<p>A <code>matrix</code> of estimated admixture proportions
from a second <code>conStruct</code> analysis, with one row per 
sample and one column per layer, for which the 
layer order is desired. Must have equal or greater number 
of layers to <code>admix.mat1</code>.</p>
</td></tr>
<tr><td><code id="match.layers.x.runs_+3A_admix.mat1.order">admix.mat1.order</code></td>
<td>
<p>An optional <code>vector</code> giving the
order in which the layers of <code>admix.mat1</code> are read.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes the results of two independent
<code>conStruct</code> analyses and compares them to identify 
which layers in a new analysis correspond most closely 
to the layers from an original analysis.
</p>
<p>This function compares admixture proportions in layers across 
independent <code>conStruct</code> runs, and compares between them to 
identify the layers in <code>admix.mat2</code> that correspond most 
closely to those in <code>admix.mat1</code>. It then returns a vector 
giving an ordering of <code>admix.mat2</code> that matches up the order
of the layers that correspond to each other.  This can be useful 
for:
</p>

<ol>
<li><p> Dealing with &quot;label switching&quot; across independent runs 
with the same number of layers; 
</p>
</li>
<li><p> Plotting results from independent runs with different 
numbers of layers using consistent colors
(e.g., the &quot;blue&quot; layer shows up as blue even as 
<code>K</code> increases); 
</p>
</li>
<li><p> Examining results for multimodality (i.e., multiple 
distinct solutions with qualitatively different patterns
of membership across layers).
</p>
</li></ol>

<p>The <code>admix.mat1.order</code> argument can be useful when running 
this function to sync up plotting colors/order across the output 
of more than two <code>conStruct</code> runs.
</p>


<h3>Value</h3>

<p>This function returns a <code>vector</code> giving the ordering 
of the layers in <code>admix.mat2</code> that maximizes 
similarity between <code>admix.mat1</code> and re-ordered 
<code>admix.mat2</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# compare the estimated admixture proportions from 
# two different conStruct runs to determine which 
# layers in one run correspond to those in the other
match.layers.x.runs(admix.props1,admix.props2)

</code></pre>

<hr>
<h2 id='print.conStruct.results'>An S3 print method for class conStruct.results</h2><span id='topic+print.conStruct.results'></span>

<h3>Description</h3>

<p>An S3 print method for class conStruct.results
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'conStruct.results'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.conStruct.results_+3A_x">x</code></td>
<td>
<p>an object of class <code>conStruct.results</code></p>
</td></tr>
<tr><td><code id="print.conStruct.results_+3A_...">...</code></td>
<td>
<p>further options to be passed to <code>print</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>prints a top-level summary of the conStruct.results, returns nothing
</p>

<hr>
<h2 id='print.data.block'>An S3 print method for class data.block</h2><span id='topic+print.data.block'></span>

<h3>Description</h3>

<p>An S3 print method for class data.block
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'data.block'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.data.block_+3A_x">x</code></td>
<td>
<p>an object of class <code>data.block</code></p>
</td></tr>
<tr><td><code id="print.data.block_+3A_...">...</code></td>
<td>
<p>further options to be passed to <code>print</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>prints a top-level summary of the data.block, returns nothing
</p>

<hr>
<h2 id='print.freq.data'>An S3 print method for class freq.data</h2><span id='topic+print.freq.data'></span>

<h3>Description</h3>

<p>An S3 print method for class freq.data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'freq.data'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.freq.data_+3A_x">x</code></td>
<td>
<p>an object of class <code>freq.data</code></p>
</td></tr>
<tr><td><code id="print.freq.data_+3A_...">...</code></td>
<td>
<p>further options to be passed to <code>print</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>prints a top-level summary of the freq.data, returns nothing
</p>

<hr>
<h2 id='print.layer.params'>An S3 print method for class layer.params</h2><span id='topic+print.layer.params'></span>

<h3>Description</h3>

<p>An S3 print method for class layer.params
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'layer.params'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.layer.params_+3A_x">x</code></td>
<td>
<p>an object of class <code>layer.params</code></p>
</td></tr>
<tr><td><code id="print.layer.params_+3A_...">...</code></td>
<td>
<p>further options to be passed to <code>print</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>prints a top-level summary of the layer.params, returns nothing
</p>

<hr>
<h2 id='structure2conStruct'>Convert a dataset from STRUCTURE to conStruct format</h2><span id='topic+structure2conStruct'></span>

<h3>Description</h3>

<p><code>structure2conStruct</code> converts a STRUCTURE dataset 
to conStruct format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>structure2conStruct(
  infile,
  onerowperind,
  start.loci,
  start.samples = 1,
  missing.datum,
  outfile
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="structure2conStruct_+3A_infile">infile</code></td>
<td>
<p>The name and path of the file in STRUCTURE format 
to be converted to <code>conStruct</code> format.</p>
</td></tr>
<tr><td><code id="structure2conStruct_+3A_onerowperind">onerowperind</code></td>
<td>
<p>Indicates whether the file format has 
one row per individual (<code>TRUE</code>) or two rows per 
individual (<code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="structure2conStruct_+3A_start.loci">start.loci</code></td>
<td>
<p>The index of the first column in the dataset 
that contains genotype data.</p>
</td></tr>
<tr><td><code id="structure2conStruct_+3A_start.samples">start.samples</code></td>
<td>
<p>The index of the first row in the dataset 
that contains genotype data (e.g., after any headers). 
Default value is 1.</p>
</td></tr>
<tr><td><code id="structure2conStruct_+3A_missing.datum">missing.datum</code></td>
<td>
<p>The character or value used to denote 
missing data in the STRUCTURE dataset (often 0 or -9).</p>
</td></tr>
<tr><td><code id="structure2conStruct_+3A_outfile">outfile</code></td>
<td>
<p>The name and path of the file containing the 
<code>conStruct</code> formatted dataset to be generated 
by this function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function takes a population genetics dataset in 
STRUCTURE format and converts it to conStruct format. 
The STRUCTURE file can have one row per individual 
and two columns per locus, or one column and two rows 
per individual. It can only contain bi-allelic SNPs.
Missing data is acceptable, but must be indicated with 
a single value throughout the dataset.
</p>
<p>This function takes a STRUCTURE format data file and 
converts it to a <code>conStruct</code> format data file.
This function can only be applied to diploid organisms.
The STRUCTURE data file must be a plain text file. 
If there is extraneous text or column headers before the data 
starts, those extra lines should be deleted by hand or 
taken into account via the <code>start.samples</code> argument.
</p>
<p>The STRUCTURE dataset can either be in the ONEROWPERIND=1 
file format, with one row per individual and two columns 
per locus, or the ONEROWPERIND=0 format, with two rows and 
one column per individual. The first column of the STRUCTURE 
dataset should be individual names. There may be any number 
of other columns that contain non-genotype information before 
the first column that contains genotype data, but there can 
be no extraneous columns at the end of the dataset, after the 
genotype data.
</p>
<p>The genotype data must be bi-allelic 
single nucleotide polymorphisms (SNPs). Applying this function 
to datasets with more than two alleles per locus may result in 
cryptic failure. For more details, see the <code>format-data</code> 
vignette.
</p>


<h3>Value</h3>

<p>This function returns an allele frequency data matrix 
that can be used as the <code>freqs</code> argument in a conStruct 
analysis run using <code><a href="#topic+conStruct">conStruct</a></code>.  It also saves 
this object as an .RData file so that it can be used in 
future analyses.
</p>

<hr>
<h2 id='x.validation'>Run a conStruct cross-validation analysis</h2><span id='topic+x.validation'></span>

<h3>Description</h3>

<p><code>x.validation</code> runs a conStruct cross-validation analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x.validation(
  train.prop = 0.9,
  n.reps,
  K,
  freqs = NULL,
  data.partitions = NULL,
  geoDist,
  coords,
  prefix,
  n.iter,
  make.figs = FALSE,
  save.files = FALSE,
  parallel = FALSE,
  n.nodes = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="x.validation_+3A_train.prop">train.prop</code></td>
<td>
<p>A numeric value between 0 and 1 that gives 
the proportions of the data to be used in the 
training partition of the analysis. Default is 0.9.</p>
</td></tr>
<tr><td><code id="x.validation_+3A_n.reps">n.reps</code></td>
<td>
<p>An <code>integer</code> giving the number of cross-
validation replicates to be run.</p>
</td></tr>
<tr><td><code id="x.validation_+3A_k">K</code></td>
<td>
<p>A numeric <code>vector</code> giving the numbers of layers 
to be tested in each cross-validation replicate.
E.g., <code>K=1:7</code>.</p>
</td></tr>
<tr><td><code id="x.validation_+3A_freqs">freqs</code></td>
<td>
<p>A <code>matrix</code> of allele frequencies with one column per 
locus and one row per sample.
Missing data should be indicated with <code>NA</code>.</p>
</td></tr>
<tr><td><code id="x.validation_+3A_data.partitions">data.partitions</code></td>
<td>
<p>A list with one element for each desired 
cross-validation replicate. This argument can be specified 
instead of the <code>freqs</code> argument if the user wants to 
provide their own data partitions for model training and testing.
See the model comparison vignette for details on what this 
should look like.</p>
</td></tr>
<tr><td><code id="x.validation_+3A_geodist">geoDist</code></td>
<td>
<p>A <code>matrix</code> of geographic distance between samples. 
If <code>NULL</code>, user can only run the nonspatial model.</p>
</td></tr>
<tr><td><code id="x.validation_+3A_coords">coords</code></td>
<td>
<p>A <code>matrix</code> giving the longitude and latitude 
(or X and Y coordinates) of the samples.</p>
</td></tr>
<tr><td><code id="x.validation_+3A_prefix">prefix</code></td>
<td>
<p>A character <code>vector</code> giving the prefix to be attached 
to all output files.</p>
</td></tr>
<tr><td><code id="x.validation_+3A_n.iter">n.iter</code></td>
<td>
<p>An <code>integer</code> giving the number of iterations each MCMC 
chain is run. Default is 1e3.  If the number of iterations 
is greater than 500, the MCMC is thinned so that the number 
of retained iterations is 500 (before burn-in).</p>
</td></tr>
<tr><td><code id="x.validation_+3A_make.figs">make.figs</code></td>
<td>
<p>A <code>logical</code> value indicating whether to automatically 
make figures during the course of the cross-validation analysis. 
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="x.validation_+3A_save.files">save.files</code></td>
<td>
<p>A <code>logical</code> value indicating whether to automatically 
save output and intermediate files once the analysis is
complete. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="x.validation_+3A_parallel">parallel</code></td>
<td>
<p>A <code>logical</code> value indicating whether or not to run the 
different cross-validation replicates in parallel. Default is <code>FALSE</code>.
For more details on how to set up runs in parallel, see the model 
comparison vignette.</p>
</td></tr>
<tr><td><code id="x.validation_+3A_n.nodes">n.nodes</code></td>
<td>
<p>Number of nodes to run parallel analyses on. Default is 
<code>NULL</code>. Ignored if <code>parallel</code> is <code>FALSE</code>. For more details 
in how to set up runs in parallel, see the model comparison vignette.</p>
</td></tr>
<tr><td><code id="x.validation_+3A_...">...</code></td>
<td>
<p>Further options to be passed to rstan::sampling (e.g., adapt_delta).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function initiates a cross-validation analysis that 
uses Monte Carlo cross-validation to determine the statistical 
support for models with different numbers of layers or 
with and without a spatial component.
</p>


<h3>Value</h3>

<p>This function returns (and also saves as a .Robj) a <code>list</code> 
containing the standardized results of the cross-validation analysis
across replicates.  For each replicate, the function returns 
a list with the following elements:
</p>

<ul>
<li> <p><code>sp</code> - the mean of the standardized log likelihoods of the 
&quot;testing&quot; data partition of that replicate for the spatial model for
each value of K specified in <code>K</code>.
</p>
</li>
<li> <p><code>nsp</code> - the mean of the standardized log likelihoods of the 
&quot;testing&quot; data partitions of that replicate for the nonspatial model for
each value of K specified in <code>K</code>.
</p>
</li></ul>

<p>In addition, this function saves two text files containing the standardized 
cross-validation results for the spatial and nonspatial results 
(prefix_sp_xval_results.txt and prefix_nsp_xval_results.txt, respectively).
These values are written as matrices for user convenience; each column is 
a cross-validation replicate, and each row gives the result for a value of 
<code>K</code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
