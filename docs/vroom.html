<!DOCTYPE html><html><head><title>Help for package vroom</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {vroom}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#vroom-package'><p>vroom: Read and Write Rectangular Text Data Quickly</p></a></li>
<li><a href='#as.col_spec'><p>Coerce to a column specification</p></a></li>
<li><a href='#cols'><p>Create column specification</p></a></li>
<li><a href='#cols_condense'><p>Examine the column specifications for a data frame</p></a></li>
<li><a href='#date_names'><p>Create or retrieve date names</p></a></li>
<li><a href='#gen_tbl'><p>Generate a random tibble</p></a></li>
<li><a href='#generators'><p>Generate individual vectors of the types supported by vroom</p></a></li>
<li><a href='#guess_type'><p>Guess the type of a vector</p></a></li>
<li><a href='#locale'><p>Create locales</p></a></li>
<li><a href='#output_column'><p>Preprocess column for output</p></a></li>
<li><a href='#problems'><p>Retrieve parsing problems</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#vroom'><p>Read a delimited file into a tibble</p></a></li>
<li><a href='#vroom_altrep'><p>Show which column types are using Altrep</p></a></li>
<li><a href='#vroom_altrep_opts'><p>Show which column types are using Altrep</p></a></li>
<li><a href='#vroom_example'><p>Get path to vroom examples</p></a></li>
<li><a href='#vroom_format'><p>Convert a data frame to a delimited string</p></a></li>
<li><a href='#vroom_fwf'><p>Read a fixed width file into a tibble</p></a></li>
<li><a href='#vroom_lines'><p>Read lines from a file</p></a></li>
<li><a href='#vroom_progress'><p>Determine whether progress bars should be shown</p></a></li>
<li><a href='#vroom_str'><p>Structure of objects</p></a></li>
<li><a href='#vroom_write'><p>Write a data frame to a delimited file</p></a></li>
<li><a href='#vroom_write_lines'><p>Write lines to a file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Read and Write Rectangular Text Data Quickly</td>
</tr>
<tr>
<td>Version:</td>
<td>1.6.5</td>
</tr>
<tr>
<td>Description:</td>
<td>The goal of 'vroom' is to read and write data (like 'csv',
    'tsv' and 'fwf') quickly. When reading it uses a quick initial
    indexing step, then reads the values lazily , so only the data you
    actually use needs to be read.  The writer formats the data in
    parallel and writes to disk asynchronously from formatting.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://vroom.r-lib.org">https://vroom.r-lib.org</a>, <a href="https://github.com/tidyverse/vroom">https://github.com/tidyverse/vroom</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/tidyverse/vroom/issues">https://github.com/tidyverse/vroom/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6)</td>
</tr>
<tr>
<td>Imports:</td>
<td>bit64, cli (&ge; 3.2.0), crayon, glue, hms, lifecycle (&ge;
1.0.3), methods, rlang (&ge; 0.4.2), stats, tibble (&ge; 2.0.0),
tidyselect, tzdb (&ge; 0.1.1), vctrs (&ge; 0.2.0), withr</td>
</tr>
<tr>
<td>Suggests:</td>
<td>archive, bench (&ge; 1.1.0), covr, curl, dplyr, forcats, fs,
ggplot2, knitr, patchwork, prettyunits, purrr, rmarkdown,
rstudioapi, scales, spelling, testthat (&ge; 2.1.0), tidyr,
utils, waldo, xml2</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>cpp11 (&ge; 0.2.0), progress (&ge; 1.2.1), tzdb (&ge; 0.1.1)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>nycflights13, tidyverse/tidytemplate</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>false</td>
</tr>
<tr>
<td>Copyright:</td>
<td>file COPYRIGHTS</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3.9000</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-05 16:46:59 UTC; jenny</td>
</tr>
<tr>
<td>Author:</td>
<td>Jim Hester <a href="https://orcid.org/0000-0002-2739-7082"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Hadley Wickham <a href="https://orcid.org/0000-0003-4757-117X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Jennifer Bryan <a href="https://orcid.org/0000-0002-6983-2759"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Shelby Bearrows [ctb],
  https://github.com/mandreyel/ [cph] (mio library),
  Jukka Jylänki [cph] (grisu3 implementation),
  Mikkel Jørgensen [cph] (grisu3 implementation),
  Posit Software, PBC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jennifer Bryan &lt;jenny@posit.co&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-05 23:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='vroom-package'>vroom: Read and Write Rectangular Text Data Quickly</h2><span id='topic+vroom-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>The goal of 'vroom' is to read and write data (like 'csv', 'tsv' and 'fwf') quickly. When reading it uses a quick initial indexing step, then reads the values lazily , so only the data you actually use needs to be read. The writer formats the data in parallel and writes to disk asynchronously from formatting.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Jennifer Bryan <a href="mailto:jenny@posit.co">jenny@posit.co</a> (<a href="https://orcid.org/0000-0002-6983-2759">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Jim Hester (<a href="https://orcid.org/0000-0002-2739-7082">ORCID</a>)
</p>
</li>
<li><p> Hadley Wickham <a href="mailto:hadley@posit.co">hadley@posit.co</a> (<a href="https://orcid.org/0000-0003-4757-117X">ORCID</a>)
</p>
</li></ul>

<p>Other contributors:
</p>

<ul>
<li><p> Shelby Bearrows [contributor]
</p>
</li>
<li><p> https://github.com/mandreyel/ (mio library) [copyright holder]
</p>
</li>
<li><p> Jukka Jylänki (grisu3 implementation) [copyright holder]
</p>
</li>
<li><p> Mikkel Jørgensen (grisu3 implementation) [copyright holder]
</p>
</li>
<li><p> Posit Software, PBC [copyright holder, funder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://vroom.r-lib.org">https://vroom.r-lib.org</a>
</p>
</li>
<li> <p><a href="https://github.com/tidyverse/vroom">https://github.com/tidyverse/vroom</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/tidyverse/vroom/issues">https://github.com/tidyverse/vroom/issues</a>
</p>
</li></ul>


<hr>
<h2 id='as.col_spec'>Coerce to a column specification</h2><span id='topic+as.col_spec'></span>

<h3>Description</h3>

<p>This is most useful for generating a specification using the short form or coercing from a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.col_spec(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.col_spec_+3A_x">x</code></td>
<td>
<p>Input object</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>as.col_spec("cccnnn")
</code></pre>

<hr>
<h2 id='cols'>Create column specification</h2><span id='topic+cols'></span><span id='topic+col_types'></span><span id='topic+cols_only'></span><span id='topic+col_logical'></span><span id='topic+col_integer'></span><span id='topic+col_big_integer'></span><span id='topic+col_double'></span><span id='topic+col_character'></span><span id='topic+col_skip'></span><span id='topic+col_number'></span><span id='topic+col_guess'></span><span id='topic+col_factor'></span><span id='topic+col_datetime'></span><span id='topic+col_date'></span><span id='topic+col_time'></span>

<h3>Description</h3>

<p><code>cols()</code> includes all columns in the input data, guessing the column types
as the default. <code>cols_only()</code> includes only the columns you explicitly
specify, skipping the rest.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cols(..., .default = col_guess(), .delim = NULL)

cols_only(...)

col_logical(...)

col_integer(...)

col_big_integer(...)

col_double(...)

col_character(...)

col_skip(...)

col_number(...)

col_guess(...)

col_factor(levels = NULL, ordered = FALSE, include_na = FALSE, ...)

col_datetime(format = "", ...)

col_date(format = "", ...)

col_time(format = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cols_+3A_...">...</code></td>
<td>
<p>Either column objects created by <code style="white-space: pre;">&#8288;col_*()&#8288;</code>, or their abbreviated
character names (as described in the <code>col_types</code> argument of
<code><a href="#topic+vroom">vroom()</a></code>). If you're only overriding a few columns, it's
best to refer to columns by name. If not named, the column types must match
the column names exactly. In <code style="white-space: pre;">&#8288;col_*()&#8288;</code> functions these are stored in the
object.</p>
</td></tr>
<tr><td><code id="cols_+3A_.default">.default</code></td>
<td>
<p>Any named columns not explicitly overridden in <code>...</code>
will be read with this column type.</p>
</td></tr>
<tr><td><code id="cols_+3A_.delim">.delim</code></td>
<td>
<p>The delimiter to use when parsing. If the <code>delim</code> argument
used in the call to <code>vroom()</code> it takes precedence over the one specified in
<code>col_types</code>.</p>
</td></tr>
<tr><td><code id="cols_+3A_levels">levels</code></td>
<td>
<p>Character vector of the allowed levels. When <code>levels = NULL</code>
(the default), <code>levels</code> are discovered from the unique values of <code>x</code>, in
the order in which they appear in <code>x</code>.</p>
</td></tr>
<tr><td><code id="cols_+3A_ordered">ordered</code></td>
<td>
<p>Is it an ordered factor?</p>
</td></tr>
<tr><td><code id="cols_+3A_include_na">include_na</code></td>
<td>
<p>If <code>TRUE</code> and <code>x</code> contains at least one <code>NA</code>, then <code>NA</code>
is included in the levels of the constructed factor.</p>
</td></tr>
<tr><td><code id="cols_+3A_format">format</code></td>
<td>
<p>A format specification, as described below. If set to &quot;&quot;,
date times are parsed as ISO8601, dates and times used the date and
time formats specified in the <code><a href="readr.html#topic+locale">locale()</a></code>.
</p>
<p>Unlike <code><a href="base.html#topic+strptime">strptime()</a></code>, the format specification must match
the complete string.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The available specifications are: (long names in quotes and string abbreviations in brackets)</p>

<table>
<tr>
 <td style="text-align: left;">
   function </td><td style="text-align: left;"> long name </td><td style="text-align: left;"> short name </td><td style="text-align: left;"> description </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>col_logical()</code> </td><td style="text-align: left;"> "logical" </td><td style="text-align: left;"> "l" </td><td style="text-align: left;"> Logical values containing only <code>T</code>, <code>F</code>, <code>TRUE</code> or <code>FALSE</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>col_integer()</code> </td><td style="text-align: left;"> "integer" </td><td style="text-align: left;"> "i" </td><td style="text-align: left;"> Integer numbers. </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>col_big_integer()</code> </td><td style="text-align: left;"> "big_integer" </td><td style="text-align: left;"> "I" </td><td style="text-align: left;"> Big Integers (64bit), requires the <code>bit64</code> package. </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>col_double()</code> </td><td style="text-align: left;"> "double", "numeric" </td><td style="text-align: left;"> "d" </td><td style="text-align: left;"> 64-bit double floating point numbers. </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>col_character()</code> </td><td style="text-align: left;"> "character" </td><td style="text-align: left;"> "c" </td><td style="text-align: left;"> Character string data. </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>col_factor(levels, ordered)</code> </td><td style="text-align: left;"> "factor" </td><td style="text-align: left;"> "f" </td><td style="text-align: left;"> A fixed set of values. </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>col_date(format = "")</code> </td><td style="text-align: left;"> "date" </td><td style="text-align: left;"> "D" </td><td style="text-align: left;"> Calendar dates formatted with the locale's <code>date_format</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>col_time(format = "")</code> </td><td style="text-align: left;"> "time" </td><td style="text-align: left;"> "t" </td><td style="text-align: left;"> Times formatted with the locale's <code>time_format</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>col_datetime(format = "")</code> </td><td style="text-align: left;"> "datetime", "POSIXct" </td><td style="text-align: left;"> "T" </td><td style="text-align: left;"> ISO8601 date times. </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>col_number()</code> </td><td style="text-align: left;"> "number" </td><td style="text-align: left;"> "n" </td><td style="text-align: left;"> Human readable numbers containing the <code>grouping_mark</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>col_skip()</code> </td><td style="text-align: left;"> "skip", "NULL" </td><td style="text-align: left;"> "_", "-" </td><td style="text-align: left;"> Skip and don't import this column. </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>col_guess()</code> </td><td style="text-align: left;"> "guess", "NA" </td><td style="text-align: left;"> "?" </td><td style="text-align: left;"> Parse using the "best" guessed type based on the input. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Examples</h3>

<pre><code class='language-R'>cols(a = col_integer())
cols_only(a = col_integer())

# You can also use the standard abbreviations
cols(a = "i")
cols(a = "i", b = "d", c = "_")

# Or long names (like utils::read.csv)
cols(a = "integer", b = "double", c = "skip")

# You can also use multiple sets of column definitions by combining
# them like so:

t1 &lt;- cols(
  column_one = col_integer(),
  column_two = col_number())

t2 &lt;- cols(
 column_three = col_character())

t3 &lt;- t1
t3$cols &lt;- c(t1$cols, t2$cols)
t3
</code></pre>

<hr>
<h2 id='cols_condense'>Examine the column specifications for a data frame</h2><span id='topic+cols_condense'></span><span id='topic+spec'></span>

<h3>Description</h3>

<p><code>cols_condense()</code> takes a spec object and condenses its definition by setting
the default column type to the most frequent type and only listing columns
with a different type.
</p>
<p><code>spec()</code> extracts the full column specification from a tibble
created by readr.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cols_condense(x)

spec(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cols_condense_+3A_x">x</code></td>
<td>
<p>The data frame object to extract from</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A col_spec object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- vroom(vroom_example("mtcars.csv"))
s &lt;- spec(df)
s

cols_condense(s)
</code></pre>

<hr>
<h2 id='date_names'>Create or retrieve date names</h2><span id='topic+date_names'></span><span id='topic+date_names_lang'></span><span id='topic+date_names_langs'></span>

<h3>Description</h3>

<p>When parsing dates, you often need to know how weekdays of the week and
months are represented as text. This pair of functions allows you to either
create your own, or retrieve from a standard list. The standard list is
derived from ICU (<code style="white-space: pre;">&#8288;https://site.icu-project.org&#8288;</code>) via the <em>stringi</em> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>date_names(mon, mon_ab = mon, day, day_ab = day, am_pm = c("AM", "PM"))

date_names_lang(language)

date_names_langs()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="date_names_+3A_mon">mon</code>, <code id="date_names_+3A_mon_ab">mon_ab</code></td>
<td>
<p>Full and abbreviated month names.</p>
</td></tr>
<tr><td><code id="date_names_+3A_day">day</code>, <code id="date_names_+3A_day_ab">day_ab</code></td>
<td>
<p>Full and abbreviated week day names. Starts with Sunday.</p>
</td></tr>
<tr><td><code id="date_names_+3A_am_pm">am_pm</code></td>
<td>
<p>Names used for AM and PM.</p>
</td></tr>
<tr><td><code id="date_names_+3A_language">language</code></td>
<td>
<p>A BCP 47 locale, made up of a language and a region,
e.g. <code>"en_US"</code> for American English. See <code>date_names_langs()</code>
for a complete list of available locales.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>date_names_lang("en")
date_names_lang("ko")
date_names_lang("fr")
</code></pre>

<hr>
<h2 id='gen_tbl'>Generate a random tibble</h2><span id='topic+gen_tbl'></span>

<h3>Description</h3>

<p>This is useful for benchmarking, but also for bug reports when you cannot
share the real dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_tbl(
  rows,
  cols = NULL,
  col_types = NULL,
  locale = default_locale(),
  missing = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_tbl_+3A_rows">rows</code></td>
<td>
<p>Number of rows to generate</p>
</td></tr>
<tr><td><code id="gen_tbl_+3A_cols">cols</code></td>
<td>
<p>Number of columns to generate, if <code>NULL</code> this is derived from <code>col_types</code>.</p>
</td></tr>
<tr><td><code id="gen_tbl_+3A_col_types">col_types</code></td>
<td>
<p>One of <code>NULL</code>, a <code><a href="#topic+cols">cols()</a></code> specification, or
a string.
</p>
<p>If <code>NULL</code>, all column types will be imputed from <code>guess_max</code> rows
on the input interspersed throughout the file. This is convenient (and
fast), but not robust. If the imputation fails, you'll need to increase
the <code>guess_max</code> or supply the correct types yourself.
</p>
<p>Column specifications created by <code><a href="base.html#topic+list">list()</a></code> or <code><a href="#topic+cols">cols()</a></code> must contain
one column specification for each column. If you only want to read a
subset of the columns, use <code><a href="#topic+cols_only">cols_only()</a></code>.
</p>
<p>Alternatively, you can use a compact string representation where each
character represents one column:
</p>

<ul>
<li><p> c = character
</p>
</li>
<li><p> i = integer
</p>
</li>
<li><p> n = number
</p>
</li>
<li><p> d = double
</p>
</li>
<li><p> l = logical
</p>
</li>
<li><p> f = factor
</p>
</li>
<li><p> D = date
</p>
</li>
<li><p> T = date time
</p>
</li>
<li><p> t = time
</p>
</li>
<li><p> ? = guess
</p>
</li>
<li><p> _ or - = skip
</p>
<p>By default, reading a file without a column specification will print a
message showing what <code>readr</code> guessed they were. To remove this message,
set <code>show_col_types = FALSE</code> or set <code>options(readr.show_col_types = FALSE)</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="gen_tbl_+3A_locale">locale</code></td>
<td>
<p>The locale controls defaults that vary from place to place.
The default locale is US-centric (like R), but you can use
<code><a href="#topic+locale">locale()</a></code> to create your own locale that controls things like
the default time zone, encoding, decimal mark, big mark, and day/month
names.</p>
</td></tr>
<tr><td><code id="gen_tbl_+3A_missing">missing</code></td>
<td>
<p>The percentage (from 0 to 1) of missing data to use</p>
</td></tr>
</table>


<h3>Details</h3>

<p>There is also a family of functions to generate individual vectors of each
type.
</p>


<h3>See Also</h3>

<p><a href="#topic+generators">generators</a> to generate individual vectors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># random 10 x 5 table with random column types
rand_tbl &lt;- gen_tbl(10, 5)
rand_tbl

# all double 25 x 4 table
dbl_tbl &lt;- gen_tbl(25, 4, col_types = "dddd")
dbl_tbl

# Use the dots in long form column types to change the random function and options
types &lt;- rep(times = 4, list(col_double(f = stats::runif, min = -10, max = 25)))
types
dbl_tbl2 &lt;- gen_tbl(25, 4, col_types = types)
dbl_tbl2
</code></pre>

<hr>
<h2 id='generators'>Generate individual vectors of the types supported by vroom</h2><span id='topic+generators'></span><span id='topic+gen_character'></span><span id='topic+gen_double'></span><span id='topic+gen_number'></span><span id='topic+gen_integer'></span><span id='topic+gen_factor'></span><span id='topic+gen_time'></span><span id='topic+gen_date'></span><span id='topic+gen_datetime'></span><span id='topic+gen_logical'></span><span id='topic+gen_name'></span>

<h3>Description</h3>

<p>Generate individual vectors of the types supported by vroom
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_character(n, min = 5, max = 25, values = c(letters, LETTERS, 0:9), ...)

gen_double(n, f = stats::rnorm, ...)

gen_number(n, f = stats::rnorm, ...)

gen_integer(n, min = 1L, max = .Machine$integer.max, prob = NULL, ...)

gen_factor(
  n,
  levels = NULL,
  ordered = FALSE,
  num_levels = gen_integer(1L, 1L, 25L),
  ...
)

gen_time(n, min = 0, max = hms::hms(days = 1), fractional = FALSE, ...)

gen_date(n, min = as.Date("2001-01-01"), max = as.Date("2021-01-01"), ...)

gen_datetime(
  n,
  min = as.POSIXct("2001-01-01"),
  max = as.POSIXct("2021-01-01"),
  tz = "UTC",
  ...
)

gen_logical(n, ...)

gen_name(n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generators_+3A_n">n</code></td>
<td>
<p>The size of the vector to generate</p>
</td></tr>
<tr><td><code id="generators_+3A_min">min</code></td>
<td>
<p>The minimum range for the vector</p>
</td></tr>
<tr><td><code id="generators_+3A_max">max</code></td>
<td>
<p>The maximum range for the vector</p>
</td></tr>
<tr><td><code id="generators_+3A_values">values</code></td>
<td>
<p>The explicit values to use.</p>
</td></tr>
<tr><td><code id="generators_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to internal generation functions</p>
</td></tr>
<tr><td><code id="generators_+3A_f">f</code></td>
<td>
<p>The random function to use.</p>
</td></tr>
<tr><td><code id="generators_+3A_prob">prob</code></td>
<td>
<p>a vector of probability weights for obtaining the elements
of the vector being sampled.</p>
</td></tr>
<tr><td><code id="generators_+3A_levels">levels</code></td>
<td>
<p>The explicit levels to use, if <code>NULL</code> random levels are generated using <code><a href="#topic+gen_name">gen_name()</a></code>.</p>
</td></tr>
<tr><td><code id="generators_+3A_ordered">ordered</code></td>
<td>
<p>Should the factors be ordered factors?</p>
</td></tr>
<tr><td><code id="generators_+3A_num_levels">num_levels</code></td>
<td>
<p>The number of factor levels to generate</p>
</td></tr>
<tr><td><code id="generators_+3A_fractional">fractional</code></td>
<td>
<p>Whether to generate times with fractional seconds</p>
</td></tr>
<tr><td><code id="generators_+3A_tz">tz</code></td>
<td>
<p>The timezone to use for dates</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># characters
gen_character(4)

# factors
gen_factor(4)

# logical
gen_logical(4)

# numbers
gen_double(4)
gen_integer(4)

# temporal data
gen_time(4)
gen_date(4)
gen_datetime(4)
</code></pre>

<hr>
<h2 id='guess_type'>Guess the type of a vector</h2><span id='topic+guess_type'></span>

<h3>Description</h3>

<p>Guess the type of a vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guess_type(
  x,
  na = c("", "NA"),
  locale = default_locale(),
  guess_integer = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guess_type_+3A_x">x</code></td>
<td>
<p>Character vector of values to parse.</p>
</td></tr>
<tr><td><code id="guess_type_+3A_na">na</code></td>
<td>
<p>Character vector of strings to interpret as missing values. Set this
option to <code>character()</code> to indicate no missing values.</p>
</td></tr>
<tr><td><code id="guess_type_+3A_locale">locale</code></td>
<td>
<p>The locale controls defaults that vary from place to place.
The default locale is US-centric (like R), but you can use
<code><a href="readr.html#topic+locale">locale()</a></code> to create your own locale that controls things like
the default time zone, encoding, decimal mark, big mark, and day/month
names.</p>
</td></tr>
<tr><td><code id="guess_type_+3A_guess_integer">guess_integer</code></td>
<td>
<p>If <code>TRUE</code>, guess integer types for whole numbers, if
<code>FALSE</code> guess numeric type for all numbers.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'> # Logical vectors
 guess_type(c("FALSE", "TRUE", "F", "T"))
 # Integers and doubles
 guess_type(c("1","2","3"))
 guess_type(c("1.6","2.6","3.4"))
 # Numbers containing grouping mark
 guess_type("1,234,566")
 # ISO 8601 date times
 guess_type(c("2010-10-10"))
 guess_type(c("2010-10-10 01:02:03"))
 guess_type(c("01:02:03 AM"))
</code></pre>

<hr>
<h2 id='locale'>Create locales</h2><span id='topic+locale'></span><span id='topic+default_locale'></span>

<h3>Description</h3>

<p>A locale object tries to capture all the defaults that can vary between
countries. You set the locale in once, and the details are automatically
passed on down to the columns parsers. The defaults have been chosen to
match R (i.e. US English) as closely as possible. See
<code>vignette("locales")</code> for more details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locale(
  date_names = "en",
  date_format = "%AD",
  time_format = "%AT",
  decimal_mark = ".",
  grouping_mark = ",",
  tz = "UTC",
  encoding = "UTF-8"
)

default_locale()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locale_+3A_date_names">date_names</code></td>
<td>
<p>Character representations of day and month names. Either
the language code as string (passed on to <code><a href="#topic+date_names_lang">date_names_lang()</a></code>)
or an object created by <code><a href="#topic+date_names">date_names()</a></code>.</p>
</td></tr>
<tr><td><code id="locale_+3A_date_format">date_format</code>, <code id="locale_+3A_time_format">time_format</code></td>
<td>
<p>Default date and time formats.</p>
</td></tr>
<tr><td><code id="locale_+3A_decimal_mark">decimal_mark</code>, <code id="locale_+3A_grouping_mark">grouping_mark</code></td>
<td>
<p>Symbols used to indicate the decimal
place, and to chunk larger numbers. Decimal mark can only be <code style="white-space: pre;">&#8288;,&#8288;</code> or
<code>.</code>.</p>
</td></tr>
<tr><td><code id="locale_+3A_tz">tz</code></td>
<td>
<p>Default tz. This is used both for input (if the time zone isn't
present in individual strings), and for output (to control the default
display). The default is to use &quot;UTC&quot;, a time zone that does not use
daylight savings time (DST) and hence is typically most useful for data.
The absence of time zones makes it approximately 50x faster to generate
UTC times than any other time zone.
</p>
<p>Use <code>""</code> to use the system default time zone, but beware that this
will not be reproducible across systems.
</p>
<p>For a complete list of possible time zones, see <code><a href="base.html#topic+OlsonNames">OlsonNames()</a></code>.
Americans, note that &quot;EST&quot; is a Canadian time zone that does not have
DST. It is <em>not</em> Eastern Standard Time. It's better to use
&quot;US/Eastern&quot;, &quot;US/Central&quot; etc.</p>
</td></tr>
<tr><td><code id="locale_+3A_encoding">encoding</code></td>
<td>
<p>Default encoding.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>locale()
locale("fr")

# South American locale
locale("es", decimal_mark = ",")
</code></pre>

<hr>
<h2 id='output_column'>Preprocess column for output</h2><span id='topic+output_column'></span>

<h3>Description</h3>

<p>This is a generic function that applied to each column before it is saved
to disk. It provides a hook for S3 classes that need special handling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>output_column(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="output_column_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Most types are returned unchanged
output_column(1)
output_column("x")

# datetimes are formatted in ISO 8601
output_column(Sys.Date())
output_column(Sys.time())
</code></pre>

<hr>
<h2 id='problems'>Retrieve parsing problems</h2><span id='topic+problems'></span>

<h3>Description</h3>

<p>vroom will only fail to parse a file if the file is invalid in a way that is
unrecoverable. However there are a number of non-fatal problems that you
might want to know about. You can retrieve a data frame of these problems
with this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>problems(x = .Last.value, lazy = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="problems_+3A_x">x</code></td>
<td>
<p>A data frame from <code>vroom::vroom()</code>.</p>
</td></tr>
<tr><td><code id="problems_+3A_lazy">lazy</code></td>
<td>
<p>If <code>TRUE</code>, just the problems found so far are returned. If
<code>FALSE</code> (the default) the lazy data is first read completely and all
problems are returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with one row for each problem and four columns:
</p>

<ul>
<li><p> row,col - Row and column number that caused the problem, referencing the
original input
</p>
</li>
<li><p> expected - What vroom expected to find
</p>
</li>
<li><p> actual - What it actually found
</p>
</li>
<li><p> file - The file with the problem
</p>
</li></ul>


<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+contains'></span><span id='topic+select_helpers'></span><span id='topic+ends_with'></span><span id='topic+everything'></span><span id='topic+matches'></span><span id='topic+num_range'></span><span id='topic+one_of'></span><span id='topic+starts_with'></span><span id='topic+last_col'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>tidyselect</dt><dd><p><code><a href="tidyselect.html#topic+starts_with">contains</a></code>, <code><a href="tidyselect.html#topic+starts_with">ends_with</a></code>, <code><a href="tidyselect.html#topic+everything">everything</a></code>, <code><a href="tidyselect.html#topic+everything">last_col</a></code>, <code><a href="tidyselect.html#topic+starts_with">matches</a></code>, <code><a href="tidyselect.html#topic+starts_with">num_range</a></code>, <code><a href="tidyselect.html#topic+one_of">one_of</a></code>, <code><a href="tidyselect.html#topic+starts_with">starts_with</a></code></p>
</dd>
</dl>

<hr>
<h2 id='vroom'>Read a delimited file into a tibble</h2><span id='topic+vroom'></span>

<h3>Description</h3>

<p>Read a delimited file into a tibble
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vroom(
  file,
  delim = NULL,
  col_names = TRUE,
  col_types = NULL,
  col_select = NULL,
  id = NULL,
  skip = 0,
  n_max = Inf,
  na = c("", "NA"),
  quote = "\"",
  comment = "",
  skip_empty_rows = TRUE,
  trim_ws = TRUE,
  escape_double = TRUE,
  escape_backslash = FALSE,
  locale = default_locale(),
  guess_max = 100,
  altrep = TRUE,
  altrep_opts = deprecated(),
  num_threads = vroom_threads(),
  progress = vroom_progress(),
  show_col_types = NULL,
  .name_repair = "unique"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vroom_+3A_file">file</code></td>
<td>
<p>Either a path to a file, a connection, or literal data (either a
single string or a raw vector). <code>file</code> can also be a character vector
containing multiple filepaths or a list containing multiple connections.
</p>
<p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will be automatically
uncompressed. Files starting with <code style="white-space: pre;">&#8288;http://&#8288;</code>, <code style="white-space: pre;">&#8288;https://&#8288;</code>, <code style="white-space: pre;">&#8288;ftp://&#8288;</code>, or
<code style="white-space: pre;">&#8288;ftps://&#8288;</code> will be automatically downloaded. Remote gz files can also be
automatically downloaded and decompressed.
</p>
<p>Literal data is most useful for examples and tests. To be recognised as
literal data, wrap the input with <code>I()</code>.</p>
</td></tr>
<tr><td><code id="vroom_+3A_delim">delim</code></td>
<td>
<p>One or more characters used to delimit fields within a
file. If <code>NULL</code> the delimiter is guessed from the set of <code>c(",", "\t", " ", "|", ":", ";")</code>.</p>
</td></tr>
<tr><td><code id="vroom_+3A_col_names">col_names</code></td>
<td>
<p>Either <code>TRUE</code>, <code>FALSE</code> or a character vector
of column names.
</p>
<p>If <code>TRUE</code>, the first row of the input will be used as the column
names, and will not be included in the data frame. If <code>FALSE</code>, column
names will be generated automatically: X1, X2, X3 etc.
</p>
<p>If <code>col_names</code> is a character vector, the values will be used as the
names of the columns, and the first row of the input will be read into
the first row of the output data frame.
</p>
<p>Missing (<code>NA</code>) column names will generate a warning, and be filled
in with dummy names <code>...1</code>, <code>...2</code> etc. Duplicate column names
will generate a warning and be made unique, see <code>name_repair</code> to control
how this is done.</p>
</td></tr>
<tr><td><code id="vroom_+3A_col_types">col_types</code></td>
<td>
<p>One of <code>NULL</code>, a <code><a href="#topic+cols">cols()</a></code> specification, or
a string.
</p>
<p>If <code>NULL</code>, all column types will be imputed from <code>guess_max</code> rows
on the input interspersed throughout the file. This is convenient (and
fast), but not robust. If the imputation fails, you'll need to increase
the <code>guess_max</code> or supply the correct types yourself.
</p>
<p>Column specifications created by <code><a href="base.html#topic+list">list()</a></code> or <code><a href="#topic+cols">cols()</a></code> must contain
one column specification for each column. If you only want to read a
subset of the columns, use <code><a href="#topic+cols_only">cols_only()</a></code>.
</p>
<p>Alternatively, you can use a compact string representation where each
character represents one column:
</p>

<ul>
<li><p> c = character
</p>
</li>
<li><p> i = integer
</p>
</li>
<li><p> n = number
</p>
</li>
<li><p> d = double
</p>
</li>
<li><p> l = logical
</p>
</li>
<li><p> f = factor
</p>
</li>
<li><p> D = date
</p>
</li>
<li><p> T = date time
</p>
</li>
<li><p> t = time
</p>
</li>
<li><p> ? = guess
</p>
</li>
<li><p> _ or - = skip
</p>
<p>By default, reading a file without a column specification will print a
message showing what <code>readr</code> guessed they were. To remove this message,
set <code>show_col_types = FALSE</code> or set <code>options(readr.show_col_types = FALSE)</code>.
</p>
</li></ul>
</td></tr>
<tr><td><code id="vroom_+3A_col_select">col_select</code></td>
<td>
<p>Columns to include in the results. You can use the same
mini-language as <code>dplyr::select()</code> to refer to the columns by name. Use
<code>c()</code> to use more than one selection expression. Although this
usage is less common, <code>col_select</code> also accepts a numeric column index. See
<code><a href="tidyselect.html#topic+language">?tidyselect::language</a></code> for full details on the
selection language.</p>
</td></tr>
<tr><td><code id="vroom_+3A_id">id</code></td>
<td>
<p>Either a string or 'NULL'. If a string, the output will contain a
variable with that name with the filename(s) as the value. If 'NULL', the
default, no variable will be created.</p>
</td></tr>
<tr><td><code id="vroom_+3A_skip">skip</code></td>
<td>
<p>Number of lines to skip before reading data. If <code>comment</code> is
supplied any commented lines are ignored <em>after</em> skipping.</p>
</td></tr>
<tr><td><code id="vroom_+3A_n_max">n_max</code></td>
<td>
<p>Maximum number of lines to read.</p>
</td></tr>
<tr><td><code id="vroom_+3A_na">na</code></td>
<td>
<p>Character vector of strings to interpret as missing values. Set this
option to <code>character()</code> to indicate no missing values.</p>
</td></tr>
<tr><td><code id="vroom_+3A_quote">quote</code></td>
<td>
<p>Single character used to quote strings.</p>
</td></tr>
<tr><td><code id="vroom_+3A_comment">comment</code></td>
<td>
<p>A string used to identify comments. Any text after the
comment characters will be silently ignored.</p>
</td></tr>
<tr><td><code id="vroom_+3A_skip_empty_rows">skip_empty_rows</code></td>
<td>
<p>Should blank rows be ignored altogether? i.e. If this
option is <code>TRUE</code> then blank rows will not be represented at all.  If it is
<code>FALSE</code> then they will be represented by <code>NA</code> values in all the columns.</p>
</td></tr>
<tr><td><code id="vroom_+3A_trim_ws">trim_ws</code></td>
<td>
<p>Should leading and trailing whitespace (ASCII spaces and tabs) be trimmed from
each field before parsing it?</p>
</td></tr>
<tr><td><code id="vroom_+3A_escape_double">escape_double</code></td>
<td>
<p>Does the file escape quotes by doubling them?
i.e. If this option is <code>TRUE</code>, the value '&quot;&quot;' represents
a single quote, '&quot;'.</p>
</td></tr>
<tr><td><code id="vroom_+3A_escape_backslash">escape_backslash</code></td>
<td>
<p>Does the file use backslashes to escape special
characters? This is more general than <code>escape_double</code> as backslashes
can be used to escape the delimiter character, the quote character, or
to add special characters like <code style="white-space: pre;">&#8288;\\n&#8288;</code>.</p>
</td></tr>
<tr><td><code id="vroom_+3A_locale">locale</code></td>
<td>
<p>The locale controls defaults that vary from place to place.
The default locale is US-centric (like R), but you can use
<code><a href="#topic+locale">locale()</a></code> to create your own locale that controls things like
the default time zone, encoding, decimal mark, big mark, and day/month
names.</p>
</td></tr>
<tr><td><code id="vroom_+3A_guess_max">guess_max</code></td>
<td>
<p>Maximum number of lines to use for guessing column types.
See <code>vignette("column-types", package = "readr")</code> for more details.</p>
</td></tr>
<tr><td><code id="vroom_+3A_altrep">altrep</code></td>
<td>
<p>Control which column types use Altrep representations,
either a character vector of types, <code>TRUE</code> or <code>FALSE</code>. See
<code><a href="#topic+vroom_altrep">vroom_altrep()</a></code> for for full details.</p>
</td></tr>
<tr><td><code id="vroom_+3A_altrep_opts">altrep_opts</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a></p>
</td></tr>
<tr><td><code id="vroom_+3A_num_threads">num_threads</code></td>
<td>
<p>Number of threads to use when reading and materializing
vectors. If your data contains newlines within fields the parser will
automatically be forced to use a single thread only.</p>
</td></tr>
<tr><td><code id="vroom_+3A_progress">progress</code></td>
<td>
<p>Display a progress bar? By default it will only display
in an interactive session and not while knitting a document. The automatic
progress bar can be disabled by setting option <code>readr.show_progress</code> to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="vroom_+3A_show_col_types">show_col_types</code></td>
<td>
<p>Control showing the column specifications. If <code>TRUE</code>
column specifications are always show, if <code>FALSE</code> they are never shown. If
<code>NULL</code> (the default) they are shown only if an explicit specification is not
given to <code>col_types</code>.</p>
</td></tr>
<tr><td><code id="vroom_+3A_.name_repair">.name_repair</code></td>
<td>
<p>Handling of column names. The default behaviour is to
ensure column names are <code>"unique"</code>. Various repair strategies are
supported:
</p>

<ul>
<li> <p><code>"minimal"</code>: No name repair or checks, beyond basic existence of names.
</p>
</li>
<li> <p><code>"unique"</code> (default value): Make sure names are unique and not empty.
</p>
</li>
<li> <p><code>"check_unique"</code>: no name repair, but check they are <code>unique</code>.
</p>
</li>
<li> <p><code>"universal"</code>: Make the names <code>unique</code> and syntactic.
</p>
</li>
<li><p> A function: apply custom name repair (e.g., <code>name_repair = make.names</code>
for names in the style of base R).
</p>
</li>
<li><p> A purrr-style anonymous function, see <code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code>.
</p>
</li></ul>

<p>This argument is passed on as <code>repair</code> to <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code>.
See there for more details on these terms and the strategies used
to enforce them.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># get path to example file
input_file &lt;- vroom_example("mtcars.csv")
input_file

# Read from a path

# Input sources -------------------------------------------------------------
# Read from a path
vroom(input_file)
# You can also use paths directly
# vroom("mtcars.csv")

## Not run: 
# Including remote paths
vroom("https://github.com/tidyverse/vroom/raw/main/inst/extdata/mtcars.csv")

## End(Not run)

# Or directly from a string with `I()`
vroom(I("x,y\n1,2\n3,4\n"))

# Column selection ----------------------------------------------------------
# Pass column names or indexes directly to select them
vroom(input_file, col_select = c(model, cyl, gear))
vroom(input_file, col_select = c(1, 3, 11))

# Or use the selection helpers
vroom(input_file, col_select = starts_with("d"))

# You can also rename specific columns
vroom(input_file, col_select = c(car = model, everything()))

# Column types --------------------------------------------------------------
# By default, vroom guesses the columns types, looking at 1000 rows
# throughout the dataset.
# You can specify them explicitly with a compact specification:
vroom(I("x,y\n1,2\n3,4\n"), col_types = "dc")

# Or with a list of column types:
vroom(I("x,y\n1,2\n3,4\n"), col_types = list(col_double(), col_character()))

# File types ----------------------------------------------------------------
# csv
vroom(I("a,b\n1.0,2.0\n"), delim = ",")
# tsv
vroom(I("a\tb\n1.0\t2.0\n"))
# Other delimiters
vroom(I("a|b\n1.0|2.0\n"), delim = "|")

# Read datasets across multiple files ---------------------------------------
mtcars_by_cyl &lt;- vroom_example(vroom_examples("mtcars-"))
mtcars_by_cyl

# Pass the filenames directly to vroom, they are efficiently combined
vroom(mtcars_by_cyl)

# If you need to extract data from the filenames, use `id` to request a
# column that reveals the underlying file path
dat &lt;- vroom(mtcars_by_cyl, id = "source")
dat$source &lt;- basename(dat$source)
dat
</code></pre>

<hr>
<h2 id='vroom_altrep'>Show which column types are using Altrep</h2><span id='topic+vroom_altrep'></span>

<h3>Description</h3>

<p><code>vroom_altrep()</code> can be used directly as input to the <code>altrep</code>
argument of <code><a href="#topic+vroom">vroom()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vroom_altrep(which = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vroom_altrep_+3A_which">which</code></td>
<td>
<p>A character vector of column types to use Altrep for. Can also
take <code>TRUE</code> or <code>FALSE</code> to use Altrep for all possible or none of the
types</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Alternatively there is also a family of environment variables to control use of
the Altrep framework. These can then be set in your <code>.Renviron</code> file, e.g.
with <code>usethis::edit_r_environ()</code>. For versions of R where the Altrep
framework is unavailable (R &lt; 3.5.0) they are automatically turned off and
the variables have no effect. The variables can take one of <code>true</code>, <code>false</code>,
<code>TRUE</code>, <code>FALSE</code>, <code>1</code>, or <code>0</code>.
</p>

<ul>
<li> <p><code>VROOM_USE_ALTREP_NUMERICS</code> - If set use Altrep for <em>all</em> numeric types
(default <code>false</code>).
</p>
</li></ul>

<p>There are also individual variables for each type. Currently only
<code>VROOM_USE_ALTREP_CHR</code> defaults to <code>true</code>.
</p>

<ul>
<li> <p><code>VROOM_USE_ALTREP_CHR</code>
</p>
</li>
<li> <p><code>VROOM_USE_ALTREP_FCT</code>
</p>
</li>
<li> <p><code>VROOM_USE_ALTREP_INT</code>
</p>
</li>
<li> <p><code>VROOM_USE_ALTREP_BIG_INT</code>
</p>
</li>
<li> <p><code>VROOM_USE_ALTREP_DBL</code>
</p>
</li>
<li> <p><code>VROOM_USE_ALTREP_NUM</code>
</p>
</li>
<li> <p><code>VROOM_USE_ALTREP_LGL</code>
</p>
</li>
<li> <p><code>VROOM_USE_ALTREP_DTTM</code>
</p>
</li>
<li> <p><code>VROOM_USE_ALTREP_DATE</code>
</p>
</li>
<li> <p><code>VROOM_USE_ALTREP_TIME</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>vroom_altrep()
vroom_altrep(c("chr", "fct", "int"))
vroom_altrep(TRUE)
vroom_altrep(FALSE)
</code></pre>

<hr>
<h2 id='vroom_altrep_opts'>Show which column types are using Altrep</h2><span id='topic+vroom_altrep_opts'></span>

<h3>Description</h3>

<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a>
This function is deprecated in favor of <code>vroom_altrep()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vroom_altrep_opts(which = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vroom_altrep_opts_+3A_which">which</code></td>
<td>
<p>A character vector of column types to use Altrep for. Can also
take <code>TRUE</code> or <code>FALSE</code> to use Altrep for all possible or none of the
types</p>
</td></tr>
</table>

<hr>
<h2 id='vroom_example'>Get path to vroom examples</h2><span id='topic+vroom_example'></span><span id='topic+vroom_examples'></span>

<h3>Description</h3>

<p>vroom comes bundled with a number of sample files in
its 'inst/extdata' directory. Use <code>vroom_examples()</code> to list all the
available examples and <code>vroom_example()</code> to retrieve the path to one
example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vroom_example(path)

vroom_examples(pattern = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vroom_example_+3A_path">path</code></td>
<td>
<p>Name of file.</p>
</td></tr>
<tr><td><code id="vroom_example_+3A_pattern">pattern</code></td>
<td>
<p>A regular expression of filenames to match. If <code>NULL</code>, all
available files are returned.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># List all available examples
vroom_examples()

# Get path to one example
vroom_example("mtcars.csv")
</code></pre>

<hr>
<h2 id='vroom_format'>Convert a data frame to a delimited string</h2><span id='topic+vroom_format'></span>

<h3>Description</h3>

<p>This is equivalent to <code><a href="#topic+vroom_write">vroom_write()</a></code>, but instead of writing to
disk, it returns a string. It is primarily useful for examples and for
testing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vroom_format(
  x,
  delim = "\t",
  eol = "\n",
  na = "NA",
  col_names = TRUE,
  escape = c("double", "backslash", "none"),
  quote = c("needed", "all", "none"),
  bom = FALSE,
  num_threads = vroom_threads()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vroom_format_+3A_x">x</code></td>
<td>
<p>A data frame or tibble to write to disk.</p>
</td></tr>
<tr><td><code id="vroom_format_+3A_delim">delim</code></td>
<td>
<p>Delimiter used to separate values. Defaults to <code style="white-space: pre;">&#8288;\t&#8288;</code> to write
tab separated value (TSV) files.</p>
</td></tr>
<tr><td><code id="vroom_format_+3A_eol">eol</code></td>
<td>
<p>The end of line character to use. Most commonly either <code>"\n"</code> for
Unix style newlines, or <code>"\r\n"</code> for Windows style newlines.</p>
</td></tr>
<tr><td><code id="vroom_format_+3A_na">na</code></td>
<td>
<p>String used for missing values. Defaults to 'NA'.</p>
</td></tr>
<tr><td><code id="vroom_format_+3A_col_names">col_names</code></td>
<td>
<p>If <code>FALSE</code>, column names will not be included at the top of the file. If <code>TRUE</code>,
column names will be included. If not specified, <code>col_names</code> will take the opposite value given to <code>append</code>.</p>
</td></tr>
<tr><td><code id="vroom_format_+3A_escape">escape</code></td>
<td>
<p>The type of escape to use when quotes are in the data.
</p>

<ul>
<li> <p><code>double</code> - quotes are escaped by doubling them.
</p>
</li>
<li> <p><code>backslash</code> - quotes are escaped by a preceding backslash.
</p>
</li>
<li> <p><code>none</code> - quotes are not escaped.
</p>
</li></ul>
</td></tr>
<tr><td><code id="vroom_format_+3A_quote">quote</code></td>
<td>
<p>How to handle fields which contain characters that need to be
quoted.
</p>

<ul>
<li> <p><code>needed</code> - Values are only quoted if needed: if they contain a delimiter,
quote, or newline.
</p>
</li>
<li> <p><code>all</code> - Quote all fields.
</p>
</li>
<li> <p><code>none</code> - Never quote fields.
</p>
</li></ul>
</td></tr>
<tr><td><code id="vroom_format_+3A_bom">bom</code></td>
<td>
<p>If <code>TRUE</code> add a UTF-8 BOM at the beginning of the file. This is
recommended when saving data for consumption by excel, as it will force
excel to read the data with the correct encoding (UTF-8)</p>
</td></tr>
<tr><td><code id="vroom_format_+3A_num_threads">num_threads</code></td>
<td>
<p>Number of threads to use when reading and materializing
vectors. If your data contains newlines within fields the parser will
automatically be forced to use a single thread only.</p>
</td></tr>
</table>

<hr>
<h2 id='vroom_fwf'>Read a fixed width file into a tibble</h2><span id='topic+vroom_fwf'></span><span id='topic+fwf_empty'></span><span id='topic+fwf_widths'></span><span id='topic+fwf_positions'></span><span id='topic+fwf_cols'></span>

<h3>Description</h3>

<p>Read a fixed width file into a tibble
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vroom_fwf(
  file,
  col_positions = fwf_empty(file, skip, n = guess_max),
  col_types = NULL,
  col_select = NULL,
  id = NULL,
  locale = default_locale(),
  na = c("", "NA"),
  comment = "",
  skip_empty_rows = TRUE,
  trim_ws = TRUE,
  skip = 0,
  n_max = Inf,
  guess_max = 100,
  altrep = TRUE,
  altrep_opts = deprecated(),
  num_threads = vroom_threads(),
  progress = vroom_progress(),
  show_col_types = NULL,
  .name_repair = "unique"
)

fwf_empty(file, skip = 0, col_names = NULL, comment = "", n = 100L)

fwf_widths(widths, col_names = NULL)

fwf_positions(start, end = NULL, col_names = NULL)

fwf_cols(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vroom_fwf_+3A_file">file</code></td>
<td>
<p>Either a path to a file, a connection, or literal data
(either a single string or a raw vector).
</p>
<p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will
be automatically uncompressed. Files starting with <code style="white-space: pre;">&#8288;http://&#8288;</code>,
<code style="white-space: pre;">&#8288;https://&#8288;</code>, <code style="white-space: pre;">&#8288;ftp://&#8288;</code>, or <code style="white-space: pre;">&#8288;ftps://&#8288;</code> will be automatically
downloaded. Remote gz files can also be automatically downloaded and
decompressed.
</p>
<p>Literal data is most useful for examples and tests. To be recognised as
literal data, the input must be either wrapped with <code>I()</code>, be a string
containing at least one new line, or be a vector containing at least one
string with a new line.
</p>
<p>Using a value of <code><a href="readr.html#topic+clipboard">clipboard()</a></code> will read from the system clipboard.</p>
</td></tr>
<tr><td><code id="vroom_fwf_+3A_col_positions">col_positions</code></td>
<td>
<p>Column positions, as created by <code><a href="readr.html#topic+fwf_empty">fwf_empty()</a></code>,
<code><a href="readr.html#topic+fwf_widths">fwf_widths()</a></code> or <code><a href="readr.html#topic+fwf_positions">fwf_positions()</a></code>. To read in only selected fields,
use <code><a href="readr.html#topic+fwf_positions">fwf_positions()</a></code>. If the width of the last column is variable (a
ragged fwf file), supply the last end position as NA.</p>
</td></tr>
<tr><td><code id="vroom_fwf_+3A_col_types">col_types</code></td>
<td>
<p>One of <code>NULL</code>, a <code><a href="readr.html#topic+cols">cols()</a></code> specification, or
a string. See <code>vignette("readr")</code> for more details.
</p>
<p>If <code>NULL</code>, all column types will be inferred from <code>guess_max</code> rows of the
input, interspersed throughout the file. This is convenient (and fast),
but not robust. If the guessed types are wrong, you'll need to increase
<code>guess_max</code> or supply the correct types yourself.
</p>
<p>Column specifications created by <code><a href="base.html#topic+list">list()</a></code> or <code><a href="readr.html#topic+cols">cols()</a></code> must contain
one column specification for each column. If you only want to read a
subset of the columns, use <code><a href="readr.html#topic+cols_only">cols_only()</a></code>.
</p>
<p>Alternatively, you can use a compact string representation where each
character represents one column:
</p>

<ul>
<li><p> c = character
</p>
</li>
<li><p> i = integer
</p>
</li>
<li><p> n = number
</p>
</li>
<li><p> d = double
</p>
</li>
<li><p> l = logical
</p>
</li>
<li><p> f = factor
</p>
</li>
<li><p> D = date
</p>
</li>
<li><p> T = date time
</p>
</li>
<li><p> t = time
</p>
</li>
<li><p> ? = guess
</p>
</li>
<li><p> _ or - = skip
</p>
</li></ul>

<p>By default, reading a file without a column specification will print a
message showing what <code>readr</code> guessed they were. To remove this message,
set <code>show_col_types = FALSE</code> or set 'options(readr.show_col_types = FALSE).</p>
</td></tr>
<tr><td><code id="vroom_fwf_+3A_col_select">col_select</code></td>
<td>
<p>Columns to include in the results. You can use the same
mini-language as <code>dplyr::select()</code> to refer to the columns by name. Use
<code>c()</code> to use more than one selection expression. Although this
usage is less common, <code>col_select</code> also accepts a numeric column index. See
<code><a href="tidyselect.html#topic+language">?tidyselect::language</a></code> for full details on the
selection language.</p>
</td></tr>
<tr><td><code id="vroom_fwf_+3A_id">id</code></td>
<td>
<p>The name of a column in which to store the file path. This is
useful when reading multiple input files and there is data in the file
paths, such as the data collection date. If <code>NULL</code> (the default) no extra
column is created.</p>
</td></tr>
<tr><td><code id="vroom_fwf_+3A_locale">locale</code></td>
<td>
<p>The locale controls defaults that vary from place to place.
The default locale is US-centric (like R), but you can use
<code><a href="readr.html#topic+locale">locale()</a></code> to create your own locale that controls things like
the default time zone, encoding, decimal mark, big mark, and day/month
names.</p>
</td></tr>
<tr><td><code id="vroom_fwf_+3A_na">na</code></td>
<td>
<p>Character vector of strings to interpret as missing values. Set this
option to <code>character()</code> to indicate no missing values.</p>
</td></tr>
<tr><td><code id="vroom_fwf_+3A_comment">comment</code></td>
<td>
<p>A string used to identify comments. Any text after the
comment characters will be silently ignored.</p>
</td></tr>
<tr><td><code id="vroom_fwf_+3A_skip_empty_rows">skip_empty_rows</code></td>
<td>
<p>Should blank rows be ignored altogether? i.e. If this
option is <code>TRUE</code> then blank rows will not be represented at all.  If it is
<code>FALSE</code> then they will be represented by <code>NA</code> values in all the columns.</p>
</td></tr>
<tr><td><code id="vroom_fwf_+3A_trim_ws">trim_ws</code></td>
<td>
<p>Should leading and trailing whitespace (ASCII spaces and tabs) be trimmed from
each field before parsing it?</p>
</td></tr>
<tr><td><code id="vroom_fwf_+3A_skip">skip</code></td>
<td>
<p>Number of lines to skip before reading data.</p>
</td></tr>
<tr><td><code id="vroom_fwf_+3A_n_max">n_max</code></td>
<td>
<p>Maximum number of lines to read.</p>
</td></tr>
<tr><td><code id="vroom_fwf_+3A_guess_max">guess_max</code></td>
<td>
<p>Maximum number of lines to use for guessing column types.
Will never use more than the number of lines read.
See <code>vignette("column-types", package = "readr")</code> for more details.</p>
</td></tr>
<tr><td><code id="vroom_fwf_+3A_altrep">altrep</code></td>
<td>
<p>Control which column types use Altrep representations,
either a character vector of types, <code>TRUE</code> or <code>FALSE</code>. See
<code><a href="#topic+vroom_altrep">vroom_altrep()</a></code> for for full details.</p>
</td></tr>
<tr><td><code id="vroom_fwf_+3A_altrep_opts">altrep_opts</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a></p>
</td></tr>
<tr><td><code id="vroom_fwf_+3A_num_threads">num_threads</code></td>
<td>
<p>The number of processing threads to use for initial
parsing and lazy reading of data. If your data contains newlines within
fields the parser should automatically detect this and fall back to using
one thread only. However if you know your file has newlines within quoted
fields it is safest to set <code>num_threads = 1</code> explicitly.</p>
</td></tr>
<tr><td><code id="vroom_fwf_+3A_progress">progress</code></td>
<td>
<p>Display a progress bar? By default it will only display
in an interactive session and not while knitting a document. The automatic
progress bar can be disabled by setting option <code>readr.show_progress</code> to
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="vroom_fwf_+3A_show_col_types">show_col_types</code></td>
<td>
<p>If <code>FALSE</code>, do not show the guessed column types. If
<code>TRUE</code> always show the column types, even if they are supplied. If <code>NULL</code>
(the default) only show the column types if they are not explicitly supplied
by the <code>col_types</code> argument.</p>
</td></tr>
<tr><td><code id="vroom_fwf_+3A_.name_repair">.name_repair</code></td>
<td>
<p>Handling of column names. The default behaviour is to
ensure column names are <code>"unique"</code>. Various repair strategies are
supported:
</p>

<ul>
<li> <p><code>"minimal"</code>: No name repair or checks, beyond basic existence of names.
</p>
</li>
<li> <p><code>"unique"</code> (default value): Make sure names are unique and not empty.
</p>
</li>
<li> <p><code>"check_unique"</code>: no name repair, but check they are <code>unique</code>.
</p>
</li>
<li> <p><code>"universal"</code>: Make the names <code>unique</code> and syntactic.
</p>
</li>
<li><p> A function: apply custom name repair (e.g., <code>name_repair = make.names</code>
for names in the style of base R).
</p>
</li>
<li><p> A purrr-style anonymous function, see <code><a href="rlang.html#topic+as_function">rlang::as_function()</a></code>.
</p>
</li></ul>

<p>This argument is passed on as <code>repair</code> to <code><a href="vctrs.html#topic+vec_as_names">vctrs::vec_as_names()</a></code>.
See there for more details on these terms and the strategies used
to enforce them.</p>
</td></tr>
<tr><td><code id="vroom_fwf_+3A_col_names">col_names</code></td>
<td>
<p>Either NULL, or a character vector column names.</p>
</td></tr>
<tr><td><code id="vroom_fwf_+3A_n">n</code></td>
<td>
<p>Number of lines the tokenizer will read to determine file structure. By default
it is set to 100.</p>
</td></tr>
<tr><td><code id="vroom_fwf_+3A_widths">widths</code></td>
<td>
<p>Width of each field. Use NA as width of last field when
reading a ragged fwf file.</p>
</td></tr>
<tr><td><code id="vroom_fwf_+3A_start">start</code>, <code id="vroom_fwf_+3A_end">end</code></td>
<td>
<p>Starting and ending (inclusive) positions of each field.
Use NA as last end field when reading a ragged fwf file.</p>
</td></tr>
<tr><td><code id="vroom_fwf_+3A_...">...</code></td>
<td>
<p>If the first element is a data frame,
then it must have all numeric columns and either one or two rows.
The column names are the variable names. The column values are the
variable widths if a length one vector, and if length two, variable start and end
positions. The elements of <code>...</code> are used to construct a data frame
with or or two rows as above.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>Note</em>: <code>fwf_empty()</code> cannot take a R connection such as a URL as input, as
this would result in reading from the connection twice. In these cases it is
better to download the file first before reading.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fwf_sample &lt;- vroom_example("fwf-sample.txt")
writeLines(vroom_lines(fwf_sample))

# You can specify column positions in several ways:
# 1. Guess based on position of empty columns
vroom_fwf(fwf_sample, fwf_empty(fwf_sample, col_names = c("first", "last", "state", "ssn")))
# 2. A vector of field widths
vroom_fwf(fwf_sample, fwf_widths(c(20, 10, 12), c("name", "state", "ssn")))
# 3. Paired vectors of start and end positions
vroom_fwf(fwf_sample, fwf_positions(c(1, 30), c(20, 42), c("name", "ssn")))
# 4. Named arguments with start and end positions
vroom_fwf(fwf_sample, fwf_cols(name = c(1, 20), ssn = c(30, 42)))
# 5. Named arguments with column widths
vroom_fwf(fwf_sample, fwf_cols(name = 20, state = 10, ssn = 12))
</code></pre>

<hr>
<h2 id='vroom_lines'>Read lines from a file</h2><span id='topic+vroom_lines'></span>

<h3>Description</h3>

<p><code>vroom_lines()</code> is similar to <code>readLines()</code>, however it reads the lines
lazily like <code><a href="#topic+vroom">vroom()</a></code>, so operations like <code>length()</code>, <code>head()</code>, <code>tail()</code> and <code>sample()</code>
can be done much more efficiently without reading all the data into R.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vroom_lines(
  file,
  n_max = Inf,
  skip = 0,
  na = character(),
  skip_empty_rows = FALSE,
  locale = default_locale(),
  altrep = TRUE,
  altrep_opts = deprecated(),
  num_threads = vroom_threads(),
  progress = vroom_progress()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vroom_lines_+3A_file">file</code></td>
<td>
<p>Either a path to a file, a connection, or literal data (either a
single string or a raw vector). <code>file</code> can also be a character vector
containing multiple filepaths or a list containing multiple connections.
</p>
<p>Files ending in <code>.gz</code>, <code>.bz2</code>, <code>.xz</code>, or <code>.zip</code> will be automatically
uncompressed. Files starting with <code style="white-space: pre;">&#8288;http://&#8288;</code>, <code style="white-space: pre;">&#8288;https://&#8288;</code>, <code style="white-space: pre;">&#8288;ftp://&#8288;</code>, or
<code style="white-space: pre;">&#8288;ftps://&#8288;</code> will be automatically downloaded. Remote gz files can also be
automatically downloaded and decompressed.
</p>
<p>Literal data is most useful for examples and tests. To be recognised as
literal data, wrap the input with <code>I()</code>.</p>
</td></tr>
<tr><td><code id="vroom_lines_+3A_n_max">n_max</code></td>
<td>
<p>Maximum number of lines to read.</p>
</td></tr>
<tr><td><code id="vroom_lines_+3A_skip">skip</code></td>
<td>
<p>Number of lines to skip before reading data. If <code>comment</code> is
supplied any commented lines are ignored <em>after</em> skipping.</p>
</td></tr>
<tr><td><code id="vroom_lines_+3A_na">na</code></td>
<td>
<p>Character vector of strings to interpret as missing values. Set this
option to <code>character()</code> to indicate no missing values.</p>
</td></tr>
<tr><td><code id="vroom_lines_+3A_skip_empty_rows">skip_empty_rows</code></td>
<td>
<p>Should blank rows be ignored altogether? i.e. If this
option is <code>TRUE</code> then blank rows will not be represented at all.  If it is
<code>FALSE</code> then they will be represented by <code>NA</code> values in all the columns.</p>
</td></tr>
<tr><td><code id="vroom_lines_+3A_locale">locale</code></td>
<td>
<p>The locale controls defaults that vary from place to place.
The default locale is US-centric (like R), but you can use
<code><a href="#topic+locale">locale()</a></code> to create your own locale that controls things like
the default time zone, encoding, decimal mark, big mark, and day/month
names.</p>
</td></tr>
<tr><td><code id="vroom_lines_+3A_altrep">altrep</code></td>
<td>
<p>Control which column types use Altrep representations,
either a character vector of types, <code>TRUE</code> or <code>FALSE</code>. See
<code><a href="#topic+vroom_altrep">vroom_altrep()</a></code> for for full details.</p>
</td></tr>
<tr><td><code id="vroom_lines_+3A_altrep_opts">altrep_opts</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a></p>
</td></tr>
<tr><td><code id="vroom_lines_+3A_num_threads">num_threads</code></td>
<td>
<p>Number of threads to use when reading and materializing
vectors. If your data contains newlines within fields the parser will
automatically be forced to use a single thread only.</p>
</td></tr>
<tr><td><code id="vroom_lines_+3A_progress">progress</code></td>
<td>
<p>Display a progress bar? By default it will only display
in an interactive session and not while knitting a document. The automatic
progress bar can be disabled by setting option <code>readr.show_progress</code> to
<code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>lines &lt;- vroom_lines(vroom_example("mtcars.csv"))

length(lines)
head(lines, n = 2)
tail(lines, n = 2)
sample(lines, size = 2)
</code></pre>

<hr>
<h2 id='vroom_progress'>Determine whether progress bars should be shown</h2><span id='topic+vroom_progress'></span>

<h3>Description</h3>

<p>By default, vroom shows progress bars. However, progress reporting is
suppressed if any of the following conditions hold:
</p>

<ul>
<li><p> The bar is explicitly disabled by setting the environment variable
<code>VROOM_SHOW_PROGRESS</code> to <code>"false"</code>.
</p>
</li>
<li><p> The code is run in a non-interactive session, as determined by
<code><a href="rlang.html#topic+is_interactive">rlang::is_interactive()</a></code>.
</p>
</li>
<li><p> The code is run in an RStudio notebook chunk, as determined by
<code>getOption("rstudio.notebook.executing")</code>.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>vroom_progress()
</code></pre>


<h3>Examples</h3>

<pre><code class='language-R'>vroom_progress()
</code></pre>

<hr>
<h2 id='vroom_str'>Structure of objects</h2><span id='topic+vroom_str'></span>

<h3>Description</h3>

<p>Similar to <code>str()</code> but with more information for Altrep objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vroom_str(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vroom_str_+3A_x">x</code></td>
<td>
<p>a vector</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># when used on non-altrep objects altrep will always be false
vroom_str(mtcars)

mt &lt;- vroom(vroom_example("mtcars.csv"), ",", altrep = c("chr", "dbl"))
vroom_str(mt)
</code></pre>

<hr>
<h2 id='vroom_write'>Write a data frame to a delimited file</h2><span id='topic+vroom_write'></span>

<h3>Description</h3>

<p>Write a data frame to a delimited file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vroom_write(
  x,
  file,
  delim = "\t",
  eol = "\n",
  na = "NA",
  col_names = !append,
  append = FALSE,
  quote = c("needed", "all", "none"),
  escape = c("double", "backslash", "none"),
  bom = FALSE,
  num_threads = vroom_threads(),
  progress = vroom_progress(),
  path = deprecated()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vroom_write_+3A_x">x</code></td>
<td>
<p>A data frame or tibble to write to disk.</p>
</td></tr>
<tr><td><code id="vroom_write_+3A_file">file</code></td>
<td>
<p>File or connection to write to.</p>
</td></tr>
<tr><td><code id="vroom_write_+3A_delim">delim</code></td>
<td>
<p>Delimiter used to separate values. Defaults to <code style="white-space: pre;">&#8288;\t&#8288;</code> to write
tab separated value (TSV) files.</p>
</td></tr>
<tr><td><code id="vroom_write_+3A_eol">eol</code></td>
<td>
<p>The end of line character to use. Most commonly either <code>"\n"</code> for
Unix style newlines, or <code>"\r\n"</code> for Windows style newlines.</p>
</td></tr>
<tr><td><code id="vroom_write_+3A_na">na</code></td>
<td>
<p>String used for missing values. Defaults to 'NA'.</p>
</td></tr>
<tr><td><code id="vroom_write_+3A_col_names">col_names</code></td>
<td>
<p>If <code>FALSE</code>, column names will not be included at the top of the file. If <code>TRUE</code>,
column names will be included. If not specified, <code>col_names</code> will take the opposite value given to <code>append</code>.</p>
</td></tr>
<tr><td><code id="vroom_write_+3A_append">append</code></td>
<td>
<p>If <code>FALSE</code>, will overwrite existing file. If <code>TRUE</code>,
will append to existing file. In both cases, if the file does not exist a new
file is created.</p>
</td></tr>
<tr><td><code id="vroom_write_+3A_quote">quote</code></td>
<td>
<p>How to handle fields which contain characters that need to be
quoted.
</p>

<ul>
<li> <p><code>needed</code> - Values are only quoted if needed: if they contain a delimiter,
quote, or newline.
</p>
</li>
<li> <p><code>all</code> - Quote all fields.
</p>
</li>
<li> <p><code>none</code> - Never quote fields.
</p>
</li></ul>
</td></tr>
<tr><td><code id="vroom_write_+3A_escape">escape</code></td>
<td>
<p>The type of escape to use when quotes are in the data.
</p>

<ul>
<li> <p><code>double</code> - quotes are escaped by doubling them.
</p>
</li>
<li> <p><code>backslash</code> - quotes are escaped by a preceding backslash.
</p>
</li>
<li> <p><code>none</code> - quotes are not escaped.
</p>
</li></ul>
</td></tr>
<tr><td><code id="vroom_write_+3A_bom">bom</code></td>
<td>
<p>If <code>TRUE</code> add a UTF-8 BOM at the beginning of the file. This is
recommended when saving data for consumption by excel, as it will force
excel to read the data with the correct encoding (UTF-8)</p>
</td></tr>
<tr><td><code id="vroom_write_+3A_num_threads">num_threads</code></td>
<td>
<p>Number of threads to use when reading and materializing
vectors. If your data contains newlines within fields the parser will
automatically be forced to use a single thread only.</p>
</td></tr>
<tr><td><code id="vroom_write_+3A_progress">progress</code></td>
<td>
<p>Display a progress bar? By default it will only display
in an interactive session and not while knitting a document. The display
is updated every 50,000 values and will only display if estimated reading
time is 5 seconds or more. The automatic progress bar can be disabled by
setting option <code>readr.show_progress</code> to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="vroom_write_+3A_path">path</code></td>
<td>
<p><a href="https://lifecycle.r-lib.org/articles/stages.html#deprecated"><img src="../help/figures/lifecycle-deprecated.svg" alt='[Deprecated]' /></a> is no longer supported, use
<code>file</code> instead.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># If you only specify a file name, vroom_write() will write
# the file to your current working directory.
out_file &lt;- tempfile(fileext = "csv")
vroom_write(mtcars, out_file, ",")

# You can also use a literal filename
# vroom_write(mtcars, "mtcars.tsv")

# If you add an extension to the file name, write_()* will
# automatically compress the output.
# vroom_write(mtcars, "mtcars.tsv.gz")
# vroom_write(mtcars, "mtcars.tsv.bz2")
# vroom_write(mtcars, "mtcars.tsv.xz")
</code></pre>

<hr>
<h2 id='vroom_write_lines'>Write lines to a file</h2><span id='topic+vroom_write_lines'></span>

<h3>Description</h3>

<p>Write lines to a file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vroom_write_lines(
  x,
  file,
  eol = "\n",
  na = "NA",
  append = FALSE,
  num_threads = vroom_threads()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vroom_write_lines_+3A_x">x</code></td>
<td>
<p>A character vector.</p>
</td></tr>
<tr><td><code id="vroom_write_lines_+3A_file">file</code></td>
<td>
<p>File or connection to write to.</p>
</td></tr>
<tr><td><code id="vroom_write_lines_+3A_eol">eol</code></td>
<td>
<p>The end of line character to use. Most commonly either <code>"\n"</code> for
Unix style newlines, or <code>"\r\n"</code> for Windows style newlines.</p>
</td></tr>
<tr><td><code id="vroom_write_lines_+3A_na">na</code></td>
<td>
<p>String used for missing values. Defaults to 'NA'.</p>
</td></tr>
<tr><td><code id="vroom_write_lines_+3A_append">append</code></td>
<td>
<p>If <code>FALSE</code>, will overwrite existing file. If <code>TRUE</code>,
will append to existing file. In both cases, if the file does not exist a new
file is created.</p>
</td></tr>
<tr><td><code id="vroom_write_lines_+3A_num_threads">num_threads</code></td>
<td>
<p>Number of threads to use when reading and materializing
vectors. If your data contains newlines within fields the parser will
automatically be forced to use a single thread only.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
