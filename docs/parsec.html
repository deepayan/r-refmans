<!DOCTYPE html><html><head><title>Help for package parsec</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {parsec}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#parsec-package'>
<p>PARtial orders in Socio-EConomics</p></a></li>
<li><a href='#AF'>
<p>OPHI counting approach</p></a></li>
<li><a href='#AF2threshold'>
<p>Poset threshold making the poset approach equivalent to the AF counting approach</p></a></li>
<li><a href='#antisymmetry'>
<p>antisymmetry</p></a></li>
<li><a href='#average_ranks'>
<p>Average Ranks</p></a></li>
<li><a href='#binary'>
<p>binary</p></a></li>
<li><a href='#colevels'>
<p>Colevels of a poset</p></a></li>
<li><a href='#cover2incidence'>
<p>cover2incidence</p></a></li>
<li><a href='#depths'>
<p>Depths</p></a></li>
<li><a href='#downset'>
<p>downset</p></a></li>
<li><a href='#drawedges'>
<p>drawedges</p></a></li>
<li><a href='#equivalences'>
<p>Equivalence classes in a poset.</p></a></li>
<li><a href='#evaluation'>
<p>Multidimensional evaluation on posets</p></a></li>
<li><a href='#FOD'>
<p>Fuzzy First Order Domninance analysis on partial orders</p></a></li>
<li><a href='#gen.downset'>
<p>Antichain generating a given downset</p></a></li>
<li><a href='#gen.upset'>
<p>Antichain generating a given upset</p></a></li>
<li><a href='#getlambda'>
<p>Object constructor for the incidence matrix representing a partial order on variables.</p></a></li>
<li><a href='#getzeta'>
<p>Incidence matrix generation</p></a></li>
<li><a href='#heights'>
<p>Heights</p></a></li>
<li><a href='#idn'>
<p>Multidimensional evaluation on posets (Identification Function only)</p></a></li>
<li><a href='#incidence2cover'>
<p>incidence2cover</p></a></li>
<li><a href='#incomparability'>
<p>Incomparability between profiles</p></a></li>
<li><a href='#is.downset'>
<p>is.downset</p></a></li>
<li><a href='#is.linext'>
<p>is.linext</p></a></li>
<li><a href='#is.partialorder'>
<p>is.partialorder</p></a></li>
<li><a href='#is.preorder'>
<p>is.preorder</p></a></li>
<li><a href='#is.upset'>
<p>is.upset</p></a></li>
<li><a href='#latex'>
<p>latex</p></a></li>
<li><a href='#LE'>
<p>Linear extensions</p></a></li>
<li><a href='#LE2incidence'>
<p>Computes the incidence matrices of lexicographic linear extensions of a profile poset.</p></a></li>
<li><a href='#levels.incidence+20and+20levels.cover'>
<p>Levels of a poset</p></a></li>
<li><a href='#lingen'>
<p>lingen</p></a></li>
<li><a href='#linzeta'>
<p>linzeta</p></a></li>
<li><a href='#maximal'>
<p>Maximal elements of a poset.</p></a></li>
<li><a href='#merge.wprof'>
<p>Merge two sets of profiles.</p></a></li>
<li><a href='#minimal'>
<p>Minimal elements of a poset</p></a></li>
<li><a href='#mrg'>
<p>Merge posets</p></a></li>
<li><a href='#MRP'>
<p>Mutial ranking probability matrix</p></a></li>
<li><a href='#MRPlex'>
<p>Mutual ranking probabilities on the lexicographic linear extensions set</p></a></li>
<li><a href='#mypackage-internal'><p>Internal parsec Functions</p></a></li>
<li><a href='#obsprof'>
<p>Remove unobserved profiles.</p></a></li>
<li><a href='#parsec2igraph'>
<p>Converting a partial order to an object of the package <code>igraph</code>.</p></a></li>
<li><a href='#plot.average_ranks'>
<p>Method of function <code>plot</code> for objects of class <code>average_ranks</code></p></a></li>
<li><a href='#plot.cover'>
<p>Hasse diagram</p></a></li>
<li><a href='#plot.parsec'>
<p>Plot the outputs of the PARSEC function <code>evaluation</code>.</p></a></li>
<li><a href='#plot.rank_stability'>
<p>Plot outputs of PARSEC function <code>rank_stability.</code></p></a></li>
<li><a href='#pop2prof'>
<p>Population to profiles</p></a></li>
<li><a href='#popelem'>
<p>popelem</p></a></li>
<li><a href='#proFreq'>
<p>Observed profile frequencies</p></a></li>
<li><a href='#rank_stability'>
<p>Rank stability analysis in posetic FOD</p></a></li>
<li><a href='#reflexivity'>
<p>reflexivity</p></a></li>
<li><a href='#rmProfiles'>
<p>Removing profiles</p></a></li>
<li><a href='#summary.cover'>
<p>Summary method for cover and incidence objects.</p></a></li>
<li><a href='#summary.parsec'>
<p>Summary of outputs of the evaluation function.</p></a></li>
<li><a href='#transitiveClosure'>
<p>Transitive Closure</p></a></li>
<li><a href='#transitivity'>
<p>transitivity</p></a></li>
<li><a href='#upset'>
<p>upset</p></a></li>
<li><a href='#validate.partialorder.incidence'>
<p>validate.partialorder.incidence</p></a></li>
<li><a href='#var2prof'>
<p>Variables to profiles</p></a></li>
<li><a href='#vertices'>
<p>Coordinates of the vertices of the Hasse diagram, representing the input cover relation.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.2.7</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-19</td>
</tr>
<tr>
<td>Title:</td>
<td>Partial Orders in Socio-Economics</td>
</tr>
<tr>
<td>Author:</td>
<td>Alberto Arcagni [aut, cre],
  Marco Fattore [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alberto Arcagni &lt;alberto.arcagni@uniroma1.it&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements tools for the analysis of partially ordered data, with a particular focus on the evaluation of multidimensional systems of indicators and on the analysis of poverty. References, Fattore M. (2016) &lt;<a href="https://doi.org/10.1007%2Fs11205-015-1059-6">doi:10.1007/s11205-015-1059-6</a>&gt; Fattore M., Arcagni A. (2016) &lt;<a href="https://doi.org/10.1007%2Fs11205-016-1501-4">doi:10.1007/s11205-016-1501-4</a>&gt; Arcagni A. (2017) &lt;<a href="https://doi.org/10.1007%2F978-3-319-45421-4_19">doi:10.1007/978-3-319-45421-4_19</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>igraph, netrankr, methods</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-19 13:01:35 UTC; alber</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-19 13:40:02 UTC</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
</table>
<hr>
<h2 id='parsec-package'>
PARtial orders in Socio-EConomics
</h2><span id='topic+parsec-package'></span><span id='topic+parsec'></span>

<h3>Description</h3>

<p>The package implements tools for the analysis of partially ordered data, with a particular focus on the evaluation of multidimensional systems of indicators and on the analysis of poverty.
</p>
<p>Its main objective is to provide socio-economic scholars with an integrated set of elementary functions for multidimensional evaluation, based on ordinal information. In particular, it provides functions for data management and basic analysis of partial orders as well as other functions for the evaluation and application of both the poset-based approach and a more classic counting method.
</p>


<h3>Author(s)</h3>

<p>A, Arcagni
M, Fattore
</p>
<p>Maintainer: A, Arcagni &lt;alberto.arcagni@unimib.it&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###########################################
# a simple example of package application #
###########################################

# definition of the variables by their number of grades
variables &lt;- c(2, 2, 2)

# definition of the threshold
threshold &lt;- c("112", "211")

# extraction of all of the possible profiles from variables; the
# function returns an object of class "wprof", weighted profiles: by default,
# weigths/frequencies are set equal to 1
profiles &lt;- var2prof(varlen = variables)

# the following function creates matrices describing the poset, and
# provides all the results related to it
eval &lt;- evaluation(profiles, threshold, nit = 10^5, maxint = 10^3)

# The results can then be summarized

summary(summary(eval))

# a method of the plot function returns the Hasse diagram, a frequency 
# distribution of the threshold, the identification function, the rank
# distribution of each profile through a barplot, and the relative gap.
plot(eval)

#########################################################
# a second example of new functions recently introduced #
#########################################################

# definition of the variables and of the corresponding profiles
v1 &lt;- as.ordered(c("a", "b", "c", "d"))
v2 &lt;- 1:3
prof &lt;- var2prof(varmod = list(v1 = as.ordered(c("a", "b", "c", "d")), v2 = 1:3))
np &lt;- nrow(prof$profiles)

# definition of different distributions over the set of profiles
k &lt;- 10 # number of populations
set.seed(0)
populations &lt;- as.data.frame(lapply(1:k, function(x) round(runif(np)*100)))
rownames(populations) &lt;- rownames(prof$profiles)
names(populations) &lt;- paste0("P", 1:k)

prof
populations

# evaluation of the fuzzy first order dominance
res &lt;- FFOD(profiles = prof, distributions = populations)
res

# rank stablity analysis
res &lt;- rank_stability(res)
res

# graphical representation
plot(res)
</code></pre>

<hr>
<h2 id='AF'>
OPHI counting approach
</h2><span id='topic+AF'></span><span id='topic+AF.default'></span><span id='topic+AF.wprof'></span>

<h3>Description</h3>

<p>The function implements the OPHI
counting approach, in a single call. The implementation is limited to ordinal attributes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AF(y, ...)
## Default S3 method:
AF(y, z, w=rep(1, ncol(y)), k=sum(w), freq=rep(1, nrow(y)), ...)
## S3 method for class 'wprof'
AF(y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AF_+3A_y">y</code></td>
<td>

<p>matrix of profiles, possibly substituted by an object of class <code>wprof</code>.
</p>
</td></tr>
<tr><td><code id="AF_+3A_z">z</code></td>
<td>

<p>vector of attribute cutoffs.
</p>
</td></tr>
<tr><td><code id="AF_+3A_w">w</code></td>
<td>

<p>variables' weights.
</p>
</td></tr>
<tr><td><code id="AF_+3A_k">k</code></td>
<td>

<p>overall cutoff.
</p>
</td></tr>
<tr><td><code id="AF_+3A_freq">freq</code></td>
<td>

<p>profiles' frequencies; the argument can be omitted if <code>y</code> is an object of class <code>wprof</code>.
.
</p>
</td></tr>
<tr><td><code id="AF_+3A_...">...</code></td>
<td>

<p>any of the above.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of S3 class <code>ophi</code> containing all the outputs related to the OPHI counting approach. The object is a <code>list</code>
comprising:
</p>
<table>
<tr><td><code>y</code></td>
<td>

<p>matrix of profiles,
</p>
</td></tr>
<tr><td><code>freq</code></td>
<td>

<p>profiles' frequencies,
</p>
</td></tr>
<tr><td><code>d</code></td>
<td>

<p>number of variables
</p>
</td></tr>
<tr><td><code>n</code></td>
<td>

<p>number of observations (sum of frequencies),
</p>
</td></tr>
<tr><td><code>z</code></td>
<td>

<p>vector of cutoffs,
</p>
</td></tr>
<tr><td><code>k</code></td>
<td>

<p>overall cutoff,
</p>
</td></tr>
<tr><td><code>rho</code></td>
<td>

<p>function comparing profiles to the vector of cutoffs,
</p>
</td></tr>
<tr><td><code>rho_k</code></td>
<td>

<p>function comparing profiles to the overall cutoff, by weighting
variables,
</p>
</td></tr>
<tr><td><code>g0</code></td>
<td>

<p>profile-variable matrix reporting the output of function
<code>rho</code>,
</p>
</td></tr>
<tr><td><code>c</code></td>
<td>

<p>censored vector of deprivation counts,
</p>
</td></tr>
<tr><td><code>Z_k</code></td>
<td>

<p>boolean vector identifying deprived profiles, according to the specified cutoffs,
</p>
</td></tr>
<tr><td><code>q</code></td>
<td>

<p>number of poor statstical units in the population,
</p>
</td></tr>
<tr><td><code>H</code></td>
<td>

<p>headcount ratio, i.e. <code>q/n</code>, where <code>n</code> is the number of statistical units in the population,
</p>
</td></tr>
<tr><td><code>A</code></td>
<td>

<p>average deprivation share,
</p>
</td></tr>
<tr><td><code>M0</code></td>
<td>

<p>adjusted headcount ratio.
</p>
</td></tr>
</table>


<h3>References</h3>

<p>Alkire S., Foster J. (2011), Counting and multidimensional poverty measurement, Journal of Public Economics, 96(7-8), 476-487.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vl &lt;- c(2, 3, 3, 2)
prof &lt;- var2prof(varlen = vl)

res &lt;- AF(prof, z = c(1, 2, 1, 1), k = 1)

res
</code></pre>

<hr>
<h2 id='AF2threshold'>
Poset threshold making the poset approach equivalent to the AF counting approach
</h2><span id='topic+AF2threshold'></span>

<h3>Description</h3>

<p>The function computes the threshold in the profile poset, which makes the poset approach equivalent to the AF counting approach, described in
argument <code>mpi</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AF2threshold(mpi, prof, zeta = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AF2threshold_+3A_mpi">mpi</code></td>
<td>

<p>an object of class <code>ophi</code>, see <code><a href="#topic+AF">AF</a></code> for details.
</p>
</td></tr>
<tr><td><code id="AF2threshold_+3A_prof">prof</code></td>
<td>

<p>an object of class <code>wprof</code>.
</p>
</td></tr>
<tr><td><code id="AF2threshold_+3A_zeta">zeta</code></td>
<td>

<p>an object of class <code>incidence</code>.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+AF">AF</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vl &lt;- c(2, 3, 2)
prof &lt;- var2prof(varlen = vl, labtype = "progressive")

res &lt;- AF(prof, z = c(1, 2, 1), k = 1)

thr &lt;- AF2threshold(res, prof)

plot(prof, col = 1 + thr, lwd = 1 + res$c,
     main = "Comparison between OPHI and parsec",
     sub = "bold: deprived profiles identified by OPHI, red: parsec threshold")

eval &lt;- evaluation(prof, thr, maxint = 10^4, nit = 10^7)

ord &lt;- order(eval$idn_f, res$c)
plot(eval$idn_f[ord], col = "red", lwd=2, type = "l", xlab="",
     ylab = "", axes = FALSE, frame.plot = TRUE,
     main = "Comparison between OPHI and parsec",
     sub = "red: identification function, black: OPHI deprived profiles")
points(res$c[ord], type="l", lwd=2)
axis(2)
</code></pre>

<hr>
<h2 id='antisymmetry'>
antisymmetry
</h2><span id='topic+antisymmetry'></span>

<h3>Description</h3>

<p>The function checks whether boolean square matrix <code>m</code> represents an antisymmetric binary relation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>antisymmetry(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="antisymmetry_+3A_m">m</code></td>
<td>

<p>a square matrix.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+transitivity">transitivity</a></code>, <code><a href="#topic+binary">binary</a></code>, <code><a href="#topic+reflexivity">reflexivity</a></code>,
</p>
<p><code><a href="#topic+is.preorder">is.preorder</a></code>, <code><a href="#topic+is.partialorder">is.partialorder</a></code>,
</p>
<p><code><a href="#topic+validate.partialorder.incidence">validate.partialorder.incidence</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- c(TRUE, FALSE, FALSE, FALSE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, TRUE,
FALSE, TRUE, TRUE, TRUE, TRUE)
M &lt;- matrix(M, 4, 4)
rownames(M) &lt;- colnames(M) &lt;- LETTERS[1:4]

antisymmetry(M)
</code></pre>

<hr>
<h2 id='average_ranks'>
Average Ranks
</h2><span id='topic+average_ranks'></span><span id='topic+average_ranks.incidence'></span><span id='topic+average_ranks.cover'></span>

<h3>Description</h3>

<p>The function evaluates the average rank, and other distribution details, for each element of the poset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>average_ranks(x, ...)
## S3 method for class 'cover'
average_ranks(x, level = 0.9, error = 10^(-5), ...)
## S3 method for class 'incidence'
average_ranks(x, level = 0.9, error = 10^(-5), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="average_ranks_+3A_x">x</code></td>
<td>

<p>an incidence or cover matrix representing a partial order.
</p>
</td></tr>
<tr><td><code id="average_ranks_+3A_level">level</code></td>
<td>

<p>coverage probability of the rank intervals.
</p>
</td></tr>
<tr><td><code id="average_ranks_+3A_error">error</code></td>
<td>

<p>the &quot;distance&quot; from uniformity in the sampling distribution of linear extensions used to evaluate the average ranks. See <code><a href="#topic+idn">idn</a></code> for details.
</p>
</td></tr>
<tr><td><code id="average_ranks_+3A_...">...</code></td>
<td>

<p>any of above.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function computes the rank distribution for each element of the poset, through function <code><a href="#topic+idn">idn</a></code>. Next, it checks whether there are any equivalent profiles, using function <code><a href="#topic+equivalences">equivalences</a></code>, and makes their rank distribution equal. Finally it provides a dataframe comprising, for each element of the poset: the average rank <code>avrg</code>, the extremes <code>inf</code> and <code>sup</code> of the rank interval, the effective coverage probability of the rank interval <code>prob</code>, the estimated minimum and maximum rank values (<code>min</code> and <code>max</code>) and the rank <code>range</code>.
</p>
<p>The output is a dataframe of class <code>average_ranks</code> /for which a method of function <code>plot</code> is available. See <code><a href="#topic+plot.average_ranks">plot.average_ranks</a></code> for details).
</p>


<h3>Value</h3>

<p>A dataframe of class <code>average_ranks</code> whose columns are:
</p>
<table>
<tr><td><code>avrg</code></td>
<td>
<p>the average rank;</p>
</td></tr>
<tr><td><code>inf</code></td>
<td>
<p>the lower extreme of the rank interval;</p>
</td></tr>
<tr><td><code>sup</code></td>
<td>
<p>the upper extreme of the rank interval;</p>
</td></tr>
<tr><td><code>prob</code></td>
<td>
<p>the effective coverage probability of the rank interval;</p>
</td></tr>
<tr><td><code>min</code></td>
<td>
<p>the minimum rank;</p>
</td></tr>
<tr><td><code>max</code></td>
<td>
<p>the maximum rank;</p>
</td></tr>
<tr><td><code>range</code></td>
<td>
<p>the rank range.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Fattore M., Arcagni A.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+idn">idn</a></code>, <code><a href="#topic+equivalences">equivalences</a></code>, <code><a href="#topic+plot.average_ranks">plot.average_ranks</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>profiles &lt;- var2prof(varlen = c(3, 2, 2))
Z &lt;- getzeta(profiles)
res &lt;- average_ranks(Z)
plot(res)
</code></pre>

<hr>
<h2 id='binary'>
binary
</h2><span id='topic+binary'></span>

<h3>Description</h3>

<p>The function checks whether square matrix <code>m</code> represents a binary relation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binary(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binary_+3A_m">m</code></td>
<td>

<p>a square matrix.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+transitivity">transitivity</a></code>, <code><a href="#topic+reflexivity">reflexivity</a></code>,
</p>
<p><code><a href="#topic+antisymmetry">antisymmetry</a></code>, <code><a href="#topic+is.preorder">is.preorder</a></code>,
</p>
<p><code><a href="#topic+is.partialorder">is.partialorder</a></code>, <code><a href="#topic+validate.partialorder.incidence">validate.partialorder.incidence</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- c(TRUE, FALSE, FALSE, FALSE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, TRUE,
FALSE, TRUE, TRUE, TRUE, TRUE)
M &lt;- matrix(M, 4, 4)
rownames(M) &lt;- colnames(M) &lt;- LETTERS[1:4]

binary(M)
</code></pre>

<hr>
<h2 id='colevels'>
Colevels of a poset
</h2><span id='topic+colevels'></span><span id='topic+colevels.cover'></span><span id='topic+colevels.incidence'></span>

<h3>Description</h3>

<p>The function returns colevels associated to poset elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colevels(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colevels_+3A_y">y</code></td>
<td>

<p>an object of class <code>cover</code> or <code>incidence</code>.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>vl &lt;- c(3, 2, 4)
prof &lt;- var2prof(varlen = vl)
Z &lt;- getzeta(prof)

colevels(Z)
</code></pre>

<hr>
<h2 id='cover2incidence'>
cover2incidence
</h2><span id='topic+cover2incidence'></span><span id='topic+cover2incidence.cover'></span>

<h3>Description</h3>

<p>The function computes the incidence matrix of a poset from its cover matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cover2incidence(g)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cover2incidence_+3A_g">g</code></td>
<td>

<p>a cover matrix, an object of class <code>cover</code>
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the corresponding incidence matrix, an object of class
<code>incidence</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+incidence2cover">incidence2cover</a></code>
</p>

<hr>
<h2 id='depths'>
Depths
</h2><span id='topic+depths'></span><span id='topic+depths.cover'></span><span id='topic+depths.incidence'></span>

<h3>Description</h3>

<p>The function computes the depths of poset elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depths(z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="depths_+3A_z">z</code></td>
<td>

<p>an object of class <code>cover</code> or <code>incidence</code>.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>vl &lt;- c(3, 2, 4)
prof &lt;- var2prof(varlen = vl)
Z &lt;- getzeta(prof)

depths(Z)
</code></pre>

<hr>
<h2 id='downset'>
downset
</h2><span id='topic+downset'></span><span id='topic+downset.incidence'></span><span id='topic+downset.cover'></span>

<h3>Description</h3>

<p>The function computes a boolean vector identifying the poset elements below (or equal to) at least one element of the input subset <code>Q</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>downset(z, ...)
## S3 method for class 'cover'
downset(z, ...)
## S3 method for class 'incidence'
downset(z, Q = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="downset_+3A_z">z</code></td>
<td>

<p>a cover, or an incidence, matrix of S3 class <code>cover</code> or <code>incidence</code> respectively
</p>
</td></tr>
<tr><td><code id="downset_+3A_q">Q</code></td>
<td>

<p>vector of indices identifying a subset of poset profiles
</p>
</td></tr>
<tr><td><code id="downset_+3A_...">...</code></td>
<td>

<p>any of the above.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- getzeta(var2prof(varlen = c(2, 2, 2)))

plot(z, col = 1 + c(1, 1, 0, 0, 1, 0, 0, 0) + c(0, 0, 0, 2, 0, 0, 2, 2), lwd = 2)

Q &lt;- c(4, 7, 8)
rownames(z)[Q]
downset(z, Q)

Q &lt;- c("211", "112", "111")
downset(z, Q)
</code></pre>

<hr>
<h2 id='drawedges'>
drawedges
</h2><span id='topic+drawedges'></span>

<h3>Description</h3>

<p>Graphical function called by <code><a href="#topic+plot.cover">plot.cover</a></code> to draw the edges of the
Hasse diagram representing the input cover matrix <code>C</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawedges(C, vertices, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drawedges_+3A_c">C</code></td>
<td>

<p>cover matrix.
</p>
</td></tr>
<tr><td><code id="drawedges_+3A_vertices">vertices</code></td>
<td>

<p>coordinates of the vertices obtained by function <code><a href="#topic+vertices">vertices</a></code>.
</p>
</td></tr>
<tr><td><code id="drawedges_+3A_...">...</code></td>
<td>

<p>line parameters, see <code><a href="graphics.html#topic+graphics">graphics</a>{lines}</code>.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+plot.cover">plot.cover</a></code>, <code><a href="#topic+vertices">vertices</a></code>, <code><a href="graphics.html#topic+graphics">graphics</a>{lines}</code>
</p>

<hr>
<h2 id='equivalences'>
Equivalence classes in a poset.
</h2><span id='topic+equivalences'></span><span id='topic+equivalences.cover'></span><span id='topic+equivalences.incidence'></span>

<h3>Description</h3>

<p>The function computes the set of poset elements sharing the same upset and downset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>equivalences(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="equivalences_+3A_x">x</code></td>
<td>

<p>an object of class <code>incidence</code> or <code>cover</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function computes a vector assigning an equivalence class to each profile. The vector is of class <code>factor</code>.
</p>


<h3>Author(s)</h3>

<p>Arcagni A.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Lmbd &lt;- getlambda(A &gt; B, A &gt; C, B &gt; D, A &gt; E, B &gt; E, C &gt; F, C &gt; G)
res &lt;- equivalences(Lmbd)

equivalence_classes &lt;- levels(res)
colrs &lt;- sapply(res, function(x) which(equivalence_classes == x)) + 1
plot(Lmbd, col = colrs, lwd = 2)
</code></pre>

<hr>
<h2 id='evaluation'>
Multidimensional evaluation on posets
</h2><span id='topic+evaluation'></span><span id='topic+inequality'></span><span id='topic+C_bd'></span><span id='topic+C_linzeta'></span>

<h3>Description</h3>

<p>Given a partial order (arguments <code>profiles</code> and/or
<code>zeta</code>) and a selected <code>threshold</code>,
the function returns an object of S3 class <code>parsec</code>, comprising the identification function and
different severity measures, computed by uniform sampling of the linear extensions of the poset, through a C implementation of the Bubley - Dyer (1999) algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluation(
    profiles = NULL,
    threshold,
    error = 10^(-3),
    zeta = getzeta(profiles),
    weights = {
        if (!is.null(profiles)) 
            profiles$freq
        else rep(1, nrow(zeta))
    },
    distances = {
        n &lt;- nrow(zeta)
        matrix(1, n, n) - diag(1, n)
    },
    linext = lingen(zeta),
    nit = floor({
        n &lt;- nrow(zeta)
        n^5 * log(n) + n^4 * log(error^(-1))
    }),
    maxint = 2^31 - 1,
    inequality = FALSE
)
inequality(profiles = NULL, zeta = getzeta(profiles), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluation_+3A_profiles">profiles</code></td>
<td>

<p>an object of S3 class <code>wprof</code>.
</p>
</td></tr>
<tr><td><code id="evaluation_+3A_threshold">threshold</code></td>
<td>

<p>a vector identifying the threshold. It can be a vector of indexes (numeric),
a vector of profile names (character) or a boolean vector of length equal to the number of
profiles. Function <code>inequality</code> does not require its definition since its results do not depend on it.
</p>
</td></tr>
<tr><td><code id="evaluation_+3A_error">error</code></td>
<td>

<p>the &quot;distance&quot; from uniformity in the sampling distribution of linear extensions.
</p>
</td></tr>
<tr><td><code id="evaluation_+3A_zeta">zeta</code></td>
<td>

<p>the incidence matrix of the poset. An object of S3 class <code>incidence</code>.
By default, extracted from <code>profiles</code>.
</p>
</td></tr>
<tr><td><code id="evaluation_+3A_weights">weights</code></td>
<td>

<p>weights assigned to profiles. If the argument <code>profiles</code> is not <code>NULL</code>,
weights are by default set equal to profile frequencies, otherwise they are
set equal to 1.
</p>
</td></tr>
<tr><td><code id="evaluation_+3A_distances">distances</code></td>
<td>

<p>matrix of distances between pairs of profiles. The matrix must be square, with dimensions
equal to the number of profiles. Even if the poset is
complete, the distance between two profiles is computed only if one
profile covers the other.
</p>
</td></tr>
<tr><td><code id="evaluation_+3A_linext">linext</code></td>
<td>

<p>the linear extension initializing the sampling algorithm. By default, it is generated by <code>lingen(zeta)</code>. Alternatively, it can be provided by 
the user through a vector of profile positions.
</p>
</td></tr>
<tr><td><code id="evaluation_+3A_nit">nit</code></td>
<td>

<p>Number of ITerations in the Bubley-Dyer algorithm, by default evaluated from a formula of Karzanov and Khachiyan
based on the number of profiles and the argument <code>error</code> (see Bubley and Dyer, 1999).
</p>
</td></tr>
<tr><td><code id="evaluation_+3A_maxint">maxint</code></td>
<td>

<p>Maximum integer. By default the maximum integer obtainable in a 32bit system.
This argument is used to group iterations and run the compiled
C code more times, so as to avoid memory indexing problems. Users can
set a lower value to <code>maxint</code> in case of low RAM availability.
</p>
</td></tr>
<tr><td><code id="evaluation_+3A_inequality">inequality</code></td>
<td>

<p>boolean parameter (by default <code>FALSE</code>) to make the evaluation function return also a measure of inequality (which can make computations quite lengthy). It is <code>TRUE</code> in function <code>inequality</code> and can not be modified.
</p>
</td></tr>
<tr><td><code id="evaluation_+3A_...">...</code></td>
<td>

<p>further optional graphical parameters. See <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>profiles</code></td>
<td>
<p>an object of S3 class <code>wprof</code> reporting poset profiles
and their associated frequencies (number of statistical units in each profile).</p>
</td></tr>
<tr><td><code>number_of_profiles</code></td>
<td>
<p>number of profiles.</p>
</td></tr>
<tr><td><code>number_of_variables</code></td>
<td>
<p>number of variables.</p>
</td></tr>
<tr><td><code>incidence</code></td>
<td>
<p>S3 class <code>incidence</code>, incidence matrix of the poset.</p>
</td></tr>
<tr><td><code>cover</code></td>
<td>
<p>S3 class <code>cover</code>, cover matrix of the poset.</p>
</td></tr>
<tr><td><code>threshold</code></td>
<td>
<p>boolean vector specifying whether a profile belongs to the threshold.</p>
</td></tr>
<tr><td><code>number_of_iterations</code></td>
<td>
<p>number of iterations performed by the Bubley-Dyer algorithm.</p>
</td></tr>
<tr><td><code>rank_dist</code></td>
<td>
<p>matrix reporting by rows the relative
frequency distributions of the ranks of each profile, over the set of sampled linear extensions.</p>
</td></tr>
<tr><td><code>thr_dist</code></td>
<td>
<p>vector reporting the relative frequency a profile is used as threshold in the sampled linear extensions.</p>
</td></tr>
<tr><td><code>prof_w</code></td>
<td>
<p>vector of weights assigned to each profile.</p>
</td></tr>
<tr><td><code>edg_w</code></td>
<td>
<p>matrix of distances between profiles, used to evaluate the
gap measures.</p>
</td></tr>
<tr><td><code>idn_f</code></td>
<td>
<p>vector reporting the identification function, computed as the fraction of sampled linear extensions where a profile is in the downset of the threshold.</p>
</td></tr>
<tr><td><code>svr_abs</code></td>
<td>
<p>vector reporting, for each profile, the average graph distance
from the first profile above all threshold elements, over the sampled linear extensions.
In each linear extension, the distance is set equal to 0 for profiles above the threshold.</p>
</td></tr>
<tr><td><code>svr_rel</code></td>
<td>
<p>equal to svr_abs divided by its
maximum, that is svr_abs of the minimal element in the linear extension.</p>
</td></tr>
<tr><td><code>wea_abs</code></td>
<td>
<p>vector reporting, for each profile, the average graph distance
from the maximum threshold element, over the sampled linear extensions.
In each linear extension, the distance is set equal to 0 for profiles in the downset of threshold elements.</p>
</td></tr>
<tr><td><code>wea_rel</code></td>
<td>
<p>the previous absolute distance is divided by its
maximum possible value, that is the absolute distance of the threshold
from the maximal element in the linear extension.</p>
</td></tr>
<tr><td><code>poverty_gap</code></td>
<td>
<p>Population mean of svr_rel</p>
</td></tr>
<tr><td><code>wealth_gap</code></td>
<td>
<p>Population mean of wea_rel</p>
</td></tr>
<tr><td><code>inequality</code></td>
<td>
<p>when the argument <code>inequality</code> is <code>TRUE</code>, the average value of the inequality index over the linear extensions (see Fattore and Arcagni, 2013). Function <code>inequalty</code> returns only this result.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Bubley R., Dyer M. (1999), Faster random generation of linear extensions, Discrete Math., 201, 81-88.
</p>
<p>Fattore M., Arcagni A. (2013), Measuring multidimensional polarization with ordinal data, SIS 2013 Statistical Conference, BES-M3.1 - The BES and the challenges of constructing composite indicators dealing with equity and sustainability
</p>


<h3>Examples</h3>

<pre><code class='language-R'>profiles &lt;- var2prof(varlen = c(3, 2, 2))
threshold &lt;- c("311", "112")

res &lt;- evaluation(profiles, threshold, maxint = 10^5)

summary(res)
plot(res)
</code></pre>

<hr>
<h2 id='FOD'>
Fuzzy First Order Domninance analysis on partial orders
</h2><span id='topic+FOD'></span><span id='topic+FOD.wprof'></span><span id='topic+FFOD'></span><span id='topic+FFOD.wprof'></span>

<h3>Description</h3>

<p>The function <code>FOD</code> performs the Fuzzy First Order Dominance analysis described in Fattore and Arcagni (forthcoming).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FFOD(profiles, ...)
## S3 method for class 'wprof'
FFOD(profiles,
    distributions = as.data.frame(profiles$freq),
    lambda = do.call(
        getlambda, as.list(names(profiles$profiles))
    ),
    alpha = NULL, ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FOD_+3A_profiles">profiles</code></td>
<td>

<p>an object of class <code>wprof</code>.
</p>
</td></tr>
<tr><td><code id="FOD_+3A_distributions">distributions</code></td>
<td>

<p>a <code>data.frame</code> of frequencies/weights where the columns correspond to the different distributions and the rows to the profiles. The profiles in the rows have to be ordered as in <code>profiles</code>.
</p>
</td></tr>
<tr><td><code id="FOD_+3A_lambda">lambda</code></td>
<td>

<p>object of class <code>incidence</code> representing the partial order of the relative importance of the indicators. By default, the lambda poset is an antichain ( i.e. all the indicators are considered equi-important).
</p>
</td></tr>
<tr><td><code id="FOD_+3A_alpha">alpha</code></td>
<td>

<p>vector of values to cut the <code>mintr.delta</code> matrix to generate the posets in the list <code>covers</code>. Default is <code>NULL</code> posets are generated for each different value in matrix <code>mintr.delta</code>.  See section 'Value' below.
</p>
</td></tr>
<tr><td><code id="FOD_+3A_...">...</code></td>
<td>

<p>any of above.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function requires the set of profiles, through the object <code>profiles</code> of class <code>wprof</code>, and the corresponding frequencies, which can be defined by the argument <code>distributions</code> of class <code>data.frame</code>.
</p>
<p>Notice that a warning is provided if the <code>rownames</code> of the distributions do not match the <code>rownamens</code> of the profiles.
</p>
<p>Through poset <code>lambda</code>, it is possible to provide (ordinal) information on the relative importance of the indicators in the multi-indicator system.
</p>


<h3>Value</h3>

<p>An object of class <code>FODposet</code> containing:
</p>
<table>
<tr><td><code>delta</code></td>
<td>
<p>matrix of the overall dominance degrees.</p>
</td></tr>
<tr><td><code>mintr.delta</code></td>
<td>
<p>matrix of the min-transitive closure of matrix <code>delta</code>.</p>
</td></tr>
<tr><td><code>global.approx</code></td>
<td>
<p>L1 distance between <code>delta</code> and <code>mintr.delta</code>, divided by the L1 norm of <code>delta</code>.</p>
</td></tr>
<tr><td><code>global.approx.corr</code></td>
<td>
<p>L1 distance between <code>delta</code> and <code>mintr.delta</code>, divided by the L1 norm of <code>delta</code> after removing its diagonal.</p>
</td></tr>
<tr><td><code>cell.approx</code></td>
<td>
<p>matrix of absolute differences between the elements of <code>delta</code> and the elements of <code>mintr.delta</code>.</p>
</td></tr>
<tr><td><code>posets.ind</code></td>
<td>
<p><code>data.frame</code> with indicators describing the partial orders obtained as alpha-cuts of the min-transitive closure <code>mintr.delta</code>. For each poset, the data frame provides: its <code>cardinality</code>, the number of <code>comparabilities</code>, the number of <code>incomparabilities</code> and their ratio (<code>ci.ratio</code>).</p>
</td></tr>
<tr><td><code>eqv.classes</code></td>
<td>
<p>list of boolean matrices specifying, for each alpha-cut, the equivalence classes of the input distributions. Equivalence classes are reported by rows and the initial distributions by columns. If element ij of the matrix is <code>TRUE</code>, then distribution j  belongs to the i-th equivalence class.</p>
</td></tr>
<tr><td><code>covers</code></td>
<td>
<p>list of objects of class <code>cover</code> comprising the cover matrices of the poset generated by each alpha-cut of <code>mintr.delta</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Fattore M., Arcagni A.
</p>


<h3>References</h3>

<p>Fattore M., Arcagni A. (forthcoming), F-FOD: Fuzzy First Order Dominance analysis and populations ranking over ordinal multi-indicator systems.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v1 &lt;- as.ordered(c("a", "b", "c", "d"))
v2 &lt;- 1:3
prof &lt;- var2prof(varmod = list(v1 = as.ordered(c("a", "b", "c", "d")), v2 = 1:3))
np &lt;- nrow(prof$profiles)

k &lt;- 10 # number of populations
set.seed(0)
populations &lt;- as.data.frame(lapply(1:k, function(x) round(runif(np)*100)))
rownames(populations) &lt;- rownames(prof$profiles)
names(populations) &lt;- paste0("P", 1:k)

prof
populations

res &lt;- FFOD(profiles = prof, distributions = populations)
res
</code></pre>

<hr>
<h2 id='gen.downset'>
Antichain generating a given downset
</h2><span id='topic+gen.downset'></span>

<h3>Description</h3>

<p>The function returns the antichain generating the input downset <code>Q</code>, given the incidence matrix <code>z</code> of the poset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.downset(z, Q = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.downset_+3A_z">z</code></td>
<td>

<p>an incidence matrix.
</p>
</td></tr>
<tr><td><code id="gen.downset_+3A_q">Q</code></td>
<td>

<p>a vector (<code>boolean</code>, <code>numeric</code> indexing elements,
or <code>character</code> with elements' names) identifying the input downset.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>boolean</code> vector.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.upset">gen.upset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lv &lt;- c(2, 3, 2)
prof &lt;- var2prof(varlen = lv)

z &lt;- getzeta(prof)
down &lt;- c("111", "211", "112", "212")
gen &lt;- gen.downset(z, down)

plot(z, lwd = 1 + (rownames(prof$profiles)%in%down), col = 1 + gen,
sub = "bold = the downset, red = the antichain generating the downset")
</code></pre>

<hr>
<h2 id='gen.upset'>
Antichain generating a given upset
</h2><span id='topic+gen.upset'></span>

<h3>Description</h3>

<p>The function returns the antichain generating the input upset <code>Q</code>, given the incidence matrix <code>z</code> of the poset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen.upset(z, Q = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen.upset_+3A_z">z</code></td>
<td>

<p>an incidence matrix.
</p>
</td></tr>
<tr><td><code id="gen.upset_+3A_q">Q</code></td>
<td>

<p>a vector (<code>boolean</code>, <code>numeric</code> indexing elements,
or <code>character</code> with elements' names) identifying the input upset.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>boolean</code> vector.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+gen.downset">gen.downset</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lv &lt;- c(2, 3, 2)
prof &lt;- var2prof(varlen = lv)

z &lt;- getzeta(prof)
up &lt;- c("221", "131", "231", "222", "132", "232")
gen &lt;- gen.upset(z, up)

plot(z, lwd = 1 + (rownames(prof$profiles)%in%up), col = 1 + gen,
sub = "bold = the upset, red = the antichain generating the upset")
</code></pre>

<hr>
<h2 id='getlambda'>
Object constructor for the incidence matrix representing a partial order on variables.
</h2><span id='topic+getlambda'></span>

<h3>Description</h3>

<p>The function creates an object of class <code>incidence</code> representing a partial order on the set of variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getlambda(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getlambda_+3A_...">...</code></td>
<td>

<p>Cover relations between variable pairs.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Cover relations between pair of ariables are defined by the names of the two variables and the symbols <code>&lt;</code> and <code>&gt;</code>. For instance, if variable A is covered by variable B, write the cover relation as <code>A &lt; B</code> or <code>B &gt; A</code>. If a variable is not comparable to the others, write the name of the variable alone.
</p>


<h3>Value</h3>

<p>an object of class <code>incidence</code>.
</p>


<h3>Author(s)</h3>

<p>Alberto Arcagni
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.cover">plot.cover</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    Lambda &lt;- getlambda(BOTTOM &lt; A, B &gt; BOTTOM, INCOMP)
    plot(Lambda)
</code></pre>

<hr>
<h2 id='getzeta'>
Incidence matrix generation
</h2><span id='topic+getzeta'></span><span id='topic+getzeta.wprof'></span>

<h3>Description</h3>

<p>The function computes the incidence matrix from the set of input profiles <code>y</code>.
The output is a boolean matrix of S3 class <code>incidence</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getzeta(y)
## S3 method for class 'wprof'
getzeta(y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getzeta_+3A_y">y</code></td>
<td>

<p>the set of profiles, an object of S3 class <code>wprof</code>.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>prf &lt;- var2prof(varlen = c(2, 3))
getzeta(prf)
</code></pre>

<hr>
<h2 id='heights'>
Heights
</h2><span id='topic+heights'></span><span id='topic+heights.cover'></span><span id='topic+heights.incidence'></span><span id='topic+height.poset'></span>

<h3>Description</h3>

<p>The function computes the vector of heights of poset elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>heights(z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="heights_+3A_z">z</code></td>
<td>

<p>an object of class <code>cover</code>, <code>incidence</code> or <code>poset</code>.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>vl &lt;- c(3, 2, 4)
prof &lt;- var2prof(varlen = vl)
Z &lt;- getzeta(prof)

heights(Z)
</code></pre>

<hr>
<h2 id='idn'>
Multidimensional evaluation on posets (Identification Function only)
</h2><span id='topic+idn'></span><span id='topic+C_bd_simp'></span>

<h3>Description</h3>

<p>Given a partial order (arguments <code>profiles</code> and/or
<code>zeta</code>) and a selected <code>threshold</code>,
the function computes the identification function, as a S3 class object <code>parsec</code>. The identification function is computed by uniform sampling of the linear extensions of the input poset, through a C implementation of the Bubley - Dyer (1999) algorithm. <a href="#topic+idn">idn</a> is a simplified and faster version of <a href="#topic+evaluation">evaluation</a>, computing just the identification function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>idn(
    profiles = NULL,
    threshold,
    error = 10^(-3),
    zeta = getzeta(profiles),
    weights = {
        if (!is.null(profiles)) 
            profiles$freq
        else rep(1, nrow(zeta))
    },
    linext = lingen(zeta),
    nit = floor({
        n &lt;- nrow(zeta)
        n^5 * log(n) + n^4 * log(error^(-1))
    }),
    maxint = 2^31 - 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="idn_+3A_profiles">profiles</code></td>
<td>

<p>an object of S3 class <code>wprof</code>.
</p>
</td></tr>
<tr><td><code id="idn_+3A_threshold">threshold</code></td>
<td>

<p>a vector identifying the threshold. It can be a vector of indexes (numeric),
a vector of poset element names (character) or a boolean vector of length equal to the number of
elements.
</p>
</td></tr>
<tr><td><code id="idn_+3A_error">error</code></td>
<td>

<p>the &quot;distance&quot; from uniformity in the sampling distribution of linear extensions.
</p>
</td></tr>
<tr><td><code id="idn_+3A_zeta">zeta</code></td>
<td>

<p>the incidence matrix of the poset. An object of S3 class <code>incidence</code>.
By default, extracted from <code>profiles</code>.
</p>
</td></tr>
<tr><td><code id="idn_+3A_weights">weights</code></td>
<td>

<p>weights assigned to profiles. If the argument <code>profiles</code> is not <code>NULL</code>,
weights are by default set equal to profile frequencies, otherwise they are
set equal to 1.
</p>
</td></tr>
<tr><td><code id="idn_+3A_linext">linext</code></td>
<td>

<p>the linear extension initializing the sampling algorithm. By default, it is generated by <code>lingen(zeta)</code>. Alternatively, it can be provided by 
the user through a vector of elements positions.
</p>
</td></tr>
<tr><td><code id="idn_+3A_nit">nit</code></td>
<td>

<p>Number of iterations in the Bubley-Dyer algorithm, by default evaluated using a formula of Karzanov and Khachiyan
based on the number of poset elements and the argument <code>error</code> (see Bubley and Dyer, 1999).
</p>
</td></tr>
<tr><td><code id="idn_+3A_maxint">maxint</code></td>
<td>

<p>Maximum integer. By default the maximum integer obtainable in a 32bit system.
This argument is used to group iterations and run the compiled
C code more times, so as to avoid memory indexing problems. User can
set a lower value to <code>maxint</code> in case of lower RAM availability.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>profiles</code></td>
<td>
<p>an object of S3 class <code>wprof</code> reporting poset profiles
and their associated frequencies (number of statistical units in each profile).</p>
</td></tr>
<tr><td><code>number_of_profiles</code></td>
<td>
<p>number of profiles.</p>
</td></tr>
<tr><td><code>number_of_variables</code></td>
<td>
<p>number of variables.</p>
</td></tr>
<tr><td><code>incidence</code></td>
<td>
<p>S3 class <code>incidence</code>, incidence matrix of the poset.</p>
</td></tr>
<tr><td><code>cover</code></td>
<td>
<p>S3 class <code>cover</code>, cover matrix of the poset.</p>
</td></tr>
<tr><td><code>threshold</code></td>
<td>
<p>boolean vector specifying whether a profile belongs to the threshold.</p>
</td></tr>
<tr><td><code>number_of_iterations</code></td>
<td>
<p>number of iterations performed by the Bubley Dyer algorithm.</p>
</td></tr>
<tr><td><code>rank_dist</code></td>
<td>
<p>matrix reporting by rows the relative
frequency distribution of the poverty ranks of each profile, over the set of sampled linear extensions.</p>
</td></tr>
<tr><td><code>thr_dist</code></td>
<td>
<p>vector reporting the relative frequency a profile is used as threshold in the sampled linear extensions.
This result is useful for a posteriori valuation of the poset threshold.</p>
</td></tr>
<tr><td><code>prof_w</code></td>
<td>
<p>vector of weights assigned to each profile.</p>
</td></tr>
<tr><td><code>edges_weights</code></td>
<td>
<p>matrix of distances between profiles, used to evaluate the
measures of gap.</p>
</td></tr>
<tr><td><code>idn_f</code></td>
<td>
<p>vector reporting the identification function, computed as the fraction of sampled linear extensions where a profile is in the downset of the threshold.</p>
</td></tr>
<tr><td><code>svr_abs</code></td>
<td>
<p><code>NA</code> use <a href="#topic+evaluation">evaluation</a> to obtain this result.</p>
</td></tr>
<tr><td><code>svr_rel</code></td>
<td>
<p><code>NA</code> use <a href="#topic+evaluation">evaluation</a> to obtain this result.</p>
</td></tr>
<tr><td><code>wea_abs</code></td>
<td>
<p><code>NA</code> use <a href="#topic+evaluation">evaluation</a> to obtain this result.</p>
</td></tr>
<tr><td><code>wea_rel</code></td>
<td>
<p><code>NA</code> use <a href="#topic+evaluation">evaluation</a> to obtain this result.</p>
</td></tr>
<tr><td><code>poverty_gap</code></td>
<td>
<p><code>NA</code> use <a href="#topic+evaluation">evaluation</a> to obtain this result.</p>
</td></tr>
<tr><td><code>wealth_gap</code></td>
<td>
<p><code>NA</code> use <a href="#topic+evaluation">evaluation</a> to obtain this result.</p>
</td></tr>
<tr><td><code>inequality</code></td>
<td>
<p><code>NA</code> use <a href="#topic+evaluation">evaluation</a> to obtain this result.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Bubley R., Dyer M. (1999), Faster random generation of linear extensions, Discrete Math., 201, 81-88.
</p>
<p>Fattore M., Arcagni A. (2013), Measuring multidimensional polarization with ordinal data, SIS 2013 Statistical Conference, BES-M3.1 - The BES and the challenges of constructing composite indicators dealing with equity and sustainability
</p>


<h3>Examples</h3>

<pre><code class='language-R'>profiles &lt;- var2prof(varlen = c(3, 2, 4))
threshold &lt;- c("311", "112")

res &lt;- idn(profiles, threshold, maxint = 10^5)

summary(res)
plot(res)
</code></pre>

<hr>
<h2 id='incidence2cover'>
incidence2cover
</h2><span id='topic+incidence2cover'></span><span id='topic+incidence2cover.incidence'></span>

<h3>Description</h3>

<p>The function computes the cover matrix associated to the input incidence matrix (i.e. the cover matrix whose transitive closure is the input incidence matrix).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>incidence2cover(z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="incidence2cover_+3A_z">z</code></td>
<td>

<p>an incidence matrix, an object of class <code>incidence</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Cover matrix, an object of class
<code>cover</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cover2incidence">cover2incidence</a></code>
</p>

<hr>
<h2 id='incomparability'>
Incomparability between profiles</h2><span id='topic+incomp'></span><span id='topic+incomp.incidence'></span>

<h3>Description</h3>

<p>The function computes the set of pairwise incomparabilities between poset elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>incomp(z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="incomparability_+3A_z">z</code></td>
<td>

<p>an incidence matrix.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean matrix whose  element ij is <code>TRUE</code> when profiles i and j
are incomparable.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getzeta">getzeta</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vl &lt;- c(2, 2, 2)
pr &lt;- var2prof(varlen = vl)
Z &lt;- getzeta(pr)
incomp(Z)
</code></pre>

<hr>
<h2 id='is.downset'>
is.downset
</h2><span id='topic+is.downset'></span>

<h3>Description</h3>

<p>The function checks whether the input set of poset elements <code>Q</code> is a downset of the poset represented by the incidence matrix <code>z</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.downset(z, Q = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.downset_+3A_z">z</code></td>
<td>

<p>incidence matrix
</p>
</td></tr>
<tr><td><code id="is.downset_+3A_q">Q</code></td>
<td>

<p>vector identifying the input set of profiles.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- getzeta(var2prof(varlen = c(2, 2, 2)))

plot(z, col = 1 + c(1, 1, 0, 0, 1, 0, 0, 0) + c(0, 0, 0, 2, 0, 0, 2, 2), lwd = 2)

Q &lt;- c(4, 7, 8)
rownames(z)[Q]
is.downset(z, Q)

Q &lt;- c("211", "112", "111")
is.downset(z, Q)
</code></pre>

<hr>
<h2 id='is.linext'>
is.linext
</h2><span id='topic+is.linext'></span>

<h3>Description</h3>

<p>The function checks whether the input argument <code>order</code> is a linear extension of the poset represented by the incidence matrix <code>z</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.linext(order, z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.linext_+3A_order">order</code></td>
<td>

<p>indexes of the poset elements (as rows and columns of <code>z</code> matrix) specifying the candidate linear order.
</p>
</td></tr>
<tr><td><code id="is.linext_+3A_z">z</code></td>
<td>

<p>incidence matrix.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>Z &lt;- getzeta(var2prof(varlen = c(3, 3)))
ranks &lt;- c(1, 4, 2, 3, 5, 7, 6, 8, 9)
names(ranks) &lt;- rownames(Z)
ranks
is.linext(order = ranks, z = Z)
</code></pre>

<hr>
<h2 id='is.partialorder'>
is.partialorder
</h2><span id='topic+is.partialorder'></span>

<h3>Description</h3>

<p>The function checks whether the input boolean square matrix <code>m</code> represents a partial order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.partialorder(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.partialorder_+3A_m">m</code></td>
<td>

<p>a boolean square matrix..
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+transitivity">transitivity</a></code>, <code><a href="#topic+binary">binary</a></code>, <code><a href="#topic+reflexivity">reflexivity</a></code>,
</p>
<p><code><a href="#topic+antisymmetry">antisymmetry</a></code>, <code><a href="#topic+is.preorder">is.preorder</a></code>,
</p>
<p><code><a href="#topic+validate.partialorder.incidence">validate.partialorder.incidence</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- c(TRUE, FALSE, FALSE, FALSE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, TRUE,
FALSE, TRUE, TRUE, TRUE, TRUE)
M &lt;- matrix(M, 4, 4)
rownames(M) &lt;- colnames(M) &lt;- LETTERS[1:4]

is.partialorder(M)
</code></pre>

<hr>
<h2 id='is.preorder'>
is.preorder
</h2><span id='topic+is.preorder'></span>

<h3>Description</h3>

<p>The function checks whether the input boolean square matrix <code>m</code> represents a preorder.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.preorder(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.preorder_+3A_m">m</code></td>
<td>

<p>a boolean square matrix.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+transitivity">transitivity</a></code>, <code><a href="#topic+binary">binary</a></code>, <code><a href="#topic+reflexivity">reflexivity</a></code>,
</p>
<p><code><a href="#topic+antisymmetry">antisymmetry</a></code>, <code><a href="#topic+is.partialorder">is.partialorder</a></code>,
</p>
<p><code><a href="#topic+validate.partialorder.incidence">validate.partialorder.incidence</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- c(TRUE, FALSE, FALSE, FALSE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, TRUE,
FALSE, TRUE, TRUE, TRUE, TRUE)
M &lt;- matrix(M, 4, 4)
rownames(M) &lt;- colnames(M) &lt;- LETTERS[1:4]

is.preorder(M)
</code></pre>

<hr>
<h2 id='is.upset'>
is.upset
</h2><span id='topic+is.upset'></span>

<h3>Description</h3>

<p>The function checks whether the input set of elements <code>Q</code> is an upset of the poset represented by the incidence matrix <code>z</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.upset(z, Q = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.upset_+3A_z">z</code></td>
<td>

<p>an incidence matrix.
</p>
</td></tr>
<tr><td><code id="is.upset_+3A_q">Q</code></td>
<td>

<p>vector specifying the input set of poset elements.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- getzeta(var2prof(varlen = c(2, 2, 2)))

plot(z, col = 1 + c(1, 1, 0, 0, 1, 0, 0, 0) + c(0, 0, 0, 2, 0, 0, 2, 2), lwd = 2)

Q &lt;- c(4, 7, 8)
rownames(z)[Q]
is.upset(z, Q)

Q &lt;- c("211", "112", "111")
is.upset(z, Q)
</code></pre>

<hr>
<h2 id='latex'>
latex
</h2><span id='topic+latex'></span><span id='topic+latex.wprof'></span><span id='topic+latex.incidence'></span><span id='topic+latex.cover'></span>

<h3>Description</h3>

<p>The function returns the LaTeX code to create a tikz figure representing the Hasse diagram drawn from a set of profiles (<code>prof</code>), an incidence matrix (<code>Z</code>) or a cover matrix (<code>C</code>). The code can be copied and pasted into a <code>latex</code> file. The <code>latex</code> source requires the <code>tikz</code> package,
</p>


<h3>Usage</h3>

<pre><code class='language-R'>latex(y, ...)
## S3 method for class 'wprof'
latex(y, label = "", caption = "", scale = c(1, 1), ...)
## S3 method for class 'incidence'
latex(y, label = "", caption = "", scale = c(1, 1), ...)
## S3 method for class 'cover'
latex(y, label = "", caption = "", scale = c(1, 1), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="latex_+3A_y">y</code></td>
<td>

<p>an object of S3 class <code>wprof</code>, an object of S3 class <code>incidence</code> or an object of S3 class <code>cover</code>.
</p>
</td></tr>
<tr><td><code id="latex_+3A_label">label</code></td>
<td>

<p>the label of the LaTeX figure.
</p>
</td></tr>
<tr><td><code id="latex_+3A_caption">caption</code></td>
<td>

<p>the caption of the LaTeX figure.
</p>
</td></tr>
<tr><td><code id="latex_+3A_scale">scale</code></td>
<td>

<p>a vector of two elements to control the scale of the X-axis and the scale of the Y-axis in the LaTeX output.
</p>
</td></tr>
<tr><td><code id="latex_+3A_...">...</code></td>
<td>

<p>any of above.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>prof &lt;- var2prof(varlen = c(2, 3))
latex(prof, label="fg:hasse", caption="Hasse diagram", scale = c(2, 2))
</code></pre>

<hr>
<h2 id='LE'>
Linear extensions
</h2><span id='topic+LE'></span>

<h3>Description</h3>

<p>The function generates all of the linear extensions of the partial order defined by the incidence matrix <code>Lambda</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LE(Lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LE_+3A_lambda">Lambda</code></td>
<td>

<p>incidence matrix.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of vectors representing all linear orders compatible with the <code>Lambda</code> incidence matrix.
</p>


<h3>Author(s)</h3>

<p>Alberto Arcagni
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getlambda">getlambda</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Lambda &lt;- getlambda(A &lt; B, A &lt; C, D &lt; C)
LE(Lambda)
</code></pre>

<hr>
<h2 id='LE2incidence'>
Computes the incidence matrices of lexicographic linear extensions of a profile poset.
</h2><span id='topic+LE2incidence'></span><span id='topic+LE2incidence.default'></span><span id='topic+LE2incidence.list'></span>

<h3>Description</h3>

<p>The function generates the incidence matrices of the lexicographic linear extensions of a profile poset, given the variables (argument <code>varmod</code> or <code>varlen</code>) and a list of complete orders on them (argument <code>lst</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LE2incidence(
    lst,
    varmod = lapply(as.list(varlen), function(lst) 1:lst),
    varlen = sapply(varmod, length)
)
## Default S3 method:
LE2incidence(
    lst,
    varmod = lapply(as.list(varlen), function(lst) 1:lst),
    varlen = sapply(varmod, length)
)
## S3 method for class 'list'
LE2incidence(
    lst,
    varmod = lapply(as.list(varlen), function(x) 1:x),
    varlen = sapply(varmod, length)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LE2incidence_+3A_lst">lst</code></td>
<td>

<p>a vector of <code>characters</code>, or a list of specifies the names of the variables in increasing order. See details.
</p>
</td></tr>
<tr><td><code id="LE2incidence_+3A_varmod">varmod</code></td>
<td>

<p>list of variables and their grades. See details. 
</p>
</td></tr>
<tr><td><code id="LE2incidence_+3A_varlen">varlen</code></td>
<td>

<p>a vector with the number of grades of each variable. See details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Argument <code>lst</code> is a list of chracter vectors. Each vector lists variable names in increasing order.
</p>
<p>List <code>varmod</code> and vector <code>varlen</code> must be named so as to identify the variables they refer to. Profiles are generated as combinations of the variables' grades. The names of the profiles are the grades of the variables concatenated, after the variables order in <code>varmod</code>/<code>varlen</code>. See <code><a href="#topic+var2prof">var2prof</a></code> for more details about these arguments.
</p>


<h3>Value</h3>

<p>an object of S3 class <code>incidence</code> or a list of objects of S3 class <code>incidence</code>.
</p>


<h3>Author(s)</h3>

<p>Alberto Arcagni
</p>


<h3>See Also</h3>

<p><code><a href="#topic+var2prof">var2prof</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Lambda &lt;- getlambda(A &lt; B, C &lt; D)
plot(Lambda)
lst &lt;- LE(Lambda)
vl &lt;- c(A = 2, B = 2, C = 2, D = 2)
lstZeta &lt;- LE2incidence(lst, varlen = vl)
for (x in lstZeta)
    plot(x)
</code></pre>

<hr>
<h2 id='levels.incidence+20and+20levels.cover'>
Levels of a poset
</h2><span id='topic+levels.incidence'></span><span id='topic+levels.cover'></span>

<h3>Description</h3>

<p>The methods return a vector associating each profile with the corresponding
level.
The behaviour of these methods for objects of classes <code>incidence</code> and
<code>cover</code> is different from the behaviour of function
<code><a href="base.html#topic+levels">levels</a></code> for factors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'incidence'
levels(x)
## S3 method for class 'cover'
levels(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="levels.incidence+2B20and+2B20levels.cover_+3A_x">x</code></td>
<td>

<p>an object of class <code>cover</code> or <code>incidence</code>.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>the function <code><a href="base.html#topic+levels">levels</a></code> for objects of type factor
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vl &lt;- c(3, 2, 4)
prof &lt;- var2prof(varlen = vl)
Z &lt;- getzeta(prof)

levels(Z)
</code></pre>

<hr>
<h2 id='lingen'>
lingen
</h2><span id='topic+lingen'></span>

<h3>Description</h3>

<p>The function computes a vector of ranks, defining a linear extension of the poset represented by incidence matrix <code>z</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lingen(z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lingen_+3A_z">z</code></td>
<td>

<p>an incidence matrix.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>Z &lt;- getzeta(var2prof(varlen = c(3, 3)))
lingen(Z)
</code></pre>

<hr>
<h2 id='linzeta'>
linzeta
</h2><span id='topic+linzeta'></span>

<h3>Description</h3>

<p>The function computes the incidence matrix of the linear order defined by the rank vector <code>lin</code>. It returns an object of S3 class <code>incidence</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linzeta(lin)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linzeta_+3A_lin">lin</code></td>
<td>

<p>a vector of elements' ranks.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>ranks &lt;- c(5, 3, 4, 2, 1)
names(ranks) &lt;- LETTERS[1:5]
linzeta(ranks)
plot(linzeta(ranks))
</code></pre>

<hr>
<h2 id='maximal'>
Maximal elements of a poset.
</h2><span id='topic+maximal'></span><span id='topic+maximal.cover'></span><span id='topic+maximal.incidence'></span>

<h3>Description</h3>

<p>The function returns a boolean vector identifying the maximal elements of the poset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maximal(z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maximal_+3A_z">z</code></td>
<td>

<p>an object of class <code>cover</code> or <code>incidence</code>.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>vl &lt;- c(3, 2, 4)
prof &lt;- var2prof(varlen = vl)
Z &lt;- getzeta(prof)

maximal(Z)
</code></pre>

<hr>
<h2 id='merge.wprof'>
Merge two sets of profiles.
</h2><span id='topic+merge.wprof'></span>

<h3>Description</h3>

<p>Method of the function <code>merge</code> of package <code>base</code> to merge two objects of class <code>wprof</code> generated through functions <code>var2prof</code> or <code>pop2prof</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wprof'
merge(x, y, support = FALSE, FUN = "+", all = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merge.wprof_+3A_x">x</code>, <code id="merge.wprof_+3A_y">y</code></td>
<td>

<p>objects of class <code>wprof</code> to be coerced to one.
</p>
</td></tr>
<tr><td><code id="merge.wprof_+3A_support">support</code></td>
<td>

<p>boolean variables specifying whether <code>y</code> is the support of <code>x</code> (<code>FALSE</code> by default).
</p>
</td></tr>
<tr><td><code id="merge.wprof_+3A_fun">FUN</code></td>
<td>

<p>function to be applied to the profiles' frequencies (by default, FUN = <code>sum</code>). It is ignored if <code>support</code> is <code>TRUE</code>.
</p>
</td></tr>
<tr><td><code id="merge.wprof_+3A_all">all</code></td>
<td>

<p>same argument of function <code><a href="base.html#topic+merge">merge</a></code>, by default set to <code>TRUE</code>, to get all possible profiles. If a profile is not observed in the data, its frequency is set to 0.
</p>
</td></tr>
<tr><td><code id="merge.wprof_+3A_...">...</code></td>
<td>

<p>additional arguments to be passed to method <code><a href="base.html#topic+merge.data.frame">merge.data.frame</a></code> of the package <code>base</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Objects of class <code>wprof</code> are composed of a <code>data.frame</code> of profiles and a vector of frequencies. This method applies method <code><a href="base.html#topic+merge.data.frame">merge.data.frame</a></code> to the profiles and applies function <code>FUN</code> to the frequencies.
</p>
<p>If <code>support</code> is <code>TRUE</code>, function <code><a href="base.html#topic+merge.data.frame">merge.data.frame</a></code> is not used and the output corresponds to the object <code>y</code>, but with its frequencies modified. These are set equal to the frequencies of the corresponding profiles in <code>x</code>, or to 0 for profiles not contained in <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Arcagni A.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+merge">merge</a></code>, <code><a href="#topic+var2prof">var2prof</a></code>, <code><a href="#topic+pop2prof">pop2prof</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 5
v1 &lt;- as.ordered(c("a", "b", "c", "d"))
v2 &lt;- 1:3
set.seed(0)
pop &lt;- data.frame(
	v1 = sample(v1, n, replace = TRUE),
	v2 = sample(v2, n, replace = TRUE)
)

survey_weights &lt;- round(runif(5)*10)

prof1 &lt;- pop2prof(pop, weights = survey_weights)
prof2 &lt;- var2prof(varmod = list(v1 = as.ordered(c("a", "b", "c", "d")), v2 = 1:3))

# prof2 is the support of prof1
merge(prof1, prof2, support = TRUE)

# union between the two sets of profiles and their frequencies are added
merge(prof1, prof2)

# intersection of the sets of profiles with the assumption
# that the minimum number of observations is shared
# between the two distributions
merge(prof1, prof2, all = FALSE, FUN = min)

prof2$freq &lt;- prof2$freq*10
# to remove from prof2 the observations in prof1
distribution &lt;- merge(prof2, prof1, FUN = "-"); distribution
</code></pre>

<hr>
<h2 id='minimal'>
Minimal elements of a poset
</h2><span id='topic+minimal'></span><span id='topic+minimal.cover'></span><span id='topic+minimal.incidence'></span>

<h3>Description</h3>

<p>The function returns a boolean vector identifying the minimal elements of the poset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>minimal(z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="minimal_+3A_z">z</code></td>
<td>

<p>an object of class <code>cover</code> or <code>incidence</code>.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>vl &lt;- c(3, 2, 4)
prof &lt;- var2prof(varlen = vl)
Z &lt;- getzeta(prof)

minimal(Z)
</code></pre>

<hr>
<h2 id='mrg'>
Merge posets
</h2><span id='topic+mrg'></span><span id='topic+mrg.character'></span><span id='topic+mrg.incidence'></span>

<h3>Description</h3>

<p>The function merges posets defined through a list of incidence matrices or a list of complete orders between the variables (argument <code>lst</code>). In the second case the variables must be defined (argument <code>varmod</code> or <code>varlen</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mrg(
    lst,
    varmod = lapply(as.list(varlen), function(x) 1:x),
    varlen = sapply(varmod, length)
)
## S3 method for class 'incidence'
mrg(lst, varmod = NULL, varlen = NULL)
## S3 method for class 'character'
mrg(
lst,
    varmod = lapply(as.list(varlen), function(x) 1:x),
    varlen = sapply(varmod, length)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mrg_+3A_lst">lst</code></td>
<td>

<p>a list of incidence matrices (class <code>incidence</code>) or list of vectors of <code>characters</code>. See details.
</p>
</td></tr>
<tr><td><code id="mrg_+3A_varmod">varmod</code></td>
<td>

<p>list of variables and their grades. See details. 
</p>
</td></tr>
<tr><td><code id="mrg_+3A_varlen">varlen</code></td>
<td>

<p>a vector of number of grades of each variable. See details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For efficiency reasons, the argument <code>lst</code> can be also a list of vectors of characters. In this case, each vector lists the names of the variables in increasing order.
</p>
<p>The list <code>varmod</code> and the vector <code>varlen</code> must be named, so as to identify the variables they refer to. The profiles are generated by the combinations of the variables grades. The names of the profiles are the grades of the variables concatenated, according to variables order in <code>varmod</code>/<code>varlen</code>. See <code><a href="#topic+var2prof">var2prof</a></code> for more details about these arguments.
</p>


<h3>Value</h3>

<p>an object of S3 class <code>incidence</code>.
</p>


<h3>Author(s)</h3>

<p>Alberto Arcagni
</p>


<h3>See Also</h3>

<p><code><a href="#topic+var2prof">var2prof</a></code>, <code><a href="#topic+LE2incidence">LE2incidence</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example with lst as list of incidence matrices
Lambda &lt;- getlambda(A &lt; B, C &lt; D)
plot(Lambda)
lst &lt;- LE(Lambda)
vl &lt;- c(A = 2, B = 2, C = 2, D = 2)
lstZeta &lt;- LE2incidence(lst, varlen = vl)
for (x in lstZeta)
    plot(x)
mrg(lstZeta)

# Example with lst as list of characters
Lambda &lt;- getlambda(A &lt; B, C &lt; D)
lst &lt;- LE(Lambda)
vl &lt;- c(A = 2, B = 2, C = 2, D = 2)
Zeta &lt;- mrg(lst, varlen = vl)
plot(Zeta)
</code></pre>

<hr>
<h2 id='MRP'>
Mutial ranking probability matrix
</h2><span id='topic+MRP'></span><span id='topic+MRP.incidence'></span>

<h3>Description</h3>

<p>Function to evaluate Mutial Ranking Probability (MRP) matrix based on <code>netrankr</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MRP(Z, method = c("exact", "mcmc", "approx"), error = 10^(-3), nit = NULL)
## S3 method for class 'incidence'
MRP(Z, method = c("exact", "mcmc", "approx"), error = 10^(-3), nit = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MRP_+3A_z">Z</code></td>
<td>

<p>an incidence matrix, an object of class <code>incidence</code>.
</p>
</td></tr>
<tr><td><code id="MRP_+3A_method">method</code></td>
<td>

<p>a string to choose the method applied to evaluate the MRP matrix. The default value is <code>"exact"</code>. See section 'Details' below.
</p>
</td></tr>
<tr><td><code id="MRP_+3A_error">error</code></td>
<td>

<p>considered only if <code>mcmc</code> method is selected. The &quot;distance&quot; from uniformity in the sampling distribution of linear extensions.
</p>
</td></tr>
<tr><td><code id="MRP_+3A_nit">nit</code></td>
<td>

<p>considered only if <code>mcmc</code> method is selected. Number of ITerations in the Bubley-Dyer algorithm, by default evaluated indicated in Bubley and Dyer (1999) depending on the value of <code>error</code>.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Package <code>netrankr</code> provides three functions to evaluate MRP matrix. Note that MRP matrix definition in <code>netrankr</code> is a little different from the one used in Fattore and Arcagni (2018), therefore this function unifies the results to the second definition.
</p>
<p>Parameter <code>method</code> allows the selection of which function of package <code>netrankr</code> to use: <code>"exact"</code> runs the function <code>exact_rank_prob</code> that provides the exact results, <code>"mcmc"</code> the function <code>mcmc_rank_prob</code> that provide the estimated results through the Bubley Dyer algorithm and <code>"approx"</code> runs the function <code>approx_rank_relative</code> that provide the Bruggemann and Carlsen (2011) approximated results. For small posets it is possible to evaluate the exact MRP matrix, for larger posets it is necessary to use the appoximated results.
</p>


<h3>Value</h3>

<p>An object of class <code>matrix</code> representing the MRP matrix. Dimensions names are equal to incidence matrix ones.
</p>


<h3>References</h3>

<p>Bruggemann R., Carlsen L., (2011). An improved estimation of averaged ranks of partial orders. MATCH Commun. Math. Comput. Chem., 65(2):383-414.
</p>
<p>Bubley R., Dyer M. (1999), Faster random generation of linear extensions, Discrete Math., 201, 81-88.
</p>
<p>Fattore M., Arcagni A. (2018). Using mutual ranking probabilities for dimensionality reduction and ranking extraction in multidimensional systems of ordinal variables. Advances in Statistical Modelling of Ordinal Data, 117.
</p>


<h3>See Also</h3>

<p><code><a href="netrankr.html#topic+exact_rank_prob">exact_rank_prob</a></code>, <code><a href="netrankr.html#topic+mcmc_rank_prob">mcmc_rank_prob</a></code>, <code><a href="netrankr.html#topic+approx_rank_relative">approx_rank_relative</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>L &lt;- getlambda(A &lt; B, C &lt; B, B &lt; D)
MRP(L)
</code></pre>

<hr>
<h2 id='MRPlex'>
Mutual ranking probabilities on the lexicographic linear extensions set
</h2><span id='topic+MRPlex'></span>

<h3>Description</h3>

<p>The function returns the mutual ranking probabilities matrix evaluated considering only the lexicographic linear extensions. Results are obtained by exact formula.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MRPlex(profiles, selection = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MRPlex_+3A_profiles">profiles</code></td>
<td>

<p>an object of S3 class <code>wprof</code>.
</p>
</td></tr>
<tr><td><code id="MRPlex_+3A_selection">selection</code></td>
<td>

<p>a vector of <code>string</code> indicating a subset of profiles to evaluate the mutual ranking probabilities. If <code>NULL</code> the mutual ranking probabilities are evaluated for all profiles.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The MRP matrix of the selected profiles.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  prf &lt;- var2prof(varlen = c(2, 2, 2))
  MRPlex(prf)
</code></pre>

<hr>
<h2 id='mypackage-internal'>Internal parsec Functions</h2><span id='topic+runC.pre_parsec'></span><span id='topic+runC.pre_parsec_simp'></span><span id='topic+runC'></span><span id='topic+intersecZ'></span>

<h3>Description</h3>

 
<p>Internal mypackage functions 
</p>


<h3>Details</h3>

 
<p>These are not to be called by users. 
</p>

<hr>
<h2 id='obsprof'>
Remove unobserved profiles.
</h2><span id='topic+obsprof'></span><span id='topic+obsprof.wprof'></span>

<h3>Description</h3>

<p>The function removes, from the set of possible profiles <code>prof</code> derived from the multi-indicator system, those unobserved in the input dataset (i.e. profiles with associated frequency equal to zero). It returns an object of class S3 <code>wprof</code>
comprising the observed profiles and their frequencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obsprof(prof)
## S3 method for class 'wprof'
obsprof(prof)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obsprof_+3A_prof">prof</code></td>
<td>

<p>object of S3 class <code>wprof</code>.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>prf &lt;- var2prof(varlen = c(3, 3, 3))
prf$freq &lt;- sample(c(0, 1), 3*3*3, replace = TRUE)
prf &lt;- obsprof(prf)
plot(prf, shape = "equispaced")
</code></pre>

<hr>
<h2 id='parsec2igraph'>
Converting a partial order to an object of the package <code><a href="igraph.html#topic+igraph">igraph</a></code>.
</h2><span id='topic+parsec2igraph'></span><span id='topic+parsec2igraph.cover'></span><span id='topic+parsec2igraph.incidence'></span>

<h3>Description</h3>

<p>The function turns a cover matrix to an <code><a href="igraph.html#topic+igraph">igraph</a></code> object, so as to allow using the graphical power of <code><a href="igraph.html#topic+igraph">igraph</a></code> to plot Hasse diagrams. Objects of class <code>cover</code> are boolean matrices where element ij is equal to 1 if element i <em>is covered by</em> element j. This makes the cover matrix the transpose of the adjacency matrix of a graph, describing the cover relation in <code><a href="igraph.html#topic+igraph">igraph</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parsec2igraph(p, ...)
## S3 method for class 'cover'
parsec2igraph(p, ...)
## S3 method for class 'incidence'
parsec2igraph(p, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parsec2igraph_+3A_p">p</code></td>
<td>

<p>an object of class <code>cover</code> or <code>incidence</code>.
</p>
</td></tr>
<tr><td><code id="parsec2igraph_+3A_...">...</code></td>
<td>

<p>additional arguments of the function <code><a href="#topic+vertices">vertices</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an object of class <code>igraph</code>, representing the directed graph defined by the cover relation.
</p>
<p>The function adds to the graph a layout generated through function <code><a href="#topic+vertices">vertices</a></code>, so as to plot the graph according to the conventions used for Hasse diagrams.
</p>


<h3>Author(s)</h3>

<p>Arcagni, A.
</p>


<h3>References</h3>

<p>Csardi G, Nepusz T: The igraph software package for complex network research,
InterJournal, Complex Systems 1695. 2006. http://igraph.org
</p>


<h3>See Also</h3>

<p><code><a href="igraph.html#topic+igraph">igraph</a></code>, <code><a href="#topic+vertices">vertices</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>example(merge.wprof)
poset &lt;- getzeta(distribution)
incidence2cover(poset)

G &lt;- parsec2igraph(poset, noise = TRUE)
get.adjacency(G)
# tkplot(G, vertex.size = distribution$freq, vertex.color = "white")

G &lt;- parsec2igraph(poset, noise = 10)
# tkplot(G, vertex.size = distribution$freq, vertex.color = "white")
</code></pre>

<hr>
<h2 id='plot.average_ranks'>
Method of function <code>plot</code> for objects of class <code>average_ranks</code>
</h2><span id='topic+plot.average_ranks'></span>

<h3>Description</h3>

<p>From the output of the function <code>average_ranks</code>, the function plots the average rank and the associated rank interval, for each element of the poset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'average_ranks'
plot(x,
    range.first = TRUE, range.col = "black", range.lty = 1,
    range.lwd = 1, type = "p", ylim = c(nrow(x), 1),
    xlab = "", ylab = "Average rank", pch = c(16, 3, 3),
    col = "black", cex = c(1, 1, 1), ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.average_ranks_+3A_x">x</code></td>
<td>

<p>An object of class <code>average_ranks</code>.
</p>
</td></tr>
<tr><td><code id="plot.average_ranks_+3A_range.first">range.first</code></td>
<td>

<p>A boolean attribute to specify whether the interval is plotted in background (<code>TRUE</code>) or in foreground (<code>FALSE</code>).
</p>
</td></tr>
<tr><td><code id="plot.average_ranks_+3A_range.col">range.col</code></td>
<td>

<p>Color of the interval.
</p>
</td></tr>
<tr><td><code id="plot.average_ranks_+3A_range.lty">range.lty</code></td>
<td>

<p>The line type to represent the range; the values are the same of the attribute <code>lty</code> in the <code><a href="graphics.html#topic+plot.default">plot.default</a></code> function.
</p>
</td></tr>
<tr><td><code id="plot.average_ranks_+3A_range.lwd">range.lwd</code></td>
<td>

<p>Width of the lines representing the range.
</p>
</td></tr>
<tr><td><code id="plot.average_ranks_+3A_type">type</code></td>
<td>

<p>Attribute of the function <code><a href="graphics.html#topic+plot.default">plot.default</a></code>, here <code>"p"</code> by default.
</p>
</td></tr>
<tr><td><code id="plot.average_ranks_+3A_ylim">ylim</code></td>
<td>

<p>Attribute of function <code><a href="graphics.html#topic+plot.default">plot.default</a></code>, here <code>c(max(x$sup), 1)</code> by default (this way, the Y-axis
is reversed, so that rank 1 corresponds to &quot;best&quot;).
</p>
</td></tr>
<tr><td><code id="plot.average_ranks_+3A_xlab">xlab</code></td>
<td>

<p>Attribute of the function <code><a href="graphics.html#topic+plot.default">plot.default</a></code>, here <code>""</code> by default.
</p>
</td></tr>
<tr><td><code id="plot.average_ranks_+3A_ylab">ylab</code></td>
<td>

<p>Attribute of the function <code><a href="graphics.html#topic+plot.default">plot.default</a></code>, here <code>"Average rank"</code> by default.
</p>
</td></tr>
<tr><td><code id="plot.average_ranks_+3A_pch">pch</code></td>
<td>

<p>Attribute of the function <code><a href="graphics.html#topic+plot.default">plot.default</a></code>, here <code>c(16, 3, 3)</code> by default. This method uses the <code><a href="graphics.html#topic+matplot">matplot</a></code> function to plot the average ranks and their range. The first value refers to the point character of the average rank, the other two to the point characters of the range.
</p>
</td></tr>
<tr><td><code id="plot.average_ranks_+3A_col">col</code></td>
<td>

<p>Attribute of the function <code><a href="graphics.html#topic+plot.default">plot.default</a></code>, here <code>"black"</code> by default. The average ranks and their ranges are of the same color, but similarly to <code>pch</code>, users can provide a vector of different colors.
</p>
</td></tr>
<tr><td><code id="plot.average_ranks_+3A_cex">cex</code></td>
<td>

<p>Attribute of the function <code><a href="graphics.html#topic+plot.default">plot.default</a></code>, here <code>c(1, 1, 1)</code> by default.
</p>
</td></tr>
<tr><td><code id="plot.average_ranks_+3A_...">...</code></td>
<td>

<p>Other arguments of the function <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+average_ranks">average_ranks</a></code>, <code><a href="graphics.html#topic+plot.default">plot.default</a></code>, <code><a href="graphics.html#topic+matplot">matplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>profiles &lt;- var2prof(varlen = c(3, 2, 4))
Z &lt;- getzeta(profiles)
res &lt;- average_ranks(Z)
plot(res)
</code></pre>

<hr>
<h2 id='plot.cover'>
Hasse diagram
</h2><span id='topic+plot.cover'></span><span id='topic+plot.incidence'></span><span id='topic+plot.wprof'></span>

<h3>Description</h3>

<p><code>plot</code> methods to draw Hasse diagrams, for objects of S3 classes <code>wprof</code>, <code>incidence</code>, <code>cover</code>, 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'wprof'
plot(x,  shape = c("square", "circle", "equispaced"), noise = FALSE, ...)
## S3 method for class 'incidence'
plot(x, shape = c("square", "circle", "equispaced"), noise = FALSE, ...)
## S3 method for class 'cover'
plot(x, shape = c("square", "circle", "equispaced"), noise = FALSE,
    pch = 21, cex = max(nchar(rownames(x))) + 2, bg = "white", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cover_+3A_x">x</code></td>
<td>

<p>an object of S3 class <code>wprof</code>, an object of S3 class <code>incidence</code> or an object of S3 class <code>cover</code>.
</p>
</td></tr>
<tr><td><code id="plot.cover_+3A_shape">shape</code></td>
<td>

<p>shape of the Hasse diagram. See <code><a href="#topic+vertices">vertices</a></code>.
</p>
</td></tr></table>
<p>,
</p>
<table>
<tr><td><code id="plot.cover_+3A_noise">noise</code></td>
<td>

<p>jittering in the shape of the Hasse diagram. See <code><a href="#topic+vertices">vertices</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.cover_+3A_pch">pch</code></td>
<td>

<p>graphical parameter. See <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.cover_+3A_cex">cex</code></td>
<td>

<p>graphical parameter. See <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.cover_+3A_bg">bg</code></td>
<td>

<p>graphical parameter. See <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.cover_+3A_...">...</code></td>
<td>

<p>further optional graphical parameters. See <code><a href="graphics.html#topic+plot.default">plot.default</a></code>.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>prf &lt;- var2prof(varlen = c(5, 5, 5))
prf$freq &lt;- sample(c(rep(0, 20), 1, 2, 3), 5*5*5, replace = TRUE)
prf &lt;- obsprof(prf)

z &lt;- getzeta(prf)

plot(z, shape = "equispaced", col = prf$freq, lwd = 2)
</code></pre>

<hr>
<h2 id='plot.parsec'>
Plot the outputs of the PARSEC function <code><a href="#topic+evaluation">evaluation</a></code>.
</h2><span id='topic+plot.parsec'></span>

<h3>Description</h3>

<p>Several representations of the results provided by the evaluation function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'parsec'
plot(
    x,
    which = c("Hasse", "threshold", "identification", "rank", "gap"),
    ask = dev.interactive(),
    shape = c("square", "circle", "equispaced"),
    noise = FALSE,
    ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.parsec_+3A_x">x</code></td>
<td>

<p>an object of S3 class <code>parsec</code>, output of the <code><a href="#topic+evaluation">evaluation</a></code> function.
</p>
</td></tr>
<tr><td><code id="plot.parsec_+3A_which">which</code></td>
<td>

<p>the names of the graphs to be plotted (<code>all</code>, by default); the user can choose among
</p>

<ul>
<li><p><code>Hasse</code>, the Hasse diagram of the poset, see <code><a href="#topic+plot.cover">plot.cover</a></code> for details,
</p>
</li>
<li><p><code>threshold</code>, the relative frequencies of the times a profile is used as threshold
in the sampled linear extensions.
</p>
</li>
<li><p><code>rank</code>, barplot providing the rank distribution of each profile (X-axis). The heights of
the blocks represent relative frequencies (the sum of the heights over profiles is equal to 1) and the color represents the rank:
white for rank one, black for the highest rank and a gray scale for intermediate ranks.
</p>
</li>
<li><p><code>gap</code>, a unified representation of the relative (e.g. poverty) gap and of the relative (e.g. wealth) gap.
The horizontal lines represent the average (e.g. poverty) gap and the average (e.g. wealth gap). The darker vertical dashed lines represent
the threshold profiles.
</p>
</li></ul>

</td></tr>
<tr><td><code id="plot.parsec_+3A_ask">ask</code></td>
<td>

<p>boolean value indicating whether the system has to ask users before changing the plot.
</p>
</td></tr>
<tr><td><code id="plot.parsec_+3A_shape">shape</code></td>
<td>

<p>the shape of the Hasse diagram, see <code><a href="#topic+plot.cover">plot.cover</a></code> for details.
</p>
</td></tr>
<tr><td><code id="plot.parsec_+3A_noise">noise</code></td>
<td>

<p>jittering in the shape of the Hasse diagram. See <code><a href="#topic+vertices">vertices</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.parsec_+3A_...">...</code></td>
<td>

<p>further arguments for the <code><a href="#topic+plot.cover">plot.cover</a></code> function.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+evaluation">evaluation</a></code>, <code><a href="#topic+plot.cover">plot.cover</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>profiles &lt;- var2prof(varlen = c(3, 2, 4))
threshold &lt;- c("311", "112")

res &lt;- evaluation(profiles, threshold, nit = 10^3)

plot(res)
</code></pre>

<hr>
<h2 id='plot.rank_stability'>
Plot outputs of PARSEC function <code><a href="#topic+rank_stability">rank_stability</a>.</code>
</h2><span id='topic+plot.rank_stability'></span>

<h3>Description</h3>

<p>The function generates four plots, to reproduce the sequence of the average ranks and of the positions of the elements, in the rankings associated to the alpha-cut posets.
</p>
<p>Rankings and average ranks have to be evaluted with the function <code><a href="#topic+rank_stability">rank_stability</a></code>.
</p>
<p>First and third plots show the sequence of average ranks, second and fourth show the sequence of rankings. Sequences in first and second plots are shown against the sequence of alpha-cuts, in third and fourth plots as a function of alpha values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rank_stability'
plot(x,
    which = 1:4, legend = TRUE, legend.x = "bottomleft",
    legend.y = NULL, legend.bg = "white", grid = TRUE,
    grid.lty = 2, grid.col = rgb(0, 0, 0, 1/7),
    grid.lwd = 1, y_axis = "reversed", ask = dev.interactive(),
    type = "l", col = gray(1:ncol(x$ranking)/ncol(x$ranking)/1.3),
    lwd = 3, lty = 1, ...
)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.rank_stability_+3A_x">x</code></td>
<td>

<p>object of class <code>rank_stability</code> generated by function <code><a href="#topic+rank_stability">rank_stability</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.rank_stability_+3A_which">which</code></td>
<td>
<p>select a subset of the numbers 1:4, to specify the desired plots. See caption below (and the 'Details').
</p>
</td></tr>
<tr><td><code id="plot.rank_stability_+3A_legend">legend</code></td>
<td>

<p>boolean argument to choose whether to show the legend in the plots.
</p>
</td></tr>
<tr><td><code id="plot.rank_stability_+3A_legend.x">legend.x</code>, <code id="plot.rank_stability_+3A_legend.y">legend.y</code>, <code id="plot.rank_stability_+3A_legend.bg">legend.bg</code></td>
<td>

<p>arguments <code>x</code>, <code>y</code> and <code>bg</code> of the function <code><a href="graphics.html#topic+legend">legend</a></code> defining the coordinates and the backgroud color of the legend.
</p>
</td></tr>
<tr><td><code id="plot.rank_stability_+3A_grid">grid</code></td>
<td>

<p>boolean argument to choose whether to show the grid in the plots.
</p>
</td></tr>
<tr><td><code id="plot.rank_stability_+3A_grid.lty">grid.lty</code>, <code id="plot.rank_stability_+3A_grid.col">grid.col</code>, <code id="plot.rank_stability_+3A_grid.lwd">grid.lwd</code></td>
<td>

<p>arguments defining the line type, color and width of the grid.
</p>
</td></tr>
<tr><td><code id="plot.rank_stability_+3A_y_axis">y_axis</code></td>
<td>
<p>if it is set equal to &quot;reversed&quot; plots show the y axis reversed.</p>
</td></tr>
<tr><td><code id="plot.rank_stability_+3A_ask">ask</code></td>
<td>

<p>boolean argument indicating whether the system has to ask users before changing plots.
</p>
</td></tr>
<tr><td><code id="plot.rank_stability_+3A_type">type</code></td>
<td>

<p>1-character string giving the desired type of plot. See <code><a href="graphics.html#topic+plot.default">plot.default</a></code> for details.
</p>
</td></tr>
<tr><td><code id="plot.rank_stability_+3A_col">col</code></td>
<td>

<p>vector of colors. See <code><a href="graphics.html#topic+matplot">matplot</a></code> for details.
</p>
</td></tr>
<tr><td><code id="plot.rank_stability_+3A_lwd">lwd</code></td>
<td>

<p>vector of line widths. See <code><a href="graphics.html#topic+matplot">matplot</a></code> for details.
</p>
</td></tr>
<tr><td><code id="plot.rank_stability_+3A_lty">lty</code></td>
<td>

<p>vector of line types. See <code><a href="graphics.html#topic+matplot">matplot</a></code> for details.
</p>
</td></tr>
<tr><td><code id="plot.rank_stability_+3A_...">...</code></td>
<td>

<p>other arguments of function <code><a href="graphics.html#topic+matplot">matplot</a></code>.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+rank_stability">rank_stability</a></code>, <code><a href="graphics.html#topic+legend">legend</a></code>, <code><a href="graphics.html#topic+plot.default">plot.default</a></code>, <code><a href="graphics.html#topic+matplot">matplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v1 &lt;- as.ordered(c("a", "b", "c", "d"))
v2 &lt;- 1:3
prof &lt;- var2prof(varmod = list(v1 = as.ordered(c("a", "b", "c", "d")), v2 = 1:3))
np &lt;- nrow(prof$profiles)

k &lt;- 10 # number of populations
set.seed(0)
populations &lt;- as.data.frame(lapply(1:k, function(x) round(runif(np)*100)))
rownames(populations) &lt;- rownames(prof$profiles)
names(populations) &lt;- paste0("P", 1:k)

x &lt;- FFOD(profiles = prof, distributions = populations)

res &lt;- rank_stability(x)
plot(res)
</code></pre>

<hr>
<h2 id='pop2prof'>
Population to profiles
</h2><span id='topic+pop2prof'></span>

<h3>Description</h3>

<p>Extract the observed profiles and the corresponding frequencies, out of the statistical population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pop2prof(
  y,
  labtype = c("profiles", "progressive", "rownames"),
  sep = "",
  weights = rep(1, nrow(y))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pop2prof_+3A_y">y</code></td>
<td>

<p>a dataset, used to count profile frequencies. See details.
</p>
</td></tr>
<tr><td><code id="pop2prof_+3A_labtype">labtype</code></td>
<td>

<p>users can choose the type of labels to assign to profiles. See details.
</p>
</td></tr>
<tr><td><code id="pop2prof_+3A_sep">sep</code></td>
<td>

<p>variables separator in the profiles labels.
</p>
</td></tr>
<tr><td><code id="pop2prof_+3A_weights">weights</code></td>
<td>

<p>a vector of length equal to the number of observations in <code>y</code>, representing the survey weights of each observation.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>y</code> is a data.frame of observations on the ordinal or numeric variables. The partial order must be defined within the object type, so as to build the incidence matrix of the order relation (see <code><a href="#topic+getzeta">getzeta</a></code>).
</p>
<p>The function extracts variables and their observed modalities from the population; it builds all possible profiles and assigns to them the corresponding frequency. If some modalities are not observed in the population, they will not be used to build the profiles. If one is interested in the set of all possible profiles from a given set of variables, function <code><a href="#topic+var2prof">var2prof</a></code> is to be used.
</p>
<p>Users can choose the label type to assign to profiles. Accepetd types are: <code>profiles</code> the variabiles modalities, <code>progressive</code> a progressive numeration, <code>rownames</code> the rownames in the dataset.
</p>


<h3>Value</h3>

<p>The function returns a S3 class object <code>wprof</code>, &quot;weighted profiles&quot;, containing the <code>data.frame</code> named <code>profiles</code> and the frequency vector <code>freq</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+var2prof">var2prof</a></code>, <code><a href="#topic+getzeta">getzeta</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n &lt;- 5
v1 &lt;- as.ordered(c("a", "b", "c", "d"))
v2 &lt;- 1:3
pop &lt;- data.frame(
    v1 = sample(v1, n, replace = TRUE),
    v2 = sample(v2, n, replace = TRUE)
)
pop2prof(pop)
</code></pre>

<hr>
<h2 id='popelem'>
popelem
</h2><span id='topic+popelem'></span><span id='topic+popelem.wprof'></span>

<h3>Description</h3>

<p>The function identifies in a matrix <code>y</code>, profiles in <code>prof</code>. 
For each row of matrix <code>y</code>, the function returns the location of the
corresponding profile in object <code>prof</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>popelem(prof, ...)
## S3 method for class 'wprof'
popelem(prof, y, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="popelem_+3A_prof">prof</code></td>
<td>

<p>an object of S3 class <code>wprof</code>.
</p>
</td></tr>
<tr><td><code id="popelem_+3A_y">y</code></td>
<td>

<p>a <code>matrix</code> or <code>data.frame</code> representing a set of observations with
variables (the same contained in <code>prof</code>) by columns.
</p>
</td></tr>
<tr><td><code id="popelem_+3A_...">...</code></td>
<td>

<p>any of the above.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>vl &lt;- c(2, 3, 2)
prf &lt;- var2prof(varlen = vl)
pop &lt;- matrix(c(2, 1, 1, 1, 2, 1, 2, 3, 1), 3, 3)
rownames(pop) &lt;- LETTERS[1:3]

v &lt;- popelem(prof = prf, y = pop)
v
prf$profiles[v,]
</code></pre>

<hr>
<h2 id='proFreq'>
Observed profile frequencies
</h2><span id='topic+proFreq'></span>

<h3>Description</h3>

<p>The function computes profile frequencies, by counting the number of times a profile appears in the population.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>proFreq(profiles, population)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="proFreq_+3A_profiles">profiles</code></td>
<td>

<p>an object of S3 class <code>wprof</code>.
</p>
</td></tr>
<tr><td><code id="proFreq_+3A_population">population</code></td>
<td>

<p>a <code>matrix</code> or <code>data.frame</code> representing a set of observations with
variables (the same contained in <code>prof</code>) by columns.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>wprof</code> with the same profiles of the argument but with different frequencies.
</p>


<h3>Author(s)</h3>

<p>Alberto Arcagni
</p>


<h3>See Also</h3>

<p><code><a href="#topic+popelem">popelem</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vl &lt;- c(2, 3, 2)
prf &lt;- var2prof(varlen = vl)
pop &lt;- matrix(c(2, 1, 1, 1, 2, 1, 2, 3, 1), 3, 3)
rownames(pop) &lt;- LETTERS[1:3]

proFreq(profiles = prf, population = pop)
</code></pre>

<hr>
<h2 id='rank_stability'>
Rank stability analysis in posetic FOD
</h2><span id='topic+rank_stability'></span><span id='topic+rank_stability.FODposet'></span>

<h3>Description</h3>

<p>The function computes the average ranks and the positions in the ranking of the elements of the alpha-cuts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rank_stability(x, ...)
## S3 method for class 'FODposet'
rank_stability(x,
    selection = 1:length(x$covers),
    coverage_probability = 0.9,
    error = 10^(-5), ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rank_stability_+3A_x">x</code></td>
<td>

<p>object of class <code>FODposet</code> generated by function <code><a href="#topic+FOD">FOD</a></code>.
</p>
</td></tr>
<tr><td><code id="rank_stability_+3A_selection">selection</code></td>
<td>

<p>numeric vector or a vector of names to select the cover matrices in argument <code>x</code>.
</p>
</td></tr>
<tr><td><code id="rank_stability_+3A_coverage_probability">coverage_probability</code></td>
<td>

<p>least coverage probability of the rank intervals with extremes <code>lower_ranks</code> and <code>upper_ranks</code>.
</p>
</td></tr>
<tr><td><code id="rank_stability_+3A_error">error</code></td>
<td>

<p>the &quot;distance&quot; from uniformity in the sampling distribution of linear extensions used to evaluate the average ranks. See <code><a href="#topic+idn">idn</a></code> for details.
</p>
</td></tr>
<tr><td><code id="rank_stability_+3A_...">...</code></td>
<td>

<p>any of above.
</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>alpha</code></td>
<td>
<p>vector of the alpha values defining the alpha-cuts.</p>
</td></tr>
<tr><td><code>average_ranks</code></td>
<td>
<p>data frame of average ranks of the poset elements (by columns) at different alpha values (by rows).</p>
</td></tr>
<tr><td><code>lower_ranks</code></td>
<td>
<p>data frame of the lower bounds of the rank interval, of each poset element (by columns) at different alpha values (by rows).</p>
</td></tr>
<tr><td><code>upper_ranks</code></td>
<td>
<p>data frame of the upper bounds of the rank interval, of each poset element (by columns) at different alpha values (by rows).</p>
</td></tr>
<tr><td><code>ranking</code></td>
<td>
<p>data frame of the positions of poset elements  (by columns), in the ranking extracted from the posets associated to alpha-cuts (by rows).</p>
</td></tr>
<tr><td><code>resolution</code></td>
<td>
<p>number of elements of the posets associated to the alpha-cuts.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Fattore M., Arcagni A.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+FFOD">FFOD</a></code>, <code><a href="#topic+idn">idn</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>v1 &lt;- as.ordered(c("a", "b", "c", "d"))
v2 &lt;- 1:3
prof &lt;- var2prof(varmod = list(v1 = as.ordered(c("a", "b", "c", "d")), v2 = 1:3))
np &lt;- nrow(prof$profiles)

k &lt;- 10 # number of populations
set.seed(0)
populations &lt;- as.data.frame(lapply(1:k, function(x) round(runif(np)*100)))
rownames(populations) &lt;- rownames(prof$profiles)
names(populations) &lt;- paste0("P", 1:k)

x &lt;- FFOD(profiles = prof, distributions = populations)

res &lt;- rank_stability(x)
res
</code></pre>

<hr>
<h2 id='reflexivity'>
reflexivity
</h2><span id='topic+reflexivity'></span>

<h3>Description</h3>

<p>The function checks whether the input boolean square matrix <code>m</code> represents a reflexive binary relation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reflexivity(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reflexivity_+3A_m">m</code></td>
<td>

<p>a boolean square matrix.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+transitivity">transitivity</a></code>, <code><a href="#topic+binary">binary</a></code>, <code><a href="#topic+antisymmetry">antisymmetry</a></code>,
</p>
<p><code><a href="#topic+is.preorder">is.preorder</a></code>, <code><a href="#topic+is.partialorder">is.partialorder</a></code>,
</p>
<p><code><a href="#topic+validate.partialorder.incidence">validate.partialorder.incidence</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- c(TRUE, FALSE, FALSE, FALSE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, TRUE,
FALSE, TRUE, TRUE, TRUE, TRUE)
M &lt;- matrix(M, 4, 4)
rownames(M) &lt;- colnames(M) &lt;- LETTERS[1:4]

reflexivity(M)
</code></pre>

<hr>
<h2 id='rmProfiles'>
Removing profiles
</h2><span id='topic+rmProfiles'></span><span id='topic+rmProfiles.wprof'></span>

<h3>Description</h3>

<p>Function to remove profiles from an object of class <code>wprof</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmProfiles(y, ...)
## S3 method for class 'wprof'
rmProfiles(y, v, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmProfiles_+3A_y">y</code></td>
<td>

<p>object of class <code>wprof</code>.
</p>
</td></tr>
<tr><td><code id="rmProfiles_+3A_v">v</code></td>
<td>

<p>a vector pointing to the profiles to be removed. The vector can be of type:
</p>

<ul>
<li><p><code>numeric</code> whose components refer to the positions of profiles in
<code>y</code>;
</p>
</li>
<li><p><code>logical</code> of the same length as the number of profiles in <code>y</code>;
</p>
</li>
<li><p><code>character</code>, referring to profile names in <code>y</code>.
</p>
</li></ul>

</td></tr>
<tr><td><code id="rmProfiles_+3A_...">...</code></td>
<td>

<p>any of the above.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an <code>wprof</code> object equal to <code>y</code> but without the
profiles in <code>v</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vl &lt;- c(3, 3, 3)
prof &lt;- var2prof(varlen = vl)
rownames(prof$profiles)

prof &lt;- rmProfiles(prof, c("123", "321"))

plot(prof)
</code></pre>

<hr>
<h2 id='summary.cover'>
Summary method for cover and incidence objects.
</h2><span id='topic+summary.cover'></span><span id='topic+summary.incidence'></span>

<h3>Description</h3>

<p>The function computes a summary of cover and incidence S3 objects. Currently, the
function returns just the number of profiles and the number of comparabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cover'
summary(object, ...)
## S3 method for class 'incidence'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.cover_+3A_object">object</code></td>
<td>

<p>a cover matrix or an incidence matrix.
</p>
</td></tr>
<tr><td><code id="summary.cover_+3A_...">...</code></td>
<td>

<p>added for consistency with the generic method.
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>vl &lt;- c(2, 3, 3)
prf &lt;- var2prof(varlen = vl)
Z &lt;- getzeta(prf)
summary(Z)
C &lt;- incidence2cover(Z)
summary(C)
</code></pre>

<hr>
<h2 id='summary.parsec'>
Summary of outputs of the evaluation function.
</h2><span id='topic+summary.parsec'></span>

<h3>Description</h3>

<p>S3 method of function <code>summary</code> reporting main information for an object of class <code>parsec</code>,
obtained from function <code><a href="#topic+evaluation">evaluation</a></code>.
In particular, the function computes a table showing, for each profile:
</p>

<ul>
<li><p>the variables' grades identifying the profile (if these are
returned by <code><a href="#topic+evaluation">evaluation</a></code>.
</p>
</li>
<li><p>the assigned weight.
</p>
</li>
<li><p>whether or not it belongs to the threshold.
</p>
</li>
<li><p>the corresponding value of the identification function.
</p>
</li>
<li><p>the average poverty rank.
</p>
</li>
<li><p>the different gap measures (see <code><a href="#topic+evaluation">evaluation</a></code> for details).
</p>
</li></ul>

<p>If the number of profiles is higher than ten, the shown table gets cut, but
the method returns a <code>data.frame</code> providing the complete output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'parsec'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.parsec_+3A_object">object</code></td>
<td>

<p>an object of S3 class <code>parsec</code>, output of the <code><a href="#topic+evaluation">evaluation</a></code> function.
</p>
</td></tr>
<tr><td><code id="summary.parsec_+3A_...">...</code></td>
<td>

<p>added for consistency with the generic method.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+evaluation">evaluation</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>profiles &lt;- var2prof(varlen = c(3, 2, 4))
threshold &lt;- c("311", "112")

res &lt;- evaluation(profiles, threshold, nit = 10^3)

sm &lt;- summary(res)
summary(sm)
</code></pre>

<hr>
<h2 id='transitiveClosure'>
Transitive Closure
</h2><span id='topic+transitiveClosure'></span><span id='topic+transitiveClosure.default'></span><span id='topic+transitiveClosure.cover'></span><span id='topic+transitiveClosure.incidence'></span>

<h3>Description</h3>

<p>The function computes the transitive closure of a reflexive and antisymmetric binary relation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transitiveClosure(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transitiveClosure_+3A_m">m</code></td>
<td>

<p>a generic square boolean matrix representing a reflexive and antisymmetric binary relation,
an object of class <code>cover</code> or an object of class <code>incidence</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Incidence matrix of the transitive closure of the input matrix <code>m</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+is.partialorder">is.partialorder</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- c(1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1)
m &lt;- matrix(m, 4, 4)

transitiveClosure(m)
</code></pre>

<hr>
<h2 id='transitivity'>
transitivity
</h2><span id='topic+transitivity'></span>

<h3>Description</h3>

<p>The function checks whether the boolean square matrix <code>m</code> representes a transitive binary relation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transitivity(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transitivity_+3A_m">m</code></td>
<td>

<p>a boolean square matrix.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+binary">binary</a></code>, <code><a href="#topic+reflexivity">reflexivity</a></code>, <code><a href="#topic+antisymmetry">antisymmetry</a></code>,
</p>
<p><code><a href="#topic+is.preorder">is.preorder</a></code>, <code><a href="#topic+is.partialorder">is.partialorder</a></code>,
</p>
<p><code><a href="#topic+validate.partialorder.incidence">validate.partialorder.incidence</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- c(TRUE, FALSE, FALSE, FALSE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, TRUE,
FALSE, TRUE, TRUE, TRUE, TRUE)
M &lt;- matrix(M, 4, 4)
rownames(M) &lt;- colnames(M) &lt;- LETTERS[1:4]

transitivity(M)
</code></pre>

<hr>
<h2 id='upset'>
upset
</h2><span id='topic+upset'></span><span id='topic+upset.incidence'></span><span id='topic+upset.cover'></span>

<h3>Description</h3>

<p>The function computes a boolean vector specifying which poset elements belong to the downset generated by subposet <code>Q</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upset(z, ...)
## S3 method for class 'cover'
upset(z, ...)
## S3 method for class 'incidence'
upset(z, Q = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upset_+3A_z">z</code></td>
<td>

<p>a cover or an incidence matrix, of S3 classes <code>cover</code> or <code>incidence</code>, respectively.
</p>
</td></tr>
<tr><td><code id="upset_+3A_q">Q</code></td>
<td>

<p>vector specifying a subposet of the poset represented by <code>z</code>.
</p>
</td></tr>
<tr><td><code id="upset_+3A_...">...</code></td>
<td>

<p>any of the above.  
</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- getzeta(var2prof(varlen = c(2, 2, 2)))

plot(z, col = 1 + c(1, 1, 0, 0, 1, 0, 0, 0) + c(0, 0, 0, 2, 0, 0, 2, 2), lwd = 2)

Q &lt;- c(4, 7, 8)
rownames(z)[Q]
upset(z, Q)

Q &lt;- c("211", "112", "111")
upset(z, Q)
</code></pre>

<hr>
<h2 id='validate.partialorder.incidence'>
validate.partialorder.incidence
</h2><span id='topic+validate.partialorder.incidence'></span>

<h3>Description</h3>

<p>The function checks whether the boolean square matrix <code>m</code> represents a partial order. If yes, the function returns the same input matrix as a S3 class object <code>incidence</code>. Otherwise, the unfulfilled partial order properties of matrix <code>m</code> are returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>validate.partialorder.incidence(m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="validate.partialorder.incidence_+3A_m">m</code></td>
<td>

<p>a boolean square matrix.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+transitivity">transitivity</a></code>, <code><a href="#topic+binary">binary</a></code>, <code><a href="#topic+reflexivity">reflexivity</a></code>,
</p>
<p><code><a href="#topic+antisymmetry">antisymmetry</a></code>, <code><a href="#topic+is.preorder">is.preorder</a></code>, <code><a href="#topic+is.partialorder">is.partialorder</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>M &lt;- c(TRUE, FALSE, FALSE, FALSE, TRUE, TRUE, FALSE, FALSE, TRUE, FALSE, TRUE,
FALSE, TRUE, TRUE, TRUE, TRUE)
M &lt;- matrix(M, 4, 4)
rownames(M) &lt;- colnames(M) &lt;- LETTERS[1:4]

M &lt;- validate.partialorder.incidence(M)

plot(M)
</code></pre>

<hr>
<h2 id='var2prof'>
Variables to profiles
</h2><span id='topic+var2prof'></span><span id='topic+wprof'></span>

<h3>Description</h3>

<p>The function computes the list of all of the profiles from a list of input ordinal variables. See details for how to define variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>var2prof(varmod = lapply(as.list(varlen), function(x) 1:x),
    varlen = sapply(varmod, length), freq = NULL,
    labtype = c("profiles", "progressive"), y=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="var2prof_+3A_varmod">varmod</code></td>
<td>

<p>list of variables and their grades. See details. 
</p>
</td></tr>
<tr><td><code id="var2prof_+3A_varlen">varlen</code></td>
<td>

<p>a vector of number of grades of each variable. See details.
</p>
</td></tr>
<tr><td><code id="var2prof_+3A_freq">freq</code></td>
<td>

<p>profiles frequency distribution. By default, the frequencies are set equal to 1.
</p>
</td></tr>
<tr><td><code id="var2prof_+3A_labtype">labtype</code></td>
<td>

<p>type of labels to assign to profiles. See details.
</p>
</td></tr>
<tr><td><code id="var2prof_+3A_y">y</code></td>
<td>

<p>a matrix of observations, used to count profiles frequencies. See details.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Variables can be defined through their names and grades, using a list as argument <code>varmod</code>. The names of the objects in the list are taken as variable names. The objects in the list must be ordered vectors or numeric vectors.
</p>
<p>A faster way to define variables is through a vector with the number of grades of each variable, as argument <code>varlen</code>. This way,  variables and their grades are assigned arbitrary names. In particular, grades are identified by their ranks in the variable definition.
</p>
<p>The user can choose the type of label to assign to profiles. <code>profiles</code> is the combination of grades identifying the profiles. When the names of the grades are too long, it is suggested to choose <code>progressive</code>.
</p>
<p><code>y</code> is a matrix of observations on the ordinal variables (observations by rows and variables by columns). Variables must be ordered as defined in the previous arguments. The names of variable grades must match their definition. By this argument, the function counts the number of times a profile is observed in the population, assigning the result to the <code>freq</code> output. This method should be used when the variables and their grades are known, otherwise the function <code><a href="#topic+pop2prof">pop2prof</a></code> is available.
</p>


<h3>Value</h3>

<p>The function returns a S3 class object <code>wprof</code>, &quot;weighted profiles&quot;, comprising the <code>data.frame</code> <code>profiles</code> and the vector of frequencies <code>freq</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pop2prof">pop2prof</a></code>, <code><a href="#topic+getzeta">getzeta</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># 2 variables with 2 modalities, frequencies detected from population
pop &lt;- matrix(sample(1:2, 100, replace=TRUE), 50, 2)
var2prof(varlen=c(2, 2))

# 2 variables:
# - mood: 2 modalities
# - weather: 3 modalities
# 2*3 profiles and frequencies sampled from a Binomial distribution n = 10, p = 0.5
var &lt;- list(
    mood = ordered(c("bad", "good"), levels = c("bad", "good")),
    weather = ordered(c("rainy", "cloudy", "sunny"), levels = c("rainy", "cloudy", "sunny"))
)
var2prof(var, freq = rbinom(2*3, 10, 0.5), labtype = "progressive")
</code></pre>

<hr>
<h2 id='vertices'>
Coordinates of the vertices of the Hasse diagram, representing the input cover relation.
</h2><span id='topic+vertices'></span>

<h3>Description</h3>

<p>The function computes the coordinates of the vertices of the Hasse diagram.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vertices(C, shape = c("square", "circle", "equispaced"), noise = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vertices_+3A_c">C</code></td>
<td>

<p>cover matrix, an object of class S3 <code>cover</code>.
</p>
</td></tr>
<tr><td><code id="vertices_+3A_shape">shape</code></td>
<td>

<p>shape of the diagram. See details.
</p>
</td></tr>
<tr><td><code id="vertices_+3A_noise">noise</code></td>
<td>

<p>some jittering on the x axis, so as to improve readability. Values can be boolean or positive values, to get different jittering intensities.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Possible Hasse diagram shapes: <code>square</code>; <code>circle</code>; <code>equispaced</code>. The last option is suggested when the poset has more than one maximal or minimal elements. The function is used by the plot methods defined in the package (see <code><a href="#topic+plot.cover">plot.cover</a></code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.cover">plot.cover</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
