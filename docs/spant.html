<!DOCTYPE html><html><head><title>Help for package spant</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spant}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#spant-package'><p>spant: spectroscopy analysis tools.</p></a></li>
<li><a href='#abfit_opts'><p>Return a list of options for an ABfit analysis.</p></a></li>
<li><a href='#abfit_opts_v1_9_0'><p>Return a list of options for an ABfit analysis to maintain comparability with</p>
analyses performed with version 1.9.0 (and earlier) of spant.</a></li>
<li><a href='#acquire'><p>Simulate pulse sequence acquisition.</p></a></li>
<li><a href='#add_noise'><p>Add noise to an mrs_data object.</p></a></li>
<li><a href='#add_noise_spec_snr'><p>Add noise to an mrs_data object to match a given SNR.</p></a></li>
<li><a href='#align'><p>Align spectra to a reference frequency using a convolution based method.</p></a></li>
<li><a href='#apodise_xy'><p>Apodise MRSI data in the x-y direction with a k-space filter.</p></a></li>
<li><a href='#append_basis'><p>Combine a pair of basis set objects.</p></a></li>
<li><a href='#append_coils'><p>Append MRS data across the coil dimension, assumes they matched across the</p>
other dimensions.</a></li>
<li><a href='#append_dyns'><p>Append MRS data across the dynamic dimension, assumes they matched across the</p>
other dimensions.</a></li>
<li><a href='#append_regs'><p>Append multiple regressor data frames into a single data frame.</p></a></li>
<li><a href='#apply_axes'><p>Apply a function over specified array axes.</p></a></li>
<li><a href='#apply_mrs'><p>Apply a function across given dimensions of a MRS data object.</p></a></li>
<li><a href='#apply_pulse'><p>Simulate an RF pulse on a single spin.</p></a></li>
<li><a href='#Arg.mrs_data'><p>Apply Arg operator to an MRS dataset.</p></a></li>
<li><a href='#array2mrs_data'><p>Convert a 7 dimensional array in into a mrs_data object. The array dimensions</p>
should be ordered as : dummy, X, Y, Z, dynamic, coil, FID.</a></li>
<li><a href='#auto_phase'><p>Perform zeroth-order phase correction based on the minimisation of the</p>
squared difference between the real and magnitude components of the
spectrum.</a></li>
<li><a href='#back_extrap_ar'><p>Back extrapolate time-domain data points using an autoregressive model.</p></a></li>
<li><a href='#basis2dyn_mrs_data'><p>Convert a basis object to a dynamic mrs_data object.</p></a></li>
<li><a href='#basis2mrs_data'><p>Convert a basis object to an mrs_data object - where basis signals are spread</p>
across the dynamic dimension.</a></li>
<li><a href='#bbase'><p>Generate a spline basis, slightly adapted from : &quot;Splines, knots, and</p>
penalties&quot;, Eilers 2010.</a></li>
<li><a href='#bc_als'><p>Baseline correction using the ALS method.</p></a></li>
<li><a href='#bc_constant'><p>Remove a constant baseline offset based on a reference spectral region.</p></a></li>
<li><a href='#bc_gauss'><p>Apply and subtract a Gaussian smoother in the spectral domain.</p></a></li>
<li><a href='#bc_poly'><p>Fit and subtract a polynomial to each spectrum in a dataset.</p></a></li>
<li><a href='#bc_spline'><p>Fit and subtract a smoothing spline to each spectrum in a dataset.</p></a></li>
<li><a href='#beta2lw'><p>Covert a beta value in the time-domain to an equivalent linewidth in Hz:</p>
x * exp(-i * t * t * beta).</a></li>
<li><a href='#bin_spec'><p>Bin equally spaced spectral regions.</p></a></li>
<li><a href='#calc_coil_noise_cor'><p>Calculate the noise correlation between coil elements.</p></a></li>
<li><a href='#calc_coil_noise_sd'><p>Calculate the noise standard deviation for each coil element.</p></a></li>
<li><a href='#calc_design_efficiency'><p>Calculate the efficiency of a regressor data frame.</p></a></li>
<li><a href='#calc_ed_from_lambda'><p>Calculate the effective dimensions of a spline smoother from lambda.</p></a></li>
<li><a href='#calc_peak_info_vec'><p>Calculate the FWHM of a peak from a vector of intensity values.</p></a></li>
<li><a href='#calc_sd_poly'><p>Perform a polynomial fit, subtract and return the standard deviation of the</p>
residuals.</a></li>
<li><a href='#calc_spec_diff'><p>Calculate the sum of squares differences between two mrs_data objects.</p></a></li>
<li><a href='#calc_spec_snr'><p>Calculate the spectral SNR.</p></a></li>
<li><a href='#check_lcm'><p>Check LCModel can be run</p></a></li>
<li><a href='#check_tqn'><p>Check the TARQUIN binary can be run</p></a></li>
<li><a href='#circ_mask'><p>Create a logical circular mask spanning the full extent of an n x n matrix.</p></a></li>
<li><a href='#coherence_filter'><p>Zero all coherence orders other than the one supplied as an argument.</p></a></li>
<li><a href='#collapse_to_dyns'><p>Collapse MRS data by concatenating spectra along the dynamic dimension.</p></a></li>
<li><a href='#comb_coils'><p>Combine coil data based on the first data point of a reference signal.</p></a></li>
<li><a href='#comb_coils_mrsi_gls'><p>Combine MRSI coil data using the GLS method presented by An et al</p>
JMRI 37:1445-1450 (2013).</a></li>
<li><a href='#comb_coils_svs_gls'><p>Combine SVS coil data using the GLS method presented by An et al</p>
JMRI 37:1445-1450 (2013).</a></li>
<li><a href='#comb_fit_list_fit_tables'><p>Combine all fitting data points from a list of fits into a single data frame.</p></a></li>
<li><a href='#comb_fit_list_result_tables'><p>Combine the fit result tables from a list of fit results.</p></a></li>
<li><a href='#comb_fit_tables'><p>Combine all fitting data points into a single data frame.</p></a></li>
<li><a href='#comb_metab_ref'><p>Combine a reference and metabolite mrs_data object.</p></a></li>
<li><a href='#Conj.mrs_data'><p>Apply Conj operator to an MRS dataset.</p></a></li>
<li><a href='#conv_mrs'><p>Convolve two MRS data objects.</p></a></li>
<li><a href='#crop_basis'><p>Crop <code>basis_set</code> object based on a frequency range.</p></a></li>
<li><a href='#crop_spec'><p>Crop <code>mrs_data</code> object based on a frequency range.</p></a></li>
<li><a href='#crop_td_pts'><p>Crop <code>mrs_data</code> object data points in the time-domain.</p></a></li>
<li><a href='#crop_td_pts_end'><p>Crop <code>mrs_data</code> object data points at the end of the FID.</p></a></li>
<li><a href='#crop_td_pts_pot'><p>Crop <code>mrs_data</code> object data points in the time-domain rounding down to</p>
the next smallest power of two (pot). Data that already has a pot length will
not be changed.</a></li>
<li><a href='#crop_xy'><p>Crop an MRSI dataset in the x-y direction</p></a></li>
<li><a href='#crossprod_3d'><p>Compute the vector cross product between vectors x and y. Adapted from</p>
http://stackoverflow.com/questions/15162741/what-is-rs-crossproduct-function</a></li>
<li><a href='#decimate_mrs_fd'><p>Decimate an MRS signal to half the original sampling frequency by filtering</p>
in the frequency domain before down sampling.</a></li>
<li><a href='#decimate_mrs_td'><p>Decimate an MRS signal by filtering in the time domain before downsampling.</p></a></li>
<li><a href='#deconv_mrs'><p>Deconvolve two MRS data objects.</p></a></li>
<li><a href='#def_acq_paras'><p>Return (and optionally modify using the input arguments) a list of the</p>
default acquisition parameters.</a></li>
<li><a href='#def_fs'><p>Return the default sampling frequency in Hz.</p></a></li>
<li><a href='#def_ft'><p>Return the default transmitter frequency in Hz.</p></a></li>
<li><a href='#def_N'><p>Return the default number of data points in the spectral dimension.</p></a></li>
<li><a href='#def_nuc'><p>Return the default nucleus.</p></a></li>
<li><a href='#def_ref'><p>Return the default reference value for ppm scale.</p></a></li>
<li><a href='#dicom_reader'><p>A very simple DICOM reader.</p></a></li>
<li><a href='#diff_mrs'><p>Apply the diff operator to an MRS dataset in the FID/spectral dimension.</p></a></li>
<li><a href='#downsample_mrs_fd'><p>Downsample an MRS signal by a factor of 2 using an FFT &quot;brick-wall&quot; filter.</p></a></li>
<li><a href='#downsample_mrs_td'><p>Downsample an MRS signal by a factor of 2 by removing every other data point</p>
in the time-domain. Note, signals outside the new sampling frequency will be
aliased.</a></li>
<li><a href='#dyn_acq_times'><p>Return a time scale vector of acquisition times for a dynamic MRS scan. The</p>
first temporal scan is assigned a value of 0.</a></li>
<li><a href='#ecc'><p>Eddy current correction.</p></a></li>
<li><a href='#elliptical_mask'><p>Create an elliptical mask stored as a matrix of logical values.</p></a></li>
<li><a href='#est_noise_sd'><p>Estimate the standard deviation of the noise from a segment of an mrs_data</p>
object.</a></li>
<li><a href='#fd_conv_filt'><p>Frequency-domain convolution based filter.</p></a></li>
<li><a href='#fd_gauss_smo'><p>Apply a Gaussian smoother in the spectral domain.</p></a></li>
<li><a href='#fd2td'><p>Transform frequency-domain data to the time-domain.</p></a></li>
<li><a href='#find_bids_mrs'><p>Search for MRS data files in a BIDS filesystem structure.</p></a></li>
<li><a href='#find_mrs_files'><p>Find valid MRS data files recursively from a directory path.</p></a></li>
<li><a href='#fit_amps'><p>Extract the fit amplitudes from an object of class <code>fit_result</code>.</p></a></li>
<li><a href='#fit_diags'><p>Calculate diagnostic information for object of class <code>fit_result</code>.</p></a></li>
<li><a href='#fit_mrs'><p>Perform a fit based analysis of MRS data.</p></a></li>
<li><a href='#fit_res2csv'><p>Write fit results table to a csv file.</p></a></li>
<li><a href='#fit_t1_ti_array'><p>Fit a T1 recovery curve, from multiple TIs, to a set of amplitudes.</p></a></li>
<li><a href='#fit_t1_tr_array'><p>Fit a T1 recovery curve, from multiple TRs, to a set of amplitudes.</p></a></li>
<li><a href='#fit_t2_te_array'><p>Fit a T2 relaxation curve, from multiple TEs, to a set of amplitudes.</p></a></li>
<li><a href='#fp_phase'><p>Return the phase of the first data point in the time-domain.</p></a></li>
<li><a href='#fp_phase_correct'><p>Perform a zeroth order phase correction based on the phase of the first data</p>
point in the time-domain.</a></li>
<li><a href='#fp_scale'><p>Scale the first time-domain data point in an mrs_data object.</p></a></li>
<li><a href='#fs'><p>Return the sampling frequency in Hz of an MRS dataset.</p></a></li>
<li><a href='#ft_dyns'><p>Apply the Fourier transform over the dynamic dimension.</p></a></li>
<li><a href='#ft_shift'><p>Perform a fft and ffshift on a vector.</p></a></li>
<li><a href='#ft_shift_mat'><p>Perform a fft and fftshift on a matrix with each column replaced by its</p>
shifted fft.</a></li>
<li><a href='#gausswin_2d'><p>Create a two dimensional Gaussian window function stored as a matrix.</p></a></li>
<li><a href='#gen_baseline_reg'><p>Generate baseline regressor.</p></a></li>
<li><a href='#gen_bold_reg'><p>Generate BOLD regressors.</p></a></li>
<li><a href='#gen_conv_reg'><p>Generate regressors by convolving a specified response function with a</p>
stimulus.</a></li>
<li><a href='#gen_F'><p>Generate the F product operator.</p></a></li>
<li><a href='#gen_F_xy'><p>Generate the Fxy product operator with a specified phase.</p></a></li>
<li><a href='#gen_group_reg'><p>Expand a regressor matrix for a group analysis.</p></a></li>
<li><a href='#gen_I'><p>Generate the I product operator for a single spin.</p></a></li>
<li><a href='#gen_impulse_reg'><p>Generate impulse regressors.</p></a></li>
<li><a href='#gen_poly_reg'><p>Generate polynomial regressors.</p></a></li>
<li><a href='#gen_trap_reg'><p>Generate trapezoidal regressors.</p></a></li>
<li><a href='#get_1h_brain_basis_names'><p>Return a character vector of common 1H molecules found in healthy human</p>
brain.</a></li>
<li><a href='#get_1h_brain_basis_paras'><p>Return a list of <code>mol_parameter</code> objects suitable for 1H brain MRS</p>
analyses.</a></li>
<li><a href='#get_1h_brain_basis_paras_v1'><p>Return a list of <code>mol_parameter</code> objects suitable for 1H brain MRS</p>
analyses.</a></li>
<li><a href='#get_1h_brain_basis_paras_v2'><p>Return a list of <code>mol_parameter</code> objects suitable for 1H brain MRS</p>
analyses.</a></li>
<li><a href='#get_1h_brain_basis_paras_v3'><p>Return a list of <code>mol_parameter</code> objects suitable for 1H brain MRS</p>
analyses.</a></li>
<li><a href='#get_1h_braino_basis_names'><p>Return a character vector of molecules included in the GE BRAINO phantom.</p></a></li>
<li><a href='#get_1h_spectre_basis_names'><p>Return a character vector of molecules included in the Gold Star Phantoms</p>
SPECTRE phantom.</a></li>
<li><a href='#get_2d_psf'><p>Get the point spread function (PSF) for a 2D phase encoded MRSI scan.</p></a></li>
<li><a href='#get_acq_paras'><p>Return acquisition parameters from a MRS data object.</p></a></li>
<li><a href='#get_basis_subset'><p>Return a subset of the input basis.</p></a></li>
<li><a href='#get_dyns'><p>Extract a subset of dynamic scans.</p></a></li>
<li><a href='#get_even_dyns'><p>Return even numbered dynamic scans starting from 1 (2,4,6...).</p></a></li>
<li><a href='#get_fh_dyns'><p>Return the first half of a dynamic series.</p></a></li>
<li><a href='#get_fit_map'><p>Get a data array from a fit result.</p></a></li>
<li><a href='#get_fp'><p>Return the first time-domain data point.</p></a></li>
<li><a href='#get_guassian_pulse'><p>Generate a gaussian pulse shape.</p></a></li>
<li><a href='#get_head_dyns'><p>Return the first scans of a dynamic series.</p></a></li>
<li><a href='#get_lcm_cmd'><p>Print the command to run the LCModel command-line program.</p></a></li>
<li><a href='#get_metab'><p>Extract the metabolite component from an mrs_data object.</p></a></li>
<li><a href='#get_mol_names'><p>Return a character array of names that may be used with the</p>
<code>get_mol_paras</code> function.</a></li>
<li><a href='#get_mol_paras'><p>Get a <code>mol_parameters</code> object for a named molecule.</p></a></li>
<li><a href='#get_mrs_affine'><p>Generate an affine for nifti generation.</p></a></li>
<li><a href='#get_mrsi_voi'><p>Generate a MRSI VOI from an <code>mrs_data</code> object.</p></a></li>
<li><a href='#get_mrsi_voxel'><p>Generate a MRSI voxel from an <code>mrs_data</code> object.</p></a></li>
<li><a href='#get_mrsi_voxel_xy_psf'><p>Generate a MRSI voxel PSF from an <code>mrs_data</code> object.</p></a></li>
<li><a href='#get_mrsi2d_seg'><p>Calculate the partial volume estimates for each voxel in a 2D MRSI dataset.</p></a></li>
<li><a href='#get_odd_dyns'><p>Return odd numbered dynamic scans starting from 1 (1,3,5...).</p></a></li>
<li><a href='#get_ref'><p>Extract the reference component from an mrs_data object.</p></a></li>
<li><a href='#get_seg_ind'><p>Get the indices of data points lying between two values (end &gt; x &gt; start).</p></a></li>
<li><a href='#get_sh_dyns'><p>Return the second half of a dynamic series.</p></a></li>
<li><a href='#get_slice'><p>Return a single slice from a larger MRSI dataset.</p></a></li>
<li><a href='#get_spin_num'><p>Return the spin number for a given nucleus.</p></a></li>
<li><a href='#get_subset'><p>Extract a subset of MRS data.</p></a></li>
<li><a href='#get_svs_voi'><p>Generate a SVS acquisition volume from an <code>mrs_data</code> object.</p></a></li>
<li><a href='#get_tail_dyns'><p>Return the last scans of a dynamic series.</p></a></li>
<li><a href='#get_td_amp'><p>Return an array of amplitudes derived from fitting the initial points in the</p>
time domain and extrapolating back to t=0.</a></li>
<li><a href='#get_tqn_cmd'><p>Print the command to run the TARQUIN command-line program.</p></a></li>
<li><a href='#get_uncoupled_mol'><p>Generate a <code>mol_parameters</code> object for a simple spin system with one</p>
resonance.</a></li>
<li><a href='#get_voi_cog'><p>Calculate the centre of gravity for an image containing 0 and 1's.</p></a></li>
<li><a href='#get_voi_seg'><p>Return the white matter, gray matter and CSF composition of a volume.</p></a></li>
<li><a href='#get_voi_seg_psf'><p>Return the white matter, gray matter and CSF composition of a volume.</p></a></li>
<li><a href='#get_voxel'><p>Return a single voxel from a larger mrs dataset.</p></a></li>
<li><a href='#glm_spec'><p>Perform a GLM analysis of dynamic MRS data in the spectral domain.</p></a></li>
<li><a href='#glm_spec_fmrs_fl'><p>Perform first-level spectral GLM analysis of an fMRS dataset.</p></a></li>
<li><a href='#glm_spec_fmrs_group'><p>Perform group-level spectral GLM analysis of an fMRS dataset.</p></a></li>
<li><a href='#glm_spec_group_linhyp'><p>Test a group-level spectral GLM linear hypothesis.</p></a></li>
<li><a href='#grid_shift_xy'><p>Grid shift MRSI data in the x/y dimension.</p></a></li>
<li><a href='#gridplot'><p>Arrange spectral plots in a grid.</p></a></li>
<li><a href='#gridplot.mrs_data'><p>Arrange spectral plots in a grid.</p></a></li>
<li><a href='#hsvd'><p>HSVD of an mrs_data object.</p></a></li>
<li><a href='#hsvd_filt'><p>HSVD based signal filter.</p></a></li>
<li><a href='#hsvd_vec'><p>HSVD of a complex vector.</p></a></li>
<li><a href='#hz'><p>Return the frequency scale of an MRS dataset in Hz.</p></a></li>
<li><a href='#ift_shift'><p>Perform an iffshift and ifft on a vector.</p></a></li>
<li><a href='#ift_shift_mat'><p>Perform an ifft and ifftshift on a matrix with each column replaced by its</p>
shifted ifft.</a></li>
<li><a href='#Im.mrs_data'><p>Apply Im operator to an MRS dataset.</p></a></li>
<li><a href='#image.mrs_data'><p>Image plot method for objects of class mrs_data.</p></a></li>
<li><a href='#img2kspace_xy'><p>Transform 2D MRSI data to k-space in the x-y direction.</p></a></li>
<li><a href='#Imzap'><p>Complex rounding function taken from complexplus package to reduce the number</p>
of spant dependencies.</a></li>
<li><a href='#int_spec'><p>Integrate a spectral region.</p></a></li>
<li><a href='#interleave_dyns'><p>Interleave the first and second half of a dynamic series.</p></a></li>
<li><a href='#inv_even_dyns'><p>Invert even numbered dynamic scans starting from 1 (2,4,6...).</p></a></li>
<li><a href='#inv_odd_dyns'><p>Invert odd numbered dynamic scans starting from 1 (1,3,5...).</p></a></li>
<li><a href='#is_fd'><p>Check if the chemical shift dimension of an MRS data object is in the</p>
frequency domain.</a></li>
<li><a href='#is.def'><p>Check if an object is defined, which is the same as being not NULL.</p></a></li>
<li><a href='#kspace2img_xy'><p>Transform 2D MRSI data from k-space to image space in the x-y direction.</p></a></li>
<li><a href='#l2_reg'><p>Perform l2 regularisation artefact suppression.</p></a></li>
<li><a href='#lb'><p>Apply line-broadening (apodisation) to MRS data or basis object.</p></a></li>
<li><a href='#lofdc'><p>Correct linear frequency drift.</p></a></li>
<li><a href='#lw2alpha'><p>Covert a linewidth in Hz to an equivalent alpha value in the time-domain ie:</p>
x * exp(-t * alpha).</a></li>
<li><a href='#lw2beta'><p>Covert a linewidth in Hz to an equivalent beta value in the time-domain ie:</p>
x * exp(-t * t * beta).</a></li>
<li><a href='#make_basis_from_raw'><p>Make a basis-set object from a directory containing LCModel formatted RAW</p>
files.</a></li>
<li><a href='#mask_dyns'><p>Mask an MRS dataset in the dynamic dimension.</p></a></li>
<li><a href='#mask_fit_res'><p>Mask fit result spectra depending on a vector of bool values.</p></a></li>
<li><a href='#mask_xy'><p>Mask an MRSI dataset in the x-y direction</p></a></li>
<li><a href='#mask_xy_corners'><p>Mask the four corners of an MRSI dataset in the x-y plane.</p></a></li>
<li><a href='#mask_xy_ellipse'><p>Mask the voxels outside an elliptical region spanning the MRSI dataset in the</p>
x-y plane.</a></li>
<li><a href='#mask_xy_mat'><p>Mask a 2D MRSI dataset in the x-y dimension.</p></a></li>
<li><a href='#mat2mrs_data'><p>Convert a matrix (with spectral points in the column dimension and dynamics</p>
in the row dimensions) into a mrs_data object.</a></li>
<li><a href='#matexp'><p>Matrix exponential function taken from complexplus package to reduce the</p>
number of spant dependencies.</a></li>
<li><a href='#max_mrs'><p>Apply the max operator to an MRS dataset.</p></a></li>
<li><a href='#max_mrs_interp'><p>Apply the max operator to an interpolated MRS dataset.</p></a></li>
<li><a href='#mean_dyn_blocks'><p>Calculate the mean of adjacent dynamic scans.</p></a></li>
<li><a href='#mean_dyn_pairs'><p>Calculate the pairwise means across a dynamic data set.</p></a></li>
<li><a href='#mean_dyns'><p>Calculate the mean dynamic data.</p></a></li>
<li><a href='#mean_mrs_list'><p>Return the mean of a list of mrs_data objects.</p></a></li>
<li><a href='#mean_vec_blocks'><p>Calculate the mean of adjacent blocks in a vector.</p></a></li>
<li><a href='#mean.list'><p>Calculate the mean spectrum from an mrs_data object.</p></a></li>
<li><a href='#mean.mrs_data'><p>Calculate the mean spectrum from an mrs_data object.</p></a></li>
<li><a href='#median_dyns'><p>Calculate the median dynamic data.</p></a></li>
<li><a href='#mod_td'><p>Apply the Modulus operator to the time-domain MRS signal.</p></a></li>
<li><a href='#Mod.mrs_data'><p>Apply Mod operator to an MRS dataset.</p></a></li>
<li><a href='#mrs_data2basis'><p>Convert an mrs_data object to basis object - where basis signals are spread</p>
across the dynamic dimension in the MRS data.</a></li>
<li><a href='#mrs_data2bids'><p>Create a BIDS file structure from a vector of MRS data paths or list of</p>
mrs_data objects.</a></li>
<li><a href='#mrs_data2mat'><p>Convert mrs_data object to a matrix, with spectral points in the column</p>
dimension and dynamics in the row dimension.</a></li>
<li><a href='#mrs_data2spec_mat'><p>Convert mrs_data object to a matrix, with spectral points in the column</p>
dimension and dynamics in the row dimension.</a></li>
<li><a href='#mrs_data2vec'><p>Convert mrs_data object to a vector.</p></a></li>
<li><a href='#mvfftshift'><p>Perform a fftshift on a matrix, with each column replaced by its shifted</p>
result.</a></li>
<li><a href='#mvifftshift'><p>Perform an ifftshift on a matrix, with each column replaced by its shifted</p>
result.</a></li>
<li><a href='#n2coord'><p>Print fit coordinates from a single index.</p></a></li>
<li><a href='#Ncoils'><p>Return the total number of coil elements in an MRS dataset.</p></a></li>
<li><a href='#Ndyns'><p>Return the total number of dynamic scans in an MRS dataset.</p></a></li>
<li><a href='#nifti_flip_lr'><p>Flip the x data dimension order of a nifti image. This corresponds to</p>
flipping MRI data in the left-right direction, assuming the data in save in
neurological format (can check with fslorient program).</a></li>
<li><a href='#Npts'><p>Return the number of data points in an MRS dataset.</p></a></li>
<li><a href='#Nspec'><p>Return the total number of spectra in an MRS dataset.</p></a></li>
<li><a href='#Ntrans'><p>Return the total number of acquired transients for an MRS dataset.</p></a></li>
<li><a href='#Nx'><p>Return the total number of x locations in an MRS dataset.</p></a></li>
<li><a href='#Ny'><p>Return the total number of y locations in an MRS dataset.</p></a></li>
<li><a href='#Nz'><p>Return the total number of z locations in an MRS dataset.</p></a></li>
<li><a href='#one_page_pdf'><p>Export a one-page pdf of a single fit result</p></a></li>
<li><a href='#ortho3'><p>Display an orthographic projection plot of a nifti object.</p></a></li>
<li><a href='#ortho3_inter'><p>Display an interactive orthographic projection plot of a nifti object.</p></a></li>
<li><a href='#peak_info'><p>Search for the highest peak in a spectral region and return the frequency,</p>
height and FWHM.</a></li>
<li><a href='#pg_extrap_xy'><p>Papoulis-Gerchberg (PG) algorithm method for k-space extrapolation.</p></a></li>
<li><a href='#phase'><p>Apply phasing parameters to MRS data.</p></a></li>
<li><a href='#phase_ref_1h_brain'><p>Corrected zero order phase and chemical shift offset in 1H MRS data from the</p>
brain.</a></li>
<li><a href='#plot_bc'><p>Convenience function to plot a baseline estimate with the original data.</p></a></li>
<li><a href='#plot_reg'><p>Plot regressors as an image.</p></a></li>
<li><a href='#plot_slice_fit'><p>Plot a 2D slice from an MRSI fit result object.</p></a></li>
<li><a href='#plot_slice_fit_inter'><p>Plot a 2D slice from an MRSI fit result object.</p></a></li>
<li><a href='#plot_slice_map'><p>Plot a slice from a 7 dimensional array.</p></a></li>
<li><a href='#plot_slice_map_inter'><p>Plot an interactive slice map from a data array where voxels can be selected</p>
to display a corresponding spectrum.</a></li>
<li><a href='#plot_spec_sd'><p>Plot the spectral standard deviation.</p></a></li>
<li><a href='#plot_voi_overlay'><p>Plot a volume as an image overlay.</p></a></li>
<li><a href='#plot_voi_overlay_seg'><p>Plot a volume as an overlay on a segmented brain volume.</p></a></li>
<li><a href='#plot.fit_result'><p>Plot the fitting results of an object of class <code>fit_result</code>.</p></a></li>
<li><a href='#plot.mrs_data'><p>Plotting method for objects of class mrs_data.</p></a></li>
<li><a href='#ppm'><p>Return the ppm scale of an MRS dataset or fit result.</p></a></li>
<li><a href='#precomp'><p>Save function results to file and load on subsequent calls to avoid repeat</p>
computation.</a></li>
<li><a href='#preproc_svs'><p>Preprocess and perform quality assessment of a single SVS data set.</p></a></li>
<li><a href='#preproc_svs_dataset'><p>Preprocess and perform quality assessment of one or more SVS data sets.</p></a></li>
<li><a href='#print.fit_result'><p>Print a summary of an object of class <code>fit_result</code>.</p></a></li>
<li><a href='#print.mrs_data'><p>Print a summary of mrs_data parameters.</p></a></li>
<li><a href='#qn_states'><p>Get the quantum coherence matrix for a spin system.</p></a></li>
<li><a href='#rats'><p>Robust Alignment to a Target Spectrum (RATS).</p></a></li>
<li><a href='#re_weighting'><p>Apply a weighting to the FID to enhance spectral resolution.</p></a></li>
<li><a href='#Re.mrs_data'><p>Apply Re operator to an MRS dataset.</p></a></li>
<li><a href='#read_basis'><p>Read a basis file in LCModel .basis format.</p></a></li>
<li><a href='#read_ima_coil_dir'><p>Read a directory containing Siemens MRS IMA files and combine along the coil</p>
dimension. Note that the coil ID is inferred from the sorted file name and
should be checked when consistency is required between two directories.</a></li>
<li><a href='#read_ima_dyn_dir'><p>Read a directory containing Siemens MRS IMA files and combine along the</p>
dynamic dimension. Note that the coil ID is inferred from the sorted file
name and should be checked when consistency is required.</a></li>
<li><a href='#read_lcm_coord'><p>Read an LCModel formatted coord file containing fit information.</p></a></li>
<li><a href='#read_mrs'><p>Read MRS data from a file.</p></a></li>
<li><a href='#read_mrs_tqn'><p>Read MRS data using the TARQUIN software package.</p></a></li>
<li><a href='#read_pulse_ascii'><p>Read an ASCII formatted pulse file.</p></a></li>
<li><a href='#read_pulse_bruker'><p>Read a Bruker formatted pulse file</p></a></li>
<li><a href='#read_pulse_pta'><p>Read a .pta formatted pulse file compatible with Siemens PulseTool.</p></a></li>
<li><a href='#read_siemens_txt_hdr'><p>Read the text format header found in Siemens IMA and TWIX data files.</p></a></li>
<li><a href='#read_tqn_fit'><p>Reader for csv fit results generated by TARQUIN.</p></a></li>
<li><a href='#read_tqn_result'><p>Reader for csv results generated by TARQUIN.</p></a></li>
<li><a href='#recon_imag'><p>Reconstruct complex time-domain data from the real part of frequency-domain</p>
data.</a></li>
<li><a href='#recon_imag_vec'><p>Reconstruct complex time-domain data from the real part of frequency-domain</p>
data.</a></li>
<li><a href='#recon_twix_2d_mrsi'><p>Reconstruct 2D MRSI data from a twix file loaded with read_mrs.</p></a></li>
<li><a href='#rectangular_mask'><p>Create a rectangular mask stored as a matrix of logical values.</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#rep_array_dim'><p>Repeat an array over a given dimension.</p></a></li>
<li><a href='#rep_dyn'><p>Replicate a scan in the dynamic dimension.</p></a></li>
<li><a href='#rep_mrs'><p>Replicate a scan over a given dimension.</p></a></li>
<li><a href='#resample_basis'><p>Resample a basis-set to match a mrs_data acquisition.</p></a></li>
<li><a href='#resample_img'><p>Resample an image to match a target image space.</p></a></li>
<li><a href='#resample_voi'><p>Resample a VOI to match a target image space using nearest-neighbour</p>
interpolation.</a></li>
<li><a href='#reslice_to_mrs'><p>Reslice a nifti object to match the orientation of mrs data.</p></a></li>
<li><a href='#reson_table2mrs_data'><p>Generate mrs_data from a table of single Lorentzian resonances.</p></a></li>
<li><a href='#rm_dyns'><p>Remove a subset of dynamic scans.</p></a></li>
<li><a href='#scale_amp_molal'><p>Apply water reference scaling to a fitting results object to yield metabolite</p>
quantities in millimolar (mM) units (mol / kg of tissue water).</a></li>
<li><a href='#scale_amp_molal_pvc'><p>Apply water reference scaling to a fitting results object to yield metabolite</p>
quantities in millimolar (mM) units (mol / kg of tissue water).</a></li>
<li><a href='#scale_amp_molar'><p>Apply water reference scaling to a fitting results object to yield metabolite</p>
quantities in millimolar (mM) units (mol / Litre of tissue).</a></li>
<li><a href='#scale_amp_molar2molal_pvc'><p>Convert default LCM/TARQUIN concentration scaling to molal units with partial</p>
volume correction.</a></li>
<li><a href='#scale_amp_ratio'><p>Scale fitted amplitudes to a ratio of signal amplitude.</p></a></li>
<li><a href='#scale_amp_ratio_value'><p>Scale fitted amplitudes to a ratio of signal amplitude.</p></a></li>
<li><a href='#scale_amp_water_ratio'><p>Scale metabolite amplitudes as a ratio to the unsuppressed water amplitude.</p></a></li>
<li><a href='#scale_basis_amp'><p>Scale a basis object by a scalar.</p></a></li>
<li><a href='#scale_basis_from_singlet'><p>Scale a basis-set to be consistent with spant assumptions for water scaling.</p></a></li>
<li><a href='#scale_mrs_amp'><p>Scale an mrs_data object by a scalar or vector or amplitudes.</p></a></li>
<li><a href='#scale_spec'><p>Scale mrs_data to a spectral region.</p></a></li>
<li><a href='#sd'><p>Calculate the standard deviation spectrum from an mrs_data object.</p></a></li>
<li><a href='#sd.mrs_data'><p>Calculate the standard deviation spectrum from an mrs_data object.</p></a></li>
<li><a href='#seconds'><p>Return a time scale vector to match the FID of an MRS data object.</p></a></li>
<li><a href='#seq_cpmg_ideal'><p>CPMG style sequence with ideal pulses.</p></a></li>
<li><a href='#seq_mega_press_ideal'><p>MEGA-PRESS sequence with ideal localisation pulses and Gaussian shaped</p>
editing pulse.</a></li>
<li><a href='#seq_press_2d_shaped'><p>PRESS sequence with shaped refocusing pulses.</p></a></li>
<li><a href='#seq_press_ideal'><p>PRESS sequence with ideal pulses.</p></a></li>
<li><a href='#seq_pulse_acquire'><p>Simple pulse and acquire sequence with ideal pulses.</p></a></li>
<li><a href='#seq_slaser_ideal'><p>sLASER sequence with ideal pulses.</p></a></li>
<li><a href='#seq_spin_echo_ideal'><p>Spin echo sequence with ideal pulses.</p></a></li>
<li><a href='#seq_steam_ideal'><p>STEAM sequence with ideal pulses.</p></a></li>
<li><a href='#seq_steam_ideal_cof'><p>STEAM sequence with ideal pulses and coherence order filtering to simulate</p>
gradient crushers.</a></li>
<li><a href='#seq_steam_ideal_young'><p>STEAM sequence with ideal pulses using the z-rotation gradient simulation</p>
method described by Young et al JMR 140, 146-152 (1999).</a></li>
<li><a href='#set_def_acq_paras'><p>Set the default acquisition parameters.</p></a></li>
<li><a href='#set_lcm_cmd'><p>Set the command to run the LCModel command-line program.</p></a></li>
<li><a href='#set_lw'><p>Apply line-broadening to an mrs_data object to achieve a specified linewidth.</p></a></li>
<li><a href='#set_mask_xy_mat'><p>Set the masked voxels in a 2D MRSI dataset to given spectrum.</p></a></li>
<li><a href='#set_Ntrans'><p>Set the number of transients for an mrs_data object.</p></a></li>
<li><a href='#set_precomp_mode'><p>Set the precompute mode.</p></a></li>
<li><a href='#set_precomp_verbose'><p>Set the verbosity of the precompute function.</p></a></li>
<li><a href='#set_ref'><p>Set the ppm reference value (eg ppm value at 0Hz).</p></a></li>
<li><a href='#set_td_pts'><p>Set the number of time-domain data points, truncating or zero-filling as</p>
appropriate.</a></li>
<li><a href='#set_tqn_cmd'><p>Set the command to run the TARQUIN command-line program.</p></a></li>
<li><a href='#set_tr'><p>Set the repetition time of an MRS dataset.</p></a></li>
<li><a href='#shift'><p>Apply a frequency shift to MRS data.</p></a></li>
<li><a href='#shift_basis'><p>Apply frequency shifts to basis set signals.</p></a></li>
<li><a href='#sim_basis'><p>Simulate a basis set object.</p></a></li>
<li><a href='#sim_basis_1h_brain'><p>Simulate a basis-set suitable for 1H brain MRS analysis acquired with a PRESS</p>
sequence. Note, ideal pulses are assumed.</a></li>
<li><a href='#sim_basis_1h_brain_press'><p>Simulate a basis-set suitable for 1H brain MRS analysis acquired with a PRESS</p>
sequence. Note, ideal pulses are assumed.</a></li>
<li><a href='#sim_basis_mm_lip_lcm'><p>Simulate a macromolecular and lipid basis-set suitable for 1H brain MRS</p>
analysis.</a></li>
<li><a href='#sim_basis_tqn'><p>Simulate a basis file using TARQUIN.</p></a></li>
<li><a href='#sim_brain_1h'><p>Simulate MRS data with a similar appearance to normal brain (by default).</p></a></li>
<li><a href='#sim_mol'><p>Simulate a <code>mol_parameter</code> object.</p></a></li>
<li><a href='#sim_noise'><p>Simulate an mrs_data object containing simulated Gaussian noise.</p></a></li>
<li><a href='#sim_resonances'><p>Simulate a MRS data object containing a set of simulated resonances.</p></a></li>
<li><a href='#sim_th_excit_profile'><p>Simulate an ideal pulse excitation profile by smoothing a top-hat function</p>
with a Gaussian.</a></li>
<li><a href='#sim_zero'><p>Simulate an mrs_data object containing complex zero valued samples.</p></a></li>
<li><a href='#smooth_dyns'><p>Smooth data across the dynamic dimension with a Gaussian kernel.</p></a></li>
<li><a href='#sort_basis'><p>Sort the basis-set elements alphabetically.</p></a></li>
<li><a href='#spant_abfit_benchmark'><p>Simulate and fit some spectra with ABfit for benchmarking purposes. Basic</p>
timing and performance metrics will be printed.</a></li>
<li><a href='#spant_mpress_drift'><p>Example MEGA-PRESS data with significant B0 drift.</p></a></li>
<li><a href='#spant_sim_fmrs_dataset'><p>Simulate an example fMRS dataset for a block design fMRS experiment and</p>
export a BIDS structure.</a></li>
<li><a href='#spant_simulation_benchmark'><p>Simulate a typical metabolite basis set for benchmarking. Timing metrics will</p>
be printed on completion.</a></li>
<li><a href='#spec_decomp'><p>Decompose an mrs_data object into white and gray matter spectra.</p></a></li>
<li><a href='#spec_op'><p>Perform a mathematical operation on a spectral region.</p></a></li>
<li><a href='#spin_sys'><p>Create a spin system object for pulse sequence simulation.</p></a></li>
<li><a href='#spm_pve2categorical'><p>Convert SPM style segmentation files to a single categorical image where</p>
the numerical values map as: 0) Other, 1) CSF, 2) GM and 3) WM.</a></li>
<li><a href='#ssp'><p>Signal space projection method for lipid suppression.</p></a></li>
<li><a href='#stackplot'><p>Produce a plot with multiple traces.</p></a></li>
<li><a href='#stackplot.fit_result'><p>Plot the fitting results of an object of class <code>fit_result</code> with</p>
individual basis set components shown.</a></li>
<li><a href='#stackplot.mrs_data'><p>Stackplot plotting method for objects of class mrs_data.</p></a></li>
<li><a href='#sub_first_dyn'><p>Subtract the first dynamic spectrum from a dynamic series.</p></a></li>
<li><a href='#sub_mean_dyns'><p>Subtract the mean dynamic spectrum from a dynamic series.</p></a></li>
<li><a href='#sub_median_dyns'><p>Subtract the median dynamic spectrum from a dynamic series.</p></a></li>
<li><a href='#sum_coils'><p>Calculate the sum across receiver coil elements.</p></a></li>
<li><a href='#sum_dyns'><p>Calculate the sum of data dynamics.</p></a></li>
<li><a href='#sum_mrs'><p>Sum two mrs_data objects.</p></a></li>
<li><a href='#sum_mrs_list'><p>Return the sum of a list of mrs_data objects.</p></a></li>
<li><a href='#svs_1h_brain_analysis'><p>Standard SVS 1H brain analysis pipeline.</p></a></li>
<li><a href='#svs_1h_brain_analysis_dev'><p>Standard SVS 1H brain analysis pipeline.</p></a></li>
<li><a href='#svs_1h_brain_batch_analysis'><p>Batch interface to the standard SVS 1H brain analysis pipeline.</p></a></li>
<li><a href='#t_test_spec'><p>Perform a t-test on spectral data points.</p></a></li>
<li><a href='#td_conv_filt'><p>Time-domain convolution based filter.</p></a></li>
<li><a href='#td2fd'><p>Transform time-domain data to the frequency-domain.</p></a></li>
<li><a href='#tdsr'><p>Time-domain spectral registration.</p></a></li>
<li><a href='#te'><p>Return the echo time of an MRS dataset.</p></a></li>
<li><a href='#tr'><p>Return the repetition time of an MRS dataset.</p></a></li>
<li><a href='#varpro_3_para_opts'><p>Return a list of options for VARPRO based fitting with 3 free parameters.</p></a></li>
<li><a href='#varpro_basic_opts'><p>Return a list of options for a basic VARPRO analysis.</p></a></li>
<li><a href='#varpro_opts'><p>Return a list of options for VARPRO based fitting.</p></a></li>
<li><a href='#vec2mrs_data'><p>Convert a vector into a mrs_data object.</p></a></li>
<li><a href='#write_basis'><p>Write a basis object to an LCModel .basis formatted file.</p></a></li>
<li><a href='#write_basis_tqn'><p>Generate a basis file using TARQUIN.</p></a></li>
<li><a href='#write_mrs'><p>Write MRS data object to file.</p></a></li>
<li><a href='#write_mrs_nifti'><p>Write MRS data object to file in NIFTI format.</p></a></li>
<li><a href='#write_pulse_ascii'><p>Write an ASCII formatted pulse file.</p></a></li>
<li><a href='#zero_fade_spec'><p>Fade a spectrum to zero by frequency domain multiplication with a tanh</p>
function. Note this operation distorts data points at the end of the FID.</a></li>
<li><a href='#zero_higher_orders'><p>Zero all coherences including and above a given order.</p></a></li>
<li><a href='#zero_td_pts_end'><p>Set <code>mrs_data</code> object data points at the end of the FID to zero.</p></a></li>
<li><a href='#zf'><p>Zero-fill MRS data in the time domain.</p></a></li>
<li><a href='#zf_xy'><p>Zero-fill MRSI data in the k-space x-y direction.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>MR Spectroscopy Analysis Tools</td>
</tr>
<tr>
<td>Version:</td>
<td>2.22.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-07-11</td>
</tr>
<tr>
<td>Description:</td>
<td>Tools for reading, visualising and processing Magnetic Resonance
    Spectroscopy data. The package includes methods for spectral fitting: Wilson
    (2021) &lt;<a href="https://doi.org/10.1002%2Fmrm.28385">doi:10.1002/mrm.28385</a>&gt; and spectral alignment: Wilson (2018)
    &lt;<a href="https://doi.org/10.1002%2Fmrm.27605">doi:10.1002/mrm.27605</a>&gt;. </td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/martin3141/spant/issues/">https://github.com/martin3141/spant/issues/</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>abind, plyr, pracma, stringr, expm, signal, minpack.lm, utils,
graphics, grDevices, ptw, mmand, RNifti, RNiftyReg, fields,
numDeriv, nloptr, irlba, jsonlite</td>
</tr>
<tr>
<td>Suggests:</td>
<td>viridisLite, shiny, ggplot2, miniUI, knitr, rmarkdown,
testthat, ragg, doParallel, car</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://martin3141.github.io/spant/">https://martin3141.github.io/spant/</a>,
<a href="https://github.com/martin3141/spant/">https://github.com/martin3141/spant/</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-11 11:39:23 UTC; martinwilson</td>
</tr>
<tr>
<td>Author:</td>
<td>Martin Wilson <a href="https://orcid.org/0000-0002-2089-3956"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [cre, aut],
  Yong Wang [ctb],
  John Muschelli [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Martin Wilson &lt;martin@pipegrep.co.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-11 12:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='spant-package'>spant: spectroscopy analysis tools.</h2><span id='topic+spant'></span><span id='topic+spant-package'></span>

<h3>Description</h3>

<p>spant provides a set of tools for reading, visualising and processing
Magnetic Resonance Spectroscopy (MRS) data.
</p>


<h3>Details</h3>

<p>To get started with spant, take a look at the introduction vignette:
</p>
<p><code>vignette("spant-intro", package="spant")</code>
</p>
<p>Full list of vignettes:
</p>
<p><code>browseVignettes(package = "spant")</code>
</p>
<p>Full list of functions:
</p>
<p><code>help(package = spant, help_type = "html")</code>
</p>
<p>An online version of the documentation is available from:
</p>
<p><a href="https://martin3141.github.io/spant/">https://martin3141.github.io/spant/</a>
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Martin Wilson <a href="mailto:martin@pipegrep.co.uk">martin@pipegrep.co.uk</a> (<a href="https://orcid.org/0000-0002-2089-3956">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Yong Wang [contributor]
</p>
</li>
<li><p> John Muschelli [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://martin3141.github.io/spant/">https://martin3141.github.io/spant/</a>
</p>
</li>
<li> <p><a href="https://github.com/martin3141/spant/">https://github.com/martin3141/spant/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/martin3141/spant/issues/">https://github.com/martin3141/spant/issues/</a>
</p>
</li></ul>


<hr>
<h2 id='abfit_opts'>Return a list of options for an ABfit analysis.</h2><span id='topic+abfit_opts'></span>

<h3>Description</h3>

<p>Return a list of options for an ABfit analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abfit_opts(
  init_damping = 5,
  maxiters = 1024,
  max_shift = 0.078,
  max_damping = 15,
  max_phase = 360,
  lambda = NULL,
  ppm_left = 4,
  ppm_right = 0.2,
  zp = TRUE,
  bl_ed_pppm = 2,
  auto_bl_flex = TRUE,
  bl_comps_pppm = 15,
  export_sp_fit = FALSE,
  max_asym = 0.25,
  max_basis_shift = 0.0078,
  max_basis_damping = 2,
  maxiters_pre = 1000,
  algo_pre = "NLOPT_LN_NELDERMEAD",
  min_bl_ed_pppm = NULL,
  max_bl_ed_pppm = 7,
  auto_bl_flex_n = 20,
  pre_fit_bl_ed_pppm = 1,
  remove_lip_mm_prefit = FALSE,
  pre_align = TRUE,
  max_pre_align_shift = 0.1,
  pre_align_ref_freqs = c(2.01, 3.03, 3.22),
  noise_region = c(-0.5, -2.5),
  optimal_smooth_criterion = "maic",
  aic_smoothing_factor = 5,
  anal_jac = TRUE,
  pre_fit_ppm_left = 4,
  pre_fit_ppm_right = 1.8,
  phi1_optim = FALSE,
  phi1_init = 0,
  max_dphi1 = 0.2,
  max_basis_shift_broad = 0.0078,
  max_basis_damping_broad = 2,
  ahat_calc_method = "lh_pnnls",
  prefit_phase_search = TRUE,
  freq_reg = NULL,
  lb_reg = NULL,
  output_all_paras = FALSE,
  output_all_paras_raw = FALSE,
  input_paras_raw = NULL,
  optim_lw_only = FALSE,
  optim_lw_only_limit = 20,
  lb_init = 0.001,
  zf_offset = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abfit_opts_+3A_init_damping">init_damping</code></td>
<td>
<p>initial value of the Gaussian global damping parameter
(Hz). Very poorly shimmed or high field data may benefit from a larger value.</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_maxiters">maxiters</code></td>
<td>
<p>The maximum number of iterations to run for the detailed fit.</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_max_shift">max_shift</code></td>
<td>
<p>The maximum allowable shift to be applied in the
optimisation phase of fitting (ppm).</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_max_damping">max_damping</code></td>
<td>
<p>maximum permitted value of the global damping parameter
(Hz).</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_max_phase">max_phase</code></td>
<td>
<p>the maximum absolute permitted value of the global
zero-order phase term (degrees). Note, the prefit_phase_search option is not
constrained by this term.</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_lambda">lambda</code></td>
<td>
<p>manually set the the baseline smoothness parameter.</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_ppm_left">ppm_left</code></td>
<td>
<p>downfield frequency limit for the fitting range (ppm).</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_ppm_right">ppm_right</code></td>
<td>
<p>upfield frequency limit for the fitting range (ppm).</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_zp">zp</code></td>
<td>
<p>zero pad the data to twice the original length before fitting.</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_bl_ed_pppm">bl_ed_pppm</code></td>
<td>
<p>manually set the the baseline smoothness parameter (ED per
ppm).</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_auto_bl_flex">auto_bl_flex</code></td>
<td>
<p>automatically determine the level of baseline smoothness.</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_bl_comps_pppm">bl_comps_pppm</code></td>
<td>
<p>spline basis density (signals per ppm).</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_export_sp_fit">export_sp_fit</code></td>
<td>
<p>add the fitted spline functions to the fit result.</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_max_asym">max_asym</code></td>
<td>
<p>maximum allowable value of the asymmetry parameter.</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_max_basis_shift">max_basis_shift</code></td>
<td>
<p>maximum allowable frequency shift for individual basis
signals (ppm).</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_max_basis_damping">max_basis_damping</code></td>
<td>
<p>maximum allowable Lorentzian damping factor for
individual basis signals (Hz).</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_maxiters_pre">maxiters_pre</code></td>
<td>
<p>maximum iterations for the coarse (pre-)fit.</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_algo_pre">algo_pre</code></td>
<td>
<p>optimisation method for the coarse (pre-)fit.</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_min_bl_ed_pppm">min_bl_ed_pppm</code></td>
<td>
<p>minimum value for the candidate baseline flexibility
analyses (ED per ppm).</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_max_bl_ed_pppm">max_bl_ed_pppm</code></td>
<td>
<p>minimum value for the candidate baseline flexibility
analyses (ED per ppm).</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_auto_bl_flex_n">auto_bl_flex_n</code></td>
<td>
<p>number of candidate baseline analyses to perform.</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_pre_fit_bl_ed_pppm">pre_fit_bl_ed_pppm</code></td>
<td>
<p>level of baseline flexibility to use in the coarse
fitting stage of the algorithm (ED per ppm).</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_remove_lip_mm_prefit">remove_lip_mm_prefit</code></td>
<td>
<p>remove broad signals in the coarse fitting stage
of the algorithm.</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_pre_align">pre_align</code></td>
<td>
<p>perform a pre-alignment step before coarse fitting.</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_max_pre_align_shift">max_pre_align_shift</code></td>
<td>
<p>maximum allowable shift in the pre-alignment step
(ppm).</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_pre_align_ref_freqs">pre_align_ref_freqs</code></td>
<td>
<p>a vector of prominent spectral frequencies used in
the pre-alignment step (ppm).</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_noise_region">noise_region</code></td>
<td>
<p>spectral region to estimate the noise level (ppm).</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_optimal_smooth_criterion">optimal_smooth_criterion</code></td>
<td>
<p>method to determine the optimal smoothness.</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_aic_smoothing_factor">aic_smoothing_factor</code></td>
<td>
<p>modification factor for the AIC calculation.</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_anal_jac">anal_jac</code></td>
<td>
<p>use a analytical approximation to the jacobian in the
detailed fitting stage.</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_pre_fit_ppm_left">pre_fit_ppm_left</code></td>
<td>
<p>downfield frequency limit for the fitting range in
the coarse fitting stage of the algorithm (ppm).</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_pre_fit_ppm_right">pre_fit_ppm_right</code></td>
<td>
<p>upfield frequency limit for the fitting range in the
coarse fitting stage of the algorithm (ppm).</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_phi1_optim">phi1_optim</code></td>
<td>
<p>apply and optimise a frequency dependant phase term.</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_phi1_init">phi1_init</code></td>
<td>
<p>initial value for the frequency dependant phase term (ms).</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_max_dphi1">max_dphi1</code></td>
<td>
<p>maximum allowable change from the initial frequency
dependant phase term (ms).</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_max_basis_shift_broad">max_basis_shift_broad</code></td>
<td>
<p>maximum allowable shift for broad signals in the
basis (ppm). Determined based on their name beginning with Lip or MM.</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_max_basis_damping_broad">max_basis_damping_broad</code></td>
<td>
<p>maximum allowable Lorentzian damping for broad
signals in the basis (Hz). Determined based on their name beginning with Lip
or MM.</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_ahat_calc_method">ahat_calc_method</code></td>
<td>
<p>method to calculate the metabolite amplitudes. May be
one of: &quot;lh_pnnls&quot; or &quot;ls&quot;.</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_prefit_phase_search">prefit_phase_search</code></td>
<td>
<p>perform a 1D search for the optimal phase in the
prefit stage of the algorithm.</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_freq_reg">freq_reg</code></td>
<td>
<p>frequency shift parameter.</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_lb_reg">lb_reg</code></td>
<td>
<p>individual line broadening parameter.</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_output_all_paras">output_all_paras</code></td>
<td>
<p>include more fitting parameters in the fit table,
e.g. individual shift and damping factors for each basis set element.</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_output_all_paras_raw">output_all_paras_raw</code></td>
<td>
<p>include raw fitting parameters in the fit table.
For advanced diagnostic use only.</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_input_paras_raw">input_paras_raw</code></td>
<td>
<p>input raw fitting parameters. For advanced diagnostic
use only.</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_optim_lw_only">optim_lw_only</code></td>
<td>
<p>optimize the global line-broadening term only.</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_optim_lw_only_limit">optim_lw_only_limit</code></td>
<td>
<p>limits for the line-breading term as a percentage
of the starting value when optim_lw_only is TRUE.</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_lb_init">lb_init</code></td>
<td>
<p>initial Lorentzian line broadening value for the individual
basis signals. Setting to 0 will clash with the minimum allowable value
(eg hard constraint) during the detailed fit.</p>
</td></tr>
<tr><td><code id="abfit_opts_+3A_zf_offset">zf_offset</code></td>
<td>
<p>offset in number of data points from the end of the FID to
zero-fill. Default is NULL and will automatically set this to 50 points when
the FID distortion flag is set for the mrs_data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>full list of options.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>opts &lt;- abfit_opts(ppm_left = 4.2, noise_region = c(-1, -3))
</code></pre>

<hr>
<h2 id='abfit_opts_v1_9_0'>Return a list of options for an ABfit analysis to maintain comparability with
analyses performed with version 1.9.0 (and earlier) of spant.</h2><span id='topic+abfit_opts_v1_9_0'></span>

<h3>Description</h3>

<p>Return a list of options for an ABfit analysis to maintain comparability with
analyses performed with version 1.9.0 (and earlier) of spant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abfit_opts_v1_9_0(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="abfit_opts_v1_9_0_+3A_...">...</code></td>
<td>
<p>arguments passed to <a href="#topic+abfit_opts">abfit_opts</a>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>full list of options.
</p>

<hr>
<h2 id='acquire'>Simulate pulse sequence acquisition.</h2><span id='topic+acquire'></span>

<h3>Description</h3>

<p>Simulate pulse sequence acquisition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acquire(sys, rec_phase = 0, tol = 1e-04, detect = NULL, amp_scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="acquire_+3A_sys">sys</code></td>
<td>
<p>spin system object.</p>
</td></tr>
<tr><td><code id="acquire_+3A_rec_phase">rec_phase</code></td>
<td>
<p>receiver phase in degrees.</p>
</td></tr>
<tr><td><code id="acquire_+3A_tol">tol</code></td>
<td>
<p>ignore resonance amplitudes below this threshold.</p>
</td></tr>
<tr><td><code id="acquire_+3A_detect">detect</code></td>
<td>
<p>detection nuclei.</p>
</td></tr>
<tr><td><code id="acquire_+3A_amp_scale">amp_scale</code></td>
<td>
<p>scaling factor for the output amplitudes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of resonance amplitudes and frequencies.
</p>

<hr>
<h2 id='add_noise'>Add noise to an mrs_data object.</h2><span id='topic+add_noise'></span>

<h3>Description</h3>

<p>Add noise to an mrs_data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_noise(mrs_data, sd = 0.1, fd = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_noise_+3A_mrs_data">mrs_data</code></td>
<td>
<p>data to add noise to.</p>
</td></tr>
<tr><td><code id="add_noise_+3A_sd">sd</code></td>
<td>
<p>standard deviation of the noise.</p>
</td></tr>
<tr><td><code id="add_noise_+3A_fd">fd</code></td>
<td>
<p>generate the noise samples in the frequency-domain (TRUE) or
time-domain (FALSE). This is required since the absolute value of the
standard deviation of noise samples changes when data is Fourier transformed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mrs_data object with additive normally distributed noise.
</p>

<hr>
<h2 id='add_noise_spec_snr'>Add noise to an mrs_data object to match a given SNR.</h2><span id='topic+add_noise_spec_snr'></span>

<h3>Description</h3>

<p>Add noise to an mrs_data object to match a given SNR.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_noise_spec_snr(
  mrs_data,
  target_snr,
  sig_region = c(4, 0.5),
  ref_data = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="add_noise_spec_snr_+3A_mrs_data">mrs_data</code></td>
<td>
<p>data to add noise to.</p>
</td></tr>
<tr><td><code id="add_noise_spec_snr_+3A_target_snr">target_snr</code></td>
<td>
<p>desired spectral SNR, note this assumes the input data is
noise-free, eg simulated data. Note the SNR is estimated from the first
scan in the dataset and the same noise level is added to all spectra.</p>
</td></tr>
<tr><td><code id="add_noise_spec_snr_+3A_sig_region">sig_region</code></td>
<td>
<p>spectral limits to search for the strongest spectral data
point.</p>
</td></tr>
<tr><td><code id="add_noise_spec_snr_+3A_ref_data">ref_data</code></td>
<td>
<p>measure the signal from the first scan in this reference data
and apply the same target noise level to mrs_data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mrs_data object with additive normally distributed noise.
</p>

<hr>
<h2 id='align'>Align spectra to a reference frequency using a convolution based method.</h2><span id='topic+align'></span>

<h3>Description</h3>

<p>Align spectra to a reference frequency using a convolution based method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>align(
  mrs_data,
  ref_freq = 4.65,
  ref_amp = 1,
  zf_factor = 2,
  lb = 2,
  max_shift = 20,
  ret_df = FALSE,
  mean_dyns = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="align_+3A_mrs_data">mrs_data</code></td>
<td>
<p>data to be aligned.</p>
</td></tr>
<tr><td><code id="align_+3A_ref_freq">ref_freq</code></td>
<td>
<p>reference frequency in ppm units. More than one frequency
may be specified.</p>
</td></tr>
<tr><td><code id="align_+3A_ref_amp">ref_amp</code></td>
<td>
<p>amplitude value for the reference signal. More than one value
may be specified to match the number of ref_freq signals.</p>
</td></tr>
<tr><td><code id="align_+3A_zf_factor">zf_factor</code></td>
<td>
<p>zero filling factor to increase alignment resolution.</p>
</td></tr>
<tr><td><code id="align_+3A_lb">lb</code></td>
<td>
<p>line broadening to apply to the reference signal.</p>
</td></tr>
<tr><td><code id="align_+3A_max_shift">max_shift</code></td>
<td>
<p>maximum allowable shift in Hz.</p>
</td></tr>
<tr><td><code id="align_+3A_ret_df">ret_df</code></td>
<td>
<p>return frequency shifts in addition to aligned data (logical).</p>
</td></tr>
<tr><td><code id="align_+3A_mean_dyns">mean_dyns</code></td>
<td>
<p>align the mean spectrum and apply the same shift to each
dynamic.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>aligned data object.
</p>

<hr>
<h2 id='apodise_xy'>Apodise MRSI data in the x-y direction with a k-space filter.</h2><span id='topic+apodise_xy'></span>

<h3>Description</h3>

<p>Apodise MRSI data in the x-y direction with a k-space filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apodise_xy(mrs_data, func = "hamming", w = 2.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apodise_xy_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRSI data.</p>
</td></tr>
<tr><td><code id="apodise_xy_+3A_func">func</code></td>
<td>
<p>must be &quot;hamming&quot;, &quot;hanning&quot; or &quot;gaussian&quot;.</p>
</td></tr>
<tr><td><code id="apodise_xy_+3A_w">w</code></td>
<td>
<p>the reciprocal of the standard deviation for the Gaussian function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>apodised data.
</p>

<hr>
<h2 id='append_basis'>Combine a pair of basis set objects.</h2><span id='topic+append_basis'></span>

<h3>Description</h3>

<p>Combine a pair of basis set objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>append_basis(basis_a, basis_b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="append_basis_+3A_basis_a">basis_a</code></td>
<td>
<p>first basis.</p>
</td></tr>
<tr><td><code id="append_basis_+3A_basis_b">basis_b</code></td>
<td>
<p>second basis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>combined basis set object.
</p>

<hr>
<h2 id='append_coils'>Append MRS data across the coil dimension, assumes they matched across the
other dimensions.</h2><span id='topic+append_coils'></span>

<h3>Description</h3>

<p>Append MRS data across the coil dimension, assumes they matched across the
other dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>append_coils(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="append_coils_+3A_...">...</code></td>
<td>
<p>MRS data objects as arguments, or a list of MRS data objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a single MRS data object with the input objects concatenated together.
</p>

<hr>
<h2 id='append_dyns'>Append MRS data across the dynamic dimension, assumes they matched across the
other dimensions.</h2><span id='topic+append_dyns'></span>

<h3>Description</h3>

<p>Append MRS data across the dynamic dimension, assumes they matched across the
other dimensions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>append_dyns(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="append_dyns_+3A_...">...</code></td>
<td>
<p>MRS data objects as arguments, or a list of MRS data objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a single MRS data object with the input objects concatenated together.
</p>

<hr>
<h2 id='append_regs'>Append multiple regressor data frames into a single data frame.</h2><span id='topic+append_regs'></span>

<h3>Description</h3>

<p>Append multiple regressor data frames into a single data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>append_regs(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="append_regs_+3A_...">...</code></td>
<td>
<p>input regressor data frames.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>output regressor data frame.
</p>

<hr>
<h2 id='apply_axes'>Apply a function over specified array axes.</h2><span id='topic+apply_axes'></span>

<h3>Description</h3>

<p>Apply a function over specified array axes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_axes(x, axes, fun, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_axes_+3A_x">x</code></td>
<td>
<p>an array.</p>
</td></tr>
<tr><td><code id="apply_axes_+3A_axes">axes</code></td>
<td>
<p>a vector of axes to apply fun over.</p>
</td></tr>
<tr><td><code id="apply_axes_+3A_fun">fun</code></td>
<td>
<p>function to be applied.</p>
</td></tr>
<tr><td><code id="apply_axes_+3A_...">...</code></td>
<td>
<p>optional arguments to fun.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>z &lt;- array(1:1000, dim = c(10, 10, 10))
a &lt;- apply_axes(z, 3, fft)
a[1,1,] == fft(z[1,1,])
a &lt;- apply_axes(z, 3, sum)
a[1,1,] == sum(z[1,1,])
</code></pre>

<hr>
<h2 id='apply_mrs'>Apply a function across given dimensions of a MRS data object.</h2><span id='topic+apply_mrs'></span>

<h3>Description</h3>

<p>Apply a function across given dimensions of a MRS data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_mrs(mrs_data, dims, fun, ..., data_only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_mrs_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
<tr><td><code id="apply_mrs_+3A_dims">dims</code></td>
<td>
<p>dimensions to apply the function.</p>
</td></tr>
<tr><td><code id="apply_mrs_+3A_fun">fun</code></td>
<td>
<p>name of the function.</p>
</td></tr>
<tr><td><code id="apply_mrs_+3A_...">...</code></td>
<td>
<p>arguments to the function.</p>
</td></tr>
<tr><td><code id="apply_mrs_+3A_data_only">data_only</code></td>
<td>
<p>return an array rather than an MRS data object.</p>
</td></tr>
</table>

<hr>
<h2 id='apply_pulse'>Simulate an RF pulse on a single spin.</h2><span id='topic+apply_pulse'></span>

<h3>Description</h3>

<p>Simulate an RF pulse on a single spin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>apply_pulse(sys, rho, spin_n, angle, nuc, xy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="apply_pulse_+3A_sys">sys</code></td>
<td>
<p>spin system object.</p>
</td></tr>
<tr><td><code id="apply_pulse_+3A_rho">rho</code></td>
<td>
<p>density matrix.</p>
</td></tr>
<tr><td><code id="apply_pulse_+3A_spin_n">spin_n</code></td>
<td>
<p>spin index.</p>
</td></tr>
<tr><td><code id="apply_pulse_+3A_angle">angle</code></td>
<td>
<p>RF flip angle in degrees.</p>
</td></tr>
<tr><td><code id="apply_pulse_+3A_nuc">nuc</code></td>
<td>
<p>nucleus influenced by the pulse.</p>
</td></tr>
<tr><td><code id="apply_pulse_+3A_xy">xy</code></td>
<td>
<p>x or y pulse.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>density matrix.
</p>

<hr>
<h2 id='Arg.mrs_data'>Apply Arg operator to an MRS dataset.</h2><span id='topic+Arg.mrs_data'></span>

<h3>Description</h3>

<p>Apply Arg operator to an MRS dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mrs_data'
Arg(z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Arg.mrs_data_+3A_z">z</code></td>
<td>
<p>MRS data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>MRS data following Arg operator.
</p>

<hr>
<h2 id='array2mrs_data'>Convert a 7 dimensional array in into a mrs_data object. The array dimensions
should be ordered as : dummy, X, Y, Z, dynamic, coil, FID.</h2><span id='topic+array2mrs_data'></span>

<h3>Description</h3>

<p>Convert a 7 dimensional array in into a mrs_data object. The array dimensions
should be ordered as : dummy, X, Y, Z, dynamic, coil, FID.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>array2mrs_data(
  data_array,
  mrs_data = NULL,
  fs = NULL,
  ft = NULL,
  ref = NULL,
  nuc = NULL,
  fd = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="array2mrs_data_+3A_data_array">data_array</code></td>
<td>
<p>7d data array.</p>
</td></tr>
<tr><td><code id="array2mrs_data_+3A_mrs_data">mrs_data</code></td>
<td>
<p>example data to copy acquisition parameters from.</p>
</td></tr>
<tr><td><code id="array2mrs_data_+3A_fs">fs</code></td>
<td>
<p>sampling frequency in Hz.</p>
</td></tr>
<tr><td><code id="array2mrs_data_+3A_ft">ft</code></td>
<td>
<p>transmitter frequency in Hz.</p>
</td></tr>
<tr><td><code id="array2mrs_data_+3A_ref">ref</code></td>
<td>
<p>reference value for ppm scale.</p>
</td></tr>
<tr><td><code id="array2mrs_data_+3A_nuc">nuc</code></td>
<td>
<p>nucleus that is resonant at the transmitter frequency.</p>
</td></tr>
<tr><td><code id="array2mrs_data_+3A_fd">fd</code></td>
<td>
<p>flag to indicate if the matrix is in the frequency domain (logical).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mrs_data object.
</p>

<hr>
<h2 id='auto_phase'>Perform zeroth-order phase correction based on the minimisation of the
squared difference between the real and magnitude components of the
spectrum.</h2><span id='topic+auto_phase'></span>

<h3>Description</h3>

<p>Perform zeroth-order phase correction based on the minimisation of the
squared difference between the real and magnitude components of the
spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>auto_phase(mrs_data, xlim = c(4, 1.8), smo_ppm_sd = 0.05, ret_phase = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="auto_phase_+3A_mrs_data">mrs_data</code></td>
<td>
<p>an object of class <code>mrs_data</code>.</p>
</td></tr>
<tr><td><code id="auto_phase_+3A_xlim">xlim</code></td>
<td>
<p>frequency range (default units of PPM) to including in the phase.</p>
</td></tr>
<tr><td><code id="auto_phase_+3A_smo_ppm_sd">smo_ppm_sd</code></td>
<td>
<p>Gaussian smoother sd in ppm units.</p>
</td></tr>
<tr><td><code id="auto_phase_+3A_ret_phase">ret_phase</code></td>
<td>
<p>return phase values (logical).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>MRS data object and phase values (optional).
</p>

<hr>
<h2 id='back_extrap_ar'>Back extrapolate time-domain data points using an autoregressive model.</h2><span id='topic+back_extrap_ar'></span>

<h3>Description</h3>

<p>Back extrapolate time-domain data points using an autoregressive model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>back_extrap_ar(
  mrs_data,
  extrap_pts,
  pred_pts = NULL,
  method = "burg",
  rem_add = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="back_extrap_ar_+3A_mrs_data">mrs_data</code></td>
<td>
<p>mrs_data object.</p>
</td></tr>
<tr><td><code id="back_extrap_ar_+3A_extrap_pts">extrap_pts</code></td>
<td>
<p>number of points to extrapolate.</p>
</td></tr>
<tr><td><code id="back_extrap_ar_+3A_pred_pts">pred_pts</code></td>
<td>
<p>number of points to base the extrapolation on.</p>
</td></tr>
<tr><td><code id="back_extrap_ar_+3A_method">method</code></td>
<td>
<p>character string specifying the method to fit the model. Must
be one of the strings in the default argument (the first few characters are
sufficient). Defaults to &quot;burg&quot;.</p>
</td></tr>
<tr><td><code id="back_extrap_ar_+3A_rem_add">rem_add</code></td>
<td>
<p>remove additional points from the end of the FID to maintain
the original length of the dataset. Default to TRUE.</p>
</td></tr>
<tr><td><code id="back_extrap_ar_+3A_...">...</code></td>
<td>
<p>additional arguments to specific methods, see ?ar.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>back extrapolated data.
</p>

<hr>
<h2 id='basis2dyn_mrs_data'>Convert a basis object to a dynamic mrs_data object.</h2><span id='topic+basis2dyn_mrs_data'></span>

<h3>Description</h3>

<p>Convert a basis object to a dynamic mrs_data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basis2dyn_mrs_data(basis, amps, tr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basis2dyn_mrs_data_+3A_basis">basis</code></td>
<td>
<p>basis set object.</p>
</td></tr>
<tr><td><code id="basis2dyn_mrs_data_+3A_amps">amps</code></td>
<td>
<p>a data frame with each column corresponding to a basis element
and each row corresponding to each dynamic scan.</p>
</td></tr>
<tr><td><code id="basis2dyn_mrs_data_+3A_tr">tr</code></td>
<td>
<p>the dataset repetition time in seconds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dynamic mrs_data object.
</p>

<hr>
<h2 id='basis2mrs_data'>Convert a basis object to an mrs_data object - where basis signals are spread
across the dynamic dimension.</h2><span id='topic+basis2mrs_data'></span>

<h3>Description</h3>

<p>Convert a basis object to an mrs_data object - where basis signals are spread
across the dynamic dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>basis2mrs_data(basis, sum_elements = FALSE, amps = NULL, shifts = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="basis2mrs_data_+3A_basis">basis</code></td>
<td>
<p>basis set object.</p>
</td></tr>
<tr><td><code id="basis2mrs_data_+3A_sum_elements">sum_elements</code></td>
<td>
<p>return the sum of basis elements (logical)</p>
</td></tr>
<tr><td><code id="basis2mrs_data_+3A_amps">amps</code></td>
<td>
<p>a vector of scaling factors to apply to each basis element.</p>
</td></tr>
<tr><td><code id="basis2mrs_data_+3A_shifts">shifts</code></td>
<td>
<p>a vector of frequency shifts (in ppm) to apply to each basis
element.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an mrs_data object with basis signals spread across the dynamic
dimension or summed.
</p>

<hr>
<h2 id='bbase'>Generate a spline basis, slightly adapted from : &quot;Splines, knots, and
penalties&quot;, Eilers 2010.</h2><span id='topic+bbase'></span>

<h3>Description</h3>

<p>Generate a spline basis, slightly adapted from : &quot;Splines, knots, and
penalties&quot;, Eilers 2010.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bbase(N, number, deg = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bbase_+3A_n">N</code></td>
<td>
<p>number of data points.</p>
</td></tr>
<tr><td><code id="bbase_+3A_number">number</code></td>
<td>
<p>number of spline functions.</p>
</td></tr>
<tr><td><code id="bbase_+3A_deg">deg</code></td>
<td>
<p>spline degree : deg = 1 linear, deg = 2 quadratic, deg = 3 cubic.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>spline basis as a matrix.
</p>

<hr>
<h2 id='bc_als'>Baseline correction using the ALS method.</h2><span id='topic+bc_als'></span>

<h3>Description</h3>

<p>Eilers P. H. C. and Boelens H. F. M. (2005) Baseline correction with
asymmetric least squares smoothing. Leiden Univ. Medical Centre Report.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bc_als(mrs_data, lambda = 10000, p = 0.001, ret_bc_only = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bc_als_+3A_mrs_data">mrs_data</code></td>
<td>
<p>mrs_data object.</p>
</td></tr>
<tr><td><code id="bc_als_+3A_lambda">lambda</code></td>
<td>
<p>controls the baseline flexibility.</p>
</td></tr>
<tr><td><code id="bc_als_+3A_p">p</code></td>
<td>
<p>controls the penalty for negative data points.</p>
</td></tr>
<tr><td><code id="bc_als_+3A_ret_bc_only">ret_bc_only</code></td>
<td>
<p>return the baseline corrected data only. When FALSE the
baseline estimate and input data will be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>baseline corrected data.
</p>

<hr>
<h2 id='bc_constant'>Remove a constant baseline offset based on a reference spectral region.</h2><span id='topic+bc_constant'></span>

<h3>Description</h3>

<p>Remove a constant baseline offset based on a reference spectral region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bc_constant(mrs_data, xlim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bc_constant_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
<tr><td><code id="bc_constant_+3A_xlim">xlim</code></td>
<td>
<p>spectral range containing a flat baseline region to measure the
offset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>baseline corrected data.
</p>

<hr>
<h2 id='bc_gauss'>Apply and subtract a Gaussian smoother in the spectral domain.</h2><span id='topic+bc_gauss'></span>

<h3>Description</h3>

<p>Apply and subtract a Gaussian smoother in the spectral domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bc_gauss(mrs_data, smo_ppm_sd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bc_gauss_+3A_mrs_data">mrs_data</code></td>
<td>
<p>mrs_data object.</p>
</td></tr>
<tr><td><code id="bc_gauss_+3A_smo_ppm_sd">smo_ppm_sd</code></td>
<td>
<p>Gaussian smoother sd in ppm units.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>smoother subtracted data.
</p>

<hr>
<h2 id='bc_poly'>Fit and subtract a polynomial to each spectrum in a dataset.</h2><span id='topic+bc_poly'></span>

<h3>Description</h3>

<p>Fit and subtract a polynomial to each spectrum in a dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bc_poly(mrs_data, p_deg = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bc_poly_+3A_mrs_data">mrs_data</code></td>
<td>
<p>mrs_data object.</p>
</td></tr>
<tr><td><code id="bc_poly_+3A_p_deg">p_deg</code></td>
<td>
<p>polynomial degree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>polynomial subtracted data.
</p>

<hr>
<h2 id='bc_spline'>Fit and subtract a smoothing spline to each spectrum in a dataset.</h2><span id='topic+bc_spline'></span>

<h3>Description</h3>

<p>Fit and subtract a smoothing spline to each spectrum in a dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bc_spline(mrs_data, spar = 0.5, nknots = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bc_spline_+3A_mrs_data">mrs_data</code></td>
<td>
<p>mrs_data object.</p>
</td></tr>
<tr><td><code id="bc_spline_+3A_spar">spar</code></td>
<td>
<p>smoothing parameter typically between 0 and 1.</p>
</td></tr>
<tr><td><code id="bc_spline_+3A_nknots">nknots</code></td>
<td>
<p>number of spline knots.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>smoothing spline subtracted data.
</p>

<hr>
<h2 id='beta2lw'>Covert a beta value in the time-domain to an equivalent linewidth in Hz:
x * exp(-i * t * t * beta).</h2><span id='topic+beta2lw'></span>

<h3>Description</h3>

<p>Covert a beta value in the time-domain to an equivalent linewidth in Hz:
x * exp(-i * t * t * beta).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta2lw(beta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beta2lw_+3A_beta">beta</code></td>
<td>
<p>beta damping value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>linewidth value in Hz.
</p>

<hr>
<h2 id='bin_spec'>Bin equally spaced spectral regions.</h2><span id='topic+bin_spec'></span>

<h3>Description</h3>

<p>Bin equally spaced spectral regions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bin_spec(mrs_data, width = 0.05, unit = "ppm")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bin_spec_+3A_mrs_data">mrs_data</code></td>
<td>
<p>data to be &quot;binned&quot;.</p>
</td></tr>
<tr><td><code id="bin_spec_+3A_width">width</code></td>
<td>
<p>bin width.</p>
</td></tr>
<tr><td><code id="bin_spec_+3A_unit">unit</code></td>
<td>
<p>bin width unit, can be &quot;ppm&quot; (default) or &quot;pts&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>binned mrs_data object.
</p>

<hr>
<h2 id='calc_coil_noise_cor'>Calculate the noise correlation between coil elements.</h2><span id='topic+calc_coil_noise_cor'></span>

<h3>Description</h3>

<p>Calculate the noise correlation between coil elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_coil_noise_cor(noise_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_coil_noise_cor_+3A_noise_data">noise_data</code></td>
<td>
<p><code>mrs_data</code> object with one FID for each coil element.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>correlation matrix.
</p>

<hr>
<h2 id='calc_coil_noise_sd'>Calculate the noise standard deviation for each coil element.</h2><span id='topic+calc_coil_noise_sd'></span>

<h3>Description</h3>

<p>Calculate the noise standard deviation for each coil element.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_coil_noise_sd(noise_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_coil_noise_sd_+3A_noise_data">noise_data</code></td>
<td>
<p><code>mrs_data</code> object with one FID for each coil element.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array of standard deviations.
</p>

<hr>
<h2 id='calc_design_efficiency'>Calculate the efficiency of a regressor data frame.</h2><span id='topic+calc_design_efficiency'></span>

<h3>Description</h3>

<p>Calculate the efficiency of a regressor data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_design_efficiency(regressor_df, contrasts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_design_efficiency_+3A_regressor_df">regressor_df</code></td>
<td>
<p>input regressor data frame.</p>
</td></tr>
<tr><td><code id="calc_design_efficiency_+3A_contrasts">contrasts</code></td>
<td>
<p>a vector of contrast values.</p>
</td></tr>
</table>

<hr>
<h2 id='calc_ed_from_lambda'>Calculate the effective dimensions of a spline smoother from lambda.</h2><span id='topic+calc_ed_from_lambda'></span>

<h3>Description</h3>

<p>Calculate the effective dimensions of a spline smoother from lambda.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_ed_from_lambda(spline_basis, deriv_mat, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_ed_from_lambda_+3A_spline_basis">spline_basis</code></td>
<td>
<p>spline basis.</p>
</td></tr>
<tr><td><code id="calc_ed_from_lambda_+3A_deriv_mat">deriv_mat</code></td>
<td>
<p>derivative matrix.</p>
</td></tr>
<tr><td><code id="calc_ed_from_lambda_+3A_lambda">lambda</code></td>
<td>
<p>smoothing parameter.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the effective dimension value.
</p>

<hr>
<h2 id='calc_peak_info_vec'>Calculate the FWHM of a peak from a vector of intensity values.</h2><span id='topic+calc_peak_info_vec'></span>

<h3>Description</h3>

<p>Calculate the FWHM of a peak from a vector of intensity values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_peak_info_vec(data_pts, interp_f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_peak_info_vec_+3A_data_pts">data_pts</code></td>
<td>
<p>input vector.</p>
</td></tr>
<tr><td><code id="calc_peak_info_vec_+3A_interp_f">interp_f</code></td>
<td>
<p>interpolation factor to improve the FWHM estimate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of: x position of the highest data point, maximum peak
value in the y axis, FWHM in the units of data points.
</p>

<hr>
<h2 id='calc_sd_poly'>Perform a polynomial fit, subtract and return the standard deviation of the
residuals.</h2><span id='topic+calc_sd_poly'></span>

<h3>Description</h3>

<p>Perform a polynomial fit, subtract and return the standard deviation of the
residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_sd_poly(y, degree = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_sd_poly_+3A_y">y</code></td>
<td>
<p>array.</p>
</td></tr>
<tr><td><code id="calc_sd_poly_+3A_degree">degree</code></td>
<td>
<p>polynomial degree.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>standard deviation of the fit residuals.
</p>

<hr>
<h2 id='calc_spec_diff'>Calculate the sum of squares differences between two mrs_data objects.</h2><span id='topic+calc_spec_diff'></span>

<h3>Description</h3>

<p>Calculate the sum of squares differences between two mrs_data objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_spec_diff(mrs_data, ref = NULL, xlim = c(4, 0.5))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_spec_diff_+3A_mrs_data">mrs_data</code></td>
<td>
<p>mrs_data object.</p>
</td></tr>
<tr><td><code id="calc_spec_diff_+3A_ref">ref</code></td>
<td>
<p>reference mrs_data object to calculate differences.</p>
</td></tr>
<tr><td><code id="calc_spec_diff_+3A_xlim">xlim</code></td>
<td>
<p>spectral limits to perform calculation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an array of the sum of squared difference values.
</p>

<hr>
<h2 id='calc_spec_snr'>Calculate the spectral SNR.</h2><span id='topic+calc_spec_snr'></span>

<h3>Description</h3>

<p>SNR is defined as the maximum signal value divided by the standard deviation
of the noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc_spec_snr(
  mrs_data,
  sig_region = c(4, 0.5),
  noise_region = c(-0.5, -2.5),
  p_order = 2,
  interp_f = 4,
  full_output = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calc_spec_snr_+3A_mrs_data">mrs_data</code></td>
<td>
<p>an object of class <code>mrs_data</code>.</p>
</td></tr>
<tr><td><code id="calc_spec_snr_+3A_sig_region">sig_region</code></td>
<td>
<p>a ppm region to define where the maximum signal value
should be estimated.</p>
</td></tr>
<tr><td><code id="calc_spec_snr_+3A_noise_region">noise_region</code></td>
<td>
<p>a ppm region to defined where the noise level should be
estimated.</p>
</td></tr>
<tr><td><code id="calc_spec_snr_+3A_p_order">p_order</code></td>
<td>
<p>polynomial order to fit to the noise region before estimating
the standard deviation.</p>
</td></tr>
<tr><td><code id="calc_spec_snr_+3A_interp_f">interp_f</code></td>
<td>
<p>interpolation factor to improve detection of the highest
signal value.</p>
</td></tr>
<tr><td><code id="calc_spec_snr_+3A_full_output">full_output</code></td>
<td>
<p>output signal, noise and SNR values separately.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The mean noise value is subtracted from the maximum signal value to reduce DC
offset bias. A polynomial detrending fit (second order by default) is applied
to the noise region before the noise standard deviation is estimated.
</p>


<h3>Value</h3>

<p>an array of SNR values.
</p>

<hr>
<h2 id='check_lcm'>Check LCModel can be run</h2><span id='topic+check_lcm'></span>

<h3>Description</h3>

<p>Check LCModel can be run
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_lcm()
</code></pre>

<hr>
<h2 id='check_tqn'>Check the TARQUIN binary can be run</h2><span id='topic+check_tqn'></span>

<h3>Description</h3>

<p>Check the TARQUIN binary can be run
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_tqn()
</code></pre>

<hr>
<h2 id='circ_mask'>Create a logical circular mask spanning the full extent of an n x n matrix.</h2><span id='topic+circ_mask'></span>

<h3>Description</h3>

<p>Create a logical circular mask spanning the full extent of an n x n matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>circ_mask(d, n, offset = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="circ_mask_+3A_d">d</code></td>
<td>
<p>diameter of the mask.</p>
</td></tr>
<tr><td><code id="circ_mask_+3A_n">n</code></td>
<td>
<p>number of matrix rows and columns.</p>
</td></tr>
<tr><td><code id="circ_mask_+3A_offset">offset</code></td>
<td>
<p>offset the mask centre in matrix dimension units.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical n x n mask matrix.
</p>

<hr>
<h2 id='coherence_filter'>Zero all coherence orders other than the one supplied as an argument.</h2><span id='topic+coherence_filter'></span>

<h3>Description</h3>

<p>Zero all coherence orders other than the one supplied as an argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coherence_filter(sys, rho, order = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coherence_filter_+3A_sys">sys</code></td>
<td>
<p>spin system object.</p>
</td></tr>
<tr><td><code id="coherence_filter_+3A_rho">rho</code></td>
<td>
<p>density matrix.</p>
</td></tr>
<tr><td><code id="coherence_filter_+3A_order">order</code></td>
<td>
<p>coherence order to keep (default is 0).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>density matrix.
</p>

<hr>
<h2 id='collapse_to_dyns'>Collapse MRS data by concatenating spectra along the dynamic dimension.</h2><span id='topic+collapse_to_dyns'></span><span id='topic+collapse_to_dyns.mrs_data'></span><span id='topic+collapse_to_dyns.fit_result'></span>

<h3>Description</h3>

<p>Collapse MRS data by concatenating spectra along the dynamic dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse_to_dyns(x, rm_masked = FALSE)

## S3 method for class 'mrs_data'
collapse_to_dyns(x, rm_masked = FALSE)

## S3 method for class 'fit_result'
collapse_to_dyns(x, rm_masked = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapse_to_dyns_+3A_x">x</code></td>
<td>
<p>data object to be collapsed (mrs_data or fit_result object).</p>
</td></tr>
<tr><td><code id="collapse_to_dyns_+3A_rm_masked">rm_masked</code></td>
<td>
<p>remove masked dynamics from the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>collapsed data with spectra or fits concatenated along the dynamic
dimension.
</p>

<hr>
<h2 id='comb_coils'>Combine coil data based on the first data point of a reference signal.</h2><span id='topic+comb_coils'></span>

<h3>Description</h3>

<p>By default, elements are phased and scaled prior to summation. Where a
reference signal is not given, the mean dynamic signal will be used
instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comb_coils(
  metab,
  ref = NULL,
  noise = NULL,
  scale = TRUE,
  scale_method = "sig_noise_sq",
  sum_coils = TRUE,
  noise_region = c(-0.5, -2.5),
  average_ref_dyns = TRUE,
  ref_pt_index = 1,
  ret_metab_only = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comb_coils_+3A_metab">metab</code></td>
<td>
<p>MRS data containing metabolite data.</p>
</td></tr>
<tr><td><code id="comb_coils_+3A_ref">ref</code></td>
<td>
<p>MRS data containing reference data (optional).</p>
</td></tr>
<tr><td><code id="comb_coils_+3A_noise">noise</code></td>
<td>
<p>MRS data from a noise scan (optional).</p>
</td></tr>
<tr><td><code id="comb_coils_+3A_scale">scale</code></td>
<td>
<p>option to rescale coil elements based on the first data point
(logical).</p>
</td></tr>
<tr><td><code id="comb_coils_+3A_scale_method">scale_method</code></td>
<td>
<p>one of &quot;sig_noise_sq&quot;, &quot;sig_noise&quot; or &quot;sig&quot;.</p>
</td></tr>
<tr><td><code id="comb_coils_+3A_sum_coils">sum_coils</code></td>
<td>
<p>sum the coil elements as a final step (logical).</p>
</td></tr>
<tr><td><code id="comb_coils_+3A_noise_region">noise_region</code></td>
<td>
<p>the spectral region (in ppm) to estimate the noise.</p>
</td></tr>
<tr><td><code id="comb_coils_+3A_average_ref_dyns">average_ref_dyns</code></td>
<td>
<p>take the mean of the reference scans in the dynamic
dimension before use.</p>
</td></tr>
<tr><td><code id="comb_coils_+3A_ref_pt_index">ref_pt_index</code></td>
<td>
<p>time-domain point to use for estimating phase and scaling
values.</p>
</td></tr>
<tr><td><code id="comb_coils_+3A_ret_metab_only">ret_metab_only</code></td>
<td>
<p>return the metabolite data only, even if reference data
has been specified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>MRS data.
</p>

<hr>
<h2 id='comb_coils_mrsi_gls'>Combine MRSI coil data using the GLS method presented by An et al
JMRI 37:1445-1450 (2013).</h2><span id='topic+comb_coils_mrsi_gls'></span>

<h3>Description</h3>

<p>Combine MRSI coil data using the GLS method presented by An et al
JMRI 37:1445-1450 (2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comb_coils_mrsi_gls(metab, noise_pts = 30, noise_mrs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comb_coils_mrsi_gls_+3A_metab">metab</code></td>
<td>
<p>MRSI data containing metabolite data.</p>
</td></tr>
<tr><td><code id="comb_coils_mrsi_gls_+3A_noise_pts">noise_pts</code></td>
<td>
<p>number of points from the end of the FIDs to use for noise
covariance estimation.</p>
</td></tr>
<tr><td><code id="comb_coils_mrsi_gls_+3A_noise_mrs">noise_mrs</code></td>
<td>
<p>MRS data containing noise information for each coil.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>coil combined MRSI data.
</p>

<hr>
<h2 id='comb_coils_svs_gls'>Combine SVS coil data using the GLS method presented by An et al
JMRI 37:1445-1450 (2013).</h2><span id='topic+comb_coils_svs_gls'></span>

<h3>Description</h3>

<p>Combine SVS coil data using the GLS method presented by An et al
JMRI 37:1445-1450 (2013).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comb_coils_svs_gls(
  metab,
  ref = NULL,
  noise_pts = 256,
  noise_mrs = NULL,
  use_mean_sens = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comb_coils_svs_gls_+3A_metab">metab</code></td>
<td>
<p>MRS data containing metabolite data.</p>
</td></tr>
<tr><td><code id="comb_coils_svs_gls_+3A_ref">ref</code></td>
<td>
<p>MRS data containing reference data (optional).</p>
</td></tr>
<tr><td><code id="comb_coils_svs_gls_+3A_noise_pts">noise_pts</code></td>
<td>
<p>number of points from the end of the FIDs to use for noise
covariance estimation.</p>
</td></tr>
<tr><td><code id="comb_coils_svs_gls_+3A_noise_mrs">noise_mrs</code></td>
<td>
<p>MRS data containing noise information for each coil.</p>
</td></tr>
<tr><td><code id="comb_coils_svs_gls_+3A_use_mean_sens">use_mean_sens</code></td>
<td>
<p>use the dynamic mean to estimate coil sensitivities.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>coil combined MRS data.
</p>

<hr>
<h2 id='comb_fit_list_fit_tables'>Combine all fitting data points from a list of fits into a single data frame.</h2><span id='topic+comb_fit_list_fit_tables'></span>

<h3>Description</h3>

<p>Combine all fitting data points from a list of fits into a single data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comb_fit_list_fit_tables(
  fit_list,
  add_extra = TRUE,
  harmonise_ppm = TRUE,
  inc_basis_sigs = FALSE,
  inc_indices = TRUE,
  add_res_id = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comb_fit_list_fit_tables_+3A_fit_list">fit_list</code></td>
<td>
<p>list of fit_result objects.</p>
</td></tr>
<tr><td><code id="comb_fit_list_fit_tables_+3A_add_extra">add_extra</code></td>
<td>
<p>add variables in the extra data frame to the output (TRUE).</p>
</td></tr>
<tr><td><code id="comb_fit_list_fit_tables_+3A_harmonise_ppm">harmonise_ppm</code></td>
<td>
<p>ensure the ppm scale for each fit is identical to the
first.</p>
</td></tr>
<tr><td><code id="comb_fit_list_fit_tables_+3A_inc_basis_sigs">inc_basis_sigs</code></td>
<td>
<p>include the individual fitting basis signals in the
output table, defaults to FALSE.</p>
</td></tr>
<tr><td><code id="comb_fit_list_fit_tables_+3A_inc_indices">inc_indices</code></td>
<td>
<p>include indices such as X, Y and coil in the output,
defaults to TRUE. These are generally not useful for SVS analysis.</p>
</td></tr>
<tr><td><code id="comb_fit_list_fit_tables_+3A_add_res_id">add_res_id</code></td>
<td>
<p>add a res_id column to the output to distinguish between
datasets.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame containing the fit data points.
</p>

<hr>
<h2 id='comb_fit_list_result_tables'>Combine the fit result tables from a list of fit results.</h2><span id='topic+comb_fit_list_result_tables'></span>

<h3>Description</h3>

<p>Combine the fit result tables from a list of fit results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comb_fit_list_result_tables(fit_list, add_extra = TRUE, add_res_id = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comb_fit_list_result_tables_+3A_fit_list">fit_list</code></td>
<td>
<p>a list of fit_result objects.</p>
</td></tr>
<tr><td><code id="comb_fit_list_result_tables_+3A_add_extra">add_extra</code></td>
<td>
<p>add variables in the extra data frame to the output (TRUE).</p>
</td></tr>
<tr><td><code id="comb_fit_list_result_tables_+3A_add_res_id">add_res_id</code></td>
<td>
<p>add a res_id column to the output to distinguish between
datasets.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame combine all fit result tables with an additional id
column to differentiate between data sets. Any variables in the extra data
frame may be optionally added to the result.
</p>

<hr>
<h2 id='comb_fit_tables'>Combine all fitting data points into a single data frame.</h2><span id='topic+comb_fit_tables'></span>

<h3>Description</h3>

<p>Combine all fitting data points into a single data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comb_fit_tables(fit_res, inc_basis_sigs = FALSE, inc_indices = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comb_fit_tables_+3A_fit_res">fit_res</code></td>
<td>
<p>a single fit_result object.</p>
</td></tr>
<tr><td><code id="comb_fit_tables_+3A_inc_basis_sigs">inc_basis_sigs</code></td>
<td>
<p>include the individual fitting basis signals in the
output table, defaults to FALSE.</p>
</td></tr>
<tr><td><code id="comb_fit_tables_+3A_inc_indices">inc_indices</code></td>
<td>
<p>include indices such as X, Y and coil in the output,
defaults to TRUE. These are generally not useful for SVS analysis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame containing the fit data points.
</p>

<hr>
<h2 id='comb_metab_ref'>Combine a reference and metabolite mrs_data object.</h2><span id='topic+comb_metab_ref'></span>

<h3>Description</h3>

<p>Combine a reference and metabolite mrs_data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>comb_metab_ref(metab, ref)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="comb_metab_ref_+3A_metab">metab</code></td>
<td>
<p>metabolite mrs_data object.</p>
</td></tr>
<tr><td><code id="comb_metab_ref_+3A_ref">ref</code></td>
<td>
<p>reference mrs_data object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>combined metabolite and reference mrs_data object.
</p>

<hr>
<h2 id='Conj.mrs_data'>Apply Conj operator to an MRS dataset.</h2><span id='topic+Conj.mrs_data'></span>

<h3>Description</h3>

<p>Apply Conj operator to an MRS dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mrs_data'
Conj(z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Conj.mrs_data_+3A_z">z</code></td>
<td>
<p>MRS data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>MRS data following Conj operator.
</p>

<hr>
<h2 id='conv_mrs'>Convolve two MRS data objects.</h2><span id='topic+conv_mrs'></span>

<h3>Description</h3>

<p>Convolve two MRS data objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>conv_mrs(mrs_data, conv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="conv_mrs_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data to be convolved.</p>
</td></tr>
<tr><td><code id="conv_mrs_+3A_conv">conv</code></td>
<td>
<p>convolution data stored as an mrs_data object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>convolved data.
</p>

<hr>
<h2 id='crop_basis'>Crop <code>basis_set</code> object based on a frequency range.</h2><span id='topic+crop_basis'></span>

<h3>Description</h3>

<p>Crop <code>basis_set</code> object based on a frequency range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crop_basis(basis, xlim = c(4, 0.2), scale = "ppm")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crop_basis_+3A_basis">basis</code></td>
<td>
<p>basis_set object to be cropped in the spectral dimension.</p>
</td></tr>
<tr><td><code id="crop_basis_+3A_xlim">xlim</code></td>
<td>
<p>range of values to crop in the spectral dimension eg
xlim = c(4, 0.2).</p>
</td></tr>
<tr><td><code id="crop_basis_+3A_scale">scale</code></td>
<td>
<p>the units to use for the frequency scale, can be one of: &quot;ppm&quot;,
&quot;hz&quot; or &quot;points&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>cropped <code>mrs_data</code> object.
</p>

<hr>
<h2 id='crop_spec'>Crop <code>mrs_data</code> object based on a frequency range.</h2><span id='topic+crop_spec'></span>

<h3>Description</h3>

<p>Crop <code>mrs_data</code> object based on a frequency range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crop_spec(mrs_data, xlim = c(4, 0.2), scale = "ppm")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crop_spec_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
<tr><td><code id="crop_spec_+3A_xlim">xlim</code></td>
<td>
<p>range of values to crop in the spectral dimension eg
xlim = c(4, 0.2).</p>
</td></tr>
<tr><td><code id="crop_spec_+3A_scale">scale</code></td>
<td>
<p>the units to use for the frequency scale, can be one of: &quot;ppm&quot;,
&quot;hz&quot; or &quot;points&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>cropped <code>mrs_data</code> object.
</p>

<hr>
<h2 id='crop_td_pts'>Crop <code>mrs_data</code> object data points in the time-domain.</h2><span id='topic+crop_td_pts'></span>

<h3>Description</h3>

<p>Crop <code>mrs_data</code> object data points in the time-domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crop_td_pts(mrs_data, start = NULL, end = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crop_td_pts_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
<tr><td><code id="crop_td_pts_+3A_start">start</code></td>
<td>
<p>starting data point (defaults to 1).</p>
</td></tr>
<tr><td><code id="crop_td_pts_+3A_end">end</code></td>
<td>
<p>ending data point (defaults to the last saved point).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>cropped <code>mrs_data</code> object.
</p>

<hr>
<h2 id='crop_td_pts_end'>Crop <code>mrs_data</code> object data points at the end of the FID.</h2><span id='topic+crop_td_pts_end'></span>

<h3>Description</h3>

<p>Crop <code>mrs_data</code> object data points at the end of the FID.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crop_td_pts_end(mrs_data, pts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crop_td_pts_end_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
<tr><td><code id="crop_td_pts_end_+3A_pts">pts</code></td>
<td>
<p>number of points to remove from the end of the FID.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>cropped <code>mrs_data</code> object.
</p>

<hr>
<h2 id='crop_td_pts_pot'>Crop <code>mrs_data</code> object data points in the time-domain rounding down to
the next smallest power of two (pot). Data that already has a pot length will
not be changed.</h2><span id='topic+crop_td_pts_pot'></span>

<h3>Description</h3>

<p>Crop <code>mrs_data</code> object data points in the time-domain rounding down to
the next smallest power of two (pot). Data that already has a pot length will
not be changed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crop_td_pts_pot(mrs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crop_td_pts_pot_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>cropped <code>mrs_data</code> object.
</p>

<hr>
<h2 id='crop_xy'>Crop an MRSI dataset in the x-y direction</h2><span id='topic+crop_xy'></span>

<h3>Description</h3>

<p>Crop an MRSI dataset in the x-y direction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crop_xy(mrs_data, x_dim, y_dim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crop_xy_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data object.</p>
</td></tr>
<tr><td><code id="crop_xy_+3A_x_dim">x_dim</code></td>
<td>
<p>x dimension output length.</p>
</td></tr>
<tr><td><code id="crop_xy_+3A_y_dim">y_dim</code></td>
<td>
<p>y dimension output length.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>selected subset of MRS data.
</p>

<hr>
<h2 id='crossprod_3d'>Compute the vector cross product between vectors x and y. Adapted from
http://stackoverflow.com/questions/15162741/what-is-rs-crossproduct-function</h2><span id='topic+crossprod_3d'></span>

<h3>Description</h3>

<p>Compute the vector cross product between vectors x and y. Adapted from
http://stackoverflow.com/questions/15162741/what-is-rs-crossproduct-function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>crossprod_3d(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="crossprod_3d_+3A_x">x</code></td>
<td>
<p>vector of length 3.</p>
</td></tr>
<tr><td><code id="crossprod_3d_+3A_y">y</code></td>
<td>
<p>vector of length 3.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector cross product of x and y.
</p>

<hr>
<h2 id='decimate_mrs_fd'>Decimate an MRS signal to half the original sampling frequency by filtering
in the frequency domain before down sampling.</h2><span id='topic+decimate_mrs_fd'></span>

<h3>Description</h3>

<p>Decimate an MRS signal to half the original sampling frequency by filtering
in the frequency domain before down sampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decimate_mrs_fd(mrs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decimate_mrs_fd_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>decimated data at half the original sampling frequency.
</p>

<hr>
<h2 id='decimate_mrs_td'>Decimate an MRS signal by filtering in the time domain before downsampling.</h2><span id='topic+decimate_mrs_td'></span>

<h3>Description</h3>

<p>Decimate an MRS signal by filtering in the time domain before downsampling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>decimate_mrs_td(mrs_data, q = 2, n = 4, ftype = "iir")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="decimate_mrs_td_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data object.</p>
</td></tr>
<tr><td><code id="decimate_mrs_td_+3A_q">q</code></td>
<td>
<p>integer factor to downsample by (default = 2).</p>
</td></tr>
<tr><td><code id="decimate_mrs_td_+3A_n">n</code></td>
<td>
<p>filter order used in the downsampling.</p>
</td></tr>
<tr><td><code id="decimate_mrs_td_+3A_ftype">ftype</code></td>
<td>
<p>filter type, &quot;iir&quot; or &quot;fir&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>decimated data.
</p>

<hr>
<h2 id='deconv_mrs'>Deconvolve two MRS data objects.</h2><span id='topic+deconv_mrs'></span>

<h3>Description</h3>

<p>Deconvolve two MRS data objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deconv_mrs(mrs_data_a, mrs_data_b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deconv_mrs_+3A_mrs_data_a">mrs_data_a</code></td>
<td>
<p>MRS data to be deconvolved.</p>
</td></tr>
<tr><td><code id="deconv_mrs_+3A_mrs_data_b">mrs_data_b</code></td>
<td>
<p>MRS data to be deconvolved.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>deconvolved data.
</p>

<hr>
<h2 id='def_acq_paras'>Return (and optionally modify using the input arguments) a list of the
default acquisition parameters.</h2><span id='topic+def_acq_paras'></span>

<h3>Description</h3>

<p>Return (and optionally modify using the input arguments) a list of the
default acquisition parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>def_acq_paras(
  ft = getOption("spant.def_ft"),
  fs = getOption("spant.def_fs"),
  N = getOption("spant.def_N"),
  ref = getOption("spant.def_ref"),
  nuc = getOption("spant.def_nuc")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="def_acq_paras_+3A_ft">ft</code></td>
<td>
<p>specify the transmitter frequency in Hz.</p>
</td></tr>
<tr><td><code id="def_acq_paras_+3A_fs">fs</code></td>
<td>
<p>specify the sampling frequency in Hz.</p>
</td></tr>
<tr><td><code id="def_acq_paras_+3A_n">N</code></td>
<td>
<p>specify the number of data points in the spectral dimension.</p>
</td></tr>
<tr><td><code id="def_acq_paras_+3A_ref">ref</code></td>
<td>
<p>specify the reference value for ppm scale.</p>
</td></tr>
<tr><td><code id="def_acq_paras_+3A_nuc">nuc</code></td>
<td>
<p>specify the resonant nucleus.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements:
</p>

<ul>
<li><p> ft transmitter frequency in Hz.
</p>
</li>
<li><p> fs sampling frequency in Hz.
</p>
</li>
<li><p> N number of data points in the spectral dimension.
</p>
</li>
<li><p> ref reference value for ppm scale.
</p>
</li>
<li><p> nuc resonant nucleus.
</p>
</li></ul>


<hr>
<h2 id='def_fs'>Return the default sampling frequency in Hz.</h2><span id='topic+def_fs'></span>

<h3>Description</h3>

<p>Return the default sampling frequency in Hz.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>def_fs()
</code></pre>


<h3>Value</h3>

<p>sampling frequency in Hz.
</p>

<hr>
<h2 id='def_ft'>Return the default transmitter frequency in Hz.</h2><span id='topic+def_ft'></span>

<h3>Description</h3>

<p>Return the default transmitter frequency in Hz.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>def_ft()
</code></pre>


<h3>Value</h3>

<p>transmitter frequency in Hz.
</p>

<hr>
<h2 id='def_N'>Return the default number of data points in the spectral dimension.</h2><span id='topic+def_N'></span>

<h3>Description</h3>

<p>Return the default number of data points in the spectral dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>def_N()
</code></pre>


<h3>Value</h3>

<p>number of data points in the spectral dimension.
</p>

<hr>
<h2 id='def_nuc'>Return the default nucleus.</h2><span id='topic+def_nuc'></span>

<h3>Description</h3>

<p>Return the default nucleus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>def_nuc()
</code></pre>


<h3>Value</h3>

<p>number of data points in the spectral dimension.
</p>

<hr>
<h2 id='def_ref'>Return the default reference value for ppm scale.</h2><span id='topic+def_ref'></span>

<h3>Description</h3>

<p>Return the default reference value for ppm scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>def_ref()
</code></pre>


<h3>Value</h3>

<p>reference value for ppm scale.
</p>

<hr>
<h2 id='dicom_reader'>A very simple DICOM reader.</h2><span id='topic+dicom_reader'></span>

<h3>Description</h3>

<p>Note this reader is very basic and does not use a DICOM dictionary or try to
convert the data to the correct datatype. For a more robust and sophisticated
reader use the oro.dicom package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dicom_reader(
  input,
  tags = list(sop_class_uid = "0008,0016"),
  endian = "little",
  debug = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dicom_reader_+3A_input">input</code></td>
<td>
<p>either a file path or raw binary object.</p>
</td></tr>
<tr><td><code id="dicom_reader_+3A_tags">tags</code></td>
<td>
<p>a named list of tags to be extracted from the file.
eg tags &lt;- list(spec_data = &quot;7FE1,1010&quot;, pat_name = &quot;0010,0010&quot;)</p>
</td></tr>
<tr><td><code id="dicom_reader_+3A_endian">endian</code></td>
<td>
<p>can be &quot;little&quot; or &quot;big&quot;.</p>
</td></tr>
<tr><td><code id="dicom_reader_+3A_debug">debug</code></td>
<td>
<p>print out some debugging information, can be &quot;little&quot; or &quot;big&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list with the same structure as the input, but with tag codes
replaced with the corresponding data in a raw format.
</p>

<hr>
<h2 id='diff_mrs'>Apply the diff operator to an MRS dataset in the FID/spectral dimension.</h2><span id='topic+diff_mrs'></span>

<h3>Description</h3>

<p>Apply the diff operator to an MRS dataset in the FID/spectral dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diff_mrs(mrs_data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diff_mrs_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
<tr><td><code id="diff_mrs_+3A_...">...</code></td>
<td>
<p>additional arguments to the diff function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>MRS data following diff operator.
</p>

<hr>
<h2 id='downsample_mrs_fd'>Downsample an MRS signal by a factor of 2 using an FFT &quot;brick-wall&quot; filter.</h2><span id='topic+downsample_mrs_fd'></span>

<h3>Description</h3>

<p>Downsample an MRS signal by a factor of 2 using an FFT &quot;brick-wall&quot; filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>downsample_mrs_fd(mrs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="downsample_mrs_fd_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>downsampled data.
</p>

<hr>
<h2 id='downsample_mrs_td'>Downsample an MRS signal by a factor of 2 by removing every other data point
in the time-domain. Note, signals outside the new sampling frequency will be
aliased.</h2><span id='topic+downsample_mrs_td'></span>

<h3>Description</h3>

<p>Downsample an MRS signal by a factor of 2 by removing every other data point
in the time-domain. Note, signals outside the new sampling frequency will be
aliased.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>downsample_mrs_td(mrs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="downsample_mrs_td_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>downsampled data.
</p>

<hr>
<h2 id='dyn_acq_times'>Return a time scale vector of acquisition times for a dynamic MRS scan. The
first temporal scan is assigned a value of 0.</h2><span id='topic+dyn_acq_times'></span>

<h3>Description</h3>

<p>Return a time scale vector of acquisition times for a dynamic MRS scan. The
first temporal scan is assigned a value of 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dyn_acq_times(mrs_data = NULL, tr = NULL, Ndyns = NULL, Ntrans = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dyn_acq_times_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
<tr><td><code id="dyn_acq_times_+3A_tr">tr</code></td>
<td>
<p>repetition time.</p>
</td></tr>
<tr><td><code id="dyn_acq_times_+3A_ndyns">Ndyns</code></td>
<td>
<p>number of dynamic scans stored, potentially less than Ntrans
if block averaging has been performed.</p>
</td></tr>
<tr><td><code id="dyn_acq_times_+3A_ntrans">Ntrans</code></td>
<td>
<p>number of dynamic scans acquired.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>time scale vector in units of seconds.
</p>

<hr>
<h2 id='ecc'>Eddy current correction.</h2><span id='topic+ecc'></span>

<h3>Description</h3>

<p>Apply eddy current correction using the Klose method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ecc(metab, ref, rev = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ecc_+3A_metab">metab</code></td>
<td>
<p>MRS data to be corrected.</p>
</td></tr>
<tr><td><code id="ecc_+3A_ref">ref</code></td>
<td>
<p>reference dataset.</p>
</td></tr>
<tr><td><code id="ecc_+3A_rev">rev</code></td>
<td>
<p>reverse the correction.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In vivo proton spectroscopy in presence of eddy currents.
Klose U.
Magn Reson Med. 1990 Apr;14(1):26-30.
</p>


<h3>Value</h3>

<p>corrected data in the time domain.
</p>

<hr>
<h2 id='elliptical_mask'>Create an elliptical mask stored as a matrix of logical values.</h2><span id='topic+elliptical_mask'></span>

<h3>Description</h3>

<p>Create an elliptical mask stored as a matrix of logical values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elliptical_mask(xN, yN, x0, y0, xr, yr, angle)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="elliptical_mask_+3A_xn">xN</code></td>
<td>
<p>number of pixels in the x dimension.</p>
</td></tr>
<tr><td><code id="elliptical_mask_+3A_yn">yN</code></td>
<td>
<p>number of pixels in the y dimension.</p>
</td></tr>
<tr><td><code id="elliptical_mask_+3A_x0">x0</code></td>
<td>
<p>centre of ellipse in the x direction in units of pixels.</p>
</td></tr>
<tr><td><code id="elliptical_mask_+3A_y0">y0</code></td>
<td>
<p>centre of ellipse in the y direction in units of pixels.</p>
</td></tr>
<tr><td><code id="elliptical_mask_+3A_xr">xr</code></td>
<td>
<p>radius in the x direction in units of pixels.</p>
</td></tr>
<tr><td><code id="elliptical_mask_+3A_yr">yr</code></td>
<td>
<p>radius in the y direction in units of pixels.</p>
</td></tr>
<tr><td><code id="elliptical_mask_+3A_angle">angle</code></td>
<td>
<p>angle of rotation in degrees.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical mask matrix with dimensions fov_yN x fov_xN.
</p>

<hr>
<h2 id='est_noise_sd'>Estimate the standard deviation of the noise from a segment of an mrs_data
object.</h2><span id='topic+est_noise_sd'></span>

<h3>Description</h3>

<p>Estimate the standard deviation of the noise from a segment of an mrs_data
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>est_noise_sd(mrs_data, n = 100, offset = 100, p_order = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="est_noise_sd_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data object.</p>
</td></tr>
<tr><td><code id="est_noise_sd_+3A_n">n</code></td>
<td>
<p>number of data points (taken from the end of array) to use in the
estimation.</p>
</td></tr>
<tr><td><code id="est_noise_sd_+3A_offset">offset</code></td>
<td>
<p>number of final points to exclude from the calculation.</p>
</td></tr>
<tr><td><code id="est_noise_sd_+3A_p_order">p_order</code></td>
<td>
<p>polynomial order to fit to the data before estimating the
standard deviation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>standard deviation array.
</p>

<hr>
<h2 id='fd_conv_filt'>Frequency-domain convolution based filter.</h2><span id='topic+fd_conv_filt'></span>

<h3>Description</h3>

<p>Frequency-domain convolution based filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fd_conv_filt(mrs_data, K = 25, ext = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fd_conv_filt_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data to be filtered.</p>
</td></tr>
<tr><td><code id="fd_conv_filt_+3A_k">K</code></td>
<td>
<p>window width in data points.</p>
</td></tr>
<tr><td><code id="fd_conv_filt_+3A_ext">ext</code></td>
<td>
<p>point separation for linear extrapolation.</p>
</td></tr>
</table>

<hr>
<h2 id='fd_gauss_smo'>Apply a Gaussian smoother in the spectral domain.</h2><span id='topic+fd_gauss_smo'></span>

<h3>Description</h3>

<p>Apply a Gaussian smoother in the spectral domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fd_gauss_smo(mrs_data, smo_ppm_sd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fd_gauss_smo_+3A_mrs_data">mrs_data</code></td>
<td>
<p>mrs_data object.</p>
</td></tr>
<tr><td><code id="fd_gauss_smo_+3A_smo_ppm_sd">smo_ppm_sd</code></td>
<td>
<p>Gaussian smoother sd in ppm units.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>spectrally smoothed data.
</p>

<hr>
<h2 id='fd2td'>Transform frequency-domain data to the time-domain.</h2><span id='topic+fd2td'></span>

<h3>Description</h3>

<p>Transform frequency-domain data to the time-domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fd2td(mrs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fd2td_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data in frequency-domain representation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>MRS data in time-domain representation.
</p>

<hr>
<h2 id='find_bids_mrs'>Search for MRS data files in a BIDS filesystem structure.</h2><span id='topic+find_bids_mrs'></span>

<h3>Description</h3>

<p>Search for MRS data files in a BIDS filesystem structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_bids_mrs(path, output_full_path = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_bids_mrs_+3A_path">path</code></td>
<td>
<p>path to the directory containing the BIDS structure.</p>
</td></tr>
<tr><td><code id="find_bids_mrs_+3A_output_full_path">output_full_path</code></td>
<td>
<p>output the full normalised data paths.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame containing full paths and information on each MRS file.
</p>

<hr>
<h2 id='find_mrs_files'>Find valid MRS data files recursively from a directory path.</h2><span id='topic+find_mrs_files'></span>

<h3>Description</h3>

<p>Find valid MRS data files recursively from a directory path.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>find_mrs_files(dir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="find_mrs_files_+3A_dir">dir</code></td>
<td>
<p>a directory path.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of valid MRS data files.
</p>

<hr>
<h2 id='fit_amps'>Extract the fit amplitudes from an object of class <code>fit_result</code>.</h2><span id='topic+fit_amps'></span>

<h3>Description</h3>

<p>Extract the fit amplitudes from an object of class <code>fit_result</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_amps(
  x,
  inc_index = FALSE,
  sort_names = FALSE,
  append_common_1h_comb = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_amps_+3A_x">x</code></td>
<td>
<p><code>fit_result</code> object.</p>
</td></tr>
<tr><td><code id="fit_amps_+3A_inc_index">inc_index</code></td>
<td>
<p>include columns for the voxel index.</p>
</td></tr>
<tr><td><code id="fit_amps_+3A_sort_names">sort_names</code></td>
<td>
<p>sort the basis set names alphabetically.</p>
</td></tr>
<tr><td><code id="fit_amps_+3A_append_common_1h_comb">append_common_1h_comb</code></td>
<td>
<p>append commonly used 1H metabolite combinations
eg tNAA = NAA + NAAG.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe of amplitudes.
</p>

<hr>
<h2 id='fit_diags'>Calculate diagnostic information for object of class <code>fit_result</code>.</h2><span id='topic+fit_diags'></span>

<h3>Description</h3>

<p>Calculate diagnostic information for object of class <code>fit_result</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_diags(x, amps = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_diags_+3A_x">x</code></td>
<td>
<p><code>fit_result</code> object.</p>
</td></tr>
<tr><td><code id="fit_diags_+3A_amps">amps</code></td>
<td>
<p>known metabolite amplitudes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a dataframe of diagnostic information.
</p>

<hr>
<h2 id='fit_mrs'>Perform a fit based analysis of MRS data.</h2><span id='topic+fit_mrs'></span>

<h3>Description</h3>

<p>Note that TARQUIN and LCModel require these packages to be installed, and
the functions set_tqn_cmd and set_lcm_cmd (respectively) need to be used to
specify the location of these software packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_mrs(
  metab,
  basis = NULL,
  method = "ABFIT",
  w_ref = NULL,
  opts = NULL,
  parallel = FALSE,
  time = TRUE,
  progress = "text",
  extra = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_mrs_+3A_metab">metab</code></td>
<td>
<p>metabolite data.</p>
</td></tr>
<tr><td><code id="fit_mrs_+3A_basis">basis</code></td>
<td>
<p>basis class object or character vector to basis file in
LCModel .basis format.</p>
</td></tr>
<tr><td><code id="fit_mrs_+3A_method">method</code></td>
<td>
<p>'ABFIT' (default), 'VARPRO', 'VARPRO_3P', 'TARQUIN' or
'LCMODEL'.</p>
</td></tr>
<tr><td><code id="fit_mrs_+3A_w_ref">w_ref</code></td>
<td>
<p>water reference data for concentration scaling (optional).</p>
</td></tr>
<tr><td><code id="fit_mrs_+3A_opts">opts</code></td>
<td>
<p>options to pass to the analysis method.</p>
</td></tr>
<tr><td><code id="fit_mrs_+3A_parallel">parallel</code></td>
<td>
<p>perform analyses in parallel (TRUE or FALSE).</p>
</td></tr>
<tr><td><code id="fit_mrs_+3A_time">time</code></td>
<td>
<p>measure the time taken for the analysis to complete
(TRUE or FALSE).</p>
</td></tr>
<tr><td><code id="fit_mrs_+3A_progress">progress</code></td>
<td>
<p>option is passed to plyr::alply function to display a
progress bar during fitting. Default value is &quot;text&quot;, set to &quot;none&quot; to
disable.</p>
</td></tr>
<tr><td><code id="fit_mrs_+3A_extra">extra</code></td>
<td>
<p>an optional data frame to provide additional variables for use
in subsequent analysis steps, eg id or grouping variables.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Fitting approaches described in the following references:
ABfit
Wilson, M. Adaptive baseline fitting for 1H MR spectroscopy analysis. Magn
Reson Med 2012;85:13-29.
</p>
<p>VARPRO
van der Veen JW, de Beer R, Luyten PR, van Ormondt D. Accurate quantification
of in vivo 31P NMR signals using the variable projection method and prior
knowledge. Magn Reson Med 1988;6:92-98.
</p>
<p>TARQUIN
Wilson, M., Reynolds, G., Kauppinen, R. A., Arvanitis, T. N. &amp; Peet, A. C.
A constrained least-squares approach to the automated quantitation of in vivo
1H magnetic resonance spectroscopy data. Magn Reson Med 2011;65:1-12.
</p>
<p>LCModel
Provencher SW. Estimation of metabolite concentrations from localized in vivo
proton NMR spectra. Magn Reson Med 1993;30:672-679.
</p>


<h3>Value</h3>

<p>MRS analysis object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fname &lt;- system.file("extdata", "philips_spar_sdat_WS.SDAT", package =
"spant")
svs &lt;- read_mrs(fname)
## Not run: 
basis &lt;- sim_basis_1h_brain_press(svs)
fit_result &lt;- fit_mrs(svs, basis)

## End(Not run)
</code></pre>

<hr>
<h2 id='fit_res2csv'>Write fit results table to a csv file.</h2><span id='topic+fit_res2csv'></span>

<h3>Description</h3>

<p>Write fit results table to a csv file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_res2csv(fit_res, fname, unscaled = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_res2csv_+3A_fit_res">fit_res</code></td>
<td>
<p>fit result object.</p>
</td></tr>
<tr><td><code id="fit_res2csv_+3A_fname">fname</code></td>
<td>
<p>filename of csv file.</p>
</td></tr>
<tr><td><code id="fit_res2csv_+3A_unscaled">unscaled</code></td>
<td>
<p>output the unscaled result table (default = FALSE).</p>
</td></tr>
</table>

<hr>
<h2 id='fit_t1_ti_array'>Fit a T1 recovery curve, from multiple TIs, to a set of amplitudes.</h2><span id='topic+fit_t1_ti_array'></span>

<h3>Description</h3>

<p>Fit a T1 recovery curve, from multiple TIs, to a set of amplitudes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_t1_ti_array(
  ti_vec,
  amp_vec,
  lower = 0,
  upper = 10,
  output_fit_res = 0.01,
  ret_full = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_t1_ti_array_+3A_ti_vec">ti_vec</code></td>
<td>
<p>vector of TI values in seconds.</p>
</td></tr>
<tr><td><code id="fit_t1_ti_array_+3A_amp_vec">amp_vec</code></td>
<td>
<p>vector of amplitudes.</p>
</td></tr>
<tr><td><code id="fit_t1_ti_array_+3A_lower">lower</code></td>
<td>
<p>minimum allowable T1 value.</p>
</td></tr>
<tr><td><code id="fit_t1_ti_array_+3A_upper">upper</code></td>
<td>
<p>maximum allowable T1 value.</p>
</td></tr>
<tr><td><code id="fit_t1_ti_array_+3A_output_fit_res">output_fit_res</code></td>
<td>
<p>temporal resolution (seconds) of the ideal output
relaxation curve.</p>
</td></tr>
<tr><td><code id="fit_t1_ti_array_+3A_ret_full">ret_full</code></td>
<td>
<p>return full fitting information including ideal relaxation
curve.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing relaxation parameters and an ideal curve for fit
evaluation.
</p>

<hr>
<h2 id='fit_t1_tr_array'>Fit a T1 recovery curve, from multiple TRs, to a set of amplitudes.</h2><span id='topic+fit_t1_tr_array'></span>

<h3>Description</h3>

<p>Fit a T1 recovery curve, from multiple TRs, to a set of amplitudes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_t1_tr_array(
  tr_vec,
  amp_vec,
  lower = 0,
  upper = 10,
  output_fit_res = 0.01,
  ret_full = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_t1_tr_array_+3A_tr_vec">tr_vec</code></td>
<td>
<p>vector of TR values in seconds.</p>
</td></tr>
<tr><td><code id="fit_t1_tr_array_+3A_amp_vec">amp_vec</code></td>
<td>
<p>vector of amplitudes.</p>
</td></tr>
<tr><td><code id="fit_t1_tr_array_+3A_lower">lower</code></td>
<td>
<p>minimum allowable T1 value.</p>
</td></tr>
<tr><td><code id="fit_t1_tr_array_+3A_upper">upper</code></td>
<td>
<p>maximum allowable T1 value.</p>
</td></tr>
<tr><td><code id="fit_t1_tr_array_+3A_output_fit_res">output_fit_res</code></td>
<td>
<p>temporal resolution (seconds) of the ideal output
relaxation curve.</p>
</td></tr>
<tr><td><code id="fit_t1_tr_array_+3A_ret_full">ret_full</code></td>
<td>
<p>return full fitting information including ideal relaxation
curve.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing relaxation parameters and an ideal curve for fit
evaluation.
</p>

<hr>
<h2 id='fit_t2_te_array'>Fit a T2 relaxation curve, from multiple TEs, to a set of amplitudes.</h2><span id='topic+fit_t2_te_array'></span>

<h3>Description</h3>

<p>Fit a T2 relaxation curve, from multiple TEs, to a set of amplitudes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_t2_te_array(
  te_vec,
  amp_vec,
  lower = 0,
  upper = 10,
  output_fit_res = 0.01,
  ret_full = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_t2_te_array_+3A_te_vec">te_vec</code></td>
<td>
<p>vector of TE values in seconds.</p>
</td></tr>
<tr><td><code id="fit_t2_te_array_+3A_amp_vec">amp_vec</code></td>
<td>
<p>vector of amplitudes.</p>
</td></tr>
<tr><td><code id="fit_t2_te_array_+3A_lower">lower</code></td>
<td>
<p>minimum allowable T2 value.</p>
</td></tr>
<tr><td><code id="fit_t2_te_array_+3A_upper">upper</code></td>
<td>
<p>maximum allowable T2 value.</p>
</td></tr>
<tr><td><code id="fit_t2_te_array_+3A_output_fit_res">output_fit_res</code></td>
<td>
<p>temporal resolution (seconds) of the ideal output
relaxation curve.</p>
</td></tr>
<tr><td><code id="fit_t2_te_array_+3A_ret_full">ret_full</code></td>
<td>
<p>return full fitting information including ideal relaxation
curve.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing relaxation parameters and an ideal curve for fit
evaluation.
</p>

<hr>
<h2 id='fp_phase'>Return the phase of the first data point in the time-domain.</h2><span id='topic+fp_phase'></span>

<h3>Description</h3>

<p>Return the phase of the first data point in the time-domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fp_phase(mrs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fp_phase_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>phase values in degrees.
</p>

<hr>
<h2 id='fp_phase_correct'>Perform a zeroth order phase correction based on the phase of the first data
point in the time-domain.</h2><span id='topic+fp_phase_correct'></span>

<h3>Description</h3>

<p>Perform a zeroth order phase correction based on the phase of the first data
point in the time-domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fp_phase_correct(mrs_data, ret_phase = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fp_phase_correct_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data to be corrected.</p>
</td></tr>
<tr><td><code id="fp_phase_correct_+3A_ret_phase">ret_phase</code></td>
<td>
<p>return phase values (logical).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>corrected data or a list with corrected data and optional phase
values.
</p>

<hr>
<h2 id='fp_scale'>Scale the first time-domain data point in an mrs_data object.</h2><span id='topic+fp_scale'></span>

<h3>Description</h3>

<p>Scale the first time-domain data point in an mrs_data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fp_scale(mrs_data, scale = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fp_scale_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
<tr><td><code id="fp_scale_+3A_scale">scale</code></td>
<td>
<p>scaling value, defaults to 0.5.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>scaled mrs_data object.
</p>

<hr>
<h2 id='fs'>Return the sampling frequency in Hz of an MRS dataset.</h2><span id='topic+fs'></span>

<h3>Description</h3>

<p>Return the sampling frequency in Hz of an MRS dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fs(mrs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fs_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sampling frequency in Hz.
</p>

<hr>
<h2 id='ft_dyns'>Apply the Fourier transform over the dynamic dimension.</h2><span id='topic+ft_dyns'></span>

<h3>Description</h3>

<p>Apply the Fourier transform over the dynamic dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ft_dyns(mrs_data, ft_shift = FALSE, ret_mod = FALSE, fd = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ft_dyns_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data where the dynamic dimension is in the time-domain.</p>
</td></tr>
<tr><td><code id="ft_dyns_+3A_ft_shift">ft_shift</code></td>
<td>
<p>apply FT shift to the output, default is FALSE.</p>
</td></tr>
<tr><td><code id="ft_dyns_+3A_ret_mod">ret_mod</code></td>
<td>
<p>return the modulus out the transform, default is FALSE.</p>
</td></tr>
<tr><td><code id="ft_dyns_+3A_fd">fd</code></td>
<td>
<p>transform the chemical shift axis to the frequency domain first,
default is TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>transformed MRS data.
</p>

<hr>
<h2 id='ft_shift'>Perform a fft and ffshift on a vector.</h2><span id='topic+ft_shift'></span>

<h3>Description</h3>

<p>Perform a fft and ffshift on a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ft_shift(vec_in)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ft_shift_+3A_vec_in">vec_in</code></td>
<td>
<p>vector input.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>output vector.
</p>

<hr>
<h2 id='ft_shift_mat'>Perform a fft and fftshift on a matrix with each column replaced by its
shifted fft.</h2><span id='topic+ft_shift_mat'></span>

<h3>Description</h3>

<p>Perform a fft and fftshift on a matrix with each column replaced by its
shifted fft.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ft_shift_mat(mat_in)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ft_shift_mat_+3A_mat_in">mat_in</code></td>
<td>
<p>matrix input.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>output matrix.
</p>

<hr>
<h2 id='gausswin_2d'>Create a two dimensional Gaussian window function stored as a matrix.</h2><span id='topic+gausswin_2d'></span>

<h3>Description</h3>

<p>Create a two dimensional Gaussian window function stored as a matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gausswin_2d(xN, yN, x0, y0, xw, yw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gausswin_2d_+3A_xn">xN</code></td>
<td>
<p>number of pixels in the x dimension.</p>
</td></tr>
<tr><td><code id="gausswin_2d_+3A_yn">yN</code></td>
<td>
<p>number of pixels in the y dimension.</p>
</td></tr>
<tr><td><code id="gausswin_2d_+3A_x0">x0</code></td>
<td>
<p>centre of window function in the x direction in units of pixels.
Note, only integer values are applied.</p>
</td></tr>
<tr><td><code id="gausswin_2d_+3A_y0">y0</code></td>
<td>
<p>centre of window function in the y direction in units of pixels.
Note, only integer values are applied.</p>
</td></tr>
<tr><td><code id="gausswin_2d_+3A_xw">xw</code></td>
<td>
<p>the reciprocal of the standard deviation of the Gaussian window in
x direction.</p>
</td></tr>
<tr><td><code id="gausswin_2d_+3A_yw">yw</code></td>
<td>
<p>the reciprocal of the standard deviation of the Gaussian window in
y direction.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix with dimensions fov_yN x fov_xN.
</p>

<hr>
<h2 id='gen_baseline_reg'>Generate baseline regressor.</h2><span id='topic+gen_baseline_reg'></span>

<h3>Description</h3>

<p>Generate baseline regressor.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_baseline_reg(mrs_data = NULL, tr = NULL, Ndyns = NULL, Ntrans = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_baseline_reg_+3A_mrs_data">mrs_data</code></td>
<td>
<p>mrs_data object for timing information.</p>
</td></tr>
<tr><td><code id="gen_baseline_reg_+3A_tr">tr</code></td>
<td>
<p>repetition time.</p>
</td></tr>
<tr><td><code id="gen_baseline_reg_+3A_ndyns">Ndyns</code></td>
<td>
<p>number of dynamic scans stored, potentially less than Ntrans
if block averaging has been performed.</p>
</td></tr>
<tr><td><code id="gen_baseline_reg_+3A_ntrans">Ntrans</code></td>
<td>
<p>number of dynamic scans acquired.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a single baseline regressor with value of 1.
</p>

<hr>
<h2 id='gen_bold_reg'>Generate BOLD regressors.</h2><span id='topic+gen_bold_reg'></span>

<h3>Description</h3>

<p>Generate BOLD regressors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_bold_reg(
  onset,
  duration = NULL,
  trial_type = NULL,
  mrs_data = NULL,
  tr = NULL,
  Ndyns = NULL,
  Ntrans = NULL,
  match_tr = TRUE,
  dt = 0.1,
  normalise = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_bold_reg_+3A_onset">onset</code></td>
<td>
<p>stimulus onset in seconds.</p>
</td></tr>
<tr><td><code id="gen_bold_reg_+3A_duration">duration</code></td>
<td>
<p>stimulus duration in seconds.</p>
</td></tr>
<tr><td><code id="gen_bold_reg_+3A_trial_type">trial_type</code></td>
<td>
<p>string label for the stimulus.</p>
</td></tr>
<tr><td><code id="gen_bold_reg_+3A_mrs_data">mrs_data</code></td>
<td>
<p>mrs_data object for timing information.</p>
</td></tr>
<tr><td><code id="gen_bold_reg_+3A_tr">tr</code></td>
<td>
<p>repetition time.</p>
</td></tr>
<tr><td><code id="gen_bold_reg_+3A_ndyns">Ndyns</code></td>
<td>
<p>number of dynamic scans stored, potentially less than Ntrans
if block averaging has been performed.</p>
</td></tr>
<tr><td><code id="gen_bold_reg_+3A_ntrans">Ntrans</code></td>
<td>
<p>number of dynamic scans acquired.</p>
</td></tr>
<tr><td><code id="gen_bold_reg_+3A_match_tr">match_tr</code></td>
<td>
<p>match the output to the input mrs_data.</p>
</td></tr>
<tr><td><code id="gen_bold_reg_+3A_dt">dt</code></td>
<td>
<p>timing resolution for internal calculations.</p>
</td></tr>
<tr><td><code id="gen_bold_reg_+3A_normalise">normalise</code></td>
<td>
<p>normalise the response function to have a maximum value of
one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>BOLD regressor data frame.
</p>

<hr>
<h2 id='gen_conv_reg'>Generate regressors by convolving a specified response function with a
stimulus.</h2><span id='topic+gen_conv_reg'></span>

<h3>Description</h3>

<p>Generate regressors by convolving a specified response function with a
stimulus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_conv_reg(
  onset,
  duration = NULL,
  trial_type = NULL,
  mrs_data = NULL,
  tr = NULL,
  Ndyns = NULL,
  Ntrans = NULL,
  resp_fn,
  match_tr = TRUE,
  normalise = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_conv_reg_+3A_onset">onset</code></td>
<td>
<p>stimulus onset in seconds.</p>
</td></tr>
<tr><td><code id="gen_conv_reg_+3A_duration">duration</code></td>
<td>
<p>stimulus duration in seconds.</p>
</td></tr>
<tr><td><code id="gen_conv_reg_+3A_trial_type">trial_type</code></td>
<td>
<p>string label for the stimulus.</p>
</td></tr>
<tr><td><code id="gen_conv_reg_+3A_mrs_data">mrs_data</code></td>
<td>
<p>mrs_data object for timing information.</p>
</td></tr>
<tr><td><code id="gen_conv_reg_+3A_tr">tr</code></td>
<td>
<p>repetition time.</p>
</td></tr>
<tr><td><code id="gen_conv_reg_+3A_ndyns">Ndyns</code></td>
<td>
<p>number of dynamic scans stored, potentially less than Ntrans
if block averaging has been performed.</p>
</td></tr>
<tr><td><code id="gen_conv_reg_+3A_ntrans">Ntrans</code></td>
<td>
<p>number of dynamic scans acquired.</p>
</td></tr>
<tr><td><code id="gen_conv_reg_+3A_resp_fn">resp_fn</code></td>
<td>
<p>a data frame specifying the response function to be convolved.</p>
</td></tr>
<tr><td><code id="gen_conv_reg_+3A_match_tr">match_tr</code></td>
<td>
<p>match the output to the input mrs_data.</p>
</td></tr>
<tr><td><code id="gen_conv_reg_+3A_normalise">normalise</code></td>
<td>
<p>normalise the response function to have a maximum value of
one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>BOLD regressor data frame.
</p>

<hr>
<h2 id='gen_F'>Generate the F product operator.</h2><span id='topic+gen_F'></span>

<h3>Description</h3>

<p>Generate the F product operator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_F(sys, op, detect = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_F_+3A_sys">sys</code></td>
<td>
<p>spin system object.</p>
</td></tr>
<tr><td><code id="gen_F_+3A_op">op</code></td>
<td>
<p>operator, one of &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;p&quot;, &quot;m&quot;.</p>
</td></tr>
<tr><td><code id="gen_F_+3A_detect">detect</code></td>
<td>
<p>detection nuclei.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>F product operator matrix.
</p>

<hr>
<h2 id='gen_F_xy'>Generate the Fxy product operator with a specified phase.</h2><span id='topic+gen_F_xy'></span>

<h3>Description</h3>

<p>Generate the Fxy product operator with a specified phase.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_F_xy(sys, phase, detect = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_F_xy_+3A_sys">sys</code></td>
<td>
<p>spin system object.</p>
</td></tr>
<tr><td><code id="gen_F_xy_+3A_phase">phase</code></td>
<td>
<p>phase angle in degrees.</p>
</td></tr>
<tr><td><code id="gen_F_xy_+3A_detect">detect</code></td>
<td>
<p>detection nuclei.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>product operator matrix.
</p>

<hr>
<h2 id='gen_group_reg'>Expand a regressor matrix for a group analysis.</h2><span id='topic+gen_group_reg'></span>

<h3>Description</h3>

<p>Expand a regressor matrix for a group analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_group_reg(regressor_df, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_group_reg_+3A_regressor_df">regressor_df</code></td>
<td>
<p>input regressor data frame.</p>
</td></tr>
<tr><td><code id="gen_group_reg_+3A_n">n</code></td>
<td>
<p>number of datasets n the group.</p>
</td></tr>
</table>

<hr>
<h2 id='gen_I'>Generate the I product operator for a single spin.</h2><span id='topic+gen_I'></span>

<h3>Description</h3>

<p>Generate the I product operator for a single spin.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_I(n, spin_num, op)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_I_+3A_n">n</code></td>
<td>
<p>spin index number for the required operator.</p>
</td></tr>
<tr><td><code id="gen_I_+3A_spin_num">spin_num</code></td>
<td>
<p>vector of spin numbers in the system.</p>
</td></tr>
<tr><td><code id="gen_I_+3A_op">op</code></td>
<td>
<p>operator, one of &quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;p&quot;, &quot;m&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>I product operator matrix.
</p>

<hr>
<h2 id='gen_impulse_reg'>Generate impulse regressors.</h2><span id='topic+gen_impulse_reg'></span>

<h3>Description</h3>

<p>Generate impulse regressors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_impulse_reg(
  onset,
  trial_type = NULL,
  mrs_data = NULL,
  tr = NULL,
  Ndyns = NULL,
  Ntrans = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_impulse_reg_+3A_onset">onset</code></td>
<td>
<p>stimulus onset in seconds.</p>
</td></tr>
<tr><td><code id="gen_impulse_reg_+3A_trial_type">trial_type</code></td>
<td>
<p>string label for the stimulus.</p>
</td></tr>
<tr><td><code id="gen_impulse_reg_+3A_mrs_data">mrs_data</code></td>
<td>
<p>mrs_data object for timing information.</p>
</td></tr>
<tr><td><code id="gen_impulse_reg_+3A_tr">tr</code></td>
<td>
<p>repetition time.</p>
</td></tr>
<tr><td><code id="gen_impulse_reg_+3A_ndyns">Ndyns</code></td>
<td>
<p>number of dynamic scans stored, potentially less than Ntrans
if block averaging has been performed.</p>
</td></tr>
<tr><td><code id="gen_impulse_reg_+3A_ntrans">Ntrans</code></td>
<td>
<p>number of dynamic scans acquired.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>impulse regressors data frame.
</p>

<hr>
<h2 id='gen_poly_reg'>Generate polynomial regressors.</h2><span id='topic+gen_poly_reg'></span>

<h3>Description</h3>

<p>Generate polynomial regressors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_poly_reg(degree, mrs_data = NULL, tr = NULL, Ndyns = NULL, Ntrans = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_poly_reg_+3A_degree">degree</code></td>
<td>
<p>the degree of the polynomial.</p>
</td></tr>
<tr><td><code id="gen_poly_reg_+3A_mrs_data">mrs_data</code></td>
<td>
<p>mrs_data object for timing information.</p>
</td></tr>
<tr><td><code id="gen_poly_reg_+3A_tr">tr</code></td>
<td>
<p>repetition time.</p>
</td></tr>
<tr><td><code id="gen_poly_reg_+3A_ndyns">Ndyns</code></td>
<td>
<p>number of dynamic scans stored, potentially less than Ntrans
if block averaging has been performed.</p>
</td></tr>
<tr><td><code id="gen_poly_reg_+3A_ntrans">Ntrans</code></td>
<td>
<p>number of dynamic scans acquired.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>polynomial regressors.
</p>

<hr>
<h2 id='gen_trap_reg'>Generate trapezoidal regressors.</h2><span id='topic+gen_trap_reg'></span>

<h3>Description</h3>

<p>Generate trapezoidal regressors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_trap_reg(
  onset,
  duration,
  trial_type = NULL,
  mrs_data = NULL,
  tr = NULL,
  Ndyns = NULL,
  Ntrans = NULL,
  rise_t = 0,
  fall_t = 0,
  exp_fall = FALSE,
  exp_fall_power = 1,
  smo_sigma = NULL,
  match_tr = TRUE,
  dt = 0.01,
  normalise = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gen_trap_reg_+3A_onset">onset</code></td>
<td>
<p>stimulus onset in seconds.</p>
</td></tr>
<tr><td><code id="gen_trap_reg_+3A_duration">duration</code></td>
<td>
<p>stimulus duration in seconds.</p>
</td></tr>
<tr><td><code id="gen_trap_reg_+3A_trial_type">trial_type</code></td>
<td>
<p>string label for the stimulus.</p>
</td></tr>
<tr><td><code id="gen_trap_reg_+3A_mrs_data">mrs_data</code></td>
<td>
<p>mrs_data object for timing information.</p>
</td></tr>
<tr><td><code id="gen_trap_reg_+3A_tr">tr</code></td>
<td>
<p>repetition time.</p>
</td></tr>
<tr><td><code id="gen_trap_reg_+3A_ndyns">Ndyns</code></td>
<td>
<p>number of dynamic scans stored, potentially less than Ntrans
if block averaging has been performed.</p>
</td></tr>
<tr><td><code id="gen_trap_reg_+3A_ntrans">Ntrans</code></td>
<td>
<p>number of dynamic scans acquired.</p>
</td></tr>
<tr><td><code id="gen_trap_reg_+3A_rise_t">rise_t</code></td>
<td>
<p>time to reach a plateau from baseline in seconds.</p>
</td></tr>
<tr><td><code id="gen_trap_reg_+3A_fall_t">fall_t</code></td>
<td>
<p>time to fall from plateau level back to baseline in seconds.</p>
</td></tr>
<tr><td><code id="gen_trap_reg_+3A_exp_fall">exp_fall</code></td>
<td>
<p>model an exponential fall instead of linear.</p>
</td></tr>
<tr><td><code id="gen_trap_reg_+3A_exp_fall_power">exp_fall_power</code></td>
<td>
<p>exponential fall power.</p>
</td></tr>
<tr><td><code id="gen_trap_reg_+3A_smo_sigma">smo_sigma</code></td>
<td>
<p>standard deviation of Gaussian smoothing kernel in seconds.
Set to NULL to disable (default behavior).</p>
</td></tr>
<tr><td><code id="gen_trap_reg_+3A_match_tr">match_tr</code></td>
<td>
<p>match the output to the input mrs_data.</p>
</td></tr>
<tr><td><code id="gen_trap_reg_+3A_dt">dt</code></td>
<td>
<p>timing resolution for internal calculations.</p>
</td></tr>
<tr><td><code id="gen_trap_reg_+3A_normalise">normalise</code></td>
<td>
<p>normalise the response function to have a maximum value of
one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>trapezoidal regressor data frame.
</p>

<hr>
<h2 id='get_1h_brain_basis_names'>Return a character vector of common 1H molecules found in healthy human
brain.</h2><span id='topic+get_1h_brain_basis_names'></span>

<h3>Description</h3>

<p>Note, this is a basic set and it may be appropriate to also include Asc,
Gly and PEth for high quality MRS data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_1h_brain_basis_names(add = NULL, remove = NULL, inc_lip_mm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_1h_brain_basis_names_+3A_add">add</code></td>
<td>
<p>optional character vector of additional molecular names. Eg
c(&quot;asc&quot;, &quot;gly&quot;, &quot;peth&quot;).</p>
</td></tr>
<tr><td><code id="get_1h_brain_basis_names_+3A_remove">remove</code></td>
<td>
<p>optional character vector of molecular names to remove from the
set. Eg c(&quot;m_cr_ch2&quot;).</p>
</td></tr>
<tr><td><code id="get_1h_brain_basis_names_+3A_inc_lip_mm">inc_lip_mm</code></td>
<td>
<p>include Lipid and MM basis signals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector of molecule names.
</p>

<hr>
<h2 id='get_1h_brain_basis_paras'>Return a list of <code>mol_parameter</code> objects suitable for 1H brain MRS
analyses.</h2><span id='topic+get_1h_brain_basis_paras'></span>

<h3>Description</h3>

<p>Return a list of <code>mol_parameter</code> objects suitable for 1H brain MRS
analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_1h_brain_basis_paras(ft, metab_lw = NULL, lcm_compat = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_1h_brain_basis_paras_+3A_ft">ft</code></td>
<td>
<p>transmitter frequency in Hz.</p>
</td></tr>
<tr><td><code id="get_1h_brain_basis_paras_+3A_metab_lw">metab_lw</code></td>
<td>
<p>linewidth of metabolite signals (Hz).</p>
</td></tr>
<tr><td><code id="get_1h_brain_basis_paras_+3A_lcm_compat">lcm_compat</code></td>
<td>
<p>when TRUE, lipid, MM and -CrCH molecules will be excluded
from the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of <code>mol_parameter</code> objects.
</p>

<hr>
<h2 id='get_1h_brain_basis_paras_v1'>Return a list of <code>mol_parameter</code> objects suitable for 1H brain MRS
analyses.</h2><span id='topic+get_1h_brain_basis_paras_v1'></span>

<h3>Description</h3>

<p>Return a list of <code>mol_parameter</code> objects suitable for 1H brain MRS
analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_1h_brain_basis_paras_v1(ft, metab_lw = NULL, lcm_compat = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_1h_brain_basis_paras_v1_+3A_ft">ft</code></td>
<td>
<p>transmitter frequency in Hz.</p>
</td></tr>
<tr><td><code id="get_1h_brain_basis_paras_v1_+3A_metab_lw">metab_lw</code></td>
<td>
<p>linewidth of metabolite signals (Hz).</p>
</td></tr>
<tr><td><code id="get_1h_brain_basis_paras_v1_+3A_lcm_compat">lcm_compat</code></td>
<td>
<p>when TRUE, lipid, MM and -CrCH molecules will be excluded
from the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of <code>mol_parameter</code> objects.
</p>

<hr>
<h2 id='get_1h_brain_basis_paras_v2'>Return a list of <code>mol_parameter</code> objects suitable for 1H brain MRS
analyses.</h2><span id='topic+get_1h_brain_basis_paras_v2'></span>

<h3>Description</h3>

<p>Return a list of <code>mol_parameter</code> objects suitable for 1H brain MRS
analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_1h_brain_basis_paras_v2(ft, metab_lw = NULL, lcm_compat = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_1h_brain_basis_paras_v2_+3A_ft">ft</code></td>
<td>
<p>transmitter frequency in Hz.</p>
</td></tr>
<tr><td><code id="get_1h_brain_basis_paras_v2_+3A_metab_lw">metab_lw</code></td>
<td>
<p>linewidth of metabolite signals (Hz).</p>
</td></tr>
<tr><td><code id="get_1h_brain_basis_paras_v2_+3A_lcm_compat">lcm_compat</code></td>
<td>
<p>when TRUE, lipid, MM and -CrCH molecules will be excluded
from the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of <code>mol_parameter</code> objects.
</p>

<hr>
<h2 id='get_1h_brain_basis_paras_v3'>Return a list of <code>mol_parameter</code> objects suitable for 1H brain MRS
analyses.</h2><span id='topic+get_1h_brain_basis_paras_v3'></span>

<h3>Description</h3>

<p>Return a list of <code>mol_parameter</code> objects suitable for 1H brain MRS
analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_1h_brain_basis_paras_v3(ft, metab_lw = NULL, lcm_compat = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_1h_brain_basis_paras_v3_+3A_ft">ft</code></td>
<td>
<p>transmitter frequency in Hz.</p>
</td></tr>
<tr><td><code id="get_1h_brain_basis_paras_v3_+3A_metab_lw">metab_lw</code></td>
<td>
<p>linewidth of metabolite signals (Hz).</p>
</td></tr>
<tr><td><code id="get_1h_brain_basis_paras_v3_+3A_lcm_compat">lcm_compat</code></td>
<td>
<p>when TRUE, lipid, MM and -CrCH molecules will be excluded
from the output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of <code>mol_parameter</code> objects.
</p>

<hr>
<h2 id='get_1h_braino_basis_names'>Return a character vector of molecules included in the GE BRAINO phantom.</h2><span id='topic+get_1h_braino_basis_names'></span>

<h3>Description</h3>

<p>Return a character vector of molecules included in the GE BRAINO phantom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_1h_braino_basis_names()
</code></pre>


<h3>Value</h3>

<p>a character vector of molecule names.
</p>

<hr>
<h2 id='get_1h_spectre_basis_names'>Return a character vector of molecules included in the Gold Star Phantoms
SPECTRE phantom.</h2><span id='topic+get_1h_spectre_basis_names'></span>

<h3>Description</h3>

<p>Return a character vector of molecules included in the Gold Star Phantoms
SPECTRE phantom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_1h_spectre_basis_names()
</code></pre>


<h3>Value</h3>

<p>a character vector of molecule names.
</p>

<hr>
<h2 id='get_2d_psf'>Get the point spread function (PSF) for a 2D phase encoded MRSI scan.</h2><span id='topic+get_2d_psf'></span>

<h3>Description</h3>

<p>Get the point spread function (PSF) for a 2D phase encoded MRSI scan.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_2d_psf(
  FOV = 160,
  mat_size = 16,
  sampling = "circ",
  hamming = FALSE,
  ensure_odd = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_2d_psf_+3A_fov">FOV</code></td>
<td>
<p>field of view in mm.</p>
</td></tr>
<tr><td><code id="get_2d_psf_+3A_mat_size">mat_size</code></td>
<td>
<p>acquisition matrix size (not interpolated).</p>
</td></tr>
<tr><td><code id="get_2d_psf_+3A_sampling">sampling</code></td>
<td>
<p>can be either &quot;circ&quot; for circular or &quot;rect&quot; for rectangular.</p>
</td></tr>
<tr><td><code id="get_2d_psf_+3A_hamming">hamming</code></td>
<td>
<p>should Hamming k-space weighting be applied (default FALSE).</p>
</td></tr>
<tr><td><code id="get_2d_psf_+3A_ensure_odd">ensure_odd</code></td>
<td>
<p>add 1mm to the FOV when required to ensure the output pdf
has odd dimensions. Required when using get_mrsi2d_seg.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of the PSF with 1mm resolution.
</p>

<hr>
<h2 id='get_acq_paras'>Return acquisition parameters from a MRS data object.</h2><span id='topic+get_acq_paras'></span>

<h3>Description</h3>

<p>Return acquisition parameters from a MRS data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_acq_paras(mrs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_acq_paras_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of acquisition parameters.
</p>

<hr>
<h2 id='get_basis_subset'>Return a subset of the input basis.</h2><span id='topic+get_basis_subset'></span>

<h3>Description</h3>

<p>Return a subset of the input basis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_basis_subset(basis, names, invert = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_basis_subset_+3A_basis">basis</code></td>
<td>
<p>input basis.</p>
</td></tr>
<tr><td><code id="get_basis_subset_+3A_names">names</code></td>
<td>
<p>basis set elements to keep in the returned object.</p>
</td></tr>
<tr><td><code id="get_basis_subset_+3A_invert">invert</code></td>
<td>
<p>set to true to return all basis elements except those given in
the names argument.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a subset of the input basis.
</p>

<hr>
<h2 id='get_dyns'>Extract a subset of dynamic scans.</h2><span id='topic+get_dyns'></span>

<h3>Description</h3>

<p>Extract a subset of dynamic scans.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dyns(mrs_data, subset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_dyns_+3A_mrs_data">mrs_data</code></td>
<td>
<p>dynamic MRS data.</p>
</td></tr>
<tr><td><code id="get_dyns_+3A_subset">subset</code></td>
<td>
<p>vector containing indices to the dynamic scans to be
returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>MRS data containing the subset of requested dynamics.
</p>

<hr>
<h2 id='get_even_dyns'>Return even numbered dynamic scans starting from 1 (2,4,6...).</h2><span id='topic+get_even_dyns'></span>

<h3>Description</h3>

<p>Return even numbered dynamic scans starting from 1 (2,4,6...).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_even_dyns(mrs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_even_dyns_+3A_mrs_data">mrs_data</code></td>
<td>
<p>dynamic MRS data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dynamic MRS data containing even numbered scans.
</p>

<hr>
<h2 id='get_fh_dyns'>Return the first half of a dynamic series.</h2><span id='topic+get_fh_dyns'></span>

<h3>Description</h3>

<p>Return the first half of a dynamic series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_fh_dyns(mrs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_fh_dyns_+3A_mrs_data">mrs_data</code></td>
<td>
<p>dynamic MRS data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>first half of the dynamic series.
</p>

<hr>
<h2 id='get_fit_map'>Get a data array from a fit result.</h2><span id='topic+get_fit_map'></span>

<h3>Description</h3>

<p>Get a data array from a fit result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_fit_map(fit_res, name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_fit_map_+3A_fit_res">fit_res</code></td>
<td>
<p><code>fit_result</code> object.</p>
</td></tr>
<tr><td><code id="get_fit_map_+3A_name">name</code></td>
<td>
<p>name of the quantity to plot, eg &quot;tNAA&quot;.</p>
</td></tr>
</table>

<hr>
<h2 id='get_fp'>Return the first time-domain data point.</h2><span id='topic+get_fp'></span>

<h3>Description</h3>

<p>Return the first time-domain data point.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_fp(mrs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_fp_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>first time-domain data point.
</p>

<hr>
<h2 id='get_guassian_pulse'>Generate a gaussian pulse shape.</h2><span id='topic+get_guassian_pulse'></span>

<h3>Description</h3>

<p>Generate a gaussian pulse shape.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_guassian_pulse(angle, n, trunc = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_guassian_pulse_+3A_angle">angle</code></td>
<td>
<p>pulse angle in degrees.</p>
</td></tr>
<tr><td><code id="get_guassian_pulse_+3A_n">n</code></td>
<td>
<p>number of points to generate.</p>
</td></tr>
<tr><td><code id="get_guassian_pulse_+3A_trunc">trunc</code></td>
<td>
<p>percentage truncation factor.</p>
</td></tr>
</table>

<hr>
<h2 id='get_head_dyns'>Return the first scans of a dynamic series.</h2><span id='topic+get_head_dyns'></span>

<h3>Description</h3>

<p>Return the first scans of a dynamic series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_head_dyns(mrs_data, n = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_head_dyns_+3A_mrs_data">mrs_data</code></td>
<td>
<p>dynamic MRS data.</p>
</td></tr>
<tr><td><code id="get_head_dyns_+3A_n">n</code></td>
<td>
<p>the number of dynamic scans to return.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>first scans of a dynamic series.
</p>

<hr>
<h2 id='get_lcm_cmd'>Print the command to run the LCModel command-line program.</h2><span id='topic+get_lcm_cmd'></span>

<h3>Description</h3>

<p>Print the command to run the LCModel command-line program.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_lcm_cmd()
</code></pre>

<hr>
<h2 id='get_metab'>Extract the metabolite component from an mrs_data object.</h2><span id='topic+get_metab'></span>

<h3>Description</h3>

<p>Extract the metabolite component from an mrs_data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_metab(mrs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_metab_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>metabolite component.
</p>

<hr>
<h2 id='get_mol_names'>Return a character array of names that may be used with the
<code>get_mol_paras</code> function.</h2><span id='topic+get_mol_names'></span>

<h3>Description</h3>

<p>Return a character array of names that may be used with the
<code>get_mol_paras</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_mol_names()
</code></pre>


<h3>Value</h3>

<p>a character array of names.
</p>

<hr>
<h2 id='get_mol_paras'>Get a <code>mol_parameters</code> object for a named molecule.</h2><span id='topic+get_mol_paras'></span>

<h3>Description</h3>

<p>Get a <code>mol_parameters</code> object for a named molecule.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_mol_paras(name, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_mol_paras_+3A_name">name</code></td>
<td>
<p>the name of the molecule.</p>
</td></tr>
<tr><td><code id="get_mol_paras_+3A_...">...</code></td>
<td>
<p>arguments to pass to molecule definition function.</p>
</td></tr>
</table>

<hr>
<h2 id='get_mrs_affine'>Generate an affine for nifti generation.</h2><span id='topic+get_mrs_affine'></span>

<h3>Description</h3>

<p>Generate an affine for nifti generation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_mrs_affine(mrs_data, x_pos = 1, y_pos = 1, z_pos = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_mrs_affine_+3A_mrs_data">mrs_data</code></td>
<td>
<p>input data.</p>
</td></tr>
<tr><td><code id="get_mrs_affine_+3A_x_pos">x_pos</code></td>
<td>
<p>x_position coordinate.</p>
</td></tr>
<tr><td><code id="get_mrs_affine_+3A_y_pos">y_pos</code></td>
<td>
<p>y_position coordinate.</p>
</td></tr>
<tr><td><code id="get_mrs_affine_+3A_z_pos">z_pos</code></td>
<td>
<p>z_position coordinate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>affine matrix.
</p>

<hr>
<h2 id='get_mrsi_voi'>Generate a MRSI VOI from an <code>mrs_data</code> object.</h2><span id='topic+get_mrsi_voi'></span>

<h3>Description</h3>

<p>Generate a MRSI VOI from an <code>mrs_data</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_mrsi_voi(mrs_data, target_mri = NULL, map = NULL, ker = mmand::boxKernel())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_mrsi_voi_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
<tr><td><code id="get_mrsi_voi_+3A_target_mri">target_mri</code></td>
<td>
<p>optional image data to match the intended volume space.</p>
</td></tr>
<tr><td><code id="get_mrsi_voi_+3A_map">map</code></td>
<td>
<p>optional voi intensity map.</p>
</td></tr>
<tr><td><code id="get_mrsi_voi_+3A_ker">ker</code></td>
<td>
<p>kernel to rescale the map data to the target_mri. Default value is
mmand::boxKernel(), use mmand::mnKernel() for a smoothed map.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>volume data as a nifti object.
</p>

<hr>
<h2 id='get_mrsi_voxel'>Generate a MRSI voxel from an <code>mrs_data</code> object.</h2><span id='topic+get_mrsi_voxel'></span>

<h3>Description</h3>

<p>Generate a MRSI voxel from an <code>mrs_data</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_mrsi_voxel(mrs_data, target_mri, x_pos, y_pos, z_pos)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_mrsi_voxel_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
<tr><td><code id="get_mrsi_voxel_+3A_target_mri">target_mri</code></td>
<td>
<p>optional image data to match the intended volume space.</p>
</td></tr>
<tr><td><code id="get_mrsi_voxel_+3A_x_pos">x_pos</code></td>
<td>
<p>x voxel coordinate.</p>
</td></tr>
<tr><td><code id="get_mrsi_voxel_+3A_y_pos">y_pos</code></td>
<td>
<p>y voxel coordinate.</p>
</td></tr>
<tr><td><code id="get_mrsi_voxel_+3A_z_pos">z_pos</code></td>
<td>
<p>z voxel coordinate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>volume data as a nifti object.
</p>

<hr>
<h2 id='get_mrsi_voxel_xy_psf'>Generate a MRSI voxel PSF from an <code>mrs_data</code> object.</h2><span id='topic+get_mrsi_voxel_xy_psf'></span>

<h3>Description</h3>

<p>Generate a MRSI voxel PSF from an <code>mrs_data</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_mrsi_voxel_xy_psf(mrs_data, target_mri, x_pos, y_pos, z_pos)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_mrsi_voxel_xy_psf_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
<tr><td><code id="get_mrsi_voxel_xy_psf_+3A_target_mri">target_mri</code></td>
<td>
<p>optional image data to match the intended volume space.</p>
</td></tr>
<tr><td><code id="get_mrsi_voxel_xy_psf_+3A_x_pos">x_pos</code></td>
<td>
<p>x voxel coordinate.</p>
</td></tr>
<tr><td><code id="get_mrsi_voxel_xy_psf_+3A_y_pos">y_pos</code></td>
<td>
<p>y voxel coordinate.</p>
</td></tr>
<tr><td><code id="get_mrsi_voxel_xy_psf_+3A_z_pos">z_pos</code></td>
<td>
<p>z voxel coordinate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>volume data as a nifti object.
</p>

<hr>
<h2 id='get_mrsi2d_seg'>Calculate the partial volume estimates for each voxel in a 2D MRSI dataset.</h2><span id='topic+get_mrsi2d_seg'></span>

<h3>Description</h3>

<p>Localisation is assumed to be perfect in the z direction and determined by
the ker input in the x-y direction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_mrsi2d_seg(mrs_data, mri_seg, ker)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_mrsi2d_seg_+3A_mrs_data">mrs_data</code></td>
<td>
<p>2D MRSI data with multiple voxels in the x-y dimension.</p>
</td></tr>
<tr><td><code id="get_mrsi2d_seg_+3A_mri_seg">mri_seg</code></td>
<td>
<p>MRI data with values corresponding to the segmentation class.
Must be 1mm isotropic resolution.</p>
</td></tr>
<tr><td><code id="get_mrsi2d_seg_+3A_ker">ker</code></td>
<td>
<p>MRSI PSF kernel in the x-y direction compatible with the mmand
package, eg: mmand::shapeKernel(c(10, 10), type = &quot;box&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame of partial volume estimates and individual segmentation
maps.
</p>

<hr>
<h2 id='get_odd_dyns'>Return odd numbered dynamic scans starting from 1 (1,3,5...).</h2><span id='topic+get_odd_dyns'></span>

<h3>Description</h3>

<p>Return odd numbered dynamic scans starting from 1 (1,3,5...).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_odd_dyns(mrs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_odd_dyns_+3A_mrs_data">mrs_data</code></td>
<td>
<p>dynamic MRS data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dynamic MRS data containing odd numbered scans.
</p>

<hr>
<h2 id='get_ref'>Extract the reference component from an mrs_data object.</h2><span id='topic+get_ref'></span>

<h3>Description</h3>

<p>Extract the reference component from an mrs_data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_ref(mrs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_ref_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>reference component.
</p>

<hr>
<h2 id='get_seg_ind'>Get the indices of data points lying between two values (end &gt; x &gt; start).</h2><span id='topic+get_seg_ind'></span>

<h3>Description</h3>

<p>Get the indices of data points lying between two values (end &gt; x &gt; start).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_seg_ind(scale, start, end)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_seg_ind_+3A_scale">scale</code></td>
<td>
<p>full list of values.</p>
</td></tr>
<tr><td><code id="get_seg_ind_+3A_start">start</code></td>
<td>
<p>smallest value in the subset.</p>
</td></tr>
<tr><td><code id="get_seg_ind_+3A_end">end</code></td>
<td>
<p>largest value in the subset.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>set of indices.
</p>

<hr>
<h2 id='get_sh_dyns'>Return the second half of a dynamic series.</h2><span id='topic+get_sh_dyns'></span>

<h3>Description</h3>

<p>Return the second half of a dynamic series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_sh_dyns(mrs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_sh_dyns_+3A_mrs_data">mrs_data</code></td>
<td>
<p>dynamic MRS data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>second half of the dynamic series.
</p>

<hr>
<h2 id='get_slice'>Return a single slice from a larger MRSI dataset.</h2><span id='topic+get_slice'></span>

<h3>Description</h3>

<p>Return a single slice from a larger MRSI dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_slice(mrs_data, z_pos)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_slice_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRSI data.</p>
</td></tr>
<tr><td><code id="get_slice_+3A_z_pos">z_pos</code></td>
<td>
<p>the z index to extract.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>MRS data.
</p>

<hr>
<h2 id='get_spin_num'>Return the spin number for a given nucleus.</h2><span id='topic+get_spin_num'></span>

<h3>Description</h3>

<p>Return the spin number for a given nucleus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_spin_num(nucleus)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_spin_num_+3A_nucleus">nucleus</code></td>
<td>
<p>nucleus name, eg &quot;1H&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>spin number.
</p>

<hr>
<h2 id='get_subset'>Extract a subset of MRS data.</h2><span id='topic+get_subset'></span>

<h3>Description</h3>

<p>Extract a subset of MRS data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_subset(
  mrs_data,
  x_set = NULL,
  y_set = NULL,
  z_set = NULL,
  dyn_set = NULL,
  coil_set = NULL,
  fd_set = NULL,
  td_set = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_subset_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data object.</p>
</td></tr>
<tr><td><code id="get_subset_+3A_x_set">x_set</code></td>
<td>
<p>x indices to include in the output (default all).</p>
</td></tr>
<tr><td><code id="get_subset_+3A_y_set">y_set</code></td>
<td>
<p>y indices to include in the output (default all).</p>
</td></tr>
<tr><td><code id="get_subset_+3A_z_set">z_set</code></td>
<td>
<p>z indices to include in the output (default all).</p>
</td></tr>
<tr><td><code id="get_subset_+3A_dyn_set">dyn_set</code></td>
<td>
<p>dynamic indices to include in the output (default all).</p>
</td></tr>
<tr><td><code id="get_subset_+3A_coil_set">coil_set</code></td>
<td>
<p>coil indices to include in the output (default all).</p>
</td></tr>
<tr><td><code id="get_subset_+3A_fd_set">fd_set</code></td>
<td>
<p>frequency domain data indices to include in the output (default
all).</p>
</td></tr>
<tr><td><code id="get_subset_+3A_td_set">td_set</code></td>
<td>
<p>time-domain indices to include in the output (default all).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>selected subset of MRS data.
</p>

<hr>
<h2 id='get_svs_voi'>Generate a SVS acquisition volume from an <code>mrs_data</code> object.</h2><span id='topic+get_svs_voi'></span>

<h3>Description</h3>

<p>Generate a SVS acquisition volume from an <code>mrs_data</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_svs_voi(mrs_data, target_mri)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_svs_voi_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
<tr><td><code id="get_svs_voi_+3A_target_mri">target_mri</code></td>
<td>
<p>optional image data to match the intended volume space.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>volume data as a nifti object.
</p>

<hr>
<h2 id='get_tail_dyns'>Return the last scans of a dynamic series.</h2><span id='topic+get_tail_dyns'></span>

<h3>Description</h3>

<p>Return the last scans of a dynamic series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_tail_dyns(mrs_data, n = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_tail_dyns_+3A_mrs_data">mrs_data</code></td>
<td>
<p>dynamic MRS data.</p>
</td></tr>
<tr><td><code id="get_tail_dyns_+3A_n">n</code></td>
<td>
<p>the number of dynamic scans to return.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>last scans of a dynamic series.
</p>

<hr>
<h2 id='get_td_amp'>Return an array of amplitudes derived from fitting the initial points in the
time domain and extrapolating back to t=0.</h2><span id='topic+get_td_amp'></span>

<h3>Description</h3>

<p>Return an array of amplitudes derived from fitting the initial points in the
time domain and extrapolating back to t=0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_td_amp(mrs_data, nstart = 10, nend = 50, method = "poly")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_td_amp_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
<tr><td><code id="get_td_amp_+3A_nstart">nstart</code></td>
<td>
<p>first data point to fit.</p>
</td></tr>
<tr><td><code id="get_td_amp_+3A_nend">nend</code></td>
<td>
<p>last data point to fit.</p>
</td></tr>
<tr><td><code id="get_td_amp_+3A_method">method</code></td>
<td>
<p>method for measuring the amplitude, one of &quot;poly&quot;, spline&quot; or
exp&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array of amplitudes.
</p>

<hr>
<h2 id='get_tqn_cmd'>Print the command to run the TARQUIN command-line program.</h2><span id='topic+get_tqn_cmd'></span>

<h3>Description</h3>

<p>Print the command to run the TARQUIN command-line program.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_tqn_cmd()
</code></pre>

<hr>
<h2 id='get_uncoupled_mol'>Generate a <code>mol_parameters</code> object for a simple spin system with one
resonance.</h2><span id='topic+get_uncoupled_mol'></span>

<h3>Description</h3>

<p>Generate a <code>mol_parameters</code> object for a simple spin system with one
resonance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_uncoupled_mol(
  name,
  chem_shift,
  nucleus,
  scale_factor,
  lw,
  lg,
  full_name = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_uncoupled_mol_+3A_name">name</code></td>
<td>
<p>abbreviated name of the molecule.</p>
</td></tr>
<tr><td><code id="get_uncoupled_mol_+3A_chem_shift">chem_shift</code></td>
<td>
<p>chemical shift of the resonance (PPM).</p>
</td></tr>
<tr><td><code id="get_uncoupled_mol_+3A_nucleus">nucleus</code></td>
<td>
<p>nucleus (1H, 31P...).</p>
</td></tr>
<tr><td><code id="get_uncoupled_mol_+3A_scale_factor">scale_factor</code></td>
<td>
<p>multiplicative scaling factor. Note, this value can be
made complex to adjust the phase of the resonance.</p>
</td></tr>
<tr><td><code id="get_uncoupled_mol_+3A_lw">lw</code></td>
<td>
<p>linewidth in Hz.</p>
</td></tr>
<tr><td><code id="get_uncoupled_mol_+3A_lg">lg</code></td>
<td>
<p>Lorentz-Gauss lineshape parameter (between 0 and 1).</p>
</td></tr>
<tr><td><code id="get_uncoupled_mol_+3A_full_name">full_name</code></td>
<td>
<p>long name of the molecule (optional).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mol_parameters object.
</p>

<hr>
<h2 id='get_voi_cog'>Calculate the centre of gravity for an image containing 0 and 1's.</h2><span id='topic+get_voi_cog'></span>

<h3>Description</h3>

<p>Calculate the centre of gravity for an image containing 0 and 1's.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_voi_cog(voi)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_voi_cog_+3A_voi">voi</code></td>
<td>
<p>nifti object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>triplet of x,y,z coordinates.
</p>

<hr>
<h2 id='get_voi_seg'>Return the white matter, gray matter and CSF composition of a volume.</h2><span id='topic+get_voi_seg'></span>

<h3>Description</h3>

<p>Return the white matter, gray matter and CSF composition of a volume.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_voi_seg(voi, mri_seg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_voi_seg_+3A_voi">voi</code></td>
<td>
<p>volume data as a nifti object.</p>
</td></tr>
<tr><td><code id="get_voi_seg_+3A_mri_seg">mri_seg</code></td>
<td>
<p>segmented brain volume as a nifti object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of partial volumes expressed as percentages.
</p>

<hr>
<h2 id='get_voi_seg_psf'>Return the white matter, gray matter and CSF composition of a volume.</h2><span id='topic+get_voi_seg_psf'></span>

<h3>Description</h3>

<p>Return the white matter, gray matter and CSF composition of a volume.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_voi_seg_psf(psf, mri_seg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_voi_seg_psf_+3A_psf">psf</code></td>
<td>
<p>volume data as a nifti object.</p>
</td></tr>
<tr><td><code id="get_voi_seg_psf_+3A_mri_seg">mri_seg</code></td>
<td>
<p>segmented brain volume as a nifti object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of partial volumes expressed as percentages.
</p>

<hr>
<h2 id='get_voxel'>Return a single voxel from a larger mrs dataset.</h2><span id='topic+get_voxel'></span>

<h3>Description</h3>

<p>Return a single voxel from a larger mrs dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_voxel(mrs_data, x_pos = 1, y_pos = 1, z_pos = 1, dyn = 1, coil = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_voxel_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
<tr><td><code id="get_voxel_+3A_x_pos">x_pos</code></td>
<td>
<p>the x index to plot.</p>
</td></tr>
<tr><td><code id="get_voxel_+3A_y_pos">y_pos</code></td>
<td>
<p>the y index to plot.</p>
</td></tr>
<tr><td><code id="get_voxel_+3A_z_pos">z_pos</code></td>
<td>
<p>the z index to plot.</p>
</td></tr>
<tr><td><code id="get_voxel_+3A_dyn">dyn</code></td>
<td>
<p>the dynamic index to plot.</p>
</td></tr>
<tr><td><code id="get_voxel_+3A_coil">coil</code></td>
<td>
<p>the coil element number to plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>MRS data.
</p>

<hr>
<h2 id='glm_spec'>Perform a GLM analysis of dynamic MRS data in the spectral domain.</h2><span id='topic+glm_spec'></span>

<h3>Description</h3>

<p>Perform a GLM analysis of dynamic MRS data in the spectral domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm_spec(mrs_data, regressor_df, full_output = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glm_spec_+3A_mrs_data">mrs_data</code></td>
<td>
<p>single-voxel dynamics MRS data.</p>
</td></tr>
<tr><td><code id="glm_spec_+3A_regressor_df">regressor_df</code></td>
<td>
<p>a data frame containing temporal regressors to be applied
to each spectral datapoint.</p>
</td></tr>
<tr><td><code id="glm_spec_+3A_full_output">full_output</code></td>
<td>
<p>append mrs_data and regressor_df to the output list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of statistical results.
</p>

<hr>
<h2 id='glm_spec_fmrs_fl'>Perform first-level spectral GLM analysis of an fMRS dataset.</h2><span id='topic+glm_spec_fmrs_fl'></span>

<h3>Description</h3>

<p>Perform first-level spectral GLM analysis of an fMRS dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm_spec_fmrs_fl(
  regressor_df,
  analysis_dir = "spant_analysis",
  exclude_labels = NULL,
  labels = NULL,
  xlim = c(4, 0.2),
  vline = c(1.35, 1.28, 2.35, 2.29),
  return_results = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glm_spec_fmrs_fl_+3A_regressor_df">regressor_df</code></td>
<td>
<p>a data frame containing temporal regressors to be applied
to each spectral datapoint.</p>
</td></tr>
<tr><td><code id="glm_spec_fmrs_fl_+3A_analysis_dir">analysis_dir</code></td>
<td>
<p>directory containing preprocessed data generated by
the preproc_svs_dataset function.</p>
</td></tr>
<tr><td><code id="glm_spec_fmrs_fl_+3A_exclude_labels">exclude_labels</code></td>
<td>
<p>vector of labels of scans to exclude, eg poor quality
data.</p>
</td></tr>
<tr><td><code id="glm_spec_fmrs_fl_+3A_labels">labels</code></td>
<td>
<p>labels to describe each data set.</p>
</td></tr>
<tr><td><code id="glm_spec_fmrs_fl_+3A_xlim">xlim</code></td>
<td>
<p>spectral range to include in the analysis.</p>
</td></tr>
<tr><td><code id="glm_spec_fmrs_fl_+3A_vline">vline</code></td>
<td>
<p>vertical lines to add to the plot.</p>
</td></tr>
<tr><td><code id="glm_spec_fmrs_fl_+3A_return_results">return_results</code></td>
<td>
<p>function will return key outputs, defaults to FALSE.</p>
</td></tr>
</table>

<hr>
<h2 id='glm_spec_fmrs_group'>Perform group-level spectral GLM analysis of an fMRS dataset.</h2><span id='topic+glm_spec_fmrs_group'></span>

<h3>Description</h3>

<p>Perform group-level spectral GLM analysis of an fMRS dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm_spec_fmrs_group(
  regressor_df,
  analysis_dir = "spant_analysis",
  exclude_labels = NULL,
  labels = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glm_spec_fmrs_group_+3A_regressor_df">regressor_df</code></td>
<td>
<p>a data frame containing temporal regressors to be applied
to each spectral datapoint.</p>
</td></tr>
<tr><td><code id="glm_spec_fmrs_group_+3A_analysis_dir">analysis_dir</code></td>
<td>
<p>directory containing preprocessed data generated by
the preproc_svs_dataset function.</p>
</td></tr>
<tr><td><code id="glm_spec_fmrs_group_+3A_exclude_labels">exclude_labels</code></td>
<td>
<p>vector of labels of scans to exclude, eg poor quality
data.</p>
</td></tr>
<tr><td><code id="glm_spec_fmrs_group_+3A_labels">labels</code></td>
<td>
<p>labels to describe each data set.</p>
</td></tr>
</table>

<hr>
<h2 id='glm_spec_group_linhyp'>Test a group-level spectral GLM linear hypothesis.</h2><span id='topic+glm_spec_group_linhyp'></span>

<h3>Description</h3>

<p>Test a group-level spectral GLM linear hypothesis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>glm_spec_group_linhyp(hmat, analysis_dir = "spant_analysis")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="glm_spec_group_linhyp_+3A_hmat">hmat</code></td>
<td>
<p>linear hypothesis matrix.</p>
</td></tr>
<tr><td><code id="glm_spec_group_linhyp_+3A_analysis_dir">analysis_dir</code></td>
<td>
<p>directory containing preprocessed data generated by
the preproc_svs_dataset function.</p>
</td></tr>
</table>

<hr>
<h2 id='grid_shift_xy'>Grid shift MRSI data in the x/y dimension.</h2><span id='topic+grid_shift_xy'></span>

<h3>Description</h3>

<p>Grid shift MRSI data in the x/y dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>grid_shift_xy(mrs_data, x_shift, y_shift)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="grid_shift_xy_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRSI data in the spatial domain.</p>
</td></tr>
<tr><td><code id="grid_shift_xy_+3A_x_shift">x_shift</code></td>
<td>
<p>shift to apply in the x-direction in units of voxels.</p>
</td></tr>
<tr><td><code id="grid_shift_xy_+3A_y_shift">y_shift</code></td>
<td>
<p>shift to apply in the y-direction in units of voxels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>shifted data.
</p>

<hr>
<h2 id='gridplot'>Arrange spectral plots in a grid.</h2><span id='topic+gridplot'></span>

<h3>Description</h3>

<p>Arrange spectral plots in a grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gridplot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gridplot_+3A_x">x</code></td>
<td>
<p>object for plotting.</p>
</td></tr>
<tr><td><code id="gridplot_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods.</p>
</td></tr>
</table>

<hr>
<h2 id='gridplot.mrs_data'>Arrange spectral plots in a grid.</h2><span id='topic+gridplot.mrs_data'></span>

<h3>Description</h3>

<p>Arrange spectral plots in a grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mrs_data'
gridplot(
  x,
  rows = NA,
  cols = NA,
  mar = c(0, 0, 0, 0),
  oma = c(3.5, 1, 1, 1),
  bty = "o",
  restore_def_par = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gridplot.mrs_data_+3A_x">x</code></td>
<td>
<p>object of class mrs_data.</p>
</td></tr>
<tr><td><code id="gridplot.mrs_data_+3A_rows">rows</code></td>
<td>
<p>number of grid rows.</p>
</td></tr>
<tr><td><code id="gridplot.mrs_data_+3A_cols">cols</code></td>
<td>
<p>number of grid columns.</p>
</td></tr>
<tr><td><code id="gridplot.mrs_data_+3A_mar">mar</code></td>
<td>
<p>option to adjust the plot margins. See ?par.</p>
</td></tr>
<tr><td><code id="gridplot.mrs_data_+3A_oma">oma</code></td>
<td>
<p>outer margin area.</p>
</td></tr>
<tr><td><code id="gridplot.mrs_data_+3A_bty">bty</code></td>
<td>
<p>option to draw a box around the plot. See ?par.</p>
</td></tr>
<tr><td><code id="gridplot.mrs_data_+3A_restore_def_par">restore_def_par</code></td>
<td>
<p>restore default plotting par values after the plot has
been made.</p>
</td></tr>
<tr><td><code id="gridplot.mrs_data_+3A_...">...</code></td>
<td>
<p>other arguments to pass to the plot method.</p>
</td></tr>
</table>

<hr>
<h2 id='hsvd'>HSVD of an mrs_data object.</h2><span id='topic+hsvd'></span>

<h3>Description</h3>

<p>HSVD method as described in:
Barkhuijsen H, de Beer R, van Ormondt D. Improved algorithm for noniterative
and timedomain model fitting to exponentially damped magnetic resonance
signals. J Magn Reson 1987;73:553-557.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hsvd(mrs_data, comps = 40, irlba = TRUE, max_damp = 10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hsvd_+3A_mrs_data">mrs_data</code></td>
<td>
<p>mrs_data object to be decomposed.</p>
</td></tr>
<tr><td><code id="hsvd_+3A_comps">comps</code></td>
<td>
<p>number of Lorentzian components to use for modelling.</p>
</td></tr>
<tr><td><code id="hsvd_+3A_irlba">irlba</code></td>
<td>
<p>option to use irlba SVD (logical).</p>
</td></tr>
<tr><td><code id="hsvd_+3A_max_damp">max_damp</code></td>
<td>
<p>maximum allowable damping factor.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>basis matrix and signal table.
</p>

<hr>
<h2 id='hsvd_filt'>HSVD based signal filter.</h2><span id='topic+hsvd_filt'></span>

<h3>Description</h3>

<p>HSVD based signal filter described in:
Barkhuijsen H, de Beer R, van Ormondt D. Improved algorithm for noniterative
and timedomain model fitting to exponentially damped magnetic resonance
signals. J Magn Reson 1987;73:553-557.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hsvd_filt(
  mrs_data,
  xlim = c(-30, 30),
  comps = 40,
  irlba = TRUE,
  max_damp = 10,
  scale = "hz",
  return_model = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hsvd_filt_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data to be filtered.</p>
</td></tr>
<tr><td><code id="hsvd_filt_+3A_xlim">xlim</code></td>
<td>
<p>frequency range to filter, default units are Hz which can be
changed to ppm using the &quot;scale&quot; argument.</p>
</td></tr>
<tr><td><code id="hsvd_filt_+3A_comps">comps</code></td>
<td>
<p>number of Lorentzian components to use for modelling.</p>
</td></tr>
<tr><td><code id="hsvd_filt_+3A_irlba">irlba</code></td>
<td>
<p>option to use irlba SVD (logical).</p>
</td></tr>
<tr><td><code id="hsvd_filt_+3A_max_damp">max_damp</code></td>
<td>
<p>maximum allowable damping factor.</p>
</td></tr>
<tr><td><code id="hsvd_filt_+3A_scale">scale</code></td>
<td>
<p>either &quot;hz&quot; or &quot;ppm&quot; to set the frequency units of xlim.</p>
</td></tr>
<tr><td><code id="hsvd_filt_+3A_return_model">return_model</code></td>
<td>
<p>by default the filtered spectrum is returned. Set
return_model to TRUE to return the HSVD model of the data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>filtered data or model depending on the return_model argument.
</p>

<hr>
<h2 id='hsvd_vec'>HSVD of a complex vector.</h2><span id='topic+hsvd_vec'></span>

<h3>Description</h3>

<p>HSVD method as described in:
Barkhuijsen H, de Beer R, van Ormondt D. Improved algorithm for noniterative
and timedomain model fitting to exponentially damped magnetic resonance
signals. J Magn Reson 1987;73:553-557.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hsvd_vec(y, fs, comps = 40, irlba = TRUE, max_damp = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hsvd_vec_+3A_y">y</code></td>
<td>
<p>time domain signal to be filtered as a vector.</p>
</td></tr>
<tr><td><code id="hsvd_vec_+3A_fs">fs</code></td>
<td>
<p>sampling frequency of y.</p>
</td></tr>
<tr><td><code id="hsvd_vec_+3A_comps">comps</code></td>
<td>
<p>number of Lorentzian components to use for modelling.</p>
</td></tr>
<tr><td><code id="hsvd_vec_+3A_irlba">irlba</code></td>
<td>
<p>option to use irlba SVD (logical).</p>
</td></tr>
<tr><td><code id="hsvd_vec_+3A_max_damp">max_damp</code></td>
<td>
<p>maximum allowable damping factor. Default value of 0 ensures
resultant model is damped.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>basis matrix and signal table.
</p>

<hr>
<h2 id='hz'>Return the frequency scale of an MRS dataset in Hz.</h2><span id='topic+hz'></span>

<h3>Description</h3>

<p>Return the frequency scale of an MRS dataset in Hz.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hz(mrs_data, fs = NULL, N = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hz_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
<tr><td><code id="hz_+3A_fs">fs</code></td>
<td>
<p>sampling frequency in Hz.</p>
</td></tr>
<tr><td><code id="hz_+3A_n">N</code></td>
<td>
<p>number of data points in the spectral dimension.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>frequency scale.
</p>

<hr>
<h2 id='ift_shift'>Perform an iffshift and ifft on a vector.</h2><span id='topic+ift_shift'></span>

<h3>Description</h3>

<p>Perform an iffshift and ifft on a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ift_shift(vec_in)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ift_shift_+3A_vec_in">vec_in</code></td>
<td>
<p>vector input.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>output vector.
</p>

<hr>
<h2 id='ift_shift_mat'>Perform an ifft and ifftshift on a matrix with each column replaced by its
shifted ifft.</h2><span id='topic+ift_shift_mat'></span>

<h3>Description</h3>

<p>Perform an ifft and ifftshift on a matrix with each column replaced by its
shifted ifft.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ift_shift_mat(mat_in)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ift_shift_mat_+3A_mat_in">mat_in</code></td>
<td>
<p>matrix input.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>output matrix.
</p>

<hr>
<h2 id='Im.mrs_data'>Apply Im operator to an MRS dataset.</h2><span id='topic+Im.mrs_data'></span>

<h3>Description</h3>

<p>Apply Im operator to an MRS dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mrs_data'
Im(z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Im.mrs_data_+3A_z">z</code></td>
<td>
<p>MRS data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>MRS data following Im operator.
</p>

<hr>
<h2 id='image.mrs_data'>Image plot method for objects of class mrs_data.</h2><span id='topic+image.mrs_data'></span>

<h3>Description</h3>

<p>Image plot method for objects of class mrs_data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mrs_data'
image(
  x,
  xlim = NULL,
  mode = "re",
  col = NULL,
  plot_dim = NULL,
  x_pos = NULL,
  y_pos = NULL,
  z_pos = NULL,
  dyn = 1,
  coil = 1,
  restore_def_par = TRUE,
  y_ticks = NULL,
  hline = NULL,
  hline_lty = 2,
  hline_col = "white",
  vline = NULL,
  vline_lty = 2,
  vline_col = "white",
  legend = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="image.mrs_data_+3A_x">x</code></td>
<td>
<p>object of class mrs_data.</p>
</td></tr>
<tr><td><code id="image.mrs_data_+3A_xlim">xlim</code></td>
<td>
<p>the range of values to display on the x-axis, eg xlim = c(4,1).</p>
</td></tr>
<tr><td><code id="image.mrs_data_+3A_mode">mode</code></td>
<td>
<p>representation of the complex numbers to be plotted, can be one
of: &quot;re&quot;, &quot;im&quot;, &quot;mod&quot; or &quot;arg&quot;.</p>
</td></tr>
<tr><td><code id="image.mrs_data_+3A_col">col</code></td>
<td>
<p>Colour map to use, defaults to viridis.</p>
</td></tr>
<tr><td><code id="image.mrs_data_+3A_plot_dim">plot_dim</code></td>
<td>
<p>the dimension to display on the y-axis, can be one of: &quot;dyn&quot;,
&quot;time_sec&quot;, x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;coil&quot; or NULL. If NULL (the default) all spectra
are collapsed into the dynamic dimension and displayed.</p>
</td></tr>
<tr><td><code id="image.mrs_data_+3A_x_pos">x_pos</code></td>
<td>
<p>the x index to plot.</p>
</td></tr>
<tr><td><code id="image.mrs_data_+3A_y_pos">y_pos</code></td>
<td>
<p>the y index to plot.</p>
</td></tr>
<tr><td><code id="image.mrs_data_+3A_z_pos">z_pos</code></td>
<td>
<p>the z index to plot.</p>
</td></tr>
<tr><td><code id="image.mrs_data_+3A_dyn">dyn</code></td>
<td>
<p>the dynamic index to plot.</p>
</td></tr>
<tr><td><code id="image.mrs_data_+3A_coil">coil</code></td>
<td>
<p>the coil element number to plot.</p>
</td></tr>
<tr><td><code id="image.mrs_data_+3A_restore_def_par">restore_def_par</code></td>
<td>
<p>restore default plotting par values after the plot has
been made.</p>
</td></tr>
<tr><td><code id="image.mrs_data_+3A_y_ticks">y_ticks</code></td>
<td>
<p>a vector of indices specifying where to place additional red
tick marks.</p>
</td></tr>
<tr><td><code id="image.mrs_data_+3A_hline">hline</code></td>
<td>
<p>add a horizontal line at the specified value.</p>
</td></tr>
<tr><td><code id="image.mrs_data_+3A_hline_lty">hline_lty</code></td>
<td>
<p>linetype for the horizontal line.</p>
</td></tr>
<tr><td><code id="image.mrs_data_+3A_hline_col">hline_col</code></td>
<td>
<p>colour for the horizontal line.</p>
</td></tr>
<tr><td><code id="image.mrs_data_+3A_vline">vline</code></td>
<td>
<p>add a vertical line at the specified value.</p>
</td></tr>
<tr><td><code id="image.mrs_data_+3A_vline_lty">vline_lty</code></td>
<td>
<p>linetype for the vertical line.</p>
</td></tr>
<tr><td><code id="image.mrs_data_+3A_vline_col">vline_col</code></td>
<td>
<p>colour for the vertical line.</p>
</td></tr>
<tr><td><code id="image.mrs_data_+3A_legend">legend</code></td>
<td>
<p>add a colour bar to the plot using the imagePlot function
from the fields package.</p>
</td></tr>
<tr><td><code id="image.mrs_data_+3A_...">...</code></td>
<td>
<p>other arguments to pass to the plot method.</p>
</td></tr>
</table>

<hr>
<h2 id='img2kspace_xy'>Transform 2D MRSI data to k-space in the x-y direction.</h2><span id='topic+img2kspace_xy'></span>

<h3>Description</h3>

<p>Transform 2D MRSI data to k-space in the x-y direction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>img2kspace_xy(mrs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="img2kspace_xy_+3A_mrs_data">mrs_data</code></td>
<td>
<p>2D MRSI data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>k-space data.
</p>

<hr>
<h2 id='Imzap'>Complex rounding function taken from complexplus package to reduce the number
of spant dependencies.</h2><span id='topic+Imzap'></span>

<h3>Description</h3>

<p>Complex rounding function taken from complexplus package to reduce the number
of spant dependencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Imzap(x, tol = 1e-06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Imzap_+3A_x">x</code></td>
<td>
<p>a scalar or vector, real or complex.</p>
</td></tr>
<tr><td><code id="Imzap_+3A_tol">tol</code></td>
<td>
<p>a tolerance, 10^-6 by default. Prevents possible numerical
problems. Can be set to 0 if desired.</p>
</td></tr>
</table>

<hr>
<h2 id='int_spec'>Integrate a spectral region.</h2><span id='topic+int_spec'></span>

<h3>Description</h3>

<p>See spec_op function for a more complete set of spectral operations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>int_spec(mrs_data, xlim = NULL, freq_scale = "ppm", mode = "re")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="int_spec_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
<tr><td><code id="int_spec_+3A_xlim">xlim</code></td>
<td>
<p>spectral range to be integrated (defaults to full range).</p>
</td></tr>
<tr><td><code id="int_spec_+3A_freq_scale">freq_scale</code></td>
<td>
<p>units of xlim, can be : &quot;ppm&quot;, &quot;hz&quot; or &quot;points&quot;.</p>
</td></tr>
<tr><td><code id="int_spec_+3A_mode">mode</code></td>
<td>
<p>spectral mode, can be : &quot;re&quot;, &quot;im&quot;, &quot;mod&quot; or &quot;cplx&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an array of integral values.
</p>

<hr>
<h2 id='interleave_dyns'>Interleave the first and second half of a dynamic series.</h2><span id='topic+interleave_dyns'></span>

<h3>Description</h3>

<p>Interleave the first and second half of a dynamic series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>interleave_dyns(mrs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="interleave_dyns_+3A_mrs_data">mrs_data</code></td>
<td>
<p>dynamic MRS data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>interleaved data.
</p>

<hr>
<h2 id='inv_even_dyns'>Invert even numbered dynamic scans starting from 1 (2,4,6...).</h2><span id='topic+inv_even_dyns'></span>

<h3>Description</h3>

<p>Invert even numbered dynamic scans starting from 1 (2,4,6...).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inv_even_dyns(mrs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inv_even_dyns_+3A_mrs_data">mrs_data</code></td>
<td>
<p>dynamic MRS data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dynamic MRS data with inverted even numbered scans.
</p>

<hr>
<h2 id='inv_odd_dyns'>Invert odd numbered dynamic scans starting from 1 (1,3,5...).</h2><span id='topic+inv_odd_dyns'></span>

<h3>Description</h3>

<p>Invert odd numbered dynamic scans starting from 1 (1,3,5...).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inv_odd_dyns(mrs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inv_odd_dyns_+3A_mrs_data">mrs_data</code></td>
<td>
<p>dynamic MRS data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dynamic MRS data with inverted odd numbered scans.
</p>

<hr>
<h2 id='is_fd'>Check if the chemical shift dimension of an MRS data object is in the
frequency domain.</h2><span id='topic+is_fd'></span>

<h3>Description</h3>

<p>Check if the chemical shift dimension of an MRS data object is in the
frequency domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_fd(mrs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_fd_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical value.
</p>

<hr>
<h2 id='is.def'>Check if an object is defined, which is the same as being not NULL.</h2><span id='topic+is.def'></span>

<h3>Description</h3>

<p>Check if an object is defined, which is the same as being not NULL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.def(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.def_+3A_x">x</code></td>
<td>
<p>object to test for being NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical value.
</p>

<hr>
<h2 id='kspace2img_xy'>Transform 2D MRSI data from k-space to image space in the x-y direction.</h2><span id='topic+kspace2img_xy'></span>

<h3>Description</h3>

<p>Transform 2D MRSI data from k-space to image space in the x-y direction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kspace2img_xy(mrs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kspace2img_xy_+3A_mrs_data">mrs_data</code></td>
<td>
<p>2D MRSI data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>MRSI data in image space.
</p>

<hr>
<h2 id='l2_reg'>Perform l2 regularisation artefact suppression.</h2><span id='topic+l2_reg'></span>

<h3>Description</h3>

<p>Perform l2 regularisation artefact suppression using the method proposed by
Bilgic et al. JMRI 40(1):181-91 2014.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>l2_reg(
  mrs_data,
  thresh = 0.05,
  b = 1e-11,
  A = NA,
  xlim = NA,
  thresh_xlim = NULL,
  A_append = NULL,
  ret_norms = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="l2_reg_+3A_mrs_data">mrs_data</code></td>
<td>
<p>input data for artefact suppression.</p>
</td></tr>
<tr><td><code id="l2_reg_+3A_thresh">thresh</code></td>
<td>
<p>threshold parameter to extract lipid signals from mrs_data
based on the spectral integration of the thresh_xlim region in magnitude
mode.</p>
</td></tr>
<tr><td><code id="l2_reg_+3A_b">b</code></td>
<td>
<p>regularisation parameter.</p>
</td></tr>
<tr><td><code id="l2_reg_+3A_a">A</code></td>
<td>
<p>set of spectra containing the artefact basis signals. The thresh
parameter is ignored when A is specified.</p>
</td></tr>
<tr><td><code id="l2_reg_+3A_xlim">xlim</code></td>
<td>
<p>spectral limits in ppm to restrict the reconstruction range.
Defaults to the full spectral width.</p>
</td></tr>
<tr><td><code id="l2_reg_+3A_thresh_xlim">thresh_xlim</code></td>
<td>
<p>spectral limits in ppm to integrate for the threshold map.</p>
</td></tr>
<tr><td><code id="l2_reg_+3A_a_append">A_append</code></td>
<td>
<p>additional spectra to append to the A basis.</p>
</td></tr>
<tr><td><code id="l2_reg_+3A_ret_norms">ret_norms</code></td>
<td>
<p>return the residual norm and solution norms.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>l2 reconstructed mrs_data object.
</p>

<hr>
<h2 id='lb'>Apply line-broadening (apodisation) to MRS data or basis object.</h2><span id='topic+lb'></span><span id='topic+lb.list'></span><span id='topic+lb.mrs_data'></span><span id='topic+lb.basis_set'></span>

<h3>Description</h3>

<p>Apply line-broadening (apodisation) to MRS data or basis object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lb(x, lb, lg = 1)

## S3 method for class 'list'
lb(x, lb, lg = 1)

## S3 method for class 'mrs_data'
lb(x, lb, lg = 1)

## S3 method for class 'basis_set'
lb(x, lb, lg = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lb_+3A_x">x</code></td>
<td>
<p>input mrs_data or basis_set object.</p>
</td></tr>
<tr><td><code id="lb_+3A_lb">lb</code></td>
<td>
<p>amount of line-broadening in Hz.</p>
</td></tr>
<tr><td><code id="lb_+3A_lg">lg</code></td>
<td>
<p>Lorentz-Gauss lineshape parameter (between 0 and 1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>line-broadened data.
</p>

<hr>
<h2 id='lofdc'>Correct linear frequency drift.</h2><span id='topic+lofdc'></span>

<h3>Description</h3>

<p>Correct linear frequency drift.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lofdc(
  mrs_data,
  max_hz_s = 0.1,
  tr = NULL,
  ret_corr_only = TRUE,
  outlier_thresh = 3,
  xlim = c(4, 0.5),
  order = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lofdc_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data to be corrected.</p>
</td></tr>
<tr><td><code id="lofdc_+3A_max_hz_s">max_hz_s</code></td>
<td>
<p>the maximum drift rate to search over.</p>
</td></tr>
<tr><td><code id="lofdc_+3A_tr">tr</code></td>
<td>
<p>mrs_data repetition time.</p>
</td></tr>
<tr><td><code id="lofdc_+3A_ret_corr_only">ret_corr_only</code></td>
<td>
<p>return the corrected mrs_data object only.</p>
</td></tr>
<tr><td><code id="lofdc_+3A_outlier_thresh">outlier_thresh</code></td>
<td>
<p>threshold to remove outliers.</p>
</td></tr>
<tr><td><code id="lofdc_+3A_xlim">xlim</code></td>
<td>
<p>spectral width (in ppm) to evaluate outliers.</p>
</td></tr>
<tr><td><code id="lofdc_+3A_order">order</code></td>
<td>
<p>correction order.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>drift corrected mrs_data object.
</p>

<hr>
<h2 id='lw2alpha'>Covert a linewidth in Hz to an equivalent alpha value in the time-domain ie:
x * exp(-t * alpha).</h2><span id='topic+lw2alpha'></span>

<h3>Description</h3>

<p>Covert a linewidth in Hz to an equivalent alpha value in the time-domain ie:
x * exp(-t * alpha).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lw2alpha(lw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lw2alpha_+3A_lw">lw</code></td>
<td>
<p>linewidth in Hz.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>beta damping value.
</p>

<hr>
<h2 id='lw2beta'>Covert a linewidth in Hz to an equivalent beta value in the time-domain ie:
x * exp(-t * t * beta).</h2><span id='topic+lw2beta'></span>

<h3>Description</h3>

<p>Covert a linewidth in Hz to an equivalent beta value in the time-domain ie:
x * exp(-t * t * beta).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lw2beta(lw)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lw2beta_+3A_lw">lw</code></td>
<td>
<p>linewidth in Hz.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>beta damping value.
</p>

<hr>
<h2 id='make_basis_from_raw'>Make a basis-set object from a directory containing LCModel formatted RAW
files.</h2><span id='topic+make_basis_from_raw'></span>

<h3>Description</h3>

<p>Make a basis-set object from a directory containing LCModel formatted RAW
files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_basis_from_raw(dir_path, ft, fs, ref)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_basis_from_raw_+3A_dir_path">dir_path</code></td>
<td>
<p>path to the directory containing LCModel RAW files. One file
per signal.</p>
</td></tr>
<tr><td><code id="make_basis_from_raw_+3A_ft">ft</code></td>
<td>
<p>transmitter frequency in Hz.</p>
</td></tr>
<tr><td><code id="make_basis_from_raw_+3A_fs">fs</code></td>
<td>
<p>sampling frequency in Hz.</p>
</td></tr>
<tr><td><code id="make_basis_from_raw_+3A_ref">ref</code></td>
<td>
<p>reference value for ppm scale.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a basis-set object.
</p>

<hr>
<h2 id='mask_dyns'>Mask an MRS dataset in the dynamic dimension.</h2><span id='topic+mask_dyns'></span>

<h3>Description</h3>

<p>Mask an MRS dataset in the dynamic dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mask_dyns(mrs_data, mask)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mask_dyns_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data object.</p>
</td></tr>
<tr><td><code id="mask_dyns_+3A_mask">mask</code></td>
<td>
<p>vector of boolean values specifying the dynamics to mask, where a
value of TRUE indicates the spectrum should be removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>masked dataset.
</p>

<hr>
<h2 id='mask_fit_res'>Mask fit result spectra depending on a vector of bool values.</h2><span id='topic+mask_fit_res'></span>

<h3>Description</h3>

<p>Mask fit result spectra depending on a vector of bool values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mask_fit_res(fit_result, mask_vec, amps_only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mask_fit_res_+3A_fit_result">fit_result</code></td>
<td>
<p>fit result object to be masked.</p>
</td></tr>
<tr><td><code id="mask_fit_res_+3A_mask_vec">mask_vec</code></td>
<td>
<p>a Boolean vector with the same number of rows as there are
rows in the results table.</p>
</td></tr>
<tr><td><code id="mask_fit_res_+3A_amps_only">amps_only</code></td>
<td>
<p>only mask the amplitude and associated error estimate
columns.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a masked fit result object.
</p>

<hr>
<h2 id='mask_xy'>Mask an MRSI dataset in the x-y direction</h2><span id='topic+mask_xy'></span>

<h3>Description</h3>

<p>Mask an MRSI dataset in the x-y direction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mask_xy(mrs_data, x_dim, y_dim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mask_xy_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data object.</p>
</td></tr>
<tr><td><code id="mask_xy_+3A_x_dim">x_dim</code></td>
<td>
<p>x dimension output length.</p>
</td></tr>
<tr><td><code id="mask_xy_+3A_y_dim">y_dim</code></td>
<td>
<p>y dimension output length.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>masked MRS data.
</p>

<hr>
<h2 id='mask_xy_corners'>Mask the four corners of an MRSI dataset in the x-y plane.</h2><span id='topic+mask_xy_corners'></span>

<h3>Description</h3>

<p>Mask the four corners of an MRSI dataset in the x-y plane.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mask_xy_corners(mrs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mask_xy_corners_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>masked MRS data.
</p>

<hr>
<h2 id='mask_xy_ellipse'>Mask the voxels outside an elliptical region spanning the MRSI dataset in the
x-y plane.</h2><span id='topic+mask_xy_ellipse'></span>

<h3>Description</h3>

<p>Mask the voxels outside an elliptical region spanning the MRSI dataset in the
x-y plane.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mask_xy_ellipse(mrs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mask_xy_ellipse_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>masked MRS data.
</p>

<hr>
<h2 id='mask_xy_mat'>Mask a 2D MRSI dataset in the x-y dimension.</h2><span id='topic+mask_xy_mat'></span>

<h3>Description</h3>

<p>Mask a 2D MRSI dataset in the x-y dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mask_xy_mat(mrs_data, mask, value = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mask_xy_mat_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data object.</p>
</td></tr>
<tr><td><code id="mask_xy_mat_+3A_mask">mask</code></td>
<td>
<p>matrix of boolean values specifying the voxels to mask, where a
value of TRUE indicates the voxel should be removed.</p>
</td></tr>
<tr><td><code id="mask_xy_mat_+3A_value">value</code></td>
<td>
<p>the value to set masked data to (usually NA or 0).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>masked dataset.
</p>

<hr>
<h2 id='mat2mrs_data'>Convert a matrix (with spectral points in the column dimension and dynamics
in the row dimensions) into a mrs_data object.</h2><span id='topic+mat2mrs_data'></span>

<h3>Description</h3>

<p>Convert a matrix (with spectral points in the column dimension and dynamics
in the row dimensions) into a mrs_data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat2mrs_data(
  mat,
  mrs_data = NULL,
  fs = NULL,
  ft = NULL,
  ref = NULL,
  nuc = NULL,
  fd = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat2mrs_data_+3A_mat">mat</code></td>
<td>
<p>data matrix.</p>
</td></tr>
<tr><td><code id="mat2mrs_data_+3A_mrs_data">mrs_data</code></td>
<td>
<p>example data to copy acquisition parameters from.</p>
</td></tr>
<tr><td><code id="mat2mrs_data_+3A_fs">fs</code></td>
<td>
<p>sampling frequency in Hz.</p>
</td></tr>
<tr><td><code id="mat2mrs_data_+3A_ft">ft</code></td>
<td>
<p>transmitter frequency in Hz.</p>
</td></tr>
<tr><td><code id="mat2mrs_data_+3A_ref">ref</code></td>
<td>
<p>reference value for ppm scale.</p>
</td></tr>
<tr><td><code id="mat2mrs_data_+3A_nuc">nuc</code></td>
<td>
<p>resonant nucleus.</p>
</td></tr>
<tr><td><code id="mat2mrs_data_+3A_fd">fd</code></td>
<td>
<p>flag to indicate if the matrix is in the frequency domain (logical).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mrs_data object.
</p>

<hr>
<h2 id='matexp'>Matrix exponential function taken from complexplus package to reduce the
number of spant dependencies.</h2><span id='topic+matexp'></span>

<h3>Description</h3>

<p>Matrix exponential function taken from complexplus package to reduce the
number of spant dependencies.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>matexp(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="matexp_+3A_x">x</code></td>
<td>
<p>a square complex matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the matrix exponential of x.
</p>

<hr>
<h2 id='max_mrs'>Apply the max operator to an MRS dataset.</h2><span id='topic+max_mrs'></span>

<h3>Description</h3>

<p>Apply the max operator to an MRS dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_mrs(mrs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="max_mrs_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>MRS data following max operator.
</p>

<hr>
<h2 id='max_mrs_interp'>Apply the max operator to an interpolated MRS dataset.</h2><span id='topic+max_mrs_interp'></span>

<h3>Description</h3>

<p>Apply the max operator to an interpolated MRS dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>max_mrs_interp(mrs_data, interp_f = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="max_mrs_interp_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
<tr><td><code id="max_mrs_interp_+3A_interp_f">interp_f</code></td>
<td>
<p>interpolation factor.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Array of maximum values (real only).
</p>

<hr>
<h2 id='mean_dyn_blocks'>Calculate the mean of adjacent dynamic scans.</h2><span id='topic+mean_dyn_blocks'></span>

<h3>Description</h3>

<p>Calculate the mean of adjacent dynamic scans.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_dyn_blocks(mrs_data, block_size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_dyn_blocks_+3A_mrs_data">mrs_data</code></td>
<td>
<p>dynamic MRS data.</p>
</td></tr>
<tr><td><code id="mean_dyn_blocks_+3A_block_size">block_size</code></td>
<td>
<p>number of adjacent dynamics scans to average over.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>dynamic data averaged in blocks.
</p>

<hr>
<h2 id='mean_dyn_pairs'>Calculate the pairwise means across a dynamic data set.</h2><span id='topic+mean_dyn_pairs'></span>

<h3>Description</h3>

<p>Calculate the pairwise means across a dynamic data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_dyn_pairs(mrs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_dyn_pairs_+3A_mrs_data">mrs_data</code></td>
<td>
<p>dynamic MRS data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mean dynamic data of adjacent dynamic pairs.
</p>

<hr>
<h2 id='mean_dyns'>Calculate the mean dynamic data.</h2><span id='topic+mean_dyns'></span>

<h3>Description</h3>

<p>Calculate the mean dynamic data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_dyns(mrs_data, subset = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_dyns_+3A_mrs_data">mrs_data</code></td>
<td>
<p>dynamic MRS data.</p>
</td></tr>
<tr><td><code id="mean_dyns_+3A_subset">subset</code></td>
<td>
<p>vector containing indices to the dynamic scans to be
averaged.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mean dynamic data.
</p>

<hr>
<h2 id='mean_mrs_list'>Return the mean of a list of mrs_data objects.</h2><span id='topic+mean_mrs_list'></span>

<h3>Description</h3>

<p>Return the mean of a list of mrs_data objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_mrs_list(mrs_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_mrs_list_+3A_mrs_list">mrs_list</code></td>
<td>
<p>list of mrs_data objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mean <code>mrs_data</code> object.
</p>

<hr>
<h2 id='mean_vec_blocks'>Calculate the mean of adjacent blocks in a vector.</h2><span id='topic+mean_vec_blocks'></span>

<h3>Description</h3>

<p>Calculate the mean of adjacent blocks in a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_vec_blocks(x, block_size)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_vec_blocks_+3A_x">x</code></td>
<td>
<p>input vector.</p>
</td></tr>
<tr><td><code id="mean_vec_blocks_+3A_block_size">block_size</code></td>
<td>
<p>number of adjacent elements to average over.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector data averaged in blocks.
</p>

<hr>
<h2 id='mean.list'>Calculate the mean spectrum from an mrs_data object.</h2><span id='topic+mean.list'></span>

<h3>Description</h3>

<p>Calculate the mean spectrum from an mrs_data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'list'
mean(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean.list_+3A_x">x</code></td>
<td>
<p>object of class mrs_data.</p>
</td></tr>
<tr><td><code id="mean.list_+3A_...">...</code></td>
<td>
<p>other arguments to pass to the colMeans function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mean mrs_data object.
</p>

<hr>
<h2 id='mean.mrs_data'>Calculate the mean spectrum from an mrs_data object.</h2><span id='topic+mean.mrs_data'></span>

<h3>Description</h3>

<p>Calculate the mean spectrum from an mrs_data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mrs_data'
mean(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean.mrs_data_+3A_x">x</code></td>
<td>
<p>object of class mrs_data.</p>
</td></tr>
<tr><td><code id="mean.mrs_data_+3A_...">...</code></td>
<td>
<p>other arguments to pass to the colMeans function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mean mrs_data object.
</p>

<hr>
<h2 id='median_dyns'>Calculate the median dynamic data.</h2><span id='topic+median_dyns'></span>

<h3>Description</h3>

<p>Calculate the median dynamic data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>median_dyns(mrs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="median_dyns_+3A_mrs_data">mrs_data</code></td>
<td>
<p>dynamic MRS data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>median dynamic data.
</p>

<hr>
<h2 id='mod_td'>Apply the Modulus operator to the time-domain MRS signal.</h2><span id='topic+mod_td'></span>

<h3>Description</h3>

<p>Apply the Modulus operator to the time-domain MRS signal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mod_td(mrs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mod_td_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data input.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>time-domain modulus of input.
</p>

<hr>
<h2 id='Mod.mrs_data'>Apply Mod operator to an MRS dataset.</h2><span id='topic+Mod.mrs_data'></span>

<h3>Description</h3>

<p>Apply Mod operator to an MRS dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mrs_data'
Mod(z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mod.mrs_data_+3A_z">z</code></td>
<td>
<p>MRS data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>MRS data following Mod operator.
</p>

<hr>
<h2 id='mrs_data2basis'>Convert an mrs_data object to basis object - where basis signals are spread
across the dynamic dimension in the MRS data.</h2><span id='topic+mrs_data2basis'></span>

<h3>Description</h3>

<p>Convert an mrs_data object to basis object - where basis signals are spread
across the dynamic dimension in the MRS data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mrs_data2basis(mrs_data, names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mrs_data2basis_+3A_mrs_data">mrs_data</code></td>
<td>
<p>mrs_data object with basis signals spread across the dynamic dimension.</p>
</td></tr>
<tr><td><code id="mrs_data2basis_+3A_names">names</code></td>
<td>
<p>list of names corresponding to basis signals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>basis set object.
</p>

<hr>
<h2 id='mrs_data2bids'>Create a BIDS file structure from a vector of MRS data paths or list of
mrs_data objects.</h2><span id='topic+mrs_data2bids'></span>

<h3>Description</h3>

<p>Create a BIDS file structure from a vector of MRS data paths or list of
mrs_data objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mrs_data2bids(
  mrs_data,
  output_dir,
  suffix = NULL,
  sub = NULL,
  ses = NULL,
  task = NULL,
  acq = NULL,
  nuc = NULL,
  voi = NULL,
  rec = NULL,
  run = NULL,
  echo = NULL,
  inv = NULL,
  skip_existing = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mrs_data2bids_+3A_mrs_data">mrs_data</code></td>
<td>
<p>vector of MRS data paths or list of mrs_data objects.</p>
</td></tr>
<tr><td><code id="mrs_data2bids_+3A_output_dir">output_dir</code></td>
<td>
<p>the base directory to create the BIDS structure.</p>
</td></tr>
<tr><td><code id="mrs_data2bids_+3A_suffix">suffix</code></td>
<td>
<p>optional vector of file suffixes. Default behaviour is to
automatically determine these from the input data, however it is recommended
that they are specified to allow more efficient skipping of existing data.</p>
</td></tr>
<tr><td><code id="mrs_data2bids_+3A_sub">sub</code></td>
<td>
<p>optional vector of subject labels. If not specified, these will be
automatically generated as a series of increasing zero-padded integer values
corresponding to the mrs_data input indices.</p>
</td></tr>
<tr><td><code id="mrs_data2bids_+3A_ses">ses</code></td>
<td>
<p>optional vector of session labels.</p>
</td></tr>
<tr><td><code id="mrs_data2bids_+3A_task">task</code></td>
<td>
<p>optional vector of task labels.</p>
</td></tr>
<tr><td><code id="mrs_data2bids_+3A_acq">acq</code></td>
<td>
<p>optional vector of acquisition labels.</p>
</td></tr>
<tr><td><code id="mrs_data2bids_+3A_nuc">nuc</code></td>
<td>
<p>optional vector of nucleus labels.</p>
</td></tr>
<tr><td><code id="mrs_data2bids_+3A_voi">voi</code></td>
<td>
<p>optional vector of volume of interest labels.</p>
</td></tr>
<tr><td><code id="mrs_data2bids_+3A_rec">rec</code></td>
<td>
<p>optional vector of reconstruction labels.</p>
</td></tr>
<tr><td><code id="mrs_data2bids_+3A_run">run</code></td>
<td>
<p>optional vector of run indices.</p>
</td></tr>
<tr><td><code id="mrs_data2bids_+3A_echo">echo</code></td>
<td>
<p>optional vector of echo time indices.</p>
</td></tr>
<tr><td><code id="mrs_data2bids_+3A_inv">inv</code></td>
<td>
<p>optional vector of inversion indices.</p>
</td></tr>
<tr><td><code id="mrs_data2bids_+3A_skip_existing">skip_existing</code></td>
<td>
<p>skip any data files that have already been converted.
Defaults to TRUE, set to FALSE to force an overwrite of any existing data
files.</p>
</td></tr>
</table>

<hr>
<h2 id='mrs_data2mat'>Convert mrs_data object to a matrix, with spectral points in the column
dimension and dynamics in the row dimension.</h2><span id='topic+mrs_data2mat'></span>

<h3>Description</h3>

<p>Convert mrs_data object to a matrix, with spectral points in the column
dimension and dynamics in the row dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mrs_data2mat(mrs_data, collapse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mrs_data2mat_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data object or list of MRS data objects.</p>
</td></tr>
<tr><td><code id="mrs_data2mat_+3A_collapse">collapse</code></td>
<td>
<p>collapse all other dimensions along the dynamic dimension, eg
a 16x16 MRSI grid would be first collapsed across 256 dynamic scans.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>MRS data matrix.
</p>

<hr>
<h2 id='mrs_data2spec_mat'>Convert mrs_data object to a matrix, with spectral points in the column
dimension and dynamics in the row dimension.</h2><span id='topic+mrs_data2spec_mat'></span>

<h3>Description</h3>

<p>Convert mrs_data object to a matrix, with spectral points in the column
dimension and dynamics in the row dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mrs_data2spec_mat(mrs_data, collapse = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mrs_data2spec_mat_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data object or list of MRS data objects.</p>
</td></tr>
<tr><td><code id="mrs_data2spec_mat_+3A_collapse">collapse</code></td>
<td>
<p>collapse all other dimensions along the dynamic dimension, eg
a 16x16 MRSI grid would be first collapsed across 256 dynamic scans.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>MRS data matrix.
</p>

<hr>
<h2 id='mrs_data2vec'>Convert mrs_data object to a vector.</h2><span id='topic+mrs_data2vec'></span>

<h3>Description</h3>

<p>Convert mrs_data object to a vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mrs_data2vec(mrs_data, dyn = 1, x_pos = 1, y_pos = 1, z_pos = 1, coil = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mrs_data2vec_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data object.</p>
</td></tr>
<tr><td><code id="mrs_data2vec_+3A_dyn">dyn</code></td>
<td>
<p>dynamic index.</p>
</td></tr>
<tr><td><code id="mrs_data2vec_+3A_x_pos">x_pos</code></td>
<td>
<p>x index.</p>
</td></tr>
<tr><td><code id="mrs_data2vec_+3A_y_pos">y_pos</code></td>
<td>
<p>y index.</p>
</td></tr>
<tr><td><code id="mrs_data2vec_+3A_z_pos">z_pos</code></td>
<td>
<p>z index.</p>
</td></tr>
<tr><td><code id="mrs_data2vec_+3A_coil">coil</code></td>
<td>
<p>coil element index.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>MRS data vector.
</p>

<hr>
<h2 id='mvfftshift'>Perform a fftshift on a matrix, with each column replaced by its shifted
result.</h2><span id='topic+mvfftshift'></span>

<h3>Description</h3>

<p>Perform a fftshift on a matrix, with each column replaced by its shifted
result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvfftshift(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvfftshift_+3A_x">x</code></td>
<td>
<p>matrix input.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>output matrix.
</p>

<hr>
<h2 id='mvifftshift'>Perform an ifftshift on a matrix, with each column replaced by its shifted
result.</h2><span id='topic+mvifftshift'></span>

<h3>Description</h3>

<p>Perform an ifftshift on a matrix, with each column replaced by its shifted
result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvifftshift(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvifftshift_+3A_x">x</code></td>
<td>
<p>matrix input.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>output matrix.
</p>

<hr>
<h2 id='n2coord'>Print fit coordinates from a single index.</h2><span id='topic+n2coord'></span>

<h3>Description</h3>

<p>Print fit coordinates from a single index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>n2coord(n, fit_res)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n2coord_+3A_n">n</code></td>
<td>
<p>fit index.</p>
</td></tr>
<tr><td><code id="n2coord_+3A_fit_res">fit_res</code></td>
<td>
<p><code>fit_result</code> object.</p>
</td></tr>
</table>

<hr>
<h2 id='Ncoils'>Return the total number of coil elements in an MRS dataset.</h2><span id='topic+Ncoils'></span>

<h3>Description</h3>

<p>Return the total number of coil elements in an MRS dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ncoils(mrs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ncoils_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
</table>

<hr>
<h2 id='Ndyns'>Return the total number of dynamic scans in an MRS dataset.</h2><span id='topic+Ndyns'></span>

<h3>Description</h3>

<p>Return the total number of dynamic scans in an MRS dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ndyns(mrs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ndyns_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
</table>

<hr>
<h2 id='nifti_flip_lr'>Flip the x data dimension order of a nifti image. This corresponds to
flipping MRI data in the left-right direction, assuming the data in save in
neurological format (can check with fslorient program).</h2><span id='topic+nifti_flip_lr'></span>

<h3>Description</h3>

<p>Flip the x data dimension order of a nifti image. This corresponds to
flipping MRI data in the left-right direction, assuming the data in save in
neurological format (can check with fslorient program).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nifti_flip_lr(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nifti_flip_lr_+3A_x">x</code></td>
<td>
<p>nifti object to be processed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nifti object with reversed x data direction.
</p>

<hr>
<h2 id='Npts'>Return the number of data points in an MRS dataset.</h2><span id='topic+Npts'></span>

<h3>Description</h3>

<p>Return the number of data points in an MRS dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Npts(mrs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Npts_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number of data points.
</p>

<hr>
<h2 id='Nspec'>Return the total number of spectra in an MRS dataset.</h2><span id='topic+Nspec'></span>

<h3>Description</h3>

<p>Return the total number of spectra in an MRS dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Nspec(mrs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Nspec_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
</table>

<hr>
<h2 id='Ntrans'>Return the total number of acquired transients for an MRS dataset.</h2><span id='topic+Ntrans'></span>

<h3>Description</h3>

<p>Return the total number of acquired transients for an MRS dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ntrans(mrs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ntrans_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
</table>

<hr>
<h2 id='Nx'>Return the total number of x locations in an MRS dataset.</h2><span id='topic+Nx'></span>

<h3>Description</h3>

<p>Return the total number of x locations in an MRS dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Nx(mrs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Nx_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
</table>

<hr>
<h2 id='Ny'>Return the total number of y locations in an MRS dataset.</h2><span id='topic+Ny'></span>

<h3>Description</h3>

<p>Return the total number of y locations in an MRS dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ny(mrs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ny_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
</table>

<hr>
<h2 id='Nz'>Return the total number of z locations in an MRS dataset.</h2><span id='topic+Nz'></span>

<h3>Description</h3>

<p>Return the total number of z locations in an MRS dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Nz(mrs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Nz_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
</table>

<hr>
<h2 id='one_page_pdf'>Export a one-page pdf of a single fit result</h2><span id='topic+one_page_pdf'></span>

<h3>Description</h3>

<p>Export a one-page pdf of a single fit result
</p>


<h3>Usage</h3>

<pre><code class='language-R'>one_page_pdf(fit_res, pdf_out_path, title = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="one_page_pdf_+3A_fit_res">fit_res</code></td>
<td>
<p><code>fit_result</code> object.</p>
</td></tr>
<tr><td><code id="one_page_pdf_+3A_pdf_out_path">pdf_out_path</code></td>
<td>
<p>path to the exported pdf file.</p>
</td></tr>
<tr><td><code id="one_page_pdf_+3A_title">title</code></td>
<td>
<p>ouptut title.</p>
</td></tr>
</table>

<hr>
<h2 id='ortho3'>Display an orthographic projection plot of a nifti object.</h2><span id='topic+ortho3'></span>

<h3>Description</h3>

<p>Display an orthographic projection plot of a nifti object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ortho3(
  underlay,
  overlay = NULL,
  xyz = NULL,
  zlim = NULL,
  zlim_ol = NULL,
  alpha = 0.7,
  col_ol = viridisLite::viridis(64),
  orient_lab = TRUE,
  rescale = 1,
  crosshairs = TRUE,
  ch_lwd = 1,
  colourbar = TRUE,
  bg = "black",
  mar = c(0, 0, 0, 0),
  smallplot = c(0.63, 0.65, 0.07, 0.42)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ortho3_+3A_underlay">underlay</code></td>
<td>
<p>underlay image to be shown in grayscale.</p>
</td></tr>
<tr><td><code id="ortho3_+3A_overlay">overlay</code></td>
<td>
<p>optional overlay image.</p>
</td></tr>
<tr><td><code id="ortho3_+3A_xyz">xyz</code></td>
<td>
<p>x, y, z slice coordinates to display.</p>
</td></tr>
<tr><td><code id="ortho3_+3A_zlim">zlim</code></td>
<td>
<p>underlay intensity limits.</p>
</td></tr>
<tr><td><code id="ortho3_+3A_zlim_ol">zlim_ol</code></td>
<td>
<p>overlay intensity limits.</p>
</td></tr>
<tr><td><code id="ortho3_+3A_alpha">alpha</code></td>
<td>
<p>transparency of overlay.</p>
</td></tr>
<tr><td><code id="ortho3_+3A_col_ol">col_ol</code></td>
<td>
<p>colour palette of overlay.</p>
</td></tr>
<tr><td><code id="ortho3_+3A_orient_lab">orient_lab</code></td>
<td>
<p>display orientation labels (default TRUE).</p>
</td></tr>
<tr><td><code id="ortho3_+3A_rescale">rescale</code></td>
<td>
<p>rescale factor for the underlay and overlay images.</p>
</td></tr>
<tr><td><code id="ortho3_+3A_crosshairs">crosshairs</code></td>
<td>
<p>display the crosshairs (default TRUE).</p>
</td></tr>
<tr><td><code id="ortho3_+3A_ch_lwd">ch_lwd</code></td>
<td>
<p>crosshair linewidth.</p>
</td></tr>
<tr><td><code id="ortho3_+3A_colourbar">colourbar</code></td>
<td>
<p>display a colourbar for the overlay (default TRUE).</p>
</td></tr>
<tr><td><code id="ortho3_+3A_bg">bg</code></td>
<td>
<p>plot background colour.</p>
</td></tr>
<tr><td><code id="ortho3_+3A_mar">mar</code></td>
<td>
<p>plot margins.</p>
</td></tr>
<tr><td><code id="ortho3_+3A_smallplot">smallplot</code></td>
<td>
<p>smallplot option for positioning the colourbar.</p>
</td></tr>
</table>

<hr>
<h2 id='ortho3_inter'>Display an interactive orthographic projection plot of a nifti object.</h2><span id='topic+ortho3_inter'></span>

<h3>Description</h3>

<p>Display an interactive orthographic projection plot of a nifti object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ortho3_inter(
  underlay,
  overlay = NULL,
  xyz = NULL,
  zlim = NULL,
  zlim_ol = NULL,
  alpha = 0.7,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ortho3_inter_+3A_underlay">underlay</code></td>
<td>
<p>underlay image to be shown in grayscale.</p>
</td></tr>
<tr><td><code id="ortho3_inter_+3A_overlay">overlay</code></td>
<td>
<p>optional overlay image.</p>
</td></tr>
<tr><td><code id="ortho3_inter_+3A_xyz">xyz</code></td>
<td>
<p>x, y, z slice coordinates to display.</p>
</td></tr>
<tr><td><code id="ortho3_inter_+3A_zlim">zlim</code></td>
<td>
<p>underlay intensity limits.</p>
</td></tr>
<tr><td><code id="ortho3_inter_+3A_zlim_ol">zlim_ol</code></td>
<td>
<p>overlay intensity limits.</p>
</td></tr>
<tr><td><code id="ortho3_inter_+3A_alpha">alpha</code></td>
<td>
<p>transparency of overlay.</p>
</td></tr>
<tr><td><code id="ortho3_inter_+3A_...">...</code></td>
<td>
<p>other options to be passed to the ortho3 function.</p>
</td></tr>
</table>

<hr>
<h2 id='peak_info'>Search for the highest peak in a spectral region and return the frequency,
height and FWHM.</h2><span id='topic+peak_info'></span>

<h3>Description</h3>

<p>Search for the highest peak in a spectral region and return the frequency,
height and FWHM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>peak_info(
  mrs_data,
  xlim = c(4, 0.5),
  interp_f = 4,
  scale = "ppm",
  mode = "real"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="peak_info_+3A_mrs_data">mrs_data</code></td>
<td>
<p>an object of class <code>mrs_data</code>.</p>
</td></tr>
<tr><td><code id="peak_info_+3A_xlim">xlim</code></td>
<td>
<p>frequency range (default units of PPM) to search for the highest
peak.</p>
</td></tr>
<tr><td><code id="peak_info_+3A_interp_f">interp_f</code></td>
<td>
<p>interpolation factor, defaults to 4x.</p>
</td></tr>
<tr><td><code id="peak_info_+3A_scale">scale</code></td>
<td>
<p>the units to use for the frequency scale, can be one of: &quot;ppm&quot;,
&quot;hz&quot; or &quot;points&quot;.</p>
</td></tr>
<tr><td><code id="peak_info_+3A_mode">mode</code></td>
<td>
<p>spectral mode, can be : &quot;real&quot;, &quot;imag&quot; or &quot;mod&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of arrays containing the highest peak frequency, height and FWHM
in units of PPM and Hz.
</p>

<hr>
<h2 id='pg_extrap_xy'>Papoulis-Gerchberg (PG) algorithm method for k-space extrapolation.</h2><span id='topic+pg_extrap_xy'></span>

<h3>Description</h3>

<p>PG method as described in: Haupt CI, Schuff N, Weiner MW, Maudsley AA.
Removal of lipid artifacts in 1H spectroscopic imaging by data extrapolation.
Magn Reson Med. 1996 May;35(5):678-87. Extrapolation is performed to expand
k-space coverage by a factor of 2, with the aim to reduce Gibbs ringing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pg_extrap_xy(
  mrs_data,
  img_mask = NULL,
  kspace_mask = NULL,
  intensity_thresh = 0.15,
  iters = 50
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pg_extrap_xy_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data object.</p>
</td></tr>
<tr><td><code id="pg_extrap_xy_+3A_img_mask">img_mask</code></td>
<td>
<p>a boolean matrix of voxels with strong signals to be
extrapolated. Must be twice the dimensions of the input data.</p>
</td></tr>
<tr><td><code id="pg_extrap_xy_+3A_kspace_mask">kspace_mask</code></td>
<td>
<p>a boolean matrix of kspace points that have been sampled.
Typically a circle for MRSI, but defaults to the full rectangular area of
k-space covered by the input data. Must match the x-y dimensions of the input
data.</p>
</td></tr>
<tr><td><code id="pg_extrap_xy_+3A_intensity_thresh">intensity_thresh</code></td>
<td>
<p>used to define img_mask based on the strength of the
signal in each voxel. Defaults to intensities greater than 15% of the
maximum. Ignored if img_mask is specified as argument.</p>
</td></tr>
<tr><td><code id="pg_extrap_xy_+3A_iters">iters</code></td>
<td>
<p>number of iterations to perform.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>extrapolated <code>mrs_data</code> object.
</p>

<hr>
<h2 id='phase'>Apply phasing parameters to MRS data.</h2><span id='topic+phase'></span>

<h3>Description</h3>

<p>Apply phasing parameters to MRS data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phase(mrs_data, zero_order, first_order = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phase_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
<tr><td><code id="phase_+3A_zero_order">zero_order</code></td>
<td>
<p>zero'th order phase term in degrees.</p>
</td></tr>
<tr><td><code id="phase_+3A_first_order">first_order</code></td>
<td>
<p>first order (frequency dependent) phase term in ms.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>MRS data with applied phase parameters.
</p>

<hr>
<h2 id='phase_ref_1h_brain'>Corrected zero order phase and chemical shift offset in 1H MRS data from the
brain.</h2><span id='topic+phase_ref_1h_brain'></span>

<h3>Description</h3>

<p>Corrected zero order phase and chemical shift offset in 1H MRS data from the
brain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phase_ref_1h_brain(mrs_data, mean_ref = FALSE, ret_corr_only = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phase_ref_1h_brain_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data to be corrected.</p>
</td></tr>
<tr><td><code id="phase_ref_1h_brain_+3A_mean_ref">mean_ref</code></td>
<td>
<p>apply the phase and offset of the mean spectrum to all
others. Default is FALSE.</p>
</td></tr>
<tr><td><code id="phase_ref_1h_brain_+3A_ret_corr_only">ret_corr_only</code></td>
<td>
<p>return the corrected data only.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>corrected MRS data.
</p>

<hr>
<h2 id='plot_bc'>Convenience function to plot a baseline estimate with the original data.</h2><span id='topic+plot_bc'></span>

<h3>Description</h3>

<p>Convenience function to plot a baseline estimate with the original data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_bc(orig_data, bc_data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_bc_+3A_orig_data">orig_data</code></td>
<td>
<p>the original data.</p>
</td></tr>
<tr><td><code id="plot_bc_+3A_bc_data">bc_data</code></td>
<td>
<p>the baseline corrected data.</p>
</td></tr>
<tr><td><code id="plot_bc_+3A_...">...</code></td>
<td>
<p>other arguments to pass to the stackplot function.</p>
</td></tr>
</table>

<hr>
<h2 id='plot_reg'>Plot regressors as an image.</h2><span id='topic+plot_reg'></span>

<h3>Description</h3>

<p>Plot regressors as an image.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_reg(regressor_df)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_reg_+3A_regressor_df">regressor_df</code></td>
<td>
<p>input regressor data frame.</p>
</td></tr>
</table>

<hr>
<h2 id='plot_slice_fit'>Plot a 2D slice from an MRSI fit result object.</h2><span id='topic+plot_slice_fit'></span>

<h3>Description</h3>

<p>Plot a 2D slice from an MRSI fit result object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_slice_fit(
  fit_res,
  map,
  map_denom = NULL,
  slice = 1,
  zlim = NULL,
  interp = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_slice_fit_+3A_fit_res">fit_res</code></td>
<td>
<p><code>fit_result</code> object.</p>
</td></tr>
<tr><td><code id="plot_slice_fit_+3A_map">map</code></td>
<td>
<p>fit result values to display as a colour map. Can be specified as
a character string or array of numeric values. Defaults to &quot;tNAA&quot;.</p>
</td></tr>
<tr><td><code id="plot_slice_fit_+3A_map_denom">map_denom</code></td>
<td>
<p>fit result values to divide the map argument by. Can be
specified as a character string (eg &quot;tCr&quot;) or array of numeric values.</p>
</td></tr>
<tr><td><code id="plot_slice_fit_+3A_slice">slice</code></td>
<td>
<p>slice to plot in the z direction.</p>
</td></tr>
<tr><td><code id="plot_slice_fit_+3A_zlim">zlim</code></td>
<td>
<p>range of values to plot.</p>
</td></tr>
<tr><td><code id="plot_slice_fit_+3A_interp">interp</code></td>
<td>
<p>interpolation factor.</p>
</td></tr>
</table>

<hr>
<h2 id='plot_slice_fit_inter'>Plot a 2D slice from an MRSI fit result object.</h2><span id='topic+plot_slice_fit_inter'></span>

<h3>Description</h3>

<p>Plot a 2D slice from an MRSI fit result object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_slice_fit_inter(
  fit_res,
  map = NULL,
  map_denom = NULL,
  slice = 1,
  zlim = NULL,
  interp = 1,
  xlim = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_slice_fit_inter_+3A_fit_res">fit_res</code></td>
<td>
<p><code>fit_result</code> object.</p>
</td></tr>
<tr><td><code id="plot_slice_fit_inter_+3A_map">map</code></td>
<td>
<p>fit result values to display as a colour map. Can be specified as
a character string or array of numeric values. Defaults to &quot;tNAA&quot;.</p>
</td></tr>
<tr><td><code id="plot_slice_fit_inter_+3A_map_denom">map_denom</code></td>
<td>
<p>fit result values to divide the map argument by. Can be
specified as a character string (eg &quot;tCr&quot;) or array of numeric values.</p>
</td></tr>
<tr><td><code id="plot_slice_fit_inter_+3A_slice">slice</code></td>
<td>
<p>slice to plot in the z direction.</p>
</td></tr>
<tr><td><code id="plot_slice_fit_inter_+3A_zlim">zlim</code></td>
<td>
<p>range of values to plot.</p>
</td></tr>
<tr><td><code id="plot_slice_fit_inter_+3A_interp">interp</code></td>
<td>
<p>interpolation factor.</p>
</td></tr>
<tr><td><code id="plot_slice_fit_inter_+3A_xlim">xlim</code></td>
<td>
<p>spectral plot limits for the x axis.</p>
</td></tr>
</table>

<hr>
<h2 id='plot_slice_map'>Plot a slice from a 7 dimensional array.</h2><span id='topic+plot_slice_map'></span>

<h3>Description</h3>

<p>Plot a slice from a 7 dimensional array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_slice_map(
  data,
  zlim = NULL,
  mask_map = NULL,
  mask_cutoff = 20,
  interp = 1,
  slice = 1,
  dyn = 1,
  coil = 1,
  ref = 1,
  denom = NULL,
  horizontal = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_slice_map_+3A_data">data</code></td>
<td>
<p>7d array of values to be plotted.</p>
</td></tr>
<tr><td><code id="plot_slice_map_+3A_zlim">zlim</code></td>
<td>
<p>smallest and largest values to be plotted.</p>
</td></tr>
<tr><td><code id="plot_slice_map_+3A_mask_map">mask_map</code></td>
<td>
<p>matching map with logical values to indicate if the
corresponding values should be plotted.</p>
</td></tr>
<tr><td><code id="plot_slice_map_+3A_mask_cutoff">mask_cutoff</code></td>
<td>
<p>minimum values to plot (as a percentage of the maximum).</p>
</td></tr>
<tr><td><code id="plot_slice_map_+3A_interp">interp</code></td>
<td>
<p>map interpolation factor.</p>
</td></tr>
<tr><td><code id="plot_slice_map_+3A_slice">slice</code></td>
<td>
<p>the slice index to plot.</p>
</td></tr>
<tr><td><code id="plot_slice_map_+3A_dyn">dyn</code></td>
<td>
<p>the dynamic index to plot.</p>
</td></tr>
<tr><td><code id="plot_slice_map_+3A_coil">coil</code></td>
<td>
<p>the coil element number to plot.</p>
</td></tr>
<tr><td><code id="plot_slice_map_+3A_ref">ref</code></td>
<td>
<p>reference index to plot.</p>
</td></tr>
<tr><td><code id="plot_slice_map_+3A_denom">denom</code></td>
<td>
<p>map to use as a denominator.</p>
</td></tr>
<tr><td><code id="plot_slice_map_+3A_horizontal">horizontal</code></td>
<td>
<p>display the colourbar horizontally (logical).</p>
</td></tr>
</table>

<hr>
<h2 id='plot_slice_map_inter'>Plot an interactive slice map from a data array where voxels can be selected
to display a corresponding spectrum.</h2><span id='topic+plot_slice_map_inter'></span>

<h3>Description</h3>

<p>Plot an interactive slice map from a data array where voxels can be selected
to display a corresponding spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_slice_map_inter(
  mrs_data,
  map = NULL,
  xlim = NULL,
  slice = 1,
  zlim = NULL,
  mask_map = NULL,
  denom = NULL,
  mask_cutoff = 20,
  interp = 1,
  mode = "re",
  y_scale = FALSE,
  ylim = NULL,
  coil = 1,
  fd = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_slice_map_inter_+3A_mrs_data">mrs_data</code></td>
<td>
<p>spectral data.</p>
</td></tr>
<tr><td><code id="plot_slice_map_inter_+3A_map">map</code></td>
<td>
<p>array of values to be plotted, defaults to the integration of the
modulus of the full spectral width.</p>
</td></tr>
<tr><td><code id="plot_slice_map_inter_+3A_xlim">xlim</code></td>
<td>
<p>spectral region to plot.</p>
</td></tr>
<tr><td><code id="plot_slice_map_inter_+3A_slice">slice</code></td>
<td>
<p>the slice index to plot.</p>
</td></tr>
<tr><td><code id="plot_slice_map_inter_+3A_zlim">zlim</code></td>
<td>
<p>smallest and largest values to be plotted.</p>
</td></tr>
<tr><td><code id="plot_slice_map_inter_+3A_mask_map">mask_map</code></td>
<td>
<p>matching map with logical values to indicate if the
corresponding values should be plotted.</p>
</td></tr>
<tr><td><code id="plot_slice_map_inter_+3A_denom">denom</code></td>
<td>
<p>map to use as a denominator.</p>
</td></tr>
<tr><td><code id="plot_slice_map_inter_+3A_mask_cutoff">mask_cutoff</code></td>
<td>
<p>minimum values to plot (as a percentage of the maximum).</p>
</td></tr>
<tr><td><code id="plot_slice_map_inter_+3A_interp">interp</code></td>
<td>
<p>map interpolation factor.</p>
</td></tr>
<tr><td><code id="plot_slice_map_inter_+3A_mode">mode</code></td>
<td>
<p>representation of the complex spectrum to be plotted, can be one
of: &quot;re&quot;, &quot;im&quot;, &quot;mod&quot; or &quot;arg&quot;.</p>
</td></tr>
<tr><td><code id="plot_slice_map_inter_+3A_y_scale">y_scale</code></td>
<td>
<p>option to display the y-axis values (logical).</p>
</td></tr>
<tr><td><code id="plot_slice_map_inter_+3A_ylim">ylim</code></td>
<td>
<p>intensity range to plot.</p>
</td></tr>
<tr><td><code id="plot_slice_map_inter_+3A_coil">coil</code></td>
<td>
<p>coil element to plot.</p>
</td></tr>
<tr><td><code id="plot_slice_map_inter_+3A_fd">fd</code></td>
<td>
<p>display data in the frequency-domain (default), or time-domain
(logical).</p>
</td></tr>
</table>

<hr>
<h2 id='plot_spec_sd'>Plot the spectral standard deviation.</h2><span id='topic+plot_spec_sd'></span>

<h3>Description</h3>

<p>Plot the spectral standard deviation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_spec_sd(mrs_data, xlim = NULL, scale_sd = 1.96, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_spec_sd_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data to be plotted.</p>
</td></tr>
<tr><td><code id="plot_spec_sd_+3A_xlim">xlim</code></td>
<td>
<p>plotting limits in ppm.</p>
</td></tr>
<tr><td><code id="plot_spec_sd_+3A_scale_sd">scale_sd</code></td>
<td>
<p>scaling factor for the standard deviation trace.</p>
</td></tr>
<tr><td><code id="plot_spec_sd_+3A_...">...</code></td>
<td>
<p>other arguments passed to the stackplot function.</p>
</td></tr>
</table>

<hr>
<h2 id='plot_voi_overlay'>Plot a volume as an image overlay.</h2><span id='topic+plot_voi_overlay'></span>

<h3>Description</h3>

<p>Plot a volume as an image overlay.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_voi_overlay(mri, voi, export_path = NULL, zlim = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_voi_overlay_+3A_mri">mri</code></td>
<td>
<p>image data as a nifti object or path to data file.</p>
</td></tr>
<tr><td><code id="plot_voi_overlay_+3A_voi">voi</code></td>
<td>
<p>volume data as a nifti object or path to data file.</p>
</td></tr>
<tr><td><code id="plot_voi_overlay_+3A_export_path">export_path</code></td>
<td>
<p>optional path to save the image in png format.</p>
</td></tr>
<tr><td><code id="plot_voi_overlay_+3A_zlim">zlim</code></td>
<td>
<p>underlay intensity limits.</p>
</td></tr>
<tr><td><code id="plot_voi_overlay_+3A_...">...</code></td>
<td>
<p>additional arguments to the ortho3 function.</p>
</td></tr>
</table>

<hr>
<h2 id='plot_voi_overlay_seg'>Plot a volume as an overlay on a segmented brain volume.</h2><span id='topic+plot_voi_overlay_seg'></span>

<h3>Description</h3>

<p>Plot a volume as an overlay on a segmented brain volume.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_voi_overlay_seg(mri_seg, voi, export_path = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_voi_overlay_seg_+3A_mri_seg">mri_seg</code></td>
<td>
<p>segmented brain volume as a nifti object.</p>
</td></tr>
<tr><td><code id="plot_voi_overlay_seg_+3A_voi">voi</code></td>
<td>
<p>volume data as a nifti object.</p>
</td></tr>
<tr><td><code id="plot_voi_overlay_seg_+3A_export_path">export_path</code></td>
<td>
<p>optional path to save the image in png format.</p>
</td></tr>
<tr><td><code id="plot_voi_overlay_seg_+3A_...">...</code></td>
<td>
<p>additional arguments to the ortho3 function.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.fit_result'>Plot the fitting results of an object of class <code>fit_result</code>.</h2><span id='topic+plot.fit_result'></span>

<h3>Description</h3>

<p>Plot the fitting results of an object of class <code>fit_result</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fit_result'
plot(
  x,
  dyn = 1,
  x_pos = 1,
  y_pos = 1,
  z_pos = 1,
  coil = 1,
  xlim = NULL,
  data_only = FALSE,
  label = NULL,
  plot_sigs = NULL,
  n = NULL,
  sub_bl = FALSE,
  mar = NULL,
  restore_def_par = TRUE,
  ylim = NULL,
  y_scale = FALSE,
  show_grid = TRUE,
  grid_nx = NULL,
  grid_ny = NA,
  invert_fit = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.fit_result_+3A_x">x</code></td>
<td>
<p>fit_result object.</p>
</td></tr>
<tr><td><code id="plot.fit_result_+3A_dyn">dyn</code></td>
<td>
<p>the dynamic index to plot.</p>
</td></tr>
<tr><td><code id="plot.fit_result_+3A_x_pos">x_pos</code></td>
<td>
<p>the x index to plot.</p>
</td></tr>
<tr><td><code id="plot.fit_result_+3A_y_pos">y_pos</code></td>
<td>
<p>the y index to plot.</p>
</td></tr>
<tr><td><code id="plot.fit_result_+3A_z_pos">z_pos</code></td>
<td>
<p>the z index to plot.</p>
</td></tr>
<tr><td><code id="plot.fit_result_+3A_coil">coil</code></td>
<td>
<p>the coil element number to plot.</p>
</td></tr>
<tr><td><code id="plot.fit_result_+3A_xlim">xlim</code></td>
<td>
<p>the range of values to display on the x-axis, eg xlim = c(4,1).</p>
</td></tr>
<tr><td><code id="plot.fit_result_+3A_data_only">data_only</code></td>
<td>
<p>display only the processed data (logical).</p>
</td></tr>
<tr><td><code id="plot.fit_result_+3A_label">label</code></td>
<td>
<p>character string to add to the top left of the plot window.</p>
</td></tr>
<tr><td><code id="plot.fit_result_+3A_plot_sigs">plot_sigs</code></td>
<td>
<p>a character vector of signal names to add to the plot.</p>
</td></tr>
<tr><td><code id="plot.fit_result_+3A_n">n</code></td>
<td>
<p>single index element to plot (overrides other indices when given).</p>
</td></tr>
<tr><td><code id="plot.fit_result_+3A_sub_bl">sub_bl</code></td>
<td>
<p>subtract the baseline from the data and fit (logical).</p>
</td></tr>
<tr><td><code id="plot.fit_result_+3A_mar">mar</code></td>
<td>
<p>option to adjust the plot margins. See ?par.</p>
</td></tr>
<tr><td><code id="plot.fit_result_+3A_restore_def_par">restore_def_par</code></td>
<td>
<p>restore default plotting par values after the plot has
been made.</p>
</td></tr>
<tr><td><code id="plot.fit_result_+3A_ylim">ylim</code></td>
<td>
<p>range of values to display on the y-axis, eg ylim = c(0,10).</p>
</td></tr>
<tr><td><code id="plot.fit_result_+3A_y_scale">y_scale</code></td>
<td>
<p>option to display the y-axis values (logical).</p>
</td></tr>
<tr><td><code id="plot.fit_result_+3A_show_grid">show_grid</code></td>
<td>
<p>plot gridlines behind the data (logical). Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="plot.fit_result_+3A_grid_nx">grid_nx</code></td>
<td>
<p>number of cells of the grid in x and y direction. When NULL
the grid aligns with the tick marks on the corresponding default axis (i.e.,
tickmarks as computed by axTicks). When NA, no grid lines are drawn in the
corresponding direction.</p>
</td></tr>
<tr><td><code id="plot.fit_result_+3A_grid_ny">grid_ny</code></td>
<td>
<p>as above.</p>
</td></tr>
<tr><td><code id="plot.fit_result_+3A_invert_fit">invert_fit</code></td>
<td>
<p>show the fit result &quot;upside-down&quot;/</p>
</td></tr>
<tr><td><code id="plot.fit_result_+3A_...">...</code></td>
<td>
<p>further arguments to plot method.</p>
</td></tr>
</table>

<hr>
<h2 id='plot.mrs_data'>Plotting method for objects of class mrs_data.</h2><span id='topic+plot.mrs_data'></span>

<h3>Description</h3>

<p>Plotting method for objects of class mrs_data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mrs_data'
plot(
  x,
  dyn = 1,
  x_pos = 1,
  y_pos = 1,
  z_pos = 1,
  coil = 1,
  fd = TRUE,
  x_units = NULL,
  xlim = NULL,
  y_scale = FALSE,
  x_ax = TRUE,
  mode = "re",
  lwd = NULL,
  bty = NULL,
  label = "",
  restore_def_par = TRUE,
  mar = NULL,
  xaxis_lab = NULL,
  yaxis_lab = NULL,
  xat = NULL,
  xlabs = TRUE,
  yat = NULL,
  ylabs = TRUE,
  show_grid = TRUE,
  grid_nx = NULL,
  grid_ny = NA,
  col = NULL,
  alpha = NULL,
  bl_lty = NULL,
  hline = NULL,
  hline_lty = 2,
  hline_col = "red",
  vline = NULL,
  vline_lty = 2,
  vline_col = "red",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.mrs_data_+3A_x">x</code></td>
<td>
<p>object of class mrs_data.</p>
</td></tr>
<tr><td><code id="plot.mrs_data_+3A_dyn">dyn</code></td>
<td>
<p>the dynamic index to plot.</p>
</td></tr>
<tr><td><code id="plot.mrs_data_+3A_x_pos">x_pos</code></td>
<td>
<p>the x index to plot.</p>
</td></tr>
<tr><td><code id="plot.mrs_data_+3A_y_pos">y_pos</code></td>
<td>
<p>the y index to plot.</p>
</td></tr>
<tr><td><code id="plot.mrs_data_+3A_z_pos">z_pos</code></td>
<td>
<p>the z index to plot.</p>
</td></tr>
<tr><td><code id="plot.mrs_data_+3A_coil">coil</code></td>
<td>
<p>the coil element number to plot.</p>
</td></tr>
<tr><td><code id="plot.mrs_data_+3A_fd">fd</code></td>
<td>
<p>display data in the frequency-domain (default), or time-domain
(logical).</p>
</td></tr>
<tr><td><code id="plot.mrs_data_+3A_x_units">x_units</code></td>
<td>
<p>the units to use for the x-axis, can be one of: &quot;ppm&quot;, &quot;hz&quot;,
&quot;points&quot; or &quot;seconds&quot;.</p>
</td></tr>
<tr><td><code id="plot.mrs_data_+3A_xlim">xlim</code></td>
<td>
<p>the range of values to display on the x-axis, eg xlim = c(4,1).</p>
</td></tr>
<tr><td><code id="plot.mrs_data_+3A_y_scale">y_scale</code></td>
<td>
<p>option to display the y-axis values (logical).</p>
</td></tr>
<tr><td><code id="plot.mrs_data_+3A_x_ax">x_ax</code></td>
<td>
<p>option to display the x-axis values (logical).</p>
</td></tr>
<tr><td><code id="plot.mrs_data_+3A_mode">mode</code></td>
<td>
<p>representation of the complex numbers to be plotted, can be one
of: &quot;re&quot;, &quot;im&quot;, &quot;mod&quot; or &quot;arg&quot;.</p>
</td></tr>
<tr><td><code id="plot.mrs_data_+3A_lwd">lwd</code></td>
<td>
<p>plot linewidth.</p>
</td></tr>
<tr><td><code id="plot.mrs_data_+3A_bty">bty</code></td>
<td>
<p>option to draw a box around the plot. See ?par.</p>
</td></tr>
<tr><td><code id="plot.mrs_data_+3A_label">label</code></td>
<td>
<p>character string to add to the top left of the plot window.</p>
</td></tr>
<tr><td><code id="plot.mrs_data_+3A_restore_def_par">restore_def_par</code></td>
<td>
<p>restore default plotting par values after the plot has
been made.</p>
</td></tr>
<tr><td><code id="plot.mrs_data_+3A_mar">mar</code></td>
<td>
<p>option to adjust the plot margins. See ?par.</p>
</td></tr>
<tr><td><code id="plot.mrs_data_+3A_xaxis_lab">xaxis_lab</code></td>
<td>
<p>x-axis label.</p>
</td></tr>
<tr><td><code id="plot.mrs_data_+3A_yaxis_lab">yaxis_lab</code></td>
<td>
<p>y-axis label.</p>
</td></tr>
<tr><td><code id="plot.mrs_data_+3A_xat">xat</code></td>
<td>
<p>x-axis tick label values.</p>
</td></tr>
<tr><td><code id="plot.mrs_data_+3A_xlabs">xlabs</code></td>
<td>
<p>x-axis tick labels.</p>
</td></tr>
<tr><td><code id="plot.mrs_data_+3A_yat">yat</code></td>
<td>
<p>y-axis tick label values.</p>
</td></tr>
<tr><td><code id="plot.mrs_data_+3A_ylabs">ylabs</code></td>
<td>
<p>y-axis tick labels.</p>
</td></tr>
<tr><td><code id="plot.mrs_data_+3A_show_grid">show_grid</code></td>
<td>
<p>plot gridlines behind the data (logical). Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="plot.mrs_data_+3A_grid_nx">grid_nx</code></td>
<td>
<p>number of cells of the grid in x and y direction. When NULL
the grid aligns with the tick marks on the corresponding default axis (i.e.,
tickmarks as computed by axTicks). When NA, no grid lines are drawn in the
corresponding direction.</p>
</td></tr>
<tr><td><code id="plot.mrs_data_+3A_grid_ny">grid_ny</code></td>
<td>
<p>as above.</p>
</td></tr>
<tr><td><code id="plot.mrs_data_+3A_col">col</code></td>
<td>
<p>set the line colour, eg col = rgb(0.5, 0.5, 0.5).</p>
</td></tr>
<tr><td><code id="plot.mrs_data_+3A_alpha">alpha</code></td>
<td>
<p>set the line transparency, eg alpha = 0.5 is 50% transparency.
Overrides any transparency levels set by col.</p>
</td></tr>
<tr><td><code id="plot.mrs_data_+3A_bl_lty">bl_lty</code></td>
<td>
<p>linetype for the y = 0 baseline trace. A default value NULL
results in no baseline being plotted.</p>
</td></tr>
<tr><td><code id="plot.mrs_data_+3A_hline">hline</code></td>
<td>
<p>add a horizontal line at the specified value.</p>
</td></tr>
<tr><td><code id="plot.mrs_data_+3A_hline_lty">hline_lty</code></td>
<td>
<p>linetype for the horizontal line.</p>
</td></tr>
<tr><td><code id="plot.mrs_data_+3A_hline_col">hline_col</code></td>
<td>
<p>colour for the horizontal line.</p>
</td></tr>
<tr><td><code id="plot.mrs_data_+3A_vline">vline</code></td>
<td>
<p>add a vertical line at the specified value.</p>
</td></tr>
<tr><td><code id="plot.mrs_data_+3A_vline_lty">vline_lty</code></td>
<td>
<p>linetype for the vertical line.</p>
</td></tr>
<tr><td><code id="plot.mrs_data_+3A_vline_col">vline_col</code></td>
<td>
<p>colour for the vertical line.</p>
</td></tr>
<tr><td><code id="plot.mrs_data_+3A_...">...</code></td>
<td>
<p>other arguments to pass to the plot method.</p>
</td></tr>
</table>

<hr>
<h2 id='ppm'>Return the ppm scale of an MRS dataset or fit result.</h2><span id='topic+ppm'></span><span id='topic+ppm.mrs_data'></span><span id='topic+ppm.fit_result'></span>

<h3>Description</h3>

<p>Return the ppm scale of an MRS dataset or fit result.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppm(x, ft = NULL, ref = NULL, fs = NULL, N = NULL)

## S3 method for class 'mrs_data'
ppm(x, ft = NULL, ref = NULL, fs = NULL, N = NULL)

## S3 method for class 'fit_result'
ppm(x, ft = NULL, ref = NULL, fs = NULL, N = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ppm_+3A_x">x</code></td>
<td>
<p>MRS dataset of fit result.</p>
</td></tr>
<tr><td><code id="ppm_+3A_ft">ft</code></td>
<td>
<p>transmitter frequency in Hz, does not apply when the object is a
fit result.</p>
</td></tr>
<tr><td><code id="ppm_+3A_ref">ref</code></td>
<td>
<p>reference value for ppm scale, does not apply when the object is a
fit result.</p>
</td></tr>
<tr><td><code id="ppm_+3A_fs">fs</code></td>
<td>
<p>sampling frequency in Hz, does not apply when the object is a
fit result.</p>
</td></tr>
<tr><td><code id="ppm_+3A_n">N</code></td>
<td>
<p>number of data points in the spectral dimension, does not apply when
the object is a fit result.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ppm scale.
</p>

<hr>
<h2 id='precomp'>Save function results to file and load on subsequent calls to avoid repeat
computation.</h2><span id='topic+precomp'></span>

<h3>Description</h3>

<p>Save function results to file and load on subsequent calls to avoid repeat
computation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>precomp(file, fun, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="precomp_+3A_file">file</code></td>
<td>
<p>file name to write the results.</p>
</td></tr>
<tr><td><code id="precomp_+3A_fun">fun</code></td>
<td>
<p>function to run.</p>
</td></tr>
<tr><td><code id="precomp_+3A_...">...</code></td>
<td>
<p>arguments to be passed to fun.</p>
</td></tr>
</table>

<hr>
<h2 id='preproc_svs'>Preprocess and perform quality assessment of a single SVS data set.</h2><span id='topic+preproc_svs'></span>

<h3>Description</h3>

<p>Preprocess and perform quality assessment of a single SVS data set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preproc_svs(path, label = NULL, output_dir = NULL, ref_inds = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preproc_svs_+3A_path">path</code></td>
<td>
<p>path to the fMRS data file or IMA directory.</p>
</td></tr>
<tr><td><code id="preproc_svs_+3A_label">label</code></td>
<td>
<p>a label to describe the data set.</p>
</td></tr>
<tr><td><code id="preproc_svs_+3A_output_dir">output_dir</code></td>
<td>
<p>output directory.</p>
</td></tr>
<tr><td><code id="preproc_svs_+3A_ref_inds">ref_inds</code></td>
<td>
<p>a vector of 1-based indices for any water reference dynamic
scans.</p>
</td></tr>
</table>

<hr>
<h2 id='preproc_svs_dataset'>Preprocess and perform quality assessment of one or more SVS data sets.</h2><span id='topic+preproc_svs_dataset'></span>

<h3>Description</h3>

<p>Preprocess and perform quality assessment of one or more SVS data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preproc_svs_dataset(
  paths,
  labels = NULL,
  output_dir = "spant_analysis",
  exclude_labels = NULL,
  overwrite = FALSE,
  ref_inds = NULL,
  return_results = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preproc_svs_dataset_+3A_paths">paths</code></td>
<td>
<p>paths to the fMRS data file or IMA directory.</p>
</td></tr>
<tr><td><code id="preproc_svs_dataset_+3A_labels">labels</code></td>
<td>
<p>labels to describe each data set.</p>
</td></tr>
<tr><td><code id="preproc_svs_dataset_+3A_output_dir">output_dir</code></td>
<td>
<p>output directory.</p>
</td></tr>
<tr><td><code id="preproc_svs_dataset_+3A_exclude_labels">exclude_labels</code></td>
<td>
<p>vector of labels of scans to exclude, eg poor quality
data.</p>
</td></tr>
<tr><td><code id="preproc_svs_dataset_+3A_overwrite">overwrite</code></td>
<td>
<p>overwrite saved results, defaults to FALSE.</p>
</td></tr>
<tr><td><code id="preproc_svs_dataset_+3A_ref_inds">ref_inds</code></td>
<td>
<p>a vector of 1-based indices for any water reference dynamic
scans.</p>
</td></tr>
<tr><td><code id="preproc_svs_dataset_+3A_return_results">return_results</code></td>
<td>
<p>function will return key outputs, defaults to FALSE.</p>
</td></tr>
</table>

<hr>
<h2 id='print.fit_result'>Print a summary of an object of class <code>fit_result</code>.</h2><span id='topic+print.fit_result'></span>

<h3>Description</h3>

<p>Print a summary of an object of class <code>fit_result</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fit_result'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.fit_result_+3A_x">x</code></td>
<td>
<p><code>fit_result</code> object.</p>
</td></tr>
<tr><td><code id="print.fit_result_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>

<hr>
<h2 id='print.mrs_data'>Print a summary of mrs_data parameters.</h2><span id='topic+print.mrs_data'></span>

<h3>Description</h3>

<p>Print a summary of mrs_data parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mrs_data'
print(x, full = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.mrs_data_+3A_x">x</code></td>
<td>
<p>mrs_data object.</p>
</td></tr>
<tr><td><code id="print.mrs_data_+3A_full">full</code></td>
<td>
<p>print all parameters (default FALSE).</p>
</td></tr>
<tr><td><code id="print.mrs_data_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>

<hr>
<h2 id='qn_states'>Get the quantum coherence matrix for a spin system.</h2><span id='topic+qn_states'></span>

<h3>Description</h3>

<p>Get the quantum coherence matrix for a spin system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qn_states(sys)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="qn_states_+3A_sys">sys</code></td>
<td>
<p>spin system object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>quantum coherence number matrix.
</p>

<hr>
<h2 id='rats'>Robust Alignment to a Target Spectrum (RATS).</h2><span id='topic+rats'></span>

<h3>Description</h3>

<p>Robust Alignment to a Target Spectrum (RATS).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rats(
  mrs_data,
  ref = NULL,
  xlim = c(4, 0.5),
  max_shift = 20,
  p_deg = 2,
  sp_N = 2,
  sp_deg = 3,
  max_t = 0.2,
  basis_type = "poly",
  rescale_output = TRUE,
  phase_corr = TRUE,
  ret_corr_only = TRUE,
  zero_freq_shift_t0 = FALSE,
  remove_freq_outliers = FALSE,
  freq_outlier_thresh = 3,
  remove_phase_outliers = FALSE,
  phase_outlier_thresh = 3,
  remove_amp_outliers = FALSE,
  amp_outlier_thresh = 3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rats_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data to be corrected.</p>
</td></tr>
<tr><td><code id="rats_+3A_ref">ref</code></td>
<td>
<p>optional MRS data to use as a reference, the mean of all dynamics
is used if this argument is not supplied.</p>
</td></tr>
<tr><td><code id="rats_+3A_xlim">xlim</code></td>
<td>
<p>optional frequency range to perform optimisation, set to NULL
to use the full range.</p>
</td></tr>
<tr><td><code id="rats_+3A_max_shift">max_shift</code></td>
<td>
<p>maximum allowable frequency shift in Hz.</p>
</td></tr>
<tr><td><code id="rats_+3A_p_deg">p_deg</code></td>
<td>
<p>polynomial degree used for baseline modelling. Negative values
disable baseline modelling.</p>
</td></tr>
<tr><td><code id="rats_+3A_sp_n">sp_N</code></td>
<td>
<p>number of spline functions, note the true number will be sp_N +
sp_deg.</p>
</td></tr>
<tr><td><code id="rats_+3A_sp_deg">sp_deg</code></td>
<td>
<p>degree of spline functions.</p>
</td></tr>
<tr><td><code id="rats_+3A_max_t">max_t</code></td>
<td>
<p>truncate the FID when longer than max_t to reduce time taken,
set to NULL to use the entire FID.</p>
</td></tr>
<tr><td><code id="rats_+3A_basis_type">basis_type</code></td>
<td>
<p>may be one of &quot;poly&quot; or &quot;spline&quot;.</p>
</td></tr>
<tr><td><code id="rats_+3A_rescale_output">rescale_output</code></td>
<td>
<p>rescale the bl_matched_spec and bl output to improve
consistency between dynamic scans.</p>
</td></tr>
<tr><td><code id="rats_+3A_phase_corr">phase_corr</code></td>
<td>
<p>apply phase correction (in addition to frequency). TRUE by
default.</p>
</td></tr>
<tr><td><code id="rats_+3A_ret_corr_only">ret_corr_only</code></td>
<td>
<p>return the corrected mrs_data object only.</p>
</td></tr>
<tr><td><code id="rats_+3A_zero_freq_shift_t0">zero_freq_shift_t0</code></td>
<td>
<p>perform a linear fit to the frequency shifts and
set the (linearly modeled) shift to be 0 Hz for the first dynamic scan.</p>
</td></tr>
<tr><td><code id="rats_+3A_remove_freq_outliers">remove_freq_outliers</code></td>
<td>
<p>remove dynamics based on their frequency shift.</p>
</td></tr>
<tr><td><code id="rats_+3A_freq_outlier_thresh">freq_outlier_thresh</code></td>
<td>
<p>threshold to remove frequency outliers.</p>
</td></tr>
<tr><td><code id="rats_+3A_remove_phase_outliers">remove_phase_outliers</code></td>
<td>
<p>remove dynamics based on their phase shift.</p>
</td></tr>
<tr><td><code id="rats_+3A_phase_outlier_thresh">phase_outlier_thresh</code></td>
<td>
<p>threshold to remove phase outliers.</p>
</td></tr>
<tr><td><code id="rats_+3A_remove_amp_outliers">remove_amp_outliers</code></td>
<td>
<p>remove dynamics based on their amplitude change.</p>
</td></tr>
<tr><td><code id="rats_+3A_amp_outlier_thresh">amp_outlier_thresh</code></td>
<td>
<p>threshold to remove amplitude outliers.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the corrected data; phase and shift values in units
of degrees and Hz respectively.
</p>

<hr>
<h2 id='re_weighting'>Apply a weighting to the FID to enhance spectral resolution.</h2><span id='topic+re_weighting'></span>

<h3>Description</h3>

<p>Apply a weighting to the FID to enhance spectral resolution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>re_weighting(mrs_data, re, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="re_weighting_+3A_mrs_data">mrs_data</code></td>
<td>
<p>data to be enhanced.</p>
</td></tr>
<tr><td><code id="re_weighting_+3A_re">re</code></td>
<td>
<p>resolution enhancement factor (rising exponential factor).</p>
</td></tr>
<tr><td><code id="re_weighting_+3A_alpha">alpha</code></td>
<td>
<p>alpha factor (Gaussian decay)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>resolution enhanced mrs_data.
</p>

<hr>
<h2 id='Re.mrs_data'>Apply Re operator to an MRS dataset.</h2><span id='topic+Re.mrs_data'></span>

<h3>Description</h3>

<p>Apply Re operator to an MRS dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mrs_data'
Re(z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Re.mrs_data_+3A_z">z</code></td>
<td>
<p>MRS data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>MRS data following Re operator.
</p>

<hr>
<h2 id='read_basis'>Read a basis file in LCModel .basis format.</h2><span id='topic+read_basis'></span>

<h3>Description</h3>

<p>Read a basis file in LCModel .basis format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_basis(basis_file, ref = def_ref(), sort_basis = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_basis_+3A_basis_file">basis_file</code></td>
<td>
<p>path to basis file.</p>
</td></tr>
<tr><td><code id="read_basis_+3A_ref">ref</code></td>
<td>
<p>assumed ppm reference value.</p>
</td></tr>
<tr><td><code id="read_basis_+3A_sort_basis">sort_basis</code></td>
<td>
<p>sort the basis set based on signal names.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>basis object.
</p>

<hr>
<h2 id='read_ima_coil_dir'>Read a directory containing Siemens MRS IMA files and combine along the coil
dimension. Note that the coil ID is inferred from the sorted file name and
should be checked when consistency is required between two directories.</h2><span id='topic+read_ima_coil_dir'></span>

<h3>Description</h3>

<p>Read a directory containing Siemens MRS IMA files and combine along the coil
dimension. Note that the coil ID is inferred from the sorted file name and
should be checked when consistency is required between two directories.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_ima_coil_dir(dir, extra = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_ima_coil_dir_+3A_dir">dir</code></td>
<td>
<p>data directory path.</p>
</td></tr>
<tr><td><code id="read_ima_coil_dir_+3A_extra">extra</code></td>
<td>
<p>an optional data frame to provide additional variables for use
in subsequent analysis steps, eg id or grouping variables.</p>
</td></tr>
<tr><td><code id="read_ima_coil_dir_+3A_verbose">verbose</code></td>
<td>
<p>output extra information to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mrs_data object.
</p>

<hr>
<h2 id='read_ima_dyn_dir'>Read a directory containing Siemens MRS IMA files and combine along the
dynamic dimension. Note that the coil ID is inferred from the sorted file
name and should be checked when consistency is required.</h2><span id='topic+read_ima_dyn_dir'></span>

<h3>Description</h3>

<p>Read a directory containing Siemens MRS IMA files and combine along the
dynamic dimension. Note that the coil ID is inferred from the sorted file
name and should be checked when consistency is required.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_ima_dyn_dir(dir, extra = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_ima_dyn_dir_+3A_dir">dir</code></td>
<td>
<p>data directory path.</p>
</td></tr>
<tr><td><code id="read_ima_dyn_dir_+3A_extra">extra</code></td>
<td>
<p>an optional data frame to provide additional variables for use
in subsequent analysis steps, eg id or grouping variables.</p>
</td></tr>
<tr><td><code id="read_ima_dyn_dir_+3A_verbose">verbose</code></td>
<td>
<p>output extra information to the console.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mrs_data object.
</p>

<hr>
<h2 id='read_lcm_coord'>Read an LCModel formatted coord file containing fit information.</h2><span id='topic+read_lcm_coord'></span>

<h3>Description</h3>

<p>Read an LCModel formatted coord file containing fit information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_lcm_coord(coord_f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_lcm_coord_+3A_coord_f">coord_f</code></td>
<td>
<p>path to the coord file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list containing a table of fit point and results structure containing
signal amplitudes, errors and fitting diagnostics.
</p>

<hr>
<h2 id='read_mrs'>Read MRS data from a file.</h2><span id='topic+read_mrs'></span>

<h3>Description</h3>

<p>Read MRS data from a file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_mrs(
  fname,
  format = NULL,
  ft = NULL,
  fs = NULL,
  ref = NULL,
  n_ref_scans = NULL,
  full_fid = FALSE,
  omit_svs_ref_scans = TRUE,
  verbose = FALSE,
  extra = NULL,
  fid_filt_dist = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_mrs_+3A_fname">fname</code></td>
<td>
<p>filename of the dpt format MRS data.</p>
</td></tr>
<tr><td><code id="read_mrs_+3A_format">format</code></td>
<td>
<p>string describing the data format. Must be one of the
following : &quot;spar_sdat&quot;, &quot;rda&quot;, &quot;dicom&quot;, &quot;twix&quot;, &quot;pfile&quot;, &quot;list_data&quot;,
&quot;paravis&quot;, &quot;dpt&quot;, &quot;lcm_raw&quot;, &quot;rds&quot;, &quot;nifti&quot;, &quot;varian&quot;, &quot;jmrui_txt&quot;. If not
specified, the format will be guessed from the filename extension.</p>
</td></tr>
<tr><td><code id="read_mrs_+3A_ft">ft</code></td>
<td>
<p>transmitter frequency in Hz (required for list_data format).</p>
</td></tr>
<tr><td><code id="read_mrs_+3A_fs">fs</code></td>
<td>
<p>sampling frequency in Hz (required for list_data format).</p>
</td></tr>
<tr><td><code id="read_mrs_+3A_ref">ref</code></td>
<td>
<p>reference value for ppm scale (required for list_data format).</p>
</td></tr>
<tr><td><code id="read_mrs_+3A_n_ref_scans">n_ref_scans</code></td>
<td>
<p>override the number of water reference scans detected in
the file header (GE p-file only).</p>
</td></tr>
<tr><td><code id="read_mrs_+3A_full_fid">full_fid</code></td>
<td>
<p>export all data points, including those before the start
of the FID (default = FALSE), TWIX format only.</p>
</td></tr>
<tr><td><code id="read_mrs_+3A_omit_svs_ref_scans">omit_svs_ref_scans</code></td>
<td>
<p>remove any reference scans sometimes saved in
SVS twix data (default = TRUE).</p>
</td></tr>
<tr><td><code id="read_mrs_+3A_verbose">verbose</code></td>
<td>
<p>print data file information (default = FALSE).</p>
</td></tr>
<tr><td><code id="read_mrs_+3A_extra">extra</code></td>
<td>
<p>an optional data frame to provide additional variables for use
in subsequent analysis steps, eg id or grouping variables.</p>
</td></tr>
<tr><td><code id="read_mrs_+3A_fid_filt_dist">fid_filt_dist</code></td>
<td>
<p>indicate if the data has a distorted FID due to a
brick-wall filter being used to downsample the data. Default is to auto
detect this from the data, but TRUE or FALSE options can be given to override
detection.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>MRS data object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fname &lt;- system.file("extdata", "philips_spar_sdat_WS.SDAT", package = "spant")
mrs_data &lt;- read_mrs(fname)
print(mrs_data)
</code></pre>

<hr>
<h2 id='read_mrs_tqn'>Read MRS data using the TARQUIN software package.</h2><span id='topic+read_mrs_tqn'></span>

<h3>Description</h3>

<p>Read MRS data using the TARQUIN software package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_mrs_tqn(fname, fname_ref = NA, format, id = NA, group = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_mrs_tqn_+3A_fname">fname</code></td>
<td>
<p>the filename containing the MRS data.</p>
</td></tr>
<tr><td><code id="read_mrs_tqn_+3A_fname_ref">fname_ref</code></td>
<td>
<p>a second filename containing reference MRS data.</p>
</td></tr>
<tr><td><code id="read_mrs_tqn_+3A_format">format</code></td>
<td>
<p>format of the MRS data. Can be one of the following:
siemens, philips, ge, dcm, dpt, rda, lcm, varian, bruker, jmrui_txt.</p>
</td></tr>
<tr><td><code id="read_mrs_tqn_+3A_id">id</code></td>
<td>
<p>optional ID string.</p>
</td></tr>
<tr><td><code id="read_mrs_tqn_+3A_group">group</code></td>
<td>
<p>optional group string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>MRS data object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fname &lt;- system.file("extdata","philips_spar_sdat_WS.SDAT",package="spant")
## Not run: 
mrs_data &lt;- read_mrs_tqn(fname, format="philips")

## End(Not run)
</code></pre>

<hr>
<h2 id='read_pulse_ascii'>Read an ASCII formatted pulse file.</h2><span id='topic+read_pulse_ascii'></span>

<h3>Description</h3>

<p>Read an ASCII formatted pulse file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_pulse_ascii(fname, deg2rad = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_pulse_ascii_+3A_fname">fname</code></td>
<td>
<p>ASCII formatted pulse file path.</p>
</td></tr>
<tr><td><code id="read_pulse_ascii_+3A_deg2rad">deg2rad</code></td>
<td>
<p>convert phase values stored in degrees to radians.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>pulse waveform and header.
</p>

<hr>
<h2 id='read_pulse_bruker'>Read a Bruker formatted pulse file</h2><span id='topic+read_pulse_bruker'></span>

<h3>Description</h3>

<p>Read a Bruker formatted pulse file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_pulse_bruker(fname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_pulse_bruker_+3A_fname">fname</code></td>
<td>
<p>Bruker formatted pulse file path.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>pulse waveform and header.
</p>

<hr>
<h2 id='read_pulse_pta'>Read a .pta formatted pulse file compatible with Siemens PulseTool.</h2><span id='topic+read_pulse_pta'></span>

<h3>Description</h3>

<p>Read a .pta formatted pulse file compatible with Siemens PulseTool.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_pulse_pta(fname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_pulse_pta_+3A_fname">fname</code></td>
<td>
<p>pta formatted pulse file path.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>pulse waveform and header.
</p>

<hr>
<h2 id='read_siemens_txt_hdr'>Read the text format header found in Siemens IMA and TWIX data files.</h2><span id='topic+read_siemens_txt_hdr'></span>

<h3>Description</h3>

<p>Read the text format header found in Siemens IMA and TWIX data files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_siemens_txt_hdr(input, version = "vd", verbose = FALSE, offset = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_siemens_txt_hdr_+3A_input">input</code></td>
<td>
<p>file name to read or raw data.</p>
</td></tr>
<tr><td><code id="read_siemens_txt_hdr_+3A_version">version</code></td>
<td>
<p>software version, can be &quot;vb&quot; or &quot;vd&quot;.</p>
</td></tr>
<tr><td><code id="read_siemens_txt_hdr_+3A_verbose">verbose</code></td>
<td>
<p>print information to the console.</p>
</td></tr>
<tr><td><code id="read_siemens_txt_hdr_+3A_offset">offset</code></td>
<td>
<p>offset to begin searching for the text header.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of parameter values
</p>

<hr>
<h2 id='read_tqn_fit'>Reader for csv fit results generated by TARQUIN.</h2><span id='topic+read_tqn_fit'></span>

<h3>Description</h3>

<p>Reader for csv fit results generated by TARQUIN.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_tqn_fit(fit_f)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_tqn_fit_+3A_fit_f">fit_f</code></td>
<td>
<p>TARQUIN fit file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of the fit data points.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fit &lt;- read_tqn_fit(system.file("extdata","fit.csv",package="spant"))

## End(Not run)
</code></pre>

<hr>
<h2 id='read_tqn_result'>Reader for csv results generated by TARQUIN.</h2><span id='topic+read_tqn_result'></span>

<h3>Description</h3>

<p>Reader for csv results generated by TARQUIN.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_tqn_result(result_f, remove_rcs = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read_tqn_result_+3A_result_f">result_f</code></td>
<td>
<p>TARQUIN result file.</p>
</td></tr>
<tr><td><code id="read_tqn_result_+3A_remove_rcs">remove_rcs</code></td>
<td>
<p>omit row, column and slice ids from output.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of amplitudes, crlbs and diagnostics.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
result &lt;- read_tqn_result(system.file("extdata","result.csv",package="spant"))

## End(Not run)
</code></pre>

<hr>
<h2 id='recon_imag'>Reconstruct complex time-domain data from the real part of frequency-domain
data.</h2><span id='topic+recon_imag'></span>

<h3>Description</h3>

<p>Reconstruct complex time-domain data from the real part of frequency-domain
data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recon_imag(mrs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recon_imag_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>reconstructed MRS data.
</p>

<hr>
<h2 id='recon_imag_vec'>Reconstruct complex time-domain data from the real part of frequency-domain
data.</h2><span id='topic+recon_imag_vec'></span>

<h3>Description</h3>

<p>Reconstruct complex time-domain data from the real part of frequency-domain
data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recon_imag_vec(data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recon_imag_vec_+3A_data">data</code></td>
<td>
<p>data points in the frequency domain.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>reconstructed signal.
</p>

<hr>
<h2 id='recon_twix_2d_mrsi'>Reconstruct 2D MRSI data from a twix file loaded with read_mrs.</h2><span id='topic+recon_twix_2d_mrsi'></span>

<h3>Description</h3>

<p>Reconstruct 2D MRSI data from a twix file loaded with read_mrs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recon_twix_2d_mrsi(twix_mrs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recon_twix_2d_mrsi_+3A_twix_mrs">twix_mrs</code></td>
<td>
<p>raw dynamic data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>reconstructed data.
</p>

<hr>
<h2 id='rectangular_mask'>Create a rectangular mask stored as a matrix of logical values.</h2><span id='topic+rectangular_mask'></span>

<h3>Description</h3>

<p>Create a rectangular mask stored as a matrix of logical values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rectangular_mask(xN, yN, x0, y0, xw, yw, angle)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rectangular_mask_+3A_xn">xN</code></td>
<td>
<p>number of pixels in the x dimension.</p>
</td></tr>
<tr><td><code id="rectangular_mask_+3A_yn">yN</code></td>
<td>
<p>number of pixels in the y dimension.</p>
</td></tr>
<tr><td><code id="rectangular_mask_+3A_x0">x0</code></td>
<td>
<p>centre of rectangle in the x direction in units of pixels.</p>
</td></tr>
<tr><td><code id="rectangular_mask_+3A_y0">y0</code></td>
<td>
<p>centre of rectangle in the y direction in units of pixels.</p>
</td></tr>
<tr><td><code id="rectangular_mask_+3A_xw">xw</code></td>
<td>
<p>width in the x direction in units of pixels.</p>
</td></tr>
<tr><td><code id="rectangular_mask_+3A_yw">yw</code></td>
<td>
<p>width in the y direction in units of pixels.</p>
</td></tr>
<tr><td><code id="rectangular_mask_+3A_angle">angle</code></td>
<td>
<p>angle of rotation in degrees.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical mask matrix with dimensions fov_yN x fov_xN.
</p>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+readNifti'></span><span id='topic+writeNifti'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>RNifti</dt><dd><p><code><a href="RNifti.html#topic+readNifti">readNifti</a></code>, <code><a href="RNifti.html#topic+writeNifti">writeNifti</a></code></p>
</dd>
</dl>

<hr>
<h2 id='rep_array_dim'>Repeat an array over a given dimension.</h2><span id='topic+rep_array_dim'></span>

<h3>Description</h3>

<p>Repeat an array over a given dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rep_array_dim(x, rep_dim, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rep_array_dim_+3A_x">x</code></td>
<td>
<p>array.</p>
</td></tr>
<tr><td><code id="rep_array_dim_+3A_rep_dim">rep_dim</code></td>
<td>
<p>dimension to extend.</p>
</td></tr>
<tr><td><code id="rep_array_dim_+3A_n">n</code></td>
<td>
<p>number of times to repeat.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>extended array.
</p>

<hr>
<h2 id='rep_dyn'>Replicate a scan in the dynamic dimension.</h2><span id='topic+rep_dyn'></span>

<h3>Description</h3>

<p>Replicate a scan in the dynamic dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rep_dyn(mrs_data, times)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rep_dyn_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data to be replicated.</p>
</td></tr>
<tr><td><code id="rep_dyn_+3A_times">times</code></td>
<td>
<p>number of times to replicate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>replicated data object.
</p>

<hr>
<h2 id='rep_mrs'>Replicate a scan over a given dimension.</h2><span id='topic+rep_mrs'></span>

<h3>Description</h3>

<p>Replicate a scan over a given dimension.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rep_mrs(
  mrs_data,
  x_rep = 1,
  y_rep = 1,
  z_rep = 1,
  dyn_rep = 1,
  coil_rep = 1,
  warn = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rep_mrs_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data to be replicated.</p>
</td></tr>
<tr><td><code id="rep_mrs_+3A_x_rep">x_rep</code></td>
<td>
<p>number of x replications.</p>
</td></tr>
<tr><td><code id="rep_mrs_+3A_y_rep">y_rep</code></td>
<td>
<p>number of y replications.</p>
</td></tr>
<tr><td><code id="rep_mrs_+3A_z_rep">z_rep</code></td>
<td>
<p>number of z replications.</p>
</td></tr>
<tr><td><code id="rep_mrs_+3A_dyn_rep">dyn_rep</code></td>
<td>
<p>number of dynamic replications.</p>
</td></tr>
<tr><td><code id="rep_mrs_+3A_coil_rep">coil_rep</code></td>
<td>
<p>number of coil replications.</p>
</td></tr>
<tr><td><code id="rep_mrs_+3A_warn">warn</code></td>
<td>
<p>print a warning when the data dimensions do not change.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>replicated data object.
</p>

<hr>
<h2 id='resample_basis'>Resample a basis-set to match a mrs_data acquisition.</h2><span id='topic+resample_basis'></span>

<h3>Description</h3>

<p>Resample a basis-set to match a mrs_data acquisition.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample_basis(basis, mrs_data, ref_freq_match = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_basis_+3A_basis">basis</code></td>
<td>
<p>the basis to be resampled.</p>
</td></tr>
<tr><td><code id="resample_basis_+3A_mrs_data">mrs_data</code></td>
<td>
<p>the mrs_data to match the number of data points and sampling
frequency.</p>
</td></tr>
<tr><td><code id="resample_basis_+3A_ref_freq_match">ref_freq_match</code></td>
<td>
<p>apply a frequency shift to the basis to match the
reference frequency (usually 4.65 or 4.68) of the mrs_data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>resampled basis set object.
</p>

<hr>
<h2 id='resample_img'>Resample an image to match a target image space.</h2><span id='topic+resample_img'></span>

<h3>Description</h3>

<p>Resample an image to match a target image space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample_img(source, target, interp = 3L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_img_+3A_source">source</code></td>
<td>
<p>image data as a nifti object.</p>
</td></tr>
<tr><td><code id="resample_img_+3A_target">target</code></td>
<td>
<p>image data as a nifti object.</p>
</td></tr>
<tr><td><code id="resample_img_+3A_interp">interp</code></td>
<td>
<p>interpolation parameter, see nifyreg.linear definition.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>resampled image data as a nifti object.
</p>

<hr>
<h2 id='resample_voi'>Resample a VOI to match a target image space using nearest-neighbour
interpolation.</h2><span id='topic+resample_voi'></span>

<h3>Description</h3>

<p>Resample a VOI to match a target image space using nearest-neighbour
interpolation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>resample_voi(voi, mri)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="resample_voi_+3A_voi">voi</code></td>
<td>
<p>volume data as a nifti object.</p>
</td></tr>
<tr><td><code id="resample_voi_+3A_mri">mri</code></td>
<td>
<p>image data as a nifti object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>volume data as a nifti object.
</p>

<hr>
<h2 id='reslice_to_mrs'>Reslice a nifti object to match the orientation of mrs data.</h2><span id='topic+reslice_to_mrs'></span>

<h3>Description</h3>

<p>Reslice a nifti object to match the orientation of mrs data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reslice_to_mrs(mri, mrs, interp = 3L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reslice_to_mrs_+3A_mri">mri</code></td>
<td>
<p>nifti object to be resliced.</p>
</td></tr>
<tr><td><code id="reslice_to_mrs_+3A_mrs">mrs</code></td>
<td>
<p>mrs_data object for the target orientation.</p>
</td></tr>
<tr><td><code id="reslice_to_mrs_+3A_interp">interp</code></td>
<td>
<p>interpolation parameter, see nifyreg.linear definition.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>resliced imaging data.
</p>

<hr>
<h2 id='reson_table2mrs_data'>Generate mrs_data from a table of single Lorentzian resonances.</h2><span id='topic+reson_table2mrs_data'></span>

<h3>Description</h3>

<p>Generate mrs_data from a table of single Lorentzian resonances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reson_table2mrs_data(
  reson_table,
  acq_paras = def_acq_paras(),
  back_extrap_pts = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reson_table2mrs_data_+3A_reson_table">reson_table</code></td>
<td>
<p>as produced by the hsvd function.</p>
</td></tr>
<tr><td><code id="reson_table2mrs_data_+3A_acq_paras">acq_paras</code></td>
<td>
<p>list of acquisition parameters. See</p>
</td></tr>
<tr><td><code id="reson_table2mrs_data_+3A_back_extrap_pts">back_extrap_pts</code></td>
<td>
<p>number of data points to back extrapolate
<code><a href="#topic+def_acq_paras">def_acq_paras</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>mrs_data object.
</p>

<hr>
<h2 id='rm_dyns'>Remove a subset of dynamic scans.</h2><span id='topic+rm_dyns'></span>

<h3>Description</h3>

<p>Remove a subset of dynamic scans.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rm_dyns(mrs_data, subset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rm_dyns_+3A_mrs_data">mrs_data</code></td>
<td>
<p>dynamic MRS data.</p>
</td></tr>
<tr><td><code id="rm_dyns_+3A_subset">subset</code></td>
<td>
<p>vector containing indices to the dynamic scans to be
removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>MRS data without the specified dynamic scans.
</p>

<hr>
<h2 id='scale_amp_molal'>Apply water reference scaling to a fitting results object to yield metabolite
quantities in millimolar (mM) units (mol / kg of tissue water).</h2><span id='topic+scale_amp_molal'></span>

<h3>Description</h3>

<p>Note, this function assumes the volume contains a homogeneous voxel, eg pure
WM, GM or  CSF. Also note that in the case of a homogeneous voxel the
relative densities of MR-visible water (eg GM=0.78, WM=0.65, and CSF=0.97)
cancel out and don't need to be considered. Use scale_amp_molal_pvc for
volumes containing  multiple compartments. Details of this method can be
found in &quot;Use of tissue water as a concentration reference for proton
spectroscopic imaging&quot; by Gasparovic et al MRM 2006 55(6):1219-26.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_amp_molal(
  fit_result,
  ref_data,
  te,
  tr,
  water_t1,
  water_t2,
  metab_t1,
  metab_t2,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_amp_molal_+3A_fit_result">fit_result</code></td>
<td>
<p>result object generated from fitting.</p>
</td></tr>
<tr><td><code id="scale_amp_molal_+3A_ref_data">ref_data</code></td>
<td>
<p>water reference MRS data object.</p>
</td></tr>
<tr><td><code id="scale_amp_molal_+3A_te">te</code></td>
<td>
<p>the MRS TE in seconds.</p>
</td></tr>
<tr><td><code id="scale_amp_molal_+3A_tr">tr</code></td>
<td>
<p>the MRS TR in seconds.</p>
</td></tr>
<tr><td><code id="scale_amp_molal_+3A_water_t1">water_t1</code></td>
<td>
<p>assumed water T1 value.</p>
</td></tr>
<tr><td><code id="scale_amp_molal_+3A_water_t2">water_t2</code></td>
<td>
<p>assumed water T2 value.</p>
</td></tr>
<tr><td><code id="scale_amp_molal_+3A_metab_t1">metab_t1</code></td>
<td>
<p>assumed metabolite T1 value.</p>
</td></tr>
<tr><td><code id="scale_amp_molal_+3A_metab_t2">metab_t2</code></td>
<td>
<p>assumed metabolite T2 value.</p>
</td></tr>
<tr><td><code id="scale_amp_molal_+3A_...">...</code></td>
<td>
<p>additional arguments to get_td_amp function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>fit_result</code> object with a rescaled results table.
</p>

<hr>
<h2 id='scale_amp_molal_pvc'>Apply water reference scaling to a fitting results object to yield metabolite
quantities in millimolar (mM) units (mol / kg of tissue water).</h2><span id='topic+scale_amp_molal_pvc'></span>

<h3>Description</h3>

<p>Details of this method can be found in &quot;Use of tissue water as a
concentration reference for proton spectroscopic imaging&quot; by Gasparovic et al
MRM 2006 55(6):1219-26. 1.5 Tesla relaxation assumptions are taken from this
paper. For 3 Tesla data, relaxation assumptions are taken from &quot;NMR
relaxation times in the human brain at 3.0 Tesla&quot; by Wansapura et al J Magn
Reson Imaging 1999 9(4):531-8.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_amp_molal_pvc(fit_result, ref_data, p_vols, te, tr, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_amp_molal_pvc_+3A_fit_result">fit_result</code></td>
<td>
<p>result object generated from fitting.</p>
</td></tr>
<tr><td><code id="scale_amp_molal_pvc_+3A_ref_data">ref_data</code></td>
<td>
<p>water reference MRS data object.</p>
</td></tr>
<tr><td><code id="scale_amp_molal_pvc_+3A_p_vols">p_vols</code></td>
<td>
<p>a numeric vector of partial volumes expressed as percentages.
For example, a voxel containing 100% white matter tissue would use :
p_vols = c(WM = 100, GM = 0, CSF = 0).</p>
</td></tr>
<tr><td><code id="scale_amp_molal_pvc_+3A_te">te</code></td>
<td>
<p>the MRS TE in seconds.</p>
</td></tr>
<tr><td><code id="scale_amp_molal_pvc_+3A_tr">tr</code></td>
<td>
<p>the MRS TR in seconds.</p>
</td></tr>
<tr><td><code id="scale_amp_molal_pvc_+3A_...">...</code></td>
<td>
<p>additional arguments to get_td_amp function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>fit_result</code> object with a rescaled results table.
</p>

<hr>
<h2 id='scale_amp_molar'>Apply water reference scaling to a fitting results object to yield metabolite
quantities in millimolar (mM) units (mol / Litre of tissue).</h2><span id='topic+scale_amp_molar'></span>

<h3>Description</h3>

<p>See the LCModel manual (section 10.2) on water-scaling for details on the
assumptions and relevant references. Use this type of concentration scaling
to compare fit results with LCModel and TARQUIN defaults. Otherwise
scale_amp_molal_pvc is generally the preferred method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_amp_molar(fit_result, ref_data, w_att = 0.7, w_conc = 35880, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_amp_molar_+3A_fit_result">fit_result</code></td>
<td>
<p>a result object generated from fitting.</p>
</td></tr>
<tr><td><code id="scale_amp_molar_+3A_ref_data">ref_data</code></td>
<td>
<p>water reference MRS data object.</p>
</td></tr>
<tr><td><code id="scale_amp_molar_+3A_w_att">w_att</code></td>
<td>
<p>water attenuation factor (default = 0.7). Assumes water T2 of
80ms and a TE = 30 ms. exp(-30ms / 80ms) ~ 0.7.</p>
</td></tr>
<tr><td><code id="scale_amp_molar_+3A_w_conc">w_conc</code></td>
<td>
<p>assumed water concentration (default = 35880). Default value
corresponds to typical white matter. Set to 43300 for gray matter, and 55556
for phantom measurements.</p>
</td></tr>
<tr><td><code id="scale_amp_molar_+3A_...">...</code></td>
<td>
<p>additional arguments to get_td_amp function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>fit_result</code> object with a rescaled results table.
</p>

<hr>
<h2 id='scale_amp_molar2molal_pvc'>Convert default LCM/TARQUIN concentration scaling to molal units with partial
volume correction.</h2><span id='topic+scale_amp_molar2molal_pvc'></span>

<h3>Description</h3>

<p>Convert default LCM/TARQUIN concentration scaling to molal units with partial
volume correction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_amp_molar2molal_pvc(fit_result, p_vols, te, tr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_amp_molar2molal_pvc_+3A_fit_result">fit_result</code></td>
<td>
<p>a <code>fit_result</code> object to apply partial volume
correction.</p>
</td></tr>
<tr><td><code id="scale_amp_molar2molal_pvc_+3A_p_vols">p_vols</code></td>
<td>
<p>a numeric vector of partial volumes expressed as percentages.
For example, a voxel containing 100% white matter tissue would use :
p_vols = c(WM = 100, GM = 0, CSF = 0).</p>
</td></tr>
<tr><td><code id="scale_amp_molar2molal_pvc_+3A_te">te</code></td>
<td>
<p>the MRS TE.</p>
</td></tr>
<tr><td><code id="scale_amp_molar2molal_pvc_+3A_tr">tr</code></td>
<td>
<p>the MRS TR.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>fit_result</code> object with a rescaled results table.
</p>

<hr>
<h2 id='scale_amp_ratio'>Scale fitted amplitudes to a ratio of signal amplitude.</h2><span id='topic+scale_amp_ratio'></span>

<h3>Description</h3>

<p>Scale fitted amplitudes to a ratio of signal amplitude.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_amp_ratio(fit_result, name, use_mean_value = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_amp_ratio_+3A_fit_result">fit_result</code></td>
<td>
<p>a result object generated from fitting.</p>
</td></tr>
<tr><td><code id="scale_amp_ratio_+3A_name">name</code></td>
<td>
<p>the signal name to use as a denominator (usually, &quot;tCr&quot; or
&quot;tNAA&quot;).</p>
</td></tr>
<tr><td><code id="scale_amp_ratio_+3A_use_mean_value">use_mean_value</code></td>
<td>
<p>scales the result by the mean of the signal when set to
TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>fit_result</code> object with a rescaled results table.
</p>

<hr>
<h2 id='scale_amp_ratio_value'>Scale fitted amplitudes to a ratio of signal amplitude.</h2><span id='topic+scale_amp_ratio_value'></span>

<h3>Description</h3>

<p>Scale fitted amplitudes to a ratio of signal amplitude.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_amp_ratio_value(fit_result, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_amp_ratio_value_+3A_fit_result">fit_result</code></td>
<td>
<p>a result object generated from fitting.</p>
</td></tr>
<tr><td><code id="scale_amp_ratio_value_+3A_value">value</code></td>
<td>
<p>the number use as a denominator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>fit_result</code> object with a rescaled results table.
</p>

<hr>
<h2 id='scale_amp_water_ratio'>Scale metabolite amplitudes as a ratio to the unsuppressed water amplitude.</h2><span id='topic+scale_amp_water_ratio'></span>

<h3>Description</h3>

<p>Scale metabolite amplitudes as a ratio to the unsuppressed water amplitude.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_amp_water_ratio(fit_result, ref_data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_amp_water_ratio_+3A_fit_result">fit_result</code></td>
<td>
<p>a result object generated from fitting.</p>
</td></tr>
<tr><td><code id="scale_amp_water_ratio_+3A_ref_data">ref_data</code></td>
<td>
<p>a water reference MRS data object.</p>
</td></tr>
<tr><td><code id="scale_amp_water_ratio_+3A_...">...</code></td>
<td>
<p>additional arguments to get_td_amp function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>fit_result</code> object with a rescaled results table.
</p>

<hr>
<h2 id='scale_basis_amp'>Scale a basis object by a scalar.</h2><span id='topic+scale_basis_amp'></span>

<h3>Description</h3>

<p>Scale a basis object by a scalar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_basis_amp(basis, amp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_basis_amp_+3A_basis">basis</code></td>
<td>
<p>basis_set object to be scaled.</p>
</td></tr>
<tr><td><code id="scale_basis_amp_+3A_amp">amp</code></td>
<td>
<p>multiplicative factor with length 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>basis_set object multiplied by the amplitude scale factor.
</p>

<hr>
<h2 id='scale_basis_from_singlet'>Scale a basis-set to be consistent with spant assumptions for water scaling.</h2><span id='topic+scale_basis_from_singlet'></span>

<h3>Description</h3>

<p>For correct water scaling, spant assumes the time-domain amplitude (t = 0)
for a single proton is 0.5. Internally simulated basis-sets will be correctly
scaled, however imported basis-sets should be assumed to be un-scaled and
this function should be used. Note that the singlet specified should only
contain one resonance, and that any additional signals (eg TSP or residual
water) will result in incorrect scaling. Therefore, only simulated basis sets
are appropriate for use with this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_basis_from_singlet(basis, name, protons)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_basis_from_singlet_+3A_basis">basis</code></td>
<td>
<p>basis set to be scaled.</p>
</td></tr>
<tr><td><code id="scale_basis_from_singlet_+3A_name">name</code></td>
<td>
<p>the name of the singlet to be used as a scaling reference.</p>
</td></tr>
<tr><td><code id="scale_basis_from_singlet_+3A_protons">protons</code></td>
<td>
<p>the number of MRS visible protons contributing to the singlet
resonance.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a scaled basis.
</p>

<hr>
<h2 id='scale_mrs_amp'>Scale an mrs_data object by a scalar or vector or amplitudes.</h2><span id='topic+scale_mrs_amp'></span>

<h3>Description</h3>

<p>Scale an mrs_data object by a scalar or vector or amplitudes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_mrs_amp(mrs_data, amp)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_mrs_amp_+3A_mrs_data">mrs_data</code></td>
<td>
<p>data to be scaled.</p>
</td></tr>
<tr><td><code id="scale_mrs_amp_+3A_amp">amp</code></td>
<td>
<p>multiplicative factor, must have length equal to 1 or
Nspec(mrs_data).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mrs_data object multiplied by the amplitude scale factor.
</p>

<hr>
<h2 id='scale_spec'>Scale mrs_data to a spectral region.</h2><span id='topic+scale_spec'></span>

<h3>Description</h3>

<p>Scale mrs_data to a spectral region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale_spec(
  mrs_data,
  xlim = NULL,
  operator = "sum",
  freq_scale = "ppm",
  mode = "re",
  mean_dyns = NULL,
  ret_scale_factor = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale_spec_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
<tr><td><code id="scale_spec_+3A_xlim">xlim</code></td>
<td>
<p>spectral range to be integrated (defaults to full range).</p>
</td></tr>
<tr><td><code id="scale_spec_+3A_operator">operator</code></td>
<td>
<p>can be &quot;sum&quot; (default), &quot;mean&quot;, &quot;l2&quot;, &quot;max&quot;, &quot;min&quot; or
&quot;max-min&quot;.</p>
</td></tr>
<tr><td><code id="scale_spec_+3A_freq_scale">freq_scale</code></td>
<td>
<p>units of xlim, can be : &quot;ppm&quot;, &quot;Hz&quot; or &quot;points&quot;.</p>
</td></tr>
<tr><td><code id="scale_spec_+3A_mode">mode</code></td>
<td>
<p>spectral mode, can be : &quot;re&quot;, &quot;im&quot;, &quot;mod&quot; or &quot;cplx&quot;.</p>
</td></tr>
<tr><td><code id="scale_spec_+3A_mean_dyns">mean_dyns</code></td>
<td>
<p>mean the dynamic scans before applying the operator. The
same scaling value will be applied to each individual dynamic.</p>
</td></tr>
<tr><td><code id="scale_spec_+3A_ret_scale_factor">ret_scale_factor</code></td>
<td>
<p>option to return the scaling factor in addition to
the scaled data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>normalised data.
</p>

<hr>
<h2 id='sd'>Calculate the standard deviation spectrum from an mrs_data object.</h2><span id='topic+sd'></span>

<h3>Description</h3>

<p>Calculate the standard deviation spectrum from an mrs_data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd(x, na.rm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sd_+3A_x">x</code></td>
<td>
<p>object of class mrs_data.</p>
</td></tr>
<tr><td><code id="sd_+3A_na.rm">na.rm</code></td>
<td>
<p>remove NA values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sd mrs_data object.
</p>

<hr>
<h2 id='sd.mrs_data'>Calculate the standard deviation spectrum from an mrs_data object.</h2><span id='topic+sd.mrs_data'></span>

<h3>Description</h3>

<p>Calculate the standard deviation spectrum from an mrs_data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mrs_data'
sd(x, na.rm = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sd.mrs_data_+3A_x">x</code></td>
<td>
<p>object of class mrs_data.</p>
</td></tr>
<tr><td><code id="sd.mrs_data_+3A_na.rm">na.rm</code></td>
<td>
<p>remove NA values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sd mrs_data object.
</p>

<hr>
<h2 id='seconds'>Return a time scale vector to match the FID of an MRS data object.</h2><span id='topic+seconds'></span>

<h3>Description</h3>

<p>Return a time scale vector to match the FID of an MRS data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seconds(mrs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seconds_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>time scale vector in units of seconds.
</p>

<hr>
<h2 id='seq_cpmg_ideal'>CPMG style sequence with ideal pulses.</h2><span id='topic+seq_cpmg_ideal'></span>

<h3>Description</h3>

<p>CPMG style sequence with ideal pulses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_cpmg_ideal(spin_params, ft, ref, TE = 0.03, echoes = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_cpmg_ideal_+3A_spin_params">spin_params</code></td>
<td>
<p>spin system definition.</p>
</td></tr>
<tr><td><code id="seq_cpmg_ideal_+3A_ft">ft</code></td>
<td>
<p>transmitter frequency in Hz.</p>
</td></tr>
<tr><td><code id="seq_cpmg_ideal_+3A_ref">ref</code></td>
<td>
<p>reference value for ppm scale.</p>
</td></tr>
<tr><td><code id="seq_cpmg_ideal_+3A_te">TE</code></td>
<td>
<p>echo time in seconds.</p>
</td></tr>
<tr><td><code id="seq_cpmg_ideal_+3A_echoes">echoes</code></td>
<td>
<p>number of echoes.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of resonance amplitudes and frequencies.
</p>

<hr>
<h2 id='seq_mega_press_ideal'>MEGA-PRESS sequence with ideal localisation pulses and Gaussian shaped
editing pulse.</h2><span id='topic+seq_mega_press_ideal'></span>

<h3>Description</h3>

<p>MEGA-PRESS sequence with ideal localisation pulses and Gaussian shaped
editing pulse.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_mega_press_ideal(
  spin_params,
  ft,
  ref,
  ed_freq = 1.89,
  TE1 = 0.015,
  TE2 = 0.053,
  BW = 110,
  steps = 50
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_mega_press_ideal_+3A_spin_params">spin_params</code></td>
<td>
<p>spin system definition.</p>
</td></tr>
<tr><td><code id="seq_mega_press_ideal_+3A_ft">ft</code></td>
<td>
<p>transmitter frequency in Hz.</p>
</td></tr>
<tr><td><code id="seq_mega_press_ideal_+3A_ref">ref</code></td>
<td>
<p>reference value for ppm scale.</p>
</td></tr>
<tr><td><code id="seq_mega_press_ideal_+3A_ed_freq">ed_freq</code></td>
<td>
<p>editing pulse frequency in ppm.</p>
</td></tr>
<tr><td><code id="seq_mega_press_ideal_+3A_te1">TE1</code></td>
<td>
<p>TE1 sequence parameter in seconds (TE=TE1+TE2).</p>
</td></tr>
<tr><td><code id="seq_mega_press_ideal_+3A_te2">TE2</code></td>
<td>
<p>TE2 sequence parameter in seconds.</p>
</td></tr>
<tr><td><code id="seq_mega_press_ideal_+3A_bw">BW</code></td>
<td>
<p>editing pulse bandwidth in Hz.</p>
</td></tr>
<tr><td><code id="seq_mega_press_ideal_+3A_steps">steps</code></td>
<td>
<p>number of hard pulses used to approximate the editing pulse.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of resonance amplitudes and frequencies.
</p>

<hr>
<h2 id='seq_press_2d_shaped'>PRESS sequence with shaped refocusing pulses.</h2><span id='topic+seq_press_2d_shaped'></span>

<h3>Description</h3>

<p>PRESS sequence with shaped refocusing pulses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_press_2d_shaped(
  spin_params,
  ft,
  ref,
  TE1 = 0.01,
  TE2 = 0.02,
  pulse_file,
  pulse_dur,
  pulse_file_format,
  refoc_flip_angle = 180,
  xy_pulse_ppm = NULL,
  resamp = TRUE,
  fs_resamp = 1e-04
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_press_2d_shaped_+3A_spin_params">spin_params</code></td>
<td>
<p>spin system definition.</p>
</td></tr>
<tr><td><code id="seq_press_2d_shaped_+3A_ft">ft</code></td>
<td>
<p>transmitter frequency in Hz.</p>
</td></tr>
<tr><td><code id="seq_press_2d_shaped_+3A_ref">ref</code></td>
<td>
<p>reference value for ppm scale.</p>
</td></tr>
<tr><td><code id="seq_press_2d_shaped_+3A_te1">TE1</code></td>
<td>
<p>TE1 sequence parameter in seconds (TE=TE1+TE2).</p>
</td></tr>
<tr><td><code id="seq_press_2d_shaped_+3A_te2">TE2</code></td>
<td>
<p>TE2 sequence parameter in seconds.</p>
</td></tr>
<tr><td><code id="seq_press_2d_shaped_+3A_pulse_file">pulse_file</code></td>
<td>
<p>path to refocusing pulse file.</p>
</td></tr>
<tr><td><code id="seq_press_2d_shaped_+3A_pulse_dur">pulse_dur</code></td>
<td>
<p>refocusing pulse duration.</p>
</td></tr>
<tr><td><code id="seq_press_2d_shaped_+3A_pulse_file_format">pulse_file_format</code></td>
<td>
<p>file format for the refocusing pulse.</p>
</td></tr>
<tr><td><code id="seq_press_2d_shaped_+3A_refoc_flip_angle">refoc_flip_angle</code></td>
<td>
<p>refocusing pulse flip angle in degrees (defaults to
180).</p>
</td></tr>
<tr><td><code id="seq_press_2d_shaped_+3A_xy_pulse_ppm">xy_pulse_ppm</code></td>
<td>
<p>a vector of ppm values for the offset of each
sub-simulation.</p>
</td></tr>
<tr><td><code id="seq_press_2d_shaped_+3A_resamp">resamp</code></td>
<td>
<p>option to resample the pulse shape.</p>
</td></tr>
<tr><td><code id="seq_press_2d_shaped_+3A_fs_resamp">fs_resamp</code></td>
<td>
<p>sampling frequency (Hz) to resample.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of resonance amplitudes and frequencies.
</p>

<hr>
<h2 id='seq_press_ideal'>PRESS sequence with ideal pulses.</h2><span id='topic+seq_press_ideal'></span>

<h3>Description</h3>

<p>PRESS sequence with ideal pulses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_press_ideal(spin_params, ft, ref, TE1 = 0.01, TE2 = 0.02)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_press_ideal_+3A_spin_params">spin_params</code></td>
<td>
<p>spin system definition.</p>
</td></tr>
<tr><td><code id="seq_press_ideal_+3A_ft">ft</code></td>
<td>
<p>transmitter frequency in Hz.</p>
</td></tr>
<tr><td><code id="seq_press_ideal_+3A_ref">ref</code></td>
<td>
<p>reference value for ppm scale.</p>
</td></tr>
<tr><td><code id="seq_press_ideal_+3A_te1">TE1</code></td>
<td>
<p>TE1 sequence parameter in seconds (TE=TE1+TE2).</p>
</td></tr>
<tr><td><code id="seq_press_ideal_+3A_te2">TE2</code></td>
<td>
<p>TE2 sequence parameter in seconds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of resonance amplitudes and frequencies.
</p>

<hr>
<h2 id='seq_pulse_acquire'>Simple pulse and acquire sequence with ideal pulses.</h2><span id='topic+seq_pulse_acquire'></span>

<h3>Description</h3>

<p>Simple pulse and acquire sequence with ideal pulses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_pulse_acquire(spin_params, ft, ref, nuc = "1H", acq_delay = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_pulse_acquire_+3A_spin_params">spin_params</code></td>
<td>
<p>spin system definition.</p>
</td></tr>
<tr><td><code id="seq_pulse_acquire_+3A_ft">ft</code></td>
<td>
<p>transmitter frequency in Hz.</p>
</td></tr>
<tr><td><code id="seq_pulse_acquire_+3A_ref">ref</code></td>
<td>
<p>reference value for ppm scale.</p>
</td></tr>
<tr><td><code id="seq_pulse_acquire_+3A_nuc">nuc</code></td>
<td>
<p>acquisition nucleus.</p>
</td></tr>
<tr><td><code id="seq_pulse_acquire_+3A_acq_delay">acq_delay</code></td>
<td>
<p>delay between excitation and acquisition.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of resonance amplitudes and frequencies.
</p>

<hr>
<h2 id='seq_slaser_ideal'>sLASER sequence with ideal pulses.</h2><span id='topic+seq_slaser_ideal'></span>

<h3>Description</h3>

<p>sLASER sequence with ideal pulses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_slaser_ideal(spin_params, ft, ref, TE1 = 0.008, TE2 = 0.011, TE3 = 0.009)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_slaser_ideal_+3A_spin_params">spin_params</code></td>
<td>
<p>spin system definition.</p>
</td></tr>
<tr><td><code id="seq_slaser_ideal_+3A_ft">ft</code></td>
<td>
<p>transmitter frequency in Hz.</p>
</td></tr>
<tr><td><code id="seq_slaser_ideal_+3A_ref">ref</code></td>
<td>
<p>reference value for ppm scale.</p>
</td></tr>
<tr><td><code id="seq_slaser_ideal_+3A_te1">TE1</code></td>
<td>
<p>first echo time (between exc. and 1st echo) in seconds.</p>
</td></tr>
<tr><td><code id="seq_slaser_ideal_+3A_te2">TE2</code></td>
<td>
<p>second echo time (between 2nd echo and 4th echo) in seconds.</p>
</td></tr>
<tr><td><code id="seq_slaser_ideal_+3A_te3">TE3</code></td>
<td>
<p>third echo time (between 4th echo and 5th echo) in seconds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of resonance amplitudes and frequencies.
</p>

<hr>
<h2 id='seq_spin_echo_ideal'>Spin echo sequence with ideal pulses.</h2><span id='topic+seq_spin_echo_ideal'></span>

<h3>Description</h3>

<p>Spin echo sequence with ideal pulses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_spin_echo_ideal(spin_params, ft, ref, nuc = "1H", TE = 0.03)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_spin_echo_ideal_+3A_spin_params">spin_params</code></td>
<td>
<p>spin system definition.</p>
</td></tr>
<tr><td><code id="seq_spin_echo_ideal_+3A_ft">ft</code></td>
<td>
<p>transmitter frequency in Hz.</p>
</td></tr>
<tr><td><code id="seq_spin_echo_ideal_+3A_ref">ref</code></td>
<td>
<p>reference value for ppm scale.</p>
</td></tr>
<tr><td><code id="seq_spin_echo_ideal_+3A_nuc">nuc</code></td>
<td>
<p>acquisition nucleus.</p>
</td></tr>
<tr><td><code id="seq_spin_echo_ideal_+3A_te">TE</code></td>
<td>
<p>echo time in seconds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of resonance amplitudes and frequencies.
</p>

<hr>
<h2 id='seq_steam_ideal'>STEAM sequence with ideal pulses.</h2><span id='topic+seq_steam_ideal'></span>

<h3>Description</h3>

<p>STEAM sequence with ideal pulses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_steam_ideal(spin_params, ft, ref, TE = 0.03, TM = 0.02, amp_scale = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_steam_ideal_+3A_spin_params">spin_params</code></td>
<td>
<p>spin system definition.</p>
</td></tr>
<tr><td><code id="seq_steam_ideal_+3A_ft">ft</code></td>
<td>
<p>transmitter frequency in Hz.</p>
</td></tr>
<tr><td><code id="seq_steam_ideal_+3A_ref">ref</code></td>
<td>
<p>reference value for ppm scale.</p>
</td></tr>
<tr><td><code id="seq_steam_ideal_+3A_te">TE</code></td>
<td>
<p>sequence parameter in seconds.</p>
</td></tr>
<tr><td><code id="seq_steam_ideal_+3A_tm">TM</code></td>
<td>
<p>sequence parameter in seconds.</p>
</td></tr>
<tr><td><code id="seq_steam_ideal_+3A_amp_scale">amp_scale</code></td>
<td>
<p>amplitude scaling factor. Set to 2 (default) to ensure
correct scaling for water reference scaling. Set to 1 to maintain the
inherent loss of signal associated with STEAM.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of resonance amplitudes and frequencies.
</p>

<hr>
<h2 id='seq_steam_ideal_cof'>STEAM sequence with ideal pulses and coherence order filtering to simulate
gradient crushers.</h2><span id='topic+seq_steam_ideal_cof'></span>

<h3>Description</h3>

<p>See Landheer et al NMR Biomed 2021 34(5):e4129 and Landheer et al MRM 2019
Apr;81(4):2209-2222 for more details on the coherence order filtering method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_steam_ideal_cof(spin_params, ft, ref, TE = 0.03, TM = 0.02, amp_scale = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_steam_ideal_cof_+3A_spin_params">spin_params</code></td>
<td>
<p>spin system definition.</p>
</td></tr>
<tr><td><code id="seq_steam_ideal_cof_+3A_ft">ft</code></td>
<td>
<p>transmitter frequency in Hz.</p>
</td></tr>
<tr><td><code id="seq_steam_ideal_cof_+3A_ref">ref</code></td>
<td>
<p>reference value for ppm scale.</p>
</td></tr>
<tr><td><code id="seq_steam_ideal_cof_+3A_te">TE</code></td>
<td>
<p>sequence parameter in seconds.</p>
</td></tr>
<tr><td><code id="seq_steam_ideal_cof_+3A_tm">TM</code></td>
<td>
<p>sequence parameter in seconds.</p>
</td></tr>
<tr><td><code id="seq_steam_ideal_cof_+3A_amp_scale">amp_scale</code></td>
<td>
<p>amplitude scaling factor. Set to 2 (default) to ensure
correct scaling for water reference scaling. Set to 1 to maintain the
inherent loss of signal associated with STEAM.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of resonance amplitudes and frequencies.
</p>

<hr>
<h2 id='seq_steam_ideal_young'>STEAM sequence with ideal pulses using the z-rotation gradient simulation
method described by Young et al JMR 140, 146-152 (1999).</h2><span id='topic+seq_steam_ideal_young'></span>

<h3>Description</h3>

<p>STEAM sequence with ideal pulses using the z-rotation gradient simulation
method described by Young et al JMR 140, 146-152 (1999).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_steam_ideal_young(
  spin_params,
  ft,
  ref,
  TE = 0.03,
  TM = 0.02,
  amp_scale = 2
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="seq_steam_ideal_young_+3A_spin_params">spin_params</code></td>
<td>
<p>spin system definition.</p>
</td></tr>
<tr><td><code id="seq_steam_ideal_young_+3A_ft">ft</code></td>
<td>
<p>transmitter frequency in Hz.</p>
</td></tr>
<tr><td><code id="seq_steam_ideal_young_+3A_ref">ref</code></td>
<td>
<p>reference value for ppm scale.</p>
</td></tr>
<tr><td><code id="seq_steam_ideal_young_+3A_te">TE</code></td>
<td>
<p>sequence parameter in seconds.</p>
</td></tr>
<tr><td><code id="seq_steam_ideal_young_+3A_tm">TM</code></td>
<td>
<p>sequence parameter in seconds.</p>
</td></tr>
<tr><td><code id="seq_steam_ideal_young_+3A_amp_scale">amp_scale</code></td>
<td>
<p>amplitude scaling factor. Set to 2 (default) to ensure
correct scaling for water reference scaling. Set to 1 to maintain the
inherent loss of signal associated with STEAM.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of resonance amplitudes and frequencies.
</p>

<hr>
<h2 id='set_def_acq_paras'>Set the default acquisition parameters.</h2><span id='topic+set_def_acq_paras'></span>

<h3>Description</h3>

<p>Set the default acquisition parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_def_acq_paras(
  ft = getOption("spant.def_ft"),
  fs = getOption("spant.def_fs"),
  N = getOption("spant.def_N"),
  ref = getOption("spant.def_ref"),
  nuc = getOption("spant.nuc")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_def_acq_paras_+3A_ft">ft</code></td>
<td>
<p>transmitter frequency in Hz.</p>
</td></tr>
<tr><td><code id="set_def_acq_paras_+3A_fs">fs</code></td>
<td>
<p>sampling frequency in Hz.</p>
</td></tr>
<tr><td><code id="set_def_acq_paras_+3A_n">N</code></td>
<td>
<p>number of data points in the spectral dimension.</p>
</td></tr>
<tr><td><code id="set_def_acq_paras_+3A_ref">ref</code></td>
<td>
<p>reference value for ppm scale.</p>
</td></tr>
<tr><td><code id="set_def_acq_paras_+3A_nuc">nuc</code></td>
<td>
<p>resonant nucleus.</p>
</td></tr>
</table>

<hr>
<h2 id='set_lcm_cmd'>Set the command to run the LCModel command-line program.</h2><span id='topic+set_lcm_cmd'></span>

<h3>Description</h3>

<p>Set the command to run the LCModel command-line program.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_lcm_cmd(cmd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_lcm_cmd_+3A_cmd">cmd</code></td>
<td>
<p>path to binary.</p>
</td></tr>
</table>

<hr>
<h2 id='set_lw'>Apply line-broadening to an mrs_data object to achieve a specified linewidth.</h2><span id='topic+set_lw'></span>

<h3>Description</h3>

<p>Apply line-broadening to an mrs_data object to achieve a specified linewidth.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_lw(mrs_data, lw, xlim = c(4, 0.5), lg = 1, mask_narrow = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_lw_+3A_mrs_data">mrs_data</code></td>
<td>
<p>data in.</p>
</td></tr>
<tr><td><code id="set_lw_+3A_lw">lw</code></td>
<td>
<p>target linewidth in units of ppm.</p>
</td></tr>
<tr><td><code id="set_lw_+3A_xlim">xlim</code></td>
<td>
<p>region to search for peaks to obtain a linewidth estimate.</p>
</td></tr>
<tr><td><code id="set_lw_+3A_lg">lg</code></td>
<td>
<p>Lorentz-Gauss lineshape parameter.</p>
</td></tr>
<tr><td><code id="set_lw_+3A_mask_narrow">mask_narrow</code></td>
<td>
<p>masks spectra where the requested linewidth is too narrow,
if set FALSE the spectra are not changed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>line-broadened data.
</p>

<hr>
<h2 id='set_mask_xy_mat'>Set the masked voxels in a 2D MRSI dataset to given spectrum.</h2><span id='topic+set_mask_xy_mat'></span>

<h3>Description</h3>

<p>Set the masked voxels in a 2D MRSI dataset to given spectrum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_mask_xy_mat(mrs_data, mask, mask_mrs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_mask_xy_mat_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRSI data object.</p>
</td></tr>
<tr><td><code id="set_mask_xy_mat_+3A_mask">mask</code></td>
<td>
<p>matrix of boolean values specifying the voxels to set, where a
value of TRUE indicates the voxel should be set to mask_mrs_data.</p>
</td></tr>
<tr><td><code id="set_mask_xy_mat_+3A_mask_mrs_data">mask_mrs_data</code></td>
<td>
<p>the spectral data to be assigned to the masked voxels.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>updated dataset.
</p>

<hr>
<h2 id='set_Ntrans'>Set the number of transients for an mrs_data object.</h2><span id='topic+set_Ntrans'></span>

<h3>Description</h3>

<p>Set the number of transients for an mrs_data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_Ntrans(mrs_data, n_trans)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_Ntrans_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
<tr><td><code id="set_Ntrans_+3A_n_trans">n_trans</code></td>
<td>
<p>number of acquired transients.</p>
</td></tr>
</table>

<hr>
<h2 id='set_precomp_mode'>Set the precompute mode.</h2><span id='topic+set_precomp_mode'></span>

<h3>Description</h3>

<p>Set the precompute mode.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_precomp_mode(mode = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_precomp_mode_+3A_mode">mode</code></td>
<td>
<p>can be one of: &quot;default&quot;, &quot;overwrite&quot;, &quot;clean&quot; or &quot;disabled&quot;.</p>
</td></tr>
</table>

<hr>
<h2 id='set_precomp_verbose'>Set the verbosity of the precompute function.</h2><span id='topic+set_precomp_verbose'></span>

<h3>Description</h3>

<p>Set the verbosity of the precompute function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_precomp_verbose(verbose = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_precomp_verbose_+3A_verbose">verbose</code></td>
<td>
<p>can be TRUE or FALSE.</p>
</td></tr>
</table>

<hr>
<h2 id='set_ref'>Set the ppm reference value (eg ppm value at 0Hz).</h2><span id='topic+set_ref'></span>

<h3>Description</h3>

<p>Set the ppm reference value (eg ppm value at 0Hz).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_ref(mrs_data, ref)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_ref_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
<tr><td><code id="set_ref_+3A_ref">ref</code></td>
<td>
<p>reference value for ppm scale.</p>
</td></tr>
</table>

<hr>
<h2 id='set_td_pts'>Set the number of time-domain data points, truncating or zero-filling as
appropriate.</h2><span id='topic+set_td_pts'></span>

<h3>Description</h3>

<p>Set the number of time-domain data points, truncating or zero-filling as
appropriate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_td_pts(mrs_data, pts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_td_pts_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
<tr><td><code id="set_td_pts_+3A_pts">pts</code></td>
<td>
<p>number of data points.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>MRS data with pts data points.
</p>

<hr>
<h2 id='set_tqn_cmd'>Set the command to run the TARQUIN command-line program.</h2><span id='topic+set_tqn_cmd'></span>

<h3>Description</h3>

<p>Set the command to run the TARQUIN command-line program.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_tqn_cmd(cmd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_tqn_cmd_+3A_cmd">cmd</code></td>
<td>
<p>path to binary.</p>
</td></tr>
</table>

<hr>
<h2 id='set_tr'>Set the repetition time of an MRS dataset.</h2><span id='topic+set_tr'></span>

<h3>Description</h3>

<p>Set the repetition time of an MRS dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_tr(mrs_data, tr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_tr_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
<tr><td><code id="set_tr_+3A_tr">tr</code></td>
<td>
<p>repetition time in seconds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>updated mrs_data set.
</p>

<hr>
<h2 id='shift'>Apply a frequency shift to MRS data.</h2><span id='topic+shift'></span>

<h3>Description</h3>

<p>Apply a frequency shift to MRS data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shift(mrs_data, shift, units = "ppm")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shift_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
<tr><td><code id="shift_+3A_shift">shift</code></td>
<td>
<p>frequency shift (in ppm by default).</p>
</td></tr>
<tr><td><code id="shift_+3A_units">units</code></td>
<td>
<p>of the shift (&quot;ppm&quot; or &quot;hz&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>frequency shifted MRS data.
</p>

<hr>
<h2 id='shift_basis'>Apply frequency shifts to basis set signals.</h2><span id='topic+shift_basis'></span>

<h3>Description</h3>

<p>Apply frequency shifts to basis set signals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shift_basis(basis, shifts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shift_basis_+3A_basis">basis</code></td>
<td>
<p>the basis to apply the shift to.</p>
</td></tr>
<tr><td><code id="shift_basis_+3A_shifts">shifts</code></td>
<td>
<p>a vector of frequency shifts to apply in ppm units. Must be the
same length as there are basis elements, or one value to be applied to all
elements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>modified basis set object.
</p>

<hr>
<h2 id='sim_basis'>Simulate a basis set object.</h2><span id='topic+sim_basis'></span>

<h3>Description</h3>

<p>Simulate a basis set object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_basis(
  mol_list,
  pul_seq = seq_pulse_acquire,
  acq_paras = def_acq_paras(),
  xlim = NULL,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_basis_+3A_mol_list">mol_list</code></td>
<td>
<p>list of <code>mol_parameter</code> objects. Alternatively, a
character vector matching molecules may also be provided. Use the
get_mol_names function for a full list of molecules.</p>
</td></tr>
<tr><td><code id="sim_basis_+3A_pul_seq">pul_seq</code></td>
<td>
<p>pulse sequence function to use.</p>
</td></tr>
<tr><td><code id="sim_basis_+3A_acq_paras">acq_paras</code></td>
<td>
<p>list of acquisition parameters or an mrs_data object. See
<code><a href="#topic+def_acq_paras">def_acq_paras</a></code></p>
</td></tr>
<tr><td><code id="sim_basis_+3A_xlim">xlim</code></td>
<td>
<p>ppm range limiting signals to be simulated.</p>
</td></tr>
<tr><td><code id="sim_basis_+3A_verbose">verbose</code></td>
<td>
<p>output simulation progress and timings.</p>
</td></tr>
<tr><td><code id="sim_basis_+3A_...">...</code></td>
<td>
<p>extra parameters to pass to the pulse sequence function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>basis object.
</p>

<hr>
<h2 id='sim_basis_1h_brain'>Simulate a basis-set suitable for 1H brain MRS analysis acquired with a PRESS
sequence. Note, ideal pulses are assumed.</h2><span id='topic+sim_basis_1h_brain'></span>

<h3>Description</h3>

<p>Simulate a basis-set suitable for 1H brain MRS analysis acquired with a PRESS
sequence. Note, ideal pulses are assumed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_basis_1h_brain(
  pul_seq = seq_press_ideal,
  acq_paras = def_acq_paras(),
  xlim = c(0.5, 4.2),
  lcm_compat = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_basis_1h_brain_+3A_pul_seq">pul_seq</code></td>
<td>
<p>pulse sequence function to use.</p>
</td></tr>
<tr><td><code id="sim_basis_1h_brain_+3A_acq_paras">acq_paras</code></td>
<td>
<p>list of acquisition parameters or an mrs_data object. See
<code><a href="#topic+def_acq_paras">def_acq_paras</a></code>.</p>
</td></tr>
<tr><td><code id="sim_basis_1h_brain_+3A_xlim">xlim</code></td>
<td>
<p>range of frequencies to simulate in ppm.</p>
</td></tr>
<tr><td><code id="sim_basis_1h_brain_+3A_lcm_compat">lcm_compat</code></td>
<td>
<p>exclude lipid and MM signals for use with default LCModel
options.</p>
</td></tr>
<tr><td><code id="sim_basis_1h_brain_+3A_...">...</code></td>
<td>
<p>extra parameters to pass to the pulse sequence function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>basis object.
</p>

<hr>
<h2 id='sim_basis_1h_brain_press'>Simulate a basis-set suitable for 1H brain MRS analysis acquired with a PRESS
sequence. Note, ideal pulses are assumed.</h2><span id='topic+sim_basis_1h_brain_press'></span>

<h3>Description</h3>

<p>Simulate a basis-set suitable for 1H brain MRS analysis acquired with a PRESS
sequence. Note, ideal pulses are assumed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_basis_1h_brain_press(
  acq_paras = def_acq_paras(),
  xlim = c(0.5, 4.2),
  lcm_compat = FALSE,
  TE1 = 0.01,
  TE2 = 0.02
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_basis_1h_brain_press_+3A_acq_paras">acq_paras</code></td>
<td>
<p>list of acquisition parameters or an mrs_data object. See
<code><a href="#topic+def_acq_paras">def_acq_paras</a></code></p>
</td></tr>
<tr><td><code id="sim_basis_1h_brain_press_+3A_xlim">xlim</code></td>
<td>
<p>range of frequencies to simulate in ppm.</p>
</td></tr>
<tr><td><code id="sim_basis_1h_brain_press_+3A_lcm_compat">lcm_compat</code></td>
<td>
<p>exclude lipid and MM signals for use with default LCModel
options.</p>
</td></tr>
<tr><td><code id="sim_basis_1h_brain_press_+3A_te1">TE1</code></td>
<td>
<p>TE1 of PRESS sequence (TE = TE1 + TE2).</p>
</td></tr>
<tr><td><code id="sim_basis_1h_brain_press_+3A_te2">TE2</code></td>
<td>
<p>TE2 of PRESS sequence.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>basis object.
</p>

<hr>
<h2 id='sim_basis_mm_lip_lcm'>Simulate a macromolecular and lipid basis-set suitable for 1H brain MRS
analysis.</h2><span id='topic+sim_basis_mm_lip_lcm'></span>

<h3>Description</h3>

<p>Simulate a macromolecular and lipid basis-set suitable for 1H brain MRS
analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_basis_mm_lip_lcm(acq_paras = def_acq_paras())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_basis_mm_lip_lcm_+3A_acq_paras">acq_paras</code></td>
<td>
<p>list of acquisition parameters or an mrs_data object. See
<code><a href="#topic+def_acq_paras">def_acq_paras</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>basis object.
</p>

<hr>
<h2 id='sim_basis_tqn'>Simulate a basis file using TARQUIN.</h2><span id='topic+sim_basis_tqn'></span>

<h3>Description</h3>

<p>Simulate a basis file using TARQUIN.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_basis_tqn(
  fs = def_fs(),
  ft = def_ft(),
  N = def_N(),
  ref = def_ref(),
  opts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_basis_tqn_+3A_fs">fs</code></td>
<td>
<p>sampling frequency</p>
</td></tr>
<tr><td><code id="sim_basis_tqn_+3A_ft">ft</code></td>
<td>
<p>transmitter frequency</p>
</td></tr>
<tr><td><code id="sim_basis_tqn_+3A_n">N</code></td>
<td>
<p>number of data points</p>
</td></tr>
<tr><td><code id="sim_basis_tqn_+3A_ref">ref</code></td>
<td>
<p>chemical shift reference</p>
</td></tr>
<tr><td><code id="sim_basis_tqn_+3A_opts">opts</code></td>
<td>
<p>list of options to pass to TARQUIN.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
write_basis_tqn('test.basis',mrs_data,c("--echo","0.04"))

## End(Not run)
</code></pre>

<hr>
<h2 id='sim_brain_1h'>Simulate MRS data with a similar appearance to normal brain (by default).</h2><span id='topic+sim_brain_1h'></span>

<h3>Description</h3>

<p>Simulate MRS data with a similar appearance to normal brain (by default).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_brain_1h(
  acq_paras = def_acq_paras(),
  type = "normal_v2",
  pul_seq = seq_slaser_ideal,
  xlim = c(0.5, 4.2),
  full_output = FALSE,
  amps = NULL,
  basis_lb = NULL,
  zero_lip_mm = FALSE,
  remove_lip_mm = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_brain_1h_+3A_acq_paras">acq_paras</code></td>
<td>
<p>list of acquisition parameters or an mrs_data object. See
<code><a href="#topic+def_acq_paras">def_acq_paras</a></code>.</p>
</td></tr>
<tr><td><code id="sim_brain_1h_+3A_type">type</code></td>
<td>
<p>type of spectrum, only &quot;normal&quot; is implemented currently.</p>
</td></tr>
<tr><td><code id="sim_brain_1h_+3A_pul_seq">pul_seq</code></td>
<td>
<p>pulse sequence function to use.</p>
</td></tr>
<tr><td><code id="sim_brain_1h_+3A_xlim">xlim</code></td>
<td>
<p>range of frequencies to simulate in ppm.</p>
</td></tr>
<tr><td><code id="sim_brain_1h_+3A_full_output">full_output</code></td>
<td>
<p>when FALSE (default) only output the simulated MRS data.
When TRUE output a list containing the MRS data, basis set object and
corresponding amplitudes.</p>
</td></tr>
<tr><td><code id="sim_brain_1h_+3A_amps">amps</code></td>
<td>
<p>a vector of basis amplitudes may be specified to modify the
output spectrum.</p>
</td></tr>
<tr><td><code id="sim_brain_1h_+3A_basis_lb">basis_lb</code></td>
<td>
<p>apply additional Gaussian line-broadening to the basis (Hz).</p>
</td></tr>
<tr><td><code id="sim_brain_1h_+3A_zero_lip_mm">zero_lip_mm</code></td>
<td>
<p>zero the amplitudes of any lipid or macromolecular
components based on their name starting with &quot;MM&quot; or &quot;Lip&quot;.</p>
</td></tr>
<tr><td><code id="sim_brain_1h_+3A_remove_lip_mm">remove_lip_mm</code></td>
<td>
<p>remove any lipid or macromolecular basis components
based on their name starting with &quot;MM&quot; or &quot;Lip&quot;.</p>
</td></tr>
<tr><td><code id="sim_brain_1h_+3A_...">...</code></td>
<td>
<p>extra parameters to pass to the pulse sequence function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>see full_output option.
</p>

<hr>
<h2 id='sim_mol'>Simulate a <code>mol_parameter</code> object.</h2><span id='topic+sim_mol'></span>

<h3>Description</h3>

<p>Simulate a <code>mol_parameter</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_mol(
  mol,
  pul_seq = seq_pulse_acquire,
  ft = def_ft(),
  ref = def_ref(),
  fs = def_fs(),
  N = def_N(),
  xlim = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_mol_+3A_mol">mol</code></td>
<td>
<p><code>mol_parameter</code> object.</p>
</td></tr>
<tr><td><code id="sim_mol_+3A_pul_seq">pul_seq</code></td>
<td>
<p>pulse sequence function to use.</p>
</td></tr>
<tr><td><code id="sim_mol_+3A_ft">ft</code></td>
<td>
<p>transmitter frequency in Hz.</p>
</td></tr>
<tr><td><code id="sim_mol_+3A_ref">ref</code></td>
<td>
<p>reference value for ppm scale.</p>
</td></tr>
<tr><td><code id="sim_mol_+3A_fs">fs</code></td>
<td>
<p>sampling frequency in Hz.</p>
</td></tr>
<tr><td><code id="sim_mol_+3A_n">N</code></td>
<td>
<p>number of data points in the spectral dimension.</p>
</td></tr>
<tr><td><code id="sim_mol_+3A_xlim">xlim</code></td>
<td>
<p>ppm range limiting signals to be simulated.</p>
</td></tr>
<tr><td><code id="sim_mol_+3A_...">...</code></td>
<td>
<p>extra parameters to pass to the pulse sequence function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>mrs_data</code> object.
</p>

<hr>
<h2 id='sim_noise'>Simulate an mrs_data object containing simulated Gaussian noise.</h2><span id='topic+sim_noise'></span>

<h3>Description</h3>

<p>Simulate an mrs_data object containing simulated Gaussian noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_noise(
  sd = 0.1,
  fs = def_fs(),
  ft = def_ft(),
  N = def_N(),
  ref = def_ref(),
  nuc = def_nuc(),
  dyns = 1,
  fd = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_noise_+3A_sd">sd</code></td>
<td>
<p>standard deviation of the noise.</p>
</td></tr>
<tr><td><code id="sim_noise_+3A_fs">fs</code></td>
<td>
<p>sampling frequency in Hz.</p>
</td></tr>
<tr><td><code id="sim_noise_+3A_ft">ft</code></td>
<td>
<p>transmitter frequency in Hz.</p>
</td></tr>
<tr><td><code id="sim_noise_+3A_n">N</code></td>
<td>
<p>number of data points in the spectral dimension.</p>
</td></tr>
<tr><td><code id="sim_noise_+3A_ref">ref</code></td>
<td>
<p>reference value for ppm scale.</p>
</td></tr>
<tr><td><code id="sim_noise_+3A_nuc">nuc</code></td>
<td>
<p>resonant nucleus.</p>
</td></tr>
<tr><td><code id="sim_noise_+3A_dyns">dyns</code></td>
<td>
<p>number of dynamic scans to generate.</p>
</td></tr>
<tr><td><code id="sim_noise_+3A_fd">fd</code></td>
<td>
<p>return data in the frequency-domain (TRUE) or time-domain (FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mrs_data object.
</p>

<hr>
<h2 id='sim_resonances'>Simulate a MRS data object containing a set of simulated resonances.</h2><span id='topic+sim_resonances'></span>

<h3>Description</h3>

<p>Simulate a MRS data object containing a set of simulated resonances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_resonances(
  freq = 0,
  amp = 1,
  lw = 0,
  lg = 0,
  phase = 0,
  freq_ppm = TRUE,
  acq_paras = def_acq_paras(),
  fp_scale = TRUE,
  back_extrap_pts = 0,
  sum_resonances = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_resonances_+3A_freq">freq</code></td>
<td>
<p>resonance frequency.</p>
</td></tr>
<tr><td><code id="sim_resonances_+3A_amp">amp</code></td>
<td>
<p>resonance amplitude.</p>
</td></tr>
<tr><td><code id="sim_resonances_+3A_lw">lw</code></td>
<td>
<p>line width in Hz.</p>
</td></tr>
<tr><td><code id="sim_resonances_+3A_lg">lg</code></td>
<td>
<p>Lorentz-Gauss lineshape parameter (between 0 and 1).</p>
</td></tr>
<tr><td><code id="sim_resonances_+3A_phase">phase</code></td>
<td>
<p>phase in degrees.</p>
</td></tr>
<tr><td><code id="sim_resonances_+3A_freq_ppm">freq_ppm</code></td>
<td>
<p>frequencies are given in ppm units if set to TRUE, otherwise
Hz are assumed.</p>
</td></tr>
<tr><td><code id="sim_resonances_+3A_acq_paras">acq_paras</code></td>
<td>
<p>list of acquisition parameters. See
<code><a href="#topic+def_acq_paras">def_acq_paras</a></code></p>
</td></tr>
<tr><td><code id="sim_resonances_+3A_fp_scale">fp_scale</code></td>
<td>
<p>multiply the first data point by 0.5.</p>
</td></tr>
<tr><td><code id="sim_resonances_+3A_back_extrap_pts">back_extrap_pts</code></td>
<td>
<p>number of data points to back extrapolate.</p>
</td></tr>
<tr><td><code id="sim_resonances_+3A_sum_resonances">sum_resonances</code></td>
<td>
<p>sum all resonances (default is TRUE), otherwise return
a dynamic mrs_data object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>MRS data object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>sim_data &lt;- sim_resonances(freq = 2, lw = 5)
</code></pre>

<hr>
<h2 id='sim_th_excit_profile'>Simulate an ideal pulse excitation profile by smoothing a top-hat function
with a Gaussian.</h2><span id='topic+sim_th_excit_profile'></span>

<h3>Description</h3>

<p>Simulate an ideal pulse excitation profile by smoothing a top-hat function
with a Gaussian.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_th_excit_profile(bw = 1500, sigma = 50, fa = 180)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_th_excit_profile_+3A_bw">bw</code></td>
<td>
<p>top-hat bandwidth (Hz).</p>
</td></tr>
<tr><td><code id="sim_th_excit_profile_+3A_sigma">sigma</code></td>
<td>
<p>Gaussian width smoothing parameter (Hz).</p>
</td></tr>
<tr><td><code id="sim_th_excit_profile_+3A_fa">fa</code></td>
<td>
<p>intended flip angle of the pulse.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame containing the frequency scale, excitation profile and
corresponding flip-angles.
</p>

<hr>
<h2 id='sim_zero'>Simulate an mrs_data object containing complex zero valued samples.</h2><span id='topic+sim_zero'></span>

<h3>Description</h3>

<p>Simulate an mrs_data object containing complex zero valued samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_zero(
  fs = def_fs(),
  ft = def_ft(),
  N = def_N(),
  ref = def_ref(),
  nuc = def_nuc(),
  dyns = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_zero_+3A_fs">fs</code></td>
<td>
<p>sampling frequency in Hz.</p>
</td></tr>
<tr><td><code id="sim_zero_+3A_ft">ft</code></td>
<td>
<p>transmitter frequency in Hz.</p>
</td></tr>
<tr><td><code id="sim_zero_+3A_n">N</code></td>
<td>
<p>number of data points in the spectral dimension.</p>
</td></tr>
<tr><td><code id="sim_zero_+3A_ref">ref</code></td>
<td>
<p>reference value for ppm scale.</p>
</td></tr>
<tr><td><code id="sim_zero_+3A_nuc">nuc</code></td>
<td>
<p>resonant nucleus.</p>
</td></tr>
<tr><td><code id="sim_zero_+3A_dyns">dyns</code></td>
<td>
<p>number of dynamic scans to generate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mrs_data object.
</p>

<hr>
<h2 id='smooth_dyns'>Smooth data across the dynamic dimension with a Gaussian kernel.</h2><span id='topic+smooth_dyns'></span>

<h3>Description</h3>

<p>Smooth data across the dynamic dimension with a Gaussian kernel.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_dyns(mrs_data, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_dyns_+3A_mrs_data">mrs_data</code></td>
<td>
<p>data to be smoothed.</p>
</td></tr>
<tr><td><code id="smooth_dyns_+3A_sigma">sigma</code></td>
<td>
<p>standard deviation of the underlying Gaussian kernel in seconds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>smoothed mrs_data object.
</p>

<hr>
<h2 id='sort_basis'>Sort the basis-set elements alphabetically.</h2><span id='topic+sort_basis'></span>

<h3>Description</h3>

<p>Sort the basis-set elements alphabetically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sort_basis(basis)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sort_basis_+3A_basis">basis</code></td>
<td>
<p>input basis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sorted basis.
</p>

<hr>
<h2 id='spant_abfit_benchmark'>Simulate and fit some spectra with ABfit for benchmarking purposes. Basic
timing and performance metrics will be printed.</h2><span id='topic+spant_abfit_benchmark'></span>

<h3>Description</h3>

<p>Simulate and fit some spectra with ABfit for benchmarking purposes. Basic
timing and performance metrics will be printed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spant_abfit_benchmark(noise_reps = 10, return_res = FALSE, opts = abfit_opts())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spant_abfit_benchmark_+3A_noise_reps">noise_reps</code></td>
<td>
<p>number of spectra to fit with differing noise samples.</p>
</td></tr>
<tr><td><code id="spant_abfit_benchmark_+3A_return_res">return_res</code></td>
<td>
<p>return a list of fit_result objects.</p>
</td></tr>
<tr><td><code id="spant_abfit_benchmark_+3A_opts">opts</code></td>
<td>
<p>ABfit options structure.</p>
</td></tr>
</table>

<hr>
<h2 id='spant_mpress_drift'>Example MEGA-PRESS data with significant B0 drift.</h2><span id='topic+spant_mpress_drift'></span>

<h3>Description</h3>

<p>Example MEGA-PRESS data with significant B0 drift.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spant_mpress_drift
</code></pre>


<h3>Format</h3>

<p>An object of class <code>mrs_data</code> of dimension 1 x 1 x 1 x 1 x 40 x 1 x 1024.
</p>

<hr>
<h2 id='spant_sim_fmrs_dataset'>Simulate an example fMRS dataset for a block design fMRS experiment and
export a BIDS structure.</h2><span id='topic+spant_sim_fmrs_dataset'></span>

<h3>Description</h3>

<p>Simulate an example fMRS dataset for a block design fMRS experiment and
export a BIDS structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spant_sim_fmrs_dataset(output_dir = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spant_sim_fmrs_dataset_+3A_output_dir">output_dir</code></td>
<td>
<p>output directory for the BIDS data. Defaults to :
&quot;HOME/sim_fmrs_dataset/data&quot;.</p>
</td></tr>
</table>

<hr>
<h2 id='spant_simulation_benchmark'>Simulate a typical metabolite basis set for benchmarking. Timing metrics will
be printed on completion.</h2><span id='topic+spant_simulation_benchmark'></span>

<h3>Description</h3>

<p>Simulate a typical metabolite basis set for benchmarking. Timing metrics will
be printed on completion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spant_simulation_benchmark(sim_reps = 10, N = 1024)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spant_simulation_benchmark_+3A_sim_reps">sim_reps</code></td>
<td>
<p>number of times to simulate the basis set.</p>
</td></tr>
<tr><td><code id="spant_simulation_benchmark_+3A_n">N</code></td>
<td>
<p>number of FID data points to simulate.</p>
</td></tr>
</table>

<hr>
<h2 id='spec_decomp'>Decompose an mrs_data object into white and gray matter spectra.</h2><span id='topic+spec_decomp'></span>

<h3>Description</h3>

<p>An implementation of the method published by Goryawala et al MRM 79(6)
2886-2895 (2018). &quot;Spectral decomposition for resolving partial volume
effects in MRSI&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spec_decomp(mrs_data, wm, gm, norm_fractions = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spec_decomp_+3A_mrs_data">mrs_data</code></td>
<td>
<p>data to be decomposed into white and gray matter spectra.</p>
</td></tr>
<tr><td><code id="spec_decomp_+3A_wm">wm</code></td>
<td>
<p>vector of white matter contributions to each voxel.</p>
</td></tr>
<tr><td><code id="spec_decomp_+3A_gm">gm</code></td>
<td>
<p>vector of gray matter contributions to each voxel.</p>
</td></tr>
<tr><td><code id="spec_decomp_+3A_norm_fractions">norm_fractions</code></td>
<td>
<p>option to normalise the wm, gm vectors for each voxel.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of two mrs_data objects corresponding to the two tissue types.
</p>

<hr>
<h2 id='spec_op'>Perform a mathematical operation on a spectral region.</h2><span id='topic+spec_op'></span>

<h3>Description</h3>

<p>Perform a mathematical operation on a spectral region.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spec_op(
  mrs_data,
  xlim = NULL,
  operator = "sum",
  freq_scale = "ppm",
  mode = "re"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spec_op_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
<tr><td><code id="spec_op_+3A_xlim">xlim</code></td>
<td>
<p>spectral range to be integrated (defaults to full range).</p>
</td></tr>
<tr><td><code id="spec_op_+3A_operator">operator</code></td>
<td>
<p>can be &quot;sum&quot; (default), &quot;mean&quot;, &quot;l2&quot;, &quot;max&quot;, &quot;max_cplx,
&quot;min&quot; or &quot;max-min&quot;.</p>
</td></tr>
<tr><td><code id="spec_op_+3A_freq_scale">freq_scale</code></td>
<td>
<p>units of xlim, can be : &quot;ppm&quot;, &quot;hz&quot; or &quot;points&quot;.</p>
</td></tr>
<tr><td><code id="spec_op_+3A_mode">mode</code></td>
<td>
<p>spectral mode, can be : &quot;re&quot;, &quot;im&quot;, &quot;mod&quot; or &quot;cplx&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an array of integral values.
</p>

<hr>
<h2 id='spin_sys'>Create a spin system object for pulse sequence simulation.</h2><span id='topic+spin_sys'></span>

<h3>Description</h3>

<p>Create a spin system object for pulse sequence simulation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spin_sys(spin_params, ft, ref, precomp_jc_H = NULL, precomp_Iz = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spin_sys_+3A_spin_params">spin_params</code></td>
<td>
<p>an object describing the spin system properties.</p>
</td></tr>
<tr><td><code id="spin_sys_+3A_ft">ft</code></td>
<td>
<p>transmitter frequency in Hz.</p>
</td></tr>
<tr><td><code id="spin_sys_+3A_ref">ref</code></td>
<td>
<p>reference value for ppm scale.</p>
</td></tr>
<tr><td><code id="spin_sys_+3A_precomp_jc_h">precomp_jc_H</code></td>
<td>
<p>use a precomputed J-coupling H matrix to save time.</p>
</td></tr>
<tr><td><code id="spin_sys_+3A_precomp_iz">precomp_Iz</code></td>
<td>
<p>use precomputed Iz matrices to save time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>spin system object.
</p>

<hr>
<h2 id='spm_pve2categorical'>Convert SPM style segmentation files to a single categorical image where
the numerical values map as: 0) Other, 1) CSF, 2) GM and 3) WM.</h2><span id='topic+spm_pve2categorical'></span>

<h3>Description</h3>

<p>Convert SPM style segmentation files to a single categorical image where
the numerical values map as: 0) Other, 1) CSF, 2) GM and 3) WM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spm_pve2categorical(fname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spm_pve2categorical_+3A_fname">fname</code></td>
<td>
<p>any of the segmentation files (eg c1_MY_T1.nii).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nifti object.
</p>

<hr>
<h2 id='ssp'>Signal space projection method for lipid suppression.</h2><span id='topic+ssp'></span>

<h3>Description</h3>

<p>Signal space projection method as described in:
Tsai SY, Lin YR, Lin HY, Lin FH. Reduction of lipid contamination in MR
spectroscopy imaging using signal space projection. Magn Reson Med 2019
Mar;81(3):1486-1498.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssp(mrs_data, comps = 5, xlim = c(1.5, 0.8))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ssp_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data object.</p>
</td></tr>
<tr><td><code id="ssp_+3A_comps">comps</code></td>
<td>
<p>the number of spatial components to use.</p>
</td></tr>
<tr><td><code id="ssp_+3A_xlim">xlim</code></td>
<td>
<p>spectral range (in ppm) covering the lipid signals.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>lipid suppressed <code>mrs_data</code> object.
</p>

<hr>
<h2 id='stackplot'>Produce a plot with multiple traces.</h2><span id='topic+stackplot'></span>

<h3>Description</h3>

<p>Produce a plot with multiple traces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stackplot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stackplot_+3A_x">x</code></td>
<td>
<p>object for plotting.</p>
</td></tr>
<tr><td><code id="stackplot_+3A_...">...</code></td>
<td>
<p>arguments to be passed to methods.</p>
</td></tr>
</table>

<hr>
<h2 id='stackplot.fit_result'>Plot the fitting results of an object of class <code>fit_result</code> with
individual basis set components shown.</h2><span id='topic+stackplot.fit_result'></span>

<h3>Description</h3>

<p>Plot the fitting results of an object of class <code>fit_result</code> with
individual basis set components shown.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'fit_result'
stackplot(
  x,
  xlim = NULL,
  y_offset = 0,
  dyn = 1,
  x_pos = 1,
  y_pos = 1,
  z_pos = 1,
  coil = 1,
  n = NULL,
  sub_bl = FALSE,
  labels = FALSE,
  label_names = NULL,
  sig_col = "black",
  restore_def_par = TRUE,
  omit_signals = NULL,
  combine_lipmm = FALSE,
  combine_metab = FALSE,
  mar = NULL,
  show_grid = TRUE,
  grid_nx = NULL,
  grid_ny = NA,
  invert_fit = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stackplot.fit_result_+3A_x">x</code></td>
<td>
<p>fit_result object.</p>
</td></tr>
<tr><td><code id="stackplot.fit_result_+3A_xlim">xlim</code></td>
<td>
<p>the range of values to display on the x-axis, eg xlim = c(4,1).</p>
</td></tr>
<tr><td><code id="stackplot.fit_result_+3A_y_offset">y_offset</code></td>
<td>
<p>separate basis signals in the y-axis direction by this value.</p>
</td></tr>
<tr><td><code id="stackplot.fit_result_+3A_dyn">dyn</code></td>
<td>
<p>the dynamic index to plot.</p>
</td></tr>
<tr><td><code id="stackplot.fit_result_+3A_x_pos">x_pos</code></td>
<td>
<p>the x index to plot.</p>
</td></tr>
<tr><td><code id="stackplot.fit_result_+3A_y_pos">y_pos</code></td>
<td>
<p>the y index to plot.</p>
</td></tr>
<tr><td><code id="stackplot.fit_result_+3A_z_pos">z_pos</code></td>
<td>
<p>the z index to plot.</p>
</td></tr>
<tr><td><code id="stackplot.fit_result_+3A_coil">coil</code></td>
<td>
<p>the coil element number to plot.</p>
</td></tr>
<tr><td><code id="stackplot.fit_result_+3A_n">n</code></td>
<td>
<p>single index element to plot (overrides other indices when given).</p>
</td></tr>
<tr><td><code id="stackplot.fit_result_+3A_sub_bl">sub_bl</code></td>
<td>
<p>subtract the baseline from the data and fit (logical).</p>
</td></tr>
<tr><td><code id="stackplot.fit_result_+3A_labels">labels</code></td>
<td>
<p>print signal labels at the right side of the plot.</p>
</td></tr>
<tr><td><code id="stackplot.fit_result_+3A_label_names">label_names</code></td>
<td>
<p>provide a character vector of signal names to replace the
defaults determined from the basis set.</p>
</td></tr>
<tr><td><code id="stackplot.fit_result_+3A_sig_col">sig_col</code></td>
<td>
<p>colour of individual signal components.</p>
</td></tr>
<tr><td><code id="stackplot.fit_result_+3A_restore_def_par">restore_def_par</code></td>
<td>
<p>restore default plotting par values after the plot has
been made.</p>
</td></tr>
<tr><td><code id="stackplot.fit_result_+3A_omit_signals">omit_signals</code></td>
<td>
<p>a character vector of basis signal names to be removed
from the plot.</p>
</td></tr>
<tr><td><code id="stackplot.fit_result_+3A_combine_lipmm">combine_lipmm</code></td>
<td>
<p>combine all basis signals with names starting with &quot;Lip&quot;
or &quot;MM&quot;.</p>
</td></tr>
<tr><td><code id="stackplot.fit_result_+3A_combine_metab">combine_metab</code></td>
<td>
<p>combine all basis signals with names not starting with
&quot;Lip&quot; or &quot;MM&quot;.</p>
</td></tr>
<tr><td><code id="stackplot.fit_result_+3A_mar">mar</code></td>
<td>
<p>option to adjust the plot margins. See ?par.</p>
</td></tr>
<tr><td><code id="stackplot.fit_result_+3A_show_grid">show_grid</code></td>
<td>
<p>plot gridlines behind the data (logical). Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="stackplot.fit_result_+3A_grid_nx">grid_nx</code></td>
<td>
<p>number of cells of the grid in x and y direction. When NULL
the grid aligns with the tick marks on the corresponding default axis (i.e.,
tickmarks as computed by axTicks). When NA, no grid lines are drawn in the
corresponding direction.</p>
</td></tr>
<tr><td><code id="stackplot.fit_result_+3A_grid_ny">grid_ny</code></td>
<td>
<p>as above.</p>
</td></tr>
<tr><td><code id="stackplot.fit_result_+3A_invert_fit">invert_fit</code></td>
<td>
<p>show the fit result &quot;upside-down&quot;/</p>
</td></tr>
<tr><td><code id="stackplot.fit_result_+3A_...">...</code></td>
<td>
<p>further arguments to plot method.</p>
</td></tr>
</table>

<hr>
<h2 id='stackplot.mrs_data'>Stackplot plotting method for objects of class mrs_data.</h2><span id='topic+stackplot.mrs_data'></span>

<h3>Description</h3>

<p>Stackplot plotting method for objects of class mrs_data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mrs_data'
stackplot(
  x,
  xlim = NULL,
  mode = "re",
  x_units = NULL,
  fd = TRUE,
  col = NULL,
  alpha = NULL,
  x_offset = 0,
  y_offset = 0,
  plot_dim = NULL,
  x_pos = NULL,
  y_pos = NULL,
  z_pos = NULL,
  dyn = 1,
  coil = 1,
  bty = NULL,
  labels = NULL,
  lab_cex = 1,
  bl_lty = NULL,
  restore_def_par = TRUE,
  show_grid = NULL,
  grid_nx = NULL,
  grid_ny = NA,
  lwd = NULL,
  vline = NULL,
  vline_lty = 2,
  vline_col = "red",
  mar = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stackplot.mrs_data_+3A_x">x</code></td>
<td>
<p>object of class mrs_data.</p>
</td></tr>
<tr><td><code id="stackplot.mrs_data_+3A_xlim">xlim</code></td>
<td>
<p>the range of values to display on the x-axis, eg xlim = c(4,1).</p>
</td></tr>
<tr><td><code id="stackplot.mrs_data_+3A_mode">mode</code></td>
<td>
<p>representation of the complex numbers to be plotted, can be one
of: &quot;re&quot;, &quot;im&quot;, &quot;mod&quot; or &quot;arg&quot;.</p>
</td></tr>
<tr><td><code id="stackplot.mrs_data_+3A_x_units">x_units</code></td>
<td>
<p>the units to use for the x-axis, can be one of: &quot;ppm&quot;, &quot;hz&quot;,
&quot;points&quot; or &quot;seconds&quot;.</p>
</td></tr>
<tr><td><code id="stackplot.mrs_data_+3A_fd">fd</code></td>
<td>
<p>display data in the frequency-domain (default), or time-domain
(logical).</p>
</td></tr>
<tr><td><code id="stackplot.mrs_data_+3A_col">col</code></td>
<td>
<p>set the colour of the line, eg col = rgb(1, 0, 0, 0.5).</p>
</td></tr>
<tr><td><code id="stackplot.mrs_data_+3A_alpha">alpha</code></td>
<td>
<p>set the line transparency, eg alpha = 0.5 is 50% transparency.
Overrides any transparency levels set by col.</p>
</td></tr>
<tr><td><code id="stackplot.mrs_data_+3A_x_offset">x_offset</code></td>
<td>
<p>separate plots in the x-axis direction by this value.
Default value is 0.</p>
</td></tr>
<tr><td><code id="stackplot.mrs_data_+3A_y_offset">y_offset</code></td>
<td>
<p>separate plots in the y-axis direction by this value.</p>
</td></tr>
<tr><td><code id="stackplot.mrs_data_+3A_plot_dim">plot_dim</code></td>
<td>
<p>the dimension to display on the y-axis, can be one of: &quot;dyn&quot;,
&quot;x&quot;, &quot;y&quot;, &quot;z&quot;, &quot;coil&quot; or NULL. If NULL (the default) all spectra will be
collapsed into the dynamic dimension and displayed.</p>
</td></tr>
<tr><td><code id="stackplot.mrs_data_+3A_x_pos">x_pos</code></td>
<td>
<p>the x index to plot.</p>
</td></tr>
<tr><td><code id="stackplot.mrs_data_+3A_y_pos">y_pos</code></td>
<td>
<p>the y index to plot.</p>
</td></tr>
<tr><td><code id="stackplot.mrs_data_+3A_z_pos">z_pos</code></td>
<td>
<p>the z index to plot.</p>
</td></tr>
<tr><td><code id="stackplot.mrs_data_+3A_dyn">dyn</code></td>
<td>
<p>the dynamic index to plot.</p>
</td></tr>
<tr><td><code id="stackplot.mrs_data_+3A_coil">coil</code></td>
<td>
<p>the coil element number to plot.</p>
</td></tr>
<tr><td><code id="stackplot.mrs_data_+3A_bty">bty</code></td>
<td>
<p>option to draw a box around the plot. See ?par.</p>
</td></tr>
<tr><td><code id="stackplot.mrs_data_+3A_labels">labels</code></td>
<td>
<p>add labels to each data item.</p>
</td></tr>
<tr><td><code id="stackplot.mrs_data_+3A_lab_cex">lab_cex</code></td>
<td>
<p>label size.</p>
</td></tr>
<tr><td><code id="stackplot.mrs_data_+3A_bl_lty">bl_lty</code></td>
<td>
<p>linetype for the y = 0 baseline trace. A default value NULL
results in no baseline being plotted.</p>
</td></tr>
<tr><td><code id="stackplot.mrs_data_+3A_restore_def_par">restore_def_par</code></td>
<td>
<p>restore default plotting par values after the plot has
been made.</p>
</td></tr>
<tr><td><code id="stackplot.mrs_data_+3A_show_grid">show_grid</code></td>
<td>
<p>plot gridlines behind the data (logical). Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="stackplot.mrs_data_+3A_grid_nx">grid_nx</code></td>
<td>
<p>number of cells of the grid in x and y direction. When NULL
the grid aligns with the tick marks on the corresponding default axis (i.e.,
tickmarks as computed by axTicks). When NA, no grid lines are drawn in the
corresponding direction.</p>
</td></tr>
<tr><td><code id="stackplot.mrs_data_+3A_grid_ny">grid_ny</code></td>
<td>
<p>as above.</p>
</td></tr>
<tr><td><code id="stackplot.mrs_data_+3A_lwd">lwd</code></td>
<td>
<p>plot linewidth.</p>
</td></tr>
<tr><td><code id="stackplot.mrs_data_+3A_vline">vline</code></td>
<td>
<p>x-value to draw a vertical line.</p>
</td></tr>
<tr><td><code id="stackplot.mrs_data_+3A_vline_lty">vline_lty</code></td>
<td>
<p>linetype for the vertical line.</p>
</td></tr>
<tr><td><code id="stackplot.mrs_data_+3A_vline_col">vline_col</code></td>
<td>
<p>colour for the vertical line.</p>
</td></tr>
<tr><td><code id="stackplot.mrs_data_+3A_mar">mar</code></td>
<td>
<p>option to adjust the plot margins. See ?par.</p>
</td></tr>
<tr><td><code id="stackplot.mrs_data_+3A_...">...</code></td>
<td>
<p>other arguments to pass to the matplot method.</p>
</td></tr>
</table>

<hr>
<h2 id='sub_first_dyn'>Subtract the first dynamic spectrum from a dynamic series.</h2><span id='topic+sub_first_dyn'></span>

<h3>Description</h3>

<p>Subtract the first dynamic spectrum from a dynamic series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sub_first_dyn(mrs_data, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sub_first_dyn_+3A_mrs_data">mrs_data</code></td>
<td>
<p>dynamic MRS data.</p>
</td></tr>
<tr><td><code id="sub_first_dyn_+3A_scale">scale</code></td>
<td>
<p>scale factor for the first spectrum.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>subtracted data.
</p>

<hr>
<h2 id='sub_mean_dyns'>Subtract the mean dynamic spectrum from a dynamic series.</h2><span id='topic+sub_mean_dyns'></span>

<h3>Description</h3>

<p>Subtract the mean dynamic spectrum from a dynamic series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sub_mean_dyns(mrs_data, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sub_mean_dyns_+3A_mrs_data">mrs_data</code></td>
<td>
<p>dynamic MRS data.</p>
</td></tr>
<tr><td><code id="sub_mean_dyns_+3A_scale">scale</code></td>
<td>
<p>scale factor for the mean spectrum.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>subtracted data.
</p>

<hr>
<h2 id='sub_median_dyns'>Subtract the median dynamic spectrum from a dynamic series.</h2><span id='topic+sub_median_dyns'></span>

<h3>Description</h3>

<p>Subtract the median dynamic spectrum from a dynamic series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sub_median_dyns(mrs_data, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sub_median_dyns_+3A_mrs_data">mrs_data</code></td>
<td>
<p>dynamic MRS data.</p>
</td></tr>
<tr><td><code id="sub_median_dyns_+3A_scale">scale</code></td>
<td>
<p>scale factor for the medium spectrum.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>subtracted data.
</p>

<hr>
<h2 id='sum_coils'>Calculate the sum across receiver coil elements.</h2><span id='topic+sum_coils'></span>

<h3>Description</h3>

<p>Calculate the sum across receiver coil elements.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_coils(mrs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum_coils_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data split across receiver coil elements.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sum across coil elements.
</p>

<hr>
<h2 id='sum_dyns'>Calculate the sum of data dynamics.</h2><span id='topic+sum_dyns'></span>

<h3>Description</h3>

<p>Calculate the sum of data dynamics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_dyns(mrs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum_dyns_+3A_mrs_data">mrs_data</code></td>
<td>
<p>dynamic MRS data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sum of data dynamics.
</p>

<hr>
<h2 id='sum_mrs'>Sum two mrs_data objects.</h2><span id='topic+sum_mrs'></span>

<h3>Description</h3>

<p>Sum two mrs_data objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_mrs(a, b, force = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum_mrs_+3A_a">a</code></td>
<td>
<p>first mrs_data object to be summed.</p>
</td></tr>
<tr><td><code id="sum_mrs_+3A_b">b</code></td>
<td>
<p>second mrs_data object to be summed.</p>
</td></tr>
<tr><td><code id="sum_mrs_+3A_force">force</code></td>
<td>
<p>set to TRUE to force mrs_data objects to be summed, even if they
are in different time/frequency domains.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a + b
</p>

<hr>
<h2 id='sum_mrs_list'>Return the sum of a list of mrs_data objects.</h2><span id='topic+sum_mrs_list'></span>

<h3>Description</h3>

<p>Return the sum of a list of mrs_data objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sum_mrs_list(mrs_list)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sum_mrs_list_+3A_mrs_list">mrs_list</code></td>
<td>
<p>list of mrs_data objects.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>sum <code>mrs_data</code> object.
</p>

<hr>
<h2 id='svs_1h_brain_analysis'>Standard SVS 1H brain analysis pipeline.</h2><span id='topic+svs_1h_brain_analysis'></span>

<h3>Description</h3>

<p>Standard SVS 1H brain analysis pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svs_1h_brain_analysis(
  metab,
  basis = NULL,
  w_ref = NULL,
  mri_seg = NULL,
  mri = NULL,
  output_dir = NULL,
  extra = NULL,
  decimate = NULL,
  rats_corr = TRUE,
  ecc = FALSE,
  comb_dyns = TRUE,
  hsvd_filt = FALSE,
  scale_amps = TRUE,
  te = NULL,
  tr = NULL,
  preproc_only = FALSE,
  method = "ABFIT",
  opts = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svs_1h_brain_analysis_+3A_metab">metab</code></td>
<td>
<p>filepath or mrs_data object containing MRS metabolite data.</p>
</td></tr>
<tr><td><code id="svs_1h_brain_analysis_+3A_basis">basis</code></td>
<td>
<p>basis set object to use for analysis.</p>
</td></tr>
<tr><td><code id="svs_1h_brain_analysis_+3A_w_ref">w_ref</code></td>
<td>
<p>filepath or mrs_data object containing MRS water reference data.</p>
</td></tr>
<tr><td><code id="svs_1h_brain_analysis_+3A_mri_seg">mri_seg</code></td>
<td>
<p>filepath or nifti object containing segmented MRI data.</p>
</td></tr>
<tr><td><code id="svs_1h_brain_analysis_+3A_mri">mri</code></td>
<td>
<p>filepath or nifti object containing anatomical MRI data.</p>
</td></tr>
<tr><td><code id="svs_1h_brain_analysis_+3A_output_dir">output_dir</code></td>
<td>
<p>directory path to output fitting results.</p>
</td></tr>
<tr><td><code id="svs_1h_brain_analysis_+3A_extra">extra</code></td>
<td>
<p>data.frame with one row containing additional information to be
attached to the fit results table.</p>
</td></tr>
<tr><td><code id="svs_1h_brain_analysis_+3A_decimate">decimate</code></td>
<td>
<p>option to decimate the input data by a factor of two. The
default value of NULL does not perform decimation unless the spectral width
is greater than 20 PPM.</p>
</td></tr>
<tr><td><code id="svs_1h_brain_analysis_+3A_rats_corr">rats_corr</code></td>
<td>
<p>option to perform rats correction, defaults to TRUE.</p>
</td></tr>
<tr><td><code id="svs_1h_brain_analysis_+3A_ecc">ecc</code></td>
<td>
<p>option to perform water reference based eddy current correction,
defaults to FALSE.</p>
</td></tr>
<tr><td><code id="svs_1h_brain_analysis_+3A_comb_dyns">comb_dyns</code></td>
<td>
<p>option to combine dynamic scans, defaults to TRUE.</p>
</td></tr>
<tr><td><code id="svs_1h_brain_analysis_+3A_hsvd_filt">hsvd_filt</code></td>
<td>
<p>option to apply hsvd water removal, defaults to FALSE.</p>
</td></tr>
<tr><td><code id="svs_1h_brain_analysis_+3A_scale_amps">scale_amps</code></td>
<td>
<p>option to scale metabolite amplitude estimates, defaults to
TRUE.</p>
</td></tr>
<tr><td><code id="svs_1h_brain_analysis_+3A_te">te</code></td>
<td>
<p>metabolite mrs data echo time in seconds.</p>
</td></tr>
<tr><td><code id="svs_1h_brain_analysis_+3A_tr">tr</code></td>
<td>
<p>metabolite mrs data repetition time in seconds.</p>
</td></tr>
<tr><td><code id="svs_1h_brain_analysis_+3A_preproc_only">preproc_only</code></td>
<td>
<p>only perform the preprocessing steps and omit fitting.
The preprocessed metabolite data will be returned in this case.</p>
</td></tr>
<tr><td><code id="svs_1h_brain_analysis_+3A_method">method</code></td>
<td>
<p>analysis method to use, see fit_mrs help.</p>
</td></tr>
<tr><td><code id="svs_1h_brain_analysis_+3A_opts">opts</code></td>
<td>
<p>options to pass to the analysis method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a fit_result or mrs_data object depending on the preproc_only option.
</p>

<hr>
<h2 id='svs_1h_brain_analysis_dev'>Standard SVS 1H brain analysis pipeline.</h2><span id='topic+svs_1h_brain_analysis_dev'></span>

<h3>Description</h3>

<p>Note this function is still under development and liable to changes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svs_1h_brain_analysis_dev(
  metab,
  w_ref = NULL,
  output_dir = NULL,
  basis = NULL,
  p_vols = NULL,
  append_basis = NULL,
  remove_basis = NULL,
  dfp_corr = FALSE,
  omit_bad_dynamics = FALSE,
  te = NULL,
  tr = NULL,
  output_ratio = "tCr",
  ecc = FALSE,
  abfit_opts = NULL,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svs_1h_brain_analysis_dev_+3A_metab">metab</code></td>
<td>
<p>filepath or mrs_data object containing MRS metabolite data.</p>
</td></tr>
<tr><td><code id="svs_1h_brain_analysis_dev_+3A_w_ref">w_ref</code></td>
<td>
<p>filepath or mrs_data object containing MRS water reference data.</p>
</td></tr>
<tr><td><code id="svs_1h_brain_analysis_dev_+3A_output_dir">output_dir</code></td>
<td>
<p>directory path to output fitting results.</p>
</td></tr>
<tr><td><code id="svs_1h_brain_analysis_dev_+3A_basis">basis</code></td>
<td>
<p>precompiled basis set object to use for analysis.</p>
</td></tr>
<tr><td><code id="svs_1h_brain_analysis_dev_+3A_p_vols">p_vols</code></td>
<td>
<p>a numeric vector of partial volumes expressed as percentages.
Defaults to 100% white matter. A voxel containing 100% gray matter tissue
would use : p_vols = c(WM = 0, GM = 100, CSF = 0).</p>
</td></tr>
<tr><td><code id="svs_1h_brain_analysis_dev_+3A_append_basis">append_basis</code></td>
<td>
<p>names of extra signals to add to the default basis. Eg
append_basis = c(&quot;peth&quot;, &quot;cit&quot;). Cannot be used with precompiled basis sets.</p>
</td></tr>
<tr><td><code id="svs_1h_brain_analysis_dev_+3A_remove_basis">remove_basis</code></td>
<td>
<p>names of signals to remove from the basis. Cannot be used
with precompiled basis sets.</p>
</td></tr>
<tr><td><code id="svs_1h_brain_analysis_dev_+3A_dfp_corr">dfp_corr</code></td>
<td>
<p>perform dynamic frequency and phase correction using the RATS
method.</p>
</td></tr>
<tr><td><code id="svs_1h_brain_analysis_dev_+3A_omit_bad_dynamics">omit_bad_dynamics</code></td>
<td>
<p>detect and remove bad dynamics.</p>
</td></tr>
<tr><td><code id="svs_1h_brain_analysis_dev_+3A_te">te</code></td>
<td>
<p>metabolite mrs data echo time in seconds. If not supplied this will
be guessed from the metab data file.</p>
</td></tr>
<tr><td><code id="svs_1h_brain_analysis_dev_+3A_tr">tr</code></td>
<td>
<p>metabolite mrs data repetition time in seconds. If not supplied
this will be guessed from the metab data file.</p>
</td></tr>
<tr><td><code id="svs_1h_brain_analysis_dev_+3A_output_ratio">output_ratio</code></td>
<td>
<p>optional string to specify a metabolite ratio to output.
Defaults to &quot;tCr&quot; and multiple metabolites may be specified for multiple
outputs. Set as NULL to omit.</p>
</td></tr>
<tr><td><code id="svs_1h_brain_analysis_dev_+3A_ecc">ecc</code></td>
<td>
<p>option to perform water reference based eddy current correction,
defaults to FALSE.</p>
</td></tr>
<tr><td><code id="svs_1h_brain_analysis_dev_+3A_abfit_opts">abfit_opts</code></td>
<td>
<p>options to pass to ABfit.</p>
</td></tr>
<tr><td><code id="svs_1h_brain_analysis_dev_+3A_verbose">verbose</code></td>
<td>
<p>output potentially useful information.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>metab &lt;- system.file("extdata", "philips_spar_sdat_WS.SDAT",
                     package = "spant")
w_ref &lt;- system.file("extdata", "philips_spar_sdat_W.SDAT",
                     package = "spant")
## Not run: 
fit_result &lt;- svs_1h_brain_analysis(metab, w_ref, "fit_res_dir")

## End(Not run)
</code></pre>

<hr>
<h2 id='svs_1h_brain_batch_analysis'>Batch interface to the standard SVS 1H brain analysis pipeline.</h2><span id='topic+svs_1h_brain_batch_analysis'></span>

<h3>Description</h3>

<p>Batch interface to the standard SVS 1H brain analysis pipeline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>svs_1h_brain_batch_analysis(
  metab_list,
  w_ref_list = NULL,
  mri_seg_list = NULL,
  mri_list = NULL,
  output_dir_list = NULL,
  extra = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="svs_1h_brain_batch_analysis_+3A_metab_list">metab_list</code></td>
<td>
<p>list of file paths or mrs_data objects containing MRS
metabolite data.</p>
</td></tr>
<tr><td><code id="svs_1h_brain_batch_analysis_+3A_w_ref_list">w_ref_list</code></td>
<td>
<p>list of file paths or mrs_data objects containing MRS
water reference data.</p>
</td></tr>
<tr><td><code id="svs_1h_brain_batch_analysis_+3A_mri_seg_list">mri_seg_list</code></td>
<td>
<p>list of file paths or nifti objects containing segmented
MRI data.</p>
</td></tr>
<tr><td><code id="svs_1h_brain_batch_analysis_+3A_mri_list">mri_list</code></td>
<td>
<p>list of file paths or nifti objects containing anatomical
MRI data.</p>
</td></tr>
<tr><td><code id="svs_1h_brain_batch_analysis_+3A_output_dir_list">output_dir_list</code></td>
<td>
<p>list of directory paths to output fitting results.</p>
</td></tr>
<tr><td><code id="svs_1h_brain_batch_analysis_+3A_extra">extra</code></td>
<td>
<p>a data frame with the same number of rows as metab_list,
containing additional information to be attached to the fit results table.</p>
</td></tr>
<tr><td><code id="svs_1h_brain_batch_analysis_+3A_...">...</code></td>
<td>
<p>additional options to be passed to the svs_1h_brain_analysis
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of fit_result objects.
</p>

<hr>
<h2 id='t_test_spec'>Perform a t-test on spectral data points.</h2><span id='topic+t_test_spec'></span>

<h3>Description</h3>

<p>Perform a t-test on spectral data points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>t_test_spec(mrs_data, group)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="t_test_spec_+3A_mrs_data">mrs_data</code></td>
<td>
<p>an mrs_data object with spectra in the dynamic dimension.</p>
</td></tr>
<tr><td><code id="t_test_spec_+3A_group">group</code></td>
<td>
<p>vector describing the group membership of each dynamic spectrum.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of statistical results.
</p>

<hr>
<h2 id='td_conv_filt'>Time-domain convolution based filter.</h2><span id='topic+td_conv_filt'></span>

<h3>Description</h3>

<p>Time-domain convolution based filter described by:
Marion D, Ikura M, Bax A. Improved solvent suppression in one-dimensional and
twodimensional NMR spectra by convolution of time-domain data. J Magn Reson
1989;84:425-430.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>td_conv_filt(mrs_data, K = 25, ext = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="td_conv_filt_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data to be filtered.</p>
</td></tr>
<tr><td><code id="td_conv_filt_+3A_k">K</code></td>
<td>
<p>window width in data points.</p>
</td></tr>
<tr><td><code id="td_conv_filt_+3A_ext">ext</code></td>
<td>
<p>point separation for linear extrapolation.</p>
</td></tr>
</table>

<hr>
<h2 id='td2fd'>Transform time-domain data to the frequency-domain.</h2><span id='topic+td2fd'></span>

<h3>Description</h3>

<p>Transform time-domain data to the frequency-domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>td2fd(mrs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="td2fd_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data in time-domain representation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>MRS data in frequency-domain representation.
</p>

<hr>
<h2 id='tdsr'>Time-domain spectral registration.</h2><span id='topic+tdsr'></span>

<h3>Description</h3>

<p>An implementation of the method published by Near et al MRM 73:44-50 (2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tdsr(mrs_data, ref = NULL, xlim = c(4, 0.5), max_t = 0.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tdsr_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data to be corrected.</p>
</td></tr>
<tr><td><code id="tdsr_+3A_ref">ref</code></td>
<td>
<p>optional MRS data to use as a reference, the mean of all dynamics
is used if this argument is not supplied.</p>
</td></tr>
<tr><td><code id="tdsr_+3A_xlim">xlim</code></td>
<td>
<p>optional frequency range to perform optimisation, set to NULL
to use the full range.</p>
</td></tr>
<tr><td><code id="tdsr_+3A_max_t">max_t</code></td>
<td>
<p>truncate the FID when longer than max_t to reduce time taken.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing the corrected data; phase and shift values in units
of degrees and Hz respectively.
</p>

<hr>
<h2 id='te'>Return the echo time of an MRS dataset.</h2><span id='topic+te'></span>

<h3>Description</h3>

<p>Return the echo time of an MRS dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>te(mrs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="te_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>echo time in seconds.
</p>

<hr>
<h2 id='tr'>Return the repetition time of an MRS dataset.</h2><span id='topic+tr'></span>

<h3>Description</h3>

<p>Return the repetition time of an MRS dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tr(mrs_data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tr_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>repetition time in seconds.
</p>

<hr>
<h2 id='varpro_3_para_opts'>Return a list of options for VARPRO based fitting with 3 free parameters.</h2><span id='topic+varpro_3_para_opts'></span>

<h3>Description</h3>

<p>Return a list of options for VARPRO based fitting with 3 free parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varpro_3_para_opts(
  nstart = 20,
  init_damping = 2,
  maxiters = 200,
  max_shift = 5,
  max_damping = 5,
  anal_jac = FALSE,
  bl_smth_pts = 80
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varpro_3_para_opts_+3A_nstart">nstart</code></td>
<td>
<p>position in the time-domain to start fitting, units of data
points.</p>
</td></tr>
<tr><td><code id="varpro_3_para_opts_+3A_init_damping">init_damping</code></td>
<td>
<p>starting value for the global Gaussian line-broadening
term - measured in Hz.</p>
</td></tr>
<tr><td><code id="varpro_3_para_opts_+3A_maxiters">maxiters</code></td>
<td>
<p>maximum number of levmar iterations to perform.</p>
</td></tr>
<tr><td><code id="varpro_3_para_opts_+3A_max_shift">max_shift</code></td>
<td>
<p>maximum global shift allowed, measured in Hz.</p>
</td></tr>
<tr><td><code id="varpro_3_para_opts_+3A_max_damping">max_damping</code></td>
<td>
<p>maximum damping allowed, FWHM measured in Hz.</p>
</td></tr>
<tr><td><code id="varpro_3_para_opts_+3A_anal_jac">anal_jac</code></td>
<td>
<p>option to use the analytic or numerical Jacobian (logical).</p>
</td></tr>
<tr><td><code id="varpro_3_para_opts_+3A_bl_smth_pts">bl_smth_pts</code></td>
<td>
<p>number of data points to use in the baseline smoothing
calculation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of options.
</p>

<hr>
<h2 id='varpro_basic_opts'>Return a list of options for a basic VARPRO analysis.</h2><span id='topic+varpro_basic_opts'></span>

<h3>Description</h3>

<p>Return a list of options for a basic VARPRO analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varpro_basic_opts(method = "fd_re", nnls = TRUE, ppm_left = 4, ppm_right = 0.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varpro_basic_opts_+3A_method">method</code></td>
<td>
<p>one of &quot;td&quot;, &quot;fd&quot;, &quot;fd_re&quot;.</p>
</td></tr>
<tr><td><code id="varpro_basic_opts_+3A_nnls">nnls</code></td>
<td>
<p>restrict basis amplitudes to non-negative values.</p>
</td></tr>
<tr><td><code id="varpro_basic_opts_+3A_ppm_left">ppm_left</code></td>
<td>
<p>downfield frequency limit for the fitting range (ppm).</p>
</td></tr>
<tr><td><code id="varpro_basic_opts_+3A_ppm_right">ppm_right</code></td>
<td>
<p>upfield frequency limit for the fitting range (ppm).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>full list of options.
</p>

<hr>
<h2 id='varpro_opts'>Return a list of options for VARPRO based fitting.</h2><span id='topic+varpro_opts'></span>

<h3>Description</h3>

<p>Return a list of options for VARPRO based fitting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>varpro_opts(
  nstart = 20,
  init_g_damping = 2,
  maxiters = 200,
  max_shift = 5,
  max_g_damping = 5,
  max_ind_damping = 5,
  anal_jac = TRUE,
  bl_smth_pts = 80
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="varpro_opts_+3A_nstart">nstart</code></td>
<td>
<p>position in the time-domain to start fitting, units of data
points.</p>
</td></tr>
<tr><td><code id="varpro_opts_+3A_init_g_damping">init_g_damping</code></td>
<td>
<p>starting value for the global Gaussian line-broadening
term - measured in Hz.</p>
</td></tr>
<tr><td><code id="varpro_opts_+3A_maxiters">maxiters</code></td>
<td>
<p>maximum number of levmar iterations to perform.</p>
</td></tr>
<tr><td><code id="varpro_opts_+3A_max_shift">max_shift</code></td>
<td>
<p>maximum shift allowed to each element in the basis set,
measured in Hz.</p>
</td></tr>
<tr><td><code id="varpro_opts_+3A_max_g_damping">max_g_damping</code></td>
<td>
<p>maximum permitted global Gaussian line-broadening.</p>
</td></tr>
<tr><td><code id="varpro_opts_+3A_max_ind_damping">max_ind_damping</code></td>
<td>
<p>maximum permitted Lorentzian line-broadening for each
element in the basis set, measured in Hz.</p>
</td></tr>
<tr><td><code id="varpro_opts_+3A_anal_jac">anal_jac</code></td>
<td>
<p>option to use the analytic or numerical Jacobian (logical).</p>
</td></tr>
<tr><td><code id="varpro_opts_+3A_bl_smth_pts">bl_smth_pts</code></td>
<td>
<p>number of data points to use in the baseline smoothing
calculation.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of options.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>varpro_opts(nstart = 10)
</code></pre>

<hr>
<h2 id='vec2mrs_data'>Convert a vector into a mrs_data object.</h2><span id='topic+vec2mrs_data'></span>

<h3>Description</h3>

<p>Convert a vector into a mrs_data object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec2mrs_data(
  vec,
  mrs_data = NULL,
  fs = NULL,
  ft = NULL,
  ref = NULL,
  nuc = NULL,
  dyns = 1,
  fd = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec2mrs_data_+3A_vec">vec</code></td>
<td>
<p>the data vector.</p>
</td></tr>
<tr><td><code id="vec2mrs_data_+3A_mrs_data">mrs_data</code></td>
<td>
<p>example data to copy acquisition parameters from.</p>
</td></tr>
<tr><td><code id="vec2mrs_data_+3A_fs">fs</code></td>
<td>
<p>sampling frequency in Hz.</p>
</td></tr>
<tr><td><code id="vec2mrs_data_+3A_ft">ft</code></td>
<td>
<p>transmitter frequency in Hz.</p>
</td></tr>
<tr><td><code id="vec2mrs_data_+3A_ref">ref</code></td>
<td>
<p>reference value for ppm scale.</p>
</td></tr>
<tr><td><code id="vec2mrs_data_+3A_nuc">nuc</code></td>
<td>
<p>resonant nucleus.</p>
</td></tr>
<tr><td><code id="vec2mrs_data_+3A_dyns">dyns</code></td>
<td>
<p>replicate the data across the dynamic dimension.</p>
</td></tr>
<tr><td><code id="vec2mrs_data_+3A_fd">fd</code></td>
<td>
<p>flag to indicate if the vector is in the frequency domain (logical).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>mrs_data object.
</p>

<hr>
<h2 id='write_basis'>Write a basis object to an LCModel .basis formatted file.</h2><span id='topic+write_basis'></span>

<h3>Description</h3>

<p>Write a basis object to an LCModel .basis formatted file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_basis(basis, basis_file, fwhmba = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_basis_+3A_basis">basis</code></td>
<td>
<p>basis object to be exported.</p>
</td></tr>
<tr><td><code id="write_basis_+3A_basis_file">basis_file</code></td>
<td>
<p>path to basis file to be generated.</p>
</td></tr>
<tr><td><code id="write_basis_+3A_fwhmba">fwhmba</code></td>
<td>
<p>parameter used by LCModel.</p>
</td></tr>
</table>

<hr>
<h2 id='write_basis_tqn'>Generate a basis file using TARQUIN.</h2><span id='topic+write_basis_tqn'></span>

<h3>Description</h3>

<p>Generate a basis file using TARQUIN.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_basis_tqn(basis_file, metab_data, opts = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_basis_tqn_+3A_basis_file">basis_file</code></td>
<td>
<p>filename of the basis file to be generated.</p>
</td></tr>
<tr><td><code id="write_basis_tqn_+3A_metab_data">metab_data</code></td>
<td>
<p>MRS data object to match the generated basis parameters.</p>
</td></tr>
<tr><td><code id="write_basis_tqn_+3A_opts">opts</code></td>
<td>
<p>list of options to pass to TARQUIN.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
write_basis_tqn('test.basis',mrs_data,c("--echo","0.04"))

## End(Not run)
</code></pre>

<hr>
<h2 id='write_mrs'>Write MRS data object to file.</h2><span id='topic+write_mrs'></span>

<h3>Description</h3>

<p>Write MRS data object to file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_mrs(mrs_data, fname, format = NULL, force = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_mrs_+3A_mrs_data">mrs_data</code></td>
<td>
<p>object to be written to file, or list of mrs_data objects.</p>
</td></tr>
<tr><td><code id="write_mrs_+3A_fname">fname</code></td>
<td>
<p>one or more filenames to output.</p>
</td></tr>
<tr><td><code id="write_mrs_+3A_format">format</code></td>
<td>
<p>string describing the data format. Must be one of the
following : &quot;nifti&quot;, &quot;dpt&quot;, &quot;lcm_raw&quot;, &quot;rds&quot;. If not specified, the format
will be guessed from the filename extension.</p>
</td></tr>
<tr><td><code id="write_mrs_+3A_force">force</code></td>
<td>
<p>set to TRUE to overwrite any existing files.</p>
</td></tr>
</table>

<hr>
<h2 id='write_mrs_nifti'>Write MRS data object to file in NIFTI format.</h2><span id='topic+write_mrs_nifti'></span>

<h3>Description</h3>

<p>Write MRS data object to file in NIFTI format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_mrs_nifti(mrs_data, fname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_mrs_nifti_+3A_mrs_data">mrs_data</code></td>
<td>
<p>object to be written to file.</p>
</td></tr>
<tr><td><code id="write_mrs_nifti_+3A_fname">fname</code></td>
<td>
<p>the filename of the output NIFTI MRS data.</p>
</td></tr>
</table>

<hr>
<h2 id='write_pulse_ascii'>Write an ASCII formatted pulse file.</h2><span id='topic+write_pulse_ascii'></span>

<h3>Description</h3>

<p>Write an ASCII formatted pulse file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>write_pulse_ascii(pulse, path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write_pulse_ascii_+3A_pulse">pulse</code></td>
<td>
<p>pulse data object.</p>
</td></tr>
<tr><td><code id="write_pulse_ascii_+3A_path">path</code></td>
<td>
<p>file path for export.</p>
</td></tr>
</table>

<hr>
<h2 id='zero_fade_spec'>Fade a spectrum to zero by frequency domain multiplication with a tanh
function. Note this operation distorts data points at the end of the FID.</h2><span id='topic+zero_fade_spec'></span>

<h3>Description</h3>

<p>Fade a spectrum to zero by frequency domain multiplication with a tanh
function. Note this operation distorts data points at the end of the FID.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zero_fade_spec(mrs_data, start_ppm, end_ppm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zero_fade_spec_+3A_mrs_data">mrs_data</code></td>
<td>
<p>data to be faded.</p>
</td></tr>
<tr><td><code id="zero_fade_spec_+3A_start_ppm">start_ppm</code></td>
<td>
<p>start point of the fade in ppm units.</p>
</td></tr>
<tr><td><code id="zero_fade_spec_+3A_end_ppm">end_ppm</code></td>
<td>
<p>end point of the fade in ppm units.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>modified mrs_data object.
</p>

<hr>
<h2 id='zero_higher_orders'>Zero all coherences including and above a given order.</h2><span id='topic+zero_higher_orders'></span>

<h3>Description</h3>

<p>Zero all coherences including and above a given order.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zero_higher_orders(sys, rho, order)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zero_higher_orders_+3A_sys">sys</code></td>
<td>
<p>spin system object.</p>
</td></tr>
<tr><td><code id="zero_higher_orders_+3A_rho">rho</code></td>
<td>
<p>density matrix.</p>
</td></tr>
<tr><td><code id="zero_higher_orders_+3A_order">order</code></td>
<td>
<p>states higher than or equal to this argument will be set to
zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>density matrix.
</p>

<hr>
<h2 id='zero_td_pts_end'>Set <code>mrs_data</code> object data points at the end of the FID to zero.</h2><span id='topic+zero_td_pts_end'></span>

<h3>Description</h3>

<p>Set <code>mrs_data</code> object data points at the end of the FID to zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zero_td_pts_end(mrs_data, pts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zero_td_pts_end_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRS data.</p>
</td></tr>
<tr><td><code id="zero_td_pts_end_+3A_pts">pts</code></td>
<td>
<p>number of end points to set to zero.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>modified <code>mrs_data</code> object.
</p>

<hr>
<h2 id='zf'>Zero-fill MRS data in the time domain.</h2><span id='topic+zf'></span><span id='topic+zf.list'></span><span id='topic+zf.mrs_data'></span><span id='topic+zf.basis_set'></span>

<h3>Description</h3>

<p>Zero-fill MRS data in the time domain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zf(x, factor = 2, offset = 0)

## S3 method for class 'list'
zf(x, factor = 2, offset = 0)

## S3 method for class 'mrs_data'
zf(x, factor = 2, offset = 0)

## S3 method for class 'basis_set'
zf(x, factor = 2, offset = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zf_+3A_x">x</code></td>
<td>
<p>input mrs_data or basis_set object.</p>
</td></tr>
<tr><td><code id="zf_+3A_factor">factor</code></td>
<td>
<p>zero-filling factor, factor of 2 returns a dataset with
twice the original data points.</p>
</td></tr>
<tr><td><code id="zf_+3A_offset">offset</code></td>
<td>
<p>number of points from the end of the FID to insert the zero
values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>zero-filled data.
</p>

<hr>
<h2 id='zf_xy'>Zero-fill MRSI data in the k-space x-y direction.</h2><span id='topic+zf_xy'></span>

<h3>Description</h3>

<p>Zero-fill MRSI data in the k-space x-y direction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zf_xy(mrs_data, factor = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zf_xy_+3A_mrs_data">mrs_data</code></td>
<td>
<p>MRSI data.</p>
</td></tr>
<tr><td><code id="zf_xy_+3A_factor">factor</code></td>
<td>
<p>zero-filling factor, a factor of 2 returns a dataset with
twice the original points in the x-y directions. Factors smaller than one
are permitted, such that a factor of 0.5 returns half the k-space points in
the x-y directions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>zero-filled data.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
