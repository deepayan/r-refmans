<!DOCTYPE html><html lang="en"><head><title>Help for package stringdist</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {stringdist}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#stringdist-package'><p>A package for string distance calculation and approximate string matching.</p></a></li>
<li><a href='#afind'><p>Stringdist-based fuzzy text search</p></a></li>
<li><a href='#amatch'><p>Approximate string matching</p></a></li>
<li><a href='#phonetic'><p>Phonetic algorithms</p></a></li>
<li><a href='#printable_ascii'><p>Detect the presence of non-printable or non-ascii characters</p></a></li>
<li><a href='#qgrams'><p>Get a table of qgram counts from one or more character vectors.</p></a></li>
<li><a href='#seq_amatch'><p>Approximate matching for integer sequences.</p></a></li>
<li><a href='#seq_dist'><p>Compute distance metrics between integer sequences</p></a></li>
<li><a href='#seq_qgrams'><p>Get a table of qgram counts for integer sequences</p></a></li>
<li><a href='#seq_sim'><p>Compute similarity scores between sequences of integers</p></a></li>
<li><a href='#stringdist'><p>Compute distance metrics between strings</p></a></li>
<li><a href='#stringdist_api'><p>Calling stringdist from <code>C</code> or <code>C++</code></p></a></li>
<li><a href='#stringdist-encoding'><p>String metrics in <span class="pkg">stringdist</span></p></a></li>
<li><a href='#stringdist-metrics'><p>String metrics in <span class="pkg">stringdist</span></p></a></li>
<li><a href='#stringdist-parallelization'><p>Multithreading and parallelization in <span class="pkg">stringdist</span></p></a></li>
<li><a href='#stringsim'><p>Compute similarity scores between strings</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Maintainer:</td>
<td>Mark van der Loo &lt;mark.vanderloo@gmail.com&gt;</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Title:</td>
<td>Approximate String Matching, Fuzzy Text Search, and String
Distance Functions</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Description:</td>
<td>Implements an approximate string matching version of R's native
    'match' function. Also offers fuzzy text search based on various string
     distance measures. Can calculate various string distances based on edits
    (Damerau-Levenshtein, Hamming, Levenshtein, optimal sting alignment), qgrams (q-
    gram, cosine, jaccard distance) or heuristic metrics (Jaro, Jaro-Winkler). An
    implementation of soundex is provided as well. Distances can be computed between
    character vectors while taking proper care of encoding or between integer
    vectors representing generic sequences. This package is built for speed and
    runs in parallel by using 'openMP'. An API for C or C++ is exposed as well.
    Reference: MPJ van der Loo (2014) &lt;<a href="https://doi.org/10.32614%2FRJ-2014-011">doi:10.32614/RJ-2014-011</a>&gt;.</td>
</tr>
<tr>
<td>Version:</td>
<td>0.9.15</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15.3)</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/markvanderloo/stringdist">https://github.com/markvanderloo/stringdist</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/markvanderloo/stringdist/issues">https://github.com/markvanderloo/stringdist/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>tinytest</td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-10 09:51:08 UTC; mark</td>
</tr>
<tr>
<td>Author:</td>
<td>Mark van der Loo <a href="https://orcid.org/0000-0002-9807-4686"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Jan van der Laan [ctb],
  R Core Team [ctb],
  Nick Logan [ctb],
  Chris Muir [ctb],
  Johannes Gruber [ctb],
  Brian Ripley [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-10 10:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='stringdist-package'>A package for string distance calculation and approximate string matching.</h2><span id='topic+stringdist-package'></span>

<h3>Description</h3>

<p>The <span class="pkg">stringdist</span> package offers fast and platform-independent string
metrics. Its main purpose is to compute various string distances and to do 
approximate text matching between character vectors. As of version 0.9.3,
it is also possible to compute distances between sequences represented by
integer vectors.
</p>


<h3>Details</h3>

<p>A typical use is to match strings that are not precisely the same. For
example
</p>
<p><code>  amatch(c("hello","g'day"),c("hi","hallo","ola"),maxDist=2)</code>
</p>
<p>returns <code>c(2,NA)</code> since <code>"hello"</code> matches closest with
<code>"hallo"</code>, and within the maximum (optimal string alignment) distance.
The second element, <code>"g'day"</code>, matches closest with <code>"ola"</code> but
since the distance equals 4, no match is reported.
</p>
<p>A second typical use is to compute string distances. For example 
</p>
<p><code>  stringdist(c("g'day"),c("hi","hallo","ola"))</code>
</p>
<p>Returns <code>c(5,5,4)</code> since these are the distances between <code>"g'day"</code>
and respectively <code>"hi"</code>, <code>"hallo"</code>, and <code>"ola"</code>.
</p>
<p>A third typical use would be to compute a <code>dist</code> object. The command
</p>
<p><code>stringdistmatrix(c("foo","bar","boo","baz"))</code>
</p>
<p>returns an object of class <code>dist</code> that can be used by clustering
algorithms such as <code>stats::hclust</code>.
</p>
<p>A fourth use is to compute string distances between general sequences,
represented as integer vectors (which must be stored in a <code>list</code>):
</p>
<p><code>seq_dist( list(c(1L,1L,2L)), list(c(1L,2L,1L),c(2L,3L,1L,2L)) )</code>
</p>
<p>The above code yields the vector <code>c(1,2)</code> (the first shorter first
argument is recycled over the longer second argument)
</p>
<p>Besides documentation for each function, the main topics documented are:
</p>

<ul>
<li><p><code><a href="#topic+stringdist-metrics">stringdist-metrics</a></code> &ndash; string metrics supported by the package
</p>
</li>
<li><p><code><a href="#topic+stringdist-encoding">stringdist-encoding</a></code> &ndash; how encoding is handled by the package
</p>
</li>
<li><p><code><a href="#topic+stringdist-parallelization">stringdist-parallelization</a></code> &ndash; on multithreading 
</p>
</li></ul>



<h3>Acknowledgements</h3>


<ul>
<li><p>The code for the full Damerau-Levenshtein distance was adapted from Nick Logan's
<a href="https://github.com/ugexe/Text--Levenshtein--Damerau--XS/blob/master/damerau-int.c">public github repository</a>.
</p>
</li>
<li><p>C code for converting UTF-8 to integer was copied from the R core for performance reasons.
</p>
</li>
<li><p>The code for soundex conversion and string similarity was kindly contributed by Jan van der Laan.
</p>
</li></ul>



<h3>Citation</h3>

<p>If you would like to cite this package, please cite the <a href="https://journal.r-project.org/archive/2014-1/loo.pdf">R Journal Paper</a>: 
</p>

<ul>
<li><p>M.P.J. van der Loo (2014). The <code>stringdist</code> package for approximate string matching. 
R Journal 6(1) pp 111-122
</p>
</li></ul>

<p>Or use <code>citation('stringdist')</code> to get a bibtex item.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Mark van der Loo <a href="mailto:mark.vanderloo@gmail.com">mark.vanderloo@gmail.com</a> (<a href="https://orcid.org/0000-0002-9807-4686">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Jan van der Laan [contributor]
</p>
</li>
<li><p> R Core Team [contributor]
</p>
</li>
<li><p> Nick Logan [contributor]
</p>
</li>
<li><p> Chris Muir [contributor]
</p>
</li>
<li><p> Johannes Gruber [contributor]
</p>
</li>
<li><p> Brian Ripley [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/markvanderloo/stringdist">https://github.com/markvanderloo/stringdist</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/markvanderloo/stringdist/issues">https://github.com/markvanderloo/stringdist/issues</a>
</p>
</li></ul>


<hr>
<h2 id='afind'>Stringdist-based fuzzy text search</h2><span id='topic+afind'></span><span id='topic+grab'></span><span id='topic+grabl'></span><span id='topic+extract'></span>

<h3>Description</h3>

<p><code>afind</code> slides a window of fixed width over a string <code>x</code> and
computes the distance between the each window and the sought-after
<code>pattern</code>. The location, content, and distance corresponding to the
window with the best match is returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>afind(
  x,
  pattern,
  window = NULL,
  value = TRUE,
  method = c("osa", "lv", "dl", "hamming", "lcs", "qgram", "cosine", "running_cosine",
    "jaccard", "jw", "soundex"),
  useBytes = FALSE,
  weight = c(d = 1, i = 1, s = 1, t = 1),
  q = 1,
  p = 0,
  bt = 0,
  nthread = getOption("sd_num_thread")
)

grab(x, pattern, maxDist = Inf, value = FALSE, ...)

grabl(x, pattern, maxDist = Inf, ...)

extract(x, pattern, maxDist = Inf, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="afind_+3A_x">x</code></td>
<td>
<p>strings to search in</p>
</td></tr>
<tr><td><code id="afind_+3A_pattern">pattern</code></td>
<td>
<p>strings to find (not a regular expression). For <code>grab</code>,
<code>grabl</code>, and <code>extract</code> this must be a single string.</p>
</td></tr>
<tr><td><code id="afind_+3A_window">window</code></td>
<td>
<p>width of moving window.</p>
</td></tr>
<tr><td><code id="afind_+3A_value">value</code></td>
<td>
<p>toggle return matrix with matched strings.</p>
</td></tr>
<tr><td><code id="afind_+3A_method">method</code></td>
<td>
<p>Matching algorithm to use. See <code><a href="#topic+stringdist-metrics">stringdist-metrics</a></code>.</p>
</td></tr>
<tr><td><code id="afind_+3A_usebytes">useBytes</code></td>
<td>
<p>Perform byte-wise comparison. See <code><a href="#topic+stringdist-encoding">stringdist-encoding</a></code>.</p>
</td></tr>
<tr><td><code id="afind_+3A_weight">weight</code></td>
<td>
<p>For <code>method='osa'</code> or <code>'dl'</code>, the penalty for
deletion, insertion, substitution and transposition, in that order. When
<code>method='lv'</code>, the penalty for transposition is ignored. When
<code>method='jw'</code>, the weights associated with characters of <code>a</code>,
characters from <code>b</code> and the transposition weight, in that order. 
Weights must be positive and not exceed 1. <code>weight</code> is ignored
completely when <code>method='hamming'</code>, <code>'qgram'</code>, <code>'cosine'</code>,
<code>'Jaccard'</code>, <code>'lcs'</code>, or <code>'soundex'</code>.</p>
</td></tr>
<tr><td><code id="afind_+3A_q">q</code></td>
<td>
<p>q-gram size, only when method is <code>'qgram'</code>, <code>'jaccard'</code>,
or <code>'cosine'</code>.</p>
</td></tr>
<tr><td><code id="afind_+3A_p">p</code></td>
<td>
<p>Winklers 'prefix' parameter for Jaro-Winkler distance, with
<code class="reqn">0\leq p\leq0.25</code>. Only when method is <code>'jw'</code></p>
</td></tr>
<tr><td><code id="afind_+3A_bt">bt</code></td>
<td>
<p>Winkler's boost threshold. Winkler's prefix factor is
only applied when the Jaro distance is larger than <code>bt</code>.
Applies only to <code>method='jw'</code> and <code>p&gt;0</code>.</p>
</td></tr>
<tr><td><code id="afind_+3A_nthread">nthread</code></td>
<td>
<p>Number of threads used by the underlying C-code. A sensible
default is chosen, see <code><a href="#topic+stringdist-parallelization">stringdist-parallelization</a></code>.</p>
</td></tr>
<tr><td><code id="afind_+3A_maxdist">maxDist</code></td>
<td>
<p>Only windows with distance <code>&lt;= maxDist</code> are considered a match.</p>
</td></tr>
<tr><td><code id="afind_+3A_...">...</code></td>
<td>
<p>passed to <code>afind</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Matching is case-sensitive.  Both <code>x</code> and <code>pattern</code> are converted
to <code>UTF-8</code> prior to search, unless <code>useBytes=TRUE</code>, in which case
the distances are measured bytewise.
</p>
<p>Code is parallelized over the <code>x</code> variable: each value of <code>x</code>
is scanned for every element in <code>pattern</code> using a separate thread (when <code>nthread</code>
is larger than 1).
</p>
<p>The functions <code>grab</code> and <code>grabl</code> are approximate string matching
functions that somewhat resemble base R's <code><a href="base.html#topic+grep">grep</a></code> and
<code><a href="base.html#topic+grep">grepl</a></code>. They are implemented as convenience wrappers
of <code>afind</code>.
</p>


<h3>Value</h3>

<p>For <code>afind</code>: a <code>list</code> of three matrices, each with
<code>length(x)</code> rows and <code>length(pattern)</code> columns. In each matrix,
element <code class="reqn">(i,j)</code> corresponds to <code>x[i]</code> and <code>pattern[j]</code>. The 
names and description of each matrix is as follows.
</p>

<ul>
<li><p><code>location</code>. <code>[integer]</code>, location of the start of best matching window.
When <code>useBytes=FALSE</code>, this corresponds to the location of a <code>UTF</code> code point
in <code>x</code>, possibly after conversion from its original encoding.
</p>
</li>
<li><p><code>distance</code>. <code>[character]</code>, the string distance between pattern and
the best matching window.
</p>
</li>
<li><p><code>match</code>. <code>[character]</code>, the first, best matching window.
</p>
</li></ul>

<p>For <code>grab</code>, an <code>integer</code> vector, indicating in which elements of
<code>x</code> a match was found with a distance <code>&lt;= maxDist</code>. The matched
values when <code>value=TRUE</code> (equivalent to <code><a href="base.html#topic+grep">grep</a></code>).
</p>
<p>For <code>grabl</code>, a <code>logical</code> vector, indicating in which elements of
<code>x</code> a match was found with a distance <code>&lt;= maxDist</code>.  (equivalent
to <code><a href="base.html#topic+grep">grepl</a></code>).
</p>
<p>For <code>extract</code>, a <code>character</code> matrix with <code>length(x)</code> rows and
<code>length(pattern)</code> columns.  If match was found, element <code class="reqn">(i,j)</code>
contains the match, otherwise it is set to <code>NA</code>.
</p>


<h3>Running cosine distance</h3>

<p>This algorithm gains efficiency by using that two consecutive windows have
a large overlap in their q-gram profiles. It gives the same result as
the <code>"cosine"</code> distance, but much faster.
</p>


<h3>See Also</h3>

<p>Other matching: 
<code><a href="#topic+amatch">amatch</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>texts = c("When I grow up, I want to be"
       , "one of the harvesters of the sea"
       , "I think before my days are gone"
       , "I want to be a fisherman")
patterns = c("fish", "gone","to be")

afind(texts, patterns, method="running_cosine", q=3)

grabl(texts,"grew", maxDist=1)
extract(texts, "harvested", maxDist=3)


</code></pre>

<hr>
<h2 id='amatch'>Approximate string matching</h2><span id='topic+amatch'></span><span id='topic+ain'></span>

<h3>Description</h3>

<p>Approximate string matching equivalents of <code>R</code>'s native
<code><a href="base.html#topic+match">match</a></code> and <code>%in%</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>amatch(
  x,
  table,
  nomatch = NA_integer_,
  matchNA = TRUE,
  method = c("osa", "lv", "dl", "hamming", "lcs", "qgram", "cosine", "jaccard", "jw",
    "soundex"),
  useBytes = FALSE,
  weight = c(d = 1, i = 1, s = 1, t = 1),
  maxDist = 0.1,
  q = 1,
  p = 0,
  bt = 0,
  nthread = getOption("sd_num_thread")
)

ain(x, table, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="amatch_+3A_x">x</code></td>
<td>
<p>elements to be approximately matched: will be coerced to 
<code>character</code> unless it is a list consisting of <code>integer</code> vectors.</p>
</td></tr>
<tr><td><code id="amatch_+3A_table">table</code></td>
<td>
<p>lookup table for matching. Will be coerced to <code>character</code>
unless it is a list consting of <code>integer</code> vectors.</p>
</td></tr>
<tr><td><code id="amatch_+3A_nomatch">nomatch</code></td>
<td>
<p>The value to be returned when no match is found. This is
coerced to integer.</p>
</td></tr>
<tr><td><code id="amatch_+3A_matchna">matchNA</code></td>
<td>
<p>Should <code>NA</code>'s be matched? Default behaviour mimics the 
behaviour of base <code><a href="base.html#topic+match">match</a></code>, meaning that <code>NA</code> matches
<code>NA</code> (see also the note on <code>NA</code> handling below).</p>
</td></tr>
<tr><td><code id="amatch_+3A_method">method</code></td>
<td>
<p>Matching algorithm to use. See <code><a href="#topic+stringdist-metrics">stringdist-metrics</a></code>.</p>
</td></tr>
<tr><td><code id="amatch_+3A_usebytes">useBytes</code></td>
<td>
<p>Perform byte-wise comparison. See <code><a href="#topic+stringdist-encoding">stringdist-encoding</a></code>.</p>
</td></tr>
<tr><td><code id="amatch_+3A_weight">weight</code></td>
<td>
<p>For <code>method='osa'</code> or <code>'dl'</code>, the penalty for
deletion, insertion, substitution and transposition, in that order. When
<code>method='lv'</code>, the penalty for transposition is ignored. When
<code>method='jw'</code>, the weights associated with characters of <code>a</code>,
characters from <code>b</code> and the transposition weight, in that order. 
Weights must be positive and not exceed 1. <code>weight</code> is ignored
completely when <code>method='hamming'</code>, <code>'qgram'</code>, <code>'cosine'</code>,
<code>'Jaccard'</code>, <code>'lcs'</code>, or <code>'soundex'</code>.</p>
</td></tr>
<tr><td><code id="amatch_+3A_maxdist">maxDist</code></td>
<td>
<p>Elements in <code>x</code> will not be matched with elements of 
<code>table</code> if their distance is larger than <code>maxDist</code>. Note that the
maximum distance between strings depends on the method: it should always be
specified.</p>
</td></tr>
<tr><td><code id="amatch_+3A_q">q</code></td>
<td>
<p>q-gram size, only when method is <code>'qgram'</code>, <code>'jaccard'</code>,
or <code>'cosine'</code>.</p>
</td></tr>
<tr><td><code id="amatch_+3A_p">p</code></td>
<td>
<p>Winklers 'prefix' parameter for Jaro-Winkler distance, with
<code class="reqn">0\leq p\leq0.25</code>. Only when method is <code>'jw'</code></p>
</td></tr>
<tr><td><code id="amatch_+3A_bt">bt</code></td>
<td>
<p>Winkler's boost threshold. Winkler's prefix factor is
only applied when the Jaro distance is larger than <code>bt</code>.
Applies only to <code>method='jw'</code> and <code>p&gt;0</code>.</p>
</td></tr>
<tr><td><code id="amatch_+3A_nthread">nthread</code></td>
<td>
<p>Number of threads used by the underlying C-code. A sensible
default is chosen, see <code><a href="#topic+stringdist-parallelization">stringdist-parallelization</a></code>.</p>
</td></tr>
<tr><td><code id="amatch_+3A_...">...</code></td>
<td>
<p>parameters to pass to <code>amatch</code> (except <code>nomatch</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ain</code> is currently defined as 
</p>
<p><code>ain(x,table,...) &lt;- function(x,table,...) amatch(x, table, nomatch=0,...) &gt; 0</code>
</p>


<h3>Value</h3>

<p><code>amatch</code> returns the position of the closest match of <code>x</code>
in <code>table</code>. When multiple matches with the same smallest distance
metric exist, the first one is returned. <code>ain</code> returns a
<code>logical</code> vector of length <code>length(x)</code> indicating wether an
element of <code>x</code> approximately matches an element in <code>table</code>.
</p>


<h3>Note on <code>NA</code> handling</h3>

<p><code>R</code>'s native <code><a href="base.html#topic+match">match</a></code> function matches <code>NA</code> with
<code>NA</code>. This may feel inconsistent with <code>R</code>'s usual <code>NA</code>
handling, since for example <code>NA==NA</code> yields
<code>NA</code> rather than <code>TRUE</code>. In most cases, one may reason about the
behaviour under <code>NA</code> along the lines of &ldquo;if one of the arguments is
<code>NA</code>, the result shall be <code>NA</code>&rdquo;, simply because not all
information necessary to execute the function is available. One uses special 
functions such as <code>is.na</code>, <code>is.null</code> <em>etc.</em> to handle special
values.
</p>
<p>The <code>amatch</code> function mimics the behaviour of <code><a href="base.html#topic+match">match</a></code>
by default: <code>NA</code> is matched with <code>NA</code> and with nothing else. Note
that this is inconsistent with the behaviour of <code><a href="#topic+stringdist">stringdist</a></code> 
since <code>stringdist</code> yields <code>NA</code> when at least one of the arguments
is <code>NA</code>. The same inconsistency exists between <code><a href="base.html#topic+match">match</a></code>
and <code><a href="utils.html#topic+adist">adist</a></code>. In <code>amatch</code> this behaviour can be
controlled by setting <code>matchNA=FALSE</code>. In that case, if any of the
arguments in <code>x</code> is <code>NA</code>, the <code>nomatch</code> value is returned,
regardless of whether <code>NA</code> is present in <code>table</code>. In
<code><a href="base.html#topic+match">match</a></code> the behaviour can be controlled by setting the
<code>incomparables</code> option.
</p>


<h3>See Also</h3>

<p>Other matching: 
<code><a href="#topic+afind">afind</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# lets see which sci-fi heroes are stringdistantly nearest
amatch("leia",c("uhura","leela"),maxDist=5)

# we can restrict the search
amatch("leia",c("uhura","leela"),maxDist=1)

# we can match each value in the find vector against values in the lookup table:
amatch(c("leia","uhura"),c("ripley","leela","scully","trinity"),maxDist=2)

# setting nomatch returns a different value when no match is found
amatch("leia",c("uhura","leela"),maxDist=1,nomatch=0)

# this is always true if maxDist is Inf
ain("leia",c("uhura","leela"),maxDist=Inf)

# Let's look in a neighbourhood of maximum 2 typo's (by default, the OSA algorithm is used)
ain("leia",c("uhura","leela"), maxDist=2)


</code></pre>

<hr>
<h2 id='phonetic'>Phonetic algorithms</h2><span id='topic+phonetic'></span>

<h3>Description</h3>

<p>Translate strings to phonetic codes. Similar sounding strings should get 
similar or equal codes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phonetic(x, method = c("soundex"), useBytes = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="phonetic_+3A_x">x</code></td>
<td>
<p>a character vector whose elements are phonetically encoded.</p>
</td></tr>
<tr><td><code id="phonetic_+3A_method">method</code></td>
<td>
<p>name of the algorithm used. The default is <code>"soundex"</code>.</p>
</td></tr>
<tr><td><code id="phonetic_+3A_usebytes">useBytes</code></td>
<td>
<p>Perform byte-wise comparison. <code>useBytes=TRUE</code> is faster 
but may yield different results depending on character encoding. For more
information see the documentation of <code><a href="#topic+stringdist">stringdist</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Currently, only the soundex algorithm is implemented. Note that soundex coding
is only meaningful for characters in the ranges a-z and A-Z. Soundex coding of strings 
containing non-printable ascii or non-ascii characters may be system-dependent and should 
not be trusted. If non-ascii or non-printable ascii charcters are encountered, a warning 
is emitted.
</p>


<h3>Value</h3>

<p>The returns value depends on the method used. However, all currently 
implemented methods return a character vector of the same length of the input
vector. Output characters are in the system's native encoding.
</p>


<h3>References</h3>


<ul>
<li><p>The Soundex algorithm implemented is the algorithm used by the 
<a href="https://www.archives.gov/research/census/soundex">National Archives</a>. 
This algorithm differs slightly from the original algorithm patented by R.C. Russell 
(US patents 1261167 (1918) and 1435663 (1922)). 

</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+printable_ascii">printable_ascii</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># The following examples are from The Art of Computer Programming (part III, p. 395)
# (Note that our algorithm is specified different from the one in TACP, see references.)
phonetic(c('Euler','Gauss','Hilbert','Knuth','Lloyd','Lukasiewicz','Wachs'),method='soundex')


</code></pre>

<hr>
<h2 id='printable_ascii'>Detect the presence of non-printable or non-ascii characters</h2><span id='topic+printable_ascii'></span>

<h3>Description</h3>

<p>Detect the presence of non-printable or non-ascii characters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>printable_ascii(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="printable_ascii_+3A_x">x</code></td>
<td>
<p>a <code>character</code> vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Printable ASCII characters consist of space, <code>A-Z</code>, <code>a-z</code>, <code>0-9</code> and the characters
</p>
<p><code>! "" # $ % &amp; ' ( ) * + , . / : ; &lt; = &gt; ? @ [ ] \ ^ _ ` { | } ~ -</code> 
</p>
<p>Note that this excludes tab (as it is a control character).
</p>


<h3>Value</h3>

<p>A <code>logical</code> indicating which elements consist solely of printable ASCII characters.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># define o-umlaut
ouml &lt;- intToUtf8("0x00F6")
x &lt;- c("Motorhead", paste0("Mot",ouml,"rhead"))
# second element contains a non-ascii character
printable_ascii(x)

# Control characters (like carriage return) are also excluded
printable_ascii("abc\r")


</code></pre>

<hr>
<h2 id='qgrams'>Get a table of qgram counts from one or more character vectors.</h2><span id='topic+qgrams'></span>

<h3>Description</h3>

<p>Get a table of qgram counts from one or more character vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qgrams(..., .list = NULL, q = 1L, useBytes = FALSE, useNames = !useBytes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="qgrams_+3A_...">...</code></td>
<td>
<p>any number of (named) arguments, that will be coerced to character with <code>as.character</code>.</p>
</td></tr>
<tr><td><code id="qgrams_+3A_.list">.list</code></td>
<td>
<p>Will be concatenated with the <code>...</code> argument(s). Useful for adding character vectors named <code>'q'</code> or <code>'useNames'</code>.</p>
</td></tr>
<tr><td><code id="qgrams_+3A_q">q</code></td>
<td>
<p>size of q-gram, must be non-negative.</p>
</td></tr>
<tr><td><code id="qgrams_+3A_usebytes">useBytes</code></td>
<td>
<p>Determine byte-wise qgrams. <code>useBytes=TRUE</code> is faster but may yield different
results depending on character encoding. For <code>ASCII</code> it is identical. See also <code><a href="#topic+stringdist">stringdist</a></code> under Encoding issues.</p>
</td></tr>
<tr><td><code id="qgrams_+3A_usenames">useNames</code></td>
<td>
<p>Add q-grams as column names. If <code>useBytes=useNames=TRUE</code>, the q-byte sequences are represented as 2 hexadecimal numbers
per byte, separated by a vertical bar (<code>|</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A table with <code class="reqn">q</code>-gram counts. Detected <code class="reqn">q</code>-grams are column names and the argument names as row names.
If no argument names were provided, they will be generated.
</p>


<h3>Details</h3>

<p>The input is converted to <code>character</code>. If <code>useBytes=TRUE</code>, each element is 
converted to <code>utf8</code> and then to <code>integer</code> as in <code><a href="#topic+stringdist">stringdist</a></code>. 
Next,the data is passed to the underlying routine.
</p>
<p>Strings with less than <code>q</code> characters and elements containing <code>NA</code> are skipped. Using <code>q=0</code> 
therefore counts the number of empty strings <code>""</code> occuring in each argument.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stringdist">stringdist</a></code>, <code><a href="#topic+amatch">amatch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
qgrams('hello world',q=3)

# q-grams are counted uniquely over a character vector
qgrams(rep('hello world',2),q=3)

# to count them separately, do something like
x &lt;- c('hello', 'world')
lapply(x,qgrams, q=3)

# output rows may be named, and you can pass any number of character vectors
x &lt;- "I will not buy this record, it is scratched"
y &lt;- "My hovercraft is full of eels"
z &lt;- c("this", "is", "a", "dead","parrot")
qgrams(A = x, B = y, C = z,q=2)

# a tonque twister, showing the effects of useBytes and useNames
x &lt;- "peter piper picked a peck of pickled peppers"
qgrams(x, q=2) 
qgrams(x, q=2, useNames=FALSE) 
qgrams(x, q=2, useBytes=TRUE)
qgrams(x, q=2, useBytes=TRUE, useNames=TRUE)




</code></pre>

<hr>
<h2 id='seq_amatch'>Approximate matching for integer sequences.</h2><span id='topic+seq_amatch'></span><span id='topic+seq_ain'></span>

<h3>Description</h3>

<p>For a <code>list</code> of integer vectors <code>x</code>, find the closest matches in a
<code>list</code> of integer or numeric vectors in <code>table.</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_amatch(
  x,
  table,
  nomatch = NA_integer_,
  matchNA = TRUE,
  method = c("osa", "lv", "dl", "hamming", "lcs", "qgram", "cosine", "jaccard", "jw"),
  weight = c(d = 1, i = 1, s = 1, t = 1),
  maxDist = 0.1,
  q = 1,
  p = 0,
  bt = 0,
  nthread = getOption("sd_num_thread")
)

seq_ain(x, table, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seq_amatch_+3A_x">x</code></td>
<td>
<p>(<code>list</code> of) <code>integer</code> or <code>numeric</code> vector(s) to be
approximately matched. Will be converted with <code>as.integer</code>.</p>
</td></tr>
<tr><td><code id="seq_amatch_+3A_table">table</code></td>
<td>
<p>(<code>list</code> of) <code>integer</code> or <code>numeric</code> vector(s)
serving as lookup table for matching. Will be converted with
<code>as.integer</code>.</p>
</td></tr>
<tr><td><code id="seq_amatch_+3A_nomatch">nomatch</code></td>
<td>
<p>The value to be returned when no match is found. This is
coerced to integer.</p>
</td></tr>
<tr><td><code id="seq_amatch_+3A_matchna">matchNA</code></td>
<td>
<p>Should <code>NA</code>'s be matched? Default behaviour mimics the 
behaviour of base <code><a href="base.html#topic+match">match</a></code>, meaning that <code>NA</code> matches
<code>NA</code>. With <code>NA</code>, we mean a missing entry in the <code>list</code>, represented as <code>NA_integer_</code>. 
If one of the integer sequences stored in the list has an <code>NA</code> entry,
this is just treated as another integer (the representation of
<code>NA_integer_</code>).</p>
</td></tr>
<tr><td><code id="seq_amatch_+3A_method">method</code></td>
<td>
<p>Matching algorithm to use. See <code><a href="#topic+stringdist-metrics">stringdist-metrics</a></code>.</p>
</td></tr>
<tr><td><code id="seq_amatch_+3A_weight">weight</code></td>
<td>
<p>For <code>method='osa'</code> or <code>'dl'</code>, the penalty for
deletion, insertion, substitution and transposition, in that order. When
<code>method='lv'</code>, the penalty for transposition is ignored. When
<code>method='jw'</code>, the weights associated with integers in elements of <code>a</code>,
integers in elements of <code>b</code> and the transposition weight, in that order. 
Weights must be positive and not exceed 1. <code>weight</code> is ignored
completely when <code>method='hamming'</code>, <code>'qgram'</code>, <code>'cosine'</code>,
<code>'Jaccard'</code>, or <code>'lcs'</code>.</p>
</td></tr>
<tr><td><code id="seq_amatch_+3A_maxdist">maxDist</code></td>
<td>
<p>Elements in <code>x</code> will not be matched with elements of 
<code>table</code> if their distance is larger than <code>maxDist</code>. Note that the
maximum distance between strings depends on the method: it should always be
specified.</p>
</td></tr>
<tr><td><code id="seq_amatch_+3A_q">q</code></td>
<td>
<p>q-gram size, only when method is <code>'qgram'</code>, <code>'jaccard'</code>,
or <code>'cosine'</code>.</p>
</td></tr>
<tr><td><code id="seq_amatch_+3A_p">p</code></td>
<td>
<p>Winkler's prefix parameter for Jaro-Winkler distance, with
<code class="reqn">0\leq p\leq0.25</code>. Only when method is <code>'jw'</code></p>
</td></tr>
<tr><td><code id="seq_amatch_+3A_bt">bt</code></td>
<td>
<p>Winkler's boost threshold. Winkler's prefix factor is
only applied when the Jaro distance is larger than <code>bt</code>.
Applies only to <code>method='jw'</code> and <code>p&gt;0</code>.</p>
</td></tr>
<tr><td><code id="seq_amatch_+3A_nthread">nthread</code></td>
<td>
<p>Number of threads used by the underlying C-code. A sensible
default is chosen, see <code><a href="#topic+stringdist-parallelization">stringdist-parallelization</a></code>.</p>
</td></tr>
<tr><td><code id="seq_amatch_+3A_...">...</code></td>
<td>
<p>parameters to pass to <code>seq_amatch</code> (except <code>nomatch</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>seq_amatch</code> returns the position of the closest match of <code>x</code>
in <code>table</code>. When multiple matches with the same minimal distance
metric exist, the first one is returned. <code>seq_ain</code> returns a
<code>logical</code> vector of length <code>length(x)</code> indicating wether an
element of <code>x</code> approximately matches an element in <code>table</code>.
</p>


<h3>Notes</h3>

<p><code>seq_ain</code> is currently defined as 
</p>
<p><code>seq_ain(x,table,...) &lt;- function(x,table,...) amatch(x, table, nomatch=0,...) &gt; 0</code>
</p>
<p>All input vectors are converted with <code>as.integer</code>. This causes truncation for numeric
vectors (e.g. <code>pi</code> will be treated as <code>3L</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seq_dist">seq_dist</a></code>, <code><a href="#topic+seq_sim">seq_sim</a></code>, <code><a href="#topic+seq_qgrams">seq_qgrams</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- list(1:3,c(3:1),c(1L,3L,4L))
table &lt;- list(
  c(5L,3L,1L,2L)
  ,1:4
)
seq_amatch(x,table,maxDist=2)

# behaviour with missings
seq_amatch(list(c(1L,NA_integer_,3L),NA_integer_), list(1:3),maxDist=1)


## Not run: 
# Match sentences based on word order. Note: words must match exactly or they
# are treated as completely different.
#
# For this example you need to have the 'hashr' package installed.
x &lt;- "Mary had a little lamb"
x.words &lt;- strsplit(x,"[[:blank:]]+")
x.int &lt;- hashr::hash(x.words)
table &lt;- c("a little lamb had Mary",
           "had Mary a little lamb")
table.int &lt;- hashr::hash(strsplit(table,"[[:blank:]]+"))
seq_amatch(x.int,table.int,maxDist=3)

## End(Not run)
</code></pre>

<hr>
<h2 id='seq_dist'>Compute distance metrics between integer sequences</h2><span id='topic+seq_dist'></span><span id='topic+seq_distmatrix'></span>

<h3>Description</h3>

<p><code>seq_dist</code> computes pairwise string distances between elements of 
<code>a</code> and <code>b</code>, where the argument with less elements is recycled. 
<code>seq_distmatrix</code> computes the distance matrix with rows according to
<code>a</code> and columns according to <code>b</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_dist(
  a,
  b,
  method = c("osa", "lv", "dl", "hamming", "lcs", "qgram", "cosine", "jaccard", "jw"),
  weight = c(d = 1, i = 1, s = 1, t = 1),
  q = 1,
  p = 0,
  bt = 0,
  nthread = getOption("sd_num_thread")
)

seq_distmatrix(
  a,
  b,
  method = c("osa", "lv", "dl", "hamming", "lcs", "qgram", "cosine", "jaccard", "jw"),
  weight = c(d = 1, i = 1, s = 1, t = 1),
  q = 1,
  p = 0,
  bt = 0,
  useNames = c("names", "none"),
  nthread = getOption("sd_num_thread")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seq_dist_+3A_a">a</code></td>
<td>
<p>(<code>list</code> of) <code>integer</code> or <code>numeric</code> vector(s). Will be converted with <code>as.integer</code>  (target)</p>
</td></tr>
<tr><td><code id="seq_dist_+3A_b">b</code></td>
<td>
<p>(<code>list</code> of) <code>integer</code> or <code>numeric</code> vector(s). Will be converted with <code>as.integer</code> (source). 
Optional for <code>seq_distmatrix</code>.</p>
</td></tr>
<tr><td><code id="seq_dist_+3A_method">method</code></td>
<td>
<p>Distance metric. See <code><a href="#topic+stringdist-metrics">stringdist-metrics</a></code></p>
</td></tr>
<tr><td><code id="seq_dist_+3A_weight">weight</code></td>
<td>
<p>For <code>method='osa'</code> or <code>'dl'</code>, the penalty for
deletion, insertion, substitution and transposition, in that order. When
<code>method='lv'</code>, the penalty for transposition is ignored. When
<code>method='jw'</code>, the weights associated with characters of <code>a</code>,
characters from <code>b</code> and the transposition weight, in that order. 
Weights must be positive and not exceed 1. <code>weight</code> is ignored
completely when <code>method='hamming'</code>, <code>'qgram'</code>, <code>'cosine'</code>,
<code>'Jaccard'</code>, or <code>'lcs'</code></p>
</td></tr>
<tr><td><code id="seq_dist_+3A_q">q</code></td>
<td>
<p>Size of the <code class="reqn">q</code>-gram; must be nonnegative. Only applies to
<code>method='qgram'</code>, <code>'jaccard'</code> or <code>'cosine'</code>.</p>
</td></tr>
<tr><td><code id="seq_dist_+3A_p">p</code></td>
<td>
<p>Prefix factor for Jaro-Winkler distance. The valid range for 
<code>p</code> is <code>0 &lt;= p &lt;= 0.25</code>. If <code>p=0</code> (default), the
Jaro-distance is returned. Applies only to <code>method='jw'</code>.</p>
</td></tr>
<tr><td><code id="seq_dist_+3A_bt">bt</code></td>
<td>
<p>Winkler's boost threshold. Winkler's prefix factor is
only applied when the Jaro distance is larger than <code>bt</code>
Applies only to <code>method='jw'</code> and <code>p&gt;0</code>.</p>
</td></tr>
<tr><td><code id="seq_dist_+3A_nthread">nthread</code></td>
<td>
<p>Maximum number of threads to use. By default, a sensible
number of threads is chosen, see <code><a href="#topic+stringdist-parallelization">stringdist-parallelization</a></code>.</p>
</td></tr>
<tr><td><code id="seq_dist_+3A_usenames">useNames</code></td>
<td>
<p>label the output matrix with <code>names(a)</code> and <code>names(b)</code>?</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>seq_dist</code> returns a numeric vector with pairwise distances between <code>a</code>
and <code>b</code> of length <code>max(length(a),length(b)</code>.
</p>
<p>For <code>seq_distmatrix</code> there are two options. If <code>b</code> is missing, the 
<code><a href="stats.html#topic+dist">dist</a></code> object corresponding to the <code>length(a) X
length(a)</code> distance matrix is returned. If <code>b</code> is specified, the
<code>length(a) X length(b)</code> distance matrix is returned.
</p>
<p>If any element of <code>a</code> or <code>b</code> is <code>NA_integer_</code>, the distance with
any matched integer vector will result in <code>NA</code>. Missing values in the sequences
themselves are treated as a number and not treated specially (Also see the examples).
</p>


<h3>Notes</h3>

<p>Input vectors are converted with <code>as.integer</code>. This causes truncation for numeric
vectors (e.g. <code>pi</code> will be treated as <code>3L</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seq_sim">seq_sim</a></code>, <code><a href="#topic+seq_amatch">seq_amatch</a></code>, <code><a href="#topic+seq_qgrams">seq_qgrams</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Distances between lists of integer vectors. Note the postfix 'L' to force 
# integer storage. The shorter argument is recycled over (\code{a})
a &lt;- list(c(102L, 107L))                        # fu
b &lt;- list(c(102L,111L,111L),c(102L,111L,111L))  # foo, fo
seq_dist(a,b)

# translate strings to a list of integer sequences 
a &lt;- lapply(c("foo","bar","baz"),utf8ToInt)
seq_distmatrix(a)

# Note how missing values are treated. NA's as part of the sequence are treated 
# as an integer (the representation of NA_integer_).
a &lt;- list(NA_integer_,c(102L, 107L))
b &lt;- list(c(102L,111L,111L),c(102L,111L,NA_integer_))  
seq_dist(a,b)

## Not run: 
# Distance between sentences based on word order. Note: words must match exactly or they
# are treated as completely different.
#
# For this example you need to have the 'hashr' package installed.
a &lt;- "Mary had a little lamb"
a.words &lt;- strsplit(a,"[[:blank:]]+")
a.int &lt;- hashr::hash(a.words)
b &lt;- c("a little lamb had Mary",
           "had Mary a little lamb")
b.int &lt;- hashr::hash(strsplit(b,"[[:blank:]]+"))
seq_dist(a.int,b.int)

## End(Not run)

</code></pre>

<hr>
<h2 id='seq_qgrams'>Get a table of qgram counts for integer sequences</h2><span id='topic+seq_qgrams'></span>

<h3>Description</h3>

<p>Get a table of qgram counts for integer sequences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_qgrams(..., .list = NULL, q = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seq_qgrams_+3A_...">...</code></td>
<td>
<p>Any number of (named) arguments that will be coerced with <code>as.integer</code></p>
</td></tr>
<tr><td><code id="seq_qgrams_+3A_.list">.list</code></td>
<td>
<p>Will be concatenated with the <code>...</code> argument(s). Useful for adding integer vectors named 'q'.</p>
</td></tr>
<tr><td><code id="seq_qgrams_+3A_q">q</code></td>
<td>
<p>The size of q-gramming.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> containing q-gram profiles. Columns 1 to <code>q</code> contain the
encountered q-grams. The ensuing (named) columns contain the q-gram counts
per vector. Run the example for a simple overview.
</p>
<p>Missing values in integer sequences are treated as any other number.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seq_dist">seq_dist</a></code>, <code><a href="#topic+seq_amatch">seq_amatch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# compare the 2-gram overlap between sequences 1:3 and 2:4
seq_qgrams(x = 1:3, y=2:4,q=2)

# behavior when NA's are present.
seq_qgrams(1:3,c(1,NA,2),NA_integer_)
</code></pre>

<hr>
<h2 id='seq_sim'>Compute similarity scores between sequences of integers</h2><span id='topic+seq_sim'></span>

<h3>Description</h3>

<p>Compute similarity scores between sequences of integers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>seq_sim(
  a,
  b,
  method = c("osa", "lv", "dl", "hamming", "lcs", "qgram", "cosine", "jaccard", "jw"),
  q = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="seq_sim_+3A_a">a</code></td>
<td>
<p><code>list</code> of <code>integer</code> vectors (target)</p>
</td></tr>
<tr><td><code id="seq_sim_+3A_b">b</code></td>
<td>
<p><code>list</code> of <code>integer</code> vectors (source). Optional for
<code>seq_distmatrix</code>.</p>
</td></tr>
<tr><td><code id="seq_sim_+3A_method">method</code></td>
<td>
<p>Method for distance calculation. The default is <code>"osa"</code>, 
see <code><a href="#topic+stringdist-metrics">stringdist-metrics</a></code>.</p>
</td></tr>
<tr><td><code id="seq_sim_+3A_q">q</code></td>
<td>
<p>Size of the <code class="reqn">q</code>-gram; must be nonnegative. Only applies to
<code>method='qgram'</code>, <code>'jaccard'</code> or <code>'cosine'</code>.</p>
</td></tr>
<tr><td><code id="seq_sim_+3A_...">...</code></td>
<td>
<p>additional arguments are passed on to <code><a href="#topic+seq_dist">seq_dist</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>numeric</code> vector of length <code>max(length(a),length(b))</code>. If one of the
entries in <code>a</code> or <code>b</code> is <code>NA_integer_</code>, all comparisons with that
element result in <code>NA</code>. Missings occurring within the sequences are treated
as an ordinary number (the representation of <code>NA_integer_</code>).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+seq_dist">seq_dist</a></code>, <code><a href="#topic+seq_amatch">seq_amatch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>L1 &lt;- list(1:3,2:4)
L2 &lt;- list(1:3)
seq_sim(L1,L2,method="osa")

# note how missing values are handled (L2 is recycled over L1)
L1 &lt;- list(c(1L,NA_integer_,3L),2:4,NA_integer_)
L2 &lt;- list(1:3)
seq_sim(L1,L2)

</code></pre>

<hr>
<h2 id='stringdist'>Compute distance metrics between strings</h2><span id='topic+stringdist'></span><span id='topic+stringdistmatrix'></span>

<h3>Description</h3>

<p><code>stringdist</code> computes pairwise string distances between elements of
<code>a</code> and <code>b</code>, where the argument with less elements is recycled.
<code>stringdistmatrix</code> computes the string distance matrix with rows
according to
<code>a</code> and columns according to <code>b</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stringdist(
  a,
  b,
  method = c("osa", "lv", "dl", "hamming", "lcs", "qgram", "cosine", "jaccard", "jw",
    "soundex"),
  useBytes = FALSE,
  weight = c(d = 1, i = 1, s = 1, t = 1),
  q = 1,
  p = 0,
  bt = 0,
  nthread = getOption("sd_num_thread")
)

stringdistmatrix(
  a,
  b,
  method = c("osa", "lv", "dl", "hamming", "lcs", "qgram", "cosine", "jaccard", "jw",
    "soundex"),
  useBytes = FALSE,
  weight = c(d = 1, i = 1, s = 1, t = 1),
  q = 1,
  p = 0,
  bt = 0,
  useNames = c("none", "strings", "names"),
  nthread = getOption("sd_num_thread")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stringdist_+3A_a">a</code></td>
<td>
<p>R object (target); will be converted by <code>as.character</code></p>
</td></tr>
<tr><td><code id="stringdist_+3A_b">b</code></td>
<td>
<p>R object (source); will be converted by <code>as.character</code>
This argument is optional for <code>stringdistmatrix</code> (see section <code>Value</code>).</p>
</td></tr>
<tr><td><code id="stringdist_+3A_method">method</code></td>
<td>
<p>Method for distance calculation. The default is <code>"osa"</code>,
see <code><a href="#topic+stringdist-metrics">stringdist-metrics</a></code>.</p>
</td></tr>
<tr><td><code id="stringdist_+3A_usebytes">useBytes</code></td>
<td>
<p>Perform byte-wise comparison, see
<code><a href="#topic+stringdist-encoding">stringdist-encoding</a></code>.</p>
</td></tr>
<tr><td><code id="stringdist_+3A_weight">weight</code></td>
<td>
<p>For <code>method='osa'</code> or <code>'dl'</code>, the penalty for
deletion, insertion, substitution and transposition, in that order. When
<code>method='lv'</code>, the penalty for transposition is ignored. When
<code>method='jw'</code>, the weights associated with characters of <code>a</code>,
characters from <code>b</code> and the transposition weight, in that order. 
Weights must be positive and not exceed 1. <code>weight</code> is ignored
completely when <code>method='hamming'</code>, <code>'qgram'</code>, <code>'cosine'</code>,
<code>'Jaccard'</code>, <code>'lcs'</code>, or <code>soundex</code>.</p>
</td></tr>
<tr><td><code id="stringdist_+3A_q">q</code></td>
<td>
<p>Size of the <code class="reqn">q</code>-gram; must be nonnegative. Only applies to
<code>method='qgram'</code>, <code>'jaccard'</code> or <code>'cosine'</code>.</p>
</td></tr>
<tr><td><code id="stringdist_+3A_p">p</code></td>
<td>
<p>Prefix factor for Jaro-Winkler distance. The valid range for 
<code>p</code> is <code>0 &lt;= p &lt;= 0.25</code>. If <code>p=0</code> (default), the
Jaro-distance is returned. Applies only to <code>method='jw'</code>.</p>
</td></tr>
<tr><td><code id="stringdist_+3A_bt">bt</code></td>
<td>
<p>Winkler's boost threshold. Winkler's prefix factor is
only applied when the Jaro distance is larger than <code>bt</code>.
Applies only to <code>method='jw'</code> and <code>p&gt;0</code>.</p>
</td></tr>
<tr><td><code id="stringdist_+3A_nthread">nthread</code></td>
<td>
<p>Maximum number of threads to use. By default, a sensible
number of threads is chosen, see <code><a href="#topic+stringdist-parallelization">stringdist-parallelization</a></code>.</p>
</td></tr>
<tr><td><code id="stringdist_+3A_usenames">useNames</code></td>
<td>
<p>Use input vectors as row and column names?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>stringdist</code>,  a vector with string distances of size
<code>max(length(a),length(b))</code>.
</p>
<p>For <code>stringdistmatrix</code>: if both <code>a</code> and <code>b</code> are passed, a
<code>length(a)xlength(b)</code> <code>matrix</code>. If a single argument <code>a</code> is
given an object of class <code><a href="stats.html#topic+dist">dist</a></code> is returned.
</p>
<p>Distances are nonnegative if they can be computed, <code>NA</code> if any of the
two argument strings is <code>NA</code> and <code>Inf</code> when <code>maxDist</code> is
exceeded or, in case of the hamming distance, when the two compared strings
have different length.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+stringsim">stringsim</a></code>, <code><a href="#topic+qgrams">qgrams</a></code>, <code><a href="#topic+amatch">amatch</a></code>, <code><a href="#topic+afind">afind</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simple example using optimal string alignment
stringdist("ca","abc")

# computing a 'dist' object
d &lt;- stringdistmatrix(c('foo','bar','boo','baz'))
# try plot(hclust(d))

# The following gives a matrix
stringdistmatrix(c("foo","bar","boo"),c("baz","buz"))

# An example using Damerau-Levenshtein distance (multiple editing of substrings allowed)
stringdist("ca","abc",method="dl")

# string distance matching is case sensitive:
stringdist("ABC","abc")

# so you may want to normalize a bit:
stringdist(tolower("ABC"),"abc")

# stringdist recycles the shortest argument:
stringdist(c('a','b','c'),c('a','c'))

# stringdistmatrix gives the distance matrix (by default for optimal string alignment):
stringdist(c('a','b','c'),c('a','c'))

# different edit operations may be weighted; e.g. weighted substitution:
stringdist('ab','ba',weight=c(1,1,1,0.5))

# Non-unit weights for insertion and deletion makes the distance metric asymetric
stringdist('ca','abc')
stringdist('abc','ca')
stringdist('ca','abc',weight=c(0.5,1,1,1))
stringdist('abc','ca',weight=c(0.5,1,1,1))

# Hamming distance is undefined for 
# strings of unequal lengths so stringdist returns Inf
stringdist("ab","abc",method="h")
# For strings of eqal length it counts the number of unequal characters as they occur
# in the strings from beginning to end
stringdist("hello","HeLl0",method="h")

# The lcs (longest common substring) distance returns the number of 
# characters that are not part of the lcs.
#
# Here, the lcs is either 'a' or 'b' and one character cannot be paired:
stringdist('ab','ba',method="lcs")
# Here the lcs is 'surey' and 'v', 'g' and one 'r' of 'surgery' are not paired
stringdist('survey','surgery',method="lcs")


# q-grams are based on the difference between occurrences of q consecutive characters
# in string a and string b.
# Since each character abc occurs in 'abc' and 'cba', the q=1 distance equals 0:
stringdist('abc','cba',method='qgram',q=1)

# since the first string consists of 'ab','bc' and the second 
# of 'cb' and 'ba', the q=2 distance equals 4 (they have no q=2 grams in common):
stringdist('abc','cba',method='qgram',q=2)

# Wikipedia has the following example of the Jaro-distance. 
stringdist('MARTHA','MATHRA',method='jw')
# Note that stringdist gives a  _distance_ where wikipedia gives the corresponding 
# _similarity measure_. To get the wikipedia result:
1 - stringdist('MARTHA','MATHRA',method='jw')

# The corresponding Jaro-Winkler distance can be computed by setting p=0.1
stringdist('MARTHA','MATHRA',method='jw',p=0.1)
# or, as a similarity measure
1 - stringdist('MARTHA','MATHRA',method='jw',p=0.1)

# This gives distance 1 since Euler and Gauss translate to different soundex codes.
stringdist('Euler','Gauss',method='soundex')
# Euler and Ellery translate to the same code and have distance 0
stringdist('Euler','Ellery',method='soundex')





</code></pre>

<hr>
<h2 id='stringdist_api'>Calling stringdist from <code>C</code> or <code>C++</code></h2><span id='topic+stringdist_api'></span>

<h3>Description</h3>

<p>As of version <code>0.9.5.0</code> several <code>C</code> level functions can be linked to
and called from C code in other R packages.
</p>
<p>A description of the API can be found in <a href="../doc/stringdist_api.pdf">stringdist_api.pdf</a>.
</p>

<hr>
<h2 id='stringdist-encoding'>String metrics in <span class="pkg">stringdist</span></h2><span id='topic+stringdist-encoding'></span>

<h3>Description</h3>

<p>This page gives an overview of encoding handling in <span class="pkg">stringst</span>.
</p>


<h3>Encoding in <span class="pkg">stringdist</span></h3>

<p>All character strings are stored as a sequence of bytes. An encoding
system relates a byte, or a short sequence of bytes to a symbol. Over the years, many 
encoding systems have been developed, and not all OS's and softwares use the same encoding 
as default. Similarly, depending on the system R is running on, R may use a
different encoding for storing strings internally.
</p>
<p>The <span class="pkg">stringdist</span> package is designed so users in principle need not
worry about this. Strings are converted to <code>UTF-32</code> (unsigned integer)
by default prior to any further computation. This means that results are
encoding-independent and that strings are interpreted as a sequence of
symbols, not as a sequence of pure bytes. In functions where this is
relevant, this may be switched by setting the <code>useBytes</code> option to
<code>TRUE</code>. However, keep in mind that results will then likely depend on the
system R is running on, except when your strings are pure ASCII.
Also, for multi-byte encodings, results for byte-wise computations
will usually differ from results using encoded computations.
</p>
<p>Prior to <span class="pkg">stringdist</span> version 0.9, setting <code>useBytes=TRUE</code> could 
give a significant performance enhancement. Since version 0.9, translation
to integer is done by C code internal to <span class="pkg">stringdist</span> and the difference in
performance is now negligible.
</p>


<h3>Unicode normalisation</h3>

<p>In <code>utf-8</code>, the same (accented) character may be represented as several byte sequences. For example, an u-umlaut
can be represented with a single byte code or as a byte code representing <code>'u'</code> followed by a modifier byte code
that adds the umlaut. The <a href="https://cran.r-project.org/package=stringi">stringi</a> package 
of Gagolevski and Tartanus offers unicode normalisation tools.
</p>


<h3>Some tips on character encoding and transliteration</h3>

<p>Some algorithms (like soundex) are defined only on the printable ASCII character set. This excludes any character
with accents for example. Translating accented characters to the non-accented ones is a form of transliteration. On
many systems running R (but not all!) you can achieve this with 
</p>
<p><code>iconv(x,to="ASCII//TRANSLIT")</code>, 
</p>
<p>where <code>x</code> is your character vector. See the documentation of <code><a href="base.html#topic+iconv">iconv</a></code> for details.
</p>
<p>The <code>stringi</code> package (Gagolewski and Tartanus) should work on any system. The command 
<code>stringi::stri_trans_general(x,"Latin-ASCII")</code> transliterates character vector <code>x</code> to ASCII.
</p>


<h3>References</h3>


<ul>
<li><p>The help page of <code><a href="base.html#topic+Encoding">Encoding</a></code> describes how R handles encoding.
</p>
</li>
<li><p>The help page of <code><a href="base.html#topic+iconv">iconv</a></code> has a good overview of base R's 
encoding conversion options. The capabilities of <code>iconv</code> depend on the system R is running on.
The <span class="pkg">stringi</span> package offers platform-independent encoding and normalization tools.
</p>
</li></ul>



<h3>See Also</h3>


<ul>
<li><p>Functions using re-encoding: <code><a href="#topic+stringdist">stringdist</a></code>, <code><a href="#topic+stringdistmatrix">stringdistmatrix</a></code>, <code><a href="#topic+amatch">amatch</a></code>, <code><a href="#topic+ain">ain</a></code>, <code><a href="#topic+qgrams">qgrams</a></code>
</p>
</li>
<li><p>Encoding related: <code><a href="#topic+printable_ascii">printable_ascii</a></code>
</p>
</li></ul>


<hr>
<h2 id='stringdist-metrics'>String metrics in <span class="pkg">stringdist</span></h2><span id='topic+stringdist-metrics'></span>

<h3>Description</h3>

<p>This page gives an overview of the string dissimilarity measures offered by
<span class="pkg">stringdist</span>.
</p>


<h3>String Metrics</h3>

<p>String metrics are ways of quantifying the dissimilarity between two finite
sequences, usually text strings. Over the years, many such measures have been
developed. Some are based on a mathematical understanding of the set of all 
strings that can be composed from a finite alphabet, others are based on more
heuristic principles, such as how a text string sounds when pronounced by a 
native English speaker.
</p>
<p>The terms 'string metrics' and 'string distance' are used more or less
interchangibly in literature. From a mathematical point of view, string
metrics often do not obey the demands that are usually required from a
distance function. For example, it is not true for all string metrics that a
distance of 0 means that two strings are the same (e.g. in the <code class="reqn">q</code>-gram
distance). Nevertheless, string metrics are very useful in practice and have
many applications.
</p>
<p>The metric you need to choose for an application strongly depends on both the
nature of the string (what does the string represent?) and the cause of
dissimilarities between the strings you are measuring. For example, if you
are comparing human-typed names that may contain typo's, the Jaro-Winkler
distance may be of use. If you are comparing names that were written down
after hearing them, a phonetic distance may be a better choice.
</p>
<p>Currently, the following distance metrics are supported by <span class="pkg">stringdist</span>.
</p>

<table>
<tr>
 <td style="text-align: left;">
   <b>Method name</b> </td><td style="text-align: left;"> <b>Description</b></td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>osa</code> </td><td style="text-align: left;"> Optimal string aligment, (restricted Damerau-Levenshtein distance).</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>lv</code> </td><td style="text-align: left;"> Levenshtein distance (as in R's native <code><a href="utils.html#topic+adist">adist</a></code>).</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>dl</code> </td><td style="text-align: left;"> Full Damerau-Levenshtein distance.</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>hamming</code>  </td><td style="text-align: left;"> Hamming distance (<code>a</code> and <code>b</code> must have same nr of characters).</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>lcs</code> </td><td style="text-align: left;"> Longest common substring distance.</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>qgram</code> </td><td style="text-align: left;"> <code class="reqn">q</code>-gram distance. </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>cosine</code> </td><td style="text-align: left;"> cosine distance between <code class="reqn">q</code>-gram profiles </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>jaccard</code> </td><td style="text-align: left;"> Jaccard distance between <code class="reqn">q</code>-gram profiles </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>jw</code> </td><td style="text-align: left;"> Jaro, or Jaro-Winkler distance.</td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>soundex</code> </td><td style="text-align: left;"> Distance based on soundex encoding (see below)
</td>
</tr>

</table>



<h3>A short description of string metrics supported by <span class="pkg">stringdist</span></h3>

<p>See <a href="https://journal.r-project.org/archive/2014-1/loo.pdf">Van der Loo
(2014)</a> for an extensive description and references. The review papers of
Navarro (2001) and Boytsov (2011) provide excellent technical overviews of
respectively online and offline string matching algorithms.
</p>
<p>The <b>Hamming distance</b> (<code>method='hamming'</code>) counts the number of 
character substitutions that turns <code>b</code> into <code>a</code>. If <code>a</code> 
and <code>b</code> have different number of characters the distance is <code>Inf</code>. 
</p>
<p>The <b>Levenshtein distance</b> (<code>method='lv'</code>) counts the number of 
deletions, insertions and substitutions necessary to turn <code>b</code> into 
<code>a</code>. This method is equivalent to <code>R</code>'s native <code><a href="utils.html#topic+adist">adist</a></code> 
function. 
</p>
<p>The <b>Optimal String Alignment distance</b> (<code>method='osa'</code>) is like the Levenshtein 
distance but also allows transposition of adjacent characters. Here, each 
substring  may be edited only once. (For example, a character cannot be transposed twice
to move it forward in the string). 
</p>
<p>The <b>full Damerau-Levenshtein distance</b> (<code>method='dl'</code>) is like the optimal 
string alignment distance except that it allows for multiple edits on substrings. 
</p>
<p>The <b>longest common substring</b> (method='lcs') is defined as the longest string that can be 
obtained by pairing characters from <code>a</code> and <code>b</code> while keeping the order 
of characters intact. The <b>lcs-distance</b> is defined as the number of unpaired characters. 
The distance is equivalent to the edit distance allowing only deletions and insertions, 
each with weight one. 
</p>
<p>A <b><code class="reqn">q</code>-gram</b> (method='qgram') is a subsequence of <code class="reqn">q</code> <em>consecutive</em> 
characters of a string. If <code class="reqn">x</code> (<code class="reqn">y</code>) is the vector of counts
of <code class="reqn">q</code>-gram occurrences in <code>a</code> (<code>b</code>), the <b><code class="reqn">q</code>-gram distance</b> 
is given by the sum over the absolute differences <code class="reqn">|x_i-y_i|</code>.
The computation is aborted when <code>q</code> is is larger than the length of 
any of the strings. In that case <code>Inf</code>  is returned.
</p>
<p>The <b>cosine distance</b> (method='cosine') is computed as <code class="reqn">1-x\cdot
y/(\|x\|\|y\|)</code>, where <code class="reqn">x</code> and <code class="reqn">y</code> were defined above.
</p>
<p>Let <code class="reqn">X</code> be the set of unique <code class="reqn">q</code>-grams in <code>a</code> and <code class="reqn">Y</code> the set of unique 
<code class="reqn">q</code>-grams in <code>b</code>. The <b>Jaccard distance</b> (<code>method='jaccard'</code>) is given by <code class="reqn">1-|X\cap Y|/|X\cup Y|</code>.
</p>
<p>The <b>Jaro distance</b> (<code>method='jw'</code>, <code>p=0</code>), is a number
between 0 (exact match) and 1 (completely dissimilar) measuring 
dissimilarity between strings.  It is defined to be 0 when both strings have
length 0, and 1 when  there are no character matches between <code>a</code> and
<code>b</code>.  Otherwise, the Jaro distance is defined as 
<code class="reqn">1-(1/3)(w_1m/|a| + w_2m/|b| + w_3(m-t)/m)</code>. 
Here,<code class="reqn">|a|</code> indicates the number of characters in <code>a</code>, <code class="reqn">m</code> is
the number of character matches and <code class="reqn">t</code> the number of transpositions of
matching characters. The <code class="reqn">w_i</code> are weights associated with the characters
in <code>a</code>, characters in <code>b</code> and with transpositions.  A character
<code class="reqn">c</code> of <code>a</code> <em>matches</em> a character from <code>b</code> when <code class="reqn">c</code>
occurs in <code>b</code>, and the index of <code class="reqn">c</code> in <code>a</code> differs less than
<code class="reqn">\max(|a|,|b|)/2 -1</code> (where we use integer division) from the index of
<code class="reqn">c</code> in <code>b</code>. Two matching characters are transposed when they are
matched but they occur in different order in string <code>a</code> and <code>b</code>.
</p>
<p>The <b>Jaro-Winkler distance</b> (<code>method=jw</code>, <code>0&lt;p&lt;=0.25</code>) adds a
correction term to the Jaro-distance. It is defined as <code class="reqn">d - l\cdot p\cdot d</code>, where
<code class="reqn">d</code> is the Jaro-distance. Here,  <code class="reqn">l</code> is obtained by counting, from
the start of the input strings, after how many characters the first
character mismatch between the two strings occurs, with a maximum of four. The
factor <code class="reqn">p</code> is a 'prefix' factor, which in the work of Winkler is often
chosen <code class="reqn">0.1</code>.
</p>
<p>For the <b>soundex</b> distance (method='soundex'), strings are translated to a soundex code 
(see <code><a href="#topic+phonetic">phonetic</a></code> for a specification). The
distance between strings is 0 when they have the same soundex code,
otherwise 1. Note that soundex recoding is only meaningful for characters
in the ranges a-z and A-Z. A warning is emitted when non-printable or non-ascii
characters are encountered. Also see <code><a href="#topic+printable_ascii">printable_ascii</a></code>.
</p>
<p>The <b>running_cosine</b> distance is an implementatation of the cosine
distance especially meant for fuzzy text search as in <code><a href="#topic+afind">afind</a></code>.
In fuzzy search a window of <code>n</code> characters slides across a (long)
string while for each position of the window the distance between the part
of the string in the window and a search pattern is computed. The (position
of) the window with the shortest distance to the search pattern is returned.
Sliding the window with a single position only affects the <code class="reqn">q</code>-grams at
the beginning and end of the window, and the 'running cosine' distance uses
this and a few other tricks to save calculations.
</p>


<h3>References</h3>


<ul>
<li>
<p>MPJ van der Loo (2014) <em>The stringdist package for approximate string matching</em>. The R Journal <b>6</b>(1) 111-122.

</p>
</li>
<li>
<p>L. Boytsov (2011). <em>Indexing methods for approximate dictionary searching: comparative analyses</em>. ACM Journal of experimental
algorithmics <b>16</b> 1-88.

</p>
</li>
<li>
<p>G. Navarro (2001). <em>A guided tour to approximate string matching</em>. ACM Computing Surveys <b>33</b> 31-88.

</p>
</li></ul>



<h3>See Also</h3>

 
<ul>
<li><p>Functions applying string metrics to text: <code><a href="#topic+stringdist">stringdist</a></code>,
<code><a href="#topic+stringdistmatrix">stringdistmatrix</a></code>, <code><a href="#topic+amatch">amatch</a></code>
</p>
</li>
<li><p>Functions applying string metrics to integer sequences:
<code><a href="#topic+seq_dist">seq_dist</a></code>, <code><a href="#topic+seq_distmatrix">seq_distmatrix</a></code>, <code><a href="#topic+seq_amatch">seq_amatch</a></code> 
</p>
</li>
<li><p>Encoding issues: <code><a href="#topic+stringdist-encoding">stringdist-encoding</a></code>  
</p>
</li></ul>


<hr>
<h2 id='stringdist-parallelization'>Multithreading and parallelization in <span class="pkg">stringdist</span></h2><span id='topic+stringdist-parallelization'></span>

<h3>Description</h3>

<p>This page describes how <span class="pkg">stringdist</span> uses parallel processing.
</p>


<h3>Multithreading and parallelization in <span class="pkg">stringdist</span></h3>

<p>The core 
functions of <span class="pkg">stringdist</span> are implemented in C. On systems where 
<code>openMP</code> is available, <span class="pkg">stringdist</span> will automatically take 
advantage of multiple cores. The
<a href="https://cran.r-project.org/doc/manuals/r-release/R-exts.html#OpenMP-support">section
on OpenMP</a> of the
<a href="https://cran.r-project.org/doc/manuals/r-release/R-exts.html">Writing
R Extensions</a> manual discusses on what systems OpenMP is available (at the time of writing more or
less anywhere except on OSX).
</p>
<p>By default, the number of threads to use is taken from <code>options('sd_num_thread')</code>.
When the package is loaded, the value for this option is determined as follows:
</p>

<ul>
<li><p>If the environment variable <code>OMP_NUM_THREADS</code> is set, this value is taken.
</p>
</li>
<li><p>Otherwise, the number of available cores is determined with <code>parallel::detectCores()</code>
If this fails, the number of threads is set to 1 (with a message). If the nr of detected
cores exceeds three, the number of used cores is set to <code class="reqn">n-1</code>.
</p>
</li>
<li><p>If available, the environment variable <code>OMP_THREAD_LIMIT</code> is
determined and The number of threads is set to the lesser of
<code>OMP_THREAD_LIMIT</code> and the number of detected cores.
</p>
</li></ul>

<p>The latter step makes sure that on machines with <code class="reqn">n&gt;3</code> cores, <code class="reqn">n-1</code> 
cores are used. Some benchmarking showed that using all cores is often slower
in such cases. This is probably because at least one of the threads will be
shared with the operating system.
</p>
<p>Functions that use multithreading have an option named <code>nthread</code> that
controls the maximum number of threads to use. If you need to do large
calculations, it is probably a good idea to benchmark the performance on your
machine(s) as a function of <code>'nthread'</code>, for example using the 
<a href="https://cran.r-project.org/package=microbenchmark">microbenchmark</a>
package of Mersmann.
</p>


<h3>See Also</h3>


<ul>
<li><p>Functions running multithreaded: <code><a href="#topic+stringdist">stringdist</a></code>, <code><a href="#topic+stringdistmatrix">stringdistmatrix</a></code>, <code><a href="#topic+amatch">amatch</a></code>, <code><a href="#topic+ain">ain</a></code> 
</p>
</li></ul>


<hr>
<h2 id='stringsim'>Compute similarity scores between strings</h2><span id='topic+stringsim'></span><span id='topic+stringsimmatrix'></span>

<h3>Description</h3>

<p><code>stringsim</code> computes pairwise string similarities between elements of
<code>character</code> vectors <code>a</code> and <code>b</code>, where the vector with less
elements is recycled. 
<code>stringsimmatrix</code> computes the string similarity matrix with rows
according to <code>a</code> and columns according to <code>b</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stringsim(
  a,
  b,
  method = c("osa", "lv", "dl", "hamming", "lcs", "qgram", "cosine", "jaccard", "jw",
    "soundex"),
  useBytes = FALSE,
  q = 1,
  ...
)

stringsimmatrix(
  a,
  b,
  method = c("osa", "lv", "dl", "hamming", "lcs", "qgram", "cosine", "jaccard", "jw",
    "soundex"),
  useBytes = FALSE,
  q = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stringsim_+3A_a">a</code></td>
<td>
<p>R object (target); will be converted by <code>as.character</code>.</p>
</td></tr>
<tr><td><code id="stringsim_+3A_b">b</code></td>
<td>
<p>R object (source); will be converted by <code>as.character</code>.</p>
</td></tr>
<tr><td><code id="stringsim_+3A_method">method</code></td>
<td>
<p>Method for distance calculation. The default is <code>"osa"</code>, 
see <code><a href="#topic+stringdist-metrics">stringdist-metrics</a></code>.</p>
</td></tr>
<tr><td><code id="stringsim_+3A_usebytes">useBytes</code></td>
<td>
<p>Perform byte-wise comparison, see <code><a href="#topic+stringdist-encoding">stringdist-encoding</a></code>.</p>
</td></tr>
<tr><td><code id="stringsim_+3A_q">q</code></td>
<td>
<p>Size of the <code class="reqn">q</code>-gram; must be nonnegative. Only applies to
<code>method='qgram'</code>, <code>'jaccard'</code> or <code>'cosine'</code>.</p>
</td></tr>
<tr><td><code id="stringsim_+3A_...">...</code></td>
<td>
<p>additional arguments are passed on to <code><a href="#topic+stringdist">stringdist</a></code> and
<code><a href="#topic+stringdistmatrix">stringdistmatrix</a></code> respectively.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The similarity is calculated by first calculating the distance using
<code><a href="#topic+stringdist">stringdist</a></code>, dividing the distance by the maximum
possible distance, and substracting the result from 1. 
This results in a score between 0 and 1, with 1
corresponding to complete similarity and 0 to complete dissimilarity.
Note that complete similarity only means equality for distances satisfying
the identity property. This is not the case e.g. for q-gram based distances
(for example if q=1, anagrams are completely similar).
For distances where weights can be specified, the maximum distance 
is currently computed by assuming that all weights are equal to 1.
</p>


<h3>Value</h3>

<p><code>stringsim</code> returns a vector with similarities, which are values between
0 and 1 where 1 corresponds to perfect similarity (distance 0) and 0 to
complete dissimilarity. <code>NA</code> is returned when <code><a href="#topic+stringdist">stringdist</a></code>
returns <code>NA</code>. Distances equal to <code>Inf</code> are truncated to a
similarity of 0. <code>stringsimmatrix</code> works the same way but, equivalent to
<code><a href="#topic+stringdistmatrix">stringdistmatrix</a></code>, returns a similarity matrix instead of a
vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

# Calculate the similarity using the default method of optimal string alignment
stringsim("ca", "abc")

# Calculate the similarity using the Jaro-Winkler method
# The p argument is passed on to stringdist
stringsim('MARTHA','MATHRA',method='jw', p=0.1)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
