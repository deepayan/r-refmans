<!DOCTYPE html><html><head><title>Help for package rxode2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rxode2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.assertRenameErrorModelLine'><p>This function asserts the requested rename makes sense</p></a></li>
<li><a href='#.copyUi'><p>This copies the rxode2 UI object so it can be modified</p></a></li>
<li><a href='#.handleSingleErrTypeNormOrTFoceiBase'><p>Handle the single error for normal or t distributions</p></a></li>
<li><a href='#.iniGetAppendArg'><p>This gets the append arg for the ini() piping</p></a></li>
<li><a href='#.iniHandleAppend'><p>Reorder rows in iniDf</p></a></li>
<li><a href='#.iniHandleLine'><p>Update the iniDf of a model</p></a></li>
<li><a href='#.matchesLangTemplate'><p>Check if a language object matches a template language object</p></a></li>
<li><a href='#.minfo'><p>Internal messaging statements</p></a></li>
<li><a href='#.modelHandleModelLines'><p>Handle model lines</p></a></li>
<li><a href='#.quoteCallInfoLines'><p>Returns quoted call information</p></a></li>
<li><a href='#.rxDocTable'><p>Print out a table in the documentation</p></a></li>
<li><a href='#.rxGetHiBoundaryPred1AndIni'><p>Get the upper boundary condition when the transformation it</p></a></li>
<li><a href='#.rxGetLambdaFromPred1AndIni'><p>Get the lambda value based on the pred information</p></a></li>
<li><a href='#.rxGetLowBoundaryPred1AndIni'><p>Get the lower boundary condition when the transformation requires it</p></a></li>
<li><a href='#.rxGetPredictionDVTransform'><p>Get the Observation transformation</p></a></li>
<li><a href='#.rxGetPredictionF'><p>Get the prediction name</p></a></li>
<li><a href='#.rxGetPredictionFTransform'><p>Get the prediction transformation</p></a></li>
<li><a href='#.rxGetVarianceForErrorType'><p>Get Variance for error type</p></a></li>
<li><a href='#.rxIsLinCmt'><p>Internal function to tell if the linCmt() is the model variables</p></a></li>
<li><a href='#.rxJacobian'><p>Internal function for calculating the Jacobian</p></a></li>
<li><a href='#.rxLinCmtGen'><p>Internal function to generate the model variables for a linCmt() model</p></a></li>
<li><a href='#.rxPrune'><p>Internal Pruning function</p></a></li>
<li><a href='#.rxSens'><p>Sensitivity for model</p></a></li>
<li><a href='#.rxWithOptions'><p>Temporarily set options then restore them while running code</p></a></li>
<li><a href='#.rxWithSink'><p>With one sink, then release</p></a></li>
<li><a href='#.rxWithWd'><p>Temporarily set options then restore them while running code</p></a></li>
<li><a href='#.useUtf'><p>Internal function to figure out if this session supports Unicode</p></a></li>
<li><a href='#+2B.rxSolve'><p>Update Solved object with '+'</p></a></li>
<li><a href='#as.ini'><p>Turn into an ini block for initialization</p></a></li>
<li><a href='#as.model'><p>Turn into a model expression</p></a></li>
<li><a href='#as.rxUi'><p>As rxode2 ui</p></a></li>
<li><a href='#assertRxUi'><p>Assert properties of the rxUi models</p></a></li>
<li><a href='#binomProbs'><p>Calculate expected confidence bands with binomial sampling distribution</p></a></li>
<li><a href='#coef.rxode2'><p>Return the rxode2 coefficients</p></a></li>
<li><a href='#erf'><p>Error function</p></a></li>
<li><a href='#etTrans'><p>Event translation for rxode2</p></a></li>
<li><a href='#findLhs'><p>Find the assignments in R expression</p></a></li>
<li><a href='#gammap'><p>Gammap: normalized lower incomplete gamma function</p></a></li>
<li><a href='#gammapDer'><p>gammapDer:  derivative of gammap</p></a></li>
<li><a href='#gammapInv'><p>gammapInv and gammapInva:  Inverses of normalized gammap function</p></a></li>
<li><a href='#gammaq'><p>Gammaq: normalized upper incomplete gamma function</p></a></li>
<li><a href='#gammaqInv'><p>gammaqInv and gammaqInva:  Inverses of normalized gammaq function</p></a></li>
<li><a href='#genShinyApp.template'><p>Generate an example (template) of a dosing regimen shiny app</p></a></li>
<li><a href='#getBaseIniSimModel'><p>Get the base simulation model for simulation with inis in the</p>
underlying rxode2 model</a></li>
<li><a href='#getBaseSimModel'><p>Get the base simulation model for simulation</p></a></li>
<li><a href='#getBaseSymengineModel'><p>Get the symengine for loading into symengine with <code>rxS()</code></p></a></li>
<li><a href='#getRxThreads'><p>Get/Set the number of threads that rxode2 uses</p></a></li>
<li><a href='#guide_none'><p>Empty Guide</p></a></li>
<li><a href='#ini.rxUi'><p>Ini block for rxode2/nlmixr models</p></a></li>
<li><a href='#ini+26lt+3B-'><p>Assign the ini block in the rxode2 related object</p></a></li>
<li><a href='#is.rxSolve'><p>Check to see if this is an rxSolve object.</p></a></li>
<li><a href='#llikBeta'><p>Calculate the log likelihood of the binomial function (and its derivatives)</p></a></li>
<li><a href='#llikBinom'><p>Calculate the log likelihood of the binomial function (and its derivatives)</p></a></li>
<li><a href='#llikCauchy'><p>log likelihood of Cauchy distribution and it's derivatives (from stan)</p></a></li>
<li><a href='#llikChisq'><p>log likelihood and derivatives for chi-squared distribution</p></a></li>
<li><a href='#llikExp'><p>log likelihood and derivatives for exponential distribution</p></a></li>
<li><a href='#llikF'><p>log likelihood and derivatives for F distribution</p></a></li>
<li><a href='#llikGamma'><p>log likelihood and derivatives for Gamma distribution</p></a></li>
<li><a href='#llikGeom'><p>log likelihood and derivatives for Geom distribution</p></a></li>
<li><a href='#llikNbinom'><p>Calculate the log likelihood of the negative binomial function (and its derivatives)</p></a></li>
<li><a href='#llikNbinomMu'><p>Calculate the log likelihood of the negative binomial function (and its derivatives)</p></a></li>
<li><a href='#llikNorm'><p>Log likelihood for normal distribution</p></a></li>
<li><a href='#llikPois'><p>log-likelihood for the Poisson distribution</p></a></li>
<li><a href='#llikT'><p>Log likelihood of T and it's derivatives (from stan)</p></a></li>
<li><a href='#llikUnif'><p>log likelihood and derivatives for Unif distribution</p></a></li>
<li><a href='#llikWeibull'><p>log likelihood and derivatives for Weibull distribution</p></a></li>
<li><a href='#logit'><p>logit and inverse logit (expit) functions</p></a></li>
<li><a href='#lowergamma'><p>lowergamma:  upper incomplete gamma function</p></a></li>
<li><a href='#meanProbs'><p>Calculate expected confidence bands or prediction intreval with normal or t sampling distribution</p></a></li>
<li><a href='#model.function'><p>Model block for rxode2/nlmixr models</p></a></li>
<li><a href='#model+26lt+3B-'><p>Assign the model block in the rxode2 related object</p></a></li>
<li><a href='#modelExtract'><p>Extract model lines from a rxui model</p></a></li>
<li><a href='#odeMethodToInt'><p>Conversion between character and integer ODE integration methods for rxode2</p></a></li>
<li><a href='#plot.rxSolve'><p>Plot rxode2 objects</p></a></li>
<li><a href='#print.rxCoef'><p>Print the rxCoef object</p></a></li>
<li><a href='#print.rxDll'><p>Print rxDll object</p></a></li>
<li><a href='#print.rxode2'><p>Print information about the rxode2 object.</p></a></li>
<li><a href='#probit'><p>probit and inverse probit functions</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#rxAllowUnload'><p>Allow unloading of dlls</p></a></li>
<li><a href='#rxAppendModel'><p>Append two rxui models together</p></a></li>
<li><a href='#rxAssignControlValue'><p>Assign Control Variable</p></a></li>
<li><a href='#rxAssignPtr'><p>Assign pointer based on model variables</p></a></li>
<li><a href='#rxbeta'><p>Simulate beta variable from threefry generator</p></a></li>
<li><a href='#rxbinom'><p>Simulate Binomial variable from threefry generator</p></a></li>
<li><a href='#rxBlockZeros'><p>Creates a logical matrix for block matrixes.</p></a></li>
<li><a href='#rxC'><p>Return the C file associated with the rxode2 object</p></a></li>
<li><a href='#rxCat'><p>Use cat when rxode2.verbose is TRUE</p></a></li>
<li><a href='#rxcauchy'><p>Simulate Cauchy variable from threefry generator</p></a></li>
<li><a href='#rxChain'><p>rxChain  Chain or add item to solved system of equations</p></a></li>
<li><a href='#rxChain2'><p>Second command in chaining commands</p></a></li>
<li><a href='#rxchisq'><p>Simulate chi-squared variable from threefry generator</p></a></li>
<li><a href='#rxClean'><p>Cleanup anonymous DLLs by unloading them</p></a></li>
<li><a href='#rxCombineErrorLines'><p>Combine Error Lines and create rxode2 expression</p></a></li>
<li><a href='#rxCompile'><p>Compile a model if needed</p></a></li>
<li><a href='#rxCondition'><p>Current Condition for rxode2 object</p></a></li>
<li><a href='#rxControlUpdateSens'><p>This updates the tolerances based on the sensitivity equations</p></a></li>
<li><a href='#rxCreateCache'><p>This will create the cache directory for rxode2 to save between sessions</p></a></li>
<li><a href='#rxD'><p>Add to rxode2's derivative tables</p></a></li>
<li><a href='#rxDelete'><p>Delete the DLL for the model</p></a></li>
<li><a href='#rxDemoteAddErr'><p>Demote the error type</p></a></li>
<li><a href='#rxDfdy'><p>Jacobian and parameter derivatives</p></a></li>
<li><a href='#rxDll'><p>Return the DLL associated with the rxode2 object</p></a></li>
<li><a href='#rxDynLoad'><p>Load rxode2 object</p></a></li>
<li><a href='#rxDynUnload'><p>Unload rxode2 object</p></a></li>
<li><a href='#rxErrTypeCombine'><p>Combine transformations and error structures</p></a></li>
<li><a href='#rxexp'><p>Simulate exponential variable from threefry generator</p></a></li>
<li><a href='#rxExpandFEta_'><p>Expand d(f)/d(eta)</p></a></li>
<li><a href='#rxExpandGrid'><p>Faster expand.grid</p></a></li>
<li><a href='#rxExpandGrid_'><p>Expand grid internal function</p></a></li>
<li><a href='#rxExpandIfElse'><p>Expand if/else clauses into multiple different types of lines.</p></a></li>
<li><a href='#rxExpandSens_'><p>Expand sensitivity</p></a></li>
<li><a href='#rxExpandSens2_'><p>Expand second order sensitivity</p></a></li>
<li><a href='#rxf'><p>Simulate F variable from threefry generator</p></a></li>
<li><a href='#rxForget'><p>Clear memoise cache for rxode2</p></a></li>
<li><a href='#rxFun'><p>Add/Create C functions for use in rxode2</p></a></li>
<li><a href='#rxgamma'><p>Simulate gamma variable from threefry generator</p></a></li>
<li><a href='#rxgeom'><p>Simulate geometric variable from threefry generator</p></a></li>
<li><a href='#rxGetControl'><p>rxGetControl option from ui</p></a></li>
<li><a href='#rxGetDistributionSimulationLines'><p>This is a S3 method for getting the distribution lines for a rxode2 simulation</p></a></li>
<li><a href='#rxGetLin'><p>Get the linear compartment model true function</p></a></li>
<li><a href='#rxGetModel'><p>Get model properties without compiling it.</p></a></li>
<li><a href='#rxGetrxode2'><p>Get rxode2 model from object</p></a></li>
<li><a href='#rxHtml'><p>Format rxSolve and related objects as html.</p></a></li>
<li><a href='#rxIndLin_'><p>Inductive linearization solver</p></a></li>
<li><a href='#rxIndLinState'><p>Set the preferred factoring by state</p></a></li>
<li><a href='#rxIndLinStrategy'><p>This sets the inductive linearization strategy for matrix building</p></a></li>
<li><a href='#rxInits'><p>Initial Values and State values for a rxode2 object</p></a></li>
<li><a href='#rxInv'><p>Invert matrix using RcppArmadillo.</p></a></li>
<li><a href='#rxIs'><p>Check the type of an object using Rcpp</p></a></li>
<li><a href='#rxIsCurrent'><p>Checks if the rxode2 object was built with the current build</p></a></li>
<li><a href='#rxIsLoaded'><p>Determine if the DLL associated with the rxode2 object is loaded</p></a></li>
<li><a href='#rxLhs'><p>Left handed Variables</p></a></li>
<li><a href='#rxLock'><p>Lock/unlocking of rxode2 dll file</p></a></li>
<li><a href='#rxMd5'><p>Return the md5 of an rxode2 object or file</p></a></li>
<li><a href='#rxModels_'><p>Get the rxModels  information</p></a></li>
<li><a href='#rxModelVars'><p>All model variables for a rxode2 object</p></a></li>
<li><a href='#rxnbinom'><p>Simulate Binomial variable from threefry generator</p></a></li>
<li><a href='#rxNorm'><p>Get the normalized model</p></a></li>
<li><a href='#rxnormV'><p>Simulate random normal variable from threefry generator</p></a></li>
<li><a href='#rxode2'><p>Create an ODE-based model specification</p></a></li>
<li><a href='#rxode2+26lt+3B-'><p>Set the function body of an rxUi object while retaining other object</p>
information (like data)</a></li>
<li><a href='#rxOptExpr'><p>Optimize rxode2 for computer evaluation</p></a></li>
<li><a href='#rxord'><p>Simulate ordinal value</p></a></li>
<li><a href='#rxParams'><p>Parameters specified by the model</p></a></li>
<li><a href='#rxParseErr'><p>Prepare Error function for inclusion in rxode2</p></a></li>
<li><a href='#rxParsePk'><p>Parse PK function for inclusion in rxode2</p></a></li>
<li><a href='#rxParsePred'><p>Prepare Pred function for inclusion in rxode2</p></a></li>
<li><a href='#rxPkg'><p>Creates a package from compiled rxode2 models</p></a></li>
<li><a href='#rxpois'><p>Simulate random Poisson variable from threefry generator</p></a></li>
<li><a href='#rxPp'><p>Simulate a from a Poisson process</p></a></li>
<li><a href='#rxPreferredDistributionName'><p>Change distribution name to the preferred distribution name term</p></a></li>
<li><a href='#rxProgress'><p>rxode2 progress bar functions</p></a></li>
<li><a href='#rxPrune'><p>Prune branches (ie if/else) from rxode2</p></a></li>
<li><a href='#rxReload'><p>Reload rxode2 DLL</p></a></li>
<li><a href='#rxRemoveControl'><p>rxRemoveControl options for UI object</p></a></li>
<li><a href='#rxRename'><p>Rename items inside of a <code>rxode2</code> ui model</p></a></li>
<li><a href='#rxRepR0_'><p>Rep R0 for foce</p></a></li>
<li><a href='#rxReservedKeywords'><p>A list and description of rxode2 supported reserved keywords</p></a></li>
<li><a href='#rxResidualError'><p>A description of Rode2 supported residual errors</p></a></li>
<li><a href='#rxS'><p>Load a model into a symengine environment</p></a></li>
<li><a href='#rxSetControl'><p>rxSetControl options for UI object</p></a></li>
<li><a href='#rxSetCovariateNamesForPiping'><p>Assign covariates for piping</p></a></li>
<li><a href='#rxSetPipingAuto'><p>Set the variables for the model piping automatic covarite selection</p></a></li>
<li><a href='#rxSetProd'><p>Defunct setting of product</p></a></li>
<li><a href='#rxSetProgressBar'><p>Set timing for progress bar</p></a></li>
<li><a href='#rxSetSilentErr'><p>Silence some of rxode2's C/C++ messages</p></a></li>
<li><a href='#rxSetSum'><p>Defunct setting of sum</p></a></li>
<li><a href='#rxSetupIni'><p>Setup the initial conditions.</p></a></li>
<li><a href='#rxSetupScale'><p>Setup the initial conditions.</p></a></li>
<li><a href='#rxShiny'><p>Use Shiny to help develop an rxode2 model</p></a></li>
<li><a href='#rxSimThetaOmega'><p>Simulate Parameters from a Theta/Omega specification</p></a></li>
<li><a href='#rxSolve'><p>Options, Solving &amp; Simulation of an ODE/solved system</p></a></li>
<li><a href='#rxSolveFree'><p>Free the C solving/parsing information.</p></a></li>
<li><a href='#rxSplitPlusQ'><p>This function splits a function based on + or - terms</p></a></li>
<li><a href='#rxState'><p>State variables</p></a></li>
<li><a href='#rxSumProdModel'><p>Recast model in terms of sum/prod</p></a></li>
<li><a href='#rxSupportedFuns'><p>Get list of supported functions</p></a></li>
<li><a href='#rxSuppressMsg'><p>Respect suppress messages</p></a></li>
<li><a href='#rxSymInvChol'><p>Get Omega^-1 and derivatives</p></a></li>
<li><a href='#rxSymInvCholCreate'><p>Creates an object for calculating Omega/Omega^-1 and derivatives</p></a></li>
<li><a href='#rxSymInvCholN'><p>Return the dimension of the built-in derivatives/inverses</p></a></li>
<li><a href='#rxSyncOptions'><p>Sync options with rxode2 variables</p></a></li>
<li><a href='#rxSyntaxFunctions'><p>A list and description of Rode supported syntax functions</p></a></li>
<li><a href='#rxt'><p>Simulate student t variable from threefry generator</p></a></li>
<li><a href='#rxTempDir'><p>Get the rxode2 temporary directory</p></a></li>
<li><a href='#rxTheme'><p>rxTheme is the ggplot2 theme for rxode2 plots</p></a></li>
<li><a href='#rxToSE'><p>rxode2 to symengine environment</p></a></li>
<li><a href='#rxTrans'><p>Translate the model to C code if needed</p></a></li>
<li><a href='#rxUiDecompress'><p>Compress/Decompress <code>rxode2</code> ui</p></a></li>
<li><a href='#rxUiGet.cmtLines'><p>S3 for getting information from UI model</p></a></li>
<li><a href='#rxunif'><p>Simulate uniform variable from threefry generator</p></a></li>
<li><a href='#rxUnloadAll'><p>Unloads all rxode2 compiled DLLs</p></a></li>
<li><a href='#rxUse'><p>Use model object in your package</p></a></li>
<li><a href='#rxValidate'><p>Validate rxode2</p>
This allows easy validation/qualification of nlmixr by running the
testing suite on your system.</a></li>
<li><a href='#rxVersion'><p>Version and repository for this dparser package.</p></a></li>
<li><a href='#rxweibull'><p>Simulate Weibull variable from threefry generator</p></a></li>
<li><a href='#stat_amt'><p>Dosing/Amt geom/stat</p></a></li>
<li><a href='#stat_cens'><p>Censoring geom/stat</p></a></li>
<li><a href='#summary.rxDll'><p>Summary of rxDll object</p></a></li>
<li><a href='#summary.rxode2'><p>Print expanded information about the rxode2 object.</p></a></li>
<li><a href='#update.rxUi'><p>Update for rxUi</p></a></li>
<li><a href='#uppergamma'><p>uppergamma:  upper incomplete gamma function</p></a></li>
<li><a href='#zeroRe'><p>Set random effects and residual error to zero</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.1.2</td>
</tr>
<tr>
<td>Title:</td>
<td>Facilities for Simulating from ODE-Based Models</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthew L. Fidler &lt;matthew.fidler@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Matrix, DT, covr, crayon, curl, digest, dplyr (&ge; 0.8.0),
ggrepel, gridExtra, htmltools, knitr, learnr, microbenchmark,
nlme, remotes, rlang, rmarkdown, scales, shiny, stringi,
symengine, testthat, tidyr, usethis, vdiffr (&ge; 1.0), withr,
xgxr, pillar, tibble, units (&ge; 0.6-0), rsconnect, devtools,
patchwork, nlmixr2data, lifecycle, kableExtra</td>
</tr>
<tr>
<td>Imports:</td>
<td>PreciseSums (&ge; 0.3), Rcpp (&ge; 0.12.3), backports, cli (&ge;
2.0.0), checkmate, ggplot2 (&ge; 3.4.0), inline, lotri (&ge;
0.4.0), magrittr, memoise, methods, rex, sys, tools, utils,
rxode2ll(&ge; 2.0.9), rxode2et (&ge; 2.0.9), rxode2parse (&gt;
2.0.16), rxode2random (&gt; 2.0.11), data.table (&ge; 1.12.4), qs</td>
</tr>
<tr>
<td>Description:</td>
<td>Facilities for running simulations from ordinary
    differential equation ('ODE') models, such as pharmacometrics and other
    compartmental models.  A compilation manager translates the ODE model
    into C, compiles it, and dynamically loads the object code into R for
    improved computational efficiency.  An event table object facilitates
    the specification of complex dosing regimens (optional) and sampling
    schedules.  NB: The use of this package requires both C and
    Fortran compilers, for details on their use with R please see
    Section 6.3, Appendix A, and Appendix D in the "R Administration and
    Installation" manual. Also the code is mostly released under GPL.  The
    'VODE' and 'LSODA' are in the public domain.  The information is available
    in the inst/COPYRIGHTS.</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/nlmixr2/rxode2/issues/">https://github.com/nlmixr2/rxode2/issues/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://nlmixr2.github.io/rxode2/">https://nlmixr2.github.io/rxode2/</a>,
<a href="https://github.com/nlmixr2/rxode2/">https://github.com/nlmixr2/rxode2/</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>rxode2parse (&ge; 2.0.12), rxode2random, PreciseSums (&ge; 0.3),
Rcpp, RcppArmadillo (&ge; 0.9.300.2.0), BH</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-30 16:16:14 UTC; matt</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthew L. Fidler <a href="https://orcid.org/0000-0001-8538-6691"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Melissa Hallow [aut],
  Wenping Wang [aut],
  Zufar Mulyukov [ctb],
  Alan Hindmarsh [ctb],
  Arun Srinivasan [ctb],
  Awad H. Al-Mohy [ctb],
  Cleve Moler [ctb],
  Drew Schmidt [ctb],
  Ernst Hairer [ctb],
  Gerhard Wanner [ctb],
  Gilbert Stewart [ctb],
  Hadley Wickham [ctb],
  Jack Dongarra [ctb],
  Jim Bunch [ctb],
  Linda Petzold [ctb],
  Martin Maechler [ctb],
  Matt Dowle [ctb],
  Matteo Fasiolo [ctb],
  Nicholas J. Higham [ctb],
  Roger B. Sidje [ctb],
  Simon Frost [ctb],
  Yu Feng [ctb],
  Bill Denney <a href="https://orcid.org/0000-0002-5759-428X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-30 23:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.assertRenameErrorModelLine'>This function asserts the requested rename makes sense</h2><span id='topic+.assertRenameErrorModelLine'></span>

<h3>Description</h3>

<p>It returns the new expression, old expression, new variable and old
variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.assertRenameErrorModelLine(line, vars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".assertRenameErrorModelLine_+3A_line">line</code></td>
<td>
<p>quoted call information line</p>
</td></tr>
<tr><td><code id=".assertRenameErrorModelLine_+3A_vars">vars</code></td>
<td>
<p>Variables contained within the mdel</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list(new, old, newChar, oldChar)
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.copyUi'>This copies the rxode2 UI object so it can be modified</h2><span id='topic+.copyUi'></span>

<h3>Description</h3>

<p>This copies the rxode2 UI object so it can be modified
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.copyUi(ui)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".copyUi_+3A_ui">ui</code></td>
<td>
<p>Original UI object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Copied UI object
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.handleSingleErrTypeNormOrTFoceiBase'>Handle the single error for normal or t distributions</h2><span id='topic+.handleSingleErrTypeNormOrTFoceiBase'></span>

<h3>Description</h3>

<p>Handle the single error for normal or t distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.handleSingleErrTypeNormOrTFoceiBase(
  env,
  pred1,
  errNum = 1L,
  rxPredLlik = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".handleSingleErrTypeNormOrTFoceiBase_+3A_env">env</code></td>
<td>
<p>Environment for the parsed model</p>
</td></tr>
<tr><td><code id=".handleSingleErrTypeNormOrTFoceiBase_+3A_pred1">pred1</code></td>
<td>
<p>The <code>data.frame</code> of the current error</p>
</td></tr>
<tr><td><code id=".handleSingleErrTypeNormOrTFoceiBase_+3A_errnum">errNum</code></td>
<td>
<p>The number of the error specification in the nlmixr2 model</p>
</td></tr>
<tr><td><code id=".handleSingleErrTypeNormOrTFoceiBase_+3A_rxpredllik">rxPredLlik</code></td>
<td>
<p>A boolean indicating if the log likelihood should
be calculated for non-normal distributions.  By default <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the lines added.  The lines will contain
</p>

<ul>
<li> <p><code>rx_yj_</code> which is an integer that corresponds to the
transformation type.
</p>
</li>
<li> <p><code>rx_lambda_</code> is the transformation lambda
</p>
</li>
<li> <p><code>rx_low_</code> The lower boundary of the transformation
</p>
</li>
<li> <p><code>rx_hi_</code> The upper boundary of the transformation
</p>
</li>
<li> <p><code>rx_pred_f_</code> The prediction function
</p>
</li>
<li> <p><code>rx_pred_</code> The transformed prediction function
</p>
</li>
<li> <p><code>rx_r_</code> The transformed variance
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='.iniGetAppendArg'>This gets the append arg for the ini() piping</h2><span id='topic+.iniGetAppendArg'></span>

<h3>Description</h3>

<p>This gets the append arg for the ini() piping
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.iniGetAppendArg(f, s)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".iniGetAppendArg_+3A_f">f</code></td>
<td>
<p>this is the <code>try(force(append))</code> argument,</p>
</td></tr>
<tr><td><code id=".iniGetAppendArg_+3A_s">s</code></td>
<td>
<p>this is the <code>as.character(substitute(append))</code> argument</p>
</td></tr>
</table>


<h3>Value</h3>

<p>corrected ini piping argument
</p>
<p>This is exported for creating new ini methods that have the same
requirements for piping
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.iniHandleAppend'>Reorder rows in iniDf</h2><span id='topic+.iniHandleAppend'></span>

<h3>Description</h3>

<p>Reorder rows in iniDf
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.iniHandleAppend(expr, rxui, envir, append)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".iniHandleAppend_+3A_expr">expr</code></td>
<td>
<p>Expression for parsing</p>
</td></tr>
<tr><td><code id=".iniHandleAppend_+3A_rxui">rxui</code></td>
<td>
<p>User interface function</p>
</td></tr>
<tr><td><code id=".iniHandleAppend_+3A_envir">envir</code></td>
<td>
<p>Environment for parsing</p>
</td></tr>
<tr><td><code id=".iniHandleAppend_+3A_append">append</code></td>
<td>
<p>Reorder theta parameters.  <code>NULL</code> means no change to
parameter order.  A parameter name (as a character string) means to put the
new parameter after the named parameter.  A number less than or equal to
zero means to put the parameter at the beginning of the list.  A number
greater than the last parameter number means to put the parameter at the
end of the list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, called for side effects
</p>

<hr>
<h2 id='.iniHandleLine'>Update the iniDf of a model</h2><span id='topic+.iniHandleLine'></span><span id='topic+.iniHandleFixOrUnfix'></span>

<h3>Description</h3>

<p>Update the iniDf of a model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.iniHandleLine(expr, rxui, envir = parent.frame(), append = NULL)

.iniHandleFixOrUnfix(expr, rxui, envir = parent.frame(), append = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".iniHandleLine_+3A_expr">expr</code></td>
<td>
<p>Expression for parsing</p>
</td></tr>
<tr><td><code id=".iniHandleLine_+3A_rxui">rxui</code></td>
<td>
<p>User interface function</p>
</td></tr>
<tr><td><code id=".iniHandleLine_+3A_envir">envir</code></td>
<td>
<p>Environment for parsing</p>
</td></tr>
<tr><td><code id=".iniHandleLine_+3A_append">append</code></td>
<td>
<p>Reorder theta parameters.  <code>NULL</code> means no change to
parameter order.  A parameter name (as a character string) means to put the
new parameter after the named parameter.  A number less than or equal to
zero means to put the parameter at the beginning of the list.  A number
greater than the last parameter number means to put the parameter at the
end of the list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, called for side effects
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.matchesLangTemplate'>Check if a language object matches a template language object</h2><span id='topic+.matchesLangTemplate'></span>

<h3>Description</h3>


<ul>
<li><p>If <code>template == str2lang(".")</code>, it will match anything.
</p>
</li>
<li><p>If <code>template == str2lang(".name")</code>, it will match any name.
</p>
</li>
<li><p>If <code>template == str2lang(".call()")</code>, it will match any call.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>.matchesLangTemplate(x, template)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".matchesLangTemplate_+3A_x">x</code></td>
<td>
<p>The object to check</p>
</td></tr>
<tr><td><code id=".matchesLangTemplate_+3A_template">template</code></td>
<td>
<p>The template object it should match</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if it matches, FALSE, otherwise
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.matchesLangTemplate(str2lang("d/dt(foo)"), str2lang("d/dt(.name)"))
.matchesLangTemplate(str2lang("d/dt(foo)"), str2lang("d/foo(.name)"))
.matchesLangTemplate(str2lang("d/dt(foo)"), str2lang("d/."))
</code></pre>

<hr>
<h2 id='.minfo'>Internal messaging statements</h2><span id='topic+.minfo'></span><span id='topic+.malert'></span><span id='topic+.mwarn'></span><span id='topic+.msuccess'></span>

<h3>Description</h3>

<p>Internal messaging statements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.minfo(text, ..., .envir = parent.frame())

.malert(text, ..., .envir = parent.frame())

.mwarn(text, ..., .envir = parent.frame())

.msuccess(text, ..., .envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".minfo_+3A_text">text</code></td>
<td>
<p>Text</p>
</td></tr>
<tr><td><code id=".minfo_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
<tr><td><code id=".minfo_+3A_.envir">.envir</code></td>
<td>
<p>Environment to evaluate in</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, called for side effects
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.modelHandleModelLines'>Handle model lines</h2><span id='topic+.modelHandleModelLines'></span>

<h3>Description</h3>

<p>Handle model lines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.modelHandleModelLines(
  modelLines,
  rxui,
  modifyIni = FALSE,
  append = NULL,
  auto = getOption("rxode2.autoVarPiping", TRUE),
  cov = NULL,
  envir
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".modelHandleModelLines_+3A_modellines">modelLines</code></td>
<td>
<p>The model lines that are being considered</p>
</td></tr>
<tr><td><code id=".modelHandleModelLines_+3A_rxui">rxui</code></td>
<td>
<p>The rxode2 UI object</p>
</td></tr>
<tr><td><code id=".modelHandleModelLines_+3A_modifyini">modifyIni</code></td>
<td>
<p>Should the ini() be considered</p>
</td></tr>
<tr><td><code id=".modelHandleModelLines_+3A_append">append</code></td>
<td>
<p>This is a boolean to determine if the lines are
appended in piping.  The possible values for this is:
</p>

<ul>
<li> <p><code>TRUE</code> which is when the lines are appended to the model instead of replaced
</p>
</li>
<li> <p><code>FALSE</code> when the lines are replaced in the model (default)
</p>
</li>
<li> <p><code>NA</code> is when the lines are pre-pended to the model instead of replaced
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;lhs expression&#8288;</code>, which will append the lines after the last observed line of the expression <code>lhs</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id=".modelHandleModelLines_+3A_auto">auto</code></td>
<td>
<p>This boolean tells if piping automatically selects the
parameters should be characterized as a population parameter,
between subject variability, or a covariate.  When <code>TRUE</code> this
automatic selection occurs.  When <code>FALSE</code> this automatic
selection is turned off and everything is added as a covariate
(which can be promoted to a parameter with the <code>ini</code> statement).
By default this is <code>TRUE</code>, but it can be changed by
<code>options(rxode2.autoVarPiping=FALSE)</code>.</p>
</td></tr>
<tr><td><code id=".modelHandleModelLines_+3A_cov">cov</code></td>
<td>
<p>is a character vector of variables that should be
assumed to be covariates.  This will override automatic promotion
to a population parameter estimate (or an eta)</p>
</td></tr>
<tr><td><code id=".modelHandleModelLines_+3A_envir">envir</code></td>
<td>
<p>Environment for evaluation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>New UI
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.quoteCallInfoLines'>Returns quoted call information</h2><span id='topic+.quoteCallInfoLines'></span>

<h3>Description</h3>

<p>Returns quoted call information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.quoteCallInfoLines(callInfo, envir = parent.frame(), iniDf = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".quoteCallInfoLines_+3A_callinfo">callInfo</code></td>
<td>
<p>Call information</p>
</td></tr>
<tr><td><code id=".quoteCallInfoLines_+3A_envir">envir</code></td>
<td>
<p>Environment for evaluation (if needed)</p>
</td></tr>
<tr><td><code id=".quoteCallInfoLines_+3A_inidf">iniDf</code></td>
<td>
<p>The parent model <code>iniDf</code> when piping in a <code>ini</code> block
(<code>NULL</code> otherwise)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Quote call information.  for <code>name=expression</code>, change to
<code>name&lt;-expression</code> in quoted call list. For expressions that are
within brackets ie <code>{}</code>, unlist the brackets as if they were
called in one single sequence.
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.rxDocTable'>Print out a table in the documentation</h2><span id='topic+.rxDocTable'></span>

<h3>Description</h3>

<p>Print out a table in the documentation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rxDocTable(table, caption = "none")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".rxDocTable_+3A_table">table</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id=".rxDocTable_+3A_caption">caption</code></td>
<td>
<p>a character vector representing the caption for the latex table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>based on the <code>knitr</code> context:
</p>

<ul>
<li><p> output a <code>kableExtra::kbl</code> for <code>latex</code> output
</p>
</li>
<li><p> output a <code>DT::datatable</code> for html output
</p>
</li>
<li><p> otherwise output a <code>knitr::kable</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.rxDocTable(rxReservedKeywords)
</code></pre>

<hr>
<h2 id='.rxGetHiBoundaryPred1AndIni'>Get the upper boundary condition when the transformation it</h2><span id='topic+.rxGetHiBoundaryPred1AndIni'></span>

<h3>Description</h3>

<p>Get the upper boundary condition when the transformation it
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rxGetHiBoundaryPred1AndIni(env, pred1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".rxGetHiBoundaryPred1AndIni_+3A_env">env</code></td>
<td>
<p>Environment for the parsed model</p>
</td></tr>
<tr><td><code id=".rxGetHiBoundaryPred1AndIni_+3A_pred1">pred1</code></td>
<td>
<p>The <code>data.frame</code> of the current error</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Upper Boundary
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='.rxGetLambdaFromPred1AndIni'>Get the lambda value based on the pred information</h2><span id='topic+.rxGetLambdaFromPred1AndIni'></span>

<h3>Description</h3>

<p>Get the lambda value based on the pred information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rxGetLambdaFromPred1AndIni(env, pred1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".rxGetLambdaFromPred1AndIni_+3A_env">env</code></td>
<td>
<p>Environment that has the environment</p>
</td></tr>
<tr><td><code id=".rxGetLambdaFromPred1AndIni_+3A_pred1">pred1</code></td>
<td>
<p>Single error data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Lambda expression
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='.rxGetLowBoundaryPred1AndIni'>Get the lower boundary condition when the transformation requires it</h2><span id='topic+.rxGetLowBoundaryPred1AndIni'></span>

<h3>Description</h3>

<p>Get the lower boundary condition when the transformation requires it
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rxGetLowBoundaryPred1AndIni(env, pred1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".rxGetLowBoundaryPred1AndIni_+3A_env">env</code></td>
<td>
<p>Environment for the parsed model</p>
</td></tr>
<tr><td><code id=".rxGetLowBoundaryPred1AndIni_+3A_pred1">pred1</code></td>
<td>
<p>The <code>data.frame</code> of the current error</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Lower Boundary
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='.rxGetPredictionDVTransform'>Get the Observation transformation</h2><span id='topic+.rxGetPredictionDVTransform'></span>

<h3>Description</h3>

<p>Get the Observation transformation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rxGetPredictionDVTransform(env, pred1, yj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".rxGetPredictionDVTransform_+3A_env">env</code></td>
<td>
<p>Environment for the parsed model</p>
</td></tr>
<tr><td><code id=".rxGetPredictionDVTransform_+3A_pred1">pred1</code></td>
<td>
<p>The <code>data.frame</code> of the current error</p>
</td></tr>
<tr><td><code id=".rxGetPredictionDVTransform_+3A_yj">yj</code></td>
<td>
<p>The transformation number for the current error</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The transformation expression
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='.rxGetPredictionF'>Get the prediction name</h2><span id='topic+.rxGetPredictionF'></span>

<h3>Description</h3>

<p>Get the prediction name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rxGetPredictionF(env, pred1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".rxGetPredictionF_+3A_env">env</code></td>
<td>
<p>Environment for the parsed model</p>
</td></tr>
<tr><td><code id=".rxGetPredictionF_+3A_pred1">pred1</code></td>
<td>
<p>The <code>data.frame</code> of the current error</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The prediction symbol
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='.rxGetPredictionFTransform'>Get the prediction transformation</h2><span id='topic+.rxGetPredictionFTransform'></span>

<h3>Description</h3>

<p>Get the prediction transformation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rxGetPredictionFTransform(env, pred1, yj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".rxGetPredictionFTransform_+3A_env">env</code></td>
<td>
<p>Environment for the parsed model</p>
</td></tr>
<tr><td><code id=".rxGetPredictionFTransform_+3A_pred1">pred1</code></td>
<td>
<p>The <code>data.frame</code> of the current error</p>
</td></tr>
<tr><td><code id=".rxGetPredictionFTransform_+3A_yj">yj</code></td>
<td>
<p>The transformation number for the current error</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The transformation expression
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='.rxGetVarianceForErrorType'>Get Variance for error type</h2><span id='topic+.rxGetVarianceForErrorType'></span>

<h3>Description</h3>

<p>Get Variance for error type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rxGetVarianceForErrorType(env, pred1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".rxGetVarianceForErrorType_+3A_env">env</code></td>
<td>
<p>Environment</p>
</td></tr>
<tr><td><code id=".rxGetVarianceForErrorType_+3A_pred1">pred1</code></td>
<td>
<p>Pred for one end-point</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Variance error type
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.rxIsLinCmt'>Internal function to tell if the linCmt() is the model variables</h2><span id='topic+.rxIsLinCmt'></span>

<h3>Description</h3>

<p>Internal function to tell if the linCmt() is the model variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rxIsLinCmt()
</code></pre>


<h3>Value</h3>

<p>0 or 1
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.rxJacobian'>Internal function for calculating the Jacobian</h2><span id='topic+.rxJacobian'></span>

<h3>Description</h3>

<p>Internal function for calculating the Jacobian
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rxJacobian(model, vars = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".rxJacobian_+3A_model">model</code></td>
<td>
<p>symengine environment</p>
</td></tr>
<tr><td><code id=".rxJacobian_+3A_vars">vars</code></td>
<td>
<p>Variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Jacobian information
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.rxLinCmtGen'>Internal function to generate the model variables for a linCmt() model</h2><span id='topic+.rxLinCmtGen'></span>

<h3>Description</h3>

<p>Internal function to generate the model variables for a linCmt() model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rxLinCmtGen(lenState, vars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".rxLinCmtGen_+3A_lenstate">lenState</code></td>
<td>
<p>Length of the state</p>
</td></tr>
<tr><td><code id=".rxLinCmtGen_+3A_vars">vars</code></td>
<td>
<p>Variables in the model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Model variables of expanded linCmt model
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.rxPrune'>Internal Pruning function</h2><span id='topic+.rxPrune'></span>

<h3>Description</h3>

<p>Internal Pruning function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rxPrune(x, envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".rxPrune_+3A_x">x</code></td>
<td>
<p>List of quoted lines</p>
</td></tr>
<tr><td><code id=".rxPrune_+3A_envir">envir</code></td>
<td>
<p>Environment where information is stored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Pruned model code
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.rxSens'>Sensitivity for model</h2><span id='topic+.rxSens'></span>

<h3>Description</h3>

<p>Sensitivity for model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rxSens(model, vars, vars2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".rxSens_+3A_model">model</code></td>
<td>
<p>symengine model environment</p>
</td></tr>
<tr><td><code id=".rxSens_+3A_vars">vars</code></td>
<td>
<p>Variables for single sensitivity</p>
</td></tr>
<tr><td><code id=".rxSens_+3A_vars2">vars2</code></td>
<td>
<p>if present, 2 parameter sensitivity</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sensitivity
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.rxWithOptions'>Temporarily set options then restore them while running code</h2><span id='topic+.rxWithOptions'></span>

<h3>Description</h3>

<p>Temporarily set options then restore them while running code
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rxWithOptions(ops, code)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".rxWithOptions_+3A_ops">ops</code></td>
<td>
<p>list of options that will be temporarily set for the
<code>code</code></p>
</td></tr>
<tr><td><code id=".rxWithOptions_+3A_code">code</code></td>
<td>
<p>The code to run during the sink</p>
</td></tr>
</table>


<h3>Value</h3>

<p>value of code
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
.rxWithOptions(list(digits = 21), {
  print(pi)
})

print(pi)
</code></pre>

<hr>
<h2 id='.rxWithSink'>With one sink, then release</h2><span id='topic+.rxWithSink'></span><span id='topic+.rxWithSinkBoth'></span>

<h3>Description</h3>

<p>With one sink, then release
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rxWithSink(file, code)

.rxWithSinkBoth(file, code)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".rxWithSink_+3A_file">file</code></td>
<td>
<p>the path to the file sink while running the <code>code</code></p>
</td></tr>
<tr><td><code id=".rxWithSink_+3A_code">code</code></td>
<td>
<p>The code to run during the sink</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>.rxWithSink</code> captures output from <code>cat</code>
</p>
<p><code>.rxWithSinkBoth</code> captures output from <code>cat</code> and <code>message</code>
</p>


<h3>Value</h3>

<p>Will return the results of the <code>code</code> section
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
t &lt;- tempfile()
.rxWithSink(t, cat("message\n"))
cat("cat2\n") # now you can see the cat2
lines &lt;- readLines(t)
unlink(t)
</code></pre>

<hr>
<h2 id='.rxWithWd'>Temporarily set options then restore them while running code</h2><span id='topic+.rxWithWd'></span>

<h3>Description</h3>

<p>Temporarily set options then restore them while running code
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rxWithWd(wd, code)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".rxWithWd_+3A_wd">wd</code></td>
<td>
<p>working directory to temporarily set the system to while
evaluating the code</p>
</td></tr>
<tr><td><code id=".rxWithWd_+3A_code">code</code></td>
<td>
<p>The code to run during the sink</p>
</td></tr>
</table>


<h3>Value</h3>

<p>value of code
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
.rxWithWd(tempdir(), {
  getwd()
})

getwd()
</code></pre>

<hr>
<h2 id='.useUtf'>Internal function to figure out if this session supports Unicode</h2><span id='topic+.useUtf'></span>

<h3>Description</h3>

<p>Internal function to figure out if this session supports Unicode
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.useUtf()
</code></pre>


<h3>Value</h3>

<p>boolean indicating if this session supports Unicode
</p>

<hr>
<h2 id='+2B.rxSolve'>Update Solved object with '+'</h2><span id='topic++2B.rxSolve'></span>

<h3>Description</h3>

<p>Update Solved object with '+'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rxSolve'
solved + new
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B2B.rxSolve_+3A_solved">solved</code></td>
<td>
<p>Solved object</p>
</td></tr>
<tr><td><code id="+2B2B.rxSolve_+3A_new">new</code></td>
<td>
<p>New information added to the table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>new solved object
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='as.ini'>Turn into an ini block for initialization</h2><span id='topic+as.ini'></span><span id='topic+as.ini.character'></span><span id='topic+as.ini.data.frame'></span><span id='topic+as.ini.call'></span><span id='topic+as.ini.lotriFix'></span><span id='topic+as.ini.matrix'></span><span id='topic+as.ini.default'></span>

<h3>Description</h3>

<p>Turn into an ini block for initialization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.ini(x)

## S3 method for class 'character'
as.ini(x)

## S3 method for class 'data.frame'
as.ini(x)

## S3 method for class 'call'
as.ini(x)

## S3 method for class 'lotriFix'
as.ini(x)

## S3 method for class 'matrix'
as.ini(x)

## Default S3 method:
as.ini(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.ini_+3A_x">x</code></td>
<td>
<p>Item to convert to a rxode2/nlmixr2 ui ini expression</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rxode2 ini expression
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ini &lt;- quote(ini({
  tka &lt;- log(1.57)
  tcl &lt;- log(2.72)
  tv &lt;- log(31.5)
  eta.ka ~ 0.6
  eta.cl ~ 0.3
  eta.v ~ 0.1
  add.sd &lt;- 0.7
}))

as.ini(ini)

l &lt;- quote(lotri({
  tka &lt;- log(1.57)
  tcl &lt;- log(2.72)
  tv &lt;- log(31.5)
  eta.ka ~ 0.6
  eta.cl ~ 0.3
  eta.v ~ 0.1
  add.sd &lt;- 0.7
 }))

as.ini(l)

m &lt;- lotri({
   eta.ka ~ 0.6
   eta.cl ~ 0.3
   eta.v ~ 0.1
})

as.ini(m)

one.compartment &lt;- function() {
  ini({
    tka &lt;- log(1.57)
    tcl &lt;- log(2.72)
    tv &lt;- log(31.5)
    eta.ka ~ 0.6
    eta.cl ~ 0.3
    eta.v ~ 0.1
    add.sd &lt;- 0.7
  })
  model({
    ka &lt;- exp(tka + eta.ka)
    cl &lt;- exp(tcl + eta.cl)
    v &lt;- exp(tv + eta.v)
    d/dt(depot) = -ka * depot
    d/dt(center) = ka * depot - cl / v * center
    cp = center / v
    cp ~ add(add.sd)
  })
}

as.ini(one.compartment)

ui &lt;- one.compartment()

as.ini(ui)

ui$iniDf

as.ini(ui$iniDf)

ini &lt;- c("ini({",
          "tka &lt;- log(1.57)",
          "tcl &lt;- log(2.72)",
          "tv &lt;- log(31.5)",
          "eta.ka ~ 0.6",
          "eta.cl ~ 0.3",
          "eta.v ~ 0.1",
          "add.sd &lt;- 0.7",
          "})")

as.ini(ini)

ini &lt;- paste(ini, collapse="\n")

as.ini(ini)

</code></pre>

<hr>
<h2 id='as.model'>Turn into a model expression</h2><span id='topic+as.model'></span><span id='topic+as.model.character'></span><span id='topic+as.model.call'></span><span id='topic+as.model.list'></span><span id='topic+as.model.default'></span>

<h3>Description</h3>

<p>Turn into a model expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.model(x)

## S3 method for class 'character'
as.model(x)

## S3 method for class 'call'
as.model(x)

## S3 method for class 'list'
as.model(x)

## Default S3 method:
as.model(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.model_+3A_x">x</code></td>
<td>
<p>item to convert to a <code>model({})</code> expression</p>
</td></tr>
</table>


<h3>Value</h3>

<p>model expression
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
model &lt;- quote(model({
  ka &lt;- exp(tka + eta.ka)
  cl &lt;- exp(tcl + eta.cl)
  v &lt;- exp(tv + eta.v)
  d/dt(depot) = -ka * depot
  d/dt(center) = ka * depot - cl / v * center
  cp = center / v
  cp ~ add(add.sd)
}))
 
as.model(model)

one.compartment &lt;- function() {
  ini({
    tka &lt;- log(1.57)
    tcl &lt;- log(2.72)
    tv &lt;- log(31.5)
    eta.ka ~ 0.6
    eta.cl ~ 0.3
    eta.v ~ 0.1
    add.sd &lt;- 0.7
  })
  model({
    ka &lt;- exp(tka + eta.ka)
    cl &lt;- exp(tcl + eta.cl)
    v &lt;- exp(tv + eta.v)
    d/dt(depot) = -ka * depot
    d/dt(center) = ka * depot - cl / v * center
    cp = center / v
    cp ~ add(add.sd)
  })
}

as.model(one.compartment)
 
ui &lt;- one.compartment()

as.model(ui)

model &lt;- c("model({",
           "ka &lt;- exp(tka + eta.ka)",
           "cl &lt;- exp(tcl + eta.cl)",
           "v &lt;- exp(tv + eta.v)",
           "d/dt(depot) = -ka * depot",
           "d/dt(center) = ka * depot - cl / v * center",
           "cp = center / v",
           "cp ~ add(add.sd)",
           "})")

as.model(model)

model &lt;- paste(model, collapse="\n")

as.model(model)

</code></pre>

<hr>
<h2 id='as.rxUi'>As rxode2 ui</h2><span id='topic+as.rxUi'></span><span id='topic+as.rxUi.rxode2'></span><span id='topic+as.rxUi.rxode2tos'></span><span id='topic+as.rxUi.rxModelVars'></span><span id='topic+as.rxUi.function'></span><span id='topic+as.rxUi.rxUi'></span><span id='topic+as.rxUi.default'></span>

<h3>Description</h3>

<p>As rxode2 ui
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.rxUi(x)

## S3 method for class 'rxode2'
as.rxUi(x)

## S3 method for class 'rxode2tos'
as.rxUi(x)

## S3 method for class 'rxModelVars'
as.rxUi(x)

## S3 method for class ''function''
as.rxUi(x)

## S3 method for class 'rxUi'
as.rxUi(x)

## Default S3 method:
as.rxUi(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.rxUi_+3A_x">x</code></td>
<td>
<p>Object to convert to <code>rxUi</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rxUi object (or error if it cannot be converted)
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mod1 &lt;- function() {
 ini({
   # central 
   KA=2.94E-01
   CL=1.86E+01
   V2=4.02E+01
   # peripheral
   Q=1.05E+01
   V3=2.97E+02
   # effects
   Kin=1
   Kout=1
   EC50=200 
 })
 model({
   C2 &lt;- centr/V2
   C3 &lt;- peri/V3
   d/dt(depot) &lt;- -KA*depot
   d/dt(centr) &lt;- KA*depot - CL*C2 - Q*C2 + Q*C3
   d/dt(peri)  &lt;- Q*C2 - Q*C3
   eff(0) &lt;- 1
   d/dt(eff)   &lt;- Kin - Kout*(1-C2/(EC50+C2))*eff
 })
}

as.rxUi(mod1)

</code></pre>

<hr>
<h2 id='assertRxUi'>Assert properties of the rxUi models</h2><span id='topic+assertRxUi'></span><span id='topic+assertRxUiPrediction'></span><span id='topic+assertRxUiSingleEndpoint'></span><span id='topic+assertRxUiTransformNormal'></span><span id='topic+assertRxUiNormal'></span><span id='topic+assertRxUiMuRefOnly'></span><span id='topic+assertRxUiEstimatedResiduals'></span><span id='topic+assertRxUiPopulationOnly'></span><span id='topic+assertRxUiMixedOnly'></span><span id='topic+assertRxUiRandomOnIdOnly'></span>

<h3>Description</h3>

<p>Assert properties of the rxUi models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assertRxUi(model, extra = "", .var.name = .vname(model))

assertRxUiPrediction(model, extra = "", .var.name = .vname(model))

assertRxUiSingleEndpoint(model, extra = "", .var.name = .vname(model))

assertRxUiTransformNormal(model, extra = "", .var.name = .vname(model))

assertRxUiNormal(model, extra = "", .var.name = .vname(model))

assertRxUiMuRefOnly(model, extra = "", .var.name = .vname(model))

assertRxUiEstimatedResiduals(model, extra = "", .var.name = .vname(model))

assertRxUiPopulationOnly(model, extra = "", .var.name = .vname(model))

assertRxUiMixedOnly(model, extra = "", .var.name = .vname(model))

assertRxUiRandomOnIdOnly(model, extra = "", .var.name = .vname(model))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assertRxUi_+3A_model">model</code></td>
<td>
<p>Model to check</p>
</td></tr>
<tr><td><code id="assertRxUi_+3A_extra">extra</code></td>
<td>
<p>Extra text to append to the error message (like
&quot;for focei&quot;)</p>
</td></tr>
<tr><td><code id="assertRxUi_+3A_.var.name">.var.name</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Name of the checked object to print in assertions. Defaults to
the heuristic implemented in <code><a href="checkmate.html#topic+vname">vname</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions have different types of assertions
</p>

<ul>
<li> <p><code>assertRxUi</code> &ndash; Make sure this is a proper rxode2 model (if not throw error)
</p>
</li>
<li> <p><code>assertRxUiSingleEndpoint</code> &ndash; Make sure the rxode2 model is only
a single endpoint model (if not throw error)
</p>
</li>
<li> <p><code>assertRxUiTransformNormal</code> &ndash; Make sure that the model residual
distribution is normal or transformably normal
</p>
</li>
<li> <p><code>assertRxUiNormal</code> &ndash; Make sure that the model residual distribution is normal
</p>
</li>
<li> <p><code>assertRxUiEstimatedResiduals</code> &ndash; Make sure that the residual error
parameters are estimated (not modeled).
</p>
</li>
<li> <p><code>assertRxUiPopulationOnly</code> &ndash; Make sure the model is the population only
model (no mixed effects)
</p>
</li>
<li> <p><code>assertRxUiMixedOnly</code> &ndash; Make sure the model is a mixed effect model (not a
population effect, only)
</p>
</li>
<li> <p><code>assertRxUiPrediction</code> &ndash; Make sure the model has predictions
</p>
</li>
<li> <p><code>assertRxUiMuRefOnly</code> &ndash; Make sure that all the parameters are mu-referenced
</p>
</li>
<li> <p><code>assertRxUiRandomOnIdOnly</code> &ndash; Make sure there are only random effects at the ID level
</p>
</li></ul>



<h3>Value</h3>

<p>the rxUi model
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

one.cmt &lt;- function() {
 ini({
   tka &lt;- 0.45; label("Ka")
   tcl &lt;- log(c(0, 2.7, 100)); label("Cl")
   tv &lt;- 3.45; label("V")
   eta.ka ~ 0.6
   eta.cl ~ 0.3
   eta.v ~ 0.1
   add.sd &lt;- 0.7
 })
 model({
   ka &lt;- exp(tka + eta.ka)
   cl &lt;- exp(tcl + eta.cl)
   v &lt;- exp(tv + eta.v)
   linCmt() ~ add(add.sd)
 })
}

assertRxUi(one.cmt)
# assertRxUi(rnorm) # will fail

assertRxUiSingleEndpoint(one.cmt)

</code></pre>

<hr>
<h2 id='binomProbs'>Calculate expected confidence bands with binomial sampling distribution</h2><span id='topic+binomProbs'></span><span id='topic+binomProbs.default'></span>

<h3>Description</h3>

<p>This is meant to perform in the same way as <code>quantile()</code> so it can
be a drop in replacement for code using <code>quantile()</code> but using
distributional assumptions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binomProbs(x, ...)

## Default S3 method:
binomProbs(
  x,
  probs = c(0.025, 0.05, 0.5, 0.95, 0.975),
  na.rm = FALSE,
  names = TRUE,
  onlyProbs = TRUE,
  n = 0L,
  m = 0L,
  pred = FALSE,
  piMethod = c("lim"),
  M = 5e+05,
  tol = .Machine$double.eps^0.25,
  ciMethod = c("wilson", "wilsonCorrect", "agrestiCoull", "wald", "wc", "ac"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binomProbs_+3A_x">x</code></td>
<td>
<p>numeric vector whose mean and probability based confidence
values are wanted, NA and NaN values are not allowed in numeric
vectors unless <code>na.rm</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="binomProbs_+3A_...">...</code></td>
<td>
<p>Arguments passed to default method, allows many
different methods to be applied.</p>
</td></tr>
<tr><td><code id="binomProbs_+3A_probs">probs</code></td>
<td>
<p>numeric vector of probabilities with values in the
interval 0 to 1, inclusive. When 0, it represents the maximum
observed, when 1, it represents the maximum observed. When 0.5 it
represents the expected probability (mean).</p>
</td></tr>
<tr><td><code id="binomProbs_+3A_na.rm">na.rm</code></td>
<td>
<p>logical; if true, any NA and NaN's are removed from
<code>x</code> before the quantiles are computed.</p>
</td></tr>
<tr><td><code id="binomProbs_+3A_names">names</code></td>
<td>
<p>logical; if true, the result has a names attribute.</p>
</td></tr>
<tr><td><code id="binomProbs_+3A_onlyprobs">onlyProbs</code></td>
<td>
<p>logical; if true, only return the probability
based confidence interval/prediction interval estimates,
otherwise return extra statistics.</p>
</td></tr>
<tr><td><code id="binomProbs_+3A_n">n</code></td>
<td>
<p>integer/integerish; this is the n used to calculate the
prediction or confidence interval.  When <code>n=0</code> (default) use the
number of non-<code>NA</code> observations.  When calculating the prediction
interval, this represents the number of observations used in the
input (&quot;true&quot;) distribution.</p>
</td></tr>
<tr><td><code id="binomProbs_+3A_m">m</code></td>
<td>
<p>integer.  When using the prediction interval this
represents the number of samples that will be observed in the
future for the prediction interval.</p>
</td></tr>
<tr><td><code id="binomProbs_+3A_pred">pred</code></td>
<td>
<p>Use a prediction interval instead of a confidence
interval.  By default this is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="binomProbs_+3A_pimethod">piMethod</code></td>
<td>
<p>gives the prediction interval method (currently only lim) from Lu 2020</p>
</td></tr>
<tr><td><code id="binomProbs_+3A_m">M</code></td>
<td>
<p>number of simulations to run for the LIM PI.</p>
</td></tr>
<tr><td><code id="binomProbs_+3A_tol">tol</code></td>
<td>
<p>tolerance of root finding in the LIM prediction interval</p>
</td></tr>
<tr><td><code id="binomProbs_+3A_cimethod">ciMethod</code></td>
<td>
<p>gives the method for calculating the confidence
interval.
</p>
<p>Can be:
</p>

<ul>
<li><p> &quot;argestiCoull&quot; or &quot;ac&quot; &ndash; Agresti-Coull method. For a 95\
interval, this method does not use the concept   of &quot;adding 2
successes and 2 failures,&quot; but rather uses the formulas explicitly
described in the following link:
</p>
</li></ul>

<p>https://en.wikipedia.org/wiki/Binomial_proportion_confidence_interval#Agresti-Coull_Interval.
</p>

<ul>
<li><p> &quot;wilson&quot; &ndash; Wilson Method
</p>
</li>
<li><p> &quot;wilsonCorrect&quot; or &quot;wc&quot; &ndash; Wilson method with continuity correction
</p>
</li>
<li><p> &quot;wald&quot; &ndash; Wald confidence interval or standard z approximation.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>It is used for confidence intervals with rxode2 solved objects using
<code>confint(mean="binom")</code>
</p>


<h3>Value</h3>

<p>By default the return has the probabilities as names (if
named) with the points where the expected distribution are
located given the sampling mean and standard deviation. If
<code>onlyProbs=FALSE</code> then it would prepend mean, variance, standard
deviation, minimum, maximum and number of non-NA observations.
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>References</h3>


<ul>
<li><p> Newcombe, R. G. (1998). &quot;Two-sided confidence intervals for the single
proportion: comparison of seven methods&quot;. Statistics
in Medicine. 17 (8):
857872. doi:10.1002/(SICI)1097-0258(19980430)17:8&lt;857::AID-SIM777&gt;3.0.CO;2-E. PMID
9595616.
</p>
</li>
<li><p> Hezhi Lu, Hua Jin,
A new prediction interval for binomial random variable based on inferential models,
Journal of Statistical Planning and Inference,
Volume 205,
2020,
Pages 156-174,
ISSN 0378-3758,
https://doi.org/10.1016/j.jspi.2019.07.001.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
x&lt;- rbinom(7001, p=0.375, size=1)
binomProbs(x)

# you can also use the prediction interval

binomProbs(x, pred=TRUE)


# Can get some extra statistics if you request onlyProbs=FALSE
binomProbs(x, onlyProbs=FALSE)

x[2] &lt;- NA_real_

binomProbs(x, onlyProbs=FALSE)

binomProbs(x, na.rm=TRUE)

</code></pre>

<hr>
<h2 id='coef.rxode2'>Return the rxode2 coefficients</h2><span id='topic+coef.rxode2'></span>

<h3>Description</h3>

<p>This returns the parameters , state variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rxode2'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.rxode2_+3A_object">object</code></td>
<td>
<p>is an rxode2 object</p>
</td></tr>
<tr><td><code id="coef.rxode2_+3A_...">...</code></td>
<td>
<p>ignored arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a rxCoef object with the following
</p>

<ul>
<li> <p><code>params</code>  is a list of strings for parameters for the rxode2 object
</p>
</li>
<li> <p><code>state</code> is a list of strings for the names of each state in
the rxode2 object.
</p>
</li>
<li> <p><code>ini</code> is the model specified default values for the
parameters.
</p>
</li>
<li> <p><code>rxode2</code> is the referring rxode2 object
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>

<hr>
<h2 id='erf'>Error function</h2><span id='topic+erf'></span>

<h3>Description</h3>

<p>Error function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>erf(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="erf_+3A_x">x</code></td>
<td>
<p>vector or real values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>erf of x
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>erf(1.0)
</code></pre>

<hr>
<h2 id='etTrans'>Event translation for rxode2</h2><span id='topic+etTrans'></span>

<h3>Description</h3>

<p>Event translation for rxode2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>etTrans(
  inData,
  obj,
  addCmt = FALSE,
  dropUnits = FALSE,
  allTimeVar = FALSE,
  keepDosingOnly = FALSE,
  combineDvid = NULL,
  keep = character(0),
  addlKeepsCov = FALSE,
  addlDropSs = TRUE,
  ssAtDoseTime = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="etTrans_+3A_indata">inData</code></td>
<td>
<p>Data frame to translate</p>
</td></tr>
<tr><td><code id="etTrans_+3A_obj">obj</code></td>
<td>
<p>Model to translate data</p>
</td></tr>
<tr><td><code id="etTrans_+3A_addcmt">addCmt</code></td>
<td>
<p>Add compartment to data frame (default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="etTrans_+3A_dropunits">dropUnits</code></td>
<td>
<p>Boolean to drop the units (default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="etTrans_+3A_alltimevar">allTimeVar</code></td>
<td>
<p>Treat all covariates as if they were time-varying</p>
</td></tr>
<tr><td><code id="etTrans_+3A_keepdosingonly">keepDosingOnly</code></td>
<td>
<p>keep the individuals who only have dosing records and any
trailing dosing records after the last observation.</p>
</td></tr>
<tr><td><code id="etTrans_+3A_combinedvid">combineDvid</code></td>
<td>
<p>is a boolean indicating if rxode2 will use <code>DVID</code> on observation
records to change the <code>cmt</code> value; Useful for multiple-endpoint nlmixr models.  By default
this is determined by <code>option("rxode2.combine.dvid")</code> and if the option has not been set,
this is <code>TRUE</code>. This typically does not affect rxode2 simulations.</p>
</td></tr>
<tr><td><code id="etTrans_+3A_keep">keep</code></td>
<td>
<p>This is a named vector of items you want to keep in the final rxode2 dataset.
For added rxode2 event records (if seen), last observation carried forward will be used.</p>
</td></tr>
<tr><td><code id="etTrans_+3A_addlkeepscov">addlKeepsCov</code></td>
<td>
<p>This determines if the additional dosing items
repeats the dose only (<code>FALSE</code>) or keeps the covariates at the
record of the dose (<code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="etTrans_+3A_addldropss">addlDropSs</code></td>
<td>
<p>When there are steady state doses with an <code>addl</code>
specification the steady state flag is dropped with repeated
doses (when <code>TRUE</code>) or retained (when <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="etTrans_+3A_ssatdosetime">ssAtDoseTime</code></td>
<td>
<p>Boolean that when <code>TRUE</code> back calculates the
steady concentration at the actual time of dose, otherwise when
<code>FALSE</code> the doses are shifted</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object for solving in rxode2
</p>

<hr>
<h2 id='findLhs'>Find the assignments in R expression</h2><span id='topic+findLhs'></span>

<h3>Description</h3>

<p>Find the assignments in R expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findLhs(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findLhs_+3A_x">x</code></td>
<td>
<p>R expression</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of assigned parameters
</p>


<h3>Author(s)</h3>

<p>Hadley Wickham and Matthew L. Fidler
</p>

<hr>
<h2 id='gammap'>Gammap: normalized lower incomplete gamma function</h2><span id='topic+gammap'></span>

<h3>Description</h3>

<p>This is the gamma_p from the boost library
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gammap(a, z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gammap_+3A_a">a</code></td>
<td>
<p>The numeric 'a' parameter in the normalized lower
incomplete gamma</p>
</td></tr>
<tr><td><code id="gammap_+3A_z">z</code></td>
<td>
<p>The numeric 'z' parameter in the normalized lower
incomplete gamma</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The gamma p function is given by:
</p>
<p>gammap = lowergamma(a, z)/gamma(a)
</p>


<h3>Value</h3>

<p>gammap results
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gammap(1, 3)
gammap(1:3, 3)
gammap(1, 1:3)
</code></pre>

<hr>
<h2 id='gammapDer'>gammapDer:  derivative of gammap</h2><span id='topic+gammapDer'></span>

<h3>Description</h3>

<p>This is the gamma_p_derivative from the boost library
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gammapDer(a, z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gammapDer_+3A_a">a</code></td>
<td>
<p>The numeric 'a' parameter in the upper
incomplete gamma</p>
</td></tr>
<tr><td><code id="gammapDer_+3A_z">z</code></td>
<td>
<p>The numeric 'z' parameter in the upper
incomplete gamma</p>
</td></tr>
</table>


<h3>Value</h3>

<p>lowergamma results
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gammapDer(1:3, 3)

gammapDer(1, 1:3)
</code></pre>

<hr>
<h2 id='gammapInv'>gammapInv and gammapInva:  Inverses of normalized gammap function</h2><span id='topic+gammapInv'></span><span id='topic+gammapInva'></span>

<h3>Description</h3>

<p>gammapInv and gammapInva:  Inverses of normalized gammap function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gammapInv(a, p)

gammapInva(x, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gammapInv_+3A_a">a</code></td>
<td>
<p>The numeric 'a' parameter in the upper
incomplete gamma</p>
</td></tr>
<tr><td><code id="gammapInv_+3A_p">p</code></td>
<td>
<p>The numeric 'p' parameter in the upper incomplete gamma</p>
</td></tr>
<tr><td><code id="gammapInv_+3A_x">x</code></td>
<td>
<p>The numeric 'x' parameter in the upper incomplete gamma</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With the equation:
</p>
<p>p = gammap(a, x)
</p>
<p>The 'gammapInv' function returns a value 'x' that satisfies the
equation above
</p>
<p>The 'gammapInva' function returns a value 'q' that satisfies the
equation above
</p>
<p>NOTE: gammapInva is slow
</p>


<h3>Value</h3>

<p>inverse gammap results
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gammapInv(1:3, 0.5)

gammapInv(1, 1:3 / 3.1)

gammapInv(1:3, 1:3 / 3.1)

gammapInva(1:3, 1:3 / 3.1)
</code></pre>

<hr>
<h2 id='gammaq'>Gammaq: normalized upper incomplete gamma function</h2><span id='topic+gammaq'></span>

<h3>Description</h3>

<p>This is the gamma_q from the boost library
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gammaq(a, z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gammaq_+3A_a">a</code></td>
<td>
<p>The numeric 'a' parameter in the normalized upper
incomplete gamma</p>
</td></tr>
<tr><td><code id="gammaq_+3A_z">z</code></td>
<td>
<p>The numeric 'z' parameter in the normalized upper
incomplete gamma</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The gamma q function is given by:
</p>
<p>gammaq = uppergamma(a, z)/gamma(a)
</p>


<h3>Value</h3>

<p>gammaq results
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gammaq(1, 3)
gammaq(1:3, 3)
gammaq(1, 1:3)
</code></pre>

<hr>
<h2 id='gammaqInv'>gammaqInv and gammaqInva:  Inverses of normalized gammaq function</h2><span id='topic+gammaqInv'></span><span id='topic+gammaqInva'></span>

<h3>Description</h3>

<p>gammaqInv and gammaqInva:  Inverses of normalized gammaq function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gammaqInv(a, q)

gammaqInva(x, q)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gammaqInv_+3A_a">a</code></td>
<td>
<p>The numeric 'a' parameter in the upper
incomplete gamma</p>
</td></tr>
<tr><td><code id="gammaqInv_+3A_q">q</code></td>
<td>
<p>The numeric 'q' parameter in the upper
incomplete gamma</p>
</td></tr>
<tr><td><code id="gammaqInv_+3A_x">x</code></td>
<td>
<p>The numeric 'x' parameter in the upper incomplete gamma</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With the equation:
</p>
<p>q = gammaq(a, x)
</p>
<p>The 'gammaqInv' function returns a value 'x' that satisfies the
equation above
</p>
<p>The 'gammaqInva' function returns a value 'a' that satisfies the
equation above
</p>
<p>NOTE: gammaqInva is slow
</p>


<h3>Value</h3>

<p>inverse gammaq results
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gammaqInv(1:3, 0.5)

gammaqInv(1, 1:3 / 3)

gammaqInv(1:3, 1:3 / 3.1)

gammaqInva(1:3, 1:3 / 3.1)
</code></pre>

<hr>
<h2 id='genShinyApp.template'>Generate an example (template) of a dosing regimen shiny app</h2><span id='topic+genShinyApp.template'></span><span id='topic+write.template.server'></span><span id='topic+write.template.ui'></span>

<h3>Description</h3>

<p>Create a complete shiny application for exploring dosing regimens
given a (hardcoded) PK/PD model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genShinyApp.template(
  appDir = "shinyExample",
  verbose = TRUE,
  ODE.config = list(ode = "model", params = c(KA = 0.294), inits = c(eff = 1), method =
    "lsoda", atol = 1e-08, rtol = 1e-06)
)

write.template.server(appDir)

write.template.ui(appDir, statevars)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="genShinyApp.template_+3A_appdir">appDir</code></td>
<td>
<p>a string with a directory where to store the shiny
app, by default is <code>"shinyExample"</code>. The directory
<code>appDir</code> will be created if it does not exist.</p>
</td></tr>
<tr><td><code id="genShinyApp.template_+3A_verbose">verbose</code></td>
<td>
<p>logical specifying whether to write messages as the
shiny app is generated. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="genShinyApp.template_+3A_ode.config">ODE.config</code></td>
<td>
<p>model name compiled and list of parameters sent to <code><a href="#topic+rxSolve">rxSolve()</a></code>.</p>
</td></tr>
<tr><td><code id="genShinyApp.template_+3A_statevars">statevars</code></td>
<td>
<p>List of statevars passed to to the <code><a href="#topic+write.template.ui">write.template.ui()</a></code> function.  This usually isn't called directly.
</p>
<p>A PK/PD model is defined using <code><a href="#topic+rxode2">rxode2()</a></code>, and
a set of parameters and initial values are defined.  Then
the appropriate R scripts for the shiny's user interface <code>ui.R</code>
and the server logic <code>server.R</code> are created in the
directory <code>appDir</code>.
</p>
<p>The function evaluates the following PK/PD model by default:
</p>
<pre>
    C2 = centr/V2;
    C3 = peri/V3;
    d/dt(depot) =-KA*depot;
    d/dt(centr) = KA*depot - CL*C2 - Q*C2 + Q*C3;
    d/dt(peri)  =                    Q*C2 - Q*C3;
    d/dt(eff)  = Kin - Kout*(1-C2/(EC50+C2))*eff;
</pre>
<p>This can be changed by the <code>ODE.config</code> parameter.
</p>
<p>To launch the shiny app, simply issue the <code>runApp(appDir)</code>
R command.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None, these functions are used for their side effects.
</p>


<h3>Note</h3>

<p>These functions create a simple, but working example of a
dosing regimen simulation web application. Users may want to
modify the code to experiment creating shiny applications for
their specific <code>rxode2</code> models.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rxode2">rxode2()</a></code>,<code><a href="#topic+eventTable">eventTable()</a></code>, and the package <span class="pkg">shiny</span> (<a href="https://shiny.posit.co">https://shiny.posit.co</a>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# remove myapp when the example is complete
on.exit(unlink("myapp", recursive = TRUE, force = TRUE))
# create the shiny app example (template)
genShinyApp.template(appDir = "myapp")
# run the shiny app
if (requireNamespace("shiny", quietly=TRUE)) {
  library(shiny)
  # runApp("myapp") # Won't launch in environments without browsers
}

</code></pre>

<hr>
<h2 id='getBaseIniSimModel'>Get the base simulation model for simulation with inis in the
underlying rxode2 model</h2><span id='topic+getBaseIniSimModel'></span>

<h3>Description</h3>

<p>Get the base simulation model for simulation with inis in the
underlying rxode2 model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBaseIniSimModel(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBaseIniSimModel_+3A_obj">obj</code></td>
<td>
<p>Fit Object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Simulation object
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='getBaseSimModel'>Get the base simulation model for simulation</h2><span id='topic+getBaseSimModel'></span><span id='topic+getBaseSimModel.default'></span><span id='topic+getBaseIniSimModel.default'></span>

<h3>Description</h3>

<p>Get the base simulation model for simulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBaseSimModel(obj)

## Default S3 method:
getBaseSimModel(obj)

## Default S3 method:
getBaseIniSimModel(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBaseSimModel_+3A_obj">obj</code></td>
<td>
<p>Fit Object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Simulation object
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='getBaseSymengineModel'>Get the symengine for loading into symengine with <code>rxS()</code></h2><span id='topic+getBaseSymengineModel'></span>

<h3>Description</h3>

<p>Get the symengine for loading into symengine with <code>rxS()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBaseSymengineModel(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getBaseSymengineModel_+3A_obj">obj</code></td>
<td>
<p>Object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Simulation model ready to load into symeng
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='getRxThreads'>Get/Set the number of threads that rxode2 uses</h2><span id='topic+getRxThreads'></span><span id='topic+setRxThreads'></span><span id='topic+rxCores'></span>

<h3>Description</h3>

<p>Get/Set the number of threads that rxode2 uses
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRxThreads(verbose = FALSE)

setRxThreads(threads = NULL, percent = NULL, throttle = NULL)

rxCores(verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getRxThreads_+3A_verbose">verbose</code></td>
<td>
<p>Display the value of relevant OpenMP settings</p>
</td></tr>
<tr><td><code id="getRxThreads_+3A_threads">threads</code></td>
<td>
<p>NULL (default) rereads environment variables. 0
means to use all logical CPUs available. Otherwise a number &gt;= 1</p>
</td></tr>
<tr><td><code id="getRxThreads_+3A_percent">percent</code></td>
<td>
<p>If provided it should be a number between 2 and
100; the percentage of logical CPUs to use. By default on
startup, 50 percent.</p>
</td></tr>
<tr><td><code id="getRxThreads_+3A_throttle">throttle</code></td>
<td>
<p>2 (default) means that, roughly speaking, a
single thread will be used when number subjects solved for is &lt;=2, 2 threads when
the number of all points is &lt;=4, etc. The throttle is to speed up small data
tasks (especially when repeated many times) by not incurring the
overhead of managing multiple threads.
</p>
<p>The throttle will also suppress sorting which ID will be solved first
when there are (nsubject solved)*throttle &lt;= nthreads.  In
<code>rxode2</code> this sorting occurs to minimize the time for waiting for
another thread to finish. If the last item solved is has a long
solving time, all the other solving have to wait for that last
costly solving to occur. If the items which are likely to take
more time are solved first, this wait is less likely to have an
impact on the overall solving time.
</p>
<p>In rxode2 the IDs are sorted by the individual number of solving
points (largest first). It also has a C interface that allows
these IDs to be resorted by total time spent solving the
equation.  This allows packages like nlmixr to sort by solving
time if needed.
</p>
<p>Overall the the number of threads is throttled (restricted) for
small tasks and sorting for IDs are suppressed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number of threads that rxode2 uses
</p>

<hr>
<h2 id='guide_none'>Empty Guide</h2><span id='topic+guide_none'></span>

<h3>Description</h3>

<p>This empty guide draws nothing; It is included in rxode2 for
compatibility with ggplot 3.2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guide_none(title = waiver(), position = waiver())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guide_none_+3A_title">title</code></td>
<td>
<p>A character string or expression indicating a title of guide.
If <code>NULL</code>, the title is not shown. By default
(<code><a href="ggplot2.html#topic+waiver">waiver()</a></code>), the name of the scale object or the name
specified in <code><a href="ggplot2.html#topic+labs">labs()</a></code> is used for the title.</p>
</td></tr>
<tr><td><code id="guide_none_+3A_position">position</code></td>
<td>
<p>Where this guide should be drawn: one of top, bottom,
left, or right.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing, simply included to be compatible with ggplot 3.2
</p>

<hr>
<h2 id='ini.rxUi'>Ini block for rxode2/nlmixr models</h2><span id='topic+ini.rxUi'></span><span id='topic+ini.default'></span><span id='topic+ini'></span>

<h3>Description</h3>

<p>The ini block controls initial conditions for 'theta' (fixed effects),
'omega' (random effects), and 'sigma' (residual error) elements of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rxUi'
ini(x, ..., envir = parent.frame(), append = NULL)

## Default S3 method:
ini(x, ..., envir = parent.frame(), append = NULL)

ini(x, ..., envir = parent.frame(), append = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ini.rxUi_+3A_x">x</code></td>
<td>
<p>expression</p>
</td></tr>
<tr><td><code id="ini.rxUi_+3A_...">...</code></td>
<td>
<p>Other expressions for <code>ini()</code> function</p>
</td></tr>
<tr><td><code id="ini.rxUi_+3A_envir">envir</code></td>
<td>
<p>the <code>environment</code> in which unevaluated model
expressions is to be evaluated.  May also be <code>NULL</code>, a list, a
data frame, a pairlist or an integer as specified to <code>sys.call</code>.</p>
</td></tr>
<tr><td><code id="ini.rxUi_+3A_append">append</code></td>
<td>
<p>Reorder theta parameters.  <code>NULL</code> means no change to
parameter order.  A parameter name (as a character string) means to put the
new parameter after the named parameter.  A number less than or equal to
zero means to put the parameter at the beginning of the list.  A number
greater than the last parameter number means to put the parameter at the
end of the list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>ini()</code> function is used in two different ways.  The main way that
it is used is to set the initial conditions and associated attributes
(described below) in a model.  The other way that it is used is for updating
the initial conditions in a model, often using the pipe operator.
</p>
<p>'theta' and 'sigma' can be set using either <code>&lt;-</code> or <code>=</code> such as
<code>tvCL &lt;- 1</code> or equivalently <code>tvCL = 1</code>.  'omega' can be set with a
<code>~</code> such as <code>etaCL ~ 0.1</code>.
</p>
<p>Parameters can be named or unnamed (though named parameters are preferred).
A named parameter is set using the name on the left of the assignment while
unnamed parameters are set without an assignment operator.  <code>tvCL &lt;- 1</code>
would set a named parameter of <code>tvCL</code> to <code>1</code>.  Unnamed parameters
are set using just the value, such as <code>1</code>.
</p>
<p>For some estimation methods, lower and upper bounds can be set for 'theta'
and 'sigma' values.  To set a lower and/or upper bound, use a vector of
values.  The vector is <code>c(lower, estimate, upper)</code>.  The vector may be
given with just the estimate (<code>estimate</code>), the lower bound and
estimate (<code>c(lower, estimate)</code>), or all three (<code>c(lower, estimate,
upper)</code>).  To set an estimate and upper bound without a lower bound, set the
lower bound to <code>-Inf</code>, <code>c(-Inf, estimate, upper)</code>.  When an
estimation method does not support bounds, the bounds will be ignored with a
warning.
</p>
<p>'omega' values can be set as a single value or as the values of a
lower-triangular matrix.  The values may be set as either a
variance-covariance matrix (the default) or as a correlation matrix for the
off-diagonals with the standard deviations on the diagonals.  Names may be
set on the left side of the <code>~</code>.  To set a variance-covariance matrix
with variance values of 2 and 3 and a covariance of -2.5 use <code>~c(2, 2.5,
3)</code>.  To set the same matrix with names of <code>iivKa</code> and <code>iivCL</code>, use
<code>iivKa + iivCL~c(2, 2.5, 3)</code>.  To set a correlation matrix with standard
deviations on the diagonal, use <code>cor()</code> like <code>iivKa + iivCL~cor(2,
-0.5, 3)</code>.
</p>
<p>Values may be fixed (and therefore not estimated) using either the name
<code>fixed</code> at the end of the assignment or by calling <code>fixed()</code> as a
function for the value to fix.  For 'theta' and 'sigma', either the estimate
or the full definition (including lower and upper bounds) may be included in
the fixed setting.  For example, the following are all effectively equivalent
to set a 'theta' or 'sigma' to a fixed value (because the lower and upper
bounds are ignored for a fixed value): <code>tvCL &lt;- fixed(1)</code>, <code>tvCL &lt;-
fixed(0, 1)</code>, <code>tvCL &lt;- fixed(0, 1, 2)</code>, <code>tvCL &lt;- c(0, fixed(1),
2)</code>, or <code>tvCL &lt;- c(0, 1, fixed)</code>.  For 'omega' assignment, the full
block or none of the block must be set as <code>fixed</code>.  Examples of setting
an 'omega' value as fixed are: <code>iivKa~fixed(1)</code>, <code>iivKa +
iivCL~fixed(1, 2, 3)</code>, or <code>iivKa + iivCL~c(1, 2, 3, fixed)</code>.  Anywhere
that <code>fixed</code> is used, <code>FIX</code>, <code>FIXED</code>, or <code>fix</code> may be
used equivalently.
</p>
<p>For any value, standard mathematical operators or functions may be used to
define the value.  For example, <code>log(2)</code> and <code>24*30</code> may be used to
define a value anywhere that a number can be used (e.g. lower bound,
estimate, upper bound, variance, etc.).
</p>
<p>Values may be labeled using the <code>label()</code> function after the assignment.
Labels are are used to make reporting easier by giving a human-readable
description of the parameter, but the labels do not have any effect on
estimation.  The typical way to set a label so that the parameter <code>tvCL</code>
has a label of &quot;Typical Value of Clearance (L/hr)&quot; is <code>tvCL &lt;- 1;
label("Typical Value of Clearance (L/hr)")</code>.
</p>
<p><code>rxode2</code>/<code>nlmixr2</code> will attempt to determine some
back-transformations for the user.  For example, <code>CL &lt;- exp(tvCL)</code> will
detect that <code>tvCL</code> must be back-transformed by <code>exp()</code> for easier
interpretation.  When you want to control the back-transformation, you can
specify the back-transformation using <code>backTransform()</code> after the
assignment.  For example, to set the
back-transformation to <code>exp()</code>, you can use <code>tvCL &lt;- 1;
backTransform(exp())</code>.
</p>


<h3>Value</h3>

<p>ini block
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>


<h3>See Also</h3>

<p>Other Initial conditions: 
<code><a href="#topic+zeroRe">zeroRe</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set the ini() block in a model
one.compartment &lt;- function() {
  ini({
    tka &lt;- log(1.57); label("Ka")
    tcl &lt;- log(2.72); label("Cl")
    tv &lt;- log(31.5); label("V")
    eta.ka ~ 0.6
    eta.cl ~ 0.3
    eta.v ~ 0.1
    add.sd &lt;- 0.7
  })
  model({
    ka &lt;- exp(tka + eta.ka)
    cl &lt;- exp(tcl + eta.cl)
    v &lt;- exp(tv + eta.v)
    d/dt(depot) = -ka * depot
    d/dt(center) = ka * depot - cl / v * center
    cp = center / v
    cp ~ add(add.sd)
  })
}

# Use piping to update initial conditions
one.compartment %&gt;% ini(tka &lt;- log(2))
one.compartment %&gt;% ini(tka &lt;- label("Absorption rate, Ka (1/hr)"))
# Move the tka parameter to be just below the tv parameter (affects parameter
# summary table, only)
one.compartment %&gt;% ini(tka &lt;- label("Absorption rate, Ka (1/hr)"), append = "tv")
# When programming with rxode2/nlmixr2, it may be easier to pass strings in
# to modify the ini
one.compartment %&gt;% ini("tka &lt;- log(2)")
</code></pre>

<hr>
<h2 id='ini+26lt+3B-'>Assign the ini block in the rxode2 related object</h2><span id='topic+ini+3C-'></span>

<h3>Description</h3>

<p>Assign the ini block in the rxode2 related object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ini(x, envir = environment(x)) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ini+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>rxode2 related object</p>
</td></tr>
<tr><td><code id="ini+2B26lt+2B3B-_+3A_envir">envir</code></td>
<td>
<p>Environment where assignment occurs</p>
</td></tr>
<tr><td><code id="ini+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>Value of the object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rxode2 related object
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='is.rxSolve'>Check to see if this is an rxSolve object.</h2><span id='topic+is.rxSolve'></span>

<h3>Description</h3>

<p>Check to see if this is an rxSolve object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.rxSolve(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.rxSolve_+3A_x">x</code></td>
<td>
<p>object to check to see if it is rxSolve
</p>
<p>If this is an rxSolve object that has expired strip all rxSolve
information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boolean indicating if this is a <code>rxSolve</code> object
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>

<hr>
<h2 id='llikBeta'>Calculate the log likelihood of the binomial function (and its derivatives)</h2><span id='topic+llikBeta'></span>

<h3>Description</h3>

<p>Calculate the log likelihood of the binomial function (and its derivatives)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llikBeta(x, shape1, shape2, full = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="llikBeta_+3A_x">x</code></td>
<td>
<p>Observation</p>
</td></tr>
<tr><td><code id="llikBeta_+3A_shape1">shape1</code>, <code id="llikBeta_+3A_shape2">shape2</code></td>
<td>
<p>non-negative parameters of the Beta distribution.</p>
</td></tr>
<tr><td><code id="llikBeta_+3A_full">full</code></td>
<td>
<p>Add the data frame showing x, mean, sd as well as the
fx and derivatives</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In an <code>rxode2()</code> model, you can use <code>llikBeta()</code> but you have to
use all arguments.  You can also get the derivative of <code>shape1</code> and <code>shape2</code> with
<code>llikBetaDshape1()</code> and <code>llikBetaDshape2()</code>.
</p>


<h3>Value</h3>

<p>data frame with <code>fx</code> for the log pdf value of with
<code>dShape1</code> and <code>dShape2</code> that has the derivatives with respect to the parameters at
the observation time-point
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


x &lt;- seq(1e-4, 1 - 1e-4, length.out = 21)

llikBeta(x, 0.5, 0.5)

llikBeta(x, 1, 3, TRUE)

et &lt;- et(seq(1e-4, 1-1e-4, length.out=21))
et$shape1 &lt;- 0.5
et$shape2 &lt;- 1.5

model &lt;- function() {
  model({
    fx &lt;- llikBeta(time, shape1, shape2)
    dShape1 &lt;- llikBetaDshape1(time, shape1, shape2)
    dShape2 &lt;- llikBetaDshape2(time, shape1, shape2)
  })
}

rxSolve(model, et)

</code></pre>

<hr>
<h2 id='llikBinom'>Calculate the log likelihood of the binomial function (and its derivatives)</h2><span id='topic+llikBinom'></span>

<h3>Description</h3>

<p>Calculate the log likelihood of the binomial function (and its derivatives)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llikBinom(x, size, prob, full = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="llikBinom_+3A_x">x</code></td>
<td>
<p>Number of successes</p>
</td></tr>
<tr><td><code id="llikBinom_+3A_size">size</code></td>
<td>
<p>Size of trial</p>
</td></tr>
<tr><td><code id="llikBinom_+3A_prob">prob</code></td>
<td>
<p>probability of success</p>
</td></tr>
<tr><td><code id="llikBinom_+3A_full">full</code></td>
<td>
<p>Add the data frame showing x, mean, sd as well as the
fx and derivatives</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In an <code>rxode2()</code> model, you can use <code>llikBinom()</code> but you have to
use all arguments.  You can also get the derivative of <code>prob</code> with
<code>llikBinomDprob()</code>
</p>


<h3>Value</h3>

<p>data frame with <code>fx</code> for the pdf value of with
<code>dProb</code> that has the derivatives with respect to the parameters at
the observation time-point
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
llikBinom(46:54, 100, 0.5)

llikBinom(46:54, 100, 0.5, TRUE)

# In rxode2 you can use:

et &lt;- et(46:54)
et$size &lt;- 100
et$prob &lt;-0.5

model &lt;- function() {
  model({
    fx &lt;- llikBinom(time, size, prob)
    dProb &lt;- llikBinomDprob(time, size, prob)
  })
}

rxSolve(model, et)

</code></pre>

<hr>
<h2 id='llikCauchy'>log likelihood of Cauchy distribution and it's derivatives (from stan)</h2><span id='topic+llikCauchy'></span>

<h3>Description</h3>

<p>log likelihood of Cauchy distribution and it's derivatives (from stan)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llikCauchy(x, location = 0, scale = 1, full = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="llikCauchy_+3A_x">x</code></td>
<td>
<p>Observation</p>
</td></tr>
<tr><td><code id="llikCauchy_+3A_location">location</code>, <code id="llikCauchy_+3A_scale">scale</code></td>
<td>
<p>location and scale parameters.</p>
</td></tr>
<tr><td><code id="llikCauchy_+3A_full">full</code></td>
<td>
<p>Add the data frame showing x, mean, sd as well as the
fx and derivatives</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In an <code>rxode2()</code> model, you can use <code>llikCauchy()</code> but you have to
use all arguments.  You can also get the derivative of <code>location</code> and <code>scale</code> with
<code>llikCauchyDlocation()</code> and <code>llikCauchyDscale()</code>.
</p>


<h3>Value</h3>

<p>data frame with <code>fx</code> for the log pdf value of with
<code>dLocation</code> and <code>dScale</code> that has the derivatives with respect to the parameters at
the observation time-point
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- seq(-3, 3, length.out = 21)

llikCauchy(x, 0, 1)

llikCauchy(x, 3, 1, full=TRUE)

et &lt;- et(-3, 3, length.out=10)
et$location &lt;- 0
et$scale &lt;- 1

model &lt;- function() {
  model({
    fx &lt;- llikCauchy(time, location, scale)
    dLocation &lt;- llikCauchyDlocation(time, location, scale)
    dScale &lt;- llikCauchyDscale(time, location, scale)
  })
}

rxSolve(model, et)

</code></pre>

<hr>
<h2 id='llikChisq'>log likelihood and derivatives for chi-squared distribution</h2><span id='topic+llikChisq'></span>

<h3>Description</h3>

<p>log likelihood and derivatives for chi-squared distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llikChisq(x, df, full = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="llikChisq_+3A_x">x</code></td>
<td>
<p>variable that is distributed by chi-squared distribution</p>
</td></tr>
<tr><td><code id="llikChisq_+3A_df">df</code></td>
<td>
<p>degrees of freedom (non-negative, but can be non-integer).</p>
</td></tr>
<tr><td><code id="llikChisq_+3A_full">full</code></td>
<td>
<p>Add the data frame showing x, mean, sd as well as the
fx and derivatives</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In an <code>rxode2()</code> model, you can use <code>llikChisq()</code> but you have to
use the x and df arguments.  You can also get the derivative of <code>df</code> with
<code>llikChisqDdf()</code>.
</p>


<h3>Value</h3>

<p>data frame with <code>fx</code> for the log pdf value of with <code>dDf</code>
that has the derivatives with respect to the <code>df</code> parameter
the observation time-point
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

llikChisq(1, df = 1:3, full=TRUE)

llikChisq(1, df = 6:9)

et &lt;- et(1:3)
et$x &lt;- 1

model &lt;- function() {
  model({
   fx &lt;- llikChisq(x, time)
   dDf &lt;- llikChisqDdf(x, time)
  })
}

rxSolve(model, et)

</code></pre>

<hr>
<h2 id='llikExp'>log likelihood and derivatives for exponential distribution</h2><span id='topic+llikExp'></span>

<h3>Description</h3>

<p>log likelihood and derivatives for exponential distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llikExp(x, rate, full = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="llikExp_+3A_x">x</code></td>
<td>
<p>variable that is distributed by exponential distribution</p>
</td></tr>
<tr><td><code id="llikExp_+3A_rate">rate</code></td>
<td>
<p>vector of rates.</p>
</td></tr>
<tr><td><code id="llikExp_+3A_full">full</code></td>
<td>
<p>Add the data frame showing x, mean, sd as well as the
fx and derivatives</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In an <code>rxode2()</code> model, you can use <code>llikExp()</code> but you have to
use the x and rate arguments.  You can also get the derivative of <code>rate</code> with
<code>llikExpDrate()</code>.
</p>


<h3>Value</h3>

<p>data frame with <code>fx</code> for the log pdf value of with <code>dRate</code>
that has the derivatives with respect to the <code>rate</code> parameter
the observation time-point
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
llikExp(1, 1:3)

llikExp(1, 1:3, full=TRUE)

# You can use rxode2 for these too:

et &lt;- et(1:3)
et$x &lt;- 1

model &lt;- function() {
  model({
    fx &lt;- llikExp(x, time)
    dRate &lt;- llikExpDrate(x, time)
  })
}

rxSolve(model, et)

</code></pre>

<hr>
<h2 id='llikF'>log likelihood and derivatives for F distribution</h2><span id='topic+llikF'></span>

<h3>Description</h3>

<p>log likelihood and derivatives for F distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llikF(x, df1, df2, full = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="llikF_+3A_x">x</code></td>
<td>
<p>variable that is distributed by f distribution</p>
</td></tr>
<tr><td><code id="llikF_+3A_df1">df1</code>, <code id="llikF_+3A_df2">df2</code></td>
<td>
<p>degrees of freedom.  <code>Inf</code> is allowed.</p>
</td></tr>
<tr><td><code id="llikF_+3A_full">full</code></td>
<td>
<p>Add the data frame showing x, mean, sd as well as the
fx and derivatives</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In an <code>rxode2()</code> model, you can use <code>llikF()</code> but you have to
use the x and rate arguments.  You can also get the derivative of <code>df1</code> and <code>df2</code> with
<code>llikFDdf1()</code> and <code>llikFDdf2()</code>.
</p>


<h3>Value</h3>

<p>data frame with <code>fx</code> for the log pdf value of with <code>dDf1</code> and <code>dDf2</code>
that has the derivatives with respect to the <code>df1</code>/<code>df2</code> parameters at
the observation time-point
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

x &lt;- seq(0.001, 5, length.out = 100)

llikF(x^2, 1, 5)

model &lt;- function(){
  model({
    fx &lt;- llikF(time, df1, df2)
    dMean &lt;- llikFDdf1(time, df1, df2)
    dSd &lt;- llikFDdf2(time, df1, df2)
  })
}

et &lt;- et(x)
et$df1 &lt;- 1
et$df2 &lt;- 5

rxSolve(model, et)

</code></pre>

<hr>
<h2 id='llikGamma'>log likelihood and derivatives for Gamma distribution</h2><span id='topic+llikGamma'></span>

<h3>Description</h3>

<p>log likelihood and derivatives for Gamma distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llikGamma(x, shape, rate, full = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="llikGamma_+3A_x">x</code></td>
<td>
<p>variable that is distributed by gamma distribution</p>
</td></tr>
<tr><td><code id="llikGamma_+3A_shape">shape</code></td>
<td>
<p>this is the distribution's shape parameter. Must be positive.</p>
</td></tr>
<tr><td><code id="llikGamma_+3A_rate">rate</code></td>
<td>
<p>this is the distribution's rate parameters.  Must be positive.</p>
</td></tr>
<tr><td><code id="llikGamma_+3A_full">full</code></td>
<td>
<p>Add the data frame showing x, mean, sd as well as the
fx and derivatives</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In an <code>rxode2()</code> model, you can use <code>llikGamma()</code> but you have to
use the x and rate arguments.  You can also get the derivative of <code>shape</code> or <code>rate</code> with
<code>llikGammaDshape()</code> and <code>llikGammaDrate()</code>.
</p>


<h3>Value</h3>

<p>data frame with <code>fx</code> for the log pdf value of with <code>dProb</code>
that has the derivatives with respect to the <code>prob</code> parameters at
the observation time-point
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

llikGamma(1, 1, 10)

# You can use this in `rxode2` too:

et  &lt;- et(seq(0.001, 1, length.out=10))
et$shape &lt;- 1
et$rate &lt;- 10
 
model &lt;- function() {
  model({
    fx &lt;- llikGamma(time, shape, rate)
    dShape&lt;- llikGammaDshape(time, shape, rate)
    dRate &lt;- llikGammaDrate(time, shape, rate)
  })
}

rxSolve(model, et)

</code></pre>

<hr>
<h2 id='llikGeom'>log likelihood and derivatives for Geom distribution</h2><span id='topic+llikGeom'></span>

<h3>Description</h3>

<p>log likelihood and derivatives for Geom distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llikGeom(x, prob, full = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="llikGeom_+3A_x">x</code></td>
<td>
<p>variable distributed by a geom distribution</p>
</td></tr>
<tr><td><code id="llikGeom_+3A_prob">prob</code></td>
<td>
<p>probability of success in each trial. <code>0 &lt; prob &lt;= 1</code>.</p>
</td></tr>
<tr><td><code id="llikGeom_+3A_full">full</code></td>
<td>
<p>Add the data frame showing x, mean, sd as well as the
fx and derivatives</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In an <code>rxode2()</code> model, you can use <code>llikGeom()</code> but you have to
use the x and rate arguments.  You can also get the derivative of <code>prob</code> with
<code>llikGeomDprob()</code>.
</p>


<h3>Value</h3>

<p>data frame with <code>fx</code> for the log pdf value of with <code>dProb</code>
that has the derivatives with respect to the <code>prob</code> parameters at
the observation time-point
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


llikGeom(1:10, 0.2)

et  &lt;- et(1:10)
et$prob &lt;- 0.2
 
model &lt;- function() {
  model({
    fx &lt;- llikGeom(time, prob)
    dProb &lt;- llikGeomDprob(time, prob)
  })
}

rxSolve(model, et)

</code></pre>

<hr>
<h2 id='llikNbinom'>Calculate the log likelihood of the negative binomial function (and its derivatives)</h2><span id='topic+llikNbinom'></span>

<h3>Description</h3>

<p>Calculate the log likelihood of the negative binomial function (and its derivatives)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llikNbinom(x, size, prob, full = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="llikNbinom_+3A_x">x</code></td>
<td>
<p>Number of successes</p>
</td></tr>
<tr><td><code id="llikNbinom_+3A_size">size</code></td>
<td>
<p>Size of trial</p>
</td></tr>
<tr><td><code id="llikNbinom_+3A_prob">prob</code></td>
<td>
<p>probability of success</p>
</td></tr>
<tr><td><code id="llikNbinom_+3A_full">full</code></td>
<td>
<p>Add the data frame showing x, mean, sd as well as the
fx and derivatives</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In an <code>rxode2()</code> model, you can use <code>llikNbinom()</code> but you have to
use all arguments.  You can also get the derivative of <code>prob</code> with
<code>llikNbinomDprob()</code>
</p>


<h3>Value</h3>

<p>data frame with <code>fx</code> for the pdf value of with
<code>dProb</code> that has the derivatives with respect to the parameters at
the observation time-point
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
llikNbinom(46:54, 100, 0.5)

llikNbinom(46:54, 100, 0.5, TRUE)

# In rxode2 you can use:

et &lt;- et(46:54)
et$size &lt;- 100
et$prob &lt;-0.5

model &lt;- function() {
  model({
    fx &lt;- llikNbinom(time, size, prob)
    dProb &lt;- llikNbinomDprob(time, size, prob)
  })
}

rxSolve(model, et)

</code></pre>

<hr>
<h2 id='llikNbinomMu'>Calculate the log likelihood of the negative binomial function (and its derivatives)</h2><span id='topic+llikNbinomMu'></span>

<h3>Description</h3>

<p>Calculate the log likelihood of the negative binomial function (and its derivatives)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llikNbinomMu(x, size, mu, full = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="llikNbinomMu_+3A_x">x</code></td>
<td>
<p>Number of successes</p>
</td></tr>
<tr><td><code id="llikNbinomMu_+3A_size">size</code></td>
<td>
<p>Size of trial</p>
</td></tr>
<tr><td><code id="llikNbinomMu_+3A_mu">mu</code></td>
<td>
<p>mu parameter for negative binomial</p>
</td></tr>
<tr><td><code id="llikNbinomMu_+3A_full">full</code></td>
<td>
<p>Add the data frame showing x, mean, sd as well as the
fx and derivatives</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In an <code>rxode2()</code> model, you can use <code>llikNbinomMu()</code> but you have to
use all arguments.  You can also get the derivative of <code>mu</code> with
<code>llikNbinomMuDmu()</code>
</p>


<h3>Value</h3>

<p>data frame with <code>fx</code> for the pdf value of with
<code>dProb</code> that has the derivatives with respect to the parameters at
the observation time-point
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
llikNbinomMu(46:54, 100, 40)

llikNbinomMu(46:54, 100, 40, TRUE)

et &lt;- et(46:54)
et$size &lt;- 100
et$mu &lt;- 40

model &lt;- function() {
  model({
    fx &lt;- llikNbinomMu(time, size, mu)
    dProb &lt;- llikNbinomMuDmu(time, size, mu)
  })
}

rxSolve(model, et)

</code></pre>

<hr>
<h2 id='llikNorm'>Log likelihood for normal distribution</h2><span id='topic+llikNorm'></span>

<h3>Description</h3>

<p>Log likelihood for normal distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llikNorm(x, mean = 0, sd = 1, full = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="llikNorm_+3A_x">x</code></td>
<td>
<p>Observation</p>
</td></tr>
<tr><td><code id="llikNorm_+3A_mean">mean</code></td>
<td>
<p>Mean for the likelihood</p>
</td></tr>
<tr><td><code id="llikNorm_+3A_sd">sd</code></td>
<td>
<p>Standard deviation for the likelihood</p>
</td></tr>
<tr><td><code id="llikNorm_+3A_full">full</code></td>
<td>
<p>Add the data frame showing x, mean, sd as well as the
fx and derivatives</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In an <code>rxode2()</code> model, you can use <code>llikNorm()</code> but you have to
use all arguments.  You can also get the derivatives with
<code>llikNormDmean()</code> and <code>llikNormDsd()</code>
</p>


<h3>Value</h3>

<p>data frame with <code>fx</code> for the pdf value of with <code>dMean</code> and
<code>dSd</code> that has the derivatives with respect to the parameters at
the observation time-point
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


llikNorm(0)

llikNorm(seq(-2,2,length.out=10), full=TRUE)

# With rxode2 you can use:
 
et &lt;- et(-3, 3, length.out=10)
et$mu &lt;- 0
et$sigma &lt;- 1

model &lt;- function(){
  model({
    fx &lt;- llikNorm(time, mu, sigma)
    dMean &lt;- llikNormDmean(time, mu, sigma)
    dSd &lt;- llikNormDsd(time, mu, sigma)
  })
 }

ret &lt;- rxSolve(model, et)
ret

</code></pre>

<hr>
<h2 id='llikPois'>log-likelihood for the Poisson distribution</h2><span id='topic+llikPois'></span>

<h3>Description</h3>

<p>log-likelihood for the Poisson distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llikPois(x, lambda, full = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="llikPois_+3A_x">x</code></td>
<td>
<p>non negative integers</p>
</td></tr>
<tr><td><code id="llikPois_+3A_lambda">lambda</code></td>
<td>
<p>non-negative means</p>
</td></tr>
<tr><td><code id="llikPois_+3A_full">full</code></td>
<td>
<p>Add the data frame showing x, mean, sd as well as the
fx and derivatives</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In an <code>rxode2()</code> model, you can use <code>llikPois()</code> but you have to
use all arguments.  You can also get the derivatives with
<code>llikPoisDlambda()</code>
</p>


<h3>Value</h3>

<p>data frame with <code>fx</code> for the pdf value of with
<code>dLambda</code> that has the derivatives with respect to the parameters at
the observation time-point
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
llikPois(0:7, lambda = 1)

llikPois(0:7, lambda = 4, full=TRUE)

# In rxode2 you can use:

et &lt;- et(0:10)
et$lambda &lt;- 0.5

model &lt;- function() {
  model({
    fx &lt;- llikPois(time, lambda)
    dLambda &lt;- llikPoisDlambda(time, lambda)
  })
}

rxSolve(model, et)

</code></pre>

<hr>
<h2 id='llikT'>Log likelihood of T and it's derivatives (from stan)</h2><span id='topic+llikT'></span>

<h3>Description</h3>

<p>Log likelihood of T and it's derivatives (from stan)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llikT(x, df, mean = 0, sd = 1, full = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="llikT_+3A_x">x</code></td>
<td>
<p>Observation</p>
</td></tr>
<tr><td><code id="llikT_+3A_df">df</code></td>
<td>
<p>degrees of freedom (<code class="reqn">&gt; 0</code>, maybe non-integer).  <code>df
      = Inf</code> is allowed.</p>
</td></tr>
<tr><td><code id="llikT_+3A_mean">mean</code></td>
<td>
<p>Mean for the likelihood</p>
</td></tr>
<tr><td><code id="llikT_+3A_sd">sd</code></td>
<td>
<p>Standard deviation for the likelihood</p>
</td></tr>
<tr><td><code id="llikT_+3A_full">full</code></td>
<td>
<p>Add the data frame showing x, mean, sd as well as the
fx and derivatives</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In an <code>rxode2()</code> model, you can use <code>llikT()</code> but you have to
use all arguments.  You can also get the derivative of <code>df</code>, <code>mean</code> and <code>sd</code> with
<code>llikTDdf()</code>, <code>llikTDmean()</code> and <code>llikTDsd()</code>.
</p>


<h3>Value</h3>

<p>data frame with <code>fx</code> for the log pdf value of with <code>dDf</code>
<code>dMean</code> and <code>dSd</code> that has the derivatives with respect to the parameters at
the observation time-point
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

x &lt;- seq(-3, 3, length.out = 21)

llikT(x, 7, 0, 1)

llikT(x, 15, 0, 1, full=TRUE)

et &lt;- et(-3, 3, length.out=10)
et$nu &lt;- 7
et$mean &lt;- 0
et$sd &lt;- 1

model &lt;- function() {
  model({
    fx &lt;- llikT(time, nu, mean, sd)
    dDf &lt;- llikTDdf(time, nu, mean, sd)
    dMean &lt;- llikTDmean(time, nu, mean, sd)
    dSd   &lt;- llikTDsd(time, nu, mean, sd)
  })
}

rxSolve(model, et)


</code></pre>

<hr>
<h2 id='llikUnif'>log likelihood and derivatives for Unif distribution</h2><span id='topic+llikUnif'></span>

<h3>Description</h3>

<p>log likelihood and derivatives for Unif distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llikUnif(x, alpha, beta, full = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="llikUnif_+3A_x">x</code></td>
<td>
<p>variable distributed by a uniform distribution</p>
</td></tr>
<tr><td><code id="llikUnif_+3A_alpha">alpha</code></td>
<td>
<p>is the lower limit of the uniform distribution</p>
</td></tr>
<tr><td><code id="llikUnif_+3A_beta">beta</code></td>
<td>
<p>is the upper limit of the distribution</p>
</td></tr>
<tr><td><code id="llikUnif_+3A_full">full</code></td>
<td>
<p>Add the data frame showing x, mean, sd as well as the
fx and derivatives</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In an <code>rxode2()</code> model, you can use <code>llikUnif()</code> but you have to
use the x and rate arguments.  You can also get the derivative of <code>alpha</code> or <code>beta</code> with
<code>llikUnifDalpha()</code> and <code>llikUnifDbeta()</code>.
</p>


<h3>Value</h3>

<p>data frame with <code>fx</code> for the log pdf value of with <code>dProb</code>
that has the derivatives with respect to the <code>prob</code> parameters at
the observation time-point
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


llikUnif(1, -2, 2)

et  &lt;- et(seq(1,1, length.out=4))
et$alpha &lt;- -2
et$beta &lt;- 2
 
model &lt;- function() {
  model({
    fx &lt;- llikUnif(time, alpha, beta)
    dAlpha&lt;- llikUnifDalpha(time, alpha, beta)
    dBeta &lt;- llikUnifDbeta(time, alpha, beta)
  })
}

rxSolve(model, et)

</code></pre>

<hr>
<h2 id='llikWeibull'>log likelihood and derivatives for Weibull distribution</h2><span id='topic+llikWeibull'></span>

<h3>Description</h3>

<p>log likelihood and derivatives for Weibull distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llikWeibull(x, shape, scale, full = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="llikWeibull_+3A_x">x</code></td>
<td>
<p>variable distributed by a Weibull distribution</p>
</td></tr>
<tr><td><code id="llikWeibull_+3A_shape">shape</code>, <code id="llikWeibull_+3A_scale">scale</code></td>
<td>
<p>shape and scale parameters, the latter defaulting to 1.</p>
</td></tr>
<tr><td><code id="llikWeibull_+3A_full">full</code></td>
<td>
<p>Add the data frame showing x, mean, sd as well as the
fx and derivatives</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In an <code>rxode2()</code> model, you can use <code>llikWeibull()</code> but you have to
use the x and rate arguments.  You can also get the derivative of <code>shape</code> or <code>scale</code> with
<code>llikWeibullDshape()</code> and <code>llikWeibullDscale()</code>.
</p>


<h3>Value</h3>

<p>data frame with <code>fx</code> for the log pdf value of with <code>dProb</code>
that has the derivatives with respect to the <code>prob</code> parameters at
the observation time-point
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
llikWeibull(1, 1, 10)

# rxode2 can use this too:

et  &lt;- et(seq(0.001, 1, length.out=10))
et$shape &lt;- 1
et$scale &lt;- 10
 
model &lt;- function() {
  model({
    fx &lt;- llikWeibull(time, shape, scale)
    dShape&lt;- llikWeibullDshape(time, shape, scale)
    dScale &lt;- llikWeibullDscale(time, shape, scale)
  })
}

rxSolve(model, et)

</code></pre>

<hr>
<h2 id='logit'>logit and inverse logit (expit) functions</h2><span id='topic+logit'></span><span id='topic+expit'></span><span id='topic+logitNormInfo'></span><span id='topic+probitNormInfo'></span>

<h3>Description</h3>

<p>logit and inverse logit (expit) functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit(x, low = 0, high = 1)

expit(alpha, low = 0, high = 1)

logitNormInfo(mean = 0, sd = 1, low = 0, high = 1, abs.tol = 1e-06, ...)

probitNormInfo(mean = 0, sd = 1, low = 0, high = 1, abs.tol = 1e-06, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="logit_+3A_x">x</code></td>
<td>
<p>Input value(s) in range [low,high] to translate -Inf to
Inf</p>
</td></tr>
<tr><td><code id="logit_+3A_low">low</code></td>
<td>
<p>Lowest value in the range</p>
</td></tr>
<tr><td><code id="logit_+3A_high">high</code></td>
<td>
<p>Highest value in the range</p>
</td></tr>
<tr><td><code id="logit_+3A_alpha">alpha</code></td>
<td>
<p>Infinite value(s) to translate to range of [low,
high]</p>
</td></tr>
<tr><td><code id="logit_+3A_mean">mean</code></td>
<td>
<p>logit-scale mean</p>
</td></tr>
<tr><td><code id="logit_+3A_sd">sd</code></td>
<td>
<p>logit-scale standard deviation</p>
</td></tr>
<tr><td><code id="logit_+3A_abs.tol">abs.tol</code></td>
<td>
<p>absolute accuracy requested.</p>
</td></tr>
<tr><td><code id="logit_+3A_...">...</code></td>
<td>
<p>other parameters passed to <code>integrate()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>logit is given by:
</p>
<p>logit(p) = -log(1/p-1)
</p>
<p>where:
</p>
<p>p = x-low/high-low
</p>
<p>expit is given by:
</p>
<p>expit(p, low, high) = (high-low)/(1+exp(-alpha)) + low
</p>
<p>The <code>logitNormInfo()</code> gives the mean, variance and coefficient of
variability on the untransformed scale.
</p>


<h3>Value</h3>

<p>values from logit and expit
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
logit(0.25)

expit(-1.09)

logitNormInfo(logit(0.25), sd = 0.1)

logitNormInfo(logit(1, 0, 10), sd = 1, low = 0, high = 10)
</code></pre>

<hr>
<h2 id='lowergamma'>lowergamma:  upper incomplete gamma function</h2><span id='topic+lowergamma'></span>

<h3>Description</h3>

<p>This is the tgamma_lower from the boost library
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lowergamma(a, z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lowergamma_+3A_a">a</code></td>
<td>
<p>The numeric 'a' parameter in the upper
incomplete gamma</p>
</td></tr>
<tr><td><code id="lowergamma_+3A_z">z</code></td>
<td>
<p>The numeric 'z' parameter in the upper
incomplete gamma</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The lowergamma function is given by:
</p>
<p style="text-align: center;"><code class="reqn">lowergamma(a, z) = \int_{0}^{z}t^{a-1}\cdot e^{-t} dt</code>
</p>



<h3>Value</h3>

<p>lowergamma results
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
lowergamma(1, 3)

lowergamma(1:3, 3)

lowergamma(1, 1:3)
</code></pre>

<hr>
<h2 id='meanProbs'>Calculate expected confidence bands or prediction intreval with normal or t sampling distribution</h2><span id='topic+meanProbs'></span><span id='topic+meanProbs.default'></span>

<h3>Description</h3>

<p>The generic function <code>meanProbs</code> produces expected confidence bands
under either the t distribution or the normal sampling
distribution. This uses <code>qnorm()</code> or <code>qt()</code> with the mean and
standard deviation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanProbs(x, ...)

## Default S3 method:
meanProbs(
  x,
  probs = seq(0, 1, 0.25),
  na.rm = FALSE,
  names = TRUE,
  useT = TRUE,
  onlyProbs = TRUE,
  pred = FALSE,
  n = 0L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="meanProbs_+3A_x">x</code></td>
<td>
<p>numeric vector whose mean and probability based confidence
values are wanted, NA and NaN values are not allowed in numeric
vectors unless na.rm is TRUE.</p>
</td></tr>
<tr><td><code id="meanProbs_+3A_...">...</code></td>
<td>
<p>Arguments passed to default method, allows many
different methods to be applied.</p>
</td></tr>
<tr><td><code id="meanProbs_+3A_probs">probs</code></td>
<td>
<p>numeric vector of probabilities with values in the
interval from 0 to 1 .</p>
</td></tr>
<tr><td><code id="meanProbs_+3A_na.rm">na.rm</code></td>
<td>
<p>logical; if true, any NA and NaN's are removed from
<code>x</code> before the quantiles are computed.</p>
</td></tr>
<tr><td><code id="meanProbs_+3A_names">names</code></td>
<td>
<p>logical; if true, the result has a names attribute.</p>
</td></tr>
<tr><td><code id="meanProbs_+3A_uset">useT</code></td>
<td>
<p>logical; if true, use the t-distribution to calculate
the confidence-based estimates. If false use the normal
distribution to calculate the confidence based estimates.</p>
</td></tr>
<tr><td><code id="meanProbs_+3A_onlyprobs">onlyProbs</code></td>
<td>
<p>logical; if true, only return the probability
based confidence interval estimates, otherwise return</p>
</td></tr>
<tr><td><code id="meanProbs_+3A_pred">pred</code></td>
<td>
<p>logical; if true use the prediction interval instead of
the confidence interval</p>
</td></tr>
<tr><td><code id="meanProbs_+3A_n">n</code></td>
<td>
<p>integer/integerish; this is the n used to calculate the
prediction or confidence interval.  When <code>n=0</code> (default) use the
number of non-<code>NA</code> observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a single probability, p, it uses either:
</p>
<p>mean + qt(p, df=n)*sd/sqrt(n)
</p>
<p>or
</p>
<p>mean + qnorm(p)*sd/sqrt(n)
</p>
<p>The smallest observation corresponds to a probability of 0 and the
largest to a probability of 1 and the mean corresponds to 0.5.
</p>
<p>The mean and standard deviation of the sample is calculated based
on Welford's method for a single pass.
</p>
<p>This is meant to perform in the same way as <code>quantile()</code> so it can
be a drop in replacement for code using <code>quantile()</code> but using
distributional assumptions.
</p>


<h3>Value</h3>

<p>By default the return has the probabilities as names (if
named) with the points where the expected distribution are
located given the sampling mean and standard deviation. If
<code>onlyProbs=FALSE</code> then it would prepend mean, variance, standard
deviation, minimum, maximum and number of non-NA observations.
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
quantile(x&lt;- rnorm(1001))
meanProbs(x)

# Can get some extra statistics if you request onlyProbs=FALSE
meanProbs(x, onlyProbs=FALSE)

x[2] &lt;- NA_real_

meanProbs(x, onlyProbs=FALSE)

quantile(x&lt;- rnorm(42))

meanProbs(x)

meanProbs(x, useT=FALSE)

</code></pre>

<hr>
<h2 id='model.function'>Model block for rxode2/nlmixr models</h2><span id='topic+model.function'></span><span id='topic+model.rxUi'></span><span id='topic+model.rxode2'></span><span id='topic+model.rxModelVars'></span><span id='topic+model'></span><span id='topic+model.default'></span>

<h3>Description</h3>

<p>Model block for rxode2/nlmixr models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class ''function''
model(
  x,
  ...,
  append = NULL,
  auto = getOption("rxode2.autoVarPiping", TRUE),
  cov = NULL,
  envir = parent.frame()
)

## S3 method for class 'rxUi'
model(
  x,
  ...,
  append = NULL,
  auto = getOption("rxode2.autoVarPiping", TRUE),
  cov = NULL,
  envir = parent.frame()
)

## S3 method for class 'rxode2'
model(
  x,
  ...,
  append = NULL,
  auto = getOption("rxode2.autoVarPiping", TRUE),
  cov = NULL,
  envir = parent.frame()
)

## S3 method for class 'rxModelVars'
model(
  x,
  ...,
  append = NULL,
  auto = getOption("rxode2.autoVarPiping", TRUE),
  cov = NULL,
  envir = parent.frame()
)

model(
  x,
  ...,
  append = FALSE,
  auto = getOption("rxode2.autoVarPiping", TRUE),
  cov = NULL,
  envir = parent.frame()
)

## Default S3 method:
model(x, ..., append = FALSE, cov = NULL, envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.function_+3A_x">x</code></td>
<td>
<p>model expression</p>
</td></tr>
<tr><td><code id="model.function_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
<tr><td><code id="model.function_+3A_append">append</code></td>
<td>
<p>This is a boolean to determine if the lines are
appended in piping.  The possible values for this is:
</p>

<ul>
<li> <p><code>TRUE</code> which is when the lines are appended to the model instead of replaced
</p>
</li>
<li> <p><code>FALSE</code> when the lines are replaced in the model (default)
</p>
</li>
<li> <p><code>NA</code> is when the lines are pre-pended to the model instead of replaced
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;lhs expression&#8288;</code>, which will append the lines after the last observed line of the expression <code>lhs</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="model.function_+3A_auto">auto</code></td>
<td>
<p>This boolean tells if piping automatically selects the
parameters should be characterized as a population parameter,
between subject variability, or a covariate.  When <code>TRUE</code> this
automatic selection occurs.  When <code>FALSE</code> this automatic
selection is turned off and everything is added as a covariate
(which can be promoted to a parameter with the <code>ini</code> statement).
By default this is <code>TRUE</code>, but it can be changed by
<code>options(rxode2.autoVarPiping=FALSE)</code>.</p>
</td></tr>
<tr><td><code id="model.function_+3A_cov">cov</code></td>
<td>
<p>is a character vector of variables that should be
assumed to be covariates.  This will override automatic promotion
to a population parameter estimate (or an eta)</p>
</td></tr>
<tr><td><code id="model.function_+3A_envir">envir</code></td>
<td>
<p>the <code>environment</code> in which unevaluated model
expressions is to be evaluated.  May also be <code>NULL</code>, a list, a
data frame, a pairlist or an integer as specified to <code>sys.call</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Model block with ini information included.  <code>ini</code> must be
called before <code>model</code> block
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='model+26lt+3B-'>Assign the model block in the rxode2 related object</h2><span id='topic+model+3C-'></span>

<h3>Description</h3>

<p>Assign the model block in the rxode2 related object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model(x, envir = environment(x)) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>rxode2 related object</p>
</td></tr>
<tr><td><code id="model+2B26lt+2B3B-_+3A_envir">envir</code></td>
<td>
<p>Environment where assignment occurs</p>
</td></tr>
<tr><td><code id="model+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>Value of the object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rxode2 related object
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='modelExtract'>Extract model lines from a rxui model</h2><span id='topic+modelExtract'></span><span id='topic+modelExtract.function'></span><span id='topic+modelExtract.rxUi'></span><span id='topic+modelExtract.rxode2'></span><span id='topic+modelExtract.rxModelVars'></span><span id='topic+modelExtract.default'></span>

<h3>Description</h3>

<p>Extract model lines from a rxui model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelExtract(
  x,
  ...,
  expression = FALSE,
  endpoint = FALSE,
  lines = FALSE,
  envir = parent.frame()
)

## S3 method for class ''function''
modelExtract(
  x,
  ...,
  expression = FALSE,
  endpoint = FALSE,
  lines = FALSE,
  envir = parent.frame()
)

## S3 method for class 'rxUi'
modelExtract(
  x,
  ...,
  expression = FALSE,
  endpoint = FALSE,
  lines = FALSE,
  envir = parent.frame()
)

## S3 method for class 'rxode2'
modelExtract(
  x,
  ...,
  expression = FALSE,
  endpoint = FALSE,
  lines = FALSE,
  envir = parent.frame()
)

## S3 method for class 'rxModelVars'
modelExtract(
  x,
  ...,
  expression = FALSE,
  endpoint = FALSE,
  lines = FALSE,
  envir = parent.frame()
)

## Default S3 method:
modelExtract(
  x,
  ...,
  expression = FALSE,
  endpoint = FALSE,
  lines = FALSE,
  envir = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modelExtract_+3A_x">x</code></td>
<td>
<p>model to extract lines from</p>
</td></tr>
<tr><td><code id="modelExtract_+3A_...">...</code></td>
<td>
<p>variables to extract. When it is missing, it will
extract the entire model (conditioned on the endpoint option
below)</p>
</td></tr>
<tr><td><code id="modelExtract_+3A_expression">expression</code></td>
<td>
<p>return expressions (if <code>TRUE</code>) or strings (if
<code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="modelExtract_+3A_endpoint">endpoint</code></td>
<td>
<p>include endpoint.  This can be:
</p>

<ul>
<li> <p><code>NA</code>    &ndash; Missing means include both the endpoint and non-endpoint lines
</p>
</li>
<li> <p><code>TRUE</code>  &ndash; Only include endpoint lines
</p>
</li>
<li> <p><code>FALSE</code> &ndash; Only include non-endpoint lines
</p>
</li></ul>
</td></tr>
<tr><td><code id="modelExtract_+3A_lines">lines</code></td>
<td>
<p>is a boolean.  When <code>TRUE</code> this will add the lines as
an attribute to the output value ie <code>attr(, "lines")</code></p>
</td></tr>
<tr><td><code id="modelExtract_+3A_envir">envir</code></td>
<td>
<p>Environment for evaluating variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>expressions or strings of extracted lines. Note if there is
a duplicated lhs expression in the line, it will return both
lines
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
one.compartment &lt;- function() {
  ini({
    tka &lt;- 0.45 # Log Ka
    tcl &lt;- 1 # Log Cl
    tv &lt;- 3.45    # Log V
    eta.ka ~ 0.6
    eta.cl ~ 0.3
    eta.v ~ 0.1
    add.sd &lt;- 0.7
  })
  model({
    ka &lt;- exp(tka + eta.ka)
    cl &lt;- exp(tcl + eta.cl)
    v  &lt;- exp(tv + eta.v)
    d/dt(depot)  &lt;- -ka * depot
    d/dt(center) &lt;-  ka * depot - cl / v * center
    cp &lt;- center / v
    cp ~ add(add.sd)
  })
 }

 f &lt;- one.compartment()

 modelExtract(f, cp)

 modelExtract(one.compartment, d/dt(depot))

 # from variable
 var &lt;- "d/dt(depot)"

 modelExtract(one.compartment, var)

 modelExtract(f, endpoint=NA, lines=TRUE, expression=TRUE)

</code></pre>

<hr>
<h2 id='odeMethodToInt'>Conversion between character and integer ODE integration methods for rxode2</h2><span id='topic+odeMethodToInt'></span>

<h3>Description</h3>

<p>If <code>NULL</code> is given as the method, all choices are returned as a named
vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>odeMethodToInt(method = c("liblsoda", "lsoda", "dop853", "indLin"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="odeMethodToInt_+3A_method">method</code></td>
<td>
<p>The method for solving ODEs.  Currently this supports:
</p>

<ul>
<li> <p><code>"liblsoda"</code> thread safe lsoda.  This supports parallel
thread-based solving, and ignores user Jacobian specification.
</p>
</li>
<li> <p><code>"lsoda"</code> &ndash; LSODA solver.  Does not support parallel thread-based
solving, but allows user Jacobian specification.
</p>
</li>
<li> <p><code>"dop853"</code> &ndash; DOP853 solver.  Does not support parallel thread-based
solving nor user Jacobian specification
</p>
</li>
<li> <p><code>"indLin"</code> &ndash; Solving through inductive linearization.  The rxode2 dll
must be setup specially to use this solving routine.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer for the method (unless the input is NULL, in which case,
see the details)
</p>

<hr>
<h2 id='plot.rxSolve'>Plot rxode2 objects</h2><span id='topic+plot.rxSolve'></span><span id='topic+plot.rxSolveConfint1'></span><span id='topic+plot.rxSolveConfint2'></span>

<h3>Description</h3>

<p>Plot rxode2 objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rxSolve'
plot(x, y, ..., log = "", xlab = "Time", ylab = "")

## S3 method for class 'rxSolveConfint1'
plot(x, y, ..., xlab = "Time", ylab = "", log = "")

## S3 method for class 'rxSolveConfint2'
plot(x, y, ..., xlab = "Time", ylab = "", log = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.rxSolve_+3A_x">x</code></td>
<td>
<p>rxode2 object to plot</p>
</td></tr>
<tr><td><code id="plot.rxSolve_+3A_y">y</code></td>
<td>
<p>Compartments or left-hand-side values to plot either as a bare name
or as a character vector</p>
</td></tr>
<tr><td><code id="plot.rxSolve_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="plot.rxSolve_+3A_log">log</code></td>
<td>
<p>Should &quot;&quot; (neither x nor y), &quot;x&quot;, &quot;y&quot;, or &quot;xy&quot; (or &quot;yx&quot;) be
log-scale?</p>
</td></tr>
<tr><td><code id="plot.rxSolve_+3A_xlab">xlab</code>, <code id="plot.rxSolve_+3A_ylab">ylab</code></td>
<td>
<p>The x and y axis labels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object
</p>


<h3>See Also</h3>

<p>Other rxode2 plotting: 
<code><a href="#topic+rxTheme">rxTheme</a>()</code>
</p>

<hr>
<h2 id='print.rxCoef'>Print the rxCoef object</h2><span id='topic+print.rxCoef'></span>

<h3>Description</h3>

<p>This prints out the user supplied arguments for rxCoef object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rxCoef'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.rxCoef_+3A_x">x</code></td>
<td>
<p>rxCoef object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>original object
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>

<hr>
<h2 id='print.rxDll'>Print rxDll object</h2><span id='topic+print.rxDll'></span>

<h3>Description</h3>

<p>This tells if the rxDll is loaded, ready and/or deleted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rxDll'
print(x, ...)
</code></pre>


<h3>Value</h3>

<p>original object
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>

<hr>
<h2 id='print.rxode2'>Print information about the rxode2 object.</h2><span id='topic+print.rxode2'></span>

<h3>Description</h3>

<p>This prints the model name and its status for being able to be solved
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rxode2'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.rxode2_+3A_x">x</code></td>
<td>
<p>An rxode2 object</p>
</td></tr>
<tr><td><code id="print.rxode2_+3A_...">...</code></td>
<td>
<p>Ignored parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>original object
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>

<hr>
<h2 id='probit'>probit and inverse probit functions</h2><span id='topic+probit'></span><span id='topic+probitInv'></span>

<h3>Description</h3>

<p>probit and inverse probit functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probit(x, low = 0, high = 1)

probitInv(x, low = 0, high = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="probit_+3A_x">x</code></td>
<td>
<p>Input value(s) in range [low,high] to translate -Inf to
Inf</p>
</td></tr>
<tr><td><code id="probit_+3A_low">low</code></td>
<td>
<p>Lowest value in the range</p>
</td></tr>
<tr><td><code id="probit_+3A_high">high</code></td>
<td>
<p>Highest value in the range</p>
</td></tr>
</table>


<h3>Value</h3>

<p>values from probit, probitInv and probitNormInfo
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
probit(0.25)

probitInv(-0.674)

probitNormInfo(probit(0.25), sd = 0.1)

probitNormInfo(probit(1, 0, 10), sd = 1, low = 0, high = 10)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+scale_type'></span><span id='topic+ggplot'></span><span id='topic+aes'></span><span id='topic+geom_line'></span><span id='topic+facet_wrap'></span><span id='topic+ylab'></span><span id='topic+xlab'></span><span id='topic+waiver'></span><span id='topic+lotri'></span><span id='topic+label_value'></span><span id='topic+label_both'></span><span id='topic+label_context'></span><span id='topic+label_wrap_gen'></span><span id='topic+scale_x_discrete'></span><span id='topic+scale_y_discrete'></span><span id='topic+scale_x_continuous'></span><span id='topic+scale_y_continuous'></span><span id='topic+scale_x_date'></span><span id='topic+scale_y_date'></span><span id='topic+expand_limits'></span><span id='topic++25+3E+25'></span><span id='topic+rxWithPreserveSeed'></span><span id='topic+rxSetSeed'></span><span id='topic+rxWithSeed'></span><span id='topic+rxGetSeed'></span><span id='topic+cvPost'></span><span id='topic+invWR1d'></span><span id='topic+phi'></span><span id='topic+rLKJ1'></span><span id='topic+rinvchisq'></span><span id='topic+rxRmvn'></span><span id='topic+rxSeedEng'></span><span id='topic+.vecDf'></span><span id='topic+.cbindOme'></span><span id='topic+et'></span><span id='topic+.s3register'></span><span id='topic+add.dosing'></span><span id='topic+add.sampling'></span><span id='topic+as.et'></span><span id='topic+as.rxEvid'></span><span id='topic+as.rxRateDur'></span><span id='topic+etExpand'></span><span id='topic+etRbind'></span><span id='topic+etRep'></span><span id='topic+etSeq'></span><span id='topic+eventTable'></span><span id='topic+rxEtDispatchSolve'></span><span id='topic+rxEvid'></span><span id='topic+rxRateDur'></span><span id='topic+rxReq'></span><span id='topic+.collectWarnings'></span><span id='topic+.clearPipe'></span><span id='topic+rxCbindStudyIndividual'></span><span id='topic+rxStack'></span><span id='topic+rxDerived'></span><span id='topic+forderForceBase'></span><span id='topic+rxSetIni0'></span><span id='topic+.getLastIdLvl'></span><span id='topic+.expandPars'></span><span id='topic+toTrialDuration'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>ggplot2</dt><dd><p><code><a href="ggplot2.html#topic+aes">aes</a></code>, <code><a href="ggplot2.html#topic+expand_limits">expand_limits</a></code>, <code><a href="ggplot2.html#topic+facet_wrap">facet_wrap</a></code>, <code><a href="ggplot2.html#topic+geom_path">geom_line</a></code>, <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>, <code><a href="ggplot2.html#topic+labellers">label_both</a></code>, <code><a href="ggplot2.html#topic+labellers">label_context</a></code>, <code><a href="ggplot2.html#topic+labellers">label_context</a></code>, <code><a href="ggplot2.html#topic+labellers">label_value</a></code>, <code><a href="ggplot2.html#topic+labellers">label_wrap_gen</a></code>, <code><a href="ggplot2.html#topic+scale_type">scale_type</a></code>, <code><a href="ggplot2.html#topic+scale_continuous">scale_x_continuous</a></code>, <code><a href="ggplot2.html#topic+scale_date">scale_x_date</a></code>, <code><a href="ggplot2.html#topic+scale_discrete">scale_x_discrete</a></code>, <code><a href="ggplot2.html#topic+scale_continuous">scale_y_continuous</a></code>, <code><a href="ggplot2.html#topic+scale_date">scale_y_date</a></code>, <code><a href="ggplot2.html#topic+scale_discrete">scale_y_discrete</a></code>, <code><a href="ggplot2.html#topic+waiver">waiver</a></code>, <code><a href="ggplot2.html#topic+labs">xlab</a></code>, <code><a href="ggplot2.html#topic+labs">ylab</a></code></p>
</dd>
<dt>lotri</dt><dd><p><code><a href="lotri.html#topic+lotri">lotri</a></code></p>
</dd>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
<dt>rxode2et</dt><dd><p><code><a href="rxode2et.html#topic+dot-clearPipe">.clearPipe</a></code>, <code><a href="rxode2et.html#topic+dot-collectWarnings">.collectWarnings</a></code>, <code><a href="rxode2et.html#topic+dot-s3register">.s3register</a></code>, <code><a href="rxode2et.html#topic+add.dosing">add.dosing</a></code>, <code><a href="rxode2et.html#topic+add.sampling">add.sampling</a></code>, <code><a href="rxode2et.html#topic+as.et">as.et</a></code>, <code><a href="rxode2et.html#topic+rxEvid">as.rxEvid</a></code>, <code><a href="rxode2et.html#topic+rxRateDur">as.rxRateDur</a></code>, <code><a href="rxode2et.html#topic+et">et</a></code>, <code><a href="rxode2et.html#topic+etExpand">etExpand</a></code>, <code><a href="rxode2et.html#topic+etRbind">etRbind</a></code>, <code><a href="rxode2et.html#topic+etRep">etRep</a></code>, <code><a href="rxode2et.html#topic+etSeq">etSeq</a></code>, <code><a href="rxode2et.html#topic+eventTable">eventTable</a></code>, <code><a href="rxode2et.html#topic+rxCbindStudyIndividual">rxCbindStudyIndividual</a></code>, <code><a href="rxode2et.html#topic+rxEtDispatchSolve">rxEtDispatchSolve</a></code>, <code><a href="rxode2et.html#topic+rxEvid">rxEvid</a></code>, <code><a href="rxode2et.html#topic+rxRateDur">rxRateDur</a></code>, <code><a href="rxode2et.html#topic+rxReq">rxReq</a></code>, <code><a href="rxode2et.html#topic+rxStack">rxStack</a></code>, <code><a href="rxode2et.html#topic+toTrialDuration">toTrialDuration</a></code></p>
</dd>
<dt>rxode2parse</dt><dd><p><code><a href="rxode2parse.html#topic+dot-getLastIdLvl">.getLastIdLvl</a></code>, <code><a href="rxode2parse.html#topic+forderForceBase">forderForceBase</a></code>, <code><a href="rxode2parse.html#topic+rxDerived">rxDerived</a></code>, <code><a href="rxode2parse.html#topic+rxSetIni0">rxSetIni0</a></code></p>
</dd>
<dt>rxode2random</dt><dd><p><code><a href="rxode2random.html#topic+dot-cbindOme">.cbindOme</a></code>, <code><a href="rxode2random.html#topic+dot-expandPars">.expandPars</a></code>, <code><a href="rxode2random.html#topic+dot-vecDf">.vecDf</a></code>, <code><a href="rxode2random.html#topic+cvPost">cvPost</a></code>, <code><a href="rxode2random.html#topic+invWR1d">invWR1d</a></code>, <code><a href="rxode2random.html#topic+phi">phi</a></code>, <code><a href="rxode2random.html#topic+rinvchisq">rinvchisq</a></code>, <code><a href="rxode2random.html#topic+rLKJ1">rLKJ1</a></code>, <code><a href="rxode2random.html#topic+rxGetSeed">rxGetSeed</a></code>, <code><a href="rxode2random.html#topic+rxGetSeed">rxGetSeed</a></code>, <code><a href="rxode2random.html#topic+rxRmvn">rxRmvn</a></code>, <code><a href="rxode2random.html#topic+rxSeedEng">rxSeedEng</a></code>, <code><a href="rxode2random.html#topic+rxSetSeed">rxSetSeed</a></code>, <code><a href="rxode2random.html#topic+rxSetSeed">rxSetSeed</a></code>, <code><a href="rxode2random.html#topic+rxSetSeed">rxSetSeed</a></code>, <code><a href="rxode2random.html#topic+rxWithSeed">rxWithPreserveSeed</a></code>, <code><a href="rxode2random.html#topic+rxWithSeed">rxWithSeed</a></code>, <code><a href="rxode2random.html#topic+rxWithSeed">rxWithSeed</a></code></p>
</dd>
</dl>


<h3>Value</h3>

<p> Inherited from parent routine </p>

<hr>
<h2 id='rxAllowUnload'>Allow unloading of dlls</h2><span id='topic+rxAllowUnload'></span>

<h3>Description</h3>

<p>Allow unloading of dlls
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxAllowUnload(allow)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxAllowUnload_+3A_allow">allow</code></td>
<td>
<p>boolean indicating if garbage collection will unload of rxode2 dlls.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean allow; called for side effects
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Garbage collection will not unload un-used rxode2 dlls
rxAllowUnload(FALSE);

# Garbage collection will unload unused rxode2 dlls
rxAllowUnload(TRUE);
</code></pre>

<hr>
<h2 id='rxAppendModel'>Append two rxui models together</h2><span id='topic+rxAppendModel'></span>

<h3>Description</h3>

<p>Append two rxui models together
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxAppendModel(..., common = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxAppendModel_+3A_...">...</code></td>
<td>
<p>models to append together</p>
</td></tr>
<tr><td><code id="rxAppendModel_+3A_common">common</code></td>
<td>
<p>boolean that determines if you need a common value to bind</p>
</td></tr>
</table>


<h3>Value</h3>

<p>New model with both models appended together
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


ocmt &lt;- function() {
  ini({
    tka &lt;- exp(0.45) # Ka
    tcl &lt;- exp(1) # Cl
    tv &lt;- exp(3.45); # log V
    ## the label("Label name") works with all models
    add.sd &lt;- 0.7
  })
  model({
    ka &lt;- tka
    cl &lt;- tcl
    v &lt;- tv
    d/dt(depot) &lt;- -ka * depot
    d/dt(center) &lt;- ka * depot - cl / v * center
    cp &lt;- center / v
    cp ~ add(add.sd)
  })
}

idr &lt;- function() {
  ini({
    tkin &lt;- log(1)
    tkout &lt;- log(1)
    tic50 &lt;- log(10)
    gamma &lt;- fix(1)
    idr.sd &lt;- 1
  })
  model({
    kin &lt;- exp(tkin)
    kout &lt;- exp(tkout)
    ic50 &lt;- exp(tic50)
    d/dt(eff) &lt;- kin - kout*(1-ceff^gamma/(ic50^gamma+ceff^gamma))
    eff ~ add(idr.sd)
  })
}

rxAppendModel(ocmt %&gt;% model(ceff=cp,append=TRUE), idr)



</code></pre>

<hr>
<h2 id='rxAssignControlValue'>Assign Control Variable</h2><span id='topic+rxAssignControlValue'></span>

<h3>Description</h3>

<p>Assign Control Variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxAssignControlValue(ui, option, value)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxAssignControlValue_+3A_ui">ui</code></td>
<td>
<p>rxode2 ui function</p>
</td></tr>
<tr><td><code id="rxAssignControlValue_+3A_option">option</code></td>
<td>
<p>Option name in the control to modify</p>
</td></tr>
<tr><td><code id="rxAssignControlValue_+3A_value">value</code></td>
<td>
<p>Value of control to modify</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing; called for the side effects
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxAssignPtr'>Assign pointer based on model variables</h2><span id='topic+rxAssignPtr'></span>

<h3>Description</h3>

<p>Assign pointer based on model variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxAssignPtr(object = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxAssignPtr_+3A_object">object</code></td>
<td>
<p>rxode2 family of objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing, called for side effects
</p>

<hr>
<h2 id='rxbeta'>Simulate beta variable from threefry generator</h2><span id='topic+rxbeta'></span>

<h3>Description</h3>

<p>Care should be taken with this method not to encounter the
birthday problem, described
<a href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/">https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/</a>.
Since the <code>sitmo</code> <code>threefry</code>, this currently generates
one random deviate from the uniform distribution to seed the
engine <code>threefry</code> and then run the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxbeta(shape1, shape2, n = 1L, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxbeta_+3A_shape1">shape1</code>, <code id="rxbeta_+3A_shape2">shape2</code></td>
<td>
<p>non-negative parameters of the Beta distribution.</p>
</td></tr>
<tr><td><code id="rxbeta_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="rxbeta_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the simulation
</p>
<p><code>rxnorm</code> simulates using the threefry sitmo generator.
</p>
<p><code>rxnormV</code> used to simulate with the vandercorput simulator, but
since it didn't satisfy the normal properties it was changed to simple be
an alias of <code>rxnorm</code>. It is no longer supported in <code>rxode2({})</code> blocks</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Therefore, a simple call to the random number generated followed by a second
call to random number generated may have identical seeds.  As the number of
random number generator calls are increased the probability that the
birthday problem will increase.
</p>
<p>The key to avoid this problem is to either run all simulations in the
<code>rxode2</code> environment once (therefore one seed or series of seeds
for the whole simulation), pre-generate all random variables
used for the simulation, or seed the rxode2 engine with <code>rxSetSeed()</code>
</p>
<p>Internally each ID is seeded with a unique number so that the
results do not depend on the number of cores used.
</p>


<h3>Value</h3>

<p>beta random deviates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Use threefry engine

rxbeta(0.5, 0.5, n = 10) # with rxbeta you have to explicitly state n
rxbeta(5, 1, n = 10, ncores = 2) # You can parallelize the simulation using openMP

rxbeta(1, 3)


## This example uses `rxbeta` directly in the model

rx &lt;- function() {
  model({
    a &lt;- rxbeta(2, 2)
  })
}

et &lt;- et(1, id = 1:2)

s &lt;- rxSolve(rx, et)

</code></pre>

<hr>
<h2 id='rxbinom'>Simulate Binomial variable from threefry generator</h2><span id='topic+rxbinom'></span>

<h3>Description</h3>

<p>Care should be taken with this method not to encounter the
birthday problem, described
<a href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/">https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/</a>.
Since the <code>sitmo</code> <code>threefry</code>, this currently generates
one random deviate from the uniform distribution to seed the
engine <code>threefry</code> and then run the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxbinom(size, prob, n = 1L, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxbinom_+3A_size">size</code></td>
<td>
<p>number of trials (zero or more).</p>
</td></tr>
<tr><td><code id="rxbinom_+3A_prob">prob</code></td>
<td>
<p>probability of success on each trial.</p>
</td></tr>
<tr><td><code id="rxbinom_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="rxbinom_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the simulation
</p>
<p><code>rxnorm</code> simulates using the threefry sitmo generator.
</p>
<p><code>rxnormV</code> used to simulate with the vandercorput simulator, but
since it didn't satisfy the normal properties it was changed to simple be
an alias of <code>rxnorm</code>. It is no longer supported in <code>rxode2({})</code> blocks</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Therefore, a simple call to the random number generated followed by a second
call to random number generated may have identical seeds.  As the number of
random number generator calls are increased the probability that the
birthday problem will increase.
</p>
<p>The key to avoid this problem is to either run all simulations in the
<code>rxode2</code> environment once (therefore one seed or series of seeds
for the whole simulation), pre-generate all random variables
used for the simulation, or seed the rxode2 engine with <code>rxSetSeed()</code>
</p>
<p>Internally each ID is seeded with a unique number so that the
results do not depend on the number of cores used.
</p>


<h3>Value</h3>

<p>binomial random deviates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Use threefry engine

rxbinom(10, 0.9, n = 10) # with rxbinom you have to explicitly state n
rxbinom(3, 0.5, n = 10, ncores = 2) # You can parallelize the simulation using openMP

rxbinom(4, 0.7)


## This example uses `rxbinom` directly in the model

rx &lt;- function() {
  model({
    a &lt;- rxbinom(1, 0.5)
  })
}

et &lt;- et(1, id = 1:2)

s &lt;- rxSolve(rx, et)


</code></pre>

<hr>
<h2 id='rxBlockZeros'>Creates a logical matrix for block matrixes.</h2><span id='topic+rxBlockZeros'></span>

<h3>Description</h3>

<p>Creates a logical matrix for block matrixes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxBlockZeros(mat, i)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxBlockZeros_+3A_mat">mat</code></td>
<td>
<p>Matrix</p>
</td></tr>
<tr><td><code id="rxBlockZeros_+3A_i">i</code></td>
<td>
<p>Row/column where block matrix should be setup.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical matrix returning where the elements should be
zero.
</p>

<hr>
<h2 id='rxC'>Return the C file associated with the rxode2 object</h2><span id='topic+rxC'></span>

<h3>Description</h3>

<p>This will return C code for generating the rxode2 DLL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxC(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxC_+3A_obj">obj</code></td>
<td>
<p>A rxode2 family of objects or a character string of the
model specification or location of a file with a model
specification.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a path of the library
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>

<hr>
<h2 id='rxCat'>Use cat when rxode2.verbose is TRUE</h2><span id='topic+rxCat'></span>

<h3>Description</h3>

<p>Use cat when rxode2.verbose is TRUE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxCat(a, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxCat_+3A_...">...</code></td>
<td>
<p>Parameters sent to cat</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxcauchy'>Simulate Cauchy variable from threefry generator</h2><span id='topic+rxcauchy'></span>

<h3>Description</h3>

<p>Care should be taken with this method not to encounter the
birthday problem, described
<a href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/">https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/</a>.
Since the <code>sitmo</code> <code>threefry</code>, this currently generates
one random deviate from the uniform distribution to seed the
engine <code>threefry</code> and then run the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxcauchy(location = 0, scale = 1, n = 1L, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxcauchy_+3A_location">location</code>, <code id="rxcauchy_+3A_scale">scale</code></td>
<td>
<p>location and scale parameters.</p>
</td></tr>
<tr><td><code id="rxcauchy_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="rxcauchy_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the simulation
</p>
<p><code>rxnorm</code> simulates using the threefry sitmo generator.
</p>
<p><code>rxnormV</code> used to simulate with the vandercorput simulator, but
since it didn't satisfy the normal properties it was changed to simple be
an alias of <code>rxnorm</code>. It is no longer supported in <code>rxode2({})</code> blocks</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Therefore, a simple call to the random number generated followed by a second
call to random number generated may have identical seeds.  As the number of
random number generator calls are increased the probability that the
birthday problem will increase.
</p>
<p>The key to avoid this problem is to either run all simulations in the
<code>rxode2</code> environment once (therefore one seed or series of seeds
for the whole simulation), pre-generate all random variables
used for the simulation, or seed the rxode2 engine with <code>rxSetSeed()</code>
</p>
<p>Internally each ID is seeded with a unique number so that the
results do not depend on the number of cores used.
</p>


<h3>Value</h3>

<p>Cauchy random deviates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Use threefry engine

rxcauchy(0, 1, n = 10) # with rxcauchy you have to explicitly state n
rxcauchy(0.5, n = 10, ncores = 2) # You can parallelize the simulation using openMP

rxcauchy(3)


## This example uses `rxcauchy` directly in the model

rx &lt;- function() {
  model({
    a &lt;- rxcauchy(2)
  })
}

et &lt;- et(1, id = 1:2)

s &lt;- rxSolve(rx, et)


</code></pre>

<hr>
<h2 id='rxChain'>rxChain  Chain or add item to solved system of equations</h2><span id='topic+rxChain'></span><span id='topic++2B.solveRxDll'></span>

<h3>Description</h3>

<p>Add item to solved system of equations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxChain(obj1, obj2)

## S3 method for class 'solveRxDll'
obj1 + obj2
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxChain_+3A_obj1">obj1</code></td>
<td>
<p>Solved object.</p>
</td></tr>
<tr><td><code id="rxChain_+3A_obj2">obj2</code></td>
<td>
<p>New object to be added/piped/chained to solved object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When <code>newObject</code> is an event table, return a new
solved object with the new event table.
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxChain2'>Second command in chaining commands</h2><span id='topic+rxChain2'></span><span id='topic+rxChain2.default'></span><span id='topic+rxChain2.EventTable'></span>

<h3>Description</h3>

<p>This is s3 method is called internally with <code>+</code> and <code style="white-space: pre;">&#8288;\%&gt;\%&#8288;</code> operators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxChain2(obj, solvedObject)

## Default S3 method:
rxChain2(obj, solvedObject)

## S3 method for class 'EventTable'
rxChain2(obj, solvedObject)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxChain2_+3A_obj">obj</code></td>
<td>
<p>the object being added/chained/piped to the solved object</p>
</td></tr>
<tr><td><code id="rxChain2_+3A_solvedobject">solvedObject</code></td>
<td>
<p>the solved object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>chained operation
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>

<hr>
<h2 id='rxchisq'>Simulate chi-squared variable from threefry generator</h2><span id='topic+rxchisq'></span>

<h3>Description</h3>

<p>Care should be taken with this method not to encounter the
birthday problem, described
<a href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/">https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/</a>.
Since the <code>sitmo</code> <code>threefry</code>, this currently generates
one random deviate from the uniform distribution to seed the
engine <code>threefry</code> and then run the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxchisq(df, n = 1L, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxchisq_+3A_df">df</code></td>
<td>
<p>degrees of freedom (non-negative, but can be non-integer).</p>
</td></tr>
<tr><td><code id="rxchisq_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="rxchisq_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the simulation
</p>
<p><code>rxnorm</code> simulates using the threefry sitmo generator.
</p>
<p><code>rxnormV</code> used to simulate with the vandercorput simulator, but
since it didn't satisfy the normal properties it was changed to simple be
an alias of <code>rxnorm</code>. It is no longer supported in <code>rxode2({})</code> blocks</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Therefore, a simple call to the random number generated followed by a second
call to random number generated may have identical seeds.  As the number of
random number generator calls are increased the probability that the
birthday problem will increase.
</p>
<p>The key to avoid this problem is to either run all simulations in the
<code>rxode2</code> environment once (therefore one seed or series of seeds
for the whole simulation), pre-generate all random variables
used for the simulation, or seed the rxode2 engine with <code>rxSetSeed()</code>
</p>
<p>Internally each ID is seeded with a unique number so that the
results do not depend on the number of cores used.
</p>


<h3>Value</h3>

<p>chi squared random deviates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Use threefry engine

rxchisq(0.5, n = 10) # with rxchisq you have to explicitly state n
rxchisq(5, n = 10, ncores = 2) # You can parallelize the simulation using openMP

rxchisq(1)


## This example uses `rxchisq` directly in the model

rx &lt;- function() {
  model({
    a &lt;- rxchisq(2)
  })
}

et &lt;- et(1, id = 1:2)

s &lt;- rxSolve(rx, et)


</code></pre>

<hr>
<h2 id='rxClean'>Cleanup anonymous DLLs by unloading them</h2><span id='topic+rxClean'></span>

<h3>Description</h3>

<p>This cleans up any rxode2 loaded DLLs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxClean(wd)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxClean_+3A_wd">wd</code></td>
<td>
<p>What directory should be cleaned; (DEPRECIATED), this no
longer does anything.
</p>
<p>This unloads all rxode2 anonymous dlls.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if successful
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxCombineErrorLines'>Combine Error Lines and create rxode2 expression</h2><span id='topic+rxCombineErrorLines'></span>

<h3>Description</h3>

<p>Combine Error Lines and create rxode2 expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxCombineErrorLines(
  uiModel,
  errLines = NULL,
  prefixLines = NULL,
  paramsLine = NULL,
  modelVars = FALSE,
  cmtLines = TRUE,
  dvidLine = TRUE,
  lstExpr = NULL,
  useIf = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxCombineErrorLines_+3A_uimodel">uiModel</code></td>
<td>
<p>UI model</p>
</td></tr>
<tr><td><code id="rxCombineErrorLines_+3A_errlines">errLines</code></td>
<td>
<p>Error lines; If missing, get the error lines from
<code>rxGetDistributionSimulationLines()</code></p>
</td></tr>
<tr><td><code id="rxCombineErrorLines_+3A_prefixlines">prefixLines</code></td>
<td>
<p>Prefix lines, after param statement</p>
</td></tr>
<tr><td><code id="rxCombineErrorLines_+3A_paramsline">paramsLine</code></td>
<td>
<p>Params line, if not present.</p>
</td></tr>
<tr><td><code id="rxCombineErrorLines_+3A_modelvars">modelVars</code></td>
<td>
<p>Return model vars instead of rxode2 statement</p>
</td></tr>
<tr><td><code id="rxCombineErrorLines_+3A_cmtlines">cmtLines</code></td>
<td>
<p>Include trailing <code>cmt</code> lines</p>
</td></tr>
<tr><td><code id="rxCombineErrorLines_+3A_dvidline">dvidLine</code></td>
<td>
<p>Include trailing <code>dvid()</code> specification</p>
</td></tr>
<tr><td><code id="rxCombineErrorLines_+3A_lstexpr">lstExpr</code></td>
<td>
<p>A list of expressions for model, or NULL.  When NULL
defaults to the model expressions accessible by
<code>uiModel$lstExpr</code>.</p>
</td></tr>
<tr><td><code id="rxCombineErrorLines_+3A_useif">useIf</code></td>
<td>
<p>Use an <code style="white-space: pre;">&#8288;if (CMT == X)&#8288;</code> for endpoints</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is exported to allow other functions to mangle the error lines
to make other types of estimation methods (if needed)
</p>


<h3>Value</h3>

<p>quoted expression that can be evaluated to compiled rxode2
model
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


one.cmt &lt;- function() {
  ini({
    ## You may label each parameter with a comment
    tka &lt;- 0.45 # Log Ka
    tcl &lt;- log(c(0, 2.7, 100)) # Log Cl
    ## This works with interactive models
    ## You may also label the preceding line with label("label text")
    tv &lt;- 3.45; label("log V")
    ## the label("Label name") works with all models
    eta.ka ~ 0.6
    eta.cl ~ 0.3
    eta.v ~ 0.1
    add.sd &lt;- 0.7
  })
  model({
    ka &lt;- exp(tka + eta.ka)
    cl &lt;- exp(tcl + eta.cl)
    v &lt;- exp(tv + eta.v)
    linCmt() ~ add(add.sd)
  })
}

f &lt;- rxode2(one.cmt)

# You can get the simulation model easily by
rxCombineErrorLines(f)

# You can then get the compiled model by simply evaluting the model:
r &lt;- eval(rxCombineErrorLines(f))

# This also works with multile endpoint models:
pk.turnover.emax &lt;- function() {
  ini({
    tktr &lt;- log(1)
    tka &lt;- log(1)
    tcl &lt;- log(0.1)
    tv &lt;- log(10)
    ##
    eta.ktr ~ 1
    eta.ka ~ 1
    eta.cl ~ 2
    eta.v ~ 1
    prop.err &lt;- 0.1
    pkadd.err &lt;- 0.1
    ##
    temax &lt;- logit(0.8)
    tec50 &lt;- log(0.5)
    tkout &lt;- log(0.05)
    te0 &lt;- log(100)
    ##
    eta.emax ~ .5
    eta.ec50  ~ .5
    eta.kout ~ .5
    eta.e0 ~ .5
    ##
    pdadd.err &lt;- 10
  })
  model({
    ktr &lt;- exp(tktr + eta.ktr)
    ka &lt;- exp(tka + eta.ka)
    cl &lt;- exp(tcl + eta.cl)
    v &lt;- exp(tv + eta.v)
    ##
    emax=expit(temax+eta.emax)
    ec50 =  exp(tec50 + eta.ec50)
    kout = exp(tkout + eta.kout)
    e0 = exp(te0 + eta.e0)
    ##
    DCP = center/v
    PD=1-emax*DCP/(ec50+DCP)
    ##
    effect(0) = e0
    kin = e0*kout
    ##
    d/dt(depot) = -ktr * depot
    d/dt(gut) =  ktr * depot -ka * gut
    d/dt(center) =  ka * gut - cl / v * center
    d/dt(effect) = kin*PD -kout*effect
    ##
    cp = center / v
    cp ~ prop(prop.err) + add(pkadd.err)
    effect ~ add(pdadd.err)
  })
}

f &lt;- rxode2(pk.turnover.emax)
rxCombineErrorLines(f)

# Note that in the parsed form, you can also get the compiled rxode2
# model with $simulationModel

f$simulationModel


</code></pre>

<hr>
<h2 id='rxCompile'>Compile a model if needed</h2><span id='topic+rxCompile'></span><span id='topic+rxCompile.rxModelVars'></span><span id='topic+rxCompile.character'></span><span id='topic+rxCompile.rxDll'></span><span id='topic+rxCompile.rxode2'></span>

<h3>Description</h3>

<p>This is the compilation workhorse creating the rxode2 model DLL
files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxCompile(
  model,
  dir,
  prefix,
  force = FALSE,
  modName = NULL,
  package = NULL,
  ...
)

## S3 method for class 'rxModelVars'
rxCompile(
  model,
  dir = NULL,
  prefix = NULL,
  force = FALSE,
  modName = NULL,
  package = NULL,
  ...
)

## S3 method for class 'character'
rxCompile(
  model,
  dir = NULL,
  prefix = NULL,
  force = FALSE,
  modName = NULL,
  package = NULL,
  ...
)

## S3 method for class 'rxDll'
rxCompile(model, ...)

## S3 method for class 'rxode2'
rxCompile(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxCompile_+3A_model">model</code></td>
<td>
<p>This is the ODE model specification.  It can be:
</p>

<ul>
<li><p> a string containing the set of ordinary differential
equations (ODE) and other expressions defining the changes in
the dynamic system.
</p>
</li>
<li><p> a file name where the ODE system equation is contained
</p>
</li></ul>

<p>An ODE expression enclosed in <code style="white-space: pre;">&#8288;\{\}&#8288;</code>
</p>
<p>(see also the <code>filename</code> argument). For
details, see the sections &ldquo;Details&rdquo; and
<code style="white-space: pre;">&#8288;rxode2 Syntax&#8288;</code> below.</p>
</td></tr>
<tr><td><code id="rxCompile_+3A_dir">dir</code></td>
<td>
<p>This is the model directory where the C file will be
stored for compiling.
</p>
<div class="sourceCode"><pre>If unspecified, the C code is stored in a temporary directory,
then the model is compiled and moved to the current directory.
Afterwards the C code is removed.

If specified, the C code is stored in the specified directory
and then compiled in that directory.  The C code is not removed
after the DLL is created in the same directory.  This can be
useful to debug the c-code outputs.
</pre></div></td></tr>
<tr><td><code id="rxCompile_+3A_prefix">prefix</code></td>
<td>
<p>is a string indicating the prefix to use in the C
based functions.  If missing, it is calculated based on file
name, or md5 of parsed model.</p>
</td></tr>
<tr><td><code id="rxCompile_+3A_force">force</code></td>
<td>
<p>is a boolean stating if the (re)compile should be
forced if rxode2 detects that the models are the same as already
generated.</p>
</td></tr>
<tr><td><code id="rxCompile_+3A_modname">modName</code></td>
<td>
<p>a string to be used as the model name. This string
is used for naming various aspects of the computations,
including generating C symbol names, dynamic libraries,
etc. Therefore, it is necessary that <code>modName</code> consists of
simple ASCII alphanumeric characters starting with a letter.</p>
</td></tr>
<tr><td><code id="rxCompile_+3A_package">package</code></td>
<td>
<p>Package name for pre-compiled binaries.</p>
</td></tr>
<tr><td><code id="rxCompile_+3A_...">...</code></td>
<td>
<p>Other arguments sent to the <code><a href="#topic+rxTrans">rxTrans()</a></code>
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An rxDll object that has the following components
</p>

<ul>
<li> <p><code>dll</code> DLL path
</p>
</li>
<li> <p><code>model</code> model specification
</p>
</li>
<li> <p><code>.c</code> A function to call C code in the correct context from the DLL
using the <code><a href="base.html#topic+.C">.C()</a></code> function.
</p>
</li>
<li> <p><code>.call</code> A function to call C code in the correct context from the DLL
using the <code><a href="base.html#topic+.Call">.Call()</a></code> function.
</p>
</li>
<li> <p><code>args</code> A list of the arguments used to create the rxDll object.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rxode2">rxode2()</a></code>
</p>

<hr>
<h2 id='rxCondition'>Current Condition for rxode2 object</h2><span id='topic+rxCondition'></span>

<h3>Description</h3>

<p>Current Condition for rxode2 object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxCondition(obj, condition = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxCondition_+3A_obj">obj</code></td>
<td>
<p>rxode2 object</p>
</td></tr>
<tr><td><code id="rxCondition_+3A_condition">condition</code></td>
<td>
<p>If specified and is one of the conditions in the
rxode2 object (as determined by <code><a href="#topic+rxExpandIfElse">rxExpandIfElse()</a></code>),
assign the rxode2 current condition to this parameter.  If the
condition is not one of the known condition, the condition is
set to <code>NULL</code>, implying no conditioning currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Current condition for rxode2 object
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxControlUpdateSens'>This updates the tolerances based on the sensitivity equations</h2><span id='topic+rxControlUpdateSens'></span>

<h3>Description</h3>

<p>This assumes the normal ODE equations are the first equations and
the ODE is expanded by the forward sensitivities or other type of
sensitivity (like adjoint)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxControlUpdateSens(rxControl, sensCmt = NULL, ncmt = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxControlUpdateSens_+3A_rxcontrol">rxControl</code></td>
<td>
<p>Input list or rxControl type of list</p>
</td></tr>
<tr><td><code id="rxControlUpdateSens_+3A_senscmt">sensCmt</code></td>
<td>
<p>Number of sensitivity compartments</p>
</td></tr>
<tr><td><code id="rxControlUpdateSens_+3A_ncmt">ncmt</code></td>
<td>
<p>Number of compartments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated rxControl where <code style="white-space: pre;">&#8288;$atol&#8288;</code>, <code style="white-space: pre;">&#8288;$rtol&#8288;</code>, <code style="white-space: pre;">&#8288;$ssAtol&#8288;</code>
<code style="white-space: pre;">&#8288;$ssRtol&#8288;</code> are updated with different sensitivities for the normal
ODEs (first) and a different sensitivity for the larger
compartments (sensitivities).
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tmp &lt;- rxControl()

tmp2 &lt;- rxControlUpdateSens(tmp, 3, 6)

tmp2$atol
tmp2$rtol
tmp2$ssAtol
tmp2$ssRtol
</code></pre>

<hr>
<h2 id='rxCreateCache'>This will create the cache directory for rxode2 to save between sessions</h2><span id='topic+rxCreateCache'></span>

<h3>Description</h3>

<p>When run, if the <code>R_user_dir</code> for rxode2's cache isn't present,
create the cache
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxCreateCache()
</code></pre>


<h3>Value</h3>

<p>nothing
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='rxD'>Add to rxode2's derivative tables</h2><span id='topic+rxD'></span>

<h3>Description</h3>

<p>Add to rxode2's derivative tables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxD(name, derivatives)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxD_+3A_name">name</code></td>
<td>
<p>Function Name</p>
</td></tr>
<tr><td><code id="rxD_+3A_derivatives">derivatives</code></td>
<td>
<p>A list of functions. Each function takes the
same number of arguments as the original function.  The first
function will construct the derivative with respect to the
first argument; The second function will construct the
derivitive with respect to the second argument, and so on.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Add an arbitrary list of derivative functions
## In this case the fun(x,y) is assumed to be 0.5*x^2+0.5*y^2

rxD("fun", list(
  function(x, y) {
    return(x)
  },
  function(x, y) {
    return(y)
  }
))
</code></pre>

<hr>
<h2 id='rxDelete'>Delete the DLL for the model</h2><span id='topic+rxDelete'></span>

<h3>Description</h3>

<p>This function deletes the DLL, but doesn't delete the model
information in the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxDelete(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxDelete_+3A_obj">obj</code></td>
<td>
<p>rxode2 family of objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean stating if the operation was successful.
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>

<hr>
<h2 id='rxDemoteAddErr'>Demote the error type</h2><span id='topic+rxDemoteAddErr'></span>

<h3>Description</h3>

<p>Demote the error type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxDemoteAddErr(errType)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxDemoteAddErr_+3A_errtype">errType</code></td>
<td>
<p>Error type factor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Demoted Error Type
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rxErrTypeCombine("add") %&gt;%
  rxErrTypeCombine("prop")

# This removes the internal additive error
rxErrTypeCombine("add") %&gt;%
  rxErrTypeCombine("prop") %&gt;%
  rxDemoteAddErr()

# This is used for logitNorm(NA), the additive portion is stripped

</code></pre>

<hr>
<h2 id='rxDfdy'>Jacobian and parameter derivatives</h2><span id='topic+rxDfdy'></span>

<h3>Description</h3>

<p>Return Jacobain and parameter derivatives
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxDfdy(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxDfdy_+3A_obj">obj</code></td>
<td>
<p>rxode2 family of objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the jacobian parameters defined in this rxode2
object.
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>See Also</h3>

<p>Other Query model information: 
<code><a href="#topic+rxInits">rxInits</a>()</code>,
<code><a href="#topic+rxLhs">rxLhs</a>()</code>,
<code><a href="#topic+rxModelVars">rxModelVars</a>()</code>,
<code><a href="#topic+rxParams">rxParams</a>()</code>,
<code><a href="#topic+rxState">rxState</a>()</code>
</p>

<hr>
<h2 id='rxDll'>Return the DLL associated with the rxode2 object</h2><span id='topic+rxDll'></span>

<h3>Description</h3>

<p>This will return the dynamic load library or shared object used to
run the C code for rxode2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxDll(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxDll_+3A_obj">obj</code></td>
<td>
<p>A rxode2 family of objects or a character string of the
model specification or location of a file with a model
specification.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a path of the library
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>

<hr>
<h2 id='rxDynLoad'>Load rxode2 object</h2><span id='topic+rxDynLoad'></span><span id='topic+rxLoad'></span>

<h3>Description</h3>

<p>Load rxode2 object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxDynLoad(obj)

rxLoad(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxDynLoad_+3A_obj">obj</code></td>
<td>
<p>A rxode2 family of objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean returning if the rxode2 library is loaded.
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>

<hr>
<h2 id='rxDynUnload'>Unload rxode2 object</h2><span id='topic+rxDynUnload'></span><span id='topic+rxUnload'></span>

<h3>Description</h3>

<p>Unload rxode2 object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxDynUnload(obj)

rxUnload(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxDynUnload_+3A_obj">obj</code></td>
<td>
<p>A rxode2 family of objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean returning if the rxode2 library is loaded.
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>

<hr>
<h2 id='rxErrTypeCombine'>Combine transformations and error structures</h2><span id='topic+rxErrTypeCombine'></span>

<h3>Description</h3>

<p>Combine error information to figure out what transformation is
being applied for the current endpoint
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxErrTypeCombine(oldErrType, newErrType)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxErrTypeCombine_+3A_olderrtype">oldErrType</code></td>
<td>
<p>This is the old transformation, by default is
zero representing no prior transformation. This parameter is
first to allow piping. When the parameter <code>addTransform</code> is
missing and <code>oldErrType</code> is a character value, this functions
swaps <code>oldErrType</code> and <code>addTransform</code> and assigns
<code>oldErrType</code> to zero assuming that there is no prior
distribution.</p>
</td></tr>
<tr><td><code id="rxErrTypeCombine_+3A_newerrtype">newErrType</code></td>
<td>
<p>This is the new distribution that is being
&quot;added&quot; to the current transformation.  These assumes the inputs
are in the preferred distribution name, as determined by
<code>rxPreferredDistributionName()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The new transformation as a factor
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rxErrTypeCombine("probitNorm")

rxErrTypeCombine("probitNorm") %&gt;%
  rxErrTypeCombine("boxCox")


</code></pre>

<hr>
<h2 id='rxexp'>Simulate exponential variable from threefry generator</h2><span id='topic+rxexp'></span>

<h3>Description</h3>

<p>Care should be taken with this method not to encounter the
birthday problem, described
<a href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/">https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/</a>.
Since the <code>sitmo</code> <code>threefry</code>, this currently generates
one random deviate from the uniform distribution to seed the
engine <code>threefry</code> and then run the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxexp(rate, n = 1L, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxexp_+3A_rate">rate</code></td>
<td>
<p>vector of rates.</p>
</td></tr>
<tr><td><code id="rxexp_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="rxexp_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the simulation
</p>
<p><code>rxnorm</code> simulates using the threefry sitmo generator.
</p>
<p><code>rxnormV</code> used to simulate with the vandercorput simulator, but
since it didn't satisfy the normal properties it was changed to simple be
an alias of <code>rxnorm</code>. It is no longer supported in <code>rxode2({})</code> blocks</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Therefore, a simple call to the random number generated followed by a second
call to random number generated may have identical seeds.  As the number of
random number generator calls are increased the probability that the
birthday problem will increase.
</p>
<p>The key to avoid this problem is to either run all simulations in the
<code>rxode2</code> environment once (therefore one seed or series of seeds
for the whole simulation), pre-generate all random variables
used for the simulation, or seed the rxode2 engine with <code>rxSetSeed()</code>
</p>
<p>Internally each ID is seeded with a unique number so that the
results do not depend on the number of cores used.
</p>


<h3>Value</h3>

<p>exponential random deviates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Use threefry engine

rxexp(0.5, n = 10) # with rxexp you have to explicitly state n
rxexp(5, n = 10, ncores = 2) # You can parallelize the simulation using openMP

rxexp(1)


## This example uses `rxexp` directly in the model

rx &lt;- function() {
  model({
    a &lt;- rxexp(2)
  })
}

et &lt;- et(1, id = 1:2)

s &lt;- rxSolve(rx, et)


</code></pre>

<hr>
<h2 id='rxExpandFEta_'>Expand d(f)/d(eta)</h2><span id='topic+rxExpandFEta_'></span>

<h3>Description</h3>

<p>Expand d(f)/d(eta)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxExpandFEta_(state, neta, pred, isTheta = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxExpandFEta__+3A_state">state</code></td>
<td>
<p>is the state to expand</p>
</td></tr>
<tr><td><code id="rxExpandFEta__+3A_neta">neta</code></td>
<td>
<p>is the number of etas</p>
</td></tr>
<tr><td><code id="rxExpandFEta__+3A_pred">pred</code></td>
<td>
<p>type of prediction</p>
</td></tr>
<tr><td><code id="rxExpandFEta__+3A_istheta">isTheta</code></td>
<td>
<p>logical, is the expansion actually for thetas instead of etas</p>
</td></tr>
</table>


<h3>Value</h3>

<p>String of symengine expressions to evaluate to calculate df/deta
</p>

<hr>
<h2 id='rxExpandGrid'>Faster expand.grid</h2><span id='topic+rxExpandGrid'></span>

<h3>Description</h3>

<p>Only support x and y as characters right now
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxExpandGrid(x, y, type = 0L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxExpandGrid_+3A_x">x</code></td>
<td>
<p>first element (must be character)</p>
</td></tr>
<tr><td><code id="rxExpandGrid_+3A_y">y</code></td>
<td>
<p>second element (must be character)</p>
</td></tr>
<tr><td><code id="rxExpandGrid_+3A_type">type</code></td>
<td>
<p>Internal type=0L is traditional expand grid and
type=1L is Jacobian expand grid (adds symbols)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Expand grid
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##
rxExpandGrid(letters, letters)

## Another fast method; See
## https://stackoverflow.com/questions/10405637/use-outer-instead-of-expand-grid

expand.grid.jc &lt;- function(seq1, seq2) {
  cbind(
    Var1 = rep.int(seq1, length(seq2)),
    Var2 = rep.int(seq2, rep.int(length(seq1), length(seq2)))
  )
}

microbenchmark::microbenchmark(rxExpandGrid(letters, letters), expand.grid.jc(letters, letters))

</code></pre>

<hr>
<h2 id='rxExpandGrid_'>Expand grid internal function</h2><span id='topic+rxExpandGrid_'></span>

<h3>Description</h3>

<p>Expand grid internal function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxExpandGrid_(c1, c2, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxExpandGrid__+3A_c1">c1</code></td>
<td>
<p>character vector of items to be expanded</p>
</td></tr>
<tr><td><code id="rxExpandGrid__+3A_c2">c2</code></td>
<td>
<p>second character vector of items to be expanded</p>
</td></tr>
<tr><td><code id="rxExpandGrid__+3A_type">type</code></td>
<td>
<p>0 for a typical data frame, 1 for symengine sensitivity expansion</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame (when type = 0) or symengine string (when type=1)
</p>

<hr>
<h2 id='rxExpandIfElse'>Expand if/else clauses into multiple different types of lines.</h2><span id='topic+rxExpandIfElse'></span>

<h3>Description</h3>

<p>Expand if/else clauses into multiple different types of lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxExpandIfElse(model, removeInis = TRUE, removePrint = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxExpandIfElse_+3A_model">model</code></td>
<td>
<p>Model can be a character, or a rxode2 model.  It needs
to have normalized syntax, that is <code>if (...){}</code> has to be
on the same line.  The <code style="white-space: pre;">&#8288;else&#8288;</code> statement must be on its
own line with the closing bracket of the <code>if</code> statement
on the previous line.  This <code style="white-space: pre;">&#8288;else&#8288;</code> statment must also
contain the opening bracket, like the code <code style="white-space: pre;">&#8288;else {}&#8288;</code></p>
</td></tr>
<tr><td><code id="rxExpandIfElse_+3A_removeinis">removeInis</code></td>
<td>
<p>A boolean indicating if parameter
initializations should be removed from the model.</p>
</td></tr>
<tr><td><code id="rxExpandIfElse_+3A_removeprint">removePrint</code></td>
<td>
<p>A boolean indicating if printing statements
should be removed from the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named character vector. The names of the vector are the
logical conditions, the values are the lines that satisfy the
logical conditions.
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxExpandSens_'>Expand sensitivity</h2><span id='topic+rxExpandSens_'></span>

<h3>Description</h3>

<p>Expand sensitivity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxExpandSens_(state, calcSens)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxExpandSens__+3A_state">state</code></td>
<td>
<p>is the state to expand</p>
</td></tr>
<tr><td><code id="rxExpandSens__+3A_calcsens">calcSens</code></td>
<td>
<p>is the variables to calculate sensitivity</p>
</td></tr>
</table>


<h3>Value</h3>

<p>symengine string for expanded sensitivity
</p>

<hr>
<h2 id='rxExpandSens2_'>Expand second order sensitivity</h2><span id='topic+rxExpandSens2_'></span>

<h3>Description</h3>

<p>Expand second order sensitivity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxExpandSens2_(state, s1, s2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxExpandSens2__+3A_state">state</code></td>
<td>
<p>is the state to expand</p>
</td></tr>
<tr><td><code id="rxExpandSens2__+3A_s1">s1</code></td>
<td>
<p>is the variables to calculate sensitivity</p>
</td></tr>
<tr><td><code id="rxExpandSens2__+3A_s2">s2</code></td>
<td>
<p>is the variables to calculate second order sensitivity</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string for symengine second order sensitivity
</p>

<hr>
<h2 id='rxf'>Simulate F variable from threefry generator</h2><span id='topic+rxf'></span>

<h3>Description</h3>

<p>Care should be taken with this method not to encounter the
birthday problem, described
<a href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/">https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/</a>.
Since the <code>sitmo</code> <code>threefry</code>, this currently generates
one random deviate from the uniform distribution to seed the
engine <code>threefry</code> and then run the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxf(df1, df2, n = 1L, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxf_+3A_df1">df1</code>, <code id="rxf_+3A_df2">df2</code></td>
<td>
<p>degrees of freedom.  <code>Inf</code> is allowed.</p>
</td></tr>
<tr><td><code id="rxf_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="rxf_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the simulation
</p>
<p><code>rxnorm</code> simulates using the threefry sitmo generator.
</p>
<p><code>rxnormV</code> used to simulate with the vandercorput simulator, but
since it didn't satisfy the normal properties it was changed to simple be
an alias of <code>rxnorm</code>. It is no longer supported in <code>rxode2({})</code> blocks</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Therefore, a simple call to the random number generated followed by a second
call to random number generated may have identical seeds.  As the number of
random number generator calls are increased the probability that the
birthday problem will increase.
</p>
<p>The key to avoid this problem is to either run all simulations in the
<code>rxode2</code> environment once (therefore one seed or series of seeds
for the whole simulation), pre-generate all random variables
used for the simulation, or seed the rxode2 engine with <code>rxSetSeed()</code>
</p>
<p>Internally each ID is seeded with a unique number so that the
results do not depend on the number of cores used.
</p>


<h3>Value</h3>

<p>f random deviates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Use threefry engine

rxf(0.5, 0.5, n = 10) # with rxf you have to explicitly state n
rxf(5, 1, n = 10, ncores = 2) # You can parallelize the simulation using openMP

rxf(1, 3)


## This example uses `rxf` directly in the model

rx &lt;- function() {
  model({
    a &lt;- rxf(2, 2)
  })
}

et &lt;- et(1, id = 1:2)

s &lt;- rxSolve(rx, et)


</code></pre>

<hr>
<h2 id='rxForget'>Clear memoise cache for rxode2</h2><span id='topic+rxForget'></span>

<h3>Description</h3>

<p>Clear memoise cache for rxode2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxForget()
</code></pre>


<h3>Value</h3>

<p>nothing; called for side effects
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxFun'>Add/Create C functions for use in rxode2</h2><span id='topic+rxFun'></span><span id='topic+rxRmFun'></span>

<h3>Description</h3>

<p>Add/Create C functions for use in rxode2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxFun(name, args, cCode)

rxRmFun(name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxFun_+3A_name">name</code></td>
<td>
<p>This can either give the name of the user function or
be a simple R function that you wish to convert to C.  If you
have rxode2 convert the R function to C, the name of the function
will match the function name provided and the number of arguments
will match the R function provided.  Hence, if you are providing
an R function for conversion to C, the rest of the arguments are
implied.</p>
</td></tr>
<tr><td><code id="rxFun_+3A_args">args</code></td>
<td>
<p>This gives the arguments of the user function</p>
</td></tr>
<tr><td><code id="rxFun_+3A_ccode">cCode</code></td>
<td>
<p>This is the C-code for the new function</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## Right now rxode2 is not aware of the function fun
## Therefore it cannot translate it to symengine or
## Compile a model with it.

try(rxode2("a=fun(a,b,c)"))

## Note for this approach to work, it cannot interfere with C
## function names or reserved rxode2 special terms.  Therefore
## f(x) would not work since f is an alias for bioavailability.

fun &lt;- "
double fun(double a, double b, double c) {
  return a*a+b*a+c;
}
" ## C-code for function

rxFun("fun", c("a", "b", "c"), fun) ## Added function

## Now rxode2 knows how to translate this function to symengine

rxToSE("fun(a,b,c)")

## And will take a central difference when calculating derivatives

rxFromSE("Derivative(fun(a,b,c),a)")

## Of course, you could specify the derivative table manually
rxD("fun", list(
  function(a, b, c) {
    paste0("2*", a, "+", b)
  },
  function(a, b, c) {
    return(a)
  },
  function(a, b, c) {
    return("0.0")
  }
))

rxFromSE("Derivative(fun(a,b,c),a)")

# You can also remove the functions by `rxRmFun`

rxRmFun("fun")

# you can also use R functions directly in rxode2


gg &lt;- function(x, y) {
  x + y
}

f &lt;- rxode2({
 z = gg(x, y)
})


e &lt;- et(1:10) |&gt; as.data.frame()

e$x &lt;- 1:10
e$y &lt;- 21:30

rxSolve(f, e)

# Note that since it touches R, it can only run single-threaded.
# There are also requirements for the function:
#
# 1. It accepts one value per argument (numeric)
#
# 2. It returns one numeric value

# If it is a simple function (like gg) you can also convert it to C
# using rxFun and load it into rxode2

rxFun(gg)

rxSolve(f, e)

# to stop the recompile simply reassign the function
f &lt;- rxode2(f)

rxSolve(f, e)

rxRmFun("gg")
rm(gg)
rm(f)


# You can also automatically convert a R function to R code (and
# calculate first derivatives)

fun &lt;- function(a, b, c) {
  a^2+b*a+c
}

rxFun(fun)

# You can see the R code if you want with rxC

message(rxC("fun"))

# you can also remove both the function and the
# derivatives with rxRmFun("fun")

rxRmFun("fun")



</code></pre>

<hr>
<h2 id='rxgamma'>Simulate gamma variable from threefry generator</h2><span id='topic+rxgamma'></span>

<h3>Description</h3>

<p>Care should be taken with this method not to encounter the
birthday problem, described
<a href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/">https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/</a>.
Since the <code>sitmo</code> <code>threefry</code>, this currently generates
one random deviate from the uniform distribution to seed the
engine <code>threefry</code> and then run the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxgamma(shape, rate = 1, n = 1L, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxgamma_+3A_shape">shape</code></td>
<td>
<p>The shape of the gamma random variable</p>
</td></tr>
<tr><td><code id="rxgamma_+3A_rate">rate</code></td>
<td>
<p>an alternative way to specify the scale.</p>
</td></tr>
<tr><td><code id="rxgamma_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="rxgamma_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the simulation
</p>
<p><code>rxnorm</code> simulates using the threefry sitmo generator.
</p>
<p><code>rxnormV</code> used to simulate with the vandercorput simulator, but
since it didn't satisfy the normal properties it was changed to simple be
an alias of <code>rxnorm</code>. It is no longer supported in <code>rxode2({})</code> blocks</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Therefore, a simple call to the random number generated followed by a second
call to random number generated may have identical seeds.  As the number of
random number generator calls are increased the probability that the
birthday problem will increase.
</p>
<p>The key to avoid this problem is to either run all simulations in the
<code>rxode2</code> environment once (therefore one seed or series of seeds
for the whole simulation), pre-generate all random variables
used for the simulation, or seed the rxode2 engine with <code>rxSetSeed()</code>
</p>
<p>Internally each ID is seeded with a unique number so that the
results do not depend on the number of cores used.
</p>


<h3>Value</h3>

<p>gamma random deviates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


## Use threefry engine

rxgamma(0.5, n = 10) # with rxgamma you have to explicitly state n
rxgamma(5, n = 10, ncores = 2) # You can parallelize the simulation using openMP

rxgamma(1)


## This example uses `rxbeta` directly in the model

rx &lt;- function() {
  model({
    a &lt;- rxgamma(2)
  })
}

et &lt;- et(1, id = 1:2)

s &lt;- rxSolve(rx, et)


</code></pre>

<hr>
<h2 id='rxgeom'>Simulate geometric variable from threefry generator</h2><span id='topic+rxgeom'></span>

<h3>Description</h3>

<p>Care should be taken with this method not to encounter the
birthday problem, described
<a href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/">https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/</a>.
Since the <code>sitmo</code> <code>threefry</code>, this currently generates
one random deviate from the uniform distribution to seed the
engine <code>threefry</code> and then run the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxgeom(prob, n = 1L, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxgeom_+3A_prob">prob</code></td>
<td>
<p>probability of success in each trial. <code>0 &lt; prob &lt;= 1</code>.</p>
</td></tr>
<tr><td><code id="rxgeom_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="rxgeom_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the simulation
</p>
<p><code>rxnorm</code> simulates using the threefry sitmo generator.
</p>
<p><code>rxnormV</code> used to simulate with the vandercorput simulator, but
since it didn't satisfy the normal properties it was changed to simple be
an alias of <code>rxnorm</code>. It is no longer supported in <code>rxode2({})</code> blocks</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Therefore, a simple call to the random number generated followed by a second
call to random number generated may have identical seeds.  As the number of
random number generator calls are increased the probability that the
birthday problem will increase.
</p>
<p>The key to avoid this problem is to either run all simulations in the
<code>rxode2</code> environment once (therefore one seed or series of seeds
for the whole simulation), pre-generate all random variables
used for the simulation, or seed the rxode2 engine with <code>rxSetSeed()</code>
</p>
<p>Internally each ID is seeded with a unique number so that the
results do not depend on the number of cores used.
</p>


<h3>Value</h3>

<p>geometric random deviates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Use threefry engine

rxgeom(0.5, n = 10) # with rxgeom you have to explicitly state n
rxgeom(0.25, n = 10, ncores = 2) # You can parallelize the simulation using openMP

rxgeom(0.75)


## This example uses `rxgeom` directly in the model

rx &lt;- function() {
  model({
    a &lt;- rxgeom(0.24)
  })
}

et &lt;- et(1, id = 1:2)

s &lt;- rxSolve(rx, et)


</code></pre>

<hr>
<h2 id='rxGetControl'>rxGetControl option from ui</h2><span id='topic+rxGetControl'></span>

<h3>Description</h3>

<p>rxGetControl option from ui
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxGetControl(ui, option, default)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxGetControl_+3A_ui">ui</code></td>
<td>
<p>rxode2 ui object</p>
</td></tr>
<tr><td><code id="rxGetControl_+3A_option">option</code></td>
<td>
<p>Option to get</p>
</td></tr>
<tr><td><code id="rxGetControl_+3A_default">default</code></td>
<td>
<p>Default value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Option (if present) or default value
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxGetDistributionSimulationLines'>This is a S3 method for getting the distribution lines for a rxode2 simulation</h2><span id='topic+rxGetDistributionSimulationLines'></span><span id='topic+rxGetDistributionSimulationLines.norm'></span><span id='topic+rxGetDistributionSimulationLines.dnorm'></span><span id='topic+rxGetDistributionSimulationLines.t'></span><span id='topic+rxGetDistributionSimulationLines.cauchy'></span><span id='topic+rxGetDistributionSimulationLines.ordinal'></span><span id='topic+rxGetDistributionSimulationLines.default'></span><span id='topic+rxGetDistributionSimulationLines.rxUi'></span>

<h3>Description</h3>

<p>This is a S3 method for getting the distribution lines for a rxode2 simulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxGetDistributionSimulationLines(line)

## S3 method for class 'norm'
rxGetDistributionSimulationLines(line)

## S3 method for class 'dnorm'
rxGetDistributionSimulationLines(line)

## S3 method for class 't'
rxGetDistributionSimulationLines(line)

## S3 method for class 'cauchy'
rxGetDistributionSimulationLines(line)

## S3 method for class 'ordinal'
rxGetDistributionSimulationLines(line)

## Default S3 method:
rxGetDistributionSimulationLines(line)

## S3 method for class 'rxUi'
rxGetDistributionSimulationLines(line)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxGetDistributionSimulationLines_+3A_line">line</code></td>
<td>
<p>Parsed rxode2 model environment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Lines for the simulation of <code>ipred</code> and <code>dv</code>. This is based
on the idea that the focei parameters are defined
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='rxGetLin'>Get the linear compartment model true function</h2><span id='topic+rxGetLin'></span>

<h3>Description</h3>

<p>Get the linear compartment model true function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxGetLin(
  model,
  linCmtSens = c("linCmtA", "linCmtB", "linCmtC"),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxGetLin_+3A_model">model</code></td>
<td>
<p>This is the ODE model specification.  It can be:
</p>

<ul>
<li><p> a string containing the set of ordinary differential
equations (ODE) and other expressions defining the changes in
the dynamic system.
</p>
</li>
<li><p> a file name where the ODE system equation is contained
</p>
</li></ul>

<p>An ODE expression enclosed in <code style="white-space: pre;">&#8288;\{\}&#8288;</code>
</p>
<p>(see also the <code>filename</code> argument). For
details, see the sections &ldquo;Details&rdquo; and
<code style="white-space: pre;">&#8288;rxode2 Syntax&#8288;</code> below.</p>
</td></tr>
<tr><td><code id="rxGetLin_+3A_lincmtsens">linCmtSens</code></td>
<td>
<p>The method to calculate the linCmt() solutions</p>
</td></tr>
<tr><td><code id="rxGetLin_+3A_verbose">verbose</code></td>
<td>
<p>When <code>TRUE</code> be verbose with the linear
compartmental model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>model with linCmt() replaced with linCmtA()
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='rxGetModel'>Get model properties without compiling it.</h2><span id='topic+rxGetModel'></span>

<h3>Description</h3>

<p>Get model properties without compiling it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxGetModel(
  model,
  calcSens = NULL,
  calcJac = NULL,
  collapseModel = NULL,
  indLin = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxGetModel_+3A_model">model</code></td>
<td>
<p>rxode2 specification</p>
</td></tr>
<tr><td><code id="rxGetModel_+3A_calcsens">calcSens</code></td>
<td>
<p>boolean indicating if rxode2 will calculate the
sensitivities according to the specified ODEs.</p>
</td></tr>
<tr><td><code id="rxGetModel_+3A_calcjac">calcJac</code></td>
<td>
<p>boolean indicating if rxode2 will calculate the
Jacobain according to the specified ODEs.</p>
</td></tr>
<tr><td><code id="rxGetModel_+3A_collapsemodel">collapseModel</code></td>
<td>
<p>boolean indicating if rxode2 will remove all
LHS variables when calculating sensitivities.</p>
</td></tr>
<tr><td><code id="rxGetModel_+3A_indlin">indLin</code></td>
<td>
<p>Calculate inductive linearization matrices and
compile with inductive linearization support.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rxode2 trans list
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxGetrxode2'>Get rxode2 model from object</h2><span id='topic+rxGetrxode2'></span>

<h3>Description</h3>

<p>Get rxode2 model from object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxGetrxode2(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxGetrxode2_+3A_obj">obj</code></td>
<td>
<p>rxode2 family of objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rxode2 model
</p>

<hr>
<h2 id='rxHtml'>Format rxSolve and related objects as html.</h2><span id='topic+rxHtml'></span><span id='topic+rxHtml.rxSolve'></span>

<h3>Description</h3>

<p>Format rxSolve and related objects as html.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxHtml(x, ...)

## S3 method for class 'rxSolve'
rxHtml(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxHtml_+3A_x">x</code></td>
<td>
<p>rxode2 object</p>
</td></tr>
<tr><td><code id="rxHtml_+3A_...">...</code></td>
<td>
<p>Extra arguments sent to kable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>html code for rxSolve object
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxIndLin_'>Inductive linearization solver</h2><span id='topic+rxIndLin_'></span>

<h3>Description</h3>

<p>Inductive linearization solver
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxIndLin__+3A_csub">cSub</code></td>
<td>
<p>= Current subject number</p>
</td></tr>
<tr><td><code id="rxIndLin__+3A_op">op</code></td>
<td>

<ul>
<li><p> rxode2 solving options
</p>
</li></ul>
</td></tr>
<tr><td><code id="rxIndLin__+3A_tp">tp</code></td>
<td>

<ul>
<li><p> Prior time point/time zero
</p>
</li></ul>
</td></tr>
<tr><td><code id="rxIndLin__+3A_yp">yp</code></td>
<td>

<ul>
<li><p> Prior state;  vector size = neq; Final state is updated here
</p>
</li></ul>
</td></tr>
<tr><td><code id="rxIndLin__+3A_tf">tf</code></td>
<td>

<ul>
<li><p> Final Time
</p>
</li></ul>
</td></tr>
<tr><td><code id="rxIndLin__+3A_infusionrate">InfusionRate</code></td>
<td>
<p>= Rates of each compartment;  vector size = neq</p>
</td></tr>
<tr><td><code id="rxIndLin__+3A_on">on</code></td>
<td>
<p>Indicator for if the compartment is &quot;on&quot;</p>
</td></tr>
<tr><td><code id="rxIndLin__+3A_cache">cache</code></td>
<td>
<p>0 = no Cache
When doIndLin == 0, cache &gt; 0 = nInf-1</p>
</td></tr>
<tr><td><code id="rxIndLin__+3A_me">ME</code></td>
<td>
<p>the rxode2 matrix exponential function</p>
</td></tr>
<tr><td><code id="rxIndLin__+3A_indf">IndF</code></td>
<td>
<p>The rxode2 Inductive Linearization function F</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a status for solving
</p>
<p>1 = Successful solve
</p>
<p>-1 = Maximum number of iterations reached when doing
inductive linearization
</p>

<hr>
<h2 id='rxIndLinState'>Set the preferred factoring by state</h2><span id='topic+rxIndLinState'></span>

<h3>Description</h3>

<p>Set the preferred factoring by state
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxIndLinState(preferred = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxIndLinState_+3A_preferred">preferred</code></td>
<td>
<p>A list of each state's preferred factorization</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='rxIndLinStrategy'>This sets the inductive linearization strategy for matrix building</h2><span id='topic+rxIndLinStrategy'></span>

<h3>Description</h3>

<p>When there is more than one state in a ODE that cannot be
separated this specifies how it is incorporated into the matrix
exponential.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxIndLinStrategy(strategy = c("curState", "split"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxIndLinStrategy_+3A_strategy">strategy</code></td>
<td>
<p>The strategy for inductive linearization matrix building
</p>

<ul>
<li> <p><code>curState</code> Prefer parameterizing in terms of the current
state, followed by the first state observed in the term.
</p>
</li>
<li> <p><code>split</code> Split the parameterization between all states in the
term by dividing each by the number of states in the term and then
adding a matrix term for each state.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxInits'>Initial Values and State values for a rxode2 object</h2><span id='topic+rxInits'></span><span id='topic+rxInit'></span>

<h3>Description</h3>

<p>Returns the initial values of the rxDll object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxInits(
  obj,
  vec = NULL,
  req = NULL,
  defaultValue = 0,
  noerror = FALSE,
  noini = FALSE,
  rxLines = FALSE
)

rxInit(
  obj,
  vec = NULL,
  req = NULL,
  defaultValue = 0,
  noerror = FALSE,
  noini = FALSE,
  rxLines = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxInits_+3A_obj">obj</code></td>
<td>
<p>rxDll, rxode2, or named vector representing default
initial arguments</p>
</td></tr>
<tr><td><code id="rxInits_+3A_vec">vec</code></td>
<td>
<p>If supplied, named vector for the model.</p>
</td></tr>
<tr><td><code id="rxInits_+3A_req">req</code></td>
<td>
<p>Required names, and the required order for the ODE solver</p>
</td></tr>
<tr><td><code id="rxInits_+3A_defaultvalue">defaultValue</code></td>
<td>
<p>a number or NA representing the default value for
parameters missing in <code>vec</code>, but required in <code>req</code>.</p>
</td></tr>
<tr><td><code id="rxInits_+3A_noerror">noerror</code></td>
<td>
<p>is a boolean specifying if an error should be thrown
for missing parameter values when <code>default</code> = <code>NA</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Initial values of the rxDll object
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>


<h3>See Also</h3>

<p>Other Query model information: 
<code><a href="#topic+rxDfdy">rxDfdy</a>()</code>,
<code><a href="#topic+rxLhs">rxLhs</a>()</code>,
<code><a href="#topic+rxModelVars">rxModelVars</a>()</code>,
<code><a href="#topic+rxParams">rxParams</a>()</code>,
<code><a href="#topic+rxState">rxState</a>()</code>
</p>

<hr>
<h2 id='rxInv'>Invert matrix using RcppArmadillo.</h2><span id='topic+rxInv'></span>

<h3>Description</h3>

<p>Invert matrix using RcppArmadillo.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxInv(matrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxInv_+3A_matrix">matrix</code></td>
<td>
<p>matrix to be inverted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>inverse or pseudo inverse of matrix.
</p>

<hr>
<h2 id='rxIs'>Check the type of an object using Rcpp</h2><span id='topic+rxIs'></span>

<h3>Description</h3>

<p>Check the type of an object using Rcpp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxIs(obj, cls)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxIs_+3A_obj">obj</code></td>
<td>
<p>Object to check</p>
</td></tr>
<tr><td><code id="rxIs_+3A_cls">cls</code></td>
<td>
<p>Type of class.  Only s3 classes for lists/environments and primitive classes are checked.
For matrix types they are distinguished as <code>numeric.matrix</code>, <code>integer.matrix</code>,
<code>logical.matrix</code>, and <code>character.matrix</code> as well as the traditional <code>matrix</code>
class. Additionally checks for <code>event.data.frame</code> which is an <code>data.frame</code> object
with <code>time</code>,  <code>evid</code> and <code>amt</code>. (UPPER, lower or Title cases accepted)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean indicating if the object is a member of the class.
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxIsCurrent'>Checks if the rxode2 object was built with the current build</h2><span id='topic+rxIsCurrent'></span>

<h3>Description</h3>

<p>Checks if the rxode2 object was built with the current build
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxIsCurrent(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxIsCurrent_+3A_obj">obj</code></td>
<td>
<p>rxode2 family of objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boolean indicating if this was built with current rxode2
</p>

<hr>
<h2 id='rxIsLoaded'>Determine if the DLL associated with the rxode2 object is loaded</h2><span id='topic+rxIsLoaded'></span><span id='topic+rxDllLoaded'></span>

<h3>Description</h3>

<p>Determine if the DLL associated with the rxode2 object is loaded
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxIsLoaded(obj)

rxDllLoaded(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxIsLoaded_+3A_obj">obj</code></td>
<td>
<p>A rxode2 family of objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean returning if the rxode2 library is loaded.
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>

<hr>
<h2 id='rxLhs'>Left handed Variables</h2><span id='topic+rxLhs'></span>

<h3>Description</h3>

<p>This returns the model calculated variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxLhs(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxLhs_+3A_obj">obj</code></td>
<td>
<p>rxode2 family of objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector listing the calculated parameters
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rxode2">rxode2</a></code>
</p>
<p>Other Query model information: 
<code><a href="#topic+rxDfdy">rxDfdy</a>()</code>,
<code><a href="#topic+rxInits">rxInits</a>()</code>,
<code><a href="#topic+rxModelVars">rxModelVars</a>()</code>,
<code><a href="#topic+rxParams">rxParams</a>()</code>,
<code><a href="#topic+rxState">rxState</a>()</code>
</p>

<hr>
<h2 id='rxLock'>Lock/unlocking of rxode2 dll file</h2><span id='topic+rxLock'></span><span id='topic+rxUnlock'></span>

<h3>Description</h3>

<p>Lock/unlocking of rxode2 dll file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxLock(obj)

rxUnlock(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxLock_+3A_obj">obj</code></td>
<td>
<p>A rxode2 family of objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing; called for side effects
</p>

<hr>
<h2 id='rxMd5'>Return the md5 of an rxode2 object or file</h2><span id='topic+rxMd5'></span>

<h3>Description</h3>

<p>This md5 is based on the model and possibly the extra c code
supplied for the model.  In addition the md5 is based on syntax
options, compiled rxode2 library md5, and the rxode2
version/repository.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxMd5(model, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxMd5_+3A_model">model</code></td>
<td>
<p>This is the ODE model specification.  It can be:
</p>

<ul>
<li><p> a string containing the set of ordinary differential
equations (ODE) and other expressions defining the changes in
the dynamic system.
</p>
</li>
<li><p> a file name where the ODE system equation is contained
</p>
</li></ul>

<p>An ODE expression enclosed in <code style="white-space: pre;">&#8288;\{\}&#8288;</code>
</p>
<p>(see also the <code>filename</code> argument). For
details, see the sections &ldquo;Details&rdquo; and
<code style="white-space: pre;">&#8288;rxode2 Syntax&#8288;</code> below.</p>
</td></tr>
<tr><td><code id="rxMd5_+3A_...">...</code></td>
<td>
<p>ignored arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If this is a rxode2 object, return a named list:
</p>

<ul>
<li> <p><code>file_md5</code> is the model's file's md5
</p>
</li>
<li> <p><code>parsed_md5</code>  is the parsed model's file's md5.
</p>
</li></ul>

<p>Otherwise return the md5 based on the arguments provided
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>

<hr>
<h2 id='rxModels_'>Get the rxModels  information</h2><span id='topic+rxModels_'></span>

<h3>Description</h3>

<p>Get the rxModels  information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxModels_(env = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxModels__+3A_env">env</code></td>
<td>
<p>boolean that returns the environment where models are stored (TRUE), or the currently assigned rxode2 model variables (FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>internal rxModels information environment
</p>

<hr>
<h2 id='rxModelVars'>All model variables for a rxode2 object</h2><span id='topic+rxModelVars'></span><span id='topic+rxModelVarsS3'></span><span id='topic+rxModelVarsS3.rxUi'></span><span id='topic+rxModelVarsS3.default'></span>

<h3>Description</h3>

<p>Return all the known model variables for a specified rxode2 object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxModelVars(obj)

rxModelVarsS3(obj)

## S3 method for class 'rxUi'
rxModelVarsS3(obj)

## Default S3 method:
rxModelVarsS3(obj)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxModelVars_+3A_obj">obj</code></td>
<td>
<p>rxode2 family of objects</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These items are only calculated after compilation; they are
built-into the rxode2 compiled DLL.
</p>
<p>To allow extension, an s3 hook is added in the function <code>rxModelVarsS3</code>.
</p>


<h3>Value</h3>

<p>A list of rxode2 model properties including:
</p>

<ul>
<li> <p><code>params</code>  a character vector of names of the model parameters
</p>
</li>
<li> <p><code>lhs</code> a character vector of the names of the model calculated parameters
</p>
</li>
<li> <p><code>state</code> a character vector of the compartments in rxode2 object
</p>
</li>
<li> <p><code>trans</code> a named vector of translated model properties
including what type of jacobian is specified, the <code>C</code> function prefixes,
as well as the <code>C</code> functions names to be called through the compiled model.
</p>
</li>
<li> <p><code>md5</code> a named vector that gives the digest of the model (<code>file_md5</code>) and the parsed model
(<code>parsed_md5</code>)
</p>
</li>
<li> <p><code>model</code>  a named vector giving the input model (<code>model</code>),
normalized model (no comments and standard syntax for parsing, <code>normModel</code>),
and interim code that is used to generate the final C file <code>parseModel</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>See Also</h3>

<p>Other Query model information: 
<code><a href="#topic+rxDfdy">rxDfdy</a>()</code>,
<code><a href="#topic+rxInits">rxInits</a>()</code>,
<code><a href="#topic+rxLhs">rxLhs</a>()</code>,
<code><a href="#topic+rxParams">rxParams</a>()</code>,
<code><a href="#topic+rxState">rxState</a>()</code>
</p>

<hr>
<h2 id='rxnbinom'>Simulate Binomial variable from threefry generator</h2><span id='topic+rxnbinom'></span><span id='topic+rxnbinomMu'></span>

<h3>Description</h3>

<p>Care should be taken with this method not to encounter the
birthday problem, described
<a href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/">https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/</a>.
Since the <code>sitmo</code> <code>threefry</code>, this currently generates
one random deviate from the uniform distribution to seed the
engine <code>threefry</code> and then run the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxnbinom(size, prob, n = 1L, ncores = 1L)

rxnbinomMu(size, mu, n = 1L, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxnbinom_+3A_size">size</code></td>
<td>
<p>target for number of successful trials, or dispersion
parameter (the shape parameter of the gamma mixing distribution).
Must be strictly positive, need not be integer.</p>
</td></tr>
<tr><td><code id="rxnbinom_+3A_prob">prob</code></td>
<td>
<p>probability of success in each trial. <code>0 &lt; prob &lt;= 1</code>.</p>
</td></tr>
<tr><td><code id="rxnbinom_+3A_n">n</code></td>
<td>
<p>number of observations.  If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="rxnbinom_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the simulation
</p>
<p><code>rxnorm</code> simulates using the threefry sitmo generator.
</p>
<p><code>rxnormV</code> used to simulate with the vandercorput simulator, but
since it didn't satisfy the normal properties it was changed to simple be
an alias of <code>rxnorm</code>. It is no longer supported in <code>rxode2({})</code> blocks</p>
</td></tr>
<tr><td><code id="rxnbinom_+3A_mu">mu</code></td>
<td>
<p>alternative parametrization via mean: see &lsquo;Details&rsquo;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Therefore, a simple call to the random number generated followed by a second
call to random number generated may have identical seeds.  As the number of
random number generator calls are increased the probability that the
birthday problem will increase.
</p>
<p>The key to avoid this problem is to either run all simulations in the
<code>rxode2</code> environment once (therefore one seed or series of seeds
for the whole simulation), pre-generate all random variables
used for the simulation, or seed the rxode2 engine with <code>rxSetSeed()</code>
</p>
<p>Internally each ID is seeded with a unique number so that the
results do not depend on the number of cores used.
</p>


<h3>Value</h3>

<p>negative binomial random deviates. Note that <code>rxbinom2</code>
uses the <code>mu</code> parameterization an the <code>rxbinom</code> uses the <code>prob</code>
parameterization (<code>mu=size/(prob+size)</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Use threefry engine

rxnbinom(10, 0.9, n = 10) # with rxbinom you have to explicitly state n
rxnbinom(3, 0.5, n = 10, ncores = 2) # You can parallelize the simulation using openMP

rxnbinom(4, 0.7)

# use mu parameter
rxnbinomMu(40, 40, n=10)

## This example uses `rxbinom` directly in the model

rx &lt;- function() {
  model({
    a &lt;- rxnbinom(10, 0.5)
  })
}

et &lt;- et(1, id = 1:100)

s &lt;- rxSolve(rx, et)

rx &lt;- function() {
  model({
    a &lt;- rxnbinomMu(10, 40)
  })
}

s &lt;- rxSolve(rx, et)

</code></pre>

<hr>
<h2 id='rxNorm'>Get the normalized model</h2><span id='topic+rxNorm'></span>

<h3>Description</h3>

<p>This get the syntax preferred model for processing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxNorm(obj, condition = NULL, removeInis, removeJac, removeSens)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxNorm_+3A_obj">obj</code></td>
<td>
<p>rxode2 family of objects</p>
</td></tr>
<tr><td><code id="rxNorm_+3A_condition">condition</code></td>
<td>
<p>Character string of a logical condition to use
for subsetting the normalized model.  When missing, and a
condition is not set via <code>rxCondition</code>, return the whole
code with all the conditional settings intact.  When a condition
is set with <code>rxCondition</code>, use that condition.</p>
</td></tr>
<tr><td><code id="rxNorm_+3A_removeinis">removeInis</code></td>
<td>
<p>A boolean indicating if parameter initialization
will be removed from the model</p>
</td></tr>
<tr><td><code id="rxNorm_+3A_removejac">removeJac</code></td>
<td>
<p>A boolean indicating if the Jacobians will be
removed.</p>
</td></tr>
<tr><td><code id="rxNorm_+3A_removesens">removeSens</code></td>
<td>
<p>A boolean indicating if the sensitivities will
be removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Normalized Normal syntax (no comments)
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxnormV'>Simulate random normal variable from threefry generator</h2><span id='topic+rxnormV'></span><span id='topic+rxnorm'></span>

<h3>Description</h3>

<p>Simulate random normal variable from threefry generator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxnormV(mean = 0, sd = 1, n = 1L, ncores = 1L)

rxnorm(mean = 0, sd = 1, n = 1L, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxnormV_+3A_mean">mean</code></td>
<td>
<p>vector of means.</p>
</td></tr>
<tr><td><code id="rxnormV_+3A_sd">sd</code></td>
<td>
<p>vector of standard deviations.</p>
</td></tr>
<tr><td><code id="rxnormV_+3A_n">n</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code id="rxnormV_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the simulation
</p>
<p><code>rxnorm</code> simulates using the threefry sitmo generator.
</p>
<p><code>rxnormV</code> used to simulate with the vandercorput simulator, but
since it didn't satisfy the normal properties it was changed to simple be
an alias of <code>rxnorm</code>. It is no longer supported in <code>rxode2({})</code> blocks</p>
</td></tr>
</table>


<h3>Value</h3>

<p>normal random number deviates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Use threefry engine

rxnorm(n = 10) # with rxnorm you have to explicitly state n
rxnorm(n = 10, ncores = 2) # You can parallelize the simulation using openMP

rxnorm(2, 3) ## The first 2 arguments are the mean and standard deviation


## This example uses `rxnorm` directly in the model

rx &lt;- function() {
  model({
    a &lt;- rxnorm()
  })
}

et &lt;- et(1, id = 1:2)

s &lt;- rxSolve(rx, et)


</code></pre>

<hr>
<h2 id='rxode2'>Create an ODE-based model specification</h2><span id='topic+rxode2'></span><span id='topic+RxODE'></span><span id='topic+rxode'></span>

<h3>Description</h3>

<p>Create a dynamic ODE-based model object suitably for translation
into fast C code
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxode2(
  model,
  modName = basename(wd),
  wd = getwd(),
  filename = NULL,
  extraC = NULL,
  debug = FALSE,
  calcJac = NULL,
  calcSens = NULL,
  collapseModel = FALSE,
  package = NULL,
  ...,
  linCmtSens = c("linCmtA", "linCmtB", "linCmtC"),
  indLin = FALSE,
  verbose = FALSE,
  fullPrint = getOption("rxode2.fullPrint", FALSE),
  envir = parent.frame()
)

RxODE(
  model,
  modName = basename(wd),
  wd = getwd(),
  filename = NULL,
  extraC = NULL,
  debug = FALSE,
  calcJac = NULL,
  calcSens = NULL,
  collapseModel = FALSE,
  package = NULL,
  ...,
  linCmtSens = c("linCmtA", "linCmtB", "linCmtC"),
  indLin = FALSE,
  verbose = FALSE,
  fullPrint = getOption("rxode2.fullPrint", FALSE),
  envir = parent.frame()
)

rxode(
  model,
  modName = basename(wd),
  wd = getwd(),
  filename = NULL,
  extraC = NULL,
  debug = FALSE,
  calcJac = NULL,
  calcSens = NULL,
  collapseModel = FALSE,
  package = NULL,
  ...,
  linCmtSens = c("linCmtA", "linCmtB", "linCmtC"),
  indLin = FALSE,
  verbose = FALSE,
  fullPrint = getOption("rxode2.fullPrint", FALSE),
  envir = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxode2_+3A_model">model</code></td>
<td>
<p>This is the ODE model specification.  It can be:
</p>

<ul>
<li><p> a string containing the set of ordinary differential
equations (ODE) and other expressions defining the changes in
the dynamic system.
</p>
</li>
<li><p> a file name where the ODE system equation is contained
</p>
</li></ul>

<p>An ODE expression enclosed in <code style="white-space: pre;">&#8288;\{\}&#8288;</code>
</p>
<p>(see also the <code>filename</code> argument). For
details, see the sections &ldquo;Details&rdquo; and
<code style="white-space: pre;">&#8288;rxode2 Syntax&#8288;</code> below.</p>
</td></tr>
<tr><td><code id="rxode2_+3A_modname">modName</code></td>
<td>
<p>a string to be used as the model name. This string
is used for naming various aspects of the computations,
including generating C symbol names, dynamic libraries,
etc. Therefore, it is necessary that <code>modName</code> consists of
simple ASCII alphanumeric characters starting with a letter.</p>
</td></tr>
<tr><td><code id="rxode2_+3A_wd">wd</code></td>
<td>
<p>character string with a working directory where to
create a subdirectory according to <code>modName</code>. When
specified, a subdirectory named after the
&ldquo;<code>modName.d</code>&rdquo; will be created and populated with a
C file, a dynamic loading library, plus various other working
files. If missing, the files are created (and removed) in the
temporary directory, and the rxode2 DLL for the model is
created in the current directory named <code style="white-space: pre;">&#8288;rx_????_platform&#8288;</code>, for
example <code>rx_129f8f97fb94a87ca49ca8dafe691e1e_i386.dll</code></p>
</td></tr>
<tr><td><code id="rxode2_+3A_filename">filename</code></td>
<td>
<p>A file name or connection object where the
ODE-based model specification resides. Only one of <code>model</code>
or <code>filename</code> may be specified.</p>
</td></tr>
<tr><td><code id="rxode2_+3A_extrac">extraC</code></td>
<td>
<p>Extra c code to include in the model.  This can be
useful to specify functions in the model.  These C functions
should usually take <code>double</code> precision arguments, and
return <code>double</code> precision values.</p>
</td></tr>
<tr><td><code id="rxode2_+3A_debug">debug</code></td>
<td>
<p>is a boolean indicating if the executable should be
compiled with verbose debugging information turned on.</p>
</td></tr>
<tr><td><code id="rxode2_+3A_calcjac">calcJac</code></td>
<td>
<p>boolean indicating if rxode2 will calculate the
Jacobain according to the specified ODEs.</p>
</td></tr>
<tr><td><code id="rxode2_+3A_calcsens">calcSens</code></td>
<td>
<p>boolean indicating if rxode2 will calculate the
sensitivities according to the specified ODEs.</p>
</td></tr>
<tr><td><code id="rxode2_+3A_collapsemodel">collapseModel</code></td>
<td>
<p>boolean indicating if rxode2 will remove all
LHS variables when calculating sensitivities.</p>
</td></tr>
<tr><td><code id="rxode2_+3A_package">package</code></td>
<td>
<p>Package name for pre-compiled binaries.</p>
</td></tr>
<tr><td><code id="rxode2_+3A_...">...</code></td>
<td>
<p>ignored arguments.</p>
</td></tr>
<tr><td><code id="rxode2_+3A_lincmtsens">linCmtSens</code></td>
<td>
<p>The method to calculate the linCmt() solutions</p>
</td></tr>
<tr><td><code id="rxode2_+3A_indlin">indLin</code></td>
<td>
<p>Calculate inductive linearization matrices and
compile with inductive linearization support.</p>
</td></tr>
<tr><td><code id="rxode2_+3A_verbose">verbose</code></td>
<td>
<p>When <code>TRUE</code> be verbose with the linear
compartmental model</p>
</td></tr>
<tr><td><code id="rxode2_+3A_fullprint">fullPrint</code></td>
<td>
<p>When using <code>printf</code> within the model, if <code>TRUE</code>
print on every step (except ME/indLin), otherwise when <code>FALSE</code>
print only when calculating the <code>d/dt</code></p>
</td></tr>
<tr><td><code id="rxode2_+3A_envir">envir</code></td>
<td>
<p>is the environment to look for R user functions
(defaults to parent environment)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>Rx</code> in the name <code>rxode2</code> is meant to suggest the
abbreviation <em>Rx</em> for a medical prescription, and thus to
suggest the package emphasis on pharmacometrics modeling, including
pharmacokinetics (PK), pharmacodynamics (PD), disease progression,
drug-disease modeling, etc.
</p>
<p>The ODE-based model specification may be coded inside four places:
</p>

<ul>
<li><p> Inside a <code>rxode2({})</code> block statements:
</p>
</li></ul>

<!-- end list -->

<div class="sourceCode r"><pre>library(rxode2)
mod &lt;- rxode2({
  # simple assignment
  C2 &lt;- centr/V2

  # time-derivative assignment
  d/dt(centr) &lt;- F*KA*depot - CL*C2 - Q*C2 + Q*C3;
})
</pre></div>
<div class="sourceCode"><pre>## using C compiler: gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0
## In file included from /usr/share/R/include/R.h:71,
##                  from /home/matt/R/x86_64-pc-linux-gnu-library/4.3/rxode2parse/include/rxode2parse.h:33,
##                  from /home/matt/src/rxode2/inst/include/rxode2.h:9,
##                  from /home/matt/R/x86_64-pc-linux-gnu-library/4.3/rxode2parse/include/rxode2_model_shared.h:3,
##                  from rx_80ab028288eddd16733200578a7fac4b_.c:117:
## /usr/share/R/include/R_ext/Complex.h:80:6: warning: ISO C99 doesnt support unnamed structs/unions [-Wpedantic]
##    80 |     };
##       |      ^
</pre></div>

<ul>
<li><p> Inside a <code>rxode2("")</code> string statement:
</p>
</li></ul>

<!-- end list -->

<div class="sourceCode r"><pre>mod &lt;- rxode2("
  # simple assignment
  C2 &lt;- centr/V2

  # time-derivative assignment
  d/dt(centr) &lt;- F*KA*depot - CL*C2 - Q*C2 + Q*C3;
")
</pre></div>
<div class="sourceCode"><pre>## using C compiler: gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0
## In file included from /usr/share/R/include/R.h:71,
##                  from /home/matt/R/x86_64-pc-linux-gnu-library/4.3/rxode2parse/include/rxode2parse.h:33,
##                  from /home/matt/src/rxode2/inst/include/rxode2.h:9,
##                  from /home/matt/R/x86_64-pc-linux-gnu-library/4.3/rxode2parse/include/rxode2_model_shared.h:3,
##                  from rx_16fc28e9f2ad308e65c8fb7a9b53fdc1_.c:117:
## /usr/share/R/include/R_ext/Complex.h:80:6: warning: ISO C99 doesnt support unnamed structs/unions [-Wpedantic]
##    80 |     };
##       |      ^
</pre></div>

<ul>
<li><p> In a file name to be loaded by rxode2:
</p>
</li></ul>

<!-- end list -->

<div class="sourceCode r"><pre>writeLines("
  # simple assignment
  C2 &lt;- centr/V2

  # time-derivative assignment
  d/dt(centr) &lt;- F*KA*depot - CL*C2 - Q*C2 + Q*C3;
", "modelFile.rxode2")
mod &lt;- rxode2(filename='modelFile.rxode2')
unlink("modelFile.rxode2")
</pre></div>

<ul>
<li><p> In a model function which can be parsed by <code>rxode2</code>:
</p>
</li></ul>

<!-- end list -->

<div class="sourceCode r"><pre>mod &lt;- function() {
  model({
    # simple assignment
    C2 &lt;- centr/V2

    # time-derivative assignment
    d/dt(centr) &lt;- F*KA*depot - CL*C2 - Q*C2 + Q*C3;
  })
}

mod &lt;- rxode2(mod) # or simply mod() if the model is at the end of the function

# These model functions often have residual components and initial
# (`ini({})`) conditions attached as well. For example the
# theophylline model can be written as:

one.compartment &lt;- function() {
  ini({
    tka &lt;- 0.45 # Log Ka
    tcl &lt;- 1 # Log Cl
    tv &lt;- 3.45    # Log V
    eta.ka ~ 0.6
    eta.cl ~ 0.3
    eta.v ~ 0.1
    add.sd &lt;- 0.7
  })
  model({
    ka &lt;- exp(tka + eta.ka)
    cl &lt;- exp(tcl + eta.cl)
    v &lt;- exp(tv + eta.v)
    d/dt(depot) = -ka * depot
    d/dt(center) = ka * depot - cl / v * center
    cp = center / v
    cp ~ add(add.sd)
  })
}

# after parsing the model
mod &lt;- one.compartment()
</pre></div>
<p>For the block statement, character string or text file an internal
<code>rxode2</code> compilation manager translates the ODE system into C, compiles
it and loads it into the R session. The call to <code>rxode2</code> produces an
object of class <code>rxode2</code> which consists of a list-like structure
(environment) with various member functions.
</p>
<p>For the last type of model (a model function), a call to <code>rxode2</code>
creates a parsed <code>rxode2</code> ui that can be translated to the <code>rxode2</code>
compilation model.
</p>
<div class="sourceCode r"><pre>mod$simulationModel
</pre></div>
<div class="sourceCode"><pre>## using C compiler: gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0
## In file included from /usr/share/R/include/R.h:71,
##                  from /home/matt/R/x86_64-pc-linux-gnu-library/4.3/rxode2parse/include/rxode2parse.h:33,
##                  from /home/matt/src/rxode2/inst/include/rxode2.h:9,
##                  from /home/matt/R/x86_64-pc-linux-gnu-library/4.3/rxode2parse/include/rxode2_model_shared.h:3,
##                  from rx_e3306ec84cb8151ac51b0c27ef3dbbe7_.c:117:
## /usr/share/R/include/R_ext/Complex.h:80:6: warning: ISO C99 doesnt support unnamed structs/unions [-Wpedantic]
##    80 |     };
##       |      ^

## rxode2 2.1.2 model named rx_e3306ec84cb8151ac51b0c27ef3dbbe7 model (ready). 
## x$state: depot, center
## x$stateExtra: cp
## x$params: tka, tcl, tv, add.sd, eta.ka, eta.cl, eta.v, rxerr.cp
## x$lhs: ka, cl, v, cp, ipredSim, sim
</pre></div>
<div class="sourceCode r"><pre># or 
mod$simulationIniModel
</pre></div>
<div class="sourceCode"><pre>## using C compiler: gcc (Ubuntu 11.4.0-1ubuntu1~22.04) 11.4.0
## In file included from /usr/share/R/include/R.h:71,
##                  from /home/matt/R/x86_64-pc-linux-gnu-library/4.3/rxode2parse/include/rxode2parse.h:33,
##                  from /home/matt/src/rxode2/inst/include/rxode2.h:9,
##                  from /home/matt/R/x86_64-pc-linux-gnu-library/4.3/rxode2parse/include/rxode2_model_shared.h:3,
##                  from rx_6f91c3aeabfdac8ced143f492e648867_.c:117:
## /usr/share/R/include/R_ext/Complex.h:80:6: warning: ISO C99 doesnt support unnamed structs/unions [-Wpedantic]
##    80 |     };
##       |      ^

## rxode2 2.1.2 model named rx_6f91c3aeabfdac8ced143f492e648867 model (ready). 
## x$state: depot, center
## x$stateExtra: cp
## x$params: tka, tcl, tv, add.sd, eta.ka, eta.cl, eta.v, rxerr.cp
## x$lhs: ka, cl, v, cp, ipredSim, sim
</pre></div>
<p>This is the same type of function required for <code>nlmixr2</code> estimation and
can be extended and modified by model piping. For this reason will be
focused on in the documentation.
</p>
<p>This basic model specification consists of one or more statements
optionally terminated by semi-colons <code style="white-space: pre;">&#8288;;&#8288;</code> and optional comments (comments
are delimited by <code style="white-space: pre;">&#8288;#&#8288;</code> and an end-of-line).
</p>
<p>A block of statements is a set of statements delimited by curly braces,
<code>{ ... }</code>.
</p>
<p>Statements can be either assignments, conditional <code>if</code>/<code style="white-space: pre;">&#8288;else if&#8288;</code>/<code style="white-space: pre;">&#8288;else&#8288;</code>,
<code>while</code> loops (can be exited by <code>break</code>), special statements, or
printing statements (for debugging/testing).
</p>
<p>Assignment statements can be:
</p>

<ul>
<li> <p><strong>simple</strong> assignments, where the left hand is an identifier (i.e.,
variable)
</p>
</li>
<li><p> special <strong>time-derivative</strong> assignments, where the left hand
specifies the change of the amount in the corresponding state
variable (compartment) with respect to time e.g., <code>d/dt(depot)</code>:
</p>
</li>
<li><p> special <strong>initial-condition</strong> assignments where the left hand
specifies the compartment of the initial condition being specified,
e.g.<code>depot(0) = 0</code>
</p>
</li>
<li><p> special model event changes including <strong>bioavailability</strong>
(<code>f(depot)=1</code>), <strong>lag time</strong> (<code>alag(depot)=0</code>), <strong>modeled rate</strong>
(<code>rate(depot)=2</code>) and <strong>modeled duration</strong> (<code>dur(depot)=2</code>). An
example of these model features and the event specification for the
modeled infusions the rxode2 data specification is found in <a href="https://nlmixr2.github.io/rxode2/articles/rxode2-event-types.html">rxode2 events vignette</a>.
</p>
</li>
<li><p> special <strong>change point syntax, or model times</strong>. These model times
are specified by <code>mtime(var)=time</code>
</p>
</li>
<li><p> special <strong>Jacobian-derivative</strong> assignments, where the left hand
specifies the change in the compartment ode with respect to a
variable. For example, if <code>d/dt(y) = dy</code>, then a Jacobian for this
compartment can be specified as <code>df(y)/dy(dy) = 1</code>. There may be
some advantage to obtaining the solution or specifying the Jacobian
for very stiff ODE systems. However, for the few stiff systems we
tried with LSODA, this actually slightly slowed down the solving.
</p>
</li></ul>

<p>Note that assignment can be done by <code>=</code>, <code style="white-space: pre;">&#8288;&lt;-&#8288;</code> or <code>~</code>.
</p>
<p>When assigning with the <code>~</code> operator, the <strong>simple assignments</strong> and
<strong>time-derivative</strong> assignments will not be output. Note that with the
<code>rxode2</code> model functions assignment with <code>~</code> can also be overloaded with
a residual distribution specification.
</p>
<p>Special statements can be:
</p>

<ul>
<li> <p><strong>Compartment declaration statements</strong>, which can change the default
dosing compartment and the assumed compartment number(s) as well as
add extra compartment names at the end (useful for multiple-endpoint
nlmixr models); These are specified by <code>cmt(compartmentName)</code>
</p>
</li>
<li> <p><strong>Parameter declaration statements</strong>, which can make sure the input
parameters are in a certain order instead of ordering the parameters
by the order they are parsed. This is useful for keeping the
parameter order the same when using 2 different ODE models. These
are specified by <code>param(par1, par2,...)</code>
</p>
</li></ul>

<p>An example model is shown below:
</p>
<div class="sourceCode"><pre>   # simple assignment
   C2 &lt;- centr/V2

   # time-derivative assignment
   d/dt(centr) &lt;- F*KA*depot - CL*C2 - Q*C2 + Q*C3;
</pre></div>
<p>Expressions in assignment and <code>if</code> statements can be numeric or logical.
</p>
<p>Numeric expressions can include the following numeric operators <code style="white-space: pre;">&#8288;+, -, *, /, ^&#8288;</code> and those mathematical functions defined in the C or the R math
libraries (e.g., <code>fabs</code>, <code>exp</code>, <code>log</code>, <code>sin</code>, <code>abs</code>).
</p>
<p>You may also access the Rs functions in the <a href="https://cran.r-project.org/doc/manuals/r-release/R-exts.html#Numerical-analysis-subroutines">R math libraries</a>,
like <code>lgammafn</code> for the log gamma function.
</p>
<p>The <code>rxode2</code> syntax is case-sensitive, i.e., <code>ABC</code> is different than
<code>abc</code>, <code>Abc</code>, <code>ABc</code>, etc.
</p>


<h4>Identifiers</h4>

<p>Like R, Identifiers (variable names) may consist of one or more
alphanumeric, underscore <code style="white-space: pre;">&#8288;_&#8288;</code> or period <code>.</code> characters, but the first
character cannot be a digit or underscore <code style="white-space: pre;">&#8288;_&#8288;</code>.
</p>
<p>Identifiers in a model specification can refer to:
</p>

<ul>
<li><p> State variables in the dynamic system (e.g., compartments in a
pharmacokinetics model).
</p>
</li>
<li><p> Implied input variable, <code>t</code> (time), <code>tlast</code> (last time point), and
<code>podo</code> (oral dose, in the undocumented case of absorption transit
models).
</p>
</li>
<li><p> Special constants like <code>pi</code> or <a href="https://cran.r-project.org/doc/manuals/r-release/R-exts.html#Mathematical-constants">Rs predefined constants</a>.
</p>
</li>
<li><p> Model parameters (e.g., <code>ka</code> rate of absorption, <code>CL</code> clearance,
etc.)
</p>
</li>
<li><p> Others, as created by assignments as part of the model
specification; these are referred as <em>LHS</em> (left-hand side)
variable.
</p>
</li></ul>

<p>Currently, the <code>rxode2</code> modeling language only recognizes system state
variables and parameters, thus, any values that need to be passed from
R to the ODE model (e.g., <code>age</code>) should be either passed in the <code>params</code>
argument of the integrator function <code>rxSolve()</code> or be in the supplied
event data-set.
</p>
<p>There are certain variable names that are in the <code>rxode2</code> event tables.
To avoid confusion, the following event table-related items cannot be
assigned, or used as a state but can be accessed in the rxode2 code:
</p>

<ul>
<li> <p><code>cmt</code>
</p>
</li>
<li> <p><code>dvid</code>
</p>
</li>
<li> <p><code>addl</code>
</p>
</li>
<li> <p><code>ss</code>
</p>
</li>
<li> <p><code>rate</code>
</p>
</li>
<li> <p><code>id</code>
</p>
</li></ul>

<p>However the following variables are cannot be used in a model
specification:
</p>

<ul>
<li> <p><code>evid</code>
</p>
</li>
<li> <p><code>ii</code>
</p>
</li></ul>

<p>Sometimes rxode2 generates variables that are fed back to rxode2.
Similarly, nlmixr2 generates some variables that are used in nlmixr
estimation and simulation. These variables start with the either the
<code>rx</code> or <code>nlmixr</code> prefixes. To avoid any problems, it is suggested to not
use these variables starting with either the <code>rx</code> or <code>nlmixr</code> prefixes.
</p>



<h4>Logical Operators</h4>

<p>Logical operators support the standard R operators <code>==</code>, <code>!=</code> <code>&gt;=</code> <code>&lt;=</code>
<code>&gt;</code> and <code>&lt;</code>. Like R these can be in <code style="white-space: pre;">&#8288;if()&#8288;</code> or <code style="white-space: pre;">&#8288;while()&#8288;</code> statements,
<code>ifelse()</code> expressions. Additionally they can be in a standard
assignment. For instance, the following is valid:
</p>
<div class="sourceCode"><pre>cov1 = covm*(sexf == "female") + covm*(sexf != "female")
</pre></div>
<p>Notice that you can also use character expressions in comparisons. This
convenience comes at a cost since character comparisons are slower than
numeric expressions. Unlike R, <code>as.numeric</code> or <code>as.integer</code> for these
logical statements is not only not needed, but will cause an syntax
error if you try to use the function.
</p>



<h4>Supported functions</h4>

<p>All the supported functions in rxode2 can be seen with the
<code>rxSupportedFuns()</code>.
</p>
<p>A brief description of the built-in functions are in the following
table:</p>

<table>
<tr>
 <td style="text-align: left;">
   Function </td><td style="text-align: left;"> Description </td><td style="text-align: left;"> Aliases </td>
</tr>
<tr>
 <td style="text-align: left;">
   gamma(x) </td><td style="text-align: left;"> The Gamma function </td><td style="text-align: left;"> gammafn </td>
</tr>
<tr>
 <td style="text-align: left;">
   lgamma(x) </td><td style="text-align: left;"> Natural logarithm of absolute value of gamma function </td><td style="text-align: left;"> digamma </td>
</tr>
<tr>
 <td style="text-align: left;">
   digamma(x) </td><td style="text-align: left;"> First derivative of lgamma </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   trigamma(x) </td><td style="text-align: left;"> Second derivative of lgamma </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   tetragamma(x) </td><td style="text-align: left;"> Third derivative of lgamma </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   pentagamma(x) </td><td style="text-align: left;"> Fourth derivative of lgamma </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   psigamma(x, deriv) </td><td style="text-align: left;"> n-th derivative of Psi, the digamma function, which is the derivative of lgammafn. In other words, digamma(x) is the same as psigamma(x,0), trigamma(x) == psigamma(x,1), etc. </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   cospi(x) </td><td style="text-align: left;"> cos(pi*x) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   sinpi(x) </td><td style="text-align: left;"> sin(pi*x) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   tanpi(x) </td><td style="text-align: left;"> tan(pi*x) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   beta(a, b) </td><td style="text-align: left;"> Beta function </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   lbeta(a, b) </td><td style="text-align: left;"> log Beta function </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   bessel_i(x, nu, expo) </td><td style="text-align: left;"> Bessel function type I with index nu </td><td style="text-align: left;"> expo==1 is unscaled expo==2 is scaled by exp(-x) </td>
</tr>
<tr>
 <td style="text-align: left;">
   bessel_j(x, nu) </td><td style="text-align: left;"> Bessel function type J with index nu </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   bessel_k(x, ku, expo) </td><td style="text-align: left;"> Bessel function type K with index nu </td><td style="text-align: left;"> expo==1 is unscaled expo==2 is scaled by exp(x) </td>
</tr>
<tr>
 <td style="text-align: left;">
   bessel_y(x, nu) </td><td style="text-align: left;"> Bessel function type Y with index nu </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   R_pow(x, y) </td><td style="text-align: left;"> x^y </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   R_pow_di(x, I) </td><td style="text-align: left;"> x^y </td><td style="text-align: left;"> y is an integer </td>
</tr>
<tr>
 <td style="text-align: left;">
   log1pmx </td><td style="text-align: left;"> log(1+x) - x </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   log1pexp </td><td style="text-align: left;"> log(1+exp(x)) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   expm1(x) </td><td style="text-align: left;"> exp(x)-1 </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   lgamma1p(x) </td><td style="text-align: left;"> log(gamma(x+1)) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   sign(x) </td><td style="text-align: left;"> Compute the signum function where sign(x) is 1, 0 -1 </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   fsign(x, y) </td><td style="text-align: left;"> abs(x)*sign(y) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   fprec(x, digits) </td><td style="text-align: left;"> x rounded to digits (after the decimal point, used by signif() </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   fround(x, digits) </td><td style="text-align: left;"> Round, used by Rs round() </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   ftrunc(x) </td><td style="text-align: left;"> Truncated towards zero </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   abs(x) </td><td style="text-align: left;"> absolute value of x </td><td style="text-align: left;"> fabs </td>
</tr>
<tr>
 <td style="text-align: left;">
   sin(x) </td><td style="text-align: left;"> sine of x </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   cos(x) </td><td style="text-align: left;"> cos of x </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   tan(x) </td><td style="text-align: left;"> tan of x </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   factorial(x) </td><td style="text-align: left;"> factorial of x </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   lfactorial(x) </td><td style="text-align: left;"> log(factorial(x)) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   log10(x) </td><td style="text-align: left;"> log base 10 </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   log2(x) </td><td style="text-align: left;"> log base 2 </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   pnorm(x) </td><td style="text-align: left;"> Normal CDF of x </td><td style="text-align: left;"> normcdf, phi </td>
</tr>
<tr>
 <td style="text-align: left;">
   qnorm(x) </td><td style="text-align: left;"> Normal pdf of x </td><td style="text-align: left;"> norminv </td>
</tr>
<tr>
 <td style="text-align: left;">
   probit(x, low=0, hi=1) </td><td style="text-align: left;"> Probit (normal pdf) of x transforming into a range </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   probitInv(q, low=0, hi=1) </td><td style="text-align: left;"> Inverse probit of x transforming into a range </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   acos(x) </td><td style="text-align: left;"> Inverse cosine </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   asin(x) </td><td style="text-align: left;"> Inverse sine </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   atan(x) </td><td style="text-align: left;"> Inverse tangent </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   atan2(a, b) </td><td style="text-align: left;"> Four quadrant inverse tangent </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   sinh(x) </td><td style="text-align: left;"> Hyperbolic sine </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   cosh(x) </td><td style="text-align: left;"> Hyperbolic cosine </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   tanh(x) </td><td style="text-align: left;"> Hyperbolic tangent </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   floor(x) </td><td style="text-align: left;"> Downward rounding </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   ceil(x) </td><td style="text-align: left;"> Upward rounding </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   logit(x, low=0, hi=1) </td><td style="text-align: left;"> Logit transformation of x transforming into a range </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   expit(x, low=0, hi=1) </td><td style="text-align: left;"> expit transofmration in range </td><td style="text-align: left;"> invLogit, logitInv </td>
</tr>
<tr>
 <td style="text-align: left;">
   gammaq(a, z) </td><td style="text-align: left;"> Normalized incomplete gamma from boost </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   gammaqInv(a, q) </td><td style="text-align: left;"> Normalized incomplete gamma inverse from boost </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   ifelse(cond, trueValue, falseValue) </td><td style="text-align: left;"> if else function </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   gammap(a, z) </td><td style="text-align: left;"> Normalized lower incomplete gamma from boost </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   gammapInv(a, p) </td><td style="text-align: left;"> Inverse of Normalized lower incomplete gamma from boost </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   gammapInva(x, p) </td><td style="text-align: left;"> Inverse of Normalized lower incomplete gamma from boost </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   rxnorm(x) </td><td style="text-align: left;"> Generate one deviate of from a normal distribution for each observation scale </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   rxnormV(x) </td><td style="text-align: left;"> Generate one deviate from low discrepancy normal for each observation </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   rxcauchy </td><td style="text-align: left;"> Generate one deviate from the cauchy distribution for each observation </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   rxchisq </td><td style="text-align: left;"> Generate one deviate from the chisq distribution for each observation </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   rxexp </td><td style="text-align: left;"> Generate one deviate from the exponential distribution for each observation </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   rxf </td><td style="text-align: left;"> Generate one deviate from low discrepancy normal for each observation </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   rxgamma </td><td style="text-align: left;"> Generate one deviate from the gamma distribution for each observation </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   rxbeta </td><td style="text-align: left;"> Generate one deviate from the beta distribution for each observation </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   rxgeom </td><td style="text-align: left;"> Generate one deviate from the geometric distribution for each observation </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   rxpois </td><td style="text-align: left;"> Generate one deviate from the poission distribution for each observation </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   rxt </td><td style="text-align: left;"> Generate one deviate from the t distribtuion for each observation </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   tad() or tad(x) </td><td style="text-align: left;"> Time after dose (tad()) or time after dose for a compartment tad(cmt) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   tafd() or tafd(x) </td><td style="text-align: left;"> Time after first dose (tafd()) or time after first dose for a compartment tafd(cmt) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   dosenum() </td><td style="text-align: left;"> Dose Number </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   tlast() or tlast(cmt) </td><td style="text-align: left;"> Time of Last dose; This takes into consideration any lag time, so if there is a dose at time 3 and a lag of 1, the time of last dose would be 4. tlast(cmt) calculates the time since last dose of a compartment </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   tfirst() or tfirst(cmt) </td><td style="text-align: left;"> Time since first dose or time since first dose of a compartment </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   prod() </td><td style="text-align: left;"> product of terms; This uses PreciseSums so the product will not have as much floating point errors (though it will take longer) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   sum() </td><td style="text-align: left;"> sum of terms; This uses PreciseSums so the product will not have as much floating point errors (though it will take longer) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   max() </td><td style="text-align: left;"> maximum of a group of numbers </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   min() </td><td style="text-align: left;"> Min of a group of numbers </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   lag(parameter, number=1) </td><td style="text-align: left;"> Get the lag of an input parameter; You can specify a number of lagged observations </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   lead(parameter, number=2) </td><td style="text-align: left;"> Get the lead of an input parameter; You can specify a number of lead observation </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   diff(par, number=1) </td><td style="text-align: left;"> Get the difference between the current parameter and the last parameter; Can change the parameter number </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   first(par) </td><td style="text-align: left;"> Get the first value of an input parameter </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   last(par) </td><td style="text-align: left;"> Get the last value of an input parameter </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   transit() </td><td style="text-align: left;"> The transit compartment psuedo function </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   is.na() </td><td style="text-align: left;"> Determine if a value is NA </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   is.nan() </td><td style="text-align: left;"> Determine if a value is NaN </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   is.infinite() </td><td style="text-align: left;"> Check to see if the value is infinite </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   rinorm(x) </td><td style="text-align: left;"> Generate one deviate of from a normal distribution for each individual </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   rinormV(x) </td><td style="text-align: left;"> Generate one deviate from low discrepancy normal for each individual </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   ricauchy </td><td style="text-align: left;"> Generate one deviate from the cauchy distribution for each individual </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   richisq </td><td style="text-align: left;"> Generate one deviate from the chisq distribution for each individual </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   riexp </td><td style="text-align: left;"> Generate one deviate from the exponential distribution for each individual </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   rif </td><td style="text-align: left;"> Generate one deviate from low discrepancy normal for each individual </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   rigamma </td><td style="text-align: left;"> Generate one deviate from the gamma distribution for each individual </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   ribeta </td><td style="text-align: left;"> Generate one deviate from the beta distribution for each individual </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   rigeom </td><td style="text-align: left;"> Generate one deviate from the geometric distribution for each individual </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   ropois </td><td style="text-align: left;"> Generate one deviate from the poission distribution for each individual </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   rit </td><td style="text-align: left;"> Generate one deviate from the t distribtuion for each individual </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   simeps </td><td style="text-align: left;"> Simulate EPS from possibly truncated sigma matrix. Will take sigma matrix from the current study. Simulated at the very last moment. </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   simeta </td><td style="text-align: left;"> Simulate ETA from possibly truncated omega matrix. Will take the omega matrix from the current study. Simulated at the initilization of the ODE system or the intialization of lhs </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Note that <code style="white-space: pre;">&#8288;lag(cmt) =&#8288;</code> is equivalent to <code style="white-space: pre;">&#8288;alag(cmt) =&#8288;</code> and not the same
as <code style="white-space: pre;">&#8288;= lag(wt)&#8288;</code>
</p>



<h4>Reserved keywords</h4>

<p>There are a few reserved keywords in a rxode2 model. They are in the
following table:</p>

<table>
<tr>
 <td style="text-align: left;">
   Reserved Name </td><td style="text-align: left;"> Meaning </td><td style="text-align: left;"> Alias </td>
</tr>
<tr>
 <td style="text-align: left;">
   time </td><td style="text-align: left;"> solver time </td><td style="text-align: left;"> t </td>
</tr>
<tr>
 <td style="text-align: left;">
   podo </td><td style="text-align: left;"> In Transit compartment models, last dose amount </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   tlast </td><td style="text-align: left;"> Time of Last dose </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_E </td><td style="text-align: left;"> Exp(1) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_LOG2E </td><td style="text-align: left;"> log2(e) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_LOG10E </td><td style="text-align: left;"> log10(e) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_LN2 </td><td style="text-align: left;"> log(2) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_LN10 </td><td style="text-align: left;"> log(10) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_PI </td><td style="text-align: left;"> pi </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_PI_2 </td><td style="text-align: left;"> pi/2 </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_PI_4 </td><td style="text-align: left;"> pi/4 </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_1_PI </td><td style="text-align: left;"> 1/pi </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_2_PI </td><td style="text-align: left;"> 2/pi </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_2_SQRTPI </td><td style="text-align: left;"> 2/sqrt(pi) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_SQRT2 </td><td style="text-align: left;"> sqrt(2) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_SQRT1_2 </td><td style="text-align: left;"> 1/sqrt(2) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_SQRT_3 </td><td style="text-align: left;"> sqrt(3) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_SQRT_32 </td><td style="text-align: left;"> sqrt(32) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_LOG10_2 </td><td style="text-align: left;"> Log10(2) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_2PI </td><td style="text-align: left;"> 2*pi </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_SQRT_PI </td><td style="text-align: left;"> sqrt(pi) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_1_SQRT_2PI </td><td style="text-align: left;"> 1/(sqrt(2*pi)) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_LN_SQRT_PI </td><td style="text-align: left;"> log(sqrt(pi)) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_LN_SQRT_2PI </td><td style="text-align: left;"> log(sqrt(2*pi)) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_LN_SQRT_PId2 </td><td style="text-align: left;"> log(sqrt(pi/2)) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   pi </td><td style="text-align: left;"> pi </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   NA </td><td style="text-align: left;"> Rs NA value </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   NaN </td><td style="text-align: left;"> Not a Number Value </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   Inf </td><td style="text-align: left;"> Infinite Value </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   newind </td><td style="text-align: left;"> 1: First record of individual; 2: Subsequent record of individual </td><td style="text-align: left;"> NEWIND </td>
</tr>
<tr>
 <td style="text-align: left;">
   rxFlag </td><td style="text-align: left;"> Flag for what part of the rxode2 model is being run; 1: ddt; 2: jac; 3: ini; 4: F; 5: lag; 6: rate; 7: dur; 8: mtime; 9: matrix exponential; 10: inductive linearization; 11: lhs </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Note that <code>rxFlag</code> will always output <code>11</code> or <code>calc_lhs</code> since that is
where the final variables are calculated, though you can tweak or test
certain parts of <code>rxode2</code> by using this flag.
</p>



<h4>Residual functions when using rxode2 functions</h4>

<p>In addition to <code>~</code> hiding output for certain types of output, it also is
used to specify a residual output or endpoint when the input is an
<code>rxode2</code> model function (that includes the residual in the <code>model({})</code>
block).
</p>
<p>These specifications are of the form:
</p>
<div class="sourceCode r"><pre>var ~ add(add.sd)
</pre></div>
<p>Indicating the variable <code>var</code> is the variable that represents the
individual central tendencies of the model and it also represents the
compartment specification in the data-set.
</p>
<p>You can also change the compartment name using the <code>|</code> syntax, that is:
</p>
<div class="sourceCode r"><pre>var ~ add(add.sd) | cmt
</pre></div>
<p>In the above case <code>var</code> represents the central tendency and <code>cmt</code>
represents the compartment or <code>dvid</code> specification.
</p>


<h5>Transformations</h5>

<p>For normal and related distributions, you can apply the transformation
on both sides by using some keywords/functions to apply these
transformations.</p>

<table>
<tr>
 <td style="text-align: left;">
   Transformation </td><td style="text-align: left;"> rxode2/nlmixr2 code </td>
</tr>
<tr>
 <td style="text-align: left;">
   Box-Cox </td><td style="text-align: left;"> +boxCox(lambda) </td>
</tr>
<tr>
 <td style="text-align: left;">
   Yeo-Johnson </td><td style="text-align: left;"> +yeoJohnson(lambda) </td>
</tr>
<tr>
 <td style="text-align: left;">
   logit-normal </td><td style="text-align: left;"> +logitNorm(logit.sd, low, hi) </td>
</tr>
<tr>
 <td style="text-align: left;">
   probit-normal </td><td style="text-align: left;"> +probitNorm(probid.sd, low, hi) </td>
</tr>
<tr>
 <td style="text-align: left;">
   log-normal </td><td style="text-align: left;"> +lnorm(lnorm.sd) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>By default for the likelihood for all of these transformations is
calculated on the <strong>untransformed</strong> scale.
</p>
<p>For bounded variables like logit-normal or probit-normal the low and
high values are defaulted to 0 and 1 if missing.
</p>
<p>For models where you wish to have a proportional model on one of these
transformation you can replace the standard deviation with <code>NA</code>
</p>
<p>To allow for more transformations, <code>lnorm()</code>, <code>probitNorm()</code> and
<code>logitNorm()</code> can be combined the variance stabilizing <code>yeoJohnson()</code>
transformation.
</p>



<h5>Normal and t-related distributions</h5>

<p>For the normal and t-related distributions, we wanted to keep the
ability to use skewed distributions additive and proportional in the
t/cauchy-space, so these distributions are specified differently in
comparison to the other supported distributions within <code>nlmixr2</code>:</p>

<table>
<tr>
 <td style="text-align: left;">
   Distribution </td><td style="text-align: left;"> How to Add </td><td style="text-align: left;"> Example </td>
</tr>
<tr>
 <td style="text-align: left;">
   Normal (log-likelihood) </td><td style="text-align: left;"> +dnorm() </td><td style="text-align: left;"> cc ~ add(add.sd) + dnorm() </td>
</tr>
<tr>
 <td style="text-align: left;">
   T-distribution </td><td style="text-align: left;"> +dt(df) </td><td style="text-align: left;"> cc ~a dd(add.sd) + dt(df) </td>
</tr>
<tr>
 <td style="text-align: left;">
   Cauchy (t with df=1) </td><td style="text-align: left;"> +dcauchy() </td><td style="text-align: left;"> cc ~ add(add.sd) + dcauchy() </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Note that with the normal and t-related distributions <code>nlmixr2</code> will
calculate <code>cwres</code> and <code>npde</code> under the normal assumption to help assess
the goodness of the fit of the model.
</p>
<p>Also note that the <code>+dnorm()</code> is mostly for testing purposes and will
slow down the estimation procedure in <code>nlmixr2</code>. We suggest not adding
it (except for explicit testing). When there are multiple endpoint
models that mix non-normal and normal distributions, the whole problem
is shifted to a log-likelihood method for estimation in <code>nlmixr2</code>.
</p>



<h5>Notes on additive + proportional models</h5>

<p>There are two different ways to specify additive and proportional
models, which we will call <strong>combined1</strong> and <strong>combined2</strong>, the same way
that Monolix calls the two distributions (to avoid between software
differences in naming).
</p>
<p>The first, <strong>combined1</strong>, assumes that the additive and proportional
differences are on the standard deviation scale, or:
</p>
<p>y=f+(a+b* f^c)*err
</p>
<p>The second, <strong>combined2</strong>, assumes that the additive and proportional
differences are combined on a variance scale:
</p>
<p>y=f+[sqrt(a^2+b^2 *f^(2c))]*err
</p>
<p>The default in <code>nlmixr2</code>/<code>rxode2</code> if not otherwise specified is
<strong>combined2</strong> since it mirrors how adding 2 normal distributions in
statistics will add their variances (not the standard deviations).
However, the <strong>combined1</strong> can describe the data possibly even better
than <strong>combined2</strong> so both are possible options in <code>rxode2</code>/<code>nlmixr2</code>.
</p>



<h5>Distributions of known likelihoods</h5>

<p>For residuals that are not related to normal, t-distribution or cauchy,
often the residual specification is of the form:
</p>
<div class="sourceCode r"><pre>cmt ~ dbeta(alpha, beta)
</pre></div>
<p>Where the compartment specification is on the left handed side of the
specification.
</p>
<p>For generalized likelihood you can specify:
</p>
<div class="sourceCode r"><pre>ll(cmt) ~ llik specification
</pre></div>



<h5>Ordinal likelihoods</h5>

<p>Finally, ordinal likelihoods/simulations can be specified in 2 ways. The
first is:
</p>
<div class="sourceCode r"><pre>err ~ c(p0, p1, p2)
</pre></div>
<p>Here <code>err</code> represents the compartment and <code>p0</code> is the probability of
being in a specific category:</p>

<table>
<tr>
 <td style="text-align: left;">
   Category </td><td style="text-align: left;"> Probability </td>
</tr>
<tr>
 <td style="text-align: left;">
   1 </td><td style="text-align: left;"> p0 </td>
</tr>
<tr>
 <td style="text-align: left;">
   2 </td><td style="text-align: left;"> p1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   3 </td><td style="text-align: left;"> p2 </td>
</tr>
<tr>
 <td style="text-align: left;">
   4 </td><td style="text-align: left;"> 1-p0-p1-p2 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>It is up to the model to ensure that the sum of the <code>p</code> values are less
than <code>1</code>. Additionally you can write an arbitrary number of categories
in the ordinal model described above.
</p>
<p>It seems a little off that <code>p0</code> is the probability for category <code>1</code> and
sometimes scores are in non-whole numbers. This can be modeled as
follows:
</p>
<div class="sourceCode r"><pre>err ~ c(p0=0, p1=1, p2=2, 3)
</pre></div>
<p>Here the numeric categories are specified explicitly, and the
probabilities remain the same:</p>

<table>
<tr>
 <td style="text-align: left;">
   Category </td><td style="text-align: left;"> Probability </td>
</tr>
<tr>
 <td style="text-align: left;">
   0 </td><td style="text-align: left;"> p0 </td>
</tr>
<tr>
 <td style="text-align: left;">
   1 </td><td style="text-align: left;"> p1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   2 </td><td style="text-align: left;"> p2 </td>
</tr>
<tr>
 <td style="text-align: left;">
   3 </td><td style="text-align: left;"> 1-p0-p1-p2 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>




<h5>General table of supported residual distributions</h5>

<p>In general all the that are supported are in the following table
(available in <code>rxode2::rxResidualError</code>)</p>

<table>
<tr>
 <td style="text-align: left;">
   Error model </td><td style="text-align: left;"> Functional Form </td><td style="text-align: left;"> Transformation </td><td style="text-align: left;"> code </td><td style="text-align: left;"> addProp </td><td style="text-align: left;"> lhs </td>
</tr>
<tr>
 <td style="text-align: left;">
   constant </td><td style="text-align: left;">  </td><td style="text-align: left;"> None </td><td style="text-align: left;"> var ~ add(add.sd) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional </td><td style="text-align: left;">  </td><td style="text-align: left;"> None </td><td style="text-align: left;"> var ~ prop(prop.sd) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power </td><td style="text-align: left;">  </td><td style="text-align: left;"> None </td><td style="text-align: left;"> var ~ pow(pow.sd, exponent) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> None </td><td style="text-align: left;"> var ~ add(add.sd) + prop(prop.sd) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> None </td><td style="text-align: left;"> var ~ add(add.sd) + prop(prop.sd) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> None </td><td style="text-align: left;"> var ~ add(add.sd) + pow(pow.sd, exponent) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> None </td><td style="text-align: left;"> var ~ add(add.sd) + pow(pow.sd, exponent) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   constant </td><td style="text-align: left;">  </td><td style="text-align: left;"> log </td><td style="text-align: left;"> var ~ lnorm(add.sd) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional </td><td style="text-align: left;">  </td><td style="text-align: left;"> log </td><td style="text-align: left;"> var ~ lnorm(NA) + prop(prop.sd) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power </td><td style="text-align: left;">  </td><td style="text-align: left;"> log </td><td style="text-align: left;"> var ~ lnorm(NA) + pow(pow.sd, exponent) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> log </td><td style="text-align: left;"> var ~ lnorm(add.sd) + prop(prop.sd) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> log </td><td style="text-align: left;"> var ~ lnorm(add.sd) + prop(prop.sd) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> log </td><td style="text-align: left;"> var ~ lnorm(add.sd) + pow(pow.sd, exponent) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> log </td><td style="text-align: left;"> var ~ lnorm(add.sd) + pow(pow.sd, exponent) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   constant </td><td style="text-align: left;">  </td><td style="text-align: left;"> boxCox </td><td style="text-align: left;"> var ~ boxCox(lambda) + add(add.sd) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional </td><td style="text-align: left;">  </td><td style="text-align: left;"> boxCox </td><td style="text-align: left;"> var ~ boxCox(lambda) + prop(prop.sd) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power </td><td style="text-align: left;">  </td><td style="text-align: left;"> boxCox </td><td style="text-align: left;"> var ~ boxCox(lambda) + pow(pow.sd, exponent) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> boxCox </td><td style="text-align: left;"> var ~ boxCox(lambda) + add(add.sd) + prop(prop.sd) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> boxCox </td><td style="text-align: left;"> var ~ boxCox(lambda) + add(add.sd) + prop(prop.sd) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> boxCox </td><td style="text-align: left;"> var ~ boxCox(lambda) + add(add.sd) + pow(pop.sd, exponent) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> boxCox </td><td style="text-align: left;"> var ~ boxCox(lambda) + add(add.sd) + pow(pop.sd, exponent) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   constant </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + add(add.sd) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + prop(prop.sd) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + pow(pow.sd, exponent) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> yeoJohnson </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + add(add.sd) + prop(prop.sd) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> yeoJohnson </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + add(add.sd) + prop(prop.sd) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> yeoJohnson </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + add(add.sd) + pow(pop.sd, exponent) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> yeoJohnson </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + add(add.sd) + pow(pop.sd, exponent) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   constant </td><td style="text-align: left;">  </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ logitNorm(logit.sd) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional </td><td style="text-align: left;">  </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ logitNorm(NA) + prop(prop.sd) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power </td><td style="text-align: left;">  </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ logitNorm(NA) + pow(pow.sd, exponent) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ logitNorm(logit.sd) + prop(prop.sd) </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ logitNorm(logit.sd) + prop(prop.sd) </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ logitNorm(logit.sd) + pow(pow.sd, exponent) </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ logitNorm(logit.sd) + pow(pow.sd, exponent) </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson(logit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + logitNorm(logit.sd) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson(logit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + logitNorm(NA) + prop(prop.sd) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson(logit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + logitNorm(NA) + pow(pow.sd, exponent) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> yeoJohnson(logit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + logitNorm(logit.sd) + prop(prop.sd) </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> yeoJohnson(logit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + logitNorm(logit.sd) + prop(prop.sd) </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> yeoJohnson(logit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + logitNorm(logit.sd) + pow(pow.sd, exponent) </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> yeoJohnson(logit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + logitNorm(logit.sd) + pow(pow.sd, exponent) </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   constant </td><td style="text-align: left;">  </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ probitNorm(probit.sd) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional </td><td style="text-align: left;">  </td><td style="text-align: left;"> probit </td><td style="text-align: left;"> var ~ probitNorm(NA) + prop(prop.sd) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power </td><td style="text-align: left;">  </td><td style="text-align: left;"> probit </td><td style="text-align: left;"> var ~ probitNorm(NA) + pow(pow.sd, exponent) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> probit </td><td style="text-align: left;"> var ~ probitNorm(probit.sd) + prop(prop.sd) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> probit </td><td style="text-align: left;"> var ~ probitNorm(probit.sd) + prop(prop.sd) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> probit </td><td style="text-align: left;"> var ~ probitNorm(probit.sd) + pow(pow.sd, exponent) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> probit </td><td style="text-align: left;"> var ~ probitNorm(probit.sd) + pow(pow.sd, exponent) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson(probit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + probitNorm(probit.sd) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson(probit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + probitNorm(NA) + prop(prop.sd) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson(probit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + probitNorm(NA) + pow(pow.sd, exponent) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> yeoJohnson(probit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + probitNorm(probit.sd) + prop(prop.sd) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> yeoJohnson(probit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + probitNorm(probit.sd) + prop(prop.sd) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> yeoJohnson(probit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + probitNorm(probit.sd) + pow(pow.sd, exponent) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> yeoJohnson(probit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + probitNorm(probit.sd) + pow(pow.sd, exponent) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   constant+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> None </td><td style="text-align: left;"> var ~ add(add.sd) + dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> None </td><td style="text-align: left;"> var ~ prop(prop.sd) + dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> None </td><td style="text-align: left;"> var ~ pow(pow.sd, exponent) + dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+t </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> None </td><td style="text-align: left;"> var ~ add(add.sd) + prop(prop.sd) + dt(df) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+t </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> None </td><td style="text-align: left;"> var ~ add(add.sd) + prop(prop.sd) + dt(df) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+t </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> None </td><td style="text-align: left;"> var ~ add(add.sd) + pow(pow.sd, exponent) + dt(df) +combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+t </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> None </td><td style="text-align: left;"> var ~ add(add.sd) + pow(pow.sd, exponent) + dt(df) +combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   constant+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> log </td><td style="text-align: left;"> var ~ lnorm(add.sd) + dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> log </td><td style="text-align: left;"> var ~ lnorm(NA) + prop(prop.sd) + dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> log </td><td style="text-align: left;"> var ~ lnorm(NA) + pow(pow.sd, exponent) + dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+t </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> log </td><td style="text-align: left;"> var ~ lnorm(add.sd) + prop(prop.sd) + dt(df) +combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+t </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> log </td><td style="text-align: left;"> var ~ lnorm(add.sd) + prop(prop.sd) + dt(df) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+t </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> log </td><td style="text-align: left;"> var ~ lnorm(add.sd) + pow(pow.sd, exponent) + dt(df) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+t </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> log </td><td style="text-align: left;"> var ~ lnorm(add.sd) + pow(pow.sd, exponent) + dt(df) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   constant+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> boxCox </td><td style="text-align: left;"> var ~ boxCox(lambda) + add(add.sd)+dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> boxCox </td><td style="text-align: left;"> var ~ boxCox(lambda) + prop(prop.sd)+dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> boxCox </td><td style="text-align: left;"> var ~ boxCox(lambda) + pow(pow.sd, exponent)+dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+t </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> boxCox </td><td style="text-align: left;"> var ~ boxCox(lambda) + add(add.sd) + prop(prop.sd) + dt(df) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+t </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> boxCox </td><td style="text-align: left;"> var ~ boxCox(lambda) + add(add.sd) + prop(prop.sd) + dt(df) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+t </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> boxCox </td><td style="text-align: left;"> var ~ boxCox(lambda) + add(add.sd) + pow(pop.sd, exponent) + dt(df) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+t </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> boxCox </td><td style="text-align: left;"> var ~ boxCox(lambda) + add(add.sd) + pow(pop.sd, exponent) + dt(df) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   constant+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + add(add.sd) + dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + prop(prop.sd) + dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + pow(pow.sd, exponent) + dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+t </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> yeoJohnson </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + add(add.sd) + prop(prop.sd) + dt(df) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+t </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> yeoJohnson </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + add(add.sd) + prop(prop.sd) + dt(df) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+t </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> yeoJohnson </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + add(add.sd) + pow(pop.sd, exponent) + dt(df) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+t </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> yeoJohnson </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + add(add.sd) + pow(pop.sd, exponent) + dt(df) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   constant+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ logitNorm(logit.sd)+dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ logitNorm(NA) + prop(prop.sd)+dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ logitNorm(NA) + pow(pow.sd, exponent) + dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+t </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ logitNorm(logit.sd) + prop(prop.sd) + dt(df) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+t </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ logitNorm(logit.sd) + prop(prop.sd) + dt(df) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+t </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ logitNorm(logit.sd) + pow(pow.sd, exponent) + dt(df) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+t </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ logitNorm(logit.sd) + pow(pow.sd, exponent) + dt(df) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson(logit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + logitNorm(logit.sd) + dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson(logit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + logitNorm(NA) + prop(prop.sd) + dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson(logit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + logitNorm(NA) + pow(pow.sd, exponent) + dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+t </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> yeoJohnson(logit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + logitNorm(logit.sd) + prop(prop.sd) + dt(df) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+t </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> yeoJohnson(logit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + logitNorm(logit.sd) + prop(prop.sd) + dt(df) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+t </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> yeoJohnson(logit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + logitNorm(logit.sd) + pow(pow.sd, exponent) + dt(df) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+t </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> yeoJohnson(logit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + logitNorm(logit.sd) + pow(pow.sd, exponent) + dt(df) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   constant+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ probitNorm(probit.sd) + dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> probit </td><td style="text-align: left;"> var ~ probitNorm(NA) + prop(prop.sd) + dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> probit </td><td style="text-align: left;"> var ~ probitNorm(NA) + pow(pow.sd, exponent) + dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+t </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> probit </td><td style="text-align: left;"> var ~ probitNorm(probit.sd) + prop(prop.sd) + dt(df) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+t </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> probit </td><td style="text-align: left;"> var ~ probitNorm(probit.sd) + prop(prop.sd) + dt(df) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+t </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> probit </td><td style="text-align: left;"> var ~ probitNorm(probit.sd) + pow(pow.sd, exponent) + dt(df) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+t </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> probit </td><td style="text-align: left;"> var ~ probitNorm(probit.sd) + pow(pow.sd, exponent) + dt(df) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson(probit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + probitNorm(probit.sd) + dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson(probit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + probitNorm(NA) + prop(prop.sd) + dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson(probit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + probitNorm(NA) + pow(pow.sd, exponent) + dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+t </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> yeoJohnson(probit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + probitNorm(probit.sd) + prop(prop.sd) + dt(df) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+t </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> yeoJohnson(probit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + probitNorm(probit.sd) + prop(prop.sd) + dt(df) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+t </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> yeoJohnson(probit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + probitNorm(probit.sd) + pow(pow.sd, exponent) + dt(df) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+t </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> yeoJohnson(probit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + probitNorm(probit.sd) + pow(pow.sd, exponent) + dt(df) +combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   constant+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> None </td><td style="text-align: left;"> var ~ add(add.sd) + dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> None </td><td style="text-align: left;"> var ~ prop(prop.sd) + dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> None </td><td style="text-align: left;"> var ~ pow(pow.sd, exponent) + dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+cauchy </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> None </td><td style="text-align: left;"> var ~ add(add.sd) + prop(prop.sd) + dcauchy() + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+cauchy </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> None </td><td style="text-align: left;"> var ~ add(add.sd) + prop(prop.sd) + dcauchy() + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+cauchy </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> None </td><td style="text-align: left;"> var ~ add(add.sd) + pow(pow.sd, exponent) + dcauchy() +combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+cauchy </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> None </td><td style="text-align: left;"> var ~ add(add.sd) + pow(pow.sd, exponent) + dcauchy() +combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   constant+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> log </td><td style="text-align: left;"> var ~ lnorm(add.sd) + dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> log </td><td style="text-align: left;"> var ~ lnorm(NA) + prop(prop.sd) + dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> log </td><td style="text-align: left;"> var ~ lnorm(NA) + pow(pow.sd, exponent) + dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+cauchy </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> log </td><td style="text-align: left;"> var ~ lnorm(add.sd) + prop(prop.sd) + dcauchy() +combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+cauchy </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> log </td><td style="text-align: left;"> var ~ lnorm(add.sd) + prop(prop.sd) + dcauchy() + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+cauchy </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> log </td><td style="text-align: left;"> var ~ lnorm(add.sd) + pow(pow.sd, exponent) + dcauchy() + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+cauchy </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> log </td><td style="text-align: left;"> var ~ lnorm(add.sd) + pow(pow.sd, exponent) + dcauchy() + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   constant+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> boxCox </td><td style="text-align: left;"> var ~ boxCox(lambda) + add(add.sd)+dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> boxCox </td><td style="text-align: left;"> var ~ boxCox(lambda) + prop(prop.sd)+dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> boxCox </td><td style="text-align: left;"> var ~ boxCox(lambda) + pow(pow.sd, exponent)+dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+cauchy </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> boxCox </td><td style="text-align: left;"> var ~ boxCox(lambda) + add(add.sd) + prop(prop.sd) + dcauchy() + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+cauchy </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> boxCox </td><td style="text-align: left;"> var ~ boxCox(lambda) + add(add.sd) + prop(prop.sd) + dcauchy() + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+cauchy </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> boxCox </td><td style="text-align: left;"> var ~ boxCox(lambda) + add(add.sd) + pow(pop.sd, exponent) + dcauchy() + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+cauchy </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> boxCox </td><td style="text-align: left;"> var ~ boxCox(lambda) + add(add.sd) + pow(pop.sd, exponent) + dcauchy() + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   constant+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + add(add.sd) + dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + prop(prop.sd) + dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + pow(pow.sd, exponent) + dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+cauchy </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> yeoJohnson </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + add(add.sd) + prop(prop.sd) + dcauchy() + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+cauchy </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> yeoJohnson </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + add(add.sd) + prop(prop.sd) + dcauchy() + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+cauchy </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> yeoJohnson </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + add(add.sd) + pow(pop.sd, exponent) + dcauchy() + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+cauchy </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> yeoJohnson </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + add(add.sd) + pow(pop.sd, exponent) + dcauchy() + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   constant+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ logitNorm(logit.sd)+dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ logitNorm(NA) + prop(prop.sd)+dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ logitNorm(NA) + pow(pow.sd, exponent) + dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+cauchy </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ logitNorm(logit.sd) + prop(prop.sd) + dcauchy() + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+cauchy </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ logitNorm(logit.sd) + prop(prop.sd) + dcauchy() + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+cauchy </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ logitNorm(logit.sd) + pow(pow.sd, exponent) + dcauchy() + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+cauchy </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ logitNorm(logit.sd) + pow(pow.sd, exponent) + dcauchy() + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson(logit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + logitNorm(logit.sd) + dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson(logit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + logitNorm(NA) + prop(prop.sd) + dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson(logit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + logitNorm(NA) + pow(pow.sd, exponent) + dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+cauchy </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> yeoJohnson(logit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + logitNorm(logit.sd) + prop(prop.sd) + dcauchy() + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+cauchy </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> yeoJohnson(logit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + logitNorm(logit.sd) + prop(prop.sd) + dcauchy() + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+cauchy </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> yeoJohnson(logit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + logitNorm(logit.sd) + pow(pow.sd, exponent) + dcauchy() + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+cauchy </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> yeoJohnson(logit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + logitNorm(logit.sd) + pow(pow.sd, exponent) + dcauchy() + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   constant+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ probitNorm(probit.sd) + dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> probit </td><td style="text-align: left;"> var ~ probitNorm(NA) + prop(prop.sd) + dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> probit </td><td style="text-align: left;"> var ~ probitNorm(NA) + pow(pow.sd, exponent) + dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+cauchy </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> probit </td><td style="text-align: left;"> var ~ probitNorm(probit.sd) + prop(prop.sd) + dcauchy() + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+cauchy </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> probit </td><td style="text-align: left;"> var ~ probitNorm(probit.sd) + prop(prop.sd) + dcauchy() + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+cauchy </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> probit </td><td style="text-align: left;"> var ~ probitNorm(probit.sd) + pow(pow.sd, exponent) + dcauchy() + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+cauchy </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> probit </td><td style="text-align: left;"> var ~ probitNorm(probit.sd) + pow(pow.sd, exponent) + dcauchy() + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson(probit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + probitNorm(probit.sd) + dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson(probit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + probitNorm(NA) + prop(prop.sd) + dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson(probit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + probitNorm(NA) + pow(pow.sd, exponent) + dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+cauchy </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> yeoJohnson(probit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + probitNorm(probit.sd) + prop(prop.sd) + dcauchy() + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+cauchy </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> yeoJohnson(probit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + probitNorm(probit.sd) + prop(prop.sd) + dcauchy() + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+cauchy </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> yeoJohnson(probit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + probitNorm(probit.sd) + pow(pow.sd, exponent) + dcauchy() + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+cauchy </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> yeoJohnson(probit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + probitNorm(probit.sd) + pow(pow.sd, exponent) + dcauchy() +combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   poission </td><td style="text-align: left;">  </td><td style="text-align: left;"> none </td><td style="text-align: left;"> cmt ~ dpois(lamba) </td><td style="text-align: left;">  </td><td style="text-align: left;"> compartment specification </td>
</tr>
<tr>
 <td style="text-align: left;">
   binomial </td><td style="text-align: left;">  </td><td style="text-align: left;"> none </td><td style="text-align: left;"> cmt ~ dbinom(n, p) </td><td style="text-align: left;">  </td><td style="text-align: left;"> compartment specification </td>
</tr>
<tr>
 <td style="text-align: left;">
   beta </td><td style="text-align: left;">  </td><td style="text-align: left;"> none </td><td style="text-align: left;"> cmt ~ dbeta(alpha, beta) </td><td style="text-align: left;">  </td><td style="text-align: left;"> compartment specification </td>
</tr>
<tr>
 <td style="text-align: left;">
   chisq </td><td style="text-align: left;">  </td><td style="text-align: left;"> none </td><td style="text-align: left;"> cmt ~ dchisq(nu) </td><td style="text-align: left;">  </td><td style="text-align: left;"> compartment specification </td>
</tr>
<tr>
 <td style="text-align: left;">
   exponential </td><td style="text-align: left;">  </td><td style="text-align: left;"> none </td><td style="text-align: left;"> cmt ~ dexp(r) </td><td style="text-align: left;">  </td><td style="text-align: left;"> compartment specification </td>
</tr>
<tr>
 <td style="text-align: left;">
   uniform </td><td style="text-align: left;">  </td><td style="text-align: left;"> none </td><td style="text-align: left;"> cmt ~ dunif(a, b) </td><td style="text-align: left;">  </td><td style="text-align: left;"> compartment specification </td>
</tr>
<tr>
 <td style="text-align: left;">
   weibull </td><td style="text-align: left;">  </td><td style="text-align: left;"> none </td><td style="text-align: left;"> cmt ~ dweibull(a, b) </td><td style="text-align: left;">  </td><td style="text-align: left;"> compartment specification </td>
</tr>
<tr>
 <td style="text-align: left;">
   gamma </td><td style="text-align: left;">  </td><td style="text-align: left;"> none </td><td style="text-align: left;"> cmt ~ dgamma(a, b) </td><td style="text-align: left;">  </td><td style="text-align: left;"> compartment specification </td>
</tr>
<tr>
 <td style="text-align: left;">
   geometric </td><td style="text-align: left;">  </td><td style="text-align: left;"> none </td><td style="text-align: left;"> cmt ~ dgeom(a) </td><td style="text-align: left;">  </td><td style="text-align: left;"> compartment specification </td>
</tr>
<tr>
 <td style="text-align: left;">
   negative binomial form #1 </td><td style="text-align: left;">  </td><td style="text-align: left;"> none </td><td style="text-align: left;"> cmt ~ dnbinom(n, p) </td><td style="text-align: left;">  </td><td style="text-align: left;"> compartment specification </td>
</tr>
<tr>
 <td style="text-align: left;">
   negative binomial form #2 </td><td style="text-align: left;">  </td><td style="text-align: left;"> none </td><td style="text-align: left;"> cmt ~ dnbinomMu(size, mu) </td><td style="text-align: left;">  </td><td style="text-align: left;"> compartment specification </td>
</tr>
<tr>
 <td style="text-align: left;">
   ordinal probability </td><td style="text-align: left;">  </td><td style="text-align: left;"> none </td><td style="text-align: left;"> cmt ~ c(p0=0, p1=1, p2=2, 3) </td><td style="text-align: left;">  </td><td style="text-align: left;"> compartment specification </td>
</tr>
<tr>
 <td style="text-align: left;">
   log-likelihood </td><td style="text-align: left;">  </td><td style="text-align: left;"> none </td><td style="text-align: left;"> ll(cmt) ~ log likelihood expression </td><td style="text-align: left;">  </td><td style="text-align: left;"> likelihood + compartment expression </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>





<h3>Value</h3>

<p>An object (environment) of class <code>rxode2</code> (see Chambers and Temple Lang (2001))
consisting of the following list of strings and functions:
</p>
<div class="sourceCode"><pre>* `model` a character string holding the source model specification.
* `get.modelVars`a function that returns a list with 3 character
    vectors, `params`, `state`, and `lhs` of variable names used in the model
    specification. These will be output when the model is computed (i.e., the ODE solved by integration).

  * `solve`{this function solves (integrates) the ODE. This
      is done by passing the code to [rxSolve()].
      This is as if you called `rxSolve(rxode2object, ...)`,
      but returns a matrix instead of a rxSolve object.

      `params`: a numeric named vector with values for every parameter
      in the ODE system; the names must correspond to the parameter
      identifiers used in the ODE specification;

      `events`: an `eventTable` object describing the
      input (e.g., doses) to the dynamic system and observation
      sampling time points (see  [eventTable()]);

      `inits`: a vector of initial values of the state variables
      (e.g., amounts in each compartment), and the order in this vector
      must be the same as the state variables (e.g., PK/PD compartments);


      `stiff`: a logical (`TRUE` by default) indicating whether
      the ODE system is stiff or not.

      For stiff ODE systems (`stiff = TRUE`), `rxode2` uses
      the LSODA (Livermore Solver for Ordinary Differential Equations)
      Fortran package, which implements an automatic method switching
      for stiff and non-stiff problems along the integration interval,
      authored by Hindmarsh and Petzold (2003).

      For non-stiff systems (`stiff = FALSE`), `rxode2` uses `DOP853`,
      an explicit Runge-Kutta method of order 8(5, 3) of Dormand and Prince
      as implemented in C by Hairer and Wanner (1993).

      `trans_abs`: a logical (`FALSE` by default) indicating
      whether to fit a transit absorption term
      (TODO: need further documentation and example);

      `atol`: a numeric absolute tolerance (1e-08 by default);

      `rtol`: a numeric relative tolerance (1e-06 by default).

      The output of \dQuote{solve} is a matrix with as many rows as there
      are sampled time points and as many columns as system variables
      (as defined by the ODEs and additional assignments in the rxode2 model
          code).}

  * `isValid` a function that (naively) checks for model validity,
      namely that the C object code reflects the latest model
      specification.
  * `version` a string with the version of the `rxode2`
      object (not the package).
  * `dynLoad` a function with one `force = FALSE` argument
      that dynamically loads the object code if needed.
  * `dynUnload` a function with no argument that unloads
      the model object code.
  * `delete` removes all created model files, including C and DLL files.
      The model object is no longer valid and should be removed, e.g.,
      `rm(m1)`.
  * `run` deprecated, use `solve`.
  * `get.index` deprecated.
  * `getObj` internal (not user callable) function.
</pre></div>


<h3>Creating rxode2 models</h3>

<p>NA
</p>


<h3>Author(s)</h3>

<p>Melissa Hallow, Wenping Wang and Matthew Fidler
</p>


<h3>References</h3>

<p>Chamber, J. M. and Temple Lang, D. (2001)
<em>Object Oriented Programming in R</em>.
R News, Vol. 1, No. 3, September 2001.
<a href="https://cran.r-project.org/doc/Rnews/Rnews_2001-3.pdf">https://cran.r-project.org/doc/Rnews/Rnews_2001-3.pdf</a>.
</p>
<p>Hindmarsh, A. C.
<em>ODEPACK, A Systematized Collection of ODE Solvers</em>.
Scientific Computing, R. S. Stepleman et al. (Eds.),
North-Holland, Amsterdam, 1983, pp. 55-64.
</p>
<p>Petzold, L. R.
<em>Automatic Selection of Methods for Solving Stiff and Nonstiff
Systems of Ordinary Differential Equations</em>.
Siam J. Sci. Stat. Comput. 4 (1983), pp. 136-148.
</p>
<p>Hairer, E., Norsett, S. P., and Wanner, G.
<em>Solving ordinary differential equations I, nonstiff problems</em>.
2nd edition, Springer Series in Computational Mathematics,
Springer-Verlag (1993).
</p>
<p>Plevyak, J.
<em><code>dparser</code></em>, <a href="https://dparser.sourceforge.net/">https://dparser.sourceforge.net/</a>. Web. 12 Oct. 2015.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eventTable">eventTable()</a></code>, <code><a href="#topic+et">et()</a></code>, <code><a href="#topic+add.sampling">add.sampling()</a></code>, <code><a href="#topic+add.dosing">add.dosing()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

mod &lt;- function() {
  ini({
    KA   &lt;- .291
    CL   &lt;- 18.6
    V2   &lt;- 40.2
    Q    &lt;- 10.5
    V3   &lt;- 297.0
    Kin  &lt;- 1.0
    Kout &lt;- 1.0
    EC50 &lt;- 200.0
  })
  model({
    # A 4-compartment model, 3 PK and a PD (effect) compartment
    # (notice state variable names 'depot', 'centr', 'peri', 'eff')
    C2 &lt;- centr/V2
    C3 &lt;- peri/V3
    d/dt(depot) &lt;- -KA*depot;
    d/dt(centr) &lt;- KA*depot - CL*C2 - Q*C2 + Q*C3;
    d/dt(peri)  &lt;-                    Q*C2 - Q*C3;
    d/dt(eff)   &lt;- Kin - Kout*(1-C2/(EC50+C2))*eff;
    eff(0)      &lt;- 1
  })
}

m1 &lt;- rxode2(mod)
print(m1)

# Step 2 - Create the model input as an EventTable,
# including dosing and observation (sampling) events

# QD (once daily) dosing for 5 days.

qd &lt;- et(amountUnits = "ug", timeUnits = "hours") %&gt;%
  et(amt = 10000, addl = 4, ii = 24)

# Sample the system hourly during the first day, every 8 hours
# then after
qd &lt;- qd %&gt;% et(0:24) %&gt;%
  et(from = 24 + 8, to = 5 * 24, by = 8)

# Step 3 - solve the system

qd.cp &lt;- rxSolve(m1, qd)

head(qd.cp)



</code></pre>

<hr>
<h2 id='rxode2+26lt+3B-'>Set the function body of an rxUi object while retaining other object
information (like data)</h2><span id='topic+rxode2+3C-'></span><span id='topic+rxode2+3C-.function'></span><span id='topic+rxode2+3C-.default'></span><span id='topic+rxode+3C-'></span><span id='topic+RxODE+3C-'></span>

<h3>Description</h3>

<p>Set the function body of an rxUi object while retaining other object
information (like data)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxode2(x, envir = environment(x)) &lt;- value

## S3 replacement method for class ''function''
rxode2(x, envir = environment(x)) &lt;- value

## Default S3 replacement method:
rxode2(x, envir = environment(x)) &lt;- value

rxode(x, envir = environment(x)) &lt;- value

RxODE(x, envir = environment(x)) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxode2+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>The rxUi object</p>
</td></tr>
<tr><td><code id="rxode2+2B26lt+2B3B-_+3A_envir">envir</code></td>
<td>
<p>environment where the assignment ocurs</p>
</td></tr>
<tr><td><code id="rxode2+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>the value that will be assigned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The rxode2 ui/function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
one.compartment &lt;- function() {
  ini({
    tka &lt;- log(1.57); label("Ka")
    tcl &lt;- log(2.72); label("Cl")
    tv &lt;- log(31.5); label("V")
    eta.ka ~ 0.6
    eta.cl ~ 0.3
    eta.v ~ 0.1
    add.sd &lt;- 0.7
  })
  model({
    ka &lt;- exp(tka + eta.ka)
    cl &lt;- exp(tcl + eta.cl)
    v &lt;- exp(tv + eta.v)
    d/dt(depot) = -ka * depot
    d/dt(center) = ka * depot - cl / v * center
    cp = center / v
    cp ~ add(add.sd)
  })
}

two.compartment &lt;- function() {
  ini({
    lka &lt;- 0.45 ; label("Absorption rate (Ka)")
    lcl &lt;- 1 ; label("Clearance (CL)")
    lvc  &lt;- 3 ; label("Central volume of distribution (V)")
    lvp  &lt;- 5 ; label("Peripheral volume of distribution (Vp)")
    lq  &lt;- 0.1 ; label("Intercompartmental clearance (Q)")
    propSd &lt;- 0.5 ; label("Proportional residual error (fraction)")
  })
  model({
    ka &lt;- exp(lka)
    cl &lt;- exp(lcl)
    vc &lt;- exp(lvc)
    vp &lt;- exp(lvp)
    q  &lt;- exp(lq)
    kel &lt;- cl/vc
    k12 &lt;- q/vc
    k21 &lt;- q/vp
    d/dt(depot) &lt;- -ka*depot
    d/dt(central) &lt;-  ka*depot - kel*central - k12*central + k21*peripheral1
    d/dt(peripheral1) &lt;- k12*central - k21*peripheral1
    cp &lt;- central / vc
    cp ~ prop(propSd)
  })
}

ui &lt;- rxode2(one.compartment)

rxode2(ui) &lt;- two.compartment

</code></pre>

<hr>
<h2 id='rxOptExpr'>Optimize rxode2 for computer evaluation</h2><span id='topic+rxOptExpr'></span>

<h3>Description</h3>

<p>This optimizes rxode2 code for computer evaluation by only
calculating redundant expressions once.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxOptExpr(x, msg = "model")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxOptExpr_+3A_x">x</code></td>
<td>
<p>rxode2 model that can be accessed by rxNorm</p>
</td></tr>
<tr><td><code id="rxOptExpr_+3A_msg">msg</code></td>
<td>
<p>This is the name of type of object that rxode2 is
optimizing that will in the message when optimizing.  For
example &quot;model&quot; will produce the following message while
optimizing the model:
</p>
<p>finding duplicate expressions in model...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Optimized rxode2 model text.  The order and type lhs and
state variables is maintained while the evaluation is sped up.
While parameters names are maintained, their order may be
modified.
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxord'>Simulate ordinal value</h2><span id='topic+rxord'></span>

<h3>Description</h3>

<p>Simulate ordinal value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxord(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxord_+3A_...">...</code></td>
<td>
<p>the probabilities to be simulated.  These should sum up to a number below one.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values entered into the 'rxord' simulation will simulate the
probability of falling each group. If it falls outside of the
specified probabilities, it will simulate the group (number of
probabilities specified + 1)
</p>


<h3>Value</h3>

<p>A number from 1 to the (number of probabilities specified + 1)
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# This will give values 1, and 2
rxord(0.5)
rxord(0.5)
rxord(0.5)
rxord(0.5)

# This will give values 1, 2 and 3
rxord(0.3, 0.3)
rxord(0.3, 0.3)
rxord(0.3, 0.3)

</code></pre>

<hr>
<h2 id='rxParams'>Parameters specified by the model</h2><span id='topic+rxParams'></span><span id='topic+rxParams.rxode2'></span><span id='topic+rxParams.rxSolve'></span><span id='topic+rxParams.rxEt'></span><span id='topic+rxParam'></span>

<h3>Description</h3>

<p>This returns the model's parameters that are required to solve the
ODE system, and can be used to pipe parameters into an rxode2 solve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxParams(obj, ...)

## S3 method for class 'rxode2'
rxParams(
  obj,
  constants = TRUE,
  ...,
  params = NULL,
  inits = NULL,
  iCov = NULL,
  keep = NULL,
  thetaMat = NULL,
  omega = NULL,
  dfSub = NULL,
  sigma = NULL,
  dfObs = NULL,
  nSub = NULL,
  nStud = NULL
)

## S3 method for class 'rxSolve'
rxParams(
  obj,
  constants = TRUE,
  ...,
  params = NULL,
  inits = NULL,
  iCov = NULL,
  keep = NULL,
  thetaMat = NULL,
  omega = NULL,
  dfSub = NULL,
  sigma = NULL,
  dfObs = NULL,
  nSub = NULL,
  nStud = NULL
)

## S3 method for class 'rxEt'
rxParams(
  obj,
  ...,
  params = NULL,
  inits = NULL,
  iCov = NULL,
  keep = NULL,
  thetaMat = NULL,
  omega = NULL,
  dfSub = NULL,
  sigma = NULL,
  dfObs = NULL,
  nSub = NULL,
  nStud = NULL
)

rxParam(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxParams_+3A_obj">obj</code></td>
<td>
<p>rxode2 family of objects</p>
</td></tr>
<tr><td><code id="rxParams_+3A_...">...</code></td>
<td>
<p>Other arguments including scaling factors for each
compartment.  This includes S# = numeric will scale a compartment
# by a dividing the compartment amount by the scale factor,
like NONMEM.</p>
</td></tr>
<tr><td><code id="rxParams_+3A_constants">constants</code></td>
<td>
<p>is a boolean indicting if constants should be
included in the list of parameters. Currently rxode2 parses
constants into variables in case you wish to change them
without recompiling the rxode2 model.</p>
</td></tr>
<tr><td><code id="rxParams_+3A_params">params</code></td>
<td>
<p>a numeric named vector with values for every
parameter in the ODE system; the names must correspond to the
parameter identifiers used in the ODE specification;</p>
</td></tr>
<tr><td><code id="rxParams_+3A_inits">inits</code></td>
<td>
<p>a vector of initial values of the state variables
(e.g., amounts in each compartment), and the order in this
vector must be the same as the state variables (e.g., PK/PD
compartments);</p>
</td></tr>
<tr><td><code id="rxParams_+3A_icov">iCov</code></td>
<td>
<p>A data frame of individual non-time varying covariates
to combine with the <code>events</code> dataset by merge.</p>
</td></tr>
<tr><td><code id="rxParams_+3A_keep">keep</code></td>
<td>
<p>Columns to keep from either the input dataset or the
<code>iCov</code> dataset.  With the <code>iCov</code> dataset, the column
is kept once per line.  For the input dataset, if any records
are added to the data LOCF (Last Observation Carried forward)
imputation is performed.</p>
</td></tr>
<tr><td><code id="rxParams_+3A_thetamat">thetaMat</code></td>
<td>
<p>Named theta matrix.</p>
</td></tr>
<tr><td><code id="rxParams_+3A_omega">omega</code></td>
<td>
<p>Estimate of Covariance matrix. When omega is a list,
assume it is a block matrix and convert it to a full matrix for
simulations.  When <code>omega</code> is <code>NA</code> and you are using it with a
<code>rxode2</code> ui model, the between subject variability described by
the <code>omega</code> matrix are set to zero.</p>
</td></tr>
<tr><td><code id="rxParams_+3A_dfsub">dfSub</code></td>
<td>
<p>Degrees of freedom to sample the between subject variability matrix from the
inverse Wishart distribution (scaled) or scaled inverse chi squared distribution.</p>
</td></tr>
<tr><td><code id="rxParams_+3A_sigma">sigma</code></td>
<td>
<p>Named sigma covariance or Cholesky decomposition of a
covariance matrix.  The names of the columns indicate
parameters that are simulated.  These are simulated for every
observation in the solved system. When <code>sigma</code> is <code>NA</code> and you are using it with a
<code>rxode2</code> ui model, the unexplained variability described by
the <code>sigma</code> matrix are set to zero.</p>
</td></tr>
<tr><td><code id="rxParams_+3A_dfobs">dfObs</code></td>
<td>
<p>Degrees of freedom to sample the unexplained variability matrix from the
inverse Wishart distribution (scaled) or scaled inverse chi squared distribution.</p>
</td></tr>
<tr><td><code id="rxParams_+3A_nsub">nSub</code></td>
<td>
<p>Number between subject variabilities (<code>ETAs</code>) simulated for every
realization of the parameters.</p>
</td></tr>
<tr><td><code id="rxParams_+3A_nstud">nStud</code></td>
<td>
<p>Number virtual studies to characterize uncertainty in estimated
parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When extracting the parameters from an rxode2 model, a
character vector listing the parameters in the model.
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>


<h3>See Also</h3>

<p>Other Query model information: 
<code><a href="#topic+rxDfdy">rxDfdy</a>()</code>,
<code><a href="#topic+rxInits">rxInits</a>()</code>,
<code><a href="#topic+rxLhs">rxLhs</a>()</code>,
<code><a href="#topic+rxModelVars">rxModelVars</a>()</code>,
<code><a href="#topic+rxState">rxState</a>()</code>
</p>

<hr>
<h2 id='rxParseErr'>Prepare Error function for inclusion in rxode2</h2><span id='topic+rxParseErr'></span>

<h3>Description</h3>

<p>Prepare Error function for inclusion in rxode2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxParseErr(
  x,
  baseTheta,
  ret = "rx_r_",
  init = NULL,
  addProp = c("combined2", "combined1")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxParseErr_+3A_x">x</code></td>
<td>
<p>error function</p>
</td></tr>
<tr><td><code id="rxParseErr_+3A_basetheta">baseTheta</code></td>
<td>
<p>Base theta to start numbering add(.) and prop(.) from.</p>
</td></tr>
<tr><td><code id="rxParseErr_+3A_ret">ret</code></td>
<td>
<p>Internal return type.  Should not be changed by the user...</p>
</td></tr>
<tr><td><code id="rxParseErr_+3A_init">init</code></td>
<td>
<p>Initialization vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rxode2 transformed text
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxParsePk'>Parse PK function for inclusion in rxode2</h2><span id='topic+rxParsePk'></span>

<h3>Description</h3>

<p>Parse PK function for inclusion in rxode2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxParsePk(x, init = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxParsePk_+3A_x">x</code></td>
<td>
<p>PK function</p>
</td></tr>
<tr><td><code id="rxParsePk_+3A_init">init</code></td>
<td>
<p>Initialization vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rxode2 transformed text.
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxParsePred'>Prepare Pred function for inclusion in rxode2</h2><span id='topic+rxParsePred'></span>

<h3>Description</h3>

<p>Prepare Pred function for inclusion in rxode2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxParsePred(x, init = NULL, err = NULL, addProp = c("combined2", "combined1"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxParsePred_+3A_x">x</code></td>
<td>
<p>pred function</p>
</td></tr>
<tr><td><code id="rxParsePred_+3A_init">init</code></td>
<td>
<p>Initialization vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rxode2 transformed text.
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxPkg'>Creates a package from compiled rxode2 models</h2><span id='topic+rxPkg'></span>

<h3>Description</h3>

<p>Creates a package from compiled rxode2 models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxPkg(
  ...,
  package,
  wd = getwd(),
  action = c("install", "build", "binary", "create"),
  license = c("gpl3", "lgpl", "mit", "agpl3"),
  name = "Firstname Lastname",
  fields = list()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxPkg_+3A_...">...</code></td>
<td>
<p>Models to build a package from</p>
</td></tr>
<tr><td><code id="rxPkg_+3A_package">package</code></td>
<td>
<p>String of the package name to create</p>
</td></tr>
<tr><td><code id="rxPkg_+3A_wd">wd</code></td>
<td>
<p>character string with a working directory where to
create a subdirectory according to <code>modName</code>. When
specified, a subdirectory named after the
&ldquo;<code>modName.d</code>&rdquo; will be created and populated with a
C file, a dynamic loading library, plus various other working
files. If missing, the files are created (and removed) in the
temporary directory, and the rxode2 DLL for the model is
created in the current directory named <code style="white-space: pre;">&#8288;rx_????_platform&#8288;</code>, for
example <code>rx_129f8f97fb94a87ca49ca8dafe691e1e_i386.dll</code></p>
</td></tr>
<tr><td><code id="rxPkg_+3A_action">action</code></td>
<td>
<p>Type of action to take after package is created</p>
</td></tr>
<tr><td><code id="rxPkg_+3A_license">license</code></td>
<td>
<p>is the type of license for the package.</p>
</td></tr>
<tr><td><code id="rxPkg_+3A_name">name</code></td>
<td>
<p>Full name of author</p>
</td></tr>
<tr><td><code id="rxPkg_+3A_fields">fields</code></td>
<td>
<p>A named list of fields to add to <code>DESCRIPTION</code>, potentially
overriding default values. See <code><a href="usethis.html#topic+use_description">use_description()</a></code> for how you can set
personalized defaults using package options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>this function returns nothing and is used for its side effects
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='rxpois'>Simulate random Poisson variable from threefry generator</h2><span id='topic+rxpois'></span>

<h3>Description</h3>

<p>Care should be taken with this method not to encounter the
birthday problem, described
<a href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/">https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/</a>.
Since the <code>sitmo</code> <code>threefry</code>, this currently generates
one random deviate from the uniform distribution to seed the
engine <code>threefry</code> and then run the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxpois(lambda, n = 1L, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxpois_+3A_lambda">lambda</code></td>
<td>
<p>vector of (non-negative) means.</p>
</td></tr>
<tr><td><code id="rxpois_+3A_n">n</code></td>
<td>
<p>number of random values to return.</p>
</td></tr>
<tr><td><code id="rxpois_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the simulation
</p>
<p><code>rxnorm</code> simulates using the threefry sitmo generator.
</p>
<p><code>rxnormV</code> used to simulate with the vandercorput simulator, but
since it didn't satisfy the normal properties it was changed to simple be
an alias of <code>rxnorm</code>. It is no longer supported in <code>rxode2({})</code> blocks</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Therefore, a simple call to the random number generated followed by a second
call to random number generated may have identical seeds.  As the number of
random number generator calls are increased the probability that the
birthday problem will increase.
</p>
<p>The key to avoid this problem is to either run all simulations in the
<code>rxode2</code> environment once (therefore one seed or series of seeds
for the whole simulation), pre-generate all random variables
used for the simulation, or seed the rxode2 engine with <code>rxSetSeed()</code>
</p>
<p>Internally each ID is seeded with a unique number so that the
results do not depend on the number of cores used.
</p>


<h3>Value</h3>

<p>poission random number deviates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Use threefry engine

rxpois(lambda = 3, n = 10) # with rxpois you have to explicitly state n
rxpois(lambda = 3, n = 10, ncores = 2) # You can parallelize the simulation using openMP

rxpois(4) ## The first arguments are the lambda parameter


## This example uses `rxpois` directly in the model

rx &lt;- function() {
  model({
    a &lt;- rxpois(3)
  })
}

et &lt;- et(1, id = 1:2)

s &lt;- rxSolve(rx, et)

</code></pre>

<hr>
<h2 id='rxPp'>Simulate a from a Poisson process</h2><span id='topic+rxPp'></span>

<h3>Description</h3>

<p>Simulate a from a Poisson process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxPp(
  n,
  lambda,
  gamma = 1,
  prob = NULL,
  t0 = 0,
  tmax = Inf,
  randomOrder = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxPp_+3A_n">n</code></td>
<td>
<p>Number of time points to simulate in the Poisson process</p>
</td></tr>
<tr><td><code id="rxPp_+3A_lambda">lambda</code></td>
<td>
<p>Rate of Poisson process</p>
</td></tr>
<tr><td><code id="rxPp_+3A_gamma">gamma</code></td>
<td>
<p>Asymmetry rate of Poisson process.  When gamma=1.0,
this simulates a homogenous Poisson process.  When gamma&lt;1.0,
the Poisson process has more events early, when gamma &gt; 1.0,
the Poisson process has more events late in the process.
</p>
<p>When gamma is non-zero, the tmax should not be infinite but indicate
the end of the Poisson process to be simulated.  In most
pharamcometric cases, this will be the end of the study.
Internally this uses a rate of:
</p>
<p>l(t) = lambda<em>gamma</em>(t/tmax)^(gamma-1)</p>
</td></tr>
<tr><td><code id="rxPp_+3A_prob">prob</code></td>
<td>
<p>When specified, this is a probability function with
one argument, time, that gives the probability that a Poisson
time t is accepted as a rejection time.</p>
</td></tr>
<tr><td><code id="rxPp_+3A_t0">t0</code></td>
<td>
<p>the starting time of the Poisson process</p>
</td></tr>
<tr><td><code id="rxPp_+3A_tmax">tmax</code></td>
<td>
<p>the maximum time of the Poisson process</p>
</td></tr>
<tr><td><code id="rxPp_+3A_randomorder">randomOrder</code></td>
<td>
<p>when <code>TRUE</code> randomize the order of the Poisson
events.  By default (<code>FALSE</code>) it returns the Poisson process is
in order of how the events occurred.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This returns a vector of the Poisson process times; If the dropout is &gt;=
tmax, then all the rest of the times are = tmax to indicate the
dropout is equal to or after tmax.
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Sample homogenous Poisson process of rate 1/10
rxPp(10, 1 / 10)

## Sample inhomogenous Poisson rate of 1/10

rxPp(10, 1 / 10, gamma = 2, tmax = 100)

## Typically the Poisson process times are in a sequential order,
## using randomOrder gives the Poisson process in random order

rxPp(10, 1 / 10, gamma = 2, tmax = 10, randomOrder = TRUE)

## This uses an arbitrary function to sample a non-homogenous Poisson process

rxPp(10, 1 / 10, prob = function(x) {
  1/(1+abs(x))
})

</code></pre>

<hr>
<h2 id='rxPreferredDistributionName'>Change distribution name to the preferred distribution name term</h2><span id='topic+rxPreferredDistributionName'></span>

<h3>Description</h3>

<p>This is determined by the internal preferred condition name list
<code>.errIdenticalDists</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxPreferredDistributionName(dist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxPreferredDistributionName_+3A_dist">dist</code></td>
<td>
<p>This is the input distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Preferred distribution term
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rxPreferredDistributionName("dt")

rxPreferredDistributionName("add")

# can be vectorized

rxPreferredDistributionName(c("add","dt"))

</code></pre>

<hr>
<h2 id='rxProgress'>rxode2 progress bar functions</h2><span id='topic+rxProgress'></span><span id='topic+rxTick'></span><span id='topic+rxProgressStop'></span><span id='topic+rxProgressAbort'></span>

<h3>Description</h3>

<p><code>rxProgress</code> sets up the progress bar
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxProgress(num, core = 0L)

rxTick()

rxProgressStop(clear = TRUE)

rxProgressAbort(error = "Aborted calculation")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxProgress_+3A_num">num</code></td>
<td>
<p>Tot number of operations to track</p>
</td></tr>
<tr><td><code id="rxProgress_+3A_core">core</code></td>
<td>
<p>Number of cores to show.  If below 1, don't show
number of cores</p>
</td></tr>
<tr><td><code id="rxProgress_+3A_clear">clear</code></td>
<td>
<p>Boolean telling if you should clear the progress bar
after completion (as if it wasn't displayed).  By default this is TRUE</p>
</td></tr>
<tr><td><code id="rxProgress_+3A_error">error</code></td>
<td>
<p>With rxProgressAbort this is the error that is displayed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rxTick</code> is a progress bar tick
</p>
<p><code>rxProgressStop</code> stop progress bar
</p>
<p><code>rxProgressAbort</code> shows an abort if <code>rxProgressStop</code>
wasn't called.
</p>


<h3>Value</h3>

<p>All return NULL invisibly.
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
f &lt;- function() {
  on.exit({
    rxProgressAbort()
  })
  rxProgress(100)
  for (i in 1:100) {
    rxTick()
    Sys.sleep(1 / 100)
  }
  rxProgressStop()
}

f()


</code></pre>

<hr>
<h2 id='rxPrune'>Prune branches (ie if/else) from rxode2</h2><span id='topic+rxPrune'></span>

<h3>Description</h3>

<p>This prunes branches (ie if/else) from rxode2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxPrune(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxPrune_+3A_x">x</code></td>
<td>
<p>rxode2 model that can be accessed by rxNorm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Pruned rxode2 model text.
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxReload'>Reload rxode2 DLL</h2><span id='topic+rxReload'></span>

<h3>Description</h3>

<p>Can be useful for debugging
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxReload()
</code></pre>


<h3>Value</h3>

<p>boolean of if the object is reloaded
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxRemoveControl'>rxRemoveControl options for UI object</h2><span id='topic+rxRemoveControl'></span>

<h3>Description</h3>

<p>rxRemoveControl options for UI object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxRemoveControl(ui)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxRemoveControl_+3A_ui">ui</code></td>
<td>
<p>rxode2 ui object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, called for side effects
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxRename'>Rename items inside of a <code>rxode2</code> ui model</h2><span id='topic+rxRename'></span><span id='topic+.rxRename'></span><span id='topic+rename.rxUi'></span><span id='topic+rename.function'></span><span id='topic+rxRename.rxUi'></span><span id='topic+rxRename.function'></span><span id='topic+rxRename.default'></span>

<h3>Description</h3>

<p><code>rxRename()</code> changes the names of individual variables, lhs, and ode states using
<code>new_name = old_name</code> syntax
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxRename(.data, ..., envir = parent.frame())

.rxRename(.data, ..., envir = parent.frame())

rename.rxUi(.data, ...)

rename.function(.data, ...)

## S3 method for class 'rxUi'
rxRename(.data, ...)

## S3 method for class ''function''
rxRename(.data, ...)

## Default S3 method:
rxRename(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxRename_+3A_.data">.data</code></td>
<td>
<p>rxode2 ui function, named data to be consistent with <code>dplyr::rename()</code></p>
</td></tr>
<tr><td><code id="rxRename_+3A_...">...</code></td>
<td>
<p>rename items</p>
</td></tr>
<tr><td><code id="rxRename_+3A_envir">envir</code></td>
<td>
<p>Environment for evaluation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is similar to <code>dplyr</code>'s <code>rename()</code> function.  When <code>dplyr</code> is
loaded, the <code>s3</code> methods work for the ui objects.
</p>
<p>Note that the <code>.rxRename()</code> is the internal function that is called
when renaming and is likely not what you need to call unless you
are writing your own extension of the function
</p>


<h3>Value</h3>

<p>New model with items renamed
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ocmt &lt;- function() {
  ini({
    tka &lt;- exp(0.45) # Ka
    tcl &lt;- exp(1) # Cl
    ## This works with interactive models
    ## You may also label the preceding line with label("label text")
    tv &lt;- exp(3.45) # log V
    ## the label("Label name") works with all models
    add.sd &lt;- 0.7
  })
  model({
    ka &lt;- tka
    cl &lt;- tcl
    v &lt;- tv
    d/dt(depot) = -ka * depot
    d/dt(center) = ka * depot - cl / v * center
    cp = center / v
    cp ~ add(add.sd)
  })
}

ocmt %&gt;% rxRename(cpParent=cp)

</code></pre>

<hr>
<h2 id='rxRepR0_'>Rep R0 for foce</h2><span id='topic+rxRepR0_'></span>

<h3>Description</h3>

<p>Rep R0 for foce
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxRepR0_(neta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxRepR0__+3A_neta">neta</code></td>
<td>
<p>ETA to substitute</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a string of R code to substitute the rx_r expression in the symengine environment .s
</p>

<hr>
<h2 id='rxReservedKeywords'>A list and description of rxode2 supported reserved keywords</h2><span id='topic+rxReservedKeywords'></span>

<h3>Description</h3>

<p>A list and description of rxode2 supported reserved keywords
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxReservedKeywords
</code></pre>


<h3>Format</h3>

<p>A data frame with 3 columns and 31 rows
</p>

<dl>
<dt>Reserved Name</dt><dd><p>Reserved Keyword Name</p>
</dd>
<dt>Meaning</dt><dd><p>Reserved Keyword Meaning</p>
</dd>
<dt>Alias</dt><dd><p>Keyword Alias</p>
</dd>
</dl>


<hr>
<h2 id='rxResidualError'>A description of Rode2 supported residual errors</h2><span id='topic+rxResidualError'></span>

<h3>Description</h3>

<p>A description of Rode2 supported residual errors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxResidualError
</code></pre>


<h3>Format</h3>

<p>A data frame with 6 columns and 181 rows
</p>

<dl>
<dt>Error model</dt><dd><p>A description of the type of residual error</p>
</dd>
<dt>Functional Form</dt><dd><p>For additive and proportional what functional form is used</p>
</dd>
<dt>Transformation</dt><dd><p>The type of transformation that is done on the DV and the prediction</p>
</dd>
<dt>code</dt><dd><p>Example code for the residual error type</p>
</dd>
<dt>addProp</dt><dd><p>The type of add+prop residual error default that would be equivalent</p>
</dd>
<dt>lhs</dt><dd><p>what the left handed side of the specification represents, either a response variable, or a compartment specification</p>
</dd>
</dl>


<hr>
<h2 id='rxS'>Load a model into a symengine environment</h2><span id='topic+rxS'></span>

<h3>Description</h3>

<p>Load a model into a symengine environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxS(x, doConst = TRUE, promoteLinSens = FALSE, envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxS_+3A_x">x</code></td>
<td>
<p>rxode2 object</p>
</td></tr>
<tr><td><code id="rxS_+3A_doconst">doConst</code></td>
<td>
<p>Load constants into the environment as well.</p>
</td></tr>
<tr><td><code id="rxS_+3A_promotelinsens">promoteLinSens</code></td>
<td>
<p>Promote solved linear compartment systems to
sensitivity-based solutions.</p>
</td></tr>
<tr><td><code id="rxS_+3A_envir">envir</code></td>
<td>
<p>default is <code>NULL</code>; Environment to put symengine
variables in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rxode2/symengine environment
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='rxSetControl'>rxSetControl options for UI object</h2><span id='topic+rxSetControl'></span>

<h3>Description</h3>

<p>rxSetControl options for UI object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSetControl(ui, control)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxSetControl_+3A_ui">ui</code></td>
<td>
<p>rxode2 ui object</p>
</td></tr>
<tr><td><code id="rxSetControl_+3A_control">control</code></td>
<td>
<p>Default value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, called for side effects
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxSetCovariateNamesForPiping'>Assign covariates for piping</h2><span id='topic+rxSetCovariateNamesForPiping'></span>

<h3>Description</h3>

<p>Assign covariates for piping
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSetCovariateNamesForPiping(covariates = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxSetCovariateNamesForPiping_+3A_covariates">covariates</code></td>
<td>
<p>NULL (for no covariates), or the list of
covariates. nlmixr uses this function to set covariates if you
pipe from a nlmixr fit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, called for side effects
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# First set the name of known covariates
# Note this is case sensitive

rxSetCovariateNamesForPiping(c("WT","HT", "TC"))

one.compartment &lt;- function() {
 ini({
   tka &lt;- 0.45 ; label("Log Ka")
   tcl &lt;- 1 ; label("Log Cl")
   tv &lt;- 3.45 ; label("Log V")
   eta.ka ~ 0.6
   eta.cl ~ 0.3
   eta.v ~ 0.1
   add.err &lt;- 0.7
 })
 model({
   ka &lt;- exp(tka + eta.ka)
   cl &lt;- exp(tcl + eta.cl)
   v &lt;- exp(tv + eta.v)
   d / dt(depot) &lt;- -ka * depot
   d/dt(depot) &lt;- -ka * depot
   d / dt(center) &lt;- ka * depot - cl / v * center
   cp &lt;- center / v
   cp ~ add(add.err)
 })
}

# now TC is detected as a covariate instead of a population parameter

one.compartment %&gt;%
  model({ka &lt;- exp(tka + eta.ka + TC * cov_C)})

# You can turn it off by simply adding it back

rxSetCovariateNamesForPiping()

one.compartment %&gt;%
  model({ka &lt;- exp(tka + eta.ka + TC * cov_C)})

# The covariates you set with `rxSetCovariateNamesForPiping()`
# are turned off every time you solve (or fit in nlmixr)

</code></pre>

<hr>
<h2 id='rxSetPipingAuto'>Set the variables for the model piping automatic covarite selection</h2><span id='topic+rxSetPipingAuto'></span>

<h3>Description</h3>

<p>Set the variables for the model piping automatic covarite selection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSetPipingAuto(
  thetamodelVars = rex::rex(or("tv", "t", "pop", "POP", "Pop", "TV", "T", "cov", "err",
    "eff")),
  covariateExceptions = rex::rex(start, or("wt", "sex", "crcl", "kout"), end),
  etaParts = c("eta", "ETA", "Eta", "ppv", "PPV", "Ppv", "iiv", "Iiv", "bsv", "Bsv",
    "BSV", "bpv", "Bpv", "BPV", "psv", "PSV", "Psv")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxSetPipingAuto_+3A_thetamodelvars">thetamodelVars</code></td>
<td>
<p>This is the prefixes for the theta model
variables in a regular expression</p>
</td></tr>
<tr><td><code id="rxSetPipingAuto_+3A_covariateexceptions">covariateExceptions</code></td>
<td>
<p>This is a regular expression of
covariates that should always be covariates</p>
</td></tr>
<tr><td><code id="rxSetPipingAuto_+3A_etaparts">etaParts</code></td>
<td>
<p>This is the list of eta prefixes/post-fixes that
identify a variable as a between subject variability</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is called once at startup to set the defaults, though you can
change this if you wish so that piping can work differently for
your individual setup
</p>


<h3>Value</h3>

<p>Nothing, called for side effects
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxSetProd'>Defunct setting of product</h2><span id='topic+rxSetProd'></span>

<h3>Description</h3>

<p>Defunct setting of product
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSetProd(type = c("long double", "double", "logify"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxSetProd_+3A_type">type</code></td>
<td>
<p>used to be type of product</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>

<hr>
<h2 id='rxSetProgressBar'>Set timing for progress bar</h2><span id='topic+rxSetProgressBar'></span>

<h3>Description</h3>

<p>Set timing for progress bar
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSetProgressBar(seconds = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxSetProgressBar_+3A_seconds">seconds</code></td>
<td>
<p>This sets the number of seconds that need to elapse
before drawing the next segment of the progress bar.  When
this is zero or below this turns off the progress bar.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing, used for side effects
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='rxSetSilentErr'>Silence some of rxode2's C/C++ messages</h2><span id='topic+rxSetSilentErr'></span>

<h3>Description</h3>

<p>Silence some of rxode2's C/C++ messages
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSetSilentErr(silent)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxSetSilentErr_+3A_silent">silent</code></td>
<td>
<p>can be 0L &quot;noisy&quot;  or 1L &quot;silent&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE; called for side effects
</p>

<hr>
<h2 id='rxSetSum'>Defunct setting of sum</h2><span id='topic+rxSetSum'></span>

<h3>Description</h3>

<p>Defunct setting of sum
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSetSum(type = c("pairwise", "fsum", "kahan", "neumaier", "c"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxSetSum_+3A_type">type</code></td>
<td>
<p>used to be type of product</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>

<hr>
<h2 id='rxSetupIni'>Setup the initial conditions.</h2><span id='topic+rxSetupIni'></span>

<h3>Description</h3>

<p>Setup the initial conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSetupIni(obj, inits = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxSetupIni_+3A_obj">obj</code></td>
<td>
<p>rxode2 object</p>
</td></tr>
<tr><td><code id="rxSetupIni_+3A_inits">inits</code></td>
<td>
<p>A numeric vector of initial conditions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>initial conditions that were setup
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxSetupScale'>Setup the initial conditions.</h2><span id='topic+rxSetupScale'></span>

<h3>Description</h3>

<p>Setup the initial conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSetupScale(obj, scale = NULL, extraArgs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxSetupScale_+3A_obj">obj</code></td>
<td>
<p>rxode2 object</p>
</td></tr>
<tr><td><code id="rxSetupScale_+3A_scale">scale</code></td>
<td>
<p>A numeric vector scales</p>
</td></tr>
<tr><td><code id="rxSetupScale_+3A_extraargs">extraArgs</code></td>
<td>
<p>A list of extra args to parse for initial conditions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>setup scale for changing compartment values
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxShiny'>Use Shiny to help develop an rxode2 model</h2><span id='topic+rxShiny'></span><span id='topic+rxShiny.rxSolve'></span><span id='topic+rxShiny.default'></span>

<h3>Description</h3>

<p>Use Shiny to help develop an rxode2 model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxShiny(
  object,
  params = NULL,
  events = NULL,
  inits = NULL,
  ...,
  data = data.frame()
)

## S3 method for class 'rxSolve'
rxShiny(
  object,
  params = NULL,
  events = NULL,
  inits = NULL,
  ...,
  data = data.frame()
)

## Default S3 method:
rxShiny(
  object = NULL,
  params = NULL,
  events = NULL,
  inits = NULL,
  ...,
  data = data.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxShiny_+3A_object">object</code></td>
<td>
<p>A rxode2 family of objects. If not supplied a
2-compartment indirect effect model is used.  If it is
supplied, use the model associated with the rxode2 object for
the model exploration.</p>
</td></tr>
<tr><td><code id="rxShiny_+3A_params">params</code></td>
<td>
<p>Initial parameters for model</p>
</td></tr>
<tr><td><code id="rxShiny_+3A_events">events</code></td>
<td>
<p>Event information (currently ignored)</p>
</td></tr>
<tr><td><code id="rxShiny_+3A_inits">inits</code></td>
<td>
<p>Initial estimates for model</p>
</td></tr>
<tr><td><code id="rxShiny_+3A_...">...</code></td>
<td>
<p>Other arguments passed to rxShiny.  Currently doesn't
do anything.</p>
</td></tr>
<tr><td><code id="rxShiny_+3A_data">data</code></td>
<td>
<p>Any data that you would like to plot.  If the data has
a <code>time</code> variable as well as a compartment or calculated
variable that matches the rxode2 model, the data will be added
to the plot of a specific compartment or calculated variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing; Starts a shiny server
</p>


<h3>Author(s)</h3>

<p>Zufar Mulyukov and Matthew L. Fidler
</p>

<hr>
<h2 id='rxSimThetaOmega'>Simulate Parameters from a Theta/Omega specification</h2><span id='topic+rxSimThetaOmega'></span>

<h3>Description</h3>

<p>Simulate Parameters from a Theta/Omega specification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSimThetaOmega(
  params = NULL,
  omega = NULL,
  omegaDf = NULL,
  omegaLower = as.numeric(c(R_NegInf)),
  omegaUpper = as.numeric(c(R_PosInf)),
  omegaIsChol = FALSE,
  omegaSeparation = "auto",
  omegaXform = 1L,
  nSub = 1L,
  thetaMat = NULL,
  thetaLower = as.numeric(c(R_NegInf)),
  thetaUpper = as.numeric(c(R_PosInf)),
  thetaDf = NULL,
  thetaIsChol = FALSE,
  nStud = 1L,
  sigma = NULL,
  sigmaLower = as.numeric(c(R_NegInf)),
  sigmaUpper = as.numeric(c(R_PosInf)),
  sigmaDf = NULL,
  sigmaIsChol = FALSE,
  sigmaSeparation = "auto",
  sigmaXform = 1L,
  nCoresRV = 1L,
  nObs = 1L,
  dfSub = 0,
  dfObs = 0,
  simSubjects = TRUE,
  simVariability = as.logical(c(NA_LOGICAL))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxSimThetaOmega_+3A_params">params</code></td>
<td>
<p>Named Vector of rxode2 model parameters</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_omega">omega</code></td>
<td>
<p>Estimate of Covariance matrix. When omega is a list,
assume it is a block matrix and convert it to a full matrix for
simulations.  When <code>omega</code> is <code>NA</code> and you are using it with a
<code>rxode2</code> ui model, the between subject variability described by
the <code>omega</code> matrix are set to zero.</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_omegadf">omegaDf</code></td>
<td>
<p>The degrees of freedom of a t-distribution for
simulation.  By default this is <code>NULL</code> which is
equivalent to <code>Inf</code> degrees, or to simulate from a normal
distribution instead of a t-distribution.</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_omegalower">omegaLower</code></td>
<td>
<p>Lower bounds for simulated ETAs (by default -Inf)</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_omegaupper">omegaUpper</code></td>
<td>
<p>Upper bounds for simulated ETAs (by default Inf)</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_omegaischol">omegaIsChol</code></td>
<td>
<p>Indicates if the <code>omega</code> supplied is a
Cholesky decomposed matrix instead of the traditional
symmetric matrix.</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_omegaseparation">omegaSeparation</code></td>
<td>
<p>Omega separation strategy
</p>
<p>Tells the type of separation strategy when
simulating covariance with parameter uncertainty with standard
deviations modeled in the <code>thetaMat</code> matrix.
</p>

<ul>
<li> <p><code>"lkj"</code> simulates the correlation matrix from the
<code>rLKJ1</code> matrix with the distribution parameter <code>eta</code>
equal to the degrees of freedom <code>nu</code> by <code>(nu-1)/2</code>
</p>
</li>
<li> <p><code>"separation"</code> simulates from the identity inverse Wishart
covariance matrix with <code>nu</code> degrees of freedom.  This is then
converted to a covariance matrix and augmented with the modeled
standard deviations.  While computationally more complex than the
<code>"lkj"</code> prior, it performs better when the covariance matrix
size is greater or equal to 10
</p>
</li>
<li> <p><code>"auto"</code> chooses <code>"lkj"</code> when the dimension of the
matrix is less than 10 and <code>"separation"</code> when greater
than equal to 10.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_omegaxform">omegaXform</code></td>
<td>
<p>When taking <code>omega</code> values from the <code>thetaMat</code>
simulations (using the separation strategy for covariance
simulation), how should the <code>thetaMat</code> values be turned int
standard deviation values:
</p>

<ul>
<li> <p><code>identity</code> This is when standard deviation values are
directly modeled by the <code>params</code> and <code>thetaMat</code> matrix
</p>
</li>
<li> <p><code>variance</code> This is when the <code>params</code> and <code>thetaMat</code>
simulates the variance that are directly modeled by the
<code>thetaMat</code> matrix
</p>
</li>
<li> <p><code>log</code> This is when the <code>params</code> and <code>thetaMat</code>
simulates <code>log(sd)</code>
</p>
</li>
<li> <p><code>nlmixrSqrt</code> This is when the <code>params</code> and
<code>thetaMat</code> simulates the inverse cholesky decomposed matrix
with the <code style="white-space: pre;">&#8288;x\^2&#8288;</code> modeled along the diagonal.  This only works
with a diagonal matrix.
</p>
</li>
<li> <p><code>nlmixrLog</code> This is when the <code>params</code> and
<code>thetaMat</code> simulates the inverse cholesky decomposed matrix
with the <code style="white-space: pre;">&#8288;exp(x\^2)&#8288;</code> along the diagonal.  This only works
with a diagonal matrix.
</p>
</li>
<li> <p><code>nlmixrIdentity</code> This is when the <code>params</code> and
<code>thetaMat</code> simulates the inverse cholesky decomposed matrix.
This only works with a diagonal matrix.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_nsub">nSub</code></td>
<td>
<p>Number between subject variabilities (<code>ETAs</code>) simulated for every
realization of the parameters.</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_thetamat">thetaMat</code></td>
<td>
<p>Named theta matrix.</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_thetalower">thetaLower</code></td>
<td>
<p>Lower bounds for simulated population parameter
variability (by default <code>-Inf</code>)</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_thetaupper">thetaUpper</code></td>
<td>
<p>Upper bounds for simulated population unexplained
variability (by default <code>Inf</code>)</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_thetadf">thetaDf</code></td>
<td>
<p>The degrees of freedom of a t-distribution for
simulation.  By default this is <code>NULL</code> which is
equivalent to <code>Inf</code> degrees, or to simulate from a normal
distribution instead of a <code>t</code>-distribution.</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_thetaischol">thetaIsChol</code></td>
<td>
<p>Indicates if the <code>theta</code> supplied is a
Cholesky decomposed matrix instead of the traditional
symmetric matrix.</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_nstud">nStud</code></td>
<td>
<p>Number virtual studies to characterize uncertainty in estimated
parameters.</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_sigma">sigma</code></td>
<td>
<p>Named sigma covariance or Cholesky decomposition of a
covariance matrix.  The names of the columns indicate
parameters that are simulated.  These are simulated for every
observation in the solved system. When <code>sigma</code> is <code>NA</code> and you are using it with a
<code>rxode2</code> ui model, the unexplained variability described by
the <code>sigma</code> matrix are set to zero.</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_sigmalower">sigmaLower</code></td>
<td>
<p>Lower bounds for simulated unexplained variability (by default -Inf)</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_sigmaupper">sigmaUpper</code></td>
<td>
<p>Upper bounds for simulated unexplained variability (by default Inf)</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_sigmadf">sigmaDf</code></td>
<td>
<p>Degrees of freedom of the sigma t-distribution.  By
default it is equivalent to <code>Inf</code>, or a normal distribution.</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_sigmaischol">sigmaIsChol</code></td>
<td>
<p>Boolean indicating if the sigma is in the
Cholesky decomposition instead of a symmetric covariance</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_sigmaseparation">sigmaSeparation</code></td>
<td>
<p>separation strategy for sigma;
</p>
<p>Tells the type of separation strategy when
simulating covariance with parameter uncertainty with standard
deviations modeled in the <code>thetaMat</code> matrix.
</p>

<ul>
<li> <p><code>"lkj"</code> simulates the correlation matrix from the
<code>rLKJ1</code> matrix with the distribution parameter <code>eta</code>
equal to the degrees of freedom <code>nu</code> by <code>(nu-1)/2</code>
</p>
</li>
<li> <p><code>"separation"</code> simulates from the identity inverse Wishart
covariance matrix with <code>nu</code> degrees of freedom.  This is then
converted to a covariance matrix and augmented with the modeled
standard deviations.  While computationally more complex than the
<code>"lkj"</code> prior, it performs better when the covariance matrix
size is greater or equal to 10
</p>
</li>
<li> <p><code>"auto"</code> chooses <code>"lkj"</code> when the dimension of the
matrix is less than 10 and <code>"separation"</code> when greater
than equal to 10.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_sigmaxform">sigmaXform</code></td>
<td>
<p>When taking <code>sigma</code> values from the <code>thetaMat</code>
simulations (using the separation strategy for covariance
simulation), how should the <code>thetaMat</code> values be turned int
standard deviation values:
</p>

<ul>
<li> <p><code>identity</code> This is when standard deviation values are
directly modeled by the <code>params</code> and <code>thetaMat</code> matrix
</p>
</li>
<li> <p><code>variance</code> This is when the <code>params</code> and <code>thetaMat</code>
simulates the variance that are directly modeled by the
<code>thetaMat</code> matrix
</p>
</li>
<li> <p><code>log</code> This is when the <code>params</code> and <code>thetaMat</code>
simulates <code>log(sd)</code>
</p>
</li>
<li> <p><code>nlmixrSqrt</code> This is when the <code>params</code> and
<code>thetaMat</code> simulates the inverse cholesky decomposed matrix
with the <code style="white-space: pre;">&#8288;x\^2&#8288;</code> modeled along the diagonal.  This only works
with a diagonal matrix.
</p>
</li>
<li> <p><code>nlmixrLog</code> This is when the <code>params</code> and
<code>thetaMat</code> simulates the inverse cholesky decomposed matrix
with the <code style="white-space: pre;">&#8288;exp(x\^2)&#8288;</code> along the diagonal.  This only works
with a diagonal matrix.
</p>
</li>
<li> <p><code>nlmixrIdentity</code> This is when the <code>params</code> and
<code>thetaMat</code> simulates the inverse cholesky decomposed matrix.
This only works with a diagonal matrix.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_ncoresrv">nCoresRV</code></td>
<td>
<p>Number of cores used for the simulation of the
sigma variables.  By default this is 1. To reproduce the results
you need to run on the same platform with the same number of
cores. This is the reason this is set to be one, regardless of
what the number of cores are used in threaded ODE solving.</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_nobs">nObs</code></td>
<td>
<p>Number of observations to simulate (with <code>sigma</code> matrix)</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_dfsub">dfSub</code></td>
<td>
<p>Degrees of freedom to sample the between subject variability matrix from the
inverse Wishart distribution (scaled) or scaled inverse chi squared distribution.</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_dfobs">dfObs</code></td>
<td>
<p>Degrees of freedom to sample the unexplained variability matrix from the
inverse Wishart distribution (scaled) or scaled inverse chi squared distribution.</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_simsubjects">simSubjects</code></td>
<td>
<p>boolean indicated rxode2 should simulate subjects in studies (<code>TRUE</code>,
default) or studies (<code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_simvariability">simVariability</code></td>
<td>
<p>determines if the variability is simulated.
When <code>NA</code> (default) this is determined by the solver.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with the simulated subjects
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>

<hr>
<h2 id='rxSolve'>Options, Solving &amp; Simulation of an ODE/solved system</h2><span id='topic+rxSolve'></span><span id='topic+rxSolve.function'></span><span id='topic+rxSolve.rxUi'></span><span id='topic+rxSolve.rxode2tos'></span><span id='topic+rxSolve.nlmixr2FitData'></span><span id='topic+rxSolve.nlmixr2FitCore'></span><span id='topic+rxSolve.default'></span><span id='topic+update.rxSolve'></span><span id='topic+predict.rxode2'></span><span id='topic+predict.function'></span><span id='topic+predict.rxUi'></span><span id='topic+predict.rxSolve'></span><span id='topic+predict.rxEt'></span><span id='topic+predict.rxParams'></span><span id='topic+simulate.rxode2'></span><span id='topic+simulate.rxSolve'></span><span id='topic+simulate.rxParams'></span><span id='topic+solve.rxSolve'></span><span id='topic+solve.rxUi'></span><span id='topic+solve.function'></span><span id='topic+solve.rxode2'></span><span id='topic+solve.rxParams'></span><span id='topic+solve.rxEt'></span><span id='topic+rxControl'></span>

<h3>Description</h3>

<p>This uses rxode2 family of objects, file, or model specification to
solve a ODE system.  There are many options for a solved rxode2
model, the first are the required <code>object</code>, and <code>events</code> with the
some-times optional <code>params</code> and <code>inits</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSolve(
  object,
  params = NULL,
  events = NULL,
  inits = NULL,
  scale = NULL,
  method = c("liblsoda", "lsoda", "dop853", "indLin"),
  sigdig = NULL,
  atol = 1e-08,
  rtol = 1e-06,
  maxsteps = 70000L,
  hmin = 0,
  hmax = NA_real_,
  hmaxSd = 0,
  hini = 0,
  maxordn = 12L,
  maxords = 5L,
  ...,
  cores,
  covsInterpolation = c("locf", "linear", "nocb", "midpoint"),
  addCov = TRUE,
  sigma = NULL,
  sigmaDf = NULL,
  sigmaLower = -Inf,
  sigmaUpper = Inf,
  nCoresRV = 1L,
  sigmaIsChol = FALSE,
  sigmaSeparation = c("auto", "lkj", "separation"),
  sigmaXform = c("identity", "variance", "log", "nlmixrSqrt", "nlmixrLog",
    "nlmixrIdentity"),
  nDisplayProgress = 10000L,
  amountUnits = NA_character_,
  timeUnits = "hours",
  theta = NULL,
  thetaLower = -Inf,
  thetaUpper = Inf,
  eta = NULL,
  addDosing = FALSE,
  stateTrim = Inf,
  updateObject = FALSE,
  omega = NULL,
  omegaDf = NULL,
  omegaIsChol = FALSE,
  omegaSeparation = c("auto", "lkj", "separation"),
  omegaXform = c("variance", "identity", "log", "nlmixrSqrt", "nlmixrLog",
    "nlmixrIdentity"),
  omegaLower = -Inf,
  omegaUpper = Inf,
  nSub = 1L,
  thetaMat = NULL,
  thetaDf = NULL,
  thetaIsChol = FALSE,
  nStud = 1L,
  dfSub = 0,
  dfObs = 0,
  returnType = c("rxSolve", "matrix", "data.frame", "data.frame.TBS", "data.table",
    "tbl", "tibble"),
  seed = NULL,
  nsim = NULL,
  minSS = 10L,
  maxSS = 1000L,
  infSSstep = 12,
  strictSS = TRUE,
  istateReset = TRUE,
  subsetNonmem = TRUE,
  maxAtolRtolFactor = 0.1,
  from = NULL,
  to = NULL,
  by = NULL,
  length.out = NULL,
  iCov = NULL,
  keep = NULL,
  indLinPhiTol = 1e-07,
  indLinPhiM = 0L,
  indLinMatExpType = c("expokit", "Al-Mohy", "arma"),
  indLinMatExpOrder = 6L,
  drop = NULL,
  idFactor = TRUE,
  mxhnil = 0,
  hmxi = 0,
  warnIdSort = TRUE,
  warnDrop = TRUE,
  ssAtol = 1e-08,
  ssRtol = 1e-06,
  safeZero = TRUE,
  sumType = c("pairwise", "fsum", "kahan", "neumaier", "c"),
  prodType = c("long double", "double", "logify"),
  sensType = c("advan", "autodiff", "forward", "central"),
  linDiff = c(tlag = 1.5e-05, f = 1.5e-05, rate = 1.5e-05, dur = 1.5e-05, tlag2 =
    1.5e-05, f2 = 1.5e-05, rate2 = 1.5e-05, dur2 = 1.5e-05),
  linDiffCentral = c(tlag = TRUE, f = TRUE, rate = TRUE, dur = TRUE, tlag2 = TRUE, f2 =
    TRUE, rate2 = TRUE, dur2 = TRUE),
  resample = NULL,
  resampleID = TRUE,
  maxwhile = 1e+05,
  atolSens = 1e-08,
  rtolSens = 1e-06,
  ssAtolSens = 1e-08,
  ssRtolSens = 1e-06,
  simVariability = NA,
  nLlikAlloc = NULL,
  useStdPow = FALSE,
  naTimeHandle = c("ignore", "warn", "error"),
  addlKeepsCov = FALSE,
  addlDropSs = TRUE,
  ssAtDoseTime = TRUE,
  ss2cancelAllPending = FALSE,
  envir = parent.frame()
)

## S3 method for class ''function''
rxSolve(
  object,
  params = NULL,
  events = NULL,
  inits = NULL,
  ...,
  theta = NULL,
  eta = NULL,
  envir = parent.frame()
)

## S3 method for class 'rxUi'
rxSolve(
  object,
  params = NULL,
  events = NULL,
  inits = NULL,
  ...,
  theta = NULL,
  eta = NULL,
  envir = parent.frame()
)

## S3 method for class 'rxode2tos'
rxSolve(
  object,
  params = NULL,
  events = NULL,
  inits = NULL,
  ...,
  theta = NULL,
  eta = NULL,
  envir = parent.frame()
)

## S3 method for class 'nlmixr2FitData'
rxSolve(
  object,
  params = NULL,
  events = NULL,
  inits = NULL,
  ...,
  theta = NULL,
  eta = NULL,
  envir = parent.frame()
)

## S3 method for class 'nlmixr2FitCore'
rxSolve(
  object,
  params = NULL,
  events = NULL,
  inits = NULL,
  ...,
  theta = NULL,
  eta = NULL,
  envir = parent.frame()
)

## Default S3 method:
rxSolve(
  object,
  params = NULL,
  events = NULL,
  inits = NULL,
  ...,
  theta = NULL,
  eta = NULL,
  envir = parent.frame()
)

## S3 method for class 'rxSolve'
update(object, ...)

## S3 method for class 'rxode2'
predict(object, ...)

## S3 method for class ''function''
predict(object, ...)

## S3 method for class 'rxUi'
predict(object, ...)

## S3 method for class 'rxSolve'
predict(object, ...)

## S3 method for class 'rxEt'
predict(object, ...)

## S3 method for class 'rxParams'
predict(object, ...)

## S3 method for class 'rxode2'
simulate(object, nsim = 1L, seed = NULL, ...)

## S3 method for class 'rxSolve'
simulate(object, nsim = 1L, seed = NULL, ...)

## S3 method for class 'rxParams'
simulate(object, nsim = 1L, seed = NULL, ...)

## S3 method for class 'rxSolve'
solve(a, b, ...)

## S3 method for class 'rxUi'
solve(a, b, ...)

## S3 method for class ''function''
solve(a, b, ...)

## S3 method for class 'rxode2'
solve(a, b, ...)

## S3 method for class 'rxParams'
solve(a, b, ...)

## S3 method for class 'rxEt'
solve(a, b, ...)

rxControl(
  ...,
  params = NULL,
  events = NULL,
  inits = NULL,
  envir = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxSolve_+3A_object">object</code></td>
<td>
<p>is a either a rxode2 family of objects, or a file-name
with a rxode2 model specification, or a string with a rxode2
model specification.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_params">params</code></td>
<td>
<p>a numeric named vector with values for every
parameter in the ODE system; the names must correspond to the
parameter identifiers used in the ODE specification;</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_events">events</code></td>
<td>
<p>an <code>eventTable</code> object describing the input
(e.g., doses) to the dynamic system and observation sampling
time points (see <code><a href="#topic+eventTable">eventTable()</a></code>);</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_inits">inits</code></td>
<td>
<p>a vector of initial values of the state variables
(e.g., amounts in each compartment), and the order in this
vector must be the same as the state variables (e.g., PK/PD
compartments);</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_scale">scale</code></td>
<td>
<p>a numeric named vector with scaling for ode
parameters of the system.  The names must correspond to the
parameter identifiers in the ODE specification. Each of the
ODE variables will be divided by the scaling factor.  For
example <code>scale=c(center=2)</code> will divide the center ODE
variable by 2.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_method">method</code></td>
<td>
<p>The method for solving ODEs.  Currently this supports:
</p>

<ul>
<li> <p><code>"liblsoda"</code> thread safe lsoda.  This supports parallel
thread-based solving, and ignores user Jacobian specification.
</p>
</li>
<li> <p><code>"lsoda"</code> &ndash; LSODA solver.  Does not support parallel thread-based
solving, but allows user Jacobian specification.
</p>
</li>
<li> <p><code>"dop853"</code> &ndash; DOP853 solver.  Does not support parallel thread-based
solving nor user Jacobian specification
</p>
</li>
<li> <p><code>"indLin"</code> &ndash; Solving through inductive linearization.  The rxode2 dll
must be setup specially to use this solving routine.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rxSolve_+3A_sigdig">sigdig</code></td>
<td>
<p>Specifies the &quot;significant digits&quot; that the ode
solving requests.  When specified this controls the relative and
absolute tolerances of the ODE solvers.  By default the tolerance
is <code>0.5*10^(-sigdig-2)</code> for regular ODEs. For the
sensitivity equations the default is <code style="white-space: pre;">&#8288;0.5*10\^(-sigdig-1.5)&#8288;</code>
(sensitivity changes only applicable for liblsoda).  This also
controls the <code>atol</code>/<code>rtol</code> of the steady state solutions. The
<code>ssAtol</code>/<code>ssRtol</code> is <code style="white-space: pre;">&#8288;0.5*10\^(-sigdig)&#8288;</code> and for the sensitivities
<code style="white-space: pre;">&#8288;0.5*10\^(-sigdig+0.625)&#8288;</code>.  By default
this is unspecified (<code>NULL</code>) and uses the standard <code>atol</code>/<code>rtol</code>.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_atol">atol</code></td>
<td>
<p>a numeric absolute tolerance (1e-8 by default) used
by the ODE solver to determine if a good solution has been
achieved;  This is also used in the solved linear model to check
if prior doses do not add anything to the solution.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_rtol">rtol</code></td>
<td>
<p>a numeric relative tolerance (<code>1e-6</code> by default) used
by the ODE solver to determine if a good solution has been
achieved. This is also used in the solved linear model to check
if prior doses do not add anything to the solution.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_maxsteps">maxsteps</code></td>
<td>
<p>maximum number of (internally defined) steps allowed
during one call to the solver. (5000 by default)</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_hmin">hmin</code></td>
<td>
<p>The minimum absolute step size allowed. The default
value is 0.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_hmax">hmax</code></td>
<td>
<p>The maximum absolute step size allowed.  When
<code>hmax=NA</code> (default), uses the average difference +
hmaxSd*sd in times and sampling events. The <code>hmaxSd</code> is a user
specified parameter and which defaults to zero.  When
<code>hmax=NULL</code> rxode2 uses the maximum difference in times in
your sampling and events.  The value 0 is equivalent to infinite
maximum absolute step size.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_hmaxsd">hmaxSd</code></td>
<td>
<p>The number of standard deviations of the time
difference to add to hmax. The default is 0</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_hini">hini</code></td>
<td>
<p>The step size to be attempted on the first step. The
default value is determined by the solver (when <code>hini = 0</code>)</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_maxordn">maxordn</code></td>
<td>
<p>The maximum order to be allowed for the nonstiff
(Adams) method.  The default is 12.  It can be between 1 and
12.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_maxords">maxords</code></td>
<td>
<p>The maximum order to be allowed for the stiff (BDF)
method.  The default value is 5.  This can be between 1 and 5.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_...">...</code></td>
<td>
<p>Other arguments including scaling factors for each
compartment.  This includes S# = numeric will scale a compartment
# by a dividing the compartment amount by the scale factor,
like NONMEM.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_cores">cores</code></td>
<td>
<p>Number of cores used in parallel ODE solving.  This
is equivalent to calling <code><a href="#topic+setRxThreads">setRxThreads()</a></code></p>
</td></tr>
<tr><td><code id="rxSolve_+3A_covsinterpolation">covsInterpolation</code></td>
<td>
<p>specifies the interpolation method for
time-varying covariates. When solving ODEs it often samples
times outside the sampling time specified in <code>events</code>.
When this happens, the time varying covariates are
interpolated.  Currently this can be:
</p>

<ul>
<li> <p><code>"linear"</code> interpolation, which interpolates the covariate
by solving the line between the observed covariates and extrapolating the new
covariate value.
</p>
</li>
<li> <p><code>"constant"</code> &ndash; Last observation carried forward (the default).
</p>
</li>
<li> <p><code>"NOCB"</code> &ndash; Next Observation Carried Backward.  This is the same method
that NONMEM uses.
</p>
</li>
<li> <p><code>"midpoint"</code> Last observation carried forward to midpoint; Next observation
carried backward to midpoint.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rxSolve_+3A_addcov">addCov</code></td>
<td>
<p>A boolean indicating if covariates should be added
to the output matrix or data frame. By default this is
disabled.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_sigma">sigma</code></td>
<td>
<p>Named sigma covariance or Cholesky decomposition of a
covariance matrix.  The names of the columns indicate
parameters that are simulated.  These are simulated for every
observation in the solved system. When <code>sigma</code> is <code>NA</code> and you are using it with a
<code>rxode2</code> ui model, the unexplained variability described by
the <code>sigma</code> matrix are set to zero.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_sigmadf">sigmaDf</code></td>
<td>
<p>Degrees of freedom of the sigma t-distribution.  By
default it is equivalent to <code>Inf</code>, or a normal distribution.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_sigmalower">sigmaLower</code></td>
<td>
<p>Lower bounds for simulated unexplained variability (by default -Inf)</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_sigmaupper">sigmaUpper</code></td>
<td>
<p>Upper bounds for simulated unexplained variability (by default Inf)</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_ncoresrv">nCoresRV</code></td>
<td>
<p>Number of cores used for the simulation of the
sigma variables.  By default this is 1. To reproduce the results
you need to run on the same platform with the same number of
cores. This is the reason this is set to be one, regardless of
what the number of cores are used in threaded ODE solving.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_sigmaischol">sigmaIsChol</code></td>
<td>
<p>Boolean indicating if the sigma is in the
Cholesky decomposition instead of a symmetric covariance</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_sigmaseparation">sigmaSeparation</code></td>
<td>
<p>separation strategy for sigma;
</p>
<p>Tells the type of separation strategy when
simulating covariance with parameter uncertainty with standard
deviations modeled in the <code>thetaMat</code> matrix.
</p>

<ul>
<li> <p><code>"lkj"</code> simulates the correlation matrix from the
<code>rLKJ1</code> matrix with the distribution parameter <code>eta</code>
equal to the degrees of freedom <code>nu</code> by <code>(nu-1)/2</code>
</p>
</li>
<li> <p><code>"separation"</code> simulates from the identity inverse Wishart
covariance matrix with <code>nu</code> degrees of freedom.  This is then
converted to a covariance matrix and augmented with the modeled
standard deviations.  While computationally more complex than the
<code>"lkj"</code> prior, it performs better when the covariance matrix
size is greater or equal to 10
</p>
</li>
<li> <p><code>"auto"</code> chooses <code>"lkj"</code> when the dimension of the
matrix is less than 10 and <code>"separation"</code> when greater
than equal to 10.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rxSolve_+3A_sigmaxform">sigmaXform</code></td>
<td>
<p>When taking <code>sigma</code> values from the <code>thetaMat</code>
simulations (using the separation strategy for covariance
simulation), how should the <code>thetaMat</code> values be turned int
standard deviation values:
</p>

<ul>
<li> <p><code>identity</code> This is when standard deviation values are
directly modeled by the <code>params</code> and <code>thetaMat</code> matrix
</p>
</li>
<li> <p><code>variance</code> This is when the <code>params</code> and <code>thetaMat</code>
simulates the variance that are directly modeled by the
<code>thetaMat</code> matrix
</p>
</li>
<li> <p><code>log</code> This is when the <code>params</code> and <code>thetaMat</code>
simulates <code>log(sd)</code>
</p>
</li>
<li> <p><code>nlmixrSqrt</code> This is when the <code>params</code> and
<code>thetaMat</code> simulates the inverse cholesky decomposed matrix
with the <code style="white-space: pre;">&#8288;x\^2&#8288;</code> modeled along the diagonal.  This only works
with a diagonal matrix.
</p>
</li>
<li> <p><code>nlmixrLog</code> This is when the <code>params</code> and
<code>thetaMat</code> simulates the inverse cholesky decomposed matrix
with the <code style="white-space: pre;">&#8288;exp(x\^2)&#8288;</code> along the diagonal.  This only works
with a diagonal matrix.
</p>
</li>
<li> <p><code>nlmixrIdentity</code> This is when the <code>params</code> and
<code>thetaMat</code> simulates the inverse cholesky decomposed matrix.
This only works with a diagonal matrix.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rxSolve_+3A_ndisplayprogress">nDisplayProgress</code></td>
<td>
<p>An integer indicating the minimum number
of c-based solves before a progress bar is shown.  By default
this is 10,000.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_amountunits">amountUnits</code></td>
<td>
<p>This supplies the dose units of a data frame
supplied instead of an event table.  This is for importing the
data as an rxode2 event table.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_timeunits">timeUnits</code></td>
<td>
<p>This supplies the time units of a data frame
supplied instead of an event table.  This is for importing the
data as an rxode2 event table.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_theta">theta</code></td>
<td>
<p>A vector of parameters that will be named <code style="white-space: pre;">&#8288;THETA\[#\]&#8288;</code> and
added to parameters</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_thetalower">thetaLower</code></td>
<td>
<p>Lower bounds for simulated population parameter
variability (by default <code>-Inf</code>)</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_thetaupper">thetaUpper</code></td>
<td>
<p>Upper bounds for simulated population unexplained
variability (by default <code>Inf</code>)</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_eta">eta</code></td>
<td>
<p>A vector of parameters that will be named <code style="white-space: pre;">&#8288;ETA\[#\]&#8288;</code> and
added to parameters</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_adddosing">addDosing</code></td>
<td>
<p>Boolean indicating if the solve should add rxode2
EVID and related columns.  This will also include dosing
information and estimates at the doses.  Be default, rxode2
only includes estimates at the observations. (default
<code>FALSE</code>). When <code>addDosing</code> is <code>NULL</code>, only
include <code>EVID=0</code> on solve and exclude any model-times or
<code>EVID=2</code>. If <code>addDosing</code> is <code>NA</code> the classic
<code>rxode2</code> EVID events are returned. When <code>addDosing</code> is <code>TRUE</code>
add the event information in NONMEM-style format; If
<code>subsetNonmem=FALSE</code> rxode2 will also include extra event types
(<code>EVID</code>) for ending infusion and modeled times:
</p>

<ul>
<li> <p><code>EVID=-1</code> when the modeled rate infusions are turned
off (matches <code>rate=-1</code>)
</p>
</li>
<li> <p><code>EVID=-2</code> When the modeled duration infusions are
turned off (matches <code>rate=-2</code>)
</p>
</li>
<li> <p><code>EVID=-10</code> When the specified <code>rate</code> infusions are
turned off (matches <code>rate&gt;0</code>)
</p>
</li>
<li> <p><code>EVID=-20</code> When the specified <code>dur</code> infusions are
turned off (matches <code>dur&gt;0</code>)
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;EVID=101,102,103,...&#8288;</code> Modeled time where 101 is the
first model time, 102 is the second etc.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rxSolve_+3A_statetrim">stateTrim</code></td>
<td>
<p>When amounts/concentrations in one of the states
are above this value, trim them to be this value. By default
Inf.  Also trims to -stateTrim for large negative
amounts/concentrations.  If you want to trim between a range
say <code>c(0, 2000000)</code> you may specify 2 values with a lower and
upper range to make sure all state values are in the
reasonable range.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_updateobject">updateObject</code></td>
<td>
<p>This is an internally used flag to update the
rxode2 solved object (when supplying an rxode2 solved object) as
well as returning a new object.  You probably should not
modify it's <code>FALSE</code> default unless you are willing to
have unexpected results.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_omega">omega</code></td>
<td>
<p>Estimate of Covariance matrix. When omega is a list,
assume it is a block matrix and convert it to a full matrix for
simulations.  When <code>omega</code> is <code>NA</code> and you are using it with a
<code>rxode2</code> ui model, the between subject variability described by
the <code>omega</code> matrix are set to zero.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_omegadf">omegaDf</code></td>
<td>
<p>The degrees of freedom of a t-distribution for
simulation.  By default this is <code>NULL</code> which is
equivalent to <code>Inf</code> degrees, or to simulate from a normal
distribution instead of a t-distribution.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_omegaischol">omegaIsChol</code></td>
<td>
<p>Indicates if the <code>omega</code> supplied is a
Cholesky decomposed matrix instead of the traditional
symmetric matrix.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_omegaseparation">omegaSeparation</code></td>
<td>
<p>Omega separation strategy
</p>
<p>Tells the type of separation strategy when
simulating covariance with parameter uncertainty with standard
deviations modeled in the <code>thetaMat</code> matrix.
</p>

<ul>
<li> <p><code>"lkj"</code> simulates the correlation matrix from the
<code>rLKJ1</code> matrix with the distribution parameter <code>eta</code>
equal to the degrees of freedom <code>nu</code> by <code>(nu-1)/2</code>
</p>
</li>
<li> <p><code>"separation"</code> simulates from the identity inverse Wishart
covariance matrix with <code>nu</code> degrees of freedom.  This is then
converted to a covariance matrix and augmented with the modeled
standard deviations.  While computationally more complex than the
<code>"lkj"</code> prior, it performs better when the covariance matrix
size is greater or equal to 10
</p>
</li>
<li> <p><code>"auto"</code> chooses <code>"lkj"</code> when the dimension of the
matrix is less than 10 and <code>"separation"</code> when greater
than equal to 10.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rxSolve_+3A_omegaxform">omegaXform</code></td>
<td>
<p>When taking <code>omega</code> values from the <code>thetaMat</code>
simulations (using the separation strategy for covariance
simulation), how should the <code>thetaMat</code> values be turned int
standard deviation values:
</p>

<ul>
<li> <p><code>identity</code> This is when standard deviation values are
directly modeled by the <code>params</code> and <code>thetaMat</code> matrix
</p>
</li>
<li> <p><code>variance</code> This is when the <code>params</code> and <code>thetaMat</code>
simulates the variance that are directly modeled by the
<code>thetaMat</code> matrix
</p>
</li>
<li> <p><code>log</code> This is when the <code>params</code> and <code>thetaMat</code>
simulates <code>log(sd)</code>
</p>
</li>
<li> <p><code>nlmixrSqrt</code> This is when the <code>params</code> and
<code>thetaMat</code> simulates the inverse cholesky decomposed matrix
with the <code style="white-space: pre;">&#8288;x\^2&#8288;</code> modeled along the diagonal.  This only works
with a diagonal matrix.
</p>
</li>
<li> <p><code>nlmixrLog</code> This is when the <code>params</code> and
<code>thetaMat</code> simulates the inverse cholesky decomposed matrix
with the <code style="white-space: pre;">&#8288;exp(x\^2)&#8288;</code> along the diagonal.  This only works
with a diagonal matrix.
</p>
</li>
<li> <p><code>nlmixrIdentity</code> This is when the <code>params</code> and
<code>thetaMat</code> simulates the inverse cholesky decomposed matrix.
This only works with a diagonal matrix.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rxSolve_+3A_omegalower">omegaLower</code></td>
<td>
<p>Lower bounds for simulated ETAs (by default -Inf)</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_omegaupper">omegaUpper</code></td>
<td>
<p>Upper bounds for simulated ETAs (by default Inf)</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_nsub">nSub</code></td>
<td>
<p>Number between subject variabilities (<code>ETAs</code>) simulated for every
realization of the parameters.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_thetamat">thetaMat</code></td>
<td>
<p>Named theta matrix.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_thetadf">thetaDf</code></td>
<td>
<p>The degrees of freedom of a t-distribution for
simulation.  By default this is <code>NULL</code> which is
equivalent to <code>Inf</code> degrees, or to simulate from a normal
distribution instead of a <code>t</code>-distribution.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_thetaischol">thetaIsChol</code></td>
<td>
<p>Indicates if the <code>theta</code> supplied is a
Cholesky decomposed matrix instead of the traditional
symmetric matrix.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_nstud">nStud</code></td>
<td>
<p>Number virtual studies to characterize uncertainty in estimated
parameters.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_dfsub">dfSub</code></td>
<td>
<p>Degrees of freedom to sample the between subject variability matrix from the
inverse Wishart distribution (scaled) or scaled inverse chi squared distribution.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_dfobs">dfObs</code></td>
<td>
<p>Degrees of freedom to sample the unexplained variability matrix from the
inverse Wishart distribution (scaled) or scaled inverse chi squared distribution.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_returntype">returnType</code></td>
<td>
<p>This tells what type of object is returned.  The
currently supported types are:
</p>

<ul>
<li> <p><code>"rxSolve"</code> (default) will return a reactive data frame
that can change easily change different pieces of the solve and
update the data frame.  This is the currently standard solving
method in rxode2,  is used for <code>rxSolve(object, ...)</code>, <code>solve(object,...)</code>,
</p>
</li>
<li> <p><code>"data.frame"</code> &ndash; returns a plain, non-reactive data
frame; Currently very slightly faster than <code>returnType="matrix"</code>
</p>
</li>
<li> <p><code>"matrix"</code> &ndash; returns a plain matrix with column names attached
to the solved object.  This is what is used <code>object$run</code> as well as <code>object$solve</code>
</p>
</li>
<li> <p><code>"data.table"</code> &ndash; returns a <code>data.table</code>; The <code>data.table</code> is
created by reference (ie <code>setDt()</code>), which should be fast.
</p>
</li>
<li> <p><code>"tbl"</code> or <code>"tibble"</code> returns a tibble format.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rxSolve_+3A_seed">seed</code></td>
<td>
<p>an object specifying if and how the random number
generator should be initialized</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_nsim">nsim</code></td>
<td>
<p>represents the number of simulations.  For rxode2, if
you supply single subject event tables (created with
<code style="white-space: pre;">&#8288;[eventTable()]&#8288;</code>)</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_minss">minSS</code></td>
<td>
<p>Minimum number of iterations for a steady-state dose</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_maxss">maxSS</code></td>
<td>
<p>Maximum number of iterations for a steady-state dose</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_infssstep">infSSstep</code></td>
<td>
<p>Step size for determining if a constant infusion
has reached steady state.  By default this is large value,
12.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_strictss">strictSS</code></td>
<td>
<p>Boolean indicating if a strict steady-state is
required. If a strict steady-state is (<code>TRUE</code>) required
then at least <code>minSS</code> doses are administered and the
total number of steady states doses will continue until
<code>maxSS</code> is reached, or <code>atol</code> and <code>rtol</code> for
every compartment have been reached.  However, if ODE solving
problems occur after the <code>minSS</code> has been reached the
whole subject is considered an invalid solve. If
<code>strictSS</code> is <code>FALSE</code> then as long as <code>minSS</code>
has been reached the last good solve before ODE solving
problems occur is considered the steady state, even though
either <code>atol</code>, <code>rtol</code> or <code>maxSS</code> have not
been achieved.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_istatereset">istateReset</code></td>
<td>
<p>When <code>TRUE</code>, reset the <code>ISTATE</code> variable to 1 for
lsoda and liblsoda with doses, like <code>deSolve</code>; When <code>FALSE</code>, do
not reset the <code>ISTATE</code> variable with doses.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_subsetnonmem">subsetNonmem</code></td>
<td>
<p>subset to NONMEM compatible EVIDs only.  By
default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_maxatolrtolfactor">maxAtolRtolFactor</code></td>
<td>
<p>The maximum <code>atol</code>/<code>rtol</code> that
FOCEi and other routines may adjust to.  By default 0.1</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_from">from</code></td>
<td>
<p>When there is no observations in the event table,
start observations at this value. By default this is zero.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_to">to</code></td>
<td>
<p>When there is no observations in the event table, end
observations at this value. By default this is 24 + maximum
dose time.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_by">by</code></td>
<td>
<p>When there are no observations in the event table, this
is the amount to increment for the observations between <code>from</code>
and <code>to</code>.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_length.out">length.out</code></td>
<td>
<p>The number of observations to create if there
isn't any observations in the event table. By default this is 200.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_icov">iCov</code></td>
<td>
<p>A data frame of individual non-time varying covariates
to combine with the <code>events</code> dataset by merge.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_keep">keep</code></td>
<td>
<p>Columns to keep from either the input dataset or the
<code>iCov</code> dataset.  With the <code>iCov</code> dataset, the column
is kept once per line.  For the input dataset, if any records
are added to the data LOCF (Last Observation Carried forward)
imputation is performed.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_indlinphitol">indLinPhiTol</code></td>
<td>
<p>the requested accuracy tolerance on
exponential matrix.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_indlinphim">indLinPhiM</code></td>
<td>
<p>the maximum size for the Krylov basis</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_indlinmatexptype">indLinMatExpType</code></td>
<td>
<p>This is them matrix exponential type that
is use for rxode2.  Currently the following are supported:
</p>

<ul>
<li> <p><code>Al-Mohy</code> Uses the exponential matrix method of Al-Mohy Higham (2009)
</p>
</li>
<li> <p><code>arma</code> Use the exponential matrix from RcppArmadillo
</p>
</li>
<li> <p><code>expokit</code> Use the exponential matrix from Roger B. Sidje (1998)
</p>
</li></ul>
</td></tr>
<tr><td><code id="rxSolve_+3A_indlinmatexporder">indLinMatExpOrder</code></td>
<td>
<p>an integer, the order of approximation to
be used, for the <code>Al-Mohy</code> and <code>expokit</code> values.
The best value for this depends on machine precision (and
slightly on the matrix). We use <code>6</code> as a default.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_drop">drop</code></td>
<td>
<p>Columns to drop from the output</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_idfactor">idFactor</code></td>
<td>
<p>This boolean indicates if original ID values
should be maintained. This changes the default sequentially
ordered ID to a factor with the original ID values in the
original dataset.  By default this is enabled.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_mxhnil">mxhnil</code></td>
<td>
<p>maximum number of messages printed (per problem)
warning that <code>T + H = T</code> on a step (<code>H</code> = step size).  This must
be positive to result in a non-default value.  The default
value is 0 (or infinite).</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_hmxi">hmxi</code></td>
<td>
<p>inverse of the maximum absolute value of <code>H</code> to are used.
hmxi = 0.0 is allowed and corresponds to an infinite <code style="white-space: pre;">&#8288;hmax1 (default).  &#8288;</code>hmin<code>and</code>hmxi<code style="white-space: pre;">&#8288;may be changed at any time, but will not take effect until the next change of&#8288;</code>H<code style="white-space: pre;">&#8288;is considered. This option is only considered with&#8288;</code>method=&quot;liblsoda&quot;'.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_warnidsort">warnIdSort</code></td>
<td>
<p>Warn if the ID is not present and rxode2 assumes
the order of the parameters/iCov are the same as the order of
the parameters in the input dataset.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_warndrop">warnDrop</code></td>
<td>
<p>Warn if column(s) were supposed to be dropped, but
were not present.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_ssatol">ssAtol</code></td>
<td>
<p>Steady state atol convergence factor.  Can be
a vector based on each state.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_ssrtol">ssRtol</code></td>
<td>
<p>Steady state rtol convergence factor.  Can be a
vector based on each state.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_safezero">safeZero</code></td>
<td>
<p>Use safe zero divide and log routines.  By default
this is turned on but you may turn it off if you wish.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_sumtype">sumType</code></td>
<td>
<p>Sum type to use for <code>sum()</code> in
rxode2 code blocks.
</p>
<p><code>pairwise</code> uses the pairwise sum (fast, default)
</p>
<p><code>fsum</code> uses the PreciseSum package's fsum function (most accurate)
</p>
<p><code>kahan</code> uses Kahan correction
</p>
<p><code>neumaier</code> uses Neumaier correction
</p>
<p><code>c</code> uses no correction: default/native summing</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_prodtype">prodType</code></td>
<td>
<p>Product to use for <code>prod()</code> in rxode2 blocks
</p>
<p><code style="white-space: pre;">&#8288;long double&#8288;</code> converts to long double, performs the
multiplication and then converts back.
</p>
<p><code>double</code> uses the standard double scale for multiplication.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_senstype">sensType</code></td>
<td>
<p>Sensitivity type for <code>linCmt()</code> model:
</p>
<p><code>advan</code> Use the direct advan solutions
</p>
<p><code>autodiff</code> Use the autodiff advan solutions
</p>
<p><code>forward</code> Use forward difference solutions
</p>
<p><code>central</code> Use central differences</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_lindiff">linDiff</code></td>
<td>
<p>This gives the linear difference amount for all the
types of linear compartment model parameters where sensitivities
are not calculated. The named components of this numeric vector are:
</p>

<ul>
<li> <p><code>"lag"</code> Central compartment lag
</p>
</li>
<li> <p><code>"f"</code> Central compartment bioavailability
</p>
</li>
<li> <p><code>"rate"</code> Central compartment modeled rate
</p>
</li>
<li> <p><code>"dur"</code> Central compartment modeled duration
</p>
</li>
<li> <p><code>"lag2"</code> Depot compartment lag
</p>
</li>
<li> <p><code>"f2"</code> Depot compartment bioavailability
</p>
</li>
<li> <p><code>"rate2"</code> Depot compartment modeled rate
</p>
</li>
<li> <p><code>"dur2"</code> Depot compartment modeled duration
</p>
</li></ul>
</td></tr>
<tr><td><code id="rxSolve_+3A_lindiffcentral">linDiffCentral</code></td>
<td>
<p>This gives the which parameters use central
differences for the linear compartment model parameters.  The
are the same components as <code>linDiff</code></p>
</td></tr>
<tr><td><code id="rxSolve_+3A_resample">resample</code></td>
<td>
<p>A character vector of model variables to resample
from the input dataset; This sampling is done with replacement.
When <code>NULL</code> or <code>FALSE</code> no resampling is done.  When
<code>TRUE</code> resampling is done on all covariates in the input
dataset</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_resampleid">resampleID</code></td>
<td>
<p>boolean representing if the resampling should be
done on an individual basis <code>TRUE</code> (ie. a whole patient is
selected) or each covariate is resampled independent of the
subject identifier <code>FALSE</code>.  When <code>resampleID=TRUE</code>
correlations of parameters are retained, where as when
<code>resampleID=FALSE</code> ignores patient covariate correaltions.
Hence the default is <code>resampleID=TRUE</code>.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_maxwhile">maxwhile</code></td>
<td>
<p>represents the maximum times a while loop is
evaluated before exiting.  By default this is 100000</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_atolsens">atolSens</code></td>
<td>
<p>Sensitivity atol, can be different than atol with
liblsoda.  This allows a less accurate solve for gradients (if desired)</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_rtolsens">rtolSens</code></td>
<td>
<p>Sensitivity rtol, can be different than rtol with
liblsoda.  This allows a less accurate solve for gradients (if desired)</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_ssatolsens">ssAtolSens</code></td>
<td>
<p>Sensitivity absolute tolerance (atol) for
calculating if steady state has been achieved for sensitivity compartments.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_ssrtolsens">ssRtolSens</code></td>
<td>
<p>Sensitivity relative tolerance (rtol) for
calculating if steady state has been achieved for sensitivity compartments.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_simvariability">simVariability</code></td>
<td>
<p>determines if the variability is simulated.
When <code>NA</code> (default) this is determined by the solver.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_nllikalloc">nLlikAlloc</code></td>
<td>
<p>The number of log likelihood endpoints that are
used in the model.  This allows independent log likelihood per
endpoint in focei for nlmixr2.  It likely shouldn't be set,
though it won't hurt anything if you do (just may take up more
memory for larger allocations).</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_usestdpow">useStdPow</code></td>
<td>
<p>This uses C's <code>pow</code> for exponentiation instead of
R's <code>R_pow</code> or <code>R_pow_di</code>.  By default this is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="rxSolve_+3A_natimehandle">naTimeHandle</code></td>
<td>
<p>Determines what time of handling happens when
the time becomes <code>NA</code>: current options are:
</p>

<ul>
<li> <p><code>ignore</code> this ignores the <code>NA</code> time input and passes it through.
</p>
</li>
<li> <p><code>warn</code> (default) this will produce a warning at the end of the
solve, but continues solving passing through the <code>NA</code> time
</p>
</li>
<li> <p><code>error</code> this will stop this solve if this is not a parallel
solved ODE (otherwise stopping can crash R)
</p>
</li></ul>
</td></tr>
<tr><td><code id="rxSolve_+3A_addlkeepscov">addlKeepsCov</code></td>
<td>
<p>This determines if the additional dosing items
repeats the dose only (<code>FALSE</code>) or keeps the covariates at the
record of the dose (<code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_addldropss">addlDropSs</code></td>
<td>
<p>When there are steady state doses with an <code>addl</code>
specification the steady state flag is dropped with repeated
doses (when <code>TRUE</code>) or retained (when <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_ssatdosetime">ssAtDoseTime</code></td>
<td>
<p>Boolean that when <code>TRUE</code> back calculates the
steady concentration at the actual time of dose, otherwise when
<code>FALSE</code> the doses are shifted</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_ss2cancelallpending">ss2cancelAllPending</code></td>
<td>
<p>When <code>TRUE</code> the <code>SS=2</code> event type
cancels all pending doses like <code>SS=1</code>.  When <code>FALSE</code> the pending
doses not canceled with <code>SS=2</code> (the infusions started before
<code>SS=2</code> occurred are canceled, though).</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_envir">envir</code></td>
<td>
<p>is the environment to look for R user functions
(defaults to parent environment)</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_a">a</code></td>
<td>
<p>when using <code>solve()</code>, this is equivalent to the
<code>object</code> argument.  If you specify <code>object</code> later in
the argument list it overwrites this parameter.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_b">b</code></td>
<td>
<p>when using <code>solve()</code>, this is equivalent to the
<code>params</code> argument.  If you specify <code>params</code> as a
named argument, this overwrites the output</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rest of the document focus on the different ODE solving
methods, followed by the core solving method's options, rxode2 event
handling options, rxode2's numerical stability options, rxode2's
output options, and finally internal rxode2 options or compatibility
options.
</p>


<h3>Value</h3>

<p>An &ldquo;rxSolve&rdquo; solve object that stores the solved
value in a special data.frame or other type as determined by
<code>returnType</code>. By default this has as many rows as there are
sampled time points and as many columns as system variables (as
defined by the ODEs and additional assignments in the rxode2 model
code).  It also stores information about the call to allow
dynamic updating of the solved object.
</p>
<p>The operations for the object are similar to a data-frame, but
expand the <code>$</code> and <code style="white-space: pre;">&#8288;[[""]]&#8288;</code> access operators and assignment
operators to resolve based on different parameter values, initial
conditions, solver parameters, or events (by updating the <code>time</code>
variable).
</p>
<p>You can call the <code><a href="#topic+eventTable">eventTable()</a></code> methods on the solved object to
update the event table and resolve the system of equations.
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler, Melissa Hallow and  Wenping Wang
</p>


<h3>References</h3>

<p>&quot;New Scaling and Squaring Algorithm for the Matrix Exponential&quot;, by
Awad H. Al-Mohy and Nicholas J. Higham, August 2009
</p>
<p>Roger B. Sidje (1998).  EXPOKIT: Software package for computing
matrix exponentials.  ACM - Transactions on Mathematical Software
<em>24</em>(1), 130-156.
</p>
<p>Hindmarsh, A. C.
<em>ODEPACK, A Systematized Collection of ODE Solvers</em>.
Scientific Computing, R. S. Stepleman et al. (Eds.),
North-Holland, Amsterdam, 1983, pp. 55-64.
</p>
<p>Petzold, L. R.
<em>Automatic Selection of Methods for Solving Stiff and Nonstiff
Systems of Ordinary Differential Equations</em>.
Siam J. Sci. Stat. Comput. 4 (1983), pp. 136-148.
</p>
<p>Hairer, E., Norsett, S. P., and Wanner, G.
<em>Solving ordinary differential equations I, nonstiff problems</em>.
2nd edition, Springer Series in Computational Mathematics,
Springer-Verlag (1993).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rxode2">rxode2()</a></code>
</p>

<hr>
<h2 id='rxSolveFree'>Free the C solving/parsing information.</h2><span id='topic+rxSolveFree'></span>

<h3>Description</h3>

<p>Take the ODE C system and free it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSolveFree()
</code></pre>


<h3>Value</h3>

<p>logical indicating if the memory was successfully freed
</p>

<hr>
<h2 id='rxSplitPlusQ'>This function splits a function based on + or - terms</h2><span id='topic+rxSplitPlusQ'></span>

<h3>Description</h3>

<p>It uses the parser and does not disturb terms within other
functions.  For example:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSplitPlusQ(x, level = 0, mult = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxSplitPlusQ_+3A_x">x</code></td>
<td>
<p>Quoted R expression for splitting</p>
</td></tr>
<tr><td><code id="rxSplitPlusQ_+3A_level">level</code></td>
<td>
<p>Internal level of parsing</p>
</td></tr>
<tr><td><code id="rxSplitPlusQ_+3A_mult">mult</code></td>
<td>
<p>boolean to split based on * and / expressions instead.
By default this is turned off.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>a<em>exp(b+c)+d</em>log(e-f)-g*f
</p>
<p>would return
</p>
<p>c(&quot;a * exp(b + c)&quot;, &quot;d * log(e - f)&quot;, &quot;- g * f&quot;)
</p>


<h3>Value</h3>

<p>character vector of the split expressions
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxState'>State variables</h2><span id='topic+rxState'></span>

<h3>Description</h3>

<p>This returns the model's compartments or states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxState(obj = NULL, state = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxState_+3A_obj">obj</code></td>
<td>
<p>rxode2 family of objects</p>
</td></tr>
<tr><td><code id="rxState_+3A_state">state</code></td>
<td>
<p>is a string indicating the state or compartment that
you would like to lookup.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If state is missing, return a character vector of all the states.
</p>
<p>If state is a string, return the compartment number of the named state.
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rxode2">rxode2()</a></code>
</p>
<p>Other Query model information: 
<code><a href="#topic+rxDfdy">rxDfdy</a>()</code>,
<code><a href="#topic+rxInits">rxInits</a>()</code>,
<code><a href="#topic+rxLhs">rxLhs</a>()</code>,
<code><a href="#topic+rxModelVars">rxModelVars</a>()</code>,
<code><a href="#topic+rxParams">rxParams</a>()</code>
</p>

<hr>
<h2 id='rxSumProdModel'>Recast model in terms of sum/prod</h2><span id='topic+rxSumProdModel'></span>

<h3>Description</h3>

<p>Recast model in terms of sum/prod
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSumProdModel(model, expand = FALSE, sum = TRUE, prod = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxSumProdModel_+3A_model">model</code></td>
<td>
<p>rxode2 model</p>
</td></tr>
<tr><td><code id="rxSumProdModel_+3A_expand">expand</code></td>
<td>
<p>Boolean indicating if the expression is expanded.</p>
</td></tr>
<tr><td><code id="rxSumProdModel_+3A_sum">sum</code></td>
<td>
<p>Use sum(...)</p>
</td></tr>
<tr><td><code id="rxSumProdModel_+3A_prod">prod</code></td>
<td>
<p>Use prod(...)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>model string with prod(.) and sum(.) for all these
operations.
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxSupportedFuns'>Get list of supported functions</h2><span id='topic+rxSupportedFuns'></span>

<h3>Description</h3>

<p>Get list of supported functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSupportedFuns()
</code></pre>


<h3>Value</h3>

<p>list of supported functions in rxode2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rxSupportedFuns()
</code></pre>

<hr>
<h2 id='rxSuppressMsg'>Respect suppress messages</h2><span id='topic+rxSuppressMsg'></span>

<h3>Description</h3>

<p>This turns on the silent REprintf in C when <code>suppressMessages()</code> is
turned on. This makes the <code>REprintf</code> act like <code>messages</code> in R,
they can be suppressed with <code>suppressMessages()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSuppressMsg()
</code></pre>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# rxSupressMsg() is called with rxode2()

# Note the errors are output to the console

try(rxode2("d/dt(matt)=/3"), silent = TRUE)

# When using suppressMessages, the output is suppressed

suppressMessages(try(rxode2("d/dt(matt)=/3"), silent = TRUE))

# In rxode2, we use REprintf so that interrupted threads do not crash R
# if there is a user interrupt. This isn't captured by R's messages, but
# This interface allows the `suppressMessages()` to suppress the C printing
# as well

# If you  want to suppress messages from rxode2 in other packages, you can use
# this function
</code></pre>

<hr>
<h2 id='rxSymInvChol'>Get Omega^-1 and derivatives</h2><span id='topic+rxSymInvChol'></span>

<h3>Description</h3>

<p>Get Omega^-1 and derivatives
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSymInvChol(
  invObjOrMatrix,
  theta = NULL,
  type = "cholOmegaInv",
  thetaNumber = 0L
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxSymInvChol_+3A_invobjormatrix">invObjOrMatrix</code></td>
<td>
<p>Object for inverse-type calculations.  If
this is a matrix, setup the object for inversion
<code><a href="#topic+rxSymInvCholCreate">rxSymInvCholCreate()</a></code> with the default arguments and return a
reactive s3 object.  Otherwise, use the inversion object to
calculate the requested derivative/inverse.</p>
</td></tr>
<tr><td><code id="rxSymInvChol_+3A_theta">theta</code></td>
<td>
<p>Thetas to be used for calculation.  If missing (<code>NULL</code>), a
special s3 class is created and returned to access <code>Omega^1</code>
objects as needed and cache them based on the theta that is
used.</p>
</td></tr>
<tr><td><code id="rxSymInvChol_+3A_type">type</code></td>
<td>
<p>The type of object.  Currently the following types are
supported:
</p>

<ul>
<li> <p><code>cholOmegaInv</code> gives the
Cholesky decomposition of the Omega Inverse matrix.
</p>
</li>
<li> <p><code>omegaInv</code> gives the Omega Inverse matrix.
</p>
</li>
<li> <p><code>d(omegaInv)</code> gives the <code>d(Omega^-1)</code> withe respect to the
theta parameter specified in <code>thetaNumber</code>.
</p>
</li>
<li> <p><code>d(D)</code> gives the <code>d(diagonal(Omega^-1))</code> with respect to
the theta parameter specified in the <code>thetaNumber</code>
parameter
</p>
</li></ul>
</td></tr>
<tr><td><code id="rxSymInvChol_+3A_thetanumber">thetaNumber</code></td>
<td>
<p>For types <code>d(omegaInv)</code> and <code>d(D)</code>,
the theta number that the derivative is taken against.  This
must be positive from 1 to the number of thetas defining the
Omega matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix based on parameters or environment with all the
matrixes calculated in variables <code>omega</code>, <code>omegaInv</code>, <code>dOmega</code>,
<code>dOmegaInv</code>.
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxSymInvCholCreate'>Creates an object for calculating Omega/Omega^-1 and derivatives</h2><span id='topic+rxSymInvCholCreate'></span>

<h3>Description</h3>

<p>Creates an object for calculating Omega/Omega^-1 and derivatives
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSymInvCholCreate(
  mat,
  diag.xform = c("sqrt", "log", "identity"),
  create.env = TRUE,
  envir = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxSymInvCholCreate_+3A_mat">mat</code></td>
<td>
<p>Initial Omega matrix</p>
</td></tr>
<tr><td><code id="rxSymInvCholCreate_+3A_diag.xform">diag.xform</code></td>
<td>
<p>transformation to diagonal elements of OMEGA. or <code>chol(Omega^-1)</code></p>
</td></tr>
<tr><td><code id="rxSymInvCholCreate_+3A_create.env">create.env</code></td>
<td>
<p>&ndash; Create an environment to calculate the inverses. (By default TRUE)</p>
</td></tr>
<tr><td><code id="rxSymInvCholCreate_+3A_envir">envir</code></td>
<td>
<p>&ndash; Environment to evaluate function, bu default it is the parent frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A rxSymInv object OR a rxSymInv environment
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxSymInvCholN'>Return the dimension of the built-in derivatives/inverses</h2><span id='topic+rxSymInvCholN'></span>

<h3>Description</h3>

<p>Return the dimension of the built-in derivatives/inverses
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSymInvCholN()
</code></pre>


<h3>Value</h3>

<p>dimension of built-in derivatives/inverses
</p>

<hr>
<h2 id='rxSyncOptions'>Sync options with rxode2 variables</h2><span id='topic+rxSyncOptions'></span>

<h3>Description</h3>

<p>Accessing rxode2 options via getOption slows down solving.  This
allows the options to be synced with variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSyncOptions(setDefaults = c("none", "permissive", "strict"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxSyncOptions_+3A_setdefaults">setDefaults</code></td>
<td>
<p>This will setup rxode2's default solving options with the following options:
</p>

<ul>
<li> <p><code>"none"</code> leave the options alone
</p>
</li>
<li> <p><code>"permissive"</code> This is a permissive option set similar to R language specifications.
</p>
</li>
<li> <p><code>"strict"</code> This is a strict option set similar to the original
rxode2(). It requires semicolons at the end of lines and equals for
assignment
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing; called for side effects
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxSyntaxFunctions'>A list and description of Rode supported syntax functions</h2><span id='topic+rxSyntaxFunctions'></span>

<h3>Description</h3>

<p>A list and description of Rode supported syntax functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSyntaxFunctions
</code></pre>


<h3>Format</h3>

<p>A data frame with 3 columns and 98 rows
</p>

<dl>
<dt>Function</dt><dd><p>Reserved function Name</p>
</dd>
<dt>Description</dt><dd><p>Description of function</p>
</dd>
<dt>Aliases</dt><dd><p>Function Aliases</p>
</dd>
</dl>


<hr>
<h2 id='rxt'>Simulate student t variable from threefry generator</h2><span id='topic+rxt'></span>

<h3>Description</h3>

<p>Care should be taken with this method not to encounter the
birthday problem, described
<a href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/">https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/</a>.
Since the <code>sitmo</code> <code>threefry</code>, this currently generates
one random deviate from the uniform distribution to seed the
engine <code>threefry</code> and then run the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxt(df, n = 1L, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxt_+3A_df">df</code></td>
<td>
<p>degrees of freedom (<code class="reqn">&gt; 0</code>, maybe non-integer).  <code>df
      = Inf</code> is allowed.</p>
</td></tr>
<tr><td><code id="rxt_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="rxt_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the simulation
</p>
<p><code>rxnorm</code> simulates using the threefry sitmo generator.
</p>
<p><code>rxnormV</code> used to simulate with the vandercorput simulator, but
since it didn't satisfy the normal properties it was changed to simple be
an alias of <code>rxnorm</code>. It is no longer supported in <code>rxode2({})</code> blocks</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Therefore, a simple call to the random number generated followed by a second
call to random number generated may have identical seeds.  As the number of
random number generator calls are increased the probability that the
birthday problem will increase.
</p>
<p>The key to avoid this problem is to either run all simulations in the
<code>rxode2</code> environment once (therefore one seed or series of seeds
for the whole simulation), pre-generate all random variables
used for the simulation, or seed the rxode2 engine with <code>rxSetSeed()</code>
</p>
<p>Internally each ID is seeded with a unique number so that the
results do not depend on the number of cores used.
</p>


<h3>Value</h3>

<p>t-distribution random numbers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Use threefry engine
rxt(df = 3, n = 10) # with rxt you have to explicitly state n
rxt(df = 3, n = 10, ncores = 2) # You can parallelize the simulation using openMP

rxt(4) ## The first argument is the df parameter


## This example uses `rxt` directly in the model

rx &lt;- function() {
   model({
    a &lt;- rxt(3)
   })
}

et &lt;- et(1, id = 1:2)

s &lt;- rxSolve(rx, et)


</code></pre>

<hr>
<h2 id='rxTempDir'>Get the rxode2 temporary directory</h2><span id='topic+rxTempDir'></span>

<h3>Description</h3>

<p>Get the rxode2 temporary directory
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxTempDir()
</code></pre>


<h3>Value</h3>

<p>rxode2 temporary directory.
</p>

<hr>
<h2 id='rxTheme'>rxTheme is the ggplot2 theme for rxode2 plots</h2><span id='topic+rxTheme'></span>

<h3>Description</h3>

<p>rxTheme is the ggplot2 theme for rxode2 plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxTheme(
  base_size = 11,
  base_family = "",
  base_line_size = base_size/22,
  base_rect_size = base_size/22,
  grid = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxTheme_+3A_base_size">base_size</code></td>
<td>
<p>base font size, given in pts.</p>
</td></tr>
<tr><td><code id="rxTheme_+3A_base_family">base_family</code></td>
<td>
<p>base font family</p>
</td></tr>
<tr><td><code id="rxTheme_+3A_base_line_size">base_line_size</code></td>
<td>
<p>base size for line elements</p>
</td></tr>
<tr><td><code id="rxTheme_+3A_base_rect_size">base_rect_size</code></td>
<td>
<p>base size for rect elements</p>
</td></tr>
<tr><td><code id="rxTheme_+3A_grid">grid</code></td>
<td>
<p>a Boolean indicating if the grid is on (<code>TRUE</code>) or off
(<code>FALSE</code>). This could also be a character indicating <code>x</code> or <code>y</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 theme used in rxode2
</p>


<h3>See Also</h3>

<p>Other rxode2 plotting: 
<code><a href="#topic+plot.rxSolve">plot.rxSolve</a>()</code>
</p>

<hr>
<h2 id='rxToSE'>rxode2 to symengine environment</h2><span id='topic+rxToSE'></span><span id='topic+.rxToSE'></span><span id='topic+rxFromSE'></span><span id='topic+.rxFromSE'></span>

<h3>Description</h3>

<p>rxode2 to symengine environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxToSE(
  x,
  envir = NULL,
  progress = FALSE,
  promoteLinSens = TRUE,
  parent = parent.frame()
)

.rxToSE(x, envir = NULL, progress = FALSE)

rxFromSE(
  x,
  unknownDerivatives = c("forward", "central", "error"),
  parent = parent.frame()
)

.rxFromSE(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxToSE_+3A_x">x</code></td>
<td>
<p>expression</p>
</td></tr>
<tr><td><code id="rxToSE_+3A_envir">envir</code></td>
<td>
<p>default is <code>NULL</code>; Environment to put symengine
variables in.</p>
</td></tr>
<tr><td><code id="rxToSE_+3A_progress">progress</code></td>
<td>
<p>shows progress bar if true.</p>
</td></tr>
<tr><td><code id="rxToSE_+3A_promotelinsens">promoteLinSens</code></td>
<td>
<p>Promote solved linear compartment systems to
sensitivity-based solutions.</p>
</td></tr>
<tr><td><code id="rxToSE_+3A_parent">parent</code></td>
<td>
<p>is the parent environment to look for R-based user functions</p>
</td></tr>
<tr><td><code id="rxToSE_+3A_unknownderivatives">unknownDerivatives</code></td>
<td>
<p>When handling derivatives from unknown
functions, the translator will translate into different types
of numeric derivatives.  The currently supported methods are:
</p>
<div class="sourceCode"><pre>- `forward` for forward differences
- `central` for central differences
- `error` for throwing an error for unknown derivatives
</pre></div></td></tr>
</table>


<h3>Value</h3>

<p>An rxode2 symengine environment
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxTrans'>Translate the model to C code if needed</h2><span id='topic+rxTrans'></span><span id='topic+rxTrans.default'></span><span id='topic+rxTrans.character'></span>

<h3>Description</h3>

<p>This function translates the model to C code, if needed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxTrans(
  model,
  modelPrefix = "",
  md5 = "",
  modName = NULL,
  modVars = FALSE,
  ...
)

## Default S3 method:
rxTrans(
  model,
  modelPrefix = "",
  md5 = "",
  modName = NULL,
  modVars = FALSE,
  ...
)

## S3 method for class 'character'
rxTrans(
  model,
  modelPrefix = "",
  md5 = "",
  modName = NULL,
  modVars = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxTrans_+3A_model">model</code></td>
<td>
<p>This is the ODE model specification.  It can be:
</p>

<ul>
<li><p> a string containing the set of ordinary differential
equations (ODE) and other expressions defining the changes in
the dynamic system.
</p>
</li>
<li><p> a file name where the ODE system equation is contained
</p>
</li></ul>

<p>An ODE expression enclosed in <code style="white-space: pre;">&#8288;\{\}&#8288;</code>
</p>
<p>(see also the <code>filename</code> argument). For
details, see the sections &ldquo;Details&rdquo; and
<code style="white-space: pre;">&#8288;rxode2 Syntax&#8288;</code> below.</p>
</td></tr>
<tr><td><code id="rxTrans_+3A_modelprefix">modelPrefix</code></td>
<td>
<p>Prefix of the model functions that will be
compiled to make sure that multiple rxode2 objects can coexist
in the same R session.</p>
</td></tr>
<tr><td><code id="rxTrans_+3A_md5">md5</code></td>
<td>
<p>Is the md5 of the model before parsing, and is used to
embed the md5 into DLL, and then provide for functions like
<code><a href="#topic+rxModelVars">rxModelVars()</a></code>.</p>
</td></tr>
<tr><td><code id="rxTrans_+3A_modname">modName</code></td>
<td>
<p>a string to be used as the model name. This string
is used for naming various aspects of the computations,
including generating C symbol names, dynamic libraries,
etc. Therefore, it is necessary that <code>modName</code> consists of
simple ASCII alphanumeric characters starting with a letter.</p>
</td></tr>
<tr><td><code id="rxTrans_+3A_modvars">modVars</code></td>
<td>
<p>returns the model variables instead of the named
vector of translated properties.</p>
</td></tr>
<tr><td><code id="rxTrans_+3A_...">...</code></td>
<td>
<p>Ignored parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named vector of translated model properties
including what type of jacobian is specified, the <code>C</code> function prefixes,
as well as the <code>C</code> functions names to be called through the compiled model.
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rxode2">rxode2()</a></code>, <code><a href="#topic+rxCompile">rxCompile()</a></code>.
</p>

<hr>
<h2 id='rxUiDecompress'>Compress/Decompress <code>rxode2</code> ui</h2><span id='topic+rxUiDecompress'></span><span id='topic+rxUiCompress'></span>

<h3>Description</h3>

<p>Compress/Decompress <code>rxode2</code> ui
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxUiDecompress(ui)

rxUiCompress(ui)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxUiDecompress_+3A_ui">ui</code></td>
<td>
<p>rxode2 ui object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A compressed or decompressed rxui object
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>one.cmt &lt;- function() {
  ini({
    ## You may label each parameter with a comment
    tka &lt;- 0.45 # Log Ka
    tcl &lt;- log(c(0, 2.7, 100)) # Log Cl
    ## This works with interactive models
    ## You may also label the preceding line with label("label text")
    tv &lt;- 3.45; label("log V")
    ## the label("Label name") works with all models
    eta.ka ~ 0.6
    eta.cl ~ 0.3
    eta.v ~ 0.1
    add.sd &lt;- 0.7
  })
  model({
    ka &lt;- exp(tka + eta.ka)
    cl &lt;- exp(tcl + eta.cl)
    v &lt;- exp(tv + eta.v)
    linCmt() ~ add(add.sd) | tmp
  })
}

f &lt;- rxode2(one.cmt)
print(class(f))
print(is.environment(f))

f  &lt;- rxUiDecompress(f)
print(class(f))
print(is.environment(f))

f  &lt;- rxUiCompress(f)
print(class(f))
print(is.environment(f))

</code></pre>

<hr>
<h2 id='rxUiGet.cmtLines'>S3 for getting information from UI model</h2><span id='topic+rxUiGet.cmtLines'></span><span id='topic+rxUiGet.dvidLine'></span><span id='topic+rxUiGet.paramsLine'></span><span id='topic+rxUiGet.simulationSigma'></span><span id='topic+rxUiGet.simulationModel'></span><span id='topic+rxUiGet.symengineModelNoPrune'></span><span id='topic+rxUiGet.symengineModelPrune'></span><span id='topic+rxUiGet.simulationIniModel'></span><span id='topic+rxUiGet'></span><span id='topic+rxUiGet.params'></span><span id='topic+rxUiGet.theta'></span><span id='topic+rxUiGet.lstChr'></span><span id='topic+rxUiGet.omega'></span><span id='topic+rxUiGet.funTxt'></span><span id='topic+rxUiGet.allCovs'></span><span id='topic+rxUiGet.muRefTable'></span><span id='topic+rxUiGet.multipleEndpoint'></span><span id='topic+rxUiGet.funPrint'></span><span id='topic+rxUiGet.fun'></span><span id='topic+rxUiGet.md5'></span><span id='topic+rxUiGet.ini'></span><span id='topic+rxUiGet.iniFun'></span><span id='topic+rxUiGet.modelFun'></span><span id='topic+rxUiGet.model'></span><span id='topic+rxUiGet.modelDesc'></span><span id='topic+rxUiGet.thetaLower'></span><span id='topic+rxUiGet.thetaUpper'></span><span id='topic+rxUiGet.lhsVar'></span><span id='topic+rxUiGet.varLhs'></span><span id='topic+rxUiGet.lhsEta'></span><span id='topic+rxUiGet.lhsTheta'></span><span id='topic+rxUiGet.lhsCov'></span><span id='topic+rxUiGet.etaLhs'></span><span id='topic+rxUiGet.thetaLhs'></span><span id='topic+rxUiGet.covLhs'></span><span id='topic+rxUiGet.default'></span>

<h3>Description</h3>

<p>S3 for getting information from UI model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cmtLines'
rxUiGet(x, ...)

## S3 method for class 'dvidLine'
rxUiGet(x, ...)

## S3 method for class 'paramsLine'
rxUiGet(x, ...)

## S3 method for class 'simulationSigma'
rxUiGet(x, ...)

## S3 method for class 'simulationModel'
rxUiGet(x, ...)

## S3 method for class 'symengineModelNoPrune'
rxUiGet(x, ...)

## S3 method for class 'symengineModelPrune'
rxUiGet(x, ...)

## S3 method for class 'simulationIniModel'
rxUiGet(x, ...)

rxUiGet(x, ...)

## S3 method for class 'params'
rxUiGet(x, ...)

## S3 method for class 'theta'
rxUiGet(x, ...)

## S3 method for class 'lstChr'
rxUiGet(x, ...)

## S3 method for class 'omega'
rxUiGet(x, ...)

## S3 method for class 'funTxt'
rxUiGet(x, ...)

## S3 method for class 'allCovs'
rxUiGet(x, ...)

## S3 method for class 'muRefTable'
rxUiGet(x, ...)

## S3 method for class 'multipleEndpoint'
rxUiGet(x, ...)

## S3 method for class 'funPrint'
rxUiGet(x, ...)

## S3 method for class 'fun'
rxUiGet(x, ...)

## S3 method for class 'md5'
rxUiGet(x, ...)

## S3 method for class 'ini'
rxUiGet(x, ...)

## S3 method for class 'iniFun'
rxUiGet(x, ...)

## S3 method for class 'modelFun'
rxUiGet(x, ...)

## S3 method for class 'model'
rxUiGet(x, ...)

## S3 method for class 'modelDesc'
rxUiGet(x, ...)

## S3 method for class 'thetaLower'
rxUiGet(x, ...)

## S3 method for class 'thetaUpper'
rxUiGet(x, ...)

## S3 method for class 'lhsVar'
rxUiGet(x, ...)

## S3 method for class 'varLhs'
rxUiGet(x, ...)

## S3 method for class 'lhsEta'
rxUiGet(x, ...)

## S3 method for class 'lhsTheta'
rxUiGet(x, ...)

## S3 method for class 'lhsCov'
rxUiGet(x, ...)

## S3 method for class 'etaLhs'
rxUiGet(x, ...)

## S3 method for class 'thetaLhs'
rxUiGet(x, ...)

## S3 method for class 'covLhs'
rxUiGet(x, ...)

## Default S3 method:
rxUiGet(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxUiGet.cmtLines_+3A_x">x</code></td>
<td>
<p>list of (UIenvironment, exact).  UI environment is the
parsed function for rxode2.  <code>exact</code> is a boolean that says if an
exact match is required.</p>
</td></tr>
<tr><td><code id="rxUiGet.cmtLines_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>value that was requested from the UI object
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='rxunif'>Simulate uniform variable from threefry generator</h2><span id='topic+rxunif'></span>

<h3>Description</h3>

<p>Care should be taken with this method not to encounter the
birthday problem, described
<a href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/">https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/</a>.
Since the <code>sitmo</code> <code>threefry</code>, this currently generates
one random deviate from the uniform distribution to seed the
engine <code>threefry</code> and then run the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxunif(min = 0, max = 1, n = 1L, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxunif_+3A_min">min</code>, <code id="rxunif_+3A_max">max</code></td>
<td>
<p>lower and upper limits of the distribution.  Must be finite.</p>
</td></tr>
<tr><td><code id="rxunif_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="rxunif_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the simulation
</p>
<p><code>rxnorm</code> simulates using the threefry sitmo generator.
</p>
<p><code>rxnormV</code> used to simulate with the vandercorput simulator, but
since it didn't satisfy the normal properties it was changed to simple be
an alias of <code>rxnorm</code>. It is no longer supported in <code>rxode2({})</code> blocks</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Therefore, a simple call to the random number generated followed by a second
call to random number generated may have identical seeds.  As the number of
random number generator calls are increased the probability that the
birthday problem will increase.
</p>
<p>The key to avoid this problem is to either run all simulations in the
<code>rxode2</code> environment once (therefore one seed or series of seeds
for the whole simulation), pre-generate all random variables
used for the simulation, or seed the rxode2 engine with <code>rxSetSeed()</code>
</p>
<p>Internally each ID is seeded with a unique number so that the
results do not depend on the number of cores used.
</p>


<h3>Value</h3>

<p>uniform random numbers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Use threefry engine

rxunif(min = 0, max = 4, n = 10) # with rxunif you have to explicitly state n
rxunif(min = 0, max = 4, n = 10, ncores = 2) # You can parallelize the simulation using openMP

rxunif()


## This example uses `rxunif` directly in the model

rx &lt;- function() {
  model({
    a &lt;- rxunif(0, 3)
  })
}

et &lt;- et(1, id = 1:2)

s &lt;- rxSolve(rx, et)


</code></pre>

<hr>
<h2 id='rxUnloadAll'>Unloads all rxode2 compiled DLLs</h2><span id='topic+rxUnloadAll'></span>

<h3>Description</h3>

<p>Unloads all rxode2 compiled DLLs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxUnloadAll()
</code></pre>


<h3>Value</h3>

<p>List of rxode2 dlls still loaded
</p>
<p>boolean of if all rxode2 dlls have been unloaded
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
print(rxUnloadAll())
</code></pre>

<hr>
<h2 id='rxUse'>Use model object in your package</h2><span id='topic+rxUse'></span>

<h3>Description</h3>

<p>Use model object in your package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxUse(obj, overwrite = TRUE, compress = "bzip2", internal = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxUse_+3A_obj">obj</code></td>
<td>
<p>model to save.</p>
</td></tr>
<tr><td><code id="rxUse_+3A_overwrite">overwrite</code></td>
<td>
<p>By default, <code>use_data()</code> will not overwrite existing
files. If you really want to do so, set this to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="rxUse_+3A_compress">compress</code></td>
<td>
<p>Choose the type of compression used by <code><a href="base.html#topic+save">save()</a></code>.
Should be one of &quot;gzip&quot;, &quot;bzip2&quot;, or &quot;xz&quot;.</p>
</td></tr>
<tr><td><code id="rxUse_+3A_internal">internal</code></td>
<td>
<p>If this is run internally.  By default this is FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing; This is used for its side effects and shouldn't be called by a user
</p>

<hr>
<h2 id='rxValidate'>Validate rxode2
This allows easy validation/qualification of nlmixr by running the
testing suite on your system.</h2><span id='topic+rxValidate'></span><span id='topic+rxTest'></span>

<h3>Description</h3>

<p>Validate rxode2
This allows easy validation/qualification of nlmixr by running the
testing suite on your system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxValidate(type = NULL, skipOnCran = TRUE)

rxTest(type = NULL, skipOnCran = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxValidate_+3A_type">type</code></td>
<td>
<p>Type of test or filter of test type, When this is an
expression, evaluate the contents, respecting <code>skipOnCran</code></p>
</td></tr>
<tr><td><code id="rxValidate_+3A_skiponcran">skipOnCran</code></td>
<td>
<p>when <code>TRUE</code> skip the test on CRAN.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxVersion'>Version and repository for this dparser package.</h2><span id='topic+rxVersion'></span>

<h3>Description</h3>

<p>Version and repository for this dparser package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxVersion(
  extra = "",
  echo = FALSE,
  version = sessionInfo()$otherPkgs$rxode2$Version
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxVersion_+3A_extra">extra</code></td>
<td>
<p>extra text to display in the logo</p>
</td></tr>
<tr><td><code id="rxVersion_+3A_echo">echo</code></td>
<td>
<p>Boolean to echo the text logo, by default FALSE</p>
</td></tr>
<tr><td><code id="rxVersion_+3A_version">version</code></td>
<td>
<p>Version to display/return</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with the version and repository.
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxweibull'>Simulate Weibull variable from threefry generator</h2><span id='topic+rxweibull'></span>

<h3>Description</h3>

<p>Care should be taken with this method not to encounter the
birthday problem, described
<a href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/">https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/</a>.
Since the <code>sitmo</code> <code>threefry</code>, this currently generates
one random deviate from the uniform distribution to seed the
engine <code>threefry</code> and then run the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxweibull(shape, scale = 1, n = 1L, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rxweibull_+3A_shape">shape</code>, <code id="rxweibull_+3A_scale">scale</code></td>
<td>
<p>shape and scale parameters, the latter defaulting to 1.</p>
</td></tr>
<tr><td><code id="rxweibull_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="rxweibull_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the simulation
</p>
<p><code>rxnorm</code> simulates using the threefry sitmo generator.
</p>
<p><code>rxnormV</code> used to simulate with the vandercorput simulator, but
since it didn't satisfy the normal properties it was changed to simple be
an alias of <code>rxnorm</code>. It is no longer supported in <code>rxode2({})</code> blocks</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Therefore, a simple call to the random number generated followed by a second
call to random number generated may have identical seeds.  As the number of
random number generator calls are increased the probability that the
birthday problem will increase.
</p>
<p>The key to avoid this problem is to either run all simulations in the
<code>rxode2</code> environment once (therefore one seed or series of seeds
for the whole simulation), pre-generate all random variables
used for the simulation, or seed the rxode2 engine with <code>rxSetSeed()</code>
</p>
<p>Internally each ID is seeded with a unique number so that the
results do not depend on the number of cores used.
</p>


<h3>Value</h3>

<p>Weibull random deviates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Use threefry engine

# with rxweibull you have to explicitly state n
rxweibull(shape = 1, scale = 4, n = 10)

# You can parallelize the simulation using openMP
rxweibull(shape = 1, scale = 4, n = 10, ncores = 2)

rxweibull(3)


## This example uses `rxweibull` directly in the model

rx &lt;- function() {
  model({
    a &lt;- rxweibull(1, 3)
  })
}

et &lt;- et(1, id = 1:2)

s &lt;- rxSolve(rx, et)

</code></pre>

<hr>
<h2 id='stat_amt'>Dosing/Amt geom/stat</h2><span id='topic+stat_amt'></span><span id='topic+geom_amt'></span>

<h3>Description</h3>

<p>This is a dosing geom that shows the vertical lines where a dose occurs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_amt(
  mapping = NULL,
  data = NULL,
  position = "identity",
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

geom_amt(
  mapping = NULL,
  data = NULL,
  position = "identity",
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_amt_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_amt_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_amt_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="stat_amt_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="stat_amt_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_amt_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requires the following aesthetics:
</p>

<ul>
<li><p> x representing the x values, usually time
</p>
</li>
<li><p> amt representing the dosing values;  They are missing or zero when no dose is given
</p>
</li></ul>



<h3>Value</h3>

<p>This returns a stat_amt in context of a ggplot2 plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(rxode2)
library(units)


## Model from RxODE tutorial
mod1 &lt;- function() {
  ini({
    KA &lt;- 2.94E-01
    CL &lt;- 1.86E+01
    V2 &lt;- 4.02E+01
    Q  &lt;- 1.05E+01
    V3 &lt;- 2.97E+02
    Kin &lt;- 1
    Kout &lt;- 1
    EC50 &lt;- 200
  })
  model({
    C2 &lt;- centr/V2
    C3 &lt;- peri/V3
    d/dt(depot) &lt;- -KA*depot
    d/dt(centr) &lt;-  KA*depot - CL*C2 - Q*C2 + Q*C3
    d/dt(peri)  &lt;-                    Q*C2 - Q*C3
    d/dt(eff)   &lt;- Kin - Kout*(1-C2/(EC50+C2))*eff
  })
}

## These are making the more complex regimens of the rxode2 tutorial

## bid for 5 days
bid &lt;- et(timeUnits="hr") %&gt;%
  et(amt=10000,ii=12,until=set_units(5, "days"))

## qd for 5 days
qd &lt;- et(timeUnits="hr") %&gt;%
      et(amt=20000,ii=24,until=set_units(5, "days"))

## bid for 5 days followed by qd for 5 days

et &lt;- seq(bid,qd) %&gt;% et(seq(0,11*24,length.out=100))

bidQd &lt;- rxSolve(mod1, et, addDosing=TRUE)

# by default dotted and under-stated
plot(bidQd, C2) + geom_amt(aes(amt=amt))

# of course you can make it a bit more visible

plot(bidQd, C2) + geom_amt(aes(amt=amt), col="red", lty=1, linewidth=1.2)


</code></pre>

<hr>
<h2 id='stat_cens'>Censoring geom/stat</h2><span id='topic+stat_cens'></span><span id='topic+geom_cens'></span>

<h3>Description</h3>

<p>This is a censoring geom that shows the left or right censoring specified in the nlmixr input data-set or fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_cens(
  mapping = NULL,
  data = NULL,
  position = "identity",
  show.legend = NA,
  inherit.aes = TRUE,
  width = 0.01,
  ...
)

geom_cens(
  mapping = NULL,
  data = NULL,
  position = "identity",
  show.legend = NA,
  inherit.aes = TRUE,
  width = 0.01,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stat_cens_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_cens_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_cens_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string naming the adjustment
(e.g. <code>"jitter"</code> to use <code>position_jitter</code>), or the result of a call to a
position adjustment function. Use the latter if you need to change the
settings of the adjustment.</p>
</td></tr>
<tr><td><code id="stat_cens_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="stat_cens_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_cens_+3A_width">width</code></td>
<td>
<p>represents the width (in \
censoring box</p>
</td></tr>
<tr><td><code id="stat_cens_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>. These are
often aesthetics, used to set an aesthetic to a fixed value, like
<code>colour = "red"</code> or <code>size = 3</code>. They may also be parameters
to the paired geom/stat.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Requires the following aesthetics:
</p>

<ul>
<li> <p><code>x</code> Represents the independent variable, often the time scale
</p>
</li>
<li> <p><code>y</code> represents the dependent variable
</p>
</li>
<li> <p><code>CENS</code> for the censoring information; (<code>-1</code> right censored, <code>0</code> no censoring or <code>1</code> left censoring)
</p>
</li>
<li> <p><code>LIMIT</code> which represents the corresponding limit ()
</p>
</li></ul>

<p>Will add boxes representing the areas of the fit that were censored.
</p>


<h3>Value</h3>

<p>This returns a ggplot2 stat
</p>

<hr>
<h2 id='summary.rxDll'>Summary of rxDll object</h2><span id='topic+summary.rxDll'></span>

<h3>Description</h3>

<p>This gives expanded information about the rxDll object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rxDll'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.rxDll_+3A_object">object</code></td>
<td>
<p>RxDll object</p>
</td></tr>
<tr><td><code id="summary.rxDll_+3A_...">...</code></td>
<td>
<p>Other arguments.  Includes <code>noprint</code>, which is a
logical telling if the object should print the rxDll object
first. By default this is FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object is returned
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>

<hr>
<h2 id='summary.rxode2'>Print expanded information about the rxode2 object.</h2><span id='topic+summary.rxode2'></span>

<h3>Description</h3>

<p>This prints the expanded information about the rxode2 object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rxode2'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.rxode2_+3A_object">object</code></td>
<td>
<p>rxode2 object</p>
</td></tr>
<tr><td><code id="summary.rxode2_+3A_...">...</code></td>
<td>
<p>Ignored parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object is returned
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>

<hr>
<h2 id='update.rxUi'>Update for rxUi</h2><span id='topic+update.rxUi'></span>

<h3>Description</h3>

<p>Update for rxUi
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rxUi'
update(object, ..., envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update.rxUi_+3A_object">object</code></td>
<td>
<p>rxode2 UI object</p>
</td></tr>
<tr><td><code id="update.rxUi_+3A_...">...</code></td>
<td>
<p>Lines to update</p>
</td></tr>
<tr><td><code id="update.rxUi_+3A_envir">envir</code></td>
<td>
<p>Environment for evaluating ini() style calls</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a new rxode2 updated UI object
</p>

<hr>
<h2 id='uppergamma'>uppergamma:  upper incomplete gamma function</h2><span id='topic+uppergamma'></span>

<h3>Description</h3>

<p>This is the tgamma from the boost library
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uppergamma(a, z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uppergamma_+3A_a">a</code></td>
<td>
<p>The numeric 'a' parameter in the upper
incomplete gamma</p>
</td></tr>
<tr><td><code id="uppergamma_+3A_z">z</code></td>
<td>
<p>The numeric 'z' parameter in the upper
incomplete gamma</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The uppergamma function is given by:
</p>
<p><code class="reqn">uppergamma(a, z) = \int_{z}^{\infty}t^{a-1}\cdot e^{-t} dt</code>
</p>


<h3>Value</h3>

<p>uppergamma results
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
uppergamma(1, 3)

uppergamma(1:3, 3)

uppergamma(1, 1:3)
</code></pre>

<hr>
<h2 id='zeroRe'>Set random effects and residual error to zero</h2><span id='topic+zeroRe'></span>

<h3>Description</h3>

<p>Set random effects and residual error to zero
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zeroRe(object, which = c("omega", "sigma"), fix = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zeroRe_+3A_object">object</code></td>
<td>
<p>The model to modify</p>
</td></tr>
<tr><td><code id="zeroRe_+3A_which">which</code></td>
<td>
<p>The types of parameters to set to zero</p>
</td></tr>
<tr><td><code id="zeroRe_+3A_fix">fix</code></td>
<td>
<p>Should the parameters be fixed to the zero value?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>object</code> with some parameters set to zero
</p>


<h3>Author(s)</h3>

<p>Bill Denney
</p>


<h3>See Also</h3>

<p>Other Initial conditions: 
<code><a href="#topic+ini.rxUi">ini.rxUi</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>one.compartment &lt;- function() {
  ini({
    tka &lt;- log(1.57); label("Ka")
    tcl &lt;- log(2.72); label("Cl")
    tv &lt;- log(31.5); label("V")
    eta.ka ~ 0.6
    eta.cl ~ 0.3
    eta.v ~ 0.1
    add.sd &lt;- 0.7
  })
  model({
    ka &lt;- exp(tka + eta.ka)
    cl &lt;- exp(tcl + eta.cl)
    v &lt;- exp(tv + eta.v)
    d/dt(depot) = -ka * depot
    d/dt(center) = ka * depot - cl / v * center
    cp = center / v
    cp ~ add(add.sd)
  })
}
zeroRe(one.compartment)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
