<!DOCTYPE html><html lang="en-US"><head><title>Help for package rxode2</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rxode2}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.assertRenameErrorModelLine'><p>This function asserts the requested rename makes sense</p></a></li>
<li><a href='#.cbindOme'><p>cbind Ome</p></a></li>
<li><a href='#.clearPipe'><p>Clear/Set pipeline</p></a></li>
<li><a href='#.collectWarnings'><p>Collect warnings and just warn once.</p></a></li>
<li><a href='#.convertId'><p>Convert a factor/char to an id</p></a></li>
<li><a href='#.copyUi'><p>This copies the rxode2 UI object so it can be modified</p></a></li>
<li><a href='#.expandPars'><p>Expand parameters</p></a></li>
<li><a href='#.extraC'><p>Generate extraC information for rxode2 models</p></a></li>
<li><a href='#.extraCnow'><p>Get the extraCnow for compiling</p></a></li>
<li><a href='#.getLastIdLvl'><p>Get the last <code>idLvl</code></p></a></li>
<li><a href='#.getWh'><p>Get the internal breakdown of an evid</p></a></li>
<li><a href='#.handleSingleErrTypeNormOrTFoceiBase'><p>Handle the single error for normal or t distributions</p></a></li>
<li><a href='#.iniGetAppendArg'><p>This gets the append arg for the ini() piping</p></a></li>
<li><a href='#.iniHandleAppend'><p>Reorder rows in iniDf</p></a></li>
<li><a href='#.iniHandleLine'><p>Update the iniDf of a model</p></a></li>
<li><a href='#.linCmtSensB'><p>Is the linear systems with gradients built-in</p></a></li>
<li><a href='#.matchesLangTemplate'><p>Check if a language object matches a template language object</p></a></li>
<li><a href='#.minfo'><p>Internal messaging statements</p></a></li>
<li><a href='#.modelHandleModelLines'><p>Handle model lines</p></a></li>
<li><a href='#.pipeRx'><p>Assign in the rxode2 pipeline</p></a></li>
<li><a href='#.quoteCallInfoLines'><p>Returns quoted call information</p></a></li>
<li><a href='#.rxBlankIni'><p>Get a blank, theta1, or eta1 initialization block for iniDf</p></a></li>
<li><a href='#.rxC'><p>Return the C code of an internal function</p></a></li>
<li><a href='#.rxDocTable'><p>Print out a table in the documentation</p></a></li>
<li><a href='#.rxGetHiBoundaryPred1AndIni'><p>Get the upper boundary condition when the transformation it</p></a></li>
<li><a href='#.rxGetLambdaFromPred1AndIni'><p>Get the lambda value based on the pred information</p></a></li>
<li><a href='#.rxGetLowBoundaryPred1AndIni'><p>Get the lower boundary condition when the transformation requires it</p></a></li>
<li><a href='#.rxGetPredictionDVTransform'><p>Get the Observation transformation</p></a></li>
<li><a href='#.rxGetPredictionF'><p>Get the prediction name</p></a></li>
<li><a href='#.rxGetPredictionFTransform'><p>Get the prediction transformation</p></a></li>
<li><a href='#.rxGetVarianceForErrorType'><p>Get Variance for error type</p></a></li>
<li><a href='#.rxIsLinCmt'><p>Internal function to tell if the linCmt() is the model variables</p></a></li>
<li><a href='#.rxJacobian'><p>Internal function for calculating the Jacobian</p></a></li>
<li><a href='#.rxLinCmtGen'><p>Internal function to generate the model variables for a linCmt() model</p></a></li>
<li><a href='#.rxode2ptrs'><p>Get the rxode2 function pointers</p></a></li>
<li><a href='#.rxPrune'><p>Internal Pruning function</p></a></li>
<li><a href='#.rxSEeqUsr'><p>Return the equivalents symengine user functions from C</p></a></li>
<li><a href='#.rxSens'><p>Sensitivity for model</p></a></li>
<li><a href='#.rxTransform'><p>rxode2 general transformation function</p></a></li>
<li><a href='#.rxTransInfo'><p>Get the information about the rxode2 derived parameter transformation</p></a></li>
<li><a href='#.rxWithOptions'><p>Temporarily set options then restore them while running code</p></a></li>
<li><a href='#.rxWithSink'><p>With one sink, then release</p></a></li>
<li><a href='#.rxWithWd'><p>Temporarily set options then restore them while running code</p></a></li>
<li><a href='#.s3register'><p>Register a method for a suggested dependency</p></a></li>
<li><a href='#.symengineFs'><p>Return symengineFs from user functions</p></a></li>
<li><a href='#.toClassicEvid'><p>This converts NONMEM-style EVIDs to classic RxODE events</p></a></li>
<li><a href='#.udfCallFunArg'><p>Get the function name with the current arguments as a string</p></a></li>
<li><a href='#.udfEnvReset'><p>Lock/Unlock environment for getting R user functions</p></a></li>
<li><a href='#.udfEnvSet'><p>Setup the UDF environment (for querying user defined funtions)</p></a></li>
<li><a href='#.udfEnvSetUdf'><p>Use the udf model variable information to get the environment where</p>
the functions exists</a></li>
<li><a href='#.udfExists'><p>See if the UI function exists in given environment.</p></a></li>
<li><a href='#.udfMd5Info'><p>Get the udf strings for creating model md5</p></a></li>
<li><a href='#.uiArg'><p>Handle arguments for ui functions</p></a></li>
<li><a href='#.useUtf'><p>Internal function to figure out if this session supports Unicode</p></a></li>
<li><a href='#.vecDf'><p>Convert numeric vector to repeated data.frame</p></a></li>
<li><a href='#+2B.rxSolve'><p>Update Solved object with '+'</p></a></li>
<li><a href='#add.dosing'><p>Add dosing to eventTable</p></a></li>
<li><a href='#add.sampling'><p>Add sampling to eventTable</p></a></li>
<li><a href='#as.et'><p>Coerce object to data.frame</p></a></li>
<li><a href='#as.ini'><p>Turn into an ini block for initialization</p></a></li>
<li><a href='#as.model'><p>Turn into a model expression</p></a></li>
<li><a href='#as.rxUi'><p>As rxode2 ui</p></a></li>
<li><a href='#assertCompartmentExists'><p>Verify that the compartment exists in a model</p></a></li>
<li><a href='#assertCompartmentName'><p>Verify that a value is a valid nlmixr2 compartment name</p></a></li>
<li><a href='#assertCompartmentNew'><p>Verify that a compartment would be new to the model</p></a></li>
<li><a href='#assertRxUi'><p>Assert properties of the rxUi models</p></a></li>
<li><a href='#assertVariableExists'><p>Assert a variable exists in the model</p></a></li>
<li><a href='#assertVariableNew'><p>Assert a variable would be new to the model</p></a></li>
<li><a href='#binomProbs'><p>Calculate expected confidence bands with binomial sampling distribution</p></a></li>
<li><a href='#boxCox'><p>boxCox/yeoJohnson and inverse boxCox/yeoJohnson functions</p></a></li>
<li><a href='#coef.rxode2'><p>Return the rxode2 coefficients</p></a></li>
<li><a href='#cvPost'><p>Sample a covariance Matrix from the Posterior Inverse Wishart</p>
distribution.</a></li>
<li><a href='#dELU'><p>Derivatives of the Exponential Linear Unit (ELU) Activation Function</p></a></li>
<li><a href='#dfWishart'><p>This uses simulations to match the rse</p></a></li>
<li><a href='#dGELU'><p>Derivatives of GELU</p></a></li>
<li><a href='#dlReLU'><p>Derivative of Leaky ReLU activation function</p></a></li>
<li><a href='#dPReLU'><p>Derivatives Parametric ReLU Activation Function</p></a></li>
<li><a href='#dReLU'><p>Derivative of the Rectified Linear Unit (ReLU) Activation Function</p></a></li>
<li><a href='#dSELU'><p>Derivative of the Scaled Exponential Linear Unit (SELU) Activation Function</p></a></li>
<li><a href='#dsoftplus'><p>Default Softplus Activation Function</p></a></li>
<li><a href='#dSwish'><p>Derivative of the Swish Activation Function</p></a></li>
<li><a href='#ELU'><p>Exponential Linear Unit (ELU) Activation Function</p></a></li>
<li><a href='#erf'><p>Error function</p></a></li>
<li><a href='#et'><p>Event Table Function</p></a></li>
<li><a href='#etExpand'><p>Expand additional doses</p></a></li>
<li><a href='#etRbind'><p>Combining event tables</p></a></li>
<li><a href='#etRep'><p>Repeat an rxode2 event table</p></a></li>
<li><a href='#etSeq'><p>Sequence of event tables</p></a></li>
<li><a href='#etTrans'><p>Event translation for rxode2</p></a></li>
<li><a href='#eventTable'><p>Create an event table object</p></a></li>
<li><a href='#findLhs'><p>Find the assignments in R expression</p></a></li>
<li><a href='#forderForceBase'><p>Force using base order for rxode2 radix sorting</p></a></li>
<li><a href='#gammap'><p>Gammap: normalized lower incomplete gamma function</p></a></li>
<li><a href='#gammapDer'><p>gammapDer:  derivative of gammap</p></a></li>
<li><a href='#gammapInv'><p>gammapInv and gammapInva:  Inverses of normalized gammap function</p></a></li>
<li><a href='#gammaq'><p>Gammaq: normalized upper incomplete gamma function</p></a></li>
<li><a href='#gammaqInv'><p>gammaqInv and gammaqInva:  Inverses of normalized gammaq function</p></a></li>
<li><a href='#GELU'><p>GELU activation function</p></a></li>
<li><a href='#genShinyApp.template'><p>Generate an example (template) of a dosing regimen shiny app</p></a></li>
<li><a href='#getBaseIniSimModel'><p>Get the base simulation model for simulation with inis in the</p>
underlying rxode2 model</a></li>
<li><a href='#getBaseSimModel'><p>Get the base simulation model for simulation</p></a></li>
<li><a href='#getBaseSymengineModel'><p>Get the symengine for loading into symengine with <code>rxS()</code></p></a></li>
<li><a href='#getRxThreads'><p>Get/Set the number of threads that rxode2 uses</p></a></li>
<li><a href='#guide_none'><p>Empty Guide</p></a></li>
<li><a href='#ini.rxUi'><p>Ini block for rxode2/nlmixr models</p></a></li>
<li><a href='#ini+26lt+3B-'><p>Assign the ini block in the rxode2 related object</p></a></li>
<li><a href='#invWR1d'><p>One correlation sample from the Inverse Wishart distribution</p></a></li>
<li><a href='#is.rxEt'><p>Check to see if this is an rxEt object.</p></a></li>
<li><a href='#is.rxSolve'><p>Check to see if this is an rxSolve object.</p></a></li>
<li><a href='#is.rxStackData'><p>Return if the object can be stacked</p></a></li>
<li><a href='#linMod'><p>Linear model to replace in rxode2 ui model</p></a></li>
<li><a href='#llikBeta'><p>Calculate the log likelihood of the binomial function (and its derivatives)</p></a></li>
<li><a href='#llikBinom'><p>Calculate the log likelihood of the binomial function (and its derivatives)</p></a></li>
<li><a href='#llikCauchy'><p>log likelihood of Cauchy distribution and it's derivatives (from stan)</p></a></li>
<li><a href='#llikChisq'><p>log likelihood and derivatives for chi-squared distribution</p></a></li>
<li><a href='#llikExp'><p>log likelihood and derivatives for exponential distribution</p></a></li>
<li><a href='#llikF'><p>log likelihood and derivatives for F distribution</p></a></li>
<li><a href='#llikGamma'><p>log likelihood and derivatives for Gamma distribution</p></a></li>
<li><a href='#llikGeom'><p>log likelihood and derivatives for Geom distribution</p></a></li>
<li><a href='#llikNbinom'><p>Calculate the log likelihood of the negative binomial function (and its derivatives)</p></a></li>
<li><a href='#llikNbinomMu'><p>Calculate the log likelihood of the negative binomial function (and its derivatives)</p></a></li>
<li><a href='#llikNorm'><p>Log likelihood for normal distribution</p></a></li>
<li><a href='#llikPois'><p>log-likelihood for the Poisson distribution</p></a></li>
<li><a href='#llikT'><p>Log likelihood of T and it's derivatives (from stan)</p></a></li>
<li><a href='#llikUnif'><p>log likelihood and derivatives for Unif distribution</p></a></li>
<li><a href='#llikWeibull'><p>log likelihood and derivatives for Weibull distribution</p></a></li>
<li><a href='#logit'><p>logit and inverse logit (expit) functions</p></a></li>
<li><a href='#lowergamma'><p>lowergamma:  upper incomplete gamma function</p></a></li>
<li><a href='#lReLU'><p>Leaky ReLU activation function</p></a></li>
<li><a href='#meanProbs'><p>Calculate expected confidence bands or prediction intreval with normal or t sampling distribution</p></a></li>
<li><a href='#model.function'><p>Model block for rxode2/nlmixr models</p></a></li>
<li><a href='#model+26lt+3B-'><p>Assign the model block in the rxode2 related object</p></a></li>
<li><a href='#modelExtract'><p>Extract model lines from a rxui model</p></a></li>
<li><a href='#odeMethodToInt'><p>Conversion between character and integer ODE integration methods for rxode2</p></a></li>
<li><a href='#phi'><p>Cumulative distribution of standard normal</p></a></li>
<li><a href='#plot.rxSolve'><p>Plot rxode2 objects</p></a></li>
<li><a href='#PReLU'><p>Parametric ReLU Activation Function</p></a></li>
<li><a href='#print.rxCoef'><p>Print the rxCoef object</p></a></li>
<li><a href='#print.rxDll'><p>Print rxDll object</p></a></li>
<li><a href='#print.rxModelVars'><p>Print Values</p></a></li>
<li><a href='#print.rxode2'><p>Print information about the rxode2 object.</p></a></li>
<li><a href='#probit'><p>probit and inverse probit functions</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#ReLU'><p>Rectified Linear Unit (ReLU) Activation Function</p></a></li>
<li><a href='#rinvchisq'><p>Scaled Inverse Chi Squared distribution</p></a></li>
<li><a href='#rLKJ1'><p>One correlation sample from the LKJ distribution</p></a></li>
<li><a href='#rxAllowUnload'><p>Allow unloading of dlls</p></a></li>
<li><a href='#rxAppendModel'><p>Append two rxui models together</p></a></li>
<li><a href='#rxAssignControlValue'><p>Assign Control Variable</p></a></li>
<li><a href='#rxAssignPtr'><p>Assign pointer based on model variables</p></a></li>
<li><a href='#rxbeta'><p>Simulate beta variable from threefry generator</p></a></li>
<li><a href='#rxbinom'><p>Simulate Binomial variable from threefry generator</p></a></li>
<li><a href='#rxBlockZeros'><p>Creates a logical matrix for block matrixes.</p></a></li>
<li><a href='#rxC'><p>Return the C file associated with the rxode2 object</p></a></li>
<li><a href='#rxCat'><p>Use cat when rxode2.verbose is TRUE</p></a></li>
<li><a href='#rxcauchy'><p>Simulate Cauchy variable from threefry generator</p></a></li>
<li><a href='#rxCbindStudyIndividual'><p>Bind the study parameters and individual parameters</p></a></li>
<li><a href='#rxChain'><p>rxChain  Chain or add item to solved system of equations</p></a></li>
<li><a href='#rxChain2'><p>Second command in chaining commands</p></a></li>
<li><a href='#rxchisq'><p>Simulate chi-squared variable from threefry generator</p></a></li>
<li><a href='#rxClean'><p>Cleanup anonymous DLLs by unloading them</p></a></li>
<li><a href='#rxCombineErrorLines'><p>Combine Error Lines and create rxode2 expression</p></a></li>
<li><a href='#rxCompile'><p>Compile a model if needed</p></a></li>
<li><a href='#rxCondition'><p>Current Condition for rxode2 object</p></a></li>
<li><a href='#rxControlUpdateSens'><p>This updates the tolerances based on the sensitivity equations</p></a></li>
<li><a href='#rxCreateCache'><p>This will create the cache directory for rxode2 to save between sessions</p></a></li>
<li><a href='#rxD'><p>Add to rxode2's derivative tables</p></a></li>
<li><a href='#rxDelete'><p>Delete the DLL for the model</p></a></li>
<li><a href='#rxDemoteAddErr'><p>Demote the error type</p></a></li>
<li><a href='#rxDerived'><p>Calculate derived parameters for the 1-, 2-, and 3- compartment</p>
linear models.</a></li>
<li><a href='#rxDfdy'><p>Jacobian and parameter derivatives</p></a></li>
<li><a href='#rxDll'><p>Return the DLL associated with the rxode2 object</p></a></li>
<li><a href='#rxDynLoad'><p>Load rxode2 object</p></a></li>
<li><a href='#rxDynUnload'><p>Unload rxode2 object</p></a></li>
<li><a href='#rxErrTypeCombine'><p>Combine transformations and error structures</p></a></li>
<li><a href='#rxEtDispatchSolve'><p>Dispatch solve to 'rxode2' solve</p></a></li>
<li><a href='#rxEvid'><p>EVID formatting for tibble and other places.</p></a></li>
<li><a href='#rxexp'><p>Simulate exponential variable from threefry generator</p></a></li>
<li><a href='#rxExpandFEta_'><p>Expand d(f)/d(eta)</p></a></li>
<li><a href='#rxExpandGrid'><p>Faster expand.grid</p></a></li>
<li><a href='#rxExpandGrid_'><p>Expand grid internal function</p></a></li>
<li><a href='#rxExpandIfElse'><p>Expand if/else clauses into multiple different types of lines.</p></a></li>
<li><a href='#rxExpandSens_'><p>Expand sensitivity</p></a></li>
<li><a href='#rxExpandSens2_'><p>Expand second order sensitivity</p></a></li>
<li><a href='#rxf'><p>Simulate F variable from threefry generator</p></a></li>
<li><a href='#rxFixPop'><p>Apply the fixed population estimated parameters</p></a></li>
<li><a href='#rxForget'><p>Clear memoise cache for rxode2</p></a></li>
<li><a href='#rxFun'><p>Add/Create C functions for use in rxode2</p></a></li>
<li><a href='#rxFunParse'><p>Add user function to rxode2</p></a></li>
<li><a href='#rxgamma'><p>Simulate gamma variable from threefry generator</p></a></li>
<li><a href='#rxgeom'><p>Simulate geometric variable from threefry generator</p></a></li>
<li><a href='#rxGetControl'><p>rxGetControl option from ui</p></a></li>
<li><a href='#rxGetDistributionSimulationLines'><p>This is a S3 method for getting the distribution lines for a rxode2 simulation</p></a></li>
<li><a href='#rxGetLin'><p>Get the linear compartment model true function</p></a></li>
<li><a href='#rxGetModel'><p>Get model properties without compiling it.</p></a></li>
<li><a href='#rxGetrxode2'><p>Get rxode2 model from object</p></a></li>
<li><a href='#rxGetSeed'><p>Get the rxode2 seed</p></a></li>
<li><a href='#rxHtml'><p>Format rxSolve and related objects as html.</p></a></li>
<li><a href='#rxIndLinState'><p>Set the preferred factoring by state</p></a></li>
<li><a href='#rxIndLinStrategy'><p>This sets the inductive linearization strategy for matrix building</p></a></li>
<li><a href='#rxInits'><p>Initial Values and State values for a rxode2 object</p></a></li>
<li><a href='#rxIntToBase'><p>Convert a positive  base</p></a></li>
<li><a href='#rxIntToLetter'><p>Convert a positive integer to a letter series</p></a></li>
<li><a href='#rxInv'><p>Invert matrix using RcppArmadillo.</p></a></li>
<li><a href='#rxIs'><p>Check the type of an object using Rcpp</p></a></li>
<li><a href='#rxIsCurrent'><p>Checks if the rxode2 object was built with the current build</p></a></li>
<li><a href='#rxIsLoaded'><p>Determine if the DLL associated with the rxode2 object is loaded</p></a></li>
<li><a href='#rxLhs'><p>Left handed Variables</p></a></li>
<li><a href='#rxLock'><p>Lock/unlocking of rxode2 dll file</p></a></li>
<li><a href='#rxMd5'><p>Return the md5 of an rxode2 object or file</p></a></li>
<li><a href='#rxModels_'><p>Get the rxModels  information</p></a></li>
<li><a href='#rxModelVars'><p>All model variables for a rxode2 object</p></a></li>
<li><a href='#rxnbinom'><p>Simulate Binomial variable from threefry generator</p></a></li>
<li><a href='#rxNorm'><p>Get the normalized model</p></a></li>
<li><a href='#rxnormV'><p>Simulate random normal variable from threefry generator</p></a></li>
<li><a href='#rxode2'><p>Create an ODE-based model specification</p></a></li>
<li><a href='#rxode2+26lt+3B-'><p>Set the function body of an rxUi object while retaining other object</p>
information (like data)</a></li>
<li><a href='#rxode2parse'><p>Internal translation to get model variables list</p></a></li>
<li><a href='#rxode2parseAssignPointerTranslation'><p>This sets function gets the currently assigned function pointer assignments</p></a></li>
<li><a href='#rxode2parseAssignTranslation'><p>This assigns the c level linkages for a roxde2 model</p></a></li>
<li><a href='#rxode2parseD'><p>This gives the derivative table for rxode2</p></a></li>
<li><a href='#rxode2parseGetPackagesToLoad'><p>Control the packages that are loaded when a <code>rxode2</code> model dll is loaded</p></a></li>
<li><a href='#rxode2parseGetPointerAssignment'><p>This function gets the currently assigned function pointer assignments</p></a></li>
<li><a href='#rxode2parseGetTranslation'><p>This function gets the currently assigned translations</p></a></li>
<li><a href='#rxOptExpr'><p>Optimize rxode2 for computer evaluation</p></a></li>
<li><a href='#rxord'><p>Simulate ordinal value</p></a></li>
<li><a href='#rxParams'><p>Parameters specified by the model</p></a></li>
<li><a href='#rxParseErr'><p>Prepare Error function for inclusion in rxode2</p></a></li>
<li><a href='#rxParsePk'><p>Parse PK function for inclusion in rxode2</p></a></li>
<li><a href='#rxParsePred'><p>Prepare Pred function for inclusion in rxode2</p></a></li>
<li><a href='#rxParseSetSilentErr'><p>Silence some of rxode2's C/C++ messages</p></a></li>
<li><a href='#rxParseSuppressMsg'><p>Respect suppress messages</p></a></li>
<li><a href='#rxPkg'><p>Creates a package from compiled rxode2 models</p></a></li>
<li><a href='#rxpois'><p>Simulate random Poisson variable from threefry generator</p></a></li>
<li><a href='#rxPp'><p>Simulate a from a Poisson process</p></a></li>
<li><a href='#rxPreferredDistributionName'><p>Change distribution name to the preferred distribution name term</p></a></li>
<li><a href='#rxProgress'><p>rxode2 progress bar functions</p></a></li>
<li><a href='#rxPrune'><p>Prune branches (ie if/else) from rxode2</p></a></li>
<li><a href='#rxRateDur'><p>Creates a rxRateDur object</p></a></li>
<li><a href='#rxReload'><p>Reload rxode2 DLL</p></a></li>
<li><a href='#rxRemoveControl'><p>rxRemoveControl options for UI object</p></a></li>
<li><a href='#rxRename'><p>Rename items inside of a <code>rxode2</code> ui model</p></a></li>
<li><a href='#rxRepR0_'><p>Rep R0 for foce</p></a></li>
<li><a href='#rxReq'><p>Require namespace, otherwise throw error.</p></a></li>
<li><a href='#rxReservedKeywords'><p>A list and description of rxode2 supported reserved keywords</p></a></li>
<li><a href='#rxResidualError'><p>A description of Rode2 supported residual errors</p></a></li>
<li><a href='#rxRmvn'><p>Simulate from a (truncated) multivariate normal</p></a></li>
<li><a href='#rxS'><p>Load a model into a symengine environment</p></a></li>
<li><a href='#rxSeedEng'><p>This seeds the engine based on the number of cores used in random number generation</p></a></li>
<li><a href='#rxSetControl'><p>rxSetControl options for UI object</p></a></li>
<li><a href='#rxSetCovariateNamesForPiping'><p>Assign covariates for piping</p></a></li>
<li><a href='#rxSetIni0'><p>Set Initial conditions to time zero instead of the first observed/dosed time</p></a></li>
<li><a href='#rxSetPipingAuto'><p>Set the variables for the model piping automatic covarite selection</p></a></li>
<li><a href='#rxSetProd'><p>Defunct setting of product</p></a></li>
<li><a href='#rxSetProgressBar'><p>Set timing for progress bar</p></a></li>
<li><a href='#rxSetSeed'><p>Set the parallel seed for rxode2 random number generation</p></a></li>
<li><a href='#rxSetSilentErr'><p>Silence some of rxode2's C/C++ messages</p></a></li>
<li><a href='#rxSetSum'><p>Defunct setting of sum</p></a></li>
<li><a href='#rxSetupIni'><p>Setup the initial conditions.</p></a></li>
<li><a href='#rxSetupScale'><p>Setup the initial conditions.</p></a></li>
<li><a href='#rxShiny'><p>Use Shiny to help develop an rxode2 model</p></a></li>
<li><a href='#rxSimThetaOmega'><p>Simulate Parameters from a Theta/Omega specification</p></a></li>
<li><a href='#rxSolve'><p>Options, Solving &amp; Simulation of an ODE/solved system</p></a></li>
<li><a href='#rxSolveFree'><p>Free the C solving/parsing information.</p></a></li>
<li><a href='#rxSolveSetup'><p>See if the memory is installed for a solve</p></a></li>
<li><a href='#rxSplitPlusQ'><p>This function splits a function based on + or - terms</p></a></li>
<li><a href='#rxStack'><p>Stack a solved object for things like default ggplot2 plot</p></a></li>
<li><a href='#rxState'><p>State variables</p></a></li>
<li><a href='#rxSumProdModel'><p>Recast model in terms of sum/prod</p></a></li>
<li><a href='#rxSupportedFuns'><p>Get list of supported functions</p></a></li>
<li><a href='#rxSuppressMsg'><p>Respect suppress messages</p></a></li>
<li><a href='#rxSymInvChol'><p>Get Omega^-1 and derivatives</p></a></li>
<li><a href='#rxSymInvCholCreate'><p>Creates an object for calculating Omega/Omega^-1 and derivatives</p></a></li>
<li><a href='#rxSymInvCholN'><p>Return the dimension of the built-in derivatives/inverses</p></a></li>
<li><a href='#rxSyncOptions'><p>Sync options with rxode2 variables</p></a></li>
<li><a href='#rxSyntaxFunctions'><p>A list and description of Rode supported syntax functions</p></a></li>
<li><a href='#rxt'><p>Simulate student t variable from threefry generator</p></a></li>
<li><a href='#rxTempDir'><p>Get the rxode2 temporary directory</p></a></li>
<li><a href='#rxTheme'><p>rxTheme is the ggplot2 theme for rxode2 plots</p></a></li>
<li><a href='#rxToSE'><p>rxode2 to symengine environment</p></a></li>
<li><a href='#rxTrans'><p>Translate the model to C code if needed</p></a></li>
<li><a href='#rxUdfUi'><p>This function is called when processing rxode2 user functions from</p>
the models</a></li>
<li><a href='#rxUdfUiControl'><p>Return the control that is being processed or setup control for processing</p></a></li>
<li><a href='#rxUdfUiData'><p>Return the data.frame that is being processed or setup data.frame for processing</p></a></li>
<li><a href='#rxUdfUiEst'><p>Return the current estimation method for the UI processing</p></a></li>
<li><a href='#rxUdfUiIniDf'><p>Get the rxode2 iniDf of the current UI being processed (or return NULL)</p></a></li>
<li><a href='#rxUdfUiIniLhs'><p>Return the lhs parsed language expression</p></a></li>
<li><a href='#rxUdfUiMv'><p>Return the model variables that is being processed or setup model</p>
variables for processing</a></li>
<li><a href='#rxUdfUiNum'><p>This gives the current number in the ui of the particular function being called.</p></a></li>
<li><a href='#rxUdfUiParsing'><p>Returns if the current ui function is being parsed</p></a></li>
<li><a href='#rxUdfUiReset'><p>Reset the rxode2 ui environment variables</p></a></li>
<li><a href='#rxUiDecompress'><p>Compress/Decompress <code>rxode2</code> ui</p></a></li>
<li><a href='#rxUiDeparse'><p>This is a generic function for deparsing certain objects when</p>
printing out a rxode2 object.  Currently it is used for any meta-information</a></li>
<li><a href='#rxUiGet.cmtLines'><p>S3 for getting information from UI model</p></a></li>
<li><a href='#rxunif'><p>Simulate uniform variable from threefry generator</p></a></li>
<li><a href='#rxUnloadAll'><p>Unloads all rxode2 compiled DLLs</p></a></li>
<li><a href='#rxUse'><p>Use model object in your package</p></a></li>
<li><a href='#rxValidate'><p>Validate rxode2</p>
This allows easy validation/qualification of nlmixr by running the
testing suite on your system.</a></li>
<li><a href='#rxVersion'><p>Version and repository for this dparser package.</p></a></li>
<li><a href='#rxweibull'><p>Simulate Weibull variable from threefry generator</p></a></li>
<li><a href='#rxWithSeed'><p>Preserved seed and possibly set the seed</p></a></li>
<li><a href='#SELU'><p>Scaled Exponential Linear Unit (SELU) Activation Function</p></a></li>
<li><a href='#softplus'><p>Softplus Activation Function</p></a></li>
<li><a href='#stat_amt'><p>Dosing/Amt geom/stat</p></a></li>
<li><a href='#stat_cens'><p>Censoring geom/stat</p></a></li>
<li><a href='#summary.rxDll'><p>Summary of rxDll object</p></a></li>
<li><a href='#summary.rxode2'><p>Print expanded information about the rxode2 object.</p></a></li>
<li><a href='#swapMatListWithCube'><p>Swaps the matrix list with a cube</p></a></li>
<li><a href='#Swish'><p>Switch Activation Function</p></a></li>
<li><a href='#testIniDf'><p>This function tests if this object is a iniDf as needed by the UI</p></a></li>
<li><a href='#testRxLinCmt'><p>Test if rxode2 uses linear solved systems</p></a></li>
<li><a href='#testRxUnbounded'><p>Test if the rxode2 model has any parameters with user defined boundaries</p></a></li>
<li><a href='#toTrialDuration'><p>Convert event data to trial duration data</p>
A helper function to create a custom event table.
The observation time will start from the first event time (baseline) and end at trial duration.
The interval is the spacing between each observation.</a></li>
<li><a href='#update.rxUi'><p>Update for rxUi</p></a></li>
<li><a href='#uppergamma'><p>uppergamma:  upper incomplete gamma function</p></a></li>
<li><a href='#zeroRe'><p>Set random effects and residual error to zero</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>3.0.4</td>
</tr>
<tr>
<td>Title:</td>
<td>Facilities for Simulating from ODE-Based Models</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthew L. Fidler &lt;matthew.fidler@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>Matrix, DT, covr, crayon, curl, digest, dplyr (&ge; 0.8.0),
ggrepel, gridExtra, htmltools, knitr, learnr, microbenchmark,
nlme, remotes, rlang, rmarkdown, scales, shiny, stringi,
symengine, testthat, tidyr, usethis, vdiffr (&ge; 1.0), withr,
xgxr, pillar, tibble, units (&ge; 0.6-0), rsconnect, devtools,
patchwork, nlmixr2data, lifecycle, kableExtra</td>
</tr>
<tr>
<td>Imports:</td>
<td>PreciseSums (&ge; 0.7), Rcpp (&ge; 0.12.3), backports, cli (&ge;
2.0.0), checkmate, ggplot2 (&ge; 3.4.0), inline, lotri (&ge;
1.0.0), magrittr, memoise, methods, rex, sys, tools, utils,
dparser (&ge; 1.3.1-12), rxode2ll(&ge; 2.0.9), data.table (&ge;
1.12.4), qs (&ge; 0.26.3)</td>
</tr>
<tr>
<td>Description:</td>
<td>Facilities for running simulations from ordinary
    differential equation ('ODE') models, such as pharmacometrics and other
    compartmental models.  A compilation manager translates the ODE model
    into C, compiles it, and dynamically loads the object code into R for
    improved computational efficiency.  An event table object facilitates
    the specification of complex dosing regimens (optional) and sampling
    schedules.  NB: The use of this package requires both C and
    Fortran compilers, for details on their use with R please see
    Section 6.3, Appendix A, and Appendix D in the "R Administration and
    Installation" manual. Also the code is mostly released under GPL.  The
    'VODE' and 'LSODA' are in the public domain.  The information is available
    in the inst/COPYRIGHTS.</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/nlmixr2/rxode2/issues/">https://github.com/nlmixr2/rxode2/issues/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://nlmixr2.github.io/rxode2/">https://nlmixr2.github.io/rxode2/</a>,
<a href="https://github.com/nlmixr2/rxode2/">https://github.com/nlmixr2/rxode2/</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Biarch:</td>
<td>true</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>sitmo, lotri (&ge; 1.0.0), PreciseSums (&ge; 0.7), Rcpp,
RcppArmadillo (&ge; 0.9.300.2.0), BH, RcppParallel, RcppEigen (&ge;
0.3.3.9.2), StanHeaders (&ge; 2.21.0.7), dparser (&ge; 1.3.1-12)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-02-14 15:17:47 UTC; matt</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthew L. Fidler <a href="https://orcid.org/0000-0001-8538-6691"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Wenping Wang [aut],
  Alan Hindmarsh [ctb],
  Arun Srinivasan [ctb],
  Awad H. Al-Mohy [ctb],
  Bill Denney <a href="https://orcid.org/0000-0002-5759-428X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb],
  Cleve Moler [ctb],
  David Cooley [ctb],
  Drew Schmidt [ctb],
  Ernst Hairer [ctb],
  Gabriel Staples [ctb],
  Gerhard Wanner [ctb],
  Gilbert Stewart [ctb],
  Goro Fuji [ctb],
  Hadley Wickham [ctb],
  Igor Kushnir [ctb],
  Jack Dongarra [ctb],
  Jim Bunch [ctb],
  Kevin Ushey [ctb],
  Linda Petzold [ctb],
  Martin Maechler [ctb],
  Matt Dowle [ctb],
  Matteo Fasiolo [ctb],
  Melissa Hallow [aut],
  Michel Lang [ctb],
  Morwenn [ctb],
  Nicholas J. Higham [ctb],
  Omar Elashkar [ctb],
  Richard Upton [ctb],
  Roger B. Sidje [ctb],
  Simon Frost [ctb],
  Yu Feng [ctb],
  Zufar Mulyukov [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-02-14 16:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.assertRenameErrorModelLine'>This function asserts the requested rename makes sense</h2><span id='topic+.assertRenameErrorModelLine'></span>

<h3>Description</h3>

<p>It returns the new expression, old expression, new variable and old
variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.assertRenameErrorModelLine(line, vars)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".assertRenameErrorModelLine_+3A_line">line</code></td>
<td>
<p>quoted call information line</p>
</td></tr>
<tr><td><code id=".assertRenameErrorModelLine_+3A_vars">vars</code></td>
<td>
<p>Variables contained within the mdel</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list(new, old, newChar, oldChar)
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.cbindOme'>cbind Ome</h2><span id='topic+.cbindOme'></span>

<h3>Description</h3>

<p>cbind Ome
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.cbindOme(et, mat, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".cbindOme_+3A_et">et</code></td>
<td>
<p>The theta data frame</p>
</td></tr>
<tr><td><code id=".cbindOme_+3A_mat">mat</code></td>
<td>
<p>The full matrix simulation from omegas</p>
</td></tr>
<tr><td><code id=".cbindOme_+3A_n">n</code></td>
<td>
<p>number of subject simulated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame with et combined with simulated omega matrix values
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='.clearPipe'>Clear/Set pipeline</h2><span id='topic+.clearPipe'></span>

<h3>Description</h3>

<p>Clear/Set pipeline
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.clearPipe(
  rx = NULL,
  inits = NULL,
  events = NULL,
  params = NULL,
  iCov = NULL,
  keep = NULL,
  thetaMat = NULL,
  omega = NULL,
  sigma = NULL,
  dfObs = NULL,
  dfSub = NULL,
  nSub = NULL,
  nStud = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".clearPipe_+3A_rx">rx</code></td>
<td>
<p>rxode2 object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None, clears rxode2 pipeline
</p>

<hr>
<h2 id='.collectWarnings'>Collect warnings and just warn once.</h2><span id='topic+.collectWarnings'></span>

<h3>Description</h3>

<p>Collect warnings and just warn once.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.collectWarnings(expr, lst = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".collectWarnings_+3A_expr">expr</code></td>
<td>
<p>R expression</p>
</td></tr>
<tr><td><code id=".collectWarnings_+3A_lst">lst</code></td>
<td>
<p>When <code>TRUE</code> return a list with
list(object,warnings) instead of issuing the warnings.
Otherwise, when <code>FALSE</code> issue the warnings and return the
object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value of the expression or a list with the value of
the expression and a list of warning messages
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.convertId'>Convert a factor/char to an id</h2><span id='topic+.convertId'></span>

<h3>Description</h3>

<p>Convert a factor/char to an id
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.convertId(a)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".convertId_+3A_a">a</code></td>
<td>
<p>value to convert to an id</p>
</td></tr>
</table>


<h3>Value</h3>

<p>id factor
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.convertId("a")
</code></pre>

<hr>
<h2 id='.copyUi'>This copies the rxode2 UI object so it can be modified</h2><span id='topic+.copyUi'></span>

<h3>Description</h3>

<p>This copies the rxode2 UI object so it can be modified
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.copyUi(ui)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".copyUi_+3A_ui">ui</code></td>
<td>
<p>Original UI object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Copied UI object
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.expandPars'>Expand parameters</h2><span id='topic+.expandPars'></span>

<h3>Description</h3>

<p>Expand parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.expandPars(object, params, events, control)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".expandPars_+3A_object">object</code></td>
<td>
<p>rxode2 model variables object</p>
</td></tr>
<tr><td><code id=".expandPars_+3A_params">params</code></td>
<td>
<p>parameters to expand</p>
</td></tr>
<tr><td><code id=".expandPars_+3A_events">events</code></td>
<td>
<p>event table to help with the expansion</p>
</td></tr>
<tr><td><code id=".expandPars_+3A_control">control</code></td>
<td>
<p>control structure to help with the parameter generation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Expanded parameters for simulation
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.extraC'>Generate extraC information for rxode2 models</h2><span id='topic+.extraC'></span>

<h3>Description</h3>

<p>Generate extraC information for rxode2 models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.extraC(extraC = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".extraC_+3A_extrac">extraC</code></td>
<td>
<p>Additional extraC from rxode2 compile optioioins</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, called for side effects
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.extraCnow'>Get the extraCnow for compiling</h2><span id='topic+.extraCnow'></span>

<h3>Description</h3>

<p>Get the extraCnow for compiling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.extraCnow()
</code></pre>


<h3>Value</h3>

<p>string of extraC information
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.getLastIdLvl'>Get the last <code>idLvl</code></h2><span id='topic+.getLastIdLvl'></span>

<h3>Description</h3>

<p>Get the last <code>idLvl</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.getLastIdLvl()
</code></pre>


<h3>Value</h3>

<p>Last <code>idLvl</code>
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.getLastIdLvl()
</code></pre>

<hr>
<h2 id='.getWh'>Get the internal breakdown of an evid</h2><span id='topic+.getWh'></span>

<h3>Description</h3>

<p>Get the internal breakdown of an evid
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.getWh(i)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".getWh_+3A_i">i</code></td>
<td>
<p>evid to breakdown</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named evid integer vector
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
.getWh(1001)
.getWh(10401)

</code></pre>

<hr>
<h2 id='.handleSingleErrTypeNormOrTFoceiBase'>Handle the single error for normal or t distributions</h2><span id='topic+.handleSingleErrTypeNormOrTFoceiBase'></span>

<h3>Description</h3>

<p>Handle the single error for normal or t distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.handleSingleErrTypeNormOrTFoceiBase(
  env,
  pred1,
  errNum = 1L,
  rxPredLlik = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".handleSingleErrTypeNormOrTFoceiBase_+3A_env">env</code></td>
<td>
<p>Environment for the parsed model</p>
</td></tr>
<tr><td><code id=".handleSingleErrTypeNormOrTFoceiBase_+3A_pred1">pred1</code></td>
<td>
<p>The <code>data.frame</code> of the current error</p>
</td></tr>
<tr><td><code id=".handleSingleErrTypeNormOrTFoceiBase_+3A_errnum">errNum</code></td>
<td>
<p>The number of the error specification in the nlmixr2 model</p>
</td></tr>
<tr><td><code id=".handleSingleErrTypeNormOrTFoceiBase_+3A_rxpredllik">rxPredLlik</code></td>
<td>
<p>A boolean indicating if the log likelihood should
be calculated for non-normal distributions.  By default <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the lines added.  The lines will contain
</p>

<ul>
<li> <p><code>rx_yj_</code> which is an integer that corresponds to the
transformation type.
</p>
</li>
<li> <p><code>rx_lambda_</code> is the transformation lambda
</p>
</li>
<li> <p><code>rx_low_</code> The lower boundary of the transformation
</p>
</li>
<li> <p><code>rx_hi_</code> The upper boundary of the transformation
</p>
</li>
<li> <p><code>rx_pred_f_</code> The prediction function
</p>
</li>
<li> <p><code>rx_pred_</code> The transformed prediction function
</p>
</li>
<li> <p><code>rx_r_</code> The transformed variance
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='.iniGetAppendArg'>This gets the append arg for the ini() piping</h2><span id='topic+.iniGetAppendArg'></span>

<h3>Description</h3>

<p>This gets the append arg for the ini() piping
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.iniGetAppendArg(f, s)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".iniGetAppendArg_+3A_f">f</code></td>
<td>
<p>this is the <code>try(force(append))</code> argument,</p>
</td></tr>
<tr><td><code id=".iniGetAppendArg_+3A_s">s</code></td>
<td>
<p>this is the <code>as.character(substitute(append))</code> argument</p>
</td></tr>
</table>


<h3>Value</h3>

<p>corrected ini piping argument
</p>
<p>This is exported for creating new ini methods that have the same
requirements for piping
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.iniHandleAppend'>Reorder rows in iniDf</h2><span id='topic+.iniHandleAppend'></span>

<h3>Description</h3>

<p>Reorder rows in iniDf
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.iniHandleAppend(expr, rxui, envir, append)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".iniHandleAppend_+3A_expr">expr</code></td>
<td>
<p>Expression for parsing</p>
</td></tr>
<tr><td><code id=".iniHandleAppend_+3A_rxui">rxui</code></td>
<td>
<p>User interface function</p>
</td></tr>
<tr><td><code id=".iniHandleAppend_+3A_envir">envir</code></td>
<td>
<p>Environment for parsing</p>
</td></tr>
<tr><td><code id=".iniHandleAppend_+3A_append">append</code></td>
<td>
<p>Reorder theta parameters.  <code>NULL</code> means no change to
parameter order.  A parameter name (as a character string) means to put the
new parameter after the named parameter.  A number less than or equal to
zero means to put the parameter at the beginning of the list.  A number
greater than the last parameter number means to put the parameter at the
end of the list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, called for side effects
</p>

<hr>
<h2 id='.iniHandleLine'>Update the iniDf of a model</h2><span id='topic+.iniHandleLine'></span><span id='topic+.iniHandleFixOrUnfix'></span>

<h3>Description</h3>

<p>Update the iniDf of a model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.iniHandleLine(expr, rxui, envir = parent.frame(), append = NULL)

.iniHandleFixOrUnfix(expr, rxui, envir = parent.frame(), append = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".iniHandleLine_+3A_expr">expr</code></td>
<td>
<p>Expression for parsing</p>
</td></tr>
<tr><td><code id=".iniHandleLine_+3A_rxui">rxui</code></td>
<td>
<p>User interface function</p>
</td></tr>
<tr><td><code id=".iniHandleLine_+3A_envir">envir</code></td>
<td>
<p>Environment for parsing</p>
</td></tr>
<tr><td><code id=".iniHandleLine_+3A_append">append</code></td>
<td>
<p>Reorder theta parameters.  <code>NULL</code> means no change to
parameter order.  A parameter name (as a character string) means to put the
new parameter after the named parameter.  A number less than or equal to
zero means to put the parameter at the beginning of the list.  A number
greater than the last parameter number means to put the parameter at the
end of the list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, called for side effects
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.linCmtSensB'>Is the linear systems with gradients built-in</h2><span id='topic+.linCmtSensB'></span>

<h3>Description</h3>

<p>Is the linear systems with gradients built-in
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.linCmtSensB()
</code></pre>


<h3>Value</h3>

<p>logical (TRUE) if the solved systems with gradients are
built-in. (FALSE) if the solves systems with gradients are absent
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.linCmtSensB()
</code></pre>

<hr>
<h2 id='.matchesLangTemplate'>Check if a language object matches a template language object</h2><span id='topic+.matchesLangTemplate'></span>

<h3>Description</h3>


<ul>
<li><p>If <code>template == str2lang(".")</code>, it will match anything.
</p>
</li>
<li><p>If <code>template == str2lang(".name")</code>, it will match any name.
</p>
</li>
<li><p>If <code>template == str2lang(".call()")</code>, it will match any call.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>.matchesLangTemplate(x, template)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".matchesLangTemplate_+3A_x">x</code></td>
<td>
<p>The object to check</p>
</td></tr>
<tr><td><code id=".matchesLangTemplate_+3A_template">template</code></td>
<td>
<p>The template object it should match</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if it matches, FALSE, otherwise
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.matchesLangTemplate(str2lang("d/dt(foo)"), str2lang("d/dt(.name)"))
.matchesLangTemplate(str2lang("d/dt(foo)"), str2lang("d/foo(.name)"))
.matchesLangTemplate(str2lang("d/dt(foo)"), str2lang("d/."))
</code></pre>

<hr>
<h2 id='.minfo'>Internal messaging statements</h2><span id='topic+.minfo'></span><span id='topic+.malert'></span><span id='topic+.mwarn'></span><span id='topic+.msuccess'></span>

<h3>Description</h3>

<p>Internal messaging statements
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.minfo(text, ..., .envir = parent.frame())

.malert(text, ..., .envir = parent.frame())

.mwarn(text, ..., .envir = parent.frame())

.msuccess(text, ..., .envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".minfo_+3A_text">text</code></td>
<td>
<p>Text</p>
</td></tr>
<tr><td><code id=".minfo_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
<tr><td><code id=".minfo_+3A_.envir">.envir</code></td>
<td>
<p>Environment to evaluate in</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, called for side effects
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.modelHandleModelLines'>Handle model lines</h2><span id='topic+.modelHandleModelLines'></span>

<h3>Description</h3>

<p>Handle model lines
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.modelHandleModelLines(
  modelLines,
  rxui,
  modifyIni = FALSE,
  append = NULL,
  auto = getOption("rxode2.autoVarPiping", TRUE),
  cov = NULL,
  envir
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".modelHandleModelLines_+3A_modellines">modelLines</code></td>
<td>
<p>The model lines that are being considered</p>
</td></tr>
<tr><td><code id=".modelHandleModelLines_+3A_rxui">rxui</code></td>
<td>
<p>The rxode2 UI object</p>
</td></tr>
<tr><td><code id=".modelHandleModelLines_+3A_modifyini">modifyIni</code></td>
<td>
<p>Should the ini() be considered</p>
</td></tr>
<tr><td><code id=".modelHandleModelLines_+3A_append">append</code></td>
<td>
<p>This is a boolean to determine if the lines are
appended in piping.  The possible values for this is:
</p>

<ul>
<li> <p><code>TRUE</code> which is when the lines are appended to the model instead of replaced
</p>
</li>
<li> <p><code>FALSE</code> when the lines are replaced in the model (default)
</p>
</li>
<li> <p><code>NA</code> is when the lines are pre-pended to the model instead of replaced
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;lhs expression&#8288;</code>, which will append the lines after the last observed line of the expression <code>lhs</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id=".modelHandleModelLines_+3A_auto">auto</code></td>
<td>
<p>This boolean tells if piping automatically selects the
parameters should be characterized as a population parameter,
between subject variability, or a covariate.  When <code>TRUE</code> this
automatic selection occurs.  When <code>FALSE</code> this automatic
selection is turned off and everything is added as a covariate
(which can be promoted to a parameter with the <code>ini</code> statement).
By default this is <code>TRUE</code>, but it can be changed by
<code>options(rxode2.autoVarPiping=FALSE)</code>.</p>
</td></tr>
<tr><td><code id=".modelHandleModelLines_+3A_cov">cov</code></td>
<td>
<p>is a character vector of variables that should be
assumed to be covariates.  This will override automatic promotion
to a population parameter estimate (or an eta)</p>
</td></tr>
<tr><td><code id=".modelHandleModelLines_+3A_envir">envir</code></td>
<td>
<p>Environment for evaluation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>New UI
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.pipeRx'>Assign in the rxode2 pipeline</h2><span id='topic+.pipeRx'></span><span id='topic+.pipeInits'></span><span id='topic+.pipeEvents'></span><span id='topic+.pipeParams'></span><span id='topic+.pipeKeep'></span><span id='topic+.pipeThetaMat'></span><span id='topic+.pipeOmega'></span><span id='topic+.pipeSigma'></span><span id='topic+.pipeDfObs'></span><span id='topic+.pipeDfSub'></span><span id='topic+.pipeNSub'></span><span id='topic+.pipeNStud'></span>

<h3>Description</h3>

<p>Assign in the rxode2 pipeline
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.pipeRx(obj)

.pipeInits(obj)

.pipeEvents(obj)

.pipeParams(obj)

.pipeKeep(obj)

.pipeThetaMat(obj)

.pipeOmega(obj)

.pipeSigma(obj)

.pipeDfObs(obj)

.pipeDfSub(obj)

.pipeNSub(obj)

.pipeNStud(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".pipeRx_+3A_obj">obj</code></td>
<td>
<p>Object to assign.  If NA return the value.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The pipeline object (invisibly)
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.quoteCallInfoLines'>Returns quoted call information</h2><span id='topic+.quoteCallInfoLines'></span>

<h3>Description</h3>

<p>Returns quoted call information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.quoteCallInfoLines(callInfo, envir = parent.frame(), iniDf = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".quoteCallInfoLines_+3A_callinfo">callInfo</code></td>
<td>
<p>Call information</p>
</td></tr>
<tr><td><code id=".quoteCallInfoLines_+3A_envir">envir</code></td>
<td>
<p>Environment for evaluation (if needed)</p>
</td></tr>
<tr><td><code id=".quoteCallInfoLines_+3A_inidf">iniDf</code></td>
<td>
<p>The parent model <code>iniDf</code> when piping in a <code>ini</code> block
(<code>NULL</code> otherwise)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Quote call information.  for <code>name=expression</code>, change to
<code>name&lt;-expression</code> in quoted call list. For expressions that are
within brackets ie <code>{}</code>, unlist the brackets as if they were
called in one single sequence.
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.rxBlankIni'>Get a blank, theta1, or eta1 initialization block for iniDf</h2><span id='topic+.rxBlankIni'></span>

<h3>Description</h3>

<p>Get a blank, theta1, or eta1 initialization block for iniDf
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rxBlankIni(type = c("empty", "theta", "eta"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".rxBlankIni_+3A_type">type</code></td>
<td>
<p>type of initialization block to return</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with the appropriate number/type of columns.
</p>
<p>For type=&quot;empty&quot;, the data.frame will have 0 rows but all the correct types.
</p>
<p>For type=&quot;theta&quot;, the data.frame will have 1 row with the correct
types and default values.  The &quot;name&quot; and &quot;est&quot; will likely need to
be updated.
</p>
<p>For type=&quot;eta&quot;, the data.frame will have 1 row with the correct
types and default values for the a single eta being added.  The
&quot;name&quot; and &quot;est&quot; will likely need to be updated.
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
.rxBlankIni("empty")

.rxBlankIni("theta")

.rxBlankIni("eta")

</code></pre>

<hr>
<h2 id='.rxC'>Return the C code of an internal function</h2><span id='topic+.rxC'></span>

<h3>Description</h3>

<p>Return the C code of an internal function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rxC(fun)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".rxC_+3A_fun">fun</code></td>
<td>
<p>is the string of a function that you wish to get the C
code for</p>
</td></tr>
</table>


<h3>Value</h3>

<p>C code if found (as a string) or NULL if not found
</p>


<h3>Author(s)</h3>

<p>Matthew Fider
</p>

<hr>
<h2 id='.rxDocTable'>Print out a table in the documentation</h2><span id='topic+.rxDocTable'></span>

<h3>Description</h3>

<p>Print out a table in the documentation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rxDocTable(table, caption = "none")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".rxDocTable_+3A_table">table</code></td>
<td>
<p>data frame</p>
</td></tr>
<tr><td><code id=".rxDocTable_+3A_caption">caption</code></td>
<td>
<p>a character vector representing the caption for the latex table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>based on the <code>knitr</code> context:
</p>

<ul>
<li><p> output a <code>kableExtra::kbl</code> for <code>latex</code> output
</p>
</li>
<li><p> output a <code>DT::datatable</code> for html output
</p>
</li>
<li><p> otherwise output a <code>knitr::kable</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.rxDocTable(rxReservedKeywords)
</code></pre>

<hr>
<h2 id='.rxGetHiBoundaryPred1AndIni'>Get the upper boundary condition when the transformation it</h2><span id='topic+.rxGetHiBoundaryPred1AndIni'></span>

<h3>Description</h3>

<p>Get the upper boundary condition when the transformation it
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rxGetHiBoundaryPred1AndIni(env, pred1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".rxGetHiBoundaryPred1AndIni_+3A_env">env</code></td>
<td>
<p>Environment for the parsed model</p>
</td></tr>
<tr><td><code id=".rxGetHiBoundaryPred1AndIni_+3A_pred1">pred1</code></td>
<td>
<p>The <code>data.frame</code> of the current error</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Upper Boundary
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='.rxGetLambdaFromPred1AndIni'>Get the lambda value based on the pred information</h2><span id='topic+.rxGetLambdaFromPred1AndIni'></span>

<h3>Description</h3>

<p>Get the lambda value based on the pred information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rxGetLambdaFromPred1AndIni(env, pred1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".rxGetLambdaFromPred1AndIni_+3A_env">env</code></td>
<td>
<p>Environment that has the environment</p>
</td></tr>
<tr><td><code id=".rxGetLambdaFromPred1AndIni_+3A_pred1">pred1</code></td>
<td>
<p>Single error data frame</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Lambda expression
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='.rxGetLowBoundaryPred1AndIni'>Get the lower boundary condition when the transformation requires it</h2><span id='topic+.rxGetLowBoundaryPred1AndIni'></span>

<h3>Description</h3>

<p>Get the lower boundary condition when the transformation requires it
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rxGetLowBoundaryPred1AndIni(env, pred1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".rxGetLowBoundaryPred1AndIni_+3A_env">env</code></td>
<td>
<p>Environment for the parsed model</p>
</td></tr>
<tr><td><code id=".rxGetLowBoundaryPred1AndIni_+3A_pred1">pred1</code></td>
<td>
<p>The <code>data.frame</code> of the current error</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Lower Boundary
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='.rxGetPredictionDVTransform'>Get the Observation transformation</h2><span id='topic+.rxGetPredictionDVTransform'></span>

<h3>Description</h3>

<p>Get the Observation transformation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rxGetPredictionDVTransform(env, pred1, yj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".rxGetPredictionDVTransform_+3A_env">env</code></td>
<td>
<p>Environment for the parsed model</p>
</td></tr>
<tr><td><code id=".rxGetPredictionDVTransform_+3A_pred1">pred1</code></td>
<td>
<p>The <code>data.frame</code> of the current error</p>
</td></tr>
<tr><td><code id=".rxGetPredictionDVTransform_+3A_yj">yj</code></td>
<td>
<p>The transformation number for the current error</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The transformation expression
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='.rxGetPredictionF'>Get the prediction name</h2><span id='topic+.rxGetPredictionF'></span>

<h3>Description</h3>

<p>Get the prediction name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rxGetPredictionF(env, pred1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".rxGetPredictionF_+3A_env">env</code></td>
<td>
<p>Environment for the parsed model</p>
</td></tr>
<tr><td><code id=".rxGetPredictionF_+3A_pred1">pred1</code></td>
<td>
<p>The <code>data.frame</code> of the current error</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The prediction symbol
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='.rxGetPredictionFTransform'>Get the prediction transformation</h2><span id='topic+.rxGetPredictionFTransform'></span>

<h3>Description</h3>

<p>Get the prediction transformation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rxGetPredictionFTransform(env, pred1, yj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".rxGetPredictionFTransform_+3A_env">env</code></td>
<td>
<p>Environment for the parsed model</p>
</td></tr>
<tr><td><code id=".rxGetPredictionFTransform_+3A_pred1">pred1</code></td>
<td>
<p>The <code>data.frame</code> of the current error</p>
</td></tr>
<tr><td><code id=".rxGetPredictionFTransform_+3A_yj">yj</code></td>
<td>
<p>The transformation number for the current error</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The transformation expression
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='.rxGetVarianceForErrorType'>Get Variance for error type</h2><span id='topic+.rxGetVarianceForErrorType'></span>

<h3>Description</h3>

<p>Get Variance for error type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rxGetVarianceForErrorType(env, pred1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".rxGetVarianceForErrorType_+3A_env">env</code></td>
<td>
<p>Environment</p>
</td></tr>
<tr><td><code id=".rxGetVarianceForErrorType_+3A_pred1">pred1</code></td>
<td>
<p>Pred for one end-point</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Variance error type
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.rxIsLinCmt'>Internal function to tell if the linCmt() is the model variables</h2><span id='topic+.rxIsLinCmt'></span>

<h3>Description</h3>

<p>Internal function to tell if the linCmt() is the model variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rxIsLinCmt()
</code></pre>


<h3>Value</h3>

<p>0 or 1
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.rxJacobian'>Internal function for calculating the Jacobian</h2><span id='topic+.rxJacobian'></span>

<h3>Description</h3>

<p>Internal function for calculating the Jacobian
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rxJacobian(model, vars = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".rxJacobian_+3A_model">model</code></td>
<td>
<p>symengine environment</p>
</td></tr>
<tr><td><code id=".rxJacobian_+3A_vars">vars</code></td>
<td>
<p>Variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Jacobian information
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.rxLinCmtGen'>Internal function to generate the model variables for a linCmt() model</h2><span id='topic+.rxLinCmtGen'></span>

<h3>Description</h3>

<p>Internal function to generate the model variables for a linCmt() model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rxLinCmtGen(lenState, vars)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".rxLinCmtGen_+3A_lenstate">lenState</code></td>
<td>
<p>Length of the state</p>
</td></tr>
<tr><td><code id=".rxLinCmtGen_+3A_vars">vars</code></td>
<td>
<p>Variables in the model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Model variables of expanded linCmt model
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.rxode2ptrs'>Get the rxode2 function pointers</h2><span id='topic+.rxode2ptrs'></span>

<h3>Description</h3>

<p>This function is used to get the function pointers for rxode2.  This is
used to allow rxode2 to have binary linkage to nlmixr2est.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rxode2ptrs()
</code></pre>


<h3>Value</h3>

<p>a list of function pointers
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
.rxode2ptrs()
</code></pre>

<hr>
<h2 id='.rxPrune'>Internal Pruning function</h2><span id='topic+.rxPrune'></span>

<h3>Description</h3>

<p>Internal Pruning function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rxPrune(x, envir = parent.frame(), strAssign = list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".rxPrune_+3A_x">x</code></td>
<td>
<p>List of quoted lines</p>
</td></tr>
<tr><td><code id=".rxPrune_+3A_envir">envir</code></td>
<td>
<p>Environment where information is stored</p>
</td></tr>
<tr><td><code id=".rxPrune_+3A_strassign">strAssign</code></td>
<td>
<p>string assignment list from  model variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Pruned model code
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.rxSEeqUsr'>Return the equivalents symengine user functions from C</h2><span id='topic+.rxSEeqUsr'></span>

<h3>Description</h3>

<p>Return the equivalents symengine user functions from C
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rxSEeqUsr()
</code></pre>


<h3>Value</h3>

<p>equivalent symengine user functions
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.rxSens'>Sensitivity for model</h2><span id='topic+.rxSens'></span>

<h3>Description</h3>

<p>Sensitivity for model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rxSens(model, vars, vars2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".rxSens_+3A_model">model</code></td>
<td>
<p>symengine model environment</p>
</td></tr>
<tr><td><code id=".rxSens_+3A_vars">vars</code></td>
<td>
<p>Variables for single sensitivity</p>
</td></tr>
<tr><td><code id=".rxSens_+3A_vars2">vars2</code></td>
<td>
<p>if present, 2 parameter sensitivity</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Sensitivity
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.rxTransform'>rxode2 general transformation function</h2><span id='topic+.rxTransform'></span>

<h3>Description</h3>

<p>rxode2 general transformation function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rxTransform(
  x,
  lambda = 1,
  low = 0,
  high = 1,
  transform = c("boxCox", "yeoJohnson", "untransformed", "lnorm", "logit",
    "logit + yeoJohnson", "probit", "probit + yeoJohnson", "logit + boxCox",
    "probit + boxCox"),
  inverse = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".rxTransform_+3A_x">x</code></td>
<td>
<p>value that will be transformed</p>
</td></tr>
<tr><td><code id=".rxTransform_+3A_lambda">lambda</code></td>
<td>
<p>lambda value for the transformation</p>
</td></tr>
<tr><td><code id=".rxTransform_+3A_low">low</code></td>
<td>
<p>lower bound for the transformation</p>
</td></tr>
<tr><td><code id=".rxTransform_+3A_high">high</code></td>
<td>
<p>upper bound for the transformation</p>
</td></tr>
<tr><td><code id=".rxTransform_+3A_transform">transform</code></td>
<td>
<p>transformation to use (can be integer or string
matching supported transformations)</p>
</td></tr>
<tr><td><code id=".rxTransform_+3A_inverse">inverse</code></td>
<td>
<p>boolean if the inverse transformation should be performed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>transformed value
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
logit(0.25)

.rxTransform(0.25, transform="logit")

expit(-1.09)

.rxTransform(-1.09, transform="logit", inverse=TRUE)

</code></pre>

<hr>
<h2 id='.rxTransInfo'>Get the information about the rxode2 derived parameter transformation</h2><span id='topic+.rxTransInfo'></span>

<h3>Description</h3>

<p>Get the information about the rxode2 derived parameter transformation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rxTransInfo(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".rxTransInfo_+3A_...">...</code></td>
<td>
<p>Parameters translated, should be unquoted and not assigned to anything.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Translation information; This list contains:
</p>

<ul>
<li> <p><code style="white-space: pre;">&#8288;$str&#8288;</code> A named string of the parameters as seen in the underlying C/C++
code. The parameters that are NA are not used in the linear
compartment model calculations.
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$ncmt&#8288;</code> the number of compartments in the model
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;$trans&#8288;</code> the rxode2 translation number of the parameterization
</p>
</li></ul>

<p>This contains the linCmt()
translation number, the number of compartments and the parameters
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
.rxTransInfo(cl, v , Vp, vp2, q, q2)

.rxTransInfo(k12, k21, k13, k31, kel, v)

.rxTransInfo(k12, k21, k13, k31, kel, v, ka)

.rxTransInfo(CL, V)

</code></pre>

<hr>
<h2 id='.rxWithOptions'>Temporarily set options then restore them while running code</h2><span id='topic+.rxWithOptions'></span>

<h3>Description</h3>

<p>Temporarily set options then restore them while running code
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rxWithOptions(ops, code)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".rxWithOptions_+3A_ops">ops</code></td>
<td>
<p>list of options that will be temporarily set for the
<code>code</code></p>
</td></tr>
<tr><td><code id=".rxWithOptions_+3A_code">code</code></td>
<td>
<p>The code to run during the sink</p>
</td></tr>
</table>


<h3>Value</h3>

<p>value of code
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
.rxWithOptions(list(digits = 21), {
  print(pi)
})

print(pi)
</code></pre>

<hr>
<h2 id='.rxWithSink'>With one sink, then release</h2><span id='topic+.rxWithSink'></span><span id='topic+.rxWithSinkBoth'></span>

<h3>Description</h3>

<p>With one sink, then release
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rxWithSink(file, code)

.rxWithSinkBoth(file, code)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".rxWithSink_+3A_file">file</code></td>
<td>
<p>the path to the file sink while running the <code>code</code></p>
</td></tr>
<tr><td><code id=".rxWithSink_+3A_code">code</code></td>
<td>
<p>The code to run during the sink</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>.rxWithSink</code> captures output from <code>cat</code>
</p>
<p><code>.rxWithSinkBoth</code> captures output from <code>cat</code> and <code>message</code>
</p>


<h3>Value</h3>

<p>Will return the results of the <code>code</code> section
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
t &lt;- tempfile()
.rxWithSink(t, cat("message\n"))
cat("cat2\n") # now you can see the cat2
lines &lt;- readLines(t)
unlink(t)
</code></pre>

<hr>
<h2 id='.rxWithWd'>Temporarily set options then restore them while running code</h2><span id='topic+.rxWithWd'></span>

<h3>Description</h3>

<p>Temporarily set options then restore them while running code
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.rxWithWd(wd, code)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".rxWithWd_+3A_wd">wd</code></td>
<td>
<p>working directory to temporarily set the system to while
evaluating the code</p>
</td></tr>
<tr><td><code id=".rxWithWd_+3A_code">code</code></td>
<td>
<p>The code to run during the sink</p>
</td></tr>
</table>


<h3>Value</h3>

<p>value of code
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
.rxWithWd(tempdir(), {
  getwd()
})

getwd()
</code></pre>

<hr>
<h2 id='.s3register'>Register a method for a suggested dependency</h2><span id='topic+.s3register'></span>

<h3>Description</h3>

<p>Generally, the recommend way to register an S3 method is to use the
<code>S3Method()</code> namespace directive (often generated automatically by the
<code style="white-space: pre;">&#8288;@export&#8288;</code> roxygen2 tag). However, this technique requires that the generic
be in an imported package, and sometimes you want to suggest a package,
and only provide a method when that package is loaded. <code>s3_register()</code>
can be called from your package's <code>.onLoad()</code> to dynamically register
a method only if the generic's package is loaded. (To avoid taking a
dependency on vctrs for this one function, please feel free to copy
and paste the function source into your own package.)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.s3register(generic, class, method = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".s3register_+3A_generic">generic</code></td>
<td>
<p>Name of the generic in the form <code>pkg::generic</code>.</p>
</td></tr>
<tr><td><code id=".s3register_+3A_class">class</code></td>
<td>
<p>Name of the class</p>
</td></tr>
<tr><td><code id=".s3register_+3A_method">method</code></td>
<td>
<p>Optionally, the implementation of the method. By default,
this will be found by looking for a function called <code>generic.class</code>
in the package environment.
</p>
<p>Note that providing <code>method</code> can be dangerous if you use
devtools. When the namespace of the method is reloaded by
<code>devtools::load_all()</code>, the function will keep inheriting from
the old namespace. This might cause crashes because of dangling
<code>.Call()</code> pointers.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For R 3.5.0 and later, <code>s3_register()</code> is also useful when demonstrating
class creation in a vignette, since method lookup no longer always involves
the lexical scope. For R 3.6.0 and later, you can achieve a similar effect
by using &quot;delayed method registration&quot;, i.e. placing the following in your
<code>NAMESPACE</code> file:
</p>
<div class="sourceCode"><pre>if (getRversion() &gt;= "3.6.0") {
  S3method(package::generic, class)
}
</pre></div>


<h3>Value</h3>

<p>nothing; called for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A typical use case is to dynamically register tibble/pillar methods
# for your class. That way you avoid creating a hard dependency on packages
# that are not essential, while still providing finer control over
# printing when they are used.

.onLoad &lt;- function(...) {
  .s3Register("pillar::pillar_shaft", "vctrs_vctr")
  .s3Register("tibble::type_sum", "vctrs_vctr")
}
</code></pre>

<hr>
<h2 id='.symengineFs'>Return symengineFs from user functions</h2><span id='topic+.symengineFs'></span>

<h3>Description</h3>

<p>Return symengineFs from user functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.symengineFs()
</code></pre>


<h3>Value</h3>

<p>symengineFs from user functions
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.toClassicEvid'>This converts NONMEM-style EVIDs to classic RxODE events</h2><span id='topic+.toClassicEvid'></span>

<h3>Description</h3>

<p>This converts NONMEM-style EVIDs to classic RxODE events
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.toClassicEvid(cmt = 1L, amt = 0, rate = 0, dur = 0, ii = 0, evid = 0L, ss = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".toClassicEvid_+3A_cmt">cmt</code></td>
<td>
<p>compartment flag</p>
</td></tr>
<tr><td><code id=".toClassicEvid_+3A_amt">amt</code></td>
<td>
<p>dose amount</p>
</td></tr>
<tr><td><code id=".toClassicEvid_+3A_rate">rate</code></td>
<td>
<p>dose rate</p>
</td></tr>
<tr><td><code id=".toClassicEvid_+3A_dur">dur</code></td>
<td>
<p>dose duration</p>
</td></tr>
<tr><td><code id=".toClassicEvid_+3A_ii">ii</code></td>
<td>
<p>inter-dose interval</p>
</td></tr>
<tr><td><code id=".toClassicEvid_+3A_evid">evid</code></td>
<td>
<p>event id</p>
</td></tr>
<tr><td><code id=".toClassicEvid_+3A_ss">ss</code></td>
<td>
<p>steady state</p>
</td></tr>
</table>


<h3>Value</h3>

<p>classic evids, excluding evids that are added (you need to
add them manually) or simply use etTran.  This is mostly for
testing and really shouldn't be used directly.
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>.toClassicEvid(cmt=10, amt=3, evid=1)
.toClassicEvid(cmt=10, amt=3, rate=2, evid=1)
.toClassicEvid(cmt=10, amt=3, rate=-1, evid=1)
.toClassicEvid(cmt=10, amt=3, rate=-2, evid=1)
.toClassicEvid(cmt=10, amt=3, dur=2, evid=1)
.toClassicEvid(cmt=304, amt=3, dur=2, evid=1)
.toClassicEvid(cmt=7, amt=0, rate=2, evid=1, ss=1)
.toClassicEvid(cmt=-10, amt=3, evid=1)
.toClassicEvid(cmt=10, amt=3, evid=5)
.toClassicEvid(cmt=6, amt=3, evid=6)
.toClassicEvid(cmt=6, amt=3, evid=7)
.toClassicEvid(evid=2)
.toClassicEvid(evid=4)
</code></pre>

<hr>
<h2 id='.udfCallFunArg'>Get the function name with the current arguments as a string</h2><span id='topic+.udfCallFunArg'></span>

<h3>Description</h3>

<p>Get the function name with the current arguments as a string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.udfCallFunArg(fun, args)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".udfCallFunArg_+3A_fun">fun</code></td>
<td>
<p>function name</p>
</td></tr>
<tr><td><code id=".udfCallFunArg_+3A_args">args</code></td>
<td>
<p>arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string of the form 'fun(arg1, arg2)':
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.udfEnvReset'>Lock/Unlock environment for getting R user functions</h2><span id='topic+.udfEnvReset'></span>

<h3>Description</h3>

<p>Lock/Unlock environment for getting R user functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.udfEnvReset(lock = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".udfEnvReset_+3A_lock">lock</code></td>
<td>
<p>logical to see if environment to look for user defined
functions is locked.  If it is locked then environments are not
assigned.  When NULL returns lock status</p>
</td></tr>
</table>


<h3>Value</h3>

<p>lock status
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.udfEnvSet'>Setup the UDF environment (for querying user defined funtions)</h2><span id='topic+.udfEnvSet'></span>

<h3>Description</h3>

<p>Setup the UDF environment (for querying user defined funtions)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.udfEnvSet(env)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".udfEnvSet_+3A_env">env</code></td>
<td>
<p>environment where user defined functions are queried. If NULL return current environment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>environment
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.udfEnvSetUdf'>Use the udf model variable information to get the environment where
the functions exists</h2><span id='topic+.udfEnvSetUdf'></span>

<h3>Description</h3>

<p>Use the udf model variable information to get the environment where
the functions exists
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.udfEnvSetUdf(udf)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".udfEnvSetUdf_+3A_udf">udf</code></td>
<td>
<p>modelVars$udf, integer vector with NA_integer_ for the
address of the environment where the functions exist</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing called for side effects
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.udfExists'>See if the UI function exists in given environment.</h2><span id='topic+.udfExists'></span>

<h3>Description</h3>

<p>If other functions have been declared, make sure they exist too.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.udfExists(fun, nargs, envir, doList = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".udfExists_+3A_fun">fun</code></td>
<td>
<p>Function to check</p>
</td></tr>
<tr><td><code id=".udfExists_+3A_nargs">nargs</code></td>
<td>
<p>Number of args to check</p>
</td></tr>
<tr><td><code id=".udfExists_+3A_envir">envir</code></td>
<td>
<p>Environment to check</p>
</td></tr>
<tr><td><code id=".udfExists_+3A_dolist">doList</code></td>
<td>
<p>A boolean to see if the functions in .udfEnv$fun
should be checked too.  By default TRUE, but this is called
recursively for each function (and set to FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>logical declaring if the udf function exists in this environment
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.udfMd5Info'>Get the udf strings for creating model md5</h2><span id='topic+.udfMd5Info'></span>

<h3>Description</h3>

<p>Get the udf strings for creating model md5
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.udfMd5Info()
</code></pre>


<h3>Value</h3>

<p>string vector
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='.uiArg'>Handle arguments for ui functions</h2><span id='topic+.uiArg'></span>

<h3>Description</h3>

<p>Note this is an internal function but it is exported in case it is
useful.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.uiArg(char, f, dp)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".uiArg_+3A_char">char</code></td>
<td>
<p>This is the character equivalent of the argument</p>
</td></tr>
<tr><td><code id=".uiArg_+3A_f">f</code></td>
<td>
<p>This is the forced equivalent of the argument</p>
</td></tr>
<tr><td><code id=".uiArg_+3A_dp">dp</code></td>
<td>
<p>This is deparsed expression</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character representing the underlying rxode2 code for the argument
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
.uiArg("1.0", 1.0, "1.0")
</code></pre>

<hr>
<h2 id='.useUtf'>Internal function to figure out if this session supports Unicode</h2><span id='topic+.useUtf'></span>

<h3>Description</h3>

<p>Internal function to figure out if this session supports Unicode
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.useUtf()
</code></pre>


<h3>Value</h3>

<p>boolean indicating if this session supports Unicode
</p>

<hr>
<h2 id='.vecDf'>Convert numeric vector to repeated data.frame</h2><span id='topic+.vecDf'></span>

<h3>Description</h3>

<p>Convert numeric vector to repeated data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.vecDf(vec, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".vecDf_+3A_vec">vec</code></td>
<td>
<p>Named input vector</p>
</td></tr>
<tr><td><code id=".vecDf_+3A_n">n</code></td>
<td>
<p>Number of columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame with repeated vec
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='+2B.rxSolve'>Update Solved object with '+'</h2><span id='topic++2B.rxSolve'></span>

<h3>Description</h3>

<p>Update Solved object with '+'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rxSolve'
solved + new
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B2B.rxSolve_+3A_solved">solved</code></td>
<td>
<p>Solved object</p>
</td></tr>
<tr><td><code id="+2B2B.rxSolve_+3A_new">new</code></td>
<td>
<p>New information added to the table.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>new solved object
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='add.dosing'>Add dosing to eventTable</h2><span id='topic+add.dosing'></span>

<h3>Description</h3>

<p>This adds a dosing event to the event table.  This is provided for
piping syntax through magrittr.  It can also be accessed by <code>eventTable$add.dosing(...)</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.dosing(
  eventTable,
  dose,
  nbr.doses = 1L,
  dosing.interval = 24,
  dosing.to = 1L,
  rate = NULL,
  amount.units = NA_character_,
  start.time = 0,
  do.sampling = FALSE,
  time.units = NA_character_,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add.dosing_+3A_eventtable">eventTable</code></td>
<td>
<p>eventTable object; When accessed from object it would be <code style="white-space: pre;">&#8288;eventTable$&#8288;</code></p>
</td></tr>
<tr><td><code id="add.dosing_+3A_dose">dose</code></td>
<td>
<p>numeric scalar, dose amount in <code>amount.units</code>;</p>
</td></tr>
<tr><td><code id="add.dosing_+3A_nbr.doses">nbr.doses</code></td>
<td>
<p>integer, number of doses;</p>
</td></tr>
<tr><td><code id="add.dosing_+3A_dosing.interval">dosing.interval</code></td>
<td>
<p>required numeric scalar, time between doses
in <code>time.units</code>, defaults to 24 of
<code>time.units="hours"</code>;</p>
</td></tr>
<tr><td><code id="add.dosing_+3A_dosing.to">dosing.to</code></td>
<td>
<p>integer, compartment the dose goes into (first
compartment by default);</p>
</td></tr>
<tr><td><code id="add.dosing_+3A_rate">rate</code></td>
<td>
<p>for infusions, the rate of infusion (default is
<code>NULL</code>, for bolus dosing;</p>
</td></tr>
<tr><td><code id="add.dosing_+3A_amount.units">amount.units</code></td>
<td>
<p>optional string indicating the dosing units.
Defaults to <code>NA</code> to indicate as per the original
<code>EventTable</code> definition.</p>
</td></tr>
<tr><td><code id="add.dosing_+3A_start.time">start.time</code></td>
<td>
<p>required dosing start time;</p>
</td></tr>
<tr><td><code id="add.dosing_+3A_do.sampling">do.sampling</code></td>
<td>
<p>logical, should observation sampling records be
added at the dosing times? Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="add.dosing_+3A_time.units">time.units</code></td>
<td>
<p>optional string indicating the time units.
Defaults to <code>"hours"</code> to indicate as per the original
<code>EventTable</code> definition.</p>
</td></tr>
<tr><td><code id="add.dosing_+3A_...">...</code></td>
<td>
<p>Other parameters passed to <code><a href="#topic+et">et()</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>eventTable with updated dosing (note the event table will
be updated anyway)
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>
<p>Matthew L Fidler, Wenping Wang
</p>


<h3>References</h3>

<p>Wang W, Hallow K, James D (2015). &quot;A Tutorial on rxode2: Simulating
Differential Equation Pharmacometric Models in R.&quot; CPT:
Pharmacometrics and Systems Pharmacology, 5(1), 3-10. ISSN 2163-8306
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eventTable">eventTable</a></code>, <code><a href="#topic+add.sampling">add.sampling</a></code>,
<code><a href="#topic+add.dosing">add.dosing</a></code>, <code><a href="#topic+et">et</a></code>,
<code><a href="#topic+etRep">etRep</a></code>, <code><a href="#topic+etRbind">etRbind</a></code>,
<code><a href="#topic+rxode2">rxode2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

library(rxode2)
library(units)

# Model from rxode2 tutorial
# Using a nlmixr2 style function

mod1 &lt;-function(){
  ini({
    KA &lt;- 2.94E-01
    CL &lt;- 1.86E+01
    V2 &lt;- 4.02E+01
    Q &lt;- 1.05E+01
    V3 &lt;- 2.97E+02
    Kin &lt;- 1
    Kout &lt;- 1
    EC50 &lt;- 200
  })
 model({
    C2 &lt;- centr/V2
    C3 &lt;- peri/V3
    d/dt(depot) &lt;- -KA*depot
    d/dt(centr) &lt;- KA*depot - CL*C2 - Q*C2 + Q*C3
    d/dt(peri)  &lt;-                    Q*C2 - Q*C3
    d/dt(eff)   &lt;- Kin - Kout*(1-C2/(EC50+C2))*eff
 })
}

## These are making the more complex regimens of the rxode2 tutorial

## bid for 5 days
bid &lt;- et(timeUnits="hr") |&gt;
       et(amt=10000,ii=12,until=set_units(5, "days"))

## qd for 5 days
qd &lt;- et(timeUnits="hr") |&gt;
      et(amt=20000,ii=24,until=set_units(5, "days"))

## bid for 5 days followed by qd for 5 days

et &lt;- seq(bid,qd) |&gt;
      et(seq(0,11*24,length.out=100))

bidQd &lt;- rxSolve(mod1, et)

plot(bidQd, C2)


## Now Infusion for 5 days followed by oral for 5 days

##  note you can dose to a named compartment instead of using the compartment number
infusion &lt;- et(timeUnits = "hr") |&gt;
      et(amt=10000, rate=5000, ii=24, until=set_units(5, "days"), cmt="centr")


qd &lt;- et(timeUnits = "hr") |&gt;
  et(amt=10000, ii=24, until=set_units(5, "days"), cmt="depot")

et &lt;- seq(infusion,qd)

infusionQd &lt;- rxSolve(mod1, et)

plot(infusionQd, C2)

## 2wk-on, 1wk-off

qd &lt;- et(timeUnits = "hr") |&gt;
      et(amt=10000, ii=24, until=set_units(2, "weeks"), cmt="depot")

et &lt;- seq(qd, set_units(1,"weeks"), qd) |&gt;
     add.sampling(set_units(seq(0, 5.5,by=0.005),weeks))

wkOnOff &lt;- rxSolve(mod1, et)

plot(wkOnOff, C2)

## You can also repeat the cycle easily with the rep function

qd &lt;-et(timeUnits = "hr") |&gt;
     et(amt=10000, ii=24, until=set_units(2, "weeks"), cmt="depot")

et &lt;- etRep(qd, times=4, wait=set_units(1,"weeks")) |&gt;
      add.sampling(set_units(seq(0, 12.5,by=0.005),weeks))

repCycle4 &lt;- rxSolve(mod1, et)

plot(repCycle4, C2)


## End(Not run)
</code></pre>

<hr>
<h2 id='add.sampling'>Add sampling to eventTable</h2><span id='topic+add.sampling'></span>

<h3>Description</h3>

<p>This adds a dosing event to the event table.  This is provided for
piping syntax through magrittr.  It can also be accessed by
<code>eventTable$add.sampling()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add.sampling(eventTable, time, time.units = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add.sampling_+3A_eventtable">eventTable</code></td>
<td>
<p>An eventTable object. When accessed from object it would be <code style="white-space: pre;">&#8288;eventTable$&#8288;</code></p>
</td></tr>
<tr><td><code id="add.sampling_+3A_time">time</code></td>
<td>
<p>a vector of time values (in <code>time.units</code>).</p>
</td></tr>
<tr><td><code id="add.sampling_+3A_time.units">time.units</code></td>
<td>
<p>an optional string specifying the time
units. Defaults to the units specified when the
<code>EventTable</code> was initialized.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>eventTable with updated sampling.  (Note the event table
will be updated even if you don't reassign the eventTable)
</p>


<h3>Author(s)</h3>

<p>Matthew L Fidler, Wenping Wang
</p>


<h3>References</h3>

<p>Wang W, Hallow K, James D (2015). &quot;A Tutorial on rxode2: Simulating
Differential Equation Pharmacometric Models in R.&quot; CPT:
Pharmacometrics and Systems Pharmacology, 5(1), 3-10. ISSN 2163-8306
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eventTable">eventTable</a></code>, <code><a href="#topic+add.sampling">add.sampling</a></code>,
<code><a href="#topic+add.dosing">add.dosing</a></code>, <code><a href="#topic+et">et</a></code>,
<code><a href="#topic+etRep">etRep</a></code>, <code><a href="#topic+etRbind">etRbind</a></code>,
<code><a href="#topic+rxode2">rxode2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

library(rxode2)
library(units)

# Model from rxode2 tutorial
# Using a nlmixr2 style function

mod1 &lt;-function(){
  ini({
    KA &lt;- 2.94E-01
    CL &lt;- 1.86E+01
    V2 &lt;- 4.02E+01
    Q &lt;- 1.05E+01
    V3 &lt;- 2.97E+02
    Kin &lt;- 1
    Kout &lt;- 1
    EC50 &lt;- 200
  })
 model({
    C2 &lt;- centr/V2
    C3 &lt;- peri/V3
    d/dt(depot) &lt;- -KA*depot
    d/dt(centr) &lt;- KA*depot - CL*C2 - Q*C2 + Q*C3
    d/dt(peri)  &lt;-                    Q*C2 - Q*C3
    d/dt(eff)   &lt;- Kin - Kout*(1-C2/(EC50+C2))*eff
 })
}

## These are making the more complex regimens of the rxode2 tutorial

## bid for 5 days
bid &lt;- et(timeUnits="hr") |&gt;
       et(amt=10000,ii=12,until=set_units(5, "days"))

## qd for 5 days
qd &lt;- et(timeUnits="hr") |&gt;
      et(amt=20000,ii=24,until=set_units(5, "days"))

## bid for 5 days followed by qd for 5 days

et &lt;- seq(bid,qd) |&gt;
      et(seq(0,11*24,length.out=100))

bidQd &lt;- rxSolve(mod1, et)

plot(bidQd, C2)


## Now Infusion for 5 days followed by oral for 5 days

##  note you can dose to a named compartment instead of using the compartment number
infusion &lt;- et(timeUnits = "hr") |&gt;
      et(amt=10000, rate=5000, ii=24, until=set_units(5, "days"), cmt="centr")


qd &lt;- et(timeUnits = "hr") |&gt;
  et(amt=10000, ii=24, until=set_units(5, "days"), cmt="depot")

et &lt;- seq(infusion,qd)

infusionQd &lt;- rxSolve(mod1, et)

plot(infusionQd, C2)

## 2wk-on, 1wk-off

qd &lt;- et(timeUnits = "hr") |&gt;
      et(amt=10000, ii=24, until=set_units(2, "weeks"), cmt="depot")

et &lt;- seq(qd, set_units(1,"weeks"), qd) |&gt;
     add.sampling(set_units(seq(0, 5.5,by=0.005),weeks))

wkOnOff &lt;- rxSolve(mod1, et)

plot(wkOnOff, C2)

## You can also repeat the cycle easily with the rep function

qd &lt;-et(timeUnits = "hr") |&gt;
     et(amt=10000, ii=24, until=set_units(2, "weeks"), cmt="depot")

et &lt;- etRep(qd, times=4, wait=set_units(1,"weeks")) |&gt;
      add.sampling(set_units(seq(0, 12.5,by=0.005),weeks))

repCycle4 &lt;- rxSolve(mod1, et)

plot(repCycle4, C2)


## End(Not run)
</code></pre>

<hr>
<h2 id='as.et'>Coerce object to data.frame</h2><span id='topic+as.et'></span><span id='topic+as.et.default'></span>

<h3>Description</h3>

<p>Coerce object to data.frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.et(x, ...)

## Default S3 method:
as.et(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.et_+3A_x">x</code></td>
<td>
<p>Object to coerce to et.</p>
</td></tr>
<tr><td><code id="as.et_+3A_...">...</code></td>
<td>
<p>Other parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An event table
</p>

<hr>
<h2 id='as.ini'>Turn into an ini block for initialization</h2><span id='topic+as.ini'></span><span id='topic+as.ini.character'></span><span id='topic+as.ini.data.frame'></span><span id='topic+as.ini.call'></span><span id='topic+as.ini.lotriFix'></span><span id='topic+as.ini.matrix'></span><span id='topic+as.ini.default'></span>

<h3>Description</h3>

<p>Turn into an ini block for initialization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.ini(x)

## S3 method for class 'character'
as.ini(x)

## S3 method for class 'data.frame'
as.ini(x)

## S3 method for class 'call'
as.ini(x)

## S3 method for class 'lotriFix'
as.ini(x)

## S3 method for class 'matrix'
as.ini(x)

## Default S3 method:
as.ini(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.ini_+3A_x">x</code></td>
<td>
<p>Item to convert to a rxode2/nlmixr2 ui ini expression</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rxode2 ini expression
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ini &lt;- quote(ini({
  tka &lt;- log(1.57)
  tcl &lt;- log(2.72)
  tv &lt;- log(31.5)
  eta.ka ~ 0.6
  eta.cl ~ 0.3
  eta.v ~ 0.1
  add.sd &lt;- 0.7
}))

as.ini(ini)

l &lt;- quote(lotri({
  tka &lt;- log(1.57)
  tcl &lt;- log(2.72)
  tv &lt;- log(31.5)
  eta.ka ~ 0.6
  eta.cl ~ 0.3
  eta.v ~ 0.1
  add.sd &lt;- 0.7
 }))

as.ini(l)

m &lt;- lotri({
   eta.ka ~ 0.6
   eta.cl ~ 0.3
   eta.v ~ 0.1
})

as.ini(m)

one.compartment &lt;- function() {
  ini({
    tka &lt;- log(1.57)
    tcl &lt;- log(2.72)
    tv &lt;- log(31.5)
    eta.ka ~ 0.6
    eta.cl ~ 0.3
    eta.v ~ 0.1
    add.sd &lt;- 0.7
  })
  model({
    ka &lt;- exp(tka + eta.ka)
    cl &lt;- exp(tcl + eta.cl)
    v &lt;- exp(tv + eta.v)
    d/dt(depot) = -ka * depot
    d/dt(center) = ka * depot - cl / v * center
    cp = center / v
    cp ~ add(add.sd)
  })
}

as.ini(one.compartment)

ui &lt;- one.compartment()

as.ini(ui)

ui$iniDf

as.ini(ui$iniDf)

ini &lt;- c("ini({",
          "tka &lt;- log(1.57)",
          "tcl &lt;- log(2.72)",
          "tv &lt;- log(31.5)",
          "eta.ka ~ 0.6",
          "eta.cl ~ 0.3",
          "eta.v ~ 0.1",
          "add.sd &lt;- 0.7",
          "})")

as.ini(ini)

ini &lt;- paste(ini, collapse="\n")

as.ini(ini)

</code></pre>

<hr>
<h2 id='as.model'>Turn into a model expression</h2><span id='topic+as.model'></span><span id='topic+as.model.character'></span><span id='topic+as.model.call'></span><span id='topic+as.model.list'></span><span id='topic+as.model.default'></span>

<h3>Description</h3>

<p>Turn into a model expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.model(x)

## S3 method for class 'character'
as.model(x)

## S3 method for class 'call'
as.model(x)

## S3 method for class 'list'
as.model(x)

## Default S3 method:
as.model(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.model_+3A_x">x</code></td>
<td>
<p>item to convert to a <code>model({})</code> expression</p>
</td></tr>
</table>


<h3>Value</h3>

<p>model expression
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
model &lt;- quote(model({
  ka &lt;- exp(tka + eta.ka)
  cl &lt;- exp(tcl + eta.cl)
  v &lt;- exp(tv + eta.v)
  d/dt(depot) = -ka * depot
  d/dt(center) = ka * depot - cl / v * center
  cp = center / v
  cp ~ add(add.sd)
}))
 
as.model(model)

one.compartment &lt;- function() {
  ini({
    tka &lt;- log(1.57)
    tcl &lt;- log(2.72)
    tv &lt;- log(31.5)
    eta.ka ~ 0.6
    eta.cl ~ 0.3
    eta.v ~ 0.1
    add.sd &lt;- 0.7
  })
  model({
    ka &lt;- exp(tka + eta.ka)
    cl &lt;- exp(tcl + eta.cl)
    v &lt;- exp(tv + eta.v)
    d/dt(depot) = -ka * depot
    d/dt(center) = ka * depot - cl / v * center
    cp = center / v
    cp ~ add(add.sd)
  })
}

as.model(one.compartment)
 
ui &lt;- one.compartment()

as.model(ui)

model &lt;- c("model({",
           "ka &lt;- exp(tka + eta.ka)",
           "cl &lt;- exp(tcl + eta.cl)",
           "v &lt;- exp(tv + eta.v)",
           "d/dt(depot) = -ka * depot",
           "d/dt(center) = ka * depot - cl / v * center",
           "cp = center / v",
           "cp ~ add(add.sd)",
           "})")

as.model(model)

model &lt;- paste(model, collapse="\n")

as.model(model)

</code></pre>

<hr>
<h2 id='as.rxUi'>As rxode2 ui</h2><span id='topic+as.rxUi'></span><span id='topic+as.rxUi.rxode2'></span><span id='topic+as.rxUi.rxode2tos'></span><span id='topic+as.rxUi.rxModelVars'></span><span id='topic+as.rxUi.function'></span><span id='topic+as.rxUi.rxUi'></span><span id='topic+as.rxUi.default'></span>

<h3>Description</h3>

<p>As rxode2 ui
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as.rxUi(x)

## S3 method for class 'rxode2'
as.rxUi(x)

## S3 method for class 'rxode2tos'
as.rxUi(x)

## S3 method for class 'rxModelVars'
as.rxUi(x)

## S3 method for class ''function''
as.rxUi(x)

## S3 method for class 'rxUi'
as.rxUi(x)

## Default S3 method:
as.rxUi(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.rxUi_+3A_x">x</code></td>
<td>
<p>Object to convert to <code>rxUi</code> object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rxUi object (or error if it cannot be converted)
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mod1 &lt;- function() {
 ini({
   # central 
   KA=2.94E-01
   CL=1.86E+01
   V2=4.02E+01
   # peripheral
   Q=1.05E+01
   V3=2.97E+02
   # effects
   Kin=1
   Kout=1
   EC50=200 
 })
 model({
   C2 &lt;- centr/V2
   C3 &lt;- peri/V3
   d/dt(depot) &lt;- -KA*depot
   d/dt(centr) &lt;- KA*depot - CL*C2 - Q*C2 + Q*C3
   d/dt(peri)  &lt;- Q*C2 - Q*C3
   eff(0) &lt;- 1
   d/dt(eff)   &lt;- Kin - Kout*(1-C2/(EC50+C2))*eff
 })
}

as.rxUi(mod1)

</code></pre>

<hr>
<h2 id='assertCompartmentExists'>Verify that the compartment exists in a model</h2><span id='topic+assertCompartmentExists'></span><span id='topic+testCompartmentExists'></span>

<h3>Description</h3>

<p>Verify that the compartment exists in a model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assertCompartmentExists(ui, x)

testCompartmentExists(ui, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assertCompartmentExists_+3A_ui">ui</code></td>
<td>
<p>is the model to test</p>
</td></tr>
<tr><td><code id="assertCompartmentExists_+3A_x">x</code></td>
<td>
<p>The value to test (can be a vector of strings)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the value of the compartment that exists; if it is a vector
returns the first item that matches
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>testCompartmentExists()</code>: Test if compartment exists
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Matthew Fidler &amp; Bill Denney
</p>


<h3>See Also</h3>

<p>Other Assertions: 
<code><a href="#topic+assertCompartmentName">assertCompartmentName</a>()</code>,
<code><a href="#topic+assertCompartmentNew">assertCompartmentNew</a>()</code>,
<code><a href="#topic+assertRxUi">assertRxUi</a>()</code>,
<code><a href="#topic+assertVariableExists">assertVariableExists</a>()</code>,
<code><a href="#topic+assertVariableNew">assertVariableNew</a>()</code>,
<code><a href="#topic+testIniDf">testIniDf</a>()</code>,
<code><a href="#topic+testRxUnbounded">testRxUnbounded</a>()</code>
</p>

<hr>
<h2 id='assertCompartmentName'>Verify that a value is a valid nlmixr2 compartment name</h2><span id='topic+assertCompartmentName'></span><span id='topic+assertVariableName'></span><span id='topic+assertParameterValue'></span><span id='topic+assertExists'></span><span id='topic+testExists'></span>

<h3>Description</h3>

<p>Verify that a value is a valid nlmixr2 compartment name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assertCompartmentName(x)

assertVariableName(x)

assertParameterValue(x)

assertExists(ui, x)

testExists(ui, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assertCompartmentName_+3A_x">x</code></td>
<td>
<p>The value to test</p>
</td></tr>
<tr><td><code id="assertCompartmentName_+3A_ui">ui</code></td>
<td>
<p>when needed, this is the rxode2/nlmixr2 model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value or an error
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>assertVariableName()</code>: Verify that a value is a valid
nlmixr2 variable name
</p>
</li>
<li> <p><code>assertParameterValue()</code>: Verify that a value is a valid
nlmixr2 parameter value
</p>
</li>
<li> <p><code>assertExists()</code>: Assert compartment/variable exists
</p>
</li>
<li> <p><code>testExists()</code>: Test compartment/variable exists
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Bill Denney
</p>


<h3>See Also</h3>

<p>Other Assertions: 
<code><a href="#topic+assertCompartmentExists">assertCompartmentExists</a>()</code>,
<code><a href="#topic+assertCompartmentNew">assertCompartmentNew</a>()</code>,
<code><a href="#topic+assertRxUi">assertRxUi</a>()</code>,
<code><a href="#topic+assertVariableExists">assertVariableExists</a>()</code>,
<code><a href="#topic+assertVariableNew">assertVariableNew</a>()</code>,
<code><a href="#topic+testIniDf">testIniDf</a>()</code>,
<code><a href="#topic+testRxUnbounded">testRxUnbounded</a>()</code>
</p>

<hr>
<h2 id='assertCompartmentNew'>Verify that a compartment would be new to the model</h2><span id='topic+assertCompartmentNew'></span>

<h3>Description</h3>

<p>Verify that a compartment would be new to the model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assertCompartmentNew(ui, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assertCompartmentNew_+3A_ui">ui</code></td>
<td>
<p>is the model to test that a model paramet exists</p>
</td></tr>
<tr><td><code id="assertCompartmentNew_+3A_x">x</code></td>
<td>
<p>The value to test</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The value or an error
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler &amp; Bill Denney
</p>


<h3>See Also</h3>

<p>Other Assertions: 
<code><a href="#topic+assertCompartmentExists">assertCompartmentExists</a>()</code>,
<code><a href="#topic+assertCompartmentName">assertCompartmentName</a>()</code>,
<code><a href="#topic+assertRxUi">assertRxUi</a>()</code>,
<code><a href="#topic+assertVariableExists">assertVariableExists</a>()</code>,
<code><a href="#topic+assertVariableNew">assertVariableNew</a>()</code>,
<code><a href="#topic+testIniDf">testIniDf</a>()</code>,
<code><a href="#topic+testRxUnbounded">testRxUnbounded</a>()</code>
</p>

<hr>
<h2 id='assertRxUi'>Assert properties of the rxUi models</h2><span id='topic+assertRxUi'></span><span id='topic+assertRxUiPrediction'></span><span id='topic+assertRxUiSingleEndpoint'></span><span id='topic+assertRxUiTransformNormal'></span><span id='topic+assertRxUiNormal'></span><span id='topic+assertRxUiMuRefOnly'></span><span id='topic+assertRxUiEstimatedResiduals'></span><span id='topic+assertRxUiPopulationOnly'></span><span id='topic+assertRxUiMixedOnly'></span><span id='topic+assertRxUiRandomOnIdOnly'></span>

<h3>Description</h3>

<p>Assert properties of the rxUi models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assertRxUi(ui, extra = "", .var.name = .vname(ui))

assertRxUiPrediction(ui, extra = "", .var.name = .vname(ui))

assertRxUiSingleEndpoint(ui, extra = "", .var.name = .vname(ui))

assertRxUiTransformNormal(ui, extra = "", .var.name = .vname(ui))

assertRxUiNormal(ui, extra = "", .var.name = .vname(ui))

assertRxUiMuRefOnly(ui, extra = "", .var.name = .vname(ui))

assertRxUiEstimatedResiduals(ui, extra = "", .var.name = .vname(ui))

assertRxUiPopulationOnly(ui, extra = "", .var.name = .vname(ui))

assertRxUiMixedOnly(ui, extra = "", .var.name = .vname(ui))

assertRxUiRandomOnIdOnly(ui, extra = "", .var.name = .vname(ui))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assertRxUi_+3A_ui">ui</code></td>
<td>
<p>Model to check</p>
</td></tr>
<tr><td><code id="assertRxUi_+3A_extra">extra</code></td>
<td>
<p>Extra text to append to the error message (like
&quot;for focei&quot;)</p>
</td></tr>
<tr><td><code id="assertRxUi_+3A_.var.name">.var.name</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Name of the checked object to print in assertions. Defaults to
the heuristic implemented in <code><a href="checkmate.html#topic+vname">vname</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions have different types of assertions
</p>

<ul>
<li> <p><code>assertRxUi</code> &ndash; Make sure this is a proper rxode2 model (if not throw error)
</p>
</li>
<li> <p><code>assertRxUiSingleEndpoint</code> &ndash; Make sure the rxode2 model is only
a single endpoint model (if not throw error)
</p>
</li>
<li> <p><code>assertRxUiTransformNormal</code> &ndash; Make sure that the model residual
distribution is normal or transformably normal
</p>
</li>
<li> <p><code>assertRxUiNormal</code> &ndash; Make sure that the model residual distribution is normal
</p>
</li>
<li> <p><code>assertRxUiEstimatedResiduals</code> &ndash; Make sure that the residual error
parameters are estimated (not modeled).
</p>
</li>
<li> <p><code>assertRxUiPopulationOnly</code> &ndash; Make sure the model is the population only
model (no mixed effects)
</p>
</li>
<li> <p><code>assertRxUiMixedOnly</code> &ndash; Make sure the model is a mixed effect model (not a
population effect, only)
</p>
</li>
<li> <p><code>assertRxUiPrediction</code> &ndash; Make sure the model has predictions
</p>
</li>
<li> <p><code>assertRxUiMuRefOnly</code> &ndash; Make sure that all the parameters are mu-referenced
</p>
</li>
<li> <p><code>assertRxUiRandomOnIdOnly</code> &ndash; Make sure there are only random effects at the ID level
</p>
</li></ul>



<h3>Value</h3>

<p>the rxUi model
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>See Also</h3>

<p>Other Assertions: 
<code><a href="#topic+assertCompartmentExists">assertCompartmentExists</a>()</code>,
<code><a href="#topic+assertCompartmentName">assertCompartmentName</a>()</code>,
<code><a href="#topic+assertCompartmentNew">assertCompartmentNew</a>()</code>,
<code><a href="#topic+assertVariableExists">assertVariableExists</a>()</code>,
<code><a href="#topic+assertVariableNew">assertVariableNew</a>()</code>,
<code><a href="#topic+testIniDf">testIniDf</a>()</code>,
<code><a href="#topic+testRxUnbounded">testRxUnbounded</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

one.cmt &lt;- function() {
 ini({
   tka &lt;- 0.45; label("Ka")
   tcl &lt;- log(c(0, 2.7, 100)); label("Cl")
   tv &lt;- 3.45; label("V")
   eta.ka ~ 0.6
   eta.cl ~ 0.3
   eta.v ~ 0.1
   add.sd &lt;- 0.7
 })
 model({
   ka &lt;- exp(tka + eta.ka)
   cl &lt;- exp(tcl + eta.cl)
   v &lt;- exp(tv + eta.v)
   linCmt() ~ add(add.sd)
 })
}

assertRxUi(one.cmt)
# assertRxUi(rnorm) # will fail

assertRxUiSingleEndpoint(one.cmt)

</code></pre>

<hr>
<h2 id='assertVariableExists'>Assert a variable exists in the model</h2><span id='topic+assertVariableExists'></span><span id='topic+testVariableExists'></span>

<h3>Description</h3>

<p>Assert a variable exists in the model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assertVariableExists(ui, x)

testVariableExists(ui, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assertVariableExists_+3A_ui">ui</code></td>
<td>
<p>rxode2 ui model</p>
</td></tr>
<tr><td><code id="assertVariableExists_+3A_x">x</code></td>
<td>
<p>does the <code>x</code> variable exist in the model.  If it is a
vector of variable check to see if any exists, but all must be
valid nlmixr2 variable names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>variable that matches, in the case of multiple variables,
the first that matches.  If nothing matches return error
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>testVariableExists()</code>: Test if variable exists
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>See Also</h3>

<p>Other Assertions: 
<code><a href="#topic+assertCompartmentExists">assertCompartmentExists</a>()</code>,
<code><a href="#topic+assertCompartmentName">assertCompartmentName</a>()</code>,
<code><a href="#topic+assertCompartmentNew">assertCompartmentNew</a>()</code>,
<code><a href="#topic+assertRxUi">assertRxUi</a>()</code>,
<code><a href="#topic+assertVariableNew">assertVariableNew</a>()</code>,
<code><a href="#topic+testIniDf">testIniDf</a>()</code>,
<code><a href="#topic+testRxUnbounded">testRxUnbounded</a>()</code>
</p>

<hr>
<h2 id='assertVariableNew'>Assert a variable would be new to the model</h2><span id='topic+assertVariableNew'></span>

<h3>Description</h3>

<p>Assert a variable would be new to the model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assertVariableNew(ui, x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="assertVariableNew_+3A_ui">ui</code></td>
<td>
<p>rxode2 ui model</p>
</td></tr>
<tr><td><code id="assertVariableNew_+3A_x">x</code></td>
<td>
<p>would the variable <code>x</code> variable be new in the model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing, but will error if <code>x</code> would not be new
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>See Also</h3>

<p>Other Assertions: 
<code><a href="#topic+assertCompartmentExists">assertCompartmentExists</a>()</code>,
<code><a href="#topic+assertCompartmentName">assertCompartmentName</a>()</code>,
<code><a href="#topic+assertCompartmentNew">assertCompartmentNew</a>()</code>,
<code><a href="#topic+assertRxUi">assertRxUi</a>()</code>,
<code><a href="#topic+assertVariableExists">assertVariableExists</a>()</code>,
<code><a href="#topic+testIniDf">testIniDf</a>()</code>,
<code><a href="#topic+testRxUnbounded">testRxUnbounded</a>()</code>
</p>

<hr>
<h2 id='binomProbs'>Calculate expected confidence bands with binomial sampling distribution</h2><span id='topic+binomProbs'></span><span id='topic+binomProbs.default'></span>

<h3>Description</h3>

<p>This is meant to perform in the same way as <code>quantile()</code> so it can
be a drop in replacement for code using <code>quantile()</code> but using
distributional assumptions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binomProbs(x, ...)

## Default S3 method:
binomProbs(
  x,
  probs = c(0.025, 0.05, 0.5, 0.95, 0.975),
  na.rm = FALSE,
  names = TRUE,
  onlyProbs = TRUE,
  n = 0L,
  m = 0L,
  pred = FALSE,
  piMethod = c("lim"),
  M = 5e+05,
  tol = .Machine$double.eps^0.25,
  ciMethod = c("wilson", "wilsonCorrect", "agrestiCoull", "wald", "wc", "ac"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="binomProbs_+3A_x">x</code></td>
<td>
<p>numeric vector whose mean and probability based confidence
values are wanted, NA and NaN values are not allowed in numeric
vectors unless <code>na.rm</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="binomProbs_+3A_...">...</code></td>
<td>
<p>Arguments passed to default method, allows many
different methods to be applied.</p>
</td></tr>
<tr><td><code id="binomProbs_+3A_probs">probs</code></td>
<td>
<p>numeric vector of probabilities with values in the
interval 0 to 1, inclusive. When 0, it represents the maximum
observed, when 1, it represents the maximum observed. When 0.5 it
represents the expected probability (mean).</p>
</td></tr>
<tr><td><code id="binomProbs_+3A_na.rm">na.rm</code></td>
<td>
<p>logical; if true, any NA and NaN's are removed from
<code>x</code> before the quantiles are computed.</p>
</td></tr>
<tr><td><code id="binomProbs_+3A_names">names</code></td>
<td>
<p>logical; if true, the result has a names attribute.</p>
</td></tr>
<tr><td><code id="binomProbs_+3A_onlyprobs">onlyProbs</code></td>
<td>
<p>logical; if true, only return the probability
based confidence interval/prediction interval estimates,
otherwise return extra statistics.</p>
</td></tr>
<tr><td><code id="binomProbs_+3A_n">n</code></td>
<td>
<p>integer/integerish; this is the n used to calculate the
prediction or confidence interval.  When <code>n=0</code> (default) use the
number of non-<code>NA</code> observations.  When calculating the prediction
interval, this represents the number of observations used in the
input (&quot;true&quot;) distribution.</p>
</td></tr>
<tr><td><code id="binomProbs_+3A_m">m</code></td>
<td>
<p>integer.  When using the prediction interval this
represents the number of samples that will be observed in the
future for the prediction interval.</p>
</td></tr>
<tr><td><code id="binomProbs_+3A_pred">pred</code></td>
<td>
<p>Use a prediction interval instead of a confidence
interval.  By default this is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="binomProbs_+3A_pimethod">piMethod</code></td>
<td>
<p>gives the prediction interval method (currently only lim) from Lu 2020</p>
</td></tr>
<tr><td><code id="binomProbs_+3A_m">M</code></td>
<td>
<p>number of simulations to run for the LIM PI.</p>
</td></tr>
<tr><td><code id="binomProbs_+3A_tol">tol</code></td>
<td>
<p>tolerance of root finding in the LIM prediction interval</p>
</td></tr>
<tr><td><code id="binomProbs_+3A_cimethod">ciMethod</code></td>
<td>
<p>gives the method for calculating the confidence
interval.
</p>
<p>Can be:
</p>

<ul>
<li><p> &quot;argestiCoull&quot; or &quot;ac&quot; &ndash; Agresti-Coull method. For a 95\
interval, this method does not use the concept   of &quot;adding 2
successes and 2 failures,&quot; but rather uses the formulas explicitly
described in the following link:
</p>
</li></ul>

<p>https://en.wikipedia.org/wiki/Binomial_proportion_confidence_interval#Agresti-Coull_Interval.
</p>

<ul>
<li><p> &quot;wilson&quot; &ndash; Wilson Method
</p>
</li>
<li><p> &quot;wilsonCorrect&quot; or &quot;wc&quot; &ndash; Wilson method with continuity correction
</p>
</li>
<li><p> &quot;wald&quot; &ndash; Wald confidence interval or standard z approximation.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>It is used for confidence intervals with rxode2 solved objects using
<code>confint(mean="binom")</code>
</p>


<h3>Value</h3>

<p>By default the return has the probabilities as names (if
named) with the points where the expected distribution are
located given the sampling mean and standard deviation. If
<code>onlyProbs=FALSE</code> then it would prepend mean, variance, standard
deviation, minimum, maximum and number of non-NA observations.
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>References</h3>


<ul>
<li><p> Newcombe, R. G. (1998). &quot;Two-sided confidence intervals for the single
proportion: comparison of seven methods&quot;. Statistics
in Medicine. 17 (8):
857872. doi:10.1002/(SICI)1097-0258(19980430)17:8&lt;857::AID-SIM777&gt;3.0.CO;2-E. PMID
9595616.
</p>
</li>
<li><p> Hezhi Lu, Hua Jin,
A new prediction interval for binomial random variable based on inferential models,
Journal of Statistical Planning and Inference,
Volume 205,
2020,
Pages 156-174,
ISSN 0378-3758,
https://doi.org/10.1016/j.jspi.2019.07.001.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>
x&lt;- rbinom(7001, p=0.375, size=1)
binomProbs(x)

# you can also use the prediction interval

binomProbs(x, pred=TRUE)


# Can get some extra statistics if you request onlyProbs=FALSE
binomProbs(x, onlyProbs=FALSE)

x[2] &lt;- NA_real_

binomProbs(x, onlyProbs=FALSE)

binomProbs(x, na.rm=TRUE)

</code></pre>

<hr>
<h2 id='boxCox'>boxCox/yeoJohnson and inverse boxCox/yeoJohnson functions</h2><span id='topic+boxCox'></span><span id='topic+boxCoxInv'></span><span id='topic+yeoJohnson'></span><span id='topic+yeoJohnsonInv'></span>

<h3>Description</h3>

<p>boxCox/yeoJohnson and inverse boxCox/yeoJohnson functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boxCox(x, lambda = 1)

boxCoxInv(x, lambda = 1)

yeoJohnson(x, lambda = 1)

yeoJohnsonInv(x, lambda = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="boxCox_+3A_x">x</code></td>
<td>
<p>input value(s) to transform</p>
</td></tr>
<tr><td><code id="boxCox_+3A_lambda">lambda</code></td>
<td>
<p>lambda value for the transformation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>values from boxCox and boxCoxInv
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
boxCox(10, 0.5)

boxCoxInv(4.32, 0.5)

yeoJohnson(10, 0.5)

yeoJohnsonInv(4.32, 0.5)

</code></pre>

<hr>
<h2 id='coef.rxode2'>Return the rxode2 coefficients</h2><span id='topic+coef.rxode2'></span>

<h3>Description</h3>

<p>This returns the parameters , state variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rxode2'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.rxode2_+3A_object">object</code></td>
<td>
<p>is an rxode2 object</p>
</td></tr>
<tr><td><code id="coef.rxode2_+3A_...">...</code></td>
<td>
<p>ignored arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a rxCoef object with the following
</p>

<ul>
<li> <p><code>params</code>  is a list of strings for parameters for the rxode2 object
</p>
</li>
<li> <p><code>state</code> is a list of strings for the names of each state in
the rxode2 object.
</p>
</li>
<li> <p><code>ini</code> is the model specified default values for the
parameters.
</p>
</li>
<li> <p><code>rxode2</code> is the referring rxode2 object
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>

<hr>
<h2 id='cvPost'>Sample a covariance Matrix from the Posterior Inverse Wishart
distribution.</h2><span id='topic+cvPost'></span>

<h3>Description</h3>

<p>Note this Inverse wishart rescaled to match the original scale of
the covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cvPost(
  nu,
  omega,
  n = 1L,
  omegaIsChol = FALSE,
  returnChol = FALSE,
  type = c("invWishart", "lkj", "separation"),
  diagXformType = c("log", "identity", "variance", "nlmixrSqrt", "nlmixrLog",
    "nlmixrIdentity")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cvPost_+3A_nu">nu</code></td>
<td>
<p>Degrees of Freedom (Number of Observations) for
covariance matrix simulation.</p>
</td></tr>
<tr><td><code id="cvPost_+3A_omega">omega</code></td>
<td>
<p>Either the estimate of covariance matrix or the
estimated standard deviations in matrix form each row forming
the standard deviation simulated values</p>
</td></tr>
<tr><td><code id="cvPost_+3A_n">n</code></td>
<td>
<p>Number of Matrices to sample.  By default this is 1.
This is only useful when <code>omega</code> is a matrix.  Otherwise
it is determined by the number of rows in the input
<code>omega</code> matrix of standard deviations</p>
</td></tr>
<tr><td><code id="cvPost_+3A_omegaischol">omegaIsChol</code></td>
<td>
<p>is an indicator of if the omega matrix is in
the Cholesky decomposition. This is only used when <code>type="invWishart"</code></p>
</td></tr>
<tr><td><code id="cvPost_+3A_returnchol">returnChol</code></td>
<td>
<p>Return the Cholesky decomposition of the
covariance matrix sample. This is only used when <code>type="invWishart"</code></p>
</td></tr>
<tr><td><code id="cvPost_+3A_type">type</code></td>
<td>
<p>The type of covariance posterior that is being
simulated.  This can be:
</p>

<ul>
<li> <p><code>invWishart</code> The posterior is an inverse wishart; This allows
for correlations between parameters to be modeled.  All the
uncertainty in the parameter is captured in the degrees of freedom
parameter.
</p>
</li>
<li> <p><code>lkj</code> The posterior separates the standard deviation
estimates (modeled outside and provided in the <code>omega</code>
argument) and the correlation estimates. The correlation estimate
is simulated with the <code><a href="#topic+rLKJ1">rLKJ1()</a></code>.  This simulation uses
the relationship <code>eta=(nu-1)/2</code>.  This is relationship based
on the proof of the relationship between the restricted
LKJ-distribution and inverse wishart distribution (XXXXXX).  Once
the correlation posterior is calculated, the estimated standard
deviations are then combined with the simulated correlation matrix
to create the covariance matrix.
</p>
</li>
<li> <p><code>separation</code> Like the <code>lkj</code> option, this separates out
the estimation of the correlation and standard deviation.  Instead
of using the <code>LKJ</code> distribution to simulate the correlation,
it simulates the inverse wishart of the identity matrix and
converts the result to a correlation matrix.  This correlation
matrix is then used with the standard deviation to calculate the
simulated covariance matrix.
</p>
</li></ul>
</td></tr>
<tr><td><code id="cvPost_+3A_diagxformtype">diagXformType</code></td>
<td>
<p>Diagonal transformation type.  These could be:
</p>

<ul>
<li> <p><code>log</code> The standard deviations are log transformed, so the
actual standard deviations are exp(omega)
</p>
</li>
<li> <p><code>identity</code> The standard deviations are not transformed. The
standard deviations are not transformed;  They should be positive.
</p>
</li>
<li> <p><code>variance</code> The variances are specified in the <code>omega</code>
matrix; They are transformed into standard deviations.
</p>
</li>
<li> <p><code>nlmixrSqrt</code> These standard deviations come from an nlmixr
omega matrix where diag(chol(inv(omega))) = x^2
</p>
</li>
<li> <p><code>nlmixrLog</code> These standard deviations come from a nlmixr
omega matrix omega matrix where diag(chol(solve(omega))) = exp(x)
</p>
</li>
<li> <p><code>nlmixrIdentity</code> These standard deviations come from a nlmixr
omega matrix omega matrix where diag(chol(solve(omega))) = x
</p>
</li></ul>

<p>The nlmixr transformations only make sense when there is no
off-diagonal correlations modeled.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If your covariance matrix is a 1x1 matrix, this uses an scaled
inverse chi-squared which is equivalent to the Inverse Wishart
distribution in the uni-directional case.
</p>
<p>In general, the separation strategy is preferred for diagonal
matrices.  If the dimension of the matrix is below 10, <code>lkj</code>
is numerically faster than <code>separation</code> method.  However, the
<code>lkj</code> method has densities too close to zero (XXXX) when the
dimension is above 10.  In that case, though computationally more
expensive <code>separation</code> method performs better.
</p>
<p>For matrices with modeled covariances, the easiest method to use
is the inverse Wishart which allows the simulation of correlation
matrices (XXXX).  This method is more well suited for well behaved
matrices, that is the variance components are not too low or too
high.  When modeling nonlinear mixed effects modeling matrices
with too high or low variances are considered sub-optimal in
describing a system.  With these rules in mind, it is reasonable
to use the inverse Wishart.
</p>


<h3>Value</h3>

<p>a matrix (n=1) or a list of matrices  (n &gt; 1)
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler &amp; Wenping Wang
</p>


<h3>References</h3>

<p>Alvarez I, Niemi J and Simpson M. (2014) <em>Bayesian Inference for a
Covariance Matrix</em>. Conference on Applied Statistics in Agriculture.
</p>
<p>Wang1 Z, Wu Y, and Chu H. (2018) <em>On Equivalence of the LKJ
distribution and the restricted Wishart
distribution</em>. &lt;doi:10.48550/arXiv.1809.047463
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Sample a single covariance.
draw1 &lt;- cvPost(3, matrix(c(1, .3, .3, 1), 2, 2))

## Sample 3 covariances
set.seed(42)
draw3 &lt;- cvPost(3, matrix(c(1, .3, .3, 1), 2, 2), n = 3)

## Sample 3 covariances, but return the cholesky decomposition
set.seed(42)
draw3c &lt;- cvPost(3, matrix(c(1, .3, .3, 1), 2, 2), n = 3, returnChol = TRUE)

## Sample 3 covariances with lognormal standard deviations via LKJ
## correlation sample
cvPost(3, sapply(1:3, function(...) {
  rnorm(10)
}), type = "lkj")

## or return cholesky decomposition
cvPost(3, sapply(1:3, function(...) {
  rnorm(10)
}),
type = "lkj",
returnChol = TRUE
)

## Sample 3 covariances with lognormal standard deviations via separation
## strategy using inverse Wishart correlation sample
cvPost(3, sapply(1:3, function(...) {
  rnorm(10)
}), type = "separation")

## or returning the cholesky decomposition
cvPost(3, sapply(1:3, function(...) {
  rnorm(10)
}),
type = "separation",
returnChol = TRUE
)
</code></pre>

<hr>
<h2 id='dELU'>Derivatives of the Exponential Linear Unit (ELU) Activation Function</h2><span id='topic+dELU'></span><span id='topic+d2ELU'></span><span id='topic+d2aELU'></span><span id='topic+dELUa'></span><span id='topic+d2ELUa'></span>

<h3>Description</h3>

<p>Derivatives of the Exponential Linear Unit (ELU) Activation Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dELU(x, alpha = 1)

d2ELU(x, alpha = 1)

d2aELU(x, alpha = 1)

dELUa(x, alpha = 1)

d2ELUa(x, alpha = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dELU_+3A_x">x</code></td>
<td>
<p>A numeric vector. All elements must be finite and
non-missing.</p>
</td></tr>
<tr><td><code id="dELU_+3A_alpha">alpha</code></td>
<td>
<p>A numeric scalar. All elements must be finite and
non-missing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector where the derivative(s) of the ELU function has been applied
to each element of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>See Also</h3>

<p>Other Activation Functions: 
<code><a href="#topic+ELU">ELU</a>()</code>,
<code><a href="#topic+GELU">GELU</a>()</code>,
<code><a href="#topic+PReLU">PReLU</a>()</code>,
<code><a href="#topic+ReLU">ReLU</a>()</code>,
<code><a href="#topic+SELU">SELU</a>()</code>,
<code><a href="#topic+Swish">Swish</a>()</code>,
<code><a href="#topic+dGELU">dGELU</a>()</code>,
<code><a href="#topic+dPReLU">dPReLU</a>()</code>,
<code><a href="#topic+dReLU">dReLU</a>()</code>,
<code><a href="#topic+dSELU">dSELU</a>()</code>,
<code><a href="#topic+dSwish">dSwish</a>()</code>,
<code><a href="#topic+dlReLU">dlReLU</a>()</code>,
<code><a href="#topic+dsoftplus">dsoftplus</a>()</code>,
<code><a href="#topic+lReLU">lReLU</a>()</code>,
<code><a href="#topic+softplus">softplus</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dELU(c(-1, 0, 1, 2), 2)
d2ELU(c(-1, 0, 1, 2), 2)
d2aELU(c(-1, 0, 1, 2), 2)
dELUa(c(-1, 0, 1, 2), 2)
d2ELUa(c(-1, 0, 1, 2), 2)

# Can also be used in rxode2:
r &lt;- rxode2({
  r1=dELU(time, 2)
  r2=d2ELU(time, 2)
  r2a=d2aELU(time, 2)
  ra=dELUa(time, 2)
  r2a=d2ELUa(time, 2)
})

e &lt;- et(c(-1, 0, 1, 2))
rxSolve(r, e)
</code></pre>

<hr>
<h2 id='dfWishart'>This uses simulations to match the rse</h2><span id='topic+dfWishart'></span>

<h3>Description</h3>

<p>This uses simulations to match the rse
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dfWishart(omega, n, rse, upper, totN = 1000, diag = TRUE, seed = 1234)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dfWishart_+3A_omega">omega</code></td>
<td>
<p>represents the matrix for simulation</p>
</td></tr>
<tr><td><code id="dfWishart_+3A_n">n</code></td>
<td>
<p>This represents the number of subjects/samples this comes
from (used to calculate rse).  When present it assumes the rse=
sqrt(2)/sqrt(n)</p>
</td></tr>
<tr><td><code id="dfWishart_+3A_rse">rse</code></td>
<td>
<p>This is the rse that we try to match, if not specified,
it is derived from <code>n</code></p>
</td></tr>
<tr><td><code id="dfWishart_+3A_upper">upper</code></td>
<td>
<p>The upper boundary for root finding in terms of
degrees of freedom.  If not specified, it is n*200</p>
</td></tr>
<tr><td><code id="dfWishart_+3A_totn">totN</code></td>
<td>
<p>This represents the total number of simulated inverse
wishart deviates</p>
</td></tr>
<tr><td><code id="dfWishart_+3A_diag">diag</code></td>
<td>
<p>When <code>TRUE</code>, represents the rse to match is the
diagonals, otherwise it is the total matrix.</p>
</td></tr>
<tr><td><code id="dfWishart_+3A_seed">seed</code></td>
<td>
<p>to make the simulation reproducible, this represents
the seed that is used for simulating the inverse Wishart
distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>output from <code>uniroot()</code> to find the right estimate
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dfWishart(lotri::lotri(a+b~c(1, 0.5, 1)), 100)

</code></pre>

<hr>
<h2 id='dGELU'>Derivatives of GELU</h2><span id='topic+dGELU'></span><span id='topic+d2GELU'></span><span id='topic+d3GELU'></span><span id='topic+d4GELU'></span>

<h3>Description</h3>

<p>Derivatives of GELU
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dGELU(x)

d2GELU(x)

d3GELU(x)

d4GELU(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dGELU_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>See Also</h3>

<p>Other Activation Functions: 
<code><a href="#topic+ELU">ELU</a>()</code>,
<code><a href="#topic+GELU">GELU</a>()</code>,
<code><a href="#topic+PReLU">PReLU</a>()</code>,
<code><a href="#topic+ReLU">ReLU</a>()</code>,
<code><a href="#topic+SELU">SELU</a>()</code>,
<code><a href="#topic+Swish">Swish</a>()</code>,
<code><a href="#topic+dELU">dELU</a>()</code>,
<code><a href="#topic+dPReLU">dPReLU</a>()</code>,
<code><a href="#topic+dReLU">dReLU</a>()</code>,
<code><a href="#topic+dSELU">dSELU</a>()</code>,
<code><a href="#topic+dSwish">dSwish</a>()</code>,
<code><a href="#topic+dlReLU">dlReLU</a>()</code>,
<code><a href="#topic+dsoftplus">dsoftplus</a>()</code>,
<code><a href="#topic+lReLU">lReLU</a>()</code>,
<code><a href="#topic+softplus">softplus</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dGELU(c(-2, -1, 0, 1, 2))
d2GELU(c(-2, -1, 0, 1, 2))
d3GELU(c(-2, -1, 0, 1, 2))
d4GELU(c(-2, -1, 0, 1, 2))
# you can use rxode2 as well
r &lt;- rxode2({
   r1 &lt;- dGELU(time)
   r2 &lt;- d2GELU(time)
   r3 &lt;- d3GELU(time)
   r4 &lt;- d4GELU(time)
})
et &lt;- et(c(-2, -1, 0, 1, 2))
rxSolve(r, et)
</code></pre>

<hr>
<h2 id='dlReLU'>Derivative of Leaky ReLU activation function</h2><span id='topic+dlReLU'></span>

<h3>Description</h3>

<p>Derivative of Leaky ReLU activation function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dlReLU(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dlReLU_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>See Also</h3>

<p>Other Activation Functions: 
<code><a href="#topic+ELU">ELU</a>()</code>,
<code><a href="#topic+GELU">GELU</a>()</code>,
<code><a href="#topic+PReLU">PReLU</a>()</code>,
<code><a href="#topic+ReLU">ReLU</a>()</code>,
<code><a href="#topic+SELU">SELU</a>()</code>,
<code><a href="#topic+Swish">Swish</a>()</code>,
<code><a href="#topic+dELU">dELU</a>()</code>,
<code><a href="#topic+dGELU">dGELU</a>()</code>,
<code><a href="#topic+dPReLU">dPReLU</a>()</code>,
<code><a href="#topic+dReLU">dReLU</a>()</code>,
<code><a href="#topic+dSELU">dSELU</a>()</code>,
<code><a href="#topic+dSwish">dSwish</a>()</code>,
<code><a href="#topic+dsoftplus">dsoftplus</a>()</code>,
<code><a href="#topic+lReLU">lReLU</a>()</code>,
<code><a href="#topic+softplus">softplus</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dlReLU(c(-1, 0, 1))

# Can use in rxode2 as well

r &lt;- rxode2({r &lt;- dlReLU(time)})
e &lt;- et(c(-1, 0, 1))
rxSolve(r, e)

</code></pre>

<hr>
<h2 id='dPReLU'>Derivatives Parametric ReLU Activation Function</h2><span id='topic+dPReLU'></span><span id='topic+dPReLUa'></span><span id='topic+dPReLUa1'></span>

<h3>Description</h3>

<p>Derivatives Parametric ReLU Activation Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dPReLU(x, alpha = 1)

dPReLUa(x, alpha = 1)

dPReLUa1(x, alpha = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dPReLU_+3A_x">x</code></td>
<td>
<p>A numeric vector. All elements must be finite and
non-missing.</p>
</td></tr>
<tr><td><code id="dPReLU_+3A_alpha">alpha</code></td>
<td>
<p>A numeric scalar. All elements must be finite and
non-missing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector where the derivative(s) of the ELU function has been applied
to each element of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>See Also</h3>

<p>Other Activation Functions: 
<code><a href="#topic+ELU">ELU</a>()</code>,
<code><a href="#topic+GELU">GELU</a>()</code>,
<code><a href="#topic+PReLU">PReLU</a>()</code>,
<code><a href="#topic+ReLU">ReLU</a>()</code>,
<code><a href="#topic+SELU">SELU</a>()</code>,
<code><a href="#topic+Swish">Swish</a>()</code>,
<code><a href="#topic+dELU">dELU</a>()</code>,
<code><a href="#topic+dGELU">dGELU</a>()</code>,
<code><a href="#topic+dReLU">dReLU</a>()</code>,
<code><a href="#topic+dSELU">dSELU</a>()</code>,
<code><a href="#topic+dSwish">dSwish</a>()</code>,
<code><a href="#topic+dlReLU">dlReLU</a>()</code>,
<code><a href="#topic+dsoftplus">dsoftplus</a>()</code>,
<code><a href="#topic+lReLU">lReLU</a>()</code>,
<code><a href="#topic+softplus">softplus</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dPReLU(c(-1, 0, 1, 2), 2)
dPReLUa(c(-1, 0, 1, 2), 2)
dPReLUa1(c(-1, 0, 1, 2), 2)


# Can also be used in rxode2:
r &lt;- rxode2({
  r1=dPReLU(time, 2)
  r2a=dPReLUa(time, 2)
  ra=dPReLUa1(time, 2)
})

e &lt;- et(c(-1, 0, 1, 2))
rxSolve(r, e)
</code></pre>

<hr>
<h2 id='dReLU'>Derivative of the Rectified Linear Unit (ReLU) Activation Function</h2><span id='topic+dReLU'></span>

<h3>Description</h3>

<p>This function applies the derivative of the Rectified Linear Unit
(ReLU) activation function to the input numeric vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dReLU(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dReLU_+3A_x">x</code></td>
<td>
<p>A numeric vector. All elements must be finite and
non-missing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector where the derivative of the ReLU function
</p>


<h3>See Also</h3>

<p>Other Activation Functions: 
<code><a href="#topic+ELU">ELU</a>()</code>,
<code><a href="#topic+GELU">GELU</a>()</code>,
<code><a href="#topic+PReLU">PReLU</a>()</code>,
<code><a href="#topic+ReLU">ReLU</a>()</code>,
<code><a href="#topic+SELU">SELU</a>()</code>,
<code><a href="#topic+Swish">Swish</a>()</code>,
<code><a href="#topic+dELU">dELU</a>()</code>,
<code><a href="#topic+dGELU">dGELU</a>()</code>,
<code><a href="#topic+dPReLU">dPReLU</a>()</code>,
<code><a href="#topic+dSELU">dSELU</a>()</code>,
<code><a href="#topic+dSwish">dSwish</a>()</code>,
<code><a href="#topic+dlReLU">dlReLU</a>()</code>,
<code><a href="#topic+dsoftplus">dsoftplus</a>()</code>,
<code><a href="#topic+lReLU">lReLU</a>()</code>,
<code><a href="#topic+softplus">softplus</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dReLU(c(-1, 0, 1, 2))

# Can also be used in rxode2:
x &lt;- rxode2({
   r=dReLU(time)
})

e &lt;- et(c(-1, 0, 1, 2))

rxSolve(x, e)
</code></pre>

<hr>
<h2 id='dSELU'>Derivative of the Scaled Exponential Linear Unit (SELU) Activation Function</h2><span id='topic+dSELU'></span>

<h3>Description</h3>

<p>Derivative of the Scaled Exponential Linear Unit (SELU) Activation Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dSELU(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dSELU_+3A_x">x</code></td>
<td>
<p>A numeric vector. All elements must be finite and
non-missing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector where the derivative of the SELU function
has been applied to each element of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>


<h3>See Also</h3>

<p>Other Activation Functions: 
<code><a href="#topic+ELU">ELU</a>()</code>,
<code><a href="#topic+GELU">GELU</a>()</code>,
<code><a href="#topic+PReLU">PReLU</a>()</code>,
<code><a href="#topic+ReLU">ReLU</a>()</code>,
<code><a href="#topic+SELU">SELU</a>()</code>,
<code><a href="#topic+Swish">Swish</a>()</code>,
<code><a href="#topic+dELU">dELU</a>()</code>,
<code><a href="#topic+dGELU">dGELU</a>()</code>,
<code><a href="#topic+dPReLU">dPReLU</a>()</code>,
<code><a href="#topic+dReLU">dReLU</a>()</code>,
<code><a href="#topic+dSwish">dSwish</a>()</code>,
<code><a href="#topic+dlReLU">dlReLU</a>()</code>,
<code><a href="#topic+dsoftplus">dsoftplus</a>()</code>,
<code><a href="#topic+lReLU">lReLU</a>()</code>,
<code><a href="#topic+softplus">softplus</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dSELU(c(-1, 0, 1, 2))
# Can also be used in rxode2:
x &lt;- rxode2({
  r=dSELU(time)
})
e &lt;- et(c(-1, 0, 1, 2))
rxSolve(x, e)
</code></pre>

<hr>
<h2 id='dsoftplus'>Default Softplus Activation Function</h2><span id='topic+dsoftplus'></span><span id='topic+d2softplus'></span><span id='topic+d3softplus'></span><span id='topic+d4softplus'></span>

<h3>Description</h3>

<p>Default Softplus Activation Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dsoftplus(x)

d2softplus(x)

d3softplus(x)

d4softplus(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dsoftplus_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>See Also</h3>

<p>Other Activation Functions: 
<code><a href="#topic+ELU">ELU</a>()</code>,
<code><a href="#topic+GELU">GELU</a>()</code>,
<code><a href="#topic+PReLU">PReLU</a>()</code>,
<code><a href="#topic+ReLU">ReLU</a>()</code>,
<code><a href="#topic+SELU">SELU</a>()</code>,
<code><a href="#topic+Swish">Swish</a>()</code>,
<code><a href="#topic+dELU">dELU</a>()</code>,
<code><a href="#topic+dGELU">dGELU</a>()</code>,
<code><a href="#topic+dPReLU">dPReLU</a>()</code>,
<code><a href="#topic+dReLU">dReLU</a>()</code>,
<code><a href="#topic+dSELU">dSELU</a>()</code>,
<code><a href="#topic+dSwish">dSwish</a>()</code>,
<code><a href="#topic+dlReLU">dlReLU</a>()</code>,
<code><a href="#topic+lReLU">lReLU</a>()</code>,
<code><a href="#topic+softplus">softplus</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dsoftplus(c(-1, 0, 1, 2))

# You can use rxode2 too:

r &lt;- rxode2({
 s1 &lt;- dsoftplus(time)
})

e &lt;- et(c(-1, 0, 1, 2))

rxSolve(r, e)

</code></pre>

<hr>
<h2 id='dSwish'>Derivative of the Swish Activation Function</h2><span id='topic+dSwish'></span>

<h3>Description</h3>

<p>Derivative of the Swish Activation Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dSwish(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dSwish_+3A_x">x</code></td>
<td>
<p>A numeric vector. All elements must be finite and
non-missing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector where the derivative of the SELU function
has been applied to each element of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>


<h3>See Also</h3>

<p>Other Activation Functions: 
<code><a href="#topic+ELU">ELU</a>()</code>,
<code><a href="#topic+GELU">GELU</a>()</code>,
<code><a href="#topic+PReLU">PReLU</a>()</code>,
<code><a href="#topic+ReLU">ReLU</a>()</code>,
<code><a href="#topic+SELU">SELU</a>()</code>,
<code><a href="#topic+Swish">Swish</a>()</code>,
<code><a href="#topic+dELU">dELU</a>()</code>,
<code><a href="#topic+dGELU">dGELU</a>()</code>,
<code><a href="#topic+dPReLU">dPReLU</a>()</code>,
<code><a href="#topic+dReLU">dReLU</a>()</code>,
<code><a href="#topic+dSELU">dSELU</a>()</code>,
<code><a href="#topic+dlReLU">dlReLU</a>()</code>,
<code><a href="#topic+dsoftplus">dsoftplus</a>()</code>,
<code><a href="#topic+lReLU">lReLU</a>()</code>,
<code><a href="#topic+softplus">softplus</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dSwish(c(-1, 0, 1, 2))

# Can also be used in rxode2:
x &lt;- rxode2({
  r &lt;- dSwish(time)
})
e &lt;- et(c(-1, 0, 1, 2))
rxSolve(x, e)
</code></pre>

<hr>
<h2 id='ELU'>Exponential Linear Unit (ELU) Activation Function</h2><span id='topic+ELU'></span>

<h3>Description</h3>

<p>Exponential Linear Unit (ELU) Activation Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ELU(x, alpha = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ELU_+3A_x">x</code></td>
<td>
<p>A numeric vector. All elements must be finite and
non-missing.</p>
</td></tr>
<tr><td><code id="ELU_+3A_alpha">alpha</code></td>
<td>
<p>A numeric scalar. All elements must be finite and
non-missing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector where the ReLU function has been applied
to each element of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>


<h3>See Also</h3>

<p>Other Activation Functions: 
<code><a href="#topic+GELU">GELU</a>()</code>,
<code><a href="#topic+PReLU">PReLU</a>()</code>,
<code><a href="#topic+ReLU">ReLU</a>()</code>,
<code><a href="#topic+SELU">SELU</a>()</code>,
<code><a href="#topic+Swish">Swish</a>()</code>,
<code><a href="#topic+dELU">dELU</a>()</code>,
<code><a href="#topic+dGELU">dGELU</a>()</code>,
<code><a href="#topic+dPReLU">dPReLU</a>()</code>,
<code><a href="#topic+dReLU">dReLU</a>()</code>,
<code><a href="#topic+dSELU">dSELU</a>()</code>,
<code><a href="#topic+dSwish">dSwish</a>()</code>,
<code><a href="#topic+dlReLU">dlReLU</a>()</code>,
<code><a href="#topic+dsoftplus">dsoftplus</a>()</code>,
<code><a href="#topic+lReLU">lReLU</a>()</code>,
<code><a href="#topic+softplus">softplus</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ELU(c(-1, 0, 1, 2), 2)

# Can also be used in rxode2:
x &lt;- rxode2({
   r=SELU(time)
})

e &lt;- et(c(-1, 0, 1, 2))

rxSolve(x, e)

</code></pre>

<hr>
<h2 id='erf'>Error function</h2><span id='topic+erf'></span>

<h3>Description</h3>

<p>Error function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>erf(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="erf_+3A_x">x</code></td>
<td>
<p>vector or real values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>erf of x
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>erf(1.0)
</code></pre>

<hr>
<h2 id='et'>Event Table Function</h2><span id='topic+et'></span><span id='topic+et.rxode2'></span><span id='topic+et.function'></span><span id='topic+et.rxUi'></span><span id='topic+et.rxSolve'></span><span id='topic+et.rxParams'></span><span id='topic+et.default'></span>

<h3>Description</h3>

<p>Event Table Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>et(x, ..., envir = parent.frame())

## S3 method for class 'rxode2'
et(x, ..., envir = parent.frame())

## S3 method for class ''function''
et(x, ..., envir = parent.frame())

## S3 method for class 'rxUi'
et(x, ..., envir = parent.frame())

## S3 method for class 'rxSolve'
et(x, ..., envir = parent.frame())

## S3 method for class 'rxParams'
et(x, ..., envir = parent.frame())

## Default S3 method:
et(
  x,
  ...,
  time,
  amt,
  evid,
  cmt,
  ii,
  addl,
  ss,
  rate,
  dur,
  until,
  id,
  amountUnits,
  timeUnits,
  addSampling,
  envir = parent.frame(),
  by = NULL,
  length.out = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="et_+3A_x">x</code></td>
<td>
<p>This is the first argument supplied to the event table.
This is named to allow <code>et</code> to be used in a pipe-line
with arbitrary objects.</p>
</td></tr>
<tr><td><code id="et_+3A_...">...</code></td>
<td>
<p>Times or event tables.  They can also be one of the named arguments below.</p>
</td></tr>
<tr><td><code id="et_+3A_envir">envir</code></td>
<td>
<p>the <code><a href="base.html#topic+environment">environment</a></code> in which <code>expr</code> is to
be evaluated.  May also be <code>NULL</code>, a list, a data frame,
a pairlist or an integer as specified to <code><a href="base.html#topic+sys.call">sys.call</a></code>.</p>
</td></tr>
<tr><td><code id="et_+3A_time">time</code></td>
<td>
<p>Time is the time of the dose or the sampling times.
This can also be unspecified and is determined by the object
type (list or numeric/integer).</p>
</td></tr>
<tr><td><code id="et_+3A_amt">amt</code></td>
<td>
<p>Amount of the dose. If specified, this assumes a dosing
record, instead of a sampling record.</p>
</td></tr>
<tr><td><code id="et_+3A_evid">evid</code></td>
<td>
<p>Event ID; This can be:</p>

<table>
<tr>
 <td style="text-align: left;">
   Numeric Value </td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: left;">
   0 </td><td style="text-align: left;"> An observation. This can also be specified as <code>evid=obs</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   1 </td><td style="text-align: left;"> A dose observation.  This can also be specified as <code>evid=dose</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   2 </td><td style="text-align: left;"> A non-dose event. This can also be specified as <code>evid=other</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   3 </td><td style="text-align: left;"> A reset event.  This can also be specified as <code>evid=reset</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
   4 </td><td style="text-align: left;"> Dose and reset event.  This can also be specified as <code>evid=doseReset</code> or <code>evid=resetDose</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Note a reset event resets all the compartment values to zero and turns off all infusions.</p>
</td></tr>
<tr><td><code id="et_+3A_cmt">cmt</code></td>
<td>
<p>Compartment name or number.  If a number, this is an
integer starting at 1.  Negative compartments turn off a
compartment. If the compartment is a name, the compartment name
is changed to the correct state/compartment number before
running the simulation.  For a compartment named &quot;-cmt&quot; the
compartment is turned off.
</p>
<div class="sourceCode"><pre>Can also specify `cmt` as `dosing.to`,
`dose.to`, `doseTo`, `dosingTo`, and
`state`.
</pre></div></td></tr>
<tr><td><code id="et_+3A_ii">ii</code></td>
<td>
<p>When specifying a dose, this is the inter-dose interval
for <code>ss</code>, <code>addl</code> and <code>until</code> options (described below).</p>
</td></tr>
<tr><td><code id="et_+3A_addl">addl</code></td>
<td>
<p>The number of additional doses at a inter-dose
interval after one dose.</p>
</td></tr>
<tr><td><code id="et_+3A_ss">ss</code></td>
<td>
<p>Steady state flag;  It can be one of:</p>

<table>
<tr>
 <td style="text-align: left;">
   Value </td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: left;">
   0 </td><td style="text-align: left;"> This dose is not a steady state dose </td>
</tr>
<tr>
 <td style="text-align: left;">
   1 </td><td style="text-align: left;"> This dose is a steady state dose with the between/inter-dose interval of <code>ii</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   2 </td><td style="text-align: left;"> Superposition steady state </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>When <code>ss=2</code> the steady state dose that uses the super-position
principle to allow more complex steady states, like 10 mg in the
morning and 20 mg at night, or dosing at 8 am 12 pm and 8 pm
instead of every 12 hours.  Since it uses the super positioning
principle, it only makes sense when you know the kinetics are
linear.
</p>
<p>All other values of <code>SS</code> are currently invalid.</p>
</td></tr>
<tr><td><code id="et_+3A_rate">rate</code></td>
<td>
<p>When positive, this is the rate of infusion.  Otherwise:</p>

<table>
<tr>
 <td style="text-align: left;">
   Value </td><td style="text-align: left;"> Description </td>
</tr>
<tr>
 <td style="text-align: left;">
   0 </td><td style="text-align: left;"> No infusion is on this record </td>
</tr>
<tr>
 <td style="text-align: left;">
   -1 </td><td style="text-align: left;"> Modeled rate (in rxode2:<code style="white-space: pre;">&#8288;rate(cmt) =&#8288;</code>); Can be <code>et(rate=model)</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
   -2 </td><td style="text-align: left;"> Modeled duration (in rxode2: <code style="white-space: pre;">&#8288;dur(cmt) =&#8288;</code>); Can be<code>et(dur=model)</code> or <code>et(rate=dur)</code>. </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>When a modeled bioavailability is applied to positive rates
(<code>rate</code> &gt; 0), the duration of infusion is changed. This is
because the data specify the rate and amount, the only think that
modeled bioavailability can affect is duration.
</p>
<p>If instead you want the modeled bioavailability to increase the
rate of infusion instead of the duration of infusion, specify the
<code>dur</code> instead or model the duration with <code>rate=2</code>.</p>
</td></tr>
<tr><td><code id="et_+3A_dur">dur</code></td>
<td>
<p>Duration of infusion.  When <code>amt</code> and <code>dur</code>
are specified the rate is calculated from the two data items.
When <code>dur</code> is specified instead of <code>rate</code>, the
bioavailability changes will increase rate instead of
duration.</p>
</td></tr>
<tr><td><code id="et_+3A_until">until</code></td>
<td>
<p>This is the time until the dosing should end.  It can
be an easier way to figure out how many additional doses are
needed over your sampling period.</p>
</td></tr>
<tr><td><code id="et_+3A_id">id</code></td>
<td>
<p>A integer vector of IDs to add or remove from the event
table.  If the event table is identical for each ID, then you
may expand it to include all the IDs in this vector.  All the
negative IDs in this vector will be removed.</p>
</td></tr>
<tr><td><code id="et_+3A_amountunits">amountUnits</code></td>
<td>
<p>The units for the dosing records (<code>amt</code>)</p>
</td></tr>
<tr><td><code id="et_+3A_timeunits">timeUnits</code></td>
<td>
<p>The units for the time records (<code>time</code>)</p>
</td></tr>
<tr><td><code id="et_+3A_addsampling">addSampling</code></td>
<td>
<p>This is a boolean indicating if a sampling time
should be added at the same time as a dosing time.  By default
this is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="et_+3A_by">by</code></td>
<td>
<p>number: increment of the sequence.</p>
</td></tr>
<tr><td><code id="et_+3A_length.out">length.out</code></td>
<td>
<p>desired length of the sequence.  A
non-negative number, which for <code>seq</code> and <code>seq.int</code> will be
rounded up if fractional.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new event table
</p>


<h3>Author(s)</h3>

<p>Matthew L Fidler, Wenping Wang
</p>


<h3>References</h3>

<p>Wang W, Hallow K, James D (2015). &quot;A Tutorial on rxode2: Simulating
Differential Equation Pharmacometric Models in R.&quot; CPT:
Pharmacometrics and Systems Pharmacology, 5(1), 3-10. ISSN 2163-8306
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eventTable">eventTable</a></code>, <code><a href="#topic+add.sampling">add.sampling</a></code>,
<code><a href="#topic+add.dosing">add.dosing</a></code>, <code><a href="#topic+et">et</a></code>,
<code><a href="#topic+etRep">etRep</a></code>, <code><a href="#topic+etRbind">etRbind</a></code>,
<code><a href="#topic+rxode2">rxode2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

library(rxode2)
library(units)

# Model from rxode2 tutorial
# Using a nlmixr2 style function

mod1 &lt;-function(){
  ini({
    KA &lt;- 2.94E-01
    CL &lt;- 1.86E+01
    V2 &lt;- 4.02E+01
    Q &lt;- 1.05E+01
    V3 &lt;- 2.97E+02
    Kin &lt;- 1
    Kout &lt;- 1
    EC50 &lt;- 200
  })
 model({
    C2 &lt;- centr/V2
    C3 &lt;- peri/V3
    d/dt(depot) &lt;- -KA*depot
    d/dt(centr) &lt;- KA*depot - CL*C2 - Q*C2 + Q*C3
    d/dt(peri)  &lt;-                    Q*C2 - Q*C3
    d/dt(eff)   &lt;- Kin - Kout*(1-C2/(EC50+C2))*eff
 })
}

## These are making the more complex regimens of the rxode2 tutorial

## bid for 5 days
bid &lt;- et(timeUnits="hr") |&gt;
       et(amt=10000,ii=12,until=set_units(5, "days"))

## qd for 5 days
qd &lt;- et(timeUnits="hr") |&gt;
      et(amt=20000,ii=24,until=set_units(5, "days"))

## bid for 5 days followed by qd for 5 days

et &lt;- seq(bid,qd) |&gt;
      et(seq(0,11*24,length.out=100))

bidQd &lt;- rxSolve(mod1, et)

plot(bidQd, C2)


## Now Infusion for 5 days followed by oral for 5 days

##  note you can dose to a named compartment instead of using the compartment number
infusion &lt;- et(timeUnits = "hr") |&gt;
      et(amt=10000, rate=5000, ii=24, until=set_units(5, "days"), cmt="centr")


qd &lt;- et(timeUnits = "hr") |&gt;
  et(amt=10000, ii=24, until=set_units(5, "days"), cmt="depot")

et &lt;- seq(infusion,qd)

infusionQd &lt;- rxSolve(mod1, et)

plot(infusionQd, C2)

## 2wk-on, 1wk-off

qd &lt;- et(timeUnits = "hr") |&gt;
      et(amt=10000, ii=24, until=set_units(2, "weeks"), cmt="depot")

et &lt;- seq(qd, set_units(1,"weeks"), qd) |&gt;
     add.sampling(set_units(seq(0, 5.5,by=0.005),weeks))

wkOnOff &lt;- rxSolve(mod1, et)

plot(wkOnOff, C2)

## You can also repeat the cycle easily with the rep function

qd &lt;-et(timeUnits = "hr") |&gt;
     et(amt=10000, ii=24, until=set_units(2, "weeks"), cmt="depot")

et &lt;- etRep(qd, times=4, wait=set_units(1,"weeks")) |&gt;
      add.sampling(set_units(seq(0, 12.5,by=0.005),weeks))

repCycle4 &lt;- rxSolve(mod1, et)

plot(repCycle4, C2)


## End(Not run)
</code></pre>

<hr>
<h2 id='etExpand'>Expand additional doses</h2><span id='topic+etExpand'></span>

<h3>Description</h3>

<p>Expand additional doses
</p>


<h3>Usage</h3>

<pre><code class='language-R'>etExpand(et)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="etExpand_+3A_et">et</code></td>
<td>
<p>Event table to expand additional doses for.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>New event table with <code>addl</code> doses expanded
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ev &lt;- et(amt = 3, ii = 24, until = 240)
print(ev)
etExpand(ev) # expands event table, but doesn't modify it

print(ev)

ev$expand() ## Expands the current event table and saves it in ev
</code></pre>

<hr>
<h2 id='etRbind'>Combining event tables</h2><span id='topic+etRbind'></span><span id='topic+rbind.rxEt'></span>

<h3>Description</h3>

<p>Combining event tables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>etRbind(
  ...,
  samples = c("use", "clear"),
  waitII = c("smart", "+ii"),
  id = c("merge", "unique")
)

## S3 method for class 'rxEt'
rbind(..., deparse.level = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="etRbind_+3A_...">...</code></td>
<td>
<p>The event tables and optionally time between event
tables, called waiting times in this help document.</p>
</td></tr>
<tr><td><code id="etRbind_+3A_samples">samples</code></td>
<td>
<p>How to handle samples when repeating an event
table.  The options are:
</p>

<ul>
<li> <p><code>"clear"</code> Clear sampling records before combining the datasets
</p>
</li>
<li> <p><code>"use"</code> Use the sampling records when combining the datasets
</p>
</li></ul>
</td></tr>
<tr><td><code id="etRbind_+3A_waitii">waitII</code></td>
<td>
<p>This determines how waiting times between events are
handled. The options are:
</p>

<ul>
<li> <p><code>"smart"</code> This &quot;smart&quot; handling of waiting times is the
default option.  In this case, if the waiting time is above the
last observed inter-dose interval in the first combined event
table, then the actual time between doses is given by the wait
time.  If it is smaller than the last observed inter-dose
interval, the time between event tables is given by the inter-dose
interval + the waiting time between event tables.
</p>
</li>
<li> <p><code>"+ii"</code> In this case, the wait time is added to the
inter-dose interval no matter the length of the wait time or
inter-dose interval
</p>
</li></ul>
</td></tr>
<tr><td><code id="etRbind_+3A_id">id</code></td>
<td>
<p>This is how rbind will handle IDs.  There are two different types of options:
</p>

<ul>
<li> <p><code>merge</code> with <code>id="merge"</code>, the IDs are merged together,
overlapping IDs would be merged into a single event table.
</p>
</li>
<li> <p><code>unique</code> with <code>id="unique"</code>, the IDs will be renumbered
so that the IDs in all the event tables are not overlapping.
</p>
</li></ul>
</td></tr>
<tr><td><code id="etRbind_+3A_deparse.level">deparse.level</code></td>
<td>
<p>The <code>deparse.level</code> of a traditional
<code>rbind</code> is ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An event table
</p>


<h3>Author(s)</h3>

<p>Matthew L Fidler
</p>
<p>Matthew L Fidler, Wenping Wang
</p>


<h3>References</h3>

<p>Wang W, Hallow K, James D (2015). &quot;A Tutorial on rxode2: Simulating
Differential Equation Pharmacometric Models in R.&quot; CPT:
Pharmacometrics and Systems Pharmacology, 5(1), 3-10. ISSN 2163-8306
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eventTable">eventTable</a></code>, <code><a href="#topic+add.sampling">add.sampling</a></code>,
<code><a href="#topic+add.dosing">add.dosing</a></code>, <code><a href="#topic+et">et</a></code>,
<code><a href="#topic+etRep">etRep</a></code>, <code><a href="#topic+etRbind">etRbind</a></code>,
<code><a href="#topic+rxode2">rxode2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

library(rxode2)
library(units)

# Model from rxode2 tutorial
# Using a nlmixr2 style function

mod1 &lt;-function(){
  ini({
    KA &lt;- 2.94E-01
    CL &lt;- 1.86E+01
    V2 &lt;- 4.02E+01
    Q &lt;- 1.05E+01
    V3 &lt;- 2.97E+02
    Kin &lt;- 1
    Kout &lt;- 1
    EC50 &lt;- 200
  })
 model({
    C2 &lt;- centr/V2
    C3 &lt;- peri/V3
    d/dt(depot) &lt;- -KA*depot
    d/dt(centr) &lt;- KA*depot - CL*C2 - Q*C2 + Q*C3
    d/dt(peri)  &lt;-                    Q*C2 - Q*C3
    d/dt(eff)   &lt;- Kin - Kout*(1-C2/(EC50+C2))*eff
 })
}

## These are making the more complex regimens of the rxode2 tutorial

## bid for 5 days
bid &lt;- et(timeUnits="hr") |&gt;
       et(amt=10000,ii=12,until=set_units(5, "days"))

## qd for 5 days
qd &lt;- et(timeUnits="hr") |&gt;
      et(amt=20000,ii=24,until=set_units(5, "days"))

## bid for 5 days followed by qd for 5 days

et &lt;- seq(bid,qd) |&gt;
      et(seq(0,11*24,length.out=100))

bidQd &lt;- rxSolve(mod1, et)

plot(bidQd, C2)


## Now Infusion for 5 days followed by oral for 5 days

##  note you can dose to a named compartment instead of using the compartment number
infusion &lt;- et(timeUnits = "hr") |&gt;
      et(amt=10000, rate=5000, ii=24, until=set_units(5, "days"), cmt="centr")


qd &lt;- et(timeUnits = "hr") |&gt;
  et(amt=10000, ii=24, until=set_units(5, "days"), cmt="depot")

et &lt;- seq(infusion,qd)

infusionQd &lt;- rxSolve(mod1, et)

plot(infusionQd, C2)

## 2wk-on, 1wk-off

qd &lt;- et(timeUnits = "hr") |&gt;
      et(amt=10000, ii=24, until=set_units(2, "weeks"), cmt="depot")

et &lt;- seq(qd, set_units(1,"weeks"), qd) |&gt;
     add.sampling(set_units(seq(0, 5.5,by=0.005),weeks))

wkOnOff &lt;- rxSolve(mod1, et)

plot(wkOnOff, C2)

## You can also repeat the cycle easily with the rep function

qd &lt;-et(timeUnits = "hr") |&gt;
     et(amt=10000, ii=24, until=set_units(2, "weeks"), cmt="depot")

et &lt;- etRep(qd, times=4, wait=set_units(1,"weeks")) |&gt;
      add.sampling(set_units(seq(0, 12.5,by=0.005),weeks))

repCycle4 &lt;- rxSolve(mod1, et)

plot(repCycle4, C2)


## End(Not run)
</code></pre>

<hr>
<h2 id='etRep'>Repeat an rxode2 event table</h2><span id='topic+etRep'></span><span id='topic+rep.rxEt'></span>

<h3>Description</h3>

<p>Repeat an rxode2 event table
</p>


<h3>Usage</h3>

<pre><code class='language-R'>etRep(
  x,
  times = 1,
  length.out = NA,
  each = NA,
  n = NULL,
  wait = 0,
  id = integer(0),
  samples = c("clear", "use"),
  waitII = c("smart", "+ii"),
  ii = 24
)

## S3 method for class 'rxEt'
rep(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="etRep_+3A_x">x</code></td>
<td>
<p>An rxode2 event table</p>
</td></tr>
<tr><td><code id="etRep_+3A_times">times</code></td>
<td>
<p>Number of times to repeat the event table</p>
</td></tr>
<tr><td><code id="etRep_+3A_length.out">length.out</code></td>
<td>
<p>Invalid with rxode2 event tables, will throw an
error if used.</p>
</td></tr>
<tr><td><code id="etRep_+3A_each">each</code></td>
<td>
<p>Invalid with rxode2 event tables, will throw an error
if used.</p>
</td></tr>
<tr><td><code id="etRep_+3A_n">n</code></td>
<td>
<p>The number of times to repeat the event table.  Overrides
<code>times</code>.</p>
</td></tr>
<tr><td><code id="etRep_+3A_wait">wait</code></td>
<td>
<p>Waiting time between each repeated event table.  By
default there is no waiting, or wait=0</p>
</td></tr>
<tr><td><code id="etRep_+3A_id">id</code></td>
<td>
<p>A integer vector of IDs to add or remove from the event
table.  If the event table is identical for each ID, then you
may expand it to include all the IDs in this vector.  All the
negative IDs in this vector will be removed.</p>
</td></tr>
<tr><td><code id="etRep_+3A_samples">samples</code></td>
<td>
<p>How to handle samples when repeating an event
table.  The options are:
</p>

<ul>
<li> <p><code>"clear"</code> Clear sampling records before combining the datasets
</p>
</li>
<li> <p><code>"use"</code> Use the sampling records when combining the datasets
</p>
</li></ul>
</td></tr>
<tr><td><code id="etRep_+3A_waitii">waitII</code></td>
<td>
<p>This determines how waiting times between events are
handled. The options are:
</p>

<ul>
<li> <p><code>"smart"</code> This &quot;smart&quot; handling of waiting times is the
default option.  In this case, if the waiting time is above the
last observed inter-dose interval in the first combined event
table, then the actual time between doses is given by the wait
time.  If it is smaller than the last observed inter-dose
interval, the time between event tables is given by the inter-dose
interval + the waiting time between event tables.
</p>
</li>
<li> <p><code>"+ii"</code> In this case, the wait time is added to the
inter-dose interval no matter the length of the wait time or
inter-dose interval
</p>
</li></ul>
</td></tr>
<tr><td><code id="etRep_+3A_ii">ii</code></td>
<td>
<p>When specifying a dose, this is the inter-dose interval
for <code>ss</code>, <code>addl</code> and <code>until</code> options (described below).</p>
</td></tr>
<tr><td><code id="etRep_+3A_...">...</code></td>
<td>
<p>Times or event tables.  They can also be one of the named arguments below.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An event table
</p>


<h3>Author(s)</h3>

<p>Matthew L Fidler, Wenping Wang
</p>


<h3>References</h3>

<p>Wang W, Hallow K, James D (2015). &quot;A Tutorial on rxode2: Simulating
Differential Equation Pharmacometric Models in R.&quot; CPT:
Pharmacometrics and Systems Pharmacology, 5(1), 3-10. ISSN 2163-8306
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eventTable">eventTable</a></code>, <code><a href="#topic+add.sampling">add.sampling</a></code>,
<code><a href="#topic+add.dosing">add.dosing</a></code>, <code><a href="#topic+et">et</a></code>,
<code><a href="#topic+etRep">etRep</a></code>, <code><a href="#topic+etRbind">etRbind</a></code>,
<code><a href="#topic+rxode2">rxode2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

library(rxode2)
library(units)

# Model from rxode2 tutorial
# Using a nlmixr2 style function

mod1 &lt;-function(){
  ini({
    KA &lt;- 2.94E-01
    CL &lt;- 1.86E+01
    V2 &lt;- 4.02E+01
    Q &lt;- 1.05E+01
    V3 &lt;- 2.97E+02
    Kin &lt;- 1
    Kout &lt;- 1
    EC50 &lt;- 200
  })
 model({
    C2 &lt;- centr/V2
    C3 &lt;- peri/V3
    d/dt(depot) &lt;- -KA*depot
    d/dt(centr) &lt;- KA*depot - CL*C2 - Q*C2 + Q*C3
    d/dt(peri)  &lt;-                    Q*C2 - Q*C3
    d/dt(eff)   &lt;- Kin - Kout*(1-C2/(EC50+C2))*eff
 })
}

## These are making the more complex regimens of the rxode2 tutorial

## bid for 5 days
bid &lt;- et(timeUnits="hr") |&gt;
       et(amt=10000,ii=12,until=set_units(5, "days"))

## qd for 5 days
qd &lt;- et(timeUnits="hr") |&gt;
      et(amt=20000,ii=24,until=set_units(5, "days"))

## bid for 5 days followed by qd for 5 days

et &lt;- seq(bid,qd) |&gt;
      et(seq(0,11*24,length.out=100))

bidQd &lt;- rxSolve(mod1, et)

plot(bidQd, C2)


## Now Infusion for 5 days followed by oral for 5 days

##  note you can dose to a named compartment instead of using the compartment number
infusion &lt;- et(timeUnits = "hr") |&gt;
      et(amt=10000, rate=5000, ii=24, until=set_units(5, "days"), cmt="centr")


qd &lt;- et(timeUnits = "hr") |&gt;
  et(amt=10000, ii=24, until=set_units(5, "days"), cmt="depot")

et &lt;- seq(infusion,qd)

infusionQd &lt;- rxSolve(mod1, et)

plot(infusionQd, C2)

## 2wk-on, 1wk-off

qd &lt;- et(timeUnits = "hr") |&gt;
      et(amt=10000, ii=24, until=set_units(2, "weeks"), cmt="depot")

et &lt;- seq(qd, set_units(1,"weeks"), qd) |&gt;
     add.sampling(set_units(seq(0, 5.5,by=0.005),weeks))

wkOnOff &lt;- rxSolve(mod1, et)

plot(wkOnOff, C2)

## You can also repeat the cycle easily with the rep function

qd &lt;-et(timeUnits = "hr") |&gt;
     et(amt=10000, ii=24, until=set_units(2, "weeks"), cmt="depot")

et &lt;- etRep(qd, times=4, wait=set_units(1,"weeks")) |&gt;
      add.sampling(set_units(seq(0, 12.5,by=0.005),weeks))

repCycle4 &lt;- rxSolve(mod1, et)

plot(repCycle4, C2)


## End(Not run)
</code></pre>

<hr>
<h2 id='etSeq'>Sequence of event tables</h2><span id='topic+etSeq'></span><span id='topic+seq.rxEt'></span>

<h3>Description</h3>

<p>This combines a sequence of event tables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>etSeq(..., samples = c("clear", "use"), waitII = c("smart", "+ii"), ii = 24)

## S3 method for class 'rxEt'
seq(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="etSeq_+3A_...">...</code></td>
<td>
<p>The event tables and optionally time between event
tables, called waiting times in this help document.</p>
</td></tr>
<tr><td><code id="etSeq_+3A_samples">samples</code></td>
<td>
<p>How to handle samples when repeating an event
table.  The options are:
</p>

<ul>
<li> <p><code>"clear"</code> Clear sampling records before combining the datasets
</p>
</li>
<li> <p><code>"use"</code> Use the sampling records when combining the datasets
</p>
</li></ul>
</td></tr>
<tr><td><code id="etSeq_+3A_waitii">waitII</code></td>
<td>
<p>This determines how waiting times between events are
handled. The options are:
</p>

<ul>
<li> <p><code>"smart"</code> This &quot;smart&quot; handling of waiting times is the
default option.  In this case, if the waiting time is above the
last observed inter-dose interval in the first combined event
table, then the actual time between doses is given by the wait
time.  If it is smaller than the last observed inter-dose
interval, the time between event tables is given by the inter-dose
interval + the waiting time between event tables.
</p>
</li>
<li> <p><code>"+ii"</code> In this case, the wait time is added to the
inter-dose interval no matter the length of the wait time or
inter-dose interval
</p>
</li></ul>
</td></tr>
<tr><td><code id="etSeq_+3A_ii">ii</code></td>
<td>
<p>If there was no inter-dose intervals found in the event
table, assume that the interdose interval is given by this
<code>ii</code> value.  By default this is <code>24</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This <code>seq</code>uences all the event tables in added in the
argument list <code>...</code>.  By default when combining the event
tables the offset is at least by the last inter-dose interval in
the prior event table (or <code>ii</code>).  If you separate any of the
event tables by a number, the event tables will be separated at
least the wait time defined by that number or the last inter-dose
interval.
</p>


<h3>Value</h3>

<p>An event table
</p>


<h3>Author(s)</h3>

<p>Matthew L Fidler, Wenping Wang
</p>


<h3>References</h3>

<p>Wang W, Hallow K, James D (2015). &quot;A Tutorial on rxode2: Simulating
Differential Equation Pharmacometric Models in R.&quot; CPT:
Pharmacometrics and Systems Pharmacology, 5(1), 3-10. ISSN 2163-8306
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eventTable">eventTable</a></code>, <code><a href="#topic+add.sampling">add.sampling</a></code>,
<code><a href="#topic+add.dosing">add.dosing</a></code>, <code><a href="#topic+et">et</a></code>,
<code><a href="#topic+etRep">etRep</a></code>, <code><a href="#topic+etRbind">etRbind</a></code>,
<code><a href="#topic+rxode2">rxode2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

library(rxode2)
library(units)

# Model from rxode2 tutorial
# Using a nlmixr2 style function

mod1 &lt;-function(){
  ini({
    KA &lt;- 2.94E-01
    CL &lt;- 1.86E+01
    V2 &lt;- 4.02E+01
    Q &lt;- 1.05E+01
    V3 &lt;- 2.97E+02
    Kin &lt;- 1
    Kout &lt;- 1
    EC50 &lt;- 200
  })
 model({
    C2 &lt;- centr/V2
    C3 &lt;- peri/V3
    d/dt(depot) &lt;- -KA*depot
    d/dt(centr) &lt;- KA*depot - CL*C2 - Q*C2 + Q*C3
    d/dt(peri)  &lt;-                    Q*C2 - Q*C3
    d/dt(eff)   &lt;- Kin - Kout*(1-C2/(EC50+C2))*eff
 })
}

## These are making the more complex regimens of the rxode2 tutorial

## bid for 5 days
bid &lt;- et(timeUnits="hr") |&gt;
       et(amt=10000,ii=12,until=set_units(5, "days"))

## qd for 5 days
qd &lt;- et(timeUnits="hr") |&gt;
      et(amt=20000,ii=24,until=set_units(5, "days"))

## bid for 5 days followed by qd for 5 days

et &lt;- seq(bid,qd) |&gt;
      et(seq(0,11*24,length.out=100))

bidQd &lt;- rxSolve(mod1, et)

plot(bidQd, C2)


## Now Infusion for 5 days followed by oral for 5 days

##  note you can dose to a named compartment instead of using the compartment number
infusion &lt;- et(timeUnits = "hr") |&gt;
      et(amt=10000, rate=5000, ii=24, until=set_units(5, "days"), cmt="centr")


qd &lt;- et(timeUnits = "hr") |&gt;
  et(amt=10000, ii=24, until=set_units(5, "days"), cmt="depot")

et &lt;- seq(infusion,qd)

infusionQd &lt;- rxSolve(mod1, et)

plot(infusionQd, C2)

## 2wk-on, 1wk-off

qd &lt;- et(timeUnits = "hr") |&gt;
      et(amt=10000, ii=24, until=set_units(2, "weeks"), cmt="depot")

et &lt;- seq(qd, set_units(1,"weeks"), qd) |&gt;
     add.sampling(set_units(seq(0, 5.5,by=0.005),weeks))

wkOnOff &lt;- rxSolve(mod1, et)

plot(wkOnOff, C2)

## You can also repeat the cycle easily with the rep function

qd &lt;-et(timeUnits = "hr") |&gt;
     et(amt=10000, ii=24, until=set_units(2, "weeks"), cmt="depot")

et &lt;- etRep(qd, times=4, wait=set_units(1,"weeks")) |&gt;
      add.sampling(set_units(seq(0, 12.5,by=0.005),weeks))

repCycle4 &lt;- rxSolve(mod1, et)

plot(repCycle4, C2)


## End(Not run)
</code></pre>

<hr>
<h2 id='etTrans'>Event translation for rxode2</h2><span id='topic+etTrans'></span>

<h3>Description</h3>

<p>Event translation for rxode2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>etTrans(
  inData,
  obj,
  addCmt = FALSE,
  dropUnits = FALSE,
  allTimeVar = FALSE,
  keepDosingOnly = FALSE,
  combineDvid = NULL,
  keep = character(0),
  addlKeepsCov = FALSE,
  addlDropSs = TRUE,
  ssAtDoseTime = TRUE,
  iCov = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="etTrans_+3A_indata">inData</code></td>
<td>
<p>Data frame to translate</p>
</td></tr>
<tr><td><code id="etTrans_+3A_obj">obj</code></td>
<td>
<p>object where model variables can be extracted from</p>
</td></tr>
<tr><td><code id="etTrans_+3A_addcmt">addCmt</code></td>
<td>
<p>Add compartment to data frame (default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="etTrans_+3A_dropunits">dropUnits</code></td>
<td>
<p>Boolean to drop the units (default <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="etTrans_+3A_alltimevar">allTimeVar</code></td>
<td>
<p>Treat all covariates as if they were time-varying</p>
</td></tr>
<tr><td><code id="etTrans_+3A_keepdosingonly">keepDosingOnly</code></td>
<td>
<p>keep the individuals who only have dosing records and any
trailing dosing records after the last observation.</p>
</td></tr>
<tr><td><code id="etTrans_+3A_combinedvid">combineDvid</code></td>
<td>
<p>is a boolean indicating if rxode2 will use <code>DVID</code> on observation
records to change the <code>cmt</code> value; Useful for multiple-endpoint nlmixr models.  By default
this is determined by <code>option("rxode2.combine.dvid")</code> and if the option has not been set,
this is <code>TRUE</code>. This typically does not affect rxode2 simulations.</p>
</td></tr>
<tr><td><code id="etTrans_+3A_keep">keep</code></td>
<td>
<p>This is a named vector of items you want to keep in the final rxode2 dataset.
For added rxode2 event records (if seen), last observation carried forward will be used.</p>
</td></tr>
<tr><td><code id="etTrans_+3A_addlkeepscov">addlKeepsCov</code></td>
<td>
<p>This determines if the additional dosing items
repeats the dose only (<code>FALSE</code>) or keeps the covariates at the
record of the dose (<code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="etTrans_+3A_addldropss">addlDropSs</code></td>
<td>
<p>When there are steady state doses with an <code>addl</code>
specification the steady state flag is dropped with repeated
doses (when <code>TRUE</code>) or retained (when <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="etTrans_+3A_ssatdosetime">ssAtDoseTime</code></td>
<td>
<p>Boolean that when <code>TRUE</code> back calculates the
steady concentration at the actual time of dose, otherwise when
<code>FALSE</code> the doses are shifted</p>
</td></tr>
<tr><td><code id="etTrans_+3A_icov">iCov</code></td>
<td>
<p>A data frame of individual non-time varying covariates
to combine with the <code>events</code> dataset.  The <code>iCov</code> dataset has one
covariate per ID and should match the event table</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object for solving in rxode2
</p>

<hr>
<h2 id='eventTable'>Create an event table object</h2><span id='topic+eventTable'></span>

<h3>Description</h3>

<p>Initializes an object of class &lsquo;EventTable&rsquo; with methods for
adding and querying dosing and observation records
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eventTable(amount.units = NA, time.units = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eventTable_+3A_amount.units">amount.units</code></td>
<td>
<p>string denoting the amount dosing units, e.g.,
&ldquo;mg&rdquo;, &ldquo;ug&rdquo;. Default to <code>NA</code> to denote
unspecified units.  It could also be a solved rxode2 object.  In
that case, eventTable(obj) returns the eventTable that was used
to solve the rxode2 object.</p>
</td></tr>
<tr><td><code id="eventTable_+3A_time.units">time.units</code></td>
<td>
<p>string denoting the time units, e.g.,
&ldquo;hours&rdquo;, &ldquo;days&rdquo;. Default to <code>"hours"</code>.
</p>
<p>An <code>eventTable</code> is an object that consists of a data.frame
storing ordered time-stamped events of an (unspecified) PK/PD
dynamic system, units (strings) for dosing and time records, plus a
list of functions to add and extract event records.
</p>
<p>Currently, events can be of two types: dosing events that represent
inputs to the system and sampling time events that represent
observations of the system with &lsquo;amount.units&rsquo; and
&lsquo;time.units&rsquo;, respectively.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A modified data.frame with the following accessible functions:
</p>

<ul>
<li> <p><code>get.EventTable()</code> returns the current event table
</p>
</li>
<li> <p><code><a href="#topic+add.dosing">add.dosing()</a></code>  adds dosing records to the event table.
</p>
</li>
<li> <p><code>get.dosing()</code> returns a data.frame of dosing records.
</p>
</li>
<li> <p><code>clear.dosing()</code> clears or deletes all dosing from event table
</p>
</li>
<li><p> '<code><a href="#topic+add.sampling">add.sampling()</a></code> adds sampling time observation records to the
event table.
</p>
</li>
<li> <p><code>get.sampling()</code>returns a data.frame of sampled observation records.
</p>
</li>
<li> <p><code>clear.sampling()</code> removes all sampling from event table.
</p>
</li>
<li> <p><code>get.obs.rec()</code> returns a logical vector indicating whether each
event record represents an observation or not.
</p>
</li>
<li> <p><code>get.nobs()</code> returns the number of observation (not dosing) records.
</p>
</li>
<li> <p><code>get.units()</code> returns a two-element character vector with the
dosing and time units, respectively
</p>
</li>
<li> <p><code>copy()</code> makes a copy of the current event table. To create
a copy of an event table object use <code>qd2 &lt;- qd$copy()</code>
</p>
</li>
<li> <p><code>expand()</code> Expands the event table for multi-subject solving.
This is done by <code>qd$expand(400)</code> for a 400 subject data expansion
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Matthew Fidler, Melissa Hallow and Wenping Wang
</p>


<h3>See Also</h3>

<p><code><a href="#topic+et">et()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create dosing and observation (sampling) events
# QD 50mg dosing, 5 days followed by 25mg 5 days
#
qd &lt;- eventTable(amount.units = "mg", time.units = "days")
#
qd$add.dosing(dose = 50, nbr.doses = 5, dosing.interval = 1, do.sampling = FALSE)
#
# sample the system's drug amounts hourly the first day, then every 12 hours
# for the next 4 days
qd$add.sampling(seq(from = 0, to = 1, by = 1 / 24))
qd$add.sampling(seq(from = 1, to = 5, by = 12 / 24))
#
# print(qd$get.dosing())     # table of dosing records
print(qd$get.nobs()) # number of observation (not dosing) records
#
# BID dosing, 5 days
bid &lt;- eventTable("mg", "days") # only dosing
bid$add.dosing(
  dose = 10000, nbr.doses = 2 * 5,
  dosing.interval = 12, do.sampling = FALSE
)
#
# Use the copy() method to create a copy (clone) of an existing
# event table (simple assignments just create a new reference to
# the same event table object (closure)).
#
bid.ext &lt;- bid$copy() # three-day extension for a 2nd cohort
bid.ext$add.dosing(
  dose = 5000, nbr.doses = 2 * 3,
  start.time = 120, dosing.interval = 12, do.sampling = FALSE
)

# You can also use the Piping operator to create a table

qd2 &lt;- eventTable(amount.units = "mg", time.units = "days") %&gt;%
  add.dosing(dose = 50, nbr.doses = 5, dosing.interval = 1, do.sampling = FALSE) %&gt;%
  add.sampling(seq(from = 0, to = 1, by = 1 / 24)) %&gt;%
  add.sampling(seq(from = 1, to = 5, by = 12 / 24))
# print(qd2$get.dosing())     # table of dosing records
print(qd2$get.nobs()) # number of observation (not dosing) records

# Note that piping with %&gt;% will update the original table.

qd3 &lt;- qd2 %&gt;% add.sampling(seq(from = 5, to = 10, by = 6 / 24))
print(qd2$get.nobs())
print(qd3$get.nobs())
</code></pre>

<hr>
<h2 id='findLhs'>Find the assignments in R expression</h2><span id='topic+findLhs'></span>

<h3>Description</h3>

<p>Find the assignments in R expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findLhs(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="findLhs_+3A_x">x</code></td>
<td>
<p>R expression</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of assigned parameters
</p>


<h3>Author(s)</h3>

<p>Hadley Wickham and Matthew L. Fidler
</p>

<hr>
<h2 id='forderForceBase'>Force using base order for rxode2 radix sorting</h2><span id='topic+forderForceBase'></span>

<h3>Description</h3>

<p>Force using base order for rxode2 radix sorting
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forderForceBase(forceBase = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="forderForceBase_+3A_forcebase">forceBase</code></td>
<td>
<p>boolean indicating if rxode2 should use R's
<code><a href="base.html#topic+order">order()</a></code> for radix sorting instead of
<code>data.table</code>'s parallel radix sorting.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>value of <code>forceBase</code> (can change if <code>data.table</code> is not
available)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
forderForceBase(TRUE) # Use base `order` for rxode2 sorts
forderForceBase(FALSE) # Use `data.table` for rxode2 sorts

</code></pre>

<hr>
<h2 id='gammap'>Gammap: normalized lower incomplete gamma function</h2><span id='topic+gammap'></span>

<h3>Description</h3>

<p>This is the gamma_p from the boost library
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gammap(a, z)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gammap_+3A_a">a</code></td>
<td>
<p>The numeric 'a' parameter in the normalized lower
incomplete gamma</p>
</td></tr>
<tr><td><code id="gammap_+3A_z">z</code></td>
<td>
<p>The numeric 'z' parameter in the normalized lower
incomplete gamma</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The gamma p function is given by:
</p>
<p>gammap = lowergamma(a, z)/gamma(a)
</p>


<h3>Value</h3>

<p>gammap results
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gammap(1, 3)
gammap(1:3, 3)
gammap(1, 1:3)
</code></pre>

<hr>
<h2 id='gammapDer'>gammapDer:  derivative of gammap</h2><span id='topic+gammapDer'></span>

<h3>Description</h3>

<p>This is the gamma_p_derivative from the boost library
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gammapDer(a, z)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gammapDer_+3A_a">a</code></td>
<td>
<p>The numeric 'a' parameter in the upper
incomplete gamma</p>
</td></tr>
<tr><td><code id="gammapDer_+3A_z">z</code></td>
<td>
<p>The numeric 'z' parameter in the upper
incomplete gamma</p>
</td></tr>
</table>


<h3>Value</h3>

<p>lowergamma results
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gammapDer(1:3, 3)

gammapDer(1, 1:3)
</code></pre>

<hr>
<h2 id='gammapInv'>gammapInv and gammapInva:  Inverses of normalized gammap function</h2><span id='topic+gammapInv'></span><span id='topic+gammapInva'></span>

<h3>Description</h3>

<p>gammapInv and gammapInva:  Inverses of normalized gammap function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gammapInv(a, p)

gammapInva(x, p)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gammapInv_+3A_a">a</code></td>
<td>
<p>The numeric 'a' parameter in the upper
incomplete gamma</p>
</td></tr>
<tr><td><code id="gammapInv_+3A_p">p</code></td>
<td>
<p>The numeric 'p' parameter in the upper incomplete gamma</p>
</td></tr>
<tr><td><code id="gammapInv_+3A_x">x</code></td>
<td>
<p>The numeric 'x' parameter in the upper incomplete gamma</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With the equation:
</p>
<p>p = gammap(a, x)
</p>
<p>The 'gammapInv' function returns a value 'x' that satisfies the
equation above
</p>
<p>The 'gammapInva' function returns a value 'q' that satisfies the
equation above
</p>
<p>NOTE: gammapInva is slow
</p>


<h3>Value</h3>

<p>inverse gammap results
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gammapInv(1:3, 0.5)

gammapInv(1, 1:3 / 3.1)

gammapInv(1:3, 1:3 / 3.1)

gammapInva(1:3, 1:3 / 3.1)
</code></pre>

<hr>
<h2 id='gammaq'>Gammaq: normalized upper incomplete gamma function</h2><span id='topic+gammaq'></span>

<h3>Description</h3>

<p>This is the gamma_q from the boost library
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gammaq(a, z)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gammaq_+3A_a">a</code></td>
<td>
<p>The numeric 'a' parameter in the normalized upper
incomplete gamma</p>
</td></tr>
<tr><td><code id="gammaq_+3A_z">z</code></td>
<td>
<p>The numeric 'z' parameter in the normalized upper
incomplete gamma</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The gamma q function is given by:
</p>
<p>gammaq = uppergamma(a, z)/gamma(a)
</p>


<h3>Value</h3>

<p>gammaq results
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gammaq(1, 3)
gammaq(1:3, 3)
gammaq(1, 1:3)
</code></pre>

<hr>
<h2 id='gammaqInv'>gammaqInv and gammaqInva:  Inverses of normalized gammaq function</h2><span id='topic+gammaqInv'></span><span id='topic+gammaqInva'></span>

<h3>Description</h3>

<p>gammaqInv and gammaqInva:  Inverses of normalized gammaq function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gammaqInv(a, q)

gammaqInva(x, q)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gammaqInv_+3A_a">a</code></td>
<td>
<p>The numeric 'a' parameter in the upper
incomplete gamma</p>
</td></tr>
<tr><td><code id="gammaqInv_+3A_q">q</code></td>
<td>
<p>The numeric 'q' parameter in the upper
incomplete gamma</p>
</td></tr>
<tr><td><code id="gammaqInv_+3A_x">x</code></td>
<td>
<p>The numeric 'x' parameter in the upper incomplete gamma</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With the equation:
</p>
<p>q = gammaq(a, x)
</p>
<p>The 'gammaqInv' function returns a value 'x' that satisfies the
equation above
</p>
<p>The 'gammaqInva' function returns a value 'a' that satisfies the
equation above
</p>
<p>NOTE: gammaqInva is slow
</p>


<h3>Value</h3>

<p>inverse gammaq results
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gammaqInv(1:3, 0.5)

gammaqInv(1, 1:3 / 3)

gammaqInv(1:3, 1:3 / 3.1)

gammaqInva(1:3, 1:3 / 3.1)
</code></pre>

<hr>
<h2 id='GELU'>GELU activation function</h2><span id='topic+GELU'></span>

<h3>Description</h3>

<p>GELU activation function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GELU(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GELU_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>See Also</h3>

<p>Other Activation Functions: 
<code><a href="#topic+ELU">ELU</a>()</code>,
<code><a href="#topic+PReLU">PReLU</a>()</code>,
<code><a href="#topic+ReLU">ReLU</a>()</code>,
<code><a href="#topic+SELU">SELU</a>()</code>,
<code><a href="#topic+Swish">Swish</a>()</code>,
<code><a href="#topic+dELU">dELU</a>()</code>,
<code><a href="#topic+dGELU">dGELU</a>()</code>,
<code><a href="#topic+dPReLU">dPReLU</a>()</code>,
<code><a href="#topic+dReLU">dReLU</a>()</code>,
<code><a href="#topic+dSELU">dSELU</a>()</code>,
<code><a href="#topic+dSwish">dSwish</a>()</code>,
<code><a href="#topic+dlReLU">dlReLU</a>()</code>,
<code><a href="#topic+dsoftplus">dsoftplus</a>()</code>,
<code><a href="#topic+lReLU">lReLU</a>()</code>,
<code><a href="#topic+softplus">softplus</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
GELU(c(-2, -1, 0, 1, 2))

# you can use rxode2 as well
r &lt;- rxode2({
  r = GELU(time)
})
et &lt;- et(c(-2, -1, 0, 1, 2))
rxSolve(r, et)

</code></pre>

<hr>
<h2 id='genShinyApp.template'>Generate an example (template) of a dosing regimen shiny app</h2><span id='topic+genShinyApp.template'></span><span id='topic+write.template.server'></span><span id='topic+write.template.ui'></span>

<h3>Description</h3>

<p>Create a complete shiny application for exploring dosing regimens
given a (hardcoded) PK/PD model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>genShinyApp.template(
  appDir = "shinyExample",
  verbose = TRUE,
  ODE.config = list(ode = "model", params = c(KA = 0.294), inits = c(eff = 1), method =
    "lsoda", atol = 1e-08, rtol = 1e-06)
)

write.template.server(appDir)

write.template.ui(appDir, statevars)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="genShinyApp.template_+3A_appdir">appDir</code></td>
<td>
<p>a string with a directory where to store the shiny
app, by default is <code>"shinyExample"</code>. The directory
<code>appDir</code> will be created if it does not exist.</p>
</td></tr>
<tr><td><code id="genShinyApp.template_+3A_verbose">verbose</code></td>
<td>
<p>logical specifying whether to write messages as the
shiny app is generated. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="genShinyApp.template_+3A_ode.config">ODE.config</code></td>
<td>
<p>model name compiled and list of parameters sent to <code><a href="#topic+rxSolve">rxSolve()</a></code>.</p>
</td></tr>
<tr><td><code id="genShinyApp.template_+3A_statevars">statevars</code></td>
<td>
<p>List of statevars passed to to the <code><a href="#topic+write.template.ui">write.template.ui()</a></code> function.  This usually isn't called directly.
</p>
<p>A PK/PD model is defined using <code><a href="#topic+rxode2">rxode2()</a></code>, and
a set of parameters and initial values are defined.  Then
the appropriate R scripts for the shiny's user interface <code>ui.R</code>
and the server logic <code>server.R</code> are created in the
directory <code>appDir</code>.
</p>
<p>The function evaluates the following PK/PD model by default:
</p>
<pre>
    C2 = centr/V2;
    C3 = peri/V3;
    d/dt(depot) =-KA*depot;
    d/dt(centr) = KA*depot - CL*C2 - Q*C2 + Q*C3;
    d/dt(peri)  =                    Q*C2 - Q*C3;
    d/dt(eff)  = Kin - Kout*(1-C2/(EC50+C2))*eff;
</pre>
<p>This can be changed by the <code>ODE.config</code> parameter.
</p>
<p>To launch the shiny app, simply issue the <code>runApp(appDir)</code>
R command.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None, these functions are used for their side effects.
</p>


<h3>Note</h3>

<p>These functions create a simple, but working example of a
dosing regimen simulation web application. Users may want to
modify the code to experiment creating shiny applications for
their specific <code>rxode2</code> models.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rxode2">rxode2()</a></code>,<code><a href="#topic+eventTable">eventTable()</a></code>, and the package <span class="pkg">shiny</span> (<a href="https://shiny.posit.co">https://shiny.posit.co</a>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# remove myapp when the example is complete
on.exit(unlink("myapp", recursive = TRUE, force = TRUE))
# create the shiny app example (template)
genShinyApp.template(appDir = "myapp")
# run the shiny app
if (requireNamespace("shiny", quietly=TRUE)) {
  library(shiny)
  # runApp("myapp") # Won't launch in environments without browsers
}

</code></pre>

<hr>
<h2 id='getBaseIniSimModel'>Get the base simulation model for simulation with inis in the
underlying rxode2 model</h2><span id='topic+getBaseIniSimModel'></span>

<h3>Description</h3>

<p>Get the base simulation model for simulation with inis in the
underlying rxode2 model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBaseIniSimModel(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getBaseIniSimModel_+3A_obj">obj</code></td>
<td>
<p>Fit Object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Simulation object
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='getBaseSimModel'>Get the base simulation model for simulation</h2><span id='topic+getBaseSimModel'></span><span id='topic+getBaseSimModel.default'></span><span id='topic+getBaseIniSimModel.default'></span>

<h3>Description</h3>

<p>Get the base simulation model for simulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBaseSimModel(obj)

## Default S3 method:
getBaseSimModel(obj)

## Default S3 method:
getBaseIniSimModel(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getBaseSimModel_+3A_obj">obj</code></td>
<td>
<p>Fit Object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Simulation object
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='getBaseSymengineModel'>Get the symengine for loading into symengine with <code>rxS()</code></h2><span id='topic+getBaseSymengineModel'></span>

<h3>Description</h3>

<p>Get the symengine for loading into symengine with <code>rxS()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getBaseSymengineModel(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getBaseSymengineModel_+3A_obj">obj</code></td>
<td>
<p>Object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Simulation model ready to load into symeng
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='getRxThreads'>Get/Set the number of threads that rxode2 uses</h2><span id='topic+getRxThreads'></span><span id='topic+setRxThreads'></span><span id='topic+rxCores'></span>

<h3>Description</h3>

<p>Get/Set the number of threads that rxode2 uses
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getRxThreads(verbose = FALSE)

setRxThreads(threads = NULL, percent = NULL, throttle = NULL)

rxCores(verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getRxThreads_+3A_verbose">verbose</code></td>
<td>
<p>Display the value of relevant OpenMP settings</p>
</td></tr>
<tr><td><code id="getRxThreads_+3A_threads">threads</code></td>
<td>
<p>NULL (default) rereads environment variables. 0
means to use all logical CPUs available. Otherwise a number &gt;= 1</p>
</td></tr>
<tr><td><code id="getRxThreads_+3A_percent">percent</code></td>
<td>
<p>If provided it should be a number between 2 and
100; the percentage of logical CPUs to use. By default on
startup, 50 percent.</p>
</td></tr>
<tr><td><code id="getRxThreads_+3A_throttle">throttle</code></td>
<td>
<p>2 (default) means that, roughly speaking, a
single thread will be used when number subjects solved for is &lt;=2, 2 threads when
the number of all points is &lt;=4, etc. The throttle is to speed up small data
tasks (especially when repeated many times) by not incurring the
overhead of managing multiple threads.
</p>
<p>The throttle will also suppress sorting which ID will be solved first
when there are (nsubject solved)*throttle &lt;= nthreads.  In
<code>rxode2</code> this sorting occurs to minimize the time for waiting for
another thread to finish. If the last item solved is has a long
solving time, all the other solving have to wait for that last
costly solving to occur. If the items which are likely to take
more time are solved first, this wait is less likely to have an
impact on the overall solving time.
</p>
<p>In rxode2 the IDs are sorted by the individual number of solving
points (largest first). It also has a C interface that allows
these IDs to be resorted by total time spent solving the
equation.  This allows packages like nlmixr to sort by solving
time if needed.
</p>
<p>Overall the the number of threads is throttled (restricted) for
small tasks and sorting for IDs are suppressed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>number of threads that rxode2 uses
</p>

<hr>
<h2 id='guide_none'>Empty Guide</h2><span id='topic+guide_none'></span>

<h3>Description</h3>

<p>This empty guide draws nothing; It is included in rxode2 for
compatibility with ggplot 3.2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guide_none(title = waiver(), position = waiver())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="guide_none_+3A_title">title</code></td>
<td>
<p>A character string or expression indicating a title of guide.
If <code>NULL</code>, the title is not shown. By default
(<code><a href="ggplot2.html#topic+waiver">waiver()</a></code>), the name of the scale object or the name
specified in <code><a href="ggplot2.html#topic+labs">labs()</a></code> is used for the title.</p>
</td></tr>
<tr><td><code id="guide_none_+3A_position">position</code></td>
<td>
<p>Where this guide should be drawn: one of top, bottom,
left, or right.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing, simply included to be compatible with ggplot 3.2
</p>

<hr>
<h2 id='ini.rxUi'>Ini block for rxode2/nlmixr models</h2><span id='topic+ini.rxUi'></span><span id='topic+ini.default'></span><span id='topic+ini'></span>

<h3>Description</h3>

<p>The ini block controls initial conditions for 'theta' (fixed effects),
'omega' (random effects), and 'sigma' (residual error) elements of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rxUi'
ini(x, ..., envir = parent.frame(), append = NULL)

## Default S3 method:
ini(x, ..., envir = parent.frame(), append = NULL)

ini(x, ..., envir = parent.frame(), append = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ini.rxUi_+3A_x">x</code></td>
<td>
<p>expression</p>
</td></tr>
<tr><td><code id="ini.rxUi_+3A_...">...</code></td>
<td>
<p>Other expressions for <code>ini()</code> function</p>
</td></tr>
<tr><td><code id="ini.rxUi_+3A_envir">envir</code></td>
<td>
<p>the <code>environment</code> in which unevaluated model
expressions is to be evaluated.  May also be <code>NULL</code>, a list, a
data frame, a pairlist or an integer as specified to <code>sys.call</code>.</p>
</td></tr>
<tr><td><code id="ini.rxUi_+3A_append">append</code></td>
<td>
<p>Reorder theta parameters.  <code>NULL</code> means no change to
parameter order.  A parameter name (as a character string) means to put the
new parameter after the named parameter.  A number less than or equal to
zero means to put the parameter at the beginning of the list.  A number
greater than the last parameter number means to put the parameter at the
end of the list.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>ini()</code> function is used in two different ways.  The main way that
it is used is to set the initial conditions and associated attributes
(described below) in a model.  The other way that it is used is for updating
the initial conditions in a model, often using the pipe operator.
</p>
<p>'theta' and 'sigma' can be set using either <code>&lt;-</code> or <code>=</code> such as
<code>tvCL &lt;- 1</code> or equivalently <code>tvCL = 1</code>.  'omega' can be set with a
<code>~</code> such as <code>etaCL ~ 0.1</code>.
</p>
<p>Parameters can be named or unnamed (though named parameters are preferred).
A named parameter is set using the name on the left of the assignment while
unnamed parameters are set without an assignment operator.  <code>tvCL &lt;- 1</code>
would set a named parameter of <code>tvCL</code> to <code>1</code>.  Unnamed parameters
are set using just the value, such as <code>1</code>.
</p>
<p>For some estimation methods, lower and upper bounds can be set for 'theta'
and 'sigma' values.  To set a lower and/or upper bound, use a vector of
values.  The vector is <code>c(lower, estimate, upper)</code>.  The vector may be
given with just the estimate (<code>estimate</code>), the lower bound and
estimate (<code>c(lower, estimate)</code>), or all three (<code>c(lower, estimate,
upper)</code>).  To set an estimate and upper bound without a lower bound, set the
lower bound to <code>-Inf</code>, <code>c(-Inf, estimate, upper)</code>.  When an
estimation method does not support bounds, the bounds will be ignored with a
warning.
</p>
<p>'omega' values can be set as a single value or as the values of a
lower-triangular matrix.  The values may be set as either a
variance-covariance matrix (the default) or as a correlation matrix
for the off-diagonals with the standard deviations on the
diagonals.  Names may be set on the left side of the <code>~</code>.  To
set a variance-covariance matrix with variance values of 2 and 3
and a covariance of -2.5 use <code>~c(2, 2.5, 3)</code>.  To set the same
matrix with names of <code>iivKa</code> and <code>iivCL</code>, use <code>iivKa
+ iivCL~c(2, 2.5, 3)</code>.  To set a correlation matrix with standard
deviations on the diagonal, use <code>cor()</code> like <code>iivKa +
iivCL~cor(2, -0.5, 3)</code>.  As of rxode2 3.0 you can also use
<code>iivKa ~ 2, iivCL ~ c(2.5, 3)</code> for covariance matrices as
well.
</p>
<p>Values may be fixed (and therefore not estimated) using either the name
<code>fixed</code> at the end of the assignment or by calling <code>fixed()</code> as a
function for the value to fix.  For 'theta' and 'sigma', either the estimate
or the full definition (including lower and upper bounds) may be included in
the fixed setting.  For example, the following are all effectively equivalent
to set a 'theta' or 'sigma' to a fixed value (because the lower and upper
bounds are ignored for a fixed value): <code>tvCL &lt;- fixed(1)</code>, <code>tvCL &lt;-
fixed(0, 1)</code>, <code>tvCL &lt;- fixed(0, 1, 2)</code>, <code>tvCL &lt;- c(0, fixed(1),
2)</code>, or <code>tvCL &lt;- c(0, 1, fixed)</code>.  For 'omega' assignment, the full
block or none of the block must be set as <code>fixed</code>.  Examples of setting
an 'omega' value as fixed are: <code>iivKa~fixed(1)</code>, <code>iivKa +
iivCL~fixed(1, 2, 3)</code>, or <code>iivKa + iivCL~c(1, 2, 3, fixed)</code>.  Anywhere
that <code>fixed</code> is used, <code>FIX</code>, <code>FIXED</code>, or <code>fix</code> may be
used equivalently.
</p>
<p>For any value, standard mathematical operators or functions may be used to
define the value.  For example, <code>log(2)</code> and <code>24*30</code> may be used to
define a value anywhere that a number can be used (e.g. lower bound,
estimate, upper bound, variance, etc.).
</p>
<p>Values may be labeled using the <code>label()</code> function after the assignment.
Labels are are used to make reporting easier by giving a human-readable
description of the parameter, but the labels do not have any effect on
estimation.  The typical way to set a label so that the parameter <code>tvCL</code>
has a label of &quot;Typical Value of Clearance (L/hr)&quot; is <code>tvCL &lt;- 1;
label("Typical Value of Clearance (L/hr)")</code>.
</p>
<p>Off diagonal values of 'omega' can be set to zero using the
<code>diag()</code> to remove all off-diagonals can be removed with
<code>ini(diag())</code>.  To remove covariances of 'omega' item with <code>iivKa</code>,
you can use <code style="white-space: pre;">&#8288;%&gt;% ini(diag(iivKa))&#8288;</code>.  Or to remove covariances that
contain either <code>iivKa</code> or <code>iivCl</code> you can use <code style="white-space: pre;">&#8288;%&gt;% ini(diag(iivKa, iivCl))&#8288;</code>.  For finer control you can remove the covariance between
two items (like <code>iivKa</code> and <code>iivCl</code>) by '%&gt;% ini(-cov(iivKa, iivCl))
</p>
<p><code>rxode2</code>/<code>nlmixr2</code> will attempt to determine some
back-transformations for the user.  For example, <code>CL &lt;- exp(tvCL)</code> will
detect that <code>tvCL</code> must be back-transformed by <code>exp()</code> for easier
interpretation.  When you want to control the back-transformation, you can
specify the back-transformation using <code>backTransform()</code> after the
assignment.  For example, to set the
back-transformation to <code>exp()</code>, you can use <code>tvCL &lt;- 1;
backTransform(exp())</code>.
</p>


<h3>Value</h3>

<p>ini block
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>


<h3>See Also</h3>

<p>Other Initial conditions: 
<code><a href="#topic+zeroRe">zeroRe</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Set the ini() block in a model
one.compartment &lt;- function() {
  ini({
    tka &lt;- log(1.57); label("Ka")
    tcl &lt;- log(2.72); label("Cl")
    tv &lt;- log(31.5); label("V")
    eta.ka ~ 0.6
    eta.cl ~ 0.3
    eta.v ~ 0.1
    add.sd &lt;- 0.7
  })
  model({
    ka &lt;- exp(tka + eta.ka)
    cl &lt;- exp(tcl + eta.cl)
    v &lt;- exp(tv + eta.v)
    d/dt(depot) = -ka * depot
    d/dt(center) = ka * depot - cl / v * center
    cp = center / v
    cp ~ add(add.sd)
  })
}

# Use piping to update initial conditions
one.compartment %&gt;% ini(tka &lt;- log(2))
one.compartment %&gt;% ini(tka &lt;- label("Absorption rate, Ka (1/hr)"))
# Move the tka parameter to be just below the tv parameter (affects parameter
# summary table, only)
one.compartment %&gt;% ini(tka &lt;- label("Absorption rate, Ka (1/hr)"), append = "tv")
# When programming with rxode2/nlmixr2, it may be easier to pass strings in
# to modify the ini
one.compartment %&gt;% ini("tka &lt;- log(2)")
</code></pre>

<hr>
<h2 id='ini+26lt+3B-'>Assign the ini block in the rxode2 related object</h2><span id='topic+ini+3C-'></span>

<h3>Description</h3>

<p>Assign the ini block in the rxode2 related object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ini(x, envir = environment(x)) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ini+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>rxode2 related object</p>
</td></tr>
<tr><td><code id="ini+2B26lt+2B3B-_+3A_envir">envir</code></td>
<td>
<p>Environment where assignment occurs</p>
</td></tr>
<tr><td><code id="ini+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>Value of the object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rxode2 related object
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='invWR1d'>One correlation sample from the Inverse Wishart distribution</h2><span id='topic+invWR1d'></span>

<h3>Description</h3>

<p>This correlation is constructed by transformation of the Inverse Wishart
random covariate to a correlation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>invWR1d(d, nu, omegaIsChol = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="invWR1d_+3A_d">d</code></td>
<td>
<p>The dimension of the correlation matrix</p>
</td></tr>
<tr><td><code id="invWR1d_+3A_nu">nu</code></td>
<td>
<p>Degrees of freedom of the Wishart distribution</p>
</td></tr>
<tr><td><code id="invWR1d_+3A_omegaischol">omegaIsChol</code></td>
<td>
<p>is an indicator of if the omega matrix is in
the Cholesky decomposition. This is only used when <code>type="invWishart"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>One correlation sample from the inverse wishart
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='is.rxEt'>Check to see if this is an rxEt object.</h2><span id='topic+is.rxEt'></span>

<h3>Description</h3>

<p>Check to see if this is an rxEt object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.rxEt(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.rxEt_+3A_x">x</code></td>
<td>
<p>object to check to see if it is rxEt
</p>
<p>If this is an rxEt object that has expired strip all rxEt
information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean indicating if this is a rxode2 event table
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>

<hr>
<h2 id='is.rxSolve'>Check to see if this is an rxSolve object.</h2><span id='topic+is.rxSolve'></span>

<h3>Description</h3>

<p>Check to see if this is an rxSolve object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.rxSolve(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.rxSolve_+3A_x">x</code></td>
<td>
<p>object to check to see if it is rxSolve
</p>
<p>If this is an rxSolve object that has expired strip all rxSolve
information.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boolean indicating if this is a <code>rxSolve</code> object
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>

<hr>
<h2 id='is.rxStackData'>Return if the object can be stacked</h2><span id='topic+is.rxStackData'></span>

<h3>Description</h3>

<p>Return if the object can be stacked
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.rxStackData(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="is.rxStackData_+3A_object">object</code></td>
<td>
<p>object to test if it can be stacked</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boolean to tell if an object can be stacked using rxode2
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
is.rxStackData(NULL)
</code></pre>

<hr>
<h2 id='linMod'>Linear model to replace in rxode2 ui model</h2><span id='topic+linMod'></span><span id='topic+linMod0'></span><span id='topic+linModB'></span><span id='topic+linModB0'></span><span id='topic+linModA'></span><span id='topic+linModA0'></span><span id='topic+linModD'></span><span id='topic+linModD0'></span><span id='topic+linModM'></span><span id='topic+linModM0'></span>

<h3>Description</h3>

<p>Linear model to replace in rxode2 ui model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linMod(
  variable,
  power,
  dv = "dv",
  intercept = TRUE,
  type = c("replace", "before", "after"),
  num = NULL,
  iniDf = NULL,
  data = FALSE,
  mv = FALSE
)

linMod0(..., intercept = FALSE)

linModB(..., type = "before")

linModB0(..., intercept = FALSE, type = "before")

linModA(..., type = "after")

linModA0(..., intercept = FALSE, type = "after")

linModD(..., intercept = TRUE, data = TRUE)

linModD0(..., intercept = FALSE, data = TRUE)

linModM(..., intercept = TRUE, mv = TRUE)

linModM0(..., intercept = FALSE, mv = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="linMod_+3A_variable">variable</code></td>
<td>
<p>The variable that the rxode2 will be made on.</p>
</td></tr>
<tr><td><code id="linMod_+3A_power">power</code></td>
<td>
<p>The power of the polynomial that will be generated.</p>
</td></tr>
<tr><td><code id="linMod_+3A_dv">dv</code></td>
<td>
<p>the dependent variable to use to generate the initial
estimates from the data. If <code>NULL</code> query using <code>rxUdfUiData()</code>.</p>
</td></tr>
<tr><td><code id="linMod_+3A_intercept">intercept</code></td>
<td>
<p>Boolean that tells if the intercept be generated.</p>
</td></tr>
<tr><td><code id="linMod_+3A_type">type</code></td>
<td>
<p>the type of linear model replacement to be used.</p>
</td></tr>
<tr><td><code id="linMod_+3A_num">num</code></td>
<td>
<p>the number the particular model is being generated. If
unspecified, query using <code>rxUdfUiNum()</code>.</p>
</td></tr>
<tr><td><code id="linMod_+3A_inidf">iniDf</code></td>
<td>
<p>the initialization <code>data.frame</code>, if <code>NULL</code> query using
<code>rxUdfUiIniDf()</code></p>
</td></tr>
<tr><td><code id="linMod_+3A_data">data</code></td>
<td>
<p>logical that tells if the initial estimates of the
linear model should be estimated from the data.</p>
</td></tr>
<tr><td><code id="linMod_+3A_mv">mv</code></td>
<td>
<p>logical that tell if the model variables need to be used
to generate model variables.</p>
</td></tr>
<tr><td><code id="linMod_+3A_...">...</code></td>
<td>
<p>arguments that are passed to <code>linMod()</code> for the other
abbreviations of <code>linMod()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list for use in when generating the <code>rxode2</code> ui model see
<code>rxUdfUi()</code> for details.
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>linMod0()</code>: linear model without intercept
</p>
</li>
<li> <p><code>linModB()</code>: linear model before where it occurs
</p>
</li>
<li> <p><code>linModB0()</code>: linear model before where the user function occurs
</p>
</li>
<li> <p><code>linModA()</code>: linear model after where the user function occurs
</p>
</li>
<li> <p><code>linModA0()</code>: liner model without an intercept placed after where the user function occurs
</p>
</li>
<li> <p><code>linModD()</code>: linear model where initial estimates are generated from the data
</p>
</li>
<li> <p><code>linModD0()</code>: linear model where initial estimates are generated from the data (no intercept)
</p>
</li>
<li> <p><code>linModM()</code>: linear model where the model variables are used to generate the model variables
</p>
</li>
<li> <p><code>linModM0()</code>: linear model where the model variables are used to generate the model variables (no intercept)
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>See Also</h3>

<p>Other User functions: 
<code><a href="#topic+rxUdfUiControl">rxUdfUiControl</a>()</code>,
<code><a href="#topic+rxUdfUiData">rxUdfUiData</a>()</code>,
<code><a href="#topic+rxUdfUiEst">rxUdfUiEst</a>()</code>,
<code><a href="#topic+rxUdfUiIniLhs">rxUdfUiIniLhs</a>()</code>,
<code><a href="#topic+rxUdfUiMv">rxUdfUiMv</a>()</code>,
<code><a href="#topic+rxUdfUiNum">rxUdfUiNum</a>()</code>,
<code><a href="#topic+rxUdfUiParsing">rxUdfUiParsing</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
linMod(x, 3)
</code></pre>

<hr>
<h2 id='llikBeta'>Calculate the log likelihood of the binomial function (and its derivatives)</h2><span id='topic+llikBeta'></span>

<h3>Description</h3>

<p>Calculate the log likelihood of the binomial function (and its derivatives)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llikBeta(x, shape1, shape2, full = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="llikBeta_+3A_x">x</code></td>
<td>
<p>Observation</p>
</td></tr>
<tr><td><code id="llikBeta_+3A_shape1">shape1</code>, <code id="llikBeta_+3A_shape2">shape2</code></td>
<td>
<p>non-negative parameters of the Beta distribution.</p>
</td></tr>
<tr><td><code id="llikBeta_+3A_full">full</code></td>
<td>
<p>Add the data frame showing x, mean, sd as well as the
fx and derivatives</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In an <code>rxode2()</code> model, you can use <code>llikBeta()</code> but you have to
use all arguments.  You can also get the derivative of <code>shape1</code> and <code>shape2</code> with
<code>llikBetaDshape1()</code> and <code>llikBetaDshape2()</code>.
</p>


<h3>Value</h3>

<p>data frame with <code>fx</code> for the log pdf value of with
<code>dShape1</code> and <code>dShape2</code> that has the derivatives with respect to the parameters at
the observation time-point
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


x &lt;- seq(1e-4, 1 - 1e-4, length.out = 21)

llikBeta(x, 0.5, 0.5)

llikBeta(x, 1, 3, TRUE)

et &lt;- et(seq(1e-4, 1-1e-4, length.out=21))
et$shape1 &lt;- 0.5
et$shape2 &lt;- 1.5

model &lt;- function() {
  model({
    fx &lt;- llikBeta(time, shape1, shape2)
    dShape1 &lt;- llikBetaDshape1(time, shape1, shape2)
    dShape2 &lt;- llikBetaDshape2(time, shape1, shape2)
  })
}

rxSolve(model, et)

</code></pre>

<hr>
<h2 id='llikBinom'>Calculate the log likelihood of the binomial function (and its derivatives)</h2><span id='topic+llikBinom'></span>

<h3>Description</h3>

<p>Calculate the log likelihood of the binomial function (and its derivatives)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llikBinom(x, size, prob, full = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="llikBinom_+3A_x">x</code></td>
<td>
<p>Number of successes</p>
</td></tr>
<tr><td><code id="llikBinom_+3A_size">size</code></td>
<td>
<p>Size of trial</p>
</td></tr>
<tr><td><code id="llikBinom_+3A_prob">prob</code></td>
<td>
<p>probability of success</p>
</td></tr>
<tr><td><code id="llikBinom_+3A_full">full</code></td>
<td>
<p>Add the data frame showing x, mean, sd as well as the
fx and derivatives</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In an <code>rxode2()</code> model, you can use <code>llikBinom()</code> but you have to
use all arguments.  You can also get the derivative of <code>prob</code> with
<code>llikBinomDprob()</code>
</p>


<h3>Value</h3>

<p>data frame with <code>fx</code> for the pdf value of with
<code>dProb</code> that has the derivatives with respect to the parameters at
the observation time-point
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
llikBinom(46:54, 100, 0.5)

llikBinom(46:54, 100, 0.5, TRUE)

# In rxode2 you can use:

et &lt;- et(46:54)
et$size &lt;- 100
et$prob &lt;-0.5

model &lt;- function() {
  model({
    fx &lt;- llikBinom(time, size, prob)
    dProb &lt;- llikBinomDprob(time, size, prob)
  })
}

rxSolve(model, et)

</code></pre>

<hr>
<h2 id='llikCauchy'>log likelihood of Cauchy distribution and it's derivatives (from stan)</h2><span id='topic+llikCauchy'></span>

<h3>Description</h3>

<p>log likelihood of Cauchy distribution and it's derivatives (from stan)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llikCauchy(x, location = 0, scale = 1, full = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="llikCauchy_+3A_x">x</code></td>
<td>
<p>Observation</p>
</td></tr>
<tr><td><code id="llikCauchy_+3A_location">location</code>, <code id="llikCauchy_+3A_scale">scale</code></td>
<td>
<p>location and scale parameters.</p>
</td></tr>
<tr><td><code id="llikCauchy_+3A_full">full</code></td>
<td>
<p>Add the data frame showing x, mean, sd as well as the
fx and derivatives</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In an <code>rxode2()</code> model, you can use <code>llikCauchy()</code> but you have to
use all arguments.  You can also get the derivative of <code>location</code> and <code>scale</code> with
<code>llikCauchyDlocation()</code> and <code>llikCauchyDscale()</code>.
</p>


<h3>Value</h3>

<p>data frame with <code>fx</code> for the log pdf value of with
<code>dLocation</code> and <code>dScale</code> that has the derivatives with respect to the parameters at
the observation time-point
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- seq(-3, 3, length.out = 21)

llikCauchy(x, 0, 1)

llikCauchy(x, 3, 1, full=TRUE)

et &lt;- et(-3, 3, length.out=10)
et$location &lt;- 0
et$scale &lt;- 1

model &lt;- function() {
  model({
    fx &lt;- llikCauchy(time, location, scale)
    dLocation &lt;- llikCauchyDlocation(time, location, scale)
    dScale &lt;- llikCauchyDscale(time, location, scale)
  })
}

rxSolve(model, et)

</code></pre>

<hr>
<h2 id='llikChisq'>log likelihood and derivatives for chi-squared distribution</h2><span id='topic+llikChisq'></span>

<h3>Description</h3>

<p>log likelihood and derivatives for chi-squared distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llikChisq(x, df, full = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="llikChisq_+3A_x">x</code></td>
<td>
<p>variable that is distributed by chi-squared distribution</p>
</td></tr>
<tr><td><code id="llikChisq_+3A_df">df</code></td>
<td>
<p>degrees of freedom (non-negative, but can be non-integer).</p>
</td></tr>
<tr><td><code id="llikChisq_+3A_full">full</code></td>
<td>
<p>Add the data frame showing x, mean, sd as well as the
fx and derivatives</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In an <code>rxode2()</code> model, you can use <code>llikChisq()</code> but you have to
use the x and df arguments.  You can also get the derivative of <code>df</code> with
<code>llikChisqDdf()</code>.
</p>


<h3>Value</h3>

<p>data frame with <code>fx</code> for the log pdf value of with <code>dDf</code>
that has the derivatives with respect to the <code>df</code> parameter
the observation time-point
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

llikChisq(1, df = 1:3, full=TRUE)

llikChisq(1, df = 6:9)

et &lt;- et(1:3)
et$x &lt;- 1

model &lt;- function() {
  model({
   fx &lt;- llikChisq(x, time)
   dDf &lt;- llikChisqDdf(x, time)
  })
}

rxSolve(model, et)

</code></pre>

<hr>
<h2 id='llikExp'>log likelihood and derivatives for exponential distribution</h2><span id='topic+llikExp'></span>

<h3>Description</h3>

<p>log likelihood and derivatives for exponential distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llikExp(x, rate, full = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="llikExp_+3A_x">x</code></td>
<td>
<p>variable that is distributed by exponential distribution</p>
</td></tr>
<tr><td><code id="llikExp_+3A_rate">rate</code></td>
<td>
<p>vector of rates.</p>
</td></tr>
<tr><td><code id="llikExp_+3A_full">full</code></td>
<td>
<p>Add the data frame showing x, mean, sd as well as the
fx and derivatives</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In an <code>rxode2()</code> model, you can use <code>llikExp()</code> but you have to
use the x and rate arguments.  You can also get the derivative of <code>rate</code> with
<code>llikExpDrate()</code>.
</p>


<h3>Value</h3>

<p>data frame with <code>fx</code> for the log pdf value of with <code>dRate</code>
that has the derivatives with respect to the <code>rate</code> parameter
the observation time-point
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
llikExp(1, 1:3)

llikExp(1, 1:3, full=TRUE)

# You can use rxode2 for these too:

et &lt;- et(1:3)
et$x &lt;- 1

model &lt;- function() {
  model({
    fx &lt;- llikExp(x, time)
    dRate &lt;- llikExpDrate(x, time)
  })
}

rxSolve(model, et)

</code></pre>

<hr>
<h2 id='llikF'>log likelihood and derivatives for F distribution</h2><span id='topic+llikF'></span>

<h3>Description</h3>

<p>log likelihood and derivatives for F distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llikF(x, df1, df2, full = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="llikF_+3A_x">x</code></td>
<td>
<p>variable that is distributed by f distribution</p>
</td></tr>
<tr><td><code id="llikF_+3A_df1">df1</code>, <code id="llikF_+3A_df2">df2</code></td>
<td>
<p>degrees of freedom.  <code>Inf</code> is allowed.</p>
</td></tr>
<tr><td><code id="llikF_+3A_full">full</code></td>
<td>
<p>Add the data frame showing x, mean, sd as well as the
fx and derivatives</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In an <code>rxode2()</code> model, you can use <code>llikF()</code> but you have to
use the x and rate arguments.  You can also get the derivative of <code>df1</code> and <code>df2</code> with
<code>llikFDdf1()</code> and <code>llikFDdf2()</code>.
</p>


<h3>Value</h3>

<p>data frame with <code>fx</code> for the log pdf value of with <code>dDf1</code> and <code>dDf2</code>
that has the derivatives with respect to the <code>df1</code>/<code>df2</code> parameters at
the observation time-point
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

x &lt;- seq(0.001, 5, length.out = 100)

llikF(x^2, 1, 5)

model &lt;- function(){
  model({
    fx &lt;- llikF(time, df1, df2)
    dMean &lt;- llikFDdf1(time, df1, df2)
    dSd &lt;- llikFDdf2(time, df1, df2)
  })
}

et &lt;- et(x)
et$df1 &lt;- 1
et$df2 &lt;- 5

rxSolve(model, et)

</code></pre>

<hr>
<h2 id='llikGamma'>log likelihood and derivatives for Gamma distribution</h2><span id='topic+llikGamma'></span>

<h3>Description</h3>

<p>log likelihood and derivatives for Gamma distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llikGamma(x, shape, rate, full = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="llikGamma_+3A_x">x</code></td>
<td>
<p>variable that is distributed by gamma distribution</p>
</td></tr>
<tr><td><code id="llikGamma_+3A_shape">shape</code></td>
<td>
<p>this is the distribution's shape parameter. Must be positive.</p>
</td></tr>
<tr><td><code id="llikGamma_+3A_rate">rate</code></td>
<td>
<p>this is the distribution's rate parameters.  Must be positive.</p>
</td></tr>
<tr><td><code id="llikGamma_+3A_full">full</code></td>
<td>
<p>Add the data frame showing x, mean, sd as well as the
fx and derivatives</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In an <code>rxode2()</code> model, you can use <code>llikGamma()</code> but you have to
use the x and rate arguments.  You can also get the derivative of <code>shape</code> or <code>rate</code> with
<code>llikGammaDshape()</code> and <code>llikGammaDrate()</code>.
</p>


<h3>Value</h3>

<p>data frame with <code>fx</code> for the log pdf value of with <code>dProb</code>
that has the derivatives with respect to the <code>prob</code> parameters at
the observation time-point
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

llikGamma(1, 1, 10)

# You can use this in `rxode2` too:

et  &lt;- et(seq(0.001, 1, length.out=10))
et$shape &lt;- 1
et$rate &lt;- 10
 
model &lt;- function() {
  model({
    fx &lt;- llikGamma(time, shape, rate)
    dShape&lt;- llikGammaDshape(time, shape, rate)
    dRate &lt;- llikGammaDrate(time, shape, rate)
  })
}

rxSolve(model, et)

</code></pre>

<hr>
<h2 id='llikGeom'>log likelihood and derivatives for Geom distribution</h2><span id='topic+llikGeom'></span>

<h3>Description</h3>

<p>log likelihood and derivatives for Geom distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llikGeom(x, prob, full = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="llikGeom_+3A_x">x</code></td>
<td>
<p>variable distributed by a geom distribution</p>
</td></tr>
<tr><td><code id="llikGeom_+3A_prob">prob</code></td>
<td>
<p>probability of success in each trial. <code>0 &lt; prob &lt;= 1</code>.</p>
</td></tr>
<tr><td><code id="llikGeom_+3A_full">full</code></td>
<td>
<p>Add the data frame showing x, mean, sd as well as the
fx and derivatives</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In an <code>rxode2()</code> model, you can use <code>llikGeom()</code> but you have to
use the x and rate arguments.  You can also get the derivative of <code>prob</code> with
<code>llikGeomDprob()</code>.
</p>


<h3>Value</h3>

<p>data frame with <code>fx</code> for the log pdf value of with <code>dProb</code>
that has the derivatives with respect to the <code>prob</code> parameters at
the observation time-point
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


llikGeom(1:10, 0.2)

et  &lt;- et(1:10)
et$prob &lt;- 0.2
 
model &lt;- function() {
  model({
    fx &lt;- llikGeom(time, prob)
    dProb &lt;- llikGeomDprob(time, prob)
  })
}

rxSolve(model, et)

</code></pre>

<hr>
<h2 id='llikNbinom'>Calculate the log likelihood of the negative binomial function (and its derivatives)</h2><span id='topic+llikNbinom'></span>

<h3>Description</h3>

<p>Calculate the log likelihood of the negative binomial function (and its derivatives)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llikNbinom(x, size, prob, full = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="llikNbinom_+3A_x">x</code></td>
<td>
<p>Number of successes</p>
</td></tr>
<tr><td><code id="llikNbinom_+3A_size">size</code></td>
<td>
<p>Size of trial</p>
</td></tr>
<tr><td><code id="llikNbinom_+3A_prob">prob</code></td>
<td>
<p>probability of success</p>
</td></tr>
<tr><td><code id="llikNbinom_+3A_full">full</code></td>
<td>
<p>Add the data frame showing x, mean, sd as well as the
fx and derivatives</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In an <code>rxode2()</code> model, you can use <code>llikNbinom()</code> but you have to
use all arguments.  You can also get the derivative of <code>prob</code> with
<code>llikNbinomDprob()</code>
</p>


<h3>Value</h3>

<p>data frame with <code>fx</code> for the pdf value of with
<code>dProb</code> that has the derivatives with respect to the parameters at
the observation time-point
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
llikNbinom(46:54, 100, 0.5)

llikNbinom(46:54, 100, 0.5, TRUE)

# In rxode2 you can use:

et &lt;- et(46:54)
et$size &lt;- 100
et$prob &lt;-0.5

model &lt;- function() {
  model({
    fx &lt;- llikNbinom(time, size, prob)
    dProb &lt;- llikNbinomDprob(time, size, prob)
  })
}

rxSolve(model, et)

</code></pre>

<hr>
<h2 id='llikNbinomMu'>Calculate the log likelihood of the negative binomial function (and its derivatives)</h2><span id='topic+llikNbinomMu'></span>

<h3>Description</h3>

<p>Calculate the log likelihood of the negative binomial function (and its derivatives)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llikNbinomMu(x, size, mu, full = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="llikNbinomMu_+3A_x">x</code></td>
<td>
<p>Number of successes</p>
</td></tr>
<tr><td><code id="llikNbinomMu_+3A_size">size</code></td>
<td>
<p>Size of trial</p>
</td></tr>
<tr><td><code id="llikNbinomMu_+3A_mu">mu</code></td>
<td>
<p>mu parameter for negative binomial</p>
</td></tr>
<tr><td><code id="llikNbinomMu_+3A_full">full</code></td>
<td>
<p>Add the data frame showing x, mean, sd as well as the
fx and derivatives</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In an <code>rxode2()</code> model, you can use <code>llikNbinomMu()</code> but you have to
use all arguments.  You can also get the derivative of <code>mu</code> with
<code>llikNbinomMuDmu()</code>
</p>


<h3>Value</h3>

<p>data frame with <code>fx</code> for the pdf value of with
<code>dProb</code> that has the derivatives with respect to the parameters at
the observation time-point
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
llikNbinomMu(46:54, 100, 40)

llikNbinomMu(46:54, 100, 40, TRUE)

et &lt;- et(46:54)
et$size &lt;- 100
et$mu &lt;- 40

model &lt;- function() {
  model({
    fx &lt;- llikNbinomMu(time, size, mu)
    dProb &lt;- llikNbinomMuDmu(time, size, mu)
  })
}

rxSolve(model, et)

</code></pre>

<hr>
<h2 id='llikNorm'>Log likelihood for normal distribution</h2><span id='topic+llikNorm'></span>

<h3>Description</h3>

<p>Log likelihood for normal distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llikNorm(x, mean = 0, sd = 1, full = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="llikNorm_+3A_x">x</code></td>
<td>
<p>Observation</p>
</td></tr>
<tr><td><code id="llikNorm_+3A_mean">mean</code></td>
<td>
<p>Mean for the likelihood</p>
</td></tr>
<tr><td><code id="llikNorm_+3A_sd">sd</code></td>
<td>
<p>Standard deviation for the likelihood</p>
</td></tr>
<tr><td><code id="llikNorm_+3A_full">full</code></td>
<td>
<p>Add the data frame showing x, mean, sd as well as the
fx and derivatives</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In an <code>rxode2()</code> model, you can use <code>llikNorm()</code> but you have to
use all arguments.  You can also get the derivatives with
<code>llikNormDmean()</code> and <code>llikNormDsd()</code>
</p>


<h3>Value</h3>

<p>data frame with <code>fx</code> for the pdf value of with <code>dMean</code> and
<code>dSd</code> that has the derivatives with respect to the parameters at
the observation time-point
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


llikNorm(0)

llikNorm(seq(-2,2,length.out=10), full=TRUE)

# With rxode2 you can use:
 
et &lt;- et(-3, 3, length.out=10)
et$mu &lt;- 0
et$sigma &lt;- 1

model &lt;- function(){
  model({
    fx &lt;- llikNorm(time, mu, sigma)
    dMean &lt;- llikNormDmean(time, mu, sigma)
    dSd &lt;- llikNormDsd(time, mu, sigma)
  })
 }

ret &lt;- rxSolve(model, et)
ret

</code></pre>

<hr>
<h2 id='llikPois'>log-likelihood for the Poisson distribution</h2><span id='topic+llikPois'></span>

<h3>Description</h3>

<p>log-likelihood for the Poisson distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llikPois(x, lambda, full = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="llikPois_+3A_x">x</code></td>
<td>
<p>non negative integers</p>
</td></tr>
<tr><td><code id="llikPois_+3A_lambda">lambda</code></td>
<td>
<p>non-negative means</p>
</td></tr>
<tr><td><code id="llikPois_+3A_full">full</code></td>
<td>
<p>Add the data frame showing x, mean, sd as well as the
fx and derivatives</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In an <code>rxode2()</code> model, you can use <code>llikPois()</code> but you have to
use all arguments.  You can also get the derivatives with
<code>llikPoisDlambda()</code>
</p>


<h3>Value</h3>

<p>data frame with <code>fx</code> for the pdf value of with
<code>dLambda</code> that has the derivatives with respect to the parameters at
the observation time-point
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
llikPois(0:7, lambda = 1)

llikPois(0:7, lambda = 4, full=TRUE)

# In rxode2 you can use:

et &lt;- et(0:10)
et$lambda &lt;- 0.5

model &lt;- function() {
  model({
    fx &lt;- llikPois(time, lambda)
    dLambda &lt;- llikPoisDlambda(time, lambda)
  })
}

rxSolve(model, et)

</code></pre>

<hr>
<h2 id='llikT'>Log likelihood of T and it's derivatives (from stan)</h2><span id='topic+llikT'></span>

<h3>Description</h3>

<p>Log likelihood of T and it's derivatives (from stan)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llikT(x, df, mean = 0, sd = 1, full = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="llikT_+3A_x">x</code></td>
<td>
<p>Observation</p>
</td></tr>
<tr><td><code id="llikT_+3A_df">df</code></td>
<td>
<p>degrees of freedom (<code class="reqn">&gt; 0</code>, maybe non-integer).  <code>df
      = Inf</code> is allowed.</p>
</td></tr>
<tr><td><code id="llikT_+3A_mean">mean</code></td>
<td>
<p>Mean for the likelihood</p>
</td></tr>
<tr><td><code id="llikT_+3A_sd">sd</code></td>
<td>
<p>Standard deviation for the likelihood</p>
</td></tr>
<tr><td><code id="llikT_+3A_full">full</code></td>
<td>
<p>Add the data frame showing x, mean, sd as well as the
fx and derivatives</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In an <code>rxode2()</code> model, you can use <code>llikT()</code> but you have to
use all arguments.  You can also get the derivative of <code>df</code>, <code>mean</code> and <code>sd</code> with
<code>llikTDdf()</code>, <code>llikTDmean()</code> and <code>llikTDsd()</code>.
</p>


<h3>Value</h3>

<p>data frame with <code>fx</code> for the log pdf value of with <code>dDf</code>
<code>dMean</code> and <code>dSd</code> that has the derivatives with respect to the parameters at
the observation time-point
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

x &lt;- seq(-3, 3, length.out = 21)

llikT(x, 7, 0, 1)

llikT(x, 15, 0, 1, full=TRUE)

et &lt;- et(-3, 3, length.out=10)
et$nu &lt;- 7
et$mean &lt;- 0
et$sd &lt;- 1

model &lt;- function() {
  model({
    fx &lt;- llikT(time, nu, mean, sd)
    dDf &lt;- llikTDdf(time, nu, mean, sd)
    dMean &lt;- llikTDmean(time, nu, mean, sd)
    dSd   &lt;- llikTDsd(time, nu, mean, sd)
  })
}

rxSolve(model, et)


</code></pre>

<hr>
<h2 id='llikUnif'>log likelihood and derivatives for Unif distribution</h2><span id='topic+llikUnif'></span>

<h3>Description</h3>

<p>log likelihood and derivatives for Unif distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llikUnif(x, alpha, beta, full = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="llikUnif_+3A_x">x</code></td>
<td>
<p>variable distributed by a uniform distribution</p>
</td></tr>
<tr><td><code id="llikUnif_+3A_alpha">alpha</code></td>
<td>
<p>is the lower limit of the uniform distribution</p>
</td></tr>
<tr><td><code id="llikUnif_+3A_beta">beta</code></td>
<td>
<p>is the upper limit of the distribution</p>
</td></tr>
<tr><td><code id="llikUnif_+3A_full">full</code></td>
<td>
<p>Add the data frame showing x, mean, sd as well as the
fx and derivatives</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In an <code>rxode2()</code> model, you can use <code>llikUnif()</code> but you have to
use the x and rate arguments.  You can also get the derivative of <code>alpha</code> or <code>beta</code> with
<code>llikUnifDalpha()</code> and <code>llikUnifDbeta()</code>.
</p>


<h3>Value</h3>

<p>data frame with <code>fx</code> for the log pdf value of with <code>dProb</code>
that has the derivatives with respect to the <code>prob</code> parameters at
the observation time-point
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


llikUnif(1, -2, 2)

et  &lt;- et(seq(1,1, length.out=4))
et$alpha &lt;- -2
et$beta &lt;- 2
 
model &lt;- function() {
  model({
    fx &lt;- llikUnif(time, alpha, beta)
    dAlpha&lt;- llikUnifDalpha(time, alpha, beta)
    dBeta &lt;- llikUnifDbeta(time, alpha, beta)
  })
}

rxSolve(model, et)

</code></pre>

<hr>
<h2 id='llikWeibull'>log likelihood and derivatives for Weibull distribution</h2><span id='topic+llikWeibull'></span>

<h3>Description</h3>

<p>log likelihood and derivatives for Weibull distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>llikWeibull(x, shape, scale, full = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="llikWeibull_+3A_x">x</code></td>
<td>
<p>variable distributed by a Weibull distribution</p>
</td></tr>
<tr><td><code id="llikWeibull_+3A_shape">shape</code>, <code id="llikWeibull_+3A_scale">scale</code></td>
<td>
<p>shape and scale parameters, the latter defaulting to 1.</p>
</td></tr>
<tr><td><code id="llikWeibull_+3A_full">full</code></td>
<td>
<p>Add the data frame showing x, mean, sd as well as the
fx and derivatives</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In an <code>rxode2()</code> model, you can use <code>llikWeibull()</code> but you have to
use the x and rate arguments.  You can also get the derivative of <code>shape</code> or <code>scale</code> with
<code>llikWeibullDshape()</code> and <code>llikWeibullDscale()</code>.
</p>


<h3>Value</h3>

<p>data frame with <code>fx</code> for the log pdf value of with <code>dProb</code>
that has the derivatives with respect to the <code>prob</code> parameters at
the observation time-point
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
llikWeibull(1, 1, 10)

# rxode2 can use this too:

et  &lt;- et(seq(0.001, 1, length.out=10))
et$shape &lt;- 1
et$scale &lt;- 10
 
model &lt;- function() {
  model({
    fx &lt;- llikWeibull(time, shape, scale)
    dShape&lt;- llikWeibullDshape(time, shape, scale)
    dScale &lt;- llikWeibullDscale(time, shape, scale)
  })
}

rxSolve(model, et)

</code></pre>

<hr>
<h2 id='logit'>logit and inverse logit (expit) functions</h2><span id='topic+logit'></span><span id='topic+expit'></span><span id='topic+logitNormInfo'></span><span id='topic+probitNormInfo'></span>

<h3>Description</h3>

<p>logit and inverse logit (expit) functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logit(x, low = 0, high = 1)

expit(alpha, low = 0, high = 1)

logitNormInfo(mean = 0, sd = 1, low = 0, high = 1, abs.tol = 1e-06, ...)

probitNormInfo(mean = 0, sd = 1, low = 0, high = 1, abs.tol = 1e-06, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logit_+3A_x">x</code></td>
<td>
<p>Input value(s) in range [low,high] to translate -Inf to
Inf</p>
</td></tr>
<tr><td><code id="logit_+3A_low">low</code></td>
<td>
<p>Lowest value in the range</p>
</td></tr>
<tr><td><code id="logit_+3A_high">high</code></td>
<td>
<p>Highest value in the range</p>
</td></tr>
<tr><td><code id="logit_+3A_alpha">alpha</code></td>
<td>
<p>Infinite value(s) to translate to range of [low,
high]</p>
</td></tr>
<tr><td><code id="logit_+3A_mean">mean</code></td>
<td>
<p>logit-scale mean</p>
</td></tr>
<tr><td><code id="logit_+3A_sd">sd</code></td>
<td>
<p>logit-scale standard deviation</p>
</td></tr>
<tr><td><code id="logit_+3A_abs.tol">abs.tol</code></td>
<td>
<p>absolute accuracy requested.</p>
</td></tr>
<tr><td><code id="logit_+3A_...">...</code></td>
<td>
<p>other parameters passed to <code>integrate()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>logit is given by:
</p>
<p>logit(p) = -log(1/p-1)
</p>
<p>where:
</p>
<p>p = x-low/high-low
</p>
<p>expit is given by:
</p>
<p>expit(p, low, high) = (high-low)/(1+exp(-alpha)) + low
</p>
<p>The <code>logitNormInfo()</code> gives the mean, variance and coefficient of
variability on the untransformed scale.
</p>


<h3>Value</h3>

<p>values from logit and expit
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
logit(0.25)

expit(-1.09)

logitNormInfo(logit(0.25), sd = 0.1)

logitNormInfo(logit(1, 0, 10), sd = 1, low = 0, high = 10)

</code></pre>

<hr>
<h2 id='lowergamma'>lowergamma:  upper incomplete gamma function</h2><span id='topic+lowergamma'></span>

<h3>Description</h3>

<p>This is the tgamma_lower from the boost library
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lowergamma(a, z)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lowergamma_+3A_a">a</code></td>
<td>
<p>The numeric 'a' parameter in the upper
incomplete gamma</p>
</td></tr>
<tr><td><code id="lowergamma_+3A_z">z</code></td>
<td>
<p>The numeric 'z' parameter in the upper
incomplete gamma</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The lowergamma function is given by:
</p>
<p style="text-align: center;"><code class="reqn">lowergamma(a, z) = \int_{0}^{z}t^{a-1}\cdot e^{-t} dt</code>
</p>



<h3>Value</h3>

<p>lowergamma results
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
lowergamma(1, 3)

lowergamma(1:3, 3)

lowergamma(1, 1:3)
</code></pre>

<hr>
<h2 id='lReLU'>Leaky ReLU activation function</h2><span id='topic+lReLU'></span>

<h3>Description</h3>

<p>Leaky ReLU activation function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lReLU(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lReLU_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>See Also</h3>

<p>Other Activation Functions: 
<code><a href="#topic+ELU">ELU</a>()</code>,
<code><a href="#topic+GELU">GELU</a>()</code>,
<code><a href="#topic+PReLU">PReLU</a>()</code>,
<code><a href="#topic+ReLU">ReLU</a>()</code>,
<code><a href="#topic+SELU">SELU</a>()</code>,
<code><a href="#topic+Swish">Swish</a>()</code>,
<code><a href="#topic+dELU">dELU</a>()</code>,
<code><a href="#topic+dGELU">dGELU</a>()</code>,
<code><a href="#topic+dPReLU">dPReLU</a>()</code>,
<code><a href="#topic+dReLU">dReLU</a>()</code>,
<code><a href="#topic+dSELU">dSELU</a>()</code>,
<code><a href="#topic+dSwish">dSwish</a>()</code>,
<code><a href="#topic+dlReLU">dlReLU</a>()</code>,
<code><a href="#topic+dsoftplus">dsoftplus</a>()</code>,
<code><a href="#topic+softplus">softplus</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
lReLU(c(-1, 0, 1))

# Can use in rxode2 as well

r &lt;- rxode2({r &lt;- lReLU(time)})
e &lt;- et(c(-1, 0, 1))
rxSolve(r, e)
</code></pre>

<hr>
<h2 id='meanProbs'>Calculate expected confidence bands or prediction intreval with normal or t sampling distribution</h2><span id='topic+meanProbs'></span><span id='topic+meanProbs.default'></span>

<h3>Description</h3>

<p>The generic function <code>meanProbs</code> produces expected confidence bands
under either the t distribution or the normal sampling
distribution. This uses <code>qnorm()</code> or <code>qt()</code> with the mean and
standard deviation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanProbs(x, ...)

## Default S3 method:
meanProbs(
  x,
  probs = seq(0, 1, 0.25),
  na.rm = FALSE,
  names = TRUE,
  useT = TRUE,
  onlyProbs = TRUE,
  pred = FALSE,
  n = 0L,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="meanProbs_+3A_x">x</code></td>
<td>
<p>numeric vector whose mean and probability based confidence
values are wanted, NA and NaN values are not allowed in numeric
vectors unless na.rm is TRUE.</p>
</td></tr>
<tr><td><code id="meanProbs_+3A_...">...</code></td>
<td>
<p>Arguments passed to default method, allows many
different methods to be applied.</p>
</td></tr>
<tr><td><code id="meanProbs_+3A_probs">probs</code></td>
<td>
<p>numeric vector of probabilities with values in the
interval from 0 to 1 .</p>
</td></tr>
<tr><td><code id="meanProbs_+3A_na.rm">na.rm</code></td>
<td>
<p>logical; if true, any NA and NaN's are removed from
<code>x</code> before the quantiles are computed.</p>
</td></tr>
<tr><td><code id="meanProbs_+3A_names">names</code></td>
<td>
<p>logical; if true, the result has a names attribute.</p>
</td></tr>
<tr><td><code id="meanProbs_+3A_uset">useT</code></td>
<td>
<p>logical; if true, use the t-distribution to calculate
the confidence-based estimates. If false use the normal
distribution to calculate the confidence based estimates.</p>
</td></tr>
<tr><td><code id="meanProbs_+3A_onlyprobs">onlyProbs</code></td>
<td>
<p>logical; if true, only return the probability
based confidence interval estimates, otherwise return</p>
</td></tr>
<tr><td><code id="meanProbs_+3A_pred">pred</code></td>
<td>
<p>logical; if true use the prediction interval instead of
the confidence interval</p>
</td></tr>
<tr><td><code id="meanProbs_+3A_n">n</code></td>
<td>
<p>integer/integerish; this is the n used to calculate the
prediction or confidence interval.  When <code>n=0</code> (default) use the
number of non-<code>NA</code> observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a single probability, p, it uses either:
</p>
<p>mean + qt(p, df=n)*sd/sqrt(n)
</p>
<p>or
</p>
<p>mean + qnorm(p)*sd/sqrt(n)
</p>
<p>The smallest observation corresponds to a probability of 0 and the
largest to a probability of 1 and the mean corresponds to 0.5.
</p>
<p>The mean and standard deviation of the sample is calculated based
on Welford's method for a single pass.
</p>
<p>This is meant to perform in the same way as <code>quantile()</code> so it can
be a drop in replacement for code using <code>quantile()</code> but using
distributional assumptions.
</p>


<h3>Value</h3>

<p>By default the return has the probabilities as names (if
named) with the points where the expected distribution are
located given the sampling mean and standard deviation. If
<code>onlyProbs=FALSE</code> then it would prepend mean, variance, standard
deviation, minimum, maximum and number of non-NA observations.
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
quantile(x&lt;- rnorm(1001))
meanProbs(x)

# Can get some extra statistics if you request onlyProbs=FALSE
meanProbs(x, onlyProbs=FALSE)

x[2] &lt;- NA_real_

meanProbs(x, onlyProbs=FALSE)

quantile(x&lt;- rnorm(42))

meanProbs(x)

meanProbs(x, useT=FALSE)

</code></pre>

<hr>
<h2 id='model.function'>Model block for rxode2/nlmixr models</h2><span id='topic+model.function'></span><span id='topic+model.rxUi'></span><span id='topic+model.rxode2'></span><span id='topic+model.rxModelVars'></span><span id='topic+model'></span><span id='topic+model.default'></span>

<h3>Description</h3>

<p>Model block for rxode2/nlmixr models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class ''function''
model(
  x,
  ...,
  append = NULL,
  auto = getOption("rxode2.autoVarPiping", TRUE),
  cov = NULL,
  envir = parent.frame()
)

## S3 method for class 'rxUi'
model(
  x,
  ...,
  append = NULL,
  auto = getOption("rxode2.autoVarPiping", TRUE),
  cov = NULL,
  envir = parent.frame()
)

## S3 method for class 'rxode2'
model(
  x,
  ...,
  append = NULL,
  auto = getOption("rxode2.autoVarPiping", TRUE),
  cov = NULL,
  envir = parent.frame()
)

## S3 method for class 'rxModelVars'
model(
  x,
  ...,
  append = NULL,
  auto = getOption("rxode2.autoVarPiping", TRUE),
  cov = NULL,
  envir = parent.frame()
)

model(
  x,
  ...,
  append = FALSE,
  auto = getOption("rxode2.autoVarPiping", TRUE),
  cov = NULL,
  envir = parent.frame()
)

## Default S3 method:
model(x, ..., append = FALSE, cov = NULL, envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model.function_+3A_x">x</code></td>
<td>
<p>model expression</p>
</td></tr>
<tr><td><code id="model.function_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
<tr><td><code id="model.function_+3A_append">append</code></td>
<td>
<p>This is a boolean to determine if the lines are
appended in piping.  The possible values for this is:
</p>

<ul>
<li> <p><code>TRUE</code> which is when the lines are appended to the model instead of replaced
</p>
</li>
<li> <p><code>FALSE</code> when the lines are replaced in the model (default)
</p>
</li>
<li> <p><code>NA</code> is when the lines are pre-pended to the model instead of replaced
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;lhs expression&#8288;</code>, which will append the lines after the last observed line of the expression <code>lhs</code>
</p>
</li></ul>
</td></tr>
<tr><td><code id="model.function_+3A_auto">auto</code></td>
<td>
<p>This boolean tells if piping automatically selects the
parameters should be characterized as a population parameter,
between subject variability, or a covariate.  When <code>TRUE</code> this
automatic selection occurs.  When <code>FALSE</code> this automatic
selection is turned off and everything is added as a covariate
(which can be promoted to a parameter with the <code>ini</code> statement).
By default this is <code>TRUE</code>, but it can be changed by
<code>options(rxode2.autoVarPiping=FALSE)</code>.</p>
</td></tr>
<tr><td><code id="model.function_+3A_cov">cov</code></td>
<td>
<p>is a character vector of variables that should be
assumed to be covariates.  This will override automatic promotion
to a population parameter estimate (or an eta)</p>
</td></tr>
<tr><td><code id="model.function_+3A_envir">envir</code></td>
<td>
<p>the <code>environment</code> in which unevaluated model
expressions is to be evaluated.  May also be <code>NULL</code>, a list, a
data frame, a pairlist or an integer as specified to <code>sys.call</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Model block with ini information included.  <code>ini</code> must be
called before <code>model</code> block
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='model+26lt+3B-'>Assign the model block in the rxode2 related object</h2><span id='topic+model+3C-'></span>

<h3>Description</h3>

<p>Assign the model block in the rxode2 related object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>model(x, envir = environment(x)) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>rxode2 related object</p>
</td></tr>
<tr><td><code id="model+2B26lt+2B3B-_+3A_envir">envir</code></td>
<td>
<p>Environment where assignment occurs</p>
</td></tr>
<tr><td><code id="model+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>Value of the object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rxode2 related object
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='modelExtract'>Extract model lines from a rxui model</h2><span id='topic+modelExtract'></span><span id='topic+modelExtract.function'></span><span id='topic+modelExtract.rxUi'></span><span id='topic+modelExtract.rxode2'></span><span id='topic+modelExtract.rxModelVars'></span><span id='topic+modelExtract.default'></span>

<h3>Description</h3>

<p>Extract model lines from a rxui model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modelExtract(
  x,
  ...,
  expression = FALSE,
  endpoint = FALSE,
  lines = FALSE,
  envir = parent.frame()
)

## S3 method for class ''function''
modelExtract(
  x,
  ...,
  expression = FALSE,
  endpoint = FALSE,
  lines = FALSE,
  envir = parent.frame()
)

## S3 method for class 'rxUi'
modelExtract(
  x,
  ...,
  expression = FALSE,
  endpoint = FALSE,
  lines = FALSE,
  envir = parent.frame()
)

## S3 method for class 'rxode2'
modelExtract(
  x,
  ...,
  expression = FALSE,
  endpoint = FALSE,
  lines = FALSE,
  envir = parent.frame()
)

## S3 method for class 'rxModelVars'
modelExtract(
  x,
  ...,
  expression = FALSE,
  endpoint = FALSE,
  lines = FALSE,
  envir = parent.frame()
)

## Default S3 method:
modelExtract(
  x,
  ...,
  expression = FALSE,
  endpoint = FALSE,
  lines = FALSE,
  envir = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modelExtract_+3A_x">x</code></td>
<td>
<p>model to extract lines from</p>
</td></tr>
<tr><td><code id="modelExtract_+3A_...">...</code></td>
<td>
<p>variables to extract. When it is missing, it will
extract the entire model (conditioned on the endpoint option
below)</p>
</td></tr>
<tr><td><code id="modelExtract_+3A_expression">expression</code></td>
<td>
<p>return expressions (if <code>TRUE</code>) or strings (if
<code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="modelExtract_+3A_endpoint">endpoint</code></td>
<td>
<p>include endpoint.  This can be:
</p>

<ul>
<li> <p><code>NA</code>    &ndash; Missing means include both the endpoint and non-endpoint lines
</p>
</li>
<li> <p><code>TRUE</code>  &ndash; Only include endpoint lines
</p>
</li>
<li> <p><code>FALSE</code> &ndash; Only include non-endpoint lines
</p>
</li></ul>
</td></tr>
<tr><td><code id="modelExtract_+3A_lines">lines</code></td>
<td>
<p>is a boolean.  When <code>TRUE</code> this will add the lines as
an attribute to the output value ie <code>attr(, "lines")</code></p>
</td></tr>
<tr><td><code id="modelExtract_+3A_envir">envir</code></td>
<td>
<p>Environment for evaluating variables</p>
</td></tr>
</table>


<h3>Value</h3>

<p>expressions or strings of extracted lines. Note if there is
a duplicated lhs expression in the line, it will return both
lines
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
one.compartment &lt;- function() {
  ini({
    tka &lt;- 0.45 # Log Ka
    tcl &lt;- 1 # Log Cl
    tv &lt;- 3.45    # Log V
    eta.ka ~ 0.6
    eta.cl ~ 0.3
    eta.v ~ 0.1
    add.sd &lt;- 0.7
  })
  model({
    ka &lt;- exp(tka + eta.ka)
    cl &lt;- exp(tcl + eta.cl)
    v  &lt;- exp(tv + eta.v)
    d/dt(depot)  &lt;- -ka * depot
    d/dt(center) &lt;-  ka * depot - cl / v * center
    cp &lt;- center / v
    cp ~ add(add.sd)
  })
 }

 f &lt;- one.compartment()

 modelExtract(f, cp)

 modelExtract(one.compartment, d/dt(depot))

 # from variable
 var &lt;- "d/dt(depot)"

 modelExtract(one.compartment, var)

 modelExtract(f, endpoint=NA, lines=TRUE, expression=TRUE)

</code></pre>

<hr>
<h2 id='odeMethodToInt'>Conversion between character and integer ODE integration methods for rxode2</h2><span id='topic+odeMethodToInt'></span>

<h3>Description</h3>

<p>If <code>NULL</code> is given as the method, all choices are returned as a named
vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>odeMethodToInt(method = c("liblsoda", "lsoda", "dop853", "indLin"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="odeMethodToInt_+3A_method">method</code></td>
<td>
<p>The method for solving ODEs.  Currently this supports:
</p>

<ul>
<li> <p><code>"liblsoda"</code> thread safe lsoda.  This supports parallel
thread-based solving, and ignores user Jacobian specification.
</p>
</li>
<li> <p><code>"lsoda"</code> &ndash; LSODA solver.  Does not support parallel thread-based
solving, but allows user Jacobian specification.
</p>
</li>
<li> <p><code>"dop853"</code> &ndash; DOP853 solver.  Does not support parallel thread-based
solving nor user Jacobian specification
</p>
</li>
<li> <p><code>"indLin"</code> &ndash; Solving through inductive linearization.  The rxode2 dll
must be setup specially to use this solving routine.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer for the method (unless the input is NULL, in which case,
see the details)
</p>

<hr>
<h2 id='phi'>Cumulative distribution of standard normal</h2><span id='topic+phi'></span>

<h3>Description</h3>

<p>Cumulative distribution of standard normal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phi(q)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="phi_+3A_q">q</code></td>
<td>
<p>vector of quantiles</p>
</td></tr>
</table>


<h3>Value</h3>

<p>cumulative distribution of standard normal distribution
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# phi is equivalent to pnorm(x)
phi(3)

# See
pnorm(3)

# This is provided for NONMEM-like compatibility in rxode2 models
</code></pre>

<hr>
<h2 id='plot.rxSolve'>Plot rxode2 objects</h2><span id='topic+plot.rxSolve'></span><span id='topic+plot.rxSolveConfint1'></span><span id='topic+plot.rxSolveConfint2'></span>

<h3>Description</h3>

<p>Plot rxode2 objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rxSolve'
plot(x, y, ..., log = "", xlab = "Time", ylab = "")

## S3 method for class 'rxSolveConfint1'
plot(x, y, ..., xlab = "Time", ylab = "", log = "")

## S3 method for class 'rxSolveConfint2'
plot(x, y, ..., xlab = "Time", ylab = "", log = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.rxSolve_+3A_x">x</code></td>
<td>
<p>rxode2 object to plot</p>
</td></tr>
<tr><td><code id="plot.rxSolve_+3A_y">y</code></td>
<td>
<p>Compartments or left-hand-side values to plot either as a bare name
or as a character vector</p>
</td></tr>
<tr><td><code id="plot.rxSolve_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="plot.rxSolve_+3A_log">log</code></td>
<td>
<p>Should &quot;&quot; (neither x nor y), &quot;x&quot;, &quot;y&quot;, or &quot;xy&quot; (or &quot;yx&quot;) be
log-scale?</p>
</td></tr>
<tr><td><code id="plot.rxSolve_+3A_xlab">xlab</code>, <code id="plot.rxSolve_+3A_ylab">ylab</code></td>
<td>
<p>The x and y axis labels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot2 object
</p>


<h3>See Also</h3>

<p>Other rxode2 plotting: 
<code><a href="#topic+rxTheme">rxTheme</a>()</code>
</p>

<hr>
<h2 id='PReLU'>Parametric ReLU Activation Function</h2><span id='topic+PReLU'></span>

<h3>Description</h3>

<p>Parametric ReLU Activation Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PReLU(x, alpha = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PReLU_+3A_x">x</code></td>
<td>
<p>A numeric vector. All elements must be finite and
non-missing.</p>
</td></tr>
<tr><td><code id="PReLU_+3A_alpha">alpha</code></td>
<td>
<p>A numeric scalar. All elements must be finite and
non-missing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector where the ReLU function has been applied
to each element of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>


<h3>See Also</h3>

<p>Other Activation Functions: 
<code><a href="#topic+ELU">ELU</a>()</code>,
<code><a href="#topic+GELU">GELU</a>()</code>,
<code><a href="#topic+ReLU">ReLU</a>()</code>,
<code><a href="#topic+SELU">SELU</a>()</code>,
<code><a href="#topic+Swish">Swish</a>()</code>,
<code><a href="#topic+dELU">dELU</a>()</code>,
<code><a href="#topic+dGELU">dGELU</a>()</code>,
<code><a href="#topic+dPReLU">dPReLU</a>()</code>,
<code><a href="#topic+dReLU">dReLU</a>()</code>,
<code><a href="#topic+dSELU">dSELU</a>()</code>,
<code><a href="#topic+dSwish">dSwish</a>()</code>,
<code><a href="#topic+dlReLU">dlReLU</a>()</code>,
<code><a href="#topic+dsoftplus">dsoftplus</a>()</code>,
<code><a href="#topic+lReLU">lReLU</a>()</code>,
<code><a href="#topic+softplus">softplus</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
PReLU(c(-1, 0, 1, 2), 2)

# Can also be used in rxode2:
x &lt;- rxode2({
   r=PReLU(time, 2)
})

e &lt;- et(c(-1, 0, 1, 2))

rxSolve(x, e)

</code></pre>

<hr>
<h2 id='print.rxCoef'>Print the rxCoef object</h2><span id='topic+print.rxCoef'></span>

<h3>Description</h3>

<p>This prints out the user supplied arguments for rxCoef object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rxCoef'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.rxCoef_+3A_x">x</code></td>
<td>
<p>rxCoef object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>original object
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>

<hr>
<h2 id='print.rxDll'>Print rxDll object</h2><span id='topic+print.rxDll'></span>

<h3>Description</h3>

<p>This tells if the rxDll is loaded, ready and/or deleted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rxDll'
print(x, ...)
</code></pre>


<h3>Value</h3>

<p>original object
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>

<hr>
<h2 id='print.rxModelVars'>Print Values</h2><span id='topic+print.rxModelVars'></span>

<h3>Description</h3>

<p><code>print</code> prints its argument and returns it <em>invisibly</em> (via
<code><a href="base.html#topic+invisible">invisible</a>(x)</code>).  It is a generic function which means that
new printing methods can be easily added for new <code><a href="base.html#topic+class">class</a></code>es.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rxModelVars'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.rxModelVars_+3A_x">x</code></td>
<td>
<p>an object used to select a method.</p>
</td></tr>
<tr><td><code id="print.rxModelVars_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default method, <code><a href="base.html#topic+print.default">print.default</a></code> has its own help page.
Use <code><a href="utils.html#topic+methods">methods</a>("print")</code> to get all the methods for the
<code>print</code> generic.
</p>
<p><code>print.factor</code> allows some customization and is used for printing
<code><a href="base.html#topic+ordered">ordered</a></code> factors as well.
</p>
<p><code>print.table</code> for printing <code><a href="base.html#topic+table">table</a></code>s allows other
customization.  As of R 3.0.0, it only prints a description in case of a table
with 0-extents (this can happen if a classifier has no valid data).
</p>
<p>See <code><a href="base.html#topic+noquote">noquote</a></code> as an example of a class whose main
purpose is a specific <code>print</code> method.
</p>


<h3>Value</h3>

<p>This returns invisibly the model variables object
</p>


<h3>References</h3>

<p>Chambers, J. M. and Hastie, T. J. (1992)
<em>Statistical Models in S.</em>
Wadsworth &amp; Brooks/Cole.
</p>


<h3>See Also</h3>

<p>The default method <code><a href="base.html#topic+print.default">print.default</a></code>, and help for the
methods above; further <code><a href="base.html#topic+options">options</a></code>, <code><a href="base.html#topic+noquote">noquote</a></code>.
</p>
<p>For more customizable (but cumbersome) printing, see
<code><a href="base.html#topic+cat">cat</a></code>, <code><a href="base.html#topic+format">format</a></code> or also <code><a href="base.html#topic+write">write</a></code>.
For a simple prototypical print method, see
<code><a href="tools.html#topic+print.via.format">.print.via.format</a></code> in package <span class="pkg">tools</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(stats)

ts(1:20)  #-- print is the "Default function" --&gt; print.ts(.) is called
for(i in 1:3) print(1:i)

## Printing of factors
attenu$station ## 117 levels -&gt; 'max.levels' depending on width

## ordered factors: levels  "l1 &lt; l2 &lt; .."
esoph$agegp[1:12]
esoph$alcgp[1:12]

## Printing of sparse (contingency) tables
set.seed(521)
t1 &lt;- round(abs(rt(200, df = 1.8)))
t2 &lt;- round(abs(rt(200, df = 1.4)))
table(t1, t2) # simple
print(table(t1, t2), zero.print = ".") # nicer to read

## same for non-integer "table":
T &lt;- table(t2,t1)
T &lt;- T * (1+round(rlnorm(length(T)))/4)
print(T, zero.print = ".") # quite nicer,
print.table(T[,2:8] * 1e9, digits=3, zero.print = ".")
## still slightly inferior to  Matrix::Matrix(T)  for larger T

## Corner cases with empty extents:
table(1, NA) # &lt; table of extent 1 x 0 &gt;
</code></pre>

<hr>
<h2 id='print.rxode2'>Print information about the rxode2 object.</h2><span id='topic+print.rxode2'></span>

<h3>Description</h3>

<p>This prints the model name and its status for being able to be solved
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rxode2'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.rxode2_+3A_x">x</code></td>
<td>
<p>An rxode2 object</p>
</td></tr>
<tr><td><code id="print.rxode2_+3A_...">...</code></td>
<td>
<p>Ignored parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>original object
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>

<hr>
<h2 id='probit'>probit and inverse probit functions</h2><span id='topic+probit'></span><span id='topic+probitInv'></span>

<h3>Description</h3>

<p>probit and inverse probit functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probit(x, low = 0, high = 1)

probitInv(x, low = 0, high = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="probit_+3A_x">x</code></td>
<td>
<p>Input value(s) in range [low,high] to translate -Inf to
Inf</p>
</td></tr>
<tr><td><code id="probit_+3A_low">low</code></td>
<td>
<p>Lowest value in the range</p>
</td></tr>
<tr><td><code id="probit_+3A_high">high</code></td>
<td>
<p>Highest value in the range</p>
</td></tr>
</table>


<h3>Value</h3>

<p>values from probit, probitInv and probitNormInfo
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
probit(0.25)

probitInv(-0.674)

probitNormInfo(probit(0.25), sd = 0.1)

probitNormInfo(probit(1, 0, 10), sd = 1, low = 0, high = 10)
</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+scale_type'></span><span id='topic+ggplot'></span><span id='topic+aes'></span><span id='topic+geom_line'></span><span id='topic+facet_wrap'></span><span id='topic+ylab'></span><span id='topic+xlab'></span><span id='topic+waiver'></span><span id='topic+lotri'></span><span id='topic+label_value'></span><span id='topic+label_both'></span><span id='topic+label_context'></span><span id='topic+label_wrap_gen'></span><span id='topic+scale_x_discrete'></span><span id='topic+scale_y_discrete'></span><span id='topic+scale_x_continuous'></span><span id='topic+scale_y_continuous'></span><span id='topic+scale_x_date'></span><span id='topic+scale_y_date'></span><span id='topic+expand_limits'></span><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>ggplot2</dt><dd><p><code><a href="ggplot2.html#topic+aes">aes</a></code>, <code><a href="ggplot2.html#topic+expand_limits">expand_limits</a></code>, <code><a href="ggplot2.html#topic+facet_wrap">facet_wrap</a></code>, <code><a href="ggplot2.html#topic+geom_path">geom_line</a></code>, <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>, <code><a href="ggplot2.html#topic+labellers">label_both</a></code>, <code><a href="ggplot2.html#topic+labellers">label_context</a></code>, <code><a href="ggplot2.html#topic+labellers">label_context</a></code>, <code><a href="ggplot2.html#topic+labellers">label_value</a></code>, <code><a href="ggplot2.html#topic+labellers">label_wrap_gen</a></code>, <code><a href="ggplot2.html#topic+scale_type">scale_type</a></code>, <code><a href="ggplot2.html#topic+scale_continuous">scale_x_continuous</a></code>, <code><a href="ggplot2.html#topic+scale_date">scale_x_date</a></code>, <code><a href="ggplot2.html#topic+scale_discrete">scale_x_discrete</a></code>, <code><a href="ggplot2.html#topic+scale_continuous">scale_y_continuous</a></code>, <code><a href="ggplot2.html#topic+scale_date">scale_y_date</a></code>, <code><a href="ggplot2.html#topic+scale_discrete">scale_y_discrete</a></code>, <code><a href="ggplot2.html#topic+waiver">waiver</a></code>, <code><a href="ggplot2.html#topic+labs">xlab</a></code>, <code><a href="ggplot2.html#topic+labs">ylab</a></code></p>
</dd>
<dt>lotri</dt><dd><p><code><a href="lotri.html#topic+lotri">lotri</a></code></p>
</dd>
<dt>magrittr</dt><dd><p><code><a href="magrittr.html#topic+pipe">%&gt;%</a></code></p>
</dd>
</dl>


<h3>Value</h3>

<p> Inherited from parent routine </p>

<hr>
<h2 id='ReLU'>Rectified Linear Unit (ReLU) Activation Function</h2><span id='topic+ReLU'></span>

<h3>Description</h3>

<p>This function applies the Rectified Linear Unit (ReLU) activation function to the input numeric vector.
The ReLU function is defined as the positive part of its argument: <code class="reqn">f(x) = max(0, x)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReLU(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ReLU_+3A_x">x</code></td>
<td>
<p>A numeric vector. All elements must be finite and
non-missing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector where the ReLU function has been applied
to each element of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>


<h3>See Also</h3>

<p>Other Activation Functions: 
<code><a href="#topic+ELU">ELU</a>()</code>,
<code><a href="#topic+GELU">GELU</a>()</code>,
<code><a href="#topic+PReLU">PReLU</a>()</code>,
<code><a href="#topic+SELU">SELU</a>()</code>,
<code><a href="#topic+Swish">Swish</a>()</code>,
<code><a href="#topic+dELU">dELU</a>()</code>,
<code><a href="#topic+dGELU">dGELU</a>()</code>,
<code><a href="#topic+dPReLU">dPReLU</a>()</code>,
<code><a href="#topic+dReLU">dReLU</a>()</code>,
<code><a href="#topic+dSELU">dSELU</a>()</code>,
<code><a href="#topic+dSwish">dSwish</a>()</code>,
<code><a href="#topic+dlReLU">dlReLU</a>()</code>,
<code><a href="#topic+dsoftplus">dsoftplus</a>()</code>,
<code><a href="#topic+lReLU">lReLU</a>()</code>,
<code><a href="#topic+softplus">softplus</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ReLU(c(-1, 0, 1, 2))

# Can also be used in rxode2:
x &lt;- rxode2({
   r=ReLU(time)
})

e &lt;- et(c(-1, 0, 1, 2))

rxSolve(x, e)

</code></pre>

<hr>
<h2 id='rinvchisq'>Scaled Inverse Chi Squared distribution</h2><span id='topic+rinvchisq'></span>

<h3>Description</h3>

<p>Scaled Inverse Chi Squared distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rinvchisq(n = 1L, nu = 1, scale = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rinvchisq_+3A_n">n</code></td>
<td>
<p>Number of random samples</p>
</td></tr>
<tr><td><code id="rinvchisq_+3A_nu">nu</code></td>
<td>
<p>degrees of freedom of inverse chi square</p>
</td></tr>
<tr><td><code id="rinvchisq_+3A_scale">scale</code></td>
<td>
<p>Scale of inverse chi squared distribution
(default is 1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector of inverse chi squared deviates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rinvchisq(3, 4, 1) ## Scale = 1, degrees of freedom = 4
rinvchisq(2, 4, 2) ## Scale = 2, degrees of freedom = 4
</code></pre>

<hr>
<h2 id='rLKJ1'>One correlation sample from the LKJ distribution</h2><span id='topic+rLKJ1'></span>

<h3>Description</h3>

<p>One correlation sample from the LKJ distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rLKJ1(d, eta = 1, cholesky = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rLKJ1_+3A_d">d</code></td>
<td>
<p>The dimension of the correlation matrix</p>
</td></tr>
<tr><td><code id="rLKJ1_+3A_eta">eta</code></td>
<td>
<p>The scaling parameter of the LKJ distribution.
Must be &gt; 1.  Also related to the degrees of freedom nu.
eta = (nu-1)/2.</p>
</td></tr>
<tr><td><code id="rLKJ1_+3A_cholesky">cholesky</code></td>
<td>
<p>boolean; If <code>TRUE</code> return the cholesky
decomposition.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A correlation sample from the LKJ distribution
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler (translated to RcppArmadillo) and Emma Schwager
</p>

<hr>
<h2 id='rxAllowUnload'>Allow unloading of dlls</h2><span id='topic+rxAllowUnload'></span>

<h3>Description</h3>

<p>Allow unloading of dlls
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxAllowUnload(allow)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxAllowUnload_+3A_allow">allow</code></td>
<td>
<p>boolean indicating if garbage collection will unload of rxode2 dlls.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean allow; called for side effects
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Garbage collection will not unload un-used rxode2 dlls
rxAllowUnload(FALSE);

# Garbage collection will unload unused rxode2 dlls
rxAllowUnload(TRUE);
</code></pre>

<hr>
<h2 id='rxAppendModel'>Append two rxui models together</h2><span id='topic+rxAppendModel'></span>

<h3>Description</h3>

<p>Append two rxui models together
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxAppendModel(..., common = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxAppendModel_+3A_...">...</code></td>
<td>
<p>models to append together</p>
</td></tr>
<tr><td><code id="rxAppendModel_+3A_common">common</code></td>
<td>
<p>boolean that determines if you need a common value to bind</p>
</td></tr>
</table>


<h3>Value</h3>

<p>New model with both models appended together
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


ocmt &lt;- function() {
  ini({
    tka &lt;- exp(0.45) # Ka
    tcl &lt;- exp(1) # Cl
    tv &lt;- exp(3.45); # log V
    ## the label("Label name") works with all models
    add.sd &lt;- 0.7
  })
  model({
    ka &lt;- tka
    cl &lt;- tcl
    v &lt;- tv
    d/dt(depot) &lt;- -ka * depot
    d/dt(center) &lt;- ka * depot - cl / v * center
    cp &lt;- center / v
    cp ~ add(add.sd)
  })
}

idr &lt;- function() {
  ini({
    tkin &lt;- log(1)
    tkout &lt;- log(1)
    tic50 &lt;- log(10)
    gamma &lt;- fix(1)
    idr.sd &lt;- 1
  })
  model({
    kin &lt;- exp(tkin)
    kout &lt;- exp(tkout)
    ic50 &lt;- exp(tic50)
    d/dt(eff) &lt;- kin - kout*(1-ceff^gamma/(ic50^gamma+ceff^gamma))
    eff ~ add(idr.sd)
  })
}

rxAppendModel(ocmt %&gt;% model(ceff=cp,append=TRUE), idr)



</code></pre>

<hr>
<h2 id='rxAssignControlValue'>Assign Control Variable</h2><span id='topic+rxAssignControlValue'></span>

<h3>Description</h3>

<p>Assign Control Variable
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxAssignControlValue(ui, option, value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxAssignControlValue_+3A_ui">ui</code></td>
<td>
<p>rxode2 ui function</p>
</td></tr>
<tr><td><code id="rxAssignControlValue_+3A_option">option</code></td>
<td>
<p>Option name in the control to modify</p>
</td></tr>
<tr><td><code id="rxAssignControlValue_+3A_value">value</code></td>
<td>
<p>Value of control to modify</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing; called for the side effects
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxAssignPtr'>Assign pointer based on model variables</h2><span id='topic+rxAssignPtr'></span>

<h3>Description</h3>

<p>Assign pointer based on model variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxAssignPtr(object = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxAssignPtr_+3A_object">object</code></td>
<td>
<p>rxode2 family of objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing, called for side effects
</p>

<hr>
<h2 id='rxbeta'>Simulate beta variable from threefry generator</h2><span id='topic+rxbeta'></span>

<h3>Description</h3>

<p>Care should be taken with this method not to encounter the
birthday problem, described
<a href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/">https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/</a>.
Since the <code>sitmo</code> <code>threefry</code>, this currently generates
one random deviate from the uniform distribution to seed the
engine <code>threefry</code> and then run the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxbeta(shape1, shape2, n = 1L, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxbeta_+3A_shape1">shape1</code>, <code id="rxbeta_+3A_shape2">shape2</code></td>
<td>
<p>non-negative parameters of the Beta distribution.</p>
</td></tr>
<tr><td><code id="rxbeta_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="rxbeta_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the simulation
</p>
<p><code>rxnorm</code> simulates using the threefry sitmo generator.
</p>
<p><code>rxnormV</code> used to simulate with the vandercorput simulator, but
since it didn't satisfy the normal properties it was changed to simple be
an alias of <code>rxnorm</code>. It is no longer supported in <code>rxode2({})</code> blocks</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Therefore, a simple call to the random number generated followed by a second
call to random number generated may have identical seeds.  As the number of
random number generator calls are increased the probability that the
birthday problem will increase.
</p>
<p>The key to avoid this problem is to either run all simulations in the
<code>rxode2</code> environment once (therefore one seed or series of seeds
for the whole simulation), pre-generate all random variables
used for the simulation, or seed the rxode2 engine with <code>rxSetSeed()</code>
</p>
<p>Internally each ID is seeded with a unique number so that the
results do not depend on the number of cores used.
</p>


<h3>Value</h3>

<p>beta random deviates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Use threefry engine

rxbeta(0.5, 0.5, n = 10) # with rxbeta you have to explicitly state n
rxbeta(5, 1, n = 10, ncores = 2) # You can parallelize the simulation using openMP

rxbeta(1, 3)


## This example uses `rxbeta` directly in the model

rx &lt;- function() {
  model({
    a &lt;- rxbeta(2, 2)
  })
}

et &lt;- et(1, id = 1:2)

s &lt;- rxSolve(rx, et)

</code></pre>

<hr>
<h2 id='rxbinom'>Simulate Binomial variable from threefry generator</h2><span id='topic+rxbinom'></span>

<h3>Description</h3>

<p>Care should be taken with this method not to encounter the
birthday problem, described
<a href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/">https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/</a>.
Since the <code>sitmo</code> <code>threefry</code>, this currently generates
one random deviate from the uniform distribution to seed the
engine <code>threefry</code> and then run the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxbinom(size, prob, n = 1L, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxbinom_+3A_size">size</code></td>
<td>
<p>number of trials (zero or more).</p>
</td></tr>
<tr><td><code id="rxbinom_+3A_prob">prob</code></td>
<td>
<p>probability of success on each trial.</p>
</td></tr>
<tr><td><code id="rxbinom_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="rxbinom_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the simulation
</p>
<p><code>rxnorm</code> simulates using the threefry sitmo generator.
</p>
<p><code>rxnormV</code> used to simulate with the vandercorput simulator, but
since it didn't satisfy the normal properties it was changed to simple be
an alias of <code>rxnorm</code>. It is no longer supported in <code>rxode2({})</code> blocks</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Therefore, a simple call to the random number generated followed by a second
call to random number generated may have identical seeds.  As the number of
random number generator calls are increased the probability that the
birthday problem will increase.
</p>
<p>The key to avoid this problem is to either run all simulations in the
<code>rxode2</code> environment once (therefore one seed or series of seeds
for the whole simulation), pre-generate all random variables
used for the simulation, or seed the rxode2 engine with <code>rxSetSeed()</code>
</p>
<p>Internally each ID is seeded with a unique number so that the
results do not depend on the number of cores used.
</p>


<h3>Value</h3>

<p>binomial random deviates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Use threefry engine

rxbinom(10, 0.9, n = 10) # with rxbinom you have to explicitly state n
rxbinom(3, 0.5, n = 10, ncores = 2) # You can parallelize the simulation using openMP

rxbinom(4, 0.7)


## This example uses `rxbinom` directly in the model

rx &lt;- function() {
  model({
    a &lt;- rxbinom(1, 0.5)
  })
}

et &lt;- et(1, id = 1:2)

s &lt;- rxSolve(rx, et)


</code></pre>

<hr>
<h2 id='rxBlockZeros'>Creates a logical matrix for block matrixes.</h2><span id='topic+rxBlockZeros'></span>

<h3>Description</h3>

<p>Creates a logical matrix for block matrixes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxBlockZeros(mat, i)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxBlockZeros_+3A_mat">mat</code></td>
<td>
<p>Matrix</p>
</td></tr>
<tr><td><code id="rxBlockZeros_+3A_i">i</code></td>
<td>
<p>Row/column where block matrix should be setup.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A logical matrix returning where the elements should be
zero.
</p>

<hr>
<h2 id='rxC'>Return the C file associated with the rxode2 object</h2><span id='topic+rxC'></span>

<h3>Description</h3>

<p>This will return C code for generating the rxode2 DLL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxC(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxC_+3A_obj">obj</code></td>
<td>
<p>A rxode2 family of objects or a character string of the
model specification or location of a file with a model
specification.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a path of the library
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>

<hr>
<h2 id='rxCat'>Use cat when rxode2.verbose is TRUE</h2><span id='topic+rxCat'></span>

<h3>Description</h3>

<p>Use cat when rxode2.verbose is TRUE
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxCat(a, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxCat_+3A_...">...</code></td>
<td>
<p>Parameters sent to cat</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxcauchy'>Simulate Cauchy variable from threefry generator</h2><span id='topic+rxcauchy'></span>

<h3>Description</h3>

<p>Care should be taken with this method not to encounter the
birthday problem, described
<a href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/">https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/</a>.
Since the <code>sitmo</code> <code>threefry</code>, this currently generates
one random deviate from the uniform distribution to seed the
engine <code>threefry</code> and then run the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxcauchy(location = 0, scale = 1, n = 1L, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxcauchy_+3A_location">location</code>, <code id="rxcauchy_+3A_scale">scale</code></td>
<td>
<p>location and scale parameters.</p>
</td></tr>
<tr><td><code id="rxcauchy_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="rxcauchy_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the simulation
</p>
<p><code>rxnorm</code> simulates using the threefry sitmo generator.
</p>
<p><code>rxnormV</code> used to simulate with the vandercorput simulator, but
since it didn't satisfy the normal properties it was changed to simple be
an alias of <code>rxnorm</code>. It is no longer supported in <code>rxode2({})</code> blocks</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Therefore, a simple call to the random number generated followed by a second
call to random number generated may have identical seeds.  As the number of
random number generator calls are increased the probability that the
birthday problem will increase.
</p>
<p>The key to avoid this problem is to either run all simulations in the
<code>rxode2</code> environment once (therefore one seed or series of seeds
for the whole simulation), pre-generate all random variables
used for the simulation, or seed the rxode2 engine with <code>rxSetSeed()</code>
</p>
<p>Internally each ID is seeded with a unique number so that the
results do not depend on the number of cores used.
</p>


<h3>Value</h3>

<p>Cauchy random deviates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Use threefry engine

rxcauchy(0, 1, n = 10) # with rxcauchy you have to explicitly state n
rxcauchy(0.5, n = 10, ncores = 2) # You can parallelize the simulation using openMP

rxcauchy(3)


## This example uses `rxcauchy` directly in the model

rx &lt;- function() {
  model({
    a &lt;- rxcauchy(2)
  })
}

et &lt;- et(1, id = 1:2)

s &lt;- rxSolve(rx, et)


</code></pre>

<hr>
<h2 id='rxCbindStudyIndividual'>Bind the study parameters and individual parameters</h2><span id='topic+rxCbindStudyIndividual'></span>

<h3>Description</h3>

<p>Bind the study parameters and individual parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxCbindStudyIndividual(studyParameters, individualParameters)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxCbindStudyIndividual_+3A_studyparameters">studyParameters</code></td>
<td>
<p>These are the study parameters, often can
be generated by sampling from a population.  This can be either
a matrix or a data frame</p>
</td></tr>
<tr><td><code id="rxCbindStudyIndividual_+3A_individualparameters">individualParameters</code></td>
<td>
<p>A data frame of individual parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Data frame that can be used in rxode2 simulations
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Function for coverting coefficient of covariance into a variance
lognCv &lt;- function(x){log((x/100)^2+1)}

set.seed(32)

nSub  &lt;-  100
nStud  &lt;-  10

#define theta
theta &lt;- c(lka=log(0.5), # log ka
          lCl=log(5), # log Cl
          lV=log(300) # log V
          )

#define theta Matrix
thetaMat &lt;- lotri(lCl ~ lognCv(5),
                 lV  ~ lognCv(5),
                 lka ~ lognCv(5))


nev &lt;- nSub*nStud

ev1 &lt;- data.frame(COV1=rnorm(nev,50,30),COV2=rnorm(nev,75,10),
                  COV3=sample(c(1.0,2.0),nev,replace=TRUE))


tmat &lt;-rxRmvn(nStud, theta[dimnames(thetaMat)[[1]]], thetaMat)

rxCbindStudyIndividual(tmat, ev1)

</code></pre>

<hr>
<h2 id='rxChain'>rxChain  Chain or add item to solved system of equations</h2><span id='topic+rxChain'></span><span id='topic++2B.solveRxDll'></span>

<h3>Description</h3>

<p>Add item to solved system of equations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxChain(obj1, obj2)

## S3 method for class 'solveRxDll'
obj1 + obj2
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxChain_+3A_obj1">obj1</code></td>
<td>
<p>Solved object.</p>
</td></tr>
<tr><td><code id="rxChain_+3A_obj2">obj2</code></td>
<td>
<p>New object to be added/piped/chained to solved object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When <code>newObject</code> is an event table, return a new
solved object with the new event table.
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxChain2'>Second command in chaining commands</h2><span id='topic+rxChain2'></span><span id='topic+rxChain2.default'></span><span id='topic+rxChain2.EventTable'></span>

<h3>Description</h3>

<p>This is s3 method is called internally with <code>+</code> and <code style="white-space: pre;">&#8288;\%&gt;\%&#8288;</code> operators.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxChain2(obj, solvedObject)

## Default S3 method:
rxChain2(obj, solvedObject)

## S3 method for class 'EventTable'
rxChain2(obj, solvedObject)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxChain2_+3A_obj">obj</code></td>
<td>
<p>the object being added/chained/piped to the solved object</p>
</td></tr>
<tr><td><code id="rxChain2_+3A_solvedobject">solvedObject</code></td>
<td>
<p>the solved object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>chained operation
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>

<hr>
<h2 id='rxchisq'>Simulate chi-squared variable from threefry generator</h2><span id='topic+rxchisq'></span>

<h3>Description</h3>

<p>Care should be taken with this method not to encounter the
birthday problem, described
<a href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/">https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/</a>.
Since the <code>sitmo</code> <code>threefry</code>, this currently generates
one random deviate from the uniform distribution to seed the
engine <code>threefry</code> and then run the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxchisq(df, n = 1L, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxchisq_+3A_df">df</code></td>
<td>
<p>degrees of freedom (non-negative, but can be non-integer).</p>
</td></tr>
<tr><td><code id="rxchisq_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="rxchisq_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the simulation
</p>
<p><code>rxnorm</code> simulates using the threefry sitmo generator.
</p>
<p><code>rxnormV</code> used to simulate with the vandercorput simulator, but
since it didn't satisfy the normal properties it was changed to simple be
an alias of <code>rxnorm</code>. It is no longer supported in <code>rxode2({})</code> blocks</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Therefore, a simple call to the random number generated followed by a second
call to random number generated may have identical seeds.  As the number of
random number generator calls are increased the probability that the
birthday problem will increase.
</p>
<p>The key to avoid this problem is to either run all simulations in the
<code>rxode2</code> environment once (therefore one seed or series of seeds
for the whole simulation), pre-generate all random variables
used for the simulation, or seed the rxode2 engine with <code>rxSetSeed()</code>
</p>
<p>Internally each ID is seeded with a unique number so that the
results do not depend on the number of cores used.
</p>


<h3>Value</h3>

<p>chi squared random deviates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Use threefry engine

rxchisq(0.5, n = 10) # with rxchisq you have to explicitly state n
rxchisq(5, n = 10, ncores = 2) # You can parallelize the simulation using openMP

rxchisq(1)


## This example uses `rxchisq` directly in the model

rx &lt;- function() {
  model({
    a &lt;- rxchisq(2)
  })
}

et &lt;- et(1, id = 1:2)

s &lt;- rxSolve(rx, et)


</code></pre>

<hr>
<h2 id='rxClean'>Cleanup anonymous DLLs by unloading them</h2><span id='topic+rxClean'></span>

<h3>Description</h3>

<p>This cleans up any rxode2 loaded DLLs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxClean(wd)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxClean_+3A_wd">wd</code></td>
<td>
<p>What directory should be cleaned; (DEPRECIATED), this no
longer does anything.
</p>
<p>This unloads all rxode2 anonymous dlls.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if successful
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxCombineErrorLines'>Combine Error Lines and create rxode2 expression</h2><span id='topic+rxCombineErrorLines'></span>

<h3>Description</h3>

<p>Combine Error Lines and create rxode2 expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxCombineErrorLines(
  uiModel,
  errLines = NULL,
  prefixLines = NULL,
  paramsLine = NULL,
  modelVars = FALSE,
  cmtLines = TRUE,
  dvidLine = TRUE,
  lstExpr = NULL,
  useIf = TRUE,
  interpLines = NULL,
  levelLines = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxCombineErrorLines_+3A_uimodel">uiModel</code></td>
<td>
<p>UI model</p>
</td></tr>
<tr><td><code id="rxCombineErrorLines_+3A_errlines">errLines</code></td>
<td>
<p>Error lines; If missing, get the error lines from
<code>rxGetDistributionSimulationLines()</code></p>
</td></tr>
<tr><td><code id="rxCombineErrorLines_+3A_prefixlines">prefixLines</code></td>
<td>
<p>Prefix lines, after param statement</p>
</td></tr>
<tr><td><code id="rxCombineErrorLines_+3A_paramsline">paramsLine</code></td>
<td>
<p>Params line, if not present.</p>
</td></tr>
<tr><td><code id="rxCombineErrorLines_+3A_modelvars">modelVars</code></td>
<td>
<p>Return model vars instead of rxode2 statement</p>
</td></tr>
<tr><td><code id="rxCombineErrorLines_+3A_cmtlines">cmtLines</code></td>
<td>
<p>Include trailing <code>cmt</code> lines</p>
</td></tr>
<tr><td><code id="rxCombineErrorLines_+3A_dvidline">dvidLine</code></td>
<td>
<p>Include trailing <code>dvid()</code> specification</p>
</td></tr>
<tr><td><code id="rxCombineErrorLines_+3A_lstexpr">lstExpr</code></td>
<td>
<p>A list of expressions for model, or NULL.  When NULL
defaults to the model expressions accessible by
<code>uiModel$lstExpr</code>.</p>
</td></tr>
<tr><td><code id="rxCombineErrorLines_+3A_useif">useIf</code></td>
<td>
<p>Use an <code style="white-space: pre;">&#8288;if (CMT == X)&#8288;</code> for endpoints</p>
</td></tr>
<tr><td><code id="rxCombineErrorLines_+3A_interplines">interpLines</code></td>
<td>
<p>Interpolation lines, if not present</p>
</td></tr>
<tr><td><code id="rxCombineErrorLines_+3A_levellines">levelLines</code></td>
<td>
<p>Levels lines for assigned strings.  If not
present, use the interpolation lines from the current model.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is exported to allow other functions to mangle the error lines
to make other types of estimation methods (if needed)
</p>


<h3>Value</h3>

<p>quoted expression that can be evaluated to compiled rxode2
model
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


one.cmt &lt;- function() {
  ini({
    ## You may label each parameter with a comment
    tka &lt;- 0.45 # Log Ka
    tcl &lt;- log(c(0, 2.7, 100)) # Log Cl
    ## This works with interactive models
    ## You may also label the preceding line with label("label text")
    tv &lt;- 3.45; label("log V")
    ## the label("Label name") works with all models
    eta.ka ~ 0.6
    eta.cl ~ 0.3
    eta.v ~ 0.1
    add.sd &lt;- 0.7
  })
  model({
    ka &lt;- exp(tka + eta.ka)
    cl &lt;- exp(tcl + eta.cl)
    v &lt;- exp(tv + eta.v)
    linCmt() ~ add(add.sd)
  })
}

f &lt;- rxode2(one.cmt)

# You can get the simulation model easily by
rxCombineErrorLines(f)

# You can then get the compiled model by simply evaluting the model:
r &lt;- eval(rxCombineErrorLines(f))

# This also works with multile endpoint models:
pk.turnover.emax &lt;- function() {
  ini({
    tktr &lt;- log(1)
    tka &lt;- log(1)
    tcl &lt;- log(0.1)
    tv &lt;- log(10)
    ##
    eta.ktr ~ 1
    eta.ka ~ 1
    eta.cl ~ 2
    eta.v ~ 1
    prop.err &lt;- 0.1
    pkadd.err &lt;- 0.1
    ##
    temax &lt;- logit(0.8)
    tec50 &lt;- log(0.5)
    tkout &lt;- log(0.05)
    te0 &lt;- log(100)
    ##
    eta.emax ~ .5
    eta.ec50  ~ .5
    eta.kout ~ .5
    eta.e0 ~ .5
    ##
    pdadd.err &lt;- 10
  })
  model({
    ktr &lt;- exp(tktr + eta.ktr)
    ka &lt;- exp(tka + eta.ka)
    cl &lt;- exp(tcl + eta.cl)
    v &lt;- exp(tv + eta.v)
    ##
    emax=expit(temax+eta.emax)
    ec50 =  exp(tec50 + eta.ec50)
    kout = exp(tkout + eta.kout)
    e0 = exp(te0 + eta.e0)
    ##
    DCP = center/v
    PD=1-emax*DCP/(ec50+DCP)
    ##
    effect(0) = e0
    kin = e0*kout
    ##
    d/dt(depot) = -ktr * depot
    d/dt(gut) =  ktr * depot -ka * gut
    d/dt(center) =  ka * gut - cl / v * center
    d/dt(effect) = kin*PD -kout*effect
    ##
    cp = center / v
    cp ~ prop(prop.err) + add(pkadd.err)
    effect ~ add(pdadd.err)
  })
}

f &lt;- rxode2(pk.turnover.emax)
rxCombineErrorLines(f)

# Note that in the parsed form, you can also get the compiled rxode2
# model with $simulationModel

f$simulationModel


</code></pre>

<hr>
<h2 id='rxCompile'>Compile a model if needed</h2><span id='topic+rxCompile'></span><span id='topic+rxCompile.rxModelVars'></span><span id='topic+rxCompile.character'></span><span id='topic+rxCompile.rxDll'></span><span id='topic+rxCompile.rxode2'></span>

<h3>Description</h3>

<p>This is the compilation workhorse creating the rxode2 model DLL
files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxCompile(
  model,
  dir,
  prefix,
  force = FALSE,
  modName = NULL,
  package = NULL,
  ...
)

## S3 method for class 'rxModelVars'
rxCompile(
  model,
  dir = NULL,
  prefix = NULL,
  force = FALSE,
  modName = NULL,
  package = NULL,
  ...
)

## S3 method for class 'character'
rxCompile(
  model,
  dir = NULL,
  prefix = NULL,
  force = FALSE,
  modName = NULL,
  package = NULL,
  ...
)

## S3 method for class 'rxDll'
rxCompile(model, ...)

## S3 method for class 'rxode2'
rxCompile(model, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxCompile_+3A_model">model</code></td>
<td>
<p>This is the ODE model specification.  It can be:
</p>

<ul>
<li><p> a string containing the set of ordinary differential
equations (ODE) and other expressions defining the changes in
the dynamic system.
</p>
</li>
<li><p> a file name where the ODE system equation is contained
</p>
</li></ul>

<p>An ODE expression enclosed in <code style="white-space: pre;">&#8288;\{\}&#8288;</code>
</p>
<p>(see also the <code>filename</code> argument). For
details, see the sections &ldquo;Details&rdquo; and
<code style="white-space: pre;">&#8288;rxode2 Syntax&#8288;</code> below.</p>
</td></tr>
<tr><td><code id="rxCompile_+3A_dir">dir</code></td>
<td>
<p>This is the model directory where the C file will be
stored for compiling.
</p>
<div class="sourceCode"><pre>If unspecified, the C code is stored in a temporary directory,
then the model is compiled and moved to the current directory.
Afterwards the C code is removed.

If specified, the C code is stored in the specified directory
and then compiled in that directory.  The C code is not removed
after the DLL is created in the same directory.  This can be
useful to debug the c-code outputs.
</pre></div></td></tr>
<tr><td><code id="rxCompile_+3A_prefix">prefix</code></td>
<td>
<p>is a string indicating the prefix to use in the C
based functions.  If missing, it is calculated based on file
name, or md5 of parsed model.</p>
</td></tr>
<tr><td><code id="rxCompile_+3A_force">force</code></td>
<td>
<p>is a boolean stating if the (re)compile should be
forced if rxode2 detects that the models are the same as already
generated.</p>
</td></tr>
<tr><td><code id="rxCompile_+3A_modname">modName</code></td>
<td>
<p>a string to be used as the model name. This string
is used for naming various aspects of the computations,
including generating C symbol names, dynamic libraries,
etc. Therefore, it is necessary that <code>modName</code> consists of
simple ASCII alphanumeric characters starting with a letter.</p>
</td></tr>
<tr><td><code id="rxCompile_+3A_package">package</code></td>
<td>
<p>Package name for pre-compiled binaries.</p>
</td></tr>
<tr><td><code id="rxCompile_+3A_...">...</code></td>
<td>
<p>Other arguments sent to the <code><a href="#topic+rxTrans">rxTrans()</a></code>
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An rxDll object that has the following components
</p>

<ul>
<li> <p><code>dll</code> DLL path
</p>
</li>
<li> <p><code>model</code> model specification
</p>
</li>
<li> <p><code>.c</code> A function to call C code in the correct context from the DLL
using the <code><a href="base.html#topic+.C">.C()</a></code> function.
</p>
</li>
<li> <p><code>.call</code> A function to call C code in the correct context from the DLL
using the <code><a href="base.html#topic+.Call">.Call()</a></code> function.
</p>
</li>
<li> <p><code>args</code> A list of the arguments used to create the rxDll object.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rxode2">rxode2()</a></code>
</p>

<hr>
<h2 id='rxCondition'>Current Condition for rxode2 object</h2><span id='topic+rxCondition'></span>

<h3>Description</h3>

<p>Current Condition for rxode2 object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxCondition(obj, condition = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxCondition_+3A_obj">obj</code></td>
<td>
<p>rxode2 object</p>
</td></tr>
<tr><td><code id="rxCondition_+3A_condition">condition</code></td>
<td>
<p>If specified and is one of the conditions in the
rxode2 object (as determined by <code><a href="#topic+rxExpandIfElse">rxExpandIfElse()</a></code>),
assign the rxode2 current condition to this parameter.  If the
condition is not one of the known condition, the condition is
set to <code>NULL</code>, implying no conditioning currently used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Current condition for rxode2 object
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxControlUpdateSens'>This updates the tolerances based on the sensitivity equations</h2><span id='topic+rxControlUpdateSens'></span>

<h3>Description</h3>

<p>This assumes the normal ODE equations are the first equations and
the ODE is expanded by the forward sensitivities or other type of
sensitivity (like adjoint)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxControlUpdateSens(rxControl, sensCmt = NULL, ncmt = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxControlUpdateSens_+3A_rxcontrol">rxControl</code></td>
<td>
<p>Input list or rxControl type of list</p>
</td></tr>
<tr><td><code id="rxControlUpdateSens_+3A_senscmt">sensCmt</code></td>
<td>
<p>Number of sensitivity compartments</p>
</td></tr>
<tr><td><code id="rxControlUpdateSens_+3A_ncmt">ncmt</code></td>
<td>
<p>Number of compartments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Updated rxControl where <code style="white-space: pre;">&#8288;$atol&#8288;</code>, <code style="white-space: pre;">&#8288;$rtol&#8288;</code>, <code style="white-space: pre;">&#8288;$ssAtol&#8288;</code>
<code style="white-space: pre;">&#8288;$ssRtol&#8288;</code> are updated with different sensitivities for the normal
ODEs (first) and a different sensitivity for the larger
compartments (sensitivities).
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
tmp &lt;- rxControl()

tmp2 &lt;- rxControlUpdateSens(tmp, 3, 6)

tmp2$atol
tmp2$rtol
tmp2$ssAtol
tmp2$ssRtol
</code></pre>

<hr>
<h2 id='rxCreateCache'>This will create the cache directory for rxode2 to save between sessions</h2><span id='topic+rxCreateCache'></span>

<h3>Description</h3>

<p>When run, if the <code>R_user_dir</code> for rxode2's cache isn't present,
create the cache
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxCreateCache()
</code></pre>


<h3>Value</h3>

<p>nothing
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='rxD'>Add to rxode2's derivative tables</h2><span id='topic+rxD'></span>

<h3>Description</h3>

<p>Add to rxode2's derivative tables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxD(name, derivatives)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxD_+3A_name">name</code></td>
<td>
<p>Function Name</p>
</td></tr>
<tr><td><code id="rxD_+3A_derivatives">derivatives</code></td>
<td>
<p>A list of functions. Each function takes the
same number of arguments as the original function.  The first
function will construct the derivative with respect to the
first argument; The second function will construct the
derivitive with respect to the second argument, and so on.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Add an arbitrary list of derivative functions
## In this case the fun(x,y) is assumed to be 0.5*x^2+0.5*y^2

rxD("fun", list(
  function(x, y) {
    return(x)
  },
  function(x, y) {
    return(y)
  }
))
</code></pre>

<hr>
<h2 id='rxDelete'>Delete the DLL for the model</h2><span id='topic+rxDelete'></span>

<h3>Description</h3>

<p>This function deletes the DLL, but doesn't delete the model
information in the object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxDelete(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxDelete_+3A_obj">obj</code></td>
<td>
<p>rxode2 family of objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean stating if the operation was successful.
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>

<hr>
<h2 id='rxDemoteAddErr'>Demote the error type</h2><span id='topic+rxDemoteAddErr'></span>

<h3>Description</h3>

<p>Demote the error type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxDemoteAddErr(errType)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxDemoteAddErr_+3A_errtype">errType</code></td>
<td>
<p>Error type factor</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Demoted Error Type
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rxErrTypeCombine("add") %&gt;%
  rxErrTypeCombine("prop")

# This removes the internal additive error
rxErrTypeCombine("add") %&gt;%
  rxErrTypeCombine("prop") %&gt;%
  rxDemoteAddErr()

# This is used for logitNorm(NA), the additive portion is stripped

</code></pre>

<hr>
<h2 id='rxDerived'>Calculate derived parameters for the 1-, 2-, and 3- compartment
linear models.</h2><span id='topic+rxDerived'></span>

<h3>Description</h3>

<p>This calculates the derived parameters based on what is provided
in a data frame or arguments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxDerived(..., verbose = FALSE, digits = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxDerived_+3A_...">...</code></td>
<td>
<p>The input can be:
</p>

<ul>
<li><p> A data frame with PK parameters in it; This should ideally
be a data frame with one pk parameter per row since it will
output a data frame with one PK parameter per row.
</p>
</li>
<li><p> PK parameters as either a vector or a scalar
</p>
</li></ul>
</td></tr>
<tr><td><code id="rxDerived_+3A_verbose">verbose</code></td>
<td>
<p>boolean that when TRUE provides a message about the detected pk parameters
and the detected compartmental model.  By default this is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="rxDerived_+3A_digits">digits</code></td>
<td>
<p>represents the number of significant digits for the
output; If the number is zero or below (default), do not round.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a data.frame of derived PK parameters for a 1-, 2-,
or 3-compartment linear model given provided clearances and
volumes based on the inferred model type.
</p>
<p>The model parameters that will be provided in the data frame are:
</p>

<ul>
<li> <p><code>vc</code>: Central Volume (for 1-, 2- and 3-
compartment models)
</p>
</li>
<li> <p><code>kel</code>: First-order elimination rate (for 1-, 2-, and
3-compartment models)
</p>
</li>
<li> <p><code>k12</code>: First-order rate of transfer from central to
first peripheral compartment; (for 2- and 3-compartment models)
</p>
</li>
<li> <p><code>k21</code>: First-order rate of transfer from first
peripheral to central compartment, (for 2- and 3-compartment
models)
</p>
</li>
<li> <p><code>k13</code>: First-order rate of transfer from central to
second peripheral compartment; (3-compartment model)
</p>
</li>
<li> <p><code>k31</code>: First-order rate of transfer from second
peripheral to central compartment (3-compartment model)
</p>
</li>
<li> <p><code>vp</code>: Peripheral Volume (for 2- and 3- compartment models)
</p>
</li>
<li> <p><code>vp2</code>: Peripheral Volume for 3rd compartment (3- compartment model)
</p>
</li>
<li> <p><code>vss</code>: Volume of distribution at steady state; (1-, 2-, and 3-compartment models)
</p>
</li>
<li> <p><code>t12alpha</code>: <code class="reqn">t_{1/2,\alpha}</code>; (1-, 2-, and 3-compartment models)
</p>
</li>
<li> <p><code>t12beta</code>: <code class="reqn">t_{1/2,\beta}</code>; (2- and 3-compartment models)
</p>
</li>
<li> <p><code>t12gamma</code>: <code class="reqn">t_{1/2,\gamma}</code>; (3-compartment model)
</p>
</li>
<li> <p><code>alpha</code>: <code class="reqn">\alpha</code>; (1-, 2-, and 3-compartment models)
</p>
</li>
<li> <p><code>beta</code>: <code class="reqn">\beta</code>; (2- and 3-compartment models)
</p>
</li>
<li> <p><code>gamma</code>: <code class="reqn">\beta</code>; (3-compartment model)
</p>
</li>
<li> <p><code>A</code>: true <code>A</code>; (1-, 2-, and 3-compartment models)
</p>
</li>
<li> <p><code>B</code>: true <code>B</code>; (2- and 3-compartment models)
</p>
</li>
<li> <p><code>C</code>: true <code>C</code>; (3-compartment model)
</p>
</li>
<li> <p><code>fracA</code>: fractional A; (1-, 2-, and 3-compartment models)
</p>
</li>
<li> <p><code>fracB</code>: fractional B; (2- and 3-compartment models)
</p>
</li>
<li> <p><code>fracC</code>: fractional C; (3-compartment model)
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Matthew Fidler and documentation from Justin Wilkins, <a href="mailto:justin.wilkins@occams.com">justin.wilkins@occams.com</a>
</p>


<h3>References</h3>

<p>Shafer S. L. <code>CONVERT.XLS</code>
</p>
<p>Rowland M, Tozer TN. Clinical Pharmacokinetics and Pharmacodynamics: Concepts and Applications (4th). Clipping Williams &amp; Wilkins, Philadelphia, 2010.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Note that rxode2 parses the names to figure out the best PK parameter

params &lt;- rxDerived(cl = 29.4, v = 23.4, Vp = 114, vp2 = 4614, q = 270, q2 = 73)

## That is why this gives the same results as the value before

params &lt;- rxDerived(CL = 29.4, V1 = 23.4, V2 = 114, V3 = 4614, Q2 = 270, Q3 = 73)

## You may also use micro-constants alpha/beta etc.

params &lt;- rxDerived(k12 = 0.1, k21 = 0.2, k13 = 0.3, k31 = 0.4, kel = 10, v = 10)

## or you can mix vectors and scalars

params &lt;- rxDerived(CL = 29.4, V = 1:3)

## If you want, you can round to a number of significant digits
## with the `digits` argument:

params &lt;- rxDerived(CL = 29.4, V = 1:3, digits = 2)
</code></pre>

<hr>
<h2 id='rxDfdy'>Jacobian and parameter derivatives</h2><span id='topic+rxDfdy'></span>

<h3>Description</h3>

<p>Return Jacobain and parameter derivatives
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxDfdy(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxDfdy_+3A_obj">obj</code></td>
<td>
<p>rxode2 family of objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the jacobian parameters defined in this rxode2
object.
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>See Also</h3>

<p>Other Query model information: 
<code><a href="#topic+rxInits">rxInits</a>()</code>,
<code><a href="#topic+rxLhs">rxLhs</a>()</code>,
<code><a href="#topic+rxModelVars">rxModelVars</a>()</code>,
<code><a href="#topic+rxParams">rxParams</a>()</code>,
<code><a href="#topic+rxState">rxState</a>()</code>
</p>

<hr>
<h2 id='rxDll'>Return the DLL associated with the rxode2 object</h2><span id='topic+rxDll'></span>

<h3>Description</h3>

<p>This will return the dynamic load library or shared object used to
run the C code for rxode2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxDll(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxDll_+3A_obj">obj</code></td>
<td>
<p>A rxode2 family of objects or a character string of the
model specification or location of a file with a model
specification.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a path of the library
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>

<hr>
<h2 id='rxDynLoad'>Load rxode2 object</h2><span id='topic+rxDynLoad'></span><span id='topic+rxLoad'></span>

<h3>Description</h3>

<p>Load rxode2 object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxDynLoad(obj)

rxLoad(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxDynLoad_+3A_obj">obj</code></td>
<td>
<p>A rxode2 family of objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean returning if the rxode2 library is loaded.
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>

<hr>
<h2 id='rxDynUnload'>Unload rxode2 object</h2><span id='topic+rxDynUnload'></span><span id='topic+rxUnload'></span>

<h3>Description</h3>

<p>Unload rxode2 object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxDynUnload(obj)

rxUnload(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxDynUnload_+3A_obj">obj</code></td>
<td>
<p>A rxode2 family of objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean returning if the rxode2 library is loaded.
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>

<hr>
<h2 id='rxErrTypeCombine'>Combine transformations and error structures</h2><span id='topic+rxErrTypeCombine'></span>

<h3>Description</h3>

<p>Combine error information to figure out what transformation is
being applied for the current endpoint
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxErrTypeCombine(oldErrType, newErrType)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxErrTypeCombine_+3A_olderrtype">oldErrType</code></td>
<td>
<p>This is the old transformation, by default is
zero representing no prior transformation. This parameter is
first to allow piping. When the parameter <code>addTransform</code> is
missing and <code>oldErrType</code> is a character value, this functions
swaps <code>oldErrType</code> and <code>addTransform</code> and assigns
<code>oldErrType</code> to zero assuming that there is no prior
distribution.</p>
</td></tr>
<tr><td><code id="rxErrTypeCombine_+3A_newerrtype">newErrType</code></td>
<td>
<p>This is the new distribution that is being
&quot;added&quot; to the current transformation.  These assumes the inputs
are in the preferred distribution name, as determined by
<code>rxPreferredDistributionName()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The new transformation as a factor
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rxErrTypeCombine("probitNorm")

rxErrTypeCombine("probitNorm") %&gt;%
  rxErrTypeCombine("boxCox")


</code></pre>

<hr>
<h2 id='rxEtDispatchSolve'>Dispatch solve to 'rxode2' solve</h2><span id='topic+rxEtDispatchSolve'></span><span id='topic+rxEtDispatchSolve.default'></span>

<h3>Description</h3>

<p>Dispatch solve to 'rxode2' solve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxEtDispatchSolve(x, ...)

## Default S3 method:
rxEtDispatchSolve(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxEtDispatchSolve_+3A_x">x</code></td>
<td>
<p>rxode2 solve dispatch object</p>
</td></tr>
<tr><td><code id="rxEtDispatchSolve_+3A_...">...</code></td>
<td>
<p>other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>if 'rxode2'  is loaded, a solved object, otherwise an error
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxEvid'>EVID formatting for tibble and other places.</h2><span id='topic+rxEvid'></span><span id='topic+as.rxEvid'></span><span id='topic+c.rxEvid'></span><span id='topic++5B.rxEvid'></span><span id='topic+as.character.rxEvid'></span><span id='topic++5B+5B.rxEvid'></span><span id='topic+units+3C-.rxEvid'></span><span id='topic+c.rxRateDur'></span><span id='topic+format.rxEvid'></span><span id='topic+format.rxRateDur'></span><span id='topic+print.rxEvid'></span>

<h3>Description</h3>

<p>This is to make an EVID more readable by non
pharmacometricians. It displays what each means and allows it to
be displayed in a tibble.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxEvid(x)

as.rxEvid(x)

## S3 method for class 'rxEvid'
c(x, ...)

## S3 method for class 'rxEvid'
x[...]

## S3 method for class 'rxEvid'
as.character(x, ...)

## S3 method for class 'rxEvid'
x[[...]]

## S3 replacement method for class 'rxEvid'
units(x) &lt;- value

## S3 method for class 'rxRateDur'
c(x, ...)

## S3 method for class 'rxEvid'
format(x, ...)

## S3 method for class 'rxRateDur'
format(x, ...)

## S3 method for class 'rxEvid'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxEvid_+3A_x">x</code></td>
<td>
<p>Item to be converted to a rxode2 EVID specification.</p>
</td></tr>
<tr><td><code id="rxEvid_+3A_...">...</code></td>
<td>
<p>Other parameters</p>
</td></tr>
<tr><td><code id="rxEvid_+3A_value">value</code></td>
<td>
<p>It will be an error to set units for evid</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rxEvid specification
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rxEvid(1:7)
</code></pre>

<hr>
<h2 id='rxexp'>Simulate exponential variable from threefry generator</h2><span id='topic+rxexp'></span>

<h3>Description</h3>

<p>Care should be taken with this method not to encounter the
birthday problem, described
<a href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/">https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/</a>.
Since the <code>sitmo</code> <code>threefry</code>, this currently generates
one random deviate from the uniform distribution to seed the
engine <code>threefry</code> and then run the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxexp(rate, n = 1L, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxexp_+3A_rate">rate</code></td>
<td>
<p>vector of rates.</p>
</td></tr>
<tr><td><code id="rxexp_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="rxexp_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the simulation
</p>
<p><code>rxnorm</code> simulates using the threefry sitmo generator.
</p>
<p><code>rxnormV</code> used to simulate with the vandercorput simulator, but
since it didn't satisfy the normal properties it was changed to simple be
an alias of <code>rxnorm</code>. It is no longer supported in <code>rxode2({})</code> blocks</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Therefore, a simple call to the random number generated followed by a second
call to random number generated may have identical seeds.  As the number of
random number generator calls are increased the probability that the
birthday problem will increase.
</p>
<p>The key to avoid this problem is to either run all simulations in the
<code>rxode2</code> environment once (therefore one seed or series of seeds
for the whole simulation), pre-generate all random variables
used for the simulation, or seed the rxode2 engine with <code>rxSetSeed()</code>
</p>
<p>Internally each ID is seeded with a unique number so that the
results do not depend on the number of cores used.
</p>


<h3>Value</h3>

<p>exponential random deviates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Use threefry engine

rxexp(0.5, n = 10) # with rxexp you have to explicitly state n
rxexp(5, n = 10, ncores = 2) # You can parallelize the simulation using openMP

rxexp(1)


## This example uses `rxexp` directly in the model

rx &lt;- function() {
  model({
    a &lt;- rxexp(2)
  })
}

et &lt;- et(1, id = 1:2)

s &lt;- rxSolve(rx, et)


</code></pre>

<hr>
<h2 id='rxExpandFEta_'>Expand d(f)/d(eta)</h2><span id='topic+rxExpandFEta_'></span>

<h3>Description</h3>

<p>Expand d(f)/d(eta)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxExpandFEta_(state, neta, pred, isTheta = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxExpandFEta__+3A_state">state</code></td>
<td>
<p>is the state to expand</p>
</td></tr>
<tr><td><code id="rxExpandFEta__+3A_neta">neta</code></td>
<td>
<p>is the number of etas</p>
</td></tr>
<tr><td><code id="rxExpandFEta__+3A_pred">pred</code></td>
<td>
<p>type of prediction</p>
</td></tr>
<tr><td><code id="rxExpandFEta__+3A_istheta">isTheta</code></td>
<td>
<p>logical, is the expansion actually for thetas instead of etas</p>
</td></tr>
</table>


<h3>Value</h3>

<p>String of symengine expressions to evaluate to calculate df/deta
</p>

<hr>
<h2 id='rxExpandGrid'>Faster expand.grid</h2><span id='topic+rxExpandGrid'></span>

<h3>Description</h3>

<p>Only support x and y as characters right now
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxExpandGrid(x, y, type = 0L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxExpandGrid_+3A_x">x</code></td>
<td>
<p>first element (must be character)</p>
</td></tr>
<tr><td><code id="rxExpandGrid_+3A_y">y</code></td>
<td>
<p>second element (must be character)</p>
</td></tr>
<tr><td><code id="rxExpandGrid_+3A_type">type</code></td>
<td>
<p>Internal type=0L is traditional expand grid and
type=1L is Jacobian expand grid (adds symbols)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Expand grid
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##
rxExpandGrid(letters, letters)

## Another fast method; See
## https://stackoverflow.com/questions/10405637/use-outer-instead-of-expand-grid

expand.grid.jc &lt;- function(seq1, seq2) {
  cbind(
    Var1 = rep.int(seq1, length(seq2)),
    Var2 = rep.int(seq2, rep.int(length(seq1), length(seq2)))
  )
}

microbenchmark::microbenchmark(rxExpandGrid(letters, letters), expand.grid.jc(letters, letters))

</code></pre>

<hr>
<h2 id='rxExpandGrid_'>Expand grid internal function</h2><span id='topic+rxExpandGrid_'></span>

<h3>Description</h3>

<p>Expand grid internal function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxExpandGrid_(c1, c2, type)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxExpandGrid__+3A_c1">c1</code></td>
<td>
<p>character vector of items to be expanded</p>
</td></tr>
<tr><td><code id="rxExpandGrid__+3A_c2">c2</code></td>
<td>
<p>second character vector of items to be expanded</p>
</td></tr>
<tr><td><code id="rxExpandGrid__+3A_type">type</code></td>
<td>
<p>0 for a typical data frame, 1 for symengine sensitivity expansion</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame (when type = 0) or symengine string (when type=1)
</p>

<hr>
<h2 id='rxExpandIfElse'>Expand if/else clauses into multiple different types of lines.</h2><span id='topic+rxExpandIfElse'></span>

<h3>Description</h3>

<p>Expand if/else clauses into multiple different types of lines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxExpandIfElse(model, removeInis = TRUE, removePrint = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxExpandIfElse_+3A_model">model</code></td>
<td>
<p>Model can be a character, or a rxode2 model.  It needs
to have normalized syntax, that is <code>if (...){}</code> has to be
on the same line.  The <code style="white-space: pre;">&#8288;else&#8288;</code> statement must be on its
own line with the closing bracket of the <code>if</code> statement
on the previous line.  This <code style="white-space: pre;">&#8288;else&#8288;</code> statment must also
contain the opening bracket, like the code <code style="white-space: pre;">&#8288;else {}&#8288;</code></p>
</td></tr>
<tr><td><code id="rxExpandIfElse_+3A_removeinis">removeInis</code></td>
<td>
<p>A boolean indicating if parameter
initializations should be removed from the model.</p>
</td></tr>
<tr><td><code id="rxExpandIfElse_+3A_removeprint">removePrint</code></td>
<td>
<p>A boolean indicating if printing statements
should be removed from the model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named character vector. The names of the vector are the
logical conditions, the values are the lines that satisfy the
logical conditions.
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxExpandSens_'>Expand sensitivity</h2><span id='topic+rxExpandSens_'></span>

<h3>Description</h3>

<p>Expand sensitivity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxExpandSens_(state, calcSens)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxExpandSens__+3A_state">state</code></td>
<td>
<p>is the state to expand</p>
</td></tr>
<tr><td><code id="rxExpandSens__+3A_calcsens">calcSens</code></td>
<td>
<p>is the variables to calculate sensitivity</p>
</td></tr>
</table>


<h3>Value</h3>

<p>symengine string for expanded sensitivity
</p>

<hr>
<h2 id='rxExpandSens2_'>Expand second order sensitivity</h2><span id='topic+rxExpandSens2_'></span>

<h3>Description</h3>

<p>Expand second order sensitivity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxExpandSens2_(state, s1, s2)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxExpandSens2__+3A_state">state</code></td>
<td>
<p>is the state to expand</p>
</td></tr>
<tr><td><code id="rxExpandSens2__+3A_s1">s1</code></td>
<td>
<p>is the variables to calculate sensitivity</p>
</td></tr>
<tr><td><code id="rxExpandSens2__+3A_s2">s2</code></td>
<td>
<p>is the variables to calculate second order sensitivity</p>
</td></tr>
</table>


<h3>Value</h3>

<p>string for symengine second order sensitivity
</p>

<hr>
<h2 id='rxf'>Simulate F variable from threefry generator</h2><span id='topic+rxf'></span>

<h3>Description</h3>

<p>Care should be taken with this method not to encounter the
birthday problem, described
<a href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/">https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/</a>.
Since the <code>sitmo</code> <code>threefry</code>, this currently generates
one random deviate from the uniform distribution to seed the
engine <code>threefry</code> and then run the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxf(df1, df2, n = 1L, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxf_+3A_df1">df1</code>, <code id="rxf_+3A_df2">df2</code></td>
<td>
<p>degrees of freedom.  <code>Inf</code> is allowed.</p>
</td></tr>
<tr><td><code id="rxf_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="rxf_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the simulation
</p>
<p><code>rxnorm</code> simulates using the threefry sitmo generator.
</p>
<p><code>rxnormV</code> used to simulate with the vandercorput simulator, but
since it didn't satisfy the normal properties it was changed to simple be
an alias of <code>rxnorm</code>. It is no longer supported in <code>rxode2({})</code> blocks</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Therefore, a simple call to the random number generated followed by a second
call to random number generated may have identical seeds.  As the number of
random number generator calls are increased the probability that the
birthday problem will increase.
</p>
<p>The key to avoid this problem is to either run all simulations in the
<code>rxode2</code> environment once (therefore one seed or series of seeds
for the whole simulation), pre-generate all random variables
used for the simulation, or seed the rxode2 engine with <code>rxSetSeed()</code>
</p>
<p>Internally each ID is seeded with a unique number so that the
results do not depend on the number of cores used.
</p>


<h3>Value</h3>

<p>f random deviates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Use threefry engine

rxf(0.5, 0.5, n = 10) # with rxf you have to explicitly state n
rxf(5, 1, n = 10, ncores = 2) # You can parallelize the simulation using openMP

rxf(1, 3)


## This example uses `rxf` directly in the model

rx &lt;- function() {
  model({
    a &lt;- rxf(2, 2)
  })
}

et &lt;- et(1, id = 1:2)

s &lt;- rxSolve(rx, et)


</code></pre>

<hr>
<h2 id='rxFixPop'>Apply the fixed population estimated parameters</h2><span id='topic+rxFixPop'></span>

<h3>Description</h3>

<p>Apply the fixed population estimated parameters
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxFixPop(ui, returnNull = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxFixPop_+3A_ui">ui</code></td>
<td>
<p>rxode2 ui function</p>
</td></tr>
<tr><td><code id="rxFixPop_+3A_returnnull">returnNull</code></td>
<td>
<p>boolean for if unchanged values should return the
original ui (<code>FALSE</code>) or null (<code>TRUE</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>when <code>returnNull</code> is TRUE, NULL if nothing was changed, or
the changed model ui.  When <code>returnNull</code> is FALSE, return a ui no
matter if it is changed or not.
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
One.comp.transit.allo &lt;- function() {
 ini({
   # Where initial conditions/variables are specified
   lktr &lt;- log(1.15)  #log k transit (/h)
   lcl  &lt;- log(0.15)  #log Cl (L/hr)
   lv   &lt;- log(7)     #log V (L)
   ALLC &lt;- fix(0.75)  #allometric exponent cl
   ALLV &lt;- fix(1.00)  #allometric exponent v
   prop.err &lt;- 0.15   #proportional error (SD/mean)
   add.err &lt;- 0.6     #additive error (mg/L)
   eta.ktr ~ 0.5
   eta.cl ~ 0.1
   eta.v ~ 0.1
 })
 model({
   #Allometric scaling on weight
   cl &lt;- exp(lcl + eta.cl + ALLC * logWT70)
   v  &lt;- exp(lv + eta.v + ALLV * logWT70)
   ktr &lt;- exp(lktr + eta.ktr)
   # RxODE-style differential equations are supported
   d/dt(depot)   = -ktr * depot
   d/dt(central) =  ktr * trans - (cl/v) * central
   d/dt(trans)   =  ktr * depot - ktr * trans
   ## Concentration is calculated
   cp = central/v
   # And is assumed to follow proportional and additive error
   cp ~ prop(prop.err) + add(add.err)
 })
}

m &lt;- rxFixPop(One.comp.transit.allo)
m

# now everything is already fixed, so calling again will do nothing

rxFixPop(m)

# if you call it with returnNull=TRUE when no changes have been
# performed, the function will return NULL

rxFixPop(m, returnNull=TRUE)

</code></pre>

<hr>
<h2 id='rxForget'>Clear memoise cache for rxode2</h2><span id='topic+rxForget'></span>

<h3>Description</h3>

<p>Clear memoise cache for rxode2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxForget()
</code></pre>


<h3>Value</h3>

<p>nothing; called for side effects
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxFun'>Add/Create C functions for use in rxode2</h2><span id='topic+rxFun'></span><span id='topic+rxRmFun'></span>

<h3>Description</h3>

<p>Add/Create C functions for use in rxode2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxFun(name, args, cCode)

rxRmFun(name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxFun_+3A_name">name</code></td>
<td>
<p>This can either give the name of the user function or
be a simple R function that you wish to convert to C.  If you
have rxode2 convert the R function to C, the name of the function
will match the function name provided and the number of arguments
will match the R function provided.  Hence, if you are providing
an R function for conversion to C, the rest of the arguments are
implied.</p>
</td></tr>
<tr><td><code id="rxFun_+3A_args">args</code></td>
<td>
<p>This gives the arguments of the user function</p>
</td></tr>
<tr><td><code id="rxFun_+3A_ccode">cCode</code></td>
<td>
<p>This is the C-code for the new function</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Right now rxode2 is not aware of the function fun
# Therefore it cannot translate it to symengine or
# Compile a model with it.

try(rxode2("a=fun(a,b,c)"))

# Note for this approach to work, it cannot interfere with C
# function names or reserved rxode2 special terms.  Therefore
# f(x) would not work since f is an alias for bioavailability.

fun &lt;- "
double fun(double a, double b, double c) {
  return a*a+b*a+c;
}
" # C-code for function

rxFun("fun", c("a", "b", "c"), fun) ## Added function

# Now rxode2 knows how to translate this function to symengine

rxToSE("fun(a,b,c)")

# And will take a central difference when calculating derivatives

rxFromSE("Derivative(fun(a,b,c),a)")

## Of course, you could specify the derivative table manually
rxD("fun", list(
  function(a, b, c) {
    paste0("2*", a, "+", b)
  },
  function(a, b, c) {
    return(a)
  },
  function(a, b, c) {
    return("0.0")
  }
))

rxFromSE("Derivative(fun(a,b,c),a)")

# You can also remove the functions by `rxRmFun`

rxRmFun("fun")

# you can also use R functions directly in rxode2


gg &lt;- function(x, y) {
  x + y
}

f &lt;- rxode2({
 z = gg(x, y)
})


e &lt;- et(1:10) |&gt; as.data.frame()

e$x &lt;- 1:10
e$y &lt;- 21:30

rxSolve(f, e)

# Note that since it touches R, it can only run single-threaded.
# There are also requirements for the function:
#
# 1. It accepts one value per argument (numeric)
#
# 2. It returns one numeric value

# If it is a simple function (like gg) you can also convert it to C
# using rxFun and load it into rxode2

rxFun(gg)

rxSolve(f, e)

# to stop the recompile simply reassign the function
f &lt;- rxode2(f)

rxSolve(f, e)

rxRmFun("gg")
rm(gg)
rm(f)


# You can also automatically convert a R function to R code (and
# calculate first derivatives)

fun &lt;- function(a, b, c) {
  a^2+b*a+c
}

rxFun(fun)

# You can see the R code if you want with rxC

message(rxC("fun"))

# you can also remove both the function and the
# derivatives with rxRmFun("fun")

rxRmFun("fun")


</code></pre>

<hr>
<h2 id='rxFunParse'>Add user function to rxode2</h2><span id='topic+rxFunParse'></span><span id='topic+rxRmFunParse'></span>

<h3>Description</h3>

<p>This adds a user function to rxode2 that can be called.  If needed,
these functions can be differentiated by numerical differences or
by adding the derivatives to rxode2's internal derivative table
with rxode2's <code>rxD</code> function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxFunParse(name, args, cCode)

rxRmFunParse(name)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxFunParse_+3A_name">name</code></td>
<td>
<p>This gives the name of the user function</p>
</td></tr>
<tr><td><code id="rxFunParse_+3A_args">args</code></td>
<td>
<p>This gives the arguments of the user function</p>
</td></tr>
<tr><td><code id="rxFunParse_+3A_ccode">cCode</code></td>
<td>
<p>This is the C-code for the new function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxgamma'>Simulate gamma variable from threefry generator</h2><span id='topic+rxgamma'></span>

<h3>Description</h3>

<p>Care should be taken with this method not to encounter the
birthday problem, described
<a href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/">https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/</a>.
Since the <code>sitmo</code> <code>threefry</code>, this currently generates
one random deviate from the uniform distribution to seed the
engine <code>threefry</code> and then run the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxgamma(shape, rate = 1, n = 1L, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxgamma_+3A_shape">shape</code></td>
<td>
<p>The shape of the gamma random variable</p>
</td></tr>
<tr><td><code id="rxgamma_+3A_rate">rate</code></td>
<td>
<p>an alternative way to specify the scale.</p>
</td></tr>
<tr><td><code id="rxgamma_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="rxgamma_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the simulation
</p>
<p><code>rxnorm</code> simulates using the threefry sitmo generator.
</p>
<p><code>rxnormV</code> used to simulate with the vandercorput simulator, but
since it didn't satisfy the normal properties it was changed to simple be
an alias of <code>rxnorm</code>. It is no longer supported in <code>rxode2({})</code> blocks</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Therefore, a simple call to the random number generated followed by a second
call to random number generated may have identical seeds.  As the number of
random number generator calls are increased the probability that the
birthday problem will increase.
</p>
<p>The key to avoid this problem is to either run all simulations in the
<code>rxode2</code> environment once (therefore one seed or series of seeds
for the whole simulation), pre-generate all random variables
used for the simulation, or seed the rxode2 engine with <code>rxSetSeed()</code>
</p>
<p>Internally each ID is seeded with a unique number so that the
results do not depend on the number of cores used.
</p>


<h3>Value</h3>

<p>gamma random deviates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>


## Use threefry engine

rxgamma(0.5, n = 10) # with rxgamma you have to explicitly state n
rxgamma(5, n = 10, ncores = 2) # You can parallelize the simulation using openMP

rxgamma(1)


## This example uses `rxbeta` directly in the model

rx &lt;- function() {
  model({
    a &lt;- rxgamma(2)
  })
}

et &lt;- et(1, id = 1:2)

s &lt;- rxSolve(rx, et)


</code></pre>

<hr>
<h2 id='rxgeom'>Simulate geometric variable from threefry generator</h2><span id='topic+rxgeom'></span>

<h3>Description</h3>

<p>Care should be taken with this method not to encounter the
birthday problem, described
<a href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/">https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/</a>.
Since the <code>sitmo</code> <code>threefry</code>, this currently generates
one random deviate from the uniform distribution to seed the
engine <code>threefry</code> and then run the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxgeom(prob, n = 1L, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxgeom_+3A_prob">prob</code></td>
<td>
<p>probability of success in each trial. <code>0 &lt; prob &lt;= 1</code>.</p>
</td></tr>
<tr><td><code id="rxgeom_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="rxgeom_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the simulation
</p>
<p><code>rxnorm</code> simulates using the threefry sitmo generator.
</p>
<p><code>rxnormV</code> used to simulate with the vandercorput simulator, but
since it didn't satisfy the normal properties it was changed to simple be
an alias of <code>rxnorm</code>. It is no longer supported in <code>rxode2({})</code> blocks</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Therefore, a simple call to the random number generated followed by a second
call to random number generated may have identical seeds.  As the number of
random number generator calls are increased the probability that the
birthday problem will increase.
</p>
<p>The key to avoid this problem is to either run all simulations in the
<code>rxode2</code> environment once (therefore one seed or series of seeds
for the whole simulation), pre-generate all random variables
used for the simulation, or seed the rxode2 engine with <code>rxSetSeed()</code>
</p>
<p>Internally each ID is seeded with a unique number so that the
results do not depend on the number of cores used.
</p>


<h3>Value</h3>

<p>geometric random deviates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Use threefry engine

rxgeom(0.5, n = 10) # with rxgeom you have to explicitly state n
rxgeom(0.25, n = 10, ncores = 2) # You can parallelize the simulation using openMP

rxgeom(0.75)


## This example uses `rxgeom` directly in the model

rx &lt;- function() {
  model({
    a &lt;- rxgeom(0.24)
  })
}

et &lt;- et(1, id = 1:2)

s &lt;- rxSolve(rx, et)


</code></pre>

<hr>
<h2 id='rxGetControl'>rxGetControl option from ui</h2><span id='topic+rxGetControl'></span>

<h3>Description</h3>

<p>rxGetControl option from ui
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxGetControl(ui, option, default)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxGetControl_+3A_ui">ui</code></td>
<td>
<p>rxode2 ui object</p>
</td></tr>
<tr><td><code id="rxGetControl_+3A_option">option</code></td>
<td>
<p>Option to get</p>
</td></tr>
<tr><td><code id="rxGetControl_+3A_default">default</code></td>
<td>
<p>Default value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Option (if present) or default value
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxGetDistributionSimulationLines'>This is a S3 method for getting the distribution lines for a rxode2 simulation</h2><span id='topic+rxGetDistributionSimulationLines'></span><span id='topic+rxGetDistributionSimulationLines.norm'></span><span id='topic+rxGetDistributionSimulationLines.dnorm'></span><span id='topic+rxGetDistributionSimulationLines.t'></span><span id='topic+rxGetDistributionSimulationLines.cauchy'></span><span id='topic+rxGetDistributionSimulationLines.ordinal'></span><span id='topic+rxGetDistributionSimulationLines.default'></span><span id='topic+rxGetDistributionSimulationLines.rxUi'></span>

<h3>Description</h3>

<p>This is a S3 method for getting the distribution lines for a rxode2 simulation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxGetDistributionSimulationLines(line)

## S3 method for class 'norm'
rxGetDistributionSimulationLines(line)

## S3 method for class 'dnorm'
rxGetDistributionSimulationLines(line)

## S3 method for class 't'
rxGetDistributionSimulationLines(line)

## S3 method for class 'cauchy'
rxGetDistributionSimulationLines(line)

## S3 method for class 'ordinal'
rxGetDistributionSimulationLines(line)

## Default S3 method:
rxGetDistributionSimulationLines(line)

## S3 method for class 'rxUi'
rxGetDistributionSimulationLines(line)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxGetDistributionSimulationLines_+3A_line">line</code></td>
<td>
<p>Parsed rxode2 model environment</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Lines for the simulation of <code>ipred</code> and <code>dv</code>. This is based
on the idea that the focei parameters are defined
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='rxGetLin'>Get the linear compartment model true function</h2><span id='topic+rxGetLin'></span>

<h3>Description</h3>

<p>Get the linear compartment model true function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxGetLin(
  model,
  linCmtSens = c("linCmtA", "linCmtB", "linCmtC"),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxGetLin_+3A_model">model</code></td>
<td>
<p>This is the ODE model specification.  It can be:
</p>

<ul>
<li><p> a string containing the set of ordinary differential
equations (ODE) and other expressions defining the changes in
the dynamic system.
</p>
</li>
<li><p> a file name where the ODE system equation is contained
</p>
</li></ul>

<p>An ODE expression enclosed in <code style="white-space: pre;">&#8288;\{\}&#8288;</code>
</p>
<p>(see also the <code>filename</code> argument). For
details, see the sections &ldquo;Details&rdquo; and
<code style="white-space: pre;">&#8288;rxode2 Syntax&#8288;</code> below.</p>
</td></tr>
<tr><td><code id="rxGetLin_+3A_lincmtsens">linCmtSens</code></td>
<td>
<p>The method to calculate the linCmt() solutions</p>
</td></tr>
<tr><td><code id="rxGetLin_+3A_verbose">verbose</code></td>
<td>
<p>When <code>TRUE</code> be verbose with the linear
compartmental model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>model with linCmt() replaced with linCmtA()
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='rxGetModel'>Get model properties without compiling it.</h2><span id='topic+rxGetModel'></span>

<h3>Description</h3>

<p>Get model properties without compiling it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxGetModel(
  model,
  calcSens = NULL,
  calcJac = NULL,
  collapseModel = NULL,
  indLin = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxGetModel_+3A_model">model</code></td>
<td>
<p>rxode2 specification</p>
</td></tr>
<tr><td><code id="rxGetModel_+3A_calcsens">calcSens</code></td>
<td>
<p>boolean indicating if rxode2 will calculate the
sensitivities according to the specified ODEs.</p>
</td></tr>
<tr><td><code id="rxGetModel_+3A_calcjac">calcJac</code></td>
<td>
<p>boolean indicating if rxode2 will calculate the
Jacobain according to the specified ODEs.</p>
</td></tr>
<tr><td><code id="rxGetModel_+3A_collapsemodel">collapseModel</code></td>
<td>
<p>boolean indicating if rxode2 will remove all
LHS variables when calculating sensitivities.</p>
</td></tr>
<tr><td><code id="rxGetModel_+3A_indlin">indLin</code></td>
<td>
<p>Calculate inductive linearization matrices and
compile with inductive linearization support.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rxode2 trans list
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxGetrxode2'>Get rxode2 model from object</h2><span id='topic+rxGetrxode2'></span>

<h3>Description</h3>

<p>Get rxode2 model from object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxGetrxode2(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxGetrxode2_+3A_obj">obj</code></td>
<td>
<p>rxode2 family of objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rxode2 model
</p>

<hr>
<h2 id='rxGetSeed'>Get the rxode2 seed</h2><span id='topic+rxGetSeed'></span>

<h3>Description</h3>

<p>Get the rxode2 seed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxGetSeed()
</code></pre>


<h3>Value</h3>

<p>rxode2 seed state or -1 when the seed isn't set
</p>


<h3>See Also</h3>

<p>rxSetSeed, rxWithSeed, rxWithPreserveSeed
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# without setting seed

rxGetSeed()
# Now set the seed
rxSetSeed(42)

rxGetSeed()

rxnorm()

rxGetSeed()

# don't use the rxode2 seed again

rxSetSeed(-1)

rxGetSeed()

rxnorm()

rxGetSeed()

</code></pre>

<hr>
<h2 id='rxHtml'>Format rxSolve and related objects as html.</h2><span id='topic+rxHtml'></span><span id='topic+rxHtml.rxSolve'></span>

<h3>Description</h3>

<p>Format rxSolve and related objects as html.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxHtml(x, ...)

## S3 method for class 'rxSolve'
rxHtml(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxHtml_+3A_x">x</code></td>
<td>
<p>rxode2 object</p>
</td></tr>
<tr><td><code id="rxHtml_+3A_...">...</code></td>
<td>
<p>Extra arguments sent to kable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>html code for rxSolve object
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxIndLinState'>Set the preferred factoring by state</h2><span id='topic+rxIndLinState'></span>

<h3>Description</h3>

<p>Set the preferred factoring by state
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxIndLinState(preferred = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxIndLinState_+3A_preferred">preferred</code></td>
<td>
<p>A list of each state's preferred factorization</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='rxIndLinStrategy'>This sets the inductive linearization strategy for matrix building</h2><span id='topic+rxIndLinStrategy'></span>

<h3>Description</h3>

<p>When there is more than one state in a ODE that cannot be
separated this specifies how it is incorporated into the matrix
exponential.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxIndLinStrategy(strategy = c("curState", "split"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxIndLinStrategy_+3A_strategy">strategy</code></td>
<td>
<p>The strategy for inductive linearization matrix building
</p>

<ul>
<li> <p><code>curState</code> Prefer parameterizing in terms of the current
state, followed by the first state observed in the term.
</p>
</li>
<li> <p><code>split</code> Split the parameterization between all states in the
term by dividing each by the number of states in the term and then
adding a matrix term for each state.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxInits'>Initial Values and State values for a rxode2 object</h2><span id='topic+rxInits'></span><span id='topic+rxInit'></span>

<h3>Description</h3>

<p>Returns the initial values of the rxDll object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxInits(
  obj,
  vec = NULL,
  req = NULL,
  defaultValue = 0,
  noerror = FALSE,
  noini = FALSE,
  rxLines = FALSE
)

rxInit(
  obj,
  vec = NULL,
  req = NULL,
  defaultValue = 0,
  noerror = FALSE,
  noini = FALSE,
  rxLines = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxInits_+3A_obj">obj</code></td>
<td>
<p>rxDll, rxode2, or named vector representing default
initial arguments</p>
</td></tr>
<tr><td><code id="rxInits_+3A_vec">vec</code></td>
<td>
<p>If supplied, named vector for the model.</p>
</td></tr>
<tr><td><code id="rxInits_+3A_req">req</code></td>
<td>
<p>Required names, and the required order for the ODE solver</p>
</td></tr>
<tr><td><code id="rxInits_+3A_defaultvalue">defaultValue</code></td>
<td>
<p>a number or NA representing the default value for
parameters missing in <code>vec</code>, but required in <code>req</code>.</p>
</td></tr>
<tr><td><code id="rxInits_+3A_noerror">noerror</code></td>
<td>
<p>is a boolean specifying if an error should be thrown
for missing parameter values when <code>default</code> = <code>NA</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Initial values of the rxDll object
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>


<h3>See Also</h3>

<p>Other Query model information: 
<code><a href="#topic+rxDfdy">rxDfdy</a>()</code>,
<code><a href="#topic+rxLhs">rxLhs</a>()</code>,
<code><a href="#topic+rxModelVars">rxModelVars</a>()</code>,
<code><a href="#topic+rxParams">rxParams</a>()</code>,
<code><a href="#topic+rxState">rxState</a>()</code>
</p>

<hr>
<h2 id='rxIntToBase'>Convert a positive  base</h2><span id='topic+rxIntToBase'></span>

<h3>Description</h3>

<p>Convert a positive  base
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxIntToBase(x, base = 36L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxIntToBase_+3A_x">x</code></td>
<td>
<p>integer to convert</p>
</td></tr>
<tr><td><code id="rxIntToBase_+3A_base">base</code></td>
<td>
<p>can be 2 to 36</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a sequence of letters and representing the number(s) input
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rxIntToBase(1:100)

</code></pre>

<hr>
<h2 id='rxIntToLetter'>Convert a positive integer to a letter series</h2><span id='topic+rxIntToLetter'></span>

<h3>Description</h3>

<p>Convert a positive integer to a letter series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxIntToLetter(x, base = 26L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxIntToLetter_+3A_x">x</code></td>
<td>
<p>integer to convert</p>
</td></tr>
<tr><td><code id="rxIntToLetter_+3A_base">base</code></td>
<td>
<p>can be 2 to 26</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a sequence of letters representing the number(s) input
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rxIntToLetter(1:100)

</code></pre>

<hr>
<h2 id='rxInv'>Invert matrix using RcppArmadillo.</h2><span id='topic+rxInv'></span>

<h3>Description</h3>

<p>Invert matrix using RcppArmadillo.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxInv(matrix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxInv_+3A_matrix">matrix</code></td>
<td>
<p>matrix to be inverted.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>inverse or pseudo inverse of matrix.
</p>

<hr>
<h2 id='rxIs'>Check the type of an object using Rcpp</h2><span id='topic+rxIs'></span>

<h3>Description</h3>

<p>Check the type of an object using Rcpp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxIs(obj, cls)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxIs_+3A_obj">obj</code></td>
<td>
<p>Object to check</p>
</td></tr>
<tr><td><code id="rxIs_+3A_cls">cls</code></td>
<td>
<p>Type of class.  Only s3 classes for lists/environments
and primitive classes are checked.  For matrix types they are
distinguished as <code>numeric.matrix</code>, <code>integer.matrix</code>,
<code>logical.matrix</code>, and <code>character.matrix</code> as well as the
traditional <code>matrix</code> class. Additionally checks for
<code>event.data.frame</code> which is an <code>data.frame</code> object with <code>time</code>,
<code>evid</code> and <code>amt</code>. (UPPER, lower or Title cases accepted)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean indicating if the object is a member of the class.
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxIsCurrent'>Checks if the rxode2 object was built with the current build</h2><span id='topic+rxIsCurrent'></span>

<h3>Description</h3>

<p>Checks if the rxode2 object was built with the current build
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxIsCurrent(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxIsCurrent_+3A_obj">obj</code></td>
<td>
<p>rxode2 family of objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boolean indicating if this was built with current rxode2
</p>

<hr>
<h2 id='rxIsLoaded'>Determine if the DLL associated with the rxode2 object is loaded</h2><span id='topic+rxIsLoaded'></span><span id='topic+rxDllLoaded'></span>

<h3>Description</h3>

<p>Determine if the DLL associated with the rxode2 object is loaded
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxIsLoaded(obj)

rxDllLoaded(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxIsLoaded_+3A_obj">obj</code></td>
<td>
<p>A rxode2 family of objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Boolean returning if the rxode2 library is loaded.
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>

<hr>
<h2 id='rxLhs'>Left handed Variables</h2><span id='topic+rxLhs'></span>

<h3>Description</h3>

<p>This returns the model calculated variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxLhs(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxLhs_+3A_obj">obj</code></td>
<td>
<p>rxode2 family of objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a character vector listing the calculated parameters
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rxode2">rxode2</a></code>
</p>
<p>Other Query model information: 
<code><a href="#topic+rxDfdy">rxDfdy</a>()</code>,
<code><a href="#topic+rxInits">rxInits</a>()</code>,
<code><a href="#topic+rxModelVars">rxModelVars</a>()</code>,
<code><a href="#topic+rxParams">rxParams</a>()</code>,
<code><a href="#topic+rxState">rxState</a>()</code>
</p>

<hr>
<h2 id='rxLock'>Lock/unlocking of rxode2 dll file</h2><span id='topic+rxLock'></span><span id='topic+rxUnlock'></span>

<h3>Description</h3>

<p>Lock/unlocking of rxode2 dll file
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxLock(obj)

rxUnlock(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxLock_+3A_obj">obj</code></td>
<td>
<p>A rxode2 family of objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing; called for side effects
</p>

<hr>
<h2 id='rxMd5'>Return the md5 of an rxode2 object or file</h2><span id='topic+rxMd5'></span>

<h3>Description</h3>

<p>This md5 is based on the model and possibly the extra c code
supplied for the model.  In addition the md5 is based on syntax
options, compiled rxode2 library md5, and the rxode2
version/repository.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxMd5(model, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxMd5_+3A_model">model</code></td>
<td>
<p>This is the ODE model specification.  It can be:
</p>

<ul>
<li><p> a string containing the set of ordinary differential
equations (ODE) and other expressions defining the changes in
the dynamic system.
</p>
</li>
<li><p> a file name where the ODE system equation is contained
</p>
</li></ul>

<p>An ODE expression enclosed in <code style="white-space: pre;">&#8288;\{\}&#8288;</code>
</p>
<p>(see also the <code>filename</code> argument). For
details, see the sections &ldquo;Details&rdquo; and
<code style="white-space: pre;">&#8288;rxode2 Syntax&#8288;</code> below.</p>
</td></tr>
<tr><td><code id="rxMd5_+3A_...">...</code></td>
<td>
<p>ignored arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If this is a rxode2 object, return a named list:
</p>

<ul>
<li> <p><code>file_md5</code> is the model's file's md5
</p>
</li>
<li> <p><code>parsed_md5</code>  is the parsed model's file's md5.
</p>
</li></ul>

<p>Otherwise return the md5 based on the arguments provided
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>

<hr>
<h2 id='rxModels_'>Get the rxModels  information</h2><span id='topic+rxModels_'></span>

<h3>Description</h3>

<p>Get the rxModels  information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxModels_(env = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxModels__+3A_env">env</code></td>
<td>
<p>boolean that returns the environment where models are stored (TRUE), or the currently assigned rxode2 model variables (FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>internal rxModels information environment
</p>

<hr>
<h2 id='rxModelVars'>All model variables for a rxode2 object</h2><span id='topic+rxModelVars'></span><span id='topic+rxModelVarsS3'></span><span id='topic+rxModelVarsS3.rxUi'></span><span id='topic+rxModelVarsS3.default'></span>

<h3>Description</h3>

<p>Return all the known model variables for a specified rxode2 object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxModelVars(obj)

rxModelVarsS3(obj)

## S3 method for class 'rxUi'
rxModelVarsS3(obj)

## Default S3 method:
rxModelVarsS3(obj)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxModelVars_+3A_obj">obj</code></td>
<td>
<p>rxode2 family of objects</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These items are only calculated after compilation; they are
built-into the rxode2 compiled DLL.
</p>
<p>To allow extension, an s3 hook is added in the function <code>rxModelVarsS3</code>.
</p>


<h3>Value</h3>

<p>A list of rxode2 model properties including:
</p>

<ul>
<li> <p><code>params</code>  a character vector of names of the model parameters
</p>
</li>
<li> <p><code>lhs</code> a character vector of the names of the model calculated parameters
</p>
</li>
<li> <p><code>state</code> a character vector of the compartments in rxode2 object
</p>
</li>
<li> <p><code>trans</code> a named vector of translated model properties
including what type of jacobian is specified, the <code>C</code> function prefixes,
as well as the <code>C</code> functions names to be called through the compiled model.
</p>
</li>
<li> <p><code>md5</code> a named vector that gives the digest of the model (<code>file_md5</code>) and the parsed model
(<code>parsed_md5</code>)
</p>
</li>
<li> <p><code>model</code>  a named vector giving the input model (<code>model</code>),
normalized model (no comments and standard syntax for parsing, <code>normModel</code>),
and interim code that is used to generate the final C file <code>parseModel</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>See Also</h3>

<p>Other Query model information: 
<code><a href="#topic+rxDfdy">rxDfdy</a>()</code>,
<code><a href="#topic+rxInits">rxInits</a>()</code>,
<code><a href="#topic+rxLhs">rxLhs</a>()</code>,
<code><a href="#topic+rxParams">rxParams</a>()</code>,
<code><a href="#topic+rxState">rxState</a>()</code>
</p>

<hr>
<h2 id='rxnbinom'>Simulate Binomial variable from threefry generator</h2><span id='topic+rxnbinom'></span><span id='topic+rxnbinomMu'></span>

<h3>Description</h3>

<p>Care should be taken with this method not to encounter the
birthday problem, described
<a href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/">https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/</a>.
Since the <code>sitmo</code> <code>threefry</code>, this currently generates
one random deviate from the uniform distribution to seed the
engine <code>threefry</code> and then run the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxnbinom(size, prob, mu, n = 1L, ncores = 1L)

rxnbinomMu(size, mu, n = 1L, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxnbinom_+3A_size">size</code></td>
<td>
<p>target for number of successful trials, or dispersion
parameter (the shape parameter of the gamma mixing distribution).
Must be strictly positive, need not be integer.</p>
</td></tr>
<tr><td><code id="rxnbinom_+3A_prob">prob</code></td>
<td>
<p>probability of success in each trial. <code>0 &lt; prob &lt;= 1</code>.</p>
</td></tr>
<tr><td><code id="rxnbinom_+3A_mu">mu</code></td>
<td>
<p>alternative parametrization via mean: see &lsquo;Details&rsquo;.</p>
</td></tr>
<tr><td><code id="rxnbinom_+3A_n">n</code></td>
<td>
<p>number of observations.  If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="rxnbinom_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the simulation
</p>
<p><code>rxnorm</code> simulates using the threefry sitmo generator.
</p>
<p><code>rxnormV</code> used to simulate with the vandercorput simulator, but
since it didn't satisfy the normal properties it was changed to simple be
an alias of <code>rxnorm</code>. It is no longer supported in <code>rxode2({})</code> blocks</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Therefore, a simple call to the random number generated followed by a second
call to random number generated may have identical seeds.  As the number of
random number generator calls are increased the probability that the
birthday problem will increase.
</p>
<p>The key to avoid this problem is to either run all simulations in the
<code>rxode2</code> environment once (therefore one seed or series of seeds
for the whole simulation), pre-generate all random variables
used for the simulation, or seed the rxode2 engine with <code>rxSetSeed()</code>
</p>
<p>Internally each ID is seeded with a unique number so that the
results do not depend on the number of cores used.
</p>


<h3>Value</h3>

<p>negative binomial random deviates. Note that <code>rxbinom2</code>
uses the <code>mu</code> parameterization an the <code>rxbinom</code> uses the <code>prob</code>
parameterization (<code>mu=size/(prob+size)</code>)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Use threefry engine

rxnbinom(10, 0.9, n = 10) # with rxbinom you have to explicitly state n
rxnbinom(3, 0.5, n = 10, ncores = 2) # You can parallelize the simulation using openMP

rxnbinom(4, 0.7)

# use mu parameter
rxnbinomMu(40, 40, n=10)

## This example uses `rxbinom` directly in the model

rx &lt;- function() {
  model({
    a &lt;- rxnbinom(10, 0.5)
  })
}

et &lt;- et(1, id = 1:100)

s &lt;- rxSolve(rx, et)

rx &lt;- function() {
  model({
    a &lt;- rxnbinomMu(10, 40)
  })
}

s &lt;- rxSolve(rx, et)

</code></pre>

<hr>
<h2 id='rxNorm'>Get the normalized model</h2><span id='topic+rxNorm'></span>

<h3>Description</h3>

<p>This get the syntax preferred model for processing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxNorm(obj, condition = NULL, removeInis, removeJac, removeSens)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxNorm_+3A_obj">obj</code></td>
<td>
<p>rxode2 family of objects</p>
</td></tr>
<tr><td><code id="rxNorm_+3A_condition">condition</code></td>
<td>
<p>Character string of a logical condition to use
for subsetting the normalized model.  When missing, and a
condition is not set via <code>rxCondition</code>, return the whole
code with all the conditional settings intact.  When a condition
is set with <code>rxCondition</code>, use that condition.</p>
</td></tr>
<tr><td><code id="rxNorm_+3A_removeinis">removeInis</code></td>
<td>
<p>A boolean indicating if parameter initialization
will be removed from the model</p>
</td></tr>
<tr><td><code id="rxNorm_+3A_removejac">removeJac</code></td>
<td>
<p>A boolean indicating if the Jacobians will be
removed.</p>
</td></tr>
<tr><td><code id="rxNorm_+3A_removesens">removeSens</code></td>
<td>
<p>A boolean indicating if the sensitivities will
be removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Normalized Normal syntax (no comments)
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxnormV'>Simulate random normal variable from threefry generator</h2><span id='topic+rxnormV'></span><span id='topic+rxnorm'></span>

<h3>Description</h3>

<p>Simulate random normal variable from threefry generator
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxnormV(mean = 0, sd = 1, n = 1L, ncores = 1L)

rxnorm(mean = 0, sd = 1, n = 1L, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxnormV_+3A_mean">mean</code></td>
<td>
<p>vector of means.</p>
</td></tr>
<tr><td><code id="rxnormV_+3A_sd">sd</code></td>
<td>
<p>vector of standard deviations.</p>
</td></tr>
<tr><td><code id="rxnormV_+3A_n">n</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code id="rxnormV_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the simulation
</p>
<p><code>rxnorm</code> simulates using the threefry sitmo generator.
</p>
<p><code>rxnormV</code> used to simulate with the vandercorput simulator, but
since it didn't satisfy the normal properties it was changed to simple be
an alias of <code>rxnorm</code>. It is no longer supported in <code>rxode2({})</code> blocks</p>
</td></tr>
</table>


<h3>Value</h3>

<p>normal random number deviates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Use threefry engine

rxnorm(n = 10) # with rxnorm you have to explicitly state n
rxnorm(n = 10, ncores = 2) # You can parallelize the simulation using openMP

rxnorm(2, 3) ## The first 2 arguments are the mean and standard deviation


## This example uses `rxnorm` directly in the model

rx &lt;- function() {
  model({
    a &lt;- rxnorm()
  })
}

et &lt;- et(1, id = 1:2)

s &lt;- rxSolve(rx, et)


</code></pre>

<hr>
<h2 id='rxode2'>Create an ODE-based model specification</h2><span id='topic+rxode2'></span><span id='topic+RxODE'></span><span id='topic+rxode'></span>

<h3>Description</h3>

<p>Create a dynamic ODE-based model object suitably for translation
into fast C code
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxode2(
  model,
  modName = basename(wd),
  wd = getwd(),
  filename = NULL,
  extraC = NULL,
  debug = FALSE,
  calcJac = NULL,
  calcSens = NULL,
  collapseModel = FALSE,
  package = NULL,
  ...,
  linCmtSens = c("linCmtA", "linCmtB", "linCmtC"),
  indLin = FALSE,
  verbose = FALSE,
  fullPrint = getOption("rxode2.fullPrint", FALSE),
  envir = parent.frame()
)

RxODE(
  model,
  modName = basename(wd),
  wd = getwd(),
  filename = NULL,
  extraC = NULL,
  debug = FALSE,
  calcJac = NULL,
  calcSens = NULL,
  collapseModel = FALSE,
  package = NULL,
  ...,
  linCmtSens = c("linCmtA", "linCmtB", "linCmtC"),
  indLin = FALSE,
  verbose = FALSE,
  fullPrint = getOption("rxode2.fullPrint", FALSE),
  envir = parent.frame()
)

rxode(
  model,
  modName = basename(wd),
  wd = getwd(),
  filename = NULL,
  extraC = NULL,
  debug = FALSE,
  calcJac = NULL,
  calcSens = NULL,
  collapseModel = FALSE,
  package = NULL,
  ...,
  linCmtSens = c("linCmtA", "linCmtB", "linCmtC"),
  indLin = FALSE,
  verbose = FALSE,
  fullPrint = getOption("rxode2.fullPrint", FALSE),
  envir = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxode2_+3A_model">model</code></td>
<td>
<p>This is the ODE model specification.  It can be:
</p>

<ul>
<li><p> a string containing the set of ordinary differential
equations (ODE) and other expressions defining the changes in
the dynamic system.
</p>
</li>
<li><p> a file name where the ODE system equation is contained
</p>
</li></ul>

<p>An ODE expression enclosed in <code style="white-space: pre;">&#8288;\{\}&#8288;</code>
</p>
<p>(see also the <code>filename</code> argument). For
details, see the sections &ldquo;Details&rdquo; and
<code style="white-space: pre;">&#8288;rxode2 Syntax&#8288;</code> below.</p>
</td></tr>
<tr><td><code id="rxode2_+3A_modname">modName</code></td>
<td>
<p>a string to be used as the model name. This string
is used for naming various aspects of the computations,
including generating C symbol names, dynamic libraries,
etc. Therefore, it is necessary that <code>modName</code> consists of
simple ASCII alphanumeric characters starting with a letter.</p>
</td></tr>
<tr><td><code id="rxode2_+3A_wd">wd</code></td>
<td>
<p>character string with a working directory where to
create a subdirectory according to <code>modName</code>. When
specified, a subdirectory named after the
&ldquo;<code>modName.d</code>&rdquo; will be created and populated with a
C file, a dynamic loading library, plus various other working
files. If missing, the files are created (and removed) in the
temporary directory, and the rxode2 DLL for the model is
created in the current directory named <code style="white-space: pre;">&#8288;rx_????_platform&#8288;</code>, for
example <code>rx_129f8f97fb94a87ca49ca8dafe691e1e_i386.dll</code></p>
</td></tr>
<tr><td><code id="rxode2_+3A_filename">filename</code></td>
<td>
<p>A file name or connection object where the
ODE-based model specification resides. Only one of <code>model</code>
or <code>filename</code> may be specified.</p>
</td></tr>
<tr><td><code id="rxode2_+3A_extrac">extraC</code></td>
<td>
<p>Extra c code to include in the model.  This can be
useful to specify functions in the model.  These C functions
should usually take <code>double</code> precision arguments, and
return <code>double</code> precision values.</p>
</td></tr>
<tr><td><code id="rxode2_+3A_debug">debug</code></td>
<td>
<p>is a boolean indicating if the executable should be
compiled with verbose debugging information turned on.</p>
</td></tr>
<tr><td><code id="rxode2_+3A_calcjac">calcJac</code></td>
<td>
<p>boolean indicating if rxode2 will calculate the
Jacobain according to the specified ODEs.</p>
</td></tr>
<tr><td><code id="rxode2_+3A_calcsens">calcSens</code></td>
<td>
<p>boolean indicating if rxode2 will calculate the
sensitivities according to the specified ODEs.</p>
</td></tr>
<tr><td><code id="rxode2_+3A_collapsemodel">collapseModel</code></td>
<td>
<p>boolean indicating if rxode2 will remove all
LHS variables when calculating sensitivities.</p>
</td></tr>
<tr><td><code id="rxode2_+3A_package">package</code></td>
<td>
<p>Package name for pre-compiled binaries.</p>
</td></tr>
<tr><td><code id="rxode2_+3A_...">...</code></td>
<td>
<p>ignored arguments.</p>
</td></tr>
<tr><td><code id="rxode2_+3A_lincmtsens">linCmtSens</code></td>
<td>
<p>The method to calculate the linCmt() solutions</p>
</td></tr>
<tr><td><code id="rxode2_+3A_indlin">indLin</code></td>
<td>
<p>Calculate inductive linearization matrices and
compile with inductive linearization support.</p>
</td></tr>
<tr><td><code id="rxode2_+3A_verbose">verbose</code></td>
<td>
<p>When <code>TRUE</code> be verbose with the linear
compartmental model</p>
</td></tr>
<tr><td><code id="rxode2_+3A_fullprint">fullPrint</code></td>
<td>
<p>When using <code>printf</code> within the model, if <code>TRUE</code>
print on every step (except ME/indLin), otherwise when <code>FALSE</code>
print only when calculating the <code>d/dt</code></p>
</td></tr>
<tr><td><code id="rxode2_+3A_envir">envir</code></td>
<td>
<p>is the environment to look for R user functions
(defaults to parent environment)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>Rx</code> in the name <code>rxode2</code> is meant to suggest the
abbreviation <em>Rx</em> for a medical prescription, and thus to
suggest the package emphasis on pharmacometrics modeling, including
pharmacokinetics (PK), pharmacodynamics (PD), disease progression,
drug-disease modeling, etc.
</p>
<p>The ODE-based model specification may be coded inside four places:
</p>

<ul>
<li><p> Inside a <code>rxode2({})</code> block statements:
</p>
</li></ul>

<div class="sourceCode r"><pre>library(rxode2)
mod &lt;- rxode2({
  # simple assignment
  C2 &lt;- centr/V2

  # time-derivative assignment
  d/dt(centr) &lt;- F*KA*depot - CL*C2 - Q*C2 + Q*C3;
})
</pre></div>

<ul>
<li><p> Inside a <code>rxode2("")</code> string statement:
</p>
</li></ul>

<div class="sourceCode r"><pre>mod &lt;- rxode2("
  # simple assignment
  C2 &lt;- centr/V2

  # time-derivative assignment
  d/dt(centr) &lt;- F*KA*depot - CL*C2 - Q*C2 + Q*C3;
")
</pre></div>

<ul>
<li><p> In a file name to be loaded by rxode2:
</p>
</li></ul>

<div class="sourceCode r"><pre>writeLines("
  # simple assignment
  C2 &lt;- centr/V2

  # time-derivative assignment
  d/dt(centr) &lt;- F*KA*depot - CL*C2 - Q*C2 + Q*C3;
", "modelFile.rxode2")
mod &lt;- rxode2(filename='modelFile.rxode2')
unlink("modelFile.rxode2")
</pre></div>

<ul>
<li><p> In a model function which can be parsed by <code>rxode2</code>:
</p>
</li></ul>

<div class="sourceCode r"><pre>mod &lt;- function() {
  model({
    # simple assignment
    C2 &lt;- centr/V2

    # time-derivative assignment
    d/dt(centr) &lt;- F*KA*depot - CL*C2 - Q*C2 + Q*C3;
  })
}

mod &lt;- rxode2(mod) # or simply mod() if the model is at the end of the function

# These model functions often have residual components and initial
# (`ini({})`) conditions attached as well. For example the
# theophylline model can be written as:

one.compartment &lt;- function() {
  ini({
    tka &lt;- 0.45 # Log Ka
    tcl &lt;- 1 # Log Cl
    tv &lt;- 3.45    # Log V
    eta.ka ~ 0.6
    eta.cl ~ 0.3
    eta.v ~ 0.1
    add.sd &lt;- 0.7
  })
  model({
    ka &lt;- exp(tka + eta.ka)
    cl &lt;- exp(tcl + eta.cl)
    v &lt;- exp(tv + eta.v)
    d/dt(depot) = -ka * depot
    d/dt(center) = ka * depot - cl / v * center
    cp = center / v
    cp ~ add(add.sd)
  })
}

# after parsing the model
mod &lt;- one.compartment()
</pre></div>
<p>For the block statement, character string or text file an internal
<code>rxode2</code> compilation manager translates the ODE system into C, compiles
it and loads it into the R session. The call to <code>rxode2</code> produces an
object of class <code>rxode2</code> which consists of a list-like structure
(environment) with various member functions.
</p>
<p>For the last type of model (a model function), a call to <code>rxode2</code>
creates a parsed <code>rxode2</code> ui that can be translated to the <code>rxode2</code>
compilation model.
</p>
<div class="sourceCode r"><pre>mod$simulationModel

# or
mod$simulationIniModel
</pre></div>
<p>This is the same type of function required for <code>nlmixr2</code> estimation and
can be extended and modified by model piping. For this reason will be
focused on in the documentation.
</p>
<p>This basic model specification consists of one or more statements
optionally terminated by semi-colons <code style="white-space: pre;">&#8288;;&#8288;</code> and optional comments (comments
are delimited by <code style="white-space: pre;">&#8288;#&#8288;</code> and an end-of-line).
</p>
<p>A block of statements is a set of statements delimited by curly braces,
<code>{ ... }</code>.
</p>
<p>Statements can be either assignments, conditional <code>if</code>/<code style="white-space: pre;">&#8288;else if&#8288;</code>/<code style="white-space: pre;">&#8288;else&#8288;</code>,
<code>while</code> loops (can be exited by <code>break</code>), special statements, or
printing statements (for debugging/testing).
</p>
<p>Assignment statements can be:
</p>

<ul>
<li> <p><strong>simple</strong> assignments, where the left hand is an identifier (i.e.,
variable). This includes string assignments
</p>
</li>
<li><p> special <strong>time-derivative</strong> assignments, where the left hand specifies
the change of the amount in the corresponding state variable
(compartment) with respect to time e.g., <code>d/dt(depot)</code>:
</p>
</li>
<li><p> special <strong>initial-condition</strong> assignments where the left hand
specifies the compartment of the initial condition being specified,
e.g.<code>depot(0) = 0</code>
</p>
</li>
<li><p> special model event changes including <strong>bioavailability</strong>
(<code>f(depot)=1</code>), <strong>lag time</strong> (<code>alag(depot)=0</code>), <strong>modeled rate</strong>
(<code>rate(depot)=2</code>) and <strong>modeled duration</strong> (<code>dur(depot)=2</code>). An
example of these model features and the event specification for the
modeled infusions the rxode2 data specification is found in <a href="https://nlmixr2.github.io/rxode2/articles/rxode2-event-types.html">rxode2 events vignette</a>.
</p>
</li>
<li><p> special <strong>change point syntax, or model times</strong>. These model times are
specified by <code>mtime(var)=time</code>
</p>
</li>
<li><p> special <strong>Jacobian-derivative</strong> assignments, where the left hand
specifies the change in the compartment ode with respect to a
variable. For example, if <code>d/dt(y) = dy</code>, then a Jacobian for this
compartment can be specified as <code>df(y)/dy(dy) = 1</code>. There may be some
advantage to obtaining the solution or specifying the Jacobian for
very stiff ODE systems. However, for the few stiff systems we tried
with LSODA, this actually slightly slowed down the solving.
</p>
</li>
<li><p> Special <strong>string value declarations</strong> which tell what values a string
variable will take within a <code>rxode2</code> solving structure. These values
will then cause a factor to be created for this variable on solving
the <code>rxode2</code> model. As such, they are declared in much the same way as
<code>R</code>, that is: <code>labels(a) &lt;- c("a1", "a2")</code>.
</p>
</li></ul>

<p>Note that assignment can be done by <code>=</code>, <code style="white-space: pre;">&#8288;&lt;-&#8288;</code> or <code>~</code>.
</p>
<p>When assigning with the <code>~</code> operator, the <strong>simple assignments</strong> and
<strong>time-derivative</strong> assignments will not be output. Note that with the
<code>rxode2</code> model functions assignment with <code>~</code> can also be overloaded with
a residual distribution specification.
</p>
<p>Special statements can be:
</p>

<ul>
<li> <p><strong>Compartment declaration statements</strong>, which can change the default
dosing compartment and the assumed compartment number(s) as well as
add extra compartment names at the end (useful for multiple-endpoint
nlmixr models); These are specified by <code>cmt(compartmentName)</code>
</p>
</li>
<li> <p><strong>Parameter declaration statements</strong>, which can make sure the input
parameters are in a certain order instead of ordering the parameters
by the order they are parsed. This is useful for keeping the parameter
order the same when using 2 different ODE models. These are specified
by <code>param(par1, par2,...)</code>
</p>
</li>
<li> <p><strong>Variable interpolation statements</strong>, which tells the interpolation
for specific covariates. These include <code>locf(cov1,     cov2, ...)</code> for
last observation carried forward, <code>nocb(cov1,     cov2, ...)</code> for next
observation carried backward, <code>linear(cov1,     cov2, ...)</code> for linear
interpolation and <code>midpoint(cov1, cov2,     ...)</code> for midpoint
interpolation.
</p>
</li></ul>

<p>An example model is shown below:
</p>
<div class="sourceCode"><pre>   # simple assignment
   C2 &lt;- centr/V2

   # time-derivative assignment
   d/dt(centr) &lt;- F*KA*depot - CL*C2 - Q*C2 + Q*C3;
</pre></div>
<p>Expressions in assignment and <code>if</code> statements can be numeric or logical.
</p>
<p>Numeric expressions can include the following numeric operators
<code style="white-space: pre;">&#8288;+, -, *, /, ^&#8288;</code> and those mathematical functions defined in the C or the
R math libraries (e.g., <code>fabs</code>, <code>exp</code>, <code>log</code>, <code>sin</code>, <code>abs</code>).
</p>
<p>You may also access the Rs functions in the <a href="https://cran.r-project.org/doc/manuals/r-release/R-exts.html#Numerical-analysis-subroutines">R math libraries</a>,
like <code>lgammafn</code> for the log gamma function.
</p>
<p>The <code>rxode2</code> syntax is case-sensitive, i.e., <code>ABC</code> is different than
<code>abc</code>, <code>Abc</code>, <code>ABc</code>, etc.
</p>


<h4>Identifiers</h4>

<p>Like R, Identifiers (variable names) may consist of one or more
alphanumeric, underscore <code style="white-space: pre;">&#8288;_&#8288;</code> or period <code>.</code> characters, but the first
character cannot be a digit or underscore <code style="white-space: pre;">&#8288;_&#8288;</code>.
</p>
<p>Identifiers in a model specification can refer to:
</p>

<ul>
<li><p> State variables in the dynamic system (e.g., compartments in a
pharmacokinetics model).
</p>
</li>
<li><p> Implied input variable, <code>t</code> (time), <code>tlast</code> (last time point), and
<code>podo</code> (oral dose, in the undocumented case of absorption transit
models).
</p>
</li>
<li><p> Special constants like <code>pi</code> or <a href="https://cran.r-project.org/doc/manuals/r-release/R-exts.html#Mathematical-constants">Rs predefined constants</a>.
</p>
</li>
<li><p> Model parameters (e.g., <code>ka</code> rate of absorption, <code>CL</code> clearance, etc.)
</p>
</li>
<li><p> Others, as created by assignments as part of the model specification;
these are referred as <em>LHS</em> (left-hand side) variable.
</p>
</li></ul>

<p>Currently, the <code>rxode2</code> modeling language only recognizes system state
variables and parameters, thus, any values that need to be passed from
R to the ODE model (e.g., <code>age</code>) should be either passed in the <code>params</code>
argument of the integrator function <code>rxSolve()</code> or be in the supplied
event data-set.
</p>
<p>There are certain variable names that are in the <code>rxode2</code> event tables.
To avoid confusion, the following event table-related items cannot be
assigned, or used as a state but can be accessed in the rxode2 code:
</p>

<ul>
<li> <p><code>cmt</code>
</p>
</li>
<li> <p><code>dvid</code>
</p>
</li>
<li> <p><code>addl</code>
</p>
</li>
<li> <p><code>ss</code>
</p>
</li>
<li> <p><code>amt</code>
</p>
</li>
<li> <p><code>dur</code>
</p>
</li>
<li> <p><code>rate</code>
</p>
</li>
<li> <p><code>Rprintf</code>
</p>
</li>
<li> <p><code>print</code>
</p>
</li>
<li> <p><code>printf</code>
</p>
</li>
<li> <p><code>id</code>
</p>
</li></ul>

<p>However the following variables are cannot be used in a model
specification:
</p>

<ul>
<li> <p><code>evid</code>
</p>
</li>
<li> <p><code>ii</code>
</p>
</li></ul>

<p>Sometimes rxode2 generates variables that are fed back to rxode2.
Similarly, nlmixr2 generates some variables that are used in nlmixr
estimation and simulation. These variables start with the either the
<code>rx</code> or <code>nlmixr</code> prefixes. To avoid any problems, it is suggested to not
use these variables starting with either the <code>rx</code> or <code>nlmixr</code> prefixes.
</p>



<h4>Logical Operators</h4>

<p>Logical operators support the standard R operators <code>==</code>, <code>!=</code> <code>&gt;=</code> <code>&lt;=</code>
<code>&gt;</code> and <code>&lt;</code>. Like R these can be in <code style="white-space: pre;">&#8288;if()&#8288;</code> or <code style="white-space: pre;">&#8288;while()&#8288;</code> statements,
<code>ifelse()</code> expressions. Additionally they can be in a standard
assignment. For instance, the following is valid:
</p>
<div class="sourceCode"><pre>cov1 = covm*(sexf == "female") + covm*(sexf != "female")
</pre></div>
<p>Notice that you can also use character expressions in comparisons. This
convenience comes at a cost since character comparisons are slower than
numeric expressions. Unlike R, <code>as.numeric</code> or <code>as.integer</code> for these
logical statements is not only not needed, but will cause an syntax
error if you try to use the function.
</p>



<h4>Supported functions</h4>

<p>All the supported functions in rxode2 can be seen with the
<code>rxSupportedFuns()</code>.
</p>
<p>A brief description of the built-in functions are in the following
table:</p>

<table>
<tr>
 <td style="text-align: left;">
   Function </td><td style="text-align: left;"> Description </td><td style="text-align: left;"> Aliases </td>
</tr>
<tr>
 <td style="text-align: left;">
   gamma(x) </td><td style="text-align: left;"> The Gamma function </td><td style="text-align: left;"> gammafn </td>
</tr>
<tr>
 <td style="text-align: left;">
   lgamma(x) </td><td style="text-align: left;"> Natural logarithm of absolute value of gamma function </td><td style="text-align: left;"> digamma </td>
</tr>
<tr>
 <td style="text-align: left;">
   digamma(x) </td><td style="text-align: left;"> First derivative of lgamma </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   trigamma(x) </td><td style="text-align: left;"> Second derivative of lgamma </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   tetragamma(x) </td><td style="text-align: left;"> Third derivative of lgamma </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   pentagamma(x) </td><td style="text-align: left;"> Fourth derivative of lgamma </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   psigamma(x, deriv) </td><td style="text-align: left;"> n-th derivative of Psi, the digamma function, which is the derivative of lgammafn. In other words, digamma(x) is the same as psigamma(x,0), trigamma(x) == psigamma(x,1), etc. </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   cospi(x) </td><td style="text-align: left;"> cos(pi*x) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   sinpi(x) </td><td style="text-align: left;"> sin(pi*x) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   tanpi(x) </td><td style="text-align: left;"> tan(pi*x) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   beta(a, b) </td><td style="text-align: left;"> Beta function </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   lbeta(a, b) </td><td style="text-align: left;"> log Beta function </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   bessel_i(x, nu, expo) </td><td style="text-align: left;"> Bessel function type I with index nu </td><td style="text-align: left;"> expo==1 is unscaled expo==2 is scaled by exp(-x) </td>
</tr>
<tr>
 <td style="text-align: left;">
   bessel_j(x, nu) </td><td style="text-align: left;"> Bessel function type J with index nu </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   bessel_k(x, ku, expo) </td><td style="text-align: left;"> Bessel function type K with index nu </td><td style="text-align: left;"> expo==1 is unscaled expo==2 is scaled by exp(x) </td>
</tr>
<tr>
 <td style="text-align: left;">
   bessel_y(x, nu) </td><td style="text-align: left;"> Bessel function type Y with index nu </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   R_pow(x, y) </td><td style="text-align: left;"> x^y </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   R_pow_di(x, I) </td><td style="text-align: left;"> x^y </td><td style="text-align: left;"> y is an integer </td>
</tr>
<tr>
 <td style="text-align: left;">
   log1pmx </td><td style="text-align: left;"> log(1+x) - x </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   log1pexp </td><td style="text-align: left;"> log(1+exp(x)) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   expm1(x) </td><td style="text-align: left;"> exp(x)-1 </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   lgamma1p(x) </td><td style="text-align: left;"> log(gamma(x+1)) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   sign(x) </td><td style="text-align: left;"> Compute the signum function where sign(x) is 1, 0 -1 </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   fsign(x, y) </td><td style="text-align: left;"> abs(x)*sign(y) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   fprec(x, digits) </td><td style="text-align: left;"> x rounded to digits (after the decimal point, used by signif() </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   fround(x, digits) </td><td style="text-align: left;"> Round, used by Rs round() </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   ftrunc(x) </td><td style="text-align: left;"> Truncated towards zero </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   abs(x) </td><td style="text-align: left;"> absolute value of x </td><td style="text-align: left;"> fabs </td>
</tr>
<tr>
 <td style="text-align: left;">
   sin(x) </td><td style="text-align: left;"> sine of x </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   cos(x) </td><td style="text-align: left;"> cos of x </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   tan(x) </td><td style="text-align: left;"> tan of x </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   factorial(x) </td><td style="text-align: left;"> factorial of x </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   lfactorial(x) </td><td style="text-align: left;"> log(factorial(x)) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   log10(x) </td><td style="text-align: left;"> log base 10 </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   log2(x) </td><td style="text-align: left;"> log base 2 </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   pnorm(x) </td><td style="text-align: left;"> Normal CDF of x </td><td style="text-align: left;"> normcdf, phi </td>
</tr>
<tr>
 <td style="text-align: left;">
   qnorm(x) </td><td style="text-align: left;"> Normal pdf of x </td><td style="text-align: left;"> norminv </td>
</tr>
<tr>
 <td style="text-align: left;">
   probit(x, low=0, hi=1) </td><td style="text-align: left;"> Probit (normal pdf) of x transforming into a range </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   probitInv(q, low=0, hi=1) </td><td style="text-align: left;"> Inverse probit of x transforming into a range </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   acos(x) </td><td style="text-align: left;"> Inverse cosine </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   asin(x) </td><td style="text-align: left;"> Inverse sine </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   atan(x) </td><td style="text-align: left;"> Inverse tangent </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   atan2(a, b) </td><td style="text-align: left;"> Four quadrant inverse tangent </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   sinh(x) </td><td style="text-align: left;"> Hyperbolic sine </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   cosh(x) </td><td style="text-align: left;"> Hyperbolic cosine </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   tanh(x) </td><td style="text-align: left;"> Hyperbolic tangent </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   floor(x) </td><td style="text-align: left;"> Downward rounding </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   ceil(x) </td><td style="text-align: left;"> Upward rounding </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   logit(x, low=0, hi=1) </td><td style="text-align: left;"> Logit transformation of x transforming into a range </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   expit(x, low=0, hi=1) </td><td style="text-align: left;"> expit transofmration in range </td><td style="text-align: left;"> invLogit, logitInv </td>
</tr>
<tr>
 <td style="text-align: left;">
   gammaq(a, z) </td><td style="text-align: left;"> Normalized incomplete gamma from boost </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   gammaqInv(a, q) </td><td style="text-align: left;"> Normalized incomplete gamma inverse from boost </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   ifelse(cond, trueValue, falseValue) </td><td style="text-align: left;"> if else function </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   gammap(a, z) </td><td style="text-align: left;"> Normalized lower incomplete gamma from boost </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   gammapInv(a, p) </td><td style="text-align: left;"> Inverse of Normalized lower incomplete gamma from boost </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   gammapInva(x, p) </td><td style="text-align: left;"> Inverse of Normalized lower incomplete gamma from boost </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   rxnorm(x) </td><td style="text-align: left;"> Generate one deviate of from a normal distribution for each observation scale </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   rxnormV(x) </td><td style="text-align: left;"> Generate one deviate from low discrepancy normal for each observation </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   rxcauchy </td><td style="text-align: left;"> Generate one deviate from the cauchy distribution for each observation </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   rxchisq </td><td style="text-align: left;"> Generate one deviate from the chisq distribution for each observation </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   rxexp </td><td style="text-align: left;"> Generate one deviate from the exponential distribution for each observation </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   rxf </td><td style="text-align: left;"> Generate one deviate from low discrepancy normal for each observation </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   rxgamma </td><td style="text-align: left;"> Generate one deviate from the gamma distribution for each observation </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   rxbeta </td><td style="text-align: left;"> Generate one deviate from the beta distribution for each observation </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   rxgeom </td><td style="text-align: left;"> Generate one deviate from the geometric distribution for each observation </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   rxpois </td><td style="text-align: left;"> Generate one deviate from the poission distribution for each observation </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   rxt </td><td style="text-align: left;"> Generate one deviate from the t distribtuion for each observation </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   tad() or tad(x) </td><td style="text-align: left;"> Time after dose (tad()) or time after dose for a compartment tad(cmt); no dose=NA </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   tad0() or tad0(x) </td><td style="text-align: left;"> Time after dose (tad0()) or time after dose for a compartment tad0(cmt); no dose=0 </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   tafd() or tafd(x) </td><td style="text-align: left;"> Time after first dose (tafd()) or time after first dose for a compartment tafd(cmt); no dose=NA </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   tafd0() or tafd0(x) </td><td style="text-align: left;"> Time after first dose (tafd()) or time after first dose for a compartment tafd(cmt); no dose=NA </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   dosenum() </td><td style="text-align: left;"> Dose Number </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   tlast() or tlast(cmt) </td><td style="text-align: left;"> Time of Last dose; This takes into consideration any lag time, so if there is a dose at time 3 and a lag of 1, the time of last dose would be 4. tlast(cmt) calculates the time since last dose of a compartment; no dose=NA </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   tlast0() or tlast0(cmt) </td><td style="text-align: left;"> Time of Last dose; This takes into consideration any lag time, so if there is a dose at time 3 and a lag of 1, the time of last dose would be 4. tlast(cmt) calculates the time since last dose of a compartment; no dose=0 </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   tfirst() or tfirst(cmt) </td><td style="text-align: left;"> Time since first dose or time since first dose of a compartment; no dose=NA </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   tfirst0() or tfirst0(cmt) </td><td style="text-align: left;"> Time since first dose or time since first dose of a compartment; no dose=0 </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   prod() </td><td style="text-align: left;"> product of terms; This uses PreciseSums so the product will not have as much floating point errors (though it will take longer) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   sum() </td><td style="text-align: left;"> sum of terms; This uses PreciseSums so the product will not have as much floating point errors (though it will take longer) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   max() </td><td style="text-align: left;"> maximum of a group of numbers </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   min() </td><td style="text-align: left;"> Min of a group of numbers </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   lag(parameter, number=1) </td><td style="text-align: left;"> Get the lag of an input parameter; You can specify a number of lagged observations </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   lead(parameter, number=2) </td><td style="text-align: left;"> Get the lead of an input parameter; You can specify a number of lead observation </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   diff(par, number=1) </td><td style="text-align: left;"> Get the difference between the current parameter and the last parameter; Can change the parameter number </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   first(par) </td><td style="text-align: left;"> Get the first value of an input parameter </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   last(par) </td><td style="text-align: left;"> Get the last value of an input parameter </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   transit() </td><td style="text-align: left;"> The transit compartment psuedo function </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   is.na() </td><td style="text-align: left;"> Determine if a value is NA </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   is.nan() </td><td style="text-align: left;"> Determine if a value is NaN </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   is.infinite() </td><td style="text-align: left;"> Check to see if the value is infinite </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   rinorm(x) </td><td style="text-align: left;"> Generate one deviate of from a normal distribution for each individual </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   rinormV(x) </td><td style="text-align: left;"> Generate one deviate from low discrepancy normal for each individual </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   ricauchy </td><td style="text-align: left;"> Generate one deviate from the cauchy distribution for each individual </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   richisq </td><td style="text-align: left;"> Generate one deviate from the chisq distribution for each individual </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   riexp </td><td style="text-align: left;"> Generate one deviate from the exponential distribution for each individual </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   rif </td><td style="text-align: left;"> Generate one deviate from low discrepancy normal for each individual </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   rigamma </td><td style="text-align: left;"> Generate one deviate from the gamma distribution for each individual </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   ribeta </td><td style="text-align: left;"> Generate one deviate from the beta distribution for each individual </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   rigeom </td><td style="text-align: left;"> Generate one deviate from the geometric distribution for each individual </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   ropois </td><td style="text-align: left;"> Generate one deviate from the poission distribution for each individual </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   rit </td><td style="text-align: left;"> Generate one deviate from the t distribtuion for each individual </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   simeps </td><td style="text-align: left;"> Simulate EPS from possibly truncated sigma matrix. Will take sigma matrix from the current study. Simulated at the very last moment. </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   simeta </td><td style="text-align: left;"> Simulate ETA from possibly truncated omega matrix. Will take the omega matrix from the current study. Simulated at the initilization of the ODE system or the intialization of lhs </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Note that <code style="white-space: pre;">&#8288;lag(cmt) =&#8288;</code> is equivalent to <code style="white-space: pre;">&#8288;alag(cmt) =&#8288;</code> and not the same
as <code style="white-space: pre;">&#8288;= lag(wt)&#8288;</code>
</p>



<h4>Reserved keywords</h4>

<p>There are a few reserved keywords in a rxode2 model. They are in the
following table:</p>

<table>
<tr>
 <td style="text-align: left;">
   Reserved Name </td><td style="text-align: left;"> Meaning </td><td style="text-align: left;"> Alias </td>
</tr>
<tr>
 <td style="text-align: left;">
   time </td><td style="text-align: left;"> solver time </td><td style="text-align: left;"> t </td>
</tr>
<tr>
 <td style="text-align: left;">
   podo </td><td style="text-align: left;"> In Transit compartment models, last dose amount </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   tlast </td><td style="text-align: left;"> Time of Last dose </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_E </td><td style="text-align: left;"> Exp(1) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_LOG2E </td><td style="text-align: left;"> log2(e) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_LOG10E </td><td style="text-align: left;"> log10(e) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_LN2 </td><td style="text-align: left;"> log(2) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_LN10 </td><td style="text-align: left;"> log(10) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_PI </td><td style="text-align: left;"> pi </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_PI_2 </td><td style="text-align: left;"> pi/2 </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_PI_4 </td><td style="text-align: left;"> pi/4 </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_1_PI </td><td style="text-align: left;"> 1/pi </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_2_PI </td><td style="text-align: left;"> 2/pi </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_2_SQRTPI </td><td style="text-align: left;"> 2/sqrt(pi) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_SQRT2 </td><td style="text-align: left;"> sqrt(2) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_SQRT1_2 </td><td style="text-align: left;"> 1/sqrt(2) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_SQRT_3 </td><td style="text-align: left;"> sqrt(3) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_SQRT_32 </td><td style="text-align: left;"> sqrt(32) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_LOG10_2 </td><td style="text-align: left;"> Log10(2) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_2PI </td><td style="text-align: left;"> 2*pi </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_SQRT_PI </td><td style="text-align: left;"> sqrt(pi) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_1_SQRT_2PI </td><td style="text-align: left;"> 1/(sqrt(2*pi)) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_LN_SQRT_PI </td><td style="text-align: left;"> log(sqrt(pi)) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_LN_SQRT_2PI </td><td style="text-align: left;"> log(sqrt(2*pi)) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   M_LN_SQRT_PId2 </td><td style="text-align: left;"> log(sqrt(pi/2)) </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   pi </td><td style="text-align: left;"> pi </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   NA </td><td style="text-align: left;"> Rs NA value </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   NaN </td><td style="text-align: left;"> Not a Number Value </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   Inf </td><td style="text-align: left;"> Infinite Value </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
   newind </td><td style="text-align: left;"> 1: First record of individual; 2: Subsequent record of individual </td><td style="text-align: left;"> NEWIND </td>
</tr>
<tr>
 <td style="text-align: left;">
   rxFlag </td><td style="text-align: left;"> Flag for what part of the rxode2 model is being run; 1: ddt; 2: jac; 3: ini; 4: F; 5: lag; 6: rate; 7: dur; 8: mtime; 9: matrix exponential; 10: inductive linearization; 11: lhs </td><td style="text-align: left;">  </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Note that <code>rxFlag</code> will always output <code>11</code> or <code>calc_lhs</code> since that is
where the final variables are calculated, though you can tweak or test
certain parts of <code>rxode2</code> by using this flag.
</p>



<h4>Residual functions when using rxode2 functions</h4>

<p>In addition to <code>~</code> hiding output for certain types of output, it also is
used to specify a residual output or endpoint when the input is an
<code>rxode2</code> model function (that includes the residual in the <code>model({})</code>
block).
</p>
<p>These specifications are of the form:
</p>
<div class="sourceCode r"><pre>var ~ add(add.sd)
</pre></div>
<p>Indicating the variable <code>var</code> is the variable that represents the
individual central tendencies of the model and it also represents the
compartment specification in the data-set.
</p>
<p>You can also change the compartment name using the <code>|</code> syntax, that is:
</p>
<div class="sourceCode r"><pre>var ~ add(add.sd) | cmt
</pre></div>
<p>In the above case <code>var</code> represents the central tendency and <code>cmt</code>
represents the compartment or <code>dvid</code> specification.
</p>


<h5>Transformations</h5>

<p>For normal and related distributions, you can apply the transformation
on both sides by using some keywords/functions to apply these
transformations.</p>

<table>
<tr>
 <td style="text-align: left;">
   Transformation </td><td style="text-align: left;"> rxode2/nlmixr2 code </td>
</tr>
<tr>
 <td style="text-align: left;">
   Box-Cox </td><td style="text-align: left;"> +boxCox(lambda) </td>
</tr>
<tr>
 <td style="text-align: left;">
   Yeo-Johnson </td><td style="text-align: left;"> +yeoJohnson(lambda) </td>
</tr>
<tr>
 <td style="text-align: left;">
   logit-normal </td><td style="text-align: left;"> +logitNorm(logit.sd, low, hi) </td>
</tr>
<tr>
 <td style="text-align: left;">
   probit-normal </td><td style="text-align: left;"> +probitNorm(probid.sd, low, hi) </td>
</tr>
<tr>
 <td style="text-align: left;">
   log-normal </td><td style="text-align: left;"> +lnorm(lnorm.sd) </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>By default for the likelihood for all of these transformations is
calculated on the <strong>untransformed</strong> scale.
</p>
<p>For bounded variables like logit-normal or probit-normal the low and
high values are defaulted to 0 and 1 if missing.
</p>
<p>For models where you wish to have a proportional model on one of these
transformation you can replace the standard deviation with <code>NA</code>
</p>
<p>To allow for more transformations, <code>lnorm()</code>, <code>probitNorm()</code> and
<code>logitNorm()</code> can be combined the variance stabilizing <code>yeoJohnson()</code>
transformation.
</p>



<h5>Normal and t-related distributions</h5>

<p>For the normal and t-related distributions, we wanted to keep the
ability to use skewed distributions additive and proportional in the
t/cauchy-space, so these distributions are specified differently in
comparison to the other supported distributions within <code>nlmixr2</code>:</p>

<table>
<tr>
 <td style="text-align: left;">
   Distribution </td><td style="text-align: left;"> How to Add </td><td style="text-align: left;"> Example </td>
</tr>
<tr>
 <td style="text-align: left;">
   Normal (log-likelihood) </td><td style="text-align: left;"> +dnorm() </td><td style="text-align: left;"> cc ~ add(add.sd) + dnorm() </td>
</tr>
<tr>
 <td style="text-align: left;">
   T-distribution </td><td style="text-align: left;"> +dt(df) </td><td style="text-align: left;"> cc ~a dd(add.sd) + dt(df) </td>
</tr>
<tr>
 <td style="text-align: left;">
   Cauchy (t with df=1) </td><td style="text-align: left;"> +dcauchy() </td><td style="text-align: left;"> cc ~ add(add.sd) + dcauchy() </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Note that with the normal and t-related distributions <code>nlmixr2</code> will
calculate <code>cwres</code> and <code>npde</code> under the normal assumption to help assess
the goodness of the fit of the model.
</p>
<p>Also note that the <code>+dnorm()</code> is mostly for testing purposes and will
slow down the estimation procedure in <code>nlmixr2</code>. We suggest not adding
it (except for explicit testing). When there are multiple endpoint
models that mix non-normal and normal distributions, the whole problem
is shifted to a log-likelihood method for estimation in <code>nlmixr2</code>.
</p>



<h5>Notes on additive + proportional models</h5>

<p>There are two different ways to specify additive and proportional
models, which we will call <strong>combined1</strong> and <strong>combined2</strong>, the same way
that Monolix calls the two distributions (to avoid between software
differences in naming).
</p>
<p>The first, <strong>combined1</strong>, assumes that the additive and proportional
differences are on the standard deviation scale, or:
</p>
<p>y=f+(a+b* f^c)*err
</p>
<p>The second, <strong>combined2</strong>, assumes that the additive and proportional
differences are combined on a variance scale:
</p>
<p>y=f+$$sqrt(a^2+b^2 *f^(2c))$$*err
</p>
<p>The default in <code>nlmixr2</code>/<code>rxode2</code> if not otherwise specified is
<strong>combined2</strong> since it mirrors how adding 2 normal distributions in
statistics will add their variances (not the standard deviations).
However, the <strong>combined1</strong> can describe the data possibly even better
than <strong>combined2</strong> so both are possible options in <code>rxode2</code>/<code>nlmixr2</code>.
</p>



<h5>Distributions of known likelihoods</h5>

<p>For residuals that are not related to normal, t-distribution or cauchy,
often the residual specification is of the form:
</p>
<div class="sourceCode r"><pre>cmt ~ dbeta(alpha, beta)
</pre></div>
<p>Where the compartment specification is on the left handed side of the
specification.
</p>
<p>For generalized likelihood you can specify:
</p>
<div class="sourceCode r"><pre>ll(cmt) ~ llik specification
</pre></div>



<h5>Ordinal likelihoods</h5>

<p>Finally, ordinal likelihoods/simulations can be specified in 2 ways. The
first is:
</p>
<div class="sourceCode r"><pre>err ~ c(p0, p1, p2)
</pre></div>
<p>Here <code>err</code> represents the compartment and <code>p0</code> is the probability of
being in a specific category:</p>

<table>
<tr>
 <td style="text-align: left;">
   Category </td><td style="text-align: left;"> Probability </td>
</tr>
<tr>
 <td style="text-align: left;">
   1 </td><td style="text-align: left;"> p0 </td>
</tr>
<tr>
 <td style="text-align: left;">
   2 </td><td style="text-align: left;"> p1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   3 </td><td style="text-align: left;"> p2 </td>
</tr>
<tr>
 <td style="text-align: left;">
   4 </td><td style="text-align: left;"> 1-p0-p1-p2 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>It is up to the model to ensure that the sum of the <code>p</code> values are less
than <code>1</code>. Additionally you can write an arbitrary number of categories
in the ordinal model described above.
</p>
<p>It seems a little off that <code>p0</code> is the probability for category <code>1</code> and
sometimes scores are in non-whole numbers. This can be modeled as
follows:
</p>
<div class="sourceCode r"><pre>err ~ c(p0=0, p1=1, p2=2, 3)
</pre></div>
<p>Here the numeric categories are specified explicitly, and the
probabilities remain the same:</p>

<table>
<tr>
 <td style="text-align: left;">
   Category </td><td style="text-align: left;"> Probability </td>
</tr>
<tr>
 <td style="text-align: left;">
   0 </td><td style="text-align: left;"> p0 </td>
</tr>
<tr>
 <td style="text-align: left;">
   1 </td><td style="text-align: left;"> p1 </td>
</tr>
<tr>
 <td style="text-align: left;">
   2 </td><td style="text-align: left;"> p2 </td>
</tr>
<tr>
 <td style="text-align: left;">
   3 </td><td style="text-align: left;"> 1-p0-p1-p2 </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>




<h5>General table of supported residual distributions</h5>

<p>In general all the that are supported are in the following table
(available in <code>rxode2::rxResidualError</code>)</p>

<table>
<tr>
 <td style="text-align: left;">
   Error model </td><td style="text-align: left;"> Functional Form </td><td style="text-align: left;"> Transformation </td><td style="text-align: left;"> code </td><td style="text-align: left;"> addProp </td><td style="text-align: left;"> lhs </td>
</tr>
<tr>
 <td style="text-align: left;">
   constant </td><td style="text-align: left;">  </td><td style="text-align: left;"> None </td><td style="text-align: left;"> var ~ add(add.sd) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional </td><td style="text-align: left;">  </td><td style="text-align: left;"> None </td><td style="text-align: left;"> var ~ prop(prop.sd) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power </td><td style="text-align: left;">  </td><td style="text-align: left;"> None </td><td style="text-align: left;"> var ~ pow(pow.sd, exponent) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> None </td><td style="text-align: left;"> var ~ add(add.sd) + prop(prop.sd) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> None </td><td style="text-align: left;"> var ~ add(add.sd) + prop(prop.sd) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> None </td><td style="text-align: left;"> var ~ add(add.sd) + pow(pow.sd, exponent) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> None </td><td style="text-align: left;"> var ~ add(add.sd) + pow(pow.sd, exponent) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   constant </td><td style="text-align: left;">  </td><td style="text-align: left;"> log </td><td style="text-align: left;"> var ~ lnorm(add.sd) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional </td><td style="text-align: left;">  </td><td style="text-align: left;"> log </td><td style="text-align: left;"> var ~ lnorm(NA) + prop(prop.sd) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power </td><td style="text-align: left;">  </td><td style="text-align: left;"> log </td><td style="text-align: left;"> var ~ lnorm(NA) + pow(pow.sd, exponent) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> log </td><td style="text-align: left;"> var ~ lnorm(add.sd) + prop(prop.sd) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> log </td><td style="text-align: left;"> var ~ lnorm(add.sd) + prop(prop.sd) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> log </td><td style="text-align: left;"> var ~ lnorm(add.sd) + pow(pow.sd, exponent) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> log </td><td style="text-align: left;"> var ~ lnorm(add.sd) + pow(pow.sd, exponent) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   constant </td><td style="text-align: left;">  </td><td style="text-align: left;"> boxCox </td><td style="text-align: left;"> var ~ boxCox(lambda) + add(add.sd) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional </td><td style="text-align: left;">  </td><td style="text-align: left;"> boxCox </td><td style="text-align: left;"> var ~ boxCox(lambda) + prop(prop.sd) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power </td><td style="text-align: left;">  </td><td style="text-align: left;"> boxCox </td><td style="text-align: left;"> var ~ boxCox(lambda) + pow(pow.sd, exponent) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> boxCox </td><td style="text-align: left;"> var ~ boxCox(lambda) + add(add.sd) + prop(prop.sd) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> boxCox </td><td style="text-align: left;"> var ~ boxCox(lambda) + add(add.sd) + prop(prop.sd) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> boxCox </td><td style="text-align: left;"> var ~ boxCox(lambda) + add(add.sd) + pow(pop.sd, exponent) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> boxCox </td><td style="text-align: left;"> var ~ boxCox(lambda) + add(add.sd) + pow(pop.sd, exponent) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   constant </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + add(add.sd) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + prop(prop.sd) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + pow(pow.sd, exponent) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> yeoJohnson </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + add(add.sd) + prop(prop.sd) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> yeoJohnson </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + add(add.sd) + prop(prop.sd) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> yeoJohnson </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + add(add.sd) + pow(pop.sd, exponent) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> yeoJohnson </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + add(add.sd) + pow(pop.sd, exponent) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   constant </td><td style="text-align: left;">  </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ logitNorm(logit.sd) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional </td><td style="text-align: left;">  </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ logitNorm(NA) + prop(prop.sd) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power </td><td style="text-align: left;">  </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ logitNorm(NA) + pow(pow.sd, exponent) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ logitNorm(logit.sd) + prop(prop.sd) </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ logitNorm(logit.sd) + prop(prop.sd) </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ logitNorm(logit.sd) + pow(pow.sd, exponent) </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ logitNorm(logit.sd) + pow(pow.sd, exponent) </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson(logit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + logitNorm(logit.sd) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson(logit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + logitNorm(NA) + prop(prop.sd) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson(logit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + logitNorm(NA) + pow(pow.sd, exponent) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> yeoJohnson(logit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + logitNorm(logit.sd) + prop(prop.sd) </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> yeoJohnson(logit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + logitNorm(logit.sd) + prop(prop.sd) </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> yeoJohnson(logit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + logitNorm(logit.sd) + pow(pow.sd, exponent) </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> yeoJohnson(logit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + logitNorm(logit.sd) + pow(pow.sd, exponent) </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   constant </td><td style="text-align: left;">  </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ probitNorm(probit.sd) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional </td><td style="text-align: left;">  </td><td style="text-align: left;"> probit </td><td style="text-align: left;"> var ~ probitNorm(NA) + prop(prop.sd) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power </td><td style="text-align: left;">  </td><td style="text-align: left;"> probit </td><td style="text-align: left;"> var ~ probitNorm(NA) + pow(pow.sd, exponent) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> probit </td><td style="text-align: left;"> var ~ probitNorm(probit.sd) + prop(prop.sd) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> probit </td><td style="text-align: left;"> var ~ probitNorm(probit.sd) + prop(prop.sd) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> probit </td><td style="text-align: left;"> var ~ probitNorm(probit.sd) + pow(pow.sd, exponent) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> probit </td><td style="text-align: left;"> var ~ probitNorm(probit.sd) + pow(pow.sd, exponent) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson(probit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + probitNorm(probit.sd) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson(probit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + probitNorm(NA) + prop(prop.sd) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson(probit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + probitNorm(NA) + pow(pow.sd, exponent) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> yeoJohnson(probit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + probitNorm(probit.sd) + prop(prop.sd) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> yeoJohnson(probit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + probitNorm(probit.sd) + prop(prop.sd) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> yeoJohnson(probit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + probitNorm(probit.sd) + pow(pow.sd, exponent) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> yeoJohnson(probit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + probitNorm(probit.sd) + pow(pow.sd, exponent) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   constant+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> None </td><td style="text-align: left;"> var ~ add(add.sd) + dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> None </td><td style="text-align: left;"> var ~ prop(prop.sd) + dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> None </td><td style="text-align: left;"> var ~ pow(pow.sd, exponent) + dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+t </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> None </td><td style="text-align: left;"> var ~ add(add.sd) + prop(prop.sd) + dt(df) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+t </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> None </td><td style="text-align: left;"> var ~ add(add.sd) + prop(prop.sd) + dt(df) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+t </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> None </td><td style="text-align: left;"> var ~ add(add.sd) + pow(pow.sd, exponent) + dt(df) +combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+t </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> None </td><td style="text-align: left;"> var ~ add(add.sd) + pow(pow.sd, exponent) + dt(df) +combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   constant+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> log </td><td style="text-align: left;"> var ~ lnorm(add.sd) + dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> log </td><td style="text-align: left;"> var ~ lnorm(NA) + prop(prop.sd) + dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> log </td><td style="text-align: left;"> var ~ lnorm(NA) + pow(pow.sd, exponent) + dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+t </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> log </td><td style="text-align: left;"> var ~ lnorm(add.sd) + prop(prop.sd) + dt(df) +combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+t </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> log </td><td style="text-align: left;"> var ~ lnorm(add.sd) + prop(prop.sd) + dt(df) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+t </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> log </td><td style="text-align: left;"> var ~ lnorm(add.sd) + pow(pow.sd, exponent) + dt(df) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+t </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> log </td><td style="text-align: left;"> var ~ lnorm(add.sd) + pow(pow.sd, exponent) + dt(df) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   constant+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> boxCox </td><td style="text-align: left;"> var ~ boxCox(lambda) + add(add.sd)+dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> boxCox </td><td style="text-align: left;"> var ~ boxCox(lambda) + prop(prop.sd)+dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> boxCox </td><td style="text-align: left;"> var ~ boxCox(lambda) + pow(pow.sd, exponent)+dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+t </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> boxCox </td><td style="text-align: left;"> var ~ boxCox(lambda) + add(add.sd) + prop(prop.sd) + dt(df) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+t </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> boxCox </td><td style="text-align: left;"> var ~ boxCox(lambda) + add(add.sd) + prop(prop.sd) + dt(df) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+t </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> boxCox </td><td style="text-align: left;"> var ~ boxCox(lambda) + add(add.sd) + pow(pop.sd, exponent) + dt(df) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+t </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> boxCox </td><td style="text-align: left;"> var ~ boxCox(lambda) + add(add.sd) + pow(pop.sd, exponent) + dt(df) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   constant+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + add(add.sd) + dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + prop(prop.sd) + dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + pow(pow.sd, exponent) + dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+t </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> yeoJohnson </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + add(add.sd) + prop(prop.sd) + dt(df) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+t </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> yeoJohnson </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + add(add.sd) + prop(prop.sd) + dt(df) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+t </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> yeoJohnson </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + add(add.sd) + pow(pop.sd, exponent) + dt(df) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+t </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> yeoJohnson </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + add(add.sd) + pow(pop.sd, exponent) + dt(df) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   constant+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ logitNorm(logit.sd)+dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ logitNorm(NA) + prop(prop.sd)+dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ logitNorm(NA) + pow(pow.sd, exponent) + dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+t </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ logitNorm(logit.sd) + prop(prop.sd) + dt(df) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+t </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ logitNorm(logit.sd) + prop(prop.sd) + dt(df) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+t </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ logitNorm(logit.sd) + pow(pow.sd, exponent) + dt(df) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+t </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ logitNorm(logit.sd) + pow(pow.sd, exponent) + dt(df) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson(logit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + logitNorm(logit.sd) + dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson(logit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + logitNorm(NA) + prop(prop.sd) + dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson(logit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + logitNorm(NA) + pow(pow.sd, exponent) + dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+t </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> yeoJohnson(logit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + logitNorm(logit.sd) + prop(prop.sd) + dt(df) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+t </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> yeoJohnson(logit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + logitNorm(logit.sd) + prop(prop.sd) + dt(df) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+t </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> yeoJohnson(logit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + logitNorm(logit.sd) + pow(pow.sd, exponent) + dt(df) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+t </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> yeoJohnson(logit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + logitNorm(logit.sd) + pow(pow.sd, exponent) + dt(df) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   constant+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ probitNorm(probit.sd) + dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> probit </td><td style="text-align: left;"> var ~ probitNorm(NA) + prop(prop.sd) + dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> probit </td><td style="text-align: left;"> var ~ probitNorm(NA) + pow(pow.sd, exponent) + dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+t </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> probit </td><td style="text-align: left;"> var ~ probitNorm(probit.sd) + prop(prop.sd) + dt(df) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+t </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> probit </td><td style="text-align: left;"> var ~ probitNorm(probit.sd) + prop(prop.sd) + dt(df) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+t </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> probit </td><td style="text-align: left;"> var ~ probitNorm(probit.sd) + pow(pow.sd, exponent) + dt(df) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+t </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> probit </td><td style="text-align: left;"> var ~ probitNorm(probit.sd) + pow(pow.sd, exponent) + dt(df) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson(probit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + probitNorm(probit.sd) + dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson(probit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + probitNorm(NA) + prop(prop.sd) + dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power+t </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson(probit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + probitNorm(NA) + pow(pow.sd, exponent) + dt(df) </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+t </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> yeoJohnson(probit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + probitNorm(probit.sd) + prop(prop.sd) + dt(df) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+t </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> yeoJohnson(probit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + probitNorm(probit.sd) + prop(prop.sd) + dt(df) + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+t </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> yeoJohnson(probit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + probitNorm(probit.sd) + pow(pow.sd, exponent) + dt(df) + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+t </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> yeoJohnson(probit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + probitNorm(probit.sd) + pow(pow.sd, exponent) + dt(df) +combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   constant+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> None </td><td style="text-align: left;"> var ~ add(add.sd) + dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> None </td><td style="text-align: left;"> var ~ prop(prop.sd) + dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> None </td><td style="text-align: left;"> var ~ pow(pow.sd, exponent) + dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+cauchy </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> None </td><td style="text-align: left;"> var ~ add(add.sd) + prop(prop.sd) + dcauchy() + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+cauchy </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> None </td><td style="text-align: left;"> var ~ add(add.sd) + prop(prop.sd) + dcauchy() + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+cauchy </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> None </td><td style="text-align: left;"> var ~ add(add.sd) + pow(pow.sd, exponent) + dcauchy() +combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+cauchy </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> None </td><td style="text-align: left;"> var ~ add(add.sd) + pow(pow.sd, exponent) + dcauchy() +combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   constant+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> log </td><td style="text-align: left;"> var ~ lnorm(add.sd) + dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> log </td><td style="text-align: left;"> var ~ lnorm(NA) + prop(prop.sd) + dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> log </td><td style="text-align: left;"> var ~ lnorm(NA) + pow(pow.sd, exponent) + dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+cauchy </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> log </td><td style="text-align: left;"> var ~ lnorm(add.sd) + prop(prop.sd) + dcauchy() +combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+cauchy </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> log </td><td style="text-align: left;"> var ~ lnorm(add.sd) + prop(prop.sd) + dcauchy() + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+cauchy </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> log </td><td style="text-align: left;"> var ~ lnorm(add.sd) + pow(pow.sd, exponent) + dcauchy() + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+cauchy </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> log </td><td style="text-align: left;"> var ~ lnorm(add.sd) + pow(pow.sd, exponent) + dcauchy() + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   constant+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> boxCox </td><td style="text-align: left;"> var ~ boxCox(lambda) + add(add.sd)+dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> boxCox </td><td style="text-align: left;"> var ~ boxCox(lambda) + prop(prop.sd)+dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> boxCox </td><td style="text-align: left;"> var ~ boxCox(lambda) + pow(pow.sd, exponent)+dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+cauchy </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> boxCox </td><td style="text-align: left;"> var ~ boxCox(lambda) + add(add.sd) + prop(prop.sd) + dcauchy() + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+cauchy </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> boxCox </td><td style="text-align: left;"> var ~ boxCox(lambda) + add(add.sd) + prop(prop.sd) + dcauchy() + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+cauchy </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> boxCox </td><td style="text-align: left;"> var ~ boxCox(lambda) + add(add.sd) + pow(pop.sd, exponent) + dcauchy() + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+cauchy </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> boxCox </td><td style="text-align: left;"> var ~ boxCox(lambda) + add(add.sd) + pow(pop.sd, exponent) + dcauchy() + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   constant+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + add(add.sd) + dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + prop(prop.sd) + dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + pow(pow.sd, exponent) + dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+cauchy </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> yeoJohnson </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + add(add.sd) + prop(prop.sd) + dcauchy() + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+cauchy </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> yeoJohnson </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + add(add.sd) + prop(prop.sd) + dcauchy() + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+cauchy </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> yeoJohnson </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + add(add.sd) + pow(pop.sd, exponent) + dcauchy() + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+cauchy </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> yeoJohnson </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + add(add.sd) + pow(pop.sd, exponent) + dcauchy() + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   constant+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ logitNorm(logit.sd)+dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ logitNorm(NA) + prop(prop.sd)+dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ logitNorm(NA) + pow(pow.sd, exponent) + dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+cauchy </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ logitNorm(logit.sd) + prop(prop.sd) + dcauchy() + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+cauchy </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ logitNorm(logit.sd) + prop(prop.sd) + dcauchy() + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+cauchy </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ logitNorm(logit.sd) + pow(pow.sd, exponent) + dcauchy() + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+cauchy </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ logitNorm(logit.sd) + pow(pow.sd, exponent) + dcauchy() + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson(logit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + logitNorm(logit.sd) + dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson(logit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + logitNorm(NA) + prop(prop.sd) + dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson(logit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + logitNorm(NA) + pow(pow.sd, exponent) + dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+cauchy </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> yeoJohnson(logit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + logitNorm(logit.sd) + prop(prop.sd) + dcauchy() + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+cauchy </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> yeoJohnson(logit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + logitNorm(logit.sd) + prop(prop.sd) + dcauchy() + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+cauchy </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> yeoJohnson(logit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + logitNorm(logit.sd) + pow(pow.sd, exponent) + dcauchy() + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+cauchy </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> yeoJohnson(logit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + logitNorm(logit.sd) + pow(pow.sd, exponent) + dcauchy() + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   constant+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> logit </td><td style="text-align: left;"> var ~ probitNorm(probit.sd) + dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> probit </td><td style="text-align: left;"> var ~ probitNorm(NA) + prop(prop.sd) + dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> probit </td><td style="text-align: left;"> var ~ probitNorm(NA) + pow(pow.sd, exponent) + dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+cauchy </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> probit </td><td style="text-align: left;"> var ~ probitNorm(probit.sd) + prop(prop.sd) + dcauchy() + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+cauchy </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> probit </td><td style="text-align: left;"> var ~ probitNorm(probit.sd) + prop(prop.sd) + dcauchy() + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+cauchy </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> probit </td><td style="text-align: left;"> var ~ probitNorm(probit.sd) + pow(pow.sd, exponent) + dcauchy() + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+cauchy </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> probit </td><td style="text-align: left;"> var ~ probitNorm(probit.sd) + pow(pow.sd, exponent) + dcauchy() + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson(probit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + probitNorm(probit.sd) + dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   proportional+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson(probit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + probitNorm(NA) + prop(prop.sd) + dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   power+cauchy </td><td style="text-align: left;">  </td><td style="text-align: left;"> yeoJohnson(probit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + probitNorm(NA) + pow(pow.sd, exponent) + dcauchy() </td><td style="text-align: left;">  </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+cauchy </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> yeoJohnson(probit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + probitNorm(probit.sd) + prop(prop.sd) + dcauchy() + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+proportional+cauchy </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> yeoJohnson(probit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + probitNorm(probit.sd) + prop(prop.sd) + dcauchy() + combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+cauchy </td><td style="text-align: left;"> combined1 </td><td style="text-align: left;"> yeoJohnson(probit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + probitNorm(probit.sd) + pow(pow.sd, exponent) + dcauchy() + combined1() </td><td style="text-align: left;"> addProp=1 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   additive+power+cauchy </td><td style="text-align: left;"> combined2 </td><td style="text-align: left;"> yeoJohnson(probit()) </td><td style="text-align: left;"> var ~ yeoJohnson(lambda) + probitNorm(probit.sd) + pow(pow.sd, exponent) + dcauchy() +combined2() </td><td style="text-align: left;"> addProp=2 </td><td style="text-align: left;"> response variable </td>
</tr>
<tr>
 <td style="text-align: left;">
   poission </td><td style="text-align: left;">  </td><td style="text-align: left;"> none </td><td style="text-align: left;"> cmt ~ dpois(lamba) </td><td style="text-align: left;">  </td><td style="text-align: left;"> compartment specification </td>
</tr>
<tr>
 <td style="text-align: left;">
   binomial </td><td style="text-align: left;">  </td><td style="text-align: left;"> none </td><td style="text-align: left;"> cmt ~ dbinom(n, p) </td><td style="text-align: left;">  </td><td style="text-align: left;"> compartment specification </td>
</tr>
<tr>
 <td style="text-align: left;">
   beta </td><td style="text-align: left;">  </td><td style="text-align: left;"> none </td><td style="text-align: left;"> cmt ~ dbeta(alpha, beta) </td><td style="text-align: left;">  </td><td style="text-align: left;"> compartment specification </td>
</tr>
<tr>
 <td style="text-align: left;">
   chisq </td><td style="text-align: left;">  </td><td style="text-align: left;"> none </td><td style="text-align: left;"> cmt ~ dchisq(nu) </td><td style="text-align: left;">  </td><td style="text-align: left;"> compartment specification </td>
</tr>
<tr>
 <td style="text-align: left;">
   exponential </td><td style="text-align: left;">  </td><td style="text-align: left;"> none </td><td style="text-align: left;"> cmt ~ dexp(r) </td><td style="text-align: left;">  </td><td style="text-align: left;"> compartment specification </td>
</tr>
<tr>
 <td style="text-align: left;">
   uniform </td><td style="text-align: left;">  </td><td style="text-align: left;"> none </td><td style="text-align: left;"> cmt ~ dunif(a, b) </td><td style="text-align: left;">  </td><td style="text-align: left;"> compartment specification </td>
</tr>
<tr>
 <td style="text-align: left;">
   weibull </td><td style="text-align: left;">  </td><td style="text-align: left;"> none </td><td style="text-align: left;"> cmt ~ dweibull(a, b) </td><td style="text-align: left;">  </td><td style="text-align: left;"> compartment specification </td>
</tr>
<tr>
 <td style="text-align: left;">
   gamma </td><td style="text-align: left;">  </td><td style="text-align: left;"> none </td><td style="text-align: left;"> cmt ~ dgamma(a, b) </td><td style="text-align: left;">  </td><td style="text-align: left;"> compartment specification </td>
</tr>
<tr>
 <td style="text-align: left;">
   geometric </td><td style="text-align: left;">  </td><td style="text-align: left;"> none </td><td style="text-align: left;"> cmt ~ dgeom(a) </td><td style="text-align: left;">  </td><td style="text-align: left;"> compartment specification </td>
</tr>
<tr>
 <td style="text-align: left;">
   negative binomial form #1 </td><td style="text-align: left;">  </td><td style="text-align: left;"> none </td><td style="text-align: left;"> cmt ~ dnbinom(n, p) </td><td style="text-align: left;">  </td><td style="text-align: left;"> compartment specification </td>
</tr>
<tr>
 <td style="text-align: left;">
   negative binomial form #2 </td><td style="text-align: left;">  </td><td style="text-align: left;"> none </td><td style="text-align: left;"> cmt ~ dnbinomMu(size, mu) </td><td style="text-align: left;">  </td><td style="text-align: left;"> compartment specification </td>
</tr>
<tr>
 <td style="text-align: left;">
   ordinal probability </td><td style="text-align: left;">  </td><td style="text-align: left;"> none </td><td style="text-align: left;"> cmt ~ c(p0=0, p1=1, p2=2, 3) </td><td style="text-align: left;">  </td><td style="text-align: left;"> compartment specification </td>
</tr>
<tr>
 <td style="text-align: left;">
   log-likelihood </td><td style="text-align: left;">  </td><td style="text-align: left;"> none </td><td style="text-align: left;"> ll(cmt) ~ log likelihood expression </td><td style="text-align: left;">  </td><td style="text-align: left;"> likelihood + compartment expression </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>





<h3>Value</h3>

<p>An object (environment) of class <code>rxode2</code> (see Chambers and Temple Lang (2001))
consisting of the following list of strings and functions:
</p>
<div class="sourceCode"><pre>* `model` a character string holding the source model specification.
* `get.modelVars`a function that returns a list with 3 character
    vectors, `params`, `state`, and `lhs` of variable names used in the model
    specification. These will be output when the model is computed (i.e., the ODE solved by integration).

  * `solve`{this function solves (integrates) the ODE. This
      is done by passing the code to [rxSolve()].
      This is as if you called `rxSolve(rxode2object, ...)`,
      but returns a matrix instead of a rxSolve object.

      `params`: a numeric named vector with values for every parameter
      in the ODE system; the names must correspond to the parameter
      identifiers used in the ODE specification;

      `events`: an `eventTable` object describing the
      input (e.g., doses) to the dynamic system and observation
      sampling time points (see  [eventTable()]);

      `inits`: a vector of initial values of the state variables
      (e.g., amounts in each compartment), and the order in this vector
      must be the same as the state variables (e.g., PK/PD compartments);


      `stiff`: a logical (`TRUE` by default) indicating whether
      the ODE system is stiff or not.

      For stiff ODE systems (`stiff = TRUE`), `rxode2` uses
      the LSODA (Livermore Solver for Ordinary Differential Equations)
      Fortran package, which implements an automatic method switching
      for stiff and non-stiff problems along the integration interval,
      authored by Hindmarsh and Petzold (2003).

      For non-stiff systems (`stiff = FALSE`), `rxode2` uses `DOP853`,
      an explicit Runge-Kutta method of order 8(5, 3) of Dormand and Prince
      as implemented in C by Hairer and Wanner (1993).

      `trans_abs`: a logical (`FALSE` by default) indicating
      whether to fit a transit absorption term
      (TODO: need further documentation and example);

      `atol`: a numeric absolute tolerance (1e-08 by default);

      `rtol`: a numeric relative tolerance (1e-06 by default).

      The output of \dQuote{solve} is a matrix with as many rows as there
      are sampled time points and as many columns as system variables
      (as defined by the ODEs and additional assignments in the rxode2 model
          code).}

  * `isValid` a function that (naively) checks for model validity,
      namely that the C object code reflects the latest model
      specification.
  * `version` a string with the version of the `rxode2`
      object (not the package).
  * `dynLoad` a function with one `force = FALSE` argument
      that dynamically loads the object code if needed.
  * `dynUnload` a function with no argument that unloads
      the model object code.
  * `delete` removes all created model files, including C and DLL files.
      The model object is no longer valid and should be removed, e.g.,
      `rm(m1)`.
  * `run` deprecated, use `solve`.
  * `get.index` deprecated.
  * `getObj` internal (not user callable) function.
</pre></div>


<h3>Creating rxode2 models</h3>

<p>NA
</p>


<h3>Note on strings in rxode2</h3>

<p>Strings are converted to double values inside of <code>rxode2</code>, hence you can
refer to them as an integer corresponding to the string value or the
string value itself. For covariates these are calculated on the fly
based on your data and you should likely not try this, though you should
be aware. For strings defined in the model, this is fixed and both could
be used.
</p>
<p>For example:
</p>
<div class="sourceCode"><pre>if (APGAR == 10 || APGAR == 8 || APGAR == 9) {
    tAPGAR &lt;- "High"
  } else if (APGAR == 1 || APGAR == 2 || APGAR == 3) {
    tAPGAR &lt;- "Low"
  } else if (APGAR == 4 || APGAR == 5 || APGAR == 6 || APGAR == 7) {
    tAPGAR &lt;- "Med"
  } else {
    tAPGAR&lt;- "Med"
  }
</pre></div>
<p>Could also be replaced by:
</p>
<div class="sourceCode"><pre>if (APGAR == 10 || APGAR == 8 || APGAR == 9) {
    tAPGAR &lt;- "High"
  } else if (APGAR == 1 || APGAR == 2 || APGAR == 3) {
    tAPGAR &lt;- "Low"
  } else if (APGAR == 4 || APGAR == 5 || APGAR == 6 || APGAR == 7) {
    tAPGAR &lt;- "Med"
  } else {
    tAPGAR&lt;- 3
  }
</pre></div>
<p>Since <code>"Med"</code> is already defined
</p>
<p>If you wanted you can pre-declare what levels it has (and the order) to
give you better control of this:
</p>
<div class="sourceCode"><pre>levels(tAPGAR) &lt;- c("Med", "Low", "High")
if (APGAR == 10 || APGAR == 8 || APGAR == 9) {
    tAPGAR &lt;- 3
  } else if (APGAR == 1 || APGAR == 2 || APGAR == 3) {
    tAPGAR &lt;- 2
  } else if (APGAR == 4 || APGAR == 5 || APGAR == 6 || APGAR == 7) {
    tAPGAR &lt;- 1
  } else {
    tAPGAR&lt;- 1
  }
</pre></div>
<p>You can see that the number changed since the declaration change the
numbers in each variable for <code>tAPGAR</code>. These <code>levels()</code> statements need
to be declared before the variable occurs to ensure the numbering is
consistent with what is declared.
</p>


<h3>Author(s)</h3>

<p>Melissa Hallow, Wenping Wang and Matthew Fidler
</p>


<h3>References</h3>

<p>Chamber, J. M. and Temple Lang, D. (2001)
<em>Object Oriented Programming in R</em>.
R News, Vol. 1, No. 3, September 2001.
<a href="https://cran.r-project.org/doc/Rnews/Rnews_2001-3.pdf">https://cran.r-project.org/doc/Rnews/Rnews_2001-3.pdf</a>.
</p>
<p>Hindmarsh, A. C.
<em>ODEPACK, A Systematized Collection of ODE Solvers</em>.
Scientific Computing, R. S. Stepleman et al. (Eds.),
North-Holland, Amsterdam, 1983, pp. 55-64.
</p>
<p>Petzold, L. R.
<em>Automatic Selection of Methods for Solving Stiff and Nonstiff
Systems of Ordinary Differential Equations</em>.
Siam J. Sci. Stat. Comput. 4 (1983), pp. 136-148.
</p>
<p>Hairer, E., Norsett, S. P., and Wanner, G.
<em>Solving ordinary differential equations I, nonstiff problems</em>.
2nd edition, Springer Series in Computational Mathematics,
Springer-Verlag (1993).
</p>
<p>Plevyak, J.
<em><code>dparser</code></em>, <a href="https://dparser.sourceforge.net/">https://dparser.sourceforge.net/</a>. Web. 12 Oct. 2015.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eventTable">eventTable()</a></code>, <code><a href="#topic+et">et()</a></code>, <code><a href="#topic+add.sampling">add.sampling()</a></code>, <code><a href="#topic+add.dosing">add.dosing()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

mod &lt;- function() {
  ini({
    KA   &lt;- .291
    CL   &lt;- 18.6
    V2   &lt;- 40.2
    Q    &lt;- 10.5
    V3   &lt;- 297.0
    Kin  &lt;- 1.0
    Kout &lt;- 1.0
    EC50 &lt;- 200.0
  })
  model({
    # A 4-compartment model, 3 PK and a PD (effect) compartment
    # (notice state variable names 'depot', 'centr', 'peri', 'eff')
    C2 &lt;- centr/V2
    C3 &lt;- peri/V3
    d/dt(depot) &lt;- -KA*depot;
    d/dt(centr) &lt;- KA*depot - CL*C2 - Q*C2 + Q*C3;
    d/dt(peri)  &lt;-                    Q*C2 - Q*C3;
    d/dt(eff)   &lt;- Kin - Kout*(1-C2/(EC50+C2))*eff;
    eff(0)      &lt;- 1
  })
}

m1 &lt;- rxode2(mod)
print(m1)

# Step 2 - Create the model input as an EventTable,
# including dosing and observation (sampling) events

# QD (once daily) dosing for 5 days.

qd &lt;- et(amountUnits = "ug", timeUnits = "hours") %&gt;%
  et(amt = 10000, addl = 4, ii = 24)

# Sample the system hourly during the first day, every 8 hours
# then after
qd &lt;- qd %&gt;% et(0:24) %&gt;%
  et(from = 24 + 8, to = 5 * 24, by = 8)

# Step 3 - solve the system

qd.cp &lt;- rxSolve(m1, qd)

head(qd.cp)



</code></pre>

<hr>
<h2 id='rxode2+26lt+3B-'>Set the function body of an rxUi object while retaining other object
information (like data)</h2><span id='topic+rxode2+3C-'></span><span id='topic+rxode2+3C-.function'></span><span id='topic+rxode2+3C-.default'></span><span id='topic+rxode+3C-'></span><span id='topic+RxODE+3C-'></span>

<h3>Description</h3>

<p>Set the function body of an rxUi object while retaining other object
information (like data)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxode2(x, envir = environment(x)) &lt;- value

## S3 replacement method for class ''function''
rxode2(x, envir = environment(x)) &lt;- value

## Default S3 replacement method:
rxode2(x, envir = environment(x)) &lt;- value

rxode(x, envir = environment(x)) &lt;- value

RxODE(x, envir = environment(x)) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxode2+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>The rxUi object</p>
</td></tr>
<tr><td><code id="rxode2+2B26lt+2B3B-_+3A_envir">envir</code></td>
<td>
<p>environment where the assignment ocurs</p>
</td></tr>
<tr><td><code id="rxode2+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>the value that will be assigned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The rxode2 ui/function
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
one.compartment &lt;- function() {
  ini({
    tka &lt;- log(1.57); label("Ka")
    tcl &lt;- log(2.72); label("Cl")
    tv &lt;- log(31.5); label("V")
    eta.ka ~ 0.6
    eta.cl ~ 0.3
    eta.v ~ 0.1
    add.sd &lt;- 0.7
  })
  model({
    ka &lt;- exp(tka + eta.ka)
    cl &lt;- exp(tcl + eta.cl)
    v &lt;- exp(tv + eta.v)
    d/dt(depot) = -ka * depot
    d/dt(center) = ka * depot - cl / v * center
    cp = center / v
    cp ~ add(add.sd)
  })
}

two.compartment &lt;- function() {
  ini({
    lka &lt;- 0.45 ; label("Absorption rate (Ka)")
    lcl &lt;- 1 ; label("Clearance (CL)")
    lvc  &lt;- 3 ; label("Central volume of distribution (V)")
    lvp  &lt;- 5 ; label("Peripheral volume of distribution (Vp)")
    lq  &lt;- 0.1 ; label("Intercompartmental clearance (Q)")
    propSd &lt;- 0.5 ; label("Proportional residual error (fraction)")
  })
  model({
    ka &lt;- exp(lka)
    cl &lt;- exp(lcl)
    vc &lt;- exp(lvc)
    vp &lt;- exp(lvp)
    q  &lt;- exp(lq)
    kel &lt;- cl/vc
    k12 &lt;- q/vc
    k21 &lt;- q/vp
    d/dt(depot) &lt;- -ka*depot
    d/dt(central) &lt;-  ka*depot - kel*central - k12*central + k21*peripheral1
    d/dt(peripheral1) &lt;- k12*central - k21*peripheral1
    cp &lt;- central / vc
    cp ~ prop(propSd)
  })
}

ui &lt;- rxode2(one.compartment)

rxode2(ui) &lt;- two.compartment

</code></pre>

<hr>
<h2 id='rxode2parse'>Internal translation to get model variables list</h2><span id='topic+rxode2parse'></span>

<h3>Description</h3>

<p>Internal translation to get model variables list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxode2parse(
  model,
  linear = FALSE,
  linCmtSens = c("linCmtA", "linCmtB", "linCmtC"),
  verbose = FALSE,
  code = NULL,
  envir = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxode2parse_+3A_model">model</code></td>
<td>
<p>Model (either file name or string)</p>
</td></tr>
<tr><td><code id="rxode2parse_+3A_linear">linear</code></td>
<td>
<p>boolean indicating if linear compartment model should
be generated from <code>linCmt()</code> (default FALSE)</p>
</td></tr>
<tr><td><code id="rxode2parse_+3A_lincmtsens">linCmtSens</code></td>
<td>
<p>Linear compartment model sensitivity type</p>
</td></tr>
<tr><td><code id="rxode2parse_+3A_verbose">verbose</code></td>
<td>
<p>is a boolean indicating the type of model detected
with <code>linCmt()</code> parsing</p>
</td></tr>
<tr><td><code id="rxode2parse_+3A_code">code</code></td>
<td>
<p>is a file name where the c code is written to (for
testing purposes mostly, it needs <code>rxode2</code> to do anything fancy)</p>
</td></tr>
<tr><td><code id="rxode2parse_+3A_envir">envir</code></td>
<td>
<p>is the environment to look for R user functions
(defaults to parent environment)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A rxModelVars object that has the model variables of a
rxode2 syntax expression
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rxode2parse("a=3")
</code></pre>

<hr>
<h2 id='rxode2parseAssignPointerTranslation'>This sets function gets the currently assigned function pointer assignments</h2><span id='topic+rxode2parseAssignPointerTranslation'></span>

<h3>Description</h3>

<p>This sets function gets the currently assigned function pointer assignments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxode2parseAssignPointerTranslation(var)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxode2parseAssignPointerTranslation_+3A_var">var</code></td>
<td>
<p>List of packages where pointer assignment will be called.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, called for side effects
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rxode2parseAssignPointerTranslation("rxode2")
</code></pre>

<hr>
<h2 id='rxode2parseAssignTranslation'>This assigns the c level linkages for a roxde2 model</h2><span id='topic+rxode2parseAssignTranslation'></span>

<h3>Description</h3>

<p>This assigns the c level linkages for a roxde2 model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxode2parseAssignTranslation(df)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxode2parseAssignTranslation_+3A_df">df</code></td>
<td>
<p>data frame containing the character column names rxFun,
fun, type, package, packageFun and the integer column names
argMin and argMax</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing called for side effects
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rxode2parseAssignTranslation(rxode2parseGetTranslation())

</code></pre>

<hr>
<h2 id='rxode2parseD'>This gives the derivative table for rxode2</h2><span id='topic+rxode2parseD'></span>

<h3>Description</h3>

<p>This will help allow registration of functions in <code>rxode2</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxode2parseD()
</code></pre>


<h3>Details</h3>

<p>This environment is a derivative table;
</p>
<p>For example:
</p>
<p>Derivative(f(a,b,c), a) = fa()
Derivative(f(a,b,c), b) = fb()
Derivative(f(a,b,c), c) = fc()
</p>
<p>Then the derivative table for <code>f</code> would be:
</p>
<p>assign(&quot;f&quot;, list(fa(a,b,c), fb(a,b,c), fc(a,b,c)), rxode2parseD())
</p>
<p>fa translates the arguments to the derivative with respect to a
fb translates the arguments to the derivative with respect to b
</p>
<p>If any of the list is NULL then rxode2 won't know how to take a
derivative with respect to the argument.
</p>
<p>If the list is shorter than the length of the arguments then the
argument then the derivative of arguments that are not specified
cannot be taken.
</p>


<h3>Value</h3>

<p>Derivative table environment for rxode2
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxode2parseGetPackagesToLoad'>Control the packages that are loaded when a <code>rxode2</code> model dll is loaded</h2><span id='topic+rxode2parseGetPackagesToLoad'></span><span id='topic+rxode2parseAssignPackagesToLoad'></span>

<h3>Description</h3>

<p>Control the packages that are loaded when a <code>rxode2</code> model dll is loaded
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxode2parseGetPackagesToLoad()

rxode2parseAssignPackagesToLoad(pkgs = rxode2parseGetPackagesToLoad())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxode2parseGetPackagesToLoad_+3A_pkgs">pkgs</code></td>
<td>
<p>The packages to make sure are loaded every time you load an rxode2 model.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List of packages to load
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rxode2parseGetPackagesToLoad()

rxode2parseAssignPackagesToLoad(rxode2parseGetPackagesToLoad())
</code></pre>

<hr>
<h2 id='rxode2parseGetPointerAssignment'>This function gets the currently assigned function pointer assignments</h2><span id='topic+rxode2parseGetPointerAssignment'></span>

<h3>Description</h3>

<p>This function gets the currently assigned function pointer assignments
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxode2parseGetPointerAssignment()
</code></pre>


<h3>Value</h3>

<p>The currently assigned pointer assignments
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rxode2parseGetTranslation()
</code></pre>

<hr>
<h2 id='rxode2parseGetTranslation'>This function gets the currently assigned translations</h2><span id='topic+rxode2parseGetTranslation'></span>

<h3>Description</h3>

<p>This function gets the currently assigned translations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxode2parseGetTranslation()
</code></pre>


<h3>Value</h3>

<p>The currently assigned translations
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rxode2parseGetTranslation()
</code></pre>

<hr>
<h2 id='rxOptExpr'>Optimize rxode2 for computer evaluation</h2><span id='topic+rxOptExpr'></span>

<h3>Description</h3>

<p>This optimizes rxode2 code for computer evaluation by only
calculating redundant expressions once.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxOptExpr(x, msg = "model")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxOptExpr_+3A_x">x</code></td>
<td>
<p>rxode2 model that can be accessed by rxNorm</p>
</td></tr>
<tr><td><code id="rxOptExpr_+3A_msg">msg</code></td>
<td>
<p>This is the name of type of object that rxode2 is
optimizing that will in the message when optimizing.  For
example &quot;model&quot; will produce the following message while
optimizing the model:
</p>
<p>finding duplicate expressions in model...</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Optimized rxode2 model text.  The order and type lhs and
state variables is maintained while the evaluation is sped up.
While parameters names are maintained, their order may be
modified.
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxord'>Simulate ordinal value</h2><span id='topic+rxord'></span>

<h3>Description</h3>

<p>Simulate ordinal value
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxord(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxord_+3A_...">...</code></td>
<td>
<p>the probabilities to be simulated.  These should sum up to a number below one.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The values entered into the 'rxord' simulation will simulate the
probability of falling each group. If it falls outside of the
specified probabilities, it will simulate the group (number of
probabilities specified + 1)
</p>


<h3>Value</h3>

<p>A number from 1 to the (number of probabilities specified + 1)
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# This will give values 1, and 2
rxord(0.5)
rxord(0.5)
rxord(0.5)
rxord(0.5)

# This will give values 1, 2 and 3
rxord(0.3, 0.3)
rxord(0.3, 0.3)
rxord(0.3, 0.3)

</code></pre>

<hr>
<h2 id='rxParams'>Parameters specified by the model</h2><span id='topic+rxParams'></span><span id='topic+rxParams.rxode2'></span><span id='topic+rxParams.rxSolve'></span><span id='topic+rxParams.rxEt'></span><span id='topic+rxParam'></span>

<h3>Description</h3>

<p>This returns the model's parameters that are required to solve the
ODE system, and can be used to pipe parameters into an rxode2 solve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxParams(obj, ...)

## S3 method for class 'rxode2'
rxParams(
  obj,
  constants = TRUE,
  ...,
  params = NULL,
  inits = NULL,
  iCov = NULL,
  keep = NULL,
  thetaMat = NULL,
  omega = NULL,
  dfSub = NULL,
  sigma = NULL,
  dfObs = NULL,
  nSub = NULL,
  nStud = NULL
)

## S3 method for class 'rxSolve'
rxParams(
  obj,
  constants = TRUE,
  ...,
  params = NULL,
  inits = NULL,
  iCov = NULL,
  keep = NULL,
  thetaMat = NULL,
  omega = NULL,
  dfSub = NULL,
  sigma = NULL,
  dfObs = NULL,
  nSub = NULL,
  nStud = NULL
)

## S3 method for class 'rxEt'
rxParams(
  obj,
  ...,
  params = NULL,
  inits = NULL,
  iCov = NULL,
  keep = NULL,
  thetaMat = NULL,
  omega = NULL,
  dfSub = NULL,
  sigma = NULL,
  dfObs = NULL,
  nSub = NULL,
  nStud = NULL
)

rxParam(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxParams_+3A_obj">obj</code></td>
<td>
<p>rxode2 family of objects</p>
</td></tr>
<tr><td><code id="rxParams_+3A_...">...</code></td>
<td>
<p>Other arguments including scaling factors for each
compartment.  This includes S# = numeric will scale a compartment
# by a dividing the compartment amount by the scale factor,
like NONMEM.</p>
</td></tr>
<tr><td><code id="rxParams_+3A_constants">constants</code></td>
<td>
<p>is a boolean indicting if constants should be
included in the list of parameters. Currently rxode2 parses
constants into variables in case you wish to change them
without recompiling the rxode2 model.</p>
</td></tr>
<tr><td><code id="rxParams_+3A_params">params</code></td>
<td>
<p>a numeric named vector with values for every
parameter in the ODE system; the names must correspond to the
parameter identifiers used in the ODE specification;</p>
</td></tr>
<tr><td><code id="rxParams_+3A_inits">inits</code></td>
<td>
<p>a vector of initial values of the state variables
(e.g., amounts in each compartment), and the order in this
vector must be the same as the state variables (e.g., PK/PD
compartments);</p>
</td></tr>
<tr><td><code id="rxParams_+3A_icov">iCov</code></td>
<td>
<p>A data frame of individual non-time varying covariates
to combine with the <code>events</code> dataset.  The <code>iCov</code> dataset has one
covariate per ID and should match the event table</p>
</td></tr>
<tr><td><code id="rxParams_+3A_keep">keep</code></td>
<td>
<p>Columns to keep from either the input dataset or the
<code>iCov</code> dataset.  With the <code>iCov</code> dataset, the column
is kept once per line.  For the input dataset, if any records
are added to the data LOCF (Last Observation Carried forward)
imputation is performed.</p>
</td></tr>
<tr><td><code id="rxParams_+3A_thetamat">thetaMat</code></td>
<td>
<p>Named theta matrix.</p>
</td></tr>
<tr><td><code id="rxParams_+3A_omega">omega</code></td>
<td>
<p>Estimate of Covariance matrix. When omega is a list,
assume it is a block matrix and convert it to a full matrix for
simulations.  When <code>omega</code> is <code>NA</code> and you are using it with a
<code>rxode2</code> ui model, the between subject variability described by
the <code>omega</code> matrix are set to zero.</p>
</td></tr>
<tr><td><code id="rxParams_+3A_dfsub">dfSub</code></td>
<td>
<p>Degrees of freedom to sample the between subject variability matrix from the
inverse Wishart distribution (scaled) or scaled inverse chi squared distribution.</p>
</td></tr>
<tr><td><code id="rxParams_+3A_sigma">sigma</code></td>
<td>
<p>Named sigma covariance or Cholesky decomposition of a
covariance matrix.  The names of the columns indicate
parameters that are simulated.  These are simulated for every
observation in the solved system. When <code>sigma</code> is <code>NA</code> and you are using it with a
<code>rxode2</code> ui model, the unexplained variability described by
the <code>sigma</code> matrix are set to zero.</p>
</td></tr>
<tr><td><code id="rxParams_+3A_dfobs">dfObs</code></td>
<td>
<p>Degrees of freedom to sample the unexplained variability matrix from the
inverse Wishart distribution (scaled) or scaled inverse chi squared distribution.</p>
</td></tr>
<tr><td><code id="rxParams_+3A_nsub">nSub</code></td>
<td>
<p>Number between subject variabilities (<code>ETAs</code>) simulated for every
realization of the parameters.</p>
</td></tr>
<tr><td><code id="rxParams_+3A_nstud">nStud</code></td>
<td>
<p>Number virtual studies to characterize uncertainty in estimated
parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When extracting the parameters from an rxode2 model, a
character vector listing the parameters in the model.
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>


<h3>See Also</h3>

<p>Other Query model information: 
<code><a href="#topic+rxDfdy">rxDfdy</a>()</code>,
<code><a href="#topic+rxInits">rxInits</a>()</code>,
<code><a href="#topic+rxLhs">rxLhs</a>()</code>,
<code><a href="#topic+rxModelVars">rxModelVars</a>()</code>,
<code><a href="#topic+rxState">rxState</a>()</code>
</p>

<hr>
<h2 id='rxParseErr'>Prepare Error function for inclusion in rxode2</h2><span id='topic+rxParseErr'></span>

<h3>Description</h3>

<p>Prepare Error function for inclusion in rxode2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxParseErr(
  x,
  baseTheta,
  ret = "rx_r_",
  init = NULL,
  addProp = c("combined2", "combined1")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxParseErr_+3A_x">x</code></td>
<td>
<p>error function</p>
</td></tr>
<tr><td><code id="rxParseErr_+3A_basetheta">baseTheta</code></td>
<td>
<p>Base theta to start numbering add(.) and prop(.) from.</p>
</td></tr>
<tr><td><code id="rxParseErr_+3A_ret">ret</code></td>
<td>
<p>Internal return type.  Should not be changed by the user...</p>
</td></tr>
<tr><td><code id="rxParseErr_+3A_init">init</code></td>
<td>
<p>Initialization vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rxode2 transformed text
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxParsePk'>Parse PK function for inclusion in rxode2</h2><span id='topic+rxParsePk'></span>

<h3>Description</h3>

<p>Parse PK function for inclusion in rxode2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxParsePk(x, init = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxParsePk_+3A_x">x</code></td>
<td>
<p>PK function</p>
</td></tr>
<tr><td><code id="rxParsePk_+3A_init">init</code></td>
<td>
<p>Initialization vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rxode2 transformed text.
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxParsePred'>Prepare Pred function for inclusion in rxode2</h2><span id='topic+rxParsePred'></span>

<h3>Description</h3>

<p>Prepare Pred function for inclusion in rxode2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxParsePred(x, init = NULL, err = NULL, addProp = c("combined2", "combined1"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxParsePred_+3A_x">x</code></td>
<td>
<p>pred function</p>
</td></tr>
<tr><td><code id="rxParsePred_+3A_init">init</code></td>
<td>
<p>Initialization vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rxode2 transformed text.
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxParseSetSilentErr'>Silence some of rxode2's C/C++ messages</h2><span id='topic+rxParseSetSilentErr'></span>

<h3>Description</h3>

<p>Silence some of rxode2's C/C++ messages
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxParseSetSilentErr(silent)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxParseSetSilentErr_+3A_silent">silent</code></td>
<td>
<p>can be 0L &quot;noisy&quot;  or 1L &quot;silent&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE; called for side effects
</p>

<hr>
<h2 id='rxParseSuppressMsg'>Respect suppress messages</h2><span id='topic+rxParseSuppressMsg'></span>

<h3>Description</h3>

<p>This turns on the silent REprintf in C when <code>suppressMessages()</code> is
turned on. This makes the <code>REprintf</code> act like <code>messages</code> in R,
they can be suppressed with <code>suppressMessages()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxParseSuppressMsg()
</code></pre>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# rxParseSuppressMsg() is called with rxode2()

# Note the errors are output to the console

try(rxode2parse("d/dt(matt)=/3"), silent = TRUE)

# When using suppressMessages, the output is suppressed

suppressMessages(try(rxode2parse("d/dt(matt)=/3"), silent = TRUE))

# In rxode2, we use REprintf so that interrupted threads do not crash R
# if there is a user interrupt. This isn't captured by R's messages, but
# This interface allows the `suppressMessages()` to suppress the C printing
# as well

# If you  want to suppress messages from rxode2 in other packages, you can use
# this function
</code></pre>

<hr>
<h2 id='rxPkg'>Creates a package from compiled rxode2 models</h2><span id='topic+rxPkg'></span>

<h3>Description</h3>

<p>Creates a package from compiled rxode2 models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxPkg(
  ...,
  package,
  wd = getwd(),
  action = c("install", "build", "binary", "create"),
  license = c("gpl3", "lgpl", "mit", "agpl3"),
  name = "Firstname Lastname",
  fields = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxPkg_+3A_...">...</code></td>
<td>
<p>Models to build a package from</p>
</td></tr>
<tr><td><code id="rxPkg_+3A_package">package</code></td>
<td>
<p>String of the package name to create</p>
</td></tr>
<tr><td><code id="rxPkg_+3A_wd">wd</code></td>
<td>
<p>character string with a working directory where to
create a subdirectory according to <code>modName</code>. When
specified, a subdirectory named after the
&ldquo;<code>modName.d</code>&rdquo; will be created and populated with a
C file, a dynamic loading library, plus various other working
files. If missing, the files are created (and removed) in the
temporary directory, and the rxode2 DLL for the model is
created in the current directory named <code style="white-space: pre;">&#8288;rx_????_platform&#8288;</code>, for
example <code>rx_129f8f97fb94a87ca49ca8dafe691e1e_i386.dll</code></p>
</td></tr>
<tr><td><code id="rxPkg_+3A_action">action</code></td>
<td>
<p>Type of action to take after package is created</p>
</td></tr>
<tr><td><code id="rxPkg_+3A_license">license</code></td>
<td>
<p>is the type of license for the package.</p>
</td></tr>
<tr><td><code id="rxPkg_+3A_name">name</code></td>
<td>
<p>Full name of author</p>
</td></tr>
<tr><td><code id="rxPkg_+3A_fields">fields</code></td>
<td>
<p>A named list of fields to add to <code>DESCRIPTION</code>, potentially
overriding default values. See <code><a href="usethis.html#topic+use_description">use_description()</a></code> for how you can set
personalized defaults using package options.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>this function returns nothing and is used for its side effects
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='rxpois'>Simulate random Poisson variable from threefry generator</h2><span id='topic+rxpois'></span>

<h3>Description</h3>

<p>Care should be taken with this method not to encounter the
birthday problem, described
<a href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/">https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/</a>.
Since the <code>sitmo</code> <code>threefry</code>, this currently generates
one random deviate from the uniform distribution to seed the
engine <code>threefry</code> and then run the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxpois(lambda, n = 1L, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxpois_+3A_lambda">lambda</code></td>
<td>
<p>vector of (non-negative) means.</p>
</td></tr>
<tr><td><code id="rxpois_+3A_n">n</code></td>
<td>
<p>number of random values to return.</p>
</td></tr>
<tr><td><code id="rxpois_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the simulation
</p>
<p><code>rxnorm</code> simulates using the threefry sitmo generator.
</p>
<p><code>rxnormV</code> used to simulate with the vandercorput simulator, but
since it didn't satisfy the normal properties it was changed to simple be
an alias of <code>rxnorm</code>. It is no longer supported in <code>rxode2({})</code> blocks</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Therefore, a simple call to the random number generated followed by a second
call to random number generated may have identical seeds.  As the number of
random number generator calls are increased the probability that the
birthday problem will increase.
</p>
<p>The key to avoid this problem is to either run all simulations in the
<code>rxode2</code> environment once (therefore one seed or series of seeds
for the whole simulation), pre-generate all random variables
used for the simulation, or seed the rxode2 engine with <code>rxSetSeed()</code>
</p>
<p>Internally each ID is seeded with a unique number so that the
results do not depend on the number of cores used.
</p>


<h3>Value</h3>

<p>poission random number deviates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Use threefry engine

rxpois(lambda = 3, n = 10) # with rxpois you have to explicitly state n
rxpois(lambda = 3, n = 10, ncores = 2) # You can parallelize the simulation using openMP

rxpois(4) ## The first arguments are the lambda parameter


## This example uses `rxpois` directly in the model

rx &lt;- function() {
  model({
    a &lt;- rxpois(3)
  })
}

et &lt;- et(1, id = 1:2)

s &lt;- rxSolve(rx, et)

</code></pre>

<hr>
<h2 id='rxPp'>Simulate a from a Poisson process</h2><span id='topic+rxPp'></span>

<h3>Description</h3>

<p>Simulate a from a Poisson process
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxPp(
  n,
  lambda,
  gamma = 1,
  prob = NULL,
  t0 = 0,
  tmax = Inf,
  randomOrder = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxPp_+3A_n">n</code></td>
<td>
<p>Number of time points to simulate in the Poisson process</p>
</td></tr>
<tr><td><code id="rxPp_+3A_lambda">lambda</code></td>
<td>
<p>Rate of Poisson process</p>
</td></tr>
<tr><td><code id="rxPp_+3A_gamma">gamma</code></td>
<td>
<p>Asymmetry rate of Poisson process.  When gamma=1.0,
this simulates a homogenous Poisson process.  When gamma&lt;1.0,
the Poisson process has more events early, when gamma &gt; 1.0,
the Poisson process has more events late in the process.
</p>
<p>When gamma is non-zero, the tmax should not be infinite but indicate
the end of the Poisson process to be simulated.  In most
pharamcometric cases, this will be the end of the study.
Internally this uses a rate of:
</p>
<p>l(t) = lambda<em>gamma</em>(t/tmax)^(gamma-1)</p>
</td></tr>
<tr><td><code id="rxPp_+3A_prob">prob</code></td>
<td>
<p>When specified, this is a probability function with
one argument, time, that gives the probability that a Poisson
time t is accepted as a rejection time.</p>
</td></tr>
<tr><td><code id="rxPp_+3A_t0">t0</code></td>
<td>
<p>the starting time of the Poisson process</p>
</td></tr>
<tr><td><code id="rxPp_+3A_tmax">tmax</code></td>
<td>
<p>the maximum time of the Poisson process</p>
</td></tr>
<tr><td><code id="rxPp_+3A_randomorder">randomOrder</code></td>
<td>
<p>when <code>TRUE</code> randomize the order of the Poisson
events.  By default (<code>FALSE</code>) it returns the Poisson process is
in order of how the events occurred.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This returns a vector of the Poisson process times; If the dropout is &gt;=
tmax, then all the rest of the times are = tmax to indicate the
dropout is equal to or after tmax.
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Sample homogenous Poisson process of rate 1/10
rxPp(10, 1 / 10)

## Sample inhomogenous Poisson rate of 1/10

rxPp(10, 1 / 10, gamma = 2, tmax = 100)

## Typically the Poisson process times are in a sequential order,
## using randomOrder gives the Poisson process in random order

rxPp(10, 1 / 10, gamma = 2, tmax = 10, randomOrder = TRUE)

## This uses an arbitrary function to sample a non-homogenous Poisson process

rxPp(10, 1 / 10, prob = function(x) {
  1/(1+abs(x))
})

</code></pre>

<hr>
<h2 id='rxPreferredDistributionName'>Change distribution name to the preferred distribution name term</h2><span id='topic+rxPreferredDistributionName'></span>

<h3>Description</h3>

<p>This is determined by the internal preferred condition name list
<code>.errIdenticalDists</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxPreferredDistributionName(dist)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxPreferredDistributionName_+3A_dist">dist</code></td>
<td>
<p>This is the input distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Preferred distribution term
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rxPreferredDistributionName("dt")

rxPreferredDistributionName("add")

# can be vectorized

rxPreferredDistributionName(c("add","dt"))

</code></pre>

<hr>
<h2 id='rxProgress'>rxode2 progress bar functions</h2><span id='topic+rxProgress'></span><span id='topic+rxTick'></span><span id='topic+rxProgressStop'></span><span id='topic+rxProgressAbort'></span>

<h3>Description</h3>

<p><code>rxProgress</code> sets up the progress bar
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxProgress(num, core = 0L)

rxTick()

rxProgressStop(clear = TRUE)

rxProgressAbort(error = "Aborted calculation")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxProgress_+3A_num">num</code></td>
<td>
<p>Tot number of operations to track</p>
</td></tr>
<tr><td><code id="rxProgress_+3A_core">core</code></td>
<td>
<p>Number of cores to show.  If below 1, don't show
number of cores</p>
</td></tr>
<tr><td><code id="rxProgress_+3A_clear">clear</code></td>
<td>
<p>Boolean telling if you should clear the progress bar
after completion (as if it wasn't displayed).  By default this is TRUE</p>
</td></tr>
<tr><td><code id="rxProgress_+3A_error">error</code></td>
<td>
<p>With rxProgressAbort this is the error that is displayed</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>rxTick</code> is a progress bar tick
</p>
<p><code>rxProgressStop</code> stop progress bar
</p>
<p><code>rxProgressAbort</code> shows an abort if <code>rxProgressStop</code>
wasn't called.
</p>


<h3>Value</h3>

<p>All return NULL invisibly.
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
f &lt;- function() {
  on.exit({
    rxProgressAbort()
  })
  rxProgress(100)
  for (i in 1:100) {
    rxTick()
    Sys.sleep(1 / 100)
  }
  rxProgressStop()
}

f()


</code></pre>

<hr>
<h2 id='rxPrune'>Prune branches (ie if/else) from rxode2</h2><span id='topic+rxPrune'></span>

<h3>Description</h3>

<p>This prunes branches (ie if/else) from rxode2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxPrune(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxPrune_+3A_x">x</code></td>
<td>
<p>rxode2 model that can be accessed by rxNorm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Pruned rxode2 model text.
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxRateDur'>Creates a rxRateDur object</h2><span id='topic+rxRateDur'></span><span id='topic++5B.rxRateDur'></span><span id='topic+as.rxRateDur'></span><span id='topic+as.character.rxRateDur'></span><span id='topic++5B+5B.rxRateDur'></span>

<h3>Description</h3>

<p>This is primarily to display information about rate
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxRateDur(x)

## S3 method for class 'rxRateDur'
x[...]

as.rxRateDur(x)

## S3 method for class 'rxRateDur'
as.character(x, ...)

## S3 method for class 'rxRateDur'
x[[...]]
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxRateDur_+3A_x">x</code></td>
<td>
<p>rxRateDur data</p>
</td></tr>
<tr><td><code id="rxRateDur_+3A_...">...</code></td>
<td>
<p>Other parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rxRateDur object
</p>

<hr>
<h2 id='rxReload'>Reload rxode2 DLL</h2><span id='topic+rxReload'></span>

<h3>Description</h3>

<p>Can be useful for debugging
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxReload()
</code></pre>


<h3>Value</h3>

<p>boolean of if the object is reloaded
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxRemoveControl'>rxRemoveControl options for UI object</h2><span id='topic+rxRemoveControl'></span>

<h3>Description</h3>

<p>rxRemoveControl options for UI object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxRemoveControl(ui)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxRemoveControl_+3A_ui">ui</code></td>
<td>
<p>rxode2 ui object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, called for side effects
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxRename'>Rename items inside of a <code>rxode2</code> ui model</h2><span id='topic+rxRename'></span><span id='topic+.rxRename'></span><span id='topic+rename.rxUi'></span><span id='topic+rename.function'></span><span id='topic+rxRename.rxUi'></span><span id='topic+rxRename.function'></span><span id='topic+rxRename.default'></span>

<h3>Description</h3>

<p><code>rxRename()</code> changes the names of individual variables, lhs, and ode states using
<code>new_name = old_name</code> syntax
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxRename(.data, ..., envir = parent.frame())

.rxRename(.data, ..., envir = parent.frame())

rename.rxUi(.data, ...)

rename.function(.data, ...)

## S3 method for class 'rxUi'
rxRename(.data, ...)

## S3 method for class ''function''
rxRename(.data, ...)

## Default S3 method:
rxRename(.data, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxRename_+3A_.data">.data</code></td>
<td>
<p>rxode2 ui function, named data to be consistent with <code>dplyr::rename()</code></p>
</td></tr>
<tr><td><code id="rxRename_+3A_...">...</code></td>
<td>
<p>rename items</p>
</td></tr>
<tr><td><code id="rxRename_+3A_envir">envir</code></td>
<td>
<p>Environment for evaluation</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is similar to <code>dplyr</code>'s <code>rename()</code> function.  When <code>dplyr</code> is
loaded, the <code>s3</code> methods work for the ui objects.
</p>
<p>Note that the <code>.rxRename()</code> is the internal function that is called
when renaming and is likely not what you need to call unless you
are writing your own extension of the function
</p>


<h3>Value</h3>

<p>New model with items renamed
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ocmt &lt;- function() {
  ini({
    tka &lt;- exp(0.45) # Ka
    tcl &lt;- exp(1) # Cl
    ## This works with interactive models
    ## You may also label the preceding line with label("label text")
    tv &lt;- exp(3.45) # log V
    ## the label("Label name") works with all models
    add.sd &lt;- 0.7
  })
  model({
    ka &lt;- tka
    cl &lt;- tcl
    v &lt;- tv
    d/dt(depot) = -ka * depot
    d/dt(center) = ka * depot - cl / v * center
    cp = center / v
    cp ~ add(add.sd)
  })
}

ocmt %&gt;% rxRename(cpParent=cp)

</code></pre>

<hr>
<h2 id='rxRepR0_'>Rep R0 for foce</h2><span id='topic+rxRepR0_'></span>

<h3>Description</h3>

<p>Rep R0 for foce
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxRepR0_(neta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxRepR0__+3A_neta">neta</code></td>
<td>
<p>ETA to substitute</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a string of R code to substitute the rx_r expression in the symengine environment .s
</p>

<hr>
<h2 id='rxReq'>Require namespace, otherwise throw error.</h2><span id='topic+rxReq'></span>

<h3>Description</h3>

<p>Require namespace, otherwise throw error.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxReq(pkg)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxReq_+3A_pkg">pkg</code></td>
<td>
<p>Package required for function to work.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxReservedKeywords'>A list and description of rxode2 supported reserved keywords</h2><span id='topic+rxReservedKeywords'></span>

<h3>Description</h3>

<p>A list and description of rxode2 supported reserved keywords
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxReservedKeywords
</code></pre>


<h3>Format</h3>

<p>A data frame with 3 columns and 31 rows
</p>

<dl>
<dt>Reserved Name</dt><dd><p>Reserved Keyword Name</p>
</dd>
<dt>Meaning</dt><dd><p>Reserved Keyword Meaning</p>
</dd>
<dt>Alias</dt><dd><p>Keyword Alias</p>
</dd>
</dl>


<hr>
<h2 id='rxResidualError'>A description of Rode2 supported residual errors</h2><span id='topic+rxResidualError'></span>

<h3>Description</h3>

<p>A description of Rode2 supported residual errors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxResidualError
</code></pre>


<h3>Format</h3>

<p>A data frame with 6 columns and 181 rows
</p>

<dl>
<dt>Error model</dt><dd><p>A description of the type of residual error</p>
</dd>
<dt>Functional Form</dt><dd><p>For additive and proportional what functional form is used</p>
</dd>
<dt>Transformation</dt><dd><p>The type of transformation that is done on the DV and the prediction</p>
</dd>
<dt>code</dt><dd><p>Example code for the residual error type</p>
</dd>
<dt>addProp</dt><dd><p>The type of add+prop residual error default that would be equivalent</p>
</dd>
<dt>lhs</dt><dd><p>what the left handed side of the specification represents, either a response variable, or a compartment specification</p>
</dd>
</dl>


<hr>
<h2 id='rxRmvn'>Simulate from a (truncated) multivariate normal</h2><span id='topic+rxRmvn'></span>

<h3>Description</h3>

<p>This is simulated with the fast, thread-safe threefry simulator
and can use multiple cores to generate the random deviates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxRmvn(
  n,
  mu = NULL,
  sigma,
  lower = -Inf,
  upper = Inf,
  ncores = 1,
  isChol = FALSE,
  keepNames = TRUE,
  a = 0.4,
  tol = 2.05,
  nlTol = 1e-10,
  nlMaxiter = 100L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxRmvn_+3A_n">n</code></td>
<td>
<p>Number of random row vectors to be simulated OR the
matrix to use for simulation (faster).</p>
</td></tr>
<tr><td><code id="rxRmvn_+3A_mu">mu</code></td>
<td>
<p>mean vector</p>
</td></tr>
<tr><td><code id="rxRmvn_+3A_sigma">sigma</code></td>
<td>
<p>Covariance matrix for multivariate normal or a list
of covariance matrices. If a list of covariance matrix, each
matrix will simulate <code>n</code> matrices and combine them to a full
matrix</p>
</td></tr>
<tr><td><code id="rxRmvn_+3A_lower">lower</code></td>
<td>
<p>is a vector of the lower bound for the truncated
multivariate norm</p>
</td></tr>
<tr><td><code id="rxRmvn_+3A_upper">upper</code></td>
<td>
<p>is a vector of the upper bound for the truncated
multivariate norm</p>
</td></tr>
<tr><td><code id="rxRmvn_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores used in the simulation</p>
</td></tr>
<tr><td><code id="rxRmvn_+3A_ischol">isChol</code></td>
<td>
<p>A boolean indicating if <code>sigma</code> is a cholesky
decomposition of the covariance matrix.</p>
</td></tr>
<tr><td><code id="rxRmvn_+3A_keepnames">keepNames</code></td>
<td>
<p>Keep the names from either the mean or covariance
matrix.</p>
</td></tr>
<tr><td><code id="rxRmvn_+3A_a">a</code></td>
<td>
<p>threshold for switching between methods; They can be
tuned for maximum speed;  There are three cases that are considered:
</p>
<p>case 1: a &lt; l &lt; u
</p>
<p>case 2: l &lt; u &lt; -a
</p>
<p>case 3: otherwise
</p>
<p>where l=lower and u = upper</p>
</td></tr>
<tr><td><code id="rxRmvn_+3A_tol">tol</code></td>
<td>
<p>When case 3 is used from the above possibilities, the
tol value controls the acceptance rejection and
inverse-transformation;
</p>
<p>When abs(u-l)&gt;tol, uses accept-reject from randn</p>
</td></tr>
<tr><td><code id="rxRmvn_+3A_nltol">nlTol</code></td>
<td>
<p>Tolerance for newton line-search</p>
</td></tr>
<tr><td><code id="rxRmvn_+3A_nlmaxiter">nlMaxiter</code></td>
<td>
<p>Maximum iterations for newton line-search</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>n==integer</code> (default) the output is an (n x d) matrix
where the i-th row is the i-th simulated vector.
</p>
<p>If <code>is.matrix(n)</code> then the random vector are store in <code>n</code>,
which is provided by the user, and the function returns
<code>NULL</code> invisibly.
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler, Zdravko Botev and some from Matteo Fasiolo
</p>


<h3>References</h3>

<p>John K. Salmon, Mark A. Moraes, Ron O. Dror, and David
E. Shaw (2011). Parallel Random Numbers: As Easy as 1, 2, 3.
D. E. Shaw Research, New York, NY 10036, USA.
</p>
<p>The thread safe multivariate normal was inspired from the <code>mvnfast</code> package by Matteo Fasiolo <a href="https://CRAN.R-project.org/package=mvnfast">https://CRAN.R-project.org/package=mvnfast</a>
</p>
<p>The concept of the truncated multivariate normal was
taken from Zdravko Botev Botev (2017) <a href="https://doi.org/10.1111/rssb.12162">doi:10.1111/rssb.12162</a>
and Botev and L'Ecuyer (2015) <a href="https://doi.org/10.1109/WSC.2015.7408180">doi:10.1109/WSC.2015.7408180</a> and
converted to thread safe simulation;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## From mvnfast
## Unlike mvnfast, uses threefry simulation

d &lt;- 5
mu &lt;- 1:d

# Creating covariance matrix
tmp &lt;- matrix(rnorm(d^2), d, d)
mcov &lt;- tcrossprod(tmp, tmp)


set.seed(414)
rxRmvn(4, 1:d, mcov)

set.seed(414)
rxRmvn(4, 1:d, mcov)

set.seed(414)
rxRmvn(4, 1:d, mcov, ncores = 2) # r.v. generated on the second core are different

###### Here we create the matrix that will hold the simulated
#  random variables upfront.
A &lt;- matrix(NA, 4, d)
class(A) &lt;- "numeric" # This is important. We need the elements of A to be of class "numeric".

set.seed(414)
rxRmvn(A, 1:d, mcov, ncores = 2) # This returns NULL ...
A # ... but the result is here

## You can also simulate from a truncated normal:

rxRmvn(10, 1:d, mcov, lower = 1:d - 1, upper = 1:d + 1)


# You can also simulate from different matrices (if they match
# dimensions) by using a list of matrices.

matL &lt;- lapply(1:4, function(...) {
  tmp &lt;- matrix(rnorm(d^2), d, d)
  tcrossprod(tmp, tmp)
})


rxRmvn(4, setNames(1:d, paste0("a", 1:d)), matL)
</code></pre>

<hr>
<h2 id='rxS'>Load a model into a symengine environment</h2><span id='topic+rxS'></span>

<h3>Description</h3>

<p>Load a model into a symengine environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxS(x, doConst = TRUE, promoteLinSens = FALSE, envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxS_+3A_x">x</code></td>
<td>
<p>rxode2 object</p>
</td></tr>
<tr><td><code id="rxS_+3A_doconst">doConst</code></td>
<td>
<p>Load constants into the environment as well.</p>
</td></tr>
<tr><td><code id="rxS_+3A_promotelinsens">promoteLinSens</code></td>
<td>
<p>Promote solved linear compartment systems to
sensitivity-based solutions.</p>
</td></tr>
<tr><td><code id="rxS_+3A_envir">envir</code></td>
<td>
<p>default is <code>NULL</code>; Environment to put symengine
variables in.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>rxode2/symengine environment
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='rxSeedEng'>This seeds the engine based on the number of cores used in random number generation</h2><span id='topic+rxSeedEng'></span>

<h3>Description</h3>

<p>This seeds the engine based on the number of cores used in random number generation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSeedEng(ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxSeedEng_+3A_ncores">ncores</code></td>
<td>
<p>is the number of cores to use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, called for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rxSeedEng()
</code></pre>

<hr>
<h2 id='rxSetControl'>rxSetControl options for UI object</h2><span id='topic+rxSetControl'></span>

<h3>Description</h3>

<p>rxSetControl options for UI object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSetControl(ui, control)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxSetControl_+3A_ui">ui</code></td>
<td>
<p>rxode2 ui object</p>
</td></tr>
<tr><td><code id="rxSetControl_+3A_control">control</code></td>
<td>
<p>Default value</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, called for side effects
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxSetCovariateNamesForPiping'>Assign covariates for piping</h2><span id='topic+rxSetCovariateNamesForPiping'></span>

<h3>Description</h3>

<p>Assign covariates for piping
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSetCovariateNamesForPiping(covariates = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxSetCovariateNamesForPiping_+3A_covariates">covariates</code></td>
<td>
<p>NULL (for no covariates), or the list of
covariates. nlmixr uses this function to set covariates if you
pipe from a nlmixr fit.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing, called for side effects
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# First set the name of known covariates
# Note this is case sensitive

rxSetCovariateNamesForPiping(c("WT","HT", "TC"))

one.compartment &lt;- function() {
 ini({
   tka &lt;- 0.45 ; label("Log Ka")
   tcl &lt;- 1 ; label("Log Cl")
   tv &lt;- 3.45 ; label("Log V")
   eta.ka ~ 0.6
   eta.cl ~ 0.3
   eta.v ~ 0.1
   add.err &lt;- 0.7
 })
 model({
   ka &lt;- exp(tka + eta.ka)
   cl &lt;- exp(tcl + eta.cl)
   v &lt;- exp(tv + eta.v)
   d / dt(depot) &lt;- -ka * depot
   d/dt(depot) &lt;- -ka * depot
   d / dt(center) &lt;- ka * depot - cl / v * center
   cp &lt;- center / v
   cp ~ add(add.err)
 })
}

# now TC is detected as a covariate instead of a population parameter

one.compartment %&gt;%
  model({ka &lt;- exp(tka + eta.ka + TC * cov_C)})

# You can turn it off by simply adding it back

rxSetCovariateNamesForPiping()

one.compartment %&gt;%
  model({ka &lt;- exp(tka + eta.ka + TC * cov_C)})

# The covariates you set with `rxSetCovariateNamesForPiping()`
# are turned off every time you solve (or fit in nlmixr)

</code></pre>

<hr>
<h2 id='rxSetIni0'>Set Initial conditions to time zero instead of the first observed/dosed time</h2><span id='topic+rxSetIni0'></span>

<h3>Description</h3>

<p>Set Initial conditions to time zero instead of the first observed/dosed time
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSetIni0(ini0 = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxSetIni0_+3A_ini0">ini0</code></td>
<td>
<p>When <code>TRUE</code> (default), set initial conditions to time
zero. Otherwise the initial conditions are the first observed
time.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the boolean ini0, though this is called for its side effects
</p>

<hr>
<h2 id='rxSetPipingAuto'>Set the variables for the model piping automatic covarite selection</h2><span id='topic+rxSetPipingAuto'></span>

<h3>Description</h3>

<p>Set the variables for the model piping automatic covarite selection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSetPipingAuto(
  thetamodelVars = rex::rex(or("tv", "t", "pop", "POP", "Pop", "TV", "T", "cov", "err",
    "eff")),
  covariateExceptions = rex::rex(start, or("wt", "sex", "crcl", "kout"), end),
  etaParts = c("eta", "ETA", "Eta", "ppv", "PPV", "Ppv", "iiv", "Iiv", "bsv", "Bsv",
    "BSV", "bpv", "Bpv", "BPV", "psv", "PSV", "Psv")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxSetPipingAuto_+3A_thetamodelvars">thetamodelVars</code></td>
<td>
<p>This is the prefixes for the theta model
variables in a regular expression</p>
</td></tr>
<tr><td><code id="rxSetPipingAuto_+3A_covariateexceptions">covariateExceptions</code></td>
<td>
<p>This is a regular expression of
covariates that should always be covariates</p>
</td></tr>
<tr><td><code id="rxSetPipingAuto_+3A_etaparts">etaParts</code></td>
<td>
<p>This is the list of eta prefixes/post-fixes that
identify a variable as a between subject variability</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is called once at startup to set the defaults, though you can
change this if you wish so that piping can work differently for
your individual setup
</p>


<h3>Value</h3>

<p>Nothing, called for side effects
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxSetProd'>Defunct setting of product</h2><span id='topic+rxSetProd'></span>

<h3>Description</h3>

<p>Defunct setting of product
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSetProd(type = c("long double", "double", "logify"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxSetProd_+3A_type">type</code></td>
<td>
<p>used to be type of product</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>

<hr>
<h2 id='rxSetProgressBar'>Set timing for progress bar</h2><span id='topic+rxSetProgressBar'></span>

<h3>Description</h3>

<p>Set timing for progress bar
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSetProgressBar(seconds = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxSetProgressBar_+3A_seconds">seconds</code></td>
<td>
<p>This sets the number of seconds that need to elapse
before drawing the next segment of the progress bar.  When
this is zero or below this turns off the progress bar.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing, used for side effects
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='rxSetSeed'>Set the parallel seed for rxode2 random number generation</h2><span id='topic+rxSetSeed'></span>

<h3>Description</h3>

<p>This sets the seed for the rxode2 parallel random number generation.
If set, then whenever a seed is set for the threefry or
vandercorput simulation engine, it will use this seed, increment
for the number of seeds and continue with the sequence the next
time the random number generator is called.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSetSeed(seed)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxSetSeed_+3A_seed">seed</code></td>
<td>
<p>An integer that represents the rxode2 parallel and
internal random number generator seed.  When positive, use this
seed for random number generation and increment and reseed any
parallel or new engines that are being called. When negative,
turn off the rxode2 seed and generate a seed from the R's uniform
random number generator.  Best practice is to set this seed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In contrast, when this is not called, the time that the
vandercorput or threefry simulation engines are seeded it comes
from a uniform random number generated from the standard R random
seed.  This may cause a duplicate seed based on the R seed state.
This means that there could be correlations between simulations
that do not exist This will avoid the birthday problem picking
exactly the same seed using the seed state of the R random number
generator.  The more times the seed is called, the more likely this
becomes.
</p>


<h3>Value</h3>

<p>Nothing, called for its side effects
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>


<h3>References</h3>

<p>JD Cook. (2016). Random number generator seed mistakes.
<a href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/">https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/</a>
</p>


<h3>See Also</h3>

<p>rxGetSeed, rxWithSeed, rxWithPreserveSeed
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rxSetSeed(42)

# seed with generator 42
rxnorm()

# Use R's random number generator
rnorm(1)

rxSetSeed(42)

# reproduces the same number
rxnorm()

# But R's random number is not the same

rnorm(1)

# If we reset this to use the R's seed
# (internally rxode2 uses a uniform random number to span seeds)
# This can lead to duplicate sequences and seeds

rxSetSeed(-1)

# Now set seed works for both.

# This is not recommended, but illustrates the different types of
# seeds that can be generated.

set.seed(42)

rxnorm()

rnorm(1)

set.seed(42)

rxnorm()

rnorm(1)

</code></pre>

<hr>
<h2 id='rxSetSilentErr'>Silence some of rxode2's C/C++ messages</h2><span id='topic+rxSetSilentErr'></span>

<h3>Description</h3>

<p>Silence some of rxode2's C/C++ messages
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSetSilentErr(silent)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxSetSilentErr_+3A_silent">silent</code></td>
<td>
<p>can be 0L &quot;noisy&quot;  or 1L &quot;silent&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE; called for side effects
</p>

<hr>
<h2 id='rxSetSum'>Defunct setting of sum</h2><span id='topic+rxSetSum'></span>

<h3>Description</h3>

<p>Defunct setting of sum
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSetSum(type = c("pairwise", "fsum", "kahan", "neumaier", "c"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxSetSum_+3A_type">type</code></td>
<td>
<p>used to be type of product</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>

<hr>
<h2 id='rxSetupIni'>Setup the initial conditions.</h2><span id='topic+rxSetupIni'></span>

<h3>Description</h3>

<p>Setup the initial conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSetupIni(obj, inits = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxSetupIni_+3A_obj">obj</code></td>
<td>
<p>rxode2 object</p>
</td></tr>
<tr><td><code id="rxSetupIni_+3A_inits">inits</code></td>
<td>
<p>A numeric vector of initial conditions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>initial conditions that were setup
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxSetupScale'>Setup the initial conditions.</h2><span id='topic+rxSetupScale'></span>

<h3>Description</h3>

<p>Setup the initial conditions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSetupScale(obj, scale = NULL, extraArgs = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxSetupScale_+3A_obj">obj</code></td>
<td>
<p>rxode2 object</p>
</td></tr>
<tr><td><code id="rxSetupScale_+3A_scale">scale</code></td>
<td>
<p>A numeric vector scales</p>
</td></tr>
<tr><td><code id="rxSetupScale_+3A_extraargs">extraArgs</code></td>
<td>
<p>A list of extra args to parse for initial conditions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>setup scale for changing compartment values
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxShiny'>Use Shiny to help develop an rxode2 model</h2><span id='topic+rxShiny'></span><span id='topic+rxShiny.rxSolve'></span><span id='topic+rxShiny.default'></span>

<h3>Description</h3>

<p>Use Shiny to help develop an rxode2 model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxShiny(
  object,
  params = NULL,
  events = NULL,
  inits = NULL,
  ...,
  data = data.frame()
)

## S3 method for class 'rxSolve'
rxShiny(
  object,
  params = NULL,
  events = NULL,
  inits = NULL,
  ...,
  data = data.frame()
)

## Default S3 method:
rxShiny(
  object = NULL,
  params = NULL,
  events = NULL,
  inits = NULL,
  ...,
  data = data.frame()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxShiny_+3A_object">object</code></td>
<td>
<p>A rxode2 family of objects. If not supplied a
2-compartment indirect effect model is used.  If it is
supplied, use the model associated with the rxode2 object for
the model exploration.</p>
</td></tr>
<tr><td><code id="rxShiny_+3A_params">params</code></td>
<td>
<p>Initial parameters for model</p>
</td></tr>
<tr><td><code id="rxShiny_+3A_events">events</code></td>
<td>
<p>Event information (currently ignored)</p>
</td></tr>
<tr><td><code id="rxShiny_+3A_inits">inits</code></td>
<td>
<p>Initial estimates for model</p>
</td></tr>
<tr><td><code id="rxShiny_+3A_...">...</code></td>
<td>
<p>Other arguments passed to rxShiny.  Currently doesn't
do anything.</p>
</td></tr>
<tr><td><code id="rxShiny_+3A_data">data</code></td>
<td>
<p>Any data that you would like to plot.  If the data has
a <code>time</code> variable as well as a compartment or calculated
variable that matches the rxode2 model, the data will be added
to the plot of a specific compartment or calculated variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing; Starts a shiny server
</p>


<h3>Author(s)</h3>

<p>Zufar Mulyukov and Matthew L. Fidler
</p>

<hr>
<h2 id='rxSimThetaOmega'>Simulate Parameters from a Theta/Omega specification</h2><span id='topic+rxSimThetaOmega'></span>

<h3>Description</h3>

<p>Simulate Parameters from a Theta/Omega specification
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSimThetaOmega(
  params = NULL,
  omega = NULL,
  omegaDf = NULL,
  omegaLower = as.numeric(c(R_NegInf)),
  omegaUpper = as.numeric(c(R_PosInf)),
  omegaIsChol = FALSE,
  omegaSeparation = "auto",
  omegaXform = 1L,
  nSub = 1L,
  thetaMat = NULL,
  thetaLower = as.numeric(c(R_NegInf)),
  thetaUpper = as.numeric(c(R_PosInf)),
  thetaDf = NULL,
  thetaIsChol = FALSE,
  nStud = 1L,
  sigma = NULL,
  sigmaLower = as.numeric(c(R_NegInf)),
  sigmaUpper = as.numeric(c(R_PosInf)),
  sigmaDf = NULL,
  sigmaIsChol = FALSE,
  sigmaSeparation = "auto",
  sigmaXform = 1L,
  nCoresRV = 1L,
  nObs = 1L,
  dfSub = 0,
  dfObs = 0,
  simSubjects = TRUE,
  simVariability = as.logical(c(NA_LOGICAL))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxSimThetaOmega_+3A_params">params</code></td>
<td>
<p>Named Vector of rxode2 model parameters</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_omega">omega</code></td>
<td>
<p>Estimate of Covariance matrix. When omega is a list,
assume it is a block matrix and convert it to a full matrix for
simulations.  When <code>omega</code> is <code>NA</code> and you are using it with a
<code>rxode2</code> ui model, the between subject variability described by
the <code>omega</code> matrix are set to zero.</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_omegadf">omegaDf</code></td>
<td>
<p>The degrees of freedom of a t-distribution for
simulation.  By default this is <code>NULL</code> which is
equivalent to <code>Inf</code> degrees, or to simulate from a normal
distribution instead of a t-distribution.</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_omegalower">omegaLower</code></td>
<td>
<p>Lower bounds for simulated ETAs (by default -Inf)</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_omegaupper">omegaUpper</code></td>
<td>
<p>Upper bounds for simulated ETAs (by default Inf)</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_omegaischol">omegaIsChol</code></td>
<td>
<p>Indicates if the <code>omega</code> supplied is a
Cholesky decomposed matrix instead of the traditional
symmetric matrix.</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_omegaseparation">omegaSeparation</code></td>
<td>
<p>Omega separation strategy
</p>
<p>Tells the type of separation strategy when
simulating covariance with parameter uncertainty with standard
deviations modeled in the <code>thetaMat</code> matrix.
</p>

<ul>
<li> <p><code>"lkj"</code> simulates the correlation matrix from the
<code>rLKJ1</code> matrix with the distribution parameter <code>eta</code>
equal to the degrees of freedom <code>nu</code> by <code>(nu-1)/2</code>
</p>
</li>
<li> <p><code>"separation"</code> simulates from the identity inverse Wishart
covariance matrix with <code>nu</code> degrees of freedom.  This is then
converted to a covariance matrix and augmented with the modeled
standard deviations.  While computationally more complex than the
<code>"lkj"</code> prior, it performs better when the covariance matrix
size is greater or equal to 10
</p>
</li>
<li> <p><code>"auto"</code> chooses <code>"lkj"</code> when the dimension of the
matrix is less than 10 and <code>"separation"</code> when greater
than equal to 10.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_omegaxform">omegaXform</code></td>
<td>
<p>When taking <code>omega</code> values from the <code>thetaMat</code>
simulations (using the separation strategy for covariance
simulation), how should the <code>thetaMat</code> values be turned int
standard deviation values:
</p>

<ul>
<li> <p><code>identity</code> This is when standard deviation values are
directly modeled by the <code>params</code> and <code>thetaMat</code> matrix
</p>
</li>
<li> <p><code>variance</code> This is when the <code>params</code> and <code>thetaMat</code>
simulates the variance that are directly modeled by the
<code>thetaMat</code> matrix
</p>
</li>
<li> <p><code>log</code> This is when the <code>params</code> and <code>thetaMat</code>
simulates <code>log(sd)</code>
</p>
</li>
<li> <p><code>nlmixrSqrt</code> This is when the <code>params</code> and
<code>thetaMat</code> simulates the inverse cholesky decomposed matrix
with the <code style="white-space: pre;">&#8288;x\^2&#8288;</code> modeled along the diagonal.  This only works
with a diagonal matrix.
</p>
</li>
<li> <p><code>nlmixrLog</code> This is when the <code>params</code> and
<code>thetaMat</code> simulates the inverse cholesky decomposed matrix
with the <code style="white-space: pre;">&#8288;exp(x\^2)&#8288;</code> along the diagonal.  This only works
with a diagonal matrix.
</p>
</li>
<li> <p><code>nlmixrIdentity</code> This is when the <code>params</code> and
<code>thetaMat</code> simulates the inverse cholesky decomposed matrix.
This only works with a diagonal matrix.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_nsub">nSub</code></td>
<td>
<p>Number between subject variabilities (<code>ETAs</code>) simulated for every
realization of the parameters.</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_thetamat">thetaMat</code></td>
<td>
<p>Named theta matrix.</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_thetalower">thetaLower</code></td>
<td>
<p>Lower bounds for simulated population parameter
variability (by default <code>-Inf</code>)</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_thetaupper">thetaUpper</code></td>
<td>
<p>Upper bounds for simulated population unexplained
variability (by default <code>Inf</code>)</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_thetadf">thetaDf</code></td>
<td>
<p>The degrees of freedom of a t-distribution for
simulation.  By default this is <code>NULL</code> which is
equivalent to <code>Inf</code> degrees, or to simulate from a normal
distribution instead of a <code>t</code>-distribution.</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_thetaischol">thetaIsChol</code></td>
<td>
<p>Indicates if the <code>theta</code> supplied is a
Cholesky decomposed matrix instead of the traditional
symmetric matrix.</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_nstud">nStud</code></td>
<td>
<p>Number virtual studies to characterize uncertainty in estimated
parameters.</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_sigma">sigma</code></td>
<td>
<p>Named sigma covariance or Cholesky decomposition of a
covariance matrix.  The names of the columns indicate
parameters that are simulated.  These are simulated for every
observation in the solved system. When <code>sigma</code> is <code>NA</code> and you are using it with a
<code>rxode2</code> ui model, the unexplained variability described by
the <code>sigma</code> matrix are set to zero.</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_sigmalower">sigmaLower</code></td>
<td>
<p>Lower bounds for simulated unexplained variability (by default -Inf)</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_sigmaupper">sigmaUpper</code></td>
<td>
<p>Upper bounds for simulated unexplained variability (by default Inf)</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_sigmadf">sigmaDf</code></td>
<td>
<p>Degrees of freedom of the sigma t-distribution.  By
default it is equivalent to <code>Inf</code>, or a normal distribution.</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_sigmaischol">sigmaIsChol</code></td>
<td>
<p>Boolean indicating if the sigma is in the
Cholesky decomposition instead of a symmetric covariance</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_sigmaseparation">sigmaSeparation</code></td>
<td>
<p>separation strategy for sigma;
</p>
<p>Tells the type of separation strategy when
simulating covariance with parameter uncertainty with standard
deviations modeled in the <code>thetaMat</code> matrix.
</p>

<ul>
<li> <p><code>"lkj"</code> simulates the correlation matrix from the
<code>rLKJ1</code> matrix with the distribution parameter <code>eta</code>
equal to the degrees of freedom <code>nu</code> by <code>(nu-1)/2</code>
</p>
</li>
<li> <p><code>"separation"</code> simulates from the identity inverse Wishart
covariance matrix with <code>nu</code> degrees of freedom.  This is then
converted to a covariance matrix and augmented with the modeled
standard deviations.  While computationally more complex than the
<code>"lkj"</code> prior, it performs better when the covariance matrix
size is greater or equal to 10
</p>
</li>
<li> <p><code>"auto"</code> chooses <code>"lkj"</code> when the dimension of the
matrix is less than 10 and <code>"separation"</code> when greater
than equal to 10.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_sigmaxform">sigmaXform</code></td>
<td>
<p>When taking <code>sigma</code> values from the <code>thetaMat</code>
simulations (using the separation strategy for covariance
simulation), how should the <code>thetaMat</code> values be turned int
standard deviation values:
</p>

<ul>
<li> <p><code>identity</code> This is when standard deviation values are
directly modeled by the <code>params</code> and <code>thetaMat</code> matrix
</p>
</li>
<li> <p><code>variance</code> This is when the <code>params</code> and <code>thetaMat</code>
simulates the variance that are directly modeled by the
<code>thetaMat</code> matrix
</p>
</li>
<li> <p><code>log</code> This is when the <code>params</code> and <code>thetaMat</code>
simulates <code>log(sd)</code>
</p>
</li>
<li> <p><code>nlmixrSqrt</code> This is when the <code>params</code> and
<code>thetaMat</code> simulates the inverse cholesky decomposed matrix
with the <code style="white-space: pre;">&#8288;x\^2&#8288;</code> modeled along the diagonal.  This only works
with a diagonal matrix.
</p>
</li>
<li> <p><code>nlmixrLog</code> This is when the <code>params</code> and
<code>thetaMat</code> simulates the inverse cholesky decomposed matrix
with the <code style="white-space: pre;">&#8288;exp(x\^2)&#8288;</code> along the diagonal.  This only works
with a diagonal matrix.
</p>
</li>
<li> <p><code>nlmixrIdentity</code> This is when the <code>params</code> and
<code>thetaMat</code> simulates the inverse cholesky decomposed matrix.
This only works with a diagonal matrix.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_ncoresrv">nCoresRV</code></td>
<td>
<p>Number of cores used for the simulation of the
sigma variables.  By default this is 1. To reproduce the results
you need to run on the same platform with the same number of
cores. This is the reason this is set to be one, regardless of
what the number of cores are used in threaded ODE solving.</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_nobs">nObs</code></td>
<td>
<p>Number of observations to simulate (with <code>sigma</code> matrix)</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_dfsub">dfSub</code></td>
<td>
<p>Degrees of freedom to sample the between subject variability matrix from the
inverse Wishart distribution (scaled) or scaled inverse chi squared distribution.</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_dfobs">dfObs</code></td>
<td>
<p>Degrees of freedom to sample the unexplained variability matrix from the
inverse Wishart distribution (scaled) or scaled inverse chi squared distribution.</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_simsubjects">simSubjects</code></td>
<td>
<p>boolean indicated rxode2 should simulate subjects in studies (<code>TRUE</code>,
default) or studies (<code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="rxSimThetaOmega_+3A_simvariability">simVariability</code></td>
<td>
<p>determines if the variability is simulated.
When <code>NA</code> (default) this is determined by the solver.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame with the simulated subjects
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>

<hr>
<h2 id='rxSolve'>Options, Solving &amp; Simulation of an ODE/solved system</h2><span id='topic+rxSolve'></span><span id='topic+rxSolve.function'></span><span id='topic+rxSolve.rxUi'></span><span id='topic+rxSolve.rxode2tos'></span><span id='topic+rxSolve.nlmixr2FitData'></span><span id='topic+rxSolve.nlmixr2FitCore'></span><span id='topic+rxSolve.default'></span><span id='topic+update.rxSolve'></span><span id='topic+predict.rxode2'></span><span id='topic+predict.function'></span><span id='topic+predict.rxUi'></span><span id='topic+predict.rxSolve'></span><span id='topic+predict.rxEt'></span><span id='topic+predict.rxParams'></span><span id='topic+simulate.rxode2'></span><span id='topic+simulate.rxSolve'></span><span id='topic+simulate.rxParams'></span><span id='topic+solve.rxSolve'></span><span id='topic+solve.rxUi'></span><span id='topic+solve.function'></span><span id='topic+solve.rxode2'></span><span id='topic+solve.rxParams'></span><span id='topic+solve.rxEt'></span><span id='topic+rxControl'></span>

<h3>Description</h3>

<p>This uses rxode2 family of objects, file, or model specification to
solve a ODE system.  There are many options for a solved rxode2
model, the first are the required <code>object</code>, and <code>events</code> with the
some-times optional <code>params</code> and <code>inits</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSolve(
  object,
  params = NULL,
  events = NULL,
  inits = NULL,
  scale = NULL,
  method = c("liblsoda", "lsoda", "dop853", "indLin"),
  sigdig = NULL,
  atol = 1e-08,
  rtol = 1e-06,
  maxsteps = 70000L,
  hmin = 0,
  hmax = NA_real_,
  hmaxSd = 0,
  hini = 0,
  maxordn = 12L,
  maxords = 5L,
  ...,
  cores,
  covsInterpolation = c("locf", "linear", "nocb", "midpoint"),
  naInterpolation = c("locf", "nocb"),
  keepInterpolation = c("na", "locf", "nocb"),
  addCov = TRUE,
  sigma = NULL,
  sigmaDf = NULL,
  sigmaLower = -Inf,
  sigmaUpper = Inf,
  nCoresRV = 1L,
  sigmaIsChol = FALSE,
  sigmaSeparation = c("auto", "lkj", "separation"),
  sigmaXform = c("identity", "variance", "log", "nlmixrSqrt", "nlmixrLog",
    "nlmixrIdentity"),
  nDisplayProgress = 10000L,
  amountUnits = NA_character_,
  timeUnits = "hours",
  theta = NULL,
  thetaLower = -Inf,
  thetaUpper = Inf,
  eta = NULL,
  addDosing = FALSE,
  stateTrim = Inf,
  updateObject = FALSE,
  omega = NULL,
  omegaDf = NULL,
  omegaIsChol = FALSE,
  omegaSeparation = c("auto", "lkj", "separation"),
  omegaXform = c("variance", "identity", "log", "nlmixrSqrt", "nlmixrLog",
    "nlmixrIdentity"),
  omegaLower = -Inf,
  omegaUpper = Inf,
  nSub = 1L,
  thetaMat = NULL,
  thetaDf = NULL,
  thetaIsChol = FALSE,
  nStud = 1L,
  dfSub = 0,
  dfObs = 0,
  returnType = c("rxSolve", "matrix", "data.frame", "data.frame.TBS", "data.table",
    "tbl", "tibble"),
  seed = NULL,
  nsim = NULL,
  minSS = 10L,
  maxSS = 1000L,
  infSSstep = 12,
  strictSS = TRUE,
  istateReset = TRUE,
  subsetNonmem = TRUE,
  maxAtolRtolFactor = 0.1,
  from = NULL,
  to = NULL,
  by = NULL,
  length.out = NULL,
  iCov = NULL,
  keep = NULL,
  indLinPhiTol = 1e-07,
  indLinPhiM = 0L,
  indLinMatExpType = c("expokit", "Al-Mohy", "arma"),
  indLinMatExpOrder = 6L,
  drop = NULL,
  idFactor = TRUE,
  mxhnil = 0,
  hmxi = 0,
  warnIdSort = TRUE,
  warnDrop = TRUE,
  ssAtol = 1e-08,
  ssRtol = 1e-06,
  safeZero = TRUE,
  safeLog = TRUE,
  safePow = TRUE,
  sumType = c("pairwise", "fsum", "kahan", "neumaier", "c"),
  prodType = c("long double", "double", "logify"),
  sensType = c("advan", "autodiff", "forward", "central"),
  linDiff = c(tlag = 1.5e-05, f = 1.5e-05, rate = 1.5e-05, dur = 1.5e-05, tlag2 =
    1.5e-05, f2 = 1.5e-05, rate2 = 1.5e-05, dur2 = 1.5e-05),
  linDiffCentral = c(tlag = TRUE, f = TRUE, rate = TRUE, dur = TRUE, tlag2 = TRUE, f2 =
    TRUE, rate2 = TRUE, dur2 = TRUE),
  resample = NULL,
  resampleID = TRUE,
  maxwhile = 1e+05,
  atolSens = 1e-08,
  rtolSens = 1e-06,
  ssAtolSens = 1e-08,
  ssRtolSens = 1e-06,
  simVariability = NA,
  nLlikAlloc = NULL,
  useStdPow = FALSE,
  naTimeHandle = c("ignore", "warn", "error"),
  addlKeepsCov = FALSE,
  addlDropSs = TRUE,
  ssAtDoseTime = TRUE,
  ss2cancelAllPending = FALSE,
  envir = parent.frame()
)

## S3 method for class ''function''
rxSolve(
  object,
  params = NULL,
  events = NULL,
  inits = NULL,
  ...,
  theta = NULL,
  eta = NULL,
  envir = parent.frame()
)

## S3 method for class 'rxUi'
rxSolve(
  object,
  params = NULL,
  events = NULL,
  inits = NULL,
  ...,
  theta = NULL,
  eta = NULL,
  envir = parent.frame()
)

## S3 method for class 'rxode2tos'
rxSolve(
  object,
  params = NULL,
  events = NULL,
  inits = NULL,
  ...,
  theta = NULL,
  eta = NULL,
  envir = parent.frame()
)

## S3 method for class 'nlmixr2FitData'
rxSolve(
  object,
  params = NULL,
  events = NULL,
  inits = NULL,
  ...,
  theta = NULL,
  eta = NULL,
  envir = parent.frame()
)

## S3 method for class 'nlmixr2FitCore'
rxSolve(
  object,
  params = NULL,
  events = NULL,
  inits = NULL,
  ...,
  theta = NULL,
  eta = NULL,
  envir = parent.frame()
)

## Default S3 method:
rxSolve(
  object,
  params = NULL,
  events = NULL,
  inits = NULL,
  ...,
  theta = NULL,
  eta = NULL,
  envir = parent.frame()
)

## S3 method for class 'rxSolve'
update(object, ...)

## S3 method for class 'rxode2'
predict(object, ...)

## S3 method for class ''function''
predict(object, ...)

## S3 method for class 'rxUi'
predict(object, ...)

## S3 method for class 'rxSolve'
predict(object, ...)

## S3 method for class 'rxEt'
predict(object, ...)

## S3 method for class 'rxParams'
predict(object, ...)

## S3 method for class 'rxode2'
simulate(object, nsim = 1L, seed = NULL, ...)

## S3 method for class 'rxSolve'
simulate(object, nsim = 1L, seed = NULL, ...)

## S3 method for class 'rxParams'
simulate(object, nsim = 1L, seed = NULL, ...)

## S3 method for class 'rxSolve'
solve(a, b, ...)

## S3 method for class 'rxUi'
solve(a, b, ...)

## S3 method for class ''function''
solve(a, b, ...)

## S3 method for class 'rxode2'
solve(a, b, ...)

## S3 method for class 'rxParams'
solve(a, b, ...)

## S3 method for class 'rxEt'
solve(a, b, ...)

rxControl(
  ...,
  params = NULL,
  events = NULL,
  inits = NULL,
  envir = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxSolve_+3A_object">object</code></td>
<td>
<p>is a either a rxode2 family of objects, or a file-name
with a rxode2 model specification, or a string with a rxode2
model specification.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_params">params</code></td>
<td>
<p>a numeric named vector with values for every
parameter in the ODE system; the names must correspond to the
parameter identifiers used in the ODE specification;</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_events">events</code></td>
<td>
<p>an <code>eventTable</code> object describing the input
(e.g., doses) to the dynamic system and observation sampling
time points (see <code><a href="#topic+eventTable">eventTable()</a></code>);</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_inits">inits</code></td>
<td>
<p>a vector of initial values of the state variables
(e.g., amounts in each compartment), and the order in this
vector must be the same as the state variables (e.g., PK/PD
compartments);</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_scale">scale</code></td>
<td>
<p>a numeric named vector with scaling for ode
parameters of the system.  The names must correspond to the
parameter identifiers in the ODE specification. Each of the
ODE variables will be divided by the scaling factor.  For
example <code>scale=c(center=2)</code> will divide the center ODE
variable by 2.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_method">method</code></td>
<td>
<p>The method for solving ODEs.  Currently this supports:
</p>

<ul>
<li> <p><code>"liblsoda"</code> thread safe lsoda.  This supports parallel
thread-based solving, and ignores user Jacobian specification.
</p>
</li>
<li> <p><code>"lsoda"</code> &ndash; LSODA solver.  Does not support parallel thread-based
solving, but allows user Jacobian specification.
</p>
</li>
<li> <p><code>"dop853"</code> &ndash; DOP853 solver.  Does not support parallel thread-based
solving nor user Jacobian specification
</p>
</li>
<li> <p><code>"indLin"</code> &ndash; Solving through inductive linearization.  The rxode2 dll
must be setup specially to use this solving routine.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rxSolve_+3A_sigdig">sigdig</code></td>
<td>
<p>Specifies the &quot;significant digits&quot; that the ode
solving requests.  When specified this controls the relative and
absolute tolerances of the ODE solvers.  By default the tolerance
is <code>0.5*10^(-sigdig-2)</code> for regular ODEs. For the
sensitivity equations the default is <code style="white-space: pre;">&#8288;0.5*10\^(-sigdig-1.5)&#8288;</code>
(sensitivity changes only applicable for liblsoda).  This also
controls the <code>atol</code>/<code>rtol</code> of the steady state solutions. The
<code>ssAtol</code>/<code>ssRtol</code> is <code style="white-space: pre;">&#8288;0.5*10\^(-sigdig)&#8288;</code> and for the sensitivities
<code style="white-space: pre;">&#8288;0.5*10\^(-sigdig+0.625)&#8288;</code>.  By default
this is unspecified (<code>NULL</code>) and uses the standard <code>atol</code>/<code>rtol</code>.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_atol">atol</code></td>
<td>
<p>a numeric absolute tolerance (1e-8 by default) used
by the ODE solver to determine if a good solution has been
achieved;  This is also used in the solved linear model to check
if prior doses do not add anything to the solution.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_rtol">rtol</code></td>
<td>
<p>a numeric relative tolerance (<code>1e-6</code> by default) used
by the ODE solver to determine if a good solution has been
achieved. This is also used in the solved linear model to check
if prior doses do not add anything to the solution.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_maxsteps">maxsteps</code></td>
<td>
<p>maximum number of (internally defined) steps allowed
during one call to the solver. (5000 by default)</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_hmin">hmin</code></td>
<td>
<p>The minimum absolute step size allowed. The default
value is 0.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_hmax">hmax</code></td>
<td>
<p>The maximum absolute step size allowed.  When
<code>hmax=NA</code> (default), uses the average difference +
hmaxSd*sd in times and sampling events. The <code>hmaxSd</code> is a user
specified parameter and which defaults to zero.  When
<code>hmax=NULL</code> rxode2 uses the maximum difference in times in
your sampling and events.  The value 0 is equivalent to infinite
maximum absolute step size.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_hmaxsd">hmaxSd</code></td>
<td>
<p>The number of standard deviations of the time
difference to add to hmax. The default is 0</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_hini">hini</code></td>
<td>
<p>The step size to be attempted on the first step. The
default value is determined by the solver (when <code>hini = 0</code>)</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_maxordn">maxordn</code></td>
<td>
<p>The maximum order to be allowed for the nonstiff
(Adams) method.  The default is 12.  It can be between 1 and
12.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_maxords">maxords</code></td>
<td>
<p>The maximum order to be allowed for the stiff (BDF)
method.  The default value is 5.  This can be between 1 and 5.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_...">...</code></td>
<td>
<p>Other arguments including scaling factors for each
compartment.  This includes S# = numeric will scale a compartment
# by a dividing the compartment amount by the scale factor,
like NONMEM.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_cores">cores</code></td>
<td>
<p>Number of cores used in parallel ODE solving.  This
is equivalent to calling <code><a href="#topic+setRxThreads">setRxThreads()</a></code></p>
</td></tr>
<tr><td><code id="rxSolve_+3A_covsinterpolation">covsInterpolation</code></td>
<td>
<p>specifies the interpolation method for
time-varying covariates. When solving ODEs it often samples
times outside the sampling time specified in <code>events</code>.
When this happens, the time varying covariates are
interpolated.  Currently this can be:
</p>

<ul>
<li> <p><code>"linear"</code> interpolation, which interpolates the covariate
by solving the line between the observed covariates and extrapolating the new
covariate value.
</p>
</li>
<li> <p><code>"locf"</code> &ndash; Last observation carried forward (the default).
</p>
</li>
<li> <p><code>"nocb"</code> &ndash; Next Observation Carried Backward.  This is the same method
that NONMEM uses.
</p>
</li>
<li> <p><code>"midpoint"</code> Last observation carried forward to midpoint; Next observation
carried backward to midpoint.
</p>
<p>For time-varying covariates where a missing value is present, the
interpolation method will use either &quot;locf&quot; or &quot;nocb&quot; throughout
if they are the type of covariate interpolation that is selected.
</p>
<p>When using the linear or midpoint interpolation, the lower point
in the interpolation will use locf to interpolate missing
covariates and the upper point will use the nocb to interpolate
missing covariates.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rxSolve_+3A_nainterpolation">naInterpolation</code></td>
<td>
<p>specifies the interpolation method for
time-varying covariates when the instantaneous value is <code>NA</code> (not
during an explicit interpolation) and the <code>covsInterpolation</code> is
either <code>"midpoint"</code> or <code>"linear"</code>. This can be:
</p>

<ul>
<li> <p><code>"locf"</code> &ndash; last observation carried forward (default)
</p>
</li>
<li> <p><code>"nocb"</code> &ndash; next observation carried backward.
</p>
</li></ul>

<p>This will look for the prior value (backwards/locf) when
instantaneously missing, or the next value when instantaneously
missing.  If all the covariates are missing and you find the
end/beginning of the individual record, switch direction.  If all
are really missing, then return missing.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_keepinterpolation">keepInterpolation</code></td>
<td>
<p>specifies the interpolation method for
variables in the <code>keep</code> column.  When <code>nlmixr2</code> creates <code>mtime</code>,
<code>addl</code> doses etc, these items were not originally in the dataset.
The interpolation methods you can choose are:
</p>

<ul>
<li> <p><code>"locf"</code> &ndash; last observation carried forward (default)
</p>
</li>
<li> <p><code>"nocb"</code> &ndash; next observation carried backward.
</p>
</li>
<li> <p><code>"na"</code> &ndash; no interpolation, simply put <code>NA</code> for the
interpolated <code>keep</code> covariates.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rxSolve_+3A_addcov">addCov</code></td>
<td>
<p>A boolean indicating if covariates should be added
to the output matrix or data frame. By default this is
disabled.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_sigma">sigma</code></td>
<td>
<p>Named sigma covariance or Cholesky decomposition of a
covariance matrix.  The names of the columns indicate
parameters that are simulated.  These are simulated for every
observation in the solved system. When <code>sigma</code> is <code>NA</code> and you are using it with a
<code>rxode2</code> ui model, the unexplained variability described by
the <code>sigma</code> matrix are set to zero.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_sigmadf">sigmaDf</code></td>
<td>
<p>Degrees of freedom of the sigma t-distribution.  By
default it is equivalent to <code>Inf</code>, or a normal distribution.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_sigmalower">sigmaLower</code></td>
<td>
<p>Lower bounds for simulated unexplained variability (by default -Inf)</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_sigmaupper">sigmaUpper</code></td>
<td>
<p>Upper bounds for simulated unexplained variability (by default Inf)</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_ncoresrv">nCoresRV</code></td>
<td>
<p>Number of cores used for the simulation of the
sigma variables.  By default this is 1. To reproduce the results
you need to run on the same platform with the same number of
cores. This is the reason this is set to be one, regardless of
what the number of cores are used in threaded ODE solving.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_sigmaischol">sigmaIsChol</code></td>
<td>
<p>Boolean indicating if the sigma is in the
Cholesky decomposition instead of a symmetric covariance</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_sigmaseparation">sigmaSeparation</code></td>
<td>
<p>separation strategy for sigma;
</p>
<p>Tells the type of separation strategy when
simulating covariance with parameter uncertainty with standard
deviations modeled in the <code>thetaMat</code> matrix.
</p>

<ul>
<li> <p><code>"lkj"</code> simulates the correlation matrix from the
<code>rLKJ1</code> matrix with the distribution parameter <code>eta</code>
equal to the degrees of freedom <code>nu</code> by <code>(nu-1)/2</code>
</p>
</li>
<li> <p><code>"separation"</code> simulates from the identity inverse Wishart
covariance matrix with <code>nu</code> degrees of freedom.  This is then
converted to a covariance matrix and augmented with the modeled
standard deviations.  While computationally more complex than the
<code>"lkj"</code> prior, it performs better when the covariance matrix
size is greater or equal to 10
</p>
</li>
<li> <p><code>"auto"</code> chooses <code>"lkj"</code> when the dimension of the
matrix is less than 10 and <code>"separation"</code> when greater
than equal to 10.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rxSolve_+3A_sigmaxform">sigmaXform</code></td>
<td>
<p>When taking <code>sigma</code> values from the <code>thetaMat</code>
simulations (using the separation strategy for covariance
simulation), how should the <code>thetaMat</code> values be turned int
standard deviation values:
</p>

<ul>
<li> <p><code>identity</code> This is when standard deviation values are
directly modeled by the <code>params</code> and <code>thetaMat</code> matrix
</p>
</li>
<li> <p><code>variance</code> This is when the <code>params</code> and <code>thetaMat</code>
simulates the variance that are directly modeled by the
<code>thetaMat</code> matrix
</p>
</li>
<li> <p><code>log</code> This is when the <code>params</code> and <code>thetaMat</code>
simulates <code>log(sd)</code>
</p>
</li>
<li> <p><code>nlmixrSqrt</code> This is when the <code>params</code> and
<code>thetaMat</code> simulates the inverse cholesky decomposed matrix
with the <code style="white-space: pre;">&#8288;x\^2&#8288;</code> modeled along the diagonal.  This only works
with a diagonal matrix.
</p>
</li>
<li> <p><code>nlmixrLog</code> This is when the <code>params</code> and
<code>thetaMat</code> simulates the inverse cholesky decomposed matrix
with the <code style="white-space: pre;">&#8288;exp(x\^2)&#8288;</code> along the diagonal.  This only works
with a diagonal matrix.
</p>
</li>
<li> <p><code>nlmixrIdentity</code> This is when the <code>params</code> and
<code>thetaMat</code> simulates the inverse cholesky decomposed matrix.
This only works with a diagonal matrix.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rxSolve_+3A_ndisplayprogress">nDisplayProgress</code></td>
<td>
<p>An integer indicating the minimum number
of c-based solves before a progress bar is shown.  By default
this is 10,000.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_amountunits">amountUnits</code></td>
<td>
<p>This supplies the dose units of a data frame
supplied instead of an event table.  This is for importing the
data as an rxode2 event table.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_timeunits">timeUnits</code></td>
<td>
<p>This supplies the time units of a data frame
supplied instead of an event table.  This is for importing the
data as an rxode2 event table.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_theta">theta</code></td>
<td>
<p>A vector of parameters that will be named <code style="white-space: pre;">&#8288;THETA\[#\]&#8288;</code> and
added to parameters</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_thetalower">thetaLower</code></td>
<td>
<p>Lower bounds for simulated population parameter
variability (by default <code>-Inf</code>)</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_thetaupper">thetaUpper</code></td>
<td>
<p>Upper bounds for simulated population unexplained
variability (by default <code>Inf</code>)</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_eta">eta</code></td>
<td>
<p>A vector of parameters that will be named <code style="white-space: pre;">&#8288;ETA\[#\]&#8288;</code> and
added to parameters</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_adddosing">addDosing</code></td>
<td>
<p>Boolean indicating if the solve should add rxode2
EVID and related columns.  This will also include dosing
information and estimates at the doses.  Be default, rxode2
only includes estimates at the observations. (default
<code>FALSE</code>). When <code>addDosing</code> is <code>NULL</code>, only
include <code>EVID=0</code> on solve and exclude any model-times or
<code>EVID=2</code>. If <code>addDosing</code> is <code>NA</code> the classic
<code>rxode2</code> EVID events are returned. When <code>addDosing</code> is <code>TRUE</code>
add the event information in NONMEM-style format; If
<code>subsetNonmem=FALSE</code> rxode2 will also include extra event types
(<code>EVID</code>) for ending infusion and modeled times:
</p>

<ul>
<li> <p><code>EVID=-1</code> when the modeled rate infusions are turned
off (matches <code>rate=-1</code>)
</p>
</li>
<li> <p><code>EVID=-2</code> When the modeled duration infusions are
turned off (matches <code>rate=-2</code>)
</p>
</li>
<li> <p><code>EVID=-10</code> When the specified <code>rate</code> infusions are
turned off (matches <code>rate&gt;0</code>)
</p>
</li>
<li> <p><code>EVID=-20</code> When the specified <code>dur</code> infusions are
turned off (matches <code>dur&gt;0</code>)
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;EVID=101,102,103,...&#8288;</code> Modeled time where 101 is the
first model time, 102 is the second etc.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rxSolve_+3A_statetrim">stateTrim</code></td>
<td>
<p>When amounts/concentrations in one of the states
are above this value, trim them to be this value. By default
Inf.  Also trims to -stateTrim for large negative
amounts/concentrations.  If you want to trim between a range
say <code>c(0, 2000000)</code> you may specify 2 values with a lower and
upper range to make sure all state values are in the
reasonable range.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_updateobject">updateObject</code></td>
<td>
<p>This is an internally used flag to update the
rxode2 solved object (when supplying an rxode2 solved object) as
well as returning a new object.  You probably should not
modify it's <code>FALSE</code> default unless you are willing to
have unexpected results.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_omega">omega</code></td>
<td>
<p>Estimate of Covariance matrix. When omega is a list,
assume it is a block matrix and convert it to a full matrix for
simulations.  When <code>omega</code> is <code>NA</code> and you are using it with a
<code>rxode2</code> ui model, the between subject variability described by
the <code>omega</code> matrix are set to zero.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_omegadf">omegaDf</code></td>
<td>
<p>The degrees of freedom of a t-distribution for
simulation.  By default this is <code>NULL</code> which is
equivalent to <code>Inf</code> degrees, or to simulate from a normal
distribution instead of a t-distribution.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_omegaischol">omegaIsChol</code></td>
<td>
<p>Indicates if the <code>omega</code> supplied is a
Cholesky decomposed matrix instead of the traditional
symmetric matrix.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_omegaseparation">omegaSeparation</code></td>
<td>
<p>Omega separation strategy
</p>
<p>Tells the type of separation strategy when
simulating covariance with parameter uncertainty with standard
deviations modeled in the <code>thetaMat</code> matrix.
</p>

<ul>
<li> <p><code>"lkj"</code> simulates the correlation matrix from the
<code>rLKJ1</code> matrix with the distribution parameter <code>eta</code>
equal to the degrees of freedom <code>nu</code> by <code>(nu-1)/2</code>
</p>
</li>
<li> <p><code>"separation"</code> simulates from the identity inverse Wishart
covariance matrix with <code>nu</code> degrees of freedom.  This is then
converted to a covariance matrix and augmented with the modeled
standard deviations.  While computationally more complex than the
<code>"lkj"</code> prior, it performs better when the covariance matrix
size is greater or equal to 10
</p>
</li>
<li> <p><code>"auto"</code> chooses <code>"lkj"</code> when the dimension of the
matrix is less than 10 and <code>"separation"</code> when greater
than equal to 10.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rxSolve_+3A_omegaxform">omegaXform</code></td>
<td>
<p>When taking <code>omega</code> values from the <code>thetaMat</code>
simulations (using the separation strategy for covariance
simulation), how should the <code>thetaMat</code> values be turned int
standard deviation values:
</p>

<ul>
<li> <p><code>identity</code> This is when standard deviation values are
directly modeled by the <code>params</code> and <code>thetaMat</code> matrix
</p>
</li>
<li> <p><code>variance</code> This is when the <code>params</code> and <code>thetaMat</code>
simulates the variance that are directly modeled by the
<code>thetaMat</code> matrix
</p>
</li>
<li> <p><code>log</code> This is when the <code>params</code> and <code>thetaMat</code>
simulates <code>log(sd)</code>
</p>
</li>
<li> <p><code>nlmixrSqrt</code> This is when the <code>params</code> and
<code>thetaMat</code> simulates the inverse cholesky decomposed matrix
with the <code style="white-space: pre;">&#8288;x\^2&#8288;</code> modeled along the diagonal.  This only works
with a diagonal matrix.
</p>
</li>
<li> <p><code>nlmixrLog</code> This is when the <code>params</code> and
<code>thetaMat</code> simulates the inverse cholesky decomposed matrix
with the <code style="white-space: pre;">&#8288;exp(x\^2)&#8288;</code> along the diagonal.  This only works
with a diagonal matrix.
</p>
</li>
<li> <p><code>nlmixrIdentity</code> This is when the <code>params</code> and
<code>thetaMat</code> simulates the inverse cholesky decomposed matrix.
This only works with a diagonal matrix.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rxSolve_+3A_omegalower">omegaLower</code></td>
<td>
<p>Lower bounds for simulated ETAs (by default -Inf)</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_omegaupper">omegaUpper</code></td>
<td>
<p>Upper bounds for simulated ETAs (by default Inf)</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_nsub">nSub</code></td>
<td>
<p>Number between subject variabilities (<code>ETAs</code>) simulated for every
realization of the parameters.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_thetamat">thetaMat</code></td>
<td>
<p>Named theta matrix.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_thetadf">thetaDf</code></td>
<td>
<p>The degrees of freedom of a t-distribution for
simulation.  By default this is <code>NULL</code> which is
equivalent to <code>Inf</code> degrees, or to simulate from a normal
distribution instead of a <code>t</code>-distribution.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_thetaischol">thetaIsChol</code></td>
<td>
<p>Indicates if the <code>theta</code> supplied is a
Cholesky decomposed matrix instead of the traditional
symmetric matrix.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_nstud">nStud</code></td>
<td>
<p>Number virtual studies to characterize uncertainty in estimated
parameters.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_dfsub">dfSub</code></td>
<td>
<p>Degrees of freedom to sample the between subject variability matrix from the
inverse Wishart distribution (scaled) or scaled inverse chi squared distribution.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_dfobs">dfObs</code></td>
<td>
<p>Degrees of freedom to sample the unexplained variability matrix from the
inverse Wishart distribution (scaled) or scaled inverse chi squared distribution.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_returntype">returnType</code></td>
<td>
<p>This tells what type of object is returned.  The
currently supported types are:
</p>

<ul>
<li> <p><code>"rxSolve"</code> (default) will return a reactive data frame
that can change easily change different pieces of the solve and
update the data frame.  This is the currently standard solving
method in rxode2,  is used for <code>rxSolve(object, ...)</code>, <code>solve(object,...)</code>,
</p>
</li>
<li> <p><code>"data.frame"</code> &ndash; returns a plain, non-reactive data
frame; Currently very slightly faster than <code>returnType="matrix"</code>
</p>
</li>
<li> <p><code>"matrix"</code> &ndash; returns a plain matrix with column names attached
to the solved object.  This is what is used <code>object$run</code> as well as <code>object$solve</code>
</p>
</li>
<li> <p><code>"data.table"</code> &ndash; returns a <code>data.table</code>; The <code>data.table</code> is
created by reference (ie <code>setDt()</code>), which should be fast.
</p>
</li>
<li> <p><code>"tbl"</code> or <code>"tibble"</code> returns a tibble format.
</p>
</li></ul>
</td></tr>
<tr><td><code id="rxSolve_+3A_seed">seed</code></td>
<td>
<p>an object specifying if and how the random number
generator should be initialized</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_nsim">nsim</code></td>
<td>
<p>represents the number of simulations.  For rxode2, if
you supply single subject event tables (created with
<code style="white-space: pre;">&#8288;[eventTable()]&#8288;</code>)</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_minss">minSS</code></td>
<td>
<p>Minimum number of iterations for a steady-state dose</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_maxss">maxSS</code></td>
<td>
<p>Maximum number of iterations for a steady-state dose</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_infssstep">infSSstep</code></td>
<td>
<p>Step size for determining if a constant infusion
has reached steady state.  By default this is large value,
12.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_strictss">strictSS</code></td>
<td>
<p>Boolean indicating if a strict steady-state is
required. If a strict steady-state is (<code>TRUE</code>) required
then at least <code>minSS</code> doses are administered and the
total number of steady states doses will continue until
<code>maxSS</code> is reached, or <code>atol</code> and <code>rtol</code> for
every compartment have been reached.  However, if ODE solving
problems occur after the <code>minSS</code> has been reached the
whole subject is considered an invalid solve. If
<code>strictSS</code> is <code>FALSE</code> then as long as <code>minSS</code>
has been reached the last good solve before ODE solving
problems occur is considered the steady state, even though
either <code>atol</code>, <code>rtol</code> or <code>maxSS</code> have not
been achieved.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_istatereset">istateReset</code></td>
<td>
<p>When <code>TRUE</code>, reset the <code>ISTATE</code> variable to 1 for
lsoda and liblsoda with doses, like <code>deSolve</code>; When <code>FALSE</code>, do
not reset the <code>ISTATE</code> variable with doses.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_subsetnonmem">subsetNonmem</code></td>
<td>
<p>subset to NONMEM compatible EVIDs only.  By
default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_maxatolrtolfactor">maxAtolRtolFactor</code></td>
<td>
<p>The maximum <code>atol</code>/<code>rtol</code> that
FOCEi and other routines may adjust to.  By default 0.1</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_from">from</code></td>
<td>
<p>When there is no observations in the event table,
start observations at this value. By default this is zero.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_to">to</code></td>
<td>
<p>When there is no observations in the event table, end
observations at this value. By default this is 24 + maximum
dose time.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_by">by</code></td>
<td>
<p>When there are no observations in the event table, this
is the amount to increment for the observations between <code>from</code>
and <code>to</code>.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_length.out">length.out</code></td>
<td>
<p>The number of observations to create if there
isn't any observations in the event table. By default this is 200.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_icov">iCov</code></td>
<td>
<p>A data frame of individual non-time varying covariates
to combine with the <code>events</code> dataset.  The <code>iCov</code> dataset has one
covariate per ID and should match the event table</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_keep">keep</code></td>
<td>
<p>Columns to keep from either the input dataset or the
<code>iCov</code> dataset.  With the <code>iCov</code> dataset, the column
is kept once per line.  For the input dataset, if any records
are added to the data LOCF (Last Observation Carried forward)
imputation is performed.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_indlinphitol">indLinPhiTol</code></td>
<td>
<p>the requested accuracy tolerance on
exponential matrix.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_indlinphim">indLinPhiM</code></td>
<td>
<p>the maximum size for the Krylov basis</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_indlinmatexptype">indLinMatExpType</code></td>
<td>
<p>This is them matrix exponential type that
is use for rxode2.  Currently the following are supported:
</p>

<ul>
<li> <p><code>Al-Mohy</code> Uses the exponential matrix method of Al-Mohy Higham (2009)
</p>
</li>
<li> <p><code>arma</code> Use the exponential matrix from RcppArmadillo
</p>
</li>
<li> <p><code>expokit</code> Use the exponential matrix from Roger B. Sidje (1998)
</p>
</li></ul>
</td></tr>
<tr><td><code id="rxSolve_+3A_indlinmatexporder">indLinMatExpOrder</code></td>
<td>
<p>an integer, the order of approximation to
be used, for the <code>Al-Mohy</code> and <code>expokit</code> values.
The best value for this depends on machine precision (and
slightly on the matrix). We use <code>6</code> as a default.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_drop">drop</code></td>
<td>
<p>Columns to drop from the output</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_idfactor">idFactor</code></td>
<td>
<p>This boolean indicates if original ID values
should be maintained. This changes the default sequentially
ordered ID to a factor with the original ID values in the
original dataset.  By default this is enabled.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_mxhnil">mxhnil</code></td>
<td>
<p>maximum number of messages printed (per problem)
warning that <code>T + H = T</code> on a step (<code>H</code> = step size).  This must
be positive to result in a non-default value.  The default
value is 0 (or infinite).</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_hmxi">hmxi</code></td>
<td>
<p>inverse of the maximum absolute value of <code>H</code> to are used.
hmxi = 0.0 is allowed and corresponds to an infinite <code style="white-space: pre;">&#8288;hmax1 (default).  &#8288;</code>hmin<code>and</code>hmxi<code style="white-space: pre;">&#8288;may be changed at any time, but will not take effect until the next change of&#8288;</code>H<code style="white-space: pre;">&#8288;is considered. This option is only considered with&#8288;</code>method=&quot;liblsoda&quot;'.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_warnidsort">warnIdSort</code></td>
<td>
<p>Warn if the ID is not present and rxode2 assumes
the order of the parameters/iCov are the same as the order of
the parameters in the input dataset.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_warndrop">warnDrop</code></td>
<td>
<p>Warn if column(s) were supposed to be dropped, but
were not present.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_ssatol">ssAtol</code></td>
<td>
<p>Steady state atol convergence factor.  Can be
a vector based on each state.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_ssrtol">ssRtol</code></td>
<td>
<p>Steady state rtol convergence factor.  Can be a
vector based on each state.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_safezero">safeZero</code></td>
<td>
<p>Use safe zero divide. By default
this is turned on but you may turn it off if you wish.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_safelog">safeLog</code></td>
<td>
<p>Use safe log.  When enabled if your value that you are taking log() of is negative or zero, this will return <code style="white-space: pre;">&#8288;log(machine epsilon)&#8288;</code>.  By default this is turned on.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_safepow">safePow</code></td>
<td>
<p>Use safe powers.  When enabled if your power is
negative and your base is zero, this will return the <code style="white-space: pre;">&#8288;machine epsilon^(negative power)&#8288;</code>.  By default this is turned on.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_sumtype">sumType</code></td>
<td>
<p>Sum type to use for <code>sum()</code> in
rxode2 code blocks.
</p>
<p><code>pairwise</code> uses the pairwise sum (fast, default)
</p>
<p><code>fsum</code> uses the PreciseSum package's fsum function (most accurate)
</p>
<p><code>kahan</code> uses Kahan correction
</p>
<p><code>neumaier</code> uses Neumaier correction
</p>
<p><code>c</code> uses no correction: default/native summing</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_prodtype">prodType</code></td>
<td>
<p>Product to use for <code>prod()</code> in rxode2 blocks
</p>
<p><code style="white-space: pre;">&#8288;long double&#8288;</code> converts to long double, performs the
multiplication and then converts back.
</p>
<p><code>double</code> uses the standard double scale for multiplication.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_senstype">sensType</code></td>
<td>
<p>Sensitivity type for <code>linCmt()</code> model:
</p>
<p><code>advan</code> Use the direct advan solutions
</p>
<p><code>autodiff</code> Use the autodiff advan solutions
</p>
<p><code>forward</code> Use forward difference solutions
</p>
<p><code>central</code> Use central differences</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_lindiff">linDiff</code></td>
<td>
<p>This gives the linear difference amount for all the
types of linear compartment model parameters where sensitivities
are not calculated. The named components of this numeric vector are:
</p>

<ul>
<li> <p><code>"lag"</code> Central compartment lag
</p>
</li>
<li> <p><code>"f"</code> Central compartment bioavailability
</p>
</li>
<li> <p><code>"rate"</code> Central compartment modeled rate
</p>
</li>
<li> <p><code>"dur"</code> Central compartment modeled duration
</p>
</li>
<li> <p><code>"lag2"</code> Depot compartment lag
</p>
</li>
<li> <p><code>"f2"</code> Depot compartment bioavailability
</p>
</li>
<li> <p><code>"rate2"</code> Depot compartment modeled rate
</p>
</li>
<li> <p><code>"dur2"</code> Depot compartment modeled duration
</p>
</li></ul>
</td></tr>
<tr><td><code id="rxSolve_+3A_lindiffcentral">linDiffCentral</code></td>
<td>
<p>This gives the which parameters use central
differences for the linear compartment model parameters.  The
are the same components as <code>linDiff</code></p>
</td></tr>
<tr><td><code id="rxSolve_+3A_resample">resample</code></td>
<td>
<p>A character vector of model variables to resample
from the input dataset; This sampling is done with replacement.
When <code>NULL</code> or <code>FALSE</code> no resampling is done.  When
<code>TRUE</code> resampling is done on all covariates in the input
dataset</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_resampleid">resampleID</code></td>
<td>
<p>boolean representing if the resampling should be
done on an individual basis <code>TRUE</code> (ie. a whole patient is
selected) or each covariate is resampled independent of the
subject identifier <code>FALSE</code>.  When <code>resampleID=TRUE</code>
correlations of parameters are retained, where as when
<code>resampleID=FALSE</code> ignores patient covariate correaltions.
Hence the default is <code>resampleID=TRUE</code>.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_maxwhile">maxwhile</code></td>
<td>
<p>represents the maximum times a while loop is
evaluated before exiting.  By default this is 100000</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_atolsens">atolSens</code></td>
<td>
<p>Sensitivity atol, can be different than atol with
liblsoda.  This allows a less accurate solve for gradients (if desired)</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_rtolsens">rtolSens</code></td>
<td>
<p>Sensitivity rtol, can be different than rtol with
liblsoda.  This allows a less accurate solve for gradients (if desired)</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_ssatolsens">ssAtolSens</code></td>
<td>
<p>Sensitivity absolute tolerance (atol) for
calculating if steady state has been achieved for sensitivity compartments.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_ssrtolsens">ssRtolSens</code></td>
<td>
<p>Sensitivity relative tolerance (rtol) for
calculating if steady state has been achieved for sensitivity compartments.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_simvariability">simVariability</code></td>
<td>
<p>determines if the variability is simulated.
When <code>NA</code> (default) this is determined by the solver.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_nllikalloc">nLlikAlloc</code></td>
<td>
<p>The number of log likelihood endpoints that are
used in the model.  This allows independent log likelihood per
endpoint in focei for nlmixr2.  It likely shouldn't be set,
though it won't hurt anything if you do (just may take up more
memory for larger allocations).</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_usestdpow">useStdPow</code></td>
<td>
<p>This uses C's <code>pow</code> for exponentiation instead of
R's <code>R_pow</code> or <code>R_pow_di</code>.  By default this is <code>FALSE</code></p>
</td></tr>
<tr><td><code id="rxSolve_+3A_natimehandle">naTimeHandle</code></td>
<td>
<p>Determines what time of handling happens when
the time becomes <code>NA</code>: current options are:
</p>

<ul>
<li> <p><code>ignore</code> this ignores the <code>NA</code> time input and passes it through.
</p>
</li>
<li> <p><code>warn</code> (default) this will produce a warning at the end of the
solve, but continues solving passing through the <code>NA</code> time
</p>
</li>
<li> <p><code>error</code> this will stop this solve if this is not a parallel
solved ODE (otherwise stopping can crash R)
</p>
</li></ul>
</td></tr>
<tr><td><code id="rxSolve_+3A_addlkeepscov">addlKeepsCov</code></td>
<td>
<p>This determines if the additional dosing items
repeats the dose only (<code>FALSE</code>) or keeps the covariates at the
record of the dose (<code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_addldropss">addlDropSs</code></td>
<td>
<p>When there are steady state doses with an <code>addl</code>
specification the steady state flag is dropped with repeated
doses (when <code>TRUE</code>) or retained (when <code>FALSE</code>)</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_ssatdosetime">ssAtDoseTime</code></td>
<td>
<p>Boolean that when <code>TRUE</code> back calculates the
steady concentration at the actual time of dose, otherwise when
<code>FALSE</code> the doses are shifted</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_ss2cancelallpending">ss2cancelAllPending</code></td>
<td>
<p>When <code>TRUE</code> the <code>SS=2</code> event type
cancels all pending doses like <code>SS=1</code>.  When <code>FALSE</code> the pending
doses not canceled with <code>SS=2</code> (the infusions started before
<code>SS=2</code> occurred are canceled, though).</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_envir">envir</code></td>
<td>
<p>is the environment to look for R user functions
(defaults to parent environment)</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_a">a</code></td>
<td>
<p>when using <code>solve()</code>, this is equivalent to the
<code>object</code> argument.  If you specify <code>object</code> later in
the argument list it overwrites this parameter.</p>
</td></tr>
<tr><td><code id="rxSolve_+3A_b">b</code></td>
<td>
<p>when using <code>solve()</code>, this is equivalent to the
<code>params</code> argument.  If you specify <code>params</code> as a
named argument, this overwrites the output</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rest of the document focus on the different ODE solving
methods, followed by the core solving method's options, rxode2 event
handling options, rxode2's numerical stability options, rxode2's
output options, and finally internal rxode2 options or compatibility
options.
</p>


<h3>Value</h3>

<p>An &ldquo;rxSolve&rdquo; solve object that stores the solved
value in a special data.frame or other type as determined by
<code>returnType</code>. By default this has as many rows as there are
sampled time points and as many columns as system variables (as
defined by the ODEs and additional assignments in the rxode2 model
code).  It also stores information about the call to allow
dynamic updating of the solved object.
</p>
<p>The operations for the object are similar to a data-frame, but
expand the <code>$</code> and <code style="white-space: pre;">&#8288;[[""]]&#8288;</code> access operators and assignment
operators to resolve based on different parameter values, initial
conditions, solver parameters, or events (by updating the <code>time</code>
variable).
</p>
<p>You can call the <code><a href="#topic+eventTable">eventTable()</a></code> methods on the solved object to
update the event table and resolve the system of equations.
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler, Melissa Hallow and  Wenping Wang
</p>


<h3>References</h3>

<p>&quot;New Scaling and Squaring Algorithm for the Matrix Exponential&quot;, by
Awad H. Al-Mohy and Nicholas J. Higham, August 2009
</p>
<p>Roger B. Sidje (1998).  EXPOKIT: Software package for computing
matrix exponentials.  ACM - Transactions on Mathematical Software
<em>24</em>(1), 130-156.
</p>
<p>Hindmarsh, A. C.
<em>ODEPACK, A Systematized Collection of ODE Solvers</em>.
Scientific Computing, R. S. Stepleman et al. (Eds.),
North-Holland, Amsterdam, 1983, pp. 55-64.
</p>
<p>Petzold, L. R.
<em>Automatic Selection of Methods for Solving Stiff and Nonstiff
Systems of Ordinary Differential Equations</em>.
Siam J. Sci. Stat. Comput. 4 (1983), pp. 136-148.
</p>
<p>Hairer, E., Norsett, S. P., and Wanner, G.
<em>Solving ordinary differential equations I, nonstiff problems</em>.
2nd edition, Springer Series in Computational Mathematics,
Springer-Verlag (1993).
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rxode2">rxode2()</a></code>
</p>

<hr>
<h2 id='rxSolveFree'>Free the C solving/parsing information.</h2><span id='topic+rxSolveFree'></span>

<h3>Description</h3>

<p>Take the ODE C system and free it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSolveFree()
</code></pre>


<h3>Value</h3>

<p>logical indicating if the memory was successfully freed
</p>

<hr>
<h2 id='rxSolveSetup'>See if the memory is installed for a solve</h2><span id='topic+rxSolveSetup'></span>

<h3>Description</h3>

<p>See if the memory is installed for a solve
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSolveSetup()
</code></pre>


<h3>Value</h3>

<p>boolean saying if the memnory is currently free for rxode2
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxSplitPlusQ'>This function splits a function based on + or - terms</h2><span id='topic+rxSplitPlusQ'></span>

<h3>Description</h3>

<p>It uses the parser and does not disturb terms within other
functions.  For example:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSplitPlusQ(x, level = 0, mult = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxSplitPlusQ_+3A_x">x</code></td>
<td>
<p>Quoted R expression for splitting</p>
</td></tr>
<tr><td><code id="rxSplitPlusQ_+3A_level">level</code></td>
<td>
<p>Internal level of parsing</p>
</td></tr>
<tr><td><code id="rxSplitPlusQ_+3A_mult">mult</code></td>
<td>
<p>boolean to split based on * and / expressions instead.
By default this is turned off.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>a<em>exp(b+c)+d</em>log(e-f)-g*f
</p>
<p>would return
</p>
<p>c(&quot;a * exp(b + c)&quot;, &quot;d * log(e - f)&quot;, &quot;- g * f&quot;)
</p>


<h3>Value</h3>

<p>character vector of the split expressions
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxStack'>Stack a solved object for things like default ggplot2 plot</h2><span id='topic+rxStack'></span>

<h3>Description</h3>

<p>Stack a solved object for things like default ggplot2 plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxStack(data, vars = NULL, doSim = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxStack_+3A_data">data</code></td>
<td>
<p>is a rxode2 object to be stacked.</p>
</td></tr>
<tr><td><code id="rxStack_+3A_vars">vars</code></td>
<td>
<p>Variables to include in stacked data; By default this
is all the variables when vars is NULL.
</p>
<p>When vars is <code>sim</code> and comes from a <code>rxode2</code> ui simulation with
multiple endpoints (ie it has a <code>CMT</code> in the simulation), it will
rework the data as if it was stacked based the value based on the
compartments in the multiple endpoint model.
</p>
<p>When the vars is <code>sim.endpoint1</code> it will subset the stack to
endpoint1, you can also have 'c(&quot;sim.endpoint1&quot;, &quot;sim.endpoint2&quot;)
and the &quot;stack&quot; will subset to endpoint1 and endpoint2.
</p>
<p>When you specify the <code>sim</code> type variables they have to be all
prefixed with <code>sim</code> otherwise, the stack will not treat them
differently.</p>
</td></tr>
<tr><td><code id="rxStack_+3A_dosim">doSim</code></td>
<td>
<p>boolean that determines if the &quot;sim&quot; variable in a
<code>rxSolve</code> dataset is actually &quot;stacking&quot; based on the endpoint
(<code>TRUE</code>) or simply treating <code>sim</code> as a variable.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Stacked data with <code>value</code> and <code>trt</code>, where value is the values
and <code>trt</code> is the state and <code>lhs</code> variables.
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='rxState'>State variables</h2><span id='topic+rxState'></span>

<h3>Description</h3>

<p>This returns the model's compartments or states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxState(obj = NULL, state = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxState_+3A_obj">obj</code></td>
<td>
<p>rxode2 family of objects</p>
</td></tr>
<tr><td><code id="rxState_+3A_state">state</code></td>
<td>
<p>is a string indicating the state or compartment that
you would like to lookup.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If state is missing, return a character vector of all the states.
</p>
<p>If state is a string, return the compartment number of the named state.
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rxode2">rxode2()</a></code>
</p>
<p>Other Query model information: 
<code><a href="#topic+rxDfdy">rxDfdy</a>()</code>,
<code><a href="#topic+rxInits">rxInits</a>()</code>,
<code><a href="#topic+rxLhs">rxLhs</a>()</code>,
<code><a href="#topic+rxModelVars">rxModelVars</a>()</code>,
<code><a href="#topic+rxParams">rxParams</a>()</code>
</p>

<hr>
<h2 id='rxSumProdModel'>Recast model in terms of sum/prod</h2><span id='topic+rxSumProdModel'></span>

<h3>Description</h3>

<p>Recast model in terms of sum/prod
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSumProdModel(model, expand = FALSE, sum = TRUE, prod = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxSumProdModel_+3A_model">model</code></td>
<td>
<p>rxode2 model</p>
</td></tr>
<tr><td><code id="rxSumProdModel_+3A_expand">expand</code></td>
<td>
<p>Boolean indicating if the expression is expanded.</p>
</td></tr>
<tr><td><code id="rxSumProdModel_+3A_sum">sum</code></td>
<td>
<p>Use sum(...)</p>
</td></tr>
<tr><td><code id="rxSumProdModel_+3A_prod">prod</code></td>
<td>
<p>Use prod(...)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>model string with prod(.) and sum(.) for all these
operations.
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxSupportedFuns'>Get list of supported functions</h2><span id='topic+rxSupportedFuns'></span>

<h3>Description</h3>

<p>Get list of supported functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSupportedFuns()
</code></pre>


<h3>Value</h3>

<p>list of supported functions in rxode2
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rxSupportedFuns()
</code></pre>

<hr>
<h2 id='rxSuppressMsg'>Respect suppress messages</h2><span id='topic+rxSuppressMsg'></span>

<h3>Description</h3>

<p>This turns on the silent REprintf in C when <code>suppressMessages()</code> is
turned on. This makes the <code>REprintf</code> act like <code>messages</code> in R,
they can be suppressed with <code>suppressMessages()</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSuppressMsg()
</code></pre>


<h3>Value</h3>

<p>Nothing
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# rxSupressMsg() is called with rxode2()

# Note the errors are output to the console

try(rxode2("d/dt(matt)=/3"), silent = TRUE)

# When using suppressMessages, the output is suppressed

suppressMessages(try(rxode2("d/dt(matt)=/3"), silent = TRUE))

# In rxode2, we use REprintf so that interrupted threads do not crash R
# if there is a user interrupt. This isn't captured by R's messages, but
# This interface allows the `suppressMessages()` to suppress the C printing
# as well

# If you  want to suppress messages from rxode2 in other packages, you can use
# this function
</code></pre>

<hr>
<h2 id='rxSymInvChol'>Get Omega^-1 and derivatives</h2><span id='topic+rxSymInvChol'></span>

<h3>Description</h3>

<p>Get Omega^-1 and derivatives
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSymInvChol(
  invObjOrMatrix,
  theta = NULL,
  type = "cholOmegaInv",
  thetaNumber = 0L
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxSymInvChol_+3A_invobjormatrix">invObjOrMatrix</code></td>
<td>
<p>Object for inverse-type calculations.  If
this is a matrix, setup the object for inversion
<code><a href="#topic+rxSymInvCholCreate">rxSymInvCholCreate()</a></code> with the default arguments and return a
reactive s3 object.  Otherwise, use the inversion object to
calculate the requested derivative/inverse.</p>
</td></tr>
<tr><td><code id="rxSymInvChol_+3A_theta">theta</code></td>
<td>
<p>Thetas to be used for calculation.  If missing (<code>NULL</code>), a
special s3 class is created and returned to access <code>Omega^1</code>
objects as needed and cache them based on the theta that is
used.</p>
</td></tr>
<tr><td><code id="rxSymInvChol_+3A_type">type</code></td>
<td>
<p>The type of object.  Currently the following types are
supported:
</p>

<ul>
<li> <p><code>cholOmegaInv</code> gives the
Cholesky decomposition of the Omega Inverse matrix.
</p>
</li>
<li> <p><code>omegaInv</code> gives the Omega Inverse matrix.
</p>
</li>
<li> <p><code>d(omegaInv)</code> gives the <code>d(Omega^-1)</code> withe respect to the
theta parameter specified in <code>thetaNumber</code>.
</p>
</li>
<li> <p><code>d(D)</code> gives the <code>d(diagonal(Omega^-1))</code> with respect to
the theta parameter specified in the <code>thetaNumber</code>
parameter
</p>
</li></ul>
</td></tr>
<tr><td><code id="rxSymInvChol_+3A_thetanumber">thetaNumber</code></td>
<td>
<p>For types <code>d(omegaInv)</code> and <code>d(D)</code>,
the theta number that the derivative is taken against.  This
must be positive from 1 to the number of thetas defining the
Omega matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix based on parameters or environment with all the
matrixes calculated in variables <code>omega</code>, <code>omegaInv</code>, <code>dOmega</code>,
<code>dOmegaInv</code>.
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxSymInvCholCreate'>Creates an object for calculating Omega/Omega^-1 and derivatives</h2><span id='topic+rxSymInvCholCreate'></span>

<h3>Description</h3>

<p>Creates an object for calculating Omega/Omega^-1 and derivatives
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSymInvCholCreate(
  mat,
  diag.xform = c("sqrt", "log", "identity"),
  create.env = TRUE,
  envir = parent.frame()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxSymInvCholCreate_+3A_mat">mat</code></td>
<td>
<p>Initial Omega matrix</p>
</td></tr>
<tr><td><code id="rxSymInvCholCreate_+3A_diag.xform">diag.xform</code></td>
<td>
<p>transformation to diagonal elements of OMEGA. or <code>chol(Omega^-1)</code></p>
</td></tr>
<tr><td><code id="rxSymInvCholCreate_+3A_create.env">create.env</code></td>
<td>
<p>&ndash; Create an environment to calculate the inverses. (By default TRUE)</p>
</td></tr>
<tr><td><code id="rxSymInvCholCreate_+3A_envir">envir</code></td>
<td>
<p>&ndash; Environment to evaluate function, bu default it is the parent frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A rxSymInv object OR a rxSymInv environment
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxSymInvCholN'>Return the dimension of the built-in derivatives/inverses</h2><span id='topic+rxSymInvCholN'></span>

<h3>Description</h3>

<p>Return the dimension of the built-in derivatives/inverses
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSymInvCholN()
</code></pre>


<h3>Value</h3>

<p>dimension of built-in derivatives/inverses
</p>

<hr>
<h2 id='rxSyncOptions'>Sync options with rxode2 variables</h2><span id='topic+rxSyncOptions'></span>

<h3>Description</h3>

<p>Accessing rxode2 options via getOption slows down solving.  This
allows the options to be synced with variables.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSyncOptions(setDefaults = c("none", "permissive", "strict"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxSyncOptions_+3A_setdefaults">setDefaults</code></td>
<td>
<p>This will setup rxode2's default solving options with the following options:
</p>

<ul>
<li> <p><code>"none"</code> leave the options alone
</p>
</li>
<li> <p><code>"permissive"</code> This is a permissive option set similar to R language specifications.
</p>
</li>
<li> <p><code>"strict"</code> This is a strict option set similar to the original
rxode2(). It requires semicolons at the end of lines and equals for
assignment
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing; called for side effects
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxSyntaxFunctions'>A list and description of Rode supported syntax functions</h2><span id='topic+rxSyntaxFunctions'></span>

<h3>Description</h3>

<p>A list and description of Rode supported syntax functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxSyntaxFunctions
</code></pre>


<h3>Format</h3>

<p>A data frame with 3 columns and 102 rows
</p>

<dl>
<dt>Function</dt><dd><p>Reserved function Name</p>
</dd>
<dt>Description</dt><dd><p>Description of function</p>
</dd>
<dt>Aliases</dt><dd><p>Function Aliases</p>
</dd>
</dl>


<hr>
<h2 id='rxt'>Simulate student t variable from threefry generator</h2><span id='topic+rxt'></span>

<h3>Description</h3>

<p>Care should be taken with this method not to encounter the
birthday problem, described
<a href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/">https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/</a>.
Since the <code>sitmo</code> <code>threefry</code>, this currently generates
one random deviate from the uniform distribution to seed the
engine <code>threefry</code> and then run the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxt(df, n = 1L, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxt_+3A_df">df</code></td>
<td>
<p>degrees of freedom (<code class="reqn">&gt; 0</code>, maybe non-integer).  <code>df
      = Inf</code> is allowed.</p>
</td></tr>
<tr><td><code id="rxt_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="rxt_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the simulation
</p>
<p><code>rxnorm</code> simulates using the threefry sitmo generator.
</p>
<p><code>rxnormV</code> used to simulate with the vandercorput simulator, but
since it didn't satisfy the normal properties it was changed to simple be
an alias of <code>rxnorm</code>. It is no longer supported in <code>rxode2({})</code> blocks</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Therefore, a simple call to the random number generated followed by a second
call to random number generated may have identical seeds.  As the number of
random number generator calls are increased the probability that the
birthday problem will increase.
</p>
<p>The key to avoid this problem is to either run all simulations in the
<code>rxode2</code> environment once (therefore one seed or series of seeds
for the whole simulation), pre-generate all random variables
used for the simulation, or seed the rxode2 engine with <code>rxSetSeed()</code>
</p>
<p>Internally each ID is seeded with a unique number so that the
results do not depend on the number of cores used.
</p>


<h3>Value</h3>

<p>t-distribution random numbers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Use threefry engine
rxt(df = 3, n = 10) # with rxt you have to explicitly state n
rxt(df = 3, n = 10, ncores = 2) # You can parallelize the simulation using openMP

rxt(4) ## The first argument is the df parameter


## This example uses `rxt` directly in the model

rx &lt;- function() {
   model({
    a &lt;- rxt(3)
   })
}

et &lt;- et(1, id = 1:2)

s &lt;- rxSolve(rx, et)


</code></pre>

<hr>
<h2 id='rxTempDir'>Get the rxode2 temporary directory</h2><span id='topic+rxTempDir'></span>

<h3>Description</h3>

<p>Get the rxode2 temporary directory
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxTempDir()
</code></pre>


<h3>Value</h3>

<p>rxode2 temporary directory.
</p>

<hr>
<h2 id='rxTheme'>rxTheme is the ggplot2 theme for rxode2 plots</h2><span id='topic+rxTheme'></span>

<h3>Description</h3>

<p>rxTheme is the ggplot2 theme for rxode2 plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxTheme(
  base_size = 11,
  base_family = "",
  base_line_size = base_size/22,
  base_rect_size = base_size/22,
  grid = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxTheme_+3A_base_size">base_size</code></td>
<td>
<p>base font size, given in pts.</p>
</td></tr>
<tr><td><code id="rxTheme_+3A_base_family">base_family</code></td>
<td>
<p>base font family</p>
</td></tr>
<tr><td><code id="rxTheme_+3A_base_line_size">base_line_size</code></td>
<td>
<p>base size for line elements</p>
</td></tr>
<tr><td><code id="rxTheme_+3A_base_rect_size">base_rect_size</code></td>
<td>
<p>base size for rect elements</p>
</td></tr>
<tr><td><code id="rxTheme_+3A_grid">grid</code></td>
<td>
<p>a Boolean indicating if the grid is on (<code>TRUE</code>) or off
(<code>FALSE</code>). This could also be a character indicating <code>x</code> or <code>y</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot2 theme used in rxode2
</p>


<h3>See Also</h3>

<p>Other rxode2 plotting: 
<code><a href="#topic+plot.rxSolve">plot.rxSolve</a>()</code>
</p>

<hr>
<h2 id='rxToSE'>rxode2 to symengine environment</h2><span id='topic+rxToSE'></span><span id='topic+.rxToSE'></span><span id='topic+rxFromSE'></span><span id='topic+.rxFromSE'></span>

<h3>Description</h3>

<p>rxode2 to symengine environment
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxToSE(
  x,
  envir = NULL,
  progress = FALSE,
  promoteLinSens = TRUE,
  parent = parent.frame()
)

.rxToSE(x, envir = NULL, progress = FALSE)

rxFromSE(
  x,
  unknownDerivatives = c("forward", "central", "error"),
  parent = parent.frame()
)

.rxFromSE(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxToSE_+3A_x">x</code></td>
<td>
<p>expression</p>
</td></tr>
<tr><td><code id="rxToSE_+3A_envir">envir</code></td>
<td>
<p>default is <code>NULL</code>; Environment to put symengine
variables in.</p>
</td></tr>
<tr><td><code id="rxToSE_+3A_progress">progress</code></td>
<td>
<p>shows progress bar if true.</p>
</td></tr>
<tr><td><code id="rxToSE_+3A_promotelinsens">promoteLinSens</code></td>
<td>
<p>Promote solved linear compartment systems to
sensitivity-based solutions.</p>
</td></tr>
<tr><td><code id="rxToSE_+3A_parent">parent</code></td>
<td>
<p>is the parent environment to look for R-based user functions</p>
</td></tr>
<tr><td><code id="rxToSE_+3A_unknownderivatives">unknownDerivatives</code></td>
<td>
<p>When handling derivatives from unknown
functions, the translator will translate into different types
of numeric derivatives.  The currently supported methods are:
</p>
<div class="sourceCode"><pre>- `forward` for forward differences
- `central` for central differences
- `error` for throwing an error for unknown derivatives
</pre></div></td></tr>
</table>


<h3>Value</h3>

<p>An rxode2 symengine environment
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxTrans'>Translate the model to C code if needed</h2><span id='topic+rxTrans'></span><span id='topic+rxTrans.default'></span><span id='topic+rxTrans.character'></span>

<h3>Description</h3>

<p>This function translates the model to C code, if needed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxTrans(
  model,
  modelPrefix = "",
  md5 = "",
  modName = NULL,
  modVars = FALSE,
  ...
)

## Default S3 method:
rxTrans(
  model,
  modelPrefix = "",
  md5 = "",
  modName = NULL,
  modVars = FALSE,
  ...
)

## S3 method for class 'character'
rxTrans(
  model,
  modelPrefix = "",
  md5 = "",
  modName = NULL,
  modVars = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxTrans_+3A_model">model</code></td>
<td>
<p>This is the ODE model specification.  It can be:
</p>

<ul>
<li><p> a string containing the set of ordinary differential
equations (ODE) and other expressions defining the changes in
the dynamic system.
</p>
</li>
<li><p> a file name where the ODE system equation is contained
</p>
</li></ul>

<p>An ODE expression enclosed in <code style="white-space: pre;">&#8288;\{\}&#8288;</code>
</p>
<p>(see also the <code>filename</code> argument). For
details, see the sections &ldquo;Details&rdquo; and
<code style="white-space: pre;">&#8288;rxode2 Syntax&#8288;</code> below.</p>
</td></tr>
<tr><td><code id="rxTrans_+3A_modelprefix">modelPrefix</code></td>
<td>
<p>Prefix of the model functions that will be
compiled to make sure that multiple rxode2 objects can coexist
in the same R session.</p>
</td></tr>
<tr><td><code id="rxTrans_+3A_md5">md5</code></td>
<td>
<p>Is the md5 of the model before parsing, and is used to
embed the md5 into DLL, and then provide for functions like
<code><a href="#topic+rxModelVars">rxModelVars()</a></code>.</p>
</td></tr>
<tr><td><code id="rxTrans_+3A_modname">modName</code></td>
<td>
<p>a string to be used as the model name. This string
is used for naming various aspects of the computations,
including generating C symbol names, dynamic libraries,
etc. Therefore, it is necessary that <code>modName</code> consists of
simple ASCII alphanumeric characters starting with a letter.</p>
</td></tr>
<tr><td><code id="rxTrans_+3A_modvars">modVars</code></td>
<td>
<p>returns the model variables instead of the named
vector of translated properties.</p>
</td></tr>
<tr><td><code id="rxTrans_+3A_...">...</code></td>
<td>
<p>Ignored parameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a named vector of translated model properties
including what type of jacobian is specified, the <code>C</code> function prefixes,
as well as the <code>C</code> functions names to be called through the compiled model.
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rxode2">rxode2()</a></code>, <code><a href="#topic+rxCompile">rxCompile()</a></code>.
</p>

<hr>
<h2 id='rxUdfUi'>This function is called when processing rxode2 user functions from
the models</h2><span id='topic+rxUdfUi'></span><span id='topic+rxUdfUi.rinbinom'></span>

<h3>Description</h3>

<p>This function is called when processing rxode2 user functions from
the models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxUdfUi(fun)

## S3 method for class 'rinbinom'
rxUdfUi(fun)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxUdfUi_+3A_fun">fun</code></td>
<td>
<p>this is the function that needs to be parsed and
changed.  This is a R language expression</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This needs to return a list with the following elements:
</p>

<ul>
<li> <p><code>iniDf</code> &ndash; the modified initial estimate data.frame
</p>
</li>
<li> <p><code>before</code> &ndash; any model code that needs to be added before the current line
</p>
</li>
<li> <p><code>after</code> &ndash; any model code that needs to be added after the current line
</p>
</li>
<li> <p><code>replace</code> &ndash; replacement code for this user function
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxUdfUiControl'>Return the control that is being processed or setup control for processing</h2><span id='topic+rxUdfUiControl'></span>

<h3>Description</h3>

<p>Return the control that is being processed or setup control for processing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxUdfUiControl(value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxUdfUiControl_+3A_value">value</code></td>
<td>
<p>when specified, this assigns the control to be
processed, or resets it by assigning it to be <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>value of the <code>data.frame</code> being processed or <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>See Also</h3>

<p>Other User functions: 
<code><a href="#topic+linMod">linMod</a>()</code>,
<code><a href="#topic+rxUdfUiData">rxUdfUiData</a>()</code>,
<code><a href="#topic+rxUdfUiEst">rxUdfUiEst</a>()</code>,
<code><a href="#topic+rxUdfUiIniLhs">rxUdfUiIniLhs</a>()</code>,
<code><a href="#topic+rxUdfUiMv">rxUdfUiMv</a>()</code>,
<code><a href="#topic+rxUdfUiNum">rxUdfUiNum</a>()</code>,
<code><a href="#topic+rxUdfUiParsing">rxUdfUiParsing</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rxUdfUiControl()

</code></pre>

<hr>
<h2 id='rxUdfUiData'>Return the data.frame that is being processed or setup data.frame for processing</h2><span id='topic+rxUdfUiData'></span>

<h3>Description</h3>

<p>Return the data.frame that is being processed or setup data.frame for processing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxUdfUiData(value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxUdfUiData_+3A_value">value</code></td>
<td>
<p>when specified, this assigns the data.frame to be processed, or resets it by assigning it to be <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>value of the <code>data.frame</code> being processed or <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>See Also</h3>

<p>Other User functions: 
<code><a href="#topic+linMod">linMod</a>()</code>,
<code><a href="#topic+rxUdfUiControl">rxUdfUiControl</a>()</code>,
<code><a href="#topic+rxUdfUiEst">rxUdfUiEst</a>()</code>,
<code><a href="#topic+rxUdfUiIniLhs">rxUdfUiIniLhs</a>()</code>,
<code><a href="#topic+rxUdfUiMv">rxUdfUiMv</a>()</code>,
<code><a href="#topic+rxUdfUiNum">rxUdfUiNum</a>()</code>,
<code><a href="#topic+rxUdfUiParsing">rxUdfUiParsing</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rxUdfUiData()

</code></pre>

<hr>
<h2 id='rxUdfUiEst'>Return the current estimation method for the UI processing</h2><span id='topic+rxUdfUiEst'></span>

<h3>Description</h3>

<p>Return the current estimation method for the UI processing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxUdfUiEst(value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxUdfUiEst_+3A_value">value</code></td>
<td>
<p>when specified, this assigns the character value of
the estimation method or NULL if there is nothing being estimated</p>
</td></tr>
</table>


<h3>Value</h3>

<p>value of the estimation method being processed or NULL
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>See Also</h3>

<p>Other User functions: 
<code><a href="#topic+linMod">linMod</a>()</code>,
<code><a href="#topic+rxUdfUiControl">rxUdfUiControl</a>()</code>,
<code><a href="#topic+rxUdfUiData">rxUdfUiData</a>()</code>,
<code><a href="#topic+rxUdfUiIniLhs">rxUdfUiIniLhs</a>()</code>,
<code><a href="#topic+rxUdfUiMv">rxUdfUiMv</a>()</code>,
<code><a href="#topic+rxUdfUiNum">rxUdfUiNum</a>()</code>,
<code><a href="#topic+rxUdfUiParsing">rxUdfUiParsing</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rxUdfUiEst()

</code></pre>

<hr>
<h2 id='rxUdfUiIniDf'>Get the rxode2 iniDf of the current UI being processed (or return NULL)</h2><span id='topic+rxUdfUiIniDf'></span>

<h3>Description</h3>

<p>Get the rxode2 iniDf of the current UI being processed (or return NULL)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxUdfUiIniDf()
</code></pre>


<h3>Value</h3>

<p>Initial <code>data.frame</code> being processed or <code>NULL</code> for nothing.
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rxUdfUiIniDf()

</code></pre>

<hr>
<h2 id='rxUdfUiIniLhs'>Return the lhs parsed language expression</h2><span id='topic+rxUdfUiIniLhs'></span>

<h3>Description</h3>

<p>Return the lhs parsed language expression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxUdfUiIniLhs()
</code></pre>


<h3>Value</h3>

<p>lhs language expression or NULL
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>See Also</h3>

<p>Other User functions: 
<code><a href="#topic+linMod">linMod</a>()</code>,
<code><a href="#topic+rxUdfUiControl">rxUdfUiControl</a>()</code>,
<code><a href="#topic+rxUdfUiData">rxUdfUiData</a>()</code>,
<code><a href="#topic+rxUdfUiEst">rxUdfUiEst</a>()</code>,
<code><a href="#topic+rxUdfUiMv">rxUdfUiMv</a>()</code>,
<code><a href="#topic+rxUdfUiNum">rxUdfUiNum</a>()</code>,
<code><a href="#topic+rxUdfUiParsing">rxUdfUiParsing</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rxUdfUiIniLhs()

</code></pre>

<hr>
<h2 id='rxUdfUiMv'>Return the model variables that is being processed or setup model
variables for processing</h2><span id='topic+rxUdfUiMv'></span>

<h3>Description</h3>

<p>Return the model variables that is being processed or setup model
variables for processing
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxUdfUiMv(value)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxUdfUiMv_+3A_value">value</code></td>
<td>
<p>when specified, this assigns the model variables to be
processed, or resets it by assigning it to be <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>value of the <code>modelVariables</code> being processed or <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>See Also</h3>

<p>Other User functions: 
<code><a href="#topic+linMod">linMod</a>()</code>,
<code><a href="#topic+rxUdfUiControl">rxUdfUiControl</a>()</code>,
<code><a href="#topic+rxUdfUiData">rxUdfUiData</a>()</code>,
<code><a href="#topic+rxUdfUiEst">rxUdfUiEst</a>()</code>,
<code><a href="#topic+rxUdfUiIniLhs">rxUdfUiIniLhs</a>()</code>,
<code><a href="#topic+rxUdfUiNum">rxUdfUiNum</a>()</code>,
<code><a href="#topic+rxUdfUiParsing">rxUdfUiParsing</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rxUdfUiMv()

</code></pre>

<hr>
<h2 id='rxUdfUiNum'>This gives the current number in the ui of the particular function being called.</h2><span id='topic+rxUdfUiNum'></span>

<h3>Description</h3>

<p>If this is called outside of function parsing or the input is
unexpected this returns 1L. This is useful when writing replacement
UI functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxUdfUiNum()
</code></pre>


<h3>Value</h3>

<p>integer greater than 1L
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>See Also</h3>

<p>Other User functions: 
<code><a href="#topic+linMod">linMod</a>()</code>,
<code><a href="#topic+rxUdfUiControl">rxUdfUiControl</a>()</code>,
<code><a href="#topic+rxUdfUiData">rxUdfUiData</a>()</code>,
<code><a href="#topic+rxUdfUiEst">rxUdfUiEst</a>()</code>,
<code><a href="#topic+rxUdfUiIniLhs">rxUdfUiIniLhs</a>()</code>,
<code><a href="#topic+rxUdfUiMv">rxUdfUiMv</a>()</code>,
<code><a href="#topic+rxUdfUiParsing">rxUdfUiParsing</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rxUdfUiNum()
</code></pre>

<hr>
<h2 id='rxUdfUiParsing'>Returns if the current ui function is being parsed</h2><span id='topic+rxUdfUiParsing'></span>

<h3>Description</h3>

<p>Returns if the current ui function is being parsed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxUdfUiParsing()
</code></pre>


<h3>Value</h3>

<p>logical if the current ui function is being parsed
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>See Also</h3>

<p>Other User functions: 
<code><a href="#topic+linMod">linMod</a>()</code>,
<code><a href="#topic+rxUdfUiControl">rxUdfUiControl</a>()</code>,
<code><a href="#topic+rxUdfUiData">rxUdfUiData</a>()</code>,
<code><a href="#topic+rxUdfUiEst">rxUdfUiEst</a>()</code>,
<code><a href="#topic+rxUdfUiIniLhs">rxUdfUiIniLhs</a>()</code>,
<code><a href="#topic+rxUdfUiMv">rxUdfUiMv</a>()</code>,
<code><a href="#topic+rxUdfUiNum">rxUdfUiNum</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rxUdfUiParsing()
</code></pre>

<hr>
<h2 id='rxUdfUiReset'>Reset the rxode2 ui environment variables</h2><span id='topic+rxUdfUiReset'></span>

<h3>Description</h3>

<p>Reset the rxode2 ui environment variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxUdfUiReset()
</code></pre>


<h3>Value</h3>

<p>NULL silently
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rxUdfUiReset()
</code></pre>

<hr>
<h2 id='rxUiDecompress'>Compress/Decompress <code>rxode2</code> ui</h2><span id='topic+rxUiDecompress'></span><span id='topic+rxUiCompress'></span>

<h3>Description</h3>

<p>Compress/Decompress <code>rxode2</code> ui
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxUiDecompress(ui)

rxUiCompress(ui)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxUiDecompress_+3A_ui">ui</code></td>
<td>
<p>rxode2 ui object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A compressed or decompressed rxui object
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>one.cmt &lt;- function() {
  ini({
    ## You may label each parameter with a comment
    tka &lt;- 0.45 # Log Ka
    tcl &lt;- log(c(0, 2.7, 100)) # Log Cl
    ## This works with interactive models
    ## You may also label the preceding line with label("label text")
    tv &lt;- 3.45; label("log V")
    ## the label("Label name") works with all models
    eta.ka ~ 0.6
    eta.cl ~ 0.3
    eta.v ~ 0.1
    add.sd &lt;- 0.7
  })
  model({
    ka &lt;- exp(tka + eta.ka)
    cl &lt;- exp(tcl + eta.cl)
    v &lt;- exp(tv + eta.v)
    linCmt() ~ add(add.sd) | tmp
  })
}

f &lt;- rxode2(one.cmt)
print(class(f))
print(is.environment(f))

f  &lt;- rxUiDecompress(f)
print(class(f))
print(is.environment(f))

f  &lt;- rxUiCompress(f)
print(class(f))
print(is.environment(f))

</code></pre>

<hr>
<h2 id='rxUiDeparse'>This is a generic function for deparsing certain objects when
printing out a rxode2 object.  Currently it is used for any meta-information</h2><span id='topic+rxUiDeparse'></span><span id='topic+rxUiDeparse.lotriFix'></span><span id='topic+rxUiDeparse.default'></span><span id='topic+rxUiDeparse.rxControl'></span>

<h3>Description</h3>

<p>This is a generic function for deparsing certain objects when
printing out a rxode2 object.  Currently it is used for any meta-information
</p>
<p>rxUiDeparse.rxControl(rxControl(covsInterpolation=&quot;linear&quot;, method=&quot;dop853&quot;,
naInterpolation=&quot;nocb&quot;, keepInterpolation=&quot;nocb&quot;, sigmaXform=&quot;variance&quot;,
omegaXform=&quot;variance&quot;, returnType=&quot;data.frame&quot;, sumType=&quot;fsum&quot;, prodType=&quot;logify&quot;,
sensType=&quot;central&quot;), &quot;ctl&quot;)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxUiDeparse(object, var)

## S3 method for class 'lotriFix'
rxUiDeparse(object, var)

## Default S3 method:
rxUiDeparse(object, var)

## S3 method for class 'rxControl'
rxUiDeparse(object, var)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxUiDeparse_+3A_object">object</code></td>
<td>
<p>object to be deparsed</p>
</td></tr>
<tr><td><code id="rxUiDeparse_+3A_var">var</code></td>
<td>
<p>variable name to be assigned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>parsed R expression that can be used for printing and
<code>as.function()</code> calls.
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mat &lt;- matrix(c(1, 0.1, 0.1, 1), 2, 2, dimnames=list(c("a", "b"), c("a", "b")))

rxUiDeparse(matrix(c(1, 0.1, 0.1, 1), 2, 2, dimnames=list(c("a", "b"), c("a", "b"))), "x")
</code></pre>

<hr>
<h2 id='rxUiGet.cmtLines'>S3 for getting information from UI model</h2><span id='topic+rxUiGet.cmtLines'></span><span id='topic+rxUiGet.dvidLine'></span><span id='topic+rxUiGet.paramsLine'></span><span id='topic+rxUiGet.interpLines'></span><span id='topic+rxUiGet.simulationSigma'></span><span id='topic+rxUiGet.simulationModel'></span><span id='topic+rxUiGet.symengineModelNoPrune'></span><span id='topic+rxUiGet.symengineModelPrune'></span><span id='topic+rxUiGet.simulationIniModel'></span><span id='topic+rxUiGet'></span><span id='topic+rxUiGet.levels'></span><span id='topic+rxUiGet.state'></span><span id='topic+rxUiGet.stateDf'></span><span id='topic+rxUiGet.statePropDf'></span><span id='topic+rxUiGet.props'></span><span id='topic+rxUiGet.theta'></span><span id='topic+rxUiGet.lstChr'></span><span id='topic+rxUiGet.omega'></span><span id='topic+rxUiGet.funTxt'></span><span id='topic+rxUiGet.allCovs'></span><span id='topic+rxUiGet.muRefTable'></span><span id='topic+rxUiGet.multipleEndpoint'></span><span id='topic+rxUiGet.funPrint'></span><span id='topic+rxUiGet.fun'></span><span id='topic+rxUiGet.funPartsDigest'></span><span id='topic+rxUiGet.md5'></span><span id='topic+rxUiGet.sha1'></span><span id='topic+rxUiGet.ini'></span><span id='topic+rxUiGet.iniFun'></span><span id='topic+rxUiGet.modelFun'></span><span id='topic+rxUiGet.model'></span><span id='topic+rxUiGet.modelDesc'></span><span id='topic+rxUiGet.thetaLower'></span><span id='topic+rxUiGet.thetaUpper'></span><span id='topic+rxUiGet.lhsVar'></span><span id='topic+rxUiGet.varLhs'></span><span id='topic+rxUiGet.lhsEta'></span><span id='topic+rxUiGet.lhsTheta'></span><span id='topic+rxUiGet.lhsCov'></span><span id='topic+rxUiGet.etaLhs'></span><span id='topic+rxUiGet.thetaLhs'></span><span id='topic+rxUiGet.covLhs'></span><span id='topic+rxUiGet.default'></span>

<h3>Description</h3>

<p>S3 for getting information from UI model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cmtLines'
rxUiGet(x, ...)

## S3 method for class 'dvidLine'
rxUiGet(x, ...)

## S3 method for class 'paramsLine'
rxUiGet(x, ...)

## S3 method for class 'interpLines'
rxUiGet(x, ...)

## S3 method for class 'simulationSigma'
rxUiGet(x, ...)

## S3 method for class 'simulationModel'
rxUiGet(x, ...)

## S3 method for class 'symengineModelNoPrune'
rxUiGet(x, ...)

## S3 method for class 'symengineModelPrune'
rxUiGet(x, ...)

## S3 method for class 'simulationIniModel'
rxUiGet(x, ...)

rxUiGet(x, ...)

## S3 method for class 'levels'
rxUiGet(x, ...)

## S3 method for class 'state'
rxUiGet(x, ...)

## S3 method for class 'stateDf'
rxUiGet(x, ...)

## S3 method for class 'statePropDf'
rxUiGet(x, ...)

## S3 method for class 'props'
rxUiGet(x, ...)

## S3 method for class 'theta'
rxUiGet(x, ...)

## S3 method for class 'lstChr'
rxUiGet(x, ...)

## S3 method for class 'omega'
rxUiGet(x, ...)

## S3 method for class 'funTxt'
rxUiGet(x, ...)

## S3 method for class 'allCovs'
rxUiGet(x, ...)

## S3 method for class 'muRefTable'
rxUiGet(x, ...)

## S3 method for class 'multipleEndpoint'
rxUiGet(x, ...)

## S3 method for class 'funPrint'
rxUiGet(x, ...)

## S3 method for class 'fun'
rxUiGet(x, ...)

## S3 method for class 'funPartsDigest'
rxUiGet(x, ...)

## S3 method for class 'md5'
rxUiGet(x, ...)

## S3 method for class 'sha1'
rxUiGet(x, ...)

## S3 method for class 'ini'
rxUiGet(x, ...)

## S3 method for class 'iniFun'
rxUiGet(x, ...)

## S3 method for class 'modelFun'
rxUiGet(x, ...)

## S3 method for class 'model'
rxUiGet(x, ...)

## S3 method for class 'modelDesc'
rxUiGet(x, ...)

## S3 method for class 'thetaLower'
rxUiGet(x, ...)

## S3 method for class 'thetaUpper'
rxUiGet(x, ...)

## S3 method for class 'lhsVar'
rxUiGet(x, ...)

## S3 method for class 'varLhs'
rxUiGet(x, ...)

## S3 method for class 'lhsEta'
rxUiGet(x, ...)

## S3 method for class 'lhsTheta'
rxUiGet(x, ...)

## S3 method for class 'lhsCov'
rxUiGet(x, ...)

## S3 method for class 'etaLhs'
rxUiGet(x, ...)

## S3 method for class 'thetaLhs'
rxUiGet(x, ...)

## S3 method for class 'covLhs'
rxUiGet(x, ...)

## Default S3 method:
rxUiGet(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxUiGet.cmtLines_+3A_x">x</code></td>
<td>
<p>list of (UIenvironment, exact).  UI environment is the
parsed function for rxode2.  <code>exact</code> is a boolean that says if an
exact match is required.</p>
</td></tr>
<tr><td><code id="rxUiGet.cmtLines_+3A_...">...</code></td>
<td>
<p>Other arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>value that was requested from the UI object
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>

<hr>
<h2 id='rxunif'>Simulate uniform variable from threefry generator</h2><span id='topic+rxunif'></span>

<h3>Description</h3>

<p>Care should be taken with this method not to encounter the
birthday problem, described
<a href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/">https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/</a>.
Since the <code>sitmo</code> <code>threefry</code>, this currently generates
one random deviate from the uniform distribution to seed the
engine <code>threefry</code> and then run the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxunif(min = 0, max = 1, n = 1L, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxunif_+3A_min">min</code>, <code id="rxunif_+3A_max">max</code></td>
<td>
<p>lower and upper limits of the distribution.  Must be finite.</p>
</td></tr>
<tr><td><code id="rxunif_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="rxunif_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the simulation
</p>
<p><code>rxnorm</code> simulates using the threefry sitmo generator.
</p>
<p><code>rxnormV</code> used to simulate with the vandercorput simulator, but
since it didn't satisfy the normal properties it was changed to simple be
an alias of <code>rxnorm</code>. It is no longer supported in <code>rxode2({})</code> blocks</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Therefore, a simple call to the random number generated followed by a second
call to random number generated may have identical seeds.  As the number of
random number generator calls are increased the probability that the
birthday problem will increase.
</p>
<p>The key to avoid this problem is to either run all simulations in the
<code>rxode2</code> environment once (therefore one seed or series of seeds
for the whole simulation), pre-generate all random variables
used for the simulation, or seed the rxode2 engine with <code>rxSetSeed()</code>
</p>
<p>Internally each ID is seeded with a unique number so that the
results do not depend on the number of cores used.
</p>


<h3>Value</h3>

<p>uniform random numbers
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Use threefry engine

rxunif(min = 0, max = 4, n = 10) # with rxunif you have to explicitly state n
rxunif(min = 0, max = 4, n = 10, ncores = 2) # You can parallelize the simulation using openMP

rxunif()


## This example uses `rxunif` directly in the model

rx &lt;- function() {
  model({
    a &lt;- rxunif(0, 3)
  })
}

et &lt;- et(1, id = 1:2)

s &lt;- rxSolve(rx, et)


</code></pre>

<hr>
<h2 id='rxUnloadAll'>Unloads all rxode2 compiled DLLs</h2><span id='topic+rxUnloadAll'></span>

<h3>Description</h3>

<p>Unloads all rxode2 compiled DLLs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxUnloadAll()
</code></pre>


<h3>Value</h3>

<p>List of rxode2 dlls still loaded
</p>
<p>boolean of if all rxode2 dlls have been unloaded
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
print(rxUnloadAll())
</code></pre>

<hr>
<h2 id='rxUse'>Use model object in your package</h2><span id='topic+rxUse'></span>

<h3>Description</h3>

<p>Use model object in your package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxUse(obj, overwrite = TRUE, compress = "bzip2", internal = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxUse_+3A_obj">obj</code></td>
<td>
<p>model to save.</p>
</td></tr>
<tr><td><code id="rxUse_+3A_overwrite">overwrite</code></td>
<td>
<p>By default, <code>use_data()</code> will not overwrite existing
files. If you really want to do so, set this to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="rxUse_+3A_compress">compress</code></td>
<td>
<p>Choose the type of compression used by <code><a href="base.html#topic+save">save()</a></code>.
Should be one of &quot;gzip&quot;, &quot;bzip2&quot;, or &quot;xz&quot;.</p>
</td></tr>
<tr><td><code id="rxUse_+3A_internal">internal</code></td>
<td>
<p>If this is run internally.  By default this is FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing; This is used for its side effects and shouldn't be called by a user
</p>

<hr>
<h2 id='rxValidate'>Validate rxode2
This allows easy validation/qualification of nlmixr by running the
testing suite on your system.</h2><span id='topic+rxValidate'></span><span id='topic+rxTest'></span>

<h3>Description</h3>

<p>Validate rxode2
This allows easy validation/qualification of nlmixr by running the
testing suite on your system.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxValidate(type = NULL, skipOnCran = TRUE)

rxTest(type = NULL, skipOnCran = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxValidate_+3A_type">type</code></td>
<td>
<p>Type of test or filter of test type, When this is an
expression, evaluate the contents, respecting <code>skipOnCran</code></p>
</td></tr>
<tr><td><code id="rxValidate_+3A_skiponcran">skipOnCran</code></td>
<td>
<p>when <code>TRUE</code> skip the test on CRAN.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>nothing
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxVersion'>Version and repository for this dparser package.</h2><span id='topic+rxVersion'></span>

<h3>Description</h3>

<p>Version and repository for this dparser package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxVersion(
  extra = "",
  echo = FALSE,
  version = sessionInfo()$otherPkgs$rxode2$Version
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxVersion_+3A_extra">extra</code></td>
<td>
<p>extra text to display in the logo</p>
</td></tr>
<tr><td><code id="rxVersion_+3A_echo">echo</code></td>
<td>
<p>Boolean to echo the text logo, by default FALSE</p>
</td></tr>
<tr><td><code id="rxVersion_+3A_version">version</code></td>
<td>
<p>Version to display/return</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with the version and repository.
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>

<hr>
<h2 id='rxweibull'>Simulate Weibull variable from threefry generator</h2><span id='topic+rxweibull'></span>

<h3>Description</h3>

<p>Care should be taken with this method not to encounter the
birthday problem, described
<a href="https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/">https://www.johndcook.com/blog/2016/01/29/random-number-generator-seed-mistakes/</a>.
Since the <code>sitmo</code> <code>threefry</code>, this currently generates
one random deviate from the uniform distribution to seed the
engine <code>threefry</code> and then run the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxweibull(shape, scale = 1, n = 1L, ncores = 1L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxweibull_+3A_shape">shape</code>, <code id="rxweibull_+3A_scale">scale</code></td>
<td>
<p>shape and scale parameters, the latter defaulting to 1.</p>
</td></tr>
<tr><td><code id="rxweibull_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n) &gt; 1</code>, the length
is taken to be the number required.</p>
</td></tr>
<tr><td><code id="rxweibull_+3A_ncores">ncores</code></td>
<td>
<p>Number of cores for the simulation
</p>
<p><code>rxnorm</code> simulates using the threefry sitmo generator.
</p>
<p><code>rxnormV</code> used to simulate with the vandercorput simulator, but
since it didn't satisfy the normal properties it was changed to simple be
an alias of <code>rxnorm</code>. It is no longer supported in <code>rxode2({})</code> blocks</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Therefore, a simple call to the random number generated followed by a second
call to random number generated may have identical seeds.  As the number of
random number generator calls are increased the probability that the
birthday problem will increase.
</p>
<p>The key to avoid this problem is to either run all simulations in the
<code>rxode2</code> environment once (therefore one seed or series of seeds
for the whole simulation), pre-generate all random variables
used for the simulation, or seed the rxode2 engine with <code>rxSetSeed()</code>
</p>
<p>Internally each ID is seeded with a unique number so that the
results do not depend on the number of cores used.
</p>


<h3>Value</h3>

<p>Weibull random deviates
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Use threefry engine

# with rxweibull you have to explicitly state n
rxweibull(shape = 1, scale = 4, n = 10)

# You can parallelize the simulation using openMP
rxweibull(shape = 1, scale = 4, n = 10, ncores = 2)

rxweibull(3)


## This example uses `rxweibull` directly in the model

rx &lt;- function() {
  model({
    a &lt;- rxweibull(1, 3)
  })
}

et &lt;- et(1, id = 1:2)

s &lt;- rxSolve(rx, et)

</code></pre>

<hr>
<h2 id='rxWithSeed'>Preserved seed and possibly set the seed</h2><span id='topic+rxWithSeed'></span><span id='topic+rxWithPreserveSeed'></span>

<h3>Description</h3>

<p>Preserved seed and possibly set the seed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rxWithSeed(
  seed,
  code,
  rxseed = rxGetSeed(),
  kind = "default",
  normal.kind = "default",
  sample.kind = "default"
)

rxWithPreserveSeed(code)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rxWithSeed_+3A_seed">seed</code></td>
<td>
<p>R seed to use for the session</p>
</td></tr>
<tr><td><code id="rxWithSeed_+3A_code">code</code></td>
<td>
<p>Is the code to evaluate</p>
</td></tr>
<tr><td><code id="rxWithSeed_+3A_rxseed">rxseed</code></td>
<td>
<p>is the rxode2 seed that is being preserved</p>
</td></tr>
<tr><td><code id="rxWithSeed_+3A_kind">kind</code></td>
<td>
<p>character or <code>NULL</code>.  If <code>kind</code> is a character
string, set <span class="rlang"><b>R</b></span>'s RNG to the kind desired.  Use <code>"default"</code> to
return to the <span class="rlang"><b>R</b></span> default.  See &lsquo;Details&rsquo; for the
interpretation of <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="rxWithSeed_+3A_normal.kind">normal.kind</code></td>
<td>
<p>character string or <code>NULL</code>.  If it is a character
string, set the method of Normal generation.  Use <code>"default"</code>
to return to the <span class="rlang"><b>R</b></span> default.  <code>NULL</code> makes no change.</p>
</td></tr>
<tr><td><code id="rxWithSeed_+3A_sample.kind">sample.kind</code></td>
<td>
<p>character string or <code>NULL</code>.  If it is a character
string, set the method of discrete uniform generation (used in 
<code><a href="base.html#topic+sample">sample</a></code>, for instance).  Use <code>"default"</code> to return to 
the <span class="rlang"><b>R</b></span> default.  <code>NULL</code> makes no change.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns whatever the code is returning
</p>


<h3>See Also</h3>

<p>rxGetSeed, rxSetSeed
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
rxGetSeed()
rxWithSeed(1, {
   print(rxGetSeed())
   rxnorm()
   print(rxGetSeed())
   rxnorm()
}, rxseed=3)

</code></pre>

<hr>
<h2 id='SELU'>Scaled Exponential Linear Unit (SELU) Activation Function</h2><span id='topic+SELU'></span>

<h3>Description</h3>

<p>Scaled Exponential Linear Unit (SELU) Activation Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SELU(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="SELU_+3A_x">x</code></td>
<td>
<p>A numeric vector. All elements must be finite and
non-missing.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector where the ReLU function has been applied
to each element of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>


<h3>See Also</h3>

<p>Other Activation Functions: 
<code><a href="#topic+ELU">ELU</a>()</code>,
<code><a href="#topic+GELU">GELU</a>()</code>,
<code><a href="#topic+PReLU">PReLU</a>()</code>,
<code><a href="#topic+ReLU">ReLU</a>()</code>,
<code><a href="#topic+Swish">Swish</a>()</code>,
<code><a href="#topic+dELU">dELU</a>()</code>,
<code><a href="#topic+dGELU">dGELU</a>()</code>,
<code><a href="#topic+dPReLU">dPReLU</a>()</code>,
<code><a href="#topic+dReLU">dReLU</a>()</code>,
<code><a href="#topic+dSELU">dSELU</a>()</code>,
<code><a href="#topic+dSwish">dSwish</a>()</code>,
<code><a href="#topic+dlReLU">dlReLU</a>()</code>,
<code><a href="#topic+dsoftplus">dsoftplus</a>()</code>,
<code><a href="#topic+lReLU">lReLU</a>()</code>,
<code><a href="#topic+softplus">softplus</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
SELU(c(-1, 0, 1, 2))

# Can also be used in rxode2:
x &lt;- rxode2({
   r=SELU(time)
})

e &lt;- et(c(-1, 0, 1, 2))

rxSolve(x, e)

</code></pre>

<hr>
<h2 id='softplus'>Softplus Activation Function</h2><span id='topic+softplus'></span>

<h3>Description</h3>

<p>Softplus Activation Function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>softplus(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="softplus_+3A_x">x</code></td>
<td>
<p>numeric vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>See Also</h3>

<p>Other Activation Functions: 
<code><a href="#topic+ELU">ELU</a>()</code>,
<code><a href="#topic+GELU">GELU</a>()</code>,
<code><a href="#topic+PReLU">PReLU</a>()</code>,
<code><a href="#topic+ReLU">ReLU</a>()</code>,
<code><a href="#topic+SELU">SELU</a>()</code>,
<code><a href="#topic+Swish">Swish</a>()</code>,
<code><a href="#topic+dELU">dELU</a>()</code>,
<code><a href="#topic+dGELU">dGELU</a>()</code>,
<code><a href="#topic+dPReLU">dPReLU</a>()</code>,
<code><a href="#topic+dReLU">dReLU</a>()</code>,
<code><a href="#topic+dSELU">dSELU</a>()</code>,
<code><a href="#topic+dSwish">dSwish</a>()</code>,
<code><a href="#topic+dlReLU">dlReLU</a>()</code>,
<code><a href="#topic+dsoftplus">dsoftplus</a>()</code>,
<code><a href="#topic+lReLU">lReLU</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
softplus(c(-1, 0, 1, 2))

# You can use rxode2 too:

r &lt;- rxode2({
 s &lt;- softplus(time)
})

e &lt;- et(c(-1, 0, 1, 2))

rxSolve(r, e)

</code></pre>

<hr>
<h2 id='stat_amt'>Dosing/Amt geom/stat</h2><span id='topic+stat_amt'></span><span id='topic+geom_amt'></span>

<h3>Description</h3>

<p>This is a dosing geom that shows the vertical lines where a dose occurs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_amt(
  mapping = NULL,
  data = NULL,
  position = "identity",
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)

geom_amt(
  mapping = NULL,
  data = NULL,
  position = "identity",
  show.legend = NA,
  inherit.aes = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stat_amt_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_amt_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_amt_+3A_position">position</code></td>
<td>
<p>A position adjustment to use on the data for this layer. This
can be used in various ways, including to prevent overplotting and
improving the display. The <code>position</code> argument accepts the following:
</p>

<ul>
<li><p> The result of calling a position function, such as <code>position_jitter()</code>.
This method allows for passing extra arguments to the position.
</p>
</li>
<li><p> A string naming the position adjustment. To give the position as a
string, strip the function name of the <code>position_</code> prefix. For example,
to use <code>position_jitter()</code>, give the position as <code>"jitter"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the position, see the
<a href="ggplot2.html#topic+layer_positions">layer position</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_amt_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="stat_amt_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_amt_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>'s <code>params</code> argument. These
arguments broadly fall into one of 4 categories below. Notably, further
arguments to the <code>position</code> argument, or aesthetics that are required
can <em>not</em> be passed through <code>...</code>. Unknown arguments that are not part
of the 4 categories below are ignored.
</p>

<ul>
<li><p> Static aesthetics that are not mapped to a scale, but are at a fixed
value and apply to the layer as a whole. For example, <code>colour = "red"</code>
or <code>linewidth = 3</code>. The geom's documentation has an <strong>Aesthetics</strong>
section that lists the available options. The 'required' aesthetics
cannot be passed on to the <code>params</code>. Please note that while passing
unmapped aesthetics as vectors is technically possible, the order and
required length is not guaranteed to be parallel to the input data.
</p>
</li>
<li><p> When constructing a layer using
a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on
parameters to the <code>geom</code> part of the layer. An example of this is
<code>stat_density(geom = "area", outline.type = "both")</code>. The geom's
documentation lists which parameters it can accept.
</p>
</li>
<li><p> Inversely, when constructing a layer using a
<code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on parameters
to the <code>stat</code> part of the layer. An example of this is
<code>geom_area(stat = "density", adjust = 0.5)</code>. The stat's documentation
lists which parameters it can accept.
</p>
</li>
<li><p> The <code>key_glyph</code> argument of <code><a href="ggplot2.html#topic+layer">layer()</a></code> may also be passed on through
<code>...</code>. This can be one of the functions described as
<a href="ggplot2.html#topic+draw_key">key glyphs</a>, to change the display of the layer in the legend.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Requires the following aesthetics:
</p>

<ul>
<li><p> x representing the x values, usually time
</p>
</li>
<li><p> amt representing the dosing values;  They are missing or zero when no dose is given
</p>
</li></ul>



<h3>Value</h3>

<p>This returns a stat_amt in context of a ggplot2 plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

library(rxode2)
library(units)


## Model from RxODE tutorial
mod1 &lt;- function() {
  ini({
    KA &lt;- 2.94E-01
    CL &lt;- 1.86E+01
    V2 &lt;- 4.02E+01
    Q  &lt;- 1.05E+01
    V3 &lt;- 2.97E+02
    Kin &lt;- 1
    Kout &lt;- 1
    EC50 &lt;- 200
  })
  model({
    C2 &lt;- centr/V2
    C3 &lt;- peri/V3
    d/dt(depot) &lt;- -KA*depot
    d/dt(centr) &lt;-  KA*depot - CL*C2 - Q*C2 + Q*C3
    d/dt(peri)  &lt;-                    Q*C2 - Q*C3
    d/dt(eff)   &lt;- Kin - Kout*(1-C2/(EC50+C2))*eff
  })
}

## These are making the more complex regimens of the rxode2 tutorial

## bid for 5 days
bid &lt;- et(timeUnits="hr") %&gt;%
  et(amt=10000,ii=12,until=set_units(5, "days"))

## qd for 5 days
qd &lt;- et(timeUnits="hr") %&gt;%
      et(amt=20000,ii=24,until=set_units(5, "days"))

## bid for 5 days followed by qd for 5 days

et &lt;- seq(bid,qd) %&gt;% et(seq(0,11*24,length.out=100))

bidQd &lt;- rxSolve(mod1, et, addDosing=TRUE)

# by default dotted and under-stated
plot(bidQd, C2) + geom_amt(aes(amt=amt))

# of course you can make it a bit more visible

plot(bidQd, C2) + geom_amt(aes(amt=amt), col="red", lty=1, linewidth=1.2)


</code></pre>

<hr>
<h2 id='stat_cens'>Censoring geom/stat</h2><span id='topic+stat_cens'></span><span id='topic+geom_cens'></span>

<h3>Description</h3>

<p>This is a censoring geom that shows the left or right censoring specified in the nlmixr input data-set or fit
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stat_cens(
  mapping = NULL,
  data = NULL,
  position = "identity",
  show.legend = NA,
  inherit.aes = TRUE,
  width = 0.01,
  ...
)

geom_cens(
  mapping = NULL,
  data = NULL,
  position = "identity",
  show.legend = NA,
  inherit.aes = TRUE,
  width = 0.01,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stat_cens_+3A_mapping">mapping</code></td>
<td>
<p>Set of aesthetic mappings created by <code><a href="ggplot2.html#topic+aes">aes()</a></code>. If specified and
<code>inherit.aes = TRUE</code> (the default), it is combined with the default mapping
at the top level of the plot. You must supply <code>mapping</code> if there is no plot
mapping.</p>
</td></tr>
<tr><td><code id="stat_cens_+3A_data">data</code></td>
<td>
<p>The data to be displayed in this layer. There are three
options:
</p>
<p>If <code>NULL</code>, the default, the data is inherited from the plot
data as specified in the call to <code><a href="ggplot2.html#topic+ggplot">ggplot()</a></code>.
</p>
<p>A <code>data.frame</code>, or other object, will override the plot
data. All objects will be fortified to produce a data frame. See
<code><a href="ggplot2.html#topic+fortify">fortify()</a></code> for which variables will be created.
</p>
<p>A <code>function</code> will be called with a single argument,
the plot data. The return value must be a <code>data.frame</code>, and
will be used as the layer data. A <code>function</code> can be created
from a <code>formula</code> (e.g. <code>~ head(.x, 10)</code>).</p>
</td></tr>
<tr><td><code id="stat_cens_+3A_position">position</code></td>
<td>
<p>A position adjustment to use on the data for this layer. This
can be used in various ways, including to prevent overplotting and
improving the display. The <code>position</code> argument accepts the following:
</p>

<ul>
<li><p> The result of calling a position function, such as <code>position_jitter()</code>.
This method allows for passing extra arguments to the position.
</p>
</li>
<li><p> A string naming the position adjustment. To give the position as a
string, strip the function name of the <code>position_</code> prefix. For example,
to use <code>position_jitter()</code>, give the position as <code>"jitter"</code>.
</p>
</li>
<li><p> For more information and other ways to specify the position, see the
<a href="ggplot2.html#topic+layer_positions">layer position</a> documentation.
</p>
</li></ul>
</td></tr>
<tr><td><code id="stat_cens_+3A_show.legend">show.legend</code></td>
<td>
<p>logical. Should this layer be included in the legends?
<code>NA</code>, the default, includes if any aesthetics are mapped.
<code>FALSE</code> never includes, and <code>TRUE</code> always includes.
It can also be a named logical vector to finely select the aesthetics to
display.</p>
</td></tr>
<tr><td><code id="stat_cens_+3A_inherit.aes">inherit.aes</code></td>
<td>
<p>If <code>FALSE</code>, overrides the default aesthetics,
rather than combining with them. This is most useful for helper functions
that define both data and aesthetics and shouldn't inherit behaviour from
the default plot specification, e.g. <code><a href="ggplot2.html#topic+borders">borders()</a></code>.</p>
</td></tr>
<tr><td><code id="stat_cens_+3A_width">width</code></td>
<td>
<p>represents the width (in \
censoring box</p>
</td></tr>
<tr><td><code id="stat_cens_+3A_...">...</code></td>
<td>
<p>Other arguments passed on to <code><a href="ggplot2.html#topic+layer">layer()</a></code>'s <code>params</code> argument. These
arguments broadly fall into one of 4 categories below. Notably, further
arguments to the <code>position</code> argument, or aesthetics that are required
can <em>not</em> be passed through <code>...</code>. Unknown arguments that are not part
of the 4 categories below are ignored.
</p>

<ul>
<li><p> Static aesthetics that are not mapped to a scale, but are at a fixed
value and apply to the layer as a whole. For example, <code>colour = "red"</code>
or <code>linewidth = 3</code>. The geom's documentation has an <strong>Aesthetics</strong>
section that lists the available options. The 'required' aesthetics
cannot be passed on to the <code>params</code>. Please note that while passing
unmapped aesthetics as vectors is technically possible, the order and
required length is not guaranteed to be parallel to the input data.
</p>
</li>
<li><p> When constructing a layer using
a <code style="white-space: pre;">&#8288;stat_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on
parameters to the <code>geom</code> part of the layer. An example of this is
<code>stat_density(geom = "area", outline.type = "both")</code>. The geom's
documentation lists which parameters it can accept.
</p>
</li>
<li><p> Inversely, when constructing a layer using a
<code style="white-space: pre;">&#8288;geom_*()&#8288;</code> function, the <code>...</code> argument can be used to pass on parameters
to the <code>stat</code> part of the layer. An example of this is
<code>geom_area(stat = "density", adjust = 0.5)</code>. The stat's documentation
lists which parameters it can accept.
</p>
</li>
<li><p> The <code>key_glyph</code> argument of <code><a href="ggplot2.html#topic+layer">layer()</a></code> may also be passed on through
<code>...</code>. This can be one of the functions described as
<a href="ggplot2.html#topic+draw_key">key glyphs</a>, to change the display of the layer in the legend.
</p>
</li></ul>
</td></tr>
</table>


<h3>Details</h3>

<p>Requires the following aesthetics:
</p>

<ul>
<li> <p><code>x</code> Represents the independent variable, often the time scale
</p>
</li>
<li> <p><code>y</code> represents the dependent variable
</p>
</li>
<li> <p><code>CENS</code> for the censoring information; (<code>-1</code> right censored, <code>0</code> no censoring or <code>1</code> left censoring)
</p>
</li>
<li> <p><code>LIMIT</code> which represents the corresponding limit ()
</p>
</li></ul>

<p>Will add boxes representing the areas of the fit that were censored.
</p>


<h3>Value</h3>

<p>This returns a ggplot2 stat
</p>

<hr>
<h2 id='summary.rxDll'>Summary of rxDll object</h2><span id='topic+summary.rxDll'></span>

<h3>Description</h3>

<p>This gives expanded information about the rxDll object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rxDll'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.rxDll_+3A_object">object</code></td>
<td>
<p>RxDll object</p>
</td></tr>
<tr><td><code id="summary.rxDll_+3A_...">...</code></td>
<td>
<p>Other arguments.  Includes <code>noprint</code>, which is a
logical telling if the object should print the rxDll object
first. By default this is FALSE</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object is returned
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>

<hr>
<h2 id='summary.rxode2'>Print expanded information about the rxode2 object.</h2><span id='topic+summary.rxode2'></span>

<h3>Description</h3>

<p>This prints the expanded information about the rxode2 object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rxode2'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.rxode2_+3A_object">object</code></td>
<td>
<p>rxode2 object</p>
</td></tr>
<tr><td><code id="summary.rxode2_+3A_...">...</code></td>
<td>
<p>Ignored parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object is returned
</p>


<h3>Author(s)</h3>

<p>Matthew L.Fidler
</p>

<hr>
<h2 id='swapMatListWithCube'>Swaps the matrix list with a cube</h2><span id='topic+swapMatListWithCube'></span>

<h3>Description</h3>

<p>Swaps the matrix list with a cube
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swapMatListWithCube(matrixListOrCube)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="swapMatListWithCube_+3A_matrixlistorcube">matrixListOrCube</code></td>
<td>
<p>Either a list of 2-dimensional matrices or a cube of matrices</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list or a cube (opposite format as input)
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Create matrix list
matLst &lt;- cvPost(10, lotri::lotri(a+b~c(1, 0.25, 1)), 3)
print(matLst)

# Convert to cube
matCube &lt;- swapMatListWithCube(matLst)
print(matCube)

# Convert back to list
matLst2 &lt;- swapMatListWithCube(matCube)
print(matLst2)

</code></pre>

<hr>
<h2 id='Swish'>Switch Activation Function</h2><span id='topic+Swish'></span>

<h3>Description</h3>

<p>The switch activation function is defined as:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Swish(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Swish_+3A_x">x</code></td>
<td>
<p>A numeric vector. All elements must be finite and
non-missing.</p>
</td></tr>
</table>


<h3>Details</h3>

<p style="text-align: center;"><code class="reqn">f(x) = x \cdot \text{sigmoid}(x)</code>
</p>



<h3>Value</h3>

<p>A numeric vector where the ReLU function has been applied
to each element of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Matthew Fidler
</p>


<h3>See Also</h3>

<p>Other Activation Functions: 
<code><a href="#topic+ELU">ELU</a>()</code>,
<code><a href="#topic+GELU">GELU</a>()</code>,
<code><a href="#topic+PReLU">PReLU</a>()</code>,
<code><a href="#topic+ReLU">ReLU</a>()</code>,
<code><a href="#topic+SELU">SELU</a>()</code>,
<code><a href="#topic+dELU">dELU</a>()</code>,
<code><a href="#topic+dGELU">dGELU</a>()</code>,
<code><a href="#topic+dPReLU">dPReLU</a>()</code>,
<code><a href="#topic+dReLU">dReLU</a>()</code>,
<code><a href="#topic+dSELU">dSELU</a>()</code>,
<code><a href="#topic+dSwish">dSwish</a>()</code>,
<code><a href="#topic+dlReLU">dlReLU</a>()</code>,
<code><a href="#topic+dsoftplus">dsoftplus</a>()</code>,
<code><a href="#topic+lReLU">lReLU</a>()</code>,
<code><a href="#topic+softplus">softplus</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Swish(c(-1, 0, 1, 2))

# Can also be used in rxode2:
x &lt;- rxode2({
   r&lt;- Swish(time)
})

e &lt;- et(c(-1, 0, 1, 2))

rxSolve(x, e)

</code></pre>

<hr>
<h2 id='testIniDf'>This function tests if this object is a iniDf as needed by the UI</h2><span id='topic+testIniDf'></span><span id='topic+assertIniDf'></span>

<h3>Description</h3>

<p>This function tests if this object is a iniDf as needed by the UI
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testIniDf(iniDf)

assertIniDf(iniDf, extra = "", .var.name = .vname(iniDf), null.ok = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="testIniDf_+3A_inidf">iniDf</code></td>
<td>
<p>the object to test if it is a rxode2 ui <code>iniDf</code> data.frame</p>
</td></tr>
<tr><td><code id="testIniDf_+3A_extra">extra</code></td>
<td>
<p>information to append to the error message</p>
</td></tr>
<tr><td><code id="testIniDf_+3A_.var.name">.var.name</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Name of the checked object to print in assertions. Defaults to
the heuristic implemented in <code><a href="checkmate.html#topic+vname">vname</a></code>.</p>
</td></tr>
<tr><td><code id="testIniDf_+3A_null.ok">null.ok</code></td>
<td>
<p>[<code>logical(1)</code>]<br />
If set to <code>TRUE</code>, <code>x</code> may also be <code>NULL</code>.
In this case only a type check of <code>x</code> is performed, all additional checks are disabled.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boolean, indicating if the object is a valid initialization data frame
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>assertIniDf()</code>: Assert that the object is a valid rxode2 ui initialization data frame
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>See Also</h3>

<p>Other Assertions: 
<code><a href="#topic+assertCompartmentExists">assertCompartmentExists</a>()</code>,
<code><a href="#topic+assertCompartmentName">assertCompartmentName</a>()</code>,
<code><a href="#topic+assertCompartmentNew">assertCompartmentNew</a>()</code>,
<code><a href="#topic+assertRxUi">assertRxUi</a>()</code>,
<code><a href="#topic+assertVariableExists">assertVariableExists</a>()</code>,
<code><a href="#topic+assertVariableNew">assertVariableNew</a>()</code>,
<code><a href="#topic+testRxUnbounded">testRxUnbounded</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>testIniDf(TRUE)
</code></pre>

<hr>
<h2 id='testRxLinCmt'>Test if rxode2 uses linear solved systems</h2><span id='topic+testRxLinCmt'></span><span id='topic+assertRxLinCmt'></span>

<h3>Description</h3>

<p>Test if rxode2 uses linear solved systems
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testRxLinCmt(ui, extra = "", .var.name = .vname(ui))

assertRxLinCmt(ui, extra = "", .var.name = .vname(ui))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="testRxLinCmt_+3A_ui">ui</code></td>
<td>
<p>rxode2 model</p>
</td></tr>
<tr><td><code id="testRxLinCmt_+3A_extra">extra</code></td>
<td>
<p>Extra text to append to the error message (like
&quot;for focei&quot;)</p>
</td></tr>
<tr><td><code id="testRxLinCmt_+3A_.var.name">.var.name</code></td>
<td>
<p>[<code>character(1)</code>]<br />
Name of the checked object to print in assertions. Defaults to
the heuristic implemented in <code><a href="checkmate.html#topic+vname">vname</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if the model uses linear solved systems, FALSE otherwise
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>assertRxLinCmt()</code>: Assert that the rxode2 uses linear solved systems
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
one.cmt &lt;- function() {
  ini({
   ## You may label each parameter with a comment
   tka &lt;- 0.45 # Log Ka
   tcl &lt;- log(c(0, 2.7, 100)) # Log Cl
   ## This works with interactive models
   ## You may also label the preceding line with label("label text")
   tv &lt;- 3.45; label("log V")
   ## the label("Label name") works with all models
   eta.ka ~ 0.6
   eta.cl ~ 0.3
   eta.v ~ 0.1
   add.sd &lt;- 0.7
 })
 model({
   ka &lt;- exp(tka + eta.ka)
   cl &lt;- exp(tcl + eta.cl)
   v &lt;- exp(tv + eta.v)
   linCmt() ~ add(add.sd)
 })
}

testRxLinCmt(one.cmt)

</code></pre>

<hr>
<h2 id='testRxUnbounded'>Test if the rxode2 model has any parameters with user defined boundaries</h2><span id='topic+testRxUnbounded'></span><span id='topic+assertRxUnbounded'></span><span id='topic+warnRxBounded'></span>

<h3>Description</h3>

<p>Test if the rxode2 model has any parameters with user defined boundaries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>testRxUnbounded(ui)

assertRxUnbounded(ui, extra = "", .var.name = .vname(ui))

warnRxBounded(ui, extra = "", .var.name = .vname(ui))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="testRxUnbounded_+3A_ui">ui</code></td>
<td>
<p>rxode2 ui</p>
</td></tr>
<tr><td><code id="testRxUnbounded_+3A_extra">extra</code></td>
<td>
<p>extra information to append to the error message</p>
</td></tr>
<tr><td><code id="testRxUnbounded_+3A_.var.name">.var.name</code></td>
<td>
<p>variable name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>boolean indicating if any parameters have user defined boundaries
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>assertRxUnbounded()</code>: Assert that the rxode2 model has any parameters with user defined boundaries
</p>
</li>
<li> <p><code>warnRxBounded()</code>: Warn that the rxode2 model has any parameters with user defined boundaries
</p>
</li></ul>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>See Also</h3>

<p>Other Assertions: 
<code><a href="#topic+assertCompartmentExists">assertCompartmentExists</a>()</code>,
<code><a href="#topic+assertCompartmentName">assertCompartmentName</a>()</code>,
<code><a href="#topic+assertCompartmentNew">assertCompartmentNew</a>()</code>,
<code><a href="#topic+assertRxUi">assertRxUi</a>()</code>,
<code><a href="#topic+assertVariableExists">assertVariableExists</a>()</code>,
<code><a href="#topic+assertVariableNew">assertVariableNew</a>()</code>,
<code><a href="#topic+testIniDf">testIniDf</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
one.cmt &lt;- function() {
  ini({
    tka &lt;- 0.45; label("Ka")
    tcl &lt;- log(c(0, 2.7, 100)); label("Cl")
    tv &lt;- 3.45; label("V")
    eta.ka ~ 0.6
    eta.cl ~ 0.3
    eta.v ~ 0.1
    add.sd &lt;- 0.7
  })
  model({
    ka &lt;- exp(tka + eta.ka)
    cl &lt;- exp(tcl + eta.cl)
    v &lt;- exp(tv + eta.v)
    linCmt() ~ add(add.sd)
  })
}

testRxUnbounded(one.cmt)

try(assertRxUnbounded(one.cmt))

warnRxBounded(one.cmt)
</code></pre>

<hr>
<h2 id='toTrialDuration'>Convert event data to trial duration data
A helper function to create a custom event table.
The observation time will start from the first event time (baseline) and end at trial duration.
The interval is the spacing between each observation.</h2><span id='topic+toTrialDuration'></span>

<h3>Description</h3>

<p>Convert event data to trial duration data
A helper function to create a custom event table.
The observation time will start from the first event time (baseline) and end at trial duration.
The interval is the spacing between each observation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>toTrialDuration(ev, trialEnd, interval, writeDir = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="toTrialDuration_+3A_ev">ev</code></td>
<td>
<p>event data</p>
</td></tr>
<tr><td><code id="toTrialDuration_+3A_trialend">trialEnd</code></td>
<td>
<p>extend trial duration. Must be same time unit as event data</p>
</td></tr>
<tr><td><code id="toTrialDuration_+3A_interval">interval</code></td>
<td>
<p>observation interval. Must be same time unit as event data</p>
</td></tr>
<tr><td><code id="toTrialDuration_+3A_writedir">writeDir</code></td>
<td>
<p>if not NULL, write the output to a csv file</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Omar Elashkar
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # Create event table with unique time for each ID
 ev = et(data.frame(id = rep(1:10, 3),  time = runif(min = 10, max = 20, n = 30)))

 # select the duration and spacing interval (assuming time is in years)
 toTrialDuration(ev, trialEnd = 1.5, interval = 0.2)

</code></pre>

<hr>
<h2 id='update.rxUi'>Update for rxUi</h2><span id='topic+update.rxUi'></span>

<h3>Description</h3>

<p>Update for rxUi
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rxUi'
update(object, ..., envir = parent.frame())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update.rxUi_+3A_object">object</code></td>
<td>
<p>rxode2 UI object</p>
</td></tr>
<tr><td><code id="update.rxUi_+3A_...">...</code></td>
<td>
<p>Lines to update</p>
</td></tr>
<tr><td><code id="update.rxUi_+3A_envir">envir</code></td>
<td>
<p>Environment for evaluating ini() style calls</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a new rxode2 updated UI object
</p>

<hr>
<h2 id='uppergamma'>uppergamma:  upper incomplete gamma function</h2><span id='topic+uppergamma'></span>

<h3>Description</h3>

<p>This is the tgamma from the boost library
</p>


<h3>Usage</h3>

<pre><code class='language-R'>uppergamma(a, z)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="uppergamma_+3A_a">a</code></td>
<td>
<p>The numeric 'a' parameter in the upper
incomplete gamma</p>
</td></tr>
<tr><td><code id="uppergamma_+3A_z">z</code></td>
<td>
<p>The numeric 'z' parameter in the upper
incomplete gamma</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The uppergamma function is given by:
</p>
<p><code class="reqn">uppergamma(a, z) = \int_{z}^{\infty}t^{a-1}\cdot e^{-t} dt</code>
</p>


<h3>Value</h3>

<p>uppergamma results
</p>


<h3>Author(s)</h3>

<p>Matthew L. Fidler
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
uppergamma(1, 3)

uppergamma(1:3, 3)

uppergamma(1, 1:3)
</code></pre>

<hr>
<h2 id='zeroRe'>Set random effects and residual error to zero</h2><span id='topic+zeroRe'></span>

<h3>Description</h3>

<p>Set random effects and residual error to zero
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zeroRe(object, which = c("omega", "sigma"), fix = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="zeroRe_+3A_object">object</code></td>
<td>
<p>The model to modify</p>
</td></tr>
<tr><td><code id="zeroRe_+3A_which">which</code></td>
<td>
<p>The types of parameters to set to zero</p>
</td></tr>
<tr><td><code id="zeroRe_+3A_fix">fix</code></td>
<td>
<p>Should the parameters be fixed to the zero value?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>object</code> with some parameters set to zero
</p>


<h3>Author(s)</h3>

<p>Bill Denney
</p>


<h3>See Also</h3>

<p>Other Initial conditions: 
<code><a href="#topic+ini.rxUi">ini.rxUi</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>one.compartment &lt;- function() {
  ini({
    tka &lt;- log(1.57); label("Ka")
    tcl &lt;- log(2.72); label("Cl")
    tv &lt;- log(31.5); label("V")
    eta.ka ~ 0.6
    eta.cl ~ 0.3
    eta.v ~ 0.1
    add.sd &lt;- 0.7
  })
  model({
    ka &lt;- exp(tka + eta.ka)
    cl &lt;- exp(tcl + eta.cl)
    v &lt;- exp(tv + eta.v)
    d/dt(depot) = -ka * depot
    d/dt(center) = ka * depot - cl / v * center
    cp = center / v
    cp ~ add(add.sd)
  })
}
zeroRe(one.compartment)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
