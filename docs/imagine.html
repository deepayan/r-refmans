<!DOCTYPE html><html lang="en"><head><title>Help for package imagine</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {imagine}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#imagine-package'><p>IMAGing engINE, Tools for application of image filters to data matrices</p></a></li>
<li><a href='#agenbagFilters'><p>Performs algorithms from Agenbag et al. (2003)</p></a></li>
<li><a href='#contextualMF'><p>Performs Contextual Median Filter</p></a></li>
<li><a href='#convolution2D'><p>Make convolution calculations from numeric matrix</p></a></li>
<li><a href='#meanFilter'><p>Make a 2D filter calculations from numeric matrix</p></a></li>
<li><a href='#wbImage'><p>Data matrix to be used as example image.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>IMAGing engINEs, Tools for Application of Image Filters to Data
Matrices</td>
</tr>
<tr>
<td>Version:</td>
<td>2.1.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-01-13</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/LuisLauM/imagine">https://github.com/LuisLauM/imagine</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/LuisLauM/imagine/issues">https://github.com/LuisLauM/imagine/issues</a></td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Wencheng Lau-Medrano &lt;luis.laum@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides fast application of image filters to data matrices,
    using R and C++ algorithms.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-13 17:35:36 UTC; llaumedr</td>
</tr>
<tr>
<td>Author:</td>
<td>Wencheng Lau-Medrano [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-13 17:50:14 UTC</td>
</tr>
</table>
<hr>
<h2 id='imagine-package'>IMAGing engINE, Tools for application of image filters to data matrices</h2><span id='topic+imagine'></span><span id='topic+imagine-package'></span>

<h3>Description</h3>

<p>Provides fast application of image filters to data matrices,
using R and C++ algorithms.
</p>


<h3>Details</h3>

<p>This package uses C++ algorithms called 'engines'. More details are
shown in the vignette.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Wencheng Lau-Medrano <a href="mailto:luis.laum@gmail.com">luis.laum@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/LuisLauM/imagine">https://github.com/LuisLauM/imagine</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/LuisLauM/imagine/issues">https://github.com/LuisLauM/imagine/issues</a>
</p>
</li></ul>


<hr>
<h2 id='agenbagFilters'>Performs algorithms from Agenbag et al. (2003)</h2><span id='topic+agenbagFilters'></span>

<h3>Description</h3>

<p>This function performs two (gradient) calculation approaches for
SST, as outlined in the paper by Agenbag et al. (2003).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>agenbagFilters(X, algorithm = c(1, 2), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="agenbagFilters_+3A_x">X</code></td>
<td>
<p>A numeric <code>matrix</code> used as main input.</p>
</td></tr>
<tr><td><code id="agenbagFilters_+3A_algorithm">algorithm</code></td>
<td>
<p><code>integer</code> specifying the type of method that will be
used. See Details.</p>
</td></tr>
<tr><td><code id="agenbagFilters_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Section 2.2.4 of the paper by Agenbag et al. (2003) introduces the following
two methods:
</p>

<dl>
<dt><strong>Method 1: </strong></dt><dd><p>Based on the equation
</p>
<p style="text-align: center;"><code class="reqn">Y_{i,j}=\sqrt{(X_{i+1,j}-X_{i-1,j})^2 +(X_{i,j+1}-X_{i,j-1})^2}</code>
</p>
</dd>
</dl>
<p>where <code class="reqn">Y_{i,j}</code> represents the output value for each <code class="reqn">X_{i,j}</code> pixel value
of a given <code class="reqn">X</code> matrix.
</p>
<dl>
<dt><strong>Method 2: </strong></dt><dd><p>the standard deviation in a 3x3 pixel area centered on
position <code class="reqn">(i,j)</code>.</p>
</dd>
</dl>

<p>As outlined in the original study, this method conducts searches within a
1-pixel vicinity of each point. For method 1, it only returns a value for
points where none of the four involved values are NA. Conversely, for method
2, the standard deviation calculation is performed only for points where at
least 3 non-NA values are found in the 3x3 neighborhood.
</p>


<h3>Value</h3>

<p><code>agenbagFilters</code> returns a <code>matrix</code> object with the same
dimensions of <code>X</code>.
</p>


<h3>References</h3>

<p>Agenbag, J.J., A.J. Richardson, H. Demarcq, P. Freon, S. Weeks,
and F.A. Shillington. &quot;Estimating Environmental Preferences of South African
Pelagic Fish Species Using Catch Size- and Remote Sensing Data&quot;. Progress in
Oceanography 59, No 2-3 (October 2003): 275-300.
(<a href="https://doi.org/10.1016/j.pocean.2003.07.004">doi:10.1016/j.pocean.2003.07.004</a>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wbImage)

# Agenbag, method 1
agenbag1 &lt;- agenbagFilters(X = wbImage, algorithm = 1)

# Agenbag, method 2
agenbag2 &lt;- agenbagFilters(X = wbImage, algorithm = 2)

# Plotting results
par(mfrow = c(3, 1), mar = rep(0, 4))

# Original
image(wbImage, axes = FALSE, col = gray.colors(n = 1e3))

# Calculated
cols &lt;- hcl.colors(n = 1e3, palette = "YlOrRd", rev = TRUE)
image(agenbag1, axes = FALSE, col = cols)
image(agenbag2, axes = FALSE, col = cols)
</code></pre>

<hr>
<h2 id='contextualMF'>Performs Contextual Median Filter</h2><span id='topic+contextualMF'></span>

<h3>Description</h3>

<p>This function implements the Contextual Median Filter (CMF)
algorithm, which was first described by Belkin &amp; O'Reilly (2009), following
the pseudocode provided in their paper.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contextualMF(X)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="contextualMF_+3A_x">X</code></td>
<td>
<p>A numeric <code>matrix</code> object used for apply filters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Following the definition of CMF, since <strong>imagine</strong> v.2.0.0, <code>times</code>
argument will not be available anymore.
</p>
<p><strong>imagine</strong> offers the CMF algorithm but for the using to find out
oceanographic fronts, it is recommended to see and use the functions of the
<a href="https://CRAN.R-project.org/package=grec"><strong>grec</strong></a> package.
</p>


<h3>Value</h3>

<p><code>contextualMF</code> returns a <code>matrix</code> object with the same
dimensions of <code>X</code>.
</p>


<h3>References</h3>

<p>Belkin, I. M., &amp; O'Reilly, J. E. (2009). An algorithm for oceanic
front detection in chlorophyll and SST satellite imagery. Journal of Marine
Systems, 78(3), 319-326 (<a href="https://doi.org/10.1016/j.jmarsys.2008.11.018">doi:10.1016/j.jmarsys.2008.11.018</a>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wbImage)

cmfOut &lt;- contextualMF(X = wbImage)

# image(cmfOut)
</code></pre>

<hr>
<h2 id='convolution2D'>Make convolution calculations from numeric matrix</h2><span id='topic+convolution2D'></span><span id='topic+convolutionQuantile'></span><span id='topic+convolutionMedian'></span>

<h3>Description</h3>

<p>This function takes a <code>matrix</code> object, and for each cell
multiplies its neighborhood by the <code>kernel</code>. Finally, it returns for
each cell the mean of the kernel-weighted sum.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convolution2D(X, kernel, times = 1, normalize = FALSE, na_only = FALSE)

convolutionQuantile(
  X,
  kernel,
  probs,
  times = 1,
  normalize = FALSE,
  na_only = FALSE
)

convolutionMedian(X, kernel, times = 1, na_only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="convolution2D_+3A_x">X</code></td>
<td>
<p>A numeric <code>matrix</code> object used for apply filters.</p>
</td></tr>
<tr><td><code id="convolution2D_+3A_kernel">kernel</code></td>
<td>
<p>A little matrix used as mask for each cell of <code>X</code>.</p>
</td></tr>
<tr><td><code id="convolution2D_+3A_times">times</code></td>
<td>
<p>How many times do you want to apply the filter?</p>
</td></tr>
<tr><td><code id="convolution2D_+3A_normalize">normalize</code></td>
<td>
<p><code>logical</code> indicating if results will (or not) be
normalized. See details.</p>
</td></tr>
<tr><td><code id="convolution2D_+3A_na_only">na_only</code></td>
<td>
<p><code>logical</code>, Do you want to apply the filter ONLY in cells
with NA?</p>
</td></tr>
<tr><td><code id="convolution2D_+3A_probs">probs</code></td>
<td>
<p><code>numeric</code> vector of probabilities with values in [0,1].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Convolution is a mathematical operation that combines two arrays of numbers
to produce an array of the same structure. The output will consist of only
valid values, meaning those where both arrays have non-missing data.
Consequently, any missing values (NAs) in the input matrix will propagate
outwards to the extent of the convolution kernel.
</p>
<p>Through normalization, the output of each convolution window is scaled by
dividing it by the sum of the absolute values of the kernel
(<code>sum(abs(as.numeric(kernel)))</code>, disabled by default).
</p>
<p><code>na_only</code> performs two actions at once: (1) it applies the filter only in
the positions where the original value is <code>NA</code> and (2) for the rest of
the cells, it is replaced with the value of the original matrix.
</p>


<h3>Value</h3>

<p><code>convolution2D</code> returns a <code>matrix</code> object with the same
dimensions of <code>X</code>.
</p>
<p><code>convolutionQuantile</code> uses the kernel but, for each cell, it
returns the position of quantile 'probs' (value between 0 and 1).
</p>
<p><code>convolutionMedian</code> is a wrapper of <code>convolutionQuantile</code>
with probs = 0.5.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate example matrix
nRows &lt;- 50
nCols &lt;- 100

myMatrix &lt;- matrix(runif(nRows*nCols, 0, 100), nrow = nRows, ncol = nCols)
kernel &lt;- diag(3)

# Make convolution
myOutput1 &lt;- convolution2D(myMatrix, kernel)
myOutput2 &lt;- convolutionQuantile(myMatrix, kernel, probs = 0.7)

# Plot results
par(mfrow = c(2, 2))
image(myMatrix, zlim = c(0, 100))
image(myOutput1, zlim = c(0, 100))
image(myOutput2, zlim = c(0, 100))
</code></pre>

<hr>
<h2 id='meanFilter'>Make a 2D filter calculations from numeric matrix</h2><span id='topic+meanFilter'></span><span id='topic+quantileFilter'></span><span id='topic+medianFilter'></span>

<h3>Description</h3>

<p>This functions take a <code>matrix</code> object, and for each cell
calculate mean, median or certain quantile around a squared/rectangular
neighborhood.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>meanFilter(X, radius, times = 1, na_only = FALSE)

quantileFilter(X, radius, probs, times = 1, na_only = FALSE)

medianFilter(X, radius, times = 1, na_only = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="meanFilter_+3A_x">X</code></td>
<td>
<p>A numeric <code>matrix</code> object used for apply filters.</p>
</td></tr>
<tr><td><code id="meanFilter_+3A_radius">radius</code></td>
<td>
<p>Size of squared or rectangular kernel to apply median. See
Details.</p>
</td></tr>
<tr><td><code id="meanFilter_+3A_times">times</code></td>
<td>
<p>How many times do you want to apply the filter?</p>
</td></tr>
<tr><td><code id="meanFilter_+3A_na_only">na_only</code></td>
<td>
<p><code>logical</code>, Do you want to apply the filter ONLY in cells
with NA?</p>
</td></tr>
<tr><td><code id="meanFilter_+3A_probs">probs</code></td>
<td>
<p><code>numeric</code> vector of probabilities with values in [0,1].</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>radius</code> must be defined as a 2-length numeric vector
specifying the number of rows and columns of the window which will be used to
make calculations. If the length of radius is 1, the window will be a square.
</p>
<p>Functions use C++ algorithms for running some statistical calculations. The
mean is far obvious, however, there are several ways to perform quantiles.
<code>quantileFilter</code> function uses
<a href="https://arma.sourceforge.net/docs.html#quantile">arma::quantile</a>: a
RcppArmadillo function, which is equivalent to use R <a href="stats.html#topic+quantile">quantile</a>
funtion with <code>type = 5</code>.
</p>
<p><code>medianFilter</code> is a wraper of <code>quantileFilter</code>, so the same
observations are applied to it.
</p>
<p><code>na_only</code> performs two actions at once: (1) it applies the filter only in
the positions where the original value is <code>NA</code> and (2) for the rest of
the cells, it is replaced with the value of the original matrix.
</p>


<h3>Value</h3>

<p>A <code>matrix</code> object with the same dimensions of <code>X</code>.
</p>
<p><code>quantileFilter</code> don't use a kernel but, for each cell, it
returns the position of quantile 'probs' (value between 0 and 1).
</p>
<p><code>medianFilter</code> is a wrapper of <code>quantileFilter</code> with
<code>probs = 0.5</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Generate example matrix
nRows &lt;- 50
nCols &lt;- 100

myMatrix &lt;- matrix(runif(nRows*nCols, 0, 100), nrow = nRows, ncol = nCols)
radius &lt;- 3

# Make convolution
myOutput1 &lt;- meanFilter(X = myMatrix, radius = radius)
myOutput2 &lt;- quantileFilter(X = myMatrix, radius = radius, probs = 0.1)
myOutput3 &lt;- medianFilter(X = myMatrix, radius = radius)

# Plot results
par(mfrow = c(2, 2))
image(myMatrix, zlim = c(0, 100), title = "Original")
image(myOutput1, zlim = c(0, 100), title = "meanFilter")
image(myOutput2, zlim = c(0, 100), title = "quantileFilter")
image(myOutput3, zlim = c(0, 100), title = "medianFilter")
</code></pre>

<hr>
<h2 id='wbImage'>Data matrix to be used as example image.</h2><span id='topic+wbImage'></span>

<h3>Description</h3>

<p><code>matrix</code> object containing numeric data to plot a image.
The photo was taken by the author on 2016.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>wbImage
</code></pre>


<h3>Format</h3>

<p>A <code>matrix</code> with dimensions 1280x720.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
