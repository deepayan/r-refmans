<!DOCTYPE html><html><head><title>Help for package baffle</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {baffle}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#baffle-package'><p>Baffle: Waffle graphs with base graphics</p></a></li>
<li><a href='#rasters'><p>Plot raster image</p></a></li>
<li><a href='#recycle_dots'><p>Recycle dots args</p></a></li>
<li><a href='#round_rect'><p>Plot a rectangle with rounded corners</p></a></li>
<li><a href='#Shapes'><p>Plot convex polygons</p></a></li>
<li><a href='#waffle'><p>Make a waffle chart.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Make Waffle Plots with Base Graphics</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Waffle plots are rectangular pie charts that represent a quantity or abundances using
    colored squares or other symbol. This makes them better at transmitting information as the
    discrete number of squares is easier to read than the circular area of pie charts.
    While the original waffle charts were rectangular with 10 rows and columns, with a single square
    representing 1%, they are nowadays popular in various infographics to visualize any
    proportional ratios.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0), knitr, rmarkdown, png</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://j-moravec.github.io/baffle/">https://j-moravec.github.io/baffle/</a>,
<a href="https://github.com/j-moravec/baffle">https://github.com/j-moravec/baffle</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/j-moravec/baffle/issues">https://github.com/j-moravec/baffle/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-25 12:20:05 UTC; jmoravec</td>
</tr>
<tr>
<td>Author:</td>
<td>Jiří Moravec [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jiří Moravec &lt;jiri.c.moravec@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-25 12:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='baffle-package'>Baffle: Waffle graphs with base graphics</h2><span id='topic+baffle'></span><span id='topic+baffle-package'></span>

<h3>Description</h3>

<p>The package provides functions to make waffle graphs in the base graphics.
</p>


<h3>Details</h3>

<p>Waffle plots are rectangular pie charts that represent a quantity or abundances using
colored squares or other symbol. This makes them better at transmitting information as the
discrete number of squares is easier to read than the circular area of pie charts.
While the original waffle charts were rectangular with 10 rows and columns, with a single square
representing 1
proportional ratios.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Jiří Moravec <a href="mailto:jiri.c.moravec@gmail.com">jiri.c.moravec@gmail.com</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://j-moravec.github.io/baffle/">https://j-moravec.github.io/baffle/</a>
</p>
</li>
<li> <p><a href="https://github.com/j-moravec/baffle">https://github.com/j-moravec/baffle</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/j-moravec/baffle/issues">https://github.com/j-moravec/baffle/issues</a>
</p>
</li></ul>


<hr>
<h2 id='rasters'>Plot raster image</h2><span id='topic+rasters'></span>

<h3>Description</h3>

<p>Plot raster image centered at 'x' and 'y' coordinates scaled to diameter 'd'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasters(x, y, image, d = 0.9, dx = NA, dy = NA, rotate = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rasters_+3A_x">x</code>, <code id="rasters_+3A_y">y</code></td>
<td>
<p>coordinates</p>
</td></tr>
<tr><td><code id="rasters_+3A_image">image</code></td>
<td>
<p>raster image</p>
</td></tr>
<tr><td><code id="rasters_+3A_d">d</code></td>
<td>
<p>**optional** diameter, see details</p>
</td></tr>
<tr><td><code id="rasters_+3A_dx">dx</code>, <code id="rasters_+3A_dy">dy</code></td>
<td>
<p>**optional** diameter in either coordinate direction</p>
</td></tr>
<tr><td><code id="rasters_+3A_rotate">rotate</code></td>
<td>
<p>**optional** clockwise rotation in degrees (0-360°)</p>
</td></tr>
<tr><td><code id="rasters_+3A_...">...</code></td>
<td>
<p>**optional** other parameters passed to [graphics::rasterImage()],
such as 'interpolate'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 'rasters()' function is a convenient wrapper around [graphics::rasterImage()] with similar
interface to the [Shapes] functions available in this package (such as [square()], [circle()]
and [rcpoly()]).
</p>
<p>The raster image is plotted centered at the 'x' and 'y' coordinates and scaled to the diameter
size 'd'. When 'dx' and 'dy' are 'NA', the proportions of the raster are kept unchanged,
otherwise they are scaled to the specified size in either direction. This scaling is done
before rotation.
</p>
<p>Unlike in 'rasterImage', the rotation is performed clockwise and the rotation axis is the center
of the raster (i.e., the provided x and y coordinates), rather than the bottom left coordinate
'x0'. This rotation is performed after scaling.
</p>
<p>As of yet, the rotation is accurate only when the aspect ratio is set to 1 ('asp=1') through
the 'graphics::plot.window()' call.
</p>
<p>The 'rasters()' function is fully vectorized.
</p>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>See Also</h3>

<p>[grDevices::as.raster()] and [graphics::rasterImage()]
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create plotting window
plot.new(); plot.window(c(-1,1), c(-1,1), asp=1); axis(1); axis(2)

# create raster image, alpha is convenient when overplotting
img = matrix(adjustcolor("black", alpha.f=0.3), 3, 3)
img[2, 2] = adjustcolor("white", alpha.f=0.3)
img = as.raster(img)

rasters(0, 0, img)

# interpolate=FALSE makes quite a difference
rasters(0, 0, img, interpolate=FALSE)

# arguments are vectorized, standard recycling rules apply
rasters(0, 0, img, interpolate=FALSE, rotate=c(30, 60, 90))
rasters(c(-1, -0.5,  0.5, 1), c(1, 0.5, -0.5, -1), img, interpolate=FALSE)

</code></pre>

<hr>
<h2 id='recycle_dots'>Recycle dots args</h2><span id='topic+recycle_dots'></span>

<h3>Description</h3>

<p>Recycle dots args
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recycle_dots(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recycle_dots_+3A_x">x</code></td>
<td>
<p>an integer vector, typically with values ranging from 1 to n, with each integer
with each integer specifying an index of element for each item in '...'</p>
</td></tr>
<tr><td><code id="recycle_dots_+3A_...">...</code></td>
<td>
<p>additional arguments, if length of item of '...' is larger than one, its elements are
is recycled according to indiced specified by the vector 'x'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>recycled arguments of '...'
</p>

<hr>
<h2 id='round_rect'>Plot a rectangle with rounded corners</h2><span id='topic+round_rect'></span>

<h3>Description</h3>

<p>Plot one or more rectangles with rounded corners.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>round_rect(x1, y1, x2, y2, xr = 0.2, yr = 0.2, n = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="round_rect_+3A_x1">x1</code>, <code id="round_rect_+3A_y1">y1</code></td>
<td>
<p>x and y coordinates of the bottom left corner</p>
</td></tr>
<tr><td><code id="round_rect_+3A_x2">x2</code>, <code id="round_rect_+3A_y2">y2</code></td>
<td>
<p>x and y coordinates of the top right corner</p>
</td></tr>
<tr><td><code id="round_rect_+3A_xr">xr</code>, <code id="round_rect_+3A_yr">yr</code></td>
<td>
<p>the proportion of length of a side of the rectangle, from which the rounded corners
start. Values between 0 and 1 are permitted. See details.</p>
</td></tr>
<tr><td><code id="round_rect_+3A_n">n</code></td>
<td>
<p>the number of points used to approximate the curvature of the rounded corner</p>
</td></tr>
<tr><td><code id="round_rect_+3A_...">...</code></td>
<td>
<p>other parameters passed to [graphics::polygon()].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rounded corner is a part of a circle (one quarter) drawn between two points of neighbouring
sides of a rectangle. The relative position of these two points determine how rounded will the
final shape be. The position of these points is determined by the parameters 'xr' and 'yr',
which determine the proportion of side x and y, from which the rounded corner is drawn.
Values between 0 and 1 are permitted, but given the symmetricity of a rectangle, values  larger
than 0.5 are reflected back (modulo 0.5). When both xr and yr are 0 or 1, normal rectangle
without rounded corners is drawn. When xr and yr are 0.5, ellipsis is drawn.
</p>


<h3>Value</h3>

<p>No return value, called for side effects
</p>

<hr>
<h2 id='Shapes'>Plot convex polygons</h2><span id='topic+Shapes'></span><span id='topic+square'></span><span id='topic+rectangle'></span><span id='topic+rounded_square'></span><span id='topic+rounded_rectangle'></span><span id='topic+circle'></span><span id='topic+ellipse'></span><span id='topic+rcpoly'></span><span id='topic+shapes'></span>

<h3>Description</h3>

<p>A collection of functions for plotting polygonal shapes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>square(x, y, d = 0.9, ...)

rectangle(x, y, d = 0.9, dx = d, dy = d, ...)

rounded_square(x, y, d = 0.9, r = 0.2, n = 10, ...)

rounded_rectangle(
  x,
  y,
  d = 0.9,
  dx = d,
  dy = d,
  r = 0.2,
  rx = r,
  ry = r,
  n = 10,
  ...
)

circle(x, y, d = 0.9, n = 1000, ...)

ellipse(x, y, d = 0.9, dx = d, dy = d, n = 1000, ...)

rcpoly(x, y, n, d = 0.9, rotate = 0, ...)

shapes(x, y, n, d = 0.9, dx = d, dy = d, rotate = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Shapes_+3A_x">x</code>, <code id="Shapes_+3A_y">y</code></td>
<td>
<p>coordinates</p>
</td></tr>
<tr><td><code id="Shapes_+3A_d">d</code></td>
<td>
<p>**optional** diameter, see details</p>
</td></tr>
<tr><td><code id="Shapes_+3A_...">...</code></td>
<td>
<p>**optional** graphical parameters 'col', 'border', 'lty' and 'lwd' passed to
[graphics::polygon()] or [graphics::rect()]</p>
</td></tr>
<tr><td><code id="Shapes_+3A_dx">dx</code>, <code id="Shapes_+3A_dy">dy</code></td>
<td>
<p>**optional** diameter in either coordinate direction</p>
</td></tr>
<tr><td><code id="Shapes_+3A_r">r</code>, <code id="Shapes_+3A_rx">rx</code>, <code id="Shapes_+3A_ry">ry</code></td>
<td>
<p>**optional** for rounded corner, the proportion of side marking the start of
rounded corner.</p>
</td></tr>
<tr><td><code id="Shapes_+3A_n">n</code></td>
<td>
<p>the number of vertices of polygon, with the minimum of three (triangle). Large 'n', such
as &lsquo;n=1000' approximate circle. The vertices start at the 12 o&rsquo;clock position and are placed
clockwise in a regular intervals. For 'rounded_square' and 'rounded_rectangle', the number of
vertices that approximate the circular shape of the rounded corners. Small 'n', such as
'n=10' should have sufficient smoothness for most applications.</p>
</td></tr>
<tr><td><code id="Shapes_+3A_rotate">rotate</code></td>
<td>
<p>**optional** clockwise rotation in degrees (0-360°),
not available for 'square' and 'rectangle'</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Polygons are drawn centered on the 'x' and 'y' coordinates, with a diameter 'd'
(or 'dx' and 'dy'). Typically, different shapes are obtained through a parametrization
of the 'shapes()' function, which draws a convex polygon using the [graphics::polygon()],
with the exception of 'square()' and 'rectangle()' function, which use the [graphics::rect()]
function instead, behave slightly differently, and should be slightly faster, and the
'rounded_square()' and 'rounded_rectangle()', which use 'round_rect()' function.
</p>
<p>The diameter parameter 'd' is interpreted differently depending for 'square()' and 'rectangle()'
and for other polygonal functions build on the 'shapes()' function ('circle()', 'ellipse()'
and 'rcpoly()'). For the 'square()' and 'rectangle()', the diameter is the size of the square,
'd=1' thus fills the whole 1x1 tile. For 'shapes()' function, 'd' is the diameter
of the inscribed circle to the square of size 'd'. This is more convenient solution to prevent
accidental overplotting when individual shapes are plotted next to each other in regular
intervals, the distance between such points would be equal to the diameter in both cases.
See examples.
</p>
<p>All shapes function accept the graphical parameters 'col', 'border', 'lty' and 'lwd', which
are passed to the [graphics::polygon()] and [graphics::rect()]. Apart of a different default
values, they behave in the same way.
</p>
<p>All parameters are vectorized and will recycle as required, with the typical warning if
parameters are not multiply of each other. This can be used to create pleasant geometric images.
See examples.
</p>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>square()</code>: draw squares
</p>
</li>
<li> <p><code>rectangle()</code>: draw rectangles
</p>
</li>
<li> <p><code>rounded_square()</code>: draw squares with rounded corners
</p>
</li>
<li> <p><code>rounded_rectangle()</code>: draw rectangles with rounded corners
</p>
</li>
<li> <p><code>circle()</code>: draw circles
</p>
</li>
<li> <p><code>ellipse()</code>: draw ellipses
</p>
</li>
<li> <p><code>rcpoly()</code>: draw regular convex polygons
</p>
</li>
<li> <p><code>shapes()</code>: draw convex polygons
</p>
</li></ul>


<h3>See Also</h3>

<p>[graphics::polygon()] and [graphics::rect()] for the underlying plotting functions
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(0, 0) # create plotting window

# Following calls are equivalent
square(0, 0, 1)
rectangle(0, 0, 1)
rectangle(0, 0, dx=1, dy=1)

# Not equivalent to `square`
rcpoly(0, 0, 4, d=1)

# Same output as `square`, but not equivalent
rcpoly(0, 0, 4, d=sqrt(2), rotate=45)

# Vectorizing parameters
plot(0, 0)
rotate = seq(0, 18, by=30)
d = seq(1, by=-0.1, length.out = length(rotate))
rcpoly(0,0,3, border="red", lwd=3, rotate=rotate, d=d)

</code></pre>

<hr>
<h2 id='waffle'>Make a waffle chart.</h2><span id='topic+waffle'></span><span id='topic+waffle.mat'></span><span id='topic+design'></span>

<h3>Description</h3>

<p>Waffle chart is a pie chart that visually represents abundances with the number of squares.
The waffle chart consists of squares plotted on a rectangular lattice according to a design
matrix that is constructed from a vector of abundances or can be provided directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>waffle(
  x,
  f = NULL,
  ...,
  nrow = NULL,
  ncol = NULL,
  byrow = TRUE,
  from = "bottomleft",
  stacked = TRUE,
  gap = 0,
  horiz = TRUE,
  add = FALSE
)

waffle.mat(x, f = square, ..., add = FALSE)

design(
  x,
  nrow = NULL,
  ncol = NULL,
  byrow = TRUE,
  from = "bottomleft",
  stacked = TRUE,
  horiz = TRUE,
  gap = 0
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="waffle_+3A_x">x</code></td>
<td>
<p>a vector of abundances or a design matrix (see details)</p>
</td></tr>
<tr><td><code id="waffle_+3A_f">f</code></td>
<td>
<p>**optional** a shape function (see details)</p>
</td></tr>
<tr><td><code id="waffle_+3A_...">...</code></td>
<td>
<p>**optional** other parameters passed to the 'f' function</p>
</td></tr>
<tr><td><code id="waffle_+3A_nrow">nrow</code></td>
<td>
<p>**optional** the number of rows</p>
</td></tr>
<tr><td><code id="waffle_+3A_ncol">ncol</code></td>
<td>
<p>**optional** the number of columns</p>
</td></tr>
<tr><td><code id="waffle_+3A_byrow">byrow</code></td>
<td>
<p>**optional** fill matrix by rows or by columns</p>
</td></tr>
<tr><td><code id="waffle_+3A_from">from</code></td>
<td>
<p>**optional** starting position from which the matrix is filled, one of
&quot;bottomleft&quot;, &quot;bottomright&quot;, &quot;topleft&quot; or &quot;topright&quot;.</p>
</td></tr>
<tr><td><code id="waffle_+3A_stacked">stacked</code></td>
<td>
<p>**optional** if FALSE, produce an unstacked waffle chart, see details</p>
</td></tr>
<tr><td><code id="waffle_+3A_gap">gap</code></td>
<td>
<p>**optional** gap between unstacked subwaffles, works only for unstacked waffle charts</p>
</td></tr>
<tr><td><code id="waffle_+3A_horiz">horiz</code></td>
<td>
<p>**optional** if FALSE, vertical instead of horizontal waffle chart is produced,
works only for unstacked waffle charts</p>
</td></tr>
<tr><td><code id="waffle_+3A_add">add</code></td>
<td>
<p>**optional** whether to add to a current plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The 'waffle()' function accepts a vector of abundances and plots a waffle chart.
This is done by first constructing a design matrix using the 'design()' function,
which is then parsed to the 'waffle.mat()' function.
</p>
<p>The 'design()' functions construct a design matrix according.
The design matrix is filled by an integer vector derived from the abundance vector 'x'.
Each integer correspond to the order of abundances in 'x', with the quantity equal to the value
in 'x'. This means that for the 'x=c(3,5)', the design matrix will be filled with three '1'
and five '2', all other cells of the design matrix are set as unknown values 'NA'.
</p>
<p>By default, the design matrix is filled by row, starting from the bottom left corner,
this can be changed by setting the variables 'byrow' and 'from'.
By setting 'byrow=FALSE', the matrix is filled by columns first.
</p>
<p>If 'ncol' or 'nrow' is not specified, a squared matrix that will fit the sum of abundances
will be constructed.
</p>
<p>By default, the design matrix is stacked, i.e., all the elements are placed in a single
matrix object, similarly how barplot produces stacked lines. By specifying 'stack=FALSE',
the 'design()' unstacks the elements, each are then placed in their own matricies, which
are then connected by 'NA' elements of size 'gap'. More complex 
</p>
<p>If the input vector 'x' is a named vector, the names are preserved in the 'levels'
attribute. These levels are not currently used, but might be used in the future
for automatic legend creation and subsetting.
</p>
<p>The function 'waffle.mat()' accepts a custom-made design matrix and thus allows a better
control of colored regions. It is called internally by the 'waffle()' function, which serves
as an easy to use interface for the 'waffle.mat()'. For this reason, the 'waffle.mat()'
does not checks for the validity of input arguments and does not set a default colors.
</p>
<p>The assumed and allocated coordinate system is from '0' to 'ncol' for x and
from '0' to 'ncol' for y. Squares are filled from top right corner of this coordinate
system.
</p>
<p>If 'add=FALSE', a new window with a fixed aspect ratio x/y=1 is allocated so that
plotted polygons are squares (by default). This might cause the plot margins,
and thus the main title, to be quite far away. In this case, plotting the title using 'text()'
instead of 'title()' might be a better idea. In this case, the coordinates might be:
<code>text(x=(ncol+2)/2, y=nrow+1,...)</code>
</p>


<h3>Value</h3>

<p>'design()' returns a design matrix (see details), in addition, if 'x' is a named vector,
the names are preserved in the 'levels' attribute.
'waffle()' and 'waffle.mat()' do not have a return value
</p>


<h3>See Also</h3>

<p>the 'waffle' package for a 'ggplot2' version.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>waffle(c(50,25,25))
waffle(c(25,75), col=c("darkorchid", "lightgray"))
waffle(c(14,8,4), nrow=3)

# custom design matrix with a more complex structure
cols = palette.colors(3, "Set 1")
design_mat = matrix(NA, 7,10)
design_mat[1,] = 1
design_mat[2,1:8] = 1
design_mat[4,] = 2
design_mat[5,1:4] = 2
design_mat[7,1:5] = 3
waffle.mat(design_mat, col=cols)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
