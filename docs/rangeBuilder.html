<!DOCTYPE html><html lang="en"><head><title>Help for package rangeBuilder</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rangeBuilder}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#rangeBuilder'><p>rangeBuilder</p></a></li>
<li><a href='#addRasterLegend'><p>addRasterLegend</p></a></li>
<li><a href='#closestCountry'><p>Return country from point</p></a></li>
<li><a href='#coordError'><p>Coordinate error</p></a></li>
<li><a href='#filterByLand'><p>Filter occurrences based on land vs ocean</p></a></li>
<li><a href='#filterByProximity'><p>Filter by proximity</p></a></li>
<li><a href='#flipSign'><p>Flip sign of coordinates</p></a></li>
<li><a href='#getDynamicAlphaHull'><p>Generate polygon based on alpha hulls</p></a></li>
<li><a href='#getExtentOfList'><p>Get extent of list</p></a></li>
<li><a href='#rangeBuilder-example'><p>rangeBuilder datasets</p></a></li>
<li><a href='#rasterStackFromPolyList'><p>Polygon List to rasterStack</p></a></li>
<li><a href='#standardizeCountry'><p>Standardize country name</p></a></li>
<li><a href='#transparentColor'><p>Define colors with transparency</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Occurrence Filtering, Geographic Standardization and Generation
of Species Range Polygons</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>alphahull (&ge; 2.5), stringi, sf, terra, pbapply, units,
rnaturalearth, methods, Rcpp (&ge; 0.12.9)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides tools for filtering occurrence records, generating alpha-hull-derived range polygons and mapping species distributions. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ptitle/rangeBuilder">https://github.com/ptitle/rangeBuilder</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ptitle/rangeBuilder/issues">https://github.com/ptitle/rangeBuilder/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-30 18:53:03 UTC; pascaltitle</td>
</tr>
<tr>
<td>Author:</td>
<td>Pascal Title <a href="https://orcid.org/0000-0002-6316-0736"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pascal Title &lt;ptitle@umich.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-30 19:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='rangeBuilder'>rangeBuilder</h2><span id='topic+rangeBuilder-package'></span><span id='topic+rangeBuilder'></span>

<h3>Description</h3>

<p>Provides tools for filtering occurrence records, standardizing countries names, 
generating alpha-hull-derived range polygons and mapping species distributions.
</p>


<h3>Author(s)</h3>

<p>Pascal Title &lt;ptitle@umich.edu&gt;
</p>


<h3>References</h3>

<p>Davis Rabosky, A.R., C.L. Cox, D.L. Rabosky, P.O. Title, I.A. Holmes, A. Feldman and J.A. 
McGuire. 2016. Coral snakes predict the evolution of mimicry across New World snakes. Nature 
Communications 7:11484.
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/ptitle/rangeBuilder">https://github.com/ptitle/rangeBuilder</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ptitle/rangeBuilder/issues">https://github.com/ptitle/rangeBuilder/issues</a>
</p>
</li></ul>


<hr>
<h2 id='addRasterLegend'>addRasterLegend</h2><span id='topic+addRasterLegend'></span>

<h3>Description</h3>

<p>Adds a legend to an existing raster plot, with some additional manual control
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addRasterLegend(
  r,
  direction,
  side,
  location = "right",
  nTicks = 2,
  adj = NULL,
  shortFrac = 0.02,
  longFrac = 0.3,
  axisOffset = 0,
  border = TRUE,
  ramp = "terrain",
  isInteger = "auto",
  ncolors = 64,
  breaks = NULL,
  minmax = NULL,
  locs = NULL,
  cex.axis = 0.8,
  labelDist = 0.7,
  digits = 2,
  bigmark = "",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="addRasterLegend_+3A_r">r</code></td>
<td>
<p>the rasterLayer object that has been plotted</p>
</td></tr>
<tr><td><code id="addRasterLegend_+3A_direction">direction</code></td>
<td>
<p>direction of color ramp. If omitted, then direction is automatically 
inferred, otherwise can be specified as <code>horizontal</code> or <code>vertical</code>.</p>
</td></tr>
<tr><td><code id="addRasterLegend_+3A_side">side</code></td>
<td>
<p>side for tick marks, see <code><a href="graphics.html#topic+axis">axis</a></code> documentation. 
Automatically inferred if omitted.</p>
</td></tr>
<tr><td><code id="addRasterLegend_+3A_location">location</code></td>
<td>
<p>either a location name (see <code>Details</code>), or coordinates for 
the corners of the bar legend <code>c(xmin, xmax, ymin, ymax)</code>.</p>
</td></tr>
<tr><td><code id="addRasterLegend_+3A_nticks">nTicks</code></td>
<td>
<p>number of tick marks, besides min and max.</p>
</td></tr>
<tr><td><code id="addRasterLegend_+3A_adj">adj</code></td>
<td>
<p>if location is top, left, bottom or right, use this argument to adjust the 
location of the legend, defined in percent of the figure width. See Details 
for additional information.</p>
</td></tr>
<tr><td><code id="addRasterLegend_+3A_shortfrac">shortFrac</code></td>
<td>
<p>Percent of the plot width range that will be used as the short 
dimention of the legend. Only applies to preset location options.</p>
</td></tr>
<tr><td><code id="addRasterLegend_+3A_longfrac">longFrac</code></td>
<td>
<p>Percent of the plot width range that will be used as the long dimention 
of the legend. Only applies to preset location options.</p>
</td></tr>
<tr><td><code id="addRasterLegend_+3A_axisoffset">axisOffset</code></td>
<td>
<p>distance from color bar for labels, as a percent of the plot width.</p>
</td></tr>
<tr><td><code id="addRasterLegend_+3A_border">border</code></td>
<td>
<p>logical, should the color legend have a black border</p>
</td></tr>
<tr><td><code id="addRasterLegend_+3A_ramp">ramp</code></td>
<td>
<p>either a vector of color names for defining the color ramp, 
or &quot;terrain&quot; (default raster behavior)</p>
</td></tr>
<tr><td><code id="addRasterLegend_+3A_isinteger">isInteger</code></td>
<td>
<p>If <code>auto</code>, automatically determines if raster is made up of integer 
values, otherwise <code>TRUE</code> or <code>FALSE</code></p>
</td></tr>
<tr><td><code id="addRasterLegend_+3A_ncolors">ncolors</code></td>
<td>
<p>grain size of color ramp</p>
</td></tr>
<tr><td><code id="addRasterLegend_+3A_breaks">breaks</code></td>
<td>
<p>If a custom set of color breaks were used in plotting the raster, pass 
those color breaks here. This overrides the minmax option.</p>
</td></tr>
<tr><td><code id="addRasterLegend_+3A_minmax">minmax</code></td>
<td>
<p>min and max values from which the color ramp will be derived. If left
as <code>NULL</code>, the min and max of the raster will be used.</p>
</td></tr>
<tr><td><code id="addRasterLegend_+3A_locs">locs</code></td>
<td>
<p>locations of tick marks, if <code>NULL</code> automatically placed</p>
</td></tr>
<tr><td><code id="addRasterLegend_+3A_cex.axis">cex.axis</code></td>
<td>
<p>size of axis labels</p>
</td></tr>
<tr><td><code id="addRasterLegend_+3A_labeldist">labelDist</code></td>
<td>
<p>distance from axis to axis labels (passed to <code>mgp</code>)</p>
</td></tr>
<tr><td><code id="addRasterLegend_+3A_digits">digits</code></td>
<td>
<p>number of decimal places for labels</p>
</td></tr>
<tr><td><code id="addRasterLegend_+3A_bigmark">bigmark</code></td>
<td>
<p>character used to separate thousands and millions, passed 
to <code><a href="base.html#topic+format">format</a></code></p>
</td></tr>
<tr><td><code id="addRasterLegend_+3A_...">...</code></td>
<td>
<p>additional parameters to be passed to <code><a href="graphics.html#topic+axis">axis</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A number of predefined locations exist in this function to make it easy to 
add a legend to a raster plot. 
Preset <code>locations</code> are: <code>topleft</code>, <code>topright</code>, <code>bottomleft</code>, 
<code>bottomright</code>, <code>left</code>, <code>right</code>, <code>top</code> and <code>bottom</code>. 
If more fine-tuned control is desired, then a numeric vector of length 4 can be 
supplied to <code>location</code>, specifying the min x, max x, min y and max y 
values for the legend. 
Additionally, the <code>adj</code> argument can be used to more intuitively adjust where
the legend is placed. <code>adj</code> is defined as a percentage of the figure width or 
height, left to right, or bottom to top, respectively. For example, if the legend is at 
the bottom, <code>adj = 0.8</code> will place the legend 80
the figure, horizontally centered.  
See examples.
</p>


<h3>Value</h3>

<p>Invisibly returns a list with the following components.
</p>

<ul>
<li><p> coords: 2-column matrix of xy coordinates for each color bin in the legend.
</p>
</li>
<li><p> width: Coordinates for the short dimension of the legend.
</p>
</li>
<li><p> pal: the color ramp
</p>
</li>
<li><p> tickLocs: the tick mark locations in plotting units
</p>
</li>
<li><p> labels: the values associated with those tick locations.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Pascal Title
</p>

<hr>
<h2 id='closestCountry'>Return country from point</h2><span id='topic+closestCountry'></span>

<h3>Description</h3>

<p>Determines which country a given point falls in.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>closestCountry(pt, crs = 4326)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="closestCountry_+3A_pt">pt</code></td>
<td>
<p>longitude and latitude, as a numeric vector, 2-column table,
or spatial points object.</p>
</td></tr>
<tr><td><code id="closestCountry_+3A_crs">crs</code></td>
<td>
<p>the CRS of the coordinate. If <code>pt</code> is a spatial object,
this argument is ignored. The default 4326 indicates longlat unprojected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on a predetermined set of global points, this function finds the country of 
occurrence.
This can be useful for checking the validity of a point by comparing the returned country 
to the country listed with the occurrence record.
If a point falls close to the boundary between two countries, the names of the nearby 
countries are returned.
This function will not be of much value if the point falls in the ocean, as it will 
return the country that is closest, regardless of how far away it is.
</p>


<h3>Value</h3>

<p>If one point is provided, a character vector is returned.
If multiple points are provided, a list of character vectors is returned.
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#point near a country border
closestCountry(c(-115.436, 32.657))

# testing different input options
samp &lt;- sample(1:nrow(crotalus), 10)
xy &lt;- crotalus[samp, c('decimallongitude', 'decimallatitude')]
sfpts &lt;- sf::st_as_sf(xy, coords = c('decimallongitude', 'decimallatitude'), crs = 4326)
sfptsEA &lt;- sf::st_transform(sfpts, crs = '+proj=eqearth')
spPts &lt;- as(sfpts, 'Spatial')
closestCountry(xy)
closestCountry(sfpts)
closestCountry(sfptsEA)
closestCountry(spPts)

</code></pre>

<hr>
<h2 id='coordError'>Coordinate error</h2><span id='topic+coordError'></span>

<h3>Description</h3>

<p>Calculates the potential error in coordinates due to lack of coordinate precision.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coordError(coords, nthreads = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coordError_+3A_coords">coords</code></td>
<td>
<p>longitude and latitude in decimal degrees, either as a long/lat vector, or as 
a 2-column table. Can be either as numeric or character format</p>
</td></tr>
<tr><td><code id="coordError_+3A_nthreads">nthreads</code></td>
<td>
<p>number of threads to use for parallelization of the function. 
The R package <code>parallel</code> must be loaded for <code>nthreads &gt; 1</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function assumes that the true precision of the coordinates is equivalent to the 
greatest number of decimals in either the longitude or latitude that are not trailing 
zeroes. In other words: <br />
<code>(-130.45670, 45.53000)</code> is interpreted as <code>(-130.4567, 45.5300)</code> <br />
<code>(-130.20000, 45.50000)</code> is interpreted as <code>(-130.2, 45.5)</code> <br />
</p>
<p>If we use <code>(-130.45670, 45.53000)</code> as an example, these coordinates are interpreted 
as <code>(-130.4567, 45.5300)</code> and the greatest possible error is inferred as two 
endpoints:
<code>(-130.45670, 45.53000)</code> and <code>(-130.45679, 45.53009)</code> <br />
</p>
<p>The distance between these two is then calculated and returned.
</p>


<h3>Value</h3>

<p>Returns a vector of coordinate error in meters.
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(crotalus)

xy &lt;- crotalus[1:100, c('decimallongitude','decimallatitude')]

coordError(xy)

</code></pre>

<hr>
<h2 id='filterByLand'>Filter occurrences based on land vs ocean</h2><span id='topic+filterByLand'></span>

<h3>Description</h3>

<p>Identifies occurrence records that do not occur on land.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filterByLand(coords, crs = 4326)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filterByLand_+3A_coords">coords</code></td>
<td>
<p>coordinates in the form of a 2 column numeric matrix,
data.frame, numeric vector, or spatial points object (sf or sp). 
If spatial object, crs must be defined.</p>
</td></tr>
<tr><td><code id="filterByLand_+3A_crs">crs</code></td>
<td>
<p>crs of input coords. Ignored if input coords are
spatial object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses a rasterized version of the GSHHG (global
self-consistent, hierarchical, high-resolution geography database,
<a href="https://www.soest.hawaii.edu/pwessel/gshhg/">https://www.soest.hawaii.edu/pwessel/gshhg/</a>), that has been buffered
by 2 km.
</p>


<h3>Value</h3>

<p>returns a logical vector where <code>TRUE</code> means the point falls on
land.
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(crotalus)

#identify points that fall off land
filterByLand(crotalus[,c('decimallongitude','decimallatitude')])


# testing different input options
samp &lt;- sample(1:nrow(crotalus), 10)
xy &lt;- crotalus[samp, c('decimallongitude', 'decimallatitude')]
sfpts &lt;- sf::st_as_sf(xy, coords = c('decimallongitude', 'decimallatitude'), crs = 4326)
sfptsEA &lt;- sf::st_transform(sfpts, crs = '+proj=eqearth')
spPts &lt;- as(sfpts, 'Spatial')
filterByLand(xy)
filterByLand(sfpts)
filterByLand(sfptsEA)
filterByLand(spPts)

</code></pre>

<hr>
<h2 id='filterByProximity'>Filter by proximity</h2><span id='topic+filterByProximity'></span>

<h3>Description</h3>

<p>Filter occurrence records by their proximity to each other.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filterByProximity(xy, dist, returnIndex = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filterByProximity_+3A_xy">xy</code></td>
<td>
<p>longitude and latitude in decimal degrees, either as a matrix,
dataframe, or spatial points object.</p>
</td></tr>
<tr><td><code id="filterByProximity_+3A_dist">dist</code></td>
<td>
<p>minimum allowed distance in km</p>
</td></tr>
<tr><td><code id="filterByProximity_+3A_returnindex">returnIndex</code></td>
<td>
<p>if <code>TRUE</code>, will return indices of points that would
be dropped, if <code>FALSE</code>, returns the points that satisfy the distance
filter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will discard coordinates that fall within a certain distance
from other points.
</p>


<h3>Value</h3>

<p>If <code>returnIndex = TRUE</code>, returns a numeric vector of indices.
If <code>returnIndex = FALSE</code>, returns coordinates of the same class as the
input.
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(crotalus)

# within the first 100 points in the dataset, identify the set of points to 
# drop in order to have points no closer to each other than 20 km

subset &lt;- crotalus[1:100,]
tooClose &lt;- filterByProximity(xy= subset[ ,c('decimallongitude','decimallatitude')], 
	dist=20, returnIndex = TRUE)

plot(subset[ ,c('decimallongitude','decimallatitude')], pch=1, col='blue', cex=1.5)
points(subset[tooClose, c('decimallongitude','decimallatitude')], pch=20, col='red')


# testing different input options
samp &lt;- sample(1:nrow(crotalus), 100)
xy &lt;- crotalus[samp, c('decimallongitude', 'decimallatitude')]
sfpts &lt;- sf::st_as_sf(xy, coords = c('decimallongitude', 'decimallatitude'), crs = 4326)
sfptsEA &lt;- sf::st_transform(sfpts, crs = '+proj=eqearth')
spPts &lt;- as(sfpts, 'Spatial')
filterByProximity(xy, dist=20, returnIndex = TRUE)
filterByProximity(sfpts, dist=20, returnIndex = TRUE)
filterByProximity(sfptsEA, dist=20, returnIndex = TRUE)
filterByProximity(spPts, dist=20, returnIndex = TRUE)

</code></pre>

<hr>
<h2 id='flipSign'>Flip sign of coordinates</h2><span id='topic+flipSign'></span>

<h3>Description</h3>

<p>Checks for coordinate sign mistakes by checking all possibilities against
country occupancy.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flipSign(
  coordVec,
  country,
  returnMultiple = FALSE,
  filterByLand = TRUE,
  crs = 4326
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="flipSign_+3A_coordvec">coordVec</code></td>
<td>
<p>numeric vector of length 2: longitude, latitude</p>
</td></tr>
<tr><td><code id="flipSign_+3A_country">country</code></td>
<td>
<p>the country that is associated with the record</p>
</td></tr>
<tr><td><code id="flipSign_+3A_returnmultiple">returnMultiple</code></td>
<td>
<p>if multiple sign flips lead to the correct country,
return all options.  If <code>FALSE</code>, returns the coords with the fewest
needed sign flips.</p>
</td></tr>
<tr><td><code id="flipSign_+3A_filterbyland">filterByLand</code></td>
<td>
<p>if <code>TRUE</code>, alternative coords will be tested for
whether or not they fall on land.</p>
</td></tr>
<tr><td><code id="flipSign_+3A_crs">crs</code></td>
<td>
<p>the crs of the coordinate.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function generates all possible coordinates with different signs, and
runs <code><a href="#topic+closestCountry">closestCountry</a></code> on each, returning the coordinates that
lead to a country match. It ignores coordinate options that do not pass
<code><a href="#topic+filterByLand">filterByLand</a></code>.
</p>
<p>If a point falls close to the boundary between two countries, it is still
considered a match.
</p>


<h3>Value</h3>

<p>list with 2 elements </p>
<table role = "presentation">
<tr><td><code>matched</code></td>
<td>
<p> logical: Was the country
matched </p>
</td></tr> <tr><td><code>newcoords</code></td>
<td>
<p> matrix of coordinates that were successful.  </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#correct coordinates
flipSign(c(4.28, 39.98), country = 'Spain')

#mistake in coordinate sign
flipSign(c(115.436, 32.657), country = 'United States')

#incorrect sign on both long and lat, but not possible to distinguish for longitude
#except when we consider which alternative coords fall on land.
flipSign(c(-4.28, -39.98), country = 'Spain', filterByLand = FALSE, returnMultiple = TRUE)
flipSign(c(-4.28, -39.98), country = 'Spain', returnMultiple = TRUE)

#coordinates are incorrect
flipSign(c(4.28, 59.98), country = 'Spain')

</code></pre>

<hr>
<h2 id='getDynamicAlphaHull'>Generate polygon based on alpha hulls</h2><span id='topic+getDynamicAlphaHull'></span>

<h3>Description</h3>

<p>Generates an apha hull polygon, where the alpha parameter is determined by
the spatial distribution of the coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getDynamicAlphaHull(
  x,
  fraction = 0.95,
  partCount = 3,
  buff = 10000,
  initialAlpha = 3,
  coordHeaders = c("Longitude", "Latitude"),
  clipToCoast = "terrestrial",
  alphaIncrement = 1,
  verbose = FALSE,
  alphaCap = 400
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getDynamicAlphaHull_+3A_x">x</code></td>
<td>
<p>dataframe of coordinates in decimal degrees, with a minimum of 3
rows.</p>
</td></tr>
<tr><td><code id="getDynamicAlphaHull_+3A_fraction">fraction</code></td>
<td>
<p>the minimum fraction of occurrences that must be included
in polygon.</p>
</td></tr>
<tr><td><code id="getDynamicAlphaHull_+3A_partcount">partCount</code></td>
<td>
<p>the maximum number of disjunct polygons that are allowed.</p>
</td></tr>
<tr><td><code id="getDynamicAlphaHull_+3A_buff">buff</code></td>
<td>
<p>buffering distance in meters</p>
</td></tr>
<tr><td><code id="getDynamicAlphaHull_+3A_initialalpha">initialAlpha</code></td>
<td>
<p>the starting value for alpha</p>
</td></tr>
<tr><td><code id="getDynamicAlphaHull_+3A_coordheaders">coordHeaders</code></td>
<td>
<p>the column names for the longitude and latitude
columns, respectively.  If x has two columns, these are assumed to be
longitude and latitude, and <code>coordHeaders</code> is ignored.</p>
</td></tr>
<tr><td><code id="getDynamicAlphaHull_+3A_cliptocoast">clipToCoast</code></td>
<td>
<p>Either &quot;no&quot; (no clipping), &quot;terrestrial&quot; (only
terrestrial part of range is kept) or &quot;aquatic&quot; (only non-terrestrial part
is clipped). See Details.</p>
</td></tr>
<tr><td><code id="getDynamicAlphaHull_+3A_alphaincrement">alphaIncrement</code></td>
<td>
<p>the amount to increase alpha with each iteration</p>
</td></tr>
<tr><td><code id="getDynamicAlphaHull_+3A_verbose">verbose</code></td>
<td>
<p>prints the alpha value to the console, intended for
debugging.</p>
</td></tr>
<tr><td><code id="getDynamicAlphaHull_+3A_alphacap">alphaCap</code></td>
<td>
<p>Max alpha value before function aborts and returns a
minimum convex hull.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>From a set of coordinates, this function will create an alpha hull with
<code>alpha = initialAlpha</code>, and will then increase <code>alpha</code> by
<code>alphaIncrement</code> until both the <code>fraction</code> and <code>partCount</code>
conditions are met.
</p>
<p>If the conditions cannot be satisfied, then a minimum convex hull is
returned.
</p>
<p>If <code>clipToCoast</code> is set to &quot;terrestrial&quot; or &quot;aquatic&quot;, the resulting
polygon is clipped to the coastline, using a basemap from naturalearth. 
The first time this function is run, this basemap will be downloaded. 
Subsequent calls will use the downloaded map.
</p>


<h3>Value</h3>

<p>a list with 2 elements: </p>
<table role = "presentation">
<tr><td><code>hull</code></td>
<td>
<p> a sf polygon object </p>
</td></tr>
<tr><td><code>alpha</code></td>
<td>
<p> the alpha value that was found to satisfy the criteria.  If a
convex hull was returned, this will list MCH.  </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>See Also</h3>

<p>Alpha hulls are created with <code><a href="alphahull.html#topic+ahull">ahull</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(crotalus)

# create a polygon range for Crotalus atrox
x &lt;- crotalus[which(crotalus$genSp == 'Crotalus_atrox'),]
x &lt;- x[sample(1:nrow(x), 50),]

range &lt;- getDynamicAlphaHull(x, coordHeaders=c('decimallongitude','decimallatitude'), 
	clipToCoast = 'no')

plot(range[[1]], col=transparentColor('dark green', 0.5), border = NA)
points(x[,c('decimallongitude','decimallatitude')], cex = 0.5, pch = 3)

# to add a basic coastline, you can use the internal map
# world &lt;- rangeBuilder:::loadWorldMap()
# plot(world, add = TRUE, lwd = 0.5)

</code></pre>

<hr>
<h2 id='getExtentOfList'>Get extent of list</h2><span id='topic+getExtentOfList'></span>

<h3>Description</h3>

<p>Given a list of SpatialPolygons or sf objects, return 
a bounding box object that encompasses all items.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getExtentOfList(shapes)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="getExtentOfList_+3A_shapes">shapes</code></td>
<td>
<p>a list of SpatialPolygons or simple features</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>bbox</code>.
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(crotalus)

# create some polygons, in this case convex hulls
sp &lt;- split(crotalus, crotalus$genSp)
sp &lt;- lapply(sp, function(x) x[,c('decimallongitude','decimallatitude')])
sp &lt;- lapply(sp, function(x) x[chull(x),])
poly &lt;- lapply(sp, function(x) 
	sf::st_convex_hull(sf::st_combine(sf::st_as_sf(x, coords = 1:2, crs = 4326))))

getExtentOfList(poly)

</code></pre>

<hr>
<h2 id='rangeBuilder-example'>rangeBuilder datasets</h2><span id='topic+rangeBuilder-example'></span><span id='topic+crotalus'></span>

<h3>Description</h3>

<p>Included datasets in <code>rangeBuilder</code>
</p>


<h3>Details</h3>

<p>The <code>crotalus</code> dataset is the result of a query for genus Crotalus on the VertNet
search portal (<a href="http://portal.vertnet.org/search">http://portal.vertnet.org/search</a>), and has been thinned and lightly 
filtered, to serve as an example dataset for this package.
</p>

<hr>
<h2 id='rasterStackFromPolyList'>Polygon List to rasterStack</h2><span id='topic+rasterStackFromPolyList'></span>

<h3>Description</h3>

<p>Takes a list of polygons and creates a multi-layer SpatRaster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rasterStackFromPolyList(
  polyList,
  resolution = 50000,
  retainSmallRanges = TRUE,
  extent = "auto"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="rasterStackFromPolyList_+3A_polylist">polyList</code></td>
<td>
<p>a list of spatial polygon objects, named with taxon names. 
It is assumed that all items in last have same crs.</p>
</td></tr>
<tr><td><code id="rasterStackFromPolyList_+3A_resolution">resolution</code></td>
<td>
<p>vertical and horizontal size of raster cell, in units of
the polygons' projection</p>
</td></tr>
<tr><td><code id="rasterStackFromPolyList_+3A_retainsmallranges">retainSmallRanges</code></td>
<td>
<p>boolean; should small ranged species be dropped or
preserved. See details.</p>
</td></tr>
<tr><td><code id="rasterStackFromPolyList_+3A_extent">extent</code></td>
<td>
<p>if 'auto', then the maximal extent of the polygons will be
used.  If not auto, must be a numeric vector of length 4 with minLong,
maxLong, minLat, maxLat.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the rasterization process, all cells for which the polygon covers the
midpoint are considered as present and receive a value of 1. If
<code>retainSmallRanges = FALSE</code>, then species whose ranges are so small
that no cell registers as present will be dropped. If
<code>retainSmallRanges = TRUE</code>, then the cells that the small polygon is
found in will be considered as present.
</p>


<h3>Value</h3>

<p>an object of class <code>SpatRaster</code> where all rasters contain
values of either NA or 1.
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 
data(crotalus)
library(sf)
library(terra)

# get 10 species occurrence sets
uniqueSp &lt;- split(crotalus, crotalus$genSp)
uniqueSp &lt;- lapply(uniqueSp, function(x) 
	x[!duplicated(x[, c('decimallongitude', 'decimallatitude')]),])
uniqueSp &lt;- names(uniqueSp[sapply(uniqueSp, nrow) &gt; 5])
uniqueSp &lt;- uniqueSp[1:10]

# create range polygons
ranges &lt;- vector('list', length = length(uniqueSp))
for (i in 1:length(uniqueSp)) {
	x &lt;- crotalus[which(crotalus$genSp == uniqueSp[i]),]

	ranges[[i]] &lt;- getDynamicAlphaHull(x, coordHeaders = c('decimallongitude', 
		'decimallatitude'), clipToCoast = 'terrestrial')
}

# name the polygons
names(ranges) &lt;- uniqueSp

# keep only the polygons
ranges &lt;- lapply(ranges, function(x) x[[1]])

# Create a SpatRaster with the extent inferred from the polygons, and a cell
# resolution of 0.2 degrees.
# cells with the presence of a species get a value of 1, NA if absent. 

rangeStack &lt;- rasterStackFromPolyList(ranges, resolution = 0.2)

# calculate species richness per cell, where cell values are counts of species
richnessRaster &lt;- app(rangeStack, fun=sum, na.rm = TRUE)

# set values of 0 to NA
richnessRaster[richnessRaster == 0] &lt;- NA

#plot
ramp &lt;- colorRampPalette(c('blue','yellow','red'))
plot(richnessRaster, col=ramp(100))

# to add a basic coastline, you can use the internal map
# world &lt;- rangeBuilder:::loadWorldMap()
# plot(world, add = TRUE, lwd = 0.5)


## End(Not run)

</code></pre>

<hr>
<h2 id='standardizeCountry'>Standardize country name</h2><span id='topic+standardizeCountry'></span>

<h3>Description</h3>

<p>Standardizes country names to the list of countries used internally by this
package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standardizeCountry(country, fuzzyDist = 1, nthreads = 1, progressBar = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="standardizeCountry_+3A_country">country</code></td>
<td>
<p>character vector of country names or ISO codes</p>
</td></tr>
<tr><td><code id="standardizeCountry_+3A_fuzzydist">fuzzyDist</code></td>
<td>
<p>for fuzzy searching, the maximum string distance allowed
for a match; if 0, fuzzy searching is disabled.</p>
</td></tr>
<tr><td><code id="standardizeCountry_+3A_nthreads">nthreads</code></td>
<td>
<p>number of threads to use for parallelization of the
function.  The R package <code>parallel</code> must be loaded for <code>nthreads
&gt; 1</code>.</p>
</td></tr>
<tr><td><code id="standardizeCountry_+3A_progressbar">progressBar</code></td>
<td>
<p>if <code>FALSE</code>, progress bar will be suppressed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This package interacts with data from the Global Invasive Species Database
(GISD), the Reptile Database, as well as global maps that were used to
generate the internal dataset used by <code><a href="#topic+closestCountry">closestCountry</a></code>. Efforts
have been made to make country names consistent across these separate
datasets. This function can be used to convert the user's <code>Country</code>
field to the same standardized set.
</p>
<p>Fuzzy matching uses the function <code><a href="utils.html#topic+adist">adist</a></code>.
</p>
<p>Parallelization with <code>nthreads</code> becomes more time-efficient only if
the input vector is of multiple thousands of country names.
</p>


<h3>Value</h3>

<p>Character vector of the standardized country names. If no match
found, <code>""</code> is returned.
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
standardizeCountry(c("Russian Federation", "USA", "Plurinational State of Bolivia", "Brezil"))

</code></pre>

<hr>
<h2 id='transparentColor'>Define colors with transparency</h2><span id='topic+transparentColor'></span>

<h3>Description</h3>

<p>Converts a named color and opacity and returns the proper RGB code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transparentColor(namedColor, alpha = 0.8)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="transparentColor_+3A_namedcolor">namedColor</code></td>
<td>
<p>a color name</p>
</td></tr>
<tr><td><code id="transparentColor_+3A_alpha">alpha</code></td>
<td>
<p>a transparency value between 0 and 1, where 0 is fully
transparent</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the transparent color in RGB format.
</p>


<h3>Author(s)</h3>

<p>Pascal Title
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
