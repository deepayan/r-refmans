<!DOCTYPE html><html><head><title>Help for package rsgeo</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rsgeo}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as_rsgeo'><p>Convert to an <code>rsgeo</code> vector</p></a></li>
<li><a href='#bearing_geodesic'><p>Calculate Bearing</p></a></li>
<li><a href='#bounding_boxes'><p>Compute Geometric Boundaries</p></a></li>
<li><a href='#cast_geoms'><p>Cast geometries to another type</p></a></li>
<li><a href='#centroids'><p>Extract Centroids</p></a></li>
<li><a href='#closest_point'><p>Find Closest Point</p></a></li>
<li><a href='#combine_geoms'><p>Combine geometries</p></a></li>
<li><a href='#coords'><p>Extract Coordinates</p></a></li>
<li><a href='#distance_euclidean_pairwise'><p>Calculate Distances</p></a></li>
<li><a href='#expand_geoms'><p>Expand Geometries</p></a></li>
<li><a href='#flatten_geoms'><p>Flatten a list of rsgeo vectors</p></a></li>
<li><a href='#frechet_distance'><p>Calculate Frechet Distance</p></a></li>
<li><a href='#geom_point'><p>Construct Geometries</p></a></li>
<li><a href='#haversine_destination'><p>Identify a destination point</p></a></li>
<li><a href='#haversine_intermediate'><p>Identifies a point between two points</p></a></li>
<li><a href='#intersects_sparse'><p>Binary Predicates</p></a></li>
<li><a href='#is_convex'><p>Determine the Convexity of a LineString</p></a></li>
<li><a href='#length_euclidean'><p>Calculate LineString Length</p></a></li>
<li><a href='#line_interpolate_point'><p>Interpolate a Point on a LineString</p></a></li>
<li><a href='#line_segmentize'><p>Segments a LineString into <code>n</code> equal length LineStrings</p></a></li>
<li><a href='#locate_point_on_line'><p>Locate a Point on a LineString</p></a></li>
<li><a href='#plot.rsgeo'><p>Plot Geometries</p></a></li>
<li><a href='#signed_area'><p>Calculate the area of a polygon</p></a></li>
<li><a href='#simplify_geoms'><p>Simplify Geometry</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>An Interface to Rust's 'geo' Library</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.6</td>
</tr>
<tr>
<td>Description:</td>
<td>An R interface to the GeoRust crates 'geo' and 'geo-types' providing 
  access to geometry primitives and algorithms.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/JosiahParry/rsgeo">https://github.com/JosiahParry/rsgeo</a>,
<a href="https://josiahparry.r-universe.dev/rsgeo">https://josiahparry.r-universe.dev/rsgeo</a>,
<a href="https://rsgeo.josiahparry.com/">https://rsgeo.josiahparry.com/</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Language:</td>
<td>en</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>rlang, vctrs</td>
</tr>
<tr>
<td>Suggests:</td>
<td>sf, testthat (&ge; 3.0.0), wk</td>
</tr>
<tr>
<td>Config/rextendr/version:</td>
<td>0.3.1.9000</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>Cargo (Rust's package manager), rustc</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Config/Needs/website:</td>
<td>rmarkdown</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-08 14:13:56 UTC; josiahparry</td>
</tr>
<tr>
<td>Author:</td>
<td>Josiah Parry <a href="https://orcid.org/0000-0001-9910-865X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Josiah Parry &lt;josiah.parry@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-08 21:50:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='as_rsgeo'>Convert to an <code>rsgeo</code> vector</h2><span id='topic+as_rsgeo'></span>

<h3>Description</h3>

<p>Given an vector of geometries, cast it as an <code>rsgeo</code> class object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_rsgeo(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_rsgeo_+3A_x">x</code></td>
<td>
<p>a geometry vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>rsgeo</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x &lt;- sf::st_sfc(sf::st_point(c(0,0)))
as_rsgeo(x)

</code></pre>

<hr>
<h2 id='bearing_geodesic'>Calculate Bearing</h2><span id='topic+bearing_geodesic'></span><span id='topic+bearing_haversine'></span>

<h3>Description</h3>

<p>Calculates the bearing between two point geometries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bearing_geodesic(x, y)

bearing_haversine(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bearing_geodesic_+3A_x">x</code></td>
<td>
<p>an object of class <code>rs_POINT</code></p>
</td></tr>
<tr><td><code id="bearing_geodesic_+3A_y">y</code></td>
<td>
<p>an object of class <code>rs_POINT</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of doubles of the calculated bearing for between x and y
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- geom_point(runif(10, 0, 90), rnorm(10, 1, 90))
y &lt;- geom_point(runif(10, 0, 90), rnorm(10, 1, 90))
bearing_geodesic(x, y)
bearing_haversine(x, y)
</code></pre>

<hr>
<h2 id='bounding_boxes'>Compute Geometric Boundaries</h2><span id='topic+bounding_boxes'></span><span id='topic+bounding_rect'></span><span id='topic+minimum_rotated_rect'></span><span id='topic+convex_hull'></span><span id='topic+concave_hull'></span><span id='topic+extreme_coords'></span><span id='topic+bounding_box'></span>

<h3>Description</h3>

<p>From a vector of geometries identify different types of boundaries.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bounding_boxes(x)

bounding_rect(x)

minimum_rotated_rect(x)

convex_hull(x)

concave_hull(x, concavity)

extreme_coords(x)

bounding_box(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bounding_boxes_+3A_x">x</code></td>
<td>
<p>an object of class <code>rsgeo</code></p>
</td></tr>
<tr><td><code id="bounding_boxes_+3A_concavity">concavity</code></td>
<td>
<p>a value between 0 and 1 specifying the concavity of the convex hull</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that if you want a convex or concave hull over an entire vector of geometries
you must first union or combine them using either <code>combine_geoms()</code> or <code>union_geoms()</code>
</p>


<h3>Value</h3>


<ul>
<li> <p><code>bounding_box()</code> returns a named vector of xmin, ymin, xmax, and ymax
</p>
</li>
<li> <p><code>bounding_boxes()</code> returns a list of bounding box numeric vectors for each geometry
</p>
</li>
<li> <p><code>bounding_rect()</code> returns an <code>rs_POLYGON</code> of the bounding rectangle of each geometry
</p>
</li>
<li> <p><code>convex_hull()</code> returns an <code>rs_POLYGON</code> of the convex hull for each geometry
</p>
</li>
<li> <p><code>concave_hull()</code> returns an <code>rs_POLYGON</code> of the specified concavity for each geometry
</p>
</li>
<li> <p><code>extreme_coords()</code> returns the extreme coordinates of each geometry as a list where each element
is a named vector of xmin, ymin, xmax, and ymax where each element is a <code>Point</code> geometry of the extreme value
</p>
</li>
<li> <p><code>minimum_rotated_rect()</code> returns the minimum rotated rectangle covering a geometry as an <code>rs_POLYGON</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>lns &lt;- geom_linestring(
  1:20,
  runif(20, -5, 5),
  rep.int(1:5, 4)
)
bounding_box(lns)
bounding_boxes(lns)
minimum_rotated_rect(lns)
convex_hull(lns)
concave_hull(lns, 0.5)
extreme_coords(lns)

</code></pre>

<hr>
<h2 id='cast_geoms'>Cast geometries to another type</h2><span id='topic+cast_geoms'></span>

<h3>Description</h3>

<p>Cast geometries to another type
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cast_geoms(x, to)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cast_geoms_+3A_x">x</code></td>
<td>
<p>an object of class <code>rsgeo</code></p>
</td></tr>
<tr><td><code id="cast_geoms_+3A_to">to</code></td>
<td>
<p>a character scalar of the target geometry type. Must be one of
<code>"point"</code>, <code>"multipoint"</code>, <code>"polygon"</code>, <code>"multipolygon"</code>, <code>"linestring"</code>,
or <code>"multilinestring"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The below conversions are made available. The left hand column indicates
the originating vector class and the right hand column indicates the
class that it will can be cast to.
</p>
<p>Note that correctness of conversions will not be checked or verified. If you
cast an <code>rs_MULTIPOINT</code> to an <code>rs_POLYGON</code>, the validity of the polygon
cannot be guaranteed.
</p>
<p>Conversions from an <code>rs_POLYGON</code> into an <code>rs_LINESTRING</code> will result in only
the exterior ring of the polygon ignoring any interior rings if there are any.</p>

<table>
<tr>
 <td style="text-align: left;">
   From </td><td style="text-align: left;"> To </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>rs_POINT</code> </td><td style="text-align: left;"> <code>rs_MULTIPOINT</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>rs_MULTIPOINT</code> </td><td style="text-align: left;"> <code>rs_POLYGON</code>, <code>rs_MULTIPOLYGON</code>, <code>rs_LINESTRING</code>, <code>rs_MULTILINESTRING</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>rs_POLYGON</code> </td><td style="text-align: left;"> <code>rs_MULTIPOINT</code>, <code>rs_MULTIPOLYGON</code>, <code>rs_LINESTRING</code>, <code>rs_MULTILINESTRING</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>rs_MULTIPOLYGON</code> </td><td style="text-align: left;"> <code>rs_MULTIPOINT</code>, <code>rs_MULTILINESTRING</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>rs_LINESTRING</code> </td><td style="text-align: left;"> <code>rs_MULTIPOINT</code>, <code>rs_MULTILINESTRING</code>, <code>rs_POLYGON</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
   <code>rs_MULTILINESTRING</code> </td><td style="text-align: left;"> <code>rs_MULTIPOINT</code>, <code>rs_MULTIPOLYGON</code> </td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Value</h3>

<p>An object of class <code>rsgeo</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>ply &lt;- geom_polygon(c(0, 1, 1, 0, 0), c(0, 0, 1, 1, 0))
cast_geoms(ply, "linestring")
cast_geoms(ply, "multipoint")
</code></pre>

<hr>
<h2 id='centroids'>Extract Centroids</h2><span id='topic+centroids'></span>

<h3>Description</h3>

<p>Given a vector of geometries, extract their centroids.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>centroids(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="centroids_+3A_x">x</code></td>
<td>
<p>an object of class <code>rsgeo</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>rs_POINT</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lns &lt;- geom_linestring(1:100, runif(100, -10, 10), rep.int(1:5, 20))
centroids(lns)
</code></pre>

<hr>
<h2 id='closest_point'>Find Closest Point</h2><span id='topic+closest_point'></span><span id='topic+closest_point_haversine'></span>

<h3>Description</h3>

<p>For a given geometry, find the closest point on that geometry
to a point. The closest point may be an intersection, a single point,
or unable to be determined.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>closest_point(x, y)

closest_point_haversine(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="closest_point_+3A_x">x</code></td>
<td>
<p>an object of class <code>rsgeo</code></p>
</td></tr>
<tr><td><code id="closest_point_+3A_y">y</code></td>
<td>
<p>an object of class <code>rs_POINT</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>rs_POINT</code> vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- geom_linestring(1:100, runif(100, 0, 90), rep.int(1:10, 10))
y &lt;- geom_point(runif(10, 0, 90), rnorm(10, 1, 90))
closest_point(x, y)
closest_point_haversine(x, y)
</code></pre>

<hr>
<h2 id='combine_geoms'>Combine geometries</h2><span id='topic+combine_geoms'></span><span id='topic+union_geoms'></span>

<h3>Description</h3>

<p>Given a vector of geometries combine them into a single geometry.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine_geoms(x)

union_geoms(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="combine_geoms_+3A_x">x</code></td>
<td>
<p>an object of class <code>rsgeo</code></p>
</td></tr>
</table>


<h3>Details</h3>



<h4><code>combine_geoms()</code></h4>

<p><code>combine_geoms()</code> combines a vector of geometries into a vector of length one
their <code>MULTI</code> counterpart.
</p>

<ul>
<li> <p><code>rs_POINT</code> and <code>rs_MULTIPOINT</code> -&gt; <code>rs_MULTIPOINT</code>
</p>
</li>
<li> <p><code>rs_LINESTRING</code> and <code>rs_MULTILINESTRING</code> -&gt; <code>rs_MULTILINESTRING</code>
</p>
</li>
<li> <p><code>rs_POLYGON</code> and <code>rs_MULTIPOLYGON</code> -&gt; <code>rs_MULTIPOLYGON</code>
</p>
</li>
<li> <p><code>rs_GEOMETRYCOLLECTION</code> is not supported
</p>
</li></ul>




<h4><code>union_geoms()</code></h4>

<p><code>union_geoms()</code> creates a union of all geometries removing repeated points
or dissolving shared boundaries.
</p>

<ul>
<li> <p><code>rs_POINT</code> - combines and removes repeated points
</p>
</li>
<li> <p><code>rs_MULTIPOINT</code> - combines removes repeated points
</p>
</li>
<li> <p><code>rs_LINESTRING</code> - combines and removes duplicated points
</p>
</li>
<li> <p><code>rs_MULTILINESTRING</code> - combines and removes duplicated points
</p>
</li>
<li> <p><code>rs_POLYGON</code> - unions geometries into a single geometry
</p>
</li>
<li> <p><code>rs_MULTIPOLYGON</code> - unions geometries into a single geometry
</p>
</li></ul>




<h3>Value</h3>

<p>An object of class <code>rsgeo</code> of length one.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pnts &lt;- geom_point(runif(10), runif(10))
combine_geoms(pnts)

lns &lt;- geom_linestring(1:100, runif(100, -10, 10), rep.int(1:5, 20))
union_geoms(lns)

x &lt;- c(0, 1, 1, 0, 0)
y &lt;- c(0, 0, 1, 1, 0)

p1 &lt;- geom_polygon(x, y)
p2 &lt;- geom_polygon(x - 1, y + 0.5)

z &lt;- c(p1, p2)

res &lt;- union_geoms(z)
res

if (rlang::is_installed(c("sf", "wk"))) {
  plot(z)
  plot(res, lty = 3, border = "blue", add = TRUE, lwd = 4)
}
</code></pre>

<hr>
<h2 id='coords'>Extract Coordinates</h2><span id='topic+coords'></span>

<h3>Description</h3>

<p>Given an <code>rsgeo</code> class object, extract the object's coordinates as a data frame.
Empty or missing geometries are ignored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>coords(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coords_+3A_x">x</code></td>
<td>
<p>an object of class <code>rsgeo</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> with columns <code>x</code>, <code>y</code>. Additional columns are returned based
on the geometry type. Additional columns are:
</p>

<ul>
<li> <p><code>id</code>
</p>
</li>
<li> <p><code>line_id</code>: refers to the <code>LineString</code> ID for <code>rs_LINESTRING</code>, or the component <code>LineString</code> in a <code>MultiLineString</code>, or as the ring ID for a <code>Polygon</code>.
</p>
</li>
<li> <p><code>multilinestring_id</code>
</p>
</li>
<li> <p><code>polygon_id</code>
</p>
</li>
<li> <p><code>multipolygon_id</code>
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>pnt &lt;- geom_point(3, 0.14)
mpnt &lt;- geom_multipoint(1:10, 10:1)
ln &lt;- geom_linestring(1:10, 10:1)
ply &lt;- geom_polygon(c(0, 1, 1, 0, 0), c(0, 0, 1, 1, 0))

coords(pnt)
coords(mpnt)
coords(ln)
coords(union_geoms(rep(ln, 2)))
coords(ply)
coords(union_geoms(rep(ply, 2)))
</code></pre>

<hr>
<h2 id='distance_euclidean_pairwise'>Calculate Distances</h2><span id='topic+distance_euclidean_pairwise'></span><span id='topic+distance_hausdorff_pairwise'></span><span id='topic+distance_vicenty_pairwise'></span><span id='topic+distance_geodesic_pairwise'></span><span id='topic+distance_haversine_pairwise'></span><span id='topic+distance_euclidean_matrix'></span><span id='topic+distance_hausdorff_matrix'></span><span id='topic+distance_vicenty_matrix'></span><span id='topic+distance_geodesic_matrix'></span><span id='topic+distance_haversine_matrix'></span>

<h3>Description</h3>

<p>Calculates distances between two vectors of geometries. There are
a number of different distance methods that can be utilized.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distance_euclidean_pairwise(x, y)

distance_hausdorff_pairwise(x, y)

distance_vicenty_pairwise(x, y)

distance_geodesic_pairwise(x, y)

distance_haversine_pairwise(x, y)

distance_euclidean_matrix(x, y)

distance_hausdorff_matrix(x, y)

distance_vicenty_matrix(x, y)

distance_geodesic_matrix(x, y)

distance_haversine_matrix(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distance_euclidean_pairwise_+3A_x">x</code></td>
<td>
<p>and object of class <code>rsgeo</code></p>
</td></tr>
<tr><td><code id="distance_euclidean_pairwise_+3A_y">y</code></td>
<td>
<p>and object of class <code>rsgeo</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>There are <code style="white-space: pre;">&#8288;_pairwise()&#8288;</code> and <code style="white-space: pre;">&#8288;_matrix()&#8288;</code> suffixed functions to
generate distances pairwise or as a dense matrix respectively.
The pairwise functions calculate distances between the ith element
of each vector. Whereas the matrix functions calculate the distance
between each and every geometry.
</p>
<p>Euclidean distance should be used for planar geometries. Haversine,
Geodesic, and Vicenty are all methods of calculating distance
based on spherical geometries. There is no concept of spherical
geometries in rsgeo, so choose your distance measure appropriately.
</p>


<h4>Notes</h4>


<ul>
<li><p> Hausdorff distance is calculated using Euclidean distance.
</p>
</li>
<li><p> Haversine, Geodesic, and Vicenty distances only work with <code>rs_POINT</code> geometries.
</p>
</li></ul>




<h3>Value</h3>

<p>For <code style="white-space: pre;">&#8288;_matrix&#8288;</code> functions, returns a dense matrix of distances whereas <code style="white-space: pre;">&#8288;_pairwise&#8288;</code>
functions return a numeric vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
x &lt;- geom_point(runif(5, -1, 1), runif(5, -1, 1))
y &lt;- rev(x)

distance_euclidean_matrix(x, y)
distance_hausdorff_matrix(x, y)
distance_vicenty_matrix(x, y)
distance_geodesic_matrix(x, y)
distance_haversine_matrix(x, y)

distance_euclidean_pairwise(x, y)
distance_hausdorff_pairwise(x, y)
distance_vicenty_pairwise(x, y)
distance_geodesic_pairwise(x, y)
distance_haversine_pairwise(x, y)
</code></pre>

<hr>
<h2 id='expand_geoms'>Expand Geometries</h2><span id='topic+expand_geoms'></span>

<h3>Description</h3>

<p>Expands geometries into a list of vectors of their components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_geoms(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_geoms_+3A_x">x</code></td>
<td>
<p>an object of class <code>rsgeo</code></p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li> <p><code>rs_MULTIPOINT</code> expands into a vector of points
</p>
</li>
<li> <p><code>rs_LINESTRING</code> expands into a vector points
</p>
</li>
<li> <p><code>rs_MULTILINESTRING</code> expands into a vector of linestrings
</p>
</li>
<li> <p><code>rs_POLYGON</code> expands into a vector of linestrings
</p>
</li>
<li> <p><code>rs_MULTIPOLYGON</code> expands into a vector of polygons
</p>
</li></ul>

<p>If you wish to have a single vector returned, pass the results
into <code>flatten_geoms()</code>.
</p>


<h3>Value</h3>

<p>A list of <code>rsgeo</code> vectors containing each original geometry's
components as a new vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mpnts &lt;- geom_multipoint(runif(10), runif(10), rep.int(1:5, 2))
expand_geoms(mpnts)
</code></pre>

<hr>
<h2 id='flatten_geoms'>Flatten a list of rsgeo vectors</h2><span id='topic+flatten_geoms'></span>

<h3>Description</h3>

<p>Flatten a list of rsgeo vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>flatten_geoms(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="flatten_geoms_+3A_x">x</code></td>
<td>
<p>list object where each element is an object of class <code>rsgeo</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>rsgeo</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pnts &lt;- replicate(
  10,
  geom_point(runif(1), runif(1)),
  simplify = FALSE
)

flatten_geoms(pnts)

</code></pre>

<hr>
<h2 id='frechet_distance'>Calculate Frechet Distance</h2><span id='topic+frechet_distance'></span>

<h3>Description</h3>

<p>Given two LineStrings compare thier similarity
by calculating the Fréchet distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frechet_distance(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frechet_distance_+3A_x">x</code></td>
<td>
<p>an object of class <code>rs_LINESTRING</code></p>
</td></tr>
<tr><td><code id="frechet_distance_+3A_y">y</code></td>
<td>
<p>an object of class <code>rs_LINESTRING</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- geom_linestring(1:10, runif(10, -1, 1))
y &lt;- geom_linestring(1:10, runif(10, -3, 3))
frechet_distance(x, y)
</code></pre>

<hr>
<h2 id='geom_point'>Construct Geometries</h2><span id='topic+geom_point'></span><span id='topic+geom_multipoint'></span><span id='topic+geom_linestring'></span><span id='topic+geom_polygon'></span>

<h3>Description</h3>

<p>Constructs geometries from numeric vectors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geom_point(x, y)

geom_multipoint(x, y, id = 1)

geom_linestring(x, y, id = 1)

geom_polygon(x, y, id = 1, ring = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geom_point_+3A_x">x</code></td>
<td>
<p>a vector of x coordinates</p>
</td></tr>
<tr><td><code id="geom_point_+3A_y">y</code></td>
<td>
<p>a vector of y coordinates</p>
</td></tr>
<tr><td><code id="geom_point_+3A_id">id</code></td>
<td>
<p>the feature identifier</p>
</td></tr>
<tr><td><code id="geom_point_+3A_ring">ring</code></td>
<td>
<p>the id of the polygon ring</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>rsgeo</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>geom_point(3, 0.14)
geom_multipoint(1:10, 10:1)
geom_linestring(1:10, 10:1)
geom_polygon(c(0, 1, 1, 0, 0), c(0, 0, 1, 1, 0))
</code></pre>

<hr>
<h2 id='haversine_destination'>Identify a destination point</h2><span id='topic+haversine_destination'></span>

<h3>Description</h3>

<p>Given a vector of point geometries, bearings, and distances,
identify a destination location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haversine_destination(x, bearing, distance)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="haversine_destination_+3A_x">x</code></td>
<td>
<p>an object of class <code>rs_POINT</code></p>
</td></tr>
<tr><td><code id="haversine_destination_+3A_bearing">bearing</code></td>
<td>
<p>a numeric vector specifying the degree of the direction where 0 is north</p>
</td></tr>
<tr><td><code id="haversine_destination_+3A_distance">distance</code></td>
<td>
<p>a numeric vector specifying the distance to travel in the direction specified by <code>bearing</code> in meters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>rs_POINT</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create 10 points at the origin
pnts &lt;- geom_point(rep(0, 10), rep(0, 10))

# set seed for reproducibiliy
set.seed(1)

# generate random bearings
bearings &lt;- runif(10, 0, 360)

# generate random distances
distances &lt;- runif(10, 10000, 100000)

# find the destinations
dests &lt;- haversine_destination(pnts, bearings, distances)

# plot points
if (rlang::is_installed(c("sf", "wk"))) {
  plot(pnts, pch = 3)
  plot(dests, add = TRUE, pch = 17)
}
</code></pre>

<hr>
<h2 id='haversine_intermediate'>Identifies a point between two points</h2><span id='topic+haversine_intermediate'></span>

<h3>Description</h3>

<p>Identifies the location between two points on a great circle
along a specified fraction of the distance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>haversine_intermediate(x, y, distance)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="haversine_intermediate_+3A_x">x</code></td>
<td>
<p>an <code>rs_POINT</code> vector</p>
</td></tr>
<tr><td><code id="haversine_intermediate_+3A_y">y</code></td>
<td>
<p>an <code>rs_POINT</code> vector</p>
</td></tr>
<tr><td><code id="haversine_intermediate_+3A_distance">distance</code></td>
<td>
<p>a numeric vector of either length 1 or the same length as x and y</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>rs_POINT</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- geom_point(1:10, rep(5, 10))
y &lt;- geom_point(1:10, rep(0, 10))
res &lt;- haversine_intermediate(x, y, 0.5)
if (rlang::is_installed(c("wk", "sf"))) {
  plot(
    c(x, y, res),
    col = sort(rep.int(c("red", "blue", "purple"), 10)),
    pch = 16
  )
}
</code></pre>

<hr>
<h2 id='intersects_sparse'>Binary Predicates</h2><span id='topic+intersects_sparse'></span><span id='topic+intersects_pairwise'></span><span id='topic+contains_sparse'></span><span id='topic+contains_pairwise'></span><span id='topic+within_sparse'></span><span id='topic+within_pairwise'></span>

<h3>Description</h3>

<p>Functions to ascertain the binary relationship between
two geometry vectors. Binary predicates are provided both pairwise
as a sparse matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>intersects_sparse(x, y)

intersects_pairwise(x, y)

contains_sparse(x, y)

contains_pairwise(x, y)

within_sparse(x, y)

within_pairwise(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="intersects_sparse_+3A_x">x</code></td>
<td>
<p>an object of class <code>rsgeo</code></p>
</td></tr>
<tr><td><code id="intersects_sparse_+3A_y">y</code></td>
<td>
<p>an object of class <code>rsgeo</code></p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> For <code style="white-space: pre;">&#8288;_sparse&#8288;</code> a list of integer vectors containing the position
of the geometry in <code>y</code>
</p>
</li>
<li><p> For <code style="white-space: pre;">&#8288;_pairwise&#8288;</code> a logical vector
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>if (rlang::is_installed("sf")) {
    nc &lt;- sf::st_read(
      system.file("shape/nc.shp", package = "sf"),
      quiet = TRUE
    )
    
    x &lt;- as_rsgeo(nc$geometry[1:5])
    y &lt;- rev(x)
    
    # intersects
    intersects_sparse(x, y)
    intersects_pairwise(x, y)
    # contains 
    contains_sparse(x, y)
    contains_pairwise(x, y)
    # within
    within_sparse(x, y)
    within_pairwise(x, y)
}
</code></pre>

<hr>
<h2 id='is_convex'>Determine the Convexity of a LineString</h2><span id='topic+is_convex'></span><span id='topic+is_ccw_convex'></span><span id='topic+is_cw_convex'></span><span id='topic+is_strictly_convex'></span><span id='topic+is_strictly_ccw_convex'></span><span id='topic+is_strictly_cw_convex'></span>

<h3>Description</h3>

<p>For a given <code>rs_LINESTRING</code> vector, test its convexity. Convexity can be tested
strictly or strongly, as well as based on winding.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_convex(x)

is_ccw_convex(x)

is_cw_convex(x)

is_strictly_convex(x)

is_strictly_ccw_convex(x)

is_strictly_cw_convex(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_convex_+3A_x">x</code></td>
<td>
<p>an object of class <code>rs_LINESTRING</code>
</p>
<p>See <a href="https://docs.rs/geo/latest/geo/algorithm/is_convex/trait.IsConvex.html"><code>geo</code> docs for further details</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a logical vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lns &lt;- geom_linestring(
    1:20,
    runif(20, -5, 5),
    rep.int(1:5, 4)
  )
  
is_convex(lns)
is_cw_convex(lns)
is_ccw_convex(lns)
is_strictly_convex(lns)
is_strictly_cw_convex(lns)
is_strictly_ccw_convex(lns)
</code></pre>

<hr>
<h2 id='length_euclidean'>Calculate LineString Length</h2><span id='topic+length_euclidean'></span><span id='topic+length_geodesic'></span><span id='topic+length_vincenty'></span><span id='topic+length_haversine'></span>

<h3>Description</h3>

<p>For a given LineString or MultiLineString geometry, calculate its length.
Other geometries will return a value of <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>length_euclidean(x)

length_geodesic(x)

length_vincenty(x)

length_haversine(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="length_euclidean_+3A_x">x</code></td>
<td>
<p>an object of class <code>rsgeo</code></p>
</td></tr>
</table>


<h3>Details</h3>



<h4>Notes</h4>


<ul>
<li><p> Vicenty, Geodesic, and Haversine methods will return in units of meters.
</p>
</li>
<li><p> Geodesic length will always converge and is more accurate than the Vicenty methods.
</p>
</li>
<li><p> Haversine uses a mean earth radius of 6371.088 km.
</p>
</li></ul>

<p>See <a href="https://docs.rs/geo/latest/geo/index.html#length"><code>geo</code></a> docs for more details.
</p>



<h3>Value</h3>

<p>A numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(0)
y &lt;- runif(25, -5, 5)
x &lt;- 1:25

ln &lt;- geom_linestring(x, y)

length_euclidean(ln)
length_geodesic(ln)
length_vincenty(ln)
length_haversine(ln)
</code></pre>

<hr>
<h2 id='line_interpolate_point'>Interpolate a Point on a LineString</h2><span id='topic+line_interpolate_point'></span>

<h3>Description</h3>

<p>Finds the point that lies a given fraction along a line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>line_interpolate_point(x, fraction)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="line_interpolate_point_+3A_x">x</code></td>
<td>
<p>an object of class <code>rs_LINESTRING</code></p>
</td></tr>
<tr><td><code id="line_interpolate_point_+3A_fraction">fraction</code></td>
<td>
<p>a numeric vector of length 1 or the same length as <code>x</code>. Must be a value between 0 and 1 inclusive.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>rs_POINT</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- geom_linestring(c(-1, 0, 0), c(0, 0, 1))
line_interpolate_point(x, 0.5)
</code></pre>

<hr>
<h2 id='line_segmentize'>Segments a LineString into <code>n</code> equal length LineStrings</h2><span id='topic+line_segmentize'></span>

<h3>Description</h3>

<p>Given a LineString, segment it into <code>n</code> equal length LineStrings.
The <code>n</code> LineStrings are provided as a <code>MultiLineString</code> which can
be expanded using <code>expand_geoms()</code> and consequently flattened
using <code>flatten_geoms()</code> if desired.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>line_segmentize(x, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="line_segmentize_+3A_x">x</code></td>
<td>
<p>and object of class <code>rs_LINESTRING</code></p>
</td></tr>
<tr><td><code id="line_segmentize_+3A_n">n</code></td>
<td>
<p>an integer vector determining the number of equal length LineStrings to create</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of class <code>rs_MULTILINESTRING</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- geom_linestring(1:10, runif(10, -1, 1))

segs &lt;- line_segmentize(x, 3)

flatten_geoms(
  expand_geoms(segs)
)
</code></pre>

<hr>
<h2 id='locate_point_on_line'>Locate a Point on a LineString</h2><span id='topic+locate_point_on_line'></span>

<h3>Description</h3>

<p>Calculates the fraction of a LineString's length to a point
that is closes to a corresponding point in <code>y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locate_point_on_line(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locate_point_on_line_+3A_x">x</code></td>
<td>
<p>an object of class <code>rs_LINESTRING</code></p>
</td></tr>
<tr><td><code id="locate_point_on_line_+3A_y">y</code></td>
<td>
<p>an object of class <code>rs_POINT</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector containing the fraction of of the LineString that
would need to be traveled to reach the closest point.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- geom_linestring(c(-1, 0, 0), c(0, 0, 1))
y &lt;- geom_point(-0.5, 0)
locate_point_on_line(x, y)
</code></pre>

<hr>
<h2 id='plot.rsgeo'>Plot Geometries</h2><span id='topic+plot.rsgeo'></span>

<h3>Description</h3>

<p>Plot Geometries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rsgeo'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.rsgeo_+3A_x">x</code></td>
<td>
<p>an object of class <code>rsgeo</code></p>
</td></tr>
<tr><td><code id="plot.rsgeo_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>wk::wk_plot()</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plotting geometries utilizes <code>wk::wk_plot()</code>. The rust geometries are
handled by first converting to an <code>sfc</code> object in the <code>wk::wk_handle()</code>
method thus requiring both packages for plotting.
</p>


<h3>Value</h3>

<p>Nothing.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (rlang::is_installed(c("sf", "wk"))) {
  plot(geom_linestring(1:10, runif(10)))
}
</code></pre>

<hr>
<h2 id='signed_area'>Calculate the area of a polygon</h2><span id='topic+signed_area'></span><span id='topic+unsigned_area'></span><span id='topic+signed_area_cd'></span><span id='topic+unsigned_area_cd'></span><span id='topic+signed_area_geodesic'></span><span id='topic+unsigned_area_geodesic'></span>

<h3>Description</h3>

<p>Functions to calculate different types of area for polygons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>signed_area(x)

unsigned_area(x)

signed_area_cd(x)

unsigned_area_cd(x)

signed_area_geodesic(x)

unsigned_area_geodesic(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="signed_area_+3A_x">x</code></td>
<td>
<p>an object of class <code>rsgeo</code></p>
</td></tr>
</table>


<h3>Details</h3>


<ul>
<li><p> functions assume counter clock-wise winding in accordance with the simple feature
access standard
</p>
</li>
<li><p> functions ending in <code style="white-space: pre;">&#8288;_cd&#8288;</code> use the Chamberlain-Duquette algorithm for spherical area
</p>
</li>
<li><p> Chamberlain-Duquette and Geodesic areas are returned in meters squared and assume non-planar geometries
</p>
</li></ul>

<p>See geo docs for more:
</p>

<ul>
<li> <p><a href="https://docs.rs/geo/latest/geo/algorithm/geodesic_area/trait.GeodesicArea.html#">GeodesicArea</a>
</p>
</li>
<li> <p><a href="https://docs.rs/geo/latest/geo/algorithm/area/trait.Area.html#">Area</a>
</p>
</li>
<li> <p><a href="https://docs.rs/geo/latest/geo/algorithm/chamberlain_duquette_area/trait.ChamberlainDuquetteArea.html">ChamberlainDuquetteArea</a>
</p>
</li></ul>



<h3>Value</h3>

<p>a numeric vector of the area contained by the geometry
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(0, 1, 1, 0, 0)
y &lt;- c(0, 0, 1, 1, 0)
p &lt;- geom_polygon(x, y)

signed_area(p)
unsigned_area(p)
signed_area_cd(p)
unsigned_area_cd(p)
signed_area_geodesic(p)
unsigned_area_geodesic(p)
</code></pre>

<hr>
<h2 id='simplify_geoms'>Simplify Geometry</h2><span id='topic+simplify_geoms'></span><span id='topic+simplify_vw_geoms'></span><span id='topic+simplify_vw_preserve_geoms'></span>

<h3>Description</h3>

<p>Simplifies LineStrings, Polygons, and their Multi- counterparts.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simplify_geoms(x, epsilon)

simplify_vw_geoms(x, epsilon)

simplify_vw_preserve_geoms(x, epsilon)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simplify_geoms_+3A_x">x</code></td>
<td>
<p>an object of class of <code>rsgeo</code></p>
</td></tr>
<tr><td><code id="simplify_geoms_+3A_epsilon">epsilon</code></td>
<td>
<p>a tolerance parameter. Cannot be equal to or less than 0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Simplify functions use the Ramer–Douglas–Peucker algorithm. Functions with <code>vw</code> use
the Visvalingam-Whyatt algorithm.
</p>
<p>For more see <a href="https://docs.rs/geo/latest/geo/index.html#simplification"><code>geo</code> docs</a>.
</p>


<h3>Value</h3>

<p>an object of class <code>rsgeo</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- geom_linestring(1:100, runif(100, 5, 10))

simplify_geoms(x, 3)
simplify_vw_geoms(x, 2)
simplify_vw_preserve_geoms(x, 100)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
