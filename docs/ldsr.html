<!DOCTYPE html><html><head><title>Help for package ldsr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ldsr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ldsr'><p>ldsr: Linear Dynamical System Reconstruction</p></a></li>
<li><a href='#calculate_metrics'><p>Reconstruction metrics</p></a></li>
<li><a href='#call_method'><p>Call a reconstruction method</p></a></li>
<li><a href='#corr'><p>Pearson's correlation</p></a></li>
<li><a href='#cvLDS'><p>Cross validate LDS model. This is a wrapper for LDS_reconstruction</p></a></li>
<li><a href='#cvPCR'><p>Cross validation of PCR reconstruction.</p></a></li>
<li><a href='#exp_ci'><p>Exponential confidence interval</p></a></li>
<li><a href='#inv_boxcox'><p>Inverse Box-Cox transform</p></a></li>
<li><a href='#Kalman_smoother'><p>Implement Kalman smoothing</p></a></li>
<li><a href='#KGE'><p>Kling-Gupta Efficiency</p></a></li>
<li><a href='#LDS_BFGS'><p>Learn LDS with L-BFGS-B</p></a></li>
<li><a href='#LDS_BFGS_with_update'><p>Learn LDS with L-BFGS-B</p></a></li>
<li><a href='#LDS_EM'><p>Learn LDS model</p></a></li>
<li><a href='#LDS_EM_restart'><p>Learn LDS model with multiple initial conditions</p></a></li>
<li><a href='#LDS_GA'><p>Learn a linear dynamical system using Genetic Algorithm.</p></a></li>
<li><a href='#LDS_reconstruction'><p>Learn LDS model.</p></a></li>
<li><a href='#LDS_rep'><p>Multiple LDS replicates</p></a></li>
<li><a href='#make_init'><p>Make initial values for parameters.</p></a></li>
<li><a href='#make_Z'><p>Make cross-validation folds.</p></a></li>
<li><a href='#metrics_with_transform'><p>Transform the estimates before calculating metrics</p></a></li>
<li><a href='#Mstep'><p>Maximizing expected likelihood using analytical solution</p></a></li>
<li><a href='#negLogLik'><p>Calculates the negative log-likelihood</p></a></li>
<li><a href='#NPannual'><p>Annual streamflow at Nakhon Phanom</p></a></li>
<li><a href='#NPpc'><p>Selected principal components</p></a></li>
<li><a href='#nRMSE'><p>Normalized root-mean-square error</p></a></li>
<li><a href='#NSE'><p>Nash-Sutcliffe Efficiency</p></a></li>
<li><a href='#one_lds_cv'><p>One cross-validation run</p></a></li>
<li><a href='#one_LDS_rep'><p>One LDS replicate</p></a></li>
<li><a href='#one_pcr_cv'><p>One cross-validation run</p></a></li>
<li><a href='#PCR_ensemble_selection'><p>Select the best reconstruction</p></a></li>
<li><a href='#PCR_reconstruction'><p>Principal Component Regression Reconstruction</p></a></li>
<li><a href='#penalized_likelihood'><p>Penalized likelihood objective function</p></a></li>
<li><a href='#propagate'><p>State propagation</p></a></li>
<li><a href='#RE'><p>Reduction of Error</p></a></li>
<li><a href='#theta'><p>LDS parameters</p></a></li>
<li><a href='#vec_to_list'><p>Converts theta from a vector (as used in GA) to list (as used in Kalman smoothing)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Linear Dynamical System Reconstruction</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Streamflow (and climate) reconstruction using Linear Dynamical Systems. 
    The advantage of this method is the additional state trajectory which can reveal more information 
    about the catchment or climate system. For details of the method please refer to Nguyen and Galelli 
    (2018) &lt;<a href="https://doi.org/10.1002%2F2017WR022114">doi:10.1002/2017WR022114</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2.0)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, foreach, MASS, Rcpp, stats</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.0</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/ntthung/ldsr">https://github.com/ntthung/ldsr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ntthung/ldsr/issues">https://github.com/ntthung/ldsr/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>GA, knitr, rmarkdown, testthat, ggplot2, patchwork, doFuture,
future</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-04-29 15:58:48 UTC; The Water Guy</td>
</tr>
<tr>
<td>Author:</td>
<td>Hung Nguyen [aut, cre],
  Stefano Galelli [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Hung Nguyen &lt;ntthung@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-05-04 14:40:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='ldsr'>ldsr: Linear Dynamical System Reconstruction</h2><span id='topic+ldsr'></span><span id='topic+ldsr-package'></span>

<h3>Description</h3>

<p>Streamflow (and climate) reconstruction using Linear Dynamical Systems. 
The advantage of this method is the additional state trajectory which can reveal more information 
about the catchment or climate system. For details of the method please refer to Nguyen and Galelli 
(2018) &lt;doi:10.1002/2017WR022114&gt;.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Hung Nguyen <a href="mailto:ntthung@gmail.com">ntthung@gmail.com</a>
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Stefano Galelli <a href="mailto:stefano_galelli@sutd.edu.sg">stefano_galelli@sutd.edu.sg</a> [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/ntthung/ldsr">https://github.com/ntthung/ldsr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/ntthung/ldsr/issues">https://github.com/ntthung/ldsr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='calculate_metrics'>Reconstruction metrics</h2><span id='topic+calculate_metrics'></span>

<h3>Description</h3>

<p>Calculate reconstruction metrics from the instrumental period
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_metrics(sim, obs, z, norm.fun = mean)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_metrics_+3A_sim">sim</code></td>
<td>
<p>A vector of reconstruction output for instrumental period</p>
</td></tr>
<tr><td><code id="calculate_metrics_+3A_obs">obs</code></td>
<td>
<p>A vector of all observations</p>
</td></tr>
<tr><td><code id="calculate_metrics_+3A_z">z</code></td>
<td>
<p>A vector of left out indices in cross validation</p>
</td></tr>
<tr><td><code id="calculate_metrics_+3A_norm.fun">norm.fun</code></td>
<td>
<p>The function (unquoted name) used to calculate the normalizing constant. Default is <code>mean()</code>, but other functions such as <code>sd()</code> can also be used. THe function must take a vector as input and return a scalar as output, and must have an argument <code>na.rm = TRUE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector of performance metrics
</p>


<h3>Examples</h3>

<pre><code class='language-R'>calculate_metrics(rnorm(100), rnorm(100), z = 1:10)
calculate_metrics(rnorm(100), rnorm(100), z = 1:10, norm.fun = sd)
</code></pre>

<hr>
<h2 id='call_method'>Call a reconstruction method</h2><span id='topic+call_method'></span>

<h3>Description</h3>

<p>Call a reconstruction method subroutine according to the method required
</p>


<h3>Usage</h3>

<pre><code class='language-R'>call_method(
  y,
  u,
  v,
  method,
  init,
  num.restarts,
  return.init,
  ub,
  lb,
  num.islands,
  pop.per.island,
  niter,
  tol
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="call_method_+3A_y">y</code></td>
<td>
<p>Catchment output, preprocessed from data</p>
</td></tr>
<tr><td><code id="call_method_+3A_u">u</code></td>
<td>
<p>Input matrix for a single-model reconstruction, or a list of input matrices for an ensemble reconstruction.</p>
</td></tr>
<tr><td><code id="call_method_+3A_v">v</code></td>
<td>
<p>Same as u.</p>
</td></tr>
<tr><td><code id="call_method_+3A_method">method</code></td>
<td>
<p>By default this is &quot;EM&quot;. There are experimental methods but you should not try.</p>
</td></tr>
<tr><td><code id="call_method_+3A_init">init</code></td>
<td>
<p>A list, each element is a vector of initial values for the parameters. If <code>NULL</code>, will be created by <code>make_init()</code>. See <a href="#topic+make_init">make_init</a> for details.</p>
</td></tr>
<tr><td><code id="call_method_+3A_num.restarts">num.restarts</code></td>
<td>
<p>The number of initial conditions to start the EM search; ignored if <code>init</code> is provided.</p>
</td></tr>
<tr><td><code id="call_method_+3A_return.init">return.init</code></td>
<td>
<p>If <code>TRUE</code>, the list of initial values (<code>init</code>) will be returned. This can be useful if you want to reproduce the model from this one set of initial values.</p>
</td></tr>
<tr><td><code id="call_method_+3A_ub">ub</code></td>
<td>
<p>Upper bounds, a vector whose length is the number of parameters</p>
</td></tr>
<tr><td><code id="call_method_+3A_lb">lb</code></td>
<td>
<p>Lower bounds</p>
</td></tr>
<tr><td><code id="call_method_+3A_num.islands">num.islands</code></td>
<td>
<p>Number of islands (if method is GA; experimental)</p>
</td></tr>
<tr><td><code id="call_method_+3A_pop.per.island">pop.per.island</code></td>
<td>
<p>Initial population per island (if method is GA; experimental)</p>
</td></tr>
<tr><td><code id="call_method_+3A_niter">niter</code></td>
<td>
<p>Maximum number of iterations, default 1000</p>
</td></tr>
<tr><td><code id="call_method_+3A_tol">tol</code></td>
<td>
<p>Tolerance for likelihood convergence, default 1e-5. Note that the log-likelihood is normalized by dividing by the number of observations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The results as produced by <code>LDS_EM_restart()</code> when the default method (EM) is called. Other methods are experimental.
</p>

<hr>
<h2 id='corr'>Pearson's correlation</h2><span id='topic+corr'></span>

<h3>Description</h3>

<p>Calculate the Pearson's correlation using the numerically stable formulation (see References). Internal function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>corr(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="corr_+3A_x">x</code></td>
<td>
<p>First variable</p>
</td></tr>
<tr><td><code id="corr_+3A_y">y</code></td>
<td>
<p>Second variable</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Pearson's correlation
</p>


<h3>Reference John D. Cook's article at https</h3>

<p>//www.johndcook.com/blog/2008/11/05/how-to-calculate-pearson-correlation-accurately/
</p>

<hr>
<h2 id='cvLDS'>Cross validate LDS model. This is a wrapper for <a href="#topic+LDS_reconstruction">LDS_reconstruction</a></h2><span id='topic+cvLDS'></span>

<h3>Description</h3>

<p>Cross validate LDS model. This is a wrapper for <a href="#topic+LDS_reconstruction">LDS_reconstruction</a>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cvLDS(
  Qa,
  u,
  v,
  start.year,
  method = "EM",
  transform = "log",
  num.restarts = 50,
  Z = make_Z(Qa$Qa),
  metric.space = "transformed",
  use.raw = FALSE,
  ub = NULL,
  lb = NULL,
  num.islands = 4,
  pop.per.island = 100,
  niter = 1000,
  tol = 1e-05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cvLDS_+3A_qa">Qa</code></td>
<td>
<p>Observations: a data.frame of annual streamflow with at least two columns: year and Qa.</p>
</td></tr>
<tr><td><code id="cvLDS_+3A_u">u</code></td>
<td>
<p>Input matrix for a single-model reconstruction, or a list of input matrices for an ensemble reconstruction.</p>
</td></tr>
<tr><td><code id="cvLDS_+3A_v">v</code></td>
<td>
<p>Same as u.</p>
</td></tr>
<tr><td><code id="cvLDS_+3A_start.year">start.year</code></td>
<td>
<p>Starting year of the climate proxies, i.e, the first year of the paleo period. <code>start.year + nrow(pc) - 1</code> will determine the last year of the study horizon, which must be greater than or equal to the last year in <code>Qa</code>.</p>
</td></tr>
<tr><td><code id="cvLDS_+3A_method">method</code></td>
<td>
<p>By default this is &quot;EM&quot;. There are experimental methods but you should not try.</p>
</td></tr>
<tr><td><code id="cvLDS_+3A_transform">transform</code></td>
<td>
<p>Flow transformation, either &quot;log&quot;, &quot;boxcox&quot; or &quot;none&quot;. Note that if the Box-Cox transform is used, the confidence interval after back-transformation is simply the back-transform of the trained onfidence interval; this is hackish and not entirely accurate.</p>
</td></tr>
<tr><td><code id="cvLDS_+3A_num.restarts">num.restarts</code></td>
<td>
<p>The number of initial conditions to start the EM search; ignored if <code>init</code> is provided.</p>
</td></tr>
<tr><td><code id="cvLDS_+3A_z">Z</code></td>
<td>
<p>A list of cross-validation folds. If <code>NULL</code>, will be created with <code>make_Z()</code> with default settings. Users are advised to use <code>make_Z()</code> to create the cross-validation folds beforehand. See <a href="#topic+make_Z">make_Z</a> for details.</p>
</td></tr>
<tr><td><code id="cvLDS_+3A_metric.space">metric.space</code></td>
<td>
<p>Either &quot;transformed&quot; or &quot;original&quot;, the space to calculate the performance metrics.</p>
</td></tr>
<tr><td><code id="cvLDS_+3A_use.raw">use.raw</code></td>
<td>
<p>Whether performance metrics are calculated on the raw time series. Experimental; don't use.</p>
</td></tr>
<tr><td><code id="cvLDS_+3A_ub">ub</code></td>
<td>
<p>Upper bounds, a vector whose length is the number of parameters</p>
</td></tr>
<tr><td><code id="cvLDS_+3A_lb">lb</code></td>
<td>
<p>Lower bounds</p>
</td></tr>
<tr><td><code id="cvLDS_+3A_num.islands">num.islands</code></td>
<td>
<p>Number of islands (if method is GA; experimental)</p>
</td></tr>
<tr><td><code id="cvLDS_+3A_pop.per.island">pop.per.island</code></td>
<td>
<p>Initial population per island (if method is GA; experimental)</p>
</td></tr>
<tr><td><code id="cvLDS_+3A_niter">niter</code></td>
<td>
<p>Maximum number of iterations, default 1000</p>
</td></tr>
<tr><td><code id="cvLDS_+3A_tol">tol</code></td>
<td>
<p>Tolerance for likelihood convergence, default 1e-5. Note that the log-likelihood is normalized by dividing by the number of observations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of cross validation results
</p>

<ul>
<li><p> metrics.dist: distribution of performance metrics across all cross-validation runs; a matrix, one column for each metric, with column names.
</p>
</li>
<li><p> metrics: average performance metrics; a named vector.
</p>
</li>
<li><p> target: the (transformed) observations used for cross-validation; a data.table with two columns (year, y)
</p>
</li>
<li><p> Ycv: the predicted streamflow in each cross validation run; a matrix, one column for each cross-validation run
</p>
</li>
<li><p> Z: the cross-validation
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Make a shorter time horizon so that this example runs fast
u &lt;- v &lt;- t(NPpc[601:813])
# We run this example without parallelism.
foreach::registerDoSEQ()
cvLDS(NPannual, u, v, start.year = 1800, num.restarts = 2,
      Z = make_Z(NPannual$Qa, nRuns = 1))
# Please refer to the vignette for the full run with parallel options. It takes a minute or two.
</code></pre>

<hr>
<h2 id='cvPCR'>Cross validation of PCR reconstruction.</h2><span id='topic+cvPCR'></span>

<h3>Description</h3>

<p>Cross validation of PCR reconstruction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cvPCR(
  Qa,
  pc,
  start.year,
  transform = "log",
  Z = NULL,
  metric.space = "transformed"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cvPCR_+3A_qa">Qa</code></td>
<td>
<p>Observations: a data.frame of annual streamflow with at least two columns: year and Qa.</p>
</td></tr>
<tr><td><code id="cvPCR_+3A_pc">pc</code></td>
<td>
<p>For a single model: a data.frame, one column for each principal component. For an ensemble reconstruction: a list, each element is a data.frame of principal components.</p>
</td></tr>
<tr><td><code id="cvPCR_+3A_start.year">start.year</code></td>
<td>
<p>Starting year of the climate proxies, i.e, the first year of the paleo period. <code>start.year + nrow(pc) - 1</code> will determine the last year of the study horizon, which must be greater than or equal to the last year in <code>Qa</code>.</p>
</td></tr>
<tr><td><code id="cvPCR_+3A_transform">transform</code></td>
<td>
<p>Flow transformation, either &quot;log&quot;, &quot;boxcox&quot; or &quot;none&quot;. Note that if the Box-Cox transform is used, the confidence interval after back-transformation is simply the back-transform of the trained onfidence interval; this is hackish and not entirely accurate.</p>
</td></tr>
<tr><td><code id="cvPCR_+3A_z">Z</code></td>
<td>
<p>A list of cross-validation folds. If <code>NULL</code>, will be created with <code>make_Z()</code> with default settings. Users are advised to use <code>make_Z()</code> to create the cross-validation folds beforehand. See <a href="#topic+make_Z">make_Z</a> for details.</p>
</td></tr>
<tr><td><code id="cvPCR_+3A_metric.space">metric.space</code></td>
<td>
<p>Either &quot;transformed&quot; or &quot;original&quot;, the space to calculate the performance metrics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of cross validation results
</p>

<ul>
<li><p> metrics.dist: distribution of performance metrics across all cross-validation runs; a matrix, one column for each metric, with column names.
</p>
</li>
<li><p> metrics: average performance metrics; a named vector.
</p>
</li>
<li><p> obs: the (transformed) observations, a data.table with two columns (year, y)
</p>
</li>
<li><p> Ycv: the predicted streamflow in each cross validation run; a matrix, one column for each cross-validation run
</p>
</li>
<li><p> Z: the cross-validation fold
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>cvPCR(NPannual, NPpc, start.year = 1200)
</code></pre>

<hr>
<h2 id='exp_ci'>Exponential confidence interval</h2><span id='topic+exp_ci'></span>

<h3>Description</h3>

<p>Get the confidence interval of Q = exp(Y) when Y is normal, i.e, Q is log-normal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exp_ci(y, sigma2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exp_ci_+3A_y">y</code></td>
<td>
<p>A vector of model estimates</p>
</td></tr>
<tr><td><code id="exp_ci_+3A_sigma2">sigma2</code></td>
<td>
<p>The variance of y as learned from a model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table with the updated confidence intervals
</p>

<hr>
<h2 id='inv_boxcox'>Inverse Box-Cox transform</h2><span id='topic+inv_boxcox'></span>

<h3>Description</h3>

<p>Inverse Box-Cox transform
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inv_boxcox(x, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inv_boxcox_+3A_x">x</code></td>
<td>
<p>A numeric vector to be transformed</p>
</td></tr>
<tr><td><code id="inv_boxcox_+3A_lambda">lambda</code></td>
<td>
<p>Lambda parameter</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The inverse Box-Cox
</p>


<h3>Examples</h3>

<pre><code class='language-R'>inv_boxcox(x = rnorm(10), lambda = 1)
inv_boxcox(x = rnorm(10), lambda = 0) # exp(x)
</code></pre>

<hr>
<h2 id='Kalman_smoother'>Implement Kalman smoothing</h2><span id='topic+Kalman_smoother'></span>

<h3>Description</h3>

<p>Estimate the hidden state and expected log-likelihood given the observations, exogeneous input and system parameters. This is an internal function and should not be called directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Kalman_smoother(y, u, v, theta, stdlik = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Kalman_smoother_+3A_y">y</code></td>
<td>
<p>Observation matrix (may need to be normalized and centered before hand) (q rows, T columns)</p>
</td></tr>
<tr><td><code id="Kalman_smoother_+3A_u">u</code></td>
<td>
<p>Input matrix for the state equation (m_u rows, T columns)</p>
</td></tr>
<tr><td><code id="Kalman_smoother_+3A_v">v</code></td>
<td>
<p>Input matrix for the output equation (m_v rows, T columns)</p>
</td></tr>
<tr><td><code id="Kalman_smoother_+3A_theta">theta</code></td>
<td>
<p>A list of system parameters (A, B, C, D, Q, R)'</p>
</td></tr>
<tr><td><code id="Kalman_smoother_+3A_stdlik">stdlik</code></td>
<td>
<p>Boolean, whether the likelihood is divided by the number of observations. Standardizing the likelihood this way may speed up convergence in the case of long time series.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of fitted elements (X, Y, V, J, and lik)
</p>


<h3>Note</h3>

<p>This code only works on one dimensional state and output at the moment. Therefore, transposing is skipped, and matrix inversion is treated as /, and log(det(Sigma)) is treated as log(Sigma).
</p>

<hr>
<h2 id='KGE'>Kling-Gupta Efficiency</h2><span id='topic+KGE'></span>

<h3>Description</h3>

<p>Kling-Gupta Efficiency
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KGE(yhat, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KGE_+3A_yhat">yhat</code></td>
<td>
<p>Model outputs</p>
</td></tr>
<tr><td><code id="KGE_+3A_y">y</code></td>
<td>
<p>Observations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>KGE
</p>


<h3>Examples</h3>

<pre><code class='language-R'>KGE(rnorm(100), rnorm(100))
</code></pre>

<hr>
<h2 id='LDS_BFGS'>Learn LDS with L-BFGS-B</h2><span id='topic+LDS_BFGS'></span>

<h3>Description</h3>

<p><strong>Warning</strong> This is an experimental feature. Use with care.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LDS_BFGS(y, u, v, ub, lb, num.restarts = 100, parallel = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LDS_BFGS_+3A_y">y</code></td>
<td>
<p>Transformed and standardized streamflow</p>
</td></tr>
<tr><td><code id="LDS_BFGS_+3A_u">u</code></td>
<td>
<p>Input matrix for a single-model reconstruction, or a list of input matrices for an ensemble reconstruction.</p>
</td></tr>
<tr><td><code id="LDS_BFGS_+3A_v">v</code></td>
<td>
<p>Same as u.</p>
</td></tr>
<tr><td><code id="LDS_BFGS_+3A_ub">ub</code></td>
<td>
<p>Upper bounds, a vector whose length is the number of parameters</p>
</td></tr>
<tr><td><code id="LDS_BFGS_+3A_lb">lb</code></td>
<td>
<p>Lower bounds</p>
</td></tr>
<tr><td><code id="LDS_BFGS_+3A_num.restarts">num.restarts</code></td>
<td>
<p>The number of initial conditions to start the EM search; ignored if <code>init</code> is provided.</p>
</td></tr>
<tr><td><code id="LDS_BFGS_+3A_parallel">parallel</code></td>
<td>
<p>Logical, whether parallel computation is used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of reconstruction results; see <a href="#topic+LDS_reconstruction">LDS_reconstruction</a>
</p>

<hr>
<h2 id='LDS_BFGS_with_update'>Learn LDS with L-BFGS-B</h2><span id='topic+LDS_BFGS_with_update'></span>

<h3>Description</h3>

<p><strong>Warning</strong> This is an experimental feature. Use with care.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LDS_BFGS_with_update(
  y,
  u,
  v,
  lambda = 1,
  ub,
  lb,
  num.restarts = 100,
  parallel = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LDS_BFGS_with_update_+3A_y">y</code></td>
<td>
<p>Transformed and standardized streamflow</p>
</td></tr>
<tr><td><code id="LDS_BFGS_with_update_+3A_u">u</code></td>
<td>
<p>Input matrix for a single-model reconstruction, or a list of input matrices for an ensemble reconstruction.</p>
</td></tr>
<tr><td><code id="LDS_BFGS_with_update_+3A_v">v</code></td>
<td>
<p>Same as u.</p>
</td></tr>
<tr><td><code id="LDS_BFGS_with_update_+3A_lambda">lambda</code></td>
<td>
<p>weight for penalty</p>
</td></tr>
<tr><td><code id="LDS_BFGS_with_update_+3A_ub">ub</code></td>
<td>
<p>Upper bounds, a vector whose length is the number of parameters</p>
</td></tr>
<tr><td><code id="LDS_BFGS_with_update_+3A_lb">lb</code></td>
<td>
<p>Lower bounds</p>
</td></tr>
<tr><td><code id="LDS_BFGS_with_update_+3A_num.restarts">num.restarts</code></td>
<td>
<p>The number of initial conditions to start the EM search; ignored if <code>init</code> is provided.</p>
</td></tr>
<tr><td><code id="LDS_BFGS_with_update_+3A_parallel">parallel</code></td>
<td>
<p>Logical, whether parallel computation is used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of reconstruction results; see <a href="#topic+LDS_reconstruction">LDS_reconstruction</a>
</p>

<hr>
<h2 id='LDS_EM'>Learn LDS model</h2><span id='topic+LDS_EM'></span>

<h3>Description</h3>

<p>Estimate the hidden state and model parameters given observations and exogenous inputs using the EM algorithm. This is the key backend routine of this package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LDS_EM(y, u, v, theta0, niter = 1000L, tol = 1e-05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LDS_EM_+3A_y">y</code></td>
<td>
<p>Observation matrix (may need to be normalized and centered before hand) (q rows, T columns)</p>
</td></tr>
<tr><td><code id="LDS_EM_+3A_u">u</code></td>
<td>
<p>Input matrix for the state equation (m_u rows, T columns)</p>
</td></tr>
<tr><td><code id="LDS_EM_+3A_v">v</code></td>
<td>
<p>Input matrix for the output equation (m_v rows, T columns)</p>
</td></tr>
<tr><td><code id="LDS_EM_+3A_theta0">theta0</code></td>
<td>
<p>A vector of initial values for the parameters</p>
</td></tr>
<tr><td><code id="LDS_EM_+3A_niter">niter</code></td>
<td>
<p>Maximum number of iterations, default 1000</p>
</td></tr>
<tr><td><code id="LDS_EM_+3A_tol">tol</code></td>
<td>
<p>Tolerance for likelihood convergence, default 1e-5. Note that the log-likelihood is normalized</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of model results
</p>

<ul>
<li><p> theta: model parameters (A, B, C, D, Q, R, mu1, V1) resulted from Mstep
</p>
</li>
<li><p> fit: results of Estep
</p>
</li>
<li><p> liks : vector of loglikelihood over the iteration steps
</p>
</li></ul>



<h3>Note</h3>

<p>This code only works on one dimensional state and output at the moment. Therefore, transposing is skipped, and matrix inversion is treated as /, and log(det(Sigma)) is treated as log(Sigma).
</p>

<hr>
<h2 id='LDS_EM_restart'>Learn LDS model with multiple initial conditions</h2><span id='topic+LDS_EM_restart'></span>

<h3>Description</h3>

<p>This is the backend computation for <a href="#topic+LDS_reconstruction">LDS_reconstruction</a>. You should not use this directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LDS_EM_restart(y, u, v, init, niter = 1000, tol = 1e-05, return.init = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LDS_EM_restart_+3A_y">y</code></td>
<td>
<p>Observation matrix (may need to be normalized and centered before hand) (q rows, T columns)</p>
</td></tr>
<tr><td><code id="LDS_EM_restart_+3A_u">u</code></td>
<td>
<p>Input matrix for the state equation (m_u rows, T columns)</p>
</td></tr>
<tr><td><code id="LDS_EM_restart_+3A_v">v</code></td>
<td>
<p>Input matrix for the output equation (m_v rows, T columns)</p>
</td></tr>
<tr><td><code id="LDS_EM_restart_+3A_init">init</code></td>
<td>
<p>A list of initial parameters for the EM search. See <a href="#topic+make_init">make_init</a>.</p>
</td></tr>
<tr><td><code id="LDS_EM_restart_+3A_niter">niter</code></td>
<td>
<p>Maximum number of iterations, default 1000</p>
</td></tr>
<tr><td><code id="LDS_EM_restart_+3A_tol">tol</code></td>
<td>
<p>Tolerance for likelihood convergence, default 1e-5. Note that the log-likelihood is normalized by dividing by the number of observations.</p>
</td></tr>
<tr><td><code id="LDS_EM_restart_+3A_return.init">return.init</code></td>
<td>
<p>Indicate whether the initial condition that results in the highest</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list as produced by <a href="#topic+LDS_EM">LDS_EM</a>. If return.init is true, a vector of initial condition is included in the list as well.
</p>

<hr>
<h2 id='LDS_GA'>Learn a linear dynamical system using Genetic Algorithm.</h2><span id='topic+LDS_GA'></span>

<h3>Description</h3>

<p><strong>Warning</strong> This is an experimental feature. Use with care.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LDS_GA(
  y,
  u,
  v,
  lambda = 1,
  ub,
  lb,
  num.islands = 4,
  pop.per.island = 100,
  niter = 1000,
  parallel = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LDS_GA_+3A_y">y</code></td>
<td>
<p>Transformed and standardized streamflow</p>
</td></tr>
<tr><td><code id="LDS_GA_+3A_u">u</code></td>
<td>
<p>Input matrix for a single-model reconstruction, or a list of input matrices for an ensemble reconstruction.</p>
</td></tr>
<tr><td><code id="LDS_GA_+3A_v">v</code></td>
<td>
<p>Same as u.</p>
</td></tr>
<tr><td><code id="LDS_GA_+3A_lambda">lambda</code></td>
<td>
<p>weight for penalty</p>
</td></tr>
<tr><td><code id="LDS_GA_+3A_ub">ub</code></td>
<td>
<p>Upper bounds, a vector whose length is the number of parameters</p>
</td></tr>
<tr><td><code id="LDS_GA_+3A_lb">lb</code></td>
<td>
<p>Lower bounds</p>
</td></tr>
<tr><td><code id="LDS_GA_+3A_num.islands">num.islands</code></td>
<td>
<p>Number of islands (if method is GA; experimental)</p>
</td></tr>
<tr><td><code id="LDS_GA_+3A_pop.per.island">pop.per.island</code></td>
<td>
<p>Initial population per island (if method is GA; experimental)</p>
</td></tr>
<tr><td><code id="LDS_GA_+3A_niter">niter</code></td>
<td>
<p>Maximum number of iterations, default 1000</p>
</td></tr>
<tr><td><code id="LDS_GA_+3A_parallel">parallel</code></td>
<td>
<p>Logical, whether parallel computation is used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of reconstruction results; see <a href="#topic+LDS_reconstruction">LDS_reconstruction</a>
</p>

<hr>
<h2 id='LDS_reconstruction'>Learn LDS model.</h2><span id='topic+LDS_reconstruction'></span>

<h3>Description</h3>

<p>The initial conditions can either be randomized (specifiled by num.restarts) or provided beforehand.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LDS_reconstruction(
  Qa,
  u,
  v,
  start.year,
  method = "EM",
  transform = "log",
  init = NULL,
  num.restarts = 50,
  return.init = FALSE,
  ub = NULL,
  lb = NULL,
  num.islands = 4,
  pop.per.island = 250,
  niter = 1000,
  tol = 1e-05,
  return.raw = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LDS_reconstruction_+3A_qa">Qa</code></td>
<td>
<p>Observations: a data.frame of annual streamflow with at least two columns: year and Qa.</p>
</td></tr>
<tr><td><code id="LDS_reconstruction_+3A_u">u</code></td>
<td>
<p>Input matrix for a single-model reconstruction, or a list of input matrices for an ensemble reconstruction.</p>
</td></tr>
<tr><td><code id="LDS_reconstruction_+3A_v">v</code></td>
<td>
<p>Same as u.</p>
</td></tr>
<tr><td><code id="LDS_reconstruction_+3A_start.year">start.year</code></td>
<td>
<p>Starting year of the climate proxies, i.e, the first year of the paleo period. <code>start.year + nrow(pc) - 1</code> will determine the last year of the study horizon, which must be greater than or equal to the last year in <code>Qa</code>.</p>
</td></tr>
<tr><td><code id="LDS_reconstruction_+3A_method">method</code></td>
<td>
<p>By default this is &quot;EM&quot;. There are experimental methods but you should not try.</p>
</td></tr>
<tr><td><code id="LDS_reconstruction_+3A_transform">transform</code></td>
<td>
<p>Flow transformation, either &quot;log&quot;, &quot;boxcox&quot; or &quot;none&quot;. Note that if the Box-Cox transform is used, the confidence interval after back-transformation is simply the back-transform of the trained onfidence interval; this is hackish and not entirely accurate.</p>
</td></tr>
<tr><td><code id="LDS_reconstruction_+3A_init">init</code></td>
<td>
<p>A list, each element is a vector of initial values for the parameters. If <code>NULL</code>, will be created by <code>make_init()</code>. See <a href="#topic+make_init">make_init</a> for details.</p>
</td></tr>
<tr><td><code id="LDS_reconstruction_+3A_num.restarts">num.restarts</code></td>
<td>
<p>The number of initial conditions to start the EM search; ignored if <code>init</code> is provided.</p>
</td></tr>
<tr><td><code id="LDS_reconstruction_+3A_return.init">return.init</code></td>
<td>
<p>If <code>TRUE</code>, the list of initial values (<code>init</code>) will be returned. This can be useful if you want to reproduce the model from this one set of initial values.</p>
</td></tr>
<tr><td><code id="LDS_reconstruction_+3A_ub">ub</code></td>
<td>
<p>Upper bounds, a vector whose length is the number of parameters</p>
</td></tr>
<tr><td><code id="LDS_reconstruction_+3A_lb">lb</code></td>
<td>
<p>Lower bounds</p>
</td></tr>
<tr><td><code id="LDS_reconstruction_+3A_num.islands">num.islands</code></td>
<td>
<p>Number of islands (if method is GA; experimental)</p>
</td></tr>
<tr><td><code id="LDS_reconstruction_+3A_pop.per.island">pop.per.island</code></td>
<td>
<p>Initial population per island (if method is GA; experimental)</p>
</td></tr>
<tr><td><code id="LDS_reconstruction_+3A_niter">niter</code></td>
<td>
<p>Maximum number of iterations, default 1000</p>
</td></tr>
<tr><td><code id="LDS_reconstruction_+3A_tol">tol</code></td>
<td>
<p>Tolerance for likelihood convergence, default 1e-5. Note that the log-likelihood is normalized by dividing by the number of observations.</p>
</td></tr>
<tr><td><code id="LDS_reconstruction_+3A_return.raw">return.raw</code></td>
<td>
<p>If TRUE, state and streamflow estimates without measurement updates will be returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of the following elements
</p>

<ul>
<li><p> rec: reconstruction results, a data.table with the following columns
</p>

<ul>
<li><p> year: calculated from Qa and the length of u
</p>
</li>
<li><p> X: the estimated hidden state
</p>
</li>
<li><p> Xl, Xu: lower and upper range for the 95\
</p>
</li>
<li><p> Q: the reconstructed streamflow
</p>
</li>
<li><p> Ql, Qu: lower and upper range for the 95\
</p>
</li></ul>

</li>
<li><p> theta: model parameters
</p>
</li>
<li><p> lik: maximum likelihood
</p>
</li>
<li><p> init: the initial condition that resulted in the maximum likelihood (if <code>return.init = TRUE</code>).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Make a shorter time horizon so that this example runs fast
u &lt;- v &lt;- t(NPpc[601:813])
# We run this example without parallelism
foreach::registerDoSEQ()
LDS_reconstruction(NPannual, u, v, start.year = 1800, num.restarts = 1)
# Please refer to the vignette for the full run with parallel options. It takes a second or two.
</code></pre>

<hr>
<h2 id='LDS_rep'>Multiple LDS replicates</h2><span id='topic+LDS_rep'></span>

<h3>Description</h3>

<p>Generate multiple stochastic time series from an LDS model. This is a convenient wrapper for <a href="#topic+one_LDS_rep">one_LDS_rep</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LDS_rep(
  theta,
  u = NULL,
  v = NULL,
  years,
  num.reps = 100,
  mu = 0,
  exp.trans = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LDS_rep_+3A_theta">theta</code></td>
<td>
<p>A list of parameters: A, B, C, D, Q, R, x0, v0</p>
</td></tr>
<tr><td><code id="LDS_rep_+3A_u">u</code></td>
<td>
<p>Input matrix for the state equation (m_u rows, T columns)</p>
</td></tr>
<tr><td><code id="LDS_rep_+3A_v">v</code></td>
<td>
<p>Input matrix for the output equation (m_v rows, T columns)</p>
</td></tr>
<tr><td><code id="LDS_rep_+3A_years">years</code></td>
<td>
<p>The years of the study horizon</p>
</td></tr>
<tr><td><code id="LDS_rep_+3A_num.reps">num.reps</code></td>
<td>
<p>The number of stochastic replicates#'</p>
</td></tr>
<tr><td><code id="LDS_rep_+3A_mu">mu</code></td>
<td>
<p>Mean of the log-transformed streamflow process</p>
</td></tr>
<tr><td><code id="LDS_rep_+3A_exp.trans">exp.trans</code></td>
<td>
<p>Whether exponential transformation back to the streamflow space is required.
If TRUE, both Y and Q are returned, otherwise only Y.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Same as <a href="#topic+one_LDS_rep">one_LDS_rep</a>, but the data.table consists of multiple replicates.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>LDS_rep(theta, t(NPpc), t(NPpc), 1200:2012, num.reps = 10, mu = mean(log(NPannual$Qa)))
</code></pre>

<hr>
<h2 id='make_init'>Make initial values for parameters.</h2><span id='topic+make_init'></span>

<h3>Description</h3>

<p>If init is a vector, make it a list of one element.
If init is NULL, randomize it. In this case, the function will randomize the initial value by sampling uniformly within the range for each parameters
(A in [0, 1], B in [-1, 1], C in [0, 1] and D in [-1, 1]).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_init(p, q, num.restarts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_init_+3A_p">p</code></td>
<td>
<p>Dimension of u</p>
</td></tr>
<tr><td><code id="make_init_+3A_q">q</code></td>
<td>
<p>Dimension of v</p>
</td></tr>
<tr><td><code id="make_init_+3A_num.restarts">num.restarts</code></td>
<td>
<p>Number of randomized initial values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of initial conditions, each element is an object of class <code>theta</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>make_init(5, 5, 1)
make_init(5, 5, 2)
</code></pre>

<hr>
<h2 id='make_Z'>Make cross-validation folds.</h2><span id='topic+make_Z'></span>

<h3>Description</h3>

<p>Make a list of cross-validation folds. Each element of the list is a vector of the cross-validation points for one cross-validation run.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_Z(obs, nRuns = 30, frac = 0.1, contiguous = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_Z_+3A_obs">obs</code></td>
<td>
<p>Vector of observations.</p>
</td></tr>
<tr><td><code id="make_Z_+3A_nruns">nRuns</code></td>
<td>
<p>Number of repetitions.</p>
</td></tr>
<tr><td><code id="make_Z_+3A_frac">frac</code></td>
<td>
<p>Fraction of left-out points. For leave-one-out, use <code>frac = 1</code>, otherwise use any value less than 1. Default is 0.1 (leave-10%-out).</p>
</td></tr>
<tr><td><code id="make_Z_+3A_contiguous">contiguous</code></td>
<td>
<p>Logical. If <code>TRUE</code>, the default, the left-out points are made in contiguous blocks; otherwise, they are scattered randomly.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of cross-validation folds
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Z &lt;- make_Z(NPannual, nRuns = 30, frac = 0.25, contiguous = TRUE)
</code></pre>

<hr>
<h2 id='metrics_with_transform'>Transform the estimates before calculating metrics</h2><span id='topic+metrics_with_transform'></span>

<h3>Description</h3>

<p>If you already ran the cross-validation on transformed output and now wanted to calculate performance on the back-transformed one, or vice-versa, you don't have to rerun the whole cross-validation, but just need to transform or back-transform the cross-validation Ycv. This function helps you do that.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>metrics_with_transform(cv, transform, lambda = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="metrics_with_transform_+3A_cv">cv</code></td>
<td>
<p>Cross-validation output as produced by cvLDS or cvPCR</p>
</td></tr>
<tr><td><code id="metrics_with_transform_+3A_transform">transform</code></td>
<td>
<p>Either &quot;log&quot;, &quot;exp&quot;, &quot;boxcox&quot; or &quot;inv_boxcox&quot;</p>
</td></tr>
<tr><td><code id="metrics_with_transform_+3A_lambda">lambda</code></td>
<td>
<p>Lambda value used in Box-Cox or inverse Box-Cox</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A new cv object wit hthe new metrics
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Cross-validate with log-transform
cv &lt;- cvPCR(NPannual, NPpc, start.year = 1200, transform = 'log', metric.space = 'transformed')
# Calculate metrics based on back-transformed values
m &lt;- metrics_with_transform(cv, 'exp')
</code></pre>

<hr>
<h2 id='Mstep'>Maximizing expected likelihood using analytical solution</h2><span id='topic+Mstep'></span>

<h3>Description</h3>

<p>Maximizing expected likelihood using analytical solution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Mstep(y, u, v, fit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Mstep_+3A_y">y</code></td>
<td>
<p>Observation matrix (may need to be normalized and centered before hand) (q rows, T columns)</p>
</td></tr>
<tr><td><code id="Mstep_+3A_u">u</code></td>
<td>
<p>Input matrix for the state equation (m_u rows, T columns)</p>
</td></tr>
<tr><td><code id="Mstep_+3A_v">v</code></td>
<td>
<p>Input matrix for the output equation (m_v rows, T columns)</p>
</td></tr>
<tr><td><code id="Mstep_+3A_fit">fit</code></td>
<td>
<p>result of <a href="#topic+Kalman_smoother">Kalman_smoother</a></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>theta</code>: a list of
</p>

<hr>
<h2 id='negLogLik'>Calculates the negative log-likelihood</h2><span id='topic+negLogLik'></span>

<h3>Description</h3>

<p>Calculates the negative log-likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>negLogLik(theta, u, v, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="negLogLik_+3A_theta">theta</code></td>
<td>
<p>A vector of model parameters, to be converted to a list</p>
</td></tr>
<tr><td><code id="negLogLik_+3A_u">u</code></td>
<td>
<p>Input matrix</p>
</td></tr>
<tr><td><code id="negLogLik_+3A_v">v</code></td>
<td>
<p>Input matrix</p>
</td></tr>
<tr><td><code id="negLogLik_+3A_y">y</code></td>
<td>
<p>Observations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The negative log-likelihood
</p>

<hr>
<h2 id='NPannual'>Annual streamflow at Nakhon Phanom</h2><span id='topic+NPannual'></span>

<h3>Description</h3>

<p>A dataset contaning annual streamflow of the Mekong River measured at station Nakhon Phanom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NPannual
</code></pre>


<h3>Format</h3>

<p>A data.table with two columns
</p>

<dl>
<dt>year</dt><dd><p>from 1960 to 2005</p>
</dd>
<dt>Qa</dt><dd><p>mean annual streamflow, cubic meter per second</p>
</dd>
</dl>



<h3>Source</h3>

<p>Mekong River Commission
</p>

<hr>
<h2 id='NPpc'>Selected principal components</h2><span id='topic+NPpc'></span>

<h3>Description</h3>

<p>A dataset contaning the principal components of MADA surrounding NP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NPpc
</code></pre>


<h3>Format</h3>

<p>A data.table
</p>

<hr>
<h2 id='nRMSE'>Normalized root-mean-square error</h2><span id='topic+nRMSE'></span>

<h3>Description</h3>

<p>RMSE is normalized by the normalization constant
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nRMSE(yhat, y, normConst)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nRMSE_+3A_yhat">yhat</code></td>
<td>
<p>Model outputs</p>
</td></tr>
<tr><td><code id="nRMSE_+3A_y">y</code></td>
<td>
<p>Observations</p>
</td></tr>
<tr><td><code id="nRMSE_+3A_normconst">normConst</code></td>
<td>
<p>The normalization constant</p>
</td></tr>
</table>


<h3>Value</h3>

<p>normalized RMSE
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100)
y &lt;- rnorm(100)
nRMSE(x, y, sd(y))
</code></pre>

<hr>
<h2 id='NSE'>Nash-Sutcliffe Efficiency</h2><span id='topic+NSE'></span>

<h3>Description</h3>

<p>Nash-Sutcliffe Efficiency
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NSE(yhat, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NSE_+3A_yhat">yhat</code></td>
<td>
<p>Model outputs</p>
</td></tr>
<tr><td><code id="NSE_+3A_y">y</code></td>
<td>
<p>Observations</p>
</td></tr>
</table>


<h3>Value</h3>

<p>NSE
</p>


<h3>Examples</h3>

<pre><code class='language-R'>NSE(rnorm(100), rnorm(100))
</code></pre>

<hr>
<h2 id='one_lds_cv'>One cross-validation run</h2><span id='topic+one_lds_cv'></span>

<h3>Description</h3>

<p>Make one prediction for one cross-validation run. This is a subroutine that is called by cvLDS, without any checks. You should not need to use this directly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>one_lds_cv(
  z,
  instPeriod,
  mu,
  y,
  u,
  v,
  method = "EM",
  num.restarts = 20,
  ub = NULL,
  lb = NULL,
  num.islands = 4,
  pop.per.island = 100,
  niter = 1000,
  tol = 1e-06,
  use.raw = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="one_lds_cv_+3A_z">z</code></td>
<td>
<p>A vector of left-out points, indexed according to the intrumental period</p>
</td></tr>
<tr><td><code id="one_lds_cv_+3A_instperiod">instPeriod</code></td>
<td>
<p>indices of the instrumental period in the whole record</p>
</td></tr>
<tr><td><code id="one_lds_cv_+3A_mu">mu</code></td>
<td>
<p>Mean of the observations</p>
</td></tr>
<tr><td><code id="one_lds_cv_+3A_y">y</code></td>
<td>
<p>Catchment output, preprocessed from data</p>
</td></tr>
<tr><td><code id="one_lds_cv_+3A_u">u</code></td>
<td>
<p>Input matrix for a single-model reconstruction, or a list of input matrices for an ensemble reconstruction.</p>
</td></tr>
<tr><td><code id="one_lds_cv_+3A_v">v</code></td>
<td>
<p>Same as u.</p>
</td></tr>
<tr><td><code id="one_lds_cv_+3A_method">method</code></td>
<td>
<p>By default this is &quot;EM&quot;. There are experimental methods but you should not try.</p>
</td></tr>
<tr><td><code id="one_lds_cv_+3A_num.restarts">num.restarts</code></td>
<td>
<p>The number of initial conditions to start the EM search; ignored if <code>init</code> is provided.</p>
</td></tr>
<tr><td><code id="one_lds_cv_+3A_ub">ub</code></td>
<td>
<p>Upper bounds, a vector whose length is the number of parameters</p>
</td></tr>
<tr><td><code id="one_lds_cv_+3A_lb">lb</code></td>
<td>
<p>Lower bounds</p>
</td></tr>
<tr><td><code id="one_lds_cv_+3A_num.islands">num.islands</code></td>
<td>
<p>Number of islands (if method is GA; experimental)</p>
</td></tr>
<tr><td><code id="one_lds_cv_+3A_pop.per.island">pop.per.island</code></td>
<td>
<p>Initial population per island (if method is GA; experimental)</p>
</td></tr>
<tr><td><code id="one_lds_cv_+3A_niter">niter</code></td>
<td>
<p>Maximum number of iterations, default 1000</p>
</td></tr>
<tr><td><code id="one_lds_cv_+3A_tol">tol</code></td>
<td>
<p>Tolerance for likelihood convergence, default 1e-5. Note that the log-likelihood is normalized by dividing by the number of observations.</p>
</td></tr>
<tr><td><code id="one_lds_cv_+3A_use.raw">use.raw</code></td>
<td>
<p>Whether performance metrics are calculated on the raw time series. Experimental; don't use.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of prediction.
</p>

<hr>
<h2 id='one_LDS_rep'>One LDS replicate</h2><span id='topic+one_LDS_rep'></span>

<h3>Description</h3>

<p>Generate a single stochastic time series from an LDS model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>one_LDS_rep(
  rep.num,
  theta,
  u = NULL,
  v = NULL,
  years,
  mu = 0,
  exp.trans = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="one_LDS_rep_+3A_rep.num">rep.num</code></td>
<td>
<p>The ID number of the replicate</p>
</td></tr>
<tr><td><code id="one_LDS_rep_+3A_theta">theta</code></td>
<td>
<p>A list of parameters: A, B, C, D, Q, R, x0, v0</p>
</td></tr>
<tr><td><code id="one_LDS_rep_+3A_u">u</code></td>
<td>
<p>Input matrix for the state equation (m_u rows, T columns)</p>
</td></tr>
<tr><td><code id="one_LDS_rep_+3A_v">v</code></td>
<td>
<p>Input matrix for the output equation (m_v rows, T columns)</p>
</td></tr>
<tr><td><code id="one_LDS_rep_+3A_years">years</code></td>
<td>
<p>The years of the study horizon</p>
</td></tr>
<tr><td><code id="one_LDS_rep_+3A_mu">mu</code></td>
<td>
<p>Mean of the log-transformed streamflow process</p>
</td></tr>
<tr><td><code id="one_LDS_rep_+3A_exp.trans">exp.trans</code></td>
<td>
<p>Whether exponential transformation back to the streamflow space is required.
If TRUE, both Y and Q are returned, otherwise only Y.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table. The first column is the years of the study horizon, as supplied by <code>year</code>.
Subsequent columns are <code>simX</code>, <code>simY</code>, and <code>simQ</code> which are the simulated catchment state (X),
log-transformed and centralized flow (Y) and flow (Q). The last column is the replicate ID number.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Learn theta
one_LDS_rep(1, theta, t(NPpc), t(NPpc), 1200:2012, mu = mean(log(NPannual$Qa)))
</code></pre>

<hr>
<h2 id='one_pcr_cv'>One cross-validation run</h2><span id='topic+one_pcr_cv'></span>

<h3>Description</h3>

<p>Make one prediction for one cross-validation run. This is a subroutine to be called by other cross-validation functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>one_pcr_cv(df, z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="one_pcr_cv_+3A_df">df</code></td>
<td>
<p>The training data, with one column named y, the (transformed) observations. and other columns the predictors.</p>
</td></tr>
<tr><td><code id="one_pcr_cv_+3A_z">z</code></td>
<td>
<p>A vector of left-out points</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of prediction.
</p>

<hr>
<h2 id='PCR_ensemble_selection'>Select the best reconstruction</h2><span id='topic+PCR_ensemble_selection'></span>

<h3>Description</h3>

<p>Select the best reconstruction from an ensemble. Experimental, API may change.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCR_ensemble_selection(
  Qa,
  pc,
  start.year,
  transform = "log",
  Z = NULL,
  agg.type = c("best member", "best overall"),
  criterion = c("RE", "CE", "nRMSE", "KGE"),
  return.all.metrics = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PCR_ensemble_selection_+3A_qa">Qa</code></td>
<td>
<p>Observations: a data.frame of annual streamflow with at least two columns: year and Qa.</p>
</td></tr>
<tr><td><code id="PCR_ensemble_selection_+3A_pc">pc</code></td>
<td>
<p>For a single model: a data.frame, one column for each principal component. For an ensemble reconstruction: a list, each element is a data.frame of principal components.</p>
</td></tr>
<tr><td><code id="PCR_ensemble_selection_+3A_start.year">start.year</code></td>
<td>
<p>Starting year of the climate proxies, i.e, the first year of the paleo period. <code>start.year + nrow(pc) - 1</code> will determine the last year of the study horizon, which must be greater than or equal to the last year in <code>Qa</code>.</p>
</td></tr>
<tr><td><code id="PCR_ensemble_selection_+3A_transform">transform</code></td>
<td>
<p>Flow transformation, either &quot;log&quot;, &quot;boxcox&quot; or &quot;none&quot;. Note that if the Box-Cox transform is used, the confidence interval after back-transformation is simply the back-transform of the trained onfidence interval; this is hackish and not entirely accurate.</p>
</td></tr>
<tr><td><code id="PCR_ensemble_selection_+3A_z">Z</code></td>
<td>
<p>A list of cross-validation folds. If <code>NULL</code>, will be created with <code>make_Z()</code> with default settings. Users are advised to use <code>make_Z()</code> to create the cross-validation folds beforehand. See <a href="#topic+make_Z">make_Z</a> for details.</p>
</td></tr>
<tr><td><code id="PCR_ensemble_selection_+3A_agg.type">agg.type</code></td>
<td>
<p>Type of ensemble aggregate. There are 2 options: 'best member': the member with the best performance score is used; 'best overall': if the ensemble average is better than the best member, it will be used, otherwise the best member will be used.</p>
</td></tr>
<tr><td><code id="PCR_ensemble_selection_+3A_criterion">criterion</code></td>
<td>
<p>The performance criterion to be used.</p>
</td></tr>
<tr><td><code id="PCR_ensemble_selection_+3A_return.all.metrics">return.all.metrics</code></td>
<td>
<p>Logical, if TRUE, all members' performance scores (and the ensemble average's score, if <code>agg.type == 'best overall'</code>) are returned.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of two elements:
</p>

<ul>
<li><p> choice: The index of the selection. If the ensemble is selected, returns 0.
</p>
</li>
<li><p> cv: the cross-validation results of the choice, see <a href="#topic+cvPCR">cvPCR</a> for details.
</p>
</li>
<li><p> all.metrics: all members' scores, and if <code>agg.type == 'best overall'</code>, the ensemble average's scores as well, in the last column.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>PCR_ensemble_selection(NPannual, list(NPpc, NPpc[, 1:2]), start.year = 1200,
                       agg.type = 'best overall', criterion = 'KGE')
PCR_ensemble_selection(NPannual, list(NPpc, NPpc[, 1:2]), start.year = 1200,
                       agg.type = 'best overall', criterion = 'KGE')
</code></pre>

<hr>
<h2 id='PCR_reconstruction'>Principal Component Regression Reconstruction</h2><span id='topic+PCR_reconstruction'></span>

<h3>Description</h3>

<p>Reconstruction with principal component linear regression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PCR_reconstruction(Qa, pc, start.year, transform = "log")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PCR_reconstruction_+3A_qa">Qa</code></td>
<td>
<p>Observations: a data.frame of annual streamflow with at least two columns: year and Qa.</p>
</td></tr>
<tr><td><code id="PCR_reconstruction_+3A_pc">pc</code></td>
<td>
<p>For a single model: a data.frame, one column for each principal component. For an ensemble reconstruction: a list, each element is a data.frame of principal components.</p>
</td></tr>
<tr><td><code id="PCR_reconstruction_+3A_start.year">start.year</code></td>
<td>
<p>Starting year of the climate proxies, i.e, the first year of the paleo period. <code>start.year + nrow(pc) - 1</code> will determine the last year of the study horizon, which must be greater than or equal to the last year in <code>Qa</code>.</p>
</td></tr>
<tr><td><code id="PCR_reconstruction_+3A_transform">transform</code></td>
<td>
<p>Flow transformation, either &quot;log&quot;, &quot;boxcox&quot; or &quot;none&quot;. Note that if the Box-Cox transform is used, the confidence interval after back-transformation is simply the back-transform of the trained onfidence interval; this is hackish and not entirely accurate.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of reconstruction results, with the following elements:
</p>


<h4>For a single-model reconstruction:</h4>


<ul>
<li><p> rec: reconstructed streamflow with 95% prediction interval; a data.table with four columns: year, Q, Ql (lower bound), and Qu (upper bound).
</p>
</li>
<li><p> coeffs: the regression coefficients.
</p>
</li>
<li><p> sigma: the residual standard deviation.
</p>
</li></ul>




<h4>For an ensemble reconstruction:</h4>


<ul>
<li><p> rec: the ensemble average reconstruction; a data.table with two columns: year and Q.
</p>
</li>
<li><p> ensemble: a list of ensemble members, each element is reconstructed from one element of <code>pc</code> and is itself a list of three elements: Q (a vector of reconstructed flow), coeffs and sigma.
Note that for ensemble reconstruction, <code>ldsr</code> does not provide uncertainty estimates. It is up to the user to do so, for example, using ensemble spread.
</p>
</li></ul>




<h3>Examples</h3>

<pre><code class='language-R'>PCR_reconstruction(NPannual, NPpc, start.year = 1200)
</code></pre>

<hr>
<h2 id='penalized_likelihood'>Penalized likelihood objective function</h2><span id='topic+penalized_likelihood'></span>

<h3>Description</h3>

<p><a href="#topic+Kalman_smoother">Kalman_smoother</a> returns X and likelihood.
The penalized likelihood is the likelihood minus the sum-of-squares of the
measurement update. This is used as the fitness function in genetic algorihm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>penalized_likelihood(y, u, v, theta.vec, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="penalized_likelihood_+3A_y">y</code></td>
<td>
<p>Observation matrix (may need to be normalized and centered before hand) (q rows, T columns)</p>
</td></tr>
<tr><td><code id="penalized_likelihood_+3A_u">u</code></td>
<td>
<p>Input matrix for the state equation (m_u rows, T columns)</p>
</td></tr>
<tr><td><code id="penalized_likelihood_+3A_v">v</code></td>
<td>
<p>Input matrix for the output equation (m_v rows, T columns)</p>
</td></tr>
<tr><td><code id="penalized_likelihood_+3A_theta.vec">theta.vec</code></td>
<td>
<p>a vector of parameter elements (i.e, the vectorized version of theta
in <code>Kalman_smoother</code>)</p>
</td></tr>
<tr><td><code id="penalized_likelihood_+3A_lambda">lambda</code></td>
<td>
<p>weight of the penalty</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The penalized likelihood (a real number)
</p>

<hr>
<h2 id='propagate'>State propagation</h2><span id='topic+propagate'></span>

<h3>Description</h3>

<p>This function propagates the state trajectory based on the exogenous inputs only
(without measurement update), and calculates the corresponding log-likelihood
</p>


<h3>Usage</h3>

<pre><code class='language-R'>propagate(theta, u, v, y, stdlik = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="propagate_+3A_theta">theta</code></td>
<td>
<p>A list of system parameters (A, B, C, D, Q, R)'</p>
</td></tr>
<tr><td><code id="propagate_+3A_u">u</code></td>
<td>
<p>Input matrix for the state equation (m_u rows, T columns)</p>
</td></tr>
<tr><td><code id="propagate_+3A_v">v</code></td>
<td>
<p>Input matrix for the output equation (m_v rows, T columns)</p>
</td></tr>
<tr><td><code id="propagate_+3A_y">y</code></td>
<td>
<p>Observations</p>
</td></tr>
<tr><td><code id="propagate_+3A_stdlik">stdlik</code></td>
<td>
<p>Boolean, whether the likelihood is divided by the number of observations. Standardizing the likelihood this way may speed up convergence in the case of long time series.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of predictions and log-likelihood (X, Y, V, lik)
</p>


<h3>Note</h3>

<p>This code only works on one dimensional state and output at the moment. Therefore, transposing is skipped, and matrix inversion is treated as /, and log(det(Sigma)) is treated as log(Sigma).
</p>

<hr>
<h2 id='RE'>Reduction of Error</h2><span id='topic+RE'></span>

<h3>Description</h3>

<p>Reduction of Error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RE(yhat, y, yc_bar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RE_+3A_yhat">yhat</code></td>
<td>
<p>Model outputs in the validation set</p>
</td></tr>
<tr><td><code id="RE_+3A_y">y</code></td>
<td>
<p>Observations in the validation set</p>
</td></tr>
<tr><td><code id="RE_+3A_yc_bar">yc_bar</code></td>
<td>
<p>Mean observations in the calibration set</p>
</td></tr>
</table>


<h3>Value</h3>

<p>RE
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100)
y &lt;- rnorm(100)
yc_bar &lt;- mean(x[1:50])
RE(x[51:100], y[51:100], yc_bar)
</code></pre>

<hr>
<h2 id='theta'>LDS parameters</h2><span id='topic+theta'></span>

<h3>Description</h3>

<p>Theta values for Nakhon Phanom, precomputed to use in examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>theta
</code></pre>


<h3>Format</h3>

<p>A list with elements A, B, C, D, Q, R, mu1, V1
</p>

<hr>
<h2 id='vec_to_list'>Converts theta from a vector (as used in GA) to list (as used in Kalman smoothing)</h2><span id='topic+vec_to_list'></span>

<h3>Description</h3>

<p>Converts theta from a vector (as used in GA) to list (as used in Kalman smoothing)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>vec_to_list(theta.vec, d)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vec_to_list_+3A_theta.vec">theta.vec</code></td>
<td>
<p>a vector of parameter elements</p>
</td></tr>
<tr><td><code id="vec_to_list_+3A_d">d</code></td>
<td>
<p>dimention of inputs</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A theta object, see <a href="#topic+make_init">make_init</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
