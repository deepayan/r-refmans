<!DOCTYPE html><html><head><title>Help for package pencal</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pencal}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#draw_cluster_bootstrap'><p>Draw a cluster bootstrap sample from a data frame in long format</p></a></li>
<li><a href='#fit_lmms'><p>Step 1 of PRC-LMM (estimation of the linear mixed models)</p></a></li>
<li><a href='#fit_mlpmms'><p>Step 1 of PRC-MLPMM (estimation of the linear mixed models)</p></a></li>
<li><a href='#fit_prclmm'><p>Step 3 of PRC-LMM (estimation of the penalized Cox model(s))</p></a></li>
<li><a href='#fit_prcmlpmm'><p>Step 3 of PRC-MLPMM (estimation of the penalized Cox model(s))</p></a></li>
<li><a href='#fitted_prclmm'><p>A fitted PRC LMM</p></a></li>
<li><a href='#fitted_prcmlpmm'><p>A fitted PRC MLPMM</p></a></li>
<li><a href='#pbc2data'><p>pbc2 dataset</p></a></li>
<li><a href='#pencox'><p>Estimation of a penalized Cox model with time-independent covariates</p></a></li>
<li><a href='#performance_pencox'><p>Predictive performance of the penalized Cox model</p>
with time-independent covariates</a></li>
<li><a href='#performance_prc'><p>Predictive performance of the PRC-LMM and PRC-MLPMM models</p></a></li>
<li><a href='#prepare_longdata'><p>Prepare longitudinal data for PRC</p></a></li>
<li><a href='#print.prclmm'><p>Print method for PRC-LMM model fits</p></a></li>
<li><a href='#print.prcmlpmm'><p>Print method for PRC-MLPMM model fits</p></a></li>
<li><a href='#simulate_prclmm_data'><p>Simulate data that can be used to fit the PRC-LMM model</p></a></li>
<li><a href='#simulate_prcmlpmm_data'><p>Simulate data that can be used to fit the PRC-LMM model</p></a></li>
<li><a href='#simulate_t_weibull'><p>Generate survival data from a Weibull model</p></a></li>
<li><a href='#summarize_lmms'><p>Step 2 of PRC-LMM (computation of the predicted random effects)</p></a></li>
<li><a href='#summarize_mlpmms'><p>Step 2 of PRC-MLPMM (computation of the predicted random effects)</p></a></li>
<li><a href='#summary.lmmfit'><p>Extract model fits from step 1 of PRC-LMM</p></a></li>
<li><a href='#summary.mlpmmfit'><p>Extract model fits from step 1 of PRC-LMM</p></a></li>
<li><a href='#summary.prclmm'><p>Summary method for PRC-LMM model fits</p></a></li>
<li><a href='#summary.prcmlpmm'><p>Summary method for PRC-MLPMM model fits</p></a></li>
<li><a href='#summary.ranefs'><p>Summary for step 2 of PRC</p></a></li>
<li><a href='#survplot_prc'><p>Visualize survival predictions for a fitted PRC model</p></a></li>
<li><a href='#survpred_prclmm'><p>Compute the predicted survival probabilities obtained</p>
from the PRC models</a></li>
<li><a href='#survpred_prcmlpmm'><p>Compute the predicted survival probabilities obtained</p>
from the PRC models</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Penalized Regression Calibration (PRC) for the Dynamic
Prediction of Survival</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>Computes penalized regression calibration (PRC), a
    statistical method for the dynamic prediction of survival when many
    longitudinal predictors are available. PRC is described in Signorelli
    et al.  (2021) &lt;<a href="https://doi.org/10.1002%2Fsim.9178">doi:10.1002/sim.9178</a>&gt; and Signorelli (2023)
    &lt;<a href="https://doi.org/10.48550%2FarXiv.2309.15600">doi:10.48550/arXiv.2309.15600</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://mirkosignorelli.github.io/r">https://mirkosignorelli.github.io/r</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.1.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>doParallel, dplyr, foreach, glmnet, lcmm, magic, MASS, Matrix,
methods, nlme, purrr, riskRegression, stats, survcomp,
survival, survivalROC</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, ptmixed, rmarkdown, survminer</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-31 20:03:04 UTC; ms</td>
</tr>
<tr>
<td>Author:</td>
<td>Mirko Signorelli <a href="https://orcid.org/0000-0002-8102-3356"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Pietro Spitali [ctb],
  Roula Tsonaka [ctb],
  Barbara Vreede [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mirko Signorelli &lt;msignorelli.rpackages@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-31 20:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='draw_cluster_bootstrap'>Draw a cluster bootstrap sample from a data frame in long format</h2><span id='topic+draw_cluster_bootstrap'></span>

<h3>Description</h3>

<p>This function is part of the cluster bootstrap optimism correction
procedure described in Signorelli et al. (2021). Note 
that the function does not perform the random sampling, but it
extracts the correct records from a dataframe, given the ids of
the sampled clusters (subjects)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>draw_cluster_bootstrap(df, idvar, boot.ids)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="draw_cluster_bootstrap_+3A_df">df</code></td>
<td>
<p>a data frame in long format</p>
</td></tr>
<tr><td><code id="draw_cluster_bootstrap_+3A_idvar">idvar</code></td>
<td>
<p>name of the subject id in <code>df</code> (it should be a
numeric id that ranges from 1 to n, without skipping values)</p>
</td></tr>
<tr><td><code id="draw_cluster_bootstrap_+3A_boot.ids">boot.ids</code></td>
<td>
<p>identifiers of the subjects to be sampled</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the bootstrapped observations
</p>


<h3>Author(s)</h3>

<p>Mirko Signorelli
</p>


<h3>References</h3>

<p>Signorelli, M. (2023). pencal: an R Package for the Dynamic 
Prediction of Survival with Many Longitudinal Predictors.
arXiv preprint: arXiv:2309.15600
</p>
<p>Signorelli, M., Spitali, P., Al-Khalili Szigyarto, C, 
The MARK-MD Consortium, Tsonaka, R. (2021). 
Penalized regression calibration: a method for the prediction 
of survival outcomes using complex longitudinal and 
high-dimensional data. Statistics in Medicine, 40 (27), 6178-6196.
DOI: 10.1002/sim.9178
</p>

<hr>
<h2 id='fit_lmms'>Step 1 of PRC-LMM (estimation of the linear mixed models)</h2><span id='topic+fit_lmms'></span>

<h3>Description</h3>

<p>This function performs the first step for the estimation
of the PRC-LMM model proposed in Signorelli et al. (2021)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_lmms(y.names, fixefs, ranefs, long.data, surv.data, t.from.base,
  n.boots = 0, n.cores = 1, max.ymissing = 0.2, verbose = TRUE,
  seed = 123, control = list(opt = "optim", niterEM = 500, maxIter = 500))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_lmms_+3A_y.names">y.names</code></td>
<td>
<p>character vector with the names of the
response variables which the LMMs have to be fitted to</p>
</td></tr>
<tr><td><code id="fit_lmms_+3A_fixefs">fixefs</code></td>
<td>
<p>fixed effects formula for the model, example:
<code>~ time</code></p>
</td></tr>
<tr><td><code id="fit_lmms_+3A_ranefs">ranefs</code></td>
<td>
<p>random effects formula for the model,
specified using the representation of random effect
structures of the <code>R</code> package <code>nlme</code></p>
</td></tr>
<tr><td><code id="fit_lmms_+3A_long.data">long.data</code></td>
<td>
<p>a data frame with the longitudinal predictors,
comprehensive of a variable called <code>id</code> with the subject 
ids</p>
</td></tr>
<tr><td><code id="fit_lmms_+3A_surv.data">surv.data</code></td>
<td>
<p>a data frame with the survival data and (if 
relevant) additional baseline covariates. <code>surv.data</code> should at least
contain a subject id (called <code>id</code>), the time to event outcome  
(<code>time</code>), and binary event variable (<code>event</code>)</p>
</td></tr>
<tr><td><code id="fit_lmms_+3A_t.from.base">t.from.base</code></td>
<td>
<p>name of the variable containing time from 
baseline in <code>long.data</code></p>
</td></tr>
<tr><td><code id="fit_lmms_+3A_n.boots">n.boots</code></td>
<td>
<p>number of bootstrap samples to be used in the
cluster bootstrap optimism correction procedure (CBOCP). If 0, no
bootstrapping is performed</p>
</td></tr>
<tr><td><code id="fit_lmms_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores to use to parallelize part of
the computations. If <code>ncores = 1</code> (default), 
no parallelization is done. Pro tip: you can use 
<code>parallel::detectCores()</code> to check how many 
cores are available on your computer</p>
</td></tr>
<tr><td><code id="fit_lmms_+3A_max.ymissing">max.ymissing</code></td>
<td>
<p>maximum proportion of subjects allowed to not have any
measurement of a longitudinal response variable. Default is 0.2</p>
</td></tr>
<tr><td><code id="fit_lmms_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default and recommended value), information
on the ongoing computations is printed in the console</p>
</td></tr>
<tr><td><code id="fit_lmms_+3A_seed">seed</code></td>
<td>
<p>random seed used for the bootstrap sampling. Default 
is <code>seed = 123</code></p>
</td></tr>
<tr><td><code id="fit_lmms_+3A_control">control</code></td>
<td>
<p>a list of control values to be passed to <code>lme</code> when fitting the
linear mixed models. By default, we set <code>opt = 'optim', niterEM = 500, maxIter = 500</code>. 
See <code>?nlme::lmeControl</code> for all possible arguments and values</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following objects:
</p>

<ul>
<li> <p><code>call.info</code>: a list containing the following function
call information: <code>call</code>, <code>y.names</code>, <code>fixefs</code>,
<code>ranefs</code>;
</p>
</li>
<li> <p><code>lmm.fits.orig</code>: a list with the LMMs fitted on the
original dataset (it should comprise as many LMMs as the elements
of <code>y.names</code> are);
</p>
</li>
<li> <p><code>df.sanitized</code>: a sanitized version of the supplied 
<code>long.data</code> dataframe, without the
longitudinal measurements that are taken after the event
or after censoring;
</p>
</li>
<li> <p><code>n.boots</code>: number of bootstrap samples;
</p>
</li>
<li> <p><code>boot.ids</code>: a list with the ids of bootstrapped subjects 
(when <code>n.boots &gt; 0</code>);
</p>
</li>
<li> <p><code>lmms.fits.boot</code>: a list of lists, which contains the LMMs fitted 
on each bootstrapped datasets (when <code>n.boots &gt; 0</code>).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Mirko Signorelli
</p>


<h3>References</h3>

<p>Signorelli, M. (2023). pencal: an R Package for the Dynamic 
Prediction of Survival with Many Longitudinal Predictors.
arXiv preprint: arXiv:2309.15600
</p>
<p>Signorelli, M., Spitali, P., Al-Khalili Szigyarto, C, 
The MARK-MD Consortium, Tsonaka, R. (2021). 
Penalized regression calibration: a method for the prediction 
of survival outcomes using complex longitudinal and 
high-dimensional data. Statistics in Medicine, 40 (27), 6178-6196.
DOI: 10.1002/sim.9178
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate_prclmm_data">simulate_prclmm_data</a></code>,
<code><a href="#topic+summarize_lmms">summarize_lmms</a></code> (step 2),
<code><a href="#topic+fit_prclmm">fit_prclmm</a></code> (step 3),
<code><a href="#topic+performance_prc">performance_prc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate example data
set.seed(1234)
p = 4 # number of longitudinal predictors
simdata = simulate_prclmm_data(n = 100, p = p, p.relev = 2, 
             seed = 123, t.values = c(0, 0.2, 0.5, 1, 1.5, 2))
 
# specify options for cluster bootstrap optimism correction
# procedure and for parallel computing 
do.bootstrap = FALSE
# IMPORTANT: set do.bootstrap = TRUE to compute the optimism correction!
n.boots = ifelse(do.bootstrap, 100, 0)
more.cores = FALSE
# IMPORTANT: set more.cores = TRUE to parallelize and speed computations up!
if (!more.cores) n.cores = 1
if (more.cores) {
   # identify number of available cores on your machine
   n.cores = parallel::detectCores()
   if (is.na(n.cores)) n.cores = 8
}

# step 1 of PRC-LMM: estimate the LMMs
y.names = paste('marker', 1:p, sep = '')
step1 = fit_lmms(y.names = y.names, 
                 fixefs = ~ age, ranefs = ~ age | id, 
                 long.data = simdata$long.data, 
                 surv.data = simdata$surv.data,
                 t.from.base = t.from.base,
                 n.boots = n.boots, n.cores = n.cores)
# estimated betas and variances for the 3rd marker:
summary(step1, 'marker3', 'betas')
summary(step1, 'marker3', 'variances')
# usual T table:
summary(step1, 'marker3', 'tTable')
</code></pre>

<hr>
<h2 id='fit_mlpmms'>Step 1 of PRC-MLPMM (estimation of the linear mixed models)</h2><span id='topic+fit_mlpmms'></span>

<h3>Description</h3>

<p>This function performs the first step for the estimation
of the PRC-MLPMM model proposed in Signorelli et al. (2021)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_mlpmms(y.names, fixefs, ranef.time, randint.items = TRUE, long.data,
  surv.data, t.from.base, n.boots = 0, n.cores = 1, verbose = TRUE,
  seed = 123, maxiter = 100, conv = rep(0.001, 3),
  lcmm.warnings = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_mlpmms_+3A_y.names">y.names</code></td>
<td>
<p>a list with the names of the
response variables which the MLPMMs have to be fitted to.
Each element in the list contains all the items used to 
reconstruct a latent biological process of interest</p>
</td></tr>
<tr><td><code id="fit_mlpmms_+3A_fixefs">fixefs</code></td>
<td>
<p>a fixed effects formula for the model, where the
time variable (specified also in <code>ranef.time</code>) is
included as first element and within the function 
<code>contrast()</code>. Examples: <code>~ contrast(age)</code>, 
<code>~ contrast(age) + group + treatment</code></p>
</td></tr>
<tr><td><code id="fit_mlpmms_+3A_ranef.time">ranef.time</code></td>
<td>
<p>a character with the name of the time variable 
for which to include a shared random slope</p>
</td></tr>
<tr><td><code id="fit_mlpmms_+3A_randint.items">randint.items</code></td>
<td>
<p>logical: should item-specific random intercepts
be included in the MLCMMs? Default is <code>TRUE</code>. It can also be a
vector, with different values for different elements of <code>y.names</code></p>
</td></tr>
<tr><td><code id="fit_mlpmms_+3A_long.data">long.data</code></td>
<td>
<p>a data frame with the longitudinal predictors,
comprehensive of a variable called <code>id</code> with the subject 
ids</p>
</td></tr>
<tr><td><code id="fit_mlpmms_+3A_surv.data">surv.data</code></td>
<td>
<p>a data frame with the survival data and (if 
relevant) additional baseline covariates. <code>surv.data</code> should at least
contain a subject id (called <code>id</code>), the time to event outcome  
(<code>time</code>), and binary event variable (<code>event</code>)</p>
</td></tr>
<tr><td><code id="fit_mlpmms_+3A_t.from.base">t.from.base</code></td>
<td>
<p>name of the variable containing time from 
baseline in <code>long.data</code></p>
</td></tr>
<tr><td><code id="fit_mlpmms_+3A_n.boots">n.boots</code></td>
<td>
<p>number of bootstrap samples to be used in the
cluster bootstrap optimism correction procedure (CBOCP). If 0, no
bootstrapping is performed</p>
</td></tr>
<tr><td><code id="fit_mlpmms_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores to use to parallelize part of
the computations. If <code>ncores = 1</code> (default), 
no parallelization is done. Pro tip: you can use 
<code>parallel::detectCores()</code> to check how many 
cores are available on your computer</p>
</td></tr>
<tr><td><code id="fit_mlpmms_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default and recommended value), information
on the ongoing computations is printed in the console</p>
</td></tr>
<tr><td><code id="fit_mlpmms_+3A_seed">seed</code></td>
<td>
<p>random seed used for the bootstrap sampling. Default 
is <code>seed = 123</code></p>
</td></tr>
<tr><td><code id="fit_mlpmms_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations to use when calling
the function <code>multlcmm</code>. Default is 100</p>
</td></tr>
<tr><td><code id="fit_mlpmms_+3A_conv">conv</code></td>
<td>
<p>a vector containing the three convergence criteria
(<code>convB</code>, <code>convL</code> and <code>convG</code>) to use when calling
the function <code><a href="lcmm.html#topic+multlcmm">multlcmm</a></code>. Default is c(1e-3, 1e-3, 1e-3)</p>
</td></tr>
<tr><td><code id="fit_mlpmms_+3A_lcmm.warnings">lcmm.warnings</code></td>
<td>
<p>logical. If TRUE, a warning is printed every 
time the (strict) convergence criteria of the <code>multlcmm</code> function
are not met. Default is <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is essentially a wrapper of the 
<code><a href="lcmm.html#topic+multlcmm">multlcmm</a></code> function that has the goal of simplifying
the estimation of several MLPMMs. In general, ensuring 
convergence of the algorithm implemented in <code>multlcmm</code>
is sometimes difficult, and it is hard to write a function that
can automatically solve these convergence problems. <code>fit_mplmms</code>
returns a warning when estimation did not converge for one or 
more MLPMMs. If this happens, try to change the convergence 
criteria in <code>conv</code> or the relevant <code>randint.items</code> value.
If doing this doesn't solve the problem, it is recommended to
re-estimate the specific MLPMMs for which estimation didn't converge
directly with <code><a href="lcmm.html#topic+multlcmm">multlcmm</a></code>, trying to manually solve
the convergence issues
</p>


<h3>Value</h3>

<p>A list containing the following objects:
</p>

<ul>
<li> <p><code>call.info</code>: a list containing the following function
call information: <code>call</code>, <code>y.names</code>, <code>fixefs</code>,
<code>ranef.time</code>, <code>randint.items</code>;
</p>
</li>
<li> <p><code>mlpmm.fits.orig</code>: a list with the MLPMMs fitted on the
original dataset (it should comprise as many MLPMMs as the elements
of <code>y.names</code> are);
</p>
</li>
<li> <p><code>df.sanitized</code>: a sanitized version of the supplied 
<code>long.data</code> dataframe, without the
longitudinal measurements that are taken after the event
or after censoring;
</p>
</li>
<li> <p><code>n.boots</code>: number of bootstrap samples;
</p>
</li>
<li> <p><code>boot.ids</code>: a list with the ids of bootstrapped subjects 
(when <code>n.boots &gt; 0</code>);
</p>
</li>
<li> <p><code>mlpmm.fits.boot</code>: a list of lists, which contains the MLPMMs 
fitted on each bootstrapped datasets (when <code>n.boots &gt; 0</code>).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Mirko Signorelli
</p>


<h3>References</h3>

<p>Signorelli, M. (2023). pencal: an R Package for the Dynamic 
Prediction of Survival with Many Longitudinal Predictors.
arXiv preprint: arXiv:2309.15600
</p>
<p>Signorelli, M., Spitali, P., Al-Khalili Szigyarto, C, 
The MARK-MD Consortium, Tsonaka, R. (2021). 
Penalized regression calibration: a method for the prediction 
of survival outcomes using complex longitudinal and 
high-dimensional data. Statistics in Medicine, 40 (27), 6178-6196.
DOI: 10.1002/sim.9178
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simulate_prcmlpmm_data">simulate_prcmlpmm_data</a></code>,
<code><a href="#topic+summarize_mlpmms">summarize_mlpmms</a></code> (step 2),
<code><a href="#topic+fit_prcmlpmm">fit_prcmlpmm</a></code> (step 3),
<code><a href="#topic+performance_prc">performance_prc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# generate example data
set.seed(123)
n.items = c(4,2,2,3,4,2)
simdata = simulate_prcmlpmm_data(n = 100, p = length(n.items),  
             p.relev = 3, n.items = n.items, 
             type = 'u+b', seed = 1)
 
# specify options for cluster bootstrap optimism correction
# procedure and for parallel computing 
do.bootstrap = FALSE
# IMPORTANT: set do.bootstrap = TRUE to compute the optimism correction!
n.boots = ifelse(do.bootstrap, 100, 0)
more.cores = FALSE
# IMPORTANT: set more.cores = TRUE to speed computations up!
if (!more.cores) n.cores = 2
if (more.cores) {
   # identify number of available cores on your machine
   n.cores = parallel::detectCores()
   if (is.na(n.cores)) n.cores = 2
}

# step 1 of PRC-MLPMM: estimate the MLPMMs
y.names = vector('list', length(n.items))
for (i in 1:length(n.items)) {
  y.names[[i]] = paste('marker', i, '_', 1:n.items[i], sep = '')
}

step1 = fit_mlpmms(y.names, fixefs = ~ contrast(age),  
                 ranef.time = age, randint.items = TRUE, 
                 long.data = simdata$long.data, 
                 surv.data = simdata$surv.data,
                 t.from.base = t.from.base,
                 n.boots = n.boots, n.cores = n.cores)

# print MLPMM summary for marker 5 (all items involved in that MLPMM):
summary(step1, 'marker5_2')

</code></pre>

<hr>
<h2 id='fit_prclmm'>Step 3 of PRC-LMM (estimation of the penalized Cox model(s))</h2><span id='topic+fit_prclmm'></span>

<h3>Description</h3>

<p>This function performs the third step for the estimation
of the PRC-LMM model proposed in Signorelli et al. (2021)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_prclmm(object, surv.data, baseline.covs = NULL, penalty = "ridge",
  standardize = TRUE, pfac.base.covs = 0, cv.seed = 19920207,
  n.alpha.elnet = 11, n.folds.elnet = 5, n.cores = 1, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_prclmm_+3A_object">object</code></td>
<td>
<p>the output of step 2 of the PRC-LMM procedure, 
as produced by the <code><a href="#topic+summarize_lmms">summarize_lmms</a></code> function</p>
</td></tr>
<tr><td><code id="fit_prclmm_+3A_surv.data">surv.data</code></td>
<td>
<p>a data frame with the survival data and (if 
relevant) additional baseline covariates. <code>surv.data</code> should at least
contain a subject id (called <code>id</code>), the time to event outcome  
(<code>time</code>), and binary event variable (<code>event</code>)</p>
</td></tr>
<tr><td><code id="fit_prclmm_+3A_baseline.covs">baseline.covs</code></td>
<td>
<p>a formula specifying the variables 
(e.g., baseline age) in <code>surv.data</code> that should be included 
as baseline covariates in the penalized Cox model. Example:
<code>baseline.covs = '~ baseline.age'</code>. Default is <code>NULL</code></p>
</td></tr>
<tr><td><code id="fit_prclmm_+3A_penalty">penalty</code></td>
<td>
<p>the type of penalty function used for regularization.
Default is <code>'ridge'</code>, other possible values are <code>'elasticnet'</code> 
and <code>'lasso'</code></p>
</td></tr>
<tr><td><code id="fit_prclmm_+3A_standardize">standardize</code></td>
<td>
<p>logical argument: should the predictors (both baseline covariates
and predicted random effects) be standardized when included  as covariates
in the penalized Cox model? Default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="fit_prclmm_+3A_pfac.base.covs">pfac.base.covs</code></td>
<td>
<p>a single value, or a vector of values, indicating
whether the baseline covariates (if any) should be penalized (1) or not (0).
Default is <code>pfac.base.covs = 0</code> (no penalization of all baseline covariates)</p>
</td></tr>
<tr><td><code id="fit_prclmm_+3A_cv.seed">cv.seed</code></td>
<td>
<p>value of the random seed to use for the cross-validation
done to select the optimal value of the tuning parameter</p>
</td></tr>
<tr><td><code id="fit_prclmm_+3A_n.alpha.elnet">n.alpha.elnet</code></td>
<td>
<p>number of alpha values for the two-dimensional 
grid of tuning parameteres in elasticnet.
Only relevant if <code>penalty = 'elasticnet'</code>. Default is 11,
so that the resulting alpha grid is c(1, 0.9, 0.8, ..., 0.1, 0)</p>
</td></tr>
<tr><td><code id="fit_prclmm_+3A_n.folds.elnet">n.folds.elnet</code></td>
<td>
<p>number of folds to be used for the selection
of the tuning parameter in elasticnet. Only relevant if 
<code>penalty = 'elasticnet'</code>. Default is 5</p>
</td></tr>
<tr><td><code id="fit_prclmm_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores to use to parallelize part of
the computations. If <code>ncores = 1</code> (default), no parallelization is done. 
Pro tip: you can use <code>parallel::detectCores()</code> to check 
how many cores are available on your computer</p>
</td></tr>
<tr><td><code id="fit_prclmm_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default and recommended value), information
on the ongoing computations is printed in the console</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following objects:
</p>

<ul>
<li> <p><code>call</code>: the function call
</p>
</li>
<li> <p><code>pcox.orig</code>: the penalized Cox model fitted on the
original dataset;
</p>
</li>
<li> <p><code>tuning</code>: the values of the tuning parameter(s) selected through 
cross-validation
</p>
</li>
<li> <p><code>surv.data</code>: the supplied survival data (ordered by
subject id)
</p>
</li>
<li> <p><code>n.boots</code>: number of bootstrap samples;
</p>
</li>
<li> <p><code>boot.ids</code>: a list with the ids of bootstrapped subjects 
(when <code>n.boots &gt; 0</code>);
</p>
</li>
<li> <p><code>pcox.boot</code>: a list where each element is a fitted penalized
Cox model for a given bootstrap sample (when <code>n.boots &gt; 0</code>).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Mirko Signorelli
</p>


<h3>References</h3>

<p>Signorelli, M. (2023). pencal: an R Package for the Dynamic 
Prediction of Survival with Many Longitudinal Predictors.
arXiv preprint: arXiv:2309.15600
</p>
<p>Signorelli, M., Spitali, P., Al-Khalili Szigyarto, C, 
The MARK-MD Consortium, Tsonaka, R. (2021). 
Penalized regression calibration: a method for the prediction 
of survival outcomes using complex longitudinal and 
high-dimensional data. Statistics in Medicine, 40 (27), 6178-6196.
DOI: 10.1002/sim.9178
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_lmms">fit_lmms</a></code> (step 1), 
<code><a href="#topic+summarize_lmms">summarize_lmms</a></code> (step 2),
<code><a href="#topic+performance_prc">performance_prc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate example data
set.seed(1234)
p = 4 # number of longitudinal predictors
simdata = simulate_prclmm_data(n = 100, p = p, p.relev = 2, 
             seed = 123, t.values = c(0, 0.2, 0.5, 1, 1.5, 2))
             
# specify options for cluster bootstrap optimism correction
# procedure and for parallel computing 
do.bootstrap = FALSE
# IMPORTANT: set do.bootstrap = TRUE to compute the optimism correction!
n.boots = ifelse(do.bootstrap, 100, 0)
more.cores = FALSE
# IMPORTANT: set more.cores = TRUE to parallelize and speed computations up!
if (!more.cores) n.cores = 1
if (more.cores) {
   # identify number of available cores on your machine
   n.cores = parallel::detectCores()
   if (is.na(n.cores)) n.cores = 8
}

# step 1 of PRC-LMM: estimate the LMMs
y.names = paste('marker', 1:p, sep = '')
step1 = fit_lmms(y.names = y.names, 
                 fixefs = ~ age, ranefs = ~ age | id, 
                 long.data = simdata$long.data, 
                 surv.data = simdata$surv.data,
                 t.from.base = t.from.base,
                 n.boots = n.boots, n.cores = n.cores)
                 
# step 2 of PRC-LMM: compute the summaries 
# of the longitudinal outcomes
step2 = summarize_lmms(object = step1, n.cores = n.cores)

# step 3 of PRC-LMM: fit the penalized Cox models
step3 = fit_prclmm(object = step2, surv.data = simdata$surv.data,
                   baseline.covs = ~ baseline.age,
                   penalty = 'ridge', n.cores = n.cores)
summary(step3)                    
</code></pre>

<hr>
<h2 id='fit_prcmlpmm'>Step 3 of PRC-MLPMM (estimation of the penalized Cox model(s))</h2><span id='topic+fit_prcmlpmm'></span>

<h3>Description</h3>

<p>This function performs the third step for the estimation
of the PRC-MLPMM model proposed in Signorelli et al. (2021)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_prcmlpmm(object, surv.data, baseline.covs = NULL, include.b0s = TRUE,
  penalty = "ridge", standardize = TRUE, pfac.base.covs = 0,
  cv.seed = 19920207, n.alpha.elnet = 11, n.folds.elnet = 5,
  n.cores = 1, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_prcmlpmm_+3A_object">object</code></td>
<td>
<p>the output of step 2 of the PRC-MLPMM procedure, 
as produced by the <code><a href="#topic+summarize_mlpmms">summarize_mlpmms</a></code> function</p>
</td></tr>
<tr><td><code id="fit_prcmlpmm_+3A_surv.data">surv.data</code></td>
<td>
<p>a data frame with the survival data and (if 
relevant) additional baseline covariates. <code>surv.data</code> should at least
contain a subject id (called <code>id</code>), the time to event outcome  
(<code>time</code>), and binary event variable (<code>event</code>)</p>
</td></tr>
<tr><td><code id="fit_prcmlpmm_+3A_baseline.covs">baseline.covs</code></td>
<td>
<p>a formula specifying the variables 
(e.g., baseline age) in <code>surv.data</code> that should be included 
as baseline covariates in the penalized Cox model. Example:
<code>baseline.covs = '~ baseline.age'</code>. Default is <code>NULL</code></p>
</td></tr>
<tr><td><code id="fit_prcmlpmm_+3A_include.b0s">include.b0s</code></td>
<td>
<p>logical. If <code>TRUE</code>, the PRC-MLPMM(U+B) model
is estimated; if <code>FALSE</code>, the PRC-MLPMM(U) model is estimated. See
Signorelli et al. (2021) for details</p>
</td></tr>
<tr><td><code id="fit_prcmlpmm_+3A_penalty">penalty</code></td>
<td>
<p>the type of penalty function used for regularization.
Default is <code>'ridge'</code>, other possible values are <code>'elasticnet'</code> 
and <code>'lasso'</code></p>
</td></tr>
<tr><td><code id="fit_prcmlpmm_+3A_standardize">standardize</code></td>
<td>
<p>logical argument: should the predicted random effects
be standardized when included in the penalized Cox model? Default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="fit_prcmlpmm_+3A_pfac.base.covs">pfac.base.covs</code></td>
<td>
<p>a single value, or a vector of values, indicating
whether the baseline covariates (if any) should be penalized (1) or not (0).
Default is <code>pfac.base.covs = 0</code> (no penalization of all baseline covariates)</p>
</td></tr>
<tr><td><code id="fit_prcmlpmm_+3A_cv.seed">cv.seed</code></td>
<td>
<p>value of the random seed to use for the cross-validation
done to select the optimal value of the tuning parameter</p>
</td></tr>
<tr><td><code id="fit_prcmlpmm_+3A_n.alpha.elnet">n.alpha.elnet</code></td>
<td>
<p>number of alpha values for the two-dimensional 
grid of tuning parameteres in elasticnet.
Only relevant if <code>penalty = 'elasticnet'</code>. Default is 11,
so that the resulting alpha grid is c(1, 0.9, 0.8, ..., 0.1, 0)</p>
</td></tr>
<tr><td><code id="fit_prcmlpmm_+3A_n.folds.elnet">n.folds.elnet</code></td>
<td>
<p>number of folds to be used for the selection
of the tuning parameter in elasticnet. Only relevant if 
<code>penalty = 'elasticnet'</code>. Default is 5</p>
</td></tr>
<tr><td><code id="fit_prcmlpmm_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores to use to parallelize part of
the computations. If <code>ncores = 1</code> (default), no parallelization is done. 
Pro tip: you can use <code>parallel::detectCores()</code> to check 
how many cores are available on your computer</p>
</td></tr>
<tr><td><code id="fit_prcmlpmm_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default and recommended value), information
on the ongoing computations is printed in the console</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following objects:
</p>

<ul>
<li> <p><code>call</code>: the function call
</p>
</li>
<li> <p><code>pcox.orig</code>: the penalized Cox model fitted on the
original dataset;
</p>
</li>
<li> <p><code>tuning</code>: the values of the tuning parameter(s) selected through 
cross-validation
</p>
</li>
<li> <p><code>surv.data</code>: the supplied survival data (ordered by
subject id)
</p>
</li>
<li> <p><code>n.boots</code>: number of bootstrap samples;
</p>
</li>
<li> <p><code>boot.ids</code>: a list with the ids of bootstrapped subjects 
(when <code>n.boots &gt; 0</code>);
</p>
</li>
<li> <p><code>pcox.boot</code>: a list where each element is a fitted penalized
Cox model for a given bootstrap sample (when <code>n.boots &gt; 0</code>).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Mirko Signorelli
</p>


<h3>References</h3>

<p>Signorelli, M. (2023). pencal: an R Package for the Dynamic 
Prediction of Survival with Many Longitudinal Predictors.
arXiv preprint: arXiv:2309.15600
</p>
<p>Signorelli, M., Spitali, P., Al-Khalili Szigyarto, C, 
The MARK-MD Consortium, Tsonaka, R. (2021). 
Penalized regression calibration: a method for the prediction 
of survival outcomes using complex longitudinal and 
high-dimensional data. Statistics in Medicine, 40 (27), 6178-6196.
DOI: 10.1002/sim.9178
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_mlpmms">fit_mlpmms</a></code> (step 1), 
<code><a href="#topic+summarize_mlpmms">summarize_mlpmms</a></code> (step 2),
<code><a href="#topic+performance_prc">performance_prc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# generate example data
set.seed(123)
n.items = c(4,2,2,3,4,2)
simdata = simulate_prcmlpmm_data(n = 100, p = length(n.items),  
             p.relev = 3, n.items = n.items, 
             type = 'u+b', seed = 1)
 
# specify options for cluster bootstrap optimism correction
# procedure and for parallel computing 
do.bootstrap = FALSE
# IMPORTANT: set do.bootstrap = TRUE to compute the optimism correction!
n.boots = ifelse(do.bootstrap, 100, 0)
more.cores = FALSE
# IMPORTANT: set more.cores = TRUE to speed computations up!
if (!more.cores) n.cores = 2
if (more.cores) {
   # identify number of available cores on your machine
   n.cores = parallel::detectCores()
   if (is.na(n.cores)) n.cores = 2
}

# step 1 of PRC-MLPMM: estimate the MLPMMs
y.names = vector('list', length(n.items))
for (i in 1:length(n.items)) {
  y.names[[i]] = paste('marker', i, '_', 1:n.items[i], sep = '')
}

step1 = fit_mlpmms(y.names, fixefs = ~ contrast(age),  
                 ranef.time = age, randint.items = TRUE, 
                 long.data = simdata$long.data, 
                 surv.data = simdata$surv.data,
                 t.from.base = t.from.base,
                 n.boots = n.boots, n.cores = n.cores)

# step 2 of PRC-MLPMM: compute the summaries 
step2 = summarize_mlpmms(object = step1, n.cores = n.cores)

# step 3 of PRC-LMM: fit the penalized Cox models
step3 = fit_prcmlpmm(object = step2, surv.data = simdata$surv.data,
                   baseline.covs = ~ baseline.age,
                   include.b0s = TRUE,
                   penalty = 'ridge', n.cores = n.cores)
summary(step3)

</code></pre>

<hr>
<h2 id='fitted_prclmm'>A fitted PRC LMM</h2><span id='topic+fitted_prclmm'></span>

<h3>Description</h3>

<p>This list contains a fitted PRC LMM, where the CBOCP is
computed using 50 cluster bootstrap samples. It is
used to reduce the computing time in the example of
the function <code>performance_prc</code>. The simulated dataset 
on which the model was fitted was landmarked at t = 2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fitted_prclmm)
</code></pre>


<h3>Format</h3>

<p>A list comprising step 2 and step 3 as obtained
during the estimation of a PRC LMM
</p>


<h3>Author(s)</h3>

<p>Mirko Signorelli
</p>


<h3>References</h3>

<p>Signorelli, M. (2023). pencal: an R Package for the Dynamic 
Prediction of Survival with Many Longitudinal Predictors.
arXiv preprint: arXiv:2309.15600
</p>
<p>Signorelli, M., Spitali, P., Al-Khalili Szigyarto, C, 
The MARK-MD Consortium, Tsonaka, R. (2021). 
Penalized regression calibration: a method for the prediction 
of survival outcomes using complex longitudinal and 
high-dimensional data. Statistics in Medicine.
DOI: 10.1002/sim.9178
</p>


<h3>See Also</h3>

<p><code><a href="#topic+performance_prc">performance_prc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fitted_prclmm)
ls(fitted_prclmm)
</code></pre>

<hr>
<h2 id='fitted_prcmlpmm'>A fitted PRC MLPMM</h2><span id='topic+fitted_prcmlpmm'></span>

<h3>Description</h3>

<p>This list contains a fitted PRC MLPMM. It is
used to reduce the computing time in the example of
the function <code>survpred_prcmlpmm</code>. The simulated dataset 
on which the model was fitted was landmarked at t = 2.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(fitted_prclmm)
</code></pre>


<h3>Format</h3>

<p>A list comprising step 2 and step 3 as obtained
during the estimation of a PRC MLPMM
</p>


<h3>Author(s)</h3>

<p>Mirko Signorelli
</p>


<h3>References</h3>

<p>Signorelli, M., Spitali, P., Al-Khalili Szigyarto, C, 
The MARK-MD Consortium, Tsonaka, R. (2021). 
Penalized regression calibration: a method for the prediction 
of survival outcomes using complex longitudinal and 
high-dimensional data. Statistics in Medicine, 40 (27), 6178-6196.
DOI: 10.1002/sim.9178
</p>


<h3>See Also</h3>

<p><code><a href="#topic+survpred_prcmlpmm">survpred_prcmlpmm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fitted_prcmlpmm)
ls(fitted_prcmlpmm)
</code></pre>

<hr>
<h2 id='pbc2data'>pbc2 dataset</h2><span id='topic+pbc2data'></span>

<h3>Description</h3>

<p>This list contains data from the Mayo Clinic primary biliary cirrhosis (PBC)
study (1974-1984). It comprises two datasets, one with the survival and baseline covariates
and the other with the longitudinal measurements. The datasets are a 
rearrangement of the 'pbc2' dataframe from the 'joineRML' package that makes
them more suitable for analysis within 'pencal'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(pbc2data)
</code></pre>


<h3>Format</h3>

<p>The list contains two data frames:
</p>

<ul>
<li> <p><code>baselineInfo</code> contains the subject indicator 'id', information about
the survival outcome ('time' and 'event') and the covariates 'baselineAge', 'sex'
and 'treatment';
</p>
</li>
<li> <p><code>longitudinalInfo</code> contains the subject 'id' and the repeated measurement 
data: 'age' is the age of the individual at each visit, 'fuptime' the follow-up time
(time on study), and 'serBilir', 'serChol', 'albumin', 'alkaline', 'SGOT',
'platelets' and 'prothrombin' contain the value of each covariate at the 
corresponding visit
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Mirko Signorelli
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pbc2data)
head(pbc2data$baselineInfo)
head(pbc2data$longitudinalInfo)
</code></pre>

<hr>
<h2 id='pencox'>Estimation of a penalized Cox model with time-independent covariates</h2><span id='topic+pencox'></span>

<h3>Description</h3>

<p>This function estimates a penalized Cox model where only
time-independent covariates are included as predictors, and then
computes a bootstrap optimism correction procedure that 
is used to validate the predictive performance of the model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pencox(data, formula, penalty = "ridge", standardize = TRUE,
  penalty.factor = 1, n.alpha.elnet = 11, n.folds.elnet = 5,
  n.boots = 0, n.cores = 1, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pencox_+3A_data">data</code></td>
<td>
<p>a data frame with one row for each subject.It
should at least contain a subject id (called <code>id</code>), 
the time to event outcome (<code>time</code>), and the binary censoring
indicator (<code>event</code>), plus at least one covariate to
be included in the linear predictor</p>
</td></tr>
<tr><td><code id="pencox_+3A_formula">formula</code></td>
<td>
<p>a formula specifying the variables 
in <code>data</code> to include as predictors in 
the penalized Cox model</p>
</td></tr>
<tr><td><code id="pencox_+3A_penalty">penalty</code></td>
<td>
<p>the type of penalty function used for regularization.
Default is <code>'ridge'</code>, other possible values are <code>'elasticnet'</code> 
and <code>'lasso'</code></p>
</td></tr>
<tr><td><code id="pencox_+3A_standardize">standardize</code></td>
<td>
<p>logical argument: should the covariates
be standardized when included in the penalized Cox model? Default is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="pencox_+3A_penalty.factor">penalty.factor</code></td>
<td>
<p>a single value, or a vector of values, indicating
whether the covariates (if any) should be penalized (1) or not (0).
Default is <code>penalty.factor = 1</code></p>
</td></tr>
<tr><td><code id="pencox_+3A_n.alpha.elnet">n.alpha.elnet</code></td>
<td>
<p>number of alpha values for the two-dimensional 
grid of tuning parameteres in elasticnet.
Only relevant if <code>penalty = 'elasticnet'</code>. Default is 11,
so that the resulting alpha grid is c(1, 0.9, 0.8, ..., 0.1, 0)</p>
</td></tr>
<tr><td><code id="pencox_+3A_n.folds.elnet">n.folds.elnet</code></td>
<td>
<p>number of folds to be used for the selection
of the tuning parameter in elasticnet. Only relevant if 
<code>penalty = 'elasticnet'</code>. Default is 5</p>
</td></tr>
<tr><td><code id="pencox_+3A_n.boots">n.boots</code></td>
<td>
<p>number of bootstrap samples to be used 
in the bootstrap optimism correction procedure. If 0, no
bootstrapping is performed</p>
</td></tr>
<tr><td><code id="pencox_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores to use to parallelize the computation
of the CBOCP. If <code>ncores = 1</code> (default), no parallelization is done. 
Pro tip: you can use <code>parallel::detectCores()</code> to check 
how many cores are available on your computer</p>
</td></tr>
<tr><td><code id="pencox_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default and recommended value), information
on the ongoing computations is printed in the console</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following objects:
</p>

<ul>
<li> <p><code>call</code>: the function call
</p>
</li>
<li> <p><code>pcox.orig</code>: the penalized Cox model fitted on the
original dataset;
</p>
</li>
<li> <p><code>surv.data</code>: a data frame with the survival data
</p>
</li>
<li> <p><code>X.orig</code>: a data frame with the design matrix used
to estimate the Cox model
</p>
</li>
<li> <p><code>n.boots</code>: number of bootstrap samples;
</p>
</li>
<li> <p><code>boot.ids</code>: a list with the ids of bootstrapped subjects 
(when <code>n.boots &gt; 0</code>);
</p>
</li>
<li> <p><code>pcox.boot</code>: a list where each element is a fitted penalized
Cox model for a given bootstrap sample (when <code>n.boots &gt; 0</code>).
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Mirko Signorelli
</p>


<h3>References</h3>

<p>Signorelli, M. (2023). pencal: an R Package for the Dynamic 
Prediction of Survival with Many Longitudinal Predictors.
arXiv preprint: arXiv:2309.15600
</p>
<p>Signorelli, M., Spitali, P., Al-Khalili Szigyarto, C, 
The MARK-MD Consortium, Tsonaka, R. (2021). 
Penalized regression calibration: a method for the prediction 
of survival outcomes using complex longitudinal and 
high-dimensional data. Statistics in Medicine, 40 (27), 6178-6196.
DOI: 10.1002/sim.9178
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_prclmm">fit_prclmm</a></code>, 
<code><a href="#topic+fit_prcmlpmm">fit_prcmlpmm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate example data
set.seed(1234)
p = 4 # number of longitudinal predictors
simdata = simulate_prclmm_data(n = 100, p = p, p.relev = 2, 
             seed = 123, t.values = c(0, 0.2, 0.5, 1, 1.5, 2))
#create dataframe with baseline measurements only
baseline.visits = simdata$long.data[which(!duplicated(simdata$long.data$id)),]
df = merge(simdata$surv.data, baseline.visits, by = 'id')
df = df[ , -c(5:6)]

do.bootstrap = FALSE
# IMPORTANT: set do.bootstrap = TRUE to compute the optimism correction!
n.boots = ifelse(do.bootstrap, 100, 0)
more.cores = FALSE
# IMPORTANT: set more.cores = TRUE to speed computations up!
if (!more.cores) n.cores = 2
if (more.cores) {
   # identify number of available cores on your machine
   n.cores = parallel::detectCores()
   if (is.na(n.cores)) n.cores = 2
}

form = as.formula(~ baseline.age + marker1 + marker2
                     + marker3 + marker4)
base.pcox = pencox(data = df, 
              formula = form, 
              n.boots = n.boots, n.cores = n.cores) 
ls(base.pcox)
</code></pre>

<hr>
<h2 id='performance_pencox'>Predictive performance of the penalized Cox model
with time-independent covariates</h2><span id='topic+performance_pencox'></span>

<h3>Description</h3>

<p>This function computes the naive and optimism-corrected
measures of performance (C index, time-dependent AUC and time-dependent 
Brier score) for a penalized Cox model with time-independent covariates. 
The optimism correction is computed based on a cluster bootstrap
optimism correction procedure (CBOCP, Signorelli et al., 2021)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>performance_pencox(fitted_pencox, metric = c("tdauc", "c", "brier"),
  times = c(2, 3), n.cores = 1, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="performance_pencox_+3A_fitted_pencox">fitted_pencox</code></td>
<td>
<p>the output of <code><a href="#topic+pencox">pencox</a></code></p>
</td></tr>
<tr><td><code id="performance_pencox_+3A_metric">metric</code></td>
<td>
<p>the desired performance measure(s). Options include: 'tdauc',
'c' and 'brier'</p>
</td></tr>
<tr><td><code id="performance_pencox_+3A_times">times</code></td>
<td>
<p>numeric vector with the time points at which
to estimate the time-dependent AUC and time-dependent Brier score</p>
</td></tr>
<tr><td><code id="performance_pencox_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores to use to parallelize part of
the computations. If <code>ncores = 1</code> (default), 
no parallelization is done. Pro tip: you can use 
<code>parallel::detectCores()</code> to check how many 
cores are available on your computer</p>
</td></tr>
<tr><td><code id="performance_pencox_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default and recommended value), information
on the ongoing computations is printed in the console</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following objects:
</p>

<ul>
<li> <p><code>call</code>: the function call;
</p>
</li>
<li> <p><code>concordance</code>: a data frame with the naive and
optimism-corrected estimates of the concordance (C) index;
</p>
</li>
<li> <p><code>tdAUC</code>: a data frame with the naive and
optimism-corrected estimates of the time-dependent AUC
at the desired time points.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Mirko Signorelli
</p>


<h3>References</h3>

<p>Signorelli, M. (2023). pencal: an R Package for the Dynamic 
Prediction of Survival with Many Longitudinal Predictors.
arXiv preprint: arXiv:2309.15600
</p>
<p>Signorelli, M., Spitali, P., Al-Khalili Szigyarto, C, 
The MARK-MD Consortium, Tsonaka, R. (2021). 
Penalized regression calibration: a method for the prediction 
of survival outcomes using complex longitudinal and 
high-dimensional data. Statistics in Medicine, 40 (27), 6178-6196.
DOI: 10.1002/sim.9178
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pencox">pencox</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate example data
set.seed(1234)
p = 4 # number of longitudinal predictors
simdata = simulate_prclmm_data(n = 100, p = p, p.relev = 2, 
             seed = 123, t.values = c(0, 0.5, 1, 1.5, 2))
# create dataframe with baseline measurements only
baseline.visits = simdata$long.data[which(!duplicated(simdata$long.data$id)),]
df = merge(simdata$surv.data, baseline.visits, by = 'id')
df = df[ , -c(5:6)]

do.bootstrap = FALSE
# IMPORTANT: set do.bootstrap = TRUE to compute the optimism correction!
n.boots = ifelse(do.bootstrap, 100, 0)
more.cores = FALSE
# IMPORTANT: set more.cores = TRUE to speed computations up!
if (!more.cores) n.cores = 2
if (more.cores) {
   # identify number of available cores on your machine
   n.cores = parallel::detectCores()
   if (is.na(n.cores)) n.cores = 2
}

form = as.formula(~ baseline.age + marker1 + marker2
                     + marker3 + marker4)
base.pcox = pencox(data = df, 
              formula = form, 
              n.boots = n.boots, n.cores = n.cores) 
ls(base.pcox)
                   
# compute the performance measures
perf = performance_pencox(fitted_pencox = base.pcox, 
          metric = 'tdauc', times = 3:5, n.cores = n.cores)
 # use metric = 'brier' for the Brier score and metric = 'c' for the
 # concordance index

# time-dependent AUC estimates:
ls(perf)
perf$tdAUC
</code></pre>

<hr>
<h2 id='performance_prc'>Predictive performance of the PRC-LMM and PRC-MLPMM models</h2><span id='topic+performance_prc'></span>

<h3>Description</h3>

<p>This function computes the naive and optimism-corrected
measures of performance (C index, time-dependent AUC and time-dependent 
Brier score) for the PRC models proposed 
in Signorelli et al. (2021). The optimism
correction is computed based on a cluster bootstrap
optimism correction procedure (CBOCP)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>performance_prc(step2, step3, metric = c("tdauc", "c", "brier"),
  times = c(2, 3), n.cores = 1, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="performance_prc_+3A_step2">step2</code></td>
<td>
<p>the output of either <code><a href="#topic+summarize_lmms">summarize_lmms</a></code> 
or <code><a href="#topic+summarize_mlpmms">summarize_mlpmms</a></code> (step 2 of the estimation of
PRC)</p>
</td></tr>
<tr><td><code id="performance_prc_+3A_step3">step3</code></td>
<td>
<p>the output of <code><a href="#topic+fit_prclmm">fit_prclmm</a></code> or
<code><a href="#topic+fit_prcmlpmm">fit_prcmlpmm</a></code> (step 3 of PRC)</p>
</td></tr>
<tr><td><code id="performance_prc_+3A_metric">metric</code></td>
<td>
<p>the desired performance measure(s). Options include: 'tdauc',
'c' and 'brier'</p>
</td></tr>
<tr><td><code id="performance_prc_+3A_times">times</code></td>
<td>
<p>numeric vector with the time points at which
to estimate the time-dependent AUC and time-dependent Brier score</p>
</td></tr>
<tr><td><code id="performance_prc_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores to use to parallelize part of
the computations. If <code>ncores = 1</code> (default), 
no parallelization is done. Pro tip: you can use 
<code>parallel::detectCores()</code> to check how many 
cores are available on your computer</p>
</td></tr>
<tr><td><code id="performance_prc_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default and recommended value), information
on the ongoing computations is printed in the console</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following objects:
</p>

<ul>
<li> <p><code>call</code>: the function call;
</p>
</li>
<li> <p><code>concordance</code>: a data frame with the naive and
optimism-corrected estimates of the concordance (C) index;
</p>
</li>
<li> <p><code>tdAUC</code>: a data frame with the naive and
optimism-corrected estimates of the time-dependent AUC
at the desired time points;
</p>
</li>
<li> <p><code>Brier</code>: a data frame with the naive and
optimism-corrected estimates of the time-dependent Brier score
at the desired time points;
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Mirko Signorelli
</p>


<h3>References</h3>

<p>Signorelli, M. (2023). pencal: an R Package for the Dynamic 
Prediction of Survival with Many Longitudinal Predictors.
arXiv preprint: arXiv:2309.15600
</p>
<p>Signorelli, M., Spitali, P., Al-Khalili Szigyarto, C, 
The MARK-MD Consortium, Tsonaka, R. (2021). 
Penalized regression calibration: a method for the prediction 
of survival outcomes using complex longitudinal and 
high-dimensional data. Statistics in Medicine, 40 (27), 6178-6196.
DOI: 10.1002/sim.9178
</p>


<h3>See Also</h3>

<p>for the PRC-LMM model: <code><a href="#topic+fit_lmms">fit_lmms</a></code> (step 1),
<code><a href="#topic+summarize_lmms">summarize_lmms</a></code> (step 2) and <code><a href="#topic+fit_prclmm">fit_prclmm</a></code> (step 3);
for the PRC-MLPMM model: <code><a href="#topic+fit_mlpmms">fit_mlpmms</a></code> (step 1),
<code><a href="#topic+summarize_mlpmms">summarize_mlpmms</a></code> (step 2) and <code><a href="#topic+fit_prcmlpmm">fit_prcmlpmm</a></code> (step 3).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(fitted_prclmm)

more.cores = FALSE
# IMPORTANT: set more.cores = TRUE to speed computations up!
if (!more.cores) n.cores = 2
if (more.cores) {
   # identify number of available cores on your machine
   n.cores = parallel::detectCores()
   if (is.na(n.cores)) n.cores = 2
}
                   
# compute the time-dependent AUC
perf = performance_prc(fitted_prclmm$step2, fitted_prclmm$step3,
             metric = 'tdauc', times = c(3, 3.5, 4), n.cores = n.cores)
 # use metric = 'brier' for the Brier score and metric = 'c' for the
 # concordance index

# time-dependent AUC estimates:
ls(perf)
perf$tdAUC

</code></pre>

<hr>
<h2 id='prepare_longdata'>Prepare longitudinal data for PRC</h2><span id='topic+prepare_longdata'></span>

<h3>Description</h3>

<p>This function removes from a longitudinal dataframe
all measurements taken after the occurence of the event 
or after censoring. It is used internally by <code><a href="#topic+fit_lmms">fit_lmms</a></code>
and it assumes that <code>df</code> is sorted by <code>subj.id</code>,
with survival times given in the same order by subject id
(<code>fit_lmms</code> automatically performs this sorting when
needed)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_longdata(df, t.from.base, subj.id, survtime, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare_longdata_+3A_df">df</code></td>
<td>
<p>dataframe with the longitudinal measurements</p>
</td></tr>
<tr><td><code id="prepare_longdata_+3A_t.from.base">t.from.base</code></td>
<td>
<p>name (as character) of the variable containing
time from baseline in <code>df</code></p>
</td></tr>
<tr><td><code id="prepare_longdata_+3A_subj.id">subj.id</code></td>
<td>
<p>name of the subject id variable in <code>df</code></p>
</td></tr>
<tr><td><code id="prepare_longdata_+3A_survtime">survtime</code></td>
<td>
<p>vector containing the survival time or censoring time</p>
</td></tr>
<tr><td><code id="prepare_longdata_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code>, a summary of the data manipulation
is printed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing: a reduced dataframe called <code>df.sanitized</code>, 
where only measurements taken before <code>t</code> are retained; the number of
measurements retained (<code>n.kept</code>) and removed (<code>n.removed</code>)
from the input data frame
</p>


<h3>Author(s)</h3>

<p>Mirko Signorelli
</p>


<h3>References</h3>

<p>Signorelli, M. (2023). pencal: an R Package for the Dynamic 
Prediction of Survival with Many Longitudinal Predictors.
arXiv preprint: arXiv:2309.15600
</p>
<p>Signorelli, M., Spitali, P., Al-Khalili Szigyarto, C, 
The MARK-MD Consortium, Tsonaka, R. (2021). 
Penalized regression calibration: a method for the prediction 
of survival outcomes using complex longitudinal and 
high-dimensional data. Statistics in Medicine, 40 (27), 6178-6196.
DOI: 10.1002/sim.9178
</p>

<hr>
<h2 id='print.prclmm'>Print method for PRC-LMM model fits</h2><span id='topic+print.prclmm'></span>

<h3>Description</h3>

<p>Print method for PRC-LMM model fits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'prclmm'
print(x, digits = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.prclmm_+3A_x">x</code></td>
<td>
<p>an object of class <code>prclmm</code></p>
</td></tr>
<tr><td><code id="print.prclmm_+3A_digits">digits</code></td>
<td>
<p>number of digits at which the printed estimated regression
coefficients should be rounded (default is 4)</p>
</td></tr>
<tr><td><code id="print.prclmm_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Summary information about the fitted PRC-LMM model
</p>


<h3>Author(s)</h3>

<p>Mirko Signorelli
</p>


<h3>References</h3>

<p>Signorelli, M. (2023). pencal: an R Package for the Dynamic 
Prediction of Survival with Many Longitudinal Predictors.
arXiv preprint: arXiv:2309.15600
</p>
<p>Signorelli, M., Spitali, P., Al-Khalili Szigyarto, C, 
The MARK-MD Consortium, Tsonaka, R. (2021). 
Penalized regression calibration: a method for the prediction 
of survival outcomes using complex longitudinal and 
high-dimensional data. Statistics in Medicine, 40 (27), 6178-6196.
DOI: 10.1002/sim.9178
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_prclmm">fit_prclmm</a></code>, <code><a href="#topic+summary.prclmm">summary.prclmm</a></code>
</p>

<hr>
<h2 id='print.prcmlpmm'>Print method for PRC-MLPMM model fits</h2><span id='topic+print.prcmlpmm'></span>

<h3>Description</h3>

<p>Print method for PRC-MLPMM model fits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'prcmlpmm'
print(x, digits = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.prcmlpmm_+3A_x">x</code></td>
<td>
<p>an object of class <code>prcmlpmm</code></p>
</td></tr>
<tr><td><code id="print.prcmlpmm_+3A_digits">digits</code></td>
<td>
<p>number of digits at which the printed estimated regression
coefficients should be rounded (default is 4)</p>
</td></tr>
<tr><td><code id="print.prcmlpmm_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Summary information about the fitted PRC-MLPMM model
</p>


<h3>Author(s)</h3>

<p>Mirko Signorelli
</p>


<h3>References</h3>

<p>Signorelli, M. (2023). pencal: an R Package for the Dynamic 
Prediction of Survival with Many Longitudinal Predictors.
arXiv preprint: arXiv:2309.15600
</p>
<p>Signorelli, M., Spitali, P., Al-Khalili Szigyarto, C, 
The MARK-MD Consortium, Tsonaka, R. (2021). 
Penalized regression calibration: a method for the prediction 
of survival outcomes using complex longitudinal and 
high-dimensional data. Statistics in Medicine, 40 (27), 6178-6196.
DOI: 10.1002/sim.9178
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_prcmlpmm">fit_prcmlpmm</a></code>, <code><a href="#topic+summary.prcmlpmm">summary.prcmlpmm</a></code>
</p>

<hr>
<h2 id='simulate_prclmm_data'>Simulate data that can be used to fit the PRC-LMM model</h2><span id='topic+simulate_prclmm_data'></span>

<h3>Description</h3>

<p>This function allows to simulate a survival outcome
from longitudinal predictors following the PRC LMM model
presented in Signorelli et al. (2021). Specifically, the longitudinal
predictors are simulated from linear mixed models (LMMs), and 
the survival outcome from a Weibull model where the time
to event depends linearly on the baseline age and on the 
random effects from the LMMs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_prclmm_data(n = 100, p = 10, p.relev = 4, t.values = c(0, 0.5,
  1, 2), landmark = max(t.values), seed = 1, lambda = 0.2, nu = 2,
  cens.range = c(landmark, 10), base.age.range = c(3, 5), tau.age = 0.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_prclmm_data_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="simulate_prclmm_data_+3A_p">p</code></td>
<td>
<p>number of longitudinal outcomes</p>
</td></tr>
<tr><td><code id="simulate_prclmm_data_+3A_p.relev">p.relev</code></td>
<td>
<p>number of longitudinal outcomes that
are associated with the survival outcome (min: 1, max: p)</p>
</td></tr>
<tr><td><code id="simulate_prclmm_data_+3A_t.values">t.values</code></td>
<td>
<p>vector specifying the time points 
at which longitudinal measurements are collected
(NB: for simplicity, this function assumes a balanced 
designed; however, <code>pencal</code> is designed to work
both with balanced and with unbalanced designs!)</p>
</td></tr>
<tr><td><code id="simulate_prclmm_data_+3A_landmark">landmark</code></td>
<td>
<p>the landmark time up until which all individuals survived.
Default is equal to <code>max(t.values)</code></p>
</td></tr>
<tr><td><code id="simulate_prclmm_data_+3A_seed">seed</code></td>
<td>
<p>random seed (defaults to 1)</p>
</td></tr>
<tr><td><code id="simulate_prclmm_data_+3A_lambda">lambda</code></td>
<td>
<p>Weibull location parameter, positive</p>
</td></tr>
<tr><td><code id="simulate_prclmm_data_+3A_nu">nu</code></td>
<td>
<p>Weibull scale parameter, positive</p>
</td></tr>
<tr><td><code id="simulate_prclmm_data_+3A_cens.range">cens.range</code></td>
<td>
<p>range for censoring times. By default, the minimum
of this range is equal to the <code>landmark</code> time</p>
</td></tr>
<tr><td><code id="simulate_prclmm_data_+3A_base.age.range">base.age.range</code></td>
<td>
<p>range for age at baseline (set it
equal to c(0, 0) if you want all subjects to enter
the study at the same age)</p>
</td></tr>
<tr><td><code id="simulate_prclmm_data_+3A_tau.age">tau.age</code></td>
<td>
<p>the coefficient that multiplies baseline age
in the linear predictor (like in formula (6) from Signorelli 
et al. (2021))</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements:
</p>

<ul>
<li><p> a dataframe <code>long.data</code> with data on the longitudinal 
predictors, comprehensive of a subject id (<code>id</code>),
baseline age (<code>base.age</code>), time from baseline
(<code>t.from.base</code>) and the longitudinal biomarkers;
</p>
</li>
<li><p> a dataframe <code>surv.data</code> with the survival data: 
a subject id (<code>id</code>), baseline age (<code>baseline.age</code>),
the time to event outcome (<code>time</code>) and a binary vector
(<code>event</code>) that is 1 if the event
is observed, and 0 in case of right-censoring;
</p>
</li>
<li> <p><code>perc.cens</code> the proportion of censored individuals 
in the simulated dataset;
</p>
</li>
<li> <p><code>theta.true</code> a list containing the true parameter values
used to simulate data from the mixed model (beta0 and beta1) and
from the Weibull model (tau.age, gamma, delta)
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Mirko Signorelli
</p>


<h3>References</h3>

<p>Signorelli, M. (2023). pencal: an R Package for the Dynamic 
Prediction of Survival with Many Longitudinal Predictors.
arXiv preprint: arXiv:2309.15600
</p>
<p>Signorelli, M., Spitali, P., Al-Khalili Szigyarto, C, 
The MARK-MD Consortium, Tsonaka, R. (2021). 
Penalized regression calibration: a method for the prediction 
of survival outcomes using complex longitudinal and 
high-dimensional data. Statistics in Medicine, 40 (27), 6178-6196.
DOI: 10.1002/sim.9178
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate example data
simdata = simulate_prclmm_data(n = 20, p = 10, p.relev = 4,
               t.values = c(0, 0.5, 1, 2), landmark = 2, 
               seed = 19931101)
# view the longitudinal markers:
if(requireNamespace("ptmixed")) {
  ptmixed::make.spaghetti(x = age, y = marker1, 
                 id = id, group = id,
                 data = simdata$long.data, 
                 legend.inset = - 1)
 }
# proportion of censored subjects
simdata$censoring.prop
# visualize KM estimate of survival
library(survival)
surv.obj = Surv(time = simdata$surv.data$time, 
                event = simdata$surv.data$event)
kaplan &lt;- survfit(surv.obj ~ 1,  
                  type="kaplan-meier")
plot(kaplan)
</code></pre>

<hr>
<h2 id='simulate_prcmlpmm_data'>Simulate data that can be used to fit the PRC-LMM model</h2><span id='topic+simulate_prcmlpmm_data'></span>

<h3>Description</h3>

<p>This function allows to simulate a survival outcome
from longitudinal predictors following the PRC MLPMM model
presented in Signorelli et al. (2021). Specifically, the 
longitudinal predictors are simulated from multivariate 
latent process mixed models (MLPMMs), and 
the survival outcome from a Weibull model where the time
to event depends on the random effects from the MLPMMs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_prcmlpmm_data(n = 100, p = 5, p.relev = 2, n.items = c(3, 2,
  3, 4, 1), type = "u", t.values = c(0, 0.5, 1, 2),
  landmark = max(t.values), seed = 1, lambda = 0.2, nu = 2,
  cens.range = c(landmark, 10), base.age.range = c(3, 5), tau.age = 0.2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_prcmlpmm_data_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="simulate_prcmlpmm_data_+3A_p">p</code></td>
<td>
<p>number of longitudinal latent processes</p>
</td></tr>
<tr><td><code id="simulate_prcmlpmm_data_+3A_p.relev">p.relev</code></td>
<td>
<p>number of latent processes that
are associated with the survival outcome (min: 1, max: p)</p>
</td></tr>
<tr><td><code id="simulate_prcmlpmm_data_+3A_n.items">n.items</code></td>
<td>
<p>number of items that are observed for each 
latent process of interest. It must be either a scalar, or
a vector of length <code>p</code></p>
</td></tr>
<tr><td><code id="simulate_prcmlpmm_data_+3A_type">type</code></td>
<td>
<p>the type of relation between the longitudinal
outcomes and survival time. Two values can be used: 'u' 
refers to the PRC-MLPMM(U) model, and 'u+b' to the PRC-MLPMM(U+B)
model presented in Section 2.3 of Signorelli et al. (2021).
See the article for the mathematical details</p>
</td></tr>
<tr><td><code id="simulate_prcmlpmm_data_+3A_t.values">t.values</code></td>
<td>
<p>vector specifying the time points 
at which longitudinal measurements are collected
(NB: for simplicity, this function assumes a balanced 
designed; however, <code>pencal</code> is designed to work
both with balanced and with unbalanced designs!)</p>
</td></tr>
<tr><td><code id="simulate_prcmlpmm_data_+3A_landmark">landmark</code></td>
<td>
<p>the landmark time up until which all individuals survived.
Default is equal to <code>max(t.values)</code></p>
</td></tr>
<tr><td><code id="simulate_prcmlpmm_data_+3A_seed">seed</code></td>
<td>
<p>random seed (defaults to 1)</p>
</td></tr>
<tr><td><code id="simulate_prcmlpmm_data_+3A_lambda">lambda</code></td>
<td>
<p>Weibull location parameter, positive</p>
</td></tr>
<tr><td><code id="simulate_prcmlpmm_data_+3A_nu">nu</code></td>
<td>
<p>Weibull scale parameter, positive</p>
</td></tr>
<tr><td><code id="simulate_prcmlpmm_data_+3A_cens.range">cens.range</code></td>
<td>
<p>range for censoring times. By default, the minimum
of this range is equal to the <code>landmark</code> time</p>
</td></tr>
<tr><td><code id="simulate_prcmlpmm_data_+3A_base.age.range">base.age.range</code></td>
<td>
<p>range for age at baseline (set it
equal to c(0, 0) if you want all subjects to enter
the study at the same age)</p>
</td></tr>
<tr><td><code id="simulate_prcmlpmm_data_+3A_tau.age">tau.age</code></td>
<td>
<p>the coefficient that multiplies baseline age
in the linear predictor (like in formulas (7) and (8) from  
Signorelli et al. (2021))</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following elements:
</p>

<ul>
<li><p> a dataframe <code>long.data</code> with data on the longitudinal 
predictors, comprehensive of a subject id (<code>id</code>),
baseline age (<code>base.age</code>), time from baseline
(<code>t.from.base</code>) and the longitudinal biomarkers;
</p>
</li>
<li><p> a dataframe <code>surv.data</code> with the survival data: 
a subject id (<code>id</code>), baseline age (<code>baseline.age</code>),
the time to event outcome (<code>time</code>) and a binary vector
(<code>event</code>) that is 1 if the event
is observed, and 0 in case of right-censoring;
</p>
</li>
<li> <p><code>perc.cens</code> the proportion of censored individuals 
in the simulated dataset.
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Mirko Signorelli
</p>


<h3>References</h3>

<p>Signorelli, M. (2023). pencal: an R Package for the Dynamic 
Prediction of Survival with Many Longitudinal Predictors.
arXiv preprint: arXiv:2309.15600
</p>
<p>Signorelli, M., Spitali, P., Al-Khalili Szigyarto, C, 
The MARK-MD Consortium, Tsonaka, R. (2021). 
Penalized regression calibration: a method for the prediction 
of survival outcomes using complex longitudinal and 
high-dimensional data. Statistics in Medicine, 40 (27), 6178-6196.
DOI: 10.1002/sim.9178
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate example data
simdata = simulate_prcmlpmm_data(n = 40, p = 6,  
             p.relev = 3, n.items = c(3,4,2,5,4,2), 
             type = 'u+b', t.values = c(0, 0.5, 1, 2), 
             landmark = 2, seed = 19931101)

# names of the longitudinal outcomes:
names(simdata$long.data)
# markerx_y is the y-th item for latent process (LP) x
# we have 6 latent processes of interest, and for LP1 
# we measure 3 items, for LP2 4, for LP3 2 items, and so on

# visualize trajectories of marker1_1
if(requireNamespace("ptmixed")) {
  ptmixed::make.spaghetti(x = age, y = marker1_1, 
                 id = id, group = id,
                 data = simdata$long.data, 
                 legend.inset = - 1)
 }
# proportion of censored subjects
simdata$censoring.prop
# visualize KM estimate of survival
library(survival)
surv.obj = Surv(time = simdata$surv.data$time, 
                event = simdata$surv.data$event)
kaplan &lt;- survfit(surv.obj ~ 1,  
                 type="kaplan-meier")
plot(kaplan)
</code></pre>

<hr>
<h2 id='simulate_t_weibull'>Generate survival data from a Weibull model</h2><span id='topic+simulate_t_weibull'></span>

<h3>Description</h3>

<p>This function implements the algorithm proposed by
Bender et al. (2005) to simulate survival times from 
a Weibull model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_t_weibull(n, lambda, nu, X, beta, seed = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_t_weibull_+3A_n">n</code></td>
<td>
<p>sample size</p>
</td></tr>
<tr><td><code id="simulate_t_weibull_+3A_lambda">lambda</code></td>
<td>
<p>Weibull location parameter, positive</p>
</td></tr>
<tr><td><code id="simulate_t_weibull_+3A_nu">nu</code></td>
<td>
<p>Weibull scale parameter, positive</p>
</td></tr>
<tr><td><code id="simulate_t_weibull_+3A_x">X</code></td>
<td>
<p>design matrix (n rows, p columns)</p>
</td></tr>
<tr><td><code id="simulate_t_weibull_+3A_beta">beta</code></td>
<td>
<p>p-dimensional vector of regression coefficients
associated to X</p>
</td></tr>
<tr><td><code id="simulate_t_weibull_+3A_seed">seed</code></td>
<td>
<p>random seed (defaults to 1)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of survival times
</p>


<h3>Author(s)</h3>

<p>Mirko Signorelli
</p>


<h3>References</h3>

<p>Bender, R., Augustin, T., &amp; Blettner, M. (2005). 
Generating survival times to simulate Cox proportional 
hazards models. Statistics in medicine, 24(11), 1713-1723.
</p>
<p>Signorelli, M. (2023). pencal: an R Package for the Dynamic 
Prediction of Survival with Many Longitudinal Predictors.
arXiv preprint: arXiv:2309.15600
</p>
<p>Signorelli, M., Spitali, P., Al-Khalili Szigyarto, C, 
The MARK-MD Consortium, Tsonaka, R. (2021). 
Penalized regression calibration: a method for the prediction 
of survival outcomes using complex longitudinal and 
high-dimensional data. Statistics in Medicine, 40 (27), 6178-6196.
DOI: 10.1002/sim.9178
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate example data
set.seed(1)
n = 50
X = cbind(matrix(1, n, 1), 
   matrix(rnorm(n*9, sd = 0.7), n, 9))
beta = rnorm(10, sd = 0.7)
times = simulate_t_weibull(n = n, lambda = 1, nu = 2,
   X = X, beta = beta)
hist(times, 20)
</code></pre>

<hr>
<h2 id='summarize_lmms'>Step 2 of PRC-LMM (computation of the predicted random effects)</h2><span id='topic+summarize_lmms'></span>

<h3>Description</h3>

<p>This function performs the second step for the estimation
of the PRC-LMM model proposed in Signorelli et al. (2021)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_lmms(object, n.cores = 1, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_lmms_+3A_object">object</code></td>
<td>
<p>a list of objects as produced by <code><a href="#topic+fit_lmms">fit_lmms</a></code></p>
</td></tr>
<tr><td><code id="summarize_lmms_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores to use to parallelize part of
the computations. If <code>ncores = 1</code> (default), no parallelization is done. 
Pro tip: you can use <code>parallel::detectCores()</code> to check 
how many cores are available on your computer</p>
</td></tr>
<tr><td><code id="summarize_lmms_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default and recommended value), information
on the ongoing computations is printed in the console</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following objects:
</p>

<ul>
<li> <p><code>call</code>: the function call
</p>
</li>
<li> <p><code>ranef.orig</code>: a matrix with the predicted random effects
computed for the original data;
</p>
</li>
<li> <p><code>n.boots</code>: number of bootstrap samples;
</p>
</li>
<li> <p><code>boot.ids</code>: a list with the ids of bootstrapped subjects 
(when <code>n.boots &gt; 0</code>);
</p>
</li>
<li> <p><code>ranef.boot.train</code>: a list where each element is a matrix that 
contains the predicted random effects for each bootstrap sample 
(when <code>n.boots &gt; 0</code>);
</p>
</li>
<li> <p><code>ranef.boot.valid</code>: a list where each element is a matrix that 
contains the predicted random effects on the original data, based on the 
lmms fitted on the cluster bootstrap samples (when <code>n.boots &gt; 0</code>);
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Mirko Signorelli
</p>


<h3>References</h3>

<p>Signorelli, M. (2023). pencal: an R Package for the Dynamic 
Prediction of Survival with Many Longitudinal Predictors.
arXiv preprint: arXiv:2309.15600
</p>
<p>Signorelli, M., Spitali, P., Al-Khalili Szigyarto, C, 
The MARK-MD Consortium, Tsonaka, R. (2021). 
Penalized regression calibration: a method for the prediction 
of survival outcomes using complex longitudinal and 
high-dimensional data. Statistics in Medicine, 40 (27), 6178-6196.
DOI: 10.1002/sim.9178
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_lmms">fit_lmms</a></code> (step 1), 
<code><a href="#topic+fit_prclmm">fit_prclmm</a></code> (step 3),
<code><a href="#topic+performance_prc">performance_prc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate example data
set.seed(1234)
p = 4 # number of longitudinal predictors
simdata = simulate_prclmm_data(n = 100, p = p, p.relev = 2, 
             seed = 123, t.values = c(0, 0.2, 0.5, 1, 1.5, 2))
             
# specify options for cluster bootstrap optimism correction
# procedure and for parallel computing 
do.bootstrap = FALSE
# IMPORTANT: set do.bootstrap = TRUE to compute the optimism correction!
n.boots = ifelse(do.bootstrap, 100, 0)
more.cores = FALSE
# IMPORTANT: set more.cores = TRUE to parallelize and speed computations up!
if (!more.cores) n.cores = 1
if (more.cores) {
   # identify number of available cores on your machine
   n.cores = parallel::detectCores()
   if (is.na(n.cores)) n.cores = 8
}

# step 1 of PRC-LMM: estimate the LMMs
y.names = paste('marker', 1:p, sep = '')
step1 = fit_lmms(y.names = y.names, 
                 fixefs = ~ age, ranefs = ~ age | id, 
                 long.data = simdata$long.data, 
                 surv.data = simdata$surv.data,
                 t.from.base = t.from.base,
                 n.boots = n.boots, n.cores = n.cores)
                 
# step 2 of PRC-LMM: compute the summaries 
# of the longitudinal outcomes
step2 = summarize_lmms(object = step1, n.cores = n.cores)
summary(step2)
</code></pre>

<hr>
<h2 id='summarize_mlpmms'>Step 2 of PRC-MLPMM (computation of the predicted random effects)</h2><span id='topic+summarize_mlpmms'></span>

<h3>Description</h3>

<p>This function performs the second step for the estimation
of the PRC-MLPMM model proposed in Signorelli et al. (2021)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarize_mlpmms(object, n.cores = 1, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarize_mlpmms_+3A_object">object</code></td>
<td>
<p>a list of objects as produced by <code><a href="#topic+fit_mlpmms">fit_mlpmms</a></code></p>
</td></tr>
<tr><td><code id="summarize_mlpmms_+3A_n.cores">n.cores</code></td>
<td>
<p>number of cores to use to parallelize part of
the computations. If <code>ncores = 1</code> (default), no parallelization is done. 
Pro tip: you can use <code>parallel::detectCores()</code> to check 
how many cores are available on your computer</p>
</td></tr>
<tr><td><code id="summarize_mlpmms_+3A_verbose">verbose</code></td>
<td>
<p>if <code>TRUE</code> (default and recommended value), information
on the ongoing computations is printed in the console</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following objects:
</p>

<ul>
<li> <p><code>call</code>: the function call
</p>
</li>
<li> <p><code>ranef.orig</code>: a matrix with the predicted random effects
computed for the original data;
</p>
</li>
<li> <p><code>n.boots</code>: number of bootstrap samples;
</p>
</li>
<li> <p><code>boot.ids</code>: a list with the ids of bootstrapped subjects 
(when <code>n.boots &gt; 0</code>);
</p>
</li>
<li> <p><code>ranef.boot.train</code>: a list where each element is a matrix that 
contains the predicted random effects for each bootstrap sample 
(when <code>n.boots &gt; 0</code>);
</p>
</li>
<li> <p><code>ranef.boot.valid</code>: a list where each element is a matrix that 
contains the predicted random effects on the original data, based on the 
mlpmms fitted on the cluster bootstrap samples (when <code>n.boots &gt; 0</code>);
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Mirko Signorelli
</p>


<h3>References</h3>

<p>Signorelli, M. (2023). pencal: an R Package for the Dynamic 
Prediction of Survival with Many Longitudinal Predictors.
arXiv preprint: arXiv:2309.15600
</p>
<p>Signorelli, M., Spitali, P., Al-Khalili Szigyarto, C, 
The MARK-MD Consortium, Tsonaka, R. (2021). 
Penalized regression calibration: a method for the prediction 
of survival outcomes using complex longitudinal and 
high-dimensional data. Statistics in Medicine, 40 (27), 6178-6196.
DOI: 10.1002/sim.9178
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_mlpmms">fit_mlpmms</a></code> (step 1), 
<code><a href="#topic+fit_prcmlpmm">fit_prcmlpmm</a></code> (step 3),
<code><a href="#topic+performance_prc">performance_prc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# generate example data
set.seed(123)
n.items = c(4,2,2,3,4,2)
simdata = simulate_prcmlpmm_data(n = 100, p = length(n.items),  
             p.relev = 3, n.items = n.items, 
             type = 'u+b', seed = 1)
 
# specify options for cluster bootstrap optimism correction
# procedure and for parallel computing 
do.bootstrap = FALSE
# IMPORTANT: set do.bootstrap = TRUE to compute the optimism correction!
n.boots = ifelse(do.bootstrap, 100, 0)
more.cores = FALSE
# IMPORTANT: set more.cores = TRUE to speed computations up!
if (!more.cores) n.cores = 2
if (more.cores) {
   # identify number of available cores on your machine
   n.cores = parallel::detectCores()
   if (is.na(n.cores)) n.cores = 2
}

# step 1 of PRC-MLPMM: estimate the MLPMMs
y.names = vector('list', length(n.items))
for (i in 1:length(n.items)) {
  y.names[[i]] = paste('marker', i, '_', 1:n.items[i], sep = '')
}

step1 = fit_mlpmms(y.names, fixefs = ~ contrast(age),  
                 ranef.time = age, randint.items = TRUE, 
                 long.data = simdata$long.data, 
                 surv.data = simdata$surv.data,
                 t.from.base = t.from.base,
                 n.boots = n.boots, n.cores = n.cores)

# step 2 of PRC-MLPMM: compute the summaries 
step2 = summarize_mlpmms(object = step1, n.cores = n.cores)
summary(step2)

</code></pre>

<hr>
<h2 id='summary.lmmfit'>Extract model fits from step 1 of PRC-LMM</h2><span id='topic+summary.lmmfit'></span>

<h3>Description</h3>

<p>Summary function to extract the estimated fixed effect parameters and
variances of the random effects from an object fitted using 'fit_lmms'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lmmfit'
summary(object, yname, what = "betas", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.lmmfit_+3A_object">object</code></td>
<td>
<p>the output of 'fit_lmms'</p>
</td></tr>
<tr><td><code id="summary.lmmfit_+3A_yname">yname</code></td>
<td>
<p>a character giving the name of the longitudinal
variable for which you want to extract information</p>
</td></tr>
<tr><td><code id="summary.lmmfit_+3A_what">what</code></td>
<td>
<p>one of the following: ''betas'' for the estimates 
of the regression coefficients; ''tTable'' for the usual T table
produced by &lsquo;nlme'; '&rsquo;variances'' for the estimates of 
the variances (and covariances) of the random effects and of the
variance of the error term</p>
</td></tr>
<tr><td><code id="summary.lmmfit_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the estimated fixed-effect parameters if 
&lsquo;what = &rsquo;betas'&lsquo;, the usual T table produced by 'nlme' if 'what = &rsquo;tTable'',
or the estimated variance-covariance matrix of the random
effects and the estimated variance of the error if &lsquo;what = &rsquo;variances''
</p>


<h3>Author(s)</h3>

<p>Mirko Signorelli
</p>


<h3>References</h3>

<p>Signorelli, M. (2023). pencal: an R Package for the Dynamic 
Prediction of Survival with Many Longitudinal Predictors.
arXiv preprint: arXiv:2309.15600
</p>
<p>Signorelli, M., Spitali, P., Al-Khalili Szigyarto, C, 
The MARK-MD Consortium, Tsonaka, R. (2021). 
Penalized regression calibration: a method for the prediction 
of survival outcomes using complex longitudinal and 
high-dimensional data. Statistics in Medicine, 40 (27), 6178-6196.
DOI: 10.1002/sim.9178
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_lmms">fit_lmms</a></code>
</p>

<hr>
<h2 id='summary.mlpmmfit'>Extract model fits from step 1 of PRC-LMM</h2><span id='topic+summary.mlpmmfit'></span>

<h3>Description</h3>

<p>Utility function to extract the MLPMM summaries from a model fit
obtained through 'fit_mlpmms'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mlpmmfit'
summary(object, yname, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.mlpmmfit_+3A_object">object</code></td>
<td>
<p>the output of 'fit_lmms'</p>
</td></tr>
<tr><td><code id="summary.mlpmmfit_+3A_yname">yname</code></td>
<td>
<p>a character giving the name of one of the longitudinal
outcomes modelled within one of the MLPMM</p>
</td></tr>
<tr><td><code id="summary.mlpmmfit_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The model summary as returned by 'summary.multlcmm'
</p>


<h3>Author(s)</h3>

<p>Mirko Signorelli
</p>


<h3>References</h3>

<p>Signorelli, M. (2023). pencal: an R Package for the Dynamic 
Prediction of Survival with Many Longitudinal Predictors.
arXiv preprint: arXiv:2309.15600
</p>
<p>Signorelli, M., Spitali, P., Al-Khalili Szigyarto, C, 
The MARK-MD Consortium, Tsonaka, R. (2021). 
Penalized regression calibration: a method for the prediction 
of survival outcomes using complex longitudinal and 
high-dimensional data. Statistics in Medicine, 40 (27), 6178-6196.
DOI: 10.1002/sim.9178
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_mlpmms">fit_mlpmms</a></code> and <code><a href="lcmm.html#topic+summary.multlcmm">summary.multlcmm</a></code>
</p>

<hr>
<h2 id='summary.prclmm'>Summary method for PRC-LMM model fits</h2><span id='topic+summary.prclmm'></span>

<h3>Description</h3>

<p>Summary method for PRC-LMM model fits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'prclmm'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.prclmm_+3A_object">object</code></td>
<td>
<p>an object of class <code>prclmm</code></p>
</td></tr>
<tr><td><code id="summary.prclmm_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'sprclmm'
</p>


<h3>Author(s)</h3>

<p>Mirko Signorelli
</p>


<h3>References</h3>

<p>Signorelli, M. (2023). pencal: an R Package for the Dynamic 
Prediction of Survival with Many Longitudinal Predictors.
arXiv preprint: arXiv:2309.15600
</p>
<p>Signorelli, M., Spitali, P., Al-Khalili Szigyarto, C, 
The MARK-MD Consortium, Tsonaka, R. (2021). 
Penalized regression calibration: a method for the prediction 
of survival outcomes using complex longitudinal and 
high-dimensional data. Statistics in Medicine, 40 (27), 6178-6196.
DOI: 10.1002/sim.9178
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_prclmm">fit_prclmm</a></code>, <code><a href="#topic+print.prclmm">print.prclmm</a></code>
</p>

<hr>
<h2 id='summary.prcmlpmm'>Summary method for PRC-MLPMM model fits</h2><span id='topic+summary.prcmlpmm'></span>

<h3>Description</h3>

<p>Summary method for PRC-MLPMM model fits
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'prcmlpmm'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.prcmlpmm_+3A_object">object</code></td>
<td>
<p>an object of class <code>prcmlpmm</code></p>
</td></tr>
<tr><td><code id="summary.prcmlpmm_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class 'sprcmlpmm'
</p>


<h3>Author(s)</h3>

<p>Mirko Signorelli
</p>


<h3>References</h3>

<p>Signorelli, M. (2023). pencal: an R Package for the Dynamic 
Prediction of Survival with Many Longitudinal Predictors.
arXiv preprint: arXiv:2309.15600
</p>
<p>Signorelli, M., Spitali, P., Al-Khalili Szigyarto, C, 
The MARK-MD Consortium, Tsonaka, R. (2021). 
Penalized regression calibration: a method for the prediction 
of survival outcomes using complex longitudinal and 
high-dimensional data. Statistics in Medicine, 40 (27), 6178-6196.
DOI: 10.1002/sim.9178
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_prcmlpmm">fit_prcmlpmm</a></code>, <code><a href="#topic+print.prcmlpmm">print.prcmlpmm</a></code>
</p>

<hr>
<h2 id='summary.ranefs'>Summary for step 2 of PRC</h2><span id='topic+summary.ranefs'></span>

<h3>Description</h3>

<p>Summary function to extract basic descriptives from 'summarize_lmms'
and 'summarize_mlpmms'
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ranefs'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ranefs_+3A_object">object</code></td>
<td>
<p>the output of 'summarize_lmms' or 'summarize_mlpmms'</p>
</td></tr>
<tr><td><code id="summary.ranefs_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Information about number of predicted random effects and sample size
</p>


<h3>Author(s)</h3>

<p>Mirko Signorelli
</p>


<h3>References</h3>

<p>Signorelli, M. (2023). pencal: an R Package for the Dynamic 
Prediction of Survival with Many Longitudinal Predictors.
arXiv preprint: arXiv:2309.15600
</p>
<p>Signorelli, M., Spitali, P., Al-Khalili Szigyarto, C, 
The MARK-MD Consortium, Tsonaka, R. (2021). 
Penalized regression calibration: a method for the prediction 
of survival outcomes using complex longitudinal and 
high-dimensional data. Statistics in Medicine, 40 (27), 6178-6196.
DOI: 10.1002/sim.9178
</p>


<h3>See Also</h3>

<p><code><a href="#topic+summarize_lmms">summarize_lmms</a></code>, <code><a href="#topic+summarize_mlpmms">summarize_mlpmms</a></code>
</p>

<hr>
<h2 id='survplot_prc'>Visualize survival predictions for a fitted PRC model</h2><span id='topic+survplot_prc'></span>

<h3>Description</h3>

<p>Visualize survival predictions for a fitted PRC model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survplot_prc(step1, step2, step3, ids, tmax = 5, res = 0.01, lwd = 1,
  lty = 1, legend.title = "Subject", legend.inset = -0.3,
  legend.space = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survplot_prc_+3A_step1">step1</code></td>
<td>
<p>the output of <code><a href="#topic+fit_lmms">fit_lmms</a></code> or <code><a href="#topic+fit_mlpmms">fit_mlpmms</a></code></p>
</td></tr>
<tr><td><code id="survplot_prc_+3A_step2">step2</code></td>
<td>
<p>the output of <code><a href="#topic+summarize_lmms">summarize_lmms</a></code> or
<code><a href="#topic+summarize_mlpmms">summarize_mlpmms</a></code></p>
</td></tr>
<tr><td><code id="survplot_prc_+3A_step3">step3</code></td>
<td>
<p>the output of <code><a href="#topic+fit_prclmm">fit_prclmm</a></code> or <code><a href="#topic+fit_prcmlpmm">fit_prcmlpmm</a></code></p>
</td></tr>
<tr><td><code id="survplot_prc_+3A_ids">ids</code></td>
<td>
<p>a vector with the identifiers of the subjects to show in the plot</p>
</td></tr>
<tr><td><code id="survplot_prc_+3A_tmax">tmax</code></td>
<td>
<p>maximum prediction time to consider for the chart. Default is 5</p>
</td></tr>
<tr><td><code id="survplot_prc_+3A_res">res</code></td>
<td>
<p>resolution at which to evaluate predictions for the chart. Default is 0.01</p>
</td></tr>
<tr><td><code id="survplot_prc_+3A_lwd">lwd</code></td>
<td>
<p>line width</p>
</td></tr>
<tr><td><code id="survplot_prc_+3A_lty">lty</code></td>
<td>
<p>line type</p>
</td></tr>
<tr><td><code id="survplot_prc_+3A_legend.title">legend.title</code></td>
<td>
<p>legend title</p>
</td></tr>
<tr><td><code id="survplot_prc_+3A_legend.inset">legend.inset</code></td>
<td>
<p>moves legend more to the left / right (default is -0.3)</p>
</td></tr>
<tr><td><code id="survplot_prc_+3A_legend.space">legend.space</code></td>
<td>
<p>interspace between lines in the legend (default is 1)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mirko Signorelli
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate example data
simdata = simulate_prclmm_data(n = 100, p = 4, p.relev = 2, 
             t.values = c(0, 0.2, 0.5, 1, 1.5, 2),
             landmark = 2, seed = 123)
             
# estimate the PRC-LMM model
y.names = paste('marker', 1:4, sep = '')
step1 = fit_lmms(y.names = y.names, 
                 fixefs = ~ age, ranefs = ~ age | id, 
                 long.data = simdata$long.data, 
                 surv.data = simdata$surv.data,
                 t.from.base = t.from.base,
                 n.boots = 0)
step2 = summarize_lmms(object = step1)
step3 = fit_prclmm(object = step2, surv.data = simdata$surv.data,
                   baseline.covs = ~ baseline.age,
                   penalty = 'ridge')

# visualize the predicted survival for subjects 1, 3, 7 and 13                    
survplot_prc(step1, step2, step3, ids = c(1, 3, 7, 13), tmax = 6)
</code></pre>

<hr>
<h2 id='survpred_prclmm'>Compute the predicted survival probabilities obtained
from the PRC models</h2><span id='topic+survpred_prclmm'></span>

<h3>Description</h3>

<p>This function computes the predicted survival probabilities 
for the for the PRC-LMM model proposed 
in Signorelli et al. (2021)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survpred_prclmm(step1, step2, step3, times = 1, new.longdata = NULL,
  new.basecovs = NULL, keep.ranef = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survpred_prclmm_+3A_step1">step1</code></td>
<td>
<p>the output of <code><a href="#topic+fit_lmms">fit_lmms</a></code> (step 1
of the estimation of PRC-LMM)</p>
</td></tr>
<tr><td><code id="survpred_prclmm_+3A_step2">step2</code></td>
<td>
<p>the output of <code><a href="#topic+summarize_lmms">summarize_lmms</a></code> (step 2
of the estimation of PRC-LMM)</p>
</td></tr>
<tr><td><code id="survpred_prclmm_+3A_step3">step3</code></td>
<td>
<p>the output of <code><a href="#topic+fit_prclmm">fit_prclmm</a></code> (step 3
of the estimation of PRC-LMM)</p>
</td></tr>
<tr><td><code id="survpred_prclmm_+3A_times">times</code></td>
<td>
<p>numeric vector with the time points at which
to estimate the time-dependent AUC</p>
</td></tr>
<tr><td><code id="survpred_prclmm_+3A_new.longdata">new.longdata</code></td>
<td>
<p>longitudinal data if you want to compute 
predictions for new subjects on which the model was not trained.
It should comprise an identifier variable called 'id'.
Default is <code>new.longdata = NULL</code></p>
</td></tr>
<tr><td><code id="survpred_prclmm_+3A_new.basecovs">new.basecovs</code></td>
<td>
<p>a dataframe with baseline covariates for the
new subjects for which predictions are to be computed. 
It should comprise an identifier variable called 'id'.
Only needed if baseline covariates were included in step 3 and 
<code>new.longdata</code> is specified. Default is <code>new.basecovs = NULL</code></p>
</td></tr>
<tr><td><code id="survpred_prclmm_+3A_keep.ranef">keep.ranef</code></td>
<td>
<p>should a data frame with the predicted random 
effects be included in the output? Default is <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the function call (<code>call</code>),
a data frame with the predicted survival probabilities
computed at the supplied time points (<code>predicted_survival</code>),
and if <code>keep.ranef = TRUE</code> also the predicted random effects
<code>predicted_ranefs</code>.
</p>


<h3>Author(s)</h3>

<p>Mirko Signorelli
</p>


<h3>References</h3>

<p>Signorelli, M. (2023). pencal: an R Package for the Dynamic 
Prediction of Survival with Many Longitudinal Predictors.
arXiv preprint: arXiv:2309.15600
</p>
<p>Signorelli, M., Spitali, P., Al-Khalili Szigyarto, C, 
The MARK-MD Consortium, Tsonaka, R. (2021). 
Penalized regression calibration: a method for the prediction 
of survival outcomes using complex longitudinal and 
high-dimensional data. Statistics in Medicine, 40 (27), 6178-6196.
DOI: 10.1002/sim.9178
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_lmms">fit_lmms</a></code> (step 1),
<code><a href="#topic+summarize_lmms">summarize_lmms</a></code> (step 2) and 
<code><a href="#topic+fit_prclmm">fit_prclmm</a></code> (step 3)
</p>


<h3>Examples</h3>

<pre><code class='language-R'># generate example data
set.seed(1234)
p = 4 # number of longitudinal predictors
simdata = simulate_prclmm_data(n = 100, p = p, p.relev = 2, 
             t.values = c(0, 0.2, 0.5, 1, 1.5, 2),
             landmark = 2, seed = 123)
             
# step 1 of PRC-LMM: estimate the LMMs
y.names = paste('marker', 1:p, sep = '')
step1 = fit_lmms(y.names = y.names, 
                 fixefs = ~ age, ranefs = ~ age | id, 
                 long.data = simdata$long.data, 
                 surv.data = simdata$surv.data,
                 t.from.base = t.from.base,
                 n.boots = 0)
                 
# step 2 of PRC-LMM: compute the summaries 
# of the longitudinal outcomes
step2 = summarize_lmms(object = step1)

# step 3 of PRC-LMM: fit the penalized Cox models
step3 = fit_prclmm(object = step2, surv.data = simdata$surv.data,
                   baseline.covs = ~ baseline.age,
                   penalty = 'ridge')
                   
# predict survival probabilities at times 3 to 6
surv.probs = survpred_prclmm(step1, step2, step3, times = 3:6)
head(surv.probs$predicted_survival)

# predict survival probabilities for new subjects:
temp = simulate_prclmm_data(n = 10, p = p, p.relev = 2, 
      seed = 321, t.values = c(0, 0.2, 0.5, 1, 1.5, 2))
new.longdata = temp$long.data
new.basecovs = temp$surv.data[ , 1:2]
surv.probs.new = survpred_prclmm(step1, step2, step3, 
                     times = 3:6,
                     new.longdata = new.longdata,
                     new.basecovs = new.basecovs)
head(surv.probs.new$predicted_survival)
</code></pre>

<hr>
<h2 id='survpred_prcmlpmm'>Compute the predicted survival probabilities obtained
from the PRC models</h2><span id='topic+survpred_prcmlpmm'></span>

<h3>Description</h3>

<p>This function computes the predicted survival probabilities 
for the for the PRC-MLPMM(U) and PRC-MLPMM(U+B) models proposed 
in Signorelli et al. (2021)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>survpred_prcmlpmm(step2, step3, times = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="survpred_prcmlpmm_+3A_step2">step2</code></td>
<td>
<p>the output of <code><a href="#topic+summarize_mlpmms">summarize_mlpmms</a></code> 
(step 2 of the estimation of PRC-MLPMM)</p>
</td></tr>
<tr><td><code id="survpred_prcmlpmm_+3A_step3">step3</code></td>
<td>
<p>the output of <code><a href="#topic+fit_prcmlpmm">fit_prcmlpmm</a></code> (step 3 
of the estimation of PRC-MLPMM)</p>
</td></tr>
<tr><td><code id="survpred_prcmlpmm_+3A_times">times</code></td>
<td>
<p>numeric vector with the time points at which
to estimate the time-dependent AUC</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the predicted survival probabilities
computed at the supplied time points
</p>


<h3>Author(s)</h3>

<p>Mirko Signorelli
</p>


<h3>References</h3>

<p>Signorelli, M. (2023). pencal: an R Package for the Dynamic 
Prediction of Survival with Many Longitudinal Predictors.
arXiv preprint: arXiv:2309.15600
</p>
<p>Signorelli, M., Spitali, P., Al-Khalili Szigyarto, C, 
The MARK-MD Consortium, Tsonaka, R. (2021). 
Penalized regression calibration: a method for the prediction 
of survival outcomes using complex longitudinal and 
high-dimensional data. Statistics in Medicine, 40 (27), 6178-6196.
DOI: 10.1002/sim.9178
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fit_mlpmms">fit_mlpmms</a></code> (step 1),
<code><a href="#topic+summarize_mlpmms">summarize_mlpmms</a></code> (step 2) and 
<code><a href="#topic+fit_prcmlpmm">fit_prcmlpmm</a></code> (step 3).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(fitted_prcmlpmm)
                   
# predict survival probabilities at times 3 to 6
surv.probs = survpred_prcmlpmm(fitted_prcmlpmm$step2, 
                 fitted_prcmlpmm$step3, times = 3:6)
ls(surv.probs)
head(surv.probs$predicted_survival)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
