<!DOCTYPE html><html><head><title>Help for package ambit</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ambit}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#acf_Exp'><p>Autocorrelation function of the exponential trawl function</p></a></li>
<li><a href='#acf_LM'><p>Autocorrelation function of the long memory trawl function</p></a></li>
<li><a href='#acf_supIG'><p>Autocorrelation function of the supIG trawl function</p></a></li>
<li><a href='#AddSlices_Rcpp'><p>Add slices and return vector of the sums of slices</p></a></li>
<li><a href='#AddWeightedSlices_Rcpp'><p>Add slices and return vector of the weighted sums of slices</p></a></li>
<li><a href='#asymptotic_variance'><p>Computing the true asymptotic variance in the CLT of the</p>
trawl estimation</a></li>
<li><a href='#asymptotic_variance_est'><p>Estimating the asymptotic variance in the trawl function CLT</p></a></li>
<li><a href='#c4est'><p>Estimating the fourth cumulant of the trawl process</p></a></li>
<li><a href='#LebA_est'><p>Nonparametric estimation of the trawl set Leb(A)</p></a></li>
<li><a href='#LebA_slice_est'><p>Nonparametric estimation of the trawl (sub-) sets</p>
Leb(A), Leb(A intersection A_h), Leb(A setdifference A_h)</a></li>
<li><a href='#LebA_slice_ratio_est_acfbased'><p>Nonparametric estimation of the ratios</p>
Leb(A intersection A_h)/Leb(A), Leb(A setdifference A_h)/Leb(A)</a></li>
<li><a href='#my_mae'><p>my_mse</p></a></li>
<li><a href='#my_mse'><p>my_mse</p></a></li>
<li><a href='#my_results'><p>my_results</p></a></li>
<li><a href='#nonpar_trawlest'><p>Nonparametric estimation of the trawl function</p></a></li>
<li><a href='#rq'><p>Computing the scaled realised quarticity</p></a></li>
<li><a href='#sim_weighted_trawl'><p>Simulation of a weighted trawl process</p></a></li>
<li><a href='#sim_weighted_trawl_gen'><p>Simulation of a weighted trawl process with generic trawl function</p></a></li>
<li><a href='#test_asymnorm'><p>Computing the infeasible test statistic from the trawl function</p>
estimation CLT</a></li>
<li><a href='#test_asymnorm_est'><p>Computing the feasible statistic of the trawl function CLT</p></a></li>
<li><a href='#test_asymnorm_est_dev'><p>Computing the feasible statistic of the trawl function CLT</p></a></li>
<li><a href='#trawl_deriv'><p>Estimating the derivative of the trawl function using the</p>
empirical derivative</a></li>
<li><a href='#trawl_deriv_mod'><p>Estimating the derivative of the trawl function</p></a></li>
<li><a href='#trawl_Exp'><p>Evaluates the exponential trawl function</p></a></li>
<li><a href='#trawl_LM'><p>Evaluates the long memory trawl function</p></a></li>
<li><a href='#trawl_supIG'><p>Evaluates the supIG trawl function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simulation and Estimation of Ambit Processes</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Simulation and estimation tools for 
    various types of ambit processes, including trawl processes and weighted
    trawl processes. </td>
</tr>
<tr>
<td>Language:</td>
<td>en-GB</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.1</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>base, fBasics, Rcpp, stats</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, knitr, latex2exp, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-08-17 23:53:19 UTC; customer</td>
</tr>
<tr>
<td>Author:</td>
<td>Almut E. D. Veraart
    <a href="https://orcid.org/0000-0001-8582-3652"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre,
    cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Almut E. D. Veraart &lt;a.veraart@imperial.ac.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-08-19 11:40:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='acf_Exp'>Autocorrelation function of the exponential trawl function</h2><span id='topic+acf_Exp'></span>

<h3>Description</h3>

<p>This function computes the autocorrelation function associated with the
exponential trawl function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acf_Exp(x, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="acf_Exp_+3A_x">x</code></td>
<td>
<p>The argument (lag) at which the autocorrelation function associated
with the exponential trawl function will be evaluated</p>
</td></tr>
<tr><td><code id="acf_Exp_+3A_lambda">lambda</code></td>
<td>
<p>parameter in the exponential trawl</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The trawl function is parametrised by the parameter <code class="reqn">\lambda &gt; 0</code>
as follows:
</p>
<p style="text-align: center;"><code class="reqn">g(x) = e^{\lambda x},  \mbox{ for } x \le 0.</code>
</p>

<p>Its autocorrelation function is given by:
</p>
<p style="text-align: center;"><code class="reqn">r(x) = e^{-\lambda x},  \mbox{ for } x \ge 0.</code>
</p>



<h3>Value</h3>

<p>The autocorrelation function of the exponential trawl function
evaluated at x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>acf_Exp(1,0.1)
</code></pre>

<hr>
<h2 id='acf_LM'>Autocorrelation function of the long memory trawl function</h2><span id='topic+acf_LM'></span>

<h3>Description</h3>

<p>This function computes the autocorrelation function associated with the long
memory trawl function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acf_LM(x, alpha, H)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="acf_LM_+3A_x">x</code></td>
<td>
<p>The argument (lag) at which the autocorrelation function associated
with the long memory trawl function will be evaluated</p>
</td></tr>
<tr><td><code id="acf_LM_+3A_alpha">alpha</code></td>
<td>
<p>parameter in the long memory trawl</p>
</td></tr>
<tr><td><code id="acf_LM_+3A_h">H</code></td>
<td>
<p>parameter in the long memory trawl</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The trawl function is parametrised by the two parameters <code class="reqn">H&gt; 1</code>
and <code class="reqn">\alpha &gt; 0</code> as follows: </p>
<p style="text-align: center;"><code class="reqn">g(x) = (1-x/\alpha)^{-H},
  \mbox{ for  }  x \le 0.</code>
</p>
<p> Its autocorrelation function is given by
</p>
<p style="text-align: center;"><code class="reqn">r(x)=(1+x/\alpha)^{(1-H)}, \mbox{ for } x \ge 0.</code>
</p>



<h3>Value</h3>

<p>The autocorrelation function of the long memory trawl function
evaluated at x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>acf_LM(1,0.3,1.5)
</code></pre>

<hr>
<h2 id='acf_supIG'>Autocorrelation function of the supIG trawl function</h2><span id='topic+acf_supIG'></span>

<h3>Description</h3>

<p>This function computes the autocorrelation function associated with the supIG
trawl function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acf_supIG(x, delta, gamma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="acf_supIG_+3A_x">x</code></td>
<td>
<p>The argument (lag) at which the autocorrelation function associated
with the supIG trawl function will be evaluated</p>
</td></tr>
<tr><td><code id="acf_supIG_+3A_delta">delta</code></td>
<td>
<p>parameter in the supIG trawl</p>
</td></tr>
<tr><td><code id="acf_supIG_+3A_gamma">gamma</code></td>
<td>
<p>parameter in the supIG trawl</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The trawl function is parametrised by the two parameters <code class="reqn">\delta
 \geq 0</code> and <code class="reqn">\gamma \geq 0</code> as follows: </p>
<p style="text-align: center;"><code class="reqn">g(x) =
 (1-2x\gamma^{-2})^{-1/2}\exp(\delta \gamma(1-(1-2x\gamma^{-2})^{1/2})),
 \mbox{ for } x \le 0.</code>
</p>
<p> It is assumed that <code class="reqn">\delta</code> and <code class="reqn">\gamma</code> are
not simultaneously equal to zero. Its autocorrelation function is given by:
</p>
<p style="text-align: center;"><code class="reqn">r(x) = \exp(\delta\gamma (1-\sqrt{1+2 x/\gamma^2})),  \mbox{ for } x
 \ge 0.</code>
</p>



<h3>Value</h3>

<p>The autocorrelation function of the supIG trawl function evaluated at
x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>acf_supIG(1,0.3,0.1)
</code></pre>

<hr>
<h2 id='AddSlices_Rcpp'>Add slices and return vector of the sums of slices</h2><span id='topic+AddSlices_Rcpp'></span>

<h3>Description</h3>

<p>Add slices and return vector of the sums of slices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddSlices_Rcpp(slicematrix)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AddSlices_Rcpp_+3A_slicematrix">slicematrix</code></td>
<td>
<p>A matrix of slices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the vector of the sums of the slices
</p>

<hr>
<h2 id='AddWeightedSlices_Rcpp'>Add slices and return vector of the weighted sums of slices</h2><span id='topic+AddWeightedSlices_Rcpp'></span>

<h3>Description</h3>

<p>Add slices and return vector of the weighted sums of slices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AddWeightedSlices_Rcpp(slicematrix, weightvector)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AddWeightedSlices_Rcpp_+3A_slicematrix">slicematrix</code></td>
<td>
<p>A matrix of slices.</p>
</td></tr>
<tr><td><code id="AddWeightedSlices_Rcpp_+3A_weightvector">weightvector</code></td>
<td>
<p>A vector of weights.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the vector of the weighted sums of the slices
</p>

<hr>
<h2 id='asymptotic_variance'>Computing the true asymptotic variance in the CLT of the
trawl estimation</h2><span id='topic+asymptotic_variance'></span>

<h3>Description</h3>

<p>This function computes the theoretical asymptotic variance
appearing in the CLT of the trawl process for a given trawl function and
fourth cumulant.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asymptotic_variance(t, c4, varlevyseed = 1, trawlfct, trawlfct_par)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asymptotic_variance_+3A_t">t</code></td>
<td>
<p>Time point at which the asymptotic variance is computed</p>
</td></tr>
<tr><td><code id="asymptotic_variance_+3A_c4">c4</code></td>
<td>
<p>The fourth cumulant of the Levy seed of the trawl process</p>
</td></tr>
<tr><td><code id="asymptotic_variance_+3A_varlevyseed">varlevyseed</code></td>
<td>
<p>The variance of the Levy seed of the trawl process,
the default is 1</p>
</td></tr>
<tr><td><code id="asymptotic_variance_+3A_trawlfct">trawlfct</code></td>
<td>
<p>The trawl function for which the
asymptotic variance will be computed (Exp, supIG or LM)</p>
</td></tr>
<tr><td><code id="asymptotic_variance_+3A_trawlfct_par">trawlfct_par</code></td>
<td>
<p>The parameter vector of the trawl function
(Exp: lambda, supIG: delta, gamma, LM: alpha, H)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As derived in
Sauri and Veraart (2022), the asymptotic variance in the central limit
theorem for the trawl function estimation is given by
</p>
<p style="text-align: center;"><code class="reqn">\sigma_{a}^{2}(t)=c_{4}(L')a(t)+2\{ \int_{0}^{\infty}a(s)^{2}ds+
\int_{0}^{t}a(t-s)a(t+s)ds-\int_{t}^{\infty}a(s-t)a(t+s)ds\},</code>
</p>

<p>for <code class="reqn">t&gt;0</code>.
The integrals in the above formula are approximated numerically.
</p>


<h3>Value</h3>

<p>The function returns <code class="reqn">\sigma_{a}^{2}(t)</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Compute the asymptotic variance at time t for an exponential trawl with
#parameter 2; here we assume that the fourth cumulant equals 1.
av&lt;-asymptotic_variance(t=1, c4=1, varlevyseed=1, trawlfct="Exp", trawlfct_par=2)
#Print the av
av$v
#Print the four components of the asymptotic variance separately
av$v1
av$v2
av$v3
av$v4

#Note that v=v1+v2+v3+v4
av$v
av$v1+av$v2+av$v3+av$v4
</code></pre>

<hr>
<h2 id='asymptotic_variance_est'>Estimating the asymptotic variance in the trawl function CLT</h2><span id='topic+asymptotic_variance_est'></span>

<h3>Description</h3>

<p>This function estimates the asymptotic variance which appears in the
CLT for the trawl function estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asymptotic_variance_est(t, c4, varlevyseed = 1, Delta, avector, N = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asymptotic_variance_est_+3A_t">t</code></td>
<td>
<p>The time point at which to compute the asymptotic variance</p>
</td></tr>
<tr><td><code id="asymptotic_variance_est_+3A_c4">c4</code></td>
<td>
<p>The fourth cumulant of the Levy seed of the trawl process</p>
</td></tr>
<tr><td><code id="asymptotic_variance_est_+3A_varlevyseed">varlevyseed</code></td>
<td>
<p>The variance of the Levy seed of the trawl process,
the default is 1</p>
</td></tr>
<tr><td><code id="asymptotic_variance_est_+3A_delta">Delta</code></td>
<td>
<p>The width Delta of the observation grid</p>
</td></tr>
<tr><td><code id="asymptotic_variance_est_+3A_avector">avector</code></td>
<td>
<p>The vector <code class="reqn">(\hat a(0), \hat a(\Delta_n),
..., \hat a((n-1)\Delta_n))</code></p>
</td></tr>
<tr><td><code id="asymptotic_variance_est_+3A_n">N</code></td>
<td>
<p>The optional parameter to specify the upper bound <code class="reqn">N_n</code> in the
computations of the estimators</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As derived in
Sauri and Veraart (2022), the estimated asymptotic variance is given by
</p>
<p style="text-align: center;"><code class="reqn">\hat \sigma^2_a(t)=\hat v_1(t)+\hat v_2(t)+\hat v_3(t)+\hat v_4(t),</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">\hat{v}_{1}(t):=\widehat{c_{4}(L')}\hat{a}(t)=RQ_n\hat{a}(t)/
\hat{a}(0),</code>
</p>

<p>for
</p>
<p style="text-align: center;"><code class="reqn">RQ_n:=\frac{1}{\sqrt{2 n\Delta_{n}}}
\sum_{k=0}^{n-2}(X_{(k+1)\Delta_n}-X_{k\Delta_n})^4,</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">	\hat{v}_{2}(t):=2\sum_{l=0}^{N_{n}}\hat{a}^{2}(l\Delta_{n})
\Delta_{n},</code>
</p>

<p style="text-align: center;"><code class="reqn">	\hat{v}_{3}(t):=2\sum_{l=0}^{\min\{i,n-1-i\}}\hat{a}((i-l)\Delta_{n})
\hat{a}((i+l)\Delta_{n})\Delta_{n},</code>
</p>

<p style="text-align: center;"><code class="reqn">	\hat{v}_{4}(t):=-2\sum_{l=i}^{N_{n}-i}\hat{a}((l-i)\Delta_{n})
\hat{a}((i+l)\Delta_{n})\Delta_{n}.</code>
</p>



<h3>Value</h3>

<p>The estimated asymptotic variance <code class="reqn">\hat v=\hat \sigma_a^2(t)</code>
and its components <code class="reqn">\hat v_1, \hat v_2, \hat v_3, \hat v_4</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Simulate a trawl process
##Determine the sampling grid
my_n &lt;- 1000
my_delta &lt;- 0.1
my_t &lt;- my_n*my_delta

###Choose the model parameter
#Exponential trawl function:
my_lambda &lt;- 2
#Poisson marginal distribution trawl
my_v &lt;- 1

#Set the seed
set.seed(123)
#Simulate the trawl process
Poi_data &lt;- sim_weighted_trawl(my_n, my_delta,
                               "Exp", my_lambda, "Poi", my_v)$path

#Estimate the trawl function
my_lag &lt;- 100+1
trawl &lt;- nonpar_trawlest(Poi_data, my_delta, lag=my_lag)$a_hat

#Estimate the fourth cumulant of the trawl process
c4_est &lt;- c4est(Poi_data, my_delta)

asymptotic_variance_est(t=1, c4=c4_est, varlevyseed=1,
                        Delta=my_delta, avector=trawl)$v



</code></pre>

<hr>
<h2 id='c4est'>Estimating the fourth cumulant of the trawl process</h2><span id='topic+c4est'></span>

<h3>Description</h3>

<p>This function estimates the fourth cumulant of the trawl process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c4est(data, Delta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c4est_+3A_data">data</code></td>
<td>
<p>The data set used to estimate the fourth cumulant</p>
</td></tr>
<tr><td><code id="c4est_+3A_delta">Delta</code></td>
<td>
<p>The width Delta of the observation grid</p>
</td></tr>
</table>


<h3>Details</h3>

<p>According to
Sauri and Veraart (2022), estimator based on
<code class="reqn">X_0, X_{\Delta_n}, \ldots, X_{(n-1)\Delta_n}</code> is given by
</p>
<p style="text-align: center;"><code class="reqn">\hat c_4(L')=RQ_n/\hat a(0),</code>
</p>

<p>where
</p>
<p style="text-align: center;"><code class="reqn">RQ_n:=\frac{1}{\sqrt{2 n\Delta_{n}}}
\sum_{k=0}^{n-2}(X_{(k+1)\Delta_n}-X_{k\Delta_n})^4,</code>
</p>

<p>and
</p>
<p style="text-align: center;"><code class="reqn">\hat a(0)=\frac{1}{2\Delta_{n}n}
\sum_{k=0}^{n-2}(X_{(k+1)\Delta_n}-X_{k\Delta_n})^{2}.</code>
</p>



<h3>Value</h3>

<p>The function returns the estimated fourth cumulant of the Levy seed:
<code class="reqn">\hat c_4(L')</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Simulate a trawl process
##Determine the sampling grid
my_n &lt;- 1000
my_delta &lt;- 0.1
my_t &lt;- my_n*my_delta

###Choose the model parameter
#Exponential trawl function:
my_lambda &lt;- 2
#Poisson marginal distribution trawl
my_v &lt;- 1

#Set the seed
set.seed(123)
#Simulate the trawl process
Poi_data&lt;-ambit::sim_weighted_trawl(my_n, my_delta, "Exp", my_lambda, "Poi", my_v)$path

#Estimate the fourth cumulant of the trawl process
c4est(Poi_data, my_delta)
</code></pre>

<hr>
<h2 id='LebA_est'>Nonparametric estimation of the trawl set Leb(A)</h2><span id='topic+LebA_est'></span>

<h3>Description</h3>

<p>This function estimates the size of the trawl set given by Leb(A).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LebA_est(data, Delta, biascor = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LebA_est_+3A_data">data</code></td>
<td>
<p>Data to be used in the trawl function estimation.</p>
</td></tr>
<tr><td><code id="LebA_est_+3A_delta">Delta</code></td>
<td>
<p>Width of the grid on which we observe the data</p>
</td></tr>
<tr><td><code id="LebA_est_+3A_biascor">biascor</code></td>
<td>
<p>A binary variable determining whether a bias correction should
be computed, the default is FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimation of the trawl function using the methodology proposed in
Sauri and Veraart (2022).
</p>


<h3>Value</h3>

<p>The estimated Lebesgue measure of the trawl set
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##Simulate a trawl process
##Determine the sampling grid
my_n &lt;- 5000
my_delta &lt;- 0.1
my_t &lt;- my_n*my_delta

###Choose the model parameter
#Exponential trawl function:
my_lambda &lt;- 2
#Poisson marginal distribution trawl
my_v &lt;- 1

#Set the seed
set.seed(1726)
#Simulate the trawl process
Poi_data&lt;-ambit::sim_weighted_trawl(my_n, my_delta, "Exp", my_lambda, "Poi", my_v)$path

#Estimate the trawl set without bias correction
LebA1 &lt;-LebA_est(Poi_data, my_delta)
LebA1

#Estimate the trawl set with bias correction
LebA2 &lt;-LebA_est(Poi_data, my_delta, biascor=TRUE)
LebA2

#Note that Leb(A)=1/my_lambda for an exponential trawl

</code></pre>

<hr>
<h2 id='LebA_slice_est'>Nonparametric estimation of the trawl (sub-) sets
Leb(A), Leb(A intersection A_h), Leb(A setdifference A_h)</h2><span id='topic+LebA_slice_est'></span>

<h3>Description</h3>

<p>This function estimates Leb(A), Leb(A intersection A_h), Leb(A\ A_h).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LebA_slice_est(data, Delta, h, biascor = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LebA_slice_est_+3A_data">data</code></td>
<td>
<p>Data to be used in the trawl function estimation.</p>
</td></tr>
<tr><td><code id="LebA_slice_est_+3A_delta">Delta</code></td>
<td>
<p>Width of the grid on which we observe the data</p>
</td></tr>
<tr><td><code id="LebA_slice_est_+3A_h">h</code></td>
<td>
<p>Time point used in A intersection A_h and the setdifference
A setdifference A_h</p>
</td></tr>
<tr><td><code id="LebA_slice_est_+3A_biascor">biascor</code></td>
<td>
<p>A binary variable determining whether a bias correction should
be computed, the default is FALSE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimation of the trawl function using the methodology proposed in
Sauri and Veraart (2022).
</p>


<h3>Value</h3>

<p>LebA
</p>
<p>LebAintersection
</p>
<p>LebAsetdifference
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##Simulate a trawl process
##Determine the sampling grid
my_n &lt;- 5000
my_delta &lt;- 0.1
my_t &lt;- my_n*my_delta

###Choose the model parameter
#Exponential trawl function:
my_lambda &lt;- 2
#Poisson marginal distribution trawl
my_v &lt;- 1

#Set the seed
set.seed(1726)
#Simulate the trawl process
Poi_data&lt;-ambit::sim_weighted_trawl(my_n, my_delta, "Exp", my_lambda, "Poi", my_v)$path

#Estimate the trawl set and its two slices at time h=2 without bias correction
est1 &lt;- LebA_slice_est(Poi_data, my_delta, h=2)
est1$LebA
est1$LebAintersection
est1$LebAsetdifference

#Estimate the trawl set and its two slices at time h=2 without bias correction
est2 &lt;- LebA_slice_est(Poi_data, my_delta, h=2, biascor=TRUE)
est2$LebA
est2$LebAintersection
est2$LebAsetdifference

#Note that Leb(A)=1/my_lambda for an exponential trawl

</code></pre>

<hr>
<h2 id='LebA_slice_ratio_est_acfbased'>Nonparametric estimation of the ratios
Leb(A intersection A_h)/Leb(A), Leb(A setdifference A_h)/Leb(A)</h2><span id='topic+LebA_slice_ratio_est_acfbased'></span>

<h3>Description</h3>

<p>This function estimates the ratios
Leb(A intersection A_h)/Leb(A), Leb(A\ A_h)/Leb(A).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LebA_slice_ratio_est_acfbased(data, Delta, h)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LebA_slice_ratio_est_acfbased_+3A_data">data</code></td>
<td>
<p>Data to be used in the trawl function estimation.</p>
</td></tr>
<tr><td><code id="LebA_slice_ratio_est_acfbased_+3A_delta">Delta</code></td>
<td>
<p>Width of the grid on which we observe the data</p>
</td></tr>
<tr><td><code id="LebA_slice_ratio_est_acfbased_+3A_h">h</code></td>
<td>
<p>Time point used in A intersection A_h and the setdifference
A setdifference A_h</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimation of the trawl function using the methodology proposed in
Sauri and Veraart (2022) which is based on the empirical acf.
</p>


<h3>Value</h3>

<p>LebAintersection_ratio: LebAintersection/LebA
</p>
<p>LebAsetdifference_ratio: LebAsetdifference/LebA
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##Simulate a trawl process
##Determine the sampling grid
my_n &lt;- 5000
my_delta &lt;- 0.1
my_t &lt;- my_n*my_delta

###Choose the model parameter
#Exponential trawl function:
my_lambda &lt;- 2
#Poisson marginal distribution trawl
my_v &lt;- 1

#Set the seed
set.seed(1726)
#Simulate the trawl process
Poi_data&lt;-ambit::sim_weighted_trawl(my_n, my_delta, "Exp", my_lambda, "Poi", my_v)$path

#Estimate the trawl set and its two slices at time h=0.5
est &lt;- LebA_slice_ratio_est_acfbased(Poi_data, my_delta, h=0.5)
#Print the ratio LebAintersection/LebA
est$LebAintersection_ratio
#Print the ratio LebAsetdifference/LebA
est$LebAsetdifference_ratio

</code></pre>

<hr>
<h2 id='my_mae'>my_mse</h2><span id='topic+my_mae'></span>

<h3>Description</h3>

<p>Returns the mean absolute error between two vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>my_mae(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="my_mae_+3A_x">x</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="my_mae_+3A_y">y</code></td>
<td>
<p>vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Mean absolute error between the two vectors x and y
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Simulate two vectors of i.i.d.~standard normal data
set.seed(456)
x &lt;- rnorm(100)
y &lt;- rnorm(100)
#Compute the mean absolute error between both vectors
my_mae(x,y)
</code></pre>

<hr>
<h2 id='my_mse'>my_mse</h2><span id='topic+my_mse'></span>

<h3>Description</h3>

<p>Returns the mean squared error between two vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>my_mse(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="my_mse_+3A_x">x</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="my_mse_+3A_y">y</code></td>
<td>
<p>vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Mean square error between the two vectors x and y
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Simulate two vectors of i.i.d.~standard normal data
set.seed(456)
x &lt;- rnorm(100)
y &lt;- rnorm(100)
#Compute the mean squared error between both vectors
my_mse(x,y)
</code></pre>

<hr>
<h2 id='my_results'>my_results</h2><span id='topic+my_results'></span>

<h3>Description</h3>

<p>Returns summary statistics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>my_results(x, sd = 1, digits = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="my_results_+3A_x">x</code></td>
<td>
<p>data</p>
</td></tr>
<tr><td><code id="my_results_+3A_sd">sd</code></td>
<td>
<p>Optional parameter giving the standard deviation of the normal
distribution used for computing the coverage probabilities</p>
</td></tr>
<tr><td><code id="my_results_+3A_digits">digits</code></td>
<td>
<p>Optional parameter to how many digits the results
should be rounded, the default is three.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions returns the sample mean, sample standard deviation
and the coverage probabilities at level 75%, 80%, 85%, 90%, 95%, 99%
compared to the standard normal quantiles.
</p>


<h3>Value</h3>

<p>The vector of the sample mean, sample standard deviation
and the coverage probabilities at level 75%, 80%, 85%, 90%, 95%, 99%
compared to the standard normal quantiles.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#Simulate i.i.d.~standard normal data
set.seed(456)
data &lt;- rnorm(10000)
#Display the sample mean, standard deviation and coverage probabilities:
my_results(data)
</code></pre>

<hr>
<h2 id='nonpar_trawlest'>Nonparametric estimation of the trawl function</h2><span id='topic+nonpar_trawlest'></span>

<h3>Description</h3>

<p>This function implements the nonparametric trawl estimation proposed in
Sauri and Veraart (2022).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nonpar_trawlest(data, Delta, lag = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nonpar_trawlest_+3A_data">data</code></td>
<td>
<p>Data to be used in the trawl function estimation.</p>
</td></tr>
<tr><td><code id="nonpar_trawlest_+3A_delta">Delta</code></td>
<td>
<p>Width of the grid on which we observe the data</p>
</td></tr>
<tr><td><code id="nonpar_trawlest_+3A_lag">lag</code></td>
<td>
<p>The lag until which the trawl function should be estimated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Estimation of the trawl function using the methodology proposed in
Sauri and Veraart (2022). Suppose the data is observed on the grid
0, Delta, 2Delta, ..., (n-1)Delta. Given the path contained in data,
the function  returns the lag-dimensional
vector </p>
<p style="text-align: center;"><code class="reqn">(\hat a(0), \hat a(\Delta), \ldots, \hat a((lag-1) \Delta)).</code>
</p>

<p>In the case when lag=n, the n-1 dimensional vector
</p>
<p style="text-align: center;"><code class="reqn">(\hat a(0), \hat a(\Delta), \ldots, \hat a((n-2) \Delta))</code>
</p>
<p> is returned.
</p>


<h3>Value</h3>

<p>ahat Returns the lag-dimensional vector
<code class="reqn">(\hat a(0), \hat a(\Delta), \ldots, \hat a((lag-1) \Delta)).</code>
Here, <code class="reqn">\hat a(0)</code> is estimated
based on the realised variance estimator.
</p>
<p>a0_alt Returns the alternative estimator of a(0) using
the same methodology as the one used for
t&gt;0. Note that this is not the recommended estimator to use, but can be
used for comparison purposes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##Simulate a trawl process
##Determine the sampling grid
my_n &lt;- 5000
my_delta &lt;- 0.1
my_t &lt;- my_n*my_delta

###Choose the model parameter
#Exponential trawl function:
my_lambda &lt;- 2
#Poisson marginal distribution trawl
my_v &lt;- 1

#Set the seed
set.seed(1726)
#Simulate the trawl process
Poi_data&lt;-ambit::sim_weighted_trawl(my_n, my_delta, "Exp", my_lambda, "Poi", my_v)$path

#Estimate the trawl function
my_lag &lt;- 100+1
PoiEx_trawl &lt;- nonpar_trawlest(Poi_data, my_delta, lag=my_lag)$a_hat

#Plot the estimated trawl function and superimpose the true one
l_seq &lt;- seq(from = 0,to = (my_lag-1), by = 1)
esttrawlfct.data &lt;- base::data.frame(l=l_seq[1:31],
                               value=PoiEx_trawl[1:31])
p1 &lt;- ggplot2::ggplot(esttrawlfct.data, ggplot2::aes(x=l,y=value))+
  ggplot2::geom_point(size=3)+
  ggplot2::geom_function(fun = function(x) acf_Exp(x*my_delta,my_lambda), colour="red", size=1.5)+
  ggplot2::xlab("l")+
  ggplot2::ylab(latex2exp::TeX("$\\hat{a}(\\cdot)$ for Poisson trawl process"))
p1

</code></pre>

<hr>
<h2 id='rq'>Computing the scaled realised quarticity</h2><span id='topic+rq'></span>

<h3>Description</h3>

<p>This function computes the scaled realised quarticity of a time series
for a given width of the observation grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rq(data, Delta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rq_+3A_data">data</code></td>
<td>
<p>The data set used to compute the scaled realised quarticity</p>
</td></tr>
<tr><td><code id="rq_+3A_delta">Delta</code></td>
<td>
<p>The width Delta of the observation grid</p>
</td></tr>
</table>


<h3>Details</h3>

<p>According to
Sauri and Veraart (2022), the scaled realised quarticity for
<code class="reqn">X_0, X_{\Delta_n}, \ldots, X_{(n-1)\Delta_n}</code> is given by
</p>
<p style="text-align: center;"><code class="reqn">RQ_n:=\frac{1}{\sqrt{2 n\Delta_{n}}}
\sum_{k=0}^{n-2}(X_{(k+1)\Delta_n}-X_{k\Delta_n})^4.</code>
</p>



<h3>Value</h3>

<p>The function returns the scaled realised quarticity RQ_n.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Simulate a trawl process
##Determine the sampling grid
my_n &lt;- 1000
my_delta &lt;- 0.1
my_t &lt;- my_n*my_delta

###Choose the model parameter
#Exponential trawl function:
my_lambda &lt;- 2
#Poisson marginal distribution trawl
my_v &lt;- 1

#Set the seed
set.seed(123)
#Simulate the trawl process
Poi_data&lt;-ambit::sim_weighted_trawl(my_n, my_delta, "Exp", my_lambda, "Poi", my_v)$path

#Compute the scaled realised quarticity
rq(Poi_data, my_delta)
</code></pre>

<hr>
<h2 id='sim_weighted_trawl'>Simulation of a weighted trawl process</h2><span id='topic+sim_weighted_trawl'></span>

<h3>Description</h3>

<p>This function simulates a weighted trawl process for various
choices of the trawl function and the marginal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_weighted_trawl(
  n,
  Delta,
  trawlfct,
  trawlfct_par,
  distr,
  distr_par,
  kernelfct = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_weighted_trawl_+3A_n">n</code></td>
<td>
<p>number of grid points to be simulated (excluding the starting value)</p>
</td></tr>
<tr><td><code id="sim_weighted_trawl_+3A_delta">Delta</code></td>
<td>
<p>grid-width</p>
</td></tr>
<tr><td><code id="sim_weighted_trawl_+3A_trawlfct">trawlfct</code></td>
<td>
<p>the trawl function a used in the simulation (Exp, supIG or LM)</p>
</td></tr>
<tr><td><code id="sim_weighted_trawl_+3A_trawlfct_par">trawlfct_par</code></td>
<td>
<p>parameter vector of trawl function
(Exp: lambda, supIG: delta, gamma, LM: alpha, H)</p>
</td></tr>
<tr><td><code id="sim_weighted_trawl_+3A_distr">distr</code></td>
<td>
<p>marginal distribution. Choose from &quot;Gamma&quot; (Gamma),
&quot;Gauss&quot; (Gaussian), &quot;Cauchy&quot;
(Cauchy), &quot;NIG&quot; (Normal Inverse Gaussian),
Poi&quot; (Poisson), &quot;NegBin&quot; (Negative Binomial)</p>
</td></tr>
<tr><td><code id="sim_weighted_trawl_+3A_distr_par">distr_par</code></td>
<td>
<p>parameters of the marginal distribution:
(Gamma: shape, scale;
Gauss: mu, sigma (i.e. the second parameter is the standard deviation, not the
variance);
Cauchy: l, s;
NIG: alpha, beta, delta, mu;
Poi: v, NegBin: m, theta)</p>
</td></tr>
<tr><td><code id="sim_weighted_trawl_+3A_kernelfct">kernelfct</code></td>
<td>
<p>the kernel function p used in the ambit process</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions simulates a sample path from a weighted trawl process
given by
</p>
<p style="text-align: center;"><code class="reqn">	Y_t =\int_{(-\infty,t]\times (-\infty, \infty)}
p(t-s)I_{(0,a(t-s))}(x)L(dx,ds),</code>
</p>

<p>for   <code class="reqn">t \ge 0</code>,
and returns <code class="reqn">Y_0, Y_{\Delta}, \ldots, Y_{n\Delta}</code>.
</p>


<h3>Value</h3>

<p>path Simulated  path
</p>
<p>slice_sizes slice sizes used
</p>
<p>S_matrix Matrix of all slices
</p>
<p>kernelweights kernel weights used
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Simulation of a Gaussian trawl process with exponential trawl function
n&lt;-2000
Delta&lt;-0.1
trawlfct="Exp"
trawlfct_par &lt;-0.5
distr&lt;-"Gauss"
distr_par&lt;-c(0,1) #mean 0, std 1
set.seed(233)
path &lt;- sim_weighted_trawl(n, Delta, trawlfct, trawlfct_par, distr, distr_par)$path
#Plot the path
library(ggplot2)
df &lt;- data.frame(time = seq(0,n,1), value=path)
p &lt;- ggplot(df, aes(x=time, y=path))+
  geom_line()+
  xlab("l")+
  ylab("Trawl process")
  p

</code></pre>

<hr>
<h2 id='sim_weighted_trawl_gen'>Simulation of a weighted trawl process with generic trawl function</h2><span id='topic+sim_weighted_trawl_gen'></span>

<h3>Description</h3>

<p>This function simulates a weighted trawl process for a generic trawl
function and various
choices the marginal distribution. The specific trawl function
to be used can be supplied
directly by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_weighted_trawl_gen(
  n,
  Delta,
  trawlfct_gen,
  distr,
  distr_par,
  kernelfct = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sim_weighted_trawl_gen_+3A_n">n</code></td>
<td>
<p>number of grid points to be simulated (excluding the starting value)</p>
</td></tr>
<tr><td><code id="sim_weighted_trawl_gen_+3A_delta">Delta</code></td>
<td>
<p>grid-width</p>
</td></tr>
<tr><td><code id="sim_weighted_trawl_gen_+3A_trawlfct_gen">trawlfct_gen</code></td>
<td>
<p>the trawl function a used in the simulation</p>
</td></tr>
<tr><td><code id="sim_weighted_trawl_gen_+3A_distr">distr</code></td>
<td>
<p>marginal distribution. Choose from &quot;Gamma&quot; (Gamma),
&quot;Gauss&quot; (Gaussian), &quot;Cauchy&quot;
(Cauchy), &quot;NIG&quot; (Normal Inverse Gaussian),
Poi&quot; (Poisson), &quot;NegBin&quot; (Negative Binomial)</p>
</td></tr>
<tr><td><code id="sim_weighted_trawl_gen_+3A_distr_par">distr_par</code></td>
<td>
<p>parameters of the marginal distribution:
(Gamma: shape, scale;
Gauss: mu, sigma (i.e. the second parameter is the standard deviation, not the
variance);
Cauchy: l, s;
NIG: alpha, beta, delta, mu;
Poi: v, NegBin: m, theta)</p>
</td></tr>
<tr><td><code id="sim_weighted_trawl_gen_+3A_kernelfct">kernelfct</code></td>
<td>
<p>the kernel function p used in the ambit process</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This functions simulates a sample path from a weighted trawl process
given by
</p>
<p style="text-align: center;"><code class="reqn">	Y_t =\int_{(-\infty,t]\times (-\infty, \infty)}
p(t-s)I_{(0,a(t-s))}(x)L(dx,ds),</code>
</p>
<p> for <code class="reqn"> t \ge 0</code>,
and returns <code class="reqn">Y_0, Y_{\Delta}, \ldots, Y_{n\Delta}</code>.
The user needs to ensure that trawlfct_gen is a monotonic function.
</p>


<h3>Value</h3>

<p>path Simulated  path
</p>
<p>slice_sizes slice sizes used
</p>
<p>S_matrix Matrix of all slices
</p>
<p>kernelweights kernel weights used
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#Simulation of a Gaussian trawl process with exponential trawl function
n&lt;-2000
Delta&lt;-0.1

trawlfct_par &lt;-0.5
distr&lt;-"Gauss"
distr_par&lt;-c(0,1) #mean 0, std 1
set.seed(233)

a &lt;- function(x){exp(-trawlfct_par*x)}
path &lt;- sim_weighted_trawl_gen(n, Delta, a,
                           distr, distr_par)$path
#Plot the path
library(ggplot2)
df &lt;- data.frame(time = seq(0,n,1), value=path)
p &lt;- ggplot(df, aes(x=time, y=path))+
  geom_line()+
  xlab("l")+
  ylab("Trawl process")
p

</code></pre>

<hr>
<h2 id='test_asymnorm'>Computing the infeasible test statistic from the trawl function
estimation CLT</h2><span id='topic+test_asymnorm'></span>

<h3>Description</h3>

<p>This function computes the infeasible test statistic appearing in the CLT
for the trawl function estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_asymnorm(ahat, n, Delta, k, c4, varlevyseed = 1, trawlfct, trawlfct_par)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_asymnorm_+3A_ahat">ahat</code></td>
<td>
<p>The term <code class="reqn">\hat a(k \Delta_n)</code> in the CLT</p>
</td></tr>
<tr><td><code id="test_asymnorm_+3A_n">n</code></td>
<td>
<p>The number n of observations in the sample</p>
</td></tr>
<tr><td><code id="test_asymnorm_+3A_delta">Delta</code></td>
<td>
<p>The width Delta of the observation grid</p>
</td></tr>
<tr><td><code id="test_asymnorm_+3A_k">k</code></td>
<td>
<p>The time point in <code class="reqn">0, 1, \ldots, n-1</code>;
the test statistic will be computed for the time point
<code class="reqn">k*\Delta_n</code>.</p>
</td></tr>
<tr><td><code id="test_asymnorm_+3A_c4">c4</code></td>
<td>
<p>The fourth cumulant of the Levy seed of the trawl process</p>
</td></tr>
<tr><td><code id="test_asymnorm_+3A_varlevyseed">varlevyseed</code></td>
<td>
<p>The variance of the Levy seed of the trawl process,
the default is 1</p>
</td></tr>
<tr><td><code id="test_asymnorm_+3A_trawlfct">trawlfct</code></td>
<td>
<p>The trawl function for which the
asymptotic variance will be computed (Exp, supIG or LM)</p>
</td></tr>
<tr><td><code id="test_asymnorm_+3A_trawlfct_par">trawlfct_par</code></td>
<td>
<p>The parameter vector of the trawl function
(Exp: lambda, supIG: delta, gamma, LM: alpha, H)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As derived in
Sauri and Veraart (2022), the infeasible test statistic is given by
</p>
<p style="text-align: center;"><code class="reqn">\frac{\sqrt{n\Delta_{n}}}{\sqrt{\sigma_{a}^2(k \Delta_n)}}
\left(\hat{a}(k\Delta_n)-a(k \Delta_n)\right),</code>
</p>

<p>for <code class="reqn">k \in \{0, 1, \ldots, n-1\}</code>.
</p>


<h3>Value</h3>

<p>The function returns the infeasible test statistic specified above.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_asymnorm(ahat=0.9, n=5000, Delta=0.1, k=1, c4=1, varlevyseed=1,
              trawlfct="Exp", trawlfct_par=0.1)
</code></pre>

<hr>
<h2 id='test_asymnorm_est'>Computing the feasible statistic of the trawl function CLT</h2><span id='topic+test_asymnorm_est'></span>

<h3>Description</h3>

<p>This function computes the feasible statistics associated with the
CLT for the trawl function estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_asymnorm_est(
  data,
  Delta,
  trawlfct,
  trawlfct_par,
  biascor = FALSE,
  k = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_asymnorm_est_+3A_data">data</code></td>
<td>
<p>The data set based on observations of
<code class="reqn">X_0, X_{\Delta_n}, \ldots, X_{(n-1)\Delta_n}</code></p>
</td></tr>
<tr><td><code id="test_asymnorm_est_+3A_delta">Delta</code></td>
<td>
<p>The width Delta of the observation grid</p>
</td></tr>
<tr><td><code id="test_asymnorm_est_+3A_trawlfct">trawlfct</code></td>
<td>
<p>The trawl function for which the
asymptotic variance will be computed (Exp, supIG or LM)</p>
</td></tr>
<tr><td><code id="test_asymnorm_est_+3A_trawlfct_par">trawlfct_par</code></td>
<td>
<p>The parameter vector of the trawl function
(Exp: lambda, supIG: delta, gamma, LM: alpha, H)</p>
</td></tr>
<tr><td><code id="test_asymnorm_est_+3A_biascor">biascor</code></td>
<td>
<p>A binary variable determining whether a bias correction should
be computed, the default is FALSE</p>
</td></tr>
<tr><td><code id="test_asymnorm_est_+3A_k">k</code></td>
<td>
<p>The optional parameter specifying the time point in
<code class="reqn">0, 1, \ldots, n-1</code>;
the test statistic will be computed for the time point <code class="reqn">k \Delta_n</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As derived in
Sauri and Veraart (2022), the feasible statistic, for <code class="reqn">t&gt;0</code>,  is given by
</p>
<p style="text-align: center;"><code class="reqn">T(t)_n:=\frac{\sqrt{n\Delta_{n}}}{\sqrt{\widehat{\sigma_{a}^2(t)}}}
\left(\hat{a}(t)-a(t)-bias(t)\right).</code>
</p>

<p>For <code class="reqn">t=0</code>, we have </p>
<p style="text-align: center;"><code class="reqn">T(t)_n:=\frac{\sqrt{n\Delta_{n}}}{\sqrt{RQ_n}}
\left(\hat{a}(0)-a(0)-bias(0)\right),</code>
</p>
<p> where
</p>
<p style="text-align: center;"><code class="reqn">RQ_n:=\frac{1}{\sqrt{2 n\Delta_{n}}}
\sum_{k=0}^{n-2}(X_{(k+1)\Delta_n}-X_{k\Delta_n})^4.</code>
</p>

<p>We set <code class="reqn">bias(t)=0</code> in the case
when biascor==FALSE and <code class="reqn">bias(t)=0.5 * \Delta * \hat a'(t)</code> otherwise.
</p>


<h3>Value</h3>

<p>The function returns the vector of the feasible statistics
<code class="reqn">(T(0)_n, T((\Delta)_n, \ldots, T((n-2)\Delta_n))</code> if no bias correction
is required and <code class="reqn">(T(0)_n, T((\Delta)_n, \ldots, T((n-3)\Delta_n))</code> if
bias correction is required if k is not provided, otherwise it returns the
value <code class="reqn">T(k \Delta_n)_n</code>. If the estimated asymptotic variance is &lt;= 0,
the value of the test statistic is set to 999.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Simulate a trawl process
##Determine the sampling grid
my_n &lt;- 1000
my_delta &lt;- 0.1
my_t &lt;- my_n*my_delta

###Choose the model parameter
#Exponential trawl function:
my_lambda &lt;- 2
#Poisson marginal distribution trawl
my_v &lt;- 1

#Set the seed
set.seed(123)
#Simulate the trawl process
Poi_data &lt;- sim_weighted_trawl(my_n, my_delta,
                               "Exp", my_lambda, "Poi", my_v)$path

#Compute the test statistic for time t=0
##Either one can use:
test_asymnorm_est(Poi_data, my_delta,
                  trawlfct="Exp", trawlfct_par=my_lambda)[1]
#or:
test_asymnorm_est(Poi_data, my_delta,
                  trawlfct="Exp", trawlfct_par=my_lambda, k=0)
</code></pre>

<hr>
<h2 id='test_asymnorm_est_dev'>Computing the feasible statistic of the trawl function CLT</h2><span id='topic+test_asymnorm_est_dev'></span>

<h3>Description</h3>

<p>This function computes the feasible test statistic appearing in the CLT
for the trawl function estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_asymnorm_est_dev(
  ahat,
  n,
  Delta,
  k,
  c4,
  varlevyseed = 1,
  trawlfct,
  trawlfct_par,
  avector
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_asymnorm_est_dev_+3A_ahat">ahat</code></td>
<td>
<p>The estimated trawl function at time t: <code class="reqn">\hat{a}(t)</code></p>
</td></tr>
<tr><td><code id="test_asymnorm_est_dev_+3A_n">n</code></td>
<td>
<p>The number of observations in the data set</p>
</td></tr>
<tr><td><code id="test_asymnorm_est_dev_+3A_delta">Delta</code></td>
<td>
<p>The width Delta of the observation grid</p>
</td></tr>
<tr><td><code id="test_asymnorm_est_dev_+3A_k">k</code></td>
<td>
<p>The time point in <code class="reqn">0, 1, \ldots, n-1</code>;
the test statistic will be computed for the time point <code class="reqn">k * \Delta_n</code>.</p>
</td></tr>
<tr><td><code id="test_asymnorm_est_dev_+3A_c4">c4</code></td>
<td>
<p>The fourth cumulant of the Levy seed of the trawl process</p>
</td></tr>
<tr><td><code id="test_asymnorm_est_dev_+3A_varlevyseed">varlevyseed</code></td>
<td>
<p>The variance of the Levy seed of the trawl process,
the default is 1</p>
</td></tr>
<tr><td><code id="test_asymnorm_est_dev_+3A_trawlfct">trawlfct</code></td>
<td>
<p>The trawl function for which the
asymptotic variance will be computed (Exp, supIG or LM)</p>
</td></tr>
<tr><td><code id="test_asymnorm_est_dev_+3A_trawlfct_par">trawlfct_par</code></td>
<td>
<p>The parameter vector of the trawl function
(Exp: lambda, supIG: delta, gamma, LM: alpha, H)</p>
</td></tr>
<tr><td><code id="test_asymnorm_est_dev_+3A_avector">avector</code></td>
<td>
<p>The vector <code class="reqn">(\hat a(0), \hat a(Delta_n), ...,
\hat a((n-1)\Delta_n))</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>As derived in
Sauri and Veraart (2022), the feasible statistic is given by
</p>
<p style="text-align: center;"><code class="reqn">T(k \Delta_n)_n:=\frac{\sqrt{n\Delta_{n}}}{
\sqrt{\widehat{\sigma_{a}^2( \Delta_n)}}}
\left(\hat{a}( \Delta_n)-a( \Delta_n)\right)</code>
</p>
<p>.
</p>


<h3>Value</h3>

<p>The function returns the feasible statistic <code class="reqn">T( \Delta_n)_n</code>
if the estimated asymptotic variance is positive and 999 otherwise.
</p>

<hr>
<h2 id='trawl_deriv'>Estimating the derivative of the trawl function using the
empirical derivative</h2><span id='topic+trawl_deriv'></span>

<h3>Description</h3>

<p>This function estimates the derivative of the trawl function using
the empirical derivative of the trawl function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trawl_deriv(data, Delta, lag = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trawl_deriv_+3A_data">data</code></td>
<td>
<p>The data set used to compute the derivative of the trawl function</p>
</td></tr>
<tr><td><code id="trawl_deriv_+3A_delta">Delta</code></td>
<td>
<p>The width Delta of the observation grid</p>
</td></tr>
<tr><td><code id="trawl_deriv_+3A_lag">lag</code></td>
<td>
<p>The lag until which the trawl function should be estimated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>According to
Sauri and Veraart (2022), the derivative of the trawl function can
be estimated based on observations
<code class="reqn">X_0, X_{\Delta_n}, \ldots, X_{(n-1)\Delta_n}</code>  by
</p>
<p style="text-align: center;"><code class="reqn">\widehat a(t)=\frac{1}{\Delta_{n}}
(\hat a(t+\Delta_n)-\hat a(\Delta_n)),</code>
</p>

<p>for <code class="reqn">\Delta_nl\leq t &lt; (l+1)\Delta_n</code>.
</p>


<h3>Value</h3>

<p>The function returns the lag-dimensional vector
<code class="reqn">(\hat a'(0), \hat a'(\Delta), \ldots, \hat a'((lag-1) \Delta)).</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Simulate a trawl process
##Determine the sampling grid
my_n &lt;- 1000
my_delta &lt;- 0.1
my_t &lt;- my_n*my_delta

###Choose the model parameter
#Exponential trawl function:
my_lambda &lt;- 2
#Poisson marginal distribution trawl
my_v &lt;- 1

#Set the seed
set.seed(123)
#Simulate the trawl process
Poi_data &lt;- sim_weighted_trawl(my_n, my_delta,
                               "Exp", my_lambda, "Poi", my_v)$path

#Estimate the trawl function
my_lag &lt;- 100+1
trawl &lt;- nonpar_trawlest(Poi_data, my_delta, lag=my_lag)$a_hat

#Estimate the derivative of the trawl function
trawl_deriv &lt;- trawl_deriv(Poi_data, my_delta, lag=100)
</code></pre>

<hr>
<h2 id='trawl_deriv_mod'>Estimating the derivative of the trawl function</h2><span id='topic+trawl_deriv_mod'></span>

<h3>Description</h3>

<p>This function estimates the derivative of the trawl function using
the modified version proposed in Sauri and Veraart (2022).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trawl_deriv_mod(data, Delta, lag = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trawl_deriv_mod_+3A_data">data</code></td>
<td>
<p>The data set used to compute the derivative of the trawl function</p>
</td></tr>
<tr><td><code id="trawl_deriv_mod_+3A_delta">Delta</code></td>
<td>
<p>The width Delta of the observation grid</p>
</td></tr>
<tr><td><code id="trawl_deriv_mod_+3A_lag">lag</code></td>
<td>
<p>The lag until which the trawl function should be estimated</p>
</td></tr>
</table>


<h3>Details</h3>

<p>According to
Sauri and Veraart (2022), the derivative of the trawl function can
be estimated based on observations
<code class="reqn">X_0, X_{\Delta_n}, \ldots, X_{(n-1)\Delta_n}</code>  by
</p>
<p style="text-align: center;"><code class="reqn">\widehat a(t)=\frac{1}{\sqrt{ n\Delta_{n}^2}}
\sum_{k=l+1}^{n-2}(X_{(k+1)\Delta_n}-X_{k\Delta_n})
(X_{(k-l+1)\Delta_n}-X_{(k-l)\Delta_n}),</code>
</p>

<p>for <code class="reqn">\Delta_nl\leq t &lt; (l+1)\Delta_n</code>.
</p>


<h3>Value</h3>

<p>The function returns the lag-dimensional vector
<code class="reqn">(\hat a'(0), \hat a'(\Delta), \ldots, \hat a'((lag-1) \Delta)).</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##Simulate a trawl process
##Determine the sampling grid
my_n &lt;- 1000
my_delta &lt;- 0.1
my_t &lt;- my_n*my_delta

###Choose the model parameter
#Exponential trawl function:
my_lambda &lt;- 2
#Poisson marginal distribution trawl
my_v &lt;- 1

#Set the seed
set.seed(123)
#Simulate the trawl process
Poi_data &lt;- sim_weighted_trawl(my_n, my_delta,
                               "Exp", my_lambda, "Poi", my_v)$path

#Estimate the trawl function
my_lag &lt;- 100+1
trawl &lt;- nonpar_trawlest(Poi_data, my_delta, lag=my_lag)$a_hat

#Estimate the derivative of the trawl function
trawl_deriv &lt;- trawl_deriv_mod(Poi_data, my_delta, lag=100)
</code></pre>

<hr>
<h2 id='trawl_Exp'>Evaluates the exponential trawl function</h2><span id='topic+trawl_Exp'></span>

<h3>Description</h3>

<p>Evaluates the exponential trawl function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trawl_Exp(x, lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trawl_Exp_+3A_x">x</code></td>
<td>
<p>the argument at which the exponential trawl function will be
evaluated</p>
</td></tr>
<tr><td><code id="trawl_Exp_+3A_lambda">lambda</code></td>
<td>
<p>the parameter <code class="reqn">\lambda</code> in the exponential trawl</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The trawl function is parametrised by parameter <code class="reqn">\lambda &gt; 0</code> as
follows: </p>
<p style="text-align: center;"><code class="reqn">g(x) = e^{\lambda x},  \mbox{ for }  x \le 0.</code>
</p>



<h3>Value</h3>

<p>The exponential trawl function evaluated at x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trawl_Exp(-1,0.5)
</code></pre>

<hr>
<h2 id='trawl_LM'>Evaluates the long memory trawl function</h2><span id='topic+trawl_LM'></span>

<h3>Description</h3>

<p>Evaluates the long memory trawl function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trawl_LM(x, alpha, H)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trawl_LM_+3A_x">x</code></td>
<td>
<p>the argument at which the supOU/long memory trawl function will be
evaluated</p>
</td></tr>
<tr><td><code id="trawl_LM_+3A_alpha">alpha</code></td>
<td>
<p>the parameter <code class="reqn">\alpha</code> in the long memory trawl</p>
</td></tr>
<tr><td><code id="trawl_LM_+3A_h">H</code></td>
<td>
<p>the parameter <code class="reqn">H</code> in the long memory trawl</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The trawl function is parametrised by the two parameters <code class="reqn">H&gt; 1</code>
and <code class="reqn">\alpha &gt; 0</code> as follows: </p>
<p style="text-align: center;"><code class="reqn">g(x) = (1-x/\alpha)^{-H},
 \mbox{ for  }  x \le 0.</code>
</p>
<p> If <code class="reqn">H \in (1,2]</code>, then the resulting trawl
process has long memory, for <code class="reqn">H&gt;2</code>, it has short memory.
</p>


<h3>Value</h3>

<p>the long memory trawl function evaluated at x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trawl_LM(-1,0.5, 1.5)
</code></pre>

<hr>
<h2 id='trawl_supIG'>Evaluates the supIG trawl function</h2><span id='topic+trawl_supIG'></span>

<h3>Description</h3>

<p>Evaluates the supIG trawl function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trawl_supIG(x, delta, gamma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trawl_supIG_+3A_x">x</code></td>
<td>
<p>the argument at which the supIG trawl function will be evaluated</p>
</td></tr>
<tr><td><code id="trawl_supIG_+3A_delta">delta</code></td>
<td>
<p>the parameter <code class="reqn">\delta</code> in the supIG trawl</p>
</td></tr>
<tr><td><code id="trawl_supIG_+3A_gamma">gamma</code></td>
<td>
<p>the parameter <code class="reqn">\gamma</code> in the supIG trawl</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The trawl function is parametrised by the two parameters <code class="reqn">\delta
 \geq 0</code> and <code class="reqn">\gamma \geq 0</code> as follows: </p>
<p style="text-align: center;"><code class="reqn">gd(x) =
 (1-2x\gamma^{-2})^{-1/2}\exp(\delta \gamma(1-(1-2x\gamma^{-2})^{1/2})),
 \mbox{ for } x \le 0.</code>
</p>
<p> It is assumed that <code class="reqn">\delta</code> and <code class="reqn">\gamma</code> are
not simultaneously equal to zero.
</p>


<h3>Value</h3>

<p>The supIG trawl function evaluated at x
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trawl_supIG(-1,0.5,0.2)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
