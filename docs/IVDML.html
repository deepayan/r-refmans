<!DOCTYPE html><html lang="en"><head><title>Help for package IVDML</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {IVDML}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#IVDML-package'><p>IVDML: Double Machine Learning with Instrumental Variables and Heterogeneity</p></a></li>
<li><a href='#bandwidth_normal'><p>Compute Bandwidth Using the Normal Reference Rule</p></a></li>
<li><a href='#coef.IVDML'><p>Extract Treatment Effect Estimate from an IVDML Object</p></a></li>
<li><a href='#fit_IVDML'><p>Fitting Double Machine Learning Models with Instrumental Variables and Potentially Heterogeneous Treatment Effect</p></a></li>
<li><a href='#print.IVDML'><p>Print IVDML</p></a></li>
<li><a href='#robust_confint'><p>Compute Robust Confidence Interval for Treatment Effect in an IVDML Object</p></a></li>
<li><a href='#robust_p_value_aggregated'><p>Compute Aggregated Robust p-Value for Treatment Effect in an IVDML Object</p></a></li>
<li><a href='#se'><p>Compute Standard Error for the Treatment Effect Estimate in an IVDML Object</p></a></li>
<li><a href='#standard_confint'><p>Compute Standard Confidence Interval for the Treatment Effect Estimate in an IVDML Object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Double Machine Learning with Instrumental Variables and
Heterogeneity</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Description:</td>
<td>Instrumental variable (IV) estimators for homogeneous and
    heterogeneous treatment effects with efficient machine learning instruments.
    The estimators are based on double/debiased machine learning allowing for
    nonlinear and potentially high-dimensional control variables. Details can 
    be found in Scheidegger, Guo and Bühlmann (2025) "Inference for 
    heterogeneous treatment effects with efficient instruments and machine 
    learning" &lt;<a href="https://doi.org/10.48550%2FarXiv.2503.03530">doi:10.48550/arXiv.2503.03530</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/cyrillsch/IVDML">https://github.com/cyrillsch/IVDML</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>Imports:</td>
<td>mgcv, ranger, stats, xgboost</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-10 12:55:29 UTC; scyrill</td>
</tr>
<tr>
<td>Author:</td>
<td>Cyrill Scheidegger
    <a href="https://orcid.org/0009-0005-2851-1384"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre,
    cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Cyrill Scheidegger &lt;cyrill.scheidegger@stat.math.ethz.ch&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-11 16:40:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='IVDML-package'>IVDML: Double Machine Learning with Instrumental Variables and Heterogeneity</h2><span id='topic+IVDML'></span><span id='topic+IVDML-package'></span>

<h3>Description</h3>

<p>Instrumental variable (IV) estimators for homogeneous and heterogeneous treatment effects with efficient machine learning instruments. The estimators are based on double/debiased machine learning allowing for nonlinear and potentially high-dimensional control variables. Details can be found in Scheidegger, Guo and Bühlmann (2025) &quot;Inference for heterogeneous treatment effects with efficient instruments and machine learning&quot; <a href="https://doi.org/10.48550/arXiv.2503.03530">doi:10.48550/arXiv.2503.03530</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Cyrill Scheidegger <a href="mailto:cyrill.scheidegger@stat.math.ethz.ch">cyrill.scheidegger@stat.math.ethz.ch</a> (<a href="https://orcid.org/0009-0005-2851-1384">ORCID</a>) [copyright holder]
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/cyrillsch/IVDML">https://github.com/cyrillsch/IVDML</a>
</p>
</li></ul>


<hr>
<h2 id='bandwidth_normal'>Compute Bandwidth Using the Normal Reference Rule</h2><span id='topic+bandwidth_normal'></span>

<h3>Description</h3>

<p>This function calculates the bandwidth for kernel smoothing using the Normal Reference Rule. The rule is based on Silverman's rule of thumb, which selects the bandwidth as a function of the standard deviation and interquartile range (IQR) of the data. The bandwidth is computed as: <code class="reqn">h = 1.06 \times \min(\mathrm{sd}(A), \mathrm{IQR}(A) / 1.34) / N^{0.2}</code>, where <code class="reqn">\mathrm{sd}(A)</code> is the standard deviation of <code>A</code>, <code class="reqn">\mathrm{IQR}(A)</code> is the interquartile range and <code>N</code> is the length of <code>A</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bandwidth_normal(A)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bandwidth_normal_+3A_a">A</code></td>
<td>
<p>Numeric vector. The data for which the bandwidth is to be computed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the computed bandwidth.
</p>


<h3>References</h3>

<p>Silverman, B. W. (1986). <em>Density Estimation for Statistics and Data Analysis</em>.  Chapman &amp; Hall/CRC monographs on statistics and applied probability.  Chapman &amp; Hall.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
A &lt;- rnorm(100)
bandwidth_normal(A)

</code></pre>

<hr>
<h2 id='coef.IVDML'>Extract Treatment Effect Estimate from an IVDML Object</h2><span id='topic+coef.IVDML'></span>

<h3>Description</h3>

<p>This function computes the estimated (potentially heterogeneous) treatment effect from a fitted <code>IVDML</code> object (output of <code><a href="#topic+fit_IVDML">fit_IVDML()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'IVDML'
coef(
  object,
  iv_method,
  a = NULL,
  A = NULL,
  kernel_name = NULL,
  bandwidth = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="coef.IVDML_+3A_object">object</code></td>
<td>
<p>An object of class <code>IVDML</code>, produced by the <code><a href="#topic+fit_IVDML">fit_IVDML()</a></code> function.</p>
</td></tr>
<tr><td><code id="coef.IVDML_+3A_iv_method">iv_method</code></td>
<td>
<p>Character. The instrumental variable estimation method to use. Must be one of the methods specified in the fitted object.</p>
</td></tr>
<tr><td><code id="coef.IVDML_+3A_a">a</code></td>
<td>
<p>Numeric (optional). A specific value of <code>A</code> at which to evaluate the heterogeneous treatment effect. If <code>NULL</code>, the function returns the homogeneous treatment effect.</p>
</td></tr>
<tr><td><code id="coef.IVDML_+3A_a">A</code></td>
<td>
<p>Numeric vector (optional). The variable with respect to which treatment effect heterogeneity is considered. If <code>NULL</code>, the function assumes the <code>A</code> used in model fitting.</p>
</td></tr>
<tr><td><code id="coef.IVDML_+3A_kernel_name">kernel_name</code></td>
<td>
<p>Character (optional). The name of the kernel function to use for smoothing (if a heterogeneous treatment effect is estimated). Needs to be one of &quot;boxcar&quot;, &quot;gaussian&quot;, &quot;epanechnikov&quot; or &quot;tricube&quot;.</p>
</td></tr>
<tr><td><code id="coef.IVDML_+3A_bandwidth">bandwidth</code></td>
<td>
<p>Numeric (optional). The bandwidth for the kernel smoothing (if a heterogeneous treatment effect is estimated).</p>
</td></tr>
<tr><td><code id="coef.IVDML_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>a</code> is not specified, the estimated homogeneous treatment effect is returned. If <code>a</code> is specified, the heterogeneous treatment effect <code class="reqn">\beta(a)</code> at <code class="reqn">A = a</code> is returned.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
Z &lt;- rnorm(100)
X &lt;- Z + rnorm(100)
H &lt;- rnorm(100)
D &lt;- Z^2 + sin(X) + H + rnorm(100)
A &lt;- X
Y &lt;- tanh(A) * D + cos(X) - H + rnorm(100)
fit &lt;- fit_IVDML(Y = Y, D = D, Z = Z, X = X, ml_method = "gam")
coef(fit, iv_method = "mlIV")
coef(fit, iv_method = "mlIV", a = 0, A = A, kernel_name = "boxcar", bandwidth = 0.2)

</code></pre>

<hr>
<h2 id='fit_IVDML'>Fitting Double Machine Learning Models with Instrumental Variables and Potentially Heterogeneous Treatment Effect</h2><span id='topic+fit_IVDML'></span>

<h3>Description</h3>

<p>This function is used to fit a Double Machine Learning (DML) model with Instrumental Variables (IV) with the goal to perform inference on potentially heterogeneous treatment effects. The model under study is <code class="reqn">Y = \beta(A)D + g(X) + \epsilon</code>, where the error <code class="reqn">\epsilon</code> is potentially correlated with the treatment <code class="reqn">D</code>, but there is an IV <code class="reqn">Z</code> satisfying <code class="reqn">\mathbb E[\epsilon|Z,X] = 0</code>. The object of interest is the treatment effect <code class="reqn">\beta</code> of the treatment <code class="reqn">D</code> on the response <code class="reqn">Y</code>. The treatment effect <code class="reqn">\beta</code> is either constant or can depend on the univariate quantity <code class="reqn">A</code>, which is typically a component of the covariates <code class="reqn">X</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_IVDML(
  Y,
  D,
  Z,
  X = NULL,
  A = NULL,
  ml_method,
  ml_par = list(),
  A_deterministic_X = TRUE,
  K_dml = 5,
  iv_method = c("linearIV", "mlIV"),
  S_split = 1
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fit_IVDML_+3A_y">Y</code></td>
<td>
<p>Numeric vector. Response variable.</p>
</td></tr>
<tr><td><code id="fit_IVDML_+3A_d">D</code></td>
<td>
<p>Numeric vector. Treatment variable.</p>
</td></tr>
<tr><td><code id="fit_IVDML_+3A_z">Z</code></td>
<td>
<p>Matrix, vector, or data frame. Instrumental variables.</p>
</td></tr>
<tr><td><code id="fit_IVDML_+3A_x">X</code></td>
<td>
<p>Matrix, vector, or data frame. Additional covariates (default: NULL).</p>
</td></tr>
<tr><td><code id="fit_IVDML_+3A_a">A</code></td>
<td>
<p>Numeric vector. Variable with respect to which treatment effect heterogeneity is considered. Usually equal to a column of X and in this case it can also be specified later (default: NULL).</p>
</td></tr>
<tr><td><code id="fit_IVDML_+3A_ml_method">ml_method</code></td>
<td>
<p>Character. Machine learning method to use. Options are &quot;gam&quot;, &quot;xgboost&quot;, and &quot;randomForest&quot;.</p>
</td></tr>
<tr><td><code id="fit_IVDML_+3A_ml_par">ml_par</code></td>
<td>
<p>List. Parameters for the machine learning method:
</p>

<ul>
<li><p> If <code>ml_method == "gam"</code>, can specify <code>ind_lin_Z</code> and <code>ind_lin_X</code> for components of <code>Z</code> and <code>X</code> to be modeled linearly.
</p>
</li>
<li><p> If <code>ml_method == "xgboost"</code>, can specify <code>max_nrounds</code>, <code>k_cv</code>, <code>early_stopping_rounds</code>, and vectors <code>eta</code> and <code>max_depth</code>.
</p>
</li>
<li><p> If <code>ml_method == "randomForest"</code>, can specify <code>num.trees</code>, <code>num_mtry</code> (number of different mtry values to try out) or a vector <code>mtry</code>, a vector <code>max.depth</code>, <code>num_min.node.size</code> (number of different min.node.size values to try out) or a vector <code>min.node.size</code>.
</p>
</li>
<li><p> To specify different parameters for the different nuisance function regressions, <code>ml_par</code> should be a list of lists: <code>ml_par_D_XZ</code> (parameters for nuisance function <code class="reqn">\mathbb E[D|Z, X]</code>, needed for <code>iv_method</code> &quot;mlIV&quot; and &quot;mlIV_direct&quot;), <code>ml_par_D_X</code> (parameters for nuisance function <code class="reqn">\mathbb E[D|X]</code>, needed for <code>iv_method</code> &quot;linearIV&quot;, &quot;mlIV&quot; and &quot;mlIV_direct&quot;), <code>ml_par_f_X</code> (parameters for nuisance function <code class="reqn">\mathbb E[\widehat{\mathbb E}[D|Z, X]|X]</code>, needed for <code>iv_method</code> &quot;mlIV&quot;), <code>ml_par_Y_X</code> (parameters for nuisance function <code class="reqn">\mathbb E[Y|X]</code>, needed for <code>iv_method</code> &quot;linearIV&quot;, &quot;mlIV&quot; and &quot;mlIV_direct&quot;), <code>ml_par_Z_X</code> (parameters for nuisance function <code class="reqn">\mathbb E[Z|X]</code>, needed for <code>iv_method</code> &quot;linearIV&quot;).
</p>
</li></ul>
</td></tr>
<tr><td><code id="fit_IVDML_+3A_a_deterministic_x">A_deterministic_X</code></td>
<td>
<p>Logical. Whether <code>A</code> is a deterministic function of <code>X</code> (default: TRUE).</p>
</td></tr>
<tr><td><code id="fit_IVDML_+3A_k_dml">K_dml</code></td>
<td>
<p>Integer. Number of cross-fitting folds (default: 5).</p>
</td></tr>
<tr><td><code id="fit_IVDML_+3A_iv_method">iv_method</code></td>
<td>
<p>Character vector. Instrumental variables estimation method. Options:
&quot;linearIV&quot;, &quot;mlIV&quot;, &quot;mlIV_direct&quot; (default: c(&quot;linearIV&quot;, &quot;mlIV&quot;)). &quot;linearIV&quot; corresponds to using instruments linearly and &quot;mlIV&quot; corresponds to using machine learning instruments. &quot;mlIV_direct&quot; is a variant of &quot;mlIV&quot; that uses the same estimate of <code class="reqn">\mathbb E[D|X]</code> for both the residuals <code class="reqn">X - \mathbb E[D|X]</code> and <code class="reqn">\mathbb E[D|Z, X] - \mathbb E[D|X]</code>, whereas &quot;mlIV&quot; uses a two-stage estimate of <code class="reqn">\mathbb E[\widehat{\mathbb E}[D|Z, X]|X]</code> for the residuals <code class="reqn">\mathbb E[D|Z, X] - \mathbb E[D|X]</code>.</p>
</td></tr>
<tr><td><code id="fit_IVDML_+3A_s_split">S_split</code></td>
<td>
<p>Integer. Number of sample splits for cross-fitting (default: 1).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>IVDML</code>, containing:
</p>

<ul>
<li> <p><code>results_splits</code>: A list of S_split lists of cross-fitted residuals from the different sample splits.
</p>
</li>
<li> <p><code>A</code>: The argument <code>A</code> of the function.
</p>
</li>
<li> <p><code>ml_method</code>: The argument <code>ml_method</code> of the function.
</p>
</li>
<li> <p><code>A_deterministic_X</code>: The argument <code>A_deterministic_X</code> of the function.
</p>
</li>
<li> <p><code>iv_method</code>: The argument <code>iv_method</code> of the function.
The treatment effect estimates, standard errors and confidence intervals can be calculated from the <code>IVDML</code> object using the functions <code><a href="#topic+coef.IVDML">coef.IVDML()</a></code>, <code><a href="#topic+se">se()</a></code>, <code><a href="#topic+standard_confint">standard_confint()</a></code>, <code><a href="#topic+robust_confint">robust_confint()</a></code>.
</p>
</li></ul>



<h3>References</h3>

<p>Cyrill Scheidegger, Zijian Guo and Peter Bühlmann. Inference for heterogeneous treatment effects with efficient instruments and machine learning. Preprint, arXiv:2503.03530, 2025.
</p>


<h3>See Also</h3>

<p>Inference for a fitted <code>IVDML</code> object is done with the functions <code><a href="#topic+coef.IVDML">coef.IVDML()</a></code>, <code><a href="#topic+se">se()</a></code>, <code><a href="#topic+standard_confint">standard_confint()</a></code> and <code><a href="#topic+robust_confint">robust_confint()</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
Z &lt;- rnorm(100)
X &lt;- Z + rnorm(100)
H &lt;- rnorm(100)
D &lt;- Z^2 + sin(X) + H + rnorm(100)
A &lt;- X
Y &lt;- tanh(A) * D + cos(X) - H + rnorm(100)
fit &lt;- fit_IVDML(Y = Y, D = D, Z = Z, X = X, A = A, ml_method = "gam")
coef(fit, iv_method = "mlIV", a = 0, A = A, kernel_name = "boxcar", bandwidth = 0.2)

</code></pre>

<hr>
<h2 id='print.IVDML'>Print IVDML</h2><span id='topic+print.IVDML'></span>

<h3>Description</h3>

<p>Print information for an IVDML object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'IVDML'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.IVDML_+3A_x">x</code></td>
<td>
<p>Fitted object of class <code>IVDML</code>.</p>
</td></tr>
<tr><td><code id="print.IVDML_+3A_...">...</code></td>
<td>
<p>Further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side effects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
Z &lt;- rnorm(100)
X &lt;- Z + rnorm(100)
H &lt;- rnorm(100)
D &lt;- Z^2 + sin(X) + H + rnorm(100)
A &lt;- X
Y &lt;- tanh(A) * D + cos(X) - H + rnorm(100)
fit &lt;- fit_IVDML(Y = Y, D = D, Z = Z, X = X, A = A, ml_method = "gam")
print(fit)

</code></pre>

<hr>
<h2 id='robust_confint'>Compute Robust Confidence Interval for Treatment Effect in an IVDML Object</h2><span id='topic+robust_confint'></span>

<h3>Description</h3>

<p>This function computes a robust (with respect to weak IV) confidence interval/confidence set for the estimated treatment effect in a fitted <code>IVDML</code> object (output of <code><a href="#topic+fit_IVDML">fit_IVDML()</a></code>). The confidence interval/confidence set is constructed by inverting the robust test from the <code><a href="#topic+robust_p_value_aggregated">robust_p_value_aggregated()</a></code> function, which either uses the Double Machine Learning aggregation method (<code>"DML_agg"</code>) or the quantile-based method of Meinshausen, Meier, and Bühlmann (2009) (<code>"MMB_agg"</code>) to aggregate the p-values corresponding to the <code>S_split</code> cross-fitting sample splits (where <code>S_split</code> was an argument of the <code><a href="#topic+fit_IVDML">fit_IVDML()</a></code> function).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robust_confint(
  object,
  iv_method,
  level = 0.95,
  a = NULL,
  A = NULL,
  kernel_name = NULL,
  bandwidth = NULL,
  CI_range = NULL,
  agg_method = "DML_agg",
  gamma = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="robust_confint_+3A_object">object</code></td>
<td>
<p>An object of class <code>IVDML</code>, produced by the <code><a href="#topic+fit_IVDML">fit_IVDML()</a></code> function.</p>
</td></tr>
<tr><td><code id="robust_confint_+3A_iv_method">iv_method</code></td>
<td>
<p>Character. The instrumental variable estimation method to use. Must be one of the methods specified in the fitted object.</p>
</td></tr>
<tr><td><code id="robust_confint_+3A_level">level</code></td>
<td>
<p>Numeric (default: 0.95). The confidence level for the confidence interval.</p>
</td></tr>
<tr><td><code id="robust_confint_+3A_a">a</code></td>
<td>
<p>Numeric (optional). A specific value of <code>A</code> at which to compute the confidence interval for the heterogeneous treatment effect. If <code>NULL</code>, the function returns the confidence interval for the homogeneous treatment effect.</p>
</td></tr>
<tr><td><code id="robust_confint_+3A_a">A</code></td>
<td>
<p>Numeric vector (optional). The variable with respect to which treatment effect heterogeneity is considered. If <code>NULL</code>, the function assumes the <code>A</code> used in model fitting.</p>
</td></tr>
<tr><td><code id="robust_confint_+3A_kernel_name">kernel_name</code></td>
<td>
<p>Character (optional). The name of the kernel function to use for smoothing (if a heterogeneous treatment effect is estimated). Must be one of <code>"boxcar"</code>, <code>"gaussian"</code>, <code>"epanechnikov"</code>, or <code>"tricube"</code>.</p>
</td></tr>
<tr><td><code id="robust_confint_+3A_bandwidth">bandwidth</code></td>
<td>
<p>Numeric (optional). The bandwidth for the kernel smoothing (if a heterogeneous treatment effect is estimated).</p>
</td></tr>
<tr><td><code id="robust_confint_+3A_ci_range">CI_range</code></td>
<td>
<p>Numeric vector of length 2 (optional). The search range for the confidence interval. If <code>NULL</code>, the function sets <code>CI_range</code> to be four times as large as the standard confidence interval centered at the point estimate of the treatment effect.</p>
</td></tr>
<tr><td><code id="robust_confint_+3A_agg_method">agg_method</code></td>
<td>
<p>Character (default: <code>"DML_agg"</code>). The aggregation method for computing the confidence interval. Options are:
</p>

<ul>
<li> <p><code>"DML_agg"</code>: Uses the Double Machine Learning (DML) aggregation approach.
</p>
</li>
<li> <p><code>"MMB_agg"</code>: Uses the quantile-based aggregation method of Meinshausen, Meier, and Bühlmann (2009).
</p>
</li></ul>
</td></tr>
<tr><td><code id="robust_confint_+3A_gamma">gamma</code></td>
<td>
<p>Numeric (default: 0.5). Quantile level for the <code>"MMB_agg"</code> method. Ignored if <code>agg_method = "DML_agg"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements:
</p>

<ul>
<li> <p><code>CI</code>: A named numeric vector with the lower and upper bounds of the confidence interval.
</p>
</li>
<li> <p><code>level</code>: The confidence level used.
</p>
</li>
<li> <p><code>message</code>: A message describing the nature of the confidence set (e.g., whether it spans the full range, is non-connected, or is empty due to optimization failure).
</p>
</li>
<li> <p><code>heterogeneous_parameters</code>: A list of parameters (<code>a</code>, <code>kernel_name</code>, <code>bandwidth</code>) if a heterogeneous treatment effect is considered; otherwise, <code>NULL</code>.
</p>
</li></ul>



<h3>References</h3>

<p>Meinshausen, N., Meier, L., &amp; Bühlmann, P. (2009). <em>P-values for high-dimensional regression</em>. Journal of the American Statistical Association, 104(488), 1671–1681.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
Z &lt;- rnorm(100)
X &lt;- Z + rnorm(100)
H &lt;- rnorm(100)
D &lt;- Z^2 + sin(X) + H + rnorm(100)
A &lt;- X
Y &lt;- tanh(A) * D + cos(X) - H + rnorm(100)
fit &lt;- fit_IVDML(Y = Y, D = D, Z = Z, X = X, ml_method = "gam")
robust_confint(fit, iv_method = "mlIV", CI_range = c(-10, 10))
robust_confint(fit, iv_method = "mlIV", a = 0, A = A,
               kernel_name = "boxcar", bandwidth = 0.2, CI_range = c(-10, 10))

</code></pre>

<hr>
<h2 id='robust_p_value_aggregated'>Compute Aggregated Robust p-Value for Treatment Effect in an IVDML Object</h2><span id='topic+robust_p_value_aggregated'></span>

<h3>Description</h3>

<p>This function calculates an aggregated robust (with respect to weak IV) p-value for testing a candidate treatment effect value in a fitted <code>IVDML</code> object (output of <code><a href="#topic+fit_IVDML">fit_IVDML()</a></code>), using either the the standard Double Machine Learning aggregation method (&quot;DML_agg&quot;) or the method by Meinshausen, Meier, and Bühlmann (2009) (&quot;MMB_agg&quot;) to aggregate the p-values corresponding to the <code>S_split</code> cross-fitting sample splits (where <code>S_split</code> was an argument of the <code><a href="#topic+fit_IVDML">fit_IVDML()</a></code> function).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>robust_p_value_aggregated(
  object,
  candidate_value,
  iv_method,
  a = NULL,
  A = NULL,
  kernel_name = NULL,
  bandwidth = NULL,
  agg_method = "DML_agg",
  gamma = 0.5
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="robust_p_value_aggregated_+3A_object">object</code></td>
<td>
<p>An object of class <code>IVDML</code>, produced by the <code><a href="#topic+fit_IVDML">fit_IVDML()</a></code> function.</p>
</td></tr>
<tr><td><code id="robust_p_value_aggregated_+3A_candidate_value">candidate_value</code></td>
<td>
<p>Numeric. The candidate treatment effect value to test.</p>
</td></tr>
<tr><td><code id="robust_p_value_aggregated_+3A_iv_method">iv_method</code></td>
<td>
<p>Character. The instrumental variable estimation method to use. Must be one of the methods specified in the fitted object.</p>
</td></tr>
<tr><td><code id="robust_p_value_aggregated_+3A_a">a</code></td>
<td>
<p>Numeric (optional). A specific value of <code>A</code> at which to compute the p-value for the heterogeneous treatment effect. If <code>NULL</code>, the function returns the p-value for the homogeneous treatment effect.</p>
</td></tr>
<tr><td><code id="robust_p_value_aggregated_+3A_a">A</code></td>
<td>
<p>Numeric vector (optional). The variable with respect to which treatment effect heterogeneity is considered. If <code>NULL</code>, the function assumes the <code>A</code> used in model fitting.</p>
</td></tr>
<tr><td><code id="robust_p_value_aggregated_+3A_kernel_name">kernel_name</code></td>
<td>
<p>Character (optional). The name of the kernel function to use for smoothing (if a heterogeneous treatment effect is estimated). Must be one of &quot;boxcar&quot;, &quot;gaussian&quot;, &quot;epanechnikov&quot;, or &quot;tricube&quot;.</p>
</td></tr>
<tr><td><code id="robust_p_value_aggregated_+3A_bandwidth">bandwidth</code></td>
<td>
<p>Numeric (optional). The bandwidth for the kernel smoothing (if a heterogeneous treatment effect is estimated).</p>
</td></tr>
<tr><td><code id="robust_p_value_aggregated_+3A_agg_method">agg_method</code></td>
<td>
<p>Character (default: &quot;DML_agg&quot;). The aggregation method for computing the p-value. Options are:
</p>

<ul>
<li> <p><code>"DML_agg"</code>: Uses the Double Machine Learning (DML) aggregation approach.
</p>
</li>
<li> <p><code>"MMB_agg"</code>: Uses the quantile-based aggregation method of Meinshausen, Meier, and Bühlmann (2009).
</p>
</li></ul>
</td></tr>
<tr><td><code id="robust_p_value_aggregated_+3A_gamma">gamma</code></td>
<td>
<p>Numeric (default: 0.5). Quantile level for the <code>"MMB_agg"</code> method. Ignored if <code>agg_method = "DML_agg"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The aggregated robust p-value for testing the candidate treatment effect.
</p>


<h3>References</h3>

<p>Meinshausen, N., Meier, L., &amp; Bühlmann, P. (2009). <em>P-values for high-dimensional regression</em>. Journal of the American Statistical Association, 104(488), 1671–1681.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
Z &lt;- rnorm(100)
X &lt;- Z + rnorm(100)
H &lt;- rnorm(100)
D &lt;- Z^2 + sin(X) + H + rnorm(100)
A &lt;- X
Y &lt;- tanh(A) * D + cos(X) - H + rnorm(100)
fit &lt;- fit_IVDML(Y = Y, D = D, Z = Z, X = X, A = A, ml_method = "gam")
robust_p_value_aggregated(fit, candidate_value = 0, iv_method = "mlIV")
robust_p_value_aggregated(fit, candidate_value = 0, iv_method = "mlIV",
                          a = 0, A = A, kernel_name = "boxcar", bandwidth = 0.2)

</code></pre>

<hr>
<h2 id='se'>Compute Standard Error for the Treatment Effect Estimate in an IVDML Object</h2><span id='topic+se'></span>

<h3>Description</h3>

<p>This function calculates the standard error of the estimated (potentially heterogeneous) treatment effect from a fitted <code>IVDML</code> object (output of <code><a href="#topic+fit_IVDML">fit_IVDML()</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>se(object, iv_method, a = NULL, A = NULL, kernel_name = NULL, bandwidth = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="se_+3A_object">object</code></td>
<td>
<p>An object of class <code>IVDML</code>, produced by the <code><a href="#topic+fit_IVDML">fit_IVDML()</a></code> function.</p>
</td></tr>
<tr><td><code id="se_+3A_iv_method">iv_method</code></td>
<td>
<p>Character. The instrumental variable estimation method to use. Must be one of the methods specified in the fitted object.</p>
</td></tr>
<tr><td><code id="se_+3A_a">a</code></td>
<td>
<p>Numeric (optional). A specific value of <code>A</code> at which to evaluate the standard error of the heterogeneous treatment effect. If <code>NULL</code>, the function returns the standard error of the homogeneous treatment effect.</p>
</td></tr>
<tr><td><code id="se_+3A_a">A</code></td>
<td>
<p>Numeric vector (optional). The variable with respect to which treatment effect heterogeneity is considered. If <code>NULL</code>, the function assumes the <code>A</code> used in model fitting.</p>
</td></tr>
<tr><td><code id="se_+3A_kernel_name">kernel_name</code></td>
<td>
<p>Character (optional). The name of the kernel function to use for smoothing (if a heterogeneous treatment effect is estimated). Must be one of &quot;boxcar&quot;, &quot;gaussian&quot;, &quot;epanechnikov&quot;, or &quot;tricube&quot;.</p>
</td></tr>
<tr><td><code id="se_+3A_bandwidth">bandwidth</code></td>
<td>
<p>Numeric (optional). The bandwidth for the kernel smoothing (if a heterogeneous treatment effect is estimated).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric value representing the estimated standard error of the treatment effect estimate. If <code>a</code> is not specified, the function returns the standard error of the homogeneous treatment effect. If <code>a</code> is specified, it returns the standard error of the heterogeneous treatment effect estimate at <code class="reqn">A = a</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
Z &lt;- rnorm(100)
X &lt;- Z + rnorm(100)
H &lt;- rnorm(100)
D &lt;- Z^2 + sin(X) + H + rnorm(100)
A &lt;- X
Y &lt;- tanh(A) * D + cos(X) - H + rnorm(100)
fit &lt;- fit_IVDML(Y = Y, D = D, Z = Z, X = X, ml_method = "gam")
se(fit, iv_method = "mlIV")
se(fit, iv_method = "mlIV", a = 0, A = A, kernel_name = "boxcar", bandwidth = 0.2)

</code></pre>

<hr>
<h2 id='standard_confint'>Compute Standard Confidence Interval for the Treatment Effect Estimate in an IVDML Object</h2><span id='topic+standard_confint'></span>

<h3>Description</h3>

<p>This function calculates a standard confidence interval for the estimated (potentially heterogeneous) treatment effect from a fitted <code>IVDML</code> object (output of <code><a href="#topic+fit_IVDML">fit_IVDML()</a></code>). The confidence interval is computed using the normal approximation method using the standard error computed by <code><a href="#topic+se">se()</a></code> and the treatment effect estimate from <code><a href="stats.html#topic+coef">coef()</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>standard_confint(
  object,
  iv_method,
  a = NULL,
  A = NULL,
  kernel_name = NULL,
  bandwidth = NULL,
  level = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="standard_confint_+3A_object">object</code></td>
<td>
<p>An object of class <code>IVDML</code>, produced by the <code><a href="#topic+fit_IVDML">fit_IVDML()</a></code> function.</p>
</td></tr>
<tr><td><code id="standard_confint_+3A_iv_method">iv_method</code></td>
<td>
<p>Character. The instrumental variable estimation method to use. Must be one of the methods specified in the fitted object.</p>
</td></tr>
<tr><td><code id="standard_confint_+3A_a">a</code></td>
<td>
<p>Numeric (optional). A specific value of <code>A</code> at which to compute the confidence interval for the heterogeneous treatment effect. If <code>NULL</code>, the function returns the confidence interval for the homogeneous treatment effect.</p>
</td></tr>
<tr><td><code id="standard_confint_+3A_a">A</code></td>
<td>
<p>Numeric vector (optional). The variable with respect to which treatment effect heterogeneity is considered. If <code>NULL</code>, the function assumes the <code>A</code> used in object fitting.</p>
</td></tr>
<tr><td><code id="standard_confint_+3A_kernel_name">kernel_name</code></td>
<td>
<p>Character (optional). The name of the kernel function to use for smoothing (if a heterogeneous treatment effect is estimated). Must be one of &quot;boxcar&quot;, &quot;gaussian&quot;, &quot;epanechnikov&quot;, or &quot;tricube&quot;.</p>
</td></tr>
<tr><td><code id="standard_confint_+3A_bandwidth">bandwidth</code></td>
<td>
<p>Numeric (optional). The bandwidth for the kernel smoothing (if a heterogeneous treatment effect is estimated).</p>
</td></tr>
<tr><td><code id="standard_confint_+3A_level">level</code></td>
<td>
<p>Numeric (default: 0.95). The confidence level for the interval (e.g., 0.95 for a 95% confidence interval).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>description A list containing:
</p>

<ul>
<li> <p><code>CI</code>: A numeric vector of length 2 with the lower and upper confidence interval bounds.
</p>
</li>
<li> <p><code>level</code>: The confidence level used.
</p>
</li>
<li> <p><code>heterogeneous_parameters</code>: A list with values of <code>a</code>, <code>kernel_name</code>, and <code>bandwidth</code> (if applicable), or <code>NULL</code> if a homogeneous treatment effect is estimated.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
Z &lt;- rnorm(100)
X &lt;- Z + rnorm(100)
H &lt;- rnorm(100)
D &lt;- Z^2 + sin(X) + H + rnorm(100)
A &lt;- X
Y &lt;- tanh(A) * D + cos(X) - H + rnorm(100)
fit &lt;- fit_IVDML(Y = Y, D = D, Z = Z, X = X, ml_method = "gam")
standard_confint(fit, iv_method = "mlIV")
standard_confint(fit, iv_method = "mlIV", a = 0, A = A,
                 kernel_name = "boxcar", bandwidth = 0.2, level = 0.95)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
