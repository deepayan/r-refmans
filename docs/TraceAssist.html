<!DOCTYPE html><html><head><title>Help for package TraceAssist</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {TraceAssist}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#ADMM'><p>ADMM algorithm for weighted classification</p></a></li>
<li><a href='#CNN'><p>Convolutional Neural Network (CNN) with two hidden layers</p></a></li>
<li><a href='#Lasso'><p>Logistic probability model via penalized maximum likelihood</p></a></li>
<li><a href='#TraceAssist'><p>Aggregation of structured sign series for trace regression (ASSIST)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Nonparametric Trace Regression via Sign Series Representation</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Chanwoo Lee &lt;chanwoo.lee@wisc.edu&gt;, Lexin Li &lt;lexinli@berkeley.edu&gt;, Hao Helen Zhang &lt;hzhang@math.arizona.edu&gt;, Miaoyan Wang &lt;miaoyan.wang@wisc.edu&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Chanwoo Lee &lt;chanwoo.lee@wisc.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Efficient method for fitting nonparametric matrix trace regression model. The detailed description can be found in  C. Lee, L. Li, H. Zhang, and M. Wang (2021). Nonparametric Trace Regression via Sign Series Representation. &lt;<a href="https://doi.org/10.48550/arXiv.2105.01783">doi:10.48550/arXiv.2105.01783</a>&gt;. The method employs the aggregation of structured sign series for trace regression (ASSIST) algorithm.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://arxiv.org/abs/2105.01783">https://arxiv.org/abs/2105.01783</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>quadprog, Matrix, glmnet, keras</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-05-08 22:10:47 UTC; chanwoolee</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-05-10 08:42:14 UTC</td>
</tr>
</table>
<hr>
<h2 id='ADMM'>ADMM algorithm for weighted classification</h2><span id='topic+ADMM'></span>

<h3>Description</h3>

<p>Implement an ADMM algorithm to optimize the weigthed classificiation loss.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ADMM(X,ybar,Weight,Covariate=NULL,r,srow,scol,lambda=0,rho.ini=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ADMM_+3A_x">X</code></td>
<td>
<p>A list of matrix-valued predictors.</p>
</td></tr>
<tr><td><code id="ADMM_+3A_ybar">ybar</code></td>
<td>
<p>A vector of  shifted response variables.</p>
</td></tr>
<tr><td><code id="ADMM_+3A_weight">Weight</code></td>
<td>
<p>Classification weight.</p>
</td></tr>
<tr><td><code id="ADMM_+3A_covariate">Covariate</code></td>
<td>
<p>Additional covariates including intercept. <code>Covariate = NULL</code> indicates no covariates.</p>
</td></tr>
<tr><td><code id="ADMM_+3A_r">r</code></td>
<td>
<p>The rank of coefficient matrix to be fitted.</p>
</td></tr>
<tr><td><code id="ADMM_+3A_srow">srow</code></td>
<td>
<p>The number of zero rows in coefficient matrix.</p>
</td></tr>
<tr><td><code id="ADMM_+3A_scol">scol</code></td>
<td>
<p>The number of zero columns in coefficient matrix.</p>
</td></tr>
<tr><td><code id="ADMM_+3A_lambda">lambda</code></td>
<td>
<p>Lagrangian multiplier. Default is zero.</p>
</td></tr>
<tr><td><code id="ADMM_+3A_rho.ini">rho.ini</code></td>
<td>
<p>Initial step size. Default is 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The returned object is a list of components.
</p>
<p><code>intercept</code> - The estimated intercept of the classifier.
</p>
<p><code>P_row</code> - The left-singular vectors of the coefficient matrix.
</p>
<p><code>P_col</code> - The right-singular vectors of the coefficient matrix.
</p>
<p><code>obj</code> - Trajectory of weighted classification loss values over iterations.
</p>
<p><code>iter</code> - The number of iterations.
</p>
<p><code>fitted</code> - A vector of fitted reponse from estimated classifier.
</p>
<p><code>B</code> - The estimated coefficient matrix of the classifier.
</p>


<h3>References</h3>

<p>Lee, C., Li, L., Zhang, H., and Wang, M. (2021). Nonparametric Trace Regression via Sign Series Representation. <em>arXiv preprint arXiv:2105.01783</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#### Generate matrix predictors  ##########
X = list()
for(i in 1:10){
 X[[i]] = matrix(runif(4,-1,1),nrow = 2,ncol = 2)
}

#### Generate coefficient matrix #########
B = runif(2,-1,1)%*%t(runif(2,-1,1))

#### Generate response variables #########
y = NULL
for(i in 1:10){
 y = c(y,sign(sum(X[[i]]*B)+rnorm(1,sd = 0.1)))
}

#### classification with equal weights #########
res = ADMM(X,y,rep(1,10),r = 1,srow = 0,scol = 0)

### Misclassification rate on training data ######
mean(sign(res$fitted)-y)
</code></pre>

<hr>
<h2 id='CNN'>Convolutional Neural Network (CNN) with two hidden layers</h2><span id='topic+CNN'></span>

<h3>Description</h3>

<p>Implement a CNN with two hidden layers and ReLU activation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CNN(X,y,X_new,plot.figure = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CNN_+3A_x">X</code></td>
<td>
<p>A list of matrix-valued predictors.</p>
</td></tr>
<tr><td><code id="CNN_+3A_y">y</code></td>
<td>
<p>Binary response variable.</p>
</td></tr>
<tr><td><code id="CNN_+3A_x_new">X_new</code></td>
<td>
<p>A list of new matrices in the test data.</p>
</td></tr>
<tr><td><code id="CNN_+3A_plot.figure">plot.figure</code></td>
<td>
<p>Option for plotting trajectory of accuracy over epochs.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The returned object is a list of components.
</p>
<p><code>prob</code> - The predicted probabilities for the test data.
</p>
<p><code>class</code> - The estimated binary response for the test data.
</p>
<p><code>history</code> - The trajectory of classification accuracy over epochs.
</p>
<p><code>acc</code> - The classification accuracy on test data.
</p>

<hr>
<h2 id='Lasso'>Logistic probability model via penalized maximum likelihood</h2><span id='topic+Lasso'></span>

<h3>Description</h3>

<p>Fit a logistic probability model based on Lasso penalty
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lasso(xvec,y,xnew,lambda)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lasso_+3A_xvec">xvec</code></td>
<td>
<p>An input matrix. Each row is a vectorized predictor.</p>
</td></tr>
<tr><td><code id="Lasso_+3A_y">y</code></td>
<td>
<p>Binary response variable.</p>
</td></tr>
<tr><td><code id="Lasso_+3A_xnew">xnew</code></td>
<td>
<p>New predictors in the test data. Organized as a matrix with each row being a data point.</p>
</td></tr>
<tr><td><code id="Lasso_+3A_lambda">lambda</code></td>
<td>
<p>The regularization penalty.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The returned object is a list of components.
</p>
<p><code>B_est</code> - The estimated coefficient vector of linear predictor.
</p>
<p><code>prob</code> - The predicted probabilities for the test data.
</p>

<hr>
<h2 id='TraceAssist'>Aggregation of structured sign series for trace regression (ASSIST)</h2><span id='topic+TraceAssist'></span>

<h3>Description</h3>

<p>Main function for fitting the nonparametric trace regression. The algorithm uses a learning reduction approach to estimate the nonparametric trace regression via ASSIST.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TraceAssist(X,y,X_new=NULL,r,sparse_r,sparse_c,H=10,lambda=0,rho.ini=0.1,min,max)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TraceAssist_+3A_x">X</code></td>
<td>
<p>A list of matrix-valued predictors.</p>
</td></tr>
<tr><td><code id="TraceAssist_+3A_y">y</code></td>
<td>
<p>A vector of response variables.</p>
</td></tr>
<tr><td><code id="TraceAssist_+3A_x_new">X_new</code></td>
<td>
<p>A list of new matrices in the test data. <code>X_new = NULL</code> returns fitted values in the training data.</p>
</td></tr>
<tr><td><code id="TraceAssist_+3A_r">r</code></td>
<td>
<p>The rank of sign representable function to be fitted.</p>
</td></tr>
<tr><td><code id="TraceAssist_+3A_sparse_r">sparse_r</code></td>
<td>
<p>The number of zero rows in coefficient matrix.</p>
</td></tr>
<tr><td><code id="TraceAssist_+3A_sparse_c">sparse_c</code></td>
<td>
<p>The number of zero columns in coefficient matrix.</p>
</td></tr>
<tr><td><code id="TraceAssist_+3A_h">H</code></td>
<td>
<p>Resoution parameter that controls the number of classifiers to aggregate.</p>
</td></tr>
<tr><td><code id="TraceAssist_+3A_lambda">lambda</code></td>
<td>
<p>Lagrangian multiplier.</p>
</td></tr>
<tr><td><code id="TraceAssist_+3A_rho.ini">rho.ini</code></td>
<td>
<p>Initial step size.</p>
</td></tr>
<tr><td><code id="TraceAssist_+3A_min">min</code></td>
<td>
<p>Minimum value of the response variables</p>
</td></tr>
<tr><td><code id="TraceAssist_+3A_max">max</code></td>
<td>
<p>Maximum value of the response variables.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The returned object is a list of components.
</p>
<p><code>B_est</code> - An array that collects a series of coefficient matrices for the classifiers used in the algorithm.
</p>
<p><code>fitted</code> - The predicted responses in the test data.
</p>
<p><code>sign_fitted</code> - A matrix that collects a series of predicted signs for the classifiers used in the algorithm.
</p>


<h3>References</h3>

<p>Lee, C., Li, L., Zhang, H., and Wang, M. (2021). Nonparametric Trace Regression via Sign Series Representation. <em>arXiv preprint arXiv:2105.01783</em>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>######### Generate matrices in the training data ################
X = list()
for(i in 1:10){
 X[[i]] = matrix(runif(4,-1,1),nrow = 2,ncol = 2)
}

######### Generate coefficient matrix ###########################
B = runif(2,-1,1)%*%t(runif(2,-1,1))

######### Generate response variables ###########################
y = NULL;signal = NULL
for(i in 1:10){
 signal = c(signal,sum(X[[i]]*B))
 y = c(y,sum(X[[i]]*B)+rnorm(1,sd = 0.1))
}


######### Run ASSIST ############################################
res =TraceAssist(X,y,r = 1,sparse_r = 0,sparse_c = 0,min = min(y),max = max(y))
mean(abs(res$fitted-signal))


######### Generate new matrices in the test data ################
X_new = list()
for(i in 1:10){
  X_new[[i]] = matrix(runif(4,-1,1),nrow = 2,ncol = 2)
}

######### Generate response variables from X_new ################
y_new = NULL
for(i in 1:10){
  y_new = c(y_new,sum(X_new[[i]]*B))
}

######### Run ASSIST #############################################
res =TraceAssist(X,y,X_new,r = 1,sparse_r = 0,sparse_c = 0,min = min(y),max = max(y))
mean(abs(res$fitted-y_new))

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
