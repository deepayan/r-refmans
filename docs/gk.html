<!DOCTYPE html><html lang="en"><head><title>Help for package gk</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {gk}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#abc'><p>Approximate Bayesian computation inference</p></a></li>
<li><a href='#abc_batch'><p>Single batch of ABC</p></a></li>
<li><a href='#dgh'><p>g-and-h distribution functions</p></a></li>
<li><a href='#dgk'><p>g-and-k distribution functions</p></a></li>
<li><a href='#fdsa'><p>Finite difference stochastic approximation inference</p></a></li>
<li><a href='#fx'><p>Exchange rate example</p></a></li>
<li><a href='#improper_uniform_log_density'><p>Improper uniform log density</p></a></li>
<li><a href='#isValid'><p>Check validity of g-and-k or g-and-h parameters</p></a></li>
<li><a href='#isValid_scalar'><p>Check validity of g-and-k or g-and-h parameters</p></a></li>
<li><a href='#logSumExp'><p>Calculate log sum exp safely</p></a></li>
<li><a href='#mcmc'><p>Markov chain Monte Carlo inference</p></a></li>
<li><a href='#momentEstimates'><p>Convert octiles to moment estimates</p></a></li>
<li><a href='#orderstats'><p>Order statistics</p></a></li>
<li><a href='#pgh_scalar'><p>Distribution function for the g-and-h distribution</p></a></li>
<li><a href='#pgk_scalar'><p>Distribution function for the g-and-k distribution</p></a></li>
<li><a href='#project'><p>Project into a region</p></a></li>
<li><a href='#Qgh_deriv'><p>g-and-h Q derivative</p></a></li>
<li><a href='#Qgh_log_deriv'><p>g-and-h Q log derivative</p></a></li>
<li><a href='#Qgk_deriv'><p>g-and-k Q derivative</p></a></li>
<li><a href='#Qgk_log_deriv'><p>g-and-k Q log derivative</p></a></li>
<li><a href='#z2gh'><p>Transform standard normal draws to g-and-h draws.</p></a></li>
<li><a href='#z2gk'><p>Transform standard normal draws to g-and-k draws.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>g-and-k and g-and-h Distribution Functions</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-07-20</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for the g-and-k and generalised g-and-h distributions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Ecdat, lubridate, progress, grDevices, graphics, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/dennisprangle/gk">https://github.com/dennisprangle/gk</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/dennisprangle/gk/issues">https://github.com/dennisprangle/gk/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-07-20 12:59:26 UTC; dennis</td>
</tr>
<tr>
<td>Author:</td>
<td>Dennis Prangle [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Dennis Prangle &lt;dennis.prangle@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-10 15:40:15 UTC</td>
</tr>
</table>
<hr>
<h2 id='abc'>Approximate Bayesian computation inference</h2><span id='topic+abc'></span>

<h3>Description</h3>

<p>Approximate Bayesian computation (ABC) inference for the g-and-k or g-and-h distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abc(
  x,
  N,
  model = c("gk", "generalised_gh", "tukey_gh", "gh"),
  logB = FALSE,
  rprior,
  M,
  sumstats = c("all order statistics", "octiles", "moment estimates"),
  silent = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="abc_+3A_x">x</code></td>
<td>
<p>Vector of observations.</p>
</td></tr>
<tr><td><code id="abc_+3A_n">N</code></td>
<td>
<p>Number of iterations to perform.</p>
</td></tr>
<tr><td><code id="abc_+3A_model">model</code></td>
<td>
<p>Which model to check: &quot;gk&quot;, &quot;generalised_gh&quot; or &quot;tukey_gh&quot;.
For backwards compatibility, &quot;gh&quot; acts the same as &quot;generalised_gh&quot;.</p>
</td></tr>
<tr><td><code id="abc_+3A_logb">logB</code></td>
<td>
<p>When true, the second parameter is log(B) rather than B.</p>
</td></tr>
<tr><td><code id="abc_+3A_rprior">rprior</code></td>
<td>
<p>A function with single argument, n, which returns a matrix with n rows consisting of samples from the prior distribution for 4 parameters e.g. (A,B,g,k).</p>
</td></tr>
<tr><td><code id="abc_+3A_m">M</code></td>
<td>
<p>Number of simulations to accept.</p>
</td></tr>
<tr><td><code id="abc_+3A_sumstats">sumstats</code></td>
<td>
<p>Which summary statistics to use.</p>
</td></tr>
<tr><td><code id="abc_+3A_silent">silent</code></td>
<td>
<p>When <code>FALSE</code> (the default) a progress bar is shown.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function performs approximate Bayesian inference for iid data from a g-and-k or g-and-h distribution, avoiding expensive density calculations.
The algorithm samples many parameter vectors from the prior and simulates corresponding data from the model.
The parameters are accepted or rejected based on how similar the simulations are to the observed data.
Similarity is measured using weighted Euclidean distance between summary vectors of the simulations and observations.
Several summaries can be used, including the complete order statistics or summaries based on octiles.
In the latter case only the corresponding order statistics are simulated, speeding up the method.
</p>


<h3>Value</h3>

<p>Matrix whose rows are accepted parameter estimates plus a column giving the ABC distances.
</p>


<h3>References</h3>

<p>D. Prangle. gk: An R package for the g-and-k and generalised g-and-h distributions, 2017.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
x = rgk(10, A=3, B=1, g=2, k=0.5) ##An unusually small dataset for fast execution of this example
rprior = function(n) { matrix(runif(4*n,0,10), ncol=4) }
abc(x, N=1E4, rprior=rprior, M=100)
</code></pre>

<hr>
<h2 id='abc_batch'>Single batch of ABC</h2><span id='topic+abc_batch'></span>

<h3>Description</h3>

<p>Interal function carrying out part of ABC inference calculations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abc_batch(sobs, priorSims, simStats, M, v = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="abc_batch_+3A_sobs">sobs</code></td>
<td>
<p>Vector of observed summary statistics.</p>
</td></tr>
<tr><td><code id="abc_batch_+3A_priorsims">priorSims</code></td>
<td>
<p>Matrix whose rows are vector of parameters drawn from the prior.</p>
</td></tr>
<tr><td><code id="abc_batch_+3A_simstats">simStats</code></td>
<td>
<p>Function mapping a vector of parameters to summary statistics.</p>
</td></tr>
<tr><td><code id="abc_batch_+3A_m">M</code></td>
<td>
<p>How many simulations to accept in this batch.</p>
</td></tr>
<tr><td><code id="abc_batch_+3A_v">v</code></td>
<td>
<p>Optional vector of estimated variances for each summary statistic</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Outputs a list containing:
1) matrix whose rows are accepted parameter vectors, and a column of resulting distances
2) value of v.
If v is not supplied then variances are estimated here and returned.
(The idea is that this is done for the first batch, and these values are reused from then on.)
</p>

<hr>
<h2 id='dgh'>g-and-h distribution functions</h2><span id='topic+dgh'></span><span id='topic+pgh'></span><span id='topic+g-and-h'></span><span id='topic+qgh'></span><span id='topic+rgh'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation for the generalised g-and-h distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgh(x, A, B, g, h, c = 0.8, log = FALSE, type = c("generalised", "tukey"))

pgh(q, A, B, g, h, c = 0.8, zscale = FALSE, type = c("generalised", "tukey"))

qgh(p, A, B, g, h, c = 0.8, type = c("generalised", "tukey"))

rgh(n, A, B, g, h, c = 0.8, type = c("generalised", "tukey"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dgh_+3A_x">x</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="dgh_+3A_a">A</code></td>
<td>
<p>Vector of A (location) parameters.</p>
</td></tr>
<tr><td><code id="dgh_+3A_b">B</code></td>
<td>
<p>Vector of B (scale) parameters. Must be positive.</p>
</td></tr>
<tr><td><code id="dgh_+3A_g">g</code></td>
<td>
<p>Vector of g parameters.</p>
</td></tr>
<tr><td><code id="dgh_+3A_h">h</code></td>
<td>
<p>Vector of h parameters. Must be non-negative.</p>
</td></tr>
<tr><td><code id="dgh_+3A_c">c</code></td>
<td>
<p>Vector of c parameters (used for generalised g-and-h). Often fixed at 0.8 which is the default.</p>
</td></tr>
<tr><td><code id="dgh_+3A_log">log</code></td>
<td>
<p>If true the log density is returned.</p>
</td></tr>
<tr><td><code id="dgh_+3A_type">type</code></td>
<td>
<p>Can be &quot;generalised&quot; (default) or &quot;tukey&quot;.</p>
</td></tr>
<tr><td><code id="dgh_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="dgh_+3A_zscale">zscale</code></td>
<td>
<p>If true the N(0,1) quantile of the cdf is returned.</p>
</td></tr>
<tr><td><code id="dgh_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="dgh_+3A_n">n</code></td>
<td>
<p>Number of draws to make.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Tukey and generalised g-and-h distributions are defined by their quantile functions.
For Tukey's g-and-h distribution, this is
</p>
<p style="text-align: center;"><code class="reqn">x(p) = A + B [(\exp(gz)-1) / g] \exp(hz^2/2).</code>
</p>

<p>The generalised g-and-h instead uses
</p>
<p style="text-align: center;"><code class="reqn">x(p) = A + B [1 + c \tanh(gz/2)] z \exp(hz^2/2).</code>
</p>

<p>In both cases z is the standard normal quantile of p.
Note that neither family of distributions is a special case of the other.
Parameter restrictions include <code class="reqn">B&gt;0</code> and <code class="reqn">h \geq 0</code>.
The generalised g-and-h distribution typically takes <code class="reqn">c=0.8</code>.
For more background information see the references.
</p>
<p><code>rgh</code> and <code>qgh</code> use quick direct calculations. However <code>dgh</code> and <code>pgh</code> involve slower numerical inversion of the quantile function.
</p>
<p>Especially extreme values of the inputs will produce <code>pgh</code> output rounded to 0 or 1 (-Inf or Inf for <code>zscale=TRUE</code>).
The corresponding <code>dgh</code> output will be 0 or -Inf for <code>log=TRUE</code>.
</p>


<h3>Value</h3>

<p><code>dgh</code> gives the density, <code>pgh</code> gives the distribution, <code>qgh</code> gives the quantile function, and <code>rgh</code> generates random deviates
</p>


<h3>References</h3>

<p>Haynes &lsquo;Flexible distributions and statistical models in ranking and selection procedures, with applications&rsquo; PhD Thesis QUT (1998)
Rayner and MacGillivray &lsquo;Numerical maximum likelihood estimation for the g-and-k and generalized g-and-h distributions&rsquo; Statistics and Computing, 12, 57-75 (2002)
Tukey &lsquo;Modern techniques in data analysis&rsquo; (1977)
Yan and Genton &lsquo;The Tukey g-and-h distribution&rsquo; Significance, 16, 12-13 (2019)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p = 1:9/10 ##Some probabilities
x = qgh(seq(0.1,0.9,0.1), A=3, B=1, g=2, h=0.5) ##g-and-h quantiles
rgh(5, A=3, B=1, g=2, h=0.5) ##g-and-h draws
dgh(x, A=3, B=1, g=2, h=0.5) ##Densities of x under g-and-h
dgh(x, A=3, B=1, g=2, h=0.5, log=TRUE) ##Log densities of x under g-and-h
pgh(x, A=3, B=1, g=2, h=0.5) ##Distribution function of x under g-and-h
</code></pre>

<hr>
<h2 id='dgk'>g-and-k distribution functions</h2><span id='topic+dgk'></span><span id='topic+pgk'></span><span id='topic+g-and-k'></span><span id='topic+qgk'></span><span id='topic+rgk'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation for the g-and-k distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgk(x, A, B, g, k, c = 0.8, log = FALSE)

pgk(q, A, B, g, k, c = 0.8, zscale = FALSE)

qgk(p, A, B, g, k, c = 0.8)

rgk(n, A, B, g, k, c = 0.8)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dgk_+3A_x">x</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="dgk_+3A_a">A</code></td>
<td>
<p>Vector of A (location) parameters.</p>
</td></tr>
<tr><td><code id="dgk_+3A_b">B</code></td>
<td>
<p>Vector of B (scale) parameters. Must be positive.</p>
</td></tr>
<tr><td><code id="dgk_+3A_g">g</code></td>
<td>
<p>Vector of g parameters.</p>
</td></tr>
<tr><td><code id="dgk_+3A_k">k</code></td>
<td>
<p>Vector of k parameters. Must be at least -0.5.</p>
</td></tr>
<tr><td><code id="dgk_+3A_c">c</code></td>
<td>
<p>Vector of c parameters. Often fixed at 0.8 which is the default.</p>
</td></tr>
<tr><td><code id="dgk_+3A_log">log</code></td>
<td>
<p>If true the log density is returned.</p>
</td></tr>
<tr><td><code id="dgk_+3A_q">q</code></td>
<td>
<p>Vector of quantiles.</p>
</td></tr>
<tr><td><code id="dgk_+3A_zscale">zscale</code></td>
<td>
<p>If true the N(0,1) quantile of the cdf is returned.</p>
</td></tr>
<tr><td><code id="dgk_+3A_p">p</code></td>
<td>
<p>Vector of probabilities.</p>
</td></tr>
<tr><td><code id="dgk_+3A_n">n</code></td>
<td>
<p>Number of draws to make.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The g-and-k distribution is defined by its quantile function:
</p>
<p style="text-align: center;"><code class="reqn">x(p) = A + B [1 + c \tanh(gz/2)] z(1 + z^2)^k,</code>
</p>

<p>where z is the standard normal quantile of p.
Parameter restrictions include <code class="reqn">B&gt;0</code> and <code class="reqn">k \geq -0.5</code>. Typically c=0.8. For more
background information see the references.
</p>
<p><code>rgk</code> and <code>qgk</code> use quick direct calculations. However <code>dgk</code> and <code>pgk</code> involve slower numerical inversion of the quantile function.
</p>
<p>Especially extreme values of the inputs will produce <code>pgk</code> output rounded to 0 or 1 (-Inf or Inf for <code>zscale=TRUE</code>).
The corresponding <code>dgk</code> output will be 0 or -Inf for <code>log=TRUE</code>.
</p>


<h3>Value</h3>

<p><code>dgk</code> gives the density, <code>pgk</code> gives the distribution, <code>qgk</code> gives the quantile function, and <code>rgk</code> generates random deviates
</p>


<h3>References</h3>

<p>Haynes &lsquo;Flexible distributions and statistical models in ranking and selection procedures, with applications&rsquo; PhD Thesis QUT (1998)
Rayner and MacGillivray &lsquo;Numerical maximum likelihood estimation for the g-and-k and generalized g-and-h distributions&rsquo; Statistics and Computing, 12, 57-75 (2002)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>p = 1:9/10 ##Some probabilities
x = qgk(seq(0.1,0.9,0.1), A=3, B=1, g=2, k=0.5) ##g-and-k quantiles
rgk(5, A=3, B=1, g=2, k=0.5) ##g-and-k draws
dgk(x, A=3, B=1, g=2, k=0.5) ##Densities of x under g-and-k
dgk(x, A=3, B=1, g=2, k=0.5, log=TRUE) ##Log densities of x under g-and-k
pgk(x, A=3, B=1, g=2, k=0.5) ##Distribution function of x under g-and-k
</code></pre>

<hr>
<h2 id='fdsa'>Finite difference stochastic approximation inference</h2><span id='topic+fdsa'></span>

<h3>Description</h3>

<p>Finite difference stochastic approximation (FDSA) inference for the g-and-k or g-and-h distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fdsa(
  x,
  N,
  model = c("gk", "generalised_gh", "tukey_gh", "gh"),
  logB = FALSE,
  theta0,
  batch_size = 100,
  alpha = 1,
  gamma = 0.49,
  a0 = 1,
  c0 = NULL,
  A = 100,
  theta_min = c(-Inf, ifelse(logB, -Inf, 1e-05), -Inf, 1e-05),
  theta_max = c(Inf, Inf, Inf, Inf),
  silent = FALSE,
  plotEvery = 100
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fdsa_+3A_x">x</code></td>
<td>
<p>Vector of observations.</p>
</td></tr>
<tr><td><code id="fdsa_+3A_n">N</code></td>
<td>
<p>number of iterations to perform.</p>
</td></tr>
<tr><td><code id="fdsa_+3A_model">model</code></td>
<td>
<p>Which model to check: &quot;gk&quot;, &quot;generalised_gh&quot; or &quot;tukey_gh&quot;.
For backwards compatibility, &quot;gh&quot; acts the same as &quot;generalised_gh&quot;.</p>
</td></tr>
<tr><td><code id="fdsa_+3A_logb">logB</code></td>
<td>
<p>When true, the second parameter is log(B) rather than B.</p>
</td></tr>
<tr><td><code id="fdsa_+3A_theta0">theta0</code></td>
<td>
<p>Vector of initial value for 4 parameters.</p>
</td></tr>
<tr><td><code id="fdsa_+3A_batch_size">batch_size</code></td>
<td>
<p>Mini-batch size.</p>
</td></tr>
<tr><td><code id="fdsa_+3A_alpha">alpha</code></td>
<td>
<p>Gain decay for step size.</p>
</td></tr>
<tr><td><code id="fdsa_+3A_gamma">gamma</code></td>
<td>
<p>Gain decay for finite difference.</p>
</td></tr>
<tr><td><code id="fdsa_+3A_a0">a0</code></td>
<td>
<p>Multiplicative step size tuning parameter (or vector of 4 values).</p>
</td></tr>
<tr><td><code id="fdsa_+3A_c0">c0</code></td>
<td>
<p>Multiplicative finite difference step tuning parameter (or vector of 4 values).</p>
</td></tr>
<tr><td><code id="fdsa_+3A_a">A</code></td>
<td>
<p>Additive step size tuning parameter.</p>
</td></tr>
<tr><td><code id="fdsa_+3A_theta_min">theta_min</code></td>
<td>
<p>Vector of minimum values for each parameter.
Note: for <code>model=="tukey_gh"</code> it's usually advisable to rule out h=0 as this case sometimes causes optimisation problems.</p>
</td></tr>
<tr><td><code id="fdsa_+3A_theta_max">theta_max</code></td>
<td>
<p>Vector of maximum values for each parameter.</p>
</td></tr>
<tr><td><code id="fdsa_+3A_silent">silent</code></td>
<td>
<p>When <code>FALSE</code> (the default) a progress bar and intermediate results plots are shown.</p>
</td></tr>
<tr><td><code id="fdsa_+3A_plotevery">plotEvery</code></td>
<td>
<p>How often to plot the results if <code>silent==FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fdsa</code> performs maximum likelihood inference for iid data from a g-and-k or g-and-h distribution, using simulataneous perturbation stochastic approximation. This should be faster than directly maximising the likelihood.
</p>


<h3>Value</h3>

<p>Matrix whose rows are FDSA states: the initial state <code>theta0</code> and N subsequent states.
The final row is the MLE estimate.
</p>


<h3>References</h3>

<p>D. Prangle gk: An R package for the g-and-k and generalised g-and-h distributions, 2017.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
x = rgk(10, A=3, B=1, g=2, k=0.5) ##An unusually small dataset for fast execution of this example
out = fdsa(x, N=100, theta0=c(mean(x),sd(x),0,1E-5), theta_min=c(-5,1E-5,-5,1E-5),
    theta_max=c(5,5,5,5))
</code></pre>

<hr>
<h2 id='fx'>Exchange rate example</h2><span id='topic+fx'></span>

<h3>Description</h3>

<p>Performs a demo analysis of exchange rate data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fx(type = c("standard", "quick", "for paper"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fx_+3A_type">type</code></td>
<td>
<p>What type of demo to perform. <code>standard</code> runs the full demo displaying plots. <code>quick</code> is a fast demo suitable for testing the package. <code>for paper</code> saves pdfs which can be used in the paper.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>fx</code> performs the analysis of exchange rate data in the supporting reference (Prangle 2017).
</p>


<h3>References</h3>

<p>D. Prangle gk: An R package for the g-and-k and generalised g-and-h distributions, 2017.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
fx()

## End(Not run)
</code></pre>

<hr>
<h2 id='improper_uniform_log_density'>Improper uniform log density</h2><span id='topic+improper_uniform_log_density'></span>

<h3>Description</h3>

<p>Returns log density of an improper prior for the g-and-k or g-and-h distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>improper_uniform_log_density(theta)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="improper_uniform_log_density_+3A_theta">theta</code></td>
<td>
<p>A vector of 4 parameters representing (A,B,g,k) or (A,B,g,h)</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>improper_uniform_log_density</code> takes a 4 parameter vector as input and returns a log density value.
The output corresponds to an improper uniform with constraints that the second and fourth parameters should be non-negative.
These ensure that the resulting parameters are valid to use in the g-and-k or g-and-h distribution is valid.
This function is supplied as a convenient default prior to use in the <code>mcmc</code> function.
</p>


<h3>Value</h3>

<p>Value of an (unnormalised) log density
</p>


<h3>Examples</h3>

<pre><code class='language-R'>improper_uniform_log_density(c(0,1,0,0)) ##Valid parameters - returns 0
improper_uniform_log_density(c(0,-1,0,0)) ##Invalid parameters - returns -Inf
</code></pre>

<hr>
<h2 id='isValid'>Check validity of g-and-k or g-and-h parameters</h2><span id='topic+isValid'></span>

<h3>Description</h3>

<p>Check whether parameter choices produce a valid g-and-k or g-and-h distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isValid(
  g,
  k_or_h,
  c = 0.8,
  model = c("gk", "generalised_gh", "tukey_gh", "gh"),
  initial_z = seq(-1, 1, 0.2)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isValid_+3A_g">g</code></td>
<td>
<p>Vector of g parameters.</p>
</td></tr>
<tr><td><code id="isValid_+3A_k_or_h">k_or_h</code></td>
<td>
<p>Vector of k or h parameters.</p>
</td></tr>
<tr><td><code id="isValid_+3A_c">c</code></td>
<td>
<p>Vector of c parameters.</p>
</td></tr>
<tr><td><code id="isValid_+3A_model">model</code></td>
<td>
<p>Which model to check: &quot;gk&quot;, &quot;generalised_gh&quot; or &quot;tukey_gh&quot;.
For backwards compatibility, &quot;gh&quot; acts the same as &quot;generalised_gh&quot;.</p>
</td></tr>
<tr><td><code id="isValid_+3A_initial_z">initial_z</code></td>
<td>
<p>Vector of initial z values to use in each optimisation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function tests whether parameter choices provide a valid distribution.
Only g k and c parameters need be supplied as A and B&gt;0 have no effect.
The function operates by numerically minimising the derivative of the quantile function,
and returning <code>TRUE</code> if the minimum is positive.
It is possible that a local minimum is found, so it is recommended to use multiple optimisation starting points, and to beware that false positive may still result!
</p>


<h3>Value</h3>

<p>Logical vector denoting whether each parameter combination is valid.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>isValid(0:10, -0.5)
isValid(0:10, 0.5, c=0.9, model="generalised_gh")
isValid(0:10, 0.5, model="tukey_gh")
</code></pre>

<hr>
<h2 id='isValid_scalar'>Check validity of g-and-k or g-and-h parameters</h2><span id='topic+isValid_scalar'></span>

<h3>Description</h3>

<p>Check whether parameter choices produce a valid g-and-k or g-and-h distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isValid_scalar(
  g,
  k_or_h,
  c = 0.8,
  model = c("gk", "generalised_gh", "tukey_gh", "gh"),
  initial_z = seq(-1, 1, 0.2)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isValid_scalar_+3A_g">g</code></td>
<td>
<p>A g parameter.</p>
</td></tr>
<tr><td><code id="isValid_scalar_+3A_k_or_h">k_or_h</code></td>
<td>
<p>A k or h parameter.</p>
</td></tr>
<tr><td><code id="isValid_scalar_+3A_c">c</code></td>
<td>
<p>A c parameter.</p>
</td></tr>
<tr><td><code id="isValid_scalar_+3A_model">model</code></td>
<td>
<p>Which model to check: &quot;gk&quot;, &quot;generalised_gh&quot; or &quot;tukey_gh&quot;.
For backwards compatibility, &quot;gh&quot; acts the same as &quot;generalised_gh&quot;.</p>
</td></tr>
<tr><td><code id="isValid_scalar_+3A_initial_z">initial_z</code></td>
<td>
<p>Vector of initial z values to use in optimisation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This internal function performs the calculation using scalar parameter inputs.
The exported function is a vectorised wrapper of this.
</p>


<h3>Value</h3>

<p>Logical vector denoting whether each parameter combination is valid
</p>

<hr>
<h2 id='logSumExp'>Calculate log sum exp safely</h2><span id='topic+logSumExp'></span>

<h3>Description</h3>

<p>Calculate log(exp(a)+exp(b)) avoiding numerical issues
</p>


<h3>Usage</h3>

<pre><code class='language-R'>logSumExp(a, b)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logSumExp_+3A_a">a</code></td>
<td>
<p>Number</p>
</td></tr>
<tr><td><code id="logSumExp_+3A_b">b</code></td>
<td>
<p>Number</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Value of log(exp(a)+exp(b))
</p>

<hr>
<h2 id='mcmc'>Markov chain Monte Carlo inference</h2><span id='topic+mcmc'></span>

<h3>Description</h3>

<p>Markov chain Monte Carlo (MCMC) inference for the g-and-k or g-and-h distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc(
  x,
  N,
  model = c("gk", "generalised_gh", "tukey_gh", "gh"),
  logB = FALSE,
  get_log_prior = improper_uniform_log_density,
  theta0,
  Sigma0,
  t0 = 100,
  epsilon = 1e-06,
  silent = FALSE,
  plotEvery = 100
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcmc_+3A_x">x</code></td>
<td>
<p>Vector of observations.</p>
</td></tr>
<tr><td><code id="mcmc_+3A_n">N</code></td>
<td>
<p>Number of MCMC steps to perform.</p>
</td></tr>
<tr><td><code id="mcmc_+3A_model">model</code></td>
<td>
<p>Which model to check: &quot;gk&quot;, &quot;generalised_gh&quot; or &quot;tukey_gh&quot;.
For backwards compatibility, &quot;gh&quot; acts the same as &quot;generalised_gh&quot;.</p>
</td></tr>
<tr><td><code id="mcmc_+3A_logb">logB</code></td>
<td>
<p>When true, the second parameter is log(B) rather than B.</p>
</td></tr>
<tr><td><code id="mcmc_+3A_get_log_prior">get_log_prior</code></td>
<td>
<p>A function with one argument (corresponding to a vector of 4 parameters e.g. A,B,g,k) returning the log prior density. This should ensure the parameters are valid - i.e. return -Inf for invalid parameters - as the <code>mcmc</code> code will not check this.</p>
</td></tr>
<tr><td><code id="mcmc_+3A_theta0">theta0</code></td>
<td>
<p>Vector of initial value for 4 parameters.</p>
</td></tr>
<tr><td><code id="mcmc_+3A_sigma0">Sigma0</code></td>
<td>
<p>MCMC proposal covariance matrix</p>
</td></tr>
<tr><td><code id="mcmc_+3A_t0">t0</code></td>
<td>
<p>Tuning parameter (number of initial iterations without adaptation).</p>
</td></tr>
<tr><td><code id="mcmc_+3A_epsilon">epsilon</code></td>
<td>
<p>Tuning parameter (weight given to identity matrix in covariance calculation).</p>
</td></tr>
<tr><td><code id="mcmc_+3A_silent">silent</code></td>
<td>
<p>When <code>FALSE</code> (the default) a progress bar and intermediate results plots are shown.</p>
</td></tr>
<tr><td><code id="mcmc_+3A_plotevery">plotEvery</code></td>
<td>
<p>How often to plot the results if <code>silent==FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mcmc</code> performs Markov chain Monte Carlo inference for iid data from a g-and-k or g-and-h distribution, using the adaptive Metropolis algorithm of Haario et al (2001).
</p>


<h3>Value</h3>

<p>Matrix whose rows are MCMC states: the initial state <code>theta0</code> and N subsequent states.
</p>


<h3>References</h3>

<p>D. Prangle gk: An R package for the g-and-k and generalised g-and-h distributions, 2017.
H. Haario, E. Saksman, and J. Tamminen. An adaptive Metropolis algorithm. Bernoulli, 2001.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
x = rgk(10, A=3, B=1, g=2, k=0.5) ##An unusually small dataset for fast execution of this example
out = mcmc(x, N=1000, theta0=c(mean(x),sd(x),0,0), Sigma0=0.1*diag(4))
</code></pre>

<hr>
<h2 id='momentEstimates'>Convert octiles to moment estimates</h2><span id='topic+momentEstimates'></span>

<h3>Description</h3>

<p>Convert octiles to estimates of location, scale, skewness and kurtosis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>momentEstimates(octiles)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="momentEstimates_+3A_octiles">octiles</code></td>
<td>
<p>Vector of octiles.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Converts octiles to robust estimate of location, scale, skewness and kurtosis as used by Drovandi and Pettitt (2011).
</p>


<h3>Value</h3>

<p>Vector of moment estimates.
</p>


<h3>References</h3>

<p>C. C. Drovandi and A. N. Pettitt. Likelihood-free Bayesian estimation of multivariate quantile distributions. Computational Statistics &amp; Data Analysis, 2011.
</p>

<hr>
<h2 id='orderstats'>Order statistics</h2><span id='topic+orderstats'></span>

<h3>Description</h3>

<p>Sample a subset of order statistics of the Uniform(0,1) distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>orderstats(n, orderstats)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="orderstats_+3A_n">n</code></td>
<td>
<p>Total number of independent draws</p>
</td></tr>
<tr><td><code id="orderstats_+3A_orderstats">orderstats</code></td>
<td>
<p>Which order statistics to generate, in increasing order</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uniform order statistics are generated by the exponential spacings method (see Ripley for example).
</p>


<h3>Value</h3>

<p>A vector of order statistics equal in length to <code>orderstats</code>
</p>


<h3>References</h3>

<p>Brian Ripley &lsquo;Stochastic Simulation&rsquo; Wiley (1987)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>orderstats(100, c(25,50,75))
</code></pre>

<hr>
<h2 id='pgh_scalar'>Distribution function for the g-and-h distribution</h2><span id='topic+pgh_scalar'></span>

<h3>Description</h3>

<p>Distribution function for the g-and-h distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pgh_scalar(
  q,
  A,
  B,
  g,
  h,
  c = 0.8,
  zscale = FALSE,
  type = c("generalised", "tukey")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pgh_scalar_+3A_q">q</code></td>
<td>
<p>Quantiles.</p>
</td></tr>
<tr><td><code id="pgh_scalar_+3A_a">A</code></td>
<td>
<p>A (location) parameter.</p>
</td></tr>
<tr><td><code id="pgh_scalar_+3A_b">B</code></td>
<td>
<p>B (scale) parameter. Must be positive.</p>
</td></tr>
<tr><td><code id="pgh_scalar_+3A_g">g</code></td>
<td>
<p>g parameter.</p>
</td></tr>
<tr><td><code id="pgh_scalar_+3A_h">h</code></td>
<td>
<p>h parameter. Must be non-negative.</p>
</td></tr>
<tr><td><code id="pgh_scalar_+3A_c">c</code></td>
<td>
<p>c parameter. Often fixed at 0.8 which is the default.</p>
</td></tr>
<tr><td><code id="pgh_scalar_+3A_zscale">zscale</code></td>
<td>
<p>When true returns the N(0,1) quantile of the cdf (needed by dgh).</p>
</td></tr>
<tr><td><code id="pgh_scalar_+3A_type">type</code></td>
<td>
<p>Can be &quot;generalised&quot; (default) or &quot;tukey&quot;.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This internal function performs the calculation assuming scalar inputs.
The exported function is a vectorised wrapper of this.
</p>


<h3>Value</h3>

<p>The cumulative probability.
</p>

<hr>
<h2 id='pgk_scalar'>Distribution function for the g-and-k distribution</h2><span id='topic+pgk_scalar'></span>

<h3>Description</h3>

<p>Distribution function for the g-and-k distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pgk_scalar(q, A, B, g, k, c = 0.8, zscale = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pgk_scalar_+3A_q">q</code></td>
<td>
<p>Quantiles.</p>
</td></tr>
<tr><td><code id="pgk_scalar_+3A_a">A</code></td>
<td>
<p>A (location) parameter.</p>
</td></tr>
<tr><td><code id="pgk_scalar_+3A_b">B</code></td>
<td>
<p>B (scale) parameter. Must be positive.</p>
</td></tr>
<tr><td><code id="pgk_scalar_+3A_g">g</code></td>
<td>
<p>g parameter.</p>
</td></tr>
<tr><td><code id="pgk_scalar_+3A_k">k</code></td>
<td>
<p>k parameter. Must be at least -0.5.</p>
</td></tr>
<tr><td><code id="pgk_scalar_+3A_c">c</code></td>
<td>
<p>c parameter. Often fixed at 0.8 which is the default.</p>
</td></tr>
<tr><td><code id="pgk_scalar_+3A_zscale">zscale</code></td>
<td>
<p>When true returns the N(0,1) quantile of the cdf (needed by dgk).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This internal function performs the calculation assuming scalar inputs.
The exported function is a vectorised wrapper of this.
</p>


<h3>Value</h3>

<p>The cumulative probability.
</p>

<hr>
<h2 id='project'>Project into a region</h2><span id='topic+project'></span>

<h3>Description</h3>

<p>Project a vector elementwise into a constrained region
</p>


<h3>Usage</h3>

<pre><code class='language-R'>project(x, xmin, xmax)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="project_+3A_x">x</code></td>
<td>
<p>Vector</p>
</td></tr>
<tr><td><code id="project_+3A_xmin">xmin</code></td>
<td>
<p>Vector of lower bounds</p>
</td></tr>
<tr><td><code id="project_+3A_xmax">xmax</code></td>
<td>
<p>Vector of upper bounds</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Vector of closest values to x which satisfy the bounds
</p>

<hr>
<h2 id='Qgh_deriv'>g-and-h Q derivative</h2><span id='topic+Qgh_deriv'></span>

<h3>Description</h3>

<p>Derivative of the g-and-h Q function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Qgh_deriv(
  z,
  A,
  B,
  g,
  h,
  c = 0.8,
  getR = FALSE,
  type = c("generalised", "tukey")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Qgh_deriv_+3A_z">z</code></td>
<td>
<p>A vector of normal quantiles.</p>
</td></tr>
<tr><td><code id="Qgh_deriv_+3A_a">A</code></td>
<td>
<p>Vector of A (location) parameters.</p>
</td></tr>
<tr><td><code id="Qgh_deriv_+3A_b">B</code></td>
<td>
<p>Vector of B (scale) parameters. Must be positive.</p>
</td></tr>
<tr><td><code id="Qgh_deriv_+3A_g">g</code></td>
<td>
<p>Vector of g parameters.</p>
</td></tr>
<tr><td><code id="Qgh_deriv_+3A_h">h</code></td>
<td>
<p>Vector of h parameters. Must be positive.</p>
</td></tr>
<tr><td><code id="Qgh_deriv_+3A_c">c</code></td>
<td>
<p>Vector of c parameters. Often fixed at 0.8 which is the default.</p>
</td></tr>
<tr><td><code id="Qgh_deriv_+3A_getr">getR</code></td>
<td>
<p>When <code>TRUE</code> returns a faster partial calculation that has the same sign as the derivative (Used in checking parameter validity.)</p>
</td></tr>
<tr><td><code id="Qgh_deriv_+3A_type">type</code></td>
<td>
<p>Can be &quot;generalised&quot; (default) or &quot;tukey&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The derivative of the g-and-h Q function at p.
</p>

<hr>
<h2 id='Qgh_log_deriv'>g-and-h Q log derivative</h2><span id='topic+Qgh_log_deriv'></span>

<h3>Description</h3>

<p>Derivative of the g-and-h log(Q) function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Qgh_log_deriv(z, A, B, g, h, c = 0.8, type)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Qgh_log_deriv_+3A_z">z</code></td>
<td>
<p>A vector of normal quantiles.</p>
</td></tr>
<tr><td><code id="Qgh_log_deriv_+3A_a">A</code></td>
<td>
<p>Vector of A (location) parameters.</p>
</td></tr>
<tr><td><code id="Qgh_log_deriv_+3A_b">B</code></td>
<td>
<p>Vector of B (scale) parameters. Must be positive.</p>
</td></tr>
<tr><td><code id="Qgh_log_deriv_+3A_g">g</code></td>
<td>
<p>Vector of g parameters.</p>
</td></tr>
<tr><td><code id="Qgh_log_deriv_+3A_h">h</code></td>
<td>
<p>Vector of k parameters. Must be positive.</p>
</td></tr>
<tr><td><code id="Qgh_log_deriv_+3A_c">c</code></td>
<td>
<p>Vector of c parameters. Often fixed at 0.8 which is the default.</p>
</td></tr>
<tr><td><code id="Qgh_log_deriv_+3A_type">type</code></td>
<td>
<p>Can be &quot;generalised&quot; (default) or &quot;tukey&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The derivative of the g-and-h Q function at p.
</p>

<hr>
<h2 id='Qgk_deriv'>g-and-k Q derivative</h2><span id='topic+Qgk_deriv'></span>

<h3>Description</h3>

<p>Derivative of the g-and-k Q function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Qgk_deriv(z, A, B, g, k, c = 0.8, getR = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Qgk_deriv_+3A_z">z</code></td>
<td>
<p>A vector of normal quantiles.</p>
</td></tr>
<tr><td><code id="Qgk_deriv_+3A_a">A</code></td>
<td>
<p>Vector of A (location) parameters.</p>
</td></tr>
<tr><td><code id="Qgk_deriv_+3A_b">B</code></td>
<td>
<p>Vector of B (scale) parameters. Must be positive.</p>
</td></tr>
<tr><td><code id="Qgk_deriv_+3A_g">g</code></td>
<td>
<p>Vector of g parameters.</p>
</td></tr>
<tr><td><code id="Qgk_deriv_+3A_k">k</code></td>
<td>
<p>Vector of k parameters. Must be at least -0.5.</p>
</td></tr>
<tr><td><code id="Qgk_deriv_+3A_c">c</code></td>
<td>
<p>Vector of c parameters. Often fixed at 0.8 which is the default.</p>
</td></tr>
<tr><td><code id="Qgk_deriv_+3A_getr">getR</code></td>
<td>
<p>When <code>TRUE</code> returns a faster partial calculation that has the same sign as the derivative (Used in checking parameter validity.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The derivative of the g-and-k Q function at p.
</p>

<hr>
<h2 id='Qgk_log_deriv'>g-and-k Q log derivative</h2><span id='topic+Qgk_log_deriv'></span>

<h3>Description</h3>

<p>Derivative of the g-and-k log(Q) function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Qgk_log_deriv(z, A, B, g, k, c = 0.8)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="Qgk_log_deriv_+3A_z">z</code></td>
<td>
<p>A vector of normal quantiles.</p>
</td></tr>
<tr><td><code id="Qgk_log_deriv_+3A_a">A</code></td>
<td>
<p>Vector of A (location) parameters.</p>
</td></tr>
<tr><td><code id="Qgk_log_deriv_+3A_b">B</code></td>
<td>
<p>Vector of B (scale) parameters. Must be positive.</p>
</td></tr>
<tr><td><code id="Qgk_log_deriv_+3A_g">g</code></td>
<td>
<p>Vector of g parameters.</p>
</td></tr>
<tr><td><code id="Qgk_log_deriv_+3A_k">k</code></td>
<td>
<p>Vector of k parameters. Must be greater than -0.5.</p>
</td></tr>
<tr><td><code id="Qgk_log_deriv_+3A_c">c</code></td>
<td>
<p>Vector of c parameters. Often fixed at 0.8 which is the default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The derivative of the g-and-k Q function at p.
</p>

<hr>
<h2 id='z2gh'>Transform standard normal draws to g-and-h draws.</h2><span id='topic+z2gh'></span>

<h3>Description</h3>

<p>Transform standard normal draws to g-and-h draws.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>z2gh(z, A, B, g, h, c = 0.8, type = c("generalised", "tukey"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="z2gh_+3A_z">z</code></td>
<td>
<p>Vector of N(0,1) draws.</p>
</td></tr>
<tr><td><code id="z2gh_+3A_a">A</code></td>
<td>
<p>Vector of location parameters.</p>
</td></tr>
<tr><td><code id="z2gh_+3A_b">B</code></td>
<td>
<p>Vector of scale parameters. Must be positive.</p>
</td></tr>
<tr><td><code id="z2gh_+3A_g">g</code></td>
<td>
<p>Vector of g parameters.</p>
</td></tr>
<tr><td><code id="z2gh_+3A_h">h</code></td>
<td>
<p>Vector of h parameters.</p>
</td></tr>
<tr><td><code id="z2gh_+3A_c">c</code></td>
<td>
<p>Vector of c parameters. Often fixed at 0.8 which is the default.</p>
</td></tr>
<tr><td><code id="z2gh_+3A_type">type</code></td>
<td>
<p>Can be &quot;generalised&quot; (default) or &quot;tukey&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of g-and-h values.
</p>

<hr>
<h2 id='z2gk'>Transform standard normal draws to g-and-k draws.</h2><span id='topic+z2gk'></span>

<h3>Description</h3>

<p>Transform standard normal draws to g-and-k draws.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>z2gk(z, A, B, g, k, c = 0.8)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="z2gk_+3A_z">z</code></td>
<td>
<p>Vector of N(0,1) draws.</p>
</td></tr>
<tr><td><code id="z2gk_+3A_a">A</code></td>
<td>
<p>Vector of location parameters.</p>
</td></tr>
<tr><td><code id="z2gk_+3A_b">B</code></td>
<td>
<p>Vector of scale parameters. Must be positive.</p>
</td></tr>
<tr><td><code id="z2gk_+3A_g">g</code></td>
<td>
<p>Vector of g parameters.</p>
</td></tr>
<tr><td><code id="z2gk_+3A_k">k</code></td>
<td>
<p>Vector of k parameters. Must be at least -0.5.</p>
</td></tr>
<tr><td><code id="z2gk_+3A_c">c</code></td>
<td>
<p>Vector of c parameters. Often fixed at 0.8 which is the default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of g-and-k values.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
