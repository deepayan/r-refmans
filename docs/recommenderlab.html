<!DOCTYPE html><html><head><title>Help for package recommenderlab</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {recommenderlab}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#binaryRatingMatrix'><p>Class &quot;binaryRatingMatrix&quot;: A Binary Rating Matrix</p></a></li>
<li><a href='#calcPredictionAccuracy'>
<p>Calculate the Prediction Error for a Recommendation</p></a></li>
<li><a href='#dissimilarity'>
<p>Dissimilarity and Similarity Calculation Between Rating Data</p></a></li>
<li><a href='#Error'><p>Error Calculation</p></a></li>
<li><a href='#evaluate'>
<p>Evaluate a Recommender Models</p></a></li>
<li><a href='#evaluationResultList-class'><p>Class &quot;evaluationResultList&quot;: Results of the Evaluation of a Multiple Recommender Methods</p></a></li>
<li><a href='#evaluationResults-class'><p>Class &quot;evaluationResults&quot;: Results of the Evaluation of a Single Recommender Method</p></a></li>
<li><a href='#evaluationScheme'><p>Creator Function for evaluationScheme</p></a></li>
<li><a href='#evaluationScheme-class'><p>Class &quot;evaluationScheme&quot;: Evaluation Scheme</p></a></li>
<li><a href='#funkSVD'><p>Funk SVD for Matrices with Missing Data</p></a></li>
<li><a href='#getList'>
<p>List and Data.frame Representation for Recommender Matrix Objects</p></a></li>
<li><a href='#HybridRecommender'>
<p>Create a Hybrid Recommender</p></a></li>
<li><a href='#internalFunctions'><p>Internal Utility Functions</p></a></li>
<li><a href='#Jester5k'><p>Jester dataset (5k sample)</p></a></li>
<li><a href='#MovieLense'>
<p>MovieLense Dataset (100k)</p></a></li>
<li><a href='#MSWeb'>
<p>Anonymous web data from www.microsoft.com</p></a></li>
<li><a href='#normalize'><p>Normalize the ratings</p></a></li>
<li><a href='#plot'>
<p>Plot Evaluation Results</p></a></li>
<li><a href='#predict'>
<p>Predict Recommendations</p></a></li>
<li><a href='#ratingMatrix'><p>Class &quot;ratingMatrix&quot;: Virtual Class for Rating Data</p></a></li>
<li><a href='#realRatingMatrix'><p>Class &quot;realRatingMatrix&quot;: Real-valued Rating Matrix</p></a></li>
<li><a href='#Recommender'>
<p>Create a Recommender Model</p></a></li>
<li><a href='#Recommender-class'><p>Class &quot;Recommender&quot;: A Recommender Model</p></a></li>
<li><a href='#sparseNAMatrix-class'>
<p>Sparse Matrix Representation With NAs Not Explicitly Stored</p></a></li>
<li><a href='#topNList'><p>Class &quot;topNList&quot;: Top-N List</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.0.6</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-19</td>
</tr>
<tr>
<td>Title:</td>
<td>Lab for Developing and Testing Recommender Algorithms</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides a research infrastructure to develop and evaluate
    collaborative filtering recommender algorithms. This includes a sparse 
    representation for user-item matrices, many popular algorithms, top-N recommendations,
    and cross-validation. Hahsler (2022) &lt;<a href="https://doi.org/10.48550%2FarXiv.2205.12371">doi:10.48550/arXiv.2205.12371</a>&gt;.</td>
</tr>
<tr>
<td>Classification/ACM:</td>
<td>G.4, H.2.8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), Matrix, arules, proxy (&ge; 0.4-26)</td>
</tr>
<tr>
<td>Imports:</td>
<td>registry, methods, utils, stats, irlba, recosystem,
matrixStats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mhahsler/recommenderlab/issues">https://github.com/mhahsler/recommenderlab/issues</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mhahsler/recommenderlab">https://github.com/mhahsler/recommenderlab</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Copyright:</td>
<td>(C) Michael Hahsler</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-19 16:47:44 UTC; hahsler</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Hahsler <a href="https://orcid.org/0000-0003-2716-1405"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Bregt Vereet [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Hahsler &lt;mhahsler@lyle.smu.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-20 07:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='binaryRatingMatrix'>Class &quot;binaryRatingMatrix&quot;: A Binary Rating Matrix</h2><span id='topic+binaryRatingMatrix-class'></span><span id='topic+binaryRatingMatrix'></span><span id='topic+coerce+2Cmatrix+2CbinaryRatingMatrix-method'></span><span id='topic+coerce+2CitemMatrix+2CbinaryRatingMatrix-method'></span><span id='topic+coerce+2Cdata.frame+2CbinaryRatingMatrix-method'></span><span id='topic+coerce+2CbinaryRatingMatrix+2Cmatrix-method'></span><span id='topic+coerce+2CbinaryRatingMatrix+2CdgTMatrix-method'></span><span id='topic+coerce+2CbinaryRatingMatrix+2CngCMatrix-method'></span><span id='topic+coerce+2CbinaryRatingMatrix+2CdgCMatrix-method'></span><span id='topic+coerce+2CbinaryRatingMatrix+2CitemMatrix-method'></span><span id='topic+coerce+2CbinaryRatingMatrix+2Clist-method'></span>

<h3>Description</h3>

<p>A matrix to represent binary rating data. 1 codes for a positive
rating and 0 codes for either no or a negative rating. This
coding is common for market basked data where products are either bought or
not.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("binaryRatingMatrix", data = im)</code>, where <code>im</code> is an <code>itemMatrix</code> as defined in package
<span class="pkg">arules</span>, by coercion from a matrix (all non-zero values will be a 1),
or by using <code>binarize</code> for
an object of class &quot;realRatingMatrix&quot;.
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code>:</dt><dd><p>Object of class <code>"itemMatrix"</code> (see package <span class="pkg">arules</span>)</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+ratingMatrix-class">ratingMatrix</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>coerce</dt><dd><p><code>signature(from = "matrix", to = "binaryRatingMatrix")</code>:
The matrix needs to be a logical matrix, or a 0-1 matrix (0 means FALSE and 1 means TRUE).
NAs are interpreted as FALSE.
</p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "itemMatrix", to = "binaryRatingMatrix")</code></p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "data.frame", to = "binaryRatingMatrix")</code></p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "binaryRatingMatrix", to = "matrix")</code></p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "binaryRatingMatrix", to = "dgTMatrix")</code></p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "binaryRatingMatrix", to = "ngCMatrix")</code></p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "binaryRatingMatrix", to = "dgCMatrix")</code></p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "binaryRatingMatrix", to = "itemMatrix")</code></p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "binaryRatingMatrix", to = "list")</code></p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="arules.html#topic+itemMatrix-class">itemMatrix</a></code> in <span class="pkg">arules</span>,
<code><a href="#topic+getList">getList</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create a 0-1 matrix
m &lt;- matrix(sample(c(0,1), 50, replace=TRUE), nrow=5, ncol=10,
    dimnames=list(users=paste("u", 1:5, sep=''),
    items=paste("i", 1:10, sep='')))
m

## coerce it into a binaryRatingMatrix
b &lt;- as(m, "binaryRatingMatrix")
b

## coerce it back to see if it worked
as(b, "matrix")

## use some methods defined in ratingMatrix
dim(b)
dimnames(b)

## counts
rowCounts(b) ## number of ratings per user
colCounts(b) ## number of ratings per item

## plot
image(b)

## sample and subset
sample(b,2)
b[1:2,1:5]

## coercion
as(b, "list")
head(as(b, "data.frame"))
head(getData.frame(b, ratings=FALSE))

## creation from user/item tuples
df &lt;- data.frame(user=c(1,1,2,2,2,3), items=c(1,4,1,2,3,5))
df
b2 &lt;- as(df, "binaryRatingMatrix")
b2
as(b2, "matrix")
</code></pre>

<hr>
<h2 id='calcPredictionAccuracy'>
Calculate the Prediction Error for a Recommendation
</h2><span id='topic+calcPredictionAccuracy'></span><span id='topic+calcPredictionAccuracy+2CrealRatingMatrix+2CrealRatingMatrix-method'></span><span id='topic+calcPredictionAccuracy+2CtopNList+2CbinaryRatingMatrix-method'></span><span id='topic+calcPredictionAccuracy+2CtopNList+2CrealRatingMatrix-method'></span>

<h3>Description</h3>

<p>Calculate prediction accuracy. For predicted ratings
MAE (mean average error), MSE (means squared error)
and RMSE (root means squared error) are calculated. For topNLists
various binary classification metrics are returned (e.g., precision, recall, TPR, FPR).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcPredictionAccuracy(x, data, ...)

## S4 method for signature 'realRatingMatrix,realRatingMatrix'
calcPredictionAccuracy(x, data, byUser = FALSE, ...)

## S4 method for signature 'topNList,realRatingMatrix'
calcPredictionAccuracy(x, data, byUser = FALSE,
  given = NULL, goodRating = NA, ...)

## S4 method for signature 'topNList,binaryRatingMatrix'
calcPredictionAccuracy(x, data, byUser = FALSE,
  given = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calcPredictionAccuracy_+3A_x">x</code></td>
<td>
<p> Predicted items in a &quot;topNList&quot; or predicted ratings as a &quot;realRatingMatrix&quot;</p>
</td></tr>
<tr><td><code id="calcPredictionAccuracy_+3A_data">data</code></td>
<td>
<p> Observed true ratings for the users as a &quot;RatingMatrix&quot;. The users have to be in the same order as in <code>x</code>. </p>
</td></tr>
<tr><td><code id="calcPredictionAccuracy_+3A_byuser">byUser</code></td>
<td>
<p> logical; Should the accuracy measures be reported for each user individually instead of being averaged over all users?</p>
</td></tr>
<tr><td><code id="calcPredictionAccuracy_+3A_given">given</code></td>
<td>
<p> how many items were given to create the predictions. If the data comes from an evaluation scheme that usses all-but-x (i.e., a negative value for <code>give</code>), then a vector with the number of items actually given for each prediction needs to be supplied.
This can be optained from the evaluation scheme <code>es</code> via <code>getData(es, "given")</code>. </p>
</td></tr>
<tr><td><code id="calcPredictionAccuracy_+3A_goodrating">goodRating</code></td>
<td>
<p> If <code>x</code> is a &quot;topNList&quot; and <code>data</code> is a &quot;realRatingMatrix&quot; then <code>goodRating</code> is used as the threshold for determining what rating in <code>data</code> is considered a good rating.</p>
</td></tr>
<tr><td><code id="calcPredictionAccuracy_+3A_...">...</code></td>
<td>
<p> further arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calculates the accuracy of predictions compared to the observed true ratings (<code>data</code>) averaged over the users. Use <code>byUser = TRUE</code> to get the results for each user.
</p>
<p>If both, the predictions are numeric ratings (i.e. a &quot;realRatingMatrix&quot;),
then the error measures RMSE, MSE and MAE are calculated.
</p>
<p>If the predictions are a &quot;topNList&quot;, then the entries of the confusion matrix (true positives TP, false positives FP, false negatives FN and true negatives TN) and binary classification measures like precision, recall, TPR and FPR are calculated. If data is a &quot;realRatingMatrix&quot;, then
<code>goodRating</code> has to be specified to identify items that should be recommended (i.e., have a rating of goodRating or more).
Note that you need to specify the number of items given to the recommender to create predictions.
The number of predictions by user (N) is the total number of items in the data minus the number of given items. The number of TP is limited by the size of the top-N list. Also, since the counts for TP, FP, FN and TN are averaged over the users (unless <code>byUser = TRUE</code> is used),
they will not be whole numbers.
</p>
<p>If the ratings are a &quot;topNList&quot; and the observed data is a &quot;realRatingMatrix&quot; then <code>goodRating</code> is used
to determine what rating in <code>data</code> is considered a good rating for calculating binary classification measures. This means that an item in the topNList is considered a true positive if it has a rating of <code>goodRating</code> or better in the observed data.
</p>


<h3>Value</h3>

<p>Returns a vector with the appropriate measures averaged over all users.
For <code>byUser=TRUE</code>, a matrix with a row for each user is returned.
</p>


<h3>References</h3>

<p>Asela Gunawardana and Guy Shani (2009). A Survey of Accuracy Evaluation Metrics of
Recommendation Tasks, Journal of Machine Learning Research 10, 2935-2962.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+topNList-class">topNList</a></code>,
<code><a href="#topic+binaryRatingMatrix-class">binaryRatingMatrix</a></code>,
<code><a href="#topic+realRatingMatrix-class">realRatingMatrix</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### recommender for real-valued ratings
data(Jester5k)

## create 90/10 split (known/unknown) for the first 500 users in Jester5k
e &lt;- evaluationScheme(Jester5k[1:500, ], method = "split", train = 0.9,
    k = 1, given = 15)
e

## create a user-based CF recommender using training data
r &lt;- Recommender(getData(e, "train"), "UBCF")

## create predictions for the test data using known ratings (see given above)
p &lt;- predict(r, getData(e, "known"), type = "ratings")
p

## compute error metrics averaged per user and then averaged over all
## recommendations
calcPredictionAccuracy(p, getData(e, "unknown"))
head(calcPredictionAccuracy(p, getData(e, "unknown"), byUser = TRUE))

## evaluate topNLists instead (you need to specify given and goodRating!)
p &lt;- predict(r, getData(e, "known"), type = "topNList")
p
calcPredictionAccuracy(p, getData(e, "unknown"), given = 15, goodRating = 5)

## evaluate a binary recommender
data(MSWeb)
MSWeb10 &lt;- sample(MSWeb[rowCounts(MSWeb) &gt;10,], 50)

e &lt;- evaluationScheme(MSWeb10, method="split", train = 0.9,
    k = 1, given = 3)
e

## create a user-based CF recommender using training data
r &lt;- Recommender(getData(e, "train"), "UBCF")

## create predictions for the test data using known ratings (see given above)
p &lt;- predict(r, getData(e, "known"), type="topNList", n = 10)
p

calcPredictionAccuracy(p, getData(e, "unknown"), given = 3)
calcPredictionAccuracy(p, getData(e, "unknown"), given = 3, byUser = TRUE)
</code></pre>

<hr>
<h2 id='dissimilarity'>
Dissimilarity and Similarity Calculation Between Rating Data
</h2><span id='topic+dissimilarity'></span><span id='topic+dissimilarity+2CbinaryRatingMatrix-method'></span><span id='topic+dissimilarity+2CrealRatingMatrix-method'></span><span id='topic+similarity'></span><span id='topic+similarity+2CratingMatrix-method'></span>

<h3>Description</h3>

<p>Calculate dissimilarities/similarities between ratings by users and for items.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'binaryRatingMatrix'
dissimilarity(x, y = NULL, method = NULL, args = NULL, which = "users")
## S4 method for signature 'realRatingMatrix'
dissimilarity(x, y = NULL, method = NULL, args = NULL, which = "users")

similarity(x, y = NULL, method = NULL, args = NULL, ...)
## S4 method for signature 'ratingMatrix'
similarity(x, y = NULL, method = NULL, args = NULL, which = "users",
  min_matching = 0, min_predictive = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dissimilarity_+3A_x">x</code></td>
<td>
<p>a ratingMatrix.</p>
</td></tr>
<tr><td><code id="dissimilarity_+3A_y">y</code></td>
<td>
<p><code>NULL</code> or a second ratingMatrix to calculate
cross-(dis)similarities.</p>
</td></tr>
<tr><td><code id="dissimilarity_+3A_method">method</code></td>
<td>
<p>(dis)similarity measure to use. Available measures
are typically <code>"cosine"</code>, <code>"pearson"</code>, <code>"jaccard"</code>, etc.
See <code>dissimilarity</code> for
class <code>itemMatrix</code> in <span class="pkg">arules</span> for details about measures
for <code>binaryRatingMatrix</code> and <code>dist</code> in <span class="pkg">proxy</span> for
<code>realRatingMatrix</code>.
Default for <code>realRatingMatrix</code> is cosine and for <code>binaryRatingMatrix</code> is jaccard.</p>
</td></tr>
<tr><td><code id="dissimilarity_+3A_args">args</code></td>
<td>
<p>a list of additional arguments for the methods.</p>
</td></tr>
<tr><td><code id="dissimilarity_+3A_which">which</code></td>
<td>
<p>a character string indicating if the (dis)similarity should be
calculated between <code>"users"</code> (rows) or <code>"items"</code> (columns).</p>
</td></tr>
<tr><td><code id="dissimilarity_+3A_min_matching">min_matching</code>, <code id="dissimilarity_+3A_min_predictive">min_predictive</code></td>
<td>
<p> Thresholds on the minimum number of ratings used to
calculate the similarity and the minimum number of ratings that can be used for prediction.</p>
</td></tr>
<tr><td><code id="dissimilarity_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Most dissimlarites and similarities are calculated using the <span class="pkg">proxy</span> package.
Similarities are typically converted into dissimilarities using <code class="reqn">s = 1 / (1 + d)</code>
or <code class="reqn">s = 1 - d</code> (used for Jaccard, Cosine and Pearson correlation) depending on the measure.
</p>
<p>Similarities are usually defined in the range of <code class="reqn">[0, 1]</code>, however,
Cosine similarity and Pearson correlation are defined in the interval <code class="reqn">[-1, 1]</code>. We rescale these
measures with <code class="reqn">s' = 1 / 2 (s + 1)</code> to the interval <code class="reqn">[0, 1]</code>.
</p>
<p>Similarities are calculated using only the ratings that are available for both
users/items. This can lead to calculating the measure using only a very small number (maybe only one)
of ratings. <code>min_matching</code> is the required number of shared ratings to calculate similarities.
To predict ratings, there need to be additional ratings in argument <code>y</code>.
<code>min_predictive</code>  is the  required number of additional ratings to calculate similarities. If
<code>min_matching</code> or <code>min_predictive</code> fails, then <code>NA</code> is reported instead of the calculated similarity.
</p>


<h3>Value</h3>

<p>returns an object of class <code>"dist"</code>, <code>"simil"</code>
or an appropriate object (e.g.,
a matrix with class <code>"crossdist"</code> o <code>"crosssimil"</code>) to represent
a cross-(dis)similarity.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ratingMatrix-class">ratingMatrix</a></code>,
<code><a href="arules.html#topic+dissimilarity">dissimilarity</a></code> in <span class="pkg">arules</span>, and
<code><a href="proxy.html#topic+dist">dist</a></code> in <span class="pkg">proxy</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(MSWeb)

## between 5 users
dissimilarity(MSWeb[1:5,], method = "jaccard")
similarity(MSWeb[1:5,], method = "jaccard")

## between first 3 items
dissimilarity(MSWeb[,1:3], method = "jaccard", which = "items")
similarity(MSWeb[,1:3], method = "jaccard", which = "items")

## cross-similarity between first 2 users and users 10-20
similarity(MSWeb[1:2,], MSWeb[10:20,], method="jaccard")
</code></pre>

<hr>
<h2 id='Error'>Error Calculation</h2><span id='topic+RMSE'></span><span id='topic+frobenius'></span><span id='topic+MSE'></span><span id='topic+MAE'></span>

<h3>Description</h3>

<p>Calculate the mean absolute error (MAE), mean square error (MSE),
root mean square error (RMSE) and for matrices also the Frobenius norm (identical to RMSE).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MSE(true, predicted, na.rm = TRUE)
RMSE(true, predicted, na.rm = TRUE)
MAE(true, predicted, na.rm = TRUE)
frobenius(true, predicted, na.rm = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Error_+3A_true">true</code></td>
<td>
<p> true values. </p>
</td></tr>
<tr><td><code id="Error_+3A_predicted">predicted</code></td>
<td>
<p> predicted values </p>
</td></tr>
<tr><td><code id="Error_+3A_na.rm">na.rm</code></td>
<td>
<p> ignore missing values. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Frobenius norm requires matrices.
</p>


<h3>Value</h3>

<p>The error value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>true &lt;- rnorm(10)
predicted &lt;- rnorm(10)

MAE(true, predicted)
MSE(true, predicted)
RMSE(true, predicted)

true &lt;- matrix(rnorm(9), nrow = 3)
predicted &lt;- matrix(rnorm(9), nrow = 3)

frobenius(true, predicted)
</code></pre>

<hr>
<h2 id='evaluate'>
Evaluate a Recommender Models
</h2><span id='topic+evaluate'></span><span id='topic+evaluate+2CevaluationScheme+2Ccharacter-method'></span><span id='topic+evaluate+2CevaluationScheme+2Clist-method'></span>

<h3>Description</h3>

<p>Evaluates a single or a list of recommender model given an evaluation scheme and return evaluation metrics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate(x, method, ...)

## S4 method for signature 'evaluationScheme,character'
evaluate(x, method, type="topNList",
  n=1:10, parameter=NULL, progress = TRUE, keepModel=FALSE)
## S4 method for signature 'evaluationScheme,list'
evaluate(x, method, type="topNList",
  n=1:10, parameter=NULL, progress = TRUE, keepModel=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_+3A_x">x</code></td>
<td>
<p>an evaluation scheme (class <code>"evaluationScheme"</code>).</p>
</td></tr>
<tr><td><code id="evaluate_+3A_method">method</code></td>
<td>
<p>a character string or a list. If
a single character string is given it defines the recommender method
used for evaluation. If several recommender methods need to be compared,
<code>method</code> contains a nested list. Each element describes a recommender
method and consists of a list with two elements: a character string
named <code>"name"</code> containing the method and a list named
<code>"parameters"</code> containing the parameters used for this recommender method.
See <code>Recommender</code> for available methods.</p>
</td></tr>
<tr><td><code id="evaluate_+3A_type">type</code></td>
<td>
<p>evaluate &quot;topNList&quot; or &quot;ratings&quot;?</p>
</td></tr>
<tr><td><code id="evaluate_+3A_n">n</code></td>
<td>
<p>a vector of the different values for N used to generate top-N lists (only if type=&quot;topNList&quot;).</p>
</td></tr>
<tr><td><code id="evaluate_+3A_parameter">parameter</code></td>
<td>
<p>a list with parameters for the recommender algorithm (only
used when <code>method</code> is a single method).</p>
</td></tr>
<tr><td><code id="evaluate_+3A_progress">progress</code></td>
<td>
<p>logical; report progress?</p>
</td></tr>
<tr><td><code id="evaluate_+3A_keepmodel">keepModel</code></td>
<td>
<p>logical; store used recommender models?</p>
</td></tr>
<tr><td><code id="evaluate_+3A_...">...</code></td>
<td>
<p>further arguments. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The evaluation uses the specification in the evaluation scheme to train a recommender models on training data and then evaluates the models on test data.
The result is a set of accuracy measures averaged over the test users.
See <code><a href="#topic+calcPredictionAccuracy">calcPredictionAccuracy</a></code> for details on the accuracy measures and the averaging.
Note: Also the confusion matrix counts are averaged over users and therefore not whole numbers.
</p>
<p>See <code>vignette("recommenderlab")</code> for more details on the evaluaiton process and the used metrics.
</p>


<h3>Value</h3>

<p>If a single recommender method is specified in  <code>method</code>, then an
object of class <code>"evaluationResults"</code> is returned.
If <code>method</code> is a list of recommendation models, then an object of class <code>"evaluationResultList"</code> is returned.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+calcPredictionAccuracy">calcPredictionAccuracy</a></code>,
<code><a href="#topic+evaluationScheme-class">evaluationScheme</a></code>,
<code><a href="#topic+evaluationResults-class">evaluationResults</a></code>.
<code><a href="#topic+evaluationResultList-class">evaluationResultList</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### evaluate top-N list recommendations on a 0-1 data set
## Note: we sample only 100 users to make the example run faster
data("MSWeb")
MSWeb10 &lt;- sample(MSWeb[rowCounts(MSWeb) &gt;10,], 100)

## create an evaluation scheme (10-fold cross validation, given-3 scheme)
es &lt;- evaluationScheme(MSWeb10, method="cross-validation",
        k=10, given=3)

## run evaluation
ev &lt;- evaluate(es, "POPULAR", n=c(1,3,5,10))
ev

## look at the results (the length of the topNList is shown as column n)
getResults(ev)

## get a confusion matrices averaged over the 10 folds
avg(ev)
plot(ev, annotate = TRUE)

## evaluate several algorithms (including a hybrid recommender) with a list
algorithms &lt;- list(
  RANDOM = list(name = "RANDOM", param = NULL),
  POPULAR = list(name = "POPULAR", param = NULL),
  HYBRID = list(name = "HYBRID", param =
      list(recommenders = list(
          RANDOM = list(name = "RANDOM", param = NULL),
          POPULAR = list(name = "POPULAR", param = NULL)
        )
      )
  )
)

evlist &lt;- evaluate(es, algorithms, n=c(1,3,5,10))
evlist
names(evlist)

## select the first results by index
evlist[[1]]
avg(evlist[[1]])

plot(evlist, legend="topright")

### Evaluate using a data set with real-valued ratings
## Note: we sample only 100 users to make the example run faster
data("Jester5k")
es &lt;- evaluationScheme(Jester5k[1:100], method="split",
  train=.9, given=10, goodRating=5)
## Note: goodRating is used to determine positive ratings

## predict top-N recommendation lists
## (results in TPR/FPR and precision/recall)
ev &lt;- evaluate(es, "RANDOM", type="topNList", n=10)
getResults(ev)

## predict missing ratings
## (results in RMSE, MSE and MAE)
ev &lt;- evaluate(es, "RANDOM", type="ratings")
getResults(ev)
</code></pre>

<hr>
<h2 id='evaluationResultList-class'>Class &quot;evaluationResultList&quot;: Results of the Evaluation of a Multiple Recommender Methods </h2><span id='topic+evaluationResultList-class'></span><span id='topic+coerce+2Clist+2CevaluationResultList-method'></span><span id='topic+avg+2CevaluationResultList-method'></span><span id='topic++5B+2CevaluationResultList+2CANY+2Cmissing+2Cmissing-method'></span><span id='topic+show+2CevaluationResultList-method'></span>

<h3>Description</h3>

<p>Contains the evaluation results for several runs using multiple recommender methods in form of confusion matrices. For each run the used models might be avialable.</p>


<h3>Objects from the Class</h3>

<p>Objects are created by <code>evaluate</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>.Data</code>:</dt><dd><p>Object of class <code>"list"</code>: a list of
<code>"evaluationResults"</code>.</p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="methods.html#topic+list-class">list</a>"</code>, from data part.
</p>


<h3>Methods</h3>


<dl>
<dt>avg</dt><dd><p><code>signature(x = "evaluationResultList")</code>: returns a
list of average confusion matrices.</p>
</dd>
<dt>[</dt><dd><p><code>signature(x = "evaluationResultList", i = "ANY", j = "missing", drop = "missing")</code></p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "list", to = "evaluationResultList")</code></p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "evaluationResultList")</code></p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+evaluate">evaluate</a></code>,
<code><a href="#topic+evaluationResults-class">evaluationResults</a></code>.
</p>

<hr>
<h2 id='evaluationResults-class'>Class &quot;evaluationResults&quot;: Results of the Evaluation of a Single Recommender Method</h2><span id='topic+evaluationResults-class'></span><span id='topic+confusionMatrix-class'></span><span id='topic+avg'></span><span id='topic+avg+2CevaluationResults-method'></span><span id='topic+getConfusionMatrix'></span><span id='topic+getConfusionMatrix+2CevaluationResults-method'></span><span id='topic+getResults'></span><span id='topic+getResults+2CevaluationResults-method'></span><span id='topic+getModel'></span><span id='topic+getModel+2CevaluationResults-method'></span><span id='topic+getRuns'></span><span id='topic+getRuns+2CevaluationResults-method'></span><span id='topic+show+2CevaluationResults-method'></span>

<h3>Description</h3>

<p>Contains the evaluation results for several runs using the same recommender method in form of confusion matrices. For each run the used model might be avialable.</p>


<h3>Objects from the Class</h3>

<p>Objects are created by <code>evaluate</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>results</code>:</dt><dd><p>Object of class <code>"list"</code>: contains
objects of class <code>"ConfusionMatrix"</code>, one for each run specified
in the used evaluation scheme.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>avg</dt><dd><p><code>signature(x = "evaluationResults")</code>: returns the evaluation metrics averaged of cross-validation folds. </p>
</dd>
<dt>getConfusionMatrix</dt><dd><p><code>signature(x = "evaluationResults")</code>: 
Deprecated. Use <code>getResults()</code>.</p>
</dd>
<dt>getResults</dt><dd><p><code>signature(x = "evaluationResults")</code>: 
returns a list of evaluation metrics with one element for each cross-valudation fold.</p>
</dd>
<dt>getModel</dt><dd><p><code>signature(x = "evaluationResults")</code>: returns a
list of used recommender models (if avilable). </p>
</dd>
<dt>getRuns</dt><dd><p><code>signature(x = "evaluationResults")</code>: returns
the number of runs/number of confusion matrices.</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "evaluationResults")</code> </p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+evaluate">evaluate</a></code>
</p>

<hr>
<h2 id='evaluationScheme'>Creator Function for evaluationScheme</h2><span id='topic+evaluationScheme'></span><span id='topic+evaluationScheme+2CratingMatrix-method'></span>

<h3>Description</h3>

<p>Creates an evaluationScheme object from a data set. The scheme can be a
simple split into training and test data, k-fold cross-evaluation or using k
independent bootstrap samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluationScheme(data, ...)

## S4 method for signature 'ratingMatrix'
evaluationScheme(data, method="split",
    train=0.9, k=NULL, given, goodRating = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluationScheme_+3A_data">data</code></td>
<td>
<p>data set as a ratingMatrix.</p>
</td></tr>
<tr><td><code id="evaluationScheme_+3A_method">method</code></td>
<td>
<p>a character string defining the evaluation
method to use (see details).</p>
</td></tr>
<tr><td><code id="evaluationScheme_+3A_train">train</code></td>
<td>
<p>fraction of the data set used for training.</p>
</td></tr>
<tr><td><code id="evaluationScheme_+3A_k">k</code></td>
<td>
<p>number of folds/times to run the evaluation (defaults to 10
for cross-validation and bootstrap and 1 for split).</p>
</td></tr>
<tr><td><code id="evaluationScheme_+3A_given">given</code></td>
<td>
<p>single number of items given for evaluation or
a vector of length of data giving the number of items given for each
observation. Negative values implement all-but schemes. For example,
<code>given = -1</code> means all-but-1 evaluation.</p>
</td></tr>
<tr><td><code id="evaluationScheme_+3A_goodrating">goodRating</code></td>
<td>
<p>numeric; threshold at which ratings are considered
good for evaluation. E.g., with <code>goodRating=3</code> all items
with actual user rating of greater or equal 3 are
considered positives in the evaluation process.
Note that this argument is only used if
the ratingMatrix is
a of subclass realRatingMatrix!</p>
</td></tr>
<tr><td><code id="evaluationScheme_+3A_...">...</code></td>
<td>
<p>further arguments. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>evaluationScheme</code> creates an evaluation scheme (training and test data)
with <code>k</code> runs and one of the following methods:
</p>
<p><code>"split"</code> randomly assigns
the proportion of objects specified by <code>train</code> to the training set and
the rest is used for the test set.
</p>
<p><code>"cross-validation"</code> creates a k-fold cross-validation scheme. The data
is randomly split into k parts and in each run k-1 parts are used for
training and the remaining part is used for testing. After all k runs each
part was used as the test set exactly once.
</p>
<p><code>"bootstrap"</code> creates the training set by taking a bootstrap sample
(sampling with replacement) of size <code>train</code> times number of users in
the data set.
All objects not in the training set are used for testing.
</p>
<p>For evaluation, Breese et al. (1998) introduced the
four experimental protocols called Given 2, Given 5, Given 10 and All-but-1.
During testing, the Given x protocol presents the algorithm with
only x randomly chosen items for the test user, and the algorithm
is evaluated by how well it is able to predict the withheld items.
For All-but-x,
the algorithm sees all but
x withheld ratings for the test user.
<code>given</code> controls x in the evaluations scheme.
Positive integers result in a Given x protocol, while negative values
produce a All-but-x protocol.
</p>
<p>If a user does not have enough ratings to satisfy <code>given</code>, then the user is dropped from the
evaluation with a warning.
</p>


<h3>Value</h3>

<p>Returns an object of class <code>"evaluationScheme"</code>.
</p>


<h3>References</h3>

<p>Kohavi, Ron (1995). &quot;A study of cross-validation and bootstrap for accuracy
estimation and model selection&quot;. Proceedings of  the Fourteenth International
Joint Conference on Artificial Intelligence, pp. 1137-1143.
</p>
<p>Breese JS, Heckerman D, Kadie C (1998). &quot;Empirical Analysis of Predictive
Algorithms for Collaborative Filtering.&quot; In Uncertainty in Artificial
Intelligence. Proceedings of the Fourteenth Conference, pp. 43-52.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+getData">getData</a></code>,
<code><a href="#topic+evaluationScheme-class">evaluationScheme</a></code>,
<code><a href="#topic+ratingMatrix-class">ratingMatrix</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("MSWeb")

MSWeb10 &lt;- sample(MSWeb[rowCounts(MSWeb) &gt;10,], 50)
MSWeb10

## simple split with 3 items given
esSplit &lt;- evaluationScheme(MSWeb10, method="split",
        train = 0.9, k=1, given=3)
esSplit

## 4-fold cross-validation with all-but-1 items for learning.
esCross &lt;- evaluationScheme(MSWeb10, method="cross-validation",
        k=4, given=-1)
esCross
</code></pre>

<hr>
<h2 id='evaluationScheme-class'>Class &quot;evaluationScheme&quot;: Evaluation Scheme</h2><span id='topic+evaluationScheme-class'></span><span id='topic+getData'></span><span id='topic+getData+2CevaluationScheme-method'></span><span id='topic+show+2CevaluationScheme-method'></span>

<h3>Description</h3>

<p>An evaluation scheme created from a data set. The scheme can be a simple split into training and test data, k-fold cross-evaluation or using k
bootstrap samples.</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by
<code>evaluationScheme(data, method="split", train=0.9, k=NULL, given=3).</code>
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code>:</dt><dd><p>Object of class <code>"ratingMatrix"</code>; the data set. </p>
</dd>
<dt><code>given</code>:</dt><dd><p>Object of class <code>"integer"</code>; given ratings are
randomly selected for each evaluation user and
presented to the recommender
algorithm to calculate recommend items/ratings.
The recommended items are compared
to the remaining items for the evaluation user.</p>
</dd>
<dt><code>goodRating</code>:</dt><dd><p>Object of class <code>"numeric"</code>; Rating at which an item is considered a positive for evaluation. </p>
</dd>
<dt><code>k</code>:</dt><dd><p>Object of class <code>"integer"</code>; number of runs for evaluation. Default is 1 for method &quot;split&quot; and 10 for &quot;cross-validation&quot; and &quot;bootstrap&quot;.</p>
</dd>
<dt><code>knownData</code>:</dt><dd><p>Object of class <code>"ratingMatrix"</code>; data set with only known (given) items. </p>
</dd>
<dt><code>method</code>:</dt><dd><p>Object of class <code>"character"</code>; evaluation method. Available methods are: &quot;split&quot;, &quot;cross-validation&quot; and &quot;bootstrap&quot;.</p>
</dd>
<dt><code>runsTrain</code>:</dt><dd><p>Object of class <code>"list"</code>; internal repesentation for the split in training and test data for the evaluation runs.</p>
</dd>
<dt><code>train</code>:</dt><dd><p>Object of class <code>"numeric"</code>; portion of data used for training for &quot;split&quot; and &quot;bootstrap&quot;.</p>
</dd>
<dt><code>unknownData</code>:</dt><dd><p>Object of class <code>"ratingMatrix"</code>; data set with only unknown items. </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>getData</dt><dd><p><code>signature(x = "evaluationScheme")</code>: access data.
Parameters are <code>type</code> (&quot;train&quot;, &quot;known&quot; or &quot;unknown&quot;, &quot;given&quot;) and
<code>run</code> (1...k).
<code>"train"</code> returns the training data for the run,
<code>"known"</code> returns the known ratings used for prediction
for the test data,
<code>"unknown"</code> returns the ratings used for evaluation
for the test data, and
<code>"given"</code> returns the number of items that were given in &quot;known.&quot; If the <code>given</code> items
was a positive number, then this will be a vector with this number, but if <code>given</code> was negative (all-but-x),
then the number of given items for each test user will be different.
</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "evaluationScheme")</code> </p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+ratingMatrix-class">ratingMatrix</a></code> and
the creator function <code><a href="#topic+evaluationScheme">evaluationScheme</a></code>.
</p>

<hr>
<h2 id='funkSVD'>Funk SVD for Matrices with Missing Data</h2><span id='topic+funkSVD'></span><span id='topic+predict.funkSVD'></span>

<h3>Description</h3>

<p>Implements matrix decomposition by the stochastic gradient descent optimization popularized by Simon Funk to minimize the error on the known values.
This function is used by the recommender method &quot;SVDF&quot; (see <code><a href="#topic+Recommender">Recommender</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>funkSVD(x, k = 10, gamma = 0.015, lambda = 0.001,
  min_improvement = 1e-06, min_epochs = 50, max_epochs = 200,
  verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funkSVD_+3A_x">x</code></td>
<td>
<p> a matrix, potentially containing NAs.</p>
</td></tr>
<tr><td><code id="funkSVD_+3A_k">k</code></td>
<td>
<p> number of features (i.e, rank of the approximation). </p>
</td></tr>
<tr><td><code id="funkSVD_+3A_gamma">gamma</code></td>
<td>
<p> regularization term. </p>
</td></tr>
<tr><td><code id="funkSVD_+3A_lambda">lambda</code></td>
<td>
<p> learning rate. </p>
</td></tr>
<tr><td><code id="funkSVD_+3A_min_improvement">min_improvement</code></td>
<td>
<p> required minimum improvement per iteration. </p>
</td></tr>
<tr><td><code id="funkSVD_+3A_min_epochs">min_epochs</code></td>
<td>
<p> minimum number of iterations per feature. </p>
</td></tr>
<tr><td><code id="funkSVD_+3A_max_epochs">max_epochs</code></td>
<td>
<p> maximum number of iterations per feature. </p>
</td></tr>
<tr><td><code id="funkSVD_+3A_verbose">verbose</code></td>
<td>
<p> show progress. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Funk SVD decomposes a matrix (with missing values)
into two components <code class="reqn">U</code> and <code class="reqn">V</code>.
The singular values are folded into these matrices.
The approximation
for the original matrix can be obtained by <code class="reqn">R = UV'</code>.
</p>
<p>This function <code>predict</code> in this implementation folds in new data rows
by estimating the <code class="reqn">u</code> vectors using gradient descend and then calculating
the reconstructed complete matrix r for these users via <code class="reqn">r = uV'</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>"funkSVD"</code> with components
</p>
<table>
<tr><td><code>U</code></td>
<td>
<p> the <code class="reqn">U</code> matrix. </p>
</td></tr>
<tr><td><code>V</code></td>
<td>
<p> the <code class="reqn">V</code> matrix. </p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p> a list with parameter values. </p>
</td></tr>
</table>


<h3>Note</h3>

<p>The code is based on the implmentation in package <span class="pkg">rrecsys</span> by
Ludovik Coba and Markus Zanker.
</p>


<h3>References</h3>

<p>Y. Koren, R. Bell, and C. Volinsky. Matrix Factorization Techniques for Recommender Systems, IEEE Computer, pp. 42-49, August 2009.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># this takes a while to run!
## Not run: 
data("Jester5k")

# helper to calculate root mean squared error
rmse &lt;- function(pred, truth) sqrt(sum((truth-pred)^2, na.rm = TRUE))

train &lt;- as(Jester5k[1:100], "matrix")
fsvd &lt;- funkSVD(train, verbose = TRUE)

# reconstruct the original rating matrix as R = UV'
r &lt;- tcrossprod(fsvd$U, fsvd$V)
rmse(train, r)

# fold in new users for matrix completion
test &lt;- as(Jester5k[101:105], "matrix")
p &lt;- predict(fsvd, test, verbose = TRUE)
rmse(test, p)

## End(Not run)
</code></pre>

<hr>
<h2 id='getList'>
List and Data.frame Representation for Recommender Matrix Objects
</h2><span id='topic+getList'></span><span id='topic+getList+2CbinaryRatingMatrix-method'></span><span id='topic+getList+2CrealRatingMatrix-method'></span><span id='topic+getList+2CtopNList-method'></span><span id='topic+getData.frame'></span><span id='topic+getData.frame+2CratingMatrix-method'></span>

<h3>Description</h3>

<p>Create a list or data.frame representation for various objects 
used in <span class="pkg">recommenderlab</span>. These functions are used in addition to
available coercion to allow for parameters like <code>decode</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getList(from, ...)
## S4 method for signature 'realRatingMatrix'
getList(from, decode = TRUE, ratings = TRUE, ...)
## S4 method for signature 'binaryRatingMatrix'
getList(from, decode = TRUE, ...)
## S4 method for signature 'topNList'
getList(from, decode = TRUE, ...)

getData.frame(from, ...)
## S4 method for signature 'ratingMatrix'
getData.frame(from, decode = TRUE, ratings = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getList_+3A_from">from</code></td>
<td>
<p> object to be represented as a list.</p>
</td></tr>
<tr><td><code id="getList_+3A_decode">decode</code></td>
<td>
<p> use item names or item IDs (column numbers) for items? </p>
</td></tr>
<tr><td><code id="getList_+3A_ratings">ratings</code></td>
<td>
<p> include ratings in the list or data.frame?</p>
</td></tr>
<tr><td><code id="getList_+3A_...">...</code></td>
<td>
<p> further arguments (currently unused).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Lists have one vector with items (and ratings) per user. The 
data.frame has one row per rating with the user in the first column,
the item as the second and the rating as the third.
</p>


<h3>Value</h3>

<p>Returns a list or a data.frame.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+binaryRatingMatrix-class">binaryRatingMatrix</a></code>,
<code><a href="#topic+realRatingMatrix-class">realRatingMatrix</a></code>,
<code><a href="#topic+topNList-class">topNList</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Jester5k)

getList(Jester5k[1,])
getData.frame(Jester5k[1,])
</code></pre>

<hr>
<h2 id='HybridRecommender'>
Create a Hybrid Recommender
</h2><span id='topic+HybridRecommender'></span>

<h3>Description</h3>

<p>Creates and combines recommendations using several recommender algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HybridRecommender(..., weights = NULL, aggregation_type = "sum")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HybridRecommender_+3A_...">...</code></td>
<td>
<p> objects of class 'Recommender'. </p>
</td></tr>
<tr><td><code id="HybridRecommender_+3A_weights">weights</code></td>
<td>
<p> weights for the recommenders. The recommenders are equally
weighted by default. </p>
</td></tr>
<tr><td><code id="HybridRecommender_+3A_aggregation_type">aggregation_type</code></td>
<td>
<p> How are the recommendations aggregated. Options are &quot;sum&quot;, &quot;min&quot;, and
&quot;max&quot;. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The hybrid recommender is initialized with a set of pretrained Recommender objects.
Typically, the algorithms are trained using the same training set. If different
training sets are used, then, at least the training sets
need to have the same items in the same order.
</p>
<p>Alternatively, hybrid recommenders can be created using the regular <code>Recommender()</code>
interface. Here <code>method</code> is set to <code>HYBRID</code> and <code>parameter</code> contains
a list with recommenders and weights. recommenders are a list of recommender alorithms,
where each algorithms is represented as a list with elements name (method of the recommender)
and parameters (the algorithms parameters). This method can be used in <code>evaluate()</code>
</p>
<p>For creating recommendations (<code>predict</code>), each recommender algorithm
is used to create ratings. The individual ratings are combined using
a weighted sum where missing ratings are ignored. Weights can be specified in <code>weights</code>.
</p>


<h3>Value</h3>

<p>An object of class 'Recommender'.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Recommender-class">Recommender</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("MovieLense")
MovieLense100 &lt;- MovieLense[rowCounts(MovieLense) &gt;100,]
train &lt;- MovieLense100[1:100]
test &lt;- MovieLense100[101:103]

## mix popular movies with a random recommendations for diversity and
## rerecommend some movies the user liked.
recom &lt;- HybridRecommender(
  Recommender(train, method = "POPULAR"),
  Recommender(train, method = "RANDOM"),
  Recommender(train, method = "RERECOMMEND"),
  weights = c(.6, .1, .3)
  )

recom

getModel(recom)

as(predict(recom, test), "list")

## create a hybrid recommender using the regular Recommender interface.
## This is needed to use hybrid recommenders with evaluate().
recommenders &lt;- list(
  RANDOM = list(name = "POPULAR", param = NULL),
  POPULAR = list(name = "RANDOM", param = NULL),
  RERECOMMEND = list(name = "RERECOMMEND", param = NULL)
)

weights &lt;- c(.6, .1, .3)

recom &lt;- Recommender(train, method = "HYBRID",
  parameter = list(recommenders = recommenders, weights = weights))
recom

as(predict(recom, test), "list")
</code></pre>

<hr>
<h2 id='internalFunctions'>Internal Utility Functions</h2><span id='topic+returnRatings'></span><span id='topic+getParameters'></span>

<h3>Description</h3>

<p>Utility functions used internally by recommender algorithms. See files starting
with <code>RECOM</code> in the package's <code>R</code> directory for examples of usage.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>returnRatings(ratings, newdata,
  type = c("topNList", "ratings", "ratingMatrix"),
  n, randomize = NULL, minRating = NA)

getParameters(defaults, parameter)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="internalFunctions_+3A_ratings">ratings</code></td>
<td>
<p> a realRatingMatrix. </p>
</td></tr>
<tr><td><code id="internalFunctions_+3A_newdata">newdata</code></td>
<td>
<p> a realRatingMatrix. </p>
</td></tr>
<tr><td><code id="internalFunctions_+3A_type">type</code></td>
<td>
<p> type of recommendation to return. </p>
</td></tr>
<tr><td><code id="internalFunctions_+3A_n">n</code></td>
<td>
<p> max. number of entries in the top-N list. </p>
</td></tr>
<tr><td><code id="internalFunctions_+3A_randomize">randomize</code></td>
<td>
<p> randomization factor for producing the top-N list. </p>
</td></tr>
<tr><td><code id="internalFunctions_+3A_minrating">minRating</code></td>
<td>
<p> do not include ratings less than this. </p>
</td></tr>
<tr><td><code id="internalFunctions_+3A_defaults">defaults</code></td>
<td>
<p> list with parameters and default values. </p>
</td></tr>
<tr><td><code id="internalFunctions_+3A_parameter">parameter</code></td>
<td>
<p> list with actual parameters. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>returnRatings</code> is used in the predict function of recommender algorithms
to return different types of recommendations.
</p>
<p><code>getParameters</code> is a helper function which checks parameters for
consistency and provides default values. Used in the Recommender constructor.
</p>

<hr>
<h2 id='Jester5k'>Jester dataset (5k sample)</h2><span id='topic+Jester5k'></span><span id='topic+JesterJokes'></span>

<h3>Description</h3>

<p>The data set contains a sample of 5000 users from the anonymous
ratings data from
the Jester Online Joke Recommender System collected between
April 1999 and May 2003.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Jester5k)</code></pre>


<h3>Format</h3>

<p>The format of <code>Jester5k</code> is: Formal class 'realRatingMatrix' [package &quot;recommenderlab&quot;]
</p>
<p>The format of <code>JesterJokes</code> is: vector of character strings.
</p>


<h3>Details</h3>

<p><code>Jester5k</code> contains a 5000 x 100 rating matrix (5000 users and 100 jokes)
with ratings between -10.00 and +10.00. All selected users have
rated 36 or more jokes.
</p>
<p>The data also contains the actual jokes in <code>JesterJokes</code>.
</p>


<h3>References</h3>

<p>Ken Goldberg, Theresa Roeder, Dhruv Gupta, and  Chris Perkins.
&quot;Eigentaste: A Constant Time Collaborative Filtering Algorithm.&quot;
Information Retrieval, 4(2), 133-151. July 2001.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(Jester5k)
Jester5k

## number of ratings
nratings(Jester5k)

## number of ratings per user
summary(rowCounts(Jester5k))

## rating distribution
hist(getRatings(Jester5k), main="Distribution of ratings")

## 'best' joke with highest average rating
best &lt;- which.max(colMeans(Jester5k))
cat(JesterJokes[best])
</code></pre>

<hr>
<h2 id='MovieLense'>
MovieLense Dataset (100k)
</h2><span id='topic+MovieLense'></span><span id='topic+MovieLenseMeta'></span><span id='topic+MovieLenseUser'></span>

<h3>Description</h3>

<p>The 100k MovieLense
ratings data set. The data was collected through the MovieLens web site
(movielens.umn.edu) during the seven-month period from September 19th,
1997 through April 22nd, 1998.
The data set contains about 100,000 ratings (1-5)
from 943 users on 1664 movies. Movie and user metadata is also provided in <code>MovieLenseMeta</code> and <code>MovieLenseUser</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(MovieLense)</code></pre>


<h3>Format</h3>

<p>The format of <code>MovieLense</code> is an object of class <code>"realRatingMatrix"</code>
</p>
<p>The format of <code>MovieLenseMeta</code> is a data.frame with movie title, year, IMDb URL and indicator variables for 19 genres.
</p>
<p>The format of <code>MovieLenseUser</code> is a data.frame with user age, sex, occupation and zip code.
</p>


<h3>Source</h3>

<p>GroupLens Research, <a href="https://grouplens.org/datasets/movielens/">https://grouplens.org/datasets/movielens/</a>
</p>


<h3>References</h3>

<p>Herlocker, J., Konstan, J., Borchers, A., Riedl, J.. An Algorithmic
Framework for Performing Collaborative Filtering. Proceedings of the
1999 Conference on Research and Development in Information
Retrieval. Aug. 1999.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(MovieLense)
MovieLense

## look at the first few ratings of the first user
head(as(MovieLense[1,], "list")[[1]])

## visualize part of the matrix
image(MovieLense[1:100,1:100])

## number of ratings per user
hist(rowCounts(MovieLense))

## number of ratings per movie
hist(colCounts(MovieLense))

## mean rating (averaged over users)
mean(rowMeans(MovieLense))

## available movie meta information
head(MovieLenseMeta)

## available user meta information
head(MovieLenseUser)
</code></pre>

<hr>
<h2 id='MSWeb'>
Anonymous web data from www.microsoft.com
</h2><span id='topic+MSWeb'></span>

<h3>Description</h3>

<p>Vroots visited by users in a one week timeframe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(MSWeb)</code></pre>


<h3>Format</h3>

<p>The format is: Formal class <code>"binaryRatingMatrix"</code>.
</p>


<h3>Details</h3>

<p>The data was created by sampling and processing the www.microsoft.com logs.
The data records the use of www.microsoft.com by 38000 anonymous,
randomly-selected users. For each user, the data lists all the areas of the web
site (Vroots) that user visited in a one week timeframe in February 1998.
</p>
<p>This dataset contains 32710 valid users and 285 Vroots.
</p>


<h3>Source</h3>

<p>Asuncion, A., Newman, D.J. (2007). UCI Machine Learning Repository, Irvine, CA:
University of California, School of Information and Computer Science.
<a href="https://archive.ics.uci.edu/">https://archive.ics.uci.edu/</a>
</p>


<h3>References</h3>

<p>J. Breese, D. Heckerman., C. Kadie (1998). Empirical Analysis of Predictive
Algorithms for Collaborative Filtering, Proceedings of the Fourteenth
Conference on Uncertainty in Artificial Intelligence, Madison, WI.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(MSWeb)
MSWeb

nratings(MSWeb)

## look at first two users
as(MSWeb[1:2,], "list")

## items per user
hist(rowCounts(MSWeb), main="Distribution of Vroots visited per user")
</code></pre>

<hr>
<h2 id='normalize'>Normalize the ratings</h2><span id='topic+normalize'></span><span id='topic+denormalize'></span><span id='topic+denormalize+2CrealRatingMatrix-method'></span><span id='topic+normalize+2CrealRatingMatrix-method'></span>

<h3>Description</h3>

<p>Provides the generic for normalize/denormalize and 
a method to normalize/denormalize the ratings in a realRatingMatrix.</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalize(x, ...)
## S4 method for signature 'realRatingMatrix'
normalize(x, method="center", row=TRUE)

denormalize(x, ...)
## S4 method for signature 'realRatingMatrix'
denormalize(x, method=NULL, row=NULL, 
    factors=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalize_+3A_x">x</code></td>
<td>
<p>a realRatingMatrix.</p>
</td></tr>
<tr><td><code id="normalize_+3A_method">method</code></td>
<td>
<p>normalization method. Currently &quot;center&quot; or &quot;Z-score&quot;.</p>
</td></tr>
<tr><td><code id="normalize_+3A_row">row</code></td>
<td>
<p>logical; normalize rows (or the columns)?</p>
</td></tr>
<tr><td><code id="normalize_+3A_factors">factors</code></td>
<td>
<p>a list with the factors to be used for denormalizing
(elements are &quot;mean&quot; and &quot;sds&quot;). Usually these are not specified and the
values stored in <code>x</code> are used.</p>
</td></tr>
<tr><td><code id="normalize_+3A_...">...</code></td>
<td>
<p>further arguments (currently unused).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Normalization tries to reduce the individual rating bias by 
row centering the data, i.e., by
subtracting 
from each available rating the mean of the ratings of that user (row). 
Z-score in addition divides by the standard deviation of the row/column.
Normalization can also be done on columns.
</p>
<p>Denormalization reverses normalization. It uses the normalization
information stored in x unless the user specifies method, row and factors.
</p>


<h3>Value</h3>

<p>A normalized realRatingMatrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create a matrix with ratings
m &lt;- matrix(sample(c(NA,0:5),50, replace=TRUE, prob=c(.5,rep(.5/6,6))), 
nrow=5, ncol=10, dimnames = list(users=paste('u', 1:5, sep=''),
items=paste('i', 1:10, sep='')))

## do normalization
r &lt;- as(m, "realRatingMatrix")
r_n1 &lt;- normalize(r) 
r_n2 &lt;- normalize(r, method="Z-score")

r
r_n1
r_n2

## show normalized data
image(r, main="Raw Data")
image(r_n1, main="Centered")
image(r_n2, main="Z-Score Normalization")
</code></pre>

<hr>
<h2 id='plot'>
Plot Evaluation Results
</h2><span id='topic+plot'></span><span id='topic+plot+2CevaluationResults-method'></span><span id='topic+plot+2CevaluationResultList-method'></span>

<h3>Description</h3>

<p>Creates precision-recall or ROC plots for recommender evaluation results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'evaluationResults'
plot(x, y,
        avg = TRUE, add=FALSE, type= "b", annotate = FALSE, ...)
## S4 method for signature 'evaluationResultList'
plot(x, y,
        xlim=NULL, ylim=NULL, col = NULL, pch = NULL, lty = 1,
        avg = TRUE, type = "b", annotate= 0, legend="bottomright", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_+3A_x">x</code></td>
<td>
<p> the object to be plotted.</p>
</td></tr>
<tr><td><code id="plot_+3A_y">y</code></td>
<td>
<p>a character string indicating the type of plot (e.g., &quot;ROC&quot; or &quot;prec/rec&quot;).</p>
</td></tr>
<tr><td><code id="plot_+3A_avg">avg</code></td>
<td>
<p> plot average of runs?</p>
</td></tr>
<tr><td><code id="plot_+3A_add">add</code></td>
<td>
<p> add to a plot?</p>
</td></tr>
<tr><td><code id="plot_+3A_type">type</code></td>
<td>
<p> line type (see <code>plot</code>).</p>
</td></tr>
<tr><td><code id="plot_+3A_annotate">annotate</code></td>
<td>
<p> annotate N (recommendation list size) to plot. </p>
</td></tr>
<tr><td><code id="plot_+3A_xlim">xlim</code>, <code id="plot_+3A_ylim">ylim</code></td>
<td>
<p>plot limits (see <code>plot</code>).</p>
</td></tr>
<tr><td><code id="plot_+3A_col">col</code></td>
<td>
<p> colors (see <code>plot</code>).</p>
</td></tr>
<tr><td><code id="plot_+3A_pch">pch</code></td>
<td>
<p> point symbol to use (see <code>plot</code>).</p>
</td></tr>
<tr><td><code id="plot_+3A_lty">lty</code></td>
<td>
<p> line type (see <code>plot</code>)</p>
</td></tr>
<tr><td><code id="plot_+3A_legend">legend</code></td>
<td>
<p> where to place legend (see <code>legend</code>).</p>
</td></tr>
<tr><td><code id="plot_+3A_...">...</code></td>
<td>
<p> further arguments passed on to <code>plot</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+evaluationResults-class">evaluationResults</a></code>,
<code><a href="#topic+evaluationResultList-class">evaluationResultList</a></code>.
See 
<code><a href="#topic+evaluate">evaluate</a></code> for examples.
</p>

<hr>
<h2 id='predict'>
Predict Recommendations
</h2><span id='topic+predict'></span><span id='topic+predict+2CRecommender-method'></span>

<h3>Description</h3>

<p>Creates recommendations using a recommender model and data about new users.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'Recommender'
predict(object, newdata, n = 10, data=NULL,
    type="topNList", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict_+3A_object">object</code></td>
<td>
<p>a recommender model (class <code>"Recommender"</code>).</p>
</td></tr>
<tr><td><code id="predict_+3A_newdata">newdata</code></td>
<td>
<p>data for active users (class <code>"ratingMatrix"</code>)
or the index of users in the training data to create recommendations for.
If an index is used then some recommender algorithms need to be passed
the training data as argument <code>data</code>. Some algorithms may only support
user indices. </p>
</td></tr>
<tr><td><code id="predict_+3A_n">n</code></td>
<td>
<p> number of recommendations in the top-N list.</p>
</td></tr>
<tr><td><code id="predict_+3A_data">data</code></td>
<td>
<p> training data needed by some recommender algorithms if
<code>newdata</code> is a user index and not user data. </p>
</td></tr>
<tr><td><code id="predict_+3A_type">type</code></td>
<td>
<p> type of recommendation. The default type is
<code>"topNList"</code> which creates
a top-N recommendation list with recommendations.
Some recommenders can also predict ratings with
type <code>"ratings"</code> which returns only predicted ratings with
known ratings represented by <code>NA</code>,
or type <code>"ratingMatrix"</code> which returns a completed rating matrix (Note that
the predicted ratings may differ from the known ratings).</p>
</td></tr>
<tr><td><code id="predict_+3A_...">...</code></td>
<td>
<p>further arguments.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>"topNList"</code> or of other appropriate
classes.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Recommender-class">Recommender</a></code>,
<code><a href="#topic+ratingMatrix-class">ratingMatrix</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("MovieLense")
MovieLense100 &lt;- MovieLense[rowCounts(MovieLense) &gt;100,]
train &lt;- MovieLense100[1:50]

rec &lt;- Recommender(train, method = "POPULAR")
rec

## create top-N recommendations for new users
pre &lt;- predict(rec, MovieLense100[101:102], n = 10)
pre
as(pre, "list")

## predict ratings for new users
pre &lt;- predict(rec, MovieLense100[101:102], type="ratings")
pre
as(pre, "matrix")[,1:10]


## create recommendations using user ids with ids 1..10 in the
## training data
pre &lt;- predict(rec, 1:10 , data = train, n = 10)
pre
as(pre, "list")
</code></pre>

<hr>
<h2 id='ratingMatrix'>Class &quot;ratingMatrix&quot;: Virtual Class for Rating Data</h2><span id='topic+ratingMatrix-class'></span><span id='topic+ratingMatrix'></span><span id='topic+coerce+2CratingMatrix+2Clist-method'></span><span id='topic+coerce+2CratingMatrix+2Cdata.frame-method'></span><span id='topic++5B+2CratingMatrix+2CANY+2CANY+2CANY-method'></span><span id='topic+sample+2CratingMatrix-method'></span><span id='topic+colCounts'></span><span id='topic+colCounts+2CratingMatrix-method'></span><span id='topic+rowCounts'></span><span id='topic+rowCounts+2CratingMatrix-method'></span><span id='topic+colMeans+2CratingMatrix-method'></span><span id='topic+rowMeans+2CratingMatrix-method'></span><span id='topic+dim+2CratingMatrix-method'></span><span id='topic+dimnames+3C-+2CratingMatrix+2Clist-method'></span><span id='topic+dimnames+2CratingMatrix-method'></span><span id='topic+nratings'></span><span id='topic+nratings+2CratingMatrix-method'></span><span id='topic+show+2CratingMatrix-method'></span><span id='topic+image+2CratingMatrix-method'></span><span id='topic+getNormalize'></span><span id='topic+getNormalize+2CratingMatrix-method'></span><span id='topic+getRatings'></span><span id='topic+getRatings+2CratingMatrix-method'></span><span id='topic+hasRating'></span><span id='topic+hasRating+2CratingMatrix-method'></span><span id='topic+getRatingMatrix'></span><span id='topic+getRatingMatrix+2CratingMatrix-method'></span>

<h3>Description</h3>

<p>Defines a common class for rating data.</p>


<h3>Objects from the Class</h3>

<p>A virtual Class: No objects may be created from it.</p>


<h3>Methods</h3>


<dl>
<dt>[</dt><dd><p><code>signature(x = "ratingMatrix", i = "ANY", j = "ANY", drop = "ANY")</code>: subset the rating matrix (<code>drop</code> is ignorred). </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "ratingMatrix", to = "list")</code></p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "ratingMatrix", to = "data.frame")</code>: a data.frame with three columns. Col 1 contains user ids, col 2 contains        item ids and col 3 contains ratings.</p>
</dd>
<dt>colCounts</dt><dd><p><code>signature(x = "ratingMatrix")</code>:  number of ratings per column.</p>
</dd>
<dt>rowCounts</dt><dd><p><code>signature(x = "ratingMatrix")</code>:  number of ratings per row.</p>
</dd>
<dt>colMeans</dt><dd><p><code>signature(x = "ratingMatrix")</code>: column-wise rating means. </p>
</dd>
<dt>rowMeans</dt><dd><p><code>signature(x = "ratingMatrix")</code>: row-wise rating means. </p>
</dd>
<dt>dim</dt><dd><p><code>signature(x = "ratingMatrix")</code>: dimensions of the rating matrix. </p>
</dd>
<dt>dimnames&lt;-</dt><dd><p><code>signature(x = "ratingMatrix", value = "list")</code>: replace dimnames. </p>
</dd>
<dt>dimnames</dt><dd><p><code>signature(x = "ratingMatrix")</code>: retrieve dimnames. </p>
</dd>
<dt>getNormalize</dt><dd><p><code>signature(x = "ratingMatrix")</code>: returns a list with normalization information for the matrix (NULL if data is not normalized). </p>
</dd>
<dt>getRatings</dt><dd><p><code>signature(x = "ratingMatrix")</code>: returns all
ratings in <code>x</code> as a numeric vector. </p>
</dd>
<dt>getRatingMatrix</dt><dd><p><code>signature(x = "ratingMatrix")</code>: returns the ratings as a sparse matrix. The format is different for binary and real rating matices.</p>
</dd>
<dt>hasRating</dt><dd><p><code>signature(x = "ratingMatrix")</code>: returns a sparse logical matrix with TRUE for user-item combinations which have a rating. </p>
</dd>
<dt>image</dt><dd><p><code>signature(x = "ratingMatrix")</code>: plot the matrix. </p>
</dd>
<dt>nratings</dt><dd><p><code>signature(x = "ratingMatrix")</code>: number of ratings in the matrix. </p>
</dd>
<dt>sample</dt><dd><p><code>signature(x = "ratingMatrix")</code>: sample from users (rows). </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "ratingMatrix")</code> </p>
</dd>
</dl>



<h3>See Also</h3>

<p>See implementing classes
<code><a href="#topic+realRatingMatrix-class">realRatingMatrix</a></code>
and
<code><a href="#topic+binaryRatingMatrix-class">binaryRatingMatrix</a></code>.
See <code><a href="#topic+getList">getList</a></code>,
<code><a href="#topic+getData.frame">getData.frame</a></code>,
<code><a href="#topic+similarity">similarity</a></code>,
<code><a href="#topic+dissimilarity">dissimilarity</a></code> and
<code><a href="#topic+dissimilarity">dissimilarity</a></code>.
</p>

<hr>
<h2 id='realRatingMatrix'>Class &quot;realRatingMatrix&quot;: Real-valued Rating Matrix</h2><span id='topic+realRatingMatrix-class'></span><span id='topic+realRatingMatrix'></span><span id='topic+coerce+2Cmatrix+2CrealRatingMatrix-method'></span><span id='topic+coerce+2CrealRatingMatrix+2Cmatrix-method'></span><span id='topic+coerce+2CrealRatingMatrix+2CdgTMatrix-method'></span><span id='topic+coerce+2CdgTMatrix+2CrealRatingMatrix-method'></span><span id='topic+coerce+2CrealRatingMatrix+2CngCMatrix-method'></span><span id='topic+coerce+2CrealRatingMatrix+2CdgCMatrix-method'></span><span id='topic+coerce+2CdgCMatrix+2CrealRatingMatrix-method'></span><span id='topic+coerce+2Cdata.frame+2CrealRatingMatrix-method'></span><span id='topic+coerce+2CrealRatingMatrix+2Cdata.frame-method'></span><span id='topic+rowSds'></span><span id='topic+rowSds+2CrealRatingMatrix-method'></span><span id='topic+colSds'></span><span id='topic+colSds+2CrealRatingMatrix-method'></span><span id='topic+binarize'></span><span id='topic+binarize+2CrealRatingMatrix-method'></span><span id='topic+removeKnownRatings'></span><span id='topic+removeKnownRatings+2CrealRatingMatrix-method'></span><span id='topic++5B+3C-+2CrealRatingMatrix+2CANY+2CANY+2CANY-method'></span><span id='topic+getTopNLists'></span><span id='topic+getTopNLists+2CrealRatingMatrix-method'></span>

<h3>Description</h3>

<p>A matrix containing ratings (typically 1-5 stars, etc.).</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form <code>new("realRatingMatrix", data = m)</code>, where <code>m</code> is sparse matrix of class

<code>dgCMatrix</code> in package <span class="pkg">Matrix</span> 
or by coercion from a regular matrix, a data.frame containing user/item/rating triplets as rows, or
a sparse matrix in triplet form (<code>dgTMatrix</code> in package <span class="pkg">Matrix</span>).
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code>:</dt><dd><p>Object of class

<code>"dgCMatrix"</code>, a sparse matrix
defined in package <span class="pkg">Matrix</span>. Note that this matrix drops NAs instead
of zeroes. Operations on <code>"dgCMatrix"</code> potentially will delete
zeroes.</p>
</dd>
<dt><code>normalize</code>:</dt><dd><p><code>NULL</code> or a list with normalizaton factors. </p>
</dd>
</dl>



<h3>Extends</h3>

<p>Class <code>"<a href="#topic+ratingMatrix-class">ratingMatrix</a>"</code>, directly.
</p>


<h3>Methods</h3>


<dl>
<dt>coerce</dt><dd><p><code>signature(from = "matrix", to = "realRatingMatrix")</code>: Note that
unknown ratings have to be encoded in the matrix as NA and not as 0 (which would mean an actual rating of 0).</p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "realRatingMatrix", to = "matrix")</code></p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "data.frame", to = "realRatingMatrix")</code>:
coercion from a data.frame with three columns.
Col 1 contains user ids, col 2 contains	item ids and
col 3 contains ratings.</p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "realRatingMatrix", to = "data.frame")</code>: produces user/item/rating triplets.</p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "realRatingMatrix", to = "dgTMatrix")</code></p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "dgTMatrix", to = "realRatingMatrix")</code></p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "realRatingMatrix", to = "dgCMatrix")</code></p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "dgCMatrix", to = "realRatingMatrix")</code></p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "realRatingMatrix", to = "ngCMatrix")</code></p>
</dd>
<dt>binarize</dt><dd><p><code>signature(x = "realRatingMatrix")</code>: create a
<code>"binaryRatingMatrix"</code> by setting all ratings larger or equal to
the argument <code>minRating</code> as 1 and all others to 0.</p>
</dd>
<dt>getTopNLists</dt><dd><p><code>signature(x = "realRatingMatrix")</code>: create
top-N lists from the ratings in x. Arguments are
<code>n</code> (defaults to 10),
<code>randomize</code> (default is <code>NULL</code>) and
<code>minRating</code> (default is <code>NA</code>).
Items with a rating below <code>minRating</code> will not be part of the
top-N list. <code>randomize</code> can be used to get diversity in the
predictions by randomly selecting items with a bias to higher rated
items. The bias is introduced by choosing the items with a probability
proportional to the rating <code class="reqn">(r-min(r)+1)^{randomize}</code>.
The larger the value
the more likely it is to get very highly rated items and a negative
value for <code>randomize</code> will select low-rated items. </p>
</dd>
<dt>removeKnownRatings</dt><dd><p><code>signature(x = "realRatingMatrix")</code>: removes
all ratings in <code>x</code> for which ratings are available in
the realRatingMatrix (of same dimensions as <code>x</code>)
passed as the argument <code>known</code>. </p>
</dd>
<dt>rowSds</dt><dd><p><code>signature(x = "realRatingMatrix")</code>: calculate
the standard deviation of ratings for rows (users).</p>
</dd>
<dt>colSds</dt><dd><p><code>signature(x = "realRatingMatrix")</code>: calculate
the standard deviation of ratings for columns (items).</p>
</dd>
</dl>



<h3>See Also</h3>

<p>See <code><a href="#topic+ratingMatrix-class">ratingMatrix</a></code> inherited methods,
<code><a href="#topic+binaryRatingMatrix-class">binaryRatingMatrix</a></code>,
<code><a href="#topic+topNList-class">topNList</a></code>,
<code><a href="#topic+getList">getList</a></code> and <code><a href="#topic+getData.frame">getData.frame</a></code>.
Also see <code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a></code>,
<code><a href="Matrix.html#topic+dgTMatrix-class">dgTMatrix</a></code> and
<code><a href="Matrix.html#topic+nsparseMatrix-classes">ngCMatrix</a></code>
in <span class="pkg">Matrix</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create a matrix with ratings
m &lt;- matrix(sample(c(NA,0:5),100, replace=TRUE, prob=c(.7,rep(.3/6,6))),
	nrow=10, ncol=10, dimnames = list(
	    user=paste('u', 1:10, sep=''),
	    item=paste('i', 1:10, sep='')
    ))
m

## coerce into a realRatingMAtrix
r &lt;- as(m, "realRatingMatrix")
r

## get some information
dimnames(r)
rowCounts(r) ## number of ratings per user
colCounts(r) ## number of ratings per item
colMeans(r) ## average item rating
nratings(r) ## total number of ratings
hasRating(r) ## user-item combinations with ratings

## histogram of ratings
hist(getRatings(r), breaks="FD")

## inspect a subset
image(r[1:5,1:5])

## coerce it back to see if it worked
as(r, "matrix")

## coerce to data.frame (user/item/rating triplets)
as(r, "data.frame")

## binarize into a binaryRatingMatrix with all 4+ rating a 1
b &lt;- binarize(r, minRating=4)
b
as(b, "matrix")
</code></pre>

<hr>
<h2 id='Recommender'>
Create a Recommender Model
</h2><span id='topic+Recommender'></span><span id='topic+recommenderRegistry'></span><span id='topic+Recommender+2CratingMatrix-method'></span><span id='topic+getModel+2CRecommender-method'></span>

<h3>Description</h3>

<p>Learns a recommender model from given data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Recommender(data, ...)
## S4 method for signature 'ratingMatrix'
Recommender(data, method, parameter=NULL)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Recommender_+3A_data">data</code></td>
<td>
<p>training data.</p>
</td></tr>
<tr><td><code id="Recommender_+3A_method">method</code></td>
<td>
<p>a character string defining the recommender method to use
(see details).</p>
</td></tr>
<tr><td><code id="Recommender_+3A_parameter">parameter</code></td>
<td>
<p>parameters for the recommender algorithm.</p>
</td></tr>
<tr><td><code id="Recommender_+3A_...">...</code></td>
<td>
<p>further arguments. </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Recommender uses the registry mechanism from package <span class="pkg">registry</span>
to manage methods. This let's the user easily specify and add new methods.
The registry is called <code>recommenderRegistry</code>. See examples section.
</p>


<h3>Value</h3>

<p>An object of class 'Recommender'.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Recommender-class">Recommender</a></code>,
<code><a href="#topic+ratingMatrix-class">ratingMatrix</a></code>,
<code><a href="#topic+predict">predict</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("MSWeb")
MSWeb10 &lt;- sample(MSWeb[rowCounts(MSWeb) &gt;10,], 100)

rec &lt;- Recommender(MSWeb10, method = "POPULAR")
rec

getModel(rec)

## save and read a recommender model
saveRDS(rec, file = "rec.rds")
rec2 &lt;- readRDS("rec.rds")
rec2
unlink("rec.rds")

## look at registry and a few methods
recommenderRegistry$get_entry_names()

recommenderRegistry$get_entry("POPULAR", dataType = "binaryRatingMatrix")

recommenderRegistry$get_entry("SVD", dataType = "realRatingMatrix")
</code></pre>

<hr>
<h2 id='Recommender-class'>Class &quot;Recommender&quot;: A Recommender Model</h2><span id='topic+Recommender-class'></span><span id='topic+show+2CRecommender-method'></span>

<h3>Description</h3>

<p>Represents a recommender model learned for a given data set
(a rating matrix).</p>


<h3>Objects from the Class</h3>

<p>Objects are created by
the creator function <code>Recommender(data, method, parameter = NULL)</code>
</p>


<h3>Slots</h3>


<dl>
<dt><code>method</code>:</dt><dd><p>Object of class <code>"character"</code>;
used recommendation method.</p>
</dd>
<dt><code>dataType</code>:</dt><dd><p>Object of class <code>"character"</code>;
concrete class of the input data.</p>
</dd>
<dt><code>ntrain</code>:</dt><dd><p>Object of class <code>"integer"</code>;
size of training set. </p>
</dd>
<dt><code>model</code>:</dt><dd><p>Object of class <code>"list"</code>; the model. </p>
</dd>
<dt><code>predict</code>:</dt><dd><p>Object of class <code>"function"</code>; code to compute
a recommendation using the model. </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>getModel</dt><dd><p><code>signature(x = "Recommender")</code>: retrieve the model. </p>
</dd>
<dt>predict</dt><dd><p><code>signature(object = "Recommender")</code>: create
recommendations for new data (argument <code>newdata</code>). </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "Recommender")</code> </p>
</dd>
</dl>



<h3>See Also</h3>

<p>See <code><a href="#topic+Recommender">Recommender</a></code> for the constructor function and
a description of availble methods.
</p>

<hr>
<h2 id='sparseNAMatrix-class'>
Sparse Matrix Representation With NAs Not Explicitly Stored
</h2><span id='topic+dropNA'></span><span id='topic+dropNA2matrix'></span><span id='topic+dropNAis.na'></span>

<h3>Description</h3>

<p>Coerce from and to a
sparse matrix representation where <code>NA</code>s are not explicitly stored.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dropNA(x)
dropNA2matrix(x)
dropNAis.na(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sparseNAMatrix-class_+3A_x">x</code></td>
<td>
<p> a matrix for <code>dropNA()</code>, or a sparse matrix with dropped NA values
for <code>dropNA2matrix()</code> or <code>dropNAis.na()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The representation is based on
the sparse <code>dgCMatrix</code> in <span class="pkg">Matrix</span> but instead of zeros, <code>NA</code>s are dropped.
This is achieved by the following:
</p>

<ul>
<li><p> Zeros are represented with a very small value (<code>.Machine$double.xmin</code>)
so they do not get dropped in the sparse representation.
</p>
</li>
<li><p> NAs are converted to 0 before cercions to <code>dgCMatrix</code> to make them not explicitly stored.
</p>
</li></ul>

<p><b>Caution:</b> Be careful when working with the sparse matrix and sparse matrix operations
(multiplication, addition, etc.) directly.
</p>

<ul>
<li><p> Sparse matrix operations will see 0 where NAs should be.
</p>
</li>
<li><p> Actual zero ratings have a small, but non-zero value (<code>.Machine$double.xmin</code>).
</p>
</li>
<li><p> Sparse matrix operations that can result in a true 0
need to be followed by replacing the 0 with <code>.Machine$double.xmin</code> or other operations
(like subsetting) may drop the 0.
</p>
</li></ul>

<p><code>dropNAis.na()</code> correctly finds NA values in a sparse matrix with dropped NA values, while
<code>is.na()</code> does not work.
</p>
<p><code>dropNA2matrix()</code> converts the sparse representation into a dense matrix. NAs represented by
dropped values are converted to true NAs. Zeros are recovered by using <code>zapsmall()</code> which replaces
small values by 0.
</p>


<h3>Value</h3>

<p>Returns a dgCMatrix or a matrix, respectively.
</p>


<h3>See Also</h3>

<p><code><a href="Matrix.html#topic+dgCMatrix-class">dgCMatrix</a></code> in <span class="pkg">Matrix</span>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>m &lt;- matrix(sample(c(NA,0:5),50, replace=TRUE, prob=c(.5,rep(.5/6,6))),
    nrow=5, ncol=10, dimnames = list(users=paste('u', 1:5, sep=''),
    items=paste('i', 1:10, sep='')))
m

## drop all NAs in the representation. Zeros are represented by very small values.
sparse &lt;- dropNA(m)
sparse

## convert back to matrix
dropNA2matrix(sparse)

## Note: be careful with the sparse representation!
## Do not use is.na, but use
dropNAis.na(sparse)
</code></pre>

<hr>
<h2 id='topNList'>Class &quot;topNList&quot;: Top-N List</h2><span id='topic+topNList-class'></span><span id='topic+topNList'></span><span id='topic+bestN'></span><span id='topic+bestN+2CtopNList-method'></span><span id='topic+coerce+2CtopNList+2CdgTMatrix-method'></span><span id='topic+coerce+2CtopNList+2CdgCMatrix-method'></span><span id='topic+coerce+2CtopNList+2CngCMatrix-method'></span><span id='topic+coerce+2CtopNList+2Cmatrix-method'></span><span id='topic+coerce+2CtopNList+2Clist-method'></span><span id='topic+coerce+2CtopNList+2CrealRatingMatrix-method'></span><span id='topic+colCounts+2CtopNList-method'></span><span id='topic+rowCounts+2CtopNList-method'></span><span id='topic+show+2CtopNList-method'></span><span id='topic+length+2CtopNList-method'></span><span id='topic+removeKnownItems'></span><span id='topic+removeKnownItems+2CtopNList-method'></span><span id='topic+c+2CtopNList-method'></span>

<h3>Description</h3>

<p>Recommendations a Top-N list. </p>


<h3>Objects from the Class</h3>

<p>Objects can be created by
<code>predict</code> with a recommender model and new data. Alternatively,
objects can be created from a realRatingMatrix using
<code><a href="#topic+getTopNLists">getTopNLists</a></code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>ratings</code>:</dt><dd><p>Object of class <code>"list"</code>.
Each element in the list represents a top-N recommendation
(an integer vector) with item IDs (column numbers in the rating
matrix). The items are ordered in each vector.</p>
</dd>
<dt><code>items</code>:</dt><dd><p>Object of class <code>"list"</code> or <code>NULL</code>.
If available, a list of the same structure as <code>items</code> with the
ratings. </p>
</dd>
<dt><code>itemLabels</code>:</dt><dd><p>Object of class <code>"character"</code></p>
</dd>
<dt><code>n</code>:</dt><dd><p>Object of class <code>"integer"</code> specifying the
number of items in each recommendation.
Note that the actual number
on recommended items can be less depending on the data and the
used algorithm.</p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>coerce</dt><dd><p><code>signature(from = "topNList", to = "list")</code>: returns a
list with the items (labels) in the topNList. </p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "topNList", to = "realRatingMatrix")</code>: creates a rating Matrix with entries for the items in the topN list.</p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "topNList", to = "dgTMatrix")</code></p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "topNList", to = "dgCMatrix")</code></p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "topNList", to = "ngCMatrix")</code></p>
</dd>
<dt>coerce</dt><dd><p><code>signature(from = "topNList", to = "matrix")</code>: returns
a dense matrix with the ratings for the top-N items. All other items have a rating of NA.</p>
</dd>
<dt>c</dt><dd><p><code>signature(x = "topNList")</code>: combine several topN lists into a single list. The lists need to be for the same data (i.e., items). </p>
</dd>
<dt>bestN</dt><dd><p><code>signature(x = "topNList")</code>: returns only the best
n recommendations (second argument is <code>n</code> which defaults to 10).
The additional argument <code>minRating</code> can be used to remove all
entries with a rating below this value. </p>
</dd>
<dt>length</dt><dd><p><code>signature(x = "topNList")</code>: for how many users
does this object contain a top-N list? </p>
</dd>
<dt>removeKnownItems</dt><dd><p><code>signature(x = "topNList")</code>:
remove items from the top-N list which are known (have a rating)
for the user given as a ratingMatrix passed on as argument
<code>known</code>. </p>
</dd>
<dt>colCounts</dt><dd><p><code>signature(x = "topNList")</code>: in how many top-N
does each item occur? </p>
</dd>
<dt>rowCounts</dt><dd><p><code>signature(x = "topNList")</code>: number of recommendations per user. </p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "topNList")</code></p>
</dd>
</dl>



<h3>See Also</h3>

<p><code><a href="#topic+evaluate">evaluate</a></code>,
<code><a href="#topic+getList">getList</a></code>,
<code><a href="#topic+realRatingMatrix-class">realRatingMatrix</a></code>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
