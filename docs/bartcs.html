<!DOCTYPE html><html><head><title>Help for package bartcs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bartcs}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bartcs-package'><p>bartcs: Bayesian Additive Regression Trees for Confounder Selection</p></a></li>
<li><a href='#bart'><p>Fit BART models to select confounders and estimate treatment effect</p></a></li>
<li><a href='#count_omp_thread'><p>Count the number of OpenMP threads for parallel computation</p></a></li>
<li><a href='#ihdp'><p>Infant Health and Development Program Data</p></a></li>
<li><a href='#plot.bartcs'><p>Draw plot for <code>bartcs</code> object</p></a></li>
<li><a href='#summary.bartcs'><p>Summary for <code>bartcs</code> object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Bayesian Additive Regression Trees for Confounder Selection</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.2</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit Bayesian Regression Additive Trees (BART) models to
    select true confounders from a large set of potential confounders and
    to estimate average treatment effect. For more information, see Kim et
    al. (2023) &lt;<a href="https://doi.org/10.1111%2Fbiom.13833">doi:10.1111/biom.13833</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/yooyh/bartcs">https://github.com/yooyh/bartcs</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/yooyh/bartcs/issues">https://github.com/yooyh/bartcs/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>coda (&ge; 0.4.0), ggcharts, ggplot2, invgamma, MCMCpack, Rcpp,
rlang, rootSolve, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, microbenchmark, rmarkdown</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-05-01 12:38:45 UTC; yhoon</td>
</tr>
<tr>
<td>Author:</td>
<td>Yeonghoon Yoo [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yeonghoon Yoo &lt;yooyh.stat@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-05-01 13:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bartcs-package'>bartcs: Bayesian Additive Regression Trees for Confounder Selection</h2><span id='topic+bartcs'></span><span id='topic+bartcs-package'></span>

<h3>Description</h3>

<p>Fit Bayesian Regression Additive Trees (BART) models to
select true confounders from a large set of potential confounders and
to estimate average treatment effect. For more information, see
Kim et al. (2023) <a href="https://doi.org/10.1111/biom.13833">doi:10.1111/biom.13833</a>.
</p>


<h3>Details</h3>

<p>Functions in <code>bartcs</code> serve one of three purposes.
</p>

<ol>
<li><p> Functions for fitting: <code>separate_bart()</code> and <code>single_bart()</code>.
</p>
</li>
<li><p> Functions for summary: <code>summary()</code> and <code>plot()</code>.
</p>
</li>
<li><p> Utility function for OpenMP: <code>count_omp_thread()</code>.
</p>
</li></ol>

<p>The code of BART model are based on the 'BART' package by
Sparapani et al. (2021) under the GPL license, with modifications.
The modifications from the <code>BART</code> package include (but are not limited to):
</p>

<ul>
<li><p> Add CHANGE step.
</p>
</li>
<li><p> Add Single and Separate Model.
</p>
</li>
<li><p> Add causal effect estimation.
</p>
</li>
<li><p> Add confounder selection.
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Yeonghoon Yoo <a href="mailto:yooyh.stat@gmail.com">yooyh.stat@gmail.com</a>
</p>


<h3>References</h3>

<p>Sparapani R, Spanbauer C, McCulloch R (2021).
“Nonparametric Machine Learning and Efficient Computation
with Bayesian Additive Regression Trees: The BART R Package.”
<em>Journal of Statistical Software</em>, 97(1), 1–66.
<a href="https://doi.org/10.18637/jss.v097.i01">doi:10.18637/jss.v097.i01</a>
</p>
<p>Kim, C., Tec, M., &amp; Zigler, C. M. (2023).
Bayesian Nonparametric Adjustment of Confounding, <em>Biometrics</em>
<a href="https://doi.org/10.1111/biom.13833">doi:10.1111/biom.13833</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/yooyh/bartcs">https://github.com/yooyh/bartcs</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/yooyh/bartcs/issues">https://github.com/yooyh/bartcs/issues</a>
</p>
</li></ul>


<hr>
<h2 id='bart'>Fit BART models to select confounders and estimate treatment effect</h2><span id='topic+bart'></span><span id='topic+separate_bart'></span><span id='topic+single_bart'></span>

<h3>Description</h3>

<p>Fit Bayesian Regression Additive Trees (BART) models
to select relevant confounders among a large set of potential confounders
and to estimate average treatment effect <code class="reqn">E[Y(1) - Y(0)]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>separate_bart(
  Y, trt, X,
  trt_treated     = 1,
  trt_control     = 0,
  num_tree        = 50,
  num_chain       = 4,
  num_burn_in     = 100,
  num_thin        = 1,
  num_post_sample = 100,
  step_prob       = c(0.28, 0.28, 0.44),
  alpha           = 0.95,
  beta            = 2,
  nu              = 3,
  q               = 0.95,
  dir_alpha       = 5,
  parallel        = FALSE,
  verbose         = TRUE
)

single_bart(
  Y, trt, X,
  trt_treated     = 1,
  trt_control     = 0,
  num_tree        = 50,
  num_chain       = 4,
  num_burn_in     = 100,
  num_thin        = 1,
  num_post_sample = 100,
  step_prob       = c(0.28, 0.28, 0.44),
  alpha           = 0.95,
  beta            = 2,
  nu              = 3,
  q               = 0.95,
  dir_alpha       = 5,
  parallel        = FALSE,
  verbose         = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bart_+3A_y">Y</code></td>
<td>
<p>A vector of outcome values.</p>
</td></tr>
<tr><td><code id="bart_+3A_trt">trt</code></td>
<td>
<p>A vector of treatment values. Binary treatment works for both model
and continuous treatment works for single_bart(). For binary treatment,
use 1 to indicate the treated group and 0 for the control group.</p>
</td></tr>
<tr><td><code id="bart_+3A_x">X</code></td>
<td>
<p>A matrix of potential confounders.</p>
</td></tr>
<tr><td><code id="bart_+3A_trt_treated">trt_treated</code></td>
<td>
<p>Value of <code>trt</code> for the treated group.
The default value is set to 1.</p>
</td></tr>
<tr><td><code id="bart_+3A_trt_control">trt_control</code></td>
<td>
<p>Value of <code>trt</code> for the control group.
The default value is set to 0.</p>
</td></tr>
<tr><td><code id="bart_+3A_num_tree">num_tree</code></td>
<td>
<p>Number of trees in BART model. The default value is set to 100.</p>
</td></tr>
<tr><td><code id="bart_+3A_num_chain">num_chain</code></td>
<td>
<p>Number of MCMC chains.
Need to set <code>num_chain &gt; 1</code> for the Gelman-Rubin diagnostic.
The default value is set to 4.</p>
</td></tr>
<tr><td><code id="bart_+3A_num_burn_in">num_burn_in</code></td>
<td>
<p>Number of MCMC samples to be discarded per chain
as initial burn-in periods.
The default value is set to 100.</p>
</td></tr>
<tr><td><code id="bart_+3A_num_thin">num_thin</code></td>
<td>
<p>Number of thinning per chain.
One in every <code>num_thin</code> samples are selected.
The default value is set to 1.</p>
</td></tr>
<tr><td><code id="bart_+3A_num_post_sample">num_post_sample</code></td>
<td>
<p>Final number of posterior samples per chain.
Number of MCMC iterations per chain is
<code>burn_in + num_thin * num_post_sample</code>.
The default value is set to 100.</p>
</td></tr>
<tr><td><code id="bart_+3A_step_prob">step_prob</code></td>
<td>
<p>A vector of tree alteration probabilities (GROW, PRUNE, CHANGE).
Each alteration is proposed to change the tree structure. <br />
The default setting is <code style="white-space: pre;">&#8288;(0.28, 0.28, 0.44)&#8288;</code>.</p>
</td></tr>
<tr><td><code id="bart_+3A_alpha">alpha</code>, <code id="bart_+3A_beta">beta</code></td>
<td>
<p>Hyperparameters for tree regularization prior.
A terminal node of depth <code>d</code> will split with
probability of <code>alpha * (1 + d)^(-beta)</code>. <br />
The default setting is
<code style="white-space: pre;">&#8288;(alpha, beta) = (0.95, 2)&#8288;</code> from Chipman et al. (2010).</p>
</td></tr>
<tr><td><code id="bart_+3A_nu">nu</code>, <code id="bart_+3A_q">q</code></td>
<td>
<p>Values to calibrate hyperparameter of sigma prior. <br />
The default setting is <code style="white-space: pre;">&#8288;(nu, q) = (3, 0.95)&#8288;</code> from Chipman et al. (2010).</p>
</td></tr>
<tr><td><code id="bart_+3A_dir_alpha">dir_alpha</code></td>
<td>
<p>Hyperparameter of Dirichlet prior for selection probabilities.
The default value is 5.</p>
</td></tr>
<tr><td><code id="bart_+3A_parallel">parallel</code></td>
<td>
<p>If <code>TRUE</code>, model fitting will be parallelized
with respect to <code>N = nrow(X)</code>.
Parallelization is recommended for very high <code>n</code> only.
The default setting is FALSE.</p>
</td></tr>
<tr><td><code id="bart_+3A_verbose">verbose</code></td>
<td>
<p>If <code>TRUE</code>, message will be printed during training.
If <code>FALSE</code>, message will be suppressed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>separate_bart()</code> and <code>single_bart()</code> fit an exposure model and outcome model(s)
for estimating treatment effect with adjustment of confounders
in the presence of a large set of potential confounders (Kim et al. 2023).
</p>
<p>The exposure model <code class="reqn">E[A|X]</code> and the outcome model(s) <code class="reqn">E[Y|A,X]</code> are
linked together with a common Dirichlet prior that accrues
posterior selection probabilities to the corresponding confounders (<code class="reqn">X</code>)
on the basis of association with both the exposure (<code class="reqn">A</code>) and the
outcome (<code class="reqn">Y</code>).
</p>
<p>There is a distinction between fitting separate outcome models for the treated
and control groups and fitting a single outcome model for both groups.
</p>

<ul>
<li> <p><code>separate_bart()</code> specifies two <strong>&quot;separate&quot;</strong> outcome models
for two binary treatment levels.
Thus, it fits three models:
one exposure model and two separate outcome models for <code class="reqn">A = 0, 1</code>.
</p>
</li>
<li> <p><code>single_bart()</code> specifies one <strong>&quot;single&quot;</strong> outcome model.
Thus, it fits two models:
one exposure model and one outcome model for the entire sample.
</p>
</li></ul>

<p>All inferences are made with outcome model(s).
</p>


<h3>Value</h3>

<p>A <code>bartcs</code> object. A list object contains the following components.
</p>
<table>
<tr><td><code>mcmc_list</code></td>
<td>
<p>A <code>mcmc.list</code> object from <span class="pkg">coda</span> package.
<code>mcmc_list</code> contains the following items.</p>
</td></tr>
</table>

<ul>
<li> <p><code>ATE</code>        Posterior sample of average treatment effect <code class="reqn">E[Y(1) - Y(0)]</code>.
</p>
</li>
<li> <p><code>Y1</code>         Posterior sample of potential outcome <code class="reqn">E[Y(1)]</code>.
</p>
</li>
<li> <p><code>Y0</code>         Posterior sample of potential outcome <code class="reqn">E[Y(0)]</code>.
</p>
</li>
<li> <p><code>dir_alpha</code>  Posterior sample of <code>dir_alpha.</code>
</p>
</li>
<li> <p><code>sigma2_out</code> Posterior sample of <code>sigma2</code> in the outcome model.
</p>
</li></ul>

<table>
<tr><td><code>var_prob</code></td>
<td>
<p>Aggregated posterior inclusion probability of each variable.</p>
</td></tr>
<tr><td><code>var_count</code></td>
<td>
<p>Number of selection of each variable in each MCMC iteration.
Its dimension is <code>num_post_sample * ncol(X)</code>.</p>
</td></tr>
<tr><td><code>chains</code></td>
<td>
<p>A list of results from each MCMC chain.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p><code>separate</code> or <code>single</code>.</p>
</td></tr>
<tr><td><code>label</code></td>
<td>
<p>Column names of <code>X</code>.</p>
</td></tr>
<tr><td><code>params</code></td>
<td>
<p>Parameters used in the model.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Chipman, H. A., George, E. I., &amp; McCulloch, R. E. (2010).
BART: Bayesian additive regression trees.
<em>The Annals of Applied Statistics</em>, 4(1), 266-298.
<a href="https://doi.org/10.1214/09-AOAS285">doi:10.1214/09-AOAS285</a>
</p>
<p>Kim, C., Tec, M., &amp; Zigler, C. M. (2023).
Bayesian Nonparametric Adjustment of Confounding, <em>Biometrics</em>
<a href="https://doi.org/10.1111/biom.13833">doi:10.1111/biom.13833</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ihdp, package = "bartcs")
single_bart(
  Y               = ihdp$y_factual,
  trt             = ihdp$treatment,
  X               = ihdp[, 6:30],
  num_tree        = 10,
  num_chain       = 2,
  num_post_sample = 20,
  num_burn_in     = 10,
  verbose         = FALSE
)
separate_bart(
  Y               = ihdp$y_factual,
  trt             = ihdp$treatment,
  X               = ihdp[, 6:30],
  num_tree        = 10,
  num_chain       = 2,
  num_post_sample = 20,
  num_burn_in     = 10,
  verbose         = FALSE
)
</code></pre>

<hr>
<h2 id='count_omp_thread'>Count the number of OpenMP threads for parallel computation</h2><span id='topic+count_omp_thread'></span>

<h3>Description</h3>

<p><code>count_omp_thread()</code> counts the number of OpenMP threads for
parallel computation.
If it returns 1, OpenMP is not viable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_omp_thread()
</code></pre>


<h3>Value</h3>

<p>Number of OpenMP thread(s).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>count_omp_thread()

</code></pre>

<hr>
<h2 id='ihdp'>Infant Health and Development Program Data</h2><span id='topic+ihdp'></span>

<h3>Description</h3>

<p>Infant Health and Development Program (IHDP) is a randomized experiment from
1985 to 1988 which studied the effect of home visits on cognitive test scores
for infants.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ihdp
</code></pre>


<h3>Format</h3>


<dl>
<dt>treatment</dt><dd><p>Given treatment.</p>
</dd>
<dt>y_factual</dt><dd><p>Observed outcome.</p>
</dd>
<dt>y_cfactual</dt><dd><p>Potential outcome given the opposite treatment.</p>
</dd>
<dt>mu0</dt><dd><p>Control conditional means.</p>
</dd>
<dt>mu1</dt><dd><p>Treated conditional means.</p>
</dd>
<dt>X1 ~ X6</dt><dd><p>Confounders with continuous values.</p>
</dd>
<dt>X7 ~ X25</dt><dd><p>Confounders with binary values.</p>
</dd>
</dl>



<h3>Details</h3>

<p>This dataset was first used by Hill (2011), then used by other researchers
(Shalit et al. 2017, Louizos et al. 2017).
</p>


<h3>Source</h3>

<p>Our version of dataset is the dataset used by Louizos et al. (2017).
This is the first realization of 10 generated datasets and you can find
other realizations from
<a href="https://github.com/AMLab-Amsterdam/CEVAE">https://github.com/AMLab-Amsterdam/CEVAE</a>.
</p>


<h3>References</h3>

<p>Hill, J. L. (2011). Bayesian nonparametric modeling for causal inference.
<em>Journal of Computational and Graphical Statistics</em>, 20(1), 217-240.
<a href="https://doi.org/10.1198/jcgs.2010.08162">doi:10.1198/jcgs.2010.08162</a>
</p>
<p>Louizos, C., Shalit, U., Mooij, J. M., Sontag, D., Zemel, R., &amp; Welling, M. (2017).
Causal effect inference with deep latent-variable models.
<em>Advances in neural information processing systems</em>, 30.
<a href="https://doi.org/10.48550/arXiv.1705.08821">doi:10.48550/arXiv.1705.08821</a>
<a href="https://github.com/AMLab-Amsterdam/CEVAE">https://github.com/AMLab-Amsterdam/CEVAE</a>
</p>
<p>Shalit, U., Johansson, F. D., &amp; Sontag, D. (2017, July).
Estimating individual treatment effect: generalization bounds and algorithms.
In <em>International Conference on Machine Learning</em> (pp. 3076-3085). PMLR.
<a href="https://doi.org/10.48550/arXiv.1606.03976">doi:10.48550/arXiv.1606.03976</a>
</p>

<hr>
<h2 id='plot.bartcs'>Draw plot for <code>bartcs</code> object</h2><span id='topic+plot.bartcs'></span>

<h3>Description</h3>

<p>Two options are available:
posterior inclusion probability (PIP) plot and trace plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bartcs'
plot(x, method = NULL, parameter = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bartcs_+3A_x">x</code></td>
<td>
<p>A <code>bartcs</code> object.</p>
</td></tr>
<tr><td><code id="plot.bartcs_+3A_method">method</code></td>
<td>
<p>&quot;<code>pip</code>&quot; for posterior inclusion probability plot
or &quot;<code>trace</code>&quot; for trace plot.</p>
</td></tr>
<tr><td><code id="plot.bartcs_+3A_parameter">parameter</code></td>
<td>
<p>Parameter for traceplot.</p>
</td></tr>
<tr><td><code id="plot.bartcs_+3A_...">...</code></td>
<td>
<p>Additional arguments for PIP plot.
Check <code>?ggcharts::bar_chart</code> for possible arguments.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>PIP plot</h4>

<p>When a posterior sample is sampled during training,
<code>separate_bart()</code> or <code>single_bart()</code> also counts
which variables are included in the model and
compute PIP for each variable.
For <code>bartcs</code> object <code>x</code>,
this is stored in <code>x$var_count</code> and <code>x$var_prob</code> respectively.
<code>plot(method = "pip")</code> uses this information and
draws plot using <code>ggcharts::bar_chart()</code>.
</p>



<h4>Traceplot</h4>

<p>Parameters are recorded for each MCMC iterations.
Parameters include &quot;<code>ATE</code>&quot;, &quot;<code>Y1</code>&quot;, &quot;<code>Y0</code>&quot;, &quot;<code>dir_alpha</code>&quot;,
and either &quot;<code>sigma2_out</code>&quot; from <code>single_bart()</code>
or &quot;<code>sigma2_out1</code>&quot; and &quot;<code>sigma2_out0</code>&quot; from <br />
<code>separate_bart()</code>.
Vertical line indicates burn-in.
</p>



<h3>Value</h3>

<p>A <code>ggplot</code> object of either PIP plot or trace plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(ihdp, package = "bartcs")
x &lt;- single_bart(
  Y               = ihdp$y_factual,
  trt             = ihdp$treatment,
  X               = ihdp[, 6:30],
  num_tree        = 10,
  num_chain       = 2,
  num_post_sample = 20,
  num_burn_in     = 10,
  verbose         = FALSE
)

# PIP plot
plot(x, method = "pip")
plot(x, method = "pip", top_n = 10)
plot(x, method = "pip", threshold = 0.5)
# Check `?ggcharts::bar_chart` for other possible arguments.

# trace plot
plot(x, method = "trace")
plot(x, method = "trace", "Y1")
plot(x, method = "trace", "dir_alpha")

</code></pre>

<hr>
<h2 id='summary.bartcs'>Summary for <code>bartcs</code> object</h2><span id='topic+summary.bartcs'></span>

<h3>Description</h3>

<p>Provide summary for <code>bartcs</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bartcs'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.bartcs_+3A_object">object</code></td>
<td>
<p>A <code>bartcs</code> object.</p>
</td></tr>
<tr><td><code id="summary.bartcs_+3A_...">...</code></td>
<td>
<p>Additional arguments. Not yet supported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summary()</code> provides 95% posterior credible interval for both
aggregated outcome and individual outcomes from each MCMC chain.
</p>


<h3>Value</h3>

<p>Provide list with the following components
</p>
<table>
<tr><td><code>model</code></td>
<td>
<p><code>separate_bart</code> or <code>single_bart</code>.</p>
</td></tr>
<tr><td><code>trt_value</code></td>
<td>
<p>Treatment values for each treatment group:
<code>trt_treated</code> for the treatment group and <code>trt_control</code> for
the control group.</p>
</td></tr>
<tr><td><code>tree_params</code></td>
<td>
<p>Parameters for the tree structure.</p>
</td></tr>
<tr><td><code>chain_params</code></td>
<td>
<p>Parameters for MCMC chains.</p>
</td></tr>
<tr><td><code>outcome</code></td>
<td>
<p>Summary of outcomes from the model. This includes
both aggregated outcome and individual outcomes from each MCMC chain.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>data(ihdp, package = "bartcs")
x &lt;- single_bart(
  Y               = ihdp$y_factual,
  trt             = ihdp$treatment,
  X               = ihdp[, 6:30],
  num_tree        = 10,
  num_chain       = 2,
  num_post_sample = 20,
  num_burn_in     = 10,
  verbose         = FALSE
)
summary(x)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
