<!DOCTYPE html><html lang="en"><head><title>Help for package tsdecomp</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {tsdecomp}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#tsdecomp-package'><p>ARIMA-Model-Based Decomposition of Time Series Data</p></a></li>
<li><a href='#acgf2poly'><p>Change of Variable in the AutoCovariance Generating Function</p></a></li>
<li><a href='#acov2ma'><p>Convert Autocovariances to Coefficients of a Moving Average</p></a></li>
<li><a href='#ARIMAdec'><p>ARIMA-Model-Based Decomposition of Time Series</p></a></li>
<li><a href='#ARMAacov'><p>Compute Theoretical Autocovariances of an ARMA Model</p></a></li>
<li><a href='#canonical.decomposition'><p>Canonical Decomposition</p></a></li>
<li><a href='#compare.acf'><p>Compare ACF of Theoretical, Estimator and Empirical Component</p></a></li>
<li><a href='#filtering'><p>Double-Sided Symmetric Linear Filter</p></a></li>
<li><a href='#partial.fraction'><p>Partial Fraction Decomposition</p></a></li>
<li><a href='#plot.tsdecFilter'><p>Plot Method for <code>tsdecFilter</code> Objects</p></a></li>
<li><a href='#polyeval'><p>Polynomial Operations and Utilities</p></a></li>
<li><a href='#pseudo.spectrum'><p>Pseudo-Spectrum of an ARIMA Model</p></a></li>
<li><a href='#roots.allocation'><p>Allocation of Autoregressive Roots</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Version:</td>
<td>0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2017-01-03</td>
</tr>
<tr>
<td>Title:</td>
<td>Decomposition of Time Series Data</td>
</tr>
<tr>
<td>Description:</td>
<td>ARIMA-model-based decomposition of quarterly and 
 monthly time series data.
 The methodology is developed and described, among others, in 
 Burman (1980) &lt;<a href="https://doi.org/10.2307%2F2982132">doi:10.2307/2982132</a>&gt; and 
 Hillmer and Tiao (1982) &lt;<a href="https://doi.org/10.2307%2F2287770">doi:10.2307/2287770</a>&gt;.</td>
</tr>
<tr>
<td>Author:</td>
<td>Javier López-de-Lacalle &lt;javlacalle@yahoo.es&gt;</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Javier López-de-Lacalle &lt;javlacalle@yahoo.es&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://jalobe.com">https://jalobe.com</a></td>
</tr>
<tr>
<td>Packaged:</td>
<td>2017-01-03 18:34:59 UTC; javlacalle</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2017-01-04 10:56:16</td>
</tr>
</table>
<hr>
<h2 id='tsdecomp-package'>ARIMA-Model-Based Decomposition of Time Series Data</h2><span id='topic+tsdecomp-package'></span><span id='topic+tsdecomp'></span>

<h3>Description</h3>

<p>ARIMA-model-based decomposition of a time series.
</p>


<h3>Details</h3>

<p>The methods implemented in the package are developed and described (among others)
in the references given below. 
The package is mainly intended for annual, quarterly and monthly time series.
The bottom line of the procedure can be summarized as follows.
An ARIMA model is fitted to the observed series. Then the pseudo-spectrum 
of the model is computed and decomposed into partial fractions. 
This gives ARIMA models for the unobserved components 
(e.g., trend, seasonal and irregular), 
which are then used to obtain the weights of double-sided linear filters 
upon which estimates of the components are obtained.
</p>
<p>For practical purposes, the main function provided in the package is 
<code><a href="#topic+ARIMAdec">ARIMAdec</a></code>. This function relies on other 
procedures that implement different stages of the procedure:
<code><a href="#topic+roots.allocation">roots.allocation</a></code>,
<code><a href="#topic+pseudo.spectrum">pseudo.spectrum</a></code>,
<code><a href="#topic+partial.fraction">partial.fraction</a></code>,
<code><a href="#topic+canonical.decomposition">canonical.decomposition</a></code>,
<code><a href="#topic+filtering">filtering</a></code>.
</p>
<p>An introduction to the methodology and the package 
in the form of a vignette is available here:
</p>
<p><a href="https://www.jalobe.com/doc/tsdecomp.pdf">https://www.jalobe.com/doc/tsdecomp.pdf</a>
</p>


<h3>Author(s)</h3>

<p>Javier López-de-Lacalle <a href="mailto:javlacalle@yahoo.es">javlacalle@yahoo.es</a>
</p>
<p><a href="https://jalobe.com">https://jalobe.com</a>
</p>


<h3>References</h3>

<p>Box, G. E. P., Hillmer, S. C. and Tiao, G. C. (1978)
&lsquo;Analysis and Modeling of Seasonal Time Series&rsquo; in 
<em>Seasonal Analysis of Economic Time Series</em>, Editor Zellner, A.
pp. 309-334. U.S. Dept. of Commerce - Bureau of the Census.
<a href="http://www.nber.org/chapters/c3904.pdf">http://www.nber.org/chapters/c3904.pdf</a>
</p>
<p>Brockwell, P. J. and Davis, R. A. (1991) 
<em>Time Series: Theory and Methods</em>, 
Second Edition. Springer.
<a href="http://doi.org/10.1007/978-1-4419-0320-4">doi: 10.1007/978-1-4419-0320-4</a>
</p>
<p>Burman, J. P. (1980) 
&lsquo;Seasonal Adjustment by Signal Extraction&rsquo;.
<em>Journal of the Royal Statistical Society. Series A (General)</em>,
<b>143</b>(3), pp. 321-337.
<a href="http://doi.org/10.2307/2982132">doi: 10.2307/2982132</a>
</p>
<p>Gómez, V. and Maravall, A. (2001)
&lsquo;Programs <span class="pkg">TRAMO</span> and <span class="pkg">SEATS</span>. Instructions for the User (Beta Version: June 1997)&rsquo;.
Ministerio de Economía y Hacienda. Dirección General de Análisis y Programación Presupuestaria,
Working paper SGAPE-97001.
<a href="http://www.bde.es/f/webbde/SES/servicio/Programas_estadisticos_y_econometricos/Programas/ficheros/manualdos.pdf">http://www.bde.es/f/webbde/SES/servicio/Programas_estadisticos_y_econometricos/Programas/ficheros/manualdos.pdf</a>
</p>
<p>Gómez, V. (2015) 
&lsquo;<span class="pkg">SSMMATLAB</span>: A Set of MATLAB Programs for the Statistical Analysis of State Space Models&rsquo;.
<em>Journal of Statistical Software</em>, <b>66</b>(1), pp. 1-37.
<a href="http://doi.org/10.18637/jss.v066.i09">doi: 10.18637/jss.v066.i09</a>
<a href="http://www.sepg.pap.minhap.gob.es/sitios/sepg/en-GB/Presupuestos/Documentacion/Paginas/SSMMATLAB.aspx">http://www.sepg.pap.minhap.gob.es/sitios/sepg/en-GB/Presupuestos/Documentacion/Paginas/SSMMATLAB.aspx</a>
</p>
<p>Hillmer, S. C. and Tiao, G. C. (1982) 
&lsquo;An ARIMA-Model-Based Approach to Seasonal Adjustment&rsquo;.
<em>Journal of the American Statistical Association</em>,
<b>77</b>(377), pp. 63-70.
<a href="http://doi.org/10.1080/01621459.1982.10477767">doi: 10.1080/01621459.1982.10477767</a>
</p>
<p>Maravall, A. and Pierce, D. A. (1987)
&lsquo;A Prototypical Seasonal Adjustment Model&rsquo;.
<em>Journal of Time Series Analysis</em>, <b>8</b>(2), pp.177-193.
<a href="http://doi.org/10.1111/j.1467-9892.1987.tb00431.x">doi: 10.1111/j.1467-9892.1987.tb00431.x</a>
</p>
<p>Planas, C. (1997) 
<em>Applied Time Series Analysis: Modelling, Forecasting, Unobserved Components Analysis and the Wiener-Kolmogorov Filter</em>.
Eurostat: Series E, Methods.
<a href="https://bookshop.europa.eu/en/applied-time-series-analysis-pbCA0897484/">https://bookshop.europa.eu/en/applied-time-series-analysis-pbCA0897484/</a>
</p>
<p>Pollock, D. S. G. (1999)
<em>A Handbook of Time-Series Analysis Signal Processing and Dynamics</em>. 
Academic Press. 
<a href="http://doi.org/10.1016/B978-012560990-6/50002-6">doi: 10.1016/B978-012560990-6/50002-6</a>
</p>

<hr>
<h2 id='acgf2poly'>Change of Variable in the AutoCovariance Generating Function</h2><span id='topic+acgf2poly'></span><span id='topic+poly2acgf'></span><span id='topic+print.tsdecMAroots'></span>

<h3>Description</h3>

<p>Change of variable in the autocovariance generating function (ACGF). 
This transformation allows the pseudo-spectrum to be represented as 
a polynomial liable to be decomposed in partial fractions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acgf2poly(x)
poly2acgf(x, type=c("roots2poly", "acov2ma"), tol = 1e-16, maxiter = 100, 
  init.tol=1e-05, init.maxiter=100)
## S3 method for class 'tsdecMAroots'
print(x, units = c("radians", "degrees", "pi"), digits = 4, echo = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="acgf2poly_+3A_x">x</code></td>
<td>
<p>numeric vector of autocovariances;
for <code>poly2acgf</code>, an object of class <code>tsdecMAroots</code> returned by <code>type="roots2poly"</code></p>
</td></tr>
<tr><td><code id="acgf2poly_+3A_type">type</code></td>
<td>
<p>character string selecting the method to undo the transformation.</p>
</td></tr>
<tr><td><code id="acgf2poly_+3A_tol">tol</code></td>
<td>
<p>convergence tolerance to be used by <code><a href="#topic+acov2ma">acov2ma</a></code>.</p>
</td></tr>
<tr><td><code id="acgf2poly_+3A_maxiter">maxiter</code></td>
<td>
<p>maximum number of iterations allowed in <code><a href="#topic+acov2ma">acov2ma</a></code>.</p>
</td></tr>
<tr><td><code id="acgf2poly_+3A_init.tol">init.tol</code></td>
<td>
<p>convergence tolerance to be used by <code><a href="#topic+acov2ma.init">acov2ma.init</a></code>.</p>
</td></tr>
<tr><td><code id="acgf2poly_+3A_init.maxiter">init.maxiter</code></td>
<td>
<p>maximum number of iterations allowed in <code><a href="#topic+acov2ma.init">acov2ma.init</a></code>.</p>
</td></tr>
<tr><td><code id="acgf2poly_+3A_units">units</code></td>
<td>
<p>character, the units in which the argument of the roots are printed. <code>units="pi"</code> prints the 
argument in radians as multiples of <code class="reqn">\pi</code>.</p>
</td></tr>
<tr><td><code id="acgf2poly_+3A_digits">digits</code></td>
<td>
<p>numeric, the number of significant digits to be used by <code><a href="base.html#topic+print">print</a></code>.</p>
</td></tr>
<tr><td><code id="acgf2poly_+3A_echo">echo</code></td>
<td>
<p>logical, if <code>TRUE</code> the output is printed, otherwise a <code><a href="base.html#topic+invisible">invisible</a></code> 
copy of the matrix summarizing the results obtained by <code>poly2acgf</code> is returned.</p>
</td></tr>
<tr><td><code id="acgf2poly_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="base.html#topic+print">print</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ACGF is defined as a power series where the coefficients are the autocovariances 
<code class="reqn">\gamma_\tau</code>:
</p>
<p style="text-align: center;"><code class="reqn">
\gamma(z) = \gamma_0 + \gamma_1(z+z^{-1}) + \gamma_2(z^2+z^{-2}) + \gamma_3(z^3+z^{-3}) + \cdots</code>
</p>

<p>where <code class="reqn">z</code> is a complex variable.
</p>
<p>Replacing <code class="reqn">z</code> by <code class="reqn">e^{-i\omega}</code> with <code class="reqn">\omega\in[0,2\pi]</code>
yields the spectral density multiplied by <code class="reqn">2\pi</code>.
This gives a power series in the variable <code class="reqn">2\cos(\omega j)</code>
(note that for <code class="reqn">z=e^{-i\omega}</code>, which has unit modulus, 
the inverse <code class="reqn">1/z</code> is the complex-conjugate of <code class="reqn">z</code>):
</p>
<p style="text-align: center;"><code class="reqn">z^j + z^{-j} = \cos(\omega j) + i\sin(\omega j) + \cos(\omega j) - i\sin(\omega j) = 
2\cos(\omega j)\,.</code>
</p>

<p><code>acgf2poly</code> transforms the following expression in the variable <code class="reqn">2\cos(\omega j)</code>:
</p>
<p style="text-align: center;"><code class="reqn">A(2\cos(j\omega)) = a_0 + a_1 2\cos(\omega) + a_2 2\cos(2\omega) + \cdots + a_n 2\cos(n\omega)</code>
</p>

<p>into a polynomial in the variable <code class="reqn">x=2\cos(\omega)</code>:
</p>
<p style="text-align: center;"><code class="reqn">
B(x) = b_0 + b_1 x + b_2 x^2 + \cdots + b_n x^n\,.</code>
</p>

<p><code>poly2acgf</code> recovers the vector of autocovariances by 
undoing the above transformation and computes the coefficients 
and the variance of the innovations of the moving average model 
related to those autocovariances. 
Two methods can be employed.
1) <code>type="acov2ma"</code>: this method recovers the autocovariances 
by undoing the change of variable; then, the the autocovariances 
are converted to the coefficients of a moving average 
by means of <code><a href="#topic+acov2ma">acov2ma</a></code>. 
In the presence of non-invertible roots, 
this method may experience difficulties to converge.
2) <code>type="roots2poly"</code>: this method does not explicitly undo 
the change of variable <code>acgf2poly</code> (i.e., the vector of 
autocovariances is not recovered). Instead, 
the roots of the moving average polynomial <code class="reqn">\theta(L)</code>
are obtained from the polynomial <code class="reqn">\theta(L)\theta(L^{-1})</code>, 
where the coefficients are in terms of the polynomial <code class="reqn">B(x)</code> 
defined above; then, the coefficients of the moving average model are 
computed by means of <code><a href="#topic+roots2poly">roots2poly</a></code>.
</p>


<h3>Value</h3>

<p><code>acgf2poly</code> returns the transformed vector of coefficients.
</p>
<p><code>poly2acgf</code> returns an object of class <code>tsdecMAroots</code>
containing the coefficients and the variance of the 
innovations in the moving average model related to the autocovariances 
underlying the transformed coefficients.
<code>print.tsdecMAroots</code> prints a summary of the results computed 
by <code>poly2acgf</code>.
</p>


<h3>Note</h3>

<p>Method <code>type="roots2poly"</code> in <code>poly2acgf</code> is based on 
algorithm <code>pu2ma</code> in the software SSMMATLAB by Gómez, V. 
URL 
<a href="http://www.sepg.pap.minhap.gob.es/sitios/sepg/en-GB/Presupuestos/Documentacion/Paginas/SSMMATLAB.aspx">http://www.sepg.pap.minhap.gob.es/sitios/sepg/en-GB/Presupuestos/Documentacion/Paginas/SSMMATLAB.aspx</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+acov2ma">acov2ma</a></code>, <code><a href="#topic+roots2poly">roots2poly</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># the matrix 'm' performs the mapping from the original 
# to the transformed coefficients
n &lt;- 30
m &lt;- diag(1, n, n)
n2 &lt;- n - 2
j &lt;- -1
tmp &lt;- seq.int(2, n-1)
for (i in seq.int(3, n-2, 2))
{
  id &lt;- cbind(seq_len(n2),seq.int(i,n))
  m[id] &lt;- j * tmp
  n2 &lt;- n2 - 2
  j &lt;- -1 * j
  tmp &lt;- cumsum(tmp[seq_len(n2)])
}
if (2*floor(n/2) == n) {  # if (n %% 2 == 0)
  m[cbind(seq_len(n2),seq.int(n-1,n))] &lt;- j * tmp 
} else 
  m[1,n] &lt;- j * tmp
m[1:10,1:10]

# equivalence of the original and transformed coefficients,
# example with an ARMA(2,1) model
#
# method 1: compute the spectral density upon the 
# the theoretical autocovariances ('gamma') of the ARMA model
gamma &lt;- ARMAacov(ar=c(0.8,-0.6), ma=0.4, lag.max=n-1)
w &lt;- seq(0, pi, len=length(gamma))
spec1 &lt;- rep(gamma[1], length(w))
for (i in seq_along(w))
{
  z &lt;- 2*cos(w[i] * seq_len(length(gamma)-1))
  spec1[i] &lt;- spec1[i] + sum(gamma[seq.int(2, n)] * z)
}
spec1 &lt;- spec1/(2*pi)
#plot(w, spec1)

# method 2: compute the spectral density upon the 
# transformed coefficients
newcoefs &lt;- m 
spec2 &lt;- rep(newcoefs[1], length(w))
for (i in seq_along(w))
{
  x &lt;- (2*cos(w[i]))^seq_len(n-1)
  spec2[i] &lt;- spec2[i] + sum(newcoefs[seq.int(2, n)] * x)
}
spec2 &lt;- spec2/(2*pi)

# both representations are equivalent
all.equal(spec1, spec2, check.names=FALSE)
#[1] TRUE

# the original coefficients (the autocovariances) 
# can be recovered premultiplying by the inverse of the 
# transformation matrix 'm'
all.equal(c(solve(m) %*% newcoefs), gamma, check.names=FALSE)
#[1] TRUE
</code></pre>

<hr>
<h2 id='acov2ma'>Convert Autocovariances to Coefficients of a Moving Average</h2><span id='topic+acov2ma'></span><span id='topic+acov2ma.init'></span>

<h3>Description</h3>

<p>Convert autocovariances to coefficients of a moving average.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>acov2ma.init(x, tol = 0.00001, maxiter = 100)
acov2ma(x, tol = 1e-16, maxiter = 100, init = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="acov2ma_+3A_x">x</code></td>
<td>
<p>a numeric vector containing the autocovariances.</p>
</td></tr>
<tr><td><code id="acov2ma_+3A_tol">tol</code></td>
<td>
<p>numeric, convergence tolerance.</p>
</td></tr>
<tr><td><code id="acov2ma_+3A_maxiter">maxiter</code></td>
<td>
<p>numeric, maximum number of iterations.</p>
</td></tr>
<tr><td><code id="acov2ma_+3A_init">init</code></td>
<td>
<p>numeric, vector of initial coefficients.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>acov2ma.init</code> is based on procedure (17.35) described in Pollock (1999).
<code>acov2ma</code> is the Newton-Raphson procedure (17.39) 
described in the same reference.
</p>


<h3>Value</h3>

<p>A list containing the vector of coefficients and the variance of the 
innovations in the moving average model; 
convergence code and number of iterations.
</p>


<h3>References</h3>

<p>Pollock, D. S. G. (1999)
<em>A Handbook of Time-Series Analysis Signal Processing and Dynamics</em>. 
Academic Press. Chapter 17.
<a href="http://doi.org/10.1016/B978-012560990-6/50002-6">doi: 10.1016/B978-012560990-6/50002-6</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x &lt;- arima.sim(n=200, model=list(ma=c(0.7,-0.3)))
#sample autocovariances
a &lt;- c(var(x), cov(x[-1], x[-200]), cov(x[-c(1,2)], x[-c(199,200)]))
#inferred coefficients and variance
acov2ma(a, init=acov2ma.init(a, maxit=10)$macoefs)
#compare with maximum-likelihood
arima(x, order=c(2,0,0), include.mean=FALSE)
</code></pre>

<hr>
<h2 id='ARIMAdec'>ARIMA-Model-Based Decomposition of Time Series</h2><span id='topic+ARIMAdec'></span><span id='topic+plot.ARIMAdec'></span><span id='topic+print.ARIMAdec'></span>

<h3>Description</h3>

<p>This is the main function for the ARIMA-model-based decomposition of a time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ARIMAdec(x, mod, width = c(0.035, 0.035), min.modulus = 0.4, 
  extend = 16, drift = FALSE, optim.tol = 1e-04, ...)
## S3 method for class 'ARIMAdec'
print(x, units = c("radians", "degrees", "pi"), digits = 4, ...)
## S3 method for class 'ARIMAdec'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ARIMAdec_+3A_x">x</code></td>
<td>
<p>for <code>ARIMAdec</code>, a univariate time series; 
for <code>plot.ARIMAdec</code> and <code>print.ARIMAdec</code>, 
an object of class <code>ARIMAdec</code> returned by <code>ARIMAdec</code>.</p>
</td></tr>
<tr><td><code id="ARIMAdec_+3A_mod">mod</code></td>
<td>
<p>an object of class <code>Arima</code>. See <code><a href="stats.html#topic+arima">arima</a></code>.</p>
</td></tr>
<tr><td><code id="ARIMAdec_+3A_width">width</code></td>
<td>
<p>numeric of length two, width of the interval of frequencies allocated to the trend 
and the seasonal components (measured in radians). If a numeric of length one is passed as argument, the same 
width is used for both components. See <code><a href="#topic+roots.allocation">roots.allocation</a></code>.</p>
</td></tr>
<tr><td><code id="ARIMAdec_+3A_min.modulus">min.modulus</code></td>
<td>
<p>numeric, minimum modulus of the roots assigned to the trend component. 
See <code><a href="#topic+roots.allocation">roots.allocation</a></code>.</p>
</td></tr>
<tr><td><code id="ARIMAdec_+3A_extend">extend</code></td>
<td>
<p>integer; if greater than zero, the series is extended by means of forecasts 
and backcasts based on the fitted model <code>mod</code>.
See <code><a href="#topic+filtering">filtering</a></code>.</p>
</td></tr>
<tr><td><code id="ARIMAdec_+3A_drift">drift</code></td>
<td>
<p>logical, if <code>TRUE</code> the <code>intercept</code> in the fitted model <code>mod</code> or an 
external regressor named <code>"drift"</code> is treated as a deterministic linear trend.
See <code><a href="#topic+filtering">filtering</a></code>.</p>
</td></tr>
<tr><td><code id="ARIMAdec_+3A_optim.tol">optim.tol</code></td>
<td>
<p>numeric, the convergence tolerance to be used by <code><a href="stats.html#topic+optimize">optimize</a></code>.</p>
</td></tr>
<tr><td><code id="ARIMAdec_+3A_units">units</code></td>
<td>
<p>character, the units in which the argument of the roots are printed. <code>units="pi"</code> prints the 
argument in radians as multiples of <code class="reqn">\pi</code>.</p>
</td></tr>
<tr><td><code id="ARIMAdec_+3A_digits">digits</code></td>
<td>
<p>numeric, the number of significant digits to be used by <code><a href="base.html#topic+print">print</a></code>.</p>
</td></tr>
<tr><td><code id="ARIMAdec_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="#topic+poly2acgf">poly2acgf</a></code> or to 
<code><a href="#topic+plot.tsdecFilter">plot.tsdecFilter</a></code> and <code><a href="base.html#topic+print">print</a></code> methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper to the sequence of calls to 
<code><a href="#topic+roots.allocation">roots.allocation</a></code>, <code><a href="#topic+pseudo.spectrum">pseudo.spectrum</a></code>, 
<code><a href="#topic+canonical.decomposition">canonical.decomposition</a></code> and <code><a href="#topic+filtering">filtering</a></code>.
</p>


<h3>Value</h3>

<p>An object of class <code>ARIMAdec</code> containing the following:
1) <code>ar</code>: the output from <code>{roots.allocation}</code>,
2) <code>spectrum</code>: the output from <code>{pseudo.spectrum}</code>,
3) <code>ma</code>:  the output from <code>{canonical.decomposition}</code>,
4) <code>xextended</code>: the series extended with backcasts and forecasts (if <code>extend &gt; 0</code>),
5) <code>filters</code>: the filters returned by <code>{filtering}</code>,
6) <code>components</code>: the estimated components returned by <code>{filtering}</code>.
</p>


<h3>References</h3>

<p>Burman, J. P. (1980) 
&lsquo;Seasonal Adjustment by Signal Extraction&rsquo;.
<em>Journal of the Royal Statistical Society. Series A (General)</em>,
<b>143</b>(3), pp. 321-337.
<a href="http://doi.org/10.2307/2982132">doi: 10.2307/2982132</a>
</p>
<p>Hillmer, S. C. and Tiao, G. C. (1982) 
&lsquo;An ARIMA-Model-Based Approach to Seasonal Adjustment&rsquo;.
<em>Journal of the American Statistical Association</em>,
<b>77</b>(377), pp. 63-70.
<a href="http://doi.org/10.1080/01621459.1982.10477767">doi: 10.1080/01621459.1982.10477767</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+canonical.decomposition">canonical.decomposition</a></code>,
<code><a href="#topic+filtering">filtering</a></code>,
<code><a href="#topic+pseudo.spectrum">pseudo.spectrum</a></code>,
<code><a href="#topic+roots.allocation">roots.allocation</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Airlines model and monthly data
y &lt;- log(AirPassengers)
fit &lt;- arima(y, order=c(0,1,1), seasonal=list(order=c(0,1,1)))
dec &lt;- ARIMAdec(y, fit, extend=72)
dec
plot(dec)

# JohnsonJohnson quarterly data
y &lt;- log(JohnsonJohnson)
fit &lt;- arima(y, order=c(0,1,1), seasonal=list(order=c(0,1,1)))
dec &lt;- ARIMAdec(y, fit, extend=16)
dec
plot(dec)

# Nile annual data
# this series is better modelled as a level shift at 
# observation 29 and a mean (no ARMA structure),
# here the shift is ignored for illustration of the 
# decomposition of the fitted ARIMA(0,1,1) model
y &lt;- Nile
fit &lt;- arima(y, order=c(0,1,1))
dec &lt;- ARIMAdec(y, fit, extend=72)
dec
plot(dec, overlap.trend=TRUE, args.trend=list(col="blue"))
</code></pre>

<hr>
<h2 id='ARMAacov'>Compute Theoretical Autocovariances of an ARMA Model</h2><span id='topic+ARMAacov'></span>

<h3>Description</h3>

<p>Compute the theoretical autocovariances of an ARMA model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ARMAacov(ar = numeric(0), ma = numeric(0), lag.max = max(p, q + 1), 
  sigma2 = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ARMAacov_+3A_ar">ar</code></td>
<td>
<p>numeric vector of AR coefficients.</p>
</td></tr>
<tr><td><code id="ARMAacov_+3A_ma">ma</code></td>
<td>
<p>numeric vector of MA coefficients.</p>
</td></tr>
<tr><td><code id="ARMAacov_+3A_lag.max">lag.max</code></td>
<td>
<p>integer, maximum lag to be computed. The default is <code>max(p, q+1)</code>,
where <code>p</code> and <code>q</code> are orders of the AR and MA terms,
<code>length(ar)</code> and <code>length(ma)</code>, respectively.
</p>
</td></tr>
<tr><td><code id="ARMAacov_+3A_sigma2">sigma2</code></td>
<td>
<p>numeric, the variance of the innovations.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of autocovariances named by lag order.
</p>


<h3>Note</h3>

<p>Based on <code><a href="stats.html#topic+ARMAacf">ARMAacf</a></code>.
</p>


<h3>References</h3>

<p>Brockwell, P. J. and Davis, R. A. (1991) 
<em>Time Series: Theory and Methods</em>, 
Second Edition. Springer.
<a href="http://doi.org/10.1007/978-1-4419-0320-4">doi: 10.1007/978-1-4419-0320-4</a>
</p>
<p>Pollock, D. S. G. (1999)
<em>A Handbook of Time-Series Analysis Signal Processing and Dynamics</em>. 
Academic Press. Chapter 17.
<a href="http://doi.org/10.1016/B978-012560990-6/50002-6">doi: 10.1016/B978-012560990-6/50002-6</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+ARMAtoMA">ARMAtoMA</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Autocovariances of an ARMA(2,1)
# method 1: using ARMAacov()
a1 &lt;- ARMAacov(ar=c(0.8,-0.6), ma=0.4, lag.max=10)

# method 2: upon the coefficients of the infinite MA representation
psi &lt;- c(1, ARMAtoMA(ar=c(0.8,-0.6), ma=0.4, lag.max=50))
a2 &lt;- c(sum(psi^2), rep(0, length(a1)-1))
for (i in seq_along(a2[-1]))
  a2[i+1] &lt;- sum(psi[seq_len(length(psi)-i)] * psi[-seq_len(i)])

# for a high enough number of 'psi' coefficients
# both methods are equivalent
all.equal(a1, a2, check.names=FALSE)
#[1] TRUE
</code></pre>

<hr>
<h2 id='canonical.decomposition'>Canonical Decomposition</h2><span id='topic+canonical.decomposition'></span><span id='topic+print.tsdecCanDec'></span>

<h3>Description</h3>

<p>Given the partial fraction decomposition of the pseudo-spectrum, 
the canonical decomposition allocates the variance of each component 
so that the variance of the irregular is maximised. 
Then, the coefficients of the numerators in the pseudo-spectrum 
(relationship given in <code><a href="#topic+pseudo.spectrum">pseudo.spectrum</a></code>) 
are converted into the MA coefficients of the model for each component 
by means of <code><a href="#topic+acgf2poly">acgf2poly</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>canonical.decomposition(num.trend, den.trend, 
  num.trans, den.trans, num.seas, den.seas, quotient, optim.tol = 1e-04, ...)
## S3 method for class 'tsdecCanDec'
print(x, units = c("radians", "degrees", "pi"), digits = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="canonical.decomposition_+3A_num.trend">num.trend</code></td>
<td>
<p>numeric vector, the coefficients of the MA polynomial related to 
the trend component in the relationship given in <code><a href="#topic+pseudo.spectrum">pseudo.spectrum</a></code>.</p>
</td></tr>
<tr><td><code id="canonical.decomposition_+3A_den.trend">den.trend</code></td>
<td>
<p>numeric vector, the coefficients of the AR polynomial related to 
the trend component in the relationship given in <code><a href="#topic+pseudo.spectrum">pseudo.spectrum</a></code>.</p>
</td></tr>
<tr><td><code id="canonical.decomposition_+3A_num.trans">num.trans</code></td>
<td>
<p>numeric vector, the coefficients of the MA polynomial related to 
the transitory component in the relationship given in <code><a href="#topic+pseudo.spectrum">pseudo.spectrum</a></code>.</p>
</td></tr>
<tr><td><code id="canonical.decomposition_+3A_den.trans">den.trans</code></td>
<td>
<p>numeric vector, the coefficients of the AR polynomial related to 
the transitory component in the relationship given in <code><a href="#topic+pseudo.spectrum">pseudo.spectrum</a></code>.</p>
</td></tr>
<tr><td><code id="canonical.decomposition_+3A_num.seas">num.seas</code></td>
<td>
<p>numeric vector, the coefficients of the MA polynomial related to 
the seasonal component in the relationship given in <code><a href="#topic+pseudo.spectrum">pseudo.spectrum</a></code>.</p>
</td></tr>
<tr><td><code id="canonical.decomposition_+3A_den.seas">den.seas</code></td>
<td>
<p>numeric vector, the coefficients of the AR polynomial related to 
the seasonal component in the relationship given in <code><a href="#topic+pseudo.spectrum">pseudo.spectrum</a></code>.</p>
</td></tr>
<tr><td><code id="canonical.decomposition_+3A_quotient">quotient</code></td>
<td>
<p>numeric vector, the quotient of the polynomial division of the polynomials 
in the LHS of the relationship given in <code><a href="#topic+pseudo.spectrum">pseudo.spectrum</a></code>.
(Different from zero only when 
the degree of the MA polynomial is equal or higher than the degree of the AR polynomial 
in the fitted model).</p>
</td></tr>
<tr><td><code id="canonical.decomposition_+3A_optim.tol">optim.tol</code></td>
<td>
<p>numeric, the convergence tolerance to be used by <code><a href="stats.html#topic+optimize">optimize</a></code>.</p>
</td></tr>
<tr><td><code id="canonical.decomposition_+3A_units">units</code></td>
<td>
<p>character, the units in which the argument of the roots are printed. <code>units="pi"</code> prints the 
argument in radians as multiples of <code class="reqn">\pi</code>.</p>
</td></tr>
<tr><td><code id="canonical.decomposition_+3A_x">x</code></td>
<td>
<p>an object of class <code>tsdecCanDec</code> returned by <code>canonical.decomposition</code>.</p>
</td></tr>
<tr><td><code id="canonical.decomposition_+3A_digits">digits</code></td>
<td>
<p>numeric, the number of significant digits to be used by <code><a href="base.html#topic+print">print</a></code>.</p>
</td></tr>
<tr><td><code id="canonical.decomposition_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="#topic+poly2acgf">poly2acgf</a></code> or 
<code><a href="base.html#topic+print">print</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>tsdecCanDec</code> containing 
the MA coefficients of the ARIMA models obtained for the unobserved components
(e.g., trend, seasonal) and the variance of the corresponding disturbance terms.
</p>


<h3>References</h3>

<p>Burman, J. P. (1980) 
&lsquo;Seasonal Adjustment by Signal Extraction&rsquo;.
<em>Journal of the Royal Statistical Society. Series A (General)</em>,
<b>143</b>(3), pp. 321-337.
<a href="http://doi.org/10.2307/2982132">doi: 10.2307/2982132</a>.
</p>
<p>Hillmer, S. C. and Tiao, G. C. (1982) 
&lsquo;An ARIMA-Model-Based Approach to Seasonal Adjustment&rsquo;.
<em>Journal of the American Statistical Association</em>,
<b>77</b>(377), pp. 63-70.
<a href="http://doi.org/10.1080/01621459.1982.10477767">doi: 10.1080/01621459.1982.10477767</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+acgf2poly">acgf2poly</a></code>, <code><a href="#topic+pseudo.spectrum">pseudo.spectrum</a></code>, 
<code><a href="stats.html#topic+optimize">optimize</a></code>.
</p>

<hr>
<h2 id='compare.acf'>Compare ACF of Theoretical, Estimator and Empirical Component</h2><span id='topic+compare.acf'></span><span id='topic+plot.tsdecAcf'></span>

<h3>Description</h3>

<p>Compute the AutoCorrelation functions of the following elements: 
the theoretical ARMA model of each component, the estimator for each component, 
the filtered or estimated components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare.acf(x, mod, lag.max = 12, ...)
## S3 method for class 'tsdecAcf'
plot(x, component = c("trend", "transitory", "seasonal"), ci = 0.95, 
  ci.type = c("ma", "white"), ci.class = c("estimator", "theoretical", "empirical"), 
  plot = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compare.acf_+3A_x">x</code></td>
<td>
<p>for <code>compare.acf</code>, an object of class <code><a href="#topic+ARIMAdec">ARIMAdec</a></code>;
for <code>plot.tsdecAcf</code>, an object of class <code>tsdecAcf</code> returned by <code>compare.acf</code>.</p>
</td></tr>
<tr><td><code id="compare.acf_+3A_mod">mod</code></td>
<td>
<p>the object of class <code>Arima</code> decomposed in <code>x</code>. See <code><a href="stats.html#topic+arima">arima</a></code>.</p>
</td></tr>
<tr><td><code id="compare.acf_+3A_lag.max">lag.max</code></td>
<td>
<p>maximum lag at which to calculate the autocorrelations.</p>
</td></tr>
<tr><td><code id="compare.acf_+3A_component">component</code></td>
<td>
<p>a character, the label of the component for which the ACF is to be obtained.</p>
</td></tr>
<tr><td><code id="compare.acf_+3A_ci">ci</code></td>
<td>
<p>coverage probability for confidence interval. If this is zero or negative, 
confidence intervals are not computed</p>
</td></tr>
<tr><td><code id="compare.acf_+3A_ci.type">ci.type</code></td>
<td>
<p>a character, the type of confidence interval. See details.</p>
</td></tr>
<tr><td><code id="compare.acf_+3A_ci.class">ci.class</code></td>
<td>
<p>a character, the element that is taken as reference to computed the 
confidence intervals. Ignored if <code>ci.class='white'</code>.</p>
</td></tr>
<tr><td><code id="compare.acf_+3A_plot">plot</code></td>
<td>
<p>logical, if <code>TRUE</code> the ACF is plotted.</p>
</td></tr>
<tr><td><code id="compare.acf_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="stats.html#topic+acf">acf</a></code> 
and <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ACF is obtained upon the stationary transformation of the models 
for the components and the estimators; i.e.,
non-stationary roots (if any) are removed from the AR polynomials.
The estimated components are also transformed according to the 
polynomials <code>x$ar$polys.nonstationary</code> that render the signals stationary.
</p>
<p>Argument <code>ci.type</code> behaves similarly to the same argument in <code><a href="stats.html#topic+plot.acf">plot.acf</a></code>.
If <code>ci.type = "white"</code>, the confidence bands are fixed to 
<code class="reqn">t_{\alpha/2}/\sqrt(n)</code>, where <code class="reqn">n</code> is the number of observations 
in the fitted model <code>model</code>.
If <code>ci.type = "ma"</code>, confidence bands are obtained upon Bartlett's approximations 
for the standard deviations of the autocorrelations.
</p>


<h3>Value</h3>

<p><code>compare.acf</code> returns the ACF of the components, respectively 
for their theoretical ARMA model, estimator and estimates.
</p>
<p><code>plot.tsdecAcf</code> displays a plot and returns a <code><a href="base.html#topic+invisible">invisible</a></code>
copy of a matrix containing the confidence intervals.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ARIMAdec">ARIMAdec</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Airlines model and monthly data
y &lt;- log(AirPassengers)
fit &lt;- arima(y, order=c(0,1,1), seasonal=list(order=c(0,1,1)))
dec &lt;- ARIMAdec(y, fit, extend=72)
cacf &lt;- compare.acf(x = dec, mod=fit, lag.max=24)
plot(cacf, component="seasonal")
# unexpected discrepancy between the ACF of the estimator and the 
# ACF of the empirical signal
plot(cacf, component="trend")

# Nile time series
y &lt;- Nile
fit &lt;- arima(y, order=c(0,1,1))
dec &lt;- ARIMAdec(y, fit, extend=16)
cacf &lt;- compare.acf(x = dec, mod=fit, lag.max=24)
plot(cacf, component="trend")
</code></pre>

<hr>
<h2 id='filtering'>Double-Sided Symmetric Linear Filter</h2><span id='topic+filtering'></span><span id='topic+dsfilter'></span>

<h3>Description</h3>

<p>Double-sided symmetric linear filter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filtering(x, mod, 
  trend = list(ar=1, ma=1, sigma2=NULL), 
  transitory = list(ar=1, ma=1, sigma2=NULL), 
  seasonal = list(ar=1, ma=1, sigma2=NULL),
  irregular.sigma2 = NULL,
  extend = 16, drift = FALSE)
dsfilter(x, w, mod, extend = 16)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filtering_+3A_x">x</code></td>
<td>
<p>a univariate time series.</p>
</td></tr>
<tr><td><code id="filtering_+3A_mod">mod</code></td>
<td>
<p>an object of class <code>Arima</code>. See <code><a href="stats.html#topic+arima">arima</a></code>.</p>
</td></tr>
<tr><td><code id="filtering_+3A_trend">trend</code></td>
<td>
<p>a list containing the coefficients and variance of the ARIMA model related to the 
trend component.</p>
</td></tr>
<tr><td><code id="filtering_+3A_transitory">transitory</code></td>
<td>
<p>a list containing the coefficients and variance of the ARIMA model related to the 
transitory component.</p>
</td></tr>
<tr><td><code id="filtering_+3A_seasonal">seasonal</code></td>
<td>
<p>a list containing the coefficients and variance of the ARIMA model related to the 
seasonal component.</p>
</td></tr>
<tr><td><code id="filtering_+3A_irregular.sigma2">irregular.sigma2</code></td>
<td>
<p>numeric, variance of the irregular component. If <code>NULL</code>, the 
estimate of the irregular component is not computed.</p>
</td></tr>
<tr><td><code id="filtering_+3A_extend">extend</code></td>
<td>
<p>integer; if greater than zero, the series is extended by means of forecasts 
and backcasts based on the fitted model <code>mod</code>.</p>
</td></tr>
<tr><td><code id="filtering_+3A_drift">drift</code></td>
<td>
<p>logical, if <code>TRUE</code> the <code>intercept</code> in the fitted model <code>mod</code> or an 
external regressor named <code>"drift"</code> is treated as a deterministic linear trend.</p>
</td></tr>
<tr><td><code id="filtering_+3A_w">w</code></td>
<td>
<p>a vector of filter coefficients (one side).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These functions perform the convolution of the time series and the double-sided 
symmetric filter. They perform:
</p>
<p><code>stats::filter(c(rep(0, n-1), x, rep(0, n-1)), </code>
</p>
<p><code>+ filter=c(rev(w[-1]), w), method="convolution", sides=1)</code> 
</p>
<p>where <code>n</code> is <code>length(x)</code>.
</p>
<p>The design of the filter in the ARIMA-model-based decomposition procedure 
relies on the following result. 
The minimum mean squared error estimator of the component
is given by the ACGF of the model:
</p>
<p style="text-align: center;"><code class="reqn">%
\theta(L)x_t = \phi_n(L)\theta_s(L)a_t \,,</code>
</p>

<p>where <code class="reqn">\theta(L)</code> is the MA of the model fitted to the observed data, 
<code class="reqn">\theta_s(L)</code> is the MA of the component (signal) to be estimated 
and <code class="reqn">\phi_n(L)</code> is the product of the AR polynomials 
of the remaining components.
The estimate of the signal, <code class="reqn">\hat{s}_t</code>, is obtained by means of a 
double-sided symmetrical filter where the weights, <code class="reqn">w</code>, are the 
theoretical autocovariances of the model above:
</p>
<p style="text-align: center;"><code class="reqn">%
\hat{s}_t = \sum_{i=-\infty}^\infty w_i x_{t-i} \,.</code>
</p>



<h3>Value</h3>

<p><code>filtering</code> returns a list of class <code>tsdecFilter</code> containing 
the series extended with forecasts (if <code>extend &gt; 0</code>)
(based on the ARMA model given as input),
the weights of one side of the filter for each component 
and the corresponding estimate of the components.
</p>
<p><code>dsfilter</code> returns the filtered time series.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ARIMAdec">ARIMAdec</a></code>, <code><a href="stats.html#topic+filter">filter</a></code>.
</p>

<hr>
<h2 id='partial.fraction'>Partial Fraction Decomposition</h2><span id='topic+partial.fraction'></span>

<h3>Description</h3>

<p>Partial fraction decomposition of the pseudo-spectrum of a fitted ARIMA model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partial.fraction(numerator, den.trend, den.transitory, den.seasonal)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="partial.fraction_+3A_numerator">numerator</code></td>
<td>
<p>numeric vector containing the coefficients of the numerator of the 
ratio of polynomials to be decomposed (numerator in the left-hand-side of the 
relationship given in <code><a href="#topic+pseudo.spectrum">pseudo.spectrum</a></code>).</p>
</td></tr>
<tr><td><code id="partial.fraction_+3A_den.trend">den.trend</code></td>
<td>
<p>numeric vector containing the coefficients of the denominator in 
the partial fraction related to the trend component.</p>
</td></tr>
<tr><td><code id="partial.fraction_+3A_den.transitory">den.transitory</code></td>
<td>
<p>numeric vector containing the coefficients of the denominator in 
the partial fraction related to the transitory component.</p>
</td></tr>
<tr><td><code id="partial.fraction_+3A_den.seasonal">den.seasonal</code></td>
<td>
<p>numeric vector containing the coefficients of the denominator in 
the partial fraction related to the seasonal component.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the system of equations which is solved and 
the numerators of the partial fractions related, respectively, 
to the trend, transitory and seasonal components.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pseudo.spectrum">pseudo.spectrum</a></code>.
</p>

<hr>
<h2 id='plot.tsdecFilter'>Plot Method for <code>tsdecFilter</code> Objects</h2><span id='topic+plot.tsdecFilter'></span>

<h3>Description</h3>

<p>Plot the time series containing the components in a <code>tsdecFilter</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'tsdecFilter'
plot(x, select = colnames(X), 
  overlap.trend = FALSE, args.trend = list(col = "black"),
  set.pars = list(mar = c(0, 3, 0, 3), oma = c(4, 0, 2, 0), mfrow = c(nplot, 1)),
  main = NULL, range.bars = TRUE, ..., 
  col.range = "light gray", 
  args.xlab = list(text = "time", side = 1, line = 2), 
  args.ylab = list(side = 3, adj = 0, line = -1),
  xaxis.line = -0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.tsdecFilter_+3A_x">x</code></td>
<td>
<p>an object of class <code>tsdecFilter</code> returned by <code><a href="#topic+filtering">filtering</a></code>.</p>
</td></tr>
<tr><td><code id="plot.tsdecFilter_+3A_select">select</code></td>
<td>
<p>character vector with the labels of the series to be plot. Allowed values are 
<code>c("observed", "trend", "transitory", "seasonal", "sadj", "irregular")</code>.</p>
</td></tr></table>
<p>,
</p>
<table role = "presentation">
<tr><td><code id="plot.tsdecFilter_+3A_overlap.trend">overlap.trend</code></td>
<td>
<p>logical, if <code>TRUE</code> the trend component is plot over the observed data; 
otherwise, the trend is plot separately.</p>
</td></tr>
<tr><td><code id="plot.tsdecFilter_+3A_args.trend">args.trend</code></td>
<td>
<p>a list containing the arguments to be passed to <code><a href="graphics.html#topic+lines">lines</a></code>. 
If <code>overlap.trend=TRUE</code>, these options are used to plot the trend; otherwise, it is ignored.</p>
</td></tr>
<tr><td><code id="plot.tsdecFilter_+3A_set.pars">set.pars</code></td>
<td>
<p>settings for <code><a href="graphics.html#topic+par">par</a>(.)</code> when setting up the plot.</p>
</td></tr>
<tr><td><code id="plot.tsdecFilter_+3A_main">main</code></td>
<td>
<p>plot main title.</p>
</td></tr>
<tr><td><code id="plot.tsdecFilter_+3A_range.bars">range.bars</code></td>
<td>
<p>logical indicating if each plot should have a bar at
its right side which are of equal heights in user coordinates. 
The same as in <code><a href="stats.html#topic+plot.stl">plot.stl</a></code>.</p>
</td></tr>
<tr><td><code id="plot.tsdecFilter_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="graphics.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="plot.tsdecFilter_+3A_col.range">col.range</code></td>
<td>
<p>colour to be used for the range bars, if plotted.
Note this appears after <code>...</code> and so cannot be abbreviated.</p>
</td></tr>
<tr><td><code id="plot.tsdecFilter_+3A_args.xlab">args.xlab</code></td>
<td>
<p>arguments to be passed to <code><a href="graphics.html#topic+mtext">mtext</a></code> 
when setting the title for the x axis.</p>
</td></tr>
<tr><td><code id="plot.tsdecFilter_+3A_args.ylab">args.ylab</code></td>
<td>
<p>arguments to be passed to <code><a href="graphics.html#topic+mtext">mtext</a></code> 
when setting the title for the y axis.</p>
</td></tr>
<tr><td><code id="plot.tsdecFilter_+3A_xaxis.line">xaxis.line</code></td>
<td>
<p>the number of lines into the margin at which 
the x axis line will be drawn.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is based on <code><a href="stats.html#topic+plot.stl">plot.stl</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+filtering">filtering</a></code>.
</p>

<hr>
<h2 id='polyeval'>Polynomial Operations and Utilities</h2><span id='topic+polydiv'></span><span id='topic+polyeval'></span><span id='topic+polyprod'></span><span id='topic+polystring'></span><span id='topic+roots2poly'></span>

<h3>Description</h3>

<p>Polynomial operations and utilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polystring(x, varchar = "x", brackets = FALSE, ndec = 2, emptychar = "")
polyeval(p, x)
polyprod(x, y, tol = 1.490116e-08) 
polydiv(x, y)
roots2poly(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="polyeval_+3A_x">x</code></td>
<td>
<p>numeric vector containing the coefficients of the polynomial (in increasing order and 
without gaps). For <code>polyeval</code>, this is the point at which the polynomial is to be evaluated.
For <code>roots2poly</code>, this is a numeric vector containing the roots of the polynomial.</p>
</td></tr>
<tr><td><code id="polyeval_+3A_y">y</code></td>
<td>
<p>numeric vector containing the coefficients of the polynomial (in increasing order and 
without gaps).</p>
</td></tr>
<tr><td><code id="polyeval_+3A_p">p</code></td>
<td>
<p>numeric vector containing the coefficients of the polynomial (in increasing order and 
without gaps).</p>
</td></tr>
<tr><td><code id="polyeval_+3A_varchar">varchar</code></td>
<td>
<p>character string, the label to be printed representing the variable of the polynomial, 
defaults to <code>"x"</code>.</p>
</td></tr>
<tr><td><code id="polyeval_+3A_brackets">brackets</code></td>
<td>
<p>logical, if <code>TRUE</code> the polynomial is printed within parentheses.</p>
</td></tr>
<tr><td><code id="polyeval_+3A_ndec">ndec</code></td>
<td>
<p>integer, coefficients are rounded up to this number of decimals.</p>
</td></tr>
<tr><td><code id="polyeval_+3A_emptychar">emptychar</code></td>
<td>
<p>the character string to be printed if the polynomial is empty.</p>
</td></tr>
<tr><td><code id="polyeval_+3A_tol">tol</code></td>
<td>
<p>a numeric, tolerance below which coefficients are set to zero.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>polystring</code> returns a string of a numeric vector in the format of a polynomial.
</p>
<p><code>polyeval</code> evaluates the polynomial defined in the vector of coefficients <code>p</code> 
at the point <code>x</code>.
</p>
<p><code>polyprod</code> performs polynomial multiplication.
</p>
<p><code>polydiv</code> performs polynomial division (returning the quotient and the remainder).
</p>
<p><code>roots2poly</code> computes the coefficients of a polynomial from its roots.
</p>


<h3>Note</h3>

<p><code>polyprod</code> is based on <code><a href="stats.html#topic+convolve">convolve</a></code>; it is equivalent to
<code>convolve(x, rev(y), type="open")</code>.
</p>
<p><code>roots2poly</code> is based on <code>poly.from.zeros()</code> in package <a href="https://CRAN.R-project.org/package=polynom"><span class="pkg">polynom</span></a>.
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+polyroot">polyroot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># print a fitted ARMA model
set.seed(123)
y &lt;- arima.sim(n=120, model=list(ar=c(0.8, -0.3), ma=0.6))
fit &lt;- arima(y, order=c(2,0,1), include.mean=FALSE)
cat(paste0(
polystring(c(1, -fit$model$phi), brackets=TRUE, ndec=3), "y_t = ",
polystring(c(1, fit$model$theta), brackets=TRUE, ndec=3), "e_t\n"))

# convert roots to coefficients
p &lt;- c(1, 0.8, -0.3)
cat(polystring(p))
r &lt;- polyroot(p)
roots2poly(r)
</code></pre>

<hr>
<h2 id='pseudo.spectrum'>Pseudo-Spectrum of an ARIMA Model</h2><span id='topic+pseudo.spectrum'></span><span id='topic+print.tsdecPSP'></span>

<h3>Description</h3>

<p>Compute the polynomials in the numerators of a partial fraction 
decomposition of the pseudo-spectrum in an ARIMA model. 
The polynomials are in terms of the variable <code class="reqn">2\cos\omega</code>, 
with <code class="reqn">\omega\in [0, 2\pi]</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pseudo.spectrum(mod, ar)
## S3 method for class 'tsdecPSP'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pseudo.spectrum_+3A_mod">mod</code></td>
<td>
<p>an object of class <code>Arima</code>, the fitted model.</p>
</td></tr>
<tr><td><code id="pseudo.spectrum_+3A_ar">ar</code></td>
<td>
<p>an object of class <code>tsdecARroots</code> returned by <code><a href="#topic+roots.allocation">roots.allocation</a></code>.</p>
</td></tr>
<tr><td><code id="pseudo.spectrum_+3A_x">x</code></td>
<td>
<p>an object of class <code>tsdecPSP</code> returned by <code>pseudo.spectrum</code>.</p>
</td></tr>
<tr><td><code id="pseudo.spectrum_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="base.html#topic+print">print</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The coefficients of the ARIMA models for each component (e.g., trend, seasonal) 
are obtained from the following relationship.
</p>
<p style="text-align: center;"><code class="reqn">
\sigma^2\frac{\theta(B)\theta(F)}{\phi(B)\phi(F)} = 
\sigma^2_a\frac{\theta_T(B)\theta_T(F)}{\phi_T(B)\phi_T(F)} + 
\sigma^2_b\frac{\theta_S(B)\theta_S(F)}{\phi_S(B)\phi_S(F)} + \sigma^2_e \,,
</code>
</p>

<p>where <code class="reqn">B</code> is the backshift operator and <code class="reqn">F=B^{-1}</code> is the 
forward operator. Each term in the right-hand-side is related to the ARIMA models 
of each one of the unobserved components.
</p>
<p><code>pseudo.spectrum</code> computes the symmetric polynomials of the type 
<code class="reqn">\varphi(B)\varphi(F)</code> for the polynomials in 
the left-hand-side LHS (based on the fitted model) and for the polynomials 
in the denominators of the right-hand-side RHS 
(based on the allocation of roots of the fitted AR polynomial, 
<code><a href="#topic+roots.allocation">roots.allocation</a></code>).
Then coefficients in the numerators of the RHS are obtained 
by means of <code><a href="#topic+partial.fraction">partial.fraction</a></code> .To do so 
the terms in the RHS are multiplied by the denominator in the LHS; 
then, the coefficients of the numerators in the RHS are obtained 
by equating the coefficients of the same order on both sides of 
the relationship (the orders of the unknown polynomials are set 
to one degree lower than those polynomials of the corresponding denominator).
</p>


<h3>Value</h3>

<p>A list of class <code>tsdecPSP</code> containing:
the quotient of the polynomial division (if the degree of the 
numerator in the LHS is equal or higher than the degree of the denominator);
the coefficients of total polynomials (numerator and denominator in the LHS)
and the denominators in the RHS.
</p>


<h3>References</h3>

<p>Burman, J. P. (1980) 
&lsquo;Seasonal Adjustment by Signal Extraction&rsquo;.
<em>Journal of the Royal Statistical Society. Series A (General)</em>,
<b>143</b>(3), pp. 321-337.
<a href="http://doi.org/10.2307/2982132">doi: 10.2307/2982132</a>
</p>
<p>Hillmer, S. C. and Tiao, G. C. (1982) 
&lsquo;An ARIMA-Model-Based Approach to Seasonal Adjustment&rsquo;.
<em>Journal of the American Statistical Association</em>,
<b>77</b>(377), pp. 63-70.
<a href="http://doi.org/10.1080/01621459.1982.10477767">doi: 10.1080/01621459.1982.10477767</a>
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+arima">arima</a></code>, <code><a href="#topic+partial.fraction">partial.fraction</a></code>, 
<code><a href="#topic+roots.allocation">roots.allocation</a></code>.
</p>

<hr>
<h2 id='roots.allocation'>Allocation of Autoregressive Roots</h2><span id='topic+roots.allocation'></span><span id='topic+plot.tsdecARroots'></span><span id='topic+print.tsdecARroots'></span>

<h3>Description</h3>

<p>Allocate the roots of the autoregressive polynomial from a fitted ARIMA model to 
trend, transitory and seasonal components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roots.allocation(x, width = c(0.035, 0.035), min.modulus = 0.4)
## S3 method for class 'tsdecARroots'
plot(x, xlim, ylim, ...)
## S3 method for class 'tsdecARroots'
print(x, units = c("radians", "degrees", "pi"), digits = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="roots.allocation_+3A_x">x</code></td>
<td>
<p>for <code>roots.allocation</code>, an object of class <code>Arima</code> (see <code><a href="stats.html#topic+arima">arima</a></code>);
for <code>print.tsdecARroots</code> and <code>plot.tsdecARroots</code>, an object of class <code>tsdecARroots</code> 
returned by <code>type="roots.allocation"</code>.</p>
</td></tr>
<tr><td><code id="roots.allocation_+3A_width">width</code></td>
<td>
<p>numeric of length two, width of the interval of frequencies allocated to the trend 
and the seasonal components (measured in radians). If a numeric of length one is passed as argument, the same 
width is used for both components.</p>
</td></tr>
<tr><td><code id="roots.allocation_+3A_min.modulus">min.modulus</code></td>
<td>
<p>numeric, minimum modulus of the roots assigned to the trend component.</p>
</td></tr>
<tr><td><code id="roots.allocation_+3A_xlim">xlim</code></td>
<td>
<p>optional numerics, lower and upper limits of the x-axis.</p>
</td></tr>
<tr><td><code id="roots.allocation_+3A_ylim">ylim</code></td>
<td>
<p>optional numerics, lower and upper limits of the y-axis.</p>
</td></tr>
<tr><td><code id="roots.allocation_+3A_units">units</code></td>
<td>
<p>character, the units in which the argument of the roots are printed. <code>units="pi"</code> prints the 
argument in radians as multiples of <code class="reqn">\pi</code>.</p>
</td></tr>
<tr><td><code id="roots.allocation_+3A_digits">digits</code></td>
<td>
<p>numeric, the number of significant digits to be used by <code><a href="base.html#topic+print">print</a></code>.</p>
</td></tr>
<tr><td><code id="roots.allocation_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code><a href="graphics.html#topic+plot">plot</a></code> or <code><a href="base.html#topic+print">print</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The roots related to cycles with frequency within the range [<code class="reqn">0</code>, <code>width[1]</code>] 
are allocated to the trend or transitory component. In particular,if the modulus 
is below <code>min.modulus</code>, then they are are allocated to the transitory component,
otherwise to the trend.
</p>
<p>The seasonal frequencies are defined as <code class="reqn">\omega_j=2\pi j/S</code>, 
for <code class="reqn">j=1,...,S-1</code>, 
where <code class="reqn">S</code> is the periodicity of the data (e.g., <code class="reqn">S=4</code> in quarterly data 
and <code class="reqn">S=12</code> in monthly data).
Roots related to cycles of frequency within the range 
[<code class="reqn">\omega_j - </code><code>seasonal.width</code>, 
<code class="reqn">\omega_j + </code><code>seasonal.width</code>] are
assigned to the seasonal component.
</p>


<h3>Value</h3>

<p><code>roots.allocation</code> returns a list of class <code>tsdecARroots</code>.
<code>plot.tsdecARroots</code> displays the roots in the complex plane and 
<code>print.tsdecARroots</code> shows a summary.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
