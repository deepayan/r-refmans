<!DOCTYPE html><html><head><title>Help for package pgenlibr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {pgenlibr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#AlleleCodeBuf'><p>Returns an empty two-row numeric matrix that ReadAlleles() can load to.</p></a></li>
<li><a href='#BoolBuf'><p>Returns a bool buffer that ReadAlleles() can load phasing information to.</p></a></li>
<li><a href='#Buf'><p>Returns a numeric buffer that Read() or ReadHardcalls() can load to.</p></a></li>
<li><a href='#ClosePgen'><p>Closes a pgen object, releasing resources.</p></a></li>
<li><a href='#ClosePvar'><p>Closes a pvar object, releasing memory.</p></a></li>
<li><a href='#GetAlleleCode'><p>Look up an allele code.</p></a></li>
<li><a href='#GetAlleleCt'><p>Returns the effective number of alleles for a variant.  Note that if no</p>
pvar was provided to the NewPgen() call, this function may return 2 even at
multiallelic variants, since the .pgen may not store allele-count
information.</a></li>
<li><a href='#GetMaxAlleleCt'><p>Returns the maximum GetAlleleCt() value across all variants in the file.</p></a></li>
<li><a href='#GetRawSampleCt'><p>Returns the number of samples in the file.</p></a></li>
<li><a href='#GetVariantCt'><p>Returns the number of variants in the file.</p></a></li>
<li><a href='#GetVariantId'><p>Convert variant index to variant ID string.</p></a></li>
<li><a href='#GetVariantsById'><p>Convert variant ID string to variant index(es).</p></a></li>
<li><a href='#HardcallPhasePresent'><p>Returns whether explicitly phased hardcalls are present.</p></a></li>
<li><a href='#IntAlleleCodeBuf'><p>Returns an empty two-row integer matrix that ReadAlleles() can load to.</p></a></li>
<li><a href='#IntBuf'><p>Returns an integer buffer that ReadHardcalls() can load to.</p></a></li>
<li><a href='#NewPgen'><p>Opens a .pgen or PLINK 1 .bed file.</p></a></li>
<li><a href='#NewPvar'><p>Loads variant IDs and allele codes from a .pvar or .bim file (which can be</p>
compressed with gzip or Zstd).</a></li>
<li><a href='#pgenlibr-package'>
<p>PLINK 2 Binary (.pgen) Reader</p></a></li>
<li><a href='#Read'><p>Loads the variant_numth variant, and then fills buf with numeric dosages</p>
in [0, 2] indicating the dosages of the first ALT (or user-specified)
allele for each sample, with missing values represented by NA.</a></li>
<li><a href='#ReadAlleles'><p>Loads the variant_numth variant, and then fills acbuf with integer allele</p>
codes, where each column of the buffer corresponds to a sample.  An allele
code of 0 corresponds to the REF allele, 1 to the first ALT, 2 to the
second ALT, etc.  Missing hardcalls are represented by a pair of NA codes.</a></li>
<li><a href='#ReadHardcalls'><p>Loads the variant_numth variant, and then fills buf with 0, 1, 2, NA</p>
values indicating the number of copies of the first ALT (or user-specified)
allele each sample has.</a></li>
<li><a href='#ReadIntList'><p>Load hardcalls for multiple variants as an integer matrix.</p></a></li>
<li><a href='#ReadList'><p>Load dosages for multiple variants as a numeric matrix.</p></a></li>
<li><a href='#VariantScores'><p>Compute variant scores.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>PLINK 2 Binary (.pgen) Reader</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.5</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-06-11</td>
</tr>
<tr>
<td>Description:</td>
<td>A thin wrapper over PLINK 2's core libraries which provides an R
    interface for reading .pgen files.  A minimal .pvar loader is also
    included.  Chang et al. (2015) &lt;<a href="https://doi.org/10.1186%2Fs13742-015-0047-8">doi:10.1186/s13742-015-0047-8</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/LGPL-3">LGPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Copyright:</td>
<td>This package includes sources of the libdeflate library
owned by Eric Biggers, sources of the SIMDe library owned by
Evan Nemerson, sources of the Zstd library owned by Meta
Platforms, Inc., and sources of the pgenlib library owned by
Christopher Chang.</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/chrchang/plink-ng/issues">https://github.com/chrchang/plink-ng/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 1.0.1)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-11 19:05:31 UTC; chrchang</td>
</tr>
<tr>
<td>Author:</td>
<td>Christopher Chang [aut, cre],
  Eric Biggers [ctb, cph] (Author of included libdeflate library),
  Yann Collet [ctb] (Author of included Zstd library),
  Meta Platforms, Inc. [cph] (Zstd library),
  Evan Nemerson [ctb, cph] (Author of included SIMDe library),
  Przemyslaw Skibinski [ctb] (Author of included Zstd library),
  Nick Terrell [ctb] (Author of included Zstd library)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christopher Chang &lt;chrchang@alumni.caltech.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-12 18:10:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='AlleleCodeBuf'>Returns an empty two-row numeric matrix that ReadAlleles() can load to.</h2><span id='topic+AlleleCodeBuf'></span>

<h3>Description</h3>

<p>Returns an empty two-row numeric matrix that ReadAlleles() can load to.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>AlleleCodeBuf(pgen)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="AlleleCodeBuf_+3A_pgen">pgen</code></td>
<td>
<p>Object returned by NewPgen().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric matrix with two rows, and appropriate number of columns for
ReadAlleles().
</p>

<hr>
<h2 id='BoolBuf'>Returns a bool buffer that ReadAlleles() can load phasing information to.</h2><span id='topic+BoolBuf'></span>

<h3>Description</h3>

<p>Returns a bool buffer that ReadAlleles() can load phasing information to.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BoolBuf(pgen)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BoolBuf_+3A_pgen">pgen</code></td>
<td>
<p>Object returned by NewPgen().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical vector with appropriate length for ReadAlleles().
</p>

<hr>
<h2 id='Buf'>Returns a numeric buffer that Read() or ReadHardcalls() can load to.</h2><span id='topic+Buf'></span>

<h3>Description</h3>

<p>Returns a numeric buffer that Read() or ReadHardcalls() can load to.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Buf(pgen)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Buf_+3A_pgen">pgen</code></td>
<td>
<p>Object returned by NewPgen().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector with appropriate length for Read() and
ReadHardcalls().
</p>

<hr>
<h2 id='ClosePgen'>Closes a pgen object, releasing resources.</h2><span id='topic+ClosePgen'></span>

<h3>Description</h3>

<p>Closes a pgen object, releasing resources.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ClosePgen(pgen)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ClosePgen_+3A_pgen">pgen</code></td>
<td>
<p>Object returned by NewPgen().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side-effect.
</p>

<hr>
<h2 id='ClosePvar'>Closes a pvar object, releasing memory.</h2><span id='topic+ClosePvar'></span>

<h3>Description</h3>

<p>Closes a pvar object, releasing memory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ClosePvar(pvar)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ClosePvar_+3A_pvar">pvar</code></td>
<td>
<p>Object returned by NewPvar().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for side-effect.
</p>

<hr>
<h2 id='GetAlleleCode'>Look up an allele code.</h2><span id='topic+GetAlleleCode'></span>

<h3>Description</h3>

<p>Look up an allele code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetAlleleCode(pvar, variant_num, allele_num)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetAlleleCode_+3A_pvar">pvar</code></td>
<td>
<p>Object returned by NewPvar().</p>
</td></tr>
<tr><td><code id="GetAlleleCode_+3A_variant_num">variant_num</code></td>
<td>
<p>Variant index (1-based).</p>
</td></tr>
<tr><td><code id="GetAlleleCode_+3A_allele_num">allele_num</code></td>
<td>
<p>Allele index (1-based).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The allele_numth allele code for the variant_numth variant.
allele_num=1 corresponds to the REF allele, allele_num=2 corresponds to the
first ALT allele, allele_num=3 corresponds to the second ALT allele if it
exists and errors out otherwise, etc.
</p>

<hr>
<h2 id='GetAlleleCt'>Returns the effective number of alleles for a variant.  Note that if no
pvar was provided to the NewPgen() call, this function may return 2 even at
multiallelic variants, since the .pgen may not store allele-count
information.</h2><span id='topic+GetAlleleCt'></span>

<h3>Description</h3>

<p>Returns the effective number of alleles for a variant.  Note that if no
pvar was provided to the NewPgen() call, this function may return 2 even at
multiallelic variants, since the .pgen may not store allele-count
information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetAlleleCt(pvar_or_pgen, variant_num)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetAlleleCt_+3A_pvar_or_pgen">pvar_or_pgen</code></td>
<td>
<p>Object returned by NewPvar() or NewPgen().</p>
</td></tr>
<tr><td><code id="GetAlleleCt_+3A_variant_num">variant_num</code></td>
<td>
<p>Variant index (1-based).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>max(2, &lt;number of alleles the variant_numth variant is known to
have&gt;).  Note that if no
</p>

<hr>
<h2 id='GetMaxAlleleCt'>Returns the maximum GetAlleleCt() value across all variants in the file.</h2><span id='topic+GetMaxAlleleCt'></span>

<h3>Description</h3>

<p>Returns the maximum GetAlleleCt() value across all variants in the file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetMaxAlleleCt(pvar_or_pgen)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetMaxAlleleCt_+3A_pvar_or_pgen">pvar_or_pgen</code></td>
<td>
<p>Object returned by NewPvar() or NewPgen().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Maximum GetAlleleCt() value across all variants.
</p>

<hr>
<h2 id='GetRawSampleCt'>Returns the number of samples in the file.</h2><span id='topic+GetRawSampleCt'></span>

<h3>Description</h3>

<p>Returns the number of samples in the file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetRawSampleCt(pgen)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetRawSampleCt_+3A_pgen">pgen</code></td>
<td>
<p>Object returned by NewPgen().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of samples.
</p>

<hr>
<h2 id='GetVariantCt'>Returns the number of variants in the file.</h2><span id='topic+GetVariantCt'></span>

<h3>Description</h3>

<p>Returns the number of variants in the file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetVariantCt(pvar_or_pgen)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetVariantCt_+3A_pvar_or_pgen">pvar_or_pgen</code></td>
<td>
<p>Object returned by NewPvar() or NewPgen().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Number of variants.
</p>

<hr>
<h2 id='GetVariantId'>Convert variant index to variant ID string.</h2><span id='topic+GetVariantId'></span>

<h3>Description</h3>

<p>Convert variant index to variant ID string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetVariantId(pvar, variant_num)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetVariantId_+3A_pvar">pvar</code></td>
<td>
<p>Object returned by NewPvar().</p>
</td></tr>
<tr><td><code id="GetVariantId_+3A_variant_num">variant_num</code></td>
<td>
<p>Variant index (1-based).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The variant_numth variant ID string.
</p>

<hr>
<h2 id='GetVariantsById'>Convert variant ID string to variant index(es).</h2><span id='topic+GetVariantsById'></span>

<h3>Description</h3>

<p>Convert variant ID string to variant index(es).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GetVariantsById(pvar, id)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GetVariantsById_+3A_pvar">pvar</code></td>
<td>
<p>Object returned by NewPvar().</p>
</td></tr>
<tr><td><code id="GetVariantsById_+3A_id">id</code></td>
<td>
<p>Variant ID to look up.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of all (1-based) variant indices with the given variant ID.
</p>

<hr>
<h2 id='HardcallPhasePresent'>Returns whether explicitly phased hardcalls are present.</h2><span id='topic+HardcallPhasePresent'></span>

<h3>Description</h3>

<p>Returns whether explicitly phased hardcalls are present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>HardcallPhasePresent(pgen)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="HardcallPhasePresent_+3A_pgen">pgen</code></td>
<td>
<p>Object returned by NewPgen().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if the file contains at least one phased heterozygous
hardcall, FALSE otherwise.
</p>

<hr>
<h2 id='IntAlleleCodeBuf'>Returns an empty two-row integer matrix that ReadAlleles() can load to.</h2><span id='topic+IntAlleleCodeBuf'></span>

<h3>Description</h3>

<p>Returns an empty two-row integer matrix that ReadAlleles() can load to.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IntAlleleCodeBuf(pgen)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IntAlleleCodeBuf_+3A_pgen">pgen</code></td>
<td>
<p>Object returned by NewPgen().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer matrix with two rows, and appropriate number of columns for
ReadAlleles().
</p>

<hr>
<h2 id='IntBuf'>Returns an integer buffer that ReadHardcalls() can load to.</h2><span id='topic+IntBuf'></span>

<h3>Description</h3>

<p>Returns an integer buffer that ReadHardcalls() can load to.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IntBuf(pgen)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IntBuf_+3A_pgen">pgen</code></td>
<td>
<p>Object returned by NewPgen().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer vector with appropriate length for ReadHardcalls().
</p>

<hr>
<h2 id='NewPgen'>Opens a .pgen or PLINK 1 .bed file.</h2><span id='topic+NewPgen'></span>

<h3>Description</h3>

<p>Opens a .pgen or PLINK 1 .bed file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NewPgen(filename, pvar = NULL, raw_sample_ct = NULL, sample_subset = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NewPgen_+3A_filename">filename</code></td>
<td>
<p>.pgen/.bed file path.</p>
</td></tr>
<tr><td><code id="NewPgen_+3A_pvar">pvar</code></td>
<td>
<p>Object (see NewPvar()) corresponding to the .pgen's companion
.pvar; technically optional, but necessary for some functionality.  In
particular, at multiallelic variants, all ALT alleles may be collapsed
together when .pvar information is not available.</p>
</td></tr>
<tr><td><code id="NewPgen_+3A_raw_sample_ct">raw_sample_ct</code></td>
<td>
<p>Number of samples in file; required if it's a PLINK 1
.bed file, otherwise optional.</p>
</td></tr>
<tr><td><code id="NewPgen_+3A_sample_subset">sample_subset</code></td>
<td>
<p>List of 1-based positions of samples to load;
optional, all samples are loaded if this is not specified.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A pgen object, which can be queried for genotype/dosage data.
</p>

<hr>
<h2 id='NewPvar'>Loads variant IDs and allele codes from a .pvar or .bim file (which can be
compressed with gzip or Zstd).</h2><span id='topic+NewPvar'></span>

<h3>Description</h3>

<p>Loads variant IDs and allele codes from a .pvar or .bim file (which can be
compressed with gzip or Zstd).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NewPvar(filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NewPvar_+3A_filename">filename</code></td>
<td>
<p>.pvar/.bim file path.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A pvar object, which can be queried for variant IDs and allele
codes.
</p>

<hr>
<h2 id='pgenlibr-package'>
PLINK 2 Binary (.pgen) Reader
</h2><span id='topic+pgenlibr-package'></span><span id='topic+pgenlibr'></span>

<h3>Description</h3>

<p>A thin wrapper over PLINK 2's core libraries which provides an R interface
for reading .pgen files.  A minimal .pvar loader is also included.
</p>


<h3>Details</h3>

<p><code>NewPvar</code> and <code>NewPgen</code> initialize the respective readers.  Then,
you can either iterate through one variant at a time (<code>Read</code>,
<code>ReadAlleles</code>) or perform a multi-variant matrix load
(<code>ReadIntList</code>, <code>ReadList</code>).  When you're done, <code>ClosePgen</code>
and <code>ClosePvar</code> free resources.
</p>


<h3>Author(s)</h3>

<p>Christopher Chang <a href="mailto:chrchang@alumni.caltech.edu">chrchang@alumni.caltech.edu</a>
</p>


<h3>References</h3>

<p>Chang, C.C. and Chow, C.C. and Tellier, L.C.A.M. and Vattikuti, S. and
Purcell, S.M. and Lee J.J. (2015) Second-generation PLINK: rising to the
challenge of larger and richer datasets.  <em>Gigascience</em> 4:7.
<a href="https://doi.org/10.1186/s13742-015-0047-8">doi:10.1186/s13742-015-0047-8</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # This is modified from https://yosuketanigawa.com/posts/2020/09/PLINK2 .
  library(pgenlibr)

  # These files are subsetted from downloads available at
  #   https://www.cog-genomics.org/plink/2.0/resources#phase3_1kg .
  # Note that, after downloading the original files, the .pgen file must be
  # decompressed before use; but both pgenlibr and the PLINK 2 program can
  # handle compressed .pvar files.
  pvar_path &lt;- system.file("extdata", "chr21_phase3_start.pvar.zst", package="pgenlibr")
  pgen_path &lt;- system.file("extdata", "chr21_phase3_start.pgen", package="pgenlibr")

  pvar &lt;- pgenlibr::NewPvar(pvar_path)
  pgen &lt;- pgenlibr::NewPgen(pgen_path, pvar=pvar)

  # Check the number of variants and samples.
  pgenlibr::GetVariantCt(pgen)
  pgenlibr::GetRawSampleCt(pgen)

  # Get the ID of the first variant.
  GetVariantId(pvar, 1)

  # Read the 14th variant.
  buf &lt;- pgenlibr::Buf(pgen)
  pgenlibr::Read(pgen, buf, 14)

  # Get the index of the variant with ID "rs569225703".
  var_id &lt;- pgenlibr::GetVariantsById(pvar, "rs569225703")

  # Get allele count.
  pgenlibr::GetAlleleCt(pvar, var_id)

  # It has three alleles, i.e. two ALT alleles.
  # Read first-ALT-allele dosages for that variant.
  pgenlibr::Read(pgen, buf, var_id)

  # Read second-ALT-allele dosages.
  pgenlibr::Read(pgen, buf, var_id, allele_num=3)

  # Read a matrix with both variants.  Note that, for the multiallelic variant,
  # the dosages of both ALT alleles are summed here.
  geno_mat &lt;- pgenlibr::ReadList(pgen, c(14, var_id))

  pgenlibr::ClosePgen(pgen)
  pgenlibr::ClosePvar(pvar)
</code></pre>

<hr>
<h2 id='Read'>Loads the variant_numth variant, and then fills buf with numeric dosages
in [0, 2] indicating the dosages of the first ALT (or user-specified)
allele for each sample, with missing values represented by NA.</h2><span id='topic+Read'></span>

<h3>Description</h3>

<p>This function treats the data as diploid; divide by 2 to obtain haploid
dosages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Read(pgen, buf, variant_num, allele_num = 2L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Read_+3A_pgen">pgen</code></td>
<td>
<p>Object returned by NewPgen().</p>
</td></tr>
<tr><td><code id="Read_+3A_buf">buf</code></td>
<td>
<p>Buffer returned by Buf().</p>
</td></tr>
<tr><td><code id="Read_+3A_variant_num">variant_num</code></td>
<td>
<p>Variant index (1-based).</p>
</td></tr>
<tr><td><code id="Read_+3A_allele_num">allele_num</code></td>
<td>
<p>Allele index; 1 corresponds to REF, 2 to the first ALT
allele, 3 to the second ALT allele if it exists, etc.  Optional, defaults
2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for buf-filling side-effect.
</p>

<hr>
<h2 id='ReadAlleles'>Loads the variant_numth variant, and then fills acbuf with integer allele
codes, where each column of the buffer corresponds to a sample.  An allele
code of 0 corresponds to the REF allele, 1 to the first ALT, 2 to the
second ALT, etc.  Missing hardcalls are represented by a pair of NA codes.</h2><span id='topic+ReadAlleles'></span>

<h3>Description</h3>

<p>This function treats the data as diploid.  If it's really haploid, you may
want to compare the two rows, and then treat samples where the allele codes
differ as missing values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadAlleles(pgen, acbuf, variant_num, phasepresent_buf = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ReadAlleles_+3A_pgen">pgen</code></td>
<td>
<p>Object returned by NewPgen().</p>
</td></tr>
<tr><td><code id="ReadAlleles_+3A_acbuf">acbuf</code></td>
<td>
<p>Buffer returned by AlleleCodeBuf() or IntAlleleCodeBuf().</p>
</td></tr>
<tr><td><code id="ReadAlleles_+3A_variant_num">variant_num</code></td>
<td>
<p>Variant index (1-based).</p>
</td></tr>
<tr><td><code id="ReadAlleles_+3A_phasepresent_buf">phasepresent_buf</code></td>
<td>
<p>Buffer returned by BoolBuf().  Optional; if
provided, elements are set to true when the sample has known phase.  Most
of these values will be TRUE even when the raw data is unphased, because
homozygous genotypes always have known phase.  (Missing genotypes are
considered to have unknown phase.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for acbuf-filling side-effect.
</p>

<hr>
<h2 id='ReadHardcalls'>Loads the variant_numth variant, and then fills buf with 0, 1, 2, NA
values indicating the number of copies of the first ALT (or user-specified)
allele each sample has.</h2><span id='topic+ReadHardcalls'></span>

<h3>Description</h3>

<p>This function treats the data as diploid; you can divide by 2, and then
treat 0.5 as NA, if it's actually haploid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadHardcalls(pgen, buf, variant_num, allele_num = 2L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ReadHardcalls_+3A_pgen">pgen</code></td>
<td>
<p>Object returned by NewPgen().</p>
</td></tr>
<tr><td><code id="ReadHardcalls_+3A_buf">buf</code></td>
<td>
<p>Buffer returned by Buf() or IntBuf().</p>
</td></tr>
<tr><td><code id="ReadHardcalls_+3A_variant_num">variant_num</code></td>
<td>
<p>Variant index (1-based).</p>
</td></tr>
<tr><td><code id="ReadHardcalls_+3A_allele_num">allele_num</code></td>
<td>
<p>Allele index; 1 corresponds to REF, 2 to the first ALT
allele, 3 to the second ALT allele if it exists, etc.  Optional, defaults
2.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, called for buf-filling side-effect.
</p>

<hr>
<h2 id='ReadIntList'>Load hardcalls for multiple variants as an integer matrix.</h2><span id='topic+ReadIntList'></span>

<h3>Description</h3>

<p>This function treats the data as diploid; you can divide by 2, and then
treat 0.5 as NA, if it's actually haploid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadIntList(pgen, variant_subset)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ReadIntList_+3A_pgen">pgen</code></td>
<td>
<p>Object returned by NewPgen().</p>
</td></tr>
<tr><td><code id="ReadIntList_+3A_variant_subset">variant_subset</code></td>
<td>
<p>Integer vector containing 1-based indexes of variants
to load.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer matrix, where rows correspond to samples, columns
correspond to variant_subset, and values are in 0, 1, 2, NA indicating
the number of hardcall ALT allele copies.  For multiallelic variants, all
ALT alleles are combined.
</p>

<hr>
<h2 id='ReadList'>Load dosages for multiple variants as a numeric matrix.</h2><span id='topic+ReadList'></span>

<h3>Description</h3>

<p>This function treats the data as diploid; divide by 2 to obtain haploid
dosages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ReadList(pgen, variant_subset, meanimpute = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ReadList_+3A_pgen">pgen</code></td>
<td>
<p>Object returned by NewPgen().</p>
</td></tr>
<tr><td><code id="ReadList_+3A_variant_subset">variant_subset</code></td>
<td>
<p>Integer vector containing 1-based indexes of variants
to load.</p>
</td></tr>
<tr><td><code id="ReadList_+3A_meanimpute">meanimpute</code></td>
<td>
<p>Optional; if true, missing values are mean-imputed
instead of being represented by NA.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric matrix, where rows correspond to samples, and columns
correspond to variant_subset.  Values are in [0, 2] indicating ALT
allele dosages, or NA for missing dosages.  For multiallelic variants, all
ALT alelles are combined.
</p>

<hr>
<h2 id='VariantScores'>Compute variant scores.</h2><span id='topic+VariantScores'></span>

<h3>Description</h3>

<p>This function treats the data as diploid; divide by 2 to obtain scores
based on a haploid dosage matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>VariantScores(pgen, weights, variant_subset = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="VariantScores_+3A_pgen">pgen</code></td>
<td>
<p>Object returned by NewPgen().</p>
</td></tr>
<tr><td><code id="VariantScores_+3A_weights">weights</code></td>
<td>
<p>Sample weights.</p>
</td></tr>
<tr><td><code id="VariantScores_+3A_variant_subset">variant_subset</code></td>
<td>
<p>Integer vector containing 1-based indexes of variants
to include in the dosage matrix.  Optional; by default, all variants are
included.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numeric vector, containing product of sample-weight vector and the
specified subset of the dosage matrix.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
