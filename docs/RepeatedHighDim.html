<!DOCTYPE html><html><head><title>Help for package RepeatedHighDim</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RepeatedHighDim}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#RepeatedHighDim'><p>RepeatedHighDim Package</p></a></li>
<li><a href='#bag'><p>Calculates the bag</p></a></li>
<li><a href='#check_limma'><p>Check for 'limma' availability</p></a></li>
<li><a href='#depmed'><p>Calculates the depth median.</p></a></li>
<li><a href='#fc_ci'><p>Calculation of adjusted confidence intervals</p></a></li>
<li><a href='#fc_plot'><p>Volcano plot of adjusted confidence intervals</p></a></li>
<li><a href='#GA_diagplot'><p>Diagnostic plot for comparison of two correlation matrices.</p></a></li>
<li><a href='#gem'><p>Plots a gemstone to an interactive graphics device</p></a></li>
<li><a href='#GlobTestMissing'><p>Detection of global group effect</p></a></li>
<li><a href='#gridfun'><p>Specifies grid for the calculation of the halfspace location depths</p></a></li>
<li><a href='#hldepth'><p>Calculates the halfspace location depth</p></a></li>
<li><a href='#iter_matrix'><p>Genetic algorithm for generating correlated binary data</p></a></li>
<li><a href='#loop'><p>Calculates the fence and the loop</p></a></li>
<li><a href='#RHighDim'><p>Detection of global group effect</p></a></li>
<li><a href='#rho_bounds'><p>Calculate lower and upper the bounds for pairwise</p>
correlations</a></li>
<li><a href='#rmvbinary_EP'><p>Simulating correlated binary variables using the algorithm</p>
by Emrich and Piedmonte (1991)</a></li>
<li><a href='#rmvbinary_QA'><p>Simulating correlated binary variables using the algorithm</p>
by Qaqish (2003)</a></li>
<li><a href='#sequence_probs'><p>Calculation of probabilities for binary sequences</p></a></li>
<li><a href='#start_matrix'><p>Setup of the start matrix</p></a></li>
<li><a href='#summary_RHD'><p>Summary of RHighDim function</p></a></li>
<li><a href='#TestStatSimple'><p>Calculates test statistic for RHighDim</p></a></li>
<li><a href='#TestStatSP'><p>Calculates test statistic for RHighDim</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Methods for High-Dimensional Repeated Measures Data</td>
</tr>
<tr>
<td>Version:</td>
<td>2.2.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Klaus Jung [aut, cre],
  Jochen Kruppa [aut],
  Sergej Ruff [aut]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Klaus Jung &lt;klaus.jung@tiho-hannover.de&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A toolkit for the analysis of high-dimensional repeated measurements, providing functions 
    for outlier detection, differential expression analysis, gene-set tests, and binary random data generation.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Imports:</td>
<td>ddalpha, geometry, graphics, grDevices, MASS, mvtnorm, nlme,
rgl, stats, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>BiocManager, limma</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-19 16:17:15 UTC; Serij</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-29 11:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='RepeatedHighDim'>RepeatedHighDim Package</h2><span id='topic+RepeatedHighDim'></span><span id='topic+RepeatedHighDim-package'></span>

<h3>Description</h3>

<p>A comprehensive toolkit for repeated high-dimensional analysis.
</p>


<h3>Details</h3>

<p>The RepeatedHighDim-package is a collection of functions for the analysis of high-dimensional repeated measures data, e.g. from Omics experiments. It provides function for outlier detection, differential expression analysis, self-contained gene-set testing, and generation of correlated binary data.
</p>
<p>For more information and examples, please refer to the package documentation and the tutorial available at <a href="https://software.klausjung-lab.de/">https://software.klausjung-lab.de/</a>.
</p>


<h3>Functions</h3>

<p>This package includes the following functions:
</p>
<p><strong>B</strong>:
</p>

<ul>
<li> <p><code><a href="#topic+bag">bag</a></code>: Calculates the bag.
</p>
</li></ul>

<p><strong>D</strong>:
</p>

<ul>
<li> <p><code><a href="#topic+depmed">depmed</a></code>: Calculates the depth median.
</p>
</li></ul>

<p><strong>F</strong>:
</p>

<ul>
<li> <p><code><a href="#topic+fc_ci">fc_ci</a></code>: Calculates adjusted confidence intervals.
</p>
</li>
<li> <p><code><a href="#topic+fc_plot">fc_plot</a></code>: Creates a volcano plot of adjusted confidence intervals.
</p>
</li></ul>

<p><strong>G</strong>:
</p>

<ul>
<li> <p><code><a href="#topic+GA_diagplot">GA_diagplot</a></code>: Generates a diagnostic plot for comparing two correlation matrices.
</p>
</li>
<li> <p><code><a href="#topic+gem">gem</a></code>: Plots a gemstone to an interactive graphics device.
</p>
</li>
<li> <p><code><a href="#topic+GlobTestMissing">GlobTestMissing</a></code>: Detects global group effects.
</p>
</li>
<li> <p><code><a href="#topic+gridfun">gridfun</a></code>: Specifies a grid for calculating halfspace location depths.
</p>
</li></ul>

<p><strong>H</strong>:
</p>

<ul>
<li> <p><code><a href="#topic+hldepth">hldepth</a></code>: Calculates the halfspace location depth.
</p>
</li></ul>

<p><strong>I</strong>:
</p>

<ul>
<li> <p><code><a href="#topic+iter_matrix">iter_matrix</a></code>: Implements a genetic algorithm for generating correlated binary data.
</p>
</li></ul>

<p><strong>L</strong>:
</p>

<ul>
<li> <p><code><a href="#topic+loop">loop</a></code>: Calculates the fence and the loop.
</p>
</li></ul>

<p><strong>R</strong>:
</p>

<ul>
<li> <p><code><a href="#topic+RHighDim">RHighDim</a></code>: Detects global group effects.
</p>
</li>
<li> <p><code><a href="#topic+rho_bounds">rho_bounds</a></code>: Calculates lower and upper bounds for pairwise correlations.
</p>
</li>
<li> <p><code><a href="#topic+rmvbinary_EP">rmvbinary_EP</a></code>: Simulates correlated binary variables using the algorithm by Emrich and Piedmonte (1991).
</p>
</li>
<li> <p><code><a href="#topic+rmvbinary_QA">rmvbinary_QA</a></code>: Simulates correlated binary variables using the algorithm by Qaqish (2003).
</p>
</li></ul>

<p><strong>S</strong>:
</p>

<ul>
<li> <p><code><a href="#topic+sequence_probs">sequence_probs</a></code>: Calculates probabilities for binary sequences.
</p>
</li>
<li> <p><code><a href="#topic+start_matrix">start_matrix</a></code>: Sets up the start matrix.
</p>
</li>
<li> <p><code><a href="#topic+summary_RHD">summary_RHD</a></code>: Provides a summary of the RHighDim function.
</p>
</li></ul>

<p><strong>T</strong>:
</p>

<ul>
<li> <p><code><a href="#topic+TestStatSimple">TestStatSimple</a></code>: Calculates the test statistic for RHighDim.
</p>
</li>
<li> <p><code><a href="#topic+TestStatSP">TestStatSP</a></code>: Calculates the test statistic for RHighDim.
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Klaus Jung (<a href="mailto:klaus.jung@tiho-hannover.de">klaus.jung@tiho-hannover.de</a>)
</p>
<p><strong>Other contributors</strong>:
</p>

<ul>
<li><p> Jochen Kruppa (<a href="mailto:j.kruppa@hs-osnabrueck.de">j.kruppa@hs-osnabrueck.de</a>)
</p>
</li>
<li><p> Sergej Ruff (<a href="mailto:Sergej.Ruff@tiho-hannover.de">Sergej.Ruff@tiho-hannover.de</a>)
</p>
</li></ul>

<p>If you have any questions, suggestions, or issues, please feel free to contact the maintainer, Klaus Jung (<a href="mailto:klaus.jung@tiho-hannover.de">klaus.jung@tiho-hannover.de</a>).
</p>


<h3>See Also</h3>

<p>For more information, please refer to the package's documentation and the tutorial: <a href="https://software.klausjung-lab.de/">https://software.klausjung-lab.de/</a>.
</p>

<hr>
<h2 id='bag'>Calculates the bag</h2><span id='topic+bag'></span>

<h3>Description</h3>

<p>Calculates the bag of a gemplot (i.e. the inner gemstone).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bag(D, G)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bag_+3A_d">D</code></td>
<td>
<p>Data set with rows representing the individuals and
columns representing the features. In the case of three
dimensions, the colnames of D must be c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;).</p>
</td></tr>
<tr><td><code id="bag_+3A_g">G</code></td>
<td>
<p>List containing the grid information produced by
<code><a href="#topic+gridfun">gridfun</a></code> and the halfspace location depths calculated by
<code><a href="#topic+hldepth">hldepth</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Determines those grid points that belong to the bag, i.e. a convex
hull that contains 50 percent of the data. In the case of a
3-dimensional data set, the bag can be visualized by an inner
gemstone that can be accompanied by an outer gemstone (<code><a href="#topic+loop">loop</a></code>).
</p>


<h3>Value</h3>

<p>A list containg the following elements:
</p>

<dl>
<dt><em>coords</em></dt><dd><p>Coordinates of the grid points that belong to
the bag. Each row represents a grid point and each column
represents one dimension.</p>
</dd>
<dt><em>hull</em></dt><dd><p>A data matrix that
contains the indices of the margin grid points of the bag that
cover the convex hull by triangles. Each row represents one
triangle. The indices correspond to the rows of coords.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Jochen Kruppa, Klaus Jung
</p>


<h3>References</h3>

<p>Rousseeuw, P. J., Ruts, I., &amp; Tukey, J. W. (1999). The bagplot: a bivariate boxplot. <em>The American Statistician</em>, <strong>53(4)</strong>, 382-387. doi: <a href="https://doi.org/10.1080/00031305.1999.10474494">10.1080/00031305.1999.10474494</a>
</p>
<p>Kruppa, J., &amp; Jung, K. (2017). Automated multigroup outlier identification in molecular high-throughput data using bagplots and gemplots. <em>BMC bioinformatics</em>, <strong>18(1)</strong>, 1-10. <a href="https://link.springer.com/article/10.1186/s12859-017-1645-5">https://link.springer.com/article/10.1186/s12859-017-1645-5</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Attention: calculation is currently time-consuming.
## Remove #-Symbols to run examples

## Two 3-dimensional example data sets D1 and D2
# n &lt;- 200
# x1 &lt;- rnorm(n, 0, 1)
# y1 &lt;- rnorm(n, 0, 1)
# z1 &lt;- rnorm(n, 0, 1)
# D1 &lt;- data.frame(cbind(x1, y1, z1))
# x2 &lt;- rnorm(n, 1, 1)
# y2 &lt;- rnorm(n, 1, 1)
# z2 &lt;- rnorm(n, 1, 1)
# D2 &lt;- data.frame(cbind(x2, y2, z2))
# colnames(D1) &lt;- c("x", "y", "z")
# colnames(D2) &lt;- c("x", "y", "z")

## Placing outliers in D1 and D2
# D1[17,] = c(4, 5, 6)
# D2[99,] = -c(3, 4, 5)

## Grid size and graphic parameters
# grid.size &lt;- 20
# red &lt;- rgb(200, 100, 100, alpha = 100, maxColorValue = 255)
# blue &lt;- rgb(100, 100, 200, alpha = 100, maxColorValue = 255)
# yel &lt;- rgb(255, 255, 102, alpha = 100, maxColorValue = 255)
# white &lt;- rgb(255, 255, 255, alpha = 100, maxColorValue = 255)
# require(rgl)
# material3d(color=c(red, blue, yel, white),
# alpha=c(0.5, 0.5, 0.5, 0.5), smooth=FALSE, specular="black")

## Calucation and visualization of gemplot for D1
# G &lt;- gridfun(D1, grid.size=20)
# G$H &lt;- hldepth(D1, G, verbose=TRUE)
# dm &lt;- depmed(G)
# B &lt;- bag(D1, G)
# L &lt;- loop(D1, B, dm=dm)
# bg3d(color = "gray39" )
# points3d(D1[L$outliers==0,1], D1[L$outliers==0,2], D1[L$outliers==0,3], col="green")
# text3d(D1[L$outliers==1,1], D1[L$outliers==1,2],D1[L$outliers==1,3],
# as.character(which(L$outliers==1)), col=yel)
# spheres3d(dm[1], dm[2], dm[3], col=yel, radius=0.1)
# material3d(1,alpha=0.4)
# gem(B$coords, B$hull, red)
# gem(L$coords.loop, L$hull.loop, red)
# axes3d(col="white")

## Calucation and visualization of gemplot for D2
# G &lt;- gridfun(D2, grid.size=20)
# G$H &lt;- hldepth(D2, G, verbose=TRUE)
# dm &lt;- depmed(G)
# B &lt;- bag(D2, G)
# L &lt;- loop(D2, B, dm=dm)
# points3d(D2[L$outliers==0,1], D2[L$outliers==0,2], D2[L$outliers==0,3], col="green")
# text3d(D2[L$outliers==1,1], D2[L$outliers==1,2],D2[L$outliers==1,3],
# as.character(which(L$outliers==1)), col=yel)
# spheres3d(dm[1], dm[2], dm[3], col=yel, radius=0.1)
# gem(B$coords, B$hull, blue)
# gem(L$coords.loop, L$hull.loop, blue)
</code></pre>

<hr>
<h2 id='check_limma'>Check for 'limma' availability</h2><span id='topic+check_limma'></span>

<h3>Description</h3>

<p>checks if the 'limma' package is installed. If not already installed,
limma will be installed automatically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_limma()
</code></pre>


<h3>Details</h3>

<p>Check for package dependency
</p>


<h3>Author(s)</h3>

<p>Sergej Ruff
</p>

<hr>
<h2 id='depmed'>Calculates the depth median.</h2><span id='topic+depmed'></span>

<h3>Description</h3>

<p>Calculates the depth median.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>depmed(G)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="depmed_+3A_g">G</code></td>
<td>
<p>List containing the grid information produced by
<code><a href="#topic+gridfun">gridfun</a></code> and the halfspace location depths
produced by <code><a href="#topic+hldepth">hldepth</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the depth median in a specified grid array with given
halfspace location depth at each grid location.
</p>


<h3>Value</h3>

<p>An vector with a length equal to the number of dimension
of the array in G, containing the coordinates of the depth
median.
</p>


<h3>Author(s)</h3>

<p>Jochen Kruppa, Klaus Jung
</p>


<h3>References</h3>

<p>Rousseeuw, P. J., Ruts, I., &amp; Tukey, J. W. (1999). The
bagplot: a bivariate boxplot. The American Statistician,
53(4), 382-387.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Attention: calculation is currently time-consuming.
## Remove #-Symbols to run examples

## A 3-dimensional example data set D1
# n &lt;- 200
# x1 &lt;- rnorm(n, 0, 1)
# y1 &lt;- rnorm(n, 0, 1)
# z1 &lt;- rnorm(n, 0, 1)
# D1 &lt;- data.frame(cbind(x1, y1, z1))
# colnames(D1) &lt;- c("x", "y", "z")

## Specification of the grid and calculation of the halfspace location depth at each grid location.
# G &lt;- gridfun(D1, grid.size=20)
# G$H &lt;- hldepth(D1, G, verbose=TRUE)
# dm &lt;- depmed(G) ## Calculation of the depth median
</code></pre>

<hr>
<h2 id='fc_ci'>Calculation of adjusted confidence intervals</h2><span id='topic+fc_ci'></span>

<h3>Description</h3>

<p>Calculation of adjusted confidence intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fc_ci(fit, alpha = 0.05, method = "raw")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fc_ci_+3A_fit">fit</code></td>
<td>
<p>Object as returned from the function eBayes of the limma package</p>
</td></tr>
<tr><td><code id="fc_ci_+3A_alpha">alpha</code></td>
<td>
<p>1 - confidence level (e.g., if confidence level is 0.95, alpha is 0.05)</p>
</td></tr>
<tr><td><code id="fc_ci_+3A_method">method</code></td>
<td>
<p>Either 'raw' for unadjusted confidence intervals, or 'BH' for Bejamini Hochberg-adjusted confidence intervals, or 'BY' for Benjamini Yekutieli-adjusted confidence intervals</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculation of unadjusted and adjusted confidence intervals for the log fold change
</p>


<h3>Value</h3>

<p>A results matrix with one row per gene, and one column for the p-value, the log fold change, the lower limit of the CI, and the upper limit of the CI
</p>


<h3>Author(s)</h3>

<p>Klaus Jung
</p>


<h3>References</h3>

<p>Dudoit, S., Shaffer, J. P., &amp; Boldrick, J. C. (2003). Multiple hypothesis testing in microarray experiments. <em>Statistical Science</em>, <strong>18(1)</strong>, 71-103. <a href="https://projecteuclid.org/journals/statistical-science/volume-18/issue-1/Multiple-Hypothesis-Testing-in-Microarray-Experiments/10.1214/ss/1056397487.full">https://projecteuclid.org/journals/statistical-science/volume-18/issue-1/Multiple-Hypothesis-Testing-in-Microarray-Experiments/10.1214/ss/1056397487.full</a>
</p>
<p>Jung, K., Friede, T., &amp; Beißbarth, T. (2011). Reporting FDR analogous confidence intervals for the log fold change of differentially expressed genes. <em>BMC bioinformatics</em>, <strong>12</strong>, 1-9. <a href="https://link.springer.com/article/10.1186/1471-2105-12-288">https://link.springer.com/article/10.1186/1471-2105-12-288</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Artificial microarray data
d = 1000 ### Number of genes
n = 10 ### Sample per group
fc = rlnorm(d, 0, 0.1)
mu1 = rlnorm(d, 0, 1) ### Mean vector group 1
mu2 = mu1 * fc ### Mean vector group 2
sd1 = rnorm(d, 1, 0.2)
sd2 = rnorm(d, 1, 0.2)
X1 = matrix(NA, d, n) ### Expression levels group 1
X2 = matrix(NA, d, n) ### Expression levels group 2
for (i in 1:n) {
  X1[,i] = rnorm(d, mu1, sd=sd1)
  X2[,i] = rnorm(d, mu2, sd=sd2)
}
X = cbind(X1, X2)
heatmap(X)

### Differential expression analysis with limma
if(check_limma()){
group = gl(2, n)
design = model.matrix(~ group)
fit1 = limma::lmFit(X, design)
fit = limma::eBayes(fit1)

### Calculation of confidence intervals
CI = fc_ci(fit=fit, alpha=0.05, method="raw")
head(CI)
CI = fc_ci(fit=fit, alpha=0.05, method="BH")
head(CI)
CI = fc_ci(fit=fit, alpha=0.05, method="BY")
head(CI)

fc_plot(CI, xlim=c(-0.5, 3), ylim=-log10(c(1, 0.0001)), updown="up")
fc_plot(CI, xlim=c(-3, 0.5), ylim=-log10(c(1, 0.0001)), updown="down")
fc_plot(CI, xlim=c(-3, 3), ylim=-log10(c(1, 0.0001)), updown="all")
}
</code></pre>

<hr>
<h2 id='fc_plot'>Volcano plot of adjusted confidence intervals</h2><span id='topic+fc_plot'></span>

<h3>Description</h3>

<p>Volcano plot of adjusted confidence intervals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fc_plot(
  CI,
  alpha = 0.05,
  updown = "all",
  xlim = c(-3, 3),
  ylim = -log10(c(1, 0.001))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fc_plot_+3A_ci">CI</code></td>
<td>
<p>Object as returned from the function fc_ci</p>
</td></tr>
<tr><td><code id="fc_plot_+3A_alpha">alpha</code></td>
<td>
<p>1 - confidence level (e.g., if confidence level is 0.95, alpha is 0.05)</p>
</td></tr>
<tr><td><code id="fc_plot_+3A_updown">updown</code></td>
<td>
<p>Character, 'all' if CIs for all genes, 'down' if CIs for down-regulated genes, or 'up' if CIs for up-regulated genes to be plotted</p>
</td></tr>
<tr><td><code id="fc_plot_+3A_xlim">xlim</code></td>
<td>
<p>Vector of length 2 with the lower and upper limits for the X-axis</p>
</td></tr>
<tr><td><code id="fc_plot_+3A_ylim">ylim</code></td>
<td>
<p>Vector of length 2 with the lower and upper limits for the Y-axis. Please note, that p-values are usually displayed on the -log10-scale in a volcano plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Volcano plot of adjusted confidence intervals
</p>


<h3>Author(s)</h3>

<p>Klaus Jung
</p>


<h3>References</h3>

<p>Dudoit, S., Shaffer, J. P., &amp; Boldrick, J. C. (2003). Multiple hypothesis testing in microarray experiments. <em>Statistical Science</em>, <strong>18(1)</strong>, 71-103. <a href="https://projecteuclid.org/journals/statistical-science/volume-18/issue-1/Multiple-Hypothesis-Testing-in-Microarray-Experiments/10.1214/ss/1056397487.full">https://projecteuclid.org/journals/statistical-science/volume-18/issue-1/Multiple-Hypothesis-Testing-in-Microarray-Experiments/10.1214/ss/1056397487.full</a>
</p>
<p>Jung, K., Friede, T., &amp; Beißbarth, T. (2011). Reporting FDR analogous confidence intervals for the log fold change of differentially expressed genes. <em>BMC bioinformatics</em>, <strong>12</strong>, 1-9. <a href="https://link.springer.com/article/10.1186/1471-2105-12-288">https://link.springer.com/article/10.1186/1471-2105-12-288</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Artificial microarray data
d = 1000 ### Number of genes
n = 10 ### Sample per group
fc = rlnorm(d, 0, 0.1)
mu1 = rlnorm(d, 0, 1) ### Mean vector group 1
mu2 = mu1 * fc ### Mean vector group 2
sd1 = rnorm(d, 1, 0.2)
sd2 = rnorm(d, 1, 0.2)
X1 = matrix(NA, d, n) ### Expression levels group 1
X2 = matrix(NA, d, n) ### Expression levels group 2
for (i in 1:n) {
  X1[,i] = rnorm(d, mu1, sd=sd1)
  X2[,i] = rnorm(d, mu2, sd=sd2)
}
X = cbind(X1, X2)
heatmap(X)

### Differential expression analysis with limma
if(check_limma()){
group = gl(2, n)
design = model.matrix(~ group)
fit1 = limma::lmFit(X, design)
fit = limma::eBayes(fit1)

### Calculation of confidence intervals
CI = fc_ci(fit=fit, alpha=0.05, method="raw")
head(CI)
CI = fc_ci(fit=fit, alpha=0.05, method="BH")
head(CI)
CI = fc_ci(fit=fit, alpha=0.05, method="BY")
head(CI)

fc_plot(CI, xlim=c(-0.5, 3), ylim=-log10(c(1, 0.0001)), updown="up")
fc_plot(CI, xlim=c(-3, 0.5), ylim=-log10(c(1, 0.0001)), updown="down")
fc_plot(CI, xlim=c(-3, 3), ylim=-log10(c(1, 0.0001)), updown="all")
}
</code></pre>

<hr>
<h2 id='GA_diagplot'>Diagnostic plot for comparison of two correlation matrices.</h2><span id='topic+GA_diagplot'></span>

<h3>Description</h3>

<p>A diagnostic plot that compares the entries of two correlation
matrices using a color scale.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GA_diagplot(
  R,
  Rt,
  eps = 0.05,
  col.method = "trafficlight",
  color = c(0, 8),
  top = ""
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GA_diagplot_+3A_r">R</code></td>
<td>
<p>Specified correlation matrix.</p>
</td></tr>
<tr><td><code id="GA_diagplot_+3A_rt">Rt</code></td>
<td>
<p>Correlation matrix of the data generated by the genetic
algorithm.</p>
</td></tr>
<tr><td><code id="GA_diagplot_+3A_eps">eps</code></td>
<td>
<p>Permitted difference between the entries of two
matrices. Must only be specified if col.method=&quot;trafficlight&quot;.</p>
</td></tr>
<tr><td><code id="GA_diagplot_+3A_col.method">col.method</code></td>
<td>
<p>Method to use for color scaling the difference
between the matrices. If method=&quot;trafficlight&quot; only two colors
are used, indicating whether the entries deviated at least by a
difference of eps. If method=&quot;updown&quot; a discrete gray scale is
used.</p>
</td></tr>
<tr><td><code id="GA_diagplot_+3A_color">color</code></td>
<td>
<p>Value of two color that are used if method=&quot;trafficlight&quot;</p>
</td></tr>
<tr><td><code id="GA_diagplot_+3A_top">top</code></td>
<td>
<p>Specifies the main title of the plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A diagnostic plot that compares the entries of two correlation
matrices using a color scale.
</p>


<h3>Author(s)</h3>

<p>Jochen Kruppa, Klaus Jung
</p>


<h3>References</h3>

<p>Kruppa, J., Lepenies, B., &amp; Jung, K. (2018). A genetic algorithm for simulating correlated binary data from biomedical research. <em>Computers in biology and medicine</em>, <strong>92</strong>, 1-8. doi: <a href="https://doi.org/10.1016/j.compbiomed.2017.10.023">10.1016/j.compbiomed.2017.10.023</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>R1 = diag(10)
X0 &lt;- start_matrix(p=c(0.4, 0.2, 0.5, 0.15, 0.4, 0.35, 0.2, 0.25, 0.3, 0.4), k = 5000)
Xt &lt;- iter_matrix(X0, R = diag(10), T = 10000, e.min = 0.00001)
GA_diagplot(R1, Rt = Xt$Rt, col.method = "trafficlight")
GA_diagplot(R1, Rt = Xt$Rt, col.method = "updown")
</code></pre>

<hr>
<h2 id='gem'>Plots a gemstone to an interactive graphics device</h2><span id='topic+gem'></span>

<h3>Description</h3>

<p>Plots a gemstone to an interactive graphics device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gem(coords, hull, clr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gem_+3A_coords">coords</code></td>
<td>
<p>Matrix with coordinates of the grid or of data
points that belong to the gemstone, calculated by either
<code><a href="#topic+bag">bag</a></code> or <code><a href="#topic+loop">loop</a></code>. Each row represents a
grid point and each column represents one dimension.</p>
</td></tr>
<tr><td><code id="gem_+3A_hull">hull</code></td>
<td>
<p>Matrix with indices of triangles that cover a convex
hull arround the gemstone. Each row represents one triangle
and the indices refer to the rows of coords.</p>
</td></tr>
<tr><td><code id="gem_+3A_clr">clr</code></td>
<td>
<p>Specifies the color of the gemstone.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Only applicable to 3-dimensional data sets. Transparent colors are
recommended for outer gemstone of the gemplot. Further graphical
parameters can be set using material3d() of the rgl-package.
</p>


<h3>Author(s)</h3>

<p>Jochen Kruppa, Klaus Jung
</p>


<h3>References</h3>

<p>Rousseeuw, P. J., Ruts, I., &amp; Tukey, J. W. (1999). The bagplot: a bivariate boxplot. <em>The American Statistician</em>, <strong>53(4)</strong>, 382-387. doi: <a href="https://doi.org/10.1080/00031305.1999.10474494">10.1080/00031305.1999.10474494</a>
</p>
<p>Kruppa, J., &amp; Jung, K. (2017). Automated multigroup outlier identification in molecular high-throughput data using bagplots and gemplots. <em>BMC bioinformatics</em>, <strong>18(1)</strong>, 1-10. <a href="https://link.springer.com/article/10.1186/s12859-017-1645-5">https://link.springer.com/article/10.1186/s12859-017-1645-5</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Attention: calculation is currently time-consuming.
## Remove #-Symbols to run examples

## Two 3-dimensional example data sets D1 and D2
# n &lt;- 200
# x1 &lt;- rnorm(n, 0, 1)
# y1 &lt;- rnorm(n, 0, 1)
# z1 &lt;- rnorm(n, 0, 1)
# D1 &lt;- data.frame(cbind(x1, y1, z1))
# x2 &lt;- rnorm(n, 1, 1)
# y2 &lt;- rnorm(n, 1, 1)
# z2 &lt;- rnorm(n, 1, 1)
# D2 &lt;- data.frame(cbind(x2, y2, z2))
# colnames(D1) &lt;- c("x", "y", "z")
# colnames(D2) &lt;- c("x", "y", "z")

## Placing outliers in D1 and D2
# D1[17,] = c(4, 5, 6)
# D2[99,] = -c(3, 4, 5)

## Grid size and graphic parameters
# grid.size &lt;- 20
# red &lt;- rgb(200, 100, 100, alpha = 100, maxColorValue = 255)
# blue &lt;- rgb(100, 100, 200, alpha = 100, maxColorValue = 255)
# yel &lt;- rgb(255, 255, 102, alpha = 100, maxColorValue = 255)
# white &lt;- rgb(255, 255, 255, alpha = 100, maxColorValue = 255)
# require(rgl)
# material3d(color=c(red, blue, yel, white),
# alpha=c(0.5, 0.5, 0.5, 0.5), smooth=FALSE, specular="black")

## Calucation and visualization of gemplot for D1
# G &lt;- gridfun(D1, grid.size=20)
# G$H &lt;- hldepth(D1, G, verbose=TRUE)
# dm &lt;- depmed(G)
# B &lt;- bag(D1, G)
# L &lt;- loop(D1, B, dm=dm)
# bg3d(color = "gray39" )
# points3d(D1[L$outliers==0,1], D1[L$outliers==0,2], D1[L$outliers==0,3], col="green")
# text3d(D1[L$outliers==1,1], D1[L$outliers==1,2], D1[L$outliers==1,3],
# as.character(which(L$outliers==1)), col=yel)
# spheres3d(dm[1], dm[2], dm[3], col=yel, radius=0.1)
# material3d(1,alpha=0.4)
# gem(B$coords, B$hull, red)
# gem(L$coords.loop, L$hull.loop, red)
# axes3d(col="white")

## Calucation and visualization of gemplot for D2
# G &lt;- gridfun(D2, grid.size=20)
# G$H &lt;- hldepth(D2, G, verbose=TRUE)
# dm &lt;- depmed(G)
# B &lt;- bag(D2, G)
# L &lt;- loop(D2, B, dm=dm)
# points3d(D2[L$outliers==0,1], D2[L$outliers==0,2], D2[L$outliers==0,3], col="green")
# text3d(D2[L$outliers==1,1], D2[L$outliers==1,2], D2[L$outliers==1,3],
# as.character(which(L$outliers==1)), col=yel)
# spheres3d(dm[1], dm[2], dm[3], col=yel, radius=0.1)
# gem(B$coords, B$hull, blue)
# gem(L$coords.loop, L$hull.loop, blue)

## Example of outlier detection with four principal components.
## Attention: calculation is currently time-consuming.

# set.seed(123)
# n &lt;- 200
# x1 &lt;- rnorm(n, 0, 1)
# x2 &lt;- rnorm(n, 0, 1)
# x3 &lt;- rnorm(n, 0, 1)
# x4 &lt;- rnorm(n, 0, 1)
# D &lt;- data.frame(cbind(x1, x2, x3, x4))
# D[67,] = c(7, 0, 0, 0)

# date()
# G = gridfun(D, 20, 4)
# G$H = hldepth(D, G, verbose=TRUE)
# dm = depmed(G)
# B = bag(D, G)
# L = loop(D, B, dm=dm)
# which(L$outliers==1)
# date()
</code></pre>

<hr>
<h2 id='GlobTestMissing'>Detection of global group effect</h2><span id='topic+GlobTestMissing'></span>

<h3>Description</h3>

<p>Detection of global group effect
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GlobTestMissing(X1, X2, nperm = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GlobTestMissing_+3A_x1">X1</code></td>
<td>
<p>Matrix of expression levels in first group. Rows
represent features, columns represent samples.</p>
</td></tr>
<tr><td><code id="GlobTestMissing_+3A_x2">X2</code></td>
<td>
<p>Matrix of expression levels in second group. Rows
represent features, columns represent samples.</p>
</td></tr>
<tr><td><code id="GlobTestMissing_+3A_nperm">nperm</code></td>
<td>
<p>Number of permutations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Tests a global effect for a set of molecular features (e.g. genes,
proteins,...) between the two groups of samples. Missing values
are allowd in the expression data. Samples of the two groups are
supposed to be unpaired.
</p>


<h3>Value</h3>

<p>The p-value of a permutation test.
</p>


<h3>Author(s)</h3>

<p>Klaus Jung
</p>


<h3>References</h3>

<p>Jung K, Dihazi H, Bibi A, Dihazi GH and Beissbarth T (2014): Adaption of the Global Test Idea to Proteomics Data with Missing Values. <em>Bioinformatics</em>, <strong>30</strong>, 1424-30. doi: <a href="https://doi.org/10.1093/bioinformatics/btu062">10.1093/bioinformatics/btu062</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Global comparison of a set of 100 proteins between two experimental groups,
### where (tau * 100) percent of expression levels are missing.
n1 = 10
n2 = 10
d = 100
tau = 0.1
X1 = t(matrix(rnorm(n1*d, 0, 1), n1, d))
X2 = t(matrix(rnorm(n2*d, 0.1, 1), n2, d))
X1[sample(1:(n1*d), tau * (n1*d))] = NA
X2[sample(1:(n2*d), tau * (n2*d))] = NA
GlobTestMissing(X1, X2, nperm=100)
</code></pre>

<hr>
<h2 id='gridfun'>Specifies grid for the calculation of the halfspace location depths</h2><span id='topic+gridfun'></span>

<h3>Description</h3>

<p>Specifies a k-dimensional array as grid for the calculation of the
halfspace location depths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gridfun(D, grid.size, k = 4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gridfun_+3A_d">D</code></td>
<td>
<p>Data set with rows representing the individuals and
columns representing the features. In the case of three
dimensions, the colnames of D must be c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;).</p>
</td></tr>
<tr><td><code id="gridfun_+3A_grid.size">grid.size</code></td>
<td>
<p>Number of grid points in each dimension.</p>
</td></tr>
<tr><td><code id="gridfun_+3A_k">k</code></td>
<td>
<p>Number of dimensions of the grid. Needs only be specified
if D has more than columns.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>D must have at least three columns. If D has three columns,
automatically a 3-dimensional grid is generated. If D has more
than three columns, k must be specified.
</p>


<h3>Value</h3>

<p>A list containing the following elements:
</p>

<dl>
<dt><em>H</em></dt><dd><p>The k-dimensional array.</p>
</dd>
</dl>

<p>In the case of a 3-dimensional array, additional elements are:
</p>

<dl>
<dt><em>grid.x, grid.y, grid.z</em></dt><dd><p>The coordinates of the grid points at each dimension.</p>
</dd>
</dl>

<p>In the case that the array has more than three dimensions, additional elements are:
</p>

<dl>
<dt><em>grid.k</em></dt><dd><p>A matrix with the coordinates of the grid. Row represents dimensions and columns represent grid points.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Jochen Kruppa, Klaus Jung
</p>

<hr>
<h2 id='hldepth'>Calculates the halfspace location depth</h2><span id='topic+hldepth'></span>

<h3>Description</h3>

<p>Calculates the halfspace location depth for each point in a given grid.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hldepth(D, G, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hldepth_+3A_d">D</code></td>
<td>
<p>Data set with rows representing the individuals and
columns representing the features. In the case of three
dimensions, the colnames of D must be c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;).</p>
</td></tr>
<tr><td><code id="hldepth_+3A_g">G</code></td>
<td>
<p>List containing the grid information produced by
<code><a href="#topic+gridfun">gridfun</a></code>.</p>
</td></tr>
<tr><td><code id="hldepth_+3A_verbose">verbose</code></td>
<td>
<p>Logical. Indicates whether progress information is
printed during calculation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculation of the halfspace location depth at each grid point is
mandatory before calculating the depth median
(<code><a href="#topic+depmed">depmed</a></code>), the bag (<code><a href="#topic+bag">bag</a></code>) and the loop
(<code><a href="#topic+loop">loop</a></code>). Ideally, the output is assigned to the array
H produced by <code><a href="#topic+gridfun">gridfun</a></code>.
</p>


<h3>Value</h3>


<dl>
<dt><em>H</em></dt><dd><p>An array of the same dimension as the array in argument G. The elements contain the halfspace location depth at the related grid location.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Jochen Kruppa, Klaus Jung
</p>


<h3>References</h3>

<p>Rousseeuw, P. J., Ruts, I., &amp; Tukey, J. W. (1999). The
bagplot: a bivariate boxplot. The American Statistician,
53(4), 382-387.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Attention: calculation is currently time-consuming.
## Remove #-Symbols to run examples

## A 3-dimensional example data set D1
# n &lt;- 200
# x1 &lt;- rnorm(n, 0, 1)
# y1 &lt;- rnorm(n, 0, 1)
# z1 &lt;- rnorm(n, 0, 1)
# D1 &lt;- data.frame(cbind(x1, y1, z1))
# colnames(D1) &lt;- c("x", "y", "z")

## Specification of the grid and calculation of the halfspace location depth at each grid location.
# G &lt;- gridfun(D1, grid.size=20)
# G$H &lt;- hldepth(D1, G, verbose=TRUE)
</code></pre>

<hr>
<h2 id='iter_matrix'>Genetic algorithm for generating correlated binary data</h2><span id='topic+iter_matrix'></span>

<h3>Description</h3>

<p>Starts the genetic algorithm based on a start matrix with
specified marginal probabilities.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iter_matrix(X0, R, T = 1000, e.min = 1e-04, plt = TRUE, perc = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iter_matrix_+3A_x0">X0</code></td>
<td>
<p>Start matrix with specified marginal probabilities. Can
be generated by <code><a href="#topic+start_matrix">start_matrix</a></code>.</p>
</td></tr>
<tr><td><code id="iter_matrix_+3A_r">R</code></td>
<td>
<p>Desired correlation matrix the data should have after
running the genetic algorithm.</p>
</td></tr>
<tr><td><code id="iter_matrix_+3A_t">T</code></td>
<td>
<p>Maximum number of iterations after which the genetic
algorithm stops.</p>
</td></tr>
<tr><td><code id="iter_matrix_+3A_e.min">e.min</code></td>
<td>
<p>Minimum error (RMSE) between the correlation of the
iterated data matrix and R.</p>
</td></tr>
<tr><td><code id="iter_matrix_+3A_plt">plt</code></td>
<td>
<p>Boolean parameter that indicates whether to plot
e.min versus the iteration step.</p>
</td></tr>
<tr><td><code id="iter_matrix_+3A_perc">perc</code></td>
<td>
<p>Boolean parameter that indicates whether to print the
percentage of iteration steps relativ to T.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In each step, the genetic algorithm swaps two randomly selected
entries in each column of X0. Thus it can be guaranteed that the
marginal probabilities do not change. If the correlation matrix is closer to R than that of x0(t-1), X0(t) replaces X0(t-1).
</p>


<h3>Value</h3>

<p>A list with four entries:
</p>

<dl>
<dt><em>Xt</em></dt><dd><p>Final representativ data matrix with specified marginal probabilities and a correlation as close as possible to R</p>
</dd>
<dt><em>t</em></dt><dd><p>Number of performed iteration steps (t &lt;= T)</p>
</dd>
<dt><em>Rt</em></dt><dd><p>Empirical correlation matrix of Xt</p>
</dd>
<dt><em>RMSE</em></dt><dd><p>Final RSME error between desired and achieved correlation matrix </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Jochen Kruppa, Klaus Jung
</p>


<h3>References</h3>

<p>Kruppa, J., Lepenies, B., &amp; Jung, K. (2018). A genetic algorithm for simulating correlated binary data from biomedical research. <em>Computers in biology and medicine</em>, <strong>92</strong>, 1-8. doi: <a href="https://doi.org/10.1016/j.compbiomed.2017.10.023">10.1016/j.compbiomed.2017.10.023</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Generation of the representive matrix Xt
X0 &lt;- start_matrix(p = c(0.5, 0.6), k = 1000)
Xt &lt;- iter_matrix(X0, R = diag(2), T = 10000, e.min = 0.00001)$Xt

### Drawing of a random sample S of size n = 10
S &lt;- Xt[sample(1:1000, 10, replace = TRUE),]
</code></pre>

<hr>
<h2 id='loop'>Calculates the fence and the loop</h2><span id='topic+loop'></span>

<h3>Description</h3>

<p>Calculates the fence and the loop of a gemplot (i.e. the outer gemstone).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loop(D, B, inflation = 3, dm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loop_+3A_d">D</code></td>
<td>
<p>Data set with rows representing the individuals and
columns representing the features. In the case of three
dimensions, the colnames of D must be c(&quot;x&quot;, &quot;y&quot;, &quot;z&quot;).</p>
</td></tr>
<tr><td><code id="loop_+3A_b">B</code></td>
<td>
<p>List containing the information about the coordinates of
the bag and the convex hull that forms the bag (determined by
<code><a href="#topic+bag">bag</a></code>).</p>
</td></tr>
<tr><td><code id="loop_+3A_inflation">inflation</code></td>
<td>
<p>A numeric value &gt; 0 that specifies the inflation
factor of the bag relative to the median (default = 3).</p>
</td></tr>
<tr><td><code id="loop_+3A_dm">dm</code></td>
<td>
<p>The coordinates of the depth median as produced by
<code><a href="#topic+depmed">depmed</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The fence inflates the the bag relative to the depth median by the
factor inflation. Data points outside the bag and inside the fence
the loop or outer gemstone are flagged as outliers. Data points
outside the fence are marked as outliers. In the case of a
3-dimensional data set, the loop can be visualized by an outer
gemstone around the inner gemstone or bag.
</p>


<h3>Value</h3>

<p>A list containing the following elements:
</p>

<dl>
<dt><em>coords.loop</em></dt><dd><p>Coordinates of the data points that are inside the convex hull around the loop.</p>
</dd>
<dt><em>hull.loop</em></dt><dd><p>A data matrix that contains the indices of the margin data points of the loop that cover the convex hull by triangles. Each row represnts one triangle. The indices correspond to the rows of coords.loop.</p>
</dd>
<dt><em>coords.fence</em></dt><dd><p>Coordinates of the grid points that are inside the fence but outside the bag.</p>
</dd>
<dt><em>hull.fence</em></dt><dd><p>A data matrix that contains the indices of the margin grid points of the fence that cover the convex hull around the fence by triangles. Each row represnts one triangle. The indices correspond to the rows of coords.fence.</p>
</dd>
<dt><em>outliers</em></dt><dd><p>A vector of length equal to the sample size. Data points that are inside the fence are labelled by 0 and values outside the fence (i.e. outliers) are labelled by 1.</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Jochen Kruppa, Klaus Jung
</p>


<h3>References</h3>

<p>Rousseeuw, P. J., Ruts, I., &amp; Tukey, J. W. (1999). The bagplot: a bivariate boxplot. <em>The American Statistician</em>, <strong>53(4)</strong>, 382-387. doi: <a href="https://doi.org/10.1080/00031305.1999.10474494">10.1080/00031305.1999.10474494</a>
</p>
<p>Kruppa, J., &amp; Jung, K. (2017). Automated multigroup outlier identification in molecular high-throughput data using bagplots and gemplots. <em>BMC bioinformatics</em>, <strong>18(1)</strong>, 1-10. <a href="https://link.springer.com/article/10.1186/s12859-017-1645-5">https://link.springer.com/article/10.1186/s12859-017-1645-5</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Attention: calculation is currently time-consuming.
## Remove #-Symbols to run examples

## Two 3-dimensional example data sets D1 and D2
# n &lt;- 200
# x1 &lt;- rnorm(n, 0, 1)
# y1 &lt;- rnorm(n, 0, 1)
# z1 &lt;- rnorm(n, 0, 1)
# D1 &lt;- data.frame(cbind(x1, y1, z1))
# x2 &lt;- rnorm(n, 1, 1)
# y2 &lt;- rnorm(n, 1, 1)
# z2 &lt;- rnorm(n, 1, 1)
# D2 &lt;- data.frame(cbind(x2, y2, z2))
# colnames(D1) &lt;- c("x", "y", "z")
# colnames(D2) &lt;- c("x", "y", "z")

## Placing outliers in D1 and D2
# D1[17,] = c(4, 5, 6)
# D2[99,] = -c(3, 4, 5)

## Grid size and graphic parameters
# grid.size &lt;- 20
# red &lt;- rgb(200, 100, 100, alpha = 100, maxColorValue = 255)
# blue &lt;- rgb(100, 100, 200, alpha = 100, maxColorValue = 255)
# yel &lt;- rgb(255, 255, 102, alpha = 100, maxColorValue = 255)
# white &lt;- rgb(255, 255, 255, alpha = 100, maxColorValue = 255)
# require(rgl)
# material3d(color=c(red, blue, yel, white),
#  alpha=c(0.5, 0.5, 0.5, 0.5), smooth=FALSE, specular="black")

## Calucation and visualization of gemplot for D1
# G &lt;- gridfun(D1, grid.size=20)
# G$H &lt;- hldepth(D1, G, verbose=TRUE)
# dm &lt;- depmed(G)
# B &lt;- bag(D1, G)
# L &lt;- loop(D1, B, dm=dm)
# bg3d(color = "gray39" )
# points3d(D1[L$outliers==0,1], D1[L$outliers==0,2], D1[L$outliers==0,3], col="green")
# text3d(D1[L$outliers==1,1], D1[L$outliers==1,2], D1[L$outliers==1,3],
# as.character(which(L$outliers==1)), col=yel)
# spheres3d(dm[1], dm[2], dm[3], col=yel, radius=0.1)
# material3d(1,alpha=0.4)
# gem(B$coords, B$hull, red)
# gem(L$coords.loop, L$hull.loop, red)
# axes3d(col="white")

## Calucation and visualization of gemplot for D2
# G &lt;- gridfun(D2, grid.size=20)
# G$H &lt;- hldepth(D2, G, verbose=TRUE)
# dm &lt;- depmed(G)
# B &lt;- bag(D2, G)
# L &lt;- loop(D2, B, dm=dm)
# points3d(D2[L$outliers==0,1], D2[L$outliers==0,2], D2[L$outliers==0,3], col="green")
# text3d(D2[L$outliers==1,1], D2[L$outliers==1,2], D2[L$outliers==1,3],
# as.character(which(L$outliers==1)), col=yel)
# spheres3d(dm[1], dm[2], dm[3], col=yel, radius=0.1)
# gem(B$coords, B$hull, blue)
# gem(L$coords.loop, L$hull.loop, blue)
</code></pre>

<hr>
<h2 id='RHighDim'>Detection of global group effect</h2><span id='topic+RHighDim'></span>

<h3>Description</h3>

<p>Detection of global group effect
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RHighDim(X1, X2, paired = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RHighDim_+3A_x1">X1</code></td>
<td>
<p>Matrix of expression levels in first group. Rows represent features, columns represent samples.</p>
</td></tr>
<tr><td><code id="RHighDim_+3A_x2">X2</code></td>
<td>
<p>Matrix of expression levels in second group. Rows represent features, columns represent samples.</p>
</td></tr>
<tr><td><code id="RHighDim_+3A_paired">paired</code></td>
<td>
<p>FALSE if samples are unpaired, TRUE if samples are paired.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Global test for a set of molecular features (e.g. genes, proteins,...) between two experimental groups. Paired or unpaired design is allowed.
</p>


<h3>Value</h3>

<p>An object that contains the test results. Contents can be displayed by the summary function.
</p>


<h3>Author(s)</h3>

<p>Klaus Jung
</p>


<h3>References</h3>

<p>Brunner, E (2009) Repeated measures under non-sphericity. <em>Proceedings of the 6th St. Petersburg Workshop on Simulation</em>, 605-609.
</p>
<p>Jung K, Becker B, Brunner B and Beissbarth T (2011) Comparison of Global Tests for Functional Gene Sets in Two-Group Designs and Selection of Potentially Effect-causing Genes. <em>Bioinformatics</em>, <strong>27</strong>, 1377-1383. doi: <a href="https://doi.org/10.1093/bioinformatics/btr152">10.1093/bioinformatics/btr152</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Global comparison of a set of 100 genes between two experimental groups.
X1 = matrix(rnorm(1000, 0, 1), 10, 100)
X2 = matrix(rnorm(1000, 0.1, 1), 10, 100)
RHD = RHighDim(X1, X2, paired=FALSE)
summary_RHD(RHD)
</code></pre>

<hr>
<h2 id='rho_bounds'>Calculate lower and upper the bounds for pairwise
correlations</h2><span id='topic+rho_bounds'></span>

<h3>Description</h3>

<p>Calculate lower and upper the bounds for pairwise correlations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rho_bounds(R, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rho_bounds_+3A_r">R</code></td>
<td>
<p>Correlation matrix</p>
</td></tr>
<tr><td><code id="rho_bounds_+3A_p">p</code></td>
<td>
<p>Vector of marginal frequencies</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function calculates upper and lower bounds for pairwise
correlations given a vector of marginal probabilities as detailed
in Emrich and Piedmonte (1991).
</p>


<h3>Value</h3>

<p>A list with three entries:
</p>

<dl>
<dt><em>L</em></dt><dd><p>Matrix of lower bounds</p>
</dd>
<dt><em>U</em></dt><dd><p>Matrix of upper bounds</p>
</dd>
<dt><em>Z</em></dt><dd><p>Matrix that indicates whether specified
correlations in R are bigger or smaller than the calculated
bounds</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Jochen Kruppa, Klaus Jung
</p>


<h3>References</h3>

<p>Emrich, L.J., Piedmonte, M.R.: A method for generating highdimensional multivariate binary variates. <em>The American Statistician</em>, <strong>45(4)</strong>, 302 (1991). doi: <a href="https://doi.org/10.1080/00031305.1991.10475828">10.1080/00031305.1991.10475828</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### A simple example
R &lt;- diag(4)
p &lt;- c(0.1, 0.2, 0.4, 0.5)

rho_bounds(R, p)
</code></pre>

<hr>
<h2 id='rmvbinary_EP'>Simulating correlated binary variables using the algorithm
by Emrich and Piedmonte (1991)</h2><span id='topic+rmvbinary_EP'></span>

<h3>Description</h3>

<p>Generation of random sample of binary correlated variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmvbinary_EP(n, R, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmvbinary_EP_+3A_n">n</code></td>
<td>
<p>Sample size</p>
</td></tr>
<tr><td><code id="rmvbinary_EP_+3A_r">R</code></td>
<td>
<p>Correlation matrix</p>
</td></tr>
<tr><td><code id="rmvbinary_EP_+3A_p">p</code></td>
<td>
<p>Vector of marginal probabilities</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements the algorithm proposed by Emrich and
Piedmonte (1991) to generate a random sample of d (=length(p))
correlated binary variables. The sample is generated based on
given marginal probabilities p of the d variables and their
correlation matrix R. The algorithm generates first determines an
appropriate correlation matrix R' for the multivariate normal
distribution. Next, a sample is drawn from N_d(0, R') and each
variable is finnaly dichotomized with respect to p.
</p>


<h3>Value</h3>

<p>Sample (n x p)-matrix with representing a random sample of size n from the specified multivariate binary distribution.
</p>


<h3>Author(s)</h3>

<p>Jochen Kruppa, Klaus Jung
</p>


<h3>References</h3>

<p>Emrich, L.J., Piedmonte, M.R. (1991) A method for generating highdimensional multivariate binary variates. <em>The American Statistician</em>, <strong>45(4)</strong>, 302. doi: <a href="https://doi.org/10.1080/00031305.1991.10475828">10.1080/00031305.1991.10475828</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generation of a random sample
rmvbinary_EP(n = 10, R = diag(2), p = c(0.5, 0.6))
</code></pre>

<hr>
<h2 id='rmvbinary_QA'>Simulating correlated binary variables using the algorithm
by Qaqish (2003)</h2><span id='topic+rmvbinary_QA'></span>

<h3>Description</h3>

<p>Generation of random sample of binary correlated variables
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmvbinary_QA(n, R, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmvbinary_QA_+3A_n">n</code></td>
<td>
<p>Sample size</p>
</td></tr>
<tr><td><code id="rmvbinary_QA_+3A_r">R</code></td>
<td>
<p>Correlation matrix</p>
</td></tr>
<tr><td><code id="rmvbinary_QA_+3A_p">p</code></td>
<td>
<p>Vector of marginal probabilities</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements the algorithm proposed by Qaqish (2003) to
generate a random sample of d (=length(p)) correlated binary
variables. The sample is generated based on given marginal
probabilities p of the d variables and their correlation matrix
R. The algorithm starts by generating a data for the first
variable X_1 and generates succesively the data for X_2, ... based
on their conditional probabilities P(X_j|X_[i-1],...,X_1),
j=1,...,d.
</p>


<h3>Value</h3>

<p>Sample (n x p)-matrix representing a random sample of size n
from the specified multivariate binary distribution.
</p>


<h3>Author(s)</h3>

<p>Jochen Kruppa, Klaus Jung
</p>


<h3>References</h3>

<p>Qaqish, B. F. (2003) A family of multivariate binary distributions for simulating correlated binary variables with specified marginal means and correlations. <em>Biometrika</em>, <strong>90(2)</strong>, 455-463. doi: <a href="https://doi.org/10.1093/biomet/90.2.455">10.1093/biomet/90.2.455</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generation of a random sample
rmvbinary_QA(n = 10, R = diag(2), p = c(0.5, 0.6))
</code></pre>

<hr>
<h2 id='sequence_probs'>Calculation of probabilities for binary sequences</h2><span id='topic+sequence_probs'></span>

<h3>Description</h3>

<p>Calculation of proabilities for binary sequences based on the
final matrix generated by the genetic algorithm
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sequence_probs(Xt)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sequence_probs_+3A_xt">Xt</code></td>
<td>
<p>Representative matrix generated by the genetic algorithm
with <code><a href="#topic+iter_matrix">iter_matrix</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Observation of binary correlated binary data can be expressed as
binary sequences. In the case of two binary variables possible
observations are (0,0), (0,1), (1,0) and (1,1). In general, 2^m
binary sequences are possible, where m is the number of binary
variables. Based on the representative matrix generated by the
genetic algorithm the probability for each binary sequence is
determined.
</p>


<h3>Value</h3>

<p>A vector of probabilities for the binary sequences
</p>


<h3>Author(s)</h3>

<p>Jochen Kruppa, Klaus Jung
</p>


<h3>References</h3>

<p>Kruppa, J., Lepenies, B., &amp; Jung, K. (2018). A genetic algorithm for simulating correlated binary data from biomedical research. <em>Computers in biology and medicine</em>, <strong>92</strong>, 1-8. doi: <a href="https://doi.org/10.1016/j.compbiomed.2017.10.023">10.1016/j.compbiomed.2017.10.023</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Generation of the representive matrix Xt
X0 &lt;- start_matrix(p = c(0.5, 0.6), k = 1000)
Xt &lt;- iter_matrix(X0, R = diag(2), T = 10000, e.min = 0.00001)$Xt

### Calculation of probabilities for binary sequences
sequence_probs(Xt = Xt)
</code></pre>

<hr>
<h2 id='start_matrix'>Setup of the start matrix</h2><span id='topic+start_matrix'></span>

<h3>Description</h3>

<p>Generation of the start matrix with n rows and specified marginal
probabilities p.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>start_matrix(p, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="start_matrix_+3A_p">p</code></td>
<td>
<p>Marginal probabilities of the start matrix.</p>
</td></tr>
<tr><td><code id="start_matrix_+3A_k">k</code></td>
<td>
<p>Number of rows to be generated.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The start matrix needs to be setup for further use in the genetic
algorithm implemented in the function <code><a href="#topic+iter_matrix">iter_matrix</a></code>. For
high-dimensional cases or if the marginal probabilities have
multiple decimal places, the number k of rows should be large (up
to multiple thousand).
</p>


<h3>Value</h3>

<p>A (k x p)-Matrix with with entries 0 and 1 according to
the specified marginal probabilities p.
</p>


<h3>Author(s)</h3>

<p>Jochen Kruppa, Klaus Jung
</p>


<h3>References</h3>

<p>Kruppa, J., Lepenies, B., &amp; Jung, K. (2018). A genetic algorithm for simulating correlated binary data from biomedical research. <em>Computers in biology and medicine</em>, <strong>92</strong>, 1-8. doi: <a href="https://doi.org/10.1016/j.compbiomed.2017.10.023">10.1016/j.compbiomed.2017.10.023</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>X0 &lt;- start_matrix(p = c(0.5, 0.6), k = 10000)

## check if p can be restored
apply(X0, 2, mean)
</code></pre>

<hr>
<h2 id='summary_RHD'>Summary of RHighDim function</h2><span id='topic+summary_RHD'></span>

<h3>Description</h3>

<p>Summary of RHighDim function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summary_RHD(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary_RHD_+3A_object">object</code></td>
<td>
<p>An object provided by the RHighDim function.</p>
</td></tr>
<tr><td><code id="summary_RHD_+3A_...">...</code></td>
<td>
<p>additional arguments affecting the summary produced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Summarizes the test results obtained by the RHighDim function.
</p>


<h3>Value</h3>

<p>No value
</p>


<h3>Author(s)</h3>

<p>Klaus Jung
</p>


<h3>References</h3>

<p>Brunner, E (2009) Repeated measures under non-sphericity. <em>Proceedings of the 6th St. Petersburg Workshop on Simulation</em>, 605-609.
</p>
<p>Jung K, Becker B, Brunner B and Beissbarth T (2011) Comparison of Global Tests for Functional Gene Sets in Two-Group Designs and Selection of Potentially Effect-causing Genes. <em>Bioinformatics</em>, <strong>27</strong>, 1377-1383. doi: <a href="https://doi.org/10.1093/bioinformatics/btr152">10.1093/bioinformatics/btr152</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### Global comparison of a set of 100 genes between two experimental groups.
X1 = matrix(rnorm(1000, 0, 1), 10, 100)
X2 = matrix(rnorm(1000, 0.1, 1), 10, 100)
RHD = RHighDim (X1, X2, paired=FALSE)
summary_RHD(RHD)
</code></pre>

<hr>
<h2 id='TestStatSimple'>Calculates test statistic for RHighDim</h2><span id='topic+TestStatSimple'></span>

<h3>Description</h3>

<p>Calculates test statistic for RHighDim
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TestStatSimple(Y, H)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TestStatSimple_+3A_y">Y</code></td>
<td>
<p>A matrix.</p>
</td></tr>
<tr><td><code id="TestStatSimple_+3A_h">H</code></td>
<td>
<p>A matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list.
</p>

<hr>
<h2 id='TestStatSP'>Calculates test statistic for RHighDim</h2><span id='topic+TestStatSP'></span>

<h3>Description</h3>

<p>Calculates test statistic for RHighDim
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TestStatSP(Y1, Y2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TestStatSP_+3A_y1">Y1</code></td>
<td>
<p>A matrix.</p>
</td></tr>
<tr><td><code id="TestStatSP_+3A_y2">Y2</code></td>
<td>
<p>A matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
