<!DOCTYPE html><html><head><title>Help for package rMEA</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rMEA}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#CCFartefacts'><p>Detection of potential artefacts in CCF results.</p></a></li>
<li><a href='#ccfResNames'><p>Extract the names of the ccf analysis summaries in a MEA objects</p></a></li>
<li><a href='#cohens_d'><p>Cohen's d</p>
A simple function to calculate Cohen's d effect size</a></li>
<li><a href='#colTrans'><p>Transform color</p></a></li>
<li><a href='#diagnosticPlot'><p>Plots the initial, middle and ending part of a MEA object</p></a></li>
<li><a href='#getCCF'><p>Extract ccf values from MEA objects</p></a></li>
<li><a href='#id'><p>Get MEA attributes</p></a></li>
<li><a href='#lagNames'><p>Extract the lag names of a ccf analysis in MEA objects</p></a></li>
<li><a href='#lines.MEA'><p>Adds lines of a <code>MEA</code> object to a Plot</p></a></li>
<li><a href='#MEA'><p><code>MEA</code> class constructor</p></a></li>
<li><a href='#MEAccf'><p>Moving-windows lagged cross-correlation routine for <code>MEA</code> objects</p></a></li>
<li><a href='#MEAdistplot'><p>Distribution of cross-correlations</p></a></li>
<li><a href='#MEAheatmap'><p>Plot a heatmap of dyadic cross-correlations</p></a></li>
<li><a href='#MEAlagplot'><p>Plots the average cross-correlation at different lags</p></a></li>
<li><a href='#MEAlist'><p>Well formatted list of <code>MEA</code> objects</p></a></li>
<li><a href='#MEAmap'><p>Apply a function to a single or a list of MEA objects</p></a></li>
<li><a href='#MEAoutlier'><p>Replace outliers with given values</p></a></li>
<li><a href='#MEAreplace'><p>Substitute values from MEA data</p></a></li>
<li><a href='#MEAscale'><p>Scaling (and centering) of motion energy time-series</p></a></li>
<li><a href='#MEAsmooth'><p>Moving average smoothing for motion energy data</p></a></li>
<li><a href='#plot.MEA'><p>Plots an object of class <code>MEA</code></p></a></li>
<li><a href='#readMEA'><p>Import MEA raw data</p></a></li>
<li><a href='#setGroup'><p>Sets the group of MEA objects</p></a></li>
<li><a href='#shuffle'><p>Shuffle MEA data (between subjects)</p></a></li>
<li><a href='#shuffle_segments'><p>Shuffle MEA data (within subjects)</p></a></li>
<li><a href='#timeMaster'><p>Transform time values between different formats</p></a></li>
<li><a href='#writeMEA'><p>Exports analyzed MEA data to .txt files</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Synchrony in Motion Energy Analysis (MEA) Time-Series</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-02-17</td>
</tr>
<tr>
<td>Author:</td>
<td>Johann R. Kleinbub, Fabian Ramseyer</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Johann R. Kleinbub &lt;johann.kleinbub@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A suite of tools useful to read, visualize and export bivariate motion energy time-series. Lagged synchrony between subjects can be analyzed through windowed cross-correlation. Surrogate data generation allows an estimation of pseudosynchrony that helps to estimate the effect size of the observed synchronization. Kleinbub, J. R., &amp; Ramseyer, F. T. (2020). rMEA: An R package to assess nonverbal synchronization in motion energy analysis time-series. Psychotherapy research, 1-14. &lt;<a href="https://doi.org/10.1080%2F10503307.2020.1844334">doi:10.1080/10503307.2020.1844334</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/kleinbub/rMEA">https://github.com/kleinbub/rMEA</a> <a href="https://psync.ch">https://psync.ch</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/kleinbub/rMEA/issues">https://github.com/kleinbub/rMEA/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>grDevices, graphics, methods, stats, utils</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-02-17 17:21:27 UTC; Kleinbub</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-02-17 18:12:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='CCFartefacts'>Detection of potential artefacts in CCF results.</h2><span id='topic+CCFartefacts'></span>

<h3>Description</h3>

<p>High synchronization values for extended time durations may be the effect of artefacts in the MEA data. For instance subject 2 movement may have
been captured by subject 1's camera (or ROI) as well, or some environment characteristic (e.g. light) is changing for both cameras (or ROIs). This function identifies
those moments allowing to inspect the original videos with temporal precision.
**Please note that is impossible to discriminate real high synchronization phenomena from artefacts without inspecting the
original videos.**
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CCFartefacts(mea, threshold, delta = 1, duration = attributes(mea)$ccf$inc)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CCFartefacts_+3A_mea">mea</code></td>
<td>
<p>an object of class <code>MEA</code> or a list of <code>MEA</code> objects (see function <code><a href="#topic+readMEA">readMEA</a></code>)</p>
</td></tr>
<tr><td><code id="CCFartefacts_+3A_threshold">threshold</code></td>
<td>
<p>A single numeric value specifying the absolute correlation value above (and below) which a window must be considered artefactual.</p>
</td></tr>
<tr><td><code id="CCFartefacts_+3A_delta">delta</code></td>
<td>
<p>Integer. The maximum numbers of consecutive CCF windows below threshold to be allowed in an artefactual streak without determining its end. A value of 1 is
default and recommended, but it can be increased if the reports become too long (e.g. with very noisy source material, or when working with very small ccf windows),  to achieve
the desired level of reporting detail.</p>
</td></tr>
<tr><td><code id="CCFartefacts_+3A_duration">duration</code></td>
<td>
<p>Integer. Minimum duration of the artefacts to be reported. Note that artefacts smaller than the CCF windows increments cannot be detected.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function only considers lag_zero correlations as MEA artefacts are expected to be non-lagged phenomena.
</p>


<h3>Value</h3>

<p>a data.frame object with all potential artefact epochs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## read the first 4 minutes of the normal sample
## (intake interviews of patients that carried on therapy)
path_normal &lt;- system.file("extdata/normal", package = "rMEA")
mea_normal &lt;- readMEA(path_normal, sampRate = 25, s1Col = 1, s2Col = 2,
                      s1Name = "Patient", s2Name = "Therapist",
                      idOrder = c("id","session"), idSep="_", skip=1, nrow = 6000)
mea_normal &lt;- MEAccf(mea_normal, lagSec = 5, winSec = 30, incSec = 10, ABS = FALSE)

## find potential artefacts with various granularity of reporting
print(CCFartefacts(mea_normal, threshold = 0.2, delta=1))
print(CCFartefacts(mea_normal, threshold = 0.2, delta=5))
print(CCFartefacts(mea_normal, threshold = 0.2, delta=5, duration=60))

</code></pre>

<hr>
<h2 id='ccfResNames'>Extract the names of the ccf analysis summaries in a MEA objects</h2><span id='topic+ccfResNames'></span>

<h3>Description</h3>

<p>Extract the names of the ccf analysis summaries in a MEA objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ccfResNames(mea)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ccfResNames_+3A_mea">mea</code></td>
<td>
<p>an object of class <code>MEA</code> or a list of <code>MEA</code> objects (see function <code><a href="#topic+readMEA">readMEA</a></code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector containing the labels of the ccfRes indexes
</p>

<hr>
<h2 id='cohens_d'>Cohen's d
A simple function to calculate Cohen's d effect size</h2><span id='topic+cohens_d'></span>

<h3>Description</h3>

<p>Cohen's d
A simple function to calculate Cohen's d effect size
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cohens_d(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cohens_d_+3A_x">x</code>, <code id="cohens_d_+3A_y">y</code></td>
<td>
<p>two numeric vectors containing the scores of the two samples</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Generates two samples with means distance of 1 sd
x = rnorm(1000, mean = 10, sd = 1.5)
y = rnorm(1000, mean = 11.5, sd = 1.5)
# cohen's d should approximate to 1
cohens_d(x,y)
</code></pre>

<hr>
<h2 id='colTrans'>Transform color</h2><span id='topic+colTrans'></span>

<h3>Description</h3>

<p>Transform color
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colTrans(col, luminosity = NA, alpha = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colTrans_+3A_col">col</code></td>
<td>
<p>a color to begin with in hex format</p>
</td></tr>
<tr><td><code id="colTrans_+3A_luminosity">luminosity</code></td>
<td>
<p>numeric. negative numbers darken the color, positive lighten it. Eg: a value of -2 make the color two times darker.</p>
</td></tr>
<tr><td><code id="colTrans_+3A_alpha">alpha</code></td>
<td>
<p>numeric from 0 to 1. the value of opacity of the resulting color</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a color string
</p>

<hr>
<h2 id='diagnosticPlot'>Plots the initial, middle and ending part of a MEA object</h2><span id='topic+diagnosticPlot'></span>

<h3>Description</h3>

<p>This is typically useful to check if the motion energy time-series are good.
The middle section is chosen randomly among possible middle sections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diagnosticPlot(mea, width = 60, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diagnosticPlot_+3A_mea">mea</code></td>
<td>
<p>an object of class <code>MEA</code> (see function <code><a href="#topic+readMEA">readMEA</a></code>).</p>
</td></tr>
<tr><td><code id="diagnosticPlot_+3A_width">width</code></td>
<td>
<p>integer. The number of seconds to be plotted for each panel</p>
</td></tr>
<tr><td><code id="diagnosticPlot_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>plot</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Motion energy time-series should always be visually inspected for possible artifacts. Periodic peaks or drops in time-series are indicators of e.g. key-frames or duplicated video-frames.
For further information regarding the program MEA, please refer to the documentation available at <code>http://www.psync.ch</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## read a single file
path_normal &lt;- system.file("extdata/normal/200_01.txt", package = "rMEA")
mea_normal &lt;- readMEA(path_normal, sampRate = 25, s1Col = 1, s2Col = 2,
                     s1Name = "Patient", s2Name = "Therapist", skip=1,
                     idOrder = c("id","session"), idSep="_")
## Visual inspection of the data
diagnosticPlot(mea_normal[[1]])

</code></pre>

<hr>
<h2 id='getCCF'>Extract ccf values from MEA objects</h2><span id='topic+getCCF'></span>

<h3>Description</h3>

<p>Extract ccf values from MEA objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getCCF(mea, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getCCF_+3A_mea">mea</code></td>
<td>
<p>an object of class <code>MEA</code> or a list of <code>MEA</code> objects (see function <code><a href="#topic+readMEA">readMEA</a></code>)</p>
</td></tr>
<tr><td><code id="getCCF_+3A_type">type</code></td>
<td>
<p>A character vector defining which ccf must be extracted.
Either &quot;matrix&quot;, &quot;fullMatrix&quot;, one of the ccfRes indexes identified with <code><a href="#topic+ccfResNames">ccfResNames</a></code>,
or the name of one lag value which can be identified with <code><a href="#topic+lagNames">lagNames</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>type="matrix"</code>, the ccf matrix with discrete lag-seconds is returned.
If <code>type="fullMatrix"</code>, the whole ccf matrix with all lags is returned.
Otherwise a vector containing the ccf
time-series for the selected lag, or aggregated values is returned.
If <code>mea</code> is a list, the return value is a list of the individual ccf of each MEA object.
</p>

<hr>
<h2 id='id'>Get MEA attributes</h2><span id='topic+id'></span><span id='topic+group'></span><span id='topic+session'></span><span id='topic+sampRate'></span><span id='topic+s1Name'></span><span id='topic+s2Name'></span><span id='topic+uid'></span>

<h3>Description</h3>

<p>Get MEA attributes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>id(mea)

group(mea)

session(mea)

sampRate(mea)

s1Name(mea)

s2Name(mea)

uid(mea)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="id_+3A_mea">mea</code></td>
<td>
<p>an object of class <code>MEA</code> or a list of <code>MEA</code> objects (see function <code><a href="#topic+readMEA">readMEA</a></code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>if a well formatted list of MEA objects is provided, the function returns a vector
of results for id, session, group and uid. sampRate, s1Name, and s2Name return always a single
value, as they are not allowed to be mixed.
</p>


<h3>Value</h3>

<p>A string or a vector of strings containing the metadata.
</p>

<hr>
<h2 id='lagNames'>Extract the lag names of a ccf analysis in MEA objects</h2><span id='topic+lagNames'></span>

<h3>Description</h3>

<p>Extract the lag names of a ccf analysis in MEA objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lagNames(mea)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lagNames_+3A_mea">mea</code></td>
<td>
<p>an object of class <code>MEA</code> or a list of <code>MEA</code> objects (see function <code><a href="#topic+readMEA">readMEA</a></code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a vector containing the labels of the lag values
</p>

<hr>
<h2 id='lines.MEA'>Adds lines of a <code>MEA</code> object to a Plot</h2><span id='topic+lines.MEA'></span>

<h3>Description</h3>

<p>Adds lines of a <code>MEA</code> object to a Plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MEA'
lines(x, from = 0, to = NULL, duration = NULL, ccf = F, rescale = F, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lines.MEA_+3A_x">x</code></td>
<td>
<p>an object of class <code>MEA</code> (see function <code><a href="#topic+readMEA">readMEA</a></code>).</p>
</td></tr>
<tr><td><code id="lines.MEA_+3A_from">from</code></td>
<td>
<p>either an integer or a string in the format hh:mm:ss or mm:ss representing the starting second.</p>
</td></tr>
<tr><td><code id="lines.MEA_+3A_to">to</code></td>
<td>
<p>if <code>duration</code> is not specified, either an integer or a string in the format hh:mm:ss or mm:ss representing the ending second.</p>
</td></tr>
<tr><td><code id="lines.MEA_+3A_duration">duration</code></td>
<td>
<p>if <code>to</code> is not specified, either an integer or a string in the format hh:mm:ss or mm:ss representing the amount of seconds to be plotted.</p>
</td></tr>
<tr><td><code id="lines.MEA_+3A_ccf">ccf</code></td>
<td>
<p>either FALSE or a string representing the type of ccf to be overlayed. Possible values can be found with the <code><a href="#topic+ccfResNames">ccfResNames</a></code> function.</p>
</td></tr>
<tr><td><code id="lines.MEA_+3A_rescale">rescale</code></td>
<td>
<p>logical. Should the motion energy time-series be rescaled?</p>
</td></tr>
<tr><td><code id="lines.MEA_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="graphics.html#topic+lines">lines</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: if more of than 10s of trailing zeroes are found at the end of both s1 and s2 signals they are truncated.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## read a single file
path_normal &lt;- system.file("extdata/normal/200_01.txt", package = "rMEA")
mea_normal &lt;- readMEA(path_normal, sampRate = 25, s1Col = 1, s2Col = 2,
                     s1Name = "Patient", s2Name = "Therapist", skip=1,
                     idOrder = c("id","session"), idSep="_")
mea_normal &lt;- MEAccf(mea_normal, lagSec = 5, winSec = 30, incSec = 10, ABS = FALSE)
mea_smoothed &lt;- MEAsmooth(mea_normal)
## Visual inspection of the data
plot(mea_normal[[1]], from = 240, duration=20)
lines(mea_smoothed[[1]], from = 240, duration=20, lty=3, col=c(1,2))
</code></pre>

<hr>
<h2 id='MEA'><code>MEA</code> class constructor</h2><span id='topic+MEA'></span><span id='topic+is.MEA'></span>

<h3>Description</h3>

<p>The preferred way to create an object of class <code>MEA</code> is through the function <code><a href="#topic+readMEA">readMEA</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MEA(
  dataframe,
  sampRate,
  filter = "raw",
  id,
  session,
  group,
  s1Name,
  s2Name,
  uid = paste(group, id, session, sep = "_")
)

is.MEA(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MEA_+3A_dataframe">dataframe</code></td>
<td>
<p>a data frame with 2 columns containing MEA data respectively for subject 1 (s1) and subject 2 (s2).</p>
</td></tr>
<tr><td><code id="MEA_+3A_samprate">sampRate</code></td>
<td>
<p>integer. The sampling rate of the MEA data. Normally derived from the framerate of the analyzed video sequence (frames per second; fps).</p>
</td></tr>
<tr><td><code id="MEA_+3A_filter">filter</code></td>
<td>
<p>a string describing the pre-processing that has been applied on the raw data.</p>
</td></tr>
<tr><td><code id="MEA_+3A_id">id</code></td>
<td>
<p>a string representing a unique identifier of the dyad that the MEA data belong to.</p>
</td></tr>
<tr><td><code id="MEA_+3A_session">session</code></td>
<td>
<p>an integer representing the session (or experiment, interaction, etc); if each dyad is measured only once, the default value is 1.</p>
</td></tr>
<tr><td><code id="MEA_+3A_group">group</code></td>
<td>
<p>a string naming the group the dyad belongs to, such as diagnostic group, clinic, etc.</p>
</td></tr>
<tr><td><code id="MEA_+3A_s1name">s1Name</code></td>
<td>
<p>a string naming subject 1.</p>
</td></tr>
<tr><td><code id="MEA_+3A_s2name">s2Name</code></td>
<td>
<p>a string naming subject 2.</p>
</td></tr>
<tr><td><code id="MEA_+3A_uid">uid</code></td>
<td>
<p>a string providing a unique identifier of the file. By default 'group_id_session'.</p>
</td></tr>
<tr><td><code id="MEA_+3A_x">x</code></td>
<td>
<p>object to be tested.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is advised to <strong>not</strong> create the <code>MEA</code> object manually but to always use the function <code><a href="#topic+readMEA">readMEA</a></code> instead.
</p>


<h3>Value</h3>

<p>A list containing three objects:
</p>
<p>MEA: the dataframe containing the motion energy data
</p>
<p>ccf: the matrix of lagged cross-correlations between s1 and s2 (if <code><a href="#topic+MEAccf">MEAccf</a></code> was run)
</p>
<p>ccfRes: some useful row marginals
</p>
<p><code>is.MEA</code> returns TRUE if and only if its argument is of class <code>MEA</code>
</p>

<hr>
<h2 id='MEAccf'>Moving-windows lagged cross-correlation routine for <code>MEA</code> objects</h2><span id='topic+MEAccf'></span>

<h3>Description</h3>

<p>This function analyzes a bivariate MEA signal represented by two time-series (subject 1 &quot;s1&quot;, subject 2 &quot;s2&quot;) resulting from a dyadic interaction.
MEAccf performs windowed cross-correlations with specified increments. The cross-correlation analysis is repeated for each
lag step, with discrete increments of 1 sample in both directions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MEAccf(mea, lagSec, winSec, incSec, r2Z = T, ABS = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MEAccf_+3A_mea">mea</code></td>
<td>
<p>an object of class <code>MEA</code> or a list of <code>MEA</code> objects (see function <code><a href="#topic+readMEA">readMEA</a></code>)</p>
</td></tr>
<tr><td><code id="MEAccf_+3A_lagsec">lagSec</code></td>
<td>
<p>an integer specifying the maximum number of lags (in seconds) for which the time-series will be shifted forwards and backwards.</p>
</td></tr>
<tr><td><code id="MEAccf_+3A_winsec">winSec</code></td>
<td>
<p>an integer specifying the cross-correlation window size (in seconds).</p>
</td></tr>
<tr><td><code id="MEAccf_+3A_incsec">incSec</code></td>
<td>
<p>an integer specifying the step size (in seconds) between successive windows. Values lower than <code>winSec</code> result in overlapping windows.</p>
</td></tr>
<tr><td><code id="MEAccf_+3A_r2z">r2Z</code></td>
<td>
<p>logical. The default value TRUE applies Fisher's r to Z transformation (inverse hyperbolic tangent function) to all computed correlations.</p>
</td></tr>
<tr><td><code id="MEAccf_+3A_abs">ABS</code></td>
<td>
<p>logical. The default value TRUE transforms the (Fisher's Z-transformed) correlations to absolute values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The choice of <code>lagSec</code> depends on the type of synchronization expected from the specific interaction. In the literature, lags of ±5 seconds have been reported by multiple authors.
Function <code><a href="#topic+MEAlagplot">MEAlagplot</a></code> can be used for visual inspection of the appropriateness of the chosen lag.
</p>
<p>The choice of <code>winSec</code> represents the temporal resolution of the analysis.
The combination of <code>incSec</code> and <code>winSec</code> settings has a big impact on the results. These parameters should be chosen carefully, guided by theoretical and empirical considerations.
</p>
<p>If <code>r2Z</code> is TRUE, values of Fisher's Z are constrained to an upper bound of 10.
</p>
<p>Using absolute values (<code>ABS</code>) treats positive and negative cross-correlations as equal. The underlying assumption is that both simultaneous movement (positive correlation) and when
one subject accelerates and the other decelerates (negative correlation), are both signs of interrelatedness and should thus contribute equally to overall synchrony.
</p>


<h3>Value</h3>

<p>The function returns a copy of the <code>mea</code> object in which the <code>ccf</code> and <code>ccfRes</code> objects are populated. <code>mea$ccf</code> includes the complete lagged cross-correlation table
for each window and each lag of S1 and S2 MEA signals. <code>mea$ccfRes</code> contains various aggregate values, typically used in research:
</p>

<ul>
<li><p> lag_zero: a numeric vector containing for each window, the non-lagged cross-correlation value.
</p>
</li>
<li><p> all_lags: a numeric vector containing  for each window, the average across all lags.
</p>
</li>
<li><p> s1_lead/s2_lead: a numeric vector containing for each window, the average of positive/negative lags, summing up the strength of S1/S2 in &quot;leading&quot; the synchronization.
</p>
</li>
<li><p> s1_lead_0/s2_lead_0: the same as s1_lead/s2_lead, but including lag_zero values in the average.
</p>
</li>
<li><p> bestLag: for each window, the lag value (in seconds) that has the highest correlation value.
</p>
</li>
<li><p> grandAver: a single numeric value of the grand-average of the whole cross-correlation table.
</p>
</li>
<li><p> winTimes: a data frame containing the start and end times of each window in the format hh:mm:ss
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>## read a single file
path_normal &lt;- system.file("extdata/normal/200_01.txt", package = "rMEA")
mea_normal &lt;- readMEA(path_normal, sampRate = 25, s1Col = 1, s2Col = 2,
                     s1Name = "Patient", s2Name = "Therapist", skip=1,
                     idOrder = c("id","session"), idSep="_")

## perform ccf analysis
mea_ccf = MEAccf(mea_normal, lagSec = 5, winSec = 60, incSec = 30, r2Z = TRUE, ABS = TRUE)
summary(mea_ccf)

##extract ccf values
res &lt;- getCCF(mea_ccf, type="grandAver")
print(res)

#visualize the analysis results for the first file
MEAheatmap(mea_ccf[[1]])

</code></pre>

<hr>
<h2 id='MEAdistplot'>Distribution of cross-correlations</h2><span id='topic+MEAdistplot'></span>

<h3>Description</h3>

<p>Plots the distribution of the average cross-correlations in a list of <code>MEA</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MEAdistplot(
  mea,
  contrast = FALSE,
  by = c("none", "group", "id", "session"),
  by.group = FALSE,
  sub.line = 0.5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MEAdistplot_+3A_mea">mea</code></td>
<td>
<p>a well formatted list of <code>MEA</code> objects (see function <code><a href="#topic+MEAlist">MEAlist</a></code>).</p>
</td></tr>
<tr><td><code id="MEAdistplot_+3A_contrast">contrast</code></td>
<td>
<p>either FALSE or a list of <code>MEA</code> objects to be used as a contrast</p>
</td></tr>
<tr><td><code id="MEAdistplot_+3A_by">by</code></td>
<td>
<p>Either &quot;none&quot;, &quot;group&quot;, &quot;id&quot;, or &quot;session&quot;. Defines the grouping to be used.</p>
</td></tr>
<tr><td><code id="MEAdistplot_+3A_by.group">by.group</code></td>
<td>
<p>deprecated argument. Use by=&quot;group&quot; instead.</p>
</td></tr>
<tr><td><code id="MEAdistplot_+3A_sub.line">sub.line</code></td>
<td>
<p>on which margin line should the Effect Size subtitle be printed, starting at 0 counting outwards.</p>
</td></tr>
<tr><td><code id="MEAdistplot_+3A_...">...</code></td>
<td>
<p>further graphical parameters passed to  <code><a href="base.html#topic+plot">plot</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>contrast</code> is defined, then a normalized difference (Cohen's <em>d</em>) between the means of each group and the contrast is provided.
Otherwise, if the <code>mea</code> object has 3 or less groups, Cohen's <em>d</em> will be calculated on the group differences.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## This example is excluded from test as it may take more than 10s to run
## read the first 4 minutes of the normal sample
##   (intake interviews of patients that carried on therapy)
path_normal &lt;- system.file("extdata/normal", package = "rMEA")
mea_normal &lt;- readMEA(path_normal, sampRate = 25, s1Col = 1, s2Col = 2,
                     s1Name = "Patient", s2Name = "Therapist",
                     idOrder = c("id","session"), idSep="_", skip=1, nrow = 6000)
mea_normal &lt;- setGroup(mea_normal, "normal")

## read the dropout sample (intake interviews of patients that dropped out)
path_dropout &lt;- system.file("extdata/dropout", package = "rMEA")
mea_dropout &lt;- readMEA(path_dropout, sampRate = 25, s1Col = 1, s2Col = 2,
                     s1Name = "Patient", s2Name = "Therapist",
                     idOrder = c("id","session"), idSep="_", skip=1, nrow = 6000)
mea_dropout &lt;- setGroup(mea_dropout, "dropout")

## Combine into a single object
mea_all = c(mea_normal, mea_dropout)

## Create a shuffled sample
mea_rand = shuffle(mea_all, 20)

## Compute ccf
mea_all = MEAccf(mea_all, lagSec = 5, winSec = 60, incSec = 30, r2Z = TRUE, ABS = TRUE)
mea_rand = MEAccf(mea_rand, lagSec = 5, winSec = 60, incSec = 30, r2Z = TRUE, ABS = TRUE)

## Visualize the effects:

MEAdistplot(mea_all, contrast = mea_rand, by.group = TRUE)

</code></pre>

<hr>
<h2 id='MEAheatmap'>Plot a heatmap of dyadic cross-correlations</h2><span id='topic+MEAheatmap'></span>

<h3>Description</h3>

<p>Graphical representation of the lagged cross-correlations in time. Provides an intuitive description of synchronization dynamics.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MEAheatmap(
  mea,
  legendSteps = 10,
  rescale = FALSE,
  colors = c("#F5FBFF", "#86E89E", "#FFF83F", "#E8A022", "#FF3700"),
  bias = 1,
  mirror = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MEAheatmap_+3A_mea">mea</code></td>
<td>
<p>an object of class <code>MEA</code> (see function <code><a href="#topic+readMEA">readMEA</a></code>).</p>
</td></tr>
<tr><td><code id="MEAheatmap_+3A_legendsteps">legendSteps</code></td>
<td>
<p>integer. the number of levels used for the color-coding of the legend.</p>
</td></tr>
<tr><td><code id="MEAheatmap_+3A_rescale">rescale</code></td>
<td>
<p>logical. If TRUE, the color range will represent the minimum and maximum of the data. Otherwise the theoretical correlation range -1 to 1.</p>
</td></tr>
<tr><td><code id="MEAheatmap_+3A_colors">colors</code></td>
<td>
<p>a vector of colors defining the plot scale.</p>
</td></tr>
<tr><td><code id="MEAheatmap_+3A_bias">bias</code></td>
<td>
<p>a positive number. Allows to skew the color scale. Values larger than 1 give more widely spaced colors at the high end, and vice versa.</p>
</td></tr>
<tr><td><code id="MEAheatmap_+3A_mirror">mirror</code></td>
<td>
<p>logical. If TRUE, colors are mirrored for negative correlation values. This has effect only if <code><a href="#topic+MEAccf">MEAccf</a></code> was run with <code>ABS=FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cross-correlation values are rescaled to be in a range from 0 to 1 before plotting.
</p>

<hr>
<h2 id='MEAlagplot'>Plots the average cross-correlation at different lags</h2><span id='topic+MEAlagplot'></span>

<h3>Description</h3>

<p>Provides a graphical representation of the comparison between two lists of <code>MEA</code> objects.
The X-axis represents the lag values over which cross-correlation was calculated (in seconds), the Y-axis represents the averaged strength of the cross-correlation.
Typically, the  is useful for a visual inspection of the strength of synchrony from real dyads in relation to synchrony expected by coincidence (pseudosynchrony).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MEAlagplot(mea, contrast = F, by.group = T, sub.line = 0.5, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MEAlagplot_+3A_mea">mea</code></td>
<td>
<p>a list of <code>MEA</code> objects (see function <code><a href="#topic+MEAlist">MEAlist</a></code>).</p>
</td></tr>
<tr><td><code id="MEAlagplot_+3A_contrast">contrast</code></td>
<td>
<p>either FALSE or a list of <code>MEA</code> objects to be used as a contrast</p>
</td></tr>
<tr><td><code id="MEAlagplot_+3A_by.group">by.group</code></td>
<td>
<p>logical. Should the different groups of <code>mea</code> be plotted separately?</p>
</td></tr>
<tr><td><code id="MEAlagplot_+3A_sub.line">sub.line</code></td>
<td>
<p>on which margin line should the 'social presence' subtitle be printed, starting at 0 counting outwards.</p>
</td></tr>
<tr><td><code id="MEAlagplot_+3A_...">...</code></td>
<td>
<p>further arguments and <code><a href="graphics.html#topic+par">par</a></code> parameters passed to <code><a href="base.html#topic+plot">plot</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A typical application of <code>MEAlagplot</code> is to represent the difference between real dyads and random dyads obtained through a <code><a href="#topic+shuffle">shuffle</a></code> procedure.
It may also be used to see the difference among various filtering procedures or different regions of interest (e.g. head-synchrony versus body-synchrony, female vs. male dyads, etc).
</p>
<p>Percentages indicate the relative amount of synchrony where the values are higher than the contrast sample.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## This example is excluded from test as it takes more than 10s to run
## read the first 4 minutes of the normal sample
##   (intake interviews of patients that carried on therapy)
path_normal &lt;- system.file("extdata/normal", package = "rMEA")
mea_normal &lt;- readMEA(path_normal, sampRate = 25, s1Col = 1, s2Col = 2,
                     s1Name = "Patient", s2Name = "Therapist",
                     idOrder = c("id","session"), idSep="_", skip=1, nrow = 6000)
mea_normal &lt;- setGroup(mea_normal, "normal")

## read the dropout sample (intake interviews of patients that dropped out)
path_dropout &lt;- system.file("extdata/dropout", package = "rMEA")
mea_dropout &lt;- readMEA(path_dropout, sampRate = 25, s1Col = 1, s2Col = 2,
                     s1Name = "Patient", s2Name = "Therapist",
                     idOrder = c("id","session"), idSep="_", skip=1, nrow = 6000)
mea_dropout &lt;- setGroup(mea_dropout, "dropout")

## Combine into a single object
mea_all = c(mea_normal, mea_dropout)

## Create a shuffled sample
mea_rand = shuffle(mea_all, 20)

## Compute ccf
mea_all = MEAccf(mea_all, lagSec = 5, winSec = 60, incSec = 30, r2Z = TRUE, ABS = TRUE)
mea_rand = MEAccf(mea_rand, lagSec = 5, winSec = 60, incSec = 30, r2Z = TRUE, ABS = TRUE)

## Visualize the effects:

MEAlagplot(mea_all, contrast = mea_rand, by.group = TRUE)

</code></pre>

<hr>
<h2 id='MEAlist'>Well formatted list of <code>MEA</code> objects</h2><span id='topic+MEAlist'></span><span id='topic+is.MEAlist'></span>

<h3>Description</h3>

<p>This constructor function checks if all the supplied <code>MEA</code> objects share the same sampling rate, pre-processing, and metadata,
and returns an object with additional attributes summarizing the contained <code>MEA</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MEAlist(listOfMea)

is.MEAlist(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MEAlist_+3A_listofmea">listOfMea</code></td>
<td>
<p>a list containing <code>MEA</code> objects</p>
</td></tr>
<tr><td><code id="MEAlist_+3A_x">x</code></td>
<td>
<p>object to be tested.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>MEAlist</code>
</p>
<p><code>is.MEAlist</code> returns TRUE if and only if its argument is of class <code>MEAlist</code>
</p>

<hr>
<h2 id='MEAmap'>Apply a function to a single or a list of MEA objects</h2><span id='topic+MEAmap'></span>

<h3>Description</h3>

<p>MEApply is a wrapper to <code><a href="base.html#topic+do.call">do.call</a></code> that allows to apply a function on the motion energy data of one or multiple <code>MEA</code> objects. Complex constructions are possible, see details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MEAmap(mea, FUN, label = "", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MEAmap_+3A_mea">mea</code></td>
<td>
<p>an object of class <code>MEA</code> or a list of <code>MEA</code> objects (see function <code><a href="#topic+readMEA">readMEA</a></code>)</p>
</td></tr>
<tr><td><code id="MEAmap_+3A_fun">FUN</code></td>
<td>
<p>function to apply, found via <code><a href="base.html#topic+match.fun">match.fun</a></code>.</p>
</td></tr>
<tr><td><code id="MEAmap_+3A_label">label</code></td>
<td>
<p>a character vector to update the 'filter' attribute of <code>mea</code>.</p>
</td></tr>
<tr><td><code id="MEAmap_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>FUN</code>. If a function is provided,
it will be run on each MEA object and then passed as an argument to <code>FUN</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>FUN</code> will be applied on the motion energy time-series of <code>MEA</code> objects, which is stored as a data frame with 2 columns, respectively for s1 and s2.
</p>


<h3>Value</h3>

<p>an object of the same class of the provided <code>'mea'</code> object, with the transformed motion energy data
</p>

<hr>
<h2 id='MEAoutlier'>Replace outliers with given values</h2><span id='topic+MEAoutlier'></span>

<h3>Description</h3>

<p>Sometimes motion energy analysis generates excessively high peaks resulting from video artifacts or other anomalies in the video source.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MEAoutlier(
  mea,
  threshold = function(x) {     stats::sd(x) * 10 },
  direction = c("greater", "less"),
  replace = NA
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MEAoutlier_+3A_mea">mea</code></td>
<td>
<p>an object of class <code>MEA</code> or a list of <code>MEA</code> objects (see function <code><a href="#topic+readMEA">readMEA</a></code>)</p>
</td></tr>
<tr><td><code id="MEAoutlier_+3A_threshold">threshold</code></td>
<td>
<p>a numeric value, or a function returning the threshold value to consider data as outliers.</p>
</td></tr>
<tr><td><code id="MEAoutlier_+3A_direction">direction</code></td>
<td>
<p>a text string. One of &quot;<code>greater</code>&quot; or &quot;<code>less</code>&quot;: can be abbreviated.</p>
</td></tr>
<tr><td><code id="MEAoutlier_+3A_replace">replace</code></td>
<td>
<p>a numeric, NULL, or NA value to use as substitution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The same <code>mea</code> object with all extreme values substituted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## read the first 4 minutes of the normal sample
##   (intake interviews of patients that carried on therapy)
path_normal &lt;- system.file("extdata/normal", package = "rMEA")
mea_raw &lt;- readMEA(path_normal, sampRate = 25, s1Col = 1, s2Col = 2,
                     s1Name = "Patient", s2Name = "Therapist",
                     idOrder = c("id","session"), idSep="_", skip=1, nrow = 6000)

## Remove extreme values, higher than 10 times the standard deviation
mea_clean = MEAoutlier(mea_raw, threshold=function(x){sd(x)*10}, direction = "greater")
</code></pre>

<hr>
<h2 id='MEAreplace'>Substitute values from MEA data</h2><span id='topic+MEAreplace'></span>

<h3>Description</h3>

<p>This function allows to substitute MEA data from a list of time epochs. This is useful to mark and remove artefacts,
or to substitute extreme values.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MEAreplace(mea, epochs, replacement, filterLabel = "replaced")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MEAreplace_+3A_mea">mea</code></td>
<td>
<p>an object of class <code>MEA</code> or a list of <code>MEA</code> objects (see function <code><a href="#topic+readMEA">readMEA</a></code>)</p>
</td></tr>
<tr><td><code id="MEAreplace_+3A_epochs">epochs</code></td>
<td>
<p>a data.frame containing a list of epochs that must be changed (see Details)</p>
</td></tr>
<tr><td><code id="MEAreplace_+3A_replacement">replacement</code></td>
<td>
<p>the value used to mark artefacts. Use 'NA' to remove artefacts and '0' to apply thresholds.
Other values are allowed but should not be used without a good reason.</p>
</td></tr>
<tr><td><code id="MEAreplace_+3A_filterlabel">filterLabel</code></td>
<td>
<p>can be used to update the <code>filter</code> attribute, to keep track of the data transformations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>the <code>artefacts</code> data.frame must contain a &quot;start&quot; and &quot;end&quot; columns, with the boundaries of the epochs that must be
marked as artefacts. The start and end values can be either integers (denoting seconds), or string values in the format hh:mm:ss, or mm:ss.
Furthermore the data.frame must contain a <code>uid</code> column containing strings in the format &quot;group_id_session&quot;, OR three columns <code>group, id, session</code>
presenting the information separately. Data identifiers must match those of the <code>mea</code> object.
</p>
<p>The data.frame can be either hand crafted, for instance by importing a csv file (see <code><a href="utils.html#topic+read.table">read.table</a></code>), or
generated through the packages own artefact detection tools such as <code><a href="#topic+CCFartefacts">CCFartefacts</a></code>
</p>


<h3>Value</h3>

<p>returns the same <code>MEA</code> or <code>MEAlist</code> object, with all artefactual data substituted.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' ## read the first 4 minutes of the normal sample
## (intake interviews of patients that carried on therapy)
path_normal &lt;- system.file("extdata/normal", package = "rMEA")
mea_normal &lt;- readMEA(path_normal, sampRate = 25, s1Col = 1, s2Col = 2,
                      s1Name = "Patient", s2Name = "Therapist",
                      idOrder = c("id","session"), idSep="_", skip=1, nrow = 6000)
mea_normal &lt;- MEAccf(mea_normal, lagSec = 5, winSec = 30, incSec = 10, ABS = FALSE)

## find potential artefacts
artefacts = CCFartefacts(mea_normal, threshold = 0.2, delta=1)

##replace values
mea_replaced &lt;- MEAreplace(mea_normal, epochs = artefacts,
                           replace = NA, filterLabel = "artefacts deletion")

#visualize results on first case
plot(mea_normal$all_200_1)
plot(mea_replaced$all_200_1)


</code></pre>

<hr>
<h2 id='MEAscale'>Scaling (and centering) of motion energy time-series</h2><span id='topic+MEAscale'></span>

<h3>Description</h3>

<p>Scaling (and centering) of motion energy time-series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MEAscale(mea, scale = "sd", ..., center = F, removeNA = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MEAscale_+3A_mea">mea</code></td>
<td>
<p>an object of class <code>MEA</code> or a list of <code>MEA</code> objects (see function <code><a href="#topic+readMEA">readMEA</a></code>)</p>
</td></tr>
<tr><td><code id="MEAscale_+3A_scale">scale</code></td>
<td>
<p>either a numeric value or a function to be applied to each motion
energy time-series to calculate a scaling factor. Default is standard deviation.</p>
</td></tr>
<tr><td><code id="MEAscale_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code>scale</code> if it is a function.</p>
</td></tr>
<tr><td><code id="MEAscale_+3A_center">center</code></td>
<td>
<p>either a logical value or a numeric vector of length 2 specifying separate centering values for s1 and s2.</p>
</td></tr>
<tr><td><code id="MEAscale_+3A_removena">removeNA</code></td>
<td>
<p>logical. If <code>scale</code> is a function, defines whether NAs be removed prior to calculating the scaling factor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>scale</code> is a function, it is found by a call to  <code><a href="base.html#topic+match.fun">match.fun</a></code> and typically is either a function
or a symbol (e.g., a backquoted name) or a character string specifying a function
to be searched for from the environment of the call to apply. Note that the chosen function must return a single numeric value.
</p>
<p><code>center</code> is directly passed to <code><a href="base.html#topic+scale">scale</a></code>. If <code>center</code> is <code>TRUE</code> then centering
is done by subtracting the means (omitting NAs) from the motion energy time-series. If <code>center</code> is a numeric vector,
the first value will be subtracted from s1 and the second from s2.
Note: the s1 and s2 signals are scaled independently.
</p>


<h3>Value</h3>

<p>returns the same <code>MEA</code> or <code>MEAlist</code> object, with all motion energy data rescaled
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## read the first 4 minutes of the normal sample
##   (intake interviews of patients that carried on therapy)
path_normal &lt;- system.file("extdata/normal", package = "rMEA")
mea_raw &lt;- readMEA(path_normal, sampRate = 25, s1Col = 1, s2Col = 2,
                     s1Name = "Patient", s2Name = "Therapist",
                     idOrder = c("id","session"), idSep="_", skip=1, nrow = 6000)

## rescale by factor 0.7
mea_scaled = MEAscale(mea_raw, scale = 0.7)

## rescale with standard deviation
mea_scaled = MEAscale(mea_raw, scale = "sd", removeNA = TRUE)

## assign groups names
mea_raw &lt;- setGroup(mea_raw, "raw")
mea_scaled &lt;- setGroup(mea_scaled, "scaled")

## Compute ccf
mea_raw &lt;- MEAccf(mea_raw, lagSec = 5, winSec = 60, incSec = 30, r2Z = TRUE, ABS = FALSE)
mea_scaled &lt;- MEAccf(mea_scaled, lagSec = 5, winSec = 60, incSec = 30, r2Z = TRUE, ABS = FALSE)

## Compare the effect of scaling on ccf
MEAlagplot(mea_scaled, contrast = mea_raw)

</code></pre>

<hr>
<h2 id='MEAsmooth'>Moving average smoothing for motion energy data</h2><span id='topic+MEAsmooth'></span>

<h3>Description</h3>

<p>This function applies a moving average filter, based on SAS &quot;proc expand&quot; procedure. The moving average is applied independently on each subject's motion energy data.
NA values are set to 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MEAsmooth(mea, moving.average.win = 0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MEAsmooth_+3A_mea">mea</code></td>
<td>
<p>an object of class <code>MEA</code> or a list of <code>MEA</code> objects (see function <code><a href="#topic+readMEA">readMEA</a></code>)</p>
</td></tr>
<tr><td><code id="MEAsmooth_+3A_moving.average.win">moving.average.win</code></td>
<td>
<p>numeric. The size of the filter window, in seconds or fractions of seconds.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The filtered object(s)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## read the first 4 minutes of the normal sample
##   (intake interviews of patients that carried on therapy)
path_normal &lt;- system.file("extdata/normal", package = "rMEA")
mea_raw &lt;- readMEA(path_normal, sampRate = 25, s1Col = 1, s2Col = 2,
                     s1Name = "Patient", s2Name = "Therapist",
                     idOrder = c("id","session"), idSep="_", skip=1, nrow = 6000)

## filter with moving average
mea_filter = MEAsmooth(mea_raw)

## assign groups names
mea_raw &lt;- setGroup(mea_raw, "raw")
mea_filter &lt;- setGroup(mea_filter, "filtered")

## Compute ccf
mea_raw &lt;- MEAccf(mea_raw, lagSec = 5, winSec = 60, incSec = 30, r2Z = TRUE, ABS = FALSE)
mea_filter &lt;- MEAccf(mea_filter, lagSec = 5, winSec = 60, incSec = 30, r2Z = TRUE, ABS = FALSE)

## Compare the effect of filtering on ccf
MEAlagplot(mea_filter, contrast = mea_raw)

</code></pre>

<hr>
<h2 id='plot.MEA'>Plots an object of class <code>MEA</code></h2><span id='topic+plot.MEA'></span>

<h3>Description</h3>

<p>Plots an object of class <code>MEA</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'MEA'
plot(x, from = 0, to = NULL, duration = NULL, ccf = F, rescale = F, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.MEA_+3A_x">x</code></td>
<td>
<p>an object of class <code>MEA</code> (see function <code><a href="#topic+readMEA">readMEA</a></code>).</p>
</td></tr>
<tr><td><code id="plot.MEA_+3A_from">from</code></td>
<td>
<p>either an integer or a string in the format hh:mm:ss or mm:ss representing the starting second.</p>
</td></tr>
<tr><td><code id="plot.MEA_+3A_to">to</code></td>
<td>
<p>if <code>duration</code> is not specified, either an integer or a string in the format hh:mm:ss or mm:ss representing the ending second.</p>
</td></tr>
<tr><td><code id="plot.MEA_+3A_duration">duration</code></td>
<td>
<p>if <code>to</code> is not specified, either an integer or a string in the format hh:mm:ss or mm:ss representing the amount of seconds to be plotted.</p>
</td></tr>
<tr><td><code id="plot.MEA_+3A_ccf">ccf</code></td>
<td>
<p>either FALSE or a string representing the type of ccf to be overlayed.
One of &quot;all_lags&quot;  &quot;s1_lead&quot;   &quot;s2_lead&quot;   &quot;lag_zero&quot;  &quot;s1_lead_0&quot; &quot;s2_lead_0&quot; &quot;bestLag&quot; &quot;grandAver&quot; &quot;winTimes&quot;.</p>
</td></tr>
<tr><td><code id="plot.MEA_+3A_rescale">rescale</code></td>
<td>
<p>logical. Should the motion energy time-series be rescaled?</p>
</td></tr>
<tr><td><code id="plot.MEA_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="base.html#topic+plot">plot</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note: if more of than 10s of trailing zeroes are found at the end of both s1 and s2 signals they are truncated.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## read a single file
path_normal &lt;- system.file("extdata/normal/200_01.txt", package = "rMEA")
mea_normal &lt;- readMEA(path_normal, sampRate = 25, s1Col = 1, s2Col = 2,
                     s1Name = "Patient", s2Name = "Therapist", skip=1,
                     idOrder = c("id","session"), idSep="_")
mea_normal &lt;- MEAccf(mea_normal, lagSec = 5, winSec = 30, incSec = 10, ABS = FALSE)
## Visual inspection of the data
plot(mea_normal[[1]], from = 60, to = "2:00")
plot(mea_normal[[1]], from = 0, duration = "5:00")

#' ## Visualize CCF inspection of the data
plot(mea_normal[[1]], from = 0, duration = "2:00", ccf = "lag_zero", rescale=TRUE)

</code></pre>

<hr>
<h2 id='readMEA'>Import MEA raw data</h2><span id='topic+readMEA'></span>

<h3>Description</h3>

<p><code>readMEA</code> reads the output of MEA software.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readMEA(
  path,
  s1Col,
  s2Col,
  sampRate,
  namefilt = NA,
  s1Name = "s1",
  s2Name = "s2",
  idOrder = c("id", "session", "group"),
  idSep = "_",
  removeShortFiles = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readMEA_+3A_path">path</code></td>
<td>
<p>a character vector of full path names; may point to an individual
file or a directory containing MEA files. Only .txt or .csv file extensions
are considered in directories.</p>
</td></tr>
<tr><td><code id="readMEA_+3A_s1col">s1Col</code>, <code id="readMEA_+3A_s2col">s2Col</code></td>
<td>
<p>the index of one or multiple columns in the data,
identifying the two dyad's members (e.g. patient and therapist) motion energy data. If multiple columns
are selected for a subject (e.g. because of multiple regions of interest per subject), their MEA values will be summed.</p>
</td></tr>
<tr><td><code id="readMEA_+3A_samprate">sampRate</code></td>
<td>
<p>sampling rate at which the data is acquired (usually frames per
second of the original video recording).</p>
</td></tr>
<tr><td><code id="readMEA_+3A_namefilt">namefilt</code></td>
<td>
<p>either NA or a character string specifying a pattern to be matched in the filenames.
Regular expressions can be used.</p>
</td></tr>
<tr><td><code id="readMEA_+3A_s1name">s1Name</code>, <code id="readMEA_+3A_s2name">s2Name</code></td>
<td>
<p>the label describing each participant. (e.g. Right/Left, or Patient/Therapist, etc).</p>
</td></tr>
<tr><td><code id="readMEA_+3A_idorder">idOrder</code></td>
<td>
<p>either NA or a character vector that contains one or more of the three strings: &quot;id&quot;,
&quot;session&quot;,&quot;group&quot; in a given order. These are used to interpret the
filenames and correctly label the cases. The strings can be abbreviated.
If the filenames contains other data the character &quot;x&quot; can be used to skip a position.
If NA, no attempt to identify cases will be done.</p>
</td></tr>
<tr><td><code id="readMEA_+3A_idsep">idSep</code></td>
<td>
<p>character vector (or object which can be coerced to such) containing regular expression(s).
If idOrder is not NA, this will be used as separator to split the filenames and identify &quot;id&quot;, &quot;session&quot;, and &quot;group&quot;
informations.</p>
</td></tr>
<tr><td><code id="readMEA_+3A_removeshortfiles">removeShortFiles</code></td>
<td>
<p>Either NULL or an number ranging from 0 to 1.
Specifies the proportion of the average file length below which a file should be excluded.
(E.g. a value of 0.7 will exclude all files with a duration smaller than 70% of the mean duration of all other files in the directory.)</p>
</td></tr>
<tr><td><code id="readMEA_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="utils.html#topic+read.table">read.table</a></code>. E.g. sep, skip, header, etc.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For instance if <code>s1Col = c(1,3)</code> and <code>s2Col = c(2,4)</code>, the
returned values will be the sum of column 1 and 3 for the first participant and
columns 2 and 4 for the second one.
</p>


<h3>Value</h3>

<p>an object of class <code>MEAlist</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## read the first sample (intake interviews of patients that carried on therapy)
path_normal &lt;- system.file("extdata/normal", package = "rMEA")
mea_normal &lt;- readMEA(path_normal, sampRate = 25, s1Col = 1, s2Col = 2,
                     s1Name = "Patient", s2Name = "Therapist", skip=1,
                     idOrder = c("id","session"), idSep="_")
mea_normal &lt;- setGroup(mea_normal, "normal")

## read the second sample (intake interviews of patients that dropped out)
path_dropout &lt;- system.file("extdata/dropout", package = "rMEA")
mea_dropout &lt;- readMEA(path_dropout, sampRate = 25, s1Col = 1, s2Col = 2,
                     s1Name = "Patient", s2Name = "Therapist", skip=1,
                     idOrder = c("id","session"), idSep="_")
mea_dropout &lt;- setGroup(mea_dropout, "dropout")

## Combine into a single object
mea_all = c(mea_normal, mea_dropout)

summary(mea_all)



</code></pre>

<hr>
<h2 id='setGroup'>Sets the group of MEA objects</h2><span id='topic+setGroup'></span>

<h3>Description</h3>

<p>Sets the group of MEA objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setGroup(mea, group)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setGroup_+3A_mea">mea</code></td>
<td>
<p>a single or a list of <code>MEA</code> objects (see function <code><a href="#topic+readMEA">readMEA</a></code>)</p>
</td></tr>
<tr><td><code id="setGroup_+3A_group">group</code></td>
<td>
<p>a text string specifying a group name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of the same type of <code>'mea'</code>, with the group attributes set to <code>group</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## read a sample
path_normal &lt;- system.file("extdata/normal", package = "rMEA")
mea_normal &lt;- readMEA(path_normal, sampRate = 25, s1Col = 1, s2Col = 2,
                     s1Name = "Patient", s2Name = "Therapist",
                     idOrder = c("id","session"), idSep = "_",  skip = 1)
mea_normal &lt;- setGroup(mea_normal, "normal")
</code></pre>

<hr>
<h2 id='shuffle'>Shuffle MEA data (between subjects)</h2><span id='topic+shuffle'></span>

<h3>Description</h3>

<p>This function recombines the s1 and s2 motion energy time-series between all <code>MEA</code> objects in the supplied list.
It is typically used to compare genuine synchrony of real data with pseudosynchrony of shuffled (recombined) data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shuffle(mea, size = "max", keepRoles = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shuffle_+3A_mea">mea</code></td>
<td>
<p>a list of <code>MEA</code> objects (see function <code><a href="#topic+readMEA">readMEA</a></code>).</p>
</td></tr>
<tr><td><code id="shuffle_+3A_size">size</code></td>
<td>
<p>either &quot;max&quot; or an integer specifying the number of combinations to be returned.</p>
</td></tr>
<tr><td><code id="shuffle_+3A_keeproles">keepRoles</code></td>
<td>
<p>Boolean. If TRUE the resulting random dyad will preserve the roles, i.e. they will all have a new s1 sampled among all
s1s and a new s2 sampled among all s2s. If FALSE (default), the role will be disregared.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The shuffling process first creates all possible combinations between s1 and s2 of all <code>MEA</code> objects in the supplied list,
then removes the original pairings, and finally extracts the desired numbers of dyads without replacement.
</p>
<p>Note: all the ccf data, if present, are discarded from the shuffled objects and have to be calculated again using <code><a href="#topic+MEAccf">MEAccf</a></code>
</p>


<h3>Value</h3>

<p>an object of class <code>MEAlist</code> containing randomly combined dyads.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## read the first 4 minutes of the normal sample
##   (intake interviews of patients that carried on therapy)
path_normal &lt;- system.file("extdata/normal", package = "rMEA")
mea_normal &lt;- readMEA(path_normal, sampRate = 25, s1Col = 1, s2Col = 2,
                     s1Name = "Patient", s2Name = "Therapist",
                     idOrder = c("id","session"), idSep="_", skip=1, nrow = 6000)
mea_normal &lt;- setGroup(mea_normal, "normal")

## Create a shuffled sample
mea_rand = shuffle(mea_normal, 50)

summary(mea_rand)
</code></pre>

<hr>
<h2 id='shuffle_segments'>Shuffle MEA data (within subjects)</h2><span id='topic+shuffle_segments'></span>

<h3>Description</h3>

<p>This function generates fakes dyads to be used for pseudosynchrony calculations following the Ramseyer &amp; Tschacher (2010)
within-subject segment shuffling approach.
Between subjects shuffling <code><a href="#topic+shuffle">shuffle</a></code> is probably more conservative, and suggested for most cases.
This function is provided for replicability of older studies, and can be useful to quickly assess pseudosynchrony in single sessions,
or very small samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shuffle_segments(mea, n_each, segSec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shuffle_segments_+3A_mea">mea</code></td>
<td>
<p>a list of <code>MEA</code> objects (see function <code><a href="#topic+readMEA">readMEA</a></code>).</p>
</td></tr>
<tr><td><code id="shuffle_segments_+3A_n_each">n_each</code></td>
<td>
<p>the number of random dyads to be generated from each real dyad.</p>
</td></tr>
<tr><td><code id="shuffle_segments_+3A_segsec">segSec</code></td>
<td>
<p>the width (in seconds) of the shuffling segments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each <code>MEA</code> object, the shuffling procedure first divides s1 and s2 MEA data in segments of size <code>segSec</code>,
then shuffles them within subject (so that the new segments of s1, are the old segments of s1 in a new order). This is repeated
for <code>n_each</code> times, before getting to the next <code>MEA</code> object
</p>
<p>Note: all the ccf data, if present, are discarded from the shuffled objects and have to be calculated again using <code><a href="#topic+MEAccf">MEAccf</a></code>
</p>


<h3>Value</h3>

<p>an object of class <code>MEAlist</code> containing <code>n_each * length(mea)</code> random dyads.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## read the first 4 minutes of the normal sample
##   (intake interviews of patients that carried on therapy)
path_normal &lt;- system.file("extdata/normal", package = "rMEA")
mea_normal &lt;- readMEA(path_normal, sampRate = 25, s1Col = 1, s2Col = 2,
                     s1Name = "Patient", s2Name = "Therapist",
                     idOrder = c("id","session"), idSep="_", skip=1, nrow = 6000)
mea_normal &lt;- setGroup(mea_normal, "normal")

## Create a shuffled sample
mea_rand = shuffle_segments(mea_normal, n_each=10, segSec=30)

summary(mea_rand)
</code></pre>

<hr>
<h2 id='timeMaster'>Transform time values between different formats</h2><span id='topic+timeMaster'></span>

<h3>Description</h3>

<p>This function allows to
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timeMaster(
  baseTime,
  add = 0,
  out = c("auto", "hour", "min", "sec"),
  baseSep = "[\\.,:,\\,',-,\"]"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timeMaster_+3A_basetime">baseTime</code>, <code id="timeMaster_+3A_add">add</code></td>
<td>
<p>either integer of seconds or a time string in the format h:m:s, m:s, or s, with or without leading zeroes</p>
</td></tr>
<tr><td><code id="timeMaster_+3A_out">out</code></td>
<td>
<p>a character string indicating the format of the output. One of &quot;auto&quot; (the default which tries to keep the format of <code>'baseTime'</code>), &quot;hour&quot;, &quot;min&quot;, or &quot;sec&quot;: can be abbreviated.</p>
</td></tr>
<tr><td><code id="timeMaster_+3A_basesep">baseSep</code></td>
<td>
<p>a character string or a regular expression identifying separators in <code>baseTime</code></p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Adding seconds to minutes
timeMaster(30, add="10:00", out = "min")

## Adding strings to integer seconds and returning a numeric value
timeMaster(30, add="10:00")

## Automatic detection of format
timeMaster("01:30:55",add="10:00",out = "auto")
</code></pre>

<hr>
<h2 id='writeMEA'>Exports analyzed MEA data to .txt files</h2><span id='topic+writeMEA'></span>

<h3>Description</h3>

<p>Exports analyzed MEA data to .txt files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeMEA(mea, save.directory, what = c("mea", "ccf"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writeMEA_+3A_mea">mea</code></td>
<td>
<p>an object of class <code>MEA</code> or <code>MEAlist</code> (see function <code><a href="#topic+readMEA">readMEA</a></code>)</p>
</td></tr>
<tr><td><code id="writeMEA_+3A_save.directory">save.directory</code></td>
<td>
<p>a character string naming a directory</p>
</td></tr>
<tr><td><code id="writeMEA_+3A_what">what</code></td>
<td>
<p>a character vector defining what has to be exported. Can be one of 'mea' or 'ccf'.</p>
</td></tr>
<tr><td><code id="writeMEA_+3A_...">...</code></td>
<td>
<p>further arguments passed to <code><a href="utils.html#topic+write.table">write.table</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>'mea' exports the (filtered) MEA data. 'ccf' instead exports the cross-correlation matrix together with all
summarizing statistics calculated by <code><a href="#topic+MEAccf">MEAccf</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## This example is excluded from test as it takes more than 10s to run
## define a regex filter for the filenames to be read
to_read = c("20[123]_*")

## read the first 4 minutes of the files
path_normal &lt;- system.file("extdata/normal", package = "rMEA")
mea_normal &lt;- readMEA(path_normal, namefilt = to_read, sampRate = 25, s1Col = 1, s2Col = 2,
                     s1Name = "Patient", s2Name = "Therapist",
                     idOrder = c("id","session"), idSep = "_",  skip = 1, nrow = 6000)

## perform ccf analysis
mea_ccf = MEAccf(mea_normal, lagSec = 5, winSec = 60, incSec = 30, r2Z = TRUE, ABS = TRUE)

## export data and analysis
save_path = tempdir()
writeMEA(mea_ccf, save.directory = save_path, what="ccf")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
