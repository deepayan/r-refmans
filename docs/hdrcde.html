<!DOCTYPE html><html lang="en"><head><title>Help for package hdrcde</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {hdrcde}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#alpha'><p>Alpha</p></a></li>
<li><a href='#BoxCox'><p>Box Cox Transformation</p></a></li>
<li><a href='#cde'><p>Conditional Density Estimation</p></a></li>
<li><a href='#cde.bandwidths'><p>Bandwidth calculation for conditional density estimation</p></a></li>
<li><a href='#hdr'><p>Highest Density Regions</p></a></li>
<li><a href='#hdr.2d'><p>Bivariate Highest Density Regions</p></a></li>
<li><a href='#hdr.boxplot'><p>Highest Density Region Boxplots</p></a></li>
<li><a href='#hdr.cde'><p>Calculate highest density regions continously over some conditioned</p>
variable.</a></li>
<li><a href='#hdr.den'><p>Density plot with Highest Density Regions</p></a></li>
<li><a href='#hdrbw'><p>Highest Density Region Bandwidth</p></a></li>
<li><a href='#hdrconf'><p>HDRs with confidence intervals</p></a></li>
<li><a href='#hdrscatterplot'><p>Scatterplot showing bivariate highest density regions</p></a></li>
<li><a href='#lane2'><p>Speed-Flow data for Californian Freeway</p></a></li>
<li><a href='#maxtemp'><p>Daily maximum temperatures in Melbourne, Australia</p></a></li>
<li><a href='#modalreg'><p>Nonparametric Multimodal Regression</p></a></li>
<li><a href='#plot.cde'><p>Plots conditional densities</p></a></li>
<li><a href='#plot.hdrconf'><p>Plot HDRs with confidence intervals</p></a></li>
<li><a href='#shades'><p>Shades</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Highest Density Regions and Conditional Density Estimation</td>
</tr>
<tr>
<td>Version:</td>
<td>3.4</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/robjhyndman/hdrcde/issues">https://github.com/robjhyndman/hdrcde/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.15)</td>
</tr>
<tr>
<td>Imports:</td>
<td>locfit, ash, ks, KernSmooth, ggplot2, RColorBrewer</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>Description:</td>
<td>Computation of highest density regions in one and two dimensions, kernel estimation of univariate density functions conditional on one covariate,and multimodal regression.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://pkg.robjhyndman.com/hdrcde/">https://pkg.robjhyndman.com/hdrcde/</a>,
<a href="https://github.com/robjhyndman/hdrcde">https://github.com/robjhyndman/hdrcde</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2021-01-18 05:11:19 UTC; robjhyndman</td>
</tr>
<tr>
<td>Author:</td>
<td>Rob Hyndman <a href="https://orcid.org/0000-0002-2140-5352"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre, cph],
  Jochen Einbeck <a href="https://orcid.org/0000-0002-9457-2020"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Matthew Wand <a href="https://orcid.org/0000-0003-2555-896X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Simon Carrignon <a href="https://orcid.org/0000-0002-4416-1389"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb],
  Fan Cheng <a href="https://orcid.org/0000-0003-0009-3262"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Rob Hyndman &lt;Rob.Hyndman@monash.edu&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2021-01-18 06:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='alpha'>Alpha</h2><span id='topic+alpha'></span>

<h3>Description</h3>

<p>A simple function to change the opacity of a color
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alpha(color, alpha)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="alpha_+3A_color">color</code></td>
<td>
<p>the name or idea of a R color</p>
</td></tr>
<tr><td><code id="alpha_+3A_alpha">alpha</code></td>
<td>
<p>a value in [0,1] defining the opacity wanted.</p>
</td></tr>
</table>

<hr>
<h2 id='BoxCox'>Box Cox Transformation</h2><span id='topic+BoxCox'></span><span id='topic+InvBoxCox'></span>

<h3>Description</h3>

<p>BoxCox() returns a transformation of the input variable using a Box-Cox
transformation. InvBoxCox() reverses the transformation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BoxCox(x, lambda)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="BoxCox_+3A_x">x</code></td>
<td>
<p>a numeric vector or time series</p>
</td></tr>
<tr><td><code id="BoxCox_+3A_lambda">lambda</code></td>
<td>
<p>transformation parameter</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Box-Cox transformation is given by </p>
<p style="text-align: center;"><code class="reqn">f_\lambda(x) =\frac{x^\lambda -
1}{\lambda}</code>
</p>
<p> if
<code class="reqn">\lambda\ne0</code>. For <code class="reqn">\lambda=0</code>,
</p>
<p style="text-align: center;"><code class="reqn">f_0(x) = \log(x).</code>
</p>



<h3>Value</h3>

<p>a numeric vector of the same length as x.
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>References</h3>

<p>Box, G. E. P. and Cox, D. R. (1964) An analysis of
transformations. <em>JRSS B</em> <b>26</b> 211&ndash;246.
</p>

<hr>
<h2 id='cde'>Conditional Density Estimation</h2><span id='topic+cde'></span>

<h3>Description</h3>

<p>Calculates kernel conditional density estimate using local polynomial
estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cde(
  x,
  y,
  deg = 0,
  link = "identity",
  a,
  b,
  mean = NULL,
  x.margin,
  y.margin,
  x.name,
  y.name,
  use.locfit = FALSE,
  fw = TRUE,
  rescale = TRUE,
  nxmargin = 15,
  nymargin = 100,
  a.nndefault = 0.3,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cde_+3A_x">x</code></td>
<td>
<p>Numerical vector or matrix: the conditioning variable(s).</p>
</td></tr>
<tr><td><code id="cde_+3A_y">y</code></td>
<td>
<p>Numerical vector: the response variable.</p>
</td></tr>
<tr><td><code id="cde_+3A_deg">deg</code></td>
<td>
<p>Degree of local polynomial used in estimation.</p>
</td></tr>
<tr><td><code id="cde_+3A_link">link</code></td>
<td>
<p>Link function used in estimation. Default &quot;identity&quot;. The other
possibility is &quot;log&quot; which is recommended if degree &gt; 0.</p>
</td></tr>
<tr><td><code id="cde_+3A_a">a</code></td>
<td>
<p>Optional bandwidth in x direction.</p>
</td></tr>
<tr><td><code id="cde_+3A_b">b</code></td>
<td>
<p>Optional bandwidth in y direction.</p>
</td></tr>
<tr><td><code id="cde_+3A_mean">mean</code></td>
<td>
<p>Estimated mean of y|x. If present, it will adjust conditional
density to have this mean.</p>
</td></tr>
<tr><td><code id="cde_+3A_x.margin">x.margin</code></td>
<td>
<p>Values in x-space on which conditional density is
calculated. If not specified, an equi-spaced grid of <code>nxmargin</code> values
over the range of x is used.  If x is a matrix, x.margin should be a list of
two numerical vectors.</p>
</td></tr>
<tr><td><code id="cde_+3A_y.margin">y.margin</code></td>
<td>
<p>Values in y-space on which conditional density is
calculated. If not specified, an equi-spaced grid of <code>nymargin</code> values
over the range of y is used.</p>
</td></tr>
<tr><td><code id="cde_+3A_x.name">x.name</code></td>
<td>
<p>Optional name of x variable used in plots.</p>
</td></tr>
<tr><td><code id="cde_+3A_y.name">y.name</code></td>
<td>
<p>Optional name of y variable used in plots.</p>
</td></tr>
<tr><td><code id="cde_+3A_use.locfit">use.locfit</code></td>
<td>
<p>If TRUE, will use <code><a href="locfit.html#topic+locfit">locfit</a></code> for
estimation. Otherwise <code><a href="stats.html#topic+ksmooth">ksmooth</a></code> is used.
<code><a href="locfit.html#topic+locfit">locfit</a></code> is used if degree&gt;0 or link not the identity or
the dimension of x is greater than 1 even if <code>use.locfit=FALSE</code>.</p>
</td></tr>
<tr><td><code id="cde_+3A_fw">fw</code></td>
<td>
<p>If TRUE (default), will use fixed window width estimation.
Otherwise nearest neighbourhood estimation is used. If the dimension of x is
greater than 1, nearest neighbourhood must be used.</p>
</td></tr>
<tr><td><code id="cde_+3A_rescale">rescale</code></td>
<td>
<p>If TRUE (default), will rescale the conditional densities to
integrate to one.</p>
</td></tr>
<tr><td><code id="cde_+3A_nxmargin">nxmargin</code></td>
<td>
<p>Number of values used in <code>x.margin</code> by default.</p>
</td></tr>
<tr><td><code id="cde_+3A_nymargin">nymargin</code></td>
<td>
<p>Number of values used in <code>y.margin</code> by default.</p>
</td></tr>
<tr><td><code id="cde_+3A_a.nndefault">a.nndefault</code></td>
<td>
<p>Default nearest neighbour bandwidth (used only if
<code>fw=FALSE</code> and <code>a</code> is missing.).</p>
</td></tr>
<tr><td><code id="cde_+3A_...">...</code></td>
<td>
<p>Additional arguments are passed to locfit.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If bandwidths are omitted, they are computed using normal reference rules
described in Bashtannyk and Hyndman (2001) and Hyndman and Yao (2002). Bias
adjustment uses the method described in Hyndman, Bashtannyk and Grunwald
(1996). If deg&gt;1 then estimation is based on the local parametric estimator
of Hyndman and Yao (2002).
</p>


<h3>Value</h3>

<p>A list with the following components: </p>
<table role = "presentation">
<tr><td><code>x</code></td>
<td>
<p>grid in x direction
on which density evaluated. Equal to x.margin if specified.</p>
</td></tr> <tr><td><code>y</code></td>
<td>
<p>grid
in y direction on which density is evaluated. Equal to y.margin if
specified. </p>
</td></tr> <tr><td><code>z</code></td>
<td>
<p>value of conditional density estimate returned as a
matrix. </p>
</td></tr> <tr><td><code>a</code></td>
<td>
<p>window width in x direction.</p>
</td></tr> <tr><td><code>b</code></td>
<td>
<p>window width in y
direction.</p>
</td></tr> <tr><td><code>x.name</code></td>
<td>
<p>Name of x variable to be used in plots.</p>
</td></tr>
<tr><td><code>y.name</code></td>
<td>
<p>Name of y variable to be used in plots.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>References</h3>

<p>Hyndman, R.J., Bashtannyk, D.M. and Grunwald, G.K. (1996)
&quot;Estimating and visualizing conditional densities&quot;. <em>Journal of
Computational and Graphical Statistics</em>, <b>5</b>, 315-336.
</p>
<p>Bashtannyk, D.M., and Hyndman, R.J. (2001) &quot;Bandwidth selection for kernel
conditional density estimation&quot;. <em>Computational statistics and data
analysis</em>, <b>36</b>(3), 279-298.
</p>
<p>Hyndman, R.J. and Yao, Q. (2002) &quot;Nonparametric estimation and symmetry
tests for conditional density functions&quot;. <em>Journal of Nonparametric
Statistics</em>, <b>14</b>(3), 259-278.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cde.bandwidths">cde.bandwidths</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Old faithful data
faithful.cde &lt;- cde(faithful$waiting, faithful$eruptions,
  x.name="Waiting time", y.name="Duration time")
plot(faithful.cde)
plot(faithful.cde, plot.fn="hdr")

# Melbourne maximum temperatures with bias adjustment
x &lt;- maxtemp[1:3649]
y &lt;- maxtemp[2:3650]
maxtemp.cde &lt;- cde(x, y,
  x.name="Today's max temperature", y.name="Tomorrow's max temperature")
# Assume linear mean
fit &lt;- lm(y~x)
fit.mean &lt;- list(x=6:45,y=fit$coef[1]+fit$coef[2]*(6:45))
maxtemp.cde2 &lt;- cde(x, y, mean=fit.mean,
	 x.name="Today's max temperature", y.name="Tomorrow's max temperature")
plot(maxtemp.cde)
</code></pre>

<hr>
<h2 id='cde.bandwidths'>Bandwidth calculation for conditional density estimation</h2><span id='topic+cde.bandwidths'></span>

<h3>Description</h3>

<p>Calculates bandwidths for kernel conditional density estimates. Methods
described in Bashtannyk and Hyndman (2001) and Hyndman and Yao (2002).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cde.bandwidths(
  x,
  y,
  deg = 0,
  link = "identity",
  method = 1,
  y.margin,
  passes = 2,
  ngrid = 8,
  min.a = NULL,
  ny = 25,
  use.sample = FALSE,
  GCV = TRUE,
  b = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="cde.bandwidths_+3A_x">x</code></td>
<td>
<p>Numerical vector: the conditioning variable.</p>
</td></tr>
<tr><td><code id="cde.bandwidths_+3A_y">y</code></td>
<td>
<p>Numerical vector: the response variable.</p>
</td></tr>
<tr><td><code id="cde.bandwidths_+3A_deg">deg</code></td>
<td>
<p>Degree of local polynomial used in estimation.</p>
</td></tr>
<tr><td><code id="cde.bandwidths_+3A_link">link</code></td>
<td>
<p>Link function used in estimation. Default &quot;identity&quot;. The other
possibility is &quot;log&quot; which is recommended if degree &gt; 0.</p>
</td></tr>
<tr><td><code id="cde.bandwidths_+3A_method">method</code></td>
<td>

<dl>
<dt>method = 1:</dt><dd><p>Hyndman-Yao algorithm if deg&gt;0; Bashtannyk-Hyndman algorithm if deg=0;</p>
</dd>
<dt>method = 2:</dt><dd><p>Normal reference rules;</p>
</dd>
<dt>method = 3:</dt><dd><p>Bashtannyk-Hyndman regression method if deg=0;</p>
</dd>
<dt>method = 4:</dt><dd><p>Bashtannyk-Hyndman bootstrap method if deg=0.</p>
</dd>
</dl>
</td></tr>
<tr><td><code id="cde.bandwidths_+3A_y.margin">y.margin</code></td>
<td>
<p>Values in y-space on which conditional density is
calculated. If not specified, an equi-spaced grid of 50 values over the
range of y is used.</p>
</td></tr>
<tr><td><code id="cde.bandwidths_+3A_passes">passes</code></td>
<td>
<p>Number of passes through Bashtannyk-Hyndman algorithm.</p>
</td></tr>
<tr><td><code id="cde.bandwidths_+3A_ngrid">ngrid</code></td>
<td>
<p>Number of values of smoothing parameter in grid.</p>
</td></tr>
<tr><td><code id="cde.bandwidths_+3A_min.a">min.a</code></td>
<td>
<p>Smallest value of a to consider if method=1.</p>
</td></tr>
<tr><td><code id="cde.bandwidths_+3A_ny">ny</code></td>
<td>
<p>Number of values to use for y margin if <code>y.margin</code> is
missing.</p>
</td></tr>
<tr><td><code id="cde.bandwidths_+3A_use.sample">use.sample</code></td>
<td>
<p>Used when regression method (3) is chosen.</p>
</td></tr>
<tr><td><code id="cde.bandwidths_+3A_gcv">GCV</code></td>
<td>
<p>Generalized cross-validation. Used only if method=1 and deg&gt;0. If
GCV=FALSE, method=1 and deg=0, then the AIC is used instead.  The argument
is ignored if deg=0 or method&gt;1.</p>
</td></tr>
<tr><td><code id="cde.bandwidths_+3A_b">b</code></td>
<td>
<p>Value of b can be specified only if method=1 and deg&gt;0. For deg=0
or method&gt;1, this argument is ignored.</p>
</td></tr>
<tr><td><code id="cde.bandwidths_+3A_...">...</code></td>
<td>
<p>Other arguments control details for individual methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Details of the various algorithms are in Bashtannyk and Hyndman (2001) and
Hyndman and Yao (2002).
</p>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>a</code></td>
<td>
<p>Window width in <code>x</code> direction.</p>
</td></tr> <tr><td><code>b</code></td>
<td>
<p>Window width
in <code>y</code> direction.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>References</h3>

<p>Hyndman, R.J., Bashtannyk, D.M. and Grunwald, G.K. (1996)
&quot;Estimating and visualizing conditional densities&quot;. <em>Journal of
Computational and Graphical Statistics</em>, <b>5</b>, 315-336.
</p>
<p>Bashtannyk, D.M., and Hyndman, R.J. (2001) &quot;Bandwidth selection for kernel
conditional density estimation&quot;. <em>Computational statistics and data
analysis</em>, <b>36</b>(3), 279-298.
</p>
<p>Hyndman, R.J. and Yao, Q. (2002) &quot;Nonparametric estimation and symmetry
tests for conditional density functions&quot;. <em>Journal of Nonparametric
Statistics</em>, <b>14</b>(3), 259-278.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cde">cde</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>bands &lt;- cde.bandwidths(faithful$waiting,faithful$eruptions,method=2)
plot(cde(faithful$waiting,faithful$eruptions,a=bands$a,b=bands$b))
</code></pre>

<hr>
<h2 id='hdr'>Highest Density Regions</h2><span id='topic+hdr'></span>

<h3>Description</h3>

<p>Calculates highest density regions in one dimension
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hdr(
  x = NULL,
  prob = c(50, 95, 99),
  den = NULL,
  h = hdrbw(BoxCox(x, lambda), mean(prob)),
  lambda = 1,
  nn = 5000,
  all.modes = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hdr_+3A_x">x</code></td>
<td>
<p>Numeric vector containing data. If <code>x</code> is missing then
<code>den</code> must be provided, and the HDR is computed from the given density.</p>
</td></tr>
<tr><td><code id="hdr_+3A_prob">prob</code></td>
<td>
<p>Probability coverage required for HDRs</p>
</td></tr>
<tr><td><code id="hdr_+3A_den">den</code></td>
<td>
<p>Density of data as list with components <code>x</code> and <code>y</code>.
If omitted, the density is estimated from <code>x</code> using
<code><a href="stats.html#topic+density">density</a></code>.</p>
</td></tr>
<tr><td><code id="hdr_+3A_h">h</code></td>
<td>
<p>Optional bandwidth for calculation of density.</p>
</td></tr>
<tr><td><code id="hdr_+3A_lambda">lambda</code></td>
<td>
<p>Box-Cox transformation parameter where <code>0 &lt;= lambda &lt;=
1</code>.</p>
</td></tr>
<tr><td><code id="hdr_+3A_nn">nn</code></td>
<td>
<p>Number of random numbers used in computing f-alpha quantiles.</p>
</td></tr>
<tr><td><code id="hdr_+3A_all.modes">all.modes</code></td>
<td>
<p>Return all local modes or just the global mode?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Either <code>x</code> or <code>den</code> must be provided. When <code>x</code> is provided,
the density is estimated using kernel density estimation. A Box-Cox
transformation is used if <code>lambda!=1</code>, as described in Wand, Marron and
Ruppert (1991). This allows the density estimate to be non-zero only on the
positive real line. The default kernel bandwidth <code>h</code> is selected using
the algorithm of Samworth and Wand (2010).
</p>
<p>Hyndman's (1996) density quantile algorithm is used for calculation.
</p>


<h3>Value</h3>

<p>A list of three components: </p>
<table role = "presentation">
<tr><td><code>hdr</code></td>
<td>
<p>The endpoints of each interval
in each HDR</p>
</td></tr> <tr><td><code>mode</code></td>
<td>
<p>The estimated mode of the density.</p>
</td></tr>
<tr><td><code>falpha</code></td>
<td>
<p>The value of the density at the boundaries of each HDR.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>References</h3>

<p>Hyndman, R.J. (1996) Computing and graphing highest density
regions. <em>American Statistician</em>, <b>50</b>, 120-126.
</p>
<p>Samworth, R.J. and Wand, M.P. (2010). Asymptotics and optimal bandwidth
selection for highest density region estimation.  <em>The Annals of
Statistics</em>, <b>38</b>, 1767-1792.
</p>
<p>Wand, M.P., Marron, J S., Ruppert, D. (1991) Transformations in density
estimation. <em>Journal of the American Statistical Association</em>,
<b>86</b>, 343-353.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hdr.den">hdr.den</a></code>, <code><a href="#topic+hdr.boxplot">hdr.boxplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Old faithful eruption duration times
hdr(faithful$eruptions)
</code></pre>

<hr>
<h2 id='hdr.2d'>Bivariate Highest Density Regions</h2><span id='topic+hdr.2d'></span><span id='topic+hdr.boxplot.2d'></span><span id='topic+plot.hdr2d'></span>

<h3>Description</h3>

<p>Calculates and plots highest density regions in two dimensions, including
the bivariate HDR boxplot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hdr.2d(
  x,
  y,
  prob = c(50, 95, 99),
  den = NULL,
  kde.package = c("ash", "ks"),
  h = NULL,
  xextend = 0.15,
  yextend = 0.15
)

hdr.boxplot.2d(
  x,
  y,
  prob = c(50, 99),
  kde.package = c("ash", "ks"),
  h = NULL,
  xextend = 0.15,
  yextend = 0.15,
  xlab = "",
  ylab = "",
  shadecols = "darkgray",
  pointcol = 1,
  outside.points = TRUE,
  ...
)

## S3 method for class 'hdr2d'
plot(
  x,
  shaded = TRUE,
  show.points = FALSE,
  outside.points = FALSE,
  pch = 20,
  shadecols = gray((length(x$alpha):1)/(length(x$alpha) + 1)),
  pointcol = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hdr.2d_+3A_x">x</code></td>
<td>
<p>Numeric vector</p>
</td></tr>
<tr><td><code id="hdr.2d_+3A_y">y</code></td>
<td>
<p>Numeric vector of same length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="hdr.2d_+3A_prob">prob</code></td>
<td>
<p>Probability coverage required for HDRs</p>
</td></tr>
<tr><td><code id="hdr.2d_+3A_den">den</code></td>
<td>
<p>Bivariate density estimate (a list with elements x, y and z where
x and y are grid values and z is a matrix of density values). If
<code>NULL</code>, the density is estimated.</p>
</td></tr>
<tr><td><code id="hdr.2d_+3A_kde.package">kde.package</code></td>
<td>
<p>Package to be used in calculating the kernel density
estimate when <code>den=NULL</code>.</p>
</td></tr>
<tr><td><code id="hdr.2d_+3A_h">h</code></td>
<td>
<p>Pair of bandwidths passed to either <code><a href="ash.html#topic+ash2">ash2</a></code> or
<code><a href="ks.html#topic+kde">kde</a></code>. If NULL, a reasonable default is used. Ignored if
<code>den</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="hdr.2d_+3A_xextend">xextend</code></td>
<td>
<p>Proportion of range of <code>x</code>. The density is estimated on
a grid extended by <code>xextend</code> beyond the range of <code>x</code>.</p>
</td></tr>
<tr><td><code id="hdr.2d_+3A_yextend">yextend</code></td>
<td>
<p>Proportion of range of <code>y</code>. The density is estimated on
a grid extended by <code>yextend</code> beyond the range of <code>y</code>.</p>
</td></tr>
<tr><td><code id="hdr.2d_+3A_xlab">xlab</code></td>
<td>
<p>Label for x-axis.</p>
</td></tr>
<tr><td><code id="hdr.2d_+3A_ylab">ylab</code></td>
<td>
<p>Label for y-axis.</p>
</td></tr>
<tr><td><code id="hdr.2d_+3A_shadecols">shadecols</code></td>
<td>
<p>Colors for shaded regions</p>
</td></tr>
<tr><td><code id="hdr.2d_+3A_pointcol">pointcol</code></td>
<td>
<p>Color for outliers and mode</p>
</td></tr>
<tr><td><code id="hdr.2d_+3A_outside.points">outside.points</code></td>
<td>
<p>If <code>TRUE</code>, the observations lying outside the
largest HDR are shown.</p>
</td></tr>
<tr><td><code id="hdr.2d_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to plot.</p>
</td></tr>
<tr><td><code id="hdr.2d_+3A_shaded">shaded</code></td>
<td>
<p>If <code>TRUE</code>, the HDR contours are shown as shaded regions.</p>
</td></tr>
<tr><td><code id="hdr.2d_+3A_show.points">show.points</code></td>
<td>
<p>If <code>TRUE</code>, the observations are plotted over the top
of the HDR contours.</p>
</td></tr>
<tr><td><code id="hdr.2d_+3A_pch">pch</code></td>
<td>
<p>The plotting character used for observations.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The density is estimated using kernel density estimation. Either
<code><a href="ash.html#topic+ash2">ash2</a></code> or <code><a href="ks.html#topic+kde">kde</a></code> is used to do the
calculations. Then Hyndman's (1996) density quantile algorithm is used to
compute the HDRs.
</p>
<p><code>hdr.2d</code> returns an object of class <code>hdr2d</code> containing all the
information needed to compute the HDR contours. This object can be plotted
using <code>plot.hdr2d</code>.
</p>
<p><code>hdr.boxplot.2d</code> produces a bivariate HDR boxplot. This is a special
case of applying <code>plot.hdr2d</code> to an object computed using
<code>hdr.2d</code>.
</p>


<h3>Value</h3>

<p>Some information about the HDRs is returned. See code for details.
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>References</h3>

<p>Hyndman, R.J. (1996) Computing and graphing highest density
regions <em>American Statistician</em>, <b>50</b>, 120-126.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hdr.boxplot">hdr.boxplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(rnorm(200,0,1),rnorm(200,4,1))
y &lt;- c(rnorm(200,0,1),rnorm(200,4,1))
hdr.boxplot.2d(x,y)

hdrinfo &lt;- hdr.2d(x,y)
plot(hdrinfo, pointcol="red", show.points=TRUE, pch=3)
</code></pre>

<hr>
<h2 id='hdr.boxplot'>Highest Density Region Boxplots</h2><span id='topic+hdr.boxplot'></span>

<h3>Description</h3>

<p>Calculates and plots a univariate highest density regions boxplot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hdr.boxplot(
  x,
  prob = c(99, 50),
  h = hdrbw(BoxCox(x, lambda), mean(prob)),
  lambda = 1,
  boxlabels = "",
  col = gray((9:1)/10),
  main = "",
  xlab = "",
  ylab = "",
  pch = 1,
  border = 1,
  outline = TRUE,
  space = 0.25,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hdr.boxplot_+3A_x">x</code></td>
<td>
<p>Numeric vector containing data or a list containing several vectors.</p>
</td></tr>
<tr><td><code id="hdr.boxplot_+3A_prob">prob</code></td>
<td>
<p>Probability coverage required for HDRs
<code><a href="stats.html#topic+density">density</a></code>.</p>
</td></tr>
<tr><td><code id="hdr.boxplot_+3A_h">h</code></td>
<td>
<p>Optional bandwidth for calculation of density.</p>
</td></tr>
<tr><td><code id="hdr.boxplot_+3A_lambda">lambda</code></td>
<td>
<p>Box-Cox transformation parameter where <code>0 &lt;= lambda &lt;=
1</code>.</p>
</td></tr>
<tr><td><code id="hdr.boxplot_+3A_boxlabels">boxlabels</code></td>
<td>
<p>Label for each box plotted.</p>
</td></tr>
<tr><td><code id="hdr.boxplot_+3A_col">col</code></td>
<td>
<p>Colours for regions of each box.</p>
</td></tr>
<tr><td><code id="hdr.boxplot_+3A_main">main</code></td>
<td>
<p>Overall title for the plot.</p>
</td></tr>
<tr><td><code id="hdr.boxplot_+3A_xlab">xlab</code></td>
<td>
<p>Label for x-axis.</p>
</td></tr>
<tr><td><code id="hdr.boxplot_+3A_ylab">ylab</code></td>
<td>
<p>Label for y-axis.</p>
</td></tr>
<tr><td><code id="hdr.boxplot_+3A_pch">pch</code></td>
<td>
<p>Plotting character.</p>
</td></tr>
<tr><td><code id="hdr.boxplot_+3A_border">border</code></td>
<td>
<p>Width of border of box.</p>
</td></tr>
<tr><td><code id="hdr.boxplot_+3A_outline">outline</code></td>
<td>
<p>If not &lt;code&gt;TRUE&lt;/code&gt;, the outliers are not drawn.</p>
</td></tr>
<tr><td><code id="hdr.boxplot_+3A_space">space</code></td>
<td>
<p>The space between each box, between 0 and 0.5.</p>
</td></tr>
<tr><td><code id="hdr.boxplot_+3A_...">...</code></td>
<td>
<p>Other arguments passed to plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The density is estimated using kernel density estimation. A Box-Cox
transformation is used if <code>lambda!=1</code>, as described in Wand, Marron and
Ruppert (1991). This allows the density estimate to be non-zero only on the
positive real line. The default kernel bandwidth <code>h</code> is selected using
the algorithm of Samworth and Wand (2010).
</p>
<p>Hyndman's (1996) density quantile algorithm is used for calculation.
</p>


<h3>Value</h3>

<p>nothing.
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>References</h3>

<p>Hyndman, R.J. (1996) Computing and graphing highest density
regions. <em>American Statistician</em>, <b>50</b>, 120-126.
</p>
<p>Samworth, R.J. and Wand, M.P. (2010). Asymptotics and optimal bandwidth
selection for highest density region estimation.  <em>The Annals of
Statistics</em>, <b>38</b>, 1767-1792.
</p>
<p>Wand, M.P., Marron, J S., Ruppert, D. (1991) Transformations in density
estimation. <em>Journal of the American Statistical Association</em>,
<b>86</b>, 343-353.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hdr.boxplot.2d">hdr.boxplot.2d</a></code>, <code><a href="#topic+hdr">hdr</a></code>, <code><a href="#topic+hdr.den">hdr.den</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Old faithful eruption duration times
hdr.boxplot(faithful$eruptions)

# Simple bimodal example
x &lt;- c(rnorm(100,0,1), rnorm(100,5,1))
par(mfrow=c(1,2))
boxplot(x)
hdr.boxplot(x)

# Highly skewed example
x &lt;- exp(rnorm(100,0,1))
par(mfrow=c(1,2))
boxplot(x)
hdr.boxplot(x,lambda=0)

</code></pre>

<hr>
<h2 id='hdr.cde'>Calculate highest density regions continously over some conditioned
variable.</h2><span id='topic+hdr.cde'></span>

<h3>Description</h3>

<p>Calculates and plots highest density regions for a conditional density
estimate. Uses output from <code><a href="#topic+cde">cde</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hdr.cde(
  den,
  prob = c(50, 95, 99),
  plot = TRUE,
  plot.modes = TRUE,
  mden = rep(1, length(den$x)),
  threshold = 0.05,
  nn = 1000,
  xlim,
  ylim,
  xlab,
  ylab,
  border = TRUE,
  font = 1,
  cex = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hdr.cde_+3A_den">den</code></td>
<td>
<p>Conditional density in the same format as the output from
<code><a href="#topic+cde">cde</a></code>.</p>
</td></tr>
<tr><td><code id="hdr.cde_+3A_prob">prob</code></td>
<td>
<p>Probability coverage level for HDRs</p>
</td></tr>
<tr><td><code id="hdr.cde_+3A_plot">plot</code></td>
<td>
<p>Should HDRs be plotted? If FALSE, results are returned.</p>
</td></tr>
<tr><td><code id="hdr.cde_+3A_plot.modes">plot.modes</code></td>
<td>
<p>Should modes be plotted as well as HDRs?</p>
</td></tr>
<tr><td><code id="hdr.cde_+3A_mden">mden</code></td>
<td>
<p>Marginal density in the <code>x</code> direction. When small, the HDRs
won't be plotted. Default is uniform so all HDRs are plotted.</p>
</td></tr>
<tr><td><code id="hdr.cde_+3A_threshold">threshold</code></td>
<td>
<p>Threshold for margin density. HDRs are not plotted if the
margin density <code>mden</code> is lower than this value.</p>
</td></tr>
<tr><td><code id="hdr.cde_+3A_nn">nn</code></td>
<td>
<p>Number of points to be sampled from each density when estimating
the HDRs.</p>
</td></tr>
<tr><td><code id="hdr.cde_+3A_xlim">xlim</code></td>
<td>
<p>Limits for x-axis.</p>
</td></tr>
<tr><td><code id="hdr.cde_+3A_ylim">ylim</code></td>
<td>
<p>Limits for y-axis.</p>
</td></tr>
<tr><td><code id="hdr.cde_+3A_xlab">xlab</code></td>
<td>
<p>Label for x-axis.</p>
</td></tr>
<tr><td><code id="hdr.cde_+3A_ylab">ylab</code></td>
<td>
<p>Label for y-axis.</p>
</td></tr>
<tr><td><code id="hdr.cde_+3A_border">border</code></td>
<td>
<p>Show border of polygons</p>
</td></tr>
<tr><td><code id="hdr.cde_+3A_font">font</code></td>
<td>
<p>Font to be used in plot.</p>
</td></tr>
<tr><td><code id="hdr.cde_+3A_cex">cex</code></td>
<td>
<p>Size of characters.</p>
</td></tr>
<tr><td><code id="hdr.cde_+3A_...">...</code></td>
<td>
<p>Other arguments passed to plotting functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<table role = "presentation">
<tr><td><code>hdr</code></td>
<td>
<p>array (a,b,c) where where a specifies conditioning value,
b gives the HDR endpoints and c gives the probability coverage.</p>
</td></tr>
<tr><td><code>modes</code></td>
<td>
<p>estimated mode of each conditional density</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>References</h3>

<p>Hyndman, R.J., Bashtannyk, D.M. and Grunwald, G.K. (1996)
&quot;Estimating and visualizing conditional densities&quot;. <em>Journal of
Computational and Graphical Statistics</em>, <b>5</b>, 315-336.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cde">cde</a></code>, <code><a href="#topic+hdr">hdr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>faithful.cde &lt;- cde(faithful$waiting,faithful$eruptions)
plot(faithful.cde,xlab="Waiting time",ylab="Duration time",plot.fn="hdr")
</code></pre>

<hr>
<h2 id='hdr.den'>Density plot with Highest Density Regions</h2><span id='topic+hdr.den'></span>

<h3>Description</h3>

<p>Plots univariate density with highest density regions displayed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hdr.den(
  x,
  prob = c(50, 95, 99),
  den,
  h = hdrbw(BoxCox(x, lambda), mean(prob)),
  lambda = 1,
  xlab = NULL,
  ylab = "Density",
  ylim = NULL,
  plot.lines = TRUE,
  col = 2:8,
  bgcol = "gray",
  legend = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hdr.den_+3A_x">x</code></td>
<td>
<p>Numeric vector containing data. If <code>x</code> is missing then
<code>den</code> must be provided, and the HDR is computed from the given density.</p>
</td></tr>
<tr><td><code id="hdr.den_+3A_prob">prob</code></td>
<td>
<p>Probability coverage required for HDRs</p>
</td></tr>
<tr><td><code id="hdr.den_+3A_den">den</code></td>
<td>
<p>Density of data as list with components <code>x</code> and <code>y</code>.
If omitted, the density is estimated from <code>x</code> using
<code><a href="stats.html#topic+density">density</a></code>.</p>
</td></tr>
<tr><td><code id="hdr.den_+3A_h">h</code></td>
<td>
<p>Optional bandwidth for calculation of density.</p>
</td></tr>
<tr><td><code id="hdr.den_+3A_lambda">lambda</code></td>
<td>
<p>Box-Cox transformation parameter where <code>0 &lt;= lambda &lt;=
1</code>.</p>
</td></tr>
<tr><td><code id="hdr.den_+3A_xlab">xlab</code></td>
<td>
<p>Label for x-axis.</p>
</td></tr>
<tr><td><code id="hdr.den_+3A_ylab">ylab</code></td>
<td>
<p>Label for y-axis.</p>
</td></tr>
<tr><td><code id="hdr.den_+3A_ylim">ylim</code></td>
<td>
<p>Limits for y-axis.</p>
</td></tr>
<tr><td><code id="hdr.den_+3A_plot.lines">plot.lines</code></td>
<td>
<p>If <code>TRUE</code>, will show how the HDRs are determined
using lines.</p>
</td></tr>
<tr><td><code id="hdr.den_+3A_col">col</code></td>
<td>
<p>Colours for regions.</p>
</td></tr>
<tr><td><code id="hdr.den_+3A_bgcol">bgcol</code></td>
<td>
<p>Colours for the background behind the boxes. Default <code>"gray"</code>, if <code>NULL</code> no box is drawn.</p>
</td></tr>
<tr><td><code id="hdr.den_+3A_legend">legend</code></td>
<td>
<p>If <code>TRUE</code> add a legend on the right of the boxes.</p>
</td></tr>
<tr><td><code id="hdr.den_+3A_...">...</code></td>
<td>
<p>Other arguments passed to plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Either <code>x</code> or <code>den</code> must be provided. When <code>x</code> is provided,
the density is estimated using kernel density estimation. A Box-Cox
transformation is used if <code>lambda!=1</code>, as described in Wand, Marron and
Ruppert (1991). This allows the density estimate to be non-zero only on the
positive real line. The default kernel bandwidth <code>h</code> is selected using
the algorithm of Samworth and Wand (2010).
</p>
<p>Hyndman's (1996) density quantile algorithm is used for calculation.
</p>


<h3>Value</h3>

<p>a list of three components: </p>
<table role = "presentation">
<tr><td><code>hdr</code></td>
<td>
<p>The endpoints of each interval
in each HDR</p>
</td></tr> <tr><td><code>mode</code></td>
<td>
<p>The estimated mode of the density.</p>
</td></tr>
<tr><td><code>falpha</code></td>
<td>
<p>The value of the density at the boundaries of each HDR.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>References</h3>

<p>Hyndman, R.J. (1996) Computing and graphing highest density
regions. <em>American Statistician</em>, <b>50</b>, 120-126.
</p>
<p>Samworth, R.J. and Wand, M.P. (2010). Asymptotics and optimal bandwidth
selection for highest density region estimation.  <em>The Annals of
Statistics</em>, <b>38</b>, 1767-1792.
</p>
<p>Wand, M.P., Marron, J S., Ruppert, D. (1991) Transformations in density
estimation. <em>Journal of the American Statistical Association</em>,
<b>86</b>, 343-353.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hdr">hdr</a></code>, <code><a href="#topic+hdr.boxplot">hdr.boxplot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Old faithful eruption duration times
hdr.den(faithful$eruptions)

# Simple bimodal example
x &lt;- c(rnorm(100,0,1), rnorm(100,5,1))
hdr.den(x)
</code></pre>

<hr>
<h2 id='hdrbw'>Highest Density Region Bandwidth</h2><span id='topic+hdrbw'></span>

<h3>Description</h3>

<p>Estimates the optimal bandwidth for 1-dimensional highest density regions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hdrbw(x, HDRlevel, gridsize = 801, nMChdr = 1e+06, graphProgress = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hdrbw_+3A_x">x</code></td>
<td>
<p>Numerical vector containing data.</p>
</td></tr>
<tr><td><code id="hdrbw_+3A_hdrlevel">HDRlevel</code></td>
<td>
<p>HDR-level as defined in Hyndman (1996). Setting &lsquo;HDRlevel&rsquo;
equal to p (0&lt;p&lt;1) corresponds to a probability of 1-p of inclusion in the
highest density region.</p>
</td></tr>
<tr><td><code id="hdrbw_+3A_gridsize">gridsize</code></td>
<td>
<p>the number of equally spaced points used for binned kernel
density estimation.</p>
</td></tr>
<tr><td><code id="hdrbw_+3A_nmchdr">nMChdr</code></td>
<td>
<p>the size of the Monte Carlo sample used for density quantile
approximation of the highest density region, as described in Hyndman (1996).</p>
</td></tr>
<tr><td><code id="hdrbw_+3A_graphprogress">graphProgress</code></td>
<td>
<p>logical flag: if &lsquo;TRUE&rsquo; then plots showing the progress
of the bandwidth selection algorithm are produced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a plug-in rule for bandwidth selection tailored to highest density
region estimation
</p>


<h3>Value</h3>

<p>A numerical vector of length 1.
</p>


<h3>Author(s)</h3>

<p>Matt Wand
</p>


<h3>References</h3>

<p>Hyndman, R.J. (1996). Computing and graphing highest density
regions.  <em>The American Statistician</em>, <b>50</b>, 120-126.
</p>
<p>Samworth, R.J. and Wand, M.P. (2010). Asymptotics and optimal bandwidth
selection for highest density region estimation.  <em>The Annals of
Statistics</em>, <b>38</b>, 1767-1792.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>HDRlevelVal &lt;- 0.55
x &lt;- faithful$eruptions
hHDR &lt;- hdrbw(x,HDRlevelVal)
HDRhat &lt;- hdr.den(x,prob=100*(1-HDRlevelVal),h=hHDR)
</code></pre>

<hr>
<h2 id='hdrconf'>HDRs with confidence intervals</h2><span id='topic+hdrconf'></span>

<h3>Description</h3>

<p>Calculates Highest Density Regions with confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hdrconf(x, den, prob = 95, conf = 95)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hdrconf_+3A_x">x</code></td>
<td>
<p>Numeric vector containing data.</p>
</td></tr>
<tr><td><code id="hdrconf_+3A_den">den</code></td>
<td>
<p>Density of data as list with components <code>x</code> and <code>y</code>.</p>
</td></tr>
<tr><td><code id="hdrconf_+3A_prob">prob</code></td>
<td>
<p>Probability coverage for for HDRs.</p>
</td></tr>
<tr><td><code id="hdrconf_+3A_conf">conf</code></td>
<td>
<p>Confidence for limits on HDR.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>hdrconf</code> returns list containing the following components:
</p>
<table role = "presentation">
<tr><td><code>hdr</code></td>
<td>
<p>Highest density regions</p>
</td></tr> <tr><td><code>hdr.lo</code></td>
<td>
<p>Highest density regions
corresponding to lower confidence limit.</p>
</td></tr> <tr><td><code>hdr.hi</code></td>
<td>
<p>Highest density
regions corresponding to upper confidence limit.</p>
</td></tr> <tr><td><code>falpha</code></td>
<td>
<p>Values of
<code class="reqn">f_\alpha</code> corresponding to HDRs.</p>
</td></tr> <tr><td><code>falpha.ci</code></td>
<td>
<p>Values of
<code class="reqn">f_\alpha</code> corresponding to lower and upper limits.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>References</h3>

<p>Hyndman, R.J. (1996) Computing and graphing highest density
regions <em>American Statistician</em>, <b>50</b>, 120-126.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hdr">hdr</a></code>, <code><a href="#topic+plot.hdrconf">plot.hdrconf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(rnorm(100,0,1),rnorm(100,4,1))
den &lt;- density(x,bw=hdrbw(x,50))
trueden &lt;- den
trueden$y &lt;- 0.5*(exp(-0.5*(den$x*den$x)) + exp(-0.5*(den$x-4)^2))/sqrt(2*pi)
sortx &lt;- sort(x)

par(mfcol=c(2,2))
for(conf in c(50,95))
{
  m &lt;- hdrconf(sortx,trueden,conf=conf)
  plot(m,trueden,main=paste(conf,"% HDR from true density"))
  m &lt;- hdrconf(sortx,den,conf=conf)
  plot(m,den,main=paste(conf,"% HDR from empirical density\n(n=200)"))
}
</code></pre>

<hr>
<h2 id='hdrscatterplot'>Scatterplot showing bivariate highest density regions</h2><span id='topic+hdrscatterplot'></span>

<h3>Description</h3>

<p>Produces a scatterplot where the points are coloured according to the
bivariate HDRs in which they fall.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hdrscatterplot(
  x,
  y,
  levels = c(1, 50, 99),
  kde.package = c("ash", "ks"),
  noutliers = NULL,
  label = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hdrscatterplot_+3A_x">x</code></td>
<td>
<p>Numeric vector or matrix with 2 columns.</p>
</td></tr>
<tr><td><code id="hdrscatterplot_+3A_y">y</code></td>
<td>
<p>Numeric vector of same length as <code>x</code>.</p>
</td></tr>
<tr><td><code id="hdrscatterplot_+3A_levels">levels</code></td>
<td>
<p>Percentage coverage for HDRs</p>
</td></tr>
<tr><td><code id="hdrscatterplot_+3A_kde.package">kde.package</code></td>
<td>
<p>Package to be used in calculating the kernel density
estimate when <code>den=NULL</code>.</p>
</td></tr>
<tr><td><code id="hdrscatterplot_+3A_noutliers">noutliers</code></td>
<td>
<p>Number of outliers to be labelled. By default, all points
outside the largest HDR are labelled.</p>
</td></tr>
<tr><td><code id="hdrscatterplot_+3A_label">label</code></td>
<td>
<p>Label of outliers of same length as <code>x</code> and <code>y</code>. By default, all outliers are labelled as the row index of the point <code>(x, y)</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The bivariate density is estimated using kernel density estimation. Either
<code><a href="ash.html#topic+ash2">ash2</a></code> or <code><a href="ks.html#topic+kde">kde</a></code> is used to do the
calculations. Then Hyndman's (1996) density quantile algorithm is used to
compute the HDRs. The scatterplot of (x,y) is created where the points are
coloured according to which HDR they fall. A ggplot object is returned.
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hdr.boxplot.2d">hdr.boxplot.2d</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(rnorm(200, 0, 1), rnorm(200, 4, 1))
y &lt;- c(rnorm(200, 0, 1), rnorm(200, 4, 1))
hdrscatterplot(x, y)
hdrscatterplot(x, y, label = paste0("p", 1:length(x)))
</code></pre>

<hr>
<h2 id='lane2'>Speed-Flow data for Californian Freeway</h2><span id='topic+lane2'></span><span id='topic+lane3'></span>

<h3>Description</h3>

<p>These are two data sets collected in 1993 on two individual lanes (lane 2
and lane 3) of the 4-lane Californian freeway I-880. The data were collected
by loop detectors, and the time units are 30 seconds per observation (see
Petty et al., 1996, for details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lane2; lane3
</code></pre>


<h3>Format</h3>

<p>Two data frames (<code>lane2</code> and <code>lane3</code>) each with 1318
observations on the following two variables:
</p>

<dl>
<dt>flow</dt><dd><p>a numeric vector giving the traffic flow in vehicles per lane per hour.</p>
</dd>
<dt>speed</dt><dd><p>a numeric vector giving the speed in miles per hour.</p>
</dd>
</dl>



<h3>Details</h3>

<p>The data is examined in Einbeck and Tutz (2006), using a nonparametric
approach to multi-valued regression based on conditional mean shift.
</p>


<h3>Source</h3>

<p>Petty, K.F., Noeimi, H., Sanwal, K., Rydzewski, D., Skabardonis, A.,
Varaiya, P., and Al-Deek, H.  (1996). &ldquo;The Freeway Service Patrol
Evaluation Project: Database Support Programs, and Accessibility&rdquo;.
<em>Transportation Research Part C: Emerging Technologies</em>, <b>4</b>,
71-85.
</p>
<p>The data is provided by courtesy of CALIFORNIA PATH, Institute of
Transportation Studies, University of California, Berkeley.
</p>


<h3>References</h3>

<p>Einbeck, J., and Tutz, G. (2006). &ldquo;Modelling beyond regression
functions: an application of multimodal regression to speed-flow data&rdquo;.
<em>Journal of the Royal Statistical Society, Series C (Applied
Statistics)</em>, <b>55</b>, 461-475.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(lane2)
plot(lane3)
</code></pre>

<hr>
<h2 id='maxtemp'>Daily maximum temperatures in Melbourne, Australia</h2><span id='topic+maxtemp'></span>

<h3>Description</h3>

<p>Daily maximum temperatures in Melbourne, Australia, from 1981-1990. Leap
days have been omitted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxtemp
</code></pre>


<h3>Format</h3>

<p>Time series of frequency 365.
</p>


<h3>Source</h3>

<p>Hyndman, R.J., Bashtannyk, D.M. and Grunwald, G.K. (1996)
&quot;Estimating and visualizing conditional densities&quot;. <em>Journal of
Computational and Graphical Statistics</em>, <b>5</b>, 315-336.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(maxtemp)
</code></pre>

<hr>
<h2 id='modalreg'>Nonparametric Multimodal Regression</h2><span id='topic+modalreg'></span>

<h3>Description</h3>

<p>Nonparametric multi-valued regression based on the modes of conditional
density estimates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modalreg(
  x,
  y,
  xfix = seq(min(x), max(x), l = 50),
  a,
  b,
  deg = 0,
  iter = 30,
  P = 2,
  start = "e",
  prun = TRUE,
  prun.const = 10,
  plot.type = c("p", 1),
  labels = c("", "x", "y"),
  pch = 20,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="modalreg_+3A_x">x</code></td>
<td>
<p>Numerical vector: the conditioning variable.</p>
</td></tr>
<tr><td><code id="modalreg_+3A_y">y</code></td>
<td>
<p>Numerical vector: the response variable.</p>
</td></tr>
<tr><td><code id="modalreg_+3A_xfix">xfix</code></td>
<td>
<p>Numerical vector corresponding to the input values of which the
fitted values shall be calculated.</p>
</td></tr>
<tr><td><code id="modalreg_+3A_a">a</code></td>
<td>
<p>Optional bandwidth in <code class="reqn">x</code>-direction.</p>
</td></tr>
<tr><td><code id="modalreg_+3A_b">b</code></td>
<td>
<p>Optional bandwidth in <code class="reqn">y</code>-direction.</p>
</td></tr>
<tr><td><code id="modalreg_+3A_deg">deg</code></td>
<td>
<p>Degree of local polynomial used in estimation (0 or 1).</p>
</td></tr>
<tr><td><code id="modalreg_+3A_iter">iter</code></td>
<td>
<p>Positive integer giving the number of mean shift iterations per
point and branch.</p>
</td></tr>
<tr><td><code id="modalreg_+3A_p">P</code></td>
<td>
<p>Maximal number of branches.</p>
</td></tr>
<tr><td><code id="modalreg_+3A_start">start</code></td>
<td>
<p>Character determining how the starting points are selected.
<code>"q"</code>: proportional to quantiles; <code>"e"</code>: equidistant; <code>"r"</code>:
random.  All, <code>"q"</code>, <code>"e"</code>, and <code>"r"</code>, give starting points
which are constant over <code>x</code>.  As an alternative, the choice <code>"v"</code>
gives variable starting points, which are equal to <code>"q"</code> for the
smallest <code>x</code>, and equal to the previously fitted values for all
subsequent <code>x</code>.</p>
</td></tr>
<tr><td><code id="modalreg_+3A_prun">prun</code></td>
<td>
<p>Boolean. If TRUE, parts of branches are dismissed (in the
plotted output) where their associated kernel density value falls below the
threshold <code>1/(prun.const*(max(x)-min(x))*(max(y)-min(y)))</code>.</p>
</td></tr>
<tr><td><code id="modalreg_+3A_prun.const">prun.const</code></td>
<td>
<p>Numerical value giving the constant used above (the
higher, the less pruning)</p>
</td></tr>
<tr><td><code id="modalreg_+3A_plot.type">plot.type</code></td>
<td>
<p>Vector with two elements. The first one is
character-valued, with possible values <code>"p"</code>, <code>"l"</code>, and
<code>"n"</code>.  If equal to <code>"n"</code>, no plotted output is given at all. If
equal to <code>"p"</code>, fitted curves are symbolized as points in the graphical
output, otherwise as lines.  The second vector component is a numerical
value either being 0 or 1. If 1, the position of the starting points is
depicted in the plot, otherwise omitted.</p>
</td></tr>
<tr><td><code id="modalreg_+3A_labels">labels</code></td>
<td>
<p>Vector of three character strings.  The first one is the
&quot;main&quot; title of the graphical output, the second one is the label of the
<code class="reqn">x</code> axis, and the third one the label of the <code class="reqn">y</code> axis.</p>
</td></tr>
<tr><td><code id="modalreg_+3A_pch">pch</code></td>
<td>
<p>Plotting character. The default corresponds to small bullets.</p>
</td></tr>
<tr><td><code id="modalreg_+3A_...">...</code></td>
<td>
<p>Other arguments passed to <code><a href="#topic+cde.bandwidths">cde.bandwidths</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Computes multi-modal nonparametric regression curves based on the maxima of
conditional density estimates. The tool for the estimation is the
conditional mean shift as outlined in Einbeck and Tutz (2006).  Estimates of
the conditional modes might fluctuate highly if <code>deg=1</code>.  Hence,
<code>deg=0</code> is recommended. For bandwidth selection, the hybrid rule
introduced by Bashtannyk and Hyndman (2001) is employed if <code>deg=0</code>.
This corresponds to the setting <code>method=1</code> in function
<code>cde.bandwidths</code>. For <code>deg=1</code> automatic bandwidth selection is not
supported.
</p>


<h3>Value</h3>

<p>A list with the following components: </p>
<table role = "presentation">
<tr><td><code>xfix</code></td>
<td>
<p>Grid of predictor
values at which the fitted values are calculated.</p>
</td></tr> <tr><td><code>fitted.values</code></td>
<td>
<p>A
<code>[P x length(xfix)]</code>- matrix with fitted j-th branch in the j-th row
(<code class="reqn">1 \le j \le P</code>) </p>
</td></tr> <tr><td><code>bandwidths</code></td>
<td>
<p>A vector with
bandwidths <code>a</code> and <code>b</code>.</p>
</td></tr> <tr><td><code>density</code></td>
<td>
<p>A <code>[P x
length(xfix)]</code>- matrix with estimated kernel densities. This will only be
computed if <code>prun=TRUE</code>.</p>
</td></tr> <tr><td><code>threshold</code></td>
<td>
<p>The pruning threshold.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jochen Einbeck (2007)
</p>


<h3>References</h3>

<p>Einbeck, J., and Tutz, G. (2006) &quot;Modelling beyond regression
functions: an application of multimodal regression to speed-flow data&quot;.
<em>Journal of the Royal Statistical Society, Series C (Applied
Statistics)</em>, <b>55</b>, 461-475.
</p>
<p>Bashtannyk, D.M., and Hyndman, R.J. (2001) &quot;Bandwidth selection for kernel
conditional density estimation&quot;. <em>Computational Statistics and Data
Analysis</em>, <b>36</b>(3), 279-298.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cde.bandwidths">cde.bandwidths</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lane2.fit &lt;- modalreg(lane2$flow, lane2$speed, xfix=(1:55)*40, a=100, b=4)
</code></pre>

<hr>
<h2 id='plot.cde'>Plots conditional densities</h2><span id='topic+plot.cde'></span>

<h3>Description</h3>

<p>Produces stacked density plots or highest density region plots for a
univariate density conditional on one covariate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cde'
plot(
  x,
  firstvar = 1,
  mfrow = n2mfrow(dim(x$z)[firstvar]),
  plot.fn = "stacked",
  x.name,
  margin = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.cde_+3A_x">x</code></td>
<td>
<p>Output from <code><a href="#topic+cde">cde</a></code>.</p>
</td></tr>
<tr><td><code id="plot.cde_+3A_firstvar">firstvar</code></td>
<td>
<p>If there is more than one conditioning variable,
<code>firstvar</code> specifies which variable to fix first.</p>
</td></tr>
<tr><td><code id="plot.cde_+3A_mfrow">mfrow</code></td>
<td>
<p>If there is more than one conditioning variable, <code>mfrow</code>
is passed to <code><a href="graphics.html#topic+par">par</a></code> before plotting.</p>
</td></tr>
<tr><td><code id="plot.cde_+3A_plot.fn">plot.fn</code></td>
<td>
<p>Specifies which plotting function to use: &quot;stacked&quot; results
in stacked conditional densities and &quot;hdr&quot; results in highest density
regions.</p>
</td></tr>
<tr><td><code id="plot.cde_+3A_x.name">x.name</code></td>
<td>
<p>Name of x (conditioning) variable for use on x-axis.</p>
</td></tr>
<tr><td><code id="plot.cde_+3A_margin">margin</code></td>
<td>
<p>Marginal density of conditioning variable. If present, only
conditional densities corresponding to non-negligible marginal densities
will be plotted.</p>
</td></tr>
<tr><td><code id="plot.cde_+3A_...">...</code></td>
<td>
<p>Additional arguments to plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If <code>plot.fn=="stacked"</code> and there is only one conditioning
variable, the function returns the output from
<code><a href="graphics.html#topic+persp">persp</a></code>.  If <code>plot.fn=="hdr"</code> and there is only
one conditioning variable, the function returns the output from
<code><a href="#topic+hdr.cde">hdr.cde</a></code>. When there is more than one conditioning variable,
nothing is returned.
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>References</h3>

<p>Hyndman, R.J., Bashtannyk, D.M. and Grunwald, G.K. (1996)
&quot;Estimating and visualizing conditional densities&quot;. <em>Journal of
Computational and Graphical Statistics</em>, <b>5</b>, 315-336.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hdr.cde">hdr.cde</a></code>, <code><a href="#topic+cde">cde</a></code>, <code><a href="#topic+hdr">hdr</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>faithful.cde &lt;- cde(faithful$waiting,faithful$eruptions,
	 x.name="Waiting time", y.name="Duration time")
plot(faithful.cde)
plot(faithful.cde,plot.fn="hdr")
</code></pre>

<hr>
<h2 id='plot.hdrconf'>Plot HDRs with confidence intervals</h2><span id='topic+plot.hdrconf'></span>

<h3>Description</h3>

<p>Plots Highest Density Regions with confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'hdrconf'
plot(x, den, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.hdrconf_+3A_x">x</code></td>
<td>
<p>Output from <code>hdrconf</code>.</p>
</td></tr>
<tr><td><code id="plot.hdrconf_+3A_den">den</code></td>
<td>
<p>Density of data as list with components <code>x</code> and <code>y</code>.</p>
</td></tr>
<tr><td><code id="plot.hdrconf_+3A_...">...</code></td>
<td>
<p>Other arguments are passed to plot.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>None
</p>


<h3>Author(s)</h3>

<p>Rob J Hyndman
</p>


<h3>References</h3>

<p>Hyndman, R.J. (1996) Computing and graphing highest density
regions <em>American Statistician</em>, <b>50</b>, 120-126.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hdrconf">hdrconf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- c(rnorm(100,0,1),rnorm(100,4,1))
den &lt;- density(x,bw=bw.SJ(x))
trueden &lt;- den
trueden$y &lt;- 0.5*(exp(-0.5*(den$x*den$x)) + exp(-0.5*(den$x-4)^2))/sqrt(2*pi)
sortx &lt;- sort(x)

par(mfcol=c(2,2))
for(conf in c(50,95))
{
  m &lt;- hdrconf(sortx,trueden,conf=conf)
  plot(m,trueden,main=paste(conf,"% HDR from true density"))
  m &lt;- hdrconf(sortx,den,conf=conf)
  plot(m,den,main=paste(conf,"% HDR from empirical density\n(n=200)"))
}
</code></pre>

<hr>
<h2 id='shades'>Shades</h2><span id='topic+shades'></span>

<h3>Description</h3>

<p>A simple function to genarte shade of one color by changing its opacity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shades(color, n)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="shades_+3A_color">color</code></td>
<td>
<p>the name or idea of a R color</p>
</td></tr>
<tr><td><code id="shades_+3A_n">n</code></td>
<td>
<p>number or shades wanted</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
