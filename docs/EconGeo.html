<!DOCTYPE html><html><head><title>Help for package EconGeo</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {EconGeo}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#co_occurrence'><p>Compute the number of co-occurrences between industry pairs from an incidence (industry - event) matrix</p></a></li>
<li><a href='#diversity'><p>Compute a simple measure of diversity of regions</p></a></li>
<li><a href='#ease_recombination'><p>Compute the ease of recombination of a given technological class</p></a></li>
<li><a href='#entropy'><p>Compute the Shannon entropy index from regions - industries matrices</p></a></li>
<li><a href='#entry_list'><p>Generate a data frame of entry events from multiple regions - industries matrices (same matrix composition for the different periods)</p></a></li>
<li><a href='#entry_mat'><p>Generate a matrix of entry events from two regions - industries matrices (same matrix composition from two different periods)</p></a></li>
<li><a href='#exit_list'><p>Generate a data frame of exit events from multiple regions - industries matrices (same matrix composition for the different periods)</p></a></li>
<li><a href='#exit_mat'><p>Generate a matrix of exit events from two regions - industries matrices (same matrix composition from two different periods)</p></a></li>
<li><a href='#expy'><p>Compute the expy index of regions from regions - industries matrices</p></a></li>
<li><a href='#get_list'><p>Create regular data frames from regions - industries matrices</p></a></li>
<li><a href='#get_matrix'><p>Create regions - industries matrices from regular data frames</p></a></li>
<li><a href='#gini'><p>Compute the Gini coefficient</p></a></li>
<li><a href='#growth_ind'><p>Generate a matrix of industrial growth by industries from two regions - industries matrices (same matrix composition from two different periods)</p></a></li>
<li><a href='#growth_list'><p>Generate a data frame of industrial growth in regions from multiple regions - industries matrices (same matrix composition for the different periods)</p></a></li>
<li><a href='#growth_list_ind'><p>Generate a data frame of industrial growth in regions from multiple regions - industries matrices (same matrix composition for the different periods)</p></a></li>
<li><a href='#growth_list_reg'><p>Generate a data frame of region growth from multiple regions - industries matrices (same matrix composition for the different periods)</p></a></li>
<li><a href='#growth_mat'><p>Generate a matrix of industrial growth in regions from two regions - industries matrices (same matrix composition from two different periods)</p></a></li>
<li><a href='#growth_reg'><p>Generate a matrix of industrial growth by regions from two regions - industries matrices (same matrix composition from two different periods)</p></a></li>
<li><a href='#hachman'><p>Compute the Hachman index from regions - industries matrices</p></a></li>
<li><a href='#herfindahl'><p>Compute the Herfindahl index from regions - industries matrices</p></a></li>
<li><a href='#hoover_curve'><p>Plot a Hoover curve from regions - industries matrices</p></a></li>
<li><a href='#hoover_gini'><p>Compute the Hoover Gini</p></a></li>
<li><a href='#hoover_index'><p>Compute the Hoover index</p></a></li>
<li><a href='#inv_norm_ubiquity'><p>Compute a measure of complexity from the inverse of the normalized ubiquity of industries</p></a></li>
<li><a href='#kci'><p>Compute an index of knowledge complexity of regions using the eigenvector method</p></a></li>
<li><a href='#krugman_index'><p>Compute the Krugman index from regions - industries matrices</p></a></li>
<li><a href='#location_quotient'><p>Compute location quotients from regions - industries matrices</p></a></li>
<li><a href='#location_quotient_avg'><p>Compute average location quotients of regions from regions - industries matrices</p></a></li>
<li><a href='#locational_gini'><p>Compute the locational Gini coefficient from regions - industries matrices</p></a></li>
<li><a href='#locational_gini_curve'><p>Plot a locational Gini curve from regions - industries matrices</p></a></li>
<li><a href='#lorenz_curve'><p>Plot a Lorenz curve from regional industrial counts</p></a></li>
<li><a href='#match_mat'><p>Re-arrange the dimension of a matrix based on the dimension of another matrix</p></a></li>
<li><a href='#modular_complexity'><p>Compute a measure of modular complexity of patent documents</p></a></li>
<li><a href='#modular_complexity_avg'><p>Compute a measure of average modular complexity of technologies</p></a></li>
<li><a href='#morc'><p>Compute an index of knowledge complexity of regions using the method of reflection</p></a></li>
<li><a href='#mort'><p>Compute an index of knowledge complexity of industries using the method of reflection</p></a></li>
<li><a href='#norm_ubiquity'><p>Compute a measure of complexity by normalizing ubiquity of industries</p></a></li>
<li><a href='#prody'><p>Compute the prody index of industries from regions - industries matrices</p></a></li>
<li><a href='#rca'><p>Compute an index of revealed comparative advantage (RCA) from regions - industries matrices</p></a></li>
<li><a href='#relatedness'><p>Compute the relatedness between entities (industries, technologies, ...) from their co-occurence matrix</p></a></li>
<li><a href='#relatedness_density'><p>Compute the relatedness density between regions and industries from regions - industries matrices and industries - industries matrices</p></a></li>
<li><a href='#relatedness_density_ext'><p>Compute the relatedness density between regions and industries that are not part of the regional portfolio from regions - industries matrices and industries - industries matrices</p></a></li>
<li><a href='#relatedness_density_ext_avg'><p>Compute the average relatedness density of regions to industries that are not part of the regional portfolio from regions - industries matrices and industries - industries matrices</p></a></li>
<li><a href='#relatedness_density_int'><p>Compute the relatedness density between regions and industries that are part of the regional portfolio from regions - industries matrices and industries - industries matrices</p></a></li>
<li><a href='#relatedness_density_int_avg'><p>Compute the average relatedness density within the regional portfolio from regions - industries matrices and industries - industries matrices</p></a></li>
<li><a href='#spec_coeff'><p>Compute the Hoover coefficient of specialization from regions - industries matrices</p></a></li>
<li><a href='#tci'><p>Compute an index of knowledge complexity of industries using the eigenvector method</p></a></li>
<li><a href='#ubiquity'><p>Compute a simple measure of ubiquity of industries</p></a></li>
<li><a href='#weighted_avg'><p>Compute a weighted average of regions or industries from regions - industries matrices</p></a></li>
<li><a href='#z_score'><p>Compute the z-score between technologies from an incidence matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Computing Key Indicators of the Spatial Distribution of Economic
Activities</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-06-22</td>
</tr>
<tr>
<td>Description:</td>
<td>Computes a series of indices commonly used in the fields of economic geography, economic complexity, and evolutionary economics to describe the location, distribution, spatial organization, structure, and complexity of economic activities. Functions include basic spatial indicators such as the location quotient, the Krugman specialization index, the Herfindahl or the Shannon entropy indices but also more advanced functions to compute different forms of normalized relatedness between economic activities or network-based measures of economic complexity. Most of the functions use matrix calculus and are based on bipartite (incidence) matrices consisting of region - industry pairs. These are described in Balland (2017) <a href="http://econ.geo.uu.nl/peeg/peeg1709.pdf">http://econ.geo.uu.nl/peeg/peeg1709.pdf</a>.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/PABalland/EconGeo">https://github.com/PABalland/EconGeo</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.1)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, reshape</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/PABalland/EconGeo/issues">https://github.com/PABalland/EconGeo/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-24 12:02:47 UTC; admin</td>
</tr>
<tr>
<td>Author:</td>
<td>Pierre-Alexandre Balland [aut, cre, cph]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pierre-Alexandre Balland &lt;p.balland@uu.nl&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-26 12:00:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='co_occurrence'>Compute the number of co-occurrences between industry pairs from an incidence (industry - event) matrix</h2><span id='topic+co_occurrence'></span>

<h3>Description</h3>

<p>This function computes the number of co-occurrences between industry pairs from an incidence (industry - event) matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>co_occurrence(mat, diagonal = FALSE, list = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="co_occurrence_+3A_mat">mat</code></td>
<td>
<p>An incidence matrix with industries in rows and events in columns</p>
</td></tr>
<tr><td><code id="co_occurrence_+3A_diagonal">diagonal</code></td>
<td>
<p>Logical; shall the values in the diagonal of the co-occurrence matrix be included in the output? Defaults to FALSE (values in the diagonal are set to 0), but can be set to TRUE (values in the diagonal reflects in how many events a single industry can be found)</p>
</td></tr>
<tr><td><code id="co_occurrence_+3A_list">list</code></td>
<td>
<p>Logical; is the input a list? Defaults to FALSE (input = adjacency matrix), but can be set to TRUE if the input is an edge list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The co-occurrence matrix as an R matrix object.
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>References</h3>

<p>Boschma, R., Balland, P.A. and Kogler, D. (2015) Relatedness and Technological Change in Cities: The rise and fall of technological knowledge in U.S. metropolitan areas from 1981 to 2010, <em>Industrial and Corporate Change</em> <strong>24</strong> (1): 223-250
</p>


<h3>See Also</h3>

<p><code><a href="#topic+relatedness">relatedness</a></code>, <code><a href="#topic+relatedness_density">relatedness_density</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a region - events matrix
set.seed(31)
mat &lt;- matrix(sample(0:1, 20, replace = TRUE), ncol = 5)
rownames(mat) &lt;- c("I1", "I2", "I3", "I4")
colnames(mat) &lt;- c("US1", "US2", "US3", "US4", "US5")

## run the function
co_occurrence(mat)
co_occurrence(mat, diagonal = TRUE)

## generate a regular data frame (list)
my_list &lt;- get_list(mat)

## run the function
co_occurrence(my_list, list = TRUE)
co_occurrence(my_list, list = TRUE, diagonal = TRUE)
</code></pre>

<hr>
<h2 id='diversity'>Compute a simple measure of diversity of regions</h2><span id='topic+diversity'></span>

<h3>Description</h3>

<p>This function computes a simple measure of diversity of regions by counting the number of industries in which a region has a relative comparative advantage (location quotient &gt; 1) from regions - industries (incidence) matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>diversity(mat, rca = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="diversity_+3A_mat">mat</code></td>
<td>
<p>An incidence matrix with regions in rows and industries in columns</p>
</td></tr>
<tr><td><code id="diversity_+3A_rca">rca</code></td>
<td>
<p>Logical; should the index of relative comparative advantage (RCA - also refered to as location quotient) first be computed? Defaults to FALSE (a binary matrix - 0/1 - is expected as an input), but can be set to TRUE if the index of relative comparative advantage first needs to be computed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector representing the share of a tech in a city's portfolio
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>References</h3>

<p>Balland, P.A. and Rigby, D. (2017) The Geography of Complex Knowledge, <em>Economic Geography</em> <strong>93</strong> (1): 1-23.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ubiquity">ubiquity</a></code>, <code><a href="#topic+location_quotient">location_quotient</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a region - industry matrix with full count
set.seed(31)
mat &lt;- matrix(sample(0:10, 20, replace = TRUE), ncol = 4)
rownames(mat) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat) &lt;- c("I1", "I2", "I3", "I4")

## run the function
diversity(mat, rca = TRUE)

## generate a region - industry matrix in which cells represent the presence/absence of a RCA
set.seed(31)
mat &lt;- matrix(sample(0:1, 20, replace = TRUE), ncol = 4)
rownames(mat) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat) &lt;- c("I1", "I2", "I3", "I4")

## run the function
diversity(mat)
</code></pre>

<hr>
<h2 id='ease_recombination'>Compute the ease of recombination of a given technological class</h2><span id='topic+ease_recombination'></span>

<h3>Description</h3>

<p>This function computes the ease of recombination of a given technological class from technological classes - patents (incidence) matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ease_recombination(mat, sparse = FALSE, list = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ease_recombination_+3A_mat">mat</code></td>
<td>
<p>A bipartite adjacency matrix (can be a sparse matrix)</p>
</td></tr>
<tr><td><code id="ease_recombination_+3A_sparse">sparse</code></td>
<td>
<p>Logical; is the input matrix a sparse matrix? Defaults to FALSE, but can be set to TRUE if the input matrix is a sparse matrix</p>
</td></tr>
<tr><td><code id="ease_recombination_+3A_list">list</code></td>
<td>
<p>Logical; is the input a list? Defaults to FALSE, but can be set to TRUE if the input matrix is a list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with two columns: &quot;tech&quot; representing the technological class and &quot;eor&quot; representing the ease of recombination of the technological class
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>References</h3>

<p>Fleming, L. and Sorenson, O. (2001) Technology as a complex adaptive system: evidence from patent data, <em>Research Policy</em> <strong>30</strong>: 1019-1039
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modular_complexity">modular_complexity</a></code>, <code><a href="#topic+tci">tci</a></code>, <code><a href="#topic+mort">mort</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a technology - patent matrix
set.seed(31)
mat &lt;- matrix(sample(0:1, 30, replace = TRUE), ncol = 5)
rownames(mat) &lt;- c("T1", "T2", "T3", "T4", "T5", "T6")
colnames(mat) &lt;- c("US1", "US2", "US3", "US4", "US5")

## generate a technology - patent sparse matrix
library(Matrix)
smat &lt;- Matrix(mat, sparse = TRUE)

## run the function
ease_recombination(mat)
ease_recombination(smat, sparse = TRUE)

## generate a regular data frame (list)
my_list &lt;- get_list(mat)

## run the function
ease_recombination(my_list, list = TRUE)
</code></pre>

<hr>
<h2 id='entropy'>Compute the Shannon entropy index from regions - industries matrices</h2><span id='topic+entropy'></span>

<h3>Description</h3>

<p>This function computes the Shannon entropy index from regions - industries matrices from (incidence) regions - industries matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>entropy(mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="entropy_+3A_mat">mat</code></td>
<td>
<p>An incidence matrix with regions in rows and industries in columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector representing the Shannon entropy index computed from the regions - industries matrix
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>References</h3>

<p>Shannon, C.E., Weaver, W. (1949) <em>The Mathematical Theory of Communication</em>. Univ of Illinois Press. <br />
<br />
Frenken, K., Van Oort, F. and Verburg, T. (2007) Related variety, unrelated variety and regional economic growth, <em>Regional studies</em> <strong>41</strong> (5): 685-697.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diversity">diversity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a region - industry matrix
set.seed(31)
mat &lt;- matrix(sample(0:100, 20, replace = TRUE), ncol = 4)
rownames(mat) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat) &lt;- c("I1", "I2", "I3", "I4")

## run the function
entropy(mat)
</code></pre>

<hr>
<h2 id='entry_list'>Generate a data frame of entry events from multiple regions - industries matrices (same matrix composition for the different periods)</h2><span id='topic+entry_list'></span>

<h3>Description</h3>

<p>This function generates a data frame of entry events from multiple regions - industries matrices (different matrix compositions are allowed). In this function, the maximum number of periods is limited to 20.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>entry_list(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="entry_list_+3A_...">...</code></td>
<td>
<p>Incidence matrices with regions in rows and industries in columns (period ... - optional)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame representing the entry events from multiple regions - industries matrices, with columns &quot;region&quot; (representing the region), &quot;industry&quot; (representing the industry), &quot;entry&quot; (representing the entry event), and &quot;period&quot; (representing the period)
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a> <br />
Wolf-Hendrik Uhlbach <a href="mailto:w.p.uhlbach@students.uu.nl">w.p.uhlbach@students.uu.nl</a>
</p>


<h3>References</h3>

<p>Boschma, R., Balland, P.A. and Kogler, D. (2015) Relatedness and Technological Change in Cities: The rise and fall of technological knowledge in U.S. metropolitan areas from 1981 to 2010, <em>Industrial and Corporate Change</em> <strong>24</strong> (1): 223-250 <br />
<br />
Boschma, R., Heimeriks, G. and Balland, P.A. (2014) Scientific Knowledge Dynamics and Relatedness in Bio-Tech Cities, <em>Research Policy</em> <strong>43</strong> (1): 107-114
</p>


<h3>See Also</h3>

<p><code><a href="#topic+growth_list">growth_list</a></code>, <code><a href="#topic+exit_list">exit_list</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a first region - industry matrix in which cells represent the presence/absence
## of a RCA (period 1)
set.seed(31)
mat1 &lt;- matrix(sample(0:1, 20, replace = TRUE), ncol = 4)
rownames(mat1) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat1) &lt;- c("I1", "I2", "I3", "I4")

## generate a second region - industry matrix in which cells represent the presence/absence
## of a RCA (period 2)
mat2 &lt;- mat1
mat2[3, 1] &lt;- 1

## run the function
entry_list(mat1, mat2)

## generate a third region - industry matrix in which cells represent the presence/absence
## of a RCA (period 3)
mat3 &lt;- mat2
mat3[5, 2] &lt;- 1

## run the function
entry_list(mat1, mat2, mat3)

## generate a fourth region - industry matrix in which cells represent the presence/absence
## of a RCA (period 4)
mat4 &lt;- mat3
mat4[5, 4] &lt;- 1

## run the function
entry_list(mat1, mat2, mat3, mat4)
</code></pre>

<hr>
<h2 id='entry_mat'>Generate a matrix of entry events from two regions - industries matrices (same matrix composition from two different periods)</h2><span id='topic+entry_mat'></span>

<h3>Description</h3>

<p>This function generates a matrix of entry events from two regions - industries matrices (different matrix compositions are allowed)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>entry_mat(mat1, mat2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="entry_mat_+3A_mat1">mat1</code></td>
<td>
<p>An incidence matrix with regions in rows and industries in columns (period 1)</p>
</td></tr>
<tr><td><code id="entry_mat_+3A_mat2">mat2</code></td>
<td>
<p>An incidence matrix with regions in rows and industries in columns (period 2)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix representing the entry events from two regions - industries matrices, with rows representing regions and columns representing industries
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a> <br />
Wolf-Hendrik Uhlbach <a href="mailto:w.p.uhlbach@students.uu.nl">w.p.uhlbach@students.uu.nl</a>
</p>


<h3>References</h3>

<p>Boschma, R., Balland, P.A. and Kogler, D. (2015) Relatedness and Technological Change in Cities: The rise and fall of technological knowledge in U.S. metropolitan areas from 1981 to 2010, <em>Industrial and Corporate Change</em> <strong>24</strong> (1): 223-250 <br />
<br />
Boschma, R., Heimeriks, G. and Balland, P.A. (2014) Scientific Knowledge Dynamics and Relatedness in Bio-Tech Cities, <em>Research Policy</em> <strong>43</strong> (1): 107-114
</p>


<h3>See Also</h3>

<p><code><a href="#topic+growth_list">growth_list</a></code>, <code><a href="#topic+entry_list">entry_list</a></code>, <code><a href="#topic+exit_list">exit_list</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a first region - industry matrix in which cells represent the presence/absence
## of a RCA (period 1)
set.seed(31)
mat1 &lt;- matrix(sample(0:1, 20, replace = TRUE), ncol = 4)
rownames(mat1) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat1) &lt;- c("I1", "I2", "I3", "I4")

## generate a second region - industry matrix in which cells represent the presence/absence
## of a RCA (period 2)
mat2 &lt;- mat1
mat2[3, 1] &lt;- 1


## run the function
entry_mat(mat1, mat2)
</code></pre>

<hr>
<h2 id='exit_list'>Generate a data frame of exit events from multiple regions - industries matrices (same matrix composition for the different periods)</h2><span id='topic+exit_list'></span>

<h3>Description</h3>

<p>This function generates a data frame of exit events from multiple regions - industries matrices (different matrix compositions are allowed). In this function, the maximum number of periods is limited to 20.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exit_list(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exit_list_+3A_...">...</code></td>
<td>
<p>Incidence matrices with regions in rows and industries in columns (period ... - optional)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame representing the exit events from multiple regions - industries matrices, with columns &quot;region&quot; (representing the region), &quot;industry&quot; (representing the industry), &quot;exit&quot; (representing the exit event), and &quot;period&quot; (representing the period)
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a> <br />
Wolf-Hendrik Uhlbach <a href="mailto:w.p.uhlbach@students.uu.nl">w.p.uhlbach@students.uu.nl</a>
</p>


<h3>References</h3>

<p>Boschma, R., Balland, P.A. and Kogler, D. (2015) Relatedness and Technological Change in Cities: The rise and fall of technological knowledge in U.S. metropolitan areas from 1981 to 2010, <em>Industrial and Corporate Change</em> <strong>24</strong> (1): 223-250 <br />
<br />
Boschma, R., Heimeriks, G. and Balland, P.A. (2014) Scientific Knowledge Dynamics and Relatedness in Bio-Tech Cities, <em>Research Policy</em> <strong>43</strong> (1): 107-114
</p>


<h3>See Also</h3>

<p><code><a href="#topic+entry_list">entry_list</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a first region - industry matrix in which cells represent the presence/absence
## of a RCA (period 1)
set.seed(31)
mat1 &lt;- matrix(sample(0:1, 20, replace = TRUE), ncol = 4)
rownames(mat1) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat1) &lt;- c("I1", "I2", "I3", "I4")

## generate a second region - industry matrix in which cells represent the presence/absence
## of a RCA (period 2)
mat2 &lt;- mat1
mat2[2, 1] &lt;- 0

## run the function
exit_list(mat1, mat2)

## generate a third region - industry matrix in which cells represent the presence/absence
## of a RCA (period 3)
mat3 &lt;- mat2
mat3[5, 1] &lt;- 0

## run the function
exit_list(mat1, mat2, mat3)

## generate a fourth region - industry matrix in which cells represent the presence/absence
## of a RCA (period 4)
mat4 &lt;- mat3
mat4[5, 3] &lt;- 0

## run the function
exit_list(mat1, mat2, mat3, mat4)
</code></pre>

<hr>
<h2 id='exit_mat'>Generate a matrix of exit events from two regions - industries matrices (same matrix composition from two different periods)</h2><span id='topic+exit_mat'></span>

<h3>Description</h3>

<p>This function generates a matrix of exit events from two regions - industries matrices (different matrix compositions are allowed)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exit_mat(mat1, mat2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exit_mat_+3A_mat1">mat1</code></td>
<td>
<p>An incidence matrix with regions in rows and industries in columns (period 1)</p>
</td></tr>
<tr><td><code id="exit_mat_+3A_mat2">mat2</code></td>
<td>
<p>An incidence matrix with regions in rows and industries in columns (period 2)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix representing the exit events from two regions - industries matrices, with rows representing regions and columns representing industries
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a> <br />
Wolf-Hendrik Uhlbach <a href="mailto:w.p.uhlbach@students.uu.nl">w.p.uhlbach@students.uu.nl</a>
</p>


<h3>References</h3>

<p>Boschma, R., Balland, P.A. and Kogler, D. (2015) Relatedness and Technological Change in Cities: The rise and fall of technological knowledge in U.S. metropolitan areas from 1981 to 2010, <em>Industrial and Corporate Change</em> <strong>24</strong> (1): 223-250 <br />
<br />
Boschma, R., Heimeriks, G. and Balland, P.A. (2014) Scientific Knowledge Dynamics and Relatedness in Bio-Tech Cities, <em>Research Policy</em> <strong>43</strong> (1): 107-114
</p>


<h3>See Also</h3>

<p><code><a href="#topic+growth_list">growth_list</a></code>, <code><a href="#topic+exit_list">exit_list</a></code>, <code><a href="#topic+entry_list">entry_list</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a first region - industry matrix in which cells represent the presence/absence
## of a RCA (period 1)
set.seed(31)
mat1 &lt;- matrix(sample(0:1, 20, replace = TRUE), ncol = 4)
rownames(mat1) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat1) &lt;- c("I1", "I2", "I3", "I4")

## generate a second region - industry matrix in which cells represent the presence/absence
## of a RCA (period 2)
mat2 &lt;- mat1
mat2[2, 1] &lt;- 0


## run the function
exit_mat(mat1, mat2)
</code></pre>

<hr>
<h2 id='expy'>Compute the expy index of regions from regions - industries matrices</h2><span id='topic+expy'></span>

<h3>Description</h3>

<p>This function computes the expy index of regions from (incidence) regions - industries matrices, as proposed by Hausmann, Hwang &amp; Rodrik (2007). The index is a measure of the productivity level associated with a region's specialization pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expy(mat, vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expy_+3A_mat">mat</code></td>
<td>
<p>An incidence matrix with regions in rows and industries in columns</p>
</td></tr>
<tr><td><code id="expy_+3A_vec">vec</code></td>
<td>
<p>A vector that gives GDP, R&amp;D, education or any other relevant regional attribute that will be used to compute the weighted average for each industry</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector representing the expy index of regions computed from the regions - industries matrix
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>References</h3>

<p>Balassa, B. (1965) Trade Liberalization and Revealed Comparative Advantage, <em>The Manchester School</em> <strong>33</strong>: 99-123 <br />
<br />
Hausmann, R., Hwang, J. &amp; Rodrik, D. (2007) What you export matters, <em>Journal of economic growth</em> <strong>12</strong>: 1-25.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+location_quotient">location_quotient</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a region - industry matrix
set.seed(31)
mat &lt;- matrix(sample(0:100, 20, replace = TRUE), ncol = 4)
rownames(mat) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat) &lt;- c("I1", "I2", "I3", "I4")

## a vector of GDP of regions
vec &lt;- c(5, 10, 15, 25, 50)
## run the function
expy(mat, vec)
</code></pre>

<hr>
<h2 id='get_list'>Create regular data frames from regions - industries matrices</h2><span id='topic+get_list'></span>

<h3>Description</h3>

<p>This function creates regular data frames with three columns (regions, industries, count) from (incidence) matrices (wide to long format) using the reshape2 package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_list(mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_list_+3A_mat">mat</code></td>
<td>
<p>An incidence matrix with regions in rows and industries in columns (or the other way around)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with three columns: &quot;Region&quot; (representing the region), &quot;Industry&quot; (representing the industry), and &quot;Count&quot; (representing the count of occurrences)
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_matrix">get_matrix</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a region - industry matrix
set.seed(31)
mat &lt;- matrix(sample(0:100, 20, replace = TRUE), ncol = 4)
rownames(mat) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat) &lt;- c("I1", "I2", "I3", "I4")

## run the function
get_list(mat)
</code></pre>

<hr>
<h2 id='get_matrix'>Create regions - industries matrices from regular data frames</h2><span id='topic+get_matrix'></span>

<h3>Description</h3>

<p>This function creates regions - industries (incidence) matrices from regular data frames (long to wide format) using the reshape2 package or the Matrix package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_matrix (my_data, sparse = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_matrix_+3A_my_data">my_data</code></td>
<td>
<p>is a data frame with three columns (regions, industries, count)</p>
</td></tr>
<tr><td><code id="get_matrix_+3A_sparse">sparse</code></td>
<td>
<p>Logical; shall the returned output be a sparse matrix? Defaults to FALSE, but can be set to TRUE if the dataset is very large</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A regions - industries matrix in either dense or sparse format, depending on the value of the &quot;sparse&quot; parameter
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_list">get_list</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a region - industry data frame
set.seed(31)
region &lt;- c("R1", "R1", "R1", "R1", "R2", "R2", "R3", "R4", "R5", "R5")
industry &lt;- c("I1", "I2", "I3", "I4", "I1", "I2", "I1", "I1", "I3", "I3")
my_data &lt;- data.frame(region, industry)
my_data$count &lt;- 1

## run the function
get_matrix(my_data)
get_matrix(my_data, sparse = TRUE)
</code></pre>

<hr>
<h2 id='gini'>Compute the Gini coefficient</h2><span id='topic+gini'></span>

<h3>Description</h3>

<p>This function computes the Gini coefficient. The Gini index measures spatial inequality. It ranges from 0 (perfect income equality) to 1 (perfect income inequality) and is derived from the Lorenz curve. The Gini coefficient is defined as a ratio of two surfaces derived from the Lorenz curve. The numerator is given by the area between the Lorenz curve of the distribution and the uniform distribution line (45 degrees line). The denominator is the area under the uniform distribution line (the lower triangle). This index gives an indication of the unequal distribution of an industry accross n regions. Maximum inequality in the sample occurs when n-1 regions have a score of zero and one region has a positive score. The maximum value of the Gini coefficient is (n-1)/n and approaches 1 (theoretical maximum limit) as the number of observations (regions) increases.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gini(mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gini_+3A_mat">mat</code></td>
<td>
<p>A region-industry count matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Gini coefficient or a data frame with the Gini coefficient for each industry (if the input is a matrix with multiple columns)
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>References</h3>

<p>Gini, C. (1921) Measurement of Inequality of Incomes, <em>The Economic Journal</em> <strong>31</strong>: 124-126
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hoover_gini">hoover_gini</a></code>, <code><a href="#topic+locational_gini">locational_gini</a></code>, <code><a href="#topic+locational_gini_curve">locational_gini_curve</a></code>, <code><a href="#topic+lorenz_curve">lorenz_curve</a></code>, <code><a href="#topic+hoover_curve">hoover_curve</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate vectors of industrial count
ind &lt;- c(0, 10, 10, 30, 50)

## run the function
gini(ind)

## generate a region - industry matrix
mat &lt;- matrix(
  c(
    0, 1, 0, 0,
    0, 1, 0, 0,
    0, 1, 0, 0,
    0, 1, 0, 1,
    0, 1, 1, 1
  ),
  ncol = 4, byrow = TRUE
)
rownames(mat) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat) &lt;- c("I1", "I2", "I3", "I4")

## run the function
gini(mat)

## run the function by aggregating all industries
gini(rowSums(mat))

## run the function for industry #1 only (perfect equality)
gini(mat[, 1])

## run the function for industry #2 only (perfect equality)
gini(mat[, 2])

## run the function for industry #3 only (perfect unequality: max gini = (5-1)/5)
gini(mat[, 3])

## run the function for industry #4 only (top 40% produces 100% of the output)
gini(mat[, 4])

</code></pre>

<hr>
<h2 id='growth_ind'>Generate a matrix of industrial growth by industries from two regions - industries matrices (same matrix composition from two different periods)</h2><span id='topic+growth_ind'></span>

<h3>Description</h3>

<p>This function generates a matrix of industrial growth by industries from two regions - industries matrices (same matrix composition from two different periods)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>growth_ind(mat1, mat2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="growth_ind_+3A_mat1">mat1</code></td>
<td>
<p>An incidence matrix with regions in rows and industries in columns (period 1)</p>
</td></tr>
<tr><td><code id="growth_ind_+3A_mat2">mat2</code></td>
<td>
<p>An incidence matrix with regions in rows and industries in columns (period 2)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of industrial growth by industries
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>References</h3>

<p>Boschma, R., Balland, P.A. and Kogler, D. (2015) Relatedness and Technological Change in Cities: The rise and fall of technological knowledge in U.S. metropolitan areas from 1981 to 2010, <em>Industrial and Corporate Change</em> <strong>24</strong> (1): 223-250 <br />
<br />
Boschma, R., Heimeriks, G. and Balland, P.A. (2014) Scientific Knowledge Dynamics and Relatedness in Bio-Tech Cities, <em>Research Policy</em> <strong>43</strong> (1): 107-114
</p>


<h3>See Also</h3>

<p><code><a href="#topic+entry_list">entry_list</a></code>, <code><a href="#topic+exit_list">exit_list</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a first region - industry matrix with full count (period 1)
set.seed(31)
mat1 &lt;- matrix(sample(0:10, 20, replace = TRUE), ncol = 4)
rownames(mat1) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat1) &lt;- c("I1", "I2", "I3", "I4")

## generate a second region - industry matrix with full count (period 2)
mat2 &lt;- mat1
mat2[3, 1] &lt;- 8


## run the function
growth_ind(mat1, mat2)
</code></pre>

<hr>
<h2 id='growth_list'>Generate a data frame of industrial growth in regions from multiple regions - industries matrices (same matrix composition for the different periods)</h2><span id='topic+growth_list'></span>

<h3>Description</h3>

<p>This function generates a data frame of industrial growth in regions from multiple regions - industries matrices (same matrix composition for the different periods). In this function, the maximum number of periods is limited to 20.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>growth_list(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="growth_list_+3A_...">...</code></td>
<td>
<p>Incidence matrices with regions in rows and industries in columns (period ... - optional)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of industrial growth in regions
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>References</h3>

<p>Boschma, R., Balland, P.A. and Kogler, D. (2015) Relatedness and Technological Change in Cities: The rise and fall of technological knowledge in U.S. metropolitan areas from 1981 to 2010, <em>Industrial and Corporate Change</em> <strong>24</strong> (1): 223-250 <br />
<br />
Boschma, R., Heimeriks, G. and Balland, P.A. (2014) Scientific Knowledge Dynamics and Relatedness in Bio-Tech Cities, <em>Research Policy</em> <strong>43</strong> (1): 107-114
</p>


<h3>See Also</h3>

<p><code><a href="#topic+exit_list">exit_list</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a first region - industry matrix with full count (period 1)
set.seed(31)
mat1 &lt;- matrix(sample(0:10, 20, replace = TRUE), ncol = 4)
rownames(mat1) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat1) &lt;- c("I1", "I2", "I3", "I4")

## generate a second region - industry matrix with full count (period 2)
mat2 &lt;- mat1
mat2[3, 1] &lt;- 8

## run the function
growth_list(mat1, mat2)

## generate a third region - industry matrix with full count (period 3)
mat3 &lt;- mat2
mat3[5, 2] &lt;- 1

## run the function
growth_list(mat1, mat2, mat3)

## generate a fourth region - industry matrix with full count (period 4)
mat4 &lt;- mat3
mat4[5, 4] &lt;- 1

## run the function
growth_list(mat1, mat2, mat3, mat4)
</code></pre>

<hr>
<h2 id='growth_list_ind'>Generate a data frame of industrial growth in regions from multiple regions - industries matrices (same matrix composition for the different periods)</h2><span id='topic+growth_list_ind'></span>

<h3>Description</h3>

<p>This function generates a data frame of industrial growth in regions from multiple regions - industries matrices (same matrix composition for the different periods). In this function, the maximum number of periods is limited to 20.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>growth_list_ind(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="growth_list_ind_+3A_...">...</code></td>
<td>
<p>Incidence matrices with regions in rows and industries in columns (period ... - optional)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of industrial growth in regions
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>References</h3>

<p>Boschma, R., Balland, P.A. and Kogler, D. (2015) Relatedness and Technological Change in Cities: The rise and fall of technological knowledge in U.S. metropolitan areas from 1981 to 2010, <em>Industrial and Corporate Change</em> <strong>24</strong> (1): 223-250 <br />
<br />
Boschma, R., Heimeriks, G. and Balland, P.A. (2014) Scientific Knowledge Dynamics and Relatedness in Bio-Tech Cities, <em>Research Policy</em> <strong>43</strong> (1): 107-114
</p>


<h3>See Also</h3>

<p><code><a href="#topic+growth_list">growth_list</a></code>, <code><a href="#topic+entry_list">entry_list</a></code>, <code><a href="#topic+exit_list">exit_list</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a first region - industry matrix with full count (period 1)
set.seed(31)
mat1 &lt;- matrix(sample(0:10, 20, replace = TRUE), ncol = 4)
rownames(mat1) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat1) &lt;- c("I1", "I2", "I3", "I4")

## generate a second region - industry matrix with full count (period 2)
mat2 &lt;- mat1
mat2[3, 1] &lt;- 8

## run the function
growth_list_ind(mat1, mat2)

## generate a third region - industry matrix with full count (period 3)
mat3 &lt;- mat2
mat3[5, 2] &lt;- 1

## run the function
growth_list_ind(mat1, mat2, mat3)

## generate a fourth region - industry matrix with full count (period 4)
mat4 &lt;- mat3
mat4[5, 4] &lt;- 1

## run the function
growth_list_ind(mat1, mat2, mat3, mat4)
</code></pre>

<hr>
<h2 id='growth_list_reg'>Generate a data frame of region growth from multiple regions - industries matrices (same matrix composition for the different periods)</h2><span id='topic+growth_list_reg'></span>

<h3>Description</h3>

<p>This function generates a data frame of industrial growth in regions from multiple regions - industries matrices (same matrix composition for the different periods). In this function, the maximum number of periods is limited to 20.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>growth_list_reg(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="growth_list_reg_+3A_...">...</code></td>
<td>
<p>Incidence matrices with regions in rows and industries in columns (period ... - optional)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of region growth from multiple regions - industries matrices
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>References</h3>

<p>Boschma, R., Balland, P.A. and Kogler, D. (2015) Relatedness and Technological Change in Cities: The rise and fall of technological knowledge in U.S. metropolitan areas from 1981 to 2010, <em>Industrial and Corporate Change</em> <strong>24</strong> (1): 223-250 <br />
<br />
Boschma, R., Heimeriks, G. and Balland, P.A. (2014) Scientific Knowledge Dynamics and Relatedness in Bio-Tech Cities, <em>Research Policy</em> <strong>43</strong> (1): 107-114
</p>


<h3>See Also</h3>

<p><code><a href="#topic+growth_list">growth_list</a></code>, <code><a href="#topic+entry_list">entry_list</a></code>, <code><a href="#topic+exit_list">exit_list</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a first region - industry matrix with full count (period 1)
set.seed(31)
mat1 &lt;- matrix(sample(0:10, 20, replace = TRUE), ncol = 4)
rownames(mat1) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat1) &lt;- c("I1", "I2", "I3", "I4")

## generate a second region - industry matrix with full count (period 2)
mat2 &lt;- mat1
mat2[3, 1] &lt;- 8

## run the function
growth_list_reg(mat1, mat2)

## generate a third region - industry matrix with full count (period 3)
mat3 &lt;- mat2
mat3[5, 2] &lt;- 1

## run the function
growth_list_reg(mat1, mat2, mat3)

## generate a fourth region - industry matrix with full count (period 4)
mat4 &lt;- mat3
mat4[5, 4] &lt;- 1

## run the function
growth_list_reg(mat1, mat2, mat3, mat4)
</code></pre>

<hr>
<h2 id='growth_mat'>Generate a matrix of industrial growth in regions from two regions - industries matrices (same matrix composition from two different periods)</h2><span id='topic+growth_mat'></span>

<h3>Description</h3>

<p>This function generates a matrix of industrial growth in regions from two regions - industries matrices (same matrix composition from two different periods)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>growth_mat(mat1, mat2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="growth_mat_+3A_mat1">mat1</code></td>
<td>
<p>An incidence matrix with regions in rows and industries in columns (period 1)</p>
</td></tr>
<tr><td><code id="growth_mat_+3A_mat2">mat2</code></td>
<td>
<p>An incidence matrix with regions in rows and industries in columns (period 2)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of industrial growth in regions from two regions - industries matrices
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>References</h3>

<p>Boschma, R., Balland, P.A. and Kogler, D. (2015) Relatedness and Technological Change in Cities: The rise and fall of technological knowledge in U.S. metropolitan areas from 1981 to 2010, <em>Industrial and Corporate Change</em> <strong>24</strong> (1): 223-250 <br />
<br />
Boschma, R., Heimeriks, G. and Balland, P.A. (2014) Scientific Knowledge Dynamics and Relatedness in Bio-Tech Cities, <em>Research Policy</em> <strong>43</strong> (1): 107-114
</p>


<h3>See Also</h3>

<p><code><a href="#topic+growth_list">growth_list</a></code>, <code><a href="#topic+entry_list">entry_list</a></code>, <code><a href="#topic+exit_list">exit_list</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a first region - industry matrix with full count (period 1)
set.seed(31)
mat1 &lt;- matrix(sample(0:10, 20, replace = TRUE), ncol = 4)
rownames(mat1) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat1) &lt;- c("I1", "I2", "I3", "I4")

## generate a second region - industry matrix with full count (period 2)
mat2 &lt;- mat1
mat2[3, 1] &lt;- 8


## run the function
growth_mat(mat1, mat2)
</code></pre>

<hr>
<h2 id='growth_reg'>Generate a matrix of industrial growth by regions from two regions - industries matrices (same matrix composition from two different periods)</h2><span id='topic+growth_reg'></span>

<h3>Description</h3>

<p>This function generates a matrix of industrial growth by regions from two regions - industries matrices (same matrix composition from two different periods)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>growth_reg(mat1, mat2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="growth_reg_+3A_mat1">mat1</code></td>
<td>
<p>An incidence matrix with regions in rows and industries in columns (period 1)</p>
</td></tr>
<tr><td><code id="growth_reg_+3A_mat2">mat2</code></td>
<td>
<p>An incidence matrix with regions in rows and industries in columns (period 2)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of industrial growth by regions from two regions - industries matrices
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>References</h3>

<p>Boschma, R., Balland, P.A. and Kogler, D. (2015) Relatedness and Technological Change in Cities: The rise and fall of technological knowledge in U.S. metropolitan areas from 1981 to 2010, <em>Industrial and Corporate Change</em> <strong>24</strong> (1): 223-250 <br />
<br />
Boschma, R., Heimeriks, G. and Balland, P.A. (2014) Scientific Knowledge Dynamics and Relatedness in Bio-Tech Cities, <em>Research Policy</em> <strong>43</strong> (1): 107-114
</p>


<h3>See Also</h3>

<p><code><a href="#topic+growth_list">growth_list</a></code>, <code><a href="#topic+entry_list">entry_list</a></code>, <code><a href="#topic+exit_list">exit_list</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a first region - industry matrix with full count (period 1)
set.seed(31)
mat1 &lt;- matrix(sample(0:10, 20, replace = TRUE), ncol = 4)
rownames(mat1) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat1) &lt;- c("I1", "I2", "I3", "I4")

## generate a second region - industry matrix with full count (period 2)
mat2 &lt;- mat1
mat2[3, 1] &lt;- 8


## run the function
growth_reg(mat1, mat2)
</code></pre>

<hr>
<h2 id='hachman'>Compute the Hachman index from regions - industries matrices</h2><span id='topic+hachman'></span>

<h3>Description</h3>

<p>This function computes the Hachman index from regions - industries matrices. The Hachman index indicates how closely the industrial distribution of a region resembles the one of a more global economy (nation, world). The index varies between 0 (extreme dissimilarity between the region and the more global economy) and 1 (extreme similarity between the region and the more global economy)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hachman(mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hachman_+3A_mat">mat</code></td>
<td>
<p>An incidence matrix with regions in rows and industries in columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of Hachman index values indicating the similarity between the industrial distribution of a region and a more global economy
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+location_quotient_avg">location_quotient_avg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a region - industry matrix
set.seed(31)
mat &lt;- matrix(sample(0:100, 20, replace = TRUE), ncol = 4)
rownames(mat) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat) &lt;- c("I1", "I2", "I3", "I4")

## run the function
hachman(mat)
</code></pre>

<hr>
<h2 id='herfindahl'>Compute the Herfindahl index from regions - industries matrices</h2><span id='topic+herfindahl'></span>

<h3>Description</h3>

<p>This function computes the Herfindahl index from regions - industries matrices from (incidence) regions - industries matrices. This index is also known as the  Herfindahl-Hirschman index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>herfindahl(mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="herfindahl_+3A_mat">mat</code></td>
<td>
<p>An incidence matrix with regions in rows and industries in columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of Herfindahl index values indicating the concentration of industries within regions
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>References</h3>

<p>Herfindahl, O.C. (1959) <em>Copper Costs and Prices: 1870-1957</em>. Baltimore: The Johns Hopkins Press. <br />
<br />
Hirschman, A.O. (1945) <em>National Power and the Structure of Foreign Trade</em>, Berkeley and Los Angeles: University of California Press.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+krugman_index">krugman_index</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a region - industry matrix
set.seed(31)
mat &lt;- matrix(sample(0:100, 20, replace = TRUE), ncol = 4)
rownames(mat) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat) &lt;- c("I1", "I2", "I3", "I4")

## run the function
herfindahl(mat)
</code></pre>

<hr>
<h2 id='hoover_curve'>Plot a Hoover curve from regions - industries matrices</h2><span id='topic+hoover_curve'></span>

<h3>Description</h3>

<p>This function plots a Hoover curve from regions - industries matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hoover_curve(mat, pop, plot = TRUE, pdf = FALSE, pdf_location = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hoover_curve_+3A_mat">mat</code></td>
<td>
<p>An incidence matrix with regions in rows and industries in columns. The input can also be a vector of industrial regional count (a matrix with n regions in rows and a single column).</p>
</td></tr>
<tr><td><code id="hoover_curve_+3A_pop">pop</code></td>
<td>
<p>A vector of population regional count</p>
</td></tr>
<tr><td><code id="hoover_curve_+3A_plot">plot</code></td>
<td>
<p>Logical; shall the curve be automatically plotted? Defaults to TRUE. If set to TRUE, the function will return x y coordinates that you can latter use to plot and customize the curve.</p>
</td></tr>
<tr><td><code id="hoover_curve_+3A_pdf">pdf</code></td>
<td>
<p>Logical; shall a pdf be saved?  Defaults to FALSE. If set to TRUE, a pdf with all will be compiled and saved to R's temp dir if no 'pdf_location' is specified.</p>
</td></tr>
<tr><td><code id="hoover_curve_+3A_pdf_location">pdf_location</code></td>
<td>
<p>Output location of pdf file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If 'plot = FALSE', a list containing the cumulative distribution of population shares ('cum.reg') and industry shares ('cum.out') is returned. If 'plot = TRUE', no return value is specified.
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>References</h3>

<p>Hoover, E.M. (1936) The Measurement of Industrial Localization, <em>The Review of Economics and Statistics</em> <strong>18</strong> (1): 162-171
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hoover_gini">hoover_gini</a></code>, <code><a href="#topic+locational_gini">locational_gini</a></code>, <code><a href="#topic+locational_gini_curve">locational_gini_curve</a></code>, <code><a href="#topic+lorenz_curve">lorenz_curve</a></code>, <code><a href="#topic+gini">gini</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate vectors of industrial and population count
ind &lt;- c(0, 10, 10, 30, 50)
pop &lt;- c(10, 15, 20, 25, 30)

## run the function (30% of the population produces 50% of the industrial output)
hoover_curve (ind, pop)
hoover_curve (ind, pop, pdf = FALSE)
hoover_curve (ind, pop, plot = FALSE)

## generate a region - industry matrix
mat = matrix (
c (0, 10, 0, 0,
0, 15, 0, 0,
0, 20, 0, 0,
0, 25, 0, 1,
0, 30, 1, 1), ncol = 4, byrow = TRUE)
rownames(mat) &lt;- c ("R1", "R2", "R3", "R4", "R5")
colnames(mat) &lt;- c ("I1", "I2", "I3", "I4")

## run the function
hoover_curve (mat, pop)
hoover_curve (mat, pop, plot = FALSE)

## run the function by aggregating all industries
hoover_curve (rowSums(mat), pop)
hoover_curve (rowSums(mat), pop, plot = FALSE)

## run the function for industry #1 only
hoover_curve (mat[,1], pop)
hoover_curve (mat[,1], pop, plot = FALSE)

## run the function for industry #2 only (perfectly proportional to population)
hoover_curve (mat[,2], pop)
hoover_curve (mat[,2], pop, plot = FALSE)

## run the function for industry #3 only (30% of the pop. produces 100% of the output)
hoover_curve (mat[,3], pop)
hoover_curve (mat[,3], pop, plot = FALSE)

## run the function for industry #4 only (55% of the pop. produces 100% of the output)
hoover_curve (mat[,4], pop)
hoover_curve (mat[,4], pop, plot = FALSE)

## Compare the distribution of the #industries
oldpar &lt;- par(mfrow = c(2, 2))  # Save the current graphical parameter settings
hoover_curve (mat[,1], pop)
hoover_curve (mat[,2], pop)
hoover_curve (mat[,3], pop)
hoover_curve (mat[,4], pop)
par(oldpar)  # Reset the graphical parameters to their original values

## Save output as pdf
hoover_curve (mat, pop, pdf = TRUE)

## To specify an output directory for the pdf,
## specify 'pdf_location', for instance as '/Users/jones/hoover_curve.pdf'
## hoover_curve(mat, pop, pdf = TRUE, pdf_location = '/Users/jones/hoover_curve.pdf')


</code></pre>

<hr>
<h2 id='hoover_gini'>Compute the Hoover Gini</h2><span id='topic+hoover_gini'></span>

<h3>Description</h3>

<p>This function computes the Hoover Gini, named after Hedgar hoover_ The Hoover index is a measure of spatial inequality. It ranges from 0 (perfect equality) to 1 (perfect inequality) and is calculated from the Hoover curve associated with a given distribution of population, industries or technologies and a reference category. In this sense, it is closely related to the Gini coefficient and the Hoover index. The numerator is given by the area between the Hoover curve of the distribution and the uniform distribution line (45 degrees line). The denominator is the area under the uniform distribution line (the lower triangle).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hoover_gini(mat, pop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hoover_gini_+3A_mat">mat</code></td>
<td>
<p>An incidence matrix with regions in rows and industries in columns. The input can also be a vector of industrial regional count (a matrix with n regions in rows and a single column).</p>
</td></tr>
<tr><td><code id="hoover_gini_+3A_pop">pop</code></td>
<td>
<p>A vector of population regional count</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Hoover Gini value(s). If the input matrix has a single column, the function returns a numeric value representing the Hoover Gini index. If the input matrix has multiple columns, the function returns a data frame with two columns: &quot;Industry&quot; (names of the industries) and &quot;hoover_gini&quot; (corresponding Hoover Gini values).
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>References</h3>

<p>Hoover, E.M. (1936) The Measurement of Industrial Localization, <em>The Review of Economics and Statistics</em> <strong>18</strong> (1): 162-171
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hoover_curve">hoover_curve</a></code>, <code><a href="#topic+locational_gini">locational_gini</a></code>, <code><a href="#topic+locational_gini_curve">locational_gini_curve</a></code>, <code><a href="#topic+lorenz_curve">lorenz_curve</a></code>, <code><a href="#topic+gini">gini</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate vectors of industrial and population count
ind &lt;- c(0, 10, 10, 30, 50)
pop &lt;- c(10, 15, 20, 25, 30)

## run the function (30% of the population produces 50% of the industrial output)
hoover_gini(ind, pop)

## generate a region - industry matrix
mat &lt;- matrix(
  c(
    0, 10, 0, 0,
    0, 15, 0, 0,
    0, 20, 0, 0,
    0, 25, 0, 1,
    0, 30, 1, 1
  ),
  ncol = 4, byrow = TRUE
)
rownames(mat) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat) &lt;- c("I1", "I2", "I3", "I4")

## run the function
hoover_gini(mat, pop)

## run the function by aggregating all industries
hoover_gini(rowSums(mat), pop)

## run the function for industry #1 only
hoover_gini(mat[, 1], pop)

## run the function for industry #2 only (perfectly proportional to population)
hoover_gini(mat[, 2], pop)

## run the function for industry #3 only (30% of the pop. produces 100% of the output)
hoover_gini(mat[, 3], pop)

## run the function for industry #4 only (55% of the pop. produces 100% of the output)
hoover_gini(mat[, 4], pop)

</code></pre>

<hr>
<h2 id='hoover_index'>Compute the Hoover index</h2><span id='topic+hoover_index'></span>

<h3>Description</h3>

<p>This function computes the Hoover index, named after Hedgar Hoover. The Hoover index is a measure of spatial inequality. It ranges from 0 (perfect equality) to 100 (perfect inequality) and is calculated from the Lorenz curve associated with a given distribution of population, industries or technologies. In this sense, it is closely related to the Gini coefficient. The Hoover index represents the maximum vertical distance between the Lorenz curve and the 45 degree line of perfect spatial equality. It indicates the proportion of industries, jobs, or population needed to be transferred from the top to the bottom of the distribution to achieve perfect spatial equality. The Hoover index is also known as the Robin Hood index in studies of income inequality.<br />
<br />
Computation of the Hoover index: <code class="reqn">H=1/2\sum _{ i=1 }^{ N }{ \left| \frac { { E }_{ i } }{ { E }_{ total } } -\frac { { A }_{ i } }{ { A }_{ total } }  \right|  }  </code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hoover_index(mat, pop)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hoover_index_+3A_mat">mat</code></td>
<td>
<p>An incidence matrix with regions in rows and industries in columns. The input can also be a vector of industrial regional count (a matrix with n regions in rows and a single column).</p>
</td></tr>
<tr><td><code id="hoover_index_+3A_pop">pop</code></td>
<td>
<p>A vector of population regional count; if this argument is missing an equal distribution of the reference group will be assumed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The Hoover index value(s) as either a numeric value or a data frame with two columns: &quot;Industry&quot; (names of the industries) and &quot;hoover_index&quot; (corresponding Hoover index values).
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>References</h3>

<p>Hoover, E.M. (1936) The Measurement of Industrial Localization, <em>The Review of Economics and Statistics</em> <strong>18</strong> (1): 162-171
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hoover_curve">hoover_curve</a></code>, <code><a href="#topic+hoover_gini">hoover_gini</a></code>, <code><a href="#topic+locational_gini">locational_gini</a></code>, <code><a href="#topic+locational_gini_curve">locational_gini_curve</a></code>, <code><a href="#topic+lorenz_curve">lorenz_curve</a></code>, <code><a href="#topic+gini">gini</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate vectors of industrial and population count
ind &lt;- c(0, 10, 10, 30, 50)
pop &lt;- c(10, 15, 20, 25, 30)

## run the function (30% of the population produces 50% of the industrial output)
hoover_index(ind, pop)

## generate a region - industry matrix
mat &lt;- matrix(
  c(
    0, 10, 0, 0,
    0, 15, 0, 0,
    0, 20, 0, 0,
    0, 25, 0, 1,
    0, 30, 1, 1
  ),
  ncol = 4, byrow = TRUE
)
rownames(mat) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat) &lt;- c("I1", "I2", "I3", "I4")

## run the function
hoover_index(mat, pop)

## run the function by aggregating all industries
hoover_index(rowSums(mat), pop)

## run the function for industry #1 only
hoover_index(mat[, 1], pop)

## run the function for industry #2 only (perfectly proportional to population)
hoover_index(mat[, 2], pop)

## run the function for industry #3 only (30% of the pop. produces 100% of the output)
hoover_index(mat[, 3], pop)

## run the function for industry #4 only (55% of the pop. produces 100% of the output)
hoover_index(mat[, 4], pop)

</code></pre>

<hr>
<h2 id='inv_norm_ubiquity'>Compute a measure of complexity from the inverse of the normalized ubiquity of industries</h2><span id='topic+inv_norm_ubiquity'></span>

<h3>Description</h3>

<p>This function computes a measure of complexity from the inverse of the normalized ubiquity of industries. We divide the logarithm of the total count (employment, number of firms, number of patents, ...) in an industry by its ubiquity. Ubiquity is given by the number of regions in which an industry can be found (location quotient &gt; 1) from regions - industries (incidence) matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inv_norm_ubiquity(mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inv_norm_ubiquity_+3A_mat">mat</code></td>
<td>
<p>An incidence matrix with regions in rows and industries in columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of complexity values computed from the inverse of the normalized ubiquity of industries.
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>References</h3>

<p>Balland, P.A. and Rigby, D. (2017) The Geography of Complex Knowledge, <em>Economic Geography</em> <strong>93</strong> (1): 1-23.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diversity">diversity</a></code>, <code><a href="#topic+location_quotient">location_quotient</a></code>, <code><a href="#topic+ubiquity">ubiquity</a></code>, <code><a href="#topic+tci">tci</a></code>, <code><a href="#topic+mort">mort</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a region - industry matrix with full count
set.seed(31)
mat &lt;- matrix(sample(0:10, 20, replace = TRUE), ncol = 4)
rownames(mat) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat) &lt;- c("I1", "I2", "I3", "I4")

## run the function
inv_norm_ubiquity(mat)
</code></pre>

<hr>
<h2 id='kci'>Compute an index of knowledge complexity of regions using the eigenvector method</h2><span id='topic+kci'></span>

<h3>Description</h3>

<p>This function computes an index of knowledge complexity of regions using the eigenvector method from regions - industries (incidence) matrices. Technically, the function returns the eigenvector associated with the second largest eigenvalue of the projected region - region matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kci(mat, rca = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kci_+3A_mat">mat</code></td>
<td>
<p>An incidence matrix with regions in rows and industries in columns</p>
</td></tr>
<tr><td><code id="kci_+3A_rca">rca</code></td>
<td>
<p>Logical; should the index of relative comparative advantage (RCA - also refered to as location quotient) first be computed? Defaults to FALSE (a binary matrix - 0/1 - is expected as an input), but can be set to TRUE if the index of relative comparative advantage first needs to be computed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector representing the index of knowledge complexity of regions computed using the eigenvector method.
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>References</h3>

<p>Hidalgo, C. and Hausmann, R. (2009) The building blocks of economic complexity, <em>Proceedings of the National Academy of Sciences</em> <strong>106</strong>: 10570 - 10575. <br />
<br />
Balland, P.A. and Rigby, D. (2017) The Geography of Complex Knowledge, <em>Economic Geography</em> <strong>93</strong> (1): 1-23.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+location_quotient">location_quotient</a></code>, <code><a href="#topic+ubiquity">ubiquity</a></code>, <code><a href="#topic+diversity">diversity</a></code>, <code><a href="#topic+morc">morc</a></code>, <code><a href="#topic+tci">tci</a></code>, <code><a href="#topic+mort">mort</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a region - industry matrix with full count
set.seed(31)
mat &lt;- matrix(sample(0:10, 20, replace = TRUE), ncol = 4)
rownames(mat) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat) &lt;- c("I1", "I2", "I3", "I4")

## run the function
kci(mat, rca = TRUE)

## generate a region - industry matrix in which cells represent the presence/absence of a RCA
set.seed(31)
mat &lt;- matrix(sample(0:1, 20, replace = TRUE), ncol = 4)
rownames(mat) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat) &lt;- c("I1", "I2", "I3", "I4")

## run the function
kci(mat)

## generate the simple network of Hidalgo and Hausmann (2009) presented p.11 (Fig. S4)
countries &lt;- c("C1", "C1", "C1", "C1", "C2", "C3", "C3", "C4")
products &lt;- c("P1", "P2", "P3", "P4", "P2", "P3", "P4", "P4")
my_data &lt;- data.frame(countries, products)
my_data$freq &lt;- 1
mat &lt;- get_matrix(my_data)

## run the function
kci(mat)
</code></pre>

<hr>
<h2 id='krugman_index'>Compute the Krugman index from regions - industries matrices</h2><span id='topic+krugman_index'></span>

<h3>Description</h3>

<p>This function computes the Krugman index from regions - industries matrices. The higher the coefficient, the greater the regional specialization. This index is often referred to as the Krugman specialisation index and measures the distance between the distributions of industry shares in a region and at a more aggregated level (country for instance).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>krugman_index(mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="krugman_index_+3A_mat">mat</code></td>
<td>
<p>An incidence matrix with regions in rows and industries in columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector representing the Krugman index of regional specialization computed from the regions - industries matrix.
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>References</h3>

<p>Krugman P. (1991) <em>Geography and Trade</em>, MIT Press, Cambridge
</p>


<h3>See Also</h3>

<p><code><a href="#topic+location_quotient_avg">location_quotient_avg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a region - industry matrix
set.seed(31)
mat &lt;- matrix(sample(0:100, 20, replace = TRUE), ncol = 4)
rownames(mat) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat) &lt;- c("I1", "I2", "I3", "I4")

## run the function
krugman_index(mat)
</code></pre>

<hr>
<h2 id='location_quotient'>Compute location quotients from regions - industries matrices</h2><span id='topic+location_quotient'></span>

<h3>Description</h3>

<p>This function computes location quotients from (incidence) regions - industries matrices. The numerator is the share of a given industry in a given region. The denominator is the share of a this industry in a larger economy (overall country for instance). This index is also refered to as the index of Revealed Comparative Advantage (RCA) following Ballasa (1965), or the Hoover-Balassa index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>location_quotient(mat, binary = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="location_quotient_+3A_mat">mat</code></td>
<td>
<p>An incidence matrix with regions in rows and industries in columns</p>
</td></tr>
<tr><td><code id="location_quotient_+3A_binary">binary</code></td>
<td>
<p>Logical; shall the returned output be a dichotomized version (0/1) of the location quotient? Defaults to FALSE (the full values of the location quotient will be returned), but can be set to TRUE (location quotient values above 1 will be set to 1 &amp; location quotient values below 1 will be set to 0)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of location quotients computed from the regions - industries matrix. If the 'binary' parameter is set to TRUE, the returned matrix will contain binary values (0/1) representing the location quotient. If 'binary' is set to FALSE, the full values of the location quotient will be returned.
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>References</h3>

<p>Balassa, B. (1965) Trade Liberalization and Revealed Comparative Advantage, <em>The Manchester School</em> <strong>33</strong>: 99-123.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rca">rca</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a region - industry matrix
mat &lt;- matrix(
  c(
    100, 0, 0, 0, 0,
    0, 15, 5, 70, 10,
    0, 20, 10, 20, 50,
    0, 25, 30, 5, 40,
    0, 40, 55, 5, 0
  ),
  ncol = 5, byrow = TRUE
)
rownames(mat) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat) &lt;- c("I1", "I2", "I3", "I4", "I5")

## run the function
location_quotient(mat)
location_quotient(mat, binary = TRUE)
</code></pre>

<hr>
<h2 id='location_quotient_avg'>Compute average location quotients of regions from regions - industries matrices</h2><span id='topic+location_quotient_avg'></span>

<h3>Description</h3>

<p>This function computes the average location quotients of regions from (incidence) regions - industries matrices. This index is also referred to as the <em>coefficient of specialization</em> (Hoover and Giarratani, 1985).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>location_quotient_avg(mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="location_quotient_avg_+3A_mat">mat</code></td>
<td>
<p>An incidence matrix with regions in rows and industries in columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of average location quotients computed for each region from the regions - industries matrix. The average location quotient represents the degree of specialization of each region in different industries.
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>References</h3>

<p>Hoover, E.M. and Giarratani, F. (1985) <em>An Introduction to Regional Economics</em>. 3rd edition. New York: Alfred A. Knopf <br />
<br />
Boschma, R., Balland, P.A. and Kogler, D. (2015) Relatedness and Technological Change in Cities: The rise and fall of technological knowledge in U.S. metropolitan areas from 1981 to 2010, <em>Industrial and Corporate Change</em> <strong>24</strong> (1): 223-250
</p>


<h3>See Also</h3>

<p><code><a href="#topic+location_quotient">location_quotient</a></code>, <code><a href="#topic+hachman">hachman</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a region - industry matrix
mat &lt;- matrix(
  c(
    100, 0, 0, 0, 0,
    0, 15, 5, 70, 10,
    0, 20, 10, 20, 50,
    0, 25, 30, 5, 40,
    0, 40, 55, 5, 0
  ),
  ncol = 5, byrow = TRUE
)
rownames(mat) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat) &lt;- c("I1", "I2", "I3", "I4", "I5")

## run the function
location_quotient_avg(mat)
</code></pre>

<hr>
<h2 id='locational_gini'>Compute the locational Gini coefficient from regions - industries matrices</h2><span id='topic+locational_gini'></span>

<h3>Description</h3>

<p>This function computes the locational Gini coefficient as proposed by Krugman from regions - industries matrices. The higher the coefficient (theoretical limit = 0.5), the greater the industrial concentration. The locational Gini of an industry that is not localized at all (perfectly spread out) in proportion to overall employment would be 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locational_gini(mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locational_gini_+3A_mat">mat</code></td>
<td>
<p>An incidence matrix with regions in rows and industries in columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with two columns: &quot;Industry&quot; and &quot;Loc_gini&quot;. The &quot;Industry&quot; column contains the names of the industries, and the &quot;Loc_gini&quot; column contains the locational Gini coefficient computed for each industry from the regions - industries matrix.
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>References</h3>

<p>Krugman P. (1991) <em>Geography and Trade</em>, MIT Press, Cambridge (chapter 2 - p.56)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hoover_gini">hoover_gini</a></code>, <code><a href="#topic+locational_gini_curve">locational_gini_curve</a></code>, <code><a href="#topic+hoover_curve">hoover_curve</a></code>, <code><a href="#topic+lorenz_curve">lorenz_curve</a></code>, <code><a href="#topic+gini">gini</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a region - industry matrix
mat &lt;- matrix(
  c(
    100, 0, 0, 0, 0,
    0, 15, 5, 70, 10,
    0, 20, 10, 20, 50,
    0, 25, 30, 5, 40,
    0, 40, 55, 5, 0
  ),
  ncol = 5, byrow = TRUE
)
rownames(mat) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat) &lt;- c("I1", "I2", "I3", "I4", "I5")

## run the function
locational_gini(mat)
</code></pre>

<hr>
<h2 id='locational_gini_curve'>Plot a locational Gini curve from regions - industries matrices</h2><span id='topic+locational_gini_curve'></span>

<h3>Description</h3>

<p>This function plots a locational Gini curve following Krugman from regions - industries matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locational_gini_curve(mat, pdf = FALSE, pdf_location = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locational_gini_curve_+3A_mat">mat</code></td>
<td>
<p>An incidence matrix with regions in rows and industries in columns. The input can also be a vector of industrial regional count (a matrix with n regions in rows and a single column).</p>
</td></tr>
<tr><td><code id="locational_gini_curve_+3A_pdf">pdf</code></td>
<td>
<p>Logical; shall a pdf be saved?  Defaults to FALSE. If set to TRUE, a pdf with all will be compiled and saved to R's temp dir if no 'pdf_location' is specified.</p>
</td></tr>
<tr><td><code id="locational_gini_curve_+3A_pdf_location">pdf_location</code></td>
<td>
<p>Output location of pdf file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value, produces a plot or pdf.
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>References</h3>

<p>Krugman P. (1991) <em>Geography and Trade</em>, MIT Press, Cambridge (chapter 2 - p.56)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hoover_gini">hoover_gini</a></code>, <code><a href="#topic+locational_gini">locational_gini</a></code>, <code><a href="#topic+hoover_curve">hoover_curve</a></code>, <code><a href="#topic+lorenz_curve">lorenz_curve</a></code>, <code><a href="#topic+gini">gini</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## generate a region - industry matrix
mat &lt;- matrix(
  c(
    100, 0, 0, 0, 0,
    0, 15, 5, 70, 10,
    0, 20, 10, 20, 50,
    0, 25, 30, 5, 40,
    0, 40, 55, 5, 0
  ),
  ncol = 5, byrow = TRUE
)
rownames(mat) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat) &lt;- c("I1", "I2", "I3", "I4", "I5")

## run the function (shows industry #5)
locational_gini_curve(mat, pdf = FALSE)
locational_gini_curve(mat, pdf = FALSE)

## Save output as pdf
locational_gini_curve(mat, pdf = TRUE)

## To specify an output directory for the pdf,
## specify 'pdf_location', for instance as '/Users/jones/locational_gini_curve.pdf'
## locational_gini_curve(mat, pdf = TRUE, pdf_location = '/Users/jones/locational_gini_curve.pdf')

</code></pre>

<hr>
<h2 id='lorenz_curve'>Plot a Lorenz curve from regional industrial counts</h2><span id='topic+lorenz_curve'></span>

<h3>Description</h3>

<p>This function plots a Lorenz curve from regional industrial counts. This curve gives an indication of the unequal distribution of an industry accross regions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lorenz_curve(mat, plot = TRUE, pdf = TRUE, pdf_location = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lorenz_curve_+3A_mat">mat</code></td>
<td>
<p>An incidence matrix with regions in rows and industries in columns. The input can also be a vector of industrial regional count (a matrix with n regions in rows and a single column).</p>
</td></tr>
<tr><td><code id="lorenz_curve_+3A_plot">plot</code></td>
<td>
<p>Logical; shall the curve be automatically plotted? Defaults to TRUE. If set to TRUE, the function will return x y coordinates that you can latter use to plot and customize the curve.</p>
</td></tr>
<tr><td><code id="lorenz_curve_+3A_pdf">pdf</code></td>
<td>
<p>Logical; shall a pdf be saved?  Defaults to FALSE. If set to TRUE, a pdf with all will be compiled and saved to R's temp dir if no 'pdf_location' is specified.</p>
</td></tr>
<tr><td><code id="lorenz_curve_+3A_pdf_location">pdf_location</code></td>
<td>
<p>Output location of pdf file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If 'plot = FALSE', the function returns a list with two components:
- 'cum.reg': A vector of cumulative proportions of regions.
- 'cum.out': A vector of cumulative proportions of industrial output.
If 'plot = TRUE', the function generates a plot of the Lorenz curve and does not return a value.
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>References</h3>

<p>Lorenz, M. O. (1905) Methods of measuring the concentration of wealth, <em>Publications of the American Statistical Association</em> <strong>9</strong>: 209–219
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hoover_gini">hoover_gini</a></code>, <code><a href="#topic+locational_gini">locational_gini</a></code>, <code><a href="#topic+locational_gini_curve">locational_gini_curve</a></code>, <code><a href="#topic+hoover_curve">hoover_curve</a></code>, <code><a href="#topic+gini">gini</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate vectors of industrial count
ind &lt;- c(0, 10, 10, 30, 50)

## run the function
lorenz_curve (ind)
lorenz_curve (ind, plot = FALSE)

## generate a region - industry matrix
mat = matrix (
c (0, 1, 0, 0,
0, 1, 0, 0,
0, 1, 0, 0,
0, 1, 0, 1,
0, 1, 1, 1), ncol = 4, byrow = TRUE)
rownames(mat) &lt;- c ("R1", "R2", "R3", "R4", "R5")
colnames(mat) &lt;- c ("I1", "I2", "I3", "I4")

## run the function
lorenz_curve (mat)
lorenz_curve (mat, plot = FALSE)

## run the function by aggregating all industries
lorenz_curve (rowSums(mat))
lorenz_curve (rowSums(mat), plot = FALSE)

## run the function for industry #1 only (perfect equality)
lorenz_curve (mat[,1])
lorenz_curve (mat[,1], plot = FALSE)

## run the function for industry #2 only (perfect equality)
lorenz_curve (mat[,2])
lorenz_curve (mat[,2], plot = FALSE)

## run the function for industry #3 only (perfect unequality)
lorenz_curve (mat[,3])
lorenz_curve (mat[,3], plot = FALSE)

## run the function for industry #4 only (top 40% produces 100% of the output)
lorenz_curve (mat[,4])
lorenz_curve (mat[,4], plot = FALSE)

## Compare the distribution of the #industries
oldpar &lt;- par(mfrow = c(2, 2))  # Save the current graphical parameter settings
lorenz_curve (mat[,1])
lorenz_curve (mat[,2])
lorenz_curve (mat[,3])
lorenz_curve (mat[,4])
par(oldpar)  # Reset the graphical parameters to their original values

## Save output as pdf
lorenz_curve (mat, pdf = TRUE)

## To specify an output directory for the pdf,
## specify 'pdf_location', for instance as '/Users/jones/lorenz_curve.pdf'
## lorenz_curve(mat, pdf = TRUE, pdf_location = '/Users/jones/lorenz_curve.pdf')

</code></pre>

<hr>
<h2 id='match_mat'>Re-arrange the dimension of a matrix based on the dimension of another matrix</h2><span id='topic+match_mat'></span>

<h3>Description</h3>

<p>This function e-arranges the dimension of a matrix based on the dimension of another matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>match_mat(fill, dim, missing = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="match_mat_+3A_fill">fill</code></td>
<td>
<p>A matrix that will be used to populate the matrix output</p>
</td></tr>
<tr><td><code id="match_mat_+3A_dim">dim</code></td>
<td>
<p>A matrix that will be used to determine the dimensions of the matrix output</p>
</td></tr>
<tr><td><code id="match_mat_+3A_missing">missing</code></td>
<td>
<p>Logical; Shall the cells of the non matching rows/columns set to NA? Default to TRUE but can be set to FALSE to set the cells of the non matching rows/columns to 0 instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The matrix output with the dimensions rearranged based on the input 'dim' matrix.
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+location_quotient">location_quotient</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a first region - industry matrix
set.seed(31)
mat1 &lt;- matrix(sample(0:1, 20, replace = TRUE), ncol = 4)
rownames(mat1) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat1) &lt;- c("I1", "I2", "I3", "I4")

## generate a second region - industry matrix
set.seed(31)
mat2 &lt;- matrix(sample(0:1, 16, replace = TRUE), ncol = 4)
rownames(mat2) &lt;- c("R1", "R2", "R3", "R5")
colnames(mat2) &lt;- c("I1", "I2", "I3", "I4")

## run the function
match_mat(fill = mat1, dim = mat2)
match_mat(fill = mat2, dim = mat1)
match_mat(fill = mat2, dim = mat1, missing = FALSE)
</code></pre>

<hr>
<h2 id='modular_complexity'>Compute a measure of modular complexity of patent documents</h2><span id='topic+modular_complexity'></span>

<h3>Description</h3>

<p>This function computes a measure of modular complexity of patent documents from technological classes - patents (incidence) matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modular_complexity(mat, sparse = FALSE, list = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modular_complexity_+3A_mat">mat</code></td>
<td>
<p>A bipartite adjacency matrix (can be a sparse matrix)</p>
</td></tr>
<tr><td><code id="modular_complexity_+3A_sparse">sparse</code></td>
<td>
<p>Logical; is the input matrix a sparse matrix? Defaults to FALSE, but can be set to TRUE if the input matrix is a sparse matrix</p>
</td></tr>
<tr><td><code id="modular_complexity_+3A_list">list</code></td>
<td>
<p>Logical; is the input a list? Defaults to FALSE (input = adjacency matrix), but can be set to TRUE if the input is an edge list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns &quot;patent&quot; and &quot;mod.comp&quot; representing the patents and their corresponding modular complexity values.
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>References</h3>

<p>Fleming, L. and Sorenson, O. (2001) Technology as a complex adaptive system: evidence from patent data, <em>Research Policy</em> <strong>30</strong>: 1019-1039
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ease_recombination">ease_recombination</a></code>, <code><a href="#topic+tci">tci</a></code>, <code><a href="#topic+mort">mort</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a technology - patent matrix
set.seed(31)
mat &lt;- matrix(sample(0:1, 30, replace = TRUE), ncol = 5)
rownames(mat) &lt;- c("T1", "T2", "T3", "T4", "T5", "T6")
colnames(mat) &lt;- c("US1", "US2", "US3", "US4", "US5")

## run the function
modular_complexity(mat)

## generate a technology - patent sparse matrix
library(Matrix)

## run the function
smat &lt;- Matrix(mat, sparse = TRUE)

modular_complexity(smat, sparse = TRUE)
## generate a regular data frame (list)
my_list &lt;- get_list(mat)

## run the function
modular_complexity(my_list, list = TRUE)
</code></pre>

<hr>
<h2 id='modular_complexity_avg'>Compute a measure of average modular complexity of technologies</h2><span id='topic+modular_complexity_avg'></span>

<h3>Description</h3>

<p>This function computes a measure of average modular complexity of technologies (average complexity of patent documents in a given technological class) from technological classes - patents (incidence) matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modular_complexity_avg(mat, sparse = FALSE, list = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modular_complexity_avg_+3A_mat">mat</code></td>
<td>
<p>A bipartite adjacency matrix (can be a sparse matrix)</p>
</td></tr>
<tr><td><code id="modular_complexity_avg_+3A_sparse">sparse</code></td>
<td>
<p>Logical; is the input matrix a sparse matrix? Defaults to FALSE, but can be set to TRUE if the input matrix is a sparse matrix</p>
</td></tr>
<tr><td><code id="modular_complexity_avg_+3A_list">list</code></td>
<td>
<p>Logical; is the input a list? Defaults to FALSE (input = adjacency matrix), but can be set to TRUE if the input is an edge list</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with columns &quot;tech&quot; and &quot;avg.mod.comp&quot; representing the technologies and their corresponding average modular complexity values.
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>References</h3>

<p>Fleming, L. and Sorenson, O. (2001) Technology as a complex adaptive system: evidence from patent data, <em>Research Policy</em> <strong>30</strong>: 1019-1039
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ease_recombination">ease_recombination</a></code>, <code><a href="#topic+tci">tci</a></code>, <code><a href="#topic+mort">mort</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a technology - patent matrix
set.seed(31)
mat &lt;- matrix(sample(0:1, 30, replace = TRUE), ncol = 5)
rownames(mat) &lt;- c("T1", "T2", "T3", "T4", "T5", "T6")
colnames(mat) &lt;- c("US1", "US2", "US3", "US4", "US5")

## run the function
modular_complexity_avg(mat)

## generate a technology - patent sparse matrix
library(Matrix)

## run the function
smat &lt;- Matrix(mat, sparse = TRUE)

modular_complexity_avg(smat, sparse = TRUE)
## generate a regular data frame (list)
my_list &lt;- get_list(mat)

## run the function
modular_complexity_avg(my_list, list = TRUE)
</code></pre>

<hr>
<h2 id='morc'>Compute an index of knowledge complexity of regions using the method of reflection</h2><span id='topic+morc'></span>

<h3>Description</h3>

<p>This function computes an index of knowledge complexity of regions using the method of reflection from regions - industries (incidence) matrices. The index has been developed by Hidalgo and Hausmann (2009) for country - product matrices and adapted by Balland and Rigby (2016) to city - technology matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>morc(mat, rca = FALSE, steps = 20)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="morc_+3A_mat">mat</code></td>
<td>
<p>An incidence matrix with regions in rows and industries in columns</p>
</td></tr>
<tr><td><code id="morc_+3A_rca">rca</code></td>
<td>
<p>Logical; should the index of relative comparative advantage (RCA - also refered to as location quotient) first be computed? Defaults to FALSE (a binary matrix - 0/1 - is expected as an input), but can be set to TRUE if the index of relative comparative advantage first needs to be computed</p>
</td></tr>
<tr><td><code id="morc_+3A_steps">steps</code></td>
<td>
<p>Number of iteration steps. Defaults to 20, but can be set to 0 to give diversity (number of industry in which a region has a RCA), to 1 to give  the average ubiquity of the industries in which a region has a RCA, to 2 to give the average diversity of regions that have similar industrial structures, or to any other number of steps &lt; or = to 22. Note that above steps = 2 the index will be rescaled from 0 (minimum relative complexity) to 100 (maximum relative complexity).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If 'steps' is set to 0, the function returns a numeric vector representing the diversification of regions. Otherwise, it returns
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>References</h3>

<p>Hidalgo, C. and Hausmann, R. (2009) The building blocks of economic complexity, <em>Proceedings of the National Academy of Sciences</em> <strong>106</strong>: 10570 - 10575. <br />
<br />
Balland, P.A. and Rigby, D. (2017) The Geography of Complex Knowledge, <em>Economic Geography</em> <strong>93</strong> (1): 1-23.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+location_quotient">location_quotient</a></code>, <code><a href="#topic+ubiquity">ubiquity</a></code>, <code><a href="#topic+diversity">diversity</a></code>, <code><a href="#topic+kci">kci</a></code>, <code><a href="#topic+tci">tci</a></code>, <code><a href="#topic+mort">mort</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a region - industry matrix with full count
set.seed(31)
mat &lt;- matrix(sample(0:10, 20, replace = TRUE), ncol = 4)
rownames(mat) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat) &lt;- c("I1", "I2", "I3", "I4")

## run the function
morc(mat, rca = TRUE)
morc(mat, rca = TRUE, steps = 0)
morc(mat, rca = TRUE, steps = 1)
morc(mat, rca = TRUE, steps = 2)

## generate a region - industry matrix in which cells represent the presence/absence of an RCA
set.seed(32)
mat &lt;- matrix(sample(0:1, 20, replace = TRUE), ncol = 4)
rownames(mat) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat) &lt;- c("I1", "I2", "I3", "I4")

## run the function
morc(mat)
morc(mat, steps = 0)
morc(mat, steps = 1)
morc(mat, steps = 2)

## generate the simple network of Hidalgo and Hausmann (2009) presented p.11 (Fig. S4)
countries &lt;- c("C1", "C1", "C1", "C1", "C2", "C3", "C3", "C4")
products &lt;- c("P1", "P2", "P3", "P4", "P2", "P3", "P4", "P4")
my_data &lt;- data.frame(countries, products)
my_data$freq &lt;- 1
mat &lt;- get_matrix(my_data)

## run the function
morc(mat)
morc(mat, steps = 0)
morc(mat, steps = 1)
morc(mat, steps = 2)
</code></pre>

<hr>
<h2 id='mort'>Compute an index of knowledge complexity of industries using the method of reflection</h2><span id='topic+mort'></span>

<h3>Description</h3>

<p>This function computes an index of knowledge complexity of industries using the method of reflection from regions - industries (incidence) matrices. The index has been developed by Hidalgo and Hausmann (2009) for country - product matrices and adapted by Balland and Rigby (2016) to city - technology matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mort(mat, rca = FALSE, steps = 19)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mort_+3A_mat">mat</code></td>
<td>
<p>An incidence matrix with regions in rows and industries in columns</p>
</td></tr>
<tr><td><code id="mort_+3A_rca">rca</code></td>
<td>
<p>Logical; should the index of relative comparative advantage (RCA - also refered to as location quotient) first be computed? Defaults to FALSE (a binary matrix - 0/1 - is expected as an input), but can be set to TRUE if the index of relative comparative advantage first needs to be computed</p>
</td></tr>
<tr><td><code id="mort_+3A_steps">steps</code></td>
<td>
<p>Number of iteration steps. Defaults to 19, but can be set to 0 to give ubiquity (number of regions that have a RCA in a industry), to 1 to give  the average diversity of the regions that have a RCA in this industry, to 2 to give the average ubiquity of technologies developed in the same regions, or to any other number of steps &lt; or = to 21. Note that above steps = 2 the index will be rescaled from 0 (minimum relative complexity) to 100 (maximum relative complexity).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If 'steps' is set to 0, the function returns a numeric vector representing the ubiquity (number of regions that have a relative comparative advantage) of industries. Otherwise, it returns a numeric vector representing the index of knowledge complexity of industries based on the specified number of iteration steps.
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>References</h3>

<p>Hidalgo, C. and Hausmann, R. (2009) The building blocks of economic complexity, <em>Proceedings of the National Academy of Sciences</em> <strong>106</strong>: 10570 - 10575. <br />
<br />
Balland, P.A. and Rigby, D. (2017) The Geography of Complex Knowledge, <em>Economic Geography</em> <strong>93</strong> (1): 1-23.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+location_quotient">location_quotient</a></code>, <code><a href="#topic+ubiquity">ubiquity</a></code>, <code><a href="#topic+diversity">diversity</a></code>, <code><a href="#topic+kci">kci</a></code>, <code><a href="#topic+tci">tci</a></code>, <code><a href="#topic+morc">morc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a region - industry matrix with full count
set.seed(31)
mat &lt;- matrix(sample(0:10, 20, replace = TRUE), ncol = 4)
rownames(mat) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat) &lt;- c("I1", "I2", "I3", "I4")

## run the function
mort(mat, rca = TRUE)
mort(mat, rca = TRUE, steps = 0)
mort(mat, rca = TRUE, steps = 1)
mort(mat, rca = TRUE, steps = 2)

## generate a region - industry matrix in which cells represent the presence/absence of a rca
set.seed(32)
mat &lt;- matrix(sample(0:1, 20, replace = TRUE), ncol = 4)
rownames(mat) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat) &lt;- c("I1", "I2", "I3", "I4")

## run the function
mort(mat)
mort(mat, steps = 0)
mort(mat, steps = 1)
mort(mat, steps = 2)

## generate the simple network of Hidalgo and Hausmann (2009) presented p.11 (Fig. S4)
countries &lt;- c("C1", "C1", "C1", "C1", "C2", "C3", "C3", "C4")
products &lt;- c("P1", "P2", "P3", "P4", "P2", "P3", "P4", "P4")
my_data &lt;- data.frame(countries, products)
my_data$freq &lt;- 1
mat &lt;- get_matrix(my_data)

## run the function
mort(mat)
mort(mat, steps = 0)
mort(mat, steps = 1)
mort(mat, steps = 2)
</code></pre>

<hr>
<h2 id='norm_ubiquity'>Compute a measure of complexity by normalizing ubiquity of industries</h2><span id='topic+norm_ubiquity'></span>

<h3>Description</h3>

<p>This function computes a measure of complexity by normalizing ubiquity of industries. We divide the share of the total count (employment, number of firms, number of patents, ...) in an industry by its share of ubiquity. Ubiquity is given by the number of regions in which an industry can be found (location quotient &gt; 1) from regions - industries (incidence) matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm_ubiquity(mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="norm_ubiquity_+3A_mat">mat</code></td>
<td>
<p>An incidence matrix with regions in rows and industries in columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector representing the measure of complexity obtained by normalizing the ubiquity of industries. Each value in the vector corresponds to the normalized complexity score of an industry.
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>References</h3>

<p>Balland, P.A. and Rigby, D. (2017) The Geography of Complex Knowledge, <em>Economic Geography</em> <strong>93</strong> (1): 1-23.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diversity">diversity</a></code>, <code><a href="#topic+location_quotient">location_quotient</a></code>, <code><a href="#topic+ubiquity">ubiquity</a></code>, <code><a href="#topic+tci">tci</a></code>, <code><a href="#topic+mort">mort</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a region - industry matrix with full count
set.seed(31)
mat &lt;- matrix(sample(0:10, 20, replace = TRUE), ncol = 4)
rownames(mat) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat) &lt;- c("I1", "I2", "I3", "I4")

## run the function
norm_ubiquity(mat)
</code></pre>

<hr>
<h2 id='prody'>Compute the prody index of industries from regions - industries matrices</h2><span id='topic+prody'></span>

<h3>Description</h3>

<p>This function computes the prody index of industries from (incidence) regions - industries matrices, as proposed by Hausmann, Hwang &amp; Rodrik (2007). The index gives an associated income level for each industry. It represents a weighted average of per-capita GDPs (but GDP can be replaced by R&amp;D, education...), where the weights correspond to the revealed comparative advantage of each region in a given industry (or sector, technology, ...).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prody(mat, vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prody_+3A_mat">mat</code></td>
<td>
<p>An incidence matrix with regions in rows and industries in columns</p>
</td></tr>
<tr><td><code id="prody_+3A_vec">vec</code></td>
<td>
<p>A vector that gives GDP, R&amp;D, education or any other relevant regional attribute that will be used to compute the weighted average for each industry</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector representing the prody index of industries. Each value in the vector corresponds to the associated income level for an industry.
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>References</h3>

<p>Balassa, B. (1965) Trade Liberalization and Revealed Comparative Advantage, <em>The Manchester School</em> <strong>33</strong>: 99-123 <br />
<br />
Hausmann, R., Hwang, J. &amp; Rodrik, D. (2007) What you export matters, <em>Journal of economic growth</em> <strong>12</strong>: 1-25.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+location_quotient">location_quotient</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a region - industry matrix
set.seed(31)
mat &lt;- matrix(sample(0:100, 20, replace = TRUE), ncol = 4)
rownames(mat) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat) &lt;- c("I1", "I2", "I3", "I4")

## a vector of GDP of regions
vec &lt;- c(5, 10, 15, 25, 50)
## run the function
prody(mat, vec)
</code></pre>

<hr>
<h2 id='rca'>Compute an index of revealed comparative advantage (RCA) from regions - industries matrices</h2><span id='topic+rca'></span>

<h3>Description</h3>

<p>This function computes an index of revealed comparative advantage (RCA) from (incidence) regions - industries matrices. The numerator is the share of a given industry in a given region. The denominator is the share of a this industry in a larger economy (overall country for instance). This index is also refered to as a location quotient, or the Hoover-Balassa index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rca(mat, binary = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rca_+3A_mat">mat</code></td>
<td>
<p>An incidence matrix with regions in rows and industries in columns</p>
</td></tr>
<tr><td><code id="rca_+3A_binary">binary</code></td>
<td>
<p>Logical; shall the returned output be a dichotomized version (0/1) of the RCA? Defaults to FALSE (the full values of the RCA will be returned), but can be set to TRUE (RCA above 1 will be set to 1 &amp; RCA values below 1 will be set to 0)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix representing the index of revealed comparative advantage (RCA) or location quotient. Each cell in the matrix corresponds to the RCA value for a specific region and industry. If the 'binary' parameter is set to TRUE, the returned matrix will be dichotomized, with values above 1 set to 1 and values below 1 set to 0.
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>References</h3>

<p>Balassa, B. (1965) Trade Liberalization and Revealed Comparative Advantage, <em>The Manchester School</em> <strong>33</strong>: 99-123.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+location_quotient">location_quotient</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a region - industry matrix
set.seed(31)
mat &lt;- matrix(sample(0:100, 20, replace = TRUE), ncol = 4)
rownames(mat) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat) &lt;- c("I1", "I2", "I3", "I4")

## run the function
rca(mat)
rca(mat, binary = TRUE)
</code></pre>

<hr>
<h2 id='relatedness'>Compute the relatedness between entities (industries, technologies, ...) from their co-occurence matrix</h2><span id='topic+relatedness'></span>

<h3>Description</h3>

<p>This function computes the relatedness between entities (industries, technologies, ...) from their co-occurence (adjacency) matrix. Different normalization procedures are proposed following van Eck and Waltman (2009): association strength, cosine, Jaccard, and an adapted version of the association strength that we refer to as probability index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relatedness(mat, method = "prob")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relatedness_+3A_mat">mat</code></td>
<td>
<p>An adjacency matrix of co-occurences between entities (industries, technologies, cities...)</p>
</td></tr>
<tr><td><code id="relatedness_+3A_method">method</code></td>
<td>
<p>Which normalization method should be used to compute relatedness? Defaults to &quot;prob&quot;, but it can be &quot;association&quot;, &quot;cosine&quot; or &quot;Jaccard&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix representing the relatedness between entities (industries, technologies, etc.) based on their co-occurrence matrix. The specific method of normalization used is determined by the 'method' parameter, which can be &quot;prob&quot; (probability index), &quot;association&quot; (association strength), &quot;cosine&quot; (cosine similarity), or &quot;jaccard&quot; (Jaccard index).
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a> <br />
Joan Crespo <a href="mailto:J.Crespo@uu.nl">J.Crespo@uu.nl</a> <br />
Mathieu Steijn <a href="mailto:M.P.A.Steijn@uu.nl">M.P.A.Steijn@uu.nl</a>
</p>


<h3>References</h3>

<p>van Eck, N.J. and Waltman, L. (2009) How to normalize cooccurrence data? An analysis of some well-known similarity measures, <em>Journal of the American Society for Information Science and Technology</em> <strong>60</strong> (8): 1635-1651 <br />
<br />
Boschma, R., Heimeriks, G. and Balland, P.A. (2014) Scientific Knowledge Dynamics and Relatedness in Bio-Tech Cities, <em>Research Policy</em> <strong>43</strong> (1): 107-114 <br />
<br />
Hidalgo, C.A., Klinger, B., Barabasi, A. and Hausmann, R. (2007) The product space conditions the development of nations, <em>Science</em> <strong>317</strong>: 482-487 <br />
<br />
Balland, P.A. (2016) Relatedness and the Geography of Innovation, in: R. Shearmur, C. Carrincazeaux and D. Doloreux (eds) Handbook on the Geographies of Innovation. Northampton, MA: Edward Elgar <br />
<br />
Steijn, M.P.A. (2017) Improvement on the association strength: implementing probability measures based on combinations without repetition, <em>Working Paper, Utrecht University</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+relatedness_density">relatedness_density</a></code>, <code><a href="#topic+co_occurrence">co_occurrence</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate an industry - industry matrix in which cells give the number of co-occurences
## between two industries
set.seed(31)
mat &lt;- matrix(sample(0:10, 36, replace = TRUE), ncol = 6)
mat[lower.tri(mat, diag = TRUE)] &lt;- t(mat)[lower.tri(t(mat), diag = TRUE)]
rownames(mat) &lt;- c("I1", "I2", "I3", "I4", "I5", "I6")
colnames(mat) &lt;- c("I1", "I2", "I3", "I4", "I5", "I6")

## run the function
relatedness(mat)
relatedness(mat, method = "association")
relatedness(mat, method = "cosine")
relatedness(mat, method = "jaccard")
</code></pre>

<hr>
<h2 id='relatedness_density'>Compute the relatedness density between regions and industries from regions - industries matrices and industries - industries matrices</h2><span id='topic+relatedness_density'></span>

<h3>Description</h3>

<p>This function computes the relatedness density between regions and industries from regions - industries (incidence) matrices and industries - industries (adjacency) matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relatedness_density(mat, relatedness)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relatedness_density_+3A_mat">mat</code></td>
<td>
<p>An incidence matrix with regions in rows and industries in columns</p>
</td></tr>
<tr><td><code id="relatedness_density_+3A_relatedness">relatedness</code></td>
<td>
<p>An adjacency industry - industry matrix indicating the degree of relatedness between industries</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix representing the relatedness density between regions and industries. The values in the matrix indicate the share of industries related to each industry in each region, scaled from 0 to 100. Rows represent regions and columns represent industries.
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>References</h3>

<p>Boschma, R., Balland, P.A. and Kogler, D. (2015) Relatedness and Technological Change in Cities: The rise and fall of technological knowledge in U.S. metropolitan areas from 1981 to 2010, <em>Industrial and Corporate Change</em> <strong>24</strong> (1): 223-250 <br />
<br />
Boschma, R., Heimeriks, G. and Balland, P.A. (2014) Scientific Knowledge Dynamics and Relatedness in Bio-Tech Cities, <em>Research Policy</em> <strong>43</strong> (1): 107-114
</p>


<h3>See Also</h3>

<p><code><a href="#topic+relatedness">relatedness</a></code>, <code><a href="#topic+co_occurrence">co_occurrence</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a region - industry matrix in which cells represent the presence/absence of a RCA
set.seed(31)
mat &lt;- matrix(sample(0:1, 20, replace = TRUE), ncol = 4)
rownames(mat) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat) &lt;- c("I1", "I2", "I3", "I4")

## generate an industry - industry matrix in which cells indicate if two industries are
## related (1) or not (0)
relatedness &lt;- matrix(sample(0:1, 16, replace = TRUE), ncol = 4)
relatedness[lower.tri(relatedness, diag = TRUE)] &lt;- t(relatedness)[lower.tri(t(relatedness),
  diag = TRUE
)]
rownames(relatedness) &lt;- c("I1", "I2", "I3", "I4")
colnames(relatedness) &lt;- c("I1", "I2", "I3", "I4")

## run the function
relatedness_density(mat, relatedness)
</code></pre>

<hr>
<h2 id='relatedness_density_ext'>Compute the relatedness density between regions and industries that are not part of the regional portfolio from regions - industries matrices and industries - industries matrices</h2><span id='topic+relatedness_density_ext'></span>

<h3>Description</h3>

<p>This function computes the relatedness density between regions and industries that are not part of the regional portfolio from regions - industries (incidence) matrices and industries - industries (adjacency) matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relatedness_density_ext(mat, relatedness)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relatedness_density_ext_+3A_mat">mat</code></td>
<td>
<p>An incidence matrix with regions in rows and industries in columns</p>
</td></tr>
<tr><td><code id="relatedness_density_ext_+3A_relatedness">relatedness</code></td>
<td>
<p>An adjacency industry - industry matrix indicating the degree of relatedness between industries</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix representing the relatedness density between regions and industries that are not part of the regional portfolio. The values in the matrix indicate the share of industries related to each industry in each region, scaled from 0 to 100. Rows represent regions and columns represent industries. Industries that are part of the regional portfolio are assigned NA.
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>References</h3>

<p>Boschma, R., Balland, P.A. and Kogler, D. (2015) Relatedness and Technological Change in Cities: The rise and fall of technological knowledge in U.S. metropolitan areas from 1981 to 2010, <em>Industrial and Corporate Change</em> <strong>24</strong> (1): 223-250 <br />
<br />
Boschma, R., Heimeriks, G. and Balland, P.A. (2014) Scientific Knowledge Dynamics and Relatedness in Bio-Tech Cities, <em>Research Policy</em> <strong>43</strong> (1): 107-114
</p>


<h3>See Also</h3>

<p><code><a href="#topic+relatedness">relatedness</a></code>, <code><a href="#topic+co_occurrence">co_occurrence</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a region - industry matrix in which cells represent the presence/absence of a RCA
set.seed(31)
mat &lt;- matrix(sample(0:1, 20, replace = TRUE), ncol = 4)
rownames(mat) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat) &lt;- c("I1", "I2", "I3", "I4")

## generate an industry - industry matrix in which cells indicate if two industries are
## related (1) or not (0)
relatedness &lt;- matrix(sample(0:1, 16, replace = TRUE), ncol = 4)
relatedness[lower.tri(relatedness, diag = TRUE)] &lt;- t(relatedness)[lower.tri(t(relatedness),
  diag = TRUE
)]
rownames(relatedness) &lt;- c("I1", "I2", "I3", "I4")
colnames(relatedness) &lt;- c("I1", "I2", "I3", "I4")

## run the function
relatedness_density_ext(mat, relatedness)
</code></pre>

<hr>
<h2 id='relatedness_density_ext_avg'>Compute the average relatedness density of regions to industries that are not part of the regional portfolio from regions - industries matrices and industries - industries matrices</h2><span id='topic+relatedness_density_ext_avg'></span>

<h3>Description</h3>

<p>This function computes the average relatedness density of regions to industries that are not part of the regional portfolio from regions - industries (incidence) matrices and industries - industries (adjacency) matrices. This is the technological flexibility indicator proposed by Balland et al. (2015).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relatedness_density_ext_avg(mat, relatedness)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relatedness_density_ext_avg_+3A_mat">mat</code></td>
<td>
<p>An incidence matrix with regions in rows and industries in columns</p>
</td></tr>
<tr><td><code id="relatedness_density_ext_avg_+3A_relatedness">relatedness</code></td>
<td>
<p>An adjacency industry - industry matrix indicating the degree of relatedness between industries</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector representing the average relatedness density of regions to industries that are not part of the regional portfolio. The values in the vector indicate the average relatedness density for each region, rounded to the nearest integer.
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>References</h3>

<p>Boschma, R., Balland, P.A. and Kogler, D. (2015) Relatedness and Technological Change in Cities: The rise and fall of technological knowledge in U.S. metropolitan areas from 1981 to 2010, <em>Industrial and Corporate Change</em> <strong>24</strong> (1): 223-250 <br />
<br />
Balland P.A., Rigby, D., and Boschma, R. (2015) The Technological Resilience of U.S. Cities, <em>Cambridge Journal of Regions, Economy and Society</em>, <strong>8</strong> (2): 167-184
</p>


<h3>See Also</h3>

<p><code><a href="#topic+relatedness">relatedness</a></code>, <code><a href="#topic+relatedness_density">relatedness_density</a></code>,  <code><a href="#topic+relatedness_density_ext">relatedness_density_ext</a></code>,  <code><a href="#topic+relatedness_density_int">relatedness_density_int</a></code>,  <code><a href="#topic+relatedness_density_int_avg">relatedness_density_int_avg</a></code>, <code><a href="#topic+relatedness_density_ext_avg">relatedness_density_ext_avg</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a region - industry matrix in which cells represent the presence/absence
## of a RCA
set.seed(31)
mat &lt;- matrix(sample(0:1, 20, replace = TRUE), ncol = 4)
rownames(mat) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat) &lt;- c("I1", "I2", "I3", "I4")

## generate an industry - industry matrix in which cells indicate if two industries are
## related (1) or not (0)
relatedness &lt;- matrix(sample(0:1, 16, replace = TRUE), ncol = 4)
relatedness[lower.tri(relatedness, diag = TRUE)] &lt;- t(relatedness)[lower.tri(t(relatedness),
  diag = TRUE
)]
rownames(relatedness) &lt;- c("I1", "I2", "I3", "I4")
colnames(relatedness) &lt;- c("I1", "I2", "I3", "I4")

## run the function
relatedness_density_ext_avg(mat, relatedness)
</code></pre>

<hr>
<h2 id='relatedness_density_int'>Compute the relatedness density between regions and industries that are part of the regional portfolio from regions - industries matrices and industries - industries matrices</h2><span id='topic+relatedness_density_int'></span>

<h3>Description</h3>

<p>This function computes the relatedness density between regions and industries that are part of the regional portfolio from regions - industries (incidence) matrices and industries - industries (adjacency) matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relatedness_density_int(mat, relatedness)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relatedness_density_int_+3A_mat">mat</code></td>
<td>
<p>An incidence matrix with regions in rows and industries in columns</p>
</td></tr>
<tr><td><code id="relatedness_density_int_+3A_relatedness">relatedness</code></td>
<td>
<p>An adjacency industry - industry matrix indicating the degree of relatedness between industries</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix representing the relatedness density between regions and industries that are part of the regional portfolio. The values in the matrix indicate the relatedness density for each region and industry, scaled from 0 to 100.
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>References</h3>

<p>Boschma, R., Balland, P.A. and Kogler, D. (2015) Relatedness and Technological Change in Cities: The rise and fall of technological knowledge in U.S. metropolitan areas from 1981 to 2010, <em>Industrial and Corporate Change</em> <strong>24</strong> (1): 223-250 <br />
<br />
Boschma, R., Heimeriks, G. and Balland, P.A. (2014) Scientific Knowledge Dynamics and Relatedness in Bio-Tech Cities, <em>Research Policy</em> <strong>43</strong> (1): 107-114
</p>


<h3>See Also</h3>

<p><code><a href="#topic+relatedness">relatedness</a></code>, <code><a href="#topic+co_occurrence">co_occurrence</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a region - industry matrix in which cells represent the presence/absence
## of a RCA
set.seed(31)
mat &lt;- matrix(sample(0:1, 20, replace = TRUE), ncol = 4)
rownames(mat) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat) &lt;- c("I1", "I2", "I3", "I4")

## generate an industry - industry matrix in which cells indicate if two industries are
## related (1) or not (0)
relatedness &lt;- matrix(sample(0:1, 16, replace = TRUE), ncol = 4)
relatedness[lower.tri(relatedness, diag = TRUE)] &lt;- t(relatedness)[lower.tri(t(relatedness),
  diag = TRUE
)]
rownames(relatedness) &lt;- c("I1", "I2", "I3", "I4")
colnames(relatedness) &lt;- c("I1", "I2", "I3", "I4")

## run the function
relatedness_density_int(mat, relatedness)
</code></pre>

<hr>
<h2 id='relatedness_density_int_avg'>Compute the average relatedness density within the regional portfolio from regions - industries matrices and industries - industries matrices</h2><span id='topic+relatedness_density_int_avg'></span>

<h3>Description</h3>

<p>This function computes the average relatedness density within the regional portfolio from regions - industries (incidence) matrices and industries - industries (adjacency) matrices. This is a measure of the technological coherence of the regional industrial structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relatedness_density_int_avg(mat, relatedness)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relatedness_density_int_avg_+3A_mat">mat</code></td>
<td>
<p>An incidence matrix with regions in rows and industries in columns</p>
</td></tr>
<tr><td><code id="relatedness_density_int_avg_+3A_relatedness">relatedness</code></td>
<td>
<p>An adjacency industry - industry matrix indicating the degree of relatedness between industries</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector representing the average relatedness density within the regional portfolio. The values in the vector indicate the average relatedness density for each region, scaled from 0 to 100.
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>References</h3>

<p>Boschma, R., Balland, P.A. and Kogler, D. (2015) Relatedness and Technological Change in Cities: The rise and fall of technological knowledge in U.S. metropolitan areas from 1981 to 2010, <em>Industrial and Corporate Change</em> <strong>24</strong> (1): 223-250 <br />
<br />
Balland P.A., Rigby, D., and Boschma, R. (2015) The Technological Resilience of U.S. Cities, <em>Cambridge Journal of Regions, Economy and Society</em>, <strong>8</strong> (2): 167-184
</p>


<h3>See Also</h3>

<p><code><a href="#topic+relatedness">relatedness</a></code>, <code><a href="#topic+relatedness_density">relatedness_density</a></code>, <code><a href="#topic+relatedness_density_ext">relatedness_density_ext</a></code>, <code><a href="#topic+relatedness_density_int">relatedness_density_int</a></code>, <code><a href="#topic+relatedness_density_ext_avg">relatedness_density_ext_avg</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a region - industry matrix in which cells represent the presence/absence
## of a RCA
set.seed(31)
mat &lt;- matrix(sample(0:1, 20, replace = TRUE), ncol = 4)
rownames(mat) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat) &lt;- c("I1", "I2", "I3", "I4")

## generate an industry - industry matrix in which cells indicate if two industries are
## related (1) or not (0)
relatedness &lt;- matrix(sample(0:1, 16, replace = TRUE), ncol = 4)
relatedness[lower.tri(relatedness, diag = TRUE)] &lt;- t(relatedness)[lower.tri(t(relatedness),
  diag = TRUE
)]
rownames(relatedness) &lt;- c("I1", "I2", "I3", "I4")
colnames(relatedness) &lt;- c("I1", "I2", "I3", "I4")

## run the function
relatedness_density_int_avg(mat, relatedness)
</code></pre>

<hr>
<h2 id='spec_coeff'>Compute the Hoover coefficient of specialization from regions - industries matrices</h2><span id='topic+spec_coeff'></span>

<h3>Description</h3>

<p>This function computes the Hoover coefficient of specialization from regions - industries matrices. The higher the coefficient, the greater the regional specialization. This index is closely related to the Krugman specialisation index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>spec_coeff(mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="spec_coeff_+3A_mat">mat</code></td>
<td>
<p>An incidence matrix with regions in rows and industries in columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector representing the Hoover coefficient of specialization for each region. The values in the vector indicate the degree of regional specialization, with higher values indicating greater specialization.
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>References</h3>

<p>Hoover, E.M. and Giarratani, F. (1985) <em>An Introduction to Regional Economics</em>. 3rd edition. New York: Alfred A. Knopf (see table 9-4 in particular)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+krugman_index">krugman_index</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a region - industry matrix
set.seed(31)
mat &lt;- matrix(sample(0:100, 20, replace = TRUE), ncol = 4)
rownames(mat) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat) &lt;- c("I1", "I2", "I3", "I4")

## run the function
spec_coeff(mat)
</code></pre>

<hr>
<h2 id='tci'>Compute an index of knowledge complexity of industries using the eigenvector method</h2><span id='topic+tci'></span>

<h3>Description</h3>

<p>This function computes an index of knowledge complexity of industries using the eigenvector method from regions - industries (incidence) matrices. Technically, the function returns the eigenvector associated with the second largest eigenvalue of the projected industry - industry matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tci(mat, rca = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tci_+3A_mat">mat</code></td>
<td>
<p>An incidence matrix with regions in rows and industries in columns</p>
</td></tr>
<tr><td><code id="tci_+3A_rca">rca</code></td>
<td>
<p>Logical; should the index of relative comparative advantage (RCA - also refered to as location quotient) first be computed? Defaults to FALSE (a binary matrix - 0/1 - is expected as an input), but can be set to TRUE if the index of relative comparative advantage first needs to be computed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector representing the index of knowledge complexity of industries. The vector contains the values of the eigenvector associated with the second largest eigenvalue of the projected industry - industry matrix.
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>References</h3>

<p>Hidalgo, C. and Hausmann, R. (2009) The building blocks of economic complexity, <em>Proceedings of the National Academy of Sciences</em> <strong>106</strong>: 10570 - 10575. <br />
<br />
Balland, P.A. and Rigby, D. (2017) The Geography of Complex Knowledge, <em>Economic Geography</em> <strong>93</strong> (1): 1-23.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+location_quotient">location_quotient</a></code>, <code><a href="#topic+ubiquity">ubiquity</a></code>, <code><a href="#topic+diversity">diversity</a></code>, <code><a href="#topic+morc">morc</a></code>, <code><a href="#topic+kci">kci</a></code>, <code><a href="#topic+mort">mort</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a region - industry matrix with full count
set.seed(31)
mat &lt;- matrix(sample(0:10, 20, replace = TRUE), ncol = 4)
rownames(mat) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat) &lt;- c("I1", "I2", "I3", "I4")

## run the function
tci(mat, rca = TRUE)

## generate a region - industry matrix in which cells represent the presence/absence of a rca
set.seed(31)
mat &lt;- matrix(sample(0:1, 20, replace = TRUE), ncol = 4)
rownames(mat) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat) &lt;- c("I1", "I2", "I3", "I4")

## run the function
tci(mat)

## generate the simple network of Hidalgo and Hausmann (2009) presented p.11 (Fig. S4)
countries &lt;- c("C1", "C1", "C1", "C1", "C2", "C3", "C3", "C4")
products &lt;- c("P1", "P2", "P3", "P4", "P2", "P3", "P4", "P4")
my_data &lt;- data.frame(countries, products)
my_data$freq &lt;- 1
mat &lt;- get_matrix(my_data)

## run the function
tci(mat)
</code></pre>

<hr>
<h2 id='ubiquity'>Compute a simple measure of ubiquity of industries</h2><span id='topic+ubiquity'></span>

<h3>Description</h3>

<p>This function computes a simple measure of ubiquity of industries by counting the number of regions in which an industry can be found (location quotient &gt; 1) from regions - industries (incidence) matrices
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ubiquity(mat, rca = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ubiquity_+3A_mat">mat</code></td>
<td>
<p>An incidence matrix with regions in rows and industries in columns</p>
</td></tr>
<tr><td><code id="ubiquity_+3A_rca">rca</code></td>
<td>
<p>Logical; should the index of relative comparative advantage (RCA - also refered to as location quotient) first be computed? Defaults to FALSE (a binary matrix - 0/1 - is expected as an input), but can be set to TRUE if the index of relative comparative advantage first needs to be computed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector representing the measure of ubiquity of industries. Each element of the vector corresponds to the number of regions in which an industry can be found (location quotient &gt; 1).
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>References</h3>

<p>Balland, P.A. and Rigby, D. (2017) The Geography of Complex Knowledge, <em>Economic Geography</em> <strong>93</strong> (1): 1-23.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+diversity">diversity</a></code> <code><a href="#topic+location_quotient">location_quotient</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a region - industry matrix with full count
set.seed(31)
mat &lt;- matrix(sample(0:10, 20, replace = TRUE), ncol = 4)
rownames(mat) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat) &lt;- c("I1", "I2", "I3", "I4")

## run the function
ubiquity(mat, rca = TRUE)

## generate a region - industry matrix in which cells represent the presence/absence of a rca
set.seed(31)
mat &lt;- matrix(sample(0:1, 20, replace = TRUE), ncol = 4)
rownames(mat) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat) &lt;- c("I1", "I2", "I3", "I4")

## run the function
ubiquity(mat)
</code></pre>

<hr>
<h2 id='weighted_avg'>Compute a weighted average of regions or industries from regions - industries matrices</h2><span id='topic+weighted_avg'></span>

<h3>Description</h3>

<p>This function computes a weighted average of regions or industries from (incidence) regions - industries matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>weighted_avg(mat, vec, reg = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weighted_avg_+3A_mat">mat</code></td>
<td>
<p>An incidence matrix with regions in rows and industries in columns</p>
</td></tr>
<tr><td><code id="weighted_avg_+3A_vec">vec</code></td>
<td>
<p>A vector that will be used to compute the weighted average for each industry/region</p>
</td></tr>
<tr><td><code id="weighted_avg_+3A_reg">reg</code></td>
<td>
<p>Logical; Shall the weighted average for regions be returned? Default to TRUE (requires a vector of industry value) but can be set to FALSE (requires a vector of region value) if the weighted average for industries should be returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector representing the weighted average of regions or industries, depending on the value of the 'reg' argument. If 'reg = TRUE', the weighted average for regions is returned; if 'reg = FALSE', the weighted average for industries is returned.
</p>


<h3>Author(s)</h3>

<p>Pierre-Alexandre Balland <a href="mailto:p.balland@uu.nl">p.balland@uu.nl</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+location_quotient">location_quotient</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## generate a region - industry matrix
set.seed(31)
mat &lt;- matrix(sample(0:100, 20, replace = TRUE), ncol = 4)
rownames(mat) &lt;- c("R1", "R2", "R3", "R4", "R5")
colnames(mat) &lt;- c("I1", "I2", "I3", "I4")

## a vector for regions will be used to computed the weighted average of industries
vec &lt;- c(5, 10, 15, 25, 50)
## run the function
weighted_avg(mat, vec, reg = FALSE)

## a vector for industries will be used to computed the weighted average of regions
vec &lt;- c(5, 10, 15, 25)
## run the function
weighted_avg(mat, vec, reg = TRUE)
</code></pre>

<hr>
<h2 id='z_score'>Compute the z-score between technologies from an incidence matrix</h2><span id='topic+z_score'></span>

<h3>Description</h3>

<p>This function computes the z-score between pairs of technologies from a patent-technology incidence matrix. The z-score is a measure to analyze the co-occurrence of technologies in patent documents (i.e. knowledge combination). It compares the observed number of co-occurrences to what would be expected under the hypothesis that combination is random. A positive z-score indicates a typical co-occurrence which has occurred multiple times before. In contrast, a negative z-socre indicates an atypical co-occurrence. The z-score has been used to estimate the degree of novelty of patents (Kim 2016), scientific publications (Uzzi et al. 2013) or the relatedness between industries (Teece et al. 1994).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>z_score(mat)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="z_score_+3A_mat">mat</code></td>
<td>
<p>A patent-technology incidence matrix with patents in rows and technologies in columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of z-scores representing the co-occurrence of technologies in the input incidence matrix. The z-score measures the deviation of the observed co-occurrence from the expected co-occurrence under the assumption of random combination. Positive z-scores indicate typical co-occurrences, while negative z-scores indicate atypical co-occurrences.
</p>


<h3>Author(s)</h3>

<p>Lars Mewes <a href="mailto:mewes@wigeo.uni-hannover.de">mewes@wigeo.uni-hannover.de</a>
</p>


<h3>References</h3>

<p>Kim, D., Cerigo, D. B., Jeong, H., and Youn, H. (2016). Technological novelty proile and invention's future impact. <em>EPJ Data Science</em>, <b>5</b> (1):1&ndash;15 <br />
<br />
Teece, D. J., Rumelt, R., Dosi, G., and Winter, S. (1994). Understanding corporate coherence. Theory and evidence. <em>Journal of Economic Behavior and Organization</em>, <b>23</b> (1):1&ndash;30 <br />
<br />
Uzzi, B., Mukherjee, S., Stringer, M., and Jones, B. (2013). Atypical Combinations and Scientific Impact. <em>Science</em>, <b>342</b> (6157):468&ndash;472
</p>


<h3>See Also</h3>

<p><code><a href="#topic+relatedness_density">relatedness_density</a></code>, <code><a href="#topic+co_occurrence">co_occurrence</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Generate a toy incidence matrix
set.seed(2210)
techs &lt;- paste0("T", seq(1, 5))
techs &lt;- sample(techs, 50, replace = TRUE)
patents &lt;- paste0("P", seq(1, 20))
patents &lt;- sort(sample(patents, 50, replace = TRUE))
my_data &lt;- data.frame(patents, techs)
my_dat &lt;- unique(my_data)
mat &lt;- as.matrix(table(my_data$patents, my_data$techs))

## run the function
z_score(mat)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
