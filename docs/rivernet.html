<!DOCTYPE html><html><head><title>Help for package rivernet</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {rivernet}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adjacentreaches'>
<p>Finds regions of adjacent reaches</p></a></li>
<li><a href='#adjacentreaches.rivernet'>
<p>Finds Regions of Adjacent Reaches</p></a></li>
<li><a href='#analyze'>
<p>Analyzes the Network Structure of a River Network</p></a></li>
<li><a href='#analyze.rivernet'>
<p>Analyzes the Network Structure of a River Network</p></a></li>
<li><a href='#getnodeind'>
<p>Gets indices of nodes that are closest to given locations</p></a></li>
<li><a href='#getnodeind.rivernet'>
<p>Gets indices of nodes that are closest to given locations</p></a></li>
<li><a href='#getreachind'>
<p>Gets indices of reaches that are closest to given locations</p></a></li>
<li><a href='#getreachind.rivernet'>
<p>Gets indices of reaches that are closest to given locations</p></a></li>
<li><a href='#getregionconnections'>
<p>Gets indices of reaches that are closest to given locations</p></a></li>
<li><a href='#mean.rivernet'>
<p>Calculates the length and stream order - weighted average of a given reach property</p></a></li>
<li><a href='#plot.rivernet'>
<p>Plots a River Network Stored in an Object of Class &quot;rivernet&quot;</p></a></li>
<li><a href='#prune'>
<p>Prune a river network at specified reaches</p></a></li>
<li><a href='#prune.rivernet'>
<p>Prune a river network at specified reaches</p></a></li>
<li><a href='#rivernet-package'>
<p>Read, Analyse and Plot River Networks</p></a></li>
<li><a href='#rivernet.read'>
<p>Reads Geographical Information of River Network</p></a></li>
<li><a href='#rivernet.write'>
<p>Write a river network to three data files</p></a></li>
<li><a href='#splitreach'>
<p>Split a reach into two sub-reaches</p></a></li>
<li><a href='#splitreach.rivernet'>
<p>Split a reach into two sub-reaches</p></a></li>
<li><a href='#upstreamconnectivity'>
<p>Calculates connectivity from outlet to upstream reaches</p></a></li>
<li><a href='#upstreamconnectivity.rivernet'>
<p>Calculates connectivity from outlet to upstream reaches</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Read, Analyze and Plot River Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.3</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-08-28</td>
</tr>
<tr>
<td>Author:</td>
<td>Peter Reichert</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions for reading, analysing and plotting river networks.
  For this package, river networks consist of sections and nodes with associated attributes, 
  e.g. to characterise their morphological, chemical and biological state.
  The package provides functions to read this data from text files, to analyse the network
  structure and network paths and regions consisting of sections and nodes that fulfill
  prescribed criteria, and to plot the river network and associated properties.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-28 10:00:43 UTC; peter</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-28 11:00:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='adjacentreaches'>
Finds regions of adjacent reaches
</h2><span id='topic+adjacentreaches'></span>

<h3>Description</h3>

<p>Finds regions of adjacent reaches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adjacentreaches(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjacentreaches_+3A_x">x</code></td>
<td>

<p>Object of class &quot;rivernet&quot; e.g. read by the function <code><a href="#topic+rivernet.read">rivernet.read</a></code>.
</p>
</td></tr>
<tr><td><code id="adjacentreaches_+3A_...">...</code></td>
<td>

<p>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numerical vector of the same length as the number of reaches in the river network with unique numbering corresponding to regions of adjacent reaches (under the condition specified by <code>crit.reach</code> and <code>thresh.length</code>). The segment labelled 0 corresponds to reaches that do not fulfill the criteria. The other regions are labelled with 1, 2, 3, ...
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rivernet.read">rivernet.read</a></code>, <code><a href="#topic+mean.rivernet">mean.rivernet</a></code>, <code><a href="#topic+upstreamconnectivity.rivernet">upstreamconnectivity.rivernet</a></code>,<br /> 
<code><a href="utility.html#topic+utility-package">utility</a></code>.
</p>

<hr>
<h2 id='adjacentreaches.rivernet'>
Finds Regions of Adjacent Reaches
</h2><span id='topic+adjacentreaches.rivernet'></span>

<h3>Description</h3>

<p>Finds regions of adjacent reaches that fulfill given criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rivernet'
adjacentreaches(x,crit.reach,crit.node=TRUE,thresh.length=0,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adjacentreaches.rivernet_+3A_x">x</code></td>
<td>

<p>Object of class &quot;rivernet&quot; e.g. read by the function <code><a href="#topic+rivernet.read">rivernet.read</a></code>.
</p>
</td></tr>
<tr><td><code id="adjacentreaches.rivernet_+3A_crit.reach">crit.reach</code></td>
<td>

<p>Logical vector of the same length as the number of reaches. Indicating whether the criterion for reaches is fulfilled. A single value of <code>TRUE</code> indicates the criterion is fulfilled for all reaches.
</p>
</td></tr>
<tr><td><code id="adjacentreaches.rivernet_+3A_crit.node">crit.node</code></td>
<td>

<p>Logical vector of the same length as the number of nodes. Indicating whether the criterion for nodes is fulfilled. A single value of <code>TRUE</code> indicates the criterion is fulfilled for all nodes.
</p>
</td></tr>
<tr><td><code id="adjacentreaches.rivernet_+3A_thresh.length">thresh.length</code></td>
<td>

<p>Threshold length above which not fulfillment of the criterion separates reaches as not being adjacent.
</p>
</td></tr>
<tr><td><code id="adjacentreaches.rivernet_+3A_...">...</code></td>
<td>

<p>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Numerical vector of the same length as the number of reaches in the river network with unique numbering corresponding to regions of adjacent reaches (under the conditions specified by <code>crit.reach</code>, <code>crit.node</code> and <code>thresh.length</code>). The segment labelled 0 corresponds to reaches which do not fulfill the criteria and are further away than <code>thresh.length</code> from reaches that fulfill the criteria or which are longer than <code>thresh.length</code>. The other regions are labelled with 1, 2, 3, ...
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rivernet.read">rivernet.read</a></code>, <code><a href="#topic+mean.rivernet">mean.rivernet</a></code>, <code><a href="#topic+upstreamconnectivity.rivernet">upstreamconnectivity.rivernet</a></code>,<br /> 
<code><a href="utility.html#topic+utility-package">utility</a></code>.
</p>

<hr>
<h2 id='analyze'>
Analyzes the Network Structure of a River Network
</h2><span id='topic+analyze'></span>

<h3>Description</h3>

<p>Analyzes the network structure of a river network stored as an object of type <code>rivernet</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyze(net,outlet.reach=NA,calc.streamorder=TRUE,verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyze_+3A_net">net</code></td>
<td>

<p>Object of class &quot;rivernet&quot; e.g. read by the function <code><a href="#topic+rivernet.read">rivernet.read</a></code>.
</p>
</td></tr>
<tr><td><code id="analyze_+3A_outlet.reach">outlet.reach</code></td>
<td>

<p>Index or, in case of multiple subnets index vector, of outlet reach or outlet reaches.
If not provided, the function identifies the outlet reach either by assuming coordinates are provided in downstream direction or from elevation information.
</p>
</td></tr>
<tr><td><code id="analyze_+3A_calc.streamorder">calc.streamorder</code></td>
<td>

<p>Logical variable to indicate whether streamorder should be calculated
(after pruning top reaches (see <code><a href="#topic+prune.rivernet">prune.rivernet</a></code>) it may be unwanted to calculate stream order by setting (new) top reaches to order one).
</p>
</td></tr>
<tr><td><code id="analyze_+3A_verbose">verbose</code></td>
<td>

<p>Logical variable to turn on and off summary output about the network structure read.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an object of type <code>rivernet</code> that adds the following columns to the
data frame <code>attrib.reach</code> of the object:
<code>subnet</code>: index of sub-network,<br />
<code>n_start</code>: number of reaches connected at the start end of the reach,<br />
<code>n_end</code>: number of reaches connected at the end end of the reach,<br />
<code>endreach</code>: logical variable indicating if the reach is only connected at one end,<br />
<code>outlet</code>: logical variable indicating if the reach represents the outlet of the network,<br />
<code>headwater</code>: logical variable indicating if the reach is a headwater,<br />
<code>downstream</code>: logical variable indicating if the reach coordinates represent the downstream direction,<br />
<code>reach_down</code>: index of reach downstream of the reach,<br />
<code>streamorder</code>: stream order of the reach.<br /><br />
In addition, the list of reaches (<code>reaches</code>) and the list of nodes (<code>nodes</code>) are appended by indices
<code>from_node</code>, <code>to_node</code> and <code>from_reach</code>, <code>to_reach</code>, respectively.
Finally, a list of all paths from the headwaters to the outlet is provided;<br />
<code>paths</code>: list of vectors of reach indices of the paths from all sources to the outlet.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rivernet.read">rivernet.read</a></code>, <code><a href="#topic+mean.rivernet">mean.rivernet</a></code>, <code><a href="#topic+adjacentreaches.rivernet">adjacentreaches.rivernet</a></code>,<br /> 
<code><a href="utility.html#topic+utility-package">utility</a></code>.
</p>

<hr>
<h2 id='analyze.rivernet'>
Analyzes the Network Structure of a River Network
</h2><span id='topic+analyze.rivernet'></span>

<h3>Description</h3>

<p>Analyzes the network structure of a river network stored as an object of type <code>rivernet</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rivernet'
analyze(net,outlet.reach=NA,calc.streamorder=TRUE,verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyze.rivernet_+3A_net">net</code></td>
<td>

<p>Object of class &quot;rivernet&quot; e.g. read by the function <code><a href="#topic+rivernet.read">rivernet.read</a></code>.
</p>
</td></tr>
<tr><td><code id="analyze.rivernet_+3A_outlet.reach">outlet.reach</code></td>
<td>

<p>Index or, in case of multiple subnets index vector, of outlet reach or outlet reaches.
If not provided, the function identifies the outlet reach either by assuming coordinates are provided in downstream direction or from elevation information.
</p>
</td></tr>
<tr><td><code id="analyze.rivernet_+3A_calc.streamorder">calc.streamorder</code></td>
<td>

<p>Logical variable to indicate whether streamorder should be calculated
(after pruning top reaches (see <code><a href="#topic+prune.rivernet">prune.rivernet</a></code>) it may be unwanted to calculate stream order by setting (new) top reaches to order one).
</p>
</td></tr>
<tr><td><code id="analyze.rivernet_+3A_verbose">verbose</code></td>
<td>

<p>Logical variable to turn on and off summary output about the network structure read.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an object of type <code>rivernet</code> that adds the following columns to the
data frame <code>attrib.reach</code> of the object:
<code>subnet</code>: index of sub-network,<br />
<code>n_start</code>: number of reaches connected at the start end of the reach,<br />
<code>n_end</code>: number of reaches connected at the end end of the reach,<br />
<code>endreach</code>: logical variable indicating if the reach is only connected at one end,<br />
<code>outlet</code>: logical variable indicating if the reach represents the outlet of the network,<br />
<code>headwater</code>: logical variable indicating if the reach is a headwater,<br />
<code>downstream</code>: logical variable indicating if the reach coordinates represent the downstream direction,<br />
<code>reach_down</code>: index of reach downstream of the reach,<br />
<code>streamorder</code>: stream order of the reach.<br /><br />
In addition, the list of reaches (<code>reaches</code>) and the list of nodes (<code>nodes</code>) are appended by indices
<code>from_node</code>, <code>to_node</code> and <code>from_reach</code>, <code>to_reach</code>, respectively.
Finally, a list of all paths from the headwaters to the outlet is provided;<br />
<code>paths</code>: list of vectors of reach indices of the paths from all sources to the outlet.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rivernet.read">rivernet.read</a></code>, <code><a href="#topic+rivernet.write">rivernet.write</a></code>,<br />
<code><a href="#topic+prune.rivernet">prune.rivernet</a></code>,<br />
<code><a href="#topic+mean.rivernet">mean.rivernet</a></code>, <code><a href="#topic+upstreamconnectivity.rivernet">upstreamconnectivity.rivernet</a></code>, <code><a href="#topic+adjacentreaches.rivernet">adjacentreaches.rivernet</a></code>,<br /> 
<code><a href="utility.html#topic+utility-package">utility</a></code>.
</p>

<hr>
<h2 id='getnodeind'>
Gets indices of nodes that are closest to given locations
</h2><span id='topic+getnodeind'></span>

<h3>Description</h3>

<p>Gets indices of nodes that are closest to given locations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getnodeind(net,x,y,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getnodeind_+3A_net">net</code></td>
<td>

<p>Object of class &quot;rivernet&quot; e.g. read by the function <code><a href="#topic+rivernet.read">rivernet.read</a></code>.
</p>
</td></tr>
<tr><td><code id="getnodeind_+3A_x">x</code></td>
<td>

<p>Numerical vector of x coordinates of sites to be analyzed (needs to be of the same length as argument <code>y</code>).
</p>
</td></tr>
<tr><td><code id="getnodeind_+3A_y">y</code></td>
<td>

<p>Numerical vector of y coordinates of sites to be analyzed (needs to be of the same length as argument <code>x</code>).
</p>
</td></tr>
<tr><td><code id="getnodeind_+3A_...">...</code></td>
<td>

<p>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the indices in the first and the distances in the second column.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rivernet.read">rivernet.read</a></code>, <code><a href="#topic+getreachind.rivernet">getreachind.rivernet</a></code>, <code><a href="#topic+upstreamconnectivity.rivernet">upstreamconnectivity.rivernet</a></code>, <code><a href="#topic+adjacentreaches.rivernet">adjacentreaches.rivernet</a></code>,<br />
<code><a href="utility.html#topic+utility-package">utility</a></code>.
</p>

<hr>
<h2 id='getnodeind.rivernet'>
Gets indices of nodes that are closest to given locations
</h2><span id='topic+getnodeind.rivernet'></span>

<h3>Description</h3>

<p>Gets indices of nodes that are closest to given locations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rivernet'
getnodeind(net,x,y,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getnodeind.rivernet_+3A_net">net</code></td>
<td>

<p>Object of class &quot;rivernet&quot; e.g. read by the function <code><a href="#topic+rivernet.read">rivernet.read</a></code>.
</p>
</td></tr>
<tr><td><code id="getnodeind.rivernet_+3A_x">x</code></td>
<td>

<p>Numerical vector of x coordinates of sites to be analyzed (needs to be of the same length as argument <code>y</code>).
</p>
</td></tr>
<tr><td><code id="getnodeind.rivernet_+3A_y">y</code></td>
<td>

<p>Numerical vector of y coordinates of sites to be analyzed (needs to be of the same length as argument <code>x</code>).
</p>
</td></tr>
<tr><td><code id="getnodeind.rivernet_+3A_...">...</code></td>
<td>

<p>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the indices in the first and the distances in the second column.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rivernet.read">rivernet.read</a></code>, <code><a href="#topic+getreachind.rivernet">getreachind.rivernet</a></code>, <code><a href="#topic+upstreamconnectivity.rivernet">upstreamconnectivity.rivernet</a></code>, <code><a href="#topic+adjacentreaches.rivernet">adjacentreaches.rivernet</a></code>,<br />
<code><a href="utility.html#topic+utility-package">utility</a></code>.
</p>

<hr>
<h2 id='getreachind'>
Gets indices of reaches that are closest to given locations
</h2><span id='topic+getreachind'></span>

<h3>Description</h3>

<p>Gets indices of reaches that are closest to given locations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getreachind(net,x,y,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getreachind_+3A_net">net</code></td>
<td>

<p>Object of class &quot;rivernet&quot; e.g. read by the function <code><a href="#topic+rivernet.read">rivernet.read</a></code>.
</p>
</td></tr>
<tr><td><code id="getreachind_+3A_x">x</code></td>
<td>

<p>Numerical vector of x coordinates of sites to be analyzed (needs to be of the same length as argument <code>y</code>).
</p>
</td></tr>
<tr><td><code id="getreachind_+3A_y">y</code></td>
<td>

<p>Numerical vector of y coordinates of sites to be analyzed (needs to be of the same length as argument <code>x</code>).
</p>
</td></tr>
<tr><td><code id="getreachind_+3A_...">...</code></td>
<td>

<p>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the indices in the first and the distances in the second column.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rivernet.read">rivernet.read</a></code>, <code><a href="#topic+getnodeind.rivernet">getnodeind.rivernet</a></code>, <code><a href="#topic+upstreamconnectivity.rivernet">upstreamconnectivity.rivernet</a></code>, <code><a href="#topic+adjacentreaches.rivernet">adjacentreaches.rivernet</a></code>,<br />
<code><a href="utility.html#topic+utility-package">utility</a></code>.
</p>

<hr>
<h2 id='getreachind.rivernet'>
Gets indices of reaches that are closest to given locations
</h2><span id='topic+getreachind.rivernet'></span>

<h3>Description</h3>

<p>Gets indices of reaches that are closest to given locations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rivernet'
getreachind(net,x,y,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getreachind.rivernet_+3A_net">net</code></td>
<td>

<p>Object of class &quot;rivernet&quot; e.g. read by the function <code><a href="#topic+rivernet.read">rivernet.read</a></code>.
</p>
</td></tr>
<tr><td><code id="getreachind.rivernet_+3A_x">x</code></td>
<td>

<p>Numerical vector of x coordinates of sites to be analyzed (needs to be of the same length as argument <code>y</code>).
</p>
</td></tr>
<tr><td><code id="getreachind.rivernet_+3A_y">y</code></td>
<td>

<p>Numerical vector of y coordinates of sites to be analyzed (needs to be of the same length as argument <code>x</code>).
</p>
</td></tr>
<tr><td><code id="getreachind.rivernet_+3A_...">...</code></td>
<td>

<p>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the indices in the first and the distances in the second column.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rivernet.read">rivernet.read</a></code>, <code><a href="#topic+getnodeind.rivernet">getnodeind.rivernet</a></code>, <code><a href="#topic+upstreamconnectivity.rivernet">upstreamconnectivity.rivernet</a></code>, <code><a href="#topic+adjacentreaches.rivernet">adjacentreaches.rivernet</a></code>,<br />
<code><a href="utility.html#topic+utility-package">utility</a></code>.
</p>

<hr>
<h2 id='getregionconnections'>
Gets indices of reaches that are closest to given locations
</h2><span id='topic+getregionconnections'></span>

<h3>Description</h3>

<p>Gets indices of reaches that are closest to given locations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getregionconnections(net,regions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getregionconnections_+3A_net">net</code></td>
<td>

<p>Object of class &quot;rivernet&quot; e.g. read by the function <code><a href="#topic+rivernet.read">rivernet.read</a></code>.
</p>
</td></tr>
<tr><td><code id="getregionconnections_+3A_regions">regions</code></td>
<td>

<p>Numerical vector of the length of the number of regions containing the region coding as calculated e.g. by the function <code><a href="#topic+adjacentreaches.rivernet">adjacentreaches.rivernet</a></code>:
Reaches not belonging to a region should be encoded by the value of zero; reaches belonging to regions should be coded with the index of the region, a natural number from 1 to the number of reaches.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with an entry for each region. The entry for each region is again a list with the folowing entries (some may be empty):<br />
<code>downstream.path</code>: A single vector of indices of reaches describing the path downstream of the given region to the outlet of the river network irrespective of potential other regions to be crossed. Note that the vector will be of length zero if the given region extends to the outlet reach.<br />
<code>upstream.paths</code>: A list of numeric vectors of the paths from all upstream headwaters to the given region irrespective of potential other regions to be crossed. Note that the list will be of length zero if the given region includes all upstream headwaters.<br />
<code>downstream.region</code>: If there on the path downstream to the outlet, this will be an empty list. If there is a downstream region, this is a list with the following elements:
<code>region</code>: index of downstream region;
<code>path</code>: vector of reach indices of the path from the given region to the downstream region;
<code>dist</code>: length of the path to the downstream region.<br />
<code>upstream.regions</code>: Empty list if there is no upstream region to the given region. Otherwise list of upstream regions with list entries as in <code>downstream.region</code> for each upstream regtion.<br />
<code>downupstream.regions</code>: List of regions that can be reached from the given region by first moving downstream and then upstream without crossing another region. If there are no such regions, this is an empty list. Otherwise this is a list of such regions and for each of these regions again a list with the following entries: 
<code>region</code>: index of (down-upstream) region;
<code>downstream.path</code>: vector of reach indices of the downstream path from the given region to the junction from which the region can be reached upstream;
<code>upstream.path</code>: vector of reach indices of the path from thejunction where the downstream path ends to the region;
<code>dist</code>: length of the path between the regions.<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rivernet.read">rivernet.read</a></code>, <code><a href="#topic+adjacentreaches.rivernet">adjacentreaches.rivernet</a></code>,<br />
<code><a href="utility.html#topic+utility-package">utility</a></code>.
</p>

<hr>
<h2 id='mean.rivernet'>
Calculates the length and stream order - weighted average of a given reach property
</h2><span id='topic+mean.rivernet'></span>

<h3>Description</h3>

<p>Calculates the length and stream order - weighted average of a given reach property.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rivernet'
mean(x,y=NA,na.rm=FALSE,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean.rivernet_+3A_x">x</code></td>
<td>

<p>Object of class &quot;rivernet&quot; e.g. read by the function <code><a href="#topic+rivernet.read">rivernet.read</a></code>.
</p>
</td></tr>
<tr><td><code id="mean.rivernet_+3A_y">y</code></td>
<td>

<p>Numerical vector of properties of reaches to be averaged. If no values are provided, the function returns the average length of the reaches.
</p>
</td></tr>
<tr><td><code id="mean.rivernet_+3A_na.rm">na.rm</code></td>
<td>

<p>Indication whether NAs should be removed.
</p>
</td></tr>
<tr><td><code id="mean.rivernet_+3A_...">...</code></td>
<td>

<p>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar representing the weighted mean.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rivernet.read">rivernet.read</a></code>, <code><a href="#topic+upstreamconnectivity.rivernet">upstreamconnectivity.rivernet</a></code>, <code><a href="#topic+adjacentreaches.rivernet">adjacentreaches.rivernet</a></code>,<br />
<code><a href="utility.html#topic+utility-package">utility</a></code>.
</p>

<hr>
<h2 id='plot.rivernet'>
Plots a River Network Stored in an Object of Class &quot;rivernet&quot;
</h2><span id='topic+plot.rivernet'></span>

<h3>Description</h3>

<p>Plots a river network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rivernet'
plot(x,margin=0,
                        main=NA,cex.main=1,pos="topleft",
                        col=NA,lwd=1,
                        pch.nodes=NA,cex.nodes=0.2,col.nodes="black",
                        ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.rivernet_+3A_x">x</code></td>
<td>

<p>Object of class &quot;rivernet&quot; e.g. read by the function <code><a href="#topic+rivernet.read">rivernet.read</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.rivernet_+3A_margin">margin</code></td>
<td>

<p>Relative margin size.
</p>
</td></tr>
<tr><td><code id="plot.rivernet_+3A_main">main</code></td>
<td>

<p>Optional title of the plot.
</p>
</td></tr>
<tr><td><code id="plot.rivernet_+3A_cex.main">cex.main</code></td>
<td>

<p>Font scaling factor of the title.
</p>
</td></tr>
<tr><td><code id="plot.rivernet_+3A_pos">pos</code></td>
<td>

<p>Position of legend. Either &quot;topleft&quot; or &quot;topright&quot;.
</p>
</td></tr>
<tr><td><code id="plot.rivernet_+3A_col">col</code></td>
<td>

<p>Optional single color or vector of colors of the different reaches either in the same order as the reaches in the rivernet object or labeled by the reach identifiers.
</p>
</td></tr>
<tr><td><code id="plot.rivernet_+3A_lwd">lwd</code></td>
<td>

<p>Optional single line width or vector of line widths of the different reaches either in the same order as the reaches in the rivernet object or labeled by the reach identifiers.
</p>
</td></tr>
<tr><td><code id="plot.rivernet_+3A_pch.nodes">pch.nodes</code></td>
<td>

<p>Plot marker for nodes. See <code><a href="graphics.html#topic+points">points</a></code> for an explanation of codes.
</p>
</td></tr>
<tr><td><code id="plot.rivernet_+3A_cex.nodes">cex.nodes</code></td>
<td>

<p>Scaling of markers for nodes.
</p>
</td></tr>
<tr><td><code id="plot.rivernet_+3A_col.nodes">col.nodes</code></td>
<td>

<p>Single color or vector of colors used for node markers. The order must be the same as in the rivernet object.
</p>
</td></tr>
<tr><td><code id="plot.rivernet_+3A_...">...</code></td>
<td>

<p>Further arguments are passed to the plotting function.
</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+rivernet.read">rivernet.read</a></code>,
<code><a href="utility.html#topic+utility-package">utility</a></code>.
</p>

<hr>
<h2 id='prune'>
Prune a river network at specified reaches
</h2><span id='topic+prune'></span>

<h3>Description</h3>

<p>Prune a river network at specified reaches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prune(net,reach.up=numeric(0),reach.dn=numeric(0),verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prune_+3A_net">net</code></td>
<td>

<p>Object of class &quot;rivernet&quot; e.g. read by the function <code><a href="#topic+rivernet.read">rivernet.read</a></code>.
</p>
</td></tr>
<tr><td><code id="prune_+3A_reach.up">reach.up</code></td>
<td>

<p>Numerical vector of reach indices from which to prune all upstream reaches (the indicated reaches to prune from will be kept in the pruned network). Note that you can get reach indices from coordinates with the function <code><a href="#topic+getreachind.rivernet">getreachind.rivernet</a></code>.
</p>
</td></tr>
<tr><td><code id="prune_+3A_reach.dn">reach.dn</code></td>
<td>

<p>Numerical vector of reach indices from which to prune all downstream reaches and branches from downstream reaches (the indicated reaches to prune from will be kept in the pruned network). Note that you can get reach indices from coordinates with the function <code><a href="#topic+getreachind.rivernet">getreachind.rivernet</a></code>.
</p>
</td></tr>
<tr><td><code id="prune_+3A_verbose">verbose</code></td>
<td>

<p>Logical argument to specify whether there should be (minimal) output over what has been done.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns pruned object of class &quot;rivernet&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rivernet.read">rivernet.read</a></code>, <code><a href="#topic+rivernet.write">rivernet.write</a></code>, <br />
<code><a href="#topic+upstreamconnectivity.rivernet">upstreamconnectivity.rivernet</a></code>, <code><a href="#topic+adjacentreaches.rivernet">adjacentreaches.rivernet</a></code>,<br />
<code><a href="utility.html#topic+utility-package">utility</a></code>.
</p>

<hr>
<h2 id='prune.rivernet'>
Prune a river network at specified reaches
</h2><span id='topic+prune.rivernet'></span>

<h3>Description</h3>

<p>Prune a river network at specified reaches.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rivernet'
prune(net,reach.up=numeric(0),reach.dn=numeric(0),verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prune.rivernet_+3A_net">net</code></td>
<td>

<p>Object of class &quot;rivernet&quot; e.g. read by the function <code><a href="#topic+rivernet.read">rivernet.read</a></code>.
</p>
</td></tr>
<tr><td><code id="prune.rivernet_+3A_reach.up">reach.up</code></td>
<td>

<p>Numerical vector of reach indices from which to prune all upstream reaches (the indicated reaches to prune from will be kept in the pruned network). Note that you can get reach indices from coordinates with the function <code><a href="#topic+getreachind.rivernet">getreachind.rivernet</a></code>.
</p>
</td></tr>
<tr><td><code id="prune.rivernet_+3A_reach.dn">reach.dn</code></td>
<td>

<p>Numerical vector of reach indices from which to prune all downstream reaches and branches from downstream reaches (the indicated reaches to prune from will be kept in the pruned network). Note that you can get reach indices from coordinates with the function <code><a href="#topic+getreachind.rivernet">getreachind.rivernet</a></code>.
</p>
</td></tr>
<tr><td><code id="prune.rivernet_+3A_verbose">verbose</code></td>
<td>

<p>Logical argument to specify whether there should be (minimal) output over what has been done.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns pruned object of class &quot;rivernet&quot;.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rivernet.read">rivernet.read</a></code>, <code><a href="#topic+rivernet.write">rivernet.write</a></code>, <br />
<code><a href="#topic+upstreamconnectivity.rivernet">upstreamconnectivity.rivernet</a></code>, <code><a href="#topic+adjacentreaches.rivernet">adjacentreaches.rivernet</a></code>,<br />
<code><a href="utility.html#topic+utility-package">utility</a></code>.
</p>

<hr>
<h2 id='rivernet-package'>
Read, Analyse and Plot River Networks
</h2><span id='topic+rivernet-package'></span><span id='topic+rivernet'></span>

<h3>Description</h3>

<p>Functions for reading, analysing and plotting river networks.<br /><br />
For this package, river networks consist of sections and nodes with associated attributes,
e.g. to characterise their morphological, chemical and biological state.
The package provides functions to read this data from text files, to analyse the network
structure and network paths and regions consisting of sections and nodes that fulfill
prescribed criteria, and to plot the river network and associated properties.<br /><br />
Important functions:<br /><br />
<code><a href="#topic+rivernet.read">rivernet.read</a></code>: Read river network and attribute data from text files.<br />
<code><a href="#topic+rivernet.write">rivernet.write</a></code>: Write river network and attribute data to text files.<br />
<code><a href="#topic+plot.rivernet">plot.rivernet</a></code>: Plot a river network and visualize properties.<br />
<code><a href="#topic+analyze.rivernet">analyze.rivernet</a></code>: Analyse the network structure and calculate network properties.<br />
<code><a href="#topic+prune.rivernet">prune.rivernet</a></code>: Prune a river network at given points.<br />
<code><a href="#topic+getreachind.rivernet">getreachind.rivernet</a></code>: Find the reach that is closest to a given point.<br />
<code><a href="#topic+getnodeind.rivernet">getnodeind.rivernet</a></code>: Find the node that is closest to a given point.<br />
<code><a href="#topic+mean.rivernet">mean.rivernet</a></code>: Calculate the length and stream order weighted mean of a property.<br />
<code><a href="#topic+upstreamconnectivity.rivernet">upstreamconnectivity.rivernet</a></code>: Find flow paths that fulfill given properties, e.g. that can be reached by fish from downstream.<br />
<code><a href="#topic+adjacentreaches.rivernet">adjacentreaches.rivernet</a></code>: Find regions of river sections that fulfill given properties and are (nearly) adjacent to each other.
<code><a href="#topic+getregionconnections">getregionconnections</a></code>: Find connecting paths between regions that may have been identified with the function <code><a href="#topic+adjacentreaches.rivernet">adjacentreaches.rivernet</a></code>.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> rivernet</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.2.3</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2023-08-28</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Peter Reichert
</p>
<p>Maintainer: Peter Reichert &lt;peter.reichert@emeriti.eawag.ch&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>coord &lt;- data.frame(Reach_ID=c(1,1,2,2,2,2,2,3,3,4,4),
                    X=c(5,5,5,7,8,9,10,5,0,0,2),
                    Y=c(0,2,2,4,7,6, 8,2,6,6,7),
                    Z=c(0,1,1,2,3,4, 5,1,2,2,3))
attrib.reach &lt;- data.frame(Reach_ID=c(1,2,3,4),
                           State   =c(0,0.2,0.8,0.8),
                           Flow    =c(4,2,2,2))
attrib.node  &lt;- data.frame(X=c(5,5,0,10,2),
                           Y=c(0,2,6, 8,7),
                           Height=c(0,0,1,0,0))
write.table(coord       ,"rivernet_example_coord.csv",sep=";",col.names=TRUE,row.names=FALSE)
write.table(attrib.reach,"rivernet_example_reach.csv",sep=";",col.names=TRUE,row.names=FALSE)
write.table(attrib.node ,"rivernet_example_node.csv" ,sep=";",col.names=TRUE,row.names=FALSE)
net &lt;- rivernet.read("rivernet_example_coord.csv",
                     "rivernet_example_reach.csv",
                     "rivernet_example_node.csv",
                     sep=";")
plot(net,col=ifelse(net$attrib.reach$State&lt;0.5,"red","blue"),lwd=2,pch=19,cex.nodes=1.5,
     col.nodes=ifelse(is.na(net$attrib.node$Height),
                      "black",
                      ifelse(net$attrib.node$Height&lt;0.1,"blue","red")))
net &lt;- splitreach(net,2,0.4)
plot(net,col=ifelse(net$attrib.reach$State&lt;0.5,"red","blue"),lwd=2,pch=19,cex.nodes=1.5,
     col.nodes=ifelse(is.na(net$attrib.node$Height),
                      "black",
                      ifelse(net$attrib.node$Height&lt;0.1,"blue","red")))
file.remove("rivernet_example_coord.csv")
file.remove("rivernet_example_reach.csv")
file.remove("rivernet_example_node.csv")
</code></pre>

<hr>
<h2 id='rivernet.read'>
Reads Geographical Information of River Network
</h2><span id='topic+rivernet.read'></span>

<h3>Description</h3>

<p>Reads a river network and attributes from text files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rivernet.read(file.reachcoord,
              file.reachattrib = NA,
              file.nodeattrib  = NA,
              colnames         = c(reach = "Reach_ID",
                                   node  = "Node_ID",
                                   x     = "X",
                                   y     = "Y",
                                   z     = "Z"),
              sep              ="\t",
              tol              = 1,
              analyze          = FALSE,
              verbose          = TRUE,
              ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rivernet.read_+3A_file.reachcoord">file.reachcoord</code></td>
<td>

<p>Name of text file or vector of names that contain(s) columns with reach id, x, y, and z coordinates.
An arbitrary number of rows per reach is possible to allow for a reasonable geographical resolution of the river reach, but the rows corresponding to the same reach id are interpreted as a sequential series of points between which the river is constructed by linear interpolation.
If multiple file names are provided, the data frames read from different files
are combined with <code><a href="base.html#topic+rbind">rbind</a></code>.
</p>
</td></tr>
<tr><td><code id="rivernet.read_+3A_file.reachattrib">file.reachattrib</code></td>
<td>

<p>Name of text file or vector of names that contain(s) a column with the same reach reach ids as used in the file <code>file.reachcorrd</code> and an arbitrary number of attributes of the reaches.
If multiple file names are provided, the data frames read from different files are combined by <code><a href="base.html#topic+merge">merge</a></code> so that either additional attributes of existing reaches (same reach identifier) or attributes for additional reaches (new reach identifiers) can be provided.
</p>
</td></tr>
<tr><td><code id="rivernet.read_+3A_file.nodeattrib">file.nodeattrib</code></td>
<td>

<p>Name of text file or vector of names that contain(s) columns with x and y coordinates of the node (must be identical with start or end coordinats of the connecting reaches) and an arbitrary number of attributes of the nodes.
If multiple file names are provided, the data frames read from different files are combined by <code><a href="base.html#topic+merge">merge</a></code> so that either additional attributes of existing nodes (same values for x and y coordinates) or attributes for additional nodes (new x and y coordinates) can be provided.
</p>
</td></tr>
<tr><td><code id="rivernet.read_+3A_colnames">colnames</code></td>
<td>

<p>Labelled vector containing strings to identify the headers of the colums for reach and node identifiers and x, y and z coordinates along the river reaches.
</p>
</td></tr>
<tr><td><code id="rivernet.read_+3A_sep">sep</code></td>
<td>

<p>Column separator used for the files.
</p>
</td></tr>
<tr><td><code id="rivernet.read_+3A_tol">tol</code></td>
<td>

<p>Spatial tolerance for identifying nodes.
</p>
</td></tr>
<tr><td><code id="rivernet.read_+3A_analyze">analyze</code></td>
<td>

<p>Logical variable to indicate whether the function <code><a href="#topic+analyze.rivernet">analyze.rivernet</a></code> should be called after reading.
</p>
</td></tr>
<tr><td><code id="rivernet.read_+3A_verbose">verbose</code></td>
<td>

<p>Logical variable to turn on and off summary output about the network structure read.
</p>
</td></tr>
<tr><td><code id="rivernet.read_+3A_...">...</code></td>
<td>

<p>Optional further arguments are passed to read.table.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an object of type &quot;rivernet&quot; that contains the geographical representation of the river.
This object contains the following elements<br /><br />
<code>reaches</code>: list of river reaches with the following elements: <br />
<code>n</code>: number of coordinates,<br />
<code>x</code>: vector of x-coordinates,<br />
<code>y</code>: vector of y-coordinates,<br />
<code>z</code>: vector of z-coordinates,<br />
<code>length</code>: length of the reach),<br /><br />
<code>nodes</code>: list of river nodes with the following elements: <br />
<code>x</code>: x-coordinate,<br />
<code>y</code>: y-coordinate,<br /><br />
<code>xlim</code>: range of river network in x direction.<br /><br />
<code>ylim</code>: range of river network in y direction.<br /><br />
<code>zlim</code>: vertical range of river network (z direction).<br /><br />
<code>htow</code>: ratio of y to x extension; to be used for the height to widht ratio of network plots.<br /><br />
<code>total.length</code>: sum of length of all river reaches in the network.<br /><br />
<code>attrib.reach</code>: data frame of reaches with columns<br />
<code>Reach_ID</code>: reach identifier,<br />
<code>Reach</code>: reach index,<br />
<code>x_start</code>: start x-coordinate of reach,<br />
<code>y_start</code>: start y-coordinate of reach,<br />
<code>z_start</code>: start elevation of reach,<br />
<code>x_end</code>: end x-coordinate of reach,<br />
<code>y_end</code>: end y-coordinate of reach,<br />
<code>z_end</code>: end elevation of reach,<br />
<code>node_start</code>: index of node at the start of the reach,<br />
<code>node_end</code>: index of node at the end of the reach,<br />
<code>length</code>: length of reach.<br />
If a file <code>file.reachattrib</code> was provided, its columns are added to the colums of this data frame.<br /><br />
<code>attrib.node</code>: data frame of nodes with columns <br />
<code>node</code>: node index,<br />
<code>x</code>: x-coordinate of the node,<br />
<code>y</code>: y-coordinate of the node.<br /><br />
If a file <code>file.nodeattrib</code> was provided, its columns are added to the colums of this data frame.<br /><br />
If the argument <code>analyze</code> is true, the data frame <code>attrib.reach</code> contains the additional columns:
<code>subnet</code>: index of sub-network,<br />
<code>n_start</code>: number of reaches connected at the start end of the reach,<br />
<code>n_end</code>: number of reaches connected at the end end of the reach,<br />
<code>endreach</code>: logical variable indicating if the reach is only connected at one end,<br />
<code>outlet</code>: logical variable indicating if the reach represents the outlet of the network,<br />
<code>headwater</code>: logical variable indicating if the reach is a headwater,<br />
<code>downstream</code>: logical variable indicating if the reach coordinates represent the downstream direction,<br />
<code>reach_down</code>: index of reach downstream of the reach,<br />
<code>streamorder</code>: stream order of the reach.<br />
<code>paths</code>: list of vectors of reach indices of the paths from all headwaters to the outlet.<br />
In addition, the list of reaches (<code>reaches</code>) and the list of nodes (<code>nodes</code>) are appended by indices
<code>from_node</code>, <code>to_node</code> and <code>from_reach</code>, <code>to_reach</code>, respectively.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+analyze.rivernet">analyze.rivernet</a></code><br />
<code><a href="#topic+plot.rivernet">plot.rivernet</a></code><br />
<code><a href="#topic+rivernet.write">rivernet.write</a></code><br />
<code><a href="#topic+prune.rivernet">prune.rivernet</a></code><br />
<code><a href="#topic+getreachind.rivernet">getreachind.rivernet</a></code><br />
<code><a href="#topic+getnodeind.rivernet">getnodeind.rivernet</a></code><br />
<code><a href="#topic+mean.rivernet">mean.rivernet</a></code><br />
<code><a href="#topic+upstreamconnectivity.rivernet">upstreamconnectivity.rivernet</a></code><br />
<code><a href="#topic+adjacentreaches.rivernet">adjacentreaches.rivernet</a></code>.
</p>

<hr>
<h2 id='rivernet.write'>
Write a river network to three data files
</h2><span id='topic+rivernet.write'></span>

<h3>Description</h3>

<p>Writes a river network to three data files: coordinates of river reaches, attributes of reaches, and attributes of nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rivernet.write(x,
               file.reachcoord  = NA,
               file.reachattrib = NA,
               file.nodeattrib  = NA,
               sep              = "\t",
               subnets          = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rivernet.write_+3A_x">x</code></td>
<td>

<p>Object of class &quot;rivernet&quot; e.g. read by the function <code><a href="#topic+rivernet.read">rivernet.read</a></code>.
</p>
</td></tr>
<tr><td><code id="rivernet.write_+3A_file.reachcoord">file.reachcoord</code></td>
<td>

<p>File name for writing reach coordinates.
</p>
</td></tr>
<tr><td><code id="rivernet.write_+3A_file.reachattrib">file.reachattrib</code></td>
<td>

<p>File name for writing reach attributes.
</p>
</td></tr>
<tr><td><code id="rivernet.write_+3A_file.nodeattrib">file.nodeattrib</code></td>
<td>

<p>File name for writing node attributes.
</p>
</td></tr>
<tr><td><code id="rivernet.write_+3A_sep">sep</code></td>
<td>

<p>Separator on data files.
</p>
</td></tr>
<tr><td><code id="rivernet.write_+3A_subnets">subnets</code></td>
<td>

<p>Optional vector of sub-networks to write (with the default NA all sub-networks are written..
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rivernet.read">rivernet.read</a></code>, <br />
<code><a href="#topic+prune.rivernet">prune.rivernet</a></code>, <br />
<code><a href="#topic+upstreamconnectivity.rivernet">upstreamconnectivity.rivernet</a></code>, <code><a href="#topic+adjacentreaches.rivernet">adjacentreaches.rivernet</a></code>,<br />
<code><a href="utility.html#topic+utility-package">utility</a></code>.
</p>

<hr>
<h2 id='splitreach'>
Split a reach into two sub-reaches
</h2><span id='topic+splitreach'></span>

<h3>Description</h3>

<p>Splits a reach at a given part of its length into two subreaches
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splitreach(net,reachind,fract,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitreach_+3A_net">net</code></td>
<td>

<p>Object of class &quot;rivernet&quot; e.g. read by the function <code><a href="#topic+rivernet.read">rivernet.read</a></code>.
</p>
</td></tr>
<tr><td><code id="splitreach_+3A_reachind">reachind</code></td>
<td>

<p>Index of a reach in the rivernet object.
</p>
</td></tr>
<tr><td><code id="splitreach_+3A_fract">fract</code></td>
<td>

<p>Fraction of the length at which the reach should be split. 
Needs to be between 0 and 1.
The fraction is counted from the logical start point of the reach.
</p>
</td></tr>
<tr><td><code id="splitreach_+3A_...">...</code></td>
<td>

<p>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The complete rivernet with the splitted reach.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rivernet.read">rivernet.read</a></code>, <code><a href="#topic+getnodeind.rivernet">getnodeind.rivernet</a></code>, <code><a href="#topic+upstreamconnectivity.rivernet">upstreamconnectivity.rivernet</a></code>, <code><a href="#topic+adjacentreaches.rivernet">adjacentreaches.rivernet</a></code>,<br />
<code><a href="utility.html#topic+utility-package">utility</a></code>.
</p>

<hr>
<h2 id='splitreach.rivernet'>
Split a reach into two sub-reaches
</h2><span id='topic+splitreach.rivernet'></span>

<h3>Description</h3>

<p>Splits a reach at a given part of its length into two subreaches
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rivernet'
splitreach(net,reachind,fract,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="splitreach.rivernet_+3A_net">net</code></td>
<td>

<p>Object of class &quot;rivernet&quot; e.g. read by the function <code><a href="#topic+rivernet.read">rivernet.read</a></code>.
</p>
</td></tr>
<tr><td><code id="splitreach.rivernet_+3A_reachind">reachind</code></td>
<td>

<p>Index of a reach in the rivernet object.
</p>
</td></tr>
<tr><td><code id="splitreach.rivernet_+3A_fract">fract</code></td>
<td>

<p>Fraction of the length at which the reach should be split. 
Needs to be between 0 and 1.
The fraction is counted from the logical start point of the reach.
</p>
</td></tr>
<tr><td><code id="splitreach.rivernet_+3A_...">...</code></td>
<td>

<p>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The complete rivernet with the splitted reach.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rivernet.read">rivernet.read</a></code>, <code><a href="#topic+getnodeind.rivernet">getnodeind.rivernet</a></code>, <code><a href="#topic+upstreamconnectivity.rivernet">upstreamconnectivity.rivernet</a></code>, <code><a href="#topic+adjacentreaches.rivernet">adjacentreaches.rivernet</a></code>,<br />
<code><a href="utility.html#topic+utility-package">utility</a></code>.
</p>

<hr>
<h2 id='upstreamconnectivity'>
Calculates connectivity from outlet to upstream reaches
</h2><span id='topic+upstreamconnectivity'></span>

<h3>Description</h3>

<p>Calculates connectivity from the outlet to upstream reaches, in particular to stream order 1 reaches. Criteria can be provided for reaches as well as nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>upstreamconnectivity(x,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upstreamconnectivity_+3A_x">x</code></td>
<td>

<p>Object of class &quot;rivernet&quot; e.g. read by the function <code><a href="#topic+rivernet.read">rivernet.read</a></code>.
</p>
</td></tr>
<tr><td><code id="upstreamconnectivity_+3A_...">...</code></td>
<td>

<p>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with the following entries:<br />
<code>paths.reachable</code>: List of numeric vectors specifying the indices of the reaches of a reachable path. Note that this is a subset of the reaches given in the same component of the element <code>pahts</code> of the river network.<br />
<code>firstorder.reachable</code>: Vector of logicals indicating if the corresponding paths given above reach first order rivers.
<code>fract.firstorder.reachable</code>: fraction of first order segments that can be reached (under the conditions specified by <code>crit.reach</code>, <code>crit.node</code> and <code>thresh.length</code>).<br />
<code>streamorder.reachable</code>: vector of reachable rivers of order 1, 2, etc.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rivernet.read">rivernet.read</a></code>, <code><a href="#topic+mean.rivernet">mean.rivernet</a></code>, <code><a href="#topic+adjacentreaches.rivernet">adjacentreaches.rivernet</a></code>,<br /> 
<code><a href="utility.html#topic+utility-package">utility</a></code>.
</p>

<hr>
<h2 id='upstreamconnectivity.rivernet'>
Calculates connectivity from outlet to upstream reaches
</h2><span id='topic+upstreamconnectivity.rivernet'></span>

<h3>Description</h3>

<p>Calculates connectivity from the outlet to upstream reaches, in particular to stream order 1 reaches. Criteria can be provided for reaches as well as nodes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rivernet'
upstreamconnectivity(x,crit.reach,crit.node,thresh.length=0,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="upstreamconnectivity.rivernet_+3A_x">x</code></td>
<td>

<p>Object of class &quot;rivernet&quot; e.g. read by the function <code><a href="#topic+rivernet.read">rivernet.read</a></code>.
</p>
</td></tr>
<tr><td><code id="upstreamconnectivity.rivernet_+3A_crit.reach">crit.reach</code></td>
<td>

<p>Logical vector of the same length as the number of reaches. Indicates whether the reach can be counted as connecting between adjacent reaches.
</p>
</td></tr>
<tr><td><code id="upstreamconnectivity.rivernet_+3A_crit.node">crit.node</code></td>
<td>

<p>Logical vector of the same length as the number of (internal) nodes of the river network. Indicates wheter the node can be counted as connecting between adjacent reaches (e.g. small drop height that allows for fish migration).
</p>
</td></tr>
<tr><td><code id="upstreamconnectivity.rivernet_+3A_thresh.length">thresh.length</code></td>
<td>

<p>Threshold lenght below which a reach (or a sequence of reaches) can be accepted as connecting even if their criterion <code>crit.reach</code> is not fulfilled.
</p>
</td></tr>
<tr><td><code id="upstreamconnectivity.rivernet_+3A_...">...</code></td>
<td>

<p>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List with the following entries:<br />
<code>paths.reachable</code>: List of numeric vectors specifying the indices of the reaches of a reachable path. Note that this is a subset of the reaches given in the same component of the element <code>paths</code> of the river network.<br />
<code>firstorder.reachable</code>: Vector of logicals indicating if the corresponding paths given above reach first order rivers.
<code>fract.firstorder.reachable</code>: fraction of first order segments that can be reached (under the conditions specified by <code>crit.reach</code>, <code>crit.node</code> and <code>thresh.length</code>).<br />
<code>streamorder.reachable</code>: vector of reachable rivers of order 1, 2, etc.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+rivernet.read">rivernet.read</a></code>, <code><a href="#topic+mean.rivernet">mean.rivernet</a></code>, <code><a href="#topic+adjacentreaches.rivernet">adjacentreaches.rivernet</a></code>,<br /> 
<code><a href="utility.html#topic+utility-package">utility</a></code>.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
