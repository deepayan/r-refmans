<!DOCTYPE html><html><head><title>Help for package ipmr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ipmr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#+25+5E+25'><p>Raise a matrix to a power</p></a></li>
<li><a href='#as.matrix.ipmr_matrix'><p>Convert to bare matrices</p></a></li>
<li><a href='#collapse_pop_state'><p>Extract threshold based population size information</p></a></li>
<li><a href='#define_impl'><p>Helpers for IPM construction</p></a></li>
<li><a href='#define_kernel'><p>Functions to initialize and define IPM kernels</p></a></li>
<li><a href='#domains'><p>Accessor functions for (proto_)ipm objects</p></a></li>
<li><a href='#format_mega_kernel'><p>Create iteration kernels from an IPM object</p></a></li>
<li><a href='#gen_di_det_ex'><p>A general deterministic IPM example</p></a></li>
<li><a href='#iceplant_ex'><p>Raw demographic data to construct an example IPM</p></a></li>
<li><a href='#init_ipm'><p>Initialize an IPM</p></a></li>
<li><a href='#ipm_to_df'><p>Convert ipmr matrix to long data frame</p></a></li>
<li><a href='#is_conv_to_asymptotic'><p>Check for model convergence to asymptotic dynamics</p></a></li>
<li><a href='#lambda'><p>Compute the per-capita growth rate for an IPM object</p></a></li>
<li><a href='#make_ipm'><p>Methods to implement an IPM</p></a></li>
<li><a href='#make_ipm_report'><p>Generate an RMarkdown file with IPM metadata</p></a></li>
<li><a href='#mean_kernel'><p>Mean kernels for stochastic models</p></a></li>
<li><a href='#monocarp_proto'><p>A <code>proto_ipm</code> for a monocarpic perennial</p></a></li>
<li><a href='#plot.ipmr_matrix'><p>Plot a matrix or an *_ipm object</p></a></li>
<li><a href='#print.proto_ipm'><p>Print proto_ipms or *_ipm objects</p></a></li>
<li><a href='#right_ev'><p>Compute the standardized left and right eigenvectors via iteration</p></a></li>
<li><a href='#right_mult'><p>Right/left multiplication</p></a></li>
<li><a href='#sim_di_det_ex'><p>Simple deterministic IPM example</p></a></li>
<li><a href='#tidyeval'><p>Tidy eval helpers</p></a></li>
<li><a href='#truncated_distributions'><p>Eviction correction</p></a></li>
<li><a href='#use_vr_model'><p>Predict methods in ipmr</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Integral Projection Models</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.7</td>
</tr>
<tr>
<td>Description:</td>
<td>Flexibly implements Integral Projection Models using a
  mathematical(ish) syntax. This package will not help with the vital rate
  modeling process, but will help convert those regression models into an
  IPM. 'ipmr' handles density dependence and environmental stochasticity, with a
  couple of options for implementing the latter. In addition, provides functions
  to avoid unintentional eviction of individuals from models. Additionally, 
  provides model diagnostic tools, plotting functionality, 
  stochastic/deterministic simulations, and analysis tools.
  Integral projection models are described in depth by Easterling et al. (2000) 
  &lt;<a href="https://doi.org/10.1890%2F0012-9658%282000%29081%5B0694%3ASSSAAN%5D2.0.CO%3B2">doi:10.1890/0012-9658(2000)081[0694:SSSAAN]2.0.CO;2</a>&gt;, Merow et al. (2013) 
  &lt;<a href="https://doi.org/10.1111%2F2041-210X.12146">doi:10.1111/2041-210X.12146</a>&gt;, Rees et al. (2014) &lt;<a href="https://doi.org/10.1111%2F1365-2656.12178">doi:10.1111/1365-2656.12178</a>&gt;,
  and Metcalf et al. (2015) &lt;<a href="https://doi.org/10.1111%2F2041-210X.12405">doi:10.1111/2041-210X.12405</a>&gt;. 
  Williams et al. (2012) &lt;<a href="https://doi.org/10.1890%2F11-2147.1">doi:10.1890/11-2147.1</a>&gt; discuss the problem of 
  unintentional eviction.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>covr, knitr, lme4, mvtnorm, rmarkdown, roxygen2, spelling,
testthat, tools</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Imports:</td>
<td>graphics, grDevices, magrittr, methods, purrr (&ge; 0.3.0),
rlang (&ge; 0.3.0), stats, utils, Rcpp</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.2</td>
</tr>
<tr>
<td>Config/testthat/parallel:</td>
<td>true</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://padrinoDB.github.io/ipmr/">https://padrinoDB.github.io/ipmr/</a>,
<a href="https://github.com/padrinoDB/ipmr">https://github.com/padrinoDB/ipmr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/padrinoDB/ipmr/issues">https://github.com/padrinoDB/ipmr/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-02-16 14:02:56 UTC; sl13sise</td>
</tr>
<tr>
<td>Author:</td>
<td>Sam Levin <a href="https://orcid.org/0000-0002-3289-9925"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre],
  Aldo Compagnoni [aut],
  Dylan Childs [aut],
  Sanne Evers [aut],
  Roberto Salguero-Gomez [aut],
  Tiffany Knight [aut],
  Eric Scott [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sam Levin &lt;levisc8@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-02-16 15:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See vignette at <a href="https://CRAN.R-project.org/package=magrittr">https://CRAN.R-project.org/package=magrittr</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Value</h3>

<p>The value of the final expression in the pipe chain.
</p>

<hr>
<h2 id='+25+5E+25'>Raise a matrix to a power</h2><span id='topic++25+5E+25'></span><span id='topic+mat_power'></span>

<h3>Description</h3>

<p>Raises a matrix <code>x</code> to the <code>y</code>-th power. <code>x ^ y</code> computes
element wise powers, whereas this computes <em>y - 1</em> matrix multiplications.
<code>mat_power(x, y)</code> is identical to <code>x %^% y</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>x %^% y

mat_power(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="+2B25+2B5E+2B25_+3A_x">x</code></td>
<td>
<p>A numeric or integer matrix.</p>
</td></tr>
<tr><td><code id="+2B25+2B5E+2B25_+3A_y">y</code></td>
<td>
<p>An integer.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix.
</p>

<hr>
<h2 id='as.matrix.ipmr_matrix'>Convert to bare matrices</h2><span id='topic+as.matrix.ipmr_matrix'></span><span id='topic+as.matrix.ipmr_ipm'></span>

<h3>Description</h3>

<p>Converts objects to <code>c("matrix", "array")</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ipmr_matrix'
as.matrix(x, ...)

## S3 method for class 'ipmr_ipm'
as.matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.matrix.ipmr_matrix_+3A_x">x</code></td>
<td>
<p>An object of class <code>ipmr_matrix</code>, or the output from
<code>make_ipm</code>.</p>
</td></tr>
<tr><td><code id="as.matrix.ipmr_matrix_+3A_...">...</code></td>
<td>
<p>ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix.
</p>

<hr>
<h2 id='collapse_pop_state'>Extract threshold based population size information</h2><span id='topic+collapse_pop_state'></span>

<h3>Description</h3>

<p>Given a model object, this function computes population sizes
given thresholds for a state variable of interest. For example,
the number (or proportion) of individuals shorter than 60 cm tall at the 20th
time step of the model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>collapse_pop_state(ipm, time_step, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="collapse_pop_state_+3A_ipm">ipm</code></td>
<td>
<p>An object created by <code>make_ipm</code></p>
</td></tr>
<tr><td><code id="collapse_pop_state_+3A_time_step">time_step</code></td>
<td>
<p>the time step to pull out. Can be a single time step or a
vector of multiple time steps. In the latter case, one value is computed for
each time step.</p>
</td></tr>
<tr><td><code id="collapse_pop_state_+3A_...">...</code></td>
<td>
<p>Named expressions that provide the threshold information for the
desired classes. The expression should be logicals with a state variable name
on the left side, and a threshold value on the right side.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of numeric vectors containing the summed population
sizes at each requested time step. Names are taken from <code>...</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gen_di_det_ex)

# Rebuild the model and return_main_env this time

gen_di_det_ex &lt;- gen_di_det_ex$proto_ipm %&gt;%
  make_ipm(iterate = TRUE, iterations = 50, return_main_env = TRUE)

disc_sizes &lt;- collapse_pop_state(gen_di_det_ex,
                                 time_step = 20:25,
                                 seedlings = ht &lt;= 10,
                                 NRA = ht &gt; 10 &amp; ht &lt;= 200,
                                 RA = ht &gt; 200)

</code></pre>

<hr>
<h2 id='define_impl'>Helpers for IPM construction</h2><span id='topic+define_impl'></span><span id='topic+make_impl_args_list'></span><span id='topic+define_domains'></span><span id='topic+define_pop_state'></span><span id='topic+define_env_state'></span><span id='topic+discretize_pop_vector'></span>

<h3>Description</h3>

<p>Helpers for IPM construction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_impl(proto_ipm, kernel_impl_list)

make_impl_args_list(kernel_names, int_rule, state_start, state_end)

define_domains(proto_ipm, ...)

define_pop_state(proto_ipm, ..., pop_vectors = list())

define_env_state(proto_ipm, ..., data_list = list())

discretize_pop_vector(
  trait_values,
  n_mesh,
  pad_low = NULL,
  pad_high = NULL,
  normalize = TRUE,
  na.rm = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_impl_+3A_proto_ipm">proto_ipm</code></td>
<td>
<p>The name of the model.</p>
</td></tr>
<tr><td><code id="define_impl_+3A_kernel_impl_list">kernel_impl_list</code></td>
<td>
<p>A named list. Names correspond to kernel names. Each
kernel should have 3 slots defined - the <code>int_rule</code> (integration rule),
the <code>state_start</code> (the domain the kernel begins on), and the <code>state_end</code>
(the domain the kernel ends on). For more complicated models, it is usually
safest to use <code>make_impl_args_list</code> to generate this.</p>
</td></tr>
<tr><td><code id="define_impl_+3A_kernel_names">kernel_names</code></td>
<td>
<p>A character vector with the names of the kernels
that parameters are being defined for.</p>
</td></tr>
<tr><td><code id="define_impl_+3A_int_rule">int_rule</code></td>
<td>
<p>The integration rule to be used for the kernel. The default is
&quot;midpoint&quot;. &quot;b2b&quot; (bin to bin) and &quot;cdf&quot; (cumulative density functions) will
be implemented as well.</p>
</td></tr>
<tr><td><code id="define_impl_+3A_state_start">state_start</code></td>
<td>
<p>The name of the state variable for the kernel that the
kernel acts on at time <em>t</em>.</p>
</td></tr>
<tr><td><code id="define_impl_+3A_state_end">state_end</code></td>
<td>
<p>The name of the state variable that the kernel produces
at time <em>t+1</em>.</p>
</td></tr>
<tr><td><code id="define_impl_+3A_...">...</code></td>
<td>
<p>Named expressions. See Details for more information on their usage in
each <code>define_*</code> function.</p>
</td></tr>
<tr><td><code id="define_impl_+3A_pop_vectors">pop_vectors</code></td>
<td>
<p>If the population vectors are already pre-defined (i.e. are
not defined by a function passed to <code>...</code>), then they can
be passed as a named list here.</p>
</td></tr>
<tr><td><code id="define_impl_+3A_data_list">data_list</code></td>
<td>
<p>A list of named values that contain data used in the expressions
in <code>...</code> in <code>define_env_state()</code>.</p>
</td></tr>
<tr><td><code id="define_impl_+3A_trait_values">trait_values</code></td>
<td>
<p>A numeric vector of trait values.</p>
</td></tr>
<tr><td><code id="define_impl_+3A_n_mesh">n_mesh</code></td>
<td>
<p>The number of meshpoints to use when integrating the trait
distribution.</p>
</td></tr>
<tr><td><code id="define_impl_+3A_pad_low">pad_low</code></td>
<td>
<p>The amount to pad the smallest value by, expressed as a
proportion. For example, 0.8 would shrink the smallest value by 20%.</p>
</td></tr>
<tr><td><code id="define_impl_+3A_pad_high">pad_high</code></td>
<td>
<p>The amount to pad the largest value by, expressed as a
proportion. For example, 1.2 would increase the largest value by 20%.</p>
</td></tr>
<tr><td><code id="define_impl_+3A_normalize">normalize</code></td>
<td>
<p>A logical indicating whether to normalize the result to sum
to 1.</p>
</td></tr>
<tr><td><code id="define_impl_+3A_na.rm">na.rm</code></td>
<td>
<p>A logical indicating whether to remove <code>NA</code>s from
<code>trait_distrib</code>. If <code>FALSE</code> and <code>trait_values</code> contains
<code>NA</code>s, returns a <code>NA</code> with a warning</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These are helper functions to define IPMs. They are used after defining the kernels,
but before calling <code>make_ipm()</code> They are meant to be called in the
following order:
</p>

<ol>
<li> <p><code>define_impl()</code>
</p>
</li>
<li> <p><code>define_domains()</code>
</p>
</li>
<li> <p><code>define_pop_state()</code>
</p>
</li>
<li> <p><code>define_env_state()</code>
</p>
</li></ol>

<p>The order requirement is so that information is correctly matched to each kernel.
Below are specific details on the way each works.
</p>
<p><strong><code>define_impl</code></strong>
</p>
<p>This has two arguments - <code>proto_ipm</code> (the model object you wish to work with),
and the <code>kernel_impl_list</code>. The format of the <code>kernel_impl_list</code> is:
names of the list should be kernel names, and each kernel should have 3 entries:
<code>int_rule</code>, <code>state_start</code>, and <code>state_end</code>. See examples.
</p>
<p><strong><code>define_domains</code></strong>
</p>
<p>If the <code>int_rule = "midpoint"</code>, the <code>...</code> entries are vectors of
length 3 where the name corresponds to the
state variable, the first entry is the lower bound of the domain, the second
is the upper bound of the domain, and the third entry is the number of
meshpoints. Other <code>int_rule</code>s are not yet implemented, so for now this is the
only format they can take. See examples.
</p>
<p><strong><code>define_pop_state</code></strong>
</p>
<p>This takes either calls to functions in the <code>...</code>, or a pre-generated
list of vectors in the <code>pop_vectors</code>. The names used
for each entry in <code>...</code> and/or for the <code>pop_vectors</code> should be
<code>n_&lt;state_variable&gt;</code>. See examples.
</p>
<p><strong><code>define_env_state</code></strong>
</p>
<p>Takes expressions that generate values for environmental covariates at each
iteration of the model in <code>...</code>. The <code>data_list</code> should contain any
parameters that the function uses, as well as the function itself. The
functions should return named lists. Names in that list can be referenced in
vital rate expressions and/or kernel formulas.
</p>
<p><strong><code>discretize_pop_vec</code></strong>
</p>
<p>This takes a numeric vector of a trait distribution and computes the relative
frequency of trait values. By default, it integrates the kernel density estimate
of the trait using the midpoint rule with <code>n_mesh</code> mesh points.
This is helpful for creating an initial population state vector that
corresponds to an observed trait distribution.
</p>


<h3>Value</h3>

<p>All <code>define_*</code> functions return a proto_ipm. <code>make_impl_args_list</code>
returns a list, and so must be used within a call to <code>define_impl</code> or
before initiating the model creation procedure.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example with kernels named "P" and "F", and a domain "z"

kernel_impl_list &lt;- list(P = list(int_rule = "midpoint",
                                  state_start = "z",
                                  state_end = "z"),
                         F = list(int_rule = "midpoint",
                                  state_start = "z",
                                  state_end = "z"))

# an equivalent version using make_impl_args_list

kernel_impl_list &lt;- make_impl_args_list(
     kernel_names = c("P", "F"),
     int_rule     = c("midpoint", "midpoint"),
     state_start  = c("z", "z"),
     state_end    = c("z", "z")
)

data(sim_di_det_ex)

proto_ipm &lt;- sim_di_det_ex$proto_ipm

# define_domains

lower_bound &lt;- 1
upper_bound &lt;- 100
n_meshpoints &lt;- 50


define_domains(proto_ipm, c(lower_bound, upper_bound, n_meshpoints))

# define_pop_state with a state variable named "z". Note that "n_" is prefixed
# to denote that it is a population state function!

define_pop_state(proto_ipm, n_z = runif(100))

# alternative, we can make a list before starting to make the IPM

pop_vecs &lt;- list(n_z = runif(100))

define_pop_state(proto_ipm, pop_vectors = pop_vecs)

# define_env_state. Generates a random draw from a known distribution
# of temperatures.

env_sampler &lt;- function(env_pars) {

  temp &lt;- rnorm(1, env_pars$temp_mean, env_pars$temp_sd)

  return(list(temp = temp))

}

env_pars &lt;- list(temp_mean = 12, temp_sd = 2)

define_env_state(
 proto_ipm,
 env_values = env_sampler(env_pars),
 data_list  = list(env_sampler = env_sampler,
                   env_pars    = env_pars)

)

data(iceplant_ex)

z &lt;- c(iceplant_ex$log_size, iceplant_ex$log_size_next)

pop_vecs &lt;- discretize_pop_vector(z,
                                  n_mesh = 100,
                                  pad_low = 1.2,
                                  pad_high = 1.2)

</code></pre>

<hr>
<h2 id='define_kernel'>Functions to initialize and define IPM kernels</h2><span id='topic+define_kernel'></span>

<h3>Description</h3>

<p>Adds a new kernel to the <code>proto_ipm</code> structure.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_kernel(
  proto_ipm,
  name,
  formula,
  family,
  ...,
  data_list = list(),
  states,
  uses_par_sets = FALSE,
  par_set_indices = list(),
  age_indices = list(),
  evict_cor = FALSE,
  evict_fun = NULL,
  integrate = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_kernel_+3A_proto_ipm">proto_ipm</code></td>
<td>
<p>The name of the model.</p>
</td></tr>
<tr><td><code id="define_kernel_+3A_name">name</code></td>
<td>
<p>The name of the new kernel.</p>
</td></tr>
<tr><td><code id="define_kernel_+3A_formula">formula</code></td>
<td>
<p>A bare expression specifying the form of the kernel.</p>
</td></tr>
<tr><td><code id="define_kernel_+3A_family">family</code></td>
<td>
<p>The type of kernel. Options are <code>"CC"</code> for continuous to continuous
transitions, <code>"DC"</code> for discrete to continuous (e.g. emergence from a seedbank),
<code>"CD"</code> for continuous to discrete (e.g. entering a seedbank), and <code>"DD"</code> for
discrete to discrete (e.g. stasis in a seedbank).</p>
</td></tr>
<tr><td><code id="define_kernel_+3A_...">...</code></td>
<td>
<p>A set of named expressions that correspond
to vital rates in <code>formula</code>. Parameter set index syntax is supported.</p>
</td></tr>
<tr><td><code id="define_kernel_+3A_data_list">data_list</code></td>
<td>
<p>A list of named values that correspond to constants in the formula
and vital rate expressions in <code>...</code>.</p>
</td></tr>
<tr><td><code id="define_kernel_+3A_states">states</code></td>
<td>
<p>A list with character vector containing the names of each state
variable used in the kernel.</p>
</td></tr>
<tr><td><code id="define_kernel_+3A_uses_par_sets">uses_par_sets</code></td>
<td>
<p>A logical indicating whether or not the parameters in the kernel and/or its
underlying vital rates are derived from sets. See the
introduction vignette for this feature for more details
(<code>vignettes(ipmr-introduction', package = 'ipmr')}, and
\code{vignettes( index-notation', package = 'ipmr')</code>).</p>
</td></tr>
<tr><td><code id="define_kernel_+3A_par_set_indices">par_set_indices</code></td>
<td>
<p>A named list with vectors corresponding to the values
the index variable can take. The names should match the suffixes used
in the vital rate expressions.</p>
</td></tr>
<tr><td><code id="define_kernel_+3A_age_indices">age_indices</code></td>
<td>
<p>If <code>init_ipm(uses_age = TRUE)</code>, a list with possibly
2 entries: 1. <code>"age"</code>: the range
of possible ages in the model and, optionally, 2. <code>"max_age"</code>: the maximum
age individuals in the model can attain. Otherwise, not used.</p>
</td></tr>
<tr><td><code id="define_kernel_+3A_evict_cor">evict_cor</code></td>
<td>
<p>A logical indicating whether an eviction correction should be applied
to the kernel.</p>
</td></tr>
<tr><td><code id="define_kernel_+3A_evict_fun">evict_fun</code></td>
<td>
<p>If <code>evict_cor = TRUE</code>, then a function that corrects for it.
Currently, only <code>truncated_distributions</code> and <code>discrete_extrema</code> are
possible.</p>
</td></tr>
<tr><td><code id="define_kernel_+3A_integrate">integrate</code></td>
<td>
<p>For <code>simple_*</code> models, this controls whether a <code>"d_z"</code>
is automatically appended to the <code>formula</code> argument. When <code>TRUE</code>,
this automatically generates <code>formula * d_z</code>. There may be some cases where
this behavior is not desirable. Set this to <code>FALSE</code> and specify the correct
form if needed. The default is <code>TRUE</code>. This argument is ignored for
all <code>general_*</code> models.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Different classes of IPMs may have many or only a few kernels. Each
one requires its own call to <code>define_kernel</code>, though there are some exceptions,
namely for kernels derived for models derived from parameter sets (e.g. vital
rate models fit across plots and years).
</p>
<p>A much more complete overview of how to generate kernels is provided in
<code>vignette("ipmr-introduction", "ipmr")</code>.
</p>


<h3>Value</h3>

<p>A <code>proto_ipm</code>.
</p>

<hr>
<h2 id='domains'>Accessor functions for (proto_)ipm objects</h2><span id='topic+domains'></span><span id='topic+domains.proto_ipm'></span><span id='topic+domains.default'></span><span id='topic+vital_rate_exprs'></span><span id='topic+vital_rate_exprs.proto_ipm'></span><span id='topic+vital_rate_exprs.default'></span><span id='topic+vital_rate_funs'></span><span id='topic+vital_rate_funs.ipmr_ipm'></span><span id='topic+vital_rate_exprs+3C-'></span><span id='topic+vital_rate_exprs+3C-.proto_ipm'></span><span id='topic+new_fun_form'></span><span id='topic+kernel_formulae'></span><span id='topic+kernel_formulae.proto_ipm'></span><span id='topic+kernel_formulae.default'></span><span id='topic+kernel_formulae+3C-'></span><span id='topic+kernel_formulae+3C-.proto_ipm'></span><span id='topic+parameters'></span><span id='topic+parameters.proto_ipm'></span><span id='topic+parameters.default'></span><span id='topic+parameters+3C-'></span><span id='topic+parameters+3C-.proto_ipm'></span><span id='topic+int_mesh'></span><span id='topic+int_mesh.ipmr_ipm'></span><span id='topic+pop_state'></span><span id='topic+pop_state.proto_ipm'></span><span id='topic+pop_state.default'></span>

<h3>Description</h3>

<p>Functions that access slots of a <code>*_ipm</code> (including
<code>proto_ipm</code>). <code>default</code> methods correspond to <code>*_ipm</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>domains(object)

## S3 method for class 'proto_ipm'
domains(object)

## Default S3 method:
domains(object)

vital_rate_exprs(object)

## S3 method for class 'proto_ipm'
vital_rate_exprs(object)

## Default S3 method:
vital_rate_exprs(object)

vital_rate_funs(ipm)

## S3 method for class 'ipmr_ipm'
vital_rate_funs(ipm)

vital_rate_exprs(object, kernel, vital_rate) &lt;- value

## S3 replacement method for class 'proto_ipm'
vital_rate_exprs(object, kernel, vital_rate) &lt;- value

new_fun_form(form)

kernel_formulae(object)

## S3 method for class 'proto_ipm'
kernel_formulae(object)

## Default S3 method:
kernel_formulae(object)

kernel_formulae(object, kernel) &lt;- value

## S3 replacement method for class 'proto_ipm'
kernel_formulae(object, kernel) &lt;- value

parameters(object)

## S3 method for class 'proto_ipm'
parameters(object)

## Default S3 method:
parameters(object)

parameters(object, ...) &lt;- value

## S3 replacement method for class 'proto_ipm'
parameters(object, ...) &lt;- value

int_mesh(ipm, full_mesh = TRUE)

## S3 method for class 'ipmr_ipm'
int_mesh(ipm, full_mesh = TRUE)

pop_state(object)

## S3 method for class 'proto_ipm'
pop_state(object)

## Default S3 method:
pop_state(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="domains_+3A_object">object</code></td>
<td>
<p>A <code>proto_ipm</code> or object created by <code>make_ipm()</code>.</p>
</td></tr>
<tr><td><code id="domains_+3A_ipm">ipm</code></td>
<td>
<p>An object created by <code>make_ipm()</code>. This argument only applies to
<code>int_mesh()</code> and <code>vital_rate_funs()</code> (because these quantities don't
exist until <code>make_ipm()</code> is called).</p>
</td></tr>
<tr><td><code id="domains_+3A_kernel">kernel</code></td>
<td>
<p>The name of the kernel to insert the new vital rate expression
into.</p>
</td></tr>
<tr><td><code id="domains_+3A_vital_rate">vital_rate</code></td>
<td>
<p>The name of the vital rate to replace. If the vital rate
doesn't already exist in the <code>object</code>, a new one with this name will be
created.</p>
</td></tr>
<tr><td><code id="domains_+3A_value">value</code></td>
<td>
<p>For <code>parameters&lt;-</code>, a named list of new parameters. The new list does not need
to contain all of the parameters, just the ones to update/append. For
<code>vital_rate_exprs&lt;-</code> and <code>kernel_formulae&lt;-</code>, a new functional form.
The new functional form must be wrapped in a call to <code>new_fun_form</code>.</p>
</td></tr>
<tr><td><code id="domains_+3A_form">form</code></td>
<td>
<p>An expression representing the new vital rate or kernel formula
to insert.</p>
</td></tr>
<tr><td><code id="domains_+3A_...">...</code></td>
<td>
<p>Additional arguments used in <code>RPadrino</code> methods.</p>
</td></tr>
<tr><td><code id="domains_+3A_full_mesh">full_mesh</code></td>
<td>
<p>Return the full integration mesh? Default is <code>TRUE</code>.
<code>FALSE</code> returns only unique values for each state variable.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>*.default</code> method corresponds to output from <code>make_ipm()</code>,
and the <code>*.proto_ipm</code> methods correspond to outputs from <code>define_*</code>.
</p>
<p>When using <code>kernel_formulae&lt;-</code> and <code>vital_rates_exprs&lt;-</code>, the right
hand side of the expression must be wrapped in <code>new_fun_form</code>. See
examples.
</p>
<p>Note that when using <code>vital_rate_funs</code>, unless the vital rate expression
explicitly contains an expression for integration, these functions
<strong>are not yet integrated!</strong> This is useful for things like sensitivity
and elasticity analysis, but care must be taken to not use these values
incorrectly.
</p>


<h3>Value</h3>

<p>Depending on the class of <code>object</code>, a list
with types numeric or character.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(gen_di_det_ex)

proto &lt;- gen_di_det_ex$proto_ipm

# Create a new, iterated IPM
new_ipm &lt;- make_ipm(proto, iterate = TRUE,
                    iterations = 100, return_all_envs = TRUE)

vital_rate_exprs(new_ipm)
kernel_formulae(new_ipm)
vital_rate_funs(new_ipm)

domains(new_ipm)
parameters(new_ipm)

# Usage is the same for proto_ipm's as *_ipm's

vital_rate_exprs(proto)
kernel_formulae(proto)

domains(proto)
parameters(proto)

int_mesh(new_ipm)

# Setting new parameters, vital rate expressions, and kernel formulae
# only works on proto_ipm's.

# This replaces the "g_int" parameter and leaves the rest untouched

parameters(proto) &lt;- list(g_int = 1.5)

# This creates a new g_z parameter and leaves the rest of parameters untouched
parameters(proto) &lt;- list(g_z = 2.2)

# setting a new vital rate or kernel expression requires wrapping the
# right-hand side in a call to new_fun_form(). new_fun_form uses expressions
# with the same format as ... in define_kernel()

vital_rate_exprs(proto,
                 kernel = "P",
                 vital_rate = "g_mu") &lt;- new_fun_form(g_int + g_z + g_slope * ht_1)

kernel_formulae(proto, kernel = "stay_discrete") &lt;- new_fun_form(g_z * d_ht)

</code></pre>

<hr>
<h2 id='format_mega_kernel'>Create iteration kernels from an IPM object</h2><span id='topic+format_mega_kernel'></span><span id='topic+format_mega_kernel.default'></span><span id='topic+format_mega_kernel.age_x_size_ipm'></span><span id='topic+make_iter_kernel'></span>

<h3>Description</h3>

<p>Creates iteration kernels for IPMs. <code>ipmr</code> does not create
these to iterate models, but they may be useful for further analyses.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>format_mega_kernel(ipm, ...)

## Default S3 method:
format_mega_kernel(ipm, mega_mat, ...)

## S3 method for class 'age_x_size_ipm'
format_mega_kernel(ipm, name_ps, f_forms, ...)

make_iter_kernel(ipm, ..., name_ps, f_forms)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="format_mega_kernel_+3A_ipm">ipm</code></td>
<td>
<p>Output from <code>make_ipm</code>.</p>
</td></tr>
<tr><td><code id="format_mega_kernel_+3A_...">...</code></td>
<td>
<p>Other arguments passed to methods.</p>
</td></tr>
<tr><td><code id="format_mega_kernel_+3A_mega_mat">mega_mat</code></td>
<td>
<p>A vector with symbols, I's, and/or 0s representing the matrix blocks.
They should be specified in ROW MAJOR order! Can also be a character
string specifying the call. Parameter set index syntax is supported. When used,
<code>format_mega_kernel</code> will produce as many mega-matrices as there are
combinations of <code>par_set_indices</code> in the <code>proto_ipm</code>.</p>
</td></tr>
<tr><td><code id="format_mega_kernel_+3A_name_ps">name_ps</code></td>
<td>
<p>The prefix(es) for the kernel name that correspond to survival
and growth/maturation of existing individuals. For the model
<code>K = P_age + F_age</code>, this would be <code>"P"</code>. Only applies to
age X size models. The <code>"_age"</code> suffix is appended automatically, so
does not need to be supplied.</p>
</td></tr>
<tr><td><code id="format_mega_kernel_+3A_f_forms">f_forms</code></td>
<td>
<p>The names of the kernels that correspond to production of new
individuals, and possibly, how they are combined. For example, a model that
includes sexual (with an &quot;F&quot; kernel) and asexual reproduction (with a &quot;C&quot; kernel),
this would be <code>"F + C"</code>. If data come from multiple sites or years,
then this information is supplied using the index syntax (i.e.
<code>f_forms = "F_yr + C_yr"</code>). Only applies to age X size models. The
<code>"_age"</code> index is appended automatically, so does not need to be
supplied.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ipmr</code> does not generate complete iteration kernels, and uses
sub-kernels to iterate models. However, some further analyses are just easier
to code with a complete iteration kernel. This handles constructing those for
simple and general models of all forms. <code>format_mega_kernel</code> is used
internally by <code>make_iter_kernel</code> for general IPMs. The difference
between these two functions is that <code>make_iter_kernel</code> always returns
a list of objects with <code>c(ipmr_matrix, array, matrix)</code> classes,
whereas <code>format_mega_kernel</code> always returns a list of objects with
<code>c(array, matrix)</code> classes. The former has <code>plot()</code> methods while
the latter does not.
</p>
<p><code>I</code> and <code>0</code> represent identity matrices and 0 matrices,
respectively. They can be used to fill in blocks that represent either, without
having to create those separately and append them to the model object. The function
will work out the correct dimensions for both internally, and there is no
restriction on the number that may be used in a given call.
</p>
<p>For <code>age_size_ipm</code>s, the correct form of <code>mega_mat</code> is generated
internally by creating sub-diagonal matrices for the <code>name_ps</code> kernels,
and a top row using the <code>f_forms</code>. If parameter set indices are part of the
model, the indices should be attached to the <code>name_ps, f_forms</code> in the
function arguments, and the correct block matrices will be generated internally.
</p>


<h3>Value</h3>

<p>A list containing a large matrix or many large matrices (when used with
suffix syntax). The names in the former case will be <code>"mega_matrix"</code>
and in the latter case, <code>"mega_matrix_&lt;par_sets&gt;"</code> with the levels of the
grouping effects substituted in.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gen_di_det_ex)

big_k &lt;- make_iter_kernel(gen_di_det_ex,
                            mega_mat = c(0, go_discrete,
                                         leave_discrete, P))

char_call &lt;- c(0, "go_discrete", "leave_discrete", "P")

big_k_c &lt;- make_iter_kernel(gen_di_det_ex, mega_mat = char_call)

# Now, with an Identity matrix instead of a 0

big_k &lt;- make_iter_kernel(gen_di_det_ex,
                            mega_mat = c(I, go_discrete,
                                         leave_discrete, P))

# For simple IPMs with no grouping effects, this computes the sum of
# the sub-kernels (i.e. K = P + F)

data(sim_di_det_ex)

simple_k &lt;- make_iter_kernel(sim_di_det_ex)

</code></pre>

<hr>
<h2 id='gen_di_det_ex'>A general deterministic IPM example</h2><span id='topic+gen_di_det_ex'></span>

<h3>Description</h3>

<p>A general deterministic IPM example
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gen_di_det_ex
</code></pre>


<h3>Format</h3>

<p>A general deterministic IPM with the following slots:
</p>

<dl>
<dt>sub_kernels</dt><dd><p>The computed sub-kernels for the model, named <code>P</code>,
<code>go_discrete</code>, <code>stay_discrete</code>, and <code>leave_discrete</code>.</p>
</dd>
<dt>env_list</dt><dd><p>Empty</p>
</dd>
<dt>env_seq</dt><dd><p>Contains <code>NA</code>. Not particularly useful for deterministic IPMs,
but critical for reproducing stochastic ones.</p>
</dd>
<dt>pop_state</dt><dd><p>A list of length 2, with names <code>n_b</code> and
<code>n_ht</code>.</p>
</dd>
<dt>proto_ipm</dt><dd><p>The <code>proto_ipm</code> used to implement the model.</p>
</dd>
</dl>


<hr>
<h2 id='iceplant_ex'>Raw demographic data to construct an example IPM</h2><span id='topic+iceplant_ex'></span>

<h3>Description</h3>

<p>Raw demographic data to construct an example IPM
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iceplant_ex
</code></pre>


<h3>Format</h3>

<p>288 observations of 10 variables
</p>

<dl>
<dt>id</dt><dd><p>Individual identification number</p>
</dd>
<dt>size</dt><dd><p>Surface area in square meters of each individual at time <em>t</em>.</p>
</dd>
<dt>flower_n</dt><dd><p>If the plant is reproductive, the number of flowers it made.</p>
</dd>
<dt>log_size</dt><dd><p>Log transformed <code>size</code>.</p>
</dd>
<dt>repro</dt><dd><p>Either 0 or 1 to indicate whether the plant is reproductive.</p>
</dd>
<dt>size_next</dt><dd><p>Surface area in square meters of each individual at time <em>t + 1</em>.</p>
</dd>
<dt>flower_n_next</dt><dd><p>If the plant is reproductive at <em>t + 1</em>, the number of
flowers it made.</p>
</dd>
<dt>survival</dt><dd><p>Either 0 or 1 to indicate whether a plant at <em>t</em> survives to <em>t + 1</em>.</p>
</dd>
<dt>log_size_next</dt><dd><p>Log transformed <code>size_next</code>.</p>
</dd>
<dt>repro_next</dt><dd><p>Either 0 or 1 to indicate whether a plant is reproductive at <em>t + 1</em>.</p>
</dd>
</dl>


<hr>
<h2 id='init_ipm'>Initialize an IPM</h2><span id='topic+init_ipm'></span>

<h3>Description</h3>

<p>This is always the first step in constructing an IPM with <code>ipmr</code>.
All you need for this is to know what type of IPM you want to construct - the
rest comes later with <code>define_kernel</code>, <code>make_ipm</code>, and associated
helper functions. See Details for complete overview of each option.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init_ipm(sim_gen, di_dd, det_stoch, kern_param = NULL, uses_age = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="init_ipm_+3A_sim_gen">sim_gen</code></td>
<td>
<p>Either <code>"simple"</code> or <code>"general"</code>.</p>
</td></tr>
<tr><td><code id="init_ipm_+3A_di_dd">di_dd</code></td>
<td>
<p>Either <code>"di"</code> or <code>"dd"</code>.</p>
</td></tr>
<tr><td><code id="init_ipm_+3A_det_stoch">det_stoch</code></td>
<td>
<p>Either <code>"det"</code> or <code>"stoch"</code>. If this is <code>"det"</code>,
then <code>kern_param</code> is ignored. If <code>"stoch"</code>, then <code>kern_param</code>
must be specified.</p>
</td></tr>
<tr><td><code id="init_ipm_+3A_kern_param">kern_param</code></td>
<td>
<p>If <code>det_stoch = "stoch"</code>, then this should be either
<code>"kern"</code> or <code>"param"</code>.</p>
</td></tr>
<tr><td><code id="init_ipm_+3A_uses_age">uses_age</code></td>
<td>
<p>A logical indicating whether the model has age structure. Default
is <code>FALSE</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Combinations of <code>simple</code> or <code>general</code>, <code>dd</code> or <code>di</code>,
and <code>det</code> or <code>stoch</code> are generated to create 1 of 12 unique IPM classes.
</p>
<p>Within <code>stoch</code> model types, there are two additional options:
<code>"kern"</code> or <code>"param"</code>. These distinguish between models that
use kernel resampling vs those that use parameter resampling (<em>sensu</em> Metcalf et al.
2015). Below are quick definitions. More detailed explanations can be found
in the <code>vignettes("ipmr-introduction", package = 'ipmr')</code>.
</p>

<ul>
<li><p><code>sim_gen</code>
</p>

<ul>
<li><p><code>simple</code>: an IPM with a single continuous state variable that does not include
any discrete stages. Simple IPMs can still be stochastic and/or density dependent.
</p>
</li>
<li><p><code>general</code>: an IPM with more than one continuous state variable
and/or a model that includes discrete stages.
</p>
</li></ul>

</li>
<li><p><code>di_dd</code>
</p>

<ul>
<li><p><code>dd</code>: used to denote a density dependent IPM.
</p>
</li>
<li><p><code>di</code>: used to denote a density independent IPM.
</p>
</li></ul>

</li>
<li><p><code>det_stoch</code>
</p>

<ul>
<li><p><code>det</code>: used to denote a deterministic IPM.
</p>
</li>
<li><p><code>stoch</code>: used to denote a stochastic IPM. Stochasticity can
be implemented in two ways in <code>ipmr</code>: <code>"kern"</code> resampling,
and <code>"param"</code> resampling.
</p>
</li></ul>

</li>
<li><p><code>kern_param</code> - if using <code>det</code>, this should be omitted. If
using <code>stoch</code>, then one of the following: 
</p>

<ul>
<li><p><code>kern</code>: used to denote an IPM that uses kernel resampling. Briefly,
these models build all of the iteration kernels ahead of time and then choose one
at random or in a user-specified order as they move from iteration to iteration. The
user-specified population vector is multiplied by the chosen kernel and the result
is multiplied by the next kernel for the desired number of iterations.
</p>
</li>
<li><p><code>param</code>: used to denote parameter resampling. This samples distributions
for each parameter based on user-specified functions supplied to <code>define_env_state()</code>.
This will be a bit slower than <code>"kern"</code> resampling because kernels
need to be reconstructed from new parameters at every time step.
</p>
</li></ul>

</li></ul>



<h3>Value</h3>

<p>An object with classes <code>"proto_ipm"</code> and a combination of
<code>sim_gen</code>, <code>di_dd</code>, <code>det_stoch</code>, and possibly
<code>kern_param</code>. If
<code>uses_age = TRUE</code>, then an <code>"age_x_size"</code> class is also added.
</p>


<h3>References</h3>

<p>Metcalf et al. (2015). Statistical modelling of annual variation
for inference on stochastic population dynamics using Integral Projection
Models. Methods in Ecology and Evolution, 6: 1007-1017
</p>

<hr>
<h2 id='ipm_to_df'>Convert ipmr matrix to long data frame</h2><span id='topic+ipm_to_df'></span><span id='topic+ipm_to_df.array'></span><span id='topic+ipm_to_df.default'></span>

<h3>Description</h3>

<p>Converts IPM kernels into long data frames. These are useful for
creating plots using <code>ggplot2</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ipm_to_df(ipm, ...)

## S3 method for class 'array'
ipm_to_df(ipm, ...)

## Default S3 method:
ipm_to_df(ipm, ..., mega_mat, name_ps = NULL, f_forms = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ipm_to_df_+3A_ipm">ipm</code></td>
<td>
<p>Output from <code>make_ipm</code>.</p>
</td></tr>
<tr><td><code id="ipm_to_df_+3A_...">...</code></td>
<td>
<p>Other arguments passed to methods.</p>
</td></tr>
<tr><td><code id="ipm_to_df_+3A_mega_mat">mega_mat</code></td>
<td>
<p>A vector with symbols, I's, and/or 0s representing the matrix blocks.
They should be specified in ROW MAJOR order! Can also be a character
string specifying the call. Parameter set index syntax is supported. When used,
<code>format_mega_kernel</code> will produce as many mega-matrices as there are
combinations of <code>par_set_indices</code> in the <code>proto_ipm</code>.</p>
</td></tr>
<tr><td><code id="ipm_to_df_+3A_name_ps">name_ps</code></td>
<td>
<p>The prefix(es) for the kernel name that correspond to survival
and growth/maturation of existing individuals. For the model
<code>K = P_age + F_age</code>, this would be <code>"P"</code>. Only applies to
age X size models. The <code>"_age"</code> suffix is appended automatically, so
does not need to be supplied.</p>
</td></tr>
<tr><td><code id="ipm_to_df_+3A_f_forms">f_forms</code></td>
<td>
<p>The names of the kernels that correspond to production of new
individuals, and possibly, how they are combined. For example, a model that
includes sexual (with an &quot;F&quot; kernel) and asexual reproduction (with a &quot;C&quot; kernel),
this would be <code>"F + C"</code>. If data come from multiple sites or years,
then this information is supplied using the index syntax (i.e.
<code>f_forms = "F_yr + C_yr"</code>). Only applies to age X size models. The
<code>"_age"</code> index is appended automatically, so does not need to be
supplied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with 3 columns named <code>"t"</code>, <code>"t_1"</code>, and
<code>"value"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(gen_di_det_ex)

big_mat_df &lt;- ipm_to_df(gen_di_det_ex,
                        mega_mat = c(stay_discrete, go_discrete,
                                     leave_discrete, P))

</code></pre>

<hr>
<h2 id='is_conv_to_asymptotic'>Check for model convergence to asymptotic dynamics</h2><span id='topic+is_conv_to_asymptotic'></span><span id='topic+is_conv_to_asymptotic.ipmr_ipm'></span><span id='topic+conv_plot'></span><span id='topic+conv_plot.ipmr_ipm'></span>

<h3>Description</h3>

<p>Checks for convergence to asymptotic dynamics numerically and
visually. <code>is_conv_to_asymptotic</code> checks whether
<code>lambda[iterations - 1]</code> equals <code>lambda[iterations]</code> within the
specified tolerance, <code>tolerance</code>. <code>conv_plot</code> plots the time series of
<code>lambda</code> (or <code>log(lambda)</code>). For stochastic models, a cumulative mean of
log(lambda) is used to check for convergence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_conv_to_asymptotic(ipm, tolerance, burn_in)

## S3 method for class 'ipmr_ipm'
is_conv_to_asymptotic(ipm, tolerance = 1e-06, burn_in = 0.1)

conv_plot(ipm, iterations, log, show_stable, burn_in, ...)

## S3 method for class 'ipmr_ipm'
conv_plot(
  ipm,
  iterations = NULL,
  log = NULL,
  show_stable = TRUE,
  burn_in = 0.1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_conv_to_asymptotic_+3A_ipm">ipm</code></td>
<td>
<p>An object returned by <code>make_ipm()</code>.</p>
</td></tr>
<tr><td><code id="is_conv_to_asymptotic_+3A_tolerance">tolerance</code></td>
<td>
<p>The tolerance for convergence in lambda or, in the case of stochastic models, the cumulative mean of log(lambda).</p>
</td></tr>
<tr><td><code id="is_conv_to_asymptotic_+3A_burn_in">burn_in</code></td>
<td>
<p>The proportion of iterations to discard. Default is 0.1 (i.e.
first 10% of iterations in the simulation). Ignored for deterministic
models.</p>
</td></tr>
<tr><td><code id="is_conv_to_asymptotic_+3A_iterations">iterations</code></td>
<td>
<p>The range of iterations to plot <code>lambda</code> for. The default
is every iteration.</p>
</td></tr>
<tr><td><code id="is_conv_to_asymptotic_+3A_log">log</code></td>
<td>
<p>A logical indicating whether to log transform <code>lambda</code>. This
defaults to TRUE for stochastic models and FALSE for deterministic models.</p>
</td></tr>
<tr><td><code id="is_conv_to_asymptotic_+3A_show_stable">show_stable</code></td>
<td>
<p>A logical indicating whether or not to draw a line indicating
population stability at <code>lambda = 1</code>.</p>
</td></tr>
<tr><td><code id="is_conv_to_asymptotic_+3A_...">...</code></td>
<td>
<p>Further arguments to <code>plot</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plotting can be controlled by passing additional graphing parameters
to <code>...</code>.
</p>


<h3>Value</h3>

<p><code>is_conv_to_asymptotic</code>: Either <code>TRUE</code> or <code>FALSE</code>.
<code>conv_plot</code>: codeipm invisibly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(gen_di_det_ex)

proto &lt;- gen_di_det_ex$proto_ipm %&gt;%
  define_pop_state(n_ht = runif(200),
                   n_b  = 200000)

ipm &lt;- make_ipm(proto)

is_conv_to_asymptotic(ipm, tolerance = 1e-5)
conv_plot(ipm)

</code></pre>

<hr>
<h2 id='lambda'>Compute the per-capita growth rate for an IPM object</h2><span id='topic+lambda'></span><span id='topic+lambda.simple_di_det_ipm'></span><span id='topic+lambda.simple_di_stoch_kern_ipm'></span><span id='topic+lambda.simple_di_stoch_param_ipm'></span><span id='topic+lambda.general_di_det_ipm'></span><span id='topic+lambda.general_di_stoch_kern_ipm'></span><span id='topic+lambda.general_di_stoch_param_ipm'></span><span id='topic+lambda.simple_dd_det_ipm'></span><span id='topic+lambda.simple_dd_stoch_kern_ipm'></span><span id='topic+lambda.simple_dd_stoch_param_ipm'></span><span id='topic+lambda.general_dd_det_ipm'></span><span id='topic+lambda.general_dd_stoch_kern_ipm'></span><span id='topic+lambda.general_dd_stoch_param_ipm'></span>

<h3>Description</h3>

<p>Compute the per-capita growth rate for a given model. Can handle
stochastic and deterministic models, and has the option to discard burn in for
stochastic models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lambda(ipm, ...)

## S3 method for class 'simple_di_det_ipm'
lambda(ipm, type_lambda = "last", log = FALSE, ...)

## S3 method for class 'simple_di_stoch_kern_ipm'
lambda(ipm, type_lambda = "stochastic", burn_in = 0.1, log = NULL, ...)

## S3 method for class 'simple_di_stoch_param_ipm'
lambda(ipm, type_lambda = "stochastic", burn_in = 0.1, log = NULL, ...)

## S3 method for class 'general_di_det_ipm'
lambda(ipm, type_lambda = "last", log = FALSE, ...)

## S3 method for class 'general_di_stoch_kern_ipm'
lambda(ipm, ..., type_lambda = "stochastic", burn_in = 0.1, log = NULL)

## S3 method for class 'general_di_stoch_param_ipm'
lambda(ipm, ..., type_lambda = "stochastic", burn_in = 0.1, log = NULL)

## S3 method for class 'simple_dd_det_ipm'
lambda(ipm, type_lambda = "all", ..., log = FALSE)

## S3 method for class 'simple_dd_stoch_kern_ipm'
lambda(ipm, ..., type_lambda = "stochastic", burn_in = 0.1, log = NULL)

## S3 method for class 'simple_dd_stoch_param_ipm'
lambda(ipm, ..., type_lambda = "stochastic", burn_in = 0.1, log = NULL)

## S3 method for class 'general_dd_det_ipm'
lambda(ipm, type_lambda = "last", ..., log = FALSE)

## S3 method for class 'general_dd_stoch_kern_ipm'
lambda(ipm, ..., type_lambda = "stochastic", burn_in = 0.1, log = NULL)

## S3 method for class 'general_dd_stoch_param_ipm'
lambda(ipm, ..., type_lambda = "stochastic", burn_in = 0.1, log = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lambda_+3A_ipm">ipm</code></td>
<td>
<p>An object returned by <code>make_ipm()</code>.</p>
</td></tr>
<tr><td><code id="lambda_+3A_...">...</code></td>
<td>
<p>other arguments passed to methods.</p>
</td></tr>
<tr><td><code id="lambda_+3A_type_lambda">type_lambda</code></td>
<td>
<p>Either <code>'all'</code>, <code>'last'</code>,
or <code>'stochastic'</code>. <code>'all'</code>
returns a vector of lambda values for each time step of the simulation (equal
in length to the <code>iterations</code> argument of <code>make_ipm()</code>).
<code>'last'</code> returns the lambda value for the final timestep.
<code>'stochastic'</code> returns a single value, which by default is
<code>mean(log(lambda(ipm, type_lambda = "all")))</code>, with the proportion of
<code>burn_in</code> iterations removed from the beginning of the simulation. Set
<code>log</code> to <code>FALSE</code> to get <code>lambda</code> on the linear scale  for
stochastic models (i.e. <code>exp(mean(log(lambdas)))</code>).</p>
</td></tr>
<tr><td><code id="lambda_+3A_log">log</code></td>
<td>
<p>Return lambda on the log scale? This is <code>TRUE</code> by default for
stochastic models, and <code>FALSE</code> for deterministic models.</p>
</td></tr>
<tr><td><code id="lambda_+3A_burn_in">burn_in</code></td>
<td>
<p>The proportion of iterations to discard. Default is 0.1
(i.e. first 10% of iterations in the simulation).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When <code>type_lambda = "all"</code>, an array. Rows correspond to time
steps, and columns correspond to parameter sets (if any). For other types,
a numeric vector.
</p>

<hr>
<h2 id='make_ipm'>Methods to implement an IPM</h2><span id='topic+make_ipm'></span><span id='topic+make_ipm.simple_di_det'></span><span id='topic+make_ipm.simple_di_stoch_kern'></span><span id='topic+make_ipm.simple_di_stoch_param'></span><span id='topic+make_ipm.general_di_det'></span><span id='topic+make_ipm.general_di_stoch_kern'></span><span id='topic+make_ipm.general_di_stoch_param'></span><span id='topic+make_ipm.simple_dd_det'></span><span id='topic+make_ipm.simple_dd_stoch_kern'></span><span id='topic+make_ipm.simple_dd_stoch_param'></span><span id='topic+make_ipm.general_dd_det'></span><span id='topic+make_ipm.general_dd_stoch_kern'></span><span id='topic+make_ipm.general_dd_stoch_param'></span>

<h3>Description</h3>

<p>The <code>make_ipm.*</code> methods convert a <code>proto_ipm</code> into a
set of discretized kernels and population vectors. Methods have different
requirements, so be sure to read the parameter documentation. <code>
vignette('ipmr-introduction', 'ipmr')</code>  a more complete introduction.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_ipm(
  proto_ipm,
  return_main_env = TRUE,
  return_all_envs = FALSE,
  usr_funs = list(),
  ...
)

## S3 method for class 'simple_di_det'
make_ipm(
  proto_ipm,
  return_main_env = TRUE,
  return_all_envs = FALSE,
  usr_funs = list(),
  ...,
  domain_list = NULL,
  iterate = TRUE,
  iterations = 50,
  normalize_pop_size = TRUE,
  iteration_direction = "right"
)

## S3 method for class 'simple_di_stoch_kern'
make_ipm(
  proto_ipm,
  return_main_env = TRUE,
  return_all_envs = FALSE,
  usr_funs = list(),
  ...,
  domain_list = NULL,
  iterate = TRUE,
  iterations = 50,
  kernel_seq = NULL,
  normalize_pop_size = TRUE,
  report_progress = FALSE,
  iteration_direction = "right"
)

## S3 method for class 'simple_di_stoch_param'
make_ipm(
  proto_ipm,
  return_main_env = TRUE,
  return_all_envs = FALSE,
  usr_funs = list(),
  ...,
  domain_list = NULL,
  iterate = TRUE,
  iterations = 50,
  kernel_seq = NULL,
  normalize_pop_size = TRUE,
  report_progress = FALSE,
  iteration_direction = "right",
  return_sub_kernels = FALSE
)

## S3 method for class 'general_di_det'
make_ipm(
  proto_ipm,
  return_main_env = TRUE,
  return_all_envs = FALSE,
  usr_funs = list(),
  ...,
  domain_list = NULL,
  iterate = TRUE,
  iterations = 50,
  normalize_pop_size = TRUE,
  iteration_direction = "right"
)

## S3 method for class 'general_di_stoch_kern'
make_ipm(
  proto_ipm,
  return_main_env = TRUE,
  return_all_envs = FALSE,
  usr_funs = list(),
  ...,
  domain_list = NULL,
  iterate = TRUE,
  iterations = 50,
  kernel_seq = NULL,
  normalize_pop_size = TRUE,
  report_progress = FALSE,
  iteration_direction = "right"
)

## S3 method for class 'general_di_stoch_param'
make_ipm(
  proto_ipm,
  return_main_env = TRUE,
  return_all_envs = FALSE,
  usr_funs = list(),
  ...,
  domain_list = NULL,
  iterate = TRUE,
  iterations = 50,
  kernel_seq = NULL,
  normalize_pop_size = TRUE,
  report_progress = FALSE,
  iteration_direction = "right",
  return_sub_kernels = FALSE
)

## S3 method for class 'simple_dd_det'
make_ipm(
  proto_ipm,
  return_main_env = TRUE,
  return_all_envs = FALSE,
  usr_funs = list(),
  ...,
  domain_list = NULL,
  iterate = TRUE,
  iterations = 50,
  normalize_pop_size = FALSE,
  report_progress = FALSE,
  iteration_direction = "right",
  return_sub_kernels = FALSE
)

## S3 method for class 'simple_dd_stoch_kern'
make_ipm(
  proto_ipm,
  return_main_env = TRUE,
  return_all_envs = FALSE,
  usr_funs = list(),
  ...,
  domain_list = NULL,
  iterate = TRUE,
  iterations = 50,
  kernel_seq = NA_character_,
  normalize_pop_size = FALSE,
  report_progress = FALSE,
  iteration_direction = "right",
  return_sub_kernels = FALSE
)

## S3 method for class 'simple_dd_stoch_param'
make_ipm(
  proto_ipm,
  return_main_env = TRUE,
  return_all_envs = FALSE,
  usr_funs = list(),
  ...,
  domain_list = NULL,
  iterate = TRUE,
  iterations = 50,
  kernel_seq = NA_character_,
  normalize_pop_size = FALSE,
  report_progress = FALSE,
  iteration_direction = "right",
  return_sub_kernels = FALSE
)

## S3 method for class 'general_dd_det'
make_ipm(
  proto_ipm,
  return_main_env = TRUE,
  return_all_envs = FALSE,
  usr_funs = list(),
  ...,
  domain_list = NULL,
  iterate = TRUE,
  iterations = 50,
  normalize_pop_size = FALSE,
  report_progress = FALSE,
  iteration_direction = "right",
  return_sub_kernels = FALSE
)

## S3 method for class 'general_dd_stoch_kern'
make_ipm(
  proto_ipm,
  return_main_env = TRUE,
  return_all_envs = FALSE,
  usr_funs = list(),
  ...,
  domain_list = NULL,
  iterate = TRUE,
  iterations = 50,
  kernel_seq = NA_character_,
  normalize_pop_size = FALSE,
  report_progress = FALSE,
  iteration_direction = "right",
  return_sub_kernels = FALSE
)

## S3 method for class 'general_dd_stoch_param'
make_ipm(
  proto_ipm,
  return_main_env = TRUE,
  return_all_envs = FALSE,
  usr_funs = list(),
  ...,
  domain_list = NULL,
  iterate = TRUE,
  iterations = 50,
  kernel_seq = NA_character_,
  normalize_pop_size = FALSE,
  report_progress = FALSE,
  iteration_direction = "right",
  return_sub_kernels = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_ipm_+3A_proto_ipm">proto_ipm</code></td>
<td>
<p>A proto_ipm. This should be the
output of <code>define_kernel</code>, or the <code>define_*</code> functions.</p>
</td></tr>
<tr><td><code id="make_ipm_+3A_return_main_env">return_main_env</code></td>
<td>
<p>A logical indicating whether to return the main environment
for the model. This environment contains the integration mesh, weights, and
other potentially useful variables for subsequent analyses. Default is
<code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="make_ipm_+3A_return_all_envs">return_all_envs</code></td>
<td>
<p>A logical indicating whether to return the environments that
the kernel expressions are evaluated in. These may be useful for some analyses,
such as regression-level sensitivity/elasticity analyses, but can also rapidly
increase memory consumption for models with many kernels (e.g. ones with
parameter set indices that have many levels, or any <code>*_stoch_param</code> model).
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="make_ipm_+3A_usr_funs">usr_funs</code></td>
<td>
<p>An optional list of user-specified functions that are passed
on to the  model building process. This can help make vital rate expressions
more concise and expressive. Names in this list should exactly match the names
of the function calls in the <code>...</code> or <code>formula</code>.</p>
</td></tr>
<tr><td><code id="make_ipm_+3A_...">...</code></td>
<td>
<p>Other arguments passed to methods.</p>
</td></tr>
<tr><td><code id="make_ipm_+3A_domain_list">domain_list</code></td>
<td>
<p>An optional list of new domain information to implement
the IPM with.</p>
</td></tr>
<tr><td><code id="make_ipm_+3A_iterate">iterate</code></td>
<td>
<p>A logical indicating whether or not iterate the model before exiting
or just return the sub-kernels. Only applies to density-independent, deterministic
models and density-independent, stochastic kernel re-sampled models.</p>
</td></tr>
<tr><td><code id="make_ipm_+3A_iterations">iterations</code></td>
<td>
<p>If <code>iterate</code> is <code>TRUE</code>, then the number of iterations
to run the model for.</p>
</td></tr>
<tr><td><code id="make_ipm_+3A_normalize_pop_size">normalize_pop_size</code></td>
<td>
<p>A logical indicating whether to re-scale the population
vector to sum to 1 before each iteration. Default is <code>TRUE</code> for
<code>*_di_*</code> methods and <code>FALSE</code> for <code>*_dd_*</code> methods.</p>
</td></tr>
<tr><td><code id="make_ipm_+3A_iteration_direction">iteration_direction</code></td>
<td>
<p>Either <code>"right"</code> (default) or <code>"left"</code>.
This controls the direction of projection. Right iteration will generate
the right eigenvector (if it exists), while left iteration generates
the left eigenvector. These correspond to the stable trait distributions, and
reproductive values, respectively. This parameter is mostly used internally
by other functions. Use with care.</p>
</td></tr>
<tr><td><code id="make_ipm_+3A_kernel_seq">kernel_seq</code></td>
<td>
<p>For <code>*_stoch_kern</code> methods, the sequence of kernels
to use during the simulation process. It should have the same number of entries
as the number of <code>iterations</code>.
This should be a vector containing values of the parameter set indices specified
in <code>par_set_indices</code>, or empty. Support for Markov chains will eventually
get implemented. If it is empty, <code>make_ipm</code> will try to generate a
sequence internally using a random selection of the <code>par_set_indices</code>
defined in <code>define_kernel</code>.</p>
</td></tr>
<tr><td><code id="make_ipm_+3A_report_progress">report_progress</code></td>
<td>
<p>A logical indicating whether or not to periodically
report progress for a stochastic simulation. Does not apply to deterministic
methods. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="make_ipm_+3A_return_sub_kernels">return_sub_kernels</code></td>
<td>
<p>Only applies to density dependent and parameter
resampled models. If <code>TRUE</code>, then all sub-kernels will be returned. These
are required for some analyses, but a large number of iterations will
take up lots of RAM. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>make_ipm.*</code> methods will always return a list of length 5
containing the following components:
</p>

<ul>
<li><p><strong>sub_kernels</strong>: a list of arrays specified in <code>define_kernel</code>.
</p>
</li>
<li><p><strong>env_list</strong>: a list containing the evaluation environments of
kernel. This will contain the <code>main_env</code> object
if <code>return_main_env = TRUE</code>. It will also contain
the sub-kernels evaluation environments if
<code>return_all_envs = TRUE</code>. 
</p>
</li>
<li><p><strong>env_seq</strong>: a character vector with length <code>iterations</code> of
kernel indices indicating the order
in which kernels are to be/were resampled OR
a matrix with as many columns as stochastic parameters
and <code>n_iterations</code> rows.
</p>
</li>
<li><p><strong>pop_state</strong>: population vectors
stored as a list of arrays. The first dimension
of each array corresponds to the state variable distribution,
and the second dimension corresponds to time
steps.
</p>
</li>
<li><p><strong>proto_ipm</strong>: the <code>proto_ipm</code> object used to implement
the model.
</p>
</li></ul>

<p>In addition to the list class, each object will have a class comprised of the
arguments from  <code>init_ipm</code> plus <code>'ipm'</code> pasted together with
underscores. This is to facilitate <code>print</code>, <code>plot</code>, and
<code>lambda</code> methods. For example, a <code>init_ipm("general", "di", "det")</code>
model will have the class <code>'general_di_det_ipm'</code> once it has been
implemented using <code>make_ipm</code>.
</p>

<hr>
<h2 id='make_ipm_report'>Generate an RMarkdown file with IPM metadata</h2><span id='topic+make_ipm_report'></span><span id='topic+make_ipm_report.default'></span><span id='topic+make_ipm_report.ipmr_ipm'></span><span id='topic+make_ipm_report_body'></span>

<h3>Description</h3>

<p>Generates a <code>.rmd</code> file containing a mathematical
description of the <code>proto_ipm</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_ipm_report(
  object,
  rmd_dest = getwd(),
  title = "",
  output_format = "html",
  render_output = FALSE,
  block_eqs = TRUE,
  long_eq_length = 65
)

## Default S3 method:
make_ipm_report(
  object,
  rmd_dest = getwd(),
  title = "",
  output_format = "html",
  render_output = FALSE,
  block_eqs = TRUE,
  long_eq_length = 65
)

## S3 method for class 'ipmr_ipm'
make_ipm_report(
  object,
  rmd_dest = getwd(),
  title = "",
  output_format = "html",
  render_output = FALSE,
  block_eqs = TRUE,
  long_eq_length = 65
)

make_ipm_report_body(proto_ipm, block_eqs, rmd_dest, long_eq_length)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_ipm_report_+3A_object">object</code></td>
<td>
<p>A <code>proto_ipm</code> or output from <code>make_ipm()</code>.</p>
</td></tr>
<tr><td><code id="make_ipm_report_+3A_rmd_dest">rmd_dest</code></td>
<td>
<p>The folder to save the Rmd file at. The default is
<code>getwd()</code>. Alternatively, can be a complete file path that specifies
the location and title of the document with the extension <code>".rmd"</code>. in
this case, the current date will be appended to the title.</p>
</td></tr>
<tr><td><code id="make_ipm_report_+3A_title">title</code></td>
<td>
<p>The title to include in the document. This is not necessarily
the same as <code>rmd_dest</code>, as this appears at the top of the generated
report, and is not included in the file path!</p>
</td></tr>
<tr><td><code id="make_ipm_report_+3A_output_format">output_format</code></td>
<td>
<p>The format to include in the YAML header for the created
<code>.rmd</code> document.</p>
</td></tr>
<tr><td><code id="make_ipm_report_+3A_render_output">render_output</code></td>
<td>
<p>A logical indicating whether to call
<code>rmarkdown::render</code> on the generated <code>.rmd</code> file. Often times,
the <code>.rmd</code> file will need further editing before it's useful, so the
default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="make_ipm_report_+3A_block_eqs">block_eqs</code></td>
<td>
<p>A logical. If <code>TRUE</code>, all equations will be inserted
with blocks and numbered using <code>tag{}</code>. If <code>FALSE</code>, equations
will be rendered as inline equations on a single line, and numbered as
1.1, 1.2, 1.3 (iteration expressions), 2.1, 2.2 (vital rate expressions),
etc.</p>
</td></tr>
<tr><td><code id="make_ipm_report_+3A_long_eq_length">long_eq_length</code></td>
<td>
<p>For longer equations, <code>make_ipm_report</code> tries
to wrap these into multiple lines using <code>\\</code>. This parameter controls
the number of characters per line. Default is 65. Ignored when
<code>block_eqs = FALSE</code>.</p>
</td></tr>
<tr><td><code id="make_ipm_report_+3A_proto_ipm">proto_ipm</code></td>
<td>
<p>A <code>proto_ipm</code> object. Only used for
<code>make_ipm_report_body</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>make_ipm_report_body</code> only translates the iteration
expressions and vital rate expressions into Markdown with LaTeX, and does
not produce any headers needed to knit the file. This function is exported
mostly for re-usage in <code><a href="Rpadrino.html#topic+pdb_report">pdb_report</a></code>, and isn't really
intended for use by <code>ipmr</code> users.
</p>


<h3>Value</h3>

<p>For <code>make_ipm_report</code>, the filepath to the <code>.rmd</code> file. The
default name is <code> "ipmr_report_&lt;current_date&gt;.rmd"</code>. For
<code>make_ipm_report_body</code>, a character vector with Markdown and LaTeX
suitable for rendering, but without a header.
</p>


<h3><strong>Translations</strong></h3>

<p>For iteration expressions, vital rate expressions, and parameter names,
<code>make_ipm_report</code> first translates all values in the <code>data_list</code>
to <code>beta_X</code>. For example, <code>s = surv_int + surv_slope * z_1</code> is
translated into <code>beta_0 + beta_1 * z_1</code>, and then is translated into
LaTeX equations. Since everything is call <code>beta_X</code>, a glossary is
provided at the end of each report that matches <code>beta</code>s to their names
in the <code>data_list</code>.
</p>

<hr>
<h2 id='mean_kernel'>Mean kernels for stochastic models</h2><span id='topic+mean_kernel'></span>

<h3>Description</h3>

<p>This function computes mean sub-kernels for stochastic
parameter re-sampled and stochastic kernel re-sampled models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mean_kernel(ipm)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mean_kernel_+3A_ipm">ipm</code></td>
<td>
<p>A stochastic model created by <code>make_ipm()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For <code>*_stoch_kern</code> models, this computes the element-wise
mean for each sub-kernel across all the different levels of
<code>par_set_indices</code>. For models where not all sub-kernels contain
parameter set indices, sub-kernels that do not have varying
parameters are included in the output and are identical to their input.
</p>
<p>For <code>*_stoch_param</code> models, this computes the element-wise mean for each
sub-kernel created by the iteration procedure.
</p>


<h3>Value</h3>

<p>A list of mean sub-kernels for the model.
</p>

<hr>
<h2 id='monocarp_proto'>A <code>proto_ipm</code> for a monocarpic perennial</h2><span id='topic+monocarp_proto'></span>

<h3>Description</h3>

<p>A <code>proto_ipm</code> for a monocarpic perennial
</p>


<h3>Usage</h3>

<pre><code class='language-R'>monocarp_proto
</code></pre>


<h3>Format</h3>

<p>A <code>proto_ipm</code> for a simple IPM of <em>Oenothera glazioviana</em>.
The parameters are from Ellner, Childs, &amp; Rees (2016), Chapter 2, and the data
are from Kachi &amp; Hirose (1985). Parameter values can be accessed with
<code>parameters(monocarp_proto)</code>, vital rate expressions can be accessed with
<code>vital_rate_exprs(monocarp_proto)</code>, etc.
</p>


<h3>References</h3>

<p>Kachi, H., &amp; Hirose, T. (1985). Population dynamics of _Oenothera glazioviana_
in a sand-dune system with special reference to the adaptive significance of
size-dependent reproduction. Journal of Ecology 73: 887-901.
https://doi.org/10.2307/2260155
</p>
<p>Ellner, S.P., Childs, D.Z., Rees, M. (2016) Data-driven modelling of
structured populations: a practical guide to the integral projection model.
Basel, Switzerland: Springer International Publishing AG
</p>

<hr>
<h2 id='plot.ipmr_matrix'>Plot a matrix or an *_ipm object</h2><span id='topic+plot.ipmr_matrix'></span><span id='topic+plot.simple_di_det_ipm'></span><span id='topic+plot.simple_di_stoch_param_ipm'></span><span id='topic+plot.simple_di_stoch_kern_ipm'></span><span id='topic+plot.general_di_det_ipm'></span>

<h3>Description</h3>

<p>Plot a matrix or an *_ipm object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ipmr_matrix'
plot(
  x = NULL,
  y = NULL,
  A,
  col = grDevices::rainbow(100, start = 0.67, end = 0),
  bw = FALSE,
  do_contour = FALSE,
  do_legend = FALSE,
  contour_cex = 1,
  ...
)

## S3 method for class 'simple_di_det_ipm'
plot(
  x = NULL,
  y = NULL,
  ipm = NULL,
  col = rainbow(100, start = 0.67, end = 0),
  bw = FALSE,
  do_contour = FALSE,
  do_legend = FALSE,
  exponent = 1,
  n_row = 1,
  n_col = 1,
  ...
)

## S3 method for class 'simple_di_stoch_param_ipm'
plot(
  x = NULL,
  y = NULL,
  ipm = NULL,
  col = rainbow(100, start = 0.67, end = 0),
  bw = FALSE,
  do_contour = FALSE,
  do_legend = FALSE,
  exponent = 1,
  n_row = 1,
  n_col = 1,
  ...
)

## S3 method for class 'simple_di_stoch_kern_ipm'
plot(
  x = NULL,
  y = NULL,
  ipm = NULL,
  col = rainbow(100, start = 0.67, end = 0),
  bw = FALSE,
  do_contour = FALSE,
  do_legend = FALSE,
  exponent = 1,
  n_row = 1,
  n_col = 1,
  ...
)

## S3 method for class 'general_di_det_ipm'
plot(
  x = NULL,
  y = NULL,
  ipm = NULL,
  mega_mat = NA_character_,
  col = rainbow(100, start = 0.67, end = 0),
  bw = FALSE,
  do_contour = FALSE,
  do_legend = FALSE,
  exponent = 1,
  n_row = 1,
  n_col = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.ipmr_matrix_+3A_x">x</code>, <code id="plot.ipmr_matrix_+3A_y">y</code></td>
<td>
<p>Either the values of the meshpoints or <code>NULL</code>. If <code>NULL</code>,
then a sequence is generated so that meshpoints are given sequential bin numbers.</p>
</td></tr>
<tr><td><code id="plot.ipmr_matrix_+3A_a">A</code>, <code id="plot.ipmr_matrix_+3A_ipm">ipm</code></td>
<td>
<p>A matrix or a result from <code>make_ipm</code>, or <code>NULL</code> if <code>x</code>
is specified as the matrix or IPM object.</p>
</td></tr>
<tr><td><code id="plot.ipmr_matrix_+3A_col">col</code></td>
<td>
<p>A vector of colors to use for plotting</p>
</td></tr>
<tr><td><code id="plot.ipmr_matrix_+3A_bw">bw</code></td>
<td>
<p>A logical indicating whether to use a greyscale palette for plotting</p>
</td></tr>
<tr><td><code id="plot.ipmr_matrix_+3A_do_contour">do_contour</code></td>
<td>
<p>A logical indicating whether or not draw contour lines
on the plot</p>
</td></tr>
<tr><td><code id="plot.ipmr_matrix_+3A_do_legend">do_legend</code></td>
<td>
<p>A logical indicating whether to draw a legend for the plot</p>
</td></tr>
<tr><td><code id="plot.ipmr_matrix_+3A_contour_cex">contour_cex</code></td>
<td>
<p>A numeric specifying how large to make labels for the
contour lines.</p>
</td></tr>
<tr><td><code id="plot.ipmr_matrix_+3A_...">...</code></td>
<td>
<p>further arguments passed to legend</p>
</td></tr>
<tr><td><code id="plot.ipmr_matrix_+3A_exponent">exponent</code></td>
<td>
<p>The exponent to raise each kernel to. Setting this to a low
number can help visualize kernels that are overwhelmed by a few very large
numbers.</p>
</td></tr>
<tr><td><code id="plot.ipmr_matrix_+3A_n_row">n_row</code>, <code id="plot.ipmr_matrix_+3A_n_col">n_col</code></td>
<td>
<p>If plotting multiple (sub-)kernels, how many rows and
columns to arrange them in.</p>
</td></tr>
<tr><td><code id="plot.ipmr_matrix_+3A_mega_mat">mega_mat</code></td>
<td>
<p>A vector with symbols, I's, and/or 0s representing the matrix blocks.
They should be specified in ROW MAJOR order! Can also be a character
string specifying the call. Parameter set index syntax is supported. When used,
<code>format_mega_kernel</code> will produce as many mega-matrices as there are
combinations of <code>par_set_indices</code> in the <code>proto_ipm</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If an IPM kernel is overwhelmed by information in say, a fecundity sub-kernel,
use the <code>exponent</code> argument in <code>plot.*_ipm</code> to make it more visually
appealing.
</p>


<h3>Value</h3>

<p><code>A</code> or <code>ipm</code> invisibly
</p>

<hr>
<h2 id='print.proto_ipm'>Print proto_ipms or *_ipm objects</h2><span id='topic+print.proto_ipm'></span><span id='topic+print.simple_di_det_ipm'></span><span id='topic+print.simple_dd_det_ipm'></span><span id='topic+print.simple_di_stoch_kern_ipm'></span><span id='topic+print.simple_dd_stoch_kern_ipm'></span><span id='topic+print.simple_di_stoch_param_ipm'></span><span id='topic+print.simple_dd_stoch_param_ipm'></span><span id='topic+print.general_di_det_ipm'></span><span id='topic+print.general_dd_det_ipm'></span><span id='topic+print.general_di_stoch_kern_ipm'></span><span id='topic+print.general_dd_stoch_kern_ipm'></span><span id='topic+print.general_di_stoch_param_ipm'></span><span id='topic+print.general_dd_stoch_param_ipm'></span>

<h3>Description</h3>

<p>Print proto_ipms or *_ipm objects
</p>
<p>Generics for IPM classes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'proto_ipm'
print(x, ...)

## S3 method for class 'simple_di_det_ipm'
print(
  x,
  comp_lambda = TRUE,
  type_lambda = "last",
  sig_digits = 3,
  check_conv = TRUE,
  ...
)

## S3 method for class 'simple_dd_det_ipm'
print(x, comp_lambda = TRUE, type_lambda = "last", sig_digits = 3, ...)

## S3 method for class 'simple_di_stoch_kern_ipm'
print(x, comp_lambda = TRUE, type_lambda = "stochastic", sig_digits = 3, ...)

## S3 method for class 'simple_dd_stoch_kern_ipm'
print(x, comp_lambda = TRUE, type_lambda = "stochastic", sig_digits = 3, ...)

## S3 method for class 'simple_di_stoch_param_ipm'
print(x, comp_lambda = TRUE, type_lambda = "stochastic", sig_digits = 3, ...)

## S3 method for class 'simple_dd_stoch_param_ipm'
print(x, comp_lambda = TRUE, type_lambda = "stochastic", sig_digits = 3, ...)

## S3 method for class 'general_di_det_ipm'
print(
  x,
  comp_lambda = TRUE,
  type_lambda = "last",
  sig_digits = 3,
  check_conv = TRUE,
  ...
)

## S3 method for class 'general_dd_det_ipm'
print(x, comp_lambda = TRUE, type_lambda = "last", sig_digits = 3, ...)

## S3 method for class 'general_di_stoch_kern_ipm'
print(x, comp_lambda = TRUE, type_lambda = "stochastic", sig_digits = 3, ...)

## S3 method for class 'general_dd_stoch_kern_ipm'
print(x, comp_lambda = TRUE, type_lambda = "stochastic", sig_digits = 3, ...)

## S3 method for class 'general_di_stoch_param_ipm'
print(x, comp_lambda = TRUE, type_lambda = "stochastic", sig_digits = 3, ...)

## S3 method for class 'general_dd_stoch_param_ipm'
print(x, comp_lambda = TRUE, type_lambda = "stochastic", sig_digits = 3, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.proto_ipm_+3A_x">x</code></td>
<td>
<p>An object of class <code>proto_ipm</code> or produced by <code>make_ipm()</code>.</p>
</td></tr>
<tr><td><code id="print.proto_ipm_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="print.proto_ipm_+3A_comp_lambda">comp_lambda</code></td>
<td>
<p>A logical indicating whether or not to calculate lambdas
for the iteration kernels and display them.</p>
</td></tr>
<tr><td><code id="print.proto_ipm_+3A_type_lambda">type_lambda</code></td>
<td>
<p>Either <code>'all'</code> or <code>'stochastic'</code>. See
<code><a href="#topic+lambda">lambda</a></code> for more details.</p>
</td></tr>
<tr><td><code id="print.proto_ipm_+3A_sig_digits">sig_digits</code></td>
<td>
<p>The number of significant digits to round to if <code>
comp_lambda = TRUE</code>.</p>
</td></tr>
<tr><td><code id="print.proto_ipm_+3A_check_conv">check_conv</code></td>
<td>
<p>A logical: for deterministic models, check if population state
has converged to asymptotic dynamics? If <code>TRUE</code> and the model has not
converged, a message will be printed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For printing <code>proto_ipm</code> objects, indices are wrapped in
<code>&lt;index&gt;</code> to assist with debugging. These are not carried into the model,
just a visual aid.
</p>


<h3>Value</h3>

<p><code>x</code> invisibly.
</p>

<hr>
<h2 id='right_ev'>Compute the standardized left and right eigenvectors via iteration</h2><span id='topic+right_ev'></span><span id='topic+right_ev.simple_di_det_ipm'></span><span id='topic+right_ev.simple_di_stoch_kern_ipm'></span><span id='topic+right_ev.simple_di_stoch_param_ipm'></span><span id='topic+right_ev.general_di_det_ipm'></span><span id='topic+right_ev.general_di_stoch_kern_ipm'></span><span id='topic+right_ev.general_di_stoch_param_ipm'></span><span id='topic+left_ev'></span><span id='topic+left_ev.simple_di_det_ipm'></span><span id='topic+left_ev.simple_di_stoch_kern_ipm'></span><span id='topic+left_ev.general_di_det_ipm'></span><span id='topic+left_ev.general_di_stoch_kern_ipm'></span><span id='topic+left_ev.general_di_stoch_param_ipm'></span><span id='topic+left_ev.simple_di_stoch_param_ipm'></span>

<h3>Description</h3>

<p>Compute the standardized left and right eigenvectors via iteration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>right_ev(ipm, ...)

## S3 method for class 'simple_di_det_ipm'
right_ev(ipm, iterations = 100, tolerance = 1e-10, ...)

## S3 method for class 'simple_di_stoch_kern_ipm'
right_ev(ipm, burn_in = 0.25, ...)

## S3 method for class 'simple_di_stoch_param_ipm'
right_ev(ipm, burn_in = 0.25, ...)

## S3 method for class 'general_di_det_ipm'
right_ev(ipm, iterations = 100, tolerance = 1e-10, ...)

## S3 method for class 'general_di_stoch_kern_ipm'
right_ev(ipm, burn_in = 0.25, ...)

## S3 method for class 'general_di_stoch_param_ipm'
right_ev(ipm, burn_in = 0.25, ...)

left_ev(ipm, ...)

## S3 method for class 'simple_di_det_ipm'
left_ev(ipm, iterations = 100, tolerance = 1e-10, ...)

## S3 method for class 'simple_di_stoch_kern_ipm'
left_ev(ipm, iterations = 10000, burn_in = 0.25, kernel_seq = NULL, ...)

## S3 method for class 'general_di_det_ipm'
left_ev(ipm, iterations = 100, tolerance = 1e-10, ...)

## S3 method for class 'general_di_stoch_kern_ipm'
left_ev(ipm, iterations = 10000, burn_in = 0.25, kernel_seq = NULL, ...)

## S3 method for class 'general_di_stoch_param_ipm'
left_ev(ipm, iterations = 10000, burn_in = 0.25, kernel_seq = NULL, ...)

## S3 method for class 'simple_di_stoch_param_ipm'
left_ev(ipm, iterations = 10000, burn_in = 0.25, kernel_seq = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="right_ev_+3A_ipm">ipm</code></td>
<td>
<p>Output from <code>make_ipm()</code>.</p>
</td></tr>
<tr><td><code id="right_ev_+3A_...">...</code></td>
<td>
<p>Other arguments passed to methods</p>
</td></tr>
<tr><td><code id="right_ev_+3A_iterations">iterations</code></td>
<td>
<p>The number of times to iterate the model to reach
convergence. Default is 100.</p>
</td></tr>
<tr><td><code id="right_ev_+3A_tolerance">tolerance</code></td>
<td>
<p>Tolerance to evaluate convergence to asymptotic dynamics.</p>
</td></tr>
<tr><td><code id="right_ev_+3A_burn_in">burn_in</code></td>
<td>
<p>The proportion of early iterations to discard from the
stochastic simulation</p>
</td></tr>
<tr><td><code id="right_ev_+3A_kernel_seq">kernel_seq</code></td>
<td>
<p>The sequece of parameter set indices used to select kernels
during the iteration procedure. If <code>NULL</code>, will use the sequence stored
in the <code>ipm</code> object. Should usually be left as <code>NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of named numeric vector(s) corresponding to the stable trait distribution
function (<code>right_ev</code>) or the reproductive values for each trait (<code>left_ev</code>).
</p>


<h3><strong>Deterministic eigenvectors</strong></h3>

<p>For <code>right_ev</code>, if the model has already been iterated and has
converged to asymptotic dynamics, then it will just extract the final
population state and return that in a named list. Each element of the list
is a vector with length <code>&gt;= 1</code> and corresponds each state variable's
portion of the eigenvector.
If the model has been iterated, but has not yet converged to asymptotic dynamics,
<code>right_ev</code> will try to iterate it further using the final population state
as the starting point. The default number of iterations is 100, and can be
adjusted using the <code>iterations</code> argument.
If the model hasn't been iterated, then <code>right_ev</code> will try iterating it
for <code>iterations</code> number of time steps and check for convergence. In the
latter two cases, if the model still has not converged to asymptotic dynamics,
it will return <code>NA</code> with a warning.
</p>
<p>For <code>left_ev</code>, the transpose iteration (<em>sensu</em> Ellner &amp; Rees 2006,
Appendix A) is worked out based on the <code>state_start</code> and <code>state_end</code>
in the model's <code>proto_ipm</code> object. The model is then iterated for
<code>iterations</code> times to produce a standardized left eigenvector.
</p>


<h3><strong>Stochastic eigenvectors</strong></h3>

<p><code>left_ev</code> and <code>right_ev</code> return different things for stochastic models.
<code>right_ev</code> returns the trait distribution through time from the stochastic
simulation (i.e. <code>ipm$pop_state</code>), and normalizes it such that the
distribution at each time step integrates to 1 (if it is not already).
It then discards the first <code>burn_in * iterations</code> time steps of the
simulation to eliminate transient dynamics. See Ellner, Childs, &amp; Rees 2016,
Chapter 7.5 for more details.
</p>
<p><code>left_ev</code> returns a similar result as <code>right_ev</code>, except the trait
distributions are the result of left multiplying the kernel and trait
distribution. See Ellner, Childs, &amp; Rees 2016, Chapter 7.5 for more
details.
</p>

<hr>
<h2 id='right_mult'>Right/left multiplication</h2><span id='topic+right_mult'></span><span id='topic+left_mult'></span>

<h3>Description</h3>

<p>Performs right and left multiplication.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>right_mult(kernel, vectr, family = NULL, start_end = NULL)

left_mult(kernel, vectr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="right_mult_+3A_kernel">kernel</code>, <code id="right_mult_+3A_vectr">vectr</code></td>
<td>
<p><code>kernel</code> should be a bivariate kernel, <code>vectr</code>
should be a univariate trait distribution.</p>
</td></tr>
<tr><td><code id="right_mult_+3A_family">family</code>, <code id="right_mult_+3A_start_end">start_end</code></td>
<td>
<p>Used internally, do not touch.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>left_mult</code> returns <code>t(kernel) %*% vectr</code>. <code>right_mult</code>
returns <code>kernel %*% vectr</code>.
</p>

<hr>
<h2 id='sim_di_det_ex'>Simple deterministic IPM example</h2><span id='topic+sim_di_det_ex'></span>

<h3>Description</h3>

<p>Simple deterministic IPM example
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_di_det_ex
</code></pre>


<h3>Format</h3>

<p>A simple deterministic IPM with the following slots:
</p>

<dl>
<dt>sub_kernels</dt><dd><p>The computed sub-kernels, named <code>P</code> and <code>F</code>.</p>
</dd>
<dt>env_list</dt><dd><p>Empty</p>
</dd>
<dt>env_seq</dt><dd><p>Empty.</p>
</dd>
<dt>pop_state</dt><dd><p>Empty.</p>
</dd>
<dt>proto_ipm</dt><dd><p>The <code>proto_ipm</code> object used to implement the model.</p>
</dd>
</dl>


<hr>
<h2 id='tidyeval'>Tidy eval helpers</h2><span id='topic+tidyeval'></span><span id='topic+quo'></span><span id='topic+quos'></span><span id='topic+enquo'></span><span id='topic+enquos'></span><span id='topic+quo_name'></span><span id='topic+sym'></span><span id='topic+ensym'></span><span id='topic+syms'></span><span id='topic+ensyms'></span><span id='topic+expr'></span><span id='topic+exprs'></span><span id='topic+enexpr'></span><span id='topic+enexprs'></span><span id='topic+.data'></span>

<h3>Description</h3>

<p>Re-exported tidy eval helpers
</p>


<h3>Value</h3>

<p>These functions return quosures, symbols, and expressions.
</p>

<hr>
<h2 id='truncated_distributions'>Eviction correction</h2><span id='topic+truncated_distributions'></span><span id='topic+discrete_extrema'></span>

<h3>Description</h3>

<p>Various helpers to correct for unintentional eviction (Williams
et al. 2012).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>truncated_distributions(fun, target, ...)

discrete_extrema(target, state, ncol = NULL, nrow = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="truncated_distributions_+3A_fun">fun</code></td>
<td>
<p>The density function to use. For example, could be
<code>"norm"</code> to correct a Gaussian density function, or <code>"lnorm"</code> to
correct a log-normal density function.</p>
</td></tr>
<tr><td><code id="truncated_distributions_+3A_target">target</code></td>
<td>
<p>The parameter/vital rate being modified. If this is a vector, the
distribution specified in <code>fun</code> will be recycled.</p>
</td></tr>
<tr><td><code id="truncated_distributions_+3A_...">...</code></td>
<td>
<p>Used internally, do not touch!</p>
</td></tr>
<tr><td><code id="truncated_distributions_+3A_state">state</code></td>
<td>
<p>The state variable used in the kernel that is being discretized.</p>
</td></tr>
<tr><td><code id="truncated_distributions_+3A_ncol">ncol</code>, <code id="truncated_distributions_+3A_nrow">nrow</code></td>
<td>
<p>The number of rows or column that the final form of the iteration
matrix should have. This is only necessary for rectangular kernels with
class <code>"CC"</code>. <code>make_ipm</code> works out the correct dimensions for
<code>"DC"</code> and <code>"CD"</code> kernels internally.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For <code>truncated_distributions</code>, a
modified function call with that truncates the probability density
function based on the cumulative density function.
</p>
<p>For <code>discrete_extrema</code>, a numeric vector with modified entries based
on the discretization process.
</p>


<h3>Note</h3>

<p>Neither of these functions are intended for use outside of
<code>define_kernel</code>, as they rely on internally generated variables to
work inside of <code>make_ipm</code>.
</p>


<h3>References</h3>

<p>Williams JL, Miller TEX &amp; Ellner SP, (2012). Avoiding unintentional eviction
from integral projection models.Ecology 93(9): 2008-2014.
</p>

<hr>
<h2 id='use_vr_model'>Predict methods in ipmr</h2><span id='topic+use_vr_model'></span>

<h3>Description</h3>

<p>This function is used when a <code>predict</code> method is incorporated
into the vital rate expressions of a kernel. Generally, ipmr can handle this
without any additional user effort, but some model classes will fail (often
with an obscure error message).
When this happens, <code>use_vr_model</code> can ensure that model object is
correctly represented in the <code>data_list</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>use_vr_model(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="use_vr_model_+3A_model">model</code></td>
<td>
<p>A fitted model object representing a vital rate. Primarily used to avoid
writing the mathematical expression for a vital rate, and using a <code>predict()</code>
method instead.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ipmr usually recognizes model objects passed into the <code>data_list</code> argument
automatically. Unfortunately, sometimes it'll miss one, and the user will need
to manually protect it from the standard build process. This function
provides a wrapper around that process. Additionally, please file a bug
report here: <a href="https://github.com/padrinoDB/ipmr/issues">https://github.com/padrinoDB/ipmr/issues</a> describing what type
of model you are trying to use so it can be added to later versions of the
package.
</p>
<p>Wrap a model object in <code>use_vr_model</code> when building the <code>data_list</code>
to pass to <code>define_kernel</code>.
</p>


<h3>Value</h3>

<p>A model object with a <code>"flat_protect"</code> attribute.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(iceplant_ex)

grow_mod &lt;- lm(log_size_next ~ log_size, data = iceplant_ex)
surv_mod &lt;- glm(survival ~ log_size, data = iceplant_ex, family = binomial())

data_list &lt;- list(
  grow_mod = use_vr_model(grow_mod),
  surv_mod = use_vr_model(surv_mod),
  recruit_mean = 20,
  recruit_sd   = 5
)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
