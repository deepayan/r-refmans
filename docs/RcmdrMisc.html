<!DOCTYPE html><html><head><title>Help for package RcmdrMisc</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {RcmdrMisc}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#assignCluster'><p>Append a Cluster Membership Variable to a Dataframe</p></a></li>
<li><a href='#Barplot'>
<p>Bar Plots</p></a></li>
<li><a href='#binnedCounts'>
<p>Binned Frequency Distributions of Numeric Variables</p></a></li>
<li><a href='#binVariable'><p>Bin a Numeric Varisible</p></a></li>
<li><a href='#colPercents'><p>Row, Column, and Total Percentage Tables</p></a></li>
<li><a href='#DeltaMethod'><p>Confidence Intervals by the Delta Method</p></a></li>
<li><a href='#discreteCounts'>
<p>Frequency Distributions of Numeric Variables</p></a></li>
<li><a href='#discretePlot'>
<p>Plot Distribution of Discrete Numeric Variable</p></a></li>
<li><a href='#Dotplot'>
<p>Dot Plots</p></a></li>
<li><a href='#Gumbel'>
<p>The Gumbel Distribution</p></a></li>
<li><a href='#Hist'><p>Plot a Histogram</p></a></li>
<li><a href='#indexplot'>
<p>Index Plots</p></a></li>
<li><a href='#KMeans'><p>K-Means Clustering Using Multiple Random Seeds</p></a></li>
<li><a href='#lineplot'>
<p>Plot a one or more lines.</p></a></li>
<li><a href='#mergeRows'>
<p>Function to Merge Rows of Two Data Frames.</p></a></li>
<li><a href='#normalityTest'>
<p>Normality Tests</p></a></li>
<li><a href='#numSummary'><p>Summary Statistics for Numeric Variables</p></a></li>
<li><a href='#partial.cor'><p>Partial Correlations</p></a></li>
<li><a href='#piechart'>
<p>Draw a Piechart With Percents or Counts in the Labels</p></a></li>
<li><a href='#plotBoot'>
<p>Plot Bootstrap Distributions</p></a></li>
<li><a href='#plotDistr'>
<p>Plot a probability density, mass, or distribution function.</p></a></li>
<li><a href='#plotMeans'><p>Plot Means for One or Two-Way Layout</p></a></li>
<li><a href='#rcorr.adjust'>
<p>Compute Pearson or Spearman Correlations with p-Values</p></a></li>
<li><a href='#readSAS'>
<p>Read a SAS b7dat Data Set</p></a></li>
<li><a href='#readSPSS'>
<p>Read an SPSS Data Set</p></a></li>
<li><a href='#readStata'>
<p>Read a Stata Data Set</p></a></li>
<li><a href='#readXL'>
<p>Read an Excel File</p></a></li>
<li><a href='#reliability'><p>Reliability of a Composite Scale</p></a></li>
<li><a href='#repeatedMeasuresPlot'>
<p>Plot Means for Repeated-Measures ANOVA Designs</p></a></li>
<li><a href='#reshapeL2W'>
<p>Reshape Repeated-Measures Data from Long to Wide Format</p></a></li>
<li><a href='#reshapeW2L'>
<p>Reshape Repeated-Measures Data from Wide to Long Format</p></a></li>
<li><a href='#stepwise'>
<p>Stepwise Model Selection</p></a></li>
<li><a href='#summarySandwich'><p>Linear Model Summary with Sandwich Standard Errors</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>2.9-1</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-09-25</td>
</tr>
<tr>
<td>Title:</td>
<td>R Commander Miscellaneous Functions</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), utils, car (&ge; 3.0-0), sandwich</td>
</tr>
<tr>
<td>Imports:</td>
<td>abind, colorspace, Hmisc (&ge; 4.1-0), MASS, e1071, foreign,
haven, readstata13, readxl, graphics, grDevices, stats,
nortest, lattice</td>
</tr>
<tr>
<td>Suggests:</td>
<td>boot, datasets, carData</td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>yes</td>
</tr>
<tr>
<td>Description:</td>
<td>
  Various statistical, graphics, and data-management functions used by the Rcmdr package in the R Commander GUI for R.  </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://www.r-project.org">https://www.r-project.org</a>,
<a href="https://socialsciences.mcmaster.ca/jfox/">https://socialsciences.mcmaster.ca/jfox/</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-09-25 15:55:52 UTC; johnfox</td>
</tr>
<tr>
<td>Author:</td>
<td>John Fox [aut, cre],
  Manuel Marquez [aut],
  Robert Muenchen [ctb],
  Dan Putler [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>John Fox &lt;jfox@mcmaster.ca&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-09-26 17:10:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='assignCluster'>Append a Cluster Membership Variable to a Dataframe</h2><span id='topic+assignCluster'></span>

<h3>Description</h3>

<p>Correctly creates a cluster membership variable that can be attached to a
dataframe when only a subset of the observations in that dataframe were used
to create the clustering solution. NAs are assigned to the observations of the
original dataframe not used in creating the clustering solution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assignCluster(clusterData, origData, clusterVec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assignCluster_+3A_clusterdata">clusterData</code></td>
<td>
<p>The data matrix used in the clustering solution.
The data matrix may have have only a subset of the observations contained in
the original dataframe.</p>
</td></tr>
<tr><td><code id="assignCluster_+3A_origdata">origData</code></td>
<td>
<p>The original dataframe from which the data used in the
clustering solution were taken.</p>
</td></tr>
<tr><td><code id="assignCluster_+3A_clustervec">clusterVec</code></td>
<td>
<p>An integer variable containing the cluster membership 
assignments for the observations used in creating the clustering solution.
This vector can be created using <code>cutree</code> for clustering solutions
generated by <code>hclust</code> or the <code>cluster</code> component of a list object
created by <code>kmeans</code> or <code>KMeans</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A factor (with integer labels) that indicate the cluster assignment for each
observation, with an NA value given to observations not used in the clustering
solution.
</p>


<h3>Author(s)</h3>

<p>Dan Putler</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+hclust">hclust</a></code>, <code><a href="stats.html#topic+cutree">cutree</a></code>, <code><a href="stats.html#topic+kmeans">kmeans</a></code>, 
<code><a href="#topic+KMeans">KMeans</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(USArrests)
  USArrkm3 &lt;- KMeans(USArrests[USArrests$UrbanPop&lt;66, ], centers=3)
  assignCluster(USArrests[USArrests$UrbanPop&lt;66, ], USArrests, USArrkm3$cluster)
</code></pre>

<hr>
<h2 id='Barplot'>
Bar Plots
</h2><span id='topic+Barplot'></span>

<h3>Description</h3>

<p>Create bar plots for one or two factors scaled by frequency or precentages.
In the case of two factors, the bars can be divided (stacked) or plotted in
parallel (side-by-side). This function is a front end to <code><a href="graphics.html#topic+barplot">barplot</a></code>
in the <span class="pkg">graphics</span> package.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Barplot(x, by, scale = c("frequency", "percent"), conditional=TRUE,
  style = c("divided", "parallel"), 
  col=if (missing(by)) "gray" else rainbow_hcl(length(levels(by))),
  xlab = deparse(substitute(x)), legend.title = deparse(substitute(by)), 
  ylab = scale, main=NULL, legend.pos = "above", label.bars=FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Barplot_+3A_x">x</code></td>
<td>

<p>a factor (or character or logical variable).</p>
</td></tr>
<tr><td><code id="Barplot_+3A_by">by</code></td>
<td>

<p>optionally, a second factor (or character or logical variable).</p>
</td></tr>
<tr><td><code id="Barplot_+3A_scale">scale</code></td>
<td>

<p>either <code>"frequency"</code> (the default) or <code>"percent"</code>.</p>
</td></tr>
<tr><td><code id="Barplot_+3A_conditional">conditional</code></td>
<td>

<p>if <code>TRUE</code> then percentages are computed separately for each value of <code>x</code> 
(i.e., conditional percentages of <code>by</code> within levels of <code>x</code>); 
if <code>FALSE</code> then total percentages are graphed; 
ignored if <code>scale="frequency"</code>.</p>
</td></tr>
<tr><td><code id="Barplot_+3A_style">style</code></td>
<td>

<p>for two-factor plots, either <code>"divided"</code> (the default) or <code>"parallel"</code>.</p>
</td></tr>
<tr><td><code id="Barplot_+3A_col">col</code></td>
<td>

<p>if <code>by</code> is missing, the color for the bars, defaulting to <code>"gray"</code>;
otherwise colors for the levels of the <code>by</code> factor in two-factor plots, defaulting to colors
provided by <code><a href="colorspace.html#topic+rainbow_hcl">rainbow_hcl</a></code> in the <span class="pkg">colorspace</span> package.</p>
</td></tr>
<tr><td><code id="Barplot_+3A_xlab">xlab</code></td>
<td>

<p>an optional character string providing a label for the horizontal axis.</p>
</td></tr>
<tr><td><code id="Barplot_+3A_legend.title">legend.title</code></td>
<td>

<p>an optional character string providing a title for the legend.</p>
</td></tr>
<tr><td><code id="Barplot_+3A_ylab">ylab</code></td>
<td>

<p>an optional character string providing a label for the vertical axis.</p>
</td></tr>
<tr><td><code id="Barplot_+3A_main">main</code></td>
<td>

<p>an optional main title for the plot.</p>
</td></tr>
<tr><td><code id="Barplot_+3A_legend.pos">legend.pos</code></td>
<td>

<p>position of the legend, in a form acceptable to the <code><a href="graphics.html#topic+legend">legend</a></code>
function; the default, <code>"above"</code>, puts the legend above the plot.</p>
</td></tr>
<tr><td><code id="Barplot_+3A_label.bars">label.bars</code></td>
<td>

<p>if <code>TRUE</code> (the default is <code>FALSE</code>) show values of frequencies or percents in the bars.
</p>
</td></tr>
<tr><td><code id="Barplot_+3A_...">...</code></td>
<td>

<p>arguments to be passed to the <code><a href="graphics.html#topic+barplot">barplot</a></code> function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Invisibly returns the horizontal coordinates of the centers of the bars.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+barplot">barplot</a></code>, <code><a href="graphics.html#topic+legend">legend</a></code>, <code><a href="colorspace.html#topic+rainbow_hcl">rainbow_hcl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>with(Mroz, {
  Barplot(wc)
  Barplot(wc, col="lightblue", label.bars=TRUE)
  Barplot(wc, by=hc)
  Barplot(wc, by=hc, scale="percent", label.bars=TRUE)
  Barplot(wc, by=hc, style="parallel", 
    scale="percent", legend.pos="center")
})
</code></pre>

<hr>
<h2 id='binnedCounts'>
Binned Frequency Distributions of Numeric Variables
</h2><span id='topic+binnedCounts'></span>

<h3>Description</h3>

<p>Bins a numeric variable, as for a histogram, and reports the count and percentage in each bin. The computations are done by the <code><a href="graphics.html#topic+hist">hist</a></code> function, but no histogram is drawn. If supplied a numeric matrix or data frame, the distribution of each column is printed. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binnedCounts(x, breaks="Sturges", round.percents=2, 
  name=deparse(substitute(x)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binnedCounts_+3A_x">x</code></td>
<td>
<p>a numeric vector, matrix, or data frame.</p>
</td></tr>
<tr><td><code id="binnedCounts_+3A_breaks">breaks</code></td>
<td>
<p>specification of the breaks between bins, to be passed to the <code><a href="graphics.html#topic+hist">hist</a></code> function.</p>
</td></tr>
<tr><td><code id="binnedCounts_+3A_round.percents">round.percents</code></td>
<td>
<p>number of decimal places to round percentages; default is <code>2</code>.</p>
</td></tr>
<tr><td><code id="binnedCounts_+3A_name">name</code></td>
<td>
<p>name for the variable; only used for vector argument <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For a numeric vector, invisibly returns the vector of counts, named with the end-points of the corresponding bins. For a matrix or data frame, invisibly returns <code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+hist">hist</a></code>, <code><a href="#topic+discreteCounts">discreteCounts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>with(Prestige, binnedCounts(income))
binnedCounts(Prestige[, 1:4])
</code></pre>

<hr>
<h2 id='binVariable'>Bin a Numeric Varisible</h2><span id='topic+binVariable'></span><span id='topic+bin.var'></span>

<h3>Description</h3>

<p>Create a factor dissecting the range of a numeric variable into
bins of equal width, (roughly) equal frequency, or at &quot;natural&quot;
cut points. The <code><a href="base.html#topic+cut">cut</a></code> function is used to create the factor.
<code>bin.var</code> is a synomym for <code>binVariable</code>, retained for backwards compatibility.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>binVariable(x, bins = 4, method = c("intervals", "proportions", "natural"),
    labels = FALSE)
    
bin.var(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="binVariable_+3A_x">x</code></td>
<td>
<p>numeric variable to be binned.</p>
</td></tr>
<tr><td><code id="binVariable_+3A_bins">bins</code></td>
<td>
<p>number of bins.</p>
</td></tr>
<tr><td><code id="binVariable_+3A_method">method</code></td>
<td>
<p>one of <code>"intervals"</code> for equal-width bins;
<code>"proportions"</code> for equal-count bins;
<code>"natural"</code> for cut points between bins to be determined
by a k-means clustering.</p>
</td></tr>
<tr><td><code id="binVariable_+3A_labels">labels</code></td>
<td>
<p>if <code>FALSE</code>, numeric labels will be used for the factor levels;
if <code>NULL</code>, the cut points are used to define labels; otherwise a character
vector of level names.</p>
</td></tr>
<tr><td><code id="binVariable_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code>binVariable</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A factor.
</p>


<h3>Author(s)</h3>

<p>Dan Putler, slightly modified by John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>
with the original author's permission.</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+cut">cut</a></code>, <code><a href="stats.html#topic+kmeans">kmeans</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>summary(binVariable(rnorm(100), method="prop", labels=letters[1:4]))
</code></pre>

<hr>
<h2 id='colPercents'>Row, Column, and Total Percentage Tables</h2><span id='topic+colPercents'></span><span id='topic+rowPercents'></span><span id='topic+totPercents'></span>

<h3>Description</h3>

<p>Percentage a matrix or higher-dimensional array of frequency counts by
rows, columns, or total frequency.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colPercents(tab, digits=1)
rowPercents(tab, digits=1)
totPercents(tab, digits=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colPercents_+3A_tab">tab</code></td>
<td>
<p>a matrix or higher-dimensional array of frequency counts.</p>
</td></tr>
<tr><td><code id="colPercents_+3A_digits">digits</code></td>
<td>
<p>number of places to the right of the decimal place for percentages.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an array of the same size and shape as <code>tab</code> percentaged by
rows or columns, plus rows or columns of totals and counts, or by the
table total.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(car)){
    data(Mroz) # from car package
    cat("\n\n column percents:\n")
    print(colPercents(xtabs(~ lfp + wc, data=Mroz)))
    cat("\n\n row percents:\n")
    print(rowPercents(xtabs(~ hc + lfp, data=Mroz)))
    cat("\n\n total percents:\n")
    print(totPercents(xtabs(~ hc + wc, data=Mroz)))
    cat("\n\n three-way table, column percents:\n")
    print(colPercents(xtabs(~ lfp + wc + hc, data=Mroz)))
}
</code></pre>

<hr>
<h2 id='DeltaMethod'>Confidence Intervals by the Delta Method</h2><span id='topic+DeltaMethod'></span><span id='topic+print.DeltaMethod'></span>

<h3>Description</h3>

<p><code>DeltaMethod</code> is a wrapper for the <code><a href="car.html#topic+deltaMethod">deltaMethod</a></code> function in the <span class="pkg">car</span> package. It computes the asymptotic standard error of an arbitrary, usually nonlinear, function of model coefficients, which are named <code>b0</code> (if there is an intercept in the model), <code>b1</code>, <code>b2</code>, etc., and based on the standard error, a confidence interval based on the normal distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DeltaMethod(model, g, level = 0.95)
## S3 method for class 'DeltaMethod'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DeltaMethod_+3A_model">model</code></td>
<td>
<p>a regression model; see the <code><a href="car.html#topic+deltaMethod">deltaMethod</a></code> documentation.</p>
</td></tr>
<tr><td><code id="DeltaMethod_+3A_g">g</code></td>
<td>
<p>the expression &mdash; that is, function of the coefficients &mdash; to evaluate, as a character string.</p>
</td></tr>
<tr><td><code id="DeltaMethod_+3A_level">level</code></td>
<td>
<p>the confidence level, defaults to <code>0.95</code>.</p>
</td></tr>
<tr><td><code id="DeltaMethod_+3A_x">x</code></td>
<td>
<p>an object of class <code>"DeltaMethod"</code>.</p>
</td></tr>
<tr><td><code id="DeltaMethod_+3A_...">...</code></td>
<td>
<p>optional arguments to pass to <code>print</code> to show the results.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>DeltaMethod</code> returns an objects of class <code>"DeltaMethod"</code>, for which a <code>print</code> method is provided.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="car.html#topic+deltaMethod">deltaMethod</a></code> function in the <span class="pkg">car</span> package</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(car)){
  DeltaMethod(lm(prestige ~ income + education, data=Duncan), "b1/b2")
  }
</code></pre>

<hr>
<h2 id='discreteCounts'>
Frequency Distributions of Numeric Variables
</h2><span id='topic+discreteCounts'></span>

<h3>Description</h3>

<p>Computes the frequency and percentage distribution of a descrete numeric variable or the distributions of the variables
in a numeric matrix or data frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discreteCounts(x, round.percents=2, name=deparse(substitute(x)),
  max.values=min(round(2*sqrt(length(x))), round(10*log10(length(x))), 100))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discreteCounts_+3A_x">x</code></td>
<td>
<p>a discrete numeric vector, matrix, or data frame.</p>
</td></tr>
<tr><td><code id="discreteCounts_+3A_round.percents">round.percents</code></td>
<td>
<p>number of decimal places to round percentages; default is <code>2</code>.</p>
</td></tr>
<tr><td><code id="discreteCounts_+3A_name">name</code></td>
<td>
<p>name for the variable; only used for vector argument <code>x</code>.</p>
</td></tr>
<tr><td><code id="discreteCounts_+3A_max.values">max.values</code></td>
<td>
<p>maximum number of unique values (default is the smallest of 
twice the square root of the number of elements in <code>x</code>, 10 times the log10 of
the number of elements, and <code>100</code>); 
if exceeded, an error is reported.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For a numeric vector, invisibly returns the table of counts. 
For a matrix or data frame, invisibly returns <code>NULL</code>
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+binnedCounts">binnedCounts</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12345) # for reproducibility
discreteCounts(data.frame(x=rpois(51, 2), y=rpois(51, 10)))
</code></pre>

<hr>
<h2 id='discretePlot'>
Plot Distribution of Discrete Numeric Variable
</h2><span id='topic+discretePlot'></span>

<h3>Description</h3>

<p>Plot the distribution of a discrete numeric variable,
optionally classified by a factor. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>discretePlot(x, by, scale = c("frequency", "percent"), 
    xlab = deparse(substitute(x)), ylab = scale, main = "",
    xlim=NULL, ylim=NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="discretePlot_+3A_x">x</code></td>
<td>
<p>a numeric variable.</p>
</td></tr>
<tr><td><code id="discretePlot_+3A_by">by</code></td>
<td>
<p>optionally a factor (or character or logical variable) by which to classify <code>x</code>.</p>
</td></tr>
<tr><td><code id="discretePlot_+3A_scale">scale</code></td>
<td>
<p>either <code>"frequency"</code> (the default) or <code>"percent"</code>.</p>
</td></tr>
<tr><td><code id="discretePlot_+3A_xlab">xlab</code></td>
<td>
<p>optional character string to label the horizontal axis.</p>
</td></tr>
<tr><td><code id="discretePlot_+3A_ylab">ylab</code></td>
<td>
<p>optional character string to label the vertical axis.</p>
</td></tr>
<tr><td><code id="discretePlot_+3A_main">main</code></td>
<td>
<p>optonal main label for the plot (ignored if the <code>by</code> argument is specified).</p>
</td></tr>
<tr><td><code id="discretePlot_+3A_xlim">xlim</code>, <code id="discretePlot_+3A_ylim">ylim</code></td>
<td>
<p>two-element numeric vectors specifying the ranges of the x and y axes; 
if not specified, will be determined from the data; 
the lower limit of the y-axis should normally be 0 and a warning will be printed if it isn't.</p>
</td></tr>
<tr><td><code id="discretePlot_+3A_...">...</code></td>
<td>
<p>other arguments to be passed to <code><a href="graphics.html#topic+plot.default">plot</a></code></p>
</td></tr></table>
<p>.
</p>


<h3>Details</h3>

<p>If the <code>by</code> argument is specified, then one plot is produced for each
level of <code>by</code>; these are arranged vertically and all use the same scale
for the horizontal and vertical axes.
</p>


<h3>Value</h3>

<p>Returns <code>NULL</code> invisibly.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Hist">Hist</a></code>, <code>link{Dotplot}</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(datasets)){
  data(mtcars)
  mtcars$cyl &lt;- factor(mtcars$cyl)
  with(mtcars, {
    discretePlot(carb)
    discretePlot(carb, scale="percent")
    discretePlot(carb, by=cyl)
  })
}
</code></pre>

<hr>
<h2 id='Dotplot'>
Dot Plots
</h2><span id='topic+Dotplot'></span>

<h3>Description</h3>

<p>Dot plot of numeric variable, either using raw values or binned, 
optionally classified by a factor. Dot plots are useful for visualizing the
distribution of a numeric variable in a small data set.</p>


<h3>Usage</h3>

<pre><code class='language-R'>Dotplot(x, by, bin = FALSE, breaks, xlim, 
    xlab = deparse(substitute(x)))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Dotplot_+3A_x">x</code></td>
<td>
<p>a numeric variable.</p>
</td></tr>
<tr><td><code id="Dotplot_+3A_by">by</code></td>
<td>
<p>optionally a factor (or character or logical variable) by which to classify <code>x</code>.</p>
</td></tr>
<tr><td><code id="Dotplot_+3A_bin">bin</code></td>
<td>
<p>if <code>TRUE</code> (the default is <code>FALSE</code>), the values of <code>x</code> are binned, 
as in a histogram, prior to plotting.</p>
</td></tr>
<tr><td><code id="Dotplot_+3A_breaks">breaks</code></td>
<td>
<p>breaks for the bins, in a form acceptable to the <code><a href="graphics.html#topic+hist">hist</a></code> function;
the default is <code>"Sturges"</code>.</p>
</td></tr>
<tr><td><code id="Dotplot_+3A_xlim">xlim</code></td>
<td>
<p>optional 2-element numeric vector giving limits of the horizontal axis.</p>
</td></tr>
<tr><td><code id="Dotplot_+3A_xlab">xlab</code></td>
<td>
<p>optional character string to label horizontal axis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the <code>by</code> argument is specified, then one dot plot is produced for each
level of <code>by</code>; these are arranged vertically and all use the same scale
for <code>x</code>. An attempt is made to adjust the size of the dots to the space
available without making them too big.
</p>


<h3>Value</h3>

<p>Returns <code>NULL</code> invisibly.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+hist">hist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(car)){
  data(Duncan)
  with(Duncan, {
    Dotplot(education)
    Dotplot(education, bin=TRUE)
    Dotplot(education, by=type)
    Dotplot(education, by=type, bin=TRUE)
  })
}
</code></pre>

<hr>
<h2 id='Gumbel'>
The Gumbel Distribution
</h2><span id='topic+Gumbel'></span><span id='topic+dgumbel'></span><span id='topic+pgumbel'></span><span id='topic+qgumbel'></span><span id='topic+rgumbel'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random generation for the Gumbel distribution with
specified <code>location</code> and <code>scale</code> parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dgumbel(x, location = 0, scale = 1)
pgumbel(q, location=0, scale=1, lower.tail=TRUE)
qgumbel(p, location=0, scale=1, lower.tail=TRUE)
rgumbel(n, location=0, scale=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gumbel_+3A_x">x</code>, <code id="Gumbel_+3A_q">q</code></td>
<td>
<p>vector of quantiles (values of the variable).</p>
</td></tr>
<tr><td><code id="Gumbel_+3A_p">p</code></td>
<td>
<p>vector of probabilities.</p>
</td></tr>
<tr><td><code id="Gumbel_+3A_n">n</code></td>
<td>
<p>number of observations. If <code>length(n)</code> &gt; 1, the length is taken to be the number required.</p>
</td></tr>
<tr><td><code id="Gumbel_+3A_location">location</code></td>
<td>
<p>location parameter (default <code>0</code>); potentially a vector.</p>
</td></tr>
<tr><td><code id="Gumbel_+3A_scale">scale</code></td>
<td>
<p>scale parameter (default <code>1</code>); potentially a vector.</p>
</td></tr>
<tr><td><code id="Gumbel_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (the default) probabilities and quantiles correspond to
<code class="reqn">P(X \le x)</code>, if <code>FALSE</code> to  <code class="reqn">P(X &gt; x)</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>
</p>


<h3>References</h3>

<p>See <a href="https://en.wikipedia.org/wiki/Gumbel_distribution">https://en.wikipedia.org/wiki/Gumbel_distribution</a> for details of the Gumbel distribution.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- 100 + 5*c(-Inf, -1, 0, 1, 2, 3, Inf, NA)
dgumbel(x, 100, 5)
pgumbel(x, 100, 5)

p &lt;- c(0, .25, .5, .75, 1, NA)
qgumbel(p, 100, 5)

summary(rgumbel(1e5, 100, 5))
</code></pre>

<hr>
<h2 id='Hist'>Plot a Histogram</h2><span id='topic+Hist'></span>

<h3>Description</h3>

<p>This function is a wrapper for the <code><a href="graphics.html#topic+hist">hist</a></code> function in
the <code>base</code> package, permitting percentage scaling of the
vertical axis in addition to frequency and density scaling.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Hist(x, groups, scale=c("frequency", "percent", "density"), xlab=deparse(substitute(x)), 
    ylab=scale, main="", breaks = "Sturges", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Hist_+3A_x">x</code></td>
<td>
<p>a vector of values for which a histogram is to be plotted.</p>
</td></tr>
<tr><td><code id="Hist_+3A_groups">groups</code></td>
<td>
<p>a factor (or character or logical variable) to create histograms by group with common horizontal and vertical scales.</p>
</td></tr>
<tr><td><code id="Hist_+3A_scale">scale</code></td>
<td>
<p>the scaling of the vertical axis: <code>"frequency"</code> (the default),
<code>"percent"</code>, or <code>"density"</code>.</p>
</td></tr>
<tr><td><code id="Hist_+3A_xlab">xlab</code></td>
<td>
<p>x-axis label, defaults to name of variable.</p>
</td></tr>
<tr><td><code id="Hist_+3A_ylab">ylab</code></td>
<td>
<p>y-axis label, defaults to value of <code>scale</code>.</p>
</td></tr>
<tr><td><code id="Hist_+3A_main">main</code></td>
<td>
<p>main title for graph, defaults to empty.</p>
</td></tr>
<tr><td><code id="Hist_+3A_breaks">breaks</code></td>
<td>
<p>see the <code>breaks</code> argument for <code><a href="graphics.html#topic+hist">hist</a></code>.</p>
</td></tr>
<tr><td><code id="Hist_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code>hist</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>This function is primarily called for its side effect &mdash;
plotting a histogram or histograms &mdash; but it also invisibly 
returns an object of class <code><a href="graphics.html#topic+hist">hist</a></code> or a list of <code>hist</code> objects.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+hist">hist</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(Prestige, package="car")
    Hist(Prestige$income, scale="percent")
    with(Prestige, Hist(income, groups=type))
    </code></pre>

<hr>
<h2 id='indexplot'>
Index Plots
</h2><span id='topic+indexplot'></span>

<h3>Description</h3>

<p>Index plots with point identification.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>indexplot(x, groups, labels = seq_along(x), id.method = "y", type = "h", 
    id.n = 0, ylab, legend="topright", title, col=palette(), ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="indexplot_+3A_x">x</code></td>
<td>
<p>a numeric variable, a matrix whose columns are numeric variables, or a numeric data frame;
if <code>x</code> is a matrix or data frame, plots vertically aligned index plots for the columns.</p>
</td></tr>
<tr><td><code id="indexplot_+3A_labels">labels</code></td>
<td>
<p>point labels; if <code>x</code> is a data frame, defaults to the row names of <code>x</code>,
otherwise to the case index.</p>
</td></tr>
<tr><td><code id="indexplot_+3A_groups">groups</code></td>
<td>
<p>an optional grouping variable, typically a factor (or character or logical variable).</p>
</td></tr>
<tr><td><code id="indexplot_+3A_id.method">id.method</code></td>
<td>
<p>method for identifying points; see <code><a href="car.html#topic+showLabels">showLabels</a></code>.</p>
</td></tr>
<tr><td><code id="indexplot_+3A_type">type</code></td>
<td>
<p>to be passed to <code><a href="base.html#topic+plot">plot</a></code>.</p>
</td></tr>
<tr><td><code id="indexplot_+3A_id.n">id.n</code></td>
<td>
<p>number of points to identify; see <code><a href="car.html#topic+showLabels">showLabels</a></code>.</p>
</td></tr>
<tr><td><code id="indexplot_+3A_ylab">ylab</code></td>
<td>
<p>label for vertical axis; if missing, will be constructed from <code>x</code>; for a data frame,
defaults to the column names.</p>
</td></tr>
<tr><td><code id="indexplot_+3A_legend">legend</code></td>
<td>
<p>keyword (see <code>link</code>[grapics]legend) giving location of the legend if <code>groups</code> are specified; 
if <code>legend=FALSE</code>, the legend is suppressed.</p>
</td></tr>
<tr><td><code id="indexplot_+3A_title">title</code></td>
<td>
<p>title for the legend; may normally be omitted.</p>
</td></tr>
<tr><td><code id="indexplot_+3A_col">col</code></td>
<td>
<p>vector of colors for the <code>groups</code>.</p>
</td></tr>
<tr><td><code id="indexplot_+3A_...">...</code></td>
<td>
<p>to be passed to <code>plot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns labelled indices of identified points or (invisibly) <code>NULL</code> if no points
are identified or if there are multiple variables with some missing data.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="car.html#topic+showLabels">showLabels</a></code>, <code><a href="graphics.html#topic+plot.default">plot.default</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("car")){
    with(Prestige, indexplot(income, id.n=2, labels=rownames(Prestige)))
    indexplot(Prestige[, c("income", "education", "prestige")], 
        groups = Prestige$type, id.n=2)
}
</code></pre>

<hr>
<h2 id='KMeans'>K-Means Clustering Using Multiple Random Seeds</h2><span id='topic+KMeans'></span>

<h3>Description</h3>

<p>Finds a number of k-means clusting solutions using R's <code>kmeans</code> function,
and selects as the final solution the one that has the minimum total
within-cluster sum of squared distances.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KMeans(x, centers, iter.max=10, num.seeds=10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KMeans_+3A_x">x</code></td>
<td>
<p>A numeric matrix of data, or an object that can be coerced to such a
matrix (such as a numeric vector or a dataframe with all numeric columns).</p>
</td></tr>
<tr><td><code id="KMeans_+3A_centers">centers</code></td>
<td>
<p>The number of clusters in the solution.</p>
</td></tr>
<tr><td><code id="KMeans_+3A_iter.max">iter.max</code></td>
<td>
<p>The maximum number of iterations allowed.</p>
</td></tr>
<tr><td><code id="KMeans_+3A_num.seeds">num.seeds</code></td>
<td>
<p>The number of different starting random seeds to use. Each
random seed results in a different k-means solution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with components:
</p>
<table>
<tr><td><code>cluster</code></td>
<td>
<p>A vector of integers indicating the cluster to which each 
point is allocated.</p>
</td></tr>
<tr><td><code>centers</code></td>
<td>
<p>A matrix of cluster centres (centroids).</p>
</td></tr>
<tr><td><code>withinss</code></td>
<td>
<p>The within-cluster sum of squares for each cluster.</p>
</td></tr>
<tr><td><code>tot.withinss</code></td>
<td>
<p>The within-cluster sum of squares summed across clusters.</p>
</td></tr>
<tr><td><code>betweenss</code></td>
<td>
<p>The between-cluster sum of squared distances.</p>
</td></tr>
<tr><td><code>size</code></td>
<td>
<p>The number of points in each cluster.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Dan Putler</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+kmeans">kmeans</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(USArrests)
  KMeans(USArrests, centers=3, iter.max=5, num.seeds=5)
</code></pre>

<hr>
<h2 id='lineplot'>
Plot a one or more lines.
</h2><span id='topic+lineplot'></span>

<h3>Description</h3>

<p>This function plots lines for one or more variables against another variable &mdash; 
typically time series against time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lineplot(x, ..., legend)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lineplot_+3A_x">x</code></td>
<td>
<p>variable giving horizontal coordinates.</p>
</td></tr>
<tr><td><code id="lineplot_+3A_...">...</code></td>
<td>
<p>one or more variables giving vertical coordinates.</p>
</td></tr>
<tr><td><code id="lineplot_+3A_legend">legend</code></td>
<td>
<p>plot legend? Default is <code>TRUE</code> if there is more than one
variable to plot and <code>FALSE</code> is there is just one.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Produces a plot; returns <code>NULL</code> invisibly.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>    if (require("car")){
    data(Bfox)
    Bfox$time &lt;- as.numeric(rownames(Bfox))
    with(Bfox, lineplot(time, menwage, womwage))
}
</code></pre>

<hr>
<h2 id='mergeRows'>
Function to Merge Rows of Two Data Frames.
</h2><span id='topic+mergeRows'></span><span id='topic+mergeRows.data.frame'></span>

<h3>Description</h3>

<p>This function merges two data frames by combining their rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mergeRows(X, Y, common.only = FALSE, ...)

## S3 method for class 'data.frame'
mergeRows(X, Y, common.only = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mergeRows_+3A_x">X</code></td>
<td>
<p>First data frame.</p>
</td></tr>
<tr><td><code id="mergeRows_+3A_y">Y</code></td>
<td>
<p>Second data frame.</p>
</td></tr>
<tr><td><code id="mergeRows_+3A_common.only">common.only</code></td>
<td>
<p>If <code>TRUE</code>, only variables (columns) common to the two
data frame are included in the merged data set; the default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mergeRows_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the rows from both input data frames.</p>


<h3>Author(s)</h3>

<p>John Fox</p>


<h3>See Also</h3>

<p>For column merges and more complex merges, see <code><a href="base.html#topic+merge">merge</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(car)){
    data(Duncan)
    D1 &lt;- Duncan[1:20,]
    D2 &lt;- Duncan[21:45,]
    D &lt;- mergeRows(D1, D2)
    print(D)
    dim(D)
}
</code></pre>

<hr>
<h2 id='normalityTest'>
Normality Tests
</h2><span id='topic+normalityTest'></span><span id='topic+normalityTest.default'></span><span id='topic+normalityTest.formula'></span>

<h3>Description</h3>

<p>Perform one of several tests of normality, either for a variable or for a variable by groups. The <code>normalityTest</code>
function uses the <code><a href="stats.html#topic+shapiro.test">shapiro.test</a></code> function or one of several functions in the <span class="pkg">nortest</span> package.
If tests are done by groups, then adjusted p-values, computed by the Holm method, are also reported (see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalityTest(x, ...)

## S3 method for class 'formula'
normalityTest(formula, test, data, ...)

## Default S3 method:
normalityTest(x, 
    test=c("shapiro.test", "ad.test", "cvm.test", "lillie.test", 
        "pearson.test", "sf.test"),
    groups, vname, gname, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalityTest_+3A_x">x</code></td>
<td>
<p>numeric vector or formula.</p>
</td></tr>
<tr><td><code id="normalityTest_+3A_formula">formula</code></td>
<td>
<p>one-sided formula of the form <code>~x</code> or two-sided formula of the form <code>x ~ groups</code>,
where <code>x</code> is a numeric variable and <code>groups</code> is a factor.</p>
</td></tr>
<tr><td><code id="normalityTest_+3A_data">data</code></td>
<td>
<p>a data frame containing the data for the test.</p>
</td></tr>
<tr><td><code id="normalityTest_+3A_test">test</code></td>
<td>
<p>quoted name of the function to perform the test.</p>
</td></tr>
<tr><td><code id="normalityTest_+3A_groups">groups</code></td>
<td>
<p>optional factor to divide the data into groups.</p>
</td></tr>
<tr><td><code id="normalityTest_+3A_vname">vname</code></td>
<td>
<p>optional name for the variable; if absent, taken from <code>x</code>.</p>
</td></tr>
<tr><td><code id="normalityTest_+3A_gname">gname</code></td>
<td>
<p>optional name for the grouping factor; if absent, taken from <code>groups</code>.</p>
</td></tr>
<tr><td><code id="normalityTest_+3A_...">...</code></td>
<td>
<p>any arguments to be passed down; the only useful such arguments are for the 
<code><a href="nortest.html#topic+pearson.test">pearson.test</a></code> function in the <span class="pkg">nortest</span> package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>If testing by groups, the function invisibly returns <code>NULL</code>; otherwise it returns an object of class
<code>"htest"</code>, which normally would be printed.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+shapiro.test">shapiro.test</a></code>, <code><a href="nortest.html#topic+ad.test">ad.test</a></code>, <code><a href="nortest.html#topic+cvm.test">cvm.test</a></code>, <code><a href="nortest.html#topic+lillie.test">lillie.test</a></code>,
<code><a href="nortest.html#topic+pearson.test">pearson.test</a></code>, <code><a href="nortest.html#topic+sf.test">sf.test</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(Prestige, package="car")
  with(Prestige, normalityTest(income))
  normalityTest(income ~ type, data=Prestige, test="ad.test")
  normalityTest(~income, data=Prestige, test="pearson.test", n.classes=5)
</code></pre>

<hr>
<h2 id='numSummary'>Summary Statistics for Numeric Variables</h2><span id='topic+numSummary'></span><span id='topic+print.numSummary'></span><span id='topic+CV'></span>

<h3>Description</h3>

<p><code>numSummary</code> creates neatly formatted tables of means, standard deviations, coefficients of variation,
skewness, kurtosis, and quantiles of numeric variables. <code>CV</code> computes the coefficient of variation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numSummary(data, 
           statistics=c("mean", "sd", "se(mean)", "var", "CV", "IQR", 
                "quantiles", "skewness", "kurtosis"),
            type=c("2", "1", "3"),
            quantiles=c(0, .25, .5, .75, 1),
            groups)

CV(x, na.rm=TRUE)
    
## S3 method for class 'numSummary'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="numSummary_+3A_data">data</code></td>
<td>
<p>a numeric vector, matrix, or data frame.</p>
</td></tr>
<tr><td><code id="numSummary_+3A_statistics">statistics</code></td>
<td>
<p>any of <code>"mean"</code>, <code>"sd"</code>, <code>"se(mean)"</code>,
<code>"var"</code>, <code>"CV"</code>, <code>"IQR"</code>, <code>"quantiles"</code>, 
<code>"skewness"</code>, or <code>"kurtosis"</code>,
defaulting to <code>c("mean", "sd", "quantiles", "IQR")</code>.</p>
</td></tr>
<tr><td><code id="numSummary_+3A_type">type</code></td>
<td>
<p>definition to use in computing skewness and kurtosis; see the 
<code><a href="e1071.html#topic+skewness">skewness</a></code> and <code><a href="e1071.html#topic+kurtosis">kurtosis</a></code> functions in the <span class="pkg">e1071</span>
package. The default is <code>"2"</code>.</p>
</td></tr>
<tr><td><code id="numSummary_+3A_quantiles">quantiles</code></td>
<td>
<p>quantiles to report; default is <code>c(0, 0.25, 0.5, 0.75, 1)</code>.</p>
</td></tr>
<tr><td><code id="numSummary_+3A_groups">groups</code></td>
<td>
<p>optional variable, typically a factor, to be used to partition the data.</p>
</td></tr>
<tr><td><code id="numSummary_+3A_x">x</code></td>
<td>
<p>object of class <code>"numSummary"</code> to print, or for <code>CV</code>, a numeric vector or matrix.</p>
</td></tr>
<tr><td><code id="numSummary_+3A_na.rm">na.rm</code></td>
<td>
<p>if <code>TRUE</code> (the default) remove <code>NA</code>s before computing the coefficient of variation.</p>
</td></tr>
<tr><td><code id="numSummary_+3A_...">...</code></td>
<td>
<p>arguments to pass down from the print method.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>numSummary</code> returns an object of class <code>"numSummary"</code> containing the table of 
statistics to be reported along with information on missing data, if there are any. <code>CV</code> returns the coefficient(s) of variation.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+mean">mean</a></code>, <code><a href="stats.html#topic+sd">sd</a></code>, <code><a href="stats.html#topic+quantile">quantile</a></code>,
<code><a href="e1071.html#topic+skewness">skewness</a></code>, <code><a href="e1071.html#topic+kurtosis">kurtosis</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require("carData")){
    data(Prestige)
    Prestige[1, "income"] &lt;- NA
    print(numSummary(Prestige[,c("income", "education")], 
    	statistics=c("mean", "sd", "quantiles", "cv", "skewness", "kurtosis")))
    print(numSummary(Prestige[,c("income", "education")], groups=Prestige$type))
    remove(Prestige)
}
</code></pre>

<hr>
<h2 id='partial.cor'>Partial Correlations</h2><span id='topic+partial.cor'></span>

<h3>Description</h3>

<p>Computes a matrix of partial correlations between each pair of variables
controlling for the others.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>partial.cor(X, tests=FALSE, use=c("complete.obs", "pairwise.complete.obs"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="partial.cor_+3A_x">X</code></td>
<td>
<p>data matrix.</p>
</td></tr>
<tr><td><code id="partial.cor_+3A_tests">tests</code></td>
<td>
<p>show two-sided p-value and p-value adjusted for multiple testing by Holm's method for each partial correlation?</p>
</td></tr>
<tr><td><code id="partial.cor_+3A_use">use</code></td>
<td>
<p>observations to use to compute partial correlations, default is <code>"complete.obs"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the matrix of partial correlations, optionally with adjusted and unadjusted p-values.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+cor">cor</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>    data(DavisThin, package="car")
    partial.cor(DavisThin)
    partial.cor(DavisThin, tests=TRUE)
</code></pre>

<hr>
<h2 id='piechart'>
Draw a Piechart With Percents or Counts in the Labels
</h2><span id='topic+piechart'></span>

<h3>Description</h3>

<p><code>piechart</code> is a front-end to the standard R <code><a href="graphics.html#topic+pie">pie</a></code> function, with the
capability of adding percents or counts to the pie-segment labels.</p>


<h3>Usage</h3>

<pre><code class='language-R'>piechart(x, scale = c("percent", "frequency", "none"), 
  col = rainbow_hcl(nlevels(x)), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="piechart_+3A_x">x</code></td>
<td>

<p>a factor or other discrete variable; the segments of the pie correspond to the
unique values (levels) of <code>x</code> and are proportional to the frequency counts in
the various levels.
</p>
</td></tr>
<tr><td><code id="piechart_+3A_scale">scale</code></td>
<td>

<p>parenthetical numbers to add to the pie-segment labels; the default is <code>"percent"</code>.
</p>
</td></tr>
<tr><td><code id="piechart_+3A_col">col</code></td>
<td>

<p>colors for the segments; the default is provided by the <code><a href="colorspace.html#topic+rainbow_hcl">rainbow_hcl</a></code>
function in the <span class="pkg">colorspace</span> package.
</p>
</td></tr>
<tr><td><code id="piechart_+3A_...">...</code></td>
<td>

<p>further arguments to be passed to <code><a href="graphics.html#topic+pie">pie</a></code>.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="graphics.html#topic+pie">pie</a></code>, <code><a href="colorspace.html#topic+rainbow_hcl">rainbow_hcl</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>with(Duncan, piechart(type))
</code></pre>

<hr>
<h2 id='plotBoot'>
Plot Bootstrap Distributions
</h2><span id='topic+plotBoot'></span><span id='topic+plotBoot.boot'></span>

<h3>Description</h3>

<p>The function takes an object of class <code>"boot"</code> and creates an array of density estimates for the bootstrap distributions of the parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotBoot(object, confint=NULL, ...)
## S3 method for class 'boot'
plotBoot(object, confint=NULL, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotBoot_+3A_object">object</code></td>
<td>
<p>an object of class <code>"boot"</code>.</p>
</td></tr>
<tr><td><code id="plotBoot_+3A_confint">confint</code></td>
<td>
<p>an object of class <code>"confint.boot"</code> (or an ordinary 2-column matrix) containing confidence limits for the parameters in <code>object</code>; if <code>NULL</code> (the default), these are computed from the first argument, using the defaults for <code>"boot"</code> objects.</p>
</td></tr>
<tr><td><code id="plotBoot_+3A_...">...</code></td>
<td>
<p>not used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates an array of adaptive kernal density plots, using <code><a href="car.html#topic+densityPlot">densityPlot</a></code> in the <span class="pkg">car</span> package, showing the bootstrap distribution, point estimate ,and (optionally) confidence limits for each parameter.</p>


<h3>Value</h3>

<p>Invisibly returns the object produced by <code>densityPlot</code>.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="car.html#topic+densityPlot">densityPlot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
plotBoot(Boot(lm(prestige ~ income + education + type, data=Duncan)))

## End(Not run)
</code></pre>

<hr>
<h2 id='plotDistr'>
Plot a probability density, mass, or distribution function.
</h2><span id='topic+plotDistr'></span>

<h3>Description</h3>

<p>This function plots a probability density, mass, or distribution function, adapting the form
of the plot as appropriate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotDistr(x, p, discrete=FALSE, cdf=FALSE, 
  regions=NULL, col="gray", 
  legend=TRUE, legend.pos="topright", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotDistr_+3A_x">x</code></td>
<td>
<p>horizontal coordinates</p>
</td></tr>
<tr><td><code id="plotDistr_+3A_p">p</code></td>
<td>
<p>vertical coordinates</p>
</td></tr>
<tr><td><code id="plotDistr_+3A_discrete">discrete</code></td>
<td>
<p>is the random variable discrete?</p>
</td></tr>
<tr><td><code id="plotDistr_+3A_cdf">cdf</code></td>
<td>
<p>is this a cumulative distribution (as opposed to mass) function?</p>
</td></tr>
<tr><td><code id="plotDistr_+3A_regions">regions</code>, <code id="plotDistr_+3A_col">col</code></td>
<td>
<p>for continuous distributions only,
if non-<code>NULL</code>, a list of regions to fill with color <code>col</code>;
each element of the list is a pair of <code>x</code> values with the minimum and maximum
horizontal coordinates of the corresponding region; <code>col</code> may be a single value
or a vector.</p>
</td></tr>
<tr><td><code id="plotDistr_+3A_legend">legend</code></td>
<td>
<p>plot a legend of the regions (default <code>TRUE</code>).</p>
</td></tr>
<tr><td><code id="plotDistr_+3A_legend.pos">legend.pos</code></td>
<td>
<p>position for the legend (see <code><a href="graphics.html#topic+legend">legend</a></code>, default <code>"topright"</code>).</p>
</td></tr>
<tr><td><code id="plotDistr_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code>plot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Produces a plot; returns <code>NULL</code> invisibly.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- seq(-4, 4, length=100)
plotDistr(x, dnorm(x), xlab="Z", ylab="p(z)", main="Standard Normal Density")
plotDistr(x, dnorm(x), xlab="Z", ylab="p(z)", main="Standard Normal Density",
    region=list(c(1.96, Inf), c(-Inf, -1.96)), col=c("red", "blue"))
plotDistr(x, dnorm(x), xlab="Z", ylab="p(z)", main="Standard Normal Density",
    region=list(c(qnorm(0), qnorm(.025)), c(qnorm(.975), qnorm(1)))) # same 

x &lt;- 0:10
plotDistr(x, pbinom(x, 10, 0.5), xlab="successes", 
    discrete=TRUE, cdf=TRUE,
    main="Binomial Distribution Function, p=0.5, n=10")
</code></pre>

<hr>
<h2 id='plotMeans'>Plot Means for One or Two-Way Layout</h2><span id='topic+plotMeans'></span>

<h3>Description</h3>

<p>Plots cell means for a numeric variable in each category of a factor or in each
combination of categories of two factors, optionally along with error bars based
on cell standard errors or standard deviations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotMeans(response, factor1, factor2, 
    error.bars = c("se", "sd", "conf.int", "none"),
    level=0.95, xlab=deparse(substitute(factor1)), 
    ylab=paste("mean of", deparse(substitute(response))),
    legend.lab=deparse(substitute(factor2)), 
    legend.pos=c("farright", "bottomright", "bottom", "bottomleft", 
                 "left", "topleft", "top", "topright", "right", "center"),
    main="Plot of Means",
    pch=1:n.levs.2, lty=1:n.levs.2, col=palette(), connect=TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotMeans_+3A_response">response</code></td>
<td>
<p>Numeric variable for which means are to be computed.</p>
</td></tr>
<tr><td><code id="plotMeans_+3A_factor1">factor1</code></td>
<td>
<p>Factor defining horizontal axis of the plot.</p>
</td></tr>
<tr><td><code id="plotMeans_+3A_factor2">factor2</code></td>
<td>
<p>If present, factor defining profiles of means</p>
</td></tr>
<tr><td><code id="plotMeans_+3A_error.bars">error.bars</code></td>
<td>
<p>If <code>"se"</code>, the default, error bars around means
give plus or minus one standard error of the mean; if <code>"sd"</code>, error
bars give plus or minus one standard deviation; if <code>"conf.int"</code>, error
bars give a confidence interval around each mean; if <code>"none"</code>, error
bars are suppressed.</p>
</td></tr>
<tr><td><code id="plotMeans_+3A_level">level</code></td>
<td>
<p>level of confidence for confidence intervals; default is .95</p>
</td></tr>
<tr><td><code id="plotMeans_+3A_xlab">xlab</code></td>
<td>
<p>Label for horizontal axis.</p>
</td></tr>
<tr><td><code id="plotMeans_+3A_ylab">ylab</code></td>
<td>
<p>Label for vertical axis.</p>
</td></tr>
<tr><td><code id="plotMeans_+3A_legend.lab">legend.lab</code></td>
<td>
<p>Label for legend.</p>
</td></tr>
<tr><td><code id="plotMeans_+3A_legend.pos">legend.pos</code></td>
<td>
<p>Position of legend; if <code>"farright"</code> (the default), extra space is left at the right of the plot.</p>
</td></tr>
<tr><td><code id="plotMeans_+3A_main">main</code></td>
<td>
<p>Label for the graph.</p>
</td></tr>
<tr><td><code id="plotMeans_+3A_pch">pch</code></td>
<td>
<p>Plotting characters for profiles of means.</p>
</td></tr>
<tr><td><code id="plotMeans_+3A_lty">lty</code></td>
<td>
<p>Line types for profiles of means.</p>
</td></tr>
<tr><td><code id="plotMeans_+3A_col">col</code></td>
<td>
<p>Colours for profiles of means</p>
</td></tr>
<tr><td><code id="plotMeans_+3A_connect">connect</code></td>
<td>
<p>connect profiles of means, default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="plotMeans_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code>plot</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function invisibly returns <code>NULL</code>.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+interaction.plot">interaction.plot</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(car)){
    data(Moore)
    with(Moore, plotMeans(conformity, fcategory, partner.status, ylim=c(0, 25)))
}
</code></pre>

<hr>
<h2 id='rcorr.adjust'>
Compute Pearson or Spearman Correlations with p-Values
</h2><span id='topic+rcorr.adjust'></span><span id='topic+print.rcorr.adjust'></span>

<h3>Description</h3>

<p>This function uses the <code><a href="Hmisc.html#topic+rcorr">rcorr</a></code> function in the <span class="pkg">Hmisc</span> package
to compute matrices of Pearson or Spearman correlations along with
the pairwise p-values among the correlations. The p-values are corrected
for multiple inference using Holm's method (see <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>).
Observations are filtered for missing data, and only complete observations are used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rcorr.adjust(x, type = c("pearson", "spearman"), 
	use=c("complete.obs", "pairwise.complete.obs"))

## S3 method for class 'rcorr.adjust'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rcorr.adjust_+3A_x">x</code></td>
<td>
<p>a numeric matrix or data frame, or an object of class <code>"rcorr.adjust"</code> to be printed.</p>
</td></tr>
<tr><td><code id="rcorr.adjust_+3A_type">type</code></td>
<td>
<p><code>"pearson"</code> or <code>"spearman"</code>, depending upon the type of
correlations desired; the default is <code>"pearson"</code>.</p>
</td></tr>
<tr><td><code id="rcorr.adjust_+3A_use">use</code></td>
<td>
<p>how to handle missing data: <code>"complete.obs"</code>, the default, use only complete cases;
<code>"pairwise.complete.obs"</code>, use all cases with valid data for each pair.</p>
</td></tr>
<tr><td><code id="rcorr.adjust_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>"rcorr.adjust"</code>, which is normally just printed.
</p>


<h3>Author(s)</h3>

<p>John Fox, adapting code from Robert A. Muenchen.
</p>


<h3>See Also</h3>

<p><code><a href="Hmisc.html#topic+rcorr">rcorr</a></code>, <code><a href="stats.html#topic+p.adjust">p.adjust</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(car)){
    data(Mroz)
    print(rcorr.adjust(Mroz[,c("k5", "k618", "age", "lwg", "inc")]))
    print(rcorr.adjust(Mroz[,c("k5", "k618", "age", "lwg", "inc")], type="spearman"))
    }
</code></pre>

<hr>
<h2 id='readSAS'>
Read a SAS b7dat Data Set
</h2><span id='topic+readSAS'></span>

<h3>Description</h3>

<p><code>readSAS</code> reads a SAS &ldquo;b7dat&rdquo; data set, stored in a file of type <code>.sas7bdat</code>, into an R data frame; it provides
a front end to the <code><a href="haven.html#topic+read_sas">read_sas</a></code> function in the <span class="pkg">haven</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readSAS(file, rownames=FALSE, stringsAsFactors=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readSAS_+3A_file">file</code></td>
<td>
<p>path to a SAS b7dat file.</p>
</td></tr>
<tr><td><code id="readSAS_+3A_rownames">rownames</code></td>
<td>
<p>if <code>TRUE</code> (the default is <code>FALSE</code>), the first column in the
data set contains row names (which must be unique&mdash;i.e., no duplicates).</p>
</td></tr>
<tr><td><code id="readSAS_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>if <code>TRUE</code> (the default is <code>FALSE</code>) then columns containing character data are converted to
factors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="haven.html#topic+read_sas">read_sas</a></code>
</p>

<hr>
<h2 id='readSPSS'>
Read an SPSS Data Set
</h2><span id='topic+readSPSS'></span>

<h3>Description</h3>

<p><code>readSPSS</code> reads an SPSS data set, stored in a file of type <code>.sav</code> or <code>.por</code>, into an R data frame; it provides
a front end to the <code><a href="haven.html#topic+read_spss">read_spss</a></code> function in the <span class="pkg">haven</span> package and the <code><a href="foreign.html#topic+read.spss">read.spss</a></code> function in the <span class="pkg">foreign</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readSPSS(file, rownames=FALSE, stringsAsFactors=FALSE,
  tolower=TRUE, use.value.labels=TRUE, use.haven=!por)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readSPSS_+3A_file">file</code></td>
<td>
<p>path to an SPSS <code>.sav</code> or <code>.por</code> file.</p>
</td></tr>
<tr><td><code id="readSPSS_+3A_rownames">rownames</code></td>
<td>
<p>if <code>TRUE</code> (the default is <code>FALSE</code>), the first column in the
data set contains row names, which should be unique.</p>
</td></tr>
<tr><td><code id="readSPSS_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>if <code>TRUE</code> (the default is <code>FALSE</code>) then columns containing character data are converted to
factors and factors are created from SPSS value labels.</p>
</td></tr>
<tr><td><code id="readSPSS_+3A_tolower">tolower</code></td>
<td>
<p>change variable names to lowercase, default <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="readSPSS_+3A_use.value.labels">use.value.labels</code></td>
<td>
<p>if <code>TRUE</code>, the default, variables with value labels in the SPSS
data set will become either factors or character variables (depending on the <code>stringsAsFactors</code>
argument) with the value labels as their levels or values. As for <code><a href="foreign.html#topic+read.spss">read.spss</a></code>, 
this is only done if there are at least as many labels as values of the variable 
(and values without a matching label are returned as <code>NA</code>).</p>
</td></tr>
<tr><td><code id="readSPSS_+3A_use.haven">use.haven</code></td>
<td>
<p>use <code><a href="haven.html#topic+read_spss">read_spss</a></code> from the <span class="pkg">haven</span> package to read the file,
in preference to <code><a href="foreign.html#topic+read.spss">read.spss</a></code> from the <span class="pkg">foreign</span> package; the default is
<code>TRUE</code> for a <code>.sav</code> file and <code>FALSE</code> for a <code>.por</code> file.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="haven.html#topic+read_spss">read_spss</a></code>, <code><a href="foreign.html#topic+read.spss">read.spss</a></code>
</p>

<hr>
<h2 id='readStata'>
Read a Stata Data Set
</h2><span id='topic+readStata'></span>

<h3>Description</h3>

<p><code>readStata</code> reads a Stata data set, stored in a file of type <code>.dta</code>, into an R data frame; it provides
a front end to the <code><a href="readstata13.html#topic+read.dta13">read.dta13</a></code> function in the <span class="pkg">readstata13</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readStata(file, rownames=FALSE, stringsAsFactors=FALSE,  convert.dates=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readStata_+3A_file">file</code></td>
<td>
<p>path to a Stata <code>.dta</code> file.</p>
</td></tr>
<tr><td><code id="readStata_+3A_rownames">rownames</code></td>
<td>
<p>if <code>TRUE</code> (the default is <code>FALSE</code>), the first column in the
data set contains row names, which should be unique.</p>
</td></tr>
<tr><td><code id="readStata_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>if <code>TRUE</code> (the default is <code>FALSE</code>) then columns containing character data are converted to
factors and factors are created from Stata value labels.</p>
</td></tr>
<tr><td><code id="readStata_+3A_convert.dates">convert.dates</code></td>
<td>
<p>if <code>TRUE</code> (the default) then Stata dates are converted to R dates.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="readstata13.html#topic+read.dta13">read.dta13</a></code>
</p>

<hr>
<h2 id='readXL'>
Read an Excel File
</h2><span id='topic+readXL'></span><span id='topic+excel_sheets'></span>

<h3>Description</h3>

<p><code>readXL</code> reads an Excel file, either of type <code>.xls</code> or <code>.xlsx</code> into an R data frame; it provides
a front end to the <code><a href="readxl.html#topic+read_excel">read_excel</a></code> function in the <span class="pkg">readxl</span> package.
<code><a href="readxl.html#topic+excel_sheets">excel_sheets</a></code> is re-exported from the <span class="pkg">readxl</span> package and reports the
names of spreadsheets in an Excel file.</p>


<h3>Usage</h3>

<pre><code class='language-R'>readXL(file, rownames = FALSE, header = TRUE, na = "", sheet = 1, 
  stringsAsFactors = FALSE)
  
excel_sheets(path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="readXL_+3A_file">file</code>, <code id="readXL_+3A_path">path</code></td>
<td>
<p>path to an Excel file.</p>
</td></tr>
<tr><td><code id="readXL_+3A_rownames">rownames</code></td>
<td>
<p>if <code>TRUE</code> (the default is <code>FALSE</code>), the first column in the
spreadsheet contains row names (which must be unique&mdash;i.e., no duplicates).</p>
</td></tr>
<tr><td><code id="readXL_+3A_header">header</code></td>
<td>
<p>if <code>TRUE</code> (the default), the first row in the spreadsheet contains column
(variable) names.</p>
</td></tr>
<tr><td><code id="readXL_+3A_na">na</code></td>
<td>
<p>character string denoting missing data; the default is the empty string, <code>""</code>.</p>
</td></tr>
<tr><td><code id="readXL_+3A_sheet">sheet</code></td>
<td>
<p>number of the spreadsheet in the file containing the data to be read; the
default is <code>1</code>.</p>
</td></tr>
<tr><td><code id="readXL_+3A_stringsasfactors">stringsAsFactors</code></td>
<td>
<p>if <code>TRUE</code> (the default is <code>FALSE</code>) then columns containing character data are converted to
factors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="readxl.html#topic+read_excel">read_excel</a></code>, <code><a href="readxl.html#topic+excel_sheets">excel_sheets</a></code>
</p>

<hr>
<h2 id='reliability'>Reliability of a Composite Scale</h2><span id='topic+reliability'></span><span id='topic+print.reliability'></span>

<h3>Description</h3>

<p>Calculates Cronbach's alpha and standardized alpha (lower bounds on reliability)
for a composite (summated-rating) scale. Standardized alpha is for the sum of the
standardized items. In addition, the function calculates alpha and standardized
alpha for the scale with each item deleted in turn, and computes the correlation
between each item and the sum of the other items.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reliability(S)

## S3 method for class 'reliability'
print(x, digits=4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reliability_+3A_s">S</code></td>
<td>
<p>the covariance matrix of the items; normally, there should be at least 3 items
and certainly no fewer than 2.</p>
</td></tr>
<tr><td><code id="reliability_+3A_x">x</code></td>
<td>
<p>reliability object to be printed.</p>
</td></tr>
<tr><td><code id="reliability_+3A_digits">digits</code></td>
<td>
<p>number of decimal places.</p>
</td></tr>
<tr><td><code id="reliability_+3A_...">...</code></td>
<td>
<p>not used: for compatibility with the print generic.&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class reliability, which normally would be printed.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>References</h3>

<p>N. Cliff (1986) Psychological testing theory. Pp. 343&ndash;349 in
S. Kotz and N. Johnson, eds., <em>Encyclopedia of Statistical Sciences, Vol. 7</em>.
Wiley.</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+cov">cov</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(car)){
    data(DavisThin)
    reliability(cov(DavisThin))
}
</code></pre>

<hr>
<h2 id='repeatedMeasuresPlot'>
Plot Means for Repeated-Measures ANOVA Designs
</h2><span id='topic+repeatedMeasuresPlot'></span>

<h3>Description</h3>

<p>Creates a means plot for a repeated-measures ANOVA design with one or two within-subjects factor and zero or more between-subjects factors, for data in &quot;wide&quot; format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>repeatedMeasuresPlot(data, within, within.names, within.levels, 
    between.names = NULL, response.name = "score", trace, xvar, 
    pch=15:25, lty=1:6, col=palette()[-1], 
    plot.means=TRUE, print.tables = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="repeatedMeasuresPlot_+3A_data">data</code></td>
<td>
<p>a data frame in wide format.</p>
</td></tr>
<tr><td><code id="repeatedMeasuresPlot_+3A_within">within</code></td>
<td>
<p>a character vector with the names of the data columns containing the repeated measures.</p>
</td></tr>
<tr><td><code id="repeatedMeasuresPlot_+3A_within.names">within.names</code></td>
<td>
<p>a character vector with one or two elements, of names of the within-subjects factor(s).</p>
</td></tr>
<tr><td><code id="repeatedMeasuresPlot_+3A_within.levels">within.levels</code></td>
<td>
<p>a named list whose elements are character vectors of level names for the within-subjects factors, with names corresponding to the names of the within-subjects factors; the product of the numbers of levels should be equal to the number of repeated-measures columns in <code>within</code>.</p>
</td></tr>
<tr><td><code id="repeatedMeasuresPlot_+3A_between.names">between.names</code></td>
<td>
<p>a column vector of names of the between-subjects factors (if any).</p>
</td></tr>
<tr><td><code id="repeatedMeasuresPlot_+3A_response.name">response.name</code></td>
<td>
<p>optional quoted name for the response variable, defaults to <code>"score"</code>.</p>
</td></tr>
<tr><td><code id="repeatedMeasuresPlot_+3A_trace">trace</code></td>
<td>
<p>optional quoted name of the (either within- or between-subjects) factor to define profiles of means in each panel of the graph; the default is the within-subjects factor with the smaller number of levels, if there are two, or not used if there is one.</p>
</td></tr>
<tr><td><code id="repeatedMeasuresPlot_+3A_xvar">xvar</code></td>
<td>
<p>optional quoted name of the factor to define the horizontal axis of each panel; the default is the within-subjects factor with the larger number of levels.</p>
</td></tr>
<tr><td><code id="repeatedMeasuresPlot_+3A_pch">pch</code>, <code id="repeatedMeasuresPlot_+3A_lty">lty</code></td>
<td>
<p>vectors of symbol and line-type numbers to use for the profiles of means (i.e., levels of the <code>trace</code> factor); for the meaning of the defaults, see <code><a href="graphics.html#topic+points">points</a></code> and <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="repeatedMeasuresPlot_+3A_col">col</code></td>
<td>
<p>vector of colors for the profiles of means; the default is given by <code>palette()</code>, starting at the second color.</p>
</td></tr>
<tr><td><code id="repeatedMeasuresPlot_+3A_plot.means">plot.means</code></td>
<td>
<p>if <code>TRUE</code> (the default), draw a plot of means by the factors.</p>
</td></tr>
<tr><td><code id="repeatedMeasuresPlot_+3A_print.tables">print.tables</code></td>
<td>
<p>if <code>TRUE</code> (the default is <code>FALSE</code>), print tables of means
and standard deviations of the response by the factors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>"trellis"</code> object, which normally is just &quot;printed&quot; (i.e., plotted).</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a>
</p>


<h3>See Also</h3>

<p><code><a href="car.html#topic+Anova">Anova</a></code>, <code><a href="carData.html#topic+OBrienKaiser">OBrienKaiser</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(carData)){
repeatedMeasuresPlot(
  data=OBrienKaiser, 
  within=c("pre.1", "pre.2", "pre.3", "pre.4", "pre.5",
          "post.1", "post.2", "post.3", "post.4", "post.5",
          "fup.1", "fup.2", "fup.3", "fup.4", "fup.5"), 
  within.names=c("phase", "hour"), 
  within.levels=list(phase=c("pre", "post", "fup"),
                    hour = c("1", "2", "3", "4", "5")),
  between.names=c("gender", "treatment"),
  response.name="improvement",
  print.tables=TRUE)
}

if (require(carData)){
repeatedMeasuresPlot(data=OBrienKaiser, 
  within=c("pre.1", "pre.2", "pre.3", "pre.4", "pre.5",
          "post.1", "post.2", "post.3", "post.4", "post.5",
          "fup.1", "fup.2", "fup.3", "fup.4", "fup.5"), 
  within.names=c("phase", "hour"), 
  within.levels=list(phase=c("pre", "post", "fup"),
                    hour = c("1", "2", "3", "4", "5")),
  between.names=c("gender", "treatment"),
  trace="gender") # note that gender is between subjects
}

if (require(carData)){
repeatedMeasuresPlot(
  data=OBrienKaiser, 
  within=c("fup.1", "fup.2", "fup.3", "fup.4", "fup.5"), 
  within.names="hour", 
  within.levels=list(hour = c("1", "2", "3", "4", "5")),
  between.names=c("treatment", "gender"),
  response.name="improvement")
}
</code></pre>

<hr>
<h2 id='reshapeL2W'>
Reshape Repeated-Measures Data from Long to Wide Format
</h2><span id='topic+reshapeL2W'></span>

<h3>Description</h3>

<p>A simple front-end to the standard R <code><a href="stats.html#topic+reshape">reshape</a></code> function. The data are assumed to be in &quot;long&quot; format, with several rows for each subject. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reshapeL2W(data, within, id, varying, ignore)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reshapeL2W_+3A_data">data</code></td>
<td>
<p>a data frame in long format.</p>
</td></tr>
<tr><td><code id="reshapeL2W_+3A_within">within</code></td>
<td>
<p>a character vector of names of the within-subjects factors in the long form of the data; there must be at least one within-subjects factor.</p>
</td></tr>
<tr><td><code id="reshapeL2W_+3A_id">id</code></td>
<td>
<p>the (character) name of the variable representing the subject identifier in the long form of the data set; that is, rows with the same <code>id</code> belong to the same subject.</p>
</td></tr>
<tr><td><code id="reshapeL2W_+3A_varying">varying</code></td>
<td>
<p>a character vector of names of the occasion-varying variables in the long form of the data; there must be at least one such variable, and typically there will be just one, an occasion-varying response variable.</p>
</td></tr>
<tr><td><code id="reshapeL2W_+3A_ignore">ignore</code></td>
<td>
<p>an optional character vector of names of variables in the long form of the data to exclude from the wide data set.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Between-subjects variables don't vary by occasions for each subject. Variables that aren't listed explicitly in the arguments to the function are assumed to be between-subjects variables, and a warning is printed if their values aren't invariant for each subject (see the <code>ignore</code> argument). 
</p>
<p>Within-subjects factors vary by occasions for each subject, and it is assumed that the within-subjects design is regular, completely crossed, and balanced, so that the same combinations of within-subjects factors are observed for each subject. 
</p>
<p>Occasion-varying variables, as their name implies, (potentially) vary by occasions for each subject, and include one or more &quot;response&quot; variables, possibly along with occasion-varying covariates; these variables can be factors as well as numeric variables. 
</p>
<p>The data are reshaped so that there is one row per subject, with columns for the between-subjects variables, and each occasion-varying variable as multiple columns representing the combinations of levels of the within-subjects factors. The names of the columns for the occasion-varying variables are composed from the combinations of levels of the within-subjects factors and from the names of the occasion-varying variables.  If a subject in the long form of the data set lacks any combination of levels of within-subjects factors, he or she is excluded (with a warning) from the wide form of the data.
</p>


<h3>Value</h3>

<p>a data frame in &quot;wide&quot; format, with one row for each subject, columns representing the between subjects factors, and columns for the occasion-varying variable(s) for each combination of within-subjects factors.</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+reshape">reshape</a></code>, <code><a href="carData.html#topic+OBrienKaiser">OBrienKaiser</a></code>, <code><a href="carData.html#topic+OBrienKaiserLong">OBrienKaiserLong</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(carData)){
  OBW &lt;- reshapeL2W(OBrienKaiserLong,
                    within=c("phase", "hour"), 
                    id="id", varying="score")
  brief(OBW)
  # should be the same as OBrienKaiser in the carData package:
  all.equal(OBrienKaiser, OBW, check.attributes=FALSE)
}
</code></pre>

<hr>
<h2 id='reshapeW2L'>
Reshape Repeated-Measures Data from Wide to Long Format
</h2><span id='topic+reshapeW2L'></span>

<h3>Description</h3>

<p>The data are assumed to be in &quot;wide&quot; format, with a single row for each subject, and different columns for values of one or more repeated-measures variables classified by one or more within-subjects factors.</p>


<h3>Usage</h3>

<pre><code class='language-R'>reshapeW2L(data, within, levels, varying, ignore, id = "id")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reshapeW2L_+3A_data">data</code></td>
<td>
<p>wide version of data set.</p>
</td></tr>
<tr><td><code id="reshapeW2L_+3A_within">within</code></td>
<td>
<p>a character vector of names for the crossed within-subjects factors to be created in the long form of the data.</p>
</td></tr>
<tr><td><code id="reshapeW2L_+3A_levels">levels</code></td>
<td>
<p>a named list of character vectors, each element giving the names of the levels for a within-subjects factor; the names of the list elements are the names of the within-subjects factor, given in the <code>within</code> argument.</p>
</td></tr>
<tr><td><code id="reshapeW2L_+3A_varying">varying</code></td>
<td>
<p>a named list of the names of variables in the wide data set specifying the occasion-varying variables to be created in the long data set; each element in the list is named for an occasion-varying variable and is a character vector of column names in the wide data for that occasion-varying variable.</p>
</td></tr>
<tr><td><code id="reshapeW2L_+3A_ignore">ignore</code></td>
<td>
<p>a character vector of names of variables in the wide data to be dropped in the long form of the data.</p>
</td></tr>
<tr><td><code id="reshapeW2L_+3A_id">id</code></td>
<td>
<p>the (character) name of the subject ID variable to be created in the long form of the data, default <code>"id"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Between-subjects variables don't vary by occasions for each subject. Variables that aren't listed explicitly in the arguments to the function are assumed to be between-subjects variables. The values of these variables are duplicated in each row pertaining to a given subject.
</p>
<p>Within-subjects factors vary by occasions for each subject, and it is assumed that the within-subjects design is regular, completely crossed, and balanced, so that the same combinations of within-subjects factors are observed for each subject. There are typically one or two within-subject factors.
</p>
<p>Occasion-varying variables, as their name implies, (potentially) vary by occasions for each subject, and include one or more &quot;response&quot; variables, possibly along with occasion-varying covariates; these variables can be factors as well as numeric variables. Each occasion-varying variable is encoded in multiple columns of the wide form of the data and in a single column in the long form. There is typically one occasion-varying variable, a response variable.
</p>
<p>There is one value of each occasion-varying variable for each combination of levels of the within-subjects factors. Thus, the number of variables in the wide data for each occasion-varying variable must be equal to the product of levels of the within-subjects factors, with the levels of the within-subjects factors varying most quickly from right to left in the 
<code>within</code> argument.
</p>


<h3>Value</h3>

<p>a data frame in &quot;long&quot; format, with multiple rows for each subject (equal to the number of combinations of levels of the within-subject factors) and one column for each between-subjects and occasion-varying variable.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+reshapeL2W">reshapeL2W</a></code>, <code><a href="stats.html#topic+reshape">reshape</a></code>, <code><a href="carData.html#topic+OBrienKaiser">OBrienKaiser</a></code>, <code><a href="carData.html#topic+OBrienKaiserLong">OBrienKaiserLong</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>if (require(carData)){
  OBrienKaiserL &lt;- reshapeW2L(OBrienKaiser, within=c("phase", "hour"), 
        levels=list(phase=c("pre", "post", "fup"), hour=1:5),
        varying=list(score=c("pre.1", "pre.2", "pre.3", "pre.4", "pre.5", 
                  "post.1", "post.2", "post.3", "post.4", "post.5", 
                  "fup.1", "fup.2", "fup.3", "fup.4", "fup.5")))
  brief(OBrienKaiserL, c(15, 15))
  m1 &lt;- Tapply(score ~ phase + hour + treatment + gender, mean, data=OBrienKaiserL)
  m2 &lt;- Tapply(score ~ phase + hour + treatment + gender, mean, data=OBrienKaiserLong)
  all.equal(m1, m2) # should be equal
}

if (require(carData)){
  OBrienKaiserL2 &lt;- reshapeW2L(OBrienKaiser, within="phase", 
                  levels=list(phase=c("pre", "post", "fup")),
                  ignore=c("pre.2", "pre.3", "pre.4", "pre.5", 
                           "post.2", "post.3", "post.4", "post.5", 
                           "fup.2", "fup.3", "fup.4", "fup.5"),
                  varying=list(score=c("pre.1", "post.1", "fup.1")))
  brief(OBrienKaiserL2, c(6, 6))
  m1 &lt;- Tapply(score ~ phase + treatment + gender, mean, data=OBrienKaiserL2)
  m2 &lt;- Tapply(score ~ phase + treatment + gender, mean, 
               data=subset(OBrienKaiserLong, hour==1))
  all.equal(m1, m2) # should be equal
}
</code></pre>

<hr>
<h2 id='stepwise'>
Stepwise Model Selection
</h2><span id='topic+stepwise'></span>

<h3>Description</h3>

<p>This function is a front end to the <code><a href="MASS.html#topic+stepAIC">stepAIC</a></code> function in the
<span class="pkg">MASS</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stepwise(mod, 
    direction = c("backward/forward", "forward/backward", "backward", "forward"), 
    criterion = c("BIC", "AIC"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stepwise_+3A_mod">mod</code></td>
<td>
<p>a model object of a class that can be handled by <code>stepAIC</code>.</p>
</td></tr>
<tr><td><code id="stepwise_+3A_direction">direction</code></td>
<td>
<p>if <code>"backward/forward"</code> (the default), selection starts with
the full model and eliminates predictors one at a time, at each step considering whether the
criterion will be improved by adding back in a variable removed at a previous step;
if <code>"forward/backwards"</code>, selection starts with a model including only a constant,
and adds predictors one at a time, at each step considering whether the criterion
will be improved by removing a previously added variable; <code>"backwards"</code> and 
<code>"forward"</code> are similar without the reconsideration at each step.</p>
</td></tr>
<tr><td><code id="stepwise_+3A_criterion">criterion</code></td>
<td>
<p>for selection. Either <code>"BIC"</code> (the default) or <code>"AIC"</code>. Note that
<code>stepAIC</code> labels the criterion in the output as <code>"AIC"</code> regardless of which
criterion is employed.</p>
</td></tr>
<tr><td><code id="stepwise_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code>stepAIC</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The model selected by <code>stepAIC</code>.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>References</h3>

<p>W. N. Venables and B. D. Ripley
<em>Modern Applied Statistics Statistics with S, Fourth Edition</em>
Springer, 2002.
</p>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+stepAIC">stepAIC</a></code></p>


<h3>Examples</h3>

<pre><code class='language-R'># adapted from ?stepAIC in MASS
if (require(MASS)){
data(birthwt)
bwt &lt;- with(birthwt, {
    race &lt;- factor(race, labels = c("white", "black", "other"))
    ptd &lt;- factor(ptl &gt; 0)
    ftv &lt;- factor(ftv)
    levels(ftv)[-(1:2)] &lt;- "2+"
    data.frame(low = factor(low), age, lwt, race, smoke = (smoke &gt; 0),
               ptd, ht = (ht &gt; 0), ui = (ui &gt; 0), ftv)
})
birthwt.glm &lt;- glm(low ~ ., family = binomial, data = bwt)
print(stepwise(birthwt.glm, trace = FALSE))
print(stepwise(birthwt.glm, direction="forward/backward"))
}
</code></pre>

<hr>
<h2 id='summarySandwich'>Linear Model Summary with Sandwich Standard Errors</h2><span id='topic+summarySandwich'></span><span id='topic+summarySandwich.lm'></span>

<h3>Description</h3>

<p><code>summarySandwich</code> creates a summary of a <code>"lm"</code> object similar to the standard one,
with sandwich estimates of the coefficient standard errors in the place of the usual OLS standard errors,
also modifying as a consequence the reported t-tests and p-values for the coefficients.
Standard errors may be computed from a heteroscedasticity-consistent (&quot;HC&quot;) covariance matrix for the
coefficients (of several varieties), or from a heteroscedasticity-and-autocorrelation-consistent  (&quot;HAC&quot;) covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>summarySandwich(model, ...)
    
## S3 method for class 'lm'
summarySandwich(model, 
  type=c("hc3", "hc0", "hc1", "hc2", "hc4", "hac"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summarySandwich_+3A_model">model</code></td>
<td>
<p>a linear-model object.</p>
</td></tr>
<tr><td><code id="summarySandwich_+3A_type">type</code></td>
<td>
<p>type of sandwich standard errors to be computed; see <code><a href="car.html#topic+hccm">hccm</a></code>
in the <span class="pkg">car</span> package, and <code><a href="sandwich.html#topic+vcovHAC">vcovHAC</a></code> in the <span class="pkg">sandwich</span> package, for details.</p>
</td></tr>
<tr><td><code id="summarySandwich_+3A_...">...</code></td>
<td>
<p>arguments to be passed to <code>hccm</code> or <code>vcovHAC</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>an object of class <code>"summary.lm"</code>, with sandwich standard errors substituted for the
usual OLS standard errors; the omnibus F-test is similarly adjusted.
</p>


<h3>Author(s)</h3>

<p>John Fox <a href="mailto:jfox@mcmaster.ca">jfox@mcmaster.ca</a></p>


<h3>See Also</h3>

<p><code><a href="car.html#topic+hccm">hccm</a></code>, <code><a href="sandwich.html#topic+vcovHAC">vcovHAC</a></code>.</p>


<h3>Examples</h3>

<pre><code class='language-R'>    mod &lt;- lm(prestige ~ income + education + type, data=Prestige)
    summary(mod)
    summarySandwich(mod)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
