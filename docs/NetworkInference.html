<!DOCTYPE html><html><head><title>Help for package NetworkInference</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {NetworkInference}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#as_cascade_long'><p>Transform long data to cascade</p></a></li>
<li><a href='#as_cascade_wide'><p>Transform wide data to cascade</p></a></li>
<li><a href='#as.data.frame.cascade'><p>Convert a cascade object to a data frame</p></a></li>
<li><a href='#as.matrix.cascade'><p>Convert a cascade object to a matrix</p></a></li>
<li><a href='#cascades'><p>Example cascades</p></a></li>
<li><a href='#count_possible_edges'><p>Count the number of possible edges in the dataset</p></a></li>
<li><a href='#drop_nodes'><p>Drop nodes from a cascade object</p></a></li>
<li><a href='#is.cascade'><p>Is the object of class cascade?</p></a></li>
<li><a href='#is.diffnet'><p>Is the object of class diffnet?</p></a></li>
<li><a href='#netinf'><p>Infer latent diffusion network</p></a></li>
<li><a href='#NetworkInference'><p>NetworkInference: Inferring latent diffusion networks</p></a></li>
<li><a href='#plot.cascade'><p>Plot a cascade object</p></a></li>
<li><a href='#plot.diffnet'><p>Visualize netinf output</p></a></li>
<li><a href='#policies'><p>US State Policy Adoption (SPID)</p></a></li>
<li><a href='#sim_validation'><p>Larger simulated validation network.</p></a></li>
<li><a href='#simulate_cascades'><p>Simulate cascades from a diffusion network</p></a></li>
<li><a href='#simulate_rnd_cascades'><p>Simulate a set of random cascades</p></a></li>
<li><a href='#subset_cascade'><p>Select a subset of cascades from cascade object</p></a></li>
<li><a href='#subset_cascade_time'><p>Subset a cascade object in time</p></a></li>
<li><a href='#summary.cascade'><p>Summarize a cascade object</p></a></li>
<li><a href='#validation'><p>Validation output from netinf source.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Inferring Latent Diffusion Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2019-02-27</td>
</tr>
<tr>
<td>Description:</td>
<td>This is an R implementation of the netinf algorithm (Gomez Rodriguez, Leskovec, and Krause, 2010)&lt;<a href="https://doi.org/10.1145%2F1835804.1835933">doi:10.1145/1835804.1835933</a>&gt;. Given a set of events that spread between a set of nodes the algorithm infers the most likely stable diffusion network that is underlying the diffusion process.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.5), assertthat, checkmate, ggplot2, ggrepel,
stats</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppProgress</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/desmarais-lab/NetworkInference/issues">https://github.com/desmarais-lab/NetworkInference/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, knitr, rmarkdown, pander, igraph, utils, dplyr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++11</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2019-02-28 03:27:18 UTC; fridolinlinder</td>
</tr>
<tr>
<td>Author:</td>
<td>Fridolin Linder [aut, cre],
  Bruce Desmarais [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Fridolin Linder &lt;fridolin.linder@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2019-02-28 05:50:06 UTC</td>
</tr>
</table>
<hr>
<h2 id='as_cascade_long'>Transform long data to cascade</h2><span id='topic+as_cascade_long'></span>

<h3>Description</h3>

<p>Create a cascade object from data in long format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_cascade_long(data, cascade_node_name = "node_name",
  event_time = "event_time", cascade_id = "cascade_id",
  node_names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_cascade_long_+3A_data">data</code></td>
<td>
<p><a href="base.html#topic+data.frame">data.frame</a>, containing the cascade data 
with column names corresponding to the arguments provided to 
<code>cascade_node_names</code>, <code>event_time</code> and <code>cascade_id</code>.</p>
</td></tr>
<tr><td><code id="as_cascade_long_+3A_cascade_node_name">cascade_node_name</code></td>
<td>
<p>character, column name of <code>data</code> that specifies 
the node names in the cascade.</p>
</td></tr>
<tr><td><code id="as_cascade_long_+3A_event_time">event_time</code></td>
<td>
<p>character, column name of <code>data</code> that specifies the 
event times for each node involved in a cascade.</p>
</td></tr>
<tr><td><code id="as_cascade_long_+3A_cascade_id">cascade_id</code></td>
<td>
<p>character, column name of the cascade identifier.</p>
</td></tr>
<tr><td><code id="as_cascade_long_+3A_node_names">node_names</code></td>
<td>
<p>character, factor or numeric vector containing the names for each node. 
Optional. If not provided, node names are inferred from the cascade data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Each row of the data describes one event in the cascade. The data must 
contain at least three columns:
</p>

<ol>
<li><p> Cascade node name: The identifier of the node that experiences the 
event.
</p>
</li>
<li><p> Event time: The time when the node experiences the event. Note that
if the time column is of class date or any other special time class, 
it will be converted to an integer with 'as.numeric()'. 
</p>
</li>
<li><p> Cascade id: The identifier of the cascade that the event pertains to.
</p>
</li></ol>

<p>The default names for these columns are <code>node_name</code>, <code>event_time</code> 
and <code>cascade_id</code>. If other names are used in the <code>data</code> object the 
names have to be specified in the corresponding arguments (see argument 
documentation)
</p>


<h3>Value</h3>

<p>An object of class <code>cascade</code>. This is a list containing three
(named) elements: 
</p>

<ol>
<li> <p><code>"node_names"</code> A character vector of node names.
</p>
</li>
<li> <p><code>"cascade_nodes"</code> A list with one character vector per
cascade containing the node names in order of the events.
</p>
</li>
<li> <p><code>"cascade_times"</code> A list with one element per cascade 
containing the event times for the nodes in <code>"cascade_names"</code>.
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- simulate_rnd_cascades(10, n_nodes = 20)
cascades &lt;- as_cascade_long(df)
is.cascade(cascades)
</code></pre>

<hr>
<h2 id='as_cascade_wide'>Transform wide data to cascade</h2><span id='topic+as_cascade_wide'></span>

<h3>Description</h3>

<p>Create a cascade object from data in wide format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>as_cascade_wide(data, node_names = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as_cascade_wide_+3A_data">data</code></td>
<td>
<p><a href="base.html#topic+data.frame">data.frame</a> or <a href="base.html#topic+matrix">matrix</a>, rows corresponding to nodes, 
columns to cascades. Matrix entries are the event times for each node, 
cascade pair. Missing values indicate censored observations, that is, 
nodes that did not have an event). Specify column and row names if 
cascade and node ids other than integer sequences are  desired. Note that, 
if the time column is of class date or any other special time class, it 
will be converted to an integer with 'as.numeric()'.</p>
</td></tr>
<tr><td><code id="as_cascade_wide_+3A_node_names">node_names</code></td>
<td>
<p>character, factor or numeric vector, containing names for each node. 
Optional. If not provided, node names are inferred from the provided data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If data is in wide format, each row corresponds to a node and each column to
a cascade. Each cell indicates the event time for a node - cascade 
combination. If a node did not experience an event for a cascade (the node
is censored) the cell entry must be <code>NA</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>cascade</code>. This is a list containing three
(named) elements: 
</p>

<ol>
<li> <p><code>"node_names"</code> A character vector of node names.
</p>
</li>
<li> <p><code>"cascade_nodes"</code> A list with one character vector per
cascade containing the node names in order of the events.
</p>
</li>
<li> <p><code>"cascade_times"</code> A list with one element per cascade 
containing the event times for the nodes in <code>"cascade_names"</code>.
</p>
</li></ol>



<h3>Examples</h3>

<pre><code class='language-R'>
data("policies")
cascades &lt;- as_cascade_long(policies, cascade_node_name = 'statenam', 
                            event_time = 'adopt_year', cascade_id = 'policy')
wide_policies = as.matrix(cascades)
cascades &lt;- as_cascade_wide(wide_policies)
is.cascade(cascades)

</code></pre>

<hr>
<h2 id='as.data.frame.cascade'>Convert a cascade object to a data frame</h2><span id='topic+as.data.frame.cascade'></span>

<h3>Description</h3>

<p>Generates a data frame containing the cascade information in the cascade object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cascade'
as.data.frame(x, row.names = NULL, optional = FALSE,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.data.frame.cascade_+3A_x">x</code></td>
<td>
<p>Cascade object to convert.</p>
</td></tr>
<tr><td><code id="as.data.frame.cascade_+3A_row.names">row.names</code></td>
<td>
<p>NULL or a character vector giving the row names for the data 
frame. Missing values are not allowed.</p>
</td></tr>
<tr><td><code id="as.data.frame.cascade_+3A_optional">optional</code></td>
<td>
<p>logical. If TRUE, setting row names and converting column 
names (to syntactic names: see make.names) is optional. (Not supported)</p>
</td></tr>
<tr><td><code id="as.data.frame.cascade_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to <code><a href="base.html#topic+data.frame">data.frame</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with three columns. Containing 1) The names of 
the nodes (<code>"node_name"</code>) that experience an event in each cascade, 
2) the event time (<code>"event_time"</code>) of the corresponding node, 
3) the cascade identifier <code>"cascade_id"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(cascades)
as.data.frame(cascades)

</code></pre>

<hr>
<h2 id='as.matrix.cascade'>Convert a cascade object to a matrix</h2><span id='topic+as.matrix.cascade'></span>

<h3>Description</h3>

<p>Generates a <code><a href="base.html#topic+matrix">matrix</a></code> containing the cascade information in the 
cascade object in wide format. Missing values are used for nodes that do not 
experience an event in a cascade.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cascade'
as.matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="as.matrix.cascade_+3A_x">x</code></td>
<td>
<p>cascade object to convert.</p>
</td></tr>
<tr><td><code id="as.matrix.cascade_+3A_...">...</code></td>
<td>
<p>additional arguments to be passed to or from methods. 
(Currently not supported.)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing all cascade information in wide format. That is,
each row of the matrix corresponds to a node and each column to a cascade. 
Cell entries are event times. Censored nodes have <code>NA</code> for their entry.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(cascades) 
as.matrix(cascades)

</code></pre>

<hr>
<h2 id='cascades'>Example cascades</h2><span id='topic+cascades'></span>

<h3>Description</h3>

<p>An example dataset of 31 nodes and 54 cascades. From the original netinf 
implementation in SNAP.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(cascades)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>cascade</code> containing 4 objects
</p>

<dl>
<dt>node_names</dt><dd><p>Character node names</p>
</dd>
<dt>cascade_nodes</dt><dd><p>A list of integer vectors. Each containing the names of the
nodes infected in this cascades in the order of infection</p>
</dd>
<dt>cascade_times</dt><dd><p>A list of numeric vectors. Each containing the infection
times for the corresponding nodes in cascade_nodes</p>
</dd>
</dl>


<h3>Source</h3>

<p><a href="https://github.com/snap-stanford/snap/blob/master/examples/netinf/example-cascades.txt">https://github.com/snap-stanford/snap/blob/master/examples/netinf/example-cascades.txt</a>
</p>

<hr>
<h2 id='count_possible_edges'>Count the number of possible edges in the dataset</h2><span id='topic+count_possible_edges'></span>

<h3>Description</h3>

<p>Across all cascades, count the edges that are possible. An edge from node
<code>u</code> to node <code>v</code>
is only possible if in at least one cascade <code>u</code> experienced an event 
before <code>v</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>count_possible_edges(cascades)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="count_possible_edges_+3A_cascades">cascades</code></td>
<td>
<p>Object of class cascade containing the data.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer count.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cascades)
count_possible_edges(cascades)

</code></pre>

<hr>
<h2 id='drop_nodes'>Drop nodes from a cascade object</h2><span id='topic+drop_nodes'></span>

<h3>Description</h3>

<p>Drop nodes from a cascade object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drop_nodes(cascades, nodes, drop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drop_nodes_+3A_cascades">cascades</code></td>
<td>
<p>cascade, object to drop nodes from.</p>
</td></tr>
<tr><td><code id="drop_nodes_+3A_nodes">nodes</code></td>
<td>
<p>character or integer, vector of node_ids to drop.</p>
</td></tr>
<tr><td><code id="drop_nodes_+3A_drop">drop</code></td>
<td>
<p>logical, Should empty cascades be dropped.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class cascade containing the cascades without the 
dropped nodes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(policies)
cascades &lt;- as_cascade_long(policies, cascade_node_name = 'statenam', 
                            event_time = 'adopt_year', cascade_id = 'policy')
new_cascades &lt;- drop_nodes(cascades, c("California", "New York"))

</code></pre>

<hr>
<h2 id='is.cascade'>Is the object of class cascade?</h2><span id='topic+is.cascade'></span>

<h3>Description</h3>

<p>Is the object of class cascade?
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.cascade(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.cascade_+3A_object">object</code></td>
<td>
<p>the object to be tested.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if object is a cascade, <code>FALSE</code> otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(cascades)
is.cascade(cascades)
# &gt; TRUE
is.cascade(1) 
# &gt; FALSE
</code></pre>

<hr>
<h2 id='is.diffnet'>Is the object of class diffnet?</h2><span id='topic+is.diffnet'></span>

<h3>Description</h3>

<p>Tests if an object is of class diffnet. The class diffnet is appended to the 
object returned by <code><a href="#topic+netinf">netinf</a></code> for dispatch of appropriate plotting 
methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.diffnet(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.diffnet_+3A_object">object</code></td>
<td>
<p>the object to be tested.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>TRUE</code> if object is a diffnet, <code>FALSE</code> otherwise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(cascades)
result &lt;- netinf(cascades, n_edges = 6, params = 1)
is.diffnet(result)
</code></pre>

<hr>
<h2 id='netinf'>Infer latent diffusion network</h2><span id='topic+netinf'></span>

<h3>Description</h3>

<p>Infer a network of diffusion ties from a set of cascades. Each cascade 
is defined by pairs of node ids and infection times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>netinf(cascades, trans_mod = "exponential", n_edges = NULL,
  p_value_cutoff = NULL, params = NULL, quiet = FALSE,
  trees = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="netinf_+3A_cascades">cascades</code></td>
<td>
<p>an object of class cascade containing node and cascade 
information. See <code><a href="#topic+as_cascade_long">as_cascade_long</a></code> and 
<code><a href="#topic+as_cascade_wide">as_cascade_wide</a></code> for details.</p>
</td></tr>
<tr><td><code id="netinf_+3A_trans_mod">trans_mod</code></td>
<td>
<p>character, indicating the choice of model: 
<code>"exponential"</code>, <code>"rayleigh"</code> or <code>"log-normal"</code>.</p>
</td></tr>
<tr><td><code id="netinf_+3A_n_edges">n_edges</code></td>
<td>
<p>integer, number of edges to infer. Leave unspecified if using 
<code>p_value_cutoff</code>.</p>
</td></tr>
<tr><td><code id="netinf_+3A_p_value_cutoff">p_value_cutoff</code></td>
<td>
<p>numeric, in the interval (0, 1). If 
specified, edges are inferred in each iteration until the Vuong test for 
edge addition reaches the p-value cutoff or when the maximum 
possible number of edges is reached. Leave unspecified if using 
<code>n_edges</code> to explicitly specify number of edges to infer.</p>
</td></tr>
<tr><td><code id="netinf_+3A_params">params</code></td>
<td>
<p>numeric, Parameters for diffusion model. If left unspecified 
reasonable parameters are inferred from the data. See details for how to 
specify parameters for the different distributions.</p>
</td></tr>
<tr><td><code id="netinf_+3A_quiet">quiet</code></td>
<td>
<p>logical, Should output on progress by suppressed.</p>
</td></tr>
<tr><td><code id="netinf_+3A_trees">trees</code></td>
<td>
<p>logical, Should the inferred cascade trees be returned. Note, 
that this will lead to a different the structure of the function output. 
See section Value for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm is describe in detail in Gomez-Rodriguez et al. (2010). 
Additional information can be found on the 
netinf website (<a href="http://snap.stanford.edu/netinf/">http://snap.stanford.edu/netinf/</a>).
</p>

<ul>
<li><p> Exponential distribution: <code>trans_mod = "exponential"</code>,
<code>params = c(lambda)</code>. 
Parametrization: <code class="reqn">\lambda e^{-\lambda x}</code>.
</p>
</li>
<li><p> Rayleigh distribution: <code>trans_mod = "rayleigh"</code>,
<code>params = c(alpha)</code>. 
Parametrization: <code class="reqn">\frac{x}{\alpha^2} \frac{e^{-x^2}}{2\alpha^2}</code>.
</p>
</li>
<li><p> Log-normal distribution: <code>trans_mod = "log-normal"</code>,
<code>params = c(mu, sigma)</code>. 
Parametrization: <code class="reqn">\frac{1}{x\sigma\sqrt{2\pi}}e^{-\frac{(ln x - \mu)^2}{2\sigma^2}}</code>.
</p>
</li></ul>

<p>If higher performance is required and for very large data sets, a faster pure C++ 
implementation is available in the Stanford Network Analysis Project (SNAP). 
The software can be downloaded at <a href="http://snap.stanford.edu/netinf/">http://snap.stanford.edu/netinf/</a>.
</p>


<h3>Value</h3>

<p>Returns the inferred diffusion network as an edgelist in an object of 
class <code>diffnet</code> and <code><a href="base.html#topic+data.frame">data.frame</a></code>. The first 
column contains the sender, the second column the receiver node. The 
third column contains the improvement in fit from adding the edge that is
represented by the row. The output additionally has the following 
attributes:
</p>

<ul>
<li> <p><code>"diffusion_model"</code>: The diffusion model used to infer the 
diffusion network.
</p>
</li>
<li> <p><code>"diffusion_model_parameters"</code>: The parameters for the 
model that have been inferred by the approximate profile MLE 
procedure.
</p>
</li></ul>

<p>If the argument <code>trees</code> is set to <code>TRUE</code>, the output is a list
with the first element being the <code>data.frame</code> described above, and 
the second element being the trees in edge-list form in a single 
<code>data.frame</code>.
</p>


<h3>References</h3>

<p>M. Gomez-Rodriguez, J. Leskovec, A. Krause. Inferring Networks of Diffusion 
and Influence.The 16th ACM SIGKDD Conference on Knowledge Discovery and 
Data Mining (KDD), 2010.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Data already in cascades format:
data(cascades)
out &lt;- netinf(cascades, trans_mod = "exponential", n_edges = 5, params = 1)

# Starting with a dataframe
df &lt;- simulate_rnd_cascades(10, n_nodes = 20)
cascades2 &lt;- as_cascade_long(df, node_names = unique(df$node_name))
out &lt;- netinf(cascades2, trans_mod = "exponential", n_edges = 5, params = 1)

</code></pre>

<hr>
<h2 id='NetworkInference'>NetworkInference: Inferring latent diffusion networks</h2><span id='topic+NetworkInference'></span>

<h3>Description</h3>

<p>This package provides an R implementation of the <code>netinf</code> algorithm 
created by Gomez Rodriguez, Leskovec, and  Krause (2010). Given a set of
events that spread between a set of nodes the algorithm infers the most likely
stable diffusion network that is underlying the diffusion process.
</p>


<h3>Details</h3>

<p>The package provides three groups of functions: 1) data preparation 
2) estimation and 3) interpretation.
</p>


<h3>Data preparation</h3>

<p>The core estimation function <code><a href="#topic+netinf">netinf</a></code> requires an object of class 
<code>cascade</code> (see <a href="#topic+as_cascade_long">as_cascade_long</a> and <a href="#topic+as_cascade_wide">as_cascade_wide</a>). 
Cascade data contains information on the potential nodes in the network as 
well as on event times for each node in each cascade.
</p>


<h3>Estimation</h3>

<p>Diffusion networks are estimated using the <code><a href="#topic+netinf">netinf</a></code> function. It 
produces a diffusion network in form of an edgelist (of class 
<code><a href="base.html#topic+data.frame">data.frame</a></code>).
</p>


<h3>Interpretation and Visualization</h3>

<p>Cascade data can be visualized with the <code>plot</code> method of the <code>cascade</code>
class (<code>diffnet, <a href="#topic+plot.cascade">plot.cascade</a></code>). Results of the estimation process can 
be visualized using the plotting method of the <code>diffnet</code> class.
</p>


<h3>Performance</h3>

<p>If higher performance is required and for very large data sets, a faster pure C++ 
implementation is available in the Stanford Network Analysis Project (SNAP). 
The software can be downloaded at <a href="http://snap.stanford.edu/netinf/">http://snap.stanford.edu/netinf/</a>.
</p>

<hr>
<h2 id='plot.cascade'>Plot a cascade object</h2><span id='topic+plot.cascade'></span>

<h3>Description</h3>

<p>Allows plotting of one or multiple, labeled or unlabeled cascades.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cascade'
plot(x, label_nodes = TRUE, selection = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.cascade_+3A_x">x</code></td>
<td>
<p>object of class cascade to be plotted.</p>
</td></tr>
<tr><td><code id="plot.cascade_+3A_label_nodes">label_nodes</code></td>
<td>
<p>logical, indicating if should the nodes in each cascade be 
labeled. If the cascades are very dense setting this to <code>FALSE</code> is
recommended.</p>
</td></tr>
<tr><td><code id="plot.cascade_+3A_selection">selection</code></td>
<td>
<p>a vector of cascade ids to plot.</p>
</td></tr>
<tr><td><code id="plot.cascade_+3A_...">...</code></td>
<td>
<p>additional arguments passed to plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function returns a ggplot plot object (class <code>gg, ggplot</code>) which 
can be modified like any other ggplot. See the ggplot documentation and the 
examples below for more details.
</p>


<h3>Value</h3>

<p>A ggplot plot object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(cascades)
plot(cascades, selection = names(cascades$cascade_nodes)[1:5])
plot(cascades, label_nodes = FALSE, selection = sample(1:54, 20))

# Modify resulting ggplot object
library(ggplot2) 
p &lt;- plot(cascades, label_nodes = FALSE, selection = sample(1:54, 20))
## Add a title
p &lt;- p + ggtitle('Your Title')
p
## Change Axis
p &lt;- p + xlab("Your modified y axis label") #x and y labels are flipped here
p &lt;- p + ylab("Your modified x axis label") #x and y labels are flipped here
p

</code></pre>

<hr>
<h2 id='plot.diffnet'>Visualize netinf output</h2><span id='topic+plot.diffnet'></span>

<h3>Description</h3>

<p>Visualize the inferred diffusion network or the marginal gain in fit obtained
by addition of each edge.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'diffnet'
plot(x, type = "network", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.diffnet_+3A_x">x</code></td>
<td>
<p>object of class diffnet to be plotted.</p>
</td></tr>
<tr><td><code id="plot.diffnet_+3A_type">type</code></td>
<td>
<p>character, one of <code>c("network", "improvement", "p-value")</code> 
indicating if the inferred diffusion network, the 
improvement for each edge or the p-value from the vuong test for each
edge should be visualized .</p>
</td></tr>
<tr><td><code id="plot.diffnet_+3A_...">...</code></td>
<td>
<p>additional arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If 'type = improvement' a ggplot object is returned. It can be modified like
any other ggplot. See the ggplot documentation and the examples in 
<a href="#topic+plot.cascade">plot.cascade</a>.
</p>


<h3>Value</h3>

<p>A ggplot plot object if <code>type = "improvement"</code> otherwise an 
igraph plot.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
 data(cascades)
 res &lt;- netinf(cascades, quiet = TRUE)
 plot(res, type = "network")
 plot(res, type = "improvement")
 plot(res, type = "p-value")

## End(Not run)

</code></pre>

<hr>
<h2 id='policies'>US State Policy Adoption (SPID)</h2><span id='topic+policies'></span><span id='topic+policies_metadata'></span>

<h3>Description</h3>

<p>The SPID data includes information on the year of adoption for over 700 
policies in the American states.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(policies)
</code></pre>


<h3>Format</h3>

<p>The data comes in two objects of class <code>data.frame</code>. The first
object, named <code>policies</code> contains the adoption events. Each row 
corresponds to an adoption event. Each adoption event is described by 
the three columns: 
</p>

<ul>
<li> <p><code>statenam</code>: Name of the adopting state.
</p>
</li>
<li> <p><code>policy</code>: Name of the policy.
</p>
</li>
<li> <p><code>adopt_year</code>: Year when the state adopted the policy.
</p>
</li></ul>

<p>The second object (<code>policies_metadata</code>) contains more details on each
of the policies. It contains these columns:
</p>

<ul>
<li> <p><code>policy</code>: Name of the policy.
</p>
</li>
<li> <p><code>source</code>: Original source of the data.
</p>
</li>
<li> <p><code>first_year</code>: First year any state adopted this policy.
</p>
</li>
<li> <p><code>last_year</code>: Last year any state adopted this policy.
</p>
</li>
<li> <p><code>adopt_count</code>: Number of states that adopted this policy.
</p>
</li>
<li> <p><code>description</code>: Description of the policy.
</p>
</li>
<li> <p><code>majortopic</code>: Topic group the policy belongs to.
</p>
</li></ul>
 
<p>Both <code>data.frame</code> objects can be joined (merged) on the common column
<code>policy</code> (see example code).</p>


<h3>Details</h3>

<p>This version 1.0 of the database. For each policy we document the year of first 
adoption for each state. Adoption dates range from 1691 to 2017 and includes 
all fifty states. Policies are adopted by anywhere from 1 to 50 states, with 
an average of 24 adoptions. The data were assembled from a variety of sources, 
including academic publications and policy advocacy/information groups. 
Policies were coded according to the Policy Agendas Project major 
topic code. Additional information on policies is available at the source 
repository.
</p>


<h3>Source</h3>

<p><a href="https://doi.org/10.7910/DVN/CVYSR7">https://doi.org/10.7910/DVN/CVYSR7</a>
</p>


<h3>References</h3>

<p>Boehmke, Frederick J.; Mark Brockway; Bruce A. Desmarais; 
Jeffrey J. Harden; Scott LaCombe; Fridolin Linder; and 
Hanna Wallach. 2018. &quot;A New Database for Inferring Public Policy 
Innovativeness and Diffusion Networks.&quot; Working paper.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data('policies')

# Join the adoption events with the metadata 
merged_policies &lt;- merge(policies, policies_metadata, by = 'policy')
</code></pre>

<hr>
<h2 id='sim_validation'>Larger simulated validation network.</h2><span id='topic+sim_validation'></span>

<h3>Description</h3>

<p>A network from simulated data. For testing purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(sim_validation)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 4 columns, containing:
</p>

<dl>
<dt>origin_node</dt><dd><p>Origin of diffusion edge.</p>
</dd>
<dt>destination_node</dt><dd><p>Destination node of diffusion edge.</p>
</dd>
<dt>improvement</dt><dd><p>Improvement in score for the edge</p>
</dd>
<dt>p-value</dt><dd><p>p-value for vuong test</p>
</dd>
</dl>


<h3>Source</h3>

<p>See code below.
</p>

<hr>
<h2 id='simulate_cascades'>Simulate cascades from a diffusion network</h2><span id='topic+simulate_cascades'></span>

<h3>Description</h3>

<p>Simulate diffusion cascades based on the generative model underlying netinf
and a diffusion network.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_cascades(diffnet, nsim = 1, max_time = Inf,
  start_probabilities = NULL, partial_cascade = NULL, params = NULL,
  model = NULL, nodes = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_cascades_+3A_diffnet">diffnet</code></td>
<td>
<p>object of class <code>diffnet</code>.</p>
</td></tr>
<tr><td><code id="simulate_cascades_+3A_nsim">nsim</code></td>
<td>
<p>integer, number of cascades to simulate.</p>
</td></tr>
<tr><td><code id="simulate_cascades_+3A_max_time">max_time</code></td>
<td>
<p>numeric, the maximum time after which observations are 
censored</p>
</td></tr>
<tr><td><code id="simulate_cascades_+3A_start_probabilities">start_probabilities</code></td>
<td>
<p>a vector of probabilities for each node in diffnet,
to be the node with the first event. If <code>NULL</code> a node is drawn from
a uniform distribution over all nodes.</p>
</td></tr>
<tr><td><code id="simulate_cascades_+3A_partial_cascade">partial_cascade</code></td>
<td>
<p>object of type cascade, containing one partial 
cascades for which further development should be simulated.</p>
</td></tr>
<tr><td><code id="simulate_cascades_+3A_params">params</code></td>
<td>
<p>numeric, (optional) parameters for diffusion time distribution. 
See the details section of <code><a href="#topic+netinf">netinf</a></code> for specification details.
Only use this argument if parameters different from those contained in the 
<code>diffnet</code> object should be used or the network is not an object of 
class <code>diffnet</code>.</p>
</td></tr>
<tr><td><code id="simulate_cascades_+3A_model">model</code></td>
<td>
<p>character, diffusion model to use. One of <code>c("exponential", 
"rayleigh", "log-normal")</code>. Only use this argument if parameters different 
from those contained in the <code>diffnet</code> object should be used or the 
network is not an object of class <code>diffnet</code>.</p>
</td></tr>
<tr><td><code id="simulate_cascades_+3A_nodes">nodes</code></td>
<td>
<p>vector of node ids if different from nodes included in 
<code>diffnet</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with three columns. Containing 1) The names of 
the nodes (<code>"node_name"</code>) that experience an event in each cascade, 
2) the event time (<code>"event_time"</code>) of the corresponding node, 
3) the cascade identifier <code>"cascade_id"</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(cascades) 
out &lt;- netinf(cascades, trans_mod = "exponential", n_edges = 5, params = 1)
simulated_cascades &lt;- simulate_cascades(out, nsim = 10)
 
# Simulation from partial cascade

</code></pre>

<hr>
<h2 id='simulate_rnd_cascades'>Simulate a set of random cascades</h2><span id='topic+simulate_rnd_cascades'></span>

<h3>Description</h3>

<p>Simulate random cascades, for testing and demonstration purposes. No actual 
diffusion model is underlying these cascades.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_rnd_cascades(n_cascades, n_nodes)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_rnd_cascades_+3A_n_cascades">n_cascades</code></td>
<td>
<p>Number of cascades to generate.</p>
</td></tr>
<tr><td><code id="simulate_rnd_cascades_+3A_n_nodes">n_nodes</code></td>
<td>
<p>Number of nodes in the system.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing (in order of columns) node ids, 
event time and cascade identifier.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
df &lt;- simulate_rnd_cascades(10, n_nodes = 20)
head(df)

</code></pre>

<hr>
<h2 id='subset_cascade'>Select a subset of cascades from cascade object</h2><span id='topic+subset_cascade'></span>

<h3>Description</h3>

<p>Select a subset of cascades from cascade object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subset_cascade(cascade, selection)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset_cascade_+3A_cascade">cascade</code></td>
<td>
<p>cascade, object to select from</p>
</td></tr>
<tr><td><code id="subset_cascade_+3A_selection">selection</code></td>
<td>
<p>character or integer, vector of cascade_ids to select</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class cascade containing just the selected cascades
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(policies)
cascades &lt;- as_cascade_long(policies, cascade_node_name = 'statenam', 
                            event_time = 'adopt_year', cascade_id = 'policy')
cascade_names &lt;- names(cascades$cascade_times)
subset_cascade(cascades, selection = cascade_names[1:10])

</code></pre>

<hr>
<h2 id='subset_cascade_time'>Subset a cascade object in time</h2><span id='topic+subset_cascade_time'></span>

<h3>Description</h3>

<p>Remove each all events occurring outside the desired subset for each cascade 
in a cascade object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subset_cascade_time(cascade, start_time, end_time, drop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subset_cascade_time_+3A_cascade">cascade</code></td>
<td>
<p>cascade, object to subset.</p>
</td></tr>
<tr><td><code id="subset_cascade_time_+3A_start_time">start_time</code></td>
<td>
<p>numeric, start time of the subset.</p>
</td></tr>
<tr><td><code id="subset_cascade_time_+3A_end_time">end_time</code></td>
<td>
<p>numeric, end time of the subset.</p>
</td></tr>
<tr><td><code id="subset_cascade_time_+3A_drop">drop</code></td>
<td>
<p>logical, should empty sub-cascades be dropped?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class cascade, where only events are included that have 
times <code>start_time</code> &lt;= t &lt; <code>end_time</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(cascades)
sub_cascades &lt;- subset_cascade_time(cascades, 10, 20, drop=TRUE)

</code></pre>

<hr>
<h2 id='summary.cascade'>Summarize a cascade object</h2><span id='topic+summary.cascade'></span>

<h3>Description</h3>

<p>Generates summary statistics for single cascades and across cascades in a 
collection, contained in a cascades object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'cascade'
summary(object, quiet = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.cascade_+3A_object">object</code></td>
<td>
<p>object of class cascade to be summarized.</p>
</td></tr>
<tr><td><code id="summary.cascade_+3A_quiet">quiet</code></td>
<td>
<p>logical, if <code>FALSE</code> summary stats are printed to std out.</p>
</td></tr>
<tr><td><code id="summary.cascade_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to summary.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Prints cascade summary information to the screen
(if <code>quiet = FALSE</code>). <code>'# cascades'</code> is the number of cascades in
the object, <code>'# nodes'</code> is the number of nodes in the system (nodes 
that can theoretically experience an event), <code>'# nodes in cascades'</code> is 
the number of unique nodes of the system that experienced an event and 
<code>'# possible edges'</code> is the number of edges that are possible given
the cascade data (see <code><a href="#topic+count_possible_edges">count_possible_edges</a></code> for details.). 
</p>
<p>Additional summaries for each cascade are returned invisibly. 
cascade), <code>length</code> (length of the cascade as an integer of how many
nodes experienced and event) and <code>n_ties</code> (number of tied event 
times per cascade).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(cascades)
summary(cascades)

</code></pre>

<hr>
<h2 id='validation'>Validation output from netinf source.</h2><span id='topic+validation'></span>

<h3>Description</h3>

<p>Contains output from original netinf C++ implementation, executed on 
<code><a href="#topic+cascades">cascades</a></code>. For testing purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(validation)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 6 columns, containing:
</p>

<dl>
<dt>origin_node</dt><dd><p>Origin of diffusion edge.</p>
</dd>
<dt>destination_node</dt><dd><p>Destination node of diffusion edge.</p>
</dd>
<dt>volume</dt><dd><p>??</p>
</dd>
<dt>marginal_gain</dt><dd><p>Marginal gain from edge.</p>
</dd>
<dt>median_time_difference</dt><dd><p>Median time between events in origin and 
destination</p>
</dd>
<dt>mean_time_difference</dt><dd><p>Mean time between events in origin and 
destination</p>
</dd>
</dl>


<h3>Source</h3>

<p>Output from netinf example program (<a href="https://github.com/snap-stanford/snap/tree/master/examples/netinf">https://github.com/snap-stanford/snap/tree/master/examples/netinf</a>).
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
