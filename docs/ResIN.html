<!DOCTYPE html><html lang="en"><head><title>Help for package ResIN</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {ResIN}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#Bootstrap_example'><p>Output example for a bootstrapping analysis conducted with the ResIN package.</p></a></li>
<li><a href='#BrJSocPsychol_2024'><p>Source data for Lüders, A., Carpentras, D. and Quayle, M., 2024. Attitude networks as intergroup realities: Using network‐modelling to research attitude‐identity relationships in polarized political contexts. British Journal of Social Psychology, 63(1), pp.37-51.</p></a></li>
<li><a href='#lik_data'><p>Likert-type simulated data for &quot;ResIN&quot; package examples</p></a></li>
<li><a href='#ResIN'><p>ResIN</p></a></li>
<li><a href='#ResIN_boots_execute'><p>ResIN_boots_execute</p></a></li>
<li><a href='#ResIN_boots_extract'><p>ResIN_boots_extract</p></a></li>
<li><a href='#ResIN_boots_prepare'><p>ResIN_boots_prepare</p></a></li>
<li><a href='#ResIN_to_gephi'><p>ResIN_to_gephi</p></a></li>
<li><a href='#ResIN_to_igraph'><p>ResIN_to_igraph</p></a></li>
<li><a href='#ResIN_to_qgraph'><p>ResIN_to_qgraph</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Response Item Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.0</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Philip Warncke &lt;pwarncke@live.unc.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Contains various tools to perform and visualize Response Item Networks ('ResIN's'). 'ResIN' binarizes ordered-categorical and qualitative response choices from (survey) data, calculates pairwise associations and maps the location of each item response as a node in a force-directed network. Please refer to <a href="https://www.resinmethod.net/">https://www.resinmethod.net/</a> for more details.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/pwarncke77/ResIN">https://github.com/pwarncke77/ResIN</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/pwarncke77/ResIN/issues">https://github.com/pwarncke77/ResIN/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.2.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>psych, ggplot2 (&ge; 3.4.4), dplyr (&ge; 1.1.3), fastDummies,
qgraph, igraph, wCorr, Matrix, DirectedClustering, foreach,
parallelly, parallel, doSNOW, readr, shadowtext (&ge; 0.1.4)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>LazyDataCompression:</td>
<td>xz</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-10-04 10:24:28 UTC; philip</td>
</tr>
<tr>
<td>Author:</td>
<td>Philip Warncke [cre, aut],
  Dino Carpentras [aut],
  Adrian Lüders [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-10-04 10:40:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='Bootstrap_example'>Output example for a bootstrapping analysis conducted with the ResIN package.</h2><span id='topic+Bootstrap_example'></span>

<h3>Description</h3>

<p>Output example for a bootstrapping analysis conducted with the ResIN package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(Bootstrap_example)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"RDS"</code>
</p>


<h3>References</h3>

<p>This dataset was made available by Lüders et.al. 2024.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(Bootstrap_example)
str(Bootstrap_example)

</code></pre>

<hr>
<h2 id='BrJSocPsychol_2024'>Source data for Lüders, A., Carpentras, D. and Quayle, M., 2024. Attitude networks as intergroup realities: Using network‐modelling to research attitude‐identity relationships in polarized political contexts. British Journal of Social Psychology, 63(1), pp.37-51.</h2><span id='topic+BrJSocPsychol_2024'></span>

<h3>Description</h3>

<p>The sample of N = 402 paid participants through the crowd working platform Prolific Academic. The core of the survey consists of A set of eight political attitude items abortion, immigration, gun control, and gay marriage. Each item followed a 5-point scale ranging from strong disagreement to strong agreement. The survey also includes items on partisanship, affective polarization, and a short vignette experiment.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(BrJSocPsychol_2024)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"data.frame"</code>
</p>


<h3>References</h3>

<p>This dataset was made available by Lüders et.al. 2024.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(BrJSocPsychol_2024)
head(BrJSocPsychol_2024)


</code></pre>

<hr>
<h2 id='lik_data'>Likert-type simulated data for &quot;ResIN&quot; package examples</h2><span id='topic+lik_data'></span>

<h3>Description</h3>

<p>An artificially created data-set (n=1000) of 12, 5-point Likert data. Modeled on the basis of a standard normal data-generating process. Likert scales contain 20 percent uncorrelated, homoscedastic measurement error. This data-set is used for the examples in the &quot;ResIN&quot; package vignette.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(lik_data)
</code></pre>


<h3>Format</h3>

<p>An object of class <code>"data.frame"</code>
</p>


<h3>References</h3>

<p>This data set was artificially created for the ResIN package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(lik_data)
head(lik_data)


</code></pre>

<hr>
<h2 id='ResIN'>ResIN</h2><span id='topic+ResIN'></span>

<h3>Description</h3>

<p>Performs Response Item-Network (ResIN) analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ResIN(
  df,
  node_vars = NULL,
  left_anchor = NULL,
  cor_method = "auto",
  weights = NULL,
  method_wCorr = "Polychoric",
  poly_ncor = 2,
  neg_offset = 0,
  ResIN_scores = TRUE,
  remove_negative = TRUE,
  EBICglasso = FALSE,
  EBICglasso_arglist = NULL,
  remove_nonsignificant = FALSE,
  sign_threshold = 0.05,
  node_covars = NULL,
  node_costats = NULL,
  network_stats = TRUE,
  detect_clusters = FALSE,
  cluster_method = NULL,
  cluster_arglist = NULL,
  cluster_assignment = TRUE,
  seed = NULL,
  generate_ggplot = TRUE,
  plot_ggplot = TRUE,
  plot_whichstat = NULL,
  plot_edgestat = NULL,
  color_palette = "RdBu",
  plot_responselabels = TRUE,
  response_levels = NULL,
  plot_title = NULL,
  save_input = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ResIN_+3A_df">df</code></td>
<td>
<p>A data-frame object containing the raw data.</p>
</td></tr>
<tr><td><code id="ResIN_+3A_node_vars">node_vars</code></td>
<td>
<p>An optional character vector detailing the attitude item columns to be selected for ResIN analysis (i.e. the subset of attitude variables in df).</p>
</td></tr>
<tr><td><code id="ResIN_+3A_left_anchor">left_anchor</code></td>
<td>
<p>An optional character scalar indicating a particular response node which determines the spatial orientation of the ResIN latent space. If this response node does not appear on the left-hand side, the x-plane will be inverted. This ensures consistent interpretation of the latent space across multiple iterations (e.g. in bootstrapping analysis). Defaults to NULL (no adjustment to orientation is taken.)</p>
</td></tr>
<tr><td><code id="ResIN_+3A_cor_method">cor_method</code></td>
<td>
<p>Which correlation method should be used? Defaults to &quot;auto&quot; which applies the <code>cor_auto</code> function from the <code>qgraph</code> package. Possible arguments are <code>"auto"</code>, <code>"pearson"</code>, <code>"kendall"</code>, and <code>"spearman"</code>.</p>
</td></tr>
<tr><td><code id="ResIN_+3A_weights">weights</code></td>
<td>
<p>An optional continuous vector of survey weights. Should have the same length as number of observations in df. If weights are provided, weighted correlation matrix will be estimated with the <code>weightedCorr</code> function from the <code>wCorr</code> package.</p>
</td></tr>
<tr><td><code id="ResIN_+3A_method_wcorr">method_wCorr</code></td>
<td>
<p>If weights are supplied, which method for weighted correlations should be used? Defaults to <code>"Polychoric"</code>. See <code>wCorr::weightedCorr</code> for all correlation options.</p>
</td></tr>
<tr><td><code id="ResIN_+3A_poly_ncor">poly_ncor</code></td>
<td>
<p>How many CPU cores should be used to estimate polychoric correlation matrix? Only used if <code>cor_method = "polychoric"</code>.</p>
</td></tr>
<tr><td><code id="ResIN_+3A_neg_offset">neg_offset</code></td>
<td>
<p>Should negative correlations be offset to avoid small correlation pairs disappearing? Defaults to <code>0</code>. Any positive number between 0 and 1 may be supplied instead.</p>
</td></tr>
<tr><td><code id="ResIN_+3A_resin_scores">ResIN_scores</code></td>
<td>
<p>Should spatial scores be calculated for every individual. Defaults to TRUE. Function obtains the mean positional score on the major (x-axis) and minor (y-axis). Further versions of this package will include more sophisticated scoring techniques.</p>
</td></tr>
<tr><td><code id="ResIN_+3A_remove_negative">remove_negative</code></td>
<td>
<p>Should all negative correlations be removed? Defaults to TRUE (highly recommended). Setting to FALSE makes it impossible to estimate a force-directed network layout. Function will use igraph::layout_nicely instead.</p>
</td></tr>
<tr><td><code id="ResIN_+3A_ebicglasso">EBICglasso</code></td>
<td>
<p>Should a sparse, Gaussian-LASSO ResIN network be estimated? Defaults to FALSE. If set to TRUE, <code>EBICglasso</code> function from the <code>qgraph</code> packages performs regularization on (nearest positive-semi-definite) ResIN correlation matrix.</p>
</td></tr>
<tr><td><code id="ResIN_+3A_ebicglasso_arglist">EBICglasso_arglist</code></td>
<td>
<p>An argument list feeding additional instructions to the <code>EBICglasso</code> function if <code>EBICglasso</code> is set to TRUE.</p>
</td></tr>
<tr><td><code id="ResIN_+3A_remove_nonsignificant">remove_nonsignificant</code></td>
<td>
<p>Optionally, should non-significant edges be removed from the ResIN network? Defaults to FALSE. Note that this option is incompatible with EBICglasso and weighted correlations.</p>
</td></tr>
<tr><td><code id="ResIN_+3A_sign_threshold">sign_threshold</code></td>
<td>
<p>At what p-value threshold should non-significant edges be removed? Defaults to 0.05.</p>
</td></tr>
<tr><td><code id="ResIN_+3A_node_covars">node_covars</code></td>
<td>
<p>An optional character string selecting quantitative covariates that can be used to enhance ResIN analysis. Typically, these covariates provide grouped summary statistics for item response nodes. (E.g.: What is the average age or income level of respondents who selected a particular item response?) Variable names specified here should match existing columns in <code>df</code>.</p>
</td></tr>
<tr><td><code id="ResIN_+3A_node_costats">node_costats</code></td>
<td>
<p>If any <code>node_covars</code> are selected, what summary statistics should be estimated from them? Argument should be a character vector and call a base-R function. (E.g. <code>"mean"</code>, <code>"median"</code>, <code>"sd"</code>). Each element specified in <code>node_costats</code> is applied to each element in <code>node_covars</code> and the out-put is stored as a node-level summary statistic in the <code>ResIN_nodeframe</code>. The extra columns in <code>ResIN_nodeframe</code> are labeled according to the following template: &quot;covariate name&quot;_&quot;statistic&quot;. So for the respondents mean age, the corresponding column in <code>ResIN_nodeframe</code> would be labeled as &quot;age_mean&quot;.</p>
</td></tr>
<tr><td><code id="ResIN_+3A_network_stats">network_stats</code></td>
<td>
<p>Should common node- and graph level network statistics be extracted? Calls <code>qgraph::centrality_auto</code> and <code>DirectedClustering::ClustF</code> to the ResIN graph object to extract node-level betweenness, closeness, strength centrality, as well as the mean and standard deviation of these scores at the network level. Also estimates network expected influence, average path length, and global clustering coefficients. Defaults to TRUE. Set to FALSE if estimation takes a long time.</p>
</td></tr>
<tr><td><code id="ResIN_+3A_detect_clusters">detect_clusters</code></td>
<td>
<p>Optional, should community detection be performed on item response network? Defaults to FALSE. If set to TRUE, performs a clustering method from the [igraph](https://igraph.org/r/doc/cluster_leading_eigen.html) library and stores the results in the <code>ResIN_nodeframe</code> output.</p>
</td></tr>
<tr><td><code id="ResIN_+3A_cluster_method">cluster_method</code></td>
<td>
<p>A character scalar specifying the [igraph-based](https://igraph.org/r/doc/communities.html) community detection function.</p>
</td></tr>
<tr><td><code id="ResIN_+3A_cluster_arglist">cluster_arglist</code></td>
<td>
<p>An optional list specifying additional arguments to the selected [igraph](https://igraph.org/r/doc/communities.html) clustering method.</p>
</td></tr>
<tr><td><code id="ResIN_+3A_cluster_assignment">cluster_assignment</code></td>
<td>
<p>Should individual (survey) respondents be assigned to different clusters? If set to TRUE, function will generate an n*c matrix of probabilities for each respondent to be assigned to one of c clusters. Furthermore, a vector of length n is generated displaying the most likely cluster respondents belong to. In case of a tie between one or more clusters, a very small amount of random noise determines assignment. Both matrix and vectors are added to the <code>aux_objects</code> list. Defaults to FALSE and will be ignored if <code>detect_clusters</code> is set to FALSE.</p>
</td></tr>
<tr><td><code id="ResIN_+3A_seed">seed</code></td>
<td>
<p>Random seed for force-directed algorithm. Defaults to NULL (no seed is set.) If scalar integer is supplied, that seed will be set prior to analysis.</p>
</td></tr>
<tr><td><code id="ResIN_+3A_generate_ggplot">generate_ggplot</code></td>
<td>
<p>Should a ggplot-based visualization of the ResIN network be generated? Defaults to TRUE.</p>
</td></tr>
<tr><td><code id="ResIN_+3A_plot_ggplot">plot_ggplot</code></td>
<td>
<p>Should a basic ggplot of the ResIN network be plotted? Defaults to TRUE. If set to FALSE, the ggplot object will not be directly returned to the console. (However, if generate_ggplot=TRUE, the plot will still be generated and stored alongside the other output objects.)</p>
</td></tr>
<tr><td><code id="ResIN_+3A_plot_whichstat">plot_whichstat</code></td>
<td>
<p>Should a particular node-level metric be color-visualized in the ggplot output? For node cluster, specify &quot;cluster&quot;. For the same Likert response choices or options, specify &quot;choices&quot;. For a particular node-level co-variate please specify the name of the particular element in <code>node_covars</code> followed by a &quot;_&quot; and the specific <code>node_costats</code> you would like to visualize. For instance if you want the visualize average age at the node-level, you should specify &quot;age_mean&quot;. To colorize by node centrality statistics, possible choices are &quot;Strength&quot;, &quot;Betweenness&quot;, &quot;Closeness&quot;, and &quot;ExpectedInfluence&quot;. Defaults to NULL. Make sure to supply appropriate choices to <code>node_covars</code>, <code>node_costats</code>, <code>detect_clusters</code>, and/or <code>network_stats</code> prior to setting this argument.</p>
</td></tr>
<tr><td><code id="ResIN_+3A_plot_edgestat">plot_edgestat</code></td>
<td>
<p>Should the thickness of the edges be adjusted according to a particular co-statistic? Defaults to NULL. Possible choices are &quot;weight&quot; for the bi-variate correlation strength, and &quot;edgebetweenness&quot;</p>
</td></tr>
<tr><td><code id="ResIN_+3A_color_palette">color_palette</code></td>
<td>
<p>Optionally, you may specify the ggplot2 color palette to be applied to the plot. All options contained in [<code>RColorBrewer</code>](https://cran.r-project.org/web/packages/RColorBrewer/RColorBrewer.pdf) (for discrete colors such as cluster assignments) and [<code>ggplot2::scale_colour_distiller</code>](https://ggplot2.tidyverse.org/reference/scale_brewer.html) are supported. Defaults to &quot;RdBu&quot;.</p>
</td></tr>
<tr><td><code id="ResIN_+3A_plot_responselabels">plot_responselabels</code></td>
<td>
<p>Should response labels be plotted via <code>geom_text</code>? Defaults to TRUE. It is recommended to set to FALSE if the network possesses a lot of nodes and/or long response choice names.</p>
</td></tr>
<tr><td><code id="ResIN_+3A_response_levels">response_levels</code></td>
<td>
<p>An optional character vector specifying the correct order of global response levels. Only useful if all node-items follow the same convention (e.g. ranging from &quot;strong disagreement&quot; to &quot;strong agreement&quot;). The supplied vector should have the same length as the total number of response options and supply these (matching exactly) in the correct order. E.g. c(&quot;Strongly Agree&quot;, &quot;Somewhat Agree&quot;, &quot;Neutral&quot;, &quot;Somewhat Disagree&quot;, &quot;Strongly Disagree&quot;). Defaults to NULL.</p>
</td></tr>
<tr><td><code id="ResIN_+3A_plot_title">plot_title</code></td>
<td>
<p>Optionally, a character scalar specifying the title of the ggplot output. Defaults to &quot;ResIN plot&quot;.</p>
</td></tr>
<tr><td><code id="ResIN_+3A_save_input">save_input</code></td>
<td>
<p>Optionally, should input data and function arguments be saved (this is necessary for running ResIN_boots_prepare function). Defaults to TRUE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An edge-list type data-frame, <code>ResIN_edgelist</code>, a node-level data-frame, <code>ResIN_nodeframe</code>, an n*2 data-frame of individual-level spatial scores along the major (x) and minor(y) axis, <code>ResIN_scores</code> a list of graph-level statistics <code>graph_stats</code> including (<code>graph_structuration</code>) and centralization (<code>graph_centralization</code>), as well as a list of auxiliary objects, <code>aux_objects</code>, including the ResIN adjacency matrix (<code>adj_matrix</code>), a numeric vector detailing which item responses belong to which item (<code>same_items</code>), and the dummy-coded item-response data-frame (<code>df_dummies</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Load the 12-item simulated Likert-type toy dataset
data(lik_data)

# Apply the ResIN function to toy Likert data:
ResIN_obj &lt;- ResIN(lik_data, cor_method = "spearman", network_stats = TRUE, detect_clusters = TRUE)


</code></pre>

<hr>
<h2 id='ResIN_boots_execute'>ResIN_boots_execute</h2><span id='topic+ResIN_boots_execute'></span>

<h3>Description</h3>

<p>Execute prepared ResIN bootstrap analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ResIN_boots_execute(
  ResIN_boots_prepped,
  parallel = FALSE,
  detect_cores = TRUE,
  core_offset = 0L,
  n_cores = 2L,
  inorder = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ResIN_boots_execute_+3A_resin_boots_prepped">ResIN_boots_prepped</code></td>
<td>
<p>A list of prepared ResIN objects for bootstrapping (outcome of the <code>ResIN_boots_prepare</code> function)</p>
</td></tr>
<tr><td><code id="ResIN_boots_execute_+3A_parallel">parallel</code></td>
<td>
<p>Should the function be executed in parallel using the <code>foreach</code> package? Defaults to FALSE. If FALSE, function will execute sequentially in a simple for loop.</p>
</td></tr>
<tr><td><code id="ResIN_boots_execute_+3A_detect_cores">detect_cores</code></td>
<td>
<p>Should the number of available CPU cores be automatically detected? Defaults to TRUE and is ignored when parallel is set to FALSE.</p>
</td></tr>
<tr><td><code id="ResIN_boots_execute_+3A_core_offset">core_offset</code></td>
<td>
<p>Optionally, specify a positive integer offset that is subtracted from the number of automatically detected cores. Defaults to 0L.</p>
</td></tr>
<tr><td><code id="ResIN_boots_execute_+3A_n_cores">n_cores</code></td>
<td>
<p>Manually specify the number of available CPU cores. Defaults to 2L and is ignored if detect_cores is set to TRUE or if parallel is set to FALSE.</p>
</td></tr>
<tr><td><code id="ResIN_boots_execute_+3A_inorder">inorder</code></td>
<td>
<p>Should parallel execution be done in sequential order of the <code>ResIN_boots_prepped</code> object?</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object containing n (bootstrapped) <code>ResIN</code> list objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load the 12-item simulated Likert-type toy dataset
data(lik_data)

# Apply the ResIN function to toy Likert data:
ResIN_obj &lt;- ResIN(lik_data, cor_method = "spearman", network_stats = TRUE,
                      generate_ggplot = FALSE)

## Not run: 
# Prepare for bootstrapping
prepped_boots &lt;- ResIN_boots_prepare(ResIN_obj, n=5000, boots_type="permute")

# Execute the prepared bootstrap list
executed_boots &lt;-  ResIN_boots_execute(prepped_boots, parallel = TRUE, detect_cores = TRUE)

# Extract results - here for example, the network (global)-clustering coefficient
ResIN_boots_extract(executed_boots, what = "global_clustering", summarize_results = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='ResIN_boots_extract'>ResIN_boots_extract</h2><span id='topic+ResIN_boots_extract'></span>

<h3>Description</h3>

<p>Extract and summarize quantities from bootstrapped ResIN objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ResIN_boots_extract(ResIN_boots_executed, what, summarize_results = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ResIN_boots_extract_+3A_resin_boots_executed">ResIN_boots_executed</code></td>
<td>
<p>A list of prepared ResIN objects for bootstrapping (outcome of the <code>ResIN_boots_executed</code> function)</p>
</td></tr>
<tr><td><code id="ResIN_boots_extract_+3A_what">what</code></td>
<td>
<p>A character vector of length one specifying the target quantity of interest. This should be a one-to-one match with the corresponding output vector (or scalar) among the bootstrapped result list (see <code>ResIN_boots_execute</code>). For participants' position on the x-axis of the ResIN latent space, for example, specify &quot;scores_x&quot;.</p>
</td></tr>
<tr><td><code id="ResIN_boots_extract_+3A_summarize_results">summarize_results</code></td>
<td>
<p>Should the extracted quantities be summarized through a series of descriptive statistics? If set to true, the minimum, maximum, mean, selected quantiles, and the standard deviation are reported. If set to FALSE (default), extracted quantities are instead returned as a list.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object containing n (bootstrapped) <code>ResIN</code> list objects.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load the 12-item simulated Likert-type toy dataset
data(lik_data)

# Apply the ResIN function to toy Likert data:
ResIN_obj &lt;- ResIN(lik_data, cor_method = "spearman", network_stats = TRUE,
                      generate_ggplot = FALSE)

## Not run: 
# Prepare for bootstrapping
prepped_boots &lt;- ResIN_boots_prepare(ResIN_obj, n=5000, boots_type="permute")

# Execute the prepared bootstrap list
executed_boots &lt;-  ResIN_boots_execute(prepped_boots, parallel = TRUE, detect_cores = TRUE)

# Extract results - here for example, the network (global)-clustering coefficient
ResIN_boots_extract(executed_boots, what = "global_clustering", summarize_results = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='ResIN_boots_prepare'>ResIN_boots_prepare</h2><span id='topic+ResIN_boots_prepare'></span>

<h3>Description</h3>

<p>Prepare a ResIN-based bootstrap analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ResIN_boots_prepare(
  ResIN_object,
  n = 10000,
  boots_type = "resample",
  resample_size = NULL,
  weights = NULL,
  save_input = FALSE,
  seed = 42
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ResIN_boots_prepare_+3A_resin_object">ResIN_object</code></td>
<td>
<p>A ResIN object to prepare bootstrapping workflow.</p>
</td></tr>
<tr><td><code id="ResIN_boots_prepare_+3A_n">n</code></td>
<td>
<p>Bootstrapping sample size. Defaults to 10.000.</p>
</td></tr>
<tr><td><code id="ResIN_boots_prepare_+3A_boots_type">boots_type</code></td>
<td>
<p>What kind of bootstrapping should be performed? If set to &quot;resample&quot;, function performs row-wise re-sampling of raw data (useful for e.g., sensitivity or power analysis). If set to &quot;permute&quot;, function will randomly reshuffle raw item responses (useful e.g., for simulating null-hypothesis distributions). Defaults to &quot;resample&quot;.</p>
</td></tr>
<tr><td><code id="ResIN_boots_prepare_+3A_resample_size">resample_size</code></td>
<td>
<p>Optional parameter determining sample size when <code>boots_type</code> is set to &quot;resample&quot;. Defaults of to number of rows in raw data.</p>
</td></tr>
<tr><td><code id="ResIN_boots_prepare_+3A_weights">weights</code></td>
<td>
<p>An optional weights vector that can be used to adjust the re-sampling of observations. Should either be NULL (default) or a positive numeric vector of the same length as the original data.</p>
</td></tr>
<tr><td><code id="ResIN_boots_prepare_+3A_save_input">save_input</code></td>
<td>
<p>Should all input information for each bootstrap iteration (including re-sampled/permuted data) be stored. Set to FALSE by default to save a lot of memory and disk storage.</p>
</td></tr>
<tr><td><code id="ResIN_boots_prepare_+3A_seed">seed</code></td>
<td>
<p>Random seed for bootstrap samples</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object containing n re-sampled or permuted copies of the raw data, along with a list of instructions for how to perform the ResIN analysis and what outputs to generate.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Load the 12-item simulated Likert-type toy dataset
data(lik_data)

# Apply the ResIN function to toy Likert data:
ResIN_obj &lt;- ResIN(lik_data, cor_method = "spearman", network_stats = TRUE,
                      generate_ggplot = FALSE)

## Not run: 
# Prepare for bootstrapping
prepped_boots &lt;- ResIN_boots_prepare(ResIN_obj, n=5000, boots_type="permute")

# Execute the prepared bootstrap list
executed_boots &lt;-  ResIN_boots_execute(prepped_boots, parallel = TRUE, detect_cores = TRUE)

# Extract results - here for example, the network (global)-clustering coefficient
ResIN_boots_extract(executed_boots, what = "global_clustering", summarize_results = TRUE)

## End(Not run)

</code></pre>

<hr>
<h2 id='ResIN_to_gephi'>ResIN_to_gephi</h2><span id='topic+ResIN_to_gephi'></span>

<h3>Description</h3>

<p>Saves a ResIN graph as a series of csv files readable by Gephi. Source code taken from RMHogervorst / gephi
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ResIN_to_gephi(ResIN_object, file = "ResIN_gephi.csv")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ResIN_to_gephi_+3A_resin_object">ResIN_object</code></td>
<td>
<p>the output of the ResIN function (a list with class ResIN).</p>
</td></tr>
<tr><td><code id="ResIN_to_gephi_+3A_file">file</code></td>
<td>
<p>the name with .csv extension for the Gephi readable file to be output at. Defaults to &quot;ResIN_gephi.csv&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A series of csv files readable by Gephi
</p>


<h3>References</h3>

<p>Source code was taken from: https://github.com/RMHogervorst/gephi?tab=MIT-1-ov-file#readme
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
## Load the 12-item simulated Likert-type ResIN toy dataset
data(lik_data)

## Run the function:
ResIN_to_gephi(ResIN(lik_data), file = "ResIN_gephi.csv")

## End(Not run)

</code></pre>

<hr>
<h2 id='ResIN_to_igraph'>ResIN_to_igraph</h2><span id='topic+ResIN_to_igraph'></span>

<h3>Description</h3>

<p>Transforms the output of the ResIN function into an [igraph](https://igraph.org/r/doc/cluster_leading_eigen.html) object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ResIN_to_igraph(ResIN_object, igraph_arglist = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ResIN_to_igraph_+3A_resin_object">ResIN_object</code></td>
<td>
<p>the output of the ResIN function (a list with class ResIN).</p>
</td></tr>
<tr><td><code id="ResIN_to_igraph_+3A_igraph_arglist">igraph_arglist</code></td>
<td>
<p>an optional argument list to be supplied to the igraph::graph_from_adjacency_matrix function. If NULL, default is: list(mode = &quot;undirected&quot;, weighted = TRUE, diag = FALSE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A class <code>igraph</code> object.
</p>


<h3>References</h3>

<p>Csardi G, Nepusz T (2006). “The igraph software package for complex network research.” InterJournal, Complex Systems, 1695. https://igraph.org.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Load the 12-item simulated Likert-type ResIN toy dataset
data(lik_data)

## Run the function:

igraph_output &lt;-  ResIN_to_igraph(ResIN(lik_data))


## Plot and/or investigate as you wish:
igraph::plot.igraph(igraph_output)


</code></pre>

<hr>
<h2 id='ResIN_to_qgraph'>ResIN_to_qgraph</h2><span id='topic+ResIN_to_qgraph'></span>

<h3>Description</h3>

<p>Transforms the output of the ResIN function into an <code>qgraph</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ResIN_to_qgraph(ResIN_object, qgraph_arglist = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ResIN_to_qgraph_+3A_resin_object">ResIN_object</code></td>
<td>
<p>the output of the ResIN function (a list with class ResIN).</p>
</td></tr>
<tr><td><code id="ResIN_to_qgraph_+3A_qgraph_arglist">qgraph_arglist</code></td>
<td>
<p>an optional argument list to be supplied to the igraph::graph_from_adjacency_matrix function. If NULL, defaults are: list(layout = &quot;spring&quot;, maximum = 1, vsize = 6, DoNotPlot = TRUE, sampleSize = nrow(df_nodes), mar = c(3,3,3,3), normalize = FALSE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A [qgraph]https://cran.r-project.org/web/packages/qgraph/index.html graph object.
</p>


<h3>References</h3>

<p>Epskamp S, Cramer AOJ, Waldorp LJ, Schmittmann VD, Borsboom D (2012). “qgraph: Network Visualizations of Relationships in Psychometric Data.” Journal of Statistical Software, 48(4), 1–18.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Load the 12-item simulated Likert-type ResIN toy dataset
data(lik_data)

## Run the function:
ResIN_qgraph &lt;-  ResIN_to_qgraph(ResIN(lik_data))


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
