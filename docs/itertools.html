<!DOCTYPE html><html><head><title>Help for package itertools</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {itertools}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#itertools-package'>
<p>The itertools Package</p></a></li>
<li><a href='#chain'><p>Create a chaining iterator</p></a></li>
<li><a href='#enumerate'><p>Create an enumeration object</p></a></li>
<li><a href='#hasNext'><p>Does This Iterator Have A Next Element</p></a></li>
<li><a href='#iarray'><p>Create an iterator over an array</p></a></li>
<li><a href='#ibreak'><p>Create an iterator that can be told to stop</p></a></li>
<li><a href='#ichunk'><p>Create a chunking iterator</p></a></li>
<li><a href='#ifilter'><p>Create a filtering iterator</p></a></li>
<li><a href='#ihasNext'><p>Create an iterator that supports the hasNext method</p></a></li>
<li><a href='#ilimit'><p>Create a limited iterator</p></a></li>
<li><a href='#ireadBin'><p>Create an iterator to read binary data from a connection</p></a></li>
<li><a href='#ireaddf'><p>Create an iterator to read data frames from files</p></a></li>
<li><a href='#irecord'><p>Record and replay iterators</p></a></li>
<li><a href='#irep'><p>Create a repeating iterator</p></a></li>
<li><a href='#irepeat'><p>Create a repeating iterator</p></a></li>
<li><a href='#iRNGStream'><p>Iterators that support parallel RNG</p></a></li>
<li><a href='#is.iterator'><p>Utilities for writing iterators</p></a></li>
<li><a href='#isplitCols'><p>Create an iterator that splits a matrix into block columns</p></a></li>
<li><a href='#isplitIndices'><p>Create an iterator of indices</p></a></li>
<li><a href='#isplitRows'><p>Create an iterator that splits a matrix into block rows</p></a></li>
<li><a href='#isplitVector'><p>Create an iterator that splits a vector</p></a></li>
<li><a href='#izip'><p>Create an iterator over multiple iterables</p></a></li>
<li><a href='#product'><p>Create a cartesian product iterator</p></a></li>
<li><a href='#recycle'><p>Create a recycling iterator</p></a></li>
<li><a href='#timeout'><p>Create a timeout iterator</p></a></li>
<li><a href='#writedf.combiner'><p>Create an object that contains a combiner function</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Iterator Tools</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1-3</td>
</tr>
<tr>
<td>Author:</td>
<td>Steve Weston, Hadley Wickham</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Steve Weston &lt;stephen.b.weston@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Various tools for creating iterators, many patterned after
        functions in the Python itertools module, and others patterned
        after functions in the 'snow' package.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.14.0), iterators(&ge; 1.0.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>parallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>foreach</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Repository/R-Forge/Project:</td>
<td>itertools</td>
</tr>
<tr>
<td>Repository/R-Forge/Revision:</td>
<td>60</td>
</tr>
<tr>
<td>Repository/R-Forge/DateTimeStamp:</td>
<td>2014-02-27 22:33:49</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2014-03-12 00:20:01</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2014-02-27 23:36:25 UTC; rforge</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
</table>
<hr>
<h2 id='itertools-package'>
The itertools Package
</h2><span id='topic+itertools-package'></span><span id='topic+itertools'></span>

<h3>Description</h3>

<p>The <code>itertools</code> package provides a variety of functions used to create
iterators, as defined by REvolution Computing's <code>iterators</code> package.
Many of the functions are patterned after functions of the same name in
the Python itertools module, including <code>chain</code>, <code>product</code>,
<code>izip</code>, <code>ifilter</code>, etc.
In addition, a number of functions were inspired by utility functions in the
<code>snow</code> package, such as <code>isplitRows</code>, <code>isplitCols</code>, and
<code>isplitIndices</code>.
</p>
<p>There are also several utility functions that were contributed by
Hadley Wickham that aid in writing iterators.
These include <code>is.iterator</code>, <code>end_iterator</code>,
<code>iteration_has_ended</code>, and <code>new_iterator</code>.
</p>


<h3>Details</h3>

<p>More information is available on the following topics:
</p>

<table>
<tr>
 <td style="text-align: left;">
<code>isplitVector</code> </td><td style="text-align: left;"> splits, or slices, a vector into shorter segments</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>isplitCols</code> </td><td style="text-align: left;"> splits a matrix column-wise</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>isplitRows</code> </td><td style="text-align: left;"> splits a matrix row-wise</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>isplitIndices</code> </td><td style="text-align: left;"> iterate over &ldquo;chunks&rdquo; of indices from 1 to n</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>chain</code> </td><td style="text-align: left;"> chain multiple iterators together into one iterator</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>enumerate</code> </td><td style="text-align: left;"> create an enumeration from an iterator</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>ichunk</code> </td><td style="text-align: left;"> create lists of values from an iterator to aid manual chunking</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>ihasNext</code> </td><td style="text-align: left;"> add a hasNext method to an iterator</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>ifilter</code> </td><td style="text-align: left;"> only return values for which a predicate function returns true</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>ifilterfalse</code> </td><td style="text-align: left;"> only return values for which a predicate function returns false</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>ilimit</code> </td><td style="text-align: left;"> limit, or truncate, an iterator</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>ireadBin</code> </td><td style="text-align: left;"> reads from a binary connection</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>irep</code> </td><td style="text-align: left;"> an iterator version of the rep function</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>irepeat</code> </td><td style="text-align: left;"> a simple repeating value iterator</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>izip</code> </td><td style="text-align: left;"> zip together multiple iterators</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>product</code> </td><td style="text-align: left;"> zip together multiple iterators in cartesian product fashion</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>recycle</code> </td><td style="text-align: left;"> recycle values from an iterator repeatedly</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>timeout</code> </td><td style="text-align: left;"> iterate for a specified number of seconds</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>is.iterator</code> </td><td style="text-align: left;"> indicates if an object is an iterator</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>end_iteration</code> </td><td style="text-align: left;"> throws an exception to signal end of iteration</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>iteration_has_ended</code> </td><td style="text-align: left;"> tests an exception to see if iteration has ended</td>
</tr>
<tr>
 <td style="text-align: left;">
<code>new_iterator</code> </td><td style="text-align: left;"> creates a new iterator object</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>For a complete list of functions with individual help pages,
use <code>library(help="itertools")</code>.
</p>

<hr>
<h2 id='chain'>Create a chaining iterator</h2><span id='topic+chain'></span>

<h3>Description</h3>

<p>Create an iterator that chains multiple iterables together.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chain(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chain_+3A_...">...</code></td>
<td>
<p>The iterables to iterate over.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Iterate over two iterables
as.list(chain(1:2, letters[1:3]))
</code></pre>

<hr>
<h2 id='enumerate'>Create an enumeration object</h2><span id='topic+enumerate'></span>

<h3>Description</h3>

<p>Create an iterator that iterates over an iterable, returning the value
in a list that includes an index.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>enumerate(iterable)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="enumerate_+3A_iterable">iterable</code></td>
<td>
<p>Iterable to iterate over.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Create an enumeration of five random numbers
as.list(enumerate(rnorm(5)))
</code></pre>

<hr>
<h2 id='hasNext'>Does This Iterator Have A Next Element</h2><span id='topic+hasNext'></span><span id='topic+hasNext.ihasNext'></span>

<h3>Description</h3>

<p><code>hasNext</code> is a generic function that indicates if the iterator
has another element.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hasNext(obj, ...)

## S3 method for class 'ihasNext'
hasNext(obj, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hasNext_+3A_obj">obj</code></td>
<td>
<p>an iterator object.</p>
</td></tr>
<tr><td><code id="hasNext_+3A_...">...</code></td>
<td>
<p>additional arguments that are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Logical value indicating whether the iterator has a next element.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  it &lt;- ihasNext(iter(c('a', 'b', 'c')))
  while (hasNext(it))
    print(nextElem(it))
</code></pre>

<hr>
<h2 id='iarray'>Create an iterator over an array</h2><span id='topic+iarray'></span>

<h3>Description</h3>

<p>Create an iterator over an array.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iarray(X, MARGIN, ..., chunks, chunkSize, drop,
       idx=lapply(dim(X), function(i) TRUE))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iarray_+3A_x">X</code></td>
<td>
<p>Array to iterate over.</p>
</td></tr>
<tr><td><code id="iarray_+3A_margin">MARGIN</code></td>
<td>
<p>Vector of subscripts to iterate over.  Note that if
the length of <code>MARGIN</code> is greater than one, the resulting iterator
will generate iterators which is particularly useful with nested
foreach loops.</p>
</td></tr>
<tr><td><code id="iarray_+3A_...">...</code></td>
<td>
<p>Used to force subsequent arguments to be specified by name.</p>
</td></tr>
<tr><td><code id="iarray_+3A_chunks">chunks</code></td>
<td>
<p>Number of elements that the iterator should generate.
This can be a single value or a vector the same length as <code>MARGIN</code>.
A single value will be recycled for each dimension if <code>MARGIN</code>
has more than one value.</p>
</td></tr>
<tr><td><code id="iarray_+3A_chunksize">chunkSize</code></td>
<td>
<p>The maximum size Number of elements that the iterator
should generate.
This can be a single value or a vector the same length as <code>MARGIN</code>.
A single value will be recycled for each dimension if <code>MARGIN</code>
has more than one value.</p>
</td></tr>
<tr><td><code id="iarray_+3A_drop">drop</code></td>
<td>
<p>Should dimensions of length 1 be dropped in the generated
values?  It defaults to <code>FALSE</code> if either <code>chunks</code> or
<code>chunkSize</code> is specified, otherwise to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="iarray_+3A_idx">idx</code></td>
<td>
<p>List of indices used to generate a call object.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+apply">apply</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  # Iterate over matrices in a 3D array
  x &lt;- array(1:24, c(2,3,4))
  as.list(iarray(x, 3))

  # Iterate over subarrays
  as.list(iarray(x, 3, chunks=2))

  x &lt;- array(1:64, c(4,4,4))
  it &lt;- iarray(x, c(2,3), chunks=c(1,2))
  jt &lt;- nextElem(it)
  nextElem(jt)
  jt &lt;- nextElem(it)
  nextElem(jt)

  it &lt;- iarray(x, c(2,3), chunks=c(2,2))
  jt &lt;- nextElem(it)
  nextElem(jt)
  nextElem(jt)
  jt &lt;- nextElem(it)
  nextElem(jt)
  nextElem(jt)
</code></pre>

<hr>
<h2 id='ibreak'>Create an iterator that can be told to stop</h2><span id='topic+ibreak'></span>

<h3>Description</h3>

<p>Create an iterator that iterates over another iterator until
a specified function returns <code>FALSE</code>.
This can be useful for breaking out of a foreach loop, for example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ibreak(iterable, finished)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ibreak_+3A_iterable">iterable</code></td>
<td>
<p>Iterable to iterate over.</p>
</td></tr>
<tr><td><code id="ibreak_+3A_finished">finished</code></td>
<td>
<p>Function that returns a logical value.  The iterator
stops when this function returns <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># See how high we can count in a tenth of a second
mkfinished &lt;- function(time) {
  starttime &lt;- proc.time()[3]
  function() proc.time()[3] &gt; starttime + time
}
length(as.list(ibreak(icount(), mkfinished(0.1))))
</code></pre>

<hr>
<h2 id='ichunk'>Create a chunking iterator</h2><span id='topic+ichunk'></span>

<h3>Description</h3>

<p>Create an iterator that issues lists of values from the underlying iterable.
This is useful for manually &ldquo;chunking&rdquo; values from an iterable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ichunk(iterable, chunkSize, mode='list')
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ichunk_+3A_iterable">iterable</code></td>
<td>
<p>Iterable to iterate over.</p>
</td></tr>
<tr><td><code id="ichunk_+3A_chunksize">chunkSize</code></td>
<td>
<p>Maximum number of values from <code>iterable</code> to
return in each value issued by the resulting iterator.</p>
</td></tr>
<tr><td><code id="ichunk_+3A_mode">mode</code></td>
<td>
<p>Mode of the objects returned by the iterator.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+isplitVector">isplitVector</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Split the vector 1:10 into "chunks" with a maximum length of three
it &lt;- ihasNext(ichunk(1:10, 3))
while (hasNext(it)) {
  print(unlist(nextElem(it)))
}

# Same as previous, but return integer vectors rather than lists
it &lt;- ihasNext(ichunk(1:10, 3, mode='integer'))
while (hasNext(it)) {
  print(nextElem(it))
}
</code></pre>

<hr>
<h2 id='ifilter'>Create a filtering iterator</h2><span id='topic+ifilter'></span><span id='topic+ifilterfalse'></span>

<h3>Description</h3>

<p>The <code>ifilter</code> and <code>ifilterfalse</code> functions create iterators
that return a subset of the values of the specified iterable.
<code>ifilter</code> returns the values for which the <code>pred</code> function
returns <code>TRUE</code>, and <code>ifilterfalse</code> returns the values for
which the <code>pred</code> function returns <code>FALSE</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifilter(pred, iterable)
ifilterfalse(pred, iterable)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ifilter_+3A_pred">pred</code></td>
<td>
<p>A function that takes one argument and returns <code>TRUE</code> or <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="ifilter_+3A_iterable">iterable</code></td>
<td>
<p>The iterable to iterate over.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Return the odd numbers between 1 and 10
as.list(ifilter(function(x) x %% 2 == 1, icount(10)))

# Return the even numbers between 1 and 10
as.list(ifilterfalse(function(x) x %% 2 == 1, icount(10)))
</code></pre>

<hr>
<h2 id='ihasNext'>Create an iterator that supports the hasNext method</h2><span id='topic+ihasNext'></span>

<h3>Description</h3>

<p><code>ihasNext</code> is a generic function that indicates if the iterator
has another element.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ihasNext(iterable)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ihasNext_+3A_iterable">iterable</code></td>
<td>
<p>an iterable object, which could be an iterator.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An <code>ihasNext</code> iterator that wraps the specified iterator and supports
the <code>hasNext</code> method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  it &lt;- ihasNext(c('a', 'b', 'c'))
  while (hasNext(it))
    print(nextElem(it))
</code></pre>

<hr>
<h2 id='ilimit'>Create a limited iterator</h2><span id='topic+ilimit'></span>

<h3>Description</h3>

<p>Create an iterator that wraps a specified iterable a limited number of times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ilimit(iterable, n)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ilimit_+3A_iterable">iterable</code></td>
<td>
<p>Iterable to iterate over.</p>
</td></tr>
<tr><td><code id="ilimit_+3A_n">n</code></td>
<td>
<p>Maximum number of values to return.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Limit icount to only return three values
as.list(ilimit(icount(), 3))
</code></pre>

<hr>
<h2 id='ireadBin'>Create an iterator to read binary data from a connection</h2><span id='topic+ireadBin'></span>

<h3>Description</h3>

<p>Create an iterator to read binary data from a connection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ireadBin(con, what='raw', n=1L, size=NA_integer_, signed=TRUE,
         endian=.Platform$endian, ipos=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ireadBin_+3A_con">con</code></td>
<td>
<p>A connection object or a character string naming a file or a
raw vector.</p>
</td></tr>
<tr><td><code id="ireadBin_+3A_what">what</code></td>
<td>
<p>Either an object whose mode will give the mode of the vector
to be read, or a character vector of length one describing
the mode: one of &ldquo;numeric&rdquo;, &ldquo;double&rdquo;, &ldquo;integer&rdquo;,
&ldquo;int&rdquo;, &ldquo;logical&rdquo;, &ldquo;complex&rdquo;, &ldquo;character&rdquo;,
&ldquo;raw&rdquo;.  Unlike <code>readBin</code>, the default value is &ldquo;raw&rdquo;.</p>
</td></tr>
<tr><td><code id="ireadBin_+3A_n">n</code></td>
<td>
<p>integer.  The (maximal) number of records to be read each time
the iterator is called.</p>
</td></tr>
<tr><td><code id="ireadBin_+3A_size">size</code></td>
<td>
<p>integer.  The number of bytes per element in the byte stream.
The default, &lsquo;NA_integer_&rsquo;, uses the natural size.</p>
</td></tr>
<tr><td><code id="ireadBin_+3A_signed">signed</code></td>
<td>
<p>logical.  Only used for integers of sizes 1 and 2, when it
determines if the quantity on file should be regarded as a signed or
unsigned integer.</p>
</td></tr>
<tr><td><code id="ireadBin_+3A_endian">endian</code></td>
<td>
<p>The endian-ness ('&ldquo;big&rdquo;' or '&ldquo;little&rdquo;') of
the target system for the file.  Using '&ldquo;swap&rdquo;' will force swapping
endian-ness.</p>
</td></tr>
<tr><td><code id="ireadBin_+3A_ipos">ipos</code></td>
<td>
<p>iterable.  If not <code>NULL</code>, values from this iterable
will be used to do a seek on the file before calling readBin.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>zz &lt;- file("testbin", "wb")
writeBin(1:100, zz)
close(zz)

it &lt;- ihasNext(ireadBin("testbin", integer(), 10))
while (hasNext(it)) {
  print(nextElem(it))
}
unlink("testbin")
</code></pre>

<hr>
<h2 id='ireaddf'>Create an iterator to read data frames from files</h2><span id='topic+ireaddf'></span>

<h3>Description</h3>

<p>Create an iterator to read data frames from files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ireaddf(filenames, n, start=1, col.names, chunkSize=1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ireaddf_+3A_filenames">filenames</code></td>
<td>
<p>Names of files contains column data.</p>
</td></tr>
<tr><td><code id="ireaddf_+3A_n">n</code></td>
<td>
<p>Number of elements to read from each column file.</p>
</td></tr>
<tr><td><code id="ireaddf_+3A_start">start</code></td>
<td>
<p>Element to starting reading from.</p>
</td></tr>
<tr><td><code id="ireaddf_+3A_col.names">col.names</code></td>
<td>
<p>Names of the columns.</p>
</td></tr>
<tr><td><code id="ireaddf_+3A_chunksize">chunkSize</code></td>
<td>
<p>Number of rows to read at a time.</p>
</td></tr>
</table>

<hr>
<h2 id='irecord'>Record and replay iterators</h2><span id='topic+irecord'></span><span id='topic+ireplay'></span>

<h3>Description</h3>

<p>The <code>irecord</code> function records the values issued by a specified
iterator to a file or connection object.  The <code>ireplay</code> function
returns an iterator that will replay those values.  This is useful
for iterating concurrently over multiple, large matrices or data frames
that you can't keep in memory at the same time.  These large objects
can be recorded to files one at a time, and then be replayed
concurrently using minimal memory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irecord(con, iterable)
ireplay(con)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="irecord_+3A_con">con</code></td>
<td>
<p>A file path or open connection.</p>
</td></tr>
<tr><td><code id="irecord_+3A_iterable">iterable</code></td>
<td>
<p>The iterable to record to the file.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>suppressMessages(library(foreach))

m1 &lt;- matrix(rnorm(70), 7, 10)
f1 &lt;- tempfile()
irecord(f1, iter(m1, by='row', chunksize=3))

m2 &lt;- matrix(1:50, 10, 5)
f2 &lt;- tempfile()
irecord(f2, iter(m2, by='column', chunksize=3))

# Perform a simple out-of-core matrix multiply
p &lt;- foreach(col=ireplay(f2), .combine='cbind') %:%
       foreach(row=ireplay(f1), .combine='rbind') %do% {
         row %*% col
       }

dimnames(p) &lt;- NULL
print(p)
all.equal(p, m1 %*% m2)
unlink(c(f1, f2))
</code></pre>

<hr>
<h2 id='irep'>Create a repeating iterator</h2><span id='topic+irep'></span>

<h3>Description</h3>

<p>Create an iterator version of the <code>rep</code> function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irep(iterable, times, length.out, each)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="irep_+3A_iterable">iterable</code></td>
<td>
<p>The iterable to iterate over repeatedly.</p>
</td></tr>
<tr><td><code id="irep_+3A_times">times</code></td>
<td>
<p>A vector giving the number of times to repeat each element
if the length is greater than one, or to repeat all the elements if the
length is one.  This behavior is less strict than <code>rep</code> since the
length of an iterable isn't generally known.</p>
</td></tr>
<tr><td><code id="irep_+3A_length.out">length.out</code></td>
<td>
<p>non-negative integer.  The desired length of the output
iterator.</p>
</td></tr>
<tr><td><code id="irep_+3A_each">each</code></td>
<td>
<p>non-negative integer.  Each element of the iterable is repeated
<code>each</code> times.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+rep">rep</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>unlist(as.list(irep(1:4, 2)))
unlist(as.list(irep(1:4, each=2)))
unlist(as.list(irep(1:4, c(2,2,2,2))))
unlist(as.list(irep(1:4, c(2,1,2,1))))
unlist(as.list(irep(1:4, each=2, len=4)))
unlist(as.list(irep(1:4, each=2, len=10)))
unlist(as.list(irep(1:4, each=2, times=3)))
</code></pre>

<hr>
<h2 id='irepeat'>Create a repeating iterator</h2><span id='topic+irepeat'></span>

<h3>Description</h3>

<p>Create an iterator that returns a value a specified number of times.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irepeat(x, times)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="irepeat_+3A_x">x</code></td>
<td>
<p>The value to return repeatedly.</p>
</td></tr>
<tr><td><code id="irepeat_+3A_times">times</code></td>
<td>
<p>The number of times to repeat the value.  Default value is infinity.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Repeat a value 10 times
unlist(as.list(irepeat(42, 10)))
</code></pre>

<hr>
<h2 id='iRNGStream'>Iterators that support parallel RNG</h2><span id='topic+iRNGStream'></span><span id='topic+iRNGSubStream'></span>

<h3>Description</h3>

<p>The <code>iRNGStream</code> function creates an infinite iterator that calls
<code>nextRNGStream</code> repeatedly, and <code>iRNGSubStream</code> creates an
infinite iterator that calls <code>nextRNGSubStream</code> repeatedly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>iRNGStream(seed)
iRNGSubStream(seed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="iRNGStream_+3A_seed">seed</code></td>
<td>
<p>Either a single number to be passed to <code>set.seed</code> or a vector
to be passed to <code>nextRNGStream</code> or <code>nextRNGSubStream</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="base.html#topic+set.seed">set.seed</a></code>, <code><a href="parallel.html#topic+nextRNGStream">nextRNGStream</a></code>,
<code><a href="parallel.html#topic+nextRNGSubStream">nextRNGSubStream</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>it &lt;- iRNGStream(313)
print(nextElem(it))
print(nextElem(it))

## Not run: 
library(foreach)
foreach(1:3, rseed=iRNGSubStream(1970), .combine='c') %dopar% {
  RNGkind("L'Ecuyer-CMRG") # would be better to initialize workers only once
  assign('.Random.seed', rseed, pos=.GlobalEnv)
  runif(1)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='is.iterator'>Utilities for writing iterators</h2><span id='topic+is.iterator'></span><span id='topic+end_iteration'></span><span id='topic+iteration_has_ended'></span><span id='topic+new_iterator'></span>

<h3>Description</h3>

<p><code>is.iterator</code> indicates if an object is an iterator.
<code>end_iteration</code> throws an exception to signal that there
are no more values available in an iterator.
<code>iteration_has_ended</code> tests an exception to see if it
indicates that iteration has ended.
<code>new_iterator</code> returns an iterator object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is.iterator(x)
end_iteration()
iteration_has_ended(e)
new_iterator(nextElem, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.iterator_+3A_x">x</code></td>
<td>
<p>any object.</p>
</td></tr>
<tr><td><code id="is.iterator_+3A_e">e</code></td>
<td>
<p>a condition object.</p>
</td></tr>
<tr><td><code id="is.iterator_+3A_nextelem">nextElem</code></td>
<td>
<p>a function object that takes no arguments.</p>
</td></tr>
<tr><td><code id="is.iterator_+3A_...">...</code></td>
<td>
<p>not currently used.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Manually iterate using the iteration_has_ended function to help
it &lt;- iter(1:3)
tryCatch({
  stopifnot(is.iterator(it))
  repeat {
    print(nextElem(it))
  }
},
error=function(e) {
  if (!iteration_has_ended(e)) {
    stop(e)
  }
})
</code></pre>

<hr>
<h2 id='isplitCols'>Create an iterator that splits a matrix into block columns</h2><span id='topic+isplitCols'></span>

<h3>Description</h3>

<p>Create an iterator that splits a matrix into block columns.
You can specify either the number of blocks, using the <code>chunks</code>
argument, or the maximum size of the blocks, using the <code>chunkSize</code>
argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isplitCols(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isplitCols_+3A_x">x</code></td>
<td>
<p>Matrix to iterate over.</p>
</td></tr>
<tr><td><code id="isplitCols_+3A_...">...</code></td>
<td>
<p>Passed as the second and subsequent arguments to
<code>idiv</code> function.  Currently, <code>idiv</code> accepts either a value
for <code>chunks</code> or <code>chunkSize</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An iterator that returns submatrices of <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="iterators.html#topic+idiv">idiv</a>, <a href="#topic+isplitRows">isplitRows</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Split a matrix into submatrices with a maximum of three columns
x &lt;- matrix(1:30, 3)
it &lt;- ihasNext(isplitCols(x, chunkSize=3))
while (hasNext(it)) {
  print(nextElem(it))
}

# Split the same matrix into five submatrices
it &lt;- ihasNext(isplitCols(x, chunks=5))
while (hasNext(it)) {
  print(nextElem(it))
}
</code></pre>

<hr>
<h2 id='isplitIndices'>Create an iterator of indices</h2><span id='topic+isplitIndices'></span>

<h3>Description</h3>

<p>Create an iterator of chunks of indices from 1 to <code>n</code>.
You can specify either the number of pieces, using the <code>chunks</code>
argument, or the maximum size of the pieces, using the <code>chunkSize</code>
argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isplitIndices(n, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isplitIndices_+3A_n">n</code></td>
<td>
<p>Maximum index to generate.</p>
</td></tr>
<tr><td><code id="isplitIndices_+3A_...">...</code></td>
<td>
<p>Passed as the second and subsequent arguments to
<code>idiv</code> function.  Currently, <code>idiv</code> accepts either a value
for <code>chunks</code> or <code>chunkSize</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An iterator that returns vectors of indices from 1 to <code>n</code>.
</p>


<h3>See Also</h3>

<p><code><a href="iterators.html#topic+idiv">idiv</a>, <a href="#topic+isplitVector">isplitVector</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Return indices from 1 to 17 in vectors no longer than five
it &lt;- ihasNext(isplitIndices(17, chunkSize=5))
while (hasNext(it)) {
  print(nextElem(it))
}

# Return indices from 1 to 7 in four vectors
it &lt;- ihasNext(isplitIndices(7, chunks=4))
while (hasNext(it)) {
  print(nextElem(it))
}
</code></pre>

<hr>
<h2 id='isplitRows'>Create an iterator that splits a matrix into block rows</h2><span id='topic+isplitRows'></span>

<h3>Description</h3>

<p>Create an iterator that splits a matrix into block rows.
You can specify either the number of blocks, using the <code>chunks</code>
argument, or the maximum size of the blocks, using the <code>chunkSize</code>
argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isplitRows(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isplitRows_+3A_x">x</code></td>
<td>
<p>Matrix to iterate over.</p>
</td></tr>
<tr><td><code id="isplitRows_+3A_...">...</code></td>
<td>
<p>Passed as the second and subsequent arguments to
<code>idiv</code> function.  Currently, <code>idiv</code> accepts either a value
for <code>chunks</code> or <code>chunkSize</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An iterator that returns submatrices of <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="iterators.html#topic+idiv">idiv</a>, <a href="#topic+isplitCols">isplitCols</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Split a matrix into submatrices with a maximum of three rows
x &lt;- matrix(1:100, 10)
it &lt;- ihasNext(isplitRows(x, chunkSize=3))
while (hasNext(it)) {
  print(nextElem(it))
}

# Split the same matrix into five submatrices
it &lt;- ihasNext(isplitRows(x, chunks=5))
while (hasNext(it)) {
  print(nextElem(it))
}
</code></pre>

<hr>
<h2 id='isplitVector'>Create an iterator that splits a vector</h2><span id='topic+isplitVector'></span>

<h3>Description</h3>

<p>Create an iterator that splits a vector into smaller pieces.
You can specify either the number of pieces, using the <code>chunks</code>
argument, or the maximum size of the pieces, using the <code>chunkSize</code>
argument.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isplitVector(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="isplitVector_+3A_x">x</code></td>
<td>
<p>Vector to iterate over.  Note that it doesn't need to be an
atomic vector, so a list is acceptable.</p>
</td></tr>
<tr><td><code id="isplitVector_+3A_...">...</code></td>
<td>
<p>Passed as the second and subsequent arguments to
<code>idiv</code> function.  Currently, <code>idiv</code> accepts either a value
for <code>chunks</code> or <code>chunkSize</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An iterator that returns vectors of the same type as <code>x</code> with one
or more elements from <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="iterators.html#topic+idiv">idiv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Split the vector 1:10 into "chunks" with a maximum length of three
it &lt;- ihasNext(isplitVector(1:10, chunkSize=3))
while (hasNext(it)) {
  print(nextElem(it))
}

# Split the vector "letters" into four chunks
it &lt;- ihasNext(isplitVector(letters, chunks=4))
while (hasNext(it)) {
  print(nextElem(it))
}

# Get the first five elements of a list as a list
nextElem(isplitVector(as.list(letters), chunkSize=5))
</code></pre>

<hr>
<h2 id='izip'>Create an iterator over multiple iterables</h2><span id='topic+izip'></span>

<h3>Description</h3>

<p>Create an iterator that iterates over multiple iterables, returning
the values as a list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>izip(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="izip_+3A_...">...</code></td>
<td>
<p>The iterables to iterate over.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Iterate over two iterables of different sizes
as.list(izip(a=1:2, b=letters[1:3]))
</code></pre>

<hr>
<h2 id='product'>Create a cartesian product iterator</h2><span id='topic+product'></span>

<h3>Description</h3>

<p>Create an iterator that returns values from multiple iterators in
cartesian product fashion.  That is, they are combined the manner
of nested <code>for</code> loops.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>product(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="product_+3A_...">...</code></td>
<td>
<p>Named iterables to iterate over.  The right-most iterables
change more quickly, like an odometer.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate a doubly-nested loop with a single while loop
it &lt;- ihasNext(product(a=1:3, b=1:2))
while (hasNext(it)) {
  x &lt;- nextElem(it)
  cat(sprintf('a = %d, b = %d\n', x$a, x$b))
}
</code></pre>

<hr>
<h2 id='recycle'>Create a recycling iterator</h2><span id='topic+recycle'></span>

<h3>Description</h3>

<p>Create an iterator that recycles a specified iterable.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>recycle(iterable, times=NA_integer_)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="recycle_+3A_iterable">iterable</code></td>
<td>
<p>The iterable to recycle.</p>
</td></tr>
<tr><td><code id="recycle_+3A_times">times</code></td>
<td>
<p>integer.  Number of times to recycle the values in the iterator.
Default value of <code>NA_integer_</code> means to recycle forever.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Recycle over 'a', 'b', and 'c' three times
recycle(letters[1:3], 3)
</code></pre>

<hr>
<h2 id='timeout'>Create a timeout iterator</h2><span id='topic+timeout'></span>

<h3>Description</h3>

<p>Create an iterator that iterates over another iterator for a specified
period of time, and then stops.  This can be useful when you want to
search for something, or run a test for awhile, and then stop.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>timeout(iterable, time)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="timeout_+3A_iterable">iterable</code></td>
<td>
<p>Iterable to iterate over.</p>
</td></tr>
<tr><td><code id="timeout_+3A_time">time</code></td>
<td>
<p>The time interval to iterate for, in seconds.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># See how high we can count in a tenth of a second
length(as.list(timeout(icount(), 0.1)))
</code></pre>

<hr>
<h2 id='writedf.combiner'>Create an object that contains a combiner function</h2><span id='topic+writedf.combiner'></span>

<h3>Description</h3>

<p>Create an object that contains a combiner function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writedf.combiner(filenames)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="writedf.combiner_+3A_filenames">filenames</code></td>
<td>
<p>Names of files to write column data to.</p>
</td></tr>
</table>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
