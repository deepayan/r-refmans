<!DOCTYPE html><html lang="en"><head><title>Help for package blackbox</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {blackbox}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#blackbox'><p>Black box optimization and response surface exploration</p></a></li>
<li><a href='#bboptim'>
<p>Black-box function optimization</p></a></li>
<li><a href='#buildFONKgpointls'>
<p>Prepare data for smoothing</p></a></li>
<li><a href='#buildPointls'>
<p>Read a data file</p></a></li>
<li><a href='#calc1DCIs'>
<p>Compute 1D confidence intervals</p></a></li>
<li><a href='#calc1Dprofiles'>
<p>One and two-dimensional profiles, and surface plots</p></a></li>
<li><a href='#calcGCV'>
<p>Estimate smoothing parameters by generalized cross-validation (GCV)</p></a></li>
<li><a href='#calcLRTs'>
<p>Compute (profile) likelihood ratio tests</p></a></li>
<li><a href='#calcPredictorOK'>
<p>Generate smoothing predictor given smoothing parameters</p></a></li>
<li><a href='#init_grid'>
<p>Define starting points in parameter space.</p></a></li>
<li><a href='#islogscale'>
<p>Test for parameter log scale</p></a></li>
<li><a href='#maximizeOK'>
<p>Find maximum of predicted response surface</p></a></li>
<li><a href='#options'><p>blackbox options settings</p></a></li>
<li><a href='#ordinary-internal'><p>Internal ordinary Functions</p></a></li>
<li><a href='#prepareData'>
<p>Prepare data and controls for smoothing</p></a></li>
<li><a href='#preprocessbboptions'>
<p>Set controls for most functiosn in the package</p></a></li>
<li><a href='#sampleByResp'>
<p>Sample predictor points according to predicted response</p></a></li>
<li><a href='#saveOldFile'>
<p>Save a copy of an existing file.</p></a></li>
<li><a href='#writeFinalInfo'>
<p>Pretty output, and management of output files</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Black Box Optimization and Exploration of Parameter Space</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.46</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-12-08</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>François Rousset &lt;francois.rousset@umontpellier.fr&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>numDeriv, rcdd, geometry (&ge; 0.3-6), proxy, spaMM (&ge; 3.1.0),
lattice, Rcpp (&ge; 0.12.10), nloptr, MASS, pbapply, foreach,
matrixStats</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, minqa, lbfgsb3c, igraph</td>
</tr>
<tr>
<td>Description:</td>
<td>Performs prediction of a response function from simulated response values, allowing black-box optimization of functions estimated with some error. Includes a simple user interface for such applications, as well as more specialized functions designed to be called by the Migraine software (Rousset and Leblois, 2012 &lt;<a href="https://doi.org/10.1093%2Fmolbev%2FMSR262">doi:10.1093/molbev/MSR262</a>&gt;; Leblois et al., 2014 &lt;<a href="https://doi.org/10.1093%2Fmolbev%2Fmsu212">doi:10.1093/molbev/msu212</a>&gt;; and see URL). The latter functions are used for prediction of likelihood surfaces and implied likelihood ratio confidence intervals, and for exploration of predictor space of the surface. Prediction of the response is based on ordinary Kriging (with residual error) of the input. Estimation of smoothing parameters is performed by generalized cross-validation.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.cecill.info/licences/Licence_CeCILL_V2-en.txt">CeCILL-2</a></td>
</tr>
<tr>
<td>ByteCompile:</td>
<td>true</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://kimura.univ-montp2.fr/~rousset/Migraine.htm">https://kimura.univ-montp2.fr/~rousset/Migraine.htm</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-12-08 00:45:16 UTC; francois.rousset</td>
</tr>
<tr>
<td>Author:</td>
<td>François Rousset <a href="https://orcid.org/0000-0003-4670-0371"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Raphaël Leblois <a href="https://orcid.org/0000-0002-3051-4497"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-12-08 03:20:11 UTC</td>
</tr>
</table>
<hr>
<h2 id='blackbox'>Black box optimization and response surface exploration</h2><span id='topic+blackbox'></span><span id='topic+blackbox-package'></span>

<h3>Description</h3>

<p>blackbox allows prediction and optimization of a response function from simulated response values.  It also includes procedures designed mainly or only to be called, in a completely automated way without any input by users, by other R packages such as the <span class="pkg">Infusion</span> package, or by R code automatically generated by the Migraine software (see Details). For prediction, blackbox interfaces a C++ library for &ldquo;ordinary Kriging&rdquo; (which is jargon for: prediction in a linear mixed model with a constant term as fixed effect). It uses generalized cross validation (GCV) by default to estimate smoothing parameters.
</p>


<h3>Details</h3>

<p>Beyond the usage illustrated below, this package is used in particular for smoothing the output of the <code>Migraine</code> software for likelihood analysis of population genetic data
(<a href="https://kimura.univ-montp2.fr/~rousset/Migraine.htm">https://kimura.univ-montp2.fr/~rousset/Migraine.htm</a>). In the latter application  the response function is a simulated log-likelihood surface and the procedures generate plots of the (profile) log-likelihood, compute (profile) likelihood ratio confidence intervals, and design new parameter points where the likelihood should be simulated. This package provides documentation for all user-level functions in the R script written by Migraine. Control from Migraine uses many variables stored globally in the list of options accessible through <code>blackbox.options().</code>
</p>
<p>The C++ DLL was originally a C++ reimplementation of some of the internal functions of the <span class="pkg">fields</span> package, circa 2005-2006. To estimate smoothing parameters, it requires pairs of responses values for some values of the predictor variables, but will not allow more than pairs.
</p>


<h3>Author(s)</h3>

<p>François Rousset, with contributions by Raphaël Leblois.</p>


<h3>References</h3>

<p>Fields Development Team (2006). fields: Tools for Spatial Data. National Center for Atmospheric Research, Boulder, CO. <a href="https://www.image.ucar.edu/GSP/Software/Fields/">https://www.image.ucar.edu/GSP/Software/Fields/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>fr &lt;- function(v) { ## Rosenbrock Banana function with noise
  10 * (v["y"] - v["x"]^2)^2 + (1 - v["x"])^2 + rnorm(1,sd=0.1)
}
set.seed(123)

# Initial parameter values, including duplicates. See ?init_grid.
parsp &lt;- init_grid(lower=c(x=0,y=0),upper=c(x=2,y=2))

# add function values
simuls &lt;- cbind(parsp,bb=apply(parsp,1,"fr"))

## The following shows the backbone of the 'bboptim' code:

sorted_etc &lt;- prepareData(data=simuls)
#   Then smoothing using GCV (beware of implicit 'decreasing=FALSE' argument)
gcvres &lt;- calcGCV(sorted_etc)

## The results can be used as input to functions from other packages,
##  e.g. fitme from spaMM:
## Not run: 
require(spaMM)
fitme(bb ~ 1+Matern(1|x+y),data=sorted_etc,
          fixed=list(rho=1/gcvres$CovFnParam[c("x", "y")],
          #         note '1/...'
                      nu=gcvres$CovFnParam[["smoothness"]],
                      phi=gcvres$pureRMSE^2,
          # note distinct meaning of lambda notation in spaMM and blackbox
                      lambda=with(gcvres,(pureRMSE^2)/lambdaEst)))

## GCV is distinct from an REML fit:
fitme(bb ~ 1+Matern(1|x+y),data=sorted_etc,
          init=list(rho=c(1,1)), method="REML")

## End(Not run)

</code></pre>

<hr>
<h2 id='bboptim'>
Black-box function optimization
</h2><span id='topic+bboptim'></span><span id='topic+rbb'></span>

<h3>Description</h3>

<p><code>bboptim</code> implements optimization of a black-box function, possibly estimated with error, using prediction of the function by smoothing of its values in a given set of points, followed by a call to <code>optim</code> for optimization of the predicted function. <code>rbb</code> samples the parameter space of the function using a crude implementation of Expected Improvement (e.g. Bingham et al., 2014) methods: points with the highest predicted probability of improvement of the response value among a set of candidates sampled uniformly are retained.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bboptim(data, ParameterNames = NULL, respName = NULL, control = list(),
        force = FALSE, optimizers = blackbox.getOption("optimizers"), precision=1e-03)
rbb(object,n=NULL,from=NULL,focus=0.75)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="bboptim_+3A_data">data</code></td>
<td>

<p>A data frame including both function parameters and function values (or &ldquo;response&rdquo; values).
</p>
</td></tr>
<tr><td><code id="bboptim_+3A_parameternames">ParameterNames</code></td>
<td>

<p>A character vector, identifying the columns of the data that correspond to the function parameters. If NULL, all columns except the last are assumed to hold parameter values.   </p>
</td></tr>
<tr><td><code id="bboptim_+3A_respname">respName</code></td>
<td>

<p>A character string, identifying the column of the data that corresponds to the function values. If NULL, the last column is assumed to hold function values.   </p>
</td></tr>
<tr><td><code id="bboptim_+3A_control">control</code></td>
<td>
<p>A list passed to the <code>control</code> argument of the <code>optim</code> function; e.g., <code>list(fnscale=-1)</code> for  maximization.</p>
</td></tr>
<tr><td><code id="bboptim_+3A_force">force</code></td>
<td>
<p>Boolean, passed to <code>calcGCV</code>. TRUE forces the analysis of data without pairs of response values for given parameter values. This is <em>not</em> recommended as there <em>should</em> be such pairs. If the response is estimated with error, this is required for good smoothing. If it is deterministic, <code>bboptim</code> will learn it from the information provided by the pairs.</p>
</td></tr>
<tr><td><code id="bboptim_+3A_optimizers">optimizers</code></td>
<td>
<p>(A vector of) character strings, from which the optimization methods are selected. Default are that of <code><a href="#topic+calcGCV">calcGCV</a></code> for the smoothing step, and <code>nloptr</code> with its own <code>"NLOPT_LN_BOBYQA"</code> method for the smoothed function maximization. See the source of the function for other possible methods (the latter being subject to change with little notice).</p>
</td></tr>
<tr><td><code id="bboptim_+3A_object">object</code></td>
<td>
<p>An object of class <code>bboptim</code></p>
</td></tr>
<tr><td><code id="bboptim_+3A_n">n</code></td>
<td>
<p>Number of distinct points to be returned. n+1 points will be returned (see Details). If <code>NULL</code>, the following default value is used:
<code>min(2^(np+1),floor(10*(1+3*log(np))))</code>, where <code>np</code> is the number of function parameters.
</p>
</td></tr>
<tr><td><code id="bboptim_+3A_from">from</code></td>
<td>
<p>A larger (&gt;2n) number of points from which <code>n</code> are selected by an expected inmprovement criterion. If NULL, a default value computed as <code>n*floor(10*(1+3*log(np)))</code>, where <code>np</code> is the number of function parameters, is used. </p>
</td></tr>
<tr><td><code id="bboptim_+3A_focus">focus</code></td>
<td>
<p>A number between 0 and 1. Determines the proportion of points that are sampled closer to the currently inferred maximum (see Details).</p>
</td></tr>
<tr><td><code id="bboptim_+3A_precision">precision</code></td>
<td>
<p>target value of prediction variance in inferred optimum.</p>
</td></tr>
</table>


<h3>Details</h3>

 <p><code>rbb</code> selects a proportion <code>1-focus</code> of the returned points according to expected improvement, from points sampled uniformly in a space defined by a tesselation of the fitted <code>object</code>'s parameter points. They are completed to n-1 points, by points similarly selected but within a space defined by a selection of fitted points with the best predicted response values. Finally, two replicates of the predicted optimum (the <code>optim</code> <code>$par</code> result contained in the <code>object</code>) are included. A total of n+1 points (n distinct) is thus returned.
</p>
<p>Global optimization cannot be proven, but it is tested by the following criteria: (1) the predicted optimum is close enough to the optimum among assessed parameter points (i.e. either the optimum parameters are well approached or the function is flat in some way), and (2) the prediction variance at the inferred optimum is low enough (so that the predictions used in the first criterion can be trusted). Accordingly, <code>conv_crits</code> has elements (1) <code>objective</code> that indicates whether <code>optr$value</code> betters <code>optr_fitted$value</code> by more than <code>control$reltol</code>, if given, or else by more than <code>sqrt(.Machine$double.eps)</code>; and (2) <code>precision</code> that indicates whether variance of prediction error at the inferred optimum is lower than the target <code>precision</code>. This variance is computed as described for <code><a href="spaMM.html#topic+predict.HLfit">predict.HLfit</a></code>, with <code>variances=list(linPred=TRUE,dispVar=TRUE)</code>. 
</p>


<h3>Value</h3>

<p><code>bboptim</code> returns an object of class <code>bboptim</code>, a list which includes
</p>
<table role = "presentation">
<tr><td><code>optr</code></td>
<td>
<p>the result of the <code>optim</code> call</p>
</td></tr>
<tr><td><code>RMSE</code></td>
<td>
<p>the root meant square prediction error of response at the optimum <code>optr$par</code></p>
</td></tr>
<tr><td><code>optr_fitted</code></td>
<td>
<p>the best of the fitted points, with its fitted response value and prediction RMSE</p>
</td></tr>
<tr><td><code>fit</code></td>
<td>
<p>the predictor of the response (an <code>HLfit</code> object as returned by <code><a href="spaMM.html#topic+corrHLfit">corrHLfit</a></code>, with a <code>predict</code> method, etc.)</p>
</td></tr>
<tr><td><code>conv_crits</code></td>
<td>
<p>Indicators of convergence (see Details)</p>
</td></tr>
</table>
<p>and some other elements.
</p>
<p><code>rbb</code> returns a data frame.
</p>


<h3>References</h3>

<p>D. Bingham, P. Ranjan, and W.J. Welch (2014) Design of Computer Experiments for Optimization, Estimation of Function Contours, and Related Objectives, pp. 109-124 in Statistics in Action: A Canadian Outlook (J.F. Lawless, ed.). Chapman and Hall/CRC.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Classical toy example with optional noise
fr &lt;- function(v,sd) {   ## Rosenbrock Banana function 
  10 * (v["y"] - v["x"]^2)^2 + (1 - v["x"])^2 + rnorm(1,sd=sd)
}
set.seed(123)

# Initial parameter values, including duplicates. See ?init_grid.
parsp &lt;- init_grid(lower=c(x=0,y=0),upper=c(x=2,y=2),nUnique=25)

#### Without noise
# add function values
simuls &lt;- cbind(parsp,bb=apply(parsp,1,"fr",sd=0))

# optimization
bbresu &lt;- bboptim(simuls)
print(bbresu)

# refine with additional points
if (blackbox.getOption("example_maxtime")&gt;4) {
 while ( any( ! bbresu$conv_crits) ) {
  print(unlist(bbresu$optr[c("par","value")]))
  candidates &lt;- rbb(bbresu)
  newsimuls &lt;- cbind(candidates,bb=apply(candidates,1,"fr",sd=0))
  bbresu &lt;- bboptim(rbind(bbresu$fit$data,newsimuls))
 }
 print(bbresu)
}

#### With noise

if (blackbox.getOption("example_maxtime")&gt;78) {
 set.seed(123)
 simuls &lt;- cbind(parsp,bb=apply(parsp,1,"fr",sd=0.1))

 bbresu &lt;- bboptim(simuls, precision=0.02)
 
 while ( any( ! bbresu$conv_crits) ) {
  print(unlist(bbresu$optr[c("par","value")]))
  candidates &lt;- rbb(bbresu)
  newsimuls &lt;- cbind(candidates,bb=apply(candidates,1,"fr",sd=0.1))
  bbresu &lt;- bboptim(rbind(bbresu$fit$data,newsimuls), precision=0.02)
 }
 print(bbresu)
}

# basic plot
## Not run: 
require(spaMM)
opt &lt;- bbresu$optr$par
mapMM(bbresu$fit, decorations=points(opt[1],opt[2],cex=2,pch="+"))

## End(Not run)
</code></pre>

<hr>
<h2 id='buildFONKgpointls'>
Prepare data for smoothing
</h2><span id='topic+buildFONKgpointls'></span>

<h3>Description</h3>

<p>From a data frame, builds another data frame. The input data frame must contain values of the canonical parameters of the model and the variables required to construct the smoothed response. Which of the (output) parameters are variable is also determined for later use.       
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildFONKgpointls(pointls)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildFONKgpointls_+3A_pointls">pointls</code></td>
<td>

<p>A data frame obtained as return value from <code><a href="#topic+buildPointls">buildPointls</a></code>
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With controls set by the Migraine software, this can operate transformations of parameter space as well as transformations in logarithmic scale (see <code><a href="#topic+islogscale">islogscale</a></code>). The output frame will then contain values of transformed parameters. 
</p>


<h3>Value</h3>

<p>A data frame.
</p>

<hr>
<h2 id='buildPointls'>
Read a data file
</h2><span id='topic+buildPointls'></span>

<h3>Description</h3>

<p>This reads a data file into a data frame, performs various checks, assign namesto columns, and can select rows.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>buildPointls(dataFile = blackbox.getOption("dataFile"), respCols = NULL,
             subsetRows = NULL, ycolname, cleanResu = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="buildPointls_+3A_datafile">dataFile</code></td>
<td>

<p>Name of data file
</p>
</td></tr>
<tr><td><code id="buildPointls_+3A_respcols">respCols</code></td>
<td>

<p>A way to select response columns in later analyses (see Details). NULL or a numeric vector.
</p>
</td></tr>
<tr><td><code id="buildPointls_+3A_subsetrows">subsetRows</code></td>
<td>

<p>A set of rows to select. All rows are retained if this is NULL
</p>
</td></tr>
<tr><td><code id="buildPointls_+3A_ycolname">ycolname</code></td>
<td>

<p>A name to be given to the response variable; willbe used in many further outputs.
</p>
</td></tr>
<tr><td><code id="buildPointls_+3A_cleanresu">cleanResu</code></td>
<td>

<p>A connection, or a character string naming a file for some nicely formated output. If <code>""</code> (the default), print to the standard output connection.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input file is a an ASCII numeric data table with the following columns. The first columns contain values of all canonical parameters of the model in canonical order, as given by <code>blackbox.getOption{"ParameterNames"}</code>. Pairs of lines may have identical parameter vectors, but not more than pairs. The next columns may all be used as response variables.
</p>
<p><code>respCols</code> identifies columns that will be used to construct the smoothed response (but all columns are retained in this function's return value). If it is NULL, then the last column will be used. If a numeric vector, it identifies response columns (where column 1 is the first column after the parameters columns) which values will be summed to construct the response variable.
</p>


<h3>Value</h3>

<p>A data frame with as many columns as the input table.
As a side effect, the function sets the <code>blackbox.options ycolname</code> and <code>respCols</code> to respectively the input <code>ycolname</code> and to the column names deduced from the input <code>respCols</code> indices.
</p>

<hr>
<h2 id='calc1DCIs'>
Compute 1D confidence intervals
</h2><span id='topic+calc1DCIs'></span>

<h3>Description</h3>

<p>This computes 1D confidence intervals from an inferred likelihood surface by profile likelihood ratio methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc1DCIs(oneDimCIvars, FONKgNames, fittedNames, CIlevel = blackbox.getOption("CIlevel"),
          nextBounds = blackbox.getOption("nextBounds"),
          NextBoundsLevel = blackbox.getOption("NextBoundsLevel"),
          boundsOutfile = "", dataString = "", cleanResu = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc1DCIs_+3A_onedimcivars">oneDimCIvars</code></td>
<td>

<p>The names of parameters for which confidence intervals are computed
</p>
</td></tr>
<tr><td><code id="calc1DCIs_+3A_fonkgnames">FONKgNames</code></td>
<td>

<p>The names of &ldquo;Fitted Or Not&rdquo; parameters (see Details in <code><a href="#topic+blackbox.options">blackbox.options</a></code> for this concept)
</p>
</td></tr>
<tr><td><code id="calc1DCIs_+3A_fittednames">fittedNames</code></td>
<td>

<p>The names of fitted parameters (see Details in <code><a href="#topic+blackbox.options">blackbox.options</a></code> for this concept)
</p>
</td></tr>
<tr><td><code id="calc1DCIs_+3A_cilevel">CIlevel</code></td>
<td>

<p>Level (1-coverage) of the confidence intervals. Default is 0.05.
</p>
</td></tr>
<tr><td><code id="calc1DCIs_+3A_nextbounds">nextBounds</code></td>
<td>

<p>For development purposes, not documented
</p>
</td></tr>
<tr><td><code id="calc1DCIs_+3A_nextboundslevel">NextBoundsLevel</code></td>
<td>

<p>For development purposes, not documented
</p>
</td></tr>
<tr><td><code id="calc1DCIs_+3A_boundsoutfile">boundsOutfile</code></td>
<td>

<p>For development purposes, not documented
</p>
</td></tr>
<tr><td><code id="calc1DCIs_+3A_datastring">dataString</code></td>
<td>

<p>A prefix string in some outputs.
</p>
</td></tr>
<tr><td><code id="calc1DCIs_+3A_cleanresu">cleanResu</code></td>
<td>

<p>A connection, or a character string naming a file for some nicely formated output. If <code>""</code> (the default), print to the standard output connection.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns invisibly a list of profile points that met the CI level for each parameter.
</p>

<hr>
<h2 id='calc1Dprofiles'>
One and two-dimensional profiles, and surface plots
</h2><span id='topic+calc1Dprofiles'></span><span id='topic+calcProfileLR'></span><span id='topic+calc2D3Dplots'></span>

<h3>Description</h3>

<p>Assuming that <code><a href="#topic+calcPredictorOK">calcPredictorOK</a></code> and <code><a href="#topic+maximizeOK">maximizeOK</a></code> have been first run:
<code>calc1Dprofiles</code> plots 1D profiles of a predicted likelihood surface for each of the parameters. Poor profiles mayresult when only local optima are found for some parameter values. The next function provides an improvement over this.
<code>calcProfileLR</code> plots 2D profiles of the predicted response surface relative to its maximum for pairs of parameters. It also prots 1D profiles taking benefit of the computation effort for the 2D profiles.
<code>calc2D3Dplots</code> plots the predicted response surface (no profile) in different ways depending on the number of parameters.
</p>
<p>These functions have almost no arguments, as almost all control is through global controls. See in particular <code>gridStepsNbr</code> (for profile plots) and <code>graphicPars</code> in <code><a href="#topic+blackbox.options">blackbox.options</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calc1Dprofiles(varNames=blackbox.getOption("spec1DProfiles"))
calcProfileLR(varNames=blackbox.getOption("fittedNames"),
              pairlist=list(),
              cleanResu="")
calc2D3Dplots(plotFile=NULL,pairlist=list())
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calc1Dprofiles_+3A_plotfile">plotFile</code></td>
<td>
<p>If a character string, the name of the file where plots are written. Otherwise, plots are output to the screen.</p>
</td></tr>
<tr><td><code id="calc1Dprofiles_+3A_varnames">varNames</code></td>
<td>
<p>A character vector specifying the names of predictor variables to be considered. For <code>calc1Dprofiles</code> (used in conjunction with the <code>Migraine</code> software), if the default argument is <code>NULL</code>, all variable canonical parameters plus some composite ones may be considered (see the source code for details).</p>
</td></tr>
<tr><td><code id="calc1Dprofiles_+3A_pairlist">pairlist</code></td>
<td>
<p>A list of character vectors. Each vector describes a pair of predictor variables. With the default value <code>list()</code>, a default non-empty list may be constructed when <code>calc2D3Dplots</code> or <code>calcProfileLR</code> is typically used in conjunction with the <code>Migraine</code> software (see the source code for details).</p>
</td></tr>
<tr><td><code id="calc1Dprofiles_+3A_cleanresu">cleanResu</code></td>
<td>

<p>A connection, or a character string naming a file for some nicely formated output. If it is <code>""</code> (the default), print to the standard output connection.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If there is only <b>one</b> parameter, <code>calc2D3Dplots</code> plots the predicted response as function of this parameter
</p>
<p>If there are <b>two</b> parameters, <code>calc2D3Dplots</code> plots the response surface both as a 2D surface plot and as a 3D perspective plot, and <code>calcProfileLR</code> also produces a plot of the response surface (no profiling is needed) relative to its maximum (hence, a likelihood ratio, if the response is a likelihood).
</p>
<p>If there are <b>more</b> parameters, <code>calc2D3Dplots</code> plots a &ldquo;slice&rdquo; of the predicted surface, both as a 2D surface plot and as a 3D perspective plot, for each pair of parameters. A slice plot for a pair of parameters fixes all other parameters to values maximizing   the response (hence, maximum likelihood estimates, if the response is a likelihood). <code>calcProfileLR</code> plots the profile response surface relative to its maximum (hence, a profile likelihood ratio, if the response is a likelihood) for pairs of parameters in <code>varNames</code>.
</p>
<p>Two dimensional profile plots not only require many numerical maximizations, but will look ugly whenever one of these maximizations fails to find the right maximum, hence additional intensive computations are performed to minimize this problem. As a result, they are quite slow to compute, unless a low <code>gridStepsNbr</code> (say &lt; 16) is used, in which case they do not look smooth.
</p>


<h3>Value</h3>

<p>Returns NULL invisibly
</p>

<hr>
<h2 id='calcGCV'>
Estimate smoothing parameters by generalized cross-validation (GCV)
</h2><span id='topic+calcGCV'></span>

<h3>Description</h3>

<p>Smoothing is based on prediction in a linear mixed model (&ldquo;Kriging&rdquo;) with non-zero residual variance. The correlation function for the random effect is the Matern function with argument the Euclidian distance between scaled coordinates (x/scale). The Matern function also has a smoothness parameter. These parameters are by default estimated by GCV. For large data sets (say &gt;2000 rows), it is strongly recommended to select a subset of the data using <code>GCVptnbr</code>, as GCV will otherwise be very slow.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcGCV(sorted_data=data, data, CovFnParam = NULL, GCVptnbr = Inf,
       topmode = FALSE, verbose = FALSE, cleanResu = "",
       force=FALSE, decreasing=FALSE,
       verbosity = blackbox.getOption("verbosity"),
       optimizers = blackbox.getOption("optimizers"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calcGCV_+3A_sorted_data">sorted_data</code></td>
<td>

<p>A data frame with both predictor and response variance, sorted and with attributes, as produced by <code><a href="#topic+prepareData">prepareData</a></code>
</p>
</td></tr>
<tr><td><code id="calcGCV_+3A_data">data</code></td>
<td>
<p>Obsolete, for Migraine back-compatibility, should not be used.</p>
</td></tr>
<tr><td><code id="calcGCV_+3A_covfnparam">CovFnParam</code></td>
<td>

<p>Optional fixed values of scale factors for each predictor variable. Smoothness should not be included in this argument.
</p>
</td></tr>
<tr><td><code id="calcGCV_+3A_gcvptnbr">GCVptnbr</code></td>
<td>

<p>Maximum number of rows selected for GCV.
</p>
</td></tr>
<tr><td><code id="calcGCV_+3A_topmode">topmode</code></td>
<td>

<p>Controls the way rows are selected. For development purposes, should not be modified
</p>
</td></tr>
<tr><td><code id="calcGCV_+3A_verbose">verbose</code></td>
<td>

<p>Whether to print some messages or not. Distinct from <code>verbosity</code>
</p>
</td></tr>
<tr><td><code id="calcGCV_+3A_verbosity">verbosity</code></td>
<td>
<p>Distinct from <code>verbose</code>. See <code>verbosity</code> in <code><a href="#topic+blackbox.options">blackbox.options</a></code></p>
</td></tr>
<tr><td><code id="calcGCV_+3A_cleanresu">cleanResu</code></td>
<td>

<p>A connection, or a character string naming a file for some nicely formated output. If <code>""</code> (the default), print to the standard output connection.
</p>
</td></tr>
<tr><td><code id="calcGCV_+3A_force">force</code></td>
<td>
<p> Boolean. Forces the analysis of data without pairs of response values for given parameter values. </p>
</td></tr>
<tr><td><code id="calcGCV_+3A_optimizers">optimizers</code></td>
<td>
<p>A vector of) character strings, from which the optimization method is selected. Default is <code>nloptr</code> with its own <code>"NLOPT_LN_BOBYQA"</code> method. See the source of the function for other methods (the latter being subject to change with little notice).</p>
</td></tr>
<tr><td><code id="calcGCV_+3A_decreasing">decreasing</code></td>
<td>
<p> Boolean. Use TRUE if you want the result to be used in function maximization rather than minimization.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the following elements
</p>
<table role = "presentation">
<tr><td><code>CovFnParam</code></td>
<td>
<p>Scale parameters <b>and</b> smoothness parameter of the Matern correlation function</p>
</td></tr>
<tr><td><code>lambdaEst</code></td>
<td>
<p>Ratio of residual variance over random effect variance</p>
</td></tr>
<tr><td><code>pureRMSE</code></td>
<td>
<p>Estimate of root residual variance</p>
</td></tr>
</table>
<p>and possibly other elements.
</p>
<p>Global options <code>CovFnParam</code> is modified as a side effect.
</p>


<h3>References</h3>

<p>Golub, G. H., Heath, M. and Wahba, G. (1979) Generalized Cross-Validation as a method for choosing a good ridge parameter.
Technometrics 21: 215-223.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># see example on main doc page (?blackbox)
</code></pre>

<hr>
<h2 id='calcLRTs'>
Compute (profile) likelihood ratio tests
</h2><span id='topic+calcLRTs'></span>

<h3>Description</h3>

<p>Assuming that <code><a href="#topic+calcPredictorOK">calcPredictorOK</a></code> and <code><a href="#topic+maximizeOK">maximizeOK</a></code> have been first run and that the predicted response surface is a likelihood surface , this performs likelihood ratio (LR) tests for a list of parameter points. Profiles are computed if appropriate, i.e. is the point is lower-dimensional than the the parameter space.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcLRTs(testPointList, cleanResu = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calcLRTs_+3A_testpointlist">testPointList</code></td>
<td>

<p>A list of points in predictor (parameter) space. Each point is a numeric vector or list with named elements , the names being those of some parameters.</p>
</td></tr>
<tr><td><code id="calcLRTs_+3A_cleanresu">cleanResu</code></td>
<td>

<p>A connection, or a character string naming a file for some nicely formated output. If <code>""</code> (the default), print to the standard output connection.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a list with information about each LR test, except for tests that could not be performed (e.g. if the tested point is ousdie of the convex envelope of the parameter points from which the predictor has been built). The names of this list's elements are constructed from the tested points.
Eachelement is itself a list with elements
</p>
<table role = "presentation">
<tr><td><code>LRT</code></td>
<td>
<p>The LR statistics (twice the differnece in log-likelihood between maximized likelihood and profile for the input parameters)</p>
</td></tr>
<tr><td><code>pval</code></td>
<td>
<p>Associated Pvalue by standard chi-square approximation</p>
</td></tr>
<tr><td><code>profpt</code></td>
<td>
<p>Information about the profile point for the input parameters</p>
</td></tr>
<tr><td><code>maxpt</code></td>
<td>
<p>Information about the maximum likelihood point</p>
</td></tr>
</table>
<p>and other elements, not documented here.
</p>

<hr>
<h2 id='calcPredictorOK'>
Generate smoothing predictor given smoothing parameters
</h2><span id='topic+calcPredictorOK'></span>

<h3>Description</h3>

<p>Assuming that <code><a href="#topic+calcGCV">calcGCV</a></code> has been first run to estimate smoothing parameter, this produces a &ldquo;Kriging&rdquo; predictor of the response.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calcPredictorOK(FONKgpointls, minKrigPtNbr = blackbox.getOption("minKrigPtNbr"),
                krigmax = NULL, topmode = FALSE, rawPlots = TRUE, cleanResu = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="calcPredictorOK_+3A_fonkgpointls">FONKgpointls</code></td>
<td>

<p>Input data frame as produced by <code><a href="#topic+buildFONKgpointls">buildFONKgpointls</a></code>
</p>
</td></tr>
<tr><td><code id="calcPredictorOK_+3A_minkrigptnbr">minKrigPtNbr</code></td>
<td>

<p>NULL or numeric. At least this many rows (if available) should be selected for Kriging. The default value depends on the number p of predictor variables and is
90, 159,  500, 1307, 3050, 6560 for p from 1 to 6 (beyond which it is strongly advised to use a non-default value).
</p>
</td></tr>
<tr><td><code id="calcPredictorOK_+3A_krigmax">krigmax</code></td>
<td>

<p>NULL or Numeric. For large data sets the selected points are not &ldquo;Kriged&rdquo; all together. Rather, overlapping blocks of rows are selected and are Kriged separately. This sets the size of the blocks. Default depends on the operating system (see source code).
</p>
</td></tr>
<tr><td><code id="calcPredictorOK_+3A_topmode">topmode</code></td>
<td>

<p>Controls the way rows are selected. For development purposes, should not be modified
</p>
</td></tr>
<tr><td><code id="calcPredictorOK_+3A_rawplots">rawPlots</code></td>
<td>

<p>Boolean. Whether to plot one-dimensional &ldquo;profiles&rdquo; of the raw data.
</p>
</td></tr>
<tr><td><code id="calcPredictorOK_+3A_cleanresu">cleanResu</code></td>
<td>

<p>A connection, or a character string naming a file for some nicely formated output. If <code>""</code> (the default), print to the standard output connection.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns invisibly a list with many undocumented elements. Thislist is also stored as a global option <code>"fitobject"</code>.
</p>

<hr>
<h2 id='init_grid'>
Define starting points in parameter space.
</h2><span id='topic+init_grid'></span>

<h3>Description</h3>

<p>This function samples the space of estimated parameters. It also handles other fixed arguments that need to be passed to the function simulating the summary statistics (sample size is likely to be one such argument). The current sampling strategy is crude but achieves three desirable effects: it samples the points uniformly but not independently from each other, avoiding large gaps more than independent ampling would allow; it is not exactly a regular grid; and it can include replicates of some parameter points, required for good inference of a response surface when this inference includes a smoothing step of response values evaluated with some error (as is typical in applications of the Migraine software, for which this function was first conceived).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>init_grid(lower=c(par=0), upper=c(par=1), steps=NULL, nUnique=NULL, 
          nRepl=min(10L,nUnique), maxmin=TRUE, jitterFac=0.5)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="init_grid_+3A_lower">lower</code></td>
<td>

<p>A vector of lower bounds for the parameters, as well as fixed arguments to be passed to the function simulating the summary statistics. Elements must be named. 
</p>
</td></tr>
<tr><td><code id="init_grid_+3A_upper">upper</code></td>
<td>

<p>A vector of upper bounds for the parameters, as well as fixed parameters. Elements must be named and match those of <code>lower</code>.  
</p>
</td></tr>
<tr><td><code id="init_grid_+3A_steps">steps</code></td>
<td>

<p>Number of steps of the grid, in each dimension of estimated parameters. If NULL, a default value is defined from the other arguments. If a single value is given, it is applied to all dimensions. Otherwise, this must have the same length as <code>lower</code> and <code>upper</code> and named in the same way as the variable parameters in these arguments.    
</p>
</td></tr>
<tr><td><code id="init_grid_+3A_nunique">nUnique</code></td>
<td>

<p>Number of distinct values of parameter vectors in output. Default is an heuristic guess for good start from not too many points, computed as  <code>floor(50^((v/3)^(1/3)))</code> where <code>v</code> is the number of variable parameters.  
</p>
</td></tr>
<tr><td><code id="init_grid_+3A_nrepl">nRepl</code></td>
<td>

<p>Number of replicates of distinct values of parameter vectors in output.
</p>
</td></tr>
<tr><td><code id="init_grid_+3A_maxmin">maxmin</code></td>
<td>

<p>Boolean. If TRUE, use a greedy max-min strategy (GMM, inspired from Ravi et al. 1994) in the selection of points from a larger set of points generated by an hypercube-sampling step. If FALSE, <code>sample</code> is instead used for this second step. This may be useful as the default method becomes slow when thousands of points are to be sampled. GMM was always used in the second step prior to introduction of this argument. 
</p>
</td></tr>
<tr><td><code id="init_grid_+3A_jitterfac">jitterFac</code></td>
<td>

<p>Controls the amount of jitter of the points around regular grid nodes. The default value 0.5 means that a mode can move by up to half a grid step (independently in each dimension), so that two adjacent nodes moved toward each other can (almost) meet each other. 
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame. Each row defines a list of arguments of vector of the function simulating the summary statistics.
</p>


<h3>References</h3>

<p>Ravi S.S., Rosenkrantz D.J., Tayi G.K. 1994. Heuristic and special case algorithms for dispersion problems. Operations Research 42, 299-310.  
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
init_grid()
init_grid(lower=c(mu=2.8,s2=0.5,sample.size=20),
          upper=c(mu=5.2,s2=4.5,sample.size=20),
          steps=c(mu=7,s2=9),nUnique=63)
</code></pre>

<hr>
<h2 id='islogscale'>
Test for parameter log scale
</h2><span id='topic+islogscale'></span>

<h3>Description</h3>

<p>This tests whether a log scale is used for a parameter.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>islogscale(string, scale = blackbox.getOption("FONKgScale"),
           extraScale = blackbox.getOption("extraScale"))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="islogscale_+3A_string">string</code></td>
<td>

<p>Name of the parameter tested
</p>
</td></tr>
<tr><td><code id="islogscale_+3A_scale">scale</code></td>
<td>

<p>A vector of scales for parameters of the smoothed object (i.e. parameters in  <code>blackbox.getOption("FONKgNames")</code>, see Details in <code><a href="#topic+blackbox.options">blackbox.options</a></code>).
</p>
</td></tr>
<tr><td><code id="islogscale_+3A_extrascale">extraScale</code></td>
<td>

<p>A vector of scales for additional transformed parameters not in <code>blackbox.getOption("FONKgNames")</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean.
</p>

<hr>
<h2 id='maximizeOK'>
Find maximum of predicted response surface
</h2><span id='topic+maximizeOK'></span>

<h3>Description</h3>

<p>Assuming that <code><a href="#topic+calcPredictorOK">calcPredictorOK</a></code> has been first run to produce a predictor of  the response surface, this finds its constrained maximum in the convex envelope of the smoothed data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maximizeOK(fitobject = blackbox.getOption("fitobject"), cleanResu = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maximizeOK_+3A_fitobject">fitobject</code></td>
<td>

<p>Return object of <code><a href="#topic+calcPredictorOK">calcPredictorOK</a></code>.
</p>
</td></tr>
<tr><td><code id="maximizeOK_+3A_cleanresu">cleanResu</code></td>
<td>

<p>A connection, or a character string naming a file for some nicely formated output. If <code>""</code> (the default), print to the standard output connection.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with element
</p>
<table role = "presentation">
<tr><td><code>par</code></td>
<td>
<p>predictor values maximizing the predicted response (in the parameter space used for Kriging)</p>
</td></tr>
<tr><td><code>value</code></td>
<td>
<p>maximum of the predicted response</p>
</td></tr>
<tr><td><code>canonVP</code></td>
<td>
<p>Representation of <code>par</code> in canonical parameter space</p>
</td></tr>
</table>
<p>and possibly other elements (i) returned by an optimization function such as <code>optim</code>; (ii) values of additional transformed parameters; (iii) cryptic information whether maximization occurred at some boundary of the convex envelope.
</p>

<hr>
<h2 id='options'>blackbox options settings</h2><span id='topic+blackbox.options'></span><span id='topic+blackbox.getOption'></span><span id='topic+parallel'></span>

<h3>Description</h3>

<p>Allow the user to examine a variety of &ldquo;options&rdquo; (most of which are not true user options)
which affect operations of the blackbox package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>blackbox.options(...)

blackbox.getOption(x)

</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="options_+3A_x">x</code></td>
<td>
<p>a character string holding an option name.</p>
</td></tr>
<tr><td><code id="options_+3A_...">...</code></td>
<td>
<p>A named value or a list of named values. Most are not to be manipulated by users and are undocumented. Exceptions are:
</p>

<dl>
<dt><code>ParameterNames</code></dt><dd><p>See Details</p>
</dd>
<dt><code>FONKgNames</code></dt><dd><p>See Details</p>
</dd>
<dt><code>fittedNames</code></dt><dd><p>See Details</p>
</dd>
<dt><code>gridStepsNbr</code></dt><dd><p>Number of steps of the grid of value for each parameter in profile plots.</p>
</dd>
<dt><code>graphicPars</code></dt><dd><p>Graphic parameters used for most plots.</p>
</dd>
<dt><code>coreNbr</code></dt><dd><p>Number of cores that R can use for parallel profile computations (see Details for implementation of these).</p>
</dd>
<dt><code>verbosity=0</code>:</dt><dd><p>Controls display of information about generalized cross-validation.
<code>0</code> suppresses (most) messages.
<code>1</code> displays information about estimates and progress of the procedure.
Higher values display more information from the optimizer and possibly additional information.
</p>
</dd>
</dl>

</td></tr>
</table>


<h3>Details</h3>

<p>blackbox.options() provides an interface for changing options, many of which are undocumented has they are intended to by used only in conjunction with the Migraine software, in which case the Migraine documentation should be consulted.
</p>
<p>The package has been designed first to infer likelihood surfaces by smoothing estimated likelihood points in a model with some canonical parameters (<b>ParameterNames</b>). A transformed parameter space may be considered for smoothing, wherein some parameters are variable (<b>fittedNames</b>) and others may be constant. The transformed parameter space including constant parameters has names <b>FONKgNames</b> (FON for Fitted Or Not).
</p>
<p><code>blackbox</code> can perform in parallel manner the Migraine-specific computations of grids of profile log-likelihood values. See the Migraine documentation for user control of the requested number of cores; direct control through R code is possible by <code>blackbox.options(coreNbr=.)</code>. If the <code>doSNOW</code> back-end is attached (by explicit request from the user), it will be used; otherwise, <code>pbapply</code> will be used. Both provide progress bars, but <code>doSNOW</code> may provide more efficient load-balancing. 
</p>


<h3>Value</h3>

<p>For <code>blackbox.getOption</code>, the current value set for option <code>x</code>, or
<code>NULL</code> if the option is unset.
</p>
<p>For <code>blackbox.options()</code>, a list of all set options.  For
<code>blackbox.options(name)</code>, a list of length one containing the set value,
or <code>NULL</code> if it is unset.  For uses setting one or more options,
a list with the previous values of the options changed (returned
invisibly).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  blackbox.getOption("verbosity")
  ## Not run: 
  blackbox.options(verbosity=1)
  blackbox.options()
  
## End(Not run)
</code></pre>

<hr>
<h2 id='ordinary-internal'>Internal ordinary Functions</h2><span id='topic+projpath'></span><span id='topic+shrink_knots'></span><span id='topic++25+3D+3Dnc+25'></span><span id='topic++25innc+25'></span><span id='topic++25w+2Fo+25'></span><span id='topic+AUEformat'></span><span id='topic+CcovFocal'></span><span id='topic+GCV_lamVar_covFix_Wrapper'></span><span id='topic+Krig_coef_Wrapper'></span><span id='topic+R_GCV_lamVar_covFix'></span><span id='topic+getFnEvalCount'></span><span id='topic+newCSmooth'></span><span id='topic+flushCSmoothTable'></span><span id='topic+calcKnotsInfo'></span><span id='topic+profileByFullHull'></span><span id='topic+calcGridRelProfile'></span><span id='topic+indepCalcProfileLRforeachPoint'></span><span id='topic+calcBounds1D'></span><span id='topic+generateNextpointsfromCI'></span><span id='topic+toCanonical'></span><span id='topic+bbrhull'></span><span id='topic+CKrigcoefs'></span><span id='topic+Cpredict'></span><span id='topic+Hreprrational'></span><span id='topic+OKrig'></span><span id='topic+LRTfn'></span><span id='topic+LowUpFromKnots'></span><span id='topic+LowUpfn'></span><span id='topic+addSimplexEq'></span><span id='topic+addtoedges'></span><span id='topic+as.surface'></span><span id='topic+bounds1D'></span><span id='topic+calcKnotsInfoWrapper'></span><span id='topic+canonizeFromKrig'></span><span id='topic+checklogicalbounds'></span><span id='topic+condaxialS2fromg'></span><span id='topic+constrOptimR'></span><span id='topic+constrSymOrRefl'></span><span id='topic+constrSymOrReflWrapper'></span><span id='topic+deleteCSmooth'></span><span id='topic+eps'></span><span id='topic+euclidian'></span><span id='topic+calcGridFromxy'></span><span id='topic+findReplicates'></span><span id='topic+findglobalMLE'></span><span id='topic+fitinbounds'></span><span id='topic+formatName'></span><span id='topic+from2Ns2Tocanon'></span><span id='topic+fromFONKtoanyspace'></span><span id='topic+fromCanonToFONK'></span><span id='topic+generateFileName'></span><span id='topic+generateInitpts'></span><span id='topic+generateNewPoints'></span><span id='topic+generatePredictor'></span><span id='topic+get_os'></span><span id='topic+greedyMAXMINwithFixed'></span><span id='topic+gridfn'></span><span id='topic+groot'></span><span id='topic+handlesPointAtEdge'></span><span id='topic+insert.at'></span><span id='topic+isPointInCHull'></span><span id='topic+isoline'></span><span id='topic+knotsFromLRTlist'></span><span id='topic+knotsFromProfileEdges'></span><span id='topic+.ls.objects'></span><span id='topic+locatePointinvT'></span><span id='topic+lsos'></span><span id='topic+lsOK'></span><span id='topic+make.surface.grid'></span><span id='topic+makeplot'></span><span id='topic+makeplottypes'></span><span id='topic+maketicks'></span><span id='topic+mantissExp'></span><span id='topic+massBarycenter'></span><span id='topic+matchVertCons'></span><span id='topic+message.redef'></span><span id='topic+messageNAMED'></span><span id='topic+minimiseGCV'></span><span id='topic+myprettyW'></span><span id='topic+optimWrapper'></span><span id='topic+overmessage'></span><span id='topic+parse.grid.list'></span><span id='topic+plot.OKrig'></span><span id='topic+plot.OKriglistplus'></span><span id='topic+plotParPoints'></span><span id='topic+plot1DprofFrom2D'></span><span id='topic+plotSlice'></span><span id='topic+pointsToFONK'></span><span id='topic+predict.OKrig'></span><span id='topic+predict.OKriglistplus'></span><span id='topic+predict_surface'></span><span id='topic+prettyNamedUserValues'></span><span id='topic+prettyPlotMain'></span><span id='topic+prettyUserValues'></span><span id='topic+prettynum'></span><span id='topic+print.OKrig'></span><span id='topic+print.OKriglistplus'></span><span id='topic+print.bboptim'></span><span id='topic+summary.bboptim'></span><span id='topic+summary.OKriglistplus'></span><span id='topic+profileBySubHull'></span><span id='topic+provideCovFnParams'></span><span id='topic+provideDevice'></span><span id='topic+providePlotFile'></span><span id='topic+providefullhull'></span><span id='topic+provideHullwFallBack'></span><span id='topic+provideVertices'></span><span id='topic+prune_by_dist'></span><span id='topic+purefn'></span><span id='topic+RAMavail'></span><span id='topic+rawProfiles'></span><span id='topic+redundant.addVeq'></span><span id='topic+resetCHull'></span><span id='topic+rExpandedHull'></span><span id='topic+rhullByEI'></span><span id='topic+rhullByvT'></span><span id='topic+safeSurface.OKrig'></span><span id='topic+sampleStep'></span><span id='topic+savePredictor'></span><span id='topic+scdd.addHline'></span><span id='topic+setExtrapol'></span><span id='topic+setHullPrecMode'></span><span id='topic+selectFn'></span><span id='topic+selectByLR'></span><span id='topic+select_ByHull_ByLogic'></span><span id='topic+select_ByLogic'></span><span id='topic+set_extrapol_dlr_from_LRTs'></span><span id='topic+spaMM.colors'></span><span id='topic+stop.redef'></span><span id='topic+stripclosestpairs'></span><span id='topic+stripclosestpairsWrapper'></span><span id='topic+subHullWrapper'></span><span id='topic+summary.OKrig'></span><span id='topic+surface.OKrig'></span><span id='topic+symmetricKnots'></span><span id='topic+technicolorTitle'></span><span id='topic+temp_capture.output'></span><span id='topic+toDgmuFromCanonical'></span><span id='topic+tofKpredict.nohull'></span><span id='topic+tofullKrigingspace'></span><span id='topic+tolatt2Ns2'></span><span id='topic+toNMratioFromCanonical'></span><span id='topic+tomratioFromCanonical'></span><span id='topic+tom1overmuFromCanonical'></span><span id='topic+tom2overmuFromCanonical'></span><span id='topic+toNactNfounderratioFromCanonical'></span><span id='topic+toNfounderNancratioFromCanonical'></span><span id='topic+toNfounderratioFromCanonical'></span><span id='topic+toNratioFromCanonical'></span><span id='topic+toTgmuFromCanonical'></span><span id='topic+toUserValues'></span><span id='topic+transformx'></span><span id='topic+userunit'></span><span id='topic+verticesBarycenter'></span><span id='topic+volTriangulation'></span><span id='topic+volTriangulationWrapper'></span><span id='topic+rvolTriangulation'></span><span id='topic+subsimplices.volTriangulation'></span><span id='topic+rsimplex'></span><span id='topic+writeCleanNAMED'></span><span id='topic+writeoutput'></span><span id='topic+zoomProfile'></span>

<h3>Description</h3>

<p>Internal ordinary functions
</p>


<h3>Details</h3>

<p>These are not to be called by the user, or are waiting for documentation to be written.
</p>

<hr>
<h2 id='prepareData'>
Prepare data and controls for smoothing
</h2><span id='topic+prepareData'></span>

<h3>Description</h3>

<p>This sorts the data, identifies parameters and function value (response), identifies pairs of response values for identical parameter values, and may set some global controls in <code>blackbox.options()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepareData(data, ParameterNames=NULL, respName=NULL,
            verbose=TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="prepareData_+3A_data">data</code></td>
<td>

<p>A data frame including variables in <code>ParameterNames</code> and <code>respName</code>  </p>
</td></tr>
<tr><td><code id="prepareData_+3A_parameternames">ParameterNames</code></td>
<td>

<p>Names of the variables to be used as predictors of the smoothed surface. If NULL, all columns except the last are assumed to hold parameter values. </p>
</td></tr>
<tr><td><code id="prepareData_+3A_respname">respName</code></td>
<td>

<p>Name of the variable to be used as response of the smoothed surface. If NULL, the last column is assumed to hold function values.</p>
</td></tr>
<tr><td><code id="prepareData_+3A_verbose">verbose</code></td>
<td>

<p>Whether to print some information (in particular a message if replicate responses values are identical for given parameter values, whichwill be suspect in some applications)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the required variables, ordered by increasing values as in <code>do.call(order,data)</code>.
This may set some global controls in <code>blackbox.options()</code> as a side effect.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(spaMM)
data(blackcap) ## use dataset as template
sorted_etc &lt;- prepareData(data=blackcap,ParameterNames=c("longitude", "latitude"),
                    respName="means")
</code></pre>

<hr>
<h2 id='preprocessbboptions'>
Set controls for most functiosn in the package
</h2><span id='topic+preprocessbboptions'></span>

<h3>Description</h3>

<p>Preprocesses a list of argument. The return value of this function serves as argument to <code><a href="#topic+blackbox.options">blackbox.options</a></code> (see Examples). Providing in this way the information described in the Details section of <code>blackbox.options</code> is essential for further usage of the package functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>preprocessbboptions(optionList)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="preprocessbboptions_+3A_optionlist">optionList</code></td>
<td>

<p>A list, with named elements, which names will (mostly) match the names of options set by this function
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list, returned invisibly
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
GP &lt;- list(ParameterNames=c("theta_1","theta_2"))
pp &lt;- preprocessbboptions(GP)
do.call(blackbox.options, pp) ## essential

## End(Not run)
</code></pre>

<hr>
<h2 id='sampleByResp'>
Sample predictor points according to predicted response
</h2><span id='topic+sampleByResp'></span>

<h3>Description</h3>

<p>Assuming that <code><a href="#topic+calcPredictorOK">calcPredictorOK</a></code> and <code><a href="#topic+maximizeOK">maximizeOK</a></code> have been first run:
predictor points can be sampled in several ways: the convex hull of predictor points with predicted response higher than some threshold value can be sampled uniformly. An Expected Improvement (e.g. Bingham et al., 2014) strategy can be used; whereby points with the highest predicted probability of improvement of the response value among a set of candidates sampled uniformly are retained. An expanded convex hull allowing further exploration of predictor space can also be considered. This function performs various combinations of these methods and (if the response was treated as a likelihood surface) can further use information from any previous likelihood ratio test of confidence interval computations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sampleByResp(size = blackbox.getOption("nextPointNumber"), outfile = NULL, useEI,
             NextBoundsLevel = 0.001,
             threshold=qchisq(1-NextBoundsLevel, 1)/2,
             rnd.seed = NULL, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sampleByResp_+3A_size">size</code></td>
<td>

<p>sample size
</p>
</td></tr>
<tr><td><code id="sampleByResp_+3A_outfile">outfile</code></td>
<td>

<p>If not NULL, the name of an ASCII file where to print the result as a table.
</p>
</td></tr>
<tr><td><code id="sampleByResp_+3A_useei">useEI</code></td>
<td>

<p>Whether to use an expected improvement criterion
</p>
</td></tr>
<tr><td><code id="sampleByResp_+3A_nextboundslevel">NextBoundsLevel</code></td>
<td>

<p>Controls <code>threshold</code> in a way meaningful for log-likelihood surfaces
</p>
</td></tr>
<tr><td><code id="sampleByResp_+3A_threshold">threshold</code></td>
<td>

<p>Controls the threshold for selection of the vertices of the convex hull to be sampled, and for inclusion of candidate predictor points in the sample. This threshold corresponds to a difference between predicted value and maximum predicted value. The actual maximal difference for inclusion of vertices additionally depends on the residual error of the predictor.
</p>
</td></tr>
<tr><td><code id="sampleByResp_+3A_rnd.seed">rnd.seed</code></td>
<td>

<p>NULL (in which case nothing is done) or an integer (in which case <code>set.seed(seed=rnd.seed)</code> is called).
</p>
</td></tr>
<tr><td><code id="sampleByResp_+3A_verbose">verbose</code></td>
<td>

<p>To print information about evaluation, for development purposes.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sampling procedure is designed to balance exploration of new regions of the predictor space and filling the top of a likelihood surface, or accurately locating the maximum and bounds of one-dimensional profile likelihood confidence interval. Details are yet to be documented.
</p>


<h3>Value</h3>

<p>Returns the predictor points invisibly.
</p>


<h3>References</h3>

<p>D. Bingham, P. Ranjan, and W.J. Welch (2014) Design of Computer Experiments for Optimization, Estimation of Function Contours, and Related Objectives, pp. 109-124 in Statistics in Action: A Canadian Outlook (J.F. Lawless, ed.). Chapman and Hall/CRC.
</p>

<hr>
<h2 id='saveOldFile'>
Save a copy of an existing file.
</h2><span id='topic+saveOldFile'></span>

<h3>Description</h3>

<p>This checks if a file of given name already exists in the current directory, and if so saves a copy of it under an automatically generated name (see below).  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>saveOldFile(filename)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="saveOldFile_+3A_filename">filename</code></td>
<td>

<p>Name of file to be saved.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function copies the file named &ldquo;<em>first names.ext</em>&rdquo; under a name created by inserting a string of the form <code>.old_</code><code class="reqn">n</code> between &ldquo;<em>first names</em>&rdquo; and &ldquo;<em>.ext</em>&rdquo;, where <code class="reqn">n</code> is one more than the highest value for any file, matching the first names and extension, already in the current directory, and 0 if no file matches. For example, if <code>filename</code> is <code>my.beautiful.pdf</code>, it is copied as <code>my.beautiful.old_0.pdf</code> if no <code>my.beautiful.old_</code><code class="reqn">n</code><code>.pdf</code> file exists, and is is copied as <code>my.beautiful.old_4.pdf</code> if <code>my.beautiful.old_3.pdf</code> (and any lower <code class="reqn">n</code>) file exists.
</p>


<h3>Value</h3>

<p>Returns <code>""</code> if no file with given name was present on disk, FALSE if it failed to copy an existing old file, 
and the name of the copy if it successfully copied such a file.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
saveOldFile("same.story")

## End(Not run)
</code></pre>

<hr>
<h2 id='writeFinalInfo'>
Pretty output, and management of output files
</h2><span id='topic+writeFinalInfo'></span>

<h3>Description</h3>

<p>Final code of the R script written by the Migraine software (<a href="https://kimura.univ-montp2.fr/~rousset/Migraine.htm">https://kimura.univ-montp2.fr/~rousset/Migraine.htm</a>; see main documentation page for the package, for the context). This prints some information, close output files, and beeps to warn that a possibly long computation is finished.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>writeFinalInfo(cleanResu = "")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="writeFinalInfo_+3A_cleanresu">cleanResu</code></td>
<td>

<p>A connection, or a character string naming a file for some nicely formated output. If <code>""</code> (the default), print to the standard output connection.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns NULL invisibly.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
