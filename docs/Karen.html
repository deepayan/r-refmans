<!DOCTYPE html><html><head><title>Help for package Karen</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {Karen}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#get.cdn'><p>Get the cell differentiation network from a fitted Kalman Reaction Network.</p></a></li>
<li><a href='#get.fit'><p>Fit the state-space model to a clonal tracking dataset</p></a></li>
<li><a href='#get.sim.trajectories'><p>Simulate a clonal tracking dataset from a given cell differentiation network.</p></a></li>
<li><a href='#get.sMoments'><p>Get the first two-order smoothing moments from a fitted Kalman Reaction Network.</p></a></li>
<li><a href='#get.sMoments.avg'><p>Get the clone-average of the first two-order smoothing moments from a fitted Kalman Reaction Network.</p></a></li>
<li><a href='#nearestPD'><p>Nearest Positive Definite Matrix</p></a></li>
<li><a href='#Y_CT'><p>Clonal tracking data from clinical trials</p></a></li>
<li><a href='#Y_RM'><p>Rhesus Macaque clonal tracking dataset</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Kalman Reaction Networks</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0</td>
</tr>
<tr>
<td>Description:</td>
<td>This is a stochastic framework that combines biochemical reaction networks with extended Kalman filter and Rauch-Tung-Striebel smoothing. 
  This framework allows to investigate the dynamics of cell differentiation from high-dimensional clonal tracking data subject to measurement noise, false negative errors, and systematically unobserved cell types. 
  Our tool can provide statistical support to biologists in gene therapy clonal tracking studies for a deeper understanding of clonal reconstitution dynamics. Further details on the methods can be found in L. Del Core et al., (2022) &lt;<a href="https://doi.org/10.1101%2F2022.07.08.499353">doi:10.1101/2022.07.08.499353</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix, parallel, gaussquad, splines, scales, mvtnorm,
tmvtnorm, MASS, igraph, xtable, stringr, abind, expm, methods</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>R.rsp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-14 16:28:19 UTC; delcore.luca</td>
</tr>
<tr>
<td>Author:</td>
<td>Luca Del Core <a href="https://orcid.org/0000-0002-1672-6995"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre, cph],
  Danilo Pellin <a href="https://orcid.org/0000-0002-2647-0508"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Marco Grzegorczyk <a href="https://orcid.org/0000-0002-2604-9270"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, ths],
  Ernst Wit <a href="https://orcid.org/0000-0002-3671-9610"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    ths]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Luca Del Core &lt;l.del.core@rug.nl&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-15 07:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='get.cdn'>Get the cell differentiation network from a fitted Kalman Reaction Network.</h2><span id='topic+get.cdn'></span>

<h3>Description</h3>

<p>This function returns the cell differentiation network from a Kalman Reaction Network previously fitted on a clonal tracking dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.cdn(res.fit, edges.lab = FALSE, AIC = FALSE, cell.cols = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.cdn_+3A_res.fit">res.fit</code></td>
<td>
<p>A list returned by get.fit() containing the information of a fitted Kalman Reaction Network.</p>
</td></tr>
<tr><td><code id="get.cdn_+3A_edges.lab">edges.lab</code></td>
<td>
<p>(logical) Defaults to FALSE, in which case the labels (weights) will not be printed on the network edges.</p>
</td></tr>
<tr><td><code id="get.cdn_+3A_aic">AIC</code></td>
<td>
<p>(logical) Defaults to FALSE, in which case the Akaike Information Criterion is not reported.</p>
</td></tr>
<tr><td><code id="get.cdn_+3A_cell.cols">cell.cols</code></td>
<td>
<p>Color legend for the cell types. Defaults to NULL, in which case no color legend for the cell types is provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rcts &lt;- c("HSC-&gt;T", ## reactions
          "HSC-&gt;M",
          "T-&gt;0",
          "M-&gt;0")

cnstr &lt;- c("theta\\[\\'HSC-&gt;T\\'\\]=(theta\\[\\'T-&gt;0\\'\\])",
           "theta\\[\\'HSC-&gt;M\\'\\]=(theta\\[\\'M-&gt;0\\'\\])")
latsts &lt;- "HSC" ## latent cell types

ctps &lt;- unique(setdiff(c(sapply(rcts, function(r){ ## all cell types
  as.vector(unlist(strsplit(r, split = "-&gt;", fixed = TRUE)))
}, simplify = "array")), c("0", "1")))



Y0 &lt;- Y_CT$WAS[,setdiff(ctps,"HSC"),]
topClones &lt;- 2
Y0 &lt;- Y0[,,names(head(sort(apply(Y0!=0, 3, sum), decreasing = TRUE), topClones)),drop=FALSE]


## cluster parameters:
cl &lt;- parallel::makeCluster(2, type = "PSOCK")

## initial condition:
X0 &lt;- rep(0, length(ctps))
names(X0) &lt;- ctps
X0["HSC"] &lt;- 1

## mean vector and covariance matrix of X0:
m_0 &lt;- replicate(dim(Y0)[3], X0, simplify = "array")
colnames(m_0) &lt;- dimnames(Y0)[[3]]
P_0 &lt;- Matrix::Diagonal(length(ctps) * dim(Y0)[3], 10)
rownames(P_0) &lt;- colnames(P_0) &lt;- rep(dimnames(Y0)[[3]], each = length(ctps))

## fit Karen on data:
res.fit &lt;- get.fit(rct.lst = rcts,
                   constr.lst = cnstr,
                   latSts.lst = latsts,
                   ct.lst = ctps,
                   Y = Y0,
                   m0 = m_0,
                   P0 = P_0,
                   cl = cl,
                   list(nLQR = 1,
                        lmm = 0, ## needs to be &gt;=5 for real applications
                        pgtol = 0,
                        relErrfct = 1e-5,
                        tol = 1e-3,
                        maxit = 0, ## needs to be increased for real applications
                        maxitEM = 1, ## needs to be increased for real applications
                        trace = 1,
                        verbose = TRUE,
                        FORCEP = FALSE))
parallel::stopCluster(cl)

get.cdn(res.fit)
</code></pre>

<hr>
<h2 id='get.fit'>Fit the state-space model to a clonal tracking dataset</h2><span id='topic+get.fit'></span>

<h3>Description</h3>

<p>This function fits a state-space model to a clonal tracking dataset using an extended Kalman filter approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.fit(
  rct.lst,
  constr.lst = NULL,
  latSts.lst,
  ct.lst,
  Y,
  m0,
  P0,
  cl = getDefaultCluster(),
  control = list(nLQR = 3, lmm = 25, pgtol = 0, relErrfct = 1e-05, tol = 1e-09, maxit =
    1000, maxitEM = 10, trace = 1, verbose = TRUE, FORCEP = TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.fit_+3A_rct.lst">rct.lst</code></td>
<td>
<p>A list of biochemical reactions defining the cell differentiation network.
A differentiation move from cell type &quot;A&quot; to cell type &quot;B&quot; must be coded as &quot;A-&gt;B&quot;
Duplication of cell &quot;A&quot; must be coded as &quot;A-&gt;1&quot;
Death of cell &quot;A&quot; must be coded as &quot;A-&gt;0&quot;.</p>
</td></tr>
<tr><td><code id="get.fit_+3A_constr.lst">constr.lst</code></td>
<td>
<p>(defaults to NULL, when no constraints are needed) List of linear constraints that must be applied to the biochemical reactions.
For example, if we need the constraint &quot;A-&gt;B = B-&gt;C + B-&gt;D&quot;, this must be coded using the following syntax
c(&quot;theta\[\'A-&gt;B\'\]=(theta\[\'B-&gt;C\'\] + theta\[\'B-&gt;D\'\])&quot;).</p>
</td></tr>
<tr><td><code id="get.fit_+3A_latsts.lst">latSts.lst</code></td>
<td>
<p>List of the latent cell types. If for example counts are not available for cell types &quot;A&quot; and &quot;B&quot;, then latSts.lst = c(&quot;A&quot;, &quot;B&quot;).</p>
</td></tr>
<tr><td><code id="get.fit_+3A_ct.lst">ct.lst</code></td>
<td>
<p>List of all the cell types involved in the network formulation.
For example, if the network is defined by the biochemical reactions are A-&gt;B&quot; and &quot;A-&gt;C&quot;, then ct.lst = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;).</p>
</td></tr>
<tr><td><code id="get.fit_+3A_y">Y</code></td>
<td>
<p>A 3-dimensional array whose dimensions are the time, the cell type and the clone respectively.</p>
</td></tr>
<tr><td><code id="get.fit_+3A_m0">m0</code></td>
<td>
<p>mean vector of the initial condition <code class="reqn">x_0</code></p>
</td></tr>
<tr><td><code id="get.fit_+3A_p0">P0</code></td>
<td>
<p>covariance matrix of the initial condition <code class="reqn">x_0</code></p>
</td></tr>
<tr><td><code id="get.fit_+3A_cl">cl</code></td>
<td>
<p>An object of class &quot;cluster&quot; specifying the cluster to be used for parallel execution. See makeCluster for more information.
If the argument is not specified, the default cluster is used. See setDefaultCluster for information on how to set up a default cluster.</p>
</td></tr>
<tr><td><code id="get.fit_+3A_control">control</code></td>
<td>
<p>A a list of control parameters for the optimization routine:
</p>

<ul>
<li><p>&quot;nLQR&quot;(defaults to 3) is an integer giving the order of the Gauss-Legendre approximation for integrals.
</p>
</li>
<li><p>&quot;lmm&quot;(defaults to 25) is an integer giving the number of BFGS updates retained in the &quot;L-BFGS-B&quot; method.
</p>
</li>
<li><p>&quot;pgtol&quot;(defaults to 0 when check is suppressed) is a tolerance on the projected gradient
in the current search direction of the &quot;L-BFGS-B&quot; method.
</p>
</li>
<li><p>&quot;relErrfct&quot;(defaults to 1e-5) is the relative error on the function value for the &quot;L-BFGS-B&quot; optimization.
That is, the parameter &quot;factr&quot; of the optim() function is set to relErrfct/.Machine$double.eps.
</p>
</li>
<li><p>&quot;tol&quot;(defaults to 1e-9) is the relative error tolerance for the expectation-maximization algorithm
of the extended Kalman filter optimization. That is, the optimization is run until the relative error of the function
and of the parameter vector are lower than tol.
</p>
</li>
<li><p>&quot;maxit&quot;(defaults to 1000) The maximum number of iterations for the &quot;L-BFGS-B&quot; optimization.
</p>
</li>
<li><p>&quot;maxitEM&quot;(defaults to 10) The maximum number of iterations for the expectation-maximization algorithm.
</p>
</li>
<li><p>&quot;trace&quot;(defaults to 1) Non-negative integer. If positive, tracing information on the progress of the optimization is produced.
This parameter is also passed to the optim() function.
Higher values may produce more tracing information: for method &quot;L-BFGS-B&quot; there are six levels of tracing.
(To understand exactly what these do see the source code: higher levels give more detail.)
</p>
</li>
<li><p>&quot;verbose&quot;(defaults to TRUE) Logical value. If TRUE, then information messages on the progress of the
filtering/smoothing algorithm are printed to the console.
</p>
</li>
<li><p>&quot;FORCEP&quot;(defaults to TRUE) Logical value. If TRUE, then all the covariance matrices involved in the algorithm
are forced to be positive-definite and it helps the convergence of the optimization.
</p>
</li></ul>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following:
</p>

<ul>
<li><p>&quot;fit&quot;The output list returned by the optim() function (See documenttion of optim() for more details).
</p>
</li>
<li><p>&quot;bwd.res&quot;First two-order moments of the estimated smoothing distribution.
</p>
</li>
<li><p>&quot;m0.res&quot;Mean vector of the smoothing distribution at time t = 0.
</p>
</li>
<li><p>&quot;P0.res&quot;Covariance matrix of the smoothing distribution at time t = 0.
</p>
</li>
<li><p>&quot;AIC&quot;Akaike Information Criterion (AIC) of the fitted model.
</p>
</li>
<li><p>&quot;cloneChunks&quot;List containing the chunks of clones that have been defined for parallel-computing.
</p>
</li>
<li><p>&quot;V&quot;The net-effect matrix associated to the differentiation network.
</p>
</li>
<li><p>&quot;Y&quot;The complete clonal tracking dataset that includes also the missing cell types.
</p>
</li>
<li><p>&quot;rct.lst&quot;The list of biochemical reactions.
</p>
</li>
<li><p>&quot;constr.lst&quot;The linear constraints applied on the reactions.
</p>
</li>
<li><p>&quot;latSts.lst&quot;The missing/latent cell types.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>rcts &lt;- c("HSC-&gt;T", ## reactions
          "HSC-&gt;M",
          "T-&gt;0",
          "M-&gt;0")

cnstr &lt;- c("theta\\[\\'HSC-&gt;T\\'\\]=(theta\\[\\'T-&gt;0\\'\\])",
           "theta\\[\\'HSC-&gt;M\\'\\]=(theta\\[\\'M-&gt;0\\'\\])")
latsts &lt;- "HSC" ## latent cell types

ctps &lt;- unique(setdiff(c(sapply(rcts, function(r){ ## all cell types
  as.vector(unlist(strsplit(r, split = "-&gt;", fixed = TRUE)))
}, simplify = "array")), c("0", "1")))



Y0 &lt;- Y_CT$WAS[,setdiff(ctps,"HSC"),]
topClones &lt;- 2
Y0 &lt;- Y0[,,names(head(sort(apply(Y0!=0, 3, sum), decreasing = TRUE), topClones)),drop=FALSE]


## cluster parameters:
cl &lt;- parallel::makeCluster(2, type = "PSOCK")

## initial condition:
X0 &lt;- rep(0, length(ctps))
names(X0) &lt;- ctps
X0["HSC"] &lt;- 1

## mean vector and covariance matrix of X0:
m_0 &lt;- replicate(dim(Y0)[3], X0, simplify = "array")
colnames(m_0) &lt;- dimnames(Y0)[[3]]
P_0 &lt;- Matrix::Diagonal(length(ctps) * dim(Y0)[3], 10)
rownames(P_0) &lt;- colnames(P_0) &lt;- rep(dimnames(Y0)[[3]], each = length(ctps))

## fit Karen on data:
res.fit &lt;- get.fit(rct.lst = rcts,
                   constr.lst = cnstr,
                   latSts.lst = latsts,
                   ct.lst = ctps,
                   Y = Y0,
                   m0 = m_0,
                   P0 = P_0,
                   cl = cl,
                   list(nLQR = 1,
                        lmm = 0, ## needs to be &gt;=5 for real applications
                        pgtol = 0,
                        relErrfct = 1e-5,
                        tol = 1e-3,
                        maxit = 0, ## needs to be increased for real applications
                        maxitEM = 1, ## needs to be increased for real applications
                        trace = 1,
                        verbose = TRUE,
                        FORCEP = FALSE))
</code></pre>

<hr>
<h2 id='get.sim.trajectories'>Simulate a clonal tracking dataset from a given cell differentiation network.</h2><span id='topic+get.sim.trajectories'></span>

<h3>Description</h3>

<p>This function simulates clone-specific trajectories for a cell differentiation network associated to a set of (constrained) biochemical reactions,
cell types, and missing/latent cell types.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.sim.trajectories(
  rct.lst,
  constr.lst = NULL,
  latSts.lst,
  ct.lst,
  th,
  S,
  nCL,
  X0,
  s2 = 1e-08,
  r0 = 0,
  r1 = 0,
  f = 0,
  ntps,
  trunc = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.sim.trajectories_+3A_rct.lst">rct.lst</code></td>
<td>
<p>A list of biochemical reactions defining the cell differentiation network.
A differentiation move from cell type &quot;A&quot; to cell type &quot;B&quot; must be coded as &quot;A-&gt;B&quot;
Duplication of cell &quot;A&quot; must be coded as &quot;A-&gt;1&quot;
Death of cell &quot;A&quot; must be coded as &quot;A-&gt;0&quot;.</p>
</td></tr>
<tr><td><code id="get.sim.trajectories_+3A_constr.lst">constr.lst</code></td>
<td>
<p>(defaults to NULL, when no constraints are needed) List of linear constraints that must be applied to the biochemical reactions.
For example, if we need the constraint &quot;A-&gt;B = B-&gt;C + B-&gt;D&quot;, this must be coded using the following syntax
c(&quot;theta\[\'A-&gt;B\'\]=(theta\[\'B-&gt;C\'\] + theta\[\'B-&gt;D\'\])&quot;).</p>
</td></tr>
<tr><td><code id="get.sim.trajectories_+3A_latsts.lst">latSts.lst</code></td>
<td>
<p>List of the latent cell types. If for example counts are not available for cell types &quot;A&quot; and &quot;B&quot;, then latSts.lst = c(&quot;A&quot;, &quot;B&quot;).</p>
</td></tr>
<tr><td><code id="get.sim.trajectories_+3A_ct.lst">ct.lst</code></td>
<td>
<p>List of all the cell types involved in the network formulation.
For example, if the network is defined by the biochemical reactions are A-&gt;B&quot; and &quot;A-&gt;C&quot;, then ct.lst = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;).</p>
</td></tr>
<tr><td><code id="get.sim.trajectories_+3A_th">th</code></td>
<td>
<p>The vector parameter that must be used for simulation. The length of th equals the number of unconstrained reactions plus 2
(for the noise parameters <code class="reqn">(\rho_0, \rho_1)</code>). Only positive parameters can be provided.</p>
</td></tr>
<tr><td><code id="get.sim.trajectories_+3A_s">S</code></td>
<td>
<p>The length of each trajectory.</p>
</td></tr>
<tr><td><code id="get.sim.trajectories_+3A_ncl">nCL</code></td>
<td>
<p>An integer defining the number of distinct clones.</p>
</td></tr>
<tr><td><code id="get.sim.trajectories_+3A_x0">X0</code></td>
<td>
<p>A p-dimensional vector for the initial condition of the cell types,
where <code class="reqn">p</code> is the number of distinct cell types provided in ct.lst.</p>
</td></tr>
<tr><td><code id="get.sim.trajectories_+3A_s2">s2</code></td>
<td>
<p>(defaults to 1e-8) A positive value for the overall noise variance.</p>
</td></tr>
<tr><td><code id="get.sim.trajectories_+3A_r0">r0</code></td>
<td>
<p>(defaults to 0) A positive value for the intercept defining the
noise covariance matrix <code class="reqn">R_k = \rho_0 + \rho_1G_kX_k</code>).</p>
</td></tr>
<tr><td><code id="get.sim.trajectories_+3A_r1">r1</code></td>
<td>
<p>(defaults to 0) A positive value for the slope defining the
noise covariance matrix <code class="reqn">R_k = \rho_0 + \rho_1G_kX_k</code>).</p>
</td></tr>
<tr><td><code id="get.sim.trajectories_+3A_f">f</code></td>
<td>
<p>(defaults to 0) The fraction of measurements that must be considered as missing/latent.</p>
</td></tr>
<tr><td><code id="get.sim.trajectories_+3A_ntps">ntps</code></td>
<td>
<p>Number of time points to consider from the whole simulated clonal tracking dataset.</p>
</td></tr>
<tr><td><code id="get.sim.trajectories_+3A_trunc">trunc</code></td>
<td>
<p>(defaults to FALSE) Logical, indicating whether sampling from a truncated multivariate normal must be performed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following:
</p>

<ul>
<li><p>&quot;X&quot;The simulated process.
</p>
</li>
<li><p>&quot;Y&quot;The simulated noisy-corrupted measurements.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>rcts &lt;- c("HSC-&gt;T", ## reactions
          "HSC-&gt;M",
          "T-&gt;0",
          "M-&gt;0")

cnstr &lt;- NULL
latsts &lt;- "HSC" ## latent cell types

ctps &lt;- unique(setdiff(c(sapply(rcts, function(r){ ## all cell types
  as.vector(unlist(strsplit(r, split = "-&gt;", fixed = TRUE)))
}, simplify = "array")), c("0", "1")))

## simulation parameters:
S &lt;- 100 ## trajectories length
nCL &lt;- 2 ## number of clones
X0 &lt;- rep(0, length(ctps)) ## initial condition
names(X0) &lt;- ctps
X0["HSC"] &lt;- 1
ntps &lt;- 5 ## number of time-points
f_NA &lt;- 0 ## fraction of observed data

th.true &lt;- c(1.9538674, 1.0559815, 0.7232172, 0.7324133) ## dynamic parameters
names(th.true) &lt;- rcts
s2.true &lt;- 1e-8 ## additonal noise
r0.true &lt;- .1 ## intercept noise parameter
r1.true &lt;- .01 ## slope noise parameter

## simulate trajectories:
XY &lt;- get.sim.trajectories(rct.lst = rcts,
                           constr.lst = cnstr,
                           latSts.lst = latsts,
                           ct.lst = ctps,
                           th = th.true,
                           S = S,
                           nCL = nCL,
                           X0 = X0,
                           s2 = s2.true,
                           r0 = r0.true,
                           r1 = r1.true,
                           f = f_NA,
                           ntps = ntps,
                           trunc = FALSE)

XY$X ## process
XY$Y ## measurements
</code></pre>

<hr>
<h2 id='get.sMoments'>Get the first two-order smoothing moments from a fitted Kalman Reaction Network.</h2><span id='topic+get.sMoments'></span>

<h3>Description</h3>

<p>This function returns the first two-order smoothing moments from a Kalman Reaction Network previously fitted on a clonal tracking dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.sMoments(res.fit, X = NULL, cell.cols = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.sMoments_+3A_res.fit">res.fit</code></td>
<td>
<p>A list returned by get.fit() containing the information of a fitted Kalman Reaction Network.</p>
</td></tr>
<tr><td><code id="get.sMoments_+3A_x">X</code></td>
<td>
<p>Stochastic process. A 3-dimensional array whose dimensions are the time, the cell type and the clone respectively.</p>
</td></tr>
<tr><td><code id="get.sMoments_+3A_cell.cols">cell.cols</code></td>
<td>
<p>Color legend for the cell types. Defaults to NULL, in which case no color legend for the cell types is provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rcts &lt;- c("HSC-&gt;T", ## reactions
          "HSC-&gt;M",
          "T-&gt;0",
          "M-&gt;0")

cnstr &lt;- c("theta\\[\\'HSC-&gt;T\\'\\]=(theta\\[\\'T-&gt;0\\'\\])",
           "theta\\[\\'HSC-&gt;M\\'\\]=(theta\\[\\'M-&gt;0\\'\\])")
latsts &lt;- "HSC" ## latent cell types

ctps &lt;- unique(setdiff(c(sapply(rcts, function(r){ ## all cell types
  as.vector(unlist(strsplit(r, split = "-&gt;", fixed = TRUE)))
}, simplify = "array")), c("0", "1")))



Y0 &lt;- Y_CT$WAS[,setdiff(ctps,"HSC"),]
topClones &lt;- 2
Y0 &lt;- Y0[,,names(head(sort(apply(Y0!=0, 3, sum), decreasing = TRUE), topClones)),drop=FALSE]


## cluster parameters:
cl &lt;- parallel::makeCluster(2, type = "PSOCK")

## initial condition:
X0 &lt;- rep(0, length(ctps))
names(X0) &lt;- ctps
X0["HSC"] &lt;- 1

## mean vector and covariance matrix of X0:
m_0 &lt;- replicate(dim(Y0)[3], X0, simplify = "array")
colnames(m_0) &lt;- dimnames(Y0)[[3]]
P_0 &lt;- Matrix::Diagonal(length(ctps) * dim(Y0)[3], 10)
rownames(P_0) &lt;- colnames(P_0) &lt;- rep(dimnames(Y0)[[3]], each = length(ctps))

## fit Karen on data:
res.fit &lt;- get.fit(rct.lst = rcts,
                   constr.lst = cnstr,
                   latSts.lst = latsts,
                   ct.lst = ctps,
                   Y = Y0,
                   m0 = m_0,
                   P0 = P_0,
                   cl = cl,
                   list(nLQR = 1,
                        lmm = 0, ## needs to be &gt;=5 for real applications
                        pgtol = 0,
                        relErrfct = 1e-5,
                        tol = 1e-3,
                        maxit = 0, ## needs to be increased for real applications
                        maxitEM = 1, ## needs to be increased for real applications
                        trace = 1,
                        verbose = TRUE,
                        FORCEP = FALSE))
parallel::stopCluster(cl)
oldpar &lt;- par(no.readonly = TRUE)
par(mar = c(5,5,2,2), mfrow = c(1,3))
get.sMoments(res.fit)
par(oldpar)
</code></pre>

<hr>
<h2 id='get.sMoments.avg'>Get the clone-average of the first two-order smoothing moments from a fitted Kalman Reaction Network.</h2><span id='topic+get.sMoments.avg'></span>

<h3>Description</h3>

<p>This function returns the clone-average of the first two-order smoothing moments from a Kalman Reaction Network previously fitted on a clonal tracking dataset.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.sMoments.avg(res.fit, X = NULL, cell.cols = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.sMoments.avg_+3A_res.fit">res.fit</code></td>
<td>
<p>A list returned by get.fit() containing the information of a fitted Kalman Reaction Network.</p>
</td></tr>
<tr><td><code id="get.sMoments.avg_+3A_x">X</code></td>
<td>
<p>Stochastic process. A 3-dimensional array whose dimensions are the time, the cell type and the clone respectively.</p>
</td></tr>
<tr><td><code id="get.sMoments.avg_+3A_cell.cols">cell.cols</code></td>
<td>
<p>Color legend for the cell types. Defaults to NULL, in which case no color legend for the cell types is provided.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rcts &lt;- c("HSC-&gt;T", ## reactions
          "HSC-&gt;M",
          "T-&gt;0",
          "M-&gt;0")

cnstr &lt;- c("theta\\[\\'HSC-&gt;T\\'\\]=(theta\\[\\'T-&gt;0\\'\\])",
           "theta\\[\\'HSC-&gt;M\\'\\]=(theta\\[\\'M-&gt;0\\'\\])")
latsts &lt;- "HSC" ## latent cell types

ctps &lt;- unique(setdiff(c(sapply(rcts, function(r){ ## all cell types
  as.vector(unlist(strsplit(r, split = "-&gt;", fixed = TRUE)))
}, simplify = "array")), c("0", "1")))

Y0 &lt;- Y_CT$WAS[,setdiff(ctps,"HSC"),]
topClones &lt;- 2
Y0 &lt;- Y0[,,names(head(sort(apply(Y0!=0, 3, sum), decreasing = TRUE), topClones)),drop=FALSE]

## cluster parameters:
cl &lt;- parallel::makeCluster(2, type = "PSOCK")

## initial condition:
X0 &lt;- rep(0, length(ctps))
names(X0) &lt;- ctps
X0["HSC"] &lt;- 1

## mean vector and covariance matrix of X0:
m_0 &lt;- replicate(dim(Y0)[3], X0, simplify = "array")
colnames(m_0) &lt;- dimnames(Y0)[[3]]
P_0 &lt;- Matrix::Diagonal(length(ctps) * dim(Y0)[3], 10)
rownames(P_0) &lt;- colnames(P_0) &lt;- rep(dimnames(Y0)[[3]], each = length(ctps))

## fit Karen on data:
res.fit &lt;- get.fit(rct.lst = rcts,
                   constr.lst = cnstr,
                   latSts.lst = latsts,
                   ct.lst = ctps,
                   Y = Y0,
                   m0 = m_0,
                   P0 = P_0,
                   cl = cl,
                   list(nLQR = 1,
                        lmm = 0, ## needs to be &gt;=5 for real applications
                        pgtol = 0,
                        relErrfct = 1e-5,
                        tol = 1e-3,
                        maxit = 0, ## needs to be increased for real applications
                        maxitEM = 1, ## needs to be increased for real applications
                        trace = 1,
                        verbose = TRUE,
                        FORCEP = FALSE))
parallel::stopCluster(cl)
get.sMoments.avg(res.fit)
</code></pre>

<hr>
<h2 id='nearestPD'>Nearest Positive Definite Matrix</h2><span id='topic+nearestPD'></span>

<h3>Description</h3>

<p>This function first check if a matrix A is positive definite, typically a correlation or variance-covariance matrix.
If A is not positive definite, this function computes the nearest positive definite matrix of A using the function nearPD from package Matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nearestPD(A, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nearestPD_+3A_a">A</code></td>
<td>
<p>numeric <code class="reqn">n \times n</code> approximately positive definite matrix, typically an approximation to a correlation or covariance matrix.
If A is not symmetric (and ensureSymmetry is not false), symmpart(A) is used.</p>
</td></tr>
<tr><td><code id="nearestPD_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to nearPD (see package Matrix for details).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The nearest positive definite matrix of A.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nearestPD(diag(c(1,0,1)))
</code></pre>

<hr>
<h2 id='Y_CT'>Clonal tracking data from clinical trials</h2><span id='topic+Y_CT'></span>

<h3>Description</h3>

<p>A dataset containing clonal tracking cell counts from three different clinical trials.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Y_CT
</code></pre>


<h3>Format</h3>

<p>A list containing the clonal tracking data for each clinical trial (WAS, <code class="reqn">\beta 0 \beta E</code>, <code class="reqn">\beta S \beta S</code>).
Each clonal tracking dataset is a 3-dimensional array whose dimensions identify
</p>

<dl>
<dt>1</dt><dd><p>time, in months</p>
</dd>
<dt>2</dt><dd><p>cell types: T, B, NK, Macrophages(M) and Granulocytes(G)</p>
</dd>
<dt>3</dt><dd><p>unique barcodes (clones)</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://github.com/BushmanLab/HSC_diversity">https://github.com/BushmanLab/HSC_diversity</a>
</p>

<hr>
<h2 id='Y_RM'>Rhesus Macaque clonal tracking dataset</h2><span id='topic+Y_RM'></span>

<h3>Description</h3>

<p>A dataset containing clonal tracking cell counts from a Rhesus Macaque study.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Y_RM
</code></pre>


<h3>Format</h3>

<p>A list containing clonal tracking data for each animal (ZH33, ZH17, ZG66).
Each clonal tracking dataset is a 3-dimensional array whose dimensions identify
</p>

<dl>
<dt>1</dt><dd><p>time, in months</p>
</dd>
<dt>2</dt><dd><p>cell types: T, B, NK, Macrophages(M) and Granulocytes(G)</p>
</dd>
<dt>3</dt><dd><p>unique barcodes (clones)</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3979461/bin/NIHMS567927-supplement-02.xlsx">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3979461/bin/NIHMS567927-supplement-02.xlsx</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
