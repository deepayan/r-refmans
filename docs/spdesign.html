<!DOCTYPE html><html><head><title>Help for package spdesign</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {spdesign}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#spdesign-package'><p>spdesign: Designing Stated Preference Experiments</p></a></li>
<li><a href='#.onAttach'><p>Print package startup message</p></a></li>
<li><a href='#all_priors_and_levels_specified'><p>Check whether all priors and attributes have specified levels</p></a></li>
<li><a href='#any_duplicates'><p>Check whether any priors or attributes are specified with a value more than</p>
once</a></li>
<li><a href='#attribute_level_balance'><p>Check whether we can achieve attribute level balance</p></a></li>
<li><a href='#attribute_levels'><p>Generic for getting the attributes and levels from the utility function</p></a></li>
<li><a href='#attribute_names'><p>Generic for getting the attribute names</p></a></li>
<li><a href='#block'><p>Block the design</p></a></li>
<li><a href='#calculate_a_error'><p>A-error</p></a></li>
<li><a href='#calculate_c_error'><p>C-error</p></a></li>
<li><a href='#calculate_d_error'><p>D-error</p></a></li>
<li><a href='#calculate_efficiency'><p>Calculate efficiency</p></a></li>
<li><a href='#calculate_efficiency_criteria'><p>Calculate efficiency criteria</p></a></li>
<li><a href='#calculate_s_error'><p>S-error</p></a></li>
<li><a href='#clean_utility'><p>Cleans the utility expression</p></a></li>
<li><a href='#coef.spdesign'><p>Generic for extracting the vector of priors</p></a></li>
<li><a href='#contains_dummies'><p>Check whether the utility function contains dummy coded variables</p></a></li>
<li><a href='#cor'><p>Correlation</p></a></li>
<li><a href='#cycle'><p>Cycling of attribute levels</p></a></li>
<li><a href='#define_base_x_j'><p>Define base x_j</p></a></li>
<li><a href='#define_x_j'><p>Define x_j</p></a></li>
<li><a href='#derive_vcov'><p>Derive the variance covariance matrix of the design</p></a></li>
<li><a href='#derive_vcov_mnl'><p>Derive the variance covariance matrix for the MNL model</p></a></li>
<li><a href='#derive_vcov_rpl'><p>Derive the variance covariance matrix for the RPL model</p></a></li>
<li><a href='#digitize'><p>Expand the sequence of integers</p></a></li>
<li><a href='#dummy_names'><p>Find the position of the dummy coded attributes</p></a></li>
<li><a href='#evaluate_design_candidate'><p>Evaluate the design candidate</p></a></li>
<li><a href='#exclude'><p>Exclude rows from the candidate set</p></a></li>
<li><a href='#expand_attribute_levels'><p>Expand the list of attributes and levels to the &quot;wide&quot; format</p></a></li>
<li><a href='#extract_all_names'><p>Extract all names</p></a></li>
<li><a href='#extract_attribute_names'><p>Extract attribute names</p></a></li>
<li><a href='#extract_distribution'><p>Extract distributions</p></a></li>
<li><a href='#extract_level_occurrence'><p>Extract the frequency of levels</p></a></li>
<li><a href='#extract_named_values'><p>Extracts the named values of the utility function</p></a></li>
<li><a href='#extract_param_distribution'><p>Extract the parameter distribution</p></a></li>
<li><a href='#extract_param_names'><p>Extract parameter names</p></a></li>
<li><a href='#extract_prior_distribution'><p>Extract the prior distribution</p></a></li>
<li><a href='#extract_specified'><p>Extract specified</p></a></li>
<li><a href='#extract_unparsed_values'><p>Extract unparsed named values of the utilitiy function</p></a></li>
<li><a href='#extract_values'><p>Extract the value argument(s)</p></a></li>
<li><a href='#federov'><p>Find a design using a modified Federov algorithm</p></a></li>
<li><a href='#fits_lvl_occurrences'><p>Test whether a design candidate fits the constraints imposed by the level</p>
occurrences</a></li>
<li><a href='#full_factorial'><p>Generate the full factorial</p></a></li>
<li><a href='#generate_design'><p>Generate an efficient experimental design</p></a></li>
<li><a href='#generate_rsc_candidate'><p>Generates a candidate for the RSC algorithm</p></a></li>
<li><a href='#has_bayesian_prior'><p>Tests whether the utility expression contains Bayesian priors</p></a></li>
<li><a href='#has_random_parameter'><p>Tests whether the utility expression contains random parameters</p></a></li>
<li><a href='#is_balanced'><p>Tests whether a utility function is balanced</p></a></li>
<li><a href='#lvl_occurrences'><p>Attribute level occurrence lookup tables</p></a></li>
<li><a href='#make_draws'><p>Make random draws</p></a></li>
<li><a href='#make_mlhs'><p>Make Modified Latin Hypercube Draws</p></a></li>
<li><a href='#make_pseudo_random'><p>Make pseudo random draws</p></a></li>
<li><a href='#make_scrambled_halton'><p>Make scrambled Halton draws</p></a></li>
<li><a href='#make_scrambled_sobol'><p>Make scrambled sobol draws</p></a></li>
<li><a href='#make_standard_halton'><p>Wrapper for halton()</p></a></li>
<li><a href='#make_standard_sobol'><p>Make sobol draws</p></a></li>
<li><a href='#min_lvl_occurrence'><p>Find minimum level occurrences</p></a></li>
<li><a href='#nlvls'><p>Find the number of levels</p></a></li>
<li><a href='#normal'><p>Evaluating a distribution</p></a></li>
<li><a href='#occurrences'><p>Extract or set attribute level occurrences</p></a></li>
<li><a href='#prepare_priors'><p>Prepare the list of priors</p></a></li>
<li><a href='#print_efficiency_criteria'><p>Creates a printable version of the efficiency criteria</p></a></li>
<li><a href='#print_initial_header'><p>Prints the initial header for the table of results</p></a></li>
<li><a href='#print_iteration_information'><p>Prints iteration information</p></a></li>
<li><a href='#print.spdesign'><p>A generic function for printing an 'spdesign' object</p></a></li>
<li><a href='#priors'><p>Generic for extracting the vector of priors</p></a></li>
<li><a href='#probabilities'><p>Calculate the probabilities of the design</p></a></li>
<li><a href='#probabilities_mnl'><p>Calculate the MNL probabilities</p></a></li>
<li><a href='#radical_inverse'><p>Compute the radical inverse</p></a></li>
<li><a href='#random'><p>Make a random design</p></a></li>
<li><a href='#random_design_candidate'><p>Create a random design_object candidate</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#relabel'><p>Relabeling of attribute levels</p></a></li>
<li><a href='#remove_all_brackets'><p>Removes all brackets</p></a></li>
<li><a href='#remove_prior'><p>Removes the parameter from the utility string</p></a></li>
<li><a href='#remove_round_brackets'><p>Remove round bracket</p></a></li>
<li><a href='#remove_square_brackets'><p>Remove square bracket</p></a></li>
<li><a href='#remove_whitespace'><p>Remove all white spaces</p></a></li>
<li><a href='#rep_cols'><p>Repeat columns</p></a></li>
<li><a href='#rep_rows'><p>Repeat rows</p></a></li>
<li><a href='#rsc'><p>Make a design candidate based on the rsc algorithm</p></a></li>
<li><a href='#set_default_level_occurrence'><p>Sets the default level occurrence in an attribute level balanced design</p></a></li>
<li><a href='#set_default_options'><p>Validate design opt</p></a></li>
<li><a href='#shuffle'><p>Shuffle the order of points in the unit interval.</p></a></li>
<li><a href='#summary.spdesign'><p>Create a summary of the experimental design</p></a></li>
<li><a href='#swap'><p>Swapping of attribute</p></a></li>
<li><a href='#too_small'><p>Check if the design is too small</p></a></li>
<li><a href='#transform_distribution'><p>Transform distribution</p></a></li>
<li><a href='#transform_lognormal'><p>Transform to the lognormal distribution</p></a></li>
<li><a href='#transform_normal'><p>Transform to the normal distribution</p></a></li>
<li><a href='#transform_triangular'><p>Transform to the triangular distribution</p></a></li>
<li><a href='#transform_uniform'><p>Transform to the uniform distribution</p></a></li>
<li><a href='#update_utility'><p>Update the utility function</p></a></li>
<li><a href='#utility_formula'><p>Create formulas from the utility functions</p></a></li>
<li><a href='#vcov.spdesign'><p>Extract the variance co-variance matrix</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Designing Stated Preference Experiments</td>
</tr>
<tr>
<td>Version:</td>
<td>0.0.3</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Erlend Dancke Sandorf &lt;erlend.dancke.sandorf@nmbu.no&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Contemporary software commonly used to design stated preference experiments are expensive and the code is closed source. This is a free software package with an easy to use interface to make flexible stated preference experimental designs using state-of-the-art methods. For an overview of stated choice experimental design theory, see e.g., Rose, J. M. &amp; Bliemer, M. C. J. (2014) in Hess S. &amp; Daly. A. &lt;<a href="https://doi.org/10.4337%2F9781781003152">doi:10.4337/9781781003152</a>&gt;. The package website can be accessed at <a href="https://spdesign.edsandorf.me">https://spdesign.edsandorf.me</a>. We acknowledge funding from the European Union’s Horizon 2020 research and innovation program under the Marie Sklodowska-Curie grant INSPiRE (Grant agreement ID: 793163).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://creativecommons.org/licenses/by-sa/4.0">CC BY-SA 4.0</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://spdesign.edsandorf.me">https://spdesign.edsandorf.me</a>,
<a href="https://github.com/edsandorf/spdesign">https://github.com/edsandorf/spdesign</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.0.0), stringr</td>
</tr>
<tr>
<td>Imports:</td>
<td>cli, future, randtoolbox, matrixStats, dplyr, tibble</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-16 07:06:00 UTC; edsandorf</td>
</tr>
<tr>
<td>Author:</td>
<td>Erlend Dancke Sandorf [aut, cre],
  Danny Campbell [aut]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-16 10:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='spdesign-package'>spdesign: Designing Stated Preference Experiments</h2><span id='topic+spdesign'></span><span id='topic+spdesign-package'></span>

<h3>Description</h3>

<p>Contemporary software commonly used to design stated preference experiments are expensive and the code is closed source. This is a free software package with an easy to use interface to make flexible stated preference experimental designs using state-of-the-art methods. For an overview of stated choice experimental design theory, see e.g., Rose, J. M. &amp; Bliemer, M. C. J. (2014) in Hess S. &amp; Daly. A. <a href="https://doi.org/10.4337/9781781003152">doi:10.4337/9781781003152</a>. The package website can be accessed at <a href="https://spdesign.edsandorf.me">https://spdesign.edsandorf.me</a>. We acknowledge funding from the European Union’s Horizon 2020 research and innovation program under the Marie Sklodowska-Curie grant INSPiRE (Grant agreement ID: 793163).
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Erlend Dancke Sandorf <a href="mailto:erlend.dancke.sandorf@nmbu.no">erlend.dancke.sandorf@nmbu.no</a>
</p>
<p>Authors:
</p>

<ul>
<li><p> Danny Campbell <a href="mailto:danny.campbell@stir.ac.uk">danny.campbell@stir.ac.uk</a>
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://spdesign.edsandorf.me">https://spdesign.edsandorf.me</a>
</p>
</li>
<li> <p><a href="https://github.com/edsandorf/spdesign">https://github.com/edsandorf/spdesign</a>
</p>
</li></ul>


<hr>
<h2 id='.onAttach'>Print package startup message</h2><span id='topic+.onAttach'></span>

<h3>Description</h3>

<p>The function is called when the package is loaded through library or require.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.onAttach(libname, pkgname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id=".onAttach_+3A_libname">libname</code></td>
<td>
<p>Library name</p>
</td></tr>
<tr><td><code id=".onAttach_+3A_pkgname">pkgname</code></td>
<td>
<p>Package name</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing
</p>

<hr>
<h2 id='all_priors_and_levels_specified'>Check whether all priors and attributes have specified levels</h2><span id='topic+all_priors_and_levels_specified'></span>

<h3>Description</h3>

<p>Check whether all priors and attributes have specified levels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_priors_and_levels_specified(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="all_priors_and_levels_specified_+3A_x">x</code></td>
<td>
<p>A list of utility expressions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean equal to 'TRUE' if all are specified and 'FALSE' if not
</p>

<hr>
<h2 id='any_duplicates'>Check whether any priors or attributes are specified with a value more than
once</h2><span id='topic+any_duplicates'></span>

<h3>Description</h3>

<p>Check whether any priors or attributes are specified with a value more than
once
</p>


<h3>Usage</h3>

<pre><code class='language-R'>any_duplicates(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="any_duplicates_+3A_x">x</code></td>
<td>
<p>A list of utility expressions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean equal to 'TRUE' if specified more than once.
</p>

<hr>
<h2 id='attribute_level_balance'>Check whether we can achieve attribute level balance</h2><span id='topic+attribute_level_balance'></span>

<h3>Description</h3>

<p>Check whether we can achieve attribute level balance
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attribute_level_balance(x, rows)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="attribute_level_balance_+3A_x">x</code></td>
<td>
<p>A list of utility expressions</p>
</td></tr>
<tr><td><code id="attribute_level_balance_+3A_rows">rows</code></td>
<td>
<p>The number of rows in the design</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean equal to 'TRUE' if attribute level balance can be achieved
and 'FALSE' otherwise
</p>

<hr>
<h2 id='attribute_levels'>Generic for getting the attributes and levels from the utility function</h2><span id='topic+attribute_levels'></span>

<h3>Description</h3>

<p>Generic for getting the attributes and levels from the utility function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attribute_levels(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="attribute_levels_+3A_x">x</code></td>
<td>
<p>An object of class utility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of attribute levels
</p>

<hr>
<h2 id='attribute_names'>Generic for getting the attribute names</h2><span id='topic+attribute_names'></span>

<h3>Description</h3>

<p>Generic for getting the attribute names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>attribute_names(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="attribute_names_+3A_x">x</code></td>
<td>
<p>An object of class utility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of attribute names
</p>

<hr>
<h2 id='block'>Block the design</h2><span id='topic+block'></span>

<h3>Description</h3>

<p>The function will take an object of class 'spdesign' and add a blocking
column to the design matrix. The function will use random permutations of
the blocking column to find the column that minimizes correlation between
the blocking column and the design columns. Specifically the target for the
minimization procedure is the mean squared correlation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>block(x, blocks, target = 5e-04, max_iter = 1e+06)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="block_+3A_x">x</code></td>
<td>
<p>An object of class 'spdesign'</p>
</td></tr>
<tr><td><code id="block_+3A_blocks">blocks</code></td>
<td>
<p>An integer giving the number of blocks. The number of blocks
must be a multiple of the number of rows to ensure equal number of choices
within a block.</p>
</td></tr>
<tr><td><code id="block_+3A_target">target</code></td>
<td>
<p>A target value for the mean squared correlation. The default
value is 0.0005. Setting the target to 0 forces the function to search all
'max_iter' blocking candidates</p>
</td></tr>
<tr><td><code id="block_+3A_max_iter">max_iter</code></td>
<td>
<p>The maximum number of candidates to consider before returning
the best blocking candidate. The default value is 1000000.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses a random permutation so every time you run the function
you will get a slightly different blocking column. You can set a seed prior
to calling the function to always return the same blocking vector.
</p>
<p>If you pass in a design that already contains a blocking column, then this
blocking column will be replaced without warning.
</p>


<h3>Value</h3>

<p>A modified 'spdesign' object where the design is replaced with the
same design and a blocking column. In addition a correlation vector, number
of iterations and the target value are returned as part of the modified
'spdesign' object.
</p>

<hr>
<h2 id='calculate_a_error'>A-error</h2><span id='topic+calculate_a_error'></span>

<h3>Description</h3>

<p>Computes the A-error of the design, which is equal to the trace of the
variance-covariance matrix over the number of parameters to be estimated
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_a_error(design_vcov)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_a_error_+3A_design_vcov">design_vcov</code></td>
<td>
<p>A variance-covariance matrix returned by
<code><a href="#topic+derive_vcov">derive_vcov</a></code> or returned by an estimation routine. The matrix
should be symmetrical and K-by-K</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single error measure
</p>

<hr>
<h2 id='calculate_c_error'>C-error</h2><span id='topic+calculate_c_error'></span>

<h3>Description</h3>

<p>Seeks to minimize the variance of the ratio of two parameters, for example,
willingness-to-pay.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_c_error(design_vcov, p, dudx, return_all)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_c_error_+3A_design_vcov">design_vcov</code></td>
<td>
<p>A variance-covariance matrix returned by
<code><a href="#topic+derive_vcov">derive_vcov</a></code> or returned by an estimation routine. The matrix
should be symmetrical and K-by-K</p>
</td></tr>
<tr><td><code id="calculate_c_error_+3A_p">p</code></td>
<td>
<p>Prior values</p>
</td></tr>
<tr><td><code id="calculate_c_error_+3A_dudx">dudx</code></td>
<td>
<p>A character string giving the name of the prior in the
denominator. Must be specified when optimizing for 'c-error'</p>
</td></tr>
<tr><td><code id="calculate_c_error_+3A_return_all">return_all</code></td>
<td>
<p>If 'TRUE' return a K or K-1 vector with parameter specific error
measures. Default is 'FALSE'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector giving the variance of the ratio for each K-1 parameter or a
single number with the sum of the variances used for optimization
</p>

<hr>
<h2 id='calculate_d_error'>D-error</h2><span id='topic+calculate_d_error'></span>

<h3>Description</h3>

<p>Computes the D-error of the design, which is equal to the K-root of the
determinant of the variance-covariance matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_d_error(design_vcov)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_d_error_+3A_design_vcov">design_vcov</code></td>
<td>
<p>A variance-covariance matrix returned by
<code><a href="#topic+derive_vcov">derive_vcov</a></code> or returned by an estimation routine. The matrix
should be symmetrical and K-by-K</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single number
</p>

<hr>
<h2 id='calculate_efficiency'>Calculate efficiency</h2><span id='topic+calculate_efficiency'></span>

<h3>Description</h3>

<p>The function is called inside <code><a href="#topic+evaluate_design_candidate">evaluate_design_candidate</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_efficiency(
  prior_values,
  design_env,
  model,
  dudx,
  return_all = FALSE,
  significance = 1.96
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_efficiency_+3A_prior_values">prior_values</code></td>
<td>
<p>a list or vector of assumed priors</p>
</td></tr>
<tr><td><code id="calculate_efficiency_+3A_design_env">design_env</code></td>
<td>
<p>A design environment in which to evaluate the
the function to derive the variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="calculate_efficiency_+3A_model">model</code></td>
<td>
<p>A character string indicating the model to optimize the design
for. Currently the only model programmed is the 'mnl' model and this is also
set as the default.</p>
</td></tr>
<tr><td><code id="calculate_efficiency_+3A_dudx">dudx</code></td>
<td>
<p>A character string giving the name of the prior in the
denominator. Must be specified when optimizing for 'c-error'</p>
</td></tr>
<tr><td><code id="calculate_efficiency_+3A_return_all">return_all</code></td>
<td>
<p>If 'TRUE' return a K or K-1 vector with parameter specific error
measures. Default is 'FALSE'.</p>
</td></tr>
<tr><td><code id="calculate_efficiency_+3A_significance">significance</code></td>
<td>
<p>A t-value corresponding to the desired level of
significance. The default is significance at the 5
t-value of 1.96.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with a named vector of efficiency criteria and the
variance-covariance matrix
</p>

<hr>
<h2 id='calculate_efficiency_criteria'>Calculate efficiency criteria</h2><span id='topic+calculate_efficiency_criteria'></span>

<h3>Description</h3>

<p>The function is a wrapper around <code><a href="#topic+calculate_a_error">calculate_a_error</a></code>,
<code><a href="#topic+calculate_c_error">calculate_c_error</a></code>, <code><a href="#topic+calculate_d_error">calculate_d_error</a></code> and
<code><a href="#topic+calculate_s_error">calculate_s_error</a></code> to provide a unified interface for
calling and calculating efficiency criteria.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_efficiency_criteria(
  design_vcov,
  p = NULL,
  dudx = NULL,
  return_all = FALSE,
  significance = 1.96,
  type
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_efficiency_criteria_+3A_design_vcov">design_vcov</code></td>
<td>
<p>A variance-covariance matrix returned by
<code><a href="#topic+derive_vcov">derive_vcov</a></code> or returned by an estimation routine. The matrix
should be symmetrical and K-by-K</p>
</td></tr>
<tr><td><code id="calculate_efficiency_criteria_+3A_p">p</code></td>
<td>
<p>Prior values</p>
</td></tr>
<tr><td><code id="calculate_efficiency_criteria_+3A_dudx">dudx</code></td>
<td>
<p>A character string giving the name of the prior in the
denominator. Must be specified when optimizing for 'c-error'</p>
</td></tr>
<tr><td><code id="calculate_efficiency_criteria_+3A_return_all">return_all</code></td>
<td>
<p>If 'TRUE' return a K or K-1 vector with parameter specific error
measures. Default is 'FALSE'.</p>
</td></tr>
<tr><td><code id="calculate_efficiency_criteria_+3A_significance">significance</code></td>
<td>
<p>A t-value corresponding to the desired level of
significance. The default is significance at the 5
t-value of 1.96.</p>
</td></tr>
<tr><td><code id="calculate_efficiency_criteria_+3A_type">type</code></td>
<td>
<p>A string indicating the type of efficiency criteria to calculate
can be either: &quot;a-error&quot;, &quot;c-error&quot;, &quot;d-error&quot; or &quot;s-error&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is mainly used internally to evaluate and report on designs,
but is exported to allow the user to use the function to calculate the
efficiency criteria of the model once it has been run on their data.
</p>


<h3>Value</h3>

<p>See individual efficiency criteria
</p>


<h3>References</h3>

<p>Bliemer and Rose, 2009, Efficiency and sample size requirements for state
choice experiments, Transportation Research Board Annual Meeting, Washington
DC
Scarpa and Rose, 2008, Designs efficiency for non-market valuation with
choice modelling: How to measure it, what to report and why, Australian
Journal of Agricultural and Resource Economics, 52(3):253-282
Bliemer and Rose, 2005a, Efficiency and sample size requirements for stated
choice experiments, Report ITLS-WP-05-08, Institute for Transport and
Logistics Studies, University of Sydney
Kessels, R., Goos, P. and Vandebroek, M., 2006, A comparison of criteria to
design efficient choice experiments, Journal of Marketing Research,
43(3):409-419
</p>

<hr>
<h2 id='calculate_s_error'>S-error</h2><span id='topic+calculate_s_error'></span>

<h3>Description</h3>

<p>Calculates a &quot;lower bound&quot; sample size to obtain theoretically significant
parameter estimates under the assumption that the priors are correct.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_s_error(design_vcov, p, return_all, significance)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_s_error_+3A_design_vcov">design_vcov</code></td>
<td>
<p>A variance-covariance matrix returned by
<code><a href="#topic+derive_vcov">derive_vcov</a></code> or returned by an estimation routine. The matrix
should be symmetrical and K-by-K</p>
</td></tr>
<tr><td><code id="calculate_s_error_+3A_p">p</code></td>
<td>
<p>Prior values</p>
</td></tr>
<tr><td><code id="calculate_s_error_+3A_return_all">return_all</code></td>
<td>
<p>If 'TRUE' return a K or K-1 vector with parameter specific error
measures. Default is 'FALSE'.</p>
</td></tr>
<tr><td><code id="calculate_s_error_+3A_significance">significance</code></td>
<td>
<p>A t-value corresponding to the desired level of
significance. The default is significance at the 5
t-value of 1.96.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector giving the &quot;minimum&quot; sample size for each parameter or a
single number with the smallest sample size needed for all parameters to be
theoretically significant.
</p>

<hr>
<h2 id='clean_utility'>Cleans the utility expression</h2><span id='topic+clean_utility'></span>

<h3>Description</h3>

<p>The function cleans the utility expression by removing extra white spaces,
removes brackets and other information to return a clean, easy-to-read
expression.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>clean_utility(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="clean_utility_+3A_x">x</code></td>
<td>
<p>An object of class utility</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We can also use the side-effect of the function on a list of utility
expressions that do not contain brackets to return a an updated utility
expression with alternative specific attribute names.
</p>
<p>Warning: The function does not check if the utility expression *is* clean,
which means that running the function multiple times will result in
duplicate alternative names for the attributes. You need to pay particular
attention to this fact when using the formula <code><a href="#topic+update_utility">update_utility</a></code>
because this function calls <code>clean_utility</code>.
</p>


<h3>Value</h3>

<p>A cleaned utility function as a list
</p>

<hr>
<h2 id='coef.spdesign'>Generic for extracting the vector of priors</h2><span id='topic+coef.spdesign'></span>

<h3>Description</h3>

<p>Generic for extracting the vector of priors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spdesign'
coef(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.spdesign_+3A_object">object</code></td>
<td>
<p>A model object of class 'spdesign'</p>
</td></tr>
<tr><td><code id="coef.spdesign_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of named priors used in the optimization
</p>

<hr>
<h2 id='contains_dummies'>Check whether the utility function contains dummy coded variables</h2><span id='topic+contains_dummies'></span>

<h3>Description</h3>

<p>We are splitting on all separators first before detecting whether we have
dummy coded attributes to allow for people reusing the _dummy name for the
attribute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contains_dummies(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contains_dummies_+3A_string">string</code></td>
<td>
<p>A string or list of strings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean equal to 'TRUE' if the utility function contains dummy
coded attributes and 'FALSE' otherwise
</p>

<hr>
<h2 id='cor'>Correlation</h2><span id='topic+cor'></span>

<h3>Description</h3>

<p>Calculate the correlation of the design. The function gets the design from
the design object before passing it to <code><a href="#topic+cor">cor</a></code> from stats.
This is a wrapper around <code><a href="#topic+cor">cor</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cor(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cor_+3A_x">x</code></td>
<td>
<p>A model object of class 'spdesign'</p>
</td></tr>
<tr><td><code id="cor_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to the function</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that when your design includes constants, the function will print a
warning because the standard deviation of a constant is 0.
</p>


<h3>Value</h3>

<p>A matrix with correlations
</p>

<hr>
<h2 id='cycle'>Cycling of attribute levels</h2><span id='topic+cycle'></span>

<h3>Description</h3>

<p>Cycles the attribute levels to create a new design candidate. &quot;Cycling
replaces all attribute levels in each choice situation at the time by
replacing the first level with the second level, second level with the third
etc. Since this change affects all columns, cycling can only be performed if
all attributes have exactly the same sets of feasible levels,
(e.g., where all variables are dummy coded).&quot; (p. 253).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cycle(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cycle_+3A_x">x</code></td>
<td>
<p>A vector of attribute levels</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This part of the RSC algorithm is rarely invoked.
</p>


<h3>Value</h3>

<p>A cycled design candidate
</p>


<h3>References</h3>

<p>Hensher, D. A., Rose, J. M. &amp; Greene, W., 2005, Applied Choice Analysis,
2nd ed., Cambridge University Press
</p>

<hr>
<h2 id='define_base_x_j'>Define base x_j</h2><span id='topic+define_base_x_j'></span>

<h3>Description</h3>

<p>Defines the base of the x_j list using the parsed utility expression,
design_candidate and the base model matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_base_x_j(utility, design_candidate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_base_x_j_+3A_utility">utility</code></td>
<td>
<p>A named list of utility functions. See the examples and the
vignette for examples of how to define these correctly for different types
of experimental designs.</p>
</td></tr>
<tr><td><code id="define_base_x_j_+3A_design_candidate">design_candidate</code></td>
<td>
<p>The current design candidate under consideration</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A base list x_j with model matrices the lenght of J
</p>

<hr>
<h2 id='define_x_j'>Define x_j</h2><span id='topic+define_x_j'></span>

<h3>Description</h3>

<p>Define x_j to use for the analytic derivatives of the variance-covariance
matrix. x_j is derived based on the provided utility functions and design
candidate using base model.matrix to automatically handle alternative
specific attributes and interaction terms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>define_x_j(utility, design_candidate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="define_x_j_+3A_utility">utility</code></td>
<td>
<p>A named list of utility functions. See the examples and the
vignette for examples of how to define these correctly for different types
of experimental designs.</p>
</td></tr>
<tr><td><code id="define_x_j_+3A_design_candidate">design_candidate</code></td>
<td>
<p>The current design candidate under consideration</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We can extract the attribute names for each utility function to allow us
to place the correct restrictions on the design candidate. Specifically, we
restrict all levels of unavailable attributes to zero for alternatives where
they do not feature. This is to ensure that we do not give weight when
deriving the variance-covariance matrix using <code><a href="#topic+derive_vcov">derive_vcov</a></code>.
Furthermore, the Xs are &quot;sorted&quot; using the order of the candidate set, which
ensures that when we calculate the sum of the probabilities times X, the
correct columns are added together. See <code><a href="#topic+derive_vcov">derive_vcov</a></code>.
</p>


<h3>Value</h3>

<p>The list x_j
</p>

<hr>
<h2 id='derive_vcov'>Derive the variance covariance matrix of the design</h2><span id='topic+derive_vcov'></span>

<h3>Description</h3>

<p>The function is a wrapper around <code><a href="#topic+derive_vcov_mnl">derive_vcov_mnl</a></code> and
<code><a href="#topic+derive_vcov_rpl">derive_vcov_rpl</a></code> and calculates the variance-covariance matrix
of the specified model and design given the priors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_vcov(design_env, model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="derive_vcov_+3A_design_env">design_env</code></td>
<td>
<p>An environment containing all the elements
necessary to derive the variance-covariance matrix</p>
</td></tr>
<tr><td><code id="derive_vcov_+3A_model">model</code></td>
<td>
<p>A string indicating the model for which you wish to derive the
variance covariance matrix. Can be either &quot;mnl&quot; or &quot;rpl&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The variance covariance matrix. If the Fisher information matrix is
singular, then return NULL
</p>

<hr>
<h2 id='derive_vcov_mnl'>Derive the variance covariance matrix for the MNL model</h2><span id='topic+derive_vcov_mnl'></span>

<h3>Description</h3>

<p>The function takes no arguments and is evaluated in context!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_vcov_mnl()
</code></pre>


<h3>Value</h3>

<p>The variance co-variance matrix
</p>

<hr>
<h2 id='derive_vcov_rpl'>Derive the variance covariance matrix for the RPL model</h2><span id='topic+derive_vcov_rpl'></span>

<h3>Description</h3>

<p>The function takes no arguments and is evaluated in context!
</p>


<h3>Usage</h3>

<pre><code class='language-R'>derive_vcov_rpl()
</code></pre>


<h3>Value</h3>

<p>The variance co-variance matrix
</p>

<hr>
<h2 id='digitize'>Expand the sequence of integers</h2><span id='topic+digitize'></span>

<h3>Description</h3>

<p>Equation 1 in Bhat (2003)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>digitize(n_dim, primes, count, digit)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="digitize_+3A_n_dim">n_dim</code></td>
<td>
<p>Number of dimensions</p>
</td></tr>
<tr><td><code id="digitize_+3A_primes">primes</code></td>
<td>
<p>A vector of prime numbers</p>
</td></tr>
<tr><td><code id="digitize_+3A_count">count</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="digitize_+3A_digit">digit</code></td>
<td>
<p>A vector</p>
</td></tr>
</table>


<h3>References</h3>

<p>Bhat, C. n_draws., 2003, Simulation Estimation of Mixed Discrete
Choice Models Using Randomized and Scrambled Halton Sequences, Transportation
Research Part B, 9, pp. 837-855
</p>

<hr>
<h2 id='dummy_names'>Find the position of the dummy coded attributes</h2><span id='topic+dummy_names'></span>

<h3>Description</h3>

<p>The function will find the position of the dummy coded attributes in the
candidate set (in the case of the Modified Federov or Random algorithms) or
the design candidate (in the case of the RSC algorithm). This will let us
know which columns to coerce to factors prior to defining x_j.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dummy_names(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dummy_names_+3A_x">x</code></td>
<td>
<p>An object of class utility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean vector matching the expanded utility expression
</p>

<hr>
<h2 id='evaluate_design_candidate'>Evaluate the design candidate</h2><span id='topic+evaluate_design_candidate'></span>

<h3>Description</h3>

<p>The evaluation of the design candidate is independent of the optimization
algorithm used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>evaluate_design_candidate(
  utility,
  design_candidate,
  prior_values,
  design_env,
  model,
  dudx,
  return_all,
  significance
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="evaluate_design_candidate_+3A_utility">utility</code></td>
<td>
<p>A utility function</p>
</td></tr>
<tr><td><code id="evaluate_design_candidate_+3A_design_candidate">design_candidate</code></td>
<td>
<p>The current design candidate</p>
</td></tr>
<tr><td><code id="evaluate_design_candidate_+3A_prior_values">prior_values</code></td>
<td>
<p>a list or vector of assumed priors</p>
</td></tr>
<tr><td><code id="evaluate_design_candidate_+3A_design_env">design_env</code></td>
<td>
<p>A design environment in which to evaluate the
the function to derive the variance-covariance matrix.</p>
</td></tr>
<tr><td><code id="evaluate_design_candidate_+3A_model">model</code></td>
<td>
<p>A character string indicating the model to optimize the design
for. Currently the only model programmed is the 'mnl' model and this is also
set as the default.</p>
</td></tr>
<tr><td><code id="evaluate_design_candidate_+3A_dudx">dudx</code></td>
<td>
<p>A character string giving the name of the prior in the
denominator. Must be specified when optimizing for 'c-error'</p>
</td></tr>
<tr><td><code id="evaluate_design_candidate_+3A_return_all">return_all</code></td>
<td>
<p>If 'TRUE' return a K or K-1 vector with parameter specific error
measures. Default is 'FALSE'.</p>
</td></tr>
<tr><td><code id="evaluate_design_candidate_+3A_significance">significance</code></td>
<td>
<p>A t-value corresponding to the desired level of
significance. The default is significance at the 5
t-value of 1.96.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector with efficiency criteria of the current design
candidate. If Bayesian prior_values are used, then it returns the average
error.
</p>

<hr>
<h2 id='exclude'>Exclude rows from the candidate set</h2><span id='topic+exclude'></span>

<h3>Description</h3>

<p>The function takes the list of exclusions and transforms them into an
expression that is then parsed and evaluated to apply the exclusions
to the supplied candidate set using standard subsetting routines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>exclude(candidate_set, exclusions)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="exclude_+3A_candidate_set">candidate_set</code></td>
<td>
<p>A matrix or data frame in the &quot;wide&quot; format containing
all permitted combinations of attributes. The default is NULL. If no
candidate set is provided, then the full factorial subject to specified
exclusions will be used. This is passed in as an object and not a character
string. The candidate set will be expanded to include zero columns to
consider alternative specific attributes.</p>
</td></tr>
<tr><td><code id="exclude_+3A_exclusions">exclusions</code></td>
<td>
<p>A list of exclusions Often this list will be pulled
directly from the list of options or it is a modified list of exclusions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A restricted candidate set
</p>

<hr>
<h2 id='expand_attribute_levels'>Expand the list of attributes and levels to the &quot;wide&quot; format</h2><span id='topic+expand_attribute_levels'></span>

<h3>Description</h3>

<p>Expands the attributes and levels to the wide format. The nested list is
padded with zeros where alternative specific attributes are present to ensure
that we can work with square matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expand_attribute_levels(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expand_attribute_levels_+3A_x">x</code></td>
<td>
<p>An object of class utility</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named vector
</p>

<hr>
<h2 id='extract_all_names'>Extract all names</h2><span id='topic+extract_all_names'></span>

<h3>Description</h3>

<p>Extracts all parameter and attribute names from the utility function.
This is a wrapper around <code><a href="stringr.html#topic+str_extract_all">str_extract_all</a></code> with a specified
boundary. The function also calls <code><a href="#topic+remove_all_brackets">remove_all_brackets</a></code> to
ensure that if a word is used inside a square bracket, e.g. seq, it is not
extracted.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_all_names(string, simplify = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_all_names_+3A_string">string</code></td>
<td>
<p>A character string</p>
</td></tr>
<tr><td><code id="extract_all_names_+3A_simplify">simplify</code></td>
<td>
<p>If TRUE return as a vector. Default is FALSE.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that we are not matching spaces nor the interaction operator I(). This
is to avoid I being identified as its own (unspecified) attribute.
</p>


<h3>Value</h3>

<p>A list or vector with all names
</p>

<hr>
<h2 id='extract_attribute_names'>Extract attribute names</h2><span id='topic+extract_attribute_names'></span>

<h3>Description</h3>

<p>Extracts attribute names. It is a wrapper around
<code><a href="#topic+extract_all_names">extract_all_names</a></code> and <code><a href="#topic+extract_param_names">extract_param_names</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_attribute_names(string, simplify = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_attribute_names_+3A_string">string</code></td>
<td>
<p>A character string</p>
</td></tr>
<tr><td><code id="extract_attribute_names_+3A_simplify">simplify</code></td>
<td>
<p>If TRUE return as a vector. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A Vector or string wtih attribute names
</p>

<hr>
<h2 id='extract_distribution'>Extract distributions</h2><span id='topic+extract_distribution'></span>

<h3>Description</h3>

<p>This function will locate and extract the the distributions for Bayesian
priors and random parameters as specified in the design. The output is used
to create the matrix of correct draws for priors and parameters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_distribution(string, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_distribution_+3A_string">string</code></td>
<td>
<p>A single character string or list of character strings with a
single or multiple utility functions</p>
</td></tr>
<tr><td><code id="extract_distribution_+3A_type">type</code></td>
<td>
<p>A string indicating the type: prior or param</p>
</td></tr>
</table>


<h3>Details</h3>

<p>IMPORTANT: The function will silently drop duplicates.
</p>


<h3>Value</h3>

<p>A named vector of priors or parameters where the type of distribution
is given by a character letter: &quot;normal&quot;, &quot;lognormal&quot;, &quot;uniform&quot; or
&quot;triangular&quot;
</p>

<hr>
<h2 id='extract_level_occurrence'>Extract the frequency of levels</h2><span id='topic+extract_level_occurrence'></span>

<h3>Description</h3>

<p>The function extracts how many times each level of an attribute should
occur within the design when attribute level balance is not enforced.
Note that it extracts the parentheses AFTER the end of the square brackets.
Specifying round brackets without the square brackets are syntactically
invalid and therefore we want the code to fail in this case.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_level_occurrence(string, simplify = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_level_occurrence_+3A_string">string</code></td>
<td>
<p>A character string</p>
</td></tr>
<tr><td><code id="extract_level_occurrence_+3A_simplify">simplify</code></td>
<td>
<p>If TRUE return as a vector. Default is FALSE.</p>
</td></tr>
</table>

<hr>
<h2 id='extract_named_values'>Extracts the named values of the utility function</h2><span id='topic+extract_named_values'></span>

<h3>Description</h3>

<p>The function extracts the named values of the supplied utility function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_named_values(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_named_values_+3A_string">string</code></td>
<td>
<p>A character string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of parameter and attribute values. Each list element is
named and can contain a single prior, a list with a mean and sd, or a vector
with attribute levels
</p>

<hr>
<h2 id='extract_param_distribution'>Extract the parameter distribution</h2><span id='topic+extract_param_distribution'></span>

<h3>Description</h3>

<p>Extract the parameter distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_param_distribution(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_param_distribution_+3A_string">string</code></td>
<td>
<p>A single character string or list of character strings with a
single or multiple utility functions</p>
</td></tr>
</table>

<hr>
<h2 id='extract_param_names'>Extract parameter names</h2><span id='topic+extract_param_names'></span>

<h3>Description</h3>

<p>Extracts all words starting with &quot;b_&quot;. Leverages the fact that all parameters
has to start with &quot;b_&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_param_names(string, simplify = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_param_names_+3A_string">string</code></td>
<td>
<p>A character string</p>
</td></tr>
<tr><td><code id="extract_param_names_+3A_simplify">simplify</code></td>
<td>
<p>If TRUE return as a vector. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list or vector with the parameter names.
</p>

<hr>
<h2 id='extract_prior_distribution'>Extract the prior distribution</h2><span id='topic+extract_prior_distribution'></span>

<h3>Description</h3>

<p>Extract the prior distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_prior_distribution(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_prior_distribution_+3A_string">string</code></td>
<td>
<p>A single character string or list of character strings with a
single or multiple utility functions</p>
</td></tr>
</table>

<hr>
<h2 id='extract_specified'>Extract specified</h2><span id='topic+extract_specified'></span>

<h3>Description</h3>

<p>Only extract parameters and attributes with specified priors and levels. This
is very useful to test whether parameters or attributes are specified
multiple times
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_specified(string, simplify = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_specified_+3A_string">string</code></td>
<td>
<p>A character string</p>
</td></tr>
<tr><td><code id="extract_specified_+3A_simplify">simplify</code></td>
<td>
<p>If TRUE return as a vector. Default is FALSE.</p>
</td></tr>
</table>

<hr>
<h2 id='extract_unparsed_values'>Extract unparsed named values of the utilitiy function</h2><span id='topic+extract_unparsed_values'></span>

<h3>Description</h3>

<p>If the utility function contains parameters that are dummy coded, the dummy
coding is handled here. By expanding the dummy coding prior to parsing we can
directly consider Bayesian priors for each level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_unparsed_values(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_unparsed_values_+3A_string">string</code></td>
<td>
<p>A character string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of parameter and attribute values. Each list element is
named and contains a numeric value or expression to be parsed
</p>

<hr>
<h2 id='extract_values'>Extract the value argument(s)</h2><span id='topic+extract_values'></span>

<h3>Description</h3>

<p>Extracts the value argument(s) of the supplied string. The value argument
is defined as the characters between [] string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extract_values(string, simplify = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extract_values_+3A_string">string</code></td>
<td>
<p>A character string</p>
</td></tr>
<tr><td><code id="extract_values_+3A_simplify">simplify</code></td>
<td>
<p>If TRUE return as a vector. Default is FALSE.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector or list with the extracted value arguments
</p>

<hr>
<h2 id='federov'>Find a design using a modified Federov algorithm</h2><span id='topic+federov'></span>

<h3>Description</h3>

<p>The modified Federov algorithm implemented here starts with a random design
candidate and systematically swaps out rows of the design candidate to
iteratively find better designs. The algorithm has the following steps and
restrictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>federov(
  design_object,
  model,
  efficiency_criteria,
  utility,
  prior_values,
  dudx,
  candidate_set,
  rows,
  control
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="federov_+3A_design_object">design_object</code></td>
<td>
<p>A list of class 'spdesign' created within the
<code><a href="#topic+generate_design">generate_design</a></code> function</p>
</td></tr>
<tr><td><code id="federov_+3A_model">model</code></td>
<td>
<p>A character string indicating the model to optimize the design
for. Currently the only model programmed is the 'mnl' model and this is also
set as the default.</p>
</td></tr>
<tr><td><code id="federov_+3A_efficiency_criteria">efficiency_criteria</code></td>
<td>
<p>A character string giving the efficiency criteria
to optimize for. One of 'a-error', 'c-error', 'd-error' or 's-error'. No
default is set and argument must be specified. Optimizing for multiple
criteria is not yet implemented and will result in an error.</p>
</td></tr>
<tr><td><code id="federov_+3A_utility">utility</code></td>
<td>
<p>A named list of utility functions. See the examples and the
vignette for examples of how to define these correctly for different types
of experimental designs.</p>
</td></tr>
<tr><td><code id="federov_+3A_prior_values">prior_values</code></td>
<td>
<p>A list of priors</p>
</td></tr>
<tr><td><code id="federov_+3A_dudx">dudx</code></td>
<td>
<p>A character string giving the name of the prior in the
denominator. Must be specified when optimizing for 'c-error'</p>
</td></tr>
<tr><td><code id="federov_+3A_candidate_set">candidate_set</code></td>
<td>
<p>A matrix or data frame in the &quot;wide&quot; format containing
all permitted combinations of attributes. The default is NULL. If no
candidate set is provided, then the full factorial subject to specified
exclusions will be used. This is passed in as an object and not a character
string. The candidate set will be expanded to include zero columns to
consider alternative specific attributes.</p>
</td></tr>
<tr><td><code id="federov_+3A_rows">rows</code></td>
<td>
<p>An integer giving the number of rows in the final design</p>
</td></tr>
<tr><td><code id="federov_+3A_control">control</code></td>
<td>
<p>A list of control options</p>
</td></tr>
</table>


<h3>Details</h3>

<p>1) Create a random initial design and evaluate it.
2) Swap the first row of the design candidate with the first row of the
candidate set.
3) If no better candidate is found, try the second row of the candidate set.
Keep trying new rows of the candidate set until an improvement is found.
4) If a better candidate is found, then we try to swap out the next row in
the design candidate with the first row of the candidate set. Keep
repeating the previous step.
5) When all rows of the design candidate has been swapped once, reset the
counter and work through the design candidate and candidate set again.
6) The algorithm terminates after a pre-determined number of iterations or
when a pre-determined efficiency threshold has been found.
</p>
<p>NOTE: I have not yet implemented a duplicate check! That is, I do not check
whether the &quot;same&quot; choice rows are included but with the order of
alternatives swapped. This can be achieved by further restricting the
candidate set prior to searching for designs. That said, &quot;identical&quot;
choice rows will not provide much additional information and should
be excluded by default in the search process.
</p>


<h3>Value</h3>

<p>A list of class 'spdesign'
</p>

<hr>
<h2 id='fits_lvl_occurrences'>Test whether a design candidate fits the constraints imposed by the level
occurrences</h2><span id='topic+fits_lvl_occurrences'></span>

<h3>Description</h3>

<p>Test whether a design candidate fits the constraints imposed by the level
occurrences
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fits_lvl_occurrences(utility, x, rows)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fits_lvl_occurrences_+3A_utility">utility</code></td>
<td>
<p>A named list of utility functions. See the examples and the
vignette for examples of how to define these correctly for different types
of experimental designs.</p>
</td></tr>
<tr><td><code id="fits_lvl_occurrences_+3A_x">x</code></td>
<td>
<p>An object of class 'utility' or 'spdesign'</p>
</td></tr>
<tr><td><code id="fits_lvl_occurrences_+3A_rows">rows</code></td>
<td>
<p>Number of rows in the design</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean equal to TRUE if attribute level balanced
</p>

<hr>
<h2 id='full_factorial'>Generate the full factorial</h2><span id='topic+full_factorial'></span>

<h3>Description</h3>

<p>The function is a wrapper around <code><a href="base.html#topic+expand.grid">expand.grid</a></code> and
generates the full factorial given the supplied attributes. The attributes
can either be specified directly by the user or extracted from the list
of utility functions using.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>full_factorial(attrs)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="full_factorial_+3A_attrs">attrs</code></td>
<td>
<p>A named list of attributes and their levels</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The full factorial is often used as the starting point to generate a
candidate set. Note that the full factorial will include unrealistic and
completely dominated alternatives. It is therefore advised to use a subset
of the full factorial as a candidate set. The user can call
<code>full_factorial</code> and create a subset that is passed to
<code><a href="#topic+generate_design">generate_design</a></code> using the 'candidate_set' parameter, or supply
a set of restrictions through the 'restrictions' argument.
</p>


<h3>Value</h3>

<p>A matrix containing the full factorial
</p>


<h3>Examples</h3>

<pre><code class='language-R'>opts &lt;- list(
  level_balance = FALSE,
  tasks = 10
)
attrs &lt;- list(
  a1 = 1:5,
  a2 = c(0, 1)
)

full_factorial(attrs)

V &lt;- list(
  alt1 = "b_a1[0.1] * a1[1:5] + b_a2[-2] * a2[c(0, 1)]",
  alt2 = "b_a1      * a1      + b_a2     * a2"
)

attrs &lt;- expand_attribute_levels(V)
full_factorial(attrs)

</code></pre>

<hr>
<h2 id='generate_design'>Generate an efficient experimental design</h2><span id='topic+generate_design'></span>

<h3>Description</h3>

<p>The function generates efficient experimental designs. The function takes
a set of indirect utility functions and generates efficient experimental
designs assuming that people are maximizing utility.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_design(
  utility,
  rows,
  model = "mnl",
  efficiency_criteria = c("a-error", "c-error", "d-error", "s-error"),
  algorithm = c("federov", "rsc", "random"),
  draws = c("pseudo-random", "mlhs", "standard-halton", "scrambled-halton",
    "standard-sobol", "scrambled-sobol"),
  R = 100,
  dudx = NULL,
  candidate_set = NULL,
  exclusions = NULL,
  control = list(cores = 1, max_iter = 10000, max_relabel = 10000, max_no_improve =
    1e+05, efficiency_threshold = 0.1, sample_with_replacement = FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_design_+3A_utility">utility</code></td>
<td>
<p>A named list of utility functions. See the examples and the
vignette for examples of how to define these correctly for different types
of experimental designs.</p>
</td></tr>
<tr><td><code id="generate_design_+3A_rows">rows</code></td>
<td>
<p>An integer giving the number of rows in the final design</p>
</td></tr>
<tr><td><code id="generate_design_+3A_model">model</code></td>
<td>
<p>A character string indicating the model to optimize the design
for. Currently the only model programmed is the 'mnl' model and this is also
set as the default.</p>
</td></tr>
<tr><td><code id="generate_design_+3A_efficiency_criteria">efficiency_criteria</code></td>
<td>
<p>A character string giving the efficiency criteria
to optimize for. One of 'a-error', 'c-error', 'd-error' or 's-error'. No
default is set and argument must be specified. Optimizing for multiple
criteria is not yet implemented and will result in an error.</p>
</td></tr>
<tr><td><code id="generate_design_+3A_algorithm">algorithm</code></td>
<td>
<p>A character string giving the optimization algorithm to use.
No default is set and the argument must be specified to be one of 'rsc',
'federov' or 'random'.</p>
</td></tr>
<tr><td><code id="generate_design_+3A_draws">draws</code></td>
<td>
<p>The type of draws to use with Bayesian priors. No default is set
and must be specified even if you are not creating a Bayesian design. Can be
one of &quot;pseudo-random&quot;, &quot;mlhs&quot;, &quot;standard-halton&quot;, &quot;scrambled-halton&quot;,
&quot;standard-sobol&quot;,&quot;scrambled-sobol&quot;.</p>
</td></tr>
<tr><td><code id="generate_design_+3A_r">R</code></td>
<td>
<p>An integer giving the number of draws to use. The default is 100.</p>
</td></tr>
<tr><td><code id="generate_design_+3A_dudx">dudx</code></td>
<td>
<p>A character string giving the name of the prior in the
denominator. Must be specified when optimizing for 'c-error'</p>
</td></tr>
<tr><td><code id="generate_design_+3A_candidate_set">candidate_set</code></td>
<td>
<p>A matrix or data frame in the &quot;wide&quot; format containing
all permitted combinations of attributes. The default is NULL. If no
candidate set is provided, then the full factorial subject to specified
exclusions will be used. This is passed in as an object and not a character
string. The candidate set will be expanded to include zero columns to
consider alternative specific attributes.</p>
</td></tr>
<tr><td><code id="generate_design_+3A_exclusions">exclusions</code></td>
<td>
<p>A list of exclusions Often this list will be pulled
directly from the list of options or it is a modified list of exclusions</p>
</td></tr>
<tr><td><code id="generate_design_+3A_control">control</code></td>
<td>
<p>A list of control options</p>
</td></tr>
</table>


<h3>Details</h3>

<p>No assumptions are made with respect to default values and it is up to the
user to specify optimization criteria, optmization routines, draws to use for
Bayesian priors and more.
</p>


<h3>Value</h3>

<p>An object of class 'spdesign'
</p>

<hr>
<h2 id='generate_rsc_candidate'>Generates a candidate for the RSC algorithm</h2><span id='topic+generate_rsc_candidate'></span>

<h3>Description</h3>

<p>Creates a design candidate by assuming attribute level balance. Will work
out the minimum level of times an attribute must occur for level balance. If
level balance cannot be achieved the function will systematically add level
occurrences to get as close as possible to attribute level balance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>generate_rsc_candidate(utility, rows)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="generate_rsc_candidate_+3A_utility">utility</code></td>
<td>
<p>A named list of utility functions. See the examples and the
vignette for examples of how to define these correctly for different types
of experimental designs.</p>
</td></tr>
<tr><td><code id="generate_rsc_candidate_+3A_rows">rows</code></td>
<td>
<p>An integer giving the number of rows in the final design</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame with rows equal to the number of choice tasks and columns
equal to the number of attributes in the 'wide' format
</p>

<hr>
<h2 id='has_bayesian_prior'>Tests whether the utility expression contains Bayesian priors</h2><span id='topic+has_bayesian_prior'></span>

<h3>Description</h3>

<p>This is particularly useful for flow-control
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_bayesian_prior(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has_bayesian_prior_+3A_string">string</code></td>
<td>
<p>A string or list of strings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean equal to 'TRUE' if we have Bayesian priors
</p>

<hr>
<h2 id='has_random_parameter'>Tests whether the utility expression contains random parameters</h2><span id='topic+has_random_parameter'></span>

<h3>Description</h3>

<p>This is particularly useful for flow-control
</p>


<h3>Usage</h3>

<pre><code class='language-R'>has_random_parameter(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="has_random_parameter_+3A_string">string</code></td>
<td>
<p>A string or list of strings</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean equal to 'TRUE' if we have random parameters
</p>

<hr>
<h2 id='is_balanced'>Tests whether a utility function is balanced</h2><span id='topic+is_balanced'></span>

<h3>Description</h3>

<p>Tests whether there is an equal number of opening and closing brackets in
the utility functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>is_balanced(string, open, close)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is_balanced_+3A_string">string</code></td>
<td>
<p>A character string</p>
</td></tr>
<tr><td><code id="is_balanced_+3A_open">open</code></td>
<td>
<p>An opening bracket ( [ or &lt;</p>
</td></tr>
<tr><td><code id="is_balanced_+3A_close">close</code></td>
<td>
<p>A closing bracket ) ] or &gt;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean equal to 'TRUE' if the utility expression is balanced
</p>

<hr>
<h2 id='lvl_occurrences'>Attribute level occurrence lookup tables</h2><span id='topic+lvl_occurrences'></span>

<h3>Description</h3>

<p>Creates a list of lookup tables for attribute level occurrence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lvl_occurrences(utility, rows, level_balance)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lvl_occurrences_+3A_utility">utility</code></td>
<td>
<p>A named list of utility functions. See the examples and the
vignette for examples of how to define these correctly for different types
of experimental designs.</p>
</td></tr>
<tr><td><code id="lvl_occurrences_+3A_rows">rows</code></td>
<td>
<p>An integer giving the number of rows in the final design</p>
</td></tr>
<tr><td><code id="lvl_occurrences_+3A_level_balance">level_balance</code></td>
<td>
<p>Boolean equal to TRUE if level balance. This is not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list the length of the expanced attribute levels. Each list element
is a lookup table where the names of the table is the attribute level and the
element the number of times the minimum number of times the level occurs.
</p>

<hr>
<h2 id='make_draws'>Make random draws</h2><span id='topic+make_draws'></span>

<h3>Description</h3>

<p>A common interface to creating a variety of random draws used to simulate
the log likelihood function
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_draws(n_ind, n_draws, n_dim, seed, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_draws_+3A_n_ind">n_ind</code></td>
<td>
<p>Number of individuals in your sample</p>
</td></tr>
<tr><td><code id="make_draws_+3A_n_draws">n_draws</code></td>
<td>
<p>Number of draws per respondent</p>
</td></tr>
<tr><td><code id="make_draws_+3A_n_dim">n_dim</code></td>
<td>
<p>Number of dimensions</p>
</td></tr>
<tr><td><code id="make_draws_+3A_seed">seed</code></td>
<td>
<p>A seed to change the scrambling of the sobol sequence.</p>
</td></tr>
<tr><td><code id="make_draws_+3A_type">type</code></td>
<td>
<p>A character string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of dimensions n_ind*n_draws x n_dim of standard uniform
draws
</p>


<h3>Examples</h3>

<pre><code class='language-R'>n_ind &lt;- 10
n_draws &lt;- 5
n_dim &lt;- 3

draws &lt;- make_draws(n_ind, n_draws, n_dim, seed = 10, "scrambled-sobol")
head(draws)

draws &lt;- make_draws(n_ind, n_draws, n_dim, seed = 10, "scrambled-halton")
head(draws)

</code></pre>

<hr>
<h2 id='make_mlhs'>Make Modified Latin Hypercube Draws</h2><span id='topic+make_mlhs'></span>

<h3>Description</h3>

<p>Make Modified Latin Hypercube Draws
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_mlhs(n_ind, n_draws, n_dim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_mlhs_+3A_n_ind">n_ind</code></td>
<td>
<p>Number of individuals in your sample</p>
</td></tr>
<tr><td><code id="make_mlhs_+3A_n_draws">n_draws</code></td>
<td>
<p>Number of draws per respondent</p>
</td></tr>
<tr><td><code id="make_mlhs_+3A_n_dim">n_dim</code></td>
<td>
<p>Number of dimensions</p>
</td></tr>
</table>


<h3>References</h3>

<p>Hess, S., Train, K. E. &amp; Polak, J. W., 2006, On the use of a Modified Latin
Hypercube Sampling (MLHS) method in the estimation of a Mixed Logit Model
for vehicle choice, Transportation Research Part B, 40, pp. 147-163
</p>

<hr>
<h2 id='make_pseudo_random'>Make pseudo random draws</h2><span id='topic+make_pseudo_random'></span>

<h3>Description</h3>

<p>Wrapper for runif to create a common interface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_pseudo_random(n_ind, n_draws, n_dim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_pseudo_random_+3A_n_ind">n_ind</code></td>
<td>
<p>Number of individuals in your sample</p>
</td></tr>
<tr><td><code id="make_pseudo_random_+3A_n_draws">n_draws</code></td>
<td>
<p>Number of draws per respondent</p>
</td></tr>
<tr><td><code id="make_pseudo_random_+3A_n_dim">n_dim</code></td>
<td>
<p>Number of dimensions</p>
</td></tr>
</table>

<hr>
<h2 id='make_scrambled_halton'>Make scrambled Halton draws</h2><span id='topic+make_scrambled_halton'></span>

<h3>Description</h3>

<p>A function for creating scrambled Halton draws. The code is a translation of
the [GAUSS](http://www.caee.utexas.edu/prof/bhat/FULL_CODES.htm) codes
written by Professor Chandra Bhat. Note that the maximum number of dimensions
for the scrambled Halton draws is limited to 16. This is because only
permutations up to prime 16 are included in the permutation matrix. Extending
to more than 16 dimensions can be achieved by including a different
permutation matrix.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_scrambled_halton(n_ind, n_draws, n_dim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_scrambled_halton_+3A_n_ind">n_ind</code></td>
<td>
<p>Number of individuals in your sample</p>
</td></tr>
<tr><td><code id="make_scrambled_halton_+3A_n_draws">n_draws</code></td>
<td>
<p>Number of draws per respondent</p>
</td></tr>
<tr><td><code id="make_scrambled_halton_+3A_n_dim">n_dim</code></td>
<td>
<p>Number of dimensions</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The permutations are based on the Braaten-Weller algorithm.
</p>


<h3>References</h3>

<p>Bhat, C. n_draws., 2003, Simulation Estimation of Mixed Descrete
Choice Models Using Randomized and Scrambled Halton Sequences, Transportation
Research Part B, 9, pp. 837-855
</p>

<hr>
<h2 id='make_scrambled_sobol'>Make scrambled sobol draws</h2><span id='topic+make_scrambled_sobol'></span>

<h3>Description</h3>

<p>Wrapper function for sobol() from randtoolbox to create a common interface.
Owen + Fazure_Tezuka Scrambling
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_scrambled_sobol(n_ind, n_draws, n_dim, seed = seed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_scrambled_sobol_+3A_n_ind">n_ind</code></td>
<td>
<p>Number of individuals in your sample</p>
</td></tr>
<tr><td><code id="make_scrambled_sobol_+3A_n_draws">n_draws</code></td>
<td>
<p>Number of draws per respondent</p>
</td></tr>
<tr><td><code id="make_scrambled_sobol_+3A_n_dim">n_dim</code></td>
<td>
<p>Number of dimensions</p>
</td></tr>
<tr><td><code id="make_scrambled_sobol_+3A_seed">seed</code></td>
<td>
<p>A seed to change the scrambling of the sobol sequence.</p>
</td></tr>
</table>

<hr>
<h2 id='make_standard_halton'>Wrapper for halton()</h2><span id='topic+make_standard_halton'></span>

<h3>Description</h3>

<p>Wrapper function for halton() from randtoolbox to create a common interface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_standard_halton(n_ind, n_draws, n_dim)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_standard_halton_+3A_n_ind">n_ind</code></td>
<td>
<p>Number of individuals in your sample</p>
</td></tr>
<tr><td><code id="make_standard_halton_+3A_n_draws">n_draws</code></td>
<td>
<p>Number of draws per respondent</p>
</td></tr>
<tr><td><code id="make_standard_halton_+3A_n_dim">n_dim</code></td>
<td>
<p>Number of dimensions</p>
</td></tr>
</table>

<hr>
<h2 id='make_standard_sobol'>Make sobol draws</h2><span id='topic+make_standard_sobol'></span>

<h3>Description</h3>

<p>Wrapper function for sobol() from randtoolbox to create a common interface
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_standard_sobol(n_ind, n_draws, n_dim, seed = seed)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_standard_sobol_+3A_n_ind">n_ind</code></td>
<td>
<p>Number of individuals in your sample</p>
</td></tr>
<tr><td><code id="make_standard_sobol_+3A_n_draws">n_draws</code></td>
<td>
<p>Number of draws per respondent</p>
</td></tr>
<tr><td><code id="make_standard_sobol_+3A_n_dim">n_dim</code></td>
<td>
<p>Number of dimensions</p>
</td></tr>
<tr><td><code id="make_standard_sobol_+3A_seed">seed</code></td>
<td>
<p>A seed to change the scrambling of the sobol sequence.</p>
</td></tr>
</table>

<hr>
<h2 id='min_lvl_occurrence'>Find minimum level occurrences</h2><span id='topic+min_lvl_occurrence'></span>

<h3>Description</h3>

<p>Find minimium level occurrences. This is useful to ensure/approximate attribute
level balance in designs using the Modified Federov Algorithm or the
Random design algorithms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>min_lvl_occurrence(x, rows)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="min_lvl_occurrence_+3A_x">x</code></td>
<td>
<p>An object of class 'utility' or 'spdesign'</p>
</td></tr>
<tr><td><code id="min_lvl_occurrence_+3A_rows">rows</code></td>
<td>
<p>Number of rows in the design</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of minimum level occurrences for the attribute levels
</p>

<hr>
<h2 id='nlvls'>Find the number of levels</h2><span id='topic+nlvls'></span>

<h3>Description</h3>

<p>Find the number of levels for each attribute
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nlvls(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nlvls_+3A_x">x</code></td>
<td>
<p>An object of class 'utility' or 'spdesign'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with the number of levels for each attribute
</p>

<hr>
<h2 id='normal'>Evaluating a distribution</h2><span id='topic+normal'></span><span id='topic+normal_p'></span><span id='topic+lognormal'></span><span id='topic+lognormal_p'></span><span id='topic+triangular'></span><span id='topic+triangular_p'></span><span id='topic+uniform'></span><span id='topic+uniform_p'></span>

<h3>Description</h3>

<p>The function returns its arguments as a named list. The function is used
inside the utility functions. It is transformed to an expression using
<code><a href="base.html#topic+parse">parse</a></code> and evaluated using <code><a href="base.html#topic+eval">eval</a></code>. This ensures
that in the case of an RPL with Bayesian priors, recursion is handled
automatically. This significantly simplifies translating the utility function
to lists of parameters to use when optimizing the designs. It is also less
error prone.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normal(mu, sigma)

normal_p(mu, sigma)

lognormal(mu, sigma)

lognormal_p(mu, sigma)

triangular(mu, sigma)

triangular_p(mu, sigma)

uniform(mu, sigma)

uniform_p(mu, sigma)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normal_+3A_mu">mu</code></td>
<td>
<p>A parameter indicating the mean or location of the distribution
depending on whether it is a normal, log-normal, triangular or uniform,
or it can be another call to <code><a href="#topic+normal">normal</a></code>, <code><a href="#topic+lognormal">lognormal</a></code>,
<code><a href="#topic+uniform">uniform</a></code> or <code><a href="#topic+triangular">triangular</a></code> if the model is an RPL with
a Bayesian prior.</p>
</td></tr>
<tr><td><code id="normal_+3A_sigma">sigma</code></td>
<td>
<p>A parameter indicating the SD or spread of the distribution
or it can be another call to <code><a href="#topic+normal">normal</a></code>, <code><a href="#topic+lognormal">lognormal</a></code>,
<code><a href="#topic+uniform">uniform</a></code> or <code><a href="#topic+triangular">triangular</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of parameters
</p>


<h3>Functions</h3>


<ul>
<li> <p><code>normal()</code>: The normal distribution
</p>
</li>
<li> <p><code>normal_p()</code>: The normal distribution when applied to a prior
</p>
</li>
<li> <p><code>lognormal()</code>: The log normal distribution
</p>
</li>
<li> <p><code>lognormal_p()</code>: The log-normal distribution when applied to a prior
</p>
</li>
<li> <p><code>triangular()</code>: The triangular distribution
</p>
</li>
<li> <p><code>triangular_p()</code>: The triangular distribution when applied to a prior
</p>
</li>
<li> <p><code>uniform()</code>: The uniform distribution
</p>
</li>
<li> <p><code>uniform_p()</code>: The uniform distribution when applied to a prior
</p>
</li></ul>

<hr>
<h2 id='occurrences'>Extract or set attribute level occurrences</h2><span id='topic+occurrences'></span>

<h3>Description</h3>

<p>This function will set the range of attribute level occurrences equal to to
the size of the design. This is equivalent to fully letting go of attribute
level balance. Letting go of attribute level balance is the default behavior
for the Modified Federov algorithm and the Random algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>occurrences(x, rows)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="occurrences_+3A_x">x</code></td>
<td>
<p>An object of class 'utility' or 'spdesign'</p>
</td></tr>
<tr><td><code id="occurrences_+3A_rows">rows</code></td>
<td>
<p>Number of rows in the design</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If restrictions are placed on attribute level occurrence in the utility
function, then this function will extract these and add them to the output.
</p>
<p>Notice that specifying restrictions in the utility function only matters for
the Modified Federov and Random algorithms and will in general result in a
less efficient design.
</p>


<h3>Value</h3>

<p>A named list of lists where the outer list is for the attributes and
the inner list, the levels of each attribute and the number or range of times
they can occur
</p>

<hr>
<h2 id='prepare_priors'>Prepare the list of priors</h2><span id='topic+prepare_priors'></span>

<h3>Description</h3>

<p>Prepare the list of priors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>prepare_priors(utility, draws, R)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="prepare_priors_+3A_utility">utility</code></td>
<td>
<p>A named list of utility functions. See the examples and the
vignette for examples of how to define these correctly for different types
of experimental designs.</p>
</td></tr>
<tr><td><code id="prepare_priors_+3A_draws">draws</code></td>
<td>
<p>The type of draws to use with Bayesian priors. No default is set
and must be specified even if you are not creating a Bayesian design. Can be
one of &quot;pseudo-random&quot;, &quot;mlhs&quot;, &quot;standard-halton&quot;, &quot;scrambled-halton&quot;,
&quot;standard-sobol&quot;,&quot;scrambled-sobol&quot;.</p>
</td></tr>
<tr><td><code id="prepare_priors_+3A_r">R</code></td>
<td>
<p>An integer giving the number of draws to use. The default is 100.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of priors
</p>

<hr>
<h2 id='print_efficiency_criteria'>Creates a printable version of the efficiency criteria</h2><span id='topic+print_efficiency_criteria'></span>

<h3>Description</h3>

<p>The function prints a string of efficiency criteria to the console and
highlights the color of the considered efficiency criteria. Effectively it
is a wrapper around multiple calls to <code><a href="base.html#topic+cat">cat</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_efficiency_criteria(
  iter,
  values,
  criteria,
  digits = 4,
  padding = 10,
  efficiency_criteria
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_efficiency_criteria_+3A_iter">iter</code></td>
<td>
<p>An integer giving the iteration of the loop</p>
</td></tr>
<tr><td><code id="print_efficiency_criteria_+3A_values">values</code></td>
<td>
<p>The value of the efficiency criteria obtained by
<code><a href="#topic+calculate_efficiency_criteria">calculate_efficiency_criteria</a></code></p>
</td></tr>
<tr><td><code id="print_efficiency_criteria_+3A_criteria">criteria</code></td>
<td>
<p>A character string with the name of the efficiency criteria.
See manual for valid values</p>
</td></tr>
<tr><td><code id="print_efficiency_criteria_+3A_digits">digits</code></td>
<td>
<p>The nubmer of digits to round the printed value to. The default
is 4.</p>
</td></tr>
<tr><td><code id="print_efficiency_criteria_+3A_padding">padding</code></td>
<td>
<p>An integer specifying the padding of each column element.
Default value is 10.</p>
</td></tr>
<tr><td><code id="print_efficiency_criteria_+3A_efficiency_criteria">efficiency_criteria</code></td>
<td>
<p>The criteria that we optimize over</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string.
</p>

<hr>
<h2 id='print_initial_header'>Prints the initial header for the table of results</h2><span id='topic+print_initial_header'></span>

<h3>Description</h3>

<p>The function prints the initial header for the console output and colors in
the criteria used for optimization. Effectively, the function makes multiple
calls to <code><a href="base.html#topic+cat">cat</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_initial_header(efficiency_criteria, padding = 10, width = 80)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_initial_header_+3A_efficiency_criteria">efficiency_criteria</code></td>
<td>
<p>The criteria that we optimize over</p>
</td></tr>
<tr><td><code id="print_initial_header_+3A_padding">padding</code></td>
<td>
<p>An integer specifying the padding of each column element.
Default value is 10.</p>
</td></tr>
<tr><td><code id="print_initial_header_+3A_width">width</code></td>
<td>
<p>An integer giving the width of the horizontal rules. Default
value is 80</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Noting
</p>

<hr>
<h2 id='print_iteration_information'>Prints iteration information</h2><span id='topic+print_iteration_information'></span>

<h3>Description</h3>

<p>Prints iteration information every time a better design is found. The
function wraps around <code><a href="#topic+print_initial_header">print_initial_header</a></code> and
<code><a href="#topic+print_efficiency_criteria">print_efficiency_criteria</a></code>. This reduces the number of
if-statements and function calls within <code><a href="#topic+generate_design">generate_design</a></code> in an
attempt simplify code maintenance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>print_iteration_information(
  iter,
  values,
  criteria,
  digits = 4,
  padding = 10,
  width = 80,
  efficiency_criteria
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_iteration_information_+3A_iter">iter</code></td>
<td>
<p>An integer giving the iteration of the loop</p>
</td></tr>
<tr><td><code id="print_iteration_information_+3A_values">values</code></td>
<td>
<p>The value of the efficiency criteria obtained by
<code><a href="#topic+calculate_efficiency_criteria">calculate_efficiency_criteria</a></code></p>
</td></tr>
<tr><td><code id="print_iteration_information_+3A_criteria">criteria</code></td>
<td>
<p>A character string with the name of the efficiency criteria.
See manual for valid values</p>
</td></tr>
<tr><td><code id="print_iteration_information_+3A_digits">digits</code></td>
<td>
<p>The nubmer of digits to round the printed value to. The default
is 4.</p>
</td></tr>
<tr><td><code id="print_iteration_information_+3A_padding">padding</code></td>
<td>
<p>An integer specifying the padding of each column element.
Default value is 10.</p>
</td></tr>
<tr><td><code id="print_iteration_information_+3A_width">width</code></td>
<td>
<p>An integer giving the width of the horizontal rules. Default
value is 80</p>
</td></tr>
<tr><td><code id="print_iteration_information_+3A_efficiency_criteria">efficiency_criteria</code></td>
<td>
<p>The criteria that we optimize over</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing
</p>

<hr>
<h2 id='print.spdesign'>A generic function for printing an 'spdesign' object</h2><span id='topic+print.spdesign'></span>

<h3>Description</h3>

<p>A generic function for printing an 'spdesign' object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spdesign'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.spdesign_+3A_x">x</code></td>
<td>
<p>A model object of class 'spdesign'</p>
</td></tr>
<tr><td><code id="print.spdesign_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to the function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Prints the 'spdesign' object.
</p>

<hr>
<h2 id='priors'>Generic for extracting the vector of priors</h2><span id='topic+priors'></span>

<h3>Description</h3>

<p>Generic for extracting the vector of priors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>priors(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="priors_+3A_x">x</code></td>
<td>
<p>An object of class 'utility' or 'spdesign'</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of named priors used in the optimization
</p>

<hr>
<h2 id='probabilities'>Calculate the probabilities of the design</h2><span id='topic+probabilities'></span>

<h3>Description</h3>

<p>Will take the design object and calculate the probabilities of each
alternative and choice tasks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probabilities(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="probabilities_+3A_x">x</code></td>
<td>
<p>An 'spdesign' object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Using Bayesian priors the average across the prior distribution will be used.
</p>
<p>Using the specific type of model, either the MNL or RPL probs will be
returned.
</p>


<h3>Value</h3>

<p>A matrix of probabilities for each alternative and choice task.
</p>

<hr>
<h2 id='probabilities_mnl'>Calculate the MNL probabilities</h2><span id='topic+probabilities_mnl'></span>

<h3>Description</h3>

<p>Calculate the MNL probabilities
</p>


<h3>Usage</h3>

<pre><code class='language-R'>probabilities_mnl(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="probabilities_mnl_+3A_x">x</code></td>
<td>
<p>An 'spdesign' object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix of probabilities for each alternative and choice task. With
Bayesian priors the return is the average probabilites over the prior
distribution
</p>

<hr>
<h2 id='radical_inverse'>Compute the radical inverse</h2><span id='topic+radical_inverse'></span>

<h3>Description</h3>

<p>Equation 2 in Bhat (2003)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>radical_inverse(n_dim, primes, count, digit, perms)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="radical_inverse_+3A_n_dim">n_dim</code></td>
<td>
<p>Number of dimensions</p>
</td></tr>
<tr><td><code id="radical_inverse_+3A_primes">primes</code></td>
<td>
<p>A vector of prime numbers</p>
</td></tr>
<tr><td><code id="radical_inverse_+3A_count">count</code></td>
<td>
<p>A matrix</p>
</td></tr>
<tr><td><code id="radical_inverse_+3A_digit">digit</code></td>
<td>
<p>A vector</p>
</td></tr>
<tr><td><code id="radical_inverse_+3A_perms">perms</code></td>
<td>
<p>A matrix of the permutations. Defaults to a set of
Braaten-Weller permutations.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Bhat, C. n_draws., 2003, Simulation Estimation of Mixed Descrete
Choice Models Using Randomized and Scrambled Halton Sequences, Transportation
Research Part B, 9, pp. 837-855
</p>

<hr>
<h2 id='random'>Make a random design</h2><span id='topic+random'></span>

<h3>Description</h3>

<p>Generates a random design by sampling from the candidate set each update of
the algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random(
  design_object,
  model,
  efficiency_criteria,
  utility,
  prior_values,
  dudx,
  candidate_set,
  rows,
  control
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_+3A_design_object">design_object</code></td>
<td>
<p>A list of class 'spdesign' created within the
<code><a href="#topic+generate_design">generate_design</a></code> function</p>
</td></tr>
<tr><td><code id="random_+3A_model">model</code></td>
<td>
<p>A character string indicating the model to optimize the design
for. Currently the only model programmed is the 'mnl' model and this is also
set as the default.</p>
</td></tr>
<tr><td><code id="random_+3A_efficiency_criteria">efficiency_criteria</code></td>
<td>
<p>A character string giving the efficiency criteria
to optimize for. One of 'a-error', 'c-error', 'd-error' or 's-error'. No
default is set and argument must be specified. Optimizing for multiple
criteria is not yet implemented and will result in an error.</p>
</td></tr>
<tr><td><code id="random_+3A_utility">utility</code></td>
<td>
<p>A named list of utility functions. See the examples and the
vignette for examples of how to define these correctly for different types
of experimental designs.</p>
</td></tr>
<tr><td><code id="random_+3A_prior_values">prior_values</code></td>
<td>
<p>A list of priors</p>
</td></tr>
<tr><td><code id="random_+3A_dudx">dudx</code></td>
<td>
<p>A character string giving the name of the prior in the
denominator. Must be specified when optimizing for 'c-error'</p>
</td></tr>
<tr><td><code id="random_+3A_candidate_set">candidate_set</code></td>
<td>
<p>A matrix or data frame in the &quot;wide&quot; format containing
all permitted combinations of attributes. The default is NULL. If no
candidate set is provided, then the full factorial subject to specified
exclusions will be used. This is passed in as an object and not a character
string. The candidate set will be expanded to include zero columns to
consider alternative specific attributes.</p>
</td></tr>
<tr><td><code id="random_+3A_rows">rows</code></td>
<td>
<p>An integer giving the number of rows in the final design</p>
</td></tr>
<tr><td><code id="random_+3A_control">control</code></td>
<td>
<p>A list of control options</p>
</td></tr>
</table>


<h3>Details</h3>

<p>With no restrictions placed, this type of design will only consider efficiency.
There is no guarantee that you will achieve attribute level balance, nor that
all attribute levels will be present. More efficient designs tend to have
more extreme trade-offs.
</p>


<h3>Value</h3>

<p>A list of class 'spdesign'
</p>

<hr>
<h2 id='random_design_candidate'>Create a random design_object candidate</h2><span id='topic+random_design_candidate'></span>

<h3>Description</h3>

<p>Sample from the candidate set to create a random design_object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>random_design_candidate(utility, candidate_set, rows, sample_with_replacement)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="random_design_candidate_+3A_utility">utility</code></td>
<td>
<p>A named list of utility functions. See the examples and the
vignette for examples of how to define these correctly for different types
of experimental designs.</p>
</td></tr>
<tr><td><code id="random_design_candidate_+3A_candidate_set">candidate_set</code></td>
<td>
<p>A matrix or data frame in the &quot;wide&quot; format containing
all permitted combinations of attributes. The default is NULL. If no
candidate set is provided, then the full factorial subject to specified
exclusions will be used. This is passed in as an object and not a character
string. The candidate set will be expanded to include zero columns to
consider alternative specific attributes.</p>
</td></tr>
<tr><td><code id="random_design_candidate_+3A_rows">rows</code></td>
<td>
<p>An integer giving the number of rows in the final design</p>
</td></tr>
<tr><td><code id="random_design_candidate_+3A_sample_with_replacement">sample_with_replacement</code></td>
<td>
<p>A boolean equal to TRUE if we sample from the
candidate set with replacement. The default is FALSE</p>
</td></tr>
</table>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+vcov'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>stats</dt><dd><p><code><a href="stats.html#topic+vcov">vcov</a></code></p>
</dd>
</dl>

<hr>
<h2 id='relabel'>Relabeling of attribute levels</h2><span id='topic+relabel'></span>

<h3>Description</h3>

<p>Relabels the attribute levels to create a new design candidate. For example,
if the column contains the levels (1, 2, 1, 3, 2, 3) and 1 and 3 are
relabeled, then the column becomes (3, 2, 3, 1, 2, 1), i.e. 1 becomes 3 and
3 becomes 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>relabel(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="relabel_+3A_x">x</code></td>
<td>
<p>A vector of attribute levels</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Will randomly sample 2 attribute levels that will be relabeled and the
relabeling is done independently for each column, which implies that
the same attribute will be relabeled differently depending on which
alternative it belongs to.
</p>


<h3>References</h3>

<p>Hensher, D. A., Rose, J. M. &amp; Greene, W., 2005, Applied Choice Analysis,
2nd ed., Cambridge University Press
</p>

<hr>
<h2 id='remove_all_brackets'>Removes all brackets</h2><span id='topic+remove_all_brackets'></span>

<h3>Description</h3>

<p>Takes a string as input and removes everything between square and round
brackets. The function wraps around <code><a href="#topic+remove_square_brackets">remove_square_brackets</a></code> and
<code><a href="#topic+remove_round_brackets">remove_round_brackets</a></code>. To avoid problems, we first remove
square brackets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_all_brackets(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_all_brackets_+3A_string">string</code></td>
<td>
<p>A character string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string without brackets
</p>

<hr>
<h2 id='remove_prior'>Removes the parameter from the utility string</h2><span id='topic+remove_prior'></span>

<h3>Description</h3>

<p>Removes the parameter from the utility string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_prior(prior, string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_prior_+3A_prior">prior</code></td>
<td>
<p>A string with the parameter name</p>
</td></tr>
<tr><td><code id="remove_prior_+3A_string">string</code></td>
<td>
<p>A string to remove param from</p>
</td></tr>
</table>

<hr>
<h2 id='remove_round_brackets'>Remove round bracket</h2><span id='topic+remove_round_brackets'></span>

<h3>Description</h3>

<p>Removes everything between (and including) round brackets. We negating
matches with I(), since this is R's interaction operator.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_round_brackets(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_round_brackets_+3A_string">string</code></td>
<td>
<p>A character string</p>
</td></tr>
</table>


<h3>Details</h3>

<p>(?&lt;!I) - A negative lookbehind for I
</p>

<hr>
<h2 id='remove_square_brackets'>Remove square bracket</h2><span id='topic+remove_square_brackets'></span>

<h3>Description</h3>

<p>Removes everything between (and including) square brackets
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_square_brackets(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_square_brackets_+3A_string">string</code></td>
<td>
<p>A character string</p>
</td></tr>
</table>

<hr>
<h2 id='remove_whitespace'>Remove all white spaces</h2><span id='topic+remove_whitespace'></span>

<h3>Description</h3>

<p>Takes a string as an input and removes all whitespaces in the string
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_whitespace(string)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="remove_whitespace_+3A_string">string</code></td>
<td>
<p>A character string</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with no white spaces
</p>

<hr>
<h2 id='rep_cols'>Repeat columns</h2><span id='topic+rep_cols'></span>

<h3>Description</h3>

<p>Repeats each column of the matrix or data frame 'x' a number of times equal
to 'times'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rep_cols(x, times)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rep_cols_+3A_x">x</code></td>
<td>
<p>A matrix or data frame</p>
</td></tr>
<tr><td><code id="rep_cols_+3A_times">times</code></td>
<td>
<p>An integer indicating the number of times to repeat the
row/column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or data.frame depending on the type of the input
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_matrix &lt;- matrix(runif(12), 4)
rep_cols(test_matrix, 2)

</code></pre>

<hr>
<h2 id='rep_rows'>Repeat rows</h2><span id='topic+rep_rows'></span>

<h3>Description</h3>

<p>Repeats each row in the matrix or data frame 'x' a number of times equal to
'times'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rep_rows(x, times)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rep_rows_+3A_x">x</code></td>
<td>
<p>A matrix or data frame</p>
</td></tr>
<tr><td><code id="rep_rows_+3A_times">times</code></td>
<td>
<p>An integer indicating the number of times to repeat the
row/column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix or data.frame depending on type of the input
</p>


<h3>Examples</h3>

<pre><code class='language-R'>test_matrix &lt;- matrix(runif(12), 4)
rep_rows(test_matrix, 2)

</code></pre>

<hr>
<h2 id='rsc'>Make a design candidate based on the rsc algorithm</h2><span id='topic+rsc'></span>

<h3>Description</h3>

<p>Depending on the setting the function calls a combination of
<code><a href="#topic+relabel">relabel</a></code>, <code><a href="#topic+swap">swap</a></code> and <code><a href="#topic+cycle">cycle</a></code>
to create new design candidates. The code is intentionally written modular
to allow for all special cases of the algorithm.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rsc(
  design_object,
  model,
  efficiency_criteria,
  utility,
  prior_values,
  dudx,
  candidate_set,
  rows,
  control
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rsc_+3A_design_object">design_object</code></td>
<td>
<p>A list of class 'spdesign' created within the
<code><a href="#topic+generate_design">generate_design</a></code> function</p>
</td></tr>
<tr><td><code id="rsc_+3A_model">model</code></td>
<td>
<p>A character string indicating the model to optimize the design
for. Currently the only model programmed is the 'mnl' model and this is also
set as the default.</p>
</td></tr>
<tr><td><code id="rsc_+3A_efficiency_criteria">efficiency_criteria</code></td>
<td>
<p>A character string giving the efficiency criteria
to optimize for. One of 'a-error', 'c-error', 'd-error' or 's-error'. No
default is set and argument must be specified. Optimizing for multiple
criteria is not yet implemented and will result in an error.</p>
</td></tr>
<tr><td><code id="rsc_+3A_utility">utility</code></td>
<td>
<p>A named list of utility functions. See the examples and the
vignette for examples of how to define these correctly for different types
of experimental designs.</p>
</td></tr>
<tr><td><code id="rsc_+3A_prior_values">prior_values</code></td>
<td>
<p>A list of priors</p>
</td></tr>
<tr><td><code id="rsc_+3A_dudx">dudx</code></td>
<td>
<p>A character string giving the name of the prior in the
denominator. Must be specified when optimizing for 'c-error'</p>
</td></tr>
<tr><td><code id="rsc_+3A_candidate_set">candidate_set</code></td>
<td>
<p>A matrix or data frame in the &quot;wide&quot; format containing
all permitted combinations of attributes. The default is NULL. If no
candidate set is provided, then the full factorial subject to specified
exclusions will be used. This is passed in as an object and not a character
string. The candidate set will be expanded to include zero columns to
consider alternative specific attributes.</p>
</td></tr>
<tr><td><code id="rsc_+3A_rows">rows</code></td>
<td>
<p>An integer giving the number of rows in the final design</p>
</td></tr>
<tr><td><code id="rsc_+3A_control">control</code></td>
<td>
<p>A list of control options</p>
</td></tr>
</table>

<hr>
<h2 id='set_default_level_occurrence'>Sets the default level occurrence in an attribute level balanced design</h2><span id='topic+set_default_level_occurrence'></span>

<h3>Description</h3>

<p>The function sets the default level occurrence of an attribute when a design
is restricted to be attribute level balanced. If the design cannot be
attribute level balanced, then the restriction will be relaxed for each
attribute failing to meet this criteria. Specifically, the code will impose
a minimum range of how often an attribute level can occur. This will secure
that the design is near attribute level balanced. In this case a warning is
issued.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_default_level_occurrence(n_lvls, rows)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_default_level_occurrence_+3A_n_lvls">n_lvls</code></td>
<td>
<p>An integer giving the number of levels for the considered
attribute</p>
</td></tr>
<tr><td><code id="set_default_level_occurrence_+3A_rows">rows</code></td>
<td>
<p>Number of rows in the design</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of lists where the top level gives the attribute and the
lower level gives the times or range each attribute level should occur in
the design
</p>

<hr>
<h2 id='set_default_options'>Validate design opt</h2><span id='topic+set_default_options'></span>

<h3>Description</h3>

<p>The function takes the list of design options and adds default values where
none are specified. This function is exported, but is not intended to be
called by the user of the package. The function is called from within
<code><a href="#topic+generate_design">generate_design</a></code> to populate the list with sensible defaults
</p>


<h3>Usage</h3>

<pre><code class='language-R'>set_default_options(opts_input)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="set_default_options_+3A_opts_input">opts_input</code></td>
<td>
<p>A list of user supplied design options</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of design options populated by sensible default values
</p>

<hr>
<h2 id='shuffle'>Shuffle the order of points in the unit interval.</h2><span id='topic+shuffle'></span>

<h3>Description</h3>

<p>Shuffle the order of points in the unit interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shuffle(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="shuffle_+3A_x">x</code></td>
<td>
<p>A vector</p>
</td></tr>
</table>

<hr>
<h2 id='summary.spdesign'>Create a summary of the experimental design</h2><span id='topic+summary.spdesign'></span>

<h3>Description</h3>

<p>Create a summary of the experimental design
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spdesign'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.spdesign_+3A_object">object</code></td>
<td>
<p>A model object of class 'spdesign'</p>
</td></tr>
<tr><td><code id="summary.spdesign_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No return value. Prints a summary of the 'spdesign' object to the
console
</p>

<hr>
<h2 id='swap'>Swapping of attribute</h2><span id='topic+swap'></span>

<h3>Description</h3>

<p>Swaps the order of the attributes to create a new design candidate. For
example, if the attributes in the first and fourth choice situation (row)
are swapped, then (1, 2, 1, 3, 2, 3) becomes( 3, 2, 1, 1, 2, 3).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>swap(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="swap_+3A_x">x</code></td>
<td>
<p>A vector of attribute levels</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm randomly samples 2 row positions that are swapped and
the swaps are independent across attributes and alternatives
</p>


<h3>References</h3>

<p>Hensher, D. A., Rose, J. M. &amp; Greene, W., 2005, Applied Choice Analysis,
2nd ed., Cambridge University Press
</p>

<hr>
<h2 id='too_small'>Check if the design is too small</h2><span id='topic+too_small'></span>

<h3>Description</h3>

<p>Uses the formula of T * (J - 1) to check if the design is large enough to
identify the parameters of the utility function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>too_small(x, rows)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="too_small_+3A_x">x</code></td>
<td>
<p>A list of utility expressions</p>
</td></tr>
<tr><td><code id="too_small_+3A_rows">rows</code></td>
<td>
<p>The number of rows in the design</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A boolean equal to 'TRUE' if the design is too small
</p>

<hr>
<h2 id='transform_distribution'>Transform distribution</h2><span id='topic+transform_distribution'></span>

<h3>Description</h3>

<p>Transform distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_distribution(mu, sigma, eta, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform_distribution_+3A_mu">mu</code></td>
<td>
<p>A value for the mean of the distribution</p>
</td></tr>
<tr><td><code id="transform_distribution_+3A_sigma">sigma</code></td>
<td>
<p>A value for the standard deviation of the distribution</p>
</td></tr>
<tr><td><code id="transform_distribution_+3A_eta">eta</code></td>
<td>
<p>A numeric standard uniform vector</p>
</td></tr>
<tr><td><code id="transform_distribution_+3A_type">type</code></td>
<td>
<p>The type of distribution</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector with the transformed distribution given the parameters
</p>

<hr>
<h2 id='transform_lognormal'>Transform to the lognormal distribution</h2><span id='topic+transform_lognormal'></span>

<h3>Description</h3>

<p>Transform to the lognormal distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_lognormal(mu, sigma, eta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform_lognormal_+3A_mu">mu</code></td>
<td>
<p>A value for the mean of the distribution</p>
</td></tr>
<tr><td><code id="transform_lognormal_+3A_sigma">sigma</code></td>
<td>
<p>A value for the standard deviation of the distribution</p>
</td></tr>
<tr><td><code id="transform_lognormal_+3A_eta">eta</code></td>
<td>
<p>A numeric standard uniform vector</p>
</td></tr>
</table>

<hr>
<h2 id='transform_normal'>Transform to the normal distribution</h2><span id='topic+transform_normal'></span>

<h3>Description</h3>

<p>Transform to the normal distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_normal(mu, sigma, eta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform_normal_+3A_mu">mu</code></td>
<td>
<p>A value for the mean of the distribution</p>
</td></tr>
<tr><td><code id="transform_normal_+3A_sigma">sigma</code></td>
<td>
<p>A value for the standard deviation of the distribution</p>
</td></tr>
<tr><td><code id="transform_normal_+3A_eta">eta</code></td>
<td>
<p>A numeric standard uniform vector</p>
</td></tr>
</table>

<hr>
<h2 id='transform_triangular'>Transform to the triangular distribution</h2><span id='topic+transform_triangular'></span>

<h3>Description</h3>

<p>Transform to the triangular distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_triangular(mu, sigma, eta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform_triangular_+3A_mu">mu</code></td>
<td>
<p>A value for the mean of the distribution</p>
</td></tr>
<tr><td><code id="transform_triangular_+3A_sigma">sigma</code></td>
<td>
<p>A value for the standard deviation of the distribution</p>
</td></tr>
<tr><td><code id="transform_triangular_+3A_eta">eta</code></td>
<td>
<p>A numeric standard uniform vector</p>
</td></tr>
</table>

<hr>
<h2 id='transform_uniform'>Transform to the uniform distribution</h2><span id='topic+transform_uniform'></span>

<h3>Description</h3>

<p>Transform to the uniform distribution
</p>


<h3>Usage</h3>

<pre><code class='language-R'>transform_uniform(mu, sigma, eta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="transform_uniform_+3A_mu">mu</code></td>
<td>
<p>A value for the mean of the distribution</p>
</td></tr>
<tr><td><code id="transform_uniform_+3A_sigma">sigma</code></td>
<td>
<p>A value for the standard deviation of the distribution</p>
</td></tr>
<tr><td><code id="transform_uniform_+3A_eta">eta</code></td>
<td>
<p>A numeric standard uniform vector</p>
</td></tr>
</table>

<hr>
<h2 id='update_utility'>Update the utility function</h2><span id='topic+update_utility'></span>

<h3>Description</h3>

<p>Updates the utility function to consider dummy coded attributes. It will
expand the dummy-coding to K-1 dropping the lowest level. This is consistent
with standard practice.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>update_utility(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="update_utility_+3A_x">x</code></td>
<td>
<p>An object of class utility</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is called prior to evaluating designs if dummy-coded attributes
are present in the utility function. This is because the utility function
is evaluated in the context of the design environment and must be added there
</p>
<p>Important to note about the naming of the expanded priors and attributes:
The names for the attributes will be attached with the level of the factor,
whereas the prior will be named corresponding to the level, e.g., 2, 3, 4.
This is simply the result of the difference between how it's extracted from
the utility functions and how model.matrix creates names.
</p>


<h3>Value</h3>

<p>An updated cleaned utility expression
</p>

<hr>
<h2 id='utility_formula'>Create formulas from the utility functions</h2><span id='topic+utility_formula'></span>

<h3>Description</h3>

<p>Create formulas from the utility functions such that we can create correct
model matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utility_formula(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utility_formula_+3A_x">x</code></td>
<td>
<p>An object of class utility</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that this function should be used on a cleaned utility expression and
**not** an updated utility expression. This is because we are converting
dummy coded attributes to factors prior to calling <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>.
This ensures that dummy coded attributes are correctly returned with the
model matrix.
</p>


<h3>Value</h3>

<p>A list of formula expressions for the utility functions
</p>

<hr>
<h2 id='vcov.spdesign'>Extract the variance co-variance matrix</h2><span id='topic+vcov.spdesign'></span>

<h3>Description</h3>

<p>A generic method for extracting the variance covariance matrix from a design
object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'spdesign'
vcov(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="vcov.spdesign_+3A_object">object</code></td>
<td>
<p>A model object of class 'spdesign'</p>
</td></tr>
<tr><td><code id="vcov.spdesign_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the function</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix with row- and column names equal to the parameter names
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
