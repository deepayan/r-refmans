<!DOCTYPE html><html><head><title>Help for package bamlss</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bamlss}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bamlss-package'>
<p>Bayesian Additive Models for Location Scale and Shape (and Beyond)</p></a></li>
<li><a href='#bamlss'>
<p>Fit Bayesian Additive Models for Location Scale and Shape (and Beyond)</p></a></li>
<li><a href='#BAMLSS'><p>Create <span class="pkg">distributions3</span> Object</p></a></li>
<li><a href='#bamlss.engine.helpers'>
<p>BAMLSS Engine Helper Functions</p></a></li>
<li><a href='#bamlss.engine.setup'>
<p>BAMLSS Engine Setup Function</p></a></li>
<li><a href='#bamlss.formula'>
<p>Formulae for BAMLSS</p></a></li>
<li><a href='#bamlss.frame'>
<p>Create a Model Frame for BAMLSS</p></a></li>
<li><a href='#bboost'><p>Bootstrap Boosting</p></a></li>
<li><a href='#boost2'><p>Some Shortcuts</p></a></li>
<li><a href='#c95'>
<p>Compute 95% Credible Interval and Mean</p></a></li>
<li><a href='#coef.bamlss'>
<p>Extract BAMLSS Coefficients</p></a></li>
<li><a href='#colorlegend'>
<p>Plot a Color Legend</p></a></li>
<li><a href='#continue'>
<p>Continue Sampling</p></a></li>
<li><a href='#cox_predict'>
<p>Cox Model Prediction</p></a></li>
<li><a href='#Crazy'>
<p>Crazy simulated data</p></a></li>
<li><a href='#CRPS'>
<p>Continuous Rank Probability Score</p></a></li>
<li><a href='#ddnn'><p>Deep Distributional Neural Network</p></a></li>
<li><a href='#DIC'>
<p>Deviance Information Criterion</p></a></li>
<li><a href='#dist_mvnchol'><p>Cholesky MVN (disttree)</p></a></li>
<li><a href='#engines'>
<p>Show Available Engines for a Family Object</p></a></li>
<li><a href='#family.bamlss'>
<p>Distribution Families in <span class="pkg">bamlss</span></p></a></li>
<li><a href='#fatalities'><p>Weekly Number of Fatalities in Austria</p></a></li>
<li><a href='#fitted.bamlss'>
<p>BAMLSS Fitted Values</p></a></li>
<li><a href='#GAMart'><p>GAM Artificial Data Set</p></a></li>
<li><a href='#gamlss_distributions'>
<p>Extract Distribution families of the <span class="pkg">gamlss.dist</span> Package</p></a></li>
<li><a href='#gF'>
<p>Get a BAMLSS Family</p></a></li>
<li><a href='#Golf'><p>Prices of Used Cars Data</p></a></li>
<li><a href='#homstart_data'>
<p>HOMSTART Precipitation Data</p></a></li>
<li><a href='#jm_bamlss'>
<p>Fit Flexible Additive Joint Models</p></a></li>
<li><a href='#la'><p>Lasso Smooth Constructor</p></a></li>
<li><a href='#lin'><p>Linear Effects for BAMLSS</p></a></li>
<li><a href='#LondonFire'><p>London Fire Data</p></a></li>
<li><a href='#make_formula'><p>Formula Generator</p></a></li>
<li><a href='#model.frame.bamlss'>
<p>BAMLSS Model Frame</p></a></li>
<li><a href='#model.matrix.bamlss.frame'>
<p>Construct/Extract BAMLSS Design Matrices</p></a></li>
<li><a href='#mvn_chol'><p>Cholesky MVN</p></a></li>
<li><a href='#mvn_modchol'><p>Modified Cholesky MVN</p></a></li>
<li><a href='#mvnchol_bamlss'><p>Cholesky MVN</p></a></li>
<li><a href='#n'><p>Neural Networks for BAMLSS</p></a></li>
<li><a href='#neighbormatrix'>
<p>Compute a Neighborhood Matrix from Spatial Polygons</p></a></li>
<li><a href='#opt_bbfit'><p>Batchwise Backfitting</p></a></li>
<li><a href='#opt_bfit'>
<p>Fit BAMLSS with Backfitting</p></a></li>
<li><a href='#opt_boost'><p>Boosting BAMLSS</p></a></li>
<li><a href='#opt_Cox'>
<p>Cox Model Posterior Mode Estimation</p></a></li>
<li><a href='#opt_isgd'>
<p>Implicit Stochastic Gradient Descent Optimizer</p></a></li>
<li><a href='#parameters'><p>Extract or Initialize Parameters for BAMLSS</p></a></li>
<li><a href='#pathplot'><p>Plot Coefficients Paths</p></a></li>
<li><a href='#plot.bamlss'>
<p>Plotting BAMLSS</p></a></li>
<li><a href='#plot2d'>
<p>Plot 2D Effects</p></a></li>
<li><a href='#plot3d'>
<p>Plot 3D Effects</p></a></li>
<li><a href='#plotblock'>
<p>Factor Variable and Random Effects Plots</p></a></li>
<li><a href='#plotmap'>
<p>Plot Maps</p></a></li>
<li><a href='#predict.bamlss'>
<p>BAMLSS Prediction</p></a></li>
<li><a href='#randomize'>
<p>Transform Smooth Constructs to Random Effects</p></a></li>
<li><a href='#rb'><p>Random Bits for BAMLSS</p></a></li>
<li><a href='#residuals.bamlss'>
<p>Compute BAMLSS Residuals</p></a></li>
<li><a href='#response_name'>
<p>Extract the reponse name of a <code>bamlss.frame</code> object.</p></a></li>
<li><a href='#results.bamlss.default'>
<p>Compute BAMLSS Results for Plotting and Summaries</p></a></li>
<li><a href='#rmf'>
<p>Remove Special Characters</p></a></li>
<li><a href='#s2'>
<p>Special Smooths in BAMLSS Formulae</p></a></li>
<li><a href='#sam_BayesX'>
<p>Markov Chain Monte Carlo for BAMLSS using <span class="pkg">BayesX</span></p></a></li>
<li><a href='#sam_Cox'>
<p>Cox Model Markov Chain Monte Carlo</p></a></li>
<li><a href='#sam_GMCMC'>
<p>General Markov Chain Monte Carlo for BAMLSS</p></a></li>
<li><a href='#sam_JAGS'>
<p>Markov Chain Monte Carlo for BAMLSS using JAGS</p></a></li>
<li><a href='#sam_MVNORM'>
<p>Create Samples for BAMLSS by Multivariate Normal Approximation</p></a></li>
<li><a href='#samples'>
<p>Extract Samples</p></a></li>
<li><a href='#samplestats'>
<p>Sampling Statistics</p></a></li>
<li><a href='#scale2'>
<p>Scaling Vectors and Matrices</p></a></li>
<li><a href='#simdata'><p>Reference data.</p></a></li>
<li><a href='#simJM'>
<p>Simulate longitudinal and survival data for joint models</p></a></li>
<li><a href='#simSurv'>
<p>Simulate Survival Times</p></a></li>
<li><a href='#sliceplot'>
<p>Plot Slices of Bivariate Functions</p></a></li>
<li><a href='#smooth_check'>
<p>MCMC Based Simple Significance Check for Smooth Terms</p></a></li>
<li><a href='#smooth.construct'><p>Constructor Functions for Smooth Terms in BAMLSS</p></a></li>
<li><a href='#smooth.construct.kr.smooth.spec'><p>Kriging Smooth Constructor</p></a></li>
<li><a href='#smooth.construct.ms.smooth.spec'><p>Smooth constructor for monotonic P-splines</p></a></li>
<li><a href='#smooth.construct.sr.smooth.spec'><p>Random Effects P-Spline</p></a></li>
<li><a href='#stabsel'><p>Stability selection.</p></a></li>
<li><a href='#summary.bamlss'>
<p>Summary for BAMLSS</p></a></li>
<li><a href='#surv_transform'>
<p>Survival Model Transformer Function</p></a></li>
<li><a href='#Surv2'>
<p>Create a Survival Object for Joint Models</p></a></li>
<li><a href='#TempIbk'><p>Temperature data.</p></a></li>
<li><a href='#terms.bamlss'>
<p>BAMLSS Model Terms</p></a></li>
<li><a href='#trans_AR1'>
<p>AR1 Transformer Function</p></a></li>
<li><a href='#Volcano'>
<p>Artificial Data Set based on Auckland's Maunga Whau Volcano</p></a></li>
<li><a href='#WAIC'>
<p>Watanabe-Akaike Information Criterion (WAIC)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>1.2-3</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-18</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Additive Models for Location, Scale, and Shape (and
Beyond)</td>
</tr>
<tr>
<td>Description:</td>
<td>Infrastructure for estimating probabilistic distributional regression models in a Bayesian framework.
  The distribution parameters may capture location, scale, shape, etc. and every parameter may depend
  on complex additive terms (fixed, random, smooth, spatial, etc.) similar to a generalized additive model.
  The conceptual and computational framework is introduced in Umlauf, Klein, Zeileis (2019)
  &lt;<a href="https://doi.org/10.1080%2F10618600.2017.1407325">doi:10.1080/10618600.2017.1407325</a>&gt; and the R package in Umlauf, Klein, Simon, Zeileis (2021)
  &lt;<a href="https://doi.org/10.18637%2Fjss.v100.i04">doi:10.18637/jss.v100.i04</a>&gt;.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0), coda, colorspace, distributions3 (&ge; 0.2.1),
mgcv</td>
</tr>
<tr>
<td>Imports:</td>
<td>Formula, MBA, mvtnorm, sp, Matrix, survival, methods, parallel</td>
</tr>
<tr>
<td>Suggests:</td>
<td>bit, ff, fields, gamlss, gamlss.dist, interp, rjags, BayesX,
mapdata, maps, sf, nnet, spatstat, spdep, zoo, keras, splines2,
sdPrior, statmod, glogis, glmnet, scoringRules, knitr,
rmarkdown, MASS, tensorflow</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="http://www.bamlss.org/">http://www.bamlss.org/</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-18 08:56:53 UTC; nik</td>
</tr>
<tr>
<td>Author:</td>
<td>Nikolaus Umlauf <a href="https://orcid.org/0000-0003-2160-9803"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Nadja Klein <a href="https://orcid.org/0000-0002-5072-5347"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut],
  Achim Zeileis <a href="https://orcid.org/0000-0003-0918-3766"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Meike Koehler [ctb],
  Thorsten Simon <a href="https://orcid.org/0000-0002-3778-7738"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut],
  Stanislaus Stadlmann [ctb],
  Alexander Volkmann
    <a href="https://orcid.org/0000-0001-5028-8098"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nikolaus Umlauf &lt;Nikolaus.Umlauf@uibk.ac.at&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-18 10:00:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bamlss-package'>
Bayesian Additive Models for Location Scale and Shape (and Beyond)
</h2><span id='topic+bamlss-package'></span>

<h3>Description</h3>

<p>The <span class="pkg">bamlss</span> package is a general tool for complex Bayesian regression modeling
with structured additive predictors based on Markov chain Monte Carlo simulation.
The design of this package substantially focuses on maximum flexibility and easy
integration of new code and/or standalone systems. The package makes heavy use of
<code><a href="mgcv.html#topic+mgcv">mgcv</a></code> infrastructures to build up all necessary model matrices and
information from which it is relatively easy for the user to construct estimation
algorithms or interfaces to existing software packages. The package can also be
seen as an harmonized framework for regression modeling since it does not restrict
to any type of problem. The main function in this package is <code><a href="#topic+bamlss">bamlss</a></code>,
which is a wrapper function that calls optimizer and/or sampling functions for fitting
Bayesian additive models for location scale and shape (and beyond). These model fitting
functions can be exchanged by the user. Moreover, the package contains numerous
functions for creating post-estimation results like summary statistics and
effect plots etc.
</p>


<h3>Author(s)</h3>

<p>Nikolaus Umlauf, Nadja Klein, Achim Zeileis.
</p>


<h3>References</h3>

<p>Umlauf N, Klein N, Zeileis A (2019). BAMLSS: Bayesian Additive Models for Location,
Scale and Shape (and Beyond). <em>Journal of Computational and Graphical Statistics</em>,
<b>27</b>(3), 612&ndash;627. <a href="https://doi.org/10.1080/10618600.2017.1407325">doi:10.1080/10618600.2017.1407325</a>
</p>
<p>Umlauf N, Klein N, Simon T, Zeileis A (2021).
bamlss: A Lego Toolbox for Flexible Bayesian Regression (and Beyond).
<em>Journal of Statistical Software</em>,
<b>100</b>(4), 1&ndash;53. <a href="https://doi.org/10.18637/jss.v100.i04">doi:10.18637/jss.v100.i04</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bamlss">bamlss</a></code>, <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>
</p>

<hr>
<h2 id='bamlss'>
Fit Bayesian Additive Models for Location Scale and Shape (and Beyond)
</h2><span id='topic+bamlss'></span>

<h3>Description</h3>

<p>This is the main model fitting function of the package. Function <code>bamlss()</code>
is a wrapper function that parses the <code>data</code> and the model <code>formula</code>, or
extended <code><a href="#topic+bamlss.formula">bamlss.formula</a></code>, as well as the <code><a href="#topic+bamlss.family">bamlss.family</a></code>
into a <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>. The <code><a href="#topic+bamlss.frame">bamlss.frame</a></code> then holds all model
matrices and information that is needed for setting up estimation engines.
The model matrices are based on <code><a href="mgcv.html#topic+mgcv">mgcv</a></code> infrastructures, i.e.,
smooth terms are constructed using <code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code> and
<code><a href="mgcv.html#topic+smoothCon">smoothCon</a></code>. Therefore, all <code><a href="mgcv.html#topic+mgcv">mgcv</a></code> model term constructors like
<code><a href="mgcv.html#topic+s">s</a></code>, <code><a href="mgcv.html#topic+te">te</a></code>, <code><a href="mgcv.html#topic+t2">t2</a></code> and <code><a href="mgcv.html#topic+ti">ti</a></code>
can be used. Identifiability conditions are imposed using function <code><a href="mgcv.html#topic+gam.side">gam.side</a></code>.
</p>
<p>After the <code><a href="#topic+bamlss.frame">bamlss.frame</a></code> is set up function <code>bamlss()</code> applies optimizer
and/or sampling functions. These functions can also be provided by the user. See the details
below on how to create new engines to be used with function <code>bamlss()</code>.
</p>
<p>Finally, the estimated parameters and/or samples are used to create model output results like
summary statistics or effect plots. The computation of results may also be controlled by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bamlss(formula, family = "gaussian", data = NULL,
  start = NULL, knots = NULL, weights = NULL,
  subset = NULL, offset = NULL, na.action = na.omit,
  contrasts = NULL, reference = NULL, transform = NULL,
  optimizer = NULL, sampler = NULL, samplestats = NULL,
  results = NULL, cores = NULL, sleep = NULL,
  combine = TRUE, model = TRUE, x = TRUE,
  light = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bamlss_+3A_formula">formula</code></td>
<td>
<p>A formula or extended formula, i.e., the <code>formula</code> can be a
<code><a href="base.html#topic+list">list</a></code> of formulas where each list entry specifies the details of one parameter
of the modeled response distribution, see <code><a href="#topic+bamlss.formula">bamlss.formula</a></code>. For incorporating
smooth terms, all model term constructors implemented in <code><a href="mgcv.html#topic+mgcv">mgcv</a></code> such as
<code><a href="mgcv.html#topic+s">s</a></code>, <code><a href="mgcv.html#topic+te">te</a></code> and <code><a href="mgcv.html#topic+ti">ti</a></code> can be used, amongst others.</p>
</td></tr>
<tr><td><code id="bamlss_+3A_family">family</code></td>
<td>
<p>A <code><a href="#topic+bamlss.family">bamlss.family</a></code> object, specifying the details of the modeled
distribution such as the parameter names, the density function, link functions, etc.
Can be a character without the <code>"_bamlss"</code> extension of the
<code><a href="#topic+bamlss.family">bamlss.family</a></code> name.</p>
</td></tr>
<tr><td><code id="bamlss_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> or <code><a href="base.html#topic+list">list</a></code> containing the model
response variable(s) and covariates specified in the <code>formula</code>.
By default the variables are taken from <code>environment(formula)</code>:
typically the environment from which <code>bamlss</code> is called.</p>
</td></tr>
<tr><td><code id="bamlss_+3A_start">start</code></td>
<td>
<p>A named numeric vector containing starting values to be send to the <code>optimizer</code>
and/or <code>sampler</code> function. For a possible naming convention for the parameters see
function <code><a href="#topic+parameters">parameters</a></code>, but this is not restrictive and engine specific.</p>
</td></tr>
<tr><td><code id="bamlss_+3A_knots">knots</code></td>
<td>
<p>An optional list containing user specified knots, see the documentation of
function <code><a href="mgcv.html#topic+gam">gam</a></code>.</p>
</td></tr>
<tr><td><code id="bamlss_+3A_weights">weights</code></td>
<td>
<p>Prior weights on the data.</p>
</td></tr>
<tr><td><code id="bamlss_+3A_subset">subset</code></td>
<td>
<p>An optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="bamlss_+3A_offset">offset</code></td>
<td>
<p>Can be used to supply model offsets for use in fitting.</p>
</td></tr>
<tr><td><code id="bamlss_+3A_na.action">na.action</code></td>
<td>
<p>A function which indicates what should happen when the data
contain <code>NA</code>'s. The default is set by the <code>na.action</code>
setting of <code><a href="base.html#topic+options">options</a></code>, and is <code><a href="stats.html#topic+na.omit">na.omit</a></code> if set to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="bamlss_+3A_contrasts">contrasts</code></td>
<td>
<p>An optional list. See the <code>contrasts.arg</code> of 
<code><a href="stats.html#topic+model.matrix.default">model.matrix.default</a></code>.</p>
</td></tr>
<tr><td><code id="bamlss_+3A_reference">reference</code></td>
<td>
<p>A <code>character</code> specifying a reference category, e.g., when
fitting a multinomial model.</p>
</td></tr>
<tr><td><code id="bamlss_+3A_transform">transform</code></td>
<td>
<p>A transformer function that is applied on the <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>.
See, e.g., function <code><a href="#topic+randomize">randomize</a></code> and <code><a href="#topic+bamlss.engine.setup">bamlss.engine.setup</a></code>.</p>
</td></tr>
<tr><td><code id="bamlss_+3A_optimizer">optimizer</code></td>
<td>
<p>An optimizer function that returns, e.g., posterior mode estimates
of the parameters as a named numeric vector. The default optimizer function is
<code><a href="#topic+opt_bfit">opt_bfit</a></code>. If set to <code>FALSE</code>, no optimizer function will be used.</p>
</td></tr>
<tr><td><code id="bamlss_+3A_sampler">sampler</code></td>
<td>
<p>A sampler function that returns a matrix of samples, the columns represent the
parameters, the rows the iterations. The returned matrix must be coerced to an object of
class <code>"mcmc"</code>, see <code><a href="coda.html#topic+as.mcmc">as.mcmc</a></code>. The default sampler function is
<code><a href="#topic+sam_GMCMC">sam_GMCMC</a></code>. If set to <code>FALSE</code>, no sampler function will be used.</p>
</td></tr>
<tr><td><code id="bamlss_+3A_samplestats">samplestats</code></td>
<td>
<p>A function computing statistics from samples, per default function
<code><a href="#topic+samplestats">samplestats</a></code> is used. If set to <code>FALSE</code>, no <code>samplestats</code> function
will be used. Note that this option is crucial for very large datasets, as computing
statistics from samples this way may be very time consuming!</p>
</td></tr>
<tr><td><code id="bamlss_+3A_results">results</code></td>
<td>
<p>A function computing results from the parameters and/or samples, e.g., for
creating effect plots, see function <code>link{results.bamlss.default}</code>. If set <code>FALSE</code>
no <code>results</code> function will be used.</p>
</td></tr>
<tr><td><code id="bamlss_+3A_cores">cores</code></td>
<td>
<p>An integer specifying the number of cores that should be used for the sampler
function. This is based on function <code><a href="parallel.html#topic+mclapply">mclapply</a></code> of the <span class="pkg">parallel</span>
package.</p>
</td></tr>
<tr><td><code id="bamlss_+3A_sleep">sleep</code></td>
<td>
<p>Time the system should sleep before the next core is started.</p>
</td></tr>
<tr><td><code id="bamlss_+3A_combine">combine</code></td>
<td>
<p>If samples are computed on multiple cores, should the samples be combined into
one <code><a href="coda.html#topic+mcmc">mcmc</a></code> matrix?</p>
</td></tr>
<tr><td><code id="bamlss_+3A_model">model</code></td>
<td>
<p>If set to <code>FALSE</code> the model frame used for modeling is not part of the
return value.</p>
</td></tr>
<tr><td><code id="bamlss_+3A_x">x</code></td>
<td>
<p>If set to <code>FALSE</code> the model matrices are not part of the return value.</p>
</td></tr>
<tr><td><code id="bamlss_+3A_light">light</code></td>
<td>
<p>Should the returned object be lighter, i.e., if <code>light = TRUE</code> the returned
object will not contain the model.frame and design and penalty matrices are deleted.</p>
</td></tr>
<tr><td><code id="bamlss_+3A_...">...</code></td>
<td>
<p>Arguments passed to the <code>transformer</code>, <code>optimizer</code>, <code>sampler</code>,
<code>results</code> and <code>samplestats</code> function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The main idea of this function is to provide infrastructures that make it relatively easy
to create estimation engines for new problems, or write interfaces to existing software
packages.
</p>
<p>The steps that are performed within the function are:
</p>

<ul>
<li><p> First, the function parses the <code>data</code>, the <code>formula</code> or the extended
<code><a href="#topic+bamlss.formula">bamlss.formula</a></code> as well as the <code><a href="#topic+bamlss.family">bamlss.family</a></code> into a model frame
like object, the <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>. This object holds all necessary model matrices
and information that is needed for subsequent model fitting engines. Per default,
all package <code><a href="mgcv.html#topic+mgcv">mgcv</a></code> smooth term constructor functions like
<code><a href="mgcv.html#topic+s">s</a></code>, <code><a href="mgcv.html#topic+te">te</a></code>, <code><a href="mgcv.html#topic+t2">t2</a></code> and
<code><a href="mgcv.html#topic+ti">ti</a></code> can be used (see also function <code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code>),
however, even special user defined constructors can be included, see the manual of
<code><a href="#topic+bamlss.frame">bamlss.frame</a></code>.
</p>
</li>
<li><p> In a second step, the <code><a href="#topic+bamlss.frame">bamlss.frame</a></code> can be transformed, e.g., if a mixed
model representation of smooth terms is needed, see function <code><a href="#topic+randomize">randomize</a></code>.
</p>
</li>
<li><p> Then an optimizer function is started, e.g., a function that finds posterior mode estimates
of the parameters. A convention for model fitting engines is that such functions should have
the following arguments:
</p>
<p><code>optimizer(x, y, family, start, weights, offset, ...)</code>
</p>
<p>Internally, function <code>bamlss()</code> will send the <code>x</code> object that holds all
model matrices, the response <code>y</code> object, the <code>family</code> object, <code>start</code>ing
values for the parameters, possible <code>weights</code> and <code>offset</code>s of the created
<code><a href="#topic+bamlss.frame">bamlss.frame</a></code> to the
optimizer function (see the manual of <code><a href="#topic+bamlss.frame">bamlss.frame</a></code> for more details on the
<code>x</code>, <code>y</code> and other objects). The job of the optimizer is to return a named numeric
vector of optimum parameters. The names of the parameters should be such that they can be
uniquely mapped to the corresponding model matrices in <code>x</code>. See function
<code><a href="#topic+parameters">parameters</a></code> for more details on parameter names. The default optimizer function
is <code><a href="#topic+opt_bfit">opt_bfit</a></code>. The optimizer can return more information than only the optimum
parameters. It is possible to return a list, the convention here is that an element named
<code>"parameters"</code> then holds the named vector of estimated parameters. Possible other return
values could be fitted values, the Hessian matrix, information criteria or information
about convergence of the algorithm, etc. Note that the parameters are simply added to the
<code><a href="#topic+bamlss.frame">bamlss.frame</a></code> in an (list) entry named <code>parameters</code>.
</p>
</li>
<li><p> After the optimization step, a <code>sampler</code> function is started. The arguments of such
sampler functions are the same as for the <code>optimizer</code> functions
</p>
<p><code>sampler(x, y, family, start, weights, offset, ...)</code>
</p>
<p>Sampler functions must return a matrix of samples, each row represents one iteration and the matrix
can be coerced to <code><a href="coda.html#topic+mcmc">mcmc</a></code> objects. The function may return a list of samples,
e.g., if multiple chains are returned each list entry then holds one sample matrix of
one chain. The column names of the sample matrix should be the same as the names of estimated
parameters. For a possible naming convention see function <code><a href="#topic+parameters">parameters</a></code>, which
ensures unique mapping of samples with the model matrices in the <code>x</code> object of the
<code><a href="#topic+bamlss.frame">bamlss.frame</a></code>. The samples are added to the <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>
in an (list) entry named <code>samples</code>.
</p>
</li>
<li><p> Next, the <code>samplestats</code> function is applied. This function can compute any quantity
from the samples and the <code>x</code> object, the arguments of such functions are
</p>
<p><code>samplestats(samples, x, y, family, ...)</code>
</p>
<p>where argument <code>samples</code> are the samples returned from the <code>sampler</code> function,
and <code>x</code>, <code>y</code> and <code>family</code> are the same objects as passed to the optimizer
and or sampler functions. For example, the default function in <code>bamlss()</code> for this task
is also called <code><a href="#topic+samplestats">samplestats</a></code> and returns the mean of the log-likelihood and the
log-posterior computed of all samples, as well as the DIC.
</p>
</li>
<li><p> The last step is to compute more complex information about the model using the
<code>results</code> function. The arguments of such <code>results</code> functions are
</p>
<p><code>results(bamlss.frame, ...)</code>
</p>
<p>here, the full <code><a href="#topic+bamlss.frame">bamlss.frame</a></code> including possible <code>parameters</code> and
<code>samples</code> is passed to the function within <code>bamlss()</code>. The default function
for this task is <code><a href="#topic+results.bamlss.default">results.bamlss.default</a></code> which returns an object of class
<code>"bamlss.results"</code> for which generic plotting functions are and a <code><a href="base.html#topic+summary">summary</a></code>
function is provided. Hence, the user can control the output of the model, the plotting
and summary statistics, too.
</p>
</li></ul>

<p>Note that function <code>transform()</code>, <code>optimizer()</code>, <code>sampler()</code>, <code>samplestats()</code>
and <code>results()</code> can be provided from the <code><a href="#topic+bamlss.family">bamlss.family</a></code> object, e.g.,
if a <code><a href="#topic+bamlss.family">bamlss.family</a></code> object has an element named <code>"optimizer"</code>, which
represents a valid optimizer function such as <code><a href="#topic+opt_bfit">opt_bfit</a></code>, exactly this optimizer
function will be used as a default when using the family.
</p>


<h3>Value</h3>

<p>An object of class <code>"bamlss"</code>. The object is in principle only a slight extension
of a <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>, i.e., if an <code>optimizer</code> is applied it will hold the
estimated parameters in an additional element named <code>"parameters"</code>. If a sampler function
is applied it will additionally hold the samples in an element named <code>"samples"</code>.
The same mechanism is used for <code>results</code> function.
</p>
<p>If the <code>optimizer</code> function computes additional output next to the parameters, this will
be saved in an element named <code>"model.stats"</code>. If a <code>samplestats</code> function is applied,
the output will also be saved in the <code>"model.stats"</code> element.
</p>
<p>Additionally, all functions that are called are saved as attribute <code>"functions"</code> in the
returned object.
</p>


<h3>Author(s)</h3>

<p>Nikolaus Umlauf, Nadja Klein, Achim Zeileis.
</p>


<h3>References</h3>

<p>Umlauf N, Klein N, Zeileis A (2019). BAMLSS: Bayesian Additive Models for Location,
Scale and Shape (and Beyond). <em>Journal of Computational and Graphical Statistics</em>, <b>27</b>(3), 612&ndash;627.
<a href="https://doi.org/10.1080/10618600.2017.1407325">doi:10.1080/10618600.2017.1407325</a>
</p>
<p>Umlauf N, Klein N, Simon T, Zeileis A (2021).
bamlss: A Lego Toolbox for Flexible Bayesian Regression (and Beyond).
<em>Journal of Statistical Software</em>,
<b>100</b>(4), 1&ndash;53. <a href="https://doi.org/10.18637/jss.v100.i04">doi:10.18637/jss.v100.i04</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bamlss.frame">bamlss.frame</a></code>, <code><a href="#topic+family.bamlss">family.bamlss</a></code>, <code><a href="#topic+bamlss.formula">bamlss.formula</a></code>,
<code><a href="#topic+randomize">randomize</a></code>, <code><a href="#topic+bamlss.engine.setup">bamlss.engine.setup</a></code>,
<code><a href="#topic+opt_bfit">opt_bfit</a></code>, <code><a href="#topic+sam_GMCMC">sam_GMCMC</a></code>, <code><a href="#topic+continue">continue</a></code>,
<code><a href="#topic+coef.bamlss">coef.bamlss</a></code>, <code><a href="#topic+parameters">parameters</a></code>, <code><a href="#topic+predict.bamlss">predict.bamlss</a></code>,
<code><a href="#topic+plot.bamlss">plot.bamlss</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ## Simulated data example.
d &lt;- GAMart()
f &lt;- num ~ s(x1) + s(x2) + s(x3) + te(lon, lat)
b &lt;- bamlss(f, data = d)
summary(b)
plot(b)
plot(b, which = 3:4)
plot(b, which = "samples")

## Use of optimizer and sampler functions:
## * first run optimizer,
b1 &lt;- bamlss(f, data = d, optimizer = opt_bfit, sampler = FALSE)
print(b1)
summary(b1)

## * afterwards, start sampler with staring values,
b2 &lt;- bamlss(f, data = d, start = coef(b1), optimizer = FALSE, sampler = sam_GMCMC)
print(b2)
summary(b2)

## Continue sampling.
b3 &lt;- continue(b2, n.iter = 12000, burnin = 0, thin = 10)
plot(b3, which = "samples")
plot(b3, which = "max-acf")
plot(b3, which = "max-acf", burnin = 500, thin = 4)

## End(Not run)
</code></pre>

<hr>
<h2 id='BAMLSS'>Create <span class="pkg">distributions3</span> Object</h2><span id='topic+BAMLSS'></span><span id='topic+family.BAMLSS'></span><span id='topic+mean.BAMLSS'></span><span id='topic+variance.BAMLSS'></span><span id='topic+skewness.BAMLSS'></span><span id='topic+kurtosis.BAMLSS'></span><span id='topic+random.BAMLSS'></span><span id='topic+pdf.BAMLSS'></span><span id='topic+log_pdf.BAMLSS'></span><span id='topic+cdf.BAMLSS'></span><span id='topic+quantile.BAMLSS'></span><span id='topic+support.BAMLSS'></span><span id='topic+is_discrete.BAMLSS'></span><span id='topic+is_continuous.BAMLSS'></span><span id='topic+format.BAMLSS'></span><span id='topic+print.BAMLSS'></span>

<h3>Description</h3>

<p>A single class and corresponding methods encompassing all <code>bamlss.family</code>
distributions (from the <span class="pkg">bamlss</span> package) using the workflow from the
<span class="pkg">distributions3</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BAMLSS(family, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BAMLSS_+3A_family">family</code></td>
<td>
<p>object. BAMLSS family specifications recognized by
<code><a href="#topic+bamlss.family">bamlss.family</a></code>, including <code>family.bamlss</code> objects,
family-generating functions (e.g., <code><a href="#topic+gaussian_bamlss">gaussian_bamlss</a></code>),
or characters with family names (e.g., <code>"gaussian"</code> or <code>"binomial"</code>).</p>
</td></tr>
<tr><td><code id="BAMLSS_+3A_...">...</code></td>
<td>
<p>further arguments passed as parameters to the BAMLSS family.
Can be scalars or vectors.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The constructor function <code>BAMLSS</code> sets up a distribution
object, representing a distribution from the BAMLSS (Bayesian additive
model of location, scale, and shape) framework by the corresponding parameters
plus a <code>family</code> attribute, e.g., <code><a href="#topic+gaussian_bamlss">gaussian_bamlss</a></code> for the
normal distribution or <code><a href="#topic+binomial_bamlss">binomial_bamlss</a></code> for the binomial
distribution. The parameters employed by the family vary across the families
but typically capture different distributional properties (like location, scale,
shape, etc.).
</p>
<p>All parameters can also be vectors, so that it is possible to define a vector
of BAMLSS distributions from the same family with potentially different parameters.
All parameters need to have the same length or must be scalars (i.e.,
of length 1) which are then recycled to the length of the other parameters.
</p>
<p>For the <code>BAMLSS</code> distribution objects there is a wide range
of standard methods available to the generics provided in the <span class="pkg">distributions3</span>
package: <code><a href="distributions3.html#topic+pdf">pdf</a></code> and <code><a href="distributions3.html#topic+log_pdf">log_pdf</a></code>
for the (log-)density (PDF), <code><a href="distributions3.html#topic+cdf">cdf</a></code> for the probability
from the cumulative distribution function (CDF), <code>quantile</code> for quantiles,
<code><a href="distributions3.html#topic+random">random</a></code> for simulating random variables,
and <code><a href="distributions3.html#topic+support">support</a></code> for the support interval
(minimum and maximum). Internally, these methods rely on the usual d/p/q/r
functions provided in <span class="pkg">bamlss</span>, see the manual pages of the individual
families. The methods <code><a href="distributions3.html#topic+is_discrete">is_discrete</a></code> and
<code><a href="distributions3.html#topic+is_continuous">is_continuous</a></code> can be used to query whether the
distributions are discrete on the entire support or continuous on the entire
support, respectively.
</p>
<p>See the examples below for an illustration of the workflow for the class and methods.
</p>


<h3>Value</h3>

<p>A <code>BAMLSS</code> distribution object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bamlss.family">bamlss.family</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## package and random seed
library("distributions3")
set.seed(6020)

## three Weibull distributions
X &lt;- BAMLSS("weibull", lambda = c(1, 1, 2), alpha = c(1, 2, 2))
X

## moments (FIXME: mean and variance not provided by weibull_bamlss)
## mean(X)
## variance(X)

## support interval (minimum and maximum)
support(X)
is_discrete(X)
is_continuous(X)

## simulate random variables
random(X, 5)

## histograms of 1,000 simulated observations
x &lt;- random(X, 1000)
hist(x[1, ], main = "Weibull(1,1)")
hist(x[2, ], main = "Weibull(1,2)")
hist(x[3, ], main = "Weibull(2,2)")

## probability density function (PDF) and log-density (or log-likelihood)
x &lt;- c(2, 2, 1)
pdf(X, x)
pdf(X, x, log = TRUE)
log_pdf(X, x)

## cumulative distribution function (CDF)
cdf(X, x)

## quantiles
quantile(X, 0.5)

## cdf() and quantile() are inverses
cdf(X, quantile(X, 0.5))
quantile(X, cdf(X, 1))

## all methods above can either be applied elementwise or for
## all combinations of X and x, if length(X) = length(x),
## also the result can be assured to be a matrix via drop = FALSE
p &lt;- c(0.05, 0.5, 0.95)
quantile(X, p, elementwise = FALSE)
quantile(X, p, elementwise = TRUE)
quantile(X, p, elementwise = TRUE, drop = FALSE)

## compare theoretical and empirical mean from 1,000 simulated observations
## (FIXME: mean not provided by weibull_bamlss)
## cbind(
##   "theoretical" = mean(X),
##   "empirical" = rowMeans(random(X, 1000))
## )
</code></pre>

<hr>
<h2 id='bamlss.engine.helpers'>
BAMLSS Engine Helper Functions
</h2><span id='topic+bamlss.engine.helpers'></span><span id='topic+get.par'></span><span id='topic+set.par'></span><span id='topic+get.state'></span><span id='topic+set.starting.values'></span>

<h3>Description</h3>

<p>These functions can be useful when setting up new model fitting engines that are based
on the setup function <code><a href="#topic+bamlss.engine.setup">bamlss.engine.setup</a></code>. See the examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Functions to extract parameter states.
get.par(x, what = NULL)
get.state(x, what = NULL)
set.par(x, replacement, what)

## Function for setting starting values.
set.starting.values(x, start)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bamlss.engine.helpers_+3A_x">x</code></td>
<td>
<p>For function <code>get.par()</code> and <code>set.par()</code> argument <code>x</code> is a
named numeric vector. For function <code>get.state()</code> argument <code>x</code> is an object
of the <code><a href="#topic+smooth.construct">smooth.construct</a></code> list that is processed by function
<code><a href="#topic+bamlss.engine.setup">bamlss.engine.setup</a></code>, i.e., which has a <code>"state"</code> object.
For function <code>set.starting.values()</code> argument <code>x</code> is the <code>x</code> list, as
returned from function <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>.</p>
</td></tr>
<tr><td><code id="bamlss.engine.helpers_+3A_what">what</code></td>
<td>
<p>The name of the parameter(s) that should be extracted or replaced.</p>
</td></tr>
<tr><td><code id="bamlss.engine.helpers_+3A_replacement">replacement</code></td>
<td>
<p>The value(s) that should be used for replacement.</p>
</td></tr>
<tr><td><code id="bamlss.engine.helpers_+3A_start">start</code></td>
<td>
<p>The named numeric vector of starting values. The name convention is based
on function <code><a href="#topic+parameters">parameters</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+bamlss.engine.setup">bamlss.engine.setup</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a bamlss.frame.
d &lt;- GAMart()
bf &lt;- bamlss.frame(num ~ s(x1) + s(x2) + te(lon,lat), data = d, family = "gaussian")
names(bf$x$mu$smooth.construct)

## Use the setup function for
## adding state elements.
bf$x &lt;- bamlss.engine.setup(bf$x, df = c("s(x1)" = 1, "s(x2)" = 3))
names(bf$x$mu$smooth.construct)

## Extract regression coefficients.
get.state(bf$x$mu$smooth.construct[["te(lon,lat)"]], "b")

## Extract smoothing variances.
get.state(bf$x$mu$smooth.construct[["te(lon,lat)"]], "tau2")

## More examples.
state &lt;- bf$x$mu$smooth.construct[["te(lon,lat)"]]$state
get.par(state$parameters, "b")
get.par(state$parameters, "tau2")

state$parameters &lt;- set.par(state$parameters, c(0.1, 0.5), "tau2")
get.par(state$parameters, "tau2")

## Setting starting values.
start &lt;- c("mu.s.s(x1).b" = 1:9, "mu.s.s(x1).tau2" = 0.1)
bf$x &lt;- set.starting.values(bf$x, start = start)
get.state(bf$x$mu$smooth.construct[["s(x1)"]], "b")
get.state(bf$x$mu$smooth.construct[["s(x1)"]], "tau2")
</code></pre>

<hr>
<h2 id='bamlss.engine.setup'>
BAMLSS Engine Setup Function
</h2><span id='topic+bamlss.engine.setup'></span>

<h3>Description</h3>

<p>This function takes the <code>x</code> object of a <code><a href="#topic+bamlss.frame">bamlss.frame</a></code> and adds
additional objects that are useful for model fitting engines. This is applied only
for 'regular' terms, e.g., as created by <code><a href="mgcv.html#topic+s">s</a></code> and <code><a href="mgcv.html#topic+te">te</a></code>.
For special model terms the corresponding <code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code> method is in charge
of this (see also the examples for function <code><a href="#topic+bfit">bfit</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bamlss.engine.setup(x, update = "iwls", propose = "iwlsC_gp",
  do.optim = NULL, df = NULL, parametric2smooth = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bamlss.engine.setup_+3A_x">x</code></td>
<td>
<p>The <code>x</code> list, as returned from function <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>,
holding all model matrices and other information that is used for
fitting the model.</p>
</td></tr>
<tr><td><code id="bamlss.engine.setup_+3A_update">update</code></td>
<td>
<p>Sets the updating function for model terms, see function <code><a href="#topic+bfit">bfit</a></code>.</p>
</td></tr>
<tr><td><code id="bamlss.engine.setup_+3A_propose">propose</code></td>
<td>
<p>Sets the propose function for model terms, see function <code><a href="#topic+GMCMC">GMCMC</a></code>.</p>
</td></tr>
<tr><td><code id="bamlss.engine.setup_+3A_do.optim">do.optim</code></td>
<td>
<p>Adds list element <code>"do.optim"</code> in the <code>"state"</code> element, see the
details below.</p>
</td></tr>
<tr><td><code id="bamlss.engine.setup_+3A_df">df</code></td>
<td>
<p>The initial degrees of freedom that should be assigned to a smooth model term,
based on the trace of the smoother matrix. Note that <code>df</code> can be a named numeric vector.
If the names match the labels of the model terms, the corresponding <code>df</code> are used, e.g.,
<code>df = c("s(x1)" = 1, "s(x2)" = 2)</code> sets different <code>df</code>s for each term.</p>
</td></tr>
<tr><td><code id="bamlss.engine.setup_+3A_parametric2smooth">parametric2smooth</code></td>
<td>
<p>Should parametric model terms be transformed into an artificial
smooth model term and be added to the <code>"smooth.construct"</code> object within the <code>x</code> list?
This feature is handy, since algorithms can then cycle over the <code>"smooth.construct"</code>
object, only.</p>
</td></tr>
<tr><td><code id="bamlss.engine.setup_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each model term in the <code>"smooth.construct"</code> object of the <code>x</code> list (as returned
from <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>), this function adds a named list called <code>"state"</code> with the
following entries:
</p>

<ul>
<li> <p><code>"parameters"</code>: A numeric vector. Regression coefficients are named with <code>"b"</code>,
smooth variances are named with <code>"tau2"</code>.
</p>
</li>
<li> <p><code>"fitted.values"</code>: Given the <code>"parameters"</code>, the actual fitted values of
the model term.
</p>
</li>
<li> <p><code>"edf"</code>: Given the smoothing variances, the actual equivalent degrees of freedom
(edf) of the model term.
</p>
</li>
<li> <p><code>"do.optim"</code>: Should an optimizer function try to find optimum smoothing variances?
</p>
</li></ul>

<p>The state will be changed in each iteration and can be passed outside an updating function.
</p>
<p>Additionally, if missing in the <code>xt</code> argument of a model term (see, e.g., function
<code><a href="mgcv.html#topic+s">s</a></code> for <code>xt</code>) the function adds the corresponding log-prior and its first
and second order derivatives w.r.t. regression coefficients in functions <code>grad()</code> and
<code>hess()</code>.
</p>
<p>Also, objects named <code>"lower"</code> and <code>"upper"</code> are added to each model term. These
indicate the lower and upper boundaries of the parameter space.
</p>


<h3>Value</h3>

<p>A transformed <code>x</code> list, as returned from function <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bamlss.frame">bamlss.frame</a></code>, <code><a href="#topic+bfit">bfit</a></code>, <code><a href="#topic+GMCMC">GMCMC</a></code>,
<code><a href="#topic+get.par">get.par</a></code>, <code><a href="#topic+set.par">set.par</a></code>, <code><a href="#topic+get.state">get.state</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- GAMart()
bf &lt;- bamlss.frame(num ~ s(x1) + s(x2), data = d, family = "gaussian")
names(bf$x$mu$smooth.construct)
bf$x &lt;- bamlss.engine.setup(bf$x, df = c("s(x1)" = 1, "s(x2)" = 3))
names(bf$x$mu$smooth.construct)
names(bf$x$mu$smooth.construct[["s(x1)"]])
names(bf$x$mu$smooth.construct[["s(x1)"]]$state)
sapply(bf$x$mu$smooth.construct, function(x) {
  c(x$state$edf, get.state(x, "tau2"))
})
</code></pre>

<hr>
<h2 id='bamlss.formula'>
Formulae for BAMLSS
</h2><span id='topic+bamlss.formula'></span>

<h3>Description</h3>

<p>This function creates an extended BAMLSS <code><a href="stats.html#topic+formula">formula</a></code>. In combination with a
<code><a href="#topic+bamlss.family">bamlss.family</a></code> object, each parameter of the response distribution is linked
to a single formula. If no formula is supplied for a parameter, a simple intercept only
model is created. Moreover, the function identifies hierarchical structures, see the examples.
This function is useful for creating complex <code><a href="stats.html#topic+model.frame">model.frame</a></code>s for (hierarchical)
multi-parameter models and is used by function <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bamlss.formula(formula, family = NULL, specials = NULL, env = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bamlss.formula_+3A_formula">formula</code></td>
<td>
<p>A simple <code><a href="stats.html#topic+formula">formula</a></code>, or a <code><a href="base.html#topic+list">list</a></code> of simple formulae,
or an extended <code><a href="Formula.html#topic+Formula">Formula</a></code>. For formula lists or extended
<code><a href="Formula.html#topic+Formula">Formula</a></code>e, each single formula represents one model for the
respective parameter as specified in the <code>family</code> object.</p>
</td></tr>
<tr><td><code id="bamlss.formula_+3A_family">family</code></td>
<td>
<p>A <code><a href="#topic+bamlss.family">bamlss.family</a></code> object.</p>
</td></tr>
<tr><td><code id="bamlss.formula_+3A_specials">specials</code></td>
<td>
<p>A character vector specifying special functions to be used within
formulae, see <code><a href="stats.html#topic+terms.object">terms.object</a></code>.</p>
</td></tr>
<tr><td><code id="bamlss.formula_+3A_env">env</code></td>
<td>
<p>The environment that should be assigned to the formula.</p>
</td></tr>
<tr><td><code id="bamlss.formula_+3A_...">...</code></td>
<td>
<p>Arguments passed to the <code>family</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of class <code>"bamlss.formula"</code>. Each list entry specifies a model, e.g., for
one parameter of a provided <code><a href="#topic+bamlss.family">bamlss.family</a></code> object. Each entry (parameter model) then
holds:
</p>
<table>
<tr><td><code>formula</code></td>
<td>
<p>A simple <code><a href="stats.html#topic+formula">formula</a></code>.</p>
</td></tr>
<tr><td><code>fake.formula</code></td>
<td>
<p>A formula with all function calls being dropped, e.g., the formula
<code>y ~ s(x1) + s(x2)</code> is represented in the <code>fake.formula</code> entry as
<code>y ~ x1 + x2</code>. The <code>fake.formula</code> is useful for creating model frames.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+bamlss">bamlss</a></code>, <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>, <code><a href="#topic+bamlss.family">bamlss.family</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simple formula without family object.
f &lt;- bamlss.formula(y ~ x1 + s(x2))
print(f)
print(str(f))

## Complex formula with list of formulae.
f &lt;- list(
  y1 ~ x1 + s(x2),
  y2 ~ x3 + te(lon, lat),
  u ~ x4 + x1
)

f &lt;- bamlss.formula(f)
print(f)
print(names(f))

## Same formula but using extended formulae
## of package Formula.
f &lt;- y1|y2|u ~ x1 + s(x2)|x3 + te(lon,lat)|x4 + x1
f &lt;- bamlss.formula(f)
print(f)
print(names(f))

## Using a bamlss family object, e.g., gaussian_bamlss().
## The family has two parameters, mu and sigma, for
## each parameter one formula is returned. If no
## formula is specified an intercept only model is
## generated for the respective parameter.
f &lt;- bamlss.formula(y ~ x1 + s(x2), family = gaussian_bamlss)

## Note, same as:
f &lt;- bamlss.formula(y ~ x1 + s(x2), family = "gaussian")
print(f)

## Specify model for parameter sigma, too
f &lt;- list(
  y ~ x1 + s(x2),
  sigma ~ x2 + te(lon, lat)
)
f &lt;- bamlss.formula(f, family = "gaussian")
print(f)

## With complex hierarchical structures,
## each parameter is another list of formulae,
## indicated by the h1,...,hk, names.
f &lt;- list(
  y ~ x1 + s(x2) + id1,
  sigma ~ x2 + te(lon, lat) + id2,
  id1 ~ s(x3) + x4 + s(id3),
  id3 ~ x5 + s(x5, x6),
  id2 ~ x7
)
f &lt;- bamlss.formula(f, family = "gaussian")
print(f)
</code></pre>

<hr>
<h2 id='bamlss.frame'>
Create a Model Frame for BAMLSS
</h2><span id='topic+bamlss.frame'></span>

<h3>Description</h3>

<p>This function parses the <code>data</code> and the model <code>formula</code>, or
extended <code><a href="#topic+bamlss.formula">bamlss.formula</a></code>, as well as the <code><a href="#topic+bamlss.family">bamlss.family</a></code>
into a <code><a href="#topic+bamlss.frame">bamlss.frame</a></code> object. The <code><a href="#topic+bamlss.frame">bamlss.frame</a></code> then holds all model
matrices and information that is needed for setting up estimation engines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bamlss.frame(formula, data = NULL, family = "gaussian",
  weights = NULL, subset = NULL, offset = NULL,
  na.action = na.omit, contrasts = NULL,
  knots = NULL, specials = NULL, reference = NULL,
  model.matrix = TRUE, smooth.construct = TRUE,
  ytype = c("matrix", "vector", "integer"),
  scale.x = FALSE, scale.d = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bamlss.frame_+3A_formula">formula</code></td>
<td>
<p>A formula or extended formula, i.e., the <code>formula</code> can be a
<code><a href="base.html#topic+list">list</a></code> of formulas where each list entry specifies the details of one parameter
of the modeled response distribution, see <code><a href="#topic+bamlss.formula">bamlss.formula</a></code>. For incorporating
smooth terms, all model term constructors implemented in <code><a href="mgcv.html#topic+mgcv">mgcv</a></code> such as
<code><a href="mgcv.html#topic+s">s</a></code>, <code><a href="mgcv.html#topic+te">te</a></code> and <code><a href="mgcv.html#topic+ti">ti</a></code> can be used, amongst others.</p>
</td></tr>
<tr><td><code id="bamlss.frame_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> or <code><a href="base.html#topic+list">list</a></code> containing the model
response variable(s) and covariates specified in the <code>formula</code>.
By default the variables are taken from <code>environment(formula)</code>:
typically the environment from which <code>bamlss</code> is called.</p>
</td></tr>
<tr><td><code id="bamlss.frame_+3A_family">family</code></td>
<td>
<p>A <code><a href="#topic+bamlss.family">bamlss.family</a></code> object, specifying the details of the modeled
distribution such as the parameter names, the density function, link functions, etc.</p>
</td></tr>
<tr><td><code id="bamlss.frame_+3A_weights">weights</code></td>
<td>
<p>Prior weights on the data.</p>
</td></tr>
<tr><td><code id="bamlss.frame_+3A_subset">subset</code></td>
<td>
<p>An optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="bamlss.frame_+3A_offset">offset</code></td>
<td>
<p>Can be used to supply model offsets for use in fitting.</p>
</td></tr>
<tr><td><code id="bamlss.frame_+3A_na.action">na.action</code></td>
<td>
<p>A function which indicates what should happen when the data
contain <code>NA</code>'s. The default is set by the <code>na.action</code>
setting of <code><a href="base.html#topic+options">options</a></code>, and is <code><a href="stats.html#topic+na.omit">na.omit</a></code> if set to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="bamlss.frame_+3A_contrasts">contrasts</code></td>
<td>
<p>An optional list. See the <code>contrasts.arg</code> of 
<code><a href="stats.html#topic+model.matrix.default">model.matrix.default</a></code>.</p>
</td></tr>
<tr><td><code id="bamlss.frame_+3A_knots">knots</code></td>
<td>
<p>An optional list containing user specified knots, see the documentation of
function <code><a href="mgcv.html#topic+gam">gam</a></code>.</p>
</td></tr>
<tr><td><code id="bamlss.frame_+3A_specials">specials</code></td>
<td>
<p>Specify new special terms here to be used with the <code><a href="#topic+bamlss.formula">bamlss.formula</a></code>,
see also <code><a href="stats.html#topic+terms.object">terms.object</a></code>.</p>
</td></tr>
<tr><td><code id="bamlss.frame_+3A_reference">reference</code></td>
<td>
<p>A <code>character</code> specifying a reference category, e.g., when
fitting a multinomial model.</p>
</td></tr>
<tr><td><code id="bamlss.frame_+3A_model.matrix">model.matrix</code></td>
<td>
<p>Logical, should model matrices for linear parts be returned?</p>
</td></tr>
<tr><td><code id="bamlss.frame_+3A_smooth.construct">smooth.construct</code></td>
<td>
<p>Logical, should model matrices, e.g., as returned from
<code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code> and <code><a href="mgcv.html#topic+smoothCon">smoothCon</a></code> be part
of returned <code>bamlss.frame</code>?.</p>
</td></tr>
<tr><td><code id="bamlss.frame_+3A_ytype">ytype</code></td>
<td>
<p>For categorical responses, should the response be a vector or matrix. If
<code>ytype == "matrix"</code> <code>bamlss.frame()</code> uses function <code><a href="stats.html#topic+model.matrix">model.matrix</a></code>
to construct the response matrix from levels. If the response is a factor
<code>ytype == "integer"</code> will create an integer response.</p>
</td></tr>
<tr><td><code id="bamlss.frame_+3A_scale.x">scale.x</code></td>
<td>
<p>Logical, should the model matrices of the linear parts be scaled?</p>
</td></tr>
<tr><td><code id="bamlss.frame_+3A_scale.d">scale.d</code></td>
<td>
<p>Logical, should the numeric variables in the model frame be scaled?</p>
</td></tr>
<tr><td><code id="bamlss.frame_+3A_...">...</code></td>
<td>
<p>Arguments passed to function <code><a href="#topic+smooth.construct.bamlss.frame">smooth.construct.bamlss.frame</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function parses the <code>data</code>, the <code>formula</code> or the extended
<code><a href="#topic+bamlss.formula">bamlss.formula</a></code> as well as the <code><a href="#topic+bamlss.family">bamlss.family</a></code> into a model frame
like object, the <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>. This object holds all necessary model matrices
and information that is needed for model fitting engines. Per default,
all package <code><a href="mgcv.html#topic+mgcv">mgcv</a></code> smooth term constructor functions like
<code><a href="mgcv.html#topic+s">s</a></code>, <code><a href="mgcv.html#topic+te">te</a></code>, <code><a href="mgcv.html#topic+t2">t2</a></code> and
<code><a href="mgcv.html#topic+ti">ti</a></code> can be used (see also function <code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code>),
however, even special user defined constructors can be included, see the examples below.
</p>
<p>Function <code>bamlss.frame()</code> uses function <code><a href="#topic+model.matrix.bamlss.frame">model.matrix.bamlss.frame</a></code> to
compute all design matrices for simple linear parts, all smooth terms are parsed with
function <code><a href="#topic+smooth.construct.bamlss.frame">smooth.construct.bamlss.frame</a></code>.
</p>
<p>It is also possible to create a <code>"bamlss.frame"</code> using hierarchical formulae, see the
example below.
</p>


<h3>Value</h3>

<p>An list of class <code>"bamlss.frame"</code> with the following elements:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The initial call.</p>
</td></tr>
<tr><td><code>model.frame</code></td>
<td>
<p>The <code><a href="stats.html#topic+model.frame">model.frame</a></code> used to compute all design matrices.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>The <code><a href="#topic+bamlss.formula">bamlss.formula</a></code>.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>The <code><a href="#topic+bamlss.family">bamlss.family</a></code> object.</p>
</td></tr>
<tr><td><code>terms</code></td>
<td>
<p>The <code><a href="#topic+terms.bamlss">terms.bamlss</a></code> object.</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>A named list, the elements correspond to the parameters that are specified
within the <code><a href="#topic+bamlss.family">bamlss.family</a></code> object. For each parameter the corresponding
<code>formula</code>, a <code>fake.formula</code> only holding the covariate names, a <code><a href="stats.html#topic+terms">terms</a></code>
object, a <code><a href="stats.html#topic+model.matrix">model.matrix</a></code> for the linear part and a list <code>smooth.construct</code>
holding all information for smooth terms as returned from function
<code>link{smooth.construct.bamlss.frame}</code> is created.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>The response data.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+bamlss">bamlss</a></code>, <code><a href="#topic+bamlss.formula">bamlss.formula</a></code>, <code><a href="#topic+bamlss.family">bamlss.family</a></code>,
<code><a href="#topic+smooth.construct.bamlss.frame">smooth.construct.bamlss.frame</a></code>, <code><a href="#topic+model.matrix.bamlss.frame">model.matrix.bamlss.frame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a 'bamlss.frame'.
d &lt;- GAMart()
f &lt;- list(
  num ~ fac + s(x1) + s(x2) + te(lon, lat),
  sigma ~ id + s(x2) + s(x3)
)
bf &lt;- bamlss.frame(f, data = d, family = "gaussian")

## Show parts of the 'bamlss.frame'.
print(bf)

## Categorical responses.
f &lt;- list(
  cat ~ fac + s(x1) + s(x2)
)

bf &lt;- bamlss.frame(f, data = d, family = "multinomial", reference = "low")
print(bf)

## The response is a matrix per default.
head(bf$y)

## 0/1 responses.
d &lt;- cbind(d, model.matrix(~ -1 + cat, data = d))

f &lt;- list(
  catnone ~ fac + s(x1),
  catlow ~ s(x2),
  catmedium ~ s(x3)
)

bf &lt;- bamlss.frame(f, data = d, family = "multinomial")
print(bf)

## Hierarchical structures.
f &lt;- list(
  num ~ s(x1) + s(x2) + id,
  id ~ te(lon, lat),
  sigma ~ s(x1) + fac
)

bf &lt;- bamlss.frame(f, data = d, family = "gaussian")
print(bf)

## Special model term constructors,
## set up "new" constructor function and eval
## with bamlss.frame().
s77 &lt;- function(...) {
  sm &lt;- s(...)
  sm$label &lt;- paste("s77(", paste(sm$term, collapse = ","), ")", sep = "")
  sm
}

f &lt;- list(
  num ~ s77(x1) + s(x2) + id,
  sigma ~ s77(x1)
)

bf &lt;- bamlss.frame(f, data = d, family = "gaussian", specials = "s77")
print(bf)
names(bf$x$mu$smooth.construct)
</code></pre>

<hr>
<h2 id='bboost'>Bootstrap Boosting</h2><span id='topic+bboost'></span><span id='topic+bboost_plot'></span><span id='topic+predict.bboost'></span>

<h3>Description</h3>

<p>Wrapper function for applying bootstrap estimation using gradient boosting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Bootstrap boosting.
bboost(..., data, type = 1, cores = 1,
  n = 2, prob = 0.623, fmstop = NULL,
  trace = TRUE, drop = FALSE, replace = FALSE)

## Plotting function.
bboost_plot(object, col = NULL)

## Predict method.
## S3 method for class 'bboost'
predict(object, newdata, ..., cores = 1, pfun = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bboost_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+bamlss">bamlss</a></code> and <code><a href="#topic+predict.bamlss">predict.bamlss</a></code>.</p>
</td></tr>
<tr><td><code id="bboost_+3A_data">data</code></td>
<td>
<p>The data frame to be used for modeling.</p>
</td></tr>
<tr><td><code id="bboost_+3A_type">type</code></td>
<td>
<p>Type of algorithm, <code>type = 1</code> uses all observations and samples with
replacement, <code>type = 2</code> uses only a fraction specified in <code>prob</code> and samples
with replacement.</p>
</td></tr>
<tr><td><code id="bboost_+3A_cores">cores</code></td>
<td>
<p>The number of cores to be used.</p>
</td></tr>
<tr><td><code id="bboost_+3A_n">n</code></td>
<td>
<p>The number of bootstrap iterations.</p>
</td></tr>
<tr><td><code id="bboost_+3A_prob">prob</code></td>
<td>
<p>The fraction that should be used to fit the model in each bootstrap iteration.</p>
</td></tr>
<tr><td><code id="bboost_+3A_fmstop">fmstop</code></td>
<td>
<p>The function that should return the optimum stopping iteration. The function must
have two arguments: (1) the <code>model</code> end (2) the <code>data</code>. The function must return
a list with two named arguments: (1) <code>"mstop"</code> the optimum stopping iteration and (2)
a vector of the objective criterion that should be evaluated by the hold out sample data during
each bootstrap iteration. See the examples.</p>
</td></tr>
<tr><td><code id="bboost_+3A_trace">trace</code></td>
<td>
<p>Prints out the current state of the bootstrap algorithm.</p>
</td></tr>
<tr><td><code id="bboost_+3A_drop">drop</code></td>
<td>
<p>Should only the best set of parameters be saved?</p>
</td></tr>
<tr><td><code id="bboost_+3A_replace">replace</code></td>
<td>
<p>Sampling with replacement, or sampling <code>ceiling(nobs * prob)</code>
rows of the data for fitting the <code>n</code> models.</p>
</td></tr>
<tr><td><code id="bboost_+3A_object">object</code></td>
<td>
<p>The <code>"bboost"</code> object used for prediction and plotting.</p>
</td></tr>
<tr><td><code id="bboost_+3A_col">col</code></td>
<td>
<p>The color that should be used for plotting.</p>
</td></tr>
<tr><td><code id="bboost_+3A_newdata">newdata</code></td>
<td>
<p>The data frame predictions should be made for.</p>
</td></tr>
<tr><td><code id="bboost_+3A_pfun">pfun</code></td>
<td>
<p>The prediction function that should be used, for example <code><a href="#topic+predictn">predictn</a></code> could
be used, too. Note that this is experimental.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of <code>bamlss</code> objects.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bamlss">bamlss</a></code>, <code><a href="#topic+boost">boost</a></code>, <code><a href="#topic+lasso">lasso</a></code>, <code><a href="#topic+BayesX">BayesX</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ## Simulate data.
set.seed(123)
d &lt;- GAMart()

## Estimate model.
f &lt;- num ~ s(x1) + s(x2) + s(x3) + s(lon,lat)

## Function for evaluation of hold out sample
## criterion to find the optimum mstop.
fmstop &lt;- function(model, data) {
  p &lt;- predict(model, newdata = data, model = "mu")
  mse &lt;- NULL
  for(i in 1:nrow(model$parameters))
    mse &lt;- c(mse, mean((data$num - p[, i])^2))
  list("MSE" = mse, "mstop" = which.min(mse))
}

## Bootstrap boosted models.
b &lt;- bboost(f, data = d, n = 50, cores = 3, fmstop = fmstop)

## Plot hold out sample MSE.
bboost_plot(b)

## Predict for each bootstrap sample.
nd &lt;- data.frame("x2" = seq(0, 1, length = 100))
p &lt;- predict(b, newdata = nd, model = "mu", term = "x2")
plot2d(p ~ x2, data = nd)

## End(Not run)
</code></pre>

<hr>
<h2 id='boost2'>Some Shortcuts</h2><span id='topic+boost2'></span><span id='topic+lasso2'></span><span id='topic+bayesx2'></span>

<h3>Description</h3>

<p>Some simple shortcuts to model fitting engines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## BayesX.
bayesx2(...)

## Gradient boosting.
boost2(...)

## Lasso.
lasso2(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boost2_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+bamlss">bamlss</a></code> and <code><a href="#topic+predict.bamlss">predict.bamlss</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>bamlss</code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bamlss">bamlss</a></code>, <code><a href="#topic+boost">boost</a></code>, <code><a href="#topic+lasso">lasso</a></code>, <code><a href="#topic+BayesX">BayesX</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ## Simulate data.
set.seed(123)
d &lt;- GAMart()

## Estimate model.
f &lt;- num ~ s(x1) + s(x2) + s(x3) + s(lon,lat)

## Boosted model.
b &lt;- boost2(f, data = d)

## Plot estimated effects.
plot(b)

## End(Not run)
</code></pre>

<hr>
<h2 id='c95'>
Compute 95% Credible Interval and Mean
</h2><span id='topic+c95'></span>

<h3>Description</h3>

<p>Small helper function that computes the 2.5% and 97.5% quantiles and the
mean of a vector. Useful for example when using function <code><a href="#topic+predict.bamlss">predict.bamlss</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>c95(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="c95_+3A_x">x</code></td>
<td>
<p>A numeric vector.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+predict.bamlss">predict.bamlss</a></code>, <code><a href="#topic+coef.bamlss">coef.bamlss</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>x &lt;- rnorm(100)
c95(x)

## Not run: ## Example computing predictions.
set.seed(123)
d &lt;- data.frame("x" = seq(-3, 3, length = 30))
d$y &lt;- sin(d$x) + rnorm(30, sd = 0.3)

## Estimate model and compute predictions.
## with c95().
b &lt;- bamlss(y ~ s(x), data = d)
p &lt;- predict(b, model = "mu", FUN = c95)
plot(d)
matplot(d$x, p, type = "l", lty = c(2, 1, 2),
  col = "black", add = TRUE)

## Example extracting coefficients.
coef(b, FUN = c95)

## End(Not run)
</code></pre>

<hr>
<h2 id='coef.bamlss'>
Extract BAMLSS Coefficients
</h2><span id='topic+coef.bamlss'></span><span id='topic+confint.bamlss'></span>

<h3>Description</h3>

<p>Methods to extract coefficients of fitted <code><a href="#topic+bamlss">bamlss</a></code> objects, either coefficients
returned from optimizer functions, or samples from a sampler functions.
</p>
<p>Method <code>confint.bamlss()</code> produces credible intervals or parameter samples
using quantiles.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bamlss'
coef(object, model = NULL, term = NULL,
  FUN = NULL, parameters = NULL,
  pterms = TRUE, sterms = TRUE,
  hyper.parameters = TRUE, list = FALSE,
  full.names = TRUE, rescale = FALSE, ...)

## S3 method for class 'bamlss'
confint(object, parm, level = 0.95,
  model = NULL, pterms = TRUE, sterms = FALSE,
  full.names = FALSE, hyper.parameters = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="coef.bamlss_+3A_object">object</code></td>
<td>
<p>An object of class <code>"bamlss"</code></p>
</td></tr>
<tr><td><code id="coef.bamlss_+3A_model">model</code></td>
<td>
<p>Character or integer. For which model should coefficients be extracted?</p>
</td></tr>
<tr><td><code id="coef.bamlss_+3A_term">term</code></td>
<td>
<p>Character or integer. For which term should coefficients be extracted?</p>
</td></tr>
<tr><td><code id="coef.bamlss_+3A_fun">FUN</code></td>
<td>
<p>A function that is applied on the parameter samples.</p>
</td></tr>
<tr><td><code id="coef.bamlss_+3A_parameters">parameters</code></td>
<td>
<p>If is set to <code>TRUE</code>, additionally adds estimated parameters
returned from an optimizer function (if available).</p>
</td></tr>
<tr><td><code id="coef.bamlss_+3A_pterms">pterms</code></td>
<td>
<p>Should coefficients of parametric terms be included?</p>
</td></tr>
<tr><td><code id="coef.bamlss_+3A_sterms">sterms</code></td>
<td>
<p>Should coefficients of smooths terms be included?</p>
</td></tr>
<tr><td><code id="coef.bamlss_+3A_hyper.parameters">hyper.parameters</code></td>
<td>
<p>For smooth terms, should hyper parameters such as smoothing variances
be included?</p>
</td></tr>
<tr><td><code id="coef.bamlss_+3A_list">list</code></td>
<td>
<p>Should the returned object have a list structure for each distribution parameter?</p>
</td></tr>
<tr><td><code id="coef.bamlss_+3A_full.names">full.names</code></td>
<td>
<p>Should full names be assigned, indicating whether a term is parametric &quot;p&quot; or
smooth &quot;s&quot;.</p>
</td></tr>
<tr><td><code id="coef.bamlss_+3A_rescale">rescale</code></td>
<td>
<p>Should parameters of the linear parts be rescaled if the <code>scale.d</code> argument
in <code><a href="#topic+bamlss.frame">bamlss.frame</a></code> is set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="coef.bamlss_+3A_parm">parm</code></td>
<td>
<p>Character or integer. For which term should coefficients intervals be extracted?</p>
</td></tr>
<tr><td><code id="coef.bamlss_+3A_level">level</code></td>
<td>
<p>The credible level which defines the lower and upper quantiles that should
be computed from the samples.</p>
</td></tr>
<tr><td><code id="coef.bamlss_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code>FUN</code> and function <code><a href="#topic+samples">samples</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on argument <code>list</code> and the number of distributional parameters, either a
<code>list</code> or vector/matrix of model coefficients.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bamlss">bamlss</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ## Simulate data.
d &lt;- GAMart()

## Model formula.
f &lt;- list(
  num ~ s(x1) + s(x2) + s(x3),
  sigma ~ s(x1) + s(x2) + s(x3)
)

## Estimate model.
b &lt;- bamlss(f, data = d)

## Extract coefficients based on MCMC samples.
coef(b)

## Now only the mean.
coef(b, FUN = mean)

## As list without the full names.
coef(b, FUN = mean, list = TRUE, full.names = FALSE)

## Coefficients only for "mu".
coef(b, model = "mu")

## And "s(x2)".
coef(b, model = "mu", term = "s(x2)")

## With optimizer parameters.
coef(b, model = "mu", term = "s(x2)", parameters = TRUE)

## Only parameteric part.
coef(b, sterms = FALSE, hyper.parameters = FALSE)

## For sigma.
coef(b, model = "sigma", sterms = FALSE,
  hyper.parameters = FALSE)

## 95 perc. credible interval based on samples.
confint(b)

## End(Not run)
</code></pre>

<hr>
<h2 id='colorlegend'>
Plot a Color Legend
</h2><span id='topic+colorlegend'></span>

<h3>Description</h3>

<p>Function to generate a color legend, the legend may be added to an existing plot or drawn in a
separate plotting window.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>colorlegend(color = NULL, ncol = NULL, x = NULL, breaks = NULL, 
  pos = "center", shift = 0.02, side.legend = 1L, side.ticks = 1L,
  range = NULL, lrange = NULL, width = 0.25, height = 0.05,
  scale = TRUE, xlim = NULL, ylim = NULL, plot = NULL, full = FALSE,
  add = FALSE, col.border = "black", lty.border = 1L, lwd.border = 1L,
  ticks = TRUE, at = NULL, col.ticks = "black", lwd.ticks = 1L,
  lty.ticks = 1L, length.ticks = 0.3, labels = NULL,
  distance.labels = 0, col.labels = "black", cex.labels = 1L,
  digits = 2L, swap = FALSE, symmetric = TRUE, xpd = NULL,
  title = NULL, side.title = 2, shift.title = c(0, 0),
  cex.title = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="colorlegend_+3A_color">color</code></td>
<td>
<p>Character, integer. The colors for the legend, may also be a function, e.g.
<code>colors = heat.colors</code>.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_ncol">ncol</code></td>
<td>
<p>Integer, the number of different colors that should be generated if <code>color</code> is a 
function.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_x">x</code></td>
<td>
<p>Numeric, values for which the color legend should be drawn.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_breaks">breaks</code></td>
<td>
<p>Numeric, a set of breakpoints for the colors: must give one more breakpoint than 
<code>ncol</code>.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_pos">pos</code></td>
<td>
<p>Character, numeric. The position of the legend. Either a numeric vector, e.g.
<code>pos = c(0.1, 0.2)</code> will add the legend at the 10<code class="reqn">\%</code> point in the x-direction and at
the 20<code class="reqn">\%</code> point in the y-direction of the plotting window, may also be negative, or one of
the following: <code>"bottomleft"</code>, <code>"topleft"</code>, <code>"topright"</code>, <code>"bottomright"</code>,
<code>"left"</code>, <code>"right"</code>, <code>"top"</code>, <code>"bottom"</code> and <code>"center"</code>.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_shift">shift</code></td>
<td>
<p>Numeric, if argument <code>pos</code> is a character, <code>shift</code> determines the distance
of the legend from the plotting box.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_side.legend">side.legend</code></td>
<td>
<p>Integer, if set to <code>2</code> the legend will be flipped by 90 degrees.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_side.ticks">side.ticks</code></td>
<td>
<p>Integer, if set to <code>2</code>, the ticks and labels will be on the opposite site
of the legend.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_range">range</code></td>
<td>
<p>Numeric, specifies a range for <code>x</code> values for which the legend should be drawn.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_lrange">lrange</code></td>
<td>
<p>Numeric, specifies the range of legend.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_width">width</code></td>
<td>
<p>Numeric, the width of the legend, if <code>scale = TRUE</code> the width is proportional to
the x-limits of the plotting window.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_height">height</code></td>
<td>
<p>Numeric, the height of the legend, if <code>scale = TRUE</code> the height is proportional
to the y-limits of the plotting window.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_scale">scale</code></td>
<td>
<p>Logical, if set to <code>TRUE</code>, the <code>width</code> and <code>height</code> of the legend will
be calculated proportional to the x- and y-limits of the plotting window.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_xlim">xlim</code></td>
<td>
<p>Numeric, the x-limits of the plotting window the legend should be added for, numeric
vector, e.g., returned from function <code><a href="base.html#topic+range">range</a></code>.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_ylim">ylim</code></td>
<td>
<p>Numeric, the y-limits of the plotting window the legend should be added for, numeric
vector, e.g., returned from function <code><a href="base.html#topic+range">range</a></code>.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_plot">plot</code></td>
<td>
<p>Logical, if set to <code>TRUE</code>, the legend will be drawn in a separate plotting window.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_full">full</code></td>
<td>
<p>Logical, if set to <code>TRUE</code>, the legend will be drawn using the full window range.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_add">add</code></td>
<td>
<p>Logical, if set to <code>TRUE</code>, the legend will be added to an existing plot.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_col.border">col.border</code></td>
<td>
<p>The color of the surrounding border line of the legend.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_lty.border">lty.border</code></td>
<td>
<p>The line type of the surrounding border line of the legend.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_lwd.border">lwd.border</code></td>
<td>
<p>The line width of the surrounding border line of the legend.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_ticks">ticks</code></td>
<td>
<p>Logical, if set to <code>TRUE</code>, ticks will be added to the legend.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_at">at</code></td>
<td>
<p>Numeric, specifies at which locations ticks and labels should be added.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_col.ticks">col.ticks</code></td>
<td>
<p>The colors of the ticks.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_lwd.ticks">lwd.ticks</code></td>
<td>
<p>The line width of the ticks.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_lty.ticks">lty.ticks</code></td>
<td>
<p>The line type of the ticks.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_length.ticks">length.ticks</code></td>
<td>
<p>Numeric, the length of the ticks as percentage of the <code>height</code> or
<code>width</code> of the colorlegend.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_labels">labels</code></td>
<td>
<p>Character, specifies labels that should be added to the ticks.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_distance.labels">distance.labels</code></td>
<td>
<p>Numeric, the distance of the labels to the ticks, proportional to the
length of the ticks.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_col.labels">col.labels</code></td>
<td>
<p>The colors of the labels.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_cex.labels">cex.labels</code></td>
<td>
<p>Text size of the labels.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_digits">digits</code></td>
<td>
<p>Integer, the decimal places if labels are numerical.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_swap">swap</code></td>
<td>
<p>Logical, if set to <code>TRUE</code> colors will be represented in reverse order.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_symmetric">symmetric</code></td>
<td>
<p>Logical, if set to <code>TRUE</code>, a symmetric legend will be drawn corresponding to
the <code>+- max(abs(x))</code> value.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_xpd">xpd</code></td>
<td>
<p>Sets the <code>xpd</code> parameter in function <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_title">title</code></td>
<td>
<p>Character, a title for the legend.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_side.title">side.title</code></td>
<td>
<p>Integer, <code>1</code> or <code>2</code>. Specifies where the legend is placed, either on
top if <code>side.title = 1</code> or at the bottom if <code>side.title = 2</code>.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_shift.title">shift.title</code></td>
<td>
<p>Numeric vector of length 2. Specifies a possible shift of the title in either
x- or y-direction.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_cex.title">cex.title</code></td>
<td>
<p>Text size for the title.</p>
</td></tr>
<tr><td><code id="colorlegend_+3A_...">...</code></td>
<td>
<p>Other graphical parameters to be passed to function <code><a href="graphics.html#topic+text">text</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named <code>list</code> with the colors generated, the breaks and the function <code>map</code>, which may 
be used for mapping of <code>x</code> values to the colors specified in argument <code>colors</code>, please 
see the examples below.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Play with colorlegend.
colorlegend()
colorlegend(side.legend = 2)
colorlegend(side.legend = 2, side.ticks = 2)
colorlegend(height = 2)
colorlegend(width = 1, height = 0.8, scale = FALSE, 
  pos = c(0, 0.2), length.ticks = 0.5)
colorlegend(color = heat.colors, ncol = 9)
colorlegend(color = heat.colors, ncol = 9, swap = TRUE)
colorlegend(pos = "bottomleft")
colorlegend(pos = "topleft")
colorlegend(pos = "topright")
colorlegend(pos = "bottomright")


## Take x values for the color legend.
x &lt;- runif(100, -2, 2)
colorlegend(color = diverge_hcl, x = x)
colorlegend(color = diverge_hcl, x = x, at = c(-1.5, 0, 1.5))
colorlegend(color = diverge_hcl, x = x, at = c(-1.5, 0, 1.5),
  labels = c("low", "middle", "high"))
colorlegend(color = rainbow_hcl, x = x, at = c(-1.5, 0, 1.5),
  labels = c("low", "middle", "high"), length.ticks = 1.5)
colorlegend(color = heat_hcl, x = x, at = c(-1.5, 0, 1.5),
  labels = c("low", "middle", "high"), length.ticks = 1.5,
  lwd.border = 2, lwd.ticks = 2, cex.labels = 1.5, font = 2)
colorlegend(color = topo.colors, x = x, at = c(-1.5, 0, 1.5),
  labels = c("low", "middle", "high"), length.ticks = 1.5,
  lwd.border = 2, lwd.ticks = 2, cex.labels = 1.5, font = 2,
  col.border = "green3", col.ticks = c(2, 5, 2), 
  col.labels = c(6, 4, 3))
colorlegend(color = diverge_hsv, x = x, at = c(-1.5, 0, 1.5),
  labels = c("low", "middle", "high"), length.ticks = 1.5,
  lwd.border = 2, lwd.ticks = 2, cex.labels = 1.5, font = 2,
  col.border = "green3", col.ticks = c(2, 5, 2), 
  col.labels = c(6, 4, 3), lty.border = 2, lty.ticks = c(2, 3, 2))
colorlegend(color = diverge_hsv, x = x, at = c(-1.5, 0, 1.5),
  labels = c("low", "middle", "high"), length.ticks = 1.5,
  lwd.border = 2, lwd.ticks = 2, cex.labels = 1.5, font = 2,
  col.border = "green3", col.ticks = c(2, 5, 2), 
  col.labels = c(6, 4, 3), lty.border = 2, lty.ticks = c(2, 3, 2),
  ncol = 3)
colorlegend(color = c("red", "white", "red"), x = x, at = c(-1.5, 0, 1.5),
  labels = c("low", "middle", "high"), length.ticks = 1.5,
  lwd.border = 2, lwd.ticks = 2, cex.labels = 1.5, font = 2,
  col.border = "green3", col.ticks = c(2, 5, 2), 
  col.labels = c(6, 4, 3), lty.border = 2, lty.ticks = c(2, 3, 2),
  ncol = 3, breaks = c(-2, -1, 1, 2))
colorlegend(color = diverge_hcl, x = x, range = c(-3, 3))
colorlegend(color = diverge_hcl, x = x, range = c(-3, 3), lrange = c(-6, 6))


## Combine plot with color legend.
n &lt;- 100
x &lt;- y &lt;- seq(-3, 3, length.out = n)
z &lt;- outer(sin(x), cos(x)) 
pal &lt;- colorlegend(color = diverge_hcl, x = z, plot = FALSE)
op &lt;- par(no.readonly = TRUE)
par(mar = c(4.1, 4.1, 1.1, 1.1))
layout(matrix(c(1, 2), nrow = 1), widths = c(1, 0.3))
image(x = x, y = y, z = z, col = pal$colors, breaks = pal$breaks)
par(mar = c(4.1, 0.1, 1.1, 3.1))
colorlegend(color = diverge_hcl, x = z, plot = TRUE, full = TRUE,
  side.legend = 2, side.ticks = 2)
par(op)


## Another example with different plot.
n &lt;- 50
x &lt;- sin(seq(-3, 3, length.out = n)) 
pal &lt;- colorlegend(color = diverge_hcl, x = x, plot = FALSE)
op &lt;- par(no.readonly = TRUE)
par(mar = c(7.1, 4.1, 1.1, 1.1))
barplot(x, border = "transparent", col = pal$map(x))
colorlegend(color = diverge_hcl, x = x, plot = FALSE, add = TRUE,
  xlim = c(0, 60), ylim = c(-1, 1), pos = c(0, -0.15), xpd = TRUE,
  scale = FALSE, width = 60, height = 0.15,
  at = seq(min(x), max(x), length.out = 9))
par(op)
</code></pre>

<hr>
<h2 id='continue'>
Continue Sampling
</h2><span id='topic+continue'></span>

<h3>Description</h3>

<p>This function takes a <code><a href="#topic+bamlss">bamlss</a></code> object which was created using a sampler function
and continues sampling from the last state of the MCMC chain.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>continue(object, cores = NULL, combine = TRUE,
  sleep = NULL, results = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="continue_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+bamlss">bamlss</a></code> object which contains samples.</p>
</td></tr>
<tr><td><code id="continue_+3A_cores">cores</code></td>
<td>
<p>An integer specifying the number of cores that should be used for the sampler
function. This is based on function <code><a href="parallel.html#topic+mclapply">mclapply</a></code> of the <span class="pkg">parallel</span>
package.</p>
</td></tr>
<tr><td><code id="continue_+3A_combine">combine</code></td>
<td>
<p>Should the new samples be combined with the old samples into one
<code><a href="coda.html#topic+mcmc">mcmc</a></code> matrix? Note that if <code>combine = FALSE</code> and the number of
iterations differ from one sampling step to the other there will be an error since
the start and end points in the samples <code><a href="coda.html#topic+mcmc">mcmc</a></code> objects are different!</p>
</td></tr>
<tr><td><code id="continue_+3A_sleep">sleep</code></td>
<td>
<p>Time the system should sleep before the next core is started.</p>
</td></tr>
<tr><td><code id="continue_+3A_results">results</code></td>
<td>
<p>If a results function was used to create the <code><a href="#topic+bamlss">bamlss</a></code> object,
should the results function be applied using the new samples?</p>
</td></tr>
<tr><td><code id="continue_+3A_...">...</code></td>
<td>
<p>Arguments passed to the sampler function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+bamlss">bamlss</a></code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bamlss">bamlss</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ## Simulate and run model with MCMC.
set.seed(123)
d &lt;- GAMart()
b &lt;- bamlss(num ~ s(x1) + s(x2) + s(x3) + te(lon,lat), data = d)

## Continue sampling.
a &lt;- continue(b)

## Plot all samples.
## plot(a, which = "samples")

## End(Not run)
</code></pre>

<hr>
<h2 id='cox_predict'>
Cox Model Prediction
</h2><span id='topic+cox_predict'></span>

<h3>Description</h3>

<p>This function takes a fitted Cox model, i.e., a model estimated by <code><a href="#topic+opt_Cox">opt_Cox</a></code>
or <code><a href="#topic+sam_Cox">sam_Cox</a></code> and computes predictions given a new data set or the
original values. Survival probabilities are computed using numerical integration, therefore,
computation may take some time. To avoid problems with computer memory, the prediction
of survival probabilities can be split into chunks and computed parallel on different cores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cox_predict(object, newdata,
  type = c("link", "parameter", "probabilities"),
  FUN = function(x) { mean(x, na.rm = TRUE) },
  time = NULL, subdivisions = 100, cores = NULL,
  chunks = 1, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cox_predict_+3A_object">object</code></td>
<td>
<p>A <code>"bamlss"</code> object as returned from function <code><a href="#topic+bamlss">bamlss</a></code>
using the optimizer <code><a href="#topic+opt_Cox">opt_Cox</a></code> or sampler function <code><a href="#topic+sam_Cox">sam_Cox</a></code>.</p>
</td></tr>
<tr><td><code id="cox_predict_+3A_newdata">newdata</code></td>
<td>
<p>A data frame or list containing the values of the model
covariates at which predictions are required. If missing <code>newdata</code> is the
<code>model.frame</code> of the provided model.</p>
</td></tr>
<tr><td><code id="cox_predict_+3A_type">type</code></td>
<td>
<p>Specifies the type of predictions that should be computed.</p>
</td></tr>
<tr><td><code id="cox_predict_+3A_fun">FUN</code></td>
<td>
<p>A function that should be applied on each row of the samples
of the additive predictor, parameter or probabilities. Per default
the function computes means of samples, however, other functions like <code><a href="stats.html#topic+quantile">quantile</a></code>
can be supplied.</p>
</td></tr>
<tr><td><code id="cox_predict_+3A_time">time</code></td>
<td>
<p><code>numeric</code>, specifies the time for which survival probabilities should
be computed if <code>type = "probabilities"</code>. Note that this overwrites survival times
that are supplied in argument <code>newdata</code>.</p>
</td></tr>
<tr><td><code id="cox_predict_+3A_subdivisions">subdivisions</code></td>
<td>
<p>How many time points should be created for each individual.</p>
</td></tr>
<tr><td><code id="cox_predict_+3A_cores">cores</code></td>
<td>
<p>Specifies the number of cores that should be used for prediction. The problem is
split into <code>core</code> chunks, each chunk is then processed by one core.</p>
</td></tr>
<tr><td><code id="cox_predict_+3A_chunks">chunks</code></td>
<td>
<p>The number of chunks that should be processed sequentially on one core.
This way memory problems can be avoided when computing survival times for large problems.</p>
</td></tr>
<tr><td><code id="cox_predict_+3A_verbose">verbose</code></td>
<td>
<p>Print progress information.</p>
</td></tr>
<tr><td><code id="cox_predict_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+predict.bamlss">predict.bamlss</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the type of function provided in argument <code>FUN</code>, a <code>numeric</code> vector
or <code>matrix</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sam_Cox">sam_Cox</a></code>, <code><a href="#topic+cox_bamlss">cox_bamlss</a></code>, <code><a href="#topic+surv_transform">surv_transform</a></code>,
<code><a href="#topic+simSurv">simSurv</a></code>, <code><a href="#topic+bamlss">bamlss</a></code>, <code><a href="#topic+predict.bamlss">predict.bamlss</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: library("survival")
set.seed(123)

## Simulate survival data.
d &lt;- simSurv(n = 500)

## Formula of the survival model, note
## that the baseline is given in the first formula by s(time).
f &lt;- list(
  Surv(time, event) ~ s(time) + s(time, by = x3),
  gamma ~ s(x1) + s(x2)
)

## Cox model with continuous time.
## Note the the family object cox_bamlss() sets
## the default optimizer and sampler function!
## First, posterior mode estimates are computed
## using function opt_Cox(), afterwards the
## sampler sam_Cox() is started.
b &lt;- bamlss(f, family = "cox", data = d)

## Predict survival probabilities P(T &gt; t).
p &lt;- predict(b, type = "probabilities",
  time = 3, subdivisions = 100, FUN = c95)

## End(Not run)
</code></pre>

<hr>
<h2 id='Crazy'>
Crazy simulated data
</h2><span id='topic+Crazy'></span>

<h3>Description</h3>

<p>This function creates simulated data based on a crazy function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Crazy(n = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Crazy_+3A_n">n</code></td>
<td>
<p>The number of observations to be simulated.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with response <code>y</code> and covariate <code>x</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GAMart">GAMart</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- Crazy(1000)
head(d)
plot(d)
</code></pre>

<hr>
<h2 id='CRPS'>
Continuous Rank Probability Score
</h2><span id='topic+CRPS'></span>

<h3>Description</h3>

<p>The function computes the continuous rank probability score (CRPS). Note that the function
uses numerical integration, for highly efficient computation please see
the <span class="pkg">scoringRules</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CRPS(object, newdata = NULL,
  interval = c(-Inf, Inf), FUN = mean,
  term = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CRPS_+3A_object">object</code></td>
<td>
<p>An object returned from <code><a href="#topic+bamlss">bamlss</a></code>.</p>
</td></tr>
<tr><td><code id="CRPS_+3A_newdata">newdata</code></td>
<td>
<p>Optional new data that should be used for calculation.</p>
</td></tr>
<tr><td><code id="CRPS_+3A_interval">interval</code></td>
<td>
<p>The interval that should be used for numerical integration</p>
</td></tr>
<tr><td><code id="CRPS_+3A_fun">FUN</code></td>
<td>
<p>Function to be applied on the CRPS scores.</p>
</td></tr>
<tr><td><code id="CRPS_+3A_term">term</code></td>
<td>
<p>If required, specify the model terms that should be used within the
<code><a href="#topic+predict.bamlss">predict.bamlss</a></code> function.</p>
</td></tr>
<tr><td><code id="CRPS_+3A_...">...</code></td>
<td>
<p>Arguments passed to function <code>FUN</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Gneiting T, Raftery AE (2007). Strictly Proper Scoring Rules, Prediction, and
Estimation.&quot; Journal of the American Statistical Association, 102(477), 359&ndash;378.
<a href="https://doi.org/10.1198/016214506000001437">doi:10.1198/016214506000001437</a>cd ..
</p>
<p>Gneiting T, Balabdaoui F, Raftery AE (2007). Probabilistic Forecasts, Calibration and
Sharpness. Journal of the Royal Statistical Society B, 69(2), 243&ndash;268.
<a href="https://doi.org/10.1111/j.1467-9868.2007.00587.x">doi:10.1111/j.1467-9868.2007.00587.x</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ## Simulate data.
d &lt;- GAMart()

## Model only including covariate x1.
b1 &lt;- bamlss(num ~ s(x1), data = d)

## Now, also including x2 and x2.
b2 &lt;- bamlss(num ~ s(x1) + s(x2) + s(x3), data = d)

## Compare using the CRPS score.
CRPS(b1)
CRPS(b2)

## End(Not run)</code></pre>

<hr>
<h2 id='ddnn'>Deep Distributional Neural Network</h2><span id='topic+ddnn'></span><span id='topic+predict.ddnn'></span><span id='topic+cv_ddnn'></span>

<h3>Description</h3>

<p>This function interfaces <span class="pkg">keras</span> infrastructures for high-level neural networks. The function
can be used as a standalone model fitting engine such as <code><a href="#topic+bamlss">bamlss</a></code> or as an on top
model engine to capture special features in the data that could not be captures by other
model fitting engines.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Deep distributional neural net.
ddnn(object, optimizer = "adam",
  learning_rate = 0.01,
  epochs = 100, batch_size = NULL,
  nlayers = 2, units = 100, activation = "relu",
  l1 = NULL, l2 = NULL,
  validation_split = 0.2, early_stopping = TRUE, patience = 50,
  verbose = TRUE, ...)

## Predict method.
## S3 method for class 'ddnn'
predict(object, newdata,
  model = NULL, type = c("link", "parameter"),
  drop = TRUE, ...)

## CV method for optimizing
## the number of epochs using
## the CRPS.
cv_ddnn(formula, data, folds = 10,
  min_epochs = 300, max_epochs = 400,
  interval = c(-Inf, Inf), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ddnn_+3A_object">object</code></td>
<td>
<p>An object of class <code>"bamlss"</code> or a <code><a href="#topic+bamlss.formula">bamlss.formula</a></code>.</p>
</td></tr>
<tr><td><code id="ddnn_+3A_optimizer">optimizer</code></td>
<td>
<p>Character or call to optimizer functions to be used within <code><a href="keras.html#topic+fit">fit</a></code>.
For character, options are: <code>"adam"</code> <code>"sgd"</code>, <code>"rmsprop"</code>, <code>"adagrad"</code>,
<code>"adadelta"</code>, <code>"adamax"</code>, <code>"adam"</code>. The default is
<code><a href="keras.html#topic+optimizer_rmsprop">optimizer_rmsprop</a></code> with learning rate set to <code>1e-04</code>.</p>
</td></tr>
<tr><td><code id="ddnn_+3A_learning_rate">learning_rate</code></td>
<td>
<p>The learning rate of the optimizer.</p>
</td></tr>
<tr><td><code id="ddnn_+3A_epochs">epochs</code></td>
<td>
<p>Number of times to iterate over the training data arrays, see
<code><a href="keras.html#topic+fit">fit</a></code>.</p>
</td></tr>
<tr><td><code id="ddnn_+3A_batch_size">batch_size</code></td>
<td>
<p>Number of samples per gradient update, see <code><a href="keras.html#topic+fit">fit</a></code>.</p>
</td></tr>
<tr><td><code id="ddnn_+3A_nlayers">nlayers</code></td>
<td>
<p>Number of hidden layers.</p>
</td></tr>
<tr><td><code id="ddnn_+3A_units">units</code></td>
<td>
<p>Number of nodes per hidden layer, can be a vector.</p>
</td></tr>
<tr><td><code id="ddnn_+3A_activation">activation</code></td>
<td>
<p>Activation functions used for the hidden layers, can be a vector.</p>
</td></tr>
<tr><td><code id="ddnn_+3A_l1">l1</code></td>
<td>
<p>Shrinkage parameter for L1 penalty.</p>
</td></tr>
<tr><td><code id="ddnn_+3A_l2">l2</code></td>
<td>
<p>Shrinkage parameter for L2 penalty.</p>
</td></tr>
<tr><td><code id="ddnn_+3A_validation_split">validation_split</code></td>
<td>
<p>Proportion of data that should be used for validation.</p>
</td></tr>
<tr><td><code id="ddnn_+3A_early_stopping">early_stopping</code></td>
<td>
<p>Logical, should early stopping of the optimizer be applied?</p>
</td></tr>
<tr><td><code id="ddnn_+3A_patience">patience</code></td>
<td>
<p>Integer, number of iterations the optimizer waits until early stopping is applied
after changes get small in validation data set.</p>
</td></tr>
<tr><td><code id="ddnn_+3A_verbose">verbose</code></td>
<td>
<p>Print information during runtime of the algorithm.</p>
</td></tr>
<tr><td><code id="ddnn_+3A_newdata">newdata</code></td>
<td>
<p>A <code><a href="base.html#topic+list">list</a></code> or <code><a href="base.html#topic+data.frame">data.frame</a></code> that should
be used for prediction.</p>
</td></tr>
<tr><td><code id="ddnn_+3A_model">model</code></td>
<td>
<p>Character or integer specifying for which distributional parameter predictions should
be computed.</p>
</td></tr>
<tr><td><code id="ddnn_+3A_type">type</code></td>
<td>
<p>If <code>type = "link"</code> the predictor of the corresponding <code>model</code>
is returned. If <code>type = "parameter"</code> predictions on the distributional parameter scale
are returned.</p>
</td></tr>
<tr><td><code id="ddnn_+3A_drop">drop</code></td>
<td>
<p>If predictions for only one <code>model</code> are returned, the list structure is dropped.</p>
</td></tr>
<tr><td><code id="ddnn_+3A_formula">formula</code></td>
<td>
<p>The model formula.</p>
</td></tr>
<tr><td><code id="ddnn_+3A_data">data</code></td>
<td>
<p>The data used for estimation.</p>
</td></tr>
<tr><td><code id="ddnn_+3A_folds">folds</code></td>
<td>
<p>The number of folds that should be generated.</p>
</td></tr>
<tr><td><code id="ddnn_+3A_min_epochs">min_epochs</code>, <code id="ddnn_+3A_max_epochs">max_epochs</code></td>
<td>
<p>Defines the minimum and maximum epochs thet should be used.</p>
</td></tr>
<tr><td><code id="ddnn_+3A_interval">interval</code></td>
<td>
<p>Response interval, see function <code><a href="#topic+CRPS">CRPS</a></code>.</p>
</td></tr>
<tr><td><code id="ddnn_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default <span class="pkg">keras</span> model is a sequential model with two hidden layers with <code>"relu"</code>
activation function and 100 units in each layer. Between each layer is a dropout layer with
0.1 dropout rate.
</p>


<h3>Value</h3>

<p>For function <code>ddnn()</code> an object of class <code>"ddnn"</code>. Note that extractor
functions <code><a href="stats.html#topic+fitted">fitted</a></code> and <code><a href="#topic+residuals.bamlss">residuals.bamlss</a></code> can be applied.
For function <code>predict.ddnn()</code> a list or vector of predicted values.
</p>


<h3>WARNINGS</h3>

<p>The deep learning infrastructure is experimental!
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bamlss.frame">bamlss.frame</a></code>, <code><a href="#topic+bamlss">bamlss</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ## Simulate data.
set.seed(123)
n &lt;- 300
x &lt;- runif(n, -3, 3)
fsigma &lt;- -2 + cos(x)
y &lt;- sin(x) + rnorm(n, sd = exp(fsigma))

## Setup model formula.
f &lt;- list(
  y ~ x,
  sigma ~ x
)

## Fit neural network.
library("keras")
b &lt;- ddnn(f, epochs = 2000)

## Plot estimated functions.
par(mfrow = c(1, 2))
plot(x, y)
plot2d(fitted(b)$mu ~ x, add = TRUE)
plot2d(fitted(b)$sigma ~ x,
  ylim = range(c(fitted(b)$sigma, fsigma)))
plot2d(fsigma ~ x, add = TRUE, col.lines = "red")

## Predict with newdata.
nd &lt;- data.frame(x = seq(-6, 6, length = 100))
nd$p &lt;- predict(b, newdata = nd, type = "link")

par(mfrow = c(1, 2))
plot(x, y, xlim = c(-6, 6), ylim = range(c(nd$p$mu, y)))
plot2d(p$mu ~ x, data = nd, add = TRUE)
plot2d(p$sigma ~ x, data = nd,
  ylim = range(c(nd$p$sigma, fsigma)))
plot2d(fsigma ~ x, add = TRUE, col.lines = "red")

## Plot quantile residuals.
e &lt;- residuals(b)
plot(e)

## End(Not run)
</code></pre>

<hr>
<h2 id='DIC'>
Deviance Information Criterion
</h2><span id='topic+DIC'></span>

<h3>Description</h3>

<p>Generic function returning the deviance information criterion (DIC) of a fitted model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DIC(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DIC_+3A_object">object</code></td>
<td>
<p>A fitted model object for which there exists a <code>DIC</code> method.</p>
</td></tr>
<tr><td><code id="DIC_+3A_...">...</code></td>
<td>
<p>Optionally more fitted model objects.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: d &lt;- GAMart()
b1 &lt;- bamlss(num ~ s(x1), data = d)
b2 &lt;- bamlss(num ~ s(x1) + s(x2), data = d)
DIC(b1, b2)

## End(Not run)
</code></pre>

<hr>
<h2 id='dist_mvnchol'>Cholesky MVN (disttree)</h2><span id='topic+dist_mvnchol'></span>

<h3>Description</h3>

<p>disttree Families for MVN with Cholesky Parameterization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dist_mvnchol(k, r = k - 1L, type = c("basic", "modified", "chol"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dist_mvnchol_+3A_k">k</code></td>
<td>
<p>integer. The dimension of the multivariate distribution.</p>
</td></tr>
<tr><td><code id="dist_mvnchol_+3A_r">r</code></td>
<td>
<p>Integer, the number of off-diagonals to model (AD-r covariance).</p>
</td></tr>
<tr><td><code id="dist_mvnchol_+3A_type">type</code></td>
<td>
<p>character. Choose <code>"basic"</code> Cholesky decomposition or <code>"modified"</code>
Cholesky decomposition. (For back compatibility <code>"chol"</code> is identical to <code>"basic"</code>.)</p>
</td></tr>
<tr><td><code id="dist_mvnchol_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>NOTE: These functions are under development!! 
disttree families that models a multivariate Normal (Gaussian)
distribution by (modified) Cholesky decomposition of the covariance
matrix.
</p>


<h3>Value</h3>

<p>a bamlss family.
</p>

<hr>
<h2 id='engines'>
Show Available Engines for a Family Object
</h2><span id='topic+engines'></span>

<h3>Description</h3>

<p>The function shows available optimizer and sampling engines for a given family object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>engines(family, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="engines_+3A_family">family</code></td>
<td>
<p>A family object or the name of the family.</p>
</td></tr>
<tr><td><code id="engines_+3A_...">...</code></td>
<td>
<p>Further family objects or names.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>engines(gaussian_bamlss, "gamma", cox_bamlss)
</code></pre>

<hr>
<h2 id='family.bamlss'>
Distribution Families in <span class="pkg">bamlss</span>
</h2><span id='topic+family.bamlss'></span><span id='topic+family.bamlss.frame'></span><span id='topic+bamlss.family'></span><span id='topic+beta_bamlss'></span><span id='topic+binomial_bamlss'></span><span id='topic+dw_bamlss'></span><span id='topic+cnorm_bamlss'></span><span id='topic+cox_bamlss'></span><span id='topic+gaussian_bamlss'></span><span id='topic+gaussian2_bamlss'></span><span id='topic+Gaussian_bamlss'></span><span id='topic+gamma_bamlss'></span><span id='topic+multinomial_bamlss'></span><span id='topic+mvnorm_bamlss'></span><span id='topic+mvnormAR1_bamlss'></span><span id='topic+poisson_bamlss'></span><span id='topic+gpareto_bamlss'></span><span id='topic+glogis_bamlss'></span><span id='topic+AR1_bamlss'></span><span id='topic+beta1_bamlss'></span><span id='topic+ztnbinom_bamlss'></span><span id='topic+lognormal_bamlss'></span><span id='topic+ALD_bamlss'></span><span id='topic+nbinom_bamlss'></span><span id='topic+weibull_bamlss'></span><span id='topic+dirichlet_bamlss'></span><span id='topic+logNN_bamlss'></span><span id='topic+Sichel_bamlss'></span><span id='topic+GEV_bamlss'></span><span id='topic+gumbel_bamlss'></span><span id='topic+mix_bamlss'></span><span id='topic+ELF_bamlss'></span><span id='topic+DGP_bamlss'></span><span id='topic+ZANBI_bamlss'></span>

<h3>Description</h3>

<p>Family objects in <span class="pkg">bamlss</span> specify the information that is needed for using (different)
model fitting engines, e.g., the parameter names and corresponding link functions, the
density function, derivatives of the log-likelihood w.r.t. the predictors, and so
forth. The optimizer or sampler functions that are called by <code><a href="#topic+bamlss">bamlss</a></code> must know how
much information is needed to interpret the model since the family objects are simply
passed through. Family objects are also used for computing post-modeling statistics, e.g., for
residual diagnostics or random number generation. See the details and examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Family objects in bamlss:
ALD_bamlss(..., tau = 0.5, eps = 0.01)
beta_bamlss(...)
binomial_bamlss(link = "logit", ...)
cnorm_bamlss(...)
cox_bamlss(...)
dw_bamlss(...)
DGP_bamlss(...)
dirichlet_bamlss(...)
ELF_bamlss(..., tau = 0.5)
gaussian_bamlss(...)
gaussian2_bamlss(...)
Gaussian_bamlss(...)
gamma_bamlss(...)
logNN_bamlss(...)
multinomial_bamlss(...)
mvnorm_bamlss(k = 2, ...)
mvnormAR1_bamlss(k = 2, ...)
poisson_bamlss(...)
gpareto_bamlss(...)
glogis_bamlss(...)
AR1_bamlss(...)
beta1_bamlss(ar.start, ...)
nbinom_bamlss(...)
ztnbinom_bamlss(...)
lognormal_bamlss(...)
weibull_bamlss(...)
Sichel_bamlss(...)
GEV_bamlss(...)
gumbel_bamlss(...)
mix_bamlss(f1, f2, ...)
ZANBI_bamlss(...)

## Extractor functions:
## S3 method for class 'bamlss'
family(object, ...)
## S3 method for class 'bamlss.frame'
family(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="family.bamlss_+3A_object">object</code></td>
<td>
<p>An object of class <code>"bamlss"</code> or <code>"bamlss.frame"</code>, see function
<code><a href="#topic+bamlss">bamlss</a></code> and <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>.</p>
</td></tr>
<tr><td><code id="family.bamlss_+3A_k">k</code></td>
<td>
<p>The dimension of the multivariate normal. Note, if <code>k = 1</code> function
<code>gaussian_bamlss()</code> is called.</p>
</td></tr>
<tr><td><code id="family.bamlss_+3A_ar.start">ar.start</code></td>
<td>
<p>Logical vector of length equal to the number of rows of the full data set
used for modeling. Must hold entries <code>TRUE</code> indicating the start of a time series of
a section. If <code>ar.start = NULL</code> lagged residuals are computed by simple shifting.
See also <code><a href="mgcv.html#topic+bam">bam</a></code>.</p>
</td></tr>
<tr><td><code id="family.bamlss_+3A_link">link</code></td>
<td>
<p>Possible link functions.</p>
</td></tr>
<tr><td><code id="family.bamlss_+3A_tau">tau</code></td>
<td>
<p>The quantile the should be fitted.</p>
</td></tr>
<tr><td><code id="family.bamlss_+3A_eps">eps</code></td>
<td>
<p>Constant to be used for the approximation of the absolute function.</p>
</td></tr>
<tr><td><code id="family.bamlss_+3A_f1">f1</code>, <code id="family.bamlss_+3A_f2">f2</code></td>
<td>
<p>A family of class <code>"gamlss.family"</code>, see package <span class="pkg">gamlss.dist</span>.</p>
</td></tr>
<tr><td><code id="family.bamlss_+3A_...">...</code></td>
<td>
<p>Arguments passed to functions that are called within the family object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The following lists the minimum requirements on a <span class="pkg">bamlss</span> family object to be used with
<code><a href="#topic+bamlss">bamlss</a></code> and <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>:
</p>

<ul>
<li><p> The family object must return a <code><a href="base.html#topic+list">list</a></code> of class <code>"family.bamlss"</code>.
</p>
</li>
<li><p> The object must contain the family name as a character string. 
</p>
</li>
<li><p> The object must contain the names of the parameters as a character string, as well as
the corresponding link functions as character string.
</p>
</li></ul>

<p>For most optimizer and sampling functions at least the density function, including a <code>log</code>
argument, should be provided.
When using generic model fitting engines like <code><a href="#topic+opt_bfit">opt_bfit</a></code> or <code><a href="#topic+sam_GMCMC">sam_GMCMC</a></code>, as
well as for computing post-modeling statistics with function <code><a href="#topic+samplestats">samplestats</a></code>, and others,
it is assumed that the density function in a family object has the following arguments:
</p>
<p><code>d(y, par, log = FALSE, ...)</code>
</p>
<p>where argument <code>y</code> is the response (possibly a matrix) and <code>par</code> is a named list
holding the evaluated parameters of the distribution, e.g., using a normal distribution <code>par</code>
has two elements, one for the mean <code>par$mu</code> and one for the standard deviation
<code>par$sigma</code>. The dots argument is for passing special internally used objects, depending
on the type of model this feature is usually not needed.
</p>
<p>Similarly, for derivative based algorithms, e.g. using iteratively weighted least squares
(IWLS, see function <code><a href="#topic+opt_bfit">opt_bfit</a></code>, the family object holds derivative functions evaluating
derivatives of the log-likelihood w.r.t. the predictors (or expectations of derivatives).
For each parameter, these functions also hold the following arguments:
</p>
<p><code>score(y, par, ...)</code>
</p>
<p>for computing the first derivative of the log-likelihood w.r.t. a predictor and
</p>
<p><code>hess(y, par, ...)</code>
</p>
<p>for computing the negative second derivatives. Within the family object these functions
are organized in a named list, see the examples below.
</p>
<p>In addition, for the cumulative distribution function (<code>p(y, par, ...)</code>), for the quantile
function (<code>q(y, par, ...)</code>) or for creating random numbers (<code>r(n, par, ...)</code>) the same
structure is assumed. See, e.g., the code of function <code>gaussian.bamlss()</code>.
</p>
<p>Some model fitting engines can initialize the distributional parameters which oftentimes
leads to much faster convergence. The initialize functions are again organized within a named list,
one entry for each parameter, similar to the <code>score</code> and <code>hess</code> functions, e.g.,
see the code of family object <code>gaussian.bamlss</code>.
</p>
<p>Using function <code><a href="#topic+bamlss">bamlss</a></code>, <code><a href="#topic+residuals.bamlss">residuals.bamlss</a></code> and
<code><a href="#topic+predict.bamlss">predict.bamlss</a></code> the family objects may
also specify the <code>transform()</code>er, <code>optimizer()</code>, <code>sampler()</code>,
<code>samplestats()</code>, <code>results()</code>, <code>residuals()</code> and <code>predict()</code> function that
should be used with this family. See for example the setup of <code><a href="#topic+cox_bamlss">cox_bamlss</a></code>.
</p>
<p>For using specialized estimation engines like <code><a href="#topic+sam_JAGS">sam_JAGS</a></code> it is recommended to supply
any extra arguments needed by those engines with an additional list entry within the family
object, e.g., using <code>gaussian_bamlss()</code> with <code><a href="#topic+sam_JAGS">sam_JAGS</a></code> the family objects holds
special details in an element named <code>"bugs"</code>.
</p>
<p>The examples below illustrate this setup. See also the code of the <span class="pkg">bamlss</span> family
functions.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bamlss">bamlss</a></code>, <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## New family object for the normal distribution,
## can be used by function opt_bfit() and sam_GMCMC().
normal_bamlss &lt;- function(...) {
  f &lt;- list(
    "family" = "normal",
    "names" = c("mu", "sigma"),
    "links" = c("identity", "log"),
    "d" = function(y, par, log = FALSE) {
      dnorm(y, mean = par$mu, sd = par$sigma, log = log)
    },
    "score" = list(
      "mu" = function(y, par, ...) {
        drop((y - par$mu) / (par$sigma^2))
      },
      "sigma" = function(y, par, ...) {
        drop(-1 + (y - par$mu)^2 / (par$sigma^2))
      }
    ),
    "hess" = list(
      "mu" = function(y, par, ...) {
        drop(1 / (par$sigma^2))
      },
      "sigma" = function(y, par, ...) { 
        rep(2, length(y))
      }
    )
  )
  class(f) &lt;- "family.bamlss"
  return(f)
}

## Not run: ## Test on simulated data.
d &lt;- GAMart()
b &lt;- bamlss(num ~ s(x1) + s(x2) + s(x3),
  data = d, family = "normal")
plot(b)

## Compute the log-likelihood using the family object.
f &lt;- family(b)
sum(f$d(y = d$num, par = f$map2par(fitted(b)), log = TRUE))

## For using JAGS() more details are needed.
norm4JAGS_bamlss &lt;- function(...) {
  f &lt;- normal_bamlss()
  f$bugs &lt;- list(
    "dist" = "dnorm",
    "eta" = BUGSeta,
    "model" = BUGSmodel,
    "reparam" = c(sigma = "1 / sqrt(sigma)")
  )
  return(f)
}

## Now with opt_bfit() and sam_JAGS().
b &lt;- bamlss(num ~ s(x1) + s(x2) + s(x3), data = d,
  optimizer = opt_bfit, sampler = sam_JAGS, family = "norm4JAGS")
plot(b)

## End(Not run)
</code></pre>

<hr>
<h2 id='fatalities'>Weekly Number of Fatalities in Austria</h2><span id='topic+fatalities'></span>

<h3>Description</h3>

<p>This data set includes weekly fatalities in Austria from 2000 to 46 weeks in 2020. The data
is taken from the Eurostat data base.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("fatalities")</code></pre>


<h3>Format</h3>

<p>The <code>fatalities</code> data contains the following variables:
</p>

<dl>
<dt>num:</dt><dd><p>Integer, the number of fatalities.</p>
</dd>
<dt>year:</dt><dd><p>Integer, the corresponding year fatalities are recorded.</p>
</dd>
<dt>week:</dt><dd><p>Integer, the corresponding week fatalities are recorded..</p>
</dd>
</dl>



<h3>References</h3>

<p>Eurostat Database (2020). <em>Population and social conditions, demography and migration,
mortality, weekly deaths, deaths by week and NUTS 3 region, Austria</em>
<a href="https://ec.europa.eu/eurostat/">https://ec.europa.eu/eurostat/</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("fatalities")
plot(num ~ week, data = fatalities)
</code></pre>

<hr>
<h2 id='fitted.bamlss'>
BAMLSS Fitted Values
</h2><span id='topic+fitted.bamlss'></span>

<h3>Description</h3>

<p>Function to compute fitted values for <code><a href="#topic+bamlss">bamlss</a></code> models. The function calls
<code><a href="#topic+predict.bamlss">predict.bamlss</a></code> to compute fitted values from samples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bamlss'
fitted(object, model = NULL, term = NULL,
  type = c("link", "parameter"), samples = TRUE,
  FUN = c95, nsamps = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fitted.bamlss_+3A_object">object</code></td>
<td>
<p>An object of class <code>"bamlss"</code></p>
</td></tr>
<tr><td><code id="fitted.bamlss_+3A_model">model</code></td>
<td>
<p>Character or integer, specifies the model for which fitted values should be computed.</p>
</td></tr>
<tr><td><code id="fitted.bamlss_+3A_term">term</code></td>
<td>
<p>Character or integer, specifies the model terms for which fitted values are required.
Note that if <code>samples = TRUE</code>, e.g., <code>term = c("s(x1)", "x2")</code> will compute the
combined fitted values <code>s(x1) + x2</code>.</p>
</td></tr>
<tr><td><code id="fitted.bamlss_+3A_type">type</code></td>
<td>
<p>If <code>type = "link"</code> the predictor of the corresponding <code>model</code>
is returned. If <code>type = "parameter"</code> fitted values on the distributional parameter scale
are returned.</p>
</td></tr>
<tr><td><code id="fitted.bamlss_+3A_samples">samples</code></td>
<td>
<p>Should fitted values be computed using samples of parameters or estimated parameters
as returned from optimizer functions (e.g., function <code><a href="#topic+bfit">bfit</a></code> returns
<code>"fitted.values"</code>). The former results in a call to <code><a href="#topic+predict.bamlss">predict.bamlss</a></code>, the
latter simply extracts the <code>"fitted.values"</code> of the <code><a href="#topic+bamlss">bamlss</a></code> object and
is not model term specific.</p>
</td></tr>
<tr><td><code id="fitted.bamlss_+3A_fun">FUN</code></td>
<td>
<p>A function that should be applied on the samples of predictors or
parameters, depending on argument <code>type</code>.</p>
</td></tr>
<tr><td><code id="fitted.bamlss_+3A_nsamps">nsamps</code></td>
<td>
<p>If the fitted <code><a href="#topic+bamlss">bamlss</a></code> object contains samples of parameters,
computing fitted values may take quite some time. Therefore, to get a first feeling it can
be useful to compute fitted values only based on <code>nsamps</code> samples, i.e., <code>nsamps</code>
specifies the number of samples which are extracted on equidistant intervals.</p>
</td></tr>
<tr><td><code id="fitted.bamlss_+3A_...">...</code></td>
<td>
<p>Arguments passed to function <code><a href="#topic+predict.bamlss">predict.bamlss</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on arguments <code>model</code>, <code>FUN</code> and the structure of the <code><a href="#topic+bamlss">bamlss</a></code>
model, a list of fitted values or simple vectors or matrices of fitted values.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bamlss">bamlss</a></code>, <code><a href="#topic+predict.bamlss">predict.bamlss</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ## Generate some data.
d &lt;- GAMart()

## Model formula.
f &lt;- list(
  num ~ s(x1) + s(x2) + s(x3) + te(lon,lat),
  sigma ~ s(x1) + s(x2) + s(x3) + te(lon,lat)
)

## Estimate model.
b &lt;- bamlss(f, data = d)

## Fitted values returned from optimizer.
f1 &lt;- fitted(b, model = "mu", samples = FALSE)

## Fitted values returned from sampler.
f2 &lt;- fitted(b, model = "mu", samples = TRUE, FUN = mean)

plot(f1, f2)

## End(Not run)
</code></pre>

<hr>
<h2 id='GAMart'>GAM Artificial Data Set</h2><span id='topic+GAMart'></span>

<h3>Description</h3>

<p>This function creates artificial GAM-type <code><a href="base.html#topic+data.frame">data.frame</a></code>s.
The function is mainly used for testing purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GAMart(n = 500, sd = 0.1, seed = FALSE,
  ti = c("none", "vcm", "main", "both"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GAMart_+3A_n">n</code></td>
<td>
<p>The number of observations.</p>
</td></tr>
<tr><td><code id="GAMart_+3A_sd">sd</code></td>
<td>
<p>Standard deviation of the normal errors.</p>
</td></tr>
<tr><td><code id="GAMart_+3A_seed">seed</code></td>
<td>
<p>Sets the <code>seed</code> to <code>111</code>.</p>
</td></tr>
<tr><td><code id="GAMart_+3A_ti">ti</code></td>
<td>
<p>For tensor product interaction term, the type of interaction.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- GAMart()
head(d)

## Not run: b &lt;- bamlss(num ~ s(x1) + s(x2) + s(x3) + te(lon,lat), data = d)
plot(b)

## End(Not run)
</code></pre>

<hr>
<h2 id='gamlss_distributions'>
Extract Distribution families of the <span class="pkg">gamlss.dist</span> Package
</h2><span id='topic+gamlss_distributions'></span>

<h3>Description</h3>

<p>The functions searches in the <span class="pkg">gamlss.dist</span> namespace for available
distributions. It returns a named list of faily functions which can be used
with <code><a href="#topic+bamlss">bamlss</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamlss_distributions(type = c("continuous", "discrete"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamlss_distributions_+3A_type">type</code></td>
<td>
<p>Character specifying the type of distribution to be extracted.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+bamlss">bamlss</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
dists &lt;- gamlss_distributions(type = "continuous")
print(dists)

## End(Not run)</code></pre>

<hr>
<h2 id='gF'>
Get a BAMLSS Family
</h2><span id='topic+gF'></span>

<h3>Description</h3>

<p>Function to get a <code><a href="#topic+family.bamlss">family.bamlss</a></code> object to be used for fitting. The main
purpose of this function is to ease the handling of extra arguments to the family object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gF(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gF_+3A_x">x</code></td>
<td>
<p>The name of the <code><a href="#topic+family.bamlss">family.bamlss</a></code> without the <code>".bamlss"</code> extension.</p>
</td></tr>
<tr><td><code id="gF_+3A_...">...</code></td>
<td>
<p>Arguments passed to the family object.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+family.bamlss">family.bamlss</a></code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+family.bamlss">family.bamlss</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- gF(gaussian)
print(f)
</code></pre>

<hr>
<h2 id='Golf'>Prices of Used Cars Data</h2><span id='topic+Golf'></span>

<h3>Description</h3>

<p>This dataset is taken from the Regression Book and is about prices of used VW Golf cars.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Golf")</code></pre>


<h3>Format</h3>

<p>The <code>Golf</code> data contains the following variables:
</p>

<dl>
<dt>price:</dt><dd><p>Numeric, sale price in 1000 Euro.</p>
</dd>
<dt>age:</dt><dd><p>Numeric, age of the car in month.</p>
</dd>
<dt>kilometer:</dt><dd><p>Numeric, kilometer reading in 1000 kilometers.</p>
</dd>
<dt>tia:</dt><dd><p>Numeric, month until the next TIA appointment (German TUEV).</p>
</dd>
<dt>abs:</dt><dd><p>Factor, does the car have abs?</p>
</dd>
<dt>sunroof:</dt><dd><p>Factor, does the car have a sunroof?</p>
</dd>
</dl>



<h3>References</h3>

<p>Fahrmeir, L., Kneib, T., Lang, S. and Marx, B. (2013).
Regression - Models, Methods and Applications, Springer.
<code>https://www.uni-goettingen.de/de/551357.html</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Golf")
plot(price ~ age, data = Golf)
plot(price ~ kilometer, data = Golf)
</code></pre>

<hr>
<h2 id='homstart_data'>
HOMSTART Precipitation Data
</h2><span id='topic+homstart_data'></span>

<h3>Description</h3>

<p>This function downloads and compiles the HOMSTART-project data set. The data is downloaded from
the Zentralanstalt fuer Meteorologie und Geodynamik (ZAMG, <a href="http://www.zamg.ac.at">http://www.zamg.ac.at</a>) and
funded by the Austrian Climate Research Programme (ACRP) and is free for research purposes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>homstart_data(dir = NULL, load = TRUE, tdir = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="homstart_data_+3A_dir">dir</code></td>
<td>
<p>The directory where the <code>homstart.rda</code> file should be stored.</p>
</td></tr>
<tr><td><code id="homstart_data_+3A_load">load</code></td>
<td>
<p>Should the <code>homstart</code> data be loaded?</p>
</td></tr>
<tr><td><code id="homstart_data_+3A_tdir">tdir</code></td>
<td>
<p>An optional temporary directory where all downloaded files are processed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the following variables:
</p>
<table>
<tr><td><code>raw</code></td>
<td>
<p>The daily precipitation observations.</p>
</td></tr>
<tr><td><code>cens</code></td>
<td>
<p>Precipitation observations censored at 0.</p>
</td></tr>
<tr><td><code>bin</code></td>
<td>
<p>Factor with levels <code>"yes"</code> or <code>"no"</code> indicating precipitation.</p>
</td></tr>
<tr><td><code>cat</code></td>
<td>
<p>Factor with levels <code>"none"</code>, <code>"low"</code>, <code>"medium"</code> and <code>"high"</code>
indicating the amount of precipitation.</p>
</td></tr>
<tr><td><code>trend</code></td>
<td>
<p>A numeric time trend</p>
</td></tr>
<tr><td><code>month</code></td>
<td>
<p>Month of of the observation.</p>
</td></tr>
<tr><td><code>year</code></td>
<td>
<p>Year of the observation.</p>
</td></tr>
<tr><td><code>day</code></td>
<td>
<p>Day of the year.</p>
</td></tr>
<tr><td><code>lon</code></td>
<td>
<p>The longitude coordinate of the corresponding meteorological station.</p>
</td></tr>
<tr><td><code>lat</code></td>
<td>
<p>The latitude coordinate of the corresponding meteorological station.</p>
</td></tr>
<tr><td><code>id</code></td>
<td>
<p>Factor, meteorological station identifier.</p>
</td></tr>
<tr><td><code>cos1</code>, <code>cos2</code>, <code>sin1</code>, <code>sin2</code></td>
<td>
<p>Transformed time trend for harmonic regression.</p>
</td></tr>
<tr><td><code>weekend</code></td>
<td>
<p>Factor, with levels <code>"yes"</code> and <code>"no"</code> indication if the observation
was measured on a weekend.</p>
</td></tr>
<tr><td><code>elevation</code></td>
<td>
<p>Numeric, the elevation of the meteorological station.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Nemec J, Gruber C, Chimani B, Auer I (2012).
Trends in extreme temperature indices in Austria based on a new homogenised dataset.
<em>International Journal of Climatology</em>. DOI 10.1002/joc.3532.
</p>
<p>Nemec J, Chimani B, Gruber C, Auer I (2011).
Ein neuer Datensatz homogenisierter Tagesdaten.
<em>OEGM Bulletin</em>, <b>1</b>, 19&ndash;20.
<a href="https://www.meteorologie.at/docs/OEGM_bulletin_2011_1.pdf">https://www.meteorologie.at/docs/OEGM_bulletin_2011_1.pdf</a>
</p>
<p>Umlauf N, Mayr G, Messner J, Zeileis A (2012).
Why does it always rain on me? A spatio-temporal analysis of precipitation in Austria.
<em>Austrian Journal of Statistics</em>, <b>41</b>(1), 81&ndash;92.
<a href="https://doi.org/10.17713/ajs.v41i1.190">doi:10.17713/ajs.v41i1.190</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: homstart_data(load = TRUE)
head(homstart)

## End(Not run)
</code></pre>

<hr>
<h2 id='jm_bamlss'>
Fit Flexible Additive Joint Models
</h2><span id='topic+jm_bamlss'></span><span id='topic+sam_JM'></span><span id='topic+opt_JM'></span><span id='topic+jm_mode'></span><span id='topic+jm_mcmc'></span><span id='topic+jm_transform'></span><span id='topic+jm_survplot'></span><span id='topic+jm_predict'></span>

<h3>Description</h3>

<p>Family object to fit a flexible additive joint model for longitudinal and survival
data under a Bayesian approach as presented in Koehler et al. (2017a, b). 
All parts of the joint model can be specified as structured additive predictors. 
See the details and examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## JM family object.
jm_bamlss(...)

## "bamlss.frame" transformer function
## to set up joint models.
jm_transform(x, y, data, terms, knots, formula, family, subdivisions = 25,
  timedependent = c("lambda", "mu", "alpha", "dalpha"), timevar = NULL, 
  idvar = NULL, alpha = .Machine$double.eps, mu = NULL, sigma = NULL, 
  sparse = TRUE, nonlinear = FALSE, edf_alt = FALSE, start_mu = NULL, 
  k_mu = 6, ...)
                    
## Posterior mode optimizing engine.     
opt_JM(x, y, start = NULL, weights = NULL, offset = NULL, 
  criterion = c("AICc", "BIC", "AIC"), maxit = c(100, 1), 
  nu = c("lambda" = 0.1, "gamma" = 0.1, "mu" = 1, "sigma" = 1,
    "alpha" = 1, "dalpha" = 1),
  update.nu = FALSE, eps = 0.0001, alpha.eps = 0.001, ic.eps = 1e-08, 
  nback = 40, verbose = TRUE, digits = 4, ...)

jm_mode(x, y, start = NULL, weights = NULL, offset = NULL, 
  criterion = c("AICc", "BIC", "AIC"), maxit = c(100, 1), 
  nu = c("lambda" = 0.1, "gamma" = 0.1, "mu" = 1, "sigma" = 1,
    "alpha" = 1, "dalpha" = 1),
  update.nu = FALSE, eps = 0.0001, alpha.eps = 0.001, ic.eps = 1e-08, 
  nback = 40, verbose = TRUE, digits = 4, ...)

## Sampler function.
sam_JM(x, y, family, start = NULL, weights = NULL, offset = NULL, 
  n.iter = 1200, burnin = 200, thin = 1, verbose = TRUE, digits = 4, 
  step = 20, ...)

jm_mcmc(x, y, family, start = NULL, weights = NULL, offset = NULL, 
  n.iter = 1200, burnin = 200, thin = 1, verbose = TRUE, digits = 4, 
  step = 20, ...)
  
## Predict function, set to default in jm_bamlss().
jm_predict(object, newdata,
  type = c("link", "parameter", "probabilities", "cumhaz", "loglik"),
  dt, steps, id, FUN = function(x) { mean(x, na.rm = TRUE) }, 
  subdivisions = 100, cores = NULL, chunks = 1,
  verbose = FALSE,  ...)
  
## Survival plot.
jm_survplot(object, id = 1, dt = NULL, steps = 10, 
  points = TRUE, rug = !points)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jm_bamlss_+3A_x">x</code></td>
<td>
<p>The <code>x</code> list, as returned from function
<code><a href="#topic+bamlss.frame">bamlss.frame</a></code> (and transformed by function <code>jm_transform()</code>),
holding all model matrices and other information that is used for
fitting the model.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_y">y</code></td>
<td>
<p>The model response, as returned from function <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> or <code><a href="base.html#topic+list">list</a></code> containing the model
response variable(s) and covariates specified in the <code>formula</code> in long format.
By default the variables are taken from <code>environment(formula)</code>:
typically the environment from which <code>bamlss</code> is called.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_terms">terms</code></td>
<td>
<p>The corresponding <code><a href="#topic+terms.bamlss">terms.bamlss</a></code> object needed for processing.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_knots">knots</code></td>
<td>
<p>An optional list containing user specified knots, see the documentation of
function <code><a href="mgcv.html#topic+gam">gam</a></code>.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_formula">formula</code></td>
<td>
<p>The corresponding <code><a href="#topic+bamlss.formula">bamlss.formula</a></code>.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_family">family</code></td>
<td>
<p>The <code><a href="#topic+bamlss.family">bamlss.family</a></code> object.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_subdivisions">subdivisions</code></td>
<td>
<p>How many time points should be created for each individual.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_timedependent">timedependent</code></td>
<td>
<p>A character vector specifying the names of parameters in <code>x</code>
that are time-dependent. Time grid design matrices are only computed for these parameters.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_timevar">timevar</code></td>
<td>
<p>A character specifying the name of the survival time variable in the
data set.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_idvar">idvar</code></td>
<td>
<p>Depending on the type of data set, this is the name of the variable specifying
identifier of individuals.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_alpha">alpha</code></td>
<td>
<p>Numeric, a starting value for the intercept of the association parameter alpha.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_mu">mu</code></td>
<td>
<p>Numeric, a starting value for the intercept of the mu parameter.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_sigma">sigma</code></td>
<td>
<p>Numeric, a starting value for the intercept of the sigma parameter.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_sparse">sparse</code></td>
<td>
<p>Logical, indicating if sparse matrix structures are used for updating and sampling
of mu parameter model terms.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_nonlinear">nonlinear</code></td>
<td>
<p>Logical, indicating if association is nonlinear in mu. See Details on the different
model specifications.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_edf_alt">edf_alt</code></td>
<td>
<p>Logical, indicating if an alternative computation of estimated degrees of freedom 
for penalized model terms should be used.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_start_mu">start_mu</code></td>
<td>
<p>Starting values for the computation of mu. For estimating associations which are 
nonlinear in mu, knot placement is based on these starting values which can improve stability. </p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_k_mu">k_mu</code></td>
<td>
<p>Number of knots for spline basis of association nonlinear in mu. Reducing this number
improves stability of the estimation.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_start">start</code></td>
<td>
<p>A named numeric vector containing possible starting values, the names are based on
function <code><a href="#topic+parameters">parameters</a></code>.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_weights">weights</code></td>
<td>
<p>Currently not supported.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_offset">offset</code></td>
<td>
<p>Currently not supported.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_criterion">criterion</code></td>
<td>
<p>Information criterion to be used, e.g., for smoothing
variance selection. Options are the corrected AIC <code>"AICc"</code> (see Details), the <code>"BIC"</code> and
<code>"AIC"</code>. Defaults to <code>"AICc"</code>?</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_maxit">maxit</code></td>
<td>
<p>Vector containing the maximum number of iterations for the backfitting
algorithm with <code>maxit[1]</code> defining the iterations for the full model and <code>maxit[2]</code>
the iterations within each predictor. <code>maxit[2]</code> defaults to 1 if only one value is
specified.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_nu">nu</code></td>
<td>
<p>Vector of step lengths for parameter updates of one Newton-Raphson update for 
each predictor of the joint model.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_update.nu">update.nu</code></td>
<td>
<p>Should the updating step length be optimized in each iteration
of the backfitting algorithm? Uses <code>nu</code> as starting value if set to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_eps">eps</code></td>
<td>
<p>The relative convergence tolerance of the backfitting algorithm.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_alpha.eps">alpha.eps</code></td>
<td>
<p>The relative convergence tolerance of the backfitting algorithm
for predictor alpha.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_ic.eps">ic.eps</code></td>
<td>
<p>The relative convergence tolerance of the information criterion used, e.g.,
for smoothing variance selection.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_nback">nback</code></td>
<td>
<p>For computing <code>ic.eps</code>, how many iterations back should be included
when computing relative convergence tolerance of the information criterion.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_verbose">verbose</code></td>
<td>
<p>Print information during runtime of the algorithm.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_digits">digits</code></td>
<td>
<p>Set the digits for printing when <code>verbose = TRUE</code>.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_n.iter">n.iter</code></td>
<td>
<p>the number of MCMC iterations.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_burnin">burnin</code></td>
<td>
<p>the burn-in phase of the sampler, i.e., the number of starting samples that
should be removed.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_thin">thin</code></td>
<td>
<p>the thinning parameter for MCMC simulation. E.g., <code>thin = 10</code> means,
that only every 10th sampled parameter will be stored.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_step">step</code></td>
<td>
<p>How many times should algorithm runtime information be printed, divides <code>n.iter</code>.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_object">object</code></td>
<td>
<p>A <code>"bamlss"</code> object processed with the JM optimizer function
<code>opt_JM()</code> ans/or sampler function <code>sam_JM()</code> for which the survival plot
should be created.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_newdata">newdata</code></td>
<td>
<p>Dataset for which to create predictions. Not needed for conditional survival probabilities.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_type">type</code></td>
<td>
<p>Character string indicating which type of predictions to compute. <code>link</code> returns estimates
for all predictors with the respective link functions applied, <code>"parameter"</code> returns the estimates
for all pedictors, <code>"probabilities"</code> returns the survival probabilities conditional on the
survival up to the last longitudinal measurement, and <code>"cumhaz"</code> return the cumulative hazard
up to the survival time or for a time window after the last longitudinal measurement. If <code>type</code>
is set to <code>"loglik"</code>, the log-likelihood of the joint model is returned.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_id">id</code></td>
<td>
<p>Integer or character, that specifies the individual for which the plot should be created.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_dt">dt</code></td>
<td>
<p>The time window after the last observed measurement for which predictions should be computed. 
The default is <code>0.4 * max(obstime)</code> and <code>obstime</code> are the individual's longitudinal measurement times.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_steps">steps</code></td>
<td>
<p>Integer, the number of steps for which to evaluate the conditional survival probability 
up to <code>dt</code>.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_fun">FUN</code></td>
<td>
<p>A function that should be applied on the samples of predictors or
parameters, depending on argument <code>type</code>.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_cores">cores</code></td>
<td>
<p>Specifies the number of cores that should be used for prediction. Note that
this functionality is based on the <code><a href="parallel.html#topic+parallel">parallel</a></code> package.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_chunks">chunks</code></td>
<td>
<p>Should computations be split into <code>chunks</code>? Prediction is then processed
sequentially.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_points">points</code></td>
<td>
<p>Should longitudinal observations be added to the plot.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_rug">rug</code></td>
<td>
<p>Should longitudinal observed time points be added on the x-axis to the plot.</p>
</td></tr>
<tr><td><code id="jm_bamlss_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>We refer to the papers of Koehler et al. (2017a, b) for details on the flexible
additive joint model. In short, we model the hazard of subject <code class="reqn">i</code> an event at time
<code class="reqn">t</code> as
</p>
<p style="text-align: center;"><code class="reqn">h_{i}(t)= \exp [\eta_{\lambda i}(t)+
\eta_{\gamma i}+\eta_{\alpha i}(\eta_{\mu i}(t), t) ]</code>
</p>

<p>with predictor <code class="reqn">\eta_{\lambda}</code> for all survival covariates that are time-varying or have a
time-varying coefficient (including the log baseline hazard), predictor <code class="reqn">\eta_{\gamma}</code> for
baseline survival covariates, predictor <code class="reqn">\eta_{\alpha}</code> representing the potentially
time-varying or nonlinear association between the longitudinal marker <code class="reqn">\eta_{\mu}</code> and the hazard. The
longitudinal response <code class="reqn">y_{ij}</code> at time points <code class="reqn">t_{ij}</code> is modeled as
</p>
<p style="text-align: center;"><code class="reqn">y_{ij}=\eta_{\mu i}(t_{ij})+e_{ij}</code>
</p>
<p> with independent normal errors <code class="reqn">N(0, \exp[\eta_{\sigma i}(t_{ij})]^2)</code>. 
</p>
<p>Each predictor <code class="reqn">\eta_{ki}</code> is a structured additive predictor, i.e. a sum of functions of
covariates <code class="reqn">\eta_{ki} =  \sum_{m=1}^{M_k} f_{km}(\bm{x}_{ki})</code>. Each of these functions can be
modeled parametrically or using basis function evaluations from the smooth constructors in
<span class="pkg">mgcv</span> such as <code><a href="mgcv.html#topic+s">s</a></code>, <code><a href="mgcv.html#topic+te">te</a></code> and <code><a href="mgcv.html#topic+ti">ti</a></code> and can
include smooth time-varying, random or spatial effects. For the Bayesian estimation of these effects
we specify corresponding priors: For linear or parametric terms we use vague normal priors, smooth
and random effect terms are regularized by placing generic multivariate normal priors on the
coefficients and for anisotropic smooths, when multiple smoothing variance parameters are involved,
more complex prior are in place (cf. Koehler et al., 2017a). We use inverse Gamma
hyper-priors, i.e. IG(0.001, 0.001) to obtain an inverse Gamma full conditional for the variance
parameters. We estimate the posterior mode by maximizing the log-posterior of the model using a
Newton-Raphson procedure, the posterior mean is obtained via derivative-based Metropolis-Hastings
sampling. We recommend to use posterior mode estimates for a quick model assessment. In order to
draw correct inferences from the model, posterior mean estimates should be computed. 
We approximate integration in the survival part of the likelihood using trapezoidal rule. For
posterior mode estimation.
</p>
<p>A variety specifications of the association <code class="reqn">\eta_{\alpha i}(\eta_{\mu i}(t), t)</code> are possible with an 
important distinction between associations which are nonlinear in <code class="reqn">\eta_{\mu}</code>  for <code>nonlinear = TRUE</code> (Koehler et al. 2017b) or linear where <code class="reqn">\eta_{\alpha i}(\eta_{\mu i}(t), t) = \eta_{\alpha i}(t)\eta_{\mu i}(t)</code> for <code>nonlinear = FALSE</code> (Koehler et al. 2017a).
</p>


<h3>Note</h3>

<p>The indicator <code>nonlinear</code> for associations with are linear or nonlinear in <code class="reqn">\eta_{\mu}</code> was named <code>interaction]</code> in earlier versions stages of the development.</p>


<h3>References</h3>

<p>Koehler M, Umlauf N, Beyerlein, A., Winkler, C. Ziegler, A.-G., Greven S (2017). Flexible
Bayesian Additive Joint Models with an Application to Type 1 Diabetes Research.
<em>Biometrical Journal</em>. <a href="https://doi.org/10.1002/bimj.201600224">doi:10.1002/bimj.201600224</a>
</p>
<p>Meike Koehler, Nikolaus Umlauf, and Sonja Greven (2018). Nonlinear association structures in
flexible Bayesian additive joint models. <em>Statistics in Medicine</em>.
<a href="https://doi.org/10.1002/sim.7967">doi:10.1002/sim.7967</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bamlss">bamlss</a></code>, <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

set.seed(123)
## Simulate survival data
## with random intercepts/slopes and a linear effect of time,
## constant association alpha and no effect of the derivative
d &lt;- simJM(nsub = 200, long_setting = "linear", 
  alpha_setting = "constant",
  dalpha_setting = "zero", full = FALSE)

## Formula of the according joint model
f &lt;- list(
  Surv2(survtime, event, obs = y) ~ s(survtime, bs = "ps"),
  gamma ~ s(x1, bs = "ps"),
  mu ~ obstime + s(id, bs = "re") + 
    s(id, obstime, bs = "re"),
  sigma ~ 1,
  alpha ~ 1,
  dalpha ~ -1
)

## Joint model estimation
## jm_bamlss() sets the default optimizer and sampler function.
## First, posterior mode estimates are computed using function
## opt_JM(), afterwards the sampler sam_JM() is started.
b &lt;- bamlss(f, data = d, family = "jm",
           timevar = "obstime", idvar = "id")

## Plot estimated effects.
plot(b)

## Predict event probabilities for two individuals
## at 12 time units after their last longitudinal measurement.
## The event probability is conditional on their survival
## up to their last observed measurement.
p &lt;- predict(b, type = "probabilities", id = c(1, 2), dt = 12, FUN = c95)
print(p)

## Plot of survival probabilities and
## corresponding longitudinal effects
## for individual id.
jm_survplot(b, id = 3)
jm_survplot(b, id = 30)


## Simulate survival data
## with functional random intercepts and a nonlinear effect 
## of time, time-varying association alpha and no effect 
## of the derivative.
## Note: This specification is the simJM default.
d &lt;- simJM(nsub = 200, full = FALSE)

## Formula of the according joint model
## number of knots for the smooth nonlinear effect of time
klong &lt;- 8
f &lt;- list(
  Surv2(survtime, event, obs = y) ~ s(survtime, bs = "ps"),
  gamma ~ s(x1, bs = "ps"),
  mu ~ ti(id, bs = "re") + 
    ti(obstime, bs = "ps", k = klong) + 
    ti(id, obstime, bs = c("re", "ps"), 
      k = c(nlevels(d$id), klong)) + 
    s(x2, bs = "ps"),
  sigma ~ 1,
  alpha ~ s(survtime, bs = "ps"),
  dalpha ~ -1
)

## Estimating posterior mode only using opt_JM()
b_mode &lt;- bamlss(f, data = d, family = "jm",
                 timevar = "obstime", idvar = "id", 
                 sampler = FALSE)

## Estimating posterior means using sam_JM() 
##  with starting values generated from posterior mode 
b_mean &lt;- bamlss(f, data = d, family = "jm",
                 timevar = "obstime", idvar = "id", optimizer = FALSE,
                 start = parameters(b_mode), results = FALSE)

## Plot effects.
plot(b_mean, model = "alpha")



## Simulate survival data
## with functional random intercepts and an association nonlinear in mu
set.seed(234)
d &lt;- simJM(nsub = 300, long_setting = "functional", alpha_setting = "nonlinear", 
           nonlinear = TRUE, full = FALSE, probmiss = 0.9)

## Calculate longitudinal model to obtain starting values for mu
long_df &lt;- 7
f_start &lt;- y ~ ti(id, bs = "re") + ti(obstime, bs = "ps", k = long_df) + 
               ti(id, obstime, bs = c("re", "ps"), k = c(nlevels(d$id), long_df)) + 
               s(x2, bs = "ps")
b_start &lt;- bamlss(f_start, data = d, sampler = FALSE)
mu &lt;- predict(b_start)$mu

## Fit joint model with nonlinear association (nonlinear = TRUE)
f &lt;- list(
  Surv2(survtime, event, obs = y) ~ s(survtime, bs = "ps"),
  gamma ~ x1,
  mu ~ ti(id, bs = "re") + ti(obstime, bs = "ps", k = long_df) + 
       ti(id, obstime, bs = c("re", "ps"), k = c(nlevels(d$id), long_df)) + 
       s(x2, bs = "ps"),
  sigma ~ 1,
  alpha ~ 1,
  dalpha ~ -1
)
b &lt;- bamlss(f, data = d, family = "jm", timevar = "obstime", idvar = "id", 
            nonlinear = TRUE, start_mu = mu, 
            n.iter = 6000, burnin = 2000, thin = 2)
plot(b)
samplestats(b$samples)

## End(Not run)
</code></pre>

<hr>
<h2 id='la'>Lasso Smooth Constructor</h2><span id='topic+la'></span><span id='topic+lasso'></span><span id='topic+opt_lasso'></span><span id='topic+lasso_plot'></span><span id='topic+lasso_stop'></span><span id='topic+lasso_coef'></span><span id='topic+lasso_transform'></span>

<h3>Description</h3>

<p>Smooth constructors and optimizer for Lasso penalization with <code><a href="#topic+bamlss">bamlss</a></code>. The
penalization is based on a Taylor series approximation of the Lasso penalty.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Smooth constructor function.
la(formula, type = c("single", "multiple"), ...)

## Single Lasso smoothing parameter optimizer.
opt_lasso(x, y, start = NULL, adaptive = TRUE, lower = 0.001, upper = 1000,
  nlambda = 100, lambda = NULL,  multiple = FALSE, verbose = TRUE,
  digits = 4, flush = TRUE, nu = NULL, stop.nu = NULL,
  ridge = .Machine$double.eps^0.5, zeromodel = NULL, ...)

lasso(x, y, start = NULL, adaptive = TRUE, lower = 0.001, upper = 1000,
  nlambda = 100, lambda = NULL,  multiple = FALSE, verbose = TRUE,
  digits = 4, flush = TRUE, nu = NULL, stop.nu = NULL,
  ridge = .Machine$double.eps^0.5, zeromodel = NULL, ...)

## Lasso transformation function to set
## adaptive weights from an unpenalized model.
lasso_transform(x, zeromodel, nobs = NULL, ...)

## Plotting function for opt_lasso() optimizer.
lasso_plot(x, which = c("criterion", "parameters"),
  spar = TRUE, model = NULL, name = NULL, mstop = NULL,
  retrans = FALSE, color = NULL, show.lambda = TRUE,
  labels = NULL, digits = 2, ...)

## Extract optimum stopping iteration for opt_lasso() optimizer.
## Based on the minimum of the information criterion.
lasso_stop(x)

## Extract retransformed Lasso coefficients.
lasso_coef(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="la_+3A_formula">formula</code></td>
<td>
<p>A formula like <code>~ x1 + x2 + ... + xk</code> of variables which should be
penalized with Lasso.</p>
</td></tr>
<tr><td><code id="la_+3A_type">type</code></td>
<td>
<p>Should one single penalty parameter be used or multiple parameters, one for each
covariate in <code>formula</code>.</p>
</td></tr>
<tr><td><code id="la_+3A_x">x</code></td>
<td>
<p>For function <code>opt_lasso()</code> and <code>lasso_transform()</code> the <code>x</code> list, as returned
from function <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>, holding all model matrices and other information that
is used for fitting the model. For the plotting function and
<code>lasso_stop()</code>/<code>lasso_coef()</code> the
corresponding <code><a href="#topic+bamlss">bamlss</a></code> object fitted with the <code>opt_lasso()</code> optimizer.</p>
</td></tr>
<tr><td><code id="la_+3A_y">y</code></td>
<td>
<p>The model response, as returned from function <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>.</p>
</td></tr>
<tr><td><code id="la_+3A_start">start</code></td>
<td>
<p>A vector of starting values. Note, Lasso smoothing parameters will be dropped.</p>
</td></tr>
<tr><td><code id="la_+3A_adaptive">adaptive</code></td>
<td>
<p>Should adaptive weights be used for fused Lasso terms?</p>
</td></tr>
<tr><td><code id="la_+3A_lower">lower</code></td>
<td>
<p>Numeric. The minimum lambda value.</p>
</td></tr>
<tr><td><code id="la_+3A_upper">upper</code></td>
<td>
<p>Numeric. The maximum lambda value.</p>
</td></tr>
<tr><td><code id="la_+3A_nlambda">nlambda</code></td>
<td>
<p>Integer. The number of smoothing parameters for which coefficients should be
estimated, i.e., the vector of smoothing parameters is build up as a sequence from
<code>lower</code> to <code>upper</code> with length <code>nlambda</code>.</p>
</td></tr>
<tr><td><code id="la_+3A_lambda">lambda</code></td>
<td>
<p>Numeric. A sequence/vector of lambda parameters that should be used.</p>
</td></tr>
<tr><td><code id="la_+3A_multiple">multiple</code></td>
<td>
<p>Logical. Should the lambda grid be exapnded to search for multiple lambdas, one for
each distributional parameter.</p>
</td></tr>
<tr><td><code id="la_+3A_verbose">verbose</code></td>
<td>
<p>Print information during runtime of the algorithm.</p>
</td></tr>
<tr><td><code id="la_+3A_digits">digits</code></td>
<td>
<p>Set the digits for printing when <code>verbose = TRUE</code>. If the optimum lambda value
is plotted, the number of decimal decimal places to be used within <code>lasso_plot()</code>.</p>
</td></tr>
<tr><td><code id="la_+3A_flush">flush</code></td>
<td>
<p>use <code><a href="utils.html#topic+flush.console">flush.console</a></code> for displaying the current output in the console.</p>
</td></tr>
<tr><td><code id="la_+3A_nu">nu</code></td>
<td>
<p>Numeric or logical. Defines the step length for parameter updating of a model term,
useful when the algorithm encounters convergence problems. If <code>nu = TRUE</code> the step length
parameter is optimized for each model term in each iteration of the backfitting algorithm.</p>
</td></tr>
<tr><td><code id="la_+3A_stop.nu">stop.nu</code></td>
<td>
<p>Integer. Should step length reduction be stopped after <code>stop.nu</code> iterations
of the Lasso algorithm?</p>
</td></tr>
<tr><td><code id="la_+3A_ridge">ridge</code></td>
<td>
<p>A ridge penalty parameter that should be used when finding adaptive weights, i.e.,
parameters from an unpenalized model. The ridge penalty is used to stabilize the estimation
in complex models.</p>
</td></tr>
<tr><td><code id="la_+3A_zeromodel">zeromodel</code></td>
<td>
<p>A model containing the unpenalized parameters, e.g., for each <code>la()</code>
terms one can place a simple ridge penalty with <code>la(x, ridge = TRUE, sp = 0.1)</code>. This
way it is possible to find the unpenalized parameters that can be used as adaptive
weights for fusion penalties.</p>
</td></tr>
<tr><td><code id="la_+3A_nobs">nobs</code></td>
<td>
<p>Integer, number of observations of the data used for modeling. If not supplied
<code>nobs</code> is taken from the number of rows from the model term design matrices.</p>
</td></tr>
<tr><td><code id="la_+3A_which">which</code></td>
<td>
<p>Which of the two provided plots should be created, character or integer <code>1</code> and <code>2</code>.</p>
</td></tr>
<tr><td><code id="la_+3A_spar">spar</code></td>
<td>
<p>Should graphical parameters be set by the plotting function?</p>
</td></tr>
<tr><td><code id="la_+3A_model">model</code></td>
<td>
<p>Character selecting for which model the plot shpuld be created.</p>
</td></tr>
<tr><td><code id="la_+3A_name">name</code></td>
<td>
<p>Character, the name of the coefficient group that should be plotted. Note that
the string provided in <code>name</code> will be removed from the labels on the 4th axis.</p>
</td></tr>
<tr><td><code id="la_+3A_mstop">mstop</code></td>
<td>
<p>Integer vector, defines the path length to be plotted.</p>
</td></tr>
<tr><td><code id="la_+3A_retrans">retrans</code></td>
<td>
<p>Logical, should coefficients be re-transformed before plotting?</p>
</td></tr>
<tr><td><code id="la_+3A_color">color</code></td>
<td>
<p>Colors or color function that creates colors for the group paths.</p>
</td></tr>
<tr><td><code id="la_+3A_show.lambda">show.lambda</code></td>
<td>
<p>Logical. Should the optimum value of the penalty parameter lambda be shown?</p>
</td></tr>
<tr><td><code id="la_+3A_labels">labels</code></td>
<td>
<p>A character string of labels that should be used on the 4 axis.</p>
</td></tr>
<tr><td><code id="la_+3A_...">...</code></td>
<td>
<p>Arguments passed to the subsequent smooth constructor function.
<code>lambda</code> controls the starting value of the penalty parameter, <code>const</code> the constant
that is added within the penalty approximation. Moreover, <code>fuse = 1</code> enforces nominal
fusion of categorical variables and <code>fuse = 2</code> ordered fusion within <code>la()</code> Note that
<code>la()</code> terms with and without fusion should not be mixed when using the <code>opt_lasso()</code>
optimizer function.
For the optimizer <code>opt_lasso()</code> arguments passed to function <code><a href="#topic+bfit">bfit</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For function <code>la()</code>, similar to function <code><a href="mgcv.html#topic+s">s</a></code> a simple smooth
specification object.
</p>
<p>For function <code>opt_lasso()</code> a list containing the following objects:
</p>
<table>
<tr><td><code>fitted.values</code></td>
<td>
<p>A named list of the fitted values based on the last lasso iteration
of the modeled parameters of the selected distribution.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>A matrix, each row corresponds to the parameter values of one boosting iteration.</p>
</td></tr>
<tr><td><code>lasso.stats</code></td>
<td>
<p>A matrix containing information about the log-likelihood, log-posterior
and the information criterion for each lambda.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Andreas Groll, Julien Hambuckers, Thomas Kneib, and Nikolaus Umlauf (2019). Lasso-type penalization in
the framework of generalized additive models for location, scale and shape.
<em>Computational Statistics &amp; Data Analysis</em>.
<a href="https://doi.org/10.1016/j.csda.2019.06.005">doi:10.1016/j.csda.2019.06.005</a>
</p>
<p>Oelker Margreth-Ruth and Tutz Gerhard (2015). A uniform framework for combination of
penalties in generalized structured models. <em>Adv Data Anal Classif</em>.
<a href="https://doi.org/10.1007/s11634-015-0205-y">doi:10.1007/s11634-015-0205-y</a>
</p>


<h3>See Also</h3>

<p><code><a href="mgcv.html#topic+s">s</a></code>, <code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ## Simulated fusion Lasso example.
bmu &lt;- c(0,0,0,2,2,2,4,4,4)
bsigma &lt;- c(0,0,0,-2,-2,-2,-1,-1,-1)
id &lt;- factor(sort(rep(1:length(bmu), length.out = 300)))

## Response.
set.seed(123)
y &lt;- bmu[id] + rnorm(length(id), sd = exp(bsigma[id]))

## Estimate model:
## fuse=1 -&gt; nominal fusion,
## fuse=2 -&gt; ordinal fusion,
## first, unpenalized model to be used for adaptive fusion weights.
f &lt;- list(y ~ la(id,fuse=2,fx=TRUE), sigma ~ la(id,fuse=1,fx=TRUE))
b0 &lt;- bamlss(f, sampler = FALSE)

## Model with single lambda parameter.
f &lt;- list(y ~ la(id,fuse=2), sigma ~ la(id,fuse=1))
b1 &lt;- bamlss(f, sampler = FALSE, optimizer = opt_lasso,
  criterion = "BIC", zeromodel = b0)

## Plot information criterion and coefficient paths.
lasso_plot(b1, which = 1)
lasso_plot(b1, which = 2)
lasso_plot(b1, which = 2, model = "mu", name = "mu.s.la(id).id")
lasso_plot(b1, which = 2, model = "sigma", name = "sigma.s.la(id).id")

## Extract coefficients for optimum Lasso parameter.
coef(b1, mstop = lasso_stop(b1))

## Predict with optimum Lasso parameter.
p1 &lt;- predict(b1, mstop = lasso_stop(b1))

## Full MCMC, needs lasso_transform() to assign the
## adaptive weights from unpenalized model b0.
b2 &lt;- bamlss(f, optimizer = FALSE, transform = lasso_transform,
  zeromodel = b0, nobs = length(y), start = coef(b1, mstop = lasso_stop(b1)),
  n.iter = 4000, burnin = 1000)
summary(b2)
plot(b2)

ci &lt;- confint(b2, model = "mu", pterms = FALSE, sterms = TRUE)
lasso_plot(b1, which = 2, model = "mu", name = "mu.s.la(id).id", spar = FALSE)
for(i in 1:8) {
  abline(h = ci[i, 1], lty = 2, col = "red")
  abline(h = ci[i, 2], lty = 2, col = "red")
}

## End(Not run)
</code></pre>

<hr>
<h2 id='lin'>Linear Effects for BAMLSS</h2><span id='topic+lin'></span><span id='topic+smooth.construct.linear.smooth.spec'></span>

<h3>Description</h3>

<p>This smooth constructor implements simple linear effects. The columns of the design matrix
are automatically scaled. The main advantage of this constructor is speed when used in
the BAMLSS boosting algorithm <code><a href="#topic+boost">boost</a></code>. Optionally, a ridge penalty can be
added, please see the example.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Linear smooth constructor.
lin(...)

## For mgcv.
## S3 method for class 'linear.smooth.spec'
smooth.construct(object, data, knots, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lin_+3A_...">...</code></td>
<td>
<p>For function <code>lin()</code> a formula of the type <code>~x1+x2+x3</code> that specifies
the covariates that should be modeled.</p>
</td></tr>
<tr><td><code id="lin_+3A_object">object</code>, <code id="lin_+3A_data">data</code>, <code id="lin_+3A_knots">knots</code></td>
<td>
<p>See <code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function <code>lin()</code>, similar to function <code><a href="mgcv.html#topic+s">s</a></code> a simple smooth specification
object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bamlss">bamlss</a></code>, <code><a href="#topic+predict.bamlss">predict.bamlss</a></code>, <code><a href="#topic+bfit">bfit</a></code>, <code><a href="#topic+boost">boost</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ## Simulate data.
set.seed(123)
d &lt;- GAMart()

## Estimate model.
f &lt;- num ~ lin(~x1+x2+x3+fac,ridge=TRUE)

b &lt;- bamlss(f, data = d)

summary(b)

## End(Not run)
</code></pre>

<hr>
<h2 id='LondonFire'>London Fire Data</h2><span id='topic+LondonFire'></span><span id='topic+LondonBoroughs'></span><span id='topic+LondonBoundaries'></span><span id='topic+LondonFStations'></span>

<h3>Description</h3>

<p>Provides the compiled dwelling fire data of London in 2015. The data is provided
as a <code><a href="sp.html#topic+SpatialPointsDataFrame">SpatialPointsDataFrame</a></code> in object <code>LondonFire</code>. In addition
the boundary and borough information is provided in objects <code>LondonBoundaries</code> and
<code>LondonBoroughs</code>. Locations of all fire stations in London of 2015 are provided in
object <code>LondonFStations</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("LondonFire")</code></pre>


<h3>Format</h3>

<p>The <code>LondonFire</code> data contains the following variables:
</p>

<dl>
<dt>arrivaltime:</dt><dd><p>Numeric, the time after the emergency call until the first fire engine arrived.</p>
</dd>
<dt>daytime:</dt><dd><p>Numeric, The time of day at which the emergency call was received.</p>
</dd>
<dt>fsintens:</dt><dd><p>Numeric, the fire station intensity at the location of the fire scene. The
intensity is measured using a kernel density estimate of the <code>LondonFStations</code> using the
<span class="pkg">spatstat</span> package.</p>
</dd>
</dl>



<h3>References</h3>

<p>London Fire (2015). London Fire Brigade Incident Records.
<em>London Data Store</em>, UK Open Government Licence (OGL v2).
<a href="https://data.london.gov.uk/dataset/london-fire-brigade-incident-records">https://data.london.gov.uk/dataset/london-fire-brigade-incident-records</a>
</p>
<p>London Boroughs/Boundaries (2015). Statistical GIS Boundary Files for London.
<em>London Data Store</em>, UK Open Government Licence (OGL v2).
<a href="https://data.london.gov.uk/dataset/statistical-gis-boundary-files-london">https://data.london.gov.uk/dataset/statistical-gis-boundary-files-london</a>
</p>
<p>London Fire Stations (2015). <em>London Fire Brigade</em>,
<code>https://www.london-fire.gov.uk/</code>.
(old url <code>http://www.london-fire.gov.uk/A-ZFireStations.asp</code>)
</p>
<p>Taylor BM (2016). Spatial Modelling of Emergency Service Response Times.
<em>Journal of the Royal Statistical Society</em>: Series A (Statistics in Society),
<b>180</b>(2), 433&ndash;453. <a href="https://doi.org/10.1111/rssa.12192">doi:10.1111/rssa.12192</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("LondonFire")
plot(LondonFire, col = "red")
plot(LondonFStations, col = "blue", cex = 1.5, pch = 16, add = TRUE)
plot(LondonBoroughs, lwd = 0.5, add = TRUE)
plot(LondonBoundaries, add = TRUE, lwd = 1.5)
head(LondonFire@data)
</code></pre>

<hr>
<h2 id='make_formula'>Formula Generator</h2><span id='topic+make_formula'></span>

<h3>Description</h3>

<p>Generate a formula for a MVN Cholesky model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_formula(formula, type = "basic")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_formula_+3A_formula">formula</code></td>
<td>
<p>formula.</p>
</td></tr>
<tr><td><code id="make_formula_+3A_type">type</code></td>
<td>
<p>character. Type of Cholesky decomposition.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a helper to generate a formula for a bamlss model with <code>k</code>-dimensional
multi-variate normal distribution and Cholesky decomposed variance-covariance matrix.
It is helpful if one formula should be used for means, another for all diagonal
entries of the Cholesky factor, and a third one for all lower triangular entries
of the Cholesky factor.
The left hand side has <code>k</code> elements separated by <code>|</code>.
The right hand side has one to three elements separated by <code>|</code> specifying
the formulas used for all means, diagonal entries of the Cholesky factor and
lower triangular entries of the Cholesky factor, respectively.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvnchol_bamlss">mvnchol_bamlss</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>f &lt;- O | C | E | A | N ~ s(x1) + s(x2) | s(y) | z 
f2 &lt;- make_formula(f)
f2
</code></pre>

<hr>
<h2 id='model.frame.bamlss'>
BAMLSS Model Frame
</h2><span id='topic+model.frame.bamlss'></span><span id='topic+model.frame.bamlss.frame'></span><span id='topic+bamlss.model.frame'></span>

<h3>Description</h3>

<p>Extracts the model frame of a <code><a href="#topic+bamlss">bamlss</a></code> or <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bamlss'
model.frame(formula, ...)

## S3 method for class 'bamlss.frame'
model.frame(formula, ...)

## Internal helper function for creating
## the model frame.
bamlss.model.frame(formula, data, family = gaussian_bamlss(),
  weights = NULL, subset = NULL, offset = NULL,
  na.action = na.omit, specials = NULL, contrasts.arg = NULL,
  drop.unused.levels = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.frame.bamlss_+3A_formula">formula</code></td>
<td>
<p>An object of class <code>"bamlss"</code> or <code>"bamlss.frame"</code>.</p>
</td></tr>
<tr><td><code id="model.frame.bamlss_+3A_data">data</code></td>
<td>
<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> or <code><a href="base.html#topic+list">list</a></code> containing the model
response variable(s) and covariates specified in the <code>formula</code>.
By default the variables are taken from <code>environment(formula)</code>.</p>
</td></tr>
<tr><td><code id="model.frame.bamlss_+3A_family">family</code></td>
<td>
<p>A <code><a href="#topic+bamlss.family">bamlss.family</a></code> object, see function <code><a href="#topic+bamlss">bamlss</a></code>.</p>
</td></tr>
<tr><td><code id="model.frame.bamlss_+3A_weights">weights</code></td>
<td>
<p>Prior weights on the data.</p>
</td></tr>
<tr><td><code id="model.frame.bamlss_+3A_subset">subset</code></td>
<td>
<p>An optional vector specifying a subset of observations to be
used in the fitting process.</p>
</td></tr>
<tr><td><code id="model.frame.bamlss_+3A_offset">offset</code></td>
<td>
<p>Can be used to supply model offsets for use in fitting.</p>
</td></tr>
<tr><td><code id="model.frame.bamlss_+3A_na.action">na.action</code></td>
<td>
<p>A function which indicates what should happen when the data
contain <code>NA</code>'s. The default is set by the <code>na.action</code>
setting of <code><a href="base.html#topic+options">options</a></code>, and is <code><a href="stats.html#topic+na.omit">na.omit</a></code> if set to <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="model.frame.bamlss_+3A_specials">specials</code></td>
<td>
<p>Special function in formulas, see <code><a href="stats.html#topic+terms.object">terms.object</a></code>.</p>
</td></tr>
<tr><td><code id="model.frame.bamlss_+3A_contrasts.arg">contrasts.arg</code></td>
<td>
<p>An optional list. See the <code>contrasts.arg</code> of 
<code><a href="stats.html#topic+model.matrix.default">model.matrix.default</a></code>.</p>
</td></tr>
<tr><td><code id="model.frame.bamlss_+3A_drop.unused.levels">drop.unused.levels</code></td>
<td>
<p>Should factors have unused levels dropped?</p>
</td></tr>
<tr><td><code id="model.frame.bamlss_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code>bamlss.model.frame()</code> and others.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code><a href="base.html#topic+data.frame">data.frame</a></code> containing the variables used for modeling
with function <code><a href="#topic+bamlss">bamlss</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bamlss">bamlss</a></code>, <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>,
<code><a href="#topic+model.matrix.bamlss.frame">model.matrix.bamlss.frame</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ## Generate some data.
d &lt;- GAMart()

## Model formula.
f &lt;- list(
  log(pnum) ~ s(x1) + log(x2),
  sigma ~ s(x3)
)

## Estimate model.
b &lt;- bamlss(f, data = d)

## Extract the model frame.
head(model.frame(b))

## End(Not run)
</code></pre>

<hr>
<h2 id='model.matrix.bamlss.frame'>
Construct/Extract BAMLSS Design Matrices
</h2><span id='topic+model.matrix.bamlss.frame'></span><span id='topic+model.matrix.bamlss.formula'></span><span id='topic+model.matrix.bamlss.terms'></span>

<h3>Description</h3>

<p>The function creates design (or model) matrices for BAMLSS, i.e., for
each parameter of a <code><a href="#topic+bamlss.family">bamlss.family</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bamlss.frame'
model.matrix(object, data = NULL, model = NULL,
  drop = TRUE, scale.x = FALSE, ...)

## S3 method for class 'bamlss.formula'
model.matrix(object, data = NULL, model = NULL,
  drop = TRUE, scale.x = FALSE, ...)

## S3 method for class 'bamlss.terms'
model.matrix(object, data = NULL, model = NULL,
  drop = TRUE, scale.x = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="model.matrix.bamlss.frame_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>, <code><a href="#topic+bamlss.formula">bamlss.formula</a></code> or
<code><a href="#topic+terms.bamlss">terms.bamlss</a></code> object.</p>
</td></tr>
<tr><td><code id="model.matrix.bamlss.frame_+3A_data">data</code></td>
<td>
<p>A data frame or list.</p>
</td></tr>
<tr><td><code id="model.matrix.bamlss.frame_+3A_model">model</code></td>
<td>
<p>Character or integer, specifies the model for which design matrices should be returned.</p>
</td></tr>
<tr><td><code id="model.matrix.bamlss.frame_+3A_drop">drop</code></td>
<td>
<p>If model matrices for only one <code>model</code> are returned, the list structure is dropped.</p>
</td></tr>
<tr><td><code id="model.matrix.bamlss.frame_+3A_scale.x">scale.x</code></td>
<td>
<p>Logical, should the model matrices of the linear parts be scaled?</p>
</td></tr>
<tr><td><code id="model.matrix.bamlss.frame_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on the type of model a named list of model matrices or a single
model matrix.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+model.matrix">model.matrix</a></code>, <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>,
<code><a href="#topic+bamlss.formula">bamlss.formula</a></code>, <code><a href="#topic+terms.bamlss">terms.bamlss</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate some data.
d &lt;- GAMart()

## Model formula.
f &lt;- list(
  num ~ x1 + x2 + id,
  sigma ~ x3 + fac + lon + lat
)

## Create a "bamlss.frame".
bf &lt;- bamlss.frame(f, data = d)

## Get the model matrices.
X &lt;- model.matrix(bf)
head(X$sigma)

## Same with "bamlss.formula".
X &lt;- model.matrix(bamlss.formula(f), data = d)
head(X$sigma)
</code></pre>

<hr>
<h2 id='mvn_chol'>Cholesky MVN</h2><span id='topic+mvn_chol'></span>

<h3>Description</h3>

<p>BAMLSS Family for MVN with Cholesky Parameterization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvn_chol(k = 2L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvn_chol_+3A_k">k</code></td>
<td>
<p>integer. The dimension of the multivariate distribution.</p>
</td></tr>
<tr><td><code id="mvn_chol_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a prototype implementation of a BAMLSS family that models
a multivariate Normal (Gaussian) distribution by a Cholesky
decomposition of the covariance matrix.
</p>


<h3>Value</h3>

<p>a bamlss family.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvnchol_bamlss">mvnchol_bamlss</a></code>
</p>

<hr>
<h2 id='mvn_modchol'>Modified Cholesky MVN</h2><span id='topic+mvn_modchol'></span>

<h3>Description</h3>

<p>BAMLSS Family for MVN with Modified Cholesky Parameterization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvn_modchol(k = 2L, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvn_modchol_+3A_k">k</code></td>
<td>
<p>integer. The dimension of the multivariate distribution.</p>
</td></tr>
<tr><td><code id="mvn_modchol_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a prototype implementation of a BAMLSS family that models
a multivariate Normal (Gaussian) distribution by a modified Cholesky
decomposition of the covariance matrix.
</p>


<h3>Value</h3>

<p>a bamlss family.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvnchol_bamlss">mvnchol_bamlss</a></code>
</p>

<hr>
<h2 id='mvnchol_bamlss'>Cholesky MVN</h2><span id='topic+mvnchol_bamlss'></span>

<h3>Description</h3>

<p>BAMLSS Families for MVN with Cholesky Parameterization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvnchol_bamlss(k, type = c("basic", "modified", "chol"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mvnchol_bamlss_+3A_k">k</code></td>
<td>
<p>integer. The dimension of the multivariate distribution.</p>
</td></tr>
<tr><td><code id="mvnchol_bamlss_+3A_type">type</code></td>
<td>
<p>character. Choose <code>"basic"</code> Cholesky decomposition or <code>"modified"</code>
Cholesky decomposition. (For back compatibility <code>"chol"</code> is identical to <code>"basic"</code>.)</p>
</td></tr>
<tr><td><code id="mvnchol_bamlss_+3A_...">...</code></td>
<td>
<p>not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>BAMLSS families that models a multivariate Normal (Gaussian)
distribution by (modified) Cholesky decomposition of the covariance
matrix.
</p>
<p>For examples see <code><a href="#topic+TempIbk">TempIbk</a></code>.
</p>


<h3>Value</h3>

<p>a bamlss family.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+simdata">simdata</a></code>, <code><a href="#topic+TempIbk">TempIbk</a></code>
</p>

<hr>
<h2 id='n'>Neural Networks for BAMLSS</h2><span id='topic+n'></span><span id='topic+n.weights'></span><span id='topic+make_weights'></span><span id='topic+predictn'></span>

<h3>Description</h3>

<p>This smooth constructor implements single hidden layer neural networks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## The neural network smooth constructor.
n(..., k = 10, type = 2)

## Initialize weights.
n.weights(nodes, k, r = NULL, s = NULL,
  type = c("sigmoid", "gauss", "softplus", "cos", "sin"),
  x = NULL, ...)

## Second weights initializer, internally calls n.weights.
make_weights(object, data, dropout = 0.2)

## Boosted neural net predictions.
predictn(object, newdata, model = NULL,
  mstop = NULL, type = c("link", "parameter"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="n_+3A_...">...</code></td>
<td>
<p>For function <code>n()</code> a formula of the type <code>~x1+x2+x3</code> that specifies
the covariates that should be modeled by the neural network. For function <code>predictn()</code>,
arguments to be passed to <code><a href="#topic+predict.bamlss">predict.bamlss</a></code>.</p>
</td></tr>
<tr><td><code id="n_+3A_k">k</code></td>
<td>
<p>For function <code>n()</code>, the number of hidden nodes of the network. Note that one can set
an argument <code>split = TRUE</code> to split up the neural network into, e.g., <code>nsplit = 5</code>
parts with <code>k</code> nodes each. For function <code>n.weights()</code>, argument <code>k</code>
is the number of input variables of the network (number of covariates).</p>
</td></tr>
<tr><td><code id="n_+3A_type">type</code></td>
<td>
<p>Integer. Type <code>1</code> fits a complete network in each boosting iteration, <code>type = 2</code> selects
the best fitting node in each boosting iteration. for function <code>n.weights()</code>, the type of
activation function that should be used. For function <code>predictn()</code>, the type of prediction
that should be computed.</p>
</td></tr>
<tr><td><code id="n_+3A_nodes">nodes</code></td>
<td>
<p>Number of nodes for each layer, i.e., can also be a vector.</p>
</td></tr>
<tr><td><code id="n_+3A_r">r</code>, <code id="n_+3A_s">s</code></td>
<td>
<p>Parameters controlling the shape of the activation functions.</p>
</td></tr>
<tr><td><code id="n_+3A_x">x</code></td>
<td>
<p>A scaled covariate matrix, the data will be used to identify the range of the weights.</p>
</td></tr>
<tr><td><code id="n_+3A_object">object</code>, <code id="n_+3A_data">data</code></td>
<td>
<p>See <code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code>. For function <code>predictn()</code>,
a boosted <code>"bamlss"</code> object.</p>
</td></tr>
<tr><td><code id="n_+3A_dropout">dropout</code></td>
<td>
<p>The fraction of inner weights that should be set to zero.</p>
</td></tr>
<tr><td><code id="n_+3A_newdata">newdata</code></td>
<td>
<p>The data frame that should be used for prediction.</p>
</td></tr>
<tr><td><code id="n_+3A_model">model</code></td>
<td>
<p>For which parameter of the distribution predictions should be computed.</p>
</td></tr>
<tr><td><code id="n_+3A_mstop">mstop</code></td>
<td>
<p>The stopping iteration for which predictions should be computed. The default
is to return a matrix of predictions, each column represents the prediction of one
boosting iteration.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function <code>n()</code>, similar to function <code><a href="mgcv.html#topic+s">s</a></code> a simple smooth specification
object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bamlss">bamlss</a></code>, <code><a href="#topic+predict.bamlss">predict.bamlss</a></code>, <code><a href="#topic+bfit">bfit</a></code>, <code><a href="#topic+boost">boost</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## ... coming soon ...!
</code></pre>

<hr>
<h2 id='neighbormatrix'>
Compute a Neighborhood Matrix from Spatial Polygons
</h2><span id='topic+neighbormatrix'></span><span id='topic+plotneighbors'></span>

<h3>Description</h3>

<p>The function takes a <code><a href="sp.html#topic+SpatialPolygonsDataFrame">SpatialPolygonsDataFrame</a></code> and computes
the neighbor penalty matrix that can be used to fit a Markov
random field, e.g., using the smooth constructor
<code><a href="mgcv.html#topic+smooth.construct.mrf.smooth.spec">smooth.construct.mrf.smooth.spec</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Compute the neighborhood matrix.
neighbormatrix(x, type = c("boundary", "dist", "delaunay", "knear"),
  k = 1, id = NULL, nb = FALSE, names = NULL, ...)

## Plot neighborhood structure.
plotneighbors(x, add = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="neighbormatrix_+3A_x">x</code></td>
<td>
<p>An object of class <code>"SpatialPolygons"</code> or <code>"SpatialPolygonsDataFrame"</code>.</p>
</td></tr>
<tr><td><code id="neighbormatrix_+3A_type">type</code></td>
<td>
<p>Which type of neighborhood structure should be used,
<code>"boundary"</code> uses <code><a href="spdep.html#topic+poly2nb">poly2nb</a></code>, <code>"dist"</code>
uses function <code><a href="spdep.html#topic+dnearneigh">dnearneigh</a></code>, <code>"delaunay"</code>
uses function <code><a href="spdep.html#topic+tri2nb">tri2nb</a></code> and option
<code>"knear"</code> applies function <code><a href="spdep.html#topic+knn2nb">knn2nb</a></code>.</p>
</td></tr>
<tr><td><code id="neighbormatrix_+3A_k">k</code></td>
<td>
<p>For <code>type = "knear"</code>, specifies number of nearest neighbors.</p>
</td></tr>
<tr><td><code id="neighbormatrix_+3A_id">id</code></td>
<td>
<p>An identifier variable for which the penalty matrix should be computed.</p>
</td></tr>
<tr><td><code id="neighbormatrix_+3A_nb">nb</code></td>
<td>
<p>Should only the neighborhood object be returned.</p>
</td></tr>
<tr><td><code id="neighbormatrix_+3A_names">names</code></td>
<td>
<p>Specifies the column where the regions names are provided in the data
slot in the <code>"SpatialPolygonsDataFrame"</code></p>
</td></tr>
<tr><td><code id="neighbormatrix_+3A_add">add</code></td>
<td>
<p>Should the neighborhood structure be added to an existing plot?</p>
</td></tr>
<tr><td><code id="neighbormatrix_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to function <code><a href="spdep.html#topic+poly2nb">poly2nb</a></code>,
<code><a href="spdep.html#topic+dnearneigh">dnearneigh</a></code>, <code><a href="spdep.html#topic+tri2nb">tri2nb</a></code> or
<code><a href="spdep.html#topic+knn2nb">knn2nb</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="mgcv.html#topic+smooth.construct.mrf.smooth.spec">smooth.construct.mrf.smooth.spec</a></code>, <code><a href="spdep.html#topic+dnearneigh">dnearneigh</a></code>,
<code><a href="spdep.html#topic+tri2nb">tri2nb</a></code>, <code><a href="spdep.html#topic+knn2nb">knn2nb</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: data("LondonFire")

## Compute polygon boundary based
## neighborhood matrix.
nm &lt;- neighbormatrix(LondonBoroughs)
print(nm)

## Plot neighborhood structures.
plotneighbors(LondonBoroughs)
plotneighbors(LondonBoroughs, type = "delaunay")
plotneighbors(LondonBoroughs, type = "dist", d1 = 0, d2 = 0.15)

## End(Not run)</code></pre>

<hr>
<h2 id='opt_bbfit'>Batchwise Backfitting</h2><span id='topic+bbfit'></span><span id='topic+opt_bbfit'></span><span id='topic+bbfitp'></span><span id='topic+opt_bbfitp'></span><span id='topic+contribplot'></span>

<h3>Description</h3>

<p>Batchwise backfitting estimation engine for GAMLSS using very large data sets.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Batchwise backfitting engine.
opt_bbfit(x, y, family, shuffle = TRUE, start = NULL, offset = NULL,
  epochs = 1, nbatch = 10, verbose = TRUE, ...)

bbfit(x, y, family, shuffle = TRUE, start = NULL, offset = NULL,
  epochs = 1, nbatch = 10, verbose = TRUE, ...)

## Parallel version.
opt_bbfitp(x, y, family, mc.cores = 1, ...)

## Loglik contribution plot.
contribplot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opt_bbfit_+3A_x">x</code></td>
<td>
<p>For function <code>bfit()</code> the <code>x</code> list, as returned from function
<code><a href="#topic+bamlss.frame">bamlss.frame</a></code>, holding all model matrices and other information that is used for
fitting the model. For the updating functions an object as returned from function
<code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code> or <code><a href="mgcv.html#topic+smoothCon">smoothCon</a></code>. For function
<code>contribplot()</code>, a <code>"bamlss"</code> object using <code>bbfit()</code> with argument
<code>select = TRUE</code>.</p>
</td></tr>
<tr><td><code id="opt_bbfit_+3A_y">y</code></td>
<td>
<p>The model response, as returned from function <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>.</p>
</td></tr>
<tr><td><code id="opt_bbfit_+3A_family">family</code></td>
<td>
<p>A <span class="pkg">bamlss</span> family object, see <code><a href="#topic+family.bamlss">family.bamlss</a></code>.</p>
</td></tr>
<tr><td><code id="opt_bbfit_+3A_shuffle">shuffle</code></td>
<td>
<p>Should observations be shuffled?</p>
</td></tr>
<tr><td><code id="opt_bbfit_+3A_start">start</code></td>
<td>
<p>A named numeric vector containing possible starting values, the names are based on
function <code><a href="#topic+parameters">parameters</a></code>.</p>
</td></tr>
<tr><td><code id="opt_bbfit_+3A_offset">offset</code></td>
<td>
<p>Can be used to supply model offsets for use in fitting,
returned from function <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>.</p>
</td></tr>
<tr><td><code id="opt_bbfit_+3A_epochs">epochs</code></td>
<td>
<p>For how many epochs should the algorithm run?</p>
</td></tr>
<tr><td><code id="opt_bbfit_+3A_nbatch">nbatch</code></td>
<td>
<p>Number of batches. Can also be a number between 0 and 1, i.e., determining
the fraction of observations that should be used for fitting.</p>
</td></tr>
<tr><td><code id="opt_bbfit_+3A_verbose">verbose</code></td>
<td>
<p>Print information during runtime of the algorithm.</p>
</td></tr>
<tr><td><code id="opt_bbfit_+3A_mc.cores">mc.cores</code></td>
<td>
<p>On how many cores should estimation be started?</p>
</td></tr>
<tr><td><code id="opt_bbfit_+3A_...">...</code></td>
<td>
<p>For <code>bbfitp()</code> all arguments to be passed to <code>bbfit()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The algorithm uses batch-wise estimation of regression coefficients and smoothing variances.
The smoothing variances are estimated on an hold-out batch. This way, models for very large
data sets can be estimated. Note, the algorithm can work in combination with the <span class="pkg">ff</span>
and <span class="pkg">ffbase</span> package, i.e., the entire data is never in the computer RAM. Therefore, the
data can either to be stored as comma separated file on disc or provided as <code>"ffdf"</code>
data frame, see also the examples.
</p>
<p>The optimizer functions use additional arguments:
</p>

<ul>
<li> <p><code>batch_ids</code>. This argument can either be a list of indices specifying the
batches that should be used for estimation, or a vector of length 2, where the
first element specifies the number of observations that should be sampled for each
batch and the second argument specifies the number of batches, see the example.
</p>
</li>
<li> <p><code>nu</code>, the step length control parameter. Defaults to <code>nu = 0.05</code>.
If argument <code>slice = TRUE</code> then <code>nu = 1</code>.
</p>
</li>
<li> <p><code>loglik</code>, defaults to <code>loglik = FALSE</code>. If set to <code>loglik = TRUE</code>
the &quot;out-of-sample&quot; log-likelihood is used for smoothing variance estimation.
</p>
</li>
<li> <p><code>aic</code>, defaults to <code>aic = FALSE</code>, If set to <code>aic = TRUE</code>
the &quot;out-of-sample&quot; AIC is used for smoothing variance estimation.
</p>
</li>
<li> <p><code>eps_loglik</code>, defaults to <code>eps_loglik = 0.01</code>. This argument specifies
the relative change in the &quot;out-of-sample&quot; log-likelihood that is needed such that
a model term gets updated.
</p>
</li>
<li> <p><code>select</code>, defaults to <code>select = FALSE</code>. If set to <code>select = TRUE</code>,
the algorithm only selects the model term with the largest contribution in the
&quot;out-of-sample&quot; log-likelihood for updating in each iteration/batch.
</p>
</li>
<li> <p><code>always</code>, defaults to <code>always = FALSE</code>. If set to <code>always = TRUE</code>
no log-likelihood contribution checks will be used and model terms are always updated.
</p>
</li>
<li> <p><code>K</code>, defaults to <code>K = 2</code>. This argument controls the penalty on the
degrees of freedom in the computation of the AIC.
</p>
</li>
<li> <p><code>slice</code>, defaults to <code>slice = FALSE</code>. If set to <code>slice = TRUE</code>,
slice sampling using the &quot;out-of-sample&quot; log-likelihood or AIC is used for smoothing
variance estimation. Moreover, <code>always = TRUE</code>, <code>eps_loglik = -Inf</code> and
<code>nu = 1</code>. If <code>slice</code> is an integer <code>n</code>, slice sampling is started after
<code>n</code> iterations, before smoothing variances are optimized.
</p>
</li></ul>

<p>When using function <code>opt_bbfitp</code>, the parameter updates are stored as <code>"mcmc"</code>
objects. In this case the traceplots can be visualized using <code><a href="#topic+plot.bamlss">plot.bamlss</a></code>.
</p>


<h3>Value</h3>

<p>For function <code>opt_bbfit()</code> a list containing the following objects:
</p>
<table>
<tr><td><code>fitted.values</code></td>
<td>
<p>A named list of the fitted values of the modeled parameters
of the selected distribution.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>The estimated set regression coefficients and smoothing variances.</p>
</td></tr>
<tr><td><code>shuffle</code></td>
<td>
<p>Logical</p>
</td></tr>
<tr><td><code>runtime</code></td>
<td>
<p>The runtime of the algorithm.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+bamlss">bamlss</a></code>, <code><a href="#topic+bfit">bfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ## Simulate data.
set.seed(123)
d &lt;- GAMart(n = 27000, sd = -1)

## Write data to disc.
tf &lt;- tempdir()
write.table(d, file.path(tf, "d.raw"), quote = FALSE, row.names = FALSE, sep = ",")

## Model formula.
f &lt;- list(
  y ~ s(x1,k=40) + s(x2,k=40) + s(x3,k=40) + te(lon,lat,k=10),
  sigma ~ s(x1,k=40) + s(x2,k=40) + s(x3,k=40) + te(lon,lat,k=10)
)

## Specify 50 batches with 1000 observations.
batch_ids &lt;- c("nobs" = 1000, "nbatch" = 50)

## Note, can also be a list of indices, e.g.
## batch_ids &lt;- lapply(1:50, function(i) { sample(1:nrow(d), size = 1000) })

## Different flavors:
## (1) Using "out-of-sample" aic for smoothing
##     variance estimation. Update is only accepted
##     if the "out-of-sample" log-likelihood is
##     increased. If data is a filepath, the data set is
##     read into R using package ff and model and
##     design matrices are processed with ff. This may
##     take some time depending on the size of the data.
set.seed(1)
b1 &lt;- bamlss(f, data = file.path(tf, "d.raw"),
  sampler = FALSE, optimizer = opt_bbfit,
  batch_ids = batch_ids, nu = 0.1, aic = TRUE, eps_loglik = -Inf,
  always = FALSE)

## Plot estimated effects.
## plot(b1)

## Plot coefficient paths for x3 in mu.
## pathplot(b1, name = "mu.s.s(x3).b")

## (2) Same but always update, this mimics the classic SGD.
##     Note, for prediction only the last iteration is
##     used in this case. To use more iterations use opt_bbfitp(),
##     Then iterations are stored as "mcmc" object and we can
##     predict using the burnin argment, e.g.,
##     p &lt;- predict(b2, model = "mu", burnin = 35)
set.seed(2)
b2 &lt;- bamlss(f, data = file.path(tf, "d.raw"),
  sampler = FALSE, optimizer = opt_bbfit,
  batch_ids = batch_ids, nu = 0.1, aic = TRUE, eps_loglik = -Inf,
  always = TRUE)

## Plot coefficient paths for x3 in mu.
## pathplot(b2, name = "mu.s.s(x3).b")

## (3) Boosting type flavor, only update model term with
##     the largest contribution in the "out-of-sample"
##     log-likelihood. In this case, if edf = 0 during
##     runtime of the algorithm, no model has an additional
##     contribution and the algorithm converges. This
##     behavior is controlled by argument eps_loglik, the
##     higher eps_loglik, the more restrictive is the
##     updating step.

## Initialize intercepts.
set.seed(0)

batch_ids &lt;- lapply(1:400, function(i) { sample(1:nrow(d), size = 1000) })

b0 &lt;- bamlss(y ~ 1, data = d, sampler = FALSE, optimizer = opt_bbfitp,
  batch_ids = batch_ids)

## Compute starting values, remove the first
## 10 iterates and compute the mean of the
## remaining iterates.
start &lt;- coef(b0, FUN = mean, burnin = 200)

## Start boosting, only update if change in
## "out-of-sample" log-likelihood is 0.1
## eps_loglik = 0.001.
b3 &lt;- bamlss(f, data = d, sampler = FALSE, optimizer = opt_bbfit,
    batch_ids = batch_ids, nu = 0.1, aic = TRUE, eps_loglik = 0.001,
    select = TRUE, always = FALSE, start = start)

## Plot log-likelihood contributions.
## contribplot(b3)
## In this case, the algorithm did not converge,
## we need more iterations/batches.

## Note, prediction uses last iterate.
p3 &lt;- predict(b3, model = "mu")

## (4) Use slice sampling under the "out-of-sample"
##     log likelihood for estimation of smoothing
##     variances. In this case model terms are always
##     updated ad parameter paths behave like a MCMC
##     chain. Therefore, use opt_bbfitp(), which stores
##     parameter paths as "mcmc" objects and we can
##     inspect using traceplots. Note nu = 1 if
##     slice = TRUE.
set.seed(4)
b4 &lt;- bamlss(f, data = d, sampler = FALSE, optimizer = opt_bbfitp,
  batch_ids = batch_ids, aic = TRUE, slice = TRUE)

## plot(b4)

## Plot parameter updates/samples.
## plot(b4, which = "samples")

## Predict with burnin and compute mean
## prediction of the last 20 iterates.
p4 &lt;- predict(b4, model = "mu", burnin = 30, FUN = mean)

## End(Not run)
</code></pre>

<hr>
<h2 id='opt_bfit'>
Fit BAMLSS with Backfitting
</h2><span id='topic+bfit'></span><span id='topic+opt_bfit'></span><span id='topic+bfit_iwls'></span><span id='topic+bfit_iwls_Matrix'></span><span id='topic+bfit_iwls_lm'></span><span id='topic+bfit_iwls_optim'></span><span id='topic+bfit_lm'></span><span id='topic+bfit_optim'></span><span id='topic+bfit_glmnet'></span>

<h3>Description</h3>

<p>This optimizer function is a generic tool for fitting BAMLSS using a backfitting algorithm.
The backfitting procedure is based on iteratively weighted least squares (IWLS) for finding
posterior mode estimates, however, the updating methods for model terms can be more general, see
the details section. In addition, the default IWLS updating scheme implements optimum smoothing
variance selection based on information criteria using a stepwise approach.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Optimizer functions:
opt_bfit(x, y, family, start = NULL, weights = NULL, offset = NULL,
  update = "iwls", criterion = c("AICc", "BIC", "AIC"),
  eps = .Machine$double.eps^0.25, maxit = 400,
  outer = NULL, inner = FALSE, mgcv = FALSE,
  verbose = TRUE, digits = 4, flush = TRUE,
  nu = TRUE, stop.nu = NULL, ...)

bfit(x, y, family, start = NULL, weights = NULL, offset = NULL,
  update = "iwls", criterion = c("AICc", "BIC", "AIC"),
  eps = .Machine$double.eps^0.25, maxit = 400,
  outer = NULL, inner = FALSE, mgcv = FALSE,
  verbose = TRUE, digits = 4, flush = TRUE,
  nu = TRUE, stop.nu = NULL, ...)

## Model term updating functions:
bfit_iwls(x, family, y, eta, id, weights, criterion, ...)
bfit_iwls_Matrix(x, family, y, eta, id, weights, criterion, ...)
bfit_lm(x, family, y, eta, id, weights, criterion, ...)
bfit_optim(x, family, y, eta, id, weights, criterion, ...)
bfit_glmnet(x, family, y, eta, id, weights, criterion, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opt_bfit_+3A_x">x</code></td>
<td>
<p>For function <code>opt_bfit()</code> the <code>x</code> list, as returned from function
<code><a href="#topic+bamlss.frame">bamlss.frame</a></code>, holding all model matrices and other information that is used for
fitting the model. For the updating functions an object as returned from function
<code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code> or <code><a href="mgcv.html#topic+smoothCon">smoothCon</a></code>.</p>
</td></tr>
<tr><td><code id="opt_bfit_+3A_y">y</code></td>
<td>
<p>The model response, as returned from function <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>.</p>
</td></tr>
<tr><td><code id="opt_bfit_+3A_family">family</code></td>
<td>
<p>A <span class="pkg">bamlss</span> family object, see <code><a href="#topic+family.bamlss">family.bamlss</a></code>.</p>
</td></tr>
<tr><td><code id="opt_bfit_+3A_start">start</code></td>
<td>
<p>A named numeric vector containing possible starting values, the names are based on
function <code><a href="#topic+parameters">parameters</a></code>.</p>
</td></tr>
<tr><td><code id="opt_bfit_+3A_weights">weights</code></td>
<td>
<p>Prior weights on the data, as returned from function <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>.</p>
</td></tr>
<tr><td><code id="opt_bfit_+3A_offset">offset</code></td>
<td>
<p>Can be used to supply model offsets for use in fitting,
returned from function <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>.</p>
</td></tr>
<tr><td><code id="opt_bfit_+3A_update">update</code></td>
<td>
<p>Sets the updating function for model terms, e.g. for a term <code>s(x)</code> in the model
formula. Per default this is set to <code>"iwls"</code>, a character pointing to the set of updating
functions, see above. Other options are <code>"optim"</code> and <code>"lm"</code> etc., however, this is
more experimental and should not be set by the user. Another option is to pass a full updating
function which should be used for each model term, the structure of updating functions is
described in the details below. Model terms may also have different updating functions, see
the example section implementing a new model term constructor for Gompertz growth curves
using this feature.</p>
</td></tr>
<tr><td><code id="opt_bfit_+3A_criterion">criterion</code></td>
<td>
<p>Set the information criterion that should be used, e.g., for smoothing
variance selection. Options are the corrected AIC <code>"AICc"</code>, the <code>"BIC"</code> and
<code>"AIC"</code>.</p>
</td></tr>
<tr><td><code id="opt_bfit_+3A_eps">eps</code></td>
<td>
<p>The relative convergence tolerance of the backfitting algorithm.</p>
</td></tr>
<tr><td><code id="opt_bfit_+3A_maxit">maxit</code></td>
<td>
<p>The maximum number of iterations for the backfitting algorithm</p>
</td></tr>
<tr><td><code id="opt_bfit_+3A_outer">outer</code></td>
<td>
<p>Should the current working observations and weights be computed in one outer
iteration, otherwise the working observations are computed anew for each model term
updating step. The default will run one outer iteration first, afterwards model weights
are computed for each term anew.</p>
</td></tr>
<tr><td><code id="opt_bfit_+3A_inner">inner</code></td>
<td>
<p>Should the model terms for one parameter of the modeled distribution be
fully updated until convergence in an inner iteration, i.e., the algorithm waits until
coefficients for the current distribution parameter do not change anymore before updating
the next parameter.</p>
</td></tr>
<tr><td><code id="opt_bfit_+3A_mgcv">mgcv</code></td>
<td>
<p>Should the <span class="pkg">mgcv</span> <code><a href="mgcv.html#topic+gam">gam</a></code> function be used for computing updates
in an <code>inner</code> iteration with working observations provided in an <code>outer</code> iteration.</p>
</td></tr>
<tr><td><code id="opt_bfit_+3A_verbose">verbose</code></td>
<td>
<p>Print information during runtime of the algorithm.</p>
</td></tr>
<tr><td><code id="opt_bfit_+3A_digits">digits</code></td>
<td>
<p>Set the digits for printing when <code>verbose = TRUE</code>.</p>
</td></tr>
<tr><td><code id="opt_bfit_+3A_flush">flush</code></td>
<td>
<p>use <code><a href="utils.html#topic+flush.console">flush.console</a></code> for displaying the current output in the console.</p>
</td></tr>
<tr><td><code id="opt_bfit_+3A_nu">nu</code></td>
<td>
<p>Logical, numeric or <code>NULL</code>. Function <code>opt_bfit()</code> uses step length
optimization of parameters when updating a model term, useful to encounter convergence problems
of the algorithm. If <code>nu = TRUE</code> the step length parameter is optimized for each model term
in each iteration of the backfitting algorithm. If <code>nu</code> is numeric, e.g. <code>nu = 1</code>,
then <code>nu</code> is halfed until an improvement in the log-posterior is obtained or nu is
smaller than <code>.Machine$double.eps</code>. If <code>nu = NULL</code>, no step length optimization
is performed. Note, using very large data sets it is usually better to switch of
step length optimization.</p>
</td></tr>
<tr><td><code id="opt_bfit_+3A_stop.nu">stop.nu</code></td>
<td>
<p>Integer. Should step length reduction be stopped after <code>stop.nu</code> iterations
of the backfitting algorithm?</p>
</td></tr>
<tr><td><code id="opt_bfit_+3A_eta">eta</code></td>
<td>
<p>The current value of the predictors, provided as a named list, one list entry
for each parameter. The names correspond to the parameter names in the family object,
see <code><a href="#topic+family.bamlss">family.bamlss</a></code>. E.g., when using the <code><a href="#topic+gaussian_bamlss">gaussian_bamlss</a></code> family
object, the current values for the mean can be extracted by <code>eta\$mu</code> and for the
standard deviation by <code>eta\$sigma</code>.</p>
</td></tr>
<tr><td><code id="opt_bfit_+3A_id">id</code></td>
<td>
<p>Character, the name of the current parameter for which the model term should
be updated.</p>
</td></tr>
<tr><td><code id="opt_bfit_+3A_...">...</code></td>
<td>
<p>For function <code>opt_bfit()</code>, arguments passed to function
<code><a href="#topic+bamlss.engine.setup">bamlss.engine.setup</a></code>. For updating functions, within the dots argument the
actual <code>iteration</code> number of the backfitting algorithm, the actual total number of
equivalent degrees of freedom <code>edf</code> and vectors <code>z</code> and <code>hess</code>
only if argument <code>outer = TRUE</code> are provided.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This algorithm is based on iteratively weighted least squares (IWLS) for BAMLSS, i.e.,
a Newton-Raphson or Fisher scoring algorithm is applied, similar to
Rigby~and~Stasinopoulos~(2005). The algorithm utilizes the chain rule for computing derivatives of
the log-posterior w.r.t. regression coefficients, therefore, to compute the working observations
and weights only the derivatives of the log-likelihood w.r.t. the predictors are required.
</p>
<p>It is assumed that the provided <code>family</code> object holds functions for computing the first
and second order derivatives of the log-likelihood w.r.t. the predictors. These Functions
are provided within the named lists <code>"score"</code> and <code>"hess"</code> within the <code>family</code>
object. See the documentation of <code><a href="#topic+family.bamlss">family.bamlss</a></code> and the code of the provided
families, e.g. <code><a href="#topic+gaussian_bamlss">gaussian_bamlss</a></code>, for examples of the required structure.
</p>
<p>The algorithm either updates each model term over all distributional parameters sequentially,
or does a full update until convergence for model terms for one distributional parameter before
updating the next parameter, see argument <code>inner</code>. Additionally, working observations and
weights can be computed only once in an <code>outer</code> iteration.
</p>
<p>Starting values of regression coefficients and smoothing variances can be supplied, moreover,
if a family object holds functions for initializing the distributional parameters, see also
<code><a href="#topic+family.bamlss">family.bamlss</a></code>, starting values are based on the initialize functions.
</p>
<p>The default updating function for model terms is based on IWLS, which is assigned by function
<code><a href="#topic+bamlss.engine.setup">bamlss.engine.setup</a></code>, however, special updating functions can be used.
This is achieved by providing an updating function to argument
<code>update</code>, which should be used for all model terms. Another option is to set the updating
function within the <code>xt</code> argument of the <span class="pkg">mgcv</span> smooth term constructor functions, see
e.g. function <code><a href="mgcv.html#topic+s">s</a></code>. If the <code>xt</code> list then holds an element named <code>"update"</code>,
which is a valid updating function, this updating function is used for the corresponding model
term. This way it is possible to call different (special) updating functions for specific terms,
e.g., that do not fit in the IWLS scheme. See the examples below. Note that this does not work if
<code>mgcv = TRUE</code>, since the <code><a href="mgcv.html#topic+gam">gam</a></code> function assumes a strict linear
representation of smooth terms.
</p>
<p>A model term updating function has the following arguments:
</p>
<p><code>update(x, family, y, eta, id, weights, criterion, ...)</code>
</p>
<p>Here <code>x</code> is an object as returned from function <code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code>
or <code><a href="mgcv.html#topic+smoothCon">smoothCon</a></code>. The <code>x</code> object is preprocessed by function
<code><a href="#topic+bamlss.engine.setup">bamlss.engine.setup</a></code>, i.e., an element called <code>"state"</code> is assigned. The state
element represents the current state of the model term holding the current values of the
parameters with corresponding fitted values, as well as equivalent degrees of freedom, see
also the values that are returned by such functions below. The backfitting algorithm uses the
state of a model term for generating updates of the parameters. Note that for special model
terms the state list should already be provided within the call to the corresponding
smooth constructor function, see the growth curve example below.
</p>
<p>In addition, for special model terms the fitted values may not be computed by a linear combination
of the design matrix and the coefficients. Therefore, the <code>x</code> object should hold an element
named <code>"fit.fun"</code> which is a function for computing the fitted values.
See also <code><a href="#topic+smooth.construct.bamlss.frame">smooth.construct.bamlss.frame</a></code> and <code><a href="#topic+predict.bamlss">predict.bamlss</a></code> that use
this setup. The arguments of fitting functions are
</p>
<p><code>fit.fun(X, b, ...)</code>
</p>
<p>where <code>X</code> is the design matrix and <code>b</code> is the vector of coefficients. Hence, for
usual IWLS updating the fitted values are computed by <code>X %*% b</code>. For special terms like
nonlinear growth curves this may not be the case, see the example below. The fitting functions
are assigned by <code><a href="#topic+bamlss.engine.setup">bamlss.engine.setup</a></code>, unless the function is already provided
after calling the constructor function <code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code> or
<code><a href="mgcv.html#topic+smoothCon">smoothCon</a></code>. Note that the dots argument is usually not needed by the user.
</p>
<p>The default updating function is <code>bfit_iwls()</code>. Function <code>bfit_iwls_Matrix()</code> uses the
sparse matrix infrastructures of package <span class="pkg">Matrix</span>. The <span class="pkg">Matrix</span> package and
<code>bfit_iwls_Matrix()</code> is used for model terms where
the maximum number of non-zero entries in the design matrix is less than half of the total number
of columns, if an additional argument <code>force.Matrix</code> is set to <code>TRUE</code> in the
<code>opt_bfit()</code> call.
</p>
<p>The IWLS updating functions find optimum smoothing variances according to an information criterion
using a stepwise approach, i.e., in each iteration and for each model term update the updating
functions try to find a better smoothing variance to control the trade-off between over-smoothing
and nonlinear functional estimation. The search interval is centered around the current state
of the smoothing variances, hence, in each iteration only a slight improvement is achieved.
This algorithm is based on Belitz~and~Lang~(2008) and can also be viewed as a boosting approach
for optimization.
</p>


<h3>Value</h3>

<p>For function <code>opt_bfit()</code> a list containing the following objects:
</p>
<table>
<tr><td><code>fitted.values</code></td>
<td>
<p>A named list of the fitted values of the modeled parameters
of the selected distribution.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>The estimated set regression coefficients and smoothing variances.</p>
</td></tr>
<tr><td><code>edf</code></td>
<td>
<p>The equivalent degrees of freedom used to fit the model.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>The value of the log-likelihood.</p>
</td></tr>
<tr><td><code>logPost</code></td>
<td>
<p>The value of the log-posterior.</p>
</td></tr>
<tr><td><code>IC</code></td>
<td>
<p>The value of the information criterion.</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>Logical, indicating convergence of the backfitting algorithm.</p>
</td></tr>
<tr><td><code>For updating functions a list providing the current state</code></td>
<td>
</td></tr>
<tr><td><code>fitted.values</code></td>
<td>
<p>The resulting fitted values after updating.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>The resulting named numeric vector of updated model term parameters.
Coefficients should be named with <code>"b1"</code>, ..., <code>"bk"</code>, where <code>k</code> is
the total number of coefficients. Smoothing variances should be named with
<code>"tau21"</code>, ..., <code>"tau2m"</code>, where <code>m</code> is the total number of smoothing
variances assigned to the model term.</p>
</td></tr>
<tr><td><code>edf</code></td>
<td>
<p>The equivalent degrees of freedom used to produce the fitted values.</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p>Optional, the coefficient Hessian information</p>
</td></tr>
<tr><td><code>log.prior</code></td>
<td>
<p>Optional, the value of the log-prior of the model term.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Belitz C, Lang S (2008). Simultaneous Selection of Variables and Smoothing Parameters in
Structured Additive Regression Models. <em>Computational Statistics &amp; Data Analysis</em>,
<b>53</b>, pp 61-81.
</p>
<p>Umlauf N, Klein N, Zeileis A (2016). Bayesian Additive Models for Location
Scale and Shape (and Beyond). <em>(to appear)</em>
</p>
<p>Rigby, R. A. and  Stasinopoulos D. M. (2005). Generalized additive models for location,
scale and shape, (with discussion), <em>Appl. Statist.</em>, <b>54</b>, part 3, pp 507-554.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bamlss">bamlss</a></code>, <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>,
<code><a href="#topic+bamlss.engine.setup">bamlss.engine.setup</a></code>, <code><a href="#topic+set.starting.values">set.starting.values</a></code>, <code><a href="#topic+s2">s2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ## Simulated data example illustrating
## how to call the optimizer function.
## This is done internally within
## the setup of function bamlss().
d &lt;- GAMart(n = 200)
f &lt;- num ~ s(x1) + s(x2) + s(x3)
bf &lt;- bamlss.frame(f, data = d, family = "gaussian")
opt &lt;- with(bf, opt_bfit(x, y, family))
print(str(opt))

## Same with bamlss().
b &lt;- bamlss(f, data = d, family = "gaussian", sampler = FALSE)
plot(b)
summary(b)

## Use of different updating function.
b &lt;- bamlss(f, data = d, family = "gaussian",
  sampler = FALSE, update = bfit_lm)
plot(b)

## Use mgcv gam() function for updating.
b &lt;- bamlss(f, data = d, family = "gaussian",
  sampler = FALSE, mgcv = TRUE)
plot(b)

## Special smooth constructor including updating/sampler
## function for nonlinear Gompertz curves.
## Note: element special.npar is needed here since this
##       function has 3 parameters but the design matrix only
##       one column!
smooth.construct.gc.smooth.spec &lt;- function(object, data, knots) 
{
  object$X &lt;- matrix(as.numeric(data[[object$term]]), ncol = 1)
  center &lt;- if(!is.null(object$xt$center)) {
    object$xt$center
  } else TRUE
  object$by.done &lt;- TRUE
  if(object$by != "NA")
    stop("by variables not supported!")
  object$fit.fun &lt;- function(X, b, ...) {
    f &lt;- b[1] * exp(-b[2] * exp(-b[3] * drop(X)))
    if(center)
      f &lt;- f - mean(f)
    f
  }
  object$update &lt;- bfit_optim
  object$propose &lt;- GMCMC_slice
  object$prior &lt;- function(b) { sum(dnorm(b, sd = 1000, log = TRUE)) }
  object$fixed &lt;- TRUE
  object$state$parameters &lt;- c("b1" = 0, "b2" = 0.5, "b3" = 0.1)
  object$state$fitted.values &lt;- rep(0, length(object$X))
  object$state$edf &lt;- 3
  object$special.npar &lt;- 3 ## Important!
  class(object) &lt;- c("gc.smooth", "no.mgcv", "special")
  object
}

## Work around for the "prediction matrix" of a growth curve.
Predict.matrix.gc.smooth &lt;- function(object, data, knots) 
{
  X &lt;- matrix(as.numeric(data[[object$term]]), ncol = 1)
  X
}

## Heteroscedastic growth curve data example.
set.seed(111)

d &lt;- data.frame("time" = 1:30)
d$y &lt;- 2 + 1 / (1 + exp(0.5 * (15 - d$time))) +
  rnorm(30, sd = exp(-3 + 2 * cos(d$time/30 * 6 - 3)))

## Special model terms must be called with s2()!
f &lt;- list(
  y ~ s2(time, bs = "gc"),
  sigma ~ s(time)
)

## Fit model with special model term.
b &lt;- bamlss(f, data = d,
  optimizer = opt_bfit, sampler = sam_GMCMC)

## Plot the fitted curves.
plot(b)

## Predict with special model term.
nd &lt;- data.frame("time" = seq(1, 30, length = 100))
p &lt;- predict(b, newdata = nd, model = "mu", FUN = c95)
plot(d, ylim = range(c(d$y, p)))
matplot(nd$time, p, type = "l",
  lty = c(2, 1, 2), col = "black", add = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='opt_boost'>Boosting BAMLSS</h2><span id='topic+boost'></span><span id='topic+opt_boost'></span><span id='topic+boostm'></span><span id='topic+opt_boostm'></span><span id='topic+boost_summary'></span><span id='topic+boost_plot'></span><span id='topic+print.boost_summary'></span><span id='topic+plot.boost_summary'></span><span id='topic+boost_frame'></span>

<h3>Description</h3>

<p>Optimizer functions for gradient and likelihood boosting with <code><a href="#topic+bamlss">bamlss</a></code>. In each
boosting iteration the function selects the model term with the largest contribution to the
log-likelihood, AIC or BIC.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Gradient boosting optimizer.
opt_boost(x, y, family, weights = NULL,
  offset = NULL, nu = 0.1, nu.adapt = TRUE, df = 4, maxit = 400,
  mstop = NULL, maxq = NULL, qsel.splitfactor = FALSE,
  verbose = TRUE, digits = 4, flush = TRUE,
  eps = .Machine$double.eps^0.25,
  nback = NULL, plot = TRUE, initialize = TRUE,
  stop.criterion = NULL, select.type = 1,
  force.stop = TRUE, hatmatrix = !is.null(stop.criterion),
  reverse.edf = FALSE, approx.edf = FALSE,
  always = FALSE, ...)

boost(x, y, family, weights = NULL,
  offset = NULL, nu = 0.1, nu.adapt = TRUE, df = 4, maxit = 400,
  mstop = NULL, maxq = NULL, qsel.splitfactor = FALSE,
  verbose = TRUE, digits = 4, flush = TRUE,
  eps = .Machine$double.eps^0.25,
  nback = NULL, plot = TRUE, initialize = TRUE,
  stop.criterion = NULL, select.type = 1,
  force.stop = TRUE, hatmatrix = !is.null(stop.criterion),
  reverse.edf = FALSE, approx.edf = FALSE,
  always = FALSE, ...)

## Modified likelihood based boosting.
opt_boostm(x, y, family, offset = NULL,
  nu = 0.1, df = 3, maxit = 400, mstop = NULL,
  verbose = TRUE, digits = 4, flush = TRUE,
  eps = .Machine$double.eps^0.25, plot = TRUE,
  initialize = TRUE, stop.criterion = "BIC",
  force.stop = !is.null(stop.criterion),
  do.optim = TRUE, always = FALSE, ...)

boostm(x, y, family, offset = NULL,
  nu = 0.1, df = 3, maxit = 400, mstop = NULL,
  verbose = TRUE, digits = 4, flush = TRUE,
  eps = .Machine$double.eps^0.25, plot = TRUE,
  initialize = TRUE, stop.criterion = "BIC",
  force.stop = !is.null(stop.criterion),
  do.optim = TRUE, always = FALSE, ...)

## Boosting summary extractor.
boost_summary(object, ...)

## Plot all boosting paths.
boost_plot(x, which = c("loglik", "loglik.contrib", "parameters",
  "aic", "bic", "user"), intercept = TRUE, spar = TRUE, mstop = NULL,
  name = NULL, drop = NULL, labels = NULL, color = NULL, ...)

## Boosting summary printing and plotting.
## S3 method for class 'boost_summary'
print(x, summary = TRUE, plot = TRUE,
  which = c("loglik", "loglik.contrib"), intercept = TRUE,
  spar = TRUE, ...)
## S3 method for class 'boost_summary'
plot(x, ...)

## Model frame for out-of-sample selection.
boost_frame(formula, train, test, family = "gaussian", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opt_boost_+3A_x">x</code></td>
<td>
<p>For function <code>opt_boost()</code> the <code>x</code> list, as returned from function
<code><a href="#topic+bamlss.frame">bamlss.frame</a></code>, holding all model matrices and other information that is used for
fitting the model. For the plotting function the corresponding <code><a href="#topic+bamlss">bamlss</a></code> object
fitted with the <code>opt_boost()</code> optimizer.</p>
</td></tr>
<tr><td><code id="opt_boost_+3A_y">y</code></td>
<td>
<p>The model response, as returned from function <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>.</p>
</td></tr>
<tr><td><code id="opt_boost_+3A_family">family</code></td>
<td>
<p>A <span class="pkg">bamlss</span> family object, see <code><a href="#topic+family.bamlss">family.bamlss</a></code>.</p>
</td></tr>
<tr><td><code id="opt_boost_+3A_weights">weights</code></td>
<td>
<p>Prior weights on the data, as returned from function <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>.</p>
</td></tr>
<tr><td><code id="opt_boost_+3A_offset">offset</code></td>
<td>
<p>Can be used to supply model offsets for use in fitting,
returned from function <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>.</p>
</td></tr>
<tr><td><code id="opt_boost_+3A_nu">nu</code></td>
<td>
<p>Numeric, between [0, 1], controls the step size, i.e., the amount
that should be added to model term parameters.</p>
</td></tr>
<tr><td><code id="opt_boost_+3A_nu.adapt">nu.adapt</code></td>
<td>
<p>Logical. If set to TRUE (default) step size <code>nu</code> is divided by 2,
if current boosting iteration did not improve the loglikelihood.</p>
</td></tr>
<tr><td><code id="opt_boost_+3A_df">df</code></td>
<td>
<p>Integer, defines the initial degrees of freedom that should be assigned
to each smooth model term. May also be a named vector, the names must match the model term
labels, e.g., as provided in <code><a href="#topic+summary.bamlss">summary.bamlss</a></code>.</p>
</td></tr>
<tr><td><code id="opt_boost_+3A_maxit">maxit</code></td>
<td>
<p>Integer, the maximum number of boosting iterations.</p>
</td></tr>
<tr><td><code id="opt_boost_+3A_mstop">mstop</code></td>
<td>
<p>For convenience, overwrites <code>maxit</code>.</p>
</td></tr>
<tr><td><code id="opt_boost_+3A_maxq">maxq</code></td>
<td>
<p>Integer, defines the maximum number of selected base-learners. The algorithm stops
if this numer is exceeded.</p>
</td></tr>
<tr><td><code id="opt_boost_+3A_qsel.splitfactor">qsel.splitfactor</code></td>
<td>
<p>Logical, if set to <code>TRUE</code> dummy variables of categorical predictors are counted individually.</p>
</td></tr>
<tr><td><code id="opt_boost_+3A_name">name</code></td>
<td>
<p>Character, the name of the coefficient (group) that should be plotted. Note that
the string provided in <code>name</code> will be removed from the labels on the 4th axis.</p>
</td></tr>
<tr><td><code id="opt_boost_+3A_drop">drop</code></td>
<td>
<p>Character, the name of the coefficient (group) that should not be plotted.</p>
</td></tr>
<tr><td><code id="opt_boost_+3A_labels">labels</code></td>
<td>
<p>A character string of labels that should be used on the 4 axis.</p>
</td></tr>
<tr><td><code id="opt_boost_+3A_color">color</code></td>
<td>
<p>Colors or color function that creates colors for the (group) paths.</p>
</td></tr>
<tr><td><code id="opt_boost_+3A_verbose">verbose</code></td>
<td>
<p>Print information during runtime of the algorithm.</p>
</td></tr>
<tr><td><code id="opt_boost_+3A_digits">digits</code></td>
<td>
<p>Set the digits for printing when <code>verbose = TRUE</code>.</p>
</td></tr>
<tr><td><code id="opt_boost_+3A_flush">flush</code></td>
<td>
<p>use <code><a href="utils.html#topic+flush.console">flush.console</a></code> for displaying the current output in the console.</p>
</td></tr>
<tr><td><code id="opt_boost_+3A_eps">eps</code></td>
<td>
<p>The tolerance used as stopping mechanism, see argument <code>nback</code>.</p>
</td></tr>
<tr><td><code id="opt_boost_+3A_nback">nback</code></td>
<td>
<p>Integer. If <code>nback</code> is not <code>NULL</code>, then the algorithm stops if the
the change in the log-likelihood of the last <code>nback</code> iterations is smaller or
equal to <code>eps</code>. If <code>maxit = NULL</code> the maximum number of iterations is set to 10000.</p>
</td></tr>
<tr><td><code id="opt_boost_+3A_plot">plot</code></td>
<td>
<p>Should the boosting summary be printed and plotted?</p>
</td></tr>
<tr><td><code id="opt_boost_+3A_initialize">initialize</code></td>
<td>
<p>Logical, should intercepts be initialized?</p>
</td></tr>
<tr><td><code id="opt_boost_+3A_stop.criterion">stop.criterion</code></td>
<td>
<p>Character, selects the information criterion that should be used
to determine the optimum number of boosting iterations. Either <code>"AIC"</code> or <code>"BIC"</code>
is possible. Note that this feature requires to compute hat-matrices for each distributional
parameter, therefore, the routine may be slow and computer storage intensive.</p>
</td></tr>
<tr><td><code id="opt_boost_+3A_select.type">select.type</code></td>
<td>
<p>Should model terms be selected by the log-likelihood contribution,
<code>select.type = 1</code>, or by the corresponding <code>stop.criterion</code>, <code>select.type = 2</code>.</p>
</td></tr>
<tr><td><code id="opt_boost_+3A_force.stop">force.stop</code></td>
<td>
<p>Logical, should the algorithm stop if the information criterion increases?</p>
</td></tr>
<tr><td><code id="opt_boost_+3A_do.optim">do.optim</code></td>
<td>
<p>Logical. Should smoothing parameters be optimized in each boosting iteration?</p>
</td></tr>
<tr><td><code id="opt_boost_+3A_hatmatrix">hatmatrix</code></td>
<td>
<p>Logical, if set to <code>TRUE</code> the hat-matrices for each distributional parameter
will be computed. The hat-matrices are used to determine the effective (equivalent) degrees of
freedom in each boosting iteration, i.e., it is possible to compute information criteria
like the AIC or BIC for selecting the optimum number of boosting iterations.</p>
</td></tr>
<tr><td><code id="opt_boost_+3A_reverse.edf">reverse.edf</code></td>
<td>
<p>Logical. Instead of computing degrees of freedom with hat-matrices, the actual
smoothing parameters are reverse engineered to compute the corresponding actual smoother matrix.
Note that this option is still experimental.</p>
</td></tr>
<tr><td><code id="opt_boost_+3A_approx.edf">approx.edf</code></td>
<td>
<p>Logical. Another experimental and fast approximation of the degrees of freedom.</p>
</td></tr>
<tr><td><code id="opt_boost_+3A_always">always</code></td>
<td>
<p>Logical or character. Should the intercepts forced to be updated in each boosting iteration?
If <code>always = TRUE</code> each intercept of each distributional parameter is updated,
if <code>always = "best"</code> only the intercept corresponding to the distributional of the best
fitting model term is updated.</p>
</td></tr>
<tr><td><code id="opt_boost_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+bamlss">bamlss</a></code> object that was fitted using <code>opt_boost()</code>.</p>
</td></tr>
<tr><td><code id="opt_boost_+3A_summary">summary</code></td>
<td>
<p>Should the summary be printed?</p>
</td></tr>
<tr><td><code id="opt_boost_+3A_which">which</code></td>
<td>
<p>Which of the three provided plots should be created?</p>
</td></tr>
<tr><td><code id="opt_boost_+3A_intercept">intercept</code></td>
<td>
<p>Should the coefficient paths of intercepts be dropped in the plot?</p>
</td></tr>
<tr><td><code id="opt_boost_+3A_spar">spar</code></td>
<td>
<p>Should graphical parmeters be set with <code><a href="graphics.html#topic+par">par</a></code>?</p>
</td></tr>
<tr><td><code id="opt_boost_+3A_formula">formula</code></td>
<td>
<p>See <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>.</p>
</td></tr>
<tr><td><code id="opt_boost_+3A_train">train</code>, <code id="opt_boost_+3A_test">test</code></td>
<td>
<p>Data frames used for training and testing the model..</p>
</td></tr>
<tr><td><code id="opt_boost_+3A_...">...</code></td>
<td>
<p>For function <code>opt_boost()</code>, arguments passed to <code><a href="#topic+bamlss.engine.setup">bamlss.engine.setup</a></code>.
for function <code>boost_summary()</code> arguments passed to function <code>print.boost_summary()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For function <code>boost_summary()</code> a list containing information on selection frequencies etc.
For function <code>opt_boost()</code> and <code>opt_boostm()</code> a list containing the following objects:
</p>
<table>
<tr><td><code>fitted.values</code></td>
<td>
<p>A named list of the fitted values based on the last boosting iteration
of the modeled parameters of the selected distribution.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>A matrix, each row corresponds to the parameter values of one boosting iteration.</p>
</td></tr>
<tr><td><code>boost_summary</code></td>
<td>
<p>The boosting summary which can be printed and plotted.</p>
</td></tr>
</table>


<h3>WARNINGS</h3>

<p>The function does not take care of variable scaling for the linear parts! This must be done by the
user, e.g., one option is to use argument <code>scale.d</code> in function <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>,
which uses <code><a href="base.html#topic+scale">scale</a></code>.
</p>
<p>Function <code>opt_boost()</code> does not select the optimum stopping iteration! The modified likelihood
based algorithm implemented in function <code>opt_boostm()</code> is still experimental!
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bamlss.frame">bamlss.frame</a></code>, <code><a href="#topic+bamlss">bamlss</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ## Simulate data.
set.seed(123)
d &lt;- GAMart()

## Estimate model.
f &lt;- num ~ x1 + x2 + x3 + lon + lat +
  s(x1) + s(x2) + s(x3) + s(lon) + s(lat) + te(lon,lat)

b &lt;- bamlss(f, data = d, optimizer = opt_boost,
  sampler = FALSE, scale.d = TRUE, nu = 0.01,
  maxit = 1000, plot = FALSE)

## Plot estimated effects.
## plot(b)

## Print and plot the boosting summary.
boost_summary(b, plot = FALSE)
## boost_plot(b, which = 1)
## boost_plot(b, which = 2)
## boost_plot(b, which = 3, name = "mu.s.te(lon,lat).")

## Extract estimated parameters for certain
## boosting iterations.
parameters(b, mstop = 1)
parameters(b, mstop = 100)

## Also works with predict().
head(do.call("cbind", predict(b, mstop = 1)))
head(do.call("cbind", predict(b, mstop = 100)))

## Another example using the modified likelihood
## boosting algorithm.
f &lt;- list(
  num ~ x1 + x2 + x3 + lon + lat +
    s(x1) + s(x2) + s(x3) + s(lon) + s(lat) + te(lon,lat),
  sigma ~ x1 + x2 + x3 + lon + lat +
    s(x1) + s(x2) + s(x3) + s(lon) + s(lat) + te(lon,lat)
)

b &lt;- bamlss(f, data = d, optimizer = opt_boostm,
  sampler = FALSE, scale.d = TRUE, nu = 0.05,
  maxit = 400, stop.criterion = "AIC", force.stop = FALSE)

## Plot estimated effects.
## plot(b)

## Plot AIC and log-lik contributions.
## boost_plot(b, "AIC")
## boost_plot(b, "loglik.contrib")

## Out-of-sample selection of model terms.
set.seed(123)
d &lt;- GAMart(n = 5000)

## Split data into training and testing
i &lt;- sample(1:2, size = nrow(d), replace = TRUE)
dtest &lt;- subset(d, i == 1)
dtrain &lt;- subset(d, i == 2)

## Model formula
f &lt;- list(
  num ~ s(x1) + s(x2) + s(x3),
  sigma ~ s(x1) + s(x2) + s(x3)
)

## Create model frame for out-of-sample selection.
sm &lt;- boost_frame(f, train = dtrain, test = dtest, family = "gaussian")

## Out-of-sample selection function.
sfun &lt;- function(parameters) {
  sm$parameters &lt;- parameters
  p &lt;- predict(sm, type = "parameter")
  -1 * sum(sm$family$d(dtest$num, p, log = TRUE))
}

## Start boosting with out-of-sample negative
## log-likelihood selection of model terms.
b &lt;- bamlss(f, data = dtrain, sampler = FALSE, optimizer = opt_boost,
  selectfun = sfun, always = "best")

## Plot curve of negative out-of-sample log-likelihood.
## boost_plot(b, which = "user")

## End(Not run)
</code></pre>

<hr>
<h2 id='opt_Cox'>
Cox Model Posterior Mode Estimation
</h2><span id='topic+opt_Cox'></span><span id='topic+cox_mode'></span>

<h3>Description</h3>

<p>This function computes posterior mode estimates of the parameters of a flexible Cox model
with structured additive predictors using a Newton-Raphson algorithm. Integrals are solved
numerically. Moreover, optimum smoothing variances are computed using a stepwise optimization,
see also the details section of function <code><a href="#topic+bfit">bfit</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opt_Cox(x, y, start, weights, offset,
  criterion = c("AICc", "BIC", "AIC"),
  nu = 0.1, update.nu = TRUE,
  eps = .Machine$double.eps^0.25, maxit = 400,
  verbose = TRUE, digits = 4, ...)

cox_mode(x, y, start, weights, offset,
  criterion = c("AICc", "BIC", "AIC"),
  nu = 0.1, update.nu = TRUE,
  eps = .Machine$double.eps^0.25, maxit = 400,
  verbose = TRUE, digits = 4, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opt_Cox_+3A_x">x</code></td>
<td>
<p>The <code>x</code> list, as returned from function
<code><a href="#topic+bamlss.frame">bamlss.frame</a></code> and transformed by function <code><a href="#topic+surv_transform">surv_transform</a></code>,
holding all model matrices and other information that is used for
fitting the model.</p>
</td></tr>
<tr><td><code id="opt_Cox_+3A_y">y</code></td>
<td>
<p>The model response, as returned from function <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>.</p>
</td></tr>
<tr><td><code id="opt_Cox_+3A_start">start</code></td>
<td>
<p>A named numeric vector containing possible starting values, the names are based on
function <code><a href="#topic+parameters">parameters</a></code>.</p>
</td></tr>
<tr><td><code id="opt_Cox_+3A_weights">weights</code></td>
<td>
<p>Prior weights on the data, as returned from function <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>.</p>
</td></tr>
<tr><td><code id="opt_Cox_+3A_offset">offset</code></td>
<td>
<p>Can be used to supply model offsets for use in fitting,
returned from function <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>.</p>
</td></tr>
<tr><td><code id="opt_Cox_+3A_criterion">criterion</code></td>
<td>
<p>Set the information criterion that should be used, e.g., for smoothing
variance selection. Options are the corrected AIC <code>"AICc"</code>, the <code>"BIC"</code> and
<code>"AIC"</code>.</p>
</td></tr>
<tr><td><code id="opt_Cox_+3A_nu">nu</code></td>
<td>
<p>Calibrates the step length of parameter updates of one Newton-Raphson update.</p>
</td></tr>
<tr><td><code id="opt_Cox_+3A_update.nu">update.nu</code></td>
<td>
<p>Should the updating step length be optimized in each iteration
of the backfitting algorithm.</p>
</td></tr>
<tr><td><code id="opt_Cox_+3A_eps">eps</code></td>
<td>
<p>The relative convergence tolerance of the backfitting algorithm.</p>
</td></tr>
<tr><td><code id="opt_Cox_+3A_maxit">maxit</code></td>
<td>
<p>The maximum number of iterations for the backfitting algorithm</p>
</td></tr>
<tr><td><code id="opt_Cox_+3A_verbose">verbose</code></td>
<td>
<p>Print information during runtime of the algorithm.</p>
</td></tr>
<tr><td><code id="opt_Cox_+3A_digits">digits</code></td>
<td>
<p>Set the digits for printing when <code>verbose = TRUE</code>.</p>
</td></tr>
<tr><td><code id="opt_Cox_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing the following objects:
</p>
<table>
<tr><td><code>fitted.values</code></td>
<td>
<p>A named list of the fitted values of the modeled parameters
of the selected distribution.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>The estimated set regression coefficients and smoothing variances.</p>
</td></tr>
<tr><td><code>edf</code></td>
<td>
<p>The equivalent degrees of freedom used to fit the model.</p>
</td></tr>
<tr><td><code>logLik</code></td>
<td>
<p>The value of the log-likelihood.</p>
</td></tr>
<tr><td><code>logPost</code></td>
<td>
<p>The value of the log-posterior.</p>
</td></tr>
<tr><td><code>hessian</code></td>
<td>
<p>The Hessian matrix evaluated at the posterior mode.</p>
</td></tr>
<tr><td><code>converged</code></td>
<td>
<p>Logical, indicating convergence of the backfitting algorithm.</p>
</td></tr>
<tr><td><code>time</code></td>
<td>
<p>The runtime of the algorithm.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Umlauf N, Klein N, Zeileis A (2016). Bayesian Additive Models for Location
Scale and Shape (and Beyond). <em>(to appear)</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+sam_Cox">sam_Cox</a></code>, <code><a href="#topic+cox_bamlss">cox_bamlss</a></code>, <code><a href="#topic+surv_transform">surv_transform</a></code>,
<code><a href="#topic+simSurv">simSurv</a></code>, <code><a href="#topic+bamlss">bamlss</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Please see the examples of function sam_Cox()!
</code></pre>

<hr>
<h2 id='opt_isgd'>
Implicit Stochastic Gradient Descent Optimizer
</h2><span id='topic+opt_isgd'></span><span id='topic+isgd'></span>

<h3>Description</h3>

<p>This optimizer performs an implicit stochastic gradient descent
algorithm. It is mainly used within a <code><a href="#topic+bamlss">bamlss</a></code> call.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>opt_isgd(x, y, family, weights = NULL, offset = NULL,
     gammaFun = function(i) 1/(1 + i), shuffle = TRUE,
     CFun = function(beta) diag(length(beta)),
     start = NULL, i.state = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="opt_isgd_+3A_x">x</code></td>
<td>
<p>For function <code>boost()</code> the <code>x</code> list, as returned from
function <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>, holding all model matrices
and other information that is used for fitting the model.</p>
</td></tr>
<tr><td><code id="opt_isgd_+3A_y">y</code></td>
<td>
<p>The model response, as returned from function
<code><a href="#topic+bamlss.frame">bamlss.frame</a></code>.</p>
</td></tr>
<tr><td><code id="opt_isgd_+3A_family">family</code></td>
<td>
<p>A <span class="pkg">bamlss</span> family object, see
<code><a href="#topic+family.bamlss">family.bamlss</a></code>.</p>
</td></tr>
<tr><td><code id="opt_isgd_+3A_weights">weights</code></td>
<td>
<p>Prior weights on the data, as returned from function <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>.</p>
</td></tr>
<tr><td><code id="opt_isgd_+3A_offset">offset</code></td>
<td>
<p>Can be used to supply model offsets for use in fitting,
returned from function <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>.</p>
</td></tr>
<tr><td><code id="opt_isgd_+3A_gammafun">gammaFun</code></td>
<td>
<p>Function specifying the step length.</p>
</td></tr>
<tr><td><code id="opt_isgd_+3A_shuffle">shuffle</code></td>
<td>
<p>Should the data be shuffled?</p>
</td></tr>
<tr><td><code id="opt_isgd_+3A_cfun">CFun</code></td>
<td>
<p>Hessian approximating function.</p>
</td></tr>
<tr><td><code id="opt_isgd_+3A_start">start</code></td>
<td>
<p>Vector of starting values.</p>
</td></tr>
<tr><td><code id="opt_isgd_+3A_i.state">i.state</code></td>
<td>
<p>Added to <code>gammaFUN()</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>tpf
</p>


<h3>Value</h3>

<p>For function <code>opt_isgd()</code> a list containing the following objects:
</p>
<table>
<tr><td><code>fitted.values</code></td>
<td>
<p>A named list of the fitted values based on the last iteration
of the modeled parameters of the selected distribution.</p>
</td></tr>
<tr><td><code>parameters</code></td>
<td>
<p>A matrix, each row corresponds to the parameter values of one iteration.</p>
</td></tr>
<tr><td><code>sgd.summary</code></td>
<td>
<p>The summary of the stochastic gradient descent algorithm which can be printed and plotted.</p>
</td></tr>
</table>


<h3>Warning </h3>

<p>CAUTION: Arguments <code>weights</code> and <code>offset</code> are not implemented yet!
</p>


<h3>Note</h3>

<p>Motivated by the lecture 'Regression modelling with large data sets'
given by Ioannis Kosmidis in Innsbruck, January 2017.
</p>


<h3>Author(s)</h3>

<p>Thorsten Simon
</p>


<h3>References</h3>

<p>Toulis, P and Airoldi, EM (2015): Scalable estimation strategies based on
stochastic approximations: Classical results and new insights.
Statistics and Computing, 25, no. 4, 781&ndash;795.
doi: 10.1007/s11222-015-9560-y
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bamlss.frame">bamlss.frame</a></code>, <code><a href="#topic+bamlss">bamlss</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
set.seed(111)
d &lt;- GAMart(n = 10000)
f &lt;- num ~ s(x1) + s(x2) + s(x3) + te(lon, lat)
b &lt;- bamlss(f, data = d, optimizer = opt_isgd, sampler = FALSE)
plot(b, ask = F)

## loop over observations a 2nd time
b &lt;- bamlss(f, data = d, optimizer = opt_isgd, sampler = FALSE, start = parameters(b),
            i.state = b$model.stats$optimizer$sgd.summary$i.state)
plot(b, ask = F)

## try differeent gammaFuns, e.g.,
# gammaFun &lt;- function(i) .3/sqrt((1+i)) + 0.001

## testing some families
f2 &lt;- bin ~ s(x1) + s(x2) + s(x3) + te(lon, lat)
b2 &lt;- bamlss(f2, data = d, optimizer = opt_isgd, sampler = FALSE, family = "binomial")

f3 &lt;- cens ~ s(x1) + s(x2) + s(x3) + te(lon, lat)
b3 &lt;- bamlss(f3, data = d, optimizer = opt_isgd, sampler = FALSE, family = "cnorm")

## End(Not run)
</code></pre>

<hr>
<h2 id='parameters'>Extract or Initialize Parameters for BAMLSS</h2><span id='topic+parameters'></span>

<h3>Description</h3>

<p>The function either sets up a list of all parameters of a <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>, which
can be used for setting up models, or extracts the estimated parameters of a <code><a href="#topic+bamlss">bamlss</a></code>
object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parameters(x, model = NULL, start = NULL,
  fill = c(0, 1e-04), list = FALSE,
  simple.list = FALSE, extract = FALSE,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parameters_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+bamlss.frame">bamlss.frame</a></code> or <code><a href="#topic+bamlss">bamlss</a></code> object.</p>
</td></tr>
<tr><td><code id="parameters_+3A_model">model</code></td>
<td>
<p>The model name for which parameters should be initialized or extracted.</p>
</td></tr>
<tr><td><code id="parameters_+3A_start">start</code></td>
<td>
<p>A named numeric vector which should be used when creating the parameter list.
See also function <code>link{set.starting.values}</code></p>
</td></tr>
<tr><td><code id="parameters_+3A_fill">fill</code></td>
<td>
<p>Numeric, when setting up a parameter list, the values the should be used for regression
coefficients (first element of <code>fill</code>) and for smoothing variances
(second element of <code>fill</code>).</p>
</td></tr>
<tr><td><code id="parameters_+3A_list">list</code></td>
<td>
<p>Should the function return a list of all parameters?</p>
</td></tr>
<tr><td><code id="parameters_+3A_simple.list">simple.list</code></td>
<td>
<p>Should the names of parameter vectors be dropped?</p>
</td></tr>
<tr><td><code id="parameters_+3A_extract">extract</code></td>
<td>
<p>Should parameters of a <code><a href="#topic+bamlss.frame">bamlss.frame</a></code> be extracted or initialized?</p>
</td></tr>
<tr><td><code id="parameters_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Parameters for BAMLSS are used for optimizer functions in function <code><a href="#topic+bamlss">bamlss</a></code>.
The function is useful for initializing all parameters given a <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>
(which is done internally in function <code><a href="#topic+bamlss">bamlss</a></code>), but also for extracting all
estimated parameters of some optimizer.
</p>
<p>The naming convention of the parameter list is used by a couple of functions in this package.
For each parameter of the modeled distribution, e.g., <code><a href="#topic+gaussian_bamlss">gaussian_bamlss</a></code> has
parameters <code>"mu"</code> and <code>"sigma"</code>, a list element is created. These elements the contain
the list of all model term parameters. Parametric model terms are indicated with <code>"p"</code> and
smooth model terms with <code>"s"</code>. If the design matrix of a model term in the <code>x</code> list
of a <code><a href="#topic+bamlss.frame">bamlss.frame</a></code> does not contain any columns names, then the parameters are named
with a leading <code>"b"</code>, otherwise the column names of the design matrix are used. Smoothing
variances parameter vectors are named with a leading <code>"tau2"</code>.
</p>
<p>The naming convention is useful when setting up new model fitting engines for <code><a href="#topic+bamlss">bamlss</a></code>
and is used, e.g., by <code><a href="#topic+bfit">bfit</a></code> and <code><a href="#topic+GMCMC">GMCMC</a></code>, which are based on parameter
state list objects as provided by function <code><a href="#topic+bamlss.engine.setup">bamlss.engine.setup</a></code>.
</p>


<h3>Value</h3>

<p>A named list of all parameters of a <code><a href="#topic+bamlss.frame">bamlss.frame</a></code> or <code><a href="#topic+bamlss">bamlss</a></code>
object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bamlss.frame">bamlss.frame</a></code>, <code><a href="#topic+bamlss">bamlss</a></code>, <code><a href="#topic+opt_bfit">opt_bfit</a></code>, <code><a href="#topic+sam_GMCMC">sam_GMCMC</a></code>,
<code><a href="#topic+get.par">get.par</a></code>, <code><a href="#topic+set.par">set.par</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a "bamlss.frame"
set.seed(123)
d &lt;- GAMart()
bf &lt;- bamlss.frame(num ~ s(x1) + te(lon,lat), data = d)

## Create list of all parameters from "bamlss.frame".
p &lt;- parameters(bf, list = TRUE)
str(p)

## Not run: ## Estimate model.
f &lt;- list(num ~ s(x1) + te(lon,lat), sigma ~ s(x1))
b &lt;- bamlss(f, data = d, sampler = FALSE)

## Extract estimated parameters.
parameters(b)
parameters(b, list = TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='pathplot'>Plot Coefficients Paths</h2><span id='topic+pathplot'></span>

<h3>Description</h3>

<p>This is a simple wrapper function to plot coefficients paths obtained from
the boosting optimizer function <code><a href="#topic+boost">boost</a></code> and the LASSO optimizer
<code><a href="#topic+lasso">lasso</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pathplot(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pathplot_+3A_object">object</code></td>
<td>
<p>An object of class <code>"bamlss"</code>.</p>
</td></tr>
<tr><td><code id="pathplot_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+boost_plot">boost_plot</a></code> or <code><a href="#topic+lasso_plot">lasso_plot</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+boost_plot">boost_plot</a></code>, <code><a href="#topic+lasso_plot">lasso_plot</a></code>
</p>

<hr>
<h2 id='plot.bamlss'>
Plotting BAMLSS
</h2><span id='topic+plot.bamlss'></span><span id='topic+plot.bamlss.results'></span>

<h3>Description</h3>

<p>Plotting methods for objects of class <code>"bamlss"</code> and <code>"bamlss.results"</code>, which can be
used for producing effect plots of model terms, trace plots of samples or residual plots.
Note that effect plots of model terms with more than two covariates are not supported, for this
purpose use function <code><a href="#topic+predict.bamlss">predict.bamlss</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bamlss'
plot(x, model = NULL, term = NULL,
  which = "effects", parameters = FALSE,
  ask = dev.interactive(), spar = TRUE, ...)

## S3 method for class 'bamlss.results'
plot(x, model = NULL, term = NULL,
  ask = dev.interactive(), scale = 1, spar = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bamlss_+3A_x">x</code></td>
<td>
<p>An object of class <code>"bamlss"</code> or <code>"bamlss.results"</code>.</p>
</td></tr>
<tr><td><code id="plot.bamlss_+3A_model">model</code></td>
<td>
<p>Character or integer. For which model should the plots be created?</p>
</td></tr>
<tr><td><code id="plot.bamlss_+3A_term">term</code></td>
<td>
<p>Character or integer. For which model term should a plot be created?</p>
</td></tr>
<tr><td><code id="plot.bamlss_+3A_which">which</code></td>
<td>
<p>Character or integer, selects the type of plot: <code>"effects"</code> produces
effect plots of smooth model terms, <code>"samples"</code> shows trace plots of samples,
<code>"hist-resid"</code> shows a histogram of residuals (see also
<code><a href="#topic+residuals.bamlss">residuals.bamlss</a></code> for the different available types), <code>"qq-resid"</code> shows
a quantile-quantile plot of residuals, <code>"scatter-resid"</code> shows a scatter plot of
residuals with fitted values for the distribution mean (if available in the family object),
<code>"max-acf"</code> shows an <code><a href="stats.html#topic+acf">acf</a></code> plot of the maximum autocorrelation of
all parameter samples.</p>
</td></tr>
<tr><td><code id="plot.bamlss_+3A_parameters">parameters</code></td>
<td>
<p>For trace plots of parameters, should corresponding parameter values as returned
from an optimizer function (e.g., <code><a href="#topic+opt_bfit">opt_bfit</a></code>) be added as horizontal lines?</p>
</td></tr>
<tr><td><code id="plot.bamlss_+3A_ask">ask</code></td>
<td>
<p>For multiple plots, the user is asked to show the next plot.</p>
</td></tr>
<tr><td><code id="plot.bamlss_+3A_scale">scale</code></td>
<td>
<p>If set to <code>1</code>, effect plots all have the same scale on the y-axis. If set to
<code>0</code> each effect plot has its own scale for the y-axis.</p>
</td></tr>
<tr><td><code id="plot.bamlss_+3A_spar">spar</code></td>
<td>
<p>Should graphical parameters be set?</p>
</td></tr>
<tr><td><code id="plot.bamlss_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="#topic+plot2d">plot2d</a></code>, <code><a href="#topic+plot3d">plot3d</a></code>,
<code><a href="#topic+sliceplot">sliceplot</a></code>, <code><a href="#topic+plotblock">plotblock</a></code>, <code><a href="#topic+plotmap">plotmap</a></code> and
<code><a href="#topic+residuals.bamlss">residuals.bamlss</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+bamlss">bamlss</a></code>, <code><a href="#topic+results.bamlss.default">results.bamlss.default</a></code>, <code><a href="#topic+residuals.bamlss">residuals.bamlss</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ## Generate some data.
d &lt;- GAMart()

## Model formula.
f &lt;- list(
  num ~ s(x1) + s(x2) + s(x3) + te(lon,lat),
  sigma ~ s(x2) + te(lon,lat)
)

## Estimate model.
b &lt;- bamlss(f, data = d)

## Effect plots
plot(b, ask = FALSE)
plot(b, model = "mu")
plot(b, model = "sigma", term = "te(lon,lat)")

## Trace plots.
plot(b, which = "samples")

## Residual plots.
plot(b, which = 3:4)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot2d'>
Plot 2D Effects
</h2><span id='topic+plot2d'></span><span id='topic+plotnonp'></span>

<h3>Description</h3>

<p>Function to plot simple 2D graphics for univariate effects/functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot2d(x, residuals = FALSE, rug = FALSE, jitter = TRUE, 
  col.residuals = NULL, col.lines = NULL, col.polygons = NULL, 
  col.rug = NULL, c.select = NULL, fill.select = NULL, 
  data = NULL, sep = "", month = NULL, year = NULL,
  step = 12, shift = NULL, trans = NULL,
  scheme = 2, s2.col = NULL, grid = 50, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot2d_+3A_x">x</code></td>
<td>
<p>A matrix or data frame, containing the covariate for which the effect should be plotted 
in the first column and at least a second column containing the effect. Another possibility is
to specify the plot via a <code>formula</code>, e.g. <code>y ~ x</code>, see the examples.
<code>x</code> may also be a character file path to the data to be used for plotting.</p>
</td></tr>
<tr><td><code id="plot2d_+3A_residuals">residuals</code></td>
<td>
<p>If set to <code>TRUE</code>, residuals may also be plotted if available.
Residuals must be supplied as an <code><a href="base.html#topic+attr">attr</a></code>ibute named <code>"residuals"</code>, which
is a matrix or data frame where the first column is the covariate and the second column
the residuals.</p>
</td></tr>
<tr><td><code id="plot2d_+3A_rug">rug</code></td>
<td>
<p>Add a <code><a href="graphics.html#topic+rug">rug</a></code> to the plot.</p>
</td></tr>
<tr><td><code id="plot2d_+3A_jitter">jitter</code></td>
<td>
<p>If set to <code>TRUE</code> a <code><a href="base.html#topic+jitter">jitter</a></code>ed 
<code><a href="graphics.html#topic+rug">rug</a></code> plot is added.</p>
</td></tr>
<tr><td><code id="plot2d_+3A_col.residuals">col.residuals</code></td>
<td>
<p>The color of the partial residuals.</p>
</td></tr>
<tr><td><code id="plot2d_+3A_col.lines">col.lines</code></td>
<td>
<p>The color of the lines.</p>
</td></tr>
<tr><td><code id="plot2d_+3A_col.polygons">col.polygons</code></td>
<td>
<p>Specify the background color of polygons, if <code>x</code> has at least 3 columns, 
i.e. column 2 and 3 can form one polygon.</p>
</td></tr>
<tr><td><code id="plot2d_+3A_col.rug">col.rug</code></td>
<td>
<p>Specify the color of the rug representation.</p>
</td></tr>
<tr><td><code id="plot2d_+3A_c.select">c.select</code></td>
<td>
<p>Integer vector of maximum length of columns of <code>x</code>, selects the 
columns of the resulting data matrix that should be used for plotting. E.g. if <code>x</code> has 5
columns, then <code>c.select = c(1, 2, 5)</code> will select column 1, 2 and 5 for plotting. Note that
first element of <code>c.select</code> should always be the column that holds the variable for the
x-axis.</p>
</td></tr>
<tr><td><code id="plot2d_+3A_fill.select">fill.select</code></td>
<td>
<p>Integer vector, select pairwise the columns of the resulting data matrix 
that should form one polygon with a certain background color specified in argument <code>col</code>. 
E.g. <code>x</code> has three columns, or is specified with formula <code>f1 + f2 ~ x</code>, then setting 
<code>fill.select = c(0, 1, 1)</code> will draw a polygon with <code>f1</code> and <code>f2</code> as boundaries. 
If <code>x</code> has five columns or the formula is e.g. <code>f1 + f2 + f3 + f4 ~ x</code>, then setting
<code>fill.select = c(0, 1, 1, 2, 2)</code>, the pairs <code>f1</code>, <code>f2</code> and <code>f3</code>, <code>f4</code>
are selected to form two polygons.</p>
</td></tr>
<tr><td><code id="plot2d_+3A_data">data</code></td>
<td>
<p>If <code>x</code> is a formula, a <code>data.frame</code> or <code>list</code>. By default the variables 
are taken from <code>environment(x)</code>: typically the environment from which <code>plot2d</code> is 
called. Note that <code>data</code> may also be a character file path to the data.</p>
</td></tr>
<tr><td><code id="plot2d_+3A_sep">sep</code></td>
<td>
<p>The field separator character when <code>x</code> or <code>data</code> is a character, see function
<code><a href="utils.html#topic+read.table">read.table</a></code>.</p>
</td></tr>
<tr><td><code id="plot2d_+3A_month">month</code>, <code id="plot2d_+3A_year">year</code>, <code id="plot2d_+3A_step">step</code></td>
<td>
<p>Provide specific annotation for plotting estimation results for temporal
variables. <code>month</code> and <code>year</code> define the minimum time point whereas step specifies the
type of temporal data with <code>step = 4</code>, <code>step = 2</code> and <code>step = 1</code> corresponding to
quarterly, half yearly and yearly data.</p>
</td></tr>
<tr><td><code id="plot2d_+3A_shift">shift</code></td>
<td>
<p>Numeric constant to be added to the smooth before plotting.</p>
</td></tr>
<tr><td><code id="plot2d_+3A_trans">trans</code></td>
<td>
<p>Function to be applied to the smooth before plotting, e.g., to transform the
plot to the response scale.</p>
</td></tr>
<tr><td><code id="plot2d_+3A_scheme">scheme</code></td>
<td>
<p>Sets the plotting scheme for polygons, possible values are <code>1</code> and <code>2</code>.</p>
</td></tr>
<tr><td><code id="plot2d_+3A_s2.col">s2.col</code></td>
<td>
<p>The color for the second plotting scheme.</p>
</td></tr>
<tr><td><code id="plot2d_+3A_grid">grid</code></td>
<td>
<p>Integer, specifies the number of polygons for the second plotting scheme.</p>
</td></tr>
<tr><td><code id="plot2d_+3A_...">...</code></td>
<td>
<p>Other graphical parameters, please see the details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For 2D plots the following graphical parameters may be specified additionally: 
</p>

<ul>
<li> <p><code>cex</code>: Specify the size of partial residuals,
</p>
</li>
<li> <p><code>lty</code>: The line type for each column that is plotted, e.g. <code>lty = c(1, 2)</code>,
</p>
</li>
<li> <p><code>lwd</code>: The line width for each column that is plotted, e.g. <code>lwd = c(1, 2)</code>,
</p>
</li>
<li> <p><code>poly.lty</code>: The line type to be used for the polygons,
</p>
</li>
<li> <p><code>poly.lwd</code>: The line width to be used for the polygons,
</p>
</li>
<li> <p><code>density</code> <code>angle</code>, <code>border</code>: See <code><a href="graphics.html#topic+polygon">polygon</a></code>,
</p>
</li>
<li> <p><code>...</code>: Other graphical parameters, see function <code><a href="graphics.html#topic+plot">plot</a></code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+plot3d">plot3d</a></code>, <code><a href="#topic+plotmap">plotmap</a></code>,
<code><a href="#topic+plotblock">plotblock</a></code>, <code><a href="#topic+sliceplot">sliceplot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate some data.
set.seed(111)
n &lt;- 500
## Regressor.
d &lt;- data.frame(x = runif(n, -3, 3))

## Response. 
d$y &lt;- with(d, 10 + sin(x) + rnorm(n, sd = 0.6))

## Not run: ## Estimate model.
b &lt;- bamlss(y ~ s(x), data = d)
summary(b)

## Plot estimated effect.
plot(b)
plot(b, rug = FALSE)

## Extract fitted values.
f &lt;- fitted(b, model = "mu", term = "s(x)")
f &lt;- cbind(d["x"], f)

## Now use plot2d.
plot2d(f)
plot2d(f, fill.select = c(0, 1, 0, 1))
plot2d(f, fill.select = c(0, 1, 0, 1), lty = c(2, 1, 2))
plot2d(f, fill.select = c(0, 1, 0, 1), lty = c(2, 1, 2),
  scheme = 2)

## Variations.
plot2d(sin(x) ~ x, data = d)
d$f &lt;- with(d, sin(d$x))
plot2d(f ~ x, data = d)
d$f1 &lt;- with(d, f + 0.1)
d$f2 &lt;- with(d, f - 0.1)
plot2d(f1 + f2 ~ x, data = d)
plot2d(f1 + f2 ~ x, data = d, fill.select = c(0, 1, 1), lty = 0)
plot2d(f1 + f2 ~ x, data = d, fill.select = c(0, 1, 1), lty = 0,
  density = 20, poly.lty = 1, poly.lwd = 2)
plot2d(f1 + f + f2 ~ x, data = d, fill.select = c(0, 1, 0, 1), 
  lty = c(0, 1, 0), density = 20, poly.lty = 1, poly.lwd = 2)

## End(Not run)</code></pre>

<hr>
<h2 id='plot3d'>
Plot 3D Effects
</h2><span id='topic+plot3d'></span>

<h3>Description</h3>

<p>Function to plot 3D graphics or image and/or contour plots for bivariate effects/functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot3d(x, residuals = FALSE, col.surface = NULL, 
  ncol = 99L, swap = FALSE, col.residuals = NULL, col.contour = NULL, 
  c.select = NULL, grid = 30L, image = FALSE, contour = FALSE, 
  legend = TRUE, cex.legend = 1, breaks = NULL, range = NULL, 
  digits = 2L, d.persp = 1L, r.persp = sqrt(3), outscale = 0,
  data = NULL, sep = "", shift = NULL, trans = NULL,
  type = "mba", linear = FALSE, extrap = FALSE,
  k = 40, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot3d_+3A_x">x</code></td>
<td>
<p>A matrix or data frame, containing the covariates for which the effect should be plotted 
in the first and second column and at least a third column containing the effect. Another
possibility is to specify the plot via a <code>formula</code>, 
e.g. for simple plotting of bivariate surfaces <code>z ~ x + y</code>, see the examples.
<code>x</code> may also be a character file path to the data to be used for plotting.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_residuals">residuals</code></td>
<td>
<p>If set to <code>TRUE</code>, residuals may also be plotted if available. Residuals must
be supplied as an <code><a href="base.html#topic+attr">attr</a></code>ibute named <code>"residuals"</code>, which
is a matrix or data frame where the first two columns are covariates and the third column
the residuals.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_col.surface">col.surface</code></td>
<td>
<p>The color of the surface, may also be a function, e.g. 
<code>col.surface = heat.colors</code>.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_ncol">ncol</code></td>
<td>
<p>the number of different colors that should be generated, if <code>col.surface</code> is a 
function.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_swap">swap</code></td>
<td>
<p>If set to <code>TRUE</code> colors will be represented in reverse order.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_col.residuals">col.residuals</code></td>
<td>
<p>The color of the partial residuals, or if <code>contour = TRUE</code> the color of the
contour lines.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_col.contour">col.contour</code></td>
<td>
<p>The color of the contour lines.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_c.select">c.select</code></td>
<td>
<p>Integer vector of maximum length of columns of <code>x</code>, selects the 
columns of the resulting data matrix that should be used for plotting. E.g. if <code>x</code> has 5
columns, then <code>c.select = c(1, 2, 5)</code> will select column 1, 2 and 5 for plotting. 
If <code>c.select = 95</code> or <code>c.select = 80</code>, function <code>plot3d</code> will search for the
corresponding columns to plot a 95<code class="reqn">\%</code> or 80<code class="reqn">\%</code> confidence surfaces respectively. Note
that if e.g. <code>c.select = c(1, 2)</code>, <code>plot3d</code> will use columns 1 + 2 and 2 + 2 for 
plotting.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_grid">grid</code></td>
<td>
<p>The grid size of the surface(s).</p>
</td></tr>
<tr><td><code id="plot3d_+3A_image">image</code></td>
<td>
<p>If set to <code>TRUE</code>, an <code><a href="fields.html#topic+image.plot">image.plot</a></code> is drawn.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_contour">contour</code></td>
<td>
<p>If set to <code>TRUE</code>, a <code><a href="graphics.html#topic+contour">contour</a></code> plot is drawn.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_legend">legend</code></td>
<td>
<p>If <code>image = TRUE</code> an additional legend may be added to the plot.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_cex.legend">cex.legend</code></td>
<td>
<p>The expansion factor for the legend text, see <code><a href="graphics.html#topic+text">text</a></code>.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_breaks">breaks</code></td>
<td>
<p>A set of breakpoints for the colors: must give one more breakpoint than 
<code>ncol</code>.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_range">range</code></td>
<td>
<p>Specifies a certain range values should be plotted for.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_digits">digits</code></td>
<td>
<p>Specifies the legend decimal places.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_d.persp">d.persp</code></td>
<td>
<p>See argument <code>d</code> in function <code><a href="graphics.html#topic+persp">persp</a></code>.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_r.persp">r.persp</code></td>
<td>
<p>See argument <code>r</code> in function <code><a href="graphics.html#topic+persp">persp</a></code>.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_outscale">outscale</code></td>
<td>
<p>Scales the outer ranges of <code>x</code> and <code>z</code> limits used for interpolation.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_data">data</code></td>
<td>
<p>If <code>x</code> is a <code>formula</code>, a <code>data.frame</code> or <code>list</code>. By default the 
variables are taken from <code>environment(x)</code>: typically the environment from which 
<code>plot3d</code> is called. Note that <code>data</code> may also be a character file path to the data.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_sep">sep</code></td>
<td>
<p>The field separator character when <code>x</code> or <code>data</code> is a character, see function
<code><a href="utils.html#topic+read.table">read.table</a></code>.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_shift">shift</code></td>
<td>
<p>Numeric constant to be added to the smooth before plotting.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_trans">trans</code></td>
<td>
<p>Function to be applied to the smooth before plotting, e.g., to transform the
plot to the response scale.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_type">type</code></td>
<td>
<p>Character, which type of interpolation method should be used. The default is
<code>type = "akima"</code>, see function <code><a href="akima.html#topic+interp">interp</a></code>. The two other options are
<code>type = "mba"</code>, which calls function <code><a href="MBA.html#topic+mba.surf">mba.surf</a></code> of package <span class="pkg">MBA</span>, or
<code>type = "mgcv"</code>, which uses a spatial smoother withing package <span class="pkg">mgcv</span> for interpolation.
The last option is definitely the slowest, since a full regression model needs to be estimated.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_linear">linear</code></td>
<td>
<p>Logical, should linear interpolation be used withing function
<code><a href="akima.html#topic+interp">interp</a></code>?</p>
</td></tr>
<tr><td><code id="plot3d_+3A_extrap">extrap</code></td>
<td>
<p>Logical, should interpolations be computed outside the observation area
(i.e., extrapolated)?</p>
</td></tr>
<tr><td><code id="plot3d_+3A_k">k</code></td>
<td>
<p>Integer, the number of basis functions to be used to compute the interpolated surface
when <code>type = "mgcv"</code>.</p>
</td></tr>
<tr><td><code id="plot3d_+3A_...">...</code></td>
<td>
<p>Parameters passed to <code><a href="#topic+colorlegend">colorlegend</a></code> if an image plot with legend is drawn,
also other graphical parameters, please see the details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For 3D plots the following graphical parameters may be specified additionally: 
</p>

<ul>
<li> <p><code>cex</code>: Specify the size of partial residuals,
</p>
</li>
<li> <p><code>col</code>: It is possible to specify the color for the surfaces if <code>se &gt; 0</code>, then 
e.g. <code>col = c("green", "black", "red")</code>,
</p>
</li>
<li> <p><code>pch</code>: The plotting character of the partial residuals,
</p>
</li>
<li> <p><code>...</code>: Other graphical parameters passed functions <code><a href="graphics.html#topic+persp">persp</a></code>,
<code><a href="fields.html#topic+image.plot">image.plot</a></code> and <code><a href="graphics.html#topic+contour">contour</a></code>.
</p>
</li></ul>



<h3>Note</h3>

<p>Function <code>plot3d</code> can use the <span class="pkg">akima</span> package to construct smooth interpolated
surfaces, therefore, package <span class="pkg">akima</span> needs to be installed. The <span class="pkg">akima</span> package has an ACM
license that restricts applications to non-commercial usage, see
</p>
<p><a href="https://www.acm.org/publications/policies/software-copyright-notice">https://www.acm.org/publications/policies/software-copyright-notice</a>
</p>
<p>Function <code>plot3d</code> prints a note referring to the ACM license. This note can be suppressed by
setting
</p>
<p><code>options("use.akima" = TRUE)</code> 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+colorlegend">colorlegend</a></code>, <code><a href="#topic+plot2d">plot2d</a></code>, <code><a href="#topic+plotmap">plotmap</a></code>,
<code><a href="#topic+plotblock">plotblock</a></code>, <code><a href="#topic+sliceplot">sliceplot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate some data.
set.seed(111)
n &lt;- 500

## Regressors.
d &lt;- data.frame(z = runif(n, -3, 3), w = runif(n, 0, 6))

## Response.
d$y &lt;- with(d, 1.5 + cos(z) * sin(w) + rnorm(n, sd = 0.6))

## Not run: ## Estimate model.
b &lt;- bamlss(y ~ s(z,w), data = d)
summary(b)

## Plot estimated effect.
plot(b, model = "mu", term = "s(z,w)")

## Extract fitted values.
f &lt;- fitted(b, model = "mu", term = "s(z,w)", intercept = FALSE)
f &lt;- cbind(d[, c("z", "w")], f)

## Now use plot3d().
plot3d(f)
plot3d(f, swap = TRUE)
plot3d(f, grid = 100, border = NA)

## Only works if columns are named with
## '2.5
plot3d(f, c.select = 95, border = c("red", NA, "green"),
  col.surface = c(1, NA, 1), resid = TRUE, cex.resid = 0.2)

## Now some image and contour.
# plot3d(f, image = TRUE, legend = FALSE)
# plot3d(f, image = TRUE, legend = TRUE)
# plot3d(f, image = TRUE, contour = TRUE)
# plot3d(f, image = TRUE, contour = TRUE, swap = TRUE)
# plot3d(f, image = TRUE, contour = TRUE, col.contour = "white")
# plot3d(f, contour = TRUE)
# plot3d(f, image = TRUE, contour = TRUE, c.select = 3)
# plot3d(f, image = TRUE, contour = TRUE, c.select = "Mean")
# plot3d(f, image = TRUE, contour = TRUE, c.select = "97.5

## End(Not run)

## Variations.
d$f1 &lt;- with(d, sin(z) * cos(w))
with(d, plot3d(cbind(z, w, f1)))

## Same with formula. 
plot3d(sin(z) * cos(w) ~ z + w, zlab = "f(z,w)", data = d)
plot3d(sin(z) * cos(w) ~ z + w, zlab = "f(z,w)", data = d, 
  ticktype = "detailed")

## Play with palettes.
plot3d(sin(z) * cos(w) ~ z + w, col.surface = heat.colors, data = d)
plot3d(sin(z) * cos(w) ~ z + w, col.surface = topo.colors, data = d)
plot3d(sin(z) * cos(w) ~ z + w, col.surface = cm.colors, data = d)
plot3d(sin(z) * cos(w) ~ z + w, col.surface = rainbow, data = d)
plot3d(sin(z) * cos(w) ~ z + w, col.surface = terrain.colors, data = d)

plot3d(sin(z) * cos(w) ~ z + w, col.surface = rainbow_hcl, data = d)
plot3d(sin(z) * cos(w) ~ z + w, col.surface = diverge_hcl, data = d)
plot3d(sin(z) * cos(w) ~ z + w, col.surface = sequential_hcl, data = d)

plot3d(sin(z) * cos(w) ~ z + w, 
  col.surface = rainbow_hcl(n = 99, c = 300, l = 80, start = 0, end = 100), 
  data = d)
# plot3d(sin(z) * cos(w) ~ z + w, 
#  col.surface = rainbow_hcl(n = 99, c = 300, l = 80, start = 0, end = 100), 
#  image = TRUE, grid = 200, data = d)
</code></pre>

<hr>
<h2 id='plotblock'>
Factor Variable and Random Effects Plots
</h2><span id='topic+plotblock'></span>

<h3>Description</h3>

<p>Function to plot effects for model terms including factor, or group variables for random effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotblock(x, residuals = FALSE, range = c(0.3, 0.3), 
  col.residuals = "black", col.lines = "black", c.select = NULL, 
  fill.select = NULL , col.polygons = NULL, data = NULL,
  shift = NULL, trans = NULL, labels = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotblock_+3A_x">x</code></td>
<td>
<p>Either a <code>list</code> of length of the unique factors, where each <code>list</code> element 
contains the estimated effects for one factor as a matrix, or 
one data matrix with first column as the group or factor variable. Also formulas are accepted, 
e.g it is possible to specify the plot with <code>f ~ x</code> or <code>f1 + f2 ~ x</code>. By convention, 
the covariate for which effects should be plotted, is always in the first column in the 
resulting data matrix, that is used for plotting, i.e. in the second formula example, the data 
matrix is <code>cbind(x, f1, f2)</code>, also see argument <code>c.select</code> and <code>fill.select</code>.</p>
</td></tr>
<tr><td><code id="plotblock_+3A_residuals">residuals</code></td>
<td>
<p>If set to <code>TRUE</code>, residuals will be plotted if available. Residuals may be
set as an <code><a href="base.html#topic+attr">attr</a></code>ibute of <code>x</code> named 
<code>"residuals"</code>, where the residuals must be a matrix with first column 
specifying the covariate, and second column the residuals that should be plotted.</p>
</td></tr>
<tr><td><code id="plotblock_+3A_range">range</code></td>
<td>
<p>Numeric vector, specifying the left and right bound of the block.</p>
</td></tr>
<tr><td><code id="plotblock_+3A_col.residuals">col.residuals</code></td>
<td>
<p>The color of the partial residuals.</p>
</td></tr>
<tr><td><code id="plotblock_+3A_col.lines">col.lines</code></td>
<td>
<p>Vector of maximum length of columns of <code>x</code> minus 1, specifying the color of 
the lines.</p>
</td></tr>
<tr><td><code id="plotblock_+3A_c.select">c.select</code></td>
<td>
<p>Integer vector of maximum length of columns of <code>x</code>, selects the 
columns of the resulting data matrix that should be used for plotting. E.g. if <code>x</code> has 5 
columns, then <code>c.select = c(1, 2, 5)</code> will select column 1, 2 and 5 for plotting. Note that 
first element of <code>c.select</code> should always be 1, since this is the column of the covariate 
the effect is plotted for.</p>
</td></tr>
<tr><td><code id="plotblock_+3A_fill.select">fill.select</code></td>
<td>
<p>Integer vector, select pairwise the columns of the resulting data matrix 
that should form one polygon with a certain background color specified in argument <code>col</code>. 
E.g. <code>x</code> has three columns, or is specified with formula <code>f1 + f2 ~ x</code>, then setting 
<code>fill.select = c(0, 1, 1)</code> will draw a polygon with <code>f1</code> and <code>f2</code> as boundaries. 
If <code>x</code> has five columns or the formula is e.g. <code>f1 + f2 + f3 + f4 ~ x</code>, then setting
<code>fill.select = c(0, 1, 1, 2, 2)</code>, the pairs <code>f1</code>, <code>f2</code> and <code>f3</code>, <code>f4</code>
are selected to form two polygons.</p>
</td></tr>
<tr><td><code id="plotblock_+3A_col.polygons">col.polygons</code></td>
<td>
<p>Specify the background color for the upper and lower confidence bands, e.g. 
<code>col = c("green", "red")</code>.</p>
</td></tr>
<tr><td><code id="plotblock_+3A_data">data</code></td>
<td>
<p>If <code>x</code> is a formula, a <code>data.frame</code> or <code>list</code>. By default the variables 
are taken from <code>environment(x)</code>: typically the environment from which <code>plotblock</code> is 
called.</p>
</td></tr>
<tr><td><code id="plotblock_+3A_shift">shift</code></td>
<td>
<p>Numeric constant to be added to the smooth before plotting.</p>
</td></tr>
<tr><td><code id="plotblock_+3A_trans">trans</code></td>
<td>
<p>Function to be applied to the smooth before plotting, e.g., to transform the
plot to the response scale.</p>
</td></tr>
<tr><td><code id="plotblock_+3A_labels">labels</code></td>
<td>
<p>Character, labels for the factor levels.</p>
</td></tr>
<tr><td><code id="plotblock_+3A_...">...</code></td>
<td>
<p>Graphical parameters, please see the details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>plotblock</code> draws for every factor or group the effect as a &quot;block&quot; in one graphic, 
i.e., similar to boxplots, estimated fitted effects, e.g., containing quantiles of MCMC samples,
are drawn as one block, where the upper lines represent upper quantiles, the 
middle line the mean or median, and lower lines lower quantiles, also see the examples. The 
following graphical parameters may be supplied additionally:
</p>

<ul>
<li> <p><code>cex</code>: Specify the size of partial residuals,
</p>
</li>
<li> <p><code>lty</code>: The line type for each column that is plotted, e.g. <code>lty = c(1, 2)</code>,
</p>
</li>
<li> <p><code>lwd</code>: The line width for each column that is plotted, e.g. <code>lwd = c(1, 2)</code>,
</p>
</li>
<li> <p><code>poly.lty</code>: The line type to be used for the polygons,
</p>
</li>
<li> <p><code>poly.lwd</code>: The line width to be used for the polygons,
</p>
</li>
<li> <p><code>density</code> <code>angle</code>, <code>border</code>: See <code><a href="graphics.html#topic+polygon">polygon</a></code>,
</p>
</li>
<li> <p><code>...</code>: Other graphical parameters, see function <code><a href="graphics.html#topic+plot">plot</a></code>.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+plot2d">plot2d</a></code>, <code><a href="#topic+plot3d">plot3d</a></code>,
<code><a href="#topic+plotmap">plotmap</a></code>, <code><a href="#topic+sliceplot">sliceplot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate some data.
set.seed(111)
n &lt;- 500

## Regressors.
d &lt;- data.frame(fac = factor(rep(1:10, n/10)))

## Response.
d$y &lt;- with(d, 1.5 + rnorm(10, sd = 0.6)[fac] + 
  rnorm(n, sd = 0.6))

## Not run: ## Estimate model.
b &lt;- bamlss(y ~ s(fac,bs="re"), data = d)
summary(b)

## Plot random effects.
plot(b)

## Extract fitted values.
f &lt;- fitted(b, model = "mu", term = "fac")
f &lt;- cbind(d["fac"], f)

## Now use plotblock.
plotblock(f)

## Variations.
plotblock(f, fill.select = c(0, 1, 0, 1), col.poly = "red")
plotblock(f, fill.select = c(0, 1, 0, 1), col.poly = "lightgray",
  lty = c(2, 1, 2), lwd = c(2, 1, 2))

## End(Not run)

## More examples.
plotblock(y ~ fac, data = d, range = c(0.45, 0.45))

d &lt;- data.frame(fac = factor(rep(1:10, n/10)))
d$y &lt;- with(d, c(2.67, 5, 6, 3, 4, 2, 6, 7, 9, 7.5)[fac])
plotblock(y ~ fac, data = d)
plotblock(cbind(y - 0.1, y + 0.1) ~ fac, data = d)
</code></pre>

<hr>
<h2 id='plotmap'>
Plot Maps
</h2><span id='topic+plotmap'></span>

<h3>Description</h3>

<p>The function takes a <code><a href="base.html#topic+list">list</a></code> polygons and draws the corresponding map. Different 
colors for each polygon can be used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotmap(map, x = NA, id = NULL, select = NULL,
  legend = TRUE, names = FALSE, values = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotmap_+3A_map">map</code></td>
<td>
<p>The map to be plotted, usually an object that inherits from
<code><a href="sp.html#topic+SpatialPolygons">SpatialPolygons</a></code>, but may also be a list of polygons, i.e., each list
entry is a matrix with x- and y-coordinates.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_x">x</code></td>
<td>
<p>A vector, data.frame or matrix. In the latter case <code>x</code> should have two columns,
one column that is the region identifier and one that contains the values to be plotted.
In case <code>x</code> is a data.frame, the function searches for <code>"character"</code> or
<code>"factor"</code> columns for the region identifier. If <code>x</code> is a matrix, the second
column of <code>x</code> is supposed to be the region identifier. If <code>x = NA</code> and
<code>map</code> is an object of class <code>"SpatialPolygonsDataFrame"</code> only the polygons
will be plotted without using the data.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_id">id</code></td>
<td>
<p>If argument <code>x</code> is a vector, argument <code>id</code> should contain the region identifier
vector.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_select">select</code></td>
<td>
<p>Select the column of the data in <code>x</code> which should be used for plotting, may
be an integer or character with the corresponding column name.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_legend">legend</code></td>
<td>
<p>Should a color legend be added to the plot, see also function <code><a href="#topic+colorlegend">colorlegend</a></code>.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_names">names</code></td>
<td>
<p>If set to <code>TRUE</code> the name for each polygon will also be plotted at the centroids
of the corresponding polygons.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_values">values</code></td>
<td>
<p>If set to <code>TRUE</code> the corresponding values for each polygon will also be plotted 
at the centroids of the polygons.</p>
</td></tr>
<tr><td><code id="plotmap_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to <code><a href="#topic+colorlegend">colorlegend</a></code> and others, e.g. change the 
<code>border</code> of the polygons and <code>density</code> (<code>mdensity</code> for missing regions in <code>id</code>),
see <code><a href="graphics.html#topic+polygon">polygon</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+plot2d">plot2d</a></code>, <code><a href="#topic+plot3d">plot3d</a></code>,
<code><a href="#topic+sliceplot">sliceplot</a></code>, <code><a href="#topic+plotblock">plotblock</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from mgcv ?mrf.
## Load Columbus Ohio crime data (see ?columbus for details and credits).
data("columb", package = "mgcv")
data("columb.polys", package = "mgcv")

## Plot the map.
plotmap(columb.polys)

## Plot aggregated data.
a &lt;- with(columb, aggregate(crime,
  by = list("district" = district), FUN = mean))

plotmap(columb.polys, x = a$x, id = a$district)
plotmap(columb.polys, x = a$x, id = a$district,
  pos = "topleft")
plotmap(columb.polys, x = a$x, id = a$district,
  pos = "topleft", side.legend = 2)
plotmap(columb.polys, x = a$x, id = a$district,
  pos = "topleft", side.legend = 2, side.ticks = 2)
plotmap(columb.polys, x = a$x, id = a$district,
  pos = "topleft", side.legend = 2, side.ticks = 2,
  col = heat_hcl, swap = TRUE)
plotmap(columb.polys, x = a$x, id = a$district,
  pos = "topleft", side.legend = 2, side.ticks = 2,
  col = heat_hcl, swap = TRUE, range = c(10, 50))
plotmap(columb.polys, x = a$x, id = a$district,
  pos = "topleft", side.legend = 2, side.ticks = 2,
  col = heat_hcl(5), swap = TRUE, range = c(10, 50),
  lrange = c(0, 60))
</code></pre>

<hr>
<h2 id='predict.bamlss'>
BAMLSS Prediction 
</h2><span id='topic+predict.bamlss'></span>

<h3>Description</h3>

<p>Takes a fitted <code><a href="#topic+bamlss">bamlss</a></code> object and computes predictions. Predictions can be based on
estimated parameters of optimizer functions or on samples returned from sampler functions.
It is possible to compute predictions on multiple cores using the
<code><a href="parallel.html#topic+parallel">parallel</a></code> and to chunk predictions to save computation time and memory
storage. Predictions can be computed for full distributional parameters or specific model
terms. If a <code>link{bamlss}</code> model was fitted on multiple cores, i.e., the samples
are provided as <code>link{mcmc.list}</code> where each list entry represents samples from one
core, function <code>predict.bamlss()</code> computes combined predictions based on samples of all
cores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bamlss'
predict(object, newdata, model = NULL, term = NULL,
  match.names = TRUE, intercept = TRUE, type = c("link", "parameter"),
  FUN = function(x) { mean(x, na.rm = TRUE) }, trans = NULL,
  what = c("samples", "parameters"), nsamps = NULL,
  verbose = FALSE, drop = TRUE,
  cores = NULL, chunks = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.bamlss_+3A_object">object</code></td>
<td>
<p>An object of class <code>"bamlss"</code></p>
</td></tr>
<tr><td><code id="predict.bamlss_+3A_newdata">newdata</code></td>
<td>
<p>A data frame or list containing the values of the model
covariates at which predictions are required. Note that depending
on argument <code>term</code>, only covariates that are needed by the
corresponding model terms need to be supplied.</p>
</td></tr>
<tr><td><code id="predict.bamlss_+3A_model">model</code></td>
<td>
<p>Character or integer, specifies the model for which predictions should be computed.</p>
</td></tr>
<tr><td><code id="predict.bamlss_+3A_term">term</code></td>
<td>
<p>Character or integer, specifies the model terms for which predictions are required.
Note that, e.g., <code>term = c("s(x1)", "x2")</code> will compute the combined prediction
<code>s(x1) + x2</code>.</p>
</td></tr>
<tr><td><code id="predict.bamlss_+3A_match.names">match.names</code></td>
<td>
<p>Should partial string matching be used to select the <code>term</code>s for
prediction. Note that, e.g., <code>term = "x1"</code> will select all terms including <code>"x1"</code> if
<code>match.names = TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict.bamlss_+3A_intercept">intercept</code></td>
<td>
<p>Should the intercept be included?</p>
</td></tr>
<tr><td><code id="predict.bamlss_+3A_type">type</code></td>
<td>
<p>If <code>type = "link"</code> the predictor of the corresponding <code>model</code>
is returned. If <code>type = "parameter"</code> predictions on the distributional parameter scale
are returned.</p>
</td></tr>
<tr><td><code id="predict.bamlss_+3A_fun">FUN</code></td>
<td>
<p>A function that should be applied on the samples of predictors or
parameters, depending on argument <code>type</code>.</p>
</td></tr>
<tr><td><code id="predict.bamlss_+3A_trans">trans</code></td>
<td>
<p>A transformer function or named list of transformer functions that computes
transformed predictions. If <code>trans</code> is a list, the list names must match the names
of the parameters of the <code><a href="#topic+bamlss.family">bamlss.family</a></code>.</p>
</td></tr>
<tr><td><code id="predict.bamlss_+3A_what">what</code></td>
<td>
<p>Predictions can be computed from samples or estimated parameters of optimizer
functions. If no samples are available the default is to use estimated parameters.</p>
</td></tr>
<tr><td><code id="predict.bamlss_+3A_nsamps">nsamps</code></td>
<td>
<p>If the fitted <code><a href="#topic+bamlss">bamlss</a></code> object contains samples of parameters,
computing predictions may take quite some time. Therefore, to get a first feeling it can
be useful to compute predictions only based on <code>nsamps</code> samples, i.e., <code>nsamps</code>
specifies the number of samples which are extracted on equidistant intervals.</p>
</td></tr>
<tr><td><code id="predict.bamlss_+3A_verbose">verbose</code></td>
<td>
<p>If predictions are chunked, information on the prediction process can be printed.</p>
</td></tr>
<tr><td><code id="predict.bamlss_+3A_drop">drop</code></td>
<td>
<p>If predictions for only one <code>model</code> are returned, the list structure is dropped.</p>
</td></tr>
<tr><td><code id="predict.bamlss_+3A_cores">cores</code></td>
<td>
<p>Specifies the number of cores that should be used for prediction. Note that
this functionality is based on the <code><a href="parallel.html#topic+parallel">parallel</a></code> package.</p>
</td></tr>
<tr><td><code id="predict.bamlss_+3A_chunks">chunks</code></td>
<td>
<p>Should computations be split into <code>chunks</code>? Prediction is then processed
sequentially.</p>
</td></tr>
<tr><td><code id="predict.bamlss_+3A_...">...</code></td>
<td>
<p>Arguments passed to prediction functions that are part of a <code><a href="#topic+bamlss.family">bamlss.family</a></code>
object, i.e., the objects has a <code>$predict()</code> function that should be used instead.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Depending on arguments <code>model</code>, <code>FUN</code> and the structure of the <code><a href="#topic+bamlss">bamlss</a></code>
model, a list of predictions or simple vectors or matrices of predictions.
</p>


<h3>See Also</h3>

<p><code>link{bamlss}</code>, <code><a href="#topic+fitted.bamlss">fitted.bamlss</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ## Generate some data.
d &lt;- GAMart()

## Model formula.
f &lt;- list(
  num ~ s(x1) + s(x2) + s(x3) + te(lon,lat),
  sigma ~ s(x1) + s(x2) + s(x3) + te(lon,lat)
)

## Estimate model.
b &lt;- bamlss(f, data = d)

## Predictions.
p &lt;- predict(b)
str(b)

## Prediction for "mu" model and term "s(x2)".
p &lt;- predict(b, model = "mu", term = "s(x2)")

## Plot effect
plot2d(p ~ x2, data = d)

## Same for "sigma" model.
p &lt;- predict(b, model = "sigma", term = "s(x2)")
plot2d(p ~ x2, data = d)

## Prediction for "mu" model and term "s(x1)" + "s(x2)"
## without intercept.
p &lt;- predict(b, model = "mu", term = c("s(x1)", "s(x2)"),
  intercept = FALSE)

## Prediction based on quantiles.
p &lt;- predict(b, model = "mu", term = "s(x2)", FUN = c95)
plot2d(p ~ x2, data = d)

## Extract samples of predictor for "s(x2)".
p &lt;- predict(b, model = "mu", term = "s(x2)",
  intercept = FALSE, FUN = function(x) { x })
print(dim(p))
plot2d(p ~ x2, data = d, col.lines = rgb(0.1, 0.1, 0.1, alpha = 0.1))

## Or using specific combinations of terms.
p &lt;- predict(b, model = "mu", term = c("s(x2)", "te(lon,lat)"),
  intercept = FALSE, FUN = function(x) { x })
head(p)

## Prediction using new data.
## Only need x3 data when predicting
## for s(x3).
nd &lt;- data.frame("x3" = seq(0, 1, length = 100))
nd &lt;- cbind(nd, predict(b, newdata = nd, term = "s(x3)"))
print(head(nd))
plot2d(mu ~ x3, data = nd)
plot2d(sigma ~ x3, data = nd)

## End(Not run)
</code></pre>

<hr>
<h2 id='randomize'>
Transform Smooth Constructs to Random Effects
</h2><span id='topic+randomize'></span><span id='topic+trans_random'></span>

<h3>Description</h3>

<p>The transformer function takes a <code><a href="#topic+bamlss.frame">bamlss.frame</a></code> object and transforms all
<code><a href="#topic+smooth.construct">smooth.construct</a></code>s into a random effects representation. Note that this
is only possible for smooth terms with a single smoothing variance. The function
is based on function <code><a href="mgcv.html#topic+smooth2random">smooth2random</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trans_random(x)
randomize(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="randomize_+3A_x">x</code></td>
<td>
<p>Object returned from function <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The decomposition is achieved by a spectral decomposition of the penalty and design matrix by
finding a basis of the null space of the penalty matrix. This feature is used, e.g., for the
<code><a href="#topic+JAGS">JAGS</a></code> sampler function. For more details see also <code><a href="mgcv.html#topic+jagam">jagam</a></code>.
</p>


<h3>Value</h3>

<p>A transformed <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>. To each <code><a href="#topic+smooth.construct">smooth.construct</a></code> model term
an element named <code>"Xf"</code>, the fixed effects design matrix, and an element <code>"rand$Xr"</code>,
the random effects design matrix, is added. In addition, for re-transforming parameters elements
<code>"trans.U"</code> and <code>"trans.D"</code> are supplied. See also function
<code><a href="mgcv.html#topic+smooth2random">smooth2random</a></code>.
</p>


<h3>References</h3>

<p>Fahrmeir L, Kneib T, Lang S, Marx B (2013). Regression - Models, Methods and Applications.
Springer-Verlag, Berlin. ISBN 978-3-642-34332-2.
</p>
<p>Wood S.N. (2006). Generalized Additive Models: An Introduction with
<span class="rlang"><b>R</b></span>. Chapman and Hall/CRC.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bamlss.frame">bamlss.frame</a></code>, <code><a href="#topic+bamlss">bamlss</a></code>, <code><a href="mgcv.html#topic+smooth2random">smooth2random</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate data.
d &lt;- GAMart()

## Create a "bamlss.frame".
bf &lt;- bamlss.frame(num ~ s(x1) + s(x2) + s(x3) + s(lon,lat), data = d)

## Structure of the "s(x1)" smooth.construct.
str(bf$x$mu$smooth.construct[["s(x1)"]])

## Transform.
bf &lt;- randomize(bf)

## New structure adding fixed
## and random effect matrices.
str(bf$x$mu$smooth.construct[["s(x1)"]])
</code></pre>

<hr>
<h2 id='rb'>Random Bits for BAMLSS</h2><span id='topic+rb'></span><span id='topic+smooth.construct.randombits.smooth.spec'></span>

<h3>Description</h3>

<p>This smooth constructor implements random bits model terms. Note that this is experimental.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Linear smooth constructor.
rb(..., k = 50)

## For mgcv.
## S3 method for class 'randombits.smooth.spec'
smooth.construct(object, data, knots, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rb_+3A_...">...</code></td>
<td>
<p>For function <code>rb()</code> a formula of the type <code>~x1+x2+x3</code> that specifies
the covariates that should be modeled.</p>
</td></tr>
<tr><td><code id="rb_+3A_k">k</code></td>
<td>
<p>Integer, number of radnom bit columns in the design matrix.</p>
</td></tr>
<tr><td><code id="rb_+3A_object">object</code>, <code id="rb_+3A_data">data</code>, <code id="rb_+3A_knots">knots</code></td>
<td>
<p>See <code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function <code>rb()</code>, similar to function <code><a href="mgcv.html#topic+s">s</a></code> a simple smooth specification
object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bamlss">bamlss</a></code>, <code><a href="#topic+predict.bamlss">predict.bamlss</a></code>, <code><a href="#topic+bfit">bfit</a></code>, <code><a href="#topic+boost">boost</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ## Simulate data.
set.seed(123)
d &lt;- GAMart()

## Estimate model.
f &lt;- num ~ rb(x1) + rb(x2) + rb(x3) + rb(~lon+lat)

b &lt;- bamlss(f, data = d)

plot(b)

## End(Not run)
</code></pre>

<hr>
<h2 id='residuals.bamlss'>
Compute BAMLSS Residuals
</h2><span id='topic+residuals.bamlss'></span><span id='topic+plot.bamlss.residuals'></span>

<h3>Description</h3>

<p>Function to compute quantile and response residuals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bamlss'
residuals(object, type = c("quantile", "response"),
  nsamps = NULL, ...)

## S3 method for class 'bamlss.residuals'
plot(x, which = c("hist-resid", "qq-resid", "wp"),
  spar = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="residuals.bamlss_+3A_object">object</code></td>
<td>
<p>An object of class <code>"bamlss"</code>.</p>
</td></tr>
<tr><td><code id="residuals.bamlss_+3A_type">type</code></td>
<td>
<p>The type of residuals wanted, possible types are
<code>"quantile"</code> residuals and <code>"response"</code> residuals.</p>
</td></tr>
<tr><td><code id="residuals.bamlss_+3A_nsamps">nsamps</code></td>
<td>
<p>If the fitted <code><a href="#topic+bamlss">bamlss</a></code> object contains samples of parameters,
computing residuals may take quite some time. Therefore, to get a first feeling it can
be useful to compute residuals only based on <code>nsamps</code> samples, i.e., <code>nsamps</code>
specifies the number of samples which are extracted on equidistant intervals.</p>
</td></tr>
<tr><td><code id="residuals.bamlss_+3A_x">x</code></td>
<td>
<p>Object returned from function <code>residuals.bamlss()</code>.</p>
</td></tr>
<tr><td><code id="residuals.bamlss_+3A_which">which</code></td>
<td>
<p>Should a histogram with kernel density estimates be plotted, a qq-plot or a worm plot?</p>
</td></tr>
<tr><td><code id="residuals.bamlss_+3A_spar">spar</code></td>
<td>
<p>Should graphical parameters be set by the plotting function?</p>
</td></tr>
<tr><td><code id="residuals.bamlss_+3A_...">...</code></td>
<td>
<p>For function <code>residuals.bamlss()</code> arguments passed to possible
<code>$residuals()</code> functions that may be part of a <code><a href="#topic+bamlss.family">bamlss.family</a></code>. For function
<code>plot.bamlss.residuals()</code> arguments passed to function
<code><a href="graphics.html#topic+hist.default">hist.default</a></code> and <code><a href="stats.html#topic+qqnorm.default">qqnorm.default</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Response residuals are the raw residuals, i.e., the response data minus the fitted distributional
mean. If the <code><a href="#topic+bamlss.family">bamlss.family</a></code> object contains a function <code>$mu(par, ...)</code>, then
raw residuals are computed with <code>y - mu(par)</code> where <code>par</code> is the named list of fitted
values of distributional parameters. If <code>$mu(par, ...)</code> is missing, then the fitted values
of the first distributional parameter are used.
</p>
<p>Randomized quantile residuals are based on the cumulative distribution function of the
<code><a href="#topic+bamlss.family">bamlss.family</a></code> object, i.e., the <code>$p(y, par, ...)</code> function.
</p>


<h3>Value</h3>

<p>A vector of residuals.
</p>


<h3>References</h3>

<p>Dunn P. K., and Smyth G. K. (1996). Randomized Quantile Residuals.
<em>Journal of Computational and Graphical Statistics</em> <b>5</b>, 236&ndash;244.
</p>
<p>van Buuren S., and Fredriks M. (2001) Worm Plot: Simple Diagnostic Device for Modelling Growth
Reference Curves. <em>Statistics in Medicine</em>, <b>20</b>, 1259&ndash;1277
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bamlss">bamlss</a></code>, <code><a href="#topic+predict.bamlss">predict.bamlss</a></code>, <code><a href="#topic+fitted.bamlss">fitted.bamlss</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ## Generate data.
d &lt;- GAMart()

## Estimate models.
b1 &lt;- bamlss(num ~ s(x1), data = d)
b2 &lt;- bamlss(num ~ s(x1) + s(x2) + s(x3), data = d)

## Extract quantile residuals.
e1 &lt;- residuals(b1, type = "quantile")
e2 &lt;- residuals(b2, type = "quantile")

## Plots.
plot(e1)
plot(e2)

## End(Not run)
</code></pre>

<hr>
<h2 id='response_name'>
Extract the reponse name of a <code><a href="#topic+bamlss.frame">bamlss.frame</a></code> object.
</h2><span id='topic+response_name'></span>

<h3>Description</h3>

<p>This is a small helper function to quickly extract the response name(s) of an object of
class <code>"bamlss.frame"</code> or <code>"bamlss"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>response_name(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="response_name_+3A_object">object</code></td>
<td>
<p>An object of class <code>"bamlss.frame"</code> or <code>"bamlss"</code>.</p>
</td></tr>
<tr><td><code id="response_name_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+bamlss">bamlss</a></code>, <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulate some data.
d &lt;- GAMart()

## Create a bamlss.frame.
bf &lt;- bamlss.frame(num ~ s(x1) + s(x2) + s(x3), data = d)

## Extract the response name.
response_name(bf)
</code></pre>

<hr>
<h2 id='results.bamlss.default'>
Compute BAMLSS Results for Plotting and Summaries
</h2><span id='topic+results.bamlss.default'></span>

<h3>Description</h3>

<p>The results function combines estimated parameters and/or samples with the
<code><a href="#topic+bamlss.frame">bamlss.frame</a></code> and computes the data that can be used, e.g., for
creating effect plots or summary statistics. The function is usually used
internally within <code><a href="#topic+bamlss">bamlss</a></code>. The object returned is of class &quot;bamlss.results&quot;,
which has a plotting method, see <code><a href="#topic+plot.bamlss.results">plot.bamlss.results</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>results.bamlss.default(x, what = c("samples", "parameters"),
  grid = -1, nsamps = NULL, burnin = NULL, thin = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="results.bamlss.default_+3A_x">x</code></td>
<td>
<p>A <code><a href="#topic+bamlss.frame">bamlss.frame</a></code> which has estimated parameters
or samples. See also <code><a href="#topic+bfit">bfit</a></code> and <code><a href="#topic+GMCMC">GMCMC</a></code>.</p>
</td></tr>
<tr><td><code id="results.bamlss.default_+3A_what">what</code></td>
<td>
<p>Should the results data be prepared using estimated parameters or samples?</p>
</td></tr>
<tr><td><code id="results.bamlss.default_+3A_grid">grid</code></td>
<td>
<p>Integer, sets the number of grid points for univariate functions to be used for
creating results data, e.g., for plotting. This is more efficient when using data sets with
a large number of unique covariate values. If negative suitable defaults are chosen.</p>
</td></tr>
<tr><td><code id="results.bamlss.default_+3A_nsamps">nsamps</code></td>
<td>
<p>Integer, if results are computed using parameter samples, this argument controls
the number of samples that should be used, e.g., if <code>nsamps = 100</code> only 100 samples
with equidistant intervals are selected. Basically similar to argument <code>thin</code>.</p>
</td></tr>
<tr><td><code id="results.bamlss.default_+3A_burnin">burnin</code></td>
<td>
<p>Integer, sets the number of samples that should be dropped from the beginning
of the MCMC chain when creating results.</p>
</td></tr>
<tr><td><code id="results.bamlss.default_+3A_thin">thin</code></td>
<td>
<p>Integer, should the MCMC chain be thinned additionally?</p>
</td></tr>
<tr><td><code id="results.bamlss.default_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"bamlss.results"</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.bamlss.results">plot.bamlss.results</a></code>, <code><a href="#topic+bamlss">bamlss</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ## Simulate data.
d &lt;- GAMart()

## Estimate model with no results.
b &lt;- bamlss(num ~ s(x1) + s(x2) + s(x3),
  data = d, results = FALSE)

## Compute model results
a &lt;- results.bamlss.default(b)

## Plot results for smooth terms.
plot(a)

## End(Not run)
</code></pre>

<hr>
<h2 id='rmf'>
Remove Special Characters
</h2><span id='topic+rmf'></span>

<h3>Description</h3>

<p>A simple helper function that removes special characters from a character string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmf(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmf_+3A_x">x</code></td>
<td>
<p>A character string.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character string with special characters removed.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>rmf("ba*&amp;m^l$$:s.s")
</code></pre>

<hr>
<h2 id='s2'>
Special Smooths in BAMLSS Formulae
</h2><span id='topic+s2'></span>

<h3>Description</h3>

<p>This is a simple wrapper function to define special smooth terms
in BAMLSS formulae. The function calls the smooth term constructor function
<code><a href="mgcv.html#topic+s">s</a></code>. The return value of <code><a href="mgcv.html#topic+s">s</a></code> is only slightly
modified, such that function <code><a href="#topic+bamlss.frame">bamlss.frame</a></code> identifies this term as a special
term and uses the appropriate (internal) infrastructures.
</p>
<p>This structure is useful when the model term structure is, e.g., not a
linear combination of a design matrix and coefficients. See the example section of
function <code><a href="#topic+bfit">bfit</a></code> on how to use this setup.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>s2(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="s2_+3A_...">...</code></td>
<td>
<p>Arguments passed to function <code><a href="mgcv.html#topic+s">s</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Slightly modified return value of function <code><a href="mgcv.html#topic+s">s</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bamlss">bamlss</a></code>, <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>, <code><a href="#topic+bamlss.formula">bamlss.formula</a></code>, <code><a href="#topic+opt_bfit">opt_bfit</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print(names(s(x)))
print(names(s2(x)))
</code></pre>

<hr>
<h2 id='sam_BayesX'>
Markov Chain Monte Carlo for BAMLSS using <span class="pkg">BayesX</span>
</h2><span id='topic+BayesX'></span><span id='topic+sam_BayesX'></span><span id='topic+BayesX.control'></span><span id='topic+sx'></span><span id='topic+tx'></span><span id='topic+tx2'></span><span id='topic+tx3'></span><span id='topic+tx4'></span><span id='topic+get_BayesXsrc'></span><span id='topic+quant_bamlss'></span><span id='topic+smooth.construct.tensorX.smooth.spec'></span><span id='topic+Predict.matrix.tensorX.smooth'></span><span id='topic+smooth.construct.tensorX3.smooth.spec'></span><span id='topic+Predict.matrix.tensorX3.smooth'></span>

<h3>Description</h3>

<p>This sampler function for BAMLSS is an interface to the <span class="pkg">BayesX</span>
(<code>https://www.uni-goettingen.de/de/bayesx/550513.html</code>)
command-line binary from <span class="rlang"><b>R</b></span>. The sampler is based on the command line version and functions
provided in the <span class="pkg">BayesXsrc</span> package, which can be installed using
function <code>get_BayesXsrc()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Sampler functions:
sam_BayesX(x, y, family, start = NULL, weights = NULL, offset = NULL,
  data = NULL, control = BayesX.control(...), ...)

BayesX(x, y, family, start = NULL, weights = NULL, offset = NULL,
  data = NULL, control = BayesX.control(...), ...)

## Sampler control:
BayesX.control(n.iter = 1200, thin = 1, burnin = 200,
  seed = NULL, predict = "light", model.name = "bamlss",
  data.name = "d", prg.name = NULL, dir = NULL,
  verbose = FALSE, show.prg = TRUE, modeonly = FALSE, ...)

## Special BayesX smooth term constructor.
sx(x, z = NULL, bs = "ps", by = NA, ...)

## Special BayesX tensor product smooth term constructor.
tx(..., bs = "ps", k = -1,
  ctr = c("center", "main", "both", "both1", "both2",
    "none", "meanf", "meanfd", "meansimple", "nullspace"),
  xt = NULL, special = TRUE)
tx2(...)
tx3(..., bs = "ps", k = c(10, 5),
  ctr = c("main", "center"),
  xt = NULL, special = TRUE)
tx4(..., ctr = c("center", "main", "both", "both1", "both2"))

## Smooth constructors and predict matrix.
## S3 method for class 'tensorX.smooth.spec'
smooth.construct(object, data, knots, ...)
## S3 method for class 'tensorX.smooth'
Predict.matrix(object, data) 
## S3 method for class 'tensorX3.smooth.spec'
smooth.construct(object, data, knots, ...)
## S3 method for class 'tensorX3.smooth'
Predict.matrix(object, data) 

## Family object for quantile regression with BayesX.
quant_bamlss(prob = 0.5)

## Download the newest version of BayesXsrc.
get_BayesXsrc(dir = NULL, install = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sam_BayesX_+3A_x">x</code></td>
<td>
<p>For function <code>BayesX()</code> the <code>x</code> list, as returned from
function <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>, holding all model matrices and other information that is
used for fitting the model. For function <code>sx()</code> arguments <code>x</code> and <code>z</code> specify
the variables the smooth should be a function of.</p>
</td></tr>
<tr><td><code id="sam_BayesX_+3A_y">y</code></td>
<td>
<p>The model response, as returned from function <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>.</p>
</td></tr>
<tr><td><code id="sam_BayesX_+3A_z">z</code></td>
<td>
<p>Second variable in a <code>sx()</code> term.</p>
</td></tr>
<tr><td><code id="sam_BayesX_+3A_family">family</code></td>
<td>
<p>A <span class="pkg">bamlss</span> family object, see <code><a href="#topic+family.bamlss">family.bamlss</a></code>.</p>
</td></tr>
<tr><td><code id="sam_BayesX_+3A_start">start</code></td>
<td>
<p>A named numeric vector containing possible starting values, the names are based on
function <code><a href="#topic+parameters">parameters</a></code>.</p>
</td></tr>
<tr><td><code id="sam_BayesX_+3A_weights">weights</code></td>
<td>
<p>Prior weights on the data, as returned from function <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>.</p>
</td></tr>
<tr><td><code id="sam_BayesX_+3A_offset">offset</code></td>
<td>
<p>Can be used to supply model offsets for use in fitting,
returned from function <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>.</p>
</td></tr>
<tr><td><code id="sam_BayesX_+3A_data">data</code></td>
<td>
<p>The model frame that should be used for modeling. Note that argument <code>data</code> needs
not to be specified when the <code>BayesX()</code> sampler function is used with <code><a href="#topic+bamlss">bamlss</a></code>.
For the smooth constructor for <code>tx()</code> terms, see function <code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code>.</p>
</td></tr>
<tr><td><code id="sam_BayesX_+3A_control">control</code></td>
<td>
<p>List of control arguments to be send to <span class="pkg">BayesX</span>. See below.</p>
</td></tr>
<tr><td><code id="sam_BayesX_+3A_n.iter">n.iter</code></td>
<td>
<p>Sets the number of MCMC iterations.</p>
</td></tr>
<tr><td><code id="sam_BayesX_+3A_thin">thin</code></td>
<td>
<p>Defines the thinning parameter for MCMC simulation. E.g., <code>thin = 10</code> means,
that only every 10th sampled parameter will be stored.</p>
</td></tr>
<tr><td><code id="sam_BayesX_+3A_burnin">burnin</code></td>
<td>
<p>Sets the burn-in phase of the sampler, i.e., the number of starting samples that
should be removed.</p>
</td></tr>
<tr><td><code id="sam_BayesX_+3A_seed">seed</code></td>
<td>
<p>Sets the seed.</p>
</td></tr>
<tr><td><code id="sam_BayesX_+3A_predict">predict</code></td>
<td>
<p>Not supported at the moment, do not modify!</p>
</td></tr>
<tr><td><code id="sam_BayesX_+3A_model.name">model.name</code></td>
<td>
<p>The name that should be used for the model when calling <span class="pkg">BayesX</span>.</p>
</td></tr>
<tr><td><code id="sam_BayesX_+3A_data.name">data.name</code></td>
<td>
<p>The name that should be used for the data set when calling <span class="pkg">BayesX</span>.</p>
</td></tr>
<tr><td><code id="sam_BayesX_+3A_prg.name">prg.name</code></td>
<td>
<p>The name that should be used for the <code>.prg</code> file that is send to <span class="pkg">BayesX</span>.</p>
</td></tr>
<tr><td><code id="sam_BayesX_+3A_dir">dir</code></td>
<td>
<p>Specifies the directory where <span class="pkg">BayesX</span> should store all output files. For function
<code>get_BayesXsrc()</code>, the directory where <span class="pkg">BayesXsrc</span> should be stored.</p>
</td></tr>
<tr><td><code id="sam_BayesX_+3A_verbose">verbose</code></td>
<td>
<p>Print information during runtime of the algorithm.</p>
</td></tr>
<tr><td><code id="sam_BayesX_+3A_show.prg">show.prg</code></td>
<td>
<p>Show the <span class="pkg">BayesX</span> <code>.prg</code> file.</p>
</td></tr>
<tr><td><code id="sam_BayesX_+3A_modeonly">modeonly</code></td>
<td>
<p>Should only the posterior mode be compute, note that this is done using
fixed smoothing parameters/variances.</p>
</td></tr>
<tr><td><code id="sam_BayesX_+3A_bs">bs</code></td>
<td>
<p>A <code><a href="base.html#topic+character">character</a></code> string, specifying the basis/type which is used for
this model term.</p>
</td></tr>
<tr><td><code id="sam_BayesX_+3A_by">by</code></td>
<td>
<p>A by variable for varying coefficient model terms.</p>
</td></tr>
<tr><td><code id="sam_BayesX_+3A_k">k</code></td>
<td>
<p>The dimension(s) of the bases used to represent the <code>tx()</code> smooth term.</p>
</td></tr>
<tr><td><code id="sam_BayesX_+3A_...">...</code></td>
<td>
<p>Not used in <code>BayesX.control</code>. For function <code>sx()</code> any extra arguments that
should be passed to <span class="pkg">BayesX</span> for this model term can be specified here. For function
<code>tx()</code>, all variables the smooth should be a function of are specified here. For function
<code>sam_BayesX()</code> all arguments that should be passed to <code>BayesX.control</code>.</p>
</td></tr>
<tr><td><code id="sam_BayesX_+3A_ctr">ctr</code></td>
<td>
<p>Specifies the type of constraints that should be applied. <code>"main"</code>, both
main effects should be removed; <code>"both"</code>, both main effects and varying effects should
be removed; <code>"none"</code>, no constraint should be applied.</p>
</td></tr>
<tr><td><code id="sam_BayesX_+3A_xt">xt</code></td>
<td>
<p>A list of extra arguments to be passed to <span class="pkg">BayesX</span>.</p>
</td></tr>
<tr><td><code id="sam_BayesX_+3A_special">special</code></td>
<td>
<p>Should the <code>tx()</code> model term be treated as a special smooth. This must
be set to <code>TRUE</code> if using the <code>sam_BayesX</code> sampler and should be set to <code>FALSE</code>,
e.g., when using the <code><a href="#topic+sam_GMCMC">sam_GMCMC</a></code> sampler.</p>
</td></tr>
<tr><td><code id="sam_BayesX_+3A_object">object</code>, <code id="sam_BayesX_+3A_knots">knots</code></td>
<td>
<p>See, function <code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code>.</p>
</td></tr>
<tr><td><code id="sam_BayesX_+3A_prob">prob</code></td>
<td>
<p>Numeric, specifies the quantile to be modeled, see the examples.</p>
</td></tr>
<tr><td><code id="sam_BayesX_+3A_install">install</code></td>
<td>
<p>Should package <span class="pkg">BayesXsrc</span> be installed?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>sam_BayesX()</code> writes a <span class="pkg">BayesX</span> <code>.prg</code> file and processes the data.
Then, the function call the <span class="pkg">BayesX</span> binary via function
<code>run.bayesx()</code> of the <span class="pkg">BayesXsrc</span> package. After the <span class="pkg">BayesX</span> sampler has
finished, the function reads back in all the parameter samples that can then be used
for further processing within <code><a href="#topic+bamlss">bamlss</a></code>, i.a.
</p>
<p>The smooth term constructor functions <code><a href="mgcv.html#topic+s">s</a></code> and <code><a href="mgcv.html#topic+te">te</a></code> can
be used with the <code>sam_BayesX()</code> sampler. When using <code><a href="mgcv.html#topic+te">te</a></code> note that only
one smoothing variance is estimated by <span class="pkg">BayesX</span>.
</p>
<p>For anisotropic penalties use function <code>tx()</code> and <code>tx3()</code>, the former currently
supports smooth functions of two variables, while <code>tx3()</code> is supposed to model space-time
interactions. Note that in <code>tx3()</code> the first variable represents time and the 2nd and 3rd
variable the coordinates in space.
</p>


<h3>Value</h3>

<p>Function <code>sam_BayesX()</code> returns samples of parameters. The samples are provided as a
<code><a href="coda.html#topic+mcmc">mcmc</a></code> matrix.
</p>
<p>Function <code>BayesX.control()</code> returns a <code>list</code> with control arguments for
<span class="pkg">BayesX</span>.
</p>
<p>Function <code>sx()</code> a <code>list</code> of class <code>"xx.smooth.spec"</code> and <code>"no.mgcv"</code>, where
<code>"xx"</code> is a basis/type identifying code given by the <code>bs</code> argument.
</p>
<p>Function <code>tx()</code> and <code>tx2()</code> a <code>list</code> of class <code>tensorX.smooth.spec</code>.
</p>


<h3>Note</h3>

<p>Note that this interface is still experimental and needs the newest version of the <span class="pkg">BayesX</span>
source code, which is not yet part of the <span class="pkg">BayesXsrc</span> package on CRAN. The newest version
can be installed with function <code>get_BayesXsrc</code>. Note that the function assumes that sh,
subversion (svn) and <span class="rlang"><b>R</b></span> can be run from the command line!
</p>
<p>Note that for setting up a new family object to be used with <code>sam_BayesX()</code> additional
information needs to be supplied. The extra information must be placed within the
family object in an named <code>list</code> element named <code>"bayesx"</code>. For each parameter of
the distribution a character string with the corresponding <span class="pkg">BayesX</span> <code>family</code> name and the
<code>equationtype</code> must be supplied. See, e.g., the <span class="rlang"><b>R</b></span> code of <code><a href="#topic+gaussian_bamlss">gaussian_bamlss</a></code>
how the setup works.
</p>
<p>For function <code>sx()</code> the following basis types are currently supported:
</p>

<ul>
<li> <p><code>"ps"</code>: P-spline with second order difference penalty. 
</p>
</li>
<li> <p><code>"mrf"</code>: Markov random fields: Defines a Markov random field prior for a
spatial covariate, where geographical information is provided by a map object in
boundary or graph file format (see function <code><a href="BayesX.html#topic+read.bnd">read.bnd</a></code>,
<code><a href="BayesX.html#topic+read.gra">read.gra</a></code> and <code><a href="BayesX.html#topic+shp2bnd">shp2bnd</a></code>), as an additional
argument named <code>map</code>.
</p>
</li>
<li> <p><code>"re"</code>: Gaussian i.i.d. Random effects of a unit or cluster identification covariate.
</p>
</li></ul>

<p>Function <code>tx()</code> currently supports smooth terms with two variables.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bamlss">bamlss</a></code>, <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Get newest version of BayesXsrc.
## Note: needs sh, svn and R build tools!
## get_BayesXsrc()
## Not run: if(require("BayesXsrc")) {
  ## Simulate some data
  set.seed(123)
  d &lt;- GAMart()

  ## Estimate model with BayesX. Note
  ## that BayesX computes starting values, so
  ## these are not required by some optimizer function
  ## in bamlss()
  b1 &lt;- bamlss(num ~ s(x1) + s(x2) + s(x3) + s(lon,lat),
    data = d, optimizer = FALSE, sampler = sam_BayesX)

  plot(b1)

  ## Same model with anisotropic penalty.
  b2 &lt;- bamlss(num ~ s(x1) + s(x2) + s(x3) + tx(lon,lat),
    data = d, optimizer = FALSE, sampler = sam_BayesX)

  plot(b2)

  ## Quantile regression.
  b3_0.1 &lt;- bamlss(num ~ s(x1) + s(x2) + s(x3) + tx(lon,lat),
    data = d, optimizer = FALSE, sampler = sam_BayesX,
    family = gF("quant", prob = 0.1))

  b3_0.9 &lt;- bamlss(num ~ s(x1) + s(x2) + s(x3) + tx(lon,lat),
    data = d, optimizer = FALSE, sampler = sam_BayesX,
    family = gF("quant", prob = 0.9))

  ## Predict quantiles.
  p_0.1 &lt;- predict(b3_0.1, term = "s(x2)")
  p_0.9 &lt;- predict(b3_0.9, term = "s(x2)")

  ## Plot.
  plot2d(p_0.1 + p_0.9 ~ x2, data = d)  
}

## End(Not run)
</code></pre>

<hr>
<h2 id='sam_Cox'>
Cox Model Markov Chain Monte Carlo
</h2><span id='topic+sam_Cox'></span><span id='topic+cox_mcmc'></span>

<h3>Description</h3>

<p>This sampler function implements a derivative based MCMC algorithm for
flexible Cox models with structured additive predictors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sam_Cox(x, y, family, start, weights, offset,
  n.iter = 1200, burnin = 200, thin = 1,
  verbose = TRUE, digits = 4, step = 20, ...)

cox_mcmc(x, y, family, start, weights, offset,
  n.iter = 1200, burnin = 200, thin = 1,
  verbose = TRUE, digits = 4, step = 20, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sam_Cox_+3A_x">x</code></td>
<td>
<p>The <code>x</code> list, as returned from function
<code><a href="#topic+bamlss.frame">bamlss.frame</a></code> and transformed by function <code><a href="#topic+surv_transform">surv_transform</a></code>,
holding all model matrices and other information that is used for
fitting the model.</p>
</td></tr>
<tr><td><code id="sam_Cox_+3A_y">y</code></td>
<td>
<p>The model response, as returned from function <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>.</p>
</td></tr>
<tr><td><code id="sam_Cox_+3A_family">family</code></td>
<td>
<p>A <span class="pkg">bamlss</span> family object, see <code><a href="#topic+family.bamlss">family.bamlss</a></code>.
In this case this is the <code><a href="#topic+cox_bamlss">cox_bamlss</a></code> family object.</p>
</td></tr>
<tr><td><code id="sam_Cox_+3A_start">start</code></td>
<td>
<p>A named numeric vector containing possible starting values, the names are based on
function <code><a href="#topic+parameters">parameters</a></code>.</p>
</td></tr>
<tr><td><code id="sam_Cox_+3A_weights">weights</code></td>
<td>
<p>Prior weights on the data, as returned from function <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>.</p>
</td></tr>
<tr><td><code id="sam_Cox_+3A_offset">offset</code></td>
<td>
<p>Can be used to supply model offsets for use in fitting,
returned from function <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>.</p>
</td></tr>
<tr><td><code id="sam_Cox_+3A_n.iter">n.iter</code></td>
<td>
<p>Sets the number of MCMC iterations.</p>
</td></tr>
<tr><td><code id="sam_Cox_+3A_burnin">burnin</code></td>
<td>
<p>Sets the burn-in phase of the sampler, i.e., the number of starting samples that
should be removed.</p>
</td></tr>
<tr><td><code id="sam_Cox_+3A_thin">thin</code></td>
<td>
<p>Defines the thinning parameter for MCMC simulation. E.g., <code>thin = 10</code> means,
that only every 10th sampled parameter will be stored.</p>
</td></tr>
<tr><td><code id="sam_Cox_+3A_verbose">verbose</code></td>
<td>
<p>Print information during runtime of the algorithm.</p>
</td></tr>
<tr><td><code id="sam_Cox_+3A_digits">digits</code></td>
<td>
<p>Set the digits for printing when <code>verbose = TRUE</code>.</p>
</td></tr>
<tr><td><code id="sam_Cox_+3A_step">step</code></td>
<td>
<p>How many times should algorithm runtime information be printed, divides <code>n.iter</code>.</p>
</td></tr>
<tr><td><code id="sam_Cox_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sampler uses derivative based proposal functions to create samples of parameters.
For time-dependent functions the proposals are based on one Newton-Raphson iteration centered
at the last state, while for the time-constant functions proposals can be based
on iteratively reweighted least squares (IWLS), see also function <code><a href="#topic+GMCMC">GMCMC</a></code>.
The integrals that are part of the time-dependent function updates are solved numerically.
In addition, smoothing variances are sampled using slice sampling.
</p>


<h3>Value</h3>

<p>The function returns samples of parameters. The samples are provided as a
<code><a href="coda.html#topic+mcmc">mcmc</a></code> matrix.
</p>


<h3>References</h3>

<p>Umlauf N, Klein N, Zeileis A (2016). Bayesian Additive Models for Location
Scale and Shape (and Beyond). <em>(to appear)</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+opt_Cox">opt_Cox</a></code>, <code><a href="#topic+cox_bamlss">cox_bamlss</a></code>, <code><a href="#topic+surv_transform">surv_transform</a></code>,
<code><a href="#topic+simSurv">simSurv</a></code>, <code><a href="#topic+bamlss">bamlss</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: library("survival")
set.seed(123)

## Simulate survival data.
d &lt;- simSurv(n = 500)

## Formula of the survival model, note
## that the baseline is given in the first formula by s(time).
f &lt;- list(
  Surv(time, event) ~ s(time) + s(time, by = x3),
  gamma ~ s(x1) + s(x2)
)

## Cox model with continuous time.
## Note the the family object cox_bamlss() sets
## the default optimizer and sampler function!
## First, posterior mode estimates are computed
## using function opt_Cox(), afterwards the
## sampler sam_Cox() is started.
b &lt;- bamlss(f, family = "cox", data = d)

## Plot estimated effects.
plot(b)

## End(Not run)
</code></pre>

<hr>
<h2 id='sam_GMCMC'>
General Markov Chain Monte Carlo for BAMLSS
</h2><span id='topic+sam_GMCMC'></span><span id='topic+GMCMC'></span><span id='topic+GMCMC_iwls'></span><span id='topic+GMCMC_iwlsC'></span><span id='topic+GMCMC_iwlsC_gp'></span><span id='topic+GMCMC_slice'></span>

<h3>Description</h3>

<p>These functions provide a quite general infrastructure for sampling BAMLSS. The default
proposal function is based on iteratively weighted least squares (IWLS), however,
each model term may have a different updating function, see the details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Sampler functions:
sam_GMCMC(x, y, family, start = NULL, weights = NULL, offset = NULL,
  n.iter = 1200, burnin = 200, thin = 1, verbose = TRUE,
  step = 20, propose = "iwlsC_gp", chains = NULL, ...)

GMCMC(x, y, family, start = NULL, weights = NULL, offset = NULL,
  n.iter = 1200, burnin = 200, thin = 1, verbose = TRUE,
  step = 20, propose = "iwlsC_gp", chains = NULL, ...)

## Propose functions:
GMCMC_iwls(family, theta, id, eta, y, data,
  weights = NULL, offset = NULL, ...)
GMCMC_iwlsC(family, theta, id, eta, y, data,
  weights = NULL, offset = NULL, zworking, resids, rho, ...)
GMCMC_iwlsC_gp(family, theta, id, eta, y, data,
  weights = NULL, offset = NULL, zworking, resids, rho, ...)
GMCMC_slice(family, theta, id, eta, y, data, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sam_GMCMC_+3A_x">x</code></td>
<td>
<p>For function <code>bfit()</code> the <code>x</code> list, as returned from function
<code><a href="#topic+bamlss.frame">bamlss.frame</a></code>, holding all model matrices and other information that is used for
fitting the model. For the updating functions an object as returned from function
<code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code> or <code><a href="mgcv.html#topic+smoothCon">smoothCon</a></code>.</p>
</td></tr>
<tr><td><code id="sam_GMCMC_+3A_y">y</code></td>
<td>
<p>The model response, as returned from function <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>.</p>
</td></tr>
<tr><td><code id="sam_GMCMC_+3A_family">family</code></td>
<td>
<p>A <span class="pkg">bamlss</span> family object, see <code><a href="#topic+family.bamlss">family.bamlss</a></code>.</p>
</td></tr>
<tr><td><code id="sam_GMCMC_+3A_start">start</code></td>
<td>
<p>A named numeric vector containing possible starting values, the names are based on
function <code><a href="#topic+parameters">parameters</a></code>.</p>
</td></tr>
<tr><td><code id="sam_GMCMC_+3A_weights">weights</code></td>
<td>
<p>Prior weights on the data, as returned from function <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>.</p>
</td></tr>
<tr><td><code id="sam_GMCMC_+3A_offset">offset</code></td>
<td>
<p>Can be used to supply model offsets for use in fitting,
returned from function <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>.</p>
</td></tr>
<tr><td><code id="sam_GMCMC_+3A_n.iter">n.iter</code></td>
<td>
<p>Sets the number of MCMC iterations.</p>
</td></tr>
<tr><td><code id="sam_GMCMC_+3A_burnin">burnin</code></td>
<td>
<p>Sets the burn-in phase of the sampler, i.e., the number of starting samples that
should be removed.</p>
</td></tr>
<tr><td><code id="sam_GMCMC_+3A_thin">thin</code></td>
<td>
<p>Defines the thinning parameter for MCMC simulation. E.g., <code>thin = 10</code> means,
that only every 10th sampled parameter will be stored.</p>
</td></tr>
<tr><td><code id="sam_GMCMC_+3A_verbose">verbose</code></td>
<td>
<p>Print information during runtime of the algorithm.</p>
</td></tr>
<tr><td><code id="sam_GMCMC_+3A_step">step</code></td>
<td>
<p>How many times should algorithm runtime information be printed, divides <code>n.iter</code>.</p>
</td></tr>
<tr><td><code id="sam_GMCMC_+3A_propose">propose</code></td>
<td>
<p>Sets the propose function for model terms, e.g. for a term <code>s(x)</code> in the model
formula. Per default this is set to <code>"iwlsC"</code>, a character pointing to the set of propose
functions, see above. Other options are <code>"iwls"</code> and <code>"slice"</code>, however, this is
more experimental and should not be set by the user. Another option is to pass a full propose
function which should be used for each model term, the structure of propose functions is
described in the details below. Model terms may also have different propose functions, see
the example section.</p>
</td></tr>
<tr><td><code id="sam_GMCMC_+3A_chains">chains</code></td>
<td>
<p>How many chains should be started? Chains a sampled sequentially!</p>
</td></tr>
<tr><td><code id="sam_GMCMC_+3A_theta">theta</code></td>
<td>
<p>The current state of parameters, provided as a named list. The first level
represents the parameters of the distribution, the second level the parameters of
the model terms. E.g., using the <code><a href="#topic+gaussian_bamlss">gaussian_bamlss</a></code> family object
<code>theta[["mu"]][["s(x)"]]</code> extracts the current state of a model term <code>"s(x)"</code>
of the <code>"mu"</code> parameter. Extraction is done with the <code>id</code> argument.</p>
</td></tr>
<tr><td><code id="sam_GMCMC_+3A_id">id</code></td>
<td>
<p>The parameter identifier, a character vector of length 2. The first character
specifies the current distributional parameter, the second the current model term.</p>
</td></tr>
<tr><td><code id="sam_GMCMC_+3A_eta">eta</code></td>
<td>
<p>The current value of the predictors, provided as a named list, one list entry
for each parameter. The names correspond to the parameter names in the family object,
see <code><a href="#topic+family.bamlss">family.bamlss</a></code>. E.g., when using the <code><a href="#topic+gaussian_bamlss">gaussian_bamlss</a></code> family
object, the current values for the mean can be extracted by <code>eta\$mu</code> and for the
standard deviation by <code>eta\$sigma</code>.</p>
</td></tr>
<tr><td><code id="sam_GMCMC_+3A_data">data</code></td>
<td>
<p>An object as returned from function
<code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code> or <code><a href="mgcv.html#topic+smoothCon">smoothCon</a></code>. The object is
preprocessed by function <code><a href="#topic+bamlss.engine.setup">bamlss.engine.setup</a></code>.</p>
</td></tr>
<tr><td><code id="sam_GMCMC_+3A_zworking">zworking</code></td>
<td>
<p>Preinitialized numeric vector of <code>length(y)</code>, only for internal usage.</p>
</td></tr>
<tr><td><code id="sam_GMCMC_+3A_resids">resids</code></td>
<td>
<p>Preinitialized numeric vector of <code>length(y)</code>, only for internal usage.</p>
</td></tr>
<tr><td><code id="sam_GMCMC_+3A_rho">rho</code></td>
<td>
<p>An environment, only for internal usage.</p>
</td></tr>
<tr><td><code id="sam_GMCMC_+3A_...">...</code></td>
<td>
<p>Arguments passed to function <code><a href="#topic+bamlss.engine.setup">bamlss.engine.setup</a></code> and to the
propose functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The sampler function <code>sam_GMCMC()</code> cycles through all distributional parameters and corresponding
model terms in each iteration of the MCMC chain. Samples of the parameters of a model term (e.g.,
<code>s(x)</code>) are generated by proposal functions, e.g. <code>GMCMC_iwls()</code>.
</p>
<p>The default proposal function that should be used for all model terms is set with argument
<code>propose</code>. For smooth terms, e.g. terms created with function <code><a href="mgcv.html#topic+s">s</a></code>, if
a valid propose function is supplied within the extra <code>xt</code> list, this propose function will
be used. This way each model term may have its own propose function for creating samples
of the parameters. See the example section.
</p>
<p>The default proposal function <code>GMCMC_iwlsC_gp</code> allows for general priors for the
smoothing variances and general penalty functions. Samples of smoothing variances are computed
using slice sampling. Function <code>GMCMC_iwlsC</code> samples smoothing variances of univariate terms
assuming an inverse gamma prior. Terms of higher dimensions use again slice sampling for creating
samples of smoothing variances.
</p>
<p>Function <code>GMCMC_iwls</code> is similar to function <code>GMCMC_iwlsC</code> but uses plain <span class="rlang"><b>R</b></span> code.
</p>
<p>Function <code>GMCMC_slice</code> applies slice sampling also for the regression coefficients and
is therefore relatively slow.
</p>


<h3>Value</h3>

<p>The function returns samples of parameters, depending on the return value of the propose functions
other quantities can be returned. The samples are provided as a <code><a href="coda.html#topic+mcmc">mcmc</a></code> matrix.
If <code>chains &gt; 1</code>, the samples are provided as a <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code>.
</p>


<h3>References</h3>

<p>Umlauf N, Klein N, Zeileis A (2016). Bayesian Additive Models for Location
Scale and Shape (and Beyond). <em>(to appear)</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bamlss">bamlss</a></code>, <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>,
<code><a href="#topic+bamlss.engine.setup">bamlss.engine.setup</a></code>, <code><a href="#topic+set.starting.values">set.starting.values</a></code>, <code><a href="#topic+s2">s2</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ## Simulated data example illustrating
## how to call the sampler function.
## This is done internally within
## the setup of function bamlss().
d &lt;- GAMart()
f &lt;- num ~ s(x1, bs = "ps")
bf &lt;- bamlss.frame(f, data = d, family = "gaussian")

## First, find starting values with optimizer.
opt &lt;- with(bf, bfit(x, y, family))

## Sample.
samps &lt;- with(bf, sam_GMCMC(x, y, family, start = opt$parameters))
plot(samps)

## End(Not run)
</code></pre>

<hr>
<h2 id='sam_JAGS'>
Markov Chain Monte Carlo for BAMLSS using JAGS
</h2><span id='topic+sam_JAGS'></span><span id='topic+JAGS'></span><span id='topic+BUGSeta'></span><span id='topic+BUGSmodel'></span>

<h3>Description</h3>

<p>This sampler function for BAMLSS is an interface to the JAGS library
using package <code><a href="rjags.html#topic+rjags">rjags</a></code>. The function basically interprets the
<code><a href="#topic+bamlss.frame">bamlss.frame</a></code> into BUGS code, similar to the <code><a href="mgcv.html#topic+jagam">jagam</a></code> function of
package <code><a href="mgcv.html#topic+mgcv">mgcv</a></code>. I.e., the function uses the random effects representation of
smooth terms, see the transformer function <code><a href="#topic+randomize">randomize</a></code> to generate the BUGS code.
</p>
<p>Note that estimating BAMLSS with JAGS is not very efficient.
Also note that this function is more experimental and support is only provided for a small
number of <code><a href="#topic+bamlss.family">bamlss.family</a></code> objects.
</p>
<p>Function <code>BUGSeta()</code> therefore computes the code and data for one parameter of
the modeled distribution. Function <code>BUGSmodel()</code> then collects all parameter model code
and data, which can be send to JAGS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Sampler functions:
sam_JAGS(x, y, family, start = NULL,
  tdir = NULL, n.chains = 1, n.adapt = 100,
  n.iter = 4000, thin = 2, burnin = 1000,
  seed = NULL, verbose = TRUE, set.inits = TRUE,
  save.all = FALSE, modules = NULL, ...)

JAGS(x, y, family, start = NULL,
  tdir = NULL, n.chains = 1, n.adapt = 100,
  n.iter = 4000, thin = 2, burnin = 1000,
  seed = NULL, verbose = TRUE, set.inits = TRUE,
  save.all = FALSE, modules = NULL, ...)

## Function to interpret an additive predictor into BUGS code:
BUGSeta(x, id = NULL, ...)

## Function to interpret the full BAMLSS:
BUGSmodel(x, family, is.stan = FALSE, reference = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sam_JAGS_+3A_x">x</code></td>
<td>
<p>For function <code>sam_JAGS()</code> and <code>BUGSmodel()</code> the <code>x</code> list, as returned from
function <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>, holding all model matrices and other information that is
used for fitting the model. For function <code>BUGSeta()</code> argument <code>x</code> is one element of
the <code>x</code> object, i.e., one parameter.</p>
</td></tr>
<tr><td><code id="sam_JAGS_+3A_y">y</code></td>
<td>
<p>The model response, as returned from function <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>.</p>
</td></tr>
<tr><td><code id="sam_JAGS_+3A_family">family</code></td>
<td>
<p>A <span class="pkg">bamlss</span> family object, see <code><a href="#topic+family.bamlss">family.bamlss</a></code>.</p>
</td></tr>
<tr><td><code id="sam_JAGS_+3A_start">start</code></td>
<td>
<p>A named numeric vector containing possible starting values, the names are based on
function <code><a href="#topic+parameters">parameters</a></code>.</p>
</td></tr>
<tr><td><code id="sam_JAGS_+3A_tdir">tdir</code></td>
<td>
<p>The path to the temporary directory that should be used.</p>
</td></tr>
<tr><td><code id="sam_JAGS_+3A_n.chains">n.chains</code></td>
<td>
<p>Specifies the number of sequential MCMC chains that should be run with JAGS.</p>
</td></tr>
<tr><td><code id="sam_JAGS_+3A_n.adapt">n.adapt</code></td>
<td>
<p>Specifies the number of iterations that should be used as an initial adaptive phase.</p>
</td></tr>
<tr><td><code id="sam_JAGS_+3A_n.iter">n.iter</code></td>
<td>
<p>Sets the number of MCMC iterations.</p>
</td></tr>
<tr><td><code id="sam_JAGS_+3A_thin">thin</code></td>
<td>
<p>Defines the thinning parameter for MCMC simulation. E.g., <code>thin = 10</code> means,
that only every 10th sampled parameter will be stored.</p>
</td></tr>
<tr><td><code id="sam_JAGS_+3A_burnin">burnin</code></td>
<td>
<p>Sets the burn-in phase of the sampler, i.e., the number of starting samples that
should be removed.</p>
</td></tr>
<tr><td><code id="sam_JAGS_+3A_seed">seed</code></td>
<td>
<p>Sets the seed.</p>
</td></tr>
<tr><td><code id="sam_JAGS_+3A_verbose">verbose</code></td>
<td>
<p>Print information during runtime of the algorithm.</p>
</td></tr>
<tr><td><code id="sam_JAGS_+3A_set.inits">set.inits</code></td>
<td>
<p>Should initial values of BAMLSS <code><a href="#topic+parameters">parameters</a></code> be provided to JAGS,
if available. Set in argument <code>start</code>.</p>
</td></tr>
<tr><td><code id="sam_JAGS_+3A_save.all">save.all</code></td>
<td>
<p>Should all JAGS files be saved in <code>tdir</code>.</p>
</td></tr>
<tr><td><code id="sam_JAGS_+3A_modules">modules</code></td>
<td>
<p>Specify additional modules that should be loaded, see function <code><a href="rjags.html#topic+load.module">load.module</a></code>.</p>
</td></tr>
<tr><td><code id="sam_JAGS_+3A_id">id</code></td>
<td>
<p>Character, the current parameter name for which the BUGS code should be produced.</p>
</td></tr>
<tr><td><code id="sam_JAGS_+3A_is.stan">is.stan</code></td>
<td>
<p>Should the BUGS code be translated to STAN code. Note that this is only experimental.</p>
</td></tr>
<tr><td><code id="sam_JAGS_+3A_reference">reference</code></td>
<td>
<p>A <code>character</code> specifying a reference category, e.g., when
fitting a multinomial model.</p>
</td></tr>
<tr><td><code id="sam_JAGS_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function <code>sam_JAGS()</code> returns samples of parameters. The samples are provided as a <code><a href="coda.html#topic+mcmc">mcmc</a></code>
matrix. If <code>n.chains &gt; 1</code>, the samples are provided as a <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code>.
</p>
<p>Function <code>BUGSeta()</code> returns the BUGS model code and preprocessed data for one
additive predictor. Function <code>BUGSmodel()</code> then combines all single BUGS code chunks and
the data and creates the final BUGS model code that can be send to JAGS.
</p>


<h3>Note</h3>

<p>Note that for setting up a new family object to be used with <code>sam_JAGS()</code> additional
information needs to be supplied. The extra information must be placed within the
family object in an element named <code>"bugs"</code>. The following entries should be supplied
within the <code>..$bugs</code> list:
</p>

<ul>
<li> <p><code>"dist"</code>. The name of the distribution in BUGS/JAGS model language.
</p>
</li>
<li> <p><code>"eta"</code>. The function that computes the BUGS code for one structured additive predictor.
Function <code>BUGSeta()</code> is used per default.
</p>
</li>
<li> <p><code>"model"</code>. The function that merges all single predictor BUGS model code and data.
The default function is <code>BUGSmodel()</code>.
</p>
</li>
<li> <p><code>"reparam"</code>. A named vector of character strings that specify a re-parametrization.
</p>
</li></ul>

<p>See also the example code of <code><a href="#topic+family.bamlss">family.bamlss</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bamlss">bamlss</a></code>, <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>,
<code><a href="#topic+bamlss.engine.setup">bamlss.engine.setup</a></code>, <code><a href="#topic+set.starting.values">set.starting.values</a></code>, <code><a href="#topic+bfit">bfit</a></code>,
<code><a href="#topic+GMCMC">GMCMC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ## Simulated data example illustrating
## how to call the sampler function.
## This is done internally within
## the setup of function bamlss().
d &lt;- GAMart()
f &lt;- num ~ s(x1, bs = "ps")
bf &lt;- bamlss.frame(f, data = d, family = "gaussian")

## First, find starting values with optimizer.
opt &lt;- with(bf, opt_bfit(x, y, family))

## Sample with JAGS.
if(require("rjags")) {
  samps &lt;- with(bf, sam_JAGS(x, y, family, start = opt$parameters))
  plot(samps)

  b &lt;- bamlss(f, data = d, family = "gaussian", sampler = sam_JAGS)
  plot(b)
}

## End(Not run)
</code></pre>

<hr>
<h2 id='sam_MVNORM'>
Create Samples for BAMLSS by Multivariate Normal Approximation
</h2><span id='topic+sam_MVNORM'></span><span id='topic+MVNORM'></span>

<h3>Description</h3>

<p>This sampler function for BAMLSS uses estimated <code><a href="#topic+parameters">parameters</a></code> and the Hessian
information to create samples from a multivariate normal distribution. Note that smoothing
variance uncertainty is not accounted for, therefore, the resulting credible intervals
are most likely too narrow. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sam_MVNORM(x, y = NULL, family = NULL, start = NULL,
  n.samples = 500, hessian = NULL, ...)

MVNORM(x, y = NULL, family = NULL, start = NULL,
  n.samples = 500, hessian = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sam_MVNORM_+3A_x">x</code></td>
<td>
<p>The <code>x</code> list, as returned from
function <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>, holding all model matrices and other information that is
used for fitting the model. Or an object returned from function <code><a href="#topic+bamlss">bamlss</a></code>.</p>
</td></tr>
<tr><td><code id="sam_MVNORM_+3A_y">y</code></td>
<td>
<p>The model response, as returned from function <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>.</p>
</td></tr>
<tr><td><code id="sam_MVNORM_+3A_family">family</code></td>
<td>
<p>A <span class="pkg">bamlss</span> family object, see <code><a href="#topic+family.bamlss">family.bamlss</a></code>.</p>
</td></tr>
<tr><td><code id="sam_MVNORM_+3A_start">start</code></td>
<td>
<p>A named numeric vector containing possible starting values, the names are based on
function <code><a href="#topic+parameters">parameters</a></code>.</p>
</td></tr>
<tr><td><code id="sam_MVNORM_+3A_n.samples">n.samples</code></td>
<td>
<p>Sets the number of samples that should be generated.</p>
</td></tr>
<tr><td><code id="sam_MVNORM_+3A_hessian">hessian</code></td>
<td>
<p>The Hessian matrix that should be used. Note that the row and column names
must be the same as the names of the <code><a href="#topic+parameters">parameters</a></code>. If <code>hessian = NULL</code>
the function uses <code><a href="stats.html#topic+optim">optim</a></code> to compute the Hessian if it is not provided
within <code>x</code>.</p>
</td></tr>
<tr><td><code id="sam_MVNORM_+3A_...">...</code></td>
<td>
<p>Arguments passed to function <code><a href="stats.html#topic+optim">optim</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Function <code>MVNORM()</code> returns samples of parameters. The samples are provided as a
<code><a href="coda.html#topic+mcmc">mcmc</a></code> matrix.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bamlss">bamlss</a></code>, <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>,
<code><a href="#topic+bamlss.engine.setup">bamlss.engine.setup</a></code>, <code><a href="#topic+set.starting.values">set.starting.values</a></code>, <code><a href="#topic+opt_bfit">opt_bfit</a></code>,
<code><a href="#topic+sam_GMCMC">sam_GMCMC</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Simulated data example illustrating
## how to call the sampler function.
## This is done internally within
## the setup of function bamlss().
d &lt;- GAMart()
f &lt;- num ~ s(x1, bs = "ps")
bf &lt;- bamlss.frame(f, data = d, family = "gaussian")

## First, find starting values with optimizer.
o &lt;- with(bf, opt_bfit(x, y, family))

## Sample.
samps &lt;- with(bf, sam_MVNORM(x, y, family, start = o$parameters))
plot(samps)
</code></pre>

<hr>
<h2 id='samples'>
Extract Samples
</h2><span id='topic+samples'></span><span id='topic+samples.bamlss'></span><span id='topic+samples.bamlss.frame'></span>

<h3>Description</h3>

<p>Generic function to extract samples from objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Generic.
samples(object, ...)

## Method for "bamlss" objects.
## S3 method for class 'bamlss'
samples(object, model = NULL, term = NULL,
  combine = TRUE, drop = TRUE, burnin = NULL,
  thin = NULL, coef.only = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samples_+3A_object">object</code></td>
<td>
<p>An object for which samples should be extracted.</p>
</td></tr>
<tr><td><code id="samples_+3A_model">model</code></td>
<td>
<p>Character or integer, specifies the model for which samples should be extracted.</p>
</td></tr>
<tr><td><code id="samples_+3A_term">term</code></td>
<td>
<p>Character or integer, specifies the term for which samples should be extracted.</p>
</td></tr>
<tr><td><code id="samples_+3A_combine">combine</code></td>
<td>
<p>Samples stored as a <code><a href="coda.html#topic+mcmc.list">mcmc.list</a></code>, e.g., when a model is estimated
on multiple cores, can be combined into one large sample matrix.</p>
</td></tr>
<tr><td><code id="samples_+3A_drop">drop</code></td>
<td>
<p>If there is only one <code>model</code> for which samples should be extracted, should
the list structure be dropped?</p>
</td></tr>
<tr><td><code id="samples_+3A_burnin">burnin</code></td>
<td>
<p>Integer, specifies the number of samples that should be withdrawn as a burn-in phase.</p>
</td></tr>
<tr><td><code id="samples_+3A_thin">thin</code></td>
<td>
<p>Integer, specifies the step length of samples that should be extracted, e.g.,
<code>thin = 10</code> mean that only every 10th sample is returned.</p>
</td></tr>
<tr><td><code id="samples_+3A_coef.only">coef.only</code></td>
<td>
<p>Logical, should only samples of model coefficients be returned?</p>
</td></tr>
<tr><td><code id="samples_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+bamlss">bamlss</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ## Generate data.
d &lt;- GAMart()

## Estimate model.
b &lt;- bamlss(num ~ s(x1) + s(x2) + s(x3), data = d)

## Extract samples for "s(x2)".
sa &lt;- samples(b, term = "s(x2)")
head(sa)

## Trace plot.
plot(sa)

## End(Not run)
</code></pre>

<hr>
<h2 id='samplestats'>
Sampling Statistics
</h2><span id='topic+samplestats'></span>

<h3>Description</h3>

<p>The function computes the average the log-likelihood, log-posterior, the deviance
information criterion and estimated degrees of freedom from samples of, e.g., a
<code><a href="#topic+bamlss">bamlss</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>samplestats(samples, x = NULL, y = NULL,
  family = NULL, logLik = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="samplestats_+3A_samples">samples</code></td>
<td>
<p>An object of class <code>"mcmc.list"</code> or <code>"bamlss"</code> which contains MCMC
samples.</p>
</td></tr>
<tr><td><code id="samplestats_+3A_x">x</code></td>
<td>
<p>The <code>x</code> list as returned by function <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>.</p>
</td></tr>
<tr><td><code id="samplestats_+3A_y">y</code></td>
<td>
<p>The model response, as returned by function <code><a href="#topic+bamlss.frame">bamlss.frame</a></code></p>
</td></tr>
<tr><td><code id="samplestats_+3A_family">family</code></td>
<td>
<p>A <code><a href="#topic+bamlss.family">bamlss.family</a></code> object.</p>
</td></tr>
<tr><td><code id="samplestats_+3A_loglik">logLik</code></td>
<td>
<p>Logical, should the log-likelihood be computed, may take some time!</p>
</td></tr>
<tr><td><code id="samplestats_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the log-likelihood is not available in the samples, the function tries to compute
the information. Depending on the complexity of the model, this may take some time.
Computations are based on the <code>$d()</code> or <code>$loglik()</code> function of the
<code><a href="#topic+bamlss.family">bamlss.family</a></code> object.
</p>
<p>If a <code><a href="#topic+bamlss.family">bamlss.family</a></code> object contains a function <code>$p2d()</code> or <code>$p2loglik()</code>,
which computes the log-likelihood from parameters, these functions are used for computation.
</p>


<h3>Value</h3>

<p>A list with the following entries (if available):
</p>
<table>
<tr><td><code>logLik</code></td>
<td>
<p>The average log-likelihood.</p>
</td></tr>
<tr><td><code>logPost</code></td>
<td>
<p>The average log-posterior.</p>
</td></tr>
<tr><td><code>DIC</code></td>
<td>
<p>The deviance information criterion.</p>
</td></tr>
<tr><td><code>pd</code></td>
<td>
<p>The estimated degrees of freedom.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+bamlss">bamlss</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ## Generate some data.
d &lt;- GAMart()

## Estimate model without sampling statistics
b &lt;- bamlss(num ~ s(x1) + s(x2) + s(x3) + te(lon,lat),
  data = d, samplestats = FALSE)

## Note: needs the $d() or $loglik() function in the family!
names(family(b))

## Compute sampling statistics.
samplestats(b)

## End(Not run)
</code></pre>

<hr>
<h2 id='scale2'>
Scaling Vectors and Matrices
</h2><span id='topic+scale2'></span>

<h3>Description</h3>

<p>The function scales numeric objects to specific ranges.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scale2(x, lower = -1.5, upper = 1.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scale2_+3A_x">x</code></td>
<td>
<p>Numeric, vector or matrix.</p>
</td></tr>
<tr><td><code id="scale2_+3A_lower">lower</code></td>
<td>
<p>The upper range.</p>
</td></tr>
<tr><td><code id="scale2_+3A_upper">upper</code></td>
<td>
<p>The lower range.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scaled numeric vector or matrix, scaled to the range provided in <code>lower</code>
and <code>upper</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(123)
x &lt;- runif(5)
scale2(x, -1, 1)
scale2(x, 0, 10)
</code></pre>

<hr>
<h2 id='simdata'>Reference data.</h2><span id='topic+simdata'></span>

<h3>Description</h3>

<p>Simulated data to test the implementation of the bamlss families.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("simdata")
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 3.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvnchol_bamlss">mvnchol_bamlss</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ## Reproducing code.
set.seed(111)
n &lt;- 2000

## build orthogonal rotation matrix
thetax &lt;- pi/4
thetay &lt;- pi/4
thetaz &lt;- pi/4
Rx &lt;- matrix( c(1,0,0, 0,cos(thetax),sin(thetax), 0,-sin(thetax),cos(thetax) ), 3, 3 )
Ry &lt;- matrix( c(cos(thetay),0,-sin(thetay), 0,1,0,  sin(thetay),0,cos(thetay) ), 3, 3 )
Rz &lt;- matrix( c(cos(thetaz),sin(thetaz),0, -sin(thetaz),cos(thetaz),0, 0,0,1 ), 3, 3 )
R &lt;- Rx %*% Ry %*% Rz

## non-linear functions
f1 &lt;- function(x) (sin(pi * x))^2
f2 &lt;- function(x) (cos(pi * x))^2

## random derivitates  
x &lt;- runif(n)

## eigenvalues
val1 &lt;- f1(x) 
val2 &lt;- f2(x)
val3 &lt;- rep(0, n)

## initialize vectors for parameter lists
p12 &lt;- NULL
p13 &lt;- NULL
p23 &lt;- NULL
sig &lt;- matrix(0, n, 3)

lamdiag &lt;- matrix(0, n, 3)
lambda &lt;- matrix(0, n, 3)

y &lt;- matrix(0, n, 3)
log_dens_ref &lt;- rep(0, n)

tau &lt;- .1  ## offset on diagonal
l &lt;- 0     ## count occasions with invertible cv 
dens1 &lt;- NULL
for ( ii in seq(n) ) {
    mu &lt;- rep(0, 3)
  
    val &lt;- diag( c(val1[ii], val2[ii], val3[ii]) ) + diag(tau, 3)
    ## compute covariance matrix from rotation matrix and eigenvalues
    cv &lt;- R %*% val %*% t(R)
  
    ## compute parameters for parameter list
    sig[ii,] &lt;- sqrt(diag(cv))
    p12[ii] &lt;- cv[1,2]
    p13[ii] &lt;- cv[1,3]
    p23[ii] &lt;- cv[2,3]
  
    ## compute paramters for Cholesky family
    chol_cv &lt;- solve(chol(cv))  # lambdas come from L^-1 not L
    lamdiag[ii,] &lt;- diag(chol_cv)
    lambda[ii,] &lt;- chol_cv[upper.tri(chol_cv)]
  
    ## Check if cv is invertible 
    if ( !is.matrix(try(chol(cv))) ) l &lt;- l + 1
  
    y[ii,] &lt;- mvtnorm::rmvnorm(1, mu, cv)
  
    log_dens_ref[ii] &lt;- mvtnorm::dmvnorm(y[ii,], mu, cv, log = TRUE)
}
print(l)

## Data
d &lt;- as.data.frame(y)
names(d) &lt;- paste0("y", 1:3)
d$x &lt;- x

## make parameter list for mvn chol family
par &lt;- list()
par[["mu1"]] &lt;- rep(0,n)
par[["mu2"]] &lt;- rep(0,n)
par[["mu3"]] &lt;- rep(0,n)
par[["lamdiag1"]] &lt;- lamdiag[,1]
par[["lamdiag2"]] &lt;- lamdiag[,2]
par[["lamdiag3"]] &lt;- lamdiag[,3]
par[["lambda12"]] &lt;- lambda[,1]
par[["lambda13"]] &lt;- lambda[,2]
par[["lambda23"]] &lt;- lambda[,3]

simdata &lt;- list(
    d   = d,
    par = par,
    y   = y
)

## save(simdata, file = "simdata.rda")
## End of simulation

## End(Not run)
</code></pre>

<hr>
<h2 id='simJM'>
Simulate longitudinal and survival data for joint models
</h2><span id='topic+simJM'></span><span id='topic+rJM'></span>

<h3>Description</h3>

<p>Simulates longitudinal data with normal error and (Cox-type) survival times
using the inversion method. The function <code>simJM()</code> is a wrapper specifying
all predictors and the resulting data sets. The wrapper calls <code>rJM()</code> to sample
the survival times, a modified version of <code>rSurvtime()</code> from the <span class="rlang"><b>R</b></span> package
<span class="pkg">CoxFlexBoost</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simJM(nsub = 300, times = seq(0, 120, 1), probmiss = 0.75,
  long_setting = "functional",
  alpha_setting = if(nonlinear) "linear" else "nonlinear",
  dalpha_setting = "zero", sigma = 0.3, long_df = 6, tmax = NULL,
  seed = NULL, full = FALSE, file = NULL, nonlinear = FALSE,
  fac = FALSE)
  
rJM(hazard, censoring, x, r, 
  subdivisions = 1000, tmin = 0, tmax,
  file = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simJM_+3A_nsub">nsub</code></td>
<td>
<p>number of individuals for which longitudinal data and survival times should be simulated.</p>
</td></tr>
<tr><td><code id="simJM_+3A_times">times</code></td>
<td>
<p>vector of time points at which longitudinal measurements are &quot;sampled&quot;.</p>
</td></tr>
<tr><td><code id="simJM_+3A_probmiss">probmiss</code></td>
<td>
<p>proportion of longitudinal measurements to be set to missing. Used to induce
sparsity in the longitudinal measurements.</p>
</td></tr>
<tr><td><code id="simJM_+3A_long_setting">long_setting</code></td>
<td>
<p>Specification of the longitudinal trajectories of the sampled subjects.
Preset specifications are <code>"linear"</code>, <code>"nonlinear"</code> and <code>"functional"</code>. See Details.</p>
</td></tr>
<tr><td><code id="simJM_+3A_alpha_setting">alpha_setting</code></td>
<td>
<p>specification of the association between survival and longitudinal. Preset
specifications are <code>"simple"</code>, <code>"linear"</code>, <code>"nonlinear"</code> and
<code>"nonlinear2"</code>. See Details.</p>
</td></tr>
<tr><td><code id="simJM_+3A_dalpha_setting">dalpha_setting</code></td>
<td>
<p>specification of the association between survival and the derivative of the
longitudinal. Work in progress.</p>
</td></tr>
<tr><td><code id="simJM_+3A_sigma">sigma</code></td>
<td>
<p>standard deviation of the normal error around the true longitudinal measurements.</p>
</td></tr>
<tr><td><code id="simJM_+3A_long_df">long_df</code></td>
<td>
<p>number of basis functions from which functional random intercepts are sampled.</p>
</td></tr>
<tr><td><code id="simJM_+3A_tmax">tmax</code></td>
<td>
<p>For function <code>simJM()</code>, longest possible survival time, observations are censored
after that timepoint. Defaults to <code>max(times)</code> and should not be specified longer than
<code>max(times)</code> for longitudinal setting &quot;functional&quot;. For function <code>rJM()</code>, latest
time point to sample a survival time.</p>
</td></tr>
<tr><td><code id="simJM_+3A_seed">seed</code></td>
<td>
<p>numeric scalar setting the random seed.</p>
</td></tr>
<tr><td><code id="simJM_+3A_full">full</code></td>
<td>
<p>logical indicating if only the longitudinal data set should be returned (<code>FALSE</code>)
or additionally also the data for the survival part evaluated on a regular time grid and the
longitudinal data set without longitudinal missings (<code>TRUE</code>). </p>
</td></tr>
<tr><td><code id="simJM_+3A_file">file</code></td>
<td>
<p>name of the data file the generated data set should be stored into
(e.g., &quot;simdata.RData&quot;) or NULL if the dataset should directly be returned in <span class="rlang"><b>R</b></span>.</p>
</td></tr>
<tr><td><code id="simJM_+3A_nonlinear">nonlinear</code></td>
<td>
<p>If set to <code>TRUE</code>, a nonlinear interaction between <code>alpha</code> and
<code>mu</code> is simulated.</p>
</td></tr>
<tr><td><code id="simJM_+3A_fac">fac</code></td>
<td>
<p>If set to <code>TRUE</code>, a smooth interaction that varies by a factor is simulated.</p>
</td></tr>
<tr><td><code id="simJM_+3A_hazard">hazard</code></td>
<td>
<p>complete hazard function to specify the joint model. Time must be the
first argument.</p>
</td></tr>
<tr><td><code id="simJM_+3A_censoring">censoring</code></td>
<td>
<p>function to compute (random) censoring. </p>
</td></tr>
<tr><td><code id="simJM_+3A_x">x</code></td>
<td>
<p>matrix of sampled covariate values.</p>
</td></tr>
<tr><td><code id="simJM_+3A_r">r</code></td>
<td>
<p>matrix of sampled random coefficients.</p>
</td></tr>
<tr><td><code id="simJM_+3A_subdivisions">subdivisions</code></td>
<td>
<p>the maximum number of subintervals for the integration.</p>
</td></tr>
<tr><td><code id="simJM_+3A_tmin">tmin</code></td>
<td>
<p>earliest time point to sample a survival time.</p>
</td></tr>
<tr><td><code id="simJM_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>hazard</code> or <code>censoring</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function simulates longitudinal data basing on the given specification at given <code>times</code>.
The full hazard is built from all joint model predictors <code class="reqn">\eta_{\mu}</code>, <code class="reqn">\eta_{\sigma}</code>,
<code class="reqn">\eta_{\lambda}</code>, <code class="reqn">\eta_{\gamma}</code>, <code class="reqn">\eta_{\alpha}</code> as presented in
Koehler, Umlauf, and Greven (2016), see also <code><a href="#topic+jm_bamlss">jm_bamlss</a></code>. Survival times are sampled using the inversion
method (cf. Bender, Augustin, &amp; Blettner, 2005). Additional censoring and missingness is
introduced. The longitudinal information is censored according to the survival information. The
user can also specify own predictors and use only <code>rJM</code> to simulate survival times
accordingly.  
</p>
<p>Pre-specified functions for <code class="reqn">\eta_{\mu}</code> in <code>long_setting</code> are for <code>linear</code>
</p>
<p style="text-align: center;"><code class="reqn">\eta_{\mu i}(t) = 1.25 + r_{1i} + 0.6 \sin(x_{2i}) + (-0.01) t + 0.02 r_{2i} t</code>
</p>
<p>,
for <code>nonlinear</code> </p>
<p style="text-align: center;"><code class="reqn">\eta_{\mu i}(t) = 0.5 + r_{1i} + 0.6 \sin(x_{2i}) + 0.1 (t+1) \exp(-0.075 t)</code>
</p>

<p>and for <code>functional</code>
</p>
<p style="text-align: center;"><code class="reqn">\eta_{\mu i}(t) = 0.5 + r_{1i} + 0.6 \sin(x_{2i}) + 0.1 (t+1) \exp(-0.075 t) + \sum_k \beta_{ki} B(t)</code>
</p>
<p>,
where <code class="reqn">B(.)</code> denotes a B-spline basis function and <code class="reqn">\beta_{ki}</code> are the sampled penalized
coefficients from <code>gen_b</code> per person. 
</p>
<p>Prespecified functions for <code class="reqn">\eta_{\alpha}</code> in <code>alpha_setting</code> are for <code>constant</code>
</p>
<p style="text-align: center;"><code class="reqn">\eta_{\alpha}(t) = 1</code>
</p>
<p>, for <code>linear</code> </p>
<p style="text-align: center;"><code class="reqn">\eta_{\alpha}(t) = 1 - 0.015 t</code>
</p>
<p>, for
<code>nonlinear</code> </p>
<p style="text-align: center;"><code class="reqn">\eta_{\alpha}(t) = \cos((time-20)/20)</code>
</p>
<p>, and for <code>nonlinear</code>
</p>
<p style="text-align: center;"><code class="reqn">\eta_{\alpha}(t) = \cos((time-33)/33)</code>
</p>
<p>. 
</p>
<p>Additionally the fixed functions for <code class="reqn">\eta_{\lambda} = 0.1(t+2)\exp(-0.075t)</code> and
<code class="reqn">\eta_{\lambda} = 0.1(t+2)\exp(-0.075t)</code> are employed.
</p>


<h3>Value</h3>

<p>For <code>full = TRUE</code> a list of the three <code>data.frame</code>s is returned:
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p>Simulated dataset in long format including all longitudinal and survival covariates.</p>
</td></tr>
<tr><td><code>data_grid</code></td>
<td>
<p>Dataset of the time-varying survival predictors which are not subject specific,
evaluated at a grid of fixed time points.</p>
</td></tr>
<tr><td><code>data_full</code></td>
<td>
<p>Simulated data set prior to generating longitudinal missings. Useful to
assess the longitudinal fit.</p>
</td></tr>
</table>
<p>For <code>full = FALSE</code> only the first dataset is returned. 
</p>
<p>Covariates within these datasets include a subject identifier <code>id</code>, the sampled survival
times <code>survtime</code>, the event indicator <code>event</code>, the time points of longitudinally
&quot;observed&quot; measurements  <code>obstime</code>,   the longitudinal response <code>y</code>, the cumulative
hazard at the survival time <code>cumhaz</code>, as well as covariates  <code>x1, x2</code>, random effects
<code>r1, r2, b1, ...</code>,  and the true predictors <code>alpha, lambda, gamma, mu, sigma</code>. 
</p>


<h3>References</h3>

<p>Hofner, B (2016). <span class="pkg">CoxFlexBoost</span>: Boosting Flexible Cox Models
(with Time-Varying Effects). <span class="rlang"><b>R</b></span> package version 0.7-0.
</p>
<p>Bender, R., Augustin, T., and Blettner, M. (2005).
Generating Survival Times to Simulate Cox Proportional Hazards Models.
<em>Statistics in Medicine</em>, <b>24</b>, 1713-1723.
</p>
<p>Koehler N, Umlauf N, Beyerlein, A., Winkler, C., Ziegler, A., and Greven S (2016). Flexible Bayesian Additive Joint Models with an
Application to Type 1 Diabetes Research. <em>(submitted)</em>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jm_bamlss">jm_bamlss</a></code>, <code><a href="#topic+opt_JM">opt_JM</a></code>, <code><a href="#topic+sam_JM">sam_JM</a></code>, <code><a href="#topic+bamlss">bamlss</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ## Simulate survival data
## with functional random intercepts and a nonlinear effect 
## of time, time-varying association alpha.
d &lt;- simJM(nsub = 300)
head(d)

## Simulate survival data
## with random intercepts/slopes and a linear effect of time,
## constant association alpha.
d &lt;- simJM(nsub = 200, long_setting = "linear", 
  alpha_setting = "constant")
head(d)

## End(Not run)
</code></pre>

<hr>
<h2 id='simSurv'>
Simulate Survival Times
</h2><span id='topic+simSurv'></span><span id='topic+rSurvTime2'></span>

<h3>Description</h3>

<p>Function <code>simSurv()</code> and <code>rSurvtime2()</code> simulate arbitrary (Cox-type) survival times
using the inversion method. Function <code>simSurv()</code> is a simple wrapper that calls
<code>rSurvtime2()</code>. The functions are based on the <span class="rlang"><b>R</b></span> package <span class="pkg">CoxFlexBoost</span> implementation
<code>rSurvtime()</code> and only slightly modify the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Simulate a pre-specified survival times data set.
simSurv(n = 300)

## Simulate arbitrary survival times.
rSurvTime2(lambda, x, cens_fct, upper = 1000, ...,
  file = NULL, subdivisions = 1000)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simSurv_+3A_n">n</code></td>
<td>
<p>The number of individuals for which survival times should be simulated.</p>
</td></tr>
<tr><td><code id="simSurv_+3A_lambda">lambda</code></td>
<td>
<p>function. Baseline hazard <code class="reqn">\lambda(t, x)</code>
where time must be first argument. </p>
</td></tr>
<tr><td><code id="simSurv_+3A_x">x</code></td>
<td>
<p>matrix. (Sampled) values for covariates (without time). </p>
</td></tr>
<tr><td><code id="simSurv_+3A_cens_fct">cens_fct</code></td>
<td>
<p> function. Function to compute (random) censoring. </p>
</td></tr>
<tr><td><code id="simSurv_+3A_upper">upper</code></td>
<td>
<p> upper boundary of the interval the random survival times fall into. </p>
</td></tr>
<tr><td><code id="simSurv_+3A_...">...</code></td>
<td>
<p>further arguments to be passed to <code>lambda</code> or <code>cens_fct</code>. </p>
</td></tr>
<tr><td><code id="simSurv_+3A_file">file</code></td>
<td>
<p>character. name of the data file the generated data set should be stored into
(e.g., &quot;survtimes.RData&quot;) or NULL if the dataset should directly be returned in <span class="rlang"><b>R</b></span>. </p>
</td></tr>
<tr><td><code id="simSurv_+3A_subdivisions">subdivisions</code></td>
<td>
<p>The maximum number of subintervals for the integration.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is basically a slight modification according the computation of the integral,
see the manual page of function <code>rSurvtime()</code> of package <code>CoxFlexBoost</code> for
details.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> consisting of the observed survival time
(<code>time</code>), the non-censoring indicator (<code>event</code>) and further
covariates <code>x</code> is returned. If <code>file</code> is specified, the
data.frame is additionally stored on the disc.
</p>


<h3>References</h3>

<p>Benjamin Hofner (2016). <span class="pkg">CoxFlexBoost</span>: Boosting Flexible Cox Models
(with Time-Varying Effects). R package version 0.7-0.
</p>
<p>Ralph Bender and Thomas Augustin and Maria Blettner (2005),
Generating Survival Times to Simulate Cox Proportional Hazards Models.
<em>Statistics in Medicine</em>, <b>24</b>, 1713-1723.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cox_bamlss">cox_bamlss</a></code>, <code><a href="#topic+opt_Cox">opt_Cox</a></code>, <code><a href="#topic+sam_Cox">sam_Cox</a></code>, <code><a href="#topic+bamlss">bamlss</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The following shows the code of the
## wrapper function simSurv().
set.seed(111)
n &lt;- 100
X &lt;- matrix(NA, nrow = n, ncol = 3)
X[, 1] &lt;- runif(n, -1, 1)
X[, 2] &lt;- runif(n, -3, 3)
X[, 3] &lt;- runif(n, -1, 1)

## Specify censoring function.
cens_fct &lt;- function(time, mean_cens) {
  ## Censoring times are independent exponentially distributed.
  censor_time &lt;- rexp(n = length(time), rate = 1 / mean_cens)
  event &lt;- (time &lt;= censor_time)
  t_obs &lt;- apply(cbind(time, censor_time), 1, min)
  ## Return matrix of observed survival times and event indicator.
  return(cbind(t_obs, event))
}

## log(time) is the baseline hazard.
lambda &lt;-  function(time, x) {
  exp(log(time) + 0.7 * x[1] + sin(x[2]) + sin(time * 2) * x[3])
}

## Simulate data with lambda() and cens_fct().
d &lt;- rSurvTime2(lambda, X, cens_fct, mean_cens = 5)
</code></pre>

<hr>
<h2 id='sliceplot'>
Plot Slices of Bivariate Functions 
</h2><span id='topic+sliceplot'></span>

<h3>Description</h3>

<p>This function plots slices from user defined values of bivariate surfaces.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sliceplot(x, y = NULL, z = NULL, view = 1, c.select = NULL,
  values = NULL, probs = c(0.1, 0.5, 0.9), grid = 100,
  legend = TRUE, pos = "topright", digits = 2, data = NULL,
  rawdata = FALSE, type = "mba", linear = FALSE,
  extrap = FALSE, k = 40, rug = TRUE, rug.col = NULL,
  jitter = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sliceplot_+3A_x">x</code></td>
<td>
<p>A matrix or data frame, containing the covariates for which the effect should be plotted 
in the first and second column and at least a third column containing the effect. Another
possibility is to specify the plot via a <code>formula</code>, 
e.g., for simple plotting of bivariate surfaces <code>z ~ x + y</code>, see the examples.</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_y">y</code></td>
<td>
<p>If <code>x</code> is a vector the argument <code>y</code> and <code>z</code> must also be supplied as
vectors.</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_z">z</code></td>
<td>
<p>If <code>x</code> is a vector the argument <code>y</code> and <code>z</code> must also be supplied as
vectors, <code>z</code> defines the surface given by <code class="reqn">z = f(x, y)</code>.</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_view">view</code></td>
<td>
<p>Which variable should be used for the x-axis of the plot, the other variable will be
used to compute the slices. May also be a <code>character</code> with the name of the corresponding
variable.</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_c.select">c.select</code></td>
<td>
<p>Integer, selects the column that is used in the resulting matrix to be
used as the <code>z</code> argument.</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_values">values</code></td>
<td>
<p>The values of the <code>x</code> or <code>y</code> variable that should be used for computing
the slices, if set to <code>NULL</code>, slices will be constructed according to the quantiles, see
also argument <code>probs</code>.</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_probs">probs</code></td>
<td>
<p>Numeric vector of probabilities with values in [0,1] to be used within function
<code><a href="stats.html#topic+quantile">quantile</a></code> to compute the <code>values</code> for plotting the slices.</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_grid">grid</code></td>
<td>
<p>The grid size of the surface where the slices are generated from.</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_legend">legend</code></td>
<td>
<p>If set to <code>TRUE</code>, a legend with the <code>values</code> that where used for slicing
will be added.</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_pos">pos</code></td>
<td>
<p>The position of the legend, see also function <code><a href="graphics.html#topic+legend">legend</a></code>.</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_digits">digits</code></td>
<td>
<p>The decimal place the legend values should be rounded.</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_data">data</code></td>
<td>
<p>If <code>x</code> is a <code>formula</code>, a <code>data.frame</code> or <code>list</code>. By default the 
variables are taken from <code>environment(x)</code>: typically the environment from which 
<code>plot3d</code> is called.</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_rawdata">rawdata</code></td>
<td>
<p>If set to <code>TRUE</code>, the data will not be interpolated, only raw data will be
used. This is useful when displaying data on a regular grid.</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_type">type</code></td>
<td>
<p>Character, which type of interpolation method should be used. The default is
<code>type = "akima"</code>, see function <code><a href="akima.html#topic+interp">interp</a></code>. The two other options are
<code>type = "mba"</code>, which calls function <code><a href="MBA.html#topic+mba.surf">mba.surf</a></code> of package <span class="pkg">MBA</span>, or
<code>type = "mgcv"</code>, which uses a spatial smoother withing package <span class="pkg">mgcv</span> for interpolation.
The last option is definitely the slowest, since a full regression model needs to be estimated.</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_linear">linear</code></td>
<td>
<p>Logical, should linear interpolation be used withing function
<code><a href="akima.html#topic+interp">interp</a></code>?</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_extrap">extrap</code></td>
<td>
<p>Logical, should interpolations be computed outside the observation area
(i.e., extrapolated)?</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_k">k</code></td>
<td>
<p>Integer, the number of basis functions to be used to compute the interpolated surface
when <code>type = "mgcv"</code>.</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_rug">rug</code></td>
<td>
<p>Add a <code><a href="graphics.html#topic+rug">rug</a></code> to the plot.</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_jitter">jitter</code></td>
<td>
<p>If set to <code>TRUE</code> a <code><a href="base.html#topic+jitter">jitter</a></code>ed 
<code><a href="graphics.html#topic+rug">rug</a></code> plot is added.</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_rug.col">rug.col</code></td>
<td>
<p>Specify the color of the rug representation.</p>
</td></tr>
<tr><td><code id="sliceplot_+3A_...">...</code></td>
<td>
<p>Parameters passed to <code><a href="graphics.html#topic+matplot">matplot</a></code> and <code><a href="graphics.html#topic+legend">legend</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Similar to function <code><a href="#topic+plot3d">plot3d</a></code>, this function first applies bivariate interpolation
on a regular <code>grid</code>, afterwards the slices are computed from the resulting surface. 
</p>


<h3>Note</h3>

<p>Function <code>sliceplot</code> can use the <span class="pkg">akima</span> package to construct smooth interpolated
surfaces, therefore, package <span class="pkg">akima</span> needs to be installed. The <span class="pkg">akima</span> package has an ACM
license that restricts applications to non-commercial usage, see
</p>
<p><a href="https://www.acm.org/publications/policies/software-copyright-notice">https://www.acm.org/publications/policies/software-copyright-notice</a>
</p>
<p>Function <code>sliceplot</code> prints a note referring to the ACM license. This note can be suppressed by
setting
</p>
<p><code>options("use.akima" = TRUE)</code> 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot2d">plot2d</a></code>, <code><a href="#topic+plot3d">plot3d</a></code>,
<code><a href="#topic+plotmap">plotmap</a></code>, <code><a href="#topic+plotblock">plotblock</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate some data.
set.seed(111)
n &lt;- 500

## Regressors.
d &lt;- data.frame(z = runif(n, -3, 3), w = runif(n, 0, 6))

## Response.
d$y &lt;- with(d, 1.5 + cos(z) * sin(w) + rnorm(n, sd = 0.6))

## Not run: ## Estimate model.
b &lt;- bamlss(y ~ te(z, w), data = d)
summary(b)

## Plot estimated effect.
plot(b, term = "te(z,w)", sliceplot = TRUE)
plot(b, term = "te(z,w)", sliceplot = TRUE, view = 2)
plot(b, term = "te(z,w)", sliceplot = TRUE, view = "w")
plot(b, term = "te(z,w)", sliceplot = TRUE, probs = seq(0, 1, length = 10))

## End(Not run)

## Variations.
d$f1 &lt;- with(d, sin(z) * cos(w))
sliceplot(cbind(z = d$z, w = d$w, f1 = d$f1))

## Same with formula. 
sliceplot(sin(z) * cos(w) ~ z + w, ylab = "f(z)", data = d)

## Compare with plot3d().
plot3d(sin(z) * 1.5 * w ~ z + w, zlab = "f(z,w)", data = d)
sliceplot(sin(z) * 1.5 * w ~ z + w, ylab = "f(z)", data = d)
sliceplot(sin(z) * 1.5 * w ~ z + w, view = 2, ylab = "f(z)", data = d)
</code></pre>

<hr>
<h2 id='smooth_check'>
MCMC Based Simple Significance Check for Smooth Terms
</h2><span id='topic+smooth_check'></span>

<h3>Description</h3>

<p>For each smooth term estimated with MCMC, the function computes 95
intervals and simply computes the fraction of the cases where the interval does not contain zero.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth_check(object, newdata = NULL, model = NULL, term = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth_check_+3A_object">object</code></td>
<td>
<p>A fitted model object which contains MCMC samples.</p>
</td></tr>
<tr><td><code id="smooth_check_+3A_newdata">newdata</code></td>
<td>
<p>Optionally, use new data for computing the check.</p>
</td></tr>
<tr><td><code id="smooth_check_+3A_model">model</code></td>
<td>
<p>Character, for which model should the check be computed?</p>
</td></tr>
<tr><td><code id="smooth_check_+3A_term">term</code></td>
<td>
<p>Character, for which term should the check be computed?</p>
</td></tr>
<tr><td><code id="smooth_check_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+predict.bamlss">predict.bamlss</a></code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ## Simulate some data.
d &lt;- GAMart()

## Model formula.
f &lt;- list(
  num ~ s(x1) + s(x2) + s(x3),
  sigma ~ s(x1) + s(x2) + s(x3)
)

## Estimate model with MCMC.
b &lt;- bamlss(f, data = d)

## Run the check, note that all variables
## for sigma should have no effect.
smooth_check(b)

## End(Not run)
</code></pre>

<hr>
<h2 id='smooth.construct'>Constructor Functions for Smooth Terms in BAMLSS</h2><span id='topic+smooth.construct'></span><span id='topic+smooth.construct.bamlss.frame'></span><span id='topic+smooth.construct.bamlss.formula'></span><span id='topic+smooth.construct.bamlss.terms'></span>

<h3>Description</h3>

<p>The generic function is only a copy of <code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code> adding
a <code>...</code> argument. For objects of class <code>"bamlss.frame"</code> and <code>"bamlss"</code> the
method extracts all smooth model terms, see function <code><a href="#topic+bamlss.frame">bamlss.frame</a></code> for details
on the setup of BAMLSS.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## Function as in package mgcv
## but with additional dots argument.
smooth.construct(object, data, knots, ...)

## For 'bamlss.frame's.
## S3 method for class 'bamlss.frame'
smooth.construct(object, data = NULL, knots = NULL,
  model = NULL, drop = TRUE, ...)

## S3 method for class 'bamlss.formula'
smooth.construct(object, data = NULL, knots = NULL,
  model = NULL, drop = TRUE, ...)

## S3 method for class 'bamlss.terms'
smooth.construct(object, data = NULL, knots = NULL,
  model = NULL, drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth.construct_+3A_object">object</code></td>
<td>
<p>Either a smooth specification object, or object of class <code>"bamlss"</code>,
<code>"bamlss.frame"</code>, <code>"bamlss.formula"</code> or <code>"bamlss.terms"</code>. For smooth
specification objects, see function <code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code>.</p>
</td></tr>
<tr><td><code id="smooth.construct_+3A_data">data</code></td>
<td>
<p>A data frame or list, see also see function <code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code>.</p>
</td></tr>
<tr><td><code id="smooth.construct_+3A_knots">knots</code></td>
<td>
<p>See function <code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code>.</p>
</td></tr>
<tr><td><code id="smooth.construct_+3A_model">model</code></td>
<td>
<p>Character, specifies for which model parameter the smooth constructs should be
created.</p>
</td></tr>
<tr><td><code id="smooth.construct_+3A_drop">drop</code></td>
<td>
<p>If there is only one model parameter the returned named list is simplified.</p>
</td></tr>
<tr><td><code id="smooth.construct_+3A_...">...</code></td>
<td>
<p>Arguments passed to the smooth term constructor functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>For smooth specification objects see function see <code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code>. For
objects of class <code>"bamlss.frame"</code> or <code>"bamlss"</code> the list of smooth constructs,
see function <code><a href="#topic+bamlss.frame">bamlss.frame</a></code> for more details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bamlss.frame">bamlss.frame</a></code>, <code><a href="#topic+bamlss.formula">bamlss.formula</a></code>,
<code><a href="#topic+bamlss">bamlss</a></code>, <code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Generate some data.
d &lt;- GAMart()

## Create a "bamlss.frame".
bf &lt;- bamlss.frame(num ~ s(x1) + s(x2), data = d)

## Extract the smooth construct.
sc &lt;- smooth.construct(bf)
str(sc)

## Also possible with formulas.
f &lt;- bamlss.formula(list(
  num ~ s(x1) + te(lon,lat),
  sigma ~ s(x2)
), family = "gaussian")

sc &lt;- smooth.construct(f, data = d)
str(sc)
</code></pre>

<hr>
<h2 id='smooth.construct.kr.smooth.spec'>Kriging Smooth Constructor</h2><span id='topic+smooth.construct.kr.smooth.spec'></span><span id='topic+Predict.matrix.kriging.smooth'></span>

<h3>Description</h3>

<p>This smooth constructor implements a kriging based model term.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'kr.smooth.spec'
smooth.construct(object, data, knots, ...)
## S3 method for class 'kriging.smooth'
Predict.matrix(object, data)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth.construct.kr.smooth.spec_+3A_object">object</code>, <code id="smooth.construct.kr.smooth.spec_+3A_data">data</code>, <code id="smooth.construct.kr.smooth.spec_+3A_knots">knots</code></td>
<td>
<p>See <code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code>.</p>
</td></tr>
<tr><td><code id="smooth.construct.kr.smooth.spec_+3A_...">...</code></td>
<td>
<p>Currently not  used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This smooth constructor implements univariate and bivariate Kriging terms. The
basis functions are based on the Matern covariance function. For finding
knots, a space filling algorithm is used, see <code><a href="fields.html#topic+cover.design">cover.design</a></code>.
</p>


<h3>Value</h3>

<p>A smooth specification object, see also <code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a>.</code>
</p>


<h3>References</h3>

<p>Fahrmeir, L., Kneib, T. , Lang, S., Marx, B. (2013): Regression. Models, Methods and Applications,
Springer Verlag. <code>https://www.uni-goettingen.de/de/551357.html</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bamlss">bamlss</a></code>, <code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ## Simulate data.
set.seed(123)
d &lt;- GAMart()

## Estimate model.
f &lt;- num ~ s(x1,bs="kr") + s(x2,bs="kr") + s(x3,bs="kr") + s(lon,lat,bs="kr",k=30)

## Set the seed, estimate model.
set.seed(111)
b &lt;- bamlss(f, data = d)

## Plot estimated effects.
plot(b)

## End(Not run)
</code></pre>

<hr>
<h2 id='smooth.construct.ms.smooth.spec'>Smooth constructor for monotonic P-splines</h2><span id='topic+smooth.construct.ms.smooth.spec'></span>

<h3>Description</h3>

<p>The function sets up a smooth term for shape constraint estimation of
P-spline model terms. Note that this currently only works using boosting and backfitting.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ms.smooth.spec'
smooth.construct(object, data, knots, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth.construct.ms.smooth.spec_+3A_object">object</code></td>
<td>
<p>Either a smooth specification object, or object of class <code>"bamlss"</code>,
<code>"bamlss.frame"</code>, <code>"bamlss.formula"</code> or <code>"bamlss.terms"</code>. For smooth
specification objects, see function <code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code>.</p>
</td></tr>
<tr><td><code id="smooth.construct.ms.smooth.spec_+3A_data">data</code></td>
<td>
<p>A data frame or list, see also see function <code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code>.</p>
</td></tr>
<tr><td><code id="smooth.construct.ms.smooth.spec_+3A_knots">knots</code></td>
<td>
<p>See function <code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code>.</p>
</td></tr>
<tr><td><code id="smooth.construct.ms.smooth.spec_+3A_...">...</code></td>
<td>
<p>Arguments passed to the smooth term constructor functions.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See function see <code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bamlss.frame">bamlss.frame</a></code>, <code><a href="#topic+bamlss.formula">bamlss.formula</a></code>,
<code><a href="#topic+bamlss">bamlss</a></code>, <code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ## Generate some data.
set.seed(123)

n &lt;- 300
x &lt;- runif(n, -2, 3)
y &lt;- sin(x) + rnorm(n, sd = 0.1)

d &lt;- data.frame("y" = y, "x" = x)

## Increasing: constr = 1.
## Decreasing: constr = 2.
b &lt;- bamlss(y ~ s2(x,bs="ms",xt=list(constr=1)),
  data = d, optimizer = opt_bfit, sampler = sam_MVNORM)

## Predict and plot.
p &lt;- predict(b, model = "mu", FUN = c95)
plot(y ~ x)
plot2d(p ~ x, add = TRUE, col.lines = 4, lwd = 2)

## End(Not run)</code></pre>

<hr>
<h2 id='smooth.construct.sr.smooth.spec'>Random Effects P-Spline</h2><span id='topic+smooth.construct.sr.smooth.spec'></span>

<h3>Description</h3>

<p>This smooth constructor implements the random effects representation of a P-spline.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sr.smooth.spec'
smooth.construct(object, data, knots, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth.construct.sr.smooth.spec_+3A_object">object</code>, <code id="smooth.construct.sr.smooth.spec_+3A_data">data</code>, <code id="smooth.construct.sr.smooth.spec_+3A_knots">knots</code></td>
<td>
<p>See <code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code>.</p>
</td></tr>
<tr><td><code id="smooth.construct.sr.smooth.spec_+3A_...">...</code></td>
<td>
<p>Currently not used.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See <code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bamlss">bamlss</a></code>, <code><a href="#topic+predict.bamlss">predict.bamlss</a></code>, <code><a href="#topic+opt_bfit">opt_bfit</a></code>, <code><a href="#topic+opt_boost">opt_boost</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ## Simulate data.
set.seed(123)
d &lt;- GAMart()

## Estimate model.
f &lt;- num ~ x1 + x2 + x3 + s2(x1,bs="sr") + s2(x2,bs="sr") + s2(x3,bs="sr")

b &lt;- bamlss(f, data = d, optimizer = boost, sampler = FALSE)

plot(b)

## End(Not run)
</code></pre>

<hr>
<h2 id='stabsel'>Stability selection.</h2><span id='topic+stabsel'></span><span id='topic+plot.stabsel'></span>

<h3>Description</h3>

<p>Performs stability selection based on gradient boosting.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stabsel(formula, data, family = "gaussian",
  q, maxit, B = 100, thr = .9, fraction = 0.5, seed = NULL, ...)

## Plot selection frequencies.
## S3 method for class 'stabsel'
plot(x, show = NULL,
  pal = function(n) gray.colors(n, start = 0.9, end = 0.3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="stabsel_+3A_formula">formula</code></td>
<td>
<p> A formula or extended formula. </p>
</td></tr>
<tr><td><code id="stabsel_+3A_data">data</code></td>
<td>
<p> A <code><a href="base.html#topic+data.frame">data.frame</a></code>. </p>
</td></tr>
<tr><td><code id="stabsel_+3A_family">family</code></td>
<td>
<p> A <code><a href="#topic+bamlss.family">bamlss.family</a></code> object. </p>
</td></tr>
<tr><td><code id="stabsel_+3A_q">q</code></td>
<td>
<p> An integer specifying how many terms to select in each boosting run. </p>
</td></tr>
<tr><td><code id="stabsel_+3A_maxit">maxit</code></td>
<td>
<p> An integer specifying the maximum number of boosting iterations.
See <code><a href="#topic+opt_boost">opt_boost</a></code>. Either choose <code>q</code> or <code>maxit</code> as hyper-parameter
for regularization.</p>
</td></tr>
<tr><td><code id="stabsel_+3A_b">B</code></td>
<td>
<p> An integer. The boosting is run B times. </p>
</td></tr>
<tr><td><code id="stabsel_+3A_thr">thr</code></td>
<td>
<p> Cut-off threshold of relative frequencies (between 0 and 1) for selection. </p>
</td></tr>
<tr><td><code id="stabsel_+3A_fraction">fraction</code></td>
<td>
<p> Numeric between 0 and 1. The fraction of data to be used in each
boosting run. </p>
</td></tr>
<tr><td><code id="stabsel_+3A_seed">seed</code></td>
<td>
<p>A seed to be set before the stability selection.</p>
</td></tr>
<tr><td><code id="stabsel_+3A_x">x</code></td>
<td>
<p> A object of class stabsel. </p>
</td></tr>
<tr><td><code id="stabsel_+3A_show">show</code></td>
<td>
<p> Number of terms to be shown. </p>
</td></tr>
<tr><td><code id="stabsel_+3A_pal">pal</code></td>
<td>
<p> Color palette for different model terms. </p>
</td></tr>
<tr><td><code id="stabsel_+3A_...">...</code></td>
<td>
<p> Not used yet in <code>stabsel</code>. </p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>stabsel</code> performs stability selection based on gradient
boosting (<code><a href="#topic+opt_boost">opt_boost</a></code>): The boosting algorithm is run
<code>B</code> times on a randomly drawn <code>fraction</code> of the <code>data</code>.
Each boosting run is stopped either when <code>q</code> terms have been selected,
or when <code>maxit</code> iterations have been performed, i.e. either <code>q</code>
or <code>maxit</code> can be used to tune the regularization of the boosting.
After the boosting the relative selection frequencies are evaluated.
Terms with a relative selection frequency larger then <code>thr</code>
are suggested for a final regression model.
</p>
<p>If neither <code>q</code> nor <code>maxit</code> has been specified, <code>q</code>
will be set to the square root of the number of columns in <code>data</code>.
</p>
<p>Gradient boosting does not depend on random numbers. Thus, the
individual boosting runs differ only in the subset of data which
is used.
</p>


<h3>Value</h3>

<p>A object of class stabsel.
</p>


<h3>Author(s)</h3>

<p>Thorsten Simon</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ## Simulate some data.
set.seed(111)
d &lt;- GAMart()
n &lt;- nrow(d)

## Add some noise variables.
for(i in 4:9)
  d[[paste0("x",i)]] &lt;- rnorm(n)

f &lt;- paste0("~ ", paste("s(x", 1:9, ")", collapse = "+", sep = ""))
f &lt;- paste(f, "+ te(lon,lat)")
f &lt;- as.formula(f)
f &lt;- list(update(f, num ~ .), f)

## Run stability selection.
sel &lt;- stabsel(f, data = d, q = 6, B = 10)
plot(sel)

## Estimate selected model.
nf &lt;- formula(sel)
b &lt;- bamlss(nf, data = d)
plot(b)

## End(Not run)
</code></pre>

<hr>
<h2 id='summary.bamlss'>
Summary for BAMLSS
</h2><span id='topic+summary.bamlss'></span><span id='topic+print.summary.bamlss'></span>

<h3>Description</h3>

<p>The function takes an object of class <code>"bamlss"</code> and produces summaries
of optimizer and sampler function outputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bamlss'
summary(object, model = NULL,
  FUN = NULL, parameters = TRUE, ...)

## S3 method for class 'summary.bamlss'
print(x, digits = max(3, getOption("digits") - 3), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.bamlss_+3A_object">object</code></td>
<td>
<p>An object of class &quot;bamlss&quot;.</p>
</td></tr>
<tr><td><code id="summary.bamlss_+3A_x">x</code></td>
<td>
<p>An oject of class <code>"summary.bamlss"</code>.</p>
</td></tr>
<tr><td><code id="summary.bamlss_+3A_model">model</code></td>
<td>
<p>Character or integer, specifies the model for which a summary should be computed.</p>
</td></tr>
<tr><td><code id="summary.bamlss_+3A_fun">FUN</code></td>
<td>
<p>Function that should be applied on samples, see also function <code><a href="#topic+coef.bamlss">coef.bamlss</a></code>.</p>
</td></tr>
<tr><td><code id="summary.bamlss_+3A_parameters">parameters</code></td>
<td>
<p>If an optimizer function is applied within the <code><a href="#topic+bamlss">bamlss</a></code> call, should
the values of the estimated parameters be part of the summary?</p>
</td></tr>
<tr><td><code id="summary.bamlss_+3A_digits">digits</code></td>
<td>
<p>Controls number of digits printed in output.</p>
</td></tr>
<tr><td><code id="summary.bamlss_+3A_...">...</code></td>
<td>
<p>Other arguments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the fitted model contains samples, summaries according to the supplied function can be
computed, e.g., different quantiles of samples. See also function <code><a href="#topic+coef.bamlss">coef.bamlss</a></code>
that extracts the coefficient summaries.
</p>
<p>If an optimizer function was used within the <code><a href="#topic+bamlss">bamlss</a></code> call, estimated parameters
will be included per default into the summary.
</p>
<p>Note that summaries not based on samples can be user defined, e.g., as returned from function
<code><a href="#topic+samplestats">samplestats</a></code> or the return values of optimizer function, e.g., see function
<code><a href="#topic+opt_bfit">opt_bfit</a></code>.
</p>


<h3>Value</h3>

<p><code>summary.bamlss</code> produces the following summary:
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>The initial <code><a href="#topic+bamlss">bamlss</a></code> call.</p>
</td></tr>
<tr><td><code>family</code></td>
<td>
<p>The family that is used for modeling.</p>
</td></tr>
<tr><td><code>formula</code></td>
<td>
<p>The model formula.</p>
</td></tr>
<tr><td><code>model.matrix</code></td>
<td>
<p>Summary of parameteric terms.</p>
</td></tr>
<tr><td><code>smooth.construct</code></td>
<td>
<p>Summary of smooth terms.</p>
</td></tr>
<tr><td><code>model.stats</code></td>
<td>
<p>Other model statistics, e.g., as returned from
optimizer functions and/or produces by function <code><a href="#topic+samplestats">samplestats</a></code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+bamlss">bamlss</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ## Generate some data.
d &lt;- GAMart()

## Model formula.
f &lt;- list(
  num ~ s(x1) + s(x2),
  sigma ~ s(x3) + te(lon,lat)
)

## Estimate model.
b &lt;- bamlss(f, data = d)

## Print the summary.
print(summary(b))

## End(Not run)
</code></pre>

<hr>
<h2 id='surv_transform'>
Survival Model Transformer Function
</h2><span id='topic+surv_transform'></span>

<h3>Description</h3>

<p>This function takes a <code><a href="#topic+bamlss.frame">bamlss.frame</a></code> and computes design matrices of model terms
based on a time grid for time-dependent structured additive predictors in a survival context.
Note that this transformer function is usually used internally by function <code><a href="#topic+bamlss">bamlss</a></code>
and is the default transformer function using the <code><a href="#topic+cox_bamlss">cox_bamlss</a></code> family object.
</p>
<p>The time grid design matrices can be used to construct the full structured additive predictor
for each time point. This way it is possible to solve the integrals that are part of, e.g.,
a Newton-Raphson updating scheme, numerically.
</p>
<p>See the example section on how to extract the time grid design matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>surv_transform(x, y, data, family,
  subdivisions = 100, timedependent = "lambda",
  timevar = NULL, idvar = NULL, is.cox = FALSE,
  alpha = 0.1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="surv_transform_+3A_x">x</code></td>
<td>
<p>The <code>x</code> list, as returned from function
<code><a href="#topic+bamlss.frame">bamlss.frame</a></code> and transformed by function <code><a href="#topic+surv_transform">surv_transform</a></code>,
holding all model matrices and other information that is used for
fitting the model.</p>
</td></tr>
<tr><td><code id="surv_transform_+3A_y">y</code></td>
<td>
<p>The model response, as returned from function <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>.</p>
</td></tr>
<tr><td><code id="surv_transform_+3A_data">data</code></td>
<td>
<p>The data.frame that should be used for setting up all matrices.</p>
</td></tr>
<tr><td><code id="surv_transform_+3A_family">family</code></td>
<td>
<p>A <span class="pkg">bamlss</span> family object, see <code><a href="#topic+family.bamlss">family.bamlss</a></code>.
In this case this is the <code><a href="#topic+cox_bamlss">cox_bamlss</a></code> family object.</p>
</td></tr>
<tr><td><code id="surv_transform_+3A_subdivisions">subdivisions</code></td>
<td>
<p>How many time points should be created for each individual.</p>
</td></tr>
<tr><td><code id="surv_transform_+3A_timedependent">timedependent</code></td>
<td>
<p>A character vector specifying the names of parameters in <code>x</code>
that are time-dependent. Time grid design matrices are only computed for these parameters.</p>
</td></tr>
<tr><td><code id="surv_transform_+3A_timevar">timevar</code></td>
<td>
<p>A character specifying the name of the survival time variable in the
data set.</p>
</td></tr>
<tr><td><code id="surv_transform_+3A_idvar">idvar</code></td>
<td>
<p>Depending on the type of data set, this is the name of the variable specifying
identifier of individuals.</p>
</td></tr>
<tr><td><code id="surv_transform_+3A_is.cox">is.cox</code></td>
<td>
<p>Should the <code><a href="#topic+bamlss.frame">bamlss.frame</a></code> be set up for a Cox type survival model.</p>
</td></tr>
<tr><td><code id="surv_transform_+3A_alpha">alpha</code></td>
<td>
<p>A value for the intercept of a parameter names alpha. Typically the association
parameter of a longitudinal and survival process in a joint model.</p>
</td></tr>
<tr><td><code id="surv_transform_+3A_...">...</code></td>
<td>
<p>Arguments passed to function <code><a href="#topic+bamlss.engine.setup">bamlss.engine.setup</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="#topic+bamlss.frame">bamlss.frame</a></code> including the time grid design matrices.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cox_bamlss">cox_bamlss</a></code>, <code><a href="#topic+opt_Cox">opt_Cox</a></code>, <code><a href="#topic+sam_Cox">sam_Cox</a></code>,
<code><a href="#topic+simSurv">simSurv</a></code>, <code><a href="#topic+bamlss">bamlss</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library("survival")
set.seed(111)

## Simulate survival data.
d &lt;- simSurv(n = 20)

## Formula of the survival model, note
## that the baseline is given in the first formula by s(time).
f &lt;- list(
  Surv(time, event) ~ s(time) + s(time, by = x3),
  gamma ~ s(x1) + s(x2)
)

## Create the bamlss.frame.
bf &lt;- bamlss.frame(f, family = "cox", data = d)

## Lambda is the time-dependent parameter.
print(bf)

## Apply the transformer.
bf &lt;- with(bf, surv_transform(x, y, data = model.frame,
  family = family, is.cox = TRUE, subdivisions = 25))

## Extract the time grid design matrix for term s(time).
X &lt;- bf$x$lambda$smooth.construct[["s(time)"]]$fit.fun_timegrid(NULL)
dim(X)

## Compute fitted values for each time point.
grid &lt;- attr(bf$y[[1]], "grid")
gdim &lt;- c(length(grid), length(grid[[1]]))
b &lt;- runif(ncol(X))
fit &lt;- X %*% b
fit &lt;- matrix(fit, nrow = gdim[1], ncol = gdim[2], byrow = TRUE)

plot(as.vector(fit) ~ unlist(grid), type = "n",
  xlab = "Survival time", ylab = "Effect")
for(j in seq_along(grid)) {
  lines(fit[j, ] ~ grid[[j]], lwd = 2, col = rgb(0.1, 0.1, 0.1, alpha = 0.3))
  points(grid[[j]][gdim[2]], fit[j, gdim[2]], col = "red")
}
</code></pre>

<hr>
<h2 id='Surv2'>
Create a Survival Object for Joint Models
</h2><span id='topic+Surv2'></span>

<h3>Description</h3>

<p>This function is only a slight extension of <code><a href="survival.html#topic+Surv">Surv</a></code> for
joint models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Surv2(..., obs = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Surv2_+3A_...">...</code></td>
<td>
<p>Arguments passed to function <code><a href="survival.html#topic+Surv">Surv</a></code>.</p>
</td></tr>
<tr><td><code id="Surv2_+3A_obs">obs</code></td>
<td>
<p>The observed longitudinal response.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"Surv2"</code> and <code>"matrix"</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+opt_JM">opt_JM</a></code>, <code><a href="#topic+sam_JM">sam_JM</a></code>, <code><a href="#topic+bamlss">bamlss</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Surv2(time, event, obs = y)
## See the examples of opt_JM() and sam_JM()!
</code></pre>

<hr>
<h2 id='TempIbk'>Temperature data.</h2><span id='topic+TempIbk'></span>

<h3>Description</h3>

<p>Temperature Data for Innsbruck Airport
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("TempIbk")
</code></pre>


<h3>Format</h3>

<p>An object of class <code>data.frame</code> with 1798 rows and 17 columns.
</p>


<h3>Details</h3>

<p>Numerical weather predictions (NWP) and observations of
2 meter temperature at Innsbruck Airport.
The observations from the SYNOP station 11120 cover 5 years from
2015-01-01 to 2019-31-12.
The NWP data are derived from GEFS reforecasts (Hamill et al. 2013).
The data contain following variables:
</p>

<ul>
<li> <p><code>init</code>: Time of initialization of the NWP model.
</p>
</li>
<li> <p><code>obs_*</code>: Observations for lead time <code>*</code>.
</p>
</li>
<li> <p><code>mean_ens_*</code>: NWP ensemble mean for lead time <code>*</code>.
</p>
</li>
<li> <p><code>logsd_ens_*</code>: NWP logarithm of ensemble standard deviation for lead time <code>*</code>.
</p>
</li>
<li> <p><code>yday</code>: Yearday.
</p>
</li></ul>



<h3>References</h3>

<p>Hamill TM, Bates GT, Whitaker JS, Murray DR, Fiorino M, Galarneau Jr TJ,
Zhu Y, Lapenta W (2013). NOAA's Second-Generation Global Medium-Range
Ensemble Reforecast Data Set. <em>Bulletin of the American Meteorological
Society</em>, 94(10), 1553-1565.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvnchol_bamlss">mvnchol_bamlss</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ## Innsbruck temperature data.
data("TempIbk", package = "bamlss")

## Five lead times.
lead &lt;- seq(192, 216, by = 6)

## Set up formulas.
f &lt;- c(
  ## mu equations
  sprintf('obs_%s ~ s(yday, bs = "cc") + s(yday, bs = "cc", by = mean_ens_%s)', lead, lead),

  ## lambda diag equations
  sprintf('lamdiag%s ~ s(yday, bs = "cc") + s(yday, bs = "cc", by = logsd_ens_%s)', 1:5, lead),

  ## lambda off-diag equations
  sprintf('lambda%s ~ s(yday, bs = "cc")', apply(combn(1:5, 2), 2, paste, collapse = ""))
)
f &lt;- lapply(f, as.formula)

## Multivariate normal family with basic Cholesky parameterization.
fam &lt;- mvnchol_bamlss(k = 5, type = "basic")

## Fit model.
set.seed(123)
b &lt;- bamlss(f, family = fam, data = TempIbk, optimizer = opt_boost, maxit = 1000)

## Show estimated effects.
par(mfrow = c(2, 2))
plot(b, model = "mu1", scale = 0, spar = FALSE)
plot(b, model = "lamdiag2", term = "s(yday)", spar = FALSE)
plot(b, model = "lambda12")

## Predict sample case.
nd &lt;- subset(TempIbk, format(init, "%Y-%m-%d") %in% c("2015-01-03", "2015-10-10"))
fit &lt;- predict(b, newdata = nd, type = "parameter")

## Plot correlation matrix for GEFS initialization 2015-10-10.
plot_cor &lt;- function(i) {
    image(lead, lead, fam$correlation(fit)[[i]][5:1, ], zlim = c(0, 1),
    	 col = hcl.colors(10, "Blues 3", rev = TRUE), axes = FALSE,
    	 xlab = "lead time in hours", ylab = "lead time in hours",
    	 main = sprintf("Correlation matrix fitted for %s", nd[i, "init"]))
    axis(1, lead)
    axis(2, lead, rev(lead))
    box()
}
par(mfrow = c(1, 2))
plot_cor(1)
plot_cor(2)

## Plot means and standard deviations.
plot_ms &lt;- function(i) {
	stdev &lt;- fam$stdev(fit)[[i]]
	means &lt;- fam$means(fit)[[i]]
	lower &lt;- means - stdev
	upper &lt;- means + stdev
	
	plot(lead, means, type = 'b', cex = 2, lwd = 1, lty = 2, axes = FALSE,
		 ylim = c(-6, 16), # c(min(lower), max(upper)),
		 ylab = expression("Temperature in " * degree * "C"),
		 xlab = "lead time in hours",
		 main = sprintf("Means +/- one st. dev. for %s", nd[i, "init"]))
	segments(lead, y0 = lower, y1 = upper)
	axis(1, lead)
	axis(2)
	box()
}
par(mfrow = c(1, 2))
plot_ms(1)
plot_ms(2)

## End(Not run)

</code></pre>

<hr>
<h2 id='terms.bamlss'>
BAMLSS Model Terms
</h2><span id='topic+terms.bamlss'></span><span id='topic+terms.bamlss.frame'></span><span id='topic+terms.bamlss.formula'></span>

<h3>Description</h3>

<p>Extract <code><a href="stats.html#topic+terms.object">terms.object</a></code>s for BAMLSS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'bamlss'
terms(x, specials = NULL, data = NULL,
  model = NULL, pterms = TRUE, sterms = TRUE,
  drop = TRUE, ...)

## S3 method for class 'bamlss.frame'
terms(x, specials = NULL, data = NULL,
  model = NULL, pterms = TRUE, sterms = TRUE,
  drop = TRUE, ...)

## S3 method for class 'bamlss.formula'
terms(x, specials = NULL, data = NULL,
  model = NULL, pterms = TRUE, sterms = TRUE,
  drop = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="terms.bamlss_+3A_x">x</code></td>
<td>
<p>An <code>link{bamlss}</code>, <code><a href="#topic+bamlss.frame">bamlss.frame</a></code> or
<code><a href="#topic+bamlss.formula">bamlss.formula</a></code> object.</p>
</td></tr>
<tr><td><code id="terms.bamlss_+3A_specials">specials</code></td>
<td>
<p>See <code><a href="stats.html#topic+terms.object">terms.object</a></code>.</p>
</td></tr>
<tr><td><code id="terms.bamlss_+3A_data">data</code></td>
<td>
<p>Data passed to <code><a href="stats.html#topic+terms.formula">terms.formula</a></code>.</p>
</td></tr>
<tr><td><code id="terms.bamlss_+3A_model">model</code></td>
<td>
<p>Character or integer, specifies the model for which terms should be returned.</p>
</td></tr>
<tr><td><code id="terms.bamlss_+3A_pterms">pterms</code></td>
<td>
<p>Should parametric terms be part of the object?</p>
</td></tr>
<tr><td><code id="terms.bamlss_+3A_sterms">sterms</code></td>
<td>
<p>Should smooth terms be part of the object?</p>
</td></tr>
<tr><td><code id="terms.bamlss_+3A_drop">drop</code></td>
<td>
<p>If terms for only one <code>model</code> are returned, the list structure is dropped.</p>
</td></tr>
<tr><td><code id="terms.bamlss_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="#topic+bamlss.formula">bamlss.formula</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Object of class <code>"bamlss.terms"</code>, a list of <code><a href="stats.html#topic+terms.object">terms.object</a></code>s, depending on
the structure of the <code><a href="#topic+bamlss.formula">bamlss.formula</a></code> object.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bamlss">bamlss</a></code>, <code><a href="#topic+bamlss.frame">bamlss.frame</a></code>, <code><a href="#topic+bamlss.formula">bamlss.formula</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Model formula.
f &lt;- list(
  num ~ x1 + x2 + id,
  sigma ~ x3 + fac + lon + lat
)

## Create the terms object.
terms(bamlss.formula(f))
</code></pre>

<hr>
<h2 id='trans_AR1'>
AR1 Transformer Function
</h2><span id='topic+trans_AR1'></span><span id='topic+AR1'></span>

<h3>Description</h3>

<p>The transformer function takes a <code><a href="#topic+bamlss.frame">bamlss.frame</a></code> object and transforms
the response and the design matrices to account for lag 1 autocorrelation. The method
is also known as Prais-Winsten estimation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trans_AR1(rho = 0.1)
AR1(rho = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trans_AR1_+3A_rho">rho</code></td>
<td>
<p>Specifies the correlation parameter at lag 1.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A transformer function which can be used in the <code><a href="#topic+bamlss">bamlss</a></code> call.
</p>


<h3>References</h3>

<p>Johnston, John (1972). Econometric Methods (2nd ed.). New York: McGraw-Hill. pp. 259&ndash;265.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bamlss.frame">bamlss.frame</a></code>, <code><a href="#topic+bamlss">bamlss</a></code>, <code><a href="mgcv.html#topic+smooth2random">smooth2random</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: ## Simulate AR1 data.
set.seed(111)

n &lt;- 240
d &lt;- data.frame("t" = 1:n)

## Nonlinear function.
f &lt;- function(x) {
  2 + sin(x / n * 2 * pi - pi)
}

## Correlated errors.
rho &lt;- 0.8
e &lt;- rnorm(n, sd = 0.1)
u &lt;- c(e[1], rep(NA, n - 1))
for(i in 2:n){
  u[i] &lt;- rho * u[i - 1] + e[i]
}

## Response.
d$y &lt;- f(d$t) + u

## Plot time-series data.
plot(d, type = "l")

## Estimate models without and with AR1 transformation.
b0 &lt;- bamlss(y ~ s(t,k=20), data = d, criterion = "BIC")
b1 &lt;- bamlss(y ~ s(t,k=20), data = d, criterion = "BIC",
  transform = AR1(rho = 0.8))

## Estimate full AR1 model.
b2 &lt;- bamlss(y ~ s(t,k=20), data = d, criterion = "BIC",
  family = "AR1")
rho &lt;- predict(b2, model = "rho", type = "parameter")
print(range(rho))

## Estimated standard deviations.
sd0 &lt;- predict(b0, model = "sigma", type = "parameter")
sd1 &lt;- predict(b1, model = "sigma", type = "parameter")
sd2 &lt;- predict(b2, model = "sigma", type = "parameter")
print(round(c(sd0[1], sd1[1], sd2[1]), 2))

## Plot fitted trends.
p0 &lt;- predict(b0, model = "mu")
p1 &lt;- predict(b1, model = "mu")
p2 &lt;- predict(b2, model = "mu")

plot(d, type = "l")
lines(f(d$t) ~ d$t, col = 2, lwd = 2)
lines(p0 ~ d$t, col = 4, lwd = 2)
lines(p1 ~ d$t, col = 3, lwd = 3)
lines(p2 ~ d$t, col = 5, lwd = 3)
legend("topleft",
  c("no trans", "with trans", "AR1 model", "truth"),
  lwd = 2, col = c(4, 3, 5, 2), bty = "n")

## End(Not run)</code></pre>

<hr>
<h2 id='Volcano'>
Artificial Data Set based on Auckland's Maunga Whau Volcano
</h2><span id='topic+Volcano'></span>

<h3>Description</h3>

<p>This function creates a data set based on the <code><a href="datasets.html#topic+volcano">volcano</a></code>
data by adding normal errors to the topographic information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Volcano(sd = 0.3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Volcano_+3A_sd">sd</code></td>
<td>
<p>The standard deviation of the normal errors.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with coordinates and noisy elevation.
</p>


<h3>See Also</h3>

<p><code><a href="datasets.html#topic+volcano">volcano</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>d &lt;- Volcano()
head(d)

## Not run: b &lt;- bamlss(y ~ te(lon,lat,k=10), data = d)
plot(b, theta = -130)

## End(Not run)
</code></pre>

<hr>
<h2 id='WAIC'>
Watanabe-Akaike Information Criterion (WAIC)
</h2><span id='topic+WAIC'></span>

<h3>Description</h3>

<p>Function returning the Watanabe-Akaike Information Criterion (WAIC) of a fitted model object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>WAIC(object, ..., newdata = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="WAIC_+3A_object">object</code></td>
<td>
<p>A fitted model object which contains MCMC samples.</p>
</td></tr>
<tr><td><code id="WAIC_+3A_...">...</code></td>
<td>
<p>Optionally more fitted model objects.</p>
</td></tr>
<tr><td><code id="WAIC_+3A_newdata">newdata</code></td>
<td>
<p>Optionally, use new data for computing the WAIC.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the WAIC and estimated number of parameters.
</p>


<h3>References</h3>

<p>Watanabe S. (2010). Asymptotic Equivalence of Bayes Cross Validation and Widely
Applicable Information Criterion in Singular Learning Theory. <em>The Journal of Machine
Learning Research</em>, <b>11</b>, 3571&ndash;3594.
<a href="https://jmlr.org/papers/v11/watanabe10a.html">https://jmlr.org/papers/v11/watanabe10a.html</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: d &lt;- GAMart()
b1 &lt;- bamlss(num ~ s(x1), data = d)
b2 &lt;- bamlss(num ~ s(x1) + s(x2), data = d)
WAIC(b1, b2)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
