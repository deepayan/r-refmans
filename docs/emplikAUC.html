<!DOCTYPE html><html><head><title>Help for package emplikAUC</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {emplikAUC}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#EL2paucT1T2'>
<p>Testing one pAUC(p1, p2) and two quantile values together by Empirical Likelihood.</p></a></li>
<li><a href='#el2test4auc'>
<p>Testing one AUC value by Empirical likelihood.</p></a></li>
<li><a href='#el2testPauc'>
<p>Testing one pAUC(0, p) value by Empirical likelihood.</p></a></li>
<li><a href='#el2testPaucT'>
<p>Testing one pAUC(0, p) value and one quantile: F(tau) = 1-p together by Empirical Likelihood.</p></a></li>
<li><a href='#eltest4aucONE'>
<p>Testing one AUC value by Empirical likelihood.</p></a></li>
<li><a href='#eltest4paucONE'>
<p>Testing one pAUC value by Empirical likelihood.</p></a></li>
<li><a href='#eltest4paucT'>
<p>Testing one pAUC and one quantile together by Empirical Likelihood.</p></a></li>
<li><a href='#emplikAUC.internal'><p>Internal emplikAUC functions</p></a></li>
<li><a href='#findLnew'>
<p>Finding the Lower bound of a confidence interval for theta by repeatedly testing the</p>
hypothesis for the parameter theta.</a></li>
<li><a href='#findULNEW'>
<p>Finding the Upper and Lower bound of a confidence interval for theta by repeatedly testing the</p>
hypothesis for the parameter theta.</a></li>
<li><a href='#findUnew'>
<p>Finding the Upper bound of a confidence interval for <code>theta</code> by repeatedly testing the</p>
hypothesis for the parameter <code>theta</code>.</a></li>
<li><a href='#myEstPaucT'>
<p>Given the x, y 2-sample data,</p>
first estimate the (1-partial)-th quantile of X sample, then
estimate the pAUC(0, partial), with the plug-in estimated quantile.</a></li>
<li><a href='#quantONE'>
<p>Smoothed quantile estimation from the given x-sample.</p></a></li>
<li><a href='#smooth3'>
<p>Smoothed indicator function I[x &lt; y], which is the integration of the Epanechnikov kernal.</p></a></li>
<li><a href='#smooth3vec'>
<p>Smoothed indicator function I[x &lt; const], which is the integration of the Epanechnikov kernal.</p></a></li>
<li><a href='#smooth5vec'>
<p>Smoothed indicator function I[x &lt; const], which is the integration of the Quartic kernal.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Version:</td>
<td>0.3</td>
</tr>
<tr>
<td>Title:</td>
<td>Empirical Likelihood Ratio Test/Confidence Interval for AUC or
pAUC</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mai Zhou &lt;maizhou@gmail.com&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.2.5), emplik2, rootSolve</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats</td>
</tr>
<tr>
<td>Description:</td>
<td>Test hypotheses and construct confidence intervals for AUC (area under Receiver 
             Operating Characteristic curve) and pAUC (partial area under ROC curve), from the
			 given two samples of test data with disease/healthy subjects. The method used is
			 based on two sample empirical likelihood, as described in
			 <a href="https://www.ms.uky.edu/~mai/research/eAUC1.pdf">https://www.ms.uky.edu/~mai/research/eAUC1.pdf</a>.		 </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Author:</td>
<td>Mai Zhou [aut, cre, cph],
  Xue Ding [aut]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-01-13 04:37:26 UTC; maizh</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-01-13 19:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='EL2paucT1T2'>
Testing one pAUC(p1, p2) and two quantile values together by Empirical Likelihood. 
</h2><span id='topic+EL2paucT1T2'></span>

<h3>Description</h3>

<p>This function computes the two sample Log Empirical Likelihood ratio
for testing <code class="reqn">H_0</code>: pAUC(p1, p2) = theta; F(tau1)=1-p2; F(tau2)= 1-p1. 
The two samples are in the x-vector and y-vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>EL2paucT1T2(tauVec, pauc, partial1, partial2, x, y, epsxy)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="EL2paucT1T2_+3A_tauvec">tauVec</code></td>
<td>
<p>The vector (tau1, tau2), the two quantile values, to be tested.</p>
</td></tr>
<tr><td><code id="EL2paucT1T2_+3A_pauc">pauc</code></td>
<td>
<p>The value of the pAUC(p1, p2) under <code class="reqn">H_0</code>, to be tested.</p>
</td></tr>
<tr><td><code id="EL2paucT1T2_+3A_partial1">partial1</code></td>
<td>
<p>The probability that define the quantile 1</p>
</td></tr>
<tr><td><code id="EL2paucT1T2_+3A_partial2">partial2</code></td>
<td>
<p>The probability that define the quantile 2. Must satisfy partial 1 &lt; partial 2 .</p>
</td></tr>
<tr><td><code id="EL2paucT1T2_+3A_x">x</code></td>
<td>
<p>a vector of observations, length m, for the first sample.</p>
</td></tr>
<tr><td><code id="EL2paucT1T2_+3A_y">y</code></td>
<td>
<p>a vector of observations, length n, for the second sample.</p>
</td></tr>
<tr><td><code id="EL2paucT1T2_+3A_epsxy">epsxy</code></td>
<td>
<p>The parameter for smoothing when compare x-y.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The input <code>tauVec=(tau1, tau2)</code>, and must have: tau1 &lt; tau2. The relavant definitions are: 
tau1 = <code class="reqn">F^{-1}</code>(1-partial2); tau2 = <code class="reqn">F^{-1}</code>(1-partial1).
Thus, we must have  partial2 &gt; partial1.
</p>
<p>This function is testing 3 parameters simultanuously.
It depend on the package <code>emplik2</code>.
</p>
<p>The empirical likelihood we used here is defined as
</p>
<p style="text-align: center;"><code class="reqn"> EL = \prod_{i=1}^m v_i \prod_{j=1}^n \nu_j ~;~~~s.t. ~~~~~ \sum v_i =1 ~,~~ \sum \nu_j =1 ~. </code>
</p>



<h3>Value</h3>

<p>A single value that is the &quot;-2LLR&quot; from <code>emplik2::el2.cen.EMm()</code>.
Typically should be distributed as chi square df=3, under <code class="reqn">H_0</code>.
</p>


<h3>Author(s)</h3>

<p>Mai Zhou &lt;maizhou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Zhao, Y., Ding, X. and Zhou (2021). Confidence Intervals of AUC and pAUC by Empirical Likelihood.
Tech Report. https://www.ms.uky.edu/~mai/research/eAUC1.pdf
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
y &lt;- c(10, 209, 273, 279, 324, 391, 566, 785)
x &lt;- c(21, 38, 39, 51, 77, 185, 240, 289, 524)
</code></pre>

<hr>
<h2 id='el2test4auc'>
Testing one AUC value by Empirical likelihood. 
</h2><span id='topic+el2test4auc'></span>

<h3>Description</h3>

<p>By calling upon a function from the package <code>emplik2</code> (using EM), 
this function computes the two sample Log Empirical Likelihood ratio
for testing <code class="reqn">H_0</code>: AUC = theta. The two samples are in the x-vector and y-vector inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>el2test4auc(theta, x, y, ind)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="el2test4auc_+3A_theta">theta</code></td>
<td>
<p>The &quot;true&quot; value of the AUC under <code class="reqn">H_0</code>, to be tested.</p>
</td></tr>
<tr><td><code id="el2test4auc_+3A_x">x</code></td>
<td>
<p>a vector of observations, length m, for the first sample. The test-results of healthy subjects.</p>
</td></tr>
<tr><td><code id="el2test4auc_+3A_y">y</code></td>
<td>
<p>a vector of observations, length n, for the second sample. The test-results of desease subjects.</p>
</td></tr>
<tr><td><code id="el2test4auc_+3A_ind">ind</code></td>
<td>
<p>A smoothed indicator function, to generate a Matrix of (smoothed) indicator values: I[x[i] &lt; y[j]].</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is similar to the function <code>eltest4aucONE()</code>, the difference 
is that we call the function <code>emplik2::el2.cen.EMs()</code> to 
do the heavy computation (instead of by our own code).  
So, the speed and convergence property may be slightly different. When they both converge
the results should be the same.
</p>
<p>The empirical likelihood we used here is defined as
</p>
<p style="text-align: center;"><code class="reqn"> EL = \prod_{i=1}^m v_i \prod_{j=1}^n \nu_j ~;~~~~~ \sum v_i =1 ~,~~ \sum \nu_j =1 ~. </code>
</p>



<h3>Value</h3>

<p>A list that is the same as el2.cen.EMs() from emplik2 package.
Which contains
</p>
<table>
<tr><td><code>lambda</code></td>
<td>
<p>The final tilting parameter.</p>
</td></tr>
<tr><td><code>"-2LLR"</code></td>
<td>
<p>The -2 log empirical likelihood ratio.</p>
</td></tr>
<tr><td><code>Pval</code></td>
<td>
<p>The p-value.</p>
</td></tr>
<tr><td><code>iterNum</code></td>
<td>
<p>The iteration number used in computing.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mai Zhou &lt;maizhou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Zhao, Y., Ding, X. and Zhou (2021). Confidence Intervals of AUC and pAUC by Empirical Likelihood.
Tech Report. https://www.ms.uky.edu/~mai/research/eAUC1.pdf
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
y &lt;- c(10, 209, 273, 279, 324, 391, 566, 785)
x &lt;- c(21, 38, 39, 51, 77, 185, 240, 289, 524)
#### The estimation of AUC
sum(smooth3(x=x, y=y))/(length(x)*length(y))
#### This does not work in Rcmd check: (truncate at %*%) 
####   rep(1/length(x), length(x))%*%smooth3(x=x, y=y)%*%rep(1/length(y), length(y))
#### The result should be 0.75.
#### We may then test a hypothesis about the AUC value: H0: AUC= 0.7
el2test4auc(theta=0.7, x=x, y=y, ind=smooth3)
#### Two of the outputs should be '-2LLR'=0.1379561 and Pval=0.7103214
</code></pre>

<hr>
<h2 id='el2testPauc'>
Testing one pAUC(0, p) value by Empirical likelihood. 
</h2><span id='topic+el2testPauc'></span>

<h3>Description</h3>

<p>This function computes the two sample Log Empirical Likelihood ratio
for testing <code class="reqn">H_0</code>: pAUC(0, p) = theta. 
The two samples are in the x-vector and y-vector inputs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>el2testPauc(theta, x, y, ind, nuilow, nuiup, partial, epsxy, epsT)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="el2testPauc_+3A_theta">theta</code></td>
<td>
<p>The &quot;true&quot; value of the pAUC(0, p) under <code class="reqn">H_0</code>, to be tested.</p>
</td></tr>
<tr><td><code id="el2testPauc_+3A_x">x</code></td>
<td>
<p>a vector of observations, length m, for the first sample, test-results with the healthy subjects.</p>
</td></tr>
<tr><td><code id="el2testPauc_+3A_y">y</code></td>
<td>
<p>a vector of observations, length n, for the second sample, test-results with the desease subjects.</p>
</td></tr>
<tr><td><code id="el2testPauc_+3A_ind">ind</code></td>
<td>
<p>The (smoothed) indicator function for compare x-y.</p>
</td></tr>
<tr><td><code id="el2testPauc_+3A_nuilow">nuilow</code></td>
<td>
<p>Lower bound for the nuisamce parameter (1-p)-th quantile of X) search.</p>
</td></tr>
<tr><td><code id="el2testPauc_+3A_nuiup">nuiup</code></td>
<td>
<p>Upper bound for nuisance parameter search.</p>
</td></tr>
<tr><td><code id="el2testPauc_+3A_partial">partial</code></td>
<td>
<p>The probability p in pAUC(0, p).</p>
</td></tr>
<tr><td><code id="el2testPauc_+3A_epsxy">epsxy</code></td>
<td>
<p>The smoothing parameter when compare x-y.</p>
</td></tr>
<tr><td><code id="el2testPauc_+3A_epst">epsT</code></td>
<td>
<p>The smoothing parameter when calculating quantile.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function will call another function: <code>el2testPaucT( )</code>.
We then use <code>optimize( )</code> to profile out the nuisance 
parameter tau: the (1-p)-th quantile of X distribution.
</p>
<p>Can be used by  <code>findUnew( )</code> etc.
</p>
<p>The empirical likelihood we used here is defined as
</p>
<p style="text-align: center;"><code class="reqn"> EL = \prod_{i=1}^m v_i \prod_{j=1}^n \nu_j ~; ~~~~s.t. ~~~ \sum v_i =1 ~,~~ \sum \nu_j =1 ~. </code>
</p>



<h3>Value</h3>

<p>A list containing
</p>
<table>
<tr><td><code>"-2LLR"</code></td>
<td>
<p>The -2 log empirical likelihood ratio.</p>
</td></tr>
<tr><td><code>Nupar</code></td>
<td>
<p>The nuisance parameter value that achieved the minimum.</p>
</td></tr>
<tr><td><code>Pval</code></td>
<td>
<p>The p-value, by using chi square distribution with 1 df.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mai Zhou &lt;maizhou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Zhao, Y., Ding, X. and Zhou (2021). Confidence Intervals of AUC and pAUC by Empirical Likelihood.
Tech Report. https://www.ms.uky.edu/~mai/research/eAUC1.pdf
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
y &lt;- c(10, 209, 273, 279, 324, 391, 566, 785)
x &lt;- c(21, 38, 39, 51, 77, 185, 240, 289, 524)
</code></pre>

<hr>
<h2 id='el2testPaucT'>
Testing one pAUC(0, p) value and one quantile: F(tau) = 1-p together by Empirical Likelihood. 
</h2><span id='topic+el2testPaucT'></span>

<h3>Description</h3>

<p>This function computes the two sample Log Empirical Likelihood ratio
for testing <code class="reqn">H_0</code>: pAUC(0, p) = theta and F(tau) = 1-p. (F is the CDF of X).
The two samples data are in the x-vector and y-vector inputs. It uses EM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>el2testPaucT(tau, pauc, ind, partial, x, y, epsxy, epsT)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="el2testPaucT_+3A_tau">tau</code></td>
<td>
<p>The &quot;true&quot; value of the (1-p)-th quantile of X-distribution F, to be tested.</p>
</td></tr>
<tr><td><code id="el2testPaucT_+3A_pauc">pauc</code></td>
<td>
<p>The <code class="reqn">H_0</code> value of pAUC(0, p) to be tested.</p>
</td></tr>
<tr><td><code id="el2testPaucT_+3A_ind">ind</code></td>
<td>
<p>A smoothed indicator function, to generate a Matrix of (smoothed) indicator values: I[x[i] &lt; y[j]].</p>
</td></tr>
<tr><td><code id="el2testPaucT_+3A_partial">partial</code></td>
<td>
<p>The probability p in pAUC(0, p); also the p in F(tau) = 1-p.</p>
</td></tr>
<tr><td><code id="el2testPaucT_+3A_x">x</code></td>
<td>
<p>a vector of observations, length m, for the first sample, test-results with healthy subjects.</p>
</td></tr>
<tr><td><code id="el2testPaucT_+3A_y">y</code></td>
<td>
<p>a vector of observations, length n, for the second sample, test-results with desease subjects.</p>
</td></tr>
<tr><td><code id="el2testPaucT_+3A_epsxy">epsxy</code></td>
<td>
<p>The smoothing parameter when compare x-y.</p>
</td></tr>
<tr><td><code id="el2testPaucT_+3A_epst">epsT</code></td>
<td>
<p>The smoothing parameter when compare x to Tau, for quantile estimation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called by <code>el2testPauc( )</code>.  
It is listed here stand alone because users may find it useful elsewhere.
</p>
<p>It make use of function <code>smooth3( )</code> and the function <code>el2.cen.EMm( )</code> 
from the <code>emplik2</code> package.
</p>
<p>The empirical likelihood we used here is defined as
</p>
<p style="text-align: center;"><code class="reqn"> EL = \prod_{i=1}^m v_i \prod_{j=1}^n \nu_j ~;~~~~~~ \sum v_i =1 ~,~~ \sum \nu_j =1 ~. </code>
</p>



<h3>Value</h3>

<p>It returns one value that is the &quot;-2LLR&quot;. It should have chi square df=2 under <code class="reqn">H_0</code>.
</p>


<h3>Author(s)</h3>

<p>Mai Zhou &lt;maizhou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Zhao, Y., Ding, X. and Zhou (2021). Confidence Intervals of AUC and pAUC by Empirical Likelihood.
Tech Report. https://www.ms.uky.edu/~mai/research/eAUC1.pdf
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
y &lt;- c(10, 209, 273, 279, 324, 391, 566, 785)
x &lt;- c(21, 38, 39, 51, 77, 185, 240, 289, 524)
</code></pre>

<hr>
<h2 id='eltest4aucONE'>
Testing one AUC value by Empirical likelihood. 
</h2><span id='topic+eltest4aucONE'></span>

<h3>Description</h3>

<p>This function computes the two sample Log Empirical Likelihood ratio
for testing <code class="reqn">H_0</code>: AUC = theta. The two samples are in the x-vector and y-vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eltest4aucONE(theta, x, y, ind, tol.u, tol.v, tol.H0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eltest4aucONE_+3A_theta">theta</code></td>
<td>
<p>The &quot;true&quot; value of the AUC under <code class="reqn">H_0</code>, to be tested.</p>
</td></tr>
<tr><td><code id="eltest4aucONE_+3A_x">x</code></td>
<td>
<p>a vector of observations, length m, for the first sample. The test-results of healthy subjects</p>
</td></tr>
<tr><td><code id="eltest4aucONE_+3A_y">y</code></td>
<td>
<p>a vector of observations, length n, for the second sample. The test-results of desease subjects.</p>
</td></tr>
<tr><td><code id="eltest4aucONE_+3A_ind">ind</code></td>
<td>
<p>A smoothed indicator function, to generate a Matrix of (smoothed) indicator values: I[x[i] &lt; y[j]].</p>
</td></tr>
<tr><td><code id="eltest4aucONE_+3A_tol.u">tol.u</code></td>
<td>
<p>Error tol for final u probability vector. Must &gt; 0.</p>
</td></tr>
<tr><td><code id="eltest4aucONE_+3A_tol.v">tol.v</code></td>
<td>
<p>Error tol for final v probability vector. Must &gt; 0.</p>
</td></tr>
<tr><td><code id="eltest4aucONE_+3A_tol.h0">tol.H0</code></td>
<td>
<p>The error bound for the constrained NPMLE to satisfy <code class="reqn">H_0</code>, must &gt;0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is similar to <code>el2test4auc</code>, but using our own algorithm (not EM).  
It may be slightly different to the above in terms of speed and convergence property.
We listed 3 kind of tol to control convergence.
</p>
<p>The empirical likelihood we used here is defined as
</p>
<p style="text-align: center;"><code class="reqn"> EL = \prod_{i=1}^m v_i \prod_{j=1}^n \nu_j ~;~~~~~~ \sum v_i =1 ~,~~ \sum \nu_j =1 ~. </code>
</p>



<h3>Value</h3>

<p>A list containing
</p>
<table>
<tr><td><code>lambda</code></td>
<td>
<p>The final tilting parameter.</p>
</td></tr>
<tr><td><code>u</code></td>
<td>
<p>the new u vector.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>The new v vector.</p>
</td></tr>
<tr><td><code>"-2LLR"</code></td>
<td>
<p>The -2 log empirical likelihood ratio.</p>
</td></tr>
<tr><td><code>Pval</code></td>
<td>
<p>The p-value.</p>
</td></tr>
<tr><td><code>iterNum</code></td>
<td>
<p>The iteration number used in computing.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mai Zhou &lt;maizhou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Zhao, Y., Ding, X. and Zhou (2021). Confidence Intervals of AUC and pAUC by Empirical Likelihood.
Tech Report. https://www.ms.uky.edu/~mai/research/eAUC1.pdf
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
y &lt;- c(10, 209, 273, 279, 324, 391, 566, 785)
x &lt;- c(21, 38, 39, 51, 77, 185, 240, 289, 524)
#### We know the AUC estimator here is 0.75.
#### We may test a hypothesis about the AUC value: H0: AUC= 0.7
eltest4aucONE(theta=0.7, x=x, y=y, ind=smooth3, tol.u=1e-6, tol.v=1e-6, tol.H0=1e-6)
#### Two of the outputs should be '-2LLR'=0.1379561 and Pval=0.7103214
</code></pre>

<hr>
<h2 id='eltest4paucONE'>
Testing one pAUC value by Empirical likelihood. 
</h2><span id='topic+eltest4paucONE'></span>

<h3>Description</h3>

<p>This function computes the two sample Log Empirical Likelihood ratio
for testing <code class="reqn">H_0</code>: pAUC(0, p) = theta. The two samples are in the x-vector and y-vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eltest4paucONE(theta,x,y,nuilow,nuiup,ind,partial,epsxy=0.05,epsT=(length(x))^(-0.75))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eltest4paucONE_+3A_theta">theta</code></td>
<td>
<p>The &quot;true&quot; value of the pAUC under <code class="reqn">H_0</code>, to be tested.</p>
</td></tr>
<tr><td><code id="eltest4paucONE_+3A_x">x</code></td>
<td>
<p>a vector of observations, length m, for the first sample. Test-results with healthy subjects.</p>
</td></tr>
<tr><td><code id="eltest4paucONE_+3A_y">y</code></td>
<td>
<p>a vector of observations, length n, for the second sample. Test-results with desease subjects.</p>
</td></tr>
<tr><td><code id="eltest4paucONE_+3A_nuilow">nuilow</code></td>
<td>
<p>The lower bound for the nuisance parameter (the (1-p)-th quantile of X CDF F) search.</p>
</td></tr>
<tr><td><code id="eltest4paucONE_+3A_nuiup">nuiup</code></td>
<td>
<p>The upper bound for the nuisance parameter search.</p>
</td></tr>
<tr><td><code id="eltest4paucONE_+3A_ind">ind</code></td>
<td>
<p>A smoothed indicator function, to generate a Matrix of (smoothed) indicator values: I[x[i] &lt; y[j]].</p>
</td></tr>
<tr><td><code id="eltest4paucONE_+3A_partial">partial</code></td>
<td>
<p>The probability p in the pAUC(0,p).</p>
</td></tr>
<tr><td><code id="eltest4paucONE_+3A_epsxy">epsxy</code></td>
<td>
<p>Window width for the smoother, &quot;ind&quot;, when compare x-y.</p>
</td></tr>
<tr><td><code id="eltest4paucONE_+3A_epst">epsT</code></td>
<td>
<p>Window width for the smoother, &quot;ind&quot;, when define quantile.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calls the function <code>eltest4paucT</code>.
We then use <code>optimize( )</code> to profile out the nuisance parameter.
Return an empirical likelihood ratio siutable for testing one parameter pAUC(0,p).
</p>
<p>The empirical likelihood we used here is defined as
</p>
<p style="text-align: center;"><code class="reqn"> EL = \prod_{i=1}^m v_i \prod_{j=1}^n \nu_j ~;~~~~~~ \sum v_i =1 ~,~~ \sum \nu_j =1 ~. </code>
</p>



<h3>Value</h3>

<p>A list containing
</p>
<table>
<tr><td><code>"-2LLR"</code></td>
<td>
<p>The -2 log empirical likelihood ratio.</p>
</td></tr>
<tr><td><code>Nupar</code></td>
<td>
<p>The nuisance parameter value to achieve the minimum.</p>
</td></tr>
<tr><td><code>Pval</code></td>
<td>
<p>The p-value.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mai Zhou &lt;maizhou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Zhao, Y., Ding, X. and Zhou (2021). Confidence Intervals of AUC and pAUC by Empirical Likelihood.
Tech Report. https://www.ms.uky.edu/~mai/research/eAUC1.pdf
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
y &lt;- c(10, 209, 273, 279, 324, 391, 566, 785)
x &lt;- c(21, 38, 39, 51, 77, 185, 240, 289, 524)
</code></pre>

<hr>
<h2 id='eltest4paucT'>
Testing one pAUC and one quantile together by Empirical Likelihood. 
</h2><span id='topic+eltest4paucT'></span>

<h3>Description</h3>

<p>This function computes the two sample Log Empirical Likelihood ratio
for testing <code class="reqn">H_0</code>: pAUC(0,p) = theta and F(tau) = 1-p. 
The two samples are in the x-vector and y-vector.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eltest4paucT(tau, x, y, true, ind, epsxy, epsT, tol.u, tol.v, tol.H0, p)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eltest4paucT_+3A_tau">tau</code></td>
<td>
<p>The &quot;true&quot; value of the (1-p)th quantile of X, under <code class="reqn">H_0</code>, to be tested.</p>
</td></tr>
<tr><td><code id="eltest4paucT_+3A_x">x</code></td>
<td>
<p>a vector of observations, length m, for the first sample. Test-results with healthy subjects.</p>
</td></tr>
<tr><td><code id="eltest4paucT_+3A_y">y</code></td>
<td>
<p>a vector of observations, length n, for the second sample. Test-results with desease subjects.</p>
</td></tr>
<tr><td><code id="eltest4paucT_+3A_true">true</code></td>
<td>
<p>The <code class="reqn">H_0</code> value of the pAUC(0, p) to be tested.</p>
</td></tr>
<tr><td><code id="eltest4paucT_+3A_ind">ind</code></td>
<td>
<p>A smoothed indicator function, to generate a Matrix of (smoothed) indicator values: I[x[i] &lt; y[j]].</p>
</td></tr>
<tr><td><code id="eltest4paucT_+3A_epsxy">epsxy</code></td>
<td>
<p>Window width for smoother (ind) when compare x-y.</p>
</td></tr>
<tr><td><code id="eltest4paucT_+3A_epst">epsT</code></td>
<td>
<p>Window width for smoother (ind) when find quantile.</p>
</td></tr>
<tr><td><code id="eltest4paucT_+3A_tol.u">tol.u</code></td>
<td>
<p>Error tol for final u probability vector. Must &gt; 0.</p>
</td></tr>
<tr><td><code id="eltest4paucT_+3A_tol.v">tol.v</code></td>
<td>
<p>Error tol for final v probability vector. Must &gt; 0.</p>
</td></tr>
<tr><td><code id="eltest4paucT_+3A_tol.h0">tol.H0</code></td>
<td>
<p>The error bound for checking if the constrained NPMLE satisfy H0, must &gt;0.</p>
</td></tr>
<tr><td><code id="eltest4paucT_+3A_p">p</code></td>
<td>
<p>The probability p in pAUC(0, p), and also in F(tau) = 1-p.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is similar to <code>el2testPaucT( )</code>. Just a different algorithm (not EM). 
Speed and convergence may be slightly different.
</p>
<p>This function is called by <code>eltest4paucONE</code>.  
It is listed here because the user may find it useful elsewhere.
</p>
<p>The empirical likelihood we used here is defined as
</p>
<p style="text-align: center;"><code class="reqn"> EL = \prod_{i=1}^m v_i \prod_{j=1}^n \nu_j ~;~~~~~~ \sum v_i =1 ~,~~ \sum \nu_j =1 ~. </code>
</p>



<h3>Value</h3>

<p>A list containing
</p>
<table>
<tr><td><code>lambda</code></td>
<td>
<p>The final tilting parameter.</p>
</td></tr>
<tr><td><code>u</code></td>
<td>
<p>the new u vector.</p>
</td></tr>
<tr><td><code>v</code></td>
<td>
<p>The new v vector.</p>
</td></tr>
<tr><td><code>"-2LLR"</code></td>
<td>
<p>The -2 log empirical likelihood ratio.</p>
</td></tr>
<tr><td><code>iterNum</code></td>
<td>
<p>The iteration number used in computing.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mai Zhou &lt;maizhou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Zhao, Y., Ding, X. and Zhou (2021). Confidence Intervals of AUC and pAUC by Empirical Likelihood.
Tech Report. https://www.ms.uky.edu/~mai/research/eAUC1.pdf
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
y &lt;- c(10, 209, 273, 279, 324, 391, 566, 785)
x &lt;- c(21, 38, 39, 51, 77, 185, 240, 289, 524)
</code></pre>

<hr>
<h2 id='emplikAUC.internal'>Internal emplikAUC functions
</h2><span id='topic+lamONE'></span><span id='topic+lam2'></span>

<h3>Description</h3>

<p>These are internal functions called by <code>eltest4aucONE</code> and <code>eltest4paucT</code>.  They are not intended
to be called by the user.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lamONE(u0, v0, indicmat, tol.H0)
lam2(u0, v0, indicmat1, indicmat2, tol.H0, start)
</code></pre>


<h3>Details</h3>

<p><code>lamONE()</code> find the lambda (tilting parameter) in the two sample Empirical Likelihood, 
with an AUC constrain. 
</p>
<p>This function computes the lambda that satisfy null hypothesis <code class="reqn">H_0</code> constraint by
using <code>uniroot</code>.
</p>
<p>Input: 
</p>
<p>u0 is a vector of probabilities, length m, for the first (X) sample.
</p>
<p>v0 is a vector of propabilities, length n, for the second (Y) sample.
</p>
<p>indicmat is a Matrix (size m by n) of indicator function values: I[X[i] &lt; Y[j]]. 
But typically smoothed and centered.
</p>
<p>tol.H0 is The error bound for (checking) if satisfy <code class="reqn">H_0</code>, must &gt; 0.
</p>
<p>This function is called by <code>eltest4aucONE</code>.  
It is listed here because the user may find it useful elsewhere.
</p>
<p>Output is A list containing:
</p>
<p>u, which is the new u vector.
</p>
<p>v, which is the new v vector.
</p>
<p>lam, which is The solution lambda.
</p>
<p>The function <code>lam2</code>, similar to function <code>lamONE</code>,
calculates the tilting parameter (lam1, lam2) for the empirical likelihood of
a hypothesis about pAUC(0, p) = theta and F(tau) = p.
</p>
<p>The function <code>lam2( )</code> is called by <code>eltest4paucT( )</code>, and is 
similar to <code>lamONE</code>
except there are 2 lambda's and needs
to call <code>multiroot()</code> to solve the
equation. 
</p>
<p>And also, with a starting value input to help the 
iteration of solve the equation. It is directly passed to <code>multiroot( )</code> function.
</p>
<p>Author: Ding Xue.
</p>

<hr>
<h2 id='findLnew'>
Finding the Lower bound of a confidence interval for theta by repeatedly testing the 
hypothesis for the parameter theta. 
</h2><span id='topic+findLnew'></span>

<h3>Description</h3>

<p>This function try to find the Lower bound of a confidence interval 
by repeatedly testing the 
hypothesis for the parameter theta until we reach the 
<code>level</code> for the &quot;-2LLR&quot; which return from
the user supplied function <code>fun</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findLnew(step=0.01, initStep=0, fun, MLE, level=qchisq(0.95,df=1), 
           tol=.Machine$double.eps^0.5,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findLnew_+3A_step">step</code></td>
<td>
<p>Search step. Must &gt; 0. </p>
</td></tr>
<tr><td><code id="findLnew_+3A_initstep">initStep</code></td>
<td>
<p>The initial step from MLE. May be used if we knew the bound is far away from MLE. This help
to speed up things. Should be &gt;=0.</p>
</td></tr>
<tr><td><code id="findLnew_+3A_fun">fun</code></td>
<td>
<p>The function that should return &quot;-2LLR&quot;.</p>
</td></tr>
<tr><td><code id="findLnew_+3A_mle">MLE</code></td>
<td>
<p>The MLE of the parameter.</p>
</td></tr>
<tr><td><code id="findLnew_+3A_level">level</code></td>
<td>
<p>The level of the confidence. Default to 3.84 which is 95 percent confidence.</p>
</td></tr>
<tr><td><code id="findLnew_+3A_tol">tol</code></td>
<td>
<p>The error bound for achieving the level given.</p>
</td></tr>
<tr><td><code id="findLnew_+3A_...">...</code></td>
<td>
<p>Any additional input to be passed to fun.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is similar to <code>findUnew( )</code>. 
</p>


<h3>Value</h3>

<p>It returns a list containing
</p>
<table>
<tr><td><code>Low</code></td>
<td>
<p>Lower bound of the confidence interval.</p>
</td></tr>
<tr><td><code>FstepL</code></td>
<td>
<p>The error when search for Lower bound.</p>
</td></tr>
<tr><td><code>Lvalue</code></td>
<td>
<p>The final likelihood ratio value for Lower bound. Should =~ level.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mai Zhou &lt;maizhou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Zhao, Y., Ding, X. and Zhou (2021). Confidence Intervals of AUC and pAUC by Empirical Likelihood.
Tech Report. https://www.ms.uky.edu/~mai/research/eAUC1.pdf
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
y &lt;- c(10, 209, 273, 279, 324, 391, 566, 785)
x &lt;- c(21, 38, 39, 51, 77, 185, 240, 289, 524)
</code></pre>

<hr>
<h2 id='findULNEW'>
Finding the Upper and Lower bound of a confidence interval for theta by repeatedly testing the 
hypothesis for the parameter theta. 
</h2><span id='topic+findULNEW'></span>

<h3>Description</h3>

<p>This function try to find the Upper and Lower bound of a confidence interval 
by repeatedly testing the 
hypothesis for the parameter theta until we reach the 
given level for the &quot;-2LLR&quot; which is returned from
the user supplied function <code>fun</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findULNEW(step=0.01, initStep=0, fun, MLE, level=qchisq(0.95,df=1), 
           tol=.Machine$double.eps^0.5,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findULNEW_+3A_step">step</code></td>
<td>
<p>Search step. Must &gt; 0. </p>
</td></tr>
<tr><td><code id="findULNEW_+3A_initstep">initStep</code></td>
<td>
<p>The initial step from MLE. May be used if we knew the bound is far away from MLE. This help
to speed up things. Should be &gt;=0.</p>
</td></tr>
<tr><td><code id="findULNEW_+3A_fun">fun</code></td>
<td>
<p>The function that should return &quot;-2LLR&quot;.</p>
</td></tr>
<tr><td><code id="findULNEW_+3A_mle">MLE</code></td>
<td>
<p>The MLE of the parameter.</p>
</td></tr>
<tr><td><code id="findULNEW_+3A_level">level</code></td>
<td>
<p>The level of the confidence. Default to 3.84 which is 95 percent confidence (assume df=1).</p>
</td></tr>
<tr><td><code id="findULNEW_+3A_tol">tol</code></td>
<td>
<p>The error bound for achieving the level given.</p>
</td></tr>
<tr><td><code id="findULNEW_+3A_...">...</code></td>
<td>
<p>Any additional input to be passed to fun.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function just combines the two functions <code>findUnew( )</code> and <code>findLnew( )</code>.
</p>


<h3>Value</h3>

<p>It returns a list containing
</p>
<table>
<tr><td><code>Low</code></td>
<td>
<p>Lower bound of the confidence interval.</p>
</td></tr>
<tr><td><code>Up</code></td>
<td>
<p>Upper bound of the confidence interval.</p>
</td></tr>
<tr><td><code>FstepL</code></td>
<td>
<p>The error when search for Lower bound.</p>
</td></tr>
<tr><td><code>FstepU</code></td>
<td>
<p>The error when search for Upper bound.</p>
</td></tr>
<tr><td><code>Lvalue</code></td>
<td>
<p>The final likelihood ratio value for Lower bound. Should = level.</p>
</td></tr>
<tr><td><code>Uvalue</code></td>
<td>
<p>The final likelihood ratio value for Upper bound. Should = level.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mai Zhou &lt;maizhou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Zhao, Y., Ding, X. and Zhou (2021). Confidence Intervals of AUC and pAUC by Empirical Likelihood.
Tech Report. https://www.ms.uky.edu/~mai/research/eAUC1.pdf
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
y &lt;- c(10, 209, 273, 279, 324, 391, 566, 785)
x &lt;- c(21, 38, 39, 51, 77, 185, 240, 289, 524)
</code></pre>

<hr>
<h2 id='findUnew'>
Finding the Upper bound of a confidence interval for <code>theta</code> by repeatedly testing the 
hypothesis for the parameter <code>theta</code>. 
</h2><span id='topic+findUnew'></span>

<h3>Description</h3>

<p>This function try to find the Upper bound of a confidence interval 
by repeatedly testing the 
hypothesis for the parameter theta until we reach the 
level for the &quot;-2LLR&quot; which return from
the user supplied function <code>fun</code>. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>findUnew(step=0.01, initStep=0, fun, MLE, level=qchisq(0.95,df=1), 
           tol=.Machine$double.eps^0.5,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="findUnew_+3A_step">step</code></td>
<td>
<p>Search step. Must &gt; 0. </p>
</td></tr>
<tr><td><code id="findUnew_+3A_initstep">initStep</code></td>
<td>
<p>The initial step from MLE. May be used if we knew the bound is far away from MLE. This help
to speed up things. Should be &gt;=0.</p>
</td></tr>
<tr><td><code id="findUnew_+3A_fun">fun</code></td>
<td>
<p>The user supplied function that should return &quot;-2LLR&quot;.</p>
</td></tr>
<tr><td><code id="findUnew_+3A_mle">MLE</code></td>
<td>
<p>The MLE of the parameter. An approximate value should be OK.</p>
</td></tr>
<tr><td><code id="findUnew_+3A_level">level</code></td>
<td>
<p>The level of the confidence. Default to 3.84 which is 95 percent confidence.</p>
</td></tr>
<tr><td><code id="findUnew_+3A_tol">tol</code></td>
<td>
<p>The error bound for achieving the level given.</p>
</td></tr>
<tr><td><code id="findUnew_+3A_...">...</code></td>
<td>
<p>Any additional input to be passed to fun.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is similar to <code>findLnew( )</code>.
</p>
<p>The search is separate (for upper and lower) 
since Upper and Lower bound may behave differently and require different 
nuisance parameters inputs (in <code>...</code>).
</p>


<h3>Value</h3>

<p>It returns a list containing
</p>
<table>
<tr><td><code>Up</code></td>
<td>
<p>Upper bound of the confidence interval.</p>
</td></tr>
<tr><td><code>FstepU</code></td>
<td>
<p>The error when search for Upper bound.</p>
</td></tr>
<tr><td><code>Uvalue</code></td>
<td>
<p>The final likelihood ratio value for Upper bound. Should =~ level.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Mai Zhou &lt;maizhou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Zhao, Y., Ding, X. and Zhou (2021). Confidence Intervals of AUC and pAUC by Empirical Likelihood.
Tech Report. https://www.ms.uky.edu/~mai/research/eAUC1.pdf
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
y &lt;- c(10, 209, 273, 279, 324, 391, 566, 785)
x &lt;- c(21, 38, 39, 51, 77, 185, 240, 289, 524)
</code></pre>

<hr>
<h2 id='myEstPaucT'>
Given the x, y 2-sample data, 
first estimate the (1-partial)-th quantile of X sample, then 
estimate the pAUC(0, partial), with the plug-in estimated quantile.
</h2><span id='topic+myEstPaucT'></span>

<h3>Description</h3>

<p>This function computes the estimator using smoothed Indicator function I[x &lt; y] which is
a 3rd order polynomial.
</p>
<p><code class="reqn">eps</code> is a scalar, must &gt; 0. It is the smoothing window width for indicator function when compare x-y.
<code class="reqn">epsT</code> is a scalar, must &gt; 0. It is the smoothing window width for estimating quantile function when compare x with tau.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>myEstPaucT(x, y, partial, eps=0.05, epsT=(length(x))^(-0.75)) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="myEstPaucT_+3A_x">x</code></td>
<td>
<p>a vector of observations, length m, for the first sample. Test-results with healthy subjects.</p>
</td></tr>
<tr><td><code id="myEstPaucT_+3A_y">y</code></td>
<td>
<p>a vector of observations, length n, for the second sample. Test-results with desease subjects.</p>
</td></tr>
<tr><td><code id="myEstPaucT_+3A_partial">partial</code></td>
<td>
<p>The probability in pAUC(0, partial). </p>
</td></tr>
<tr><td><code id="myEstPaucT_+3A_eps">eps</code></td>
<td>
<p>The smoothing window width, for indicator I[x &lt; y]. Must &gt;0.</p>
</td></tr>
<tr><td><code id="myEstPaucT_+3A_epst">epsT</code></td>
<td>
<p>The smoothing window width for the quantile estimation. Must &gt;0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function gives the estimators that are consistant with our smoothing used in the computation of 
empirical likelihood.
Typically the smoother for quantile should be a bit &quot;smoother&quot; that usual.
</p>
<p>Known problem: when input <code>partial</code> is too close to 1 or 0, it will fail.
When <code>partial</code> is equal to 1, then the pAUC reduces to AUC, which can be estimated easily,
as the example below shows.
</p>
<p>Why not also give the AUC estimator? May be it is too easy. See example below.
</p>


<h3>Value</h3>

<p>This function returns a list, with 
</p>
<table>
<tr><td><code>"tau(1-partial)"</code></td>
<td>
<p>The estimator for the (1-partial)-th quantile of X-distribution,</p>
</td></tr></table>
<p> and
</p>
<table>
<tr><td><code>"Pauc(0</code>, <code>partial)"</code></td>
<td>
<p>The estimated pAUC.</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Mai Zhou &lt;maizhou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Zhao, Y., Ding, X. and Zhou (2021). Confidence Intervals of AUC and pAUC by Empirical Likelihood.
Tech Report. https://www.ms.uky.edu/~mai/research/eAUC1.pdf
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
y &lt;- c(10, 209, 273, 279, 324, 391, 566, 785)
x &lt;- c(21, 38, 39, 51, 77, 185, 240, 289, 524)
#### To get an estimator of the AUC (not pAUC), using our smooth3( ), we do
sum(smooth3(x=x, y=y))/(length(x)*length(y))
#### We should get AUC = 0.75.
#### To get the estimator of the pAUC(0, 0.3) AND the 70th quantile of x sample
myEstPaucT(x=x, y=y, partial=0.3)
#### We should get estimator tau(1-0.3)=239.9474 and pAUC(0, 0.3)=0.1416667.
</code></pre>

<hr>
<h2 id='quantONE'>
Smoothed quantile estimation from the given x-sample.  
</h2><span id='topic+quantONE'></span>

<h3>Description</h3>

<p>This function computes the smoothed quantile estimate, 
using the smoothing function <code>smooth3</code>. (or it can be changed easily)
Otherwise it is similar to R function <code>quantile()</code>.
Compare to <code>quantile(x, prob, type=9)</code>.
</p>
<p><code class="reqn">myeps</code> is a scalar, must &gt; 0. It is the smoothing window width.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>quantONE(x, prob, myeps=(length(x))^(-0.75))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="quantONE_+3A_x">x</code></td>
<td>
<p>a vector of observations, length m, the sample.</p>
</td></tr>
<tr><td><code id="quantONE_+3A_prob">prob</code></td>
<td>
<p>a probabilty.</p>
</td></tr>
<tr><td><code id="quantONE_+3A_myeps">myeps</code></td>
<td>
<p>The smoothing window width, must &gt;0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is called by <code>myEstPaucT</code>.  
It is listed here because the user may find it useful elsewhere.
</p>
<p>Known problems: when the input <code>prob</code> is too close to 0 or 1 (distance less than 0.03),
the computation will stop.
Also, if the solution to the equation
</p>
<p style="text-align: center;"><code class="reqn"> \tau ~| ~~~ \frac{1}{m} \sum_{i=1}^m smooth3vec(X_i, \tau, myeps)  =  prob </code>
</p>
 
<p>is not unique, this function only returns one of the solutions.
</p>


<h3>Value</h3>

<p>The function <code>quantONE</code> returns a scalar that is the estimated (prob)-th quantile of X distribution.
</p>


<h3>Author(s)</h3>

<p>Mai Zhou &lt;maizhou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Zhao, Y., Ding, X. and Zhou (2021). Confidence Intervals of AUC and pAUC by Empirical Likelihood.
Tech Report. https://www.ms.uky.edu/~mai/research/eAUC1.pdf
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
y &lt;- c(10, 209, 273, 279, 324, 391, 566, 785)
x &lt;- c(21, 38, 39, 51, 77, 185, 240, 289, 524)
#### To estimate the 70-th percentile of x distrubution:
quantONE(x=x, prob=0.7)
#### we should get 239.9474. 
</code></pre>

<hr>
<h2 id='smooth3'>
Smoothed indicator function I[x &lt; y], which is the integration of the Epanechnikov kernal.  
</h2><span id='topic+smooth3'></span>

<h3>Description</h3>

<p>This function computes the smoothed Indicator function I[x &lt; y] using
a 3rd order polynomial.
</p>
<p>If |x-y| &gt; eps then the result is the same as the indicator function I[x &lt; y] (either 0 or 1).
For |x-y| &lt; eps, it is a 3rd order polynomial.
</p>
<p><code class="reqn">eps</code> is a scalar, must &gt; 0. It is the smoothing window width.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth3(x, y, eps=0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth3_+3A_x">x</code></td>
<td>
<p>a vector of observations, length m, for the first sample.</p>
</td></tr>
<tr><td><code id="smooth3_+3A_y">y</code></td>
<td>
<p>a vector of observations, length n, for the second sample.</p>
</td></tr>
<tr><td><code id="smooth3_+3A_eps">eps</code></td>
<td>
<p>The smoothing window width, must &gt;0.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used in many places to replace an indicator function <code class="reqn">I[x&lt;y]</code>. 
For example, when estimating the AUC. 
It is listed here because users may find it useful elsewhere.
</p>


<h3>Value</h3>

<p><code>smooth3( )</code> returns a matrix of dimension <code>ncol=length(y)</code>, <code>nrow=length(x)</code>. The entry
of the matrix are smoothed values of  I[x[i] &lt; y[j]].
</p>


<h3>Author(s)</h3>

<p>Mai Zhou &lt;maizhou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Zhao, Y., Ding, X. and Zhou (2021). Confidence Intervals of AUC and pAUC by Empirical Likelihood.
Tech Report. https://www.ms.uky.edu/~mai/research/eAUC1.pdf
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
y &lt;- c(10, 209, 273, 279, 324, 391, 566, 785)
x &lt;- c(21, 38, 39, 51, 77, 185, 240, 289, 524)
</code></pre>

<hr>
<h2 id='smooth3vec'>
Smoothed indicator function I[x &lt; const], which is the integration of the Epanechnikov kernal.  
</h2><span id='topic+smooth3vec'></span>

<h3>Description</h3>

<p>This function computes the smoothed Indicator function I[x &lt; const] using
a 3rd order polynomial.
</p>
<p>If |x - const| &gt; eps then the result is the same as the indicator function I[x &lt; const] (either 0 or 1).
For |x - const| &lt; eps, it is a 3rd order polynomial.
</p>
<p><code class="reqn">eps</code> is a scalar, must &gt; 0. It is the smoothing window width.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth3vec(x, const, eps=0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth3vec_+3A_x">x</code></td>
<td>
<p>a vector of observations, length m, for the first sample.</p>
</td></tr>
<tr><td><code id="smooth3vec_+3A_const">const</code></td>
<td>
<p>a single number.</p>
</td></tr>
<tr><td><code id="smooth3vec_+3A_eps">eps</code></td>
<td>
<p>The smoothing window width, must be &gt;0. Ideally this should be sample size dependent.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is similar to <code>smooth3</code> but only compare the x vector to a single number 
and thus returns a vector instead of matrix. 
You may also use the <code>smooth3()</code> with a bit care, for that matter, but this vector
version should be faster and save memory.  
It is listed here because the user may find it useful elsewhere.
</p>
<p>We used this function to estimate the quantile from the x-sample.
</p>


<h3>Value</h3>

<p><code>smooth3vec</code> returns a vector of length=length(x). The entry
of the matrix are smoothed values of  I[x[i] &lt; const].
</p>


<h3>Author(s)</h3>

<p>Mai Zhou &lt;maizhou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Zhao, Y., Ding, X. and Zhou (2021). Confidence Intervals of AUC and pAUC by Empirical Likelihood.
Tech Report. https://www.ms.uky.edu/~mai/research/eAUC1.pdf
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
y &lt;- c(10, 209, 273, 279, 324, 391, 566, 785)
x &lt;- c(21, 38, 39, 51, 77, 185, 240, 289, 524)
</code></pre>

<hr>
<h2 id='smooth5vec'>
Smoothed indicator function I[x &lt; const], which is the integration of the Quartic kernal.  
</h2><span id='topic+smooth5vec'></span>

<h3>Description</h3>

<p>This function computes the smoothed Indicator function I[x &lt; const] using
a 5th order polynomial.
</p>
<p>If |x - const| &gt; eps then the result is the same as the indicator function I[x &lt; const] (either 0 or 1).
For |x - const| &lt; eps, it is a 5th order polynomial.
</p>
<p><code class="reqn">eps</code> is a scalar, must &gt; 0. It is the smoothing window width.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smooth5vec(x, const, eps=0.05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smooth5vec_+3A_x">x</code></td>
<td>
<p>a vector of observations, length m, for the first sample.</p>
</td></tr>
<tr><td><code id="smooth5vec_+3A_const">const</code></td>
<td>
<p>a single number.</p>
</td></tr>
<tr><td><code id="smooth5vec_+3A_eps">eps</code></td>
<td>
<p>The smoothing window width, must be &gt;0. Ideally, this should be sample size dependent.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is twice continuously differenciable, smoother than <code>smooth3vec</code>.
It is listed here because the user may need extra smoothness (compare to <code>smooth3vec</code>)
and may find it useful elsewhere.
</p>


<h3>Value</h3>

<p><code>smooth5vec</code> returns a vector of length=length(x). The entry
of the vector are smoothed values of  I[x[i] &lt; const].
</p>


<h3>Author(s)</h3>

<p>Mai Zhou &lt;maizhou@gmail.com&gt;.
</p>


<h3>References</h3>

<p>Zhao, Y., Ding, X. and Zhou (2021). Confidence Intervals of AUC and pAUC by Empirical Likelihood.
Tech Report. https://www.ms.uky.edu/~mai/research/eAUC1.pdf
</p>


<h3>Examples</h3>

<pre><code class='language-R'> 
y &lt;- c(10, 209, 273, 279, 324, 391, 566, 785)
x &lt;- c(21, 38, 39, 51, 77, 185, 240, 289, 524)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
