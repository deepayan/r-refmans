<!DOCTYPE html><html><head><title>Help for package SMFilter</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SMFilter}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#FDist2'><p>Compute the squared Frobenius distance between two matrices.</p></a></li>
<li><a href='#FilterModel1'><p>Filtering algorithm for the type one model.</p></a></li>
<li><a href='#FilterModel2'><p>Filtering algorithm for the type two model.</p></a></li>
<li><a href='#rmLB_sm'><p>Sample from the matrix Langevin-Bingham on the Stiefel manifold.</p></a></li>
<li><a href='#runif_sm'><p>Sample from the uniform distribution on the Stiefel manifold.</p></a></li>
<li><a href='#rvlb_sm'><p>Sample from the vector Langevin-Bingham on the Stiefel manifold.</p></a></li>
<li><a href='#SimModel1'><p>Simulate from the type one state-space Model on Stiefel manifold.</p></a></li>
<li><a href='#SimModel2'><p>Simulate from the type two state-space Model on Stiefel manifold.</p></a></li>
<li><a href='#SMFilter'><p>SMFilter: a package implementing the filtering algorithms for the state-space models on the Stiefel manifold.</p></a></li>
<li><a href='#version'><p>Show the version number of some information.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Filtering Algorithms for the State Space Models on the Stiefel
Manifold</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.3</td>
</tr>
<tr>
<td>Description:</td>
<td>Provides the filtering algorithms for the state space models on the Stiefel manifold as well as the corresponding sampling algorithms for uniform, vector Langevin-Bingham and matrix Langevin-Bingham distributions on the Stiefel manifold.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>6.1.1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/yukai-yang/SMFilter">https://github.com/yukai-yang/SMFilter</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/yukai-yang/SMFilter/issues">https://github.com/yukai-yang/SMFilter/issues</a></td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, ggplot2</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2018-12-12 22:10:57 UTC; yyang</td>
</tr>
<tr>
<td>Author:</td>
<td>Yukai Yang [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Yukai Yang &lt;yukai.yang@statistik.uu.se&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2018-12-12 22:20:03 UTC</td>
</tr>
</table>
<hr>
<h2 id='FDist2'>Compute the squared Frobenius distance between two matrices.</h2><span id='topic+FDist2'></span>

<h3>Description</h3>

<p>This function Compute the squared Frobenius distance between two matrices.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FDist2(mX, mY)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FDist2_+3A_mx">mX</code></td>
<td>
<p>a <code class="reqn">p \times r</code> matrix where <code class="reqn">p \geq r</code>.</p>
</td></tr>
<tr><td><code id="FDist2_+3A_my">mY</code></td>
<td>
<p>another <code class="reqn">p \times r</code> matrix where <code class="reqn">p \geq r</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Frobenius distance between two matrices is defined to be
</p>
<p style="text-align: center;"><code class="reqn">d(X, Y) = \sqrt{ \mathrm{tr} \{ A' A \} }</code>
</p>

<p>where <code class="reqn">A = X - Y</code>.
</p>
<p>The Frobenius distance is a possible measure of the distance between two points on the Stiefel manifold.
</p>


<h3>Value</h3>

<p>the Frobenius distance.
</p>


<h3>Author(s)</h3>

<p>Yukai Yang, <a href="mailto:yukai.yang@statistik.uu.se">yukai.yang@statistik.uu.se</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
FDist2(runif_sm(1,4,2)[1,,], runif_sm(1,4,2)[1,,])

</code></pre>

<hr>
<h2 id='FilterModel1'>Filtering algorithm for the type one model.</h2><span id='topic+FilterModel1'></span>

<h3>Description</h3>

<p>This function implements the filtering algorithm for the type one model.
See Details part below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FilterModel1(mY, mX, mZ, beta, mB = NULL, Omega, vD, U0,
  method = "max_1")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FilterModel1_+3A_my">mY</code></td>
<td>
<p>the matrix containing Y_t with dimension <code class="reqn">T \times p</code>.</p>
</td></tr>
<tr><td><code id="FilterModel1_+3A_mx">mX</code></td>
<td>
<p>the matrix containing X_t with dimension <code class="reqn">T \times q_1</code>.</p>
</td></tr>
<tr><td><code id="FilterModel1_+3A_mz">mZ</code></td>
<td>
<p>the matrix containing Z_t with dimension <code class="reqn">T \times q_2</code>.</p>
</td></tr>
<tr><td><code id="FilterModel1_+3A_beta">beta</code></td>
<td>
<p>the <code class="reqn">\beta</code> matrix.</p>
</td></tr>
<tr><td><code id="FilterModel1_+3A_mb">mB</code></td>
<td>
<p>the coefficient matrix <code class="reqn">\boldsymbol{B}</code> before <code>mZ</code> with dimension <code class="reqn">p \times q_2</code>.</p>
</td></tr>
<tr><td><code id="FilterModel1_+3A_omega">Omega</code></td>
<td>
<p>covariance matrix of the errors.</p>
</td></tr>
<tr><td><code id="FilterModel1_+3A_vd">vD</code></td>
<td>
<p>vector of the diagonals of <code class="reqn">D</code>.</p>
</td></tr>
<tr><td><code id="FilterModel1_+3A_u0">U0</code></td>
<td>
<p>initial value of the alpha sequence.</p>
</td></tr>
<tr><td><code id="FilterModel1_+3A_method">method</code></td>
<td>
<p>a string representing the optimization method from c('max_1','max_2','max_3','min_1','min_2').</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The type one model on Stiefel manifold takes the form:
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol{y}_t \quad = \quad \boldsymbol{\alpha}_t \boldsymbol{\beta} ' \boldsymbol{x}_t + \boldsymbol{B} \boldsymbol{z}_t + \boldsymbol{\varepsilon}_t</code>
</p>

<p style="text-align: center;"><code class="reqn">\boldsymbol{\alpha}_{t+1} | \boldsymbol{\alpha}_{t} \quad \sim \quad ML (p, r, \boldsymbol{\alpha}_{t} \boldsymbol{D})</code>
</p>

<p>where <code class="reqn">\boldsymbol{y}_t</code> is a <code class="reqn">p</code>-vector of the dependent variable,
<code class="reqn">\boldsymbol{x}_t</code> and <code class="reqn">\boldsymbol{z}_t</code> are explanatory variables wit dimension <code class="reqn">q_1</code> and <code class="reqn">q_2</code>,
<code class="reqn">\boldsymbol{x}_t</code> and <code class="reqn">\boldsymbol{z}_t</code> have no overlap,
matrix <code class="reqn">\boldsymbol{B}</code> is the coefficients for <code class="reqn">\boldsymbol{z}_t</code>,
<code class="reqn">\boldsymbol{\varepsilon}_t</code> is the error vector.
</p>
<p>The matrices <code class="reqn">\boldsymbol{\alpha}_t</code> and <code class="reqn">\boldsymbol{\beta}</code> have dimensions <code class="reqn">p \times r</code> and <code class="reqn">q_1 \times r</code>, respectively.
Note that <code class="reqn">r</code> is strictly smaller than both <code class="reqn">p</code> and <code class="reqn">q_1</code>.
<code class="reqn">\boldsymbol{\alpha}_t</code> and <code class="reqn">\boldsymbol{\beta}</code> are both non-singular matrices.
<code class="reqn">\boldsymbol{\alpha}_t</code> is time-varying while <code class="reqn">\boldsymbol{\beta}</code> is time-invariant.
</p>
<p>Furthermore, <code class="reqn">\boldsymbol{\alpha}_t</code> fulfills the condition <code class="reqn">\boldsymbol{\alpha}_t' \boldsymbol{\alpha}_t = \boldsymbol{I}_r</code>,
and therefor it evolves on the Stiefel manifold.
</p>
<p><code class="reqn">ML (p, r, \boldsymbol{\alpha}_{t} \boldsymbol{D})</code> denotes the Matrix Langevin distribution or matrix von Mises-Fisher distribution on the Stiefel manifold.
Its density function takes the form
</p>
<p style="text-align: center;"><code class="reqn">f(\boldsymbol{\alpha_{t+1}} ) = \frac{ \mathrm{etr} \left\{ \boldsymbol{D} \boldsymbol{\alpha}_{t}' \boldsymbol{\alpha_{t+1}} \right\} }{ _{0}F_1 (\frac{p}{2}; \frac{1}{4}\boldsymbol{D}^2 ) }</code>
</p>

<p>where <code class="reqn">\mathrm{etr}</code> denotes <code class="reqn">\mathrm{exp}(\mathrm{tr}())</code>,
and <code class="reqn">_{0}F_1 (\frac{p}{2}; \frac{1}{4}\boldsymbol{D}^2 )</code> is the (0,1)-type hypergeometric function for matrix.
</p>


<h3>Value</h3>

<p>an array <code>aAlpha</code> containing the modal orientations of alpha in the prediction step.
</p>


<h3>Author(s)</h3>

<p>Yukai Yang, <a href="mailto:yukai.yang@statistik.uu.se">yukai.yang@statistik.uu.se</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
iT = 50
ip = 2
ir = 1
iqx = 4
iqz=0
ik = 0
Omega = diag(ip)*.1

if(iqx==0) mX=NULL else mX = matrix(rnorm(iT*iqx),iT, iqx)
if(iqz==0) mZ=NULL else mZ = matrix(rnorm(iT*iqz),iT, iqz)
if(ik==0) mY=NULL else mY = matrix(0, ik, ip)

alpha_0 = matrix(c(runif_sm(num=1,ip=ip,ir=ir)), ip, ir)
beta = matrix(c(runif_sm(num=1,ip=ip*ik+iqx,ir=ir)), ip*ik+iqx, ir)
mB=NULL
vD = 100

ret = SimModel1(iT=iT, mX=mX, mZ=mZ, mY=mY, alpha_0=alpha_0, beta=beta, mB=mB, vD=vD, Omega=Omega)
mYY=as.matrix(ret$dData[,1:ip])
fil = FilterModel1(mY=mYY, mX=mX, mZ=mZ, beta=beta, mB=mB, Omega=Omega, vD=vD, U0=alpha_0)

</code></pre>

<hr>
<h2 id='FilterModel2'>Filtering algorithm for the type two model.</h2><span id='topic+FilterModel2'></span>

<h3>Description</h3>

<p>This function implements the filtering algorithm for the type two model.
See Details part below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FilterModel2(mY, mX, mZ, alpha, mB = NULL, Omega, vD, U0,
  method = "max_1")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FilterModel2_+3A_my">mY</code></td>
<td>
<p>the matrix containing Y_t with dimension <code class="reqn">T \times p</code>.</p>
</td></tr>
<tr><td><code id="FilterModel2_+3A_mx">mX</code></td>
<td>
<p>the matrix containing X_t with dimension <code class="reqn">T \times q_1</code>.</p>
</td></tr>
<tr><td><code id="FilterModel2_+3A_mz">mZ</code></td>
<td>
<p>the matrix containing Z_t with dimension <code class="reqn">T \times q_2</code>.</p>
</td></tr>
<tr><td><code id="FilterModel2_+3A_alpha">alpha</code></td>
<td>
<p>the <code class="reqn">\alpha</code> matrix.</p>
</td></tr>
<tr><td><code id="FilterModel2_+3A_mb">mB</code></td>
<td>
<p>the coefficient matrix <code class="reqn">\boldsymbol{B}</code> before <code>mZ</code> with dimension <code class="reqn">p \times q_2</code>.</p>
</td></tr>
<tr><td><code id="FilterModel2_+3A_omega">Omega</code></td>
<td>
<p>covariance matrix of the errors.</p>
</td></tr>
<tr><td><code id="FilterModel2_+3A_vd">vD</code></td>
<td>
<p>vector of the diagonals of <code class="reqn">D</code>.</p>
</td></tr>
<tr><td><code id="FilterModel2_+3A_u0">U0</code></td>
<td>
<p>initial value of the alpha sequence.</p>
</td></tr>
<tr><td><code id="FilterModel2_+3A_method">method</code></td>
<td>
<p>a string representing the optimization method from c('max_1','max_2','max_3','min_1','min_2').</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The type two model on Stiefel manifold takes the form:
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol{y}_t \quad = \quad \boldsymbol{\alpha} \boldsymbol{\beta}_t ' \boldsymbol{x}_t + \boldsymbol{B}' \boldsymbol{z}_t + \boldsymbol{\varepsilon}_t</code>
</p>

<p style="text-align: center;"><code class="reqn">\boldsymbol{\beta}_{t+1} | \boldsymbol{\beta}_{t} \quad \sim \quad ML (q_1, r, \boldsymbol{\beta}_{t} \boldsymbol{D})</code>
</p>

<p>where <code class="reqn">\boldsymbol{y}_t</code> is a <code class="reqn">p</code>-vector of the dependent variable,
<code class="reqn">\boldsymbol{x}_t</code> and <code class="reqn">\boldsymbol{z}_t</code> are explanatory variables wit dimension <code class="reqn">q_1</code> and <code class="reqn">q_2</code>,
<code class="reqn">\boldsymbol{x}_t</code> and <code class="reqn">\boldsymbol{z}_t</code> have no overlap,
matrix <code class="reqn">\boldsymbol{B}</code> is the coefficients for <code class="reqn">\boldsymbol{z}_t</code>,
<code class="reqn">\boldsymbol{\varepsilon}_t</code> is the error vector.
</p>
<p>The matrices <code class="reqn">\boldsymbol{\alpha}</code> and <code class="reqn">\boldsymbol{\beta}_t</code> have dimensions <code class="reqn">p \times r</code> and <code class="reqn">q_1 \times r</code>, respectively.
Note that <code class="reqn">r</code> is strictly smaller than both <code class="reqn">p</code> and <code class="reqn">q_1</code>.
<code class="reqn">\boldsymbol{\alpha}</code> and <code class="reqn">\boldsymbol{\beta}_t</code> are both non-singular matrices.
<code class="reqn">\boldsymbol{\beta}_t</code> is time-varying while <code class="reqn">\boldsymbol{\alpha}</code> is time-invariant.
</p>
<p>Furthermore, <code class="reqn">\boldsymbol{\beta}_t</code> fulfills the condition <code class="reqn">\boldsymbol{\beta}_t' \boldsymbol{\beta}_t = \boldsymbol{I}_r</code>,
and therefor it evolves on the Stiefel manifold.
</p>
<p><code class="reqn">ML (p, r, \boldsymbol{\beta}_t \boldsymbol{D})</code> denotes the Matrix Langevin distribution or matrix von Mises-Fisher distribution on the Stiefel manifold.
Its density function takes the form
</p>
<p style="text-align: center;"><code class="reqn">f(\boldsymbol{\beta_{t+1}} ) = \frac{ \mathrm{etr} \left\{ \boldsymbol{D} \boldsymbol{\beta}_{t}' \boldsymbol{\beta_{t+1}} \right\} }{ _{0}F_1 (\frac{p}{2}; \frac{1}{4}\boldsymbol{D}^2 ) }</code>
</p>

<p>where <code class="reqn">\mathrm{etr}</code> denotes <code class="reqn">\mathrm{exp}(\mathrm{tr}())</code>,
and <code class="reqn">_{0}F_1 (\frac{p}{2}; \frac{1}{4}\boldsymbol{D}^2 )</code> is the (0,1)-type hypergeometric function for matrix.
</p>


<h3>Value</h3>

<p>an array <code>aAlpha</code> containing the modal orientations of alpha in the prediction step.
</p>


<h3>Author(s)</h3>

<p>Yukai Yang, <a href="mailto:yukai.yang@statistik.uu.se">yukai.yang@statistik.uu.se</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
iT = 50
ip = 2
ir = 1
iqx = 4
iqz=0
ik = 0
Omega = diag(ip)*.1

if(iqx==0) mX=NULL else mX = matrix(rnorm(iT*iqx),iT, iqx)
if(iqz==0) mZ=NULL else mZ = matrix(rnorm(iT*iqz),iT, iqz)
if(ik==0) mY=NULL else mY = matrix(0, ik, ip)

alpha = matrix(c(runif_sm(num=1,ip=ip,ir=ir)), ip, ir)
beta_0 = matrix(c(runif_sm(num=1,ip=ip*ik+iqx,ir=ir)), ip*ik+iqx, ir)
mB=NULL
vD = 100

ret = SimModel2(iT=iT, mX=mX, mZ=mZ, mY=mY, alpha=alpha, beta_0=beta_0, mB=mB, vD=vD)
mYY=as.matrix(ret$dData[,1:ip])
fil = FilterModel2(mY=mYY, mX=mX, mZ=mZ, alpha=alpha, mB=mB, Omega=Omega, vD=vD, U0=beta_0)

</code></pre>

<hr>
<h2 id='rmLB_sm'>Sample from the matrix Langevin-Bingham on the Stiefel manifold.</h2><span id='topic+rmLB_sm'></span>

<h3>Description</h3>

<p>This function draws a sample from the matrix Langevin-Bingham on the Stiefel manifold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rmLB_sm(num, mJ, mH, mC, mX, ir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rmLB_sm_+3A_num">num</code></td>
<td>
<p>number of observations or sample size.</p>
</td></tr>
<tr><td><code id="rmLB_sm_+3A_mj">mJ</code></td>
<td>
<p>symmetric ip*ip matrix</p>
</td></tr>
<tr><td><code id="rmLB_sm_+3A_mh">mH</code></td>
<td>
<p>symmetric ir*ir matrix</p>
</td></tr>
<tr><td><code id="rmLB_sm_+3A_mc">mC</code></td>
<td>
<p>ip*ir matrix</p>
</td></tr>
<tr><td><code id="rmLB_sm_+3A_mx">mX</code></td>
<td>
<p>ip*ir matrix, the initial value</p>
</td></tr>
<tr><td><code id="rmLB_sm_+3A_ir">ir</code></td>
<td>
<p>ir</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The matrix Langevin-Bingham distribution on the Stiefel manifold has the density kernel:
</p>
<p style="text-align: center;"><code class="reqn">f(X) \propto \mathrm{etr}\{ H X' J X + C' X \}</code>
</p>

<p>where <code class="reqn">X</code> satisfies <code class="reqn">X'X = I_r</code>, and <code class="reqn">H</code> and <code class="reqn">J</code> are symmetric matrices.
</p>


<h3>Value</h3>

<p>an array containing a sample of draws from the matrix Langevin-Bingham on the Stiefel manifold.
</p>


<h3>Author(s)</h3>

<p>Yukai Yang, <a href="mailto:yukai.yang@statistik.uu.se">yukai.yang@statistik.uu.se</a>
</p>
<p>#' @section References:
Hoff, P. D. (2009) &quot;Simulation of the Matrix Bingham—von Mises—Fisher Distribution, With Applications to Multivariate and Relational Data&quot;, Journal of Computational and Graphical Statistics, Vol. 18, pp. 438-456.
</p>

<hr>
<h2 id='runif_sm'>Sample from the uniform distribution on the Stiefel manifold.</h2><span id='topic+runif_sm'></span>

<h3>Description</h3>

<p>This function draws a sample from the uniform distribution on the Stiefel manifold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>runif_sm(num, ip, ir)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="runif_sm_+3A_num">num</code></td>
<td>
<p>number of observations or sample size.</p>
</td></tr>
<tr><td><code id="runif_sm_+3A_ip">ip</code></td>
<td>
<p>the first dimension <code class="reqn">p</code> of the matrix.</p>
</td></tr>
<tr><td><code id="runif_sm_+3A_ir">ir</code></td>
<td>
<p>the second dimension <code class="reqn">r</code> of the matrix.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Stiefel manifold with dimension <code class="reqn">p</code> and <code class="reqn">r</code> (<code class="reqn">p \geq r</code>) is a space whose points are <code class="reqn">r</code>-frames in <code class="reqn">R^p</code>.
A set of <code class="reqn">r</code> orthonormal vectors in <code class="reqn">R^p</code> is called an <code class="reqn">r</code>-frame in <code class="reqn">R^p</code>.
The Stiefel manifold is a collection of <code class="reqn">p \times r</code> full rank matrices <code class="reqn">X</code> such that <code class="reqn">X'X = I_r</code>.
</p>


<h3>Value</h3>

<p>an array with dimension <code>num</code>, <code>ip</code> and <code>ir</code> containing a sample of draws from the uniform distribution on the Stiefel manifold.
</p>


<h3>Author(s)</h3>

<p>Yukai Yang, <a href="mailto:yukai.yang@statistik.uu.se">yukai.yang@statistik.uu.se</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
runif_sm(10,4,2)

</code></pre>

<hr>
<h2 id='rvlb_sm'>Sample from the vector Langevin-Bingham on the Stiefel manifold.</h2><span id='topic+rvlb_sm'></span>

<h3>Description</h3>

<p>This function draws a sample from the vector Langevin-Bingham on the Stiefel manifold.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rvlb_sm(num, mA, vc, vx)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rvlb_sm_+3A_num">num</code></td>
<td>
<p>number of observations or sample size.</p>
</td></tr>
<tr><td><code id="rvlb_sm_+3A_ma">mA</code></td>
<td>
<p>the matrix A which is symmetric ip*ip matrix.</p>
</td></tr>
<tr><td><code id="rvlb_sm_+3A_vc">vc</code></td>
<td>
<p>the vector c with dimension ip.</p>
</td></tr>
<tr><td><code id="rvlb_sm_+3A_vx">vx</code></td>
<td>
<p>the vector x, the initial value.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The vector Langevin-Bingham distribution on the Stiefel manifold has the density kernel:
</p>
<p style="text-align: center;"><code class="reqn">f(X) \propto \mathrm{etr}\{ x' A x + c' x \}</code>
</p>

<p>where <code class="reqn">x</code> satisfies <code class="reqn">x'x = 1</code>, and <code class="reqn">A</code> is a symmetric matrix.
</p>


<h3>Value</h3>

<p>an array containing a sample of draws from the vector Langevin-Bingham on the Stiefel manifold.
</p>


<h3>References</h3>

<p>Hoff, P. D. (2009) &quot;Simulation of the Matrix Bingham—von Mises—Fisher Distribution, With Applications to Multivariate and Relational Data&quot;, Journal of Computational and Graphical Statistics, Vol. 18, pp. 438-456.
</p>


<h3>Author(s)</h3>

<p>Yukai Yang, <a href="mailto:yukai.yang@statistik.uu.se">yukai.yang@statistik.uu.se</a>
</p>

<hr>
<h2 id='SimModel1'>Simulate from the type one state-space Model on Stiefel manifold.</h2><span id='topic+SimModel1'></span>

<h3>Description</h3>

<p>This function simulates from the type one model on Stiefel manifold.
See Details part below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimModel1(iT, mX = NULL, mZ = NULL, mY = NULL, alpha_0, beta,
  mB = NULL, Omega = NULL, vD, burnin = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SimModel1_+3A_it">iT</code></td>
<td>
<p>the sample size.</p>
</td></tr>
<tr><td><code id="SimModel1_+3A_mx">mX</code></td>
<td>
<p>the matrix containing X_t with dimension <code class="reqn">T \times q_1</code>.</p>
</td></tr>
<tr><td><code id="SimModel1_+3A_mz">mZ</code></td>
<td>
<p>the matrix containing Z_t with dimension <code class="reqn">T \times q_2</code>.</p>
</td></tr>
<tr><td><code id="SimModel1_+3A_my">mY</code></td>
<td>
<p>initial values of the dependent variable for <code>ik-1</code> up to 0. If <code>mY = NULL</code>, then no lagged dependent variables in regressors.</p>
</td></tr>
<tr><td><code id="SimModel1_+3A_alpha_0">alpha_0</code></td>
<td>
<p>the initial alpha, <code class="reqn">p \times r</code>.</p>
</td></tr>
<tr><td><code id="SimModel1_+3A_beta">beta</code></td>
<td>
<p>the <code class="reqn">\beta</code> matrix, iqx+ip*ik, y_1,t-1,y_1,t-2,...,y_2,t-1,y_2,t-2,...</p>
</td></tr>
<tr><td><code id="SimModel1_+3A_mb">mB</code></td>
<td>
<p>the coefficient matrix <code class="reqn">\boldsymbol{B}</code> before <code>mZ</code> with dimension <code class="reqn">p \times q_2</code>.</p>
</td></tr>
<tr><td><code id="SimModel1_+3A_omega">Omega</code></td>
<td>
<p>covariance matrix of the errors.</p>
</td></tr>
<tr><td><code id="SimModel1_+3A_vd">vD</code></td>
<td>
<p>vector of the diagonals of <code class="reqn">D</code>.</p>
</td></tr>
<tr><td><code id="SimModel1_+3A_burnin">burnin</code></td>
<td>
<p>burn-in sample size (matrix Langevin).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The type one model on Stiefel manifold takes the form:
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol{y}_t \quad = \quad \boldsymbol{\alpha}_t \boldsymbol{\beta} ' \boldsymbol{x}_t + \boldsymbol{B} \boldsymbol{z}_t + \boldsymbol{\varepsilon}_t</code>
</p>

<p style="text-align: center;"><code class="reqn">\boldsymbol{\alpha}_{t+1} | \boldsymbol{\alpha}_{t} \quad \sim \quad ML (p, r, \boldsymbol{\alpha}_{t} \boldsymbol{D})</code>
</p>

<p>where <code class="reqn">\boldsymbol{y}_t</code> is a <code class="reqn">p</code>-vector of the dependent variable,
<code class="reqn">\boldsymbol{x}_t</code> and <code class="reqn">\boldsymbol{z}_t</code> are explanatory variables wit dimension <code class="reqn">q_1</code> and <code class="reqn">q_2</code>,
<code class="reqn">\boldsymbol{x}_t</code> and <code class="reqn">\boldsymbol{z}_t</code> have no overlap,
matrix <code class="reqn">\boldsymbol{B}</code> is the coefficients for <code class="reqn">\boldsymbol{z}_t</code>,
<code class="reqn">\boldsymbol{\varepsilon}_t</code> is the error vector.
</p>
<p>The matrices <code class="reqn">\boldsymbol{\alpha}_t</code> and <code class="reqn">\boldsymbol{\beta}</code> have dimensions <code class="reqn">p \times r</code> and <code class="reqn">q_1 \times r</code>, respectively.
Note that <code class="reqn">r</code> is strictly smaller than both <code class="reqn">p</code> and <code class="reqn">q_1</code>.
<code class="reqn">\boldsymbol{\alpha}_t</code> and <code class="reqn">\boldsymbol{\beta}</code> are both non-singular matrices.
<code class="reqn">\boldsymbol{\alpha}_t</code> is time-varying while <code class="reqn">\boldsymbol{\beta}</code> is time-invariant.
</p>
<p>Furthermore, <code class="reqn">\boldsymbol{\alpha}_t</code> fulfills the condition <code class="reqn">\boldsymbol{\alpha}_t' \boldsymbol{\alpha}_t = \boldsymbol{I}_r</code>,
and therefor it evolves on the Stiefel manifold.
</p>
<p><code class="reqn">ML (p, r, \boldsymbol{\alpha}_{t} \boldsymbol{D})</code> denotes the Matrix Langevin distribution or matrix von Mises-Fisher distribution on the Stiefel manifold.
Its density function takes the form
</p>
<p style="text-align: center;"><code class="reqn">f(\boldsymbol{\alpha_{t+1}} ) = \frac{ \mathrm{etr} \left\{ \boldsymbol{D} \boldsymbol{\alpha}_{t}' \boldsymbol{\alpha_{t+1}} \right\} }{ _{0}F_1 (\frac{p}{2}; \frac{1}{4}\boldsymbol{D}^2 ) }</code>
</p>

<p>where <code class="reqn">\mathrm{etr}</code> denotes <code class="reqn">\mathrm{exp}(\mathrm{tr}())</code>,
and <code class="reqn">_{0}F_1 (\frac{p}{2}; \frac{1}{4}\boldsymbol{D}^2 )</code> is the (0,1)-type hypergeometric function for matrix.
</p>
<p>Note that the function does not add intercept automatically.
</p>


<h3>Value</h3>

<p>A list containing the sampled data and the dynamics of alpha.
</p>
<p>The object is a list containing the following components:
</p>
<table>
<tr><td><code>dData</code></td>
<td>
<p>a data.frame of the sampled data</p>
</td></tr>
<tr><td><code>aAlpha</code></td>
<td>
<p>an array of the <code class="reqn">\boldsymbol{\alpha}_{t}</code> with the dimension <code class="reqn">T \times p \times r</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yukai Yang, <a href="mailto:yukai.yang@statistik.uu.se">yukai.yang@statistik.uu.se</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
iT = 50 # sample size
ip = 2 # dimension of the dependent variable
ir = 1 # rank number
iqx=2 # number of variables in X
iqz=2 # number of variables in Z
ik = 1 # lag length

if(iqx==0) mX=NULL else mX = matrix(rnorm(iT*iqx),iT, iqx)
if(iqz==0) mZ=NULL else mZ = matrix(rnorm(iT*iqz),iT, iqz)
if(ik==0) mY=NULL else mY = matrix(0, ik, ip)

alpha_0 = matrix(c(runif_sm(num=1,ip=ip,ir=ir)), ip, ir)
beta = matrix(c(runif_sm(num=1,ip=ip*ik+iqx,ir=ir)), ip*ik+iqx, ir)
if(ip*ik+iqz==0) mB=NULL else mB = matrix(c(runif_sm(num=1,ip=(ip*ik+iqz)*ip,ir=1)), ip, ip*ik+iqz)
vD = 50

ret = SimModel1(iT=iT, mX=mX, mZ=mZ, mY=mY, alpha_0=alpha_0, beta=beta, mB=mB, vD=vD)

</code></pre>

<hr>
<h2 id='SimModel2'>Simulate from the type two state-space Model on Stiefel manifold.</h2><span id='topic+SimModel2'></span>

<h3>Description</h3>

<p>This function simulates from the type two model on Stiefel manifold.
See Details part below.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SimModel2(iT, mX = NULL, mZ = NULL, mY = NULL, beta_0, alpha,
  mB = NULL, Omega = NULL, vD, burnin = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SimModel2_+3A_it">iT</code></td>
<td>
<p>the sample size.</p>
</td></tr>
<tr><td><code id="SimModel2_+3A_mx">mX</code></td>
<td>
<p>the matrix containing X_t with dimension <code class="reqn">T \times q_1</code>.</p>
</td></tr>
<tr><td><code id="SimModel2_+3A_mz">mZ</code></td>
<td>
<p>the matrix containing Z_t with dimension <code class="reqn">T \times q_2</code>.</p>
</td></tr>
<tr><td><code id="SimModel2_+3A_my">mY</code></td>
<td>
<p>initial values of the dependent variable for <code>ik-1</code> up to 0. If <code>mY = NULL</code>, then no lagged dependent variables in regressors.</p>
</td></tr>
<tr><td><code id="SimModel2_+3A_beta_0">beta_0</code></td>
<td>
<p>the initial beta, iqx+ip*ik, y_1,t-1,y_1,t-2,...,y_2,t-1,y_2,t-2,....</p>
</td></tr>
<tr><td><code id="SimModel2_+3A_alpha">alpha</code></td>
<td>
<p>the <code class="reqn">\alpha</code> matrix, <code class="reqn">p \times r</code>.</p>
</td></tr>
<tr><td><code id="SimModel2_+3A_mb">mB</code></td>
<td>
<p>the coefficient matrix <code class="reqn">\boldsymbol{B}</code> before <code>mZ</code> with dimension <code class="reqn">p \times q_2</code>.</p>
</td></tr>
<tr><td><code id="SimModel2_+3A_omega">Omega</code></td>
<td>
<p>covariance matrix of the errors.</p>
</td></tr>
<tr><td><code id="SimModel2_+3A_vd">vD</code></td>
<td>
<p>vector of the diagonals of <code class="reqn">D</code>.</p>
</td></tr>
<tr><td><code id="SimModel2_+3A_burnin">burnin</code></td>
<td>
<p>burn-in sample size (matrix Langevin).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The type two model on Stiefel manifold takes the form:
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol{y}_t \quad = \quad \boldsymbol{\alpha} \boldsymbol{\beta}_t ' \boldsymbol{x}_t + \boldsymbol{B}' \boldsymbol{z}_t + \boldsymbol{\varepsilon}_t</code>
</p>

<p style="text-align: center;"><code class="reqn">\boldsymbol{\beta}_{t+1} | \boldsymbol{\beta}_{t} \quad \sim \quad ML (q_1, r, \boldsymbol{\beta}_{t} \boldsymbol{D})</code>
</p>

<p>where <code class="reqn">\boldsymbol{y}_t</code> is a <code class="reqn">p</code>-vector of the dependent variable,
<code class="reqn">\boldsymbol{x}_t</code> and <code class="reqn">\boldsymbol{z}_t</code> are explanatory variables wit dimension <code class="reqn">q_1</code> and <code class="reqn">q_2</code>,
<code class="reqn">\boldsymbol{x}_t</code> and <code class="reqn">\boldsymbol{z}_t</code> have no overlap,
matrix <code class="reqn">\boldsymbol{B}</code> is the coefficients for <code class="reqn">\boldsymbol{z}_t</code>,
<code class="reqn">\boldsymbol{\varepsilon}_t</code> is the error vector.
</p>
<p>The matrices <code class="reqn">\boldsymbol{\alpha}</code> and <code class="reqn">\boldsymbol{\beta}_t</code> have dimensions <code class="reqn">p \times r</code> and <code class="reqn">q_1 \times r</code>, respectively.
Note that <code class="reqn">r</code> is strictly smaller than both <code class="reqn">p</code> and <code class="reqn">q_1</code>.
<code class="reqn">\boldsymbol{\alpha}</code> and <code class="reqn">\boldsymbol{\beta}_t</code> are both non-singular matrices.
<code class="reqn">\boldsymbol{\beta}_t</code> is time-varying while <code class="reqn">\boldsymbol{\alpha}</code> is time-invariant.
</p>
<p>Furthermore, <code class="reqn">\boldsymbol{\beta}_t</code> fulfills the condition <code class="reqn">\boldsymbol{\beta}_t' \boldsymbol{\beta}_t = \boldsymbol{I}_r</code>,
and therefor it evolves on the Stiefel manifold.
</p>
<p><code class="reqn">ML (p, r, \boldsymbol{\beta}_t \boldsymbol{D})</code> denotes the Matrix Langevin distribution or matrix von Mises-Fisher distribution on the Stiefel manifold.
Its density function takes the form
</p>
<p style="text-align: center;"><code class="reqn">f(\boldsymbol{\beta_{t+1}} ) = \frac{ \mathrm{etr} \left\{ \boldsymbol{D} \boldsymbol{\beta}_{t}' \boldsymbol{\beta_{t+1}} \right\} }{ _{0}F_1 (\frac{p}{2}; \frac{1}{4}\boldsymbol{D}^2 ) }</code>
</p>

<p>where <code class="reqn">\mathrm{etr}</code> denotes <code class="reqn">\mathrm{exp}(\mathrm{tr}())</code>,
and <code class="reqn">_{0}F_1 (\frac{p}{2}; \frac{1}{4}\boldsymbol{D}^2 )</code> is the (0,1)-type hypergeometric function for matrix.
</p>
<p>Note that the function does not add intercept automatically.
</p>


<h3>Value</h3>

<p>A list containing the sampled data and the dynamics of beta.
</p>
<p>The object is a list containing the following components:
</p>
<table>
<tr><td><code>dData</code></td>
<td>
<p>a data.frame of the sampled data</p>
</td></tr>
<tr><td><code>aBeta</code></td>
<td>
<p>an array of the <code class="reqn">\boldsymbol{\beta}_t</code> with the dimension <code class="reqn">T \times q_1 \times r</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Yukai Yang, <a href="mailto:yukai.yang@statistik.uu.se">yukai.yang@statistik.uu.se</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
iT = 50
ip = 2
ir = 1
iqx =3
iqz=2
ik = 1

if(iqx==0) mX=NULL else mX = matrix(rnorm(iT*iqx),iT, iqx)
if(iqz==0) mZ=NULL else mZ = matrix(rnorm(iT*iqz),iT, iqz)
if(ik==0) mY=NULL else mY = matrix(0, ik, ip)

alpha = matrix(c(runif_sm(num=1,ip=ip,ir=ir)), ip, ir)
beta_0 = matrix(c(runif_sm(num=1,ip=ip*ik+iqx,ir=ir)), ip*ik+iqx, ir)
if(ip*ik+iqz==0) mB=NULL else mB = matrix(c(runif_sm(num=1,ip=(ip*ik+iqz)*ip,ir=1)), ip, ip*ik+iqz)
vD = 50

ret = SimModel2(iT=iT, mX=mX, mZ=mZ, mY=mY, alpha=alpha, beta_0=beta_0, mB=mB, vD=vD)

</code></pre>

<hr>
<h2 id='SMFilter'>SMFilter: a package implementing the filtering algorithms for the state-space models on the Stiefel manifold.</h2><span id='topic+SMFilter'></span><span id='topic+SMFilter-package'></span>

<h3>Description</h3>

<p>The package implements the filtering algorithms for the state-space models on the Stiefel manifold.
It also implements sampling algorithms for uniform, vector Langevin-Bingham and matrix Langevin-Bingham distributions on the Stiefel manifold.
</p>


<h3>Details</h3>

<p>Two types of the state-space models on the Stiefel manifold are considered.
</p>
<p>The type one model on Stiefel manifold takes the form:
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol{y}_t \quad = \quad \boldsymbol{\alpha}_t \boldsymbol{\beta} ' \boldsymbol{x}_t + \boldsymbol{B} \boldsymbol{z}_t + \boldsymbol{\varepsilon}_t</code>
</p>

<p style="text-align: center;"><code class="reqn">\boldsymbol{\alpha}_{t+1} | \boldsymbol{\alpha}_{t} \quad \sim \quad ML (p, r, \boldsymbol{\alpha}_{t} \boldsymbol{D})</code>
</p>

<p>where <code class="reqn">\boldsymbol{y}_t</code> is a <code class="reqn">p</code>-vector of the dependent variable,
<code class="reqn">\boldsymbol{x}_t</code> and <code class="reqn">\boldsymbol{z}_t</code> are explanatory variables wit dimension <code class="reqn">q_1</code> and <code class="reqn">q_2</code>,
<code class="reqn">\boldsymbol{x}_t</code> and <code class="reqn">\boldsymbol{z}_t</code> have no overlap,
matrix <code class="reqn">\boldsymbol{B}</code> is the coefficients for <code class="reqn">\boldsymbol{z}_t</code>,
<code class="reqn">\boldsymbol{\varepsilon}_t</code> is the error vector.
</p>
<p>The matrices <code class="reqn">\boldsymbol{\alpha}_t</code> and <code class="reqn">\boldsymbol{\beta}</code> have dimensions <code class="reqn">p \times r</code> and <code class="reqn">q_1 \times r</code>, respectively.
Note that <code class="reqn">r</code> is strictly smaller than both <code class="reqn">p</code> and <code class="reqn">q_1</code>.
<code class="reqn">\boldsymbol{\alpha}_t</code> and <code class="reqn">\boldsymbol{\beta}</code> are both non-singular matrices.
<code class="reqn">\boldsymbol{\alpha}_t</code> is time-varying while <code class="reqn">\boldsymbol{\beta}</code> is time-invariant.
</p>
<p>Furthermore, <code class="reqn">\boldsymbol{\alpha}_t</code> fulfills the condition <code class="reqn">\boldsymbol{\alpha}_t' \boldsymbol{\alpha}_t = \boldsymbol{I}_r</code>,
and therefor it evolves on the Stiefel manifold.
</p>
<p><code class="reqn">ML (p, r, \boldsymbol{\alpha}_{t} \boldsymbol{D})</code> denotes the Matrix Langevin distribution or matrix von Mises-Fisher distribution on the Stiefel manifold.
Its density function takes the form
</p>
<p style="text-align: center;"><code class="reqn">f(\boldsymbol{\alpha_{t+1}} ) = \frac{ \mathrm{etr} \left\{ \boldsymbol{D} \boldsymbol{\alpha}_{t}' \boldsymbol{\alpha_{t+1}} \right\} }{ _{0}F_1 (\frac{p}{2}; \frac{1}{4}\boldsymbol{D}^2 ) }</code>
</p>

<p>where <code class="reqn">\mathrm{etr}</code> denotes <code class="reqn">\mathrm{exp}(\mathrm{tr}())</code>,
and <code class="reqn">_{0}F_1 (\frac{p}{2}; \frac{1}{4}\boldsymbol{D}^2 )</code> is the (0,1)-type hypergeometric function for matrix.
</p>
<p>The type two model on Stiefel manifold takes the form:
</p>
<p style="text-align: center;"><code class="reqn">\boldsymbol{y}_t \quad = \quad \boldsymbol{\alpha} \boldsymbol{\beta}_t ' \boldsymbol{x}_t + \boldsymbol{B}' \boldsymbol{z}_t + \boldsymbol{\varepsilon}_t</code>
</p>

<p style="text-align: center;"><code class="reqn">\boldsymbol{\beta}_{t+1} | \boldsymbol{\beta}_{t} \quad \sim \quad ML (q_1, r, \boldsymbol{\beta}_{t} \boldsymbol{D})</code>
</p>

<p>where <code class="reqn">\boldsymbol{y}_t</code> is a <code class="reqn">p</code>-vector of the dependent variable,
<code class="reqn">\boldsymbol{x}_t</code> and <code class="reqn">\boldsymbol{z}_t</code> are explanatory variables wit dimension <code class="reqn">q_1</code> and <code class="reqn">q_2</code>,
<code class="reqn">\boldsymbol{x}_t</code> and <code class="reqn">\boldsymbol{z}_t</code> have no overlap,
matrix <code class="reqn">\boldsymbol{B}</code> is the coefficients for <code class="reqn">\boldsymbol{z}_t</code>,
<code class="reqn">\boldsymbol{\varepsilon}_t</code> is the error vector.
</p>
<p>The matrices <code class="reqn">\boldsymbol{\alpha}</code> and <code class="reqn">\boldsymbol{\beta}_t</code> have dimensions <code class="reqn">p \times r</code> and <code class="reqn">q_1 \times r</code>, respectively.
Note that <code class="reqn">r</code> is strictly smaller than both <code class="reqn">p</code> and <code class="reqn">q_1</code>.
<code class="reqn">\boldsymbol{\alpha}</code> and <code class="reqn">\boldsymbol{\beta}_t</code> are both non-singular matrices.
<code class="reqn">\boldsymbol{\beta}_t</code> is time-varying while <code class="reqn">\boldsymbol{\alpha}</code> is time-invariant.
</p>
<p>Furthermore, <code class="reqn">\boldsymbol{\beta}_t</code> fulfills the condition <code class="reqn">\boldsymbol{\beta}_t' \boldsymbol{\beta}_t = \boldsymbol{I}_r</code>,
and therefor it evolves on the Stiefel manifold.
</p>
<p><code class="reqn">ML (p, r, \boldsymbol{\beta}_t \boldsymbol{D})</code> denotes the Matrix Langevin distribution or matrix von Mises-Fisher distribution on the Stiefel manifold.
Its density function takes the form
</p>
<p style="text-align: center;"><code class="reqn">f(\boldsymbol{\beta_{t+1}} ) = \frac{ \mathrm{etr} \left\{ \boldsymbol{D} \boldsymbol{\beta}_{t}' \boldsymbol{\beta_{t+1}} \right\} }{ _{0}F_1 (\frac{p}{2}; \frac{1}{4}\boldsymbol{D}^2 ) }</code>
</p>

<p>where <code class="reqn">\mathrm{etr}</code> denotes <code class="reqn">\mathrm{exp}(\mathrm{tr}())</code>,
and <code class="reqn">_{0}F_1 (\frac{p}{2}; \frac{1}{4}\boldsymbol{D}^2 )</code> is the (0,1)-type hypergeometric function for matrix.
</p>


<h3>Author and Maintainer</h3>

<p>Yukai Yang
</p>
<p>Department of Statistics, Uppsala University
</p>
<p><a href="mailto:yukai.yang@statistik.uu.se">yukai.yang@statistik.uu.se</a>
</p>


<h3>References</h3>

<p>Yang, Yukai and Bauwens, Luc. (2018) &quot;<a href="https://www.mdpi.com/2225-1146/6/4/48">State-Space Models on the Stiefel Manifold with a New Approach to Nonlinear Filtering</a>&quot;, Econometrics, 6(4), 48.
</p>


<h3>Simulation</h3>

<p><code><a href="#topic+SimModel1">SimModel1</a></code> simulate from the type one state-space model on the Stiefel manifold.
</p>
<p><code><a href="#topic+SimModel2">SimModel2</a></code> simulate from the type two state-space model on the Stiefel manifold.
</p>


<h3>Filtering</h3>

<p><code><a href="#topic+FilterModel1">FilterModel1</a></code> filtering algorithm for the type one model.
</p>
<p><code><a href="#topic+FilterModel2">FilterModel2</a></code> filtering algorithm for the type two model.
</p>


<h3>Sampling</h3>

<p><code><a href="#topic+runif_sm">runif_sm</a></code> sample from the uniform distribution on the Stiefel manifold.
</p>
<p><code><a href="#topic+rvlb_sm">rvlb_sm</a></code> sample from the vector Langevin-Bingham distribution on the Stiefel manifold.
</p>
<p><code><a href="#topic+rmLB_sm">rmLB_sm</a></code> sample from the matrix Langevin-Bingham distribution on the Stiefel manifold.
</p>


<h3>Other Functions</h3>

<p><code><a href="#topic+version">version</a></code> shows the version number and some information of the package.
</p>

<hr>
<h2 id='version'>Show the version number of some information.</h2><span id='topic+version'></span>

<h3>Description</h3>

<p>This function shows the version number and some information of the package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>version()
</code></pre>


<h3>Author(s)</h3>

<p>Yukai Yang, <a href="mailto:yukai.yang@statistik.uu.se">yukai.yang@statistik.uu.se</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
