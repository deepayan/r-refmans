<!DOCTYPE html><html><head><title>Help for package GEOmap</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {GEOmap}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#GEOmap-package'>
<p>Topographic and Geologic Mapping</p></a></li>
<li><a href='#addLLXY'><p>Add Lat-Lon points using projection</p></a></li>
<li><a href='#addTIX'><p>Add Tic marks to map</p></a></li>
<li><a href='#along.great'><p>Along A great Arc</p></a></li>
<li><a href='#antipolygon'><p>Fill the complement of a polygon</p></a></li>
<li><a href='#BASICTOPOMAP'><p>Basic Topogrpahy Map</p></a></li>
<li><a href='#bcars'><p>Plot Box Cars</p></a></li>
<li><a href='#boundGEOmap'><p>Set Bounds for GEOmap</p></a></li>
<li><a href='#CCcheck'><p>Counter Clockwise check</p></a></li>
<li><a href='#ccw'><p>Counter Clockwise Whorl</p></a></li>
<li><a href='#coastmap'><p>Global Coast Map</p></a></li>
<li><a href='#darc'><p>Circular Arc</p></a></li>
<li><a href='#DATUMinfo'><p>Datum information.</p></a></li>
<li><a href='#demcmap'><p>Color Map from DEM</p></a></li>
<li><a href='#difflon'><p>Difference between Longitudes</p></a></li>
<li><a href='#distaz'><p>Distance and Azimuth from two points</p></a></li>
<li><a href='#dms'><p>Convert decimal degrees to degree, minutes, seconds</p></a></li>
<li><a href='#DUMPLOC'><p>DUMP vectors to screen in list format</p></a></li>
<li><a href='#EHB.LLZ'><p>Earthquake Location Data</p></a></li>
<li><a href='#Ellipsoidal.Distance'><p>Ellipsoidal Distance</p></a></li>
<li><a href='#eqswath'><p>Extract a set of eathquakes in swath along a cross sectional line</p></a></li>
<li><a href='#ExcludeGEOmap'><p>Exclude GEOmap Strokes</p></a></li>
<li><a href='#expandbound'><p>Expand Bounds</p></a></li>
<li><a href='#explode'><p>Explode Points</p></a></li>
<li><a href='#ExplodeSymbols'><p>Explode symbols that overlap</p></a></li>
<li><a href='#faultdip'><p>Show Fault dip</p></a></li>
<li><a href='#faultperp'><p>Fault Perpendiculars</p></a></li>
<li><a href='#fixCoastwrap'><p>Correct the Wrapping problem</p></a></li>
<li><a href='#gclc'><p>Global to local coordinates</p></a></li>
<li><a href='#geoarea'><p>Area of Map objects</p></a></li>
<li><a href='#geoLEGEND'><p>Geological legend from GEOmap Structure</p></a></li>
<li><a href='#GEOmap.breakline'><p>Break a line at specified indeces into a list</p></a></li>
<li><a href='#GEOmap.breakpoly'><p>Break up a polygon</p></a></li>
<li><a href='#GEOmap.cat'><p>Concatenate Two GEOmaps</p></a></li>
<li><a href='#GEOmap.CombineStrokes'><p>Combine strokes in a GEOmap list</p></a></li>
<li><a href='#GEOmap.Extract'><p>Extract from GEOmap</p></a></li>
<li><a href='#GEOmap.list'><p>GEOmap to list</p></a></li>
<li><a href='#GEOsymbols'><p>GEOsymbols</p></a></li>
<li><a href='#GEOTOPO'><p>Topographic Plot of geographic region</p></a></li>
<li><a href='#getETOPO'><p>Get Subset ETOPO Digital elevation map</p></a></li>
<li><a href='#getGEOmap'><p>Get Geomap</p></a></li>
<li><a href='#getGEOperim'><p>Get Lat-Lon Perimeter</p></a></li>
<li><a href='#getgreatarc'><p>Great Circle Arc</p></a></li>
<li><a href='#getmagsize'><p>Earthquake Magnitude based on exponentional</p></a></li>
<li><a href='#getnicetix'><p>Nice Looking Lat-Lon pairs for plotting</p></a></li>
<li><a href='#getspline'><p>Get a spline curve along a set of points</p></a></li>
<li><a href='#getsplineG'><p>Get a spline curve along a set of points</p></a></li>
<li><a href='#GETXprofile'><p>Cross sectional profile through a digital elevation map</p></a></li>
<li><a href='#GLOB.XY'><p>Convert from GLOBAL LAT-LON to X-Y</p></a></li>
<li><a href='#GLOBE.ORTH'><p>Plot globe with orthogonal</p></a></li>
<li><a href='#GlobeView'><p>Global Plot</p></a></li>
<li><a href='#gmat'><p>Globe Rotation Matrix</p></a></li>
<li><a href='#goodticdivs'><p>Nice tic division</p></a></li>
<li><a href='#horseshoe'><p>Horseshoe Symbol</p></a></li>
<li><a href='#inpoly'><p>Test set of points for inside/outside polygon</p></a></li>
<li><a href='#insertNA'><p>Insert NA in a vector</p></a></li>
<li><a href='#insertvec'><p>Insert a set of values in a vector</p></a></li>
<li><a href='#inside'><p>Determine if point is inside polygon</p></a></li>
<li><a href='#insideGEOmapXY'><p>Get LAT-LON points that fall inside a map</p></a></li>
<li><a href='#jarea'>
<p>Area of closed polygon.</p></a></li>
<li><a href='#KINOUT'><p>Map inside-outside</p></a></li>
<li><a href='#lamaz.eqarea'><p>Lambert-Azimuthal Equal Area</p></a></li>
<li><a href='#LandSeaCol'><p>Land and Sea Colors</p></a></li>
<li><a href='#lcgc'><p>local coordinates to Global</p></a></li>
<li><a href='#linesGEOmapXY'><p>Add lines, points or text to GEOmap projected plot</p></a></li>
<li><a href='#Lintersect'><p>Finder intersection of lines</p></a></li>
<li><a href='#list.GEOmap'><p>List stroke points in a GEOmap</p></a></li>
<li><a href='#ll2xyz'><p>LAT-LON to xyz</p></a></li>
<li><a href='#Lll2xyz'><p>List Lat-Lon to cartesian XYZ</p></a></li>
<li><a href='#LLlabel'><p>Nice Lat-Lon Label</p></a></li>
<li><a href='#LLsmallcircMap'><p>World Map centered on Lat-Lon</p></a></li>
<li><a href='#LOCPOLIMAP'><p>LOCPOLIMAP</p></a></li>
<li><a href='#locworld'><p>Locate points in worlmap</p></a></li>
<li><a href='#Lxyz2ll'><p>Cartesian to Lat-Lon</p></a></li>
<li><a href='#MAPconstants'><p>Set Various Map Constants</p></a></li>
<li><a href='#maplim'><p>Map Limits</p></a></li>
<li><a href='#maps2GEOmap'><p>Convert maps data to GEOmap format</p></a></li>
<li><a href='#mapTeleSeis'><p>World Map with Teleseismic Ray-paths</p></a></li>
<li><a href='#Markup'><p>Add markup information to an existing plot</p></a></li>
<li><a href='#merid'><p>Orthogonal Projection of  Meridian or Parallel</p></a></li>
<li><a href='#niceLLtix'><p>Nice DMS coordinates</p></a></li>
<li><a href='#NoOverlap'><p>Shift Symbols</p></a></li>
<li><a href='#normalfault'><p>Normal Fault trace</p></a></li>
<li><a href='#NSarrow'><p>North-South Weather Vane Arrow</p></a></li>
<li><a href='#NSWath'><p>Cross sectional Swaths of Earthquakes over Japan</p></a></li>
<li><a href='#ortho.proj'><p>Orthogonal Map Projection</p></a></li>
<li><a href='#OverTurned'><p>Plot Overturned fault</p></a></li>
<li><a href='#perpen'><p>perpendicular marks  along line</p></a></li>
<li><a href='#pgon'><p>Plot regular polygon: pentagon, hexagon, octagon</p></a></li>
<li><a href='#pline'><p>Point to line distance</p></a></li>
<li><a href='#plotGEOmap'><p>Plot a GEO map</p></a></li>
<li><a href='#plotGEOmapXY'><p>Plot a projected GEO map</p></a></li>
<li><a href='#plothypos'><p>Plot Edicenters</p></a></li>
<li><a href='#plotnicetix'><p>Plot Lat-Lon tick marks</p></a></li>
<li><a href='#plotusa'><p>Map of USA</p></a></li>
<li><a href='#plotUTM'><p>Plot UTM</p></a></li>
<li><a href='#plotworldmap'><p>Plot World Map with UTM sections</p></a></li>
<li><a href='#PointsAlong'><p>Find spaced Points along a line</p></a></li>
<li><a href='#polyintern'><p>Internal point of polygon</p></a></li>
<li><a href='#printGEOinfo'><p>printGEOinfo</p></a></li>
<li><a href='#printGEOmap'><p>printGEOmap</p></a></li>
<li><a href='#projtype'><p>List of Projection types</p></a></li>
<li><a href='#rectPERIM'><p>Extract a rectangular perimeter</p></a></li>
<li><a href='#rekt2line'><p>Rectangle Line Overlap</p></a></li>
<li><a href='#rose'><p>Rose Diagram</p></a></li>
<li><a href='#rotateGEOmap'><p>Rotate a GEOmap</p></a></li>
<li><a href='#rotdelta4'><p>rotation about Z-axis</p></a></li>
<li><a href='#rotmat2D'><p>set a rotation matrix</p></a></li>
<li><a href='#rotx4'><p>x-axis rotation matrix</p></a></li>
<li><a href='#roty4'><p>y-axis rotation matrix</p></a></li>
<li><a href='#SELGEOmap'><p>Select parts of a GEOmap</p></a></li>
<li><a href='#setMarkup'><p>Set up mark up for maps</p></a></li>
<li><a href='#setplotmat'><p>set up matrices for selecting from eTOPO5</p></a></li>
<li><a href='#SETPOLIMAP'><p>Set up polygons for World map Database</p></a></li>
<li><a href='#setPROJ'><p>Set Projection</p></a></li>
<li><a href='#settopocol'><p>Topographic Color Map</p></a></li>
<li><a href='#sizelegend'><p>Magnitude size legend</p></a></li>
<li><a href='#sqrTICXY'><p>Tick marks for Square plot</p></a></li>
<li><a href='#SSfault'><p>Strike Slip Fault</p></a></li>
<li><a href='#STROKEinfo'><p>Stroke Information</p></a></li>
<li><a href='#subsetTOPO'><p>Subset a Topo map</p></a></li>
<li><a href='#SynAnticline'><p>Syncline and Anticline traces</p></a></li>
<li><a href='#targetLL'><p>Target Lat-Lon</p></a></li>
<li><a href='#teeth'><p>Add Teeth to line</p></a></li>
<li><a href='#thrust'><p>Thrust Fault</p></a></li>
<li><a href='#TOPOCOL'><p>Create Topography ColorMAP</p></a></li>
<li><a href='#trans4'><p>Translation matrix</p></a></li>
<li><a href='#UTM.ll'><p>Map projection</p></a></li>
<li><a href='#utm.sphr.ll'><p>Map projection</p></a></li>
<li><a href='#utm.sphr.xy'><p>Map projection</p></a></li>
<li><a href='#UTM.xy'><p>Map projection</p></a></li>
<li><a href='#utmbox'><p>Get UTM Box info</p></a></li>
<li><a href='#UTMzone'><p>UTM zone information</p></a></li>
<li><a href='#X.prod'><p>Cross Product</p></a></li>
<li><a href='#XSECDEMg'><p>Cross Sections Using RPMG</p></a></li>
<li><a href='#XSECEQ'><p>Iinteractive earthquake cross section</p></a></li>
<li><a href='#XSECwin'><p>Cross sectional plot with earthquakes projected</p></a></li>
<li><a href='#XY.GLOB'><p>Convert from XY to GLOBAL LAT-LON</p></a></li>
<li><a href='#xyz2ll'><p>Cartesian to Lat-Lon</p></a></li>
<li><a href='#zebra'><p>Horizontal Zebra Scale</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Topographic and Geologic Mapping</td>
</tr>
<tr>
<td>Version:</td>
<td>2.5-11</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-07-09</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>RPMG, fields, sf, MBA</td>
</tr>
<tr>
<td>Suggests:</td>
<td>geomapdata, maps</td>
</tr>
<tr>
<td>LazyData:</td>
<td>yes</td>
</tr>
<tr>
<td>Author:</td>
<td>Jonathan M. Lees [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Set of routines for making map projections (forward and inverse), topographic maps, perspective plots, geological maps, geological map symbols, geological databases, interactive plotting and selection of focus regions.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-07-09 16:02:55 UTC; lees</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-07-09 16:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='GEOmap-package'>
Topographic and Geologic Mapping
</h2><span id='topic+GEOmap-package'></span><span id='topic+GEOmap'></span>

<h3>Description</h3>

<p>Topographic and Geologic Mapping
</p>


<h3>Details</h3>

<p>Set of routines for making Map Projections (forward and inverse),
Topographic Maps, Perspective plots, geological databases,
interactive plotting and selection of focus regions.
</p>


<h3>Note</h3>


<dl>
<dt>High level plotting:</dt><dd>
<p>BASICTOPOMAP
DOTOPOMAPI
geoLEGEND
GEOsymbols
locworld
plotGEOmap
plotGEOmapXY
linesGEOmapXY
rectGEOmapXY
textGEOmapXY
pointsGEOmapXY
insideGEOmapXY
plotUTM
plotworldmap
XSECDEM</p>
</dd>
<dt>PLOTTING:</dt><dd>
<p>circle
addLLXY addTIX
antipolygon
zebra
demcmap
setXMCOL
shade.col</p>
</dd>
<dt>Geological Map Symbols:</dt><dd>
<p>bcars
faultdip
faultperp
horseshoe
normalfault 
OverTurned
perpen
teeth
thrust
SynAnticline
SSfault</p>
</dd>
<dt>Data manipulation:</dt><dd>
<p>getGEOmap
boundGEOmap
SELGEOmap
geoarea
GEOTOPO
getGEOperim
GETXprofile
Lintersect
LOCPOLIMAP
pline
selectPOLImap
setplotmat
SETPOLIMAP
settopocol
subsetTOPO</p>
</dd>
<dt>Misc:</dt><dd>
<p>getgreatarc
ccw
difflon
DUMPLOC
getsplineG
inpoly
inside
PointsAlong
polyintern</p>
</dd>
<dt>Projections:</dt><dd>
<p>setPROJ
projtype
GLOB.XY
XY.GLOB
MAPconstants
GCLCFR
lambert.cc.ll
lambert.cc.xy
lambert.ea.ll
lambert.ea.xy
lcgc
merc.sphr.ll
merc.sphr.xy
utmbox
utm.elps.ll
utm.elps.xy
utm.sphr.ll
utm.sphr.xy
stereo.sphr.ll
stereo.sphr.xy
equid.cyl.ll
equid.cyl.xy</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;
Maintainer:Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Snyder, John P., Map Projections- a working manual, USGS, Professional Paper, 1987.
</p>
<p>Lees, J. M., Geotouch: Software for Three and Four Dimensional GIS in the Earth Sciences, Computers &amp; Geosciences, 26, 7, 751-761, 2000.
</p>


<h3>See Also</h3>

<p>RSEIS
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

################  projections
proj = setPROJ(type = 2, LAT0 =23, LON0 = 35)

### get lat-lon
LL = XY.GLOB(200, 300, proj)


##  find x-y again, should be the same
XY = GLOB.XY(LL$lat, LL$lon, proj)
XY
################
library(geomapdata)
data(worldmap)
  KAMlat = c(48.5,  65)
    KAMlon = c(150, 171)
    
    PLOC=list(LON=KAMlon,LAT=KAMlat)


    PLON = seq(from=KAMlon[1], to=KAMlon[2], by=2)
    PLAT = seq(from=KAMlat[1], to=KAMlat[2], by=2)
    
    proj = setPROJ(2, LON0=mean(KAMlon), LAT0=mean(KAMlat))

 xy = GLOB.XY(KAMlat,  KAMlon , proj)
 kbox=list(x=range(xy$x, na.rm=TRUE), y=range(xy$y, na.rm=TRUE))

 plot(kbox$x,kbox$y, type='n', axes=FALSE, xlab="", ylab="", asp=1)
   plotGEOmapXY(worldmap, LIM=c(KAMlon[1], KAMlat[1], KAMlon[2],
KAMlat[2]),  add=TRUE, PROJ=proj, axes=FALSE, xlab="", ylab="" )

sqrTICXY(kbox , proj, side=c(1,2,3,4), LLgrid=TRUE, col=grey(.7) )
title("Crude Map of Kamchatka")
   
    
</code></pre>

<hr>
<h2 id='addLLXY'>Add Lat-Lon points using projection</h2><span id='topic+addLLXY'></span>

<h3>Description</h3>

<p>Add Lat-Lon points using projection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addLLXY(lats, lons, PROJ = PROJ, PMAT = NULL,
col = gray(0.7), GRID = TRUE, GRIDcol = 1, LABS = NULL,
LABcol = 1, BORDER = NULL, TICS = c(1, 1), xpd=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addLLXY_+3A_lats">lats</code></td>
<td>
<p>Latitudes in Degrees</p>
</td></tr>
<tr><td><code id="addLLXY_+3A_lons">lons</code></td>
<td>
<p>Longitude in  Degrees</p>
</td></tr>
<tr><td><code id="addLLXY_+3A_proj">PROJ</code></td>
<td>
<p>Map Projection list</p>
</td></tr>
<tr><td><code id="addLLXY_+3A_pmat">PMAT</code></td>
<td>
<p>Perspective matrix conversion</p>
</td></tr>
<tr><td><code id="addLLXY_+3A_col">col</code></td>
<td>
<p>color</p>
</td></tr>
<tr><td><code id="addLLXY_+3A_grid">GRID</code></td>
<td>
<p>logical, TRUE=add grid lines</p>
</td></tr>
<tr><td><code id="addLLXY_+3A_gridcol">GRIDcol</code></td>
<td>
<p>color for grid lines</p>
</td></tr>
<tr><td><code id="addLLXY_+3A_labs">LABS</code></td>
<td>
<p>vector of labels</p>
</td></tr>
<tr><td><code id="addLLXY_+3A_labcol">LABcol</code></td>
<td>
<p>color for labels</p>
</td></tr>
<tr><td><code id="addLLXY_+3A_border">BORDER</code></td>
<td>
<p>add border</p>
</td></tr>
<tr><td><code id="addLLXY_+3A_tics">TICS</code></td>
<td>
<p>tick marks</p>
</td></tr>
<tr><td><code id="addLLXY_+3A_xpd">xpd</code></td>
<td>
<p>logical, expand plotting region (see par)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Graphical Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>plotGEOmapXY, sqrTICXY</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(geomapdata)


data('fujitopo', package='geomapdata')
data('japmap', package='geomapdata')

PLOC=list(LON=range(c( japmap$STROKES$LON1,japmap$STROKES$LON2) ),
LAT=range(c( japmap$STROKES$LAT1,japmap$STROKES$LAT2) ))
PLOC$x = PLOC$LON
PLOC$y = PLOC$LAT

PROJ = setPROJ(type=2, LAT0=mean(PLOC$y) , LON0=mean(PLOC$x) )
isel1 = which( japmap$STROKES$code != "i" &amp; japmap$STROKES$num&gt;120 )


plotGEOmapXY(japmap, PROJ=PROJ,SEL=isel1,  add=FALSE, axes=FALSE, xlab="", ylab="")
A = PLOC

   PLAT =  pretty(A$LAT)
    PLAT = c(min(A$LAT),  PLAT[PLAT&gt;min(A$LAT) &amp; PLAT&lt;max(A$LAT)],max(A$LAT)) 
  PLON  = pretty(A$LON)
        PLON = c(min(A$LON), PLON[PLON&gt;min(A$LON) &amp; PLON&lt;max(A$LON)],
 max(A$LON))


addLLXY(PLAT,  PLON, PROJ=PROJ, LABS=TRUE, PMAT=NULL, TICS=c(.1,.1) )

###############


</code></pre>

<hr>
<h2 id='addTIX'>Add Tic marks to map</h2><span id='topic+addTIX'></span>

<h3>Description</h3>

<p>Add Tic marks to map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>addTIX(lats, lons, PROJ = list(), PMAT = NULL,
col = gray(0.7), TICS = c(1, 1), OUTER = TRUE,
sides = c(1, 2, 3, 4))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="addTIX_+3A_lats">lats</code></td>
<td>
<p>Latitudes in Degrees</p>
</td></tr>
<tr><td><code id="addTIX_+3A_lons">lons</code></td>
<td>
<p>Longitude in  Degrees</p>
</td></tr>
<tr><td><code id="addTIX_+3A_proj">PROJ</code></td>
<td>
<p>Map Projection list </p>
</td></tr>
<tr><td><code id="addTIX_+3A_pmat">PMAT</code></td>
<td>
<p>Perspective matrix conversion</p>
</td></tr>
<tr><td><code id="addTIX_+3A_col">col</code></td>
<td>
<p>color</p>
</td></tr>
<tr><td><code id="addTIX_+3A_tics">TICS</code></td>
<td>
<p>tic labels</p>
</td></tr>
<tr><td><code id="addTIX_+3A_outer">OUTER</code></td>
<td>
<p>logical</p>
</td></tr>
<tr><td><code id="addTIX_+3A_sides">sides</code></td>
<td>
<p>sides, 1,2,3,4</p>
</td></tr>
</table>


<h3>Details</h3>

<p>attempts to make correct default values
</p>


<h3>Value</h3>

<p>Graphical Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>addLLXY</p>


<h3>Examples</h3>

<pre><code class='language-R'>
##########3  this program is run internally


PLOC=list(LON=c(137.008, 141.000),
LAT=c(34.000, 36.992),
x=c(137.008, 141.000),
y=c(34.000, 36.992))

PROJ = setPROJ(type=2, LAT0=mean(PLOC$y) , LON0=mean(PLOC$x) )

gxy = GLOB.XY(PLOC$LAT, PLOC$LON, PROJ)

PLAT =  pretty(PLOC$LAT)

PLAT = c(min(PLOC$LAT),PLAT[PLAT&gt;min(PLOC$LAT)&amp;PLAT&lt;max(PLOC$LAT)],max(PLOC$LAT)) 

PLON  = pretty(PLOC$LON)

PLON = c(min(PLOC$LON), PLON[PLON&gt;min(PLOC$LON)&amp;PLON&lt;max(PLOC$LON)], max(PLOC$LON))
     

plot(gxy$x, gxy$y,  asp=TRUE)

 addTIX(PLAT, PLON, PMAT=NULL, col='red', TICS=c(.1,.1), PROJ=PROJ)




   

</code></pre>

<hr>
<h2 id='along.great'>Along A great Arc</h2><span id='topic+along.great'></span>

<h3>Description</h3>

<p>Calculate points along a great arc
</p>


<h3>Usage</h3>

<pre><code class='language-R'>along.great(phi1, lam0, c, Az)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="along.great_+3A_phi1">phi1</code></td>
<td>
<p>start lat, radians</p>
</td></tr>
<tr><td><code id="along.great_+3A_lam0">lam0</code></td>
<td>
<p>start lon, radians</p>
</td></tr>
<tr><td><code id="along.great_+3A_c">c</code></td>
<td>
<p>distance, radians</p>
</td></tr>
<tr><td><code id="along.great_+3A_az">Az</code></td>
<td>
<p>Azimuthal direction, radiansm  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>All input and output is radians
</p>


<h3>Value</h3>

<p>List:
</p>
<table>
<tr><td><code>phi</code></td>
<td>
<p>latitudes, radians</p>
</td></tr>
<tr><td><code>lam</code></td>
<td>
<p>longitudes, radians</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>lat1 &lt;- 48.856578
lon1 &lt;- 2.351828	

A = along.great(lat1*pi/180, lon1*pi/180, 50*pi/180, -63*pi/180)

lat=A$phi*180/pi
lon = A$lam*180/pi


</code></pre>

<hr>
<h2 id='antipolygon'>Fill the complement of a polygon</h2><span id='topic+antipolygon'></span>

<h3>Description</h3>

<p>Fill a plot with a color outside the confines of a polygon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>antipolygon(x, y, col = 0, corner=1, pct=.4)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="antipolygon_+3A_x">x</code></td>
<td>
<p>x coordinates of polygon</p>
</td></tr>
<tr><td><code id="antipolygon_+3A_y">y</code></td>
<td>
<p>y coordinates of polygon</p>
</td></tr>
<tr><td><code id="antipolygon_+3A_col">col</code></td>
<td>
<p>Fill color</p>
</td></tr>
<tr><td><code id="antipolygon_+3A_corner">corner</code></td>
<td>
<p>Corner on the plot to connect to at the end: 1 =
LowerLeft(default) ; 2:UpperLeft 3 = UpperRight; 4=LowerRight</p>
</td></tr>
<tr><td><code id="antipolygon_+3A_pct">pct</code></td>
<td>
<p>Decimal percent of usr coordinates to expand beyond the polygon</p>
</td></tr>
</table>


<h3>Details</h3>

<p>antipolygon uses par(&quot;usr&quot;) to determine the external bounds of
plotting region.
Corners are labels from bottom left  counter-clockwise, 1-4.
</p>


<h3>Value</h3>

<p>List:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p> x-coordinates of mask </p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p> y-coordinates of mask </p>
</td></tr>			
</table>
<p>Used for graphical side effect	  
</p>


<h3>Note</h3>

<p>If the figure is resized after plotting, filling may not appear correct.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>polygon, par</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(2018)
x = runif(100)
y = runif(100)

#########  some data points to plot:

plot(x,y)
###########   create polygon:
pp =list(x=c(0.231,0.316,0.169,0.343,0.311,0.484,0.757,
         0.555,0.800,0.563,0.427,0.412,0.203),
     y=c(0.774,0.622,0.401,0.386,0.138,0.312,0.200,0.459,
        0.658,0.624,0.954,0.686,0.813))

polygon(pp)

antipolygon(x=pp$x, y=pp$y,col='blue')
####  where as this does not look so good
plot(x,y)
antipolygon(x=pp$x, y=pp$y,col='blue', corner=2)



</code></pre>

<hr>
<h2 id='BASICTOPOMAP'>Basic Topogrpahy Map</h2><span id='topic+BASICTOPOMAP'></span>

<h3>Description</h3>

<p>Basic Topogrpahy Map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>BASICTOPOMAP(xo, yo, DOIMG, DOCONT, UZ, AZ, IZ, perim, PLAT, PLON,
PROJ = PROJ, pnts = NULL, GRIDcol = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="BASICTOPOMAP_+3A_xo">xo</code></td>
<td>
<p>vector of x-coordinates</p>
</td></tr>
<tr><td><code id="BASICTOPOMAP_+3A_yo">yo</code></td>
<td>
<p>vector of y-coordinates</p>
</td></tr>
<tr><td><code id="BASICTOPOMAP_+3A_doimg">DOIMG</code></td>
<td>
<p>logical, add image</p>
</td></tr>
<tr><td><code id="BASICTOPOMAP_+3A_docont">DOCONT</code></td>
<td>
<p>logical, add contours</p>
</td></tr>
<tr><td><code id="BASICTOPOMAP_+3A_uz">UZ</code></td>
<td>
<p>matrix of image values under  sea level</p>
</td></tr>
<tr><td><code id="BASICTOPOMAP_+3A_az">AZ</code></td>
<td>
<p>matrix of image values above sea level</p>
</td></tr>
<tr><td><code id="BASICTOPOMAP_+3A_iz">IZ</code></td>
<td>
<p>matrix of image values</p>
</td></tr>
<tr><td><code id="BASICTOPOMAP_+3A_perim">perim</code></td>
<td>
<p>perimeter vectors</p>
</td></tr>
<tr><td><code id="BASICTOPOMAP_+3A_plat">PLAT</code></td>
<td>
<p>latitudes for tic-marks</p>
</td></tr>
<tr><td><code id="BASICTOPOMAP_+3A_plon">PLON</code></td>
<td>
<p>longitude for tic-marks</p>
</td></tr>
<tr><td><code id="BASICTOPOMAP_+3A_proj">PROJ</code></td>
<td>
<p>projection list</p>
</td></tr>
<tr><td><code id="BASICTOPOMAP_+3A_pnts">pnts</code></td>
<td>
<p>points to add to plot</p>
</td></tr>
<tr><td><code id="BASICTOPOMAP_+3A_gridcol">GRIDcol</code></td>
<td>
<p>color for grid</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Image is processed prior to calling 
</p>


<h3>Value</h3>

<p>Graphical Side effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>DOTOPOMAPI, GEOTOPO</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 


library(geomapdata)
library(MBA) ##  for interpolation
#######  set up topo data
data(fujitopo)
#####  set up map data
data('japmap', package='geomapdata' )


###  target region
PLOC= list(LON=c(138.3152, 139.0214), 
LAT=c(35.09047, 35.57324))

PLOC$x =PLOC$LON
PLOC$y =PLOC$LAT



####  set up projection
PROJ = setPROJ(type=2, LAT0=mean(PLOC$y) , LON0=mean(PLOC$x) )

##########  select data from the topo data internal to the target
    topotemp = list(lon=fujitopo$lon, lat= fujitopo$lat, z=fujitopo$z)

    
 ####  project target
  A = GLOB.XY(PLOC$LAT  , PLOC$LON ,  PROJ)

#######   select topo
selectionflag = topotemp$lat&gt;+PLOC$LAT[1] &amp; topotemp$lat&lt;=PLOC$LAT[2] &amp;
topotemp$lon&gt;+PLOC$LON[1] &amp; topotemp$lon&lt;=PLOC$LON[2]


###  project topo data
  B = GLOB.XY( topotemp$lat[selectionflag] ,topotemp$lon[selectionflag] ,  PROJ)

###  set up out put matrix:
### xo = seq(from=range(A$x)[1], to=range(A$x)[2], length=200)
###    yo = seq(from=range(A$y)[1], to=range(A$y)[2], length=200)

#######  interpolation using akima
  ###  IZ = interp(x=B$x , y=B$y,  z=topotemp$z[selectionflag]  , xo=xo, yo=yo)
DF = cbind(x=B$x , y=B$y ,  z=topotemp$z[selectionflag])
 IZ = mba.surf(DF, 200, 200, extend=TRUE)$xyz.est

    xo = IZ[[1]]
    yo = IZ[[2]]


###  image(IZ)

#######  underwater section
    UZ = IZ$z
    UZ[IZ$z&gt;=0] = NA
#### above sea level
    AZ = IZ$z
    AZ[IZ$z&lt;=-.01] = NA

#### create perimeter:
    perim= getGEOperim(PLOC$LON, PLOC$LAT, PROJ, 50)

###  lats for tic marks:
    PLAT =  pretty(PLOC$LAT)

    PLAT = c(min(PLOC$LAT),
PLAT[PLAT&gt;min(PLOC$LAT) &amp; PLAT&lt;max(PLOC$LAT)],max(PLOC$LAT)) 
PLON  = pretty(PLOC$LON)

### main program:
 DOIMG = TRUE
DOCONT = TRUE
PNTS  = NULL

BASICTOPOMAP(xo, yo , DOIMG, DOCONT, UZ, AZ, IZ, perim, PLAT, PLON,
PROJ=PROJ, pnts=NULL, GRIDcol=NULL)


###  add in the map information
 plotGEOmapXY(japmap, LIM=c(PLOC$LON[1], PLOC$LAT[1],PLOC$LON[2],
PLOC$LAT[2]) , PROJ=PROJ, add=TRUE )


## End(Not run)


</code></pre>

<hr>
<h2 id='bcars'>Plot Box Cars</h2><span id='topic+bcars'></span>

<h3>Description</h3>

<p>Add Box Cars to a line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bcars(x, y, h1 = 1, h2 = 0.3, rot, col = "black", border = "black")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bcars_+3A_x">x</code></td>
<td>
<p>x-coordinates</p>
</td></tr>
<tr><td><code id="bcars_+3A_y">y</code></td>
<td>
<p>y-coordinates</p>
</td></tr>
<tr><td><code id="bcars_+3A_h1">h1</code></td>
<td>
<p>length, mm</p>
</td></tr>
<tr><td><code id="bcars_+3A_h2">h2</code></td>
<td>
<p>thickness, mm</p>
</td></tr>
<tr><td><code id="bcars_+3A_rot">rot</code></td>
<td>
<p>rotation vectors, (cosines and sines)</p>
</td></tr>
<tr><td><code id="bcars_+3A_col">col</code></td>
<td>
<p>color</p>
</td></tr>
<tr><td><code id="bcars_+3A_border">border</code></td>
<td>
<p>color</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used for plotting detachment faults in USGS format.
</p>


<h3>Value</h3>

<p>Graphical Side effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>G=list()
G$x=c(-1.0960,-0.9942,-0.8909,-0.7846,-0.6738,-0.5570,-0.4657,-0.3709,
-0.2734,-0.1740,-0.0734, 0.0246, 0.1218, 0.2169, 0.3086, 0.3956, 0.4641, 
0.5293, 0.5919, 0.6530, 0.7131)
G$y=c(-0.72392,-0.62145,-0.52135,-0.42599,-0.33774,-0.25896,-0.20759,
-0.16160,-0.11981,-0.08105,-0.04414,-0.00885, 0.02774, 0.06759, 0.11262, 
0.16480, 0.21487, 0.27001, 0.32895, 0.39044, 0.45319)



 g = PointsAlong(G$x, G$y, N=6)

 sk = 3

###############
plot(G$x, G$y, type='n',asp=1, axes=FALSE, xlab='', ylab='')

 lines(G$x,G$y,col='blue')
 bcars(g$x,g$y,h1=sk,h2=sk*.5, rot=g$rot , col='blue')


###############
plot(G$x, G$y, type='n',asp=1, axes=FALSE, xlab='', ylab='')
 lines(G$x,G$y,col='blue')
 bcars(g$x,g$y,h1=sk,h2=sk*.5, rot=g$rot , col=NA, border='blue')



</code></pre>

<hr>
<h2 id='boundGEOmap'>Set Bounds for GEOmap</h2><span id='topic+boundGEOmap'></span>

<h3>Description</h3>

<p>Given a GEOmap strucutre, set the bounds for the strokes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>boundGEOmap(MAP, NEGLON = FALSE, projtype = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="boundGEOmap_+3A_map">MAP</code></td>
<td>
<p>GEOmap structure</p>
</td></tr>
<tr><td><code id="boundGEOmap_+3A_neglon">NEGLON</code></td>
<td>
<p>whether to allow negative longitudes</p>
</td></tr>
<tr><td><code id="boundGEOmap_+3A_projtype">projtype</code></td>
<td>
<p>suggestion (local) map projection to use when getting bounds</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used to rectify a new map after reading in from ascii
file.  Can take GMT map ascii map files and convert to GEOmap.
</p>


<h3>Value</h3>

<p>List structure:
</p>
<table>
<tr><td><code>STROKES</code></td>
<td>
<p>list(nam, num, index, col, style, code, LAT1, LAT2, LON1, LON2)</p>
</td></tr>
<tr><td><code>POINTS</code></td>
<td>
<p>list(lat, lon)</p>
</td></tr>
<tr><td><code>PROJ</code></td>
<td>
<p>list(type, LAT0, LON0, LAT1, LAT2, LATS, LONS, DLAT, DLON, FE, FN, name)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>worldmap</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(geomapdata)
data(worldmap)
worldmap = boundGEOmap(worldmap)



</code></pre>

<hr>
<h2 id='CCcheck'>Counter Clockwise check</h2><span id='topic+CCcheck'></span>

<h3>Description</h3>

<p>Check for counter-clockwise orientation
for polygons.  Positive is counterclockwise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>CCcheck(Z)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="CCcheck_+3A_z">Z</code></td>
<td>
<p>list(x,y) </p>
</td></tr>
</table>


<h3>Details</h3>

<p> Uses sign of the area of the polygon to determine
polarity.
</p>


<h3>Value</h3>

<table>
<tr><td><code>j</code></td>
<td>
<p>sign of area</p>
</td></tr> 
</table>


<h3>Note</h3>

<p>Based on the idea calculated area of a polygon.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>

Y=list()
Y$x=c(170,175,184,191,194,190,177,166,162,164)
Y$y=c(-54,-60,-60,-50,-26,8,34,37,10,-15)

plot(c(160, 200),c(-85, 85), type='n')
points(Y)
lines(Y)

CCcheck(Y)


Z = list(x=rev(Y$x), y=rev(Y$y))

CCcheck(Z)

</code></pre>

<hr>
<h2 id='ccw'>Counter Clockwise Whorl</h2><span id='topic+ccw'></span>

<h3>Description</h3>

<p>Used for determining if points are in polygons.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ccw(p0, p1, p2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ccw_+3A_p0">p0</code></td>
<td>
<p>point 0 </p>
</td></tr>
<tr><td><code id="ccw_+3A_p1">p1</code></td>
<td>
<p>point 1  </p>
</td></tr>
<tr><td><code id="ccw_+3A_p2">p2</code></td>
<td>
<p>point 2   </p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns 1 or 0 depending on position of points
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>Lintersect</p>


<h3>Examples</h3>

<pre><code class='language-R'>
l1 = list(p1=list(x=0, y=0), p2=list(x=1,y=1))
l2 = list(p1=list(x=6, y=4), p2=list(x=-1,y=-12))

ccw(l1$p1, l1$p2, l2$p1)


</code></pre>

<hr>
<h2 id='coastmap'>Global Coast Map</h2><span id='topic+coastmap'></span>

<h3>Description</h3>

<p>Global Maps of Coast 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(coastmap)</code></pre>


<h3>Format</h3>

<p>List structure:
</p>

<dl>
<dt>STROKES</dt><dd><p>list(nam, num, index, col, style, code, LAT1, LAT2, LON1, LON2)</p>
</dd>
<dt>POINTS</dt><dd><p>list(lat, lon)</p>
</dd>
<dt>PROJ</dt><dd><p>list(type, LAT0, LON0, LAT1, LAT2, LATS, LONS, DLAT, DLON, FE, FN, name)</p>
</dd>
</dl>



<h3>Details</h3>

<p>This map list is used for filling in coastal lines for global maps.
The style=3 is for filling in polygons.  The strokes are named
for easier access to particular parts ofthe globe.
Asia and Africa are one stroke, as are North and South America.
there are currently three codes: C=major coast,  c=smaller coasts,
L=interior lakes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(coastmap)
#######  see the codes:
unique(coastmap$STROKES$code)
#########  see the different names:
unique(coastmap$STROKES$nam)

#########  change the colors based on code
coastmap$STROKES$col[coastmap$STROKES$code=="C" ] = rgb(1, .6, .6)
coastmap$STROKES$col[coastmap$STROKES$code=="c" ] = rgb(1, .9, .9)
coastmap$STROKES$col[coastmap$STROKES$code=="L" ] = rgb(.6, .6, 1)

plotGEOmap(coastmap , border='black' , add=FALSE, xaxs='i')





##
</code></pre>

<hr>
<h2 id='darc'>Circular Arc
</h2><span id='topic+darc'></span>

<h3>Description</h3>

<p>Draw acircular arc
from angle 1 to angle 2 at a given location.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>darc(rad = 1, ang1 = 0, ang2 = 360, x1 = 0, y1 = 0, n = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="darc_+3A_rad">rad</code></td>
<td>
<p>radius
</p>
</td></tr>
<tr><td><code id="darc_+3A_ang1">ang1</code></td>
<td>
<p>angle 1, degrees
</p>
</td></tr>
<tr><td><code id="darc_+3A_ang2">ang2</code></td>
<td>
<p>angle 2, degrees
</p>
</td></tr>
<tr><td><code id="darc_+3A_x1">x1</code></td>
<td>
<p>x location, plot coordinates
</p>
</td></tr>
<tr><td><code id="darc_+3A_y1">y1</code></td>
<td>
<p>y location, plot coordinates
</p>
</td></tr>
<tr><td><code id="darc_+3A_n">n</code></td>
<td>
<p>increment for number of segments, degrees
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If angle1 &gt; angle2 arc is drawn in opposite direction
</p>


<h3>Value</h3>

<p>list(x,y)
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot(c(0,1), c(0,1), type='n', ann=FALSE, asp=1)

A = darc(.3, 23, 47, .5, .5, n=1)

lines(A$x, A$y)



</code></pre>

<hr>
<h2 id='DATUMinfo'>Datum information.
</h2><span id='topic+DATUMinfo'></span>

<h3>Description</h3>

<p>Return a small data base of
Datum values for use in UTM projections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DATUMinfo()
</code></pre>


<h3>Details</h3>

<p>The function just return a list with the relavent information.
</p>


<h3>Value</h3>

<p>List:
</p>
<table>
<tr><td><code>Datum</code></td>
<td>
<p>character name</p>
</td></tr>
<tr><td><code>Equatorial Radius</code>, <code>meters (a)</code></td>
<td>
<p>numeric</p>
</td></tr>
<tr><td><code>Polar Radius</code>, <code>meters (b)</code></td>
<td>
<p>numeric</p>
</td></tr>
<tr><td><code>Flattening (a-b)/a</code></td>
<td>
<p>numeric</p>
</td></tr>
<tr><td><code>Use</code></td>
<td>
<p>character  usage</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>stevedutch.net
</p>


<h3>See Also</h3>

<p>UTM.xy, UTM.ll, setPROJ
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
h = DATUMinfo()
data.frame(h)

</code></pre>

<hr>
<h2 id='demcmap'>Color Map from DEM</h2><span id='topic+demcmap'></span>

<h3>Description</h3>

<p>create a color map from a DEM (Digital Elevation Map)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>demcmap(ZTOPO, n = 100, ccol = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="demcmap_+3A_ztopo">ZTOPO</code></td>
<td>
<p>Topography structure</p>
</td></tr>
<tr><td><code id="demcmap_+3A_n">n</code></td>
<td>
<p>number of colors</p>
</td></tr>
<tr><td><code id="demcmap_+3A_ccol">ccol</code></td>
<td>
<p>color structure</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of rgb colors
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>rgb, settopocol</p>

<hr>
<h2 id='difflon'>Difference between Longitudes</h2><span id='topic+difflon'></span>

<h3>Description</h3>

<p>Difference between Longitudes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>difflon(LON1, LON2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="difflon_+3A_lon1">LON1</code></td>
<td>
<p>Longitude in degrees</p>
</td></tr>
<tr><td><code id="difflon_+3A_lon2">LON2</code></td>
<td>
<p>Longitude in degrees</p>
</td></tr>
</table>


<h3>Details</h3>

<p>takes into account crossing the zero longitude
</p>


<h3>Value</h3>

<table>
<tr><td><code>deg</code></td>
<td>
<p>degrees difference</p>
</td></tr>
<tr><td><code>sn</code></td>
<td>
<p>direction of rotation</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
difflon( 34 , 67)

###  here we cross the zero line
difflon( 344 , 67)

</code></pre>

<hr>
<h2 id='distaz'>Distance and Azimuth from two points </h2><span id='topic+distaz'></span>

<h3>Description</h3>

<p>Calculate distance, Azimuth and Back-Azimuth from two points on Globe.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>distaz(olat, olon, tlat, tlon)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distaz_+3A_olat">olat</code></td>
<td>
<p>origin latitude, degrees </p>
</td></tr>
<tr><td><code id="distaz_+3A_olon">olon</code></td>
<td>
<p>origin longitude, degrees </p>
</td></tr>
<tr><td><code id="distaz_+3A_tlat">tlat</code></td>
<td>
<p>target latitude, degrees </p>
</td></tr>
<tr><td><code id="distaz_+3A_tlon">tlon</code></td>
<td>
<p>target longitude, degrees  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Program is set up for one origin (olat, olon) pair and many
target (tlat, tlon) pairs given as vectors.
</p>
<p>If multiple olat and olon are given, the program returns a list
of outputs for each.
</p>
<p>If olat or any tlat is greater than 90 or less than -90 NA is returned
and error flag is 0.
</p>
<p>If any tlat and tlon is equal to olat and olon, the points are
coincident.
In that case the distances are set to zero, but the az and baz are NA,
and the error flag is set to 0.
</p>


<h3>Value</h3>

<p>List:
</p>
<table>
<tr><td><code>del</code></td>
<td>
<p>Delta, angle in degrees</p>
</td></tr>
<tr><td><code>az</code></td>
<td>
<p>Azimuth, angle in degrees</p>
</td></tr>
<tr><td><code>baz</code></td>
<td>
<p>back Azimuth, (az+180) in degrees</p>
</td></tr>
<tr><td><code>dist</code></td>
<td>
<p>distance in km</p>
</td></tr>
<tr><td><code>err</code></td>
<td>
<p>0 or 1, error flag.  0=error, 1=no error, see details</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>along.great, getgreatarc</p>


<h3>Examples</h3>

<pre><code class='language-R'>

####  one point
d = distaz(12, 23, -32,    -65)
d

####  many random target points
org = c(80.222, -100.940)
targ = cbind(runif(10, 10, 50), runif(10, 20, 100))


distaz(org[1], org[2], targ[,1], targ[,2])

############  if origin and target are identical
#####  the distance is zero, but the az and baz are not defined
distaz(80.222, -100.940, 80.222, -100.940)


########################   set one of the targets equal to the origin
targ[7,1] = org[1]
targ[7,2] = org[2]

distaz(org[1], org[2], targ[,1], targ[,2])

####  put in erroneous latitude data

targ[3,1] = -91.3


distaz(org[1], org[2], targ[,1], targ[,2])


</code></pre>

<hr>
<h2 id='dms'>Convert decimal degrees to degree, minutes, seconds</h2><span id='topic+dms'></span>

<h3>Description</h3>

<p>Convert decimal degrees to degree, minutes, seconds
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dms(d1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dms_+3A_d1">d1</code></td>
<td>
<p>decomal degrees </p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>
<table>
<tr><td><code>d</code></td>
<td>
<p>degrees</p>
</td></tr>
<tr><td><code>m</code></td>
<td>
<p>minutes</p>
</td></tr>
<tr><td><code>s</code></td>
<td>
<p>seconds</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
dms(33.12345)

H = dms(-91.8765)

print(H)

newH = H$d+H$m/60+H$s/3600
print(newH)


</code></pre>

<hr>
<h2 id='DUMPLOC'>DUMP vectors to screen in list format</h2><span id='topic+DUMPLOC'></span>

<h3>Description</h3>

<p>For saving vectors to a file after the locator function
has been executed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DUMPLOC(zloc, dig = 12)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DUMPLOC_+3A_zloc">zloc</code></td>
<td>
<p>x,y list of locator positions</p>
</td></tr>
<tr><td><code id="DUMPLOC_+3A_dig">dig</code></td>
<td>
<p>number of digits in output</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Side effects: print to screen
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>G=list()
G$x=c(-1.0960,-0.9942,-0.8909,-0.7846,-0.6738,-0.5570,-0.4657,-0.3709,
-0.2734,-0.1740,-0.0734, 0.0246, 0.1218, 0.2169, 0.3086, 0.3956, 0.4641, 
0.5293, 0.5919, 0.6530, 0.7131)
G$y=c(-0.72392,-0.62145,-0.52135,-0.42599,-0.33774,-0.25896,-0.20759,
-0.16160,-0.11981,-0.08105,-0.04414,-0.00885, 0.02774, 0.06759, 0.11262, 
0.16480, 0.21487, 0.27001, 0.32895, 0.39044, 0.45319)

g = PointsAlong(G$x, G$y, N=3)
DUMPLOC(g, dig = 5)


</code></pre>

<hr>
<h2 id='EHB.LLZ'>Earthquake Location Data</h2><span id='topic+EHB.LLZ'></span>

<h3>Description</h3>

<p>Global Earthquake catalog locations from Engdahl, et al.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(EHB.LLZ)</code></pre>


<h3>Format</h3>


<dl>
<dt>lat</dt><dd><p>Latitude</p>
</dd>
<dt>lon</dt><dd><p>Longitude</p>
</dd>
<dt>z</dt><dd><p>depth in km</p>
</dd>
</dl>



<h3>Source</h3>

<p>Data is extrcted from an earthquake data base of relocated events
provided by Robert Engdahl.
</p>


<h3>References</h3>

<p>Engdahl, E. R., R. D. van der Hilst, S. H. Kirby, G. Ekstrom, K. M. Shedlock, and A. F. Sheehan (1998), A global survey of slab structures and internal processes using a combined data base of high-resolution earthquake hypocenters, tomographic images and focal mechanism data, Seismol. Res. Lett., 69, 153-154. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(EHB.LLZ)
## maybe str(EHB.LLZ) ; plot(EHB.LLZ) ...
</code></pre>

<hr>
<h2 id='Ellipsoidal.Distance'>Ellipsoidal Distance
</h2><span id='topic+Ellipsoidal.Distance'></span>

<h3>Description</h3>

<p>Ellipsoidal Distance given Latitude and Longitude
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Ellipsoidal.Distance(olat, olon, tlat, tlon, a = 6378137, b = 6356752.314, tol=10^(-12))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Ellipsoidal.Distance_+3A_olat">olat</code></td>
<td>
<p>Origin Latitude, degrees
</p>
</td></tr>
<tr><td><code id="Ellipsoidal.Distance_+3A_olon">olon</code></td>
<td>
<p>Origin Longitude, degrees
</p>
</td></tr>
<tr><td><code id="Ellipsoidal.Distance_+3A_tlat">tlat</code></td>
<td>
<p>Target Latitude, degrees
</p>
</td></tr>
<tr><td><code id="Ellipsoidal.Distance_+3A_tlon">tlon</code></td>
<td>
<p>Target Longitude, degrees
</p>
</td></tr>
<tr><td><code id="Ellipsoidal.Distance_+3A_a">a</code></td>
<td>
<p>major axis, meters.  If missing uses the 
</p>
</td></tr>
<tr><td><code id="Ellipsoidal.Distance_+3A_b">b</code></td>
<td>
<p>minor axis, meters
</p>
</td></tr>
<tr><td><code id="Ellipsoidal.Distance_+3A_tol">tol</code></td>
<td>
<p>Tolerance for convergence, default=10^(-12)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses Vincenty's formulation to calculate the distance along a great
circle on an ellipsoidal body.
</p>
<p>If a and be are not provided,
they are set by default to a=6378137.0 , b=6356752.314,
the WGS-84 standard.
</p>
<p>Only one pair of (olat, olon) and (tlat, tlon) can
be given at a time.  The program is not vectorized.
</p>
<p>Quoting from the wiki page this algorithm was extracted from:
</p>
<p>&quot;Vincenty's formulae are two related iterative methods used in
geodesy to calculate the distance
between two points on the surface of an spheroid, developed by
Thaddeus Vincenty in 1975. They are based on the assumption that
the figure of the Earth is an oblate
spheroid, and hence are more accurate than methods such as
great-circle distance which assume a spherical Earth.
</p>
<p>The first (direct) method computes the location of a point which is a given
distance and azimuth (direction) from another point. The second (inverse) method
computes the geographical distance and azimuth between two given points.
They have been widely used in geodesy because they are
accurate to within 0.5 mm (.020 sec)  on the Earth ellipsoid&quot;
</p>


<h3>Value</h3>

<p>list
</p>
<table>
<tr><td><code>dist</code></td>
<td>
<p>distance, km</p>
</td></tr>
<tr><td><code>az</code></td>
<td>
<p>azimuth, degrees</p>
</td></tr>
<tr><td><code>revaz</code></td>
<td>
<p>reverse azimuth, degrees</p>
</td></tr>
<tr><td><code>err</code></td>
<td>
<p>=0, if convergence failed, else=1</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Latitudes &gt;90 and &lt; -90 are not allowed.  NA's are returned.
</p>
<p>If points are identical, a distance of zero is returned
and NA for the azimuths.
If there is some problems with convergence or division by
zero, NA's are returned and error message is printed.
</p>
<p>A couple of known cases that do not work are, e.g.:
(olat=0; olon=0; tlat=0; tlon=-180)  and 
(olat=0; olon=0; tlat=0; tlon=180).
They will return NA's to avoid division by zero.
</p>
<p>I am not sure how to deal with these cases yet.
</p>
<p>The reverse azimuth is the angle from the meridian
on the target point to the great circle from the origin to the target
(as far as I can tell).  If distaz and Ellipsoidal.Distance
are compared, they give the same azimuth, and the
absolute angles of baz (from distaz) and revaz (from
Ellipsoidal.Distance) will add to 180 degrees.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>http://en.wikipedia.org/wiki/Vincenty%27s_formulae
</p>
<p>Vincenty, T. (April 1975). Direct and Inverse Solutions of Geodesics
on the Ellipsoid with application of nested equations.
Survey Review XXIII (misprinted as XXII) (176): 88.201393.
http://www.ngs.noaa.gov/PUBS_LIB/inverse.pdf. Retrieved 2009-07-11.
</p>


<h3>See Also</h3>

<p>distaz
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
####    compare to spheroidal calculation distaz
####


R.MAPK = 6378.2064
N =20

OUT = list(dadist=0, ed2dist=0, ed1dist=0, dif2=0, dif1=0, pct1=0)
for( i in 1:N)
  {

    olat = runif(1, -90, 90)
    olon = runif(1, 0, 180)

     tlat = runif(1, -90, 90)
    tlon = runif(1, 0, 180)

##########  older spherical calculation
    da = distaz(olat, olon, tlat, tlon)
#####  ed1 = elliposidal earth
    ed1 = Ellipsoidal.Distance(olat, olon, tlat, tlon)
#####   ed2 spherical earth using
############      ellipsoidal calculations, compare with
distaz
   ed2 =  Ellipsoidal.Distance(olat, olon, tlat, tlon, a=R.MAPK*1000, b=R.MAPK*1000)

    dif1 =  da$dist-ed1$dis
    dif2 =  da$dist-ed2$dis

    pct1 = 100*dif1/ed1$dist

##############   OUT = format( c(da$dist, ed2$dist, ed1$dist, dif2, dif1, pct1) , digits=10)

    OUT$dadist[i] =da$dist
    OUT$ed2dist[i] =ed2$dist
OUT$ed1dist[i]=ed1$dist
OUT$dif2[i]= dif2
OUT$dif1[i]=dif1
OUT$pct1[i]=pct1

###cat(paste(collapse=" ", OUT), sep="\n")

  }


print( data.frame(OUT) )



###############   some extreme cases can cause problems
#######  here compare  Ellipsoidal.Distance with spherical program distaz

Alat = c(90,   90,  90,   90,  45,  45,  45,  45,   0,    0,    0, 0)
Alon = c(180, 180,-180, -180,  45,  45,  45,  45,   0,    0,    0, 0)
Blat = c(-90, -45,   0,   45, -45,  0,    0,  -80,  45,   0,    0, 0)
Blon = c(180,-180, 180,    0, -45,  0, -180,  100, -60, -180, 180, 0)


BOUT = list(olat=0, olon=0, tlat=0, tlon=0, dadist=0, ed2dist=0, daaz=0, ed2az=0, dabaz=0, ed2baz=0)

R.MAPK = 6378.2064
for(i in 1:length(Alat))
{

  olat = Alat[i]
  olon  = Alon[i]
  tlat  = Blat[i]
  tlon  = Blon[i]

 da = distaz(olat, olon, tlat, tlon)
  ed2 = Ellipsoidal.Distance(olat, olon, tlat, tlon, a=R.MAPK*1000, b=R.MAPK*1000)
 cat(paste("i=", i), sep="\n")
 

 BOUT$olon[i] =olon
 BOUT$olat[i] =olat
 BOUT$tlat[i] =tlat
 BOUT$tlon[i] =tlon


      BOUT$dadist[i] =da$dist
   BOUT$ed2dist[i] =ed2$dist

BOUT$daaz[i]= da$az
BOUT$dabaz[i]= da$baz

BOUT$ed2az[i]= ed2$az
BOUT$ed2baz[i]=  ed2$revaz


}

print(data.frame(BOUT))




</code></pre>

<hr>
<h2 id='eqswath'>Extract a set of eathquakes in swath along a cross sectional line</h2><span id='topic+eqswath'></span>

<h3>Description</h3>

<p>Extract a set of eathquakes in swath along a cross sectional line
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eqswath(x, y, z, L, width = 1, PROJ = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eqswath_+3A_x">x</code></td>
<td>
<p>x-coordinates of earthquakes</p>
</td></tr>
<tr><td><code id="eqswath_+3A_y">y</code></td>
<td>
<p>y-coordinates of earthquakes</p>
</td></tr>
<tr><td><code id="eqswath_+3A_z">z</code></td>
<td>
<p>z-coordinates of earthquakes</p>
</td></tr>
<tr><td><code id="eqswath_+3A_l">L</code></td>
<td>
<p>list of x-y coordinates of cross section</p>
</td></tr>
<tr><td><code id="eqswath_+3A_width">width</code></td>
<td>
<p>width of swath (km)</p>
</td></tr>
<tr><td><code id="eqswath_+3A_proj">PROJ</code></td>
<td>
<p>projection information</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All units should be the same.
</p>


<h3>Value</h3>

<table>
<tr><td><code>r</code></td>
<td>
<p>r-distance along cross section (x-coordinate)</p>
</td></tr>
<tr><td><code>dh</code></td>
<td>
<p>distance from cross seection</p>
</td></tr>
<tr><td><code>depth</code></td>
<td>
<p>depth in cross section (y-coordinate) </p>
</td></tr>
<tr><td><code>flag</code></td>
<td>
<p>index vector of which earthquakes fell in swath and depth range</p>
</td></tr>
<tr><td><code>InvBox</code></td>
<td>
<p>coordinates of swath for plotting on map</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>XSECwin, XSECEQ</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 #############  create data
x = runif(100, 1, 100)  
y = runif(100, 1, 100) 
z = runif(100, 1, 10) 
plot(x,y, asp=1)
## L = locator()

L=list()
L$x=c( 5.42328560757,64.62879777806)
L$y=c(89.843266449785,-0.174423911329)

J = eqswath(x, y, z, L, width = 10, PROJ = NULL)

##########   show box:
plot(x,y, asp=1)
lines(J$InvBox$x, J$InvBox$y)


############  show cross section with events plotted
plot(J$r, -J$depth)

</code></pre>

<hr>
<h2 id='ExcludeGEOmap'>Exclude GEOmap Strokes</h2><span id='topic+ExcludeGEOmap'></span>

<h3>Description</h3>

<p>Select sections of a MAP-list structure based on stroke index
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExcludeGEOmap(MAP, SEL, INOUT = "out")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExcludeGEOmap_+3A_map">MAP</code></td>
<td>
<p>Map List</p>
</td></tr>
<tr><td><code id="ExcludeGEOmap_+3A_sel">SEL</code></td>
<td>
<p>Selection of stroke indeces to include or exclude</p>
</td></tr>
<tr><td><code id="ExcludeGEOmap_+3A_inout">INOUT</code></td>
<td>
<p>text, &quot;in&quot; means include, &quot;out&quot; means exclude</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>MAP</code></td>
<td>
<p>list</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>getGEOmap, plotGEOmap, SELGEOmap, boundGEOmap </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(coastmap)

###  extract (include)  the first 6 strokes from world map


A1 = ExcludeGEOmap(coastmap, 1:6, INOUT="in")
print(A1$STROKES$nam)


</code></pre>

<hr>
<h2 id='expandbound'>Expand Bounds
</h2><span id='topic+expandbound'></span>

<h3>Description</h3>

<p>Calculate an
expanded bounding region based on a percent
of the existing boundaries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>expandbound(g, pct = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="expandbound_+3A_g">g</code></td>
<td>
<p>vector of values
</p>
</td></tr>
<tr><td><code id="expandbound_+3A_pct">pct</code></td>
<td>
<p>fractional percent to expand
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>uses the range of the exising
vector to estimate the expanded bound
</p>


<h3>Value</h3>

<p>vector, new range
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
i = 5:10
exi = expandbound(i, pct = 0.1)
range(i)
range(exi)

</code></pre>

<hr>
<h2 id='explode'>Explode Points
</h2><span id='topic+explode'></span>

<h3>Description</h3>

<p>Explode a set of points away from a center point
</p>


<h3>Usage</h3>

<pre><code class='language-R'>explode(fxy, dixplo=1, mult=1, cenx=0, ceny=0, PLOT=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="explode_+3A_fxy">fxy</code></td>
<td>
<p>list of x, y coordinates
</p>
</td></tr>
<tr><td><code id="explode_+3A_dixplo">dixplo</code></td>
<td>
<p>distance to explode
</p>
</td></tr>
<tr><td><code id="explode_+3A_mult">mult</code></td>
<td>
<p>multiplier for the distance
</p>
</td></tr>
<tr><td><code id="explode_+3A_cenx">cenx</code></td>
<td>
<p>x coordinate center of explosion 
</p>
</td></tr>
<tr><td><code id="explode_+3A_ceny">ceny</code></td>
<td>
<p>y  coordinate center  of explosion 
</p>
</td></tr>
<tr><td><code id="explode_+3A_plot">PLOT</code></td>
<td>
<p>logical, TRUE=make a plot of the resulting explosion
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If cenx and ceny is missing it is assumed to
be the mean of the coordinates.
Program  calculates the new locations
radiating away from the central point.
No protection against overlapping symbols is included.
</p>


<h3>Value</h3>

<p>list of new x,y values
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>new x coordinates 
</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>new y coordinates 
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>ExplodeSymbols, NoOverlap
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

############  random data
x = rnorm(20)
y = rnorm(20)

NEW = explode(list(x=x,y=y), dixplo =1)

plot(range(c(x,NEW$x)), range(c(y,NEW$y)), asp=1, type='n')
segments(x,y,NEW$x, NEW$y)
points(x,y, pch=3, col='red')
points(NEW$x, NEW$y, pch=6, col='blue', cex=2)


###  try a larger radius:
NEW2 = explode(list(x=x,y=y), dixplo =1.3)
points(NEW2$x, NEW2$y, pch=7, col='brown', cex=2, xpd=TRUE)
arrows(NEW$x, NEW$y,NEW2$x, NEW2$y, col='green' )



#####   try with a different center
cenx=-1; ceny=-1
NEW = explode(list(x=x,y=y), dixplo =1, cenx=cenx, ceny=ceny)
plot(range(c(x,NEW$x)), range(c(y,NEW$y)), asp=1, type='n')
points(x,y, pch=3, col='red')
segments(x,y,NEW$x, NEW$y)
points(NEW$x, NEW$y, pch=6, col='blue', cex=2)
points(cenx, ceny, pch=8, col='purple')
text(cenx, ceny, labels="Center Point", pos=1)



</code></pre>

<hr>
<h2 id='ExplodeSymbols'>Explode symbols that overlap
</h2><span id='topic+ExplodeSymbols'></span>

<h3>Description</h3>

<p>Interactive program for
redistributing symbols for later plotting.  Used
for Focal Mechanisms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ExplodeSymbols(XY, fsiz = 1, STARTXY = NULL, MAP = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ExplodeSymbols_+3A_xy">XY</code></td>
<td>
<p>list of x,y values
</p>
</td></tr>
<tr><td><code id="ExplodeSymbols_+3A_fsiz">fsiz</code></td>
<td>
<p>size of the symbol, as a percentage of the user coordinates
</p>
</td></tr>
<tr><td><code id="ExplodeSymbols_+3A_startxy">STARTXY</code></td>
<td>
<p>Starting positions.  This is used
for multiple sessions where we want to pick up the previous locations.
</p>
</td></tr>
<tr><td><code id="ExplodeSymbols_+3A_map">MAP</code></td>
<td>
<p>Map to plot on the screen, in GEOmap format.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The program is interactive.  It starts by plotting the points as
symbols.  A number of buttons are provided for exploding the points
semi automatically.  To move each point click near its current point,
then click at the destination followed by a click on the HAND button.
several symbols can be moved at the same time.
</p>
<p>You must click on the screen
and on the buttons to get this code working -
the program will not work in batch mode or run as a script
You click in the active screen area and then press a button
on top (or bottom) - the button takes your clicks and does something
Here are some hints:
</p>
<p>Buttons:Buttons appear on top and bottom of the plotting
region.
</p>
<p>HAND: If you want to move only one symbol (focal mech) click near it and then click
where you want it to go.  Then click the HAND button
You may click several at once, but for each click oin a symbol
there has to be a click somewhere to relocate it.
(i.e. there must be an even number of clicks on the screen before hitting the
HAND button)
</p>
<p>SEL:
If you want to explode several symbols at once, first select them:
click lower left, then upper right of rectangle enclosing the selection.
Once a selection is made it remains active until another selection is made
so you can keep changing the radius and center for different explosions
Then click CIRC.
</p>
<p>RECT
Choose a rectangle (lower left and upper right), then click RECT for
an explosion
</p>
<p>RECT2
After selecting, choose a center and a distance.
symbols will be moved to a rectangular perimeter defined by the two
points
</p>
<p>CIRC
After selection, click once for the circle center, and a second time for the radius, then click CIRC
</p>
<p>LINE
After selection,will explode the events away from a line, a given distance away.
The line is given by 2 points and the distance by a third perpendicular
distance.
</p>


<h3>Value</h3>

<p>list of new x,y values
</p>


<h3>Note</h3>

<p>For now the map is given in lat-lon coordinates-
the same as the points being moved.
There is no map  projection used.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>rekt2line
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
F1 = list(x=rnorm(43), y=rnorm(43))
SMXY = ExplodeSymbols(F1, 0.03)




## End(Not run)

</code></pre>

<hr>
<h2 id='faultdip'>Show Fault dip </h2><span id='topic+faultdip'></span>

<h3>Description</h3>

<p>Show Fault dip
</p>


<h3>Usage</h3>

<pre><code class='language-R'>faultdip(x, y, rot = 0, h = 1, lab = "")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="faultdip_+3A_x">x</code></td>
<td>
<p>x-coordinates</p>
</td></tr>
<tr><td><code id="faultdip_+3A_y">y</code></td>
<td>
<p>y-coordinates</p>
</td></tr>
<tr><td><code id="faultdip_+3A_rot">rot</code></td>
<td>
<p>cosine and sine of rotation</p>
</td></tr>
<tr><td><code id="faultdip_+3A_h">h</code></td>
<td>
<p>length of mark</p>
</td></tr>
<tr><td><code id="faultdip_+3A_lab">lab</code></td>
<td>
<p>labels</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Graphical Side effect
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>perpen, PointsAlong, getsplineG</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ff=list()
ff$x=c(-4.850,-4.700,-3.934,-2.528, 0.603, 2.647, 3.861, 2.626)
ff$y=c(-4.045,-2.087,-0.710, 0.172, 1.291, 2.087,-0.753,-4.131)

G =getsplineG(ff$x, ff$y, kdiv=20)
g = PointsAlong(G$x, G$y, N=5)


plot(c(-5,5), c(-5,5), asp=1, type='n' )
lines(G)

angs = 180*atan(g$rot$sn/g$rot$cs)/pi
faultdip(g$x , g$y , rot=angs, h=.5, lab='')


</code></pre>

<hr>
<h2 id='faultperp'>Fault Perpendiculars</h2><span id='topic+faultperp'></span>

<h3>Description</h3>

<p>Draw perpendicular marks on fault trace
</p>


<h3>Usage</h3>

<pre><code class='language-R'>faultperp(x, y, N = 20, endtol = 0.1, h = 1, col = "black")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="faultperp_+3A_x">x</code></td>
<td>
<p>x-coordinates</p>
</td></tr>
<tr><td><code id="faultperp_+3A_y">y</code></td>
<td>
<p>y-coordinates</p>
</td></tr>
<tr><td><code id="faultperp_+3A_n">N</code></td>
<td>
<p>number of points</p>
</td></tr>
<tr><td><code id="faultperp_+3A_endtol">endtol</code></td>
<td>
<p>indent on either ends</p>
</td></tr>
<tr><td><code id="faultperp_+3A_h">h</code></td>
<td>
<p>length of perpendicular marks</p>
</td></tr>
<tr><td><code id="faultperp_+3A_col">col</code></td>
<td>
<p>color of line</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Graphical Side effect
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>OverTurned</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ff=list()
ff$x=c(-4.850,-4.700,-3.934,-2.528, 0.603, 2.647, 3.861, 2.626)
ff$y=c(-4.045,-2.087,-0.710, 0.172, 1.291, 2.087,-0.753,-4.131)

G =getsplineG(ff$x, ff$y, kdiv=20)
g = PointsAlong(G$x, G$y, N=5)


plot(c(-5,5), c(-5,5), asp=1, type='n' )
lines(G)

faultperp(G$x, G$y, N = 10, endtol = 0.1, h = .3, col = "black")


</code></pre>

<hr>
<h2 id='fixCoastwrap'>Correct the Wrapping problem</h2><span id='topic+fixCoastwrap'></span>

<h3>Description</h3>

<p>Correct wrapping for GEOmaps
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fixCoastwrap(Z, maxdis = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fixCoastwrap_+3A_z">Z</code></td>
<td>
<p>list of x, y</p>
</td></tr>
<tr><td><code id="fixCoastwrap_+3A_maxdis">maxdis</code></td>
<td>
<p>maximum distance for differences</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Based on mapswrap program
</p>


<h3>Value</h3>

<p>List:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>x-coordinates (longitudes)</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>y-coordinates (latitudes)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(coastmap)
SEL = which(coastmap$STROKES$nam=="AFROASIA")

A = ExcludeGEOmap(coastmap, SEL, INOUT="in")

plot(A$POINTS$lon, A$POINTS$lat, type='n')

points(A$POINTS$lon, A$POINTS$lat, pch='.')

######  note that the map wraps around.

B = fixCoastwrap(list(x=A$POINTS$lon, y=A$POINTS$lat), 100)
 which(is.na(B$x))



lines(B)


polygon(B, col=rgb(.8,1, .8))



</code></pre>

<hr>
<h2 id='gclc'>Global to local coordinates</h2><span id='topic+gclc'></span><span id='topic+GCLCFR'></span>

<h3>Description</h3>

<p>OLD projection sometimes used in Lees' tomography. No need for
projection data, it is included in the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gclc(phiorg, lamorg, phi, lam)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gclc_+3A_phiorg">phiorg</code></td>
<td>
<p>lat origin</p>
</td></tr>
<tr><td><code id="gclc_+3A_lamorg">lamorg</code></td>
<td>
<p>lon origin</p>
</td></tr>
<tr><td><code id="gclc_+3A_phi">phi</code></td>
<td>
<p>lat</p>
</td></tr>
<tr><td><code id="gclc_+3A_lam">lam</code></td>
<td>
<p>lon</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This may be defunct now.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>coordinate, km</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>coordinate, km</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Orignally from R. S. Crosson</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>lcgc</p>


<h3>Examples</h3>

<pre><code class='language-R'>gclc(23, 35, 23.5, 35.6)
</code></pre>

<hr>
<h2 id='geoarea'>Area of Map objects</h2><span id='topic+geoarea'></span>

<h3>Description</h3>

<p>vector of areas of polygons in map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geoarea(MAP, proj=NULL, ncut=10)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geoarea_+3A_map">MAP</code></td>
<td>
<p>Map structure</p>
</td></tr>
<tr><td><code id="geoarea_+3A_proj">proj</code></td>
<td>
<p>projection</p>
</td></tr>
<tr><td><code id="geoarea_+3A_ncut">ncut</code></td>
<td>
<p>minimum number of points in polygon</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses sf function.  If proj is NULL then the project is
reset to UTM spherical for each element seperately to calculate the
area in km.
ncut is used to eliminate area calculations with strokes less than the
specified number.
</p>


<h3>Value</h3>

<p>vector of areas
</p>


<h3>Note</h3>

<p>areas smaller than a certain tolerance are NA
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>sf::st_area</p>

<hr>
<h2 id='geoLEGEND'>Geological legend from GEOmap Structure</h2><span id='topic+geoLEGEND'></span>

<h3>Description</h3>

<p>Create and add Geological legend from GEOmap Structure
</p>


<h3>Usage</h3>

<pre><code class='language-R'>geoLEGEND(names, shades, zx, zy, nx, ny, side=1, cex=0.5)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="geoLEGEND_+3A_names">names</code></td>
<td>
<p>namesof units</p>
</td></tr>
<tr><td><code id="geoLEGEND_+3A_shades">shades</code></td>
<td>
<p>colorsof units</p>
</td></tr>
<tr><td><code id="geoLEGEND_+3A_zx">zx</code></td>
<td>
<p>width of box, mm</p>
</td></tr>
<tr><td><code id="geoLEGEND_+3A_zy">zy</code></td>
<td>
<p>height of box, mm</p>
</td></tr>
<tr><td><code id="geoLEGEND_+3A_nx">nx</code></td>
<td>
<p>number of boxes in x-direction</p>
</td></tr>
<tr><td><code id="geoLEGEND_+3A_ny">ny</code></td>
<td>
<p>number of boxes in y-direction </p>
</td></tr>
<tr><td><code id="geoLEGEND_+3A_side">side</code></td>
<td>
<p>Side of the plot for the legend (1,2,3,4) </p>
</td></tr>
<tr><td><code id="geoLEGEND_+3A_cex">cex</code></td>
<td>
<p>Character expansion for text in legend </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Adds geological legend based on information
provided.  Legend is placed in margin.
</p>


<h3>Value</h3>

<p>Graphical Side Effects
</p>


<h3>Note</h3>

<p>If plot is resized, should re-run this as the
units depend on the screen size information and the transformation
of user coordinates.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

library(RPMG)
library(RSEIS)
library(GEOmap)
library(geomapdata)

data(cosogeol)
data(cosomap)
     data(faults)
     data(hiways)
     data(owens)

proj = cosomap$PROJ
   
XMCOL = setXMCOL()

newcol = XMCOL[cosogeol$STROKES$col+1]
cosocolnums = cosogeol$STROKES$col
cosogeol$STROKES$col = newcol
ss = strsplit(cosogeol$STROKES$nam, split="_")     

geo = unlist(sapply(ss  , "[[", 1))


UGEO = unique(geo)


mgeo = match( geo, UGEO )

gcol = paste(sep=".", geo, cosogeol$STROKES$col)


ucol = unique(gcol)

N = length(ucol)


spucol = strsplit(ucol,split="\.")     

       
names = unlist(sapply(spucol  , "[[", 1))

shades = unlist(sapply(spucol  , "[[", 2))

ORDN = order(names)
### example:


par(mai=c(0.5, 1.5, 0.5, 0.5) )

 plotGEOmapXY(cosomap, PROJ=proj,  add=FALSE, ann=FALSE, axes=FALSE)
  

     plotGEOmapXY(cosogeol, PROJ=proj,  add=TRUE, ann=FALSE, axes=FALSE)
  
geoLEGEND(names[ORDN], shades[ORDN], .28, .14, 4, 16, side=2)

####
par(mai=c(0.5, 0.5, 1.0, 0.5) )

 plotGEOmapXY(cosomap, PROJ=proj,  add=FALSE, ann=FALSE, axes=FALSE)
  

     plotGEOmapXY(cosogeol, PROJ=proj,  add=TRUE, ann=FALSE, axes=FALSE)
  
geoLEGEND(names[ORDN], shades[ORDN], .28, .14, 16, 6, side=3)


####
par(mai=c(0.5, 0.5, 0.5, 1) )

 plotGEOmapXY(cosomap, PROJ=proj,  add=FALSE, ann=FALSE, axes=FALSE)
  

     plotGEOmapXY(cosogeol, PROJ=proj,  add=TRUE, ann=FALSE, axes=FALSE)
  
geoLEGEND(names[ORDN], shades[ORDN], .28, .14, 3, 16, side=4)


####
par(mai=c(1.5, 0.5, 0.5, 0.5) )

 plotGEOmapXY(cosomap, PROJ=proj,  add=FALSE, ann=FALSE, axes=FALSE)
  

     plotGEOmapXY(cosogeol, PROJ=proj,  add=TRUE, ann=FALSE, axes=FALSE)
  
geoLEGEND(names[ORDN], shades[ORDN], .28, .14, 16, 3, side=1)



## End(Not run)

</code></pre>

<hr>
<h2 id='GEOmap.breakline'>Break a line at specified indeces into a list</h2><span id='topic+GEOmap.breakline'></span>

<h3>Description</h3>

<p>Break a line at specified indices into a list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GEOmap.breakline(Z, ww)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GEOmap.breakline_+3A_z">Z</code></td>
<td>
<p>list of x,y location values</p>
</td></tr>
<tr><td><code id="GEOmap.breakline_+3A_ww">ww</code></td>
<td>
<p>index vector of break locations</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>newx</code></td>
<td>
<p>list x of strokes</p>
</td></tr>
<tr><td><code>newy</code></td>
<td>
<p>list y of strokes</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Y=list()
Y$x=c(170,175,184,191,194,190,177,166,162,164)
Y$y=c(-54,-60,-60,-50,-26,8,34,37,10,-15)

GEOmap.breakline(Y, 5)


</code></pre>

<hr>
<h2 id='GEOmap.breakpoly'>Break up a polygon </h2><span id='topic+GEOmap.breakpoly'></span>

<h3>Description</h3>

<p>Break up a polygon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GEOmap.breakpoly(Z, ww)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GEOmap.breakpoly_+3A_z">Z</code></td>
<td>
<p>list, x,y locations </p>
</td></tr>
<tr><td><code id="GEOmap.breakpoly_+3A_ww">ww</code></td>
<td>
<p>vector of indecies where NAs occur </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The NA values in Z represent breaks.  GEOmap.breakpoly
breaks the polygon up into individual strokes.
The beginning and the ending of the stroke are combined.
</p>


<h3>Value</h3>

<table>
<tr><td><code>newx</code></td>
<td>
<p>list of x values</p>
</td></tr>
<tr><td><code>newy</code></td>
<td>
<p>list of y values</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>fixCoastwrap, GEOmap.breakline</p>


<h3>Examples</h3>

<pre><code class='language-R'>
x=1:100
y = 1:100

ww = c(25, 53, 75)


A = list(x=x, y=y)

W = GEOmap.breakpoly(A , ww)




</code></pre>

<hr>
<h2 id='GEOmap.cat'>Concatenate Two GEOmaps</h2><span id='topic+GEOmap.cat'></span>

<h3>Description</h3>

<p>Combine Two GEOmaps into one
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GEOmap.cat(MAP1, MAP2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GEOmap.cat_+3A_map1">MAP1</code></td>
<td>
<p>GEOmap list</p>
</td></tr>
<tr><td><code id="GEOmap.cat_+3A_map2">MAP2</code></td>
<td>
<p>GEOmap list</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Maps are combine consecutively.
</p>


<h3>Value</h3>

<table>
<tr><td><code>GEOmap</code></td>
<td>
<p>list</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>GEOmap.Extract, GEOmap.CombineStrokes, list.GEOmap</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(coastmap)
CUBA = GEOmap.Extract(coastmap,90, INOUT="in" )

NSAMER =  GEOmap.Extract(coastmap,2, INOUT="in" )
AMAP = GEOmap.cat(CUBA, NSAMER)
plotGEOmap(AMAP )

</code></pre>

<hr>
<h2 id='GEOmap.CombineStrokes'>Combine strokes in a GEOmap list </h2><span id='topic+GEOmap.CombineStrokes'></span>

<h3>Description</h3>

<p>Combine strokes in a GEOmap list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GEOmap.CombineStrokes(MAP, SEL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GEOmap.CombineStrokes_+3A_map">MAP</code></td>
<td>
<p>GEOmap list</p>
</td></tr>
<tr><td><code id="GEOmap.CombineStrokes_+3A_sel">SEL</code></td>
<td>
<p>index of strokes to be combined</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Stokes are combined in the order
designated by the SEL index vector.  The direction of the
strokes is not modified - this may have to be
fixed so that strokes align properly.
</p>


<h3>Value</h3>

<p>GEOmap list
</p>
<table>
<tr><td><code>STROKES</code></td>
<td>
<p>Metadata for strokes</p>
</td></tr>
<tr><td><code>POINTS</code></td>
<td>
<p>list, lat=vector, lon=vector</p>
</td></tr> 
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>GEOmap.cat, GEOmap.Extract, GEOmap.CombineStrokes, list.GEOmap
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(coastmap)
SEL = which(coastmap$STROKES$nam=="Caribbean")


CAR =  GEOmap.Extract(coastmap, SEL, INOUT="in" )

plotGEOmap(CAR, MAPstyle=3, NUMB=TRUE)

CAR2 = GEOmap.CombineStrokes(CAR, SEL =c(6:15)  )

plotGEOmap(CAR2, MAPstyle=3, MAPcol='red' , add=TRUE)

</code></pre>

<hr>
<h2 id='GEOmap.Extract'>Extract from GEOmap</h2><span id='topic+GEOmap.Extract'></span><span id='topic+fastExtract'></span><span id='topic+GEOmap.limit'></span>

<h3>Description</h3>

<p>Extract or Exclude parts of a GEOmap list.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GEOmap.Extract(MAP, SEL, INOUT = "out")
fastExtract(MAP, SEL, INOUT = "out")
GEOmap.limit(MAP, LLlim )

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GEOmap.Extract_+3A_map">MAP</code></td>
<td>
<p>GEOmap List </p>
</td></tr>
<tr><td><code id="GEOmap.Extract_+3A_sel">SEL</code></td>
<td>
<p>Selection of stroke indeces to include or exclude </p>
</td></tr>
<tr><td><code id="GEOmap.Extract_+3A_inout">INOUT</code></td>
<td>
<p>text, &quot;in&quot; means include, &quot;out&quot; means exclude </p>
</td></tr>
<tr><td><code id="GEOmap.Extract_+3A_lllim">LLlim</code></td>
<td>
<p>vector latlon limits </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Can either extract from the GEOmap data list with in, or exclude with
out.
fastExtract is the same but may be faster since it does not process
all the strokes in the base GEOmap.
</p>


<h3>Value</h3>

<table>
<tr><td><code>GEOmap</code></td>
<td>
<p>list</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>GEOmap.cat, GEOmap.Extract, GEOmap.CombineStrokes, list.GEOmap,
getGEOmap, plotGEOmap, SELGEOmap, boundGEOmap,   </p>


<h3>Examples</h3>

<pre><code class='language-R'>data(coastmap)
SEL=which(coastmap$STROKES$nam=="AMERICAS")
NSAMER =  GEOmap.Extract(coastmap,SEL, INOUT="in" )
plotGEOmap(NSAMER)

</code></pre>

<hr>
<h2 id='GEOmap.list'>GEOmap to list</h2><span id='topic+GEOmap.list'></span>

<h3>Description</h3>

<p>Inverse of list.GEOmap.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GEOmap.list(MAP, SEL = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GEOmap.list_+3A_map">MAP</code></td>
<td>
<p>GEOmap list </p>
</td></tr>
<tr><td><code id="GEOmap.list_+3A_sel">SEL</code></td>
<td>
<p>index, selecttion of specific strokes </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns the GEOmap strokes and instead of a long
vector for the points they are broken down into
a list of strokes.
</p>


<h3>Value</h3>

<table>
<tr><td><code>STROKES</code></td>
<td>
<p>Metadata for strokes</p>
</td></tr>
<tr><td><code>POINTS</code></td>
<td>
<p>list, lat=vector, lon=vector</p>
</td></tr>
<tr><td><code>LL</code></td>
<td>
<p>list of lat-lon strokes</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>GEOmap.cat, GEOmap.Extract, GEOmap.CombineStrokes, list.GEOmap</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(coastmap)
SEL=which(coastmap$STROKES$nam=='CUBA')
G = GEOmap.list(coastmap, SEL=SEL )

###  Lat-Lon of Cuba
G$LL



</code></pre>

<hr>
<h2 id='GEOsymbols'>GEOsymbols</h2><span id='topic+GEOsymbols'></span>

<h3>Description</h3>

<p>Plot a set of Geological Symbols
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GEOsymbols()
</code></pre>


<h3>Details</h3>

<p>Currently the choices in symbols are:
</p>

<p>contact
anticline
syncline
OverTurned-ant
OverTurned-syn
perp
thrust
normal
dextral
sinestral
detachment
bcars

</p>


<h3>Value</h3>

<p>Graphical Side effect
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>bcars, thrust, teeth, SynAnticline, SSfault, horseshoe,
strikeslip, OverTurned, normalfault, PointsAlong</p>


<h3>Examples</h3>

<pre><code class='language-R'>

GEOsymbols()


</code></pre>

<hr>
<h2 id='GEOTOPO'>Topographic Plot of geographic region</h2><span id='topic+GEOTOPO'></span>

<h3>Description</h3>

<p>Extract subset of a topographic database, interpolate and
plot using the persp program.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GEOTOPO(TOPO, PLOC, PROJ, calcol=NULL, nx=500, ny=500, nb = 4, mb = 4, hb = 8, PLOT=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GEOTOPO_+3A_topo">TOPO</code></td>
<td>
<p>list of x,y,z for a DEM </p>
</td></tr>
<tr><td><code id="GEOTOPO_+3A_ploc">PLOC</code></td>
<td>
<p>Location list, includes vectors LON and Lat</p>
</td></tr>
<tr><td><code id="GEOTOPO_+3A_proj">PROJ</code></td>
<td>
<p>projection</p>
</td></tr>
<tr><td><code id="GEOTOPO_+3A_calcol">calcol</code></td>
<td>
<p>color table for coloring elevations above sea level</p>
</td></tr>
<tr><td><code id="GEOTOPO_+3A_nx">nx</code></td>
<td>
<p>number of points in x grid, default=500</p>
</td></tr>
<tr><td><code id="GEOTOPO_+3A_ny">ny</code></td>
<td>
<p>number of points in y grid, default=500</p>
</td></tr>
<tr><td><code id="GEOTOPO_+3A_nb">nb</code></td>
<td>
<p>see function mba.surf, default = 4</p>
</td></tr>
<tr><td><code id="GEOTOPO_+3A_mb">mb</code></td>
<td>
<p>see function mba.surf, default = 4</p>
</td></tr>
<tr><td><code id="GEOTOPO_+3A_hb">hb</code></td>
<td>
<p>see function mba.surf , default= 8</p>
</td></tr>
<tr><td><code id="GEOTOPO_+3A_plot">PLOT</code></td>
<td>
<p> logical, TRUE=plot a map and return color map</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The return matrix PMAT is a rotation matrix used for adding
geographic (projected) data onto the perspective plot.
</p>
<p>ETOPO5 or ETOPO2 can be downloaded from
and installed using these links:
<a href="http://leesj.sites.oasis.unc.edu/FETCH/GRAB/RPACKAGES/ETOPO2.RData">http://leesj.sites.oasis.unc.edu/FETCH/GRAB/RPACKAGES/ETOPO2.RData</a>
and
<a href="http://leesj.sites.oasis.unc.edu/FETCH/GRAB/RPACKAGES/ETOPO5.RData">http://leesj.sites.oasis.unc.edu/FETCH/GRAB/RPACKAGES/ETOPO5.RData</a>
</p>


<h3>Value</h3>

<table>
<tr><td><code>PMAT</code></td>
<td>
<p>Matrix from persp, used for adding other geographic
information</p>
</td></tr>
<tr><td><code>xo</code></td>
<td>
<p>x-coordinates</p>
</td></tr>
<tr><td><code>yo</code></td>
<td>
<p>y-coordinates</p>
</td></tr>
<tr><td><code>IZ</code></td>
<td>
<p>interpolated elevations</p>
</td></tr>
<tr><td><code>Cmat</code></td>
<td>
<p>matrix of RGB Colors</p>
</td></tr>
<tr><td><code>Dcol</code></td>
<td>
<p>dimensions of Cmat</p>
</td></tr>
</table>


<h3>Note</h3>

<p>If PLOT is false the transform matrix PMAT and the color
mapping matrix Cmat will be returned as NA.
To create these for future plotting, use TOPOCOL or LandSeaCol
functions.  TOPOCOL simply assigns values above sea level with
one color scale and those below with under water colors.
LandSeaCol requires a coastal map and fills in
land areas with terrain colors and sea areas with blue palette colors.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>subsetTOPO, TOPOCOL,  LandSeaCol, settopocol,  subsetTOPO, persp, DOTOPOMAPI</p>


<h3>Examples</h3>

<pre><code class='language-R'>

## Not run: 

library(geomapdata)

####  need to download and install ETOPO data
###   data(ETOPO5)
load(ETOPO5)
PLOC=list(LON=c(137.008, 141.000),LAT=c(34.000, 36.992),
            x=c(137.008, 141.000), y=c(34.000, 36.992) )

 PROJ = setPROJ(type=2, LAT0=mean(PLOC$y) , LON0=mean(PLOC$x) )
COLS = settopocol()
JMAT = GEOTOPO(ETOPO5, PLOC, PROJ, COLS$calcol, nx=1000, ny=1000, nb=8, mb=8, hb=12, PLOT=TRUE)

############  this plot can be duplicated by using the output or GEOTOPO


 PMAT = persp(JMAT$xo, JMAT$yo, JMAT$IZ$z, theta = 0, phi = 90, r=4000,
col=JMAT$Cmat[1:(JMAT$Dcol[1]-1), 1:(JMAT$Dcol[2]-1)] , scale = FALSE,
      ltheta = 120, lphi=60, shade = 0.75, border = NA, expand=0.001, box = FALSE )



## End(Not run)


</code></pre>

<hr>
<h2 id='getETOPO'>Get Subset ETOPO Digital elevation map			
</h2><span id='topic+getETOPO'></span>

<h3>Description</h3>

<p>Extract from ETOPO5 or ETOPO2 data
a rectangular subset of the full data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getETOPO(topo, glat = c(-90, 90), glon = c(0, 360))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getETOPO_+3A_topo">topo</code></td>
<td>
<p>A DEM matrix, ETOPO5 or ETOPO2
</p>
</td></tr>
<tr><td><code id="getETOPO_+3A_glat">glat</code></td>
<td>
<p>2-vector, latitude limits
</p>
</td></tr>
<tr><td><code id="getETOPO_+3A_glon">glon</code></td>
<td>
<p>2-vector, longitude limits (these are converted 0-360
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ETOPO2 and ETOPO5 are stored in a strange way:
the lons are okay the latitudes are upside down.
</p>
<p>ETOPO5 or ETOPO2 can be downloaded from
and installed using these links:
<a href="http://leesj.sites.oasis.unc.edu/FETCH/GRAB/RPACKAGES/ETOPO2.RData">http://leesj.sites.oasis.unc.edu/FETCH/GRAB/RPACKAGES/ETOPO2.RData</a>
and
<a href="http://leesj.sites.oasis.unc.edu/FETCH/GRAB/RPACKAGES/ETOPO5.RData">http://leesj.sites.oasis.unc.edu/FETCH/GRAB/RPACKAGES/ETOPO5.RData</a>
</p>


<h3>Value</h3>

<p>Returns a matrix with attributes in lat-lon that are correct
for usage in image or other R imaging programs.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>image
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
library(geomapdata)
###  Download and install ETOPO Data
##    data(ETOPO5)
load(ETOPO5)
glat =c(45.4, 49)
glon = c(235, 243) 
b5 = getETOPO(ETOPO5, glat, glon)
image(x=attr(b5, 'lon'), y=attr(b5,'lat'), z=b5, col=terrain.colors(100) )
contour(   x=attr(b5, 'lon'), y=attr(b5,'lat'), z=b5, add=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='getGEOmap'>Get Geomap</h2><span id='topic+getGEOmap'></span>

<h3>Description</h3>

<p>Get Geomap from ascii files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGEOmap(fn)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGEOmap_+3A_fn">fn</code></td>
<td>
<p>root name</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Files are stored as a pair:  rootname.strks and rootname.pnts
</p>


<h3>Value</h3>

<table>
<tr><td><code>STROKES</code></td>
<td>
<p>List of stroke information:</p>
</td></tr>
<tr><td><code>nam</code></td>
<td>
<p>name of stroke</p>
</td></tr>
<tr><td><code>num</code></td>
<td>
<p>number of points</p>
</td></tr>
<tr><td><code>index</code></td>
<td>
<p>index where points start</p>
</td></tr>
<tr><td><code>col</code></td>
<td>
<p>color</p>
</td></tr>
<tr><td><code>style</code></td>
<td>
<p>plotting style: 1=point, 2=line,3=polygon</p>
</td></tr>
<tr><td><code>code</code></td>
<td>
<p>character, geological code</p>
</td></tr>
<tr><td><code>LAT1</code></td>
<td>
<p>bounding box lower left Lat</p>
</td></tr>
<tr><td><code>LAT2</code></td>
<td>
<p>bounding box upper right Lat</p>
</td></tr>
<tr><td><code>LON1</code></td>
<td>
<p>bounding box lower left Lon</p>
</td></tr>
<tr><td><code>LON2</code></td>
<td>
<p>bounding box upper right  Lon</p>
</td></tr>
<tr><td><code>POINTS</code></td>
<td>
<p>List of point LL coordinates, list(lat, lon)</p>
</td></tr>
<tr><td><code>PROJ</code></td>
<td>
<p>optional projection parameters</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>plotGEOmapXY, boundGEOmap</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
library(geomapdata)

 data(cosomap)
     data(faults)
     data(hiways)
     data(owens)

cosogeol = getGEOmap("/home/lees/XMdemo/GEOTHERM/cosogeol")

cosogeol = boundGEOmap(cosogeol)


 proj = cosomap$PROJ
    
plotGEOmapXY(cosomap, PROJ=proj,  add=FALSE, ann=FALSE, axes=FALSE)
  
 plotGEOmapXY(cosogeol, PROJ=proj,  add=TRUE, ann=FALSE, axes=FALSE)
  

  plotGEOmapXY(cosomap, PROJ=proj,  add=TRUE, ann=FALSE, axes=FALSE)
  
  plotGEOmapXY(faults, PROJ=proj,  add=TRUE, ann=FALSE, axes=FALSE)
  

## End(Not run)

</code></pre>

<hr>
<h2 id='getGEOperim'>Get Lat-Lon Perimeter</h2><span id='topic+getGEOperim'></span>

<h3>Description</h3>

<p>Get rectangular perimeter of region defined by set of Lat-Lon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getGEOperim(lon, lat, PROJ, N)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getGEOperim_+3A_lon">lon</code></td>
<td>
<p>vector of lons</p>
</td></tr>
<tr><td><code id="getGEOperim_+3A_lat">lat</code></td>
<td>
<p>vector of lats</p>
</td></tr>
<tr><td><code id="getGEOperim_+3A_proj">PROJ</code></td>
<td>
<p>projection structure</p>
</td></tr>
<tr><td><code id="getGEOperim_+3A_n">N</code></td>
<td>
<p>number of points per side</p>
</td></tr>
</table>


<h3>Details</h3>

<p>perimeter is used for antipolygon
</p>


<h3>Value</h3>

<p>List:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>x-coordinates projected</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>y-coordinates projected</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
###  target region
PLOC= list(LON=c(138.3152, 139.0214),
LAT=c(35.09047, 35.57324))

PLOC$x =PLOC$LON
PLOC$y =PLOC$LAT

####  set up projection
PROJ = setPROJ(type=2, LAT0=mean(PLOC$y) , LON0=mean(PLOC$x) )



perim= getGEOperim(PLOC$LON, PLOC$LAT, PROJ, 50)

</code></pre>

<hr>
<h2 id='getgreatarc'>Great Circle Arc</h2><span id='topic+getgreatarc'></span>

<h3>Description</h3>

<p>  Get points along great circle between two locations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getgreatarc(lat1, lon1, lat2, lon2, num)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getgreatarc_+3A_lat1">lat1</code></td>
<td>
<p>Latitude, point 1 (degrees)</p>
</td></tr>
<tr><td><code id="getgreatarc_+3A_lon1">lon1</code></td>
<td>
<p>Longitude, point 1 (degrees) </p>
</td></tr>
<tr><td><code id="getgreatarc_+3A_lat2">lat2</code></td>
<td>
<p>Latitude, point 2 (degrees) </p>
</td></tr>
<tr><td><code id="getgreatarc_+3A_lon2">lon2</code></td>
<td>
<p>Longitude, point 2 (degrees) </p>
</td></tr>
<tr><td><code id="getgreatarc_+3A_num">num</code></td>
<td>
<p>number of points along arc</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>lat</code></td>
<td>
<p>Latitude</p>
</td></tr>
<tr><td><code>lon</code></td>
<td>
<p>Longitude</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>getgreatarc, distaz</p>


<h3>Examples</h3>

<pre><code class='language-R'>PARIS = c(48.8666666666667, 2.33333333333333)
RIODEJANEIRO =c( -22.9,  -43.2333333333333)

g = getgreatarc(PARIS[1],PARIS[2], RIODEJANEIRO[1], RIODEJANEIRO[2],
100)
library(geomapdata)
data(worldmap)

plotGEOmap(worldmap, add=FALSE, shiftlon=180)

lines(g$lon+180, g$lat)

</code></pre>

<hr>
<h2 id='getmagsize'>Earthquake Magnitude based on exponentional
</h2><span id='topic+getmagsize'></span>

<h3>Description</h3>

<p>Estimate a size for plotting earthqukes
recorded as a logarithmic scale
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getmagsize(mag, minsize = 1, slope = 1, minmag = 0, maxmag = 8, style = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getmagsize_+3A_mag">mag</code></td>
<td>
<p>magnitudes from catalog
</p>
</td></tr>
<tr><td><code id="getmagsize_+3A_minsize">minsize</code></td>
<td>
<p>minimum size
</p>
</td></tr>
<tr><td><code id="getmagsize_+3A_slope">slope</code></td>
<td>
<p>slope for linear scale
</p>
</td></tr>
<tr><td><code id="getmagsize_+3A_minmag">minmag</code></td>
<td>
<p>min magnitude
</p>
</td></tr>
<tr><td><code id="getmagsize_+3A_maxmag">maxmag</code></td>
<td>
<p>max magnitude
</p>
</td></tr>
<tr><td><code id="getmagsize_+3A_style">style</code></td>
<td>
<p>Style of plotting: 0= all the same size; 1(default):
exponential scale; 2=linear scale
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The idea is to have a scale reflect the
size of the earthquake.
The default style (1) has a few parameters left over
from old program geotouch.
</p>


<h3>Value</h3>

<p>vector of sizes for plotting
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
mag = 0:9

x = runif(10, 1, 100)
y  = runif(10, 1, 100)

g = getmagsize(mag)

plot(c(0, 100), c(0, 100), asp=1, type='n')

points(x, y, pch=1, cex=g)




</code></pre>

<hr>
<h2 id='getnicetix'>Nice Looking Lat-Lon pairs for plotting</h2><span id='topic+getnicetix'></span>

<h3>Description</h3>

<p>Given a set of lat lon pairs, return a new set of tic marks
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getnicetix(lats, lons)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getnicetix_+3A_lats">lats</code></td>
<td>
<p>latitude range </p>
</td></tr>
<tr><td><code id="getnicetix_+3A_lons">lons</code></td>
<td>
<p>longitude range </p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>LAT</code></td>
<td>
<p>list output of niceLLtix</p>
</td></tr>
<tr><td><code>LON</code></td>
<td>
<p>list output of niceLLtix</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>niceLLtix</p>


<h3>Examples</h3>

<pre><code class='language-R'>proj = setPROJ(7, LAT0 = 0 , LON0= -93)
rx = c(652713.4, 656017.4)
ry = c(1629271, 1631755)

   gloc = XY.GLOB(rx, ry, proj)
    
    G = getnicetix(gloc$lat, gloc$lon)
 
print(G)





</code></pre>

<hr>
<h2 id='getspline'>Get a spline curve along a set of points</h2><span id='topic+getspline'></span>

<h3>Description</h3>

<p>Get a spline curve along a set of points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getspline(x, y, kdiv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getspline_+3A_x">x</code></td>
<td>
<p>x-coordinates</p>
</td></tr>
<tr><td><code id="getspline_+3A_y">y</code></td>
<td>
<p>y-coordinates</p>
</td></tr>
<tr><td><code id="getspline_+3A_kdiv">kdiv</code></td>
<td>
<p>number of divisions in each sections</p>
</td></tr>
</table>


<h3>Value</h3>

<p>LIST:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>x-coordinates</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>y-coordinates</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(c(-5,5), c(-5,5), asp=1, type='n' )
ff=list()
ff$x=c(-4.850,-4.700,-3.934,-2.528, 0.603, 2.647, 3.861, 2.626)
ff$y=c(-4.045,-2.087,-0.710, 0.172, 1.291, 2.087,-0.753,-4.131)

lines(ff, col='red')
G =getspline(ff$x, ff$y, kdiv=20)

lines(G, col='blue')


</code></pre>

<hr>
<h2 id='getsplineG'>Get a spline curve along a set of points</h2><span id='topic+getsplineG'></span>

<h3>Description</h3>

<p>Get a spline curve along a set of points
</p>


<h3>Usage</h3>

<pre><code class='language-R'>getsplineG(x, y, kdiv)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="getsplineG_+3A_x">x</code></td>
<td>
<p>x-coordinates</p>
</td></tr>
<tr><td><code id="getsplineG_+3A_y">y</code></td>
<td>
<p>y-coordinates</p>
</td></tr>
<tr><td><code id="getsplineG_+3A_kdiv">kdiv</code></td>
<td>
<p>number of divisions in each sections</p>
</td></tr>
</table>


<h3>Value</h3>

<p>LIST:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>x-coordinates</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>y-coordinates</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(c(-5,5), c(-5,5), asp=1, type='n' )
ff=list()
ff$x=c(-4.850,-4.700,-3.934,-2.528, 0.603, 2.647, 3.861, 2.626)
ff$y=c(-4.045,-2.087,-0.710, 0.172, 1.291, 2.087,-0.753,-4.131)

lines(ff, col='red')
G =getsplineG(ff$x, ff$y, kdiv=20)

lines(G, col='blue')


</code></pre>

<hr>
<h2 id='GETXprofile'>Cross sectional profile through a digital elevation map </h2><span id='topic+GETXprofile'></span>

<h3>Description</h3>

<p>Example of how to use RPMG button functions.  This example
shows how to plot a DEM and interactively change the plot
and find projected cross-sections through a surface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GETXprofile(jx, jy, jz, LAB = "A", myloc = NULL, PLOT = FALSE, NEWDEV=TRUE,  asp=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GETXprofile_+3A_jx">jx</code>, <code id="GETXprofile_+3A_jy">jy</code></td>
<td>
<p>locations of grid lines at which the values in 'jz' are measured.</p>
</td></tr>
<tr><td><code id="GETXprofile_+3A_jz">jz</code></td>
<td>
<p>a matrix containing the values to be plotted   </p>
</td></tr>
<tr><td><code id="GETXprofile_+3A_lab">LAB</code></td>
<td>
<p>Alphanumeric (A-Z) for labeling a cross section </p>
</td></tr>
<tr><td><code id="GETXprofile_+3A_myloc">myloc</code></td>
<td>
<p>Out put of Locator function </p>
</td></tr>
<tr><td><code id="GETXprofile_+3A_plot">PLOT</code></td>
<td>
<p>logical. Plot is created if TRUE </p>
</td></tr>
<tr><td><code id="GETXprofile_+3A_newdev">NEWDEV</code></td>
<td>
<p>logical. Plot is on a new device if TRUE </p>
</td></tr>
<tr><td><code id="GETXprofile_+3A_asp">asp</code></td>
<td>
<p>aspect ration for plotting, see par </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The program uses a similar input format as image or contour,
with structure from the locator() function of x and y coordinates
that determine where the cross section is to be extracted.
</p>


<h3>Value</h3>

<p>Returns a list of x,z values representing the projected values along
the cross section.
</p>
<table>
<tr><td><code>RX</code></td>
<td>
<p>distance along cross section</p>
</td></tr>
<tr><td><code>RZ</code></td>
<td>
<p>values extracted from the elevation map</p>
</td></tr>
</table>


<h3>Note</h3>

<p>The program is an auxiliary program provided to illustrate the RPMG
interactive R analysis.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>locator, image</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run:  
#######  get data 
   data(volcano)
####  extract dimensions of image
   nx = dim(volcano)[1]
   ny = dim(volcano)[2]

###  establish units of image
   jx = 10*seq(from=0, to=nx-1)
   jy = 10*seq(from=0, to=ny-1)

####  set a letter for the cross section
   LAB = LETTERS[1]

###  coordinates of cross section on image
###  this is normally set by using the locator() function
   x1 = 76.47351
   y1 = 231.89055
   x2 = 739.99746
   y2 = 464.08185

## extract and plot cross section

 GETXprofile(jx, jy, volcano, myloc=list(x=c(x1, x2), y=c(y1, y2)), LAB=LAB, PLOT=TRUE)
            
## End(Not run)
</code></pre>

<hr>
<h2 id='GLOB.XY'>Convert from GLOBAL LAT-LON to X-Y</h2><span id='topic+GLOB.XY'></span>

<h3>Description</h3>

<p>Convert from GLOBAL LAT-LON to X-Y
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GLOB.XY(LAT, LON, PROJ.DATA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GLOB.XY_+3A_lat">LAT</code></td>
<td>
<p>Latitude</p>
</td></tr>
<tr><td><code id="GLOB.XY_+3A_lon">LON</code></td>
<td>
<p>Longitude</p>
</td></tr>
<tr><td><code id="GLOB.XY_+3A_proj.data">PROJ.DATA</code></td>
<td>
<p>Projection list </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Units should be given according to the projection.
This is the inverse of  XY.GLOB.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>X in whatever units</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Y in whatever units</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>References</h3>

<p>Snyder, John P., Map Projections- a working manual, USGS, Professional Paper, 1987.
</p>


<h3>See Also</h3>

<p>XY.GLOB</p>


<h3>Examples</h3>

<pre><code class='language-R'>

proj = setPROJ(type = 2, LAT0 =23, LON0 = 35)

### get lat-lon
LL = XY.GLOB(200, 300, proj)


##  find x-y again, should be the same
XY = GLOB.XY(LL$lat, LL$lon, proj)
XY


</code></pre>

<hr>
<h2 id='GLOBE.ORTH'>Plot globe with orthogonal
</h2><span id='topic+GLOBE.ORTH'></span>

<h3>Description</h3>

<p>Plot globe with orthogonal
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GLOBE.ORTH(lam0, phi1, R = 1, plotmap = TRUE, plotline=TRUE, add=FALSE,
 map = coastmap, mapcol = grey(0.2), linecol = grey(0.7), fill=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GLOBE.ORTH_+3A_lam0">lam0</code></td>
<td>
<p>view origin longitude, degrees
</p>
</td></tr>
<tr><td><code id="GLOBE.ORTH_+3A_phi1">phi1</code></td>
<td>
<p>view origin  latitude, degrees
</p>
</td></tr>
<tr><td><code id="GLOBE.ORTH_+3A_r">R</code></td>
<td>
<p>Radius of sphere, default=1
</p>
</td></tr>
<tr><td><code id="GLOBE.ORTH_+3A_plotmap">plotmap</code></td>
<td>
<p>logical, default=TRUE, add map
</p>
</td></tr>
<tr><td><code id="GLOBE.ORTH_+3A_plotline">plotline</code></td>
<td>
<p>logical, default=TRUE, add grid of lat-lons
</p>
</td></tr>
<tr><td><code id="GLOBE.ORTH_+3A_add">add</code></td>
<td>
<p>logical, default=FALSE, Do not start a new plot, rather add to
existing plot
</p>
</td></tr>
<tr><td><code id="GLOBE.ORTH_+3A_map">map</code></td>
<td>
<p>GEOmap list
</p>
</td></tr>
<tr><td><code id="GLOBE.ORTH_+3A_mapcol">mapcol</code></td>
<td>
<p>color for map
</p>
</td></tr>
<tr><td><code id="GLOBE.ORTH_+3A_linecol">linecol</code></td>
<td>
<p>color for meridians and parallels
</p>
</td></tr>
<tr><td><code id="GLOBE.ORTH_+3A_fill">fill</code></td>
<td>
<p>fill polygons with color, default=FALSE
</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>Plots whole globe with grid.
</p>


<h3>Value</h3>

<p>Graphical Side effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Snyder, John P., Map Projections- a working manual, USGS, Professional Paper, 1987.
</p>


<h3>See Also</h3>

<p>setPROJ, projtype, plotGEOmap
</p>


<h3>Examples</h3>

<pre><code class='language-R'>######  simple map of world viewed at 40 degrees latitude
R = 1
R.MAPK = 6378.2064

phi1=40

viewlam = seq(from=0, to=340, by=2)

data(coastmap)

K=1
GLOBE.ORTH(viewlam[K], phi1, R=1, plotmap=TRUE)
######


OLIM = c(20, 40, 10, 40)
TLIM = c(-20, -10, -30, -10)


 olat = runif(1, OLIM[1], OLIM[2])
         olon = runif(1, OLIM[3], OLIM[4] )

          tlat = runif(1,TLIM[1], TLIM[2] )
         tlon = runif(1, TLIM[3], TLIM[4])

GLOBE.ORTH(olon, olat, 1,plotmap=FALSE )

 XYorg = ortho.proj(olat, olon, olon, olat, 1)
 XYtarg = ortho.proj(tlat, tlon, olon, olat, 1)

points( XYorg , col='red')
points(XYtarg , col='blue')
 da = distaz(olat, olon, tlat, tlon)
 ed2 =  Ellipsoidal.Distance(olat, olon, tlat, tlon, a=R.MAPK*1000, b=R.MAPK*1000)

  A = along.great(olat*pi/180, olon*pi/180,
seq(from=0, to=da$del, by=2)*pi/180,  da$az*pi/180)

     lat=A$phi*180/pi
     lon = A$lam*180/pi

 XYalong = ortho.proj(lat, lon, olon, olat, 1)

lines(XYalong , col='purple')

M = merid(tlon, lat1=tlat, phi1=olat, lam0=olon, R=1, by=2)

lines(M$x, M$y, col='blue' )

M2 = merid(olon, lat1=olat,  phi1=olat, lam0=olon,R=1, by=2)

lines(M2$x, M2$y, col='red' )

 leg = c( paste("del=", round(da$del)), paste("DA=", round(da$az),
 round(da$baz) ),
 paste("ED=", round(ed2$az) ,  round(ed2$revaz) ))
 
legend("topleft", legend=leg)







</code></pre>

<hr>
<h2 id='GlobeView'>Global Plot</h2><span id='topic+GlobeView'></span>

<h3>Description</h3>

<p>Plot global view of the earth
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GlobeView(phicen, lamcen, worldmap, MAXR, SEL = 1,
circol = rgb(1, 0.8, 0.8), innercol = "white", linecol = rgb(0, 0, 0),
 mapcol = rgb(0, 0, 0), backcol = "white", add=FALSE, antip=TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="GlobeView_+3A_phicen">phicen</code></td>
<td>
<p>Latitude</p>
</td></tr>
<tr><td><code id="GlobeView_+3A_lamcen">lamcen</code></td>
<td>
<p>Longitude</p>
</td></tr>
<tr><td><code id="GlobeView_+3A_worldmap">worldmap</code></td>
<td>
<p>Map List</p>
</td></tr>
<tr><td><code id="GlobeView_+3A_maxr">MAXR</code></td>
<td>
<p>Maximum radius (degrees)</p>
</td></tr>
<tr><td><code id="GlobeView_+3A_sel">SEL</code></td>
<td>
<p>Selection index from map</p>
</td></tr>
<tr><td><code id="GlobeView_+3A_circol">circol</code></td>
<td>
<p>color for concentric circles</p>
</td></tr>
<tr><td><code id="GlobeView_+3A_innercol">innercol</code></td>
<td>
<p>inner color</p>
</td></tr>
<tr><td><code id="GlobeView_+3A_linecol">linecol</code></td>
<td>
<p>line color, NA=do not plot</p>
</td></tr>
<tr><td><code id="GlobeView_+3A_mapcol">mapcol</code></td>
<td>
<p>map fill color, NA=do not fill polygon</p>
</td></tr>
<tr><td><code id="GlobeView_+3A_backcol">backcol</code></td>
<td>
<p>background color</p>
</td></tr>
<tr><td><code id="GlobeView_+3A_add">add</code></td>
<td>
<p>logical, FALSE means start a new plot</p>
</td></tr>
<tr><td><code id="GlobeView_+3A_antip">antip</code></td>
<td>
<p>logical, default=TRUE means white out area outside of polygon</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a plot of view of the globe from
a point in space using an Equal-Area projection.
Uses the lamaz.eqarea routine for projection. (Lambert-Azimuthal Equal
Area).  Using NA for linecol or mapcol means do not plot lines or fill
polygons respectively.
</p>


<h3>Value</h3>

<table>
<tr><td><code>Perimeter</code></td>
<td>
<p>x,y points around the perimeter of the plot</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>plotGEOmap, lamaz.eqarea</p>


<h3>Examples</h3>

<pre><code class='language-R'>

data(coastmap)

phicen  =32.20122+5
lamcen  = 335.7092+20
MAXR    = 100

carolinablue = rgb(83/255, 157/255, 194/255)


SEL=which( coastmap$STROKES$code=="C")
SEL = c(SEL, which(coastmap$STROKES$nam=="GreatBritain"),
which(coastmap$STROKES$nam=="Japan"), which(coastmap$STROKES$nam=="Ireland"))


PER = GlobeView(phicen, lamcen, SEL=SEL, coastmap, MAXR,
linecol=rgb(.2, .2, .2), mapcol=rgb(.8, .8, .8), 
innercol=carolinablue , circol=carolinablue ,    backcol="white")

</code></pre>

<hr>
<h2 id='gmat'>Globe Rotation Matrix
</h2><span id='topic+gmat'></span>

<h3>Description</h3>

<p>Globe Rotation Matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gmat(vec, p, alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gmat_+3A_vec">vec</code></td>
<td>
<p> vector axis to rotate about
</p>
</td></tr>
<tr><td><code id="gmat_+3A_p">p</code></td>
<td>
<p> translation point (c(0,0,0))
</p>
</td></tr>
<tr><td><code id="gmat_+3A_alpha">alpha</code></td>
<td>
<p> angle to rotate, degrees 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Given an arbitrary axis, return matrix for rotation about the
axis by alpha degrees.
</p>


<h3>Value</h3>

<p>4 by 4 Matrix for translation and rotation
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Rogers and Adams
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

################   kamchatka

kamlat = c(48.5,  65)
kamlon = c(150, 171)

KAMLAT0=mean(kamlat)
KAMLON0=mean(kamlon)


################  korea

 KORlon = c(123,133)
    KORlat = c(33,44)


KORLON0=mean(KORlon)
KORLAT0=mean(KORlat)

# convert to cartesian
v1 = ll2xyz(KORLAT0, KORLON0 )
v2 = ll2xyz(KAMLAT0,  KAMLON0)

###   get cross product
g = X.prod((v1), (v2))

### use dot product to get angle
delta = (180/pi)*acos( sum(v1*v2)/(sqrt(sum(v1^2))*sqrt(sum(v2^2))))

###   get rotation matrix
R1 =gmat(g, c(0,0,0) , -delta)


</code></pre>

<hr>
<h2 id='goodticdivs'>Nice tic division</h2><span id='topic+goodticdivs'></span>

<h3>Description</h3>

<p>Determine a reasonable tick division for
lat-lon tic marks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>goodticdivs(ddeg)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="goodticdivs_+3A_ddeg">ddeg</code></td>
<td>
<p>degree differnce</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Designed to give approximately 4-6 divisions
for plotting given the range input.
</p>


<h3>Value</h3>

<table>
<tr><td><code>K</code></td>
<td>
<p>suggested divisor</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>niceLLtix</p>


<h3>Examples</h3>

<pre><code class='language-R'>
goodticdivs(20)
goodticdivs(100)



</code></pre>

<hr>
<h2 id='horseshoe'>Horseshoe Symbol</h2><span id='topic+horseshoe'></span>

<h3>Description</h3>

<p>Draw a Horseshoe Symbol
</p>


<h3>Usage</h3>

<pre><code class='language-R'>horseshoe(x, y, r1 = 1, r2 = 1.2, h1 = 0.5, h2 = 0.5, rot = list(cs = 1,
sn = 0), col = "black", lwd = lwd, fill=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="horseshoe_+3A_x">x</code></td>
<td>
<p>x-coordinates</p>
</td></tr>
<tr><td><code id="horseshoe_+3A_y">y</code></td>
<td>
<p>y-coordinates</p>
</td></tr>
<tr><td><code id="horseshoe_+3A_r1">r1</code></td>
<td>
<p>x-radius of curled part</p>
</td></tr>
<tr><td><code id="horseshoe_+3A_r2">r2</code></td>
<td>
<p>y-radius of curled part</p>
</td></tr>
<tr><td><code id="horseshoe_+3A_h1">h1</code></td>
<td>
<p>length of first leg</p>
</td></tr>
<tr><td><code id="horseshoe_+3A_h2">h2</code></td>
<td>
<p>length of 2nd leg</p>
</td></tr>
<tr><td><code id="horseshoe_+3A_rot">rot</code></td>
<td>
<p>rotation, cos, sine</p>
</td></tr>
<tr><td><code id="horseshoe_+3A_col">col</code></td>
<td>
<p>color of teeth and line</p>
</td></tr>
<tr><td><code id="horseshoe_+3A_lwd">lwd</code></td>
<td>
<p>line width</p>
</td></tr>
<tr><td><code id="horseshoe_+3A_fill">fill</code></td>
<td>
<p>logical, TRUE=fill</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Grapical Side Effect
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu</p>


<h3>See Also</h3>

<p>PointsAlong</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ff=list()
ff$x=c(-4.850,-4.700,-3.934,-2.528, 0.603, 2.647, 3.861, 2.626)
ff$y=c(-4.045,-2.087,-0.710, 0.172, 1.291, 2.087,-0.753,-4.131)

G =getsplineG(ff$x, ff$y, kdiv=20)
g = PointsAlong(G$x, G$y, N=5)

plot(c(-5,5), c(-5,5), asp=1, type='n' )
lines(G)

horseshoe(g$x  , g$y , r1=.5, r2=.8, h2=0, h1=0, rot=g$rot , col='blue')


###  to make a "warm front" use something liek this:
###  shorten r2 relative to r1, to get a more squat shape for the half-suns

plot(c(-5,5), c(-5,5), asp=1, type='n' )

w1=list()
w1$x=c(-1.208, 0.113, 1.242, 2.200, 2.349)
w1$y=c( 3.206, 2.280, 0.344,-2.560,-3.485)
G =getsplineG(w1$x, w1$y, kdiv=20)
lines(G)
g = PointsAlong(G$x, G$y, N=5)

horseshoe(g$x  , g$y , r1=.5, r2=.4, h2=0, h1=0, rot=g$rot , col='blue')




</code></pre>

<hr>
<h2 id='inpoly'>Test set of points for inside/outside polygon</h2><span id='topic+inpoly'></span>

<h3>Description</h3>

<p>takes a set of points and tests with function inside()
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inpoly(x, y, POK)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inpoly_+3A_x">x</code></td>
<td>
<p>x coordinates</p>
</td></tr>
<tr><td><code id="inpoly_+3A_y">y</code></td>
<td>
<p>y coordinates</p>
</td></tr>
<tr><td><code id="inpoly_+3A_pok">POK</code></td>
<td>
<p>polygon structure list x,y</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns vector of 0,1 for points inside polygon
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>Lintersect, ccw, inside </p>


<h3>Examples</h3>

<pre><code class='language-R'>H=list()
H$x=c(-0.554,-0.258,0.062,0.538,0.701,0.332,
0.34,0.26,-0.189,0.081,0.519,0.644,0.264,
-0.086,-0.216,-0.246,-0.356,-1.022,-0.832,
-0.372,-0.463,-0.604)
H$y=c(0.047,-0.4,-0.818,-0.822,-0.314,-0.25,
-0.491,-0.589,-0.396,-0.138,0.082,0.262,0.542,
0.361,0.03,0.555,0.869,0.912,0.641,0.327,0.142,0.129)

plot(c(-1,1), c(-1,1), type='n')

polygon(H, col=NULL, border=grey(.8))

x = runif(20, -1,1)
y =  runif(20, -1,1)
points(list(x=x, y=y) )

inp = inpoly(x, y, H)

text(x[inp==0],y[inp==0], labels="out", pos=1, col='red')
text(x[inp==1],y[inp==1], labels="in", pos=1, col='blue')



</code></pre>

<hr>
<h2 id='insertNA'>Insert NA in a vector</h2><span id='topic+insertNA'></span>

<h3>Description</h3>

<p>Inserting NA values in a vector at specific index locations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insertNA(y, ind)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="insertNA_+3A_y">y</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="insertNA_+3A_ind">ind</code></td>
<td>
<p>index locations where NA is inserted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The vector is parsed out and NA values are inserted where
after the index values provided.  
</p>


<h3>Value</h3>

<table>
<tr><td><code>v</code></td>
<td>
<p>new vector with NA's</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x = 1:10
 insertNA(x, 6)
</code></pre>

<hr>
<h2 id='insertvec'>Insert a set of values in a vector</h2><span id='topic+insertvec'></span>

<h3>Description</h3>

<p>Inserting values in a vector at specific index locations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insertvec(v, ind, val)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="insertvec_+3A_v">v</code></td>
<td>
<p>vector</p>
</td></tr>
<tr><td><code id="insertvec_+3A_ind">ind</code></td>
<td>
<p>ndex locations where val is inserted</p>
</td></tr>
<tr><td><code id="insertvec_+3A_val">val</code></td>
<td>
<p>some vector of insertion, maybe NA</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The vector is parsed out and val values are inserted where
after the index values provided.   
</p>


<h3>Value</h3>

<table>
<tr><td><code>v</code></td>
<td>
<p>new vector with val inserted after the index</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>  x = 1:20

 insertvec(x, c(4,17) , NA)
</code></pre>

<hr>
<h2 id='inside'>Determine if point is inside polygon</h2><span id='topic+inside'></span>

<h3>Description</h3>

<p>Given a polygon and a point, determine if point is
internal to polygon.
The code counts the number of intersection
the point and a dummy point with a very large x-value
makes with the polygon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>inside(A, POK)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="inside_+3A_a">A</code></td>
<td>
<p>Point, list with x, y</p>
</td></tr>
<tr><td><code id="inside_+3A_pok">POK</code></td>
<td>
<p>list of x,y values of polygon </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns integer, 0=no intersection, 1=intersection
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>Lintersect, ccw, inpoly</p>


<h3>Examples</h3>

<pre><code class='language-R'>
####  make a polygon:
H=list()
H$x=c(-0.554,-0.258,0.062,0.538,0.701,0.332,
0.34,0.26,-0.189,0.081,0.519,0.644,0.264,-0.086,
-0.216,-0.246,-0.356,-1.022,-0.832,-0.372,-0.463,-0.604)
H$y=c(0.047,-0.4,-0.818,-0.822,-0.314,-0.25,
-0.491,-0.589,-0.396,-0.138,0.082,0.262,0.542,
0.361,0.03,0.555,0.869,0.912,0.641,0.327,0.142,0.129)

l1 = list(p1=list(x=-0.83587, y=-0.5765),
p2=list(x=0.731603,y=0.69705))
l2 = list(p1=list(x=-0.6114, y=0.7745),
p2=list(x=0.48430,y=-0.63250))

plot(c(-1,1), c(-1,1), type='n')

polygon(H, col=NULL, border='blue')
points(l1$p1)

####  if point is in polygon, return 1, else return 1
inside(l1$p1, H)
text(l1$p1  , labels=inside(l1$p1, H), pos=1)
points(l2$p1)
inside(l2$p1, H)
text(l2$p1  , labels=inside(l2$p1, H), pos=1)

</code></pre>

<hr>
<h2 id='insideGEOmapXY'>Get LAT-LON points that fall inside a map</h2><span id='topic+insideGEOmapXY'></span>

<h3>Description</h3>

<p>Get LAT-LON points that fall inside a map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>insideGEOmapXY(lat, lon, PROJ = NULL, R = NULL, PMAT = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="insideGEOmapXY_+3A_lat">lat</code></td>
<td>
<p>vector of latitudes</p>
</td></tr>
<tr><td><code id="insideGEOmapXY_+3A_lon">lon</code></td>
<td>
<p>vector of longitudes</p>
</td></tr>
<tr><td><code id="insideGEOmapXY_+3A_proj">PROJ</code></td>
<td>
<p>projection structure</p>
</td></tr>
<tr><td><code id="insideGEOmapXY_+3A_pmat">PMAT</code></td>
<td>
<p>persp matrix for perspective plot</p>
</td></tr>
<tr><td><code id="insideGEOmapXY_+3A_r">R</code></td>
<td>
<p>List(lat, lon, radius) for selecting instead of using usr coordinates</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameters par(&quot;usr&quot;) is queried and used to select the
lat and lons that fall within the mapped region.  If the list
R=list(lat, lon, radius) is provided, then all indeces of points falling within
that radius are returned.
</p>


<h3>Value</h3>

<p>Vector of index values for points that satisfy geographic criteria
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

data('japmap', package='geomapdata' )
isel1 = which( japmap$STROKES$code != "i" &amp; japmap$STROKES$num&gt;120 )

 PROJfuji = setPROJ(type = 2, LAT0=35.358,LON0=138.731)
plotGEOmapXY(japmap, PROJ=PROJfuji, SEL=isel1 , add=FALSE)
pointsGEOmapXY(gvol$lat, gvol$lon,  PROJ=PROJfuji)
textGEOmapXY(gvol$lat, gvol$lon, gvol$name,  PROJ=PROJfuji, pos=4,
cex=.5)
wv =insideGEOmapXY(gvol$lat, gvol$lon, PROJfuji)
cbind(gvol$name[wv], gvol$lat[wv], gvol$lon[wv])



## End(Not run)




</code></pre>

<hr>
<h2 id='jarea'>
Area of closed polygon.
</h2><span id='topic+jarea'></span>

<h3>Description</h3>

<p>Returns area of polygon.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jarea(L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jarea_+3A_l">L</code></td>
<td>
<p> list with x,y components
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If polygon is counter clockwise (CCW) area will be positive,
else negative.  If not sure, take absolute value of output.
</p>


<h3>Value</h3>

<p>Area in dimensions of x,y
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(12)
X = runif(10, 1, 100)
    Y = runif(10, 1, 100)

    hc = chull(X, Y)
#### looks like chull returns points in clockwise
    L = list(x=X[hc] , y=Y[hc] )

  j1 = jarea(L )

#########  reverse order of polygon
jc = rev(hc)
    L = list(x=X[jc] , y=Y[jc] )
 j2 = jarea(L )



</code></pre>

<hr>
<h2 id='KINOUT'>Map inside-outside
</h2><span id='topic+KINOUT'></span>

<h3>Description</h3>

<p>Determine if strokes
are in a target region
</p>


<h3>Usage</h3>

<pre><code class='language-R'>KINOUT(MAP, LLlim, projtype = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="KINOUT_+3A_map">MAP</code></td>
<td>
<p>GEOmap list 
</p>
</td></tr>
<tr><td><code id="KINOUT_+3A_lllim">LLlim</code></td>
<td>
<p>list: lat lon limits
</p>
</td></tr>
<tr><td><code id="KINOUT_+3A_projtype">projtype</code></td>
<td>
<p>local projection type
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The limits are used to calculate an origin
and each point is projected accordingly.
The x-y values are evaluated
for being in or out of the target.
A local projection is used - UTM (2) is the prefered
projection.  
</p>


<h3>Value</h3>

<p>Vector or indeces of strokes that intersect the target.
</p>


<h3>Note</h3>

<p> The mercator projections
do not work well with this routine.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>inpoly, 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(geomapdata)
data(worldmap)
data(coastmap)
L = list(lon=c(163.59, 182.95), lat=c(-48.998, -32.446))


k = KINOUT(worldmap,L, 2)

###  which strokes are these?

 print( worldmap$STROKES$nam[k] )


k = KINOUT(coastmap,L, 2)

 print( coastmap$STROKES$nam[k] )


testmap =  GEOmap.Extract(coastmap,k, INOUT="in" )

 plotGEOmap(testmap)



</code></pre>

<hr>
<h2 id='lamaz.eqarea'>Lambert-Azimuthal Equal Area</h2><span id='topic+lamaz.eqarea'></span><span id='topic+lamaz.inverse'></span>

<h3>Description</h3>

<p>Map Projection (Lambert-Azimuthal Equal Area) for global plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lamaz.eqarea(phi1, lam0, phi, lam, R=6371)
lamaz.inverse(phi1, lam0, x, y, R=6371 ) 

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lamaz.eqarea_+3A_phi1">phi1</code></td>
<td>
<p>Central Latitude, radians</p>
</td></tr>
<tr><td><code id="lamaz.eqarea_+3A_lam0">lam0</code></td>
<td>
<p>Central Longitude</p>
</td></tr>
<tr><td><code id="lamaz.eqarea_+3A_phi">phi</code></td>
<td>
<p>vector of Latitude, points for plotting, radians</p>
</td></tr>
<tr><td><code id="lamaz.eqarea_+3A_lam">lam</code></td>
<td>
<p>vector of Longitude, points for plotting , radians</p>
</td></tr>
<tr><td><code id="lamaz.eqarea_+3A_r">R</code></td>
<td>
<p> radius of sphere </p>
</td></tr>
<tr><td><code id="lamaz.eqarea_+3A_x">x</code></td>
<td>
<p>position on the plot</p>
</td></tr>		
<tr><td><code id="lamaz.eqarea_+3A_y">y</code></td>
<td>
<p>position on the plot</p>
</td></tr>		
</table>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>position on the plot</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>position on the plot</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This is a projection routine that does not need
to be set in advance. lamaz.inverse is the inverse of lamaz.eqarea.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>References</h3>

<p>Snyder, J. P., 1987; Map Projections - A Working Manual. U.S. Geological Survey Professional Paper 1395, 383 p.</p>


<h3>See Also</h3>

<p>setPROJ</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(coastmap)
#########  coastmap is a GEOmap list
DEGRAD = pi/180

phicen  = -90*DEGRAD
lamcen  = 0*DEGRAD

i = 7
j1 = coastmap$STROKES$index[i]+1
j2 = j1+ coastmap$STROKES$num[i]-1
lat = coastmap$POINTS$lat[j1:j2]*DEGRAD
lon = coastmap$POINTS$lon[j1:j2]*DEGRAD

 xy = lamaz.eqarea(phicen, lamcen,lat, lon)

plot(xy, asp=1, type='n')


 polygon(xy, col=grey(.8))

title("Antarctica")




</code></pre>

<hr>
<h2 id='LandSeaCol'>Land and Sea Colors
</h2><span id='topic+LandSeaCol'></span>

<h3>Description</h3>

<p>Color pixels with two
palettes, one for land the other for sea.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LandSeaCol(IZ, coastmap, PROJ, calcol = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LandSeaCol_+3A_iz">IZ</code></td>
<td>
<p>list of x, y, z suitable for plotting
with image or contour.
</p>
</td></tr>
<tr><td><code id="LandSeaCol_+3A_coastmap">coastmap</code></td>
<td>
<p>coastal map from GEOmap
</p>
</td></tr>
<tr><td><code id="LandSeaCol_+3A_proj">PROJ</code></td>
<td>
<p>projection list
</p>
</td></tr>
<tr><td><code id="LandSeaCol_+3A_calcol">calcol</code></td>
<td>
<p>color map for the land
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The program uses closed polygons in
the map list to separate the pixels
into land versus sea.  Sea is colored with
a palette of blues, land is colored according to
topographic color scheme extracted from
palettes similar to GMT palettes.
</p>
<p>All map and pixel coordinates are
projected with the same projection parameters.
calculations are done in XY coordinates.
</p>
<p>ETOPO5 or ETOPO2 can be downloaded from
and installed using these links:
<a href="http://leesj.sites.oasis.unc.edu/FETCH/GRAB/RPACKAGES/ETOPO2.RData">http://leesj.sites.oasis.unc.edu/FETCH/GRAB/RPACKAGES/ETOPO2.RData</a>
and
<a href="http://leesj.sites.oasis.unc.edu/FETCH/GRAB/RPACKAGES/ETOPO5.RData">http://leesj.sites.oasis.unc.edu/FETCH/GRAB/RPACKAGES/ETOPO5.RData</a>
</p>


<h3>Value</h3>

<table>
<tr><td><code>Cmat</code></td>
<td>
<p>Matrix of colors for each pixel</p>
</td></tr>
<tr><td><code>UZ</code></td>
<td>
<p>Under water </p>
</td></tr>
<tr><td><code>AZ</code></td>
<td>
<p>Above Sea Level</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>settopocol, TOPOCOL
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

Lat.range = c(-10, 30)
Lon.range = c(65, 117)
######

########  load up the important libraries
 library(RFOC)

 library(geomapdata)

 data(coastmap)

  ###    data(ETOPO5)

####  need to download and install ETOPO data
load(ETOPO5)

 PLOC=list(LON=Lon.range,LAT=Lat.range,lon=Lon.range,lat=Lat.range,
                 x=Lon.range, y=Lat.range )


#####   set up topography colors
COLS = settopocol()

####  set the projection ##   utm
 PROJ = setPROJ(type=2, LAT0=mean(PLOC$y) , LON0=mean(PLOC$x) )   
 NK = 300
    
   ###   extract topography from the etopo5 data base in geomapdata
     JMAT = GEOTOPO(ETOPO5, PLOC, PROJ, COLS$calcol,nx=NK, ny=NK )
#####   select relevant earthquakes

IZ = list(x=JMAT$xo, y=JMAT$yo, z=JMAT$IZ$z)

CMAT = LandSeaCol(IZ, coastmap, PROJ, calcol=NULL)

Mollist =CMAT$Cmat
dMol = attr(Mollist, "Dcol")

     ####  Under water
UZ = CMAT$UZ
    #####  above water
AZ = CMAT$AZ
    ####   blues for underwater:
   blues = shade.col(100, acol=as.vector(col2rgb("darkblue")/255),
        bcol= as.vector(col2rgb("paleturquoise")/255))

plot(x=range(IZ$x), y=range(IZ$y),
         type='n', asp=1, axes=FALSE, ann=FALSE)

image(x=IZ$x, y=IZ$y, z=(UZ), col=blues, add=TRUE)

image(x=IZ$x, y=IZ$y, z=(AZ), col=terrain.colors(100) , add=TRUE)

plotGEOmapXY(coastmap,
       LIM = c(Lon.range[1],Lat.range[1] ,Lon.range[2] ,Lat.range[2]),
       PROJ =PROJ,MAPstyle =2,MAPcol ="black" ,   add=TRUE  )





## End(Not run)


</code></pre>

<hr>
<h2 id='lcgc'>local coordinates to Global</h2><span id='topic+lcgc'></span>

<h3>Description</h3>

<p>OLD projection sometimes used in Lees' tomography. No need for
projection data, it is included in the code.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lcgc(phiorg, lamorg, ex, why)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lcgc_+3A_phiorg">phiorg</code></td>
<td>
<p> lat origin</p>
</td></tr>
<tr><td><code id="lcgc_+3A_lamorg">lamorg</code></td>
<td>
<p>lon origin</p>
</td></tr>
<tr><td><code id="lcgc_+3A_ex">ex</code></td>
<td>
<p>coordinate, km </p>
</td></tr>
<tr><td><code id="lcgc_+3A_why">why</code></td>
<td>
<p>coordinate, km  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>This may be defunct now.
</p>


<h3>Value</h3>

<table>
<tr><td><code>phi</code></td>
<td>
<p>lat</p>
</td></tr>
<tr><td><code>lam</code></td>
<td>
<p>lon</p>
</td></tr>
</table>


<h3>Note</h3>

<p>Orignally from R. S. Crosson</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>gclc</p>

<hr>
<h2 id='linesGEOmapXY'>Add lines, points or text to GEOmap projected plot</h2><span id='topic+linesGEOmapXY'></span><span id='topic+pointsGEOmapXY'></span><span id='topic+textGEOmapXY'></span><span id='topic+rectGEOmapXY'></span><span id='topic+polyGEOmapXY'></span>

<h3>Description</h3>

<p>Add lines, points or text to GEOmap projected plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linesGEOmapXY(lat = 0, lon = 0, PROJ = NULL, PMAT = NULL, ...)
textGEOmapXY(lat = 0, lon = 0, labels = NULL, PROJ = NULL, PMAT = NULL, ...)
pointsGEOmapXY(lat = 0, lon = 0, PROJ = NULL, PMAT = NULL, ...)
rectGEOmapXY(lat=0, lon=0, PROJ=NULL, PMAT=NULL, ... )
polyGEOmapXY(lat = 0, lon = 0, PROJ = NULL, PMAT = NULL, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linesGEOmapXY_+3A_lat">lat</code></td>
<td>
<p>vector of latitudes</p>
</td></tr>
<tr><td><code id="linesGEOmapXY_+3A_lon">lon</code></td>
<td>
<p>vector of longitudes</p>
</td></tr>
<tr><td><code id="linesGEOmapXY_+3A_labels">labels</code></td>
<td>
<p>text for labels</p>
</td></tr>
<tr><td><code id="linesGEOmapXY_+3A_proj">PROJ</code></td>
<td>
<p>projection structure</p>
</td></tr>
<tr><td><code id="linesGEOmapXY_+3A_pmat">PMAT</code></td>
<td>
<p>persp matrix for perspective plot</p>
</td></tr>
<tr><td><code id="linesGEOmapXY_+3A_...">...</code></td>
<td>
<p>graphical Parameters from par</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Graphical Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>plotGEOmapXY</p>

<hr>
<h2 id='Lintersect'>Finder intersection of lines</h2><span id='topic+Lintersect'></span>

<h3>Description</h3>

<p>Determines intersection points of 2D vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lintersect(l1, l2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lintersect_+3A_l1">l1</code></td>
<td>
<p>Line 1 </p>
</td></tr>
<tr><td><code id="Lintersect_+3A_l2">l2</code></td>
<td>
<p>Line 2 </p>
</td></tr>
</table>


<h3>Value</h3>

<p>0=no intersection
1=interesction
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>ccw</p>


<h3>Examples</h3>

<pre><code class='language-R'>

plot(c(-1,1), c(-1,1), type='n')

l1 = list(p1=list(x=-0.938, y=0.0860), p2=list(x=0.4006,y=0.9294))
l2 = list(p1=list(x=-0.375, y=0.0860), p2=list(x=-0.344,y=-0.8089))
points(l1$p1)
points(l1$p2)
points(l2$p1)
points(l2$p2)
segments(c(l1$p1$x, l2$p1$x), c(l1$p1$y, l2$p1$y), c(l1$p2$x, l2$p2$x), c(l1$p2$y, l2$p2$y) )


Lintersect(l1, l2)


plot(c(-1,1), c(-1,1), type='n')

l1 = list(p1=list(x=-0.83587, y=-0.5765), p2=list(x=0.731603,y=0.69705))
l2 = list(p1=list(x=-0.6114, y=0.7745), p2=list(x=0.48430,y=-0.63250))
points(l1$p1)
points(l1$p2)
points(l2$p1)
points(l2$p2)
segments(c(l1$p1$x, l2$p1$x), c(l1$p1$y, l2$p1$y), c(l1$p2$x, l2$p2$x), c(l1$p2$y, l2$p2$y) )

Lintersect(l1, l2)

</code></pre>

<hr>
<h2 id='list.GEOmap'>List stroke points in a GEOmap</h2><span id='topic+list.GEOmap'></span>

<h3>Description</h3>

<p>List stroke points in a GEOmap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list.GEOmap(MAP, SEL = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.GEOmap_+3A_map">MAP</code></td>
<td>
<p>GEOmap list, with LL list </p>
</td></tr>
<tr><td><code id="list.GEOmap_+3A_sel">SEL</code></td>
<td>
<p>index, selecttion of specific strokes</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns a GEOmap list from the output of GEOmap.list .
This is used to repack a GEOmap list.
Tis function can be used to create a new geomap if you have only
strokes.  See example.  Can be used to convert
a gmt map file (in ascii text format) to GEOmap.
</p>


<h3>Value</h3>

<p>GEOmap list
</p>
<table>
<tr><td><code>STROKES</code></td>
<td>
<p>Metadata for strokes</p>
</td></tr>
<tr><td><code>POINTS</code></td>
<td>
<p>list, lat=vector, lon=vector</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>GEOmap.cat, GEOmap.Extract, GEOmap.CombineStrokes, GEOmap.list</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(coastmap)

length(coastmap$STROKES$nam)

G = GEOmap.list(coastmap, 1)

length(G$STROKES$nam)

H = list.GEOmap(G)

length(H$STROKES$nam)

plotGEOmap(H)

##############   if you have a set of simple strokes
#####  make your own geomap:

latlon=list()
latlon$lat=c(39.8780395624,39.7488080389,39.4903449921,39.2964977069,
39.1995740643,39.1349583026,38.9088031365,38.6180322088,38.3272612810,
38.0041824724,37.8749509489,37.8749509489,38.3272612810,38.4888006853,
38.8118794939,39.0057267791,39.2318819452,39.5872686346,39.9426553241)
latlon$lon=c(136.6629878969,136.3444990720,136.0715086507,136.0715086507,
135.6165246151,135.0250453689,134.9795469653,134.9795469653,135.0705437724,
135.2525373866,135.7530198258,137.0724735289,137.3454639502,137.4364607574,
138.0734384071,138.0734384071,137.8004479858,137.7549495822,137.2544671431)

GLL=list()
GLL$lat=c(38.0552647517,38.1533772893,38.2754431875,
38.3672221979,38.5260793869,38.6483246519,38.7701056377,
38.8976069603,38.9457673342,38.9998962787,39.1025327692,
39.1927889270,39.3801557421,39.5193850467)
GLL$lon=c(135.7446171004,135.8598134616,135.9053532164,
135.9978522791,136.1369466401,136.3703056863,136.6044613488,
136.8081531656,136.9649782331,137.1064020435,137.2564343909,
137.4067379892,137.5747171917,137.6637851576)

LL =list()
LL[[1]] = latlon
LL[[2]] = GLL

J = list(LL=LL)


GL = list.GEOmap(J)

plotGEOmapXY(GL)


</code></pre>

<hr>
<h2 id='ll2xyz'>LAT-LON to xyz
</h2><span id='topic+ll2xyz'></span>

<h3>Description</h3>

<p>LAT-LON to xyz
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ll2xyz(lat, lon)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ll2xyz_+3A_lat">lat</code></td>
<td>
<p>latitude
</p>
</td></tr>
<tr><td><code id="ll2xyz_+3A_lon">lon</code></td>
<td>
<p>longitude
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>3-vector</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>Lll2xyz, Lxyz2ll, xyz2ll
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ll2xyz(12, 289)

</code></pre>

<hr>
<h2 id='Lll2xyz'>List Lat-Lon to cartesian XYZ
</h2><span id='topic+Lll2xyz'></span>

<h3>Description</h3>

<p>List Lat-Lon to cartesian XYZ
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lll2xyz(lat, lon)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lll2xyz_+3A_lat">lat</code></td>
<td>
<p>latitude
</p>
</td></tr>
<tr><td><code id="Lll2xyz_+3A_lon">lon</code></td>
<td>
<p>longitude
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list(x,y,z)
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>ll2xyz, Lxyz2ll, xyz2ll
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Lll2xyz(23, 157)



</code></pre>

<hr>
<h2 id='LLlabel'>Nice Lat-Lon Label
</h2><span id='topic+LLlabel'></span>

<h3>Description</h3>

<p>Create a text string for Lat-Lons
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LLlabel(DD, dir = 1, ksec = -1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LLlabel_+3A_dd">DD</code></td>
<td>
<p>Decimal degrees
</p>
</td></tr>
<tr><td><code id="LLlabel_+3A_dir">dir</code></td>
<td>
<p>direction, NS or EW
</p>
</td></tr>
<tr><td><code id="LLlabel_+3A_ksec">ksec</code></td>
<td>
<p>number of decimals for seconds
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>creates text labels with minutes and seconds
if needed.
</p>


<h3>Value</h3>

<p>character string
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>niceLLtix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

DD = -13.12345

k = LLlabel(DD)



</code></pre>

<hr>
<h2 id='LLsmallcircMap'>World Map centered on Lat-Lon
</h2><span id='topic+LLsmallcircMap'></span>

<h3>Description</h3>

<p>World Map centered on Lat-Lon with Lambert-Azimuthal projection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LLsmallcircMap(phicen, lamcen, worldmap, eqlat, eqlon, MAXR = 100,
circol = rgb(1, 0.8, 0.8), mapcol = rgb(0, 0, 0), eqcol = rgb(0.8, 0.8,
1) , pch=25, ecex=1 )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LLsmallcircMap_+3A_phicen">phicen</code></td>
<td>
<p>Center Latitude
</p>
</td></tr>
<tr><td><code id="LLsmallcircMap_+3A_lamcen">lamcen</code></td>
<td>
<p>Center Longitude
</p>
</td></tr>
<tr><td><code id="LLsmallcircMap_+3A_worldmap">worldmap</code></td>
<td>
<p>GEOmap map structure
</p>
</td></tr>
<tr><td><code id="LLsmallcircMap_+3A_eqlat">eqlat</code></td>
<td>
<p>Latitudes of points, vector
</p>
</td></tr>
<tr><td><code id="LLsmallcircMap_+3A_eqlon">eqlon</code></td>
<td>
<p>Longitude of points, vector
</p>
</td></tr>
<tr><td><code id="LLsmallcircMap_+3A_maxr">MAXR</code></td>
<td>
<p>Maximum radius, degrees
</p>
</td></tr>
<tr><td><code id="LLsmallcircMap_+3A_circol">circol</code></td>
<td>
<p>Color for small circles
</p>
</td></tr>
<tr><td><code id="LLsmallcircMap_+3A_mapcol">mapcol</code></td>
<td>
<p>Color for map
</p>
</td></tr>
<tr><td><code id="LLsmallcircMap_+3A_eqcol">eqcol</code></td>
<td>
<p>Color for points, single or 2-vector
</p>
</td></tr>
<tr><td><code id="LLsmallcircMap_+3A_pch">pch</code></td>
<td>
<p>Plotting character for points
</p>
</td></tr>
<tr><td><code id="LLsmallcircMap_+3A_ecex">ecex</code></td>
<td>
<p>Plotting size for points
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses a Lamber-Azimuthal projection of the whole globe
out to the given radius.  If a vector of 2 colors are provided for the
eqcol parameter, and the pch is one of (21:25), then a 2-tone
points is plotted with ecol[1] on the perimeter, and ecol[2] on the
interior.
</p>


<h3>Value</h3>

<p>Graphical side effects 
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>lamaz.eqarea
</p>


<h3>Examples</h3>

<pre><code class='language-R'>###  earthquake in Noto,Japan

data(coastmap)


elat = 37.4949
elon = 137.2653

K = list(lon=c(183.3158,188.2173,253.5428,295.3037,
               166.4531,110.5354,268.7554,98.9443,212.1384,236.6954),
         lat=c( 51.8823,-13.9085,34.94591,32.3713,68.0653,
               -66.2792,38.0557,18.8141,64.8736,44.5855  ))



LLsmallcircMap(elat, elon, coastmap, K$lat, K$lon  )

LLsmallcircMap(elat, elon, coastmap, K$lat, K$lon,
  MAXR=80, eqcol=c('blue', 'gold') , mapcol=grey(.8), pch=22, ecex=1.5  )





</code></pre>

<hr>
<h2 id='LOCPOLIMAP'>LOCPOLIMAP</h2><span id='topic+LOCPOLIMAP'></span>

<h3>Description</h3>

<p>This program takes a point and return the continent index for database manipulation. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>LOCPOLIMAP(P, MAP)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LOCPOLIMAP_+3A_p">P</code></td>
<td>
<p>Point selected on screen using locator</p>
</td></tr>
<tr><td><code id="LOCPOLIMAP_+3A_map">MAP</code></td>
<td>
<p>List of maps and coordinates from database </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses the CIA data base definitions.
</p>


<h3>Value</h3>

<table>
<tr><td><code>J</code></td>
<td>
<p>Index to map data base</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>SETPOLIMAP</p>


<h3>Examples</h3>

<pre><code class='language-R'>
P = list(lat=36.09063, lon=19.44610)

LMAP = SETPOLIMAP()

 J = LOCPOLIMAP(P, LMAP)
J

</code></pre>

<hr>
<h2 id='locworld'>Locate points in worlmap</h2><span id='topic+locworld'></span>

<h3>Description</h3>

<p>Locate points in worlmap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>locworld(shiftlon = 0, col = "brown", n = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="locworld_+3A_shiftlon">shiftlon</code></td>
<td>
<p>rotate map by degrees</p>
</td></tr>
<tr><td><code id="locworld_+3A_col">col</code></td>
<td>
<p>color of points</p>
</td></tr>
<tr><td><code id="locworld_+3A_n">n</code></td>
<td>
<p>number of points</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>lon</code></td>
<td>
<p>longitudes</p>
</td></tr>
<tr><td><code>lat</code></td>
<td>
<p>latitudes</p>
</td></tr>
<tr><td><code>LON</code></td>
<td>
<p>longitudes</p>
</td></tr>
<tr><td><code>LAT</code></td>
<td>
<p>latitudes</p>
</td></tr>
<tr><td><code>utmbox</code></td>
<td>
<p>UTM box list(lat, lon) </p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>UTM x-coordinates</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>UTM y-coordinates</p>
</td></tr>
<tr><td><code>UTM0</code></td>
<td>
<p>utm origin for projection list(phi, lam) </p>
</td></tr>
<tr><td><code>shiftlon</code></td>
<td>
<p>rotate map by degrees</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>plotworldmap</p>


<h3>Examples</h3>

<pre><code class='language-R'>
###  this program is interactive....
## Not run: 

library(geomapdata)

data(worldmap)
plotworldmap(worldmap)
locworld(shiftlon = 0, col = "brown", n = 2)

## End(Not run)

</code></pre>

<hr>
<h2 id='Lxyz2ll'>Cartesian to Lat-Lon
</h2><span id='topic+Lxyz2ll'></span>

<h3>Description</h3>

<p>Cartesian vector to Lat-Lon List
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Lxyz2ll(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Lxyz2ll_+3A_x">X</code></td>
<td>
<p>list, x,y,z</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of lat and lon
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>xyz2ll</p>


<h3>Examples</h3>

<pre><code class='language-R'>
Lll2xyz(23, 157)

</code></pre>

<hr>
<h2 id='MAPconstants'>Set Various Map Constants</h2><span id='topic+MAPconstants'></span>

<h3>Description</h3>

<p>Used for retrieval when doing projections
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MAPconstants()
</code></pre>


<h3>Details</h3>

<p>These include a sime list of:
DEG2RAD, RAD2DEG, A.MAPK, E2.MAPK, E2.GRS80, E.MAPK, E1.MAPK, TwoE.MAPK, R.MAPK, FEET2M, M2FEET
</p>


<h3>Value</h3>

<p>List of constants for Projections
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>References</h3>

<p>Snyder, John P., Map Projections- a working manual, USGS, Professional Paper, 1987.
</p>


<h3>See Also</h3>

<p>XY.GLOB, projtype, utm.sphr.xy</p>


<h3>Examples</h3>

<pre><code class='language-R'>MAPconstants()


</code></pre>

<hr>
<h2 id='maplim'>Map Limits
</h2><span id='topic+maplim'></span>

<h3>Description</h3>

<p>Set reasonable map limits from
a set of Lat-Lon pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maplim(lat, lon, pct = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maplim_+3A_lat">lat</code></td>
<td>
<p>vector of latitudes
</p>
</td></tr>
<tr><td><code id="maplim_+3A_lon">lon</code></td>
<td>
<p>vector of longitudes
</p>
</td></tr>
<tr><td><code id="maplim_+3A_pct">pct</code></td>
<td>
<p>percent fraction to increase (or decrease) limits
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In some (GEOmap) programs the longitude
needs to be modulus 360, so these are provided also.
</p>


<h3>Value</h3>

<p>list of range of lats and lons
</p>
<table>
<tr><td><code>lat</code></td>
<td>
<p>lat limits</p>
</td></tr>
<tr><td><code>lon</code></td>
<td>
<p>lat limits</p>
</td></tr>
<tr><td><code>LON</code></td>
<td>
<p>lon limits modulus 360</p>
</td></tr>
<tr><td><code>lim</code></td>
<td>
<p> vector: lon1 lat1 lon2 lat2</p>
</td></tr>
<tr><td><code>LIM</code></td>
<td>
<p> vector: lon1 lat1 lon2 lat2, with  lon limits modulus 360</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>expandbound, plotGEOmapXY
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
lat = rnorm(10, m=46, sd=2)
lon = rnorm(10, m=-121, sd=1)

M = maplim(lat, lon, pct=.2)

plot(M$lon, M$lat, type='n')
points(lon, lat)

############   plotting with a GEOmap
library(geomapdata)
data(worldmap)

PROJ = setPROJ(type=2, LON0=mean(lon), LAT0=mean(lat))

plotGEOmapXY(worldmap, LIM=M$LIM)
pointsGEOmapXY(lat, lon,PROJ =PROJ,  pch=6)




</code></pre>

<hr>
<h2 id='maps2GEOmap'>Convert maps data to GEOmap format
</h2><span id='topic+maps2GEOmap'></span>

<h3>Description</h3>

<p>Convert maps data to GEOmap format
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maps2GEOmap(zz, wx = 1, mapnam = "temp")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maps2GEOmap_+3A_zz">zz</code></td>
<td>

<p>Output list from maps package
</p>
</td></tr>
<tr><td><code id="maps2GEOmap_+3A_wx">wx</code></td>
<td>

<p>vector of breaks (in maps these are NA)
</p>
</td></tr>
<tr><td><code id="maps2GEOmap_+3A_mapnam">mapnam</code></td>
<td>

<p>Name pasted on each stroke
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The program takes the output of maps and converts to a GEOmap
strucuture.
This code should work with GMT style map files too.
</p>


<h3>Value</h3>

<p>GEOmap list.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(maps)


zz = map('state', region = c('new york', 'new jersey', 'penn'))

neweng  = maps2GEOmap(zz)

plotGEOmap(neweng)
##  L1 = locator(1)
L1=list()
L1$x=c(283.671347071854)
L1$y=c(42.008587074537)

LIMS1 = list( lon=range(neweng$POINTS$lon),
              lat=range(neweng$POINTS$lat) )

LIMS = c(LIMS1$lon[1], LIMS1$lat[1], LIMS1$lon[2], LIMS1$lat[2])

##########   prepare maps 2:

z2 = map('world', region = c('iceland'))
ice   = maps2GEOmap(z2)
plotGEOmap(ice)

##  L2 = locator(1)
L2=list()
L2$x=c(341.146812632372)
L2$y=c(64.9180246121089)

############    this version here is nicer, but required WORLMAP2
###kice = grep('ice' , coast2$STROKES$nam, ignore.case =TRUE)

### ice = GEOmap.Extract(coast2, kice  ,"in")

MAP = rotateGEOmap(ice, L1$y ,  L1$x ,  L2$y ,  L2$x, beta=-90 )


proj = setPROJ( 2, LAT0=L1$y, LON0=L1$x )

plotGEOmapXY(neweng, LIM=LIMS,  PROJ =proj, axes=FALSE, xlab="", ylab="" )


plotGEOmapXY(MAP, LIM=LIMS,  PROJ =proj, axes=FALSE, xlab="",
      ylab="", add = TRUE, MAPcol = grey(.85)  , lwd=2, xpd=TRUE)



  plotGEOmapXY(neweng, LIM=LIMS,  PROJ =proj, axes=FALSE,
      xlab="", ylab="", add=TRUE )
  


</code></pre>

<hr>
<h2 id='mapTeleSeis'>World Map with Teleseismic Ray-paths
</h2><span id='topic+mapTeleSeis'></span>

<h3>Description</h3>

<p>World Map with Teleseismic Ray-paths
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapTeleSeis(sta, mylist, worldmap=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mapTeleSeis_+3A_sta">sta</code></td>
<td>
<p>list of station locations
</p>
</td></tr>
<tr><td><code id="mapTeleSeis_+3A_mylist">mylist</code></td>
<td>
<p>list of event locations
</p>
</td></tr>
<tr><td><code id="mapTeleSeis_+3A_worldmap">worldmap</code></td>
<td>
<p>worldmap data (e.g. from geomapdata)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses GEOmap. No projection is used.
</p>


<h3>Value</h3>

<p>Graphical side effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
library(RSEIS)
library(GEOmap)

################### 
######   set up  stations
sta=list()
sta$'nam'=c("CAL", "KAM", "DOM", "LAV", "SMI", "CAS")
sta$'lat'=c(14.7421759974747,14.7471948493068,14.7422049415205,
14.7204249827467,14.7543726234568,14.710961318972)
sta$'lon'=c(-91.5659793619529,-91.5698443123368,-91.5775586192333,
-91.5716896307798,-91.5518522222222,-91.5702146825397)
sta$'el'=c(2.37596727272727,2.29854436407474,2.31819590643275,
1.64286335403727,3.65216666666667,1.44584353741497)
sta$'das'=c("CAL", "KAM", "DOM", "LAV", "SMI", "CAS")
sta$'sensor1'=c("60T", "60T", "60T", "40T", "INF", "3T")
sta$'comp1'=c("VNE", "VNE", "VNE", "VNE", "VNE", "VNE")
sta$'sensor2'=c("INF", "INF", "INF", "INF", "INF", "INF")
sta$'comp2'=c("IJK", "IJK", "IJK", "IJK", "IJK", "IJK")
sta$'dasSN'=c("9FF2", "9FFE", "9FFB", "9024", "A881", "9026")
sta$'sensorSN'=c("Unknown", "Unknown", "Unknown", "T41034", "Unknown", "T3A28")
sta$'start'=c("2008:366:16:02:59:615", "2008:366:20:50:18:615",
######   "2008:366:00:58:23:849", 
"2008:365:23:01:21:315", "2008:366:23:57:10:244", "2008:365:20:47:51:529")
sta$'end'=c("2009:004:18:02:58:615", "2009:004:17:50:17:615",
######   "2009:004:16:58:22:849", 
"2009:006:15:01:20:315", "2009:004:16:57:09:244", "2009:005:22:47:50:529")
sta$'name'=c("CAL", "KAM", "DOM", "LAV", "SMI", "CAS")


##############   get earthquake epicenters
eq1=list()
eq1$'yr'=c(2008,2009,2009,2009,2008,2009,
2009,2009,2009,2009,2009,2009,2009,2009,2009)
eq1$'mo'=c(12,1,1,1,12,1,1,1,1,1,1,1,1,1,1)
eq1$'dom'=c(30,1,3,4,30,1,2,3,3,3,3,3,4,4,6)
eq1$'lat'=c(14.06,14.73,13.93,15.23,-4.3,-34.84,0.62,-0.41,
-0.59,36.42,-0.32,-0.69,-0.4,36.44,-0.66)
eq1$'lon'=c(-92.21,-91.39,-91.74,-92.06,101.22,-107.65,-26.66,
132.88,133.36,70.74,132.88,133.3,132.76,70.88,133.43)
eq1$'mag'=c(4.3,4.7,4,4.7,5.9,5.8,5.6,7.6,5.6,5.8,5.6,7.4,5.9,5.7,6)
eq1$'depth'=c(9,169,61,177,20,10,10,17,35,204,29,23,35,186,16)
eq1$'hr'=c(23,11,9,19,19,6,19,19,19,20,21,22,7,23,22)
eq1$'mi'=c(12,44,16,2,49,27,42,43,53,23,49,33,14,12,48)
eq1$'sec'=c(57,51.68,0.8,23,52.61,51.22,27.19,50.65,
18.9,20.18,30.88,40.29,0.55,59.29,27.25)
eq1$'z'=c(9,169,61,177,20,10,10,17,35,204,29,23,35,186,16)
eq1$'jd'=c(365,1,3,4,365,1,2,3,3,3,3,3,4,4,6)

##########################  use the projection that is derived from the 
##########################    station file - these are based on the median station locations
 stinfo = list(mlat=median(sta$lat), mlon=median(sta$lon) )

proj =  setPROJ(6, LAT0=stinfo$mlat, LON0=stinfo$mlon )


######   get distances - this is so we can separate regional from teleseismic events
eqdists = distaz(stinfo$mlat , stinfo$mlon, eq1$lat,  eq1$lon)


mylist = list()
for(j in 1:length(eq1$sec))
{

mylist[[j]] = list(yr=eq1$yr[j], jd=eq1$jd[j], mo=eq1$mo[j], dom=eq1$dom[j], hr=eq1$hr[j], 
mi=eq1$mi[j], sec=eq1$sec[j], lat=eq1$lat[j], lon=eq1$lon[j], z=eq1$z[j], mag=eq1$mag[j])
}


library(geomapdata)
     data(worldmap)
 mapTeleSeis(sta, mylist, worldmap=worldmap)




## End(Not run)





</code></pre>

<hr>
<h2 id='Markup'>Add markup information to an existing plot</h2><span id='topic+Markup'></span>

<h3>Description</h3>

<p>For use in GEOmap to add labels to a geographic plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Markup(MM = list(), sel = 1, cex = 1, ...)

</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Markup_+3A_mm">MM</code></td>
<td>
<p>list of markup infromation</p>
</td></tr>
<tr><td><code id="Markup_+3A_sel">sel</code></td>
<td>
<p>vector, select which marks to be plotted</p>
</td></tr>
<tr><td><code id="Markup_+3A_cex">cex</code></td>
<td>
<p>character expansion</p>
</td></tr>
<tr><td><code id="Markup_+3A_...">...</code></td>
<td>
<p>graphical parameters for par</p>
</td></tr>
</table>


<h3>Details</h3>

<p> Uses the locator function
</p>


<h3>Value</h3>

<p>Graphical Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>setMarkup, plotGEOmapXY</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

   plot(c(0, 1), c(0, 1), main = "this is a test", sub = "sutitle",
        xlab = "this is x", ylab = "this is y")

LABS = c("this is", "a", "test")

MUP = setMarkup(LABS)



## End(Not run)


</code></pre>

<hr>
<h2 id='merid'>Orthogonal Projection of  Meridian or Parallel
</h2><span id='topic+merid'></span><span id='topic+paral'></span>

<h3>Description</h3>

<p>Orthogonal Projection Meridian or Parallel 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>merid(lon, lat1=-90,   lat2=90,  lam0=0, phi1=41, R=1, by=1)
paral(lat, lon1=-180 , lon2=180, lam0=0, phi1=41, R=1, by=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="merid_+3A_lon">lon</code></td>
<td>
<p>merid starting Longitude, degrees
</p>
</td></tr>
<tr><td><code id="merid_+3A_lat">lat</code></td>
<td>
<p>paral starting Latitude, degrees
</p>
</td></tr>
<tr><td><code id="merid_+3A_lam0">lam0</code></td>
<td>
<p>origin Longitude, degrees
</p>
</td></tr>
<tr><td><code id="merid_+3A_phi1">phi1</code></td>
<td>
<p>origin  Latitude, degrees
</p>
</td></tr>
<tr><td><code id="merid_+3A_r">R</code></td>
<td>
<p>Radius
</p>
</td></tr>
<tr><td><code id="merid_+3A_by">by</code></td>
<td>
<p>increment in degrees
</p>
</td></tr>
<tr><td><code id="merid_+3A_lat1">lat1</code></td>
<td>
<p>merid starting Latitude, degrees
</p>
</td></tr>
<tr><td><code id="merid_+3A_lat2">lat2</code></td>
<td>
<p>merid ending Latitude, degrees
</p>
</td></tr>
<tr><td><code id="merid_+3A_lon1">lon1</code></td>
<td>
<p>paral starting Longitude, degrees
</p>
</td></tr>
<tr><td><code id="merid_+3A_lon2">lon2</code></td>
<td>
<p>paral ending Longitude, degrees
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Retruns points along a meridian running through lat, lon
with a projection based on lam0 phi.
</p>


<h3>Value</h3>

<p>list of x-y values for plotting
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Snyder, John P., Map Projections- a working manual, USGS, Professional Paper, 1987.
</p>


<h3>See Also</h3>

<p>ortho.proj
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 olat = 0
         olon = 0

          tlat = 23
         tlon = 30

M = merid(tlon, lat1=tlat, olon, olat, 1)


R = 1

phi1=40


GLOBE.ORTH(20, phi1, 1,plotmap=FALSE)

M1 = merid(20, lat1=20, lat2=40, phi1=phi1, lam0=olat, R=1, by=1)

P2 = paral(40, lon1=20 , lon2=40, lam0=olat, phi1=phi1, R=1, by=1)

M2 = merid(40, lat1=40, lat2=20, phi1=phi1, lam0=olat, R=1, by=1)

P1 = paral(20, lon1=40 , lon2=20, lam0=olat, phi1=phi1, R=1, by=1)

polygon(c(M1$x, P2$x, M2$x, P1$x), c(M1$y, P2$y, M2$y, P1$y),
col=rgb(.8, .8, 1))


</code></pre>

<hr>
<h2 id='niceLLtix'>Nice DMS coordinates</h2><span id='topic+niceLLtix'></span>

<h3>Description</h3>

<p>Determine a nice set of coordinates in DMS
</p>


<h3>Usage</h3>

<pre><code class='language-R'>niceLLtix(rcoords)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="niceLLtix_+3A_rcoords">rcoords</code></td>
<td>
<p>vector of decimal degrees, the range will be used </p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>DD</code></td>
<td>
<p>decimal degrees</p>
</td></tr>
<tr><td><code>deg</code></td>
<td>
<p>degrees</p>
</td></tr>
<tr><td><code>min</code></td>
<td>
<p>minutes</p>
</td></tr>
<tr><td><code>sec</code></td>
<td>
<p>seconds</p>
</td></tr>
<tr><td><code>si</code></td>
<td>
<p>sign of degrees</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>dms</p>


<h3>Examples</h3>

<pre><code class='language-R'>
niceLLtix(c(12.5, 12.58) )
niceLLtix(c(12.57, 12.58) )

niceLLtix(c(91.5, 92.8) )
niceLLtix(c(-91.5, -92.8) )

niceLLtix(c(91.5, 93.8) )


niceLLtix(c(91.5, 95.8) )

niceLLtix(c(-91.5, -95.8) )


</code></pre>

<hr>
<h2 id='NoOverlap'>Shift Symbols 
</h2><span id='topic+NoOverlap'></span>

<h3>Description</h3>

<p>Shift Symbols such that there is no overlap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NoOverlap(x, y, focsiz, SEL = 0, OLDx = 0, OLDy = 0, cenx = 0, ceny = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NoOverlap_+3A_x">x</code></td>
<td>
<p>x-location
</p>
</td></tr>
<tr><td><code id="NoOverlap_+3A_y">y</code></td>
<td>
<p>y-location
</p>
</td></tr>
<tr><td><code id="NoOverlap_+3A_focsiz">focsiz</code></td>
<td>
<p>symbol size
</p>
</td></tr>
<tr><td><code id="NoOverlap_+3A_sel">SEL</code></td>
<td>
<p>selection of which symbols to shift
</p>
</td></tr>
<tr><td><code id="NoOverlap_+3A_oldx">OLDx</code></td>
<td>
<p>x-locations of origin
</p>
</td></tr>
<tr><td><code id="NoOverlap_+3A_oldy">OLDy</code></td>
<td>
<p>y-locations of origin
</p>
</td></tr>
<tr><td><code id="NoOverlap_+3A_cenx">cenx</code></td>
<td>
<p>center x
</p>
</td></tr>
<tr><td><code id="NoOverlap_+3A_ceny">ceny</code></td>
<td>
<p>center y
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Program is used for finding positions for exploding.
A vector is dcalculated from each origin to each point and explosions
are projected along these directions until a position is found that
does not overlap.
The position is nudged by a value of focsiz at each step.
If OLDx and OLDy are not provided,
cenx and ceny are used as origin points.
</p>


<h3>Value</h3>

<p>x,y list of new positions
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>ExplodeSymbols
</p>


<h3>Examples</h3>

<pre><code class='language-R'> draw.circ&lt;-function (x, y, r, ...) 
      {
        CI = RPMG::circle(1)
        for (i in 1:length(x)) {
          Cx = x[i] + r * CI$x
          Cy = y[i] + r * CI$y
          lines(c(Cx, Cx[1]), c(Cy, Cy[1]), type = "l", ...)
        }
      }
 

 x = rnorm(20)
    y = rnorm(20)

    rx = range(x)
    ry = range(y)

    drx = diff(rx)
    dry = diff(ry)
    XPCT=.2
    rx = c(rx[1]-XPCT*drx, rx[2]+XPCT*drx)
    ry = c(ry[1]-XPCT*dry, ry[2]+XPCT*dry)



   plot(rx , ry , type='n', asp=1, xlab="km", ylab="km")

    u = par("usr")

focsiz = 0.04* (u[2]-u[1])

   draw.circ(x, y, focsiz, col='red')
 NXY = NoOverlap(x,y,focsiz)

 plot(rx , ry , type='n', asp=1, xlab="km", ylab="km")

    u = par("usr")

focsiz = 0.04* (u[2]-u[1])


draw.circ(NXY$x, NXY$y, focsiz, col="blue" )

    segments(x,y,NXY$x, NXY$y)
   

</code></pre>

<hr>
<h2 id='normalfault'>Normal Fault trace</h2><span id='topic+normalfault'></span>

<h3>Description</h3>

<p>Plot normal fault on map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>normalfault(x, y, h = 1, hoff = 1, rot = list(cs = 1, sn = 0), col = "black")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalfault_+3A_x">x</code></td>
<td>
<p>x-coordinates</p>
</td></tr>
<tr><td><code id="normalfault_+3A_y">y</code></td>
<td>
<p>y-coordinates</p>
</td></tr>
<tr><td><code id="normalfault_+3A_h">h</code></td>
<td>
<p>radius of ball</p>
</td></tr>
<tr><td><code id="normalfault_+3A_hoff">hoff</code></td>
<td>
<p>distance from line</p>
</td></tr>
<tr><td><code id="normalfault_+3A_rot">rot</code></td>
<td>
<p>rotation vectors, (cosines and sines)</p>
</td></tr>
<tr><td><code id="normalfault_+3A_col">col</code></td>
<td>
<p>color</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Rotation vector is provided as list(cs=vector(), sn=vector()).
</p>


<h3>Value</h3>

<p>Graphical Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>GEOsymbols</p>


<h3>Examples</h3>

<pre><code class='language-R'>

G=list()
G$x=c(-1.0960,-0.9942,-0.8909,-0.7846,-0.6738,-0.5570,-0.4657,-0.3709,
-0.2734,-0.1740,-0.0734, 0.0246, 0.1218, 0.2169, 0.3086, 0.3956, 0.4641, 
0.5293, 0.5919, 0.6530, 0.7131)
G$y=c(-0.72392,-0.62145,-0.52135,-0.42599,-0.33774,-0.25896,-0.20759,
-0.16160,-0.11981,-0.08105,-0.04414,-0.00885, 0.02774, 0.06759, 0.11262, 
0.16480, 0.21487, 0.27001, 0.32895, 0.39044, 0.45319)


plot(G$x, G$y, type='n',asp=1, axes=FALSE, xlab='', ylab='')

 g = PointsAlong(G$x, G$y, N=3)

 sk = 2
 lines(G$x,G$y,col='blue')

bcars(g$x,g$y, h1=sk, h2=sk*.5, g$rot, col='black', border='black' )

</code></pre>

<hr>
<h2 id='NSarrow'>North-South Weather Vane Arrow </h2><span id='topic+NSarrow'></span><span id='topic+vane'></span>

<h3>Description</h3>

<p>Add north-south weather vane arrow figure 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NSarrow(x = NULL, y = NULL, R = 1, col.arrow = 1, col.N = 1,
col.circ = 1, rot = 0, PMAT = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NSarrow_+3A_x">x</code></td>
<td>
<p>X-location vector, if list, include both x and y values </p>
</td></tr>
<tr><td><code id="NSarrow_+3A_y">y</code></td>
<td>
<p>Y-location vector, not needed if x is a list </p>
</td></tr>
<tr><td><code id="NSarrow_+3A_r">R</code></td>
<td>
<p>radius, in plot coordinates </p>
</td></tr>
<tr><td><code id="NSarrow_+3A_col.arrow">col.arrow</code></td>
<td>
<p>color for arrow, default=&quot;black&quot; </p>
</td></tr>
<tr><td><code id="NSarrow_+3A_col.n">col.N</code></td>
<td>
<p>color for N symbol </p>
</td></tr>
<tr><td><code id="NSarrow_+3A_col.circ">col.circ</code></td>
<td>
<p>color for circle </p>
</td></tr>
<tr><td><code id="NSarrow_+3A_rot">rot</code></td>
<td>
<p>rotation angle, degrees </p>
</td></tr>
<tr><td><code id="NSarrow_+3A_pmat">PMAT</code></td>
<td>
<p>projection matrix, output of persp </p>
</td></tr>
</table>


<h3>Details</h3>

<p>The location list should have 2 values for x and y each, the second value for y
determines the radius R if it is not provided.  The first element of y
is the center of the weather vane. If no x-list is provided, the
interactive locator function is invoked and a list is returned for future work.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>x-location</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>y-location</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>zebra</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot(c(1:10), c(1:10), type='n')

x=c(2,2)
y = c(8,9)

NSarrow(list(x=x, y=y))

##### move over and repeat, with rotation of 25 degrees west

x=c(5,5)
y = c(8,9)

NSarrow(list(x=x, y=y), rot=25)




</code></pre>

<hr>
<h2 id='NSWath'>Cross sectional Swaths of Earthquakes over Japan</h2><span id='topic+NSWath'></span>

<h3>Description</h3>

<p>Set of 4 swaths for cross section across Japan
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(NSWath)</code></pre>


<h3>Format</h3>

<p>list of cross sections each conists of a list of form:
</p>

<dl>
<dt>r</dt><dd><p>r-distance along cross section (x-coordinate)</p>
</dd>
<dt>dh</dt><dd><p>distance from cross seection</p>
</dd>
<dt>depth</dt><dd><p>depth in cross section (y-coordinate) </p>
</dd>
<dt>flag</dt><dd><p>index vector of which earthquakes fell in swath and depth range</p>
</dd>
<dt>InvBox</dt><dd><p>coordinates of swath for plotting on map</p>
</dd>
</dl>



<h3>Source</h3>

<p>Data is extrcted from an earthquake data base of relocated events
provided by Robert Engdahl.
</p>


<h3>References</h3>

<p>Engdahl, E. R., R. D. van der Hilst, S. H. Kirby, G. Ekstrom, K. M. Shedlock, and A. F. Sheehan (1998), A global survey of slab structures and internal processes using a combined data base of high-resolution earthquake hypocenters, tomographic images and focal mechanism data, Seismol. Res. Lett., 69, 153-154. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(NSWath)
for(i in 1:length(NSWath))
{
dev.new()
LAB = attr(NSWath[[i]], "LAB")

XSECwin( NSWath[[i]] , iseclab=i, xLAB=LAB , labs=NULL, demo=TRUE  )   
}


## End(Not run)

</code></pre>

<hr>
<h2 id='ortho.proj'>Orthogonal Map Projection
</h2><span id='topic+ortho.proj'></span>

<h3>Description</h3>

<p>Orthogonal Map Projection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ortho.proj(lat, lon, lon0, lat1, R)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ortho.proj_+3A_lat">lat</code></td>
<td>
<p>latitude, degrees
</p>
</td></tr>
<tr><td><code id="ortho.proj_+3A_lon">lon</code></td>
<td>
<p>longitude, degrees
</p>
</td></tr>
<tr><td><code id="ortho.proj_+3A_lon0">lon0</code></td>
<td>
<p>view origin longitude, degrees
</p>
</td></tr>
<tr><td><code id="ortho.proj_+3A_lat1">lat1</code></td>
<td>
<p>view origin  latitude, degrees
</p>
</td></tr>
<tr><td><code id="ortho.proj_+3A_r">R</code></td>
<td>
<p>Radius of sphere, default=1
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Assumes spherical globe.  This function is not part
of the normal GEOmap plotting routines.
</p>


<h3>Value</h3>

<p>list
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>x, coordinate in units of R</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>y, coordinate in units of R</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Snyder, John P., Map Projections- a working manual, USGS, Professional Paper, 1987.
</p>


<h3>See Also</h3>

<p>GLOBE.ORTH, setPROJ, projtype
</p>


<h3>Examples</h3>

<pre><code class='language-R'>

olat = 0
         olon = 0

          tlat = 23
         tlon = 30
R = 1
ortho.proj(tlat, tlon, olon, olat, R)


</code></pre>

<hr>
<h2 id='OverTurned'>Plot Overturned fault</h2><span id='topic+OverTurned'></span>

<h3>Description</h3>

<p>Plot Overturned fault
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OverTurned(x, y, syn = TRUE, spacing = NULL, N = 1, r1 = 1, r2 = 1.2,
 h1 = 0.5, h2 = 0.5, endtol = 0.1, REV = FALSE, col = "black", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OverTurned_+3A_x">x</code></td>
<td>
<p>x-coordinates</p>
</td></tr>
<tr><td><code id="OverTurned_+3A_y">y</code></td>
<td>
<p>y-coordinates</p>
</td></tr>
<tr><td><code id="OverTurned_+3A_syn">syn</code></td>
<td>
<p>logical, TRUE=syncline, FALSE=anticline</p>
</td></tr>
<tr><td><code id="OverTurned_+3A_spacing">spacing</code></td>
<td>
<p>spacing of points</p>
</td></tr>
<tr><td><code id="OverTurned_+3A_n">N</code></td>
<td>
<p>number of points</p>
</td></tr>
<tr><td><code id="OverTurned_+3A_r1">r1</code></td>
<td>
<p>x-radius of curled part</p>
</td></tr>
<tr><td><code id="OverTurned_+3A_r2">r2</code></td>
<td>
<p>y-radius of curled part</p>
</td></tr>
<tr><td><code id="OverTurned_+3A_h1">h1</code></td>
<td>
<p>length of first leg</p>
</td></tr>
<tr><td><code id="OverTurned_+3A_h2">h2</code></td>
<td>
<p>length of 2nd leg</p>
</td></tr>
<tr><td><code id="OverTurned_+3A_endtol">endtol</code></td>
<td>
<p>indent on either ends</p>
</td></tr>
<tr><td><code id="OverTurned_+3A_rev">REV</code></td>
<td>
<p>reverse direction of x-y</p>
</td></tr>
<tr><td><code id="OverTurned_+3A_col">col</code></td>
<td>
<p>color of teeth and line</p>
</td></tr>
<tr><td><code id="OverTurned_+3A_...">...</code></td>
<td>
<p>graphical parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Graphical Side effect
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>PointsAlong</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot(c(-5,5), c(-5,5), asp=1, type='n' )
ff=list()
ff$x=c(-4.850,-4.700,-3.934,-2.528, 0.603, 2.647, 3.861, 2.626)
ff$y=c(-4.045,-2.087,-0.710, 0.172, 1.291, 2.087,-0.753,-4.131)


OverTurned(ff$x,ff$y,  r1= .4, r2= .8, h1= .5, h2= .5, N=5, syn=FALSE,
endtol=.2)



</code></pre>

<hr>
<h2 id='perpen'>perpendicular marks  along line</h2><span id='topic+perpen'></span>

<h3>Description</h3>

<p>draw perpendicular marks  along line
</p>


<h3>Usage</h3>

<pre><code class='language-R'>perpen(x, y, h, rot, col = "black", lwd = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="perpen_+3A_x">x</code></td>
<td>
<p>x-coordinates</p>
</td></tr>
<tr><td><code id="perpen_+3A_y">y</code></td>
<td>
<p>y coordinates</p>
</td></tr>
<tr><td><code id="perpen_+3A_h">h</code></td>
<td>
<p>height of tooth</p>
</td></tr>
<tr><td><code id="perpen_+3A_rot">rot</code></td>
<td>
<p>rotation of teeth</p>
</td></tr>
<tr><td><code id="perpen_+3A_col">col</code></td>
<td>
<p>color of line</p>
</td></tr>
<tr><td><code id="perpen_+3A_lwd">lwd</code></td>
<td>
<p>line width </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used by faultperp
</p>


<h3>Value</h3>

<p>graphical side effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu</p>


<h3>See Also</h3>

<p>PointsAlong, faultperp</p>


<h3>Examples</h3>

<pre><code class='language-R'>plot(c(-5,5), c(-5,5), asp=1, type='n' )
ff=list()
ff$x=c(-4.850,-4.700,-3.934,-2.528, 0.603, 2.647, 3.861, 2.626)
ff$y=c(-4.045,-2.087,-0.710, 0.172, 1.291, 2.087,-0.753,-4.131)

G =getsplineG(ff$x, ff$y, kdiv=20)
g = PointsAlong(G$x, G$y, N=5)

lines(G)

perpen(g$x, g$y, 5, g$rot, col = "black", lwd = 1)

</code></pre>

<hr>
<h2 id='pgon'>Plot regular polygon: pentagon, hexagon, octagon</h2><span id='topic+pgon'></span>

<h3>Description</h3>

<p>Plot regular polygon: pentagon, hexagon, octagon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pgon(x,  y, siz=siz, col="black", border=NULL, K=5, startalph = -45, ... )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pgon_+3A_x">x</code></td>
<td>
<p>x-coordinate </p>
</td></tr>
<tr><td><code id="pgon_+3A_y">y</code></td>
<td>
<p>y-coordinate </p>
</td></tr>
<tr><td><code id="pgon_+3A_siz">siz</code></td>
<td>
<p>radius or size </p>
</td></tr>
<tr><td><code id="pgon_+3A_col">col</code></td>
<td>
<p>inside color </p>
</td></tr>
<tr><td><code id="pgon_+3A_border">border</code></td>
<td>
<p>border color </p>
</td></tr>
<tr><td><code id="pgon_+3A_k">K</code></td>
<td>
<p>number of sides per polygon</p>
</td></tr>
<tr><td><code id="pgon_+3A_startalph">startalph</code></td>
<td>
<p>starting angle </p>
</td></tr>
<tr><td><code id="pgon_+3A_...">...</code></td>
<td>
<p>graphical parameters </p>
</td></tr>
</table>


<h3>Details</h3>

<p>I figure is resized needs to be re-called.
</p>


<h3>Value</h3>

<p>Graphical Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
N = 25
x = rnorm(N)
y = rnorm(N)

z = rnorm(N)

######## draw pentagons
plot(x,y, type='n', axes=FALSE, ann=FALSE)
pgon(x,y, siz=abs(z)/10, col="white", border='black', startalph =60, K=5, lwd=.5, xpd=TRUE)

######   color the points, use 4-sided blocks
rbow=rainbow(100)

ss = sample(1:100, N, replace = TRUE, prob = NULL)
plot(x,y, type='n', axes=FALSE, ann=FALSE)
pgon(x,y, siz=abs(z)/10, col=rbow[ss], border='black', startalph =60, K=4, lwd=.5, xpd=TRUE)




</code></pre>

<hr>
<h2 id='pline'>Point to line distance</h2><span id='topic+pline'></span>

<h3>Description</h3>

<p>get sortest distance from arbitrary point to a segment.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pline(x1, y1, x2, y2, ex, ey)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pline_+3A_x1">x1</code></td>
<td>
<p>x coordinate segment start</p>
</td></tr>
<tr><td><code id="pline_+3A_y1">y1</code></td>
<td>
<p>y coordinate segment start</p>
</td></tr>
<tr><td><code id="pline_+3A_x2">x2</code></td>
<td>
<p>x coordinate segment end </p>
</td></tr>
<tr><td><code id="pline_+3A_y2">y2</code></td>
<td>
<p>y coordinate segment end </p>
</td></tr>
<tr><td><code id="pline_+3A_ex">ex</code></td>
<td>
<p>x, point </p>
</td></tr>
<tr><td><code id="pline_+3A_ey">ey</code></td>
<td>
<p>y point</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of:  
</p>
<table>
<tr><td><code>dis</code></td>
<td>
<p>distance to segment</p>
</td></tr>
<tr><td><code>dee</code></td>
<td>
<p>distance to line</p>
</td></tr>
<tr><td><code>zee</code></td>
<td>
<p>projection along line</p>
</td></tr>
<tr><td><code>px</code></td>
<td>
<p>x, point of intersection</p>
</td></tr>
<tr><td><code>py</code></td>
<td>
<p>y, point of intersection</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>polyintern</p>


<h3>Examples</h3>

<pre><code class='language-R'>L=list()
L$x=c(-0.161416832868, 0.484046270443,-0.472622257679)
L$y=c(-0.735779816514, 0.306422018349, 0.192660550459)

P = pline(L$x[1], L$y[1], L$x[2], L$y[2], L$x[3], L$y[3])

plot(L$x, L$y, type='n', asp=1)
segments(L$x[1], L$y[1], L$x[2], L$y[2])
points( L$x[3], L$y[3])

segments(L$x[3], L$y[3], P[4], P[5], col='red')




</code></pre>

<hr>
<h2 id='plotGEOmap'>Plot a GEO map</h2><span id='topic+plotGEOmap'></span>

<h3>Description</h3>

<p>High Level plot of GEO map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotGEOmap(MAP, LIM = c(-180, -90, 180, 90) ,
shiftlon = 0, add = TRUE ,
NUMB = FALSE , SEL = NULL, MAPcol = NULL,
MAPstyle = NULL, border=NA,
PLOT = TRUE, PRINT=FALSE, BB = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotGEOmap_+3A_map">MAP</code></td>
<td>
<p>Map Structure</p>
</td></tr>
<tr><td><code id="plotGEOmap_+3A_lim">LIM</code></td>
<td>
<p>Lat-Lon limits</p>
</td></tr>
<tr><td><code id="plotGEOmap_+3A_add">add</code></td>
<td>
<p>logical, TRUE= add to existing plot</p>
</td></tr>
<tr><td><code id="plotGEOmap_+3A_sel">SEL</code></td>
<td>
<p>Index vector of strokes to be used in plotting,
default=NULL(use all that pass other tests) </p>
</td></tr>
<tr><td><code id="plotGEOmap_+3A_mapcol">MAPcol</code></td>
<td>
<p>override color for maps</p>
</td></tr>
<tr><td><code id="plotGEOmap_+3A_mapstyle">MAPstyle</code></td>
<td>
<p>override plotting style for maps</p>
</td></tr>
<tr><td><code id="plotGEOmap_+3A_border">border</code></td>
<td>
<p>color, add border to polygons, NA=no border</p>
</td></tr>
<tr><td><code id="plotGEOmap_+3A_shiftlon">shiftlon</code></td>
<td>
<p>degrees, rotate longitude</p>
</td></tr>
<tr><td><code id="plotGEOmap_+3A_numb">NUMB</code></td>
<td>
<p>logical, number the strokes on the map</p>
</td></tr>
<tr><td><code id="plotGEOmap_+3A_plot">PLOT</code></td>
<td>
<p>logical, TRUE=plot map, else just set up plotting area</p>
</td></tr>
<tr><td><code id="plotGEOmap_+3A_print">PRINT</code></td>
<td>
<p>logical, TRUE=show selected stroke indeces on the
screen(default=FALSE) </p>
</td></tr>
<tr><td><code id="plotGEOmap_+3A_bb">BB</code></td>
<td>
<p>logical, TRUE=add bounding box to each stroke (default=FALSE) </p>
</td></tr>
<tr><td><code id="plotGEOmap_+3A_...">...</code></td>
<td>
<p>graphical parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>plotGEOmap does
not plot a projected map.  MAPcol and MAPstyle can be used to override the
colors and style in the map-list.  These are applied to all the strokes.
</p>


<h3>Value</h3>

<p>Graphical Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>plotGEOmapXY, DOTOPOMAPI, addLLXY</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(geomapdata)

data(coastmap)

plotGEOmap(coastmap , xaxs='i', yaxs='i')

####################   example:
coastmap$STROKES$col[coastmap$STROKES$code=="C" ] = rgb(1, .6, .6)
coastmap$STROKES$col[coastmap$STROKES$code=="c" ] = rgb(1, .9, .9)
coastmap$STROKES$col[coastmap$STROKES$code=="L" ] = rgb(.6, .6, 1)

plot(c(-30, 370), c(-85, 85), type='n', ann=FALSE,  xaxs='i', yaxs='i')

plotGEOmap(coastmap , border='black' , add=TRUE)
title(xlab="Longitude", ylab="Latitude" )
grid()

box()


## Not run: 

###  political map of the world
library(geomapdata)
plotGEOmap(coastmap , border='black' , add=FALSE, xaxs='i')

data(europe.bdy)
data(asia.bdy)

data(africa.bdy)
data(namer.bdy)

data(samer.bdy)
data(USAmap)


plotGEOmap(europe.bdy ,  add=TRUE)
plotGEOmap(asia.bdy ,  add=TRUE)
plotGEOmap(africa.bdy ,  add=TRUE)
plotGEOmap(namer.bdy ,  add=TRUE)

plotGEOmap(samer.bdy ,  add=TRUE)

plotGEOmap(USAmap ,  add=TRUE)




## End(Not run)


</code></pre>

<hr>
<h2 id='plotGEOmapXY'>Plot a projected GEO map </h2><span id='topic+plotGEOmapXY'></span>

<h3>Description</h3>

<p>High Level plot of GEO map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotGEOmapXY(MAP, LIM = c(-180, -90, 180, 90),
PROJ = list(), PMAT=NULL,
add = TRUE,  SEL=NULL , GRID = NULL, GRIDcol = 1,
MAPcol = NULL, MAPstyle = NULL, border = NA,
cenlon = 0, shiftlon = 0, linelty = 1,
linelwd = 1, ptpch=".", ptcex=1, NUMB = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotGEOmapXY_+3A_map">MAP</code></td>
<td>
<p>Map Structure</p>
</td></tr>
<tr><td><code id="plotGEOmapXY_+3A_lim">LIM</code></td>
<td>
<p>Lat-Lon limits</p>
</td></tr>
<tr><td><code id="plotGEOmapXY_+3A_proj">PROJ</code></td>
<td>
<p>Projection list </p>
</td></tr>
<tr><td><code id="plotGEOmapXY_+3A_pmat">PMAT</code></td>
<td>
<p>Perspective matrix conversion</p>
</td></tr>
<tr><td><code id="plotGEOmapXY_+3A_add">add</code></td>
<td>
<p>logical, TRUE= add to existing plot</p>
</td></tr>
<tr><td><code id="plotGEOmapXY_+3A_sel">SEL</code></td>
<td>
<p>Index vector of strokes to be used in plotting,
default=NULL(use all that pass other tests) </p>
</td></tr>
<tr><td><code id="plotGEOmapXY_+3A_grid">GRID</code></td>
<td>
<p>logical, TRUE=add grid lines</p>
</td></tr>
<tr><td><code id="plotGEOmapXY_+3A_gridcol">GRIDcol</code></td>
<td>
<p>color for grid lines</p>
</td></tr>
<tr><td><code id="plotGEOmapXY_+3A_mapcol">MAPcol</code></td>
<td>
<p>override color for maps</p>
</td></tr>
<tr><td><code id="plotGEOmapXY_+3A_mapstyle">MAPstyle</code></td>
<td>
<p>override plotting style for maps</p>
</td></tr>
<tr><td><code id="plotGEOmapXY_+3A_border">border</code></td>
<td>
<p>color, add border to polygons, NA=no border</p>
</td></tr>
<tr><td><code id="plotGEOmapXY_+3A_cenlon">cenlon</code></td>
<td>
<p>center longitude of plot</p>
</td></tr>
<tr><td><code id="plotGEOmapXY_+3A_shiftlon">shiftlon</code></td>
<td>
<p>degrees, rotate longitude</p>
</td></tr>
<tr><td><code id="plotGEOmapXY_+3A_linelty">linelty</code></td>
<td>
<p>Line type</p>
</td></tr>
<tr><td><code id="plotGEOmapXY_+3A_linelwd">linelwd</code></td>
<td>
<p>line width</p>
</td></tr>
<tr><td><code id="plotGEOmapXY_+3A_ptpch">ptpch</code></td>
<td>
<p>plotting character for strokes (style=1) that are plotted
as points</p>
</td></tr>
<tr><td><code id="plotGEOmapXY_+3A_ptcex">ptcex</code></td>
<td>
<p>character expansion factor for style=1 strokes </p>
</td></tr>
<tr><td><code id="plotGEOmapXY_+3A_numb">NUMB</code></td>
<td>
<p>logical, number the strokes on the map</p>
</td></tr>
<tr><td><code id="plotGEOmapXY_+3A_...">...</code></td>
<td>
<p>graphical parameters</p>
</td></tr>
</table>


<h3>Details</h3>

<p>plotGEOmapXY includes projection of the data, plotGEOmap does
not.  MAPcol and MAPstyle can be used to override the
colors and style in the map-list.  These are applied to all the
strokes.
</p>
<p>For strokes that are of style=1 points are plotted with graphical
parameters ptpch=&quot;.&quot; and ptcex=1 unless otherwise indicated.
</p>


<h3>Value</h3>

<p>Graphical Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>DOTOPOMAPI, addLLXY, plotGEOmap</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data('japmap', package='geomapdata' )
isel1 = which( japmap$STROKES$code != "i" &amp; japmap$STROKES$num&gt;120 )

PLOC=list(LON=c(137.008, 141.000), LAT=c(34.000, 36.992),
x=c(137.008, 141.000), y=c(34.000, 36.992) )
  PROJ = setPROJ(type=2, LAT0=mean(PLOC$y) , LON0=mean(PLOC$x) )
      
gxy = GLOB.XY(PLOC$LAT, PLOC$LON, PROJ)
 PLAT =  pretty(PLOC$LAT)
    PLAT = c(min(PLOC$LAT),
PLAT[PLAT&gt;min(PLOC$LAT) &amp; PLAT&lt;max(PLOC$LAT)],max(PLOC$LAT)) 
  PLON  = pretty(PLOC$LON)
        PLON = c(min(PLOC$LON),
PLON[PLON&gt;min(PLOC$LON) &amp; PLON&lt;max(PLOC$LON)], max(PLOC$LON))
     

plot(gxy$x, gxy$y,  asp=TRUE, ann=FALSE , axes=FALSE)

plotGEOmapXY(japmap,SEL=isel1,  LIM=c(PLOC$LON[1], PLOC$LAT[1],PLOC$LON[2],
     PLOC$LAT[2]) , PROJ=PROJ, add=TRUE )

addLLXY(PLAT,  PLON, PROJ=PROJ, LABS=TRUE, PMAT=NULL, TICS=c(.1,.1) )

###############
####  rotated map
PMAT = rotdelta4(-34)

 plotGEOmapXY(japmap, PMAT=PMAT,SEL=isel1, xpd=TRUE)


</code></pre>

<hr>
<h2 id='plothypos'>Plot Edicenters
</h2><span id='topic+plothypos'></span>

<h3>Description</h3>

<p>Plot hypocenter  color coded to depth
and size scaled by magnitude.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plothypos(lat, lon, z, proj, mag = NULL, cex = 0.4, pch =21, PMAT = NULL, alpha = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plothypos_+3A_lat">lat</code></td>
<td>
<p>Latitude
</p>
</td></tr>
<tr><td><code id="plothypos_+3A_lon">lon</code></td>
<td>
<p>Longitude
</p>
</td></tr>
<tr><td><code id="plothypos_+3A_z">z</code></td>
<td>
<p>km Depth, (positive down)
</p>
</td></tr>
<tr><td><code id="plothypos_+3A_proj">proj</code></td>
<td>
<p>Projection structure
</p>
</td></tr>
<tr><td><code id="plothypos_+3A_mag">mag</code></td>
<td>
<p>Magnitude
</p>
</td></tr>
<tr><td><code id="plothypos_+3A_cex">cex</code></td>
<td>
<p>character expansion
</p>
</td></tr>
<tr><td><code id="plothypos_+3A_pch">pch</code></td>
<td>
<p>plotting character, default=21</p>
</td></tr>
<tr><td><code id="plothypos_+3A_pmat">PMAT</code></td>
<td>
<p>transformation matrix
</p>
</td></tr>
<tr><td><code id="plothypos_+3A_alpha">alpha</code></td>
<td>
<p>transparency factor
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Adds hypocenters to an existing
plot.
</p>


<h3>Value</h3>

<p>Graphical Side effects.
</p>


<h3>Note</h3>

<p>The events are color coded according to depth.
</p>
<p>Only a few devices can handle
transparency effects.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>plotGEOmapXY, XSECEQ, eqswath, getmagsize
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(geomapdata)

data('EHB.LLZ')
data('japmap', package='geomapdata')

RLAT = range(japmap$POINTS$lat)
RLON = range(japmap$POINTS$lon)

JLAT = expandbound(RLAT, .1) 
JLON = expandbound(RLON, .1) 

PROJ = japmap$PROJ
##############  select the events in the region
isel1 = which( japmap$STROKES$code != "i" &amp; japmap$STROKES$num&gt;120 )

sel = which(
EHB.LLZ$lat &gt; JLAT[1] &amp;
EHB.LLZ$lat &lt; JLAT[2] &amp;
EHB.LLZ$lon  &gt; JLON[1] &amp;
EHB.LLZ$lon &lt; JLON[2])

sel = sel[1:200]

plotGEOmapXY(japmap , PROJ=PROJ, SEL=isel1,  add=FALSE, MAPcol="black") 

plothypos(EHB.LLZ$lat[sel], EHB.LLZ$lon[sel], EHB.LLZ$z[sel], PROJ,
mag=NULL,  cex=.8)


## Not run: 

fn = "/home/lees/WORK/SENDAI.EVENT/catsearch.8757"

g = getANSS(fn, skip=2)
g$jd = getjul(g$yr, g$mo, g$dom)

sel = which(
g$lat &gt; JLAT[1] &amp;
g$lat &lt; JLAT[2] &amp;
g$lon  &gt; JLON[1] &amp;
g$lon &lt; JLON[2])

olat = g$lat[sel]
olon = g$lon[sel]
ordz = g$z[sel]

mag = g$mag[sel]

gm = getmagsize(mag)


plotGEOmapXY(japmap , PROJ=PROJ,   add=FALSE, MAPcol="black") 
plothypos(g$lat[sel], g$lon[sel], g$z[sel], PROJ,
mag=NULL,  cex=gm)


plotGEOmapXY(japmap , PROJ=PROJ,   add=FALSE, MAPcol="black") 
plothypos(olat, olon, ordz, PROJ,
mag=NULL,  cex=gm)


plotGEOmapXY(japmap , PROJ=PROJ,   add=FALSE, MAPcol="black") 
plothypos(olat, olon, ordz, PROJ,
mag=mag,  cex=1 )



##################  transparent plot
pdfname = local.file('TOHOKU', "pdf")

cairo_pdf(file = pdfname , width = 8, height = 10)
plotGEOmapXY(japmap , PROJ=PROJ,   add=FALSE, MAPcol="black") 
plothypos(olat, olon, ordz, PROJ,
mag=mag,  cex=1, alpha=.3 )
dev.off()
################## 




## End(Not run)




</code></pre>

<hr>
<h2 id='plotnicetix'>Plot Lat-Lon tick marks</h2><span id='topic+plotnicetix'></span>

<h3>Description</h3>

<p>Find and plot nice tick marks on projected plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotnicetix(nex, nwhy, proj, tlen = 0.1,
fonts = c("serif", "plain"), PMAT = NULL, PLOT = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotnicetix_+3A_nex">nex</code></td>
<td>
<p>X coordinates</p>
</td></tr>
<tr><td><code id="plotnicetix_+3A_nwhy">nwhy</code></td>
<td>
<p>Y coordinates</p>
</td></tr>
<tr><td><code id="plotnicetix_+3A_proj">proj</code></td>
<td>
<p>prjection list</p>
</td></tr>
<tr><td><code id="plotnicetix_+3A_tlen">tlen</code></td>
<td>
<p>length for tic marks (inches)</p>
</td></tr>
<tr><td><code id="plotnicetix_+3A_fonts">fonts</code></td>
<td>
<p>Hershy font vector</p>
</td></tr>
<tr><td><code id="plotnicetix_+3A_pmat">PMAT</code></td>
<td>
<p>projection matrix from persp</p>
</td></tr>
<tr><td><code id="plotnicetix_+3A_plot">PLOT</code></td>
<td>
<p>logical, TRUE = add to plot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Graphical Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>niceLLtix, goodticdivs, getnicetix, dms</p>


<h3>Examples</h3>

<pre><code class='language-R'>
proj = setPROJ(7, LAT0 = 0 , LON0= -93)



rx = c(652713.4, 656017.4)
ry = c(1629271, 1631755)

plot(rx, ry, type='n', asp=1, axes=FALSE , ann=FALSE)
plotnicetix(rx, ry, proj, PMAT=NULL)

</code></pre>

<hr>
<h2 id='plotusa'>Map of USA</h2><span id='topic+plotusa'></span>

<h3>Description</h3>

<p>Quick plot of USA project with UTM.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotusa(USAmap, LATS=c(22,49.62741), LONS=c(229.29389,296.41803), add=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotusa_+3A_usamap">USAmap</code></td>
<td>
<p>Map for the U.S. (from geomapdata) </p>
</td></tr> 
<tr><td><code id="plotusa_+3A_lats">LATS</code></td>
<td>
<p>vector of latitude bounds</p>
</td></tr> 
<tr><td><code id="plotusa_+3A_lons">LONS</code></td>
<td>
<p>vector of longitude bounds</p>
</td></tr>
<tr><td><code id="plotusa_+3A_add">add</code></td>
<td>
<p>  add to existing plot </p>
</td></tr>
</table>


<h3>Value</h3>

<p>Graphical Side Effect
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>zebra</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
library(geomapdata)
data(package='geomapdata', "USAmap")
plotusa(USAmap)


## End(Not run)
</code></pre>

<hr>
<h2 id='plotUTM'>Plot UTM </h2><span id='topic+plotUTM'></span>

<h3>Description</h3>

<p>Plot UTM 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotUTM(proj, LIM, shiftlon = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotUTM_+3A_proj">proj</code></td>
<td>
<p>projection</p>
</td></tr>
<tr><td><code id="plotUTM_+3A_lim">LIM</code></td>
<td>
<p>Limit vector</p>
</td></tr>
<tr><td><code id="plotUTM_+3A_shiftlon">shiftlon</code></td>
<td>
<p>rotation around z axiz, default=0</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Graphical Side Effect
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>GLOB.XY</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(geomapdata)

data(USAmap)


proj = setPROJ(type=3, LAT0=33.75, LON0= RPMG::fmod(-79., 360) ,
  LAT1=34.333333,  LAT2=36.166667, LATS=NULL, LONS=NULL,
   DLAT=NULL, DLON=NULL,FE=0,FN=0)



ALOC=list(lon=c(274.5,288), lat=c(31, 38),
         LON=c(274.5, 288), LAT=c(31, 38), shiftlon=0)

plotGEOmapXY(USAmap, LIM=c(ALOC$LON[1], ALOC$lat[1],
     ALOC$LON[2], ALOC$lat[2]) , PROJ=proj, add=FALSE, shiftlon=0)


plotUTM(proj, c(ALOC$LON[1], ALOC$lat[1], ALOC$LON[2], ALOC$lat[2]))

##############  larger scale

## Not run: 
library(geomapdata)

data(USAmap)


p = plotusa(USAmap)

plotUTM(p$PROJ, LIM=p$LIM)

## End(Not run)

</code></pre>

<hr>
<h2 id='plotworldmap'>Plot World Map with UTM sections</h2><span id='topic+plotworldmap'></span>

<h3>Description</h3>

<p>Plot World Map with UTM sections
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotworldmap(MAP, LIM = c(-180, -90, 180, 90), shiftlon = 0,
add = TRUE, NUMB = FALSE, PLOTALL=TRUE, Decorate=FALSE , ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plotworldmap_+3A_map">MAP</code></td>
<td>
<p>GEOmap structure</p>
</td></tr>
<tr><td><code id="plotworldmap_+3A_lim">LIM</code></td>
<td>
<p>Vector of limits c(lon1, lat1, lon2, lat2) </p>
</td></tr>
<tr><td><code id="plotworldmap_+3A_shiftlon">shiftlon</code></td>
<td>
<p>Rotate map by degrees longitude (must adjust the LIM vector accordingly, see example below)</p>
</td></tr>
<tr><td><code id="plotworldmap_+3A_add">add</code></td>
<td>
<p>logical, TRUE=add to current plot</p>
</td></tr>
<tr><td><code id="plotworldmap_+3A_numb">NUMB</code></td>
<td>
<p>logical, add numbers to plot</p>
</td></tr>
<tr><td><code id="plotworldmap_+3A_plotall">PLOTALL</code></td>
<td>
<p>logical, plot all strokes, do not select</p>
</td></tr>
<tr><td><code id="plotworldmap_+3A_decorate">Decorate</code></td>
<td>
<p>logical, add UTM regional designations</p>
</td></tr>
<tr><td><code id="plotworldmap_+3A_...">...</code></td>
<td>
<p>grpahical parameters from par</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Graphical Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>plotGEOmap, plotGEOmapXY</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(geomapdata)
data(worldmap)
plotworldmap(worldmap)
### restrict to North Atlantic:
plotworldmap(worldmap, LIM = c(0, 0, 120, 90), shiftlon=250, PLOTALL=TRUE, Decorate=FALSE )

</code></pre>

<hr>
<h2 id='PointsAlong'>Find spaced Points along a line</h2><span id='topic+PointsAlong'></span>

<h3>Description</h3>

<p>find evenly spaced points along a line
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PointsAlong(x, y, spacing = NULL, N = 1, endtol = 0.1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="PointsAlong_+3A_x">x</code></td>
<td>
<p>x-coordinates</p>
</td></tr>
<tr><td><code id="PointsAlong_+3A_y">y</code></td>
<td>
<p>y-coordinates</p>
</td></tr>
<tr><td><code id="PointsAlong_+3A_spacing">spacing</code></td>
<td>
<p>spacing of points</p>
</td></tr>
<tr><td><code id="PointsAlong_+3A_n">N</code></td>
<td>
<p>number of points</p>
</td></tr>
<tr><td><code id="PointsAlong_+3A_endtol">endtol</code></td>
<td>
<p>indent on either ends</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The total length is returned: this is the line integral along the
trace.
</p>


<h3>Value</h3>

<p>List:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>x-coordinates</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>y-coordinates</p>
</td></tr>
<tr><td><code>rot</code></td>
<td>
<p>angle at the points</p>
</td></tr>
<tr><td><code>TOT</code></td>
<td>
<p>total length along the trace</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot(c(-5,5), c(-5,5), asp=1, type='n' )
ff=list()
ff$x=c(-4.850,-4.700,-3.934,-2.528, 0.603, 2.647, 3.861, 2.626)
ff$y=c(-4.045,-2.087,-0.710, 0.172, 1.291, 2.087,-0.753,-4.131)

g = PointsAlong(ff$x, ff$y, N=20)

lines(ff$x, ff$y)
points(g$x, g$y)

</code></pre>

<hr>
<h2 id='polyintern'>Internal point of polygon</h2><span id='topic+polyintern'></span>

<h3>Description</h3>

<p>Find a central internal point of a polygon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>polyintern(P, n = 10, PLOT=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="polyintern_+3A_p">P</code></td>
<td>
<p>Polygon,xy</p>
</td></tr>
<tr><td><code id="polyintern_+3A_n">n</code></td>
<td>
<p>grid dimension over polygon, n by n</p>
</td></tr>
<tr><td><code id="polyintern_+3A_plot">PLOT</code></td>
<td>
<p>logical, TRUE=plot</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A grid is laid over the polygo, the internal points are extracted and
for each one the shortest distance to te perimeter is determined.
Then the point with the largest distance is returned.
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>x coordinate of point</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>y coordinate of point</p>
</td></tr>
<tr><td><code>zi</code></td>
<td>
<p>index  of point</p>
</td></tr>
<tr><td><code>nx</code></td>
<td>
<p>internal grid points x</p>
</td></tr>
<tr><td><code>ny</code></td>
<td>
<p>internal grid points y</p>
</td></tr>
<tr><td><code>ef</code></td>
<td>
<p>internal grid points distances to perimeter</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>pline</p>


<h3>Examples</h3>

<pre><code class='language-R'>X=list()
X$x=c(11.991,11.942,11.891,11.834,11.775,11.725,11.691,
    11.712,11.746,11.804,11.865,11.957,11.991)
X$y=c(-2.0091,-2.0699,-2.0823,-2.1091,-2.1419,
    -2.1394,-2.1165,-2.0604,-2.0196,-1.9847,-1.9668,-1.9777,-2.0091)


polyintern(X, n = 10, PLOT=TRUE)



</code></pre>

<hr>
<h2 id='printGEOinfo'>printGEOinfo </h2><span id='topic+printGEOinfo'></span>

<h3>Description</h3>

<p>Print information on GEOmap strokes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>printGEOinfo(MAP, kstroke)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="printGEOinfo_+3A_map">MAP</code></td>
<td>
<p>GEOmap </p>
</td></tr>
<tr><td><code id="printGEOinfo_+3A_kstroke">kstroke</code></td>
<td>
<p>index to strokes </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints some of the meta data stored in the GEOmap header list, strokes.
</p>


<h3>Value</h3>

<p>Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>printGEOmap</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(coastmap)
printGEOinfo(coastmap, 1:10)

</code></pre>

<hr>
<h2 id='printGEOmap'>printGEOmap </h2><span id='topic+printGEOmap'></span>

<h3>Description</h3>

<p>Print information on GEOmap strokes
</p>


<h3>Usage</h3>

<pre><code class='language-R'>printGEOmap(G)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="printGEOmap_+3A_g">G</code></td>
<td>
<p>GEOmap </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints the full STROES list as a dataframe.
</p>


<h3>Value</h3>

<p>Side Effects 
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>printGEOinfo</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(coastmap)
printGEOmap(coastmap)

</code></pre>

<hr>
<h2 id='projtype'>List of Projection types</h2><span id='topic+projtype'></span>

<h3>Description</h3>

<p>List of Projection types in GEOMAP
</p>


<h3>Usage</h3>

<pre><code class='language-R'>projtype(proj=list())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="projtype_+3A_proj">proj</code></td>
<td>
<p>Projection list</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Just returns possile choices.
</p>


<h3>Value</h3>

<p>Side Effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>References</h3>

<p>Snyder, John P., Map Projections- a working manual, USGS, Professional Paper, 1987.
</p>


<h3>See Also</h3>

<p>setPROJ</p>


<h3>Examples</h3>

<pre><code class='language-R'>projtype()


proj = setPROJ(type = 1, LAT0 =23, LON0 = 35)

projtype(proj)

## or, for Kamchatka-Aleutians
LL=c(54.3861210149126,171.626386683545)

PROJ = setPROJ(type=2, LAT0=LL[1], LON0=LL[2], LATS=NULL, LONS=NULL, DLAT=NULL, DLON=NULL, FN =0)
projtype(PROJ)

</code></pre>

<hr>
<h2 id='rectPERIM'>Extract a rectangular perimeter
</h2><span id='topic+rectPERIM'></span>

<h3>Description</h3>

<p>Extract a rectangular perimeter
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rectPERIM(x, y = 1, pct = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rectPERIM_+3A_x">x</code></td>
<td>
<p>x values or a list include x, y members
</p>
</td></tr>
<tr><td><code id="rectPERIM_+3A_y">y</code></td>
<td>
<p>y values, if missing, x must be a list
</p>
</td></tr>
<tr><td><code id="rectPERIM_+3A_pct">pct</code></td>
<td>
<p>Percent expansion, based on range of x and y values.
If pct&gt;1 it is divided by 100 to get a fractional percent expansion.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rectangular box will be expanded
based on the percent pct. 
</p>


<h3>Value</h3>

<p> list of x, y values from lower left corner counter clockwise
around perimeter
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>getGEOperim
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
fx  =rnorm(20)
fy = rnorm(20)

plot(fx, fy, xlim=c(-4, 4), ylim=c(-4,4))
rp = rectPERIM(fx, fy)

polygon(rp)
text(rp, labels=1:4, pos=c(1,1,3,3), font=2, cex=2)


fx2  =rnorm(20, m=-1)
fy2 = rnorm(20, m=-1)

Fx = list(x=fx2, y=fy2)

points(Fx$x, Fx$y, col='red')

rp = rectPERIM(Fx)

polygon(rp, border='red')


########   try expanding the perim:

plot(fx, fy, xlim=c(-4, 4), ylim=c(-4,4), asp=1)
rp = rectPERIM(fx, fy, pct=0.1)

polygon(rp)

rp = rectPERIM(fx, fy, pct=0.2)

polygon(rp)



</code></pre>

<hr>
<h2 id='rekt2line'>Rectangle Line Overlap
</h2><span id='topic+rekt2line'></span>

<h3>Description</h3>

<p>Find points on a rectangle
closest to a set of points.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rekt2line(rekt, pnts)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rekt2line_+3A_rekt">rekt</code></td>
<td>
<p>rectangle comprised of 4 points in
counter clockwise direction.
</p>
</td></tr>
<tr><td><code id="rekt2line_+3A_pnts">pnts</code></td>
<td>
<p>set of points inside the rectangle
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Program is used for exploding symbols to
the edge of the rectangle input
</p>


<h3>Value</h3>

<p>list ofnew poistion  x,y values 
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>ExplodeSymbols
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
F1 = list(x=rnorm(20), y=rnorm(20))
r1 = range(F1$x)
r2 = range(F1$y)

r1 = c(r1[1]-0.1*diff(r1), r1[2]+0.1*diff(r1))
r2 = c(r2[1]-0.1*diff(r2), r2[2]+0.1*diff(r2))



rekt = list(x=c(r1[1], r1[2], r1[2], r1[1]), y=c(r2[1], r2[1], r2[2], r2[2]))
pnts = list(x1=rep(mean(r1), length(F1$x)), y1=rep(mean(r2), length(F1$y)),x2= F1$x, y2=F1$y)
NEW = rekt2line(rekt, pnts)

plot(range(c(F1$x, NEW$x)) , range(c(F1$y, NEW$y)), type='n')
rect(r1[1], r2[1], r1[2], r2[2], border=grey(.75), lty=2)

points(F1, pch=2, col='blue')
segments(F1$x, F1$y, NEW$x, NEW$y)
points(NEW, pch=3, col='red')



</code></pre>

<hr>
<h2 id='rose'>Rose Diagram
</h2><span id='topic+rose'></span>

<h3>Description</h3>

<p>Rose diagram of angle orientations or directions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rose(angles, bins, x = 0, y = 0, col = "black", border = "black",
annot = FALSE, main = "", prop = 1, pts = FALSE, cex = 1, pch = 16,
dotsep = 40, siz = 1, LABS = LABS, LABangle = 180, add = FALSE, SYM = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rose_+3A_angles">angles</code></td>
<td>
<p>numeric, vector of angles in radians
</p>
</td></tr>
<tr><td><code id="rose_+3A_bins">bins</code></td>
<td>
<p>integer, number of bins
</p>
</td></tr>
<tr><td><code id="rose_+3A_x">x</code></td>
<td>
<p>numeric, x location on page
</p>
</td></tr>
<tr><td><code id="rose_+3A_y">y</code></td>
<td>
<p>numeric, y location on page
</p>
</td></tr>
<tr><td><code id="rose_+3A_col">col</code></td>
<td>
<p>color for pie slices
</p>
</td></tr>
<tr><td><code id="rose_+3A_border">border</code></td>
<td>
<p>color for pie borders
</p>
</td></tr>
<tr><td><code id="rose_+3A_annot">annot</code></td>
<td>
<p>logical, annotation
</p>
</td></tr>
<tr><td><code id="rose_+3A_main">main</code></td>
<td>
<p>character, main title
</p>
</td></tr>
<tr><td><code id="rose_+3A_prop">prop</code></td>
<td>
<p>proportional plotting, default  = 1
</p>
</td></tr>
<tr><td><code id="rose_+3A_pts">pts</code></td>
<td>
<p>logical, add points (default=FALSE)
</p>
</td></tr>
<tr><td><code id="rose_+3A_cex">cex</code></td>
<td>
<p>character expansion
</p>
</td></tr>
<tr><td><code id="rose_+3A_pch">pch</code></td>
<td>
<p>plotting character
</p>
</td></tr>
<tr><td><code id="rose_+3A_dotsep">dotsep</code></td>
<td>
<p>separation of dots
</p>
</td></tr>
<tr><td><code id="rose_+3A_siz">siz</code></td>
<td>
<p>size of plot
</p>
</td></tr>
<tr><td><code id="rose_+3A_labs">LABS</code></td>
<td>
<p>Labels
</p>
</td></tr>
<tr><td><code id="rose_+3A_labangle">LABangle</code></td>
<td>
<p>angle for plotting Label angles
</p>
</td></tr>
<tr><td><code id="rose_+3A_add">add</code></td>
<td>
<p>logical, add to plot (default=FALSE)
</p>
</td></tr>
<tr><td><code id="rose_+3A_sym">SYM</code></td>
<td>
<p>logical, symmetric rose diagram (FALSE)
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Create a rose diagram or add rose diagram to an existing plot.
Used for plotting geographic orientations or directions.
</p>


<h3>Value</h3>

<p>list:
</p>
<table>
<tr><td><code>usector</code></td>
<td>
<p>sector angles</p>
</td></tr>
<tr><td><code>uradius</code></td>
<td>
<p>sector radii</p>
</td></tr>
<tr><td><code>usizx</code></td>
<td>
<p>x size scale</p>
</td></tr>
<tr><td><code>usizy</code></td>
<td>
<p>y size scale</p>
</td></tr>
<tr><td><code>x</code></td>
<td>
<p>x center on page</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>y center on page</p>
</td></tr>
</table>


<h3>Note</h3>

<p>For symmetric plots, bins are rotated and added together,
then the reflection is made.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>package RFOC for distributions on a sphere
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
ff=c(23,27,53,58,64,83,85,88,93,99,100,
  105,113,113,114,117,121,123,125,126,
  126,126,127,127,128,128,129,132,132,
  132,134,135,137,144,145,145,146,153,
  155,155,155,157,163,165,171,172,179,181,186,190,212)




rose((ff-90)*pi/180, 50, x=0, y=0, LABS = c("N", "S", "W", "E"), 
annot=TRUE,border='white',LABangle=135, siz =sqrt(2), SYM=FALSE)

rose((ff-90)*pi/180, 50, x=0, y=0, LABS = c("N", "S", "W", "E"), 
annot=TRUE,border='white',LABangle=135, siz =sqrt(2), SYM=TRUE)





</code></pre>

<hr>
<h2 id='rotateGEOmap'>Rotate a GEOmap
</h2><span id='topic+rotateGEOmap'></span>

<h3>Description</h3>

<p>Rotate a GEOmap to a new location on the globe
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotateGEOmap(INmap, TARGlat, TARGlon, LAT0, LON0, beta = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotateGEOmap_+3A_inmap">INmap</code></td>
<td>
<p>Input GEOmap</p>
</td></tr>
<tr><td><code id="rotateGEOmap_+3A_targlat">TARGlat</code></td>
<td>
<p> Target center latitide</p>
</td></tr>
<tr><td><code id="rotateGEOmap_+3A_targlon">TARGlon</code></td>
<td>
<p> Target center longitide</p>
</td></tr>
<tr><td><code id="rotateGEOmap_+3A_lat0">LAT0</code></td>
<td>
<p>  Source center latitide</p>
</td></tr>
<tr><td><code id="rotateGEOmap_+3A_lon0">LON0</code></td>
<td>
<p> Source center longitide</p>
</td></tr>
<tr><td><code id="rotateGEOmap_+3A_beta">beta</code></td>
<td>
<p> rotation through axis coming out of screen</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used to translate a given map region
to another for over plotting.  You can compare the
areas of two region using the same projection.
</p>


<h3>Value</h3>

<p>GEOmap list.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>plotGEOmapXY
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(maps)


zz = map('state', region = c('new york', 'new jersey', 'penn'))

neweng  = maps2GEOmap(zz)

plotGEOmap(neweng)
##  L1 = locator(1)
L1=list()
L1$x=c(283.671347071854)
L1$y=c(42.008587074537)

LIMS1 = list( lon=range(neweng$POINTS$lon), lat=range(neweng$POINTS$lat) )

LIMS = c(LIMS1$lon[1], LIMS1$lat[1], LIMS1$lon[2], LIMS1$lat[2])

##########   prepare maps 2:

z2 = map('world', region = c('iceland'))
ice   = maps2GEOmap(z2)
plotGEOmap(ice)

##  L2 = locator(1)
L2=list()
L2$x=c(341.146812632372)
L2$y=c(64.9180246121089)

############    this version here is nicer, but required WORLMAP2
###kice = grep('ice' , coast2$STROKES$nam, ignore.case =TRUE)

### ice = GEOmap.Extract(coast2, kice  ,"in")

MAP = rotateGEOmap(ice, L1$y ,  L1$x ,  L2$y ,  L2$x, beta=-90 )


proj = setPROJ( 2, LAT0=L1$y, LON0=L1$x )

plotGEOmapXY(neweng, LIM=LIMS,  PROJ =proj, axes=FALSE, xlab="", ylab="" )


plotGEOmapXY(MAP, LIM=LIMS,  PROJ =proj, axes=FALSE, xlab="",
     ylab="", add = TRUE, MAPcol = grey(.85)  , lwd=2, xpd=TRUE)



  plotGEOmapXY(neweng, LIM=LIMS,  PROJ =proj,
       axes=FALSE, xlab="", ylab="", add=TRUE )
  



</code></pre>

<hr>
<h2 id='rotdelta4'>rotation about Z-axis</h2><span id='topic+rotdelta4'></span>

<h3>Description</h3>

<p>rotation about Z-axis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotdelta4(delta)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotdelta4_+3A_delta">delta</code></td>
<td>
<p>angle in degrees</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix for rotation
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>roty4, rotx4, trans4</p>


<h3>Examples</h3>

<pre><code class='language-R'>rotdelta4(23)


</code></pre>

<hr>
<h2 id='rotmat2D'>set a rotation matrix</h2><span id='topic+rotmat2D'></span>

<h3>Description</h3>

<p>set a rotation matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotmat2D(alph)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotmat2D_+3A_alph">alph</code></td>
<td>
<p>angle in radians </p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix for rotation in 2 dimensions
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>

########  make an ellipse
 theta=seq(0,360,by=5)*pi/180

r1 = 0.4
r2 = 0.2

   m=matrix(rep(0,2*length(theta)),ncol=2)
  
 m[,1]=r1*cos(theta)
    m[,2]=r2*sin(theta)


##  make a dummy plot and draw ellipse

 plot(c(0, 1), c(0, 1), main = "this is a test", sub = "sutitle",
        xlab = "this is x", ylab = "this is y")

lines(m[,1]+.5, m[,2]+.5)

## get rotation matrix
R = rotmat2D(32)

#########  apply rotation
nm=m %*% R


###  plot
lines(nm[,1]+.5, nm[,2]+.5, col='red')

</code></pre>

<hr>
<h2 id='rotx4'>x-axis rotation matrix</h2><span id='topic+rotx4'></span>

<h3>Description</h3>

<p>x-axis rotation matrix</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotx4(vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotx4_+3A_vec">vec</code></td>
<td>
<p>vector of direction cosines
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Length of vector cannot be zero.
</p>


<h3>Value</h3>

<p>Matrix for rotation
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>roty4, rotdelta4
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
v = c(12,13,-4)

rotx4(v)



</code></pre>

<hr>
<h2 id='roty4'>y-axis rotation matrix
</h2><span id='topic+roty4'></span>

<h3>Description</h3>

<p>y-axis rotation matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>roty4(vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="roty4_+3A_vec">vec</code></td>
<td>
<p>vector of direction cosines</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Length of vector cannot be zero.
</p>


<h3>Value</h3>

<p>Matrix for rotation
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Rogers and Adams</p>


<h3>See Also</h3>

<p>rotx4, rotdelta4</p>


<h3>Examples</h3>

<pre><code class='language-R'>
v = c(12,13,-4)

roty4(v)

</code></pre>

<hr>
<h2 id='SELGEOmap'>Select parts of a GEOmap</h2><span id='topic+SELGEOmap'></span>

<h3>Description</h3>

<p>Using area, number of points and Lat-Lon Limits, extracts
map strokes and creates a new GEOmap
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SELGEOmap(MAP, ncut = 3, acut = c(0, 1e+05), proj = NULL, LIM = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SELGEOmap_+3A_map">MAP</code></td>
<td>
<p>Map structure</p>
</td></tr>
<tr><td><code id="SELGEOmap_+3A_ncut">ncut</code></td>
<td>
<p>minimum number of points in polygon</p>
</td></tr>
<tr><td><code id="SELGEOmap_+3A_acut">acut</code></td>
<td>
<p>vector, min and max of areas to include</p>
</td></tr>
<tr><td><code id="SELGEOmap_+3A_proj">proj</code></td>
<td>
<p>map projection</p>
</td></tr>
<tr><td><code id="SELGEOmap_+3A_lim">LIM</code></td>
<td>
<p>vector, c(lon1, lat1, lon2, lat2)  </p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses sf::st_area  function.  If proj and LIM are NULL then
no selection on limits are used
ncut is used to eliminate area calculations with strokes less than the
specified number.
</p>


<h3>Value</h3>

<p>GEOmap LIST
</p>
<table>
<tr><td><code>STROKES</code></td>
<td>
<p>list</p>
</td></tr>
<tr><td><code>nam</code></td>
<td>
<p>name of stroke</p>
</td></tr>
<tr><td><code>num</code></td>
<td>
<p>number of points in stroke</p>
</td></tr>
<tr><td><code>index</code></td>
<td>
<p>index of stroke</p>
</td></tr>
<tr><td><code>col</code></td>
<td>
<p>color of stroke</p>
</td></tr>
<tr><td><code>style</code></td>
<td>
<p>style of stroke</p>
</td></tr>
<tr><td><code>code</code></td>
<td>
<p>code of stroke</p>
</td></tr>
<tr><td><code>LAT1</code></td>
<td>
<p>lower left Lat of stroke</p>
</td></tr>
<tr><td><code>LAT2</code></td>
<td>
<p>upper right Lat  of stroke</p>
</td></tr>
<tr><td><code>LON1</code></td>
<td>
<p>lower left Lon  of stroke</p>
</td></tr>
<tr><td><code>LON2</code></td>
<td>
<p>upper right Lon of stroke</p>
</td></tr>
<tr><td><code>POINTS</code></td>
<td>
<p>list</p>
</td></tr>
<tr><td><code>lat</code></td>
<td>
<p>vector of lats</p>
</td></tr>
<tr><td><code>lon</code></td>
<td>
<p>vector of lons</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>geoarea, sf::st_area</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(geomapdata)
data(worldmap)
skam = SELGEOmap(worldmap, ncut=3, acut=c(10000, Inf), proj=NULL, LIM=NULL)

par(mfrow=c(2,1))

#######  plot world map, with all lines:
plotGEOmap(worldmap)
length(worldmap$STROKES$num)
######   same plot with some lines removed:
plotGEOmap(skam)
length(skam$STROKES$num)

#####################
#####################

</code></pre>

<hr>
<h2 id='setMarkup'>Set up mark up for maps</h2><span id='topic+setMarkup'></span>

<h3>Description</h3>

<p>Interactive set up of mark of labels for a map
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setMarkup(LABS = NULL, PROJ = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setMarkup_+3A_labs">LABS</code></td>
<td>
<p>vector of labels</p>
</td></tr>
<tr><td><code id="setMarkup_+3A_proj">PROJ</code></td>
<td>
<p>projection structure</p>
</td></tr>
</table>


<h3>Details</h3>

<p>labels are set one-by-one and the user inout relevant information
like locator() and other features
</p>


<h3>Value</h3>

<p>List of Markup information
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>Markup</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 


  plot(c(0, 1), c(0, 1), main = "this is a test", sub = "sutitle",
        xlab = "this is x", ylab = "this is y")

LABS = c("this is", "a", "test")

MUP = setMarkup(LABS)

## End(Not run)

</code></pre>

<hr>
<h2 id='setplotmat'>set up matrices for selecting from eTOPO5</h2><span id='topic+setplotmat'></span>

<h3>Description</h3>

<p>set up matrices for selecting from eTOPO5
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setplotmat(x, y)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setplotmat_+3A_x">x</code></td>
<td>
<p>vector of lons</p>
</td></tr>
<tr><td><code id="setplotmat_+3A_y">y</code></td>
<td>
<p>vector of lats</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For extracting from ETOPO5 and ETOPO2, used internally in DOTOPOMAPI
</p>


<h3>Value</h3>

<p>list(x=EX, y=WHY)
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>DOTOPOMAPI</p>


<h3>Examples</h3>

<pre><code class='language-R'>PLOC= list(LON=c(138.3152, 139.0214), 
LAT=c(35.09047, 35.57324))

ax = seq(from=PLOC$LON[1],   to=PLOC$LON[2], length=10)
ay = seq(from=PLOC$LAT[1],   to=PLOC$LAT[2], length=10)

 G = setplotmat(ax,ay)

</code></pre>

<hr>
<h2 id='SETPOLIMAP'>Set up polygons for World map Database</h2><span id='topic+SETPOLIMAP'></span>

<h3>Description</h3>

<p>Divides world into continents.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SETPOLIMAP()
</code></pre>


<h3>Details</h3>

<p>Used for CIA data base 
</p>


<h3>Value</h3>

<p>Returns GEOmap list of continents
</p>
<table>
<tr><td><code>STROKES</code></td>
<td>
<p>list(nam, num, index, col, style, code, LAT1, LAT2, LON1, LON2)</p>
</td></tr>
<tr><td><code>POINTS</code></td>
<td>
<p>list(lat, lon)</p>
</td></tr>
<tr><td><code>PROJ</code></td>
<td>
<p>list(type, LAT0, LON0, LAT1, LAT2, LATS, LONS, DLAT, DLON, FE, FN, name)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>selectPOLImap</p>


<h3>Examples</h3>

<pre><code class='language-R'>LMAP = SETPOLIMAP()
</code></pre>

<hr>
<h2 id='setPROJ'>Set Projection</h2><span id='topic+setPROJ'></span>

<h3>Description</h3>

<p>Setup parameters for Map Projection
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setPROJ(type = 1, LAT0 = 0, LON0 = 0, LAT1 = 0, LAT2 = 0, LATS = NULL,
 LONS = NULL, DLAT = NULL, DLON = NULL, FE = 0, FN = 0, IDATUM=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="setPROJ_+3A_type">type</code></td>
<td>
<p>Type of projection</p>
</td></tr>
<tr><td><code id="setPROJ_+3A_lat0">LAT0</code></td>
<td>
<p>Central Latitude</p>
</td></tr>
<tr><td><code id="setPROJ_+3A_lon0">LON0</code></td>
<td>
<p>Central Longitude</p>
</td></tr>
<tr><td><code id="setPROJ_+3A_lat1">LAT1</code></td>
<td>
<p>Latitude parameter for special projection, where needed</p>
</td></tr>
<tr><td><code id="setPROJ_+3A_lat2">LAT2</code></td>
<td>
<p>Latitude parameter for special projection, where needed</p>
</td></tr>
<tr><td><code id="setPROJ_+3A_lats">LATS</code></td>
<td>
<p>vector of range of Latitudes</p>
</td></tr>
<tr><td><code id="setPROJ_+3A_lons">LONS</code></td>
<td>
<p>vector of range of Longitudes</p>
</td></tr>
<tr><td><code id="setPROJ_+3A_dlat">DLAT</code></td>
<td>
<p>difference of Lats</p>
</td></tr>
<tr><td><code id="setPROJ_+3A_dlon">DLON</code></td>
<td>
<p>difference of Lons</p>
</td></tr>
<tr><td><code id="setPROJ_+3A_fe">FE</code></td>
<td>
<p>False Easting</p>
</td></tr>
<tr><td><code id="setPROJ_+3A_fn">FN</code></td>
<td>
<p>False Northing</p>
</td></tr>
<tr><td><code id="setPROJ_+3A_idatum">IDATUM</code></td>
<td>
<p>integer, index to the datum database</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Set up for the various projections used by GEOmap
</p>


<h3>Value</h3>

<p>List of values described above
</p>


<h3>Note</h3>

<p>Some of the parameters are not critical to all the
choices or Map Projection. In that case they are set to defaults and
ignored by that projection.
</p>
<p>LONs are modified and rectified by fmod function.
</p>
<p>The datum data base is accesses via the function DATUMinfo.
There are 11 different projection datums.
These are NAD83/WGS84, GRS 80, WGS72, Australian 1965, Krasovsky 1940, International (1924) -Hayford (1909), Clake 1880, Clarke 1866, Airy 1830, Bessel 1841, Everest 1830.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>References</h3>

<p>Snyder, John P., Map Projections- a working manual, USGS, Professional Paper, 1987.
</p>


<h3>See Also</h3>

<p>projtype, XY.GLOB, GLOB.XY, DATUMinfo</p>


<h3>Examples</h3>

<pre><code class='language-R'>
######  type
projtype()
######  type = mercator spherical
setPROJ(type = 1, LAT0 =23, LON0 = 35)

### Hengill Map: lambert.cc
setPROJ(type=3, LAT0=65, LON0=360-19 ,LAT1=64+15/60,
LAT2=65+45/60,LATS=NULL, 
LONS=NULL, DLAT=NULL, DLON=NULL,FE=500000,FN=500000)

### old lees/crosson projection
setPROJ(type=99, LAT0=23, LON0=35, LATS=NULL, LONS=NULL, DLAT=NULL,
DLON=NULL, FN =0)

###  world map equid.cyl
setPROJ(6, LAT0=0, LON0=0)

##  North Carolina Map lambert.cc
setPROJ(type=3, LAT0=36+20/60, LON0=78+30/60,LAT1=36+46/60,
LAT2=37+58/60, LATS=NULL, LONS=NULL, DLAT=NULL, DLON=NULL,FE=0,FN=0)

###  No Projection
setPROJ(type = 0, LAT0 =23, LON0 = 35)


</code></pre>

<hr>
<h2 id='settopocol'>Topographic Color Map</h2><span id='topic+settopocol'></span>

<h3>Description</h3>

<p>Set up vectors and structures for creating a
color map for topographic plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>settopocol()
</code></pre>


<h3>Details</h3>

<p>RGB Colors are defined for topographic
elevations and/or depths.  The basic data is stored
as z1 red1 green1 blue1 z2 red2 green2 blue2
and linear interpolation is used between
elevations.
The color set here extends from green in lowlands around sealevel
through browns and light-browns through to
whites at snow covered peaks.
</p>


<h3>Value</h3>

<p>LIST:calcol=calcol , coltab=coltab
</p>
<table>
<tr><td><code>calcol</code></td>
<td>
<p>list(z1, r1,g1,b1,
z2,  r2,g2,b2, note)</p>
</td></tr>
<tr><td><code>coltab</code></td>
<td>
<p>color table, matrix </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>settopocol()
</code></pre>

<hr>
<h2 id='sizelegend'>Magnitude size legend</h2><span id='topic+sizelegend'></span>

<h3>Description</h3>

<p>Plot a simple legend of magnitude sizes at the top of a plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sizelegend(se, am, pch = pch)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sizelegend_+3A_se">se</code></td>
<td>
<p>vector, sizes</p>
</td></tr>
<tr><td><code id="sizelegend_+3A_am">am</code></td>
<td>
<p>vector, labels</p>
</td></tr>
<tr><td><code id="sizelegend_+3A_pch">pch</code></td>
<td>
<p>plotting character</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A box around the legend is currently introduced.
</p>


<h3>Value</h3>

<p>Graphical Side Effect
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>

x = rnorm(30)
y = rnorm(30)

mags = runif(30, 1,8)


plot(x, y, type="n")

esiz = exp(mags)
rsiz = RPMG::RESCALE(esiz, .4, 10, min(esiz), max(esiz))
points(x, y, pch=1, cex=rsiz)

am = pretty(mags)
am = am[am&gt;min(mags) &amp; am&lt;max(mags) ]

em = exp(am)
se = RPMG::RESCALE(em, .4, 10, min(esiz), max(esiz))

sizelegend(se, am, pch=1)



</code></pre>

<hr>
<h2 id='sqrTICXY'>Tick marks for Square plot</h2><span id='topic+sqrTICXY'></span>

<h3>Description</h3>

<p>Lat-Lon Tick marks and grid for Square plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sqrTICXY(prsurf, proj, side = c(1, 2, 3, 4), PMAT=NULL, LLgrid = TRUE,
 col = "black", colt = "black", font=5, cex=1, lty=2, lwd=1,
pcex=1, TICS=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sqrTICXY_+3A_prsurf">prsurf</code></td>
<td>
<p>list with x, y</p>
</td></tr>
<tr><td><code id="sqrTICXY_+3A_proj">proj</code></td>
<td>
<p>projection</p>
</td></tr>
<tr><td><code id="sqrTICXY_+3A_side">side</code></td>
<td>
<p>vector, which sides to plot, 1=bottom, 2=left, 3=top,
4=right</p>
</td></tr>
<tr><td><code id="sqrTICXY_+3A_pmat">PMAT</code></td>
<td>
<p> projection matrix from persp  </p>
</td></tr>
<tr><td><code id="sqrTICXY_+3A_llgrid">LLgrid</code></td>
<td>
<p>logical, whether to add grid</p>
</td></tr>
<tr><td><code id="sqrTICXY_+3A_col">col</code></td>
<td>
<p>color for grid</p>
</td></tr>
<tr><td><code id="sqrTICXY_+3A_colt">colt</code></td>
<td>
<p>color for text</p>
</td></tr>
<tr><td><code id="sqrTICXY_+3A_font">font</code></td>
<td>
<p>default=2, font for labels</p>
</td></tr>
<tr><td><code id="sqrTICXY_+3A_cex">cex</code></td>
<td>
<p>character expansion for tic labels</p>
</td></tr>
<tr><td><code id="sqrTICXY_+3A_lty">lty</code></td>
<td>
<p>Line type for lines, default=2</p>
</td></tr>
<tr><td><code id="sqrTICXY_+3A_lwd">lwd</code></td>
<td>
<p>Line width for lines, default=1</p>
</td></tr>
<tr><td><code id="sqrTICXY_+3A_pcex">pcex</code></td>
<td>
<p>character expansion for tics, pch=2</p>
</td></tr>
<tr><td><code id="sqrTICXY_+3A_tics">TICS</code></td>
<td>
<p>list(lat, lon) this will replace the default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Graphical side effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>addLLXY, plotGEOmapXY</p>


<h3>Examples</h3>

<pre><code class='language-R'>
 KAMlat = c(48.5,  65)
    KAMlon = c(150, 171)
    proj = setPROJ( 2, LAT0=mean(KAMlat) , LON0=mean(KAMlon) )
    PLOC=list(LON=KAMlon,LAT=KAMlat)


    PLON = seq(from=KAMlon[1], to=KAMlon[2], by=2)
    PLAT = seq(from=KAMlat[1], to=KAMlat[2], by=2)
    
    proj = setPROJ(2, LON0=mean(KAMlon), LAT0=mean(KAMlat))
library(geomapdata)
data(worldmap)

 plotGEOmapXY(worldmap, LIM=c(KAMlon[1], KAMlat[1], KAMlon[2], KAMlat[2]),
PROJ =proj, axes=FALSE, xlab="", ylab="" )

kbox = GLOB.XY( KAMlat,KAMlon, proj)
 sqrTICXY(kbox , proj, side=c(1,2,3,4), LLgrid=TRUE, col=grey(.7) )

#############  more detailed map:
data(kammap)

 plotGEOmapXY(kammap, LIM=c(KAMlon[1], KAMlat[1], KAMlon[2], KAMlat[2]),
PROJ =proj, axes=FALSE, xlab="", ylab="" )

kbox = GLOB.XY( KAMlat,KAMlon, proj)
 sqrTICXY(kbox , proj, side=c(1,2,3,4), LLgrid=TRUE, col=grey(.7) )
   


</code></pre>

<hr>
<h2 id='SSfault'>Strike Slip Fault</h2><span id='topic+SSfault'></span>

<h3>Description</h3>

<p>Plot a strike slip fault
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SSfault(x, y, h = 1, hoff = 0.15, rot = list(cs = 1, sn = 0),
col = "black", dextral = TRUE, lwd = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SSfault_+3A_x">x</code></td>
<td>
<p>x-coordinates</p>
</td></tr>
<tr><td><code id="SSfault_+3A_y">y</code></td>
<td>
<p>y-coordinates</p>
</td></tr>
<tr><td><code id="SSfault_+3A_h">h</code></td>
<td>
<p>length of symbol</p>
</td></tr>
<tr><td><code id="SSfault_+3A_hoff">hoff</code></td>
<td>
<p>distance from line</p>
</td></tr>
<tr><td><code id="SSfault_+3A_rot">rot</code></td>
<td>
<p>rotation list</p>
</td></tr>
<tr><td><code id="SSfault_+3A_col">col</code></td>
<td>
<p>color</p>
</td></tr>
<tr><td><code id="SSfault_+3A_dextral">dextral</code></td>
<td>
<p>logical, TRUE=dextral polarity </p>
</td></tr>
<tr><td><code id="SSfault_+3A_lwd">lwd</code></td>
<td>
<p>line width</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Rotation vector is provided as list(cs=vector(), sn=vector()).
</p>


<h3>Value</h3>

<p>Graphical Side effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>GEOsymbols</p>


<h3>Examples</h3>

<pre><code class='language-R'>G=list()
G$x=c(-1.0960,-0.9942,-0.8909,-0.7846,-0.6738,-0.5570,-0.4657,-0.3709,
-0.2734,-0.1740,-0.0734, 0.0246, 0.1218, 0.2169, 0.3086, 0.3956, 0.4641, 
0.5293, 0.5919, 0.6530, 0.7131)
G$y=c(-0.72392,-0.62145,-0.52135,-0.42599,-0.33774,-0.25896,-0.20759,
-0.16160,-0.11981,-0.08105,-0.04414,-0.00885, 0.02774, 0.06759, 0.11262, 
0.16480, 0.21487, 0.27001, 0.32895, 0.39044, 0.45319)


plot(G$x, G$y, type='n',asp=1, axes=FALSE, xlab='', ylab='')

 g = PointsAlong(G$x, G$y, N=3)



 lines(G$x,G$y,col='blue')


###  left lateral strike slip: sinestral
 sk = 2
SSfault(g$x,g$y,h=sk,hoff=sk, rot=g$rot , col='blue', dextral=FALSE)
     
###  right  lateral strike slip: dextral

plot(G$x, G$y, type='n',asp=1, axes=FALSE, xlab='', ylab='')
 lines(G$x,G$y,col='blue')

SSfault(g$x,g$y,h=sk,hoff=sk, rot=g$rot , col='blue', dextral=TRUE)
     

</code></pre>

<hr>
<h2 id='STROKEinfo'>Stroke Information
</h2><span id='topic+STROKEinfo'></span>

<h3>Description</h3>

<p>print stroke information from a GEOmap data base
</p>


<h3>Usage</h3>

<pre><code class='language-R'>STROKEinfo(map, w = 1, h = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="STROKEinfo_+3A_map">map</code></td>
<td>
<p>GEOmap data list
</p>
</td></tr>
<tr><td><code id="STROKEinfo_+3A_w">w</code></td>
<td>
<p>which strokes to extract, vector of number indices or single
string
to match names in data base list
</p>
</td></tr>
<tr><td><code id="STROKEinfo_+3A_h">h</code></td>
<td>
<p>numeric vector of columns of data base, or vector of characters
to match names.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses grep to match names so can have short names
</p>


<h3>Value</h3>

<p>data.frame of extracted strokes
</p>


<h3>Note</h3>

<p>Use gsub to change the names of strokes.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>gsub
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(coastmap)
STROKEinfo(coastmap, h="nam", w="Indo")

STROKEinfo(coastmap, w="Indo", h=c("nam", "col" ) )


</code></pre>

<hr>
<h2 id='subsetTOPO'>Subset a Topo map </h2><span id='topic+subsetTOPO'></span>

<h3>Description</h3>

<p>Extract a subset of a topo DEM 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>subsetTOPO(TOPO, ALOC, PROJ, nx=500, ny=500, nb = 4, mb = 4, hb = 8)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="subsetTOPO_+3A_topo">TOPO</code></td>
<td>
<p>DEM list including x,y,z</p>
</td></tr>
<tr><td><code id="subsetTOPO_+3A_aloc">ALOC</code></td>
<td>
<p>list including  LAT LON vectors for extracting an array
from the DEM</p>
</td></tr>
<tr><td><code id="subsetTOPO_+3A_proj">PROJ</code></td>
<td>
<p>projection</p>
</td></tr>
<tr><td><code id="subsetTOPO_+3A_nx">nx</code></td>
<td>
<p>number of points in x grid, default=500</p>
</td></tr>
<tr><td><code id="subsetTOPO_+3A_ny">ny</code></td>
<td>
<p>number of points in y grid, default=500</p>
</td></tr>
<tr><td><code id="subsetTOPO_+3A_nb">nb</code></td>
<td>
<p>see function mba.surf, default = 4</p>
</td></tr>
<tr><td><code id="subsetTOPO_+3A_mb">mb</code></td>
<td>
<p>see function mba.surf, default = 4</p>
</td></tr>
<tr><td><code id="subsetTOPO_+3A_hb">hb</code></td>
<td>
<p>see function mba.surf , default= 8</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Used for extracting a subset of ETOPO5 or ETOPO2.
</p>
<p>ETOPO5 or ETOPO2 can be downloaded from
and installed using these links:
<a href="http://leesj.sites.oasis.unc.edu/FETCH/GRAB/RPACKAGES/ETOPO2.RData">http://leesj.sites.oasis.unc.edu/FETCH/GRAB/RPACKAGES/ETOPO2.RData</a>
and
<a href="http://leesj.sites.oasis.unc.edu/FETCH/GRAB/RPACKAGES/ETOPO5.RData">http://leesj.sites.oasis.unc.edu/FETCH/GRAB/RPACKAGES/ETOPO5.RData</a>
</p>


<h3>Value</h3>

<table>
<tr><td><code>x</code></td>
<td>
<p>vector x-coordinates</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>vector y-coordinates</p>
</td></tr>
<tr><td><code>z</code></td>
<td>
<p>2D matrix of elevations</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>GEOTOPO</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#### first install the ETOPO5 data package
library(geomapdata)
load(ETOPO5)
##   data(ETOPO5)
PLOC=list(LON=c(137.008, 141.000),LAT=c(34.000, 36.992),
            x=c(137.008, 141.000), y=c(34.000, 36.992) )

 PROJ = setPROJ(type=2, LAT0=mean(PLOC$y) , LON0=mean(PLOC$x) )
JAPANtopo = subsetTOPO(ETOPO5, PLOC, PROJ)

## End(Not run)


</code></pre>

<hr>
<h2 id='SynAnticline'>Syncline and Anticline traces</h2><span id='topic+SynAnticline'></span>

<h3>Description</h3>

<p>Syncline and Anticline traces
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SynAnticline(x, y, syn = TRUE, spacing = NULL, N = 1, r1 = 1, r2 = 1.2,
 h1 = 0, h2 = 0, endtol = 0.1, REV = FALSE, col = "black", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SynAnticline_+3A_x">x</code></td>
<td>
<p>x-coordinates</p>
</td></tr>
<tr><td><code id="SynAnticline_+3A_y">y</code></td>
<td>
<p>y-coordinates</p>
</td></tr>
<tr><td><code id="SynAnticline_+3A_syn">syn</code></td>
<td>
<p>logical, TRUE=syncline, FALSE=anticline</p>
</td></tr>
<tr><td><code id="SynAnticline_+3A_spacing">spacing</code></td>
<td>
<p>spacing of points</p>
</td></tr>
<tr><td><code id="SynAnticline_+3A_n">N</code></td>
<td>
<p>number of points</p>
</td></tr>
<tr><td><code id="SynAnticline_+3A_r1">r1</code></td>
<td>
<p>x-radius of curled part</p>
</td></tr>
<tr><td><code id="SynAnticline_+3A_r2">r2</code></td>
<td>
<p>y-radius of curled part</p>
</td></tr>
<tr><td><code id="SynAnticline_+3A_h1">h1</code></td>
<td>
<p>length of first leg</p>
</td></tr>
<tr><td><code id="SynAnticline_+3A_h2">h2</code></td>
<td>
<p>length of 2nd leg</p>
</td></tr>
<tr><td><code id="SynAnticline_+3A_endtol">endtol</code></td>
<td>
<p>indent on either ends</p>
</td></tr>
<tr><td><code id="SynAnticline_+3A_rev">REV</code></td>
<td>
<p>reverse direction of x-y</p>
</td></tr>
<tr><td><code id="SynAnticline_+3A_col">col</code></td>
<td>
<p>color of teeth and line</p>
</td></tr>
<tr><td><code id="SynAnticline_+3A_...">...</code></td>
<td>
<p>graphical parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Graphical Side effect
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu</p>


<h3>See Also</h3>

<p>PointsAlong</p>


<h3>Examples</h3>

<pre><code class='language-R'>


ff=list()
ff$x=c(-4.850,-4.700,-3.934,-2.528, 0.603, 2.647, 3.861, 2.626)
ff$y=c(-4.045,-2.087,-0.710, 0.172, 1.291, 2.087,-0.753,-4.131)

G =getsplineG(ff$x, ff$y, kdiv=20)

########  anticline
plot(c(-5,5), c(-5,5), asp=1, type='n' )

SynAnticline(G$x,G$y,  N=5, syn=FALSE, endtol=.2)

######## syncline
plot(c(-5,5), c(-5,5), asp=1, type='n' )
SynAnticline(G$x,G$y,  N=5, syn=FALSE, endtol=.2)




</code></pre>

<hr>
<h2 id='targetLL'>Target Lat-Lon
</h2><span id='topic+targetLL'></span>

<h3>Description</h3>

<p>Get a target Lat-Lon from a set of Lat-Lon pairs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>targetLL(sta, rdist = 100)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="targetLL_+3A_sta">sta</code></td>
<td>
<p>station list (with slots lat lon)
</p>
</td></tr>
<tr><td><code id="targetLL_+3A_rdist">rdist</code></td>
<td>
<p>radius in km
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Uses the Median station as the center and returns the lat-lon
extents of the target region.
</p>


<h3>Value</h3>

<p>list(
</p>
<table>
<tr><td><code>A</code></td>
<td>
<p> matrix with lat-lon pairs (lons=(0,360)  </p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>  matrix with lat-lon pairs  (lons=(-180, 180))  </p>
</td></tr>
<tr><td><code>mlat</code></td>
<td>
<p> median latitude </p>
</td></tr>
<tr><td><code>mlon</code></td>
<td>
<p> median longitude </p>
</td></tr> 
<tr><td><code>Jlat</code></td>
<td>
<p> range of lats </p>
</td></tr>
<tr><td><code>Jlon</code></td>
<td>
<p>  range of lons </p>
</td></tr>
<tr><td><code>proj</code></td>
<td>
<p> projection list</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sta=list( lat=rnorm(10, mean=60, sd=0.5),
lon = rnorm(10, mean=60, sd=0.5))

A = targetLL(sta, rdist = 100)
print(A)


sta=list( lat=rnorm(10, mean=-30, sd=0.5),
lon = rnorm(10, mean=-40, sd=0.5))

A = targetLL(sta, rdist = 100)
print(A)





</code></pre>

<hr>
<h2 id='teeth'>Add Teeth to line</h2><span id='topic+teeth'></span>

<h3>Description</h3>

<p>Add teeth marks to a line.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>teeth(x, y, h, rot, col = "black", border = "black")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="teeth_+3A_x">x</code></td>
<td>
<p>x-coordinates</p>
</td></tr>
<tr><td><code id="teeth_+3A_y">y</code></td>
<td>
<p>y coordinates</p>
</td></tr>
<tr><td><code id="teeth_+3A_h">h</code></td>
<td>
<p>height of tooth</p>
</td></tr>
<tr><td><code id="teeth_+3A_rot">rot</code></td>
<td>
<p>rotation of teeth</p>
</td></tr>
<tr><td><code id="teeth_+3A_col">col</code></td>
<td>
<p>color of line</p>
</td></tr>
<tr><td><code id="teeth_+3A_border">border</code></td>
<td>
<p>color of border, default= col</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The rotation is usually determined by
consecutive  x-y points
</p>


<h3>Value</h3>

<p>Graphical Side effect
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu</p>


<h3>See Also</h3>

<p>thrust</p>


<h3>Examples</h3>

<pre><code class='language-R'> plot(c(-5,5), c(-5,5), asp=1, type='n' )
  
ff=list()
ff$x=c(-4.850,-4.700,-3.934,-2.528, 0.603, 2.647, 3.861, 2.626)
ff$y=c(-4.045,-2.087,-0.710, 0.172, 1.291, 2.087,-0.753,-4.131)

lines(ff)
points(ff)

### thrust uses teeth
thrust(ff$x, ff$y, h=2, N=12, REV=FALSE)



</code></pre>

<hr>
<h2 id='thrust'>Thrust Fault</h2><span id='topic+thrust'></span>

<h3>Description</h3>

<p>Add Thrust fault with teeth on overlying block
</p>


<h3>Usage</h3>

<pre><code class='language-R'>thrust(x, y, h = 1, N=1, REV = FALSE, endtol=0.1, col = "black", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="thrust_+3A_x">x</code></td>
<td>
<p>x-coordinates</p>
</td></tr>
<tr><td><code id="thrust_+3A_y">y</code></td>
<td>
<p>y-coordinates</p>
</td></tr>
<tr><td><code id="thrust_+3A_h">h</code></td>
<td>
<p>height of teeth</p>
</td></tr>
<tr><td><code id="thrust_+3A_n">N</code></td>
<td>
<p>NUmber of points along line</p>
</td></tr>
<tr><td><code id="thrust_+3A_endtol">endtol</code></td>
<td>
<p> percent tolerance on ends of line</p>
</td></tr>
<tr><td><code id="thrust_+3A_rev">REV</code></td>
<td>
<p>reverse direction of x-y (teeth on other side) </p>
</td></tr>
<tr><td><code id="thrust_+3A_col">col</code></td>
<td>
<p>color of teeth and line</p>
</td></tr>
<tr><td><code id="thrust_+3A_...">...</code></td>
<td>
<p>graphical parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Graphical Side effect
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu</p>


<h3>See Also</h3>

<p>teeth</p>


<h3>Examples</h3>

<pre><code class='language-R'> plot(c(-5,5), c(-5,5), asp=1, type='n' )
  
ff=list()
ff$x=c(-4.850,-4.700,-3.934,-2.528, 0.603, 2.647, 3.861, 2.626)
ff$y=c(-4.045,-2.087,-0.710, 0.172, 1.291, 2.087,-0.753,-4.131)


###

 plot(c(-5,5), c(-5,5), asp=1, type='n' )
  
thrust(ff$x, ff$y,  h=2, N=14, REV=FALSE)


##########  reverse side:
plot(c(-5,5), c(-5,5), asp=1, type='n' )
  
thrust(ff$x, ff$y, h=2, N=14, REV=TRUE)





</code></pre>

<hr>
<h2 id='TOPOCOL'>Create Topography ColorMAP</h2><span id='topic+TOPOCOL'></span>

<h3>Description</h3>

<p>Given an x-y-Z create a matrix of colors for plotting in persp
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TOPOCOL(IZ, calcol)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TOPOCOL_+3A_iz">IZ</code></td>
<td>
<p>Matrix of values</p>
</td></tr>
<tr><td><code id="TOPOCOL_+3A_calcol">calcol</code></td>
<td>
<p>Color mapping of elevations to rgb colors</p>
</td></tr>
</table>


<h3>Details</h3>

<p>colors are interpolated between boundaries in the color map
</p>


<h3>Value</h3>

<p>Matrix of colors suitable for insertion to persp
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>See Also</h3>

<p>persp</p>


<h3>Examples</h3>

<pre><code class='language-R'>
colk1 = 50
colk2 = 210
colk3 = 220
colk4 = 250
BWpal2 = list(z1=c(-3000, 0, 2000, 3500),
r1=c(0,colk1, colk3, colk4),
g1=c(0,colk1, colk3, colk4),
b1=c(0,colk1, colk3, colk4),
z2=c(0, 2000, 3500, 5000),
r2=c(0,colk2,colk4,255),
g2=c(0,colk2,colk4,255),
b2=c(0,colk2,colk4,255),
note=c("black, black", "grey, grey", "white, white", "white, white")
)


data(volcano)

MYCOLL = TOPOCOL(volcano, BWpal2)

   z &lt;- 2 * volcano        # Exaggerate the relief
     x &lt;- 10 * (1:nrow(z))   # 10 meter spacing (S to N)
     y &lt;- 10 * (1:ncol(z))   # 10 meter spacing (E to W)
     ## Don't draw the grid lines :  border = NA
     par(bg = "slategray")
Dcol = attr(  MYCOLL , "Dcol")

     persp(x, y, z, theta = 135, phi = 30,
         col = MYCOLL[1:(Dcol[1]-1), 1:(Dcol[2]-1)], scale = FALSE,
           ltheta = -120, shade = 0.75, border = NA, box = FALSE)


calcol=settopocol()
MYCOLL = TOPOCOL(volcano, calcol$calcol)

Dcol = attr(  MYCOLL , "Dcol")

  K &lt;- 8 *volcano

MYCOLL = TOPOCOL(K, calcol$calcol)

     persp(x, y, z, theta = 135, phi = 30,
           col = MYCOLL[1:(Dcol[1]-1), 1:(Dcol[2]-1)], scale = FALSE,
           ltheta = -120, shade = 0.75, border = NA,  box = FALSE)




</code></pre>

<hr>
<h2 id='trans4'>Translation matrix
</h2><span id='topic+trans4'></span>

<h3>Description</h3>

<p>Translation matrix for rotations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>trans4(vec)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="trans4_+3A_vec">vec</code></td>
<td>
<p> 3 vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p> 4 by 4 matrix
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>References</h3>

<p>Rogers and Adams
</p>


<h3>See Also</h3>

<p>rotx4, roty4, rotdelta4
</p>


<h3>Examples</h3>

<pre><code class='language-R'>trans4(c(0,0,0))

</code></pre>

<hr>
<h2 id='UTM.ll'>Map projection</h2><span id='topic+UTM.ll'></span><span id='topic+utm.wgs84.ll'></span>

<h3>Description</h3>

<p>UTM  Map projection parameters supplied and X-Y, return the LAT-LON
values, WGS-84
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UTM.ll(x , y , PROJ.DATA)
utm.wgs84.ll(x , y , PROJ.DATA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UTM.ll_+3A_x">x</code></td>
<td>
<p>x</p>
</td></tr>
<tr><td><code id="UTM.ll_+3A_y">y</code></td>
<td>
<p>y</p>
</td></tr>
<tr><td><code id="UTM.ll_+3A_proj.data">PROJ.DATA</code></td>
<td>
<p>list of projection parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List
</p>
<table>
<tr><td><code>phi</code></td>
<td>
<p>Latitude-coordinate</p>
</td></tr>
<tr><td><code>lam</code></td>
<td>
<p>Longitude-coordinate</p>
</td></tr>
</table>


<h3>Note</h3>

<p>When calling the conversion from LL to XY or vice versa,
convert the lon to 0 to 360.  Use RPMG::fmod for this conversion.
This may be rectified in future revisions.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>References</h3>

<p>Snyder</p>


<h3>See Also</h3>

<p>setPROJ, GLOB.XY,  projtype,  utm.sphr.ll, UTMzone, plotUTM, utmbox, DATUMinfo</p>


<h3>Examples</h3>

<pre><code class='language-R'>lat = 40.5
lon = -73.50
LON = RPMG::fmod(lon, 360)

uzone = UTMzone(lat, lon)
lon0 = uzone$CEN[2]
####  clark1866
wproj8 = setPROJ(type = 8, LAT0 = 0 , LON0 = lon0,  IDATUM=8)
uu = UTM.xy(lat, LON  , wproj8)
 UTM.ll(uu$x, uu$y ,wproj8)

###  wgs84
wproj1 = setPROJ(type = 8, LAT0 = 0 , LON0 = lon0  , IDATUM=1)
uu = UTM.xy(lat,LON  , wproj1)

 UTM.ll(uu$x, uu$y ,wproj1)




</code></pre>

<hr>
<h2 id='utm.sphr.ll'>Map projection</h2><span id='topic+utm.sphr.ll'></span><span id='topic+equid.cyl.ll'></span><span id='topic+lambert.cc.ll'></span><span id='topic+lambert.ea.ll'></span><span id='topic+merc.sphr.ll'></span><span id='topic+stereo.sphr.ll'></span><span id='topic+utm.elps.ll'></span>

<h3>Description</h3>

<p>Using Map projection parameters supplied and X-Y, return the LAT-LON values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utm.sphr.ll(x , y , PROJ.DATA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utm.sphr.ll_+3A_x">x</code></td>
<td>
<p>x</p>
</td></tr>
<tr><td><code id="utm.sphr.ll_+3A_y">y</code></td>
<td>
<p>y</p>
</td></tr>
<tr><td><code id="utm.sphr.ll_+3A_proj.data">PROJ.DATA</code></td>
<td>
<p>list of projection parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List
</p>
<table>
<tr><td><code>phi</code></td>
<td>
<p>Latitude-coordinate</p>
</td></tr>
<tr><td><code>lam</code></td>
<td>
<p>Longitude-coordinate</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>References</h3>

<p>Snyder</p>


<h3>See Also</h3>

<p>GLOB.XY, setPROJ</p>

<hr>
<h2 id='utm.sphr.xy'>Map projection</h2><span id='topic+utm.sphr.xy'></span><span id='topic+equid.cyl.xy'></span><span id='topic+lambert.cc.xy'></span><span id='topic+lambert.ea.xy'></span><span id='topic+merc.sphr.xy'></span><span id='topic+stereo.sphr.xy'></span><span id='topic+utm.elps.xy'></span>

<h3>Description</h3>

<p>Using Map projection parameters supplied and LAT-LON, return the x-y values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utm.sphr.xy(phi, lam, PROJ.DATA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utm.sphr.xy_+3A_phi">phi</code></td>
<td>
<p>Latitude</p>
</td></tr>
<tr><td><code id="utm.sphr.xy_+3A_lam">lam</code></td>
<td>
<p>Longitude</p>
</td></tr>
<tr><td><code id="utm.sphr.xy_+3A_proj.data">PROJ.DATA</code></td>
<td>
<p>list of projection parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>x-coordinate</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>y-coordinate</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>References</h3>

<p>Snyder</p>


<h3>See Also</h3>

<p>GLOB.XY, setPROJ</p>

<hr>
<h2 id='UTM.xy'>Map projection</h2><span id='topic+UTM.xy'></span><span id='topic+utm.wgs84.xy'></span>

<h3>Description</h3>

<p>UTM  Map projection parameters supplied and LAT-LON, return the x-y
values,  WGS-84 datum
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UTM.xy(phideg,  lamdeg, PROJ.DATA)
utm.wgs84.xy(phideg,  lamdeg, PROJ.DATA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UTM.xy_+3A_phideg">phideg</code></td>
<td>
<p>Latitude</p>
</td></tr>
<tr><td><code id="UTM.xy_+3A_lamdeg">lamdeg</code></td>
<td>
<p>Longitude</p>
</td></tr>
<tr><td><code id="UTM.xy_+3A_proj.data">PROJ.DATA</code></td>
<td>
<p>list of projection parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>x-coordinate</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>y-coordinate</p>
</td></tr>
</table>


<h3>Note</h3>

<p>When calling the conversion from LL to XY or vice versa,
convert the lon to 0 to 360.  Use RPMG::fmod for this conversion.
This may be rectified in future revisions.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>References</h3>

<p>Snyder, J. P., 1987; Map Projections - A Working Manual. U.S. Geological Survey Professional Paper 1395, 383 p.</p>


<h3>See Also</h3>

<p>setPROJ, GLOB.XY,  projtype,  utm.sphr.xy, UTMzone, plotUTM,
utmbox, DATUMinfo</p>


<h3>Examples</h3>

<pre><code class='language-R'>lat = 40.5
lon = -73.50
lon0 = -75
LON = RPMG::fmod(lon, 360)

wproj = setPROJ(type = 5, LAT0 = 0 , LON0 = lon0 , FE = 0 )

u1 = utm.elps.xy(lat, LON ,wproj ) 
utm.wgs84.xy(lat, LON ,wproj)

####  also for more general UTM:
###  this is the wgs84 projection
wproj1 = setPROJ(type = 8, LAT0 = 0 , LON0 = lon0 , FE = 0 , IDATUM=1 )
UTM.xy(lat, LON,wproj1)

###  this is the Clark-1866 (see page 270 in Snyder)
wproj8 = setPROJ(type = 8, LAT0 = 0 , LON0 = lon0 , FE = 0 , IDATUM=8)
UTM.xy(lat, LON,wproj8)

##  which is the same as:

uzone = UTMzone(lat, lon)

lon0 = uzone$CEN[2]
wproj = setPROJ(type = 5, LAT0 = 0 , LON0 = lon0 , FE = 500000 )
utm.elps.xy(lat, LON,wproj )


## to see all the Datums, use: DATUMinfo()


</code></pre>

<hr>
<h2 id='utmbox'>Get UTM Box info  </h2><span id='topic+utmbox'></span>

<h3>Description</h3>

<p>Get UTM Box info 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utmbox(lat, lon)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="utmbox_+3A_lat">lat</code></td>
<td>
<p>latitude</p>
</td></tr>
<tr><td><code id="utmbox_+3A_lon">lon</code></td>
<td>
<p>longitude</p>
</td></tr>
</table>


<h3>Value</h3>

<p>List:
</p>
<table>
<tr><td><code>lon</code></td>
<td>
<p>input  point  longitude</p>
</td></tr>
<tr><td><code>lat</code></td>
<td>
<p>input point latitude</p>
</td></tr>
<tr><td><code>LON</code></td>
<td>
<p>LL corner longitude</p>
</td></tr>
<tr><td><code>LAT</code></td>
<td>
<p>LL corner latitude</p>
</td></tr>
<tr><td><code>utmbox</code></td>
<td>
<p>List: x=utm number, y=utm letter </p>
</td></tr>
<tr><td><code>UTM0</code></td>
<td>
<p>List: center of box: lam=long, phi=lat</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>plotUTM</p>


<h3>Examples</h3>

<pre><code class='language-R'>

lat = 35.76658
lon = 279.4335
utmbox(lat, lon)  

</code></pre>

<hr>
<h2 id='UTMzone'>UTM zone information
</h2><span id='topic+UTMzone'></span>

<h3>Description</h3>

<p>Return the UTM zone information
</p>


<h3>Usage</h3>

<pre><code class='language-R'>UTMzone(lat, lon = NA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="UTMzone_+3A_lat">lat</code></td>
<td>
<p>latitude
</p>
</td></tr>
<tr><td><code id="UTMzone_+3A_lon">lon</code></td>
<td>
<p>longitude
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function works two ways:
If the lat-lon are numeric and lon is not NA
then the UTM zone information is returned.
If lon is NA and lat is one of the
UTM zones, then the lat-lon information for that
zone is returned.
</p>


<h3>Value</h3>

<p>list:
</p>
<table>
<tr><td><code>zone</code></td>
<td>
<p>Character, zone designation</p>
</td></tr>
<tr><td><code>LON</code></td>
<td>
<p>longitude range of the zone</p>
</td></tr>
<tr><td><code>LAT</code></td>
<td>
<p>latitude  range of the zone</p>
</td></tr>
<tr><td><code>CEN</code></td>
<td>
<p>center of the zone, used for projections</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>setPROJ, UTM.xy, UTM.ll, DATUMinfo
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lat = 40.5
  lon = -73.50
UTMzone(lat, lon)
##  or
UTMzone("18T")
</code></pre>

<hr>
<h2 id='X.prod'>Cross Product
</h2><span id='topic+X.prod'></span>

<h3>Description</h3>

<p>Vector Cross Product for spatial cartesian vectors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>X.prod(a, b)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="X.prod_+3A_a">a</code></td>
<td>
<p>3-vector
</p>
</td></tr>
<tr><td><code id="X.prod_+3A_b">b</code></td>
<td>
<p>3-vector
</p>
</td></tr>
</table>


<h3>Value</h3>

<p> 3-vector
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
v1 = c(1,1,1)
v2= c(-1, -1, 1)
X.prod(v1, v2)


</code></pre>

<hr>
<h2 id='XSECDEMg'>Cross Sections Using RPMG </h2><span id='topic+XSECDEMg'></span>

<h3>Description</h3>

<p>This function Takes a Digital Elevation Map (or any surface)
and illustrates how to take interactive cross sections
with RPMG through the surface.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>XSECDEMg(Data,  labs=NULL, pts=NULL, nlevels=10,  demo=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="XSECDEMg_+3A_data">Data</code></td>
<td>
<p>Structure with x, y, z components, typical of
contoured surfaces or digital images</p>
</td></tr>
<tr><td><code id="XSECDEMg_+3A_labs">labs</code></td>
<td>
<p>Vector of labels for Buttons used in the RPMG </p>
</td></tr>
<tr><td><code id="XSECDEMg_+3A_pts">pts</code></td>
<td>
<p>Points to plot on map view </p>
</td></tr>
<tr><td><code id="XSECDEMg_+3A_nlevels">nlevels</code></td>
<td>
<p>Number of levels for contours </p>
</td></tr>
<tr><td><code id="XSECDEMg_+3A_demo">demo</code></td>
<td>
<p>Argument used to turn off interactive part.  Default is
FALSE, but for package construction is set to TRUE so no interaction
is required.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>XSECDEMg is an example stub illustrating the use of RPMG.
The idea is to set up a while() loop that uses input from the
locator() function to execute or analyze data depending on user
defined buttons.  Actions are executed when the button clicked
matches the list of names provided by the user.
</p>


<h3>Value</h3>

<p>No return values
</p>


<h3>Note</h3>

<p>This code is designed as an example of how to set up a Really Poor
Man's GUI.  The demo argument is supplied so that this code will run
without user input, as when creating a checks for package
construction.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees &lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>whichbutt, rowBUTTONS</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(volcano)
attr(volcano, 'dx') =10
attr(volcano, 'dy') =10
mybutts = c("DONE", "REFRESH", "rainbow", "topo", "terrain", "CONT",
"XSEC","PS" )
###  in the following change demo=FALSE to get interactive behavior
XSECDEMg(volcano, mybutts, demo=TRUE)



</code></pre>

<hr>
<h2 id='XSECEQ'>Iinteractive earthquake cross section</h2><span id='topic+XSECEQ'></span>

<h3>Description</h3>

<p>Iinteractive earthquake cross section
</p>


<h3>Usage</h3>

<pre><code class='language-R'>XSECEQ(MAP, EQ, XSECS = NULL, labs = c("DONE", "REFRESH", "XSEC",
"MSEC"),
 width = 10, kmaxes = TRUE, pch = ".", demo = FALSE, png=FALSE )
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="XSECEQ_+3A_map">MAP</code></td>
<td>
<p>Geologic Map Structure</p>
</td></tr>
<tr><td><code id="XSECEQ_+3A_eq">EQ</code></td>
<td>
<p>list of earthquakes</p>
</td></tr>
<tr><td><code id="XSECEQ_+3A_xsecs">XSECS</code></td>
<td>
<p>list of cross sections</p>
</td></tr>
<tr><td><code id="XSECEQ_+3A_labs">labs</code></td>
<td>
<p>labels for cross sections</p>
</td></tr>
<tr><td><code id="XSECEQ_+3A_width">width</code></td>
<td>
<p>width of swaths</p>
</td></tr>
<tr><td><code id="XSECEQ_+3A_kmaxes">kmaxes</code></td>
<td>
<p>logical, TRUE=keep all cross sections same depth</p>
</td></tr>
<tr><td><code id="XSECEQ_+3A_pch">pch</code></td>
<td>
<p>plotting character</p>
</td></tr>
<tr><td><code id="XSECEQ_+3A_demo">demo</code></td>
<td>
<p>Logical, TRUE=not-interactive</p>
</td></tr>
<tr><td><code id="XSECEQ_+3A_png">png</code></td>
<td>
<p>Logical, TRUE=create png files of the cross sections</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Graphical side effects and creates cross-sectional swaths returned as
a list, see eqswath for list structure.
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>XSECDEM, eqswath, XSECwin</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 

##########  get map of Japan
 data('japmap', package='geomapdata' )
proj = setPROJ(type = 2, LAT0=35.358,LON0=138.731)

NIHON = list(lat=range(c(japmap$STROKE$LAT1, japmap$STROKE$LAT2)) , 
             lon = range(c(japmap$STROKE$LON1, japmap$STROKE$LON2)))


xyjap = GLOB.XY(NIHON$lat, NIHON$lon, proj)

NIHON = c(NIHON, xyjap)
MAP = list()
MAP[[1]] = NIHON
attr(MAP, "XYLIM") &lt;- NIHON
attr(MAP, "PROJ") &lt;- proj

MAP[[2]] = japmap

###########  load Engdahl earthquake Data base
########  
data(EHB.LLZ)

flagEHB = EHB.LLZ$lat&gt;=NIHON$lat[1] &amp;  EHB.LLZ$lat&lt;=NIHON$lat[2] &amp;
RPMG::fmod(EHB.LLZ$lon, 360)&gt;+NIHON$lon[1] &amp;  RPMG::fmod(EHB.LLZ$lon,
360)&lt;=NIHON$lon[2]

eqJ =   GLOB.XY(EHB.LLZ$lat[flagEHB], EHB.LLZ$lon[flagEHB], proj)

EQ =list()
EQ[[1]]=list(lat=EHB.LLZ$lat[flagEHB], lon=EHB.LLZ$lon[flagEHB] ,
x=eqJ$x, y=eqJ$y, z=EHB.LLZ$z[flagEHB], col="brown", pch=".", cex=1.5)

rz = NULL
for(i in 1:length(EQ))
{
rz = range(c(rz, EQ[[1]]$z), na.rm=TRUE )

}

for(i in 1:length(EQ))
{
iz = RPMG::RESCALE(EQ[[i]]$z, 1, 100, rz[1], rz[2])
EQ[[i]]$COL = rainbow(100)[iz]
}

labs=c("DONE","REFRESH", "XSEC", "MSEC",  "KMAXES", "CONT", "width", "PS" )
    
NSWath = XSECEQ(  MAP, EQ , labs=labs, width=30, demo=FALSE  )


data(NSWath)
NSWath2 = XSECEQ(  MAP, EQ ,XSECS=NSWath, labs, width=30, demo=TRUE  )   


## End(Not run)


</code></pre>

<hr>
<h2 id='XSECwin'>Cross sectional plot with earthquakes projected</h2><span id='topic+XSECwin'></span>

<h3>Description</h3>

<p>Cross section of earthquakes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>XSECwin(SW, iseclab = 1, xLAB = "A",
labs = c("DONE", "REFRESH", "PS"), width = 10, demo = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="XSECwin_+3A_sw">SW</code></td>
<td>
<p>list of swath data</p>
</td></tr>
<tr><td><code id="XSECwin_+3A_iseclab">iseclab</code></td>
<td>
<p>section number</p>
</td></tr>
<tr><td><code id="XSECwin_+3A_xlab">xLAB</code></td>
<td>
<p>Label</p>
</td></tr>
<tr><td><code id="XSECwin_+3A_labs">labs</code></td>
<td>
<p>labels</p>
</td></tr>
<tr><td><code id="XSECwin_+3A_width">width</code></td>
<td>
<p>width of swath</p>
</td></tr>
<tr><td><code id="XSECwin_+3A_demo">demo</code></td>
<td>
<p>logical, TRUE=not interactive</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Called by XSECEQ; but this can be run independantly if
plots are needed after interactive processing.
</p>


<h3>Value</h3>

<p>Graphical Side effects
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>See Also</h3>

<p>eqswath, XSECEQ</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run:  
library(geomapdata)

 data('japmap', package='geomapdata' )
proj = setPROJ(type = 2, LAT0=35.358,LON0=138.731)

NIHON = list(lat=range(c(japmap$STROKE$LAT1, japmap$STROKE$LAT2)) , 
             lon = range(c(japmap$STROKE$LON1, japmap$STROKE$LON2)))


xyjap = GLOB.XY(NIHON$lat, NIHON$lon, proj)

NIHON = c(NIHON, xyjap)
MAP = list()
MAP[[1]] = NIHON
attr(MAP, "XYLIM") &lt;- NIHON
attr(MAP, "PROJ") &lt;- proj

MAP[[2]] = japmap

###########  load Engdahl earthquake Data base
########  
data('EHB.LLZ' )

flagEHB = EHB.LLZ$lat&gt;=NIHON$lat[1] &amp;  EHB.LLZ$lat&lt;=NIHON$lat[2] &amp;
RPMG::fmod(EHB.LLZ$lon, 360)&gt;+NIHON$lon[1] &amp;  RPMG::fmod(EHB.LLZ$lon,
360)&lt;=NIHON$lon[2]

eqJ =   GLOB.XY(EHB.LLZ$lat[flagEHB], EHB.LLZ$lon[flagEHB], proj)

EQ =list()
EQ[[1]]=list(lat=EHB.LLZ$lat[flagEHB], lon=EHB.LLZ$lon[flagEHB] ,
x=eqJ$x, y=eqJ$y, z=EHB.LLZ$z[flagEHB], col="brown", pch=".", cex=1.5)

rz = NULL
for(i in 1:length(EQ))
{
rz = range(c(rz, EQ[[1]]$z), na.rm=TRUE )

}

for(i in 1:length(EQ))
{
iz = RPMG::RESCALE(EQ[[i]]$z, 1, 100, rz[1], rz[2])
EQ[[i]]$COL = rainbow(100)[iz]
}

labs=c("DONE","REFRESH", "XSEC", "MSEC",  "KMAXES", "CONT", "width",
"PS" )
##  load example cross sections:
 data(NSWath)
NSWath2 = XSECEQ(  MAP, EQ ,XSECS=NSWath, labs, width=30, demo=TRUE  )

#######  show cross sections:
   for(i in 1:length(NSWath))
{

## dev.new()
LAB = attr(NSWath[[i]], "LAB")

XSECwin( NSWath[[i]] , iseclab=i, xLAB=LAB , labs=NULL, demo=TRUE  )   
}


## End(Not run)
</code></pre>

<hr>
<h2 id='XY.GLOB'>Convert from XY to GLOBAL LAT-LON</h2><span id='topic+XY.GLOB'></span>

<h3>Description</h3>

<p>Convert from XY to GLOBAL LAT-LON
</p>


<h3>Usage</h3>

<pre><code class='language-R'>XY.GLOB(x, y, PROJ.DATA)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="XY.GLOB_+3A_x">x</code></td>
<td>
<p>X in whatever units</p>
</td></tr>
<tr><td><code id="XY.GLOB_+3A_y">y</code></td>
<td>
<p>Y in whatever units</p>
</td></tr>
<tr><td><code id="XY.GLOB_+3A_proj.data">PROJ.DATA</code></td>
<td>
<p>Projection list</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Units are whatever is returned from the projection definition.
This is the inverse of  GLOB.XY.
</p>


<h3>Value</h3>

<p>If it is a LIST, use
</p>
<table>
<tr><td><code>lat</code></td>
<td>
<p>Latitude</p>
</td></tr>
<tr><td><code>lon</code></td>
<td>
<p>Longitude</p>
</td></tr>
</table>
<p>...
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees.edu&gt;</p>


<h3>References</h3>

<p>Snyder, John P., Map Projections- a working manual, USGS, Professional Paper, 1987.
</p>


<h3>See Also</h3>

<p>setPROJ</p>


<h3>Examples</h3>

<pre><code class='language-R'>
proj = setPROJ(type = 2, LAT0 =23, LON0 = 35)

XY.GLOB(200, 300, proj)

</code></pre>

<hr>
<h2 id='xyz2ll'>Cartesian to Lat-Lon
</h2><span id='topic+xyz2ll'></span>

<h3>Description</h3>

<p>Cartesian to Lat-Lon
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xyz2ll(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xyz2ll_+3A_x">x</code></td>
<td>
<p>3-vector</p>
</td></tr>
</table>


<h3>Details</h3>

<p> Returns Latitude not Co-latitude
</p>


<h3>Value</h3>

<p> 2-vector of lat-lon
</p>


<h3>Note</h3>

<p> Does only one point at a time
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;
</p>


<h3>See Also</h3>

<p>Lxyz2ll</p>


<h3>Examples</h3>

<pre><code class='language-R'>xyz2ll(c(1,1,1) )


</code></pre>

<hr>
<h2 id='zebra'>Horizontal Zebra Scale</h2><span id='topic+zebra'></span>

<h3>Description</h3>

<p>Plot a zebra style horizontal scale on a projected map.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>zebra(x, y, Dx, dx, dy, lab = "", pos=1, col = c("black", "white"),
cex = 1, textcol="black", xpd=TRUE, PMAT = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="zebra_+3A_x">x</code></td>
<td>
<p>x-coordinate of left corner</p>
</td></tr>
<tr><td><code id="zebra_+3A_y">y</code></td>
<td>
<p>y-coordinate of left corner</p>
</td></tr>
<tr><td><code id="zebra_+3A_dx">Dx</code></td>
<td>
<p>distance in x, km</p>
</td></tr>
<tr><td><code id="zebra_+3A_dx">dx</code></td>
<td>
<p>distance for zebra stripes in x </p>
</td></tr>
<tr><td><code id="zebra_+3A_dy">dy</code></td>
<td>
<p>thickness in km</p>
</td></tr>
<tr><td><code id="zebra_+3A_lab">lab</code></td>
<td>
<p>labels</p>
</td></tr>
<tr><td><code id="zebra_+3A_pos">pos</code></td>
<td>
<p>position of text, 1=below, 3=above, as in par</p>
</td></tr>
<tr><td><code id="zebra_+3A_col">col</code></td>
<td>
<p>2-vector of colors, for the alternating bars</p>
</td></tr>
<tr><td><code id="zebra_+3A_cex">cex</code></td>
<td>
<p>character expansion</p>
</td></tr>
<tr><td><code id="zebra_+3A_textcol">textcol</code></td>
<td>
<p>color for the text</p>
</td></tr>
<tr><td><code id="zebra_+3A_xpd">xpd</code></td>
<td>
<p>logical, graphic parameter for clipping (see par) </p>
</td></tr>
<tr><td><code id="zebra_+3A_pmat">PMAT</code></td>
<td>
<p>3D projection matrix from persp</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plots a zebra style kilometer scale on the current plot
</p>


<h3>Value</h3>

<p>Graphical Side effect
</p>


<h3>Author(s)</h3>

<p>Jonathan M. Lees&lt;jonathan.lees@unc.edu&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(geomapdata)

data(USAmap)
USALL=list()
USALL$lat=c(24.72853,49.62741)
USALL$lon=c(229.29389,296.41803)
## set UTM projection
PROJ = setPROJ(type = 2, LAT0 =mean(USALL$lat), LON0 = mean(USALL$lon) )

####  plot with UTM  projection:
plotGEOmapXY(USAmap, LIM= c(USALL$lon[1], USALL$lat[1],
     USALL$lon[2], USALL$lat[2]    )  , PROJ=PROJ, add=FALSE, shiftlon=0)

zeb=list()
zeb$x=c(197.727896066)
zeb$y=c(-1155.81158234)

zebra(zeb$x[1],zeb$y[1], 1000, 100, 60, lab="Km", cex=.6)




</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
