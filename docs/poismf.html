<!DOCTYPE html><html><head><title>Help for package poismf</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {poismf}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#factors'><p>Determine latent factors for new rows/users</p></a></li>
<li><a href='#factors.single'><p>Get latent factors for a new user given her item counts</p></a></li>
<li><a href='#get.factor.matrices'><p>Extract Latent Factor Matrices</p></a></li>
<li><a href='#get.model.mappings'><p>Extract user/row and item/column mappings from Poisson model.</p></a></li>
<li><a href='#poismf'><p>Factorization of Sparse Counts Matrices through Poisson Likelihood</p></a></li>
<li><a href='#poismf_unsafe'><p>Poisson factorization with no input casting</p></a></li>
<li><a href='#predict.poismf'><p>Predict expected count for new row(user) and column(item) combinations</p></a></li>
<li><a href='#print.poismf'><p>Get information about poismf object</p></a></li>
<li><a href='#summary.poismf'><p>Get information about poismf object</p></a></li>
<li><a href='#topN'><p>Rank top-N highest-predicted items for an existing user</p></a></li>
<li><a href='#topN.new'><p>Rank top-N highest-predicted items for a new user</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Factorization of Sparse Counts Matrices Through Poisson
Likelihood</td>
</tr>
<tr>
<td>Version:</td>
<td>0.4.0-4</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Cortes &lt;david.cortes.rivera@gmail.com&gt;</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/david-cortes/poismf">https://github.com/david-cortes/poismf</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/david-cortes/poismf/issues">https://github.com/david-cortes/poismf/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Creates a non-negative low-rank approximate factorization of a sparse counts matrix by maximizing Poisson
    likelihood with L1/L2 regularization (e.g. for implicit-feedback recommender systems or bag-of-words-based topic modeling)
    (Cortes, (2018) &lt;<a href="https://doi.org/10.48550/arXiv.1811.01908">doi:10.48550/arXiv.1811.01908</a>&gt;), which usually leads to very sparse user and item factors (over 90% zero-valued).
    Similar to hierarchical Poisson factorization (HPF), but follows an optimization-based approach with regularization
    instead of a hierarchical prior, and is fit through gradient-based methods instead of variational inference.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/BSD-2-Clause">BSD_2_clause</a> + file LICENSE</td>
</tr>
<tr>
<td>Imports:</td>
<td>Matrix (&ge; 1.3), methods</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.2</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-03-26 14:41:07 UTC; david</td>
</tr>
<tr>
<td>Author:</td>
<td>David Cortes [aut, cre, cph],
  Jean-Sebastien Roy [cph] (Copyright holder of included tnc library),
  Stephen Nash [cph] (Copyright holder of included tnc library)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-03-26 21:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='factors'>Determine latent factors for new rows/users</h2><span id='topic+factors'></span>

<h3>Description</h3>

<p>Determines the latent factors for new users (rows) given their counts
for existing items (columns).
</p>
<p>This function will use the same method and hyperparameters with which the
model was fit. If using this for recommender systems, it's recommended
to use instead the function <a href="#topic+factors.single">factors.single</a> as it's likely to be more precise.
</p>
<p>Note that, when using &ldquo;method='pg'&ldquo; (not recommended), results from this function
and from 'get.factor.matrices' on the same data might differ a lot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>factors(model, X, add_names = TRUE, nthreads = parallel::detectCores())
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="factors_+3A_model">model</code></td>
<td>
<p>A Poisson factorization model as returned by 'poismf'.</p>
</td></tr>
<tr><td><code id="factors_+3A_x">X</code></td>
<td>
<p>New data for whose rows to determine latent factors. Can be passed as
a 'data.frame' or as a sparse or dense matrix (see documentation of <a href="#topic+poismf">poismf</a>
for details on the data type). While other functions only accept sparse matrices
in COO (triplets) format, this function will also take CSR matrices from the
'SparseM' and  'Matrix' packages (classes 'dgRMatrix'/'RsparseMatrix' for 'Matrix').
Inputs will be converted to CSR regardless of their original format.
</p>
<p>Note that converting a matrix to 'dgRMatrix' format might require using
'as(m, &quot;RsparseMatrix&quot;)' instead of using 'dgRMatrix' directly.
</p>
<p>If passing a 'data.frame', the first column should contain row indices or IDs,
and these will be internally remapped - the mapping will be available as the row
names for the matrix if passing 'add_names=TRUE', or as part of the outputs if
passing 'add_names=FALSE'. The IDs passed in the first column will not be matched
to the existing IDs of 'X' passed to 'poismf'.
</p>
<p>If 'X' passed to 'poismf' was a 'data.frame', 'X' here must also be passed as
'data.frame'. If 'X' passed to 'poismf' was a matrix and 'X' is a 'data.frame',
the second column of 'X' here should contain column numbers
(with numeration starting at 1).</p>
</td></tr>
<tr><td><code id="factors_+3A_add_names">add_names</code></td>
<td>
<p>Whether to add row names to the output matrix if the indices
were internally remapped - they will only be so if the 'X' here
is a 'data.frame'. Note that if the indices in passed in 'X' here (first and second
columns) are integers, once row names are added, subsetting 'X' by an integer
will give the row at that position - that is, if you want to obtain the
corresponding row for ID=2 from 'X' in 'A_out', you need to use 'A_out[&quot;2&quot;, ]',
not 'A_out[2, ]'.</p>
</td></tr>
<tr><td><code id="factors_+3A_nthreads">nthreads</code></td>
<td>
<p>Number of parallel threads to use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The factors are initialized to the mean of each column in the fitted model.
</p>


<h3>Value</h3>


<ul>
<li><p> If 'X' was passed as a matrix, will output a matrix of dimensions (n, k)
with the obtained factors. If passing 'add_names=TRUE' and 'X' passed to
'poismf' was a 'data.frame', this matrix will have row names. <b>Careful
with subsetting with integers</b> (see documentation for 'add_names').
</p>
</li>
<li><p> If 'X' was passed as a 'data.frame' and passing 'add_names=FALSE' here,
will output a list with an entry 'factors' containing the latent factors as
described above, and an entry 'mapping' indicating to which row ID does each
row of the output correspond.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+factors.single">factors.single</a> <a href="#topic+topN.new">topN.new</a>
</p>

<hr>
<h2 id='factors.single'>Get latent factors for a new user given her item counts</h2><span id='topic+factors.single'></span>

<h3>Description</h3>

<p>This is similar to obtaining topics for a document in LDA. See also
function <a href="#topic+factors">factors</a> for getting factors for multiple users/rows at
a time.
</p>
<p>This function works with one user at a time, and will use the
TNCG solver regardless of how the model was fit.
Note that, since this optimization method may have
different optimal hyperparameters than the other methods, it
offers the option of varying those hyperparameters in here.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>factors.single(
  model,
  X,
  l2_reg = model$l2_reg,
  l1_reg = model$l1_reg,
  weight_mult = model$weight_mult,
  maxupd = max(1000L, model$maxupd)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="factors.single_+3A_model">model</code></td>
<td>
<p>Poisson factorization model as returned by 'poismf'.</p>
</td></tr>
<tr><td><code id="factors.single_+3A_x">X</code></td>
<td>
<p>Data with the non-zero item indices and counts for this new user. Can be
passed as a sparse vector from package 'Matrix' ('Matrix::dsparseVector', which can
be created from indices and values through function 'Matrix::sparseVector'), or
as a 'data.frame', in which case will take the first column as the item/column indices
(numeration starting at 1) and the second column as the counts. If 'X' passed to
'poismf' was a 'data.frame', 'X' here must also be a 'data.frame'.</p>
</td></tr>
<tr><td><code id="factors.single_+3A_l2_reg">l2_reg</code></td>
<td>
<p>Strength of L2 regularization to use for optimizing the new factors.</p>
</td></tr>
<tr><td><code id="factors.single_+3A_l1_reg">l1_reg</code></td>
<td>
<p>Strength of the L1 regularization. Not recommended.</p>
</td></tr>
<tr><td><code id="factors.single_+3A_weight_mult">weight_mult</code></td>
<td>
<p>Weight multiplier for the positive entries over the missing entries.</p>
</td></tr>
<tr><td><code id="factors.single_+3A_maxupd">maxupd</code></td>
<td>
<p>Maximum number of TNCG updates to perform. You might want to
increase this value depending on the use-case.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The factors are initialized to the mean of each column in the fitted model.
</p>


<h3>Value</h3>

<p>Vector of dimensionality 'model$k' with the latent factors for the user,
given the input data.
</p>


<h3>See Also</h3>

<p><a href="#topic+factors">factors</a> <a href="#topic+topN.new">topN.new</a>
</p>

<hr>
<h2 id='get.factor.matrices'>Extract Latent Factor Matrices</h2><span id='topic+get.factor.matrices'></span>

<h3>Description</h3>

<p>Extract the latent factor matrices for users (rows) and
columns (items) from a Poisson factorization model object, as returned
by function 'poismf'.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.factor.matrices(model, add_names = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.factor.matrices_+3A_model">model</code></td>
<td>
<p>A Poisson factorization model, as produced by 'poismf'.</p>
</td></tr>
<tr><td><code id="get.factor.matrices_+3A_add_names">add_names</code></td>
<td>
<p>Whether to add row names to the matrices if the indices
were internally remapped - they will only be so if the 'X' passed to 'poismf'
was a 'data.frame'. Note that if passing 'X' as 'data.frame' with integer indices
to 'poismf', once row names are added, subsetting such matrix by an integer will
give the row at that position - that is, if you want to obtain the corresponding
row for ID=2 from 'X' in 'factors$A', you need to use 'factors$A[&quot;2&quot;, ]', not
'factors$A[2, ]'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If 'X' passed to 'poismf' was a 'data.frame', the mapping between
IDs from 'X' to row numbers in 'A' and column numbers in 'B' are avaiable under
'model$levels_A' and 'model$levels_B', respectively. They can also be obtained
through 'get.model.mappings', and will be added as row names if
using 'add_names=TRUE'. <b>Be careful about subsetting with integers</b> (see
documentation for 'add_names' for details).
</p>


<h3>Value</h3>

<p>List with entries 'A' (the user factors) and 'B' (the item factors).
</p>


<h3>See Also</h3>

<p><a href="#topic+get.model.mappings">get.model.mappings</a>
</p>

<hr>
<h2 id='get.model.mappings'>Extract user/row and item/column mappings from Poisson model.</h2><span id='topic+get.model.mappings'></span>

<h3>Description</h3>

<p>Will extract the mapping between IDs passed as 'X' to
function 'poismf' and row/column positions in the latent factor matrices
and prediction functions.
</p>
<p>Such a mapping will only be generated if the 'X' passed to 'poismf' was a
'data.frame', otherwise they will not be re-mapped.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get.model.mappings(model)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.model.mappings_+3A_model">model</code></td>
<td>
<p>A Poisson factorization model as returned by 'poismf'.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with row entries: </p>

<ul>
<li><p> 'rows': a vector in which each user/row ID is placed at its ordinal position
in the internal data structures. If there is no mapping (e.g. if 'X' passed to
'poismf' was a sparse matrix), will be 'NULL'.
</p>
</li>
<li><p> 'columns': a vector in which each item/column ID is placed at its ordinal position
in the internal data structures. If there is no mapping (e.g. if 'X' passed to
'poismf' was a sparse matrix), will be 'NULL'.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+get.factor.matrices">get.factor.matrices</a>
</p>

<hr>
<h2 id='poismf'>Factorization of Sparse Counts Matrices through Poisson Likelihood</h2><span id='topic+poismf'></span>

<h3>Description</h3>

<p>Creates a low-rank non-negative factorization of a sparse counts
matrix by maximizing Poisson likelihood minus L1/L2 regularization, using
gradient-based optimization procedures.
</p>
<p>The model idea is to approximate: <code class="reqn">\mathbf{X} \sim \texttt{Poisson}(\mathbf{A} \mathbf{B}^T)</code>
</p>
<p>Ideal for usage in recommender systems, in which the 'X' matrix would consist of
interactions (e.g. clicks, views, plays), with users representing the rows and items
representing the columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poismf(
  X,
  k = 50,
  method = "tncg",
  l2_reg = "auto",
  l1_reg = 0,
  niter = "auto",
  maxupd = "auto",
  limit_step = TRUE,
  initial_step = 1e-07,
  early_stop = TRUE,
  reuse_prev = FALSE,
  weight_mult = 1,
  handle_interrupt = TRUE,
  nthreads = parallel::detectCores()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poismf_+3A_x">X</code></td>
<td>
<p>The counts matrix to factorize. Can be: </p>

<ul>
<li><p> A 'data.frame' with 3 columns, containing in this order:
row index or user ID, column index or item ID, count value. The first two columns will
be converted to factors to enumerate them internally, and will return those same
values from 'topN'. In order to avoid this internal re-enumeration, can pass 'X'
as a sparse COO matrix instead.
</p>
</li>
<li><p> A sparse matrix from package 'Matrix' in triplets (COO) format
(that is: 'Matrix::dgTMatrix') (recommended).
Such a matrix can be created from row/column indices through
function 'Matrix::sparseMatrix' (with 'repr=&quot;T&quot;').
Will also accept them in CSC and CSR formats ('Matrix::dgCMatrix' and
'Matrix::dgRMatrix'), but will be converted
along the way (so it will be slightly slower).
</p>
</li>
<li><p> A sparse matrix in COO format from the 'SparseM' package.
Will also accept them in CSR and CSC format, but will be converted along the way
(so it will be slightly slower).
</p>
</li>
<li><p> A full matrix (of class 'base::matrix') - this is not recommended though.
</p>
</li></ul>

<p>Passing sparse matrices is faster as it will not need to re-enumerate the rows and columns.
Dense (regular) matrices will be converted to sparse format, which is inefficient.</p>
</td></tr>
<tr><td><code id="poismf_+3A_k">k</code></td>
<td>
<p>Number of latent factors to use (dimensionality of the low-rank factorization).
If &lsquo;k' is very small (e.g. 'k=3'), it&rsquo;s recommended to use &lsquo;method=&rsquo;pg'',
otherwise it's recommended to use &lsquo;method=&rsquo;tncg'&lsquo;, and if using 'method=&rsquo;cg'',
it's recommended to use large 'k' (at least 100).</p>
</td></tr>
<tr><td><code id="poismf_+3A_method">method</code></td>
<td>
<p>Optimization method to use as inner solver. Options are: </p>

<ul>
<li><p> '&quot;tncg&quot;' : will use the conjugate gradient method from reference [2].
This is the slowest option, but tends to find better local optima, and
if either run for many inner iterations (controlled by 'maxupd') or
reusing previous solutions each time (controlled by 'reuse_prev'),
tends to produce sparse latent factor matrices.
Note that when reusing previous solutions, fitting times are much faster
and the quality of the results as evaluated by ranking-based recommendation
quality metrics is almost as good, but solutions tend to be less sparse
(see reference [1] for details).
Unlike the other two, this solver is extremely unlikely to fail to produce
results, and it is thus the recommended one.
</p>
</li>
<li><p> '&quot;cg&quot;' : will use the conjugate gradient method from reference [3],
which is faster than the one from reference [2], but tends not to reach
as good local optima. Usually, with this method and the default hyperparameters,
the latent factor matrices will be very sparse, but note that it can
fail to produce results (in which case the obtained factors will be
very poor quality without warning) when 'k' is small (recommended to
use 'k&gt;=100' when using this solver).
</p>
</li>
<li><p> '&quot;pg&quot;' : will use a proximal gradient method, which is a lot faster
than the other two and more memory-efficient, but tends to only work
with very large regularization values, and doesn't find as good
local optima, nor tends to result in sparse factors. Under this method,
top-N recommendations tend to have little variation from one user to another.
</p>
</li></ul>
</td></tr>
<tr><td><code id="poismf_+3A_l2_reg">l2_reg</code></td>
<td>
<p>Strength of L2 regularization. It is recommended to use small values
along with &lsquo;method=&rsquo;tncg'&lsquo;, very large values along with 'method=&rsquo;pg'',
and medium to large values with &lsquo;method=&rsquo;cg''. If passing '&quot;auto&quot;',
will set it to <code class="reqn">10^3</code> for TNCG, <code class="reqn">10^4</code> for CG, and <code class="reqn">10^9</code> for PG.</p>
</td></tr>
<tr><td><code id="poismf_+3A_l1_reg">l1_reg</code></td>
<td>
<p>Strength of L1 regularization. Not recommended.</p>
</td></tr>
<tr><td><code id="poismf_+3A_niter">niter</code></td>
<td>
<p>Number of outer iterations to perform. One iteration denotes an update
over both matrices. If passing ''auto'', will set it to 10 for TNCG and PG,
or to 30 for CG.
</p>
<p>Using more iterations usually leads to better results for CG, at the
expense of longer fitting times. TNCG is more likely to converge to
a local optimum with fewer outer iterations, with further iterations
not changing the values of any single factor.</p>
</td></tr>
<tr><td><code id="poismf_+3A_maxupd">maxupd</code></td>
<td>
<p>Maximum number of inner iterations for each user/item vector.
Note: for 'method=TNCG', this means maximum number of <b>function
evaluations</b> rather than number of updates, so it should be higher.
You might also want to try decreasing this while increasing 'niter'.
For &lsquo;method=&rsquo;pg'', this will be taken as the actual number of updates,
as it does not perform a line search like the other methods.
If passing &lsquo;&quot;auto&quot;', will set it to '15*k' for 'method=&rsquo;tncg'',
5 for &lsquo;method=&rsquo;cg'&lsquo;, and 10 for 'method=&rsquo;pg''. If using
&lsquo;method=&rsquo;cg'', one might also want to try other combinations such as
'maxupd=1' and 'niter=100'.</p>
</td></tr>
<tr><td><code id="poismf_+3A_limit_step">limit_step</code></td>
<td>
<p>When passing &lsquo;method=&rsquo;cg'', whether to limit the step sizes in each update
so as to drive at most one variable to zero each time, as prescribed in [3].
If running the procedure for many iterations, it's recommended to set this
to &lsquo;TRUE'. You also might set 'method=&rsquo;cg'' plus 'maxupd=1' and
'limit_step=FALSE' to reduce the algorithm to simple projected gradient descent
with a line search.</p>
</td></tr>
<tr><td><code id="poismf_+3A_initial_step">initial_step</code></td>
<td>
<p>Initial step size to use for proximal gradient updates. Larger step sizes
reach converge faster, but are more likely to result in failed optimization.
Ignored when passing &lsquo;method=&rsquo;tncg'&lsquo; or 'method=&rsquo;cg'', as those will
perform a line seach instead.</p>
</td></tr>
<tr><td><code id="poismf_+3A_early_stop">early_stop</code></td>
<td>
<p>In the TNCG method, whether to stop before reaching the maximum number of
iterations if the updates do not change the factors significantly or at all.</p>
</td></tr>
<tr><td><code id="poismf_+3A_reuse_prev">reuse_prev</code></td>
<td>
<p>In the TNCG method, whether to reuse the factors obtained in the previous
iteration as starting point for each inner update. This has the
effect of reaching convergence much quicker, but will oftentimes lead to
slightly worse solutions.
</p>
<p>If passing 'FALSE' and 'maxupd' is small, the obtained factors might not
be sparse at all. If passing 'TRUE', they will typically be less sparse
than when passing &lsquo;FALSE' with large 'maxupd' or than with 'method=&rsquo;cg''.
</p>
<p>Setting it to 'TRUE' has the side effect of potentially making the factors
obtained when fitting the model different from the factors obtained after
calling the 'predict_factors' function with the same data the model was fit.
</p>
<p>For methods other than TNCG, this is always assumed 'TRUE'.</p>
</td></tr>
<tr><td><code id="poismf_+3A_weight_mult">weight_mult</code></td>
<td>
<p>Extra multiplier for the weight of the positive entries over the missing
entries in the matrix to factorize. Be aware that Poisson likelihood will
implicitly put more weight on the non-missing entries already. Passing larger
values will make the factors have larger values (which might be desirable),
and can help with instability and failed optimization cases. If passing this,
it's recommended to try very large values (e.g. 10^2), and might require
adjusting the other hyperparameters.</p>
</td></tr>
<tr><td><code id="poismf_+3A_handle_interrupt">handle_interrupt</code></td>
<td>
<p>When receiving an interrupt signal, whether the model should stop
early and leave a usable object with the parameters obtained up
to the point when it was interrupted (when passing 'TRUE'), or
raise an interrupt exception without producing a fitted model object
(when passing 'FALSE').</p>
</td></tr>
<tr><td><code id="poismf_+3A_nthreads">nthreads</code></td>
<td>
<p>Number of parallel threads to use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In order to speed up the optimization procedures, it's recommended to use
an optimized library for BLAS operations such as MKL or OpenBLAS (ideally the &quot;openmp&quot; variant).
See <a href="https://github.com/david-cortes/R-openblas-in-windows">this link</a>
for instructions on getting OpenBLAS in R for Windows.
</p>
<p>When using proximal gradient method, this model is prone to numerical
instability, and can turn out to spit all NaNs or zeros in the fitted
parameters. The TNCG method is not prone to such failed optimizations.
</p>
<p>Although the main idea behind this software is to produce sparse model/factor
matrices, they are always taken in dense format when used inside this software,
and as such, it might be faster to use these matrices through some other external
library that would be able to exploit their sparsity.
</p>
<p>For reproducible results, random number generation seeds can be controlled through 'set.seed'.
</p>
<p>Model quality or recommendation quality can be evaluated using the
<a href="https://cran.r-project.org/package=recometrics">recometrics</a> package.
</p>


<h3>Value</h3>

<p>An object of class 'poismf' with the following fields of interest:
</p>


<h3>Fields</h3>


<dl>
<dt><code>A</code></dt><dd><p>The user/document/row-factor matrix (will be transposed due to R's
column-major storage of matrices).</p>
</dd>
<dt><code>B</code></dt><dd><p>The item/word/column-factor matrix (will be transposed due to R's
column-major storage of matrices).</p>
</dd>
<dt><code>levels_A</code></dt><dd><p>A vector indicating which user/row ID corresponds to each row
position in the 'A' matrix. This will only be generated when passing 'X' as a
'data.frame', otherwise will not remap them.</p>
</dd>
<dt><code>levels_B</code></dt><dd><p>A vector indicating which item/column ID corresponds to each row
position in the 'B' matrix. This will only be generated when passing 'X' as a
'data.frame', otherwise will not remap them.</p>
</dd>
</dl>


<h3>References</h3>


<ol>
<li><p> Cortes, David.
&quot;Fast Non-Bayesian Poisson Factorization for Implicit-Feedback Recommendations.&quot;
arXiv preprint arXiv:1811.01908 (2018).
</p>
</li>
<li><p> Nash, Stephen G.
&quot;Newton-type minimization via the Lanczos method.&quot;
SIAM Journal on Numerical Analysis 21.4 (1984): 770-788.
</p>
</li>
<li><p> Li, Can.
&quot;A conjugate gradient type method for the nonnegative constraints optimization problems.&quot;
Journal of Applied Mathematics 2013 (2013).
</p>
</li></ol>



<h3>See Also</h3>

<p><a href="#topic+predict.poismf">predict.poismf</a> <a href="#topic+topN">topN</a> <a href="#topic+factors">factors</a>
<a href="#topic+get.factor.matrices">get.factor.matrices</a> <a href="#topic+get.model.mappings">get.model.mappings</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(poismf)

### create a random sparse data frame in COO format
nrow &lt;- 10^2 ## &lt;- users
ncol &lt;- 10^3 ## &lt;- items
nnz  &lt;- 10^4 ## &lt;- events (agg)
set.seed(1)
X &lt;- data.frame(
        row_ix = sample(nrow, size=nnz, replace=TRUE),
        col_ix = sample(ncol, size=nnz, replace=TRUE),
        count  = rpois(nnz, 1) + 1
     )
X &lt;- X[!duplicated(X[, c("row_ix", "col_ix")]), ]

### can also pass X as sparse matrix - see below
### X &lt;- Matrix::sparseMatrix(
###          i=X$row_ix, j=X$col_ix, x=X$count,
###          repr="T")
### the indices can also be characters or other types:
### X$row_ix &lt;- paste0("user", X$row_ix)
### X$col_ix &lt;- paste0("item", X$col_ix)

### factorize the randomly-generated sparse matrix
model &lt;- poismf(X, k=5, method="tncg", nthreads=1)

### (for sparse factors, use higher 'k' and larger data)

### predict functionality (chosen entries in X)
### predict entry [1, 10] (row 1, column 10)
predict(model, 1, 10, nthreads=1)
### predict entries [1,4], [1,5], [1,6]
predict(model, c(1, 1, 1), c(4, 5, 6), nthreads=1)

### ranking functionality (for recommender systems)
topN(model, user=2, n=5, exclude=X$col_ix[X$row_ix==2], nthreads=1)
topN.new(model, X=X[X$row_ix==2, c("col_ix","count")],
    n=5, exclude=X$col_ix[X$row_ix==2], nthreads=1)

### obtaining latent factors
a_vec  &lt;- factors.single(model,
            X[X$row_ix==2, c("col_ix","count")])
A_full &lt;- factors(model, X, nthreads=1)
A_orig &lt;- get.factor.matrices(model)$A

### (note that newly-obtained factors will differ slightly)
sqrt(mean((A_full["2",] - A_orig["2",])^2))
</code></pre>

<hr>
<h2 id='poismf_unsafe'>Poisson factorization with no input casting</h2><span id='topic+poismf_unsafe'></span>

<h3>Description</h3>

<p>This is a faster version of <a href="#topic+poismf">poismf</a> which will not make any checks
or castings on its inputs. It is intended as a fast alternative when a model is to
be fit multiple times with different hyperparameters, and for allowing
custom-initialized factor matrices. <b>Note that since it doesn't make any checks
or conversions, passing the wrong kinds of inputs or passing inputs with mismatching
dimensions will crash the R process</b>.
</p>
<p>For most use cases, it's recommended to use the function 'poismf' instead.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>poismf_unsafe(A, B, Xcsr, Xcsc, k, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="poismf_unsafe_+3A_a">A</code></td>
<td>
<p>Initial values for the user-factor matrix of dimensions [dimA, k],
assuming row-major order. Can be passed as a vector of dimension [dimA*k], or
as a matrix of dimension [k, dimA]. Note that R matrices use column-major order,
so if you want to pass an R matrix as initial values, you'll need to transpose it,
hence the shape [k, dimA]. Recommended to initialize '~ Uniform(0.3, 0.31)'.
<b>Will be modified in-place</b>.</p>
</td></tr>
<tr><td><code id="poismf_unsafe_+3A_b">B</code></td>
<td>
<p>Initial values for the item-factor matrix of dimensions [dimB, k]. See
documentation about 'A' for more details.</p>
</td></tr>
<tr><td><code id="poismf_unsafe_+3A_xcsr">Xcsr</code></td>
<td>
<p>The 'X' matrix in CSR format. Should be an object of class 'Matrix::dgRMatrix'.</p>
</td></tr>
<tr><td><code id="poismf_unsafe_+3A_xcsc">Xcsc</code></td>
<td>
<p>The 'X' matrix in CSC format. Should be an object of class 'Matrix::dgCMatrix'.</p>
</td></tr>
<tr><td><code id="poismf_unsafe_+3A_k">k</code></td>
<td>
<p>The number of latent factors. <b>Must match with the dimension of 'A' and 'B'</b>.</p>
</td></tr>
<tr><td><code id="poismf_unsafe_+3A_...">...</code></td>
<td>
<p>Other hyperparameters that can be passed to 'poismf'. See the documentation
for <a href="#topic+poismf">poismf</a> for details about possible hyperparameters.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 'poismf' model object. See the documentation for <a href="#topic+poismf">poismf</a> for details.
</p>


<h3>See Also</h3>

<p><a href="#topic+poismf">poismf</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(poismf)

### create a random sparse data frame in COO format
nrow &lt;- 10^2 ## &lt;- users
ncol &lt;- 10^3 ## &lt;- items
nnz  &lt;- 10^4 ## &lt;- events (agg)
set.seed(1)
X &lt;- data.frame(
        row_ix = sample(nrow, size=nnz, replace=TRUE),
        col_ix = sample(ncol, size=nnz, replace=TRUE),
        count  = rpois(nnz, 1) + 1
     )
X &lt;- X[!duplicated(X[, c("row_ix", "col_ix")]), ]

### convert to required format
Xcsr &lt;- Matrix::sparseMatrix(
            i=X$row_ix, j=X$col_ix, x=X$count,
            repr="R"
)
Xcsc &lt;- Matrix::sparseMatrix(
            i=X$row_ix, j=X$col_ix, x=X$count,
            repr="C"
)

### initialize factor matrices
k &lt;- 5L
A &lt;- rgamma(nrow*k, 1, 1)
B &lt;- rgamma(ncol*k, 1, 1)

### call function
model &lt;- poismf_unsafe(A, B, Xcsr, Xcsc, k, nthreads=1)
</code></pre>

<hr>
<h2 id='predict.poismf'>Predict expected count for new row(user) and column(item) combinations</h2><span id='topic+predict.poismf'></span>

<h3>Description</h3>

<p>Predict expected count for new row(user) and column(item) combinations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'poismf'
predict(object, a, b = NULL, nthreads = parallel::detectCores(), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="predict.poismf_+3A_object">object</code></td>
<td>
<p>A Poisson factorization model as returned by 'poismf'.</p>
</td></tr>
<tr><td><code id="predict.poismf_+3A_a">a</code></td>
<td>
<p>Can be either: </p>

<ul>
<li><p> A vector of length N with the users/rows to predict - each entry will be
matched to the corresponding entry at the same position in 'b' - e.g. to predict
value for entries (3,4), (3,5), and (3,6), should pass 'a=c(3,3,3), b=c(3,5,6)'.
If 'X' passed to 'poismf' was a 'data.frame', should match with the entries in
its first column. If 'X' passed to 'poismf' was a matrix, should indicate the
row numbers (numeration starting at 1).
</p>
</li>
<li><p> A sparse matrix, ideally in COO (triplets) format from package 'Matrix'
('Matrix::dgTMatrix') or from package 'SparseM' ('matrix.coo'), in which case it
will make predictions for the non-zero entries in the matrix and will output
another sparse matrix with the predicted entries as values. In this case, 'b'
should not be passed. This option is not available if the 'X' passed to 'poismf'
was a 'data.frame'.
</p>
</li></ul>
</td></tr>
<tr><td><code id="predict.poismf_+3A_b">b</code></td>
<td>
<p>A vector of length N with the items/columns to predict - each entry will be
matched to the corresponding entry at the same position in 'a' - e.g. to predict
value for entries (3,4), (3,5), and (3,6), should pass 'a=c(3,3,3), b=c(3,5,6)'.
If 'X' passed to 'poismf' was a 'data.frame', should match with the entries in
its second column. If 'X' passed to 'poismf' was a matrix, should indicate the
column numbers (numeration starting at 1). If 'a' is a sparse matrix, should not
pass 'b'.</p>
</td></tr>
<tr><td><code id="predict.poismf_+3A_nthreads">nthreads</code></td>
<td>
<p>Number of parallel threads to use.</p>
</td></tr>
<tr><td><code id="predict.poismf_+3A_...">...</code></td>
<td>
<p>Not used.</p>
</td></tr>
</table>


<h3>Value</h3>


<ul>
<li><p> If 'a' and 'b' were passed, will return a vector of length N with the
predictions  for the requested row/column combinations.
</p>
</li>
<li><p> If 'b' was not passed, will return a sparse matrix with the same entries
and shape as 'a', but with the values being the predictions from the model for
the non-missing entries. In such case, the output will be of class 'Matrix::dgTMatrix'.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+poismf">poismf</a> <a href="#topic+topN">topN</a> <a href="#topic+factors">factors</a>
</p>

<hr>
<h2 id='print.poismf'>Get information about poismf object</h2><span id='topic+print.poismf'></span>

<h3>Description</h3>

<p>Print basic properties of a &quot;poismf&quot; object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'poismf'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.poismf_+3A_x">x</code></td>
<td>
<p>An object of class &quot;poismf&quot; as returned by function &quot;poismf&quot;.</p>
</td></tr>
<tr><td><code id="print.poismf_+3A_...">...</code></td>
<td>
<p>Extra arguments (not used).</p>
</td></tr>
</table>

<hr>
<h2 id='summary.poismf'>Get information about poismf object</h2><span id='topic+summary.poismf'></span>

<h3>Description</h3>

<p>Print basic properties of a &quot;poismf&quot; object (same as 'print.poismf' function).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'poismf'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.poismf_+3A_object">object</code></td>
<td>
<p>An object of class &quot;poismf&quot; as returned by function &quot;poismf&quot;.</p>
</td></tr>
<tr><td><code id="summary.poismf_+3A_...">...</code></td>
<td>
<p>Extra arguments (not used).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><a href="#topic+print.poismf">print.poismf</a>
</p>

<hr>
<h2 id='topN'>Rank top-N highest-predicted items for an existing user</h2><span id='topic+topN'></span>

<h3>Description</h3>

<p>Rank top-N highest-predicted items for an existing user
</p>


<h3>Usage</h3>

<pre><code class='language-R'>topN(
  model,
  user,
  n = 10,
  include = NULL,
  exclude = NULL,
  output_score = FALSE,
  nthreads = parallel::detectCores()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="topN_+3A_model">model</code></td>
<td>
<p>A Poisson factorization model as returned by 'poismf'.</p>
</td></tr>
<tr><td><code id="topN_+3A_user">user</code></td>
<td>
<p>User for which to rank the items. If 'X' passed to 'poismf' was a
'data.frame', must match with the entries in its first column,
otherwise should match with the rows of 'X' (numeration starting at 1).</p>
</td></tr>
<tr><td><code id="topN_+3A_n">n</code></td>
<td>
<p>Number of top-N highest-predicted results to output.</p>
</td></tr>
<tr><td><code id="topN_+3A_include">include</code></td>
<td>
<p>List of items which will be ranked. If passing this, will only
make a ranking among these items. If 'X' passed to 'poismf' was a
'data.frame', must match with the entries in its second column,
otherwise should match with the columns of 'X' (numeration starting at 1). Can only pass
one of 'include' or 'exclude.' Must not contain duplicated entries.</p>
</td></tr>
<tr><td><code id="topN_+3A_exclude">exclude</code></td>
<td>
<p>List of items to exclude from the ranking. If passing this, will
rank all the items except for these. If 'X' passed to 'poismf' was a
'data.frame', must match with the entries in its second column,
otherwise should match with the columns of 'X' (numeration starting at 1). Can only pass
one of 'include' or 'exclude'. Must not contain duplicated entries.</p>
</td></tr>
<tr><td><code id="topN_+3A_output_score">output_score</code></td>
<td>
<p>Whether to output the scores in addition to the IDs. If passing
'FALSE', will return a single array with the item IDs, otherwise
will return a list with the item IDs and the scores.</p>
</td></tr>
<tr><td><code id="topN_+3A_nthreads">nthreads</code></td>
<td>
<p>Number of parallel threads to use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Even though the fitted model matrices might be sparse, they are always used
in dense format here. In many cases it might be more efficient to produce the
rankings externally through some library that would exploit the sparseness for
much faster computations. The matrices can be access under 'model$A' and 'model$B'.
</p>


<h3>Value</h3>


<ul>
<li><p> If passing 'output_score=FALSE' (the default), will return a vector of size 'n'
with the top-N highest predicted items for this user.If the 'X' data passed to
'poismf' was a 'data.frame', will contain the item IDs from its second column,
otherwise will be integers matching to the columns of 'X' (starting at 1). If
'X' was passed as 'data.frame', the entries in this vector might be coerced to
character regardless of their original type.
</p>
</li>
<li><p> If passing 'output_score=TRUE', will return a list, with the first entry
being the vector described above under name 'ix', and the second entry being the
associated scores, as a numeric vector of size 'n'.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+topN.new">topN.new</a> <a href="#topic+predict.poismf">predict.poismf</a> <a href="#topic+factors.single">factors.single</a>
</p>

<hr>
<h2 id='topN.new'>Rank top-N highest-predicted items for a new user</h2><span id='topic+topN.new'></span>

<h3>Description</h3>

<p>Rank top-N highest-predicted items for a new user
</p>


<h3>Usage</h3>

<pre><code class='language-R'>topN.new(
  model,
  X,
  n = 10,
  include = NULL,
  exclude = NULL,
  output_score = FALSE,
  l2_reg = model$l2_reg,
  l1_reg = model$l1_reg,
  weight_mult = model$weight_mult,
  maxupd = max(1000L, model$maxupd),
  nthreads = parallel::detectCores()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="topN.new_+3A_model">model</code></td>
<td>
<p>A Poisson factorization model as returned by 'poismf'.</p>
</td></tr>
<tr><td><code id="topN.new_+3A_x">X</code></td>
<td>
<p>Data with the non-zero item indices and counts for this new user. Can be
passed as a sparse vector from package 'Matrix' ('Matrix::dsparseVector', which can
be created from indices and values through 'Matrix::sparseVector'), or as a 'data.frame',
in which case will take the first column as the item/column indices
(numeration starting at 1) and the second column
as the counts. If 'X' passed to 'poismf' was a 'data.frame', 'X' here must also be
a 'data.frame'.</p>
</td></tr>
<tr><td><code id="topN.new_+3A_n">n</code></td>
<td>
<p>Number of top-N highest-predicted results to output.</p>
</td></tr>
<tr><td><code id="topN.new_+3A_include">include</code></td>
<td>
<p>List of items which will be ranked. If passing this, will only
make a ranking among these items. If 'X' passed to 'poismf' was a
'data.frame', must match with the entries in its second column,
otherwise should match with the columns of 'X' (numeration starting at 1). Can only pass
one of 'include' or 'exclude.' Must not contain duplicated entries.</p>
</td></tr>
<tr><td><code id="topN.new_+3A_exclude">exclude</code></td>
<td>
<p>List of items to exclude from the ranking. If passing this, will
rank all the items except for these. If 'X' passed to 'poismf' was a
'data.frame', must match with the entries in its second column,
otherwise should match with the columns of 'X' (numeration starting at 1). Can only pass
one of 'include' or 'exclude'. Must not contain duplicated entries.</p>
</td></tr>
<tr><td><code id="topN.new_+3A_output_score">output_score</code></td>
<td>
<p>Whether to output the scores in addition to the IDs. If passing
'FALSE', will return a single array with the item IDs, otherwise
will return a list with the item IDs and the scores.</p>
</td></tr>
<tr><td><code id="topN.new_+3A_l2_reg">l2_reg</code></td>
<td>
<p>Strength of L2 regularization to use for optimizing the new factors.</p>
</td></tr>
<tr><td><code id="topN.new_+3A_l1_reg">l1_reg</code></td>
<td>
<p>Strength of the L1 regularization. Not recommended.</p>
</td></tr>
<tr><td><code id="topN.new_+3A_weight_mult">weight_mult</code></td>
<td>
<p>Weight multiplier for the positive entries over the missing entries.</p>
</td></tr>
<tr><td><code id="topN.new_+3A_maxupd">maxupd</code></td>
<td>
<p>Maximum number of TNCG updates to perform. You might want to
increase this value depending on the use-case.</p>
</td></tr>
<tr><td><code id="topN.new_+3A_nthreads">nthreads</code></td>
<td>
<p>Number of parallel threads to use.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function calculates the latent factors in the same way as
'factors.single' - see the documentation of <a href="#topic+factors.single">factors.single</a>
for details.
</p>
<p>Just like <a href="#topic+topN">topN</a>, it does not exploit any potential sparsity in the
fitted matrices and vectors, so it might be a lot faster to produce the
recommendations externally (see the documentation for <a href="#topic+topN">topN</a> for details).
</p>
<p>The factors are initialized to the mean of each column in the fitted model.
</p>


<h3>Value</h3>


<ul>
<li><p> If passing 'output_score=FALSE' (the default), will return a vector of size 'n'
with the top-N highest predicted items for this user.If the 'X' data passed to
'poismf' was a 'data.frame', will contain the item IDs from its second column,
otherwise will be integers matching to the columns of 'X' (starting at 1). If
'X' was passed as 'data.frame', the entries in this vector might be coerced to
character regardless of their original type.
</p>
</li>
<li><p> If passing 'output_score=TRUE', will return a list, with the first entry
being the vector described above under name 'ix', and the second entry being the
associated scores, as a numeric vector of size 'n'.
</p>
</li></ul>



<h3>See Also</h3>

<p><a href="#topic+factors.single">factors.single</a> <a href="#topic+topN">topN</a>
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
