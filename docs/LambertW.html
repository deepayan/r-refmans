<!DOCTYPE html><html><head><title>Help for package LambertW</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {LambertW}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#LambertW-package'><p>R package for Lambert W<code class="reqn"> \times</code> F distributions</p></a></li>
<li><a href='#analyze_convergence'><p>Analyze convergence of Lambert W estimators</p></a></li>
<li><a href='#beta-utils'><p>Utilities for parameter vector beta of the input distribution</p></a></li>
<li><a href='#bootstrap'><p>Bootstrap Lambert W x F estimates</p></a></li>
<li><a href='#common-arguments'><p>Common arguments for several functions</p></a></li>
<li><a href='#datasets'><p>Datasets</p></a></li>
<li><a href='#delta_01'><p>Input parameters to get zero mean, unit variance output given delta</p></a></li>
<li><a href='#delta_GMM'><p>Estimate delta</p></a></li>
<li><a href='#delta_Taylor'><p>Estimate of delta by Taylor approximation</p></a></li>
<li><a href='#deprecated-functions'><p>List of deprecated functions</p></a></li>
<li><a href='#distname-utils'><p>Utilities for distributions supported in this package</p></a></li>
<li><a href='#G_delta_alpha'><p>Heavy tail transformation for Lambert W random variables</p></a></li>
<li><a href='#gamma_01'><p>Input parameters to get a zero mean, unit variance output for a given gamma</p></a></li>
<li><a href='#gamma_GMM'><p>Estimate gamma</p></a></li>
<li><a href='#gamma_Taylor'><p>Estimate gamma by Taylor approximation</p></a></li>
<li><a href='#Gaussianize'><p>Gaussianize matrix-like objects</p></a></li>
<li><a href='#get_gamma_bounds'><p>Get bounds for gamma</p></a></li>
<li><a href='#get_input'><p>Back-transform Y to X</p></a></li>
<li><a href='#get_output'><p>Transform input X to output Y</p></a></li>
<li><a href='#get_support'><p>Computes support for skewed Lambert W x F distributions</p></a></li>
<li><a href='#H_gamma'><p>H transformation with gamma</p></a></li>
<li><a href='#IGMM'><p>Iterative Generalized Method of Moments &ndash; IGMM</p></a></li>
<li><a href='#ks_test_t'><p>One-sample Kolmogorov-Smirnov test for student-t distribution</p></a></li>
<li><a href='#kurtosis'><p>Skewness and kurtosis</p></a></li>
<li><a href='#LambertW_fit-methods'><p>Methods for Lambert W<code class="reqn">\times</code> F estimates</p></a></li>
<li><a href='#LambertW_input_output-methods'><p>Methods for Lambert W input and output objects</p></a></li>
<li><a href='#LambertW-toolkit'><p>Do-it-yourself toolkit for Lambert W<code class="reqn"> \times</code> F distribution</p></a></li>
<li><a href='#LambertW-utils'><p>Utilities for Lambert W<code class="reqn"> \times</code> F Random Variables</p></a></li>
<li><a href='#loglik-LambertW-utils'><p>Log-Likelihood for Lambert W<code class="reqn">\times</code> F RVs</p></a></li>
<li><a href='#lp_norm'><p>lp norm of a vector</p></a></li>
<li><a href='#medcouple_estimator'><p>MedCouple Estimator</p></a></li>
<li><a href='#MLE_LambertW'><p>Maximum Likelihood Estimation for Lambert W<code class="reqn"> \times</code> F distributions</p></a></li>
<li><a href='#p_m1'><p>Non-principal branch probability</p></a></li>
<li><a href='#tau-utils'><p>Utilities for transformation vector tau</p></a></li>
<li><a href='#test_normality'><p>Visual and statistical Gaussianity check</p></a></li>
<li><a href='#test_symmetry'><p>Test symmetry based on Lambert W heavy tail(s)</p></a></li>
<li><a href='#theta-utils'><p>Utilities for the parameter vector of Lambert W<code class="reqn">\times</code> F distributions</p></a></li>
<li><a href='#U-utils'><p>Zero-mean, unit-variance version of standard distributions</p></a></li>
<li><a href='#W'><p>Lambert W function, its logarithm and derivative</p></a></li>
<li><a href='#W_delta'><p>Inverse transformation for heavy-tail Lambert W RVs</p></a></li>
<li><a href='#W_gamma'><p>Inverse transformation for skewed Lambert W RVs</p></a></li>
<li><a href='#xexp'><p>Transformation that defines the Lambert W function and its derivative</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Probabilistic Models to Analyze and Gaussianize Heavy-Tailed,
Skewed Data</td>
</tr>
<tr>
<td>Version:</td>
<td>0.6.9-1</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/gmgeorg/LambertW">https://github.com/gmgeorg/LambertW</a>
<a href="https://arxiv.org/abs/0912.4554">https://arxiv.org/abs/0912.4554</a> <a href="https://arxiv.org/abs/1010.2265">https://arxiv.org/abs/1010.2265</a>
<a href="https://arxiv.org/abs/1602.02200">https://arxiv.org/abs/1602.02200</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/gmgeorg/LambertW/issues">https://github.com/gmgeorg/LambertW/issues</a></td>
</tr>
<tr>
<td>Description:</td>
<td>Lambert W x F distributions are a generalized framework to analyze
    skewed, heavy-tailed data. It is based on an input/output system, where the
    output random variable (RV) Y is a non-linearly transformed version of an input
    RV X ~ F with similar properties as X, but slightly skewed (heavy-tailed).
    The transformed RV Y has a Lambert W x F distribution. This package contains
    functions to model and analyze skewed, heavy-tailed data the Lambert Way:
    simulate random samples, estimate parameters, compute quantiles, and plot/
    print results nicely. The most useful function is 'Gaussianize',
    which works similarly to 'scale', but actually makes the data Gaussian.
    A do-it-yourself toolkit allows users to define their own Lambert W x
    'MyFavoriteDistribution' and use it in their analysis right away.</td>
</tr>
<tr>
<td>Depends:</td>
<td>MASS, ggplot2,</td>
</tr>
<tr>
<td>Imports:</td>
<td>lamW (&ge; 1.3.0), stats, graphics, grDevices, RColorBrewer,
reshape2, Rcpp (&ge; 1.0.4), methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>boot, Rsolnp, nortest, numDeriv, testthat, data.table,
moments, knitr, markdown, vars,</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>LazyLoad:</td>
<td>yes</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, lamW</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-11-30 15:44:52 UTC; georg</td>
</tr>
<tr>
<td>Author:</td>
<td>Georg M. Goerg [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Georg M. Goerg &lt;im@gmge.org&gt;</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-11-30 17:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='LambertW-package'>R package for Lambert W<code class="reqn"> \times</code> F distributions</h2><span id='topic+LambertW-package'></span><span id='topic+LambertW'></span>

<h3>Description</h3>

<p>This package is based on notation, definitions, and results of Goerg (2011,
2015, 2016).  I will not include these references in the description of
each single function.
</p>
<p>Lambert W<code class="reqn"> \times</code> F distributions are a general framework to model and
transform skewed, heavy-tailed data. Lambert W<code class="reqn"> \times</code> F random
variables (RV) are based on an input/ouput system with input RV <code class="reqn">X
    \sim F_X(x \mid \boldsymbol \beta)</code> and output <code class="reqn">Y</code>, which is a
non-linearly transformed version of X &ndash; with similar properties to X,
but slightly skewed and/or heavy-tailed.  Then Y has a 'Lambert W
<code class="reqn">\times F_X</code>' distribution - see References.
</p>
<p><code><a href="#topic+get_distnames">get_distnames</a></code> lists all implemented Lambert W <code class="reqn">\times</code> F
distributions in this package. If you want to generate a
skewed/heavy-tailed version of a distribution that is not implemented,
you can use the do-it-yourself modular toolkit
(<code><a href="#topic+create_LambertW_input">create_LambertW_input</a></code> and
<code><a href="#topic+create_LambertW_output">create_LambertW_output</a></code>). It allows users to quickly
implement their own Lambert W x 'MyFavoriteDistribution' and use it in
their analysis right away.
</p>
<p>This package contains several functions to analyze skewed and heavy-tailed
data: simulate random samples (<code><a href="#topic+rLambertW">rLambertW</a></code>), evaluate pdf and
cdf (<code><a href="#topic+dLambertW">dLambertW</a></code> and <code><a href="#topic+pLambertW">pLambertW</a></code>), estimate
parameters (<code><a href="#topic+IGMM">IGMM</a></code> and <code><a href="#topic+MLE_LambertW">MLE_LambertW</a></code>), compute
quantiles (<code><a href="#topic+qLambertW">qLambertW</a></code>), and plot/print results nicely
(<code><a href="#topic+plot.LambertW_fit">plot.LambertW_fit</a></code>, <code><a href="#topic+print.LambertW_fit">print.LambertW_fit</a></code>,
<code><a href="#topic+summary.LambertW_fit">summary.LambertW_fit</a></code>).
</p>
<p>Probably the most useful function is <code><a href="#topic+Gaussianize">Gaussianize</a></code>, which works
similarly to <code><a href="base.html#topic+scale">scale</a></code>, but makes your data Gaussian (not
just centers and scales it, but also makes it symmetric and removes
excess kurtosis).
</p>
<p>If you use this package in your work please cite it
(<code>citation("LambertW")</code>).  You can also send me an implementation of
your 'Lambert W <code class="reqn">\times</code> YourFavoriteDistribution' to add to the
<span class="pkg">LambertW</span> package (and I will reference your work introducing your
'Lambert W <code class="reqn">\times</code> YourFavoriteDistribution' here.)
</p>
<p>Feel free to contact me for comments, suggestions, code improvements,
implementation of new input distributions, bug reports, etc.
</p>


<h3>Author(s)</h3>

<p>Author and maintainer: Georg M. Goerg (im (at) gmge.org)
</p>


<h3>References</h3>

<p>Goerg, G.M. (2011). &ldquo;Lambert W Random Variables - A New Family of
Generalized Skewed Distributions with Applications to Risk
Estimation&rdquo;. Annals of Applied Statistics, 5 (3), 2197-2230.
(<a href="https://arxiv.org/abs/0912.4554">https://arxiv.org/abs/0912.4554</a>).
</p>
<p>Goerg, G.M. (2015). &ldquo;The Lambert Way to Gaussianize heavy-tailed data
with the inverse of Tukey's h transformation as a special case&rdquo;.  The
Scientific World Journal: Probability and Statistics with Applications in
Finance and Economics. Available at
<a href="https://www.hindawi.com/journals/tswj/2015/909231/">https://www.hindawi.com/journals/tswj/2015/909231/</a>.
</p>
<p>Goerg, G.M. (2016).  &ldquo;Rebuttal of the &ldquo;Letter to the Editor of
Annals of Applied Statistics&rdquo; on Lambert W x F distributions and the
IGMM algorithm&rdquo;.  Available on arxiv.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# Replicate parts of the analysis in Goerg (2011)
data(AA)
y &lt;- AA[AA$sex=="f", "bmi"]
test_normality(y)

fit.gmm &lt;- IGMM(y, type = "s")
summary(fit.gmm)  # gamma is significant and positive
plot(fit.gmm)

# Compare empirical to theoretical moments (given parameter estimates)
moments.theory &lt;-
 mLambertW(theta = list(beta = fit.gmm$tau[c("mu_x", "sigma_x")],
                        gamma = fit.gmm$tau["gamma"]),
           distname = "normal")
TAB &lt;- rbind(unlist(moments.theory),
             c(mean(y), sd(y), skewness(y), kurtosis(y)))
rownames(TAB) &lt;- c("Theoretical (IGMM)", "Empirical")
TAB

x &lt;- get_input(y, fit.gmm$tau)
test_normality(x) # input is normal -&gt; fit a Lambert W x Gaussian by MLE

fit.ml &lt;- MLE_LambertW(y, type = "s", distname = "normal", hessian = TRUE)
summary(fit.ml)
plot(fit.ml)

## End(Not run)

</code></pre>

<hr>
<h2 id='analyze_convergence'>Analyze convergence of Lambert W estimators</h2><span id='topic+analyze_convergence'></span><span id='topic+summary.convergence_LambertW_fit'></span><span id='topic+plot.convergence_LambertW_fit'></span>

<h3>Description</h3>

<p>Analyzes the feasibility of a Lambert W x F distribution for a
given dataset based on bootstrapping.  In particular it checks whether
parameter estimates support the hypothesis that the data indeed follows a
Lambert W x F distribution with finite mean and variance of the input
distribution, which is an implicit assumption of Lambert W x F random
variables in Goerg (2011).
</p>
<p>See Goerg (2016) for an alternative definition that does not rely on fnite
second order moments (set <code>use.mean.variance = FALSE</code> to use that type
of Lambert W <code class="reqn">\times</code> F distributions).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyze_convergence(
  LambertW_fit,
  sample.sizes = round(seq(0.2, 1, length = 5) * length(LambertW_fit$data)),
  ...
)

## S3 method for class 'convergence_LambertW_fit'
summary(object, type = c("basic", "norm", "perc", "bca"), ...)

## S3 method for class 'convergence_LambertW_fit'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="analyze_convergence_+3A_lambertw_fit">LambertW_fit</code>, <code id="analyze_convergence_+3A_object">object</code>, <code id="analyze_convergence_+3A_x">x</code></td>
<td>
<p>an object of class <code>"LambertW_fit"</code> with an
<code>IGMM</code> or <code>MLE_LambertW</code> estimate.</p>
</td></tr>
<tr><td><code id="analyze_convergence_+3A_sample.sizes">sample.sizes</code></td>
<td>
<p>sample sizes for several steps of the convergence
analysis.  By default, one of them equals the length of the original
data, which leads to improved plots (see
<code><a href="#topic+plot.convergence_LambertW_fit">plot.convergence_LambertW_fit</a></code>); it is not necessary,
though.</p>
</td></tr>
<tr><td><code id="analyze_convergence_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="#topic+bootstrap">bootstrap</a></code> or
<code><a href="boot.html#topic+boot.ci">boot.ci</a></code> in <span class="pkg">boot</span> package.</p>
</td></tr>
<tr><td><code id="analyze_convergence_+3A_type">type</code></td>
<td>
<p>type of confidence interval from bootstrap estimates. Passes this
argument along to <code><a href="boot.html#topic+boot.ci">boot.ci</a></code>.  However, contrary to 
the <code>type</code> argument in <code><a href="boot.html#topic+boot.ci">boot.ci</a></code>, the <code>summary</code>
function can only take one of <code>c("basic", "norm", "perc", "bca")</code>.
See <code><a href="boot.html#topic+boot.ci">boot.ci</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Stehlik and Hermann (2015) show that when researchers use the IGMM algorithm
outlined in Goerg (2011) erroneously on data that does not have finite
input variance (and hence mean), the algorithm estimates do not converge.
</p>
<p>In practice, researchers should of course first check if a given model is
appropriate for their data-generating process.  Since original Lambert W x F
distributions assume that mean and variance are finite, it is not a given
that for a specific dataset the Lambert W x F setting makes sense.
</p>
<p>The bootstrap analysis reverses Stehlik and Hermann's argument and checks
whether the IGMM estimates <code class="reqn">\lbrace \hat{\tau}^{(n)} \rbrace_{n}</code>
converge for increasing (bootstrapped) sample size <code class="reqn">n</code>: if they do,
then modeling the data with a Lambert W x F distribution is appropriate;
if estimates do not converge, then this indicates that the input data is
too heavy tailed for a classic skewed location-scale Lambert W x F
framework. In this case, take a look at (double-)heavy tailed Lambert W x
F distributions (<code>type = 'hh'</code>) or unrestricted location-scale
Lambert W x F distributions (<code>use.mean.variance = FALSE</code>). For
details see Goerg (2016).
</p>


<h3>References</h3>

<p>Stehlik and Hermann (2015). &ldquo;Letter to the Editor&rdquo;. Ann. Appl. Stat. 9
2051. doi:10.1214/15-AOAS864 &ndash; <a href="https://projecteuclid.org/euclid.aoas/1453994190">https://projecteuclid.org/euclid.aoas/1453994190</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

sim.data &lt;- list("Lambert W x Gaussian" = 
                    rLambertW(n = 100, distname = "normal", 
                              theta = list(gamma = 0.1, beta = c(1, 2))),
                 "Cauchy" = rcauchy(n = 100))
# do not use lapply() as it does not work well with match.call() in
# bootstrap()
igmm.ests &lt;- list()
conv.analyses &lt;- list()
for (nn in names(sim.data)) {
  igmm.ests[[nn]] &lt;- IGMM(sim.data[[nn]], type = "s")
  conv.analyses[[nn]] &lt;- analyze_convergence(igmm.ests[[nn]])
}
plot.lists &lt;- lapply(conv.analyses, plot)
for (nn in names(plot.lists)) {
  plot.lists[[nn]] &lt;- lapply(plot.lists[[nn]], "+", ggtitle(nn))
}

require(gridExtra)
for (jj in seq_along(plot.lists[[1]])) {
  grid.arrange(plot.lists[[1]][[jj]], plot.lists[[2]][[jj]], ncol = 2)
}

## End(Not run)

</code></pre>

<hr>
<h2 id='beta-utils'>Utilities for parameter vector beta of the input distribution</h2><span id='topic+beta-utils'></span><span id='topic+beta2tau'></span><span id='topic+check_beta'></span><span id='topic+estimate_beta'></span><span id='topic+get_beta_names'></span>

<h3>Description</h3>

<p>The parameter <code class="reqn">\boldsymbol \beta</code> specifies the input distribution
<code class="reqn">X \sim F_X(x \mid \boldsymbol \beta)</code>.
</p>
<p><code>beta2tau</code> converts <code class="reqn">\boldsymbol \beta</code> to the transformation vector
<code class="reqn">\tau = (\mu_x, \sigma_x, \gamma = 0, \alpha = 1, \delta = 0)</code>, which
defines the Lambert W<code class="reqn">\times</code> F random variable mapping from <code class="reqn">X</code>
to <code class="reqn">Y</code> (see <code><a href="#topic+tau-utils">tau-utils</a></code>). Parameters <code class="reqn">\mu_x</code> and
<code class="reqn">\sigma_x</code> of <code class="reqn">X</code> in general depend on <code class="reqn">\boldsymbol \beta</code>
(and may not even exist for <code>use.mean.variance = TRUE</code>; in this case
<code>beta2tau</code> will throw an error).
</p>
<p><code>check_beta</code> checks if <code class="reqn">\boldsymbol \beta</code> defines a
valid distribution, e.g., for normal distribution <code>'sigma'</code> must be
positive.
</p>
<p><code>estimate_beta</code> estimates <code class="reqn">\boldsymbol \beta</code> for a given
<code class="reqn">F_X</code> using MLE or methods of moments.  Closed form solutions
are used if they exist; otherwise the MLE is obtained numerically using 
<code><a href="MASS.html#topic+fitdistr">fitdistr</a></code>.
</p>
<p><code>get_beta_names</code> returns (typical) names for each component of
<code class="reqn">\boldsymbol \beta</code>.
</p>
<p>Depending on the distribution 
<code class="reqn">\boldsymbol \beta</code> has different length and names: e.g., 
for a <code>"normal"</code> distribution <code>beta</code> is of length 
<code class="reqn">2</code> (<code>"mu"</code>, <code>"sigma"</code>); for an <code>"exp"</code>onential 
distribution <code>beta</code> is a scalar (rate <code>"lambda"</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta2tau(beta, distname, use.mean.variance = TRUE)

check_beta(beta, distname)

estimate_beta(x, distname)

get_beta_names(distname)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="beta-utils_+3A_beta">beta</code></td>
<td>
<p>numeric; vector <code class="reqn">\boldsymbol \beta</code> of the input
distribution; specifications as they are for the R implementation of this
distribution. For example, if <code>distname = "exp"</code>, then <code>beta = 2</code>
means that the rate of the exponential distribution equals <code class="reqn">2</code>; if
<code>distname = "normal"</code> then <code>beta = c(1,2)</code> means that the mean and
standard deviation are 1 and 2, respectively.</p>
</td></tr>
<tr><td><code id="beta-utils_+3A_distname">distname</code></td>
<td>
<p>character; name of input distribution; see
<code><a href="#topic+get_distnames">get_distnames</a></code>.</p>
</td></tr>
<tr><td><code id="beta-utils_+3A_use.mean.variance">use.mean.variance</code></td>
<td>
<p>logical; if <code>TRUE</code> it uses mean and variance
implied by <code class="reqn">\boldsymbol \beta</code> to do the transformation (Goerg 2011).
If <code>FALSE</code>, it uses the alternative definition from Goerg (2016)
with location and scale parameter.</p>
</td></tr>
<tr><td><code id="beta-utils_+3A_x">x</code></td>
<td>
<p>a numeric vector of real values (the <em>input</em> data).</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>estimate_beta</code> does not do any data transformation as part of the
Lambert W<code class="reqn">\times</code> F input/output framework.  For an initial estimate
of <code class="reqn">\theta</code> for Lambert W<code class="reqn">\times</code> F distributions see
<code><a href="#topic+get_initial_theta">get_initial_theta</a></code> and <code><a href="#topic+get_initial_tau">get_initial_tau</a></code>.
</p>
<p>A quick initial estimate of <code class="reqn">\theta</code> is obtained by first finding the
(approximate) input <code class="reqn">\widehat{\boldsymbol x}_{\widehat{\theta}}</code> by
<code><a href="#topic+IGMM">IGMM</a></code>, and then getting the MLE of <code class="reqn">\boldsymbol \beta</code>
for this input data <code class="reqn">\widehat{\boldsymbol x}_{\widehat{\theta}} \sim
    F_X(x \mid \boldsymbol \beta)</code> (usually using
<code><a href="MASS.html#topic+fitdistr">fitdistr</a></code>).
</p>


<h3>Value</h3>

<p><code>beta2tau</code> returns a numeric vector, which is <code class="reqn">\tau =
    \tau(\boldsymbol \beta)</code> implied by <code>beta</code> and <code>distname</code>.
</p>
<p><code>check_beta</code> throws an error if <code class="reqn">\boldsymbol \beta</code> is not
appropriate for the given distribution; e.g., if it has too many values
or if they are not within proper bounds (e.g., <code>beta['sigma']</code> of a
<code>"normal"</code> distribution must be positive).
</p>
<p><code>estimate_beta</code> returns a named vector with estimates for
<code class="reqn">\boldsymbol \beta</code> given <code>x</code>.
</p>
<p><code>get_beta_names</code> returns a vector of characters.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+tau-utils">tau-utils</a></code>, <code><a href="#topic+theta-utils">theta-utils</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># By default: delta = gamma = 0 and alpha = 1
beta2tau(c(1, 1), distname = "normal") 
## Not run: 
  beta2tau(c(1, 4, 1), distname = "t")

## End(Not run)
beta2tau(c(1, 4, 1), distname = "t", use.mean.variance = FALSE)
beta2tau(c(1, 4, 3), distname = "t") # no problem


## Not run: 
check_beta(beta = c(1, 1, -1), distname = "normal")

## End(Not run)


set.seed(124)
xx &lt;- rnorm(100)^2
estimate_beta(xx, "exp")
estimate_beta(xx, "chisq")

</code></pre>

<hr>
<h2 id='bootstrap'>Bootstrap Lambert W x F estimates</h2><span id='topic+bootstrap'></span><span id='topic+bootstrap.LambertW_fit'></span>

<h3>Description</h3>

<p>Analyzes the Lambert W x F for a given dataset based on bootstrapping. Depends
on the <span class="pkg">boot</span> package and returns a <code>"boot"</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootstrap(object, ...)

## S3 method for class 'LambertW_fit'
bootstrap(object, sample.size = length(object$data), R = 100, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bootstrap_+3A_object">object</code></td>
<td>
<p>an object of class <code>"LambertW_fit"</code>; usually
output of <code><a href="#topic+IGMM">IGMM</a></code> or <code><a href="#topic+MLE_LambertW">MLE_LambertW</a></code>.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_...">...</code></td>
<td>
<p>additional arguments passed to <code><a href="boot.html#topic+boot">boot</a></code>.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_sample.size">sample.size</code></td>
<td>
<p>sample size of the bootstrap.  By default, equal to the 
original data length.</p>
</td></tr>
<tr><td><code id="bootstrap_+3A_r">R</code></td>
<td>
<p>number of replicates for the bootstrap. See 
<code><a href="boot.html#topic+boot">boot</a></code> for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>"boot"</code> representing the bootstrap 
analysis of <code class="reqn">\hat{\theta}</code> (or <code class="reqn">\hat{\tau}</code>) of 
an Lambert W x F estimator (<code>LambertW_fit</code>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
yy &lt;- rLambertW(n = 1000, theta = list(delta = c(0.1), beta = c(2, 1)), 
                distname = "normal")
mod.igmm &lt;- IGMM(yy, type = "h")
boot.est &lt;- bootstrap(mod.igmm, R = 100) 
# use summary and plot from 'boot' pkg
plot(boot.est, 3)
summary(boot.est)

## End(Not run)
</code></pre>

<hr>
<h2 id='common-arguments'>Common arguments for several functions</h2><span id='topic+common-arguments'></span>

<h3>Description</h3>

<p>Reference list of most common function arguments in this package.
</p>


<h3>Arguments</h3>

<table>
<tr><td><code id="common-arguments_+3A_y">y</code></td>
<td>
<p>a numeric vector of real values (the observed data).</p>
</td></tr>
<tr><td><code id="common-arguments_+3A_distname">distname</code></td>
<td>
<p>character; name of input distribution; see
<code><a href="#topic+get_distnames">get_distnames</a></code>.</p>
</td></tr>
<tr><td><code id="common-arguments_+3A_type">type</code></td>
<td>
<p>type of Lambert W <code class="reqn">\times</code> F distribution: skewed <code>"s"</code>;
heavy-tail <code>"h"</code>; or skewed heavy-tail <code>"hh"</code>.</p>
</td></tr>
<tr><td><code id="common-arguments_+3A_theta">theta</code></td>
<td>
<p>list; a (possibly incomplete) list of parameters <code>alpha</code>,
<code>beta</code>, <code>gamma</code>, <code>delta</code>. <code><a href="#topic+complete_theta">complete_theta</a></code>
fills in default values for missing entries.</p>
</td></tr>
<tr><td><code id="common-arguments_+3A_beta">beta</code></td>
<td>
<p>numeric vector (deprecated); parameter <code class="reqn">\boldsymbol \beta</code> of
the input distribution.  See <code><a href="#topic+check_beta">check_beta</a></code> on how to specify
<code>beta</code> for each distribution.</p>
</td></tr>
<tr><td><code id="common-arguments_+3A_gamma">gamma</code></td>
<td>
<p>scalar (deprecated); skewness parameter; default: <code>0</code>.</p>
</td></tr>
<tr><td><code id="common-arguments_+3A_delta">delta</code></td>
<td>
<p>scalar or vector (length 2) (deprecated); heavy-tail
parameter(s); default: <code>0</code>.</p>
</td></tr>
<tr><td><code id="common-arguments_+3A_alpha">alpha</code></td>
<td>
<p>scalar or vector (length 2) (deprecated); heavy tail
exponent(s); default: <code>1</code>.</p>
</td></tr>
<tr><td><code id="common-arguments_+3A_tau">tau</code></td>
<td>
<p>named vector <code class="reqn">\tau</code> which defines the variable transformation.
Must have at least <code>'mu_x'</code> and <code>'sigma_x'</code> element; see
<code><a href="#topic+complete_tau">complete_tau</a></code> for details.</p>
</td></tr>
<tr><td><code id="common-arguments_+3A_return.u">return.u</code></td>
<td>
<p>logical; if <code>TRUE</code>, it returns the standardized input
that corresponds to <code class="reqn">U</code>, which is the zero-mean and/or unit-variance
version of input <code class="reqn">X \sim F_X</code>.</p>
</td></tr>
<tr><td><code id="common-arguments_+3A_use.mean.variance">use.mean.variance</code></td>
<td>
<p>logical; if <code>TRUE</code> it uses mean and variance
implied by <code class="reqn">\boldsymbol \beta</code> to do the transformation (Goerg 2011).
If <code>FALSE</code>, it uses the alternative definition from Goerg (2016)
with location and scale parameter.</p>
</td></tr>
</table>

<hr>
<h2 id='datasets'>Datasets</h2><span id='topic+datasets'></span><span id='topic+AA'></span><span id='topic+SolarFlares'></span>

<h3>Description</h3>

<p>Collection of datasets in this package.
</p>
<p>The Australian athletes dataset (<code>AA</code>) were collected in a study of how
data on various characteristics of the blood varied with sport body size
and sex of the athlete.
</p>
<p>The <code>SolarFlares</code> data are <code class="reqn">12,773</code> observations of peak gamma-ray
intensity of solar flares recorded from Feb, 1980 - Dec, 1989. It was
analyzed for power-law properties in Clauset et al. (2009) and comes
originally from Dennis et al.  (1991).  Thanks to the authors for giving
permission to include the dataset in this package.
</p>


<h3>Format</h3>

<p><code>AA</code> is a <code>data.frame</code> with 13 columns and 202 rows.
See <code>ais</code> dataset in the <span class="pkg">DAAG</span> package for details.
</p>


<h3>Source</h3>

<p><code>AA</code> was the basis for the analyses that are reported in 
Telford and Cunningham (1991).
</p>
<p>Resources on the <code>SolarFlares</code> dataset can be found at:
</p>
<p><a href="https://sites.santafe.edu/~aaronc/powerlaws/data.htm">https://sites.santafe.edu/~aaronc/powerlaws/data.htm</a>
</p>
<p><a href="https://ui.adsabs.harvard.edu/abs/1991chxb.book.....D/abstract">https://ui.adsabs.harvard.edu/abs/1991chxb.book.....D/abstract</a>
</p>
<p>See also References.
</p>


<h3>References</h3>

<p>Telford, R.D. and Cunningham, R.B. 1991.  Sex, sport and
body-size dependency of hematology in highly trained athletes.  Medicine and
Science in Sports and Exercise 23: 788-794.
</p>
<p>Dennis, B. R.; Orwig, L. E.; Kennard, G. S.; Labow, G. J.;
Schwartz, R. A.; Shaver, A. R.; Tolbert, A. K. (1991). &ldquo;The Complete Hard X
Ray Burst Spectrometer Event List, 1980-1989.&rdquo; NASA Technical Memorandum
4332.
</p>
<p>Clauset, A., C. R. Shalizi, and M. E. J. Newman (2009). &ldquo;Power-law
distributions in empirical data&rdquo;. SIAM Review 51, 661-703 (2009). See also
<a href="https://sites.santafe.edu/~aaronc/powerlaws/data.htm">https://sites.santafe.edu/~aaronc/powerlaws/data.htm</a>.
</p>

<hr>
<h2 id='delta_01'>Input parameters to get zero mean, unit variance output given delta</h2><span id='topic+delta_01'></span>

<h3>Description</h3>

<p>Computes the input mean <code class="reqn">\mu_x(\delta)</code> and standard deviation
<code class="reqn">\sigma_x(\delta)</code> for input <code class="reqn">X \sim F(x \mid \boldsymbol \beta)</code>
such that the resulting heavy-tail Lambert W x F RV <code class="reqn">Y</code> with
<code class="reqn">\delta</code> has zero-mean and unit-variance.  So far works only for
Gaussian input and scalar <code class="reqn">\delta</code>.
</p>
<p>The function works for any output mean and standard deviation, but default
values are <code class="reqn">\mu_y = 0</code> and <code class="reqn">\sigma_y = 1</code> since they are the most
useful, e.g., to generate a standardized Lambert W white noise sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delta_01(delta, mu.y = 0, sigma.y = 1, distname = "normal")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delta_01_+3A_delta">delta</code></td>
<td>
<p>scalar; heavy-tail parameter.</p>
</td></tr>
<tr><td><code id="delta_01_+3A_mu.y">mu.y</code></td>
<td>
<p>output mean; default: <code>0</code>.</p>
</td></tr>
<tr><td><code id="delta_01_+3A_sigma.y">sigma.y</code></td>
<td>
<p>output standard deviation; default: <code>1</code>.</p>
</td></tr>
<tr><td><code id="delta_01_+3A_distname">distname</code></td>
<td>
<p>string; distribution name.  Currently this function only supports
<code>"normal"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>5-dimensional vector (<code class="reqn">\mu_x(\delta)</code>, <code class="reqn">\sigma_x(\delta)</code>, 0, <code class="reqn">\delta</code>, 1), 
where <code class="reqn">\gamma = 0</code>  and <code class="reqn">\alpha = 1</code> are set for the sake of compatiblity with other functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
delta_01(0) # for delta = 0, input == output, therefore (0,1,0,0,1)
# delta &gt; 0 (heavy-tails): 
#   Y is symmetric for all delta: 
#   mean = 0; however, sd must be smaller 
delta_01(0.1) 
delta_01(1/3)  # only moments up to order 2 exist
delta_01(1)  # neither mean nor variance exist, thus NA
</code></pre>

<hr>
<h2 id='delta_GMM'>Estimate delta</h2><span id='topic+delta_GMM'></span>

<h3>Description</h3>

<p>This function minimizes the Euclidean distance between the sample kurtosis of
the back-transformed data <code class="reqn">W_{\delta}(\boldsymbol z)</code> and a
user-specified target kurtosis as a function of <code class="reqn">\delta</code> (see
References).  Only an iterative application of this function will give a
good estimate of <code class="reqn">\delta</code> (see <code><a href="#topic+IGMM">IGMM</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delta_GMM(
  z,
  type = c("h", "hh"),
  kurtosis.x = 3,
  skewness.x = 0,
  delta.init = delta_Taylor(z),
  tol = .Machine$double.eps^0.25,
  not.negative = FALSE,
  optim.fct = c("nlm", "optimize"),
  lower = -1,
  upper = 3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delta_GMM_+3A_z">z</code></td>
<td>
<p>a numeric vector of data values.</p>
</td></tr>
<tr><td><code id="delta_GMM_+3A_type">type</code></td>
<td>
<p>type of Lambert W <code class="reqn">\times</code> F distribution: skewed <code>"s"</code>;
heavy-tail <code>"h"</code>; or skewed heavy-tail <code>"hh"</code>.</p>
</td></tr>
<tr><td><code id="delta_GMM_+3A_kurtosis.x">kurtosis.x</code></td>
<td>
<p>theoretical kurtosis of the input X; default: <code>3</code>
(e.g., for <code class="reqn">X \sim</code> Gaussian).</p>
</td></tr>
<tr><td><code id="delta_GMM_+3A_skewness.x">skewness.x</code></td>
<td>
<p>theoretical skewness of the input X. Only used if <code>type = "hh"</code>; 
default: <code>0</code> (e.g., for <code class="reqn">X \sim</code> symmetric).</p>
</td></tr>
<tr><td><code id="delta_GMM_+3A_delta.init">delta.init</code></td>
<td>
<p>starting value for optimization; default: <code><a href="#topic+delta_Taylor">delta_Taylor</a></code>.</p>
</td></tr>
<tr><td><code id="delta_GMM_+3A_tol">tol</code></td>
<td>
<p>a positive scalar; tolerance level for terminating 
the iterative algorithm; default: <code>.Machine$double.eps^0.25</code>.</p>
</td></tr>
<tr><td><code id="delta_GMM_+3A_not.negative">not.negative</code></td>
<td>
<p>logical; if <code>TRUE</code> the estimate for <code class="reqn">\delta</code> is
restricted to the non-negative reals. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="delta_GMM_+3A_optim.fct">optim.fct</code></td>
<td>
<p>which R optimization function should be used. Either <code>'optimize'</code> 
(only for <code>type = 'h'</code> and if <code>not.negative = FALSE</code>) or <code>'nlm'</code>.  
Performance-wise there is no big difference.</p>
</td></tr>
<tr><td><code id="delta_GMM_+3A_lower">lower</code>, <code id="delta_GMM_+3A_upper">upper</code></td>
<td>
<p>lower and upper bound for optimization. Default: <code>-1</code> and <code>3</code> 
(this covers most real-world heavy-tail scenarios).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements: 
</p>
<table>
<tr><td><code>delta</code></td>
<td>
<p> optimal <code class="reqn">\delta</code> for data <code class="reqn">z</code>, </p>
</td></tr> 
<tr><td><code>iterations</code></td>
<td>
<p>number of iterations (<code>NA</code> for <code>'optimize'</code>).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+gamma_GMM">gamma_GMM</a></code> for the skewed version of this function;
<code><a href="#topic+IGMM">IGMM</a></code> to estimate all parameters jointly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# very heavy-tailed (like a Cauchy)
y &lt;- rLambertW(n = 1000, theta = list(beta = c(1, 2), delta = 1), 
               distname = "normal")
delta_GMM(y) # after the first iteration

</code></pre>

<hr>
<h2 id='delta_Taylor'>Estimate of delta by Taylor approximation</h2><span id='topic+delta_Taylor'></span>

<h3>Description</h3>

<p>Computes an initial estimate of <code class="reqn">\delta</code> based on the Taylor
approximation of the kurtosis of Lambert W <code class="reqn">\times</code> Gaussian RVs. See
Details for the formula.
</p>
<p>This is the initial estimate for <code><a href="#topic+IGMM">IGMM</a></code> and <code><a href="#topic+delta_GMM">delta_GMM</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>delta_Taylor(y, kurtosis.y = kurtosis(y), distname = "normal")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="delta_Taylor_+3A_y">y</code></td>
<td>
<p>a numeric vector of data values.</p>
</td></tr>
<tr><td><code id="delta_Taylor_+3A_kurtosis.y">kurtosis.y</code></td>
<td>
<p>kurtosis of <code class="reqn">y</code>; default: empirical kurtosis of data <code>y</code>.</p>
</td></tr>
<tr><td><code id="delta_Taylor_+3A_distname">distname</code></td>
<td>
<p>string; name of the distribution. Currently only supports <code>"normal"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The second order Taylor approximation of the theoretical kurtosis of a
heavy tail Lambert W x Gaussian RV around <code class="reqn">\delta = 0</code> 
equals
</p>
<p style="text-align: center;"><code class="reqn"> \gamma_2(\delta) = 3 + 12 \delta + 66 \delta^2 + \mathcal{O}(\delta^3). </code>
</p>

<p>Ignoring higher order terms, using the empirical estimate on the left hand side, and 
solving for <code class="reqn">\delta</code> yields (positive root) 
</p>
<p style="text-align: center;"><code class="reqn">\widehat{\delta}_{Taylor} = \frac{1}{66} \cdot \left( \sqrt{66
\widehat{\gamma}_2(\mathbf{y}) - 162}-6 \right), </code>
</p>
 
<p>where <code class="reqn">\widehat{\gamma}_2(\mathbf{y})</code> is the empirical kurtosis of <code class="reqn">\mathbf{y}</code>.
</p>
<p>Since the kurtosis is finite only for <code class="reqn">\delta &lt; 1/4</code>,
<code>delta_Taylor</code> upper-bounds the returned estimate by <code class="reqn">0.25</code>.
</p>


<h3>Value</h3>

<p>scalar; estimated <code class="reqn">\delta</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IGMM">IGMM</a></code>  to estimate all parameters jointly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(2)
# a little heavy-tailed (kurtosis does exist)
y &lt;- rLambertW(n = 1000, theta = list(beta = c(0, 1), delta = 0.2), 
               distname = "normal")
# good initial estimate since true delta=0.2 close to 0, and
# empirical kurtosis well-defined.
delta_Taylor(y) 
delta_GMM(y) # iterative estimate

y &lt;- rLambertW(n = 1000, theta = list(beta = c(0, 1), delta = 1), 
               distname = "normal") # very heavy-tailed (like a Cauchy)
delta_Taylor(y) # bounded by 1/4 (as otherwise kurtosis does not exist)
delta_GMM(y) # iterative estimate

</code></pre>

<hr>
<h2 id='deprecated-functions'>List of deprecated functions</h2><span id='topic+deprecated-functions'></span><span id='topic+beta_names'></span><span id='topic+bounds_theta'></span><span id='topic+d1W_1'></span><span id='topic+p_1'></span><span id='topic+params2theta'></span><span id='topic+skewness_test'></span><span id='topic+starting_theta'></span><span id='topic+support'></span><span id='topic+normfit'></span><span id='topic+theta2params'></span><span id='topic+vec.norm'></span><span id='topic+W_1'></span><span id='topic+W_gamma_1'></span><span id='topic+H'></span>

<h3>Description</h3>

<p>These functions have been deprecated in v0.5 of <span class="pkg">LambertW</span> mostly for
sake of following R style guides with respect to naming of
functions. This means that all deprecated functions here have an
analogous function with a similar &ndash; more style consistent &ndash; name. See
also the <code>NEWS</code> file.
</p>
<p>As of v0.6.8-1 deprecated functions will throw errors ('stop()') and print out the suggested
new function (name).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>beta_names(...)

bounds_theta(...)

d1W_1(z, W.z = W(z, branch = -1))

p_1(...)

params2theta(...)

skewness_test(...)

starting_theta(...)

support(...)

normfit(...)

theta2params(...)

vec.norm(...)

W_1(z)

W_gamma_1(z, gamma)

H(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="deprecated-functions_+3A_...">...</code></td>
<td>
<p>arguments passed to deprecated functions.</p>
</td></tr>
<tr><td><code id="deprecated-functions_+3A_z">z</code>, <code id="deprecated-functions_+3A_w.z">W.z</code></td>
<td>
<p>see <code><a href="#topic+deriv_W">deriv_W</a></code></p>
</td></tr>
<tr><td><code id="deprecated-functions_+3A_gamma">gamma</code></td>
<td>
<p>see <code><a href="#topic+W_gamma">W_gamma</a></code>.</p>
</td></tr>
</table>

<hr>
<h2 id='distname-utils'>Utilities for distributions supported in this package</h2><span id='topic+distname-utils'></span><span id='topic+check_distname'></span><span id='topic+get_distnames'></span><span id='topic+get_distname_family'></span>

<h3>Description</h3>

<p>The Lambert W<code class="reqn">\times</code> F framework can take any (continuous) random variable with distribution
F and make it skewed (<code>type = "s"</code>), heavy tailed (<code>type = "h"</code>),
or both (<code>type = "hh"</code>).
</p>
<p>In principle, this works for any F.  Of course, this package implements only a finite
number of distributions, which can be specified with the <code>distname</code> argument.
Most functions in this package, however, also allow you to pass your own distribution and parameters
and create a Lambert W<code class="reqn">\times</code> F version of it.
</p>
<p><code>check_distname</code> checks if the distribution specified by
the <code>distname</code> argument is implemented in this package.
</p>
<p><code>get_distname_family</code> determines whether a distribution is a 
location, scale, or location-scale family. 
It also returns whether the distribution is supported on non-negative
values only.
</p>
<p><code>get_distnames</code> lists all currently implemented distributions <code class="reqn">F_X</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_distname(distname)

get_distname_family(distname)

get_distnames()
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="distname-utils_+3A_distname">distname</code></td>
<td>
<p>character; name of input distribution; see
<code><a href="#topic+get_distnames">get_distnames</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>check_distname</code> returns (invisible) that the distribution is implemented, 
or throws an error otherwise.
</p>
<p><code>get_distname_family</code> returns a list with
</p>
<table>
<tr><td><code>location</code></td>
<td>
<p> logical; if <code>TRUE</code>, the distribution is a location family,</p>
</td></tr>
<tr><td><code>scale</code></td>
<td>
<p> logical; if <code>TRUE</code>, the distribution is a scale family.</p>
</td></tr>
<tr><td><code>is.non.negative</code></td>
<td>
<p> logical; if <code>TRUE</code>, the distribution has support only for
the non-negative reals (this is usually the case when <code>location = FALSE</code>
and <code>scale = TRUE</code>)</p>
</td></tr>
</table>
<p><code>get_distnames</code> returns a vector of strings in alphabetical order. 
It lists all supported distributions. 
Each string can be passed as the <code>distname</code> argument to several functions in this package.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+create_LambertW_input">create_LambertW_input</a></code>, <code><a href="#topic+create_LambertW_output">create_LambertW_output</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
check_distname("normal")
## Not run: 
check_distname("my_great_distribution")

## End(Not run)

get_distname_family("normal")
</code></pre>

<hr>
<h2 id='G_delta_alpha'>Heavy tail transformation for Lambert W random variables</h2><span id='topic+G_delta_alpha'></span><span id='topic+G_2delta_2alpha'></span><span id='topic+G_delta'></span>

<h3>Description</h3>

<p>Heavy-tail Lambert W RV transformation: <code class="reqn">G_{\delta, \alpha}(u) = u
\exp(\frac{\delta}{2} (u^2)^{\alpha})</code>. Reduces to Tukey's h distribution
for <code class="reqn">\alpha = 1</code> (<code><a href="#topic+G_delta">G_delta</a></code>) and Gaussian input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>G_delta_alpha(u, delta = 0, alpha = 1)

G_delta(u, delta = 0)

G_2delta_2alpha(u, delta = c(0, 0), alpha = c(1, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="G_delta_alpha_+3A_u">u</code></td>
<td>
<p>a numeric vector of real values.</p>
</td></tr>
<tr><td><code id="G_delta_alpha_+3A_delta">delta</code></td>
<td>
<p>heavy tail parameter; default <code>delta = 0</code>, which implies
<code>G_delta_alpha(u) = u</code>.</p>
</td></tr>
<tr><td><code id="G_delta_alpha_+3A_alpha">alpha</code></td>
<td>
<p>exponent in <code class="reqn">(u^2)^{\alpha}</code>; default <code>alpha = 1</code>
(Tukey's h).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric; same dimension/size as <code>u</code>.
</p>

<hr>
<h2 id='gamma_01'>Input parameters to get a zero mean, unit variance output for a given gamma</h2><span id='topic+gamma_01'></span>

<h3>Description</h3>

<p>Computes the input mean <code class="reqn">\mu_x(\gamma)</code> and standard deviation 
<code class="reqn">\sigma_x(\gamma)</code> for input <code class="reqn">X \sim F(x \mid \boldsymbol \beta)</code>
such that the resulting skewed Lambert W x F RV <code class="reqn">Y</code> with 
<code class="reqn">\gamma</code> has zero-mean and unit-variance.  So far works only for Gaussian 
input and scalar <code class="reqn">\gamma</code>.
</p>
<p>The function works for any output mean and standard deviation, but
<code class="reqn">\mu_y = 0</code> and <code class="reqn">\sigma_y = 1</code> are set as default as they 
are the most useful, e.g., to generate a standardized Lambert W white noise 
sequence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamma_01(gamma, mu.y = 0, sigma.y = 1, distname = "normal")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamma_01_+3A_gamma">gamma</code></td>
<td>
<p>skewness parameter</p>
</td></tr>
<tr><td><code id="gamma_01_+3A_mu.y">mu.y</code></td>
<td>
<p>output mean; default: <code>0</code>.</p>
</td></tr>
<tr><td><code id="gamma_01_+3A_sigma.y">sigma.y</code></td>
<td>
<p>output standard deviation; default: <code>1</code>.</p>
</td></tr>
<tr><td><code id="gamma_01_+3A_distname">distname</code></td>
<td>
<p>string; name of distribution. Currently only supports <code>"normal"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A 5-dimensional vector (<code class="reqn">\mu_x(\gamma)</code>, <code class="reqn">\sigma_x(\gamma)</code>, <code class="reqn">\gamma</code>, 0, 1),
where <code class="reqn">\delta = 0</code> and <code class="reqn">\alpha = 1</code> are set for the sake of compatiblity with 
other functions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
gamma_01(0) # for gamma = 0, input == output, therefore (0,1,0,0,1)
# input mean must be slightly negative to get a zero-mean output
gamma_01(0.1) # gamma = 0.1 means it is positively skewed
gamma_01(1)

</code></pre>

<hr>
<h2 id='gamma_GMM'>Estimate gamma</h2><span id='topic+gamma_GMM'></span>

<h3>Description</h3>

<p>This function minimizes the Euclidean distance between the theoretical
skewness of a skewed Lambert W x Gaussian random variable and the sample
skewness of the back-transformed data <code class="reqn">W_{\gamma}(\boldsymbol z)</code> as
a function of <code class="reqn">\gamma</code> (see References). Only an interative
application of this function will give a good estimate of <code class="reqn">\gamma</code>
(see <code><a href="#topic+IGMM">IGMM</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamma_GMM(
  z,
  skewness.x = 0,
  gamma.init = gamma_Taylor(z),
  robust = FALSE,
  tol = .Machine$double.eps^0.25,
  not.negative = FALSE,
  optim.fct = c("optimize", "nlminb")
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamma_GMM_+3A_z">z</code></td>
<td>
<p>a numeric vector of data values.</p>
</td></tr>
<tr><td><code id="gamma_GMM_+3A_skewness.x">skewness.x</code></td>
<td>
<p>theoretical skewness of the input <code class="reqn">X</code>; default:
<code>0</code>.</p>
</td></tr>
<tr><td><code id="gamma_GMM_+3A_gamma.init">gamma.init</code></td>
<td>
<p>starting value for <code class="reqn">\gamma</code>; default:
<code><a href="#topic+gamma_Taylor">gamma_Taylor</a></code>.</p>
</td></tr>
<tr><td><code id="gamma_GMM_+3A_robust">robust</code></td>
<td>
<p>logical; if <code>TRUE</code>, robust measure of asymmetry
(<code><a href="#topic+medcouple_estimator">medcouple_estimator</a></code>) will be used; default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="gamma_GMM_+3A_tol">tol</code></td>
<td>
<p>a positive scalar; tolerance level for terminating the iterative
algorithm; default: <code>.Machine$double.eps^0.25</code>.</p>
</td></tr>
<tr><td><code id="gamma_GMM_+3A_not.negative">not.negative</code></td>
<td>
<p>logical; if <code>TRUE</code>, the estimate for <code class="reqn">\gamma</code> is
restricted to non-negative reals, which is useful for scale-family
Lambert W<code class="reqn">\times</code> F random variables. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="gamma_GMM_+3A_optim.fct">optim.fct</code></td>
<td>
<p>string; which R optimization function should be used.  By
default it uses <code><a href="stats.html#topic+optimize">optimize</a></code> which is about 8-10x faster
than <code><a href="stats.html#topic+nlminb">nlminb</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with two elements: 
</p>
<table>
<tr><td><code>gamma</code></td>
<td>
<p> scalar; optimal <code class="reqn">\gamma</code>, </p>
</td></tr> 
<tr><td><code>iterations</code></td>
<td>
<p>number of iterations (<code>NA</code> for <code>"optimize"</code>).</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+delta_GMM">delta_GMM</a></code> for the heavy-tail version of this
function; <code><a href="#topic+medcouple_estimator">medcouple_estimator</a></code> for a robust measure of asymmetry;
<code><a href="#topic+IGMM">IGMM</a></code> for an iterative method to estimate all parameters
jointly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# highly skewed
y &lt;- rLambertW(n = 1000, theta = list(beta = c(1, 2), gamma = 0.5), 
               distname = "normal") 
gamma_GMM(y, optim.fct = "nlminb")
gamma_GMM(y)

</code></pre>

<hr>
<h2 id='gamma_Taylor'>Estimate gamma by Taylor approximation</h2><span id='topic+gamma_Taylor'></span>

<h3>Description</h3>

<p>Computes an initial estimate of <code class="reqn">\gamma</code> based on the Taylor
approximation of the skewness of Lambert W <code class="reqn">\times</code> Gaussian RVs around
<code class="reqn">\gamma = 0</code>. See Details for the formula.
</p>
<p>This is the initial estimate for <code><a href="#topic+IGMM">IGMM</a></code> and
<code><a href="#topic+gamma_GMM">gamma_GMM</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gamma_Taylor(y, skewness.y = skewness(y), skewness.x = 0, degree = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gamma_Taylor_+3A_y">y</code></td>
<td>
<p>a numeric vector of data values.</p>
</td></tr>
<tr><td><code id="gamma_Taylor_+3A_skewness.y">skewness.y</code></td>
<td>
<p>skewness of <code class="reqn">y</code>; default: empirical skewness of data
<code>y</code>.</p>
</td></tr>
<tr><td><code id="gamma_Taylor_+3A_skewness.x">skewness.x</code></td>
<td>
<p>skewness for input X; default: 0 (symmetric input).</p>
</td></tr>
<tr><td><code id="gamma_Taylor_+3A_degree">degree</code></td>
<td>
<p>degree of the Taylor approximation; in Goerg (2011) it just
uses the first order approximation (<code class="reqn">6 \cdot \gamma</code>); a much better
approximation is the third order (<code class="reqn">6 \cdot \gamma + 8 \cdot
\gamma^3</code>).  By default it uses the better <code>degree = 3</code>
approximation.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first order Taylor approximation of the theoretical skewness
<code class="reqn">\gamma_1</code> (not to be confused with the skewness parameter <code class="reqn">\gamma</code>)
of a Lambert W x Gaussian random variable around <code class="reqn">\gamma = 0</code> equals
</p>
<p style="text-align: center;"><code class="reqn"> \gamma_1(\gamma) = 6 \gamma + \mathcal{O}(\gamma^3). </code>
</p>

<p>Ignoring higher order terms, using the empirical estimate on the left hand
side, and solving <code class="reqn">\gamma</code> yields a first order Taylor approximation
estimate of <code class="reqn">\gamma</code> as
</p>
<p style="text-align: center;"><code class="reqn">
\widehat{\gamma}_{Taylor}^{(1)} = \frac{1}{6} \widehat{\gamma}_1(\mathbf{y}), 
</code>
</p>

<p>where <code class="reqn">\widehat{\gamma}_1(\mathbf{y})</code> is the empirical skewness of the
data <code class="reqn">\mathbf{y}</code>.
</p>
<p>As the Taylor approximation is only good in a neighborhood of <code class="reqn">\gamma =
0</code>, the output of <code>gamma_Taylor</code> is restricted to the interval
<code class="reqn">(-0.5, 0.5)</code>.
</p>
<p>The solution of the third order Taylor approximation
</p>
<p style="text-align: center;"><code class="reqn"> \gamma_1(\gamma) = 6 \gamma + 8 \gamma^3 + \mathcal{O}(\gamma^5),</code>
</p>

<p>is also supported.  See code for the solution to this third order polynomial.
</p>


<h3>Value</h3>

<p>Scalar; estimate of <code class="reqn">\gamma</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+IGMM">IGMM</a></code> to estimate all parameters jointly.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(2)
# a little skewness
yy &lt;- rLambertW(n = 1000, theta = list(beta = c(0, 1), gamma = 0.1), 
                distname = "normal") 
# Taylor estimate is good because true gamma = 0.1 close to 0
gamma_Taylor(yy) 

# very highly negatively skewed
yy &lt;- rLambertW(n = 1000, theta = list(beta = c(0, 1), gamma = -0.75), 
                distname = "normal") 
# Taylor estimate is bad since gamma = -0.75 is far from 0; 
# and gamma = -0.5 is the lower bound by default.
gamma_Taylor(yy) 

</code></pre>

<hr>
<h2 id='Gaussianize'>Gaussianize matrix-like objects</h2><span id='topic+Gaussianize'></span>

<h3>Description</h3>

<p><code>Gaussianize</code> is probably the most useful function in this package. It
works the same way as <code><a href="base.html#topic+scale">scale</a></code>, but instead of just
centering and scaling the data, it actually <em>Gaussianizes</em> the data
(works well for unimodal data).  See Goerg (2011, 2016) and Examples.
</p>
<p><strong>Important:</strong> For multivariate input <code>X</code> it performs a column-wise
Gaussianization (by simply calling <code>apply(X, 2, Gaussianize)</code>),
which is only a marginal Gaussianization.  This does <em>not</em> mean (and
is in general definitely not the case) that the transformed data is then
jointly Gaussian.
</p>
<p>By default <code>Gaussianize</code> returns the <code class="reqn">X \sim N(\mu_x, \sigma_x^2)</code>
input, not the zero-mean, unit-variance <code class="reqn">U \sim N(0, 1)</code> input.  Use
<code>return.u = TRUE</code> to obtain <code class="reqn">U</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Gaussianize(
  data = NULL,
  type = c("h", "hh", "s"),
  method = c("IGMM", "MLE"),
  return.tau.mat = FALSE,
  inverse = FALSE,
  tau.mat = NULL,
  verbose = FALSE,
  return.u = FALSE,
  input.u = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Gaussianize_+3A_data">data</code></td>
<td>
<p>a numeric matrix-like object; either the data that should be
Gaussianized; or the data that should &rdquo;DeGaussianized&rdquo; (<code>inverse =
TRUE</code>), i.e., converted back to the original space.</p>
</td></tr>
<tr><td><code id="Gaussianize_+3A_type">type</code></td>
<td>
<p>what type of non-normality: symmetric heavy-tails <code>"h"</code>
(default), skewed heavy-tails <code>"hh"</code>, or just skewed <code>"s"</code>.</p>
</td></tr>
<tr><td><code id="Gaussianize_+3A_method">method</code></td>
<td>
<p>what estimator should be used: <code>"MLE"</code> or <code>"IGMM"</code>.
<code>"IGMM"</code> gives exactly Gaussian characteristics (kurtosis
<code class="reqn">\equiv</code> 3 for <code>"h"</code> or skewness <code class="reqn">\equiv</code> 0 for <code>"s"</code>),
<code>"MLE"</code> comes close to this. Default: <code>"IGMM"</code> since it is much
faster than <code>"MLE"</code>.</p>
</td></tr>
<tr><td><code id="Gaussianize_+3A_return.tau.mat">return.tau.mat</code></td>
<td>
<p>logical; if <code>TRUE</code> it also returns the estimated
<code class="reqn">\tau</code> parameters as a matrix (same number of columns as
<code>data</code>).  This matrix can then be used to <code>Gaussianize</code> new
data with pre-estimated <code class="reqn">\tau</code>. It can also be used to
&ldquo;DeGaussianize&rdquo; data by passing it as an argument (<code>tau.mat</code>) to
<code>Gaussianize()</code> and set <code>inverse = TRUE</code>.</p>
</td></tr>
<tr><td><code id="Gaussianize_+3A_inverse">inverse</code></td>
<td>
<p>logical; if <code>TRUE</code> it performs the inverse transformation
using <code>tau.mat</code> to &quot;DeGaussianize&quot; the data back to the original
space again.</p>
</td></tr>
<tr><td><code id="Gaussianize_+3A_tau.mat">tau.mat</code></td>
<td>
<p>instead of estimating <code class="reqn">\tau</code> from the data you can pass it
as a matrix (usually obtained via <code>Gaussianize(..., return.tau.mat =
TRUE)</code>). If <code>inverse = TRUE</code> it uses this <code>tau</code> matrix to
&ldquo;DeGaussianize&rdquo; the data again.  This is useful to back-transform new
data in the Gaussianized space, e.g., predictions or fits, back to the
original space.</p>
</td></tr>
<tr><td><code id="Gaussianize_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, it prints out progress information in
the console. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="Gaussianize_+3A_return.u">return.u</code></td>
<td>
<p>logical; if <code>TRUE</code> it returns the zero-mean, unit
variance Gaussian input.  If <code>FALSE</code> (default) it returns the input
<code class="reqn">X</code>.</p>
</td></tr>
<tr><td><code id="Gaussianize_+3A_input.u">input.u</code></td>
<td>
<p>optional; if you used <code>return.u = TRUE</code> in a previous
step, and now you want to convert the data back to original space, then
you have to pass it as <code>input.u</code>.  If you pass numeric data as
<code>data</code>, <code>Gaussianize</code> assumes that <code>data</code> is the input
corresponding to <code class="reqn">X</code>, not <code class="reqn">U</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric matrix-like object with same dimension/size as input <code>data</code>. 
If <code>inverse = FALSE</code> it is the Gaussianize matrix / vector; 
if <code>TRUE</code> it is the &ldquo;DeGaussianized&rdquo; matrix / vector.
</p>
<p>The numeric parameters of mean, scale, and skewness/heavy-tail parameters
that were used in the Gaussianizing transformation are returned as
attributes of the output matrix: <code>'Gaussianized:mu'</code>,
<code>'Gaussianized:sigma'</code>, and for
</p>
<table>
<tr><td><code>type = "h":</code></td>
<td>
<p><code>'Gaussianized:delta'</code> &amp; <code>'Gaussianized:alpha'</code>,</p>
</td></tr>
<tr><td><code>type = "hh":</code></td>
<td>
<p><code>'Gaussianized:delta_l'</code> and <code>'Gaussianized:delta_r'</code> &amp; 
<code>'Gaussianized:alpha_l'</code> and <code>'Gaussianized:alpha_r'</code>,</p>
</td></tr>
<tr><td><code>type = "s":</code></td>
<td>
<p><code>'Gaussianized:gamma'</code>.</p>
</td></tr>
</table>
<p>They can also be returned as a separate matrix using <code>return.tau.mat =
    TRUE</code>. In this case <code>Gaussianize</code> returns a list with elements:
</p>
<table>
<tr><td><code>input</code></td>
<td>
<p>Gaussianized input data <code class="reqn">\boldsymbol x</code> (or
<code class="reqn">\boldsymbol u</code> if <code>return.u = TRUE</code>),</p>
</td></tr> <tr><td><code>tau.mat</code></td>
<td>
<p>matrix
with <code class="reqn">\tau</code> estimates that we used to get <code>x</code>; has same number
of columns as <code>x</code>, and 3, 5, or 6 rows (depending on
<code>type='s'</code>, <code>'h'</code>, or <code>'hh'</code>).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# Univariate example
set.seed(20)
y1 &lt;- rcauchy(n = 100)
out &lt;- Gaussianize(y1, return.tau.mat = TRUE)
x1 &lt;- get_input(y1, c(out$tau.mat[, 1]))  # same as out$input
test_normality(out$input) # Gaussianized a Cauchy!

kStartFrom &lt;- 20
y.cum.avg &lt;- (cumsum(y1)/seq_along(y1))[-seq_len(kStartFrom)]
x.cum.avg &lt;- (cumsum(x1)/seq_along(x1))[-seq_len(kStartFrom)]

plot(c((kStartFrom + 1): length(y1)), y.cum.avg, type="l" , lwd = 2, 
     main="CLT in practice", xlab = "n", 
     ylab="Cumulative sample average", 
     ylim = range(y.cum.avg, x.cum.avg))
lines(c((kStartFrom+1): length(y1)), x.cum.avg, col=2, lwd=2)
abline(h = 0)
grid()
legend("bottomright", c("Cauchy", "Gaussianize"), col = c(1, 2), 
       box.lty = 0, lwd = 2, lty = 1)

plot(x1, y1, xlab="Gaussian-like input", ylab = "Cauchy - output")
grid()
## Not run: 
# multivariate example
y2 &lt;- 0.5 * y1 + rnorm(length(y1))
YY &lt;- cbind(y1, y2)
plot(YY)

XX &lt;- Gaussianize(YY, type = "hh")
plot(XX)

out &lt;- Gaussianize(YY, type = "h", return.tau.mat = TRUE, 
                   verbose = TRUE, method = "IGMM")
                   
plot(out$input)
out$tau.mat

YY.hat &lt;- Gaussianize(data = out$input, tau.mat = out$tau.mat,
                      inverse = TRUE)
plot(YY.hat[, 1], YY[, 1])

## End(Not run)

</code></pre>

<hr>
<h2 id='get_gamma_bounds'>Get bounds for gamma</h2><span id='topic+get_gamma_bounds'></span>

<h3>Description</h3>

<p><code>get_gamma_bounds</code> returns lower and upper bounds for <code class="reqn">\gamma</code>, so
that the observed data range falls within the theoretical bounds of the
support of the distribution. This is only important for location family
input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_gamma_bounds(y, tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_gamma_bounds_+3A_y">y</code></td>
<td>
<p>a numeric vector of real values (the observed data).</p>
</td></tr>
<tr><td><code id="get_gamma_bounds_+3A_tau">tau</code></td>
<td>
<p>named vector <code class="reqn">\tau</code> which defines the variable transformation.
Must have at least <code>'mu_x'</code> and <code>'sigma_x'</code> element; see
<code><a href="#topic+complete_tau">complete_tau</a></code> for details.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Skewed Lambert W<code class="reqn">\times</code> F distributions have
parameter-dependent support for location family input.  Thus the
parameter <code class="reqn">\gamma</code> must be bounded such that the observed data is
within the theoretical support of the distribution.  This theoretical
bounds are determined by the Lambert W function (<code><a href="#topic+W">W</a></code>), which
has only real-valued solutions for <code class="reqn">z \geq -1 / \exp(1)</code>.  Thus,
<code><a href="#topic+W_gamma">W_gamma</a></code> has real-valued solutions only for <code class="reqn">z \geq -1 /
    \exp(1) \gamma</code> These lower and upper bounds are determined by minimum
and maxiumum of the normalized data <code class="reqn">\mathbf{z} = (\mathbf{y} -
    \mu_x) / \sigma_x</code>.
</p>


<h3>Value</h3>

<p><code>get_gamma_bounds</code> returns a vector of length 2 with
<code>"lower"</code> and <code>"upper"</code> bounds of <code class="reqn">\gamma</code> given the range
of <code>y</code>.
</p>

<hr>
<h2 id='get_input'>Back-transform Y to X</h2><span id='topic+get_input'></span><span id='topic+get.input'></span>

<h3>Description</h3>

<p><code>get_input</code> back-transforms the observed data <code class="reqn">\boldsymbol y</code> to the
(approximate) input data <code class="reqn">\boldsymbol x_{\tau}</code> using the
transformation vector <code class="reqn">\tau = (\mu_x(\boldsymbol \beta),
    \sigma_x(\boldsymbol \beta), \gamma, \alpha, \delta)</code>.
</p>
<p>Note that <code>get.input</code> should be deprecated; however, since it was
explicitly referenced in Goerg (2011) I keep it here for future
reference.  New code should use <code>get_input</code> exclusively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_input(y, tau, return.u = FALSE)

get.input(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_input_+3A_y">y</code></td>
<td>
<p>a numeric vector of data values or an object of class
<code>LambertW_fit</code>.</p>
</td></tr>
<tr><td><code id="get_input_+3A_tau">tau</code></td>
<td>
<p>named vector <code class="reqn">\tau</code> which defines the variable transformation.
Must have at least <code>'mu_x'</code> and <code>'sigma_x'</code> element; see
<code><a href="#topic+complete_tau">complete_tau</a></code> for details.</p>
</td></tr>
<tr><td><code id="get_input_+3A_return.u">return.u</code></td>
<td>
<p>should the normalized input be returned; default:
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="get_input_+3A_...">...</code></td>
<td>
<p>arguments passed to <code>get_input</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The (approximated) input data vector <code class="reqn">\widehat{\boldsymbol
x}_{\tau}</code>.
</p>
<p>For <code>gamma != 0</code> it uses the principal branch solution
<code><a href="#topic+W_gamma">W_gamma</a>(z, branch = 0)</code> to get a unique input. 
</p>
<p>For <code>gamma = 0</code> the back-transformation is bijective 
(for any <code class="reqn">\delta \geq 0, \alpha \geq 0</code>).
</p>
<p>If <code>return.u = TRUE</code>, then it returns a list with 2 vectors
</p>
<table>
<tr><td><code>u</code></td>
<td>
<p>centered and normalized input <code class="reqn">\widehat{\boldsymbol u}_{\theta}</code>,</p>
</td></tr> 
<tr><td><code>x</code></td>
<td>
<p>input data <code class="reqn">\widehat{\boldsymbol x}_{\theta}</code>.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+get_output">get_output</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(12)
# unskew very skewed data
y &lt;- rLambertW(n = 1000, theta = list(beta = c(0, 1), gamma = 0.3), 
               distname = "normal")
test_normality(y)
fit.gmm &lt;- IGMM(y, type="s")

x &lt;- get_input(y, fit.gmm$tau)
# the same as
x &lt;- get_input(fit.gmm)
test_normality(x) # symmetric Gaussian

</code></pre>

<hr>
<h2 id='get_output'>Transform input X to output Y</h2><span id='topic+get_output'></span>

<h3>Description</h3>

<p><code>get_output</code> transforms the input <code class="reqn">\boldsymbol x</code> to the observed
data <code class="reqn">\boldsymbol y</code> given the transformation vector <code class="reqn">\tau =
    (\mu_x(\boldsymbol \beta), \sigma_x(\boldsymbol \beta), \gamma, \alpha,
    \delta)</code>.
</p>
<p>This is the inverse of <code><a href="#topic+get_input">get_input</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_output(x, tau, return.z = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_output_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values.</p>
</td></tr>
<tr><td><code id="get_output_+3A_tau">tau</code></td>
<td>
<p>named vector <code class="reqn">\tau</code> which defines the variable transformation.
Must have at least <code>'mu_x'</code> and <code>'sigma_x'</code> element; see
<code><a href="#topic+complete_tau">complete_tau</a></code> for details.</p>
</td></tr>
<tr><td><code id="get_output_+3A_return.z">return.z</code></td>
<td>
<p>should the shifted and scaled output also be returned?
Default: <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric object of same size/dimension as input <code>x</code>.
</p>
<p>If <code>return.z = TRUE</code>, then it returns a list with 2 vectors
</p>
<table>
<tr><td><code>z</code></td>
<td>
<p>shifted and scaled input <code class="reqn">\boldsymbol z</code>, </p>
</td></tr> 
<tr><td><code>y</code></td>
<td>
<p>transformed output data <code class="reqn">\boldsymbol y</code>, which has a Lambert W
<code class="reqn">\times</code> F distribution.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+get_input">get_input</a></code>; <code><a href="#topic+Gaussianize">Gaussianize</a></code> with argument <code>inverse = TRUE</code>.
</p>

<hr>
<h2 id='get_support'>Computes support for skewed Lambert W x F distributions</h2><span id='topic+get_support'></span>

<h3>Description</h3>

<p>If the input <code class="reqn">X \sim F</code> has support on the entire real line
<code class="reqn">(-\infty, \infty)</code>, then the skewed Lambert W <code class="reqn">\times</code> F
distribution has truncated support <code class="reqn">[a,b]</code>, <code class="reqn">a,b \in R \cup \pm
    \infty</code> depending on <code class="reqn">\boldsymbol \beta</code> and (the sign of)
<code class="reqn">\gamma</code>.
</p>
<p>For scale-families no truncation occurs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_support(tau, is.non.negative = FALSE, input.bounds = c(-Inf, Inf))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_support_+3A_tau">tau</code></td>
<td>
<p>named vector <code class="reqn">\tau</code> which defines the variable transformation.
Must have at least <code>'mu_x'</code> and <code>'sigma_x'</code> element; see
<code><a href="#topic+complete_tau">complete_tau</a></code> for details.</p>
</td></tr>
<tr><td><code id="get_support_+3A_is.non.negative">is.non.negative</code></td>
<td>
<p>logical; by default it is set to <code>TRUE</code> if the
distribution is not a location but a scale family.</p>
</td></tr>
<tr><td><code id="get_support_+3A_input.bounds">input.bounds</code></td>
<td>
<p>interval; the bounds of the input distribution. If
<code>is.non.negative = FALSE</code>, then it will adjust it to <code>c(0,
Inf)</code>; also useful for bounded input distributions, such as
<code>"unif"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Half-open interval on the real line (if <code class="reqn">\gamma \neq 0</code>) for
input with support on the entire real line. For <code class="reqn">\gamma = 0</code> the
support of Y is the same as for X. Heavy-tail Lambert W RVs are not
affected by truncated support (for <code class="reqn">\delta \geq 0</code>); thus support is
<code>c(lower = -Inf, upper = Inf)</code>.
</p>


<h3>Value</h3>

<p>A vector of length 2 with names <code>'lower'</code> and <code>'upper'</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
get_support(c(mu_x = 0, sigma_x = 1, gamma = 0)) # as gamma = 0
# truncated on the left since gamma &gt; 0
get_support(c(mu_x = 0, sigma_x = 1, gamma = 0.1)) 

# no truncation for heavy tail(s)
get_support(c(mu_x = 0, sigma_x = 1, delta = 0.1))
</code></pre>

<hr>
<h2 id='H_gamma'>H transformation with gamma</h2><span id='topic+H_gamma'></span>

<h3>Description</h3>

<p>Skewed Lambert W<code class="reqn">\times</code> F RV transformation: <code class="reqn">H_{\gamma}(u) = u
    \exp(\gamma u)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>H_gamma(u, gamma = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="H_gamma_+3A_u">u</code></td>
<td>
<p>a numeric vector of real values.</p>
</td></tr>
<tr><td><code id="H_gamma_+3A_gamma">gamma</code></td>
<td>
<p>skewness parameter; default <code>gamma = 0</code>, which implies
<code>H_gamma(u) = u</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric; same dimension/size as <code>u</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+xexp">xexp</a></code>
</p>

<hr>
<h2 id='IGMM'>Iterative Generalized Method of Moments &ndash; IGMM</h2><span id='topic+IGMM'></span>

<h3>Description</h3>

<p>An iterative method of moments estimator to find this <code class="reqn">\tau = (\mu_x,
    \sigma_x, \gamma)</code> for <code>type = 's'</code> (<code class="reqn">\tau = (\mu_x, \sigma_x,
    \delta)</code> for <code>type = 'h'</code> or <code class="reqn">\tau = (\mu_x, \sigma_x, \delta_l,
    \delta_r)</code> for <code>type = "hh"</code>) which minimizes the distance between
the sample and theoretical skewness (or kurtosis) of <code class="reqn">\boldsymbol x</code>
and X.
</p>
<p>This algorithm is only well-defined for data with finite mean and variance
input X.  See <code><a href="#topic+analyze_convergence">analyze_convergence</a></code> and references therein
for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>IGMM(
  y,
  type = c("h", "hh", "s"),
  skewness.x = 0,
  kurtosis.x = 3,
  tau.init = get_initial_tau(y, type),
  robust = FALSE,
  tol = .Machine$double.eps^0.25,
  location.family = TRUE,
  not.negative = NULL,
  max.iter = 100,
  delta.lower = -1,
  delta.upper = 3
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="IGMM_+3A_y">y</code></td>
<td>
<p>a numeric vector of real values.</p>
</td></tr>
<tr><td><code id="IGMM_+3A_type">type</code></td>
<td>
<p>type of Lambert W <code class="reqn">\times</code> F distribution: skewed <code>"s"</code>;
heavy-tail <code>"h"</code>; or skewed heavy-tail <code>"hh"</code>.</p>
</td></tr>
<tr><td><code id="IGMM_+3A_skewness.x">skewness.x</code></td>
<td>
<p>theoretical skewness of input X; default <code>0</code>
(symmetric distribution).</p>
</td></tr>
<tr><td><code id="IGMM_+3A_kurtosis.x">kurtosis.x</code></td>
<td>
<p>theoretical kurtosis of input X; default <code>3</code> (Normal
distribution reference).</p>
</td></tr>
<tr><td><code id="IGMM_+3A_tau.init">tau.init</code></td>
<td>
<p>starting values for IGMM algorithm; default:
<code><a href="#topic+get_initial_tau">get_initial_tau</a></code>.  See also <code><a href="#topic+gamma_Taylor">gamma_Taylor</a></code> and
<code><a href="#topic+delta_Taylor">delta_Taylor</a></code>.</p>
</td></tr>
<tr><td><code id="IGMM_+3A_robust">robust</code></td>
<td>
<p>logical; only used for <code>type = "s"</code>. If <code>TRUE</code> a
robust estimate of asymmetry is used (see
<code><a href="#topic+medcouple_estimator">medcouple_estimator</a></code>); default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="IGMM_+3A_tol">tol</code></td>
<td>
<p>a positive scalar specifiying the tolerance level for terminating
the iterative algorithm. Default: <code>.Machine$double.eps^0.25</code></p>
</td></tr>
<tr><td><code id="IGMM_+3A_location.family">location.family</code></td>
<td>
<p>logical; tell the algorithm whether the underlying
input should have a location family distribution (for example, Gaussian
input); default: <code>TRUE</code>. If <code>FALSE</code> (e.g., for
<code>"exp"</code>onential input), then <code>tau['mu_x'] = 0</code> throughout the
optimization.</p>
</td></tr>
<tr><td><code id="IGMM_+3A_not.negative">not.negative</code></td>
<td>
<p>logical; if <code>TRUE</code>, the estimate for <code class="reqn">\gamma</code> or
<code class="reqn">\delta</code> is restricted to non-negative reals. If it is set to
<code>NULL</code> (default) then it will be set internally to <code>TRUE</code> for
heavy-tail(s) Lambert W<code class="reqn"> \times</code> F distributions (<code>type = "h"</code>
or <code>"hh"</code>).  For skewed Lambert W<code class="reqn"> \times</code> F (<code>type = "s"</code>)
it will be set to <code>FALSE</code>, unless it is not a location-scale family
(see <code><a href="#topic+get_distname_family">get_distname_family</a></code>).</p>
</td></tr>
<tr><td><code id="IGMM_+3A_max.iter">max.iter</code></td>
<td>
<p>maximum number of iterations; default: <code>100</code>.</p>
</td></tr>
<tr><td><code id="IGMM_+3A_delta.lower">delta.lower</code>, <code id="IGMM_+3A_delta.upper">delta.upper</code></td>
<td>
<p>lower and upper bound for
<code><a href="#topic+delta_GMM">delta_GMM</a></code> optimization.  By default: <code>-1</code> and <code>3</code>
which covers most real-world heavy-tail scenarios.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For algorithm details see the References.
</p>


<h3>Value</h3>

<p>A list of class <code>LambertW_fit</code>: 
</p>
<table>
<tr><td><code>tol</code></td>
<td>
<p>see Arguments</p>
</td></tr> 
<tr><td><code>data</code></td>
<td>
<p> data <code>y</code></p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p> number of observations</p>
</td></tr> 
<tr><td><code>type</code></td>
<td>
<p>see Arguments</p>
</td></tr> 
<tr><td><code>tau.init</code></td>
<td>
<p> starting values for <code class="reqn">\tau</code> </p>
</td></tr> 
<tr><td><code>tau</code></td>
<td>
<p> IGMM estimate for <code class="reqn">\tau</code> </p>
</td></tr>
<tr><td><code>tau.trace</code></td>
<td>
<p>entire iteration trace of <code class="reqn">\tau^{(k)}</code>, <code class="reqn">k = 0, ..., K</code>, where 
<code>K &lt;= max.iter</code>.</p>
</td></tr>
<tr><td><code>sub.iterations</code></td>
<td>
<p>number of iterations only performed in GMM algorithm to find optimal <code class="reqn">\gamma</code> (or <code class="reqn">\delta</code>)</p>
</td></tr> 
<tr><td><code>iterations</code></td>
<td>
<p>number of iterations to update <code class="reqn">\mu_x</code> and
<code class="reqn">\sigma_x</code>. See References for detals.</p>
</td></tr> 
<tr><td><code>hessian</code></td>
<td>
<p> Hessian matrix (obtained from simulations; see References)</p>
</td></tr> 
<tr><td><code>call</code></td>
<td>
<p>function call</p>
</td></tr>
<tr><td><code>skewness.x</code>, <code>kurtosis.x</code></td>
<td>
<p> see Arguments</p>
</td></tr> 
<tr><td><code>distname</code></td>
<td>
<p> a character string describing distribution characteristics given
the target theoretical skewness/kurtosis for the input. Same information as <code>skewness.x</code> and <code>kurtosis.x</code> but human-readable.</p>
</td></tr> 
<tr><td><code>location.family</code></td>
<td>
<p>see Arguments</p>
</td></tr> 
<tr><td><code>message</code></td>
<td>
<p>message from the optimization method. What kind of convergence?</p>
</td></tr> 
<tr><td><code>method</code></td>
<td>
<p>estimation method; here: <code>"IGMM"</code></p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Georg M. Goerg
</p>


<h3>See Also</h3>

<p><code><a href="#topic+delta_GMM">delta_GMM</a></code>, <code><a href="#topic+gamma_GMM">gamma_GMM</a></code>, <code><a href="#topic+analyze_convergence">analyze_convergence</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# estimate tau for the skewed version of a Normal
y &lt;- rLambertW(n = 100, theta = list(beta = c(2, 1), gamma = 0.2), 
               distname = "normal")
fity &lt;- IGMM(y, type = "s")
fity
summary(fity)
plot(fity)
## Not run: 
# estimate tau for the skewed version of an exponential
y &lt;- rLambertW(n = 100, theta = list(beta = 1, gamma = 0.5), 
               distname = "exp")
fity &lt;- IGMM(y, type = "s", skewness.x = 2, location.family = FALSE)
fity
summary(fity)
plot(fity)

# estimate theta for the heavy-tailed version of a Normal = Tukey's h
y &lt;- rLambertW(n = 100, theta = list(beta = c(2, 1), delta = 0.2), 
               distname = "normal")
system.time(
fity &lt;- IGMM(y, type = "h")
)
fity
summary(fity)
plot(fity)

## End(Not run)
</code></pre>

<hr>
<h2 id='ks_test_t'>One-sample Kolmogorov-Smirnov test for student-t distribution</h2><span id='topic+ks_test_t'></span>

<h3>Description</h3>

<p>Performs a two-sided KS test for <code class="reqn">H_0: X \sim t_{\nu}</code> with <code class="reqn">c</code>,
scale <code class="reqn">s</code>, and degrees of freedom <code class="reqn">\nu</code>. If parameters are not
specified, the MLE given the data will be used (see
<code><a href="MASS.html#topic+fitdistr">fitdistr</a></code>).
</p>
<p>For estimated parameters of the t-distribution the p-values are incorrect and
should be adjusted. See <code><a href="stats.html#topic+ks.test">ks.test</a></code> and the references
therein (Durbin (1973)).  As a more practical approach consider
bootstrapping and estimating the p-value empirically.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ks_test_t(x, param = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ks_test_t_+3A_x">x</code></td>
<td>
<p>a numeric vector of data values.</p>
</td></tr>
<tr><td><code id="ks_test_t_+3A_param">param</code></td>
<td>
<p>3-dimensional named vector <code>('location', 'scale', 'df')</code> 
which parametrizes the student t distribution. Default: <code>param = NULL</code>, 
in which case it will be estimated from <code>x</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>"htest"</code> containing:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the value of the Kolomogorv-Smirnov statistic.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the p-value for the test.</p>
</td></tr> 
<tr><td><code>alternative</code></td>
<td>
<p>a character string describing the alternative hypothesis.</p>
</td></tr> 
<tr><td><code>method</code></td>
<td>
<p>the character string &quot;One-sample Kolmogorov-Smirnov test
student-t&quot; plus rounded parameter values.</p>
</td></tr> 
<tr><td><code>data.name</code></td>
<td>
<p>a character string giving the name(s) of the data.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="MASS.html#topic+fitdistr">fitdistr</a></code>, <code><a href="stats.html#topic+ks.test">ks.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1021)
beta.true &lt;- c(location = 0, scale = 1, df = 4)
xx &lt;- rt(n = 1000, df = beta.true['df'])
ks_test_t(xx)
ks_test_t(xx, beta.true)

</code></pre>

<hr>
<h2 id='kurtosis'>Skewness and kurtosis</h2><span id='topic+kurtosis'></span><span id='topic+skewness'></span>

<h3>Description</h3>

<p><code>kurtosis</code> estimates the fourth central, normalized moment from data.
</p>
<p><code>skewness</code> estimates the third central, normalized moment from data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>kurtosis(x)

skewness(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kurtosis_+3A_x">x</code></td>
<td>
<p>a numeric vector.</p>
</td></tr>
</table>


<h3>See Also</h3>

<p>Corresponding functions in the <span class="pkg">moments</span> package.
</p>

<hr>
<h2 id='LambertW_fit-methods'>Methods for Lambert W<code class="reqn">\times</code> F estimates</h2><span id='topic+LambertW_fit-methods'></span><span id='topic+summary.LambertW_fit'></span><span id='topic+print.summary.LambertW_fit'></span><span id='topic+print.LambertW_fit'></span><span id='topic+plot.LambertW_fit'></span>

<h3>Description</h3>

<p>S3 methods (<code>print</code>, <code>plot</code>, <code>summary</code>, etc.) for
<code>LambertW_fit</code> class returned by the <code><a href="#topic+MLE_LambertW">MLE_LambertW</a></code> or
<code><a href="#topic+IGMM">IGMM</a></code> estimators.
</p>
<p><code>plot.LambertW_fit</code> plots a (1) histogram, (2) empirical density of the
data <code>y</code>. These are compared (3) to the theoretical <code class="reqn">F_X(x \mid
\widehat{\boldsymbol \beta})</code> and (4) Lambert W <code class="reqn">\times</code> 
<code class="reqn">F_X(y \mid \widehat{\boldsymbol \beta})</code> densities.
</p>
<p><code>print.LambertW_fit</code> prints only very basic information about
<code class="reqn">\widehat{\theta}</code> (to prevent an overload of data/information in the
console when executing an estimator).
</p>
<p><code>print.summary.LambertW_fit</code> tries to be smart about formatting the
coefficients, standard errors, etc. and also displays &quot;significance stars&quot; 
(like in the output of <code>summary.lm</code>).
</p>
<p><code>summary.LambertW_fit</code> computes some auxiliary results from
the estimate such as standard errors, theoretical support (only for
<code>type="s"</code>), skewness tests (only for <code>type="hh"</code>), etc.  See
<code>print.summary.LambertW_fit</code> for print out in the console.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LambertW_fit'
plot(x, xlim = NULL, show.qqplot = FALSE, ...)

## S3 method for class 'LambertW_fit'
print(x, ...)

## S3 method for class 'summary.LambertW_fit'
print(x, ...)

## S3 method for class 'LambertW_fit'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LambertW_fit-methods_+3A_x">x</code>, <code id="LambertW_fit-methods_+3A_object">object</code></td>
<td>
<p>object of class <code>LambertW_fit</code></p>
</td></tr>
<tr><td><code id="LambertW_fit-methods_+3A_xlim">xlim</code></td>
<td>
<p>lower and upper limit of x-axis for cdf and pdf plots.</p>
</td></tr>
<tr><td><code id="LambertW_fit-methods_+3A_show.qqplot">show.qqplot</code></td>
<td>
<p>should a Lambert W<code class="reqn"> \times</code> F QQ plot be displayed? Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="LambertW_fit-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>summary</code> returns a list of class <code>summary.LambertW_fit</code> 
containing 
</p>
<table>
<tr><td><code>call</code></td>
<td>
<p>function call</p>
</td></tr> 
<tr><td><code>coefmat</code></td>
<td>
<p>matrix with 4 columns: <code class="reqn">\widehat{\theta}</code>, its standard errors, t-statistic, and
two-sided p-values</p>
</td></tr> 
<tr><td><code>distname</code></td>
<td>
<p>see Arguments</p>
</td></tr>
<tr><td><code>n</code></td>
<td>
<p>number of observations</p>
</td></tr> 
<tr><td><code>data</code></td>
<td>
<p>original data (<code>y</code>)</p>
</td></tr> 
<tr><td><code>input</code></td>
<td>
<p>back-transformed input data</p>
</td></tr>
<tr><td><code>support</code></td>
<td>
<p>support of output random variable Y</p>
</td></tr>
<tr><td><code>data.range</code></td>
<td>
<p>empirical data range</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>estimation method</p>
</td></tr> 
<tr><td><code>hessian</code></td>
<td>
<p>Hessian at the optimum. Numerically obtained for <code>method = "MLE"</code>; 
for <code>method = "IGMM"</code> a diagonal-matrix approximation from covariance matrix
obtained by simulations for <code class="reqn">n = 1000</code> samples in Goerg (2011).</p>
</td></tr>
<tr><td><code>p_m1</code>, <code>p_m1n</code></td>
<td>
<p>Probability that one (or n) observation were caused by input 
from the non-principal branch (see <code><a href="#topic+p_m1">p_m1</a></code>); only for <code>type = "s"</code>.</p>
</td></tr>
<tr><td><code>symmetry.p.value</code></td>
<td>
<p>p-value from Wald test of identical left and right tail parameters (see
<code><a href="#topic+test_symmetry">test_symmetry</a></code>); only for <code>type = "hh"</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# See ?LambertW-package

</code></pre>

<hr>
<h2 id='LambertW_input_output-methods'>Methods for Lambert W input and output objects</h2><span id='topic+LambertW_input_output-methods'></span><span id='topic+print.LambertW_input'></span><span id='topic+plot.LambertW_input'></span><span id='topic+print.LambertW_output'></span><span id='topic+plot.LambertW_output'></span>

<h3>Description</h3>

<p>S3 methods for Lambert W input and output objects 
(created by <code><a href="#topic+create_LambertW_input">create_LambertW_input</a></code> and <code><a href="#topic+create_LambertW_output">create_LambertW_output</a></code>).
</p>
<p><code>plot.LambertW_input</code> plots the theoretical (1) pdf and (2) cdf of the
input <code class="reqn">X \sim F_X(x \mid \boldsymbol \beta)</code>.
</p>
<p><code>plot.LambertW_output</code> plots the theoretical (1) pdf and (2) cdf of the
output RV <code class="reqn">Y \sim</code> Lambert W <code class="reqn">\times</code> <code class="reqn">F_X(x \mid \boldsymbol
\beta)</code>. It overlays the plot with the pdf and cdf of the input RV <code class="reqn">X \sim F_X(x \mid
\boldsymbol \beta)</code> (setting <code class="reqn">\gamma = \delta = 0, \alpha = 1</code>).
</p>
<p><code>print.LambertW_input</code> prints an overview of the input object.
</p>
<p><code>print.LambertW_output</code> prints an overview of the output object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'LambertW_input'
plot(x, xlim = NULL, ...)

## S3 method for class 'LambertW_output'
plot(x, xlim = NULL, ...)

## S3 method for class 'LambertW_input'
print(x, ...)

## S3 method for class 'LambertW_output'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LambertW_input_output-methods_+3A_x">x</code></td>
<td>
<p>object of class <code>LambertW_input</code> or <code>LambertW_output</code>.</p>
</td></tr>
<tr><td><code id="LambertW_input_output-methods_+3A_xlim">xlim</code></td>
<td>
<p>lower and upper limit of x-axis for cdf and pdf plots. If <code>NULL</code>,
it tries to determine good limits based on the family type of the distribution
and the quantiles.  Most of the times it will show the pdf and cdf from the 0.5% to
99.5% quantile.</p>
</td></tr>
<tr><td><code id="LambertW_input_output-methods_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# create a Normal(1, 2) input
Gauss.input &lt;- create_LambertW_input("normal", beta = c(1, 2))
plot(Gauss.input)
# make it a bit heavy tailed (beta in theta comes from Gauss.input)
LW.Gauss &lt;- create_LambertW_output(LambertW.input = Gauss.input, 
                                   theta = list(delta = c(0.3)))
LW.Gauss  # print a nice overview in the console
plot(LW.Gauss)

# draw random sample
LW.Gauss$r(n=10)
Gauss.input$r(n=10)
# quantiles
LW.Gauss$q(p=0.6)
Gauss.input$q(p=0.6)

</code></pre>

<hr>
<h2 id='LambertW-toolkit'>Do-it-yourself toolkit for Lambert W<code class="reqn"> \times</code> F distribution</h2><span id='topic+LambertW-toolkit'></span><span id='topic+create_LambertW_input'></span><span id='topic+create_LambertW_output'></span>

<h3>Description</h3>

<p><strong>IMPORTANT:</strong> This toolkit functionality is still under active
development; function names, arguments, return values, etc. may change.
</p>
<p>This do-it-yourself Lambert W<code class="reqn"> \times</code> F toolkit implements the flexible
input/output framework of Lambert W <code class="reqn">\times</code> F random variables (see
References).  Using a modular approach, it allows users to create their
own Lambert W <code class="reqn">\times</code> 'MyFavoriteDistribution' RVs. See Details
below.
</p>
<p>If the distribution you inted to use is not already implemented
(<code><a href="#topic+get_distnames">get_distnames</a></code>), then you can create it:
</p>

<dl>
<dt>create input:</dt><dd><p>use <code><a href="#topic+create_LambertW_input">create_LambertW_input</a></code> with your
favorite distribution,</p>
</dd>
<dt>create output:</dt><dd><p>pass it as an input argument to <code><a href="#topic+create_LambertW_output">create_LambertW_output</a></code>,</p>
</dd>
<dt>use output:</dt><dd><p>use Rs standard functionality for distributions
such as random number generation (<code>rY</code>), pdf (<code>dY</code>) and cdf
(<code>pY</code>), quantile function (<code>qY</code>), etc. for this newly generated
Lambert W <code class="reqn">\times</code> 'MyFavoriteDistribution'.</p>
</dd>
</dl>

<p><code>create_LambertW_output</code> converts the input <code>LambertW_input</code>
representing random variable <code class="reqn">X \sim F_X</code> to the Lambert W
<code class="reqn">\times</code> <code class="reqn">F_X</code> output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_LambertW_input(
  distname = NULL,
  beta,
  input.u = list(beta2tau = NULL, d = NULL, p = NULL, r = NULL, q = NULL, distname =
    "MyFavoriteDistribution", is.non.negative = FALSE)
)

create_LambertW_output(
  LambertW.input = NULL,
  theta = NULL,
  distname = LambertW.input$distname
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LambertW-toolkit_+3A_distname">distname</code></td>
<td>
<p>character; name of input distribution; see
<code><a href="#topic+get_distnames">get_distnames</a></code>.</p>
</td></tr>
<tr><td><code id="LambertW-toolkit_+3A_beta">beta</code></td>
<td>
<p>numeric vector (deprecated); parameter <code class="reqn">\boldsymbol \beta</code> of
the input distribution.  See <code><a href="#topic+check_beta">check_beta</a></code> on how to specify
<code>beta</code> for each distribution.</p>
</td></tr>
<tr><td><code id="LambertW-toolkit_+3A_input.u">input.u</code></td>
<td>
<p>optional; users can make their own 'Lambert W x F'
distribution by supplying the necessary functions. See Description for
details.</p>
</td></tr>
<tr><td><code id="LambertW-toolkit_+3A_lambertw.input">LambertW.input</code></td>
<td>
<p>an object of class <code>LambertW_input</code></p>
</td></tr>
<tr><td><code id="LambertW-toolkit_+3A_theta">theta</code></td>
<td>
<p>list; a (possibly incomplete) list of parameters <code>alpha</code>,
<code>beta</code>, <code>gamma</code>, <code>delta</code>. <code><a href="#topic+complete_theta">complete_theta</a></code>
fills in default values for missing entries.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="#topic+create_LambertW_output">create_LambertW_output</a></code> takes an object of class
<code>LambertW_input</code> and creates a class <code>LambertW_output</code> for
standard distributions as well as the user-defined distribution. This
<code>LambertW_output</code> represents the RV Y <code class="reqn">\sim</code> Lambert W
<code class="reqn">\times</code> 'MyFavoriteDistribution' with all its properties and R
functionality, such as random number generation (<code>rY</code>), pdf
(<code>dY</code>) and cdf (<code>pY</code>), etc.
</p>
<p><code>create_LambertW_input</code> allows users to define their own Lambert
W<code class="reqn">\times</code> F distribution by supplying the necessary functions about
the input random variable <code class="reqn">U</code> and <code class="reqn">\boldsymbol \beta</code>.  Here
<code class="reqn">U</code> is the zero mean and/or unit variance version of <code class="reqn">X \sim
    F_X(x \mid \boldsymbol \beta)</code> (see References).
</p>
<p>The argument <code>input.u</code> must be a list containing all of the following:
</p>

<dl>
<dt><code>beta2tau</code></dt><dd><p> R function of <code>(beta)</code>: converts <code class="reqn">\boldsymbol \beta</code> to <code class="reqn">\tau</code> for the
user defined distribution </p>
</dd>
<dt><code>distname</code></dt><dd><p> optional; users can specify the name 
of their input distribution. By default it's called <code>"MyFavoriteDistribution"</code>. 
The distribution name will be used in plots and summaries of the Lambert W<code class="reqn">\times</code> F 
input (and output) object.</p>
</dd>
<dt><code>is.non.negative</code></dt><dd><p> logical; users should specify whether the
distribution is for non-negative random variables or not.  This will help
for plotting and theoretical quantile computation.</p>
</dd>
<dt><code>d</code></dt><dd><p> R function of <code>(u, beta)</code>: probability density function (pdf) of U,</p>
</dd>
<dt><code>p</code></dt><dd><p> R function of <code>(u, beta)</code>: cumulative distribution function (cdf) of U,</p>
</dd>
<dt><code>q</code></dt><dd><p> R function of <code>(p, beta)</code>: quantile function of U,</p>
</dd>
<dt><code>r</code></dt><dd><p> R function <code>(n, beta)</code>: random number generator for U,</p>
</dd>
</dl>



<h3>Value</h3>

<p><code>create_LambertW_output</code> returns a list of class <code>LambertW_output</code> 
with values that are (for the most part) functions themselves (see Examples): 
</p>
<table>
<tr><td><code>d</code></td>
<td>
<p> pdf of Y <code class="reqn">\sim</code> Lambert W <code class="reqn">\times</code> 'MyFavoriteDistribution',</p>
</td></tr> 
<tr><td><code>p</code></td>
<td>
<p> cdf of Y,</p>
</td></tr> 
<tr><td><code>q</code></td>
<td>
<p> quantile function for Y,</p>
</td></tr> 
<tr><td><code>r</code></td>
<td>
<p> random number generator for Y,</p>
</td></tr>
<tr><td><code>distname</code></td>
<td>
<p> character string with the name of the new distribution.
Format: &quot;Lambert W x 'MyFavoriteDistribution'&quot;,</p>
</td></tr> 
<tr><td><code>beta</code>, <code>theta</code></td>
<td>
<p>see Arguments,</p>
</td></tr>
<tr><td><code>distname.with.beta</code></td>
<td>
<p>name of the new distribution
including the parameter <code>beta</code>. Format: &quot;Lambert W x 'MyFavoriteDistribution'(beta)&quot;.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Georg M. Goerg
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# create a Gaussian N(1, 2) input
Gauss.input &lt;- create_LambertW_input("normal", beta = c(1, 2))

# create a heavy-tailed version of a normal
# gamma = 0, alpha = 1 are set by default; beta comes from input
params &lt;- list(delta = c(0.3)) 
LW.Gauss &lt;- create_LambertW_output(LambertW.input = Gauss.input, 
                                   theta = params)
LW.Gauss

op &lt;- par(no.readonly = TRUE)
par(mfrow = c(2, 1), mar = c(3, 3, 2, 1))
curve(LW.Gauss$d(x, params), -7, 10, col = "red")
# parameter will get detected automatically from the input
curve(LW.Gauss$d(x), -7, 10, col = "blue") # same in blue; 

# compare to the input case (i.e. set delta = 0)
params.0 &lt;- params 
params.0$delta &lt;- 0

# to evaluate the RV at a different parameter value, 
# it is necessary to pass the new parameter
curve(LW.Gauss$d(x, params.0), -7, 10, add = TRUE, col = 1) #' par(op)

curve(LW.Gauss$p(x, params), -7, 10, col = "red")
curve(LW.Gauss$p(x, params.0), -7, 10, add = TRUE, col = 1)

test_normality(LW.Gauss$r(n = 100), add.legend = FALSE)

## generate a positively skewed version of a shifted, scaled t_3
t.input &lt;- create_LambertW_input("t", beta = c(2, 1, 3))
t.input
params &lt;- list(gamma = 0.05) # skew it
LW.t &lt;- create_LambertW_output(LambertW.input = t.input, theta = params)
LW.t

plot(t.input$d, -7, 11, col = 1)
plot(LW.t$d, -7, 11, col = 2, add = TRUE)
abline(v = t.input$beta["location"], lty = 2)

# draw samples from the skewed t_3
yy &lt;- LW.t$r(n = 100)
test_normality(yy)

### create a skewed exponential distribution
exp.input &lt;- create_LambertW_input("exp", beta = 1)
plot(exp.input)
params &lt;- list(gamma = 0.2)
LW.exp &lt;- create_LambertW_output(exp.input, theta = params)
plot(LW.exp)

# create a heavy-tail exponential distribution
params &lt;- list(delta = 0.2)
LW.exp &lt;- create_LambertW_output(exp.input, theta = params)
plot(LW.exp)

# create a skewed chi-square distribution with 5 df
chi.input &lt;- create_LambertW_input("chisq", beta = 5)
plot(chi.input)
params &lt;- list(gamma = sqrt(2)*0.2)
LW.chi &lt;- create_LambertW_output(chi.input, theta = params)
plot(LW.chi)


# a demo on how a user-defined U input needs to look like
user.tmp &lt;- list(d = function(u, beta) dnorm(u),
                 r = function(n, beta) rnorm(n),
                 p = function(u, beta) pnorm(u),
                 q = function(p, beta) qnorm(p),
                 beta2tau = function(beta) {
                   c(mu_x = beta[1], sigma_x = beta[2], 
                     gamma = 0, alpha = 1, delta = 0)
                   },
                 distname = "MyNormal",
                 is.non.negative = FALSE)
my.input &lt;- create_LambertW_input(input.u = user.tmp, beta = c(0, 1))
my.input
plot(my.input)

</code></pre>

<hr>
<h2 id='LambertW-utils'>Utilities for Lambert W<code class="reqn"> \times</code> F Random Variables</h2><span id='topic+LambertW-utils'></span><span id='topic+dLambertW'></span><span id='topic+mLambertW'></span><span id='topic+pLambertW'></span><span id='topic+qLambertW'></span><span id='topic+qqLambertW'></span><span id='topic+rLambertW'></span>

<h3>Description</h3>

<p>Density, distribution, quantile function and random number generation for a
Lambert W <code class="reqn">\times</code> <code class="reqn">F_X(x \mid \boldsymbol \beta)</code> random
variable with parameter <code class="reqn">\theta = (\alpha, \boldsymbol \beta, \gamma,
    \delta)</code>.
</p>
<p>Following the usual R <code>dqpr</code> family of functions (e.g., <code>rnorm</code>,
<code>dnorm</code>, ...) the Lambert W<code class="reqn"> \times</code> F utility functions work as
expected: <code>dLambertW</code> evaluates the pdf at <code>y</code>,
<code>pLambertW</code> evaluates the cdf at <code>y</code>, <code>qLambertW</code> is the
quantile function, and <code>rLambertW</code> generates random samples from a
Lambert W <code class="reqn">\times</code> <code class="reqn">F_X(x \mid \boldsymbol \beta)</code> distribution.
</p>
<p><code>mLambertW</code> computes the first 4 central/standardized moments of a Lambert W
<code class="reqn">\times</code> F.  Works only for Gaussian distribution.
</p>
<p><code>qqLambertW</code> computes and plots the sample quantiles of the data
<code>y</code> versus the theoretical Lambert W <code class="reqn">\times</code> <code class="reqn">F</code> theoretical
quantiles given <code class="reqn">\theta</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dLambertW(
  y,
  distname = NULL,
  theta = NULL,
  beta = NULL,
  gamma = 0,
  delta = 0,
  alpha = 1,
  input.u = NULL,
  tau = NULL,
  use.mean.variance = TRUE,
  log = FALSE
)

mLambertW(
  theta = NULL,
  distname = c("normal"),
  beta,
  gamma = 0,
  delta = 0,
  alpha = 1
)

pLambertW(
  q,
  distname,
  theta = NULL,
  beta = NULL,
  gamma = 0,
  delta = 0,
  alpha = 1,
  input.u = NULL,
  tau = NULL,
  log = FALSE,
  lower.tail = FALSE,
  use.mean.variance = TRUE
)

qLambertW(
  p,
  distname = NULL,
  theta = NULL,
  beta = NULL,
  gamma = 0,
  delta = 0,
  alpha = 1,
  input.u = NULL,
  tau = NULL,
  is.non.negative = FALSE,
  use.mean.variance = TRUE
)

qqLambertW(
  y,
  distname,
  theta = NULL,
  beta = NULL,
  gamma = 0,
  delta = 0,
  alpha = 1,
  plot.it = TRUE,
  use.mean.variance = TRUE,
  ...
)

rLambertW(
  n,
  distname,
  theta = NULL,
  beta = NULL,
  gamma = 0,
  delta = 0,
  alpha = 1,
  return.x = FALSE,
  input.u = NULL,
  tau = NULL,
  use.mean.variance = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="LambertW-utils_+3A_y">y</code>, <code id="LambertW-utils_+3A_q">q</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="LambertW-utils_+3A_distname">distname</code></td>
<td>
<p>character; name of input distribution; see
<code><a href="#topic+get_distnames">get_distnames</a></code>.</p>
</td></tr>
<tr><td><code id="LambertW-utils_+3A_theta">theta</code></td>
<td>
<p>list; a (possibly incomplete) list of parameters <code>alpha</code>,
<code>beta</code>, <code>gamma</code>, <code>delta</code>. <code><a href="#topic+complete_theta">complete_theta</a></code>
fills in default values for missing entries.</p>
</td></tr>
<tr><td><code id="LambertW-utils_+3A_beta">beta</code></td>
<td>
<p>numeric vector (deprecated); parameter <code class="reqn">\boldsymbol \beta</code> of
the input distribution.  See <code><a href="#topic+check_beta">check_beta</a></code> on how to specify
<code>beta</code> for each distribution.</p>
</td></tr>
<tr><td><code id="LambertW-utils_+3A_gamma">gamma</code></td>
<td>
<p>scalar (deprecated); skewness parameter; default: <code>0</code>.</p>
</td></tr>
<tr><td><code id="LambertW-utils_+3A_delta">delta</code></td>
<td>
<p>scalar or vector (length 2) (deprecated); heavy-tail
parameter(s); default: <code>0</code>.</p>
</td></tr>
<tr><td><code id="LambertW-utils_+3A_alpha">alpha</code></td>
<td>
<p>scalar or vector (length 2) (deprecated); heavy tail
exponent(s); default: <code>1</code>.</p>
</td></tr>
<tr><td><code id="LambertW-utils_+3A_input.u">input.u</code></td>
<td>
<p>users can supply their own version of U (either a vector of
simulated values or a function defining the pdf/cdf/quanitle function of
U); default: <code>NULL</code>. If not <code>NULL</code>, <code>tau</code> must be
specified as well.</p>
</td></tr>
<tr><td><code id="LambertW-utils_+3A_tau">tau</code></td>
<td>
<p>optional; if <code>input.u = TRUE</code>, then <code>tau</code> must be
specified.  Note that <code class="reqn">\boldsymbol \beta</code> is still taken from
<code>theta</code>, but <code>"mu_x"</code>, <code>"sigma_x"</code>, and the other
parameters (<code class="reqn">\alpha, \gamma, \delta</code>) are all taken from <code>tau</code>.
This is usually only used by the <code><a href="#topic+create_LambertW_output">create_LambertW_output</a></code>
function; users usually don't need to supply this argument directly.</p>
</td></tr>
<tr><td><code id="LambertW-utils_+3A_use.mean.variance">use.mean.variance</code></td>
<td>
<p>logical; if <code>TRUE</code> it uses mean and variance
implied by <code class="reqn">\boldsymbol \beta</code> to do the transformation (Goerg 2011).
If <code>FALSE</code>, it uses the alternative definition from Goerg (2016)
with location and scale parameter.</p>
</td></tr>
<tr><td><code id="LambertW-utils_+3A_log">log</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities p are given as log(p).</p>
</td></tr>
<tr><td><code id="LambertW-utils_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default), probabilities are
<code class="reqn">P(X \leq x)</code> otherwise, <code class="reqn">P(X &gt; x)</code>.</p>
</td></tr>
<tr><td><code id="LambertW-utils_+3A_p">p</code></td>
<td>
<p>vector of probability levels</p>
</td></tr>
<tr><td><code id="LambertW-utils_+3A_is.non.negative">is.non.negative</code></td>
<td>
<p>logical; by default it is set to <code>TRUE</code> if the
distribution is not a location but a scale family.</p>
</td></tr>
<tr><td><code id="LambertW-utils_+3A_plot.it">plot.it</code></td>
<td>
<p>logical; should the result be plotted? Default: <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="LambertW-utils_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
<tr><td><code id="LambertW-utils_+3A_n">n</code></td>
<td>
<p>number of observations</p>
</td></tr>
<tr><td><code id="LambertW-utils_+3A_return.x">return.x</code></td>
<td>
<p>logical; if <code>TRUE</code> not only the simulated Lambert W<code class="reqn">
\times</code> F sample <code>y</code>, but also the corresponding simulated input
<code>x</code> will be returned.  Default <code>FALSE</code>. <strong>Note:</strong> if
<code>TRUE</code> then <code>rLambertW</code> does not return a vector of length
<code>n</code>, but a list of two vectors (each of length <code>n</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All functions here have an optional <code>input.u</code> argument where users can
supply their own version corresponding to zero-mean, unit variance input
<code class="reqn">U</code>.  This function usually depends on the input parameter
<code class="reqn">\boldsymbol \beta</code>; e.g., users can pass their own density function
<code>dmydist &lt;- function(u, beta) {...}</code> as <code>dLambertW(..., input.u
    = dmydist)</code>.  <code>dLambertW</code> will then use this function to evaluate
the pdf of the Lambert W x 'mydist' distribution.
</p>
<p><strong>Important:</strong> Make sure that all <code>input.u</code> in <code>dLambertW</code>,
<code>pLambertW</code>, ... are supplied correctly and return correct values &ndash;
there are no unit-tests or sanity checks for user-defined functions.
</p>
<p>See the references for the analytic expressions of the pdf and cdf.  For
<code>"h"</code> or <code>"hh"</code> types and for scale-families of <code>type =
    "s"</code> quantiles can be computed analytically.  For location (-scale)
families of <code>type = "s"</code> quantiles need to be computed numerically.
</p>


<h3>Value</h3>

<p><code>mLambertW</code> returns a list with the 4 theoretical
(central/standardized) moments of <code class="reqn">Y</code> implied by <code class="reqn">\boldsymbol \theta</code>
and <code>distname</code> (currrently, this only works for
<code>distname = "normal"</code>):
</p>
<table>
<tr><td><code>mean</code></td>
<td>
<p>mean,</p>
</td></tr> 
<tr><td><code>sd</code></td>
<td>
<p>standard deviation,</p>
</td></tr> 
<tr><td><code>skewness</code></td>
<td>
<p>skewness,</p>
</td></tr>
<tr><td><code>kurtosis</code></td>
<td>
<p>kurtosis (not excess kurtosis, i.e., 3 for a Gaussian).</p>
</td></tr>
</table>
<p><code>rLambertW</code> returns a vector of length <code>n</code>. If <code>return.input =
TRUE</code>, then it returns a list of two vectors (each of length <code>n</code>):
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>simulated input,</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>Lambert W random sample (transformed from <code>x</code> - 
see References and <code><a href="#topic+get_output">get_output</a></code>).</p>
</td></tr>
</table>
<p><code>qqLambertW</code> returns a list of 2 vectors (analogous to <code>qqnorm</code>): 
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>theoretical quantiles (sorted),</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>empirical quantiles (sorted).</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
###############################
######### mLambertW ###########
mLambertW(theta = list(beta = c(0, 1), gamma = 0.1))
mLambertW(theta = list(beta = c(1, 1), gamma = 0.1)) # mean shifted by 1
mLambertW(theta = list(beta = c(0, 1), gamma = 0)) # N(0, 1)

###############################
######### rLambertW ###########
set.seed(1)
# same as rnorm(1000)
x &lt;- rLambertW(n=100, theta = list(beta=c(0, 1)), distname = "normal") 
skewness(x) # very small skewness
medcouple_estimator(x) # also close to zero

y &lt;- rLambertW(n=100, theta = list(beta = c(1, 3), gamma = 0.1), 
               distname = "normal")
skewness(y) # high positive skewness (in theory equal to 3.70)
medcouple_estimator(y) # also the robust measure gives a high value

op &lt;- par(no.readonly=TRUE)
par(mfrow = c(2, 2), mar = c(2, 4, 3, 1))
plot(x)
hist(x, prob=TRUE, 15)
lines(density(x))

plot(y)
hist(y, prob=TRUE, 15)
lines(density(y))
par(op)
###############################
######### dLambertW ###########
beta.s &lt;- c(0, 1)
gamma.s &lt;- 0.1

# x11(width=10, height=5)
par(mfrow = c(1, 2), mar = c(3, 3, 3, 1))
curve(dLambertW(x, theta = list(beta = beta.s, gamma = gamma.s), 
                distname = "normal"),
     -3.5, 5, ylab = "",  main="Density function")
plot(dnorm, -3.5, 5, add = TRUE, lty = 2)
legend("topright" , c("Lambert W x Gaussian" , "Gaussian"), lty = 1:2)
abline(h=0)

###############################
######### pLambertW ###########

curve(pLambertW(x, theta = list(beta = beta.s, gamma = gamma.s),
                distname = "normal"),
      -3.5, 3.5, ylab = "", main = "Distribution function")
plot(pnorm, -3.5,3.5, add = TRUE, lty = 2)
legend("topleft" , c("Lambert W x Gaussian" , "Gaussian"), lty = 1:2)
par(op)

######## Animation 
## Not run: 
gamma.v &lt;- seq(-0.15, 0.15, length = 31) # typical, empirical range of gamma
b &lt;- get_support(gamma_01(min(gamma.v)))[2]*1.1
a &lt;- get_support(gamma_01(max(gamma.v)))[1]*1.1

for (ii in seq_along(gamma.v)) {
  curve(dLambertW(x, beta = gamma_01(gamma.v[ii])[c("mu_x", "sigma_x")], 
                  gamma = gamma.v[ii], distname="normal"),
        a, b, ylab="", lty = 2, col = 2, lwd = 2, main = "pdf", 
        ylim = c(0, 0.45))
  plot(dnorm, a, b, add = TRUE, lty = 1, lwd = 2)
  legend("topright" , c("Lambert W x Gaussian" , "Gaussian"), 
         lty = 2:1, lwd = 2, col = 2:1)
  abline(h=0)
  legend("topleft", cex = 1.3, 
         c(as.expression(bquote(gamma == .(round(gamma.v[ii],3))))))
Sys.sleep(0.04)
}

## End(Not run)

###############################
######### qLambertW ###########

p.v &lt;- c(0.01, 0.05, 0.5, 0.9, 0.95,0.99)
qnorm(p.v)
# same as above except for rounding errors
qLambertW(p.v, theta = list(beta = c(0, 1), gamma = 0), distname = "normal") 
# positively skewed data -&gt; quantiles are higher
qLambertW(p.v, theta = list(beta = c(0, 1), gamma = 0.1),
          distname = "normal")

###############################
######### qqLambertW ##########
## Not run: 
y &lt;- rLambertW(n=500, distname="normal", 
               theta = list(beta = c(0,1), gamma = 0.1))

layout(matrix(1:2, ncol = 2))
qqnorm(y)
qqline(y)
qqLambertW(y, theta = list(beta = c(0, 1), gamma = 0.1), 
           distname = "normal") 

## End(Not run)
</code></pre>

<hr>
<h2 id='loglik-LambertW-utils'>Log-Likelihood for Lambert W<code class="reqn">\times</code> F RVs</h2><span id='topic+loglik-LambertW-utils'></span><span id='topic+loglik_LambertW'></span><span id='topic+loglik_input'></span><span id='topic+loglik_penalty'></span>

<h3>Description</h3>

<p>Evaluates the log-likelihood for <code class="reqn">\theta</code> given observations <code>y</code>.
</p>
<p><code>loglik_LambertW</code> computes the log-likelihood of <code class="reqn">\theta</code>
for a Lambert W <code class="reqn">\times</code> F distribution given observations <code>y</code>.
</p>
<p><code>loglik_input</code> computes the log-likelihood of various distributions for 
the parameter <code class="reqn">\boldsymbol \beta</code> given the data <code>x</code>. This can be 
used independently of the Lambert W x F framework to compute 
the log-likelihood of parameters for common distributions.
</p>
<p><code>loglik_penalty</code> computes the penalty for transforming the
data back to the input (see Goerg 2016). This penalty is independent of
the distribution specified by <code>distname</code>, but only depends on
<code class="reqn">\tau</code>. If <code>type = "s"</code> then the penalty term exists if the
distribution is non-negative (see <code>get_distname_family</code>) and
<code>gamma &gt;= 0</code>; otherwise, it returns <code>NA</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loglik_LambertW(
  theta,
  y,
  distname,
  type,
  return.negative = FALSE,
  flattened.theta.names = names(theta),
  use.mean.variance = TRUE
)

loglik_input(
  beta,
  x,
  distname,
  dX = NULL,
  log.dX = function(x, beta) log(dX(x, beta))
)

loglik_penalty(tau, y, type = c("h", "hh", "s"), is.non.negative = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="loglik-LambertW-utils_+3A_theta">theta</code></td>
<td>
<p>list; a (possibly incomplete) list of parameters <code>alpha</code>,
<code>beta</code>, <code>gamma</code>, <code>delta</code>. <code><a href="#topic+complete_theta">complete_theta</a></code>
fills in default values for missing entries.</p>
</td></tr>
<tr><td><code id="loglik-LambertW-utils_+3A_y">y</code></td>
<td>
<p>a numeric vector of real values (the observed data).</p>
</td></tr>
<tr><td><code id="loglik-LambertW-utils_+3A_distname">distname</code></td>
<td>
<p>character; name of input distribution; see
<code><a href="#topic+get_distnames">get_distnames</a></code>.</p>
</td></tr>
<tr><td><code id="loglik-LambertW-utils_+3A_type">type</code></td>
<td>
<p>type of Lambert W <code class="reqn">\times</code> F distribution: skewed <code>"s"</code>;
heavy-tail <code>"h"</code>; or skewed heavy-tail <code>"hh"</code>.</p>
</td></tr>
<tr><td><code id="loglik-LambertW-utils_+3A_return.negative">return.negative</code></td>
<td>
<p>logical; if <code>TRUE</code> it returns the negative
log-likelihood as a scalar (which is useful for numerical
<em>minimization</em> algorithms for <em>maximum</em> likelihood estimation);
otherwise it returns a list of input log-likelihood, penalty, and their
sum = full likelihood. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="loglik-LambertW-utils_+3A_flattened.theta.names">flattened.theta.names</code></td>
<td>
<p>vector of strings with names of flattened
<code>theta</code>; this is necessary for optimization functions since they
drop the names of a vector, but all functions in this package use names
to select elements of (the flattened) <code>theta</code>.</p>
</td></tr>
<tr><td><code id="loglik-LambertW-utils_+3A_use.mean.variance">use.mean.variance</code></td>
<td>
<p>logical; if <code>TRUE</code> it uses mean and variance
implied by <code class="reqn">\boldsymbol \beta</code> to do the transformation (Goerg 2011).
If <code>FALSE</code>, it uses the alternative definition from Goerg (2016)
with location and scale parameter.</p>
</td></tr>
<tr><td><code id="loglik-LambertW-utils_+3A_beta">beta</code></td>
<td>
<p>numeric vector (deprecated); parameter <code class="reqn">\boldsymbol \beta</code> of
the input distribution.  See <code><a href="#topic+check_beta">check_beta</a></code> on how to specify
<code>beta</code> for each distribution.</p>
</td></tr>
<tr><td><code id="loglik-LambertW-utils_+3A_x">x</code></td>
<td>
<p>a numeric vector of real values (the <em>input</em> data).</p>
</td></tr>
<tr><td><code id="loglik-LambertW-utils_+3A_dx">dX</code></td>
<td>
<p>optional; density function of <code>x</code>. Common distributions are
already built-in (see <code>distname</code>). If you want to supply your own
density, you <strong>must</strong> supply a function of <code>(x, beta)</code> and set
<code>distname = "user"</code>.</p>
</td></tr>
<tr><td><code id="loglik-LambertW-utils_+3A_log.dx">log.dX</code></td>
<td>
<p>optional; a function that returns the logarithm of the density
function of <code>x</code>. Often &ndash; in particular for exponential families &ndash;
the <code class="reqn">\log</code> of <code class="reqn">f_X(x)</code> has a simpler form (and is thus faster to
evaluate).</p>
</td></tr>
<tr><td><code id="loglik-LambertW-utils_+3A_tau">tau</code></td>
<td>
<p>named vector <code class="reqn">\tau</code> which defines the variable transformation.
Must have at least <code>'mu_x'</code> and <code>'sigma_x'</code> element; see
<code><a href="#topic+complete_tau">complete_tau</a></code> for details.</p>
</td></tr>
<tr><td><code id="loglik-LambertW-utils_+3A_is.non.negative">is.non.negative</code></td>
<td>
<p>logical; by default it is set to <code>TRUE</code> if the
distribution is not a location but a scale family.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For heavy-tail Lambert W<code class="reqn">\times</code> F distributions (<code>type = "h"</code> or
<code>type = "hh"</code>) the log-likelihood decomposes into an input
log-likelihood plus a penalty term for transforming the data.
</p>
<p>For skewed Lambert W <code class="reqn">\times</code> F distributions this decomposition only
exists for non-negative input RVs (e.g., <code>"exp"</code>onential,
<code>"gamma"</code>, <code>"f"</code>, ...). If negative values are possible
(<code>"normal"</code>, <code>"t"</code>, <code>"unif"</code>, <code>"cauchy"</code>, ...)
then <code>loglik_input</code> and <code>loglik_penalty</code> return <code>NA</code>, but
the value of the output log-likelihood will still be returned correctly
as <code>loglik.LambertW</code>.
</p>
<p>See Goerg (2016) for details on the decomposition of the log-likelihood into
a log-likelihood on the input parameters plus a penalty term for
transforming the data.
</p>


<h3>Value</h3>

<p><code>loglik_input</code> and <code>loglik_penalty</code> return a scalar;
<code>loglik_LambertW</code> returns a list with 3 values:
</p>
<table>
<tr><td><code>loglik.input</code></td>
<td>
<p> loglikelihood of <code>beta</code> given the transformed data,</p>
</td></tr> 
<tr><td><code>loglik.penalty</code></td>
<td>
<p> penalty for transforming the data,</p>
</td></tr> 
<tr><td><code>loglik.LambertW</code></td>
<td>
<p> total log-likelihood of <code>theta</code> given the observed data; 
if the former two values exist this is simply their sum.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>set.seed(1)
yy &lt;- rLambertW(n = 1000, distname = "normal", 
                theta = list(beta = c(0, 1), delta = 0.2))
loglik_penalty(tau = theta2tau(list(beta = c(1, 1), delta = c(0.2, 0.2)),
                               distname = "normal"), 
               y = yy, type = "hh")
# For a type = 's' Lambert W x F distribution with location family input
# such a decomposition doesn't exist; thus NA.
loglik_penalty(tau = theta2tau(list(beta = c(1, 1), gamma = 0.03), 
                               distname = "normal"),
               is.non.negative = FALSE,
               y = yy, type = "s") 
# For scale-family input it does exist
loglik_penalty(tau = theta2tau(list(beta = 1, gamma = 0.01), 
                               distname = "exp"),
               is.non.negative = TRUE,
               y = yy, type = "s") 
               
# evaluating the Gaussian log-likelihood
loglik_input(beta = c(0, 1), x = yy, distname = "normal") # built-in version
# or pass your own log pdf function
loglik_input(beta = c(0, 1), x = yy, distname = "user", 
             log.dX = function(xx, beta = beta) { 
                dnorm(xx, mean = beta[1], sd = beta[2], log = TRUE)
             })
## Not run: 
# you must specify distname = 'user'; otherwise it does not work
loglik_input(beta = c(0, 1), x = yy, distname = "mydist", 
             log.dX = function(xx, beta = beta) { 
                dnorm(xx, mean = beta[1], sd = beta[2], log = TRUE)
                })

## End(Not run)

### loglik_LambertW returns all three values
loglik_LambertW(theta = list(beta = c(1, 1), delta = c(0.09, 0.07)), 
                y = yy, type = "hh", distname ="normal")

# can also take a flattend vector; must provide names though for delta
loglik_LambertW(theta = flatten_theta(list(beta = c(1, 1), 
                                          delta = c(delta_l = 0.09, 
                                                    delta_r = 0.07))), 
                y = yy, type = "hh", distname ="normal")

</code></pre>

<hr>
<h2 id='lp_norm'>lp norm of a vector</h2><span id='topic+lp_norm'></span>

<h3>Description</h3>

<p>Computes the <code class="reqn">\ell^p</code> norm of an n-dimensional (real/complex) 
vector <code class="reqn">\mathbf{x} \in \mathbf{C}^n</code>
</p>
<p style="text-align: center;"><code class="reqn"> \left|\left| \mathbf{x} \right|\right|_p = \left( \sum_{i=1}^n
\left| x_i \right|^p \right)^{1/p}, p \in [0, \infty],</code>
</p>

<p>where <code class="reqn">\left| x_i \right|</code> is the absolute value of <code class="reqn">x_i</code>.  For
<code class="reqn">p=2</code> this is Euclidean norm; for <code class="reqn">p=1</code> it is Manhattan norm. For
<code class="reqn">p=0</code> it is defined as the number of non-zero elements in
<code class="reqn">\mathbf{x}</code>; for <code class="reqn">p = \infty</code> it is the maximum of the absolute
values of <code class="reqn">\mathbf{x}</code>.
</p>
<p>The norm of <code class="reqn">\mathbf{x}</code> equals <code class="reqn">0</code> if and only if <code class="reqn">\mathbf{x} =
    \mathbf{0}</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lp_norm(x, p = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lp_norm_+3A_x">x</code></td>
<td>
<p>n-dimensional vector (possibly complex values)</p>
</td></tr>
<tr><td><code id="lp_norm_+3A_p">p</code></td>
<td>
<p>which norm? Allowed values <code class="reqn">p \geq 0</code> including <code>Inf</code>. 
Default: <code>2</code> (Euclidean norm).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Non-negative float, the norm of <code class="reqn">\mathbf{x}</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
kRealVec &lt;- c(3, 4)
# Pythagoras
lp_norm(kRealVec)
# did not know Manhattan,
lp_norm(kRealVec, p = 1)

# so he just imagined running in circles.
kComplexVec &lt;- exp(1i * runif(20, -pi, pi))
plot(kComplexVec)
sapply(kComplexVec, lp_norm)

</code></pre>

<hr>
<h2 id='medcouple_estimator'>MedCouple Estimator</h2><span id='topic+medcouple_estimator'></span>

<h3>Description</h3>

<p>A robust measure of asymmetry. See References for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>medcouple_estimator(x, seed = sample.int(1e+06, 1))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="medcouple_estimator_+3A_x">x</code></td>
<td>
<p>numeric vector; if length &gt; 3,000, it uses a random subsample
(otherwise it takes too long to compute as calculations are of order
<code class="reqn">N^2</code>.)</p>
</td></tr>
<tr><td><code id="medcouple_estimator_+3A_seed">seed</code></td>
<td>
<p>numeric; seed used for sampling (when <code>length(x) &gt;
3000</code>).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>float; measures the degree of asymmetry
</p>


<h3>References</h3>

<p>Brys, G., M. Hubert, and A. Struyf (2004). &ldquo;A robust
measure of skewness&rdquo;. Journal of Computational and Graphical Statistics
13 (4), 996 - 1017.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+test_symmetry">test_symmetry</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# a simulation
kNumSim &lt;- 100
kNumObs &lt;- 200

################# Gaussian (Symmetric) #### 
A &lt;- t(replicate(kNumSim, {xx &lt;- rnorm(kNumObs); c(skewness(xx), medcouple_estimator(xx))}))
########### skewed LambertW x Gaussian #### 
tau.s &lt;- gamma_01(0.2) # zero mean, unit variance, but positive skewness
rbind(mLambertW(theta = list(beta = tau.s[c("mu_x", "sigma_x")], 
                             gamma = tau.s["gamma"]), 
                distname="normal"))
B &lt;- t(replicate(kNumSim, 
                 {
                   xx &lt;- rLambertW(n = kNumObs, 
                                   theta = list(beta = tau.s[c("mu_x", "sigma_x")], 
                                                gamma = tau.s["gamma"]), 
                                   distname="normal")
                   c(skewness(xx), medcouple_estimator(xx))
                 }))
                  
colnames(A) &lt;- colnames(B) &lt;- c("MedCouple", "Pearson Skewness")

layout(matrix(1:4, ncol = 2))
plot(A, main = "Gaussian")
boxplot(A)
abline(h = 0)

plot(B, main = "Skewed Lambert W x Gaussian")
boxplot(B)
abline(h = mLambertW(theta = list(beta = tau.s[c("mu_x", "sigma_x")], 
                                  gamma = tau.s["gamma"]), 
                     distname="normal")["skewness"])

colMeans(A)
apply(A, 2, sd)

colMeans(B)
apply(B, 2, sd)

</code></pre>

<hr>
<h2 id='MLE_LambertW'>Maximum Likelihood Estimation for Lambert W<code class="reqn"> \times</code> F distributions</h2><span id='topic+MLE_LambertW'></span>

<h3>Description</h3>

<p>Maximum Likelihood Estimation (MLE) for Lambert W <code class="reqn">\times F</code>
distributions computes <code class="reqn">\widehat{\theta}_{MLE}</code>.
</p>
<p>For <code>type = "s"</code>, the skewness parameter <code class="reqn">\gamma</code> is estimated and
<code class="reqn">\delta = 0</code> is held fixed; for <code>type = "h"</code> the one-dimensional
<code class="reqn">\delta</code> is estimated and <code class="reqn">\gamma = 0</code> is held fixed; and for
<code>type = "hh"</code> the 2-dimensional <code class="reqn">\delta</code> is estimated and
<code class="reqn">\gamma = 0</code> is held fixed.
</p>
<p>By default <code class="reqn">\alpha = 1</code> is fixed for any <code>type</code>. If you want to
also estimate <code class="reqn">\alpha</code> (for <code>type = "h"</code> or <code>"hh"</code>) 
set <code>theta.fixed = list()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MLE_LambertW(
  y,
  distname,
  type = c("h", "s", "hh"),
  theta.fixed = list(alpha = 1),
  use.mean.variance = TRUE,
  theta.init = get_initial_theta(y, distname = distname, type = type, theta.fixed =
    theta.fixed, use.mean.variance = use.mean.variance, method = "IGMM"),
  hessian = TRUE,
  return.estimate.only = FALSE,
  optim.fct = c("optim", "nlm", "solnp"),
  not.negative = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MLE_LambertW_+3A_y">y</code></td>
<td>
<p>a numeric vector of real values.</p>
</td></tr>
<tr><td><code id="MLE_LambertW_+3A_distname">distname</code></td>
<td>
<p>character; name of input distribution; see
<code><a href="#topic+get_distnames">get_distnames</a></code>.</p>
</td></tr>
<tr><td><code id="MLE_LambertW_+3A_type">type</code></td>
<td>
<p>type of Lambert W <code class="reqn">\times</code> F distribution: skewed <code>"s"</code>;
heavy-tail <code>"h"</code>; or skewed heavy-tail <code>"hh"</code>.</p>
</td></tr>
<tr><td><code id="MLE_LambertW_+3A_theta.fixed">theta.fixed</code></td>
<td>
<p>a list of fixed parameters in the optimization; default
only <code>alpha = 1</code>.</p>
</td></tr>
<tr><td><code id="MLE_LambertW_+3A_use.mean.variance">use.mean.variance</code></td>
<td>
<p>logical; if <code>TRUE</code> it uses mean and variance
implied by <code class="reqn">\boldsymbol \beta</code> to do the transformation (Goerg 2011).
If <code>FALSE</code>, it uses the alternative definition from Goerg (2016)
with location and scale parameter.</p>
</td></tr>
<tr><td><code id="MLE_LambertW_+3A_theta.init">theta.init</code></td>
<td>
<p>a list containing the starting values of <code class="reqn">(\alpha,
\boldsymbol \beta, \gamma, \delta)</code> for the numerical optimization;
default: see <code><a href="#topic+get_initial_theta">get_initial_theta</a></code>.</p>
</td></tr>
<tr><td><code id="MLE_LambertW_+3A_hessian">hessian</code></td>
<td>
<p>indicator for returning the (numerically obtained) Hessian at
the optimum; default: <code>TRUE</code>. If the <span class="pkg">numDeriv</span> package is
available it uses <code>numDeriv::hessian()</code>; otherwise
<code>stats::optim(..., hessian = TRUE)</code>.</p>
</td></tr>
<tr><td><code id="MLE_LambertW_+3A_return.estimate.only">return.estimate.only</code></td>
<td>
<p>logical; if <code>TRUE</code>, only a named flattened
vector of <code class="reqn">\widehat{\theta}_{MLE}</code> will be returned (only the
estimated, non-fixed values). This is useful for simulations where it is
usually not necessary to give a nicely organized output, but only the
estimated parameter. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="MLE_LambertW_+3A_optim.fct">optim.fct</code></td>
<td>
<p>character; which R optimization function should be
used. Either <code>'optim'</code> (default), <code>'nlm'</code>, or <code>'solnp'</code>
from the <span class="pkg">Rsolnp</span> package (if available).  Note that if <code>'nlm'</code>
is used, then <code>not.negative = TRUE</code> will be set automatically.</p>
</td></tr>
<tr><td><code id="MLE_LambertW_+3A_not.negative">not.negative</code></td>
<td>
<p>logical; if <code>TRUE</code>, it restricts <code>delta</code> or
<code>gamma</code> to the non-negative reals. See <code><a href="#topic+theta2unbounded">theta2unbounded</a></code>
for details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>LambertW_fit</code>:
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p> data <code>y</code>,</p>
</td></tr>
<tr><td><code>loglik</code></td>
<td>
<p>scalar; log-likelihood evaluated at the optimum
<code class="reqn">\widehat{\theta}_{MLE}</code>,</p>
</td></tr> 
<tr><td><code>theta.init</code></td>
<td>
<p>list; starting values for numerical optimization,</p>
</td></tr> 
<tr><td><code>beta</code></td>
<td>
<p> estimated <code class="reqn">\boldsymbol \beta</code> vector of the input distribution via Lambert W MLE (In general this is not exactly identical to <code class="reqn">\widehat{\boldsymbol \beta}_{MLE}</code> for the input data), </p>
</td></tr> 
<tr><td><code>theta</code></td>
<td>
<p>list; MLE for <code class="reqn">\theta</code>, </p>
</td></tr> 
<tr><td><code>type</code></td>
<td>
<p>see Arguments,</p>
</td></tr> 
<tr><td><code>hessian</code></td>
<td>
<p>Hessian matrix; used to calculate standard errors (only if <code>hessian = TRUE</code>, 
otherwise <code>NULL</code>),</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>function call,</p>
</td></tr> 
<tr><td><code>distname</code></td>
<td>
<p>see Arguments,</p>
</td></tr> 
<tr><td><code>message</code></td>
<td>
<p>message from the optimization method. What kind of convergence?,</p>
</td></tr> 
<tr><td><code>method</code></td>
<td>
<p>estimation method; here <code>"MLE"</code>.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
# See ?LambertW-package

</code></pre>

<hr>
<h2 id='p_m1'>Non-principal branch probability</h2><span id='topic+p_m1'></span>

<h3>Description</h3>

<p>Computes the probability that (at least) one (out of n)
observation(s) of the latent variable <code class="reqn">U</code> lies in the non-principal
branch region. The '<code>m1</code>' in <code>p_m1</code> stands for 'minus 1', i.e,
the non-principal branch.
</p>
<p>See Goerg (2011) and Details for mathematical derivations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>p_m1(gamma, beta, distname, n = 1, use.mean.variance = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="p_m1_+3A_gamma">gamma</code></td>
<td>
<p>scalar; skewness parameter.</p>
</td></tr>
<tr><td><code id="p_m1_+3A_beta">beta</code></td>
<td>
<p>numeric vector (deprecated); parameter <code class="reqn">\boldsymbol \beta</code> of
the input distribution.  See <code><a href="#topic+check_beta">check_beta</a></code> on how to specify
<code>beta</code> for each distribution.</p>
</td></tr>
<tr><td><code id="p_m1_+3A_distname">distname</code></td>
<td>
<p>character; name of input distribution; see
<code><a href="#topic+get_distnames">get_distnames</a></code>.</p>
</td></tr>
<tr><td><code id="p_m1_+3A_n">n</code></td>
<td>
<p>number of RVs/observations.</p>
</td></tr>
<tr><td><code id="p_m1_+3A_use.mean.variance">use.mean.variance</code></td>
<td>
<p>logical; if <code>TRUE</code> it uses mean and variance
implied by <code class="reqn">\boldsymbol \beta</code> to do the transformation (Goerg 2011).
If <code>FALSE</code>, it uses the alternative definition from Goerg (2016)
with location and scale parameter.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The probability that one observation of the latent RV U lies in the
non-principal region equals at most </p>
<p style="text-align: center;"><code class="reqn"> p_{-1}(\gamma, n=1)
= P\left(U &lt; -\frac{1}{|\gamma|}\right), </code>
</p>
<p> where <code class="reqn">U</code> is the zero-mean,
unit variance version of the input <code class="reqn">X \sim F_X(x \mid \boldsymbol
\beta)</code> &ndash; see References.
</p>
<p>For <code class="reqn">N</code> independent RVs <code class="reqn">U_1, \ldots, U_N</code>, the probability that at
least one data point came from the non-principal region equals
</p>
<p style="text-align: center;"><code class="reqn">
p_{-1}(\gamma, n=N) = P\left(U_i &lt; -\frac{1}{|\gamma|} \; for \; at \;
least \; one \; i \right) </code>
</p>
 
<p>This equals (assuming independence) 
</p>
<p style="text-align: center;"><code class="reqn"> P\left(U_i &lt; -\frac{1}{|\gamma|} \; for \; at
\; least \; one \; i \right) = 1 - P\left(U_i \geq -\frac{1}{|\gamma|},
\forall i \right) = 1 - \prod_{i=1}^{N} P\left(U_i \geq -\frac{1}{|\gamma|}
\right) </code>
</p>
 <p style="text-align: center;"><code class="reqn"> = 1 - \prod_{i=1}^{N} \left(1 - p_{-1}(\gamma, n=1) \right)
= 1 - (1-p_{-1}(\gamma, n=1))^N. </code>
</p>

<p>For improved numerical stability the cdf of a geometric RV
(<code><a href="stats.html#topic+pgeom">pgeom</a></code>) is used to evaluate the last
expression. Nevertheless, numerical problems can occur for <code class="reqn">|\gamma| &lt;
0.03</code> (returns <code>0</code> due to rounding errors).
</p>
<p>Note that <code class="reqn">1 - (1-p_{-1}(\gamma, n=1))^N</code> reduces to <code class="reqn">p_{-1}(\gamma)</code>
for <code class="reqn">N=1</code>.
</p>


<h3>Value</h3>

<p>non-negative float; the probability <code class="reqn">p_{-1}</code> for <code>n</code> observations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
beta.01 &lt;- c(mu = 0, sigma = 1)
# for n=1 observation
p_m1(0, beta = beta.01, distname = "normal") # identical to 0
# in theory != 0; but machine precision too low
p_m1(0.01, beta = beta.01, distname = "normal") 
p_m1(0.05, beta = beta.01, distname = "normal") # extremely small
p_m1(0.1, beta = beta.01, distname = "normal") # != 0, but very small
# 1 out of 4 samples is a non-principal input;
p_m1(1.5, beta = beta.01, distname = "normal") 
# however, gamma=1.5 is not common in practice

# for n=100 observations
p_m1(0, n=100, beta = beta.01, distname = "normal") # == 0
p_m1(0.1, n=100, beta = beta.01, distname = "normal") # still small
p_m1(0.3, n=100, beta = beta.01, distname = "normal") # a bit more likely
p_m1(1.5, n=100, beta = beta.01, distname = "normal") 
# Here we can be almost 100% sure (rounding errors) that at least one
# y_i was caused by an input in the non-principal branch.

</code></pre>

<hr>
<h2 id='tau-utils'>Utilities for transformation vector tau</h2><span id='topic+tau-utils'></span><span id='topic+check_tau'></span><span id='topic+tau2theta'></span><span id='topic+complete_tau'></span><span id='topic+get_initial_tau'></span><span id='topic+tau2type'></span><span id='topic+normalize_by_tau'></span>

<h3>Description</h3>

<p>All functions here are for the transformation parameter vector
<code class="reqn">\tau = (\mu_x, \sigma_x, \gamma, \delta, \alpha)</code>.
</p>
<p><code>check_tau</code> checks if <code class="reqn">\tau</code> is correctly specified (correct names, non-negativity
constraints, etc.)
</p>
<p><code>complete_tau</code> completes missing values so users don't have to specify
every element of <code class="reqn">\tau</code> explicitly. <code>'mu_x'</code> and
<code>'sigma_x'</code> must be specified, but <code>alpha = 1</code>, <code>gamma =
    0</code>, and <code>delta = 0</code> will be set automatically if missing.
</p>
<p><code>get_initial_tau</code> provides starting estimates for <code class="reqn">\tau</code>.
</p>
<p><code>normalize_by_tau</code> shifts and scales data given the <code>tau</code> vector as
</p>
<p style="text-align: center;"><code class="reqn">(data - \mu_x) / \sigma_x.</code>
</p>

<p>Parameters <code class="reqn">\mu_x</code> and <code class="reqn">\sigma_x</code> are not necessarily mean and
standard deviation in the <code class="reqn">\tau</code> vector; that depends on the family
type and <code>use.mean.variance</code> (for location families they usually are
mean and standard deviation if <code>use.mean.variance = TRUE</code>; for scale
and non-location non-scale families they are just location/scale
parameters for the transformation).
</p>
<p><code>tau2theta</code> converts <code class="reqn">\tau</code> to the parameter list <code class="reqn">\theta</code> 
(inverse of <code><a href="#topic+theta2tau">theta2tau</a></code>).
</p>
<p><code>tau2type</code> guesses the type (<code>'s'</code>, <code>'h'</code>, <code>'hh'</code>) from the names
of <code>tau</code> vector; thus make sure <code>tau</code> is named correctly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_tau(tau)

complete_tau(tau, type = tau2type(tau))

get_initial_tau(y, type = c("h", "hh", "s"), location.family = TRUE)

normalize_by_tau(data, tau, inverse = FALSE)

tau2theta(tau, beta)

tau2type(tau)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="tau-utils_+3A_tau">tau</code></td>
<td>
<p>named vector <code class="reqn">\tau</code> which defines the variable transformation.
Must have at least <code>'mu_x'</code> and <code>'sigma_x'</code> element; see
<code><a href="#topic+complete_tau">complete_tau</a></code> for details.</p>
</td></tr>
<tr><td><code id="tau-utils_+3A_type">type</code></td>
<td>
<p>type of Lambert W <code class="reqn">\times</code> F distribution: skewed <code>"s"</code>;
heavy-tail <code>"h"</code>; or skewed heavy-tail <code>"hh"</code>.</p>
</td></tr>
<tr><td><code id="tau-utils_+3A_y">y</code></td>
<td>
<p>a numeric vector of real values (the observed data).</p>
</td></tr>
<tr><td><code id="tau-utils_+3A_location.family">location.family</code></td>
<td>
<p>logical; if <code>FALSE</code> it sets <code>mu_x</code> to 0 and only estimates 
<code>sigma_x</code>; if <code>TRUE</code> (default), it estimates <code>mu_x</code> as well.</p>
</td></tr>
<tr><td><code id="tau-utils_+3A_data">data</code></td>
<td>
<p>numeric; a numeric object in R.  Usually this is either 
<code>y</code> or <code>x</code> (or <code>z</code> and <code>u</code> if <code>inverse = TRUE</code>.)</p>
</td></tr>
<tr><td><code id="tau-utils_+3A_inverse">inverse</code></td>
<td>
<p>logical; if <code>TRUE</code> it applies the inverse transformation
<code class="reqn">data \cdot \sigma_x + \mu_x</code></p>
</td></tr>
<tr><td><code id="tau-utils_+3A_beta">beta</code></td>
<td>
<p>numeric vector (deprecated); parameter <code class="reqn">\boldsymbol \beta</code> of
the input distribution.  See <code><a href="#topic+check_beta">check_beta</a></code> on how to specify
<code>beta</code> for each distribution.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>check_tau</code> throws an error if <code class="reqn">\tau</code> does not define a proper
transformation.
</p>
<p><code>complete_tau</code> returns a named numeric vector.
</p>
<p><code>get_initial_tau</code> returns a named numeric vector.
</p>
<p><code>tau2theta</code> returns a list with entries <code>alpha</code>, <code>beta</code>,
<code>gamma</code>, and <code>delta</code>.
</p>
<p><code>tau2type</code> returns a string: either <code>"s"</code>, <code>"h"</code>, or
<code>"hh"</code>.
</p>

<hr>
<h2 id='test_normality'>Visual and statistical Gaussianity check</h2><span id='topic+test_normality'></span><span id='topic+test_norm'></span>

<h3>Description</h3>

<p>Graphical and statistical check if data is Gaussian (three common Normality
tests, QQ-plots, histograms, etc).
</p>
<p><code>test_normality</code> does not show the autocorrelation function (ACF)
estimate for lag <code class="reqn">0</code>, since it always equals <code class="reqn">1</code>. Thus removing it
does not lose any information, but greatly improves the y-axis scale for
higher order lags (which are usually very small compared to 1).
</p>
<p><code>test_norm</code> is a shortcut for <code>test_normality</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_normality(
  data,
  show.volatility = FALSE,
  plot = TRUE,
  pch = 1,
  add.legend = TRUE,
  seed = sample(1e+06, 1)
)

test_norm(...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_normality_+3A_data">data</code></td>
<td>
<p>a numeric vector of data values.</p>
</td></tr>
<tr><td><code id="test_normality_+3A_show.volatility">show.volatility</code></td>
<td>
<p>logical; if <code>TRUE</code> the squared (centered) data
and its ACF are also shown. Useful for time series data to see if squares
exhibit dependence (for financial data they typically do); default:
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="test_normality_+3A_plot">plot</code></td>
<td>
<p>Should visual checks (histogram, densities, qqplot, ACF) be
plotted?  Default <code>TRUE</code>; otherwise only hypothesis test results are
returned.</p>
</td></tr>
<tr><td><code id="test_normality_+3A_pch">pch</code></td>
<td>
<p>a vector of plotting characters or symbols; default <code>pch =
1</code>.</p>
</td></tr>
<tr><td><code id="test_normality_+3A_add.legend">add.legend</code></td>
<td>
<p>logical; if <code>TRUE</code> (default) a legend is placed in
histogram/density plot.</p>
</td></tr>
<tr><td><code id="test_normality_+3A_seed">seed</code></td>
<td>
<p>optional; if sample size &gt; 5,000, then some normality tests fail
to run.  In this case it uses a subsample of size 5,000.  For
reproducibility, the seed can be specified by user.  By default it uses a
random seed.</p>
</td></tr>
<tr><td><code id="test_normality_+3A_...">...</code></td>
<td>
<p>arguments as in <code>test_normality</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list with results of 3 normality tests (each of class <code>htest</code>)
and the seed used for subsampling: </p>
<table>
<tr><td><code>anderson.darling</code></td>
<td>
<p>Anderson
Darling (if <span class="pkg">nortest</span> package is available),</p>
</td></tr>
<tr><td><code>shapiro.francia</code></td>
<td>
<p>Shapiro-Francia (if <span class="pkg">nortest</span> package is
available),</p>
</td></tr> <tr><td><code>shapiro.wilk</code></td>
<td>
<p>Shapiro-Wilk,</p>
</td></tr> <tr><td><code>seed</code></td>
<td>
<p>seed for
subsampling (only used if sample size &gt; 5,000).</p>
</td></tr>
</table>


<h3>References</h3>

<p>Thode Jr., H.C. (2002): &ldquo;Testing for Normality&rdquo;. Marcel
Dekker, New York.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+shapiro.test">shapiro.test</a></code> in the <span class="pkg">stats</span> package;
<code><a href="nortest.html#topic+ad.test">ad.test</a></code>, <code><a href="nortest.html#topic+sf.test">sf.test</a></code> in the
<span class="pkg">nortest</span> package.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
y &lt;- rLambertW(n = 1000, theta = list(beta = c(3, 4), gamma = 0.3),
               distname = "normal")
test_normality(y)

x &lt;- rnorm(n = 1000)
test_normality(x)

# mixture of exponential and normal
test_normality(c(rexp(100), rnorm(100, mean = -5)))

</code></pre>

<hr>
<h2 id='test_symmetry'>Test symmetry based on Lambert W heavy tail(s)</h2><span id='topic+test_symmetry'></span>

<h3>Description</h3>

<p>Performs a test for the null hypothesis of symmetry, <code class="reqn">H_0: \delta_l =
\delta_r</code>, versus the alternative of asymmetry. This can be done using a Wald
test of the linear restriction <code class="reqn">H_0: \delta_l - \delta_r = 0</code> or a
likelihood ratio test.
</p>
<p>By default it uses <code>"Wald"</code> test since this only requires the Hessian of
the <code>"hh"</code> Lambert W fit.  The <code>"LR"</code> test requires the
log-likelihood values for both MLEs (type <code>"h"</code> and <code>"hh"</code>) and
thus takes longer to compute.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>test_symmetry(LambertW.fit, method = c("Wald", "LR"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="test_symmetry_+3A_lambertw.fit">LambertW.fit</code></td>
<td>
<p>an object of class <code>LambertW_fit</code> with <code>type =
"hh"</code> or a numeric vector (observed data). If it is data, then an
asymmetric Lambert W <code class="reqn">\times</code> Gaussian distribution (<code>distname =
"normal"</code>) with two tail parameters (<code>"hh"</code>) will be fit to the data
internally and then used as the new <code>LambertW.fit</code>.</p>
</td></tr>
<tr><td><code id="test_symmetry_+3A_method">method</code></td>
<td>
<p>test methodology: <code>"Wald"</code> (default) or a likelihood ratio
<code>"LR"</code> test</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of class <code>"htest"</code> containing: </p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>value of
the test statistic,</p>
</td></tr> <tr><td><code>p.value</code></td>
<td>
<p>p-value for the test,</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>character string describing the test,</p>
</td></tr> <tr><td><code>data.name</code></td>
<td>
<p>a
character string giving the name(s) of the data.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
# skewed
yy &lt;- rLambertW(n = 500, theta = list(delta = c(0.1, 0.25), beta = c(2, 1)), 
                distname = "normal")
fit.ml &lt;- MLE_LambertW(yy, type = "hh", distname = "normal", 
                       hessian = TRUE)
summary(fit.ml)
test_symmetry(fit.ml, "LR")
test_symmetry(fit.ml, "Wald")

# symmetric 
yy &lt;- rLambertW(n = 500, theta = list(delta = c(0.2, 0.2), beta = c(2, 1)), 
                distname = "normal")
fit.ml &lt;- MLE_LambertW(yy, type = "hh", distname = "normal")
summary(fit.ml)
test_symmetry(fit.ml, "LR")
test_symmetry(fit.ml, "Wald")

## End(Not run)
</code></pre>

<hr>
<h2 id='theta-utils'>Utilities for the parameter vector of Lambert W<code class="reqn">\times</code> F distributions</h2><span id='topic+theta-utils'></span><span id='topic+check_theta'></span><span id='topic+complete_theta'></span><span id='topic+flatten_theta'></span><span id='topic+get_initial_theta'></span><span id='topic+get_theta_bounds'></span><span id='topic+theta2tau'></span><span id='topic+theta2unbounded'></span><span id='topic+unflatten_theta'></span>

<h3>Description</h3>

<p>These functions work with <code class="reqn">\boldsymbol \theta = (\boldsymbol \beta, \gamma, \delta, \alpha)</code>,
which fully parametrizes Lambert W<code class="reqn">\times</code> F distributions.
</p>
<p>See Details for more background information on some functions.
</p>
<p><code>check_theta</code> checks if <code class="reqn">\theta = (\alpha, \boldsymbol \beta, \gamma, \delta)</code>
describes a well-defined Lambert W distribution.
</p>
<p><code>complete_theta</code> completes missing values in a parameters list so users
don't have to specify everything in detail. If not supplied, then
<code>alpha = 1</code>, <code>gamma = 0</code>, and <code>delta = 0</code> will be set by default.
</p>
<p><code>flatten_theta</code> and <code>unflatten_theta</code> convert between the list 
<code>theta</code> and its vector-style flattened type.  The flattened version is required
for several optimization routines, since they optimize over multivariate vectors &ndash; not lists.
</p>
<p><code>get_initial_theta</code> provides initial estimates for <code class="reqn">\alpha</code>,
<code class="reqn">\boldsymbol \beta</code>, <code class="reqn">\gamma</code>, and <code class="reqn">\delta</code>, which are then
used in maximum likelihood (ML) estimation (<code><a href="#topic+MLE_LambertW">MLE_LambertW</a></code>).
</p>
<p><code>get_theta_bounds</code> returns lower and upper bounds for <code class="reqn">\theta</code> 
(necessary for optimization such as <code><a href="#topic+MLE_LambertW">MLE_LambertW</a></code>).
</p>
<p><code>theta2tau</code> converts <code class="reqn">\theta</code> to the transformation vector 
<code class="reqn">\tau = (\mu_x, \sigma_x, \gamma, \delta, \alpha)</code>.
</p>
<p><code>theta2unbounded</code> transforms <code class="reqn">\theta</code> from the bounded space to an 
unrestricted space (by <code class="reqn">\log</code>-transformation on 
<code class="reqn">\sigma_x</code>, <code class="reqn">\delta</code>, and <code class="reqn">\alpha</code>; note that this restricts
<code class="reqn">\gamma \geq 0</code>, <code class="reqn">\delta \geq 0</code>, and <code class="reqn">\alpha \geq 0</code>.).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_theta(theta, distname)

complete_theta(theta = list(), LambertW.input = NULL)

flatten_theta(theta)

get_initial_theta(
  y,
  distname,
  type = c("h", "hh", "s"),
  theta.fixed = list(alpha = 1),
  method = c("Taylor", "IGMM"),
  use.mean.variance = TRUE
)

get_theta_bounds(
  distname,
  beta,
  type = c("s", "h", "hh"),
  not.negative = FALSE
)

theta2tau(theta = list(beta = c(0, 1)), distname, use.mean.variance = TRUE)

theta2unbounded(theta, distname, type = c("h", "hh", "s"), inverse = FALSE)

unflatten_theta(theta.flattened, distname, type)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="theta-utils_+3A_theta">theta</code></td>
<td>
<p>list; a (possibly incomplete) list of parameters <code>alpha</code>,
<code>beta</code>, <code>gamma</code>, <code>delta</code>. <code><a href="#topic+complete_theta">complete_theta</a></code>
fills in default values for missing entries.</p>
</td></tr>
<tr><td><code id="theta-utils_+3A_distname">distname</code></td>
<td>
<p>character; name of input distribution; see
<code><a href="#topic+get_distnames">get_distnames</a></code>.</p>
</td></tr>
<tr><td><code id="theta-utils_+3A_lambertw.input">LambertW.input</code></td>
<td>
<p>optional; if <code>beta</code> is missing in <code>theta</code>,
<code>LambertW.input</code> (which has a <code>beta</code> element) must be specified.</p>
</td></tr>
<tr><td><code id="theta-utils_+3A_y">y</code></td>
<td>
<p>a numeric vector of real values (the observed data).</p>
</td></tr>
<tr><td><code id="theta-utils_+3A_type">type</code></td>
<td>
<p>type of Lambert W <code class="reqn">\times</code> F distribution: skewed <code>"s"</code>;
heavy-tail <code>"h"</code>; or skewed heavy-tail <code>"hh"</code>.</p>
</td></tr>
<tr><td><code id="theta-utils_+3A_theta.fixed">theta.fixed</code></td>
<td>
<p>list; fixed parameters for the optimization; default:
<code>alpha = 1</code>.</p>
</td></tr>
<tr><td><code id="theta-utils_+3A_method">method</code></td>
<td>
<p>character; should a fast <code>"Taylor"</code> (default)
approximation be used (<code><a href="#topic+delta_Taylor">delta_Taylor</a></code> or
<code><a href="#topic+gamma_Taylor">gamma_Taylor</a></code>) to estimate <code class="reqn">\delta</code> or <code class="reqn">\gamma</code>, or
should <code>"IGMM"</code> (<code><a href="#topic+IGMM">IGMM</a></code>) estimates be used.  Use
<code>"Taylor"</code> as initial values for <code><a href="#topic+IGMM">IGMM</a></code>;
<code><a href="#topic+IGMM">IGMM</a></code> improves upon it and should be used for
<code><a href="#topic+MLE_LambertW">MLE_LambertW</a></code>.  Do <strong>not</strong> use <code>"IGMM"</code> as initial
values for <code><a href="#topic+IGMM">IGMM</a></code> &ndash; this will run <code><a href="#topic+IGMM">IGMM</a></code> twice.</p>
</td></tr>
<tr><td><code id="theta-utils_+3A_use.mean.variance">use.mean.variance</code></td>
<td>
<p>logical; if <code>TRUE</code> it uses mean and variance
implied by <code class="reqn">\boldsymbol \beta</code> to do the transformation (Goerg 2011).
If <code>FALSE</code>, it uses the alternative definition from Goerg (2016)
with location and scale parameter.</p>
</td></tr>
<tr><td><code id="theta-utils_+3A_beta">beta</code></td>
<td>
<p>numeric vector (deprecated); parameter <code class="reqn">\boldsymbol \beta</code> of
the input distribution.  See <code><a href="#topic+check_beta">check_beta</a></code> on how to specify
<code>beta</code> for each distribution.</p>
</td></tr>
<tr><td><code id="theta-utils_+3A_not.negative">not.negative</code></td>
<td>
<p>logical; if <code>TRUE</code> it sets the lower bounds for <code>alpha</code>
and <code>delta</code> to <code>0</code>.  Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="theta-utils_+3A_inverse">inverse</code></td>
<td>
<p>logical; if <code>TRUE</code>, it transforms the unbounded
<code>theta</code> back to the original, bounded space. Default: <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="theta-utils_+3A_theta.flattened">theta.flattened</code></td>
<td>
<p>named vector; flattened version of list <code>theta</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>get_initial_theta</code> obtains a quick initial estimate of <code class="reqn">\theta</code> by
first finding the (approximate) input <code class="reqn">\widehat{\boldsymbol
    x}_{\widehat{\theta}}</code> by <code><a href="#topic+IGMM">IGMM</a></code>, and then estimating
<code class="reqn">\boldsymbol \beta</code> for this input data <code class="reqn">\widehat{\boldsymbol
    x}_{\widehat{\theta}} \sim F_X(x \mid \boldsymbol \beta)</code> (see
<code><a href="#topic+estimate_beta">estimate_beta</a></code>).
</p>
<p>Converting <code>theta</code> to an unbounded space is especially useful
for optimization routines (like <code><a href="stats.html#topic+nlm">nlm</a></code>), which can be
performed over an unconstrained space. The obtained optimum can be
converted back to the original space using the inverse transformation
(set <code>inverse = TRUE</code> transforms it via <code class="reqn">\exp</code>) &ndash; this
guarantees that the estimate satisfies non-negativity constraints (if
required). The main advantage is that this avoids using optimization
routines with boundary constraints &ndash; since they are much slower compared
to unconstrained optimization.
</p>


<h3>Value</h3>

<p><code>check_theta</code> throws an error if list <code>theta</code> does not
define a proper Lambert W <code class="reqn">\times</code> F distribution; 
does nothing otherwise.
</p>
<p><code>complete_theta</code> returns a list containing:
</p>
<table>
<tr><td><code>alpha</code></td>
<td>
<p> heavy tail exponent(s),</p>
</td></tr>
<tr><td><code>beta</code></td>
<td>
<p> named vector <code class="reqn">\boldsymbol \beta</code> of the input distribution, </p>
</td></tr>
<tr><td><code>gamma</code></td>
<td>
<p> skewness parameter,</p>
</td></tr> 
<tr><td><code>delta</code></td>
<td>
<p> heavy-tail parameter(s).</p>
</td></tr>
</table>
<p><code>get_initial_theta</code> returns a list containing:
</p>
<table>
<tr><td><code>alpha</code></td>
<td>
<p> heavy tail exponent; default: <code>1</code>, </p>
</td></tr> 
<tr><td><code>beta</code></td>
<td>
<p> named vector <code class="reqn">\boldsymbol \beta</code> of the input distribution; 
estimated from the recovered input data <code class="reqn">\widehat{\mathbf{x}}_{\widehat{\tau}}</code>, </p>
</td></tr> 
<tr><td><code>gamma</code></td>
<td>
<p> skewness parameter; if <code>type</code> is <code>"h"</code> or <code>"hh"</code> <code>gamma = 0</code>;
estimated from <code><a href="#topic+IGMM">IGMM</a></code>, </p>
</td></tr> 
<tr><td><code>delta</code></td>
<td>
<p> heavy-tail parameter;
estimated from <code><a href="#topic+IGMM">IGMM</a></code>. If <code>type = "s"</code>, then <code>delta = 0</code>. </p>
</td></tr>
</table>
<p><code>get_theta_bounds</code> returns a list containing two vectors:
</p>
<table>
<tr><td><code>lower</code></td>
<td>
<p> flattened vector of lower bounds for valid <code class="reqn">\theta</code>, </p>
</td></tr>
<tr><td><code>upper</code></td>
<td>
<p> flattened vector of upper bounds for valid <code class="reqn">\theta</code>. </p>
</td></tr>
</table>


<h3>See Also</h3>

<p><code><a href="#topic+check_beta">check_beta</a></code>
</p>
<p><code><a href="#topic+estimate_beta">estimate_beta</a></code>, <code><a href="#topic+get_initial_tau">get_initial_tau</a></code>
</p>
<p><code><a href="#topic+beta2tau">beta2tau</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## Not run: 
check_theta(theta = list(beta =  c(1, 1, -1)), distname = "t")

## End(Not run)

check_theta(theta = list(beta =  c(1, 1)), distname = "normal") # ok

params &lt;- list(beta = c(2, 1), delta = 0.3) # alpha and gamma are missing
complete_theta(params) # added default values

params &lt;- list(beta = c(2, 1), delta = 0.3, alpha = c(1, 2))
params &lt;- complete_theta(params)
check_theta(params, distname = 'normal')

###
x &lt;- rnorm(1000)
get_initial_theta(x, distname = "normal", type = "h")
get_initial_theta(x, distname = "normal", type = "s")

# starting values for the skewed version of an exponential
y &lt;- rLambertW(n = 1000, distname = "exp", theta=list(beta = 2, gamma = 0.1))
get_initial_theta(y, distname = "exp", type = "s")

# starting values for the heavy-tailed version of a Normal = Tukey's h
y &lt;- rLambertW(n = 1000, distname="normal", theta=list(beta = c(2, 1), delta = 0.2))
get_initial_theta(y, distname = "normal", type = "h")#' 

###
get_theta_bounds(type = "hh", distname = "normal", beta = c(0, 1))

### 
theta.restr &lt;- theta2unbounded(list(beta = c(-1, 0.1), 
                                    delta = c(0.2, 0.2)), 
                                    distname = "normal")
theta.restr
# returns again the beta and delta from above
theta2unbounded(theta.restr, inverse = TRUE, distname = "normal") 

</code></pre>

<hr>
<h2 id='U-utils'>Zero-mean, unit-variance version of standard distributions</h2><span id='topic+U-utils'></span><span id='topic+dU'></span><span id='topic+pU'></span><span id='topic+qU'></span><span id='topic+rU'></span>

<h3>Description</h3>

<p>Density, distribution function, quantile function and random number
generation for the shifted and scaled U of the
(location-)scale family input <code class="reqn">X \sim F_X(x \mid \boldsymbol \beta)</code>
- see References.
</p>
<p>Since the normalized random variable U is one of the main building blocks of
Lambert W <code class="reqn">\times</code> F distributions, these functions are wrappers used
by other functions such as <code><a href="#topic+dLambertW">dLambertW</a></code> or
<code><a href="#topic+rLambertW">rLambertW</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dU(u, beta, distname, use.mean.variance = TRUE)

pU(u, beta, distname, use.mean.variance = TRUE)

qU(p, beta, distname, use.mean.variance = TRUE)

rU(n, beta, distname, use.mean.variance = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="U-utils_+3A_u">u</code></td>
<td>
<p>vector of quantiles.</p>
</td></tr>
<tr><td><code id="U-utils_+3A_beta">beta</code></td>
<td>
<p>numeric vector (deprecated); parameter <code class="reqn">\boldsymbol \beta</code> of
the input distribution.  See <code><a href="#topic+check_beta">check_beta</a></code> on how to specify
<code>beta</code> for each distribution.</p>
</td></tr>
<tr><td><code id="U-utils_+3A_distname">distname</code></td>
<td>
<p>character; name of input distribution; see
<code><a href="#topic+get_distnames">get_distnames</a></code>.</p>
</td></tr>
<tr><td><code id="U-utils_+3A_use.mean.variance">use.mean.variance</code></td>
<td>
<p>logical; if <code>TRUE</code> it uses mean and variance
implied by <code class="reqn">\boldsymbol \beta</code> to do the transformation (Goerg 2011).
If <code>FALSE</code>, it uses the alternative definition from Goerg (2016)
with location and scale parameter.</p>
</td></tr>
<tr><td><code id="U-utils_+3A_p">p</code></td>
<td>
<p>vector of probability levels</p>
</td></tr>
<tr><td><code id="U-utils_+3A_n">n</code></td>
<td>
<p>number of samples</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>dU</code> evaluates the pdf at <code>y</code>, <code>pU</code> evaluates the
cdf, <code>qU</code> is the quantile function, and <code>rU</code> generates random
samples from U.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# a zero-mean, unit variance version of the t_3 distribution.
curve(dU(x, beta = c(1, 1, 3), distname = "t"), -4, 4,
      ylab = "pdf", xlab = "u",
      main = "student-t \n zero-mean, unit variance")
# cdf of unit-variance version of an exp(3) -&gt; just an exp(1)
curve(pU(x, beta = 3, distname = "exp"), 0, 4, ylab = "cdf", xlab = "u",
      main = "Exponential \n unit variance", col = 2, lwd = 2) 
curve(pexp(x, rate = 1), 0, 4, add = TRUE, lty = 2)
# all have (empirical) variance 1
var(rU(n = 1000, distname = "chisq", beta = 2))
var(rU(n = 1000, distname = "normal", beta = c(3, 3)))
var(rU(n = 1000, distname = "exp", beta = 1))
var(rU(n = 1000, distname = "unif", beta = c(0, 10)))

</code></pre>

<hr>
<h2 id='W'>Lambert W function, its logarithm and derivative</h2><span id='topic+W'></span><span id='topic+deriv_W'></span><span id='topic+log_deriv_W'></span><span id='topic+deriv_log_W'></span><span id='topic+log_W'></span>

<h3>Description</h3>

<p>The Lambert W function <code class="reqn">W(z) = u</code> is defined as the inverse
of (see <code><a href="#topic+xexp">xexp</a></code>)
</p>
<p style="text-align: center;"><code class="reqn"> u \exp(u) = z, </code>
</p>

<p>i.e., it satisfies <code class="reqn">W(z) \exp(W(z)) = z</code>.
</p>
<p><code>W</code> evaluates the Lambert W function (<code>W</code>), its first derivative
(<code>deriv_W</code>), and its logarithm (<code>log_W</code>).  All of them have a
principal (<code>branch = 0</code> (default)) and non-principal branch
(<code>branch = -1</code>) solution.
</p>
<p><code>W</code> is a wrapper for <code><a href="lamW.html#topic+lambertW0">lambertW0</a></code> and
<code><a href="lamW.html#topic+lambertWm1">lambertWm1</a></code> in the <span class="pkg">lamW</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>W(z, branch = 0)

deriv_W(z, branch = 0, W.z = W(z, branch = branch))

log_deriv_W(z, branch = 0, W.z = W(z, branch = branch))

deriv_log_W(z, branch = 0, W.z = W(z, branch = branch))

log_W(z, branch = 0, W.z = W(z, branch = branch))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="W_+3A_z">z</code></td>
<td>
<p>a numeric vector of real values; note that <code>W(Inf, branch = 0)
= Inf</code>.</p>
</td></tr>
<tr><td><code id="W_+3A_branch">branch</code></td>
<td>
<p>either <code>0</code> or <code>-1</code> for the principal or non-principal
branch solution.</p>
</td></tr>
<tr><td><code id="W_+3A_w.z">W.z</code></td>
<td>
<p>Lambert W function evaluated at <code>z</code>; see Details below for
why this is useful.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on the argument <code class="reqn">z</code> of <code class="reqn">W(z)</code> one can distinguish 3 cases:
</p>
<dl>
<dt><code class="reqn">z \geq 0</code></dt><dd><p>solution is unique <code>W(z) = W(z, branch =
0)</code></p>
</dd></dl>
<p>; </p>
<dl>
<dt><code class="reqn">-1/e \leq z &lt; 0</code></dt><dd><p>two solutions: the principal (<code>W(z,
branch = 0)</code>) and non-principal (<code>W(z, branch = -1)</code>) branch;</p>
</dd>
<dt><code class="reqn">z &lt; -1/e</code></dt><dd><p> no solution exists in the reals.</p>
</dd>
</dl>

<p><code>log_W</code> computes the natural logarithm of <code class="reqn">W(z)</code>. This can be done
efficiently since <code class="reqn">\log W(z) = \log z - W(z)</code>. Similarly, the
derivative can be expressed as a function of <code class="reqn">W(z)</code>:
</p>
<p style="text-align: center;"><code class="reqn"> W'(z) = \frac{1}{(1 + W(z)) \exp(W(z))} = \frac{W(z)}{z(1 + W(z))}. </code>
</p>

<p>Note that <code class="reqn">W'(0) = 1</code> and <code class="reqn">W'(-1/e) = \infty</code>.
</p>
<p>Moreover, by taking logs on both sides we can even simplify further to
</p>
<p style="text-align: center;"><code class="reqn">\log W'(z) = \log W(z) - \log z - \log (1 + W(z))</code>
</p>
<p> which, since
<code class="reqn">\log W(z) = \log z - W(z)</code>, simplifies to
</p>
<p style="text-align: center;"><code class="reqn"> \log W'(z) = - W(z) - \log (1 + W(z)).</code>
</p>
 
<p>For this reason it is numerically faster to pass the value of <code class="reqn">W(z)</code> as
an argument to <code>deriv_W</code> since <code>W(z)</code> often has already been
evaluated in a previous step.
</p>


<h3>Value</h3>

<p>numeric; same dimensions/size as <code>z</code>.
</p>
<p><code>W</code> returns numeric, <code>Inf</code> (for <code>z = Inf</code>), or <code>NA</code> if
<code class="reqn">z &lt; -1/e</code>. 
</p>
<p>Note that <code>W</code> handles <code>NaN</code> differently to
<code><a href="lamW.html#topic+lambertW0">lambertW0</a></code> / <code><a href="lamW.html#topic+lambertWm1">lambertWm1</a></code> in the <span class="pkg">lamW</span> package; it returns
<code>NA</code>.
</p>


<h3>References</h3>

<p>Corless, R. M., G. H. Gonnet, D. E. G. Hare, D. J. Jeffrey and D. E. Knuth
(1996). &ldquo;On the Lambert W function&rdquo;. Advances in Computational
Mathematics, pp. 329-359.
</p>


<h3>See Also</h3>

<p><code><a href="lamW.html#topic+lambertW0">lambertW0</a></code> / <code><a href="lamW.html#topic+lambertWm1">lambertWm1</a></code>in the <span class="pkg">lamW</span> package;
<code><a href="#topic+xexp">xexp</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
W(-0.25) # "reasonable" input event 
W(-0.25, branch = -1) # "extreme" input event

curve(W(x, branch = -1), -1, 2, type = "l", col = 2, lwd = 2)
curve(W(x), -1, 2, type = "l", add = TRUE, lty = 2) 
abline(v = - 1 / exp(1))

# For lower values, the principal branch gives the 'wrong' solution; 
# the non-principal must be used.
xexp(-10) 
W(xexp(-10), branch = 0) 
W(xexp(-10), branch = -1)

curve(log(x), 0.1, 5, lty = 2, col = 1, ylab = "")
curve(W(x), 0, 5, add = TRUE, col = "red")
curve(log_W(x), 0.1, 5, add = TRUE, col = "blue")
grid()
legend("bottomright", c("log(x)", "W(x)", "log(W(x))"),
       col = c("black", "red", "blue"), lty = c(2, 1, 1))

</code></pre>

<hr>
<h2 id='W_delta'>Inverse transformation for heavy-tail Lambert W RVs</h2><span id='topic+W_delta'></span><span id='topic+W_delta_alpha'></span><span id='topic+W_2delta'></span><span id='topic+W_2delta_2alpha'></span><span id='topic+deriv_W_delta'></span><span id='topic+deriv_W_delta_alpha'></span>

<h3>Description</h3>

<p>Inverse transformation <code>W_delta_alpha</code> for heavy-tail Lambert W RVs and its derivative.
This is the inverse of Tukey's h transformation as a special case of <code>alpha = 1</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>W_delta(z, delta = 0)

W_delta_alpha(z, delta = 0, alpha = 1)

W_2delta(z, delta = c(0, 1/5))

W_2delta_2alpha(z, delta = c(0, 0), alpha = c(1, 1))

deriv_W_delta(z, delta = 0)

deriv_W_delta_alpha(z, delta = 1, alpha = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="W_delta_+3A_z">z</code></td>
<td>
<p>a numeric vector of real values.</p>
</td></tr>
<tr><td><code id="W_delta_+3A_delta">delta</code></td>
<td>
<p>heavy-tail parameter(s); by default <code>delta = 0</code>, which
implies <code>W_delta(z) = z</code>. If a vector of length 2 is supplied, then
<code>delta[1]</code> on the left and <code>delta[2]</code> on the right (of the
center) will be used.</p>
</td></tr>
<tr><td><code id="W_delta_+3A_alpha">alpha</code></td>
<td>
<p>heavy-tail exponent(s) in <code class="reqn">(u^2)^{\alpha}</code>; default: <code>alpha = 1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Computes sgn<code class="reqn">(z) \left(\frac{1}{\alpha \delta} W(\alpha \delta (z^2)^{\alpha})
\right)^{1/2 \alpha}</code>. If <code class="reqn">z</code> is a vector, so is the output.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
G_delta(0)
W_delta(0)

# W_delta is the inverse of G_delta
u.v &lt;- -2:2
W_delta(G_delta(u.v, delta = 0.3), delta = 0.3)

# with alpha too
G_delta_alpha(u.v, delta = 1, alpha = 0.33)
W_delta_alpha(G_delta_alpha(u.v, delta = 1, alpha = 0.33), 
              delta = 1, alpha = 0.33) # the inverse

</code></pre>

<hr>
<h2 id='W_gamma'>Inverse transformation for skewed Lambert W RVs</h2><span id='topic+W_gamma'></span><span id='topic+deriv_W_gamma'></span>

<h3>Description</h3>

<p>Inverse transformation for skewed Lambert W RVs and its derivative.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>W_gamma(z, gamma = 0, branch = 0)

deriv_W_gamma(z, gamma = 0, branch = 0)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="W_gamma_+3A_z">z</code></td>
<td>
<p>a numeric vector of real values; note that <code>W(Inf, branch = 0)
= Inf</code>.</p>
</td></tr>
<tr><td><code id="W_gamma_+3A_gamma">gamma</code></td>
<td>
<p>skewness parameter; by default <code>gamma = 0</code>, which implies
<code>W_gamma(z) = z</code>.</p>
</td></tr>
<tr><td><code id="W_gamma_+3A_branch">branch</code></td>
<td>
<p>either <code>0</code> or <code>-1</code> for the principal or non-principal
branch solution.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A skewed Lambert W<code class="reqn">\times</code> F RV <code class="reqn">Z</code> (for simplicity assume zero mean, unit variance input)
is defined by the transformation (see <code><a href="#topic+H_gamma">H_gamma</a></code>)
</p>
<p style="text-align: center;"><code class="reqn"> z = U \exp(\gamma U) =: H_{\gamma}(U), \quad \gamma \in \mathbf{R}, </code>
</p>

<p>where <code class="reqn">U</code> is a zero-mean and/or unit-variance version of the distribution <code class="reqn">F</code>.
</p>
<p>The inverse transformation is <code class="reqn">W_{\gamma}(z) := \frac{W(\gamma z)}{\gamma}</code>, where
<code class="reqn">W</code> is the Lambert W function.  
</p>
<p><code>W_gamma(z, gamma, branch = 0)</code> (and <code>W_gamma(z, gamma, branch = -1)</code>) 
implement this inverse. 
</p>
<p>If <code class="reqn">\gamma = 0</code>, then <code class="reqn">z = u</code> and the inverse also equals the identity.
</p>
<p>If <code class="reqn">\gamma \neq 0</code>, the inverse transformation can be computed by </p>
<p style="text-align: center;"><code class="reqn">
W_{\gamma}(z) = \frac{1}{\gamma} W(\gamma z). </code>
</p>

<p>Same holds for <code>W_gamma(z, gamma, branch = -1)</code>.
</p>
<p>The derivative of <code class="reqn">W_{\gamma}(z)</code> with respect to <code class="reqn">z</code> simplifies to
</p>
<p style="text-align: center;"><code class="reqn">
\frac{d}{dz} W_{\gamma}(z) = \frac{1}{\gamma} \cdot W'(\gamma z) \cdot \gamma = W'(\gamma z)
</code>
</p>

<p><code>deriv_W_gamma</code> implements this derivative (for both branches).
</p>


<h3>Value</h3>

<p>numeric; if <code class="reqn">z</code> is a vector, so is the output.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+H_gamma">H_gamma</a></code>
</p>

<hr>
<h2 id='xexp'>Transformation that defines the Lambert W function and its derivative</h2><span id='topic+xexp'></span><span id='topic+deriv_xexp'></span>

<h3>Description</h3>

<p>The Lambert W function <code class="reqn">W(z)</code> is the inverse of <code class="reqn">u \exp(u) = z</code>.
</p>
<p>In versions &lt; 0.6.0 of the package this function was denoted as <code>H</code>. 
It is now replaced with the more descriptive <code>xexp</code> (and <code>H</code>
is deprecated).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>xexp(x)

deriv_xexp(x, degree = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="xexp_+3A_x">x</code></td>
<td>
<p>a numeric vector of real/complex values.</p>
</td></tr>
<tr><td><code id="xexp_+3A_degree">degree</code></td>
<td>
<p>non-negative integer; degree of the derivative</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The n-th derviative of <code class="reqn">x \cdot \exp(x)</code> is available in closed for as
</p>
<p style="text-align: center;"><code class="reqn"> \exp(x) \cdot (x + n).</code>
</p>



<h3>Value</h3>

<p>Returns <code class="reqn">z = x \exp(x)</code> for <code class="reqn">x \in C</code>. If <code class="reqn">x</code> is a
vector/matrix, so is <code class="reqn">z</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+W">W</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
plot(xexp, -5, 0.5, type="l", xlab="u", ylab="z")
grid()
abline(h=0, lty = 2)
abline(v=0, lty = 2)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
