<!DOCTYPE html><html><head><title>Help for package equateIRT</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {equateIRT}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#alldirec'>
<p>Direct Equating Coefficients Between All Pairs of a List of Forms</p></a></li>
<li><a href='#bisectorec'>
<p>Bisector Equating Coefficients</p></a></li>
<li><a href='#chainec'>
<p>Chain Equating Coefficients</p></a></li>
<li><a href='#convert'>
<p>Item Parameters Conversion</p></a></li>
<li><a href='#data2pl'>
<p>Simulated Data Sets</p></a></li>
<li><a href='#dataDIF'>
<p>Simulated Data Set with DIF</p></a></li>
<li><a href='#dif.test'>
<p>DIF Test</p></a></li>
<li><a href='#direc'>
<p>Direct Equating Coefficients</p></a></li>
<li><a href='#eqc'>
<p>Extract Equating Coefficients</p></a></li>
<li><a href='#equateIRT-package'>
<p>IRT Equating Methods</p></a></li>
<li><a href='#est2pl'>
<p>Item Parameter Estimates and Covariance Matrices of a Two-Parameter Logistic Model</p></a></li>
<li><a href='#est3pl'>
<p>Item Parameter Estimates and Covariance Matrices of a Three-Parameter Logistic Model</p></a></li>
<li><a href='#estrasch'>
<p>Item Parameter Estimates and Covariance Matrices of a Rasch Model</p></a></li>
<li><a href='#id.test'>
<p>Identity Test</p></a></li>
<li><a href='#import.ltm'>
<p>Import Item Parameters Estimates and Covariance Matrices from IRT Software</p></a></li>
<li><a href='#itm'>
<p>Extract Item Parameters</p></a></li>
<li><a href='#linkp'>
<p>Linkage Plan</p></a></li>
<li><a href='#modIRT'>
<p>Estimated Coefficients and Covariance Matrix of IRT Models</p></a></li>
<li><a href='#score'>
<p>Scoring</p></a></li>
<li><a href='#sd.test'>
<p>Test on Chain Equating Coefficients</p></a></li>
<li><a href='#summary.ceqc'>
<p>Summarizing Estimated Chain Equating Coefficients</p></a></li>
<li><a href='#summary.ceqclist'>
<p>Summarizing a List of Estimated Chain Equating Coefficients</p></a></li>
<li><a href='#summary.eqc'>
<p>Summarizing Estimated Equating Coefficients</p></a></li>
<li><a href='#summary.eqclist'>
<p>Summarizing a List of Estimated Direct Equating Coefficients</p></a></li>
<li><a href='#summary.meqc'>
<p>Summarizing Bisector Equating Coefficients</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>IRT Equating Methods</td>
</tr>
<tr>
<td>Imports:</td>
<td>statmod, stats, utils, mirt</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, ltm, rmarkdown, sna</td>
</tr>
<tr>
<td>Version:</td>
<td>2.4.0</td>
</tr>
<tr>
<td>Author:</td>
<td>Michela Battauz</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michela Battauz &lt;michela.battauz@uniud.it&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Computation of direct, chain and average (bisector) equating coefficients with 
  standard errors using Item Response Theory (IRT) methods for dichotomous items 
  (Battauz (2013) &lt;<a href="https://doi.org/10.1007%2Fs11336-012-9316-y">doi:10.1007/s11336-012-9316-y</a>&gt;, 
  Battauz (2015) &lt;<a href="https://doi.org/10.18637%2Fjss.v068.i07">doi:10.18637/jss.v068.i07</a>&gt;). 
  Test scoring can be performed by true score equating and observed score equating methods. 
  DIF detection can be performed using a Wald-type test  
  (Battauz (2019) &lt;<a href="https://doi.org/10.1007%2Fs10260-018-00442-w">doi:10.1007/s10260-018-00442-w</a>&gt;).
  The package includes tests to access the stability of the equating transformations
  (Battauz(2022) &lt;<a href="https://doi.org/10.1111%2Fstan.12277">doi:10.1111/stan.12277</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-26 15:35:45 UTC; Battauz</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-26 16:30:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='alldirec'>
Direct Equating Coefficients Between All Pairs of a List of Forms
</h2><span id='topic+alldirec'></span><span id='topic+print.eqclist'></span>

<h3>Description</h3>

<p>Calculates direct equating coefficients and standard errors using 
IRT methods between all pairs of a list of forms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>alldirec(mods, method = "mean-mean", all = FALSE, quadrature = TRUE, nq = 30, 
	direction = "both")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="alldirec_+3A_mods">mods</code></td>
<td>

<p>an object of the class <code>modIRT</code> containing 
item parameter coefficients and their covariance matrix
of the forms to be equated.
</p>
</td></tr>
<tr><td><code id="alldirec_+3A_method">method</code></td>
<td>

<p>the equating method to be used. This should be one of
&quot;<code>mean-mean</code>&quot;, &quot;<code>mean-gmean</code>&quot;, &quot;<code>mean-sigma</code>&quot;,
&quot;<code>Haebara</code>&quot; or &quot;<code>Stocking-Lord</code>&quot;.
</p>
</td></tr>
<tr><td><code id="alldirec_+3A_all">all</code></td>
<td>

<p>logical; if FALSE forms that do not have common items
will not appear in the output.
</p>
</td></tr>
<tr><td><code id="alldirec_+3A_quadrature">quadrature</code></td>
<td>
<p>logical; if TRUE the Gauss-Hermite quadrature is used
to approximate the integral in the function that is minimized in the 
Haebara and Stocking-Lord methods.
If FALSE the integral is replaced with a sum over 40
equally spaced values ranging from -4 to 4 with an increment 
of 0.05 and weights equal to one for all values.
</p>
</td></tr>
<tr><td><code id="alldirec_+3A_nq">nq</code></td>
<td>
<p>number of quadrature points used for the Gauss-Hermite quadrature
if <code>quadrature</code> is TRUE
</p>
</td></tr>
<tr><td><code id="alldirec_+3A_direction">direction</code></td>
<td>
<p>a character string specifying the direction used to equate 
pair of forms. If &quot;<code>back</code>&quot; newer forms are equated to older forms,
if &quot;<code>forward</code>&quot; older forms are equated to newer forms, if &quot;<code>both</code>&quot;
(the default) equating is performed in both directions. Form A is considered 
to be newer than Form B if it is listed after Form B in <code>mods</code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>eqclist</code> consisting in a list with length 
equal to the number of pairs of forms equated. Each component of
the list is an object of class <code>eqc</code> returned by function
<code><a href="#topic+direc">direc</a></code>.
</p>


<h3>Author(s)</h3>

<p>Michela Battauz
</p>


<h3>References</h3>

<p>Battauz, M. (2015). equateIRT: An R Package for IRT Test Equating.
<em>Journal of Statistical Software</em>, <b>68</b>, 1&ndash;22.
</p>
<p>Kolen, M.J. and Brennan, R.L. (2014). <em>Test equating, scaling, 
and linking: methods and practices</em>, 3rd ed., New York: Springer
</p>
<p>Ogasawara, H. (2000). Asymptotic standard errors of IRT equating coefficients 
using moments. <em>Economic Review (Otaru University of Commerce)</em>, 
<b>51</b>, 1&ndash;23.
</p>
<p>Ogasawara, H. (2001). Standard Errors of Item Response Theory Equating/Linking
by Response Function Methods. <em>Applied Psychological Measurement</em>, 
<b>25</b>, 53&ndash;67.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+direc">direc</a></code>, <code><a href="#topic+eqc">eqc</a></code>, <code><a href="#topic+itm">itm</a></code>, <code><a href="#topic+modIRT">modIRT</a></code>, <code><a href="#topic+summary.eqclist">summary.eqclist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># three-parameter logistic model
# direct equating coefficients using the "Stocking-Lord" method
data(est3pl)
test &lt;- paste("test", 1:5, sep = "")
mod3pl &lt;- modIRT(coef = est3pl$coef, var = est3pl$var, names = test, display = FALSE)
direclist3pl &lt;- alldirec(mods = mod3pl, method = "Stocking-Lord")
summary(direclist3pl)
summary(direclist3pl$test1.test2)

# two-parameter logistic model
# direct equating coefficients using the "Haebara" method
data(est2pl)
test &lt;- paste("test", 1:5, sep = "")
mod2pl &lt;- modIRT(coef = est2pl$coef, var = est2pl$var, names = test, display = FALSE)
direclist2pl &lt;- alldirec(mods = mod2pl, method = "Haebara")
summary(direclist2pl)
summary(direclist2pl$test1.test5)

# Rasch model
# direct equating coefficients using the "mean-mean" method
data(estrasch)
test &lt;- paste("test", 1:5, sep = "")
modrasch &lt;- modIRT(coef = estrasch$coef, var = estrasch$var, names = test, 
	display = FALSE)
direclistrasch &lt;- alldirec(mods = modrasch, method = "mean-mean", all = TRUE)
summary(direclistrasch)
summary(direclistrasch$test5.test4)
</code></pre>

<hr>
<h2 id='bisectorec'>
Bisector Equating Coefficients
</h2><span id='topic+bisectorec'></span><span id='topic+print.meqc'></span>

<h3>Description</h3>

<p>Calculates average equating coefficients using the bisector method 
and standard errors
given a set of direct and chain equating coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bisectorec(ecall, mods = NULL, weighted = TRUE, unweighted = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bisectorec_+3A_ecall">ecall</code></td>
<td>

<p>list of objects of class <code>eqc</code> or <code>ceqc</code> 
returned by functions
<code><a href="#topic+direc">direc</a></code> and <code><a href="#topic+chainec">chainec</a></code>.
</p>
</td></tr>
<tr><td><code id="bisectorec_+3A_mods">mods</code></td>
<td>

<p>an object of class <code>modIRT</code> containing 
item parameter coefficients and their covariance matrix
of the forms to be equated. From version 2.0 it can be <code>NULL</code>
</p>
</td></tr>
<tr><td><code id="bisectorec_+3A_weighted">weighted</code></td>
<td>

<p>logical; if TRUE weighted bisector coefficients are computed.
</p>
</td></tr>
<tr><td><code id="bisectorec_+3A_unweighted">unweighted</code></td>
<td>

<p>logical; if TRUE unweighted bisector coefficients are computed.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>meqc</code> with components
</p>
<table>
<tr><td><code>coef</code></td>
<td>
<p>data frame containing <code>link</code>, <code>path</code>,
coefficient <code>A</code>, coefficient <code>B</code>, 
standard error of coefficient A (<code>seA</code>), standard error of 
coefficient B (<code>seB</code>) and <code>weights</code> of direct, chain and bisector 
equating coefficients.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the equating method used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michela Battauz
</p>


<h3>References</h3>

<p>Battauz, M. (2013). IRT Test Equating in Complex Linkage Plans. 
<em>Psychometrika</em>, <b>78</b>, 464&ndash;480.
</p>
<p>Battauz, M. (2015). equateIRT: An R Package for IRT Test Equating.
<em>Journal of Statistical Software</em>, <b>68</b>, 1&ndash;22.
</p>
<p>Holland, P.W. and Strawderman, W.E. (2011). How to average equating 
functions if you must. In A.A. von Davier (Ed.), <em>Statistical models for 
test equating, scaling, and linking</em> (pp. 89&ndash;107). New York: Springer.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chainec">chainec</a></code>, <code><a href="#topic+convert">convert</a></code>, <code><a href="#topic+direc">direc</a></code>, <code><a href="#topic+eqc">eqc</a></code>, <code><a href="#topic+summary.meqc">summary.meqc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># three-parameter logistic model
# direct equating coefficients using the "Stocking-Lord" method
data(est3pl)
test &lt;- paste("test", 1:5, sep = "")
mod3pl &lt;- modIRT(coef = est3pl$coef, var = est3pl$var, names = test, display = FALSE)
direclist3pl &lt;- alldirec(mods = mod3pl, method = "Stocking-Lord")
# compute chain equating coefficients for path 1,2,3,4,5
pth3 &lt;- paste("test", 1:5, sep = "")
chainec3 &lt;- chainec(direclist = direclist3pl, pths = pth3)
# create a list of objects of class eqc or ceqc
ecall &lt;- c(chainec3, direclist3pl["test1.test5"])
# compute bisector and weighted bisector coefficients
allec &lt;- bisectorec(ecall = ecall, weighted = TRUE, unweighted = TRUE)
summary(allec)

# two-parameter logistic model
# direct equating coefficients using the "Haebara" method
data(est2pl)
test &lt;- paste("test", 1:5, sep = "")
mod2pl &lt;- modIRT(coef = est2pl$coef, var = est2pl$var, names = test, display = FALSE)
direclist2pl &lt;- alldirec(mods = mod2pl, method = "Haebara")
# compute chain equating coefficients for path 1,2,3,4
pth1 &lt;- paste("test", 1:4, sep = "")
chainec1 &lt;- chainec(direclist = direclist2pl, pths = pth1)
# compute chain equating coefficients for path 1,5,4
pth2 &lt;- c(paste("test", c(1,5,4), sep = ""))
chainec2 &lt;- chainec(direclist = direclist2pl, pths = pth2)
# compute chain equating coefficients for path 1,2,3,4,5
pth3 &lt;- paste("test", 1:5, sep = "")
chainec3 &lt;- chainec(direclist = direclist2pl, pths = pth3)
# create a list of objects of class eqc or ceqc
ecall &lt;- c(chainec1, chainec2, chainec3, direclist2pl["test1.test5"])
# compute bisector and weighted bisector coefficients
allec &lt;- bisectorec(ecall = ecall, weighted = TRUE, unweighted = TRUE)
summary(allec)

# Rasch model
# direct equating coefficients using the "mean-mean" method
data(estrasch)
test &lt;- paste("test", 1:5, sep = "")
modrasch &lt;- modIRT(coef = estrasch$coef, var = estrasch$var, names = test, 
	display = FALSE)
direclistrasch &lt;- alldirec(mods = modrasch, method = "mean-mean", all = TRUE)
# compute chain equating coefficients for path 1,2,3,4
pth1 &lt;- paste("test", 1:4, sep = "")
chainec1 &lt;- chainec(direclist = direclistrasch, pths = pth1)
# compute chain equating coefficients for path 1,5,4
pth2 &lt;- c(paste("test", c(1,5,4), sep = ""))
chainec2 &lt;- chainec(direclist = direclistrasch, pths = pth2)
# create a list of objects of class eqc or ceqc
ecall &lt;- c(chainec1, chainec2)
# compute bisector and weighted bisector coefficients
allec &lt;- bisectorec(ecall = ecall, weighted = TRUE, unweighted = TRUE)
summary(allec)
</code></pre>

<hr>
<h2 id='chainec'>
Chain Equating Coefficients
</h2><span id='topic+chainec'></span><span id='topic+ceqc'></span>

<h3>Description</h3>

<p>Calculates chain (indirect) equating coefficients and standard errors using 
IRT methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chainec(r = NULL, direclist, f1 = NULL, f2 = NULL, pths = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="chainec_+3A_r">r</code></td>
<td>

<p>length of the chain, that is the number of forms used for equating
including extremes. It should be at least 3. It does not need to
be specified if argument <code>pths</code> is not NULL.
</p>
</td></tr>
<tr><td><code id="chainec_+3A_direclist">direclist</code></td>
<td>

<p>an object of the class <code>eqclist</code> return by function <code><a href="#topic+alldirec">alldirec</a></code>
containing direct equating coefficients	between pairs of forms.
</p>
</td></tr>
<tr><td><code id="chainec_+3A_f1">f1</code></td>
<td>

<p>the name of the first form of the chain.
</p>
</td></tr>
<tr><td><code id="chainec_+3A_f2">f2</code></td>
<td>

<p>the name of the last form of the chain.
</p>
</td></tr>
<tr><td><code id="chainec_+3A_pths">pths</code></td>
<td>

<p>vector, matrix or data frame containing the path used for equating. 
The number of columns 
is equal to r and the number of rows is equal to the equatings that
have to be performed.
If <code>NULL</code> all the chain equating coefficients of length <code>r</code> 
will be computed.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Equating coefficients perform the conversion from the scale of the 
first form to the scale of the last form of the path.
</p>


<h3>Value</h3>

<p>An object of class <code>ceqclist</code> consisting in a list with length 
equal to the number of chain equating coefficients computed. 
Each component of the list is an object of class <code>ceqc</code> with components
</p>
<table>
<tr><td><code>tab1</code></td>
<td>
<p>item parameters of the first form.</p>
</td></tr>
<tr><td><code>tab2</code></td>
<td>
<p>item parameters of the last form.</p>
</td></tr>
<tr><td><code>tab</code></td>
<td>
<p>Data frame containing item names (<code>Item</code>), 
item parameters of the first form (e.g. <code>test1</code>), 
item parameters of the last form (e.g. <code>test3</code>), 
and item parameters of the first form converted 
in the scale of the last form (e.g. <code>test1.as.test3</code>).</p>
</td></tr>
<tr><td><code>varAll</code></td>
<td>
<p>covariance matrix of item parameters of all forms used 
in the chain.</p>
</td></tr>
<tr><td><code>partial</code></td>
<td>
<p>partial derivatives of equating coefficients A and B
with respect to item parameters.</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>equating coefficient A.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>equating coefficient B.</p>
</td></tr>
<tr><td><code>varAB</code></td>
<td>
<p>covariance matrix of the equating coefficients.</p>
</td></tr>
<tr><td><code>commonitem</code></td>
<td>
<p>list of length r-1 containing the names of common item 
parameters between adjacent forms.</p>
</td></tr>
<tr><td><code>ni</code></td>
<td>
<p>vector containing number of common items between pairs of adjacent forms.</p>
</td></tr>
<tr><td><code>forms</code></td>
<td>
<p>names of equated forms.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the equating method used.</p>
</td></tr>
<tr><td><code>itmp</code></td>
<td>
<p>number of item parameters of the IRT model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michela Battauz
</p>


<h3>References</h3>

<p>Battauz, M. (2013). IRT Test Equating in Complex Linkage Plans. 
<em>Psychometrika</em>, <b>78</b>, 464&ndash;480.
</p>
<p>Battauz, M. (2015). equateIRT: An R Package for IRT Test Equating.
<em>Journal of Statistical Software</em>, <b>68</b>, 1&ndash;22.
</p>
<p>Kolen, M.J. and Brennan, R.L. (2014). <em>Test equating, scaling, 
and linking: methods and practices</em>, 3rd ed., New York: Springer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+alldirec">alldirec</a></code>, <code><a href="#topic+eqc">eqc</a></code>, <code><a href="#topic+itm">itm</a></code>, <code><a href="#topic+summary.ceqc">summary.ceqc</a></code>, <code><a href="#topic+summary.ceqclist">summary.ceqclist</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># three-parameter logistic model
# direct equating coefficients using the "Stocking-Lord" method
data(est3pl)
test&lt;-paste("test", 1:5, sep = "")
mod3pl &lt;- modIRT(coef = est3pl$coef, var = est3pl$var, names = test, display = FALSE)
direclist3pl &lt;- alldirec(mods = mod3pl, method = "Stocking-Lord")
# compute all chain equating coefficients of length 4
chainec4 &lt;- chainec(r = 4, direclist = direclist3pl)
summary(chainec4)
summary(chainec4$test1.test2.test3.test4)
# compute all chain equating coefficients of length 4 
# where the first form is test1
chainec4.1 &lt;- chainec(r = 4, direclist = direclist3pl, f1 = "test1")
summary(chainec4.1)
# compute all chain equating coefficients of length 4 
# where the first form is test1 and the last form is test4
chainec4.14 &lt;- chainec(r = 4, direclist = direclist3pl, f1 = "test1", f2 = "test4")
summary(chainec4.14)


# two-parameter logistic model
# direct equating coefficients using the "Haebara" method
data(est2pl)
test&lt;-paste("test", 1:5, sep = "")
mod2pl &lt;- modIRT(coef = est2pl$coef, var = est2pl$var, names = test, display = FALSE)
direclist2pl &lt;- alldirec(mods = mod2pl, method = "Haebara")
# compute chain equating coefficients of a given path
pth &lt;- paste("test", c(1,5,4), sep = "")
chainec154 &lt;- chainec(direclist = direclist2pl, pths = pth)
summary(chainec154)


# Rasch model
# direct equating coefficients using the "mean-mean" method
data(estrasch)
test&lt;-paste("test", 1:5, sep = "")
modrasch &lt;- modIRT(coef = estrasch$coef, var = estrasch$var, names = test, 
	display = FALSE)
direclistrasch &lt;- alldirec(mods = modrasch, method = "mean-mean", all = TRUE)
# compute chain equating coefficients of two given paths
pth1 &lt;- paste("test", 1:3, sep = "")
pth2 &lt;- paste("test", c(1,5,4), sep = "")
pths &lt;- rbind(pth1, pth2)
chainec1 &lt;- chainec(direclist = direclistrasch, pths = pths)
summary(chainec1)
</code></pre>

<hr>
<h2 id='convert'>
Item Parameters Conversion
</h2><span id='topic+convert'></span>

<h3>Description</h3>

<p>Converts item and person parameters using equating coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>convert(A, B, coef = NULL, person.par = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convert_+3A_a">A</code></td>
<td>

<p>equating coefficient A.
</p>
</td></tr>
<tr><td><code id="convert_+3A_b">B</code></td>
<td>

<p>equating coefficient B.
</p>
</td></tr>
<tr><td><code id="convert_+3A_coef">coef</code></td>
<td>

<p>vector of item parameters return by function <code><a href="#topic+modIRT">modIRT</a></code>.
</p>
</td></tr>
<tr><td><code id="convert_+3A_person.par">person.par</code></td>
<td>

<p>vector of person parameters estimates.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Difficulty parameters <code class="reqn">b</code> are converted using transformation <code class="reqn">b \cdot A+B</code>;
discrimination parameters <code class="reqn">a</code> are converted using transformation <code class="reqn">a/A</code>;
guessing parameters c are not transformed.
</p>
<p>Person parameters <code class="reqn">\theta</code> are converted using transformation <code class="reqn">\theta \cdot A+B</code>.
</p>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>coef</code></td>
<td>
<p>vector of item parameters transformed.</p>
</td></tr>
<tr><td><code>person.par</code></td>
<td>
<p>vector of person parameters transformed</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michela Battauz
</p>


<h3>References</h3>

<p>Battauz, M. (2015). equateIRT: An R Package for IRT Test Equating.
<em>Journal of Statistical Software</em>, <b>68</b>, 1&ndash;22.
</p>
<p>Kolen, M.J. and Brennan, R.L. (2014). <em>Test equating, scaling, 
and linking: methods and practices</em>, 3rd ed., New York: Springer
</p>


<h3>See Also</h3>

<p><code><a href="#topic+itm">itm</a></code>, <code><a href="#topic+modIRT">modIRT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># conversion using direct coefficients
# three-parameter logistic model
# direct equating coefficients between forms 1 and 2 using the Stocking-Lord method
data(est3pl)
test &lt;- paste("test", 1:5, sep = "")
mod3pl &lt;- modIRT(coef = est3pl$coef, var = est3pl$var, names = test, display = FALSE)
l12 &lt;- direc(mod1 = mod3pl[1], mod2 = mod3pl[2], method = "Stocking-Lord")
convert(A = l12$A, B = l12$B, coef = coef(mod3pl$test1))
# the conversion of item parameters is obtained also using
itm(l12)

# conversion using bisector coefficients
# two-parameter logistic model
# direct equating coefficients using the "Haebara" method
data(est2pl)
test &lt;- paste("test", 1:5, sep = "")
mod2pl &lt;- modIRT(coef = est2pl$coef, var = est2pl$var, names = test, display = FALSE)
direclist2pl &lt;- alldirec(mods = mod2pl, method = "Haebara")
# compute chain equating coefficients for path 1,2,3,4
pth1 &lt;- paste("test", 1:4, sep = "")
chainec1 &lt;- chainec(direclist = direclist2pl, pths = pth1)
# compute chain equating coefficients for path 1,5,4
pth2 &lt;- c(paste("test", c(1,5,4), sep = ""))
chainec2 &lt;- chainec(direclist = direclist2pl, pths = pth2)
# create a list of objects of class ceqc
ecall &lt;- c(chainec1, chainec2)
# compute bisector and weighted bisector coefficients
allec &lt;- bisectorec(ecall = ecall, weighted = TRUE, unweighted = TRUE)
summary(allec)
eqc14&lt;-eqc(allec, link = "test1.test4", path = "bisector")
convert(A = eqc14$A, B = eqc14$B, coef = coef(mod2pl$test1), person.par = seq(-3, 3, 0.5))
</code></pre>

<hr>
<h2 id='data2pl'>
Simulated Data Sets
</h2><span id='topic+data2pl'></span>

<h3>Description</h3>

<p>Five simulated data sets from a two-parameter logistic model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(data2pl)
</code></pre>


<h3>Format</h3>

<p>A list of length 5, containing 5 data frames with 5000 dichotomous responses to 20 items.
</p>


<h3>Author(s)</h3>

<p>Michela Battauz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+est2pl">est2pl</a></code>, <code><a href="#topic+import.ltm">import.ltm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(data2pl)
data2pl[[1]][1:3,]
</code></pre>

<hr>
<h2 id='dataDIF'>
Simulated Data Set with DIF
</h2><span id='topic+dataDIF'></span>

<h3>Description</h3>

<p>Item responses and group membership.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(dataDIF)
</code></pre>


<h3>Format</h3>

<p>A dataframe with 3000 dichotomous responses to 20 items (<code>I01</code> to <code>I20</code>) 
and group membership (<code>group</code>).
</p>


<h3>Author(s)</h3>

<p>Michela Battauz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dif.test">dif.test</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(dataDIF)
</code></pre>

<hr>
<h2 id='dif.test'>
DIF Test
</h2><span id='topic+dif.test'></span><span id='topic+print.dift'></span>

<h3>Description</h3>

<p>Performs a Wald-type test for Differential Item Functioning detection.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dif.test(coef, var, names = NULL, reference = NULL, method = "mean-mean",
  quadrature = TRUE, nq = 30, DIFtype = NULL, purification = FALSE, 
  signif.level = 0.05, trace = FALSE, maxiter = 30, anchor = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dif.test_+3A_coef">coef</code></td>
<td>
<p>list of matrices (one for each group) containing 
the item parameter estimates. Guessing, difficulty and discrimination 
parameters should strictly be given in this order and they are 
contained in different columns of the matrix.
The names of the	rows of each matrix should be the names of the items.</p>
</td></tr>
<tr><td><code id="dif.test_+3A_var">var</code></td>
<td>
<p>list of matrices (one for each group) containing the 
covariance matrix of item parameter estimates. They should be
given in the same order of coefficients.</p>
</td></tr>
<tr><td><code id="dif.test_+3A_names">names</code></td>
<td>
<p>character vector containing the names of the groups. 
This should have the same length of <code>coef</code> and <code>var</code>.
If <code>NULL</code>, the names of the groups will be &quot;T1&quot;, &quot;T2&quot;, ...</p>
</td></tr>
<tr><td><code id="dif.test_+3A_reference">reference</code></td>
<td>

<p>reference group. Can be specified by name or number.
The default is the first group.
</p>
</td></tr>
<tr><td><code id="dif.test_+3A_method">method</code></td>
<td>
<p>the equating method to be used in function 
<code><a href="#topic+direc">direc</a></code> to convert the item parameters
to the scale of the reference group. This should be one of
&quot;<code>mean-mean</code>&quot;, &quot;<code>mean-gmean</code>&quot;, &quot;<code>mean-sigma</code>&quot;,
&quot;<code>Haebara</code>&quot; or &quot;<code>Stocking-Lord</code>&quot;.
</p>
</td></tr>
<tr><td><code id="dif.test_+3A_quadrature">quadrature</code></td>
<td>
<p>logical; if TRUE the Gauss-Hermite quadrature is used
in function <code><a href="#topic+direc">direc</a></code>
to approximate the integral in the function that is minimized in the 
Haebara and Stocking-Lord methods.
If FALSE the integral is replaced with a sum over 40
equally spaced values ranging from -4 to 4 with an increment 
of 0.05 and weights equal to one for all values.
</p>
</td></tr>
<tr><td><code id="dif.test_+3A_nq">nq</code></td>
<td>
<p>number of quadrature points used for the Gauss-Hermite quadrature
if <code>quadrature</code> is TRUE.
</p>
</td></tr>
<tr><td><code id="dif.test_+3A_diftype">DIFtype</code></td>
<td>
<p>character indicating which parameters to test for DIF.
If <code>NULL</code> all parameters are tested for DIF.
Use &quot;<code>beta1</code>&quot; for <code class="reqn">\beta_1</code>, &quot;<code>beta2</code>&quot; for <code class="reqn">\beta_2</code>,
&quot;<code>beta3</code>&quot; for <code class="reqn">\beta_3</code>, &quot;<code>beta12</code>&quot; for <code class="reqn">\beta_1</code>
and <code class="reqn">\beta_2</code>, &quot;<code>beta123</code>&quot; for <code class="reqn">\beta_1</code>, <code class="reqn">\beta_2</code>
and <code class="reqn">\beta_3</code>. See details.
</p>
</td></tr>
<tr><td><code id="dif.test_+3A_purification">purification</code></td>
<td>
<p>logical. if TRUE the procedure described in
Candell and Drasgow (1988) is applied.
</p>
</td></tr>
<tr><td><code id="dif.test_+3A_signif.level">signif.level</code></td>
<td>

<p>significance level to use in the purification process.
</p>
</td></tr>
<tr><td><code id="dif.test_+3A_trace">trace</code></td>
<td>

<p>logical. If TRUE tracing information is produced.
</p>
</td></tr>
<tr><td><code id="dif.test_+3A_maxiter">maxiter</code></td>
<td>

<p>The maximum number of iterations in the purification process.
</p>
</td></tr>
<tr><td><code id="dif.test_+3A_anchor">anchor</code></td>
<td>

<p>Optional character vector containing the names of the items 
to use for equating. These should be items free of DIF.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameterization of the IRT model is that commonly used for estimation.
Under this parameterization, the three-parameter logistic model is as follows
</p>
<p style="text-align: center;"><code class="reqn">\pi_i = c_i + (1 - c_i) \frac{\exp(\beta_{1i} + \beta_{2i} z)}{1 + 
	\exp(\beta_{1i} + \beta_{2i} z)},</code>
</p>
<p> where 
<code class="reqn">\pi_i</code> denotes the conditional probability of responding correctly to 
the <code class="reqn">i</code>th item given <code class="reqn">z</code>, 
<code class="reqn">c_i</code> denotes the guessing parameter, <code class="reqn">\beta_{1i}</code> is the easiness parameter, 
<code class="reqn">\beta_{2i}</code> is the discrimination parameter, and <code class="reqn">z</code> denotes the 
latent ability.
Furthermore, the guessing parameter is equal to
</p>
<p style="text-align: center;"><code class="reqn">c_i = \frac{\exp(\beta_{3i})}{1+\exp(\beta_{3i})}</code>
</p>
<p>.
</p>
<p>The test verifies whether the item parameters 
<code class="reqn">\beta_{1i}, \beta_{2i}, \beta_{3i}</code>
are invariant across two or more groups as explained in
Battauz (2018).
</p>


<h3>Value</h3>

<p>An object of class <code>dift</code> with components
</p>
<table>
<tr><td><code>test</code></td>
<td>
<p>matrix containing the test statistic and the p-value for each item. 
&quot;noGuess&quot; is equal to 1 if the guessing parameter of a 3PL model was set
to a fixed value.</p>
</td></tr>
<tr><td><code>eqmet</code></td>
<td>
<p>the equating method used.</p>
</td></tr>
<tr><td><code>DIFtype</code></td>
<td>
<p>character indicating which parameters were tested for DIF.</p>
</td></tr>
<tr><td><code>reference</code></td>
<td>
<p>the reference group.</p>
</td></tr>
<tr><td><code>focal</code></td>
<td>
<p>the focal groups.</p>
</td></tr>
<tr><td><code>names</code></td>
<td>
<p>names of the groups.</p>
</td></tr>
<tr><td><code>purification</code></td>
<td>
<p>logical. If TRUE thre purification procedure was applied.</p>
</td></tr>
<tr><td><code>signif.level</code></td>
<td>
<p>significance level used in the purification process</p>
</td></tr>
<tr><td><code>equatings</code></td>
<td>
<p>list containing the output of function <code><a href="#topic+direc">direc</a></code>.</p>
</td></tr>
<tr><td><code>coef_trasf</code></td>
<td>
<p>list containing the item parameters of each group 
transformed to the scale of the reference group.</p>
</td></tr>
<tr><td><code>var_trasf</code></td>
<td>
<p>list containing the covariance matrix of 
item parameters of each group transformed to the scale of the reference group.</p>
</td></tr>
<tr><td><code>items.dif</code></td>
<td>
<p>names of the items for which the null hypothesis of the test is rejected.</p>
</td></tr>
<tr><td><code>anchor</code></td>
<td>
<p>names of the items used as anchors.</p>
</td></tr>
<tr><td><code>niter</code></td>
<td>
<p>number of iterations.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michela Battauz
</p>


<h3>References</h3>

<p>Battauz, M. (2019). On Wald tests for differential item functioning detection.
<em>Statistical Methods and Applications</em>. <b>28</b>, 103-118.
</p>
<p>Candell,  G.L., Drasgow, F. (1988). An iterative procedure for linking 
metrics and assessing item bias in item response theory. 
<em>Applid Psychological Measurement</em>, <b>12</b>, 253-260.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load the data
data(dataDIF)
head(dataDIF)
# estimate a 2PL model for each group using the R package mirt
library(mirt)
data1 &lt;- dataDIF[dataDIF$group == 1, 1:20]
data2 &lt;- dataDIF[dataDIF$group == 2, 1:20]
data3 &lt;- dataDIF[dataDIF$group == 3, 1:20]
mod1 &lt;- mirt(data1, SE = TRUE)
mod2 &lt;- mirt(data2, SE = TRUE)
mod3 &lt;- mirt(data3, SE = TRUE)
# extract the coefficients and the covariance matrix
est1 &lt;- import.mirt(mod1, display = FALSE)
est2 &lt;- import.mirt(mod2, display = FALSE)
est3 &lt;- import.mirt(mod3, display = FALSE)

# perform the test for DIF on two groups
res_diftest2 &lt;- dif.test(coef = list(est1$coef, est2$coef),
  var = list(est1$var, est2$var))
res_diftest2

# perform the test for DIF on three groups
res_diftest3 &lt;- dif.test(coef = list(est1$coef, est2$coef, est3$coef),
  var = list(est1$var, est2$var, est3$var))
res_diftest3

# perform the test for DIF on three groups
# reference group: 2
# equating method: Haebara
# purification applied
res_diftest3 &lt;- dif.test(coef = list(est1$coef, est2$coef, est3$coef),
  var = list(est1$var, est2$var, est3$var), reference = 2,
  method = "Haebara", purification = TRUE)
res_diftest3
</code></pre>

<hr>
<h2 id='direc'>
Direct Equating Coefficients
</h2><span id='topic+direc'></span><span id='topic+print.eqc'></span>

<h3>Description</h3>

<p>Calculates direct equating coefficients and standard errors using 
IRT methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>direc(mods, which, mod1, mod2, method = "mean-mean", suff1 = ".1", suff2 = ".2",
   D = 1, quadrature = TRUE, nq = 30, items.select = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="direc_+3A_mods">mods</code></td>
<td>

<p>an object of the class <code>modIRT</code> containing 
item parameter coefficients and their covariance matrix
of the forms to be equated.
</p>
</td></tr>
<tr><td><code id="direc_+3A_which">which</code></td>
<td>
<p>which forms to equate. Can be specified by name or number.</p>
</td></tr>
<tr><td><code id="direc_+3A_mod1">mod1</code></td>
<td>
<p>deprecated; please use mods instead. 
An object of the class <code>modIRT</code> containing 
item parameter coefficients and their covariance matrix
of the first form.
</p>
</td></tr>
<tr><td><code id="direc_+3A_mod2">mod2</code></td>
<td>
<p>deprecated; please use mods instead.
An object of the class <code>modIRT</code> containing 
item parameter coefficients and their covariance matrix
of the second form.
</p>
</td></tr>
<tr><td><code id="direc_+3A_method">method</code></td>
<td>
<p>the equating method to be used. This should be one of
&quot;<code>mean-mean</code>&quot;, &quot;<code>mean-gmean</code>&quot;, &quot;<code>mean-sigma</code>&quot;,
&quot;<code>Haebara</code>&quot; or &quot;<code>Stocking-Lord</code>&quot;.
</p>
</td></tr>
<tr><td><code id="direc_+3A_suff1">suff1</code></td>
<td>
<p>suffix to identify the first form to be equated.
</p>
</td></tr>
<tr><td><code id="direc_+3A_suff2">suff2</code></td>
<td>
<p>suffix to identify the second form to be equated.
</p>
</td></tr>
<tr><td><code id="direc_+3A_d">D</code></td>
<td>
<p>constant D of the IRT model used to estimate item 
parameters. See below for more details.
</p>
</td></tr>
<tr><td><code id="direc_+3A_quadrature">quadrature</code></td>
<td>
<p>logical; if TRUE the Gauss-Hermite quadrature is used
to approximate the integral in the function that is minimized in the 
Haebara and Stocking-Lord methods.
If FALSE the integral is replaced with a sum over 40
equally spaced values ranging from -4 to 4 with an increment 
of 0.05 and weights equal to one for all values.
</p>
</td></tr>
<tr><td><code id="direc_+3A_nq">nq</code></td>
<td>
<p>number of quadrature points used for the Gauss-Hermite quadrature
if <code>quadrature</code> is TRUE.
</p>
</td></tr>
<tr><td><code id="direc_+3A_items.select">items.select</code></td>
<td>
<p>optional character vector including the names of
the items to use for equating.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Equating coefficients perform the conversion from the scale of the 
first form to the scale of the second form.
</p>
<p>In the three-parameter logistic model  the probability of a 
positive response on item <code class="reqn">i</code> is
</p>
<p style="text-align: center;"><code class="reqn">\pi_i = c_i + (1 - c_i) \frac{\exp[D a_i (\theta - b_i)]}{1 + 
	\exp[D a_i (\theta - b_i)]}.</code>
</p>

<p>where <code class="reqn">a_i</code> is the item discrimination parameter, <code class="reqn">b_i</code> is 
the item difficulty parameter, <code class="reqn">c_i</code> is the item guessing parameter 
and	<code class="reqn">\theta</code> is the latent ability.
The constant <code class="reqn">D</code> can be specified using argument <code>D</code> of the 
<code>direc</code> function.
The two-parameter logistic model can be obtained by setting <code class="reqn">c_i</code> 
equal to zero, the one-parameter logistic model can be obtained 
by setting <code class="reqn">c_i</code> equal to zero and <code class="reqn">a_i</code> costant across items,
while the Rasch model can be obtained by setting <code class="reqn">c_i</code> 
equal to zero and <code class="reqn">a_i</code> equal to 1.
</p>
<p>The type of IRT model does not need to be specified as it is obtained 
from arguments <code>mod1</code> and <code>mod2</code>. 
</p>


<h3>Value</h3>

<p>An object of class <code>eqc</code> with components
</p>
<table>
<tr><td><code>tab1</code></td>
<td>
<p>item parameters of the first form.</p>
</td></tr>
<tr><td><code>tab2</code></td>
<td>
<p>item parameters of the second form.</p>
</td></tr>
<tr><td><code>tab</code></td>
<td>
<p>Data frame containing item names (<code>Item</code>), 
item parameters of the first form (e.g. <code>test1</code>), 
item parameters of the second form (e.g. <code>test2</code>), 
and item parameters of the first form converted 
in the scale of the second form (e.g. <code>test1.as.test2</code>).</p>
</td></tr>
<tr><td><code>var12</code></td>
<td>
<p>covariance matrix of item parameters of the first 
and the second form (only items used for equating).</p>
</td></tr>
<tr><td><code>varFull</code></td>
<td>
<p>list of covariance matrices of the item parameters
(one matrix for each form)</p>
</td></tr>
<tr><td><code>partial</code></td>
<td>
<p>partial derivatives of equating coefficients A and B
with respect to item parameters.</p>
</td></tr>
<tr><td><code>A</code></td>
<td>
<p>equating coefficient A.</p>
</td></tr>
<tr><td><code>B</code></td>
<td>
<p>equating coefficient B.</p>
</td></tr>
<tr><td><code>varAB</code></td>
<td>
<p>covariance matrix of the equating coefficients.</p>
</td></tr>
<tr><td><code>commonitem</code></td>
<td>
<p>list of length 2 containing the names of common item parameters
and the names of the common items selected for equating.</p>
</td></tr>
<tr><td><code>suffixes</code></td>
<td>
<p>suffixes used to identify the forms.</p>
</td></tr>
<tr><td><code>ni</code></td>
<td>
<p>number of common items.</p>
</td></tr>
<tr><td><code>nis</code></td>
<td>
<p>number of common items selected for equating.</p>
</td></tr>
<tr><td><code>forms</code></td>
<td>
<p>names of equated forms.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the equating method used.</p>
</td></tr>
<tr><td><code>itmp</code></td>
<td>
<p>number of item parameters of the IRT model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michela Battauz
</p>


<h3>References</h3>

<p>Battauz, M. (2015). equateIRT: An R Package for IRT Test Equating.
<em>Journal of Statistical Software</em>, <b>68</b>, 1&ndash;22.
</p>
<p>Kolen, M.J. and Brennan, R.L. (2014). <em>Test equating, scaling, 
and linking: methods and practices</em>, 3nd ed., New York: Springer
</p>
<p>Ogasawara, H. (2000). Asymptotic standard errors of IRT equating coefficients 
using moments. <em>Economic Review (Otaru University of Commerce)</em>, 
<b>51</b>, 1&ndash;23.
</p>
<p>Ogasawara, H. (2001). Standard Errors of Item Response Theory Equating/Linking
by Response Function Methods. <em>Applied Psychological Measurement</em>, 
<b>25</b>, 53&ndash;67.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eqc">eqc</a></code>, <code><a href="#topic+itm">itm</a></code>, <code><a href="#topic+modIRT">modIRT</a></code>, <code><a href="#topic+summary.eqc">summary.eqc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># three-parameter logistic model
# direct equating coefficients between forms 1 and 2 using the Stocking-Lord method
data(est3pl)
test &lt;- paste("test", 1:5, sep = "")
mod3pl &lt;- modIRT(coef = est3pl$coef, var = est3pl$var, names = test, display = FALSE)
l12 &lt;- direc(mods = mod3pl, which = c("test1", "test2"), method = "Stocking-Lord")
summary(l12)

# two-parameter logistic model
# direct equating coefficients between forms 1 and 5 using the Haebara method
data(est2pl)
test &lt;- paste("test", 1:5, sep = "")
mod2pl &lt;- modIRT(coef = est2pl$coef, var = est2pl$var, names = test, display = FALSE)
l15 &lt;- direc(mods = mod2pl, which = c(1,5), method = "Haebara")
summary(l15)

# Rasch model
# direct equating coefficients between forms 5 and 4 using the mean-mean method
data(estrasch)
test &lt;- paste("test", 1:5, sep = "")
modrasch &lt;- modIRT(coef = estrasch$coef, var = estrasch$var, names = test, 
	display = FALSE)
l54 &lt;- direc(mods = modrasch, which = c(5,4), method = "mean-mean")
summary(l54)
</code></pre>

<hr>
<h2 id='eqc'>
Extract Equating Coefficients
</h2><span id='topic+eqc'></span><span id='topic+eqc.eqc'></span><span id='topic+eqc.eqclist'></span><span id='topic+eqc.ceqc'></span><span id='topic+eqc.ceqclist'></span><span id='topic+eqc.meqc'></span>

<h3>Description</h3>

<p><code>eqc</code> is a generic function which extracts the equating coefficients.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eqc(x, ...)

## S3 method for class 'eqc'
eqc(x, ...)

## S3 method for class 'eqclist'
eqc(x, link = NULL, ...)

## S3 method for class 'ceqc'
eqc(x, ...)

## S3 method for class 'ceqclist'
eqc(x, link = NULL, path = NULL, ...)

## S3 method for class 'meqc'
eqc(x, link = NULL, path = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="eqc_+3A_x">x</code></td>
<td>
<p>object of the class <code>eqc</code> returned by function <code><a href="#topic+direc">direc</a></code> 
or of the class <code>eqclist</code> returned by function <code><a href="#topic+alldirec">alldirec</a></code> 
or of the class <code>ceqc</code> and <code>ceqclist</code> returned by function <code><a href="#topic+chainec">chainec</a></code> 
or of the class <code>meqc</code> returned by function <code><a href="#topic+bisectorec">bisectorec</a></code>.</p>
</td></tr>
<tr><td><code id="eqc_+3A_link">link</code></td>
<td>
<p>a character string with the names of the two forms being linked separated by a dot (e.g. &quot;<code>test1.test3</code>&quot;).</p>
</td></tr>
<tr><td><code id="eqc_+3A_path">path</code></td>
<td>
<p>a character string with the names of the forms that constitute the path separated by a dot (e.g. &quot;<code>test1.test2.test3</code>&quot;).</p>
</td></tr>
<tr><td><code id="eqc_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the equating coefficients for every
link and path.
</p>


<h3>Author(s)</h3>

<p>Michela Battauz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+alldirec">alldirec</a></code>, <code><a href="#topic+bisectorec">bisectorec</a></code>, <code><a href="#topic+chainec">chainec</a></code>, <code><a href="#topic+direc">direc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># two-parameter logistic model
data(est2pl)
test&lt;-paste("test", 1:5, sep = "")
mod2pl &lt;- modIRT(coef = est2pl$coef, var = est2pl$var, names = test, display = FALSE)
# direct equating coefficients between forms 1 and 2 using the Haebara method
l12 &lt;- direc(mods = mod2pl, which = c(1,2), method = "Haebara")
# all direct equating coefficients using the Haebara method
direclist2pl &lt;- alldirec(mods = mod2pl, method = "Haebara")
# compute all chain equating coefficients of length 3
chainec3 &lt;- chainec(r = 3, direclist = direclist2pl)
# compute chain equating coefficients for path 1,2,3,4
pth1 &lt;- paste("test", 1:4, sep = "")
chainec1 &lt;- chainec(direclist = direclist2pl, pths = pth1)
# compute chain equating coefficients for path 1,5,4
pth2 &lt;- c(paste("test", c(1,5,4), sep = ""))
chainec2 &lt;- chainec(direclist = direclist2pl, pths = pth2)
# create a list of objects of class ceqc
ecall &lt;- c(chainec1, chainec2)
# compute bisector and weighted bisector coefficients
allec &lt;- bisectorec(ecall = ecall, weighted = TRUE, unweighted = TRUE)

# extract equating coefficients
eqc(l12)
eqc(direclist2pl)
eqc(direclist2pl, link = "test1.test2")
eqc(chainec3)
eqc(chainec3, link = "test1.test3")
eqc(allec)
eqc(allec, path = "bisector")
</code></pre>

<hr>
<h2 id='equateIRT-package'>
IRT Equating Methods
</h2><span id='topic+equateIRT-package'></span><span id='topic+equateIRT'></span>

<h3>Description</h3>

<p>This package computes direct, chain and average (bisector) equating coefficients 
with standard errors using IRT methods for dichotomous items. 
The IRT models included are the three-parameter logistic model,
the two-parameter logistic model, the one-parameter logistic model and the
Rasch model.
Test scoring can be performed by true score equating and observed score equating methods.
DIF detection can be performed using a Wald-type test.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> equateIRT</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 2.3.0</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2022-08-08</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>

<p>Direct equating coefficients and their standard errors
between forms presenting common items  
can be computed using function <code>direc</code>.
The equating methods implemented are 
&quot;mean-mean&quot;, &quot;mean-geometric mean&quot;, &quot;mean-sigma&quot;, &quot;Haebara&quot; and &quot;Stocking-Lord&quot;.
Estimates of item parameters and their covariance matrix can be imported
from the R packages <code>ltm</code> and <code>mirt</code> or from the IRT programs IRTPRO and flexMIRT using
functions <code>import.ltm</code>, <code>import.mirt</code>, <code>import.irtpro</code> and <code>import.flexmirt</code>.
Item parameter estimates from other software can be imported as well
by the user.
Data should be previously organized using function <code>modIRT</code>.
Function <code>alldirec</code> computes all direct equating coefficients
(with standard errors) between all pairs of a list of forms.
Function <code>chainec</code> computes chain equating coefficients
(and standard errors)
given direct equating coefficients between forms directly linked.
Average equating coefficients with standard errors 
can be calculated using function <code>bisectorec</code>, that 
implements the (weighted) bisector method.
Once the equating coefficients are obtained, the computation of 
equated scores can be performed using function <code>score</code>,
which implements true score equating and observed score equating.
Standard errors of equated scores are also provided.
Three simulated datasets are available for illustrative purposes.
These datasets contain item parameter coefficients and their 
covariance matrix. In particular, <code>est3pl</code> concerns a 
three-parameter logistic model, <code>est2pl</code> regards a 
two-parameter logistic model, and <code>estrasch</code> refers to
a Rasch model.
The estimates included in <code>est2pl</code> are obtained from the
dataset <code>data2pl</code>, also contained in the package.
Function <code>dif.test</code> performs a Wald-type test for the 
detection of DIF (Battauz, 2018).
The stability of the equating transformations can be assessed using
function <code>sd.test</code>, which tests if the equating coefficients
that link the same two forms are equal, and function <code>id.test</code>,
which tests if the equating coefficients that link a form to itself
through a chain of forms return the identity equating.
</p>


<h3>Author(s)</h3>

<p>Michela Battauz
</p>
<p>Maintainer: Michela Battauz &lt;michela.battauz@uniud.it&gt;
</p>


<h3>References</h3>

<p>Battauz, M. (2013). IRT Test Equating in Complex Linkage Plans. 
<em>Psychometrika</em>, <b>78</b>, 464&ndash;480.
</p>
<p>Battauz, M. (2015). equateIRT: An R Package for IRT Test Equating.
<em>Journal of Statistical Software</em>, <b>68</b>, 1&ndash;22.
</p>
<p>Battauz, M. (2019). On Wald tests for differential item functioning detection.
<em>Statistical Methods and Applications</em>. <b>28</b>, 103&ndash;118.
</p>
<p>Battauz, M. (2022). Testing for differences in chain equating. 
<em>Statistica Neerlandica</em>, 1&ndash;12.
</p>
<p>Cai L. (2013). <em>FlexMIRT version 2: Flexible Multilevel Multidimensional Item Analysis and
Test Scoring [Computer Software]</em>. Chapel Hill, NC: Vector Psychometric Group.
</p>
<p>Cai, L., du Toit, S. H. C., Thissen, D. (2011). <em>IRTPRO: Flexible, multidimensional, multiple 
categorical IRT modeling [Computer software]</em>. Chicago: Scientific Software International.
</p>
<p>Chalmers, R. P. (2012). mirt: A Multidimensional Item Response Theory Package for the 
R Environment. <em>Journal of Statistical Software</em>, 
<b>48</b>, 1&ndash;29.
</p>
<p>Holland, P.W. and Strawderman, W.E. (2011). How to average equating 
functions if you must. In A.A. von Davier (Ed.), <em>Statistical models for 
test equating, scaling, and linking</em> (pp. 89&ndash;107). New York: Springer.
</p>
<p>Kolen, M.J. and Brennan, R.L. (2014). <em>Test equating, scaling, 
and linking: methods and practices</em>, 3rd ed., New York: Springer.
</p>
<p>Ogasawara, H. (2000). Asymptotic standard errors of IRT equating coefficients 
using moments. <em>Economic Review (Otaru University of Commerce)</em>, 
<b>51</b>, 1&ndash;23.
</p>
<p>Ogasawara, H. (2001a). Item response theory true score equatings and
their standard errors. <em>Journal of Educational and Behavioral Statistics</em>, 
<b>26</b>, 31&ndash;50.
</p>
<p>Ogasawara, H. (2001b). Standard Errors of Item Response Theory Equating/Linking
by Response Function Methods. <em>Applied Psychological Measurement</em>, 
<b>25</b>, 53&ndash;67.
</p>
<p>Ogasawara, H. (2003). Asymptotic standard errors of IRT 
observed-score equating methods. <em>Psychometrika</em>, 
<b>68</b>, 193&ndash;211.
</p>
<p>Rizopoulos, D. (2006). ltm: an R package for latent variable modelling 
and item response theory analyses. <em>Journal of Statistical Software</em>, 
<b>17</b>, 1&ndash;25.
</p>

<hr>
<h2 id='est2pl'>
Item Parameter Estimates and Covariance Matrices of a Two-Parameter Logistic Model
</h2><span id='topic+est2pl'></span>

<h3>Description</h3>

<p>This dataset includes item parameter estimates and covariance matrices of a
two-parameter logistic model applied to 5 simulated datasets with common items.
The dichotomous item responses can be found in the dataset <code>data2pl</code>.
See details for more information on the linkage plan.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(est2pl)
</code></pre>


<h3>Format</h3>

<p>A list of length 2 with components:
</p>

<dl>
<dt><code>coef</code></dt><dd><p>a list of length 5 containing the matrices of item parameter 
estimates. Each matrix presents 2 columns; the first column contains 
difficulty parameters and the second
column contains discrimination parameters. See details for information on
the parameterization used. Names of rows correspond to the
names of the items.</p>
</dd>
<dt><code>var</code></dt><dd><p>a list of length 5 containing the covariance matrices of 
item parameter estimates.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Every form is composed by 20 items and presents 10 items in common
with adjacent forms. Furthermore, forms 1 and 5 present 10 common items.
Use <code><a href="#topic+linkp">linkp</a></code> to obtain a matrix with elements equal to the
number of common items between different forms.
</p>
<p>Item parameters are given under the parameterization used in the <code>ltm</code> package. 
Under this parameterization, the two-parameter logistic model is as follows
</p>
<p style="text-align: center;"><code class="reqn">\pi_i = \frac{\exp(\beta_{1i} + \beta_{2i} z)}{1 + 
	\exp(\beta_{1i} + \beta_{2i} z)},</code>
</p>
<p> where 
<code class="reqn">\pi_i</code> denotes the conditional probability of responding 
correctly to the <code class="reqn">i</code>th item given <code class="reqn">z</code>, 
<code class="reqn">\beta_{1i}</code> is the easiness parameter, 
<code class="reqn">\beta_{2i}</code> is the discrimination parameter, and <code class="reqn">z</code> denotes the 
latent ability.
</p>


<h3>Author(s)</h3>

<p>Michela Battauz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+data2pl">data2pl</a></code>, <code><a href="#topic+linkp">linkp</a></code>, <code><a href="#topic+modIRT">modIRT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(est2pl)
est2pl$coef
est2pl$var
linkp(coef = est2pl$coef)
</code></pre>

<hr>
<h2 id='est3pl'>
Item Parameter Estimates and Covariance Matrices of a Three-Parameter Logistic Model
</h2><span id='topic+est3pl'></span>

<h3>Description</h3>

<p>This dataset includes item parameter estimates and covariance matrices of a
three-parameter logistic model applied to 5 simulated datasets with common items.
See details for more information on the linkage plan.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(est3pl)
</code></pre>


<h3>Format</h3>

<p>A list of length 2 with components:
</p>

<dl>
<dt><code>coef</code></dt><dd><p>a list of length 5 containing the matrices of item parameter 
estimates. Each matrix presents 3 columns; the first column contains guessing
parameters, the second column contains difficulty parameters and the third
column contains discrimination parameters. See details for information on
the parameterization used. Names of rows correspond to the
names of the items.</p>
</dd>
<dt><code>var</code></dt><dd><p>a list of length 5 containing the covariance matrices of 
item parameter estimates.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Every form is composed by 20 items and presents 10 items in common
with adjacent forms. Furthermore, forms 1 and 5 present 10 common items.
Use <code><a href="#topic+linkp">linkp</a></code> to obtain a matrix with elements equal to the
number of common items between different forms.
</p>
<p>Item parameters are given under the parameterization used in the <code>ltm</code> package. 
Under this parameterization, the three-parameter logistic model is as follows
</p>
<p style="text-align: center;"><code class="reqn">\pi_i = c_i + (1 - c_i) \frac{\exp(\beta_{1i} + \beta_{2i} z)}{1 + 
    \exp(\beta_{1i} + \beta_{2i} z)},</code>
</p>
<p> where 
<code class="reqn">\pi_i</code> denotes the conditional probability of responding correctly to the <code class="reqn">i</code>th item given <code class="reqn">z</code>, 
<code class="reqn">c_i</code> denotes the guessing parameter, <code class="reqn">\beta_{1i}</code> is the easiness parameter, 
<code class="reqn">\beta_{2i}</code> is the discrimination parameter, and <code class="reqn">z</code> denotes the 
latent ability.
Furthermore, the guessing parameters are given under this parameterization
</p>
<p style="text-align: center;"><code class="reqn">c_i = \frac{\exp(c_i^*)}{1+\exp(c_i^*)}. </code>
</p>



<h3>Author(s)</h3>

<p>Michela Battauz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linkp">linkp</a></code>, <code><a href="#topic+modIRT">modIRT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(est3pl)
est3pl$coef
est3pl$var
linkp(coef = est3pl$coef)
</code></pre>

<hr>
<h2 id='estrasch'>
Item Parameter Estimates and Covariance Matrices of a Rasch Model
</h2><span id='topic+estrasch'></span>

<h3>Description</h3>

<p>This dataset includes item parameter estimates and covariance matrices of a
Rasch model applied to 5 simulated datasets with common items.
See details for more information on the linkage plan.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(estrasch)
</code></pre>


<h3>Format</h3>

<p>A list of length 2 with components:
</p>

<dl>
<dt><code>coef</code></dt><dd><p>a list of length 5 containing the matrices of item parameter 
estimates. Each matrix presents 2 columns; the first column contains 
difficulty parameters and the second column is equal to 1. 
See details for information on the parameterization used. 
Names of rows correspond to the	names of the items.</p>
</dd>
<dt><code>var</code></dt><dd><p>a list of length 5 containing the covariance matrices of 
item parameter estimates.</p>
</dd>
</dl>



<h3>Details</h3>

<p>Every form is composed by 20 items and presents 10 items in common
with adjacent forms. Furthermore, forms 1 and 5 present 10 common items.
Use <code><a href="#topic+linkp">linkp</a></code> to obtain a matrix with elements equal to the
number of common items between different forms.
</p>
<p>Item parameters are given under the parameterization used in the <code>ltm</code> package. 
Under this parameterization, the Rasch model is as follows
</p>
<p style="text-align: center;"><code class="reqn">\pi_i = \frac{\exp(\beta_{1i} + z)}{1 + \exp(\beta_{1i} + z)},</code>
</p>
 
<p>where <code class="reqn">\pi_i</code> denotes the conditional probability of responding correctly to the <code class="reqn">i</code>th item given <code class="reqn">z</code>, 
<code class="reqn">\beta_{1i}</code> is the easiness parameter, and <code class="reqn">z</code> denotes the 
latent ability.
</p>


<h3>Author(s)</h3>

<p>Michela Battauz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+linkp">linkp</a></code>, <code><a href="#topic+modIRT">modIRT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(estrasch)
estrasch$coef
estrasch$var
linkp(coef = estrasch$coef)
</code></pre>

<hr>
<h2 id='id.test'>
Identity Test
</h2><span id='topic+id.test'></span><span id='topic+print.idtest'></span>

<h3>Description</h3>

<p>Performs a statistical test to verify if the chain equating coeffients from
one form to itself are A=1 and B=0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>id.test(chain)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="id.test_+3A_chain">chain</code></td>
<td>
<p>an object of the class <code>ceqc</code> returned by function
<code><a href="#topic+chainec">chainec</a></code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>idtest</code> with components
</p>
<table>
<tr><td><code>path</code></td>
<td>
</td></tr>
<tr><td><code>AB</code></td>
<td>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
</td></tr>
<tr><td><code>df</code></td>
<td>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michela Battauz
</p>


<h3>References</h3>

<p>Battauz, M. (2022). Testing for differences in chain equating. 
<em>Statistica Neerlandica</em>, 1-12.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># three-parameter logistic model
# direct equating coefficients using the "Haebara" method
data(est3pl)
test &lt;- paste("test", 1:5, sep = "")
mod3pl &lt;- modIRT(coef = est3pl$coef, var = est3pl$var, names = test, display = FALSE)
direclist3pl &lt;- alldirec(mods = mod3pl, method = "Haebara")
# compute chain equating coefficients for path 1,2,3,4,5,1
pth3 &lt;- paste("test", c(1:5,1), sep = "")
chainec_circle &lt;- chainec(direclist = direclist3pl, pths = pth3)
summary(chainec_circle)
# test
id.test(chainec_circle)
</code></pre>

<hr>
<h2 id='import.ltm'>
Import Item Parameters Estimates and Covariance Matrices from IRT Software
</h2><span id='topic+import.ltm'></span><span id='topic+import.mirt'></span><span id='topic+import.irtpro'></span><span id='topic+import.flexmirt'></span>

<h3>Description</h3>

<p>Import estimated item parameters and covariance matrix from the R packages ltm
and mirt, and from external software IRTPRO and flexMIRT.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>import.ltm(mod, display = TRUE, digits = 4) 

import.mirt(mod, display = TRUE, digits = 3) 

import.irtpro(fnamep, fnamev = NULL, fnameirt = NULL, display = TRUE, digits = 2) 

import.flexmirt(fnamep, fnamev = NULL, fnameirt = NULL, display = TRUE, digits = 2) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="import.ltm_+3A_mod">mod</code></td>
<td>
<p>output object from functions <code>rasch</code>, <code>ltm</code>, or <code>tpm</code> 
of the <code>ltm</code> package or from function <code>mirt</code> of the <code>mirt</code> package.</p>
</td></tr>
<tr><td><code id="import.ltm_+3A_display">display</code></td>
<td>
<p>logical; if TRUE coefficients and standard errors are printed.</p>
</td></tr>
<tr><td><code id="import.ltm_+3A_digits">digits</code></td>
<td>
<p>integer indicating the number of decimal places to be used
if <code>display</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="import.ltm_+3A_fnamep">fnamep</code></td>
<td>
<p>name of the file containing the estimated item parameters. Typically, -prm.txt.</p>
</td></tr>
<tr><td><code id="import.ltm_+3A_fnamev">fnamev</code></td>
<td>
<p>name of the file containing the covariance matrix of the estimated item parameters. 
Typically, -cov.txt.</p>
</td></tr>
<tr><td><code id="import.ltm_+3A_fnameirt">fnameirt</code></td>
<td>
<p>name of the file containing additional information to link item parameters with 
the covariance matrix. Typically, -irt.txt.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Item parameters are imported with the parameterization used by the software to
estimate the IRT model. The usual IRT parameterization can be obtained later
by using function <code><a href="#topic+modIRT">modIRT</a></code>.
</p>


<h3>Value</h3>

<p>A list with components
</p>
<table>
<tr><td><code>coef</code></td>
<td>
<p>item parameter estimates.</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>covariance matrix of item parameter estimates.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michela Battauz
</p>


<h3>References</h3>

<p>Battauz, M. (2015). equateIRT: An R Package for IRT Test Equating.
<em>Journal of Statistical Software</em>, <b>68</b>, 1&ndash;22.
</p>
<p>Cai L. (2013). <em>FlexMIRT version 2: Flexible Multilevel Multidimensional Item Analysis and
Test Scoring [Computer Software]</em>. Chapel Hill, NC: Vector Psychometric Group.
</p>
<p>Cai, L., du Toit, S. H. C., Thissen, D. (2011). <em>IRTPRO: Flexible, multidimensional, multiple 
categorical IRT modeling [Computer software]</em>. Chicago: Scientific Software International.
</p>
<p>Chalmers, R. P. (2012). mirt: A Multidimensional Item Response Theory Package for the 
R Environment. <em>Journal of Statistical Software</em>, 
<b>48</b>, 1&ndash;29.
</p>
<p>Rizopoulos, D. (2006). ltm: an R package for latent variable modelling 
and item response theory analyses. <em>Journal of Statistical Software</em>, 
<b>17</b>, 1&ndash;25.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+modIRT">modIRT</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
#====================
# from package ltm
library(ltm)

# one-parameter logistic model
mod1pl &lt;- rasch(LSAT)
est.mod1pl &lt;- import.ltm(mod1pl)
est.mod1pl

# two-parameter logistic model
mod2pl &lt;- ltm(LSAT ~ z1)
est.mod2pl &lt;- import.ltm(mod2pl)
est.mod2pl

#====================
# from package mirt
library(mirt)

# one-parameter logistic model
data(LSAT, package = "ltm")
val &lt;- mirt(LSAT, 1, SE = TRUE, pars = "values")
cnstr &lt;- val[val$name == "a1",]$parnum
mod1pl.m &lt;- mirt(LSAT, 1, SE = TRUE, SE.type = 'Richardson', constrain = list(cnstr))
est.mod1pl.m &lt;- import.mirt(mod1pl.m, digits = 4)
est.mod1pl.m

# two-parameter logistic model
data(LSAT, package = "ltm")
mod2pl.m &lt;- mirt(LSAT, 1, SE = TRUE, SE.type = 'Richardson')
est.mod2pl.m &lt;- import.mirt(mod2pl.m, display = FALSE)
est.mod2pl.m

</code></pre>

<hr>
<h2 id='itm'>
Extract Item Parameters
</h2><span id='topic+itm'></span><span id='topic+itm.eqc'></span><span id='topic+itm.eqclist'></span><span id='topic+itm.ceqc'></span><span id='topic+itm.ceqclist'></span><span id='topic+itm.meqc'></span>

<h3>Description</h3>

<p><code>itm</code> is a generic function which extracts a data frame containing the
item parameters of two forms being equated in the original scale and 
item parameters of the first form converted in the scale of the second form.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>itm(x, ...)

## S3 method for class 'eqc'
itm(x, ...)

## S3 method for class 'eqclist'
itm(x, link, ...)

## S3 method for class 'ceqc'
itm(x, ...)

## S3 method for class 'ceqclist'
itm(x, path, ...)

## S3 method for class 'meqc'
itm(x, link, bistype = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="itm_+3A_x">x</code></td>
<td>
<p>object of the class <code>eqc</code> returned by function <code><a href="#topic+direc">direc</a></code> 
or of the class <code>eqclist</code> returned by function <code><a href="#topic+alldirec">alldirec</a></code> 
or of the class <code>ceqc</code> and <code>ceqclist</code> returned by function <code><a href="#topic+chainec">chainec</a></code>
or of the class <code>meqc</code> return by function <code><a href="#topic+bisectorec">bisectorec</a></code>.</p>
</td></tr>
<tr><td><code id="itm_+3A_link">link</code></td>
<td>
<p>a character string with the names of the two forms being linked separated by a dot (e.g. &quot;<code>test1.test3</code>&quot;).</p>
</td></tr>
<tr><td><code id="itm_+3A_path">path</code></td>
<td>
<p>a character string with the names of the forms that constitute the path separated by a dot (e.g. &quot;<code>test1.test2.test3</code>&quot;).</p>
</td></tr>
<tr><td><code id="itm_+3A_bistype">bistype</code></td>
<td>
<p>bisector type. It should be <code>weighted</code> or <code>unweighted</code>. 
It could be <code>NULL</code> if only one type was computed by function <code><a href="#topic+bisectorec">bisectorec</a></code>.</p>
</td></tr>
<tr><td><code id="itm_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing item names (<code>Item</code>), 
item parameters of the first form (e.g. <code>test1</code>), 
item parameters of the last form (e.g. <code>test3</code>), 
and item parameters of the first form converted 
in the scale of the last form (e.g. <code>test1.as.test3</code>).	
</p>


<h3>Author(s)</h3>

<p>Michela Battauz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+convert">convert</a></code>, <code><a href="#topic+alldirec">alldirec</a></code>, <code><a href="#topic+bisectorec">bisectorec</a></code>, <code><a href="#topic+chainec">chainec</a></code>, <code><a href="#topic+direc">direc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># two-parameter logistic model
data(est2pl)
test&lt;-paste("test", 1:5, sep = "")
mod2pl &lt;- modIRT(coef = est2pl$coef, var = est2pl$var, names = test, display = FALSE)
# direct equating coefficients between forms 1 and 2 using the Haebara method
l12 &lt;- direc(mods = mod2pl, which = c(1,2), method = "Haebara")
# all direct equating coefficients using the Haebara method
direclist2pl &lt;- alldirec(mods = mod2pl, method = "Haebara")
# compute all chain equating coefficients of length 3
chainec3 &lt;- chainec(r = 3, direclist = direclist2pl)
# compute chain equating coefficients for path 1,2,3,4
pth1 &lt;- paste("test", 1:4, sep = "")
chainec1 &lt;- chainec(direclist = direclist2pl, pths = pth1)
# compute chain equating coefficients for path 1,5,4
pth2 &lt;- c(paste("test", c(1,5,4), sep = ""))
chainec2 &lt;- chainec(direclist = direclist2pl, pths = pth2)
# create a list of objects of class ceqc
ecall &lt;- c(chainec1, chainec2)
# compute bisector and weighted bisector coefficients
allec &lt;- bisectorec(ecall = ecall, weighted = TRUE, unweighted = TRUE)

# extract item parameters
itm(l12)
itm(direclist2pl, link = "test1.test2")
itm(chainec3, path = "test1.test2.test3")
itm(allec, bistype = "weighted")
</code></pre>

<hr>
<h2 id='linkp'>
Linkage Plan
</h2><span id='topic+linkp'></span>

<h3>Description</h3>

<p>Calculates the number of common items between a list of forms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>linkp(coef)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="linkp_+3A_coef">coef</code></td>
<td>
<p>list of matrices (one for each form) containing item
parameter estimates. The names of the rows of each matrix should 
be the names of the items.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix whose elements indicate the number of common items between
the forms. On the diagonal of the matrix there are the number of items
of each form.
</p>


<h3>Author(s)</h3>

<p>Michela Battauz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+est2pl">est2pl</a></code>, <code><a href="#topic+est3pl">est3pl</a></code>, <code><a href="#topic+estrasch">estrasch</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(est3pl)
linkp(coef = est3pl$coef)
</code></pre>

<hr>
<h2 id='modIRT'>
Estimated Coefficients and Covariance Matrix of IRT Models 
</h2><span id='topic+modIRT'></span>

<h3>Description</h3>

<p>Creates an object of the class <code>modIRT</code> containing estimated
coefficients and covariance matrices of IRT models. 
Rasch, one-parameter logistic, two-parameter logistic and three-parameter 
logistic models	are included.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>modIRT(coef, var = NULL, names = NULL, ltparam = TRUE, lparam = TRUE, 
	display = TRUE, digits = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="modIRT_+3A_coef">coef</code></td>
<td>
<p>list of matrices (one for each form) containing 
item parameter estimates. Guessing, difficulty and discrimination 
parameters should strictly be given in this order and they are 
contained in different columns of the matrix.
The names of the	rows of each matrix should be the names of the items.</p>
</td></tr>
<tr><td><code id="modIRT_+3A_var">var</code></td>
<td>
<p>list of matrices (one for each form) containing the 
covariance matrix of item parameter estimates. They should be
given in the same order of coefficients.</p>
</td></tr>
<tr><td><code id="modIRT_+3A_names">names</code></td>
<td>
<p>character vector containing the names of the forms. 
This should have the same length of <code>coef</code> and <code>var</code>.
If NULL, the names of the forms are assigned by 
function <code>modIRT</code>.</p>
</td></tr>
<tr><td><code id="modIRT_+3A_ltparam">ltparam</code></td>
<td>
<p>logical; if TRUE the latent trait parameterization is used
for difficulty parameters and the <code>modIRT</code> function performs a 
transformation of item parameters to return them in the usual IRT
parameterization. Set to FALSE to avoid transformations. See below for more details.</p>
</td></tr>
<tr><td><code id="modIRT_+3A_lparam">lparam</code></td>
<td>
<p>logical; if TRUE the logistic parameterization is used
for guessing parameters and the <code>modIRT</code> function performs a 
transformation of item parameters to return them in the usual IRT
parameterization. Set to FALSE to avoid transformations. See below for more details.</p>
</td></tr>
<tr><td><code id="modIRT_+3A_display">display</code></td>
<td>
<p>logical; if TRUE coefficients and standard errors are printed.</p>
</td></tr>
<tr><td><code id="modIRT_+3A_digits">digits</code></td>
<td>
<p>integer indicating the number of decimal places to be used
if <code>display</code> is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>ltparam</code> and <code>lparam</code> refers the the parameterization used
by the software used to estimate item parameters. The R package <code>ltm</code>,
and the programs IRTPRO and flexMIRT use these parameterizations.
If <code>ltparam</code> is <code>TRUE</code> the latent trait parameterization is used. 
Under this parameterization, the three-parameter logistic model is as follows
</p>
<p style="text-align: center;"><code class="reqn">\pi_i = c_i + (1 - c_i) \frac{\exp(\beta_{1i} + \beta_{2i} z)}{1 + 
	\exp(\beta_{1i} + \beta_{2i} z)},</code>
</p>
<p> where 
<code class="reqn">\pi_i</code> denotes the conditional probability of responding correctly to the <code class="reqn">i</code>th item given <code class="reqn">z</code>, 
<code class="reqn">c_i</code> denotes the guessing parameter, <code class="reqn">\beta_{1i}</code> is the easiness parameter, 
<code class="reqn">\beta_{2i}</code> is the discrimination parameter, and <code class="reqn">z</code> denotes the 
latent ability.
The two-parameter logistic model, the one-parameter logistic model 
and the Rasch model present the same
formulation. The two-parameter logistic model can be obtained 
by setting <code class="reqn">c_i</code> equal to zero,
the one-parameter logistic model can be obtained 
by setting <code class="reqn">c_i</code> equal to zero and <code class="reqn">\beta_{2i}</code> 
costant across items,
while the Rasch model can be obtained by setting <code class="reqn">c_i</code> 
equal to zero and <code class="reqn">\beta_{2i}</code> equal to 1.
</p>
<p>If <code>lparam</code> is TRUE the guessing parameters are given under this
parameterization
</p>
<p style="text-align: center;"><code class="reqn">c_i = \frac{\exp(c_i^*)}{1+\exp(c_i^*)}. </code>
</p>

<p>The <code>modIRT</code> function returns parameter estimates
under the usual IRT parameterization, that is,
</p>
<p style="text-align: center;"><code class="reqn">\pi_i = c_i + (1 - c_i) \frac{\exp[D a_i (\theta - b_i)]}{1 + 
	\exp[D a_i (\theta - b_i)]},</code>
</p>

<p>where <code class="reqn">D a_i = \beta_{2i}</code>, <code class="reqn">b_i = -\beta_{1i}/\beta_{2i}</code> and
<code class="reqn">\theta = z</code>.
</p>
<p>If <code>ltparam</code> or <code>lparam</code> are TRUE, the covariance matrix 
is calculated using the delta method.
</p>
<p>If item parameters are already given under the usual IRT parameterization,
arguments <code>ltparam</code> and <code>lparam</code> should be set to <code>FALSE</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>modIRT</code> consisting in a list with length equal
to the number of forms containing lists with components
</p>
<table>
<tr><td><code>coefficients</code></td>
<td>
<p>item parameter estimates.</p>
</td></tr>
<tr><td><code>var</code></td>
<td>
<p>covariance matrix of item parameter estimates.</p>
</td></tr>
<tr><td><code>itmp</code></td>
<td>
<p>number of item parameters of the IRT model. This is 1 for the 
Rasch model, 2 for the one-parameter logistic model with constant discriminations, 
2 for the	two-parameter logistic model and 3 for the three-parameter logistic
model.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michela Battauz
</p>


<h3>References</h3>

<p>Battauz, M. (2015). equateIRT: An R Package for IRT Test Equating.
<em>Journal of Statistical Software</em>, <b>68</b>, 1&ndash;22.
</p>
<p>Bartholomew, D., Knott, M. and Moustaki, I. (2011) 
<em>Latent Variable Models and Factor Analysis: 
a Unified Approach</em>, 3rd ed. Wiley.
</p>
<p>Rizopoulos, D. (2006). ltm: an R package for latent variable modelling 
and item response theory analyses. <em>Journal of Statistical Software</em>, 
<b>17</b>, 1&ndash;25.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+direc">direc</a></code>, <code><a href="#topic+import.ltm">import.ltm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># three-parameter logistic model
data(est3pl)
test &lt;- paste("test", 1:5, sep = "")
mod3pl &lt;- modIRT(coef = est3pl$coef, var = est3pl$var, names = test, display = FALSE)

# two-parameter logistic model
data(est2pl)
test &lt;- paste("test", 1:5, sep = "")
mod2pl &lt;- modIRT(coef = est2pl$coef, var = est2pl$var, names = test, display = FALSE)

# Rasch model
data(estrasch)
test &lt;- paste("test", 1:5, sep = "")
modrasch &lt;- modIRT(coef = estrasch$coef, var = estrasch$var, names = test, 
	display = FALSE)

# one-parameter logistic model imported from the R package ltm
library(ltm)
mod1pl &lt;- rasch(LSAT)
summary(mod1pl)
est.mod1pl &lt;- import.ltm(mod1pl)
mod1pl.ltm &lt;- modIRT(coef = list(est.mod1pl$coef), var = list(est.mod1pl$var), digits = 4)

</code></pre>

<hr>
<h2 id='score'>
Scoring
</h2><span id='topic+score'></span><span id='topic+score.eqc'></span><span id='topic+score.eqclist'></span><span id='topic+score.ceqc'></span><span id='topic+score.ceqclist'></span><span id='topic+score.meqc'></span>

<h3>Description</h3>

<p>Relates number-correct scores on two forms.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score(obj, ...)

## S3 method for class 'eqc'
score(obj, method = "TSE", D = 1, scores = NULL, se = TRUE, nq = 30, 
  w = 0.5, theta = NULL, weights = NULL, anchor.type = "internal", ...)

## S3 method for class 'eqclist'
score(obj, link = NULL, method = "TSE", D = 1, scores = NULL, se = TRUE, nq = 30, 
  w = 0.5, theta = NULL, weights = NULL, anchor.type = "internal", ...)

## S3 method for class 'ceqc'
score(obj, method = "TSE", D = 1, scores = NULL, se = TRUE, nq = 30, 
  w = 0.5, theta = NULL, weights = NULL, anchor.type = "internal", ...)

## S3 method for class 'ceqclist'
score(obj, path = NULL, method = "TSE", D = 1, scores = NULL, se = TRUE, nq = 30, 
  w = 0.5, theta = NULL, weights = NULL, anchor.type = "internal", ...)

## S3 method for class 'meqc'
score(obj, link = NULL, method = "TSE", D = 1, scores = NULL, se = TRUE, 
  bistype = NULL, nq = 30, w = 0.5, theta = NULL, weights = NULL, 
  anchor.type = "internal", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="score_+3A_obj">obj</code></td>
<td>
<p>output object from functions <code><a href="#topic+direc">direc</a></code>, 
<code><a href="#topic+alldirec">alldirec</a></code>, <code><a href="#topic+chainec">chainec</a></code> or <code><a href="#topic+bisectorec">bisectorec</a></code>.</p>
</td></tr>
<tr><td><code id="score_+3A_link">link</code></td>
<td>
<p>a character string with the names of the two forms 
being linked separated by a dot (e.g. &quot;<code>test1.test3</code>&quot;). 
Necessary if <code>obj</code> is output of functions <code>alldirec</code> or <code>bisectorec</code>.</p>
</td></tr>
<tr><td><code id="score_+3A_path">path</code></td>
<td>
<p>a character string with the names of the forms that constitute 
the path separated by a dot (e.g. &quot;<code>test1.test2.test3</code>&quot;).
Necessary if <code>obj</code> is output of function <code>chainec</code>.</p>
</td></tr>
<tr><td><code id="score_+3A_method">method</code></td>
<td>
<p>the scoring method to be used. This should be one of &quot;<code>TSE</code>&quot; 
(the default) for true score equating or &quot;<code>OSE</code>&quot; for observed score equating.</p>
</td></tr>
<tr><td><code id="score_+3A_d">D</code></td>
<td>
<p>constant D of the IRT model used to estimate item parameters.</p>
</td></tr>
<tr><td><code id="score_+3A_scores">scores</code></td>
<td>
<p>integer values to be converted.</p>
</td></tr>
<tr><td><code id="score_+3A_se">se</code></td>
<td>
<p>logical; is <code>TRUE</code> standard errors of equated scores are computed.</p>
</td></tr>
<tr><td><code id="score_+3A_bistype">bistype</code></td>
<td>
<p>bisector type. It should be specified when <code>obj</code> is an output
object from function <code><a href="#topic+bisectorec">bisectorec</a></code>.
It should be <code>weighted</code> or <code>unweighted</code>. 
It can be <code>NULL</code> if only one type was computed by function <code><a href="#topic+bisectorec">bisectorec</a></code>.</p>
</td></tr>
<tr><td><code id="score_+3A_nq">nq</code></td>
<td>
<p>number of quadrature points used to approximate integrals with observed score equating. 
Used only if arguments <code>theta</code> and <code>weights</code> are <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="score_+3A_w">w</code></td>
<td>
<p>synthetic weight for population 1. It should be a number between 0 and 1.</p>
</td></tr>
<tr><td><code id="score_+3A_theta">theta</code></td>
<td>
<p>vector of ability values used to approximate integrals with observed score equating.</p>
</td></tr>
<tr><td><code id="score_+3A_weights">weights</code></td>
<td>
<p>vector of weights used to approximate integrals with observed score equating.</p>
</td></tr>
<tr><td><code id="score_+3A_anchor.type">anchor.type</code></td>
<td>
<p>The anchor type, which can be &quot;<code>internal</code>&quot; or &quot;<code>external</code>&quot;.
External anchors are not implemented for bisector equating coefficients. See details.</p>
</td></tr>
<tr><td><code id="score_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>anchor.type</code> is <code>internal</code>, the common items are used for 
computing the scores; if it is <code>external</code>, the common items are used
for computing the equating coefficients but not for computing the scores.
External anchors are not implemented for bisector equating coefficients 
because it is possible that all items are used as achors in one of the paths
considered.
</p>
<p>This function computes standard error of equated scores with the observed score equating method
using <code class="reqn">(\alpha_X',\alpha_{V1}',A,B)'</code> for the description of <code class="reqn">\beta_{X2,x}(At_m+B)</code>, and
<code class="reqn">(\alpha_Y',\alpha_{V2}',A,B)'</code> for <code class="reqn">\beta_{Y1,y}(t_m)</code>
(see Ogasawara, 2003).
</p>


<h3>Value</h3>

<p>A data frame containing theta values (only for true score equating),
scores in the form chosen as base,
equated scores,
and standard errors of equated scores.
</p>


<h3>Author(s)</h3>

<p>Michela Battauz
</p>


<h3>References</h3>

<p>Kolen, M.J. and Brennan, R.L. (2014). <em>Test equating, scaling, 
and linking: methods and practices</em>, 3nd ed., New York: Springer.
</p>
<p>Ogasawara, H. (2001). Item response theory true score equatings and
their standard errors. <em>Journal of Educational and Behavioral Statistics</em>, 
<b>26</b>, 31&ndash;50.
</p>
<p>Ogasawara, H. (2003). Asymptotic standard errors of IRT 
observed-score equating methods. <em>Psychometrika</em>, 
<b>68</b>, 193&ndash;211.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+alldirec">alldirec</a></code>, <code><a href="#topic+bisectorec">bisectorec</a></code>, <code><a href="#topic+chainec">chainec</a></code>, <code><a href="#topic+direc">direc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># two-parameter logistic model
data(est2pl)
test&lt;-paste("test", 1:5, sep = "")
mod2pl &lt;- modIRT(coef = est2pl$coef, var = est2pl$var, names = test, display = FALSE)
# direct equating coefficients between forms 1 and 2 using the Haebara method
l12 &lt;- direc(mods = mod2pl, which = c(1,2), method = "Haebara")
# scoring using direct equating coefficients and the true score equating method
score(l12)
# scoring using direct equating coefficients and the observed score equating method
score(l12, method = "OSE")
# specify only scores from 10 to 15
score(l12, method = "OSE", scores = 10:15)
# external anchors and true score equating method
score(l12, anchor.type = "external")
# external anchors and observed score equating method
score(l12, method = "OSE", anchor.type = "external")

# all direct equating coefficients using the Haebara method
direclist2pl &lt;- alldirec(mods = mod2pl, method = "Haebara")
# scoring using direct equating coefficients and the true score equating method
score(direclist2pl, link = "test1.test2")

# compute chain equating coefficients for path 1,2,3,4
pth1 &lt;- paste("test", 1:4, sep = "")
chainec1 &lt;- chainec(direclist = direclist2pl, pths = pth1)
# compute chain equating coefficients for path 1,5,4
pth2 &lt;- paste("test", c(1,5,4), sep = "")
chainec2 &lt;- chainec(direclist = direclist2pl, pths = pth2)
# scoring using chain equating coefficients and the true score equating method for score 12
score(chainec1, path = "test1.test2.test3.test4", scores = 12)
score(chainec2, path = "test1.test5.test4", scores = 12)
# scoring using chain equating coefficients, true score equating and external anchors
score(chainec1, path = "test1.test2.test3.test4", anchor.type = "external")
# scoring using chain equating coefficients, observed score equating and external anchors
score(chainec1, path = "test1.test2.test3.test4", method = "OSE", anchor.type = "external")


# create a list of objects of class ceqc
ecall &lt;- c(chainec1, chainec2)
# compute bisector and weighted bisector coefficients
allec &lt;- bisectorec(ecall = ecall, weighted = TRUE, unweighted = TRUE)
# scoring using weighted bisector equating coefficients and the true score 
# equating method for score 12
score(allec, bistype = "weighted", link = "test1.test4", scores = 12)
</code></pre>

<hr>
<h2 id='sd.test'>
Test on Chain Equating Coefficients
</h2><span id='topic+sd.test'></span><span id='topic+print.sdtest'></span>

<h3>Description</h3>

<p>Performs a statistical test to verify if the chain equating coeffients that
link the same two forms are equal.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sd.test(ecall)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sd.test_+3A_ecall">ecall</code></td>
<td>

<p>list of objects of class <code>eqc</code> or <code>ceqc</code> 
returned by functions
<code><a href="#topic+direc">direc</a></code> and <code><a href="#topic+chainec">chainec</a></code>.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>idtest</code> with components
</p>
<table>
<tr><td><code>link</code></td>
<td>
</td></tr>
<tr><td><code>paths</code></td>
<td>
</td></tr>
<tr><td><code>AB</code></td>
<td>
</td></tr>
<tr><td><code>statistic</code></td>
<td>
</td></tr>
<tr><td><code>df</code></td>
<td>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michela Battauz
</p>


<h3>References</h3>

<p>Battauz, M. (2022). Testing for differences in chain equating. 
<em>Statistica Neerlandica</em>, 1-12.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># three-parameter logistic model
# direct equating coefficients using the "Haebara" method
data(est3pl)
test &lt;- paste("test", 1:5, sep = "")
mod3pl &lt;- modIRT(coef = est3pl$coef, var = est3pl$var, names = test, display = FALSE)
direclist3pl &lt;- alldirec(mods = mod3pl, method = "Haebara")
# compute chain equating coefficients for path 1,2,3,4,5
pth3 &lt;- paste("test", 1:5, sep = "")
chainec3 &lt;- chainec(direclist = direclist3pl, pths = pth3)
# create a list of objects of class eqc or ceqc
ecall &lt;- c(chainec3, direclist3pl["test1.test5"])
summary(chainec3)
summary(direclist3pl$test1.test5)
# test
sd.test(ecall)
</code></pre>

<hr>
<h2 id='summary.ceqc'>
Summarizing Estimated Chain Equating Coefficients
</h2><span id='topic+summary.ceqc'></span><span id='topic+print.summary.ceqc'></span>

<h3>Description</h3>

<p><code>summary</code> method for class <code>ceqc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ceqc'
summary(object, ...)

## S3 method for class 'summary.ceqc'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ceqc_+3A_object">object</code></td>
<td>

<p>an object of the class <code>ceqc</code> returned by function
<code><a href="#topic+chainec">chainec</a></code>.
</p>
</td></tr>
<tr><td><code id="summary.ceqc_+3A_x">x</code></td>
<td>

<p>an object of class <code>summary.ceqc</code>, a result of a call to <code>summary.ceqc</code>.
</p>
</td></tr>
<tr><td><code id="summary.ceqc_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>summary.ceqc</code> returns a list with components
</p>
<table>
<tr><td><code>forms</code></td>
<td>
<p>names of equated forms.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the equating method used.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a <code class="reqn">2 \times 2</code> matrix with columns for the estimated 
coefficients A and B and standard errors. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michela Battauz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chainec">chainec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># two-parameter logistic model
# direct equating coefficients using the "Haebara" method
data(est2pl)
test&lt;-paste("test", 1:5, sep = "")
mod2pl &lt;- modIRT(coef = est2pl$coef, var = est2pl$var, names = test, display = FALSE)
direclist2pl &lt;- alldirec(mods = mod2pl, method = "Haebara")
# compute all chain equating coefficients of length 3
chainec3 &lt;- chainec(r = 3, direclist = direclist2pl)
summary(chainec3$test1.test5.test4)	
</code></pre>

<hr>
<h2 id='summary.ceqclist'>
Summarizing a List of Estimated Chain Equating Coefficients
</h2><span id='topic+summary.ceqclist'></span><span id='topic+print.summary.ceqclist'></span>

<h3>Description</h3>

<p><code>summary</code> method for class <code>ceqclist</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'ceqclist'
summary(object, path, ...)

## S3 method for class 'summary.ceqclist'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.ceqclist_+3A_object">object</code></td>
<td>

<p>an object of the class <code>ceqclist</code> returned by function
<code><a href="#topic+chainec">chainec</a></code>.
</p>
</td></tr>
<tr><td><code id="summary.ceqclist_+3A_path">path</code></td>
<td>

<p>a vector of character strings with the names of the 
forms that constitute 
the path separated by a dot (e.g. &quot;<code>test1.test2.test3</code>&quot;).
</p>
</td></tr>
<tr><td><code id="summary.ceqclist_+3A_x">x</code></td>
<td>

<p>an object of class <code>summary.ceqclist</code>, a result of a call to <code>summary.ceqclist</code>.
</p>
</td></tr>
<tr><td><code id="summary.ceqclist_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>summary.ceqclist</code> returns a list containing the output
of function <code><a href="#topic+summary.ceqc">summary.ceqc</a></code> for each path
contained in <code>object</code>.
</p>


<h3>Author(s)</h3>

<p>Michela Battauz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chainec">chainec</a></code>, <code><a href="#topic+summary.eqc">summary.eqc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># two-parameter logistic model
# direct equating coefficients using the "Haebara" method
data(est2pl)
test&lt;-paste("test", 1:5, sep = "")
mod2pl &lt;- modIRT(coef = est2pl$coef, var = est2pl$var, names = test, display = FALSE)
direclist2pl &lt;- alldirec(mods = mod2pl, method = "Haebara")
# compute all chain equating coefficients of length 3
chainec3 &lt;- chainec(r = 3, direclist = direclist2pl)
summary(chainec3)	
summary(chainec3, path = "test1.test2.test3")	
summary(chainec3, path = c("test1.test2.test3","test1.test5.test4"))	
</code></pre>

<hr>
<h2 id='summary.eqc'>
Summarizing Estimated Equating Coefficients
</h2><span id='topic+summary.eqc'></span><span id='topic+print.summary.eqc'></span>

<h3>Description</h3>

<p><code>summary</code> method for class <code>eqc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'eqc'
summary(object, ...)

## S3 method for class 'summary.eqc'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.eqc_+3A_object">object</code></td>
<td>

<p>an object of the class <code>eqc</code> returned by function 
<code><a href="#topic+direc">direc</a></code>.
</p>
</td></tr>
<tr><td><code id="summary.eqc_+3A_x">x</code></td>
<td>

<p>an object of class <code>summary.eqc</code>, a result of a call to <code>summary.eqc</code>.
</p>
</td></tr>
<tr><td><code id="summary.eqc_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>summary.eqc</code> returns a list with components
</p>
<table>
<tr><td><code>forms</code></td>
<td>
<p>names of equated forms.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the equating method used.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>a <code class="reqn">2 \times 2</code> matrix with columns for the estimated 
coefficients A and B and standard errors. </p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michela Battauz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+direc">direc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># three-parameter logistic model
# direct equating coefficients between forms 1 and 2 using the Stocking-Lord method
data(est3pl)
test &lt;- paste("test", 1:5, sep = "")
mod3pl &lt;- modIRT(coef = est3pl$coef, var = est3pl$var, names = test, display = FALSE)
l12 &lt;- direc(mod1 = mod3pl[1], mod2 = mod3pl[2], method = "Stocking-Lord")
summary(l12)
</code></pre>

<hr>
<h2 id='summary.eqclist'>
Summarizing a List of Estimated Direct Equating Coefficients
</h2><span id='topic+summary.eqclist'></span><span id='topic+print.summary.eqclist'></span>

<h3>Description</h3>

<p><code>summary</code> method for class <code>eqclist</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'eqclist'
summary(object, link, ...)

## S3 method for class 'summary.eqclist'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.eqclist_+3A_object">object</code></td>
<td>

<p>an object of the class <code>eqclist</code> returned by function
<code><a href="#topic+alldirec">alldirec</a></code>.
</p>
</td></tr>
<tr><td><code id="summary.eqclist_+3A_link">link</code></td>
<td>

<p>a vector of character strings with the names of the two 
forms being linked separated by a dot 
(e.g. &quot;<code>test1.test2</code>&quot;).
</p>
</td></tr>
<tr><td><code id="summary.eqclist_+3A_x">x</code></td>
<td>

<p>an object of class <code>summary.eqclist</code>, a result of a call to <code>summary.eqclist</code>.
</p>
</td></tr>
<tr><td><code id="summary.eqclist_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>summary.eqclist</code> returns a list containing the output
of function <code><a href="#topic+summary.eqc">summary.eqc</a></code> for each link
contained in <code>object</code>.
</p>


<h3>Author(s)</h3>

<p>Michela Battauz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+alldirec">alldirec</a></code>, <code><a href="#topic+summary.eqc">summary.eqc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Rasch model
# direct equating coefficients using the "mean-mean" method
data(estrasch)
test&lt;-paste("test", 1:5, sep = "")
modrasch &lt;- modIRT(coef = estrasch$coef, var = estrasch$var, names = test, 
	display = FALSE)
direclistrasch &lt;- alldirec(mods = modrasch, method = "mean-mean", all = TRUE)
summary(direclistrasch)
summary(direclistrasch, link = "test1.test2")
summary(direclistrasch, link = c("test1.test2", "test1.test5"))
</code></pre>

<hr>
<h2 id='summary.meqc'>
Summarizing Bisector Equating Coefficients
</h2><span id='topic+summary.meqc'></span><span id='topic+print.summary.meqc'></span>

<h3>Description</h3>

<p><code>summary</code> method for class <code>meqc</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'meqc'
summary(object, ...)

## S3 method for class 'summary.meqc'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.meqc_+3A_object">object</code></td>
<td>

<p>an object of the class <code>meqc</code> returned by function
<code><a href="#topic+bisectorec">bisectorec</a></code>.
</p>
</td></tr>
<tr><td><code id="summary.meqc_+3A_x">x</code></td>
<td>

<p>an object of class <code>summary.meqc</code>, a result of a call to <code>summary.meqc</code>.
</p>
</td></tr>
<tr><td><code id="summary.meqc_+3A_...">...</code></td>
<td>

<p>further arguments passed to or from other methods.
</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function <code>summary.meqc</code> returns a list with components
</p>
<table>
<tr><td><code>link</code></td>
<td>
<p>character vector with names of equated forms.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>the equating method used.</p>
</td></tr>
<tr><td><code>coefficients</code></td>
<td>
<p>list of data frames containing <code>Path</code>,
<code>Estimate</code> and <code>StdErr</code> of direct, chain 
and bisector equating coefficients.
</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Michela Battauz
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bisectorec">bisectorec</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># three-parameter logistic model
# direct equating coefficients using the "Stocking-Lord" method
data(est3pl)
test &lt;- paste("test", 1:5, sep = "")
mod3pl &lt;- modIRT(coef = est3pl$coef, var = est3pl$var, names = test, display = FALSE)
direclist3pl &lt;- alldirec(mods = mod3pl, method = "Stocking-Lord")
# compute chain equating coefficients for path 1,2,3,4
pth1 &lt;- paste("test", 1:4, sep = "")
pth1 &lt;- data.frame(t(pth1), stringsAsFactors = FALSE)
chainec1 &lt;- chainec(direclist = direclist3pl, pths = pth1)
# compute chain equating coefficients for path 1,5,4
pth2 &lt;- c(paste("test", c(1,5,4), sep = ""))
pth2 &lt;- data.frame(t(pth2), stringsAsFactors = FALSE)
chainec2 &lt;- chainec(direclist = direclist3pl, pths = pth2)
# compute chain equating coefficients for path 1,2,3,4,5
pth3 &lt;- paste("test", 1:5, sep = "")
pth3 &lt;- data.frame(t(pth3), stringsAsFactors = FALSE)
chainec3 &lt;- chainec(direclist = direclist3pl, pths = pth3)
# create a list of objects of class eqc or ceqc
ecall &lt;- c(chainec1, chainec2, chainec3, direclist3pl["test1.test5"])
# compute bisector and weighted bisector coefficients
allec &lt;- bisectorec(ecall = ecall, weighted = TRUE, unweighted = TRUE)
summary(allec)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
