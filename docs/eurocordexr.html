<!DOCTYPE html><html><head><title>Help for package eurocordexr</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {eurocordexr}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#eurocordexr-package'><p>eurocordexr: Makes it Easier to Work with Daily 'netCDF' from EURO-CORDEX RCMs</p></a></li>
<li><a href='#check_inventory'><p>Perform some checks on the inventory</p></a></li>
<li><a href='#check_inventory_cmip5'><p>Perform some checks on the inventory of CMIP5 files</p></a></li>
<li><a href='#compare_variables_in_inventory'><p>Compare an EURO-CORDEX inventory for different variables</p></a></li>
<li><a href='#get_inventory'><p>Get inventory from path containing EURO-CORDEX .nc files</p></a></li>
<li><a href='#get_inventory_cmip5'><p>Get inventory from path containing CMIP5 GCMs .nc files</p></a></li>
<li><a href='#get_varnames'><p>Get variable names from netcdf file</p></a></li>
<li><a href='#map_non_standard_calendar'><p>Create map indices from non-standard calendars</p></a></li>
<li><a href='#nc_grid_to_dt'><p>Convert a netcdf array to long format as data.table</p></a></li>
<li><a href='#print.eurocordexr_inv'><p>Print an inventory</p></a></li>
<li><a href='#rotpole_nc_point_to_dt'><p>Extract time series of a single grid cell of a rot-pole daily netcdf to</p>
data.table</a></li>
<li><a href='#shortnames_gcm'><p>Abbreviations for RCM and GCM names</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Makes it Easier to Work with Daily 'netCDF' from EURO-CORDEX
RCMs</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.4</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Michael Matiu &lt;michaelmatiu@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>
    Daily 'netCDF' data from e.g. regional climate models (RCMs) are not trivial
    to work with. This package, which relies on 'data.table', makes it easier
    to deal with large data from RCMs, such as from EURO-CORDEX 
    (<a href="https://www.euro-cordex.net/">https://www.euro-cordex.net/</a>, <a href="https://cordex.org/data-access/">https://cordex.org/data-access/</a>). It has 
    functions to extract single grid cells from rotated pole grids as well as 
    the whole array in long format. Can handle non-standard calendars (360, 
    noleap) and interpolate them to a standard one. Potentially works with many 
    CF-conform 'netCDF' files. </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>data.table, magrittr, ncdf4, ncdf4.helpers, fs, PCICt,
lubridate</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mitmat/eurocordexr">https://github.com/mitmat/eurocordexr</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mitmat/eurocordexr/issues">https://github.com/mitmat/eurocordexr/issues</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-24 06:28:30 UTC; mitmat</td>
</tr>
<tr>
<td>Author:</td>
<td>Michael Matiu <a href="https://orcid.org/0000-0001-5289-0592"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-24 06:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='eurocordexr-package'>eurocordexr: Makes it Easier to Work with Daily 'netCDF' from EURO-CORDEX RCMs</h2><span id='topic+eurocordexr'></span><span id='topic+eurocordexr-package'></span>

<h3>Description</h3>

<p>Daily 'netCDF' data from e.g. regional climate models (RCMs) are not trivial to work with. This package, which relies on 'data.table', makes it easier to deal with large data from RCMs, such as from EURO-CORDEX (<a href="https://www.euro-cordex.net/">https://www.euro-cordex.net/</a>, <a href="https://cordex.org/data-access/">https://cordex.org/data-access/</a>). It has functions to extract single grid cells from rotated pole grids as well as the whole array in long format. Can handle non-standard calendars (360, noleap) and interpolate them to a standard one. Potentially works with many CF-conform 'netCDF' files.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Michael Matiu <a href="mailto:michaelmatiu@gmail.com">michaelmatiu@gmail.com</a> (<a href="https://orcid.org/0000-0001-5289-0592">ORCID</a>)
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/mitmat/eurocordexr">https://github.com/mitmat/eurocordexr</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/mitmat/eurocordexr/issues">https://github.com/mitmat/eurocordexr/issues</a>
</p>
</li></ul>


<hr>
<h2 id='check_inventory'>Perform some checks on the inventory</h2><span id='topic+check_inventory'></span>

<h3>Description</h3>

<p>Some simple checks for multiple time frequencies, domains, ensembles,
downscale realizations, and completeness of simulation periods.
Can also run <code><a href="#topic+compare_variables_in_inventory">compare_variables_in_inventory</a></code>
to check for completeness of variables for all models. These checks are meant
as guides only, since one might not wish multiple elements of the above for
climate model ensemble assessments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_inventory(data_inventory, check_hist = FALSE, check_vars = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_inventory_+3A_data_inventory">data_inventory</code></td>
<td>
<p>A data.table as resulting from
<code><a href="#topic+get_inventory">get_inventory</a></code>.</p>
</td></tr>
<tr><td><code id="check_inventory_+3A_check_hist">check_hist</code></td>
<td>
<p>Boolean, if <code>TRUE</code>, tests that each rcp* has a corresponding historical run.</p>
</td></tr>
<tr><td><code id="check_inventory_+3A_check_vars">check_vars</code></td>
<td>
<p>Boolean, if <code>TRUE</code>, runs <code><a href="#topic+compare_variables_in_inventory">compare_variables_in_inventory</a></code>
to check if all variables are available in all models.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The checks are </p>

<ul>
<li><p> for multiple time frequency (day, month, ...)
</p>
</li>
<li><p> for multiple domains (EUR-11, EUR-44, ...)
</p>
</li>
<li><p> for multiple ensembles (r1i1p1, r2i1p1, ...)
</p>
</li>
<li><p> for multiple downscale realizations (v1, v2, ..)
</p>
</li>
<li><p> for complete periods of simulations: historical usually goes approx.
from 1950/70 - 2005, and rcp* from 2006 - 2100; evaluation is not checked,
because it has very heterogeneous periods; cordex-adjust has historical and
rcp* combined
</p>
</li>
<li><p> that each rcp* has a corresponding historical run (optional, off by
default; otherwise problematic with merged hist and rcp runs, as in cordex-adjust)
</p>
</li>
<li><p> that all variables (tas, pr, ...) are available for all models (optional, off by default)
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &quot;eurocordexr_inv_check&quot; (an overloaded list) with results
from the checks. Has a special print method, which shows a verbose summary of the results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># some empty example files
fn_zip &lt;- system.file("extdata", "inv-test-files.zip", package = "eurocordexr")
tmpdir &lt;- tempdir()
unzip(fn_zip, exdir = tmpdir)

dat_inv &lt;- get_inventory(fs::path(tmpdir, "testdata"))
check_inventory(dat_inv)

</code></pre>

<hr>
<h2 id='check_inventory_cmip5'>Perform some checks on the inventory of CMIP5 files</h2><span id='topic+check_inventory_cmip5'></span>

<h3>Description</h3>

<p>Some simple checks for multiple time frequencies, ensembles, and completeness
of simulation periods. These checks are meant as guides only, since one might
not wish multiple elements of the above for climate model ensemble
assessments.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_inventory_cmip5(data_inventory, check_hist = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_inventory_cmip5_+3A_data_inventory">data_inventory</code></td>
<td>
<p>A data.table as resulting from
<code><a href="#topic+get_inventory">get_inventory</a></code>.</p>
</td></tr>
<tr><td><code id="check_inventory_cmip5_+3A_check_hist">check_hist</code></td>
<td>
<p>Boolean, if <code>TRUE</code>, tests that each rcp* has a corresponding historical run.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The checks are </p>

<ul>
<li><p> for multiple time frequency (day, month, ...)
</p>
</li>
<li><p> for multiple ensembles (r1i1p1, r2i1p1, ...)
</p>
</li>
<li><p> for complete periods of simulations: here complete means at least
1860-2005 for historical and 2006-2099 for rcp*
</p>
</li>
<li><p> that each rcp* has a corresponding historical run (optional, off by
default; otherwise problematic with merged hist and rcp runs)
</p>
</li></ul>



<h3>Value</h3>

<p>An object of class &quot;eurocordexr_inv_check_cmip5&quot; (an overloaded list) with results
from the checks. Has a special print method, which shows a verbose summary of the results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># some empty example files
fn_zip &lt;- system.file("extdata", "inv-test-files-cmip5.zip", package = "eurocordexr")
tmpdir &lt;- tempdir()
unzip(fn_zip, exdir = tmpdir)

dat_inv &lt;- get_inventory_cmip5(fs::path(tmpdir, "testdata-cmip5"))
check_inventory_cmip5(dat_inv)

</code></pre>

<hr>
<h2 id='compare_variables_in_inventory'>Compare an EURO-CORDEX inventory for different variables</h2><span id='topic+compare_variables_in_inventory'></span>

<h3>Description</h3>

<p>Casts the result from <code><a href="#topic+get_inventory">get_inventory</a></code> for different variables in
order to compare completeness of the inventory. Adds columns for checking
equality of years and number of files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compare_variables_in_inventory(data_inventory, vars = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compare_variables_in_inventory_+3A_data_inventory">data_inventory</code></td>
<td>
<p>A data.table as resulting from
<code><a href="#topic+get_inventory">get_inventory</a></code>.</p>
</td></tr>
<tr><td><code id="compare_variables_in_inventory_+3A_vars">vars</code></td>
<td>
<p>Character vector of variables to compare. If <code>NULL</code>, will use
all variables in <code>data_inventory</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The casted data.table with boolean columns if all years and number of
files are equal for all variables.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 

path &lt;- "/mnt/CEPH_BASEDATA/METEO/SCENARIO"
dat &lt;- get_inventory(path)
dat_compare &lt;- compare_variables_in_inventory(dat, c("tas","rsds","pr"))

## End(Not run)
</code></pre>

<hr>
<h2 id='get_inventory'>Get inventory from path containing EURO-CORDEX .nc files</h2><span id='topic+get_inventory'></span>

<h3>Description</h3>

<p>Returns a data.table with information by splitting the netcdf files into
their components (GCM, RCM, variable, experiment, ...) and aggregates over
years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_inventory(path, add_files = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_inventory_+3A_path">path</code></td>
<td>
<p>Path that will be searched recursively for .nc files.</p>
</td></tr>
<tr><td><code id="get_inventory_+3A_add_files">add_files</code></td>
<td>
<p>Boolean (default <code>TRUE</code>), if <code>TRUE</code>, will add a
column containing lists of associated files with their full paths (useful
e.g. for further processing).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table with the inventory information.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+check_inventory">check_inventory</a></code> for performing some checks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># some empty example files
fn_zip &lt;- system.file("extdata", "inv-test-files.zip", package = "eurocordexr")
tmpdir &lt;- tempdir()
unzip(fn_zip, exdir = tmpdir)

dat_inv &lt;- get_inventory(fs::path(tmpdir, "testdata", "mixed-vars"))
print(dat_inv)


</code></pre>

<hr>
<h2 id='get_inventory_cmip5'>Get inventory from path containing CMIP5 GCMs .nc files</h2><span id='topic+get_inventory_cmip5'></span>

<h3>Description</h3>

<p>Returns a data.table with information by splitting the netcdf files into
their components (GCM, variable, experiment, ...) and aggregates over
years.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_inventory_cmip5(path, add_files = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_inventory_cmip5_+3A_path">path</code></td>
<td>
<p>Path that will be searched recursively for .nc files.</p>
</td></tr>
<tr><td><code id="get_inventory_cmip5_+3A_add_files">add_files</code></td>
<td>
<p>Boolean (default <code>TRUE</code>), if <code>TRUE</code>, will add a
column containing lists of associated files with their full paths (useful
e.g. for further processing).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.table with the inventory information.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+check_inventory_cmip5">check_inventory_cmip5</a></code> for performing some checks.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># some empty example files
fn_zip &lt;- system.file("extdata", "inv-test-files-cmip5.zip", package = "eurocordexr")
tmpdir &lt;- tempdir()
unzip(fn_zip, exdir = tmpdir)

dat_inv &lt;- get_inventory_cmip5(fs::path(tmpdir, "testdata-cmip5", "basic"))
print(dat_inv)

</code></pre>

<hr>
<h2 id='get_varnames'>Get variable names from netcdf file</h2><span id='topic+get_varnames'></span>

<h3>Description</h3>

<p>Wrapper around <code><a href="ncdf4.helpers.html#topic+nc.get.variable.list">ncdf4.helpers::nc.get.variable.list</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_varnames(filename)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_varnames_+3A_filename">filename</code></td>
<td>
<p>.nc file</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of variable names
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example data from EURO-CORDEX (cropped for size)
fn1 &lt;- system.file("extdata", "test1.nc", package = "eurocordexr")
get_varnames(fn1)

</code></pre>

<hr>
<h2 id='map_non_standard_calendar'>Create map indices from non-standard calendars</h2><span id='topic+map_non_standard_calendar'></span>

<h3>Description</h3>

<p>Interpolates non-standard calendars (360 and noleap) to the standard
Gregorian. Assumes daily data as input.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>map_non_standard_calendar(times)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="map_non_standard_calendar_+3A_times">times</code></td>
<td>
<p>Vector of class PCICt (will be truncated to days).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="data.table.html#topic+data.table">data.table</a></code> with columns:
</p>
 <ul>
<li><p> dates_full: sequence of standard dates from min to max date
in input times as data.table::IDate </p>
</li>
<li><p> dates_pcict_inter: which dates in
PCICt from times correspond to the standard dates </p>
</li>
<li><p> idx_pcict: the
index associated to the input times to be used for mapping e.g. values </p>
</li></ul>



<h3>See Also</h3>

<p>Can be used internally in <code><a href="#topic+rotpole_nc_point_to_dt">rotpole_nc_point_to_dt</a></code> and
<code><a href="#topic+nc_grid_to_dt">nc_grid_to_dt</a></code> by setting the respective arguments.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example data from EURO-CORDEX (cropped for size)
# non-standard calendar (360)
fn2 &lt;- system.file("extdata", "test2.nc", package = "eurocordexr")
ncobj &lt;- ncdf4::nc_open(fn2)

# read as PCICt-class
times &lt;- ncdf4.helpers::nc.get.time.series(ncobj, "tasmin")
str(times)

dtx &lt;- map_non_standard_calendar(times)
dtx[58:64]

</code></pre>

<hr>
<h2 id='nc_grid_to_dt'>Convert a netcdf array to long format as data.table</h2><span id='topic+nc_grid_to_dt'></span>

<h3>Description</h3>

<p>Extracts a variable from netcdf, and returns a
<code><a href="data.table.html#topic+data.table">data.table</a></code> with cell index, date, values, and
optionally: coordinates.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nc_grid_to_dt(
  filename,
  variable,
  icell_raster_pkg = TRUE,
  add_xy = FALSE,
  interpolate_to_standard_calendar = FALSE,
  date_range,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nc_grid_to_dt_+3A_filename">filename</code></td>
<td>
<p>Complete path to .nc file.</p>
</td></tr>
<tr><td><code id="nc_grid_to_dt_+3A_variable">variable</code></td>
<td>
<p>Name of the variable to extract from <code>filename</code>
(character).</p>
</td></tr>
<tr><td><code id="nc_grid_to_dt_+3A_icell_raster_pkg">icell_raster_pkg</code></td>
<td>
<p>Boolean, if <code>TRUE</code>, cell indices will be ordered
as if you were extracting the data with the raster package.</p>
</td></tr>
<tr><td><code id="nc_grid_to_dt_+3A_add_xy">add_xy</code></td>
<td>
<p>Boolean, if <code>TRUE</code>, adds columns with x and y coordinates.</p>
</td></tr>
<tr><td><code id="nc_grid_to_dt_+3A_interpolate_to_standard_calendar">interpolate_to_standard_calendar</code></td>
<td>
<p>Boolean, if <code>TRUE</code> will use
<code><a href="#topic+map_non_standard_calendar">map_non_standard_calendar</a></code> to interpolate values to a standard
calendar.</p>
</td></tr>
<tr><td><code id="nc_grid_to_dt_+3A_date_range">date_range</code></td>
<td>
<p>(optional) two-element vector of class Date (min, max),
which will be used to extract only parts of the netcdf file</p>
</td></tr>
<tr><td><code id="nc_grid_to_dt_+3A_verbose">verbose</code></td>
<td>
<p>Boolean, if <code>TRUE</code>, prints more information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Coordinates are usually not put in the result, because it saves space. It is
recommended to merge them after the final operations. The unique cell index
is more efficient. However, if you plan to merge to data extracted with the
raster package (assuming the same grid), then cell indices might differ. Set
<code>icell_raster_pkg</code> to <code>TRUE</code>, to have the same cell indices. Note
that raster and ncdf4 have different concepts of coordinates (cell corner vs.
cell center), so merging based on coordinates can produce arbitrary results
(besides rounding issues).
</p>


<h3>Value</h3>

<p>A <code><a href="data.table.html#topic+data.table">data.table</a></code> with columns: </p>
<ul>
<li>
<p>icell: Cell index </p>
</li>
<li><p> date: Date of class <code><a href="base.html#topic+Date">Date</a></code>, if file has
a standard calendar. Date as character, if it has a non-standard calendar
(360, noleap) and if <code>interpolate_to_standard_calendar</code> is set to
<code>FALSE</code>. If <code>interpolate_to_standard_calendar</code> is <code>TRUE</code>,
it's always of class <code><a href="base.html#topic+Date">Date</a></code>. </p>
</li>
<li><p> variable: Values, column is
renamed to input <code>variable</code> </p>
</li>
<li><p> (optional) x,y: Coordinates of
netcdf dimensions, will be renamed to dimension names found in array named
after input <code>variable</code></p>
</li></ul>



<h3>Warning</h3>

<p>Netcdf files can be huge, so loading everything in memory
can rapidly crash your R session. Think first about subsetting or
aggregating (e.g. using CDO:
<a href="https://code.mpimet.mpg.de/projects/cdo/">https://code.mpimet.mpg.de/projects/cdo/</a>).
</p>


<h3>See Also</h3>

<p>The raster and terra packages can also open netcdf files and create
data.frames with <code>raster::as.data.frame</code>
or <code>terra::as.data.frame</code>. But, it does
not handle non-standard calendars, and returns a data.frame, which is
slower than data.table.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example data from EURO-CORDEX (cropped for size)
fn1 &lt;- system.file("extdata", "test1.nc", package = "eurocordexr")
dat &lt;- nc_grid_to_dt(fn1)
str(dat)
</code></pre>

<hr>
<h2 id='print.eurocordexr_inv'>Print an inventory</h2><span id='topic+print.eurocordexr_inv'></span>

<h3>Description</h3>

<p>Modified
<code><a href="data.table.html#topic+print.data.table">data.table::print.data.table</a></code> to
print an inventory from <code><a href="#topic+get_inventory">get_inventory</a></code> and
<code><a href="#topic+get_inventory_cmip5">get_inventory_cmip5</a></code> more nicely by removing some columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'eurocordexr_inv'
print(x, all_cols = F, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.eurocordexr_inv_+3A_x">x</code></td>
<td>
<p>data.table to print</p>
</td></tr>
<tr><td><code id="print.eurocordexr_inv_+3A_all_cols">all_cols</code></td>
<td>
<p>Boolean (default <code>FALSE</code>), if <code>TRUE</code>, will print all
columns available</p>
</td></tr>
<tr><td><code id="print.eurocordexr_inv_+3A_...">...</code></td>
<td>
<p>passed on to <code><a href="data.table.html#topic+print.data.table">data.table::print.data.table</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>x invisibly, used for side effects: prints to console
</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+print.default">print.default</a></code>
</p>

<hr>
<h2 id='rotpole_nc_point_to_dt'>Extract time series of a single grid cell of a rot-pole daily netcdf to
data.table</h2><span id='topic+rotpole_nc_point_to_dt'></span>

<h3>Description</h3>

<p>Creates a <code><a href="data.table.html#topic+data.table">data.table</a></code> from a rotated pole netcdf (as
usually found in RCMs), which includes values and date. Useful for extracting
e.g. the series for a station. Requires that dimension variables in netcdf
file contain rlon and rlat, and that it contains daily data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rotpole_nc_point_to_dt(
  filename,
  variable,
  point_lon,
  point_lat,
  interpolate_to_standard_calendar = FALSE,
  verbose = FALSE,
  add_grid_coord = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rotpole_nc_point_to_dt_+3A_filename">filename</code></td>
<td>
<p>Complete path to .nc file.</p>
</td></tr>
<tr><td><code id="rotpole_nc_point_to_dt_+3A_variable">variable</code></td>
<td>
<p>Name of the variable to extract from <code>filename</code>
(character).</p>
</td></tr>
<tr><td><code id="rotpole_nc_point_to_dt_+3A_point_lon">point_lon</code></td>
<td>
<p>Numeric longitude of the point to extract (decimal degrees).</p>
</td></tr>
<tr><td><code id="rotpole_nc_point_to_dt_+3A_point_lat">point_lat</code></td>
<td>
<p>Numeric latitude of the point to extract (decimal degrees).</p>
</td></tr>
<tr><td><code id="rotpole_nc_point_to_dt_+3A_interpolate_to_standard_calendar">interpolate_to_standard_calendar</code></td>
<td>
<p>Boolean, if <code>TRUE</code> will use
<code><a href="#topic+map_non_standard_calendar">map_non_standard_calendar</a></code> to interpolate values to a standard
calendar.</p>
</td></tr>
<tr><td><code id="rotpole_nc_point_to_dt_+3A_verbose">verbose</code></td>
<td>
<p>Boolean, if <code>TRUE</code>, will print more information.</p>
</td></tr>
<tr><td><code id="rotpole_nc_point_to_dt_+3A_add_grid_coord">add_grid_coord</code></td>
<td>
<p>Boolean, if <code>TRUE</code>, will add columns to the result
which give the longitude and latitude of the underlying grid.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Calculates the euclidean distance, and takes the grid cell with minimal
distance to <code>point_lon</code> and <code>point_lat</code>. Requires that the .nc file
contains variables lon[rlon, rlat] and lat[rlon, rlat].
</p>


<h3>Value</h3>

<p>A <code><a href="data.table.html#topic+data.table">data.table</a></code> with two columns: the dates in
date, and the values in a variable named after input <code>variable</code>. The
date column is of class <code><a href="base.html#topic+Date">Date</a></code>, unless the .nc
file has a non-standard calendar (360, noleap) and
<code>interpolate_to_standard_calendar</code> is set to <code>FALSE</code>, in which it
will be character. If <code>add_grid_coord</code> is set to <code>TRUE</code>, then
two more columns named grid_lon and grid_lat.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example data from EURO-CORDEX (cropped for size)

# standard calendar
fn1 &lt;- system.file("extdata", "test1.nc", package = "eurocordexr")
dt1 &lt;- rotpole_nc_point_to_dt(
  filename = fn1,
  variable = "tasmin",
  point_lon = 11.31,
  point_lat = 46.5,
  verbose = TRUE
)

# non-standard calendar (360)
fn2 &lt;- system.file("extdata", "test2.nc", package = "eurocordexr")

# read as is
dt2 &lt;- rotpole_nc_point_to_dt(fn2, "tasmin", 11.31, 46.5)
str(dt2) # chr date
dt2[86:94, ] # e.g. 30th of February in 360 calendar

# interpolate to standard
dt3 &lt;- rotpole_nc_point_to_dt(fn2, "tasmin", 11.31, 46.5,
                              interpolate_to_standard_calendar = TRUE)
str(dt3) # class Date
dt3[86:94, ] # standard calender

</code></pre>

<hr>
<h2 id='shortnames_gcm'>Abbreviations for RCM and GCM names</h2><span id='topic+shortnames_gcm'></span><span id='topic+shortnames_rcm'></span>

<h3>Description</h3>

<p>character vectors with short names of RCM and GCMs, with the long RCM/GCM
names as vector-names, so it can be used for renaming:
</p>


<h3>Usage</h3>

<pre><code class='language-R'>shortnames_gcm

shortnames_rcm
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 8.
</p>
<p>An object of class <code>character</code> of length 12.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># for example from inventory
fn_zip &lt;- system.file("extdata", "inv-test-files.zip", package = "eurocordexr")
tmpdir &lt;- tempdir()
unzip(fn_zip, exdir = tmpdir)
dat_inv &lt;- get_inventory(fs::path(tmpdir, "testdata"))
# compare
cbind(dat_inv$gcm, shortnames_gcm[dat_inv$gcm])
cbind(dat_inv$institute_rcm, shortnames_rcm[dat_inv$institute_rcm])



</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
