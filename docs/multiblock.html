<!DOCTYPE html><html><head><title>Help for package multiblock</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {multiblock}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#multiblock'><p>multiblock</p></a></li>
<li><a href='#asca'><p>Analysis of Variance Simultaneous Component Analysis - ASCA</p></a></li>
<li><a href='#asca_plots'><p>ASCA Result Methods</p></a></li>
<li><a href='#asca_results'><p>ASCA Result Methods</p></a></li>
<li><a href='#basic'><p>Single- and Two-Block Methods</p></a></li>
<li><a href='#block.data.frame'><p>Block-wise indexable data.frame</p></a></li>
<li><a href='#candies'><p>Sensory assessment of candies.</p></a></li>
<li><a href='#cca'><p>Canonical Correlation Analysis - CCA</p></a></li>
<li><a href='#complex'><p>Methods With Complex Linkage</p></a></li>
<li><a href='#compnames'><p>Vector of component names</p></a></li>
<li><a href='#disco'><p>Distinctive and Common Components with SCA - DISCO</p></a></li>
<li><a href='#DISCOsca'><p>DISCO-SCA rotation.</p></a></li>
<li><a href='#dummycode'><p>Dummy-coding of a single vector</p></a></li>
<li><a href='#explvar'><p>Explained predictor variance</p></a></li>
<li><a href='#extended.model.frame'><p>Extracting the Extended Model Frame from a Formula or Fit</p></a></li>
<li><a href='#gca'><p>Generalized Canonical Analysis - GCA</p></a></li>
<li><a href='#gpa'><p>Generalized Procrustes Analysis - GPA</p></a></li>
<li><a href='#gsvd'><p>Generalised Singular Value Decomposition - GSVD</p></a></li>
<li><a href='#hogsvd'><p>Higher Order Generalized SVD - HOGSVD</p></a></li>
<li><a href='#hpca'><p>Hierarchical Principal component analysis - HPCA</p></a></li>
<li><a href='#ifa'><p>Inter-battery Factor Analysis - IFA</p></a></li>
<li><a href='#jive'><p>Joint and Individual Variation Explained - JIVE</p></a></li>
<li><a href='#lpls'><p>L-PLS regression</p></a></li>
<li><a href='#lpls_results'><p>Result functions for L-PLS objects (<code>lpls</code>)</p></a></li>
<li><a href='#lplsData'><p>L-PLS data simulation for exo-type analysis</p></a></li>
<li><a href='#maage'><p>Måge plot</p></a></li>
<li><a href='#mbpls'><p>Multiblock Partial Least Squares - MB-PLS</p></a></li>
<li><a href='#mbrda'><p>Multiblock Redundancy Analysis - mbRDA</p></a></li>
<li><a href='#mcoa'><p>Multiple Co-Inertia Analysis - MCOA</p></a></li>
<li><a href='#mcolors'><p>Colour palette generation from matrix of RGB values</p></a></li>
<li><a href='#mfa'><p>Multiple Factor Analysis - MFA</p></a></li>
<li><a href='#multiblock_plots'><p>Plot Functions for Multiblock Objects</p></a></li>
<li><a href='#multiblock_results'><p>Result Functions for Multiblock Objects</p></a></li>
<li><a href='#pca'><p>Principal Component Analysis - PCA</p></a></li>
<li><a href='#pcagca'><p>PCA-GCA</p></a></li>
<li><a href='#popls'><p>Parallel and Orthogonalised Partial Least Squares - PO-PLS</p></a></li>
<li><a href='#potato'><p>Sensory, rheological, chemical and spectroscopic analysis of potatoes.</p></a></li>
<li><a href='#preprocess'><p>Preprocessing of block data</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#rosa'><p>Response Oriented Sequential Alternation - ROSA</p></a></li>
<li><a href='#rosa_plots'><p>Plotting functions for ROSA models</p></a></li>
<li><a href='#rosa_results'><p>Result functions for ROSA models</p></a></li>
<li><a href='#sca'><p>Simultaneous Component Analysis - SCA</p></a></li>
<li><a href='#simulated'><p>Data simulated to have certain characteristics.</p></a></li>
<li><a href='#smbpls'><p>Sparse Multiblock Partial Least Squares - sMB-PLS</p></a></li>
<li><a href='#SO_TDI'><p>Total, direct, indirect and additional effects in SO-PLS-PM.</p></a></li>
<li><a href='#sopls'><p>Sequential and Orthogonalized PLS (SO-PLS)</p></a></li>
<li><a href='#sopls_plots'><p>Scores, loadings and plots for sopls objects</p></a></li>
<li><a href='#sopls_results'><p>Result functions for SO-PLS models</p></a></li>
<li><a href='#statis'><p>Structuration des Tableaux à Trois Indices de la Statistique - STATIS</p></a></li>
<li><a href='#supervised'><p>Supervised Multiblock Methods</p></a></li>
<li><a href='#unique_combos'><p>Unique combinations of blocks</p></a></li>
<li><a href='#unsupervised'><p>Unsupervised Multiblock Methods</p></a></li>
<li><a href='#wine'><p>Wines of Val de Loire</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Multiblock Data Fusion in Statistics and Machine Learning</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8.8.1</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-11</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions and datasets to support Smilde, Næs and Liland (2021, ISBN: 978-1-119-60096-1) 
   "Multiblock Data Fusion in Statistics and Machine Learning - Applications in the Natural and Life Sciences". 
   This implements and imports a large collection of methods for multiblock data analysis with common interfaces, result- and plotting 
   functions, several real data sets and six vignettes covering a range different applications.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://khliland.github.io/multiblock/">https://khliland.github.io/multiblock/</a>,
<a href="https://github.com/khliland/multiblock/">https://github.com/khliland/multiblock/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/khliland/multiblock/issues/">https://github.com/khliland/multiblock/issues/</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>ade4, car, lme4, MASS, mixlm, plotrix, pls, plsVarSel, pracma,
progress, Rcpp, RSpectra, SSBtools</td>
</tr>
<tr>
<td>Suggests:</td>
<td>EMSC, FactoMineR, geigen, RGCCA (&ge; 3.0.0), r.jive,
rmarkdown, knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppEigen</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.1</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-11 19:22:07 UTC; kristian</td>
</tr>
<tr>
<td>Author:</td>
<td>Kristian Hovde Liland
    <a href="https://orcid.org/0000-0001-6468-9423"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre],
  Solve Sæbø [ctb],
  Stefan Schrunner [rev]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Kristian Hovde Liland &lt;kristian.liland@nmbu.no&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-11 19:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='multiblock'>multiblock</h2><span id='topic+multiblock-package'></span><span id='topic+multiblock'></span>

<h3>Description</h3>

<p>A collection of methods for analysis of data sets with more than two blocks of data.
</p>
<p><strong>Unsupervised methods:</strong>
</p>

<ul>
<li><p> SCA - Simultaneous Component Analysis (<code><a href="#topic+sca">sca</a></code>)
</p>
</li>
<li><p> GCA - Generalized Canonical Analysis (<code><a href="#topic+gca">gca</a></code>)
</p>
</li>
<li><p> GPA - Generalized Procrustes Analysis (<code><a href="#topic+gpa">gpa</a></code>)
</p>
</li>
<li><p> MFA - Multiple Factor Analysis (<code><a href="#topic+mfa">mfa</a></code>)
</p>
</li>
<li><p> PCA-GCA (<code><a href="#topic+pcagca">pcagca</a></code>)
</p>
</li>
<li><p> DISCO - Distinctive and Common Components with SCA (<code><a href="#topic+disco">disco</a></code>)
</p>
</li>
<li><p> HPCA - Hierarchical Principal component analysis (<code><a href="#topic+hpca">hpca</a></code>)
</p>
</li>
<li><p> MCOA - Multiple Co-Inertia Analysis (<code><a href="#topic+mcoa">mcoa</a></code>)
</p>
</li>
<li><p> JIVE - Joint and Individual Variation Explained (<code><a href="#topic+jive">jive</a></code>)
</p>
</li>
<li><p> STATIS - Structuration des Tableaux à Trois Indices de la Statistique (<code><a href="#topic+statis">statis</a></code>)
</p>
</li>
<li><p> HOGSVD - Higher Order Generalized SVD (<code><a href="#topic+hogsvd">hogsvd</a></code>)
</p>
</li></ul>

<p><strong>Design based methods:</strong>
</p>

<ul>
<li><p> ASCA - Anova Simultaneous Component Analysis (<code><a href="#topic+asca">asca</a></code>)
</p>
</li></ul>

<p><strong>Supervised methods:</strong>
</p>

<ul>
<li><p> MB-PLS - Multiblock Partial Least Squares (<code><a href="#topic+mbpls">mbpls</a></code>)
</p>
</li>
<li><p> sMB-PLS - Sparse Multiblock Partial Least Squares (<code><a href="#topic+smbpls">smbpls</a></code>)
</p>
</li>
<li><p> SO-PLS - Sequential and Orthogonalized PLS (<code><a href="#topic+sopls">sopls</a></code>)
</p>
</li>
<li><p> PO-PLS - Parallel and Orthogonalized PLS (<code><a href="#topic+popls">popls</a></code>)
</p>
</li>
<li><p> ROSA - Response Oriented Sequential Alternation (<code><a href="#topic+rosa">rosa</a></code>)
</p>
</li>
<li><p> mbRDA - Multiblock Redundancy Analysis (<code><a href="#topic+mbrda">mbrda</a></code>)
</p>
</li></ul>

<p><strong>Complex methods:</strong>
</p>

<ul>
<li><p> L-PLS - Partial Least Squares in L configuration (<code><a href="#topic+lpls">lpls</a></code>)
</p>
</li>
<li><p> SO-PLS-PM - Sequential and Orthogonalised PLS Path Modelling (<code><a href="#topic+sopls_pm">sopls_pm</a></code>)
</p>
</li></ul>

<p><strong>Single- and two-block methods:</strong>
</p>

<ul>
<li><p> PCA - Principal Component Analysis (<code><a href="#topic+pca">pca</a></code>)
</p>
</li>
<li><p> PCR - Principal Component Regression (<code><a href="#topic+pcr">pcr</a></code>)
</p>
</li>
<li><p> PLSR - Partial Least Squares Regression (<code><a href="#topic+plsr">plsr</a></code>)
</p>
</li>
<li><p> CCA - Canonical Correlation Analysis (<code><a href="#topic+cca">cca</a></code>)
</p>
</li>
<li><p> IFA - Interbattery Factor Analysis (<code><a href="#topic+ifa">ifa</a></code>)
</p>
</li>
<li><p> GSVD - Generalized SVD (<code><a href="#topic+gsvd">gsvd</a></code>)
</p>
</li></ul>

<p><strong>Datasets:</strong>
</p>

<ul>
<li><p> Sensory assessment of candies (<code><a href="#topic+candies">candies</a></code>)
</p>
</li>
<li><p> Sensory, rheological, chemical and spectroscopic analysis of potatoes (<code><a href="#topic+potato">potato</a></code>)
</p>
</li>
<li><p> Data simulated to have certain characteristics (<code><a href="#topic+simulated">simulated</a></code>)
</p>
</li>
<li><p> Wines of Val de Loire (<code><a href="#topic+wine">wine</a></code>)
</p>
</li></ul>

<p><strong>Utility functions:</strong>
</p>

<ul>
<li><p> Block-wise indexable data.frame (<code><a href="#topic+block.data.frame">block.data.frame</a></code>)
</p>
</li>
<li><p> Dummy-code a vector (<code><a href="#topic+dummycode">dummycode</a></code>)
</p>
</li></ul>



<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Kristian Hovde Liland <a href="mailto:kristian.liland@nmbu.no">kristian.liland@nmbu.no</a> (<a href="https://orcid.org/0000-0001-6468-9423">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Solve Sæbø [contributor]
</p>
</li>
<li><p> Stefan Schrunner [reviewer]
</p>
</li></ul>



<h3>See Also</h3>

<p>Overviews of available methods, <code><a href="#topic+multiblock">multiblock</a></code>, and methods organised by main structure: <code><a href="#topic+basic">basic</a></code>, <code><a href="#topic+unsupervised">unsupervised</a></code>, <code><a href="#topic+asca">asca</a></code>, <code><a href="#topic+supervised">supervised</a></code> and <code><a href="#topic+complex">complex</a></code>.
</p>

<hr>
<h2 id='asca'>Analysis of Variance Simultaneous Component Analysis - ASCA</h2><span id='topic+asca'></span>

<h3>Description</h3>

<p>This is a quite general and flexible implementation of ASCA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>asca(formula, data, subset, weights, na.action, family, pca.in = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asca_+3A_formula">formula</code></td>
<td>
<p>Model formula accepting a single response (block) and predictor names separated by + signs.</p>
</td></tr>
<tr><td><code id="asca_+3A_data">data</code></td>
<td>
<p>The data set to analyse.</p>
</td></tr>
<tr><td><code id="asca_+3A_subset">subset</code></td>
<td>
<p>Subset of objects</p>
</td></tr>
<tr><td><code id="asca_+3A_weights">weights</code></td>
<td>
<p>Optional object weights.</p>
</td></tr>
<tr><td><code id="asca_+3A_na.action">na.action</code></td>
<td>
<p>How to handle NAs (no action implemented).</p>
</td></tr>
<tr><td><code id="asca_+3A_family">family</code></td>
<td>
<p>Error distributions and link function for Generalized Linear Models.</p>
</td></tr>
<tr><td><code id="asca_+3A_pca.in">pca.in</code></td>
<td>
<p>Compress response before ASCA (number of components).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>ASCA is a method which decomposes a multivariate response according to one or more design
variables. ANOVA is used to split variation into contributions from factors, and PCA is performed
on the corresponding least squares estimates, i.e., <code>Y = X1 B1 + X2 B2 + ... + E = T1 P1' + T2 P2' + ... + E</code>.
This version of ASCA encompasses variants of LiMM-PCA, generalized ASCA and covariates ASCA. It includes
confidence ellipsoids for the balanced fixed effect ASCA.
</p>


<h3>Value</h3>

<p>An <code>asca</code> object containing loadings, scores, explained variances, etc. The object has
associated plotting (<code><a href="#topic+asca_plots">asca_plots</a></code>) and result (<code><a href="#topic+asca_results">asca_results</a></code>) functions.
</p>


<h3>References</h3>


<ul>
<li><p> Smilde, A., Jansen, J., Hoefsloot, H., Lamers,R., Van Der Greef, J., and Timmerman, M.(2005). ANOVA-Simultaneous Component Analysis (ASCA): A new tool for analyzing designed metabolomics data. Bioinformatics, 21(13), 3043–3048.
</p>
</li>
<li><p> Liland, K.H., Smilde, A., Marini, F., and Næs,T. (2018). Confidence ellipsoids for ASCA models based on multivariate regression theory. Journal of Chemometrics, 32(e2990), 1–13.
</p>
</li>
<li><p> Martin, M. and Govaerts, B. (2020). LiMM-PCA: Combining ASCA+ and linear mixed models to analyse high-dimensional designed data. Journal of Chemometrics, 34(6), e3232.
</p>
</li></ul>



<h3>See Also</h3>

<p>Overviews of available methods, <code><a href="#topic+multiblock">multiblock</a></code>, and methods organised by main structure: <code><a href="#topic+basic">basic</a></code>, <code><a href="#topic+unsupervised">unsupervised</a></code>, <code><a href="#topic+asca">asca</a></code>, <code><a href="#topic+supervised">supervised</a></code> and <code><a href="#topic+complex">complex</a></code>.
Common functions for computation and extraction of results and plotting are found in <code><a href="#topic+asca_results">asca_results</a></code> and <code><a href="#topic+asca_plots">asca_plots</a></code>, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Load candies data
data(candies)

# Basic ASCA model with two factors
mod &lt;- asca(assessment ~ candy + assessor, data=candies)
print(mod)

# ASCA model with interaction
mod &lt;- asca(assessment ~ candy * assessor, data=candies)
print(mod)

# Result plotting for first factor
loadingplot(mod, scatter=TRUE, labels="names")
scoreplot(mod, ellipsoids = "confidence")

# ASCA model with compressed response using 5 principal components
mod.pca &lt;- asca(assessment ~ candy + assessor, data=candies, pca.in=5)

# Mixed Model ASCA, random assessor
mod.mix &lt;- asca(assessment ~ candy + (1|assessor), data=candies)
scoreplot(mod.mix)

</code></pre>

<hr>
<h2 id='asca_plots'>ASCA Result Methods</h2><span id='topic+asca_plots'></span><span id='topic+loadingplot.asca'></span><span id='topic+scoreplot.asca'></span>

<h3>Description</h3>

<p>Various plotting procedures for <code><a href="#topic+asca">asca</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'asca'
loadingplot(object, factor = 1, comps = 1:2, ...)

## S3 method for class 'asca'
scoreplot(
  object,
  factor = 1,
  comps = 1:2,
  pch.scores = 19,
  pch.projections = 1,
  gr.col = 1:nlevels(object$effects[[factor]]),
  ellipsoids,
  confidence,
  xlim,
  ylim,
  xlab,
  ylab,
  legendpos,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asca_plots_+3A_object">object</code></td>
<td>
<p><code>asca</code> object.</p>
</td></tr>
<tr><td><code id="asca_plots_+3A_factor">factor</code></td>
<td>
<p><code>integer/character</code> for selecting a model factor.</p>
</td></tr>
<tr><td><code id="asca_plots_+3A_comps">comps</code></td>
<td>
<p><code>integer</code> vector of selected components.</p>
</td></tr>
<tr><td><code id="asca_plots_+3A_...">...</code></td>
<td>
<p>additional arguments to underlying methods.</p>
</td></tr>
<tr><td><code id="asca_plots_+3A_pch.scores">pch.scores</code></td>
<td>
<p><code>integer</code> plotting symbol.</p>
</td></tr>
<tr><td><code id="asca_plots_+3A_pch.projections">pch.projections</code></td>
<td>
<p><code>integer</code> plotting symbol.</p>
</td></tr>
<tr><td><code id="asca_plots_+3A_gr.col">gr.col</code></td>
<td>
<p><code>integer</code> vector of colours for groups.</p>
</td></tr>
<tr><td><code id="asca_plots_+3A_ellipsoids">ellipsoids</code></td>
<td>
<p><code>character</code> &quot;confidence&quot; or &quot;data&quot; ellipsoids for balanced fixed effect models.</p>
</td></tr>
<tr><td><code id="asca_plots_+3A_confidence">confidence</code></td>
<td>
<p><code>numeric</code> vector of ellipsoid confidences, default = c(0.4, 0.68, 0.95).</p>
</td></tr>
<tr><td><code id="asca_plots_+3A_xlim">xlim</code></td>
<td>
<p><code>numeric</code> x limits.</p>
</td></tr>
<tr><td><code id="asca_plots_+3A_ylim">ylim</code></td>
<td>
<p><code>numeric</code> y limits.</p>
</td></tr>
<tr><td><code id="asca_plots_+3A_xlab">xlab</code></td>
<td>
<p><code>character</code> x label.</p>
</td></tr>
<tr><td><code id="asca_plots_+3A_ylab">ylab</code></td>
<td>
<p><code>character</code> y label.</p>
</td></tr>
<tr><td><code id="asca_plots_+3A_legendpos">legendpos</code></td>
<td>
<p><code>character</code> position of legend.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Usage of the functions are shown using generics in the examples in <code><a href="#topic+asca">asca</a></code>.
Plot routines are available as
<code>scoreplot.asca</code> and <code>loadingplot.asca</code>.
</p>


<h3>Value</h3>

<p>The plotting routines have no return.
</p>


<h3>References</h3>


<ul>
<li><p> Smilde, A., Jansen, J., Hoefsloot, H., Lamers,R., Van Der Greef, J., and Timmerman, M.(2005). ANOVA-Simultaneous Component Analysis (ASCA): A new tool for analyzing designed metabolomics data. Bioinformatics, 21(13), 3043–3048.
</p>
</li>
<li><p> Liland, K.H., Smilde, A., Marini, F., and Næs,T. (2018). Confidence ellipsoids for ASCA models based on multivariate regression theory. Journal of Chemometrics, 32(e2990), 1–13.
</p>
</li>
<li><p> Martin, M. and Govaerts, B. (2020). LiMM-PCA: Combining ASCA+ and linear mixed models to analyse high-dimensional designed data. Journal of Chemometrics, 34(6), e3232.
</p>
</li></ul>



<h3>See Also</h3>

<p>Overviews of available methods, <code><a href="#topic+multiblock">multiblock</a></code>, and methods organised by main structure: <code><a href="#topic+basic">basic</a></code>, <code><a href="#topic+unsupervised">unsupervised</a></code>, <code><a href="#topic+asca">asca</a></code>, <code><a href="#topic+supervised">supervised</a></code> and <code><a href="#topic+complex">complex</a></code>.
Common functions for computation and extraction of results are found in <code><a href="#topic+asca_results">asca_results</a></code>.
</p>

<hr>
<h2 id='asca_results'>ASCA Result Methods</h2><span id='topic+asca_results'></span><span id='topic+print.asca'></span><span id='topic+summary.asca'></span><span id='topic+projections'></span><span id='topic+projections.asca'></span><span id='topic+print.summary.asca'></span><span id='topic+loadings.asca'></span><span id='topic+scores.asca'></span>

<h3>Description</h3>

<p>Standard result computation and extraction functions for ASCA (<code><a href="#topic+asca">asca</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'asca'
print(x, ...)

## S3 method for class 'asca'
summary(object, ...)

## S3 method for class 'summary.asca'
print(x, digits = 2, ...)

## S3 method for class 'asca'
loadings(object, factor = 1, ...)

## S3 method for class 'asca'
scores(object, factor = 1, ...)

projections(object, ...)

## S3 method for class 'asca'
projections(object, factor = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="asca_results_+3A_x">x</code></td>
<td>
<p><code>asca</code> object.</p>
</td></tr>
<tr><td><code id="asca_results_+3A_...">...</code></td>
<td>
<p>additional arguments to underlying methods.</p>
</td></tr>
<tr><td><code id="asca_results_+3A_object">object</code></td>
<td>
<p><code>asca</code> object.</p>
</td></tr>
<tr><td><code id="asca_results_+3A_digits">digits</code></td>
<td>
<p><code>integer</code> number of digits for printing.</p>
</td></tr>
<tr><td><code id="asca_results_+3A_factor">factor</code></td>
<td>
<p><code>integer/character</code> for selecting a model factor.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Usage of the functions are shown using generics in the examples in <code><a href="#topic+asca">asca</a></code>.
Explained variances are available (block-wise and global) through <code>blockexpl</code> and <code>print.rosaexpl</code>.
Object printing and summary are available through:
<code>print.asca</code> and <code>summary.asca</code>.
Scores and loadings have their own extensions of <code>scores()</code> and <code>loadings()</code> through
<code>scores.asca</code> and <code>loadings.asca</code>. Special to ASCA is that scores are on a
factor level basis, while back-projected samples have their own function in <code>projections.asca</code>.
</p>


<h3>Value</h3>

<p>Returns depend on method used, e.g. <code>projections.asca</code> returns projected samples,
<code>scores.asca</code> return scores, while print and summary methods return the object invisibly.
</p>


<h3>References</h3>


<ul>
<li><p> Smilde, A., Jansen, J., Hoefsloot, H., Lamers,R., Van Der Greef, J., and Timmerman, M.(2005). ANOVA-Simultaneous Component Analysis (ASCA): A new tool for analyzing designed metabolomics data. Bioinformatics, 21(13), 3043–3048.
</p>
</li>
<li><p> Liland, K.H., Smilde, A., Marini, F., and Næs,T. (2018). Confidence ellipsoids for ASCA models based on multivariate regression theory. Journal of Chemometrics, 32(e2990), 1–13.
</p>
</li>
<li><p> Martin, M. and Govaerts, B. (2020). LiMM-PCA: Combining ASCA+ and linear mixed models to analyse high-dimensional designed data. Journal of Chemometrics, 34(6), e3232.
</p>
</li></ul>



<h3>See Also</h3>

<p>Overviews of available methods, <code><a href="#topic+multiblock">multiblock</a></code>, and methods organised by main structure: <code><a href="#topic+basic">basic</a></code>, <code><a href="#topic+unsupervised">unsupervised</a></code>, <code><a href="#topic+asca">asca</a></code>, <code><a href="#topic+supervised">supervised</a></code> and <code><a href="#topic+complex">complex</a></code>.
Common functions for plotting are found in <code><a href="#topic+asca_plots">asca_plots</a></code>.
</p>

<hr>
<h2 id='basic'>Single- and Two-Block Methods</h2><span id='topic+basic'></span>

<h3>Description</h3>

<p>This documentation covers a range of single- and two-block methods. In particular:
</p>

<ul>
<li><p> PCA - Principal Component Analysis (<code><a href="#topic+pca">pca</a></code>)
</p>
</li>
<li><p> PCR - Principal Component Regression (<code><a href="#topic+pcr">pcr</a></code>)
</p>
</li>
<li><p> PLSR - Partial Least Squares Regression (<code><a href="#topic+plsr">plsr</a></code>)
</p>
</li>
<li><p> CCA - Canonical Correlation Analysis (<code><a href="#topic+cca">cca</a></code>)
</p>
</li>
<li><p> IFA - Interbattery Factor Analysis (<code><a href="#topic+ifa">ifa</a></code>)
</p>
</li>
<li><p> GSVD - Generalized SVD (<code><a href="#topic+gsvd">gsvd</a></code>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Overviews of available methods, <code><a href="#topic+multiblock">multiblock</a></code>, and methods organised by main structure: <code><a href="#topic+basic">basic</a></code>, <code><a href="#topic+unsupervised">unsupervised</a></code>, <code><a href="#topic+asca">asca</a></code>, <code><a href="#topic+supervised">supervised</a></code> and <code><a href="#topic+complex">complex</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(potato)
X &lt;- potato$Chemical
y &lt;- potato$Sensory[,1,drop=FALSE]

pca.pot  &lt;- pca(X, ncomp = 2)
pcr.pot  &lt;- pcr(y ~ X, ncomp = 2)
pls.pot  &lt;- plsr(y ~ X, ncomp = 2)
cca.pot  &lt;- cca(potato[1:2])
ifa.pot  &lt;- ifa(potato[1:2])
gsvd.pot &lt;- gsvd(lapply(potato[3:4], t))

</code></pre>

<hr>
<h2 id='block.data.frame'>Block-wise indexable data.frame</h2><span id='topic+block.data.frame'></span>

<h3>Description</h3>

<p>This is a convenience function for making <code>data.frame</code>s that are easily
indexed on a block-wise basis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>block.data.frame(X, block_inds = NULL, to.matrix = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="block.data.frame_+3A_x">X</code></td>
<td>
<p>Either a single <code>data.frame</code> to index or a <code>list</code> of matrices/data.frames</p>
</td></tr>
<tr><td><code id="block.data.frame_+3A_block_inds">block_inds</code></td>
<td>
<p>Named <code>list</code> of indexes if <code>X</code> is a single <code>data.frame</code>, otherwise <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="block.data.frame_+3A_to.matrix">to.matrix</code></td>
<td>
<p><code>logical</code> indicating if input list elements should be converted to matrices.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code> which can be indexed block-wise.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Random data
M &lt;- matrix(rnorm(200), nrow = 10)
# .. with dimnames
dimnames(M) &lt;- list(LETTERS[1:10], as.character(1:20))

# A named list for indexing
inds &lt;- list(B1 = 1:10, B2 = 11:20)

X &lt;- block.data.frame(M, inds)
str(X)

</code></pre>

<hr>
<h2 id='candies'>Sensory assessment of candies.</h2><span id='topic+candies'></span>

<h3>Description</h3>

<p>A dataset containing 9 sensory attributes for 5 candies assessed
by 11 trained assessors.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(candies)
</code></pre>


<h3>Format</h3>

<p>A data.frame having 165 rows and 3 variables:
</p>

<dl>
<dt>assessment</dt><dd><p>Matrix of sensory attributes</p>
</dd>
<dt>assessor</dt><dd><p>Factor of assessors</p>
</dd>
<dt>candy</dt><dd><p>Factor of candies</p>
</dd>
</dl>



<h3>References</h3>

<p>Luciano G, Næs T. Interpreting sensory data by combining principal
component analysis and analysis of variance. Food Qual Prefer. 2009;20(3):167-175.
</p>

<hr>
<h2 id='cca'>Canonical Correlation Analysis - CCA</h2><span id='topic+cca'></span>

<h3>Description</h3>

<p>This is a wrapper for the <code>stats::cancor</code> function for computing CCA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cca(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cca_+3A_x">X</code></td>
<td>
<p><code>list</code> of input data blocks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>CCA is a method which maximises correlation between linear combinations of the columns of
two blocks, i.e. max(cor(X1 x a, X2 x b)). This is done sequentially with deflation in between, such
that a sequence of correlations and weight vectors a and b are associated with a pair of matrices.
</p>


<h3>Value</h3>

<p><code>multiblock</code> object with associated with printing, scores, loadings. Relevant plotting functions: <code><a href="#topic+multiblock_plots">multiblock_plots</a></code>
and result functions: <code><a href="#topic+multiblock_results">multiblock_results</a></code>.
</p>


<h3>References</h3>

<p>Hotelling, H. (1936) Relations between two sets of variates. Biometrika, 28, 321–377.
</p>


<h3>See Also</h3>

<p>Overviews of available methods, <code><a href="#topic+multiblock">multiblock</a></code>, and methods organised by main structure: <code><a href="#topic+basic">basic</a></code>, <code><a href="#topic+unsupervised">unsupervised</a></code>, <code><a href="#topic+asca">asca</a></code>, <code><a href="#topic+supervised">supervised</a></code> and <code><a href="#topic+complex">complex</a></code>.
Common functions for computation and extraction of results and plotting are found in <code><a href="#topic+multiblock_results">multiblock_results</a></code> and <code><a href="#topic+multiblock_plots">multiblock_plots</a></code>, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(potato)
X &lt;- potato$Chemical

cca.pot  &lt;- cca(potato[1:2])
</code></pre>

<hr>
<h2 id='complex'>Methods With Complex Linkage</h2><span id='topic+complex'></span>

<h3>Description</h3>

<p>This documentation covers a few complex methods. In particular:
</p>

<ul>
<li><p> L-PLS - Partial Least Squares in L configuration (<code><a href="#topic+lpls">lpls</a></code>)
</p>
</li>
<li><p> SO-PLS-PM - Sequential and Orthogonalised PLS Path Modeling (<code><a href="#topic+sopls_pm">sopls_pm</a></code>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Overviews of available methods, <code><a href="#topic+multiblock">multiblock</a></code>, and methods organised by main structure: <code><a href="#topic+basic">basic</a></code>, <code><a href="#topic+unsupervised">unsupervised</a></code>, <code><a href="#topic+asca">asca</a></code>, <code><a href="#topic+supervised">supervised</a></code> and <code><a href="#topic+complex">complex</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># L-PLS
sim &lt;- lplsData(I = 30, N = 20, J = 5, K = 6, ncomp = 2)
X1  &lt;- sim$X1; X2 &lt;- sim$X2; X3 &lt;- sim$X3
lp  &lt;- lpls(X1,X2,X3) # exo-L-PLS

</code></pre>

<hr>
<h2 id='compnames'>Vector of component names</h2><span id='topic+compnames'></span>

<h3>Description</h3>

<p>Convenience function for creating a vector
of component names based on the dimensions the input object
(<code>matrix</code> or object having a <code>score</code> function).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compnames(object, comps, explvar = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="compnames_+3A_object">object</code></td>
<td>
<p>An object fitted using the multiblock package.</p>
</td></tr>
<tr><td><code id="compnames_+3A_comps">comps</code></td>
<td>
<p><code>integer</code> vector of components.</p>
</td></tr>
<tr><td><code id="compnames_+3A_explvar">explvar</code></td>
<td>
<p><code>logical</code> indicating if explained variances should be included.</p>
</td></tr>
<tr><td><code id="compnames_+3A_...">...</code></td>
<td>
<p>Unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This is a copy of <code>compnames</code> from the <code>pls</code> package to work with
<code>multiblock</code> objects.
</p>


<h3>Value</h3>

<p>A <code>character</code> vector of component names.
</p>

<hr>
<h2 id='disco'>Distinctive and Common Components with SCA - DISCO</h2><span id='topic+disco'></span>

<h3>Description</h3>

<p>This is a wrapper for the <code>DISCOsca</code> function by Zhengguo Gu for computing DISCO.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>disco(X, ncomp = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="disco_+3A_x">X</code></td>
<td>
<p><code>list</code> of input blocks.</p>
</td></tr>
<tr><td><code id="disco_+3A_ncomp">ncomp</code></td>
<td>
<p><code>integer</code> number of components to extract.</p>
</td></tr>
<tr><td><code id="disco_+3A_...">...</code></td>
<td>
<p>additional arguments (not used).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>DISCO is a restriction of SCA where Alternating Least Squares is used for
estimation of loadings and scores. The SCA solution is rotated towards loadings (in sample linked mode) which are filled with
zeros in a pattern resembling distinct, local and common components.
When used in sample linked mode and only selecting distinct components, it shares a
resemblance to SO-PLS, only in an unsupervised setting. Explained variances
are computed as proportion of block variation explained by scores*loadings'.
</p>


<h3>Value</h3>

<p><code>multiblock</code> object including relevant scores and loadings. Relevant plotting functions: <code><a href="#topic+multiblock_plots">multiblock_plots</a></code>
and result functions: <code><a href="#topic+multiblock_results">multiblock_results</a></code>.
</p>


<h3>References</h3>

<p>Schouteden, M., Van Deun, K., Wilderjans, T. F., &amp; Van Mechelen, I. (2014). Performing DISCO-SCA to search for distinctive and common information in linked data. Behavior research methods, 46(2), 576-587.
</p>


<h3>See Also</h3>

<p>Overviews of available methods, <code><a href="#topic+multiblock">multiblock</a></code>, and methods organised by main structure: <code><a href="#topic+basic">basic</a></code>, <code><a href="#topic+unsupervised">unsupervised</a></code>, <code><a href="#topic+asca">asca</a></code>, <code><a href="#topic+supervised">supervised</a></code> and <code><a href="#topic+complex">complex</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(potato)
potList &lt;- as.list(potato[c(1,2,9)])
pot.disco  &lt;- disco(potList)
plot(scores(pot.disco), labels="names")

</code></pre>

<hr>
<h2 id='DISCOsca'>DISCO-SCA rotation.</h2><span id='topic+DISCOsca'></span>

<h3>Description</h3>

<p>A DISCO-SCA procedure for identifying common and distinctive components. The code is adapted from the orphaned RegularizedSCA package by Zhengguo Gu.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DISCOsca(DATA, R, Jk)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DISCOsca_+3A_data">DATA</code></td>
<td>
<p>A matrix, which contains the concatenated data with the same subjects from multiple blocks.
Note that each row represents a subject.</p>
</td></tr>
<tr><td><code id="DISCOsca_+3A_r">R</code></td>
<td>
<p>Number of components (R&gt;=2).</p>
</td></tr>
<tr><td><code id="DISCOsca_+3A_jk">Jk</code></td>
<td>
<p>A vector containing number of variables in the concatenated data matrix.</p>
</td></tr>
</table>


<h3>Value</h3>

<table>
<tr><td><code>Trot_best</code></td>
<td>
<p>Estimated component score matrix (i.e., T)</p>
</td></tr>
<tr><td><code>Prot_best</code></td>
<td>
<p>Estimated component loading matrix (i.e., P)</p>
</td></tr>
<tr><td><code>comdist</code></td>
<td>
<p>A matrix representing common distinctive components. (Rows are data blocks and columns are components.) 0 in the matrix indicating that the corresponding
component of that block is estimated to be zeros, and 1 indicates that (at least one component loading in) the corresponding component of that block is not zero.
Thus, if a column in the <code>comdist</code> matrix contains only 1's, then this column is a common component, otherwise distinctive component.</p>
</td></tr>
<tr><td><code>propExp_component</code></td>
<td>
<p>Proportion of variance per component.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Schouteden, M., Van Deun, K., Wilderjans, T. F., &amp; Van Mechelen, I. (2014).
Performing DISCO-SCA to search for distinctive and common information in linked data.
Behavior research methods, 46(2), 576-587.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
DATA1 &lt;- matrix(rnorm(50), nrow=5)
DATA2 &lt;- matrix(rnorm(100), nrow=5) 
DATA &lt;- cbind(DATA1, DATA2)
R &lt;- 5
Jk &lt;- c(10, 20) 
DISCOsca(DATA, R, Jk)

## End(Not run)
</code></pre>

<hr>
<h2 id='dummycode'>Dummy-coding of a single vector</h2><span id='topic+dummycode'></span>

<h3>Description</h3>

<p>Flexible dummy-coding allowing for all R's built-in types of contrasts
and optional dropping of a factor level to reduce rank defficiency probability.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dummycode(Y, contrast = "contr.sum", drop = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dummycode_+3A_y">Y</code></td>
<td>
<p><code>vector</code> to dummy code.</p>
</td></tr>
<tr><td><code id="dummycode_+3A_contrast">contrast</code></td>
<td>
<p>Contrast type, default = &quot;contr.sum&quot;.</p>
</td></tr>
<tr><td><code id="dummycode_+3A_drop">drop</code></td>
<td>
<p><code>logical</code> indicating if one level should be dropped (default = TRUE).</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>matrix</code> made by dummy-coding the input vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>vec &lt;- c("a","a","b","b","c","c")
dummycode(vec)
</code></pre>

<hr>
<h2 id='explvar'>Explained predictor variance</h2><span id='topic+explvar'></span>

<h3>Description</h3>

<p>Extraction and/or computation of explained variances for various
object classes in the <code>multiblock</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>explvar(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="explvar_+3A_object">object</code></td>
<td>
<p>An object fitted using a method from the multiblock package</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>vector</code> of component-wise explained variances for predictors.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(potato)
so &lt;- sopls(Sensory ~ Chemical + Compression, data=potato, ncomp=c(10,10), 
            max_comps=10)
explvar(so)
</code></pre>

<hr>
<h2 id='extended.model.frame'>Extracting the Extended Model Frame from a Formula or Fit</h2><span id='topic+extended.model.frame'></span>

<h3>Description</h3>

<p>This function attempts to apply <code><a href="stats.html#topic+model.frame">model.frame</a></code> and extend the
result with columns of interactions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>extended.model.frame(formula, data, ..., sep = ".")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="extended.model.frame_+3A_formula">formula</code></td>
<td>
<p>a model formula or terms object or an R object.</p>
</td></tr>
<tr><td><code id="extended.model.frame_+3A_data">data</code></td>
<td>
<p>a data.frame, list or environment (see <code><a href="stats.html#topic+model.frame">model.frame</a></code>).</p>
</td></tr>
<tr><td><code id="extended.model.frame_+3A_...">...</code></td>
<td>
<p>further arguments to pass to <code><a href="stats.html#topic+model.frame">model.frame</a></code>.</p>
</td></tr>
<tr><td><code id="extended.model.frame_+3A_sep">sep</code></td>
<td>
<p>separator in contraction of names for interactions (default = &quot;.&quot;).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="base.html#topic+data.frame">data.frame</a></code> that includes everything a <code><a href="stats.html#topic+model.frame">model.frame</a></code>
does plus interaction terms.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dat &lt;- data.frame(Y = c(1,2,3,4,5,6), 
                  X = factor(LETTERS[c(1,1,2,2,3,3)]), 
                  W = factor(letters[c(1,2,1,2,1,2)]))
extended.model.frame(Y ~ X*W, dat)
</code></pre>

<hr>
<h2 id='gca'>Generalized Canonical Analysis - GCA</h2><span id='topic+gca'></span>

<h3>Description</h3>

<p>This is an interface to both SVD-based (default) and RGCCA-based GCA (wrapping the
<code>RGCCA::rgcca</code> function)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gca(X, ncomp = "max", svd = TRUE, tol = 10^-12, corrs = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gca_+3A_x">X</code></td>
<td>
<p><code>list</code> of input blocks.</p>
</td></tr>
<tr><td><code id="gca_+3A_ncomp">ncomp</code></td>
<td>
<p><code>integer</code> number of components to extract, either single integer (equal for all blocks), vector (individual per block) or 'max' for maximum possible number of components.</p>
</td></tr>
<tr><td><code id="gca_+3A_svd">svd</code></td>
<td>
<p><code>logical</code> indicating if Singular Value Decomposition approach should be used (default=TRUE).</p>
</td></tr>
<tr><td><code id="gca_+3A_tol">tol</code></td>
<td>
<p><code>numeric</code> tolerance for component inclusion (singular values).</p>
</td></tr>
<tr><td><code id="gca_+3A_corrs">corrs</code></td>
<td>
<p><code>logical</code> indicating if correlations should be calculated for RGCCA based approach.</p>
</td></tr>
<tr><td><code id="gca_+3A_...">...</code></td>
<td>
<p>additional arguments for RGCCA approach.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>GCA is a generalisation of Canonical Correlation Analysis to handle three or more
blocks. There are several ways to generalise, and two of these are available through <code>gca</code>.
The default is an SVD based approach estimating a common subspace and measuring mean squared
correlation to this. An alternative approach is available through RGCCA. For the SVD based
approach, the <code>ncomp</code> parameter controls the block-wise decomposition while the following
the consensus decomposition is limited to the minimum number of components from the individual blocks.
</p>


<h3>Value</h3>

<p><code>multiblock</code> object including relevant scores and loadings. Relevant plotting functions: <code><a href="#topic+multiblock_plots">multiblock_plots</a></code>
and result functions: <code><a href="#topic+multiblock_results">multiblock_results</a></code>. <code>blockCoef</code> contains canonical coefficients, while
<code>blockDecomp</code> contains decompositions of each block.
</p>


<h3>References</h3>


<ul>
<li><p> Carroll, J. D. (1968). Generalization of canonical correlation analysis to three or more sets of variables. Proceedings of the American Psychological Association, pages 227-22.
</p>
</li>
<li><p> Van der Burg, E. and Dijksterhuis, G. (1996). Generalised canonical analysis of individual sensory profiles and instrument data, Elsevier, pp. 221–258.
</p>
</li></ul>



<h3>See Also</h3>

<p>Overviews of available methods, <code><a href="#topic+multiblock">multiblock</a></code>, and methods organised by main structure: <code><a href="#topic+basic">basic</a></code>, <code><a href="#topic+unsupervised">unsupervised</a></code>, <code><a href="#topic+asca">asca</a></code>, <code><a href="#topic+supervised">supervised</a></code> and <code><a href="#topic+complex">complex</a></code>.
Common functions for computation and extraction of results and plotting are found in <code><a href="#topic+multiblock_results">multiblock_results</a></code> and <code><a href="#topic+multiblock_plots">multiblock_plots</a></code>, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(potato)
potList &lt;- as.list(potato[c(1,2,9)])
pot.gca &lt;- gca(potList)
plot(scores(pot.gca), labels="names")

</code></pre>

<hr>
<h2 id='gpa'>Generalized Procrustes Analysis - GPA</h2><span id='topic+gpa'></span>

<h3>Description</h3>

<p>This is a wrapper for the <code>FactoMineR::GPA</code> function for computing GPA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gpa(X, graph = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gpa_+3A_x">X</code></td>
<td>
<p><code>list</code> of input blocks.</p>
</td></tr>
<tr><td><code id="gpa_+3A_graph">graph</code></td>
<td>
<p><code>logical</code> indicating if decomposition should be plotted.</p>
</td></tr>
<tr><td><code id="gpa_+3A_...">...</code></td>
<td>
<p>additional arguments for RGCCA approach.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>GPA is a generalisation of Procrustes analysis, where one matrix is scaled and
rotated to be as similar as possible to another one. Through the generalisation, individual
scaling and rotation of each input matrix is performed against a common
representation which is estimated in an iterative manner.
</p>


<h3>Value</h3>

<p><code>multiblock</code> object including relevant scores and loadings. Relevant plotting functions: <code><a href="#topic+multiblock_plots">multiblock_plots</a></code>
and result functions: <code><a href="#topic+multiblock_results">multiblock_results</a></code>.
</p>


<h3>References</h3>

<p>Gower, J. C. (1975). Generalized procrustes analysis. Psychometrika. 40: 33–51.
</p>


<h3>See Also</h3>

<p>Overviews of available methods, <code><a href="#topic+multiblock">multiblock</a></code>, and methods organised by main structure: <code><a href="#topic+basic">basic</a></code>, <code><a href="#topic+unsupervised">unsupervised</a></code>, <code><a href="#topic+asca">asca</a></code>, <code><a href="#topic+supervised">supervised</a></code> and <code><a href="#topic+complex">complex</a></code>.
Common functions for computation and extraction of results and plotting are found in <code><a href="#topic+multiblock_results">multiblock_results</a></code> and <code><a href="#topic+multiblock_plots">multiblock_plots</a></code>, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(potato)
potList &lt;- as.list(potato[c(1,2,9)])
pot.gpa    &lt;- gpa(potList)
plot(scores(pot.gpa), labels="names")

</code></pre>

<hr>
<h2 id='gsvd'>Generalised Singular Value Decomposition - GSVD</h2><span id='topic+gsvd'></span>

<h3>Description</h3>

<p>This is a wrapper for the <code>geigen::gsvd</code> function for computing GSVD.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>gsvd(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="gsvd_+3A_x">X</code></td>
<td>
<p><code>list</code> of input data blocks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>GSVD is a generalisation of SVD to two variable-linked matrices where common loadings
and block-wise scores are estimated.
</p>


<h3>Value</h3>

<p><code>multiblock</code> object with associated with printing, scores, loadings. Relevant plotting functions: <code><a href="#topic+multiblock_plots">multiblock_plots</a></code>
and result functions: <code><a href="#topic+multiblock_results">multiblock_results</a></code>.
</p>


<h3>References</h3>

<p>Van Loan, C. (1976) Generalizing the singular value decomposition. SIAM Journal on Numerical Analysis, 13, 76–83.
</p>


<h3>See Also</h3>

<p>Overviews of available methods, <code><a href="#topic+multiblock">multiblock</a></code>, and methods organised by main structure: <code><a href="#topic+basic">basic</a></code>, <code><a href="#topic+unsupervised">unsupervised</a></code>, <code><a href="#topic+asca">asca</a></code>, <code><a href="#topic+supervised">supervised</a></code> and <code><a href="#topic+complex">complex</a></code>.
Common functions for computation and extraction of results and plotting are found in <code><a href="#topic+multiblock_results">multiblock_results</a></code> and <code><a href="#topic+multiblock_plots">multiblock_plots</a></code>, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(potato)
X &lt;- potato$Chemical

gsvd.pot &lt;- gsvd(lapply(potato[3:4], t))

</code></pre>

<hr>
<h2 id='hogsvd'>Higher Order Generalized SVD - HOGSVD</h2><span id='topic+hogsvd'></span>

<h3>Description</h3>

<p>This is a simple implementation for computing HOGSVD
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hogsvd(X)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hogsvd_+3A_x">X</code></td>
<td>
<p><code>list</code> of input blocks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>HOGSVD is a generalisation of SVD to two or more blocks. It finds a common set
of loadings across blocks and individual sets of scores per block.
</p>


<h3>Value</h3>

<p><code>multiblock</code> object including relevant scores and loadings. Relevant plotting functions: <code><a href="#topic+multiblock_plots">multiblock_plots</a></code>
and result functions: <code><a href="#topic+multiblock_results">multiblock_results</a></code>.
</p>


<h3>References</h3>

<p>Ponnapalli, S. P., Saunders, M. A., Van Loan, C. F., &amp; Alter, O. (2011). A higher-order generalized singular value decomposition for comparison of global mRNA expression from multiple organisms. PloS one, 6(12), e28072.
</p>


<h3>See Also</h3>

<p>Overviews of available methods, <code><a href="#topic+multiblock">multiblock</a></code>, and methods organised by main structure: <code><a href="#topic+basic">basic</a></code>, <code><a href="#topic+unsupervised">unsupervised</a></code>, <code><a href="#topic+asca">asca</a></code>, <code><a href="#topic+supervised">supervised</a></code> and <code><a href="#topic+complex">complex</a></code>.
Common functions for computation and extraction of results and plotting are found in <code><a href="#topic+multiblock_results">multiblock_results</a></code> and <code><a href="#topic+multiblock_plots">multiblock_plots</a></code>, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(candies)
candyList &lt;- lapply(1:nlevels(candies$candy),function(x)candies$assessment[candies$candy==x,])
can.hogsvd &lt;- hogsvd(candyList)
scoreplot(can.hogsvd, block=1, labels="names")

</code></pre>

<hr>
<h2 id='hpca'>Hierarchical Principal component analysis - HPCA</h2><span id='topic+hpca'></span>

<h3>Description</h3>

<p>This is a wrapper for the <code>RGCCA::rgcca</code> function for computing HPCA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hpca(X, ncomp = 2, scale = FALSE, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="hpca_+3A_x">X</code></td>
<td>
<p><code>list</code> of input blocks.</p>
</td></tr>
<tr><td><code id="hpca_+3A_ncomp">ncomp</code></td>
<td>
<p><code>integer</code> number of components to extract.</p>
</td></tr>
<tr><td><code id="hpca_+3A_scale">scale</code></td>
<td>
<p><code>logical</code> indicating if variables should be scaled.</p>
</td></tr>
<tr><td><code id="hpca_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> indicating if diagnostic information should be printed.</p>
</td></tr>
<tr><td><code id="hpca_+3A_...">...</code></td>
<td>
<p>additional arguments for RGCCA.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>HPCA is a hierarchical PCA analysis which combines two or more blocks
into a two-level decomposition with block-wise loadings and scores and superlevel
common loadings and scores. The method is closely related to the supervised method MB-PLS
in structure.
</p>


<h3>Value</h3>

<p><code>multiblock</code> object including relevant scores and loadings. Relevant plotting functions: <code><a href="#topic+multiblock_plots">multiblock_plots</a></code>
and result functions: <code><a href="#topic+multiblock_results">multiblock_results</a></code>.
</p>


<h3>References</h3>

<p>Westerhuis, J.A., Kourti, T., and MacGregor,J.F. (1998). Analysis of multiblock and hierarchical PCA and PLS models. Journal of Chemometrics, 12, 301–321.
</p>


<h3>See Also</h3>

<p>Overviews of available methods, <code><a href="#topic+multiblock">multiblock</a></code>, and methods organised by main structure: <code><a href="#topic+basic">basic</a></code>, <code><a href="#topic+unsupervised">unsupervised</a></code>, <code><a href="#topic+asca">asca</a></code>, <code><a href="#topic+supervised">supervised</a></code> and <code><a href="#topic+complex">complex</a></code>.
Common functions for computation and extraction of results and plotting are found in <code><a href="#topic+multiblock_results">multiblock_results</a></code> and <code><a href="#topic+multiblock_plots">multiblock_plots</a></code>, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(potato)
potList &lt;- as.list(potato[c(1,2,9)])
pot.hpca   &lt;- hpca(potList)
plot(scores(pot.hpca), labels="names")

</code></pre>

<hr>
<h2 id='ifa'>Inter-battery Factor Analysis - IFA</h2><span id='topic+ifa'></span>

<h3>Description</h3>

<p>This is a wrapper for the <code>RGCCA::rgcca</code> function for computing IFA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ifa(X, ncomp = 1, scale = FALSE, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ifa_+3A_x">X</code></td>
<td>
<p><code>list</code> of input data blocks.</p>
</td></tr>
<tr><td><code id="ifa_+3A_ncomp">ncomp</code></td>
<td>
<p><code>integer</code> number of principal components to return.</p>
</td></tr>
<tr><td><code id="ifa_+3A_scale">scale</code></td>
<td>
<p><code>logical</code> indicating if variables should be standardised (default=FALSE).</p>
</td></tr>
<tr><td><code id="ifa_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> indicating if intermediate results should be printed.</p>
</td></tr>
<tr><td><code id="ifa_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>RGCCA::rgcca</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>IFA rotates two matrices to align one or more factors against each other, maximising correlations.
</p>


<h3>Value</h3>

<p><code>multiblock</code> object with associated with printing, scores, loadings. Relevant plotting functions: <code><a href="#topic+multiblock_plots">multiblock_plots</a></code>
and result functions: <code><a href="#topic+multiblock_results">multiblock_results</a></code>.
</p>


<h3>References</h3>

<p>Tucker, L. R. (1958). An inter-battery method of factor analysis. Psychometrika, 23(2), 111-136.
</p>


<h3>See Also</h3>

<p>Overviews of available methods, <code><a href="#topic+multiblock">multiblock</a></code>, and methods organised by main structure: <code><a href="#topic+basic">basic</a></code>, <code><a href="#topic+unsupervised">unsupervised</a></code>, <code><a href="#topic+asca">asca</a></code>, <code><a href="#topic+supervised">supervised</a></code> and <code><a href="#topic+complex">complex</a></code>.
Common functions for computation and extraction of results and plotting are found in <code><a href="#topic+multiblock_results">multiblock_results</a></code> and <code><a href="#topic+multiblock_plots">multiblock_plots</a></code>, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(potato)
X &lt;- potato$Chemical

ifa.pot  &lt;- ifa(potato[1:2])
</code></pre>

<hr>
<h2 id='jive'>Joint and Individual Variation Explained - JIVE</h2><span id='topic+jive'></span>

<h3>Description</h3>

<p>This is a wrapper for the <code>r.jive::jive</code> function for computing JIVE.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jive(X, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="jive_+3A_x">X</code></td>
<td>
<p><code>list</code> of input blocks.</p>
</td></tr>
<tr><td><code id="jive_+3A_...">...</code></td>
<td>
<p>additional arguments for <code>r.jive::jive</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Jive performs a decomposition of the variation in two or more blocks into
low-dimensional representations of individual and joint variation plus residual variation.
</p>


<h3>Value</h3>

<p><code>multiblock</code> object including relevant scores and loadings. Relevant plotting functions: <code><a href="#topic+multiblock_plots">multiblock_plots</a></code>
and result functions: <code><a href="#topic+multiblock_results">multiblock_results</a></code>.
</p>


<h3>References</h3>

<p>Lock, E., Hoadley, K., Marron, J., and Nobel, A. (2013) Joint and individual variation explained (JIVE) for integrated analysis of multiple data types. Ann Appl Stat, 7 (1), 523–542.
</p>


<h3>See Also</h3>

<p>Overviews of available methods, <code><a href="#topic+multiblock">multiblock</a></code>, and methods organised by main structure: <code><a href="#topic+basic">basic</a></code>, <code><a href="#topic+unsupervised">unsupervised</a></code>, <code><a href="#topic+asca">asca</a></code>, <code><a href="#topic+supervised">supervised</a></code> and <code><a href="#topic+complex">complex</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'> # Too time consuming for testing
  data(candies)
  candyList &lt;- lapply(1:nlevels(candies$candy),function(x)candies$assessment[candies$candy==x,])
  can.jive  &lt;- jive(candyList)
  summary(can.jive)


</code></pre>

<hr>
<h2 id='lpls'>L-PLS regression</h2><span id='topic+lpls'></span>

<h3>Description</h3>

<p>Simultaneous decomposition of three blocks connected in an L pattern.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lpls(
  X1,
  X2,
  X3,
  ncomp = 2,
  doublecenter = TRUE,
  scale = c(FALSE, FALSE, FALSE),
  type = c("exo"),
  impute = FALSE,
  niter = 25,
  subsetX2 = NULL,
  subsetX3 = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lpls_+3A_x1">X1</code></td>
<td>
<p><code>matrix</code> of size IxN (middle matrix)</p>
</td></tr>
<tr><td><code id="lpls_+3A_x2">X2</code></td>
<td>
<p><code>matrix</code> of size IxJ (left matrix)</p>
</td></tr>
<tr><td><code id="lpls_+3A_x3">X3</code></td>
<td>
<p><code>matrix</code> of size KxN (top matrix)</p>
</td></tr>
<tr><td><code id="lpls_+3A_ncomp">ncomp</code></td>
<td>
<p>number of L-PLS components</p>
</td></tr>
<tr><td><code id="lpls_+3A_doublecenter">doublecenter</code></td>
<td>
<p><code>logical</code> indicating if centering should be done both ways for X1 (default=TRUE)</p>
</td></tr>
<tr><td><code id="lpls_+3A_scale">scale</code></td>
<td>
<p><code>logical vector</code> of length three indicating if each of the matrices should be autoscaled.</p>
</td></tr>
<tr><td><code id="lpls_+3A_type">type</code></td>
<td>
<p><code>character</code> indicating type of L-PLS (&quot;exo&quot;=default, &quot;exo_ort&quot; or &quot;endo&quot;)</p>
</td></tr>
<tr><td><code id="lpls_+3A_impute">impute</code></td>
<td>
<p><code>logical</code> indicating if SVD-based imputation of missing data is required.</p>
</td></tr>
<tr><td><code id="lpls_+3A_niter">niter</code></td>
<td>
<p><code>numeric</code> giving number of iterations in component extraction loop.</p>
</td></tr>
<tr><td><code id="lpls_+3A_subsetx2">subsetX2</code></td>
<td>
<p><code>vector</code> defining optional sub-setting of X2 data.</p>
</td></tr>
<tr><td><code id="lpls_+3A_subsetx3">subsetX3</code></td>
<td>
<p><code>vector</code> defining optional sub-setting of X3 data.</p>
</td></tr>
<tr><td><code id="lpls_+3A_...">...</code></td>
<td>
<p>Additional arguments, not used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two versions of L-PLS
are available: exo- and endo-L-PLS which assume an outward or inward relationship between the
main block X1 and the two other blocks X2 and X3.
</p>
<p>The <code>exo_ort</code> algorithm returns orthogonal scores and should be chosen for visual
exploration in correlation loading plots. If exo-L-PLS with prediction is the main purpose
of the model then the non-orthogonal <code>exo</code> type L-PLS should be chosen for which the
predict function has prediction implemented.
</p>
<p><img src="../help/figures/LPLSsmall.png" alt="L-PLS diagram" />
</p>


<h3>Value</h3>

<p>An object of type <code>lpls</code> and <code>multiblock</code> containing all results from the L-PLS
analysis. The object type <code>lpls</code> is associated with functions for correlation loading plots,
prediction and cross-validation. The type <code>multiblock</code> is associated with the default functions
for result presentation (<code><a href="#topic+multiblock_results">multiblock_results</a></code>) and plotting (<code><a href="#topic+multiblock_plots">multiblock_plots</a></code>).
</p>


<h3>Author(s)</h3>

<p>Solve Sæbø (adapted by Kristian Hovde Liland)
</p>


<h3>References</h3>


<ul>
<li><p> Martens, H., Anderssen, E., Flatberg, A.,Gidskehaug, L.H., Høy, M., Westad, F.,Thybo, A., and Martens, M. (2005). Regression of a data matrix on descriptors of both its rows and of its columns via latent variables: L-PLSR. Computational Statistics &amp; Data Analysis, 48(1), 103 – 123.
</p>
</li>
<li><p> Sæbø, S., Almøy, T., Flatberg, A., Aastveit, A.H., and Martens, H. (2008). LPLS-regression: a method for prediction and classification under the influence of background information on predictor variables. Chemometrics and Intelligent Laboratory Systems, 91, 121–132.
</p>
</li>
<li><p> Sæbø, S., Martens, M. and Martens H. (2010) Three-block data modeling by endo- and exo-LPLS regression. In Handbook of Partial Least Squares: Concepts, Methods and Applications. Esposito Vinzi, V.; Chin, W.W.; Henseler, J.; Wang, H. (Eds.). Springer.
</p>
</li></ul>



<h3>See Also</h3>

<p>Overviews of available methods, <code><a href="#topic+multiblock">multiblock</a></code>, and methods organised by main structure: <code><a href="#topic+basic">basic</a></code>, <code><a href="#topic+unsupervised">unsupervised</a></code>, <code><a href="#topic+asca">asca</a></code>, <code><a href="#topic+supervised">supervised</a></code> and <code><a href="#topic+complex">complex</a></code>.
Functions for computation and extraction of results and plotting are found in <code><a href="#topic+lpls_results">lpls_results</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate data set
sim &lt;- lplsData(I = 30, N = 20, J = 5, K = 6, ncomp = 2)
X1  &lt;- sim$X1; X2 &lt;- sim$X2; X3 &lt;- sim$X3
lp  &lt;- lpls(X1,X2,X3) # exo-L-PLS

</code></pre>

<hr>
<h2 id='lpls_results'>Result functions for L-PLS objects (<code>lpls</code>)</h2><span id='topic+lpls_results'></span><span id='topic+plot.lpls'></span><span id='topic+predict.lpls'></span><span id='topic+lplsCV'></span>

<h3>Description</h3>

<p>Correlation loading plot, prediction and cross-validation for L-PLS
models with class <code><a href="#topic+lpls">lpls</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'lpls'
plot(
  x,
  comps = c(1, 2),
  doplot = c(TRUE, TRUE, TRUE),
  level = c(2, 2, 2),
  arrow = c(1, 0, 1),
  xlim = c(-1, 1),
  ylim = c(-1, 1),
  samplecol = 4,
  pathcol = 2,
  varcol = "grey70",
  varsize = 1,
  sampleindex = 1:dim(x$corloadings$R22)[1],
  pathindex = 1:dim(x$corloadings$R3)[1],
  varindex = 1:dim(x$corloadings$R21)[1],
  ...
)

## S3 method for class 'lpls'
predict(
  object,
  X1new = NULL,
  X2new = NULL,
  X3new = NULL,
  exo.direction = c("X2", "X3"),
  ...
)

lplsCV(object, segments1 = NULL, segments2 = NULL, trace = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lpls_results_+3A_x">x</code></td>
<td>
<p><code>lpls</code> object</p>
</td></tr>
<tr><td><code id="lpls_results_+3A_comps">comps</code></td>
<td>
<p><code>integer</code> vector of components.</p>
</td></tr>
<tr><td><code id="lpls_results_+3A_doplot">doplot</code></td>
<td>
<p><code>logical</code> indicating if plotting should be performed.</p>
</td></tr>
<tr><td><code id="lpls_results_+3A_level">level</code></td>
<td>
<p><code>integer</code> vector of length 3 for selecting plot symbol. 1=dots. 2=dimnames.</p>
</td></tr>
<tr><td><code id="lpls_results_+3A_arrow">arrow</code></td>
<td>
<p><code>integer</code> vector of length 3 indicating arrows (1) or not (0).</p>
</td></tr>
<tr><td><code id="lpls_results_+3A_xlim">xlim</code></td>
<td>
<p><code>numeric</code> x limits.</p>
</td></tr>
<tr><td><code id="lpls_results_+3A_ylim">ylim</code></td>
<td>
<p><code>numeric</code> y limits.</p>
</td></tr>
<tr><td><code id="lpls_results_+3A_samplecol">samplecol</code></td>
<td>
<p><code>character</code> for sample colours.</p>
</td></tr>
<tr><td><code id="lpls_results_+3A_pathcol">pathcol</code></td>
<td>
<p><code>character</code> for third colour.</p>
</td></tr>
<tr><td><code id="lpls_results_+3A_varcol">varcol</code></td>
<td>
<p><code>character</code> for variable colours.</p>
</td></tr>
<tr><td><code id="lpls_results_+3A_varsize">varsize</code></td>
<td>
<p><code>numeric</code> size of symbols for variables.</p>
</td></tr>
<tr><td><code id="lpls_results_+3A_sampleindex">sampleindex</code></td>
<td>
<p><code>integer</code> for selecting samples.</p>
</td></tr>
<tr><td><code id="lpls_results_+3A_pathindex">pathindex</code></td>
<td>
<p><code>integer</code> for selecting in third direction.</p>
</td></tr>
<tr><td><code id="lpls_results_+3A_varindex">varindex</code></td>
<td>
<p><code>integer</code> for selecting variables.</p>
</td></tr>
<tr><td><code id="lpls_results_+3A_...">...</code></td>
<td>
<p>Not implemented.</p>
</td></tr>
<tr><td><code id="lpls_results_+3A_object">object</code></td>
<td>
<p><code>lpls</code> object.</p>
</td></tr>
<tr><td><code id="lpls_results_+3A_x1new">X1new</code></td>
<td>
<p><code>matrix</code> of new X1 samples.</p>
</td></tr>
<tr><td><code id="lpls_results_+3A_x2new">X2new</code></td>
<td>
<p><code>matrix</code> of new X2 samples.</p>
</td></tr>
<tr><td><code id="lpls_results_+3A_x3new">X3new</code></td>
<td>
<p><code>matrix</code> of new X3 samples.</p>
</td></tr>
<tr><td><code id="lpls_results_+3A_exo.direction">exo.direction</code></td>
<td>
<p><code>character</code> selecting &quot;X2&quot; or &quot;X3&quot; prediction.</p>
</td></tr>
<tr><td><code id="lpls_results_+3A_segments1">segments1</code></td>
<td>
<p><code>list</code> of sample segments.</p>
</td></tr>
<tr><td><code id="lpls_results_+3A_segments2">segments2</code></td>
<td>
<p><code>list</code> of variable segments.</p>
</td></tr>
<tr><td><code id="lpls_results_+3A_trace">trace</code></td>
<td>
<p><code>logical</code> indicating if verbose mode should be selected.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Nothing is return for plotting (<code>plot.lpls</code>), predicted values are returned for predictions (<code>predict.lpls</code>)
and cross-validation metrics are returned for for cross-validation (<code>lplsCV</code>).
</p>


<h3>See Also</h3>

<p>Overviews of available methods, <code><a href="#topic+multiblock">multiblock</a></code>, and methods organised by main structure: <code><a href="#topic+basic">basic</a></code>, <code><a href="#topic+unsupervised">unsupervised</a></code>, <code><a href="#topic+asca">asca</a></code>, <code><a href="#topic+supervised">supervised</a></code> and <code><a href="#topic+complex">complex</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate data set
sim &lt;- lplsData(I = 30, N = 20, J = 5, K = 6, ncomp = 2)
X1  &lt;- sim$X1; X2 &lt;- sim$X2; X3 &lt;- sim$X3

# exo-L-PLS:
lp.exo  &lt;- lpls(X1,X2,X3, ncomp = 2)
# Predict X1
pred.exo.X2 &lt;- predict(lp.exo, X1new = X1, exo.direction = "X2")
# Predict X3
pred.exo.X2 &lt;- predict(lp.exo, X1new = X1, exo.direction = "X3")

# endo-L-PLS:
lp.endo &lt;- lpls(X1,X2,X3, ncomp = 2, type = "endo")
# Predict X1 from X2 and X3 (in this case fitted values):
pred.endo.X1 &lt;- predict(lp.endo, X2new = X2, X3new = X3)

# LOO cross-validation horizontally
lp.cv1 &lt;- lplsCV(lp.exo, segments1 = as.list(1:dim(X1)[1]))

# LOO cross-validation vertically
lp.cv2 &lt;- lplsCV(lp.exo, segments2 = as.list(1:dim(X1)[2]))

# Three-fold CV, horizontal
lp.cv3 &lt;- lplsCV(lp.exo, segments1 = as.list(1:10, 11:20, 21:30))

</code></pre>

<hr>
<h2 id='lplsData'>L-PLS data simulation for exo-type analysis</h2><span id='topic+lplsData'></span>

<h3>Description</h3>

<p>Three data blocks are simulated to express covariance in an exo-L-PLS direction (see <code><a href="#topic+lpls">lpls</a></code>.
Dimensionality and number of underlying components can be controlled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lplsData(I = 30, N = 20, J = 5, K = 6, ncomp = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lplsData_+3A_i">I</code></td>
<td>
<p><code>numeric</code> number of rows of X1 and X2</p>
</td></tr>
<tr><td><code id="lplsData_+3A_n">N</code></td>
<td>
<p><code>numeric</code> number of columns in X1 and X3</p>
</td></tr>
<tr><td><code id="lplsData_+3A_j">J</code></td>
<td>
<p><code>numeric</code> number of columns in X2</p>
</td></tr>
<tr><td><code id="lplsData_+3A_k">K</code></td>
<td>
<p><code>numeric</code> number of rows in X3</p>
</td></tr>
<tr><td><code id="lplsData_+3A_ncomp">ncomp</code></td>
<td>
<p><code>numeric</code> number of latent components</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> of three matrices with dimensions matching in an L-shape.
</p>


<h3>Author(s)</h3>

<p>Solve Sæbø (adapted by Kristian Hovde Liland)
</p>


<h3>See Also</h3>

<p>Overviews of available methods, <code><a href="#topic+multiblock">multiblock</a></code>, and methods organised by main structure: <code><a href="#topic+basic">basic</a></code>, <code><a href="#topic+unsupervised">unsupervised</a></code>, <code><a href="#topic+asca">asca</a></code>, <code><a href="#topic+supervised">supervised</a></code> and <code><a href="#topic+complex">complex</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>lp &lt;- lplsData(I = 30, N = 20, J = 5, K = 6, ncomp = 2)
names(lp)

</code></pre>

<hr>
<h2 id='maage'>Måge plot</h2><span id='topic+maage'></span><span id='topic+maageSeq'></span>

<h3>Description</h3>

<p>Måge plot for SO-PLS (<code><a href="#topic+sopls">sopls</a></code>) cross-validation visualisation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maage(
  object,
  expl_var = TRUE,
  pure.trace = FALSE,
  pch = 20,
  xlab = "# components",
  ylab = ifelse(expl_var, "Explained variance (%)", "RMSECV"),
  xlim = NULL,
  ylim = NULL,
  cex.text = 0.8,
  ...
)

maageSeq(
  object,
  compSeq = TRUE,
  expl_var = TRUE,
  pch = 20,
  xlab = "# components",
  ylab = ifelse(expl_var, "Explained variance (%)", "RMSECV"),
  xlim = NULL,
  ylim = NULL,
  cex.text = 0.8,
  col = "gray",
  col.block = c("red", "blue", "darkgreen", "purple", "black", "red", "blue",
    "darkgreen"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="maage_+3A_object">object</code></td>
<td>
<p>An SO-PLS model (<code>sopls</code> object)</p>
</td></tr>
<tr><td><code id="maage_+3A_expl_var">expl_var</code></td>
<td>
<p>Logical indicating if explained variance (default) or RMSECV should be displayed.</p>
</td></tr>
<tr><td><code id="maage_+3A_pure.trace">pure.trace</code></td>
<td>
<p>Logical indicating if single block solutions should be traced in the plot.</p>
</td></tr>
<tr><td><code id="maage_+3A_pch">pch</code></td>
<td>
<p>Scalar or symbol giving plot symbol.</p>
</td></tr>
<tr><td><code id="maage_+3A_xlab">xlab</code></td>
<td>
<p>Label for x-axis.</p>
</td></tr>
<tr><td><code id="maage_+3A_ylab">ylab</code></td>
<td>
<p>Label for y-axis.</p>
</td></tr>
<tr><td><code id="maage_+3A_xlim">xlim</code></td>
<td>
<p>Plot limits for x-axis (numeric vector).</p>
</td></tr>
<tr><td><code id="maage_+3A_ylim">ylim</code></td>
<td>
<p>Plot limits for y-axis (numeric vector).</p>
</td></tr>
<tr><td><code id="maage_+3A_cex.text">cex.text</code></td>
<td>
<p>Text scaling (scalar) for better readability of plots.</p>
</td></tr>
<tr><td><code id="maage_+3A_...">...</code></td>
<td>
<p>Additional arguments to <code>plot</code>.</p>
</td></tr>
<tr><td><code id="maage_+3A_compseq">compSeq</code></td>
<td>
<p>Integer vector giving the sequence of previous components chosen for <code>maageSeq</code> (see example).</p>
</td></tr>
<tr><td><code id="maage_+3A_col">col</code></td>
<td>
<p>Line colour in plot.</p>
</td></tr>
<tr><td><code id="maage_+3A_col.block">col.block</code></td>
<td>
<p>Line colours for blocks (default = c('red','blue','darkgreen','purple','black'))</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can either be used
for global optimisation across blocks or sequential optimisation, using <code>maageSeq</code>.
The examples below show typical usage.
</p>


<h3>Value</h3>

<p>The <code>maage</code> plot has no return.
</p>


<h3>See Also</h3>

<p>Overviews of available methods, <code><a href="#topic+multiblock">multiblock</a></code>, and methods organised by main structure: <code><a href="#topic+basic">basic</a></code>, <code><a href="#topic+unsupervised">unsupervised</a></code>, <code><a href="#topic+asca">asca</a></code>, <code><a href="#topic+supervised">supervised</a></code> and <code><a href="#topic+complex">complex</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wine)
ncomp &lt;- unlist(lapply(wine, ncol))[-5]
so.wine &lt;- sopls(`Global quality` ~ ., data=wine, ncomp=ncomp, 
            max_comps=10, validation="CV", segments=10)
maage(so.wine)

# Sequential search for optimal number of components per block
old.par &lt;- par(mfrow=c(2,2), mar=c(3,3,0.5,1), mgp=c(2,0.7,0))
maageSeq(so.wine)
maageSeq(so.wine, 2)
maageSeq(so.wine, c(2,1))
maageSeq(so.wine, c(2,1,1))
par(old.par)
</code></pre>

<hr>
<h2 id='mbpls'>Multiblock Partial Least Squares - MB-PLS</h2><span id='topic+mbpls'></span>

<h3>Description</h3>

<p>A function computing MB-PLS scores, loadings, etc. on the super-level and
block-level.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mbpls(
  formula,
  data,
  subset,
  na.action,
  X = NULL,
  Y = NULL,
  ncomp = 1,
  scale = FALSE,
  blockScale = c("sqrtnvar", "ssq", "none"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mbpls_+3A_formula">formula</code></td>
<td>
<p>Model formula accepting a single response (block) and predictor block names separated by + signs.</p>
</td></tr>
<tr><td><code id="mbpls_+3A_data">data</code></td>
<td>
<p>The data set to analyse.</p>
</td></tr>
<tr><td><code id="mbpls_+3A_subset">subset</code></td>
<td>
<p>Expression for subsetting the data before modelling.</p>
</td></tr>
<tr><td><code id="mbpls_+3A_na.action">na.action</code></td>
<td>
<p>How to handle NAs (no action implemented).</p>
</td></tr>
<tr><td><code id="mbpls_+3A_x">X</code></td>
<td>
<p><code>list</code> of input blocks. If X is supplied, the formula interface is skipped.</p>
</td></tr>
<tr><td><code id="mbpls_+3A_y">Y</code></td>
<td>
<p><code>matrix</code> of responses.</p>
</td></tr>
<tr><td><code id="mbpls_+3A_ncomp">ncomp</code></td>
<td>
<p><code>integer</code> number of PLS components.</p>
</td></tr>
<tr><td><code id="mbpls_+3A_scale">scale</code></td>
<td>
<p><code>logical</code> for autoscaling inputs (default = FALSE).</p>
</td></tr>
<tr><td><code id="mbpls_+3A_blockscale">blockScale</code></td>
<td>
<p>Either a <code>character</code> indicating type of block scaling or a <code>numeric</code> vector of block weights (see Details).</p>
</td></tr>
<tr><td><code id="mbpls_+3A_...">...</code></td>
<td>
<p>additional arguments to pls::plsr.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>MB-PLS is the prototypical component based supervised multiblock method.
It was originally formulated as a two-level method with a block-level and a super-level,
but it was later discovered that it could be expressed as an ordinary PLS on concatenated
weighted X blocks followed by a simple loop for calculating block-level loading weights,
loadings and scores. This implementation uses the <code><a href="pls.html#topic+plsr">plsr</a></code> function on the
scaled input blocks (1/sqrt(ncol)) enabling all summaries and plots from the <code>pls</code>
package.
</p>
<p>Block weighting is performed after scaling all variables and is by default
<code>"sqrtnvar"</code>: 1/sqrt(ncol(X[[i]])) in each block. Alternatives
are <code>"ssq"</code>: 1/norm(X[[i]], &quot;F&quot;)^2 and <code>"none"</code>: 1/1. Finally, if
a <code>numeric</code> vector is supplied, it will be used to scale the blocks
after <code>"ssq"</code> scaling, i.e., Z[[i]] = X[[i]] / norm(X[[i]], &quot;F&quot;)^2 * blockScale[i].
</p>


<h3>Value</h3>

<p><code>multiblock, mvr</code> object with super-scores, super-loadings, block-scores and block-loading, and the underlying
<code>mvr</code> (PLS) object for the super model, with all its result and plot possibilities. Relevant plotting functions: <code><a href="#topic+multiblock_plots">multiblock_plots</a></code>
and result functions: <code><a href="#topic+multiblock_results">multiblock_results</a></code>.
</p>


<h3>References</h3>


<ul>
<li><p> Wangen, L.E. and Kowalski, B.R. (1988). A multiblock partial least squares algorithm for investigating complex chemical systems. Journal of Chemometrics, 3, 3–20.
</p>
</li>
<li><p> Westerhuis, J.A., Kourti, T., and MacGregor,J.F. (1998). Analysis of multiblock and hierarchical PCA and PLS models. Journal of Chemometrics, 12, 301–321.
</p>
</li></ul>



<h3>See Also</h3>

<p>Overviews of available methods, <code><a href="#topic+multiblock">multiblock</a></code>, and methods organised by main structure: <code><a href="#topic+basic">basic</a></code>, <code><a href="#topic+unsupervised">unsupervised</a></code>, <code><a href="#topic+asca">asca</a></code>, <code><a href="#topic+supervised">supervised</a></code> and <code><a href="#topic+complex">complex</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(potato)
# Formula interface
mb &lt;- mbpls(Sensory ~ Chemical+Compression, data=potato, ncomp = 5)

# ... or X and Y
mb.XY &lt;- mbpls(X=potato[c('Chemical','Compression')], Y=potato[['Sensory']], ncomp = 5)
identical(mb$scores, mb.XY$scores)
print(mb)
scoreplot(mb, labels="names") # Exploiting mvr object structure from pls package

# Block scaling with emphasis on first block
mbs &lt;- mbpls(Sensory ~ Chemical+Compression, data=potato, ncomp = 5, blockScale = c(10, 1))
scoreplot(mbs, labels="names") # Exploiting mvr object structure from pls package
</code></pre>

<hr>
<h2 id='mbrda'>Multiblock Redundancy Analysis - mbRDA</h2><span id='topic+mbrda'></span>

<h3>Description</h3>

<p>This is a wrapper for the <code>ade4::mbpcaiv</code> function for computing mbRDA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mbrda(formula, data, subset, na.action, X = NULL, Y = NULL, ncomp = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mbrda_+3A_formula">formula</code></td>
<td>
<p>Model formula accepting a single response (block) and predictor block names separated by + signs.</p>
</td></tr>
<tr><td><code id="mbrda_+3A_data">data</code></td>
<td>
<p>The data set to analyse.</p>
</td></tr>
<tr><td><code id="mbrda_+3A_subset">subset</code></td>
<td>
<p>Expression for subsetting the data before modelling.</p>
</td></tr>
<tr><td><code id="mbrda_+3A_na.action">na.action</code></td>
<td>
<p>How to handle NAs (no action implemented).</p>
</td></tr>
<tr><td><code id="mbrda_+3A_x">X</code></td>
<td>
<p><code>list</code> of input blocks.</p>
</td></tr>
<tr><td><code id="mbrda_+3A_y">Y</code></td>
<td>
<p><code>matrix</code> of responses.</p>
</td></tr>
<tr><td><code id="mbrda_+3A_ncomp">ncomp</code></td>
<td>
<p><code>integer</code> number of PLS components.</p>
</td></tr>
<tr><td><code id="mbrda_+3A_...">...</code></td>
<td>
<p>additional arguments to ade4::mbpcaiv.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>mbRDA is a multiblock formulation of Redundancy (Data) Analysis. RDA is theoretically
between PLS and GCA. Like GCA, RDA does not consider correlations within X, but like
PLS it does consider correlations within Y. RDA can also be viewed as a PCR of Y constrained to
have scores that are also linear combinations of X. If the <code>adegraphics</code> package is attached,
a nice overview can be plotted as <code>plot(mbr$mbpcaiv)</code> following the example below.
</p>


<h3>Value</h3>

<p><code>multiblock, mvr</code> object with scores, block-scores and block-loading. Relevant plotting functions: <code><a href="#topic+multiblock_plots">multiblock_plots</a></code>
and result functions: <code><a href="#topic+multiblock_results">multiblock_results</a></code>.
</p>


<h3>References</h3>

<p>Bougeard, S., Qannari, E.M., Lupo, C., andHanafi, M. (2011). From Multiblock Partial Least Squares to Multiblock Redundancy Analysis. A Continuum Approach. Informatica, 22(1), 11–26.
</p>


<h3>See Also</h3>

<p>Overviews of available methods, <code><a href="#topic+multiblock">multiblock</a></code>, and methods organised by main structure: <code><a href="#topic+basic">basic</a></code>, <code><a href="#topic+unsupervised">unsupervised</a></code>, <code><a href="#topic+asca">asca</a></code>, <code><a href="#topic+supervised">supervised</a></code> and <code><a href="#topic+complex">complex</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Convert data.frame with AsIs objects to list of matrices
data(potato)
potatoList &lt;- lapply(potato, unclass)

mbr &lt;- mbrda(Sensory ~ Chemical + Compression, data = potatoList, ncomp = 10)
mbr.XY &lt;- mbrda(X = potatoList[c('Chemical','Compression')], Y = potatoList[['Sensory']], 
                ncomp = 10)
print(mbr)
scoreplot(mbr) # Exploiting mvr object structure from pls package
</code></pre>

<hr>
<h2 id='mcoa'>Multiple Co-Inertia Analysis - MCOA</h2><span id='topic+mcoa'></span>

<h3>Description</h3>

<p>This is a wrapper for the <code>RGCCA::rgcca</code> function for computing MCOA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcoa(X, ncomp = 2, scale = FALSE, verbose = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcoa_+3A_x">X</code></td>
<td>
<p><code>list</code> of input blocks.</p>
</td></tr>
<tr><td><code id="mcoa_+3A_ncomp">ncomp</code></td>
<td>
<p><code>integer</code> number of components to extract.</p>
</td></tr>
<tr><td><code id="mcoa_+3A_scale">scale</code></td>
<td>
<p><code>logical</code> indicating if variables should be scaled.</p>
</td></tr>
<tr><td><code id="mcoa_+3A_verbose">verbose</code></td>
<td>
<p><code>logical</code> indicating if diagnostic information should be printed.</p>
</td></tr>
<tr><td><code id="mcoa_+3A_...">...</code></td>
<td>
<p>additional arguments for RGCCA.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>MCOA resembles GCA and MFA in that it creates a set of reference scores, for which each
block's individual scores should correlate maximally too, but also the variance within
each block should be taken into account. A single component solution is equivalent to a
PCA on concatenated blocks scaled by the so called inverse inertia.
</p>


<h3>Value</h3>

<p><code>multiblock</code> object including relevant scores and loadings. Relevant plotting functions: <code><a href="#topic+multiblock_plots">multiblock_plots</a></code>
and result functions: <code><a href="#topic+multiblock_results">multiblock_results</a></code>.
</p>


<h3>References</h3>


<ul>
<li><p> Le Roux; B. and H. Rouanet (2004). Geometric Data Analysis, From Correspondence Analysis to Structured Data Analysis. Dordrecht. Kluwer: p.180.
</p>
</li>
<li><p> Greenacre, Michael and Blasius, Jörg (editors) (2006). Multiple Correspondence Analysis and Related Methods. London: Chapman &amp; Hall/CRC.
</p>
</li></ul>



<h3>See Also</h3>

<p>Overviews of available methods, <code><a href="#topic+multiblock">multiblock</a></code>, and methods organised by main structure: <code><a href="#topic+basic">basic</a></code>, <code><a href="#topic+unsupervised">unsupervised</a></code>, <code><a href="#topic+asca">asca</a></code>, <code><a href="#topic+supervised">supervised</a></code> and <code><a href="#topic+complex">complex</a></code>.
Common functions for computation and extraction of results and plotting are found in <code><a href="#topic+multiblock_results">multiblock_results</a></code> and <code><a href="#topic+multiblock_plots">multiblock_plots</a></code>, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(potato)
potList &lt;- as.list(potato[c(1,2,9)])
pot.mcoa   &lt;- mcoa(potList)
plot(scores(pot.mcoa), labels="names")

</code></pre>

<hr>
<h2 id='mcolors'>Colour palette generation from matrix of RGB values</h2><span id='topic+mcolors'></span>

<h3>Description</h3>

<p>Colour palette generation from matrix of RGB values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcolors(
  n,
  colmatrix = matrix(c(0, 0, 1, 1, 1, 1, 1, 0, 0), 3, 3, byrow = TRUE)
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcolors_+3A_n">n</code></td>
<td>
<p>Integer number of colorus to produce.</p>
</td></tr>
<tr><td><code id="mcolors_+3A_colmatrix">colmatrix</code></td>
<td>
<p>A numeric <code>matrix</code> of three columns (R,G,B) to generate colour palette from.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of n colours in hexadecimal RGB format.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mcolors(5)
</code></pre>

<hr>
<h2 id='mfa'>Multiple Factor Analysis - MFA</h2><span id='topic+mfa'></span>

<h3>Description</h3>

<p>This is a wrapper for the <code>FactoMineR::MFA</code> function for computing MFA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mfa(X, type = rep("c", length(X)), graph = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mfa_+3A_x">X</code></td>
<td>
<p><code>list</code> of input blocks.</p>
</td></tr>
<tr><td><code id="mfa_+3A_type">type</code></td>
<td>
<p><code>character</code> vector indicating block types, defaults to <code>rep("c", length(X))</code> for continuous values.</p>
</td></tr>
<tr><td><code id="mfa_+3A_graph">graph</code></td>
<td>
<p><code>logical</code> indicating if decomposition should be plotted.</p>
</td></tr>
<tr><td><code id="mfa_+3A_...">...</code></td>
<td>
<p>additional arguments for RGCCA approach.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>MFA is a methods typically used to compare several equally sized matrices. It is
often used in sensory analyses, where matrices consist of sensory characteristics and products,
and each assessor generates one matrix each. In its basic form, MFA scales all matrices by their
largest eigenvalue, concatenates them and performs PCA on the result. There are several
possibilities for plots and inspections of the model, handling of categorical and continuous
inputs etc. connected to MFA.
</p>


<h3>Value</h3>

<p><code>multiblock</code> object including relevant scores and loadings. Relevant plotting functions: <code><a href="#topic+multiblock_plots">multiblock_plots</a></code>
and result functions: <code><a href="#topic+multiblock_results">multiblock_results</a></code>.
</p>


<h3>References</h3>

<p>Pagès, J. (2005). Collection and analysis of perceived product inter-distances using multiple factor analysis: Application to the study of 10 white wines from the Loire valley. Food Quality and Preference, 16(7), 642–649.
</p>


<h3>See Also</h3>

<p>Overviews of available methods, <code><a href="#topic+multiblock">multiblock</a></code>, and methods organised by main structure: <code><a href="#topic+basic">basic</a></code>, <code><a href="#topic+unsupervised">unsupervised</a></code>, <code><a href="#topic+asca">asca</a></code>, <code><a href="#topic+supervised">supervised</a></code> and <code><a href="#topic+complex">complex</a></code>.
Common functions for computation and extraction of results and plotting are found in <code><a href="#topic+multiblock_results">multiblock_results</a></code> and <code><a href="#topic+multiblock_plots">multiblock_plots</a></code>, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(potato)
potList &lt;- as.list(potato[c(1,2,9)])
pot.mfa    &lt;- mfa(potList)
if(interactive()){
  plot(pot.mfa$MFA)
}

</code></pre>

<hr>
<h2 id='multiblock_plots'>Plot Functions for Multiblock Objects</h2><span id='topic+multiblock_plots'></span><span id='topic+scoreplot.multiblock'></span><span id='topic+loadingplot.multiblock'></span><span id='topic+loadingweightplot'></span><span id='topic+corrplot'></span><span id='topic+corrplot.multiblock'></span><span id='topic+corrplot.default'></span><span id='topic+corrplot.mvr'></span><span id='topic+biplot.multiblock'></span>

<h3>Description</h3>

<p>Plotting procedures for <code>multiblock</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multiblock'
scoreplot(
  object,
  comps = 1:2,
  block = 0,
  labels,
  identify = FALSE,
  type = "p",
  xlab,
  ylab,
  main,
  ...
)

## S3 method for class 'multiblock'
loadingplot(
  object,
  comps = 1:2,
  block = 0,
  scatter = TRUE,
  labels,
  identify = FALSE,
  type,
  lty,
  lwd = NULL,
  pch,
  cex = NULL,
  col,
  legendpos,
  xlab,
  ylab,
  main,
  pretty.xlabels = TRUE,
  xlim,
  ...
)

loadingweightplot(object, main = "Loading weights", ...)

## S3 method for class 'multiblock'
biplot(
  x,
  block = 0,
  comps = 1:2,
  which = c("x", "y", "scores", "loadings"),
  var.axes = FALSE,
  xlabs,
  ylabs,
  main,
  ...
)

corrplot(object, ...)

## Default S3 method:
corrplot(object, ...)

## S3 method for class 'mvr'
corrplot(object, ...)

## S3 method for class 'multiblock'
corrplot(
  object,
  comps = 1:2,
  labels = TRUE,
  col = 1:5,
  plotx = TRUE,
  ploty = TRUE,
  blockScores = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiblock_plots_+3A_object">object</code></td>
<td>
<p><code>multiblock</code> object.</p>
</td></tr>
<tr><td><code id="multiblock_plots_+3A_comps">comps</code></td>
<td>
<p><code>integer</code> vector giving components, within block, to plot.</p>
</td></tr>
<tr><td><code id="multiblock_plots_+3A_block">block</code></td>
<td>
<p><code>integer/character</code> for block selection.</p>
</td></tr>
<tr><td><code id="multiblock_plots_+3A_labels">labels</code></td>
<td>
<p><code>character</code> indicating if &quot;names&quot; or &quot;numbers&quot; should be plot symbols (optional).</p>
</td></tr>
<tr><td><code id="multiblock_plots_+3A_identify">identify</code></td>
<td>
<p><code>logical</code> for activating <code>identify</code> to interactively identify points.</p>
</td></tr>
<tr><td><code id="multiblock_plots_+3A_type">type</code></td>
<td>
<p><code>character</code> for selecting type of plot to make. Defaults to &quot;p&quot; (points) for scatter plots and &quot;l&quot; (lines) for line plots.</p>
</td></tr>
<tr><td><code id="multiblock_plots_+3A_xlab">xlab</code></td>
<td>
<p><code>character</code> text for x labels.</p>
</td></tr>
<tr><td><code id="multiblock_plots_+3A_ylab">ylab</code></td>
<td>
<p><code>character</code> text for y labels.</p>
</td></tr>
<tr><td><code id="multiblock_plots_+3A_main">main</code></td>
<td>
<p><code>character</code> text for main header.</p>
</td></tr>
<tr><td><code id="multiblock_plots_+3A_...">...</code></td>
<td>
<p>Not implemented.</p>
</td></tr>
<tr><td><code id="multiblock_plots_+3A_scatter">scatter</code></td>
<td>
<p><code>logical</code> indicating if a scatterplot of loadings should be made (default = TRUE).</p>
</td></tr>
<tr><td><code id="multiblock_plots_+3A_lty">lty</code></td>
<td>
<p>Vector of line type specifications (see <code><a href="graphics.html#topic+par">par</a></code> for details).</p>
</td></tr>
<tr><td><code id="multiblock_plots_+3A_lwd">lwd</code></td>
<td>
<p><code>numeric</code> vector of line width specifications.</p>
</td></tr>
<tr><td><code id="multiblock_plots_+3A_pch">pch</code></td>
<td>
<p>Vector of point specifications (see <code><a href="graphics.html#topic+points">points</a></code> for details).</p>
</td></tr>
<tr><td><code id="multiblock_plots_+3A_cex">cex</code></td>
<td>
<p><code>numeric</code> vector of plot size expansions (see <code><a href="graphics.html#topic+par">par</a></code> for details).</p>
</td></tr>
<tr><td><code id="multiblock_plots_+3A_col">col</code></td>
<td>
<p><code>integer</code> vector of symbol/line colours (see <code><a href="graphics.html#topic+par">par</a></code> for details).</p>
</td></tr>
<tr><td><code id="multiblock_plots_+3A_legendpos">legendpos</code></td>
<td>
<p><code>character</code> indicating legend position (if <code>scatter</code> is FALSE), e.g. <code>legendpos = "topright"</code>.</p>
</td></tr>
<tr><td><code id="multiblock_plots_+3A_pretty.xlabels">pretty.xlabels</code></td>
<td>
<p><code>logical</code> indicating if xlabels should be more nicely plotted (default = TRUE).</p>
</td></tr>
<tr><td><code id="multiblock_plots_+3A_xlim">xlim</code></td>
<td>
<p><code>numeric</code> vector of length two, with the x limits of the plot (optional).</p>
</td></tr>
<tr><td><code id="multiblock_plots_+3A_x">x</code></td>
<td>
<p><code>multiblock</code> object.</p>
</td></tr>
<tr><td><code id="multiblock_plots_+3A_which">which</code></td>
<td>
<p><code>character</code> for selecting type of biplot (&quot;x&quot; = default, &quot;y&quot;, &quot;scores&quot;, &quot;loadings&quot;).</p>
</td></tr>
<tr><td><code id="multiblock_plots_+3A_var.axes">var.axes</code></td>
<td>
<p><code>logical</code> indicating if second axes of a biplot should have arrows.</p>
</td></tr>
<tr><td><code id="multiblock_plots_+3A_xlabs">xlabs</code></td>
<td>
<p><code>character</code> vector for labelling first set of biplot points (optional).</p>
</td></tr>
<tr><td><code id="multiblock_plots_+3A_ylabs">ylabs</code></td>
<td>
<p><code>character</code> vector for labelling second set of biplot points (optional).</p>
</td></tr>
<tr><td><code id="multiblock_plots_+3A_plotx">plotx</code></td>
<td>
<p><code>locical</code> or <code>integer</code>/<code>character</code>.  Whether to plot the <code class="reqn">X</code> correlation loadings, optionally which block(s). Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="multiblock_plots_+3A_ploty">ploty</code></td>
<td>
<p><code>logical</code>.  Whether to plot the <code class="reqn">Y</code> correlation loadings. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="multiblock_plots_+3A_blockscores">blockScores</code></td>
<td>
<p><code>logical</code>. Correlation loadings from blockScores (default = FALSE).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Plot functions for <code>scores</code>, <code>loadings</code> and <code>loading.weights</code> based
on the functions found in the <code>pls</code> package.
</p>


<h3>Value</h3>

<p>These plotting routines only generate plots and return no values.
</p>


<h3>See Also</h3>

<p>Overviews of available methods, <code><a href="#topic+multiblock">multiblock</a></code>, and methods organised by main structure: <code><a href="#topic+basic">basic</a></code>, <code><a href="#topic+unsupervised">unsupervised</a></code>, <code><a href="#topic+asca">asca</a></code>, <code><a href="#topic+supervised">supervised</a></code> and <code><a href="#topic+complex">complex</a></code>.
Common functions for computation and extraction of results are found in <code><a href="#topic+multiblock_results">multiblock_results</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wine)
sc &lt;- sca(wine[c('Smell at rest', 'View', 'Smell after shaking')], ncomp = 4)
loadingplot(sc, block = 1, labels = "names", scatter = TRUE)
scoreplot(sc, labels = "names")
corrplot(sc)

data(potato)
so &lt;- sopls(Sensory ~ NIRraw + Chemical + Compression, data=potato, ncomp = c(2,2,2), 
            max_comps = 6, validation = "CV", segments = 10)
scoreplot(so, ncomp = c(2,1), block = 3, labels = "names")
corrplot(pcp(so, ncomp = c(2,2,2)))

</code></pre>

<hr>
<h2 id='multiblock_results'>Result Functions for Multiblock Objects</h2><span id='topic+multiblock_results'></span><span id='topic+scores.multiblock'></span><span id='topic+loadings.multiblock'></span><span id='topic+print.multiblock'></span><span id='topic+summary.multiblock'></span>

<h3>Description</h3>

<p>Standard result computation and extraction functions for <code>multiblock</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'multiblock'
scores(object, block = 0, ...)

## S3 method for class 'multiblock'
loadings(object, block = 0, ...)

## S3 method for class 'multiblock'
print(x, ...)

## S3 method for class 'multiblock'
summary(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="multiblock_results_+3A_object">object</code></td>
<td>
<p><code>multiblock</code> object.</p>
</td></tr>
<tr><td><code id="multiblock_results_+3A_block">block</code></td>
<td>
<p><code>integer/character</code> for block selection.</p>
</td></tr>
<tr><td><code id="multiblock_results_+3A_...">...</code></td>
<td>
<p>Not implemented.</p>
</td></tr>
<tr><td><code id="multiblock_results_+3A_x">x</code></td>
<td>
<p><code>multiblock</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Usage of the functions are shown using generics in the examples below.
Object printing and summary are available through:
<code>print.multiblock</code> and <code>summary.multiblock</code>.
Scores and loadings have their own extensions of <code>scores()</code> and <code>loadings()</code> throught
<code>scores.multiblock</code> and <code>loadings.multiblock</code>.
</p>


<h3>Value</h3>

<p>Scores or loadings are returned by <code>scores.multiblock</code> and <code>loadings.multiblock</code>, while print and summary methods invisibly returns the object.
</p>


<h3>See Also</h3>

<p>Overviews of available methods, <code><a href="#topic+multiblock">multiblock</a></code>, and methods organised by main structure: <code><a href="#topic+basic">basic</a></code>, <code><a href="#topic+unsupervised">unsupervised</a></code>, <code><a href="#topic+asca">asca</a></code>, <code><a href="#topic+supervised">supervised</a></code> and <code><a href="#topic+complex">complex</a></code>.
Common functions for plotting are found in <code><a href="#topic+multiblock_plots">multiblock_plots</a></code>, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(wine)
sc &lt;- sca(wine[c('Smell at rest', 'View', 'Smell after shaking')], ncomp = 4)
print(sc)
summary(sc)
head(loadings(sc, block = 1))
head(scores(sc))

</code></pre>

<hr>
<h2 id='pca'>Principal Component Analysis - PCA</h2><span id='topic+pca'></span>

<h3>Description</h3>

<p>This is a wrapper for the <code>pls::PCR</code> function for computing PCA.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pca(X, scale = FALSE, ncomp = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pca_+3A_x">X</code></td>
<td>
<p><code>matrix</code> of input data.</p>
</td></tr>
<tr><td><code id="pca_+3A_scale">scale</code></td>
<td>
<p><code>logical</code> indicating if variables should be standardised (default=FALSE).</p>
</td></tr>
<tr><td><code id="pca_+3A_ncomp">ncomp</code></td>
<td>
<p><code>integer</code> number of principal components to return.</p>
</td></tr>
<tr><td><code id="pca_+3A_...">...</code></td>
<td>
<p>additional arguments to <code>pls:pcr</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>PCA is a method for decomposing a matrix into subspace components with sample scores and
variable loadings. It can be formulated in various ways, but the standard formulation uses singular
value decomposition to create scores and loadings. PCA is guaranteed to be the optimal way of extracting
orthogonal subspaces from a matrix with regard to the amount of explained variance per component.
</p>


<h3>Value</h3>

<p><code>multiblock</code> object with scores, loadings, mean X values and explained variances. Relevant plotting functions: <code><a href="#topic+multiblock_plots">multiblock_plots</a></code>
and result functions: <code><a href="#topic+multiblock_results">multiblock_results</a></code>.
</p>


<h3>References</h3>

<p>Pearson, K. (1901) On lines and planes of closest fit to points in space. Philosophical Magazine, 2, 559–572.
</p>


<h3>See Also</h3>

<p>Overviews of available methods, <code><a href="#topic+multiblock">multiblock</a></code>, and methods organised by main structure: <code><a href="#topic+basic">basic</a></code>, <code><a href="#topic+unsupervised">unsupervised</a></code>, <code><a href="#topic+asca">asca</a></code>, <code><a href="#topic+supervised">supervised</a></code> and <code><a href="#topic+complex">complex</a></code>.
Common functions for computation and extraction of results and plotting are found in <code><a href="#topic+multiblock_results">multiblock_results</a></code> and <code><a href="#topic+multiblock_plots">multiblock_plots</a></code>, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(potato)
X &lt;- potato$Chemical

pca.pot  &lt;- pca(X, ncomp = 2)

</code></pre>

<hr>
<h2 id='pcagca'>PCA-GCA</h2><span id='topic+pcagca'></span>

<h3>Description</h3>

<p>PCA-GCA is a methods which aims at estimating subspaces of common, local and
distinct variation from two or more blocks.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pcagca(
  X,
  commons = 2,
  auto = TRUE,
  auto.par = list(explVarLim = 40, rLim = 0.8),
  manual.par = list(ncomp = 0, ncommon = 0),
  tol = 10^-12
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pcagca_+3A_x">X</code></td>
<td>
<p><code>list</code> of input blocks</p>
</td></tr>
<tr><td><code id="pcagca_+3A_commons">commons</code></td>
<td>
<p><code>numeric</code> giving the highest number of blocks to combine when calculating local or common scores.</p>
</td></tr>
<tr><td><code id="pcagca_+3A_auto">auto</code></td>
<td>
<p><code>logical</code> indicating if automatic choice of complexities should be used.</p>
</td></tr>
<tr><td><code id="pcagca_+3A_auto.par">auto.par</code></td>
<td>
<p><code>named list</code> setting limits for automatic choice of complexities.</p>
</td></tr>
<tr><td><code id="pcagca_+3A_manual.par">manual.par</code></td>
<td>
<p><code>named list</code> for manual choice of blocks. The list consists of <code>ncomp</code> which indicates the number of components to extract from each block and <code>ncommon</code> which is the corresponding for choosing the block combinations (local/common). For the latter, use unique_combos(n_blocks, commons) to see order of local/common blocks. Component numbers will be reduced if simpler models give better predictions. See example.</p>
</td></tr>
<tr><td><code id="pcagca_+3A_tol">tol</code></td>
<td>
<p><code>numeric</code> tolerance for component inclusion (singular values).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The name PCA-GCA comes from the process of first applying
PCA to each block, then using GCA to estimate local and common components, and finally
orthogonalising the block-wise scores on the local/common ones and re-estimating these to
obtain distinct components. The procedure is highly similar to the supervised method
PO-PLS, where the PCA steps are exchanged with PLS.
</p>


<h3>Value</h3>

<p><code>multiblock</code> object including relevant scores and loadings. Relevant plotting functions: <code><a href="#topic+multiblock_plots">multiblock_plots</a></code>
and result functions: <code><a href="#topic+multiblock_results">multiblock_results</a></code>. Distinct components are marked as 'D(x), Comp c' for block x and component c
while local and common components are marked as &quot;C(x1, x2), Comp c&quot;, where x1 and x2 (and more) are block numbers.
</p>


<h3>References</h3>

<p>Smilde, A., Måge, I., Naes, T., Hankemeier, T.,Lips, M., Kiers, H., Acar, E., and Bro, R.(2017). Common and distinct components in data fusion. Journal of Chemometrics, 31(7), e2900.
</p>


<h3>See Also</h3>

<p>Overviews of available methods, <code><a href="#topic+multiblock">multiblock</a></code>, and methods organised by main structure: <code><a href="#topic+basic">basic</a></code>, <code><a href="#topic+unsupervised">unsupervised</a></code>, <code><a href="#topic+asca">asca</a></code>, <code><a href="#topic+supervised">supervised</a></code> and <code><a href="#topic+complex">complex</a></code>.
Common functions for computation and extraction of results and plotting are found in <code><a href="#topic+multiblock_results">multiblock_results</a></code> and <code><a href="#topic+multiblock_plots">multiblock_plots</a></code>, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(potato)
potList &lt;- as.list(potato[c(1,2,9)])
pot.pcagca &lt;- pcagca(potList)

# Show origin and type of all components
lapply(pot.pcagca$blockScores,colnames)

# Basic multiblock plot
plot(scores(pot.pcagca, block=2), comps=1, labels="names")

</code></pre>

<hr>
<h2 id='popls'>Parallel and Orthogonalised Partial Least Squares - PO-PLS</h2><span id='topic+popls'></span>

<h3>Description</h3>

<p>This is a basic implementation of PO-PLS with manual and automatic component selections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>popls(
  X,
  Y,
  commons = 2,
  auto = TRUE,
  auto.par = list(explVarLim = 40, rLim = 0.8),
  manual.par = list(ncomp = rep(0, length(X)), ncommon = list())
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="popls_+3A_x">X</code></td>
<td>
<p><code>list</code> of input blocks</p>
</td></tr>
<tr><td><code id="popls_+3A_y">Y</code></td>
<td>
<p><code>matrix</code> of response variable(s)</p>
</td></tr>
<tr><td><code id="popls_+3A_commons">commons</code></td>
<td>
<p><code>numeric</code> giving the highest number of blocks to combine when calculating local or common scores.</p>
</td></tr>
<tr><td><code id="popls_+3A_auto">auto</code></td>
<td>
<p><code>logical</code> indicating if automatic choice of complexities should be used.</p>
</td></tr>
<tr><td><code id="popls_+3A_auto.par">auto.par</code></td>
<td>
<p><code>named list</code> setting limits for automatic choice of complexities. See Details.</p>
</td></tr>
<tr><td><code id="popls_+3A_manual.par">manual.par</code></td>
<td>
<p><code>named list</code> for manual choice of blocks. The list consists of <code>ncomp</code> which indicates the number of components to extract from each block and <code>ncommon</code> which is the corresponding for choosing the block combinations (local/common). For the latter, use unique_combos(n_blocks, commons) to see order of local/common blocks. Component numbers will be reduced if simpler models give better predictions. See example.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>PO-PLS decomposes a set of input data blocks into common, local and distinct components
through a process involving <code><a href="pls.html#topic+pls">pls</a></code> and <code><a href="#topic+gca">gca</a></code>. The <code>rLim</code> parameter is
a lower bound for the GCA correlation when building common components, while explVarLim is the minimum
explained variance for common components and unique components.
</p>


<h3>Value</h3>

<p>A <code>multiblock</code> object with block-wise, local and common loadings and scores. Relevant plotting functions: <code><a href="#topic+multiblock_plots">multiblock_plots</a></code>
and result functions: <code><a href="#topic+multiblock_results">multiblock_results</a></code>.
</p>


<h3>References</h3>


<ul>
<li><p> I Måge, BH Mevik, T Næs. (2008). Regression models with process variables and parallel blocks of raw material measurements. Journal of Chemometrics: A Journal of the Chemometrics Society 22 (8), 443-456
</p>
</li>
<li><p> I Måge, E Menichelli, T Næs (2012). Preference mapping by PO-PLS: Separating common and unique information in several data blocks. Food quality and preference 24 (1), 8-16
</p>
</li></ul>



<h3>See Also</h3>

<p>Overviews of available methods, <code><a href="#topic+multiblock">multiblock</a></code>, and methods organised by main structure: <code><a href="#topic+basic">basic</a></code>, <code><a href="#topic+unsupervised">unsupervised</a></code>, <code><a href="#topic+asca">asca</a></code>, <code><a href="#topic+supervised">supervised</a></code> and <code><a href="#topic+complex">complex</a></code>.
Common functions for computation and extraction of results and plotting are found in <code><a href="#topic+multiblock_results">multiblock_results</a></code> and <code><a href="#topic+multiblock_plots">multiblock_plots</a></code>, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(potato)

# Automatic analysis
pot.po.auto &lt;- popls(potato[1:3], potato[['Sensory']][,1])
pot.po.auto$explVar

# Manual choice of up to 5 components for each block and 1, 0, and 2 blocks,
# respectively from the (1,2), (1,3) and (2,3) combinations of blocks.
pot.po.man &lt;- popls(potato[1:3], potato[['Sensory']][,1], auto=FALSE, 
                manual.par = list(ncomp=c(5,5,5), ncommon=c(1,0,2)))
pot.po.man$explVar

# Score plot for local (2,3) components
plot(scores(pot.po.man,3), comps=1:2, labels="names")

</code></pre>

<hr>
<h2 id='potato'>Sensory, rheological, chemical and spectroscopic analysis of potatoes.</h2><span id='topic+potato'></span>

<h3>Description</h3>

<p>A dataset containing 9 blocks of measurements on 26 potatoes.
Original dataset can be found at http://models.life.ku.dk/Texture_Potatoes.
This version has been pre-processed as follows (corresponding to Liland et al. 2016):
</p>

<ul>
<li><p> Variables containing NaN have been removed.
</p>
</li>
<li><p> Chemical and Compression blocks have been scaled by standard deviations.
</p>
</li>
<li><p> NIR blocks have been subjected to SNV (Standard Normal Variate).
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(potato)
</code></pre>


<h3>Format</h3>

<p>A data.frame having 26 rows and 9 variables:
</p>

<dl>
<dt>Chemical</dt><dd><p>Matrix of chemical measurements</p>
</dd>
<dt>Compression</dt><dd><p>Matrix of rheological compression data</p>
</dd>
<dt>NIRraw</dt><dd><p>Matrix of near-infrared measurements of raw potatoes</p>
</dd>
<dt>NIRcooked</dt><dd><p>Matrix of near-infrared measurements of cooked potatoes</p>
</dd>
<dt>CPMGraw</dt><dd><p>Matrix of NMR (CPMG) measurements of raw potatoes</p>
</dd>
<dt>CPMGcooked</dt><dd><p>Matrix of NMR (CPMG) measurements of cooked potatoes</p>
</dd>
<dt>FIDraw</dt><dd><p>Matrix of NMR (FID) measurements of raw potatoes</p>
</dd>
<dt>FIDcooked</dt><dd><p>Matrix of NMR (FID) measurements of cooked potatoes</p>
</dd>
<dt>Sensory</dt><dd><p>Matrix of sensory assessments</p>
</dd>
</dl>



<h3>References</h3>


<ul>
<li><p> L.G.Thygesen, A.K.Thybo, S.B.Engelsen, Prediction of Sensory Texture Quality of Boiled Potatoes
From Low-field1H NMR of Raw Potatoes. The Role of Chemical Constituents. LWT - Food Science and Technology 34(7), 2001, pp 469-477.
</p>
</li>
<li><p> Kristian Hovde Liland, Tormod Næs, Ulf Geir Indahl, ROSA – a fast extension of Partial Least Squares Regression for Multiblock Data Analysis,
Journal of Chemometrics 30:11 (2016), pp. 651-662.
</p>
</li></ul>


<hr>
<h2 id='preprocess'>Preprocessing of block data</h2><span id='topic+preprocess'></span><span id='topic+block.preprocess'></span>

<h3>Description</h3>

<p>This is an interface to simplify preprocessing of one, a subset or all
blocks in a multiblock object, e.g., a <code>data.frame</code> (see <code>block.data.frame</code>)
or <code>list</code>. Several standard preprocessing methods are supplied in addition to
letting the user supply it's own function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>block.preprocess(
  X,
  block = 1:length(X),
  fun = c("autoscale", "center", "scale", "SNV", "EMSC", "Fro", "FroSq", "SingVal"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="preprocess_+3A_x">X</code></td>
<td>
<p><code>data.frame</code> or <code>list</code> of data.</p>
</td></tr>
<tr><td><code id="preprocess_+3A_block">block</code></td>
<td>
<p><code>vector</code> of block(s) to preprocess (<code>integer</code>s or <code>character</code>s).</p>
</td></tr>
<tr><td><code id="preprocess_+3A_fun">fun</code></td>
<td>
<p><code>character</code> or <code>function</code> selecting which preprocessing to apply (see Details).</p>
</td></tr>
<tr><td><code id="preprocess_+3A_...">...</code></td>
<td>
<p>additional arguments to underlying functions.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <code>fun</code> parameter controls the type of preprocessing to be performed:
</p>

<ul>
<li><p> autoscale: centre and scale each feature/variable.
</p>
</li>
<li><p> center: centre each feature/variable.
</p>
</li>
<li><p> scale: scale each feature/variable.
</p>
</li>
<li><p> SNV: Standard Normal Variate correction, i.e., centre and scale each sample across features/variables.
</p>
</li>
<li><p> EMSC: Extended Multiplicative Signal Correction defaulting to basic EMSC (2nd order polynomials). Further parameters are sent to <code>EMSC::EMSC</code>.
</p>
</li>
<li><p> Fro: Frobenius norm scaling of whole block.
</p>
</li>
<li><p> FroSq: Squared Frobenius norm scaling of whole block (sum of squared values).
</p>
</li>
<li><p> SingVal: Singular value scaling of whole block (first singular value).
</p>
</li>
<li><p> User defined: If a function is supplied, this will be applied to chosen blocks.
Preprocessing can be done for all blocks or a subset. It can also be done in a series of operations to combine preprocessing techniques.
</p>
</li></ul>



<h3>Value</h3>

<p>The input multiblock object is preprocessed and returned.
</p>


<h3>See Also</h3>

<p>Overviews of available methods, <code><a href="#topic+multiblock">multiblock</a></code>, and methods organised by main structure: <code><a href="#topic+basic">basic</a></code>, <code><a href="#topic+unsupervised">unsupervised</a></code>, <code><a href="#topic+asca">asca</a></code>, <code><a href="#topic+supervised">supervised</a></code> and <code><a href="#topic+complex">complex</a></code>.
Common functions for computation and extraction of results and plotting are found in <code><a href="#topic+multiblock_results">multiblock_results</a></code> and <code><a href="#topic+multiblock_plots">multiblock_plots</a></code>, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(potato)
# Autoscale Chemical block
potato &lt;- block.preprocess(potato, block = "Chemical", "autoscale")
# Apply SNV to NIR blocks
potato &lt;- block.preprocess(potato, block = 3:4, "SNV")
# Centre Sensory block
potato &lt;- block.preprocess(potato, block = "Sensory", "center")
# Scale all blocks to unit Frobenius norm
potato &lt;- block.preprocess(potato, fun = "Fro")

# Effect of SNV
NIR &lt;- (potato$NIRraw + rnorm(26)) * rnorm(26,1,0.2)
NIRc &lt;- block.preprocess(list(NIR), fun = "SNV")[[1]]
old.par &lt;- par(mfrow = c(2,1), mar = c(4,4,1,1))
matplot(t(NIR), type="l", main = "uncorrected", ylab = "")
matplot(t(NIRc), type="l", main = "corrected", ylab = "")
par(old.par)

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+pcr'></span><span id='topic+plsr'></span><span id='topic+MSEP'></span><span id='topic+R2'></span><span id='topic+RMSEP'></span><span id='topic+coefplot'></span><span id='topic+cvsegments'></span><span id='topic+loading.weights'></span><span id='topic+loadingplot'></span><span id='topic+loadings'></span><span id='topic+mvrValstats'></span><span id='topic+predplot'></span><span id='topic+scoreplot'></span><span id='topic+scores'></span><span id='topic+validationplot'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>pls</dt><dd><p><code><a href="pls.html#topic+mvrVal">MSEP</a></code>, <code><a href="pls.html#topic+mvrVal">R2</a></code>, <code><a href="pls.html#topic+mvrVal">RMSEP</a></code>, <code><a href="pls.html#topic+coefplot">coefplot</a></code>, <code><a href="pls.html#topic+cvsegments">cvsegments</a></code>, <code><a href="pls.html#topic+scores">loading.weights</a></code>, <code><a href="pls.html#topic+scoreplot">loadingplot</a></code>, <code><a href="pls.html#topic+scores">loadings</a></code>, <code><a href="pls.html#topic+mvrVal">mvrValstats</a></code>, <code><a href="pls.html#topic+mvr">pcr</a></code>, <code><a href="pls.html#topic+mvr">plsr</a></code>, <code><a href="pls.html#topic+predplot">predplot</a></code>, <code><a href="pls.html#topic+scoreplot">scoreplot</a></code>, <code><a href="pls.html#topic+scores">scores</a></code>, <code><a href="pls.html#topic+validationplot">validationplot</a></code></p>
</dd>
</dl>

<hr>
<h2 id='rosa'>Response Oriented Sequential Alternation - ROSA</h2><span id='topic+rosa'></span>

<h3>Description</h3>

<p>Formula based interface to the ROSA algorithm following the style of the <code>pls</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rosa(
  formula,
  ncomp,
  Y.add,
  common.comp = 1,
  data,
  subset,
  na.action,
  scale = FALSE,
  weights = NULL,
  validation = c("none", "CV", "LOO"),
  internal.validation = FALSE,
  fixed.block = NULL,
  design.block = NULL,
  canonical = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rosa_+3A_formula">formula</code></td>
<td>
<p>Model formula accepting a single response (block) and predictor block names separated by + signs.</p>
</td></tr>
<tr><td><code id="rosa_+3A_ncomp">ncomp</code></td>
<td>
<p>The maximum number of ROSA components.</p>
</td></tr>
<tr><td><code id="rosa_+3A_y.add">Y.add</code></td>
<td>
<p>Optional response(s) available in the data set.</p>
</td></tr>
<tr><td><code id="rosa_+3A_common.comp">common.comp</code></td>
<td>
<p>Automatically create all combinations of common components up to length <code>common.comp</code> (default = 1).</p>
</td></tr>
<tr><td><code id="rosa_+3A_data">data</code></td>
<td>
<p>The data set to analyse.</p>
</td></tr>
<tr><td><code id="rosa_+3A_subset">subset</code></td>
<td>
<p>Expression for subsetting the data before modelling.</p>
</td></tr>
<tr><td><code id="rosa_+3A_na.action">na.action</code></td>
<td>
<p>How to handle NAs (no action implemented).</p>
</td></tr>
<tr><td><code id="rosa_+3A_scale">scale</code></td>
<td>
<p>Optionally scale predictor variables by their individual standard deviations.</p>
</td></tr>
<tr><td><code id="rosa_+3A_weights">weights</code></td>
<td>
<p>Optional object weights.</p>
</td></tr>
<tr><td><code id="rosa_+3A_validation">validation</code></td>
<td>
<p>Optional cross-validation strategy &quot;CV&quot; or &quot;LOO&quot;.</p>
</td></tr>
<tr><td><code id="rosa_+3A_internal.validation">internal.validation</code></td>
<td>
<p>Optional cross-validation for block selection process, &quot;LOO&quot;, &quot;CV3&quot;, &quot;CV5&quot;, &quot;CV10&quot; (CV-number of segments), or vector of integers (default = FALSE).</p>
</td></tr>
<tr><td><code id="rosa_+3A_fixed.block">fixed.block</code></td>
<td>
<p>integer vector with block numbers for each component (0 = not fixed) or list of length &lt;= ncomp (element length 0 = not fixed).</p>
</td></tr>
<tr><td><code id="rosa_+3A_design.block">design.block</code></td>
<td>
<p>integer vector containing block numbers of design blocks</p>
</td></tr>
<tr><td><code id="rosa_+3A_canonical">canonical</code></td>
<td>
<p>logical indicating if canonical correlation should be use when calculating loading weights (default), enabling B/W maximization, common components, etc. Alternatively (FALSE) a PLS2 strategy, e.g. for spectra response, is used.</p>
</td></tr>
<tr><td><code id="rosa_+3A_...">...</code></td>
<td>
<p>Additional arguments for <code>cvseg</code> or <code>rosa.fit</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>ROSA is an opportunistic method sequentially selecting components from whichever block explains
the response most effectively. It can be formulated as a PLS model on concatenated input block with block
selection per component. This implementation adds several options that are not described in the literature.
Most importantly, it opens for internal validation in the block selection process, making this more
robust. In addition it handles design blocks explicitly, enables classification and secondary responses (CPLS),
and definition of common components.
</p>


<h3>Value</h3>

<p>An object of classes <code>rosa</code> and <code>mvr</code> having several associated printing (<code><a href="#topic+rosa_results">rosa_results</a></code>) and plotting methods (<code><a href="#topic+rosa_plots">rosa_plots</a></code>).
</p>


<h3>References</h3>

<p>Liland, K.H., Næs, T., and Indahl, U.G. (2016). ROSA - a fast extension of partial least squares regression for multiblock data analysis. Journal of Chemometrics, 30, 651–662, doi:10.1002/cem.2824.
</p>


<h3>See Also</h3>

<p>Overviews of available methods, <code><a href="#topic+multiblock">multiblock</a></code>, and methods organised by main structure: <code><a href="#topic+basic">basic</a></code>, <code><a href="#topic+unsupervised">unsupervised</a></code>, <code><a href="#topic+asca">asca</a></code>, <code><a href="#topic+supervised">supervised</a></code> and <code><a href="#topic+complex">complex</a></code>.
Common functions for computation and extraction of results and plotting are found in <code><a href="#topic+rosa_results">rosa_results</a></code> and <code><a href="#topic+rosa_plots">rosa_plots</a></code>, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(potato)
mod &lt;- rosa(Sensory[,1] ~ ., data = potato, ncomp = 10, validation = "CV", segments = 5)
summary(mod)

# For examples of ROSA results and plotting see 
# ?rosa_results and ?rosa_plots.
</code></pre>

<hr>
<h2 id='rosa_plots'>Plotting functions for ROSA models</h2><span id='topic+rosa_plots'></span><span id='topic+image.rosa'></span><span id='topic+barplot.rosa'></span>

<h3>Description</h3>

<p>Various plotting procedures for <code><a href="#topic+rosa">rosa</a></code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rosa'
image(
  x,
  type = c("correlation", "residual", "order"),
  ncomp = x$ncomp,
  col = mcolors(128),
  legend = TRUE,
  mar = c(5, 6, 4, 7),
  las = 1,
  ...
)

## S3 method for class 'rosa'
barplot(
  height,
  type = c("train", "CV"),
  ncomp = height$ncomp,
  col = mcolors(ncomp),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rosa_plots_+3A_x">x</code></td>
<td>
<p>A <code>rosa</code> object</p>
</td></tr>
<tr><td><code id="rosa_plots_+3A_type">type</code></td>
<td>
<p>An optional <code>character</code> for selecting the plot type. For <code>image.rosa</code> the options are: &quot;correlation&quot; (default), &quot;residual&quot; or &quot;order&quot;. For <code>barplot.rosa</code> the options indicate: explained variance should be based on training data (&quot;train&quot;) or cross-validation (&quot;CV&quot;).</p>
</td></tr>
<tr><td><code id="rosa_plots_+3A_ncomp">ncomp</code></td>
<td>
<p>Integer to control the number of components to plot (if fewer than the fitted number of components).</p>
</td></tr>
<tr><td><code id="rosa_plots_+3A_col">col</code></td>
<td>
<p>Colours used for the image and bar plot, defaulting to mcolors(128).</p>
</td></tr>
<tr><td><code id="rosa_plots_+3A_legend">legend</code></td>
<td>
<p>Logical indicating if a legend should be included (default = TRUE) for <code>image.rosa</code>.</p>
</td></tr>
<tr><td><code id="rosa_plots_+3A_mar">mar</code></td>
<td>
<p>Figure margins, default = c(5,6,4,7) for <code>image.rosa</code>.</p>
</td></tr>
<tr><td><code id="rosa_plots_+3A_las">las</code></td>
<td>
<p>Axis text direction, default = 1 for <code>image.rosa</code>.</p>
</td></tr>
<tr><td><code id="rosa_plots_+3A_...">...</code></td>
<td>
<p>Additional parameters passed to <code>loadingplot</code>, <code>image</code>, <code>axis</code>, <code>color.legend</code>, or <code>barplot</code>.</p>
</td></tr>
<tr><td><code id="rosa_plots_+3A_height">height</code></td>
<td>
<p>A <code>rosa</code> object.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Usage of the functions are shown using generics in the examples below. <code>image.rosa</code>
makes an image plot of each candidate score's correlation to the winner or the block-wise
response residual. These plots can be used to find alternative block selection for tweaking
the ROSA model. <code>barplot.rosa</code> makes barplot of block and component explained variances.
<code>loadingweightsplot</code> is an adaptation of <code>pls::loadingplot</code> to plot loading weights.
</p>


<h3>Value</h3>

<p>No return.
</p>


<h3>References</h3>

<p>Liland, K.H., Næs, T., and Indahl, U.G. (2016). ROSA - a fast extension of partial least squares regression for multiblock data analysis. Journal of Chemometrics, 30, 651–662, doi:10.1002/cem.2824.
</p>


<h3>See Also</h3>

<p>Overviews of available methods, <code><a href="#topic+multiblock">multiblock</a></code>, and methods organised by main structure: <code><a href="#topic+basic">basic</a></code>, <code><a href="#topic+unsupervised">unsupervised</a></code>, <code><a href="#topic+asca">asca</a></code>, <code><a href="#topic+supervised">supervised</a></code> and <code><a href="#topic+complex">complex</a></code>.
Common functions for computation and extraction of results in <code><a href="#topic+rosa_results">rosa_results</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(potato)
mod &lt;- rosa(Sensory[,1] ~ ., data = potato, ncomp = 5)
image(mod)
barplot(mod)
loadingweightplot(mod)

</code></pre>

<hr>
<h2 id='rosa_results'>Result functions for ROSA models</h2><span id='topic+rosa_results'></span><span id='topic+predict.rosa'></span><span id='topic+rosa.classify'></span><span id='topic+coef.rosa'></span><span id='topic+print.rosa'></span><span id='topic+summary.rosa'></span><span id='topic+blockexpl'></span><span id='topic+print.rosaexpl'></span><span id='topic+scores.rosa'></span><span id='topic+loadings.rosa'></span>

<h3>Description</h3>

<p>Standard result computation and extraction functions for ROSA (<code><a href="#topic+rosa">rosa</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'rosa'
predict(
  object,
  newdata,
  ncomp = 1:object$ncomp,
  comps,
  type = c("response", "scores"),
  na.action = na.pass,
  ...
)

## S3 method for class 'rosa'
coef(object, ncomp = object$ncomp, comps, intercept = FALSE, ...)

## S3 method for class 'rosa'
print(x, ...)

## S3 method for class 'rosa'
summary(
  object,
  what = c("all", "validation", "training"),
  digits = 4,
  print.gap = 2,
  ...
)

blockexpl(object, ncomp = object$ncomp, type = c("train", "CV"))

## S3 method for class 'rosaexpl'
print(x, digits = 3, compwise = FALSE, ...)

rosa.classify(object, classes, newdata, ncomp, LQ)

## S3 method for class 'rosa'
scores(object, ...)

## S3 method for class 'rosa'
loadings(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rosa_results_+3A_object">object</code></td>
<td>
<p>A <code>rosa</code> object.</p>
</td></tr>
<tr><td><code id="rosa_results_+3A_newdata">newdata</code></td>
<td>
<p>Optional new data with the same types of predictor blocks as the ones used for fitting the object.</p>
</td></tr>
<tr><td><code id="rosa_results_+3A_ncomp">ncomp</code></td>
<td>
<p>An <code>integer</code> giving the number of components to apply (cummulative).</p>
</td></tr>
<tr><td><code id="rosa_results_+3A_comps">comps</code></td>
<td>
<p>An <code>integer</code> vector giving the exact components to apply (subset).</p>
</td></tr>
<tr><td><code id="rosa_results_+3A_type">type</code></td>
<td>
<p>For <code>blockexpl</code>: Character indicating which type of explained variance to compute (default = &quot;train&quot;, alternative = &quot;CV&quot;).</p>
</td></tr>
<tr><td><code id="rosa_results_+3A_na.action">na.action</code></td>
<td>
<p>Function determining what to do with missing values in <code>newdata</code>.</p>
</td></tr>
<tr><td><code id="rosa_results_+3A_...">...</code></td>
<td>
<p>Additional arguments. Currently not implemented.</p>
</td></tr>
<tr><td><code id="rosa_results_+3A_intercept">intercept</code></td>
<td>
<p>A <code>logical</code> indicating if coefficients for the intercept should be included (default = FALSE).</p>
</td></tr>
<tr><td><code id="rosa_results_+3A_x">x</code></td>
<td>
<p>A <code>rosa</code> object.</p>
</td></tr>
<tr><td><code id="rosa_results_+3A_what">what</code></td>
<td>
<p>A <code>character</code> indicating if summary should include all, validation or training.</p>
</td></tr>
<tr><td><code id="rosa_results_+3A_digits">digits</code></td>
<td>
<p>The number of digits used for printing.</p>
</td></tr>
<tr><td><code id="rosa_results_+3A_print.gap">print.gap</code></td>
<td>
<p>Gap between columns when printing.</p>
</td></tr>
<tr><td><code id="rosa_results_+3A_compwise">compwise</code></td>
<td>
<p>Logical indicating if block-wise (default/FALSE) or component-wise (TRUE) explained variance should be printed.</p>
</td></tr>
<tr><td><code id="rosa_results_+3A_classes">classes</code></td>
<td>
<p>A <code>character</code> vector of class labels.</p>
</td></tr>
<tr><td><code id="rosa_results_+3A_lq">LQ</code></td>
<td>
<p>A <code>character</code> indicating if 'max' (maximum score value), 'lda' or 'qda' should be used when classifying.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Usage of the functions are shown using generics in the examples below.
Prediction, regression coefficients, object printing and summary are available through:
<code>predict.rosa</code>,  <code>coef.rosa</code>, <code>print.rosa</code> and <code>summary.rosa</code>.
Explained variances are available (block-wise and global) through <code>blockexpl</code> and <code>print.rosaexpl</code>.
Scores and loadings have their own extensions of <code>scores()</code> and <code>loadings()</code> throught
<code>scores.rosa</code> and <code>loadings.rosa</code>. Finally, there is work in progress on classifcation
support through <code>rosa.classify</code>.
</p>
<p>When <code>type</code> is <code>"response"</code> (default), predicted response values
are returned.  If <code>comps</code> is missing (or is <code>NULL</code>), predictions
for <code>length(ncomp)</code> models with <code>ncomp[1]</code> components,
<code>ncomp[2]</code> components, etc., are returned.  Otherwise, predictions for
a single model with the exact components in <code>comps</code> are returned.
(Note that in both cases, the intercept is always included in the
predictions.  It can be removed by subtracting the <code>Ymeans</code> component
of the fitted model.)
</p>
<p>If <code>comps</code> is missing (or is <code>NULL</code>), <code>coef()[,,ncomp[i]]</code>
are the coefficients for models with <code>ncomp[i]</code> components, for <code class="reqn">i
= 1, \ldots, length(ncomp)</code>.  Also, if <code>intercept = TRUE</code>, the first
dimension is <code class="reqn">nxvar + 1</code>, with the intercept coefficients as the first
row.
</p>
<p>If <code>comps</code> is given, however, <code>coef()[,,comps[i]]</code> are the
coefficients for a model with only the component <code>comps[i]</code>, i.e., the
contribution of the component <code>comps[i]</code> on the regression
coefficients.
</p>


<h3>Value</h3>

<p>Returns depend on method used, e.g. <code>predict.rosa</code> returns predicted responses
or scores depending on inputs, <code>coef.rosa</code> returns regression coefficients, <code>blockexpl</code>
returns an object of class <code>rosaexpl</code> containing block-wise and component-wise explained variance contained in a matrix with attributes.
</p>


<h3>References</h3>

<p>Liland, K.H., Næs, T., and Indahl, U.G. (2016). ROSA - a fast extension of partial least squares regression for multiblock data analysis. Journal of Chemometrics, 30, 651–662, doi:10.1002/cem.2824.
</p>


<h3>See Also</h3>

<p>Overviews of available methods, <code><a href="#topic+multiblock">multiblock</a></code>, and methods organised by main structure: <code><a href="#topic+basic">basic</a></code>, <code><a href="#topic+unsupervised">unsupervised</a></code>, <code><a href="#topic+asca">asca</a></code>, <code><a href="#topic+supervised">supervised</a></code> and <code><a href="#topic+complex">complex</a></code>.
Common functions for computation and extraction of results and plotting are found in <code><a href="#topic+rosa_results">rosa_results</a></code> and <code><a href="#topic+rosa_plots">rosa_plots</a></code>, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(potato)
mod &lt;- rosa(Sensory[,1] ~ ., data = potato, ncomp = 5, subset = 1:20)
testset &lt;- potato[-(1:20),]; testset$Sensory &lt;- testset$Sensory[,1,drop=FALSE]
predict(mod, testset, ncomp=5)
dim(coef(mod, ncomp=5)) # &lt;variables x responses x components&gt;
print(mod)
summary(mod)
blockexpl(mod)
print(blockexpl(mod), compwise=TRUE)

</code></pre>

<hr>
<h2 id='sca'>Simultaneous Component Analysis - SCA</h2><span id='topic+sca'></span>

<h3>Description</h3>

<p>This is a basic implementation of the SCA-P algorithm (least restricted SCA) with support for both
sample- and variable-linked modes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sca(X, ncomp = 2, scale = FALSE, samplelinked = "auto", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sca_+3A_x">X</code></td>
<td>
<p><code>list</code> of input blocks.</p>
</td></tr>
<tr><td><code id="sca_+3A_ncomp">ncomp</code></td>
<td>
<p><code>integer</code> number of components to extract.</p>
</td></tr>
<tr><td><code id="sca_+3A_scale">scale</code></td>
<td>
<p><code>logical</code> indicating autoscaling of features (default = FALSE).</p>
</td></tr>
<tr><td><code id="sca_+3A_samplelinked">samplelinked</code></td>
<td>
<p><code>character/logical</code> indicating if blocks are linked by samples (TRUE) or variables (FALSE). Using 'auto' (default), this will be determined automatically.</p>
</td></tr>
<tr><td><code id="sca_+3A_...">...</code></td>
<td>
<p>additional arguments (not used).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>SCA, in its original variable-linked version, calculates common loadings and block-wise
scores. There are many possible constraints and specialisations. This implementations uses
PCA as the backbone, thus resulting in deterministic, ordered components. A parameter controls
the linking mode, but if left untouched an attempt is made at automatically determining
variable or sample linking.
</p>


<h3>Value</h3>

<p><code>multiblock</code> object including relevant scores and loadings. Relevant plotting functions: <code><a href="#topic+multiblock_plots">multiblock_plots</a></code>
and result functions: <code><a href="#topic+multiblock_results">multiblock_results</a></code>.
</p>


<h3>References</h3>

<p>Levin, J. (1966) Simultaneous factor analysis of several gramian matrices. Psychometrika, 31(3), 413–419.
</p>


<h3>See Also</h3>

<p>Overviews of available methods, <code><a href="#topic+multiblock">multiblock</a></code>, and methods organised by main structure: <code><a href="#topic+basic">basic</a></code>, <code><a href="#topic+unsupervised">unsupervised</a></code>, <code><a href="#topic+asca">asca</a></code>, <code><a href="#topic+supervised">supervised</a></code> and <code><a href="#topic+complex">complex</a></code>.
Common functions for computation and extraction of results and plotting are found in <code><a href="#topic+multiblock_results">multiblock_results</a></code> and <code><a href="#topic+multiblock_plots">multiblock_plots</a></code>, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Object linked data
data(potato)
potList &lt;- as.list(potato[c(1,2,9)])
pot.sca    &lt;- sca(potList)
plot(scores(pot.sca), labels="names")

# Variable linked data
data(candies)
candyList &lt;- lapply(1:nlevels(candies$candy),function(x)candies$assessment[candies$candy==x,])
pot.sca    &lt;- sca(candyList, samplelinked = FALSE)
pot.sca

</code></pre>

<hr>
<h2 id='simulated'>Data simulated to have certain characteristics.</h2><span id='topic+simulated'></span>

<h3>Description</h3>

<p>A dataset containing simulated data for 4 connected events where A is the
starting point and D is the end point. This can be described as a directed
acyclic graph (sketched below, moving left-&gt;right). <br />
</p>
<p><img src="../help/figures/simulated.png" alt="Path-diagram for simulated data" />
</p>
<p>Subpaths include: ABD, AD, ABCD, ACD
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(simulated)
</code></pre>


<h3>Format</h3>

<p>A list of matrices having 200 rows and 10 variables:
</p>

<dl>
<dt>A</dt><dd><p>Simulated matrix A</p>
</dd>
<dt>B</dt><dd><p>Simulated matrix B</p>
</dd>
</dl>
<p>...

</p>


<h3>References</h3>

<p>Tormod Næs, Rosaria Romano, Oliver Tomic, Ingrid Måge, Age Smilde, Kristian Hovde Liland,
Sequential and orthogonalized PLS (SO-PLS) regression for path analysis: Order of blocks and relations between effects.
Journal of Chemometrics, In Press
</p>

<hr>
<h2 id='smbpls'>Sparse Multiblock Partial Least Squares - sMB-PLS</h2><span id='topic+smbpls'></span>

<h3>Description</h3>

<p>sMB-PLS is an adaptation of MB-PLS (<code><a href="#topic+mbpls">mbpls</a></code>) that enforces sparseness in loading weights
when computing PLS components in the global model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>smbpls(
  formula,
  data,
  subset,
  na.action,
  X = NULL,
  Y = NULL,
  ncomp = 1,
  scale = FALSE,
  shrink = NULL,
  truncation = NULL,
  trunc.width = 0.95,
  blockScale = c("sqrtnvar", "ssq", "none"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="smbpls_+3A_formula">formula</code></td>
<td>
<p>Model formula accepting a single response (block) and predictor block names separated by + signs.</p>
</td></tr>
<tr><td><code id="smbpls_+3A_data">data</code></td>
<td>
<p>The data set to analyse.</p>
</td></tr>
<tr><td><code id="smbpls_+3A_subset">subset</code></td>
<td>
<p>Expression for subsetting the data before modelling.</p>
</td></tr>
<tr><td><code id="smbpls_+3A_na.action">na.action</code></td>
<td>
<p>How to handle NAs (no action implemented).</p>
</td></tr>
<tr><td><code id="smbpls_+3A_x">X</code></td>
<td>
<p><code>list</code> of input blocks. If X is supplied, the formula interface is skipped.</p>
</td></tr>
<tr><td><code id="smbpls_+3A_y">Y</code></td>
<td>
<p><code>matrix</code> of responses.</p>
</td></tr>
<tr><td><code id="smbpls_+3A_ncomp">ncomp</code></td>
<td>
<p><code>integer</code> number of PLS components.</p>
</td></tr>
<tr><td><code id="smbpls_+3A_scale">scale</code></td>
<td>
<p><code>logical</code> for autoscaling inputs (default = FALSE).</p>
</td></tr>
<tr><td><code id="smbpls_+3A_shrink">shrink</code></td>
<td>
<p><code>numeric</code> scalar indicating degree of L1-shrinkage/Soft-Thresholding (optional), 0 &lt;= shrink &lt; 1.</p>
</td></tr>
<tr><td><code id="smbpls_+3A_truncation">truncation</code></td>
<td>
<p><code>character</code> indicating type of truncation (optional) &quot;Lenth&quot; uses
asymmetric confidence intervals to determine outlying loading weights. &quot;quantile&quot; uses
a quantile plot approach to determining outliers.</p>
</td></tr>
<tr><td><code id="smbpls_+3A_trunc.width">trunc.width</code></td>
<td>
<p><code>numeric</code> indicating confidence of &quot;Lenth type&quot; confidence interval
or quantile in &quot;quantile plot&quot; approach. Default = 0.95.</p>
</td></tr>
<tr><td><code id="smbpls_+3A_blockscale">blockScale</code></td>
<td>
<p>Either a <code>character</code> indicating type of block scaling or a <code>numeric</code> vector of block weights (see Details).</p>
</td></tr>
<tr><td><code id="smbpls_+3A_...">...</code></td>
<td>
<p>additional arguments to pls::plsr.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Two versions of sparseness are supplied: Soft-Threshold PLS, also
known as Sparse PLS, and Truncation PLS. The former uses L1 shrinkage of loading weights, while the latter
comes in two flavours, both estimating inliers and outliers. The &quot;Lenth&quot; method uses asymmetric confidence
intervals around the median of a loading weigh vector to estimate inliers. The &quot;quantile&quot; method uses
a quantile plot approach to estimate outliers as deviations from the estimated quantile line. As with
ordinary MB-PLS scaled input blocks (1/sqrt(ncol)) are used.
</p>
<p>Block weighting is performed after scaling all variables and is by default
<code>"sqrtnvar"</code>: 1/sqrt(ncol(X[[i]])) in each block. Alternatives
are <code>"ssq"</code>: 1/norm(X[[i]], &quot;F&quot;)^2 and <code>"none"</code>: 1/1. Finally, if
a <code>numeric</code> vector is supplied, it will be used to scale the blocks
after <code>"ssq"</code> scaling, i.e., Z[[i]] = X[[i]] / norm(X[[i]], &quot;F&quot;)^2 * blockScale[i].
</p>


<h3>Value</h3>

<p><code>multiblock, mvr</code> object with super-scores, super-loadings, block-scores and block-loading, and the underlying
<code>mvr</code> (PLS) object for the super model, with all its result and plot possibilities. Relevant plotting functions: <code><a href="#topic+multiblock_plots">multiblock_plots</a></code>
and result functions: <code><a href="#topic+multiblock_results">multiblock_results</a></code>.
</p>


<h3>References</h3>


<ul>
<li><p> Sæbø, S.; Almøy, T.; Aarøe, J. &amp; Aastveit, A. ST-PLS: a multi-directional nearest shrunken centroid type classifier via PLS Journal of Chemometrics: A Journal of the Chemometrics Society, Wiley Online Library, 2008, 22, 54-62.
</p>
</li>
<li><p> Lê Cao, K.; Rossouw, D.; Robert-Granié, C. &amp; Besse, P. A sparse PLS for variable selection when integrating omics data Statistical applications in genetics and molecular biology, 2008, 7.
</p>
</li>
<li><p> Liland, K.; Høy, M.; Martens, H. &amp; Sæbø, S. Distribution based truncation for variable selection in subspace methods for multivariate regression Chemometrics and Intelligent Laboratory Systems, 2013, 122, 103-111.
</p>
</li>
<li><p> Karaman, I.; Nørskov, N.; Yde, C.; Hedemann, M.; Knudsen, K. &amp; Kohler, A. Sparse multi-block PLSR for biomarker discovery when integrating data from LC&ndash;MS and NMR metabolomics Metabolomics, 2015, 11, 367-379.
</p>
</li></ul>



<h3>See Also</h3>

<p>Overviews of available methods, <code><a href="#topic+multiblock">multiblock</a></code>, and methods organised by main structure: <code><a href="#topic+basic">basic</a></code>, <code><a href="#topic+unsupervised">unsupervised</a></code>, <code><a href="#topic+asca">asca</a></code>, <code><a href="#topic+supervised">supervised</a></code> and <code><a href="#topic+complex">complex</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(potato)

# Truncation MB-PLS 
# Loading weights inside 60% confidence intervals around the median are set to 0.
tmb &lt;- smbpls(Sensory ~ Chemical+Compression, data=potato, ncomp = 5, 
              truncation = "Lenth", trunc.width = 0.6)
              
# Alternative XY-interface
tmb.XY &lt;- smbpls(X=potato[c('Chemical','Compression')], Y=potato[['Sensory']], ncomp = 5, 
              truncation = "Lenth", trunc.width = 0.6)
identical(tmb, tmb.XY)
scoreplot(tmb, labels="names") # Exploiting mvr object structure from pls package
loadingweightplot(tmb, labels="names")

# Soft-Threshold / Sparse MB-PLS 
# Loading weights are subtracted by 60% of maximum value.
smb &lt;- smbpls(X=potato[c('Chemical','Compression')], Y=potato[['Sensory']], 
              ncomp = 5, shrink = 0.6)
print(smb)
scoreplot(smb, labels="names") # Exploiting mvr object structure from pls package
loadingweightplot(smb, labels="names")

# Emphasis may be different for blocks
smb &lt;- smbpls(X=potato[c('Chemical','Compression')], Y=potato[['Sensory']], 
              ncomp = 5, shrink = 0.6, blockScale = c(1, 10))
</code></pre>

<hr>
<h2 id='SO_TDI'>Total, direct, indirect and additional effects in SO-PLS-PM.</h2><span id='topic+SO_TDI'></span><span id='topic+sopls_pm'></span><span id='topic+print.SO_TDI'></span><span id='topic+sopls_pm_multiple'></span><span id='topic+print.SO_TDI_multiple'></span>

<h3>Description</h3>

<p>SO-PLS-PM is the use of SO-PLS for path-modelling. This particular function
is used to compute effects (explained variances) in sub-paths of the directed acyclic graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sopls_pm(
  X,
  Y,
  ncomp,
  max_comps = min(sum(ncomp), 20),
  sel.comp = "opt",
  computeAdditional = FALSE,
  sequential = FALSE,
  B = NULL,
  k = 10,
  type = "consecutive",
  simultaneous = TRUE
)

## S3 method for class 'SO_TDI'
print(x, showComp = TRUE, heading = "SO-PLS path effects", digits = 2, ...)

sopls_pm_multiple(
  X,
  ncomp,
  max_comps = min(sum(ncomp), 20),
  sel.comp = "opt",
  computeAdditional = FALSE,
  sequential = FALSE,
  B = NULL,
  k = 10,
  type = "consecutive"
)

## S3 method for class 'SO_TDI_multiple'
print(x, heading = "SO-PLS path effects", digits = 2, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SO_TDI_+3A_x">X</code></td>
<td>
<p>A <code>list</code> of input blocks (of type <code>matrix</code>).</p>
</td></tr>
<tr><td><code id="SO_TDI_+3A_y">Y</code></td>
<td>
<p>A <code>matrix</code> of response(s).</p>
</td></tr>
<tr><td><code id="SO_TDI_+3A_ncomp">ncomp</code></td>
<td>
<p>An <code>integer</code> vector giving the number of components per block or a single integer for common number of components.</p>
</td></tr>
<tr><td><code id="SO_TDI_+3A_max_comps">max_comps</code></td>
<td>
<p>Maximum total number of components.</p>
</td></tr>
<tr><td><code id="SO_TDI_+3A_sel.comp">sel.comp</code></td>
<td>
<p>A <code>character</code> or <code>integer</code> vector indicating the type (&quot;opt&quot; - minimum error / &quot;chi&quot; - chi-squared reduced) or exact number of components in selections.</p>
</td></tr>
<tr><td><code id="SO_TDI_+3A_computeadditional">computeAdditional</code></td>
<td>
<p>A <code>logical</code> indicating if additional components should be computed.</p>
</td></tr>
<tr><td><code id="SO_TDI_+3A_sequential">sequential</code></td>
<td>
<p>A <code>logical</code> indicating if sequential component optimization should be applied.</p>
</td></tr>
<tr><td><code id="SO_TDI_+3A_b">B</code></td>
<td>
<p>An <code>integer</code> giving the number of bootstrap replicates for variation estimation.</p>
</td></tr>
<tr><td><code id="SO_TDI_+3A_k">k</code></td>
<td>
<p>An <code>integer</code> indicating number of cross-validation segments (default = 10).</p>
</td></tr>
<tr><td><code id="SO_TDI_+3A_type">type</code></td>
<td>
<p>A <code>character</code> for selecting type of cross-validation segments (default = &quot;consecutive&quot;).</p>
</td></tr>
<tr><td><code id="SO_TDI_+3A_simultaneous">simultaneous</code></td>
<td>
<p><code>logical</code> indicating if simultaneous orthogonalisation on intermediate blocks should be performed (default = TRUE).</p>
</td></tr>
<tr><td><code id="SO_TDI_+3A_x">x</code></td>
<td>
<p>An object of type <code>SO_TDI</code>.</p>
</td></tr>
<tr><td><code id="SO_TDI_+3A_showcomp">showComp</code></td>
<td>
<p>A <code>logical</code> indicating if components should be shown in print (default = TRUE).</p>
</td></tr>
<tr><td><code id="SO_TDI_+3A_heading">heading</code></td>
<td>
<p>A <code>character</code> giving the heading of the print.</p>
</td></tr>
<tr><td><code id="SO_TDI_+3A_digits">digits</code></td>
<td>
<p>An <code>integer</code> for selecting number of digits in print.</p>
</td></tr>
<tr><td><code id="SO_TDI_+3A_...">...</code></td>
<td>
<p>Not implemented</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>sopls_pm</code> computes 'total', 'direct', 'indirect' and 'additional' effects for the 'first' versus the
'last' input block by cross-validated explained variances. 'total' is the explained variance when doing
regression of 'first' -&gt; 'last'. 'indirect' is the the same, but controlled for the intermediate blocks.
'direct' is the left-over part of the 'total' explained variance when subtracting the 'indirect'. Finally,
'additional' is the added explained variance of 'last' for each block following 'first'.
</p>
<p><code>sopls_pm_multiple</code> is a wrapper for <code>sopls_pm</code> that repeats the calculation for all pairs of blocks
from 'first' to 'last'. Where <code>sopls_pm</code> has a separate response, Y, signifying the 'last' block,
<code>sopls_pm_multiple</code> has multiple 'last' blocks, depending on sub-path, thus collects the response(s)
from the list of blocks X.
</p>
<p>When sel.comp = &quot;opt&quot;, the number of components for all models are optimized using cross-validation
within the ncomp and max_comps supplied. If sel.comp is &quot;chi&quot;, an optimization is also performed,
but parsimonious solutions are sought through a chi-square chriterion. When setting sel.comp to a
numeric vector, exact selection of number of components is performed.
</p>
<p>When setting B to a number, e.g. 200, the procedures above are repeated B times using bootstrapping
to estimate standard deviations of the cross-validated explained variances.
</p>


<h3>Value</h3>

<p>An object of type <code>SO_TDI</code> containing total, direct and indirect effects, plus
possibly additional effects and standard deviations (estimated by bootstrapping).
</p>


<h3>References</h3>


<ul>
<li><p> Menichelli, E., Almøy, T., Tomic, O., Olsen, N. V., &amp; Næs, T. (2014). SO-PLS as an exploratory tool for path modelling. Food quality and preference, 36, 122-134.
</p>
</li>
<li><p> Næs, T., Romano, R., Tomic, O., Måge, I., Smilde, A., &amp; Liland, K. H. (2020). Sequential and orthogonalized PLS (SO-PLS) regression for path analysis: Order of blocks and relations between effects. Journal of Chemometrics, e3243.
</p>
</li></ul>



<h3>See Also</h3>

<p>Overviews of available methods, <code><a href="#topic+multiblock">multiblock</a></code>, and methods organised by main structure: <code><a href="#topic+basic">basic</a></code>, <code><a href="#topic+unsupervised">unsupervised</a></code>, <code><a href="#topic+asca">asca</a></code>, <code><a href="#topic+supervised">supervised</a></code> and <code><a href="#topic+complex">complex</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Single path for the potato data:
data(potato)
pot.pm &lt;- sopls_pm(potato[1:3], potato[['Sensory']], c(5,5,5), computeAdditional=TRUE)
pot.pm

# Corresponding SO-PLS model:
# so &lt;- sopls(Sensory ~ ., data=potato[c(1,2,3,9)], ncomp=c(5,5,5), validation="CV", segments=10)
# maageSeq(pot.so, compSeq = c(3,2,4))

# All path in the forward direction for the wine data:
data(wine)
pot.pm.multiple &lt;- sopls_pm_multiple(wine, ncomp = c(4,2,9,8))
pot.pm.multiple
</code></pre>

<hr>
<h2 id='sopls'>Sequential and Orthogonalized PLS (SO-PLS)</h2><span id='topic+sopls'></span>

<h3>Description</h3>

<p>Function for computing standard SO-PLS based on the interface of the <code>pls</code> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sopls(
  formula,
  ncomp,
  max_comps = min(sum(ncomp), 20),
  data,
  subset,
  na.action,
  scale = FALSE,
  validation = c("none", "CV", "LOO"),
  sequential = FALSE,
  segments = 10,
  sel.comp = "opt",
  progress = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sopls_+3A_formula">formula</code></td>
<td>
<p>Model formula accepting a single response (block) and predictor block names separated by + signs.</p>
</td></tr>
<tr><td><code id="sopls_+3A_ncomp">ncomp</code></td>
<td>
<p>Numeric vector of components per block or scalar of overall maximum components.</p>
</td></tr>
<tr><td><code id="sopls_+3A_max_comps">max_comps</code></td>
<td>
<p>Maximum total number of components from all blocks combined (&lt;= sum(ncomp)).</p>
</td></tr>
<tr><td><code id="sopls_+3A_data">data</code></td>
<td>
<p>The data set to analyse.</p>
</td></tr>
<tr><td><code id="sopls_+3A_subset">subset</code></td>
<td>
<p>Expression for subsetting the data before modelling.</p>
</td></tr>
<tr><td><code id="sopls_+3A_na.action">na.action</code></td>
<td>
<p>How to handle NAs (no action implemented).</p>
</td></tr>
<tr><td><code id="sopls_+3A_scale">scale</code></td>
<td>
<p>Logical indicating if variables should be scaled.</p>
</td></tr>
<tr><td><code id="sopls_+3A_validation">validation</code></td>
<td>
<p>Optional cross-validation strategy &quot;CV&quot; or &quot;LOO&quot;.</p>
</td></tr>
<tr><td><code id="sopls_+3A_sequential">sequential</code></td>
<td>
<p>Logical indicating if optimal components are chosen sequentially or globally (default=FALSE).</p>
</td></tr>
<tr><td><code id="sopls_+3A_segments">segments</code></td>
<td>
<p>Optional number of segments or list of segments for cross-validation. (See <code>[pls::cvsegments()]</code>).</p>
</td></tr>
<tr><td><code id="sopls_+3A_sel.comp">sel.comp</code></td>
<td>
<p>Character indicating if sequential optimal number of components should be chosen as minimum RMSECV ('opt', default) or by Chi-square test ('chi').</p>
</td></tr>
<tr><td><code id="sopls_+3A_progress">progress</code></td>
<td>
<p>Logical indicating if a progress bar should be displayed while cross-validating.</p>
</td></tr>
<tr><td><code id="sopls_+3A_...">...</code></td>
<td>
<p>Additional arguments to underlying methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>SO-PLS is a method which handles two or more input blocks by sequentially performing
PLS on blocks against a response and orthogonalising the remaining blocks on the extracted components.
Component number optimisation can either be done globally (best combination across blocks) or sequentially
(determine for one block, move to next, etc.).
</p>


<h3>Value</h3>

<p>An <code>sopls, mvr</code> object with scores, loadings, etc.
associated with printing (<code><a href="#topic+sopls_results">sopls_results</a></code>) and plotting methods (<code><a href="#topic+sopls_plots">sopls_plots</a></code>).
</p>


<h3>References</h3>

<p>Jørgensen K, Mevik BH, Næs T. Combining designed experiments with several blocks of spectroscopic data. Chemometr Intell Lab Syst. 2007;88(2): 154–166.
</p>


<h3>See Also</h3>

<p>SO-PLS result functions, <code><a href="#topic+sopls_results">sopls_results</a></code>, SO-PLS plotting functions, <code><a href="#topic+sopls_plots">sopls_plots</a></code>, SO-PLS Måge plot, <code><a href="#topic+maage">maage</a></code>, and SO-PLS path-modelling, <code><a href="#topic+SO_TDI">SO_TDI</a></code>.
Overviews of available methods, <code><a href="#topic+multiblock">multiblock</a></code>, and methods organised by main structure: <code><a href="#topic+basic">basic</a></code>, <code><a href="#topic+unsupervised">unsupervised</a></code>, <code><a href="#topic+asca">asca</a></code>, <code><a href="#topic+supervised">supervised</a></code> and <code><a href="#topic+complex">complex</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(potato)
so &lt;- sopls(Sensory ~ Chemical + Compression, data=potato, ncomp=c(10,10), 
            max_comps=10, validation="CV", segments=10)
summary(so)

# Scatter plot matrix with two first components from Chemical block
# and 1 component from the Compression block.
scoreplot(so, comps=list(1:2,1), ncomp=2, block=2)

# Result functions and more plots for SO-PLS 
# are found in ?sopls_results and ?sopls_plots.
</code></pre>

<hr>
<h2 id='sopls_plots'>Scores, loadings and plots for sopls objects</h2><span id='topic+sopls_plots'></span><span id='topic+loadings.sopls'></span><span id='topic+scores.sopls'></span><span id='topic+loadingplot.sopls'></span><span id='topic+scoreplot.sopls'></span><span id='topic+biplot.sopls'></span><span id='topic+corrplot.sopls'></span>

<h3>Description</h3>

<p>Extraction of <code>scores</code> and <code>loadings</code> and adaptation of <code>scoreplot</code>,
<code>loadingplot</code> and <code>biplot</code> from package <code>pls</code> for <code>sopls</code> objects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sopls'
loadings(object, ncomp = "all", block = 1, y = FALSE, ...)

## S3 method for class 'sopls'
scores(object, ncomp = "all", block = 1, y = FALSE, ...)

## S3 method for class 'sopls'
scoreplot(
  object,
  comps = 1:2,
  ncomp = NULL,
  block = 1,
  labels,
  identify = FALSE,
  type = "p",
  xlab,
  ylab,
  ...
)

## S3 method for class 'sopls'
loadingplot(
  object,
  comps = 1:2,
  ncomp = NULL,
  block = 1,
  scatter = TRUE,
  labels,
  identify = FALSE,
  type,
  lty,
  lwd = NULL,
  pch,
  cex = NULL,
  col,
  legendpos,
  xlab,
  ylab,
  pretty.xlabels = TRUE,
  xlim,
  ...
)

## S3 method for class 'sopls'
corrplot(
  object,
  comps = 1:2,
  ncomp = NULL,
  block = 1,
  labels = TRUE,
  col = 1:5,
  plotx = TRUE,
  ploty = TRUE,
  ...
)

## S3 method for class 'sopls'
biplot(
  x,
  comps = 1:2,
  ncomp = "all",
  block = 1,
  which = c("x", "y", "scores", "loadings"),
  var.axes = FALSE,
  xlabs,
  ylabs,
  main,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sopls_plots_+3A_object">object</code></td>
<td>
<p><code>sopls</code> object</p>
</td></tr>
<tr><td><code id="sopls_plots_+3A_ncomp">ncomp</code></td>
<td>
<p><code>integer</code> vector giving components from all blocks before <code>block</code> (see next argument).</p>
</td></tr>
<tr><td><code id="sopls_plots_+3A_block">block</code></td>
<td>
<p><code>integer</code> indicating which block to extract components from.</p>
</td></tr>
<tr><td><code id="sopls_plots_+3A_y">y</code></td>
<td>
<p><code>logical</code> extract Y loadings/scores instead of X loadings/scores (default = FALSE).</p>
</td></tr>
<tr><td><code id="sopls_plots_+3A_...">...</code></td>
<td>
<p>further arguments sent to the underlying plot function(s)</p>
</td></tr>
<tr><td><code id="sopls_plots_+3A_comps">comps</code></td>
<td>
<p><code>integer</code> vector giving components, within block, to plot (see Details regarding combination of blocks).</p>
</td></tr>
<tr><td><code id="sopls_plots_+3A_labels">labels</code></td>
<td>
<p><code>character</code> indicating if &quot;names&quot; or &quot;numbers&quot; should be plot symbols (optional).</p>
</td></tr>
<tr><td><code id="sopls_plots_+3A_identify">identify</code></td>
<td>
<p><code>logical</code> for activating <code>identify</code> to interactively identify points.</p>
</td></tr>
<tr><td><code id="sopls_plots_+3A_type">type</code></td>
<td>
<p><code>character</code> for selecting type of plot to make. Defaults to &quot;p&quot; (points) for scatter plots and &quot;l&quot; (lines) for line plots.</p>
</td></tr>
<tr><td><code id="sopls_plots_+3A_xlab">xlab</code></td>
<td>
<p><code>character</code> text for x labels.</p>
</td></tr>
<tr><td><code id="sopls_plots_+3A_ylab">ylab</code></td>
<td>
<p><code>character</code> text for y labels.</p>
</td></tr>
<tr><td><code id="sopls_plots_+3A_scatter">scatter</code></td>
<td>
<p><code>logical</code> indicating if a scatterplot of loadings should be made (default = TRUE).</p>
</td></tr>
<tr><td><code id="sopls_plots_+3A_lty">lty</code></td>
<td>
<p>Vector of line type specifications (see <code><a href="graphics.html#topic+par">par</a></code> for details).</p>
</td></tr>
<tr><td><code id="sopls_plots_+3A_lwd">lwd</code></td>
<td>
<p><code>numeric</code> vector of line width specifications.</p>
</td></tr>
<tr><td><code id="sopls_plots_+3A_pch">pch</code></td>
<td>
<p>Vector of point specifications (see <code><a href="graphics.html#topic+points">points</a></code> for details).</p>
</td></tr>
<tr><td><code id="sopls_plots_+3A_cex">cex</code></td>
<td>
<p><code>numeric</code> vector of plot size expansions (see <code><a href="graphics.html#topic+par">par</a></code> for details).</p>
</td></tr>
<tr><td><code id="sopls_plots_+3A_col">col</code></td>
<td>
<p><code>integer</code> vector of symbol/line colours (see <code><a href="graphics.html#topic+par">par</a></code> for details).</p>
</td></tr>
<tr><td><code id="sopls_plots_+3A_legendpos">legendpos</code></td>
<td>
<p><code>character</code> indicating legend position (if <code>scatter</code> is FALSE), e.g. <code>legendpos = "topright"</code>.</p>
</td></tr>
<tr><td><code id="sopls_plots_+3A_pretty.xlabels">pretty.xlabels</code></td>
<td>
<p><code>logical</code> indicating if xlabels should be more nicely plotted (default = TRUE).</p>
</td></tr>
<tr><td><code id="sopls_plots_+3A_xlim">xlim</code></td>
<td>
<p><code>numeric</code> vector of length two, with the x limits of the plot (optional).</p>
</td></tr>
<tr><td><code id="sopls_plots_+3A_plotx">plotx</code></td>
<td>
<p><code>locical</code> or <code>integer</code>/<code>character</code>.  Whether to plot the <code class="reqn">X</code> correlation loadings, optionally which block(s). Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sopls_plots_+3A_ploty">ploty</code></td>
<td>
<p><code>logical</code>.  Whether to plot the <code class="reqn">Y</code> correlation loadings. Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="sopls_plots_+3A_x">x</code></td>
<td>
<p><code>sopls</code> object</p>
</td></tr>
<tr><td><code id="sopls_plots_+3A_which">which</code></td>
<td>
<p><code>character</code> for selecting type of biplot (&quot;x&quot; = default, &quot;y&quot;, &quot;scores&quot;, &quot;loadings&quot;).</p>
</td></tr>
<tr><td><code id="sopls_plots_+3A_var.axes">var.axes</code></td>
<td>
<p><code>logical</code> indicating if second axes of a biplot should have arrows.</p>
</td></tr>
<tr><td><code id="sopls_plots_+3A_xlabs">xlabs</code></td>
<td>
<p><code>character</code> vector for labelling first set of biplot points (optional).</p>
</td></tr>
<tr><td><code id="sopls_plots_+3A_ylabs">ylabs</code></td>
<td>
<p><code>character</code> vector for labelling second set of biplot points (optional).</p>
</td></tr>
<tr><td><code id="sopls_plots_+3A_main">main</code></td>
<td>
<p><code>character</code> for setting the main title of a plot.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If <code>comps</code> is supplied as a <code>list</code> for <code>scoreplot</code>, it is assumed that its elements refer to each of the
blocks up to block number <code>block</code>. For instance <code>comps = list(1, 0, 1:2)</code> will select 1 component from the first
block, no components from the second block and the first two components from the last block. This must be
matched by <code>ncomp</code>, specifying how many components were selected before block number <code>block</code>.
</p>


<h3>See Also</h3>

<p>Overviews of available methods, <code><a href="#topic+multiblock">multiblock</a></code>, and methods organised by main structure: <code><a href="#topic+basic">basic</a></code>, <code><a href="#topic+unsupervised">unsupervised</a></code>, <code><a href="#topic+asca">asca</a></code>, <code><a href="#topic+supervised">supervised</a></code> and <code><a href="#topic+complex">complex</a></code>.
Common functions for computation and extraction of results are found in <code><a href="#topic+sopls_results">sopls_results</a></code>.
</p>
<p>#' @return The score and loading functions return scores and loadings, while plot functions have no return (except use of 'identify').
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(potato)
so &lt;- sopls(Sensory ~ Chemical + Compression + NIRraw, data=potato, ncomp=c(5,5,5))

# Loadings
loadings(so, ncomp=c(3), block=2)[, 1:3]

# Scores
scores(so, block=1)[, 1:4]

# Default plot from first block
scoreplot(so)

# Second block with names
scoreplot(so, ncomp=c(3), block=2, labels="names")

# Scatterplot matrix
scoreplot(so, ncomp=c(3,2), block=3, comps=1:3)

# Combination of blocks (see Details)
scoreplot(so, ncomp=c(3,2), block=3, comps=list(1,0,1))

# Default plot from first block
loadingplot(so, scatter=TRUE)

# Second block with names
loadingplot(so, ncomp=c(3), block=2, labels="names", scatter=TRUE)

# Scatterplot matrix
loadingplot(so, ncomp=c(3,2), block=3, comps=1:3, scatter=TRUE)

# Correlation loadings
corrplot(so, block=2, ncomp=1)

# Default plot from first block
biplot(so)
</code></pre>

<hr>
<h2 id='sopls_results'>Result functions for SO-PLS models</h2><span id='topic+sopls_results'></span><span id='topic+predict.sopls'></span><span id='topic+coef.sopls'></span><span id='topic+print.sopls'></span><span id='topic+summary.sopls'></span><span id='topic+pcp.sopls'></span><span id='topic+R2.sopls'></span><span id='topic+classify.sopls'></span><span id='topic+RMSEP.sopls'></span><span id='topic+cvanova.sopls'></span><span id='topic+cvanova'></span><span id='topic+classify'></span><span id='topic+pcp'></span><span id='topic+pcp.default'></span><span id='topic+cvanova.default'></span><span id='topic+print.cvanova'></span><span id='topic+summary.cvanova'></span><span id='topic+plot.cvanova'></span><span id='topic+residuals.sopls'></span>

<h3>Description</h3>

<p>Standard result functions for SO-PLS (<code><a href="#topic+sopls">sopls</a></code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'sopls'
predict(
  object,
  newdata,
  ncomp = object$ncomp,
  type = c("response", "scores"),
  na.action = na.pass,
  ...
)

## S3 method for class 'sopls'
coef(object, ncomp = object$ncomp, intercept = FALSE, ...)

## S3 method for class 'sopls'
print(x, ...)

## S3 method for class 'sopls'
summary(
  object,
  what = c("all", "validation", "training"),
  digits = 4,
  print.gap = 2,
  ...
)

classify(object, ...)

## S3 method for class 'sopls'
classify(object, classes, newdata, ncomp, LQ = "LDA", ...)

## S3 method for class 'sopls'
R2(object, estimate, newdata, ncomp = "all", individual = FALSE, ...)

## S3 method for class 'sopls'
RMSEP(object, estimate, newdata, ncomp = "all", individual = FALSE, ...)

pcp(object, ...)

## S3 method for class 'sopls'
pcp(object, ncomp, ...)

## Default S3 method:
pcp(object, X, ...)

cvanova(pred, ...)

## Default S3 method:
cvanova(pred, true, absRes = TRUE, ...)

## S3 method for class 'sopls'
cvanova(pred, comps, absRes = TRUE, ...)

## S3 method for class 'cvanova'
print(x, ...)

## S3 method for class 'cvanova'
summary(object, ...)

## S3 method for class 'cvanova'
plot(x, ...)

## S3 method for class 'sopls'
residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="sopls_results_+3A_object">object</code></td>
<td>
<p>A <code>sopls</code> object.</p>
</td></tr>
<tr><td><code id="sopls_results_+3A_newdata">newdata</code></td>
<td>
<p>Optional new data with the same types of predictor blocks as the ones used for fitting the object.</p>
</td></tr>
<tr><td><code id="sopls_results_+3A_ncomp">ncomp</code></td>
<td>
<p>An <code>integer</code> vector giving the exact components to apply.</p>
</td></tr>
<tr><td><code id="sopls_results_+3A_type">type</code></td>
<td>
<p>A <code>character</code> for <code>predict</code> indicating if responses or scores should be predicted (default = &quot;response&quot;, or &quot;scores&quot;), for <code>summary</code> indicating which type of explained variance to compute (default = &quot;train&quot;, alternative = &quot;CV&quot;).</p>
</td></tr>
<tr><td><code id="sopls_results_+3A_na.action">na.action</code></td>
<td>
<p>Function determining what to do with missing values in <code>newdata</code>.</p>
</td></tr>
<tr><td><code id="sopls_results_+3A_...">...</code></td>
<td>
<p>Additional arguments. Currently not implemented.</p>
</td></tr>
<tr><td><code id="sopls_results_+3A_intercept">intercept</code></td>
<td>
<p>A <code>logical</code> indicating if coefficients for the intercept should be included (default = FALSE).</p>
</td></tr>
<tr><td><code id="sopls_results_+3A_x">x</code></td>
<td>
<p>A <code>sopls</code> object.</p>
</td></tr>
<tr><td><code id="sopls_results_+3A_what">what</code></td>
<td>
<p>A <code>character</code> indicating if summary should include all, validation or training.</p>
</td></tr>
<tr><td><code id="sopls_results_+3A_digits">digits</code></td>
<td>
<p>The number of digits used for printing.</p>
</td></tr>
<tr><td><code id="sopls_results_+3A_print.gap">print.gap</code></td>
<td>
<p>Gap between columns when printing.</p>
</td></tr>
<tr><td><code id="sopls_results_+3A_classes">classes</code></td>
<td>
<p>A <code>character</code> vector of class labels.</p>
</td></tr>
<tr><td><code id="sopls_results_+3A_lq">LQ</code></td>
<td>
<p>A <code>character</code> indicating if 'max' (maximum score value), 'lda' or 'qda' should be used when classifying.</p>
</td></tr>
<tr><td><code id="sopls_results_+3A_estimate">estimate</code></td>
<td>
<p>A <code>character</code> indicating if 'train', 'CV' or 'test' results should be displayed.</p>
</td></tr>
<tr><td><code id="sopls_results_+3A_individual">individual</code></td>
<td>
<p>A <code>logical</code> indicating if results for individual responses should be displayed.</p>
</td></tr>
<tr><td><code id="sopls_results_+3A_x">X</code></td>
<td>
<p>A <code>list</code> of data blocks.</p>
</td></tr>
<tr><td><code id="sopls_results_+3A_pred">pred</code></td>
<td>
<p>An object holding the CV-predicted values (<code>sopls</code>, <code>matrix</code> or <code>list</code> of vectors)</p>
</td></tr>
<tr><td><code id="sopls_results_+3A_true">true</code></td>
<td>
<p>A <code>numeric</code> of true response values for CVANOVA.</p>
</td></tr>
<tr><td><code id="sopls_results_+3A_absres">absRes</code></td>
<td>
<p>A <code>logical</code> indicating if absolute (TRUE) or squared (FALSE) residuals should be computed.</p>
</td></tr>
<tr><td><code id="sopls_results_+3A_comps">comps</code></td>
<td>
<p>An <code>integer</code> vector giving the exact components to apply.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The parameter <code>ncomp</code> controls
which components to apply/extract, resulting in the sequence of components leading up to the specific choice, i.e.
<code>ncomp = c(2,2,1)</code> results in the sequence 1,0,0; 2,0,0; 2,1,0; 2,2,0; 2,2,1.
Usage of the functions are shown using generics in the examples below.
Prediction, regression coefficients, object printing and summary are available through:
<code>predict.sopls</code>, <code>coef.sopls</code>, <code>print.sopls</code> and <code>summary.sopls</code>.
Explained variances and RMSEP are available through <code>R2.sopls</code> and <code>RMSEP.sopls</code>.
Principal components of predictions are available through <code>pcp.sopls</code>. Finally, there is work in progress on classifcation
support through <code>classify.sopls</code>.
</p>


<h3>Value</h3>

<p>Returns depend on method used, e.g. <code>predict.sopls</code> returns predicted responses
or scores depending on inputs, <code>coef.sopls</code> return regression coefficients, while print and summary methods return the object invisibly.
</p>


<h3>References</h3>

<p>Jørgensen K, Mevik BH, Næs T. Combining designed experiments with several blocks of spectroscopic data. Chemometr Intell Lab Syst. 2007;88(2): 154–166.
</p>


<h3>See Also</h3>

<p>Overviews of available methods, <code><a href="#topic+multiblock">multiblock</a></code>, and methods organised by main structure: <code><a href="#topic+basic">basic</a></code>, <code><a href="#topic+unsupervised">unsupervised</a></code>, <code><a href="#topic+asca">asca</a></code>, <code><a href="#topic+supervised">supervised</a></code> and <code><a href="#topic+complex">complex</a></code>.
Common functions for plotting are found in <code><a href="#topic+sopls_plots">sopls_plots</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(potato)
mod &lt;- sopls(Sensory[,1] ~ ., data = potato[c(1:3,9)], ncomp = 5, subset = 1:20)
testset &lt;- potato[-(1:20),]; testset$Sensory &lt;- testset$Sensory[,1,drop=FALSE]
predict(mod, testset, ncomp=c(2,1,2))
dim(coef(mod, ncomp=c(3,0,1))) # &lt;variables x responses x components&gt;
R2(mod, ncomp = c(4,1,2))
print(mod)
summary(mod)

# PCP from sopls object
modMulti &lt;- sopls(Sensory ~ ., data = potato[c(1:3,9)], ncomp = 5, validation = "CV", segment = 5)
(PCP &lt;- pcp(modMulti, c(2,1,2)))
scoreplot(PCP)

# PCP from matrices
preds &lt;- modMulti$validation$Ypred[,,"2,1,2"]
PCP_default &lt;- pcp(preds, potato[1:3])

# CVANOVA
modCV &lt;- sopls(Sensory[,1] ~ ., data = potato[c(1:3,9)], ncomp = 5, validation = "CV", segment = 5)
summary(cva &lt;- cvanova(modCV, "2,1,2"))
plot(cva)

</code></pre>

<hr>
<h2 id='statis'>Structuration des Tableaux à Trois Indices de la Statistique - STATIS</h2><span id='topic+statis'></span>

<h3>Description</h3>

<p>This is a wrapper for the <code>ade4::statis</code> function for computing STATIS.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>statis(X, ncomp = 3, scannf = FALSE, tol = 1e-07, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="statis_+3A_x">X</code></td>
<td>
<p><code>list</code> of input blocks.</p>
</td></tr>
<tr><td><code id="statis_+3A_ncomp">ncomp</code></td>
<td>
<p><code>integer</code> number of components to extract.</p>
</td></tr>
<tr><td><code id="statis_+3A_scannf">scannf</code></td>
<td>
<p><code>logical</code> indicating if eigenvalue bar plot shoulde be displayed.</p>
</td></tr>
<tr><td><code id="statis_+3A_tol">tol</code></td>
<td>
<p><code>numeric</code> eigenvalue threshold tolerance.</p>
</td></tr>
<tr><td><code id="statis_+3A_...">...</code></td>
<td>
<p>additional arguments (not used).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>STATIS is a method, related to MFA, for analysing two or more blocks. It also
decomposes the data into a low-dimensional subspace but uses a different scaling of the
individual blocks.
</p>


<h3>Value</h3>

<p><code>multiblock</code> object including relevant scores and loadings. Relevant plotting functions: <code><a href="#topic+multiblock_plots">multiblock_plots</a></code>
and result functions: <code><a href="#topic+multiblock_results">multiblock_results</a></code>.
</p>


<h3>References</h3>

<p>Lavit, C.; Escoufier, Y.; Sabatier, R.; Traissac, P. (1994). The ACT (STATIS method). Computational Statistics &amp; Data Analysis. 18: 97
</p>


<h3>See Also</h3>

<p>Overviews of available methods, <code><a href="#topic+multiblock">multiblock</a></code>, and methods organised by main structure: <code><a href="#topic+basic">basic</a></code>, <code><a href="#topic+unsupervised">unsupervised</a></code>, <code><a href="#topic+asca">asca</a></code>, <code><a href="#topic+supervised">supervised</a></code> and <code><a href="#topic+complex">complex</a></code>.
Common functions for computation and extraction of results and plotting are found in <code><a href="#topic+multiblock_results">multiblock_results</a></code> and <code><a href="#topic+multiblock_plots">multiblock_plots</a></code>, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(candies)
candyList &lt;- lapply(1:nlevels(candies$candy),function(x)candies$assessment[candies$candy==x,])
can.statis &lt;- statis(candyList)
plot(scores(can.statis), labels="names")

</code></pre>

<hr>
<h2 id='supervised'>Supervised Multiblock Methods</h2><span id='topic+supervised'></span>

<h3>Description</h3>

<p>Collection of supervised multiblock methods:
</p>

<ul>
<li><p> MB-PLS - Multiblock Partial Least Squares (<code><a href="#topic+mbpls">mbpls</a></code>)
</p>
</li>
<li><p> sMB-PLS - Sparse Multiblock Partial Least Squares (<code><a href="#topic+smbpls">smbpls</a></code>)
</p>
</li>
<li><p> SO-PLS - Sequential and Orthogonalized PLS (<code><a href="#topic+sopls">sopls</a></code>)
</p>
</li>
<li><p> PO-PLS - Parallel and Orthogonalized PLS (<code><a href="#topic+popls">popls</a></code>)
</p>
</li>
<li><p> ROSA - Response Oriented Sequential Alternation (<code><a href="#topic+rosa">rosa</a></code>)
</p>
</li>
<li><p> mbRDA - Multiblock Redundancy Analysis (<code><a href="#topic+mbrda">mbrda</a></code>)
</p>
</li></ul>



<h3>See Also</h3>

<p>Overviews of available methods, <code><a href="#topic+multiblock">multiblock</a></code>, and methods organised by main structure: <code><a href="#topic+basic">basic</a></code>, <code><a href="#topic+unsupervised">unsupervised</a></code>, <code><a href="#topic+asca">asca</a></code>, <code><a href="#topic+supervised">supervised</a></code> and <code><a href="#topic+complex">complex</a></code>.
Common functions for computation and extraction of results and plotting are found in <code><a href="#topic+multiblock_results">multiblock_results</a></code> and <code><a href="#topic+multiblock_plots">multiblock_plots</a></code>, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(potato)
mb &lt;- mbpls(Sensory ~ Chemical + Compression, data=potato, ncomp = 5)
print(mb)

# Convert data.frame with AsIs objects to list of matrices
potatoList &lt;- lapply(potato, unclass)
mbr &lt;- mbrda(Sensory ~ Chemical + Compression, data=potatoList, ncomp = 10)
print(mbr)
scoreplot(mbr, labels="names")

</code></pre>

<hr>
<h2 id='unique_combos'>Unique combinations of blocks</h2><span id='topic+unique_combos'></span>

<h3>Description</h3>

<p>Compute a list of all possible block combinations where
the number of blocks in each combination is limited by parameters
<code>min_level</code> and <code>max_level</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>unique_combos(n_block, max_level, min_level = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="unique_combos_+3A_n_block">n_block</code></td>
<td>
<p><code>integer</code> number of input blocks.</p>
</td></tr>
<tr><td><code id="unique_combos_+3A_max_level">max_level</code></td>
<td>
<p><code>integer</code> maximum number of blocks per combination.</p>
</td></tr>
<tr><td><code id="unique_combos_+3A_min_level">min_level</code></td>
<td>
<p><code>integer</code> minimum number of blocks per combination.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is used for minimal redundancy implementations of
<code><a href="#topic+rosa">rosa</a></code> and <code><a href="#topic+sopls">sopls</a></code> and for lookups into computed
components.
</p>


<h3>Value</h3>

<p>A list of unique block combinations.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>unique_combos(3, 2)

</code></pre>

<hr>
<h2 id='unsupervised'>Unsupervised Multiblock Methods</h2><span id='topic+unsupervised'></span>

<h3>Description</h3>

<p>Collection of unsupervised multiblock methods:
</p>

<ul>
<li><p> SCA - Simultaneous Component Analysis (<code><a href="#topic+sca">sca</a></code>)
</p>
</li>
<li><p> GCA - Generalized Canonical Analysis (<code><a href="#topic+gca">gca</a></code>)
</p>
</li>
<li><p> GPA - Generalized Procrustes Analysis (<code><a href="#topic+gpa">gpa</a></code>)
</p>
</li>
<li><p> MFA - Multiple Factor Analysis (<code><a href="#topic+mfa">mfa</a></code>)
</p>
</li>
<li><p> PCA-GCA (<code><a href="#topic+pcagca">pcagca</a></code>)
</p>
</li>
<li><p> DISCO - Distinctive and Common Components with SCA (<code><a href="#topic+disco">disco</a></code>)
</p>
</li>
<li><p> HPCA - Hierarchical Principal component analysis (<code><a href="#topic+hpca">hpca</a></code>)
</p>
</li>
<li><p> MCOA - Multiple Co-Inertia Analysis (<code><a href="#topic+mcoa">mcoa</a></code>)
</p>
</li>
<li><p> JIVE - Joint and Individual Variation Explained (<code><a href="#topic+jive">jive</a></code>)
</p>
</li>
<li><p> STATIS - Structuration des Tableaux à Trois Indices de la Statistique (<code><a href="#topic+statis">statis</a></code>)
</p>
</li>
<li><p> HOGSVD - Higher Order Generalized SVD (<code><a href="#topic+hogsvd">hogsvd</a></code>)
</p>
</li></ul>



<h3>Details</h3>

<p>Original documentation of STATIS: <a href="ade4.html#topic+statis">statis</a>.
JIVE, STATIS and HOGSVD assume variable linked matrices/data.frames, while SCA handles both links.
</p>


<h3>See Also</h3>

<p>Overviews of available methods, <code><a href="#topic+multiblock">multiblock</a></code>, and methods organised by main structure: <code><a href="#topic+basic">basic</a></code>, <code><a href="#topic+unsupervised">unsupervised</a></code>, <code><a href="#topic+asca">asca</a></code>, <code><a href="#topic+supervised">supervised</a></code> and <code><a href="#topic+complex">complex</a></code>.
Common functions for computation and extraction of results and plotting are found in <code><a href="#topic+multiblock_results">multiblock_results</a></code> and <code><a href="#topic+multiblock_plots">multiblock_plots</a></code>, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Object linked data
data(potato)
potList &lt;- as.list(potato[c(1,2,9)])
pot.sca    &lt;- sca(potList)

# Variable linked data
data(candies)
candyList &lt;- lapply(1:nlevels(candies$candy),function(x)candies$assessment[candies$candy==x,])
can.statis &lt;- statis(candyList)
plot(can.statis$statis)
</code></pre>

<hr>
<h2 id='wine'>Wines of Val de Loire</h2><span id='topic+wine'></span>

<h3>Description</h3>

<p>This dataset contains sensory assessment of 21 wines. The assessments are grouped
according to the tasting process and thus have a natural ordering with a all blocks pointing forward
to all remaining blocks in the process.
</p>
<p><img src="../help/figures/wine.png" alt="Path-diagram for wine data" />
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(wine)
</code></pre>


<h3>Format</h3>

<p>A data.frame having 21 rows and 5 variables:
</p>

<dl>
<dt>Smell at rest</dt><dd><p>Matrix of sensory assessments</p>
</dd>
<dt>View</dt><dd><p>Matrix of sensory assessments</p>
</dd>
<dt>Smell after shaking</dt><dd><p>Matrix of sensory assessments</p>
</dd>
<dt>Tasting</dt><dd><p>Matrix of sensory assessments</p>
</dd>
<dt>Global quality</dt><dd><p>Matrix of sensory assessments</p>
</dd>
</dl>



<h3>References</h3>

<p>Escofier B, Pages L. Analyses Factorielles Simples and Multiples. Paris: Dunod; 1988.
</p>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
