<!DOCTYPE html><html><head><title>Help for package adfExplorer</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {adfExplorer}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adfExplorer-package'><p>adfExplorer: Import from and Export to Amiga Disk Files</p></a></li>
<li><a href='#adf.disk.name'><p>Get or set the disk name of an amigaDisk object</p></a></li>
<li><a href='#adf.example'><p>An example of an amigaDisk object</p></a></li>
<li><a href='#adf.file.exists'><p>Test file or directory existence in an amigaDisk object</p></a></li>
<li><a href='#adf.file.info'><p>File information on virtual amigaDisk objects</p></a></li>
<li><a href='#adf.file.remove'><p>Remove a file from an amigaDisk object</p></a></li>
<li><a href='#amigaBlock-class'><p>The amigaBlock class</p></a></li>
<li><a href='#amigaBlock-method'><p>Extract block from or replace a block on an amigaDisk object</p></a></li>
<li><a href='#amigaDateToRaw'><p>Convert date time objects into raw values</p></a></li>
<li><a href='#amigaDisk-class'><p>The amigaDisk class</p></a></li>
<li><a href='#amigaIntToRaw'><p>Convert Amiga integers into raw values</p></a></li>
<li><a href='#blank.amigaDOSDisk'><p>Create blank disk with file system</p></a></li>
<li><a href='#boot.block.code'><p>Minimal executable code for a bootblock</p></a></li>
<li><a href='#current.adf.dir'><p>Get or set the current directory of an amigaDisk object</p></a></li>
<li><a href='#dir.create.adf'><p>Create a directory on an amigaDisk object</p></a></li>
<li><a href='#displayRawData'><p>Display raw data in a comprehensive way</p></a></li>
<li><a href='#get.adf.file'><p>Get a file from an amigaDisk object</p></a></li>
<li><a href='#get.blockID'><p>Get the block ID from the physical location on the disk</p></a></li>
<li><a href='#get.diskLocation'><p>Get the physical location on the disk for a specific block</p></a></li>
<li><a href='#is.amigaDOS'><p>Check if amigaDisk object is DOS formatted</p></a></li>
<li><a href='#is.bootable'><p>Check if amigaDisk object is bootable</p></a></li>
<li><a href='#list.adf.files'><p>List files in an amigaDisk directory</p></a></li>
<li><a href='#print'><p>Print Amiga Disk File objects</p></a></li>
<li><a href='#put.adf.file'><p>Put a file onto an amigaDisk object</p></a></li>
<li><a href='#rawToAmigaDate'><p>Convert raw values into a date time object</p></a></li>
<li><a href='#rawToAmigaInt'><p>Convert raw values into Amiga integers</p></a></li>
<li><a href='#rawToBitmap'><p>Convert raw data into a bitmap or vice versa</p></a></li>
<li><a href='#read.adf'><p>Read an Amiga Disk File</p></a></li>
<li><a href='#write.adf'><p>Write an amigaDisk object to an ADF file</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Import from and Export to Amiga Disk Files</td>
</tr>
<tr>
<td>Version:</td>
<td>0.1.8</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-03-06</td>
</tr>
<tr>
<td>Author:</td>
<td>Pepijn de Vries [aut, cre, dtc]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pepijn de Vries &lt;pepijn.devries@outlook.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Amiga Disk Files (ADF) are virtual
    representations of 3.5 inch floppy disks for the
    Commodore Amiga. Most disk drives from other systems
    (including modern drives) are not able to read these
    disks. To be able to emulate this system, the ADF
    format was created. This package enables you to read
    ADF files and import and export files from and to such
    virtual DOS-formatted disks.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, ProTrackR</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/pepijn-devries/adfExplorer">https://github.com/pepijn-devries/adfExplorer</a>,
<a href="https://pepijn-devries.github.io/adfExplorer/">https://pepijn-devries.github.io/adfExplorer/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/pepijn-devries/adfExplorer/issues">https://github.com/pepijn-devries/adfExplorer/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>True</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-05 23:20:40 UTC; vries171</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-06 01:00:15 UTC</td>
</tr>
</table>
<hr>
<h2 id='adfExplorer-package'>adfExplorer: Import from and Export to Amiga Disk Files</h2><span id='topic+adfExplorer'></span><span id='topic+adfExplorer-package'></span>

<h3>Description</h3>

<p>Amiga Disk Files (ADF) are virtual representations of 3.5 inch floppy disks for the Commodore Amiga. Most disk drives from other systems (including modern drives) are not able to read these disks. To be able to emulate this system, the ADF format was created. This package enables you to read ADF files and import and export files from and to such virtual DOS-formatted disks.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Pepijn de Vries <a href="mailto:pepijn.devries@outlook.com">pepijn.devries@outlook.com</a> [data contributor]
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/pepijn-devries/adfExplorer">https://github.com/pepijn-devries/adfExplorer</a>
</p>
</li>
<li> <p><a href="https://pepijn-devries.github.io/adfExplorer/">https://pepijn-devries.github.io/adfExplorer/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/pepijn-devries/adfExplorer/issues">https://github.com/pepijn-devries/adfExplorer/issues</a>
</p>
</li></ul>


<hr>
<h2 id='adf.disk.name'>Get or set the disk name of an amigaDisk object</h2><span id='topic+adf.disk.name'></span><span id='topic+adf.disk.name+2CamigaDisk-method'></span><span id='topic+adf.disk.name+3C-'></span><span id='topic+adf.disk.name+3C-+2CamigaDisk+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Get or set the disk name of an <code><a href="#topic+amigaDisk">amigaDisk</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'amigaDisk'
adf.disk.name(x)

## S4 replacement method for signature 'amigaDisk,character'
adf.disk.name(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adf.disk.name_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+amigaDisk">amigaDisk</a></code> object for which the disk
name needs to be obtained or changed.</p>
</td></tr>
<tr><td><code id="adf.disk.name_+3A_value">value</code></td>
<td>
<p>A <code>character</code> representation with which the
disk's name needs to be replaced. Disk name needs to be between
1 and 30 characters long and are not allowed to contain a colon
or forward slash.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>DOS-formatted disks (<code><a href="#topic+is.amigaDOS">is.amigaDOS</a></code>) store their disk
name on the socalled root block of the disk. This method allows
you to obtain the disk's name or change it (when it is DOS-formatted).
</p>


<h3>Value</h3>

<p>Returns A <code>character</code> representation of the disk's
name.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(adf.example)

## get the disk name:
adf.disk.name(adf.example)

## change it if you don't like it:
adf.disk.name(adf.example) &lt;- "MyDisk"

## confirm that it has changed:
adf.disk.name(adf.example)

## End(Not run)
</code></pre>

<hr>
<h2 id='adf.example'>An example of an amigaDisk object</h2><span id='topic+adf.example'></span>

<h3>Description</h3>

<p>An example of an <code><a href="#topic+amigaDisk-class">amigaDisk</a></code> object.
</p>


<h3>Format</h3>

<p>An S4 <code><a href="#topic+amigaDisk-class">amigaDisk</a></code> object.
</p>


<h3>Details</h3>

<p>An <code><a href="#topic+amigaDisk-class">amigaDisk</a></code> object that represents an
'Old File System' formatted and bootable disk. It is used in
multiple examples of this package. It contains a directory
structure and some files that can be accessed using this package.
The content of this example might change in future versions.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("adf.example")
</code></pre>

<hr>
<h2 id='adf.file.exists'>Test file or directory existence in an amigaDisk object</h2><span id='topic+adf.file.exists'></span><span id='topic+adf.file.exists+2CamigaDisk+2Ccharacter-method'></span><span id='topic+dir.exists.adf'></span><span id='topic+dir.exists.adf+2CamigaDisk+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Tests whether a specific file (or directory) exists in an
<code><a href="#topic+amigaDisk">amigaDisk</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'amigaDisk,character'
adf.file.exists(x, file)

## S4 method for signature 'amigaDisk,character'
dir.exists.adf(x, path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adf.file.exists_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+amigaDisk">amigaDisk</a></code> object in which this method
will check for the file's existence.</p>
</td></tr>
<tr><td><code id="adf.file.exists_+3A_file">file</code></td>
<td>
<p>A (<code>vector</code> of) <code>character</code> string(s) representing a file or directory name.
Use Amiga specifications for file name (see <code><a href="#topic+current.adf.dir">current.adf.dir</a></code>). Wildcards are not allowed.</p>
</td></tr>
<tr><td><code id="adf.file.exists_+3A_path">path</code></td>
<td>
<p>file A (<code>vector</code> of) <code>character</code> string(s) representing a directory name.
Use Amiga specifications for the path name (see <code><a href="#topic+current.adf.dir">current.adf.dir</a></code>). Wildcards are not allowed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method will look for a file/directory header, based on its name.
If such a header exists, it is assumed that the file exists. The
file/directory itself is not checked for validity.
</p>


<h3>Value</h3>

<p>Returns a <code>logical</code> value indicating whether the file exists
or not. In case of <code>dir.exists.adf</code> the path needs to exist and it needs to be a directory in order
to return <code>TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(adf.example)

## This file exists:
adf.file.exists(adf.example, "df0:mods/mod.intro")

## But it doesn't exist as a directory
dir.exists.adf(adf.example, "df0:mods/mod.intro")

## This file also doesn't:
adf.file.exists(adf.example, "df0:idontexist")
</code></pre>

<hr>
<h2 id='adf.file.info'>File information on virtual amigaDisk objects</h2><span id='topic+adf.file.info'></span><span id='topic+adf.file.info+2CamigaDisk+2Ccharacter-method'></span><span id='topic+adf.file.mode'></span><span id='topic+adf.file.mode+2CamigaDisk+2Ccharacter-method'></span><span id='topic+adf.file.mode+3C-'></span><span id='topic+adf.file.mode+3C-+2CamigaDisk+2Ccharacter+2Ccharacter-method'></span><span id='topic+adf.file.mode+3C-+2CamigaDisk+2Ccharacter+2Clogical-method'></span><span id='topic+adf.file.time'></span><span id='topic+adf.file.time+2CamigaDisk+2Ccharacter+2Cmissing-method'></span><span id='topic+adf.file.time+2CamigaDisk+2Ccharacter+2Ccharacter-method'></span><span id='topic+adf.file.time+3C-'></span><span id='topic+adf.file.time+3C-+2CamigaDisk+2Ccharacter+2Cmissing+2CPOSIXt-method'></span><span id='topic+adf.file.time+3C-+2CamigaDisk+2Ccharacter+2Ccharacter+2CPOSIXt-method'></span><span id='topic+adf.file.size'></span><span id='topic+adf.file.size+2CamigaDisk+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Obtain file information of file from a virtual <code><a href="#topic+amigaDisk">amigaDisk</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'amigaDisk,character'
adf.file.info(x, path)

## S4 method for signature 'amigaDisk,character'
adf.file.mode(x, path)

## S4 replacement method for signature 'amigaDisk,character,character'
adf.file.mode(x, path) &lt;- value

## S4 replacement method for signature 'amigaDisk,character,logical'
adf.file.mode(x, path) &lt;- value

## S4 method for signature 'amigaDisk,character,missing'
adf.file.time(x, path, which)

## S4 method for signature 'amigaDisk,character,character'
adf.file.time(x, path, which = c("m", "c", "a"))

## S4 replacement method for signature 'amigaDisk,character,missing,POSIXt'
adf.file.time(x, path, which) &lt;- value

## S4 replacement method for signature 'amigaDisk,character,character,POSIXt'
adf.file.time(x, path, which = c("m", "c", "a")) &lt;- value

## S4 method for signature 'amigaDisk,character'
adf.file.size(x, path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adf.file.info_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+amigaDisk">amigaDisk</a></code> object in which this method
will obtain file information.</p>
</td></tr>
<tr><td><code id="adf.file.info_+3A_path">path</code></td>
<td>
<p>A (<code>vector</code> of) <code>character</code> string(s) representing a file or directory name.
Use Amiga specifications for file name (see <code><a href="#topic+current.adf.dir">current.adf.dir</a></code>). Wildcards are not allowed.</p>
</td></tr>
<tr><td><code id="adf.file.info_+3A_value">value</code></td>
<td>
<p>In case of <code>adf.file.time</code> an object of class <code><a href="base.html#topic+DateTimeClasses">base::POSIXt</a></code>.
In case of <code>adf.file.mode</code> either a character string representing the flags,
or a <code>vector</code> of named <code>logical</code> values, where the name of the <code>logical</code>
represents the flag to be altered (see also details).</p>
</td></tr>
<tr><td><code id="adf.file.info_+3A_which">which</code></td>
<td>
<p>Character indicating which time to obtain/modify. One of
<code>"m"</code> (date modified), <code>"c"</code> (date created), or <code>"a"</code> (date root modification).
This parameter works only on the disk's root and will be ignored for any
other directory or file.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use <code>adf.file.mode</code> to obtain or set a <code>character</code> string reflecting which
file mode flags are set, where:
</p>

<ul>
<li> <p><code>D</code>: deletable
</p>
</li>
<li> <p><code>E</code>: executable
</p>
</li>
<li> <p><code>W</code>: writeable
</p>
</li>
<li> <p><code>R</code>: readable
</p>
</li>
<li> <p><code>A</code>: archived
</p>
</li>
<li> <p><code>P</code>: pure command
</p>
</li>
<li> <p><code>S</code>: script
</p>
</li>
<li> <p><code>H</code>: hold
</p>
</li>
<li><p> starting without lower case: applies to user
</p>
</li>
<li><p> starting with lower case <code>g</code>: applies to group
</p>
</li>
<li><p> starting with lower case <code>o</code>: applies to other
</p>
</li></ul>

<p>Use <code>adf.file.time</code> to obtain or set the <a href="base.html#topic+DateTimeClasses">base::POSIXt</a> properties of
a file on an <code><a href="#topic+amigaDisk">amigaDisk</a></code>.
</p>
<p>Use <code>adf.file.info</code> to obtain a combination of the information
listed above in a <code>data.frame</code>.
</p>


<h3>Value</h3>

<p>In case of the replace methods, an <code><a href="#topic+amigaDisk">amigaDisk</a></code> class object is returned with the file
information updated. Otherwise, it will return the requested file information (see also details).
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(adf.example)

adf.file.mode(adf.example,  c("mods", "mods/mod.intro"))
adf.file.time(adf.example, c("mods", "mods/mod.intro"))
adf.file.size(adf.example,  c("mods", "mods/mod.intro"))
adf.file.info(adf.example,  c("mods", "mods/mod.intro"))

## set the writeable flag for a group to TRUE
adf.file.mode(adf.example, "mods/mod.intro") &lt;- c(gW = T)

## Set the modified time-stamp to the current system time
adf.file.time(adf.example, "mods/mod.intro") &lt;- Sys.time()

## End(Not run)
</code></pre>

<hr>
<h2 id='adf.file.remove'>Remove a file from an amigaDisk object</h2><span id='topic+adf.file.remove'></span><span id='topic+adf.file.remove+2CamigaDisk+2Ccharacter+2Clogical-method'></span><span id='topic+adf.file.remove+2CamigaDisk+2Ccharacter+2Cmissing-method'></span>

<h3>Description</h3>

<p>Remove a file from a virtual Amiga floppy disk represented by
an <code><a href="#topic+amigaDisk">amigaDisk</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'amigaDisk,character,logical'
adf.file.remove(x, file, full)

## S4 method for signature 'amigaDisk,character,missing'
adf.file.remove(x, file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="adf.file.remove_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+amigaDisk">amigaDisk</a></code> onto which the file should be put.</p>
</td></tr>
<tr><td><code id="adf.file.remove_+3A_file">file</code></td>
<td>
<p>A <code>character</code> string of the path on the virtual floppy of the file that should be removed.
The path should be conform Amiga specs (see <code><a href="#topic+current.adf.dir">current.adf.dir</a></code>). Wild cards are not allowed (see details).
Both files and directories can be removed from the virtual disk using this function.</p>
</td></tr>
<tr><td><code id="adf.file.remove_+3A_full">full</code></td>
<td>
<p>A <code>logical</code> value (default is <code>FALSE</code>). When set to <code>TRUE</code> not only pointers to
the <code>file</code> are removed, but also the data in the header and data blocks. When set to <code>FALSE</code>,
the data is left as orphans on the disk. Technically, these files can be undeleted, unless they are overwritten.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Remove a file from a virtual Amiga floppy disk (represented by an <code><a href="#topic+amigaDisk">amigaDisk</a></code> object.
Make sure that the virtual disk is DOS formatted (see <code><a href="#topic+is.amigaDOS">is.amigaDOS</a></code>). This method can only remove one file at
a time from a virtual virtual disk, it is not allowed to use wild cards in the source or destination names.
It is possible to remove an entire directory at once. Use loops to remove multiple files/directories from a virtual
disk.
</p>


<h3>Value</h3>

<p>Returns an <code><a href="#topic+amigaDisk">amigaDisk</a></code> object where the
specified <code>file</code> is removed.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## This removes a single file from a disk
resulting.disk &lt;- adf.file.remove(adf.example, "df0:mods/mod.intro")

## This removes the entire 's' directory and cannot be undone:
resulting.disk &lt;- adf.file.remove(adf.example, "df0:s", TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='amigaBlock-class'>The amigaBlock class</h2><span id='topic+amigaBlock-class'></span><span id='topic+amigaBlock'></span>

<h3>Description</h3>

<p>The Commodore Amiga stores data on floppy disks as 512 byte blocks.
This class reflects such a block.
</p>


<h3>Details</h3>

<p>There are several types of blocks. Most important are the boot block
(used for booting the Amiga system), the root block (containing information
on the disk and the root directory), header blocks (indicating where to
find file data) and data blocks (containing the actual file data). See
this package's vignette (<code>vignette("amigaDiskFiles")</code>) for more
details. use the <code><a href="#topic+amigaBlock-method">amigaBlock-method</a></code> to extract a specific
block from an <code><a href="#topic+amigaDisk">amigaDisk</a></code> object.
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code></dt><dd><p>The <code>raw</code> data of a 'block' of data on
an Amiga disk file. Each block holds 512 bytes of information.
This slot is therefore a <code>vector</code> of the same length.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create a block with no data:
new("amigaBlock")
</code></pre>

<hr>
<h2 id='amigaBlock-method'>Extract block from or replace a block on an amigaDisk object</h2><span id='topic+amigaBlock-method'></span><span id='topic+amigaBlock+2CamigaDisk+2Cnumeric-method'></span><span id='topic+amigaBlock+3C-'></span><span id='topic+amigaBlock+3C-+2CamigaDisk+2Cnumeric+2CamigaBlock-method'></span>

<h3>Description</h3>

<p>Extract an <code><a href="#topic+amigaBlock">amigaBlock</a></code> from an <code><a href="#topic+amigaDisk">amigaDisk</a></code> object,
or replace it on the disk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'amigaDisk,numeric'
amigaBlock(x, block)

## S4 replacement method for signature 'amigaDisk,numeric,amigaBlock'
amigaBlock(x, block) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="amigaBlock-method_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+amigaDisk">amigaDisk</a></code> object from which the block needs to
be extracted or on which the block needs to be replaced.</p>
</td></tr>
<tr><td><code id="amigaBlock-method_+3A_block">block</code></td>
<td>
<p>A <code>numeric</code> identifier (whole numbers
ranging from 0 up to 1759 (DD disk) or 3519 (HD disk)).</p>
</td></tr>
<tr><td><code id="amigaBlock-method_+3A_value">value</code></td>
<td>
<p>An <code><a href="#topic+amigaBlock">amigaBlock</a></code> object with which the block
at the specified location on the disk needs to be replaced.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Information is stored in 512 byte blocks on floppy disks. This method
extracts a specific block at a <code>numeric</code> identifier (whole numbers
ranging from 0 up to 1759 (DD disk) or 3519 (HD disk)) from an
<code><a href="#topic+amigaDisk">amigaDisk</a></code> object.
</p>


<h3>Value</h3>

<p>The <code><a href="#topic+amigaBlock">amigaBlock</a></code> object at the specified location
is returned. In case of the replace method, an <code><a href="#topic+amigaDisk">amigaDisk</a></code>
object with a replaced <code><a href="#topic+amigaBlock">amigaBlock</a></code> is returned.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other block.operations: 
<code><a href="#topic+get.blockID">get.blockID</a>()</code>,
<code><a href="#topic+get.diskLocation">get.diskLocation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## get the root block from the example adf:
amigaBlock(adf.example, 880)

## Create a completely blank disk without file system:
blank.disk &lt;- new("amigaDisk")

## Replace the boot block on the blank disk with
## that from the example object:
amigaBlock(blank.disk, 0) &lt;- amigaBlock(adf.example, 0)

## The blank disk now has a boot block,
## but still no file system...
</code></pre>

<hr>
<h2 id='amigaDateToRaw'>Convert date time objects into raw values</h2><span id='topic+amigaDateToRaw'></span>

<h3>Description</h3>

<p>This function converts date-time objects into raw data conform
Amiga file system specifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>amigaDateToRaw(x, format = c("long", "short"), tz = "UTC")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="amigaDateToRaw_+3A_x">x</code></td>
<td>
<p>A (<code>vector</code> of) <code><a href="base.html#topic+DateTimeClasses">POSIXt</a></code> object(s).</p>
</td></tr>
<tr><td><code id="amigaDateToRaw_+3A_format">format</code></td>
<td>
<p>a <code>character</code> string indicating whether the date
should be stored as <code>short</code> or <code>long</code> integers.</p>
</td></tr>
<tr><td><code id="amigaDateToRaw_+3A_tz">tz</code></td>
<td>
<p>A <code>character</code> string specifying the time zone to be used
to convert the date time object. Note that the time zone is not stored
on the Amiga. By default the Universal time zone (UTC) is assumed.
You will get a warning when you use a timezone other then UTC.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Amiga file system stores date time objects as three unsigned
short (16 bit) or long (32 bit) integers. Where the values are
number of days, minutes and ticks (fiftieth of a second) since
1978-01-01 respectively.
</p>
<p>As these values are always positive, only date time values on or after
1978-01-01 are allowed. The inverse of this function can be achieved
with <code><a href="#topic+rawToAmigaDate">rawToAmigaDate</a></code>.
</p>


<h3>Value</h3>

<p>returns <code>raw</code> data reflecting the date-time objects conform
the Amiga file system specifications.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other raw.operations: 
<code><a href="#topic+amigaIntToRaw">amigaIntToRaw</a>()</code>,
<code><a href="#topic+displayRawData">displayRawData</a>()</code>,
<code><a href="#topic+rawToAmigaDate">rawToAmigaDate</a>()</code>,
<code><a href="#topic+rawToAmigaInt">rawToAmigaInt</a>()</code>,
<code><a href="#topic+rawToBitmap">rawToBitmap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Note that using the same date-time with different timezones will
## result in different raw data. The time zone is not stored.
amigaDateToRaw(as.POSIXct("1978-01-01 13:30", tz = "UTC"))
amigaDateToRaw(as.POSIXct("1978-01-01 13:30", tz = "CET"))
</code></pre>

<hr>
<h2 id='amigaDisk-class'>The amigaDisk class</h2><span id='topic+amigaDisk-class'></span><span id='topic+amigaDisk'></span>

<h3>Description</h3>

<p>An S4 class representing the information from an Amiga Disk File.
</p>


<h3>Details</h3>

<p>An Amiga Disk File (ADF) holds the raw data of an Amiga disk
in the same order as blocks (<code><a href="#topic+amigaBlock-class">amigaBlock</a></code>)
on the physical disks. As an Amiga
Disk can hold any kind of information, so can this class.
</p>
<p>An ADF file does not hold any other information. The size of
the file will dictate whether it represents a double density
floppy disk (880 kB) or a high density floppy disk (1760 kB).
The disk type is also stored in this class.
</p>
<p>Finally, the current directory is stored with this class. Which
is only useful for DOS-formatted disks (with a file structure).
By default this is set to the disk's root.
</p>
<p>For more (technical) backgrounds please check this package's vignette
(<code>vignette("amigaDiskFiles")</code>)
</p>
<p>Use the objects constructor (<code>new("amigaDisk")</code>) to create
a completely blank disk (without a filesystem). If you want to be
able to transfer files from and to the virtual disk, use
<code><a href="#topic+blank.amigaDOSDisk">blank.amigaDOSDisk</a></code> instead.
</p>


<h3>Slots</h3>


<dl>
<dt><code>data</code></dt><dd><p>The <code>raw</code> data of the virtual disk. It should be
a <code>vector</code> of length 901,120 in case of a double density disk and
1,802,240 in case of a high density disk.</p>
</dd>
<dt><code>type</code></dt><dd><p>A <code>character</code> indicating whether the virtual disk
represents a <code>"DD"</code> (double density, most common) or <code>"HD"</code> (high density)
disk.</p>
</dd>
<dt><code>current.dir</code></dt><dd><p>An <code>integer</code>, pointing at the block address
of the current directory of this virtual disk. Use
<code><a href="#topic+current.adf.dir">current.adf.dir</a></code> to get or set the current directory.</p>
</dd>
</dl>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## This creates a blank non-bootable, non-DOS disk:
new("amigaDisk")
</code></pre>

<hr>
<h2 id='amigaIntToRaw'>Convert Amiga integers into raw values</h2><span id='topic+amigaIntToRaw'></span>

<h3>Description</h3>

<p>Convert 8, 16, or 32-bit signed or unsigned
integer values into raw data, conform Amiga specifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>amigaIntToRaw(x, bits = 8, signed = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="amigaIntToRaw_+3A_x">x</code></td>
<td>
<p>A vector of class <code>numeric</code> which needs to be converted into raw values.</p>
</td></tr>
<tr><td><code id="amigaIntToRaw_+3A_bits">bits</code></td>
<td>
<p>Number of bits that represents the integer value. Should be 8 or a
positive multitude of 8.</p>
</td></tr>
<tr><td><code id="amigaIntToRaw_+3A_signed">signed</code></td>
<td>
<p>A <code>logical</code> value indicating whether the numeric values
is signed (<code>TRUE</code>, default) or not (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Commodore Amiga has specified the following data formats
to represent integer data: BYTE (signed 8-bit integer), UBYTE
(unsigned 8-bit integer), WORD (signed 16-bit integer), UWORD
(unsigned 16-bit integer), LONG (signed 32-bit integer), ULONG,
(unsigned 32-bit integer). This function converts
such integers into raw data.
</p>


<h3>Value</h3>

<p>Returns (a <code>vector</code> of) <code>raw</code> data, representing
the integer value(s) conform Amiga specifications.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other raw.operations: 
<code><a href="#topic+amigaDateToRaw">amigaDateToRaw</a>()</code>,
<code><a href="#topic+displayRawData">displayRawData</a>()</code>,
<code><a href="#topic+rawToAmigaDate">rawToAmigaDate</a>()</code>,
<code><a href="#topic+rawToAmigaInt">rawToAmigaInt</a>()</code>,
<code><a href="#topic+rawToBitmap">rawToBitmap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## some unsigned 8-bit integers:
ubyte &lt;- sample.int(255, 100, TRUE)

## The same values as raw data:
amigaIntToRaw(ubyte)

## some signed 8-bit integers:
byte &lt;- sample.int(255, 100, TRUE) - 128

## The same values as raw data:
amigaIntToRaw(byte, signed = TRUE)

## some signed 16-bit integers:
word &lt;- sample.int(2^16, 100, TRUE) - 2^15

## The same values as raw data:
amigaIntToRaw(word, 16, TRUE)

## note that 16-bit integers require
## twice as many raw values:
length(amigaIntToRaw(word, 16, TRUE))
length(amigaIntToRaw(byte, 8, TRUE))
</code></pre>

<hr>
<h2 id='blank.amigaDOSDisk'>Create blank disk with file system</h2><span id='topic+blank.amigaDOSDisk'></span><span id='topic+blank.amigaDOSDisk+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Create a virtual blank DOS formatted floppy disk with a file system on it.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'character'
blank.amigaDOSDisk(
  diskname,
  disktype = c("DD", "HD"),
  filesystem = c("OFS", "FFS"),
  international = F,
  dir.cache = F,
  bootable = T,
  creation.date = Sys.time()
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="blank.amigaDOSDisk_+3A_diskname">diskname</code></td>
<td>
<p>A <code>character</code> string of the desired disk name.
Disk name should be between 1 and 30 characters long, and should
not contain any colon or forward slash characters.</p>
</td></tr>
<tr><td><code id="blank.amigaDOSDisk_+3A_disktype">disktype</code></td>
<td>
<p>Either &quot;<code>DD</code>&quot; (double density, most common and
therefore default) or &quot;<code>HD</code>&quot; (high denisity). The type of disk
the blank disk should represent.</p>
</td></tr>
<tr><td><code id="blank.amigaDOSDisk_+3A_filesystem">filesystem</code></td>
<td>
<p>Either &quot;<code>OFS</code>&quot; (old file system) or &quot;<code>FFS</code>&quot;
(fast file system). <code>FFS</code> is not compatible with Amiga OS &lt;2.0.
On the original system, the FFS was slightly faster and can requires
less data for the file system. It is however less robust: on corrupt
disks, file recovery is more difficult.</p>
</td></tr>
<tr><td><code id="blank.amigaDOSDisk_+3A_international">international</code></td>
<td>
<p>The international mode was introduced in Amiga
OS 2.0. In lower versions, international characters were mistakenly
not converted to uppercase when comparing file names. The international
mode (set this argument to <code>TRUE</code>) corrects this mistake.
The international mode is not compatible with Amiga OS &lt;2.0.</p>
</td></tr>
<tr><td><code id="blank.amigaDOSDisk_+3A_dir.cache">dir.cache</code></td>
<td>
<p>The directory cache mode (set this argument to
<code>TRUE</code>) was introduced with Amiga OS 3.0 (and is not compatible
with lower versions). On real machines this allowed for slightly faster
directory listing (but costs disk space). The directory cache mode is
always used in combination with the 'international mode'.</p>
</td></tr>
<tr><td><code id="blank.amigaDOSDisk_+3A_bootable">bootable</code></td>
<td>
<p>When this argument is set to <code>TRUE</code>. Minimal
executable code is added to the bootblock. This code will open the
command line interface when the disk is used to boot the system. In
Amiga OS &gt;2.0, the 'Startup-Sequence' file needs to be present
for this, otherwise the screen will remain black on booting. See also the
<code><a href="#topic+boot.block.code">boot.block.code</a></code> data.</p>
</td></tr>
<tr><td><code id="blank.amigaDOSDisk_+3A_creation.date">creation.date</code></td>
<td>
<p>A <code><a href="base.html#topic+DateTimeClasses">POSIXt</a></code> object. Will be used
and stored as the creation date of the virtual disk. Note that the Amiga
does not store the time zone and UTC is assumed as default. The Amiga
stores the date and time as positive integers, relative to 1st of
January in 1978. As a result, dates before that are not allowed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Creates a blank <code><a href="#topic+amigaDisk">amigaDisk</a></code> object. This method differs
from the object constructor (<code>new("amigaDisk")</code>) because it also
installs a file system on the disk. The blank disk can thus be used to
write files onto, and is also usable in Amiga emulators. For use in
emulators, the object needs to be saved with the <code><a href="#topic+write.adf">write.adf</a></code>
method.
</p>


<h3>Value</h3>

<p>Returns a blank <code><a href="#topic+amigaDisk">amigaDisk</a></code> object with a file
system installed on it.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create a blank virtual disk compatible with
## Amiga OS 1.x and up (Note that spaces in file and
## disk names are allowed but not recommended):
disk.os1x &lt;- blank.amigaDOSDisk(diskname = "I'm_OS_1.x_compatible",
                                disktype = "DD",
                                filesystem = "OFS",
                                international = FALSE,
                                dir.cache = FALSE,
                                bootable = TRUE)

## create a disk that is compatible with OS 2.x and up
## (no backward compatibility):
disk.os2x &lt;- blank.amigaDOSDisk(diskname = "I'm_OS_2.x_compatible",
                                disktype = "DD",
                                filesystem = "FFS",
                                international = TRUE,
                                dir.cache = FALSE,
                                bootable = TRUE)

## create a disk that is compatible with OS 3.x and up
## (no backward compatibility):
disk.os3x &lt;- blank.amigaDOSDisk(diskname = "I'm_OS_3.x_compatible",
                                disktype = "DD",
                                filesystem = "FFS",
                                international = TRUE,
                                dir.cache = TRUE,
                                bootable = TRUE)
</code></pre>

<hr>
<h2 id='boot.block.code'>Minimal executable code for a bootblock</h2><span id='topic+boot.block.code'></span>

<h3>Description</h3>

<p>A minimal piece of code required to boot to a command line
interface on a Commodore Amiga.
</p>


<h3>Format</h3>

<p>A data frame with two columns. The first column
contains the assembled code (as <code>raw</code> data). The
second column contains the corresponding Motorola 68000
(the main CPU of the original Commodore Amiga) assembly
syntax.
</p>


<h3>Details</h3>

<p>The first two blocks (<code><a href="#topic+amigaDisk">amigaDisk</a></code>) are special and are
called the boot block. This block should contain information on the
type of disk and possibly some executable code that will be run
at boot time. This <code>data.frame</code> contains some minimal executable
code that will start the Amiga command line interface. On Amiga OS
\&gt;=2.0 the screen will stay black unless a startup-sequence file is
present on the disk.
</p>
<p>The original code is from Thomas Kessler as published by Laurent
Cl&eacute;vy
(<a href="http://lclevy.free.fr/adflib/adf_info.html">http://lclevy.free.fr/adflib/adf_info.html</a>).
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("boot.block.code")

## To create a basic boot block for a DD disk:
bblock &lt;- new("amigaBlock", data =
  c(as.raw(c(0x44, 0x4F, 0x53, 0x00, 0xE3, 0x3D, 0x0E, 0x73,
  0x00, 0x00, 0x03, 0x70)), unlist(boot.block.code$assembled),
  raw(419))
)
## The raw data preceding the executable code are
## a label, flags and a checksum.
</code></pre>

<hr>
<h2 id='current.adf.dir'>Get or set the current directory of an amigaDisk object</h2><span id='topic+current.adf.dir'></span><span id='topic+current.adf.dir+2CamigaDisk-method'></span><span id='topic+current.adf.dir+3C-'></span><span id='topic+current.adf.dir+3C-+2CamigaDisk+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Get or set the current directory of an <code><a href="#topic+amigaDisk">amigaDisk</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'amigaDisk'
current.adf.dir(x)

## S4 replacement method for signature 'amigaDisk,character'
current.adf.dir(x) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="current.adf.dir_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+amigaDisk">amigaDisk</a></code> object for which the current
directory needs to be obtained or changed.</p>
</td></tr>
<tr><td><code id="current.adf.dir_+3A_value">value</code></td>
<td>
<p>A <code>character</code> representation of the path, that
needs to be set as current directory. Use Amiga DOS syntax as
specified in the details</p>
</td></tr>
</table>


<h3>Details</h3>

<p>By default the disk's root is stored as the current directory
for a new <code><a href="#topic+amigaDisk">amigaDisk</a></code> object. With this method, the
current directory can be retrieved or changed.
</p>
<p>For this purpose the path should be specified conform Amiga DOS
syntax. Use the disk's name or &quot;DF0&quot; followed by a colon in order
to refer to the disk's root. Subdirectories are separated by forward
slashes (&quot;/&quot;). Colons and forward slashes are not allowed in file and
directory names. Both upper and lowercase letters are allowed in file
and directory names. The case is ignored when identifying files however.
This packages will NOT follow the Amiga's full search path
(<a href="https://wiki.amigaos.net/wiki/AmigaOS_Manual:_AmigaDOS_Working_With_AmigaDOS#Search_Path">https://wiki.amigaos.net/wiki/AmigaOS_Manual:_AmigaDOS_Working_With_AmigaDOS#Search_Path</a>).
</p>


<h3>Value</h3>

<p>Returns a <code>character</code> representation of the current
directory.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(adf.example)

## by default the current dir is the
## disk's root. The disk name is
## therefore shown when running
## current.adf.dir for the provided
## example data:

current.adf.dir(adf.example)

## change the current dir:
current.adf.dir(adf.example) &lt;- "DF0:this/is/a/deep/path"

## confirm that it has changed:
current.adf.dir(adf.example)

## let's set it back to the disk's root:
current.adf.dir(adf.example) &lt;- "DF0:"
</code></pre>

<hr>
<h2 id='dir.create.adf'>Create a directory on an amigaDisk object</h2><span id='topic+dir.create.adf'></span><span id='topic+dir.create.adf+2CamigaDisk+2Ccharacter+2Cmissing+2Cmissing-method'></span><span id='topic+dir.create.adf+2CamigaDisk+2Ccharacter+2CPOSIXt+2Cmissing-method'></span><span id='topic+dir.create.adf+2CamigaDisk+2Ccharacter+2CPOSIXt+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Create a directory on a virtual Amiga floppy disk represented by
an <code><a href="#topic+amigaDisk">amigaDisk</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'amigaDisk,character,missing,missing'
dir.create.adf(x, path, date, comment)

## S4 method for signature 'amigaDisk,character,POSIXt,missing'
dir.create.adf(x, path, date, comment)

## S4 method for signature 'amigaDisk,character,POSIXt,character'
dir.create.adf(x, path, date, comment)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dir.create.adf_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+amigaDisk">amigaDisk</a></code> on which the directory should be created.</p>
</td></tr>
<tr><td><code id="dir.create.adf_+3A_path">path</code></td>
<td>
<p>Specify the directory that should be created on <code>x</code>.
You can specify the full path on the virtual disk conform Amiga DOS syntax
(see <code><a href="#topic+current.adf.dir">current.adf.dir</a></code> details). When no full path is specified
the new directory will be created in the current directory. Note that
wild cards are not allowed.</p>
</td></tr>
<tr><td><code id="dir.create.adf_+3A_date">date</code></td>
<td>
<p>A <code><a href="base.html#topic+DateTimeClasses">POSIXt</a></code> object that will be used as the
directory modification date. When missing the system time will used.</p>
</td></tr>
<tr><td><code id="dir.create.adf_+3A_comment">comment</code></td>
<td>
<p>An optional <code>character</code> string that will be included
in the directory header as a comment. Should not be longer than 79 characters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Create a directory on a virtual Amiga floppy disk represented by
an <code><a href="#topic+amigaDisk">amigaDisk</a></code> object. Make sure that the virtual disk
is DOS formatted.
</p>


<h3>Value</h3>

<p>Returns an <code><a href="#topic+amigaDisk">amigaDisk</a></code> object on which the
directory is created.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## create a blank DOS disk:
blank.disk &lt;- blank.amigaDOSDisk("blank", "DD", "FFS", TRUE, FALSE, FALSE)

## creating a new directory on the blank disk is easy:
blank.disk &lt;- dir.create.adf(blank.disk, "new_dir")

## in the line above, the directory is placed in the
## current directory (the root in this case). Directories
## can also be created by specifying the full path:

blank.disk &lt;- dir.create.adf(blank.disk, "DF0:new_dir/sub_dir")

## check whether we succeeded:
list.adf.files(blank.disk)

## we can even make it the current dir:
current.adf.dir(blank.disk) &lt;- "DF0:new_dir/sub_dir"

## End(Not run)
</code></pre>

<hr>
<h2 id='displayRawData'>Display raw data in a comprehensive way</h2><span id='topic+displayRawData'></span>

<h3>Description</h3>

<p>Cat <code>raw</code> data to the sink in columns with ASCII code
</p>


<h3>Usage</h3>

<pre><code class='language-R'>displayRawData(x, ncol = 4, col.wid = 4, address.len = 3, hex.upper = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="displayRawData_+3A_x">x</code></td>
<td>
<p>A vector of class <code>raw</code> to be displayed.</p>
</td></tr>
<tr><td><code id="displayRawData_+3A_ncol">ncol</code></td>
<td>
<p>Number of columns of hexadecimal code to display.</p>
</td></tr>
<tr><td><code id="displayRawData_+3A_col.wid">col.wid</code></td>
<td>
<p>Width of each column (in bytes) to display.</p>
</td></tr>
<tr><td><code id="displayRawData_+3A_address.len">address.len</code></td>
<td>
<p>Length of the hexadecimal address
(in number of hexadecimal digits) to display.</p>
</td></tr>
<tr><td><code id="displayRawData_+3A_hex.upper">hex.upper</code></td>
<td>
<p><code>logical</code> value, to specify whether hexadecimals
should be displayed in uppercase (<code>TRUE</code>, default) or
lowercase (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As binary data is hard to decipher this function will
cat raw data as hexadecimal code in columns, together
with the relative (hexadecimal) address of the data and
an ASCII translation of the data. Hexadecimals are shown
in space separated columns for improved readability. Special
characters are replaced by dots in the ASCII representation.
</p>
<p>Raw data is padded with zeros at the end to fill remaining
columns...
</p>


<h3>Value</h3>

<p>The <code>character</code> string send to the sink is also
returned by the function.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other raw.operations: 
<code><a href="#topic+amigaDateToRaw">amigaDateToRaw</a>()</code>,
<code><a href="#topic+amigaIntToRaw">amigaIntToRaw</a>()</code>,
<code><a href="#topic+rawToAmigaDate">rawToAmigaDate</a>()</code>,
<code><a href="#topic+rawToAmigaInt">rawToAmigaInt</a>()</code>,
<code><a href="#topic+rawToBitmap">rawToBitmap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Display some raw random data:
displayRawData(as.raw(sample.int(100)))

## Display the full ASCII table:
displayRawData(as.raw(0:255))
</code></pre>

<hr>
<h2 id='get.adf.file'>Get a file from an amigaDisk object</h2><span id='topic+get.adf.file'></span><span id='topic+get.adf.file+2CamigaDisk+2Ccharacter+2Cmissing-method'></span><span id='topic+get.adf.file+2CamigaDisk+2Ccharacter+2Ccharacter-method'></span><span id='topic+get.adf.file+2CamigaDisk+2Ccharacter+2CANY-method'></span>

<h3>Description</h3>

<p>Get files stored on virtual <code><a href="#topic+amigaDisk">amigaDisk</a></code>s as raw data
or copy as file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'amigaDisk,character,missing'
get.adf.file(x, source, destination)

## S4 method for signature 'amigaDisk,character,character'
get.adf.file(x, source, destination)

## S4 method for signature 'amigaDisk,character,ANY'
get.adf.file(x, source, destination)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.adf.file_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+amigaDisk">amigaDisk</a></code> object from which a file
needs to be extracted.</p>
</td></tr>
<tr><td><code id="get.adf.file_+3A_source">source</code></td>
<td>
<p>Specify the source file's path on the
<code><a href="#topic+amigaDisk">amigaDisk</a></code> object, conform Amiga specs. See
<code><a href="#topic+current.adf.dir">current.adf.dir</a></code> for details on these specs.</p>
</td></tr>
<tr><td><code id="get.adf.file_+3A_destination">destination</code></td>
<td>
<p>either a file name or a file connection, that
allows writing binary data (see e.g., <code><a href="base.html#topic+connections">file</a></code> or
<code><a href="base.html#topic+connections">url</a></code>). When the destination is missing, the
file content is returned as <code>raw</code> data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Amiga DOS formatted disks can store any kind of file (as long
as the disk's capacity allows it). Use this method to extract
such files embedded in an Amiga Disk File (ADF) as raw data or
copy to a file on your system.
</p>


<h3>Value</h3>

<p>Returns a <code>vector</code> of <code>raw</code> data when the
argument <code>destination</code> is missing. Otherwise returns nothing.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(adf.example)

## Not run: 
## get the file "Startup-Sequence" from the virtual
## example disk and save as a text file in the
## current working directory:
get.adf.file(adf.example, "DF0:S/Startup-Sequence", "startup.txt")

## End(Not run)

## get the same file as raw data
## by omitting the destination:
startup &lt;- get.adf.file(adf.example, "DF0:S/Startup-Sequence")

## Look, it's a text file:
startup |&gt; rawToChar() |&gt; iconv(from = "ISO-8859-1", to = "UTF-8")

if (requireNamespace("ProTrackR", quietly = TRUE)) {
  ## look there is a typical ProTracker module on
  ## the example disk. You can load it like this:
  
  ## get the file from the virtual disk
  ## as raw data
  mod.raw &lt;- get.adf.file(adf.example, "DF0:mods/mod.intro")

  ## open a raw connection with the
  ## newly imported raw data
  con &lt;- rawConnection(mod.raw, "rb")

  ## and read it as a ProTracker module
  mod &lt;- ProTrackR::read.module(con)
  close(con)
  
  ## plot the first sample from the module:
  plot(ProTrackR::waveform(ProTrackR::PTSample(mod, 1)),
       type = "l", ylab = "amplitude")
} else {
  cat("You need to install and load the\nProTrackR package for this part of the example.")
}
</code></pre>

<hr>
<h2 id='get.blockID'>Get the block ID from the physical location on the disk</h2><span id='topic+get.blockID'></span><span id='topic+get.blockID+2Ccharacter+2Cnumeric+2Cnumeric+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Get the block identifier based on the physical location on a disk (side,
cylinder and sector) and the disk type.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'character,numeric,numeric,numeric'
get.blockID(disktype, sector, side, cylinder)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.blockID_+3A_disktype">disktype</code></td>
<td>
<p>A <code>character</code> string indicating the type of disk:
<code>DD</code> for double density disks. <code>HD</code> for high density disks.</p>
</td></tr>
<tr><td><code id="get.blockID_+3A_sector">sector</code></td>
<td>
<p><code>numeric</code> identifier for the sector on the disk, ranging
from 0 up to 10 (<code>DD</code> disks) or 21 (<code>HD</code> disks).</p>
</td></tr>
<tr><td><code id="get.blockID_+3A_side">side</code></td>
<td>
<p><code>numeric</code> identifier for the side of the disk (0 or 1).</p>
</td></tr>
<tr><td><code id="get.blockID_+3A_cylinder">cylinder</code></td>
<td>
<p><code>numeric</code> identifier for the cylinder on the disk,
ranging from 0 up to 79.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data on Amiga floppy disks are stored as 512 byte blocks. These blocks
are physically stored on a specific cylinder and side at a specific sector.
This method returns the block identifier based on the physical location
on the disk. The inverse of this function is achieved with the
<code><a href="#topic+get.diskLocation">get.diskLocation</a></code> method.
</p>
<p>Note that all identifiers (or indices) have a base at zero, for consistency
with Amiga specifications and documentation, opposed to the base of one
used in R.
</p>


<h3>Value</h3>

<p>Returns the <code>numeric</code> identifier for the corresponding block.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other block.operations: 
<code><a href="#topic+amigaBlock-method">amigaBlock-method</a></code>,
<code><a href="#topic+get.diskLocation">get.diskLocation</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Get the block identifier for sectors 0 up to 3 combined with
## cylinders 0 up to 3 on side 0 of the disk:
get.blockID(disktype = "DD",
            sector   = 0:3,
            side     = 0,
            cylinder = 0:3)
</code></pre>

<hr>
<h2 id='get.diskLocation'>Get the physical location on the disk for a specific block</h2><span id='topic+get.diskLocation'></span><span id='topic+get.diskLocation+2Ccharacter+2Cnumeric-method'></span>

<h3>Description</h3>

<p>Get the side, cylinder and sector on a disk, based on disk type and
block id.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'character,numeric'
get.diskLocation(disktype, block)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get.diskLocation_+3A_disktype">disktype</code></td>
<td>
<p>A <code>character</code> string indicating the type of disk:
<code>DD</code> for double density disks. <code>HD</code> for high density disks.</p>
</td></tr>
<tr><td><code id="get.diskLocation_+3A_block">block</code></td>
<td>
<p><code>numeric</code> identifier of a block. Whole numbers ranging from
0 up to 1759 (for DD disks) or 3519 (for HD disks). Note that the base
index is zero (for consitency with Amiga specifications and documentation)
opposed to the base of one used in R.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Data on Amiga floppy disks are stored as 512 byte blocks. These blocks
are physically stored on a specific cylinder and side at a specific sector.
This method returns the identifiers for the physical location based on the
block identifier. The inverse of this function is achieved with the
<code><a href="#topic+get.blockID">get.blockID</a></code> method.
</p>


<h3>Value</h3>

<p>Returns a <code>list</code> with corresponding sector, side and cylinder
identifiers (<code>numeric</code>).
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other block.operations: 
<code><a href="#topic+amigaBlock-method">amigaBlock-method</a></code>,
<code><a href="#topic+get.blockID">get.blockID</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## get the physical location of the first 20 blocks on a DD disk
## and arrange as a data.frame:
as.data.frame(get.diskLocation("DD", 0:19))
</code></pre>

<hr>
<h2 id='is.amigaDOS'>Check if amigaDisk object is DOS formatted</h2><span id='topic+is.amigaDOS'></span><span id='topic+is.amigaDOS+2CamigaDisk-method'></span>

<h3>Description</h3>

<p>This method checks if there is a DOS file structure is present
on the <code><a href="#topic+amigaDisk">amigaDisk</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'amigaDisk'
is.amigaDOS(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.amigaDOS_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+amigaDisk">amigaDisk</a></code> object for which
the check should be performed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Not all Amiga Disk Files have a DOS file structure on them.
This function checks if there is.
</p>


<h3>Value</h3>

<p>Returns a <code>logical</code> value, indicating whether the
disk is DOS formatted. When it is not, the attributes to the
returned value will contain information as to why the disk is
not DOS compatible.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(adf.example)

## let's check if the example amigaDisk object
## is DOS formatted:

is.amigaDOS(adf.example)

## it apparently is
</code></pre>

<hr>
<h2 id='is.bootable'>Check if amigaDisk object is bootable</h2><span id='topic+is.bootable'></span><span id='topic+is.bootable+2CamigaDisk-method'></span>

<h3>Description</h3>

<p>This function checks if the <code><a href="#topic+amigaDisk">amigaDisk</a></code>
object represents a bootable disk.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'amigaDisk'
is.bootable(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="is.bootable_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+amigaDisk">amigaDisk</a></code> object for which
the check should be performed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The first two <code><a href="#topic+amigaBlock-class">amigaBlock</a></code> objects on a disk
are special and are called the boot block. The boot block will
determine whether an Amiga can boot from the disk.
</p>
<p>This function will determine whether the Amiga would attempt
to execute the machine code present on the boot block. It will not
check whether it would be successful at that, as that would
require emulation of the Commodore Amiga system.
</p>


<h3>Value</h3>

<p>Returns a <code>logical</code> value, indicating whether
the disk is bootable.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(adf.example)

## let's check if the example amigaDisk object
## is bootable:

is.bootable(adf.example)

## it apparently is
</code></pre>

<hr>
<h2 id='list.adf.files'>List files in an amigaDisk directory</h2><span id='topic+list.adf.files'></span><span id='topic+list.adf.files+2CamigaDisk+2Cmissing-method'></span><span id='topic+list.adf.files+2CamigaDisk+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Get a list of files in a specific directory on a virtual
<code><a href="#topic+amigaDisk">amigaDisk</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'amigaDisk,missing'
list.adf.files(x, path)

## S4 method for signature 'amigaDisk,character'
list.adf.files(x, path)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="list.adf.files_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+amigaDisk">amigaDisk</a></code> object for which the files
should be listed.</p>
</td></tr>
<tr><td><code id="list.adf.files_+3A_path">path</code></td>
<td>
<p>Specify the path on the <code><a href="#topic+amigaDisk">amigaDisk</a></code>
object, conform Amiga specs, for which files should be listed.
See <code><a href="#topic+current.adf.dir">current.adf.dir</a></code> for details on these specs.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>As an analogue of <code style="white-space: pre;">&#8288;[base::list.files]&#8288;</code>, this method
list files in a specific directory. But in this case the files
are located on a virtual floppy disk represented by the
<code><a href="#topic+amigaDisk">amigaDisk</a></code> object. This works only for DOS-formatted
(<code><a href="#topic+is.amigaDOS">is.amigaDOS</a></code>) virtual disks.
</p>


<h3>Value</h3>

<p>Returns a <code>vector</code> of <code>character</code>s listing
the files in the specified directory on the virtual disk.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(adf.example)

## show all files in the root of the example
## disk file:
list.adf.files(adf.example)

## you can also list the files in a specified
## directory:
list.adf.files(adf.example, "DF0:mods")

## For the same path, only now specified
## relatively to the current directory:
list.adf.files(adf.example, "mods")

</code></pre>

<hr>
<h2 id='print'>Print Amiga Disk File objects</h2><span id='topic+print'></span><span id='topic+print+2CamigaDisk-method'></span><span id='topic+print+2CamigaBlock-method'></span>

<h3>Description</h3>

<p>A method to print Amiga Disk File S4 class objects to the sink.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'amigaDisk'
print(x, ...)

## S4 method for signature 'amigaBlock'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print_+3A_x">x</code></td>
<td>
<p>Either a <code><a href="#topic+amigaDisk">amigaDisk</a></code> or <code><a href="#topic+amigaBlock">amigaBlock</a></code> object.</p>
</td></tr>
<tr><td><code id="print_+3A_...">...</code></td>
<td>
<p>further arguments passed to or from other methods</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns nothing (<code>NULL</code>).
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(adf.example)

print(adf.example)
</code></pre>

<hr>
<h2 id='put.adf.file'>Put a file onto an amigaDisk object</h2><span id='topic+put.adf.file'></span><span id='topic+put.adf.file+2CamigaDisk+2Craw+2Ccharacter+2CPOSIXt+2Ccharacter-method'></span><span id='topic+put.adf.file+2CamigaDisk+2Craw+2Ccharacter+2CPOSIXt+2Cmissing-method'></span><span id='topic+put.adf.file+2CamigaDisk+2Craw+2Ccharacter+2Cmissing+2Cmissing-method'></span><span id='topic+put.adf.file+2CamigaDisk+2Ccharacter+2Ccharacter+2CPOSIXt+2Ccharacter-method'></span><span id='topic+put.adf.file+2CamigaDisk+2Ccharacter+2Ccharacter+2CPOSIXt+2Cmissing-method'></span><span id='topic+put.adf.file+2CamigaDisk+2Ccharacter+2Ccharacter+2Cmissing+2Cmissing-method'></span><span id='topic+put.adf.file+2CamigaDisk+2Ccharacter+2Cmissing+2Cmissing+2Cmissing-method'></span>

<h3>Description</h3>

<p>Put a file onto a virtual Amiga floppy disk represented by
an <code><a href="#topic+amigaDisk">amigaDisk</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'amigaDisk,raw,character,POSIXt,character'
put.adf.file(x, source, destination, date, comment)

## S4 method for signature 'amigaDisk,raw,character,POSIXt,missing'
put.adf.file(x, source, destination, date, comment)

## S4 method for signature 'amigaDisk,raw,character,missing,missing'
put.adf.file(x, source, destination, date, comment)

## S4 method for signature 'amigaDisk,character,character,POSIXt,character'
put.adf.file(x, source, destination, date, comment)

## S4 method for signature 'amigaDisk,character,character,POSIXt,missing'
put.adf.file(x, source, destination, date, comment)

## S4 method for signature 'amigaDisk,character,character,missing,missing'
put.adf.file(x, source, destination, date, comment)

## S4 method for signature 'amigaDisk,character,missing,missing,missing'
put.adf.file(x, source, destination, date, comment)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="put.adf.file_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+amigaDisk">amigaDisk</a></code> onto which the file should be put.</p>
</td></tr>
<tr><td><code id="put.adf.file_+3A_source">source</code></td>
<td>
<p>Either a <code>character</code> string of the source
file's path; or a <code>vector</code> of <code>raw</code> data that
should be written to the destination file. Wildcards are not allowed (see details)</p>
</td></tr>
<tr><td><code id="put.adf.file_+3A_destination">destination</code></td>
<td>
<p>A <code>character</code> string of the destination
path on the virtual floppy disk where the source file should be put. The
path should be conform Amiga specs (see <code><a href="#topic+current.adf.dir">current.adf.dir</a></code>). When
the destination is missing or only specifies a directory, the file will be put
into the current directory (<code><a href="#topic+current.adf.dir">current.adf.dir</a></code>) or specified path of
<code>x</code> respectively. In that case, the same file name as that
of the source file is used. Wild cards are not allowed (see details).</p>
</td></tr>
<tr><td><code id="put.adf.file_+3A_date">date</code></td>
<td>
<p>A <code><a href="base.html#topic+DateTimeClasses">POSIXt</a></code> object that will be used as the
file modification date. When missing the system time will used.</p>
</td></tr>
<tr><td><code id="put.adf.file_+3A_comment">comment</code></td>
<td>
<p>An optional <code>character</code> string that will be included
in the file header as a comment. Should not be longer than 79 characters.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Put a file or raw data from your local system onto a virtual
Amiga floppy disk represented by an <code><a href="#topic+amigaDisk">amigaDisk</a></code>
object. Make sure that the virtual disk is DOS formatted.
This method can only put one file at a time onto the virtual
virtual disk. It is therefore not allowed to use wild cards
in the source or destination names. Use loops to add multiple
files onto a virtual disk.
</p>


<h3>Value</h3>

<p>Returns an <code><a href="#topic+amigaDisk">amigaDisk</a></code> object onto which the
source file is put at the specified destination.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## create a blank disk to put files onto:
blank.disk &lt;- blank.amigaDOSDisk("blank", "DD", "OFS", TRUE, FALSE, FALSE)

## let's copy the base package 'INDEX' file onto the
## virtual disk:
blank.disk &lt;- put.adf.file(blank.disk, system.file("INDEX"))

## We can also put raw data onto the virtual disk:
blank.disk &lt;- put.adf.file(blank.disk, raw(2048), "DF0:null.dat")

## check whether we succeeded:
list.adf.files(blank.disk)

## End(Not run)
</code></pre>

<hr>
<h2 id='rawToAmigaDate'>Convert raw values into a date time object</h2><span id='topic+rawToAmigaDate'></span>

<h3>Description</h3>

<p>This function converts raw data into a date time object conform the
Amiga file system specifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rawToAmigaDate(x, format = c("long", "short"), tz = "UTC")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rawToAmigaDate_+3A_x">x</code></td>
<td>
<p>a <code>vector</code> of <code>raw</code> values with a length of a multitude
of 6 (for the short format) or 12 (for the long format).</p>
</td></tr>
<tr><td><code id="rawToAmigaDate_+3A_format">format</code></td>
<td>
<p>a <code>character</code> string indicating whether the date
is stored as <code>short</code> or <code>long</code> integers.</p>
</td></tr>
<tr><td><code id="rawToAmigaDate_+3A_tz">tz</code></td>
<td>
<p>A <code>character</code> string specifying the time zone to be used
to retrieve the date time object. Note that the time zone is not stored
on the Amiga. By default the Universal time zone (UTC) is assumed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Amiga file system stores date time objects as three unsigned
short (16 bit) or long (32 bit) integers. Where the values are
number of days, minutes and ticks (fiftieth of a second) since
1978-01-01 respectively.
</p>
<p>As these values are always positive, only date time values on or after
1978-01-01 are allowed. The inverse of this function can be achieved
with <code><a href="#topic+amigaDateToRaw">amigaDateToRaw</a></code>.
</p>


<h3>Value</h3>

<p>Returns a <code><a href="base.html#topic+DateTimeClasses">POSIXct</a></code> object based on the provided
raw data.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other raw.operations: 
<code><a href="#topic+amigaDateToRaw">amigaDateToRaw</a>()</code>,
<code><a href="#topic+amigaIntToRaw">amigaIntToRaw</a>()</code>,
<code><a href="#topic+displayRawData">displayRawData</a>()</code>,
<code><a href="#topic+rawToAmigaInt">rawToAmigaInt</a>()</code>,
<code><a href="#topic+rawToBitmap">rawToBitmap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## all raw data is zero, so the origin date is returned:
rawToAmigaDate(raw(12))

## let's get the date, one day, one minute and 50 ticks from the origin:
rawToAmigaDate(amigaIntToRaw(c(1, 1, 50), 32))
</code></pre>

<hr>
<h2 id='rawToAmigaInt'>Convert raw values into Amiga integers</h2><span id='topic+rawToAmigaInt'></span>

<h3>Description</h3>

<p>Convert raw data into 8, 16, or 32-bit signed or unsigned
integer values, conform Amiga specifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rawToAmigaInt(x, bits = 8, signed = F)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rawToAmigaInt_+3A_x">x</code></td>
<td>
<p>A vector of class <code>raw</code> to be converted into a <code>character</code>.</p>
</td></tr>
<tr><td><code id="rawToAmigaInt_+3A_bits">bits</code></td>
<td>
<p>Number of bits that represents the integer value. Should be 8 or a
positive multitude of 8.</p>
</td></tr>
<tr><td><code id="rawToAmigaInt_+3A_signed">signed</code></td>
<td>
<p>A <code>logical</code> value indicating whether the integer
should be signed (<code>TRUE</code>, default) or not (<code>FALSE</code>).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Commodore Amiga has specified the following data formats
to represent integer data: BYTE (signed 8-bit integer), UBYTE
(unsigned 8-bit integer), WORD (signed 16-bit integer), UWORD
(unsigned 16-bit integer), LONG (signed 32-bit integer), ULONG,
(unsigned 32-bit integer). This function converts raw data into
such integers. Note that WORD and UWORD are also referred to as
SHORT and USHORT respectively.
</p>


<h3>Value</h3>

<p>A <code>numeric</code> value (or a <code>vector</code> of values),
representing the integer data represented by the provided
<code>raw</code> data. Note that R defines <code>integer</code> as 32-bit
signed integers and cannot store the 32-bit signed values.
Therefore a <code>numeric</code> value is returned rather than an
explicit <code>integer</code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other raw.operations: 
<code><a href="#topic+amigaDateToRaw">amigaDateToRaw</a>()</code>,
<code><a href="#topic+amigaIntToRaw">amigaIntToRaw</a>()</code>,
<code><a href="#topic+displayRawData">displayRawData</a>()</code>,
<code><a href="#topic+rawToAmigaDate">rawToAmigaDate</a>()</code>,
<code><a href="#topic+rawToBitmap">rawToBitmap</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Let's start by obtaining unsigned 8-bit integers:
rawToAmigaInt(as.raw(0:255))

## note that this is the same as:
as.numeric(as.raw(0:255))

## but with this function we can also get signed values:
rawToAmigaInt(as.raw(0:255), signed = TRUE)

## Furthermore 32 or 16-bit integers can also be obtained.
## Let's look at 16-bit integers:
rawToAmigaInt(as.raw(0:255), 16)

## Note that 16-bit integers require twice as many bytes
## as 8 bit integers:
length(rawToAmigaInt(as.raw(0:255), 16))
length(rawToAmigaInt(as.raw(0:255), 8))
</code></pre>

<hr>
<h2 id='rawToBitmap'>Convert raw data into a bitmap or vice versa</h2><span id='topic+rawToBitmap'></span><span id='topic+bitmapToRaw'></span>

<h3>Description</h3>

<p>Convert raw data into a bitmap or vice versa (i.e., binary data)
conform Amiga specifications.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rawToBitmap(x, invert.bytes = F, invert.longs = T)

bitmapToRaw(x, invert.bytes = T, invert.longs = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="rawToBitmap_+3A_x">x</code></td>
<td>
<p>A <code>vector</code> of <code>raw</code> data, in case
<code>rawToBitmap</code> is used. A <code>vector</code> of <code>raw</code>,
<code>interger</code> or <code>logical</code> values should be used in
case of <code>bitmapToRaw</code>. In the latter case each value in the
<code>vector</code> is interpreted as a bit and should be a multiple of
8 long.</p>
</td></tr>
<tr><td><code id="rawToBitmap_+3A_invert.bytes">invert.bytes</code></td>
<td>
<p>A <code>logical</code> value. When set to <code>TRUE</code>,
the bit order of bytes are reversed.</p>
</td></tr>
<tr><td><code id="rawToBitmap_+3A_invert.longs">invert.longs</code></td>
<td>
<p>A <code>logical</code> value. When set to <code>TRUE</code>,
the bit order of long values (32 bits) are reversed. When <code>x</code>
does not have a multiple length of 32 bits or 4 bytes, <code>x</code> will
be padded with zeros to the right, but the result will be trimmed to
correspond with the length of <code>x</code>. Note that data might get lost
this way.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A bitmap is simply put a map of bits (binary data, which can
be interpeted as 0 or 1; or FALSE and TRUE). Bitmaps can have
several purposes, also on the Commodore Amiga. The Amiga file
system uses a bitmap to indicates which blocks are occupied with
data and which are free. Bitmaps can also be used in bitmap images
where each bit indicates which color should be used for a specific
pixel in an image. These function can be used to convert raw data
into usable bitmaps or vice versa.
</p>
<p>As the Commodore Amiga is a big-endian system (most significant
bit first) using a 32 bit CPU, it may sometimes necessary to invert
the bits of a byte or longs (4 bytes, 32 bits), which can be done
with the arguments '<code>invert.bytes</code>' and '<code>invert.longs</code>'
respectively.
</p>


<h3>Value</h3>

<p>Returns a <code>vector</code> of <code>raw</code> data in case of
<code>bitmapToRaw</code>, and a <code>vector</code> of binary <code>raw</code> values
in case of <code>rawToBitmap</code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other raw.operations: 
<code><a href="#topic+amigaDateToRaw">amigaDateToRaw</a>()</code>,
<code><a href="#topic+amigaIntToRaw">amigaIntToRaw</a>()</code>,
<code><a href="#topic+displayRawData">displayRawData</a>()</code>,
<code><a href="#topic+rawToAmigaDate">rawToAmigaDate</a>()</code>,
<code><a href="#topic+rawToAmigaInt">rawToAmigaInt</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## The bitmap block of the example disk is located at block
## number 882 (note that this is not true for all disks,
## the actual location is stored in the root block)
data(adf.example)
bitmap.block &lt;- amigaBlock(adf.example, 881)

## bitmap data are stored in bytes 5 up to 224 in this block:
bitmap.raw &lt;- bitmap.block@data[5:224]

## let's get the bitmap from the raw data:
bitmap &lt;- rawToBitmap(bitmap.raw)

## Whe can now get the occupied blocks (minus one is used for
## the discrepancy in indexing):
which(bitmap != as.raw(0x01)) - 1

## we can also do the reverse:
bitmap.raw.new &lt;-  bitmapToRaw(bitmap)
## it should be the same as the original raw data:
all(bitmap.raw.new == bitmap.raw)

## WARNING: don't use these methods to directly
## modify an amigaDisk objects bitmap block. The
## file system on that object may get corrupted.
## All methods in this package should update the
## bitmap block automatically and cleanly...
</code></pre>

<hr>
<h2 id='read.adf'>Read an Amiga Disk File</h2><span id='topic+read.adf'></span><span id='topic+read.adf+2Ccharacter-method'></span><span id='topic+read.adf+2CANY-method'></span><span id='topic+read.adz'></span><span id='topic+read.adz+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Read data from an Amiga Disk File (ADF) to an <code><a href="#topic+amigaDisk">amigaDisk</a></code>
object. Alternatively data can be read from an ADZ file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'character'
read.adf(file)

## S4 method for signature 'ANY'
read.adf(file)

## S4 method for signature 'character'
read.adz(file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="read.adf_+3A_file">file</code></td>
<td>
<p>Either a file name or a file connection, that
allows reading binary data (see e.g., <code><a href="base.html#topic+connections">file</a></code> or
<code><a href="base.html#topic+connections">url</a></code>). <code>read.adz</code> only accepts file names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Amiga Disk Files usually have a .adf-extension to the file name.
It should be 880 kB (double density) or 1760 kB (high density)
in size. This function can read such files.
</p>
<p>Alternatively, ADZ files can also be read. These are essentially
gzipped ADF files.
</p>
<p>Note that this package cannot read extended ADF files containing
information on the disk's Modified frequency modulation (MFM).
This information is typically only required for copy protected disk's
and is therefore out of the scope of this package.
</p>


<h3>Value</h3>

<p>Returns an <code><a href="#topic+amigaDisk">amigaDisk</a></code> object read from the provided Amiga disk file
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other io.operations: 
<code><a href="#topic+write.adf">write.adf</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## In order to read an adf-file, we first need one.
## so let's first write the example object to a file:
data(adf.example)

## write it to the current working directory:
write.adf(adf.example, "test.adf")

## now we can read it again:
my.disk &lt;- read.adf("test.adf")
print(my.disk)

## and this is how you read it,
## using a connection:
con &lt;- file("test.adf", "rb")
my.disk2 &lt;- read.adf(con)
close(con)

print(my.disk2)

## Alternatively, you can work with ADZ files:
write.adz(adf.example, "test.adz")
my.disk3 &lt;- read.adz("test.adz")

print(my.disk3)

## End(Not run)
</code></pre>

<hr>
<h2 id='write.adf'>Write an amigaDisk object to an ADF file</h2><span id='topic+write.adf'></span><span id='topic+write.adf+2CamigaDisk+2CANY-method'></span><span id='topic+write.adf+2CamigaDisk+2Ccharacter-method'></span><span id='topic+write.adz'></span><span id='topic+write.adz+2CamigaDisk+2Ccharacter-method'></span>

<h3>Description</h3>

<p>Write an <code><a href="#topic+amigaDisk">amigaDisk</a></code> object to an Amiga Disk File (ADF) or
alternatively to an ADZ file.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S4 method for signature 'amigaDisk,ANY'
write.adf(x, file)

## S4 method for signature 'amigaDisk,character'
write.adf(x, file)

## S4 method for signature 'amigaDisk,character'
write.adz(x, file)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="write.adf_+3A_x">x</code></td>
<td>
<p>An <code><a href="#topic+amigaDisk">amigaDisk</a></code> object that needs to be saved to
an ADF file.</p>
</td></tr>
<tr><td><code id="write.adf_+3A_file">file</code></td>
<td>
<p>either a file name to write to, or a file connection, that
allows to write binary data (see <code><a href="base.html#topic+connections">file</a></code>).
<code>write.adz</code> only accepts a file name.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Use this function to write <code><a href="#topic+amigaDisk">amigaDisk</a></code> objects as binary
data to so-called Amiga Disk Files (ADF). These files can be used as
input for Amiga emulator software.
</p>
<p>Alternatively, the object can be saved with 'write.adz', which is
essentially a gzipped version of an ADF file.
</p>


<h3>Value</h3>

<p>Writes to an ADF file but returns nothing.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>See Also</h3>

<p>Other io.operations: 
<code><a href="#topic+read.adf">read.adf</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Let's write the example data to an ADF file:
data(adf.example)

## Let's put it in the current working directory:
write.adf(adf.example, "test.adf")

## You can also use file connections to do the same:
con &lt;- file("test2.adf", "wb")
write.adf(adf.example, con)
close(con)

## Last but not least the same object can be saved
## as an adz file:
write.adz(adf.example, "test.3.adz")

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
