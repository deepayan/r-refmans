<!DOCTYPE html><html lang="en"><head><title>Help for package adfExplorer</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {adfExplorer}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#adfExplorer-package'><p>adfExplorer: Access and Manipulate Amiga Disk Files</p></a></li>
<li><a href='#adf_directory'><p>Changing and creating directories on a virtual device</p></a></li>
<li><a href='#adf_entry_info'><p>Retrieve information from entry headers on virtual ADF devices</p></a></li>
<li><a href='#adf_entry_name+26lt+3B-'><p>Obtain or modify an entry name on a virtual device</p></a></li>
<li><a href='#adf_file_con'><p>Open a connection to a file on a virtual ADF device</p></a></li>
<li><a href='#adf_file_exists'><p>Test if an entry exists on a virtual device</p></a></li>
<li><a href='#amigaDateToRaw'><p>Deprecated functions</p></a></li>
<li><a href='#close_all_devices'><p>Close all virtual devices</p></a></li>
<li><a href='#compress_adf'><p>Compress ADF to ADZ files and vice versa</p></a></li>
<li><a href='#connect_adf'><p>Create a connection to a virtual disk</p></a></li>
<li><a href='#copy_adf_entry'><p>Copy or move files between physical and virtual devices</p></a></li>
<li><a href='#create_adf_device'><p>Create and format a virtual ADF device</p></a></li>
<li><a href='#demo_adf'><p>Connect with a demonstration ADF file</p></a></li>
<li><a href='#device_type'><p>Obtain information about an <code>adf_device</code> connection</p></a></li>
<li><a href='#format.adf_device'><p>Basic methods for S3 class objects</p></a></li>
<li><a href='#list_adf_entries'><p>List entries in a directory of a virtual ADF device</p></a></li>
<li><a href='#read_adf_block'><p>Read or write raw data blocks to a virtual device</p></a></li>
<li><a href='#readBin'><p>Transfer binary data to and from connections</p></a></li>
<li><a href='#remove_adf_entry'><p>Remove entry (file / directory) from a virtual ADF device</p></a></li>
<li><a href='#virtual_path'><p>A path pointing to a file or directory on a virtual ADF device</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Access and Manipulate Amiga Disk Files</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.3</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Pepijn de Vries &lt;pepijn.devries@outlook.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Amiga Disk Files (ADF) are virtual
    representations of 3.5 inch floppy disks for the
    Commodore Amiga. Most disk drives from other systems
    (including modern drives) are not able to read these
    disks. The 'adfExplorer' package enables you to
    establish R connections to files on such
    virtual DOS-formatted disks, which can be use to
    read from and write to those files.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>cpp11</td>
</tr>
<tr>
<td>Collate:</td>
<td>'adfExplorer-package.R' 'blocks.R' 'compress.R' 'cpp11.R'
'connect_adf.R' 'demo.R' 'deprecated.R' 'move.R'
'device_info.R' 'device_create.R' 'helpers.R' 'directory.R'
'entry_info.R' 'remove.R' 's3_conn.R' 's3_methods.R'
'virtual_path.R'</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>methods, vctrs</td>
</tr>
<tr>
<td>Suggests:</td>
<td>adfExplorer, knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://pepijn-devries.github.io/adfExplorer/">https://pepijn-devries.github.io/adfExplorer/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/pepijn-devries/adfExplorer/issues">https://github.com/pepijn-devries/adfExplorer/issues</a></td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-01-07 22:01:35 UTC; vries171</td>
</tr>
<tr>
<td>Author:</td>
<td>Pepijn de Vries <a href="https://orcid.org/0000-0002-7961-6646"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Laurent Clévy [aut, cph] (Creator of the original ADFlib library)</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-01-10 22:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='adfExplorer-package'>adfExplorer: Access and Manipulate Amiga Disk Files</h2><span id='topic+adfExplorer'></span><span id='topic+adfExplorer-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Amiga Disk Files (ADF) are virtual representations of 3.5 inch floppy disks for the Commodore Amiga. Most disk drives from other systems (including modern drives) are not able to read these disks. The 'adfExplorer' package enables you to establish R connections to files on such virtual DOS-formatted disks, which can be use to read from and write to those files.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Pepijn de Vries <a href="mailto:pepijn.devries@outlook.com">pepijn.devries@outlook.com</a> (<a href="https://orcid.org/0000-0002-7961-6646">ORCID</a>)
</p>
<p>Authors:
</p>

<ul>
<li><p> Laurent Clévy (Creator of the original ADFlib library) [copyright holder]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://pepijn-devries.github.io/adfExplorer/">https://pepijn-devries.github.io/adfExplorer/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/pepijn-devries/adfExplorer/issues">https://github.com/pepijn-devries/adfExplorer/issues</a>
</p>
</li></ul>


<hr>
<h2 id='adf_directory'>Changing and creating directories on a virtual device</h2><span id='topic+adf_directory'></span><span id='topic+adf_directory.adf_device'></span><span id='topic+adf_directory+3C-'></span><span id='topic+adf_directory+3C-.adf_device'></span><span id='topic+adf_directory+3C-.adf_device.character'></span><span id='topic+adf_directory+3C-.adf_device.virtual_path'></span><span id='topic+make_adf_dir'></span><span id='topic+make_adf_dir.adf_device'></span><span id='topic+make_adf_dir.virtual_path'></span><span id='topic+make_adf_dir.adf_device.character'></span><span id='topic+make_adf_dir.adf_device.virtual_path'></span>

<h3>Description</h3>

<p><code>adf_directory()</code> shows the current directory of a virtual device, when a file
system is present. When connecting to or creating a new device, the current
directory is the disk's root by default. To change the current directory,
use <code>adf_directory()</code> in combination with the assign operator (<code style="white-space: pre;">&#8288;&lt;-&#8288;</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adf_directory(dev, ...)

## S3 method for class 'adf_device'
adf_directory(dev, ...)

adf_directory(dev, ...) &lt;- value

## S3 replacement method for class 'adf_device'
adf_directory(dev, ...) &lt;- value

## S3 replacement method for class 'adf_device.character'
adf_directory(dev, ...) &lt;- value

## S3 replacement method for class 'adf_device.virtual_path'
adf_directory(dev, ...) &lt;- value

make_adf_dir(x, path, ...)

## S3 method for class 'adf_device'
make_adf_dir(x, path, ...)

## S3 method for class 'virtual_path'
make_adf_dir(x, path, ...)

## S3 method for class 'character'
make_adf_dir.adf_device(x, path, ...)

## S3 method for class 'virtual_path'
make_adf_dir.adf_device(x, path, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adf_directory_+3A_dev">dev</code></td>
<td>
<p>The virtual adf device for which information needs to be obtained.
It should be of class <code>adf_device</code> which can be created with <code><a href="#topic+create_adf_device">create_adf_device()</a></code>
or <code><a href="#topic+connect_adf">connect_adf()</a></code>.</p>
</td></tr>
<tr><td><code id="adf_directory_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="adf_directory_+3A_value">value</code></td>
<td>
<p>A <code>character</code> string or a <code>virtual_path</code> (see <code><a href="#topic+virtual_path">virtual_path()</a></code>)
representing directory you wish to set as current.</p>
</td></tr>
<tr><td><code id="adf_directory_+3A_x">x</code></td>
<td>
<p>An <code>adf_device</code> or <code>virtual_path</code> class object. The first specifies
the device on which a directory needs to be created. The latter specifies
both the directory and the device on which it needs to be created.</p>
</td></tr>
<tr><td><code id="adf_directory_+3A_path">path</code></td>
<td>
<p>A <code>character</code> string or a <code>virtual_path</code> (see <code><a href="#topic+virtual_path">virtual_path()</a></code>)
specifying the name of the new directory to be created. Should be missing when <code>x</code> is
of class <code>virtual_path</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>To create a new directory on a device use <code>make_adf_dir()</code> and use a full or
relative path name to specify the new directory name.
</p>
<p>See <code>vignette("virtual_paths")</code> for a note on file and directory names on the Amiga.
</p>


<h3>Value</h3>

<p><code>make_adf_dir()</code> returns the device connection. <code>adf_directory()</code> returns
the current directory as a <code>virtual_path</code> class object.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Open virtual device to demonstrate methods
my_device &lt;- demo_adf(write_protected = FALSE)

## Show the current directory
adf_directory(my_device)

## Create a new directory
make_adf_dir(my_device, "DF0:s/newdir")

## Change the current dir to the new directory:
adf_directory(my_device) &lt;- "DF0:s/newdir"

## Close the virtual device
close(my_device)
</code></pre>

<hr>
<h2 id='adf_entry_info'>Retrieve information from entry headers on virtual ADF devices</h2><span id='topic+adf_entry_info'></span><span id='topic+adf_entry_info.adf_device'></span><span id='topic+adf_entry_info.adf_device.virtual_path'></span><span id='topic+adf_entry_info.adf_device.character'></span><span id='topic+adf_entry_info.virtual_path'></span><span id='topic+adf_entry_info.adf_file_con'></span>

<h3>Description</h3>

<p>Retrieve information from entry (file and directory) headers on virtual ADF devices.
Get information like entry name, modification date, file size etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adf_entry_info(x, path, ...)

## S3 method for class 'adf_device'
adf_entry_info(x, path, ...)

## S3 method for class 'virtual_path'
adf_entry_info.adf_device(x, path, ...)

## S3 method for class 'character'
adf_entry_info.adf_device(x, path, ...)

## S3 method for class 'virtual_path'
adf_entry_info(x, path, ...)

## S3 method for class 'adf_file_con'
adf_entry_info(x, path, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adf_entry_info_+3A_x">x</code></td>
<td>
<p>Either a virtual device or virtual path.</p>
</td></tr>
<tr><td><code id="adf_entry_info_+3A_path">path</code></td>
<td>
<p>A <code><a href="#topic+virtual_path">virtual_path()</a></code> pointing to the targeted entry (file or directory). Should
be omitted when <code>x</code> is already a virtual path.</p>
</td></tr>
<tr><td><code id="adf_entry_info_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>list</code> of named <code>list</code>s of entry properties.
Elements included in the named <code>list</code>
depend on the type of entry (root, directory or file).
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## First setup a connection to a virtual device
my_device &lt;- demo_adf()

adf_entry_info(my_device, "DF0:")
adf_entry_info(my_device, "s")
adf_entry_info(my_device, "s/startup-sequence")

close(my_device)
</code></pre>

<hr>
<h2 id='adf_entry_name+26lt+3B-'>Obtain or modify an entry name on a virtual device</h2><span id='topic+adf_entry_name+3C-'></span><span id='topic+adf_entry_name'></span><span id='topic+adf_entry_name+3C-.adf_file_con'></span><span id='topic+adf_entry_name+3C-.adf_device'></span><span id='topic+adf_entry_name+3C-.virtual_path'></span><span id='topic+adf_entry_name+3C-.adf_device.character'></span><span id='topic+adf_entry_name+3C-.adf_device.virtual_path'></span>

<h3>Description</h3>

<p>Get the name of an entry (root, file or directory) or update it with the
assign operator (<code style="white-space: pre;">&#8288;&lt;-&#8288;</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adf_entry_name(x, path, ...) &lt;- value

adf_entry_name(x, path, ...)

## S3 replacement method for class 'adf_file_con'
adf_entry_name(x, path, ...) &lt;- value

## S3 replacement method for class 'adf_device'
adf_entry_name(x, path, ...) &lt;- value

## S3 replacement method for class 'virtual_path'
adf_entry_name(x, path, ...) &lt;- value

## S3 replacement method for class 'adf_device.character'
adf_entry_name(x, path, ...) &lt;- value

## S3 replacement method for class 'adf_device.virtual_path'
adf_entry_name(x, path, ...) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adf_entry_name+2B26lt+2B3B-_+3A_x">x</code></td>
<td>
<p>Either a virtual device or virtual path.</p>
</td></tr>
<tr><td><code id="adf_entry_name+2B26lt+2B3B-_+3A_path">path</code></td>
<td>
<p>A <code><a href="#topic+virtual_path">virtual_path()</a></code> pointing to the targeted entry (file or directory). Should
be omitted when <code>x</code> is already a virtual path.</p>
</td></tr>
<tr><td><code id="adf_entry_name+2B26lt+2B3B-_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="adf_entry_name+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>New name for the entry. The name will be sanitised and truncated before
it is assigned to the entry.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the entry name of the requested path or in case of an assign
operation (<code style="white-space: pre;">&#8288;&lt;-&#8288;</code>) an updated version of <code>x</code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Open virtual device to demonstrate methods
my_device &lt;- demo_adf(write_protected = FALSE)

## rename a specific entry
adf_entry_name(my_device, "DF0:mods/mod.intro") &lt;- "mod.music"

## rename disk (also possible with `volume_name&lt;-()`)
adf_entry_name(my_device, "DF0:") &lt;- "my_disk"

close(my_device)
</code></pre>

<hr>
<h2 id='adf_file_con'>Open a connection to a file on a virtual ADF device</h2><span id='topic+adf_file_con'></span><span id='topic+adf_file_con.adf_device'></span><span id='topic+adf_file_con.adf_device.character'></span><span id='topic+adf_file_con.virtual_path'></span>

<h3>Description</h3>

<p>Open a connection to a file on a virtual ADF device. The created connection (if valid)
should be accepted by any R function that reads from or writes to a connection,
such as <code><a href="#topic+readLines">readLines()</a></code>, <code><a href="#topic+writeLines">writeLines()</a></code>, <code><a href="#topic+readBin">readBin()</a></code>, <code><a href="#topic+writeBin">writeBin()</a></code>, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adf_file_con(x, ..., writable = FALSE)

## S3 method for class 'adf_device'
adf_file_con(x, path, ..., writable = FALSE)

## S3 method for class 'character'
adf_file_con.adf_device(x, path, ..., writable = FALSE)

## S3 method for class 'virtual_path'
adf_file_con(x, ..., writable = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adf_file_con_+3A_x">x</code></td>
<td>
<p>Either a connection to a virtual ADF device created with <code><a href="#topic+connect_adf">connect_adf()</a></code>,
or a <code>virtual_path</code> created with <code><a href="#topic+virtual_path">virtual_path()</a></code>.</p>
</td></tr>
<tr><td><code id="adf_file_con_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="adf_file_con_+3A_writable">writable</code></td>
<td>
<p>A <code>logical</code> value. When <code>TRUE</code> the connection can be used to
write to the file on the virtual device. When <code>FALSE</code> it can only be used to read.
Note that a writeable connection can only be setup on a virtual device that is
not write protected.</p>
</td></tr>
<tr><td><code id="adf_file_con_+3A_path">path</code></td>
<td>
<p>Only required when <code>x</code> is a virtual device of class <code>adf_device</code>.
In that case <code>path</code> should be a character string representing the
path to the file on the virtual device. See also <code>vignette("virtual_paths")</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an R connection that can be handled by any function that
accepts a connection for reading or writing. Remember to call <code><a href="base.html#topic+close">close()</a></code> after
use.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## First setup a connection to a virtual device
adz_file &lt;- system.file("example.adz", package = "adfExplorer")
my_device &lt;- connect_adf(adz_file)

## Open a connection to a file on the virtual device
fcon &lt;- adf_file_con(my_device, "DF0:s/startup-sequence")

## Read from the file
my_startup &lt;- readLines(fcon, warn = FALSE)

## Close the file
close(fcon)

## Close the virtual device
close(my_device)
</code></pre>

<hr>
<h2 id='adf_file_exists'>Test if an entry exists on a virtual device</h2><span id='topic+adf_file_exists'></span><span id='topic+adf_file_exists.adf_device'></span><span id='topic+adf_file_exists.virtual_path'></span><span id='topic+adf_dir_exists'></span><span id='topic+adf_dir_exists.adf_device'></span><span id='topic+adf_dir_exists.virtual_path'></span>

<h3>Description</h3>

<p>Test if an entry (file or directory) exists on a virtual ADF device.
<code>adf_file_exists()</code> is the equivalent of <code><a href="base.html#topic+file.exists">file.exists()</a></code> on a virtual ADF device.
<code>adf_dir_exists()</code> is the equivalent of <code><a href="base.html#topic+dir.exists">dir.exists()</a></code> on a virtual ADF device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>adf_file_exists(x, path, ...)

## S3 method for class 'adf_device'
adf_file_exists(x, path, ...)

## S3 method for class 'virtual_path'
adf_file_exists(x, path, ...)

adf_dir_exists(x, path, ...)

## S3 method for class 'adf_device'
adf_dir_exists(x, path, ...)

## S3 method for class 'virtual_path'
adf_dir_exists(x, path, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="adf_file_exists_+3A_x">x</code></td>
<td>
<p>Either a virtual device or virtual path.</p>
</td></tr>
<tr><td><code id="adf_file_exists_+3A_path">path</code></td>
<td>
<p>A <code><a href="#topic+virtual_path">virtual_path()</a></code> pointing to the targeted entry (file or directory). Should
be omitted when <code>x</code> is already a virtual path.</p>
</td></tr>
<tr><td><code id="adf_file_exists_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>adf_file_exists()</code> returns <code>TRUE</code> if the path exists on the virtual device, <code>FALSE</code> otherwise.
<code>adf_dir_exists()</code> returns <code>TRUE</code> when the path exists and is a directory, <code>FALSE</code> otherwise.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## First setup a connection to a virtual device
my_device &lt;- demo_adf()

adf_file_exists(my_device, "s/startup-sequence")
adf_dir_exists(my_device, "s/startup-sequence")

close(my_device)
</code></pre>

<hr>
<h2 id='amigaDateToRaw'>Deprecated functions</h2><span id='topic+amigaDateToRaw'></span><span id='topic+amigaIntToRaw'></span><span id='topic+bitmapToRaw'></span><span id='topic+displayRawData'></span><span id='topic+rawToAmigaDate'></span><span id='topic+rawToAmigaInt'></span><span id='topic+rawToBitmap'></span><span id='topic+adf.disk.name+3C-'></span><span id='topic+adf.file.mode+3C-'></span><span id='topic+adf.file.time+3C-'></span><span id='topic+amigaBlock+3C-'></span><span id='topic+current.adf.dir+3C-'></span><span id='topic+adf.disk.name'></span><span id='topic+adf.file.exists'></span><span id='topic+adf.file.info'></span><span id='topic+adf.file.mode'></span><span id='topic+adf.file.remove'></span><span id='topic+adf.file.size'></span><span id='topic+adf.file.time'></span><span id='topic+amigaBlock'></span><span id='topic+blank.amigaDOSDisk'></span><span id='topic+current.adf.dir'></span><span id='topic+dir.create.adf'></span><span id='topic+dir.exists.adf'></span><span id='topic+get.blockID'></span><span id='topic+get.diskLocation'></span><span id='topic+is.amigaDOS'></span><span id='topic+is.bootable'></span><span id='topic+list.adf.files'></span><span id='topic+put.adf.file'></span><span id='topic+read.adf'></span><span id='topic+read.adz'></span><span id='topic+write.adf'></span><span id='topic+write.adz'></span>

<h3>Description</h3>

<p>Functions documented here are deprecated and will be removed in future
versions of the package. Please use the new functions as indicated instead
or revert to old releases when no alternative is available. See also
<code>vignette("version2")</code> for more information.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>amigaDateToRaw(...)

amigaIntToRaw(...)

bitmapToRaw(...)

displayRawData(...)

rawToAmigaDate(...)

rawToAmigaInt(...)

rawToBitmap(...)

adf.disk.name(...) &lt;- value

adf.file.mode(...) &lt;- value

adf.file.time(...) &lt;- value

amigaBlock(...) &lt;- value

current.adf.dir(...) &lt;- value

adf.disk.name(...)

adf.file.exists(...)

adf.file.info(...)

adf.file.mode(...)

adf.file.remove(...)

adf.file.size(...)

adf.file.time(...)

amigaBlock(...)

blank.amigaDOSDisk(...)

current.adf.dir(...)

dir.create.adf(...)

dir.exists.adf(...)

get.blockID(...)

get.diskLocation(...)

is.amigaDOS(...)

is.bootable(...)

list.adf.files(...)

put.adf.file(...)

read.adf(...)

read.adz(...)

write.adf(...)

write.adz(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="amigaDateToRaw_+3A_...">...</code></td>
<td>
<p>Ignored.</p>
</td></tr>
<tr><td><code id="amigaDateToRaw_+3A_value">value</code></td>
<td>
<p>Ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>

<hr>
<h2 id='close_all_devices'>Close all virtual devices</h2><span id='topic+close_all_devices'></span>

<h3>Description</h3>

<p>Close all virtual devices that are currently open. This function is useful
when you have multiple devices opened at the same time.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>close_all_devices()
</code></pre>


<h3>Value</h3>

<p>Returns <code>NULL</code> invisibly.
</p>

<hr>
<h2 id='compress_adf'>Compress ADF to ADZ files and vice versa</h2><span id='topic+compress_adf'></span><span id='topic+decompress_adz'></span>

<h3>Description</h3>

<p>The ADZ format is essentially a compressed (gzip) version of the
Amiga Disk File (ADF) format. The <code>adfExplorer</code> allows you to connect
to both formats. However, you can only open a 'read-only' connection
to ADZ files. Use the compression and decompression functions documented
here to move back and forth from and to ADF and ADZ formats.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>compress_adf(source, destination)

decompress_adz(source, destination)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="compress_adf_+3A_source">source</code></td>
<td>
<p>Path to the source file to read.</p>
</td></tr>
<tr><td><code id="compress_adf_+3A_destination">destination</code></td>
<td>
<p>Path to the destination file to write.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>NULL</code> invisibly.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>adz_file  &lt;- system.file("example.adz", package = "adfExplorer")
adf_file  &lt;- tempfile(fileext = ".adf")
adz_file2 &lt;- tempfile(fileext = ".adz")

decompress_adz(adz_file, adf_file)
compress_adf(adf_file, adz_file2)
</code></pre>

<hr>
<h2 id='connect_adf'>Create a connection to a virtual disk</h2><span id='topic+connect_adf'></span>

<h3>Description</h3>

<p>Establish a connection to a virtual disk stored as Amiga Disk Files (ADF).
You cannot write or read directly from this connection. Instead, use the
methods provided in this package to retrieve information about the virtual
disk or create connections to the files on the disk, to which you <em>can</em>
write and read from (see <code><a href="#topic+adf_file_con">adf_file_con()</a></code>). Like any other connection,
please use <code><a href="base.html#topic+close">close()</a></code> to close the connection after use.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>connect_adf(filename, write_protected = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="connect_adf_+3A_filename">filename</code></td>
<td>
<p>Filename of the <code>ADF</code> or <code>ADZ</code> file containing the virtual disk</p>
</td></tr>
<tr><td><code id="connect_adf_+3A_write_protected">write_protected</code></td>
<td>
<p>A <code>logical</code> value indicating whether the
virtual disk needs to be write protected. If <code>TRUE</code>, you can only open
'read only' connections and cannot write to the disk.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an R connection of class <code>adf_device</code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>adz_file &lt;- system.file("example.adz", package = "adfExplorer")
my_device &lt;- connect_adf(adz_file)

device_capacity(my_device)
close(my_device)
</code></pre>

<hr>
<h2 id='copy_adf_entry'>Copy or move files between physical and virtual devices</h2><span id='topic+copy_adf_entry'></span><span id='topic+copy_adf_entry.character'></span><span id='topic+copy_adf_entry.virtual_path'></span><span id='topic+copy_adf_entry.character.virtual_path'></span><span id='topic+copy_adf_entry.virtual_path.virtual_path'></span><span id='topic+copy_adf_entry.virtual_path.character'></span><span id='topic+move_adf_entry'></span><span id='topic+move_adf_entry.character'></span><span id='topic+move_adf_entry.virtual_path'></span><span id='topic+move_adf_entry.character.virtual_path'></span><span id='topic+move_adf_entry.virtual_path.virtual_path'></span><span id='topic+move_adf_entry.virtual_path.character'></span>

<h3>Description</h3>

<p>With these functions you can copy or move entries (files and directories) between
a physical and virtual ADF device. With <code>copy_adf_entry()</code> the files are duplicated,
with <code>move_adf_entry()</code> the files are moved (and deleted from its source).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>copy_adf_entry(source, destination, ...)

## S3 method for class 'character'
copy_adf_entry(source, destination, ...)

## S3 method for class 'virtual_path'
copy_adf_entry(source, destination, ...)

## S3 method for class 'virtual_path'
copy_adf_entry.character(source, destination, ...)

## S3 method for class 'virtual_path'
copy_adf_entry.virtual_path(source, destination, ...)

## S3 method for class 'character'
copy_adf_entry.virtual_path(source, destination, ...)

move_adf_entry(source, destination, ...)

## S3 method for class 'character'
move_adf_entry(source, destination, ...)

## S3 method for class 'virtual_path'
move_adf_entry(source, destination, ...)

## S3 method for class 'virtual_path'
move_adf_entry.character(source, destination, ...)

## S3 method for class 'virtual_path'
move_adf_entry.virtual_path(source, destination, ...)

## S3 method for class 'character'
move_adf_entry.virtual_path(source, destination, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="copy_adf_entry_+3A_source">source</code>, <code id="copy_adf_entry_+3A_destination">destination</code></td>
<td>
<p>The <code>source</code> is a path to a file or directory that needs
to be moved or copied. <code>destination</code> is a path to a directory to which the <code>source</code>
needs to be copied or moved. When <code>source</code> or <code>destination</code> is a <code>character</code> string,
it is assumed to be a path to a file or directory on a physical device. You
can use a <code><a href="#topic+virtual_path">virtual_path()</a></code> for either the <code>source</code> or <code>destination</code> or both.
<code>source</code> and <code>destination</code> cannot both be a <code>character</code> string. For copying and moving
files on a physical device you should you <code>base</code> function <code><a href="base.html#topic+file.copy">file.copy()</a></code>.</p>
</td></tr>
<tr><td><code id="copy_adf_entry_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Create an Amiga Disk File
## and prepare a file system on the virtual device
my_device &lt;-
  create_adf_device(
    tempfile(fileext = ".adf"),
    write_protected = FALSE) |&gt;
  prepare_adf_device()

## Copy the packaged R scripts of this package to the virtual device
copy_adf_entry(
  system.file("R", package = "adfExplorer"),
  virtual_path(my_device, "DF0:")
)

## List all entries on the virtual device
list_adf_entries(my_device, recursive = TRUE)

## Move the entire virtual device content to
## the tempdir on your physical device
dest &lt;- file.path(tempdir(), "DF0")
dir.create(dest)
move_adf_entry(
  virtual_path(my_device, "DF0:"),
  dest
)

## cleanup the temp directory
unlink(dest, recursive = TRUE)

close(my_device)
</code></pre>

<hr>
<h2 id='create_adf_device'>Create and format a virtual ADF device</h2><span id='topic+create_adf_device'></span><span id='topic+prepare_adf_device'></span><span id='topic+prepare_adf_device.adf_device'></span>

<h3>Description</h3>

<p>These functions help you to create an empty virtual device that can be used
in Commodore Amiga emulation. <code>create_adf_device()</code> simply creates a file
of the proper size (the file size represents the device capacity) and fills it
with <code>raw</code> zeros. In order to use the device in the Amiga operating system, a
file system needs to be installed on the device. This can be achieved with
<code>prepare_adf_device()</code>. Note that the file system itself will also consume
disk space on the virtual device.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_adf_device(destination, type = "DD", ..., connect = TRUE)

prepare_adf_device(
  dev,
  name = "EMPTY",
  ffs = TRUE,
  international = TRUE,
  dircache = FALSE,
  bootable = TRUE,
  ...
)

## S3 method for class 'adf_device'
prepare_adf_device(
  dev,
  name = "EMPTY",
  ffs = TRUE,
  international = TRUE,
  dircache = FALSE,
  bootable = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="create_adf_device_+3A_destination">destination</code></td>
<td>
<p>File path where the virtual device needs to be stored.</p>
</td></tr>
<tr><td><code id="create_adf_device_+3A_type">type</code></td>
<td>
<p>Specify the type of virtual device you wish to create.
Should be one of <code>"DD"</code> (double density floppy disk) or <code>"HD"</code> (high
density floppy disk).</p>
</td></tr>
<tr><td><code id="create_adf_device_+3A_...">...</code></td>
<td>
<p>Ignored for <code>prepare_adf_device()</code>.</p>
</td></tr>
<tr><td><code id="create_adf_device_+3A_connect">connect</code></td>
<td>
<p>A <code>logical</code> value. If set to <code>TRUE</code> a connection is opened to the
newly created virtual device and is returned as a <code>adf_device</code> class object. If
it is set to <code>FALSE</code>, the file is just created and no connection is opened. In the
latter case <code>NULL</code> is returned invisibly.</p>
</td></tr>
<tr><td><code id="create_adf_device_+3A_dev">dev</code></td>
<td>
<p>The virtual adf device for which information needs to be obtained.
It should be of class <code>adf_device</code> which can be created with <code><a href="#topic+create_adf_device">create_adf_device()</a></code>
or <code><a href="#topic+connect_adf">connect_adf()</a></code>.</p>
</td></tr>
<tr><td><code id="create_adf_device_+3A_name">name</code></td>
<td>
<p>A <code>character</code> string specifying the disk name for the volume on the
virtual device. It will be truncated automatically when too long.</p>
</td></tr>
<tr><td><code id="create_adf_device_+3A_ffs">ffs</code></td>
<td>
<p>A <code>logical</code> value indicating which file system to be used. If <code>TRUE</code>
the 'Fast File System' (FFS) is used, when <code>FALSE</code>, the 'Old File System' is used.
See also <code>vignette("file_system_modes")</code>.</p>
</td></tr>
<tr><td><code id="create_adf_device_+3A_international">international</code></td>
<td>
<p>A <code>logical</code> value indicating whether the international mode
should be used for file naming. See also <code>vignette("file_system_modes")</code>.</p>
</td></tr>
<tr><td><code id="create_adf_device_+3A_dircache">dircache</code></td>
<td>
<p>A <code>logical</code> value indicating whether directory caching should be
used. See also <code>vignette("file_system_modes")</code>.</p>
</td></tr>
<tr><td><code id="create_adf_device_+3A_bootable">bootable</code></td>
<td>
<p>A <code>logical</code> value indicating whether you want to include executable
code on the boot block. If set to <code>TRUE</code> minimal code will be added to the boot block.
In an Amiga emulator, this code will load the Amiga Disk Operating System library
and start the Amiga Command line interface (CLI). It will then run the startup
sequence file from the disk (if available).
</p>
<p>If set to <code>FALSE</code> no such code is added. In that case the file system will still be
accessible by the Amiga operating system (if the file system mode is compatible).
You just can't use the disk to start up a (virtual) Amiga machine.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either an <code>adf_device</code> connection or <code>NULL</code> depending on the value of
<code>connect</code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Filepath to store the virtual device:
dest &lt;- tempfile(fileext = ".adf")

## Create a blank unformated virtual device (a double density floppy disk):
my_device &lt;- create_adf_device(dest, "DD", connect = TRUE, write_protected = FALSE)

print(my_device)

## Format the floppy and create a file system on the device:
prepare_adf_device(my_device, name = "foobar")

print(my_device)

## don't forget to close the device connection after use:
close(my_device)
</code></pre>

<hr>
<h2 id='demo_adf'>Connect with a demonstration ADF file</h2><span id='topic+demo_adf'></span>

<h3>Description</h3>

<p>Opens a connection to a virtual device for demonstration purposes
It is used in examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>demo_adf(write_protected = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="demo_adf_+3A_write_protected">write_protected</code></td>
<td>
<p>A <code>logical</code> value. When <code>TRUE</code> you can only read
from the virtual device. If <code>FALSE</code> the demonstration disk will be
copied to the <code>tempdir()</code> and you can write to it.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a connection to a virtual device of class <code>adf_device</code>
</p>

<hr>
<h2 id='device_type'>Obtain information about an <code>adf_device</code> connection</h2><span id='topic+device_type'></span><span id='topic+device_type.adf_device'></span><span id='topic+device_capacity'></span><span id='topic+device_capacity.adf_device'></span><span id='topic+volume_capacity'></span><span id='topic+volume_capacity.adf_device'></span><span id='topic+volume_name'></span><span id='topic+volume_name+3C-'></span><span id='topic+volume_name.adf_device'></span><span id='topic+volume_name+3C-.adf_device'></span><span id='topic+n_volumes'></span><span id='topic+n_volumes.adf_device'></span><span id='topic+bytes_free'></span><span id='topic+bytes_free.adf_device'></span><span id='topic+is_bootable'></span><span id='topic+is_bootable.adf_device'></span><span id='topic+is_fast_file_system'></span><span id='topic+is_fast_file_system.adf_device'></span><span id='topic+is_international'></span><span id='topic+is_international.adf_device'></span><span id='topic+is_dircache'></span><span id='topic+is_dircache.adf_device'></span><span id='topic+is_write_protected'></span><span id='topic+is_write_protected.adf_device'></span>

<h3>Description</h3>

<p>A collection of functions to retrieve information about the virtual device, or
any volume (file system) available on the device. See examples for usage and
results.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>device_type(dev, ...)

## S3 method for class 'adf_device'
device_type(dev, ...)

device_capacity(dev, ...)

## S3 method for class 'adf_device'
device_capacity(dev, ...)

volume_capacity(dev, ...)

## S3 method for class 'adf_device'
volume_capacity(dev, vol = 0L, ...)

volume_name(dev, ...)

volume_name(dev, ...) &lt;- value

## S3 method for class 'adf_device'
volume_name(dev, vol = 0L, ...)

## S3 replacement method for class 'adf_device'
volume_name(dev, vol = 0L, ...) &lt;- value

n_volumes(dev, ...)

## S3 method for class 'adf_device'
n_volumes(dev, ...)

bytes_free(dev, ...)

## S3 method for class 'adf_device'
bytes_free(dev, vol = 0L, ...)

is_bootable(dev, ...)

## S3 method for class 'adf_device'
is_bootable(dev, vol = 0L, ...)

is_fast_file_system(dev, ...)

## S3 method for class 'adf_device'
is_fast_file_system(dev, vol = 0L, ...)

is_international(dev, ...)

## S3 method for class 'adf_device'
is_international(dev, vol = 0L, ...)

is_dircache(dev, ...)

## S3 method for class 'adf_device'
is_dircache(dev, vol = 0L, ...)

is_write_protected(dev, ...)

## S3 method for class 'adf_device'
is_write_protected(dev, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="device_type_+3A_dev">dev</code></td>
<td>
<p>The virtual adf device for which information needs to be obtained.
It should be of class <code>adf_device</code> which can be created with <code><a href="#topic+create_adf_device">create_adf_device()</a></code>
or <code><a href="#topic+connect_adf">connect_adf()</a></code>.</p>
</td></tr>
<tr><td><code id="device_type_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="device_type_+3A_vol">vol</code></td>
<td>
<p>Volume index number on the device starting at <code>0</code>. Default is <code>0</code>.
Note that floppy disks can only have 1 volume installed.</p>
</td></tr>
<tr><td><code id="device_type_+3A_value">value</code></td>
<td>
<p>Replacement value. In case of <code>volume_name()</code> it can be used to
assign a new name to the volume.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the requested information, or an updated copy of <code>dev</code> in case
of an assign operation (<code style="white-space: pre;">&#8288;&lt;-&#8288;</code>).
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Open virtual device to demonstrate methods
my_device &lt;- demo_adf(write_protected = FALSE)

device_type(my_device)

device_capacity(my_device) # in bytes

volume_capacity(my_device) # in bytes

n_volumes(my_device) # number of volumes available on device

volume_name(my_device) # name of the volume

volume_name(my_device) &lt;- "new_name" # rename the volume

bytes_free(my_device) # bytes available for writing

is_bootable(my_device) # tests if device is potentially bootable

is_fast_file_system(my_device) # tests if volume uses FFS

is_international(my_device) # tests if file system uses intl mode

is_dircache(my_device) # tests if file system uses dir caching

is_write_protected(my_device) # tests if device is protected against writing

close(my_device)
</code></pre>

<hr>
<h2 id='format.adf_device'>Basic methods for S3 class objects</h2><span id='topic+format.adf_device'></span><span id='topic+format.adf_file_con'></span><span id='topic+format.adf_block'></span><span id='topic+format.virtual_path'></span><span id='topic+print.adf_device'></span><span id='topic+print.adf_file_con'></span><span id='topic+print.adf_block'></span><span id='topic+print.virtual_path'></span><span id='topic+as.character.virtual_path'></span>

<h3>Description</h3>

<p>Format and print methods for all S3 class objects created with <code>adfExplorer</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'adf_device'
format(x, ...)

## S3 method for class 'adf_file_con'
format(x, ...)

## S3 method for class 'adf_block'
format(x, ...)

## S3 method for class 'virtual_path'
format(x, width = 20L, ...)

## S3 method for class 'adf_device'
print(x, ...)

## S3 method for class 'adf_file_con'
print(x, ...)

## S3 method for class 'adf_block'
print(x, ...)

## S3 method for class 'virtual_path'
print(x, ...)

## S3 method for class 'virtual_path'
as.character(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="format.adf_device_+3A_x">x</code></td>
<td>
<p>Object to be formatted or printed</p>
</td></tr>
<tr><td><code id="format.adf_device_+3A_...">...</code></td>
<td>
<p>Ignored or passed on to next methods</p>
</td></tr>
<tr><td><code id="format.adf_device_+3A_width">width</code></td>
<td>
<p>Set the text width for formatting virtual paths</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>my_device &lt;- demo_adf()
vp        &lt;- list_adf_entries(my_device, recursive = TRUE)
con       &lt;- adf_file_con(my_device, "s/startup-sequence")
block     &lt;- read_adf_block(my_device, 0L)

format(my_device)
format(vp)
format(con)
format(block)

print(my_device)
print(vp)
print(con)
print(block)

close(con)
close(my_device)
</code></pre>

<hr>
<h2 id='list_adf_entries'>List entries in a directory of a virtual ADF device</h2><span id='topic+list_adf_entries'></span><span id='topic+list_adf_entries.adf_device'></span><span id='topic+list_adf_entries.virtual_path'></span><span id='topic+list_adf_entries.adf_device.character'></span><span id='topic+list_adf_entries.adf_device.virtual_path'></span>

<h3>Description</h3>

<p>Get an overview of all entries (files and directories) in a specific
directory.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_adf_entries(x, path, recursive = FALSE, nested = FALSE, ...)

## S3 method for class 'adf_device'
list_adf_entries(x, path, recursive = FALSE, nested = FALSE, ...)

## S3 method for class 'virtual_path'
list_adf_entries(x, path, recursive = FALSE, nested = FALSE, ...)

## S3 method for class 'character'
list_adf_entries.adf_device(x, path, recursive = FALSE, nested = FALSE, ...)

## S3 method for class 'virtual_path'
list_adf_entries.adf_device(x, path, recursive = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="list_adf_entries_+3A_x">x</code></td>
<td>
<p>Either an <code>adf_device</code> class object, in which case the <code>virtual_path</code>
argument needs to be specified; or, a <code>virtual_path</code> class object.</p>
</td></tr>
<tr><td><code id="list_adf_entries_+3A_path">path</code></td>
<td>
<p>The virtual path for which you wish to obtain a list
of entries (see also <code>vignette("virtual_paths")</code>). When missing,
entries for the current directory (<code><a href="#topic+adf_directory">adf_directory()</a></code>) are returned, wen
<code>x</code> is an <code>adf_device</code> class object. If <code>x</code> is a <code>virtual_path</code> class
object, content of the path defined in that object is listed</p>
</td></tr>
<tr><td><code id="list_adf_entries_+3A_recursive">recursive</code></td>
<td>
<p>A <code>logical</code> value. When set to <code>TRUE</code>, the function is
called recursively for all subdirectories in <code>path</code>.</p>
</td></tr>
<tr><td><code id="list_adf_entries_+3A_nested">nested</code></td>
<td>
<p>A <code>logical</code> value. When set to The directory tree is returned
as a nested list.</p>
</td></tr>
<tr><td><code id="list_adf_entries_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector of <code>virtual_path</code> class objects, or a nested <code>list</code> in
case <code>nested</code> is <code>TRUE</code>.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## First setup a connection to a virtual device
my_device &lt;- demo_adf()

## List all entries in the disk's root:
list_adf_entries(my_device)

## List all entries on the disk as a vector of `virtual paths`:
list_adf_entries(my_device, recursive = TRUE)

##  List all entries on the disk as a nested list:
list_adf_entries(my_device, recursive = TRUE, nested = TRUE)

close(my_device)
</code></pre>

<hr>
<h2 id='read_adf_block'>Read or write raw data blocks to a virtual device</h2><span id='topic+read_adf_block'></span><span id='topic+read_adf_block.adf_device'></span><span id='topic+write_adf_block'></span><span id='topic+write_adf_block.adf_device'></span><span id='topic+write_adf_block.adf_device.raw'></span><span id='topic+write_adf_block.adf_device.adf_block'></span><span id='topic+write_adf_block.adf_device.default'></span><span id='topic+as_adf_block'></span><span id='topic+new_adf_block'></span>

<h3>Description</h3>

<p>The Amiga file system is structured around 512 byte blocks. A double density
floppy disk consists of 1760 blocks of 512 bytes. <code>read_adf_block</code> and <code>write_adf_block</code>
can be used to transform raw data from and to virtual devices (created with
<code><a href="#topic+create_adf_device">create_adf_device()</a></code> or <code><a href="#topic+connect_adf">connect_adf()</a></code>). Note that writing raw data to
a disk could corrupt the file system on the device. So it is generally not
advised unless you know what you are doing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>read_adf_block(dev, sector, ...)

## S3 method for class 'adf_device'
read_adf_block(dev, sector, ...)

write_adf_block(dev, sector, data, ...)

## S3 method for class 'adf_device'
write_adf_block(dev, sector, data, ...)

## S3 method for class 'raw'
write_adf_block.adf_device(dev, sector, data, ...)

## S3 method for class 'adf_block'
write_adf_block.adf_device(dev, sector, data, ...)

## Default S3 method:
write_adf_block.adf_device(dev, sector, data, ...)

as_adf_block(data, ...)

new_adf_block()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="read_adf_block_+3A_dev">dev</code></td>
<td>
<p>The virtual adf device for which information needs to be obtained.
It should be of class <code>adf_device</code> which can be created with <code><a href="#topic+create_adf_device">create_adf_device()</a></code>
or <code><a href="#topic+connect_adf">connect_adf()</a></code>.</p>
</td></tr>
<tr><td><code id="read_adf_block_+3A_sector">sector</code></td>
<td>
<p>Sector ID of the block you wish to read/write. It is an integer value.
For double density disks, the ID ranges from 0 to 1759.</p>
</td></tr>
<tr><td><code id="read_adf_block_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="read_adf_block_+3A_data">data</code></td>
<td>
<p>Block data (<code>raw</code> vector of length 512) you wish to write to a virtual device</p>
</td></tr>
</table>


<h3>Value</h3>

<p>In case of <code>write_adf_block</code> <code>NULL</code> is returned invisibly. In case of <code>read_adf_block</code>
the <code>raw</code> data is returned as a <code>adf_block</code> class object.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>Examples</h3>

<pre><code class='language-R'>my_device &lt;- demo_adf(write_protected = FALSE)

info &lt;- adf_entry_info(my_device, "S/startup-sequence")

filedata_block &lt;- read_adf_block(my_device, rev(info[[1]]$dataBlocks)[[1]])
filedata_block

empty_block &lt;- new_adf_block()
empty_block &lt;- as_adf_block(raw(512L))

## Write some random data to block 5 on the device
## Note that this could break the file system on the virtual device!
write_adf_block(my_device, 5, as.raw(runif(512, 0, 255)))
## converting the data to an adf block object first
## is optional:
write_adf_block(my_device, 6, as_adf_block(as.raw(runif(512, 0, 255))))
close(my_device)
</code></pre>

<hr>
<h2 id='readBin'>Transfer binary data to and from connections</h2><span id='topic+readBin'></span><span id='topic+readBin.default'></span><span id='topic+readBin.adf_file_con'></span><span id='topic+readLines'></span><span id='topic+readLines.default'></span><span id='topic+readLines.adf_file_con'></span><span id='topic+writeBin'></span><span id='topic+writeBin.default'></span><span id='topic+writeBin.adf_file_con'></span><span id='topic+writeLines'></span><span id='topic+writeLines.default'></span><span id='topic+writeLines.adf_file_con'></span>

<h3>Description</h3>

<p>These methods mask the identical functions in the <code>base</code> package (see <code><a href="base.html#topic+readBin">base::readBin()</a></code>,
<code><a href="base.html#topic+readLines">base::readLines()</a></code>, <code><a href="base.html#topic+readChar">base::readChar()</a></code>, <code><a href="base.html#topic+readBin">base::writeBin()</a></code>, <code><a href="base.html#topic+writeLines">base::writeLines()</a></code> and
<code><a href="base.html#topic+readChar">base::writeChar()</a></code>. They behave exactly the
same as their base counterpart, with the exception that they can read and write to connections
opened with <code>adf_file_con()</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>readBin(
  con,
  what,
  n = 1L,
  size = NA_integer_,
  signed = TRUE,
  endian = .Platform$endian
)

## Default S3 method:
readBin(
  con,
  what,
  n = 1L,
  size = NA_integer_,
  signed = TRUE,
  endian = .Platform$endian
)

## S3 method for class 'adf_file_con'
readBin(
  con,
  what,
  n = 1L,
  size = NA_integer_,
  signed = TRUE,
  endian = .Platform$endian
)

readLines(
  con,
  n = -1L,
  ok = TRUE,
  warn = TRUE,
  encoding = "unknown",
  skipNul = FALSE
)

## Default S3 method:
readLines(
  con = stdin(),
  n = -1L,
  ok = TRUE,
  warn = TRUE,
  encoding = "unknown",
  skipNul = FALSE
)

## S3 method for class 'adf_file_con'
readLines(
  con,
  n = -1L,
  ok = TRUE,
  warn = TRUE,
  encoding = "unknown",
  skipNul = FALSE
)

writeBin(
  object,
  con,
  size = NA_integer_,
  endian = .Platform$endian,
  useBytes = FALSE
)

## Default S3 method:
writeBin(
  object,
  con,
  size = NA_integer_,
  endian = .Platform$endian,
  useBytes = FALSE
)

## S3 method for class 'adf_file_con'
writeBin(
  object,
  con,
  size = NA_integer_,
  endian = .Platform$endian,
  useBytes = FALSE
)

writeLines(text, con, sep = "\n", useBytes = FALSE)

## Default S3 method:
writeLines(text, con = stdout(), sep = "\n", useBytes = FALSE)

## S3 method for class 'adf_file_con'
writeLines(text, con = stdout(), sep = "\n", useBytes = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="readBin_+3A_con">con</code></td>
<td>
<p>A connection to a file on a virtual ADF device. Such a connection can
be established with <code>adf_file_con()</code>.</p>
</td></tr>
<tr><td><code id="readBin_+3A_what">what</code></td>
<td>
<p>Either an object whose mode will give the mode of the
vector to be read, or a character vector of length one describing
the mode: one of <code>"numeric"</code>, <code>"double"</code>,
<code>"integer"</code>, <code>"int"</code>, <code>"logical"</code>, <code>"complex"</code>,
<code>"character"</code>, <code>"raw"</code>.</p>
</td></tr>
<tr><td><code id="readBin_+3A_n">n</code></td>
<td>
<p>numeric.  The (maximal) number of records to be
read.  You can use an over-estimate here, but not too large as
storage is reserved for <code>n</code> items.</p>
</td></tr>
<tr><td><code id="readBin_+3A_size">size</code></td>
<td>
<p>integer.  The number of bytes per element in the byte
stream.  The default, <code>NA_integer_</code>, uses the natural size.
Size changing is not supported for raw and complex vectors.</p>
</td></tr>
<tr><td><code id="readBin_+3A_signed">signed</code></td>
<td>
<p>logical.  Only used for integers of sizes 1 and 2,
when it determines if the quantity on file
should be regarded as a signed or unsigned integer.</p>
</td></tr>
<tr><td><code id="readBin_+3A_endian">endian</code></td>
<td>
<p>The endian-ness (<code>"big"</code> or <code>"little"</code>) of the
target system for the file.  Using <code>"swap"</code> will force swapping
endian-ness.</p>
</td></tr>
<tr><td><code id="readBin_+3A_ok">ok</code></td>
<td>
<p>logical.  Is it OK to reach the end of the connection before
<code>n &gt; 0</code> lines are read?  If not, an error will be generated.</p>
</td></tr>
<tr><td><code id="readBin_+3A_warn">warn</code></td>
<td>
<p>logical.  Warn if a text file is missing a final EOL or if
there are embedded nuls in the file.</p>
</td></tr>
<tr><td><code id="readBin_+3A_encoding">encoding</code></td>
<td>
<p>encoding to be assumed for input strings.  It is
used to mark character strings as known to be in
Latin-1, UTF-8 or to be bytes: it is not used to re-encode the input.
To do the
latter, specify the encoding as part of the connection <code>con</code> or
via <code><a href="base.html#topic+options">options</a>(encoding=)</code>: see the examples
and &lsquo;Details&rsquo;.
</p>
</td></tr>
<tr><td><code id="readBin_+3A_skipnul">skipNul</code></td>
<td>
<p>logical: should nuls be skipped?</p>
</td></tr>
<tr><td><code id="readBin_+3A_object">object</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object to be written to the connection.</p>
</td></tr>
<tr><td><code id="readBin_+3A_usebytes">useBytes</code></td>
<td>
<p>See <code><a href="base.html#topic+writeLines">writeLines</a></code>.</p>
</td></tr>
<tr><td><code id="readBin_+3A_text">text</code></td>
<td>
<p>A character vector</p>
</td></tr>
<tr><td><code id="readBin_+3A_sep">sep</code></td>
<td>
<p>character string.  A string to be written to the connection
after each line of text.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns <code>NULL</code> invisibly
</p>

<hr>
<h2 id='remove_adf_entry'>Remove entry (file / directory) from a virtual ADF device</h2><span id='topic+remove_adf_entry'></span><span id='topic+remove_adf_entry.adf_device'></span><span id='topic+remove_adf_entry.virtual_path'></span><span id='topic+remove_adf_entry.adf_device.character'></span><span id='topic+remove_adf_entry.adf_device.virtual_path'></span>

<h3>Description</h3>

<p>This function removes an entry (file or directory) from a virtual ADF device. At the moment
this function only removes a single entry per call, and in case the entry is a directory,
the directory needs to be empty before it can be removed.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>remove_adf_entry(x, path, flush = FALSE, ...)

## S3 method for class 'adf_device'
remove_adf_entry(x, path, flush = FALSE, ...)

## S3 method for class 'virtual_path'
remove_adf_entry(x, path, flush = FALSE, ...)

## S3 method for class 'character'
remove_adf_entry.adf_device(x, path, flush = FALSE, ...)

## S3 method for class 'virtual_path'
remove_adf_entry.adf_device(x, path, flush = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="remove_adf_entry_+3A_x">x</code></td>
<td>
<p>The virtual ADF device from which an entry needs to be deleted or a virtual path pointing
at the entry to be deleted. In case of a virtual device, it should be of class <code>adf_device</code> which
can be created with <code><a href="#topic+create_adf_device">create_adf_device()</a></code> or <code><a href="#topic+connect_adf">connect_adf()</a></code>. In case of a virtual path use
<code><a href="#topic+virtual_path">virtual_path()</a></code>.</p>
</td></tr>
<tr><td><code id="remove_adf_entry_+3A_path">path</code></td>
<td>
<p>A <code>character</code> string or a virtual_path (see <code><a href="#topic+virtual_path">virtual_path()</a></code>)
representing a file or directory you wish to delete. Should be omitted when <code>x</code> is already a
virtual path.</p>
</td></tr>
<tr><td><code id="remove_adf_entry_+3A_flush">flush</code></td>
<td>
<p>A <code>logical</code> value. When set to <code>FALSE</code> (default), only the entry's registry in its
parent directory is removed and its flags in the bitmap block are set to 'available'. The entry's
header data and if the entry is a file, the file data will still linger on the virtual disk.
If you don't want that, set this argument to <code>TRUE</code>, in that case all file or directory data will
be purged. Note that in the latter case, it won't be possible to recover your deleted file or directory.</p>
</td></tr>
<tr><td><code id="remove_adf_entry_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns the device connection
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Open a connection to a virtual device:
my_device &lt;- demo_adf(write_protected = FALSE)

## List files in directory 'Devs':
list_adf_entries(my_device, "Devs")

## remove the file 'system-configuration' from the virtual device
remove_adf_entry(my_device, "devs/system-configuration")

## List files in directory 'Devs' again:
list_adf_entries(my_device, "Devs")

## close the connection to the virtual device
close(my_device)
</code></pre>

<hr>
<h2 id='virtual_path'>A path pointing to a file or directory on a virtual ADF device</h2><span id='topic+virtual_path'></span>

<h3>Description</h3>

<p>This function creates a path pointing to a file or directory
on a virtual ADF device (created with <code><a href="#topic+connect_adf">connect_adf()</a></code> or <code><a href="#topic+create_adf_device">create_adf_device()</a></code>).
The virtual path created with this function can be used to establish a readable
or writable connection to a file, or obtain information about a file or directory.
See also <code>vignette("virtual_paths")</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>virtual_path(dev, path)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="virtual_path_+3A_dev">dev</code></td>
<td>
<p>A virtual ADF device (created with <code><a href="#topic+connect_adf">connect_adf()</a></code> or
<code><a href="#topic+create_adf_device">create_adf_device()</a></code>).
Make sure a file system is present on the virtual device or install first when missing
using <code><a href="#topic+prepare_adf_device">prepare_adf_device()</a></code>.</p>
</td></tr>
<tr><td><code id="virtual_path_+3A_path">path</code></td>
<td>
<p>A <code>character</code> string representing the path to a file or directory
on the virtual device.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a <code>virtual_path</code> class object.
</p>


<h3>Author(s)</h3>

<p>Pepijn de Vries
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Open a connection to a virtual device:
my_device &lt;- demo_adf()

# specify a virtual path:
my_path &lt;- virtual_path(my_device, "DF0:s/startup-sequence")

# close the virtual device:
close(my_device)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
