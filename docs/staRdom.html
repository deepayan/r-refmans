<!DOCTYPE html><html lang="en"><head><title>Help for package staRdom</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {staRdom}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#.eem_csv'><p>Import EEMs from generic csv files.</p></a></li>
<li><a href='#.trans_parafac'><p>Add data of a PARAFAC model derived from multiway from EEMs</p></a></li>
<li><a href='#A_missing'><p>Calculate the sample loadings for samples not involved in model building</p></a></li>
<li><a href='#abs_blcor'><p>Baseline correction for absorbance data</p></a></li>
<li><a href='#abs_fit_slope'><p>Fit absorbance data to exponential curve. <code>drm</code> is used for the fitting process.</p></a></li>
<li><a href='#abs_parms'><p>Calculating slopes and slope ratios of a data frame of absorbance data.</p></a></li>
<li><a href='#absorbance_read'><p>Reading absorbance data from txt and csv files.</p></a></li>
<li><a href='#as.data.frame.eem'><p>Converting EEM data from class eem to data.frame.</p></a></li>
<li><a href='#eem_absdil'><p>Multiply absorbance data according to the dilution and remove absorbance from samples where undiluted data is used.</p></a></li>
<li><a href='#eem_apply'><p>Applying functions on EEMs</p></a></li>
<li><a href='#eem_checkdata'><p>Check your EEM, absorption and metadata before processing</p></a></li>
<li><a href='#eem_checksize'><p>Check size of EEMs</p></a></li>
<li><a href='#eem_corrections'><p>Return names of samples where certain corrections are missing.</p></a></li>
<li><a href='#eem_csv'><p>Importer function for generic csv files to be used with eem_read().</p></a></li>
<li><a href='#eem_csv2'><p>Importer function for generic csv files to be used with eem_read().</p></a></li>
<li><a href='#eem_dilcorr'><p>Create table how samples should be corrected because of dilution</p></a></li>
<li><a href='#eem_dilution'><p>Modifying fluorescence data according to dilution.</p></a></li>
<li><a href='#eem_duplicates'><p>Check for duplicate sample names</p></a></li>
<li><a href='#eem_easy'><p>Opens an R markdown template for an easy and userfriendly analysis of EEM data.</p></a></li>
<li><a href='#eem_eemdil'><p>Correct names of EEM samples to match undiluted absorbance data.</p></a></li>
<li><a href='#eem_exclude'><p>Exclude complete wavelengths or samples form data set</p></a></li>
<li><a href='#eem_export'><p>Export all samples of an eem_list</p></a></li>
<li><a href='#eem_extend2largest'><p>EEM sample data is extended to include all wavelengths in all samples</p></a></li>
<li><a href='#eem_getextreme'><p>Determines the the biggest range of EEM spectrum where data is available from each sample.</p></a></li>
<li><a href='#eem_hitachi'><p>Importer function for Hitachi F-7000 txt files to be used with eem_read().</p></a></li>
<li><a href='#eem_ife_correction'><p>Wrapper function to allow eem_inner_filter_effect (eemR) handling different cuvette lengths.</p></a></li>
<li><a href='#eem_import_dir'><p>Load all eemlist obects saved in different Rdata or RDa files in a folder.</p></a></li>
<li><a href='#eem_interp'><p>Missing values are interpolated within EEM data</p></a></li>
<li><a href='#eem_is.na'><p>Check for NAs in EEM data</p></a></li>
<li><a href='#eem_list'><p>15 fluorescence samples from drEEM used for examples.</p></a></li>
<li><a href='#eem_list_outliers'><p>2 fluorescence samples from drEEM that were excluded as outliers from the PARAFAC model.</p></a></li>
<li><a href='#eem_load_dreem'><p>Load original data from the drEEM tutorial and return it as eemlist</p></a></li>
<li><a href='#eem_matmult'><p>Multiply all EEMs with a matrix</p></a></li>
<li><a href='#eem_metatemplate'><p>Create table that contains sample names and locations of files.</p></a></li>
<li><a href='#eem_name_replace'><p>Replace matched patterns in sample names</p></a></li>
<li><a href='#eem_overview_plot'><p>Plot fluorescence data from several samples split into several plots.</p></a></li>
<li><a href='#eem_parafac'><p>Runs a PARAFAC analysis on EEM data</p></a></li>
<li><a href='#eem_raman_area'><p>Calculate raman area of EEM samples</p></a></li>
<li><a href='#eem_raman_normalisation2'><p>Wrapper function to eem_raman_normalisation (eemR).</p></a></li>
<li><a href='#eem_range'><p>Cut EEM data matching a given wavelength range</p></a></li>
<li><a href='#eem_read_csv'><p>Import EEMs from generic csv tables (deprecated)</p></a></li>
<li><a href='#eem_red2smallest'><p>Remove wavelengths, that are missing in at least one sample form the whole set.</p></a></li>
<li><a href='#eem_rem_scat'><p>Remove Raman and Rayleigh scattering in fluorescence data</p></a></li>
<li><a href='#eem_scale_ext'><p>Determine the range of fluorescence values in a set of samples</p></a></li>
<li><a href='#eem_setNA'><p>set parts of specific samples to NA and optionally interpolate these parts</p></a></li>
<li><a href='#eem_smooth'><p>Smooth fluorescence data by calculating rolling mean along excitation wavelengths.</p></a></li>
<li><a href='#eem_spectral_cor'><p>Multiply EEMs with spectral correction vectors (Emission and Excitation)</p></a></li>
<li><a href='#eem_write_csv'><p>Export samples in an EEM list to a single csv files</p></a></li>
<li><a href='#eem2array'><p>Data from an eemlist is transformed into an array</p></a></li>
<li><a href='#eempf_bindxc'><p>Combining extracted components of PARAFAC models</p></a></li>
<li><a href='#eempf_comp_load_plot'><p>Plot components from a PARAFAC model</p></a></li>
<li><a href='#eempf_comp_mat'><p>Extract EEM matrix for single components determined in the PARAFAC analysis</p></a></li>
<li><a href='#eempf_comp_names'><p>Extract names from PARAFAC model components</p></a></li>
<li><a href='#eempf_comp_names+26lt+3B-'><p>Set names of PARAFAC components</p></a></li>
<li><a href='#eempf_compare'><p>Plot a set of PARAFAC models to compare the single components</p></a></li>
<li><a href='#eempf_comps3D'><p>3D plots of PARAFAC components</p></a></li>
<li><a href='#eempf_convergence'><p>Extract modelling information from a PARAFAC model.</p></a></li>
<li><a href='#eempf_corcondia'><p>Calculate the core consistancy of an EEM PARAFAC model</p></a></li>
<li><a href='#eempf_corplot'><p>Plot correlations of components in samples</p></a></li>
<li><a href='#eempf_cortable'><p>Calculating correlations between the component loadings in all samples (C-Modes).</p></a></li>
<li><a href='#eempf_eemqual'><p>Calculating EEMqual which is an indicator of a PARAFAC model's quality</p></a></li>
<li><a href='#eempf_excomp'><p>Extracting components of a PARAFAC model</p></a></li>
<li><a href='#eempf_export'><p>Create one table containing the PARAFAC models factors and optionally exporting it to csv or txt</p></a></li>
<li><a href='#eempf_fits'><p>Fits vs. components of PARAFAC models are plotted</p></a></li>
<li><a href='#eempf_leverage'><p>Calculate the leverage of each emission and excitation wavelength and each sample from a single PARAFAC model</p></a></li>
<li><a href='#eempf_leverage_data'><p>Combine leverages into one data frame and add optional labels.</p></a></li>
<li><a href='#eempf_leverage_ident'><p>Plot leverage of emission wavelengths, excitation wavelengths and samples.</p></a></li>
<li><a href='#eempf_leverage_plot'><p>Plot leverage of emission wavelengths, excitation wavelengths and samples.</p></a></li>
<li><a href='#eempf_load_plot'><p>Plot amount of each component in each sample as bar plot</p></a></li>
<li><a href='#eempf_mleverage'><p>Calculate the leverage of each emission and excitation wavelength and each sample from a list of PARAFAC models</p></a></li>
<li><a href='#eempf_OF_upload'><p>Upload PARAFAC models to openfluor.org</p></a></li>
<li><a href='#eempf_openfluor'><p>Write out PARAFAC components to submit to openfluor.org.</p></a></li>
<li><a href='#eempf_plot_comps'><p>Plot all components of PARAFAC models</p></a></li>
<li><a href='#eempf_plot_ssccheck'><p>Plot results from an SSC check</p></a></li>
<li><a href='#eempf_reorder'><p>Reorder PARAFAC components</p></a></li>
<li><a href='#eempf_report'><p>Create a html report of a PARAFAC analysis</p></a></li>
<li><a href='#eempf_rescaleBC'><p>Rescale B and C modes of PARAFAC model</p></a></li>
<li><a href='#eempf_residuals'><p>Calculate residuals of EEM data according to a certain model</p></a></li>
<li><a href='#eempf_residuals_metrics'><p>Calculate residual metrics from a PARAFAC model</p></a></li>
<li><a href='#eempf_residuals_plot'><p>Plot samples by means of whole sample, each single component and residuum</p></a></li>
<li><a href='#eempf_ssc'><p>Calculate the shift-and shape-sensitive congruence (SSC) between model components</p></a></li>
<li><a href='#eempf_ssccheck'><p>Check SSCs between different models or initialisations of one model</p></a></li>
<li><a href='#eempf_varimp'><p>Calculate the importance of each component.</p></a></li>
<li><a href='#eempf4analysis'><p>Create table of PARAFAC components and (optionally) EEM peaks and indices as well as absorbance slope parameters.</p></a></li>
<li><a href='#ggeem'><p>EEM spectra plotted with ggplot2</p></a></li>
<li><a href='#list_join'><p>Full join of a list of data frames.</p></a></li>
<li><a href='#maxlines'><p>Extract data from emission and excitation wavelengths of the components of a PARAFAC model (scaled B- and C-modes)</p></a></li>
<li><a href='#norm_array'><p>Normalise 3-dimensional array in first and second dimension</p></a></li>
<li><a href='#norm2A'><p>Compensate for normalisation in C-modes</p></a></li>
<li><a href='#parafac_conv'><p>Calculate a PARAFAC model similar to and using <code>parafac</code>.</p></a></li>
<li><a href='#pf1'><p>PARAFAC model, see vignette, unconstrained</p></a></li>
<li><a href='#pf1n'><p>PARAFAC model, see vignette, non-negative constraints</p></a></li>
<li><a href='#pf2'><p>PARAFAC model, see vignette, non-negative constraints, normalised</p></a></li>
<li><a href='#pf3'><p>PARAFAC model, see vignette, non-negative constraints, normalised, outliers removed</p></a></li>
<li><a href='#pf4'><p>PARAFAC model, see vignette, non-negative constraints, normalised, outliers removed, high accuarcy</p></a></li>
<li><a href='#sh'><p>result from PARAFAC split-half analysis, periodic data split</p></a></li>
<li><a href='#splithalf'><p>Running a Split-Half analysis on a PARAFAC model</p></a></li>
<li><a href='#splithalf_plot'><p>Plot results from a splithalf analysis</p></a></li>
<li><a href='#splithalf_splits'><p>Extracting a list of sample names in each subsample from a splithalf analysis</p></a></li>
<li><a href='#splithalf_tcc'><p>Extracting TCC values from a splithalf analysis</p></a></li>
<li><a href='#ssc'><p>Calculate the shift-and shape-sensitive congruence (SSC) between two matrices</p></a></li>
<li><a href='#ssc_max'><p>Calculate the combination of components giving the maximum of geometric mean of TCCs</p></a></li>
<li><a href='#tcc'><p>Caluclate Tucker's Congruence Coefficient of PARAFAC components</p></a></li>
<li><a href='#tcc_find_pairs'><p>Reorders components of different PARAFAC models according to best fit (TCC)</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>PARAFAC Analysis of EEMs from DOM</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.28</td>
</tr>
<tr>
<td>Date:</td>
<td>2023-06-15</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 4.3), ggplot2 (&ge; 3.4.2), eemR (&ge; 1.0.1), parallel (&ge;
4.3)</td>
</tr>
<tr>
<td>Description:</td>
<td>This is a user-friendly way to run a parallel factor (PARAFAC) analysis (Harshman, 1971) &lt;<a href="https://doi.org/10.1121%2F1.1977523">doi:10.1121/1.1977523</a>&gt; on excitation emission matrix (EEM) data from dissolved organic matter (DOM) samples (Murphy et al., 2013) &lt;<a href="https://doi.org/10.1039%2Fc3ay41160e">doi:10.1039/c3ay41160e</a>&gt;. The analysis includes profound methods for model validation. Some additional functions allow the calculation of absorbance slope parameters and create beautiful plots.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/AGPL-3">AGPL</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>dplyr (&ge; 1.1.2), tidyr (&ge; 1.3.0), stringr (&ge; 1.5.0), pracma
(&ge; 2.3.3), zoo (&ge; 1.8-12), tibble (&ge; 3.2.1), multiway (&ge;
1.0-6), GGally (&ge; 2.1.2), graphics (&ge; 4.3), doParallel (&ge;
1.0.16), drc (&ge; 3.0-1), foreach (&ge; 1.5.1), data.table (&ge;
1.14.8), matrixStats (&ge; 1.0.0), MBA(&ge; 0.1-0), cdom(&ge; 0.1.0),
R.matlab(&ge; 3.7.0), readr(&ge; 2.1.4), gtools(&ge; 3.9.4),
viridisLite(&ge; 0.4.2)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>plotly(&ge; 4.9.3), xlsx(&ge; 0.6.5), knitr(&ge; 1.31),
kableExtra(&ge; 1.3.4), askpass(&ge; 1.1), httr(&ge; 1.4.2),
rmarkdown(&ge; 2.6)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://cran.r-project.org/package=staRdom">https://cran.r-project.org/package=staRdom</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/MatthiasPucher/staRdom/issues">https://github.com/MatthiasPucher/staRdom/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-06-15 08:16:23 UTC; maetz</td>
</tr>
<tr>
<td>Author:</td>
<td>Matthias Pucher [aut, cre],
  Daniel Graeber [aut, ctb],
  Stefan Preiner [ctb],
  Renata Pinto [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Matthias Pucher &lt;matthias.pucher@gmx.net&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-06-16 08:20:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='.eem_csv'>Import EEMs from generic csv files.</h2><span id='topic+.eem_csv'></span>

<h3>Description</h3>

<p>Import EEMs from generic csv files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.eem_csv(file, col = "ex")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".eem_csv_+3A_file">file</code></td>
<td>
<p>path to file</p>
</td></tr>
<tr><td><code id=".eem_csv_+3A_col">col</code></td>
<td>
<p>either &quot;ex&quot; or &quot;em&quot;, whatever wavelength is arranged in columns</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with EEM data
</p>

<hr>
<h2 id='.trans_parafac'>Add data of a PARAFAC model derived from multiway from EEMs</h2><span id='topic+.trans_parafac'></span>

<h3>Description</h3>

<p>Add data of a PARAFAC model derived from multiway from EEMs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>.trans_parafac(parafac, em, ex, samples, comp, const, norm_factors)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id=".trans_parafac_+3A_parafac">parafac</code></td>
<td>
<p>parafac model</p>
</td></tr>
<tr><td><code id=".trans_parafac_+3A_em">em</code></td>
<td>
<p>emission wavelengths</p>
</td></tr>
<tr><td><code id=".trans_parafac_+3A_ex">ex</code></td>
<td>
<p>excitation wavelengths</p>
</td></tr>
<tr><td><code id=".trans_parafac_+3A_samples">samples</code></td>
<td>
<p>sample names</p>
</td></tr>
<tr><td><code id=".trans_parafac_+3A_comp">comp</code></td>
<td>
<p>number of components</p>
</td></tr>
<tr><td><code id=".trans_parafac_+3A_const">const</code></td>
<td>
<p>constraints</p>
</td></tr>
<tr><td><code id=".trans_parafac_+3A_norm_factors">norm_factors</code></td>
<td>
<p>factors to invert normalisation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>parafac model
</p>

<hr>
<h2 id='A_missing'>Calculate the sample loadings for samples not involved in model building</h2><span id='topic+A_missing'></span>

<h3>Description</h3>

<p>Samples from an eemlist that were not used in the modelling process are added as entries in the  A-modes. Values are calculated using fixed B and C modes in the PARAFAC algorithm. B and C modes can be provided via a previously calculated model or as matrices manually.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>A_missing(
  eem_list,
  pfmodel = NULL,
  cores = parallel::detectCores(logical = FALSE),
  components = NULL,
  const = NULL,
  control = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="A_missing_+3A_eem_list">eem_list</code></td>
<td>
<p>object of class eemlist with sample data</p>
</td></tr>
<tr><td><code id="A_missing_+3A_pfmodel">pfmodel</code></td>
<td>
<p>object of class parafac</p>
</td></tr>
<tr><td><code id="A_missing_+3A_cores">cores</code></td>
<td>
<p>number of cores to use for parallel processing</p>
</td></tr>
<tr><td><code id="A_missing_+3A_components">components</code></td>
<td>
<p>optionally supply components to use manually, either as a variable of class parafac_components or as a list of variables of class parafac_components, if you do so,</p>
</td></tr>
<tr><td><code id="A_missing_+3A_const">const</code></td>
<td>
<p>optional constraints for model, just used, when components are supplied</p>
</td></tr>
<tr><td><code id="A_missing_+3A_control">control</code></td>
<td>
<p>optional constraint control parameters for model, just used, when components are supplied</p>
</td></tr>
<tr><td><code id="A_missing_+3A_...">...</code></td>
<td>
<p>additional arguments passed to eem_parafac</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function can be used to calculate A modes (sample loadings) for samples that were previously excluded from the modelling process (e.g. outliers). Another way to use it would be a recombination of components from different models and calculating the according sample loadings. Expecially the later application is experimental and results have to be seen critically! Nevertheless, I decided to supply this function to stimulate some experiments on that and would be interested in your findings and feedback.
</p>


<h3>Value</h3>

<p>object of class parafac
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(eem_list)
data(pf_models)

A_missing(eem_list, pf4[[1]], cores = 2)

</code></pre>

<hr>
<h2 id='abs_blcor'>Baseline correction for absorbance data</h2><span id='topic+abs_blcor'></span>

<h3>Description</h3>

<p>Baseline correction for absorbance data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abs_blcor(abs_data, wlrange = c(680, 700))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="abs_blcor_+3A_abs_data">abs_data</code></td>
<td>
<p>data.frame containing samples in columns, the column containing wavelengths must be named &quot;wavelength&quot;</p>
</td></tr>
<tr><td><code id="abs_blcor_+3A_wlrange">wlrange</code></td>
<td>
<p>range of wavelengths that should be used for correction, absorbance mean in that range is subtracted from each value (sample-wise)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(absorbance)
abs_data_cor &lt;- abs_blcor(absorbance)

abs_data_cor1 &lt;- abs_blcor(absorbance[1:2])

</code></pre>

<hr>
<h2 id='abs_fit_slope'>Fit absorbance data to exponential curve. <code><a href="drc.html#topic+drm">drm</a></code> is used for the fitting process.</h2><span id='topic+abs_fit_slope'></span>

<h3>Description</h3>

<p>Fit absorbance data to exponential curve. <code><a href="drc.html#topic+drm">drm</a></code> is used for the fitting process.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abs_fit_slope(
  wl,
  abs,
  lim,
  l_ref = 350,
  control = drmc(errorm = FALSE, noMessage = TRUE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="abs_fit_slope_+3A_wl">wl</code></td>
<td>
<p>vector containing wavelengths</p>
</td></tr>
<tr><td><code id="abs_fit_slope_+3A_abs">abs</code></td>
<td>
<p>vector containing absorption in m^-1</p>
</td></tr>
<tr><td><code id="abs_fit_slope_+3A_lim">lim</code></td>
<td>
<p>vector containing lower and upper limits for wavelengths to use</p>
</td></tr>
<tr><td><code id="abs_fit_slope_+3A_l_ref">l_ref</code></td>
<td>
<p>numerical. reference wavelength, default is 350, if set to NA l_ref is fitted</p>
</td></tr>
<tr><td><code id="abs_fit_slope_+3A_control">control</code></td>
<td>
<p>control parameters for drm, see <code><a href="drc.html#topic+drmc">drmc</a></code></p>
</td></tr>
<tr><td><code id="abs_fit_slope_+3A_...">...</code></td>
<td>
<p>parameters that are passed on to drm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric exponential slope coefficient
</p>


<h3>See Also</h3>

<p><code><a href="drc.html#topic+drm">drm</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(absorbance)
abs_fit_slope(absorbance$wavelength,absorbance$sample1,lim=c(350,400),l_ref=350)
</code></pre>

<hr>
<h2 id='abs_parms'>Calculating slopes and slope ratios of a data frame of absorbance data.</h2><span id='topic+abs_parms'></span>

<h3>Description</h3>

<p>Calculating slopes and slope ratios of a data frame of absorbance data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>abs_parms(
  abs_data,
  cuvle = NULL,
  unit = c("absorbance", "absorption"),
  add_as = NULL,
  limits = list(c(275, 295), c(350, 400), c(300, 700)),
  l_ref = list(275, 350, 300),
  S = TRUE,
  lref = FALSE,
  p = FALSE,
  model = FALSE,
  Sint = FALSE,
  interval = 21,
  r2threshold = 0.8,
  cores = parallel::detectCores(logical = FALSE),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="abs_parms_+3A_abs_data">abs_data</code></td>
<td>
<p>data frame containing absorbance data.</p>
</td></tr>
<tr><td><code id="abs_parms_+3A_cuvle">cuvle</code></td>
<td>
<p>cuvette (path) length in cm, ignored if unit is absorption</p>
</td></tr>
<tr><td><code id="abs_parms_+3A_unit">unit</code></td>
<td>
<p>unit of absorbance data: if &quot;absorbance&quot;, absorbance data is multiplied by log(10) = 2.303 for slope calculations</p>
</td></tr>
<tr><td><code id="abs_parms_+3A_add_as">add_as</code></td>
<td>
<p>additionally to a254 and a300, absorbance at certain wavelengths can be added to the table</p>
</td></tr>
<tr><td><code id="abs_parms_+3A_limits">limits</code></td>
<td>
<p>list with vectors containig upper and lower bounds of wavelengeth ranges to be fitted</p>
</td></tr>
<tr><td><code id="abs_parms_+3A_l_ref">l_ref</code></td>
<td>
<p>list with reference wavelengths, same length as limits</p>
</td></tr>
<tr><td><code id="abs_parms_+3A_s">S</code></td>
<td>
<p>logical, include slope indices in the table</p>
</td></tr>
<tr><td><code id="abs_parms_+3A_lref">lref</code></td>
<td>
<p>logical, include reference wavelength in the table</p>
</td></tr>
<tr><td><code id="abs_parms_+3A_p">p</code></td>
<td>
<p>logical, include ps of the coefficients in the table</p>
</td></tr>
<tr><td><code id="abs_parms_+3A_model">model</code></td>
<td>
<p>logical, include complete model in data frame</p>
</td></tr>
<tr><td><code id="abs_parms_+3A_sint">Sint</code></td>
<td>
<p>logical, wether the spectral curve is calculated interval-wise (<code><a href="cdom.html#topic+cdom_spectral_curve">cdom_spectral_curve</a></code>)</p>
</td></tr>
<tr><td><code id="abs_parms_+3A_interval">interval</code></td>
<td>
<p>passed on to <code><a href="cdom.html#topic+cdom_spectral_curve">cdom_spectral_curve</a></code></p>
</td></tr>
<tr><td><code id="abs_parms_+3A_r2threshold">r2threshold</code></td>
<td>
<p>passed on to <code><a href="cdom.html#topic+cdom_spectral_curve">cdom_spectral_curve</a></code></p>
</td></tr>
<tr><td><code id="abs_parms_+3A_cores">cores</code></td>
<td>
<p>number of cores to be used for parallel processing</p>
</td></tr>
<tr><td><code id="abs_parms_+3A_verbose">verbose</code></td>
<td>
<p>logical, additional information is provided</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The absorbance data is a data frame with the first column called &quot;wavelength&quot; containg the wavelength. Each other column contains the data from one sample. You can use <a href="#topic+absorbance_read">absorbance_read</a> to read in appropriate data.
</p>
<p>The following spectral parameters are calculated:
</p>

<ul>
<li><p> $S_275-295$ slope between 275 and 295 nm calculated with nonlinear regression
</p>
</li>
<li><p> $S_350-400$ slope between 350 and 400 nm calculated with nonlinear regression
</p>
</li>
<li><p> $S_300-700$ slope between 275 and 295 nm calculated with nonlinear regression
</p>
</li>
<li><p> SR slope ratio, calculated by $S_275-295$/$S_350-400$
</p>
</li>
<li><p> E2:E3 ratio $a_250$/$a_365$
</p>
</li>
<li><p> E4:E6 ratio $a_465$/$a_665$
</p>
</li>
<li><p> $a_254$ absorbance at 254 nm
</p>
</li>
<li><p> $a_300$ absorbance at 300 nm
</p>
</li></ul>

<p>Depending on available wavelength range, values might be NA.
Additionally other wavelength limits can be defined. The slope ratio might fail in this case.
For further details please refer to Helm et al. (2008).
</p>


<h3>Value</h3>

<p>A data frame containing the adsorption slopes and slope ratios in column, one line for each sample.
</p>


<h3>References</h3>

<p>Helms, J., Kieber, D., Mopper, K. 2008. Absorption spectral slopes and slope ratios as indicators of molecular weight, source, and photobleaching of chromophoric dissolved organic matter. Limnol. Oceanogr., 53(3), 955–969
<a href="https://aslopubs.onlinelibrary.wiley.com/doi/10.4319/lo.2008.53.3.0955">https://aslopubs.onlinelibrary.wiley.com/doi/10.4319/lo.2008.53.3.0955</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(absorbance)

a1 &lt;- abs_parms(absorbance, cuvle = 5, verbose = TRUE, cores = 2)
a2 &lt;- abs_parms(absorbance, cuvle = 5,l_ref=list(NA,NA,NA), lref=TRUE, cores = 2) # fit lref as well

</code></pre>

<hr>
<h2 id='absorbance_read'>Reading absorbance data from txt and csv files.</h2><span id='topic+absorbance_read'></span>

<h3>Description</h3>

<p>Reading absorbance data from txt and csv files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>absorbance_read(
  absorbance_path,
  order = TRUE,
  recursive = TRUE,
  dec = NULL,
  sep = NULL,
  verbose = FALSE,
  cores = parallel::detectCores(logical = FALSE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="absorbance_read_+3A_absorbance_path">absorbance_path</code></td>
<td>
<p>directory containing absorbance data files or path to single file. See details for format of absorbance data.</p>
</td></tr>
<tr><td><code id="absorbance_read_+3A_order">order</code></td>
<td>
<p>logical, data is ordered according to wavelength</p>
</td></tr>
<tr><td><code id="absorbance_read_+3A_recursive">recursive</code></td>
<td>
<p>read files recursive, include subfolders</p>
</td></tr>
<tr><td><code id="absorbance_read_+3A_dec">dec</code></td>
<td>
<p>optional, either you set a decimal separator or the table is tested for . and ,</p>
</td></tr>
<tr><td><code id="absorbance_read_+3A_sep">sep</code></td>
<td>
<p>optional, either you set a field separator or it is tried to be determined automatically</p>
</td></tr>
<tr><td><code id="absorbance_read_+3A_verbose">verbose</code></td>
<td>
<p>logical, provide more information</p>
</td></tr>
<tr><td><code id="absorbance_read_+3A_cores">cores</code></td>
<td>
<p>number of CPU cores to be used simultanuously</p>
</td></tr>
<tr><td><code id="absorbance_read_+3A_...">...</code></td>
<td>
<p>additional arguments that are passed on to <code><a href="data.table.html#topic+fread">fread</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If absorbance_path is a directory, contained files that end on &quot;csv&quot; or &quot;txt&quot; are passed on to <code>read.table</code>. If the path is a file, this file is read. Tables can either contain data from one sample or from several samples in columns. The first column is considered the wavelength column. A multi-sample file must have sample names as column names. All tables are combined to one with one wavelength column and one column for each sample containing the absorbance data.
Column and decimal separators are guessed from the supplied data. In some cases, this can lead to strange results. Plaese set 'sep' and 'dec' manually if you encounter any problems.
</p>


<h3>Value</h3>

<p>A data frame containing absorbance data. An attribute &quot;location&quot; contains the filenames where each sample was taken from.
</p>


<h3>See Also</h3>

<p><code><a href="data.table.html#topic+fread">fread</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>absorbance_path &lt;- system.file("extdata", "absorbance", package = "staRdom")
absorbance &lt;- absorbance_read(absorbance_path, verbose = TRUE, cores = 2)
</code></pre>

<hr>
<h2 id='as.data.frame.eem'>Converting EEM data from class eem to data.frame.</h2><span id='topic+as.data.frame.eem'></span>

<h3>Description</h3>

<p>Converting EEM data from class eem to data.frame.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'eem'
as.data.frame(x, row.names = NULL, optional = FALSE, gather = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="as.data.frame.eem_+3A_x">x</code></td>
<td>
<p>abc</p>
</td></tr>
<tr><td><code id="as.data.frame.eem_+3A_row.names">row.names</code></td>
<td>
<p>abc</p>
</td></tr>
<tr><td><code id="as.data.frame.eem_+3A_optional">optional</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="as.data.frame.eem_+3A_gather">gather</code></td>
<td>
<p>logical, says whether data.frame is returned with excitation wavelength as column names or as values of a column. If the data is gathered, the sample name is added as value in a calumn</p>
</td></tr>
<tr><td><code id="as.data.frame.eem_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame containing the EEM data.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eem_list)

as.data.frame(eem_list[[1]])
as.data.frame(eem_list[[1]],gather=FALSE)
</code></pre>

<hr>
<h2 id='eem_absdil'>Multiply absorbance data according to the dilution and remove absorbance from samples where undiluted data is used.</h2><span id='topic+eem_absdil'></span>

<h3>Description</h3>

<p>According to dilution data absorbance is either multiplied by the according factor or the undiluted absorbance data is deleted. You can either specify the cor_data data table coming from <code><a href="#topic+eem_dilcorr">eem_dilcorr</a></code> or supply an eemlist, and the dilution data to created on the fly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eem_absdil(
  abs_data,
  eem_list = NULL,
  dilution = NULL,
  cor_data = NULL,
  auto = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eem_absdil_+3A_abs_data">abs_data</code></td>
<td>
<p>absorbance data</p>
</td></tr>
<tr><td><code id="eem_absdil_+3A_eem_list">eem_list</code></td>
<td>
<p>optional eemlist</p>
</td></tr>
<tr><td><code id="eem_absdil_+3A_dilution">dilution</code></td>
<td>
<p>optional dilution data as data frame</p>
</td></tr>
<tr><td><code id="eem_absdil_+3A_cor_data">cor_data</code></td>
<td>
<p>optional output from <code><a href="#topic+eem_dilcorr">eem_dilcorr</a></code> as data frame</p>
</td></tr>
<tr><td><code id="eem_absdil_+3A_auto">auto</code></td>
<td>
<p>optional, see <code><a href="#topic+eem_dilcorr">eem_dilcorr</a></code></p>
</td></tr>
<tr><td><code id="eem_absdil_+3A_verbose">verbose</code></td>
<td>
<p>optional, see <code><a href="#topic+eem_dilcorr">eem_dilcorr</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'># no appropriate exmaple data available yet

</code></pre>

<hr>
<h2 id='eem_apply'>Applying functions on EEMs</h2><span id='topic+eem_apply'></span>

<h3>Description</h3>

<p>Applying functions on EEMs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eem_apply(data, func, return = c("eemlist", "value"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eem_apply_+3A_data">data</code></td>
<td>
<p>eemlist to be modified</p>
</td></tr>
<tr><td><code id="eem_apply_+3A_func">func</code></td>
<td>
<p>a function to be applied on the data.</p>
</td></tr>
<tr><td><code id="eem_apply_+3A_return">return</code></td>
<td>
<p>either &quot;eemlist&quot; or &quot;value&quot;</p>
</td></tr>
<tr><td><code id="eem_apply_+3A_...">...</code></td>
<td>
<p>additional arguments passed on to func</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The EEMs are passed on as first argument to func. Additionally, the vector of excitation wavelengths is passed on as <code>ex</code> and the emission wavelengths as <code>em</code>. Therefore, the supplied function has to allow these arguments. The easiest way would be <code>...</code> (see example).
</p>


<h3>Value</h3>

<p>eemlist or list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## define a function, that would divide a matrix by its maximum
# more general, if you want to return a valid eemlist (see below),
# a matrix of the same size has to be returned
# ... is used as a placeholder for any argument, important: em and
# ex wavelengths are passed on, so the function needs to take them as arguments,
# even if they are not used
norm_max &lt;- function(x, ...){
  x/max(x)
}

# load example data
data("eem_list")

# normalise eems by the function defined above
norm_eems &lt;- eem_apply(eem_list,norm_max,"eemlist")

# plot the results to see the difference
ggeem(norm_eems)

# define another function. what values were used to
# multiply the eems with?
norm_fac &lt;- function(x, ...){
  1/max(x)
}

# return a list of factors used for normalisation
norm_factors &lt;- eem_apply(eem_list,norm_fac,"value")

unlist(norm_factors)

# return list of em vectors.
# important: x needs to be in the first position, but
# is not used later!
extr_em &lt;- function(x,em,...){
  em
}

em_vectors &lt;- eem_apply(eem_list,extr_em,"value")

em_vectors

</code></pre>

<hr>
<h2 id='eem_checkdata'>Check your EEM, absorption and metadata before processing</h2><span id='topic+eem_checkdata'></span>

<h3>Description</h3>

<p>The function tries to lead you to possible problems in your data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eem_checkdata(
  eem_list,
  absorbance,
  metadata = NULL,
  metacolumns = NULL,
  correction = FALSE,
  error = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eem_checkdata_+3A_eem_list">eem_list</code></td>
<td>
<p>eemlist continaing EEM data.</p>
</td></tr>
<tr><td><code id="eem_checkdata_+3A_absorbance">absorbance</code></td>
<td>
<p>data.frame containing absorbance data.</p>
</td></tr>
<tr><td><code id="eem_checkdata_+3A_metadata">metadata</code></td>
<td>
<p>optional data.frame containing metadata.</p>
</td></tr>
<tr><td><code id="eem_checkdata_+3A_metacolumns">metacolumns</code></td>
<td>
<p>character vector of columns that are checkt for complete data sets</p>
</td></tr>
<tr><td><code id="eem_checkdata_+3A_correction">correction</code></td>
<td>
<p>logical, whether EEMs should be checked for applied corrections</p>
</td></tr>
<tr><td><code id="eem_checkdata_+3A_error">error</code></td>
<td>
<p>logical, whether a problem should cause an error or not.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The returned list contains character vectors with sample names where possible problems were found: problem (logical, whether a severe problem was found), nas (sample names with NAs in EEM data), missing_correction (correction of EEM samples was not done or not done successfully),eem_no_abs (EEM samples with no absorbance data), abs_no_eem (samples with present absorbance but no EEM data), duplse (duplicate sample names in EEM data), duplsa (duplicate sample names in absorbance data), invalid_eem (invalid EEM sample name), invalid_abs (invalid absorbance sample name), range_mismatch (wavelength ranges of EEM and absorbance data are mismatching), metadupls (duplicate sample names in metadata), metamissing (EEM samples where metadata is missing), metaadd (samples in metadata without EEM data)
</p>


<h3>Value</h3>

<p>writes out possible porblems to command line, additionally list with sample names where possible problems were found, see details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>folder &lt;- system.file("extdata/EEMs", package = "staRdom") # load example data
eem_list &lt;- eem_read(folder, recursive = TRUE, import_function = eem_csv)

abs_folder &lt;- system.file("extdata/absorbance", package = "staRdom") # load example data
absorbance &lt;- absorbance_read(abs_folder, cores = 2)

metatable &lt;- system.file("extdata/metatable_dreem.csv",package = "staRdom")
meta &lt;- read.table(metatable, header = TRUE, sep = ",", dec = ".", row.names = 1)

checked &lt;- eem_checkdata(eem_list, absorbance, metadata = meta,
metacolumns = "dilution", error = FALSE)
# This example returns a message, that absorbance data for the
# blank samples are missing. As absorbance is supposed to be 0 over
# the whole spectrum when you measure blanks, there is no need
# to supply the data and do an inner-filter effect correction.
</code></pre>

<hr>
<h2 id='eem_checksize'>Check size of EEMs</h2><span id='topic+eem_checksize'></span>

<h3>Description</h3>

<p>The size of EEMs in an eemlist is checked and the sample names of samples with more data than the sample with the smallest range are returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eem_checksize(eem_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eem_checksize_+3A_eem_list">eem_list</code></td>
<td>
<p>eemlist</p>
</td></tr>
</table>


<h3>Value</h3>

<p>character vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eem_list)
eem_checksize(eem_list)
</code></pre>

<hr>
<h2 id='eem_corrections'>Return names of samples where certain corrections are missing.</h2><span id='topic+eem_corrections'></span>

<h3>Description</h3>

<p>Return names of samples where certain corrections are missing.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eem_corrections(eem_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eem_corrections_+3A_eem_list">eem_list</code></td>
<td>
<p>eemlist to be checked</p>
</td></tr>
</table>


<h3>Value</h3>

<p>prints out sample names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eem_list)

eem_corrections(eem_list)
</code></pre>

<hr>
<h2 id='eem_csv'>Importer function for generic csv files to be used with eem_read().</h2><span id='topic+eem_csv'></span>

<h3>Description</h3>

<p>This function can be used to import generic csv files containing EEM data using <code><a href="eemR.html#topic+eem_read">eem_read</a></code>. Excitation wavelengths are assumed column-wise and emission wavelengths row-wise. If your data is arranged the other way round, please use <code><a href="#topic+eem_csv2">eem_csv2</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eem_csv(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eem_csv_+3A_file">file</code></td>
<td>
<p>path to file passed from eem_read</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with EEM data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eems &lt;- system.file("extdata/EEMs",package="staRdom")
eem_list &lt;- eem_read(eems, recursive = TRUE, import_function = eem_csv)

eem_list
</code></pre>

<hr>
<h2 id='eem_csv2'>Importer function for generic csv files to be used with eem_read().</h2><span id='topic+eem_csv2'></span>

<h3>Description</h3>

<p>This function can be used to import generic csv files containing EEM data using <code><a href="eemR.html#topic+eem_read">eem_read</a></code>. Excitation wavelengths are assumed row-wise and emission wavelengths column-wise If your data is arranged the other way round, please use <code><a href="#topic+eem_csv">eem_csv</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eem_csv2(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eem_csv2_+3A_file">file</code></td>
<td>
<p>path to file passed from eem_read</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with EEM data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## no example data provided with the package
## below is an example how this could like like
# eems &lt;- "C:/some/path/to/eem.csv"
# eem_list &lt;- eem_read(eems, recursive = TRUE, import_function = eem_csv2)

# eem_list

</code></pre>

<hr>
<h2 id='eem_dilcorr'>Create table how samples should be corrected because of dilution</h2><span id='topic+eem_dilcorr'></span>

<h3>Description</h3>

<p>Due to dilution absorbance spectra need to be multiplied by the dilution factor and names of EEM samples can be adjusted to be similar to their undiluted absorbance sample. The table contains information about these two steps. Undiluted samples are suggested by finding absorbance samples match the beginning of EEM sample name (see details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eem_dilcorr(eem_list, abs_data, dilution, auto = FALSE, verbose = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eem_dilcorr_+3A_eem_list">eem_list</code></td>
<td>
<p>eemlist</p>
</td></tr>
<tr><td><code id="eem_dilcorr_+3A_abs_data">abs_data</code></td>
<td>
<p>absorbance data as data frame</p>
</td></tr>
<tr><td><code id="eem_dilcorr_+3A_dilution">dilution</code></td>
<td>
<p>dilution data as data frame with rownames</p>
</td></tr>
<tr><td><code id="eem_dilcorr_+3A_auto">auto</code></td>
<td>
<p>way how to deal with dilution is chosen automatically. See details.</p>
</td></tr>
<tr><td><code id="eem_dilcorr_+3A_verbose">verbose</code></td>
<td>
<p>print out more information</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If you choose an automatic analysis EEMs are renamed if there is only one matching undiluted absorbance sample. Matching samples is done by comparing the beginning of the sample name (e.g. &quot;sample3_1to10&quot; fits &quot;sample3&quot;).
</p>


<h3>Value</h3>

<p>data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'># no appropriate exmaple data available yet

</code></pre>

<hr>
<h2 id='eem_dilution'>Modifying fluorescence data according to dilution.</h2><span id='topic+eem_dilution'></span>

<h3>Description</h3>

<p>If samples were diluted before measuring, a dilution factor has to be added to the measured data. This function can do that by either multilpying each sample with the same value or using a data frame with different values for each sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eem_dilution(data, dilution = 1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eem_dilution_+3A_data">data</code></td>
<td>
<p>fluorescence data with class eemlist</p>
</td></tr>
<tr><td><code id="eem_dilution_+3A_dilution">dilution</code></td>
<td>
<p>dilution factor(s), either numeric value or data frame. Row names of data frame have to be similar to sample names in eemlist.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fluorescence data with class eemlist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eem_list)

eem_list2 &lt;- eem_dilution(eem_list, dilution = 5)

dilutionT &lt;- data.frame(dilution = rep(5, length(eem_list)))
row.names(dilutionT) &lt;- eem_names(eem_list)
dilutionT

eem_list3 &lt;- eem_dilution(eem_list, dilution = dilutionT)

</code></pre>

<hr>
<h2 id='eem_duplicates'>Check for duplicate sample names</h2><span id='topic+eem_duplicates'></span><span id='topic+eem_duplicates.default'></span><span id='topic+eem_duplicates.eemlist'></span><span id='topic+eem_duplicates.data.frame'></span>

<h3>Description</h3>

<p>Check for duplicate sample names
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eem_duplicates(data)

## Default S3 method:
eem_duplicates(data)

## S3 method for class 'eemlist'
eem_duplicates(data)

## S3 method for class 'data.frame'
eem_duplicates(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eem_duplicates_+3A_data">data</code></td>
<td>
<p>eemlist or data.frame containing absorbance data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named character vector with duplicate sample names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### check
</code></pre>

<hr>
<h2 id='eem_easy'>Opens an R markdown template for an easy and userfriendly analysis of EEM data.</h2><span id='topic+eem_easy'></span>

<h3>Description</h3>

<p>In your default editor (e.g. RStudio), a Rmd file is opened. It consists of bloacks gathering the parameters and information needed and continues with a series of data corrections, peak picking and plots. Finally you get a report of your analysis, a table with the peaks and optional pngs of your fluorescence data. To continue working and keeping your settings, the file can be sa ved anywhere and reused anytime.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eem_easy()
</code></pre>


<h3>Details</h3>

<p>Function does not work well in Windows. You might try file.edit(system.file(&quot;EEM_simple_analysis.Rmd&quot;, package = &quot;staRdom&quot;))
</p>


<h3>Value</h3>

<p>A pdf report, a peak picking table and optional plots.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#
eem_easy()

# this function fails very often, so you might use that:
file.edit(system.file("EEM_simple_analysis.Rmd", package = "staRdom"))

## End(Not run)
</code></pre>

<hr>
<h2 id='eem_eemdil'>Correct names of EEM samples to match undiluted absorbance data.</h2><span id='topic+eem_eemdil'></span>

<h3>Description</h3>

<p>Correct names of EEM samples to match undiluted absorbance data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eem_eemdil(
  eem_list,
  abs_data = NULL,
  dilution = NULL,
  cor_data = NULL,
  auto = TRUE,
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eem_eemdil_+3A_eem_list">eem_list</code></td>
<td>
<p>eemlist</p>
</td></tr>
<tr><td><code id="eem_eemdil_+3A_abs_data">abs_data</code></td>
<td>
<p>optinal absorbance data as data frame</p>
</td></tr>
<tr><td><code id="eem_eemdil_+3A_dilution">dilution</code></td>
<td>
<p>optinal dilution data as data frame</p>
</td></tr>
<tr><td><code id="eem_eemdil_+3A_cor_data">cor_data</code></td>
<td>
<p>optional output from <code><a href="#topic+eem_dilcorr">eem_dilcorr</a></code> as data frame</p>
</td></tr>
<tr><td><code id="eem_eemdil_+3A_auto">auto</code></td>
<td>
<p>optional, see <code><a href="#topic+eem_dilcorr">eem_dilcorr</a></code></p>
</td></tr>
<tr><td><code id="eem_eemdil_+3A_verbose">verbose</code></td>
<td>
<p>optional, see <code><a href="#topic+eem_dilcorr">eem_dilcorr</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>eemlist
</p>


<h3>Examples</h3>

<pre><code class='language-R'># no appropriate exmaple data available yet

</code></pre>

<hr>
<h2 id='eem_exclude'>Exclude complete wavelengths or samples form data set</h2><span id='topic+eem_exclude'></span>

<h3>Description</h3>

<p>Outliers in all modes should be avoided. With this functions excitation or emission wavelengths as well as samples can be removed completely from your sample set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eem_exclude(eem_list, exclude = list, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eem_exclude_+3A_eem_list">eem_list</code></td>
<td>
<p>object of class eemlist</p>
</td></tr>
<tr><td><code id="eem_exclude_+3A_exclude">exclude</code></td>
<td>
<p>list of three vectors, see details</p>
</td></tr>
<tr><td><code id="eem_exclude_+3A_verbose">verbose</code></td>
<td>
<p>states whether additional information is given in the command line</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument exclude is a named list of three vectors. The names must be &quot;ex&quot;, &quot;em&quot; and &quot;sample&quot;. Each element contains a vector of wavelengths or sample names that are to be excluded from the data set.
</p>


<h3>Value</h3>

<p>object of class eemlist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eem_list)

exclude &lt;- list("ex" = c(280,285,290,295),
"em" = c(),
"sample" = c("667sf", "494sf")
)

eem_list_ex &lt;- eem_exclude(eem_list, exclude)
</code></pre>

<hr>
<h2 id='eem_export'>Export all samples of an eem_list</h2><span id='topic+eem_export'></span>

<h3>Description</h3>

<p>Export all samples of an eem_list
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eem_export(file, format = c("csv", "mat"), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eem_export_+3A_file">file</code></td>
<td>
<p>path to directory (csv format) or file (Matlab format)</p>
</td></tr>
<tr><td><code id="eem_export_+3A_format">format</code></td>
<td>
<p>either &quot;csv&quot; or &quot;mat&quot; to specify export format</p>
</td></tr>
<tr><td><code id="eem_export_+3A_...">...</code></td>
<td>
<p>one or more eem_list objects</p>
</td></tr>
</table>


<h3>Value</h3>

<p>0 on successful export
</p>


<h3>Examples</h3>

<pre><code class='language-R'># create temporary directory to write out
file &lt;- paste0(tempdir(),"/eem_export/")
dir.create(file)

# run eem_export to write one csv file for each sample
eem_export(file, format = "csv", eem_list)

# show content of output directory
dir(file)

</code></pre>

<hr>
<h2 id='eem_extend2largest'>EEM sample data is extended to include all wavelengths in all samples</h2><span id='topic+eem_extend2largest'></span>

<h3>Description</h3>

<p>Compared to the whole sample set, wavelengths missing in some samples are added and set NA or interpolated. This can be especially helpful, if you want to combine data measured with different wavelength intervals in a given range.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eem_extend2largest(eem_list, interpolation = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eem_extend2largest_+3A_eem_list">eem_list</code></td>
<td>
<p>eemlist</p>
</td></tr>
<tr><td><code id="eem_extend2largest_+3A_interpolation">interpolation</code></td>
<td>
<p>logical, whether added NAs should be interpolated</p>
</td></tr>
<tr><td><code id="eem_extend2largest_+3A_...">...</code></td>
<td>
<p>arguments passed to eem_interp</p>
</td></tr>
</table>


<h3>Value</h3>

<p>eemlist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
library(dplyr)
data(eem_list)
eem_list &lt;- eem_exclude(eem_list[1:5] %&gt;%
`class&lt;-`("eemlist"), exclude = list(em = c(318,322,326,550,438), ex = c(270,275))) %&gt;%
eem_bind(eem_list[6:15] %&gt;% `class&lt;-`("eemlist"))
ggeem(eem_list)

eem_extend2largest(eem_list) %&gt;%
  ggeem()

</code></pre>

<hr>
<h2 id='eem_getextreme'>Determines the the biggest range of EEM spectrum where data is available from each sample.</h2><span id='topic+eem_getextreme'></span>

<h3>Description</h3>

<p>Determines the the biggest range of EEM spectrum where data is available from each sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eem_getextreme(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eem_getextreme_+3A_data">data</code></td>
<td>
<p>eemlist</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of numeric vector containing the biggest available range
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eem_list)
eem_getextreme(eem_list)

eem_list &lt;- eem_range(eem_list,ex = c(250,Inf),em = c(280,500))
eem_getextreme(eem_list)
</code></pre>

<hr>
<h2 id='eem_hitachi'>Importer function for Hitachi F-7000 txt files to be used with eem_read().</h2><span id='topic+eem_hitachi'></span>

<h3>Description</h3>

<p>This function can be used to import txt files from Hitachi F-7000 containing EEM data using <code><a href="eemR.html#topic+eem_read">eem_read</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eem_hitachi(file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eem_hitachi_+3A_file">file</code></td>
<td>
<p>path to file passed from eem_read</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with EEM data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## no example data provided with the package
## below is an example how this could like like
# eems &lt;- "C:/some/path/to/hitachi.TXT"
# eem_list &lt;- eem_read(eems, recursive = TRUE, import_function = eem_hitachi)

# eem_list

</code></pre>

<hr>
<h2 id='eem_ife_correction'>Wrapper function to allow eem_inner_filter_effect (eemR) handling different cuvette lengths.</h2><span id='topic+eem_ife_correction'></span>

<h3>Description</h3>

<p>Calls <code><a href="eemR.html#topic+eem_inner_filter_effect">eem_inner_filter_effect</a></code> for each sample to use different cuvette lengths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eem_ife_correction(
  data,
  abs_data,
  cuvl = NULL,
  unit = c("absorbance", "absorption")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eem_ife_correction_+3A_data">data</code></td>
<td>
<p>fluorescence data of class eemlist</p>
</td></tr>
<tr><td><code id="eem_ife_correction_+3A_abs_data">abs_data</code></td>
<td>
<p>absorbance data</p>
</td></tr>
<tr><td><code id="eem_ife_correction_+3A_cuvl">cuvl</code></td>
<td>
<p>length of cuvette of absorption measurment in cm. Either a number or a data frame. Row names of data frame have to be similar to sample names in data. This is ignored, if unit is &quot;absorption&quot;.</p>
</td></tr>
<tr><td><code id="eem_ife_correction_+3A_unit">unit</code></td>
<td>
<p>unit of absorbance data. Either &quot;absorbance&quot; or &quot;absorption&quot;.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>fluorescence data of class eemlist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>folder &lt;- system.file("extdata/cary/scans_day_1", package = "eemR") # load example data
eem_list &lt;- eem_read(folder, import_function = "cary")
data(absorbance)

eem_list &lt;- eem_ife_correction(data = eem_list, abs_data = absorbance,
    cuvl = 5, unit = "absorbance")
</code></pre>

<hr>
<h2 id='eem_import_dir'>Load all eemlist obects saved in different Rdata or RDa files in a folder.</h2><span id='topic+eem_import_dir'></span>

<h3>Description</h3>

<p>Reads Rdata and RDa files with one eemlist each. The eemlists are combined into one and returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eem_import_dir(dir, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eem_import_dir_+3A_dir">dir</code></td>
<td>
<p>folder where RData files are saved</p>
</td></tr>
<tr><td><code id="eem_import_dir_+3A_verbose">verbose</code></td>
<td>
<p>logical, set TRUE to show more information during import</p>
</td></tr>
</table>


<h3>Value</h3>

<p>eemlist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# due to package size issues no example data is provided for this function
# eem_import_dir("C:/some_folder/with_EEMS/only_Rdata_files")

## End(Not run)
</code></pre>

<hr>
<h2 id='eem_interp'>Missing values are interpolated within EEM data</h2><span id='topic+eem_interp'></span>

<h3>Description</h3>

<p>Missing EEM data can be interpolated. Usually it is the result of removing scatter or other parts where noise is presumed. Different interpolation algorithms can be used (see details).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eem_interp(
  data,
  cores = parallel::detectCores(logical = FALSE),
  type = TRUE,
  verbose = FALSE,
  nonneg = TRUE,
  extend = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eem_interp_+3A_data">data</code></td>
<td>
<p>object of class eemlist with spectra containing missing values</p>
</td></tr>
<tr><td><code id="eem_interp_+3A_cores">cores</code></td>
<td>
<p>specify number of cores for parallel computation</p>
</td></tr>
<tr><td><code id="eem_interp_+3A_type">type</code></td>
<td>
<p>numeric 0 to 4 or TRUE which resembles type 1</p>
</td></tr>
<tr><td><code id="eem_interp_+3A_verbose">verbose</code></td>
<td>
<p>logical, whether more information on calculation should be provided</p>
</td></tr>
<tr><td><code id="eem_interp_+3A_nonneg">nonneg</code></td>
<td>
<p>logical, whether negative values should be replaced by 0</p>
</td></tr>
<tr><td><code id="eem_interp_+3A_extend">extend</code></td>
<td>
<p>logical, whether data is extrapolated using type 1</p>
</td></tr>
<tr><td><code id="eem_interp_+3A_...">...</code></td>
<td>
<p>arguments passed on to other functions (pchip, na.approx, mba.points)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The types of interpolation are (0) setting all NAs to 0, (1) spline interpolation with <code><a href="MBA.html#topic+mba.points">mba.points</a></code>, (2) excitation and emission wavelength-wise interpolation with <code><a href="pracma.html#topic+pchip">pchip</a></code> and subsequent mean, (3) excitation wavelength-wise interpolation with <code><a href="pracma.html#topic+pchip">pchip</a></code> and (4) linear interpolation in 2 dimensions with <code><a href="zoo.html#topic+na.approx">na.approx</a></code> and again subsequent mean calculation. Calculating the mean is a way of ensuring NAs are also interpolated where missing boundary values would make that impossible. Using type = 1, extrapolation can be suppressed by adding the argument extend = FALSE.
</p>


<h3>Value</h3>

<p>object of class eemlist with interpoleted spectra.
</p>


<h3>References</h3>

<p>Elcoroaristizabal, S., Bro, R., García, J., Alonso, L. 2015. PARAFAC models of fluorescence data with scattering: A comparative study. Chemometrics and Intelligent Laboratory Systems, 142, 124-130
<a href="https://doi.org/10.1016/j.chemolab.2015.01.017">doi:10.1016/j.chemolab.2015.01.017</a>
</p>


<h3>See Also</h3>

<p><code><a href="pracma.html#topic+pchip">pchip</a></code>, <code><a href="MBA.html#topic+mba.points">mba.points</a></code>, <code><a href="zoo.html#topic+na.approx">na.approx</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(eem_list)
eem_list &lt;- eem_list[1:6]
class(eem_list) &lt;- "eemlist"

remove_scatter &lt;- c(FALSE, TRUE, TRUE, TRUE)

remove_scatter_width = c(15, 10, 16, 12)

eem_list &lt;- eem_rem_scat(eem_list, remove_scatter, remove_scatter_width)

eem_list &lt;- eem_interp(eem_list, cores = 2)

ggeem(eem_list)

eem_list2 &lt;- eem_setNA(eem_list, ex = 200:280, interpolate=FALSE)

ggeem(eem_list2)

eem_list3 &lt;- eem_interp(eem_list2, type = 1, extend = TRUE, cores = 2)

ggeem(eem_list3)

eem_list3 &lt;- eem_interp(eem_list2, type = 1, extend = FALSE, cores = 2)

ggeem(eem_list3)



</code></pre>

<hr>
<h2 id='eem_is.na'>Check for NAs in EEM data</h2><span id='topic+eem_is.na'></span>

<h3>Description</h3>

<p>Check for NAs in EEM data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eem_is.na(eem_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eem_is.na_+3A_eem_list">eem_list</code></td>
<td>
<p>eemlist to check</p>
</td></tr>
</table>


<h3>Value</h3>

<p>named character vector with sample names where EEM data contains NAs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>### check
</code></pre>

<hr>
<h2 id='eem_list'>15 fluorescence samples from drEEM used for examples.</h2><span id='topic+eem_list'></span>

<h3>Description</h3>

<p>15 fluorescence samples from drEEM used for examples.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eem_list
</code></pre>


<h3>Format</h3>

<p>eemlist
</p>

<hr>
<h2 id='eem_list_outliers'>2 fluorescence samples from drEEM that were excluded as outliers from the PARAFAC model.</h2><span id='topic+eem_list_outliers'></span>

<h3>Description</h3>

<p>2 fluorescence samples from drEEM that were excluded as outliers from the PARAFAC model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eem_list_outliers
</code></pre>


<h3>Format</h3>

<p>eemlist
</p>

<hr>
<h2 id='eem_load_dreem'>Load original data from the drEEM tutorial and return it as eemlist</h2><span id='topic+eem_load_dreem'></span>

<h3>Description</h3>

<p>Load original data from the drEEM tutorial and return it as eemlist
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eem_load_dreem()
</code></pre>


<h3>Value</h3>

<p>eemlist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Reading MATLAB files from recent versions like the demo dataset from drEEM
# can cause problems if the R installation lacks UTF8 support in iconv.
# Therefore, we use try() in the example. If you encounter related problems,
# please refer to the help for R.matlab::readMat() for details.

eem_list &lt;- try(eem_load_dreem(), silent = FALSE)
eem_list

</code></pre>

<hr>
<h2 id='eem_matmult'>Multiply all EEMs with a matrix</h2><span id='topic+eem_matmult'></span>

<h3>Description</h3>

<p>Multiply all EEMs with a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eem_matmult(eem_list, matrix = NULL, value = 0)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eem_matmult_+3A_eem_list">eem_list</code></td>
<td>
<p>EEM data as eemlist</p>
</td></tr>
<tr><td><code id="eem_matmult_+3A_matrix">matrix</code></td>
<td>
<p>either a vactor containing &quot;l&quot; and/or &quot;u&quot; or a matrix, see details.</p>
</td></tr>
<tr><td><code id="eem_matmult_+3A_value">value</code></td>
<td>
<p>in case matrices &quot;l&quot; or &quot;u&quot; are used, this specifies the value to use in this areas. Usually this is 0 (default) or NA but any numeric value can be used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>All EEMs must be of the same size. If matrix is of type matrix, it is used right away to multiply the EEMs. It has to be of the same size as the EEMs. If matrix is a vector containing &quot;l&quot;, values below 1st order Rayleigh scattering are set to 0. If matrix contains &quot;u&quot;, values above 2nd order Raman scattering are set to 0. If you want to remove wavelength ranges, take into consideration to use <code><a href="eemR.html#topic+eem_cut">eem_cut</a></code> or <code><a href="#topic+eem_range">eem_range</a></code>.
</p>


<h3>Value</h3>

<p>eemlist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(eem_list)
eem &lt;- eem_list[1:9]
class(eem) &lt;- "eemlist"

ggeem(eem)

eem_list_cut &lt;- eem_matmult(eem,matrix=c("l"), value= NA)
ggeem(eem_list_cut)

</code></pre>

<hr>
<h2 id='eem_metatemplate'>Create table that contains sample names and locations of files.</h2><span id='topic+eem_metatemplate'></span>

<h3>Description</h3>

<p>You can use this table as an overview of your files and/or as a template for creating a metadata table.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eem_metatemplate(eem_list = NULL, absorbance = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eem_metatemplate_+3A_eem_list">eem_list</code></td>
<td>
<p>eemlist</p>
</td></tr>
<tr><td><code id="eem_metatemplate_+3A_absorbance">absorbance</code></td>
<td>
<p>data frame with absorbance data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>folder &lt;- system.file("extdata/EEMs", package = "staRdom") # load example data
eem_list &lt;- eem_read(folder, recursive = TRUE, import_function = eem_csv)
data(absorbance)

eem_metatemplate(eem_list,absorbance)
</code></pre>

<hr>
<h2 id='eem_name_replace'>Replace matched patterns in sample names</h2><span id='topic+eem_name_replace'></span>

<h3>Description</h3>

<p>Sample names in eemlist can be altered.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eem_name_replace(eem_list, pattern, replacement)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eem_name_replace_+3A_eem_list">eem_list</code></td>
<td>
<p>data of class eemlist</p>
</td></tr>
<tr><td><code id="eem_name_replace_+3A_pattern">pattern</code></td>
<td>
<p>character vector containing pattern to look for.</p>
</td></tr>
<tr><td><code id="eem_name_replace_+3A_replacement">replacement</code></td>
<td>
<p>character vector of replacements. Has to have the same length as pattern</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code><a href="stringr.html#topic+str_replace_all">str_replace_all</a></code> from package stringr is used for the replacement. Please read the corresponding help for further options.
</p>


<h3>Value</h3>

<p>An eemlist.
</p>


<h3>See Also</h3>

<p><code><a href="stringr.html#topic+str_replace_all">str_replace_all</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eem_names(eem_list)

eem_list &lt;- eem_name_replace(eem_list,"sample","Sample")
eem_names(eem_list)
</code></pre>

<hr>
<h2 id='eem_overview_plot'>Plot fluorescence data from several samples split into several plots.</h2><span id='topic+eem_overview_plot'></span>

<h3>Description</h3>

<p>Plot fluorescence data from several samples split into several plots.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eem_overview_plot(data, spp = 8, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eem_overview_plot_+3A_data">data</code></td>
<td>
<p>fluorescence data of class eemlist</p>
</td></tr>
<tr><td><code id="eem_overview_plot_+3A_spp">spp</code></td>
<td>
<p>number of samples per plot or a vector with the numbers of rows and columns in the plot.</p>
</td></tr>
<tr><td><code id="eem_overview_plot_+3A_...">...</code></td>
<td>
<p>arguments passed on to <code><a href="#topic+ggeem">ggeem</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of ggplots
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(eem_list)
eem_overview_plot(eem_list, spp = 9)

# define number of rows and columns in plot
eem_overview_plot(eem_list, spp = c(3, 5))

</code></pre>

<hr>
<h2 id='eem_parafac'>Runs a PARAFAC analysis on EEM data</h2><span id='topic+eem_parafac'></span>

<h3>Description</h3>

<p>One or more PARAFAC models can be calculated depending on the number of components. The idea is to compare the different models to get the most suitable. B-mode is emmission wavelengths, C-mode is excitation wavelengths and, A-mode is the loadings of the samples. The calculation is done with <code><a href="multiway.html#topic+parafac">parafac</a></code>, please see details there.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eem_parafac(
  eem_list,
  comps,
  maxit = 2500,
  normalise = TRUE,
  const = c("nonneg", "nonneg", "nonneg"),
  nstart = 30,
  ctol = 10^-8,
  strictly_converging = FALSE,
  cores = parallel::detectCores(logical = FALSE),
  verbose = FALSE,
  output = "best",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eem_parafac_+3A_eem_list">eem_list</code></td>
<td>
<p>object of class <code><a href="eemR.html#topic+eem">eem</a></code></p>
</td></tr>
<tr><td><code id="eem_parafac_+3A_comps">comps</code></td>
<td>
<p>vector containing the desired numbers of components. For each of these numbers one model is calculated</p>
</td></tr>
<tr><td><code id="eem_parafac_+3A_maxit">maxit</code></td>
<td>
<p>maximum iterations for PARAFAC algorithm</p>
</td></tr>
<tr><td><code id="eem_parafac_+3A_normalise">normalise</code></td>
<td>
<p>state whether EEM data should be normalised in advance</p>
</td></tr>
<tr><td><code id="eem_parafac_+3A_const">const</code></td>
<td>
<p>constraints of PARAFAC analysis. Default is non-negative (&quot;nonneg&quot;), alternatively smooth and non-negative (&quot;smonon&quot;) might be interesting for an EEM analysis.</p>
</td></tr>
<tr><td><code id="eem_parafac_+3A_nstart">nstart</code></td>
<td>
<p>number of random starts</p>
</td></tr>
<tr><td><code id="eem_parafac_+3A_ctol">ctol</code></td>
<td>
<p>Convergence tolerance (R^2 change)</p>
</td></tr>
<tr><td><code id="eem_parafac_+3A_strictly_converging">strictly_converging</code></td>
<td>
<p>calculate nstart converging models and take the best. Please see details!</p>
</td></tr>
<tr><td><code id="eem_parafac_+3A_cores">cores</code></td>
<td>
<p>number of parallel calculations (e.g. number of physical cores in CPU)</p>
</td></tr>
<tr><td><code id="eem_parafac_+3A_verbose">verbose</code></td>
<td>
<p>print infos</p>
</td></tr>
<tr><td><code id="eem_parafac_+3A_output">output</code></td>
<td>
<p>Output the <code>"best"</code> solution (default) only or additionally add <code>"all"</code> <code>nstart</code> solutions to the model as an element named <code>"models"</code>.</p>
</td></tr>
<tr><td><code id="eem_parafac_+3A_...">...</code></td>
<td>
<p>additional parameters that are passed on to <code><a href="multiway.html#topic+parafac">parafac</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>PARAFAC models are created based on multiple random starts. In some cases, a model does not converge and the resulting model is then based on less than nstart converging models. In case you want to have nstart converging models, set strictly_converging TRUE. This calculates models stepwise until the desired number is reached but it takes more calculation time. Increasing the number of models from the beginning is much more time efficient.
</p>


<h3>Value</h3>

<p>object of class parafac
</p>


<h3>See Also</h3>

<p><code><a href="multiway.html#topic+parafac">parafac</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(eem_list)

dim_min &lt;- 3 # minimum number of components
dim_max &lt;- 7 # maximum number of components
nstart &lt;- 25 # random starts for PARAFAC analysis, models built simulanuously, best selected
# cores &lt;- parallel::detectCores(logical=FALSE) # use all cores but do not use all threads
cores &lt;- 2 # package checks only run with 2 cores
maxit = 2500
ctol &lt;- 10^-7 # tolerance for parafac

pfres_comps &lt;- eem_parafac(eem_list, comps = seq(dim_min, dim_max),
    normalise = TRUE, maxit = maxit, nstart = nstart, ctol = ctol, cores = cores)

## with a defined number of converging models
#pfres_comps &lt;- eem_parafac(eem_list, comps = seq(dim_min, dim_max),
#     normalise = TRUE, maxit = maxit, nstart = nstart, ctol = ctol,
#     output = "all", strictly_converging = TRUE, cores = cores, verbose = TRUE)

pfres_comps2 &lt;- eem_parafac(eem_list, comps = seq(dim_min, dim_max),
    normalise = TRUE, maxit = maxit, nstart = nstart, ctol = ctol, cores = cores, output = "all")

</code></pre>

<hr>
<h2 id='eem_raman_area'>Calculate raman area of EEM samples</h2><span id='topic+eem_raman_area'></span>

<h3>Description</h3>

<p>Calculate raman area of EEM samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eem_raman_area(eem_list, blanks_only = TRUE, average = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eem_raman_area_+3A_eem_list">eem_list</code></td>
<td>
<p>An object of class eemlist.</p>
</td></tr>
<tr><td><code id="eem_raman_area_+3A_blanks_only">blanks_only</code></td>
<td>
<p>logical. States whether all samples or just blanks will be used.</p>
</td></tr>
<tr><td><code id="eem_raman_area_+3A_average">average</code></td>
<td>
<p>logical. States whether samples will be averaged before calculating the raman area.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Code based on <code><a href="eemR.html#topic+eem_raman_normalisation">eem_raman_normalisation</a></code>.
</p>


<h3>Value</h3>

<p>data frame containing sample names, locations and raman areas
</p>


<h3>Examples</h3>

<pre><code class='language-R'>folder &lt;- system.file("extdata/EEMs",package="staRdom")
eem_list &lt;- eem_read(folder, recursive = TRUE, import_function = eem_csv)
blank &lt;- eem_extract(eem_list,sample ="blank", keep = TRUE)

eem_raman_area(blank)
</code></pre>

<hr>
<h2 id='eem_raman_normalisation2'>Wrapper function to eem_raman_normalisation (eemR).</h2><span id='topic+eem_raman_normalisation2'></span>

<h3>Description</h3>

<p>Usually Raman normalisation is done with fluorescence data from a blank sample. Sometimes you already know a value for the Raman area. This function can do both.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eem_raman_normalisation2(data, blank = "blank")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eem_raman_normalisation2_+3A_data">data</code></td>
<td>
<p>fluorescence data of class eemlist</p>
</td></tr>
<tr><td><code id="eem_raman_normalisation2_+3A_blank">blank</code></td>
<td>
<p>defines how Raman normalisation is done (see 'Details')</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Possible values for blank:
</p>
<p>&quot;blank&quot;: normalisation is done with a blank sample. Please refer to <code><a href="eemR.html#topic+eem_raman_normalisation">eem_raman_normalisation</a></code>.
</p>
<p>numeric: normalisation is done with one value for all samples.
</p>
<p>data frame: normalisation is done with different values for different samples. Values are taken from a data.frame with sample names as rownames and one column containing the raman area values.
</p>


<h3>Value</h3>

<p>fluorescence data of class eemlist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eem_list)
# correction by blank
eems_bl &lt;- eem_raman_normalisation2(eem_list,blank="blank")

# correction by value
eems_num &lt;- eem_raman_normalisation2(eem_list,blank=168)
</code></pre>

<hr>
<h2 id='eem_range'>Cut EEM data matching a given wavelength range</h2><span id='topic+eem_range'></span>

<h3>Description</h3>

<p>Cut EEM data matching a given wavelength range
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eem_range(data, ex = c(0, Inf), em = c(0, Inf))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eem_range_+3A_data">data</code></td>
<td>
<p>EEM data as eemlist</p>
</td></tr>
<tr><td><code id="eem_range_+3A_ex">ex</code></td>
<td>
<p>optional desired range of excitation wavelength</p>
</td></tr>
<tr><td><code id="eem_range_+3A_em">em</code></td>
<td>
<p>optional desired range of emission wavelength</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An eemlist of reduced spectra size.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eem_list)
eem_range(eem_list,ex = c(250,Inf),em = c(280,500))
</code></pre>

<hr>
<h2 id='eem_read_csv'>Import EEMs from generic csv tables (deprecated)</h2><span id='topic+eem_read_csv'></span>

<h3>Description</h3>

<p>This function is deprecate, please use <code><a href="eemR.html#topic+eem_read">eem_read</a></code>(..., import_function = <code><a href="#topic+eem_csv">eem_csv</a></code>) or eem_read(..., import_function = <code><a href="#topic+eem_csv2">eem_csv2</a></code>) instead.
EEM data is loaded from generic files. First column and first row contains wavelength values. The other values are to be plain numbers. <code><a href="data.table.html#topic+fread">fread</a></code> is used to read the table. It offers a lot of helpful functions (e.g. skipping any number n of header lines by adding 'skip = n')
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eem_read_csv(
  path,
  col = "ex",
  recursive = TRUE,
  is_blank_corrected = FALSE,
  is_scatter_corrected = FALSE,
  is_ife_corrected = FALSE,
  is_raman_normalized = FALSE,
  manufacturer = "unknown",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eem_read_csv_+3A_path">path</code></td>
<td>
<p>path to file(s), either a filename or a folder</p>
</td></tr>
<tr><td><code id="eem_read_csv_+3A_col">col</code></td>
<td>
<p>either &quot;ex&quot; or &quot;em&quot;, what wavelengths are in the columns</p>
</td></tr>
<tr><td><code id="eem_read_csv_+3A_recursive">recursive</code></td>
<td>
<p>logical, whether directories are loaded recursively</p>
</td></tr>
<tr><td><code id="eem_read_csv_+3A_is_blank_corrected">is_blank_corrected</code></td>
<td>
<p>logical, whether blank correction was done</p>
</td></tr>
<tr><td><code id="eem_read_csv_+3A_is_scatter_corrected">is_scatter_corrected</code></td>
<td>
<p>logical, wether scatters were corrected</p>
</td></tr>
<tr><td><code id="eem_read_csv_+3A_is_ife_corrected">is_ife_corrected</code></td>
<td>
<p>logical, wether inner-filter effect correction was done</p>
</td></tr>
<tr><td><code id="eem_read_csv_+3A_is_raman_normalized">is_raman_normalized</code></td>
<td>
<p>logical, wether raman normalisation applied</p>
</td></tr>
<tr><td><code id="eem_read_csv_+3A_manufacturer">manufacturer</code></td>
<td>
<p>string specifying manufacturer of instrument</p>
</td></tr>
<tr><td><code id="eem_read_csv_+3A_...">...</code></td>
<td>
<p>parameters from other functions, currently not used</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>eems &lt;- system.file("extdata/EEMs",package="staRdom")
eem_list &lt;- eem_read_csv(eems)

eem_list
</code></pre>

<hr>
<h2 id='eem_red2smallest'>Remove wavelengths, that are missing in at least one sample form the whole set.</h2><span id='topic+eem_red2smallest'></span>

<h3>Description</h3>

<p>Remove wavelengths, that are missing in at least one sample form the whole set.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eem_red2smallest(data, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eem_red2smallest_+3A_data">data</code></td>
<td>
<p>data of EEM samples as eemlist</p>
</td></tr>
<tr><td><code id="eem_red2smallest_+3A_verbose">verbose</code></td>
<td>
<p>states whether additional information is given in the command line</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This step is neccessary to perform a PARAFAC analysis which can only be calculated with spectra of similar range.
</p>


<h3>Value</h3>

<p>eemlist with reduced spectral width
</p>


<h3>Examples</h3>

<pre><code class='language-R'>require(dplyr)

data(eem_list)

eem_list_red &lt;- eem_red2smallest(eem_list)

# create an eemlist where data is missing
eem_list2 &lt;- eem_exclude(eem_list,
    list("ex" = c(280,290,350),
         "em" = c(402,510),
         "sample" = c()))

# modify names of samples with missing data
eem_names(eem_list2) &lt;- paste0("x",eem_names(eem_list2))

# combined the lists with and without missing data
eem_list3 &lt;- eem_bind(eem_list,eem_list2)
#ggeem(eem_list3)

# reduce the data in the whole sampleset to the smallest wavelengths that are present in all samples
eem_list4 &lt;- eem_red2smallest(eem_list3)
#ggeem(eem_list4)

</code></pre>

<hr>
<h2 id='eem_rem_scat'>Remove Raman and Rayleigh scattering in fluorescence data</h2><span id='topic+eem_rem_scat'></span>

<h3>Description</h3>

<p>Wrapper function to remove several scatterings in one step using <code><a href="eemR.html#topic+eem_remove_scattering">eem_remove_scattering</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eem_rem_scat(
  data,
  remove_scatter,
  remove_scatter_width = 10,
  interpolation = FALSE,
  cores = parallel::detectCores(logical = FALSE),
  verbose = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eem_rem_scat_+3A_data">data</code></td>
<td>
<p>object of class eemlist</p>
</td></tr>
<tr><td><code id="eem_rem_scat_+3A_remove_scatter">remove_scatter</code></td>
<td>
<p>logical vector. The meanings of the vector are &quot;raman1&quot;, &quot;raman2&quot;, &quot;rayleigh1&quot; and &quot;rayleigh2&quot; scattering. Set <code>TRUE</code> if certain scattering should be removed.</p>
</td></tr>
<tr><td><code id="eem_rem_scat_+3A_remove_scatter_width">remove_scatter_width</code></td>
<td>
<p>numeric vector containing width of scattering to remove. If there is only one element in this vector, each this is the width of each removed scattering. If there are 4 values, differnt widths are used ordered by &quot;raman1&quot;, &quot;raman2&quot;, &quot;rayleigh1&quot; and &quot;rayleigh2&quot;.</p>
</td></tr>
<tr><td><code id="eem_rem_scat_+3A_interpolation">interpolation</code></td>
<td>
<p>logical, optionally states whether interpolation is done right away</p>
</td></tr>
<tr><td><code id="eem_rem_scat_+3A_cores">cores</code></td>
<td>
<p>optional, CPU cores to use for interpolation</p>
</td></tr>
<tr><td><code id="eem_rem_scat_+3A_verbose">verbose</code></td>
<td>
<p>logical, provide additional information</p>
</td></tr>
</table>


<h3>Value</h3>

<p>eemlist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eem_list)

remove_scatter &lt;- c(TRUE, TRUE, TRUE, TRUE)

remove_scatter_width = c(15,10,16,12)

eems &lt;- eem_rem_scat(eem_list,remove_scatter,remove_scatter_width)
ggeem(eems)
</code></pre>

<hr>
<h2 id='eem_scale_ext'>Determine the range of fluorescence values in a set of samples</h2><span id='topic+eem_scale_ext'></span>

<h3>Description</h3>

<p>Determine the range of fluorescence values in a set of samples
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eem_scale_ext(data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eem_scale_ext_+3A_data">data</code></td>
<td>
<p>eemlist containing the EEM data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric vector
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eem_list)
eem_scale_ext(eem_list)
</code></pre>

<hr>
<h2 id='eem_setNA'>set parts of specific samples to NA and optionally interpolate these parts</h2><span id='topic+eem_setNA'></span>

<h3>Description</h3>

<p>set parts of specific samples to NA and optionally interpolate these parts
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eem_setNA(
  eem_list,
  sample = NULL,
  em = NULL,
  ex = NULL,
  interpolate = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eem_setNA_+3A_eem_list">eem_list</code></td>
<td>
<p>EEMs as eemlist</p>
</td></tr>
<tr><td><code id="eem_setNA_+3A_sample">sample</code></td>
<td>
<p>optional, names or indices of samples to process</p>
</td></tr>
<tr><td><code id="eem_setNA_+3A_em">em</code></td>
<td>
<p>optional, emission wavelengths to set NA</p>
</td></tr>
<tr><td><code id="eem_setNA_+3A_ex">ex</code></td>
<td>
<p>optional, excitation wavelengths to set NA</p>
</td></tr>
<tr><td><code id="eem_setNA_+3A_interpolate">interpolate</code></td>
<td>
<p>FALSE, 1 or 2, interpolate NAs or not, 2 different methods, see <code><a href="#topic+eem_interp">eem_interp</a></code></p>
</td></tr>
<tr><td><code id="eem_setNA_+3A_...">...</code></td>
<td>
<p>arguments passed on to <code><a href="#topic+eem_interp">eem_interp</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Samples and wavelengths are optional and if not set all of them are considered in setting data to NA. Wavelengths can be set as vectors containing more than the wavelengths present in the data. E.g. 230:250 removes all wavelengths between 230 and 250 if present. Data is best interpolated if it does not reach data boundaries. Please check the results otherwise as in some cases the interpolation might not produce meaningful data.
</p>


<h3>Value</h3>

<p>eemlist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eem_list)
eem &lt;- eem_list[1:9]
class(eem) &lt;- "eemlist"

ggeem(eem)

eem_list2 &lt;- eem_setNA(eem,ex=200:280,em=500:600, interpolate=FALSE)
ggeem(eem_list2)
</code></pre>

<hr>
<h2 id='eem_smooth'>Smooth fluorescence data by calculating rolling mean along excitation wavelengths.</h2><span id='topic+eem_smooth'></span>

<h3>Description</h3>

<p>Smooth fluorescence data by calculating rolling mean along excitation wavelengths.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eem_smooth(data, n = 4, cores = parallel::detectCores(logical = FALSE))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eem_smooth_+3A_data">data</code></td>
<td>
<p>fluorescence data of class eemlist</p>
</td></tr>
<tr><td><code id="eem_smooth_+3A_n">n</code></td>
<td>
<p>width of rolling mean window in nm</p>
</td></tr>
<tr><td><code id="eem_smooth_+3A_cores">cores</code></td>
<td>
<p>number of CPU cores to be used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>eemlist with smoothed data
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(eem_list)

eem_list &lt;- eem_smooth(eem_list, n = 4, cores = 2)

</code></pre>

<hr>
<h2 id='eem_spectral_cor'>Multiply EEMs with spectral correction vectors (Emission and Excitation)</h2><span id='topic+eem_spectral_cor'></span>

<h3>Description</h3>

<p>Multiply EEMs with spectral correction vectors (Emission and Excitation)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eem_spectral_cor(eem_list, Excor, Emcor)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eem_spectral_cor_+3A_eem_list">eem_list</code></td>
<td>
<p>eemlist</p>
</td></tr>
<tr><td><code id="eem_spectral_cor_+3A_excor">Excor</code></td>
<td>
<p>data frame, first column wavelengths, second column excitation correction</p>
</td></tr>
<tr><td><code id="eem_spectral_cor_+3A_emcor">Emcor</code></td>
<td>
<p>data frame, first column wavelengths, second column emission correction</p>
</td></tr>
</table>


<h3>Value</h3>

<p>eemlist
</p>


<h3>Examples</h3>

<pre><code class='language-R'>eems &lt;- system.file("extdata/EEMs",package="staRdom")
eem_list &lt;- eem_read(eems, recursive = TRUE, import_function = eem_csv)

excorfile &lt;- system.file("extdata/CorrectionFiles/xc06se06n.csv",package="staRdom")
Excor &lt;- data.table::fread(excorfile)
emcorfile &lt;- system.file("extdata/CorrectionFiles/mcorrs_4nm.csv",package="staRdom")
Emcor &lt;- data.table::fread(emcorfile)

# adjust range of EEMs to cover correction vectors
eem_list &lt;- eem_range(eem_list,ex = range(Excor[,1]), em = range(Emcor[,1]))

eem_list_sc &lt;- eem_spectral_cor(eem_list,Excor,Emcor)
</code></pre>

<hr>
<h2 id='eem_write_csv'>Export samples in an EEM list to a single csv files</h2><span id='topic+eem_write_csv'></span>

<h3>Description</h3>

<p>Export samples in an EEM list to a single csv files
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eem_write_csv(eem_list, output, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eem_write_csv_+3A_eem_list">eem_list</code></td>
<td>
<p>EEM data as eemlist</p>
</td></tr>
<tr><td><code id="eem_write_csv_+3A_output">output</code></td>
<td>
<p>path to folder where csv files are exported to</p>
</td></tr>
<tr><td><code id="eem_write_csv_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the exported EEMs as a list of data.frames
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eem_list)

output &lt;- tempdir()
output
a &lt;- eem_write_csv(eem_list, output)
</code></pre>

<hr>
<h2 id='eem2array'>Data from an eemlist is transformed into an array</h2><span id='topic+eem2array'></span>

<h3>Description</h3>

<p>Data matrices from EEM are combined to an array that is needed for a PARAFAC analysis.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eem2array(eem_list)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eem2array_+3A_eem_list">eem_list</code></td>
<td>
<p>object of class eemlist</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class array
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eem_list)

X &lt;- eem2array(eem_list)
</code></pre>

<hr>
<h2 id='eempf_bindxc'>Combining extracted components of PARAFAC models</h2><span id='topic+eempf_bindxc'></span>

<h3>Description</h3>

<p>Combining extracted components of PARAFAC models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eempf_bindxc(components)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eempf_bindxc_+3A_components">components</code></td>
<td>
<p>list of parafac_components</p>
</td></tr>
</table>


<h3>Value</h3>

<p>parafac_components
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pf_models)
pfmodel &lt;- pf4[[1]]
comps &lt;- eempf_excomp(pfmodel,c(1,3))
comps2 &lt;- eempf_excomp(pfmodel,c(4,6))
comps3 &lt;- eempf_bindxc(list(comps, comps2))

</code></pre>

<hr>
<h2 id='eempf_comp_load_plot'>Plot components from a PARAFAC model</h2><span id='topic+eempf_comp_load_plot'></span>

<h3>Description</h3>

<p>Additionally a bar plot with the amounts of each component in each sample is produced.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eempf_comp_load_plot(pfmodel, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eempf_comp_load_plot_+3A_pfmodel">pfmodel</code></td>
<td>
<p>object of class parafac</p>
</td></tr>
<tr><td><code id="eempf_comp_load_plot_+3A_...">...</code></td>
<td>
<p>attributes passe don to <code><a href="#topic+ggeem">ggeem</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ggeem">ggeem</a></code>, <code><a href="#topic+eempf_load_plot">eempf_load_plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pf_models)

eempf_comp_load_plot(pf4[[1]])
</code></pre>

<hr>
<h2 id='eempf_comp_mat'>Extract EEM matrix for single components determined in the PARAFAC analysis</h2><span id='topic+eempf_comp_mat'></span>

<h3>Description</h3>

<p>The components of a PARAFAC analysis are extracted as a data frame
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eempf_comp_mat(pfmodel, gather = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eempf_comp_mat_+3A_pfmodel">pfmodel</code></td>
<td>
<p>object of class parafac</p>
</td></tr>
<tr><td><code id="eempf_comp_mat_+3A_gather">gather</code></td>
<td>
<p>logical value whether excitation wavelengths are a column, otherwise excitation wavelengths are column names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of class data frames
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pf_models)

eempf_comp_mat(pf4[[1]])
</code></pre>

<hr>
<h2 id='eempf_comp_names'>Extract names from PARAFAC model components</h2><span id='topic+eempf_comp_names'></span>

<h3>Description</h3>

<p>Extract names from PARAFAC model components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eempf_comp_names(pfmodel)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eempf_comp_names_+3A_pfmodel">pfmodel</code></td>
<td>
<p>parafac model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector of names or list of vecters of names
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pf_models)
eempf_comp_names(pf4)

eempf_comp_names(pf4) &lt;- c("A","B","C","D","E","F","G")

value &lt;- list(c("A1","B1","C1","D","E","F","G"),
c("A2","B2","C","D","E","F","G"),
c("A3","B3","C","D","E","F","G"),
c("A4","B4","C","D","E","F","G"),
c("A5","B5","C","D","E","F","G5")
)

eempf_comp_names(pf4) &lt;- value
eempf_comp_names(pf4)

ggeem(pf4[[1]])

</code></pre>

<hr>
<h2 id='eempf_comp_names+26lt+3B-'>Set names of PARAFAC components</h2><span id='topic+eempf_comp_names+3C-'></span>

<h3>Description</h3>

<p>Set names of PARAFAC components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eempf_comp_names(pfmodel) &lt;- value
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eempf_comp_names+2B26lt+2B3B-_+3A_pfmodel">pfmodel</code></td>
<td>
<p>model of class parafac</p>
</td></tr>
<tr><td><code id="eempf_comp_names+2B26lt+2B3B-_+3A_value">value</code></td>
<td>
<p>character vector containing the new names for the components</p>
</td></tr>
</table>


<h3>Value</h3>

<p>parafac model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pf_models)

eempf_comp_names(pf4) &lt;- c("A","B","C","D","E","F","G")
</code></pre>

<hr>
<h2 id='eempf_compare'>Plot a set of PARAFAC models to compare the single components</h2><span id='topic+eempf_compare'></span>

<h3>Description</h3>

<p>Three plots are returned:
</p>

<ol>
<li><p> plot of numer of components vs. model fit
</p>
</li>
<li><p> plot of different components as colour maps
</p>
</li>
<li><p> plot of different components as peak lines
</p>
</li></ol>

<p>The plots are intended to help with a suitable number of components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eempf_compare(pfres, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eempf_compare_+3A_pfres">pfres</code></td>
<td>
<p>list of several objects of class parafac</p>
</td></tr>
<tr><td><code id="eempf_compare_+3A_...">...</code></td>
<td>
<p>arguments passed on to <code><a href="#topic+eempf_fits">eempf_fits</a></code> and <code><a href="#topic+eempf_plot_comps">eempf_plot_comps</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>3 objects of class ggplot
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eempf_fits">eempf_fits</a></code>, <code><a href="#topic+eempf_plot_comps">eempf_plot_comps</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pf_models)

eempf_compare(pf4)

</code></pre>

<hr>
<h2 id='eempf_comps3D'>3D plots of PARAFAC components</h2><span id='topic+eempf_comps3D'></span>

<h3>Description</h3>

<p>Interactive 3D plots are created using plotly.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eempf_comps3D(pfmodel, which = NULL)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eempf_comps3D_+3A_pfmodel">pfmodel</code></td>
<td>
<p>object of class parafac</p>
</td></tr>
<tr><td><code id="eempf_comps3D_+3A_which">which</code></td>
<td>
<p>optional, if numeric selects certain component</p>
</td></tr>
</table>


<h3>Value</h3>

<p>plotly plot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(pf_models)

eempf_comps3D(pf4[[1]])

## End(Not run)
</code></pre>

<hr>
<h2 id='eempf_convergence'>Extract modelling information from a PARAFAC model.</h2><span id='topic+eempf_convergence'></span>

<h3>Description</h3>

<p>The convergence behaviour of all initialisations in a PARAFAC model is shown by printing the numbers
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eempf_convergence(pfmodel, print = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eempf_convergence_+3A_pfmodel">pfmodel</code></td>
<td>
<p>PARAFAC model created with staRdom using output = &quot;all&quot;</p>
</td></tr>
<tr><td><code id="eempf_convergence_+3A_print">print</code></td>
<td>
<p>logical, whether you want console output or just a list with results</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list with numbers of converging models, cflags and SSEs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("pf_models")

pfmodel &lt;- pf4[[1]]
conv_beh &lt;- eempf_convergence(pfmodel)
</code></pre>

<hr>
<h2 id='eempf_corcondia'>Calculate the core consistancy of an EEM PARAFAC model</h2><span id='topic+eempf_corcondia'></span>

<h3>Description</h3>

<p>This is basically a wrapper for <code><a href="multiway.html#topic+corcondia">corcondia</a></code> that deals with the normalisation of the original data., Other than <code><a href="multiway.html#topic+corcondia">corcondia</a></code>, the default dicisor = &quot;core&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eempf_corcondia(pfmodel, eem_list, divisor = "core")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eempf_corcondia_+3A_pfmodel">pfmodel</code></td>
<td>
<p>PARAFAC model</p>
</td></tr>
<tr><td><code id="eempf_corcondia_+3A_eem_list">eem_list</code></td>
<td>
<p>eemlist</p>
</td></tr>
<tr><td><code id="eempf_corcondia_+3A_divisor">divisor</code></td>
<td>
<p>divisor, please refer to <code><a href="multiway.html#topic+corcondia">corcondia</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>numeric
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# due to data limitation in package, example does not work with that data!

# eempf_corcondia(pfmodel,eem_list)


## End(Not run)
</code></pre>

<hr>
<h2 id='eempf_corplot'>Plot correlations of components in samples</h2><span id='topic+eempf_corplot'></span>

<h3>Description</h3>

<p>A pair plot showing correlations between samples is created.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eempf_corplot(
  pfmodel,
  normalisation = FALSE,
  lower = list(continuous = "smooth"),
  mapping = aes(alpha = 0.2),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eempf_corplot_+3A_pfmodel">pfmodel</code></td>
<td>
<p>object of class parafac</p>
</td></tr>
<tr><td><code id="eempf_corplot_+3A_normalisation">normalisation</code></td>
<td>
<p>logical, whether normalisation is undone or not</p>
</td></tr>
<tr><td><code id="eempf_corplot_+3A_lower">lower</code></td>
<td>
<p>style of lower plots, see <code><a href="GGally.html#topic+ggpairs">ggpairs</a></code></p>
</td></tr>
<tr><td><code id="eempf_corplot_+3A_mapping">mapping</code></td>
<td>
<p>aesthetic mapping, see <code><a href="GGally.html#topic+ggpairs">ggpairs</a></code></p>
</td></tr>
<tr><td><code id="eempf_corplot_+3A_...">...</code></td>
<td>
<p>passed on to <code><a href="GGally.html#topic+ggpairs">ggpairs</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class ggplot
</p>


<h3>See Also</h3>

<p><code><a href="GGally.html#topic+ggpairs">ggpairs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pf_models)
eempf_corplot(pf4[[1]])


</code></pre>

<hr>
<h2 id='eempf_cortable'>Calculating correlations between the component loadings in all samples (C-Modes).</h2><span id='topic+eempf_cortable'></span>

<h3>Description</h3>

<p>Calculating correlations between the component loadings in all samples (C-Modes).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eempf_cortable(pfmodel, normalisation = FALSE, method = "pearson", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eempf_cortable_+3A_pfmodel">pfmodel</code></td>
<td>
<p>results from a PARAFAC analysis, class parafac</p>
</td></tr>
<tr><td><code id="eempf_cortable_+3A_normalisation">normalisation</code></td>
<td>
<p>logical, whether normalisation is undone or not</p>
</td></tr>
<tr><td><code id="eempf_cortable_+3A_method">method</code></td>
<td>
<p>method of correlation, passed to <code><a href="stats.html#topic+cor">cor</a></code></p>
</td></tr>
<tr><td><code id="eempf_cortable_+3A_...">...</code></td>
<td>
<p>passed on to <code><a href="stats.html#topic+cor">cor</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>matrix
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pf_models)
eempf_cortable(pf4[[1]])
</code></pre>

<hr>
<h2 id='eempf_eemqual'>Calculating EEMqual which is an indicator of a PARAFAC model's quality</h2><span id='topic+eempf_eemqual'></span>

<h3>Description</h3>

<p>Calculating EEMqual which is an indicator of a PARAFAC model's quality
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eempf_eemqual(pfmodel, eem_list, splithalf = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eempf_eemqual_+3A_pfmodel">pfmodel</code></td>
<td>
<p>PARAFAC model</p>
</td></tr>
<tr><td><code id="eempf_eemqual_+3A_eem_list">eem_list</code></td>
<td>
<p>EEM data as eemlist</p>
</td></tr>
<tr><td><code id="eempf_eemqual_+3A_splithalf">splithalf</code></td>
<td>
<p>optionally, you can supplie available splithalf results from model to decrease computation time</p>
</td></tr>
<tr><td><code id="eempf_eemqual_+3A_...">...</code></td>
<td>
<p>additional arguments passed to splithalf</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame containing fit, corcondia, product of best TCCs from splithalf analysis, eemqual and splithalf models
</p>


<h3>References</h3>

<p>Rasmus Bro, Maider Vidal, EEMizer: Automated modeling of fluorescence EEM data, Chemometrics and Intelligent Laboratory Systems, Volume 106, Issue 1, 2011, Pages 86-92, ISSN 0169-7439
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# data(eem_list)
# data(pf_models)

# pfmodel &lt;- pf4[[1]]
# eempf_eemqual(eem_list,pfmodel) # insuficient example data to run!

</code></pre>

<hr>
<h2 id='eempf_excomp'>Extracting components of a PARAFAC model</h2><span id='topic+eempf_excomp'></span>

<h3>Description</h3>

<p>Extracting components of a PARAFAC model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eempf_excomp(pfmodel, comps)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eempf_excomp_+3A_pfmodel">pfmodel</code></td>
<td>
<p>parafac model</p>
</td></tr>
<tr><td><code id="eempf_excomp_+3A_comps">comps</code></td>
<td>
<p>vector with numbers of components to extract</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pf_models)
pfmodel &lt;- pf4[[1]]
comps &lt;- eempf_excomp(pfmodel,c(1,3))
</code></pre>

<hr>
<h2 id='eempf_export'>Create one table containing the PARAFAC models factors and optionally exporting it to csv or txt</h2><span id='topic+eempf_export'></span>

<h3>Description</h3>

<p>Create one table containing the PARAFAC models factors and optionally exporting it to csv or txt
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eempf_export(pfmodel, export = NULL, Fmax = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eempf_export_+3A_pfmodel">pfmodel</code></td>
<td>
<p>PARAFAC model</p>
</td></tr>
<tr><td><code id="eempf_export_+3A_export">export</code></td>
<td>
<p>file path to export table</p>
</td></tr>
<tr><td><code id="eempf_export_+3A_fmax">Fmax</code></td>
<td>
<p>rescale modes so the A mode shows the maximum fluorescence</p>
</td></tr>
<tr><td><code id="eempf_export_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code><a href="utils.html#topic+write.table">write.table</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pf_models)

factor_table &lt;- eempf_export(pf4[[1]])
</code></pre>

<hr>
<h2 id='eempf_fits'>Fits vs. components of PARAFAC models are plotted</h2><span id='topic+eempf_fits'></span>

<h3>Description</h3>

<p>Fits vs. components of PARAFAC models are plotted
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eempf_fits(pfres, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eempf_fits_+3A_pfres">pfres</code></td>
<td>
<p>list of objects of class parafac</p>
</td></tr>
<tr><td><code id="eempf_fits_+3A_...">...</code></td>
<td>
<p>arguments passed on to ggplot</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class ggplot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pf_models)

eempf_fits(pf4)
</code></pre>

<hr>
<h2 id='eempf_leverage'>Calculate the leverage of each emission and excitation wavelength and each sample from a single PARAFAC model</h2><span id='topic+eempf_leverage'></span>

<h3>Description</h3>

<p>Calculate the leverage of each emission and excitation wavelength and each sample from a single PARAFAC model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eempf_leverage(pfmodel)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eempf_leverage_+3A_pfmodel">pfmodel</code></td>
<td>
<p>object of class parafac</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of 3 named vectors (emission, excitation wavelengths and samples)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pf_models)

eempf_leverage(pf4[[1]])
</code></pre>

<hr>
<h2 id='eempf_leverage_data'>Combine leverages into one data frame and add optional labels.</h2><span id='topic+eempf_leverage_data'></span>

<h3>Description</h3>

<p>Combine leverages into one data frame and add optional labels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eempf_leverage_data(cpl, qlabel = 0.1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eempf_leverage_data_+3A_cpl">cpl</code></td>
<td>
<p>leverage, outpout from <code><a href="#topic+eempf_leverage">eempf_leverage</a></code></p>
</td></tr>
<tr><td><code id="eempf_leverage_data_+3A_qlabel">qlabel</code></td>
<td>
<p>optional, quantile of which labels are shown (1 = all, 0 = no labels)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pf_models)

leverage &lt;- eempf_leverage(pf4[[1]])
lev_data &lt;- eempf_leverage_data(leverage)
</code></pre>

<hr>
<h2 id='eempf_leverage_ident'>Plot leverage of emission wavelengths, excitation wavelengths and samples.</h2><span id='topic+eempf_leverage_ident'></span>

<h3>Description</h3>

<p>Plot is interactive where you can select values with your mouse. A list of vectors is returned to remove this outliers in a further step from your samples. The labels to be shown can be selected by adding the quatile of samples with highest leverages to be labeled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eempf_leverage_ident(cpl, qlabel = 0.1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eempf_leverage_ident_+3A_cpl">cpl</code></td>
<td>
<p>leverage, outpout from <code><a href="#topic+eempf_leverage">eempf_leverage</a></code></p>
</td></tr>
<tr><td><code id="eempf_leverage_ident_+3A_qlabel">qlabel</code></td>
<td>
<p>optional, quantile of which labels are shown (1 = all, 0 = no labels)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of three vectors containing the names of selected samples
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eempf_leverage_plot">eempf_leverage_plot</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pf_models)

leverage &lt;- eempf_leverage(pf4[[1]])
outliers &lt;- eempf_leverage_ident(leverage)
</code></pre>

<hr>
<h2 id='eempf_leverage_plot'>Plot leverage of emission wavelengths, excitation wavelengths and samples.</h2><span id='topic+eempf_leverage_plot'></span>

<h3>Description</h3>

<p>The labels to be shown can be selected by adding the quatile of samples with highest leverages to be labeled.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eempf_leverage_plot(cpl, qlabel = 0.1)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eempf_leverage_plot_+3A_cpl">cpl</code></td>
<td>
<p>leverage, outpout from <code><a href="#topic+eempf_leverage">eempf_leverage</a></code></p>
</td></tr>
<tr><td><code id="eempf_leverage_plot_+3A_qlabel">qlabel</code></td>
<td>
<p>optional, quantile of which labels are shown (1 = all, 0 = no labels)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot
</p>


<h3>See Also</h3>

<p><code><a href="#topic+eempf_leverage_ident">eempf_leverage_ident</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pf_models)

leverage &lt;- eempf_leverage(pf4[[1]])
eempf_leverage_plot(leverage)
</code></pre>

<hr>
<h2 id='eempf_load_plot'>Plot amount of each component in each sample as bar plot</h2><span id='topic+eempf_load_plot'></span>

<h3>Description</h3>

<p>Plot amount of each component in each sample as bar plot
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eempf_load_plot(pfmodel)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eempf_load_plot_+3A_pfmodel">pfmodel</code></td>
<td>
<p>parafac model</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pf_models)

eempf_load_plot(pf4[[1]])
</code></pre>

<hr>
<h2 id='eempf_mleverage'>Calculate the leverage of each emission and excitation wavelength and each sample from a list of PARAFAC models</h2><span id='topic+eempf_mleverage'></span>

<h3>Description</h3>

<p>Calculate the leverage of each emission and excitation wavelength and each sample from a list of PARAFAC models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eempf_mleverage(pfres_comps, ecdf = FALSE, stats = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eempf_mleverage_+3A_pfres_comps">pfres_comps</code></td>
<td>
<p>object of class parafac</p>
</td></tr>
<tr><td><code id="eempf_mleverage_+3A_ecdf">ecdf</code></td>
<td>
<p>logical, transforme leverages to according empirical quantiles (<code><a href="stats.html#topic+ecdf">ecdf</a></code>)</p>
</td></tr>
<tr><td><code id="eempf_mleverage_+3A_stats">stats</code></td>
<td>
<p>logical, whether means and standard deviations are calculated from leverages</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame containing leverages of wavelengths and samples for each model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pf_models)

eempf_mleverage(pf3)
</code></pre>

<hr>
<h2 id='eempf_OF_upload'>Upload PARAFAC models to openfluor.org</h2><span id='topic+eempf_OF_upload'></span>

<h3>Description</h3>

<p>This function uploads a PARAFAC model to openfluor.org from within R. You need to have an account at openfluor.org and supply the email used for the account to the function. Your password is then asked in a secure way and only used within one execution of this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eempf_OF_upload(email, file)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eempf_OF_upload_+3A_email">email</code></td>
<td>
<p>email address you use to login at openfluor.org as string</p>
</td></tr>
<tr><td><code id="eempf_OF_upload_+3A_file">file</code></td>
<td>
<p>the file containing a PARAFAC model in openfluor format</p>
</td></tr>
</table>


<h3>Value</h3>

<p>HTTP status code from the upload POST
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## due to the need of a valid account, this function cannot be
## tested with generic data.
## Please use your own account to do so.
## Not run: 
data(pf_models)

file &lt;- file.path(tempdir(),"openfluor_example.txt")
eempf_openfluor(pf4[[1]],file)
eempf_OF_upload("helena.glory@rur.play", file)

## End(Not run)
</code></pre>

<hr>
<h2 id='eempf_openfluor'>Write out PARAFAC components to submit to openfluor.org.</h2><span id='topic+eempf_openfluor'></span>

<h3>Description</h3>

<p>openfluor.org offers the possibility to compare your results to others, that were uploaded to the database. This functions writes out a txt containing the header lines and your components. Please open the file in an editor and fill in further information that cannot be covered by this function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eempf_openfluor(
  pfmodel,
  file,
  Fmax = TRUE,
  upload = FALSE,
  email = NULL,
  model_details = list()
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eempf_openfluor_+3A_pfmodel">pfmodel</code></td>
<td>
<p>PARAFAC model</p>
</td></tr>
<tr><td><code id="eempf_openfluor_+3A_file">file</code></td>
<td>
<p>string, path to outputfile. The directory must exist, the file will be created or overwritten if already present.</p>
</td></tr>
<tr><td><code id="eempf_openfluor_+3A_fmax">Fmax</code></td>
<td>
<p>rescale modes so the A mode shows the maximum fluorescence. As openfluor does not accept values above 1, this is a way of scaling the B and C modes to a range between 0 and 1.</p>
</td></tr>
<tr><td><code id="eempf_openfluor_+3A_upload">upload</code></td>
<td>
<p>logical, whether model is directly uploaded to openfluor.org</p>
</td></tr>
<tr><td><code id="eempf_openfluor_+3A_email">email</code></td>
<td>
<p>optional email address to log into openfluor.org</p>
</td></tr>
<tr><td><code id="eempf_openfluor_+3A_model_details">model_details</code></td>
<td>
<p>optional named list with strings to be added in the openfluor file in the fields corresponding to the list names</p>
</td></tr>
</table>


<h3>Value</h3>

<p>txt file
</p>


<h3>Examples</h3>

<pre><code class='language-R'>  data(pf_models)

  model_details &lt;- list(name = "River", creator = "Helena Glory",
  constraints = "non-negative", validation = "split-half", unit= "RU")
  eempf_openfluor(pf4[[1]],file.path(tempdir(),"openfluor_example.txt"),
  upload = FALSE, model_details = model_details)
</code></pre>

<hr>
<h2 id='eempf_plot_comps'>Plot all components of PARAFAC models</h2><span id='topic+eempf_plot_comps'></span>

<h3>Description</h3>

<p>The components can be plottet in two ways: either as a colour map or as two lines (emission, excitation wavelengths) intersecting at the component maximum. If the list of provided models is named, these names are shown in the plot. Otherwise, the models are automatically named by &quot;model#&quot;.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eempf_plot_comps(
  pfres,
  type = 1,
  names = TRUE,
  contour = FALSE,
  colpal = "default",
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eempf_plot_comps_+3A_pfres">pfres</code></td>
<td>
<p>list of PARAFAC models</p>
</td></tr>
<tr><td><code id="eempf_plot_comps_+3A_type">type</code></td>
<td>
<p>1 for a colour map and 2 for em and ex wavelength loadings</p>
</td></tr>
<tr><td><code id="eempf_plot_comps_+3A_names">names</code></td>
<td>
<p>logical, whether names of components should be written into the plot</p>
</td></tr>
<tr><td><code id="eempf_plot_comps_+3A_contour">contour</code></td>
<td>
<p>in case of 3 dimensional component plots, contours are added</p>
</td></tr>
<tr><td><code id="eempf_plot_comps_+3A_colpal">colpal</code></td>
<td>
<p>&quot;default&quot; to use the viridis colour palette, &quot;rainbow&quot; to use a subset of the rainbow palette, any custom vector of colors or a colour palette. A gradient will be produced from this vector. Larger vectors (e.g. 50 elements) can produce smoother gradients.</p>
</td></tr>
<tr><td><code id="eempf_plot_comps_+3A_...">...</code></td>
<td>
<p>arguments passed on to other functions, e.g.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class ggplot
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pf_models)

eempf_plot_comps(pf4, type = 1)

# use a different colour scheme:
# eempf_plot_comps(pf4, type = 1, colpal = heat.colors(50))
eempf_plot_comps(pf4, type = 2)
eempf_plot_comps(list(pf4[[1]],pf4[[1]]), type=1)

</code></pre>

<hr>
<h2 id='eempf_plot_ssccheck'>Plot results from an SSC check</h2><span id='topic+eempf_plot_ssccheck'></span>

<h3>Description</h3>

<p>Plot results from an SSC check
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eempf_plot_ssccheck(ssccheck)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eempf_plot_ssccheck_+3A_ssccheck">ssccheck</code></td>
<td>
<p>outpout from <code><a href="#topic+eempf_ssccheck">eempf_ssccheck</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot element
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pf_models)

ssccheck &lt;- eempf_ssccheck(pfmodels = pf3[1:3], cores = 2)
eempf_plot_ssccheck(ssccheck)

</code></pre>

<hr>
<h2 id='eempf_reorder'>Reorder PARAFAC components</h2><span id='topic+eempf_reorder'></span>

<h3>Description</h3>

<p>Reorder PARAFAC components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eempf_reorder(pfmodel, order, decreasing = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eempf_reorder_+3A_pfmodel">pfmodel</code></td>
<td>
<p>model of class parafac</p>
</td></tr>
<tr><td><code id="eempf_reorder_+3A_order">order</code></td>
<td>
<p>vector containing desired new order or &quot;em&quot; or &quot;ex&quot; to reorder according to emission or excitation wavelengths of the peaks</p>
</td></tr>
<tr><td><code id="eempf_reorder_+3A_decreasing">decreasing</code></td>
<td>
<p>logical, whether components are reordered according to peak wvalengths in a decreasing direction</p>
</td></tr>
</table>


<h3>Value</h3>

<p>parafac model
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pf_models)
ggeem(pf4[[1]])

pf4r &lt;- eempf_reorder(pf4[[1]], "ex")
ggeem(pf4r)
</code></pre>

<hr>
<h2 id='eempf_report'>Create a html report of a PARAFAC analysis</h2><span id='topic+eempf_report'></span>

<h3>Description</h3>

<p>Create a html report of a PARAFAC analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eempf_report(
  pfmodel,
  export,
  eem_list = NULL,
  absorbance = NULL,
  meta = NULL,
  metacolumns = NULL,
  splithalf = FALSE,
  shmodel = NULL,
  performance = FALSE,
  residuals = FALSE,
  spp = 5,
  cores = parallel::detectCores(logical = FALSE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eempf_report_+3A_pfmodel">pfmodel</code></td>
<td>
<p>PARAFAC model</p>
</td></tr>
<tr><td><code id="eempf_report_+3A_export">export</code></td>
<td>
<p>path to exported html file</p>
</td></tr>
<tr><td><code id="eempf_report_+3A_eem_list">eem_list</code></td>
<td>
<p>optional EEM data</p>
</td></tr>
<tr><td><code id="eempf_report_+3A_absorbance">absorbance</code></td>
<td>
<p>optional absorbance data</p>
</td></tr>
<tr><td><code id="eempf_report_+3A_meta">meta</code></td>
<td>
<p>optional meta data table</p>
</td></tr>
<tr><td><code id="eempf_report_+3A_metacolumns">metacolumns</code></td>
<td>
<p>optional column names of metadata table</p>
</td></tr>
<tr><td><code id="eempf_report_+3A_splithalf">splithalf</code></td>
<td>
<p>optional logical, states whether split-half analysis should be included</p>
</td></tr>
<tr><td><code id="eempf_report_+3A_shmodel">shmodel</code></td>
<td>
<p>optional results from split-half analysis. If this data is not supplied but EEM data is available the split-half analysis is calculated on the creation of the report. Calculating the split-half analysis takes some time!</p>
</td></tr>
<tr><td><code id="eempf_report_+3A_performance">performance</code></td>
<td>
<p>calculating model performance: <code><a href="#topic+eempf_eemqual">eempf_eemqual</a></code></p>
</td></tr>
<tr><td><code id="eempf_report_+3A_residuals">residuals</code></td>
<td>
<p>logical, whether residuals are plotted in the report</p>
</td></tr>
<tr><td><code id="eempf_report_+3A_spp">spp</code></td>
<td>
<p>plots per page for loadgins and residuals plot</p>
</td></tr>
<tr><td><code id="eempf_report_+3A_cores">cores</code></td>
<td>
<p>cores to be used for the calculation</p>
</td></tr>
<tr><td><code id="eempf_report_+3A_...">...</code></td>
<td>
<p>arguments to or from other functions</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TRUE if report was created
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
folder &lt;- system.file("extdata/EEMs", package = "staRdom") # load example data
eem_list &lt;- eem_read(folder, recursive = TRUE, import_function = eem_csv)

abs_folder &lt;- system.file("extdata/absorbance", package = "staRdom") # load example data
absorbance &lt;- absorbance_read(abs_folder, cores = 2)

metatable &lt;- system.file("extdata/metatable_dreem.csv",package = "staRdom")
meta &lt;- read.table(metatable, header = TRUE, sep = ",", dec = ".", row.names = 1)

checked &lt;- eem_checkdata(eem_list, absorbance, metadata = meta,
metacolumns = "dilution", error = FALSE)

eem_names(eem_list)
pfm &lt;- A_missing(eem_list,pf4[[1]], cores = 2)
eempf_report(pfm, export = file.path(tempdir(),"pf_report.html"), eem_list = eem_list,
             absorbance = absorbance, meta = metatable, metacolumns = "dilution", cores = 2)


</code></pre>

<hr>
<h2 id='eempf_rescaleBC'>Rescale B and C modes of PARAFAC model</h2><span id='topic+eempf_rescaleBC'></span>

<h3>Description</h3>

<p>B and C modes (emission and excitation wavelengths) are rescaled to RMS of value newscale. This is compensated in A mode (sample loadings).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eempf_rescaleBC(pfmodel, newscale = "Fmax")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eempf_rescaleBC_+3A_pfmodel">pfmodel</code></td>
<td>
<p>object of class parafac</p>
</td></tr>
<tr><td><code id="eempf_rescaleBC_+3A_newscale">newscale</code></td>
<td>
<p>If (default) newscale = &quot;Fmax&quot;, each component will be scaled so the maximum of each component is 1. It is also possible to set a desired root mean-square for each column of the rescaled mode. Can input a scalar or a vector with length equal to the number of factors for the given mode.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class parafac
</p>


<h3>See Also</h3>

<p><code><a href="multiway.html#topic+rescale">rescale</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pf_models)

new_pf &lt;- eempf_rescaleBC(pf4[[1]])
</code></pre>

<hr>
<h2 id='eempf_residuals'>Calculate residuals of EEM data according to a certain model</h2><span id='topic+eempf_residuals'></span>

<h3>Description</h3>

<p>Calculate residuals of EEM data according to a certain model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eempf_residuals(
  pfmodel,
  eem_list,
  select = NULL,
  cores = parallel::detectCores(logical = FALSE)/2
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eempf_residuals_+3A_pfmodel">pfmodel</code></td>
<td>
<p>PARAFAC model of class parafac</p>
</td></tr>
<tr><td><code id="eempf_residuals_+3A_eem_list">eem_list</code></td>
<td>
<p>eemlist containing EEM data</p>
</td></tr>
<tr><td><code id="eempf_residuals_+3A_select">select</code></td>
<td>
<p>character vector containing the names of the desired samples</p>
</td></tr>
<tr><td><code id="eempf_residuals_+3A_cores">cores</code></td>
<td>
<p>number of cores to use for parallel processing</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame with EEM residuals
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(eem_list)
data(pf_models)

residuals &lt;- eempf_residuals(pf4[[1]], eem_list, cores = 2)

</code></pre>

<hr>
<h2 id='eempf_residuals_metrics'>Calculate residual metrics from a PARAFAC model</h2><span id='topic+eempf_residuals_metrics'></span>

<h3>Description</h3>

<p>The metrics calculated with this function are:
</p>

<ul>
<li><p> RSS: residual sum of squares
</p>
</li>
<li><p> MAE: mean absolute error
</p>
</li>
<li><p> SAE: sum of absolute errors
</p>
</li>
<li><p> RSAE: sum of absolute error in relation to the sum of fluorescence and
</p>
</li>
<li><p> LEV: the leverage as described in <code><a href="#topic+eempf_leverage">eempf_leverage</a></code>
The example contains a way to plot these numbers.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>eempf_residuals_metrics(residuals, leverage)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eempf_residuals_metrics_+3A_residuals">residuals</code></td>
<td>
<p>data.frame as derived from <code><a href="#topic+eempf_residuals">eempf_residuals</a></code></p>
</td></tr>
<tr><td><code id="eempf_residuals_metrics_+3A_leverage">leverage</code></td>
<td>
<p>list of data.frames as derived from <code><a href="#topic+eempf_leverage">eempf_leverage</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of data.frames containing residuals metrics for each sample, emission and excitation wavelength
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(eem_list)
data(pf_models)

residuals &lt;- eempf_residuals(pf4[[1]], eem_list, cores = 2)
leverage &lt;- eempf_leverage(pf4[[1]])

metrics &lt;- eempf_residuals_metrics(residuals, leverage)

metrics$sample

## plot different residual metrics
require(dplyr)
require(tidyr)
require(ggplot2)

lapply(names(metrics), function(name){
  metrics[[name]] %&gt;%
  mutate(mode = name, element = !!sym(name))
}) %&gt;%
  bind_rows() %&gt;%
  pivot_longer(cols = RSS:LEV, names_to = "metric", values_to = "value") %&gt;%
  # uncomment the following line to select certain metrics
  # filter(metric %in% c("RSS","LEV")) %&gt;%
  ggplot(aes(x = element, y = value, colour = metric))+
  geom_point()+
  facet_wrap(mode ~ ., ncol = 3, scales = "free")+
  theme(axis.text.x = element_text(angle = 90))+
  scale_y_continuous(trans="log")

</code></pre>

<hr>
<h2 id='eempf_residuals_plot'>Plot samples by means of whole sample, each single component and residuum</h2><span id='topic+eempf_residuals_plot'></span>

<h3>Description</h3>

<p>A raster of plots is created. Each column shows one sample. The top n rows show the n components from the model according their occurance in the certain samples. The second last row shows the residual, not covered by any component in the model and the last row shows the whole sample.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eempf_residuals_plot(
  pfmodel,
  eem_list,
  res_data = NULL,
  spp = 5,
  select = NULL,
  residuals_only = FALSE,
  cores = parallel::detectCores(logical = FALSE),
  contour = FALSE,
  colpal = "default"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eempf_residuals_plot_+3A_pfmodel">pfmodel</code></td>
<td>
<p>object of class parafac containing the generated model</p>
</td></tr>
<tr><td><code id="eempf_residuals_plot_+3A_eem_list">eem_list</code></td>
<td>
<p>object of class eemlist with all the samples that should be plotted</p>
</td></tr>
<tr><td><code id="eempf_residuals_plot_+3A_res_data">res_data</code></td>
<td>
<p>optional, data of sample residuals related to the model, output from <code><a href="#topic+eempf_residuals">eempf_residuals</a></code></p>
</td></tr>
<tr><td><code id="eempf_residuals_plot_+3A_spp">spp</code></td>
<td>
<p>optional, samples per plot</p>
</td></tr>
<tr><td><code id="eempf_residuals_plot_+3A_select">select</code></td>
<td>
<p>optional, character vector of samples you want to plot</p>
</td></tr>
<tr><td><code id="eempf_residuals_plot_+3A_residuals_only">residuals_only</code></td>
<td>
<p>plot only residuals</p>
</td></tr>
<tr><td><code id="eempf_residuals_plot_+3A_cores">cores</code></td>
<td>
<p>number of cores to use for parallel processing</p>
</td></tr>
<tr><td><code id="eempf_residuals_plot_+3A_contour">contour</code></td>
<td>
<p>logical, states whether contours should be plotted</p>
</td></tr>
<tr><td><code id="eempf_residuals_plot_+3A_colpal">colpal</code></td>
<td>
<p>&quot;default&quot; to use the viridis colour palette, &quot;rainbow&quot; to use a subset of the rainbow palette, any custom vector of colors or a colour palette. A gradient will be produced from this vector. Larger vectors (e.g. 50 elements) can produce smoother gradients.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>eem_list may contain samples not used for modelling. Calculation is done by <code><a href="#topic+A_missing">A_missing</a></code>. This especially interesting if outliers are excluded prior modelling and should be evaluated again afterwards.
Usually, residuals contain negative values, while these is the exception in samples and PARAFAC components. Therefore, we decided to use a similar colour palette as in the other plot functions but adding a purple tone for negative values.
</p>


<h3>Value</h3>

<p>several ggplot objects
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(eem_list)
data(pf_models)

eem_list &lt;- eem_extract(eem_list, 1:10)

eem_list &lt;- eem_rem_scat(eem_list, rep(TRUE, 4), c(15,10,16,12))

eempf_residuals_plot(pf4[[1]], eem_list, cores = 2)

# use other colour schemes:
# eempf_residuals_plot(pf4[[1]], eem_list, colpal = c("blue",heat.colors(50)))
# plots &lt;- eempf_residuals_plot(pf4[[1]], eem_list)
# lapply(plots, function(pl){
#   pl +
#     scale_fill_viridis_c() +
#     scale_colour_viridis_c()
# })



</code></pre>

<hr>
<h2 id='eempf_ssc'>Calculate the shift-and shape-sensitive congruence (SSC) between model components</h2><span id='topic+eempf_ssc'></span>

<h3>Description</h3>

<p>The data variable pf_models can be supplied as list of PARAFAC models, output from a splithalf analysis or list of matrices
Please see details of calculation in:
U.J. Wünsch, R. Bro, C.A. Stedmon, P. Wenig, K.R. Murphy, Emerging patterns in the global distribution of dissolved matter fluorescence, Anal. Methods, 11 (2019), pp. 888-893
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eempf_ssc(
  pfmodels,
  tcc = FALSE,
  m = FALSE,
  cores = parallel::detectCores(logical = FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eempf_ssc_+3A_pfmodels">pfmodels</code></td>
<td>
<p>list of either PARAFAC models or component matrices</p>
</td></tr>
<tr><td><code id="eempf_ssc_+3A_tcc">tcc</code></td>
<td>
<p>if set TRUE, TCC is returned instead</p>
</td></tr>
<tr><td><code id="eempf_ssc_+3A_m">m</code></td>
<td>
<p>logical, if TRUE, emission and excitation SSCs or TCCs are combined by calculating the geometric mean</p>
</td></tr>
<tr><td><code id="eempf_ssc_+3A_cores">cores</code></td>
<td>
<p>number of CPU cores to be used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>(list of) tables containing SCCs between components
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
pf_models &lt;- pf3[1:3]

sscs &lt;- eempf_ssc(pf_models, cores = 2)
sscs

tcc &lt;- eempf_ssc(pf_models, tcc = TRUE, cores = 2)
tcc
## mixed tcc (combine em and ex)
mtcc &lt;- eempf_ssc(pf_models, tcc = TRUE, m = TRUE, cores = 2)
mtcc

## compare results from splithalf analysis
sh_sscs &lt;- eempf_ssc(sh, cores = 2)

sh_sscs
## view diagonals only (components with similar numbers only)
lapply(sh_sscs, lapply, diag)

</code></pre>

<hr>
<h2 id='eempf_ssccheck'>Check SSCs between different models or initialisations of one model</h2><span id='topic+eempf_ssccheck'></span>

<h3>Description</h3>

<p>Check SSCs between different models or initialisations of one model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eempf_ssccheck(
  pfmodels,
  best = length(pfmodels),
  tcc = FALSE,
  cores = parallel::detectCores(logical = FALSE)
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eempf_ssccheck_+3A_pfmodels">pfmodels</code></td>
<td>
<p>list of parafac models</p>
</td></tr>
<tr><td><code id="eempf_ssccheck_+3A_best">best</code></td>
<td>
<p>number of models with the highest R^2 to be used, default is all models</p>
</td></tr>
<tr><td><code id="eempf_ssccheck_+3A_tcc">tcc</code></td>
<td>
<p>logical, if TRUE, TCC instead of SSC is calculated</p>
</td></tr>
<tr><td><code id="eempf_ssccheck_+3A_cores">cores</code></td>
<td>
<p>number of CPU cores to be used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame containing SSCs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pf_models)

eempf_ssccheck(pf3[1:2], cores = 2)

# SSCs of split-half models, models need to be unlisted
data(sh)
eempf_ssccheck(unlist(sh, recursive = FALSE), cores = 2)

</code></pre>

<hr>
<h2 id='eempf_varimp'>Calculate the importance of each component.</h2><span id='topic+eempf_varimp'></span>

<h3>Description</h3>

<p>Calculate the importance of each component.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eempf_varimp(
  pfmodel,
  eem_list,
  cores = parallel::detectCores(logical = FALSE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eempf_varimp_+3A_pfmodel">pfmodel</code></td>
<td>
<p>model of class parafac</p>
</td></tr>
<tr><td><code id="eempf_varimp_+3A_eem_list">eem_list</code></td>
<td>
<p>eemlist used to calculate that model</p>
</td></tr>
<tr><td><code id="eempf_varimp_+3A_cores">cores</code></td>
<td>
<p>cores to be used for the calculation</p>
</td></tr>
<tr><td><code id="eempf_varimp_+3A_...">...</code></td>
<td>
<p>other aruments passed to eem_parafac</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The importance of each variable is calculated by means of creating a model without a specific component and calculating the difference between the original R-squared and the one with the left out component. The derived values state the loss in model fit if one component is not used in the modeling process. For the creation of the new models, the exact components of the original model are used.
</p>


<h3>Value</h3>

<p>numeric vector, values are in the same order of the components in the supplied model.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(pfmodel)
data(eem_list)

eempf_varimp(pf4[[1]], eem_list, cores = 2)

</code></pre>

<hr>
<h2 id='eempf4analysis'>Create table of PARAFAC components and (optionally) EEM peaks and indices as well as absorbance slope parameters.</h2><span id='topic+eempf4analysis'></span>

<h3>Description</h3>

<p>Please refer to <code><a href="eemR.html#topic+eem_biological_index">eem_biological_index</a></code>, <code><a href="eemR.html#topic+eem_coble_peaks">eem_coble_peaks</a></code>, <code><a href="eemR.html#topic+eem_fluorescence_index">eem_fluorescence_index</a></code>, <code><a href="eemR.html#topic+eem_biological_index">eem_biological_index</a></code> and <code><a href="#topic+abs_parms">abs_parms</a></code> for details on the certain values
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eempf4analysis(
  pfmodel,
  eem_list = NULL,
  absorbance = NULL,
  cuvl = NULL,
  n = 4,
  export = NULL,
  cores = parallel::detectCores(logical = FALSE),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="eempf4analysis_+3A_pfmodel">pfmodel</code></td>
<td>
<p>PARAFAC model where loadings of the components are extracted</p>
</td></tr>
<tr><td><code id="eempf4analysis_+3A_eem_list">eem_list</code></td>
<td>
<p>optional eemlist used for peak and indices calculation</p>
</td></tr>
<tr><td><code id="eempf4analysis_+3A_absorbance">absorbance</code></td>
<td>
<p>optional absorbance table used for absorbance slope parameter calculation</p>
</td></tr>
<tr><td><code id="eempf4analysis_+3A_cuvl">cuvl</code></td>
<td>
<p>optional cuvette length of absorbance data in cm</p>
</td></tr>
<tr><td><code id="eempf4analysis_+3A_n">n</code></td>
<td>
<p>optional size of moving window in nm for data smoothing in advance of peak picking</p>
</td></tr>
<tr><td><code id="eempf4analysis_+3A_export">export</code></td>
<td>
<p>optional file path of csv or txt table where data is exported</p>
</td></tr>
<tr><td><code id="eempf4analysis_+3A_cores">cores</code></td>
<td>
<p>number of parallel calculations (e.g. number of physical cores in CPU)</p>
</td></tr>
<tr><td><code id="eempf4analysis_+3A_...">...</code></td>
<td>
<p>additional parameters passed to <code><a href="utils.html#topic+write.table">write.table</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(eem_list)
data(pf_models)

results &lt;- eempf4analysis(pfmodel = pf4[[1]],
                          eem_list = eem_list,
                          cuvl = 5, n = 4, cores = 2)
                          
</code></pre>

<hr>
<h2 id='ggeem'>EEM spectra plotted with ggplot2</h2><span id='topic+ggeem'></span><span id='topic+ggeem.default'></span><span id='topic+ggeem.eemlist'></span><span id='topic+ggeem.eem'></span><span id='topic+ggeem.parafac'></span><span id='topic+ggeem.data.frame'></span>

<h3>Description</h3>

<p>Plots from EEM spectra of class <code>ggplot</code>. In case you work with a larger number of EEMs and want to show then in several plots, you can use <code><a href="#topic+eem_overview_plot">eem_overview_plot</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ggeem(data, fill_max = FALSE, ...)

## Default S3 method:
ggeem(data, fill_max = FALSE, ...)

## S3 method for class 'eemlist'
ggeem(data, fill_max = FALSE, eemlist_order = TRUE, ...)

## S3 method for class 'eem'
ggeem(data, fill_max = FALSE, ...)

## S3 method for class 'parafac'
ggeem(data, fill_max = FALSE, ...)

## S3 method for class 'data.frame'
ggeem(
  data,
  fill_max = FALSE,
  colpal = "default",
  contour = FALSE,
  interpolate = FALSE,
  redneg = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ggeem_+3A_data">data</code></td>
<td>
<p>eem, eemlist, parafac or data.frame. The details are given under 'Details'.</p>
</td></tr>
<tr><td><code id="ggeem_+3A_fill_max">fill_max</code></td>
<td>
<p>sets the maximum fluorescence value for the colour scale. This is mainly used by other functions, and makes different plots visually comparable.</p>
</td></tr>
<tr><td><code id="ggeem_+3A_...">...</code></td>
<td>
<p>parameters passed on to <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code>.</p>
</td></tr>
<tr><td><code id="ggeem_+3A_eemlist_order">eemlist_order</code></td>
<td>
<p>logical, in case of an eemlist, the order of samples in the plot is the same as in the eemlist, alphabetically otherwise</p>
</td></tr>
<tr><td><code id="ggeem_+3A_colpal">colpal</code></td>
<td>
<p>&quot;default&quot; to use the viridis colour palette, &quot;rainbow&quot; to use a subset of the rainbow palette, any custom vector of colors or a colour palette. A gradient will be produced from this vector. Larger vectors (e.g. 50 elements) can produce smoother gradients.</p>
</td></tr>
<tr><td><code id="ggeem_+3A_contour">contour</code></td>
<td>
<p>logical, whether contours should be plotted (default FALSE), see <code><a href="ggplot2.html#topic+geom_contour">geom_contour</a></code></p>
</td></tr>
<tr><td><code id="ggeem_+3A_interpolate">interpolate</code></td>
<td>
<p>logical, whether fluorescence should be interpolated, see <code><a href="ggplot2.html#topic+geom_raster">geom_raster</a></code></p>
</td></tr>
<tr><td><code id="ggeem_+3A_redneg">redneg</code></td>
<td>
<p>deprecated! logical, whether negative values should be coloured discreet.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The data can be of different sources:
eem: a single EEM spectrum is plotted
eemlist: all spectra of the samples are plotted, arranged in a grid
data.frame: a data.frame containing EEM data. Can be created by e.g. <code>as.data.frame.eem</code>
parafac: a PARAFAC model, the components are plotted then.
</p>
<p>Using redneg you can give negative values a reddish colour. This can help identifying these parts in samples or components. Negative values are physically not possible and can only be the result of measuring errors, model deviations and problems with interpolated values.
</p>
<p>Interpolation (interpolate = TRUE) leeds to smoother plots. The default is FALSE because it might cover small scale inconsistencies.
</p>
<p>Contours (contour = TRUE)can be added to the EEM plots.
</p>
<p>A colour palette can be specified using the argument colpal.
</p>
<p>Plotting distinct samples can be done using <code><a href="eemR.html#topic+eem_extract">eem_extract</a></code>. Please see example.
</p>


<h3>Value</h3>

<p>a ggplot object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## plotting two distinct samples
data(eem_list)
eem_names(eem_list)
eem &lt;- eem_extract(eem_list,c("^d667sf$", "^d661sf$"),keep=TRUE)
ggeem(eem)

# the former redneg argument is deprecated, please see a similar looking example below!
#ggeem(eem, redneg = TRUE)
ggeem(eem, colpal = c(rainbow(75)[58],rainbow(75)[53:1]))

# use any custom colour palette
ggeem(eem, colpal = heat.colors(50))
# needs package matlab to be installed:
# ggeem(eem, colpal = matlab::jet.colors(50))
# or by adding ggplot2 colour and fill functions:
# ggeem(eem)+
#   scale_fill_viridis_c()+
#   scale_color_viridis_c()

ggeem(eem, interpolate = TRUE)
ggeem(eem, contour = TRUE)
</code></pre>

<hr>
<h2 id='list_join'>Full join of a list of data frames.</h2><span id='topic+list_join'></span>

<h3>Description</h3>

<p>Full join of a list of data frames.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>list_join(df_list, by)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="list_join_+3A_df_list">df_list</code></td>
<td>
<p>list of data frames to by joined</p>
</td></tr>
<tr><td><code id="list_join_+3A_by">by</code></td>
<td>
<p>character vector containing information how to join data frames. Format to be according to by in <code><a href="dplyr.html#topic+full_join">full_join</a></code>. Each data frame has to contain the column(s) used for joining.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The joint data frame.
</p>


<h3>See Also</h3>

<p><code><a href="dplyr.html#topic+full_join">full_join</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>a &lt;- data.frame(what=letters[1:5],a=c(1:5))
b &lt;- data.frame(what=letters[1:5],b=c(7:11))
c &lt;- data.frame(what=letters[1:5],c=c(20:24))

df_list &lt;- list(a,b,c)

list_join(df_list,by="what")
</code></pre>

<hr>
<h2 id='maxlines'>Extract data from emission and excitation wavelengths of the components of a PARAFAC model (scaled B- and C-modes)</h2><span id='topic+maxlines'></span>

<h3>Description</h3>

<p>Data for each wavelengths is returned. For each component the lines intersecting at the component maxima are returned.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>maxlines(pfmodel)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="maxlines_+3A_pfmodel">pfmodel</code></td>
<td>
<p>object of class parafac</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pf_models)

ml &lt;- maxlines(pf4[[1]])
</code></pre>

<hr>
<h2 id='norm_array'>Normalise 3-dimensional array in first and second dimension</h2><span id='topic+norm_array'></span>

<h3>Description</h3>

<p>Normalise 3-dimensional array in first and second dimension
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm_array(eem_array)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="norm_array_+3A_eem_array">eem_array</code></td>
<td>
<p>3-dimensional array</p>
</td></tr>
</table>


<h3>Value</h3>

<p>array
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(eem_list)

a &lt;- eem2array(eem_list)
an &lt;- norm_array(a)
</code></pre>

<hr>
<h2 id='norm2A'>Compensate for normalisation in C-modes</h2><span id='topic+norm2A'></span>

<h3>Description</h3>

<p>Factors used for normalisation are saved separately in the PARAFAC models. With this function, the normalisation factors are combined with the A-modes of the model and removed as a separate vector. This means former normalisation is accounted for in the amount of each component in each sample. If no normalisation was done, the original model is returned without warning.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>norm2A(pfmodel)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="norm2A_+3A_pfmodel">pfmodel</code></td>
<td>
<p>object of class parafac</p>
</td></tr>
</table>


<h3>Value</h3>

<p>object of class parafac
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pf_models)

pf4[[1]] &lt;- norm2A(pf4[[1]])
</code></pre>

<hr>
<h2 id='parafac_conv'>Calculate a PARAFAC model similar to and using <code><a href="multiway.html#topic+parafac">parafac</a></code>.</h2><span id='topic+parafac_conv'></span>

<h3>Description</h3>

<p>Please refer to <code><a href="multiway.html#topic+parafac">parafac</a></code> for input parameters and details. This wrapper function ensures 'nstart' converging models are calculated. On the contrary, parafac calculates 'nstart' models regardless if they are converging.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parafac_conv(
  X,
  nstart,
  verbose = FALSE,
  output = c("best", "all"),
  cl = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="parafac_conv_+3A_x">X</code></td>
<td>
<p>array</p>
</td></tr>
<tr><td><code id="parafac_conv_+3A_nstart">nstart</code></td>
<td>
<p>number of converging models to calculate</p>
</td></tr>
<tr><td><code id="parafac_conv_+3A_verbose">verbose</code></td>
<td>
<p>logical, whether more information is supplied</p>
</td></tr>
<tr><td><code id="parafac_conv_+3A_output">output</code></td>
<td>
<p>Output the best solution (default) or output all nstart solutions.</p>
</td></tr>
<tr><td><code id="parafac_conv_+3A_cl">cl</code></td>
<td>
<p>cluster to be used for parallel processing</p>
</td></tr>
<tr><td><code id="parafac_conv_+3A_...">...</code></td>
<td>
<p>arguments passed on to <code><a href="multiway.html#topic+parafac">parafac</a></code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>either a parafac model or a list of parafac models
</p>


<h3>See Also</h3>

<p><code><a href="multiway.html#topic+parafac">parafac</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(eem_list)

dim_min &lt;- 3 # minimum number of components
dim_max &lt;- 4 # maximum number of components
nstart &lt;- 25 # random starts for PARAFAC analysis, models built simulanuously, best selected
# cores &lt;- parallel::detectCores(logical=FALSE) # use all cores but do not use all threads
cores &lt;- 2 # package checks only run with 2 cores
maxit = 2500
ctol &lt;- 10^-7 # tolerance for parafac

pfres_comps &lt;- eem_parafac(eem_list, comps = seq(dim_min, dim_max),
    normalise = TRUE, strictly_converging = TRUE, maxit = maxit, nstart = nstart,
    ctol = ctol, cores = cores)

# keep all calculated models for diagnostics
pfres_comps_all &lt;- eem_parafac(eem_list, comps = seq(dim_min, dim_max),
    normalise = TRUE, strictly_converging = TRUE, output = "all", maxit = maxit,
    nstart = nstart, ctol = ctol, cores = cores)


</code></pre>

<hr>
<h2 id='pf1'>PARAFAC model, see vignette, unconstrained</h2><span id='topic+pf1'></span>

<h3>Description</h3>

<p>PARAFAC model, see vignette, unconstrained
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pf1
</code></pre>


<h3>Format</h3>

<p>list of parafacs
</p>

<hr>
<h2 id='pf1n'>PARAFAC model, see vignette, non-negative constraints</h2><span id='topic+pf1n'></span>

<h3>Description</h3>

<p>PARAFAC model, see vignette, non-negative constraints
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pf1n
</code></pre>


<h3>Format</h3>

<p>list of parafacs
</p>

<hr>
<h2 id='pf2'>PARAFAC model, see vignette, non-negative constraints, normalised</h2><span id='topic+pf2'></span>

<h3>Description</h3>

<p>PARAFAC model, see vignette, non-negative constraints, normalised
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pf2
</code></pre>


<h3>Format</h3>

<p>list of parafacs
</p>

<hr>
<h2 id='pf3'>PARAFAC model, see vignette, non-negative constraints, normalised, outliers removed</h2><span id='topic+pf3'></span>

<h3>Description</h3>

<p>PARAFAC model, see vignette, non-negative constraints, normalised, outliers removed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pf3
</code></pre>


<h3>Format</h3>

<p>list of parafacs
</p>

<hr>
<h2 id='pf4'>PARAFAC model, see vignette, non-negative constraints, normalised, outliers removed, high accuarcy</h2><span id='topic+pf4'></span>

<h3>Description</h3>

<p>PARAFAC model, see vignette, non-negative constraints, normalised, outliers removed, high accuarcy
</p>


<h3>Usage</h3>

<pre><code class='language-R'>pf4
</code></pre>


<h3>Format</h3>

<p>list of parafacs
</p>

<hr>
<h2 id='sh'>result from PARAFAC split-half analysis, periodic data split</h2><span id='topic+sh'></span>

<h3>Description</h3>

<p>result from PARAFAC split-half analysis, periodic data split
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sh
</code></pre>


<h3>Format</h3>

<p>list of parafacs
</p>

<hr>
<h2 id='splithalf'>Running a Split-Half analysis on a PARAFAC model</h2><span id='topic+splithalf'></span>

<h3>Description</h3>

<p>The samples are split into four subsamples: A,B,C,D. Subsamples are then combined and compared: AB vs. CD, AC vs. BD, AD vs. BC. The results show graphs from the components of each of the 6 models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splithalf(
  eem_list,
  comps,
  splits = NA,
  rand = FALSE,
  normalise = TRUE,
  nstart = 20,
  cores = parallel::detectCores(logical = FALSE),
  maxit = 2500,
  ctol = 10^(-7),
  rescale = TRUE,
  strictly_converging = FALSE,
  verbose = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splithalf_+3A_eem_list">eem_list</code></td>
<td>
<p>eemlist containing sample data</p>
</td></tr>
<tr><td><code id="splithalf_+3A_comps">comps</code></td>
<td>
<p>number of desired components</p>
</td></tr>
<tr><td><code id="splithalf_+3A_splits">splits</code></td>
<td>
<p>optional, list of 4 numerical vectors containing the sample numbers for A,B,C and D sample subsets</p>
</td></tr>
<tr><td><code id="splithalf_+3A_rand">rand</code></td>
<td>
<p>logical, splits are randomised</p>
</td></tr>
<tr><td><code id="splithalf_+3A_normalise">normalise</code></td>
<td>
<p>state whether EEM data should be normalised in advance</p>
</td></tr>
<tr><td><code id="splithalf_+3A_nstart">nstart</code></td>
<td>
<p>number of random starts</p>
</td></tr>
<tr><td><code id="splithalf_+3A_cores">cores</code></td>
<td>
<p>number of parallel calculations (e.g. number of physical cores in CPU)</p>
</td></tr>
<tr><td><code id="splithalf_+3A_maxit">maxit</code></td>
<td>
<p>maximum iterations for PARAFAC algorithm</p>
</td></tr>
<tr><td><code id="splithalf_+3A_ctol">ctol</code></td>
<td>
<p>Convergence tolerance (R^2 change)</p>
</td></tr>
<tr><td><code id="splithalf_+3A_rescale">rescale</code></td>
<td>
<p>rescale splithalf models to Fmax, see <code><a href="#topic+eempf_rescaleBC">eempf_rescaleBC</a></code></p>
</td></tr>
<tr><td><code id="splithalf_+3A_strictly_converging">strictly_converging</code></td>
<td>
<p>calculate nstart converging models and take the best. Please see <code><a href="#topic+eem_parafac">eem_parafac</a></code>.</p>
</td></tr>
<tr><td><code id="splithalf_+3A_verbose">verbose</code></td>
<td>
<p>states whether you want additional information during calculation</p>
</td></tr>
<tr><td><code id="splithalf_+3A_...">...</code></td>
<td>
<p>additional parameters that are passed on to <code><a href="multiway.html#topic+parafac">parafac</a></code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Split data sets can be split suboptimal and cause low TCCs. Therefore, subsamples are recombined in 3 different ways and a TCC close to 1 in only one split combination per component is already a positive result. Check the split sets to check for sample independency.
</p>


<h3>Value</h3>

<p>data frame containing components of the splithalf models
</p>


<h3>See Also</h3>

<p><code><a href="#topic+splithalf_plot">splithalf_plot</a></code>, <code><a href="#topic+splithalf_tcc">splithalf_tcc</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(eem_list)

splithalf &lt;- splithalf(eem_list, comps = 6, verbose = TRUE, cores = 2)
splithalf_plot(splithalf)

# Similarity of splits using SSCs
sscs &lt;- splithalf_tcc(splithalf)

</code></pre>

<hr>
<h2 id='splithalf_plot'>Plot results from a splithalf analysis</h2><span id='topic+splithalf_plot'></span>

<h3>Description</h3>

<p>Graphs of all components of all models are plotted to be compared.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splithalf_plot(fits)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splithalf_plot_+3A_fits">fits</code></td>
<td>
<p>list of components data</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ggplot
</p>


<h3>See Also</h3>

<p><code><a href="#topic+splithalf">splithalf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sh)

splithalf_plot(sh)
str(sh)
</code></pre>

<hr>
<h2 id='splithalf_splits'>Extracting a list of sample names in each subsample from a splithalf analysis</h2><span id='topic+splithalf_splits'></span>

<h3>Description</h3>

<p>Extracting a list of sample names in each subsample from a splithalf analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splithalf_splits(fits)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splithalf_splits_+3A_fits">fits</code></td>
<td>
<p>list of parafac models (from a splithalf analysis)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame containing TCC values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sh)
splithalf_splits(sh)
</code></pre>

<hr>
<h2 id='splithalf_tcc'>Extracting TCC values from a splithalf analysis</h2><span id='topic+splithalf_tcc'></span>

<h3>Description</h3>

<p>Extracting TCC values from a splithalf analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>splithalf_tcc(fits)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="splithalf_tcc_+3A_fits">fits</code></td>
<td>
<p>list of parafac models (from a splithalf analysis)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data frame containing TCC values
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(sh)

splithalf_tcc(sh)
</code></pre>

<hr>
<h2 id='ssc'>Calculate the shift-and shape-sensitive congruence (SSC) between two matrices</h2><span id='topic+ssc'></span>

<h3>Description</h3>

<p>Please see details in:
U.J. Wünsch, R. Bro, C.A. Stedmon, P. Wenig, K.R. Murphy, Emerging patterns in the global distribution of dissolved matter fluorescence, Anal. Methods, 11 (2019), pp. 888-893
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssc(mat1, mat2, tcc = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ssc_+3A_mat1">mat1</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="ssc_+3A_mat2">mat2</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="ssc_+3A_tcc">tcc</code></td>
<td>
<p>if set TRUE, TCC is returned instead</p>
</td></tr>
</table>


<h3>Value</h3>

<p>table containing pairwise SCC of matrices columns
</p>


<h3>Examples</h3>

<pre><code class='language-R'>pf_models &lt;- pf3
mat1 &lt;- pf_models[[1]][[2]]
mat2 &lt;- pf_models[[2]][[2]]

## calculate SSC
ssc(mat1,mat2)

## calculate TCC
ssc(mat1,mat2, tcc = TRUE)

</code></pre>

<hr>
<h2 id='ssc_max'>Calculate the combination of components giving the maximum of geometric mean of TCCs</h2><span id='topic+ssc_max'></span>

<h3>Description</h3>

<p>Calculate the combination of components giving the maximum of geometric mean of TCCs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ssc_max(mat)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ssc_max_+3A_mat">mat</code></td>
<td>
<p>matrix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>vector with TCCs having the highest possible geometric mean
</p>


<h3>Examples</h3>

<pre><code class='language-R'>mat &lt;- matrix(c(7,2,13,6,0,7,1,5,5), nrow = 3)
mat

sscs &lt;- ssc_max(mat)
sscs

# order of components:
attr(sscs,"order")
</code></pre>

<hr>
<h2 id='tcc'>Caluclate Tucker's Congruence Coefficient of PARAFAC components</h2><span id='topic+tcc'></span>

<h3>Description</h3>

<p>Componets must be passed as modes, see <code><a href="#topic+maxlines">maxlines</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcc(maxl_table, na.action = "na.omit")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tcc_+3A_maxl_table">maxl_table</code></td>
<td>
<p>data frame containing the peak lines of components</p>
</td></tr>
<tr><td><code id="tcc_+3A_na.action">na.action</code></td>
<td>
<p>if &quot;na.omit&quot; NA are deleted from prior the test</p>
</td></tr>
</table>


<h3>Value</h3>

<p>data.frame containing the TCCs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(pf_models)

ml &lt;- maxlines(pf4[[1]])

tcc(ml)
</code></pre>

<hr>
<h2 id='tcc_find_pairs'>Reorders components of different PARAFAC models according to best fit (TCC)</h2><span id='topic+tcc_find_pairs'></span>

<h3>Description</h3>

<p>When running a splithalf analysis similar components are not necessarily on the same position. This function looks for best fits with Tucker's Congruence Coefficients and returns a list of models with reordered components.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tcc_find_pairs(fits)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tcc_find_pairs_+3A_fits">fits</code></td>
<td>
<p>list of parafac models</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of parafac models
</p>


<h3>See Also</h3>

<p><code><a href="#topic+splithalf">splithalf</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(eem_list)

# function currently only used from within splithalf
splithalf(eem_list, 6, nstart = 2, cores = 2)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
