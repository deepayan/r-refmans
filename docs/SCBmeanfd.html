<!DOCTYPE html><html><head><title>Help for package SCBmeanfd</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SCBmeanfd}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#SCBmeanfd-package'>
<p>Simultaneous Confidence Bands for Mean Functions</p></a></li>
<li><a href='#cv.score'>
<p>Leave-One-Curve-out Cross-Validation Score</p></a></li>
<li><a href='#cv.select'>
<p>Cross-Validation Bandwidth Selection for Local Polynomial Estimation</p></a></li>
<li><a href='#phoneme'>
<p>Phoneme data</p></a></li>
<li><a href='#plasma'>
<p>Plasma citrate data</p></a></li>
<li><a href='#plot.SCBand'><p>Plot a SCBand Object</p></a></li>
<li><a href='#plrt.model'>
<p>Pseudo-Likelihood Ratio Test for Models of the Mean Function</p></a></li>
<li><a href='#plugin.select'>
<p>Plug-in Bandwidth Selection for Local Polynomial Estimation</p></a></li>
<li><a href='#print.SCBand'>
<p>Print a SCBand Object</p></a></li>
<li><a href='#scb.equal'>
<p>Compare Two Mean Functions</p></a></li>
<li><a href='#scb.mean'>
<p>Build Simultaneous Confidence Bands for Mean Functions</p></a></li>
<li><a href='#scb.model'><p>Goodness-Of-Fit of a Model for the Mean Function</p></a></li>
<li><a href='#summary.SCBand'><p>Summarize a SCBand Object</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Simultaneous Confidence Bands for the Mean of Functional Data</td>
</tr>
<tr>
<td>Version:</td>
<td>1.2.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2016-12-22</td>
</tr>
<tr>
<td>Author:</td>
<td>David Degras</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>David Degras &lt;ddegrasv@gmail.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Statistical methods for estimating and inferring the mean of functional data. The methods include simultaneous confidence bands, local polynomial fitting,  bandwidth selection by plug-in and cross-validation, goodness-of-fit tests for parametric models, equality tests for two-sample problems, and plotting functions.   </td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10), stats, graphics</td>
</tr>
<tr>
<td>Imports:</td>
<td>boot, KernSmooth</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://CRAN.R-project.org/package=SCBmeanfd">https://CRAN.R-project.org/package=SCBmeanfd</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2016-12-26 22:35:56 UTC; daviddegras</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2016-12-27 14:15:41</td>
</tr>
</table>
<hr>
<h2 id='SCBmeanfd-package'>
Simultaneous Confidence Bands for Mean Functions</h2><span id='topic+SCBmeanfd-package'></span><span id='topic+SCBmeanfd'></span>

<h3>Description</h3>

<p>Statistical methods for estimating and inferring the mean of functional data. The methods include simultaneous confidence bands, local polynomial fitting,  bandwidth selection by plug-in and cross-validation, goodness-of-fit tests for parametric models, equality tests for two-sample problems, and plotting functions.</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
Package: </td><td style="text-align: left;"> SCBmeanfd</td>
</tr>
<tr>
 <td style="text-align: left;">
Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
Version: </td><td style="text-align: left;"> 1.2.1</td>
</tr>
<tr>
 <td style="text-align: left;">
Date: </td><td style="text-align: left;"> 2016-09-24</td>
</tr>
<tr>
 <td style="text-align: left;">
License: </td><td style="text-align: left;"> GPL-3</td>
</tr>
<tr>
 <td style="text-align: left;">
</td>
</tr>

</table>



<h3>Author(s)</h3>

<p>David Degras &lt;ddegrasv@gmail.com&gt;
</p>


<h3>References</h3>

<p>Azzalini, A. and Bowman, A. (1993). On the use of nonparametric regression for checking linear relationships. <em>Journal of the Royal Statistical Society. Series B</em> <b>55</b>, 549-557.
</p>
<p>Benhenni, K. and Degras, D. (2014). Local polynomial estimation of the mean function and its derivatives based on functional data and regular designs. <em>ESAIM: Probability and Statistics</em> <b>18</b>, 881-899.
</p>
<p>Degras, D. (2011). Simultaneous confidence bands for nonparametric regression with functional data. <em>Statistica Sinica</em> <b>21</b>, 1735-1765.
</p>
<p>Rice, J. A. and Silverman, B. W. (1991). Estimating the mean and covariance structure nonparametrically when the data are curves. <em>Journal of the Royal Statistical Society. Series B</em> <b>53</b>, 233-243.
</p>

<hr>
<h2 id='cv.score'>
Leave-One-Curve-out Cross-Validation Score
</h2><span id='topic+cv.score'></span>

<h3>Description</h3>

<p>Compute the cross-validation score of Rice and Silverman (1991) for  the local polynomial estimation of a mean function.</p>


<h3>Usage</h3>

<pre><code class='language-R'>cv.score(bandwidth, x, y, degree = 1, gridsize = length(x))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.score_+3A_bandwidth">bandwidth</code></td>
<td>
<p>kernel bandwidth.</p>
</td></tr>
<tr><td><code id="cv.score_+3A_x">x</code></td>
<td>
<p>observation points. Missing values are not accepted.</p>
</td></tr>
<tr><td><code id="cv.score_+3A_y">y</code></td>
<td>
<p>matrix or data frame with functional observations (= curves) stored in rows. The number of columns of <code>y</code> must match the length of <code>x</code>. Missing values are not accepted.</p>
</td></tr>
<tr><td><code id="cv.score_+3A_degree">degree</code></td>
<td>
<p>degree of the local polynomial fit.</p>
</td></tr>
<tr><td><code id="cv.score_+3A_gridsize">gridsize</code></td>
<td>
<p>size of evaluation grid for the smoothed data.</p>
</td></tr>  
</table>


<h3>Details</h3>

<p>The cross-validation score is obtained by leaving in turn each curve out and computing the prediction error of the local polynomial smoother based on all other curves. For a bandwith value <code class="reqn">h</code>, this score is 
</p>
<p style="text-align: center;"><code class="reqn"> CV(h) = \frac{1}{np} \sum_{i=1}^n \sum_{j=1}^p \left( Y_{ij} - \hat{\mu}^{-(i)}(x_j;h) \right)^2, </code>
</p>

<p>where <code class="reqn">Y_{ij}</code> is the measurement of the <code class="reqn">i</code>-th curve at location <code class="reqn">x_j</code> for <code class="reqn">i=1,\ldots,n</code> and <code class="reqn">j=1,\ldots,p</code>, and <code class="reqn">\hat{\mu}^{-(i)}(x_j;h)</code> is the local polynomial estimator with bandwidth <code class="reqn">h</code> based on all curves except the <code class="reqn">i</code>-th.
</p>
<p>If the <code>x</code> values are not equally spaced, the data are first smoothed and evaluated on a grid of length <code>gridsize</code> spanning the range of <code>x</code>. The smoothed data are then interpolated back to <code>x</code>. 
</p>


<h3>Value</h3>

<p>the cross-validation score.</p>


<h3>References</h3>

<p>Rice, J. A. and Silverman, B. W. (1991). Estimating the mean and covariance structure nonparametrically when the data are curves. <em>Journal of the Royal Statistical Society. Series B (Methodological)</em>, <b>53</b>, 233&ndash;243.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.select">cv.select</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Artificial example 
x &lt;- seq(0, 1, len = 100)
mu &lt;- x + .2 * sin(2 * pi * x)
y &lt;- matrix(mu + rnorm(2000, sd = .25), 20, 100, byrow = TRUE)
h &lt;- c(.005, .01, .02, .05, .1, .15)
cv &lt;- numeric()
for (i in 1:length(h)) cv[i] &lt;- cv.score(h[i], x, y, 1)
plot(h, cv, type = "l")

## Plasma citrate data
## Compare cross-validation scores and bandwidths  
## for local linear and local quadratic smoothing
## Not run: 
data(plasma)
time &lt;- 8:21
h1 &lt;- seq(.5, 1.3, .05)
h2 &lt;- seq(.75, 2, .05)
cv1 &lt;- sapply(h1, cv.score, x = time, y = plasma, degree = 1)
cv2 &lt;- sapply(h2, cv.score, x = time, y = plasma, degree = 2)
plot(h1, cv1, type = "l", xlim = range(c(h1,h2)), ylim = range(c(cv1, cv2)), 
  xlab = "Bandwidth (hour)", ylab = "CV score", 
  main = "Cross validation for local polynomial estimation")
lines(h2, cv2, col = 2)
legend("topleft", legend = c("Linear", "Quadratic"), lty = 1, 
  col = 1:2, cex = .9)

## Note: using local linear (resp. quadratic) smoothing 
## with a bandwidth smaller than .5 (resp. .75) can result 
## in non-definiteness or numerical instability of the estimator. 

## End(Not run)
</code></pre>

<hr>
<h2 id='cv.select'>
Cross-Validation Bandwidth Selection for Local Polynomial Estimation</h2><span id='topic+cv.select'></span>

<h3>Description</h3>

<p>Select the cross-validation bandwidth described in Rice and Silverman (1991) for the local polynomial estimation of a mean function based on functional data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'> cv.select(x, y, degree = 1, interval = NULL, gridsize = length(x), ...) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cv.select_+3A_x">x</code></td>
<td>
<p>observation points. Missing values are not accepted.</p>
</td></tr>
<tr><td><code id="cv.select_+3A_y">y</code></td>
<td>
<p>matrix or data frame with functional observations (= curves) stored in rows. The number of columns of <code>y</code> must match the length of <code>x</code>. Missing values are not accepted.</p>
</td></tr>
<tr><td><code id="cv.select_+3A_degree">degree</code></td>
<td>
<p>degree of the local polynomial fit.</p>
</td></tr>
<tr><td><code id="cv.select_+3A_interval">interval</code></td>
<td>
<p>lower and upper bounds of the search interval (numeric vector of length 2).</p>
</td></tr>
<tr><td><code id="cv.select_+3A_gridsize">gridsize</code></td>
<td>
<p>size of evaluation grid for the smoothed data.</p>
</td></tr>  
<tr><td><code id="cv.select_+3A_...">...</code></td>
<td>
<p>additional arguments to  pass to the optimization function <code><a href="stats.html#topic+optimize">optimize</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cross-validation score is obtained by leaving in turn each curve out and computing the prediction error of the local polynomial smoother based on all other curves. For a bandwith value <code class="reqn">h</code>, this score is 
</p>
<p style="text-align: center;"><code class="reqn"> CV(h) = \frac{1}{np} \sum_{i=1}^n \sum_{j=1}^p \left( Y_{ij} - \hat{\mu}^{-(i)}(x_j;h) \right)^2, </code>
</p>

<p>where <code class="reqn">Y_{ij}</code> is the measurement of the <code class="reqn">i</code>-th curve at location <code class="reqn">x_j</code> for <code class="reqn">i=1,\ldots,n</code> and <code class="reqn">j=1,\ldots,p</code>, and <code class="reqn">\hat{\mu}^{-(i)}(x_j;h)</code> is the local polynomial estimator with bandwidth <code class="reqn">h</code> based on all curves except the <code class="reqn">i</code>-th.
</p>
<p>If the <code>x</code> values are not equally spaced, the data are first smoothed and evaluated on a grid of length <code>gridsize</code> spanning the range of <code>x</code>. The smoothed data are then interpolated back to <code>x</code>. 
</p>
<p><code>cv.select</code> uses the standard R function <code><a href="stats.html#topic+optimize">optimize</a></code> to optimize <code><a href="#topic+cv.score">cv.score</a></code>. If the argument <code>interval</code> is not specified, the lower bound of the search interval is by default <code class="reqn">(x_2-x_1)/2</code> if <code class="reqn">degree &lt; 2</code> and <code class="reqn">x_2-x_1</code> if <code class="reqn">degree &gt;= 2</code>. The default value of the upper bound is <code class="reqn">(\max(x)-\min(x))/2</code>. These values guarantee in most cases that the local polynomial estimator is well defined. It is often useful to plot the function to be optimized for a range of argument values (grid search) before applying a numerical optimizer. In this way, the search interval can be narrowed down and the optimizer is more likely to find a global solution.  
</p>


<h3>Value</h3>

<p>a bandwidth that minimizes the cross-validation score. 
</p>


<h3>References</h3>

<p>Rice, J. A. and Silverman, B. W. (1991). Estimating the mean and covariance structure nonparametrically when the data are curves. <em>Journal of the Royal Statistical Society. Series B (Methodological)</em>, <b>53</b>, 233&ndash;243.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.score">cv.score</a></code>, <code><a href="#topic+plugin.select">plugin.select</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Plasma citrate data
## Compare cross-validation scores and bandwidths  
## for local linear and local quadratic smoothing

data(plasma)
time &lt;- 8:21   				
## Local linear smoothing						
cv.select(time, plasma, 1)	# local solution h = 3.76, S(h) = 463.08			
cv.select(time, plasma, 1, interval = c(.5, 1))	# global solution = .75, S(h) = 439.54

## Local quadratic smoothing						
cv.select(time, plasma, 2)	# global solution h = 1.15, S(h) = 432.75			
cv.select(time, plasma, 2, interval = c(1, 1.5))	# same

## End(Not run)
</code></pre>

<hr>
<h2 id='phoneme'>
Phoneme data</h2><span id='topic+phoneme'></span>

<h3>Description</h3>

<p>Log-periodograms of five phonemes (&quot;sh&quot; as in &quot;she&quot;, &quot;dcl&quot; as in &quot;dark&quot;, &quot;iy&quot; as the vowel in &quot;she&quot;, &quot;aa&quot; as the vowel in &quot;dark&quot;, and &quot;ao&quot; as the first vowel in &quot;water&quot;) spoken by a sample of ~50 male speakers. For each phoneme, 400 log-periodograms are observed on a uniform grid of 150 frequencies.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(phoneme)</code></pre>


<h3>Format</h3>

<p>A data frame with 2000 rows and 151 columns.
Each row contains a discretized log-periodogram (150 first columns) followed by a phoneme indicator (last column) coded as follows:
</p>

<table>
<tr>
 <td style="text-align: center;">
Code </td><td style="text-align: center;"> Phoneme </td>
</tr>
<tr>
 <td style="text-align: center;">
1 </td><td style="text-align: center;"> "sh" </td>
</tr>
<tr>
 <td style="text-align: center;">
2 </td><td style="text-align: center;"> "iy" </td>
</tr>
<tr>
 <td style="text-align: center;">
3 </td><td style="text-align: center;"> "dcl" </td>
</tr>
<tr>
 <td style="text-align: center;">
4 </td><td style="text-align: center;"> "aa" </td>
</tr>
<tr>
 <td style="text-align: center;">
5 </td><td style="text-align: center;"> "ao"</td>
</tr>

</table>



<h3>Source</h3>

<p>This dataset was created by the STAPH group in Toulouse, France<br />
<a href="http://www.math.univ-toulouse.fr/staph/npfda/">http://www.math.univ-toulouse.fr/staph/npfda/</a>.<br />
The larger original dataset can be found at<br />
<a href="http://statweb.stanford.edu/~tibs/ElemStatLearn/">http://statweb.stanford.edu/~tibs/ElemStatLearn/</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(phoneme)
freq &lt;- 1:150
classes &lt;- phoneme[,151]
phoneme &lt;- phoneme[,-151]
classnames &lt;- c("sh", "iy", "dcl", "aa", "ao")

## Local linear fit to the mean log-periodogram for each phoneme 
llfit &lt;- mapply(locpoly, y = by(phoneme, classes, colMeans), 
          MoreArgs = list(x = freq, bandwidth = 2, degree = 1, 
          gridsize = length(freq)))
llfit.y &lt;- matrix(unlist(llfit["y",]), 150, 5)  
matplot(freq, llfit.y, type = "l", lty = 1, xlab = "Frequency (scaled)", 
	ylab = "Log-intensity", 
	main = "Local linear estimation\nof the population mean log-periodogram")
legend("topright", legend = classnames, col = 1:5, lty = 1)

## End(Not run)
</code></pre>

<hr>
<h2 id='plasma'>
Plasma citrate data</h2><span id='topic+plasma'></span>

<h3>Description</h3>

<p>Plasma citrate concentrations measured on 10 human subjects on the same day. The measurements on an individual were taken each hour from 8:00AM to 9:00PM. A possible statistical analysis is to estimate the population mean plasma citrate concentration as a function of time of day.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(plasma)</code></pre>


<h3>Format</h3>

<p>A matrix with 10 rows (corresponding to subjects) and 14 columns (corresponding to hours).
</p>


<h3>Source</h3>

<p>Andersen, A. H., Jensen, E. B. and Schou, G. (1981). Two-way analysis of variance with correlated errors. <em>International Statistical Review</em> <b>49</b>, 153&ndash;157.
</p>
<p>Hart, T. D. and Wehrly, T. E. (1986). Kernel regression estimation using repeated measurements data. <em>Journal of the American Statistical Association</em> <b>81</b>, 1080&ndash;1088.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
data(plasma)
matplot(x = 8:21, y = t(plasma), cex = .75, type = "l", col = 1, lty = 1,
  lwd = .5, xlab = "Time of day (hour)", ylab = "Concentration", 
  main = "Plasma citrate data")
lines(8:21, colMeans(plasma), col = 2, lwd = 1.5)
legend("topright", col = 2, lty = 1, lwd = 1.5, legend = "Mean")
## End(Not run)
</code></pre>

<hr>
<h2 id='plot.SCBand'>Plot a SCBand Object</h2><span id='topic+plot.SCBand'></span>

<h3>Description</h3>

<p><code>plot</code> method for class <code>"SCBand"</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SCBand'
plot(x , y = NULL, xlim = NULL, ylim = NULL, main = NULL, xlab = NULL, 
     ylab = NULL, col = NULL, cex = NULL, pch = NULL, lty = NULL, lwd = NULL, 
     legend = TRUE, where = NULL, text = NULL, legend.cex = NULL, horiz = TRUE, 
     bty = "n", ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.SCBand_+3A_x">x</code></td>
<td>
<p><code>SCBand</code> object, typically result of a call to <code><a href="#topic+scb.mean">scb.mean</a></code>, <code><a href="#topic+scb.model">scb.model</a></code>, or <code><a href="#topic+scb.equal">scb.equal</a></code>.</p>
</td></tr>
<tr><td><code id="plot.SCBand_+3A_y">y</code></td>
<td>
<p>optional y data.</p>
</td></tr>
<tr><td><code id="plot.SCBand_+3A_xlim">xlim</code></td>
<td>
<p>x limits of the plot (numeric vector of length 2).</p>
</td></tr>
<tr><td><code id="plot.SCBand_+3A_ylim">ylim</code></td>
<td>
<p>y limits of the plot (numeric vector of length 2).</p>
</td></tr>
<tr><td><code id="plot.SCBand_+3A_main">main</code></td>
<td>
<p>title of the plot.</p>
</td></tr>
<tr><td><code id="plot.SCBand_+3A_xlab">xlab</code></td>
<td>
<p>label of the x axis.</p>
</td></tr>
<tr><td><code id="plot.SCBand_+3A_ylab">ylab</code></td>
<td>
<p>label of the y axis.</p>
</td></tr>
<tr><td><code id="plot.SCBand_+3A_col">col</code></td>
<td>
<p>colors for lines and points.</p>
</td></tr>
<tr><td><code id="plot.SCBand_+3A_cex">cex</code></td>
<td>
<p>scale of plotting characters and symbols relative to default (numerical vector).</p>
</td></tr>
<tr><td><code id="plot.SCBand_+3A_pch">pch</code></td>
<td>
<p>vector of plotting characters or symbols: see <code><a href="graphics.html#topic+points">points</a></code>.</p>
</td></tr>
<tr><td><code id="plot.SCBand_+3A_lty">lty</code></td>
<td>

<p>a vector of line types, see <code><a href="graphics.html#topic+par">par</a></code>.</p>
</td></tr>
<tr><td><code id="plot.SCBand_+3A_lwd">lwd</code></td>
<td>

<p>a vector of line widths, see <code><a href="graphics.html#topic+par">par</a></code>.
</p>
</td></tr>
<tr><td><code id="plot.SCBand_+3A_legend">legend</code></td>
<td>
<p>logical; if <code>TRUE</code>, a legend is added to the plot.</p>
</td></tr>
<tr><td><code id="plot.SCBand_+3A_where">where</code></td>
<td>
<p>legend location: <code>"bottomright", "bottom"</code>, 
<code>"bottomleft", "left", "topleft", "top", "topright", "right"</code> 
or <code>"center"</code>.</p>
</td></tr>
<tr><td><code id="plot.SCBand_+3A_text">text</code></td>
<td>
<p>text of the legend (character vector).</p>
</td></tr>
<tr><td><code id="plot.SCBand_+3A_legend.cex">legend.cex</code></td>
<td>

<p>character expansion factor relative to current par(&quot;cex&quot;) for the legend. </p>
</td></tr>
<tr><td><code id="plot.SCBand_+3A_horiz">horiz</code></td>
<td>

<p>logical; if TRUE, the legend is displayed horizontally rather than vertically.
</p>
</td></tr>
<tr><td><code id="plot.SCBand_+3A_bty">bty</code></td>
<td>
<p>type of box to be drawn around the legend. The allowed values are <code>"n"</code> (the default) and <code>"o"</code>.</p>
</td></tr>
<tr><td><code id="plot.SCBand_+3A_...">...</code></td>
<td>
<p>additional arguments passed to the function <code><a href="graphics.html#topic+matplot">matplot</a></code> for displaying the y data.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The argument <code>y</code> can be used to plot subsets of the y data. 
If non null, this argument has priority over the component <code>x$y</code> for plotting. 
</p>
<p>The graphical parameters <code>col</code>, <code>cex</code>, <code>pch</code>, <code>lty</code>, and <code>lwd</code> apply to the following components to be plotted: data, parametric estimate, nonparametric estimate(s), normal simultaneous confidence bands (SCB), and bootstrap SCB. More precisely, <code>cex</code> and <code>pch</code> must be specified as vectors of length equal to the number of <code class="reqn">y</code> data sets to be plotted (0, 1, or 2); <code>lty</code> and <code>lwd</code> must specified as numeric vectors of length equal to the total number of estimates and SCB components;  <code>col</code> applies to all components and should be specified accordingly. If necessary, graphical parameters are recycled to match the required length.
</p>
<p>By default a legend is plotted horizontally at the bottom of the graph. 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Plasma citrate data 
time &lt;- 8:21
data(plasma)
h &lt;- cv.select(time, plasma, degree = 1, interval = c(.5, 1))
scbplasma &lt;- scb.mean(time, plasma, bandwidth = h, scbtype = "both",
                      gridsize = 100)
plot(scbplasma, cex = .2, legend.cex = .85, xlab = "Time of day", 
     ylab = "Concentration", main = "Plasma citrate data")

## End(Not run)
</code></pre>

<hr>
<h2 id='plrt.model'>
Pseudo-Likelihood Ratio Test for Models of the Mean Function  
</h2><span id='topic+plrt.model'></span>

<h3>Description</h3>

<p>Implement the Pseudo-Likelihood Ratio Test (PLRT) of Azzalini and Bowman (1993) with functional data. The test is used to assess whether a mean function belongs to a given finite-dimensional function space.</p>


<h3>Usage</h3>

<pre><code class='language-R'> plrt.model(x, y, model, verbose = FALSE) </code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plrt.model_+3A_x">x</code></td>
<td>
<p>a numeric vector of x data. <code>x</code> must be a uniform grid; missing values are not accepted.
</p>
</td></tr>
<tr><td><code id="plrt.model_+3A_y">y</code></td>
<td>

<p>a matrix or data frame with functional observations (= curves) stored in rows. The number of columns of <code>y</code> must match the length of <code>x</code>. Missing values are not accepted.</p>
</td></tr>
<tr><td><code id="plrt.model_+3A_model">model</code></td>
<td>
<p>an integer specifying the degree of a polynomial basis, or a data frame/matrix containing the basis functions stored in columns. In the latter case, the basis functions must be evaluated at <code>x</code>.
</p>
</td></tr>
<tr><td><code id="plrt.model_+3A_verbose">verbose</code></td>
<td>

<p>logical; if <code>TRUE</code>, information on the candidate model, kernel bandwidth, test statistic, and p value is printed; otherwise no print.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the p value of the PLRT.
</p>


<h3>References</h3>

<p>Azzalini, A. and Bowman, A. (1993). On the use of nonparametric regression for checking linear relationships. <em>Journal of the Royal Statistical Society. Series B</em> <b>55</b>, 549-557.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scb.model">scb.model</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example: Gaussian process with mean = linear function + bump 
## and Onstein-Uhlenbeck covariance. The bump is high in the y   
## direction and narrow in the x direction. The SCB and PLRT 
## tests are compared.

# The departure from linearity in the mean function is strong  
# in the supremum norm (SCB test) but mild in the euclidean norm 
# (PLRT). With either n = 20 or n = 100 curves, the SCB test 
# strongly rejects the incorrect linear model for the mean 
# function while the PLRT retains it. 

p    &lt;- 100    # number of observation points
x 	  &lt;- seq(0, 1, len = p)
mu &lt;- -1 + 1.5 * x + 0.2 * dnorm(x, .6, .02) 
plot(x, mu, type = "l")
R 	  &lt;- (.25)^2 * exp(20 * log(.9) * abs(outer(x,x,"-"))) # covariance 
eigR &lt;- eigen(R, symmetric = TRUE)  	
simR &lt;- eigR$vectors %*% diag(sqrt(eigR$values)) 	 

n  &lt;- 20
set.seed(100)
y  &lt;- mu + simR %*% matrix(rnorm(n*p), p, n) 		
y  &lt;- t(y) 	
points(x, colMeans(y))									
h  &lt;- cv.select(x, y, 1)	
scb.model(x, y, 1, bandwidth = h)		 # p value: &lt;1e-16
plrt.model(x, y, 1, verbose = TRUE)	# p value: .442
n  &lt;- 100
y  &lt;- mu + simR %*% matrix(rnorm(n*p), p, n) 		
y  &lt;- t(y) 	
h  &lt;- cv.select(x, y, 1)	
scb.model(x, y, 1, bandwidth = h)		 # p value: &lt;1e-16
plrt.model(x, y, 1, verbose = TRUE)	# p value: .456
</code></pre>

<hr>
<h2 id='plugin.select'>
Plug-in Bandwidth Selection for Local Polynomial Estimation</h2><span id='topic+plugin.select'></span>

<h3>Description</h3>

<p>Select the plug-in bandwidth described in Benhenni and Degras (2011) for the local polynomial estimation of a mean function and its first derivative based on functional data. 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plugin.select(x, y, drv = 0L, degree = drv+1L, gridsize = length(x), ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plugin.select_+3A_x">x</code></td>
<td>

<p>numeric vector of x data. This observation grid must be uniform and missing values are not accepted.</p>
</td></tr>
<tr><td><code id="plugin.select_+3A_y">y</code></td>
<td>

<p>matrix or data frame with functional observations (= curves) stored in rows. The number of columns of <code>y</code> must match the length of <code>x</code>. Missing values are not accepted.</p>
</td></tr>  
<tr><td><code id="plugin.select_+3A_drv">drv</code></td>
<td>
<p>order of the derivative to estimate. Must be 0 or 1. 
</p>
</td></tr>
<tr><td><code id="plugin.select_+3A_degree">degree</code></td>
<td>
<p>degree of local polynomial used. Must equal <code>drv</code> or <code>drv+1</code>.
</p>
</td></tr>
<tr><td><code id="plugin.select_+3A_gridsize">gridsize</code></td>
<td>

<p>the size of the grid over which the mean function is to be estimated.  
Defaults to <code>length(x)</code>.
</p>
</td></tr>
<tr><td><code id="plugin.select_+3A_...">...</code></td>
<td>
<p>additional arguments to pass to the optimizer of the CV score.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The plug-in method should not be used with small data sets, since it is based on asymptotic considerations and requires reasonably accurate estimates of derivatives of the mean and covariance functions. Both the number of observed curves and observation points should be moderate to large. The plug-in bandwidth is designed to minimize the asymptotic mean integrated  squared estimation error </p>
<p style="text-align: center;"><code class="reqn">AMISE(h) = \int (\mu(t) - \hat{\mu}(t; h))^2 dt,</code>
</p>
 
<p>where <code class="reqn">\mu(x)</code> is the mean function and <code class="reqn">\hat{\mu}(t;h)</code> is a local polynomial estimator with kernel bandwidth <code class="reqn">h</code>. The expression of the plug-in bandwidth can be found in Benhenni and Degras (2011).</p>


<h3>Value</h3>

<p>the plug-in bandwidth.</p>


<h3>References</h3>

<p>Benhenni, K. and Degras, D. (2011). Local polynomial estimation of the average growth curve with functional data. <a href="http://arxiv.org/abs/1107.4058">http://arxiv.org/abs/1107.4058</a></p>


<h3>See Also</h3>

<p><code><a href="#topic+cv.select">cv.select</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Phoneme data
data(phoneme)
classes &lt;- phoneme[,151]
phoneme &lt;- phoneme[,-151]
freq    &lt;- 1:150
plugin.bandwidth  &lt;- numeric(5) 
cv.bandwidth  &lt;- numeric(5)  # compare with cross-validation
for (i in 1:5) {
  plugin.bandwidth[i] &lt;- plugin.select(x = freq, y = phoneme[classes == i, ],
                          drv = 0, degree = 1) 
  cv.bandwidth[i]     &lt;- cv.select(x = freq, y = phoneme[classes == i, ], 
                          degree = 1)
}

round(cbind(plugin.bandwidth, cv.bandwidth), 4)


## End(Not run)
</code></pre>

<hr>
<h2 id='print.SCBand'>
Print a SCBand Object</h2><span id='topic+print.SCBand'></span>

<h3>Description</h3>

<p><code>print</code> method for class <code>"SCBand"</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SCBand'
print(x,...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.SCBand_+3A_x">x</code></td>
<td>
<p>an object of class <code>"SCBand"</code>.</p>
</td></tr>
<tr><td><code id="print.SCBand_+3A_...">...</code></td>
<td>
<p>for compatibility with the generic <code>print</code> method; argument not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>print.SCBand</code> concisely displays the information of an object of class <code>"SCBand"</code>. More precisely it shows the  
data range, bandwidth used in local polynomial estimation, and key information on SCB and statistical tests. 
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.SCBand">plot.SCBand</a></code>, <code><a href="#topic+summary.SCBand">summary.SCBand</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Plasma citrate data
data(plasma)
time &lt;- 8:21
h &lt;- cv.select(time, plasma, 1)
scbplasma &lt;- scb.mean(time, plasma, bandwidth = h, scbtype = "both", gridsize = 100)
scbplasma

## End(Not run)
</code></pre>

<hr>
<h2 id='scb.equal'>
Compare Two Mean Functions</h2><span id='topic+scb.equal'></span>

<h3>Description</h3>

<p>This two-sample test builds simultaneous confidence bands (SCB) for the difference between two population mean functions and retains the equality assumption if the null function is contained in the bands. Equivalently, SCB are built around one of the local linear estimates (the one for say, population 1), and the equality hypothesis is  accepted if the other estimate (the one for  population 2) lies within the bands.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scb.equal(x, y, bandwidth, level = .05, degree = 1, 
	scbtype = c("normal","bootstrap","both","no"), gridsize = NULL, 
	keep.y = TRUE, nrep = 2e4, nboot = 1e4, parallel = c("no","multicore","snow"), 
	ncpus = getOption("boot.ncpus",1L), cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scb.equal_+3A_x">x</code></td>
<td>
<p>a list of length 2 or matrix with 2 columns containing the x values of each sample. If the two samples are observed on the same grid, <code>x</code> can be specified as a single vector. The range of <code>x</code> must be the same for each sample; missing values are not accepted.</p>
</td></tr>
<tr><td><code id="scb.equal_+3A_y">y</code></td>
<td>
<p>a list of length 2 containing matrices or data frames with functional observations (= curves) stored in rows. The number of columns of each component of <code>y</code> must match the length of the corresponding <code>x</code>. Missing values are not accepted.</p>
</td></tr>
<tr><td><code id="scb.equal_+3A_bandwidth">bandwidth</code></td>
<td>
<p>the kernel bandwidths (numeric vector of length 1 or 2).</p>
</td></tr>
<tr><td><code id="scb.equal_+3A_level">level</code></td>
<td>
<p>the significance level of the test (default = .05).</p>
</td></tr>
<tr><td><code id="scb.equal_+3A_degree">degree</code></td>
<td>
<p>the degree of the local polynomial fit.</p>
</td></tr>
<tr><td><code id="scb.equal_+3A_scbtype">scbtype</code></td>
<td>
<p>the type of simultaneous confidence bands to build: &quot;normal&quot;, &quot;bootstrap&quot;, &quot;both&quot;, or &quot;no&quot;. </p>
</td></tr>
<tr><td><code id="scb.equal_+3A_gridsize">gridsize</code></td>
<td>
<p>the size of the grid over which the mean function is to be estimated. Defaults to the length of the smallest <code>x</code> grid.</p>
</td></tr>
<tr><td><code id="scb.equal_+3A_keep.y">keep.y</code></td>
<td>
<p>logical; if <code>TRUE</code>, keep <code>y</code> in the result.</p>
</td></tr>
<tr><td><code id="scb.equal_+3A_nrep">nrep</code></td>
<td>
<p>the number of replicates for the normal SCB method (default = 20,000).</p>
</td></tr>
<tr><td><code id="scb.equal_+3A_nboot">nboot</code></td>
<td>
<p>the number of replicates for the bootstrap SCB method (default = 5,000).</p>
</td></tr>
<tr><td><code id="scb.equal_+3A_parallel">parallel</code></td>
<td>
<p>the computation method for the bootstrap SCB. By default, computations are sequential (<code>"no"</code>).<br /> The function <code><a href="boot.html#topic+boot">boot</a></code> is used and can be run in parallel using the package <code><a href="parallel.html#topic+parallel">parallel</a></code>.<br /> Both options <code>"multicore"</code> and <code>"snow"</code> are available for parallel computing.</p>
</td></tr> 
<tr><td><code id="scb.equal_+3A_ncpus">ncpus</code></td>
<td>
<p>the number of cores to use for parallel computing if <code>parallel = "multicore"</code>.</p>
</td></tr>
<tr><td><code id="scb.equal_+3A_cl">cl</code></td>
<td>
<p>the name of the cluster to use for parallel computing if <code>parallel = "snow"</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list object of <a href="base.html#topic+class">class</a> <code>"SCBand"</code>. Depending on the  function used to create the object (<code><a href="#topic+scb.mean">scb.mean</a></code>, <code><a href="#topic+scb.model">scb.model</a></code>, or <code><a href="#topic+scb.equal">scb.equal</a></code>), some of its components are set to <code>NULL</code>. For <code><a href="#topic+scb.mean">scb.mean</a></code>, the object has components: 
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>the argument <code>x</code>.
</p>
</td></tr>
<tr><td><code>y</code></td>
<td>

<p>if <code>keep.y</code> is <code>TRUE</code>, the argument <code>y</code>, else <code>NULL</code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p><code>NULL</code>.</p>
</td></tr>  
<tr><td><code>par</code></td>
<td>
<p><code>NULL</code>.</p>
</td></tr>
<tr><td><code>nonpar</code></td>
<td>
<p>a list of two local linear estimates, one for each population.</p>
</td></tr>
<tr><td><code>bandwidth</code></td>
<td>
<p>the argument <code>bandwidth</code>.</p>
</td></tr>
<tr><td><code>degree</code></td>
<td>
<p>the degree of local polynomial used. 
Currently, only local linear estimation is supported.</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>the argument <code>level</code>.</p>
</td></tr>
<tr><td><code>scbtype</code></td>
<td>
<p>the argument <code>scbtype</code>.</p>
</td></tr>
<tr><td><code>teststat</code></td>
<td>
<p>the test statistic.</p>
</td></tr>
<tr><td><code>pnorm</code></td>
<td>
<p>the <em>p</em> value for the normal-based statistical test.</p>
</td></tr> 
<tr><td><code>pboot</code></td>
<td>
<p>the <em>p</em> value for the boostrap-based statistical test.</p>
</td></tr>  
<tr><td><code>qnorm</code></td>
<td>
<p>the quantile used to build the normal SCB.</p>
</td></tr>
<tr><td><code>qboot</code></td>
<td>
<p>the quantile used to build the bootstrap SCB.</p>
</td></tr>
<tr><td><code>normscb</code></td>
<td>
<p>a matrix containing the normal SCB stored in columns.</p>
</td></tr>
<tr><td><code>bootscb</code></td>
<td>
<p>a matrix containing the bootstrap SCB stored in columns.</p>
</td></tr>
<tr><td><code>gridsize</code></td>
<td>
<p>the argument <code>gridsize</code>, or <em>length(x)</em> if no argument was specified.</p>
</td></tr>
<tr><td><code>nrep</code></td>
<td>
<p>the argument <code>nrep</code>.</p>
</td></tr>
<tr><td><code>nboot</code></td>
<td>
<p>the argument <code>nboot</code>.</p>
</td></tr>
</table>
<p>Depending on the value of <code>scbtype</code>, some or all of  
the fields <code>pnorm</code>, <code>qnorm</code>, <code>normscb</code>, <code>nrep</code>,  <code>pboot</code>, <code>qboot</code>, <code>normboot</code> and <code>nboot</code> may be   <code>NULL</code>.
</p>


<h3>References</h3>

<p>Degras, D. (2011). Simultaneous confidence bands for nonparametric regression with functional data. <em>Statistica Sinica</em>, <b>21</b>, 1735&ndash;1765.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scb.mean">scb.mean</a></code>, <code><a href="#topic+scb.model">scb.model</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# Phoneme data: compare the mean log-periodograms 
# for phonemes "aa" as the vowel in "dark" and "ao" 
# as the first vowel in "water"
data(phoneme)
n &lt;- nrow(phoneme)
N &lt;- ncol(phoneme) 
classes &lt;- split(1:n,phoneme[,N])
names(classes) &lt;- c("sh", "iy", "dcl", "aa", "ao")
freq    &lt;- 1:150
compare.aa.ao &lt;- scb.equal(freq, list(phoneme[classes$aa,-N], 
  phoneme[classes$ao,-N]), bandwidth = c(.75, .75), scbtype = "both", nboot = 2e3)
summary(compare.aa.ao)

## End(Not run)
</code></pre>

<hr>
<h2 id='scb.mean'>
Build Simultaneous Confidence Bands for Mean Functions
</h2><span id='topic+scb.mean'></span>

<h3>Description</h3>

<p>Fit a local linear estimator and build simultaneous confidence bands (SCB) for the mean of functional data.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scb.mean(x, y, bandwidth, level = .95, degree = 1, 
	scbtype = c("normal","bootstrap","both","no"), gridsize = length(x), 
	keep.y = TRUE, nrep = 2e4, nboot = 5e3, parallel = c("no", "multicore", "snow"), 
	ncpus = getOption("boot.ncpus",1L), cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scb.mean_+3A_x">x</code></td>
<td>
<p>a numeric vector of x data. Missing values are not accepted.</p>
</td></tr>
<tr><td><code id="scb.mean_+3A_y">y</code></td>
<td>
<p>a matrix or data frame with functional observations (= curves) stored in rows. The number of columns of <code>y</code> must match the length of <code>x</code>. Missing values are not accepted.</p>
</td></tr>
<tr><td><code id="scb.mean_+3A_bandwidth">bandwidth</code></td>
<td>
<p>the kernel bandwidth smoothing parameter.</p>
</td></tr>
<tr><td><code id="scb.mean_+3A_level">level</code></td>
<td>
<p>the level of the simultaneous confidence bands.</p>
</td></tr>
<tr><td><code id="scb.mean_+3A_degree">degree</code></td>
<td>
<p>the degree of the local polynomial fit.</p>
</td></tr>
<tr><td><code id="scb.mean_+3A_scbtype">scbtype</code></td>
<td>
<p>the type of simultaneous confidence bands to build: &quot;normal&quot;, &quot;bootstrap&quot;, &quot;both&quot;, or &quot;no&quot;.</p>
</td></tr>
<tr><td><code id="scb.mean_+3A_gridsize">gridsize</code></td>
<td>
<p>the size of the grid used to evaluate the mean function estimates and SCB. Defaults to <em>length(x)</em>.</p>
</td></tr>
<tr><td><code id="scb.mean_+3A_keep.y">keep.y</code></td>
<td>
<p>logical; if <code>TRUE</code>, keep <code>y</code> in the result.</p>
</td></tr>
<tr><td><code id="scb.mean_+3A_nrep">nrep</code></td>
<td>
<p>number of replicates for the Gaussian SCB method (20,000 by default).</p>
</td></tr>
<tr><td><code id="scb.mean_+3A_nboot">nboot</code></td>
<td>
<p>number of replicates for the bootstrap SCB method (5,000 by default).</p>
</td></tr>
<tr><td><code id="scb.mean_+3A_parallel">parallel</code></td>
<td>
<p>the computation method for the SCB. By default, computations are sequential (<code>"no"</code>). The bootstrap method uses function <code><a href="boot.html#topic+boot">boot</a></code> and can be run in parallel using the package <code><a href="parallel.html#topic+parallel">parallel</a></code>. In this case both options <code>"multicore"</code> and <code>"snow"</code> are available.</p>
</td></tr>
<tr><td><code id="scb.mean_+3A_ncpus">ncpus</code></td>
<td>
<p>number of cores to use for parallel computing when <code>parallel = "multicore"</code>.</p>
</td></tr>
<tr><td><code id="scb.mean_+3A_cl">cl</code></td>
<td>
<p>name of the cluster to use for parallel computing when <code>parallel = "snow"</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The local polynomial fitting uses a standard normal kernel and is implemented via the <code><a href="KernSmooth.html#topic+locpoly">locpoly</a></code> function.
Bootstrap SCB are implemented with the <code><a href="boot.html#topic+boot">boot</a></code> function and typically require more computation time than normal SCB.
</p>


<h3>Value</h3>

<p>An object of <a href="base.html#topic+class">class</a> <code>"SCBand"</code>. To accommodate the different functions creating objects of this class (<code><a href="#topic+scb.mean">scb.mean</a></code>, <code><a href="#topic+scb.model">scb.model</a></code>, and <code><a href="#topic+scb.equal">scb.equal</a></code>), some components of the object are set to <code>NULL</code>. The component list is:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>the x data.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the y data if <code>keep.y</code> is <code>TRUE</code>, else <code>NULL</code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p><code>NULL</code>.</p>
</td></tr>  
<tr><td><code>par</code></td>
<td>
<p><code>NULL</code>.</p>
</td></tr>
<tr><td><code>nonpar</code></td>
<td>
<p>a nonparametric estimate.</p>
</td></tr>
<tr><td><code>bandwidth</code></td>
<td>
<p>the argument <code>bandwidth</code>.</p>
</td></tr>
<tr><td><code>degree</code></td>
<td>
<p>the degree of local polynomial used. 
Currently, only local linear estimation is supported.</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>the argument <code>level</code>.</p>
</td></tr>
<tr><td><code>scbtype</code></td>
<td>
<p>the argument <code>type</code>.</p>
</td></tr>
<tr><td><code>teststat</code></td>
<td>
<p><code>NULL</code>.</p>
</td></tr>
<tr><td><code>pnorm</code></td>
<td>
<p><code>NULL</code>.</p>
</td></tr> 
<tr><td><code>pboot</code></td>
<td>
<p><code>NULL</code>.</p>
</td></tr>  
<tr><td><code>qnorm</code></td>
<td>
<p>the quantile used to build the normal SCB.</p>
</td></tr>
<tr><td><code>qboot</code></td>
<td>
<p>the quantile used to build the bootstrap SCB.</p>
</td></tr>
<tr><td><code>normscb</code></td>
<td>
<p>a matrix containing the normal SCB stored in columns.</p>
</td></tr>
<tr><td><code>bootscb</code></td>
<td>
<p>a matrix containing the bootstrap SCB stored in columns.</p>
</td></tr>
<tr><td><code>gridsize</code></td>
<td>
<p>the argument <code>gridsize</code> if nonnull, else  <em>length(x)</em>.</p>
</td></tr>
<tr><td><code>nrep</code></td>
<td>
<p>the argument <code>nrep</code>.</p>
</td></tr>
<tr><td><code>nboot</code></td>
<td>
<p>the argument <code>nboot</code>.</p>
</td></tr>
</table>
<p>Depending on the value of <code>scbtype</code>, some of  
the fields <code>qnorm</code>, <code>normscb</code>, <code>nrep</code>, <code>qboot</code>, <code>normboot</code> and <code>nboot</code> may be <code>NULL</code>.
</p>


<h3>References</h3>

<p>Degras, D. (2011). Simultaneous confidence bands for nonparametric regression with functional data. <em>Statistica Sinica</em>, <b>21</b>, 1735&ndash;1765.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scb.equal">scb.equal</a></code>, <code><a href="#topic+scb.model">scb.model</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Plasma citrate data
data(plasma)
time &lt;- 8:21
h &lt;- cv.select(time, plasma, 1, c(.5, 1))
scbplasma &lt;- scb.mean(time, plasma, bandwidth = h, scbtype = "both", gridsize = 100)
scbplasma
plot(scbplasma, cex = .2, legend.cex = .85, xlab = "Time", ylab = "Concentration", 
  main = "Plasma citrate data")

## End(Not run)
</code></pre>

<hr>
<h2 id='scb.model'>Goodness-Of-Fit of a Model for the Mean Function</h2><span id='topic+scb.model'></span>

<h3>Description</h3>

<p>This is the goodness-of-fit test for parametric models of the mean function described in Degras (2011). The candidate model must be a finite-dimensional function space (curvilinear regression). The test is based on the sup-norm distance between a smoothed parametric estimate and a local linear estimate. Graphically, the candidate model is retained whenever one of the estimates lies within the SCB built around the other.  
</p>


<h3>Usage</h3>

<pre><code class='language-R'>scb.model(x, y, model, bandwidth, level = .05, degree = 1, 
	scbtype = c("normal","bootstrap","both","no"), gridsize = length(x), 
	keep.y = TRUE, nrep = 2e4, nboot = 5e3, parallel = c("no", "multicore", "snow"), 
	ncpus = getOption("boot.ncpus",1L), cl = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="scb.model_+3A_x">x</code></td>
<td>
<p>a numeric vector of x data. <code>x</code> must be a uniform grid; missing values are not accepted.</p>
</td></tr>
<tr><td><code id="scb.model_+3A_y">y</code></td>
<td>
<p>a matrix or data frame with functional observations (= curves) stored in rows. The number of columns of <code>y</code> must match the length of <code>x</code>. Missing values are not accepted.</p>
</td></tr>
<tr><td><code id="scb.model_+3A_model">model</code></td>
<td>
<p>an integer specifying the degree of a polynomial basis, or a data frame/matrix containing the basis functions stored in columns. In the latter case, the basis functions must be evaluated on a uniform grid of size <code>gridsize</code> spanning the range of <code>x</code>.</p>
</td></tr>
<tr><td><code id="scb.model_+3A_bandwidth">bandwidth</code></td>
<td>
<p>the kernel bandwidth smoothing parameter.</p>
</td></tr>
<tr><td><code id="scb.model_+3A_level">level</code></td>
<td>
<p>the significance level of the test (default = .05).</p>
</td></tr>
<tr><td><code id="scb.model_+3A_degree">degree</code></td>
<td>
<p>the degree of the local polynomial fit.</p>
</td></tr>
<tr><td><code id="scb.model_+3A_scbtype">scbtype</code></td>
<td>
<p>the type of simultaneous confidence bands to build: &quot;normal&quot;, &quot;bootstrap&quot;, &quot;both&quot;, or &quot;no&quot;.</p>
</td></tr>
<tr><td><code id="scb.model_+3A_gridsize">gridsize</code></td>
<td>
<p>the size of the grid over which the mean function is to be estimated. Defaults to <code>length(x)</code>.</p>
</td></tr>
<tr><td><code id="scb.model_+3A_keep.y">keep.y</code></td>
<td>
<p>logical; if <code>TRUE</code>, keep <code>y</code> in the result.</p>
</td></tr>
<tr><td><code id="scb.model_+3A_nrep">nrep</code></td>
<td>
<p>the number of replicates for the normal SCB method (default = 20,000).</p>
</td></tr>
<tr><td><code id="scb.model_+3A_nboot">nboot</code></td>
<td>
<p>the number of replicates for the bootstrap SCB method (default = 5,000).</p>
</td></tr>
<tr><td><code id="scb.model_+3A_parallel">parallel</code></td>
<td>
<p>the computation method for the bootstrap SCB. By default, computations are sequential (<code>"no"</code>).<br /> The function <code><a href="boot.html#topic+boot">boot</a></code> is used and can be run in parallel using the package <code><a href="parallel.html#topic+parallel">parallel</a></code>.<br /> Both options <code>"multicore"</code> and <code>"snow"</code> are available for parallel computing.</p>
</td></tr> 
<tr><td><code id="scb.model_+3A_ncpus">ncpus</code></td>
<td>
<p>the number of cores to use for parallel computing when <code>parallel = "multicore"</code>.</p>
</td></tr>
<tr><td><code id="scb.model_+3A_cl">cl</code></td>
<td>
<p>the name of the cluster to use for parallel computing when <code>parallel = "snow"</code>.</p>
</td></tr></table>


<h3>Value</h3>

<p>An object of <a href="base.html#topic+class">class</a> <code>"SCBand"</code>. To accommodate the different functions creating objects of this class (<code><a href="#topic+scb.mean">scb.mean</a></code>, <code><a href="#topic+scb.model">scb.model</a></code>, and <code><a href="#topic+scb.equal">scb.equal</a></code>), some components of the object are set to <code>NULL</code>. The component list is:
</p>
<table>
<tr><td><code>x</code></td>
<td>
<p>the argument <code>x</code>.</p>
</td></tr>
<tr><td><code>y</code></td>
<td>
<p>the argument <code>y</code> if <code>keep.y</code> is <code>TRUE</code>, else <code>NULL</code>.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>the function call.</p>
</td></tr>
<tr><td><code>model</code></td>
<td>
<p>the argument <code>model</code>.</p>
</td></tr>  
<tr><td><code>par</code></td>
<td>
<p>a smoothed parametric estimate.</p>
</td></tr>
<tr><td><code>nonpar</code></td>
<td>
<p>a local linear estimate.</p>
</td></tr>
<tr><td><code>bandwidth</code></td>
<td>
<p>the argument <code>bandwidth</code>.</p>
</td></tr>
<tr><td><code>degree</code></td>
<td>
<p>the degree of the local polynomial. 
Currently, only local linear estimation is supported.</p>
</td></tr>
<tr><td><code>level</code></td>
<td>
<p>the argument <code>level</code>.</p>
</td></tr>
<tr><td><code>scbtype</code></td>
<td>
<p>the argument <code>type</code>.</p>
</td></tr>
<tr><td><code>teststat</code></td>
<td>
<p>the test statistic.</p>
</td></tr>
<tr><td><code>pnorm</code></td>
<td>
<p>the <em>p</em> value for the normal-based statistical test.</p>
</td></tr> 
<tr><td><code>pboot</code></td>
<td>
<p>the <em>p</em> value for the boostrap-based statistical test.</p>
</td></tr>  
<tr><td><code>qnorm</code></td>
<td>
<p>the quantile used to build the normal SCB.</p>
</td></tr>
<tr><td><code>qboot</code></td>
<td>
<p>the quantile used to build the bootstrap SCB.</p>
</td></tr>
<tr><td><code>normscb</code></td>
<td>
<p>a matrix containing the normal SCB stored in columns.</p>
</td></tr>
<tr><td><code>bootscb</code></td>
<td>
<p>a matrix containing the bootstrap SCB stored in columns.</p>
</td></tr>
<tr><td><code>gridsize</code></td>
<td>
<p>the argument <code>gridsize</code>, or <em>length(x)</em> if no argument was specified.</p>
</td></tr>
<tr><td><code>nrep</code></td>
<td>
<p>the argument <code>nrep</code>.</p>
</td></tr>
<tr><td><code>nboot</code></td>
<td>
<p>the argument <code>nboot</code>.</p>
</td></tr>
</table>
<p>Depending on the value of <code>scbtype</code>, some or all of  
the fields <code>pnorm</code>, <code>qnorm</code>, <code>normscb</code>, <code>nrep</code>,  <code>pboot</code>, <code>qboot</code>, <code>normboot</code> and <code>nboot</code> may be   <code>NULL</code>.
</p>


<h3>References</h3>

<p>Degras, D. (2011). Simultaneous confidence bands for nonparametric regression with functional data.<br /> <em>Statistica Sinica</em>, <b>21</b>, 1735&ndash;1765.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+scb.equal">scb.equal</a></code>, <code><a href="#topic+scb.mean">scb.mean</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Example from Degras (2011)
## Gaussian process with polynomial mean function 
## and Ornstein-Uhlenbeck covariance function
## The SCB and PLRT tests are compared

set.seed(100)
p    &lt;- 100  	# number of observation points
x 	  &lt;- seq(0, 1, len = p)
mu	  &lt;- 10 * x^3 - 15 * x^4 + 6 * x^5	# mean 
R 	  &lt;- (.25)^2 * exp(20 * log(.9) * abs(outer(x,x,"-"))) # covariance 
eigR &lt;- eigen(R, symmetric = TRUE)  	
simR &lt;- eigR$vectors %*% diag(sqrt(eigR$values)) 	 

# Candidate model for mu: polynomial of degree &lt;= 3
# This model, although incorrect, closely approximates mu.
# With n = 50 curves, the SCB and PLRT incorrectly retain the model.
# With n = 70 curves, both tests reject it. 
n &lt;- 50  
y &lt;- mu + simR %*% matrix(rnorm(n*p), p, n) 	# simulate data  
y &lt;- t(y) 	# arrange the trajectories in rows
h &lt;- cv.select(x, y, 1)	
scb.model(x, y, 3, bandwidth = h)		  # p value: .652
plrt.model(x, y, 3, verbose = TRUE)	# p value: .450 
n &lt;- 70  	
y &lt;- mu + simR %*% matrix(rnorm(n*p), p, n) 		
y &lt;- t(y) 										
h &lt;- cv.select(x, y, 1)	
scb.model(x, y, 3, bandwidth = h)		  # p value: .004
plrt.model(x, y, 3, verbose = TRUE)	# p value: .001

# Correct model: polynomials of degree &lt;= 5
scb.model(x, y, 5, bandwidth = h)  	# p value: .696
plrt.model(x, y, 5, verbose = TRUE)	# p value: .628

</code></pre>

<hr>
<h2 id='summary.SCBand'>Summarize a SCBand Object</h2><span id='topic+summary.SCBand'></span>

<h3>Description</h3>

<p><code>summary</code> method for class <code>"SCBand"</code> </p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SCBand'
summary(object, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.SCBand_+3A_object">object</code></td>
<td>
<p>an object of class <code>"SCBand"</code></p>
</td></tr>
<tr><td><code id="summary.SCBand_+3A_...">...</code></td>
<td>
<p>additional arguments; not currently used.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function <code>summary.SCBand</code> displays all fields of a <code>SCBand</code> object at the exception of <code>x</code>, <code>y</code>, <code>par</code>, <code>nonpar</code>, <code>normscb</code>, and <code>bootscb</code> which are potentially big. It provides information on the function call, data, local polynomial fit, SCB, and statistical tests.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.SCBand">plot.SCBand</a></code>,
<code><a href="#topic+print.SCBand">print.SCBand</a></code> 
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## Plasma citrate data 
data(plasma)
time &lt;- 8:21
h &lt;- cv.select(time, plasma, 1)
scbplasma &lt;- scb.mean(time, plasma, bandwidth = h, scbtype = "both", gridsize = 100)
summary(scbplasma)

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
