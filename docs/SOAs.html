<!DOCTYPE html><html><head><title>Help for package SOAs</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {SOAs}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#contr.FFbHelmert'><p>Full-factorial-based real-valued contrasts for s^el levels</p></a></li>
<li><a href='#contr.Power'><p>A contrast function based on regular factorials</p>
for number of levels a prime or prime power</a></li>
<li><a href='#contr.TianXu'><p>A complex-valued contrast function for s^el levels based on powers of the s-th</p>
root of the unity</a></li>
<li><a href='#create_ABC'><p>Create ABC object</p></a></li>
<li><a href='#create_DfromABC'><p>Create object D from an ABC object</p></a></li>
<li><a href='#createAB'><p>Utilities for array creation</p></a></li>
<li><a href='#createABcols'><p>initialize recursive construction of A,B,C</p></a></li>
<li><a href='#createSaturated'><p>Function to create a regular saturated strength 2 array</p></a></li>
<li><a href='#createYcols'><p>Initial recursive construction of X, Y, and Z</p></a></li>
<li><a href='#DcFromDp'><p>Create the expansions</p></a></li>
<li><a href='#ff'><p>Utility functions for SOAs</p></a></li>
<li><a href='#guide_SOAs'><p>Utility function for inspecting available SOAs for which the user need not provide an OA</p></a></li>
<li><a href='#guide_SOAs_from_OA'><p>Utility function for inspecting SOAs obtainable from an OA</p></a></li>
<li><a href='#int2poly'><p>Functions for Galois field calculations</p></a></li>
<li><a href='#mbound_LiuLiu'><p>bound for number of columns for LiuLiu OSOAs</p></a></li>
<li><a href='#MDLEs'><p>Function to create maximin distance level expanded arrays</p></a></li>
<li><a href='#nchoosek'><p>Utility functions from DoE.base</p></a></li>
<li><a href='#NeighbourcalcUniversal'><p>Function to do level permutations according to Weng's algorithm</p></a></li>
<li><a href='#NeighbourcalcUniversal_random'><p>Function to do level permutations according to Weng's algorithm</p>
without using a stored list of all permutations</a></li>
<li><a href='#ocheck'><p>functions to evaluate low order projection properties of (O)SOAs</p></a></li>
<li><a href='#OSOA_LiuLiut'><p>Strong Orthogonal Arrays of Strength t using the method of Liu and Liu</p></a></li>
<li><a href='#OSOAarbitrary'><p>Auxiliary function for optimized creation of OSOAs (function OSOAs)</p>
using the Li et al. algorithm for arbitrary initial OA</a></li>
<li><a href='#OSOApb'><p>function to create a strength 3 OSOA with 8-level columns from a Hadamard matrix</p></a></li>
<li><a href='#OSOAregulart'><p>TODO</p></a></li>
<li><a href='#OSOAs'><p>Function to create an OSOA from an OA</p></a></li>
<li><a href='#OSOAs_hadamard'><p>function to create a strength 3 OSOA with 8-level columns or a strength 3- OSOA with 4-level columns from a Hadamard matrix</p></a></li>
<li><a href='#OSOAs_LiuLiu'><p>Function to create OSOAs of strengths 2, 3, or 4 from an OA</p></a></li>
<li><a href='#OSOAs_regular'><p>Function to create an OSOA in s^2 or s^3 levels and s^k runs</p>
from a basic number of levels s and a power k</a></li>
<li><a href='#permopt'><p>optimize GWLP optimal oa for maximin criterion phi_p</p></a></li>
<li><a href='#phi_optimize'><p>function to optimize the phi_p value of an array by level permutation</p></a></li>
<li><a href='#phi_p'><p>Functions to evaluate space filling of an array</p></a></li>
<li><a href='#print.SOA'><p>Print Methods</p></a></li>
<li><a href='#soa'><p>work horse function for SOAs</p></a></li>
<li><a href='#SOAs'><p>function to create SOAs of strength t with the GOA construction by He and Tang.</p></a></li>
<li><a href='#SOAs_8level'><p>Function to create 8-level SOAs according to Shi and Tang 2020</p></a></li>
<li><a href='#SOAs-package'><p>Creation of Stratum (aka Strong) Orthogonal Arrays</p></a></li>
<li><a href='#SOAs2plus_regular'><p>function to create SOAs of strength 2+ from regular s-level designs</p></a></li>
<li><a href='#Spattern'><p>functions to evaluate stratification properties of (O)SOAs and GSOAs</p></a></li>
<li><a href='#XiaoXuMDLE'><p>Implementation of the Xiao Xu TA algorithm</p>
(experimental, for comparison with MDLEs only)</a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Creation of Stratum Orthogonal Arrays</td>
</tr>
<tr>
<td>Version:</td>
<td>1.4</td>
</tr>
<tr>
<td>Description:</td>
<td>Creates stratum orthogonal arrays (also known as strong orthogonal arrays). These are arrays with more levels per column than the typical orthogonal array, and whose low order projections behave like orthogonal arrays, when collapsing levels to coarser strata. Details are described in Groemping (2022) "A unifying implementation of stratum (aka strong) orthogonal arrays" <a href="http://www1.bht-berlin.de/FB_II/reports/Report-2022-002.pdf">http://www1.bht-berlin.de/FB_II/reports/Report-2022-002.pdf</a>.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0), DoE.base (&ge; 1.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, combinat, FrF2, igraph, lhs (&ge; 1.1.3), conf.design,
sfsmisc, partitions</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/bertcarnell/SOAs">https://github.com/bertcarnell/SOAs</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/bertcarnell/SOAs/issues">https://github.com/bertcarnell/SOAs/issues</a></td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-08-10 17:30:45 UTC; Gr√∂mping</td>
</tr>
<tr>
<td>Author:</td>
<td>Ulrike Groemping [aut, cre],
  Rob Carnell [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Ulrike Groemping &lt;ulrike.groemping@bht-berlin.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-08-10 17:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='contr.FFbHelmert'>Full-factorial-based real-valued contrasts for s^el levels</h2><span id='topic+contr.FFbHelmert'></span><span id='topic+contr.FFbPoly'></span>

<h3>Description</h3>

<p>Full-factorial-based real-valued contrasts for s^el levels
</p>
<p>Full-factorial-based polynomial contrasts for s^el levels
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contr.FFbHelmert(n, s, contrasts = TRUE, slowfirst = TRUE)

contr.FFbPoly(n, s, contrasts = TRUE, slowfirst = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contr.FFbHelmert_+3A_n">n</code></td>
<td>
<p>integer or vector; either an integer number of levels of the factor for
which contrasts are created, which must be a a power of <code>s</code>; or a factor
whose number of levels is a power of <code>s</code>; or a vector of levels whose
number of elements is a power of <code>s</code>.</p>
</td></tr>
<tr><td><code id="contr.FFbHelmert_+3A_s">s</code></td>
<td>
<p>positive integer, at least 2</p>
</td></tr>
<tr><td><code id="contr.FFbHelmert_+3A_contrasts">contrasts</code></td>
<td>
<p>logical; must be TRUE</p>
</td></tr>
<tr><td><code id="contr.FFbHelmert_+3A_slowfirst">slowfirst</code></td>
<td>
<p>logical; default TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The functions implement real-valued full-factorial-based contrasts
in the sense of Groemping (2023b) that can be used
instead of the complex-valued contrasts from
Tian and Xu (2022), as implemented in function
<code><a href="#topic+contr.TianXu">contr.TianXu</a></code>. Their main use is the calculation of the
stratification pattern (also called space-filling pattern).
Function <code><a href="#topic+Spattern">Spattern</a></code> uses function <code>contr.FFbHelmert</code>
for this purpose, the internal function <code>Spattern_Poly</code> uses
<code>contr.FFbPoly</code>.
</p>


<h3>Value</h3>

<p><code>contr.FFbHelmert</code> and <code>contr.FFbPoly</code> yield a matrix
of real-valued contrasts.
That matrix can be used in function <code>model.matrix</code>
or in any statistical modeling functions.
</p>


<h3>References</h3>

<p>Groemping (2023b)
Tian and Xu (2022)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## the same n can yield different contrasts for different s
## Helmert variant
contr.FFbHelmert(16, 2)
round(contr.FFbHelmert(16, 4), 4)
round(contr.FFbHelmert(16, 16), 4)
## Poly variant
contr.FFbHelmert(16, 2)
round(contr.FFbHelmert(16, 4), 4)
round(contr.FFbHelmert(16, 16), 4)

</code></pre>

<hr>
<h2 id='contr.Power'>A contrast function based on regular factorials
for number of levels a prime or prime power</h2><span id='topic+contr.Power'></span>

<h3>Description</h3>

<p>A contrast function based on regular factorials
for number of levels a prime or prime power
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contr.Power(n, s = 2, contrasts = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contr.Power_+3A_n">n</code></td>
<td>
<p>integer or vector; either an integer number of levels of the factor for
which contrasts are created, which must be a a power of <code>s</code>; or a factor
whose number of levels is a power of <code>s</code>; or a vector of levels whose
number of elements is a power of <code>s</code>.</p>
</td></tr>
<tr><td><code id="contr.Power_+3A_s">s</code></td>
<td>
<p>integer; prime or prime power</p>
</td></tr>
<tr><td><code id="contr.Power_+3A_contrasts">contrasts</code></td>
<td>
<p>logical; must be TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is a generalization (with slowest first instead of fastest first)
of function <code>contr.FrF2</code> from package <span class="pkg">DoE.base</span>. It is in this
package because it needs Galois field functionality from package <span class="pkg">lhs</span>
for non-prime <code>s</code>. Its purpose is (was) the calculation of the
stratification (or space-filling) pattern by Tian and Xu (2022), see also
Groemping (2022). The package now calculates the pattern with function
<code><a href="#topic+contr.TianXu">contr.TianXu</a></code>.
</p>


<h3>Value</h3>

<p><code>contr.Power</code> yields a matrix of contrasts. It can be used in
function <code>model.matrix</code> or anywhere where factors with the number of
levels a power of $s$ are used with contrasts. The exponent for <code>s</code>
is determined from the number of levels.
</p>


<h3>References</h3>

<p>Groemping (2022)
Tian and Xu (2022)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## the same n can yield different contrasts for different s
contr.Power(16, 2)
contr.Power(16, 4)

</code></pre>

<hr>
<h2 id='contr.TianXu'>A complex-valued contrast function for s^el levels based on powers of the s-th
root of the unity</h2><span id='topic+contr.TianXu'></span>

<h3>Description</h3>

<p>A complex-valued contrast function for s^el levels based on powers of the s-th
root of the unity
</p>


<h3>Usage</h3>

<pre><code class='language-R'>contr.TianXu(n, s = 2, contrasts = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="contr.TianXu_+3A_n">n</code></td>
<td>
<p>integer or vector; either an integer number of levels of the factor for
which contrasts are created, which must be a a power of <code>s</code>; or a factor
whose number of levels is a power of <code>s</code>; or a vector of levels whose
number of elements is a power of <code>s</code>.</p>
</td></tr>
<tr><td><code id="contr.TianXu_+3A_s">s</code></td>
<td>
<p>positive integer, at least 2</p>
</td></tr>
<tr><td><code id="contr.TianXu_+3A_contrasts">contrasts</code></td>
<td>
<p>logical; must be TRUE</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements the complex-valued contrasts from
Tian and Xu (2022). Its sole use is the calculation of the
stratification pattern (also called space-filling pattern).
However, note that it is not used in function <code><a href="#topic+Spattern">Spattern</a></code>,
but only in the internal function <code>Spattern_TianXu</code>,
which yields exactly the same results as function <code>Spattern</code>.<br />
The <code>contrasts</code> argument has been kept in order to be
prepared in case the <code>model.matrix</code> function gains the
ability to handle complex-valued contrasts.
</p>
<p>The Tian and Xu contrasts are full-factorial-based contrasts
in the sense of Groemping (2023b). Function <code><a href="#topic+Spattern">Spattern</a></code>
uses a different type of full-factorial-based contrasts,
the full-factorial-based Helmert contrasts provided in function
<code><a href="#topic+contr.FFbHelmert">contr.FFbHelmert</a></code>.
</p>


<h3>Value</h3>

<p><code>contr.TianXu</code> yields a matrix of complex-valued contrasts.
It can therefore NOT be used in function <code>model.matrix</code>
or in statistical modeling functions.
</p>


<h3>References</h3>

<p>Groemping (2023b)
Tian and Xu (2022)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## the same n can yield different contrasts for different s
contr.TianXu(16, 2)
contr.TianXu(16, 4)
round(contr.TianXu(16, 16), 4)

</code></pre>

<hr>
<h2 id='create_ABC'>Create ABC object</h2><span id='topic+create_ABC'></span>

<h3>Description</h3>

<p>Create ABC object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_ABC(k, m = NULL, constr = "ShiTang_alphabeta")
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_ABC_+3A_k">k</code></td>
<td>
<p>the log base 2 of the run size (n) of the SOA.  <code>k</code> must be greater or equal to 4</p>
</td></tr>
<tr><td><code id="create_ABC_+3A_m">m</code></td>
<td>
<p>TODO</p>
</td></tr>
<tr><td><code id="create_ABC_+3A_constr">constr</code></td>
<td>
<p>type of construction.  Must be one of <code>"ShiTang_alphabeta", "ShiTang_alpha"</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of components
</p>

<dl>
<dt>A</dt><dd></dd>
<dt>B</dt><dd></dd>
<dt>C</dt><dd></dd>
<dt>Yates.columns</dt><dd><p>A list with components <code>A, B, C</code></p>
</dd>
</dl>


<hr>
<h2 id='create_DfromABC'>Create object D from an ABC object</h2><span id='topic+create_DfromABC'></span>

<h3>Description</h3>

<p>Create object D from an ABC object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>create_DfromABC(listABC, permlist = NULL, random = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="create_DfromABC_+3A_listabc">listABC</code></td>
<td>
<p>an object with elements A, B, C and Yates.columns with elements A,B,C</p>
</td></tr>
<tr><td><code id="create_DfromABC_+3A_permlist">permlist</code></td>
<td>
<p>a list of length m with three elements each</p>
</td></tr>
<tr><td><code id="create_DfromABC_+3A_random">random</code></td>
<td>
<p>is the construction randomized?</p>
</td></tr>
<tr><td><code id="create_DfromABC_+3A_...">...</code></td>
<td>
<p>Not used</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix
</p>

<hr>
<h2 id='createAB'>Utilities for array creation</h2><span id='topic+createAB'></span><span id='topic+BsFromB'></span><span id='topic+BcolsFromBcolllist'></span>

<h3>Description</h3>

<p>Utilities for array creation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createAB(s, k = 3, m = NULL, old = FALSE)

BsFromB(B, s = NULL, r = NULL, permlist = NULL, oneonly = TRUE)

BcolsFromBcolllist(Bcollist)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createAB_+3A_s">s</code></td>
<td>
<p>levels</p>
</td></tr>
<tr><td><code id="createAB_+3A_k">k</code></td>
<td>
<p>integer; determines the run size: the resulting array will have s^k runs</p>
</td></tr>
<tr><td><code id="createAB_+3A_m">m</code></td>
<td>
<p>the number of columns to be created</p>
</td></tr>
<tr><td><code id="createAB_+3A_b">B</code></td>
<td>
<p>n x m matrix</p>
</td></tr>
<tr><td><code id="createAB_+3A_r">r</code></td>
<td>
<p>number of copies</p>
</td></tr>
<tr><td><code id="createAB_+3A_permlist">permlist</code></td>
<td>
<p>permutation list</p>
</td></tr>
<tr><td><code id="createAB_+3A_oneonly">oneonly</code></td>
<td>
<p>logical: permute all copies in the same way?</p>
</td></tr>
<tr><td><code id="createAB_+3A_bcollist">Bcollist</code></td>
<td>
<p>list of candidate columns for He et al. (2018) construction</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>BcolsFromBcolllist</code> tries to create adequate unique matches from a list of suitable matches. For example, if four matches are needed and the list <code>list(1:2, 1:3, 4:6, 1)</code> holds the suitable matches for the four positions, the function would return the vector 2, 3, 4, 1.
</p>


<h3>Value</h3>

<p><code>createAB</code> returns a list of s^k times m matrices A, B and D for the He, Cheng and Tang (2018) construction
</p>
<p><code>BsFromB</code> returns an rn x m matrix
</p>
<p><code>BcolsFromBcolllist</code> returns column numbers selected for matrix B
</p>


<h3>Note</h3>

<p><code>BsFromB</code> is currently not used.
</p>

<hr>
<h2 id='createABcols'>initialize recursive construction of A,B,C</h2><span id='topic+createABcols'></span>

<h3>Description</h3>

<p>Used in the Shi and Tang Family 1 construction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createABcols(k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createABcols_+3A_k">k</code></td>
<td>
<p>the log base 2 of the run size (n) of the SOA.  <code>k &gt;= 4</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list containing
</p>

<dl>
<dt>Acols</dt><dd></dd>
<dt>Bcols</dt><dd></dd>
<dt>Ccols</dt><dd></dd>
</dl>


<hr>
<h2 id='createSaturated'>Function to create a regular saturated strength 2 array</h2><span id='topic+createSaturated'></span>

<h3>Description</h3>

<p>produces an OA(s^k, (s^k-1)/(s-1), s, 2) (Rao-Hamming construction)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createSaturated(s, k = 2)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createSaturated_+3A_s">s</code></td>
<td>
<p>the prime or prime power to use</p>
</td></tr>
<tr><td><code id="createSaturated_+3A_k">k</code></td>
<td>
<p>integer; determines the run size: the resulting array will have s^k runs</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For many situations, the saturated fractions produced by this function are not the best choice
for direct use in experimentation, because they heavily confound main effects with interactions.<br />
If not all columns are needed, using the last m columns may yield better results
than using the first m columns.<br />
If possible, stronger OAs from other sources can be used,
e.g. from package <span class="pkg">FrF2</span> for 2-level factors or from package <span class="pkg">DoE.base</span> for
factors with more than 2 levels.
</p>


<h3>Value</h3>

<p><code>createSaturated</code> returns an s^k times (s^k-1)/(s-1) matrix (saturated regular OA with s-level columns)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>createSaturated(3, k=3)  ## 27 x 13 array in 3 levels
</code></pre>

<hr>
<h2 id='createYcols'>Initial recursive construction of X, Y, and Z</h2><span id='topic+createYcols'></span>

<h3>Description</h3>

<p>Used in the Shi and Tang strength 3+ construction
</p>


<h3>Usage</h3>

<pre><code class='language-R'>createYcols(k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="createYcols_+3A_k">k</code></td>
<td>
<p>the log base 2 of the run size of the SOA: <code>n=2^k</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>a list of three components, each of length 2^k-1
</p>

<dl>
<dt>xcols</dt><dd></dd>
<dt>ycols</dt><dd></dd>
<dt>zcols</dt><dd></dd>
</dl>


<hr>
<h2 id='DcFromDp'>Create the expansions</h2><span id='topic+DcFromDp'></span>

<h3>Description</h3>

<p>this function is used in each step of the Weng optimization and for
the initialization of the XiaoXu optimization
</p>


<h3>Usage</h3>

<pre><code class='language-R'>DcFromDp(
  Dp,
  s,
  ell,
  permlist = rep(list(rep(list(rep(0:(ell - 1), each = nrow(Dp)/(s * ell))), s)),
    ncol(Dp))
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="DcFromDp_+3A_dp">Dp</code></td>
<td>
<p>an OA (ideally maximin optimized GMA OA)</p>
</td></tr>
<tr><td><code id="DcFromDp_+3A_s">s</code></td>
<td>
<p>the number of levels of each column in Dp</p>
</td></tr>
<tr><td><code id="DcFromDp_+3A_ell">ell</code></td>
<td>
<p><code>ell*s</code> is the target number of levels of the outgoing Dc</p>
</td></tr>
<tr><td><code id="DcFromDp_+3A_permlist">permlist</code></td>
<td>
<p>a list of m lists of length s permutations of the elements
of the replacement vector</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of the same size as <code>Dp</code>
</p>

<hr>
<h2 id='ff'>Utility functions for SOAs</h2><span id='topic+ff'></span><span id='topic+Yatesmat2'></span><span id='topic+fun_coeff'></span><span id='topic+interleavecols'></span>

<h3>Description</h3>

<p>Utility functions for SOAs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ff(...)

Yatesmat2(k)

fun_coeff(s, el)

interleavecols(A, B)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ff_+3A_...">...</code></td>
<td>
<p>list of integers or numeric vector with integers</p>
</td></tr>
<tr><td><code id="ff_+3A_k">k</code></td>
<td>
<p>determines dimension</p>
</td></tr>
<tr><td><code id="ff_+3A_s">s</code></td>
<td>
<p>the prime or prime power for which to obtain the coefficients</p>
</td></tr>
<tr><td><code id="ff_+3A_el">el</code></td>
<td>
<p>the power to which <code>s</code> is raised</p>
</td></tr>
<tr><td><code id="ff_+3A_a">A</code></td>
<td>
<p>n x m matrix A</p>
</td></tr>
<tr><td><code id="ff_+3A_b">B</code></td>
<td>
<p>n x m matrix B</p>
</td></tr>
</table>


<h3>Value</h3>

<p>ff returns a full factorial matrix
</p>
<p><code>Yatesmat2</code> returns a 2^k x (2^k - 1) matrix with 0/1 entries, Yates matrix
</p>
<p><code>fun_coeff</code> returns a matrix of coefficients for the creation
of a saturated regular fractional factorial of strength 2.
</p>
<p>interleavecols returns an n x (2m) matrix with columns <code>A[,1]</code>, <code>B[,1]</code>,
<code>A[,2]</code>, <code>B[,2]</code>, ...
</p>

<hr>
<h2 id='guide_SOAs'>Utility function for inspecting available SOAs for which the user need not provide an OA</h2><span id='topic+guide_SOAs'></span>

<h3>Description</h3>

<p>Utility function for inspecting available SOAs for which the user need not provide an OA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guide_SOAs(s = 2, el = 3, m = NULL, n = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guide_SOAs_+3A_s">s</code></td>
<td>
<p>required (default: 2); prime or prime power on which the SOA is based</p>
</td></tr>
<tr><td><code id="guide_SOAs_+3A_el">el</code></td>
<td>
<p>required (default: 3); the power to which <code>s</code> is to be taken,
i.e. the SOA will have columns with <code>s^el</code> levels</p>
</td></tr>
<tr><td><code id="guide_SOAs_+3A_m">m</code></td>
<td>
<p>the number of columns needed (optional)</p>
</td></tr>
<tr><td><code id="guide_SOAs_+3A_n">n</code></td>
<td>
<p>the maximum number of runs that are acceptable (optional);<br />
should be a multiple of <code>s^el</code>; must not be smaller than <code>m+1</code>, if <code>m</code> is specified</p>
</td></tr>
<tr><td><code id="guide_SOAs_+3A_...">...</code></td>
<td>
<p>currently unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function provides the possible creation variants of an
SOA that has <code>m</code> columns in <code>s^el</code> levels in up to <code>n</code> runs.
It is permitted to specify <code>m</code> OR <code>n</code> only; in that case the function
provides constructions with the smallest <code>n</code> or the largest <code>m</code>,
respectively.<br />
If both <code>m</code> and <code>n</code> are omitted, the function returns
the smallest possible (O)SOA constructions for <code>s^el</code> levels
that can be obtained without providing an OA.
</p>


<h3>Value</h3>

<p>The function returns a data frame, each row of which contains a possibility; if no SOAs exist, the data.frame has zero rows.
There is example code for constructing the SOA. Code details must be adjusted by the user
(see the documentation of the respective functions).
#'
</p>


<h3>Author(s)</h3>

<p>Ulrike Groemping
</p>


<h3>References</h3>

<p>For full detail, see <code><a href="#topic+SOAs-package">SOAs-package</a></code>.
</p>
<p>Groemping (2023a)<br />
He, Cheng and Tang (2018)<br />
Li, Liu and Yang (2021)<br />
Shi and Tang (2020)<br />
Zhou and Tang (2019)<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+guide_SOAs_from_OA">guide_SOAs_from_OA</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## guide_SOAs
## There is a Zhou and Tang type SOA with 4-level columns in 8 runs
guide_SOAs(2, 2, n=8)
## There are no SOAs with 8-level columns in 8 runs
guide_SOAs(2, 3, n=8)
## What SOAs based on s=2 in s^3 levels with 7 columns
## can be construct without providing an OA?
guide_SOAs(2, 3, m=7)
## pick the Shi and Tang family 3 design
myST_3plus &lt;- SOAs_8level(n=32, m=7, constr='ShiTang_alphabeta')
## Note that the design has orthogonal columns and strength 3+,
## i.e., very good balance properties.

</code></pre>

<hr>
<h2 id='guide_SOAs_from_OA'>Utility function for inspecting SOAs obtainable from an OA</h2><span id='topic+guide_SOAs_from_OA'></span>

<h3>Description</h3>

<p>Utility function for inspecting SOAs obtainable from an OA
</p>


<h3>Usage</h3>

<pre><code class='language-R'>guide_SOAs_from_OA(s, nOA, mOA, tOA, el = tOA, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="guide_SOAs_from_OA_+3A_s">s</code></td>
<td>
<p>required; the unique number of levels of the columns of a given OA (need not be prime or prime power)</p>
</td></tr>
<tr><td><code id="guide_SOAs_from_OA_+3A_noa">nOA</code></td>
<td>
<p>required; the number of runs of the OA</p>
</td></tr>
<tr><td><code id="guide_SOAs_from_OA_+3A_moa">mOA</code></td>
<td>
<p>required; the number of columns of the OA</p>
</td></tr>
<tr><td><code id="guide_SOAs_from_OA_+3A_toa">tOA</code></td>
<td>
<p>required; the strength of the OA; strengths larger than 5 are
reduced to 5; <code>el</code> must not be larger than the
(reduced) strength, except for <code>tOA=2</code> with <code>el=3</code>,
which is supported by the LLY algorithm</p>
</td></tr>
<tr><td><code id="guide_SOAs_from_OA_+3A_el">el</code></td>
<td>
<p>the power to which <code>s</code> is to be taken, i.e. the SOA will have columns with <code>s^el</code> levels;
default: <code>tOA</code>.<br />
except for <code>tOA=2</code> and <code>el=3</code>, <code>el</code> can be chosen smaller than <code>tOA</code>, but not larger.
If <code>el</code> is smaller than <code>tOA</code>, <code>tOA</code> is internally reduced before working out the possibilities.</p>
</td></tr>
<tr><td><code id="guide_SOAs_from_OA_+3A_...">...</code></td>
<td>
<p>currently unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function provides the possible creation variants of an SOA
from a strength <code>tOA</code> OA with <code>mOA</code> <code>s</code>-level columns
in <code>nOA</code> runs,
for an SOA that has columns in <code>s^el</code> levels.
Note that the SOA may have <code>nOA</code> runs
or <code>s*nOA</code> runs, depending on the construction.
</p>


<h3>Value</h3>

<p>The function returns a data frame, each row of which contains a possibility.
There is example code for constructing the SOA.
The code assumes that a given OA has the name <code>OA</code>;
this can of course be modified by the user.
Further code details can also be adjusted by the user
(see the documentation of the respective functions).
</p>


<h3>Author(s)</h3>

<p>Ulrike Groemping
</p>


<h3>References</h3>

<p>For full detail, see <code><a href="#topic+SOAs-package">SOAs-package</a></code>.
</p>
<p>Groemping (2023a)<br />
He and Tang (2013)<br />
He, Cheng and Tang (2018)<br />
Liu and Liu (2015)<br />
Li, Liu and Yang (2021)<br />
Shi and Tang (2020)<br />
Zhou and Tang (2019)<br />
</p>


<h3>See Also</h3>

<p><code><a href="#topic+guide_SOAs">guide_SOAs</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## guide_SOAs_from_OA
## there is an OA(81, 3^10, 3) (L81.3.10 in package DoE.base)
## inspect what can be done with it:
guide_SOAs_from_OA(s=3, mOA=10, nOA=81, tOA=3)
## the output shows that a strength 3 OSOA
## with 4 columns of 27 levels each can be obtained in 81 runs
## and provides the necessary code (replace OA with L81.3.10)
##      optimize=FALSE reduces example run time
OSOAs_LiuLiu(L81.3.10, t=3, optimize=FALSE)
## or that an SOA with 9 non-orthogonal columns can be obtained
## in the same number of runs
SOAs(L81.3.10, t=3)
</code></pre>

<hr>
<h2 id='int2poly'>Functions for Galois field calculations</h2><span id='topic+int2poly'></span><span id='topic+poly2int'></span><span id='topic+gf_sum'></span><span id='topic+gf_prod'></span><span id='topic+gf_sum_list'></span><span id='topic+gf_matmult'></span>

<h3>Description</h3>

<p>Functions for Galois field calculations
</p>


<h3>Usage</h3>

<pre><code class='language-R'>int2poly(x, gf)

poly2int(poly, gf)

gf_sum(x, y, gf)

gf_prod(x, y, gf)

gf_sum_list(ll, gf, checks = TRUE)

gf_matmult(M1, M2, gf, checks = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="int2poly_+3A_x">x</code></td>
<td>
<p>a vector of e elements in <code>0:(q-1)</code></p>
</td></tr>
<tr><td><code id="int2poly_+3A_gf">gf</code></td>
<td>
<p>Galois field object with characteristic <code>q</code></p>
</td></tr>
<tr><td><code id="int2poly_+3A_poly">poly</code></td>
<td>
<p>takes an e x n matrix of polygon rows or a
length n vector for a single polygon (e=1)</p>
</td></tr>
<tr><td><code id="int2poly_+3A_y">y</code></td>
<td>
<p>a second vector of e elements in <code>0:(q-1)</code></p>
</td></tr>
<tr><td><code id="int2poly_+3A_ll">ll</code></td>
<td>
<p>a list of integer vectors in <code>0:(q-1)</code></p>
</td></tr>
<tr><td><code id="int2poly_+3A_checks">checks</code></td>
<td>
<p>logical: should checks be performed</p>
</td></tr>
<tr><td><code id="int2poly_+3A_m1">M1</code></td>
<td>
<p>matrix 1 with elements in <code>0:(q-1)</code></p>
</td></tr>
<tr><td><code id="int2poly_+3A_m2">M2</code></td>
<td>
<p>matrix 2 with elements in <code>0:(q-1)</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>int2poly</code> returns an e x n matrix or a length n vector (if x is scalar)
</p>
<p><code>poly2int</code> returns an e element vector of integers in <code>0:(q-1)</code>
</p>
<p><code>gf_sum</code> returns the sum (e elements in <code>0:(q-1)</code>)
</p>
<p><code>gf_prod</code> returns the product (e elements in <code>0:(q-1)</code>)
</p>
<p><code>gf_sum_list</code> returns the sum (an integer vector in <code>0:(q-1)</code>)
</p>
<p><code>gf_matmult</code> returns the matrix product with elements from <code>0:(q-1)</code>
</p>

<hr>
<h2 id='mbound_LiuLiu'>bound for number of columns for LiuLiu OSOAs</h2><span id='topic+mbound_LiuLiu'></span>

<h3>Description</h3>

<p>bound for number of columns for LiuLiu OSOAs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mbound_LiuLiu(moa, t)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mbound_LiuLiu_+3A_moa">moa</code></td>
<td>
<p>number of oa columns</p>
</td></tr>
<tr><td><code id="mbound_LiuLiu_+3A_t">t</code></td>
<td>
<p>strength used in the construction in function <code>OSOAs_LiuLiu</code>
(it is assumed that the <code>oa</code> used has at least that strength)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>the maximum number of columns that can be obtained by the command
<code>OSOAs_LiuLiu(oa, t=t)</code> where oa has at least strength <code>t</code> and
consists of <code>moa</code> columns
</p>


<h3>Author(s)</h3>

<p>Ulrike Groemping
</p>


<h3>References</h3>

<p>#' For full detail, see <code><a href="#topic+SOAs-package">SOAs-package</a></code>.
</p>
<p>Liu and Liu 2015
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## moa is the number of columns of an oa
moa &lt;- rep(seq(4,40),3)
## t is the strength used in the construction
##      the oa must have at least this strength
t &lt;- rep(2:4, each=37)
## numbers of columns for the combination
mbounds &lt;- mapply(mbound_LiuLiu, moa, t)
## depending on the number of levels
## the number of runs can be excessive
## for larger values of moa with larger t!
## t=3 and t=4 have the same number of columns, except for moa=4*j+3
plot(moa, mbounds, pch=t, col=t)
</code></pre>

<hr>
<h2 id='MDLEs'>Function to create maximin distance level expanded arrays</h2><span id='topic+MDLEs'></span>

<h3>Description</h3>

<p>Maximin distance level expansion similar to Xiao and Xu is implemented,
using an optimization algorithm that is less demanding than the TA algorithm
of Xiao and Xu
</p>


<h3>Usage</h3>

<pre><code class='language-R'>MDLEs(
  oa,
  ell,
  noptim.rounds = 1,
  optimize = TRUE,
  noptim.oa = 1,
  dmethod = "manhattan",
  p = 50
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="MDLEs_+3A_oa">oa</code></td>
<td>
<p>matrix or data.frame that contains an ingoing symmetric OA. Levels must be denoted as 0 to s-1 or as 1 to s.</p>
</td></tr>
<tr><td><code id="MDLEs_+3A_ell">ell</code></td>
<td>
<p>the multiplier for each number of levels</p>
</td></tr>
<tr><td><code id="MDLEs_+3A_noptim.rounds">noptim.rounds</code></td>
<td>
<p>the number of optimization rounds; optimization may
take very long, therefore the default is 1, although more rounds are beneficial.</p>
</td></tr>
<tr><td><code id="MDLEs_+3A_optimize">optimize</code></td>
<td>
<p>logical: if <code>FALSE</code>, suppress optimization of expansion levels</p>
</td></tr>
<tr><td><code id="MDLEs_+3A_noptim.oa">noptim.oa</code></td>
<td>
<p>integer: number of optimization rounds applied to initial oa itself before starting expansion</p>
</td></tr>
<tr><td><code id="MDLEs_+3A_dmethod">dmethod</code></td>
<td>
<p>distance method for <code><a href="#topic+phi_p">phi_p</a></code>, &quot;manhattan&quot; (default) or &quot;euclidean&quot;</p>
</td></tr>
<tr><td><code id="MDLEs_+3A_p">p</code></td>
<td>
<p>p for <code><a href="#topic+phi_p">phi_p</a></code> (the larger, the closer to maximin distance)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ingoing oa is possibly optimized for space-filling, using function <code><a href="#topic+phi_optimize">phi_optimize</a></code>
with <code>noptim.oa</code> optimization rounds. The expansions themselves are again optimized for improving phi_p,
using an algorithm which is a variant of Weng (2014), instead of the more powerful but also much more demanding
algorithm proposed by Xiao and Xu.
</p>


<h3>Value</h3>

<p>A matrix of class <code>MDLE</code> with attributes
</p>

<dl>
<dt>phi_p</dt><dd><p>the phi_p value that was achieved</p>
</dd>
<dt>type</dt><dd><p>MDLE</p>
</dd>
<dt>optimized</dt><dd><p>logical: same as the input parameter</p>
</dd>
<dt>call</dt><dd><p>the call that produced the matrix</p>
</dd>
<dt>permpick</dt><dd><p>matrix of lists of length <code>s</code> with elements from 0 to <code>ell</code>-1;<br />
matrix element (i,j) contains the sequence of replacements used in function <code>DcFromDp</code> for constructing the level expansion of the ith level in the jth column</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ulrike Groemping
</p>


<h3>References</h3>

<p>For full detail, see <code><a href="#topic+SOAs-package">SOAs-package</a></code>.
</p>
<p>Weng (2014)<br />
Xiao and Xu (2018)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dim(aus &lt;- MDLEs(DoE.base::L16.4.5, 2, noptim.rounds = 1))
permpicks &lt;- attr(aus, "permpick")
## for people interested in internal workings:
## the code below produces the same matrix as MDLEs
SOAs:::DcFromDp(L16.4.5-1, 4,2, lapply(1:5, function(obj) permpicks[,obj]))
</code></pre>

<hr>
<h2 id='nchoosek'>Utility functions from DoE.base</h2><span id='topic+nchoosek'></span>

<h3>Description</h3>

<p>Utility functions from DoE.base
</p>


<h3>Usage</h3>

<pre><code class='language-R'>nchoosek(n, k)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="nchoosek_+3A_n">n</code></td>
<td>
<p>number to select from</p>
</td></tr>
<tr><td><code id="nchoosek_+3A_k">k</code></td>
<td>
<p>number to be selected without replacement</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>nchoosek</code> returns a <code>k</code> times <code>choose(n,k)</code> matrix
whose columns hold the possible selections in lexicographic order
</p>

<hr>
<h2 id='NeighbourcalcUniversal'>Function to do level permutations according to Weng's algorithm</h2><span id='topic+NeighbourcalcUniversal'></span>

<h3>Description</h3>

<p>Takes a workhorse function and creates random one- or two-neighbors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NeighbourcalcUniversal(
  funname,
  mperm,
  r,
  ...,
  startperm = NULL,
  allpermlist = NULL,
  neighbordist = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NeighbourcalcUniversal_+3A_funname">funname</code></td>
<td>
<p>function that creates the individual (O)SOAs</p>
</td></tr>
<tr><td><code id="NeighbourcalcUniversal_+3A_mperm">mperm</code></td>
<td>
<p>number of columns of <code>startperm</code></p>
</td></tr>
<tr><td><code id="NeighbourcalcUniversal_+3A_r">r</code></td>
<td>
<p>number of rows of <code>startperm</code></p>
</td></tr>
<tr><td><code id="NeighbourcalcUniversal_+3A_...">...</code></td>
<td>
<p>arguments for function <code>funname</code></p>
</td></tr>
<tr><td><code id="NeighbourcalcUniversal_+3A_startperm">startperm</code></td>
<td>
<p>matrix with position numbers of level permutations (refers to <code>allpermlist</code>)</p>
</td></tr>
<tr><td><code id="NeighbourcalcUniversal_+3A_allpermlist">allpermlist</code></td>
<td>
<p>list of all permutations</p>
</td></tr>
<tr><td><code id="NeighbourcalcUniversal_+3A_neighbordist">neighbordist</code></td>
<td>
<p>1 or 2: one- or two-neighbors in Weng's algorithm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of arrays and corresponding permutations
</p>

<hr>
<h2 id='NeighbourcalcUniversal_random'>Function to do level permutations according to Weng's algorithm
without using a stored list of all permutations</h2><span id='topic+NeighbourcalcUniversal_random'></span>

<h3>Description</h3>

<p>Takes a workhorse function and creates random one- or two-neighbors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>NeighbourcalcUniversal_random(
  funname,
  mperm,
  r,
  ...,
  curperms = NULL,
  replacement = NULL,
  neighbordist = 1
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="NeighbourcalcUniversal_random_+3A_funname">funname</code></td>
<td>
<p>function that creates the individual (O)SOAs</p>
</td></tr>
<tr><td><code id="NeighbourcalcUniversal_random_+3A_mperm">mperm</code></td>
<td>
<p>number of columns of <code>startperm</code></p>
</td></tr>
<tr><td><code id="NeighbourcalcUniversal_random_+3A_r">r</code></td>
<td>
<p>number of rows of <code>startperm</code></p>
</td></tr>
<tr><td><code id="NeighbourcalcUniversal_random_+3A_...">...</code></td>
<td>
<p>arguments for function <code>funname</code></p>
</td></tr>
<tr><td><code id="NeighbourcalcUniversal_random_+3A_curperms">curperms</code></td>
<td>
<p>an rxm matrix of lists of current permutation vectors, or NULL</p>
</td></tr>
<tr><td><code id="NeighbourcalcUniversal_random_+3A_replacement">replacement</code></td>
<td>
<p>a vector of replacements</p>
</td></tr>
<tr><td><code id="NeighbourcalcUniversal_random_+3A_neighbordist">neighbordist</code></td>
<td>
<p>1 or 2: one- or two-neighbors in Weng's algorithm</p>
</td></tr>
</table>


<h3>Value</h3>

<p>list of arrays and corresponding permutations
</p>

<hr>
<h2 id='ocheck'>functions to evaluate low order projection properties of (O)SOAs</h2><span id='topic+ocheck'></span><span id='topic+ocheck3'></span><span id='topic+count_npairs'></span><span id='topic+count_nallpairs'></span>

<h3>Description</h3>

<p><code>ocheck</code> and <code>ocheck3</code> evaluate pairwise or 3-orthogonality of columns,
<code>count_npairs</code> evaluates the number of level pairs in 2D projections,
<code>count_nallpairs</code> calculates corresponding total numbers of pairs.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ocheck(D, verbose = FALSE)

ocheck3(D, verbose = FALSE)

count_npairs(D, minn = 1)

count_nallpairs(ns)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ocheck_+3A_d">D</code></td>
<td>
<p>a matrix with factor levels or an object of class <code>SOA</code>;<br />
factor levels can start with 0 or with 1, and need to be consecutively numbered</p>
</td></tr>
<tr><td><code id="ocheck_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, additional information is printed
(table of correlations)</p>
</td></tr>
<tr><td><code id="ocheck_+3A_minn">minn</code></td>
<td>
<p>small integer number; the function counts pairs that are covered at least <code>minn</code> times</p>
</td></tr>
<tr><td><code id="ocheck_+3A_ns">ns</code></td>
<td>
<p>vector of numbers of levels for each column</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Functions <code>ocheck</code> and <code>ocheck3</code> return a logical.
</p>
<p>Functions <code>count_npairs</code> returns a vector of
counts for level combinations covered in factor pairs (in the order of the columns of
<code>DoE.base:::nchoosek(ncol(D),2)</code>) for the array in <code>D</code>,<br />
function <code>count_nallpairs</code> provides the total number of level combinations for
designs with numbers of levels given in <code>ns</code> (and thus can be used to obtain
a denominator for <code>count_npairs</code>).
</p>


<h3>Author(s)</h3>

<p>Ulrike Groemping
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#' ## Shi and Tang strength 3+ construction in 7 8-level factors for 32 runs
D &lt;- SOAs_8level(32, optimize=FALSE)
## is an OSOA
ocheck(D)

## an OSOA of strength 3 with 3-orthogonality
## 4 columns in 27 levels each
## second order model matrix

D_o &lt;- OSOAs_LiuLiu(DoE.base::L81.3.10, optimize=FALSE)
ocheck3(D_o)

## benefit of 3-orthogonality for second order linear models
colnames(D_o) &lt;- paste0("X", 1:4)
y &lt;- stats::rnorm(81)
mylm &lt;- stats::lm(y~(X1+X2+X3+X4)^2 + I(X1^2)+I(X2^2)+I(X3^2)+I(X4^2),
                   data=as.data.frame(scale(D_o, scale=FALSE)))
crossprod(stats::model.matrix(mylm))
</code></pre>

<hr>
<h2 id='OSOA_LiuLiut'>Strong Orthogonal Arrays of Strength t using the method of Liu and Liu</h2><span id='topic+OSOA_LiuLiut'></span>

<h3>Description</h3>

<p>Strong Orthogonal Arrays of Strength t using the method of Liu and Liu
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OSOA_LiuLiut(oa, t = NULL, m = NULL, permlist = NULL, random = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OSOA_LiuLiut_+3A_oa">oa</code></td>
<td>
<p>matrix or data.frame that contains an ingoing symmetric OA. Levels must be denoted as 0 to s-1 or as 1 to s.</p>
</td></tr>
<tr><td><code id="OSOA_LiuLiut_+3A_t">t</code></td>
<td>
<p>strength of <code>oa</code>.  If <code>NULL</code> (default), <code>t</code> will be
determined.  <code>t</code> can be chosen smaller than the input strength if
additional columns are desired.</p>
</td></tr>
<tr><td><code id="OSOA_LiuLiut_+3A_m">m</code></td>
<td>
<p>desired number of columns.  Defaults to the maximum possible.</p>
</td></tr>
<tr><td><code id="OSOA_LiuLiut_+3A_permlist">permlist</code></td>
<td>
<p>a list of length m of lists of length 1 of permutations of the levels</p>
</td></tr>
<tr><td><code id="OSOA_LiuLiut_+3A_random">random</code></td>
<td>
<p>a logical (a random draw of permutations is used if <code>permlist</code> is <code>NULL</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Suitable OAs for argument <code>oa</code> can e.g. be constructed with OA creation functions
from package <span class="pkg">lhs</span> or can be obtained from arrays listed in R package <span class="pkg">DoE.base</span>.
</p>


<h3>Value</h3>

<p>an orthogonal array
</p>


<h3>References</h3>

<p>Liu and Liu (2015)
</p>

<hr>
<h2 id='OSOAarbitrary'>Auxiliary function for optimized creation of OSOAs (function OSOAs)
using the Li et al. algorithm for arbitrary initial OA</h2><span id='topic+OSOAarbitrary'></span>

<h3>Description</h3>

<p>The optimization is done with function <code>NeighbourcalcUniversal.R</code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OSOAarbitrary(oa, el = 3, m = NULL, permlist = NULL, random = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OSOAarbitrary_+3A_oa">oa</code></td>
<td>
<p>matrix (preferred) or data.frame</p>
</td></tr>
<tr><td><code id="OSOAarbitrary_+3A_el">el</code></td>
<td>
<p>must be 2 or 3.  <code>el=3</code>: Li et al; <code>el=2</code>: Zhou and Tang</p>
</td></tr>
<tr><td><code id="OSOAarbitrary_+3A_m">m</code></td>
<td>
<p>desired number of columns.  Defaults to the maximum possible.</p>
</td></tr>
<tr><td><code id="OSOAarbitrary_+3A_permlist">permlist</code></td>
<td>
<p>a list of length m of lists of length 1 of permutations of the levels</p>
</td></tr>
<tr><td><code id="OSOAarbitrary_+3A_random">random</code></td>
<td>
<p>a logical (a random draw of permutations is used if <code>permlist</code> is <code>NULL</code>)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>an orthogonal array
</p>


<h3>References</h3>

<p>Li et al.
Zhou and Tang
</p>

<hr>
<h2 id='OSOApb'>function to create a strength 3 OSOA with 8-level columns from a Hadamard matrix</h2><span id='topic+OSOApb'></span>

<h3>Description</h3>

<p>A Hadamard matrix in m runs is used for creating an OSOA in n=2m runs for at most m-2 columns.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OSOApb(m = NULL, n = NULL, el = 3)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OSOApb_+3A_m">m</code></td>
<td>
<p>the number of columns to be created;
if <code>n</code> is also given, <code>m</code> must be compatible with it</p>
</td></tr>
<tr><td><code id="OSOApb_+3A_n">n</code></td>
<td>
<p>the number of runs to be created (must be a multiple of 8);
if <code>m</code> is also given, <code>n</code> must be compatible with it</p>
</td></tr>
<tr><td><code id="OSOApb_+3A_el">el</code></td>
<td>
<p>exponent for 2, can be 2 or 3: the OSOA will have columns with
2^el (4 or 8) levels</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At least one of <code>m</code> or <code>n</code> must be provided. For <code>el=2</code>,
Zhou and Tang (2019) strength 3- designs are created, for <code>el=3</code> strength
3 designs by Li, Liu and Yang (2021).
</p>


<h3>Value</h3>

<p>an OSOA of strength 3- or 3 (matrix)
</p>


<h3>Note</h3>

<p>Replaced by OSOAs_hadamard; eventually remove
</p>


<h3>Author(s)</h3>

<p>Ulrike Groemping
</p>


<h3>References</h3>

<p>Li, Liu and Yang (2021)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dim(OSOApb(9))  ## 9 8-level factors in 24 runs
dim(OSOApb(n=16)) ## 6 8-level factors in 16 runs
dim(OSOApb(m=35)) ## 35 8-level factors in 80 runs

</code></pre>

<hr>
<h2 id='OSOAregulart'>TODO</h2><span id='topic+OSOAregulart'></span>

<h3>Description</h3>

<p>TODO
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OSOAregulart(s, k = 3, el = 3, m = NULL, permlist = NULL, random = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OSOAregulart_+3A_s">s</code></td>
<td>
<p>TODO</p>
</td></tr>
<tr><td><code id="OSOAregulart_+3A_k">k</code></td>
<td>
<p>TODO</p>
</td></tr>
<tr><td><code id="OSOAregulart_+3A_el">el</code></td>
<td>
<p>TODO</p>
</td></tr>
<tr><td><code id="OSOAregulart_+3A_m">m</code></td>
<td>
<p>TODO</p>
</td></tr>
<tr><td><code id="OSOAregulart_+3A_permlist">permlist</code></td>
<td>
<p>TODO</p>
</td></tr>
<tr><td><code id="OSOAregulart_+3A_random">random</code></td>
<td>
<p>TODO</p>
</td></tr>
</table>


<h3>Value</h3>

<p>TODO
</p>


<h3>Note</h3>

<p>eventually remove, since function OSOAs_regular now uses OSOAs
</p>


<h3>Examples</h3>

<pre><code class='language-R'>print("TODO")

</code></pre>

<hr>
<h2 id='OSOAs'>Function to create an OSOA from an OA</h2><span id='topic+OSOAs'></span>

<h3>Description</h3>

<p>An OSOA in ns runs of strength 2* (s^3 levels) or 2+ (s^2 levels) is created from an OA(n,m,s,2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OSOAs(
  oa,
  el = 3,
  m = NULL,
  noptim.rounds = 1,
  noptim.repeats = 1,
  optimize = TRUE,
  dmethod = "manhattan",
  p = 50
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OSOAs_+3A_oa">oa</code></td>
<td>
<p>matrix or data.frame that contains an ingoing symmetric OA. Levels must be denoted as 0 to s-1 or as 1 to s.</p>
</td></tr>
<tr><td><code id="OSOAs_+3A_el">el</code></td>
<td>
<p>the exponent of the number of levels, <code>el=3</code> yields a
strength 2* OSOA in s^3 levels, <code>el=2</code> a strength 2+ OSOA in s^2 levels</p>
</td></tr>
<tr><td><code id="OSOAs_+3A_m">m</code></td>
<td>
<p>the desired number of columns of the resulting array; odd values of
m will be reduced by one, so specify the next largest even m, if you need an
odd number of columns (the function will do so, if possible; if <code>m=NULL</code>,
the maximum possible value is used.</p>
</td></tr>
<tr><td><code id="OSOAs_+3A_noptim.rounds">noptim.rounds</code></td>
<td>
<p>the number of optimization rounds for each independent restart</p>
</td></tr>
<tr><td><code id="OSOAs_+3A_noptim.repeats">noptim.repeats</code></td>
<td>
<p>the number of independent restarts of optimizations with <code>noptim.rounds</code> rounds each</p>
</td></tr>
<tr><td><code id="OSOAs_+3A_optimize">optimize</code></td>
<td>
<p>logical: should space filling be optimized by level permutations?</p>
</td></tr>
<tr><td><code id="OSOAs_+3A_dmethod">dmethod</code></td>
<td>
<p>distance method for <code><a href="#topic+phi_p">phi_p</a></code>, &quot;manhattan&quot; (default) or &quot;euclidean&quot;</p>
</td></tr>
<tr><td><code id="OSOAs_+3A_p">p</code></td>
<td>
<p>p for <code><a href="#topic+phi_p">phi_p</a></code> (the larger, the closer to maximin distance)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements the algorithms proposed by Zhou and Tang 2018
(s^2 levels) or Li, Liu and Yang 2021 (s^3 levels).
Both are enhanced with the modification for matrix A by Groemping 2022.
Level permutations are optimized
using an adaptation of the algorithm by Weng (2014).
</p>
<p>Suitable OAs for argument <code>oa</code> can e.g. be constructed with OA creation functions
from package <span class="pkg">lhs</span> or can be obtained
from arrays listed in R package <span class="pkg">DoE.base</span>
</p>


<h3>Value</h3>

<p>matrix of class <code>SOA</code> with the attributes that are listed below. All attributes can be accessed using function <code><a href="base.html#topic+attributes">attributes</a></code>, or individual attributes can be accessed using function <code><a href="base.html#topic+attr">attr</a></code>. These are the attributes:
</p>

<dl>
<dt>type</dt><dd><p>the type of array (<code>SOA</code> or <code>OSOA</code>)</p>
</dd>
<dt>strength</dt><dd><p>character string that gives the strength</p>
</dd>
<dt>phi_p</dt><dd><p>the phi_p value (smaller=better)</p>
</dd>
<dt>optimized</dt><dd><p>logical indicating whether optimization was applied</p>
</dd>
<dt>permpick</dt><dd><p>matrix that lists the id numbers of the permutations used</p>
</dd>
<dt>perms2pickfrom</dt><dd><p>optional element, when optimization was conducted: the
overall permutation list to which the numbers in permlist refer</p>
</dd>
<dt>call</dt><dd><p>the call that created the object</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ulrike Groemping
</p>


<h3>References</h3>

<p>For full detail, see <code><a href="#topic+SOAs-package">SOAs-package</a></code>.
</p>
<p>Groemping (2023a)<br />
Li, Liu and Yang (2021)<br />
Weng (2014)<br />
Zhou and Tang (2019)<br />
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## run with optimization for actual use!

## 54 runs with seven 9-level columns
OSOAs(DoE.base::L18[,3:8], el=2, optimize=FALSE)

## 54 runs with six 27-level columns
OSOAs(DoE.base::L18[,3:8], el=3, optimize=FALSE)

## 81 runs with four 9-level columns
OSOAs(DoE.base::L27.3.4, el=2, optimize=FALSE)
## An OA with 9-level factors (L81.9.10)
## has complete balance in 2D,
## however does not achieve 3D projection for
## all four collapsed triples
## It is up to the user to decide what is more important.
## I would go for the OA.

## 81 runs with four 27-level columns
OSOAs(DoE.base::L27.3.4, el=3, optimize=FALSE)
</code></pre>

<hr>
<h2 id='OSOAs_hadamard'>function to create a strength 3 OSOA with 8-level columns or a strength 3- OSOA with 4-level columns from a Hadamard matrix</h2><span id='topic+OSOAs_hadamard'></span>

<h3>Description</h3>

<p>A Hadamard matrix in k runs is used for creating an OSOA in n=2k runs for at most m=k-2 columns (8-level) or m=k-1 columns (4-level).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OSOAs_hadamard(
  m = NULL,
  n = NULL,
  el = 3,
  noptim.rounds = 1,
  noptim.repeats = 1,
  optimize = TRUE,
  dmethod = "manhattan",
  p = 50
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OSOAs_hadamard_+3A_m">m</code></td>
<td>
<p>the number of columns to be created;
if <code>n</code> is also given, <code>m</code> must be compatible with it; at present, <code>m</code> can be at most 98.</p>
</td></tr>
<tr><td><code id="OSOAs_hadamard_+3A_n">n</code></td>
<td>
<p>the number of runs to be created; <code>n</code> must be a multiple of 8 and can (at present) be at most 200;
if <code>m</code> is also given, <code>n</code> must be compatible with it.</p>
</td></tr>
<tr><td><code id="OSOAs_hadamard_+3A_el">el</code></td>
<td>
<p>exponent for 2, can be 2 or 3: the OSOA will have columns with
2^<code>el</code> (4 or 8) levels</p>
</td></tr>
<tr><td><code id="OSOAs_hadamard_+3A_noptim.rounds">noptim.rounds</code></td>
<td>
<p>the number of optimization rounds for each independent restart</p>
</td></tr>
<tr><td><code id="OSOAs_hadamard_+3A_noptim.repeats">noptim.repeats</code></td>
<td>
<p>the number of independent restarts of optimizations with <code>noptim.rounds</code> rounds each</p>
</td></tr>
<tr><td><code id="OSOAs_hadamard_+3A_optimize">optimize</code></td>
<td>
<p>logical: should space filling be optimized by level permutations?</p>
</td></tr>
<tr><td><code id="OSOAs_hadamard_+3A_dmethod">dmethod</code></td>
<td>
<p>distance method for <code><a href="#topic+phi_p">phi_p</a></code>, &quot;manhattan&quot; (default) or &quot;euclidean&quot;</p>
</td></tr>
<tr><td><code id="OSOAs_hadamard_+3A_p">p</code></td>
<td>
<p>p for <code><a href="#topic+phi_p">phi_p</a></code> (the larger, the closer to maximin distance)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>At least one of <code>m</code> or <code>n</code> must be provided. For <code>el=2</code>,
Zhou and Tang (2019) strength 3- designs are created, for <code>el=3</code> strength
3 designs by Li, Liu and Yang (2021).<br />
Li et al.'s creation of the matrix A has been enhanced by using a column specific
fold-over, which is beneficial for the space-filling properties (see Groemping 2022).
</p>


<h3>Value</h3>

<p>matrix of class <code>SOA</code> with the attributes that are listed below. All attributes can be accessed using function <code><a href="base.html#topic+attributes">attributes</a></code>, or individual attributes can be accessed using function <code><a href="base.html#topic+attr">attr</a></code>. These are the attributes:
</p>

<dl>
<dt>type</dt><dd><p>the type of array (<code>SOA</code> or <code>OSOA</code>)</p>
</dd>
<dt>strength</dt><dd><p>character string that gives the strength</p>
</dd>
<dt>phi_p</dt><dd><p>the phi_p value (smaller=better)</p>
</dd>
<dt>optimized</dt><dd><p>logical indicating whether optimization was applied</p>
</dd>
<dt>permpick</dt><dd><p>matrix that lists the id numbers of the permutations used</p>
</dd>
<dt>perms2pickfrom</dt><dd><p>optional element, when optimization was conducted: the
overall permutation list to which the numbers in permlist refer</p>
</dd>
<dt>call</dt><dd><p>the call that created the object</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ulrike Groemping
</p>


<h3>References</h3>

<p>For full detail, see <code><a href="#topic+SOAs-package">SOAs-package</a></code>.
</p>
<p>Groemping (2023a)<br />
Li, Liu and Yang (2021)<br />
Weng (2014)<br />
Zhou and Tang (2019)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dim(OSOAs_hadamard(9, optimize=FALSE))  ## 9 8-level factors in 24 runs
dim(OSOAs_hadamard(n=16, optimize=FALSE)) ## 6 8-level factors in 16 runs
OSOAs_hadamard(n=24, m=6, optimize=FALSE) ## 6 8-level factors in 24 runs
                                          ## (though 10 would be possible)
dim(OSOAs_hadamard(m=35, optimize=FALSE)) ## 35 8-level factors in 80 runs
</code></pre>

<hr>
<h2 id='OSOAs_LiuLiu'>Function to create OSOAs of strengths 2, 3, or 4 from an OA</h2><span id='topic+OSOAs_LiuLiu'></span>

<h3>Description</h3>

<p>Creates OSOAs from an OA according to the construction by Liu and Liu (2015).
Strengths 2 to 4 are covered. Strengths 3 and 4 guarantee 3-orthogonality.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OSOAs_LiuLiu(
  oa,
  t = NULL,
  m = NULL,
  noptim.rounds = 1,
  noptim.repeats = 1,
  optimize = TRUE,
  dmethod = "manhattan",
  p = 50
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OSOAs_LiuLiu_+3A_oa">oa</code></td>
<td>
<p>matrix or data.frame; a symmetric orthogonal array of strength at least <code>t</code></p>
</td></tr>
<tr><td><code id="OSOAs_LiuLiu_+3A_t">t</code></td>
<td>
<p>the requested strength of the OSOA</p>
</td></tr>
<tr><td><code id="OSOAs_LiuLiu_+3A_m">m</code></td>
<td>
<p>the requested number of columns of the OSOA (at most <code>mbound_LiuLiu(ncol(oa), t)</code>).</p>
</td></tr>
<tr><td><code id="OSOAs_LiuLiu_+3A_noptim.rounds">noptim.rounds</code></td>
<td>
<p>the number of optimization rounds for each independent restart</p>
</td></tr>
<tr><td><code id="OSOAs_LiuLiu_+3A_noptim.repeats">noptim.repeats</code></td>
<td>
<p>the number of independent restarts of optimizations with <code>noptim.rounds</code> rounds each</p>
</td></tr>
<tr><td><code id="OSOAs_LiuLiu_+3A_optimize">optimize</code></td>
<td>
<p>logical: should space filling be optimized by level permutations?</p>
</td></tr>
<tr><td><code id="OSOAs_LiuLiu_+3A_dmethod">dmethod</code></td>
<td>
<p>distance method for <code><a href="#topic+phi_p">phi_p</a></code>, &quot;manhattan&quot; (default) or &quot;euclidean&quot;</p>
</td></tr>
<tr><td><code id="OSOAs_LiuLiu_+3A_p">p</code></td>
<td>
<p>p for <code><a href="#topic+phi_p">phi_p</a></code> (the larger, the closer to maximin distance)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The number of columns goes down dramatically with the requested strength.
However, the strength 3 or 4 arrays may be worthwhile,
because they guarantee 3-orthogonality, which implies that (quantitative)
linear models with main effects and second order effects can be robustly estimated.
</p>
<p>Optimization is less successful for this construction of OSOAs; for small
arrays, the level permutations make (almost) no difference.
</p>
<p>Function <code>mbound_LiuLiu(moa, t)</code> calculates the number of columns that can be
obtained from a strength <code>t</code> OA with <code>moa</code> columns (if such an array
exists, the function does not check that).
</p>
<p>Ingoing arrays can be obtained
from oa-generating functions of R package <span class="pkg">lhs</span> like <code>createBoseBush</code>, or from OAs in
R package <span class="pkg">DoE.base</span>, or from 2-level designs created with R package <span class="pkg">FrF2</span> (see example section).
</p>


<h3>Value</h3>

<p>matrix of class <code>SOA</code> with the attributes that are listed below. All attributes can be accessed using function <code><a href="base.html#topic+attributes">attributes</a></code>, or individual attributes can be accessed using function <code><a href="base.html#topic+attr">attr</a></code>. These are the attributes:
</p>

<dl>
<dt>type</dt><dd><p>the type of array (<code>SOA</code> or <code>OSOA</code>)</p>
</dd>
<dt>strength</dt><dd><p>character string that gives the strength</p>
</dd>
<dt>phi_p</dt><dd><p>the phi_p value (smaller=better)</p>
</dd>
<dt>optimized</dt><dd><p>logical indicating whether optimization was applied</p>
</dd>
<dt>permpick</dt><dd><p>matrix that lists the id numbers of the permutations used</p>
</dd>
<dt>perms2pickfrom</dt><dd><p>optional element, when optimization was conducted: the
overall permutation list to which the numbers in permlist refer</p>
</dd>
<dt>call</dt><dd><p>the call that created the object</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ulrike Groemping
</p>


<h3>References</h3>

<p>For full detail, see <code><a href="#topic+SOAs-package">SOAs-package</a></code>.
</p>
<p>Liu and Liu (2015)<br />
Weng (2014)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## strength 2, very small (four 9-level columns in 9 runs)
OSOA9 &lt;- OSOAs_LiuLiu(DoE.base::L9.3.4)

## strength 3, from a Plackett-Burman design of FrF2
## 10 8-level columns in 40 runs with OSOA strength 3
oa &lt;- suppressWarnings(FrF2::pb(40)[,c(1:19,39)])
### columns 1 to 19 and 39 together are the largest possible strength 3 set
OSOA40 &lt;- OSOAs_LiuLiu(oa, optimize=FALSE)  ## strength 3, 8 levels
### optimize would improve phi_p, but suppressed for saving run time

## 9 8-level columns in 40 runs with OSOA strength 3
oa &lt;- FrF2::pb(40,19)
### 9 columns would be obtained without the final column in oa
mbound_LiuLiu(19, t=3)     ## example for which q=3
mbound_LiuLiu(19, t=4)     ## t=3 has one more column than t=4
OSOA40_2 &lt;- OSOAs_LiuLiu(oa, optimize=FALSE)  ## strength 3, 8 levels
### optimize would improve phi_p, but suppressed for saving run time

## starting from a strength 4 OA
oa &lt;- FrF2::FrF2(64,8)
## four 16 level columns in 64 runs with OSOA strength 4
OSOA64 &lt;- OSOAs_LiuLiu(oa, optimize=FALSE)  ## strength 4, 16 levels

### reducing the strength to 3 does not increase the number of columns
mbound_LiuLiu(8, t=3)
### reducing the strength to 2 doubles the number of columns
mbound_LiuLiu(8, t=2)
## eight 4-level columns in 64 runs with OSOA strength 2
OSOA64_2 &lt;- OSOAs_LiuLiu(oa, t=2, optimize=FALSE)
## fulfills the 2D strength 2 property
soacheck2D(OSOA64_2, s=2, el=2, t=2)
### fulfills also the 3D strength 3 property
soacheck3D(OSOA64_2, s=2, el=2, t=3)
### fulfills also the 4D strength 4 property
DoE.base::GWLP(OSOA64/2)
### but not the 3D strength 4 property
soacheck3D(OSOA64_2, s=2, el=2, t=4)
### and not the 2D 4x2 and 2x4 stratification balance
soacheck2D(OSOA64_2, s=2, el=2, t=3)
## six 36-level columns in 72 runs with OSOA strength 2
oa &lt;- DoE.base::L72.2.5.3.3.4.1.6.7[,10:16]
OSOA72 &lt;- OSOAs_LiuLiu(oa, t=2, optimize=FALSE)
</code></pre>

<hr>
<h2 id='OSOAs_regular'>Function to create an OSOA in s^2 or s^3 levels and s^k runs
from a basic number of levels s and a power k</h2><span id='topic+OSOAs_regular'></span>

<h3>Description</h3>

<p>The OSOA in s^k runs accommodates at most m=(s^(k-1)-1)/(s-1) columns in
s^2 levels or m'=2*floor(m/2) columns in s^3 levels.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>OSOAs_regular(
  s,
  k,
  el = 3,
  m = NULL,
  noptim.rounds = 1,
  noptim.repeats = 1,
  optimize = TRUE,
  dmethod = "manhattan",
  p = 50
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="OSOAs_regular_+3A_s">s</code></td>
<td>
<p>the prime or prime power to use (do not use for s=2, because other
method is better); the resulting array will have pairwise orthogonal columns in s^t levels</p>
</td></tr>
<tr><td><code id="OSOAs_regular_+3A_k">k</code></td>
<td>
<p>integer &gt;=3; determines the run size: the resulting array will have s^k runs</p>
</td></tr>
<tr><td><code id="OSOAs_regular_+3A_el">el</code></td>
<td>
<p>2 or 3; the exponent of the number of levels, <code>el=3</code> yields a
strength 2* or 3 OSOA in s^3 levels, <code>el=2</code> a strength 2+ or 3- OSOA in s^2 levels</p>
</td></tr>
<tr><td><code id="OSOAs_regular_+3A_m">m</code></td>
<td>
<p>the desired number of columns of the resulting array; for
<code>el=3</code>, odd values of <code>m</code> will be reduced by one, so specify the
next largest even <code>m</code>, if you need an odd number of columns (the function
will do so, if possible); if <code>m=NULL</code>, the maximum possible value is used.
This is at most (s^(k-1)-1)/(s-1), or one less if this is odd and <code>el=3</code>.</p>
</td></tr>
<tr><td><code id="OSOAs_regular_+3A_noptim.rounds">noptim.rounds</code></td>
<td>
<p>the number of optimization rounds for each independent restart</p>
</td></tr>
<tr><td><code id="OSOAs_regular_+3A_noptim.repeats">noptim.repeats</code></td>
<td>
<p>the number of independent restarts of optimizations with <code>noptim.rounds</code> rounds each</p>
</td></tr>
<tr><td><code id="OSOAs_regular_+3A_optimize">optimize</code></td>
<td>
<p>logical: should space filling be optimized by level permutations?</p>
</td></tr>
<tr><td><code id="OSOAs_regular_+3A_dmethod">dmethod</code></td>
<td>
<p>distance method for <code><a href="#topic+phi_p">phi_p</a></code>, &quot;manhattan&quot; (default) or &quot;euclidean&quot;</p>
</td></tr>
<tr><td><code id="OSOAs_regular_+3A_p">p</code></td>
<td>
<p>p for <code><a href="#topic+phi_p">phi_p</a></code> (the larger, the closer to maximin distance)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function implements the algorithms proposed by Zhou and Tang 2018
(s^2 levels) or Li, Liu and Yang 2021 (s^3 levels), enhanced with the
modification for matrix A by Groemping (2023a). Level permutations are optimized
using an adaptation of the algorithm by Weng (2014).
</p>
<p>If <code>m</code> is specified, the function uses the last <code>m</code> columns of
a saturated OA produced by function <code><a href="#topic+createSaturated">createSaturated</a>(s, k-1)</code>. <br />
If <code>m</code> is small enough that a resolution IV / strength 3 OA for <code>s</code> levels in <code>s^(k-1)</code> runs exists,
function <code><a href="#topic+OSOAs">OSOAs</a></code> should be used with such an OA (which can be obtained from package <span class="pkg">FrF2</span>
for <code>s=2</code> or from package <span class="pkg">DoE.base</span> for <code>s&gt;2</code>). For <code>s=2</code>,
function <code><a href="#topic+OSOAs_hadamard">OSOAs_hadamard</a></code> may also be a better choice than <code><a href="#topic+OSOAs_regular">OSOAs_regular</a> for
up to 192 runs</code>.
</p>


<h3>Value</h3>

<p>matrix of class <code>SOA</code> with the attributes that are listed below. All attributes can be accessed using function <code><a href="base.html#topic+attributes">attributes</a></code>, or individual attributes can be accessed using function <code><a href="base.html#topic+attr">attr</a></code>. These are the attributes:
</p>

<dl>
<dt>type</dt><dd><p>the type of array (<code>SOA</code> or <code>OSOA</code>)</p>
</dd>
<dt>strength</dt><dd><p>character string that gives the strength</p>
</dd>
<dt>phi_p</dt><dd><p>the phi_p value (smaller=better)</p>
</dd>
<dt>optimized</dt><dd><p>logical indicating whether optimization was applied</p>
</dd>
<dt>permpick</dt><dd><p>matrix that lists the id numbers of the permutations used</p>
</dd>
<dt>perms2pickfrom</dt><dd><p>optional element, when optimization was conducted: the
overall permutation list to which the numbers in permlist refer</p>
</dd>
<dt>call</dt><dd><p>the call that created the object</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ulrike Groemping
</p>


<h3>References</h3>

<p>For full detail, see <code><a href="#topic+SOAs-package">SOAs-package</a></code>.
Groemping (2023a)<br />
Li, Liu and Yang (2021)<br />
Weng (2014)<br />
Zhou and Tang (2019)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## 13 columns in 9 levels each
OSOAs_regular(3, 4, el=2, optimize=FALSE) ## 13 columns, phi_p about 0.117
# optimizing level permutations typically improves phi_p a lot
# OSOAs_regular(3, 4, el=2) ## 13 columns, phi_p typically below 0.055
</code></pre>

<hr>
<h2 id='permopt'>optimize GWLP optimal oa for maximin criterion phi_p</h2><span id='topic+permopt'></span>

<h3>Description</h3>

<p>optimize GWLP optimal oa for maximin criterion phi_p
</p>


<h3>Usage</h3>

<pre><code class='language-R'>permopt(oa, s, m)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="permopt_+3A_oa">oa</code></td>
<td>
<p>GWLP optimal orthogonal array</p>
</td></tr>
<tr><td><code id="permopt_+3A_s">s</code></td>
<td>
<p>TODO</p>
</td></tr>
<tr><td><code id="permopt_+3A_m">m</code></td>
<td>
<p>TODO</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a matrix of the same dimension as <code>oa</code>
</p>


<h3>Note</h3>

<p>not used any more
</p>

<hr>
<h2 id='phi_optimize'>function to optimize the phi_p value of an array by level permutation</h2><span id='topic+phi_optimize'></span>

<h3>Description</h3>

<p>takes an n x m array and returns an n x m array with improved phi_p value (if possible)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phi_optimize(
  D,
  noptim.rounds = 1,
  noptim.repeats = 1,
  dmethod = "manhattan",
  p = 50
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phi_optimize_+3A_d">D</code></td>
<td>
<p>numeric matrix or data.frame with numeric columns, n x m. A symmetric array (e.g. an OA) with <code>nl</code> levels for each columns. Levels must be coded as 0 to <code>nl - 1</code> or as 1 to <code>nl</code>. levels from</p>
</td></tr>
<tr><td><code id="phi_optimize_+3A_noptim.rounds">noptim.rounds</code></td>
<td>
<p>number of rounds in the Weng algorithm</p>
</td></tr>
<tr><td><code id="phi_optimize_+3A_noptim.repeats">noptim.repeats</code></td>
<td>
<p>number of independent repeats of the Weng algorithm</p>
</td></tr>
<tr><td><code id="phi_optimize_+3A_dmethod">dmethod</code></td>
<td>
<p>distance method for <code><a href="#topic+phi_p">phi_p</a></code>, &quot;manhattan&quot; (default) or &quot;euclidean&quot;</p>
</td></tr>
<tr><td><code id="phi_optimize_+3A_p">p</code></td>
<td>
<p>p for <code><a href="#topic+phi_p">phi_p</a></code> (the larger, the closer to maximin distance)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function uses the algorithm proposed by Weng (2014) for SOA optimization:
</p>
<p>It starts with a random permutation of column levels.
</p>
<p>Initially, individual columns are randomly permuted (m permuted matrices, called one-neighbours), and the best permutation w.r.t. the <code>phi_p</code> value (manhattan distance) is
is made the current optimum. This continues, until the current optimum is not improved by a set of randomly drawn one-neighbours.<br />
Subsequently, pairs of columns are randomly permuted (<code>choose(m,2)</code> permuted matrices, called two-neighbours). If the current optimum can be improved or the number of optimization rounds has not yet been exhausted,
a new round with one-neighbours is started with the current optimum. Otherwise, the current optimum is returned, or an independent repeat is initiated (if requested).
</p>
<p>Limited experience suggests that an increase of <code>noptim.rounds</code> from the default 1 is often helpful, whereas an increase of <code>noptim.repeats</code> did not yield as much improvement.
</p>


<h3>Value</h3>

<p>an n x m matrix
</p>


<h3>Author(s)</h3>

<p>Ulrike Groemping
</p>


<h3>References</h3>

<p>For full detail, see <code><a href="#topic+SOAs-package">SOAs-package</a></code>.
</p>
<p>Weng (2014)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>oa &lt;- lhs::createBoseBush(8,16)
print(phi_p(oa, dmethod="manhattan"))
oa_optimized &lt;- phi_optimize(oa)
print(phi_p(oa_optimized, dmethod="manhattan"))
</code></pre>

<hr>
<h2 id='phi_p'>Functions to evaluate space filling of an array</h2><span id='topic+phi_p'></span><span id='topic+mindist'></span>

<h3>Description</h3>

<p>phi_p calculates the discrepancy
</p>
<p>phi_p calculates the discrepancy
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phi_p(D, dmethod = "manhattan", p = 50)

mindist(D, dmethod = "manhattan")

phi_p(D, dmethod = "manhattan", p = 50)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phi_p_+3A_d">D</code></td>
<td>
<p>an array or an object of class SOA or MDLE</p>
</td></tr>
<tr><td><code id="phi_p_+3A_dmethod">dmethod</code></td>
<td>
<p>the distance to use, <code>"manhattan"</code> (default) or <code>"euclidean"</code></p>
</td></tr>
<tr><td><code id="phi_p_+3A_p">p</code></td>
<td>
<p>the value for p to use in the formula for phi_p</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Small values of phi_p tend to be associated with good performance on the
maximin distance criterion, i.e. with a larger minimum distance.
</p>
<p>small values of phi_p are associated with good performance on the
maximin distance criterion
</p>


<h3>Value</h3>

<p>both functions return a number
</p>
<p>a number
</p>


<h3>Author(s)</h3>

<p>Ulrike Groemping
</p>
<p>Ulrike Groemping
</p>


<h3>Examples</h3>

<pre><code class='language-R'>A &lt;- DoE.base::L25.5.6  ## levels 1:5 for each factor
phi_p(A)
mindist(A) # 5
A2 &lt;- phi_optimize(A)
phi_p(A2)     ## improved
mindist(A2)   ## 6, improved
A &lt;- DoE.base::L16.4.5  ## levels 1:4 for each factor
phi_p(A)
phi_p(A, dmethod="euclidean")
A2 &lt;- A
A2[,4] &lt;- c(2,4,3,1)[A[,4]]
phi_p(A2)
## Not run: 
  ## A2 has fewer minimal distances
  par(mfrow=c(2,1))
  hist(dist(A), xlim=c(2,6), ylim=c(0,40))
  hist(dist(A2), xlim=c(2,6), ylim=c(0,40))

## End(Not run)
</code></pre>

<hr>
<h2 id='print.SOA'>Print Methods</h2><span id='topic+print.SOA'></span><span id='topic+print.MDLE'></span><span id='topic+print.Spattern'></span><span id='topic+print.dim_wt_tab'></span>

<h3>Description</h3>

<p>Print Methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'SOA'
print(x, ...)

## S3 method for class 'MDLE'
print(x, ...)

## S3 method for class 'Spattern'
print(x, ...)

## S3 method for class 'dim_wt_tab'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="print.SOA_+3A_x">x</code></td>
<td>
<p>object to be printed (SOA, OSOA, MDLE, Spattern)</p>
</td></tr>
<tr><td><code id="print.SOA_+3A_...">...</code></td>
<td>
<p>further arguments for function <code>print</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>no value is returned
</p>


<h3>Examples</h3>

<pre><code class='language-R'>myOSOA &lt;- OSOAs_regular(s=3, k=3, optimize=FALSE)
myOSOA
str(myOSOA)  ## structure for comparison
Spat &lt;- Spattern(myOSOA, s=3)
dim_wt_tab(Spat)   ## print method prints NAs as .
print(dim_wt_tab(Spat), na.print=" ")
</code></pre>

<hr>
<h2 id='soa'>work horse function for SOAs</h2><span id='topic+soa'></span>

<h3>Description</h3>

<p>work horse function for SOAs
</p>


<h3>Usage</h3>

<pre><code class='language-R'>soa(oa, t = 3, m = NULL, permlist = NULL, random = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="soa_+3A_oa">oa</code></td>
<td>
<p>matrix or data.frame that contains an ingoing symmetric OA. Levels must be denoted as 0 to s-1 or as 1 to s.</p>
</td></tr>
<tr><td><code id="soa_+3A_t">t</code></td>
<td>
<p>the strength the SOA should have, can be 2, 3, 4, or 5. Must not
be larger than the strength of <code>oa</code>, but can be smaller. The resulting SOA will have s^t levels</p>
</td></tr>
<tr><td><code id="soa_+3A_m">m</code></td>
<td>
<p>the requested number of columns (see details for permitted numbers of columns)</p>
</td></tr>
<tr><td><code id="soa_+3A_permlist">permlist</code></td>
<td>
<p>list of lists of permutations</p>
</td></tr>
<tr><td><code id="soa_+3A_random">random</code></td>
<td>
<p>logical</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function is the workhorse function for function <code><a href="#topic+SOAs">SOAs</a></code>.
</p>


<h3>Value</h3>

<p>a matrix
</p>

<hr>
<h2 id='SOAs'>function to create SOAs of strength t with the GOA construction by He and Tang.</h2><span id='topic+SOAs'></span>

<h3>Description</h3>

<p>takes an OA(n,m,s,t) and creates an SOA(n,m',s^t',t') with t'&lt;=t.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SOAs(
  oa,
  t = 3,
  m = NULL,
  noptim.rounds = 1,
  noptim.repeats = 1,
  optimize = TRUE,
  dmethod = "manhattan",
  p = 50
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SOAs_+3A_oa">oa</code></td>
<td>
<p>matrix or data.frame that contains an ingoing symmetric OA. Levels must be denoted as 0 to s-1 or as 1 to s.</p>
</td></tr>
<tr><td><code id="SOAs_+3A_t">t</code></td>
<td>
<p>the strength the SOA should have, can be 2, 3, 4, or 5. Must not
be larger than the strength of <code>oa</code>, but can be smaller. The resulting SOA will have s^t levels</p>
</td></tr>
<tr><td><code id="SOAs_+3A_m">m</code></td>
<td>
<p>the requested number of columns (see details for permitted numbers of columns)</p>
</td></tr>
<tr><td><code id="SOAs_+3A_noptim.rounds">noptim.rounds</code></td>
<td>
<p>the number of optimization rounds for each independent restart</p>
</td></tr>
<tr><td><code id="SOAs_+3A_noptim.repeats">noptim.repeats</code></td>
<td>
<p>the number of independent restarts of optimizations with <code>noptim.rounds</code> rounds each</p>
</td></tr>
<tr><td><code id="SOAs_+3A_optimize">optimize</code></td>
<td>
<p>logical, default <code>TRUE</code>; if <code>FALSE</code>, suppresses optimization</p>
</td></tr>
<tr><td><code id="SOAs_+3A_dmethod">dmethod</code></td>
<td>
<p>method for the calculation of <code><a href="#topic+phi_p">phi_p</a></code>, &quot;manhattan&quot; (default) or &quot;euclidean&quot;</p>
</td></tr>
<tr><td><code id="SOAs_+3A_p">p</code></td>
<td>
<p>p for <code><a href="#topic+phi_p">phi_p</a></code> (the larger, the closer to maximin distance)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The resulting SOA will have at most m' columns in s^t levels and will be of
strength t. m'(m, t) is a function of the number of columns of <code>oa</code>
(denoted as m) and the strength t: m'(m,2)=m, m'(m,3)=m-1, m'(m,4)=floor(m/2),
m'(m,5)=floor((m-1)/2).
</p>
<p>Suitable OAs for argument <code>oa</code> can e.g. be constructed with OA creation functions
from package <span class="pkg">lhs</span> or can be obtained from arrays listed in R package <span class="pkg">DoE.base</span>.
</p>


<h3>Value</h3>

<p>matrix of class <code>SOA</code> with the attributes that are listed below. All attributes can be accessed using function <code><a href="base.html#topic+attributes">attributes</a></code>, or individual attributes can be accessed using function <code><a href="base.html#topic+attr">attr</a></code>. These are the attributes:
</p>

<dl>
<dt>type</dt><dd><p>the type of array (<code>SOA</code> or <code>OSOA</code>)</p>
</dd>
<dt>strength</dt><dd><p>character string that gives the strength</p>
</dd>
<dt>phi_p</dt><dd><p>the phi_p value (smaller=better)</p>
</dd>
<dt>optimized</dt><dd><p>logical indicating whether optimization was applied</p>
</dd>
<dt>permpick</dt><dd><p>matrix that lists the id numbers of the permutations used</p>
</dd>
<dt>perms2pickfrom</dt><dd><p>optional element, when optimization was conducted: the
overall permutation list to which the numbers in permlist refer</p>
</dd>
<dt>call</dt><dd><p>the call that created the object</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ulrike Groemping
</p>


<h3>References</h3>

<p>For full detail, see <code><a href="#topic+SOAs-package">SOAs-package</a></code>.
</p>
<p>He and Tang (2013)<br />
Weng (2014)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>aus &lt;- SOAs(DoE.base::L27.3.4, optimize=FALSE)  ## t=3 is the default
dim(aus)
soacheck2D(aus, s=3, el=3) ## check for 2*
soacheck3D(aus, s=3, el=3) ## check for 3

aus2 &lt;- SOAs(DoE.base::L27.3.4, t=2, optimize=FALSE)
## t can be smaller than the array strength
##     --&gt; more columns with fewer levels each
dim(aus2)
soacheck2D(aus2, s=3, el=2, t=2) # check for 2
soacheck3D(aus2, s=3, el=2)      # t=3 is the default (check for 3-)
</code></pre>

<hr>
<h2 id='SOAs_8level'>Function to create 8-level SOAs according to Shi and Tang 2020</h2><span id='topic+SOAs_8level'></span>

<h3>Description</h3>

<p>creates strength 3 or 3+ SOAs with 8-level factors in 2^k runs, k at least 4.
These SOAs have at least some more balance than guaranteed by strength 3.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SOAs_8level(
  n,
  m = NULL,
  constr = "ShiTang_alphabeta",
  noptim.rounds = 1,
  noptim.repeats = 1,
  optimize = TRUE,
  dmethod = "manhattan",
  p = 50
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SOAs_8level_+3A_n">n</code></td>
<td>
<p>run size of the SOA; power of 2, at least 16</p>
</td></tr>
<tr><td><code id="SOAs_8level_+3A_m">m</code></td>
<td>
<p>number of colums; at most 5<code>n</code>/16 for <code>constr="ShiTang_alpha"</code> (exception: only 9 for <code>n</code>=32),
at most <code>n/4</code> for <code>constr="ShiTang_alphabeta"</code>; for <code>m=NULL</code>,
defaults are <code>m=5n/16</code> and <code>m=n/4-1</code>, respectively; the latter yields
strength 3+.</p>
</td></tr>
<tr><td><code id="SOAs_8level_+3A_constr">constr</code></td>
<td>
<p>construction method.  Must be one of <code>"ShiTang_alphabeta", "ShiTang_alpha"</code>.
See Details section</p>
</td></tr>
<tr><td><code id="SOAs_8level_+3A_noptim.rounds">noptim.rounds</code></td>
<td>
<p>the number of optimization rounds for each independent restart</p>
</td></tr>
<tr><td><code id="SOAs_8level_+3A_noptim.repeats">noptim.repeats</code></td>
<td>
<p>the number of independent restarts of optimizations with <code>noptim.rounds</code> rounds each</p>
</td></tr>
<tr><td><code id="SOAs_8level_+3A_optimize">optimize</code></td>
<td>
<p>logical: should space filling be optimized by level permutations?</p>
</td></tr>
<tr><td><code id="SOAs_8level_+3A_dmethod">dmethod</code></td>
<td>
<p>distance method for <code><a href="#topic+phi_p">phi_p</a></code>, &quot;manhattan&quot; (default) or &quot;euclidean&quot;</p>
</td></tr>
<tr><td><code id="SOAs_8level_+3A_p">p</code></td>
<td>
<p>p for <code><a href="#topic+phi_p">phi_p</a></code> (the larger, the closer to maximin distance)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The construction is implemented as described in Groemping (2023a).
</p>
<p>The 8-level SOAs created by this construction have strength 3 and at least
the additional property alpha, which means that all pairs of columns achieve
perfect 4x4 balance, if consecutive level pairs (01, 23, 45, 67) are collapsed.
</p>
<p>The &quot;ShiTang_alphabeta&quot; construction additionally yields perfect 4x2x2 balance,
if one column is collapsed to 4 levels, while two further columns are collapsed
to 2 levels (0123 vs 4567). with m = n/4 columns, the &quot;ShiTang_alphabeta&quot;
construction has a single pair of correlated columns, all other columns are
uncorrelated, due to a modification of Shi and Tang's column allocation that was
proposed in Groemping (2023a).
</p>
<p>For m &lt;= n/4 - 1, the &quot;ShiTang_alphabeta&quot; construction also yields perfect balance for
8x2 projections in 2D (i.e. if one original column with another column collapsed
to two levels).
Thus, it yields all strength 4 properties in 2D and 3D, which is called
strength 3+. Furthermore, Groemping (2023a) proposed an improved choice of columns
for matrix C that implies orthogonal columns in this case.
</p>


<h3>Value</h3>

<p>matrix of class <code>SOA</code> with the attributes that are listed below. All attributes can be accessed using function <code><a href="base.html#topic+attributes">attributes</a></code>, or individual attributes can be accessed using function <code><a href="base.html#topic+attr">attr</a></code>. These are the attributes:
</p>

<dl>
<dt>type</dt><dd><p>the type of array (<code>SOA</code> or <code>OSOA</code>)</p>
</dd>
<dt>strength</dt><dd><p>character string that gives the strength</p>
</dd>
<dt>phi_p</dt><dd><p>the phi_p value (smaller=better)</p>
</dd>
<dt>optimized</dt><dd><p>logical indicating whether optimization was applied</p>
</dd>
<dt>permpick</dt><dd><p>matrix that lists the id numbers of the permutations used</p>
</dd>
<dt>perms2pickfrom</dt><dd><p>optional element, when optimization was conducted: the
overall permutation list to which the numbers in permlist refer</p>
</dd>
<dt>call</dt><dd><p>the call that created the object</p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Ulrike Groemping
</p>


<h3>References</h3>

<p>For full detail, see <code><a href="#topic+SOAs-package">SOAs-package</a></code>.
</p>
<p>Groemping (2023a)<br />
Shi and Tang (2020)<br />
Weng (2014)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## use with optimization for actually using such designs
## n/4 - 1 = 7 columns, strength 3+
SOAs_8level(32, optimize=FALSE)

## n/4 = 8 columns, strength 3 with alpha and beta
SOAs_8level(32, m=8, optimize=FALSE)

## 9 columns (special case n=32), strength 3 with alpha
SOAs_8level(32, constr="ShiTang_alpha", optimize=FALSE)

## 5*n/16 = 5 columns, strength 3 with alpha
SOAs_8level(16, constr="ShiTang_alpha", optimize=FALSE)

</code></pre>

<hr>
<h2 id='SOAs-package'>Creation of Stratum (aka Strong) Orthogonal Arrays</h2><span id='topic+SOAs-package'></span><span id='topic+_PACKAGE'></span><span id='topic++27SOAs-package+27'></span>

<h3>Description</h3>

<p>Creates stratum orthogonal arrays (also known as strong orthogonal arrays).
</p>


<h3>Details</h3>

<p>This package constructs arrays in <code class="reqn">s^{el}</code> levels from orthogonal arrays in s levels.
These are all based on equations of the type
</p>
<p style="text-align: center;"><code class="reqn">D = s^{el-1} A_1 + ... + s A_{el-1} + A_{el},</code>
</p>

<p>or for <code class="reqn">s^2</code> levels, </p>
<p style="text-align: center;"><code class="reqn">D = s A + B</code>
</p>

<p>and for <code class="reqn">s^3</code> levels, </p>
<p style="text-align: center;"><code class="reqn">D = s^2 A + s B + C.</code>
</p>

<p>The constructions differ in how they obtain the ingredient matrices, and what properties can be guaranteed for the resulting D.
Where a construction function guarantees orthogonal columns for all matrices D it produces, its name starts with a OSOA, otherwise with SOA.<br />
</p>
<p>If optimization is requested (default TRUE), space filling properties of D are improved using a level permutation algorithm
by Weng (2014). This algorithm is applied for improving the <code><a href="#topic+phi_p">phi_p</a></code>
criterion, which is often a reasonable surrogate for increasing the minimum distance.
</p>
<p>Groemping (2023a) describes the constructions by He and Tang (2013, function <code><a href="#topic+SOAs">SOAs</a></code>),
Liu and Liu (2015, function <code><a href="#topic+OSOAs_LiuLiu">OSOAs_LiuLiu</a></code>), He, Cheng and Tang (2018, function <code><a href="#topic+SOAs2plus_regular">SOAs2plus_regular</a></code>),
Zhou and Tang (2019), Shi and Tang (2020, function <code><a href="#topic+SOAs_8level">SOAs_8level</a></code>) and Li, Liu and Yang (2021) in unified notation.
The constructions by Zhou and Tang (2019) and Li et al. (2021) are very close to each other and are both implemented
in the three functions <code><a href="#topic+OSOAs">OSOAs</a></code>, <code><a href="#topic+OSOAs_hadamard">OSOAs_hadamard</a></code> and <code><a href="#topic+OSOAs_regular">OSOAs_regular</a></code>.
</p>
<p>Within the package, available SOA constructions for specific situations can be queried using
the guide functions <code><a href="#topic+guide_SOAs">guide_SOAs</a></code> and <code><a href="#topic+guide_SOAs_from_OA">guide_SOAs_from_OA</a></code>.
</p>
<p>Besides the construction functions, properties of the resulting array D can be checked using the aforementioned function
<code><a href="#topic+phi_p">phi_p</a></code> as well as check functions <code><a href="#topic+ocheck">ocheck</a></code>, <code><a href="#topic+ocheck3">ocheck3</a></code> for orthogonality and
<code><a href="#topic+soacheck2D">soacheck2D</a></code>, <code><a href="#topic+soacheck3D">soacheck3D</a></code> for (O)SOA stratification properties, and
<code><a href="#topic+Spattern">Spattern</a></code> for the space-filling pattern proposed by Tian and Xu (2022); the implementation
of the latter will presumably become more important than the
2D and 3D check functions eventually.
</p>
<p>There is one further construction, maximin distance level expansion (<code><a href="#topic+XiaoXuMDLE">XiaoXuMDLE</a></code>, <code><a href="#topic+MDLEs">MDLEs</a></code>),
that does not yield stratum (aka strong) orthogonal arrays and is available for comparison only (Xiao and Xu 2018).
</p>


<h3>Author(s)</h3>

<p>Author: Ulrike Groemping, BHT Berlin. Contributor: Rob Carnell.
</p>


<h3>References</h3>

<p>Groemping, U. (2022). Implementation of the stratification pattern by Tian and Xu via power coding. Report 2022/03, Reports in Mathematics, Physics and Chemistry, Berliner Hochschule fuer Technik. <a href="http://www1.bht-berlin.de/FB_II/reports/Report-2022-003.pdf">http://www1.bht-berlin.de/FB_II/reports/Report-2022-003.pdf</a>
</p>
<p>Groemping, U. (2023a). A unifying implementation of stratum (aka strong) orthogonal arrays. <em>Computational Statistics and Data Analysis</em> <b>183</b>, 1-28. doi: <a href="https://doi.org/10.1016/j.csda.2023.107739">10.1016/j.csda.2023.107739</a>
</p>
<p>Groemping, U. (2023b). Implementating the stratification pattern for space-filling, with dimension by weight tables. Report 2023/01, Reports in Mathematics, Physics and Chemistry, Berliner Hochschule fuer Technik. <a href="http://www1.bht-berlin.de/FB_II/reports/Report-2023-001.pdf">http://www1.bht-berlin.de/FB_II/reports/Report-2023-001.pdf</a>
</p>
<p>He, Y., Cheng, C.S. and Tang, B. (2018). Strong orthogonal arrays of strength two plus. <em>The Annals of Statistics</em> <b>46</b>, 457-468. doi: <a href="https://doi.org/10.1214/17-AOS1555">10.1214/17-AOS1555</a>
</p>
<p>He, Y. and Tang, B. (2013). Strong orthogonal arrays and associated Latin hypercubes for computer experiments. <em>Biometrika</em> <b>100</b>, 254-260. doi: <a href="https://doi.org/10.1093/biomet/ass065">10.1093/biomet/ass065</a>
</p>
<p>Li, W., Liu, M.-Q. and Yang, J.-F. (2021). Construction of column-orthogonal strong orthogonal arrays. <em>Statistical Papers</em> doi: <a href="https://doi.org/10.1007/s00362-021-01249-w">10.1007/s00362-021-01249-w</a>.
</p>
<p>Liu, H. and Liu, M.-Q. (2015). Column-orthogonal strong orthogonal arrays and sliced strong orthogonal arrays. <em>Statistica Sinica</em> <strong>25</strong>, 1713-1734. doi: <a href="https://doi.org/10.5705/ss.2014.106">10.5705/ss.2014.106</a>
</p>
<p>Shi, L. and Tang, B. (2020). Construction results for strong orthogonal arrays of strength three. <em>Bernoulli</em> <strong>26</strong>, 418-431. doi: <a href="https://doi.org/10.3150/19-BEJ1130">10.3150/19-BEJ1130</a>
</p>
<p>Tian, Y. and Xu, H. (2022). A minimum aberration-type criterion for selecting space-filling designs. <em>Biometrika</em> <strong>109</strong>, 489-501. doi: <a href="https://doi.org/10.1093/biomet/asab021">10.1093/biomet/asab021</a>
</p>
<p>Weng, J. (2014). Maximin Strong Orthognal Arrays. <em>Master's thesis</em> at Simon Fraser University under supervision of Boxin Tang and Jiguo Cao. <a href="https://summit.sfu.ca/item/14433">https://summit.sfu.ca/item/14433</a>
</p>
<p>Xiao, Q. and Xu, H.  (2018). Construction of Maximin Distance Designs via Level Permutation and Expansion. <em>Statistica Sinica</em> <b>28</b>,
1395-1414. doi: <a href="https://doi.org/10.5705/ss.202016.0423">10.5705/ss.202016.0423</a>
</p>
<p>Zhou, Y.D. and Tang, B. (2019). Column-orthogonal strong orthogonal arrays of strength two plus and three minus. <em>Biometrika</em> <strong>106</strong>, 997-1004. doi: <a href="https://doi.org/10.1093/biomet/asz043">10.1093/biomet/asz043</a>
</p>


<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/bertcarnell/SOAs">https://github.com/bertcarnell/SOAs</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/bertcarnell/SOAs/issues">https://github.com/bertcarnell/SOAs/issues</a>
</p>
</li></ul>


<hr>
<h2 id='SOAs2plus_regular'>function to create SOAs of strength 2+ from regular s-level designs</h2><span id='topic+SOAs2plus_regular'></span>

<h3>Description</h3>

<p>creates an array in s^k runs with columns in s^2 levels for prime or prime power s
</p>


<h3>Usage</h3>

<pre><code class='language-R'>SOAs2plus_regular(
  s,
  k,
  m = NULL,
  orth = TRUE,
  old = FALSE,
  noptim.rounds = 1,
  noptim.repeats = 1,
  optimize = TRUE,
  dmethod = "manhattan",
  p = 50
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="SOAs2plus_regular_+3A_s">s</code></td>
<td>
<p>prime or prime power</p>
</td></tr>
<tr><td><code id="SOAs2plus_regular_+3A_k">k</code></td>
<td>
<p>array will have n=s^k runs; for s=2, k&gt;=4 is needed, for s&gt;2, k&gt;=3 is sufficient</p>
</td></tr>
<tr><td><code id="SOAs2plus_regular_+3A_m">m</code></td>
<td>
<p>optional integer: number of columns requested; if <code>NULL</code>,
the maximum possible number of columns is created, which is (s^k-1)/(s-1) - ((s-1)^k-1)/(s-2)
for s&gt;2 and s^k-s^k1 - s^(k-k1) + 2, with k1=floor(k/2), for s=2; specifying a
smaller m is beneficial not only for run time but also for possibly achieving a
column-orthogonal array (see Details section)</p>
</td></tr>
<tr><td><code id="SOAs2plus_regular_+3A_orth">orth</code></td>
<td>
<p>logical: if FALSE, suppresses attempts for orthogonal columns and selects the first permissible column for each column of B (see Details section)</p>
</td></tr>
<tr><td><code id="SOAs2plus_regular_+3A_old">old</code></td>
<td>
<p>logical, relevant for <code>orth=TRUE</code> only: if TRUE, limits possible columns for B to the columns not eligible for A (instead of the columns not used in A); should only be used for reproducing designs created by version 1.1 or earlier</p>
</td></tr>
<tr><td><code id="SOAs2plus_regular_+3A_noptim.rounds">noptim.rounds</code></td>
<td>
<p>the number of optimization rounds for each independent restart</p>
</td></tr>
<tr><td><code id="SOAs2plus_regular_+3A_noptim.repeats">noptim.repeats</code></td>
<td>
<p>the number of independent restarts of optimizations with <code>noptim.rounds</code> rounds each</p>
</td></tr>
<tr><td><code id="SOAs2plus_regular_+3A_optimize">optimize</code></td>
<td>
<p>logical: should optimization be applied? default <code>TRUE</code></p>
</td></tr>
<tr><td><code id="SOAs2plus_regular_+3A_dmethod">dmethod</code></td>
<td>
<p>method for the distance in <code><a href="#topic+phi_p">phi_p</a></code>, &quot;manhattan&quot; (default) or &quot;euclidean&quot;</p>
</td></tr>
<tr><td><code id="SOAs2plus_regular_+3A_p">p</code></td>
<td>
<p>p for <code><a href="#topic+phi_p">phi_p</a></code> (the larger, the closer to maximin distance)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The construction is by He, Cheng and Tang (2018), Prop.1 (C2) / Theorem 2
for s=2 and Theorem 4 for s&gt;2. <br />
B is chosen as an OA of strength 2, if possible, which yields orthogonal
columns according to Zhou and Tang (2019). This is implemented using a matching
algorithm for bipartite graphs from package <span class="pkg">igraph</span>; the smaller m, the
more likely that orthogonality can be achieved. However, strength 2+ SOAs are
not usually advisable for m small enough that a strength 3 OA exists.<br />
Optimization according to Weng has been added (separate level permutations
in columns of A and B, <code>noptim.rounds</code> times). Limited tests suggest
that a single round (<code>noptim.rounds=1</code>) often does a very good job
(e.g. for s=2 and k=4), and
further rounds do not yield too much improvement; there are also cases
(e.g. s=5 with k=3), for which the unoptimized array has a better phi_p than
what can be achieved by most optimization attempts from a random start.
</p>
<p>The search for orthogonal columns can take a long time for larger arrays,
even without optimization. If this is prohibitive (or not considered valuable),
<code>orth=FALSE</code> causes the function to create the matrix B for equation D=2A+B
with less computational effort.<br />
The subsequent optimization, if not switched off,
is of the same complexity, regardless of the value for <code>orth</code>. Its
duration heavily depends on the number of optimization steps that are needed
before the algorithm stops. This has not been systematically investigated;
cases for which the total run time with optimization
is shorter for <code>orth=TRUE</code> than for <code>orth=FALSE</code> have been observed.
</p>
<p>With package version 1.2, the creation of SOAs has changed: Up to version 1.1,
the columns of B were chosen only from those columns that were <em>not eligible</em> for A,
whereas the new version chooses them from those columns that are <em>not used</em> for A.
This increases the chance to achieve geometrically orthogonal columns.<br />
Users who want to reproduce a design from an earlier version
can use argument <code>old</code>.
</p>


<h3>Value</h3>

<p>matrix of class <code>SOA</code> with the attributes that are listed below. All attributes can be accessed using function <code><a href="base.html#topic+attributes">attributes</a></code>, or individual attributes can be accessed using function <code><a href="base.html#topic+attr">attr</a></code>. These are the attributes:
</p>

<dl>
<dt>type</dt><dd><p>the type of array (<code>SOA</code> or <code>OSOA</code>)</p>
</dd>
<dt>strength</dt><dd><p>character string that gives the strength</p>
</dd>
<dt>phi_p</dt><dd><p>the phi_p value (smaller=better)</p>
</dd>
<dt>optimized</dt><dd><p>logical indicating whether optimization was applied</p>
</dd>
<dt>permpick</dt><dd><p>matrix that lists the id numbers of the permutations used</p>
</dd>
<dt>perms2pickfrom</dt><dd><p>optional element, when optimization was conducted: the
overall permutation list to which the numbers in permlist refer</p>
</dd>
<dt>call</dt><dd><p>the call that created the object</p>
</dd>
</dl>



<h3>Note</h3>

<p>Strength 2+ SOAs can accommodate a large number of factors with
reasonable stratified balance behavior. Note that their use is not usually
advisable for m small enough that a strength 3 OA with s^2 level factors exists.
</p>


<h3>Author(s)</h3>

<p>Ulrike Groemping
</p>


<h3>References</h3>

<p>For full detail, see <code><a href="#topic+SOAs-package">SOAs-package</a></code>.
</p>
<p>Groemping (2023a)
He, Cheng and Tang (2018)<br />
Weng (2014)<br />
Zhou and Tang (2019)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
## unoptimized OSOA with 8 16-level columns in 64 runs
## (maximum possible number of columns)
plan64 &lt;- SOAs2plus_regular(4, 3, optimize=FALSE)
ocheck(plan64)   ## the array has orthogonal columns

## optimized SOA with 20 9-level columns in 81 runs
## (up to 25 columns are possible)
plan &lt;- SOAs2plus_regular(3, 4, 20)
## many column pairs have only 27 level pairs covered
count_npairs(plan)
## an OA would exist for 10 9-level factors (DoE.base::L81.9.10)
## it would cover all pairs
## (SOAs are not for situations for which pair coverage
## is of primary interest)

</code></pre>

<hr>
<h2 id='Spattern'>functions to evaluate stratification properties of (O)SOAs and GSOAs</h2><span id='topic+Spattern'></span><span id='topic+dim_wt_tab'></span><span id='topic+soacheck2D'></span><span id='topic+soacheck3D'></span>

<h3>Description</h3>

<p><code>soacheck2D</code> and <code>soacheck3D</code> evaluate 2D and 3D projections,
<code>Spattern</code> calculates the stratification pattern by Tian and Xu (2022),
and <code>dim_wt_tab</code> extracts and formats the <code>dim_wt_tab</code> attribute of <code>Spattern</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Spattern(D, s, maxwt = 4, maxdim = NULL, verbose = FALSE, ...)

dim_wt_tab(pat, dimlim = NULL, wtlim = NULL, ...)

soacheck2D(D, s = 3, el = 3, t = 3, verbose = FALSE)

soacheck3D(D, s = 3, el = 3, t = 3, verbose = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Spattern_+3A_d">D</code></td>
<td>
<p>a matrix with factor levels or an object of class <code>SOA</code> or a
data.frame object with numeric columns.<br />
Functions <code>soacheck2D</code> and <code>soacheck3D</code> require levels
that are consecutively numbered (starting with 0 or 1).<br />
Function <code>Spattern</code> also works, if all columns of <code>D</code>
have the same number of unique numeric values; the function will code them using
power contrasts.</p>
</td></tr>
<tr><td><code id="Spattern_+3A_s">s</code></td>
<td>
<p>the prime or prime power according to which the array is checked</p>
</td></tr>
<tr><td><code id="Spattern_+3A_maxwt">maxwt</code></td>
<td>
<p>maximum weight to be considered for the pattern (default: 4; see Details);<br />
if the specified limit is larger than <code>maxdim*el</code>,
it is reduced accordingly (where <code>el</code> is such that <code>s^el</code> is the number of levels)</p>
</td></tr>
<tr><td><code id="Spattern_+3A_maxdim">maxdim</code></td>
<td>
<p>maximum dimension to be considered for the pattern (default: <code>NULL</code> implies that <code>maxdim</code>=<code>min(maxwt, ncol(D))</code>;
see also Details);<br />
if the specified limit is larger than <code>m=ncol(D)</code>, it is reduced to <code>m</code></p>
</td></tr>
<tr><td><code id="Spattern_+3A_verbose">verbose</code></td>
<td>
<p>logical; if <code>TRUE</code>, additional information is printed
(for <code>Spattern</code>, status information during run time; for the <code>SOAcheck...</code> functions, confounded pair or triple projections with A2 or A3, respectively, or table of correlations)</p>
</td></tr>
<tr><td><code id="Spattern_+3A_...">...</code></td>
<td>
<p>currently not used</p>
</td></tr>
<tr><td><code id="Spattern_+3A_pat">pat</code></td>
<td>
<p>an object of class <code>Spattern</code></p>
</td></tr>
<tr><td><code id="Spattern_+3A_dimlim">dimlim</code></td>
<td>
<p>integer; limits the returned dimension rows to the
rows from 1 up to <code>dimlim</code>; the bottom margin continues to include all
dimensions that were used in calculating <code>pat</code></p>
</td></tr>
<tr><td><code id="Spattern_+3A_wtlim">wtlim</code></td>
<td>
<p>integer; limits the returned weight columns to the columns from
1 up to <code>wtlim</code>; the right margin continues to include all weights
that were used in calculating <code>pat</code></p>
</td></tr>
<tr><td><code id="Spattern_+3A_el">el</code></td>
<td>
<p>the exponent so that the number of levels of the array is <code>s^el</code>
(if <code>s</code> is not NULL)</p>
</td></tr>
<tr><td><code id="Spattern_+3A_t">t</code></td>
<td>
<p>the strength for which to look (2, 3, or 4), equal to the sum of the
exponents in the stratification dimensions; for example, <code>soacheck2D</code> considers <br />
sxs 2D projections with <code>t=2</code>, <br />
s^2xs and sxs^2 projections with <code>t=3</code>, <br />
and s^3xs, s^2xs^2 and sxs^3 projections with <code>t=4</code>.<br />
If <code>t=4</code> and <code>el=2</code>, property gamma (s^3 x s and s x s^3) is obviously
impossible and will not be part of the checks.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Function <code>Spattern</code> calculates the stratification pattern or S pattern
as proposed in Tian and Xu (2022) (under the name space-filling pattern);
the details and the implementation in this function are described in
Groemping (2023b); the function uses the full-factorial-based Helmert contrasts.<br />
Position <code>j</code> in the S pattern shows the imbalance when considering <code>s^j</code>
strata. <code>j</code> is also called the (total) weight. <code>j=1</code> can occur for an
individual column only. <code>j=2</code> can be obtained either for an
<code>s^2</code> level version of an individual column or for the crossing of
<code>s^1</code> level versions of two columns, and so forth.
</p>
<p>Obtaining the entire S pattern
can be computationally demanding. The arguments <code>maxwt</code> and
<code>maxdim</code> limit the effort (choose <code>NULL</code> for no limit):<br />
<code>maxwt</code> gives an upper limit for the weight <code>j</code> of the previous paragraph;
if <code>NULL</code>, <code>maxwt</code> is set to <code>maxdim*el</code>.<br />
<code>maxdim</code> limits the number of columns that are considered in combination.<br />
When using a non-null <code>maxdim</code>, pattern entries for <code>j</code> larger than <code>maxdim</code> can be smaller
than if one would not have limited the dimension. Otherwise, dimensionality is unlimited,
which is equivalent to specifying <code>maxdim</code> as the minimum of <code>maxwt</code> and <code>ncol(D)</code>.
</p>
<p><code>Spattern</code> with <code>maxdim=2</code> and <code>maxwt=t</code> can be used as an alternative
to <code>soacheck2D</code>,<br />
and analogously <code>Spattern</code> with <code>maxdim=2</code> and <code>maxwt=t</code> can be used as an alternative
to <code>soacheck3D</code>.
</p>
<p>An <code>Spattern</code> object
object can be post-processed with function <code>dim_wt_tab</code>. That function splits
the S pattern into contributions from effect column groups of different dimensions,
arranged with a row for each dimension and a column for each weight.
If <code>Spattern</code> was called with <code>maxdim=NULL</code> and
<code>maxwt=NULL</code>, the output object shows the GWLP in the right margin and the
S pattern in the bottom margin. If <code>Spattern</code> was called with relevant restrictions
on dimensions (<code>maxdim</code>, default 4) and/or weights (<code>maxwt</code>, default 4),
sums in the margins can be smaller than they would be for unconstrained dimension and
weights.
</p>
<p>Functions <code>soacheck2D</code> and <code>soacheck3D</code> were available before
function <code>Spattern</code>; many of their use cases can now be handled with <code>Spattern</code>
instead. The functions are often fast to yield a <code>FALSE</code> outcome,
but can be very slow to yield a <code>TRUE</code> outcome for larger designs.<br />
The functions inspect 2D and 3D
stratification, respectively. Each column must have <code>s^el</code> levels.
<code>t</code> specifies the degree of balance the functions are asked to look for.
</p>
<p>Function <code>soacheck2D</code>,
</p>

<ul>
<li><p> with el=t=2, looks for strength 2 conditions (s^2 levels, sxs balance),
</p>
</li>
<li><p> with el=2, t=3, looks for strength 2+ / 3- conditions (s^2 levels, s^2xs balance),
</p>
</li>
<li><p> with el=t=3, looks for strength 2* / 3 conditions (s^3 levels, s^2xs balance).
</p>
</li>
<li><p> with el=2, t=4, looks for the enhanced strength 2+ / 3-  property alpha (s^2 levels, s^2xs^2 balance).
</p>
</li>
<li><p> and with el=3, t=4, looks for strength 3+ / 4 conditions (s^3 levels, s^3xs and s^2xs^2 balance).
</p>
</li></ul>

<p>Function <code>soacheck3D</code>,
</p>

<ul>
<li><p> with el=2, t=3, looks for strength 3- conditions (s^2 levels, sxsxs balance),
</p>
</li>
<li><p> with el=t=3, looks for strength 3 conditions (s^3 levels, sxsxs balance),
</p>
</li>
<li><p> and with el=3, t=4, looks for strength 3+ / 4 conditions (s^3 levels, s^2xsxs balance).
</p>
</li></ul>

<p>If <code>verbose=TRUE</code>, the functions print the pairs or triples that violate
the projection requirements for 2D or 3D.
</p>


<h3>Value</h3>

<p>Function <code>Spattern</code> returns an object of class <code>Spattern</code>
that is a named vector with attributes:<br />
The attribute <code>call</code> holds the function call
(and thus documents, e.g., limits set on dimension and/or weight).<br />
The attribute <code>dim_wt_tab</code> holds a table of contributions
split out by dimension (rows) and weights (columns), which has class
<code>dim_wt_tab</code> and the further attribute <code>Spattern-class</code>.<br />
Function <code>dim_wt_tab</code> returns the <code>dim_wt_tab</code> attribute of
an object of class <code>Spattern</code>; note that the object contains NA values
for combinations of dimension and weight that cannot occur.
</p>
<p>Function <code>dim_wt_tab</code> postprocesses an <code>Spattern</code> object
and produces a table that holds the S pattern entries
separated by the dimension of the contributing effect column group (rows)
and the weight of the effect column micro group (columns). The margin shows row and
column sums (see Details section for caveats).
</p>


<h3>References</h3>

<p>For full detail, see <code><a href="#topic+SOAs-package">SOAs-package</a></code>.
</p>
<p>Groemping (2023a)<br />
Groemping (2023b)<br />
He and Tang (2013)<br />
Shi and Tang (2020)<br />
Tian and Xu (2022)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>nullcase &lt;- matrix(0:7, nrow=8, ncol=4)
soacheck2D(nullcase, s=2)
soacheck3D(nullcase, s=2)
Spattern(nullcase, s=2)
Spattern(nullcase, s=2, maxdim=2)
  ## the non-zero entry at position 2 indicates that
  ## soacheck2D does not comply with t=2
(Spat &lt;- Spattern(nullcase, s=2, maxwt=4))
  ## comparison to maxdim=2 indicates that
  ## the contribution to S_4 from dimensions
  ## larger than 2 is 1
## postprocessing Spat
dim_wt_tab(Spat)

## Shi and Tang strength 3+ construction in 7 8-level factors for 32 runs
D &lt;- SOAs_8level(32, optimize=FALSE)

## check for strength 3+ (default el=3 is OK)
## 2D check
soacheck2D(D, s=2, t=4)
## 3D check
soacheck3D(D, s=2, t=4)
## using Spattern (much faster for many columns)
  ## does not have strength 4
  Spattern(D, s=2)
  ## but complies with strength 4 for dim up to 3
  Spattern(D, s=2, maxwt=4, maxdim=3)
  ## inspect more detail
  Spat &lt;- (Spattern(D, s = 2, maxwt=5))
  dim_wt_tab(Spat)
</code></pre>

<hr>
<h2 id='XiaoXuMDLE'>Implementation of the Xiao Xu TA algorithm
(experimental, for comparison with MDLEs only)</h2><span id='topic+XiaoXuMDLE'></span><span id='topic+createF'></span><span id='topic+optimize'></span>

<h3>Description</h3>

<p>Implementation of the Xiao Xu TA algorithm
(experimental, for comparison with MDLEs only)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>XiaoXuMDLE(
  oa,
  ell,
  noptim.oa = 1,
  nseq = 2000,
  nrounds = 50,
  nsteps = 3000,
  dmethod = "manhattan",
  p = 50
)

createF(Dc, Dp, s, ell, nseq = 2000)

optimize(
  Dc,
  s,
  ell,
  Fhat,
  nrounds = 50,
  nsteps = 3000,
  dmethod = "manhattan",
  p = 50
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="XiaoXuMDLE_+3A_oa">oa</code></td>
<td>
<p>matrix or data.frame that contains an ingoing symmetric OA. Levels must be denoted as 0 to s-1 or as 1 to s.</p>
</td></tr>
<tr><td><code id="XiaoXuMDLE_+3A_ell">ell</code></td>
<td>
<p>the multiplier for each number of levels</p>
</td></tr>
<tr><td><code id="XiaoXuMDLE_+3A_noptim.oa">noptim.oa</code></td>
<td>
<p>integer: number of optimization rounds applied to initial oa itself before starting expansion</p>
</td></tr>
<tr><td><code id="XiaoXuMDLE_+3A_nseq">nseq</code></td>
<td>
<p>tuning parameters for TA algorithm</p>
</td></tr>
<tr><td><code id="XiaoXuMDLE_+3A_nrounds">nrounds</code></td>
<td>
<p>tuning parameters for TA algorithm</p>
</td></tr>
<tr><td><code id="XiaoXuMDLE_+3A_nsteps">nsteps</code></td>
<td>
<p>tuning parameters for TA algorithm</p>
</td></tr>
<tr><td><code id="XiaoXuMDLE_+3A_dmethod">dmethod</code></td>
<td>
<p>distance method for <code><a href="#topic+phi_p">phi_p</a></code>, &quot;manhattan&quot; (default) or &quot;euclidean&quot;</p>
</td></tr>
<tr><td><code id="XiaoXuMDLE_+3A_p">p</code></td>
<td>
<p>p for <code><a href="#topic+phi_p">phi_p</a></code> (the larger, the closer to maximin distance)</p>
</td></tr>
<tr><td><code id="XiaoXuMDLE_+3A_dc">Dc</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="XiaoXuMDLE_+3A_dp">Dp</code></td>
<td>
<p>matrix</p>
</td></tr>
<tr><td><code id="XiaoXuMDLE_+3A_s">s</code></td>
<td>
<p>original number of levels</p>
</td></tr>
<tr><td><code id="XiaoXuMDLE_+3A_fhat">Fhat</code></td>
<td>
<p>distribution function (created with <code>createF</code>)</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The ingoing <code>oa</code> is optimized by function <code><a href="#topic+phi_optimize">phi_optimize</a></code>,
using <code>noptim.rounds=noptim.oa</code>; this yields the matrix <code>Dp</code> for use
in the internal functions <code><a href="#topic+DcFromDp">DcFromDp</a></code> and <code>createF</code>.<br />
Function <code>XiaoXuMDLE</code> returns the value
that is produced by applying the internal function <code>optimize</code>
to the resulting <code>Dc</code> and <code>F</code>.
</p>


<h3>Value</h3>

<p><code>XiaoXuMDLE</code> returns a matrix with attribute <code>phi_p</code>.
</p>
<p><code>createF</code> returns a distribution function.
</p>
<p><code>optimize</code> returns a matrix with attribute <code>phi_p</code>.
</p>


<h3>References</h3>

<p>For full detail, see <code><a href="#topic+SOAs-package">SOAs-package</a></code>.
</p>
<p>Xiao and Xu (2018)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## create 8-level columns from 4-level columns
XiaoXuMDLE(DoE.base::L16.4.5, 2, nrounds = 5, nsteps=50)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
