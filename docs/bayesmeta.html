<!DOCTYPE html><html><head><title>Help for package bayesmeta</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bayesmeta}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#bayesmeta-package'>
<p>Bayesian Random-Effects Meta-Analysis and Meta-Regression</p></a></li>
<li><a href='#BaetenEtAl2013'><p>Ankylosing spondylitis example data</p></a></li>
<li><a href='#bayesmeta'>
<p>Bayesian random-effects meta-analysis</p></a></li>
<li><a href='#bmr'>
<p>Bayesian random-effects meta-regression</p></a></li>
<li><a href='#BucherEtAl1997'><p>Direct and indirect comparison example data</p></a></li>
<li><a href='#Cochran1954'><p>Fly counts example data</p></a></li>
<li><a href='#convolve'><p>Convolution of two probability distributions</p></a></li>
<li><a href='#CrinsEtAl2014'><p>Pediatric liver transplant example data</p></a></li>
<li><a href='#dhalflogistic'><p>Half-logistic distribution.</p></a></li>
<li><a href='#dhalfnormal'><p>Half-normal, half-Student-t and half-Cauchy distributions.</p></a></li>
<li><a href='#dinvchi'><p>Inverse-Chi distribution.</p></a></li>
<li><a href='#dlomax'><p>The Lomax distribution.</p></a></li>
<li><a href='#drayleigh'><p>The Rayleigh distribution.</p></a></li>
<li><a href='#ess'>
<p>Effective sample size (ESS)</p></a></li>
<li><a href='#forest.bayesmeta'>
<p>Generate a forest plot for a <code>bayesmeta</code> object</p>
(based on the <code>metafor</code> package's plotting functions).</a></li>
<li><a href='#forestplot.bayesmeta'>
<p>Generate a forest plot for a <code>bayesmeta</code> object</p>
(based on the <code>forestplot</code> package's plotting functions).</a></li>
<li><a href='#forestplot.bmr'>
<p>Generate a forest plot for a <code>bmr</code> object</p>
(based on the <code>forestplot</code> package's plotting functions).</a></li>
<li><a href='#forestplot.escalc'>
<p>Generate a forest plot for an <code>escalc</code> object</p>
(based on the <code>forestplot</code> package's plotting functions).</a></li>
<li><a href='#funnel.bayesmeta'>
<p>Generate a funnel plot for a <code>bayesmeta</code> object.</p></a></li>
<li><a href='#GoralczykEtAl2011'><p>Liver transplant example data</p></a></li>
<li><a href='#HinksEtAl2010'><p>JIA example data</p></a></li>
<li><a href='#KarnerEtAl2014'><p>COPD example data</p></a></li>
<li><a href='#kldiv'><p>Kullback-Leibler divergence of two multivariate normal distributions.</p></a></li>
<li><a href='#NicholasEtAl2019'><p>Multiple sclerosis disability progression example data</p></a></li>
<li><a href='#normalmixture'>
<p>Compute normal mixtures</p></a></li>
<li><a href='#Peto1980'><p>Aspirin after myocardial infarction example data</p></a></li>
<li><a href='#plot.bayesmeta'>
<p>Generate summary plots for a <code>bayesmeta</code> object.</p></a></li>
<li><a href='#pppvalue'><p>Posterior predictive <code class="reqn">p</code>-values</p></a></li>
<li><a href='#RhodesEtAlPrior'><p>Heterogeneity priors for continuous outcomes (standardized mean</p>
differences) as proposed by Rhodes et al. (2015).</a></li>
<li><a href='#RobergeEtAl2017'><p>Aspirin during pregnancy example data</p></a></li>
<li><a href='#Rubin1981'><p>8-schools example data</p></a></li>
<li><a href='#SchmidliEtAl2017'><p>Historical variance example data</p></a></li>
<li><a href='#SidikJonkman2007'><p>Postoperative complication odds example data</p></a></li>
<li><a href='#SnedecorCochran'><p>Artificial insemination of cows example data</p></a></li>
<li><a href='#summary.bmr'>
<p>Summarizing a <code>bmr</code> object).</p></a></li>
<li><a href='#traceplot'>
<p>Illustrate conditional means of study-specific estimates as well as</p>
overall mean (or other linear combinations) as a function of
heterogeneity.</a></li>
<li><a href='#TurnerEtAlPrior'><p>(Log-Normal) heterogeneity priors for binary outcomes</p>
as proposed by Turner et al. (2015).</a></li>
<li><a href='#uisd'>
<p>Unit information standard deviation</p></a></li>
<li><a href='#weightsplot'>
<p>Illustrate the posterior mean weights for a <code>bayesmeta</code> object.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Bayesian Random-Effects Meta-Analysis and Meta-Regression</td>
</tr>
<tr>
<td>Version:</td>
<td>3.4</td>
</tr>
<tr>
<td>Date:</td>
<td>2024-02-15</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Christian Roever &lt;christian.roever@med.uni-goettingen.de&gt;</td>
</tr>
<tr>
<td>Depends:</td>
<td>forestplot (&ge; 2.0.0), metafor (&ge; 2.0-0), mvtnorm (&ge; 1.1-1),
numDeriv (&ge; 2016.8-1.1)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>compute.es, knitr, rmarkdown, R.rsp</td>
</tr>
<tr>
<td>Description:</td>
<td>A collection of functions allowing to derive the posterior distribution of the model parameters in random-effects meta-analysis or meta-regression, and providing functionality to evaluate joint and marginal posterior probability distributions, predictive distributions, shrinkage effects, posterior predictive p-values, etc.; For more details, see also Roever C (2020) &lt;<a href="https://doi.org/10.18637%2Fjss.v093.i06">doi:10.18637/jss.v093.i06</a>&gt;, or Roever C and Friede T (2022) &lt;<a href="https://doi.org/10.1016%2Fj.cmpb.2022.107303">doi:10.1016/j.cmpb.2022.107303</a>&gt;.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://gitlab.gwdg.de/croever/bayesmeta">https://gitlab.gwdg.de/croever/bayesmeta</a></td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr, R.rsp</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-02-15 17:06:35 UTC; christian</td>
</tr>
<tr>
<td>Author:</td>
<td>Christian Roever <a href="https://orcid.org/0000-0002-6911-698X"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Tim Friede <a href="https://orcid.org/0000-0001-5347-7441"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-02-15 18:10:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='bayesmeta-package'>
Bayesian Random-Effects Meta-Analysis and Meta-Regression
</h2><span id='topic+bayesmeta-package'></span>

<h3>Description</h3>

<p>A collection of functions allowing to derive the posterior
distribution of the model parameters in random-effects meta-analysis
or meta-regression, and providing functionality to evaluate joint and
marginal posterior probability distributions, predictive
distributions, shrinkage effects, posterior predictive p-values, etc.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
    Package: </td><td style="text-align: left;"> bayesmeta</td>
</tr>
<tr>
 <td style="text-align: left;">
    Type:    </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
    Version: </td><td style="text-align: left;"> 3.4</td>
</tr>
<tr>
 <td style="text-align: left;">
    Date:    </td><td style="text-align: left;"> 2024-02-15</td>
</tr>
<tr>
 <td style="text-align: left;">
    License: </td><td style="text-align: left;"> GPL (&gt;=2)
  </td>
</tr>

</table>

<p>The main functionality is provided by the <code><a href="#topic+bayesmeta">bayesmeta</a>()</code>
and <code><a href="#topic+bmr">bmr</a>()</code> function. It takes the data (estimates and
associated standard errors) and prior information (effect and
heterogeneity priors), and returns an object containing functions that
allow to derive posterior quantities like joint or marginal densities,
quantiles, etc. The <code><a href="#topic+bmr">bmr</a>()</code> function extends the approach
to meta-regression by allowing to specify covariables (moderators) in
addition.
</p>


<h3>Author(s)</h3>

<p>Christian Roever &lt;christian.roever@med.uni-goettingen.de&gt;
</p>


<h3>References</h3>

<p>C. Roever.
Bayesian random-effects meta-analysis using the bayesmeta R package.
<em>Journal of Statistical Software</em>, <b>93</b>(6):1-51, 2020.
<a href="https://doi.org/10.18637/jss.v093.i06">doi:10.18637/jss.v093.i06</a>.
</p>
<p>C. Roever, T. Friede.
Using the bayesmeta R package for Bayesian random-effects meta-regression.
<em>Computer Methods and Programs in Biomedicine</em>,
<b>299</b>:107303, 2023.
<a href="https://doi.org/10.1016/j.cmpb.2022.107303">doi:10.1016/j.cmpb.2022.107303</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+forestplot.bayesmeta">forestplot.bayesmeta</a></code>, <code><a href="#topic+plot.bayesmeta">plot.bayesmeta</a></code>,
<code><a href="#topic+bmr">bmr</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># example data by Snedecor and Cochran:
data("SnedecorCochran")

## Not run: 
# analysis using improper uniform prior
# (may take a few seconds to compute!):
bma &lt;- bayesmeta(y=SnedecorCochran[,"mean"],
                 sigma=sqrt(SnedecorCochran[,"var"]),
                 label=SnedecorCochran[,"no"])

# show some summary statistics:
bma

# show a bit more details:
summary(bma)

# show a forest plot:
forestplot(bma)

# show some more plots:
plot(bma)

## End(Not run)
</code></pre>

<hr>
<h2 id='BaetenEtAl2013'>Ankylosing spondylitis example data</h2><span id='topic+BaetenEtAl2013'></span>

<h3>Description</h3>

<p>Numbers of cases (patients) and events (responders)
in the placebo control groups of eight studies.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("BaetenEtAl2013")</code></pre>


<h3>Format</h3>

<p>The data frame contains the following columns:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <b>study</b>  </td><td style="text-align: left;"> <code>character</code> </td><td style="text-align: left;"> study label </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>year</b>   </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> publication year </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>events</b> </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of responders </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>total</b>  </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> total number of patients
  </td>
</tr>

</table>



<h3>Details</h3>

<p>A study was conducted in order to investigate a novel treatment
in ankylosing spondylitis (Baeten et al., 2013). The primary endpoint
related to <em>treatment response</em>. 
In order to formulate an informative prior distribution for the
response rate to be expected in the control group of the new study, a
systematic review of previous studies was consulted (McLeod et al.,
2007), and, after a meta-analysis of the estimated response
probabilities, the predictive distribution for the new study's
response probability was derived. The predictive distribution here
constitutes the <em>meta-analytic-predictive (MAP) prior</em>
distribution (Schmidli et al., 2014). The data set contains the
relevant data from the eight &ldquo;historical&rdquo; studies' placebo
groups.
</p>
<p>Note that the original analysis (Baeten et al., 2013) involved a
binomial model, and the resulting posterior predictive distribution
was eventually approximated by a mixture of beta distributions.
</p>


<h3>Source</h3>

<p>D. Baeten et al.
Anti-interleukin-17A monoclonal antibody secukinumab in treatment of
ankylosing spondylitis: a randomised, double-blind, placebo-controlled
trial.
<em>The Lancet</em>, <b>382</b>(9906):1705-1713, 2013.
<a href="https://doi.org/10.1016/S0140-6736%2813%2961134-4">doi:10.1016/S0140-6736(13)61134-4</a>.
</p>


<h3>References</h3>

<p>C. McLeod et al.
Adalimumab, etanercept, and infliximab for the treatment of ankylosing
spondylitis: a systematic review and economic evaluation.
<em>Health Technology Assessment</em>, <b>11</b>(28), 2007.
<a href="https://doi.org/10.3310/hta11280">doi:10.3310/hta11280</a>.
</p>
<p>H. Schmidli, S. Gsteiger, S. Roychoudhury, A. O'Hagan,
D. Spiegelhalter, B. Neuenschwander.
Robust meta-analytic-predictive priors in clinical trials with
historical control information.
<em>Biometrics</em>, <b>70</b>(4):1023-1032, 2014.
<a href="https://doi.org/10.1111/biom.12242">doi:10.1111/biom.12242</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+uisd">uisd</a></code>, <code><a href="#topic+ess">ess</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data:
data("BaetenEtAl2013")

# show data:
BaetenEtAl2013

## Not run: 
# compute effect sizes (logarithmic odds) from the count data:
as &lt;- escalc(xi=events, ni=total, slab=study,
             measure="PLO", data=BaetenEtAl2013)

# compute the unit information standard deviation (UISD):
uisd(as)

# perform meta-analysis
# (using uniform priors for effect and heterogeneity):
bm &lt;- bayesmeta(as)

# show results (log-odds):
forestplot(bm, xlab="log-odds", zero=NA)
# show results (odds):
forestplot(bm, exponentiate=TRUE, xlab="odds", zero=NA)

# show posterior predictive distribution --
# in terms of log-odds:
bm$summary[,"theta"]
logodds &lt;- bm$summary[c(2,5,6), "theta"]
logodds
# in terms of odds:
exp(logodds)
# in terms of probabilities:
(exp(logodds) / (exp(logodds) + 1))

# illustrate MAP prior density:
x &lt;- seq(-3, 1, by=0.01)
plot(x, bm$dposterior(theta=x, predict=TRUE), type="l",
     xlab="log-odds (response)", ylab="posterior predictive density")
abline(h=0, v=0, col="grey")

## End(Not run)
</code></pre>

<hr>
<h2 id='bayesmeta'>
Bayesian random-effects meta-analysis
</h2><span id='topic+bayesmeta'></span><span id='topic+bayesmeta.default'></span><span id='topic+bayesmeta.escalc'></span><span id='topic+print.bayesmeta'></span><span id='topic+summary.bayesmeta'></span>

<h3>Description</h3>

<p>This function allows to derive the posterior distribution of the two
parameters in a random-effects meta-analysis and provides functions to
evaluate joint and marginal posterior probability distributions, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  bayesmeta(y, ...)
  ## Default S3 method:
bayesmeta(y, sigma, labels = names(y),
          tau.prior = "uniform",
          mu.prior = c("mean"=NA,"sd"=NA),
          mu.prior.mean = mu.prior[1], mu.prior.sd = mu.prior[2],
          interval.type = c("shortest", "central"),
          delta = 0.01, epsilon = 0.0001,
          rel.tol.integrate = 2^16*.Machine$double.eps,
          abs.tol.integrate = 0.0,
          tol.uniroot = rel.tol.integrate, ...)
  ## S3 method for class 'escalc'
bayesmeta(y, labels = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bayesmeta_+3A_y">y</code></td>
<td>

<p>vector of estimates <em>or</em> an <code><a href="metafor.html#topic+escalc">escalc</a></code> object.
</p>
</td></tr>
<tr><td><code id="bayesmeta_+3A_sigma">sigma</code></td>
<td>

<p>vector of standard errors associated with <code>y</code>.
</p>
</td></tr>
<tr><td><code id="bayesmeta_+3A_labels">labels</code></td>
<td>

<p>(optional) a vector of labels corresponding to <code>y</code> and <code>sigma</code>.
</p>
</td></tr>
<tr><td><code id="bayesmeta_+3A_tau.prior">tau.prior</code></td>
<td>

<p>a <code>function</code> returning the prior density for the heterogeneity
parameter (<code class="reqn">\tau</code>) <em>or</em> a <code>character</code> string
specifying one of the <em>default &lsquo;non-informative&rsquo;
priors</em>; possible choices for the latter case are: 
</p>

<ul>
<li> <p><code>"uniform"</code>: a uniform prior in <code class="reqn">\tau</code>
</p>
</li>
<li> <p><code>"sqrt"</code>: a uniform prior in <code class="reqn">\sqrt{\tau}</code>
</p>
</li>
<li> <p><code>"Jeffreys"</code>: the Jeffreys prior for <code class="reqn">\tau</code>
</p>
</li>
<li> <p><code>"BergerDeely"</code>: the prior due to Berger and Deely (1988)
</p>
</li>
<li> <p><code>"conventional"</code>: the conventional prior
</p>
</li>
<li> <p><code>"DuMouchel"</code>: the DuMouchel prior
</p>
</li>
<li> <p><code>"shrinkage"</code>: the &lsquo;uniform shrinkage&rsquo; prior
</p>
</li>
<li> <p><code>"I2"</code>: a uniform prior on the &lsquo;relative heterogeneity&rsquo; <code class="reqn">I^2</code>
</p>
</li></ul>

<p>The default is <code>"uniform"</code> (which should be used with caution;
see remarks below). The above priors are described in some more
detail below.
</p>
</td></tr>
<tr><td><code id="bayesmeta_+3A_mu.prior">mu.prior</code></td>
<td>

<p>the mean and standard deviation of the normal prior distribution for
the effect <code class="reqn">\mu</code>. If unspecified, an (improper) uniform prior is
used.
</p>
</td></tr>
<tr><td><code id="bayesmeta_+3A_mu.prior.mean">mu.prior.mean</code>, <code id="bayesmeta_+3A_mu.prior.sd">mu.prior.sd</code></td>
<td>

<p>alternative parameters to specify the prior distribution for the
effect <code class="reqn">\mu</code> (see above).
</p>
</td></tr>
<tr><td><code id="bayesmeta_+3A_interval.type">interval.type</code></td>
<td>

<p>the type of (credible, prediction, shrinkage) interval to be
returned by default; either <code>"shortest"</code> for shortest
intervals, or <code>"central"</code> for central, equal-tailed intervals.
</p>
</td></tr>
<tr><td><code id="bayesmeta_+3A_delta">delta</code>, <code id="bayesmeta_+3A_epsilon">epsilon</code></td>
<td>

<p>the parameters specifying the desired accuracy for approximation of
the <code class="reqn">\mu</code> posterior(s), and with that determining the number of
<code class="reqn">\tau</code> support points being used internally. Smaller values
imply greater accuracy and greater computational burden (Roever and
Friede, 2017).
</p>
</td></tr>
<tr><td><code id="bayesmeta_+3A_rel.tol.integrate">rel.tol.integrate</code>, <code id="bayesmeta_+3A_abs.tol.integrate">abs.tol.integrate</code>, <code id="bayesmeta_+3A_tol.uniroot">tol.uniroot</code></td>
<td>

<p>the <code>rel.tol</code>, <code>abs.tol</code> and <code>tol</code>
&lsquo;accuracy&rsquo; arguments that are passed to
the <code><a href="stats.html#topic+integrate">integrate</a>()</code> or <code><a href="stats.html#topic+uniroot">uniroot</a>()</code> functions
for internal numerical integration or root finding
(see also the help there).
</p>
</td></tr>
<tr><td><code id="bayesmeta_+3A_...">...</code></td>
<td>

<p>other <code>bayesmeta</code> arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The common random-effects meta-analysis model may be stated as
</p>
<p style="text-align: center;"><code class="reqn">y_i|\mu,\sigma_i,\tau \;\sim\; \mathrm{Normal}(\mu, \, \sigma_i^2 + \tau^2)</code>
</p>

<p>where the data (<code class="reqn">y</code>, <code class="reqn">\sigma</code>) enter as <code class="reqn">y_i</code>, the
<code class="reqn">i</code>-th estimate, that is associated with standard error
<code class="reqn">\sigma_i &gt; 0</code>, and <code class="reqn">i=1,...,k</code>. The model includes two unknown parameters,
namely the (mean) effect <code class="reqn">\mu</code>, and the heterogeneity
<code class="reqn">\tau</code>. Alternatively, the model may also be formulated via an
intermediate step as
</p>
<p style="text-align: center;"><code class="reqn">y_i|\theta_i,\sigma_i \;\sim\; \mathrm{Normal}(\theta_i, \, \sigma_i^2),</code>
</p>

<p style="text-align: center;"><code class="reqn">\theta_i|\mu,\tau \;\sim\; \mathrm{Normal}(\mu, \, \tau^2),</code>
</p>

<p>where the <code class="reqn">\theta_i</code> denote the <em>trial-specific</em> means
that are then measured through the estimate <code class="reqn">y_i</code> with an
associated measurement uncertainty <code class="reqn">\sigma_i</code>. The
<code class="reqn">\theta_i</code> again differ from trial to trial and are
distributed around a common mean <code class="reqn">\mu</code> with standard deviation
<code class="reqn">\tau</code>.
</p>
<p>The <code>bayesmeta()</code> function utilizes the fact that the joint posterior
distribution <code class="reqn">p(\mu, \tau | y, \sigma)</code> may be partly analytically
integrated out to determine the integrals necessary for coherent
Bayesian inference on one or both of the parameters.
</p>
<p>As long as we assume that the prior probability distribution may be
factored into independent marginals <code class="reqn">p(\mu,\tau)=p(\mu)\times
  p(\tau)</code> and either an (improper) uniform
or a normal prior is used for the effect <code class="reqn">\mu</code>, the joint
likelihood <code class="reqn">p(y|\mu,\tau)</code> may be analytically marginalized over
<code class="reqn">\mu</code>, yielding the marginal likelihood function
<code class="reqn">p(y|\tau)</code>. Using any prior <code class="reqn">p(\tau)</code> for the heterogeneity,
the 1-dimensional marginal posterior <code class="reqn">p(\tau|y) \propto
  p(y|\tau)\times p(\tau)</code> may
then be treated numerically. As the <em>conditional</em> posterior
<code class="reqn">p(\mu|\tau,y)</code> is a normal distribution, inference on the
remaining joint (<code class="reqn">p(\mu,\tau|y)</code>) or marginal (<code class="reqn">p(\mu|y)</code>)
posterior may be approached numerically (using the <abbr><span class="acronym">DIRECT</span></abbr>
algorithm) as well. Accuracy of the computations is determined by the
<code>delta</code> (maximum divergence <code class="reqn">\delta</code>) and <code>epsilon</code>
(tail probability <code class="reqn">\epsilon</code>) parameters (Roever and Friede,
2017).
</p>
<p>What constitutes a sensible prior for both <code class="reqn">\mu</code> and <code class="reqn">\tau</code>
depends (as usual) very much on the context.
Potential candidates for informative (or weakly informative)
heterogeneity (<code class="reqn">\tau</code>) priors may include the <em>half-normal</em>,
<em>half-Student-<code class="reqn">t</code></em>,  <em>half-Cauchy</em>, <em>exponential</em>,
or <em>Lomax</em> distributions; we recommend the use of heavy-tailed
prior distributions if in case of prior/data conflict the prior is
supposed to be discounted (O'Hagan and Pericchi, 2012).  A sensible
informative prior might also be a <em>log-normal</em> or a <em>scaled
inverse <code class="reqn">\chi^2</code></em> distribution. 
One might argue that an uninformative prior for <code class="reqn">\tau</code> may be
uniform or monotonically decreasing in <code class="reqn">\tau</code>. Another option is
to use the <em>Jeffreys prior</em> (see the <code>tau.prior</code> argument
above). The Jeffreys prior implemented here is the variant also
described by Tibshirani (1989) that results from fixing the location
parameter (<code class="reqn">\mu</code>) and considering the Fisher information element
corresponding to the heterogeneity <code class="reqn">\tau</code> only. This prior also
constitutes the <em>Berger/Bernardo reference prior</em> for the present
problem (Bodnar <em>et al.</em>, 2016).  The <em>uniform shrinkage</em> and
<em>DuMouchel</em> priors are described in Spiegelhalter <em>et al.</em> (2004,
Sec. 5.7.3). 
The procedure is able to handle improper priors (and does so by
default), but of course the usual care must be taken here, as the
resulting posterior <em>may</em> or <em>may not</em> be a proper
probability distribution.
</p>
<p>Note that a wide range of different types of endpoints may be treated
on a continuous scale after an appropriate transformation; for
example, count data may be handled by considering corresponding
logarithmic odds ratios. Many such transformations are implemented
in the <span class="pkg">metafor</span> package's <code><a href="metafor.html#topic+escalc">escalc</a></code> function
and may be directly used as an input to the <code>bayesmeta()</code>
function; see also the example below.  Alternatively, the
<span class="pkg">compute.es</span> package also provides a range of effect sizes to be
computed from different data types.
</p>
<p>The <code>bayesmeta()</code> function eventually generates some basic
summary statistics, but most importantly it provides an object
containing a range of <code>function</code>s allowing to evaluate posterior
distributions; this includes joint and marginal posteriors, prior and
likelihood, predictive distributions, densities, cumulative
distributions and quantile functions. For more details see also the
documentation and examples below.
Use of the <code>individual</code> argument allows to access posteriors
of study-specific (<em>shrinkage-</em>) effects
(<code class="reqn">\theta_i</code>).
The <code>predict</code> argument may be used to access the predictive
distribution of a future study's effect
(<code class="reqn">\theta_{k+1}</code>), facilitating a
<em>meta-analytic-predictive (MAP)</em> approach (Neuenschwander <em>et al.</em>,
2010).
</p>


<h4>Prior specification details</h4>

<p>When specifying the <code>tau.prior</code> argument as a <code>character</code> string
(and not as a prior density <code>function</code>), then the actual
prior probability density functions corresponding to the possible
choices of the <code>tau.prior</code> argument are given by:
</p>

<ul>
<li> <p><code>"uniform"</code> - the (improper) uniform prior in <code class="reqn">\tau</code>:
</p>
<p style="text-align: center;"><code class="reqn">p(\tau) \;\propto\; 1</code>
</p>

</li>
<li> <p><code>"sqrt"</code> - the (improper) uniform prior in <code class="reqn">\sqrt{\tau}</code>:
</p>
<p style="text-align: center;"><code class="reqn">p(\tau) \;\propto\; \tau^{-1/2} \;=\; \frac{1}{\sqrt{\tau}}</code>
</p>

</li>
<li> <p><code>"Jeffreys"</code> - <em>Tibshirani's noninformative prior</em>,
a variation of the (&lsquo;general&rsquo; or &lsquo;overall&rsquo;) <em>Jeffreys prior</em>, which here also constitutes
the <em>Berger/Bernardo reference prior</em> for <code class="reqn">\tau</code>:
</p>
<p style="text-align: center;"><code class="reqn">p(\tau) \;\propto\;
        \sqrt{\sum_{i=1}^k\Bigl(\frac{\tau}{\sigma_i^2+\tau^2}\Bigr)^2}</code>
</p>

<p>This is also an improper prior whose density does not integrate to 1.
This prior results from applying <em>Jeffreys' general rule</em> (Kass and Wasserman, 1996),
and in particular considering that location parameters (here: the effect <code class="reqn">\mu</code>)
should be treated separately (Roever, 2020).
</p>
</li>
<li> <p><code>"overallJeffreys"</code> - the &lsquo;general&rsquo; or &lsquo;overall&rsquo; form 
of the <em>Jeffreys prior</em>;
this is derived based on the Fisher information terms
corresponding to <em>both</em> the effect (<code class="reqn">\mu</code>) and heterogeneity (<code class="reqn">\tau</code>).
The resulting (improper) prior density is
</p>
<p style="text-align: center;"><code class="reqn">p(\tau) \;\propto\;
        \sqrt{\sum_{i=1}^k\frac{1}{\sigma_i^2+\tau^2} \; \sum_{i=1}^k\Bigl(\frac{\tau}{\sigma_i^2+\tau^2}\Bigr)^2}</code>
</p>

<p>Use of this specification is generally <em>not</em> recommended; see, e.g.,
Jeffreys (1946), Jeffreys (1961, Sec. III.3.10),
Berger (1985, Sec. 3.3.3) and Kass and Wasserman (1996, Sec. 2.2).
Since the effect <code class="reqn">\mu</code> constitutes a <em>location parameter</em> here,
it should be treated separately (Roever, 2020).
</p>
</li>
<li> <p><code>"BergerDeely"</code> - the (improper) <em>Berger/Deely</em> prior:
</p>
<p style="text-align: center;"><code class="reqn">p(\tau) \;\propto\; \prod_{i=1}^k \Bigl(\frac{\tau}{\sigma_i^2+\tau^2}\Bigr)^{1/k}</code>
</p>

<p>This is a variation of the above <em>Jeffreys</em> prior, and both are equal in
case all standard errors (<code class="reqn">\sigma_i</code>) are the same.
</p>
</li>
<li> <p><code>"conventional"</code> - the (proper) <em>conventional prior</em>:
</p>
<p style="text-align: center;"><code class="reqn">p(\tau) \;\propto\; \prod_{i=1}^k \biggl(\frac{\tau}{(\sigma_i^2+\tau^2)^{3/2}}\biggr)^{1/k}</code>
</p>

<p>This is a proper variation of the above <em>Berger/Deely</em> prior 
intended especially for testing and model selection purposes.
</p>
</li>
<li> <p><code>"DuMouchel"</code> - the (proper) <em>DuMouchel</em> prior:
</p>
<p style="text-align: center;"><code class="reqn">p(\tau) \;=\; \frac{s_0}{(s_0+\tau)^2}</code>
</p>

<p>where <code class="reqn">s_0=\sqrt{s_0^2}</code> and <code class="reqn">s_0^2</code> again is the harmonic mean of the standard errors (as above).
</p>
</li>
<li> <p><code>"shrinkage"</code> - the (proper) <em>uniform shrinkage</em> prior:
</p>
<p style="text-align: center;"><code class="reqn">p(\tau) \;=\; \frac{2 s_0^2 \tau}{(s_0^2+\tau^2)^2}</code>
</p>

<p>where <code class="reqn">s_0^2=\frac{k}{\sum_{i=1}^k \sigma_i^{-2}}</code> is the harmonic
mean of the squared standard errors <code class="reqn">\sigma_i^2</code>.
</p>
</li>
<li> <p><code>"I2"</code> - the (proper) uniform prior in <code class="reqn">I^2</code>:
</p>
<p style="text-align: center;"><code class="reqn">p(\tau) \;=\; \frac{2 \hat{\sigma}^2 \tau}{(\hat{\sigma}^2 + \tau^2)^2}</code>
</p>

<p>where <code class="reqn">\hat{\sigma}^2 = \frac{(k-1)\; \sum_{i=1}^k\sigma_i^{-2}}{\bigl(\sum_{i=1}^k\sigma_i^{-2}\bigr)^2 - \sum_{i=1}^k\sigma_i^{-4}}</code>.
This prior is similar to the uniform shrinkage prior, except for
the use of <code class="reqn">\hat{\sigma}^2</code> instead of <code class="reqn">s_0^2</code>.
</p>
</li></ul>

<p>For more details on the above priors, see Roever (2020).
For more general information especially on (weakly)
informative heterogeneity prior distributions, see Roever <em>et al.</em> (2021).
Regarding empirically motivated informative heterogeneity priors see also
the <code><a href="#topic+TurnerEtAlPrior">TurnerEtAlPrior</a>()</code> and <code><a href="#topic+RhodesEtAlPrior">RhodesEtAlPrior</a>()</code>
functions, or Roever <em>et al.</em> (2023) and Lilienthal <em>et al.</em> 
(2023).
</p>



<h4>Credible intervals</h4>

<p>Credible intervals (as well as prediction and shrinkage intervals)
may be determined in different ways. By default, <em>shortest</em>
intervals are returned, which for unimodal posteriors (the usual
case) is equivalent to the <em>highest posterior density region</em>
(Gelman <em>et al.</em>, 1997, Sec. 2.3).
Alternatively, central (equal-tailed) intervals may also be derived.
The default behaviour may be controlled via the <code>interval.type</code>
argument, or also by using the <code>method</code> argument with each
individual call of the <code>$post.interval()</code> function (see below).
A third option, although not available for prediction or shrinkage
intervals, and hence not as an overall default choice, but only for
the <code>$post.interval()</code> function, is to
determine the <em>evidentiary</em> credible interval, which has the
advantage of being parameterization invariant (Shalloway, 2014).
</p>



<h4>Bayes factors</h4>

<p>Bayes factors (Kass and Raftery, 1995) for the two hypotheses of
<code class="reqn">\tau=0</code> and <code class="reqn">\mu=0</code> are provided in the <code>$bayesfactor</code>
element; <em>low</em> or <em>high</em> values here constitute evidence
<em>against</em> or <em>in favour of</em> the hypotheses,
respectively. Bayes factors are based on marginal likelihoods and
can only be computed if the priors for heterogeneity and effect are
proper. Bayes factors for other hypotheses can be computed using the
marginal likelihood (as provided through the <code>$marginal</code>
element) and the <code>$likelihood()</code> function. Bayes factors must
be interpreted with very much caution, as they are susceptible to
<em>Lindley's paradox</em> (Lindley, 1957), which especially implies
that variations of the prior specifications that have only minuscule
effects on the posterior distribution may have a substantial impact
on Bayes factors (via the marginal likelihood). For more details on
the problems and challenges related to Bayes factors see also
Gelman <em>et al.</em> (1997, Sec. 7.4).
</p>
<p>Besides the &lsquo;actual&rsquo; Bayes factors, <em>minimum Bayes
factors</em> are also provided (Spiegelhalter <em>et al.</em>, 2004; Sec. 4.4).
The minimum Bayes factor for the hypothesis of <code class="reqn">\mu=0</code>
constitutes the minimum across all possible priors for <code class="reqn">\mu</code> and
hence gives a measure of how much (or how little) evidence
<em>against</em> the hypothesis is provided by the data <em>at most</em>.
It is independent of the particular effect prior used in the
analysis, but still dependent on the heterogeneity
prior. Analogously, the same is true for the heterogeneity's minimum
Bayes factor. A minimum Bayes factor can also be computed when only
one of the priors is proper.
</p>



<h4>Numerical accuracy</h4>

<p>Accuracy of the numerical results is determined by four parameters,
namely, the accuracy of numerical integration as specified through the
<code>rel.tol.integrate</code> and <code>abs.tol.integrate</code> arguments (which
are internally passed on to the <code><a href="stats.html#topic+integrate">integrate</a></code>
function), and the accuracy of the grid approximation used for
integrating out the heterogeneity as specified through the
<code>delta</code> and <code>epsilon</code> arguments (Roever and Friede,
2017). As these may also heavily impact on the computation time, be
careful when changing these from their default values. You can monitor
the effect of different settings by checking the number and range of
support points returned in the <code>$support</code> element.
</p>
  


<h4>Study weights</h4>

<p>Conditional on a given <code class="reqn">\tau</code> value, the posterior
expectations of the overall effect (<code class="reqn">\mu</code>) as well as the
shrinkage estimates (<code class="reqn">\theta_i</code>) result as convex
combinations of the estimates <code class="reqn">y_i</code>. The <em>weights</em>
associated with each estimate <code class="reqn">y_i</code> are commonly quoted
in frequentist meta-analysis results in order to quantify
(arguably somewhat heuristically) each study's contribution to the
overall estimates, often in terms of percentages.
</p>
<p>In a Bayesian meta-analysis, these numbers to not immediately
arise, since the heterogeneity is marginalized over. However, due
to linearity, the posterior mean effects may still be expressed in
terms of linear combinations of initial estimates <code class="reqn">y_i</code>,
with weights now given by the <em>posterior mean weights</em>,
marginalized over the heterogeneity <code class="reqn">\tau</code> (Roever and Friede,
2020). The posterior mean weights are returned in the
<code>$weights</code> and <code>$weights.theta</code> elements, for the overall
effect <code class="reqn">\mu</code> as well as for the shrinkage estimates
<code class="reqn">\theta_i</code>.
</p>



<h3>Value</h3>

<p>A list of class <code>bayesmeta</code> containing the following elements:
</p>
<table>
<tr><td><code>y</code></td>
<td>
<p>vector of estimates (the input data).</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>vector of standard errors corresponding
to <code>y</code> (input data).</p>
</td></tr>
<tr><td><code>labels</code></td>
<td>
<p>vector of labels corresponding to <code>y</code> and <code>sigma</code>.</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>number of data points (in <code>y</code>).</p>
</td></tr>
<tr><td><code>tau.prior</code></td>
<td>
<p>the prior probability density function for <code class="reqn">\tau</code>.</p>
</td></tr>
<tr><td><code>mu.prior.mean</code></td>
<td>
<p>the prior mean of <code class="reqn">\mu</code>.</p>
</td></tr>
<tr><td><code>mu.prior.sd</code></td>
<td>
<p>the prior standard deviation of <code class="reqn">\mu</code>.</p>
</td></tr>
<tr><td><code>dprior</code></td>
<td>
<p>a <code>function(tau=NA, mu=NA, log=FALSE)</code> of two
parameters, <code>tau</code> and/or <code>mu</code>, returning either the joint or
marginal prior probability density, depending on which parameter(s)
is/are provided.</p>
</td></tr> 
<tr><td><code>tau.prior.proper</code></td>
<td>
<p>a <code>logical</code> flag indicating whether the
heterogeneity prior appears to be proper (which is judged based on
an attempted numerical integration of the density function).</p>
</td></tr> 
<tr><td><code>likelihood</code></td>
<td>
<p>a <code>function(tau=NA, mu=NA, log=FALSE)</code> of two
parameters, <code>tau</code> and/or <code>mu</code>, returning either the joint or
marginal likelihood, depending on which parameter(s) is/are provided.</p>
</td></tr> 
<tr><td><code>dposterior</code></td>
<td>
<p>a <code>function(tau=NA, mu=NA, theta=mu, log=FALSE, predict=FALSE, individual=FALSE)</code>
of two parameters, <code>tau</code> and/or <code>mu</code>,
returning either the joint or marginal posterior probability density,
depending on which parameter(s) is/are provided. Using the argument
<code>predict=TRUE</code> yields the <em>posterior predictive
distribution</em> for <code class="reqn">\theta</code>. Using the <code>individual</code>
argument, you can request individual effects'
(<code class="reqn">\theta_i</code>) posterior distributions. May be an integer
number (<code>1,...,k</code>) giving the index, or a character string giving
the label.</p>
</td></tr>
<tr><td><code>pposterior</code></td>
<td>
<p>a <code>function(tau=NA, mu=NA, theta=mu, predict=FALSE, individual=FALSE)</code> 
of one parameter (either <code>tau</code> or <code>mu</code>) returning the
corresponding marginal posterior cumulative distribution
function. Using the argument <code>predict=TRUE</code> yields the posterior
predictive distribution for <code class="reqn">\theta</code>. Using the <code>individual</code>
argument, you can request individual effects'
(<code class="reqn">\theta_i</code>) posterior distributions. May be an integer
number (<code>1,...,k</code>) giving the index, or a character string giving
the label.</p>
</td></tr> 
<tr><td><code>qposterior</code></td>
<td>
<p>a <code>function(tau.p=NA, mu.p=NA, theta.p=mu.p, predict=FALSE, individual=FALSE)</code>
of one parameter (either <code>tau.p</code> or <code>mu.p</code>) returning the
corresponding marginal posterior quantile function. Using the argument
<code>predict=TRUE</code> yields the posterior predictive distribution for
<code class="reqn">\theta</code>. Using the <code>individual</code> argument, you can request
individual effects' (<code class="reqn">\theta_i</code>) posterior
distributions. May be an integer number (<code>1,...,k</code>) giving the
index, or a character string giving the label.</p>
</td></tr>
<tr><td><code>rposterior</code></td>
<td>
<p>a <code>function(n=1, predict=FALSE, individual=FALSE, tau.sample=TRUE)</code>
generating <code>n</code> independent random draws from the
(2-dimensional) posterior distribution. Using the argument
<code>predict=TRUE</code> yields the posterior predictive distribution for
<code class="reqn">\theta</code>. Using the <code>individual</code> argument, you can request
individual effects' (<code class="reqn">\theta_i</code>) posterior
distributions. May be an integer number (<code>1,...,k</code>) giving the
index, or a character string giving the label. In general, this via
the inversion method, so it is rather slow. However, if one is not
interested in sampling the heterogeneity parameter (<code class="reqn">\tau</code>),
using &lsquo;<code>tau.sample=FALSE</code>&rsquo; will speed up the function
substantially.</p>
</td></tr> 
<tr><td><code>post.interval</code></td>
<td>
<p>a <code>function(tau.level=NA, mu.level=NA, theta.level=mu.level, method=c("shortest","central","evidentiary"), predict=FALSE, individual=FALSE)</code>
returning a credible interval, depending on which of the two
parameters is provided (either <code>tau.level</code> or
<code>mu.level</code>). The additional parameter <code>method</code> may be used
to specify the desired type of interval: <code>method</code> <code>=</code>
<code>"shortest"</code> returns the shortest interval, <code>method</code>
<code>=</code> <code>"central"</code> returns a central interval, and <code>method</code>
<code>=</code> <code>"evidentiary"</code> returns an evidentiary interval
(Shalloway, 2014); the former is the default option. Using the
argument <code>predict=TRUE</code> yields a posterior predictive interval
for <code class="reqn">\theta</code>. Using the <code>individual</code>
argument, you can request individual effects'
(<code class="reqn">\theta_i</code>) posterior distributions. May be an integer
number (<code>1,...,k</code>) giving the index, or a character string giving
the label.</p>
</td></tr> 
<tr><td><code>cond.moment</code></td>
<td>
<p>a <code>function(tau, predict=FALSE, individual=FALSE, simplify=TRUE)</code>
returning conditional moments (mean and standard deviation) of
<code class="reqn">\mu</code> as a function of <code class="reqn">\tau</code>. Using the argument
<code>predict=TRUE</code> yields (conditional) posterior predictive
moments for <code class="reqn">\theta</code>. Using the <code>individual</code>
argument, you can request individual effects'
(<code class="reqn">\theta_i</code>) posterior distributions. May be an integer
number (<code>1,...,k</code>) giving the index, or a character string giving
the label.</p>
</td></tr>
<tr><td><code>I2</code></td>
<td>
<p>a <code>function(tau)</code> returning the &lsquo;relative&rsquo; heterogeneity
<code class="reqn">I^2</code> as a function of <code class="reqn">\tau</code>.</p>
</td></tr>
<tr><td><code>summary</code></td>
<td>
<p>a <code>matrix</code> listing some summary statistics, namely
marginal posterior mode, median, mean, standard deviation
and a (shortest) 95% credible intervals,
of the marginal posterior distributions of <code class="reqn">\tau</code> and <code class="reqn">\mu</code>,
and of the posterior predictive distribution of <code class="reqn">\theta</code>.</p>
</td></tr>
<tr><td><code>interval.type</code></td>
<td>
<p>the <code>interval.type</code> input argument
specifying the type of interval to be returned by default.</p>
</td></tr>
<tr><td><code>ML</code></td>
<td>
<p>a <code>matrix</code> giving joint and marginal maximum-likelihood
estimates of <code class="reqn">(\tau,\mu)</code>.</p>
</td></tr>
<tr><td><code>MAP</code></td>
<td>
<p>a <code>matrix</code> giving joint and marginal
maximum-a-posteriori estimates of <code class="reqn">(\tau,\mu)</code>.</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>a <code>matrix</code> giving the &lsquo;shrinkage estimates&rsquo;,
i.e, summary statistics of the trial-specific means
<code class="reqn">\theta_i</code>.</p>
</td></tr> 
<tr><td><code>weights</code></td>
<td>
<p>a <code>vector</code> giving the posterior expected
<em>inverse-variance weights</em> for each study (and for the effect
prior mean, if the effect prior was proper).</p>
</td></tr>
<tr><td><code>weights.theta</code></td>
<td>
<p>a <code>matrix</code> whose columns give the
posterior expected weights of each study (and of the effect prior
mean, if the effect prior was proper) for all shrinkage
estimates.</p>
</td></tr>
<tr><td><code>marginal.likelihood</code></td>
<td>
<p>the marginal likelihood of the data (this 
number is only computed if proper effect and heterogeneity priors 
are specified).</p>
</td></tr>
<tr><td><code>bayesfactor</code></td>
<td>
<p>Bayes factors and minimum Bayes factors for the two
hypotheses of <code class="reqn">\tau=0</code> and <code class="reqn">\mu=0</code>. These depend on the
marginal likelihood and hence can only be computed if proper effect
and/or heterogeneity priors are specified; see also remark above.</p>
</td></tr>
<tr><td><code>support</code></td>
<td>
<p>a <code>matrix</code> giving the <code class="reqn">\tau</code> support points used
internally in the grid approximation, along with their associated
weights, conditional mean and standard deviation of <code class="reqn">\mu</code>,
and the standard deviation of the (conditional) predictive
distribution of <code class="reqn">\theta</code>.</p>
</td></tr>
<tr><td><code>delta</code>, <code>epsilon</code></td>
<td>
<p>the &lsquo;<code>delta</code>&rsquo; and &lsquo;<code>epsilon</code>&rsquo;
input parameter determining numerical accuracy.</p>
</td></tr>
<tr><td><code>rel.tol.integrate</code>, <code>abs.tol.integrate</code>, <code>tol.uniroot</code></td>
<td>
<p>the input
parameters determining the numerical accuracy of the internally used
<code><a href="stats.html#topic+integrate">integrate</a>()</code> and <code><a href="stats.html#topic+uniroot">uniroot</a>()</code> functions.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>an object of class <code>call</code> giving the
function call that generated the <code>bayesmeta</code> object.</p>
</td></tr>
<tr><td><code>init.time</code></td>
<td>
<p>the computation time (in seconds) used to generate
the <code>bayesmeta</code> object.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Roever <a href="mailto:christian.roever@med.uni-goettingen.de">christian.roever@med.uni-goettingen.de</a>
</p>


<h3>References</h3>

<p>C. Roever.
Bayesian random-effects meta-analysis using the bayesmeta R package.
<em>Journal of Statistical Software</em>, <b>93</b>(6):1-51, 2020.
<a href="https://doi.org/10.18637/jss.v093.i06">doi:10.18637/jss.v093.i06</a>.
</p>
<p>C. Roever, R. Bender, S. Dias, C.H. Schmid, H. Schmidli, S. Sturtz,
S. Weber, T. Friede.
On weakly informative prior distributions for the heterogeneity
parameter in Bayesian random-effects meta-analysis.
<em>Research Synthesis Methods</em>, <b>12</b>(4):448-474, 2021.
<a href="https://doi.org/10.1002/jrsm.1475">doi:10.1002/jrsm.1475</a>.
</p>
<p>C. Roever, T. Friede.
Discrete approximation of a mixture distribution via restricted divergence.
<em>Journal of Computational and Graphical Statistics</em>,
<b>26</b>(1):217-222, 2017.
<a href="https://doi.org/10.1080/10618600.2016.1276840">doi:10.1080/10618600.2016.1276840</a>.
</p>
<p>C. Roever, T. Friede.
Bounds for the weight of external data in shrinkage estimation.
<em>Biometrical Journal</em>, <b>65</b>(5):1131-1143, 2021.
<a href="https://doi.org/10.1002/bimj.202000227">doi:10.1002/bimj.202000227</a>.
</p>
<p>J. O. Berger.
<em>Statistical Decision Theory and Bayesian Analysis</em>.
2nd edition. Springer-Verlag, 1985.
<a href="https://doi.org/10.1007/978-1-4757-4286-2">doi:10.1007/978-1-4757-4286-2</a>.
</p>
<p>J.O. Berger, J. Deely.
A Bayesian approach to ranking and selection of related means with
alternatives to analysis-of-variance methodology.
<em>Journal of the American Statistical Association</em>,
<b>83</b>(402):364-373, 1988.
<a href="https://doi.org/10.1080/01621459.1988.10478606">doi:10.1080/01621459.1988.10478606</a>.
</p>
<p>O. Bodnar, A. Link, C. Elster.
Objective Bayesian inference for a generalized marginal random effects
model. 
<em>Bayesian Analysis</em>, <b>11</b>(1):25-45, 2016.
<a href="https://doi.org/10.1214/14-BA933">doi:10.1214/14-BA933</a>.
</p>
<p>A. Gelman, J.B. Carlin, H.S. Stern, D.B. Rubin. <em>Bayesian data
analysis</em>. Chapman &amp; Hall / CRC, Boca Raton, 1997.
</p>
<p>A. Gelman. Prior distributions for variance parameters in hierarchical
models. <em>Bayesian Analysis</em>, <b>1</b>(3):515-534, 2006.
<a href="https://doi.org/10.1214/06-BA117A">doi:10.1214/06-BA117A</a>.
</p>
<p>J. Hartung, G. Knapp, B.K. Sinha. <em>Statistical meta-analysis with
applications</em>. Wiley, Hoboken, 2008.
</p>
<p>L.V. Hedges, I. Olkin. <em>Statistical methods for meta-analysis</em>.
Academic Press, San Diego, 1985
</p>
<p>H. Jeffreys.
An invariant form for the prior probability in estimation problems.
<em>Proceedings of the Royal Society of london, Series A</em>,
<b>186</b>(1007):453-462, 1946.
<a href="https://doi.org/10.1098/rspa.1946.0056">doi:10.1098/rspa.1946.0056</a>.
</p>
<p>H. Jeffreys.
<em>Theory of Probability</em>. 3rd edition. Clarendon Press, Oxford, 1961.
</p>
<p>A.E. Kass, R.E. Raftery.
Bayes factors.
<em>Journal of the American Statistical Association</em>,
<b>90</b>(430):773-795, 1995.
<a href="https://doi.org/10.2307/2291091">doi:10.2307/2291091</a>.
</p>
<p>A.E. Kass, L. Wasserman.
The selection of prior distributions by formal rules.
<em>Journal of the American Statistical Association</em>.
<b>91</b>(453):1243-1370, 1996.
<a href="https://doi.org/10.1080/01621459.1996.10477003">doi:10.1080/01621459.1996.10477003</a>.
</p>
<p>J. Lilienthal, S. Sturtz, C. Schuermann, M. Maiworm, C. Roever, T. Friede, R. Bender.
Bayesian random-effects meta-analysis with empirical heterogeneity priors
for application in health technology assessment with very few studies.
<em>Research Synthesis Methods</em>, 2023.
<a href="https://doi.org/10.1002/jrsm.1685">doi:10.1002/jrsm.1685</a>.
</p>
<p>D.V. Lindley.
A statistical paradox.
<em>Biometrika</em>, <b>44</b>(1/2):187-192, 1957.
<a href="https://doi.org/10.1093/biomet/44.1-2.187">doi:10.1093/biomet/44.1-2.187</a>.
</p>
<p>B. Neuenschwander, G. Capkun-Niggli, M. Branson, D.J. Spiegelhalter.
Summarizing historical information on controls in clinical trials.
<em>Trials</em>, <b>7</b>(1):5-18, 2010.
<a href="https://doi.org/10.1177/1740774509356002">doi:10.1177/1740774509356002</a>.
</p>
<p>A. O'Hagan, L. Pericchi.
Bayesian heavy-tailed models and conflict resolution: A review.
<em>Brazilian Journal of Probability and Statistics</em>,
<b>26</b>(4):372-401, 2012.
<a href="https://doi.org/10.1214/11-BJPS164">doi:10.1214/11-BJPS164</a>.
</p>
<p>C. Roever, S. Sturtz, J. Lilienthal, R. Bender, T. Friede.
Summarizing empirical information on between-study heterogeneity
for Bayesian random-effects meta-analysis. 
<em>Statistics in Medicine</em>, <b>42</b>(14):2439-2454, 2023.
<a href="https://doi.org/10.1002/sim.9731">doi:10.1002/sim.9731</a>.
</p>
<p>S. Shalloway.
The evidentiary credible region.
<em>Bayesian Analysis</em>, <b>9</b>(4):909-922, 2014.
<a href="https://doi.org/10.1214/14-BA883">doi:10.1214/14-BA883</a>.
</p>
<p>D.J. Spiegelhalter, K.R. Abrams, J.P.Myles.
<em>Bayesian approaches to clinical trials and health-care
evaluation</em>. 
Wiley &amp; Sons, 2004.
</p>
<p>R. Tibshirani.
Noninformative priors for one parameter of many.
<em>Biometrika</em>, <b>76</b>(3):604-608, 1989.
<a href="https://doi.org/10.1093/biomet/76.3.604">doi:10.1093/biomet/76.3.604</a>.
</p>
<p>W. Viechtbauer.
Conducting meta-analyses in R with the metafor package.
<em>Journal of Statistical Software</em>, <b>36</b>(3):1-48, 2010.
<a href="https://doi.org/10.18637/jss.v036.i03">doi:10.18637/jss.v036.i03</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+forestplot.bayesmeta">forestplot.bayesmeta</a></code>, <code><a href="#topic+plot.bayesmeta">plot.bayesmeta</a></code>,
<code><a href="metafor.html#topic+escalc">escalc</a></code>,
<code><a href="#topic+bmr">bmr</a></code>,
<code><a href="compute.es.html#topic+compute.es-package">compute.es</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>########################################
# example data by Snedecor and Cochran:
data("SnedecorCochran")

## Not run: 
# analysis using improper uniform prior
# (may take a few seconds to compute!):
ma01 &lt;- bayesmeta(y=SnedecorCochran[,"mean"], sigma=sqrt(SnedecorCochran[,"var"]),
                  label=SnedecorCochran[,"no"])

# analysis using an informative prior
# (normal for mu and half-Cauchy for tau (scale=10))
# (may take a few seconds to compute!):
ma02 &lt;- bayesmeta(y=SnedecorCochran[,"mean"], sigma=sqrt(SnedecorCochran[,"var"]),
                  label=SnedecorCochran[,"no"],
                  mu.prior.mean=50, mu.prior.sd=50,
                  tau.prior=function(x){return(dhalfcauchy(x, scale=10))})

# show some summary statistics:
print(ma01)
summary(ma01)

# show some plots:
forestplot(ma01)
plot(ma01)

# compare resulting marginal densities;
# the effect parameter (mu):
mu &lt;- seq(30, 80, le=200)
plot(mu, ma02$dposterior(mu=mu), type="l", lty="dashed",
     xlab=expression("effect "*mu),
     ylab=expression("marginal posterior density"),
     main="Snedecor/Cochran example")
lines(mu, ma01$dposterior(mu=mu), lty="solid")

# the heterogeneity parameter (tau):
tau &lt;- seq(0, 50, le=200)
plot(tau, ma02$dposterior(tau=tau), type="l", lty="dashed",
     xlab=expression("heterogeneity "*tau),
     ylab=expression("marginal posterior density"),
     main="Snedecor/Cochran example")
lines(tau, ma01$dposterior(tau=tau), lty="solid")

# compute posterior median relative heterogeneity I-squared:
ma01$I2(tau=ma01$summary["median","tau"])

# determine 90 percent upper limits on the heterogeneity tau:
ma01$qposterior(tau=0.90)
ma02$qposterior(tau=0.90)
# determine shortest 90 percent credible interval for tau:
ma01$post.interval(tau.level=0.9, method="shortest")
## End(Not run)


#####################################
# example data by Sidik and Jonkman:
data("SidikJonkman2007")
# add log-odds-ratios and corresponding standard errors:
sj &lt;- SidikJonkman2007
sj &lt;- cbind(sj, "log.or"=log(sj[,"lihr.events"])-log(sj[,"lihr.cases"]-sj[,"lihr.events"])
                             -log(sj[,"oihr.events"])+log(sj[,"oihr.cases"]-sj[,"oihr.events"]),
                "log.or.se"=sqrt(1/sj[,"lihr.events"] + 1/(sj[,"lihr.cases"]-sj[,"lihr.events"])
                                 + 1/sj[,"oihr.events"] + 1/(sj[,"oihr.cases"]-sj[,"oihr.events"])))

## Not run: 
# analysis using weakly informative half-normal prior
# (may take a few seconds to compute!):
ma03a &lt;- bayesmeta(y=sj[,"log.or"], sigma=sj[,"log.or.se"],
                   label=sj[,"id.sj"],
                   tau.prior=function(t){dhalfnormal(t,scale=1)})

# alternatively: may utilize "metafor" package's "escalc()" function
# to compute log-ORs and standard errors:
require("metafor")
es &lt;- escalc(measure="OR",
             ai=lihr.events, n1i=lihr.cases,
             ci=oihr.events, n2i=oihr.cases,
             slab=id, data=SidikJonkman2007)
# apply "bayesmeta()" function directly to "escalc" object:
ma03b &lt;- bayesmeta(es, tau.prior=function(t){dhalfnormal(t,scale=1)})
# "ma03a" and "ma03b" should be identical:
print(ma03a$summary)
print(ma03b$summary)
# compare to metafor's (frequentist) random-effects meta-analysis:
rma03a &lt;- rma.uni(es)
rma03b &lt;- rma.uni(es, method="EB", knha=TRUE)
# compare mu estimates (estimate and confidence interval):
plot(ma03b, which=3)
abline(v=c(rma03a$b, rma03a$ci.lb, rma03a$ci.ub), col="red", lty=c(1,2,2))
abline(v=c(rma03b$b, rma03b$ci.lb, rma03b$ci.ub), col="green3", lty=c(1,2,2))
# compare tau estimates (estimate and confidence interval):
plot(ma03b, which=4)
abline(v=confint(rma03a)$random["tau",], col="red", lty=c(1,2,2))       
abline(v=confint(rma03b)$random["tau",], col="green3", lty=c(1,3,3))       

# show heterogeneity's posterior density:
plot(ma03a, which=4, main="Sidik/Jonkman example")

# show some numbers (mode, median and mean):
abline(v=ma03a$summary[c("mode","median","mean"),"tau"], col="blue")

# compare with Sidik and Jonkman's estimates:
sj.estimates &lt;- sqrt(c("MM"  = 0.429,   # method of moments estimator
                       "VC"  = 0.841,   # variance component type estimator
                       "ML"  = 0.562,   # maximum likelihood estimator
                       "REML"= 0.598,   # restricted maximum likelihood estimator
                       "EB"  = 0.703,   # empirical Bayes estimator
                       "MV"  = 0.818,   # model error variance estimator
                       "MVvc"= 0.747))  # a variation of the MV estimator
abline(v=sj.estimates, col="red", lty="dashed")
## End(Not run)


###########################
# example data by Cochran:
data("Cochran1954")

## Not run: 
# analysis using improper uniform prior
# (may take a few seconds to compute!):
ma04 &lt;- bayesmeta(y=Cochran1954[,"mean"], sigma=sqrt(Cochran1954[,"se2"]),
                  label=Cochran1954[,"observer"])

# show joint posterior density:
plot(ma04, which=2, main="Cochran example")
# show (known) true parameter value:
abline(h=161)

# pick a point estimate for tau:
tau &lt;- ma04$summary["median","tau"]
# highlight two point hypotheses (fixed vs. random effects):
abline(v=c(0, tau), col="orange", lty="dotted", lwd=2)

# show marginal posterior density:
plot(ma04, which=3)
abline(v=161)
# show the conditional distributions of the effect mu
# at two tau values corresponding to fixed and random effects models:
cm &lt;- ma04$cond.moment(tau=c(0,tau))
mu &lt;- seq(130,200, le=200)
lines(mu, dnorm(mu, mean=cm[1,"mean"], sd=cm[1,"sd"]), col="orange", lwd=2)
lines(mu, dnorm(mu, mean=cm[2,"mean"], sd=cm[2,"sd"]), col="orange", lwd=2)

# determine a range of tau values:
tau &lt;- seq(0, ma04$qposterior(tau=0.99), length=100)
# compute conditional posterior moments:
cm.overall &lt;- ma04$cond.moment(tau=tau)
# compute study-specific conditional posterior moments:
cm.indiv &lt;- ma04$cond.moment(tau=tau, individual=TRUE)
# show forest plot along with conditional posterior means:
par(mfrow=c(1,2))
  plot(ma04, which=1, main="Cochran 1954 example")
  matplot(tau, cm.indiv[,"mean",], type="l", lty="solid", col=1:ma04$k,
          xlim=c(0,max(tau)*1.2), xlab=expression("heterogeneity "*tau),
          ylab=expression("(conditional) shrinkage estimate E["*
                           theta[i]*"|"*list(tau, y, sigma)*"]"))
  text(rep(max(tau)*1.01, ma04$k), cm.indiv[length(tau),"mean",],
       ma04$label, col=1:ma04$k, adj=c(0,0.5))
  lines(tau, cm.overall[,"mean"], lty="dashed", lwd=2)
  text(max(tau)*1.01, cm.overall[length(tau),"mean"],
       "overall", adj=c(0,0.5))
par(mfrow=c(1,1))

# show the individual effects' posterior distributions:
theta &lt;- seq(120, 240, le=300)
plot(range(theta), c(0,0.1), type="n", xlab=expression(theta[i]), ylab="")
for (i in 1:ma04$k) {
  # draw estimate +/- uncertainty as a Gaussian:
  lines(theta, dnorm(theta, mean=ma04$y[i], sd=ma04$sigma[i]), col=i+1, lty="dotted")
  # draw effect's posterior distribution:
  lines(theta, ma04$dposterior(theta=theta, indiv=i), col=i+1, lty="solid")
}
abline(h=0)
legend(max(theta), 0.1, legend=ma04$label, col=(1:ma04$k)+1, pch=15, xjust=1, yjust=1)

## End(Not run)
</code></pre>

<hr>
<h2 id='bmr'>
Bayesian random-effects meta-regression
</h2><span id='topic+bmr'></span><span id='topic+bmr.default'></span><span id='topic+bmr.escalc'></span><span id='topic+print.bmr'></span><span id='topic+plot.bmr'></span><span id='topic+pairs.bmr'></span>

<h3>Description</h3>

<p>This function allows to derive the posterior distribution of the
parameters in a random-effects meta-regression and provides functions to
evaluate joint and marginal posterior probability distributions, etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  bmr(y, ...)
  ## Default S3 method:
bmr(y, sigma, labels = names(y),
    X = matrix(1.0, nrow=length(y), ncol=1,
               dimnames=list(labels,"intercept")),
    tau.prior = "uniform",
    beta.prior.mean = NULL,
    beta.prior.sd = NULL,
    beta.prior.cov = diag(beta.prior.sd^2,
                          nrow=length(beta.prior.sd),
                          ncol=length(beta.prior.sd)),
    interval.type = c("shortest", "central"),
    delta = 0.01, epsilon = 0.0001,
    rel.tol.integrate = 2^16*.Machine$double.eps,
    abs.tol.integrate = 0.0,
    tol.uniroot = rel.tol.integrate, ...)
  ## S3 method for class 'escalc'
bmr(y, labels = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="bmr_+3A_y">y</code></td>
<td>

<p>vector of estimates, <em>or</em> an <code><a href="metafor.html#topic+escalc">escalc</a></code> object.
</p>
</td></tr>
<tr><td><code id="bmr_+3A_sigma">sigma</code></td>
<td>

<p>vector of standard errors associated with <code>y</code>.
</p>
</td></tr>
<tr><td><code id="bmr_+3A_labels">labels</code></td>
<td>

<p>(optional) a vector of labels corresponding to <code>y</code> and <code>sigma</code>.
</p>
</td></tr>
<tr><td><code id="bmr_+3A_x">X</code></td>
<td>

<p>(optional) the <em>regressor matrix</em> for the regression.
</p>
</td></tr>
<tr><td><code id="bmr_+3A_tau.prior">tau.prior</code></td>
<td>

<p>a <code>function</code> returning the prior density for the heterogeneity
parameter (<code class="reqn">\tau</code>) <em>or</em> a <code>character</code> string
specifying one of the <em>default &lsquo;non-informative&rsquo;
priors</em>; possible choices for the latter case are: 
</p>

<ul>
<li> <p><code>"uniform"</code>: a uniform prior in <code class="reqn">\tau</code>
</p>
</li>
<li> <p><code>"sqrt"</code>: a uniform prior in <code class="reqn">\sqrt{\tau}</code>
</p>
</li>
<li> <p><code>"Jeffreys"</code>: the Jeffreys prior for <code class="reqn">\tau</code>
</p>
</li>
<li> <p><code>"BergerDeely"</code>: the prior due to Berger and Deely (1988)
</p>
</li>
<li> <p><code>"conventional"</code>: the conventional prior
</p>
</li>
<li> <p><code>"DuMouchel"</code>: the DuMouchel prior
</p>
</li>
<li> <p><code>"shrinkage"</code>: the &lsquo;uniform shrinkage&rsquo; prior
</p>
</li>
<li> <p><code>"I2"</code>: a uniform prior on the &lsquo;relative heterogeneity&rsquo; <code class="reqn">I^2</code>
</p>
</li></ul>

<p>The default is <code>"uniform"</code> (which should be used with
caution). The above priors are described in some more detail in the
<code><a href="#topic+bayesmeta">bayesmeta</a>()</code> help.
</p>
</td></tr>
<tr><td><code id="bmr_+3A_beta.prior.mean">beta.prior.mean</code>, <code id="bmr_+3A_beta.prior.sd">beta.prior.sd</code>, <code id="bmr_+3A_beta.prior.cov">beta.prior.cov</code></td>
<td>

<p>the mean and standard deviations, or covariance of the normal prior
distribution for the effects <code class="reqn">\beta</code>. If unspecified, an
(improper) uniform prior is used.
</p>
</td></tr>
<tr><td><code id="bmr_+3A_interval.type">interval.type</code></td>
<td>

<p>the type of (credible, prediction, shrinkage) interval to be
returned by default; either <code>"shortest"</code> for shortest
intervals, or <code>"central"</code> for central, equal-tailed intervals.
</p>
</td></tr>
<tr><td><code id="bmr_+3A_delta">delta</code>, <code id="bmr_+3A_epsilon">epsilon</code></td>
<td>

<p>the parameters specifying the desired accuracy for approximation of
the <code class="reqn">\beta</code> posterior(s), and with that determining the number of
<code class="reqn">\tau</code> support points being used internally. Smaller values
imply greater accuracy and greater computational burden (Roever and
Friede, 2017).
</p>
</td></tr>
<tr><td><code id="bmr_+3A_rel.tol.integrate">rel.tol.integrate</code>, <code id="bmr_+3A_abs.tol.integrate">abs.tol.integrate</code>, <code id="bmr_+3A_tol.uniroot">tol.uniroot</code></td>
<td>

<p>the <code>rel.tol</code>, <code>abs.tol</code> and <code>tol</code>
&lsquo;accuracy&rsquo; arguments that are passed to
the <code><a href="stats.html#topic+integrate">integrate</a>()</code> or <code><a href="stats.html#topic+uniroot">uniroot</a>()</code> functions
for internal numerical integration or root finding
(see also the help there).
</p>
</td></tr>
<tr><td><code id="bmr_+3A_...">...</code></td>
<td>

<p>other <code>bmr</code> arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The random-effects meta-regression model may be stated as
</p>
<p style="text-align: center;"><code class="reqn">y_i|x_i,\beta,\sigma_i,\tau \;\sim\; \mathrm{Normal}(\beta_1 x_{i,1}
    + \beta_2 x_{i,2} + \ldots + \beta_d x_{i,d}, \;
    \sigma_i^2 + \tau^2)</code>
</p>

<p>where the data (<code class="reqn">y</code>, <code class="reqn">\sigma</code>) enter as <code class="reqn">y_i</code>, the
<code class="reqn">i</code>-th estimate, that is associated with standard error
<code class="reqn">\sigma_i &gt; 0</code>, where <code class="reqn">i=1,...,k</code>. In addition to
estimates and standard errors for the <code class="reqn">i</code>th observation,
a set of covariables <code class="reqn">x_{i,j}</code> with <code class="reqn">j=1,...,d</code> are available
for each estimate <code class="reqn">y_i</code>.
</p>
<p>The model includes <code class="reqn">d+1</code> unknown parameters,
namely, the <code class="reqn">d</code> coefficients (<code class="reqn">\beta_1,...,\beta_d</code>), and the heterogeneity
<code class="reqn">\tau</code>. Alternatively, the model may also be formulated via an
intermediate step as
</p>
<p style="text-align: center;"><code class="reqn">y_i|\theta_i,\sigma_i \;\sim\; \mathrm{Normal}(\theta_i, \, \sigma_i^2),</code>
</p>

<p style="text-align: center;"><code class="reqn">\theta_i|\beta,x_i,\tau \;\sim\; \mathrm{Normal}(\beta_1 x_{i,1}
  + \ldots + \beta_d x_{i,d}, \; \tau^2),</code>
</p>

<p>where the <code class="reqn">\theta_i</code> denote the <em>trial-specific</em> means
that are then measured through the estimate <code class="reqn">y_i</code> with an
associated measurement uncertainty <code class="reqn">\sigma_i</code>. The
<code class="reqn">\theta_i</code> again differ from trial to trial (even for
identical covariable vectors <code class="reqn">x_i</code>) and are
distributed around a mean of <code class="reqn">\beta_1 x_{i,1}
  + \ldots + \beta_d x_{i,d}</code> with
standard deviation <code class="reqn">\tau</code>.
</p>
<p>It if often convenient to express the model in matrix notation, i.e.,
</p>
<p style="text-align: center;"><code class="reqn">y|\theta,\sigma \;\sim\; \mathrm{Normal}(\theta, \,
    \Sigma)</code>
</p>

<p style="text-align: center;"><code class="reqn">\theta|X,\beta,\tau \;\sim\; \mathrm{Normal}(X \beta, \,
    \tau I)</code>
</p>

<p>where <code class="reqn">y</code>, <code class="reqn">\sigma</code>, <code class="reqn">\beta</code> and <code class="reqn">\theta</code> now denote
<code class="reqn">k</code>-dimensional vectors, <code class="reqn">X</code> is the (<code class="reqn">k \times d</code>) <em>regressor matrix</em>, and <code class="reqn">\Sigma</code> is a (<code class="reqn">k \times k</code>) diagonal covariance matrix containing the
<code class="reqn">\sigma_i^2</code> values, while
<code class="reqn">I</code> is the (<code class="reqn">k \times k</code>) identity matrix. The
regressor matrix <code class="reqn">X</code> plays a crucial role here, as the
&lsquo;<code>X</code>&rsquo; argument (with rows corresponding to studies, and
columns corresponding to covariables) is required to specify the exact
regression setup.
</p>
<p>Meta-regression allows the consideration of (study-level) covariables
in a meta-analysis. Quite often, these may also be indicator variables
(&lsquo;zero/one&rsquo; variables) simply identifying subgroups of studies.
See also the examples shown below.
</p>


<h4>Connection to the simple random-effects model</h4>

<p>The meta-regression model is a generalisation of the &lsquo;simple&rsquo;
random-effects model that is implemented in the
<code><a href="#topic+bayesmeta">bayesmeta</a>()</code> function. Meta-regression reduces to the
estimation of a single &ldquo;intercept&rdquo; term when the regressor
matrix (<code class="reqn">X</code>) consists of a single column of
ones (which is also the default setting in case the &lsquo;<code>X</code>&rsquo;
argument is left unspecified). The single regression coefficient
<code class="reqn">\beta_1</code> then is equivalent to the <code class="reqn">\mu</code> parameter
from the simple random effects model (see also the &lsquo;Examples&rsquo;
section below).
</p>



<h4>Specification of the regressor matrix</h4>

<p> The actual
regression model is specified through the regressor matrix <code class="reqn">X</code>,
which is supplied via the &lsquo;<code>X</code>&rsquo; argument, and which
often may be specified in different ways. There usually is no unique
solution, and what serves the present purpose best then depends on
the context; see also the examples below. Sensible column names
should be specified for <code>X</code>, as these will subsequently
determine the labels for the associated parameters later on. Model
specification via the regressor matrix has the advantage of being
very explicit and transparent; if one prefers a
<code><a href="stats.html#topic+formula">formula</a></code> interface instead, a regressor matrix may
be generated via the &lsquo;<code><a href="stats.html#topic+model.matrix">model.matrix</a>()</code>&rsquo;
function.
</p>



<h4>Prior specification</h4>

<p>Priors for <code class="reqn">\beta</code> and <code class="reqn">\tau</code> are assumed to factor into
into independent marginals <code class="reqn">p(\beta,\tau)=p(\beta)\times
  p(\tau)</code> and either (improper)
uniform or a normal priors may be specified for the regression coefficients
<code class="reqn">\beta</code>. 
For sensible prior choices for the heterogeneity parameter <code class="reqn">\tau</code>,
see also Roever (2020), Roever <em>et al.</em> (2021) and the
&lsquo;<code><a href="#topic+bayesmeta">bayesmeta</a>()</code>&rsquo; function's help.
</p>



<h4>Accessing posterior density functions, etc.</h4>

<p>Within the <code><a href="#topic+bayesmeta">bayesmeta</a>()</code> function, access to posterior
density, cumulative distribution function, quantile functtion,
random number generation and posterior inverval computation is
implemented via the <code>$dposterior()</code>, <code>$dposterior()</code>,
<code>$pposterior()</code>, <code>$qposterior()</code>, <code>$rposterior()</code>
and <code>$post.interval()</code> functions that are accessible as elements
in the returned <code>list</code> object. Prediction and shrinkage
estimation are available by setting additional arguments in the
above functions.
</p>
<p>In the meta-regression context things get slightly more complicated,
as the <code class="reqn">\beta</code> parameter may be of higher dimension. Hence, in the
<code>bmr()</code> function, the three different types of distributions
related to <em>posterior distribution</em>, <em>prediction</em> and
<em>shrinkage</em> are split up into three groups of
functions. For example, the posterior density is accessible via the
<code>$dposterior()</code> function, the predictive distribution via the
<code>$dpredict()</code> function, and the shrinkage estimates via the
<code>$dshrink()</code> function. Analogous functions are returned for
cumulative distribution, quantile function, etc.; see also the
&lsquo;Value&rsquo; section below.
</p>



<h4>Computation</h4>

<p>The <code>bmr()</code> function utilizes the same computational method
as the <code><a href="#topic+bayesmeta">bayesmeta</a>()</code> function to derive the posterior
distribution, namely, the <abbr><span class="acronym">DIRECT</span></abbr> algorithm. Numerical
accuracy of the computations is determined by the &lsquo;<code>delta</code>&rsquo;
and &lsquo;<code>epsilon</code>&rsquo; arguments (Roever and Friede,
2017).
</p>
<p>A slight difference between the <code><a href="#topic+bayesmeta">bayesmeta</a>()</code> and
<code>bmr()</code> implementations exists in the determination of the grid
approximation within the <abbr><span class="acronym">DIRECT</span></abbr> algorithm. While
<code>bmr()</code> considers divergences w.r.t. the conditional posterior
distributions <code class="reqn">p(\beta|\tau)</code>, <code>bayesmeta()</code> in addition
considers divergences w.r.t. the shrinkage estimates, which in general
leads to a denser binning (as one can see from the numbers of bins
required; see the example below). A denser binning within the
<code>bmr()</code> function may be achieved by reducing the
&lsquo;<code>delta</code>&rsquo; argument.
</p>



<h3>Value</h3>

<p>A list of class <code>bmr</code> containing the following elements:
</p>
<table>
<tr><td><code>y</code></td>
<td>
<p>vector of estimates (the input data).</p>
</td></tr>
<tr><td><code>sigma</code></td>
<td>
<p>vector of standard errors corresponding
to <code>y</code> (input data).</p>
</td></tr>
<tr><td><code>X</code></td>
<td>
<p>the regressor matrix.</p>
</td></tr>
<tr><td><code>k</code></td>
<td>
<p>number of data points (length of <code>y</code>, or rows of <code class="reqn">X</code>).</p>
</td></tr>
<tr><td><code>d</code></td>
<td>
<p>number of coefficients (columns of <code>X</code>).</p>
</td></tr>
<tr><td><code>labels</code></td>
<td>
<p>vector of labels corresponding to <code>y</code> and <code>sigma</code>.</p>
</td></tr>
<tr><td><code>variables</code></td>
<td>
<p>variable names for the <code class="reqn">\beta</code> coefficients
(determined by the column names of the supplied <code>X</code> argument).</p>
</td></tr>
<tr><td><code>tau.prior</code></td>
<td>
<p>the prior probability density function for <code class="reqn">\tau</code>.</p>
</td></tr>
<tr><td><code>tau.prior.proper</code></td>
<td>
<p>a <code>logical</code> flag indicating whether the
heterogeneity prior appears to be proper (which is judged based on
an attempted numerical integration of the density function).</p>
</td></tr> 
<tr><td><code>beta.prior</code></td>
<td>
<p>a <code>list</code> containing the prior mean vector and
covariance matrix for the coefficients <code class="reqn">\beta</code>.</p>
</td></tr>
<tr><td><code>beta.prior.proper</code></td>
<td>
<p>a <code>logical</code> vector (of length <code class="reqn">d</code>)
indicating whether the corresponding <code class="reqn">\beta</code> coefficient's prior is
proper (i.e., finite prior mean and variance were specified).</p>
</td></tr> 
<tr><td><code>dprior</code></td>
<td>
<p>a <code>function(tau, beta, which.beta, log=FALSE)</code> of
<code class="reqn">\tau</code> and/or <code class="reqn">\beta</code> parameters, returning either the joint or
marginal prior probability density, depending on which parameter(s)
is/are provided.</p>
</td></tr>
<tr><td><code>likelihood</code></td>
<td>
<p>a <code>function(tau, beta, which.beta)</code> <code class="reqn">\tau</code>
and/or <code class="reqn">\beta</code>, returning either the joint or marginal
likelihood, depending on which parameter(s) is/are provided.</p>
</td></tr>
<tr><td><code>dposterior</code>, <code>pposterior</code>, <code>qposterior</code>, <code>rposterior</code>, <code>post.interval</code></td>
<td>
<p>functions of <code class="reqn">\tau</code> and/or <code class="reqn">\beta</code> parameters,
returning either the joint or marginal posterior probability density,
(depending on which parameter(s) is/are provided), or cumulative
distribution function, quantile function, random numbers or posterior intervals.</p>
</td></tr>
<tr><td><code>dpredict</code>, <code>ppredict</code>, <code>qpredict</code>, <code>rpredict</code>, <code>pred.interval</code></td>
<td>
<p>functions
of <code class="reqn">\beta</code> returning density, cumulative distribution
function, quantiles, random numbers, or intervals for the
<em>predictive distribution</em>. This requires specification of <code class="reqn">x</code>
values to indicate what covariable values to consider. Use of
&lsquo;<code>mean=TRUE</code>&rsquo; (the default) yields predictions for the
<em>mean</em> (<code class="reqn">x'\beta</code> values), setting it to
<code>FALSE</code> yields <em>predictions</em> (<code class="reqn">\theta</code> values).</p>
</td></tr>
<tr><td><code>dshrink</code>, <code>pshrink</code>, <code>qshrink</code>, <code>rshrink</code>, <code>shrink.interval</code></td>
<td>
<p>functions
of <code class="reqn">\theta</code> yielding density, cumulative distribution, quantiles,
random numbers or posterior intervals for the <em>shrinkage
estimates</em> of the individual <code class="reqn">\theta_i</code> parameters
corresponding to the supplied <code class="reqn">y_i</code> data values
(<code class="reqn">i=1,\ldots,k</code>). May be identified using the
&lsquo;<code>which</code>&rsquo; argument via its index (<code class="reqn">i</code>) or a character
string giving the corresponding study label.</p>
</td></tr>
<tr><td><code>post.moments</code></td>
<td>
<p>a <code>function(tau)</code>
returning conditional posterior moments (mean and covariance) of
<code class="reqn">\beta</code> as a function of <code class="reqn">\tau</code>.</p>
</td></tr>
<tr><td><code>pred.moments</code></td>
<td>
<p>a <code>function(tau, x, mean=TRUE)</code>
returning conditional posterior predictive moments (means and
standard deviations) as a function of <code class="reqn">\tau</code>.</p>
</td></tr>
<tr><td><code>shrink.moments</code></td>
<td>
<p>a <code>function(tau, which)</code>
returning conditional moments (means and standard deviations of
shrinkage distributions) as a function of <code class="reqn">\tau</code>.</p>
</td></tr>
<tr><td><code>summary</code></td>
<td>
<p>a <code>matrix</code> listing some summary statistics, namely
marginal posterior mode, median, mean, standard deviation
and a (shortest) 95% credible intervals,
of the marginal posterior distributions of <code class="reqn">\tau</code> and <code class="reqn">\beta_i</code>.</p>
</td></tr>
<tr><td><code>interval.type</code></td>
<td>
<p>the <code>interval.type</code> input argument
specifying the type of interval to be returned by default.</p>
</td></tr>
<tr><td><code>ML</code></td>
<td>
<p>a <code>matrix</code> giving joint and marginal maximum-likelihood
estimates of <code class="reqn">(\tau,\beta)</code>.</p>
</td></tr>
<tr><td><code>MAP</code></td>
<td>
<p>a <code>matrix</code> giving joint and marginal
maximum-a-posteriori estimates of <code class="reqn">(\tau,\beta)</code>.</p>
</td></tr>
<tr><td><code>theta</code></td>
<td>
<p>a <code>matrix</code> giving the &lsquo;shrinkage estimates&rsquo;,
i.e, summary statistics of the trial-specific means
<code class="reqn">\theta_i</code>.</p>
</td></tr> 
<tr><td><code>marginal.likelihood</code></td>
<td>
<p>the marginal likelihood of the data (this 
number can only be computed if proper effect and heterogeneity priors 
are specified).</p>
</td></tr>
<tr><td><code>bayesfactor</code></td>
<td>
<p>Bayes factors and minimum Bayes factors for the
hypotheses of <code class="reqn">\tau=0</code> and <code class="reqn">\beta_i=0</code>. These depend on the
marginal likelihood and hence can only be computed if proper effect
and/or heterogeneity priors are specified.</p>
</td></tr>
<tr><td><code>support</code></td>
<td>
<p>a <code>list</code> giving the <code class="reqn">\tau</code> support points used
internally in the grid approximation, along with their associated
weights, and conditional mean and covariance of <code class="reqn">\beta</code>.</p>
</td></tr>
<tr><td><code>delta</code>, <code>epsilon</code></td>
<td>
<p>the &lsquo;<code>delta</code>&rsquo; and &lsquo;<code>epsilon</code>&rsquo;
input parameter determining numerical accuracy.</p>
</td></tr>
<tr><td><code>rel.tol.integrate</code>, <code>abs.tol.integrate</code>, <code>tol.uniroot</code></td>
<td>
<p>the input
parameters determining the numerical accuracy of the internally used
<code><a href="stats.html#topic+integrate">integrate</a>()</code> and <code><a href="stats.html#topic+uniroot">uniroot</a>()</code> functions.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>an object of class <code>call</code> giving the
function call that generated the <code>bmr</code> object.</p>
</td></tr>
<tr><td><code>init.time</code></td>
<td>
<p>the computation time (in seconds) used to generate
the <code>bmr</code> object.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Roever <a href="mailto:christian.roever@med.uni-goettingen.de">christian.roever@med.uni-goettingen.de</a>
</p>


<h3>References</h3>

<p>C. Roever, T. Friede.
Using the bayesmeta R package for Bayesian random-effects meta-regression.
<em>Computer Methods and Programs in Biomedicine</em>,
<b>299</b>:107303, 2023.
<a href="https://doi.org/10.1016/j.cmpb.2022.107303">doi:10.1016/j.cmpb.2022.107303</a>.
</p>
<p>C. Roever.
Bayesian random-effects meta-analysis using the bayesmeta R package.
<em>Journal of Statistical Software</em>, <b>93</b>(6):1-51, 2020.
<a href="https://doi.org/10.18637/jss.v093.i06">doi:10.18637/jss.v093.i06</a>.
</p>
<p>C. Roever, R. Bender, S. Dias, C.H. Schmid, H. Schmidli, S. Sturtz,
S. Weber, T. Friede.
On weakly informative prior distributions for the heterogeneity
parameter in Bayesian random-effects meta-analysis.
<em>Research Synthesis Methods</em>, <b>12</b>(4):448-474, 2021.
<a href="https://doi.org/10.1002/jrsm.1475">doi:10.1002/jrsm.1475</a>.
</p>
<p>C. Roever, T. Friede.
Discrete approximation of a mixture distribution via restricted divergence.
<em>Journal of Computational and Graphical Statistics</em>,
<b>26</b>(1):217-222, 2017.
<a href="https://doi.org/10.1080/10618600.2016.1276840">doi:10.1080/10618600.2016.1276840</a>.
</p>
<p>A. Gelman, J.B. Carlin, H.S. Stern, D.B. Rubin. <em>Bayesian data
analysis</em>. Chapman &amp; Hall / CRC, Boca Raton, 1997.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesmeta">bayesmeta</a></code>, <code><a href="metafor.html#topic+escalc">escalc</a></code>,
<code><a href="stats.html#topic+model.matrix">model.matrix</a></code>, <code><a href="#topic+CrinsEtAl2014">CrinsEtAl2014</a></code>,
<code><a href="#topic+RobergeEtAl2017">RobergeEtAl2017</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
######################################################################
# (1)  A simple example with two groups of studies

# load data:
data("CrinsEtAl2014")
# compute effect measures (log-OR):
crins.es &lt;- escalc(measure="OR",
                   ai=exp.AR.events,  n1i=exp.total,
                   ci=cont.AR.events, n2i=cont.total,
                   slab=publication, data=CrinsEtAl2014)
# show data:
crins.es[,c("publication", "IL2RA", "exp.AR.events", "exp.total",
            "cont.AR.events", "cont.total", "yi", "vi")]

# specify regressor matrix:
X &lt;- cbind("bas"=as.numeric(crins.es$IL2RA=="basiliximab"),
           "dac"=as.numeric(crins.es$IL2RA=="daclizumab"))
print(X)
print(cbind(crins.es[,c("publication", "IL2RA")], X))
# NB: regressor matrix specifies individual indicator covariates
#     for studies with "basiliximab" and "daclizumab" treatment.

# perform regression:
bmr01 &lt;- bmr(y=crins.es$yi, sigma=sqrt(crins.es$vi),
             labels=crins.es$publication, X=X)

# alternatively, one may simply supply the "escalc" object
# (yields identical results):
bmr01 &lt;- bmr(crins.es, X=X)

# show results:
bmr01
bmr01$summary
plot(bmr01)
pairs(bmr01)

# NOTE: there are many ways to set up the regressor matrix "X"
# (also affecting the interpretation of the involved parameters).
# See the above specification and check out the following alternatives:
X &lt;- cbind("bas"=1, "offset.dac"=c(1,0,1,0,0,0))
X &lt;- cbind("intercept"=1, "offset"=0.5*c(1,-1,1,-1,-1,-1))
# One may also use the "model.matrix()" function
# to specify regressor matrices via the "formula" interface; e.g.:
X &lt;- model.matrix( ~ IL2RA, data=crins.es)
X &lt;- model.matrix( ~ IL2RA - 1, data=crins.es)


######################################################################
# (2)  A simple example reproducing a "bayesmeta" analysis:

data("CrinsEtAl2014")
crins.es &lt;- escalc(measure="OR",
                   ai=exp.AR.events,  n1i=exp.total,
                   ci=cont.AR.events, n2i=cont.total,
                   slab=publication, data=CrinsEtAl2014)

# a "simple" meta-analysis:
bma02 &lt;- bayesmeta(crins.es,
                   tau.prior=function(t){dhalfnormal(t, scale=0.5)},
                   mu.prior.mean=0, mu.prior.sd=4)

# the equivalent "intercept-only" meta-regression:
bmr02 &lt;- bmr(crins.es,
             tau.prior=function(t){dhalfnormal(t, scale=0.5)},
             beta.prior.mean=0, beta.prior.sd=4)
# the corresponding (default) regressor matrix:
bmr02$X

# compare computation time and numbers of bins used internally:
cbind("seconds" = c("bayesmeta" = unname(bma02$init.time),
                    "bmr"       = unname(bmr02$init.time)),
      "bins"    = c("bayesmeta" = nrow(bma02$support),
                    "bmr"       = nrow(bmr02$support$tau)))

# compare heterogeneity estimates:
rbind("bayesmeta"=bma02$summary[,1], "bmr"=bmr02$summary[,1])

# compare effect estimates:
rbind("bayesmeta"=bma02$summary[,2], "bmr"=bmr02$summary[,2])


######################################################################
# (3)  An example with binary as well as continuous covariables:

# load data:
data("RobergeEtAl2017")
str(RobergeEtAl2017)
head(RobergeEtAl2017)
?RobergeEtAl2017

# compute effect sizes (log odds ratios) from count data:
es.pe  &lt;- escalc(measure="OR",
                 ai=asp.PE.events,  n1i=asp.PE.total,
                 ci=cont.PE.events, n2i=cont.PE.total,
                 slab=study, data=RobergeEtAl2017,
                 subset=complete.cases(RobergeEtAl2017[,7:10]))

# show "bubble plot" (bubble sizes are
# inversely proportional to standard errors):
plot(es.pe$dose, es.pe$yi, cex=1/sqrt(es.pe$vi),
     col=c("blue","red")[as.numeric(es.pe$onset)],
     xlab="dose (mg)", ylab="log-OR (PE)", main="Roberge et al. (2017)")
legend("topright", col=c("blue","red"), c("early onset", "late onset"), pch=1)

# set up regressor matrix:
# (individual intercepts and slopes for two subgroups):
X &lt;- model.matrix(~ -1 + onset + onset:dose, data=es.pe)
colnames(X) &lt;- c("intEarly", "intLate", "slopeEarly", "slopeLate")
# check out regressor matrix (and compare to original data):
print(X)

# perform regression:
bmr03 &lt;- bmr(es.pe, X=X)
bmr03$summary

# derive predictions from the model;
# specify corresponding "regressor matrices":
newx.early &lt;- cbind(1, 0, seq(50, 150, by=5), 0)
newx.late  &lt;- cbind(0, 1, 0, seq(50, 150, by=5))
# (note: columns correspond to "beta" parameters)

# compute predicted medians and 95 percent intervals: 
pred.early &lt;- cbind("median"=bmr03$qpred(0.5, x=newx.early),
                    bmr03$pred.interval(x=newx.early))
pred.late &lt;- cbind("median"=bmr03$qpred(0.5, x=newx.late),
                    bmr03$pred.interval(x=newx.late))

# draw "bubble plot": 
plot(es.pe$dose, es.pe$yi, cex=1/sqrt(es.pe$vi),
     col=c("blue","red")[as.numeric(es.pe$onset)],
     xlab="dose (mg)", ylab="log-OR (PE)", main="Roberge et al. (2017)")
legend("topright", col=c("blue","red"), c("early onset", "late onset"), pch=1)
# add predictions to bubble plot:
matlines(newx.early[,3], pred.early, col="blue", lty=c(1,2,2))
matlines(newx.late[,4], pred.late, col="red", lty=c(1,2,2))


## End(Not run)
</code></pre>

<hr>
<h2 id='BucherEtAl1997'>Direct and indirect comparison example data</h2><span id='topic+BucherEtAl1997'></span>

<h3>Description</h3>

<p>Numbers of subjects and events in the different treatment arms of 22 studies.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("BucherEtAl1997")</code></pre>


<h3>Format</h3>

<p>The data frame contains the following columns:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <b>study</b>        </td><td style="text-align: left;"> <code>character</code> </td><td style="text-align: left;"> publication identifier (first author and publication year) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>treat.A</b>      </td><td style="text-align: left;"> <code>factor</code>    </td><td style="text-align: left;"> treatment in first study arm (&ldquo;TMP-SMX&rdquo; or &ldquo;AP&rdquo;) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>treat.B</b>      </td><td style="text-align: left;"> <code>factor</code>    </td><td style="text-align: left;"> treatment in second study arm (&ldquo;D/P&rdquo; or &ldquo;AP&rdquo;) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>events.A</b>     </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of events in first study arm </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>events.B</b>     </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of events in second study arm </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>total.A</b>      </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> total number of patients in first study arm </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>total.B</b>      </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> total number of patients in second study arm </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Details</h3>

<p>Bucher <em>et al.</em> (1997) discussed the example case of the
comparison of <em>sulphametoxazole-trimethoprim (TMP-SMX)</em> versus
<em>dapsone/pyrimethamine (D/P)</em> for the prophylaxis of
<em>Pneumocystis carinii</em> pneumonia in HIV patients. Eight
studies had undertaken a head-to-head comparison of both medications,
but an additional 14 studies were available investigating one of the
two medications with <em>aerosolized pentamidine (AP)</em> as a
comparator. Nine studies compared TMP-SMX vs. AP, and five studies
compared D/P vs. AP. Together these provide <em>indirect</em> evidence
on the effect of TMP-SMX compared to D/P (Kiefer <em>et al.</em>, 2015).
</p>
<p>The example constitutes a simple case of a <em>network meta-analysis
(NMA)</em> setup, where only two-armed studies are considered, and
analysis is based on pairwise comparisons of treatments (or
<em>contrasts</em>). In this case, the joint analysis of <em>direct</em>
and <em>indirect</em> evidence may be implemented as a special case of a
meta-regression (Higgins <em>et al.</em>, 2019; Sec. 11.4.2).
The original data in fact included some three-armed studies, in which
case one of the arms was deliberately omitted (Bucher <em>et al.</em>; 1997).
</p>


<h3>Source</h3>

<p>H.C. Bucher, G.H. Guyatt, L.E. Griffith, S.D. Walter.
The results of direct and indirect treatment comparisons 
in meta-analysis of randomized controlled trials.
<em>Journal of Clinical Epidemiology</em>, <b>50</b>(6):683-691, 1997.
<a href="https://doi.org/10.1016/S0895-4356%2897%2900049-8">doi:10.1016/S0895-4356(97)00049-8</a>.
</p>


<h3>References</h3>

<p>C. Roever, T. Friede.
Using the bayesmeta R package for Bayesian random-effects meta-regression.
<em>Computer Methods and Programs in Biomedicine</em>,
<b>299</b>:107303, 2023.
<a href="https://doi.org/10.1016/j.cmpb.2022.107303">doi:10.1016/j.cmpb.2022.107303</a>.
</p>
<p>J.P.T. Higgins, J. Thomas, J. Chandler, M. Cumpston, T. Li,
M.J. Page, V.A. Welch (eds.).
<em>Cochrane handbook for systematic reviews of interventions</em>.
Wiley and Sons, 2nd edition, 2019.
<a href="https://doi.org/10.1002/9781119536604">doi:10.1002/9781119536604</a>.
<a href="http://training.cochrane.org/handbook">http://training.cochrane.org/handbook</a>.
</p>
<p>C. Kiefer, S. Sturtz, R. Bender.
Indirect comparisons and network meta-analyses.
<em>Deutsches Aerzteblatt International</em>,
<b>112</b>(47):803-808, 2015.
<a href="https://doi.org/10.3238/arztebl.2015.0803">doi:10.3238/arztebl.2015.0803</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data:
data("BucherEtAl1997")

# show data:
head(BucherEtAl1997)

## Not run: 
# compute effect sizes (log-ORs for pairwise comparisons)
# from the count data:
es &lt;- escalc(measure="OR",
             ai=events.A, n1i=total.A,   # "exposure group"
             ci=events.B, n2i=total.B,   # "control group"
             slab=study, data=BucherEtAl1997)

# specify regressor matrix:
X &lt;- cbind("TMP.DP" = rep(c(1, 0, 1), c(8,5,9)),
           "AP.DP"  = rep(c(0, 1,-1), c(8,5,9)))

# perform Bayesian meta-regression:
bmr01 &lt;- bmr(es, X=X)

# show default output:
print(bmr01)

# specify contrast matrix:
contrastX &lt;- rbind("TMP-SMX vs. D/P"=c(1,0),
                   "AP vs. D/P"     =c(0,1),
                   "TMP-SMX vs. AP" =c(1,-1))
# show summary including contrast estimates:
summary(bmr01, X.mean=contrastX)
# show forest plot including contrast estimates:
forestplot(bmr01, X.mean=contrastX, xlab="log-OR")


# perform frequentist meta-regression:
fmr01 &lt;- rma(es, mods=X, intercept=FALSE)
print(fmr01)

# compare Bayesian and frequentist results;
# estimated log-OR for "TMP-SMX" vs. "D/P"
rbind("bayesmeta"=bmr01$summary[c("mean","sd"),"TMP.DP"],
      "rma"      =c(fmr01$beta["TMP.DP",], fmr01$se[1]))

# estimated log-OR for "AP" vs. "D/P"
rbind("bayesmeta"=bmr01$summary[c("mean","sd"),"AP.DP"],
      "rma"      =c(fmr01$beta["AP.DP",], fmr01$se[2]))

# estimated heterogeneity:
rbind("bayesmeta"=bmr01$summary["median","tau"],
      "rma"      =sqrt(fmr01$tau2))

## End(Not run)
</code></pre>

<hr>
<h2 id='Cochran1954'>Fly counts example data</h2><span id='topic+Cochran1954'></span>

<h3>Description</h3>

<p>This data set gives average estimated counts of flies along
with standard errors from 7 different observers.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Cochran1954")</code></pre>


<h3>Format</h3>

<p>The data frame contains the following columns:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <b>observer</b> </td><td style="text-align: left;"> <code>character</code> </td><td style="text-align: left;"> identifier </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>mean</b>     </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> mean count </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>se2</b>      </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> <em>squared</em> standard error 
  </td>
</tr>

</table>



<h3>Details</h3>

<p>Quoting from Cochran (1954), example 3, p.119:
&ldquo;In studies by the U.S. Public Health Service of observers'
abilities to count the number of flies which settle momentarily on a
grill, each of 7 observers was shown, for a brief period, grills
with known numbers of flies impaled on them and asked to estimate
the numbers. For a given grill, each observer made 5 independent
estimates. The data in table 9 are for a grill which actually
contained 161 flies. Estimated variances are based on 4 degrees of
freedom each. [...] The only point of interest in estimating the
overall mean is to test whether there is any consistent bias among
observers in estimating the 161 flies on the grill. Although
inspection of table 9 suggests no such bias, the data will serve
to illustrate the application of partial weighting.&rdquo; 
</p>


<h3>Source</h3>

<p>W.G. Cochran. The combination of estimates from different experiments.
<em>Biometrics</em>, <b>10</b>(1):101-129, 1954.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Cochran1954")
## Not run: 
# analysis using improper uniform prior
# (may take a few seconds to compute!):
bma &lt;- bayesmeta(y=Cochran1954[,"mean"], sigma=sqrt(Cochran1954[,"se2"]),
                 label=Cochran1954[,"observer"])

# show joint posterior density:
plot(bma, which=2, main="Cochran example")
# show (known) true parameter value:
abline(h=161)

# show forest plot:
forestplot(bma, zero=161)

## End(Not run)
</code></pre>

<hr>
<h2 id='convolve'>Convolution of two probability distributions</h2><span id='topic+convolve'></span>

<h3>Description</h3>

<p>Compute the convolution of two probability distributions, specified
through their densities or cumulative distribution functions (CDFs).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  convolve(dens1, dens2,
           cdf1=Vectorize(function(x){integrate(dens1,-Inf,x)$value}),
           cdf2=Vectorize(function(x){integrate(dens2,-Inf,x)$value}),
           delta=0.01, epsilon=0.0001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="convolve_+3A_dens1">dens1</code>, <code id="convolve_+3A_dens2">dens2</code></td>
<td>
<p>the two distributions' probability density functions.</p>
</td></tr>
<tr><td><code id="convolve_+3A_cdf1">cdf1</code>, <code id="convolve_+3A_cdf2">cdf2</code></td>
<td>
<p>the two distributions' cumulative distribution functions.</p>
</td></tr>
<tr><td><code id="convolve_+3A_delta">delta</code>, <code id="convolve_+3A_epsilon">epsilon</code></td>
<td>
<p>the parameters specifying the desired accuracy
for approximation of the convolution, and with that determining the
number of support points being used internally. Smaller values
imply greater accuracy and greater computational burden (Roever and
Friede, 2017).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The distribution of the <em>sum</em> of two (independent) random
variables technically results as a <em>convolution</em> of their
probability distributions. In some cases, the calculation of
convolutions may be done analytically; e.g., the sum of two normally
distributed random variables again turns out as normally distributed
(with mean and variance resulting as the sums of the original ones).
In other cases, convolutions may need to be determined
numerically. One way to achieve this is via the <em>DIRECT</em>
algorithm; the present implementation is the one discussed by Roever
and Friede (2017). Accuracy of the computations is determined by the
<code>delta</code> (maximum divergence <code class="reqn">\delta</code>) and <code>epsilon</code>
(tail probability <code class="reqn">\epsilon</code>) parameters.
</p>
<p>Convolutions here are used within the <code><a href="metafor.html#topic+funnel">funnel</a>()</code> function (to
generate funnel plots), but are often useful more generally. The
original probability distributions may be specified via their
probability density functions or their cumulative distribution
functions (CDFs). The <code>convolve()</code> function returns the
convolution's density, CDF and quantile function (inverse CDF).
</p>


<h3>Value</h3>

<p>A <code>list</code> with elements
</p>
<table>
<tr><td><code>delta</code></td>
<td>
<p>the <code class="reqn">\delta</code> parameter.</p>
</td></tr>
<tr><td><code>epsilon</code></td>
<td>
<p>the <code class="reqn">\epsilon</code> parameter.</p>
</td></tr>
<tr><td><code>binwidth</code></td>
<td>
<p>the bin width.</p>
</td></tr>
<tr><td><code>bins</code></td>
<td>
<p>the total number of bins.</p>
</td></tr>
<tr><td><code>support</code></td>
<td>
<p>a <code>matrix</code> containing the support points used
internally for the convolution approximation.</p>
</td></tr>
<tr><td><code>density</code></td>
<td>
<p>the probability density function.</p>
</td></tr>
<tr><td><code>cdf</code></td>
<td>
<p>the cumulative distribution function (CDF).</p>
</td></tr>
<tr><td><code>quantile</code></td>
<td>
<p>the quantile function (inverse CDF).</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Roever <a href="mailto:christian.roever@med.uni-goettingen.de">christian.roever@med.uni-goettingen.de</a>
</p>


<h3>References</h3>

<p>C. Roever, T. Friede.
Discrete approximation of a mixture distribution via restricted divergence.
<em>Journal of Computational and Graphical Statistics</em>,
<b>26</b>(1):217-222, 2017.
<a href="https://doi.org/10.1080/10618600.2016.1276840">doi:10.1080/10618600.2016.1276840</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesmeta">bayesmeta</a></code>, <code><a href="metafor.html#topic+funnel">funnel</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#  Skew-normal / logistic example:

dens1 &lt;- function(x, shape=4)
# skew-normal distribution's density
# see also: http://azzalini.stat.unipd.it/SN/Intro
{
  return(2 * dnorm(x) * pnorm(shape * x))
}

dens2 &lt;- function(x)
# logistic distribution's density
{
  return(dlogis(x, location=0, scale=1))
}

rskewnorm &lt;- function(n, shape=4)
# skew-normal random number generation
# (according to http://azzalini.stat.unipd.it/SN/faq-r.html)
{
  delta &lt;- shape / sqrt(shape^2+1)
  u1 &lt;- rnorm(n); v &lt;- rnorm(n)
  u2 &lt;- delta * u1 + sqrt(1-delta^2) * v
  return(apply(cbind(u1,u2), 1, function(x){ifelse(x[1]&gt;=0, x[2], -x[2])}))
}

# compute convolution:
conv &lt;- convolve(dens1, dens2)

# illustrate convolution:
n &lt;- 100000
x &lt;- rskewnorm(n)
y &lt;- rlogis(n)
z &lt;- x + y

# determine empirical and theoretical quantiles:
p      &lt;- c(0.001,0.01, 0.1, 0.5, 0.9, 0.99, 0.999)
equant &lt;- quantile(z, prob=p)
tquant &lt;- conv$quantile(p)

# show numbers:
print(cbind("p"=p, "empirical"=equant, "theoretical"=tquant))

# draw Q-Q plot:
rg &lt;- range(c(equant, tquant))
plot(rg, rg, type="n", asp=1, main="Q-Q-plot",
     xlab="theoretical quantile", ylab="empirical quantile")
abline(0, 1, col="grey")
points(tquant, equant)

## End(Not run)
</code></pre>

<hr>
<h2 id='CrinsEtAl2014'>Pediatric liver transplant example data</h2><span id='topic+CrinsEtAl2014'></span>

<h3>Description</h3>

<p>Numbers of cases (transplant patients) and events (acute rejections,
steroid resistant rejections, PTLDs, and deaths) in experimental and control groups of
six studies.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("CrinsEtAl2014")</code></pre>


<h3>Format</h3>

<p>The data frame contains the following columns:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <b>publication</b>         </td><td style="text-align: left;"> <code>character</code> </td><td style="text-align: left;"> publication identifier (first author and publication year) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>year</b>                </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> publication year </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>randomized</b>          </td><td style="text-align: left;"> <code>factor</code>    </td><td style="text-align: left;"> randomization status (y/n) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>control.type</b>        </td><td style="text-align: left;"> <code>factor</code>    </td><td style="text-align: left;"> type of control group (&lsquo;concurrent&rsquo; or &lsquo;historical&rsquo;)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>comparison</b>          </td><td style="text-align: left;"> <code>factor</code>    </td><td style="text-align: left;"> type of comparison (&lsquo;IL-2RA only&rsquo;, &lsquo;delayed CNI&rsquo;, or &lsquo;no/low steroids&rsquo;) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>IL2RA</b>               </td><td style="text-align: left;"> <code>factor</code>    </td><td style="text-align: left;"> type of interleukin-2 receptor antagonist (IL-2RA) (&lsquo;basiliximab&rsquo; or &lsquo;daclizumab&rsquo;) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>CNI</b>                 </td><td style="text-align: left;"> <code>factor</code>    </td><td style="text-align: left;"> type of calcineurin inhibitor (CNI) (&lsquo;tacrolimus&rsquo; or &lsquo;cyclosporine A&rsquo;) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>MMF</b>                 </td><td style="text-align: left;"> <code>factor</code>    </td><td style="text-align: left;"> use of mycofenolate mofetil (MMF) (y/n) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>followup</b>            </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> follow-up time in months </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>treat.AR.events</b>     </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of AR events in experimental group </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>treat.SRR.events</b>    </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of SRR events in experimental group </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>treat.PTLD.events</b>   </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of PTLD events in experimental group </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>treat.deaths</b>        </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of deaths in experimental group </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>treat.total</b>         </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of cases in experimental group </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>control.AR.events</b>   </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of AR events in control group </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>control.SRR.events</b>  </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of SRR events in control group </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>control.PTLD.events</b> </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of PTLD events in control group </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>control.deaths</b>      </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of deaths in control group </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>control.total</b>       </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of cases in control group </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Details</h3>

<p>A systematic literature review investigated the evidence on the
effect of Interleukin-2 receptor antagonists (IL-2RA) and resulted in
six controlled studies reporting acute rejection (AR),
steroid-resistant rejection (SRR) and post-transplant
lymphoproliferative disorder (PTLD) rates as well as mortality in
pediatric liver transplant recipients.
</p>


<h3>Source</h3>

<p>N.D. Crins, C. Roever, A.D. Goralczyk, T. Friede.
Interleukin-2 receptor antagonists for pediatric liver transplant
recipients: A systematic review and meta-analysis of controlled
studies.
<em>Pediatric Transplantation</em>, <b>18</b>(8):839-850, 2014.
<a href="https://doi.org/10.1111/petr.12362">doi:10.1111/petr.12362</a>.
</p>


<h3>References</h3>

<p>C. Roever.
Bayesian random-effects meta-analysis using the bayesmeta R package.
<em>Journal of Statistical Software</em>, <b>93</b>(6):1-51, 2020.
<a href="https://doi.org/10.18637/jss.v093.i06">doi:10.18637/jss.v093.i06</a>.
</p>
<p>C. Roever, T. Friede.
Using the bayesmeta R package for Bayesian random-effects meta-regression.
<em>Computer Methods and Programs in Biomedicine</em>,
<b>299</b>:107303, 2023.
<a href="https://doi.org/10.1016/j.cmpb.2022.107303">doi:10.1016/j.cmpb.2022.107303</a>.
</p>
<p>T.G. Heffron et al.
Pediatric liver transplantation with daclizumab induction therapy.
<em>Transplantation</em>, <b>75</b>(12):2040-2043, 2003.
<a href="https://doi.org/10.1097/01.TP.0000065740.69296.DA">doi:10.1097/01.TP.0000065740.69296.DA</a>.
</p>
<p>N.E.M. Gibelli et al.
Basiliximab-chimeric anti-IL2-R monoclonal antibody in pediatric liver
transplantation: comparative study.
<em>Transplantation Proceedings</em>, <b>36</b>(4):956-957, 2004.
<a href="https://doi.org/10.1016/j.transproceed.2004.04.070">doi:10.1016/j.transproceed.2004.04.070</a>.
</p>
<p>S. Schuller et al.
Daclizumab induction therapy associated with tacrolimus-MMF has better
outcome compared with tacrolimus-MMF alone in pediatric living donor
liver transplantation.
<em>Transplantation Proceedings</em>, <b>37</b>(2):1151-1152, 2005.
<a href="https://doi.org/10.1016/j.transproceed.2005.01.023">doi:10.1016/j.transproceed.2005.01.023</a>.
</p>
<p>R. Ganschow et al.
Long-term results of basiliximab induction immunosuppression in
pediatric liver transplant recipients.
<em>Pediatric Transplantation</em>, <b>9</b>(6):741-745, 2005.
<a href="https://doi.org/10.1111/j.1399-3046.2005.00371.x">doi:10.1111/j.1399-3046.2005.00371.x</a>.
</p>
<p>M. Spada et al.
Randomized trial of basiliximab induction versus steroid therapy in
pediatric liver allograft recipients under tacrolimus immunosuppression.
<em>American Journal of Transplantation</em>, <b>6</b>(8):1913-1921, 2006.
<a href="https://doi.org/10.1111/j.1600-6143.2006.01406.x">doi:10.1111/j.1600-6143.2006.01406.x</a>.
</p>
<p>J.M. Gras et al.
Steroid-free, tacrolimus-basiliximab immunosuppression in pediatric
liver transplantation: Clinical and pharmacoeconomic study in 50 children.
<em>Liver Transplantation</em>, <b>14</b>(4):469-477, 2008.
<a href="https://doi.org/10.1002/lt.21397">doi:10.1002/lt.21397</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+GoralczykEtAl2011">GoralczykEtAl2011</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("CrinsEtAl2014")
## Not run: 
# compute effect sizes (log odds ratios) from count data
# (using "metafor" package's "escalc()" function):
require("metafor")
crins.es &lt;- escalc(measure="OR",
                   ai=exp.AR.events,  n1i=exp.total,
                   ci=cont.AR.events, n2i=cont.total,
                   slab=publication, data=CrinsEtAl2014)
print(crins.es)

# analyze using weakly informative half-Cauchy prior for heterogeneity:
crins.ma &lt;- bayesmeta(crins.es, tau.prior=function(t){dhalfcauchy(t,scale=1)})

# show results:
print(crins.ma)
forestplot(crins.ma)
plot(crins.ma)

# show heterogeneity posterior along with prior:
plot(crins.ma, which=4, prior=TRUE)

# perform meta analysis using 2 randomized studies only
# but use 4 non-randomized studies to inform heterogeneity prior:
crins.nrand &lt;- bayesmeta(crins.es[crins.es$randomized=="no",],
                         tau.prior=function(t){dhalfcauchy(t,scale=1)})
crins.rand  &lt;- bayesmeta(crins.es[crins.es$randomized=="yes",],
                         tau.prior=function(t){crins.nrand$dposterior(tau=t)})
plot(crins.nrand, which=4, prior=TRUE,
     main="non-randomized posterior = randomized prior")
plot(crins.rand, which=4, prior=TRUE, main="randomized posterior")
plot(crins.rand, which=1)

## End(Not run)
</code></pre>

<hr>
<h2 id='dhalflogistic'>Half-logistic distribution.
</h2><span id='topic+dhalflogistic'></span><span id='topic+phalflogistic'></span><span id='topic+qhalflogistic'></span><span id='topic+rhalflogistic'></span><span id='topic+ehalflogistic'></span><span id='topic+vhalflogistic'></span>

<h3>Description</h3>

<p>Half-logistic density, distribution, and quantile functions,
random number generation and expectation and variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  dhalflogistic(x, scale=1, log=FALSE)
  phalflogistic(q, scale=1)
  qhalflogistic(p, scale=1)
  rhalflogistic(n, scale=1)
  ehalflogistic(scale=1)
  vhalflogistic(scale=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dhalflogistic_+3A_x">x</code>, <code id="dhalflogistic_+3A_q">q</code></td>
<td>
<p>quantile.</p>
</td></tr>
<tr><td><code id="dhalflogistic_+3A_p">p</code></td>
<td>
<p>probability.</p>
</td></tr>
<tr><td><code id="dhalflogistic_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="dhalflogistic_+3A_scale">scale</code></td>
<td>
<p>scale parameter (<code class="reqn">&gt;0</code>).</p>
</td></tr>
<tr><td><code id="dhalflogistic_+3A_log">log</code></td>
<td>
<p>logical; if <code>TRUE</code>, logarithmic density will be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <b>half-logistic distribution</b> is simply a zero-mean logistic distribution
that is restricted to take only positive values.
If <code class="reqn">X\sim\mathrm{logistic}</code>, then
<code class="reqn">|sX|\sim\mathrm{halflogistic}(\mathrm{scale}\!=\!s)</code>.
</p>


<h3>Value</h3>

<p>&lsquo;<code>dhalflogistic()</code>&rsquo; gives the density function,
&lsquo;<code>phalflogistic()</code>&rsquo; gives the cumulative distribution
function (CDF),
&lsquo;<code>qhalflogistic()</code>&rsquo; gives the quantile function (inverse CDF),
and &lsquo;<code>rhalflogistic()</code>&rsquo; generates random deviates.
The &lsquo;<code>ehalflogistic()</code>&rsquo; and &lsquo;<code>vhalflogistic()</code>&rsquo;
functions return the corresponding half-logistic distribution's
expectation and variance, respectively.
</p>


<h3>Author(s)</h3>

<p>Christian Roever <a href="mailto:christian.roever@med.uni-goettingen.de">christian.roever@med.uni-goettingen.de</a>
</p>


<h3>References</h3>

<p>C. Roever, R. Bender, S. Dias, C.H. Schmid, H. Schmidli, S. Sturtz,
S. Weber, T. Friede.
On weakly informative prior distributions for the heterogeneity
parameter in Bayesian random-effects meta-analysis.
<em>Research Synthesis Methods</em>, <b>12</b>(4):448-474, 2021.
<a href="https://doi.org/10.1002/jrsm.1475">doi:10.1002/jrsm.1475</a>.
</p>
<p>N.L. Johnson, S. Kotz, N. Balakrishnan.
<em>Continuous univariate distributions</em>,
volume 2, chapter 23.11. Wiley, New York, 2nd edition, 1994.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dlogis">dlogis</a></code>, <code><a href="#topic+dhalfnormal">dhalfnormal</a></code>,
<code><a href="#topic+dlomax">dlomax</a></code>, <code><a href="#topic+drayleigh">drayleigh</a></code>,
<code><a href="#topic+TurnerEtAlPrior">TurnerEtAlPrior</a></code>, <code><a href="#topic+RhodesEtAlPrior">RhodesEtAlPrior</a></code>,
<code><a href="#topic+bayesmeta">bayesmeta</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#######################
# illustrate densities:
x &lt;- seq(0,6,le=200)
plot(x, dhalfnormal(x), type="l", col="red", ylim=c(0,1),
     xlab=expression(tau), ylab=expression("probability density "*f(tau)))
lines(x, dhalflogistic(x), col="green3")
lines(x, dhalfcauchy(x), col="blue")
lines(x, dexp(x), col="cyan")
abline(h=0, v=0, col="grey")

# show log-densities (note the differing tail behaviour):
plot(x, dhalfnormal(x), type="l", col="red", ylim=c(0.001,1), log="y",
     xlab=expression(tau), ylab=expression("probability density "*f(tau)))
lines(x, dhalflogistic(x), col="green3")
lines(x, dhalfcauchy(x), col="blue")
lines(x, dexp(x), col="cyan")
abline(v=0, col="grey")
</code></pre>

<hr>
<h2 id='dhalfnormal'>Half-normal, half-Student-t and half-Cauchy distributions.
</h2><span id='topic+dhalfnormal'></span><span id='topic+phalfnormal'></span><span id='topic+qhalfnormal'></span><span id='topic+rhalfnormal'></span><span id='topic+ehalfnormal'></span><span id='topic+vhalfnormal'></span><span id='topic+dhalft'></span><span id='topic+phalft'></span><span id='topic+qhalft'></span><span id='topic+rhalft'></span><span id='topic+ehalft'></span><span id='topic+vhalft'></span><span id='topic+dhalfcauchy'></span><span id='topic+phalfcauchy'></span><span id='topic+qhalfcauchy'></span><span id='topic+rhalfcauchy'></span><span id='topic+ehalfcauchy'></span><span id='topic+vhalfcauchy'></span>

<h3>Description</h3>

<p>Half-normal, half-Student-t and half-Cauchy density,
distribution, quantile functions, random number generation,
and expectation and variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  dhalfnormal(x, scale=1, log=FALSE)
  phalfnormal(q, scale=1)
  qhalfnormal(p, scale=1)
  rhalfnormal(n, scale=1)
  ehalfnormal(scale=1)
  vhalfnormal(scale=1)

  dhalft(x, df, scale=1, log=FALSE)
  phalft(q, df, scale=1)
  qhalft(p, df, scale=1)
  rhalft(n, df, scale=1)
  ehalft(df, scale=1)
  vhalft(df, scale=1)

  dhalfcauchy(x, scale=1, log=FALSE)
  phalfcauchy(q, scale=1)
  qhalfcauchy(p, scale=1)
  rhalfcauchy(n, scale=1)
  ehalfcauchy(scale=1)
  vhalfcauchy(scale=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dhalfnormal_+3A_x">x</code>, <code id="dhalfnormal_+3A_q">q</code></td>
<td>
<p>quantile.</p>
</td></tr>
<tr><td><code id="dhalfnormal_+3A_p">p</code></td>
<td>
<p>probability.</p>
</td></tr>
<tr><td><code id="dhalfnormal_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="dhalfnormal_+3A_scale">scale</code></td>
<td>
<p>scale parameter (<code class="reqn">&gt;0</code>).</p>
</td></tr>
<tr><td><code id="dhalfnormal_+3A_df">df</code></td>
<td>
<p>degrees-of-freedom parameter (<code class="reqn">&gt;0</code>).</p>
</td></tr>
<tr><td><code id="dhalfnormal_+3A_log">log</code></td>
<td>
<p>logical; if <code>TRUE</code>, logarithmic density will be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <b>half-normal distribution</b> is simply a zero-mean normal distribution
that is restricted to take only positive values. The <em>scale</em>
parameter <code class="reqn">\sigma</code> here corresponds to the underlying normal
distribution's standard deviation:
if <code class="reqn">X\sim\mathrm{Normal}(0,\sigma^2)</code>, then
<code class="reqn">|X|\sim\mathrm{halfNormal}(\mathrm{scale}\!=\!\sigma)</code>.
Its mean is <code class="reqn">\sigma
  \sqrt{2/\pi}</code>, and its variance is <code class="reqn">\sigma^2
  (1-2/\pi)</code>. 
Analogously, the <b>half-t distribution</b> is a truncated Student-t
distribution with <code>df</code> degrees-of-freedom,
and the <b>half-Cauchy distribution</b> is again a special case of the
half-t distribution with <code>df=1</code> degrees of freedom.
</p>
<p>Note that (half-) Student-t and Cauchy distributions arise as
continuous <em>mixture distributions</em> of (half-) normal
distributions. If
</p>
<p style="text-align: center;"><code class="reqn">Y|\sigma\;\sim\;\mathrm{Normal}(0,\sigma^2)</code>
</p>

<p>where the standard deviation is
<code class="reqn">\sigma = \sqrt{k/X}</code> and <code class="reqn">X</code> is drawn from a
<code class="reqn">\chi^2</code>-distribution with <code class="reqn">k</code> degrees of freedom, then the
marginal distribution of <code class="reqn">Y</code> is Student-t with <code class="reqn">k</code> degrees of freedom.
</p>


<h3>Value</h3>

<p>&lsquo;<code>dhalfnormal()</code>&rsquo; gives the density function,
&lsquo;<code>phalfnormal()</code>&rsquo; gives the cumulative distribution
function (CDF),
&lsquo;<code>qhalfnormal()</code>&rsquo; gives the quantile function (inverse CDF),
and &lsquo;<code>rhalfnormal()</code>&rsquo; generates random deviates.
The &lsquo;<code>ehalfnormal()</code>&rsquo; and &lsquo;<code>vhalfnormal()</code>&rsquo;
functions return the corresponding half-normal distribution's
expectation and variance, respectively.
For the
&lsquo;<code>dhalft()</code>&rsquo;, &lsquo;<code>dhalfcauchy()</code>&rsquo; and related
function it works analogously.
</p>


<h3>Author(s)</h3>

<p>Christian Roever <a href="mailto:christian.roever@med.uni-goettingen.de">christian.roever@med.uni-goettingen.de</a>
</p>


<h3>References</h3>

<p>C. Roever, R. Bender, S. Dias, C.H. Schmid, H. Schmidli, S. Sturtz,
S. Weber, T. Friede.
On weakly informative prior distributions for the heterogeneity
parameter in Bayesian random-effects meta-analysis.
<em>Research Synthesis Methods</em>, <b>12</b>(4):448-474, 2021.
<a href="https://doi.org/10.1002/jrsm.1475">doi:10.1002/jrsm.1475</a>.
</p>
<p>A. Gelman.
Prior distributions for variance parameters in hierarchical models.
<em>Bayesian Analysis</em>, <b>1</b>(3):515-534, 2006.
<a href="https://doi.org/10.1214/06-BA117A">doi:10.1214/06-BA117A</a>.
</p>
<p>F. C. Leone, L. S. Nelson, R. B. Nottingham.
The folded normal distribution.
<em>Technometrics</em>, <b>3</b>(4):543-550, 1961.
<a href="https://doi.org/10.2307/1266560">doi:10.2307/1266560</a>.
</p>
<p>N. G. Polson, J. G. Scott.
On the half-Cauchy prior for a global scale parameter.
<em>Bayesian Analysis</em>, <b>7</b>(4):887-902, 2012.
<a href="https://doi.org/10.1214/12-BA730">doi:10.1214/12-BA730</a>.
</p>
<p>S. Psarakis, J. Panaretos.
The folded t distribution.
<em>Communications in Statistics - Theory and Methods</em>,
<b>19</b>(7):2717-2734, 1990.
<a href="https://doi.org/10.1080/03610929008830342">doi:10.1080/03610929008830342</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dnorm">dnorm</a></code>, <code><a href="stats.html#topic+dt">dt</a></code>, <code><a href="stats.html#topic+dcauchy">dcauchy</a></code>,
<code><a href="#topic+dlomax">dlomax</a></code>, <code><a href="#topic+drayleigh">drayleigh</a></code>,
<code><a href="#topic+TurnerEtAlPrior">TurnerEtAlPrior</a></code>, <code><a href="#topic+RhodesEtAlPrior">RhodesEtAlPrior</a></code>,
<code><a href="#topic+bayesmeta">bayesmeta</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#######################
# illustrate densities:
x &lt;- seq(0,6,le=200)
plot(x, dhalfnormal(x), type="l", col="red", ylim=c(0,1),
     xlab=expression(tau), ylab=expression("probability density "*f(tau)))
lines(x, dhalft(x, df=3), col="green")
lines(x, dhalfcauchy(x), col="blue")
lines(x, dexp(x), col="cyan")
abline(h=0, v=0, col="grey")

# show log-densities (note the differing tail behaviour):
plot(x, dhalfnormal(x), type="l", col="red", ylim=c(0.001,1), log="y",
     xlab=expression(tau), ylab=expression("probability density "*f(tau)))
lines(x, dhalft(x, df=3), col="green")
lines(x, dhalfcauchy(x), col="blue")
lines(x, dexp(x), col="cyan")
abline(v=0, col="grey")
</code></pre>

<hr>
<h2 id='dinvchi'>Inverse-Chi distribution.
</h2><span id='topic+dinvchi'></span><span id='topic+pinvchi'></span><span id='topic+qinvchi'></span><span id='topic+rinvchi'></span><span id='topic+einvchi'></span><span id='topic+vinvchi'></span>

<h3>Description</h3>

<p>(Scaled) inverse-Chi density, distribution, and quantile functions,
random number generation and expectation and variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  dinvchi(x, df, scale=1, log=FALSE)
  pinvchi(q, df, scale=1, lower.tail=TRUE, log.p=FALSE)
  qinvchi(p, df, scale=1, lower.tail=TRUE, log.p=FALSE)
  rinvchi(n, df, scale=1)
  einvchi(df, scale=1)
  vinvchi(df, scale=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dinvchi_+3A_x">x</code>, <code id="dinvchi_+3A_q">q</code></td>
<td>
<p>quantile.</p>
</td></tr>
<tr><td><code id="dinvchi_+3A_p">p</code></td>
<td>
<p>probability.</p>
</td></tr>
<tr><td><code id="dinvchi_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="dinvchi_+3A_df">df</code></td>
<td>
<p>degrees-of-freedom parameter (<code class="reqn">&gt;0</code>).</p>
</td></tr>
<tr><td><code id="dinvchi_+3A_scale">scale</code></td>
<td>
<p>scale parameter (<code class="reqn">&gt;0</code>).</p>
</td></tr>
<tr><td><code id="dinvchi_+3A_log">log</code></td>
<td>
<p>logical; if <code>TRUE</code>, logarithmic density will be
returned.</p>
</td></tr>
<tr><td><code id="dinvchi_+3A_lower.tail">lower.tail</code></td>
<td>
<p>logical; if <code>TRUE</code> (default),
probabilities are P(X &lt;= x), otherwise, P(X &gt; x).</p>
</td></tr>
<tr><td><code id="dinvchi_+3A_log.p">log.p</code></td>
<td>
<p>logical; if <code>TRUE</code>, probabilities p are
returned as log(p).</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <b>(scaled) inverse-Chi distribution</b> is defined as the
distribution of the (scaled) inverse of the square root of a
Chi-square-distributed random variable. It is a special case of the
<em>square-root inverted-gamma</em> distribution (with
<code class="reqn">\alpha=\nu/2</code> and <code class="reqn">\beta=1/2</code>) (Bernardo and Smith;
1994). Its probability density function is given by
</p>
<p style="text-align: center;"><code class="reqn">p(x) \;=\; \frac{2^{(1-\nu/2)}}{s \, \Gamma(\nu/2)}
    \Bigl(\frac{s}{x}\Bigr)^{(\nu+1)}
    \exp\Bigl(-\frac{s^2}{2\,x^2}\Bigr)</code>
</p>

<p>where <code class="reqn">\nu</code> is the <em>degrees-of-freedom</em> and <code class="reqn">s</code> the
<em>scale</em> parameter.
</p>


<h3>Value</h3>

<p>&lsquo;<code>dinvchi()</code>&rsquo; gives the density function,
&lsquo;<code>pinvchi()</code>&rsquo; gives the cumulative distribution
function (CDF),
&lsquo;<code>qinvchi()</code>&rsquo; gives the quantile function (inverse CDF),
and &lsquo;<code>rinvchi()</code>&rsquo; generates random deviates.
The &lsquo;<code>einvchi()</code>&rsquo; and &lsquo;<code>vinvchi()</code>&rsquo;
functions return the corresponding distribution's
expectation and variance, respectively.
</p>


<h3>Author(s)</h3>

<p>Christian Roever <a href="mailto:christian.roever@med.uni-goettingen.de">christian.roever@med.uni-goettingen.de</a>
</p>


<h3>References</h3>

<p>C. Roever, R. Bender, S. Dias, C.H. Schmid, H. Schmidli, S. Sturtz,
S. Weber, T. Friede.
On weakly informative prior distributions for the heterogeneity
parameter in Bayesian random-effects meta-analysis.
<em>Research Synthesis Methods</em>, <b>12</b>(4):448-474, 2021.
<a href="https://doi.org/10.1002/jrsm.1475">doi:10.1002/jrsm.1475</a>.
</p>
<p>J.M. Bernardo, A.F.M. Smith. <em>Bayesian theory</em>,
Appendix A.1. Wiley, Chichester, UK, 1994.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dhalfnormal">dhalfnormal</a></code>,
<code><a href="#topic+dhalft">dhalft</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#################################
# illustrate Chi^2 - connection;
# generate Chi^2-draws:
chi2 &lt;- rchisq(1000, df=10)
# transform:
invchi &lt;- sqrt(1 / chi2)
# show histogram:
hist(invchi, probability=TRUE, col="grey")
# show density for comparison:
x &lt;- seq(0, 1, length=100)
lines(x, dinvchi(x, df=10, scale=1), col="red")
# compare theoretical and empirical moments:
rbind("theoretical" = c("mean" = einvchi(df=10, scale=1),
                        "var"  = vinvchi(df=10, scale=1)),
      "Monte Carlo" = c("mean" = mean(invchi),
                        "var"  = var(invchi)))

##############################################################
# illustrate the normal/Student-t - scale mixture connection;
# specify degrees-of-freedom:
df &lt;- 5
# generate standard normal draws:
z &lt;- rnorm(1000)
# generate random scalings:
sigma &lt;- rinvchi(1000, df=df, scale=sqrt(df))
# multiply to yield Student-t draws:
t &lt;- z * sigma
# check Student-t distribution via a Q-Q-plot:
qqplot(qt(ppoints(length(t)), df=df), t)
abline(0, 1, col="red")
</code></pre>

<hr>
<h2 id='dlomax'>The Lomax distribution.</h2><span id='topic+dlomax'></span><span id='topic+plomax'></span><span id='topic+qlomax'></span><span id='topic+rlomax'></span><span id='topic+elomax'></span><span id='topic+vlomax'></span>

<h3>Description</h3>

<p>Lomax density, distribution and quantile functions,
random number generation, and expectation and variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  dlomax(x, shape=1, scale=1, log=FALSE)
  plomax(q, shape=1, scale=1)
  qlomax(p, shape=1, scale=1)
  rlomax(n, shape=1, scale=1)
  elomax(shape=1, scale=1)
  vlomax(shape=1, scale=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dlomax_+3A_x">x</code>, <code id="dlomax_+3A_q">q</code></td>
<td>
<p>quantile.</p>
</td></tr>
<tr><td><code id="dlomax_+3A_p">p</code></td>
<td>
<p>probability.</p>
</td></tr>
<tr><td><code id="dlomax_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="dlomax_+3A_shape">shape</code></td>
<td>
<p>shape parameter (<code class="reqn">\alpha &gt; 0</code>).</p>
</td></tr>
<tr><td><code id="dlomax_+3A_scale">scale</code></td>
<td>
<p>scale parameter (<code class="reqn">\lambda &gt; 0</code>).</p>
</td></tr>
<tr><td><code id="dlomax_+3A_log">log</code></td>
<td>
<p>logical; if <code>TRUE</code>, logarithmic density will be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Lomax distribution is a heavy-tailed distribution that also is a
special case of a <em>Pareto distribution of the 2nd kind</em>.
The probability density function of a Lomax distributed variable with
shape <code class="reqn">\alpha&gt;0</code> and scale <code class="reqn">\lambda&gt;0</code> is given by
</p>
<p style="text-align: center;"><code class="reqn">p(x) = (\alpha / \lambda) (1 + x / \lambda)^{-(\alpha+1)}.</code>
</p>

<p>The density function is monotonically decreasing in <code class="reqn">x</code>. Its mean
is <code class="reqn">\lambda / (\alpha-1)</code> (for <code class="reqn">\alpha&gt;1</code>) and its median is
<code class="reqn">\alpha(2^{1/\alpha}-1)</code>. Its variance is
finite only for <code class="reqn">\alpha &gt; 2</code> and equals 
<code class="reqn">(\lambda^2 \alpha) / ((\alpha-1)^2 (\alpha-2))</code>.
The cumulative distribution function (CDF) is given by
</p>
<p style="text-align: center;"><code class="reqn">P(x) = 1-(1+ x / \lambda)^{-\alpha}.</code>
</p>

<p>The Lomax distribution also arises as a <b>gamma-exponential
mixture</b>. Suppose that <code class="reqn">X</code> is a draw from an exponential
distribution whose rate <code class="reqn">\theta</code> again is drawn from a gamma
distribution with shape <code class="reqn">a</code> and scale <code class="reqn">s</code> (so that
<code class="reqn">\mathrm{E}[\theta]=as</code>
and <code class="reqn">\mathrm{Var}(\theta)=as^2</code>,
or <code class="reqn">\mathrm{E}[1/\theta]=\frac{1}{s(a+1)}</code>
and <code class="reqn">\mathrm{Var}(1/\theta)=\frac{1}{s^2(a-1)^2(a-2)}</code>). 
Then the marginal distribution of <code class="reqn">X</code> is Lomax with scale
<code class="reqn">1/s</code> and shape <code class="reqn">a</code>. Consequently, if the moments of
<code class="reqn">\theta</code> are given by <code class="reqn">\mathrm{E}[\theta]=\mu</code> and
<code class="reqn">\mathrm{Var}(\theta)=\sigma^2</code>, then <code class="reqn">X</code> is Lomax distributed
with shape
<code class="reqn">\alpha=\left(\frac{\mu}{\sigma}\right)^2</code> and
scale
<code class="reqn">\lambda=\frac{\mu}{\sigma^2}=\frac{\alpha}{\mu}</code>. 
The gamma-exponential connection is also illustrated in an example below.
</p>


<h3>Value</h3>

<p>&lsquo;<code>dlomax()</code>&rsquo; gives the density function,
&lsquo;<code>plomax()</code>&rsquo; gives the cumulative distribution
function (CDF),
&lsquo;<code>qlomax()</code>&rsquo; gives the quantile function (inverse CDF),
and &lsquo;<code>rlomax()</code>&rsquo; generates random deviates.
The &lsquo;<code>elomax()</code>&rsquo; and &lsquo;<code>vlomax()</code>&rsquo;
functions return the corresponding Lomax distribution's
expectation and variance, respectively.
</p>


<h3>Author(s)</h3>

<p>Christian Roever <a href="mailto:christian.roever@med.uni-goettingen.de">christian.roever@med.uni-goettingen.de</a>
</p>


<h3>References</h3>

<p>C. Roever, R. Bender, S. Dias, C.H. Schmid, H. Schmidli, S. Sturtz,
S. Weber, T. Friede.
On weakly informative prior distributions for the heterogeneity
parameter in Bayesian random-effects meta-analysis.
<em>Research Synthesis Methods</em>, <b>12</b>(4):448-474, 2021.
<a href="https://doi.org/10.1002/jrsm.1475">doi:10.1002/jrsm.1475</a>.
</p>
<p>N.L. Johnson, S. Kotz, N. Balakrishnan. <em>Continuous univariate
distributions</em>, volume 1. Wiley, New York, 2nd edition, 1994.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dexp">dexp</a></code>,
<code><a href="stats.html#topic+dgamma">dgamma</a></code>,
<code><a href="#topic+dhalfnormal">dhalfnormal</a></code>, <code><a href="#topic+dhalft">dhalft</a></code>, <code><a href="#topic+dhalfcauchy">dhalfcauchy</a></code>,
<code><a href="#topic+drayleigh">drayleigh</a></code>,
<code><a href="#topic+TurnerEtAlPrior">TurnerEtAlPrior</a></code>, <code><a href="#topic+RhodesEtAlPrior">RhodesEtAlPrior</a></code>,
<code><a href="#topic+bayesmeta">bayesmeta</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>#######################
# illustrate densities:
x &lt;- seq(0,6,le=200)
plot(x, dexp(x, rate=1), type="l", col="cyan", ylim=c(0,1),
     xlab=expression(tau), ylab=expression("probability density "*f(tau)))
lines(x, dlomax(x), col="orange")
abline(h=0, v=0, col="grey")

# show log-densities (note the differing tail behaviour):
plot(x, dexp(x, rate=1), type="l", col="cyan", ylim=c(0.001,1), log="y",
     xlab=expression(tau), ylab=expression("probability density "*f(tau)))
lines(x, dlomax(x), col="orange")
abline(v=0, col="grey")

######################################################
# illustrate the gamma-exponential mixture connection;
# specify a number of samples:
N &lt;- 10000
# specify some gamma shape and scale parameters
# (via mixing distribution's moments):
expectation &lt;- 2.0
stdev       &lt;- 1.0
gammashape &lt;- (expectation / stdev)^2
gammascale &lt;- stdev^2 / expectation
print(c("expectation"=expectation, "stdev"=stdev,
        "shape"=gammashape, "scale"=gammascale))
# generate gamma-distributed rates:
lambda &lt;- rgamma(N, shape=gammashape, scale=gammascale)
# generate exponential draws according to gamma-rates:
y &lt;- rexp(N, rate=lambda)
# determine Lomax quantiles accordingly parameterized:
x &lt;- qlomax(ppoints(N), scale=1/gammascale, shape=gammashape)
# compare distributions in a Q-Q-plot:
plot(x, sort(y), log="xy", main="quantile-quantile plot",
     xlab="theoretical quantile", ylab="empirical quantile")
abline(0, 1, col="red")
</code></pre>

<hr>
<h2 id='drayleigh'>The Rayleigh distribution.
</h2><span id='topic+drayleigh'></span><span id='topic+prayleigh'></span><span id='topic+qrayleigh'></span><span id='topic+rrayleigh'></span><span id='topic+erayleigh'></span><span id='topic+vrayleigh'></span>

<h3>Description</h3>

<p>Rayleigh density, distribution, quantile function, random number
generation, and expectation and variance.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  drayleigh(x, scale=1, log=FALSE)
  prayleigh(q, scale=1)
  qrayleigh(p, scale=1)
  rrayleigh(n, scale=1)
  erayleigh(scale=1)
  vrayleigh(scale=1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="drayleigh_+3A_x">x</code>, <code id="drayleigh_+3A_q">q</code></td>
<td>
<p>quantile.</p>
</td></tr>
<tr><td><code id="drayleigh_+3A_p">p</code></td>
<td>
<p>probability.</p>
</td></tr>
<tr><td><code id="drayleigh_+3A_n">n</code></td>
<td>
<p>number of observations.</p>
</td></tr>
<tr><td><code id="drayleigh_+3A_scale">scale</code></td>
<td>
<p>scale parameter (<code class="reqn">&gt;0</code>).</p>
</td></tr>
<tr><td><code id="drayleigh_+3A_log">log</code></td>
<td>
<p>logical; if <code>TRUE</code>, logarithmic density will be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Rayleigh distribution arises as the distribution of the
square root of an exponentially distributed (or
<code class="reqn">\chi^2_2</code>-distributed) random variable.
If <code class="reqn">X</code> follows an exponential distribution with rate <code class="reqn">\lambda</code>
and expectation <code class="reqn">1/\lambda</code>, then <code class="reqn">Y=\sqrt{X}</code> follows a
Rayleigh distribution with scale
<code class="reqn">\sigma=1/\sqrt{2\lambda}</code> and
expectation <code class="reqn">\sqrt{\pi/(4\lambda)}</code>.
</p>
<p>Note that the exponential distribution is the <em>maximum entropy
distribution</em> among distributions supported on the positive real
numbers and with a pre-specified expectation; so the Rayleigh
distribution gives the corresponding distribution of its square root.
</p>


<h3>Value</h3>

<p>&lsquo;<code>drayleigh()</code>&rsquo; gives the density function,
&lsquo;<code>prayleigh()</code>&rsquo; gives the cumulative distribution
function (CDF),
&lsquo;<code>qrayleigh()</code>&rsquo; gives the quantile function (inverse CDF),
and &lsquo;<code>rrayleigh()</code>&rsquo; generates random deviates.
The &lsquo;<code>erayleigh()</code>&rsquo; and &lsquo;<code>vrayleigh()</code>&rsquo;
functions return the corresponding Rayleigh distribution's
expectation and variance, respectively.
</p>


<h3>Author(s)</h3>

<p>Christian Roever <a href="mailto:christian.roever@med.uni-goettingen.de">christian.roever@med.uni-goettingen.de</a>
</p>


<h3>References</h3>

<p>C. Roever, R. Bender, S. Dias, C.H. Schmid, H. Schmidli, S. Sturtz,
S. Weber, T. Friede.
On weakly informative prior distributions for the heterogeneity
parameter in Bayesian random-effects meta-analysis.
<em>Research Synthesis Methods</em>, <b>12</b>(4):448-474, 2021.
<a href="https://doi.org/10.1002/jrsm.1475">doi:10.1002/jrsm.1475</a>.
</p>
<p>N.L. Johnson, S. Kotz, N. Balakrishnan. <em>Continuous univariate
distributions</em>, volume 1. Wiley, New York, 2nd edition, 1994.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dexp">dexp</a></code>, <code><a href="#topic+dlomax">dlomax</a></code>,
<code><a href="#topic+dhalfnormal">dhalfnormal</a></code>, <code><a href="#topic+dhalft">dhalft</a></code>, <code><a href="#topic+dhalfcauchy">dhalfcauchy</a></code>,
<code><a href="#topic+TurnerEtAlPrior">TurnerEtAlPrior</a></code>, <code><a href="#topic+RhodesEtAlPrior">RhodesEtAlPrior</a></code>,
<code><a href="#topic+bayesmeta">bayesmeta</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>########################
# illustrate densities:
x &lt;- seq(0,6,le=200)
plot(x, drayleigh(x, scale=0.5), type="l", col="green",
     xlab=expression(tau), ylab=expression("probability density "*f(tau)))
lines(x, drayleigh(x, scale=1/sqrt(2)), col="red")
lines(x, drayleigh(x, scale=1), col="blue")
abline(h=0, v=0, col="grey")

###############################################
# illustrate exponential / Rayleigh connection
# via a quantile-quantile plot (Q-Q-plot):
N &lt;- 10000
exprate &lt;- 5
plot(sort(sqrt(rexp(N, rate=exprate))),
     qrayleigh(ppoints(N), scale=1/sqrt(2*exprate)))
abline(0, 1, col="red")

###############################################
# illustrate Maximum Entropy distributions
# under similar but different constraints:
mu &lt;- 0.5
tau &lt;- seq(0, 4*mu, le=100)
plot(tau, dexp(tau, rate=1/mu), type="l", col="red", ylim=c(0,1/mu),
     xlab=expression(tau), ylab="probability density")
lines(tau, drayleigh(tau, scale=1/sqrt(2*1/mu^2)), col="blue")
abline(h=0, v=0, col="grey")
abline(v=mu, col="darkgrey"); axis(3, at=mu, label=expression(mu))
# explicate constraints:
legend("topright", pch=15, col=c("red","blue"),
       c(expression("Exponential:  E["*tau*"]"==mu),
         expression("Rayleigh:  E["*tau^2*"]"==mu^2)))
</code></pre>

<hr>
<h2 id='ess'>
Effective sample size (ESS)
</h2><span id='topic+ess'></span><span id='topic+ess.bayesmeta'></span>

<h3>Description</h3>

<p>This function computes the effective sample size (ESS) of a posterior
predictive distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ess(object, ...)
  ## S3 method for class 'bayesmeta'
ess(object, uisd, method=c("elir", "vr", "pr", "mtm.pt"), ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="ess_+3A_object">object</code></td>
<td>
<p>a <code>bayesmeta</code> object.</p>
</td></tr>
<tr><td><code id="ess_+3A_uisd">uisd</code></td>
<td>
<p>the <em>unit infomation standard deviation</em>
(a single numerical value, <em>or</em> a <code>function</code> of the
parameter (<code class="reqn">\mu</code>)).</p>
</td></tr>
<tr><td><code id="ess_+3A_method">method</code></td>
<td>
<p>a character string specifying the method to be used for
ESS computation. By default, the expected local-information-ratio
ESS (<code class="reqn">ESS_{ELIR}</code>) is returned.</p>
</td></tr>
<tr><td><code id="ess_+3A_...">...</code></td>
<td>
<p>additional arguments</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The information conveyed by a prior distribution may often be
quantified in terms of an <em>effective sample size
(ESS)</em>. Meta-analyses are commonly utilized to summarize
&ldquo;historical&rdquo; information in order to inform a future study,
leading to a <em>meta-analytic-predictive (MAP) prior</em> (Schmidli et
al., 2014). In the context of the normal-normal hierarchical model
(NNHM), the MAP prior results as the (posterior) predictive
distribution for a &ldquo;new&rdquo; study mean
<code class="reqn">\theta_{k+1}</code>. This function computes the ESS for the
posterior predictive distribution based on a <code>bayesmeta</code> object.
</p>
<p>Within the NNHM, the notion of an effective sample size requires the
specification of a <em>unit information standard deviation (UISD)</em>
(Roever et al., 2020); see also the &lsquo;<code><a href="#topic+uisd">uisd</a>()</code>&rsquo;
function's help page. The UISD <code class="reqn">\sigma_\mathrm{u}</code> here
determines the <em>Fisher information for one information unit</em>,
effectively assuming that a study's sample size <code class="reqn">n_i</code> and
standard error <code class="reqn">\sigma_i</code> are related simply as
</p>
<p style="text-align: center;"><code class="reqn">\sigma_i=\frac{\sigma_\mathrm{u}}{\sqrt{n_i}},</code>
</p>

<p>i.e., the squared standard error is inversely proportional to the
sample size. For the (possibly hypothetical) case of a sample size of
<code class="reqn">n_i=1</code>, the standard error then is equal to the UISD
<code class="reqn">\sigma_\mathrm{u}</code>.
</p>
<p>Specifying the UISD as a constant is often an approximation,
sometimes it is also possible to specify the UISD as a function of the
parameter (<code class="reqn">\mu</code>). For example, in case the outcome in
the meta-analyses are log-odds, then the UISD varies with the (log-)
odds and is given by <code class="reqn">2\,\mathrm{cosh}(\mu/2)</code>
(see also the example below).
</p>
<p>The ESS may be computed or approximated in several ways.
Possible choices here are:
</p>

<ul>
<li> <p><code>"elir"</code>: the <em>expected local-information-ratio (ELIR)</em> method (the default),
</p>
</li>
<li> <p><code>"vr"</code>: the <em>variance ratio (VR)</em> method,
</p>
</li>
<li> <p><code>"pr"</code>: the <em>precision ratio (PR)</em> method,
</p>
</li>
<li> <p><code>"mtm.pt"</code>: the <em>Morita-Thall-Mueller / Pennello-Thompson (MTM.PM)</em> method.
</p>
</li></ul>

<p>For more details on these see also Neuenschwander et al. (2020).
</p>


<h3>Value</h3>

<p>The effective sample size (ESS).
</p>


<h3>Author(s)</h3>

<p>Christian Roever <a href="mailto:christian.roever@med.uni-goettingen.de">christian.roever@med.uni-goettingen.de</a>
</p>


<h3>References</h3>

<p>B. Neuenschwander, S. Weber, H. Schmidli, A. O'Hagan.
Predictively consistent prior effective sample sizes.
<em>Biometrics</em>, <b>76</b>(2):578-587, 2020.
<a href="https://doi.org/10.1111/biom.13252">doi:10.1111/biom.13252</a>.
</p>
<p>H. Schmidli, S. Gsteiger, S. Roychoudhury, A. O'Hagan,
D. Spiegelhalter, B. Neuenschwander.
Robust meta-analytic-predictive priors in clinical trials with
historical control information.
<em>Biometrics</em>, <b>70</b>(4):1023-1032, 2014.
<a href="https://doi.org/10.1111/biom.12242">doi:10.1111/biom.12242</a>.
</p>
<p>C. Roever, R. Bender, S. Dias, C.H. Schmid, H. Schmidli, S. Sturtz,
S. Weber, T. Friede.
On weakly informative prior distributions for the heterogeneity
parameter in Bayesian random-effects meta-analysis.
<em>Research Synthesis Methods</em>, <b>12</b>(4):448-474, 2021.
<a href="https://doi.org/10.1002/jrsm.1475">doi:10.1002/jrsm.1475</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesmeta">bayesmeta</a></code>, <code><a href="#topic+uisd">uisd</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data set:
data("BaetenEtAl2013")
print(BaetenEtAl2013)

## Not run: 
# compute effect sizes (logarithmic odds) from the count data:
as &lt;- escalc(xi=events, ni=total, slab=study,
             measure="PLO", data=BaetenEtAl2013)

# estimate the unit information standard deviation (UISD):
uisd(as, individual=TRUE)
uisd(as)  # = 2.35

# perform meta-analysis
# (using uniform priors for effect and heterogeneity):
bm &lt;- bayesmeta(as)

# show forest plot:
forestplot(bm, zero=NA, xlab="log-odds")

# compute ESS_ELIR (based on fixed UISD):
ess(bm, uisd=2.35)  # = 45.7 patients

# compute ESS_ELIR based on UISD as a function of the log-odds:
uisdLogOdds &lt;- function(logodds)
{
  return(2 * cosh(logodds / 2))
}

# Note: in the present example, probabilities are
# at approximately 0.25, corresponding to odds of 1:3.
uisdLogOdds(log(1/3))
# The UISD value of 2.31 roughly matches the above empirical figure.

ess(bm, uisd=uisdLogOdds)  # = 43.4 patients

## End(Not run)
</code></pre>

<hr>
<h2 id='forest.bayesmeta'>
Generate a forest plot for a <code><a href="#topic+bayesmeta">bayesmeta</a></code> object
(based on the <code>metafor</code> package's plotting functions).
</h2><span id='topic+forest.bayesmeta'></span>

<h3>Description</h3>

<p>Generates a forest plot, showing individual estimates along with their
95 percent confidence intervals, resulting effect estimate and
prediction interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'bayesmeta'
forest(x, xlab="effect size", refline=0, cex=1,...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forest.bayesmeta_+3A_x">x</code></td>
<td>

<p>a <code><a href="#topic+bayesmeta">bayesmeta</a></code> object.
</p>
</td></tr>
<tr><td><code id="forest.bayesmeta_+3A_xlab">xlab</code></td>
<td>

<p>title for the x-axis.
</p>
</td></tr>
<tr><td><code id="forest.bayesmeta_+3A_refline">refline</code></td>
<td>

<p>value at which a vertical &lsquo;reference&rsquo; line should be drawn
(default is 0). The line can be suppressed by setting this argument
to &lsquo;NA&rsquo;.
</p>
</td></tr>
<tr><td><code id="forest.bayesmeta_+3A_cex">cex</code></td>
<td>

<p>character and symbol expansion factor.
</p>
</td></tr>
<tr><td><code id="forest.bayesmeta_+3A_...">...</code></td>
<td>
<p>other arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generates a simple forest plot illustrating the underlying data and
resulting estimates (effect estimate and prediction interval).
</p>


<h3>Note</h3>

<p>This function requires the <span class="pkg">metafor</span> package to be installed.
</p>


<h3>Author(s)</h3>

<p>Christian Roever <a href="mailto:christian.roever@med.uni-goettingen.de">christian.roever@med.uni-goettingen.de</a>
</p>


<h3>References</h3>

<p>C. Lewis and M. Clarke.
Forest plots: trying to see the wood and the trees.
<em>BMJ</em>, <b>322</b>:1479, 2001.
<a href="https://doi.org/10.1136/bmj.322.7300.1479">doi:10.1136/bmj.322.7300.1479</a>.
</p>
<p>R.D. Riley, J.P. Higgins and J.J. Deeks.
Interpretation of random effects meta-analyses.
<em>BMJ</em>, <b>342</b>:d549, 2011.
<a href="https://doi.org/10.1136/bmj.d549">doi:10.1136/bmj.d549</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesmeta">bayesmeta</a></code>, <code><a href="metafor.html#topic+forest.default">forest.default</a></code>,
<code><a href="metafor.html#topic+addpoly">addpoly</a></code>, <code><a href="#topic+forestplot.bayesmeta">forestplot.bayesmeta</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("CrinsEtAl2014")

## Not run: 
# compute effect sizes (log odds ratios) from count data
# (using "metafor" package's "escalc()" function):
require("metafor")
es.crins &lt;- escalc(measure="OR",
                   ai=exp.AR.events,  n1i=exp.total,
                   ci=cont.AR.events, n2i=cont.total,
                   slab=publication, data=CrinsEtAl2014)
# derive a prior distribution for the heterogeneity:
tp.crins &lt;- TurnerEtAlPrior("surgical", "pharma", "placebo / control")
# perform meta-analysis:
ma.crins &lt;- bayesmeta(es.crins, tau.prior=tp.crins$dprior)

########
# plot:
forest(ma.crins, xlab="log odds ratio")

forest(ma.crins, trans=exp, refline=1, xlab="odds ratio")

## End(Not run)
</code></pre>

<hr>
<h2 id='forestplot.bayesmeta'>
Generate a forest plot for a <code><a href="#topic+bayesmeta">bayesmeta</a></code> object
(based on the <code>forestplot</code> package's plotting functions).
</h2><span id='topic+forestplot.bayesmeta'></span>

<h3>Description</h3>

<p>Generates a forest plot, showing individual estimates along with their
95 percent confidence intervals, shrinkage intervals, resulting effect
estimate and prediction interval.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'bayesmeta'
forestplot(x, labeltext, exponentiate=FALSE,
           prediction=TRUE, shrinkage=TRUE, heterogeneity=TRUE, 
           digits=2, plot=TRUE,
           fn.ci_norm, fn.ci_sum, col, legend=NULL, boxsize, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forestplot.bayesmeta_+3A_x">x</code></td>
<td>

<p>a <code><a href="#topic+bayesmeta">bayesmeta</a></code> object.
</p>
</td></tr>
<tr><td><code id="forestplot.bayesmeta_+3A_labeltext">labeltext</code></td>
<td>
<p>an (alternative) &ldquo;<code>labeltext</code>&rdquo; argument
which is then handed on to the <code><a href="forestplot.html#topic+forestplot">forestplot</a>()</code>
function (see the help there). You can use this to change contents
or add columns to the displayed table; see the example below.
</p>
</td></tr>
<tr><td><code id="forestplot.bayesmeta_+3A_exponentiate">exponentiate</code></td>
<td>

<p>a logical flag indicating whether to exponentiate numbers (effect
sizes) in table and plot.
</p>
</td></tr>
<tr><td><code id="forestplot.bayesmeta_+3A_prediction">prediction</code></td>
<td>

<p>a logical flag indicating whether to show the prediction interval
below the mean estimate.
</p>
</td></tr>
<tr><td><code id="forestplot.bayesmeta_+3A_shrinkage">shrinkage</code></td>
<td>

<p>a logical flag indicating whether to show shrinkage intervals along
with the quoted estimates.
</p>
</td></tr>
<tr><td><code id="forestplot.bayesmeta_+3A_heterogeneity">heterogeneity</code></td>
<td>

<p>a logical flag indicating whether to quote the heterogeneity estimate 
and CI (at the bottom left).
</p>
</td></tr>
<tr><td><code id="forestplot.bayesmeta_+3A_digits">digits</code></td>
<td>

<p>The number of significant digits to be shown.
This is interpreted relative to the standard errors of all estimates.
</p>
</td></tr>
<tr><td><code id="forestplot.bayesmeta_+3A_plot">plot</code></td>
<td>

<p>a logical flag indicating whether to actually generate a plot.
</p>
</td></tr>
<tr><td><code id="forestplot.bayesmeta_+3A_fn.ci_norm">fn.ci_norm</code>, <code id="forestplot.bayesmeta_+3A_fn.ci_sum">fn.ci_sum</code>, <code id="forestplot.bayesmeta_+3A_col">col</code>, <code id="forestplot.bayesmeta_+3A_legend">legend</code>, <code id="forestplot.bayesmeta_+3A_boxsize">boxsize</code>, <code id="forestplot.bayesmeta_+3A_...">...</code></td>
<td>

<p>other arguments passed on to the
<span class="pkg">forestplot</span> package's <code><a href="forestplot.html#topic+forestplot">forestplot</a></code>
function (see also the help there).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generates a forest plot illustrating the underlying data and
resulting estimates (effect estimate and prediction interval,
as well as shrinkage estimates and intervals).
</p>


<h3>Value</h3>

<p>A list containing the following elements:
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p>a <code>matrix</code> of estimates and CIs.</p>
</td></tr>
<tr><td><code>shrinkage</code></td>
<td>
<p>a <code>matrix</code> of shrinkage estimates and CIs.</p>
</td></tr>
<tr><td><code>labeltext</code></td>
<td>
<p>a <code>matrix</code> of table entries.</p>
</td></tr>
<tr><td><code>forestplot</code></td>
<td>
<p>result of the call to the
&lsquo;<code>forestplot()</code>&rsquo; function.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is based on the <span class="pkg">forestplot</span> package's
&ldquo;<code><a href="forestplot.html#topic+forestplot">forestplot</a>()</code>&rdquo; function.
</p>


<h3>Author(s)</h3>

<p>Christian Roever <a href="mailto:christian.roever@med.uni-goettingen.de">christian.roever@med.uni-goettingen.de</a>
</p>


<h3>References</h3>

<p>C. Roever.
Bayesian random-effects meta-analysis using the bayesmeta R package.
<em>Journal of Statistical Software</em>, <b>93</b>(6):1-51, 2020.
<a href="https://doi.org/10.18637/jss.v093.i06">doi:10.18637/jss.v093.i06</a>.
</p>
<p>C. Lewis and M. Clarke.
Forest plots: trying to see the wood and the trees.
<em>BMJ</em>, <b>322</b>:1479, 2001.
<a href="https://doi.org/10.1136/bmj.322.7300.1479">doi:10.1136/bmj.322.7300.1479</a>.
</p>
<p>C. Guddat, U. Grouven, R. Bender and G. Skipka.
A note on the graphical presentation of prediction intervals in
random-effects meta-analyses.
<em>Systematic Reviews</em>, <b>1</b>(34), 2012.
<a href="https://doi.org/10.1186/2046-4053-1-34">doi:10.1186/2046-4053-1-34</a>.
</p>
<p>R.D. Riley, J.P. Higgins and J.J. Deeks.
Interpretation of random effects meta-analyses.
<em>BMJ</em>, <b>342</b>:d549, 2011.
<a href="https://doi.org/10.1136/bmj.d549">doi:10.1136/bmj.d549</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesmeta">bayesmeta</a></code>,
<code><a href="forestplot.html#topic+forestplot">forestplot</a></code>,
<code><a href="#topic+forest.bayesmeta">forest.bayesmeta</a></code>,
<code><a href="#topic+plot.bayesmeta">plot.bayesmeta</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data:
data("CrinsEtAl2014")

## Not run: 
# compute effect sizes (log odds ratios) from count data
# (using "metafor" package's "escalc()" function):
require("metafor")
crins.es &lt;- escalc(measure="OR",
                   ai=exp.AR.events,  n1i=exp.total,
                   ci=cont.AR.events, n2i=cont.total,
                   slab=publication, data=CrinsEtAl2014)
print(crins.es)

# perform meta analysis:
crins.ma &lt;- bayesmeta(crins.es, tau.prior=function(t){dhalfcauchy(t,scale=1)})

########################
# generate forest plots
require("forestplot")

# default options:
forestplot(crins.ma)

# exponentiate values (shown in table and plot), show vertical line at OR=1:
forestplot(crins.ma, expo=TRUE, zero=1)

# logarithmic x-axis:
forestplot(crins.ma, expo=TRUE, xlog=TRUE)

# omit prediction interval:
forestplot(crins.ma, predict=FALSE)

# omit shrinkage intervals:
forestplot(crins.ma, shrink=FALSE)

# show more decimal places:
forestplot(crins.ma, digits=3)

# change table values:
# (here: add columns for event counts)
fp &lt;- forestplot(crins.ma, expo=TRUE, plot=FALSE)
labtext &lt;- fp$labeltext
labtext &lt;- cbind(labtext[,1],
                 c("treatment",
                   paste0(CrinsEtAl2014[,"exp.AR.events"], "/", CrinsEtAl2014[,"exp.total"]),
                   "",""),
                 c("control",
                   paste0(CrinsEtAl2014[,"cont.AR.events"], "/", CrinsEtAl2014[,"cont.total"]),
                   "",""),
                 labtext[,2:3])
labtext[1,4] &lt;- "OR"
print(fp$labeltext) # before
print(labtext)      # after
forestplot(crins.ma, labeltext=labtext, expo=TRUE, xlog=TRUE)

# see also the "forestplot" help for more arguments that you may change,
# e.g. the "clip", "xticks", "xlab" and "title" arguments,
# or the "txt_gp" argument for label sizes etc.:
forestplot(crins.ma, clip=c(-4,1), xticks=(-3):0,
           xlab="log-OR", title="pediatric transplantation example",
           txt_gp = fpTxtGp(ticks = gpar(cex=1), xlab = gpar(cex=1)))

## End(Not run)
</code></pre>

<hr>
<h2 id='forestplot.bmr'>
Generate a forest plot for a <code><a href="#topic+bmr">bmr</a></code> object
(based on the <code>forestplot</code> package's plotting functions).
</h2><span id='topic+forestplot.bmr'></span>

<h3>Description</h3>

<p>Generates a forest plot, showing individual estimates along with their
95 percent confidence intervals, shrinkage intervals, resulting effect
estimates and prediction intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'bmr'
forestplot(x, X.mean, X.prediction,
           labeltext, exponentiate=FALSE,
           shrinkage=TRUE, heterogeneity=TRUE, 
           digits=2, decplaces.X, plot=TRUE,
           fn.ci_norm, fn.ci_sum, col, legend=NULL, boxsize, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forestplot.bmr_+3A_x">x</code></td>
<td>

<p>a <code><a href="#topic+bmr">bmr</a></code> object.
</p>
</td></tr>
<tr><td><code id="forestplot.bmr_+3A_x.mean">X.mean</code></td>
<td>

<p>a regressor matrix (<code class="reqn">X</code>) for effect estimates that are to be
shown in the plot. By default, a diagonal matrix; set to
<code>NULL</code> in order to suppress showing summary estimates. The
matrix' row names define the labels shown in the plot.
</p>
</td></tr>
<tr><td><code id="forestplot.bmr_+3A_x.prediction">X.prediction</code></td>
<td>

<p>an optional regressor matrix (<code class="reqn">X</code>) for predictions that are to
be shown in the plot. The matrix' row names define the labels shown
in the plot.
</p>
</td></tr>
<tr><td><code id="forestplot.bmr_+3A_labeltext">labeltext</code></td>
<td>
<p>an (alternative) &ldquo;<code>labeltext</code>&rdquo; argument
which is then handed on to the <code><a href="forestplot.html#topic+forestplot">forestplot</a>()</code>
function (see the help there). You can use this to change contents
or add columns to the displayed table; see also the example below.
</p>
</td></tr>
<tr><td><code id="forestplot.bmr_+3A_exponentiate">exponentiate</code></td>
<td>

<p>a logical flag indicating whether to exponentiate numbers (effect
sizes) in table and plot.
</p>
</td></tr>
<tr><td><code id="forestplot.bmr_+3A_shrinkage">shrinkage</code></td>
<td>

<p>a logical flag indicating whether to show shrinkage intervals along
with the quoted estimates.
</p>
</td></tr>
<tr><td><code id="forestplot.bmr_+3A_heterogeneity">heterogeneity</code></td>
<td>

<p>a logical flag indicating whether to quote the heterogeneity estimate 
and CI (at the bottom left of the plot).
</p>
</td></tr>
<tr><td><code id="forestplot.bmr_+3A_digits">digits</code></td>
<td>

<p>the number of significant digits to be shown.
This is interpreted relative to the standard errors of all estimates.
</p>
</td></tr>
<tr><td><code id="forestplot.bmr_+3A_decplaces.x">decplaces.X</code></td>
<td>

<p>The number of decimal places to be shown for the regressors.
</p>
</td></tr>
<tr><td><code id="forestplot.bmr_+3A_plot">plot</code></td>
<td>

<p>a logical flag indicating whether to actually generate a plot.
</p>
</td></tr>
<tr><td><code id="forestplot.bmr_+3A_fn.ci_norm">fn.ci_norm</code>, <code id="forestplot.bmr_+3A_fn.ci_sum">fn.ci_sum</code>, <code id="forestplot.bmr_+3A_col">col</code>, <code id="forestplot.bmr_+3A_legend">legend</code>, <code id="forestplot.bmr_+3A_boxsize">boxsize</code>, <code id="forestplot.bmr_+3A_...">...</code></td>
<td>

<p>other arguments passed on to the
<span class="pkg">forestplot</span> package's <code><a href="forestplot.html#topic+forestplot">forestplot</a></code>
function (see also the help there).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generates a forest plot illustrating the underlying data and
resulting estimates (effect estimates and/or prediction intervals,
as well as shrinkage estimates and intervals).
For effect estimates and prediction intervals, regressor matrices
(<code class="reqn">X</code>) need to be supplied via the &lsquo;<code>X.mean</code>&rsquo; or
&lsquo;<code>X.prediction</code>&rsquo; arguments. Effect estimates are shown as
diamonds, predictions are shown as horizontal bars.
</p>


<h3>Value</h3>

<p>A list containing the following elements:
</p>
<table>
<tr><td><code>data</code></td>
<td>
<p>a <code>matrix</code> of estimates and CIs.</p>
</td></tr>
<tr><td><code>X.mean</code>, <code>X.prediction</code></td>
<td>
<p>the &lsquo;<code>X.mean</code>&rsquo; and
&lsquo;<code>X.prediction</code>&rsquo; arguments.</p>
</td></tr>
<tr><td><code>shrinkage</code></td>
<td>
<p>a <code>matrix</code> of shrinkage estimates and CIs.</p>
</td></tr>
<tr><td><code>labeltext</code></td>
<td>
<p>a <code>matrix</code> of table entries.</p>
</td></tr>
<tr><td><code>forestplot</code></td>
<td>
<p>result of the call to the
&lsquo;<code>forestplot()</code>&rsquo; function.</p>
</td></tr>
</table>


<h3>Note</h3>

<p>This function is based on the <span class="pkg">forestplot</span> package's
&ldquo;<code><a href="forestplot.html#topic+forestplot">forestplot</a>()</code>&rdquo; function.
</p>


<h3>Author(s)</h3>

<p>Christian Roever <a href="mailto:christian.roever@med.uni-goettingen.de">christian.roever@med.uni-goettingen.de</a>
</p>


<h3>References</h3>

<p>C. Roever, T. Friede.
Using the bayesmeta R package for Bayesian random-effects meta-regression.
<em>Computer Methods and Programs in Biomedicine</em>,
<b>299</b>:107303, 2023.
<a href="https://doi.org/10.1016/j.cmpb.2022.107303">doi:10.1016/j.cmpb.2022.107303</a>.
</p>
<p>C. Roever.
Bayesian random-effects meta-analysis using the bayesmeta R package.
<em>Journal of Statistical Software</em>, <b>93</b>(6):1-51, 2020.
<a href="https://doi.org/10.18637/jss.v093.i06">doi:10.18637/jss.v093.i06</a>.
</p>
<p>C. Lewis and M. Clarke.
Forest plots: trying to see the wood and the trees.
<em>BMJ</em>, <b>322</b>:1479, 2001.
<a href="https://doi.org/10.1136/bmj.322.7300.1479">doi:10.1136/bmj.322.7300.1479</a>.
</p>
<p>C. Guddat, U. Grouven, R. Bender and G. Skipka.
A note on the graphical presentation of prediction intervals in
random-effects meta-analyses.
<em>Systematic Reviews</em>, <b>1</b>(34), 2012.
<a href="https://doi.org/10.1186/2046-4053-1-34">doi:10.1186/2046-4053-1-34</a>.
</p>
<p>R.D. Riley, J.P. Higgins and J.J. Deeks.
Interpretation of random effects meta-analyses.
<em>BMJ</em>, <b>342</b>:d549, 2011.
<a href="https://doi.org/10.1136/bmj.d549">doi:10.1136/bmj.d549</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesmeta">bayesmeta</a></code>,
<code><a href="forestplot.html#topic+forestplot">forestplot</a></code>,
<code><a href="#topic+forestplot.bayesmeta">forestplot.bayesmeta</a></code>,
<code><a href="#topic+forestplot.escalc">forestplot.escalc</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
#################################################################
# perform a meta-analysis using binary ("indicator") covariables:

# load data:
data("CrinsEtAl2014")
# compute effect measures (log-OR):
crins.es &lt;- escalc(measure="OR",
                   ai=exp.AR.events,  n1i=exp.total,
                   ci=cont.AR.events, n2i=cont.total,
                   slab=publication, data=CrinsEtAl2014)
# show data:
crins.es[,c("publication", "IL2RA", "exp.AR.events", "exp.total",
            "cont.AR.events", "cont.total", "yi", "vi")]
# specify regressor matrix (binary indicator variables):
X &lt;- cbind("basiliximab"=as.numeric(crins.es$IL2RA=="basiliximab"),
           "daclizumab" =as.numeric(crins.es$IL2RA=="daclizumab"))
print(X)
# perform meta-analysis:
bmr01 &lt;- bmr(crins.es, X=X,
             tau.prior=function(t){dhalfnormal(t, scale=0.5)})

# show forest plot:
forestplot(bmr01)

# show forest plot including contrast
# (difference between the two groups):
forestplot(bmr01,
           X.mean=rbind("basiliximab"      = c(1, 0),
                        "daclizumab"       = c(0, 1),
                        "group difference" = c(-1, 1)))

##############################################
# perform the meta-analysis using a different 
# ("intercept / slope") regressor setup:
X &lt;- cbind("intercept"=1,
           "offset.dac"=as.numeric(crins.es$IL2RA=="daclizumab"))
print(X)
# perform meta-analysis:
bmr02 &lt;- bmr(crins.es, X=X,
             tau.prior=function(t){dhalfnormal(t, scale=0.5)})

# show default forest plot:
forestplot(bmr02)

# show forest plot including both group means and their difference:
forestplot(bmr02,
           X.mean=rbind("basiliximab"      = c(1, 0),
                        "daclizumab"       = c(1, 1),
                        "group difference" = c(0, 1)))

###############################################################
# a meta analysis using a continuous regressor
# and including prediction:
help("NicholasEtAl2019")
# load data:
data("NicholasEtAl2019")
# compute effect sizes (logarithic odds) from count data:
es &lt;- escalc(measure="PLO",
             xi=patients*(prog.percent/100), ni=patients,
             slab=study, data=NicholasEtAl2019)
# set up regressor matrix:
X &lt;- cbind("intercept2000" = 1, "year" = (es$year-2000))
# perform analysis:
bmr03 &lt;- bmr(es, X=X)
# show forest plot including some mean estimates for the
# years from 1990 to 2018, and a prediction for 2019:
forestplot(bmr03,
           X.mean=rbind("intercept (2000)"  = c(1,   0),
                        "annual change"     = c(0,   1),
                        "change per decade" = c(0,  10),
                        "mean 1990"         = c(1, -10),
                        "mean 2000"         = c(1,   0),
                        "mean 2010"         = c(1,  10),
                        "mean 2018"         = c(1,  18)),
           X.predict=rbind("prediction 2019"   = c(1,  19)),
           xlab="log-odds",
           txt_gp = fpTxtGp(ticks = gpar(cex=1), xlab = gpar(cex=1)))

# the shown summaries and predictions may also be computed "manually";
# mean effect (year 2018), posterior median and 95 percent CI:
bmr03$qpredict(p=0.5, x=c(1, 18))
bmr03$pred.interval(level=0.95, x=c(1, 18))

# prediction (year 2019), posterior median and 95 percent CI:
bmr03$qpredict(p=0.5, x=c(1, 19), mean=FALSE)
bmr03$pred.interval(level=0.95, x=c(1, 19), mean=FALSE)

# means and predictions may also be derived
# using the "summary()" function:
summary(bmr03,
        X.mean=rbind("intercept (2000)"  = c(1,   0),
                     "annual change"     = c(0,   1),
                     "change per decade" = c(0,  10),
                     "mean 1990"         = c(1, -10),
                     "mean 2000"         = c(1,   0),
                     "mean 2010"         = c(1,  10),
                     "mean 2018"         = c(1,  18)),
        X.predict=rbind("prediction 2019"   = c(1,  19)))


##########################################################
# the tabular part of the forest plot may also be changed;
# draw a default plot:
forestplot(bmr03)
# don't plot, only extract the tabular bits:
fp &lt;- forestplot(bmr03, plot=FALSE)
labtxt &lt;- fp$labeltext
head(labtxt)

# drop two columns:
labtxt &lt;- labtxt[,-c(2,3)]
# add two new columns:
labtxt &lt;- cbind(labtxt[,1],
                c("year", es$year, "",""),
                c("events / total",
                  paste(round(es$patients*(es$prog.percent/100)),
                  "/", es$patients), "",""),
                labtxt[,2:3])
head(labtxt)
# draw new forest plot:
forestplot(bmr03, labeltext=labtxt, xlab="log-odds")

## End(Not run)
</code></pre>

<hr>
<h2 id='forestplot.escalc'>
Generate a forest plot for an <code><a href="metafor.html#topic+escalc">escalc</a></code> object
(based on the <code>forestplot</code> package's plotting functions).
</h2><span id='topic+forestplot.escalc'></span>

<h3>Description</h3>

<p>Generates a forest plot, showing estimates along with their
95 percent confidence intervals.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'escalc'
forestplot(x, labeltext, exponentiate=FALSE,
           digits=2, plot=TRUE,
           fn.ci_norm, fn.ci_sum, col, boxsize, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="forestplot.escalc_+3A_x">x</code></td>
<td>

<p>an <code><a href="metafor.html#topic+escalc">escalc</a></code> object.
</p>
</td></tr>
<tr><td><code id="forestplot.escalc_+3A_labeltext">labeltext</code></td>
<td>
<p>an (alternative) &ldquo;<code>labeltext</code>&rdquo; argument
which is then handed on to the <code><a href="forestplot.html#topic+forestplot">forestplot</a>()</code>
function (see the help there). You can use this to change contents
or add columns to the displayed table; see the example below.
</p>
</td></tr>
<tr><td><code id="forestplot.escalc_+3A_exponentiate">exponentiate</code></td>
<td>

<p>a logical flag indicating whether to exponentiate numbers (effect
sizes) in table and plot.
</p>
</td></tr>
<tr><td><code id="forestplot.escalc_+3A_digits">digits</code></td>
<td>

<p>The number of significant digits to be shown.
This is interpreted relative to the standard errors of all estimates.
</p>
</td></tr>
<tr><td><code id="forestplot.escalc_+3A_plot">plot</code></td>
<td>

<p>a logical flag indicating whether to actually generate a plot.
</p>
</td></tr>
<tr><td><code id="forestplot.escalc_+3A_fn.ci_norm">fn.ci_norm</code>, <code id="forestplot.escalc_+3A_fn.ci_sum">fn.ci_sum</code>, <code id="forestplot.escalc_+3A_col">col</code>, <code id="forestplot.escalc_+3A_boxsize">boxsize</code>, <code id="forestplot.escalc_+3A_...">...</code></td>
<td>

<p>other arguments passed on to the
<span class="pkg">forestplot</span> package's <code><a href="forestplot.html#topic+forestplot">forestplot</a></code>
function (see also the help there).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generates a forest plot illustrating the data returned by the
&ldquo;<code><a href="metafor.html#topic+escalc">escalc</a>()</code>&rdquo; function (showing the
estimates potentially to be meta-analyzed, but without a combined
summary estimate).
</p>


<h3>Note</h3>

<p>This function is based on the <span class="pkg">forestplot</span> package's
&ldquo;<code><a href="forestplot.html#topic+forestplot">forestplot</a>()</code>&rdquo; function.
</p>


<h3>Author(s)</h3>

<p>Christian Roever <a href="mailto:christian.roever@med.uni-goettingen.de">christian.roever@med.uni-goettingen.de</a>
</p>


<h3>References</h3>

<p>C. Roever.
Bayesian random-effects meta-analysis using the bayesmeta R package.
<em>Journal of Statistical Software</em>, <b>93</b>(6):1-51, 2020.
<a href="https://doi.org/10.18637/jss.v093.i06">doi:10.18637/jss.v093.i06</a>.
</p>
<p>C. Lewis and M. Clarke.
Forest plots: trying to see the wood and the trees.
<em>BMJ</em>, <b>322</b>:1479, 2001.
<a href="https://doi.org/10.1136/bmj.322.7300.1479">doi:10.1136/bmj.322.7300.1479</a>.
</p>
<p>R.D. Riley, J.P. Higgins and J.J. Deeks.
Interpretation of random effects meta-analyses.
<em>BMJ</em>, <b>342</b>:d549, 2011.
<a href="https://doi.org/10.1136/bmj.d549">doi:10.1136/bmj.d549</a>.
</p>


<h3>See Also</h3>

<p><code><a href="metafor.html#topic+escalc">escalc</a></code>,
<code><a href="forestplot.html#topic+forestplot">forestplot</a></code>,
<code><a href="#topic+forestplot.bayesmeta">forestplot.bayesmeta</a></code>,
<code><a href="#topic+forestplot.bmr">forestplot.bmr</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data:
data("CrinsEtAl2014")

# compute effect sizes (log odds ratios) from count data
# (using "metafor" package's "escalc()" function):
crins.es &lt;- escalc(measure="OR",
                   ai=exp.AR.events,  n1i=exp.total,
                   ci=cont.AR.events, n2i=cont.total,
                   slab=publication, data=CrinsEtAl2014)
print(crins.es)

########################
# generate forest plots;
# with default settings:
forestplot(crins.es)

# exponentiate values (shown in table and plot), show vertical line at OR=1:
forestplot(crins.es, expo=TRUE, zero=1)

# logarithmic x-axis:
forestplot(crins.es, expo=TRUE, xlog=TRUE)

# show more decimal places:
forestplot(crins.es, digits=3)

# change table values:
# (here: add columns for event counts)
fp &lt;- forestplot(crins.es, expo=TRUE, plot=FALSE)
labtext &lt;- fp$labeltext
labtext &lt;- cbind(labtext[,1],
                 c("treatment",
                   paste0(CrinsEtAl2014[,"exp.AR.events"], "/", CrinsEtAl2014[,"exp.total"])),
                 c("control",
                   paste0(CrinsEtAl2014[,"cont.AR.events"], "/", CrinsEtAl2014[,"cont.total"])),
                 labtext[,2:3])
labtext[1,4] &lt;- "OR"
print(fp$labeltext) # before
print(labtext)      # after
forestplot(crins.es, labeltext=labtext, expo=TRUE, xlog=TRUE)

# see also the "forestplot" help for more arguments that you may change,
# e.g. the "clip", "xticks", "xlab" and "title" arguments,
# or the "txt_gp" argument for label sizes etc.:
forestplot(crins.es, clip=c(-4,1), xticks=(-3):0,
           xlab="log-OR", title="pediatric transplantation example",
           txt_gp = fpTxtGp(ticks = gpar(cex=1), xlab = gpar(cex=1)))


###########################################################
# In case effects and standard errors are computed already
# (and normally one wouldn't need to call "escalc()")
# you can still use "escalc()" to assemble the plot, e.g.:

data("HinksEtAl2010")
print(HinksEtAl2010)

hinks.es &lt;- escalc(yi=log.or, sei=log.or.se,
                   slab=study, measure="OR",
                   data=HinksEtAl2010)

forestplot(hinks.es)
</code></pre>

<hr>
<h2 id='funnel.bayesmeta'>
Generate a funnel plot for a <code><a href="#topic+bayesmeta">bayesmeta</a></code> object.
</h2><span id='topic+funnel.bayesmeta'></span>

<h3>Description</h3>

<p>Generates a funnel plot, showing effect estimates (<code class="reqn">y_i</code>)
vs. their standard errors (<code class="reqn">\sigma_i</code>). 
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'bayesmeta'
funnel(x, main=deparse(substitute(x)), xlab=expression("effect "*y[i]),
       ylab=expression("standard error "*sigma[i]),
       zero=0.0, FE=FALSE, legend=FE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="funnel.bayesmeta_+3A_x">x</code></td>
<td>

<p>a <code><a href="#topic+bayesmeta">bayesmeta</a></code> object.
</p>
</td></tr>
<tr><td><code id="funnel.bayesmeta_+3A_main">main</code></td>
<td>

<p>main title for the plot.
</p>
</td></tr>
<tr><td><code id="funnel.bayesmeta_+3A_xlab">xlab</code></td>
<td>

<p>x-axis title.
</p>
</td></tr>
<tr><td><code id="funnel.bayesmeta_+3A_ylab">ylab</code></td>
<td>

<p>y-axis title.
</p>
</td></tr>
<tr><td><code id="funnel.bayesmeta_+3A_zero">zero</code></td>
<td>

<p>value at which a vertical &lsquo;reference&rsquo; line should be drawn
(default is 0). The line can be suppressed by setting this argument
to &lsquo;<code>NA</code>&rsquo;.
</p>
</td></tr>
<tr><td><code id="funnel.bayesmeta_+3A_fe">FE</code></td>
<td>

<p>a (<code>logical</code>) flag indicating whether the &ldquo;fixed effect&rdquo;
(FE) funnel (for <code class="reqn">\tau=0</code>) is supposed to be shown along with
the &ldquo;random effects&rdquo; (RE) funnel.
</p>
</td></tr>
<tr><td><code id="funnel.bayesmeta_+3A_legend">legend</code></td>
<td>

<p>a (<code>logical</code>) flag indicating whether a legend identifying
&lsquo;RE&rsquo; and &lsquo;FE&rsquo; funnels is supposed to be shown.
</p>
</td></tr>
<tr><td><code id="funnel.bayesmeta_+3A_...">...</code></td>
<td>

<p>other arguments passed to the <code>plot()</code> function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generates a funnel plot of effect estimates (<code class="reqn">y_i</code>)
on the x-axis vs. their associated standard errors
(<code class="reqn">\sigma_i</code>) on the y-axis (Note that the y-axis is
pointing downwards). For many studies (large <code class="reqn">k</code>) and in the
absence of publication (selection) bias, the plot should resemble a
(more or less) symmetric &ldquo;funnel&rdquo; shape (Sterne <em>et al</em>,
2005). Presence of publication bias, i.e., selection bias due to the
fact that more dramatic effects may have higher chances of publication
than less pronounced (or less controversial) findings, may cause
asymmetry in the plot; especially towards the bottom of the plot,
studies may then populate a preferred corner. 
</p>
<p>Besides the <code class="reqn">k</code> individual studies that are shown as circles, a
vertical reference line is shown; its position is determined by
the &lsquo;<code>zero</code>&rsquo; argument.  The &ldquo;funnel&rdquo; indicated in
grey shows the estimated central 95% prediction interval for
&ldquo;new&rdquo; effect estimates <code class="reqn">y_i</code> conditional on a
particular standard error <code class="reqn">\sigma_i</code>, which results from
convolving the prediction interval for the <em>true</em> value
<code class="reqn">\theta_i</code> with a normal distribution with variance
<code class="reqn">\sigma_i^2</code>. At <code class="reqn">\sigma_i=0</code> (top of
the funnel), this simply corresponds to the &ldquo;plain&rdquo; prediction
interval for <code class="reqn">\theta_i</code>. Convolutions are computed via
the <code><a href="#topic+convolve">convolve</a>()</code> function, using the algorithm described
in Roever and Friede (2017).
</p>
<p>By setting the &ldquo;<code>FE=TRUE</code>&rdquo; argument, one may request a
&ldquo;fixed effect&rdquo; (FE) funnel along with the &ldquo;random
effects&rdquo; (RE) funnel that is shown by default. The FE funnel is
analogous to the RE funnel, except that it is based on
<em>homogeneity</em> (<code class="reqn">\tau=0</code>).
</p>


<h3>Note</h3>

<p>Especially for few studies (small <code class="reqn">k</code>), the conclusions from a
forest plot are usually not very obvious (Sterne <em>et al</em>, 2011;
Terrin <em>et al.</em>, 2005). Publication bias often requires rather
large sample sizes to become apparent; funnel plots should hence
always be interpreted with caution. 
</p>


<h3>Author(s)</h3>

<p>Christian Roever <a href="mailto:christian.roever@med.uni-goettingen.de">christian.roever@med.uni-goettingen.de</a>
</p>


<h3>References</h3>

<p>J.A.C. Sterne, B.J. Becker and M. Egger.
The funnel plot.
In: H.R. Rothstein, A.J. Sutton and M. Borenstein, eds.
<em>Publication bias in meta-analysis - prevention,
assessment and adjustments</em>.
Wiley and Sons, 2005 (Chapter 5).
<a href="https://doi.org/10.1002/0470870168.ch5">doi:10.1002/0470870168.ch5</a>.
</p>
<p>J.A.C. Sterne <em>et al</em>.
Recommendations for examining and interpreting funnel plot asymmetry
in meta-analyses of randomised controlled trials.
<em>BMJ</em>, <b>343</b>:d4002, 2011.
<a href="https://doi.org/10.1136/bmj.d4002">doi:10.1136/bmj.d4002</a>.
</p>
<p>N. Terrin, C.H. Schmid and J. Lau.
In an empirical evaluation of the funnel plot, researchers could not
visually identify publication bias.
<em>Journal of Clinical Epidemiology</em>, <b>58</b>(9):894-901, 2005.
<a href="https://doi.org/10.1016/j.jclinepi.2005.01.006">doi:10.1016/j.jclinepi.2005.01.006</a>.
</p>
<p>C. Roever, T. Friede.
Discrete approximation of a mixture distribution via restricted divergence.
<em>Journal of Computational and Graphical Statistics</em>,
<b>26</b>(1):217-222, 2017.
<a href="https://doi.org/10.1080/10618600.2016.1276840">doi:10.1080/10618600.2016.1276840</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesmeta">bayesmeta</a></code>, <code><a href="metafor.html#topic+funnel">funnel</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("dat.egger2001", package="metafor")
es &lt;- escalc(measure="OR", ai=ai, n1i=n1i, ci=ci, n2i=n2i,
             slab=study, data=dat.egger2001)
## Not run: 
bm &lt;- bayesmeta(es)
print(bm)
forestplot(bm)
funnel(bm, xlab="logarithmic odds ratio", ylab="standard error",
       main="Egger (2001) example data")

## End(Not run)
</code></pre>

<hr>
<h2 id='GoralczykEtAl2011'>Liver transplant example data</h2><span id='topic+GoralczykEtAl2011'></span>

<h3>Description</h3>

<p>Numbers of cases (transplant patients) and events (acute rejections,
steroid resistant rejections, and deaths) in experimental and control groups of
19 studies.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("GoralczykEtAl2011")</code></pre>


<h3>Format</h3>

<p>The data frame contains the following columns:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <b>publication</b>        </td><td style="text-align: left;"> <code>character</code> </td><td style="text-align: left;"> publication identifier (first author and publication year) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>year</b>               </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> publication year </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>randomized</b>         </td><td style="text-align: left;"> <code>factor</code>    </td><td style="text-align: left;"> randomization status (yes / no / not stated) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>control.type</b>       </td><td style="text-align: left;"> <code>factor</code>    </td><td style="text-align: left;"> type of control group (&lsquo;concurrent&rsquo; or &lsquo;historical&rsquo;)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>comparison</b>         </td><td style="text-align: left;"> <code>factor</code>    </td><td style="text-align: left;"> type of comparison (&lsquo;IL-2RA only&rsquo;, &lsquo;delayed CNI&rsquo;, or &lsquo;no/low steroids&rsquo;) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>IL2RA</b>              </td><td style="text-align: left;"> <code>factor</code>    </td><td style="text-align: left;"> type of interleukin-2 receptor antagonist (IL-2RA) (&lsquo;basiliximab&rsquo; or &lsquo;daclizumab&rsquo;) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>CNI</b>                </td><td style="text-align: left;"> <code>factor</code>    </td><td style="text-align: left;"> type of calcineurin inhibitor (CNI) (&lsquo;tacrolimus&rsquo; or &lsquo;cyclosporine A&rsquo;) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>MMF</b>                </td><td style="text-align: left;"> <code>factor</code>    </td><td style="text-align: left;"> use of mycofenolate mofetil (MMF) (y/n) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>followup</b>           </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> follow-up time in months </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>treat.AR.events</b>    </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of AR events in experimental group </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>treat.SRR.events</b>   </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of SRR events in experimental group </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>treat.deaths</b>       </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of deaths in experimental group </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>treat.total</b>        </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of cases in experimental group </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>control.AR.events</b>  </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of AR events in control group </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>control.SRR.events</b> </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of SRR events in control group </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>control.deaths</b>     </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of deaths in control group </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>control.total</b>      </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of cases in control group </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Details</h3>

<p>A systematic literature review investigated the evidence on the
effect of Interleukin-2 receptor antagonists (IL-2RA) and resulted in
19 controlled studies reporting acute rejection (AR) and
steroid-resistant rejection (SRR) rates as well as mortality in adult
liver transplant recipients.
</p>


<h3>Source</h3>

<p>A.D. Goralczyk, N. Hauke, N. Bari, T.Y. Tsui, T. Lorf, A. Obed.
Interleukin-2 receptor antagonists for liver transplant recipients:
A systematic review and meta-analysis of controlled studies.
<em>Hepatology</em>, <b>54</b>(2):541-554, 2011.
<a href="https://doi.org/10.1002/hep.24385">doi:10.1002/hep.24385</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+CrinsEtAl2014">CrinsEtAl2014</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("GoralczykEtAl2011")
## Not run: 
# compute effect sizes (log odds ratios) from count data
# (using "metafor" package's "escalc()" function):
require("metafor")
goralczyk.es &lt;- escalc(measure="OR",
                       ai=exp.AR.events,  n1i=exp.total,
                       ci=cont.AR.events, n2i=cont.total,
                       slab=publication, data=GoralczykEtAl2011)
print(goralczyk.es[,c(1,10,12,13,15,16,17)])

# analyze using weakly informative half-Cauchy prior for heterogeneity:
goralczyk.ma &lt;- bayesmeta(goralczyk.es, tau.prior=function(t){dhalfcauchy(t,scale=1)})

# show summary:
print(goralczyk.ma)

# show forest plot:
forestplot(goralczyk.ma)

## End(Not run)
</code></pre>

<hr>
<h2 id='HinksEtAl2010'>JIA example data</h2><span id='topic+HinksEtAl2010'></span>

<h3>Description</h3>

<p>Log odds ratios indicating association of a genetic variant
(CCR5) with juvenile idiopathic arthritis (JIA).</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("HinksEtAl2010")</code></pre>


<h3>Format</h3>

<p>The data frame contains the following columns:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <b>study</b>     </td><td style="text-align: left;"> <code>character</code> </td><td style="text-align: left;"> publication identifier </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>year</b>      </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> publication year </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>country</b>   </td><td style="text-align: left;"> <code>character</code> </td><td style="text-align: left;"> country </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>or</b>        </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> odds ratio (OR)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>or.lower</b>  </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> lower 95 percent confidence bound for OR </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>or.upper</b>  </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> upper 95 percent confidence bound for OR </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>log.or</b>    </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> logarithmic OR </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>log.or.se</b> </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> standard error of logarithmic OR </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Details</h3>

<p>Results from a genetic association study (Hinks et al, 2010) were
combined with data from two additional studies (Prahalad et al., 2006;
Lindner et al., 2007) in order to determine the combined evidence
regarding the association of a particular genetic marker (CCR5) with
juvenile idiopathic arthritis (JIA).
</p>


<h3>Source</h3>

<p>A. Hinks et al.
Association of the CCR5 gene with juvenile idiopathic arthritis.
<em>Genes and Immunity</em>, <b>11</b>(7):584-589, 2010.
<a href="https://doi.org/10.1038/gene.2010.25">doi:10.1038/gene.2010.25</a>.
</p>


<h3>References</h3>

<p>S. Prahalad et al.
Association of two functional polymorphisms in the CCR5 gene with
juvenile rheumatoid arthritis.
<em>Genes and Immunity</em>, <b>7</b>:468-475, 2006.
<a href="https://doi.org/10.1038/sj.gene.6364317">doi:10.1038/sj.gene.6364317</a>.
</p>
<p>E. Lindner et al.
Lack of association between the chemokine receptor 5 polymorphism
CCR5delta32 in rheumatoid arthritis and juvenile idiopathic arthritis.
<em>BMC Medical Genetics</em>, <b>8</b>:33, 2007.
<a href="https://doi.org/10.1186/1471-2350-8-33">doi:10.1186/1471-2350-8-33</a>.
</p>
<p>C. Roever, G. Knapp, T. Friede.
Hartung-Knapp-Sidik-Jonkman approach and its modification for
random-effects meta-analysis with few studies.
<em>BMC Medical Research Methodology</em>, 15:99, 2015.
<a href="https://doi.org/10.1186/s12874-015-0091-1">doi:10.1186/s12874-015-0091-1</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("HinksEtAl2010")

## Not run: 
# perform meta analysis based on weakly informative half-normal prior:
bma01 &lt;- bayesmeta(y      = HinksEtAl2010$log.or,
                   sigma  = HinksEtAl2010$log.or.se,
                   labels = HinksEtAl2010$study,
                   tau.prior = function(t){dhalfnormal(t,scale=1.0)})

# perform meta analysis based on slightly more informative half-normal prior:
bma02 &lt;- bayesmeta(y      = HinksEtAl2010$log.or,
                   sigma  = HinksEtAl2010$log.or.se,
                   labels = HinksEtAl2010$study,
                   tau.prior = function(t){dhalfnormal(t,scale=0.5)})

# show heterogeneity posteriors:
par(mfrow=c(2,1))
plot(bma01, which=4, prior=TRUE, taulim=c(0,1))
plot(bma02, which=4, prior=TRUE, taulim=c(0,1))
par(mfrow=c(1,1))

# show heterogeneity estimates:
rbind("half-normal(1.0)"=bma01$summary[,"tau"],
      "half-normal(0.5)"=bma02$summary[,"tau"])
# show q-profile confidence interval for tau in comparison:
require("metafor")
ma03 &lt;- rma.uni(yi=log.or, sei=log.or.se, slab=study, data=HinksEtAl2010)
confint(ma03)$random["tau",c("ci.lb","ci.ub")]
# show I2 values in the relevant range:
tau &lt;- seq(0, 0.7, by=0.1)
cbind("tau"=tau,
      "I2" =bma01$I2(tau=tau))

# show effect estimates:
round(rbind("half-normal(1.0)" = bma01$summary[,"mu"],
            "half-normal(0.5)" = bma02$summary[,"mu"]), 5)

# show forest plot:
forestplot(bma02)
# show shrinkage estimates:
bma02$theta

## End(Not run)
</code></pre>

<hr>
<h2 id='KarnerEtAl2014'>COPD example data</h2><span id='topic+KarnerEtAl2014'></span>

<h3>Description</h3>

<p>Data on several endpoints from a systematic review in <em>chronic obstructive pulmonary disease (COPD)</em>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("KarnerEtAl2014")</code></pre>


<h3>Format</h3>

<p>The data frame contains the following columns:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <b>study</b>              </td><td style="text-align: left;"> <code>character</code> </td><td style="text-align: left;"> publication identifier (first author and publication year) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>year</b>               </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> publication year </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>duration</b>           </td><td style="text-align: left;"> <code>factor</code>    </td><td style="text-align: left;"> study duration (<code class="reqn">&lt;1</code> year vs. <code class="reqn">\geq 1</code> year) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>inhaler</b>            </td><td style="text-align: left;"> <code>factor</code>    </td><td style="text-align: left;"> type of inhaler investigated (&ldquo;dry powder&rdquo; or &ldquo;soft mist&rdquo;) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>baseline.age</b>       </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> mean age at baseline </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>baseline.males</b>     </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> proportion of males among study participants </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>baseline.fev1</b>      </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> mean FEV1 at baseline (L) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>baseline.fev1pp</b>    </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> mean FEV1 (percent of predicted) at baseline </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>baseline.pyr</b>       </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> mean number of pack-years (smoking history) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>tiotropium.total</b>   </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> total number of patients in the treatment group </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>tiotropium.exa</b>     </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of patients with <code class="reqn">\geq 1</code> exacerbation in the treatment group </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>tiotropium.sexa</b>    </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of patients with <code class="reqn">\geq 1</code> <em>severe</em> exacerbation in the treatment group </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>tiotropium.hospi</b>   </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of patients with <code class="reqn">\geq 1</code> hospitalisation (all-cause) in the treatment group </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>tiotropium.deaths</b>  </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of deaths in the treatment group</td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>tiotropium.sae</b>     </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of patients with <code class="reqn">\geq 1</code> serious adverse event (non-fatal) in the treatment group </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>tiotropium.dropout</b> </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of withdrawals in the treatment group </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>placebo.total</b>      </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> total number of patients in the control group </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>placebo.exa</b>        </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of patients with <code class="reqn">\geq 1</code> exacerbation in the control group </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>placebo.sexa</b>       </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of patients with <code class="reqn">\geq 1</code> <em>severe</em> exacerbation in the control group </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>placebo.hospi</b>      </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of patients with <code class="reqn">\geq 1</code> hospitalisation (all-cause) in the control group </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>placebo.deaths</b>     </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of deaths in the control group</td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>placebo.sae</b>        </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of patients with <code class="reqn">\geq 1</code> serious adverse event (non-fatal) in the control group </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>placebo.dropout</b>    </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of withdrawals in the control group </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>sgrq.md</b>, <b>sgrq.se</b> </td><td style="text-align: left;"> <code>numeric</code> </td><td style="text-align: left;"> mean difference and associated standard error for <em>St. George's respiratory questionnaire (SGRQ)</em> total score </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>fev1.md</b>, <b>fev1.se</b> </td><td style="text-align: left;"> <code>numeric</code> </td><td style="text-align: left;"> mean difference and associated standard error for <em>forced expiratory volume in 1 second (FEV1, mL)</em> </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Details</h3>

<p>Chronic obstructive pulmonary disease (COPD) is a chronic and
progressive condition characterized by recurrent exacerbation
phases. Various treatment options are available, aimed at both
providing relief during an acute exacerbation, and at delaying overall
disease progression. A common drug used in the management of COPD is
<em>tiotropium</em>, a long-acting muscarinic antagonist (LAMA), which
is administered via an inhaler device.
</p>
<p>Karner <em>et al.</em> (2014) conducted a systematic review in order to
evaluate the evidence on the effects of tiotropium in comparison to
placebo. 22 placebo-controlled studies were found, and a range of
endpoints and subgroups were considered. The data reproduced here
relate to analyses 1.1, 1.9, 1.14, 1.15, 1.19, 1.26, 1.27 and 1.28 in
the original investigation. A number of study-level covariables are
also provided.
</p>


<h3>Source</h3>

<p>C. Karner, J. Chong, P. Poole.
Tiotropium versus placebo for chronic obstructive pulmonary disease.
<em>Cochrane Database of Systematic Reviews</em>, <b>7</b>:CD009285, 2014.
<a href="https://doi.org/10.1002/14651858.CD009285.pub3">doi:10.1002/14651858.CD009285.pub3</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("KarnerEtAl2014")
## Not run: 
# compute effect sizes (log odds ratios) from exacerbation count data
# (using the "metafor" package's "escalc()" function):
karner.exa &lt;- escalc(measure="OR",
                     ai=tiotropium.exa, n1i=tiotropium.total,
                     ci=placebo.exa,    n2i=placebo.total,
                     slab=study, data=KarnerEtAl2014)
# show forest plot:
forestplot(karner.exa, title="exacerbation",
           exponentiate=TRUE, xlog=TRUE,
           xlab="odds ratio")

# derive St. George's Respiratory Questionnaire (SGRQ) effect sizes:
karner.sgrq &lt;- escalc(measure="MD",
                      yi=sgrq.md, sei=sgrq.se,
                      slab=study, data=KarnerEtAl2014,
                      subset=is.finite(KarnerEtAl2014$sgrq.md))
# show forest plot:
forestplot(karner.sgrq, title="SGRQ",
           xlab="mean difference")


## End(Not run)
</code></pre>

<hr>
<h2 id='kldiv'>Kullback-Leibler divergence of two multivariate normal distributions.</h2><span id='topic+kldiv'></span>

<h3>Description</h3>

<p>Compute the Kullback-Leiber divergence or
<em>symmetrized</em> KL-divergence based on means
and covariances of two normal distributions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  kldiv(mu1, mu2, sigma1, sigma2, symmetrized=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="kldiv_+3A_mu1">mu1</code>, <code id="kldiv_+3A_mu2">mu2</code></td>
<td>
<p>the two mean vectors.</p>
</td></tr>
<tr><td><code id="kldiv_+3A_sigma1">sigma1</code>, <code id="kldiv_+3A_sigma2">sigma2</code></td>
<td>
<p>the two covariance matrices.</p>
</td></tr>
<tr><td><code id="kldiv_+3A_symmetrized">symmetrized</code></td>
<td>
<p>logical; if <code>TRUE</code>, the <em>symmetrized</em> divergence will be returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Kullback-Leibler divergence (or <em>relative entropy</em>) of two
probability distributions <code class="reqn">p</code> and <code class="reqn">q</code> is defined as the
integral
</p>
<p style="text-align: center;"><code class="reqn">D_{\mathrm{KL}}(p\,||\,q) = \int_\Theta
    \log\Bigl(\frac{p(\theta)}{q(\theta)}\Bigr)\, p(\theta)\,
    \mathrm{d}\theta.</code>
</p>

<p>In the case of two normal distributions with mean and variance
parameters given by (<code class="reqn">\mu_1</code>, <code class="reqn">\Sigma_1</code>) and
(<code class="reqn">\mu_2</code>, <code class="reqn">\Sigma_2</code>), respectively, this
results as 
</p>
<p style="text-align: center;"><code class="reqn">D_{\mathrm{KL}}\bigl(p(\theta|\mu_1,\Sigma_1)\,||\,p(\theta|\mu_2,\Sigma_2)\bigr) = \frac{1}{2}\biggl(\mathrm{tr}(\Sigma_2^{-1} \Sigma_1) + (\mu_1-\mu_2)^\prime \Sigma_2^{-1} (\mu_1-\mu_2) - d + \log\Bigl(\frac{\det(\Sigma_2)}{\det(\Sigma_1)}\Bigr)\biggr)</code>
</p>

<p>where <code class="reqn">d</code> is the dimension.
</p>
<p>The <em>symmetrized</em> divergence simply results as
</p>
<p style="text-align: center;"><code class="reqn">D_{\mathrm{s}}(p\,||\,q)=D_{\mathrm{KL}}(p\,||\,q)+D_{\mathrm{KL}}(q\,||\,p).</code>
</p>



<h3>Value</h3>

<p>The divergence (<code class="reqn">D_{\mathrm{KL}} \geq 0 </code> or <code class="reqn">D_{\mathrm{s}} \geq 0 </code>).
</p>


<h3>Author(s)</h3>

<p>Christian Roever <a href="mailto:christian.roever@med.uni-goettingen.de">christian.roever@med.uni-goettingen.de</a>
</p>


<h3>References</h3>

<p>S. Kullback. <em>Information theory and statistics</em>.
John Wiley and Sons, New York, 1959.
</p>
<p>C. Roever, T. Friede.
Discrete approximation of a mixture distribution via restricted divergence.
<em>Journal of Computational and Graphical Statistics</em>,
<b>26</b>(1):217-222, 2017.
<a href="https://doi.org/10.1080/10618600.2016.1276840">doi:10.1080/10618600.2016.1276840</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bmr">bmr</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>kldiv(mu1=c(0,0), mu2=c(1,1), sigma1=diag(c(2,2)), sigma2=diag(c(3,3)))
</code></pre>

<hr>
<h2 id='NicholasEtAl2019'>Multiple sclerosis disability progression example data</h2><span id='topic+NicholasEtAl2019'></span>

<h3>Description</h3>

<p>Proportions of patients with disability progression in the placebo groups of 28 studies.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("NicholasEtAl2019")</code></pre>


<h3>Format</h3>

<p>The data frame contains the following columns:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <b>study</b>        </td><td style="text-align: left;"> <code>character</code> </td><td style="text-align: left;"> publication identifier (first author and publication year) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>year</b>         </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> publication year </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>patients</b>     </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of placebo patients </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>prog.percent</b> </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> percentage of patients with disability progression </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Details</h3>

<p>A systematic literature review investigated the characteristics of
randomized placebo-controlled trials in multiple sclerosis published
between 1988 and 2018 (Nicholas <em>et al.</em>, 2019). A number of
trends were observed in the trial characteristics over the
investigated period; one of these was a decline in the proportion of
placebo patients experiencing <em>disability progression within 24
months</em> during the course of a study. The data set contains the
placebo groups' sizes along with the percentages of progressing
patients within that group for 28 studies. The data were originally
extracted from tables or Kaplan-Meier curves.
</p>


<h3>Source</h3>

<p>R.S. Nicholas, E. Han, J. Raffel, J. Chataway, T. Friede.
Over three decades study populations in progressive multiple sclerosis
have become older and more disabled, but have lower on-trial
progression rates: A systematic review and meta-analysis of 43
randomised placebo-controlled trials.
<em>Multiple Sclerosis Journal</em>, <b>25</b>(11):1462-1471, 2019.
<a href="https://doi.org/10.1177/1352458518794063">doi:10.1177/1352458518794063</a>.
</p>


<h3>References</h3>

<p>C. Roever, T. Friede.
Using the bayesmeta R package for Bayesian random-effects meta-regression.
<em>Computer Methods and Programs in Biomedicine</em>,
<b>299</b>:107303, 2023.
<a href="https://doi.org/10.1016/j.cmpb.2022.107303">doi:10.1016/j.cmpb.2022.107303</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data:
data("NicholasEtAl2019")

# show data:
head(NicholasEtAl2019)

## Not run: 
# compute effect sizes (logarithmic odds) from count data
# (note: effect of potential drop-outs is ignored here):
es &lt;- escalc(measure="PLO",
             xi=patients*(prog.percent/100), ni=patients,
             slab=study, data=NicholasEtAl2019)

# illustrate estimates (log-odds):
forestplot(es, zero=NA, xlab="log(odds)", title="Nicholas et al. (2019) data")

# set up regressor matrix
# (note: "year" variable is re-scaled so that the intercept
# corresponds to the log-odds at year=2000):
X &lt;- cbind("intercept2000" = 1, "year" = (es$year-2000))

# perform analysis:
bmr01 &lt;- bmr(es, X=X)

# show results:
print(bmr01)
plot(bmr01)

# illustrate the data and time trend;
# first derive predictions from the model
# and specify corresponding "regressor matrix":
newx &lt;- cbind(1, (1989:2019)-2000)

# compute credible intervals for the mean:
pred &lt;- cbind("median"=bmr01$qpred(0.5, x=newx),
              bmr01$pred.interval(x=newx))

# compute prediction intervals:
map &lt;- cbind("median"=bmr01$qpred(0.5, x=newx, mean=FALSE),
              bmr01$pred.interval(x=newx, mean=FALSE))

# draw empty plot:
plot(range(newx[,2]), range(map), type="n",
     xlab="publication year - 2000", ylab="log(odds)")

# show the 26 studies' estimates (and 95 percent CIs):
matlines(rbind(es$year, es$year)-2000,
         rbind(es$yi-qnorm(0.975)*sqrt(es$vi), es$yi+qnorm(0.975)*sqrt(es$vi)),
         col=1, lty=1)
points(es$year-2000, es$yi)

# show trend lines (and 95 percent intervals):
matlines(newx[,2], map, col="blue", lty=c(1,2,2))
matlines(newx[,2], pred, col="red", lty=c(1,2,2))
legend("topright", pch=15, col=c("red","blue"), c("mean","prediction"))

## End(Not run)
</code></pre>

<hr>
<h2 id='normalmixture'>
Compute normal mixtures
</h2><span id='topic+normalmixture'></span>

<h3>Description</h3>

<p>This function allows to derive density, distribution function and
quantile function of a normal mixture with fixed mean (<code class="reqn">\mu</code>) and
random standard deviation (<code class="reqn">\sigma</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  normalmixture(density,
                cdf = Vectorize(function(x){integrate(density,0,x)$value}),
                mu = 0, delta = 0.01, epsilon = 0.0001,
                rel.tol.integrate = 2^16*.Machine$double.eps,
                abs.tol.integrate = rel.tol.integrate,
                tol.uniroot = rel.tol.integrate)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="normalmixture_+3A_density">density</code></td>
<td>

<p>the <code class="reqn">\sigma</code> mixing distribution's probability density
<code>function</code>.
</p>
</td></tr>
<tr><td><code id="normalmixture_+3A_cdf">cdf</code></td>
<td>

<p>the <code class="reqn">\sigma</code> mixing distribution's cumulative distribution
<code>function</code>.
</p>
</td></tr>
<tr><td><code id="normalmixture_+3A_mu">mu</code></td>
<td>

<p>the normal mean (<code class="reqn">\mu</code>).
</p>
</td></tr>
<tr><td><code id="normalmixture_+3A_delta">delta</code>, <code id="normalmixture_+3A_epsilon">epsilon</code></td>
<td>

<p>the parameters specifying the desired accuracy for approximation of
the mixing distribution, and with that determining the number of
<code class="reqn">\sigma</code> support points being used internally. Smaller values
imply greater accuracy and greater computational burden (Roever and
Friede, 2017).
</p>
</td></tr>
<tr><td><code id="normalmixture_+3A_rel.tol.integrate">rel.tol.integrate</code>, <code id="normalmixture_+3A_abs.tol.integrate">abs.tol.integrate</code>, <code id="normalmixture_+3A_tol.uniroot">tol.uniroot</code></td>
<td>

<p>the <code>rel.tol</code>, <code>abs.tol</code> and <code>tol</code>
&lsquo;accuracy&rsquo; arguments that are passed to
the <code><a href="stats.html#topic+integrate">integrate</a>()</code> or <code><a href="stats.html#topic+uniroot">uniroot</a>()</code> functions
for internal numerical integration or root finding
(see also the help there).
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When a normal random variable
</p>
<p style="text-align: center;"><code class="reqn">X|\mu,\sigma \;\sim\; \mathrm{Normal}(\mu,\sigma^2)</code>
</p>

<p>has a fixed mean <code class="reqn">\mu</code>, but a random standard deviation
</p>
<p style="text-align: center;"><code class="reqn">\sigma|\phi \;\sim\; \mathrm{G}(\phi)</code>
</p>

<p>following some probability distribution <code class="reqn">\mathrm{G}(\phi)</code>,
then the <em>marginal distribution</em> of <code class="reqn">X</code>,
</p>
<p style="text-align: center;"><code class="reqn">X|\mu,\phi</code>
</p>

<p>is a <em>mixture distribution</em> (Lindsay, 1995; Seidel, 2010).
</p>
<p>The mixture distribution's probability density function etc. result
from integration and often are not available in analytical form.
The <code>normalmixture()</code> function approximates density,
distribution function and quantile function to some pre-set accuracy
by a <em>discrete</em> mixture of normal distributions based on a finite
number of <code class="reqn">\sigma</code> values using the &lsquo;DIRECT&rsquo; algorithm
(Roever and Friede, 2017).
</p>
<p>Either the &ldquo;<code>density</code>&rdquo; or &ldquo;<code>cdf</code>&rdquo; argument
needs to be supplied. If only &ldquo;<code>density</code>&rdquo; is given, then
the CDF is derived via integration, if only &ldquo;<code>cdf</code>&rdquo; is
supplied, then the density function is not necessary.
</p>
<p>In <b>meta-analysis</b> applications, mixture distributions arise
e.g. in the
context of <b>prior predictive distributions</b>. Assuming
that a study-specific effect <code class="reqn">\theta_i</code> <em>a
priori</em> is distributed as
</p>
<p style="text-align: center;"><code class="reqn">\theta_i|\mu,\tau \;\sim\; \mathrm{Normal}(\mu,\tau^2)</code>
</p>

<p>with a prior distribution for the heterogeneity <code class="reqn">\tau</code>,
</p>
<p style="text-align: center;"><code class="reqn">\tau|\phi \;\sim\; \mathrm{G}(\phi)</code>
</p>

<p>yields a setup completely analogous to the above one.
</p>
<p>Since it is sometimes hard to judge what constitutes a sensible
heterogeneity prior, it is often useful to inspect the implications of
certain settings in terms of the corresponding <em>prior predictive
distribution</em> of
</p>
<p style="text-align: center;"><code class="reqn">\theta_i|\mu,\phi</code>
</p>

<p>indicating the <em>a priori</em> implied variation between studies due
to heterogeneity alone based on a certain prior setup (Spiegelhalter
et al., 2004, Sec. 5.7.3). Some examples using different heterogeneity
priors are illustrated below.
</p>


<h3>Value</h3>

<p>A <code>list</code> containing the following elements:
</p>
<table>
<tr><td><code>delta</code>, <code>epsilon</code></td>
<td>
<p>The supplied design parameters.</p>
</td></tr>
<tr><td><code>mu</code></td>
<td>
<p>the normal mean.</p>
</td></tr>
<tr><td><code>bins</code></td>
<td>
<p>the number of bins used.</p>
</td></tr>
<tr><td><code>support</code></td>
<td>
<p>the matrix containing lower, upper and reference points
for each bin and its associated probability.</p>
</td></tr>
<tr><td><code>density</code></td>
<td>
<p>the mixture's density <code>function(x)</code>.</p>
</td></tr>
<tr><td><code>cdf</code></td>
<td>
<p>the mixture's cumulative distribution <code>function(x)</code> (CDF).</p>
</td></tr>
<tr><td><code>quantile</code></td>
<td>
<p>the mixture's quantile <code>function(p)</code> (inverse CDF).</p>
</td></tr>
<tr><td><code>mixing.density</code></td>
<td>
<p>the mixing distribution's density
<code>function()</code> (if supplied).</p>
</td></tr>
<tr><td><code>mixing.cdf</code></td>
<td>
<p>the mixing distribution's cumulative distribution
<code>function()</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Roever <a href="mailto:christian.roever@med.uni-goettingen.de">christian.roever@med.uni-goettingen.de</a>
</p>


<h3>References</h3>

<p>B.G. Lindsay.
<em>Mixture models: theory, geometry and applications</em>.
Vol. 5 of <em>CBMS Regional Conference Series in Probability and
Statistics</em>, 
Institute of Mathematical Statistics, Hayward, CA, USA, 1995.
</p>
<p>C. Roever, T. Friede.
Discrete approximation of a mixture distribution via restricted divergence.
<em>Journal of Computational and Graphical Statistics</em>,
<b>26</b>(1):217-222, 2017.
<a href="https://doi.org/10.1080/10618600.2016.1276840">doi:10.1080/10618600.2016.1276840</a>.
</p>
<p>C. Roever.
Bayesian random-effects meta-analysis using the bayesmeta R package.
<em>Journal of Statistical Software</em>, <b>93</b>(6):1-51, 2020.
<a href="https://doi.org/10.18637/jss.v093.i06">doi:10.18637/jss.v093.i06</a>.
</p>
<p>C. Roever, R. Bender, S. Dias, C.H. Schmid, H. Schmidli, S. Sturtz,
S. Weber, T. Friede.
On weakly informative prior distributions for the heterogeneity
parameter in Bayesian random-effects meta-analysis.
<em>Research Synthesis Methods</em>, <b>12</b>(4):448-474, 2021.
<a href="https://doi.org/10.1002/jrsm.1475">doi:10.1002/jrsm.1475</a>.
</p>
<p>W.E. Seidel. Mixture models.
In: M. Lovric (ed.),
<em>International Encyclopedia of Statistical Science</em>,
Springer, Heidelberg, pp. 827-829, 2010.
</p>
<p>D.J. Spiegelhalter, K.R. Abrams, J.P.Myles.
<em>Bayesian approaches to clinical trials and health-care
evaluation</em>. 
Wiley &amp; Sons, 2004.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesmeta">bayesmeta</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>##################################################################
# compare half-normal mixing distributions with different scales:
nm05 &lt;- normalmixture(cdf=function(x){phalfnormal(x, scale=0.5)})
nm10 &lt;- normalmixture(cdf=function(x){phalfnormal(x, scale=1.0)})
# (this corresponds to the case of assuming a half-normal prior
# for the heterogeneity tau)

# check the structure of the returned object:
str(nm05)

# show density functions:
# (these would be the marginal (prior predictive) distributions
# of study-specific effects theta[i])
x &lt;- seq(-1, 3, by=0.01)
plot(x, nm05$density(x), type="l", col="blue", ylab="density")
lines(x, nm10$density(x), col="red")
abline(h=0, v=0, col="grey")

# show cumulative distributions:
plot(x, nm05$cdf(x), type="l", col="blue", ylab="CDF")
lines(x, nm10$cdf(x), col="red")
abline(h=0:1, v=0, col="grey")

# determine 5 percent and 95 percent quantiles:
rbind("HN(0.5)"=nm05$quantile(c(0.05,0.95)),
      "HN(1.0)"=nm10$quantile(c(0.05,0.95)))


##################################################################
# compare different mixing distributions
# (half-normal, half-Cauchy, exponential and Lomax):
nmHN &lt;- normalmixture(cdf=function(x){phalfnormal(x, scale=0.5)})
nmHC &lt;- normalmixture(cdf=function(x){phalfcauchy(x, scale=0.5)})
nmE  &lt;- normalmixture(cdf=function(x){pexp(x, rate=2)})
nmL  &lt;- normalmixture(cdf=function(x){plomax(x, shape=4, scale=2)})

# show densities (logarithmic y-axis):
x &lt;- seq(-1, 3, by=0.01)
plot(x,  nmHN$density(x), col="green",  type="l", ylab="density", ylim=c(0.005, 6.5), log="y")
lines(x, nmHC$density(x), col="red")
lines(x, nmE$density(x),  col="blue")
lines(x, nmL$density(x),  col="cyan")
abline(v=0, col="grey")

# show CDFs:
plot(x,  nmHN$cdf(x), col="green",  type="l", ylab="CDF", ylim=c(0,1))
lines(x, nmHC$cdf(x), col="red")
lines(x, nmE$cdf(x),  col="blue")
lines(x, nmL$cdf(x),  col="cyan")
abline(h=0:1, v=0, col="grey")
# add "exponential" x-axis at top:
axis(3, at=log(c(0.5,1,2,5,10,20)), lab=c(0.5,1,2,5,10,20))
# show 95 percent quantiles:
abline(h=0.95, col="grey", lty="dashed")
abline(v=nmHN$quantile(0.95), col="green", lty="dashed")
abline(v=nmHC$quantile(0.95), col="red", lty="dashed")
abline(v=nmE$quantile(0.95),  col="blue", lty="dashed")
abline(v=nmL$quantile(0.95),  col="cyan", lty="dashed")
rbind("half-normal(0.5)"=nmHN$quantile(0.95),
      "half-Cauchy(0.5)"=nmHC$quantile(0.95),
      "exponential(2.0)"=nmE$quantile(0.95),
      "Lomax(4,2)"      =nmL$quantile(0.95))


#####################################################################
# a normal mixture distribution example where the solution
# is actually known analytically: the Student-t distribution.
# If  Y|sigma ~ N(0,sigma^2),  where  sigma = sqrt(k/X)
# and  X|k ~ Chi^2(df=k),
# then the marginal  Y|k  is Student-t with k degrees of freedom.

# define CDF of sigma:
CDF &lt;- function(sigma, df){pchisq(df/sigma^2, df=df, lower.tail=FALSE)}

# numerically approximate normal mixture (with k=5 d.f.):
k &lt;- 5
nmT1 &lt;- normalmixture(cdf=function(x){CDF(x, df=k)})
# in addition also try a more accurate approximation:
nmT2 &lt;- normalmixture(cdf=function(x){CDF(x, df=k)}, delta=0.001, epsilon=0.00001)
# check: how many grid points were required?
nmT1$bins
nmT2$bins

# show true and approximate densities:
x &lt;- seq(-2,10,le=400)
plot(x, dt(x, df=k), type="l")
abline(h=0, v=0, col="grey")
lines(x, nmT1$density(x), col="red", lty="dashed")
lines(x, nmT2$density(x), col="blue", lty="dotted")

# show ratios of true and approximate densities:
plot(x, nmT1$density(x)/dt(x, df=k), col="red",
     type="l", log="y", ylab="density ratio")
abline(h=1, v=0, col="grey")
lines(x, nmT2$density(x)/dt(x, df=k), col="blue")
</code></pre>

<hr>
<h2 id='Peto1980'>Aspirin after myocardial infarction example data</h2><span id='topic+Peto1980'></span>

<h3>Description</h3>

<p>Numbers of cases (patients) and events (deaths) in
treatment and control groups of six studies.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Peto1980")</code></pre>


<h3>Format</h3>

<p>The data frame contains the following columns:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <b>publication</b>    </td><td style="text-align: left;"> <code>character</code> </td><td style="text-align: left;"> publication reference </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>study</b>          </td><td style="text-align: left;"> <code>character</code> </td><td style="text-align: left;"> study acronym or abbreviation </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>start</b>, <b>end</b> </td><td style="text-align: left;"> <code>integer</code>   </td><td style="text-align: left;"> duration of study (calendar years) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>age</b>            </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> mean patient age (years) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>dose</b>           </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> total daily dose (mg) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>followup</b>       </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> follow-up duration (months) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>treat.cases</b>    </td><td style="text-align: left;"> <code>integer</code>   </td><td style="text-align: left;"> number of cases in treatment group </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>treat.events</b>   </td><td style="text-align: left;"> <code>integer</code>   </td><td style="text-align: left;"> number of events in treatment group </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>control.cases</b>  </td><td style="text-align: left;"> <code>integer</code>   </td><td style="text-align: left;"> number of cases in control group </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>control.events</b> </td><td style="text-align: left;"> <code>integer</code>   </td><td style="text-align: left;"> number of events in control group </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Details</h3>

<p>Peto (1980) investigated mortality data from six randomized,
placebo-controlled clinical trials of aspirin, involving a total of
10,703 post-myocardial infarction patients. Canner (1987) later investigated
potential heterogeneity between study characteristics as well as their
reported estimates. The included studies' abbreviations are:
</p>

<table>
<tr>
 <td style="text-align: left;">
    UK-1   </td><td style="text-align: left;">  first United Kingdom trial </td>
</tr>
<tr>
 <td style="text-align: left;">
    CDPA   </td><td style="text-align: left;">  Coronary Drug Project Aspirin trial </td>
</tr>
<tr>
 <td style="text-align: left;">
    GAMS   </td><td style="text-align: left;">  German-Austrian Multicentre Study</td>
</tr>
<tr>
 <td style="text-align: left;">
    UK-2   </td><td style="text-align: left;">  second United Kingdom trial </td>
</tr>
<tr>
 <td style="text-align: left;">
    PARIS  </td><td style="text-align: left;">  Persantine-Aspirin Reinfarction Study </td>
</tr>
<tr>
 <td style="text-align: left;">
    AMIS   </td><td style="text-align: left;">  Aspirin Myocardial Infarction Study
  </td>
</tr>

</table>



<h3>Source</h3>

<p>P.L. Canner. An overview of six clinical trials of aspirin
in coronary heart disease.
<em>Statistics in Medicine</em>, <b>6</b>(3):255-263, 1987.
<a href="https://doi.org/10.1002/sim.4780060310">doi:10.1002/sim.4780060310</a>
</p>


<h3>References</h3>

<p>R. Peto.
Aspirin after myocardial infarction. 
<em>The Lancet</em>, <b>315</b>(8179):1172-1173, 1980.
<a href="https://doi.org/10.1016/S0140-6736%2880%2991626-8">doi:10.1016/S0140-6736(80)91626-8</a>.
</p>
<p>P.C. Elwood, A.L. Cochrane, M.L.Burr, P.M. Sweetnam, G. Williams,
E. Welsby, S.J. Hughes, R. Renton.
A randomized controlled trial of acetyl salicylic acid in the
secondary prevention of mortality from myocardial infarction. 
<em>British Medical Journal</em>, <b>1</b>(5905):436-440, 1974.
<a href="https://doi.org/10.1136/bmj.1.5905.436">doi:10.1136/bmj.1.5905.436</a>.
</p>
<p>The Coronary Drug Project Research Group.
Aspirin in coronary heart disease.
<em>Journal of Chronic Diseases</em>, <b>29</b>(10):625-642, 1976.
<a href="https://doi.org/10.1016/0021-9681%2876%2990020-5">doi:10.1016/0021-9681(76)90020-5</a>.
</p>
<p>K. Breddin, D. Loew, K. Lechner, K. Ueberla, E. Walter.
Secondary prevention of myocardial infarction: a comparison of
acetylsalicylic acid, placebo and phenprocoumon.
<em>Haemostasis</em>, <b>9</b>(6):325-344, 1980.
<a href="https://doi.org/10.1159/000214375">doi:10.1159/000214375</a>.
</p>
<p>P.C. Elwood, P.M. Sweetnam.
Aspirin and secondary mortality after myocardial infarction.
<em>The Lancet</em>, <b>314</b>(8156):1313-1315, 1979.
<a href="https://doi.org/10.1016/S0140-6736%2879%2992808-3">doi:10.1016/S0140-6736(79)92808-3</a>.
</p>
<p>Aspirin Myocardial Infarction Study Research Group.
A randomized, controlled trial of aspirin in persons recovered from
myocardial infarction.
<em>Journal of the American Medical Association</em>,
<b>243</b>(7):661-669, 1980.
<a href="https://doi.org/10.1001/jama.1980.03300330019023">doi:10.1001/jama.1980.03300330019023</a>.
</p>
<p>The Persantine-Aspirin Reinfarction Study Research Group.
Persantine and aspirin in coronary heart disease.
<em>Circulation</em>, <b>62</b>(3):449-461, 1980.
<a href="https://doi.org/10.1161/01.CIR.62.3.449">doi:10.1161/01.CIR.62.3.449</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Peto1980")
## Not run: 
# compute effect sizes (log odds ratios) from count data
# (using "metafor" package's "escalc()" function):
require("metafor")
peto.es &lt;- escalc(measure="OR",
                  ai=treat.events,   n1i=treat.cases,
                  ci=control.events, n2i=control.cases,
                  slab=publication, data=Peto1980)
print(peto.es)

# check sensitivity to different prior choices:
peto.ma01 &lt;- bayesmeta(peto.es)
peto.ma02 &lt;- bayesmeta(peto.es, tau.prior=function(t){dhalfnormal(t, scale=1)})
 
par(mfrow=c(2,1))
  plot(peto.ma01, which=4, prior=TRUE, taulim=c(0,1), main="uniform prior")
  plot(peto.ma02, which=4, prior=TRUE, taulim=c(0,1), main="half-normal prior")
par(mfrow=c(1,1))

# compare heterogeneity (tau) estimates:
print(rbind("uniform"    =peto.ma01$summary[,"tau"],
            "half-normal"=peto.ma02$summary[,"tau"]))

# compare effect (mu) estimates:
print(rbind("uniform"    =peto.ma01$summary[,"mu"],
            "half-normal"=peto.ma02$summary[,"mu"]))

summary(peto.ma02)
forestplot(peto.ma02)
plot(peto.ma02)

## End(Not run)
</code></pre>

<hr>
<h2 id='plot.bayesmeta'>
Generate summary plots for a <code><a href="#topic+bayesmeta">bayesmeta</a></code> object.
</h2><span id='topic+plot.bayesmeta'></span>

<h3>Description</h3>

<p>Generates a forest plot, and joint and marginal posterior density plots
for the two parameters of the random-effects meta-analysis model.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'bayesmeta'
plot(x, main=deparse(substitute(x)),
     which=1:4, prior=FALSE, forest.margin=8,
     mulim=c(NA,NA), taulim=c(NA,NA),
     violin=FALSE, ...) 
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot.bayesmeta_+3A_x">x</code></td>
<td>

<p>a <code><a href="#topic+bayesmeta">bayesmeta</a></code> object.
</p>
</td></tr>
<tr><td><code id="plot.bayesmeta_+3A_main">main</code></td>
<td>

<p>a <code>character</code> string giving the main title for the plot(s).
</p>
</td></tr>
<tr><td><code id="plot.bayesmeta_+3A_which">which</code></td>
<td>

<p>an indicator of which plots to generate.
</p>
</td></tr>
<tr><td><code id="plot.bayesmeta_+3A_prior">prior</code></td>
<td>

<p>an indicator whether to also draw the prior density in marginal
posterior density plots.
</p>
</td></tr>
<tr><td><code id="plot.bayesmeta_+3A_forest.margin">forest.margin</code></td>
<td>

<p>the width of the margin to the left of the forest plot. This may
require some manual tweaking so that the study labels fit properly.
</p>
</td></tr>
<tr><td><code id="plot.bayesmeta_+3A_mulim">mulim</code>, <code id="plot.bayesmeta_+3A_taulim">taulim</code></td>
<td>

<p>(optional) ranges of effect (mu) and heterogeneity (tau) values
to be used for plotting.
</p>
</td></tr>
<tr><td><code id="plot.bayesmeta_+3A_violin">violin</code></td>
<td>

<p>an indicator whether to draw the forest plot as a &ldquo;violin plot&rdquo;.
</p>
</td></tr>
<tr><td><code id="plot.bayesmeta_+3A_...">...</code></td>
<td>
<p>other graphical parameters.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Depending on the value of the <code>which</code> argument, one or several
plots are generated, namely
</p>

<ol>
<li><p> a forest plot, including a 95% credible interval (diamond) and
a 95% prediction interval (rectangle) for the effect <code class="reqn">\mu</code>. The
shown intervals for <code class="reqn">\mu</code> are based on posterior medians and
shortest credible intervals (from <code>x$summary</code>).
If <code>violin=TRUE</code>, the forest plot is plotted as a
&ldquo;violin plot&rdquo;, i.e., via Gaussian densities for the
estimates <code class="reqn">y_i</code> (and their associated uncertainties),
and the posterior densities for the effect <code class="reqn">\mu</code>, and for the
predictive distribution.
</p>
</li>
<li><p> a plot of the joint posterior density of heterogeneity
(<code class="reqn">\tau</code>) and effect (<code class="reqn">\mu</code>). Red lines trace the
contours of constant density corresponding to approximate 2D
credible regions (based on a <code class="reqn">\chi^2</code>-approximation to the
logarithmic posterior density) as labelled. The credible
regions are only an approximation based on a
&lsquo;well-behaved&rsquo;, unimodal posterior; contour lines are
omitted if the posterior mode is not finite. Blue lines show the
conditional mean effect <code class="reqn">\mu</code> as a function of the
heterogeneity <code class="reqn">\tau</code> (solid line) along with conditional
95% confidence bounds (dashed lines). Green lines indicate
marginal medians and shortest 95% credible intervals for
<code class="reqn">\tau</code> and <code class="reqn">\mu</code>. 
</p>
</li>
<li><p> the marginal posterior probability density of the effect
<code class="reqn">\mu</code> with median and shortest 95% credible interval
indicated. Depending on the <code>prior</code> argument, a dashed line
showing the prior density is added. Note that for improper priors
the scaling is arbitrary and may be inappropriate for the plot.
</p>
</li>
<li><p> the marginal posterior probability density of the heterogeneity
<code class="reqn">\tau</code> with median and shortest 95% credible interval
indicated. Depending on the <code>prior</code> argument, a dashed line
showing the prior density is added. Note that for improper priors
the scaling is arbitrary and may be inappropriate for the plot.
</p>
</li></ol>

<p>The joint posterior density plot (2) especially highlights the dependence
of the effect estimate on the heterogeneity parameter. In a
&lsquo;conventional&rsquo; frequentist meta-analysis, one would commonly first
estimate the heterogeneity <code class="reqn">\tau</code>, and then fix this value and
estimate the effect <code class="reqn">\mu</code> based on the assumption that the
heterogeneity estimate was the true value. In the joint density plot,
this would correspond to considering vertical &ldquo;slices&rdquo; of the
parameter space, a slice at <code class="reqn">\tau=0</code> for the fixed-effects model,
and a slice a a different <code class="reqn">\tau</code> value for the random-effects
model, where the blue lines would then indicate the corresponding
estimate and confidence interval for <code class="reqn">\mu</code>.
</p>
<p>Note that when using the <code>prior=TRUE</code> argument, the added line
may end up be outside the plotted range, especially when using
improper priors with arbitrary normalisation (consider adding it
&ldquo;manually&rdquo; instead).
</p>


<h3>Value</h3>

<p>Returns the supplied <code>bayesmeta</code> object (<code>x</code>).
</p>


<h3>Author(s)</h3>

<p>Christian Roever <a href="mailto:christian.roever@med.uni-goettingen.de">christian.roever@med.uni-goettingen.de</a>
</p>


<h3>References</h3>

<p>C. Roever.
Bayesian random-effects meta-analysis using the bayesmeta R package.
<em>Journal of Statistical Software</em>, <b>93</b>(6):1-51, 2020.
<a href="https://doi.org/10.18637/jss.v093.i06">doi:10.18637/jss.v093.i06</a>.
</p>
<p>C. Guddat, U. Grouven, R. Bender and G. Skipka.
A note on the graphical presentation of prediction intervals in
random-effects meta-analyses.
<em>Systematic Reviews</em>, <b>1</b>(34), 2012.
<a href="https://doi.org/10.1186/2046-4053-1-34">doi:10.1186/2046-4053-1-34</a>.
</p>
<p>R.D. Riley, J.P. Higgins and J.J. Deeks.
Interpretation of random effects meta-analyses.
<em>BMJ</em>, <b>342</b>:d549, 2011.
<a href="https://doi.org/10.1136/bmj.d549">doi:10.1136/bmj.d549</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesmeta">bayesmeta</a></code>, <code><a href="#topic+forestplot.bayesmeta">forestplot.bayesmeta</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# example data by Snedecor and Cochran:
data("SnedecorCochran")

# analyze using a weakly informative prior
# (may take a few seconds to compute!):
ma &lt;- bayesmeta(y=SnedecorCochran[,"mean"], sigma=sqrt(SnedecorCochran[,"var"]),
                label=SnedecorCochran[,"no"],
                mu.prior.mean=50, mu.prior.sd=50,
                tau.prior=function(x){dhalfcauchy(x, scale=10)})

# show some plots:
plot(ma, main="Snedecor/Cochran data", prior=TRUE)
plot(ma, main="Snedecor/Cochran data", which=1, violin=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='pppvalue'>Posterior predictive <code class="reqn">p</code>-values</h2><span id='topic+pppvalue'></span>

<h3>Description</h3>

<p>Compute posterior or prior predictive <code class="reqn">p</code>-values from a
<code><a href="#topic+bayesmeta">bayesmeta</a></code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  pppvalue(x, parameter = "mu", value = 0.0,
           alternative = c("two.sided", "less", "greater"),
           statistic = "median",
           rejection.region,
           n = 10,
           prior = FALSE,
           quietly = FALSE,
           parallel, seed, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="pppvalue_+3A_x">x</code></td>
<td>
<p>a <code>bayesmeta</code> object.</p>
</td></tr>
<tr><td><code id="pppvalue_+3A_parameter">parameter</code></td>
<td>
<p>the parameter to be tested. May be the effect
(<code>"mu"</code>), the heterogeneity (<code>"tau"</code>) or one of the
study-specific (<code class="reqn">\theta_i</code>) parameters denoted by
their label or their index.</p>
</td></tr>
<tr><td><code id="pppvalue_+3A_value">value</code></td>
<td>
<p>the (null-) hypothesized value.</p>
</td></tr>
<tr><td><code id="pppvalue_+3A_alternative">alternative</code></td>
<td>
<p>the type of alternative hypothesis.</p>
</td></tr>
<tr><td><code id="pppvalue_+3A_statistic">statistic</code></td>
<td>
<p>the figure to be used a the &lsquo;test
statistic&rsquo;, or &lsquo;discrepancy variable&rsquo;. May be chosen as <code>"t"</code>,
<code>"Q"</code> or <code>"cdf"</code>, or among the row
names of the <code>bayesmeta</code> object's &lsquo;<code>...$summary</code>&rsquo;
element. <em>Or</em> it may be specified as a <code>function</code>. For details, see below.</p>
</td></tr>
<tr><td><code id="pppvalue_+3A_rejection.region">rejection.region</code></td>
<td>
<p>the test statistic's rejection region. May be
one of <code>"upper.tail"</code>, <code>"lower.tail"</code> or
<code>"two.tailed"</code>. If unspecified, it is set automatically based
on the &lsquo;<code>alternative</code>&rsquo; and &lsquo;<code>statistic</code>&rsquo;
parameters.</p>
</td></tr>
<tr><td><code id="pppvalue_+3A_n">n</code></td>
<td>
<p>the number of Monte Carlo replications to be generated. The
default value is <code>n=10</code>, but in practice a substantially larger
value should be appropriate.</p>
</td></tr>
<tr><td><code id="pppvalue_+3A_prior">prior</code></td>
<td>
<p>a logical flag to request <em>prior predictive</em> (instead
of <em>posterior predictive</em>) <code class="reqn">p</code>-values. Prior predictive
values are only available for hypotheses concerning the effect
(<code class="reqn">\mu</code>) and heterogeneity (<code class="reqn">\tau</code>) parameters.</p>
</td></tr>
<tr><td><code id="pppvalue_+3A_quietly">quietly</code></td>
<td>
<p>a logical flag to show (or suppress) output during
computation; this may also speed up computations slightly.</p>
</td></tr>
<tr><td><code id="pppvalue_+3A_parallel">parallel</code></td>
<td>
<p>the number of parallel processes to utilize. By
default, if multiple (k) cores are detected, then k-1 parallel
processes are used.</p>
</td></tr>
<tr><td><code id="pppvalue_+3A_seed">seed</code></td>
<td>
<p>(optional) an <code>integer</code> random seed value to
generate reproducible results.</p>
</td></tr>
<tr><td><code id="pppvalue_+3A_...">...</code></td>
<td>
<p>further parameters passed to &lsquo;<code>statistic</code>&rsquo;,
<em>if</em> the &lsquo;<code>statistic</code>&rsquo; argument was specified as a
<code>function</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Posterior predictive <code class="reqn">p</code>-values are Bayesian analogues to
&lsquo;classical&rsquo; <code class="reqn">p</code>-values (Meng, 1994; Gelman, Meng and Stern,
1996; Gelman et al., 2014). The <code>pppvalue()</code> function allows to
compute these values for one- and two-sided hypotheses concerning the
effect (<code class="reqn">\mu</code>) or heterogeneity (<code class="reqn">\tau</code>) parameter, or one of
the study-specific effect parameters (<code class="reqn">\theta_i</code>) in a
random-effects meta-analysis.
</p>
<p><em>Prior</em> predictive <code class="reqn">p</code>-values have a
similar interpretation, but they have a stronger dependence on the
prior specification and are only available when the prior is proper;
for a more detailed discussion, see Gelman, Meng and Stern (1996,
Sec. 4).
</p>
<p>The function may also be used to only generate samples (<code class="reqn">\tau</code>,
<code class="reqn">\mu</code>, <code class="reqn">\theta_i</code>, <code class="reqn">y_i</code>) without having to also
derive a statistic or a <code class="reqn">p</code>-value. In order to achieve that, the
&lsquo;<code>statistic</code>&rsquo; argument may be specified as
&lsquo;<code>NA</code>&rsquo;, and generated samples may be recovered from the
&lsquo;<code>...$replicates</code>&rsquo; output element.
</p>


<h4><code class="reqn">p</code>-values from Monte Carlo sampling</h4>

<p>The computation
is based on Monte Carlo sampling and repeated analysis of re-generated
data sets drawn from the parameters' (conditional) posterior
predictive (or prior) distribution; so the <code class="reqn">p</code>-value derivation is
somewhat computationally expensive. The <code class="reqn">p</code>-value eventually is
computed based on how far in the tail area the actual data are (in
terms of the realized &lsquo;test statistic&rsquo; or &lsquo;discrepancy&rsquo;)
relative to the Monte-Carlo-sampled distribution. Accuracy of the
computed <code class="reqn">p</code>-value hence strongly depends on the number of samples
(as specified through the &lsquo;<code>n</code>&rsquo; argument) that are
generated. Also, (near-) zero <code class="reqn">p</code>-values need to be interpreted
with caution, and in relation to the used Monte Carlo sample size
(<code>n</code>).</p>



<h4>&lsquo;Test&rsquo;-statistics or &lsquo;discrepancy
variables&rsquo;</h4>

<p>The &lsquo;<code>statistic</code>&rsquo; argument determines the statistic
to be computed from the data as a measure of deviation from the null
hypothesis. If specified as <code>"Q"</code>, then Cochran's <code class="reqn">Q</code> statistic is
computed; this is useful for testing for homogeneity (<code class="reqn">\tau=0</code>). If specified as
one of the row names of the &lsquo;<code>x$summary</code>&rsquo; element, then,
depending on the type of null hypothesis specified through the
&lsquo;<code>parameter</code>&rsquo; argument, the corresponding parameter's posterior
quantity is used for the statistic. If specified as <code>"t"</code>, then a
<code class="reqn">t</code>-type statistic is computed (the difference between the
corresponding parameter's posterior mean and its hypothesized value,
divided by the posterior standard deviation). If specified as
<code>"cdf"</code>, the parameter's marginal posterior cumulative
distribution function evaluated a the hypothesized value
(&lsquo;<code>value</code>&rsquo;) is used.
</p>
<p>The &lsquo;<code>statistic</code>&rsquo; argument may also be specified as an
arbitrary <code>function</code> of the data (<code class="reqn">y</code>). The <code>function</code>'s
first argument then needs to be the data (<code class="reqn">y</code>), additional
arguments may be passed as arguments (&lsquo;<code>...</code>&rsquo;) to the
&lsquo;<code>pppvalue()</code>&rsquo; function. See also the examples below.</p>



<h4>One- and two-sided hypotheses</h4>

<p>Specification of one- or
two-sided hypotheses not only has implications for the determination
of the <code class="reqn">p</code>-value from the samples, but also for the sampling
process itself. Parameter values are drawn from a subspace according
to the null hypothesis, which for a two-sided test is a line, and for
a one-sided test is a half-plane. This also implies that one- and
two-sided <code class="reqn">p</code>-values cannot simply be converted into one
another.
</p>
<p>For example, when specifying
<code>pppvalue(..., param="mu", val=0, alt="two.sided")</code>,
then first paramater values (<code class="reqn">\tau</code>, <code class="reqn">\mu</code>) are drawn from the
conditional posterior distribution <code class="reqn">p(\tau, \mu | y, \sigma,
  \mu=0)</code>, and subsequently new data sets
are generated based on the parameters. If a one-sided hypothesis is
specified, e.g. via
<code>pppvalue(..., param="mu", val=0, alt="less")</code>,
then parameters are drawn from <code class="reqn">p(\tau, \mu | y,
  \sigma, \mu&gt;0)</code>.
</p>
<p>For a hypothesis concerning the individual effect parameters
<code class="reqn">\theta_i</code>, conditions are imposed on the corresponding
<code class="reqn">\theta_i</code>. For example, for a specification of
<code>pppvalue(..., param=2, val=0, alt="less")</code>, the
hypothesis concerns the <code class="reqn">i</code>=2nd study's effect paramater
<code class="reqn">\theta_2</code>. First a sample is generated from
<code class="reqn">p(\theta_2|y, \sigma, \theta_2 &gt; 0)</code>. Then samples of <code class="reqn">\mu</code> and <code class="reqn">\tau</code> are generated
by conditioning on the generated <code class="reqn">\theta_2</code> value, and
data <code class="reqn">y</code> are generated by conditioning on all three.
</p>
<p>Unless explicitly specified through the
&lsquo;<code>rejection.region</code>&rsquo; argument, the test statistic's
&ldquo;rejection region&rdquo; (the direction in which extreme <code>statistic</code>
values indicate a departure from the null hypothesis) is set based on the
&lsquo;<code>alternative</code>&rsquo; and &lsquo;<code>statistic</code>&rsquo;
parameters. The eventually used setting can be checked in the output's
&lsquo;<code>...$rejection.region</code>&rsquo; component.</p>



<h4>Computation</h4>

<p>When aiming to compute a <code class="reqn">p</code>-value, it is
probably a good idea to first start with a smaller &lsquo;<code>n</code>&rsquo;
argument to get a rough idea of the <code class="reqn">p</code>-value's order of magnitude
as well as the computational speed, before going over to a larger,
more realistic <code>n</code> value. The implementation is able to utilize
multiple processors or cores via the <span class="pkg">parallel</span> package; details
may be specified via the &lsquo;<code>parallel</code>&rsquo; argument.</p>



<h3>Value</h3>

<p>A <code>list</code> of class &lsquo;<code>htest</code>&rsquo; containing the following
components:
</p>
<table>
<tr><td><code>statistic</code></td>
<td>
<p>the &lsquo;test statistic&rsquo; (or &lsquo;discrepancy&rsquo;)
value based on the actual data.</p>
</td></tr>
<tr><td><code>parameter</code></td>
<td>
<p>the number (<code>n</code>) of Monte Carlo replications used.</p>
</td></tr>
<tr><td><code>p.value</code></td>
<td>
<p>the derived <code class="reqn">p</code>-value.</p>
</td></tr>
<tr><td><code>null.value</code></td>
<td>
<p>the (null-) hypothesized parameter value.</p>
</td></tr>
<tr><td><code>alternative</code></td>
<td>
<p>the type of alternative hypothesis.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>a character string indicating what type of test was performed.</p>
</td></tr>
<tr><td><code>data.name</code></td>
<td>
<p>the name of the underlying <code>bayesmeta</code> object.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>an object of class <code>call</code> giving the
function call that generated the <code>htest</code> object.</p>
</td></tr>
<tr><td><code>rejection.region</code></td>
<td>
<p>the test statistic's rejection region.</p>
</td></tr>
<tr><td><code>replicates</code></td>
<td>
<p>a <code>list</code> containing the replicated parameters
(<code class="reqn">\tau</code>, <code class="reqn">\mu</code>, <code class="reqn">\theta_i</code>),
data (<code class="reqn">y_i</code>) and statistic, along with an indicator for those
samples constituting the distribution's &lsquo;tail area&rsquo;.</p>
</td></tr>
<tr><td><code>computation.time</code></td>
<td>
<p>The computation time (in seconds) used.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Roever <a href="mailto:christian.roever@med.uni-goettingen.de">christian.roever@med.uni-goettingen.de</a>
</p>


<h3>References</h3>

<p>X.-L. Meng.
Posterior predictive p-values.
<em>The Annals of Statistics</em>, <b>22</b>(3):1142-1160, 1994.
<a href="https://doi.org/10.1214/aos/1176325622">doi:10.1214/aos/1176325622</a>.
</p>
<p>A. Gelman, X.-L. Meng, H. Stern.
Posterior predictive assessment of model fitness
via realized discrepancies.
<em>Statistica Sinica</em>, <b>6</b>(4):733-760, 1996.
</p>
<p>A. Gelman, J.B. Carlin, H.S. Stern, D.B. Dunson, A. Vehtari,
D.B. Rubin.
<em>Bayesian data analysis</em>.
Chapman &amp; Hall / CRC, Boca Raton, 2014.
</p>
<p>C. Roever.
Bayesian random-effects meta-analysis using the bayesmeta R package.
<em>Journal of Statistical Software</em>, <b>93</b>(6):1-51, 2020.
<a href="https://doi.org/10.18637/jss.v093.i06">doi:10.18637/jss.v093.i06</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesmeta">bayesmeta</a></code>, <code><a href="stats.html#topic+prop.test">prop.test</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# perform a meta analysis;
# load data:
data("CrinsEtAl2014")
# compute effect sizes (log odds ratios) from count data
# (using "metafor" package's "escalc()" function):
require("metafor")
crins.srr &lt;- escalc(measure="OR",
                    ai=exp.SRR.events,  n1i=exp.total,
                    ci=cont.SRR.events, n2i=cont.total,
                    slab=publication, data=CrinsEtAl2014, subset=c(1,4,6))
# analyze:
bma &lt;- bayesmeta(crins.srr, mu.prior.mean=0, mu.prior.sd=4,
                 tau.prior=function(t){dhalfnormal(t, scale=0.5)})

# compute a 2-sided p-value for the effect (mu) parameter
# (note: this may take a while!):
p &lt;- pppvalue(bma, parameter="mu", value=0, n=100)

# show result:
print(p)

# show the test statistic's distribution
# along with its actualized value:
plot(ecdf(p$replicates$statistic[,1]),
     xlim=range(c(p$statistic, p$replicates$statistic[,1])))
abline(v=p$statistic, col="red")

# show the parameter values
# drawn from the (conditional) posterior distribution:
plot(bma, which=2)
abline(h=p$null.value)                                # (the null-hypothesized mu value)
points(p$replicates$tau, p$replicates$mu, col="cyan") # (the samples)

######################################################################
#  Among the 3 studies, only the first (Heffron, 2003) was randomized.
#  One might wonder about this particular study's effect (theta[1])
#  in the light of the additional evidence and compute a one-sided
#  p-value:

p &lt;- pppvalue(bma, parameter="Heffron", value=0, n=100, alternative="less")
print(p)

######################################################################
#  One may also define one's own 'test' statistic to be used.
#  For example, one could utilize the Bayes factor to generate
#  a p-value for the homogeneity (tau=0) hypothesis:

BF &lt;- function(y, sigma)
{
  bm &lt;- bayesmeta(y=y, sigma=sigma,
                  mu.prior.mean=0, mu.prior.sd=4,
                  tau.prior=function(t){dhalfnormal(t, scale=0.5)},
                  interval.type="central")
  # (central intervals are faster to compute;
  #  interval type otherwise is not relevant here)
  return(bm$bayesfactor[1,"tau=0"])
}
# NOTE: the 'bayesmeta()' arguments above should probably match
#       the specifications from the original analysis

p &lt;- pppvalue(bma, parameter="tau", statistic=BF, value=0, n=100,
              alternative="greater", rejection.region="lower.tail",
              sigma=bma$sigma)
print(p)

######################################################################
#  If one is only interested in generating samples (and not in test
#  statistics or p-values), one may specify the 'statistic' argument
#  as 'NA'.
#  Note that different 'parameter', 'value' and 'alternative' settings
#  imply different sampling schemes.

p &lt;- pppvalue(bma, parameter="mu", statistic=NA, value=0,
              alternative="less", n=100)

plot(bma, which=2)
abline(h=p$null.value)
points(p$replicates$tau, p$replicates$mu, col="cyan")

## End(Not run)
</code></pre>

<hr>
<h2 id='RhodesEtAlPrior'>Heterogeneity priors for continuous outcomes (standardized mean
differences) as proposed by Rhodes et al. (2015).</h2><span id='topic+RhodesEtAlPrior'></span><span id='topic+RhodesEtAlParameters'></span>

<h3>Description</h3>

<p>Use the prior specifications proposed in the paper by Rhodes et al.,
based on an analysis of studies using standardized mean differences
(SMD) that were published in the <em>Cochrane Database of Systematic Reviews</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RhodesEtAlPrior(outcome=c(NA, "obstetric outcome",
  "resource use and hospital stay / process",
  "internal and external structure-related outcome",
  "general physical health and adverse event and pain and quality of life / functioning",
  paste("signs / symptoms reflecting continuation / end of condition and infection",
        "/ onset of new acute / chronic disease"),
  "mental health outcome", "biological marker", "various subjectively measured outcomes"),
  comparator1=c("pharmacological", "non-pharmacological", "placebo / control"),
  comparator2=c("pharmacological", "non-pharmacological", "placebo / control"),
  area=c("other", "respiratory", "cancer"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="RhodesEtAlPrior_+3A_outcome">outcome</code></td>
<td>
<p>The type of outcome investigated (see below for a list
of possible values). The default (<code>NA</code>) is the general
(marginal) setting, without considering meta-analysis
characteristics as covariates.</p>
</td></tr>
<tr><td><code id="RhodesEtAlPrior_+3A_comparator1">comparator1</code></td>
<td>
<p>One comparator's type.</p>
</td></tr>
<tr><td><code id="RhodesEtAlPrior_+3A_comparator2">comparator2</code></td>
<td>
<p>The other comparator's type.</p>
</td></tr>
<tr><td><code id="RhodesEtAlPrior_+3A_area">area</code></td>
<td>
<p>The medical area.</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>Rhodes et al. conducted an analysis of studies listed in the
<em>Cochrane Database of Systematic Reviews</em> that were investigating
standardized mean differences (SMD) as endpoints. As a result, they
proposed empirically motivated log-Student-<code class="reqn">t</code> prior distributions
for the (squared!) heterogeneity parameter <code class="reqn">\tau^2</code>, depending on
the particular type of outcome investigated and the type of comparison
in question. The underlying <code class="reqn">t</code>-distribution's location and scale
parameters here are internally stored in a 3-dimensional array (named
<code>RhodesEtAlParameters</code>) and are most conveniently accessed using
the <code>RhodesEtAlPrior()</code> function.
</p>
<p>The <code>outcome</code> argument specifies the type of outcome
investigated. It may take one of the following values
(partial matching is supported):
</p>

<ul>
<li> <p><code>NA</code>
</p>
</li>
<li> <p><code>"obstetric outcomes"</code>
</p>
</li>
<li> <p><code>"resource use and hospital stay / process"</code>
</p>
</li>
<li> <p><code>"internal and external structure-related outcome"</code>
</p>
</li>
<li> <p><code>"general physical health and adverse event and pain and quality of life / functioning"</code>
</p>
</li>
<li> <p><code>"signs / symptoms reflecting continuation / end of condition and infection / onset of new acute / chronic disease"</code>
</p>
</li>
<li> <p><code>"mental health outcome"</code>
</p>
</li>
<li> <p><code>"biological marker"</code>
</p>
</li>
<li> <p><code>"various subjectively measured outcomes"</code>.
</p>
</li></ul>

<p>Specifying &ldquo;<code>outcome=NA</code>&rdquo; (the default) yields the
<em>marginal</em> setting, without considering meta-analysis
characteristics as covariates.
</p>
<p>The <code>comparator1</code> and <code>comparator2</code> arguments together
specify the type of comparison in question.  These may take one of the
following values (partial matching is supported):
</p>

<ul>
<li> <p><code>"pharmacological"</code>
</p>
</li>
<li> <p><code>"non-pharmacological"</code>
</p>
</li>
<li> <p><code>"placebo / control"</code>.
</p>
</li></ul>

<p>Any combination is allowed for the <code>comparator1</code> and
<code>comparator2</code> arguments, as long as not both arguments are set to
<code>"placebo / control"</code>.
The <code>area</code> argument specifies the medical context; possible
values are:
</p>

<ul>
<li> <p><code>"respiratory"</code>
</p>
</li>
<li> <p><code>"cancer"</code>
</p>
</li>
<li> <p><code>"other"</code> (the default).
</p>
</li></ul>

<p><b>Note</b> that the location and scale parameters refer to the
logarithmic (<em>squared</em>) heterogeneity parameter <code class="reqn">\tau^2</code>,
which is modelled using a Student-<code class="reqn">t</code> distribution with 5 degrees
of freedom. When you want to use the prior specifications for
<code class="reqn">\tau</code>, the square root, as the parameter (as is necessary when
using the <code>bayesmeta()</code> function), you need to correct for the
square root transformation. Taking the square root is equivalent to
dividing by two on the log-scale, so the square root
will still be log-Student-t distributed, but with halved location and
scale parameters. The relevant transformations are already taken care
of when using the resulting <code>$dprior()</code>, <code>$pprior()</code> and
<code>$qprior()</code> functions; see also the example below.
</p>


<h3>Value</h3>

<p>a list with elements
</p>
<table>
<tr><td><code>parameters</code></td>
<td>
<p>the location and scale parameters (corresponding to the
logarithmic <em>squared</em> heterogeneity parameter <code class="reqn">\tau^2</code> as
well as <code class="reqn">\tau</code>).</p>
</td></tr>
<tr><td><code>outcome.type</code></td>
<td>
<p>the corresponding type of outcome.</p>
</td></tr>
<tr><td><code>comparison.type</code></td>
<td>
<p>the corresponding type of comparison.</p>
</td></tr>
<tr><td><code>medical.area</code></td>
<td>
<p>the medical context.</p>
</td></tr>
<tr><td><code>dprior</code></td>
<td>
<p>a <code>function(tau)</code> returning the prior
density of <code class="reqn">\tau</code>.</p>
</td></tr>
<tr><td><code>pprior</code></td>
<td>
<p>a <code>function(tau)</code> returning the prior cumulative
distribution function (CDF) of <code class="reqn">\tau</code>.</p>
</td></tr>
<tr><td><code>qprior</code></td>
<td>
<p>a <code>function(p)</code> returning the prior quantile
function (inverse CDF) of <code class="reqn">\tau</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Roever <a href="mailto:christian.roever@med.uni-goettingen.de">christian.roever@med.uni-goettingen.de</a>
</p>


<h3>References</h3>

<p>K.M. Rhodes, R.M. Turner, J.P.T. Higgins.
Predictive distributions were developed for the extent of
heterogeneity in meta-analyses of continuous outcome data. 
<em>Journal of Clinical Epidemiology</em>, <b>68</b>(1):52-60, 2015.
<a href="https://doi.org/10.1016/j.jclinepi.2014.08.012">doi:10.1016/j.jclinepi.2014.08.012</a>.
</p>
<p>C. Roever, R. Bender, S. Dias, C.H. Schmid, H. Schmidli, S. Sturtz,
S. Weber, T. Friede.
On weakly informative prior distributions for the heterogeneity
parameter in Bayesian random-effects meta-analysis.
<em>Research Synthesis Methods</em>, <b>12</b>(4):448-474, 2021.
<a href="https://doi.org/10.1002/jrsm.1475">doi:10.1002/jrsm.1475</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+TurnerEtAlPrior">TurnerEtAlPrior</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># determine prior distribution for a specific setting:
RP &lt;- RhodesEtAlPrior("obstetric", "pharma", "placebo")
print(RP$parameters)
str(RP)
# a prior 95 percent interval for tau:
RP$qprior(c(0.025,0.975))

# the general (marginal) setting:
RP &lt;- RhodesEtAlPrior()
print(RP$parameters)
str(RP)
# a prior 95 percent interval for tau:
RP$qprior(c(0.025,0.975))

## Not run: 
# load "metafor" package:
require("metafor")
# load data:
data("dat.normand1999")
# compute effect sizes (standardized mean differences):
es &lt;- escalc(measure="SMD", m1i=m1i, sd1i=sd1i, n1i=n1i,
             m2i=m2i, sd2i=sd2i, n2i=n2i,
             slab=source, data=dat.normand1999)

# derive appropriate prior:
RP &lt;- RhodesEtAlPrior("resource use", "non-pharma", "non-pharma")
# show (central) prior 95 percent interval:
RP$qprior(c(0.025, 0.975))
# show prior 95 percent upper limit:
RP$qprior(0.95)

# perform meta analysis:
bma &lt;- bayesmeta(es, tau.prior=RP$dprior)
# show results:
print(bma)
plot(bma, which=4, prior=TRUE)

## End(Not run)
</code></pre>

<hr>
<h2 id='RobergeEtAl2017'>Aspirin during pregnancy example data</h2><span id='topic+RobergeEtAl2017'></span>

<h3>Description</h3>

<p>Numbers of cases (patients) and events (preeclampsia (PE) or
fetal growth restriction (FGR)) in experimental and control groups of
45 studies.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("RobergeEtAl2017")</code></pre>


<h3>Format</h3>

<p>The data frame contains the following columns:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <b>study</b>           </td><td style="text-align: left;"> <code>character</code> </td><td style="text-align: left;"> publication identifier (first author and publication year) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>year</b>            </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> publication year </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>N</b>               </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of patients </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>onset</b>           </td><td style="text-align: left;"> <code>factor</code>    </td><td style="text-align: left;"> treatment onset (up to 16 weeks' gestation or later) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>dose</b>            </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> dose (mg/day) </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>control</b>         </td><td style="text-align: left;"> <code>factor</code>    </td><td style="text-align: left;"> type of control group </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>asp.PE.events</b>   </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of PE events in aspirin group </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>asp.PE.total</b>    </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of PE cases in aspirin group </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>cont.PE.events</b>  </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of PE events in control group </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>cont.PE.total</b>   </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of PE cases in control group </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>asp.FGR.events</b>  </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of FGR events in aspirin group </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>asp.FGR.total</b>   </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of FGR cases in aspirin group </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>cont.FGR.events</b> </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of FGR events in control group </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>cont.FGR.total</b>  </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of FGR cases in control group </td>
</tr>
<tr>
 <td style="text-align: left;">
  </td>
</tr>

</table>



<h3>Details</h3>

<p>A systematic literature review was performed in order to
summarize the evidence on effects of aspirin administered during
pregnancy. Of particular interest were occurrences of
<em>preeclampsia (PE)</em> and <em>fetal growth restriction (FGR)</em>. A
total of 45 relevant randomized controlled trials (RCTs) were found,
out of which 40 reported on PE, and 35 reported on FGR. Besides event
rates, the mode of administration (treatment onset (early vs. late)
and dose (in mg)) was also recorded for each study.
</p>


<h3>Source</h3>

<p>S. Roberge, K. Nicolaides, S. Demers, J. Hyett, N. Chaillet, E. Bujold.
The role of aspirin dose on the prevention of preeclampsia and fetal
growth restriction: systematic review and meta-analysis.
<em>American Journal of Obstetrics &amp; Gynecology</em>,
<b>216</b>(2):110-120, 2017.
<a href="https://doi.org/10.1016/j.ajog.2016.09.076">doi:10.1016/j.ajog.2016.09.076</a>.
</p>


<h3>References</h3>

<p>C. Roever, T. Friede.
Using the bayesmeta R package for Bayesian random-effects meta-regression.
<em>Computer Methods and Programs in Biomedicine</em>,
<b>299</b>:107303, 2023.
<a href="https://doi.org/10.1016/j.cmpb.2022.107303">doi:10.1016/j.cmpb.2022.107303</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bmr">bmr</a></code>, <code><a href="metafor.html#topic+escalc">escalc</a></code>,
<code><a href="stats.html#topic+model.matrix">model.matrix</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data:
data("RobergeEtAl2017")
str(RobergeEtAl2017)
head(RobergeEtAl2017)

# compute effect sizes (log odds ratios) from count data
# (using the "metafor" package's "escalc()" function);
# preeclampsia (PE):
es.pe  &lt;- escalc(measure="OR",
                 ai=asp.PE.events,  n1i=asp.PE.total,
                 ci=cont.PE.events, n2i=cont.PE.total,
                 slab=study, data=RobergeEtAl2017,
                 subset=complete.cases(RobergeEtAl2017[,7:10]))
# show forest plot:
forestplot(es.pe, title="preeclampsia (PE)")
# show "bubble plot" (bubble sizes are
# inversely proportional to standard errors):
plot(es.pe$dose, es.pe$yi, cex=1/sqrt(es.pe$vi),
     col=c("blue","red")[as.numeric(es.pe$onset)],
     xlab="dose (mg)", ylab="log-OR (PE)", main="Roberge et al. (2017)")
legend("topright", col=c("blue","red"), c("early onset", "late onset"), pch=1)

# fetal growth restriction (FGR):
es.fgr &lt;- escalc(measure="OR",
                 ai=asp.FGR.events,  n1i=asp.FGR.total,
                 ci=cont.FGR.events, n2i=cont.FGR.total,
                 slab=study, data=RobergeEtAl2017,
                 subset=complete.cases(RobergeEtAl2017[,11:14]))
# show forest plot:
forestplot(es.fgr, title="fetal growth restriction (FGR)")
# show "bubble plot":
plot(es.fgr$dose, es.fgr$yi, cex=1/sqrt(es.fgr$vi),
     col=c("blue","red")[as.numeric(es.fgr$onset)],
     xlab="dose (mg)", ylab="log-OR (FGR)", main="Roberge et al. (2017)")
legend("topright", col=c("blue","red"), c("early onset", "late onset"), pch=1)

## Not run: 
# set up regressor matrix (common intercept and slope):
X01 &lt;- model.matrix(~ dose, data=es.pe)
colnames(X01) &lt;- c("intercept", "slope")
print(X01)

# perform regression:
bmr01 &lt;- bmr(es.pe, X=X01)
bmr01$summary

# set up alternative regressor matrix
# (individual intercepts and slopes for two subgroups):
X02 &lt;- model.matrix(~ -1 + onset + onset:dose, data=es.pe)
colnames(X02) &lt;- c("intEarly", "intLate", "slopeEarly", "slopeLate")
print(X02)

# perform regression:
bmr02 &lt;- bmr(es.pe, X=X02)
bmr02$summary

# derive predictions from the model;
# specify corresponding "regressor matrices":
newx.early &lt;- cbind(1, 0, seq(50, 150, by=5), 0)
newx.late  &lt;- cbind(0, 1, 0, seq(50, 150, by=5))
# (note: columns correspond to "beta" parameters)

# compute predicted medians and 95 percent intervals: 
pred.early &lt;- cbind("median"=bmr02$qpred(0.5, x=newx.early),
                    bmr02$pred.interval(x=newx.early))
pred.late &lt;- cbind("median"=bmr02$qpred(0.5, x=newx.late),
                    bmr02$pred.interval(x=newx.late))

# draw "bubble plot": 
plot(es.pe$dose, es.pe$yi, cex=1/sqrt(es.pe$vi),
     col=c("blue","red")[as.numeric(es.pe$onset)],
     xlab="dose (mg)", ylab="log-OR (PE)", main="Roberge et al. (2017)")
legend("topright", col=c("blue","red"), c("early onset", "late onset"), pch=1)
# add predictions to bubble plot:
matlines(newx.early[,3], pred.early, col="blue", lty=c(1,2,2))
matlines(newx.late[,4], pred.late, col="red", lty=c(1,2,2))


## End(Not run)
</code></pre>

<hr>
<h2 id='Rubin1981'>8-schools example data</h2><span id='topic+Rubin1981'></span>

<h3>Description</h3>

<p>SAT coaching experiments in 8 schools.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("Rubin1981")</code></pre>


<h3>Format</h3>

<p>The data frame contains the following columns:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <b>school</b> </td><td style="text-align: left;"> <code>character</code> </td><td style="text-align: left;"> school identifier </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>n</b>      </td><td style="text-align: left;"> <code>integer</code>   </td><td style="text-align: left;"> number of students </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>effect</b> </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> effect estimate </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>stderr</b> </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> associated standard error 
  </td>
</tr>

</table>



<h3>Details</h3>

<p>Quoting from Gelman et al. (1997), Sec. 5.5:
&ldquo;A study was performed for the Educational Testing Service to
analyze the effects of special coaching programs for SAT-V
(Scholastic Aptitude Test-Verbal) in each of eight high schools. The
outcome variable in each study was the score on a special
administration of the SAT-V, a standardized multiple choice test
administered by the Educational Testing Service and used to help
colleges make admissions decisions; the scores can vary between 200
and 800, with mean about 500 and standard deviation about 100. The SAT
examinations are designed to be resistant to short-term efforts
directed specifically toward improving performance on the test;
instead they are designed to reflect knowledge acquired and abilities
developed over many years of education. Nevertheless, each of the
eight schools in this study considered its short-term coaching program
to be very successful at increasing SAT scores. Also, there was no
prior reason to believe that any of the eight programs was more
effective than any other or that some were more similar in effect to
each other than to any other.&rdquo;
</p>


<h3>Source</h3>

<p>A. Gelman, J.B. Carlin, H. Stern, and D.B. Rubin.
<em>Bayesian data analysis</em>. Chapman &amp; Hall / CRC, Boca Raton, 1997.
</p>


<h3>References</h3>

<p>D.B. Rubin.
Estimation in parallel randomized experiments.
<em>Journal of Educational Statistics</em>, <b>6</b>(4):377-401, 1981.
<a href="https://doi.org/10.3102/10769986006004377">doi:10.3102/10769986006004377</a>.
</p>
<p>A. Gelman.
Prior distributions for variance parameters in hierarchical models.
<em>Bayesian Analysis</em>, <b>1</b>(3):515-534, 2006.
<a href="https://doi.org/10.1214/06-BA117A">doi:10.1214/06-BA117A</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+traceplot">traceplot</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("Rubin1981")

## Not run: 
# analysis using a weakly informative half-Cauchy prior:
schools &lt;- bayesmeta(y=Rubin1981[,"effect"], sigma=Rubin1981[,"stderr"],
                     labels=Rubin1981[,"school"],
                     tau.prior=function(x){return(dhalfcauchy(x, scale=25))})

# show summary:
summary(schools)

# show shrinkage effect for 8 individual estimates:
schools$theta
traceplot(schools)

## End(Not run)
</code></pre>

<hr>
<h2 id='SchmidliEtAl2017'>Historical variance example data</h2><span id='topic+SchmidliEtAl2017'></span>

<h3>Description</h3>

<p>Estimates of endpoint variances from six studies.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("SchmidliEtAl2017")</code></pre>


<h3>Format</h3>

<p>The data frame contains the following columns:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <b>study</b> </td><td style="text-align: left;"> <code>character</code> </td><td style="text-align: left;"> study label </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>N</b>     </td><td style="text-align: left;"> <code>integer</code>   </td><td style="text-align: left;"> total sample size </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>stdev</b> </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> standard deviation estimate </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>df</b>    </td><td style="text-align: left;"> <code>integer</code>   </td><td style="text-align: left;"> associated degrees of freedom
  </td>
</tr>

</table>



<h3>Details</h3>

<p>Schmidli <em>et al.</em> (2017) investigated the use of
information on an endpoint's variance from previous (&ldquo;historical&rdquo;)
studies for the design and analysis of a new clinical trial. As an
example application, the problem of designing a trial in <em>wet
age-related macular degeneration (AMD)</em> was considered. Trial
design, and in particular considerations regarding the required sample
size, hinge on the expected amount of variability in the primary
endpoint (here: <em>visual acuity</em>, which is measured on a scale
ranging from 0 to 100 via an eye test chart).
</p>
<p>Historical data from six previous trials are available (Szabo <em>et
al.</em>; 2015), each trial providing an estimate <code class="reqn">\hat{s}_i</code> of
the endpoint's standard deviation along with the associated number of
degrees of freedom <code class="reqn">\nu_i</code>. The standard deviations
may then be modelled on the logarithmic scale, where the estimates and
their associated standard errors are given by 
</p>
<p style="text-align: center;"><code class="reqn">y_i=\log(\hat{s}_i) \quad \mbox{and} \quad 
  \sigma_i=\sqrt{\frac{1}{2\,\nu_i}}</code>
</p>

<p>The <em>unit information standard deviation (UISD)</em> for a logarithmic
standard deviation then is at approximately
<code class="reqn">\frac{1}{\sqrt{2}}</code>. 
</p>


<h3>Source</h3>

<p>H. Schmidli, B. Neuenschwander, T. Friede.
Meta-analytic-predictive use of historical variance data
for the design and analysis of clinical trials.
<em>Computational Statistics and Data Analysis</em>, <b>113</b>:100-110, 2017.
<a href="https://doi.org/10.1016/j.csda.2016.08.007">doi:10.1016/j.csda.2016.08.007</a>.
</p>


<h3>References</h3>

<p>S.M. Szabo, M. Hedegaard, K. Chan, K. Thorlund, R. Christensen,
H. Vorum, J.P. Jansen.
Ranibizumab vs. aflibercept for wet age-related macular degeneration:
network meta-analysis to understand the value of reduced frequency dosing.
<em>Current Medical Research and Opinion</em>, <b>31</b>(11):2031-2042, 2015.
<a href="https://doi.org/10.1185/03007995.2015.1084909">doi:10.1185/03007995.2015.1084909</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+uisd">uisd</a></code>, <code><a href="#topic+ess">ess</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data:
data("SchmidliEtAl2017")

# show data:
SchmidliEtAl2017

## Not run: 
# derive log-SDs and their standard errors:
dat &lt;- cbind(SchmidliEtAl2017,
             logstdev    = log(SchmidliEtAl2017$stdev),
             logstdev.se = sqrt(0.5/SchmidliEtAl2017$df))
dat

# alternatively, use "metafor::escalc()" function:
es &lt;- escalc(measure="SDLN",
             yi=log(stdev), vi=0.5/df, ni=N,
             slab=study, data=SchmidliEtAl2017)
es

# perform meta-analysis of log-stdevs:
bm &lt;- bayesmeta(y=dat$logstdev,
                sigma=dat$logstdev.se,
                label=dat$study,
                tau.prior=function(t){dhalfnormal(t, scale=sqrt(2)/4)})

# or, alternatively:
bm &lt;- bayesmeta(es,
                tau.prior=function(t){dhalfnormal(t, scale=sqrt(2)/4)})

# draw forest plot (see Fig.1):
forestplot(bm, zero=NA,
           xlab="log standard deviation")

# show heterogeneity posterior:
plot(bm, which=4, prior=TRUE)

# posterior of log-stdevs, heterogeneity,
# and predictive distribution:
bm$summary

# prediction (standard deviations):
exp(bm$summary[c(2,5,6),"theta"])
exp(bm$qposterior(theta=c(0.025, 0.25, 0.50, 0.75, 0.975), predict=TRUE))

# compute required sample size (per arm):
power.t.test(n=NULL, delta=8, sd=10.9, power=0.8)
power.t.test(n=NULL, delta=8, sd=14.0, power=0.8)

# check UISD:
uisd(es, indiv=TRUE)
uisd(es)
1 / sqrt(2)

# compute predictive distribution's ESS:
ess(bm, uisd=1/sqrt(2))
# actual total sample size:
sum(dat$N)

# illustrate predictive distribution
# on standard-deviation-scale (Fig.2):
x &lt;- seq(from=5, to=20, length=200)
plot(x, (1/x) * bm$dposterior(theta=log(x), predict=TRUE), type="l",
     xlab=expression("predicted standard deviation "*sigma[k+1]),
     ylab="predictive density")
abline(h=0, col="grey")

## End(Not run)
</code></pre>

<hr>
<h2 id='SidikJonkman2007'>Postoperative complication odds example data</h2><span id='topic+SidikJonkman2007'></span>

<h3>Description</h3>

<p>This data set contains the outcomes from 29 randomized
clinical trials comparing the odds of postoperative complications in
laparoscopic inguinal hernia repair (LIHR) versus conventional open
inguinal hernia repair (OIHR).</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("SidikJonkman2007")</code></pre>


<h3>Format</h3>

<p>The data frame contains the following columns:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <b>id</b>          </td><td style="text-align: left;"> <code>character</code> </td><td style="text-align: left;"> identifier used in 
    original publication by Memon et al. (2003)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>id.sj</b>       </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> identifier used by 
    Sidik and Jonkman (2007)</td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>year</b>        </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> publication year</td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>lihr.events</b> </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of events under LIHR</td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>lihr.cases</b>  </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of cases under LIHR</td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>oihr.events</b> </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of events under OIHR</td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>oihr.cases</b>  </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> number of cases under OIHR
  </td>
</tr>

</table>



<h3>Details</h3>

<p>Analysis may be done based on the logarithmic odds ratios:
</p>
<p>log(<code>lihr.events</code>) - log(<code>lihr.cases</code>-<code>lihr.events</code>) -
log(<code>oihr.events</code>) + log(<code>oihr.cases</code>-<code>oihr.events</code>)
</p>
<p>and corresponding standard errors:
</p>
<p>sqrt(1/<code>lihr.events</code> + 1/(<code>lihr.cases</code>-<code>lihr.events</code>))
+ 1/<code>oihr.events</code> + 1/(<code>oihr.cases</code>-<code>oihr.events</code>))
</p>
<p>(you may also leave these computations to the <span class="pkg">metafor</span> package's
<code><a href="metafor.html#topic+escalc">escalc</a>()</code> function).
</p>
<p>The data set was used to compare different estimators for the
(squared) heterogeneity <code class="reqn">\tau^2</code>. The values yielded for this data
set were (see Tab.1 in Sidik and Jonkman (2007)):
</p>

<table>
<tr>
 <td style="text-align: left;">
    method of moments (MM)    </td><td style="text-align: left;"> 0.429 </td>
</tr>
<tr>
 <td style="text-align: left;">
    variance component (VC)   </td><td style="text-align: left;"> 0.841 </td>
</tr>
<tr>
 <td style="text-align: left;">
    maximum likelihood (ML)   </td><td style="text-align: left;"> 0.562 </td>
</tr>
<tr>
 <td style="text-align: left;">
    restricted ML (REML)      </td><td style="text-align: left;"> 0.598 </td>
</tr>
<tr>
 <td style="text-align: left;">
    empirical Bayes (EB)      </td><td style="text-align: left;"> 0.703 </td>
</tr>
<tr>
 <td style="text-align: left;">
    model error variance (MV) </td><td style="text-align: left;"> 0.818 </td>
</tr>
<tr>
 <td style="text-align: left;">
    variation of MV (MVvc)    </td><td style="text-align: left;"> 0.747 
  </td>
</tr>

</table>



<h3>Source</h3>

<p>M.A. Memon, N.J. Cooper, B. Memon, M.I. Memon, and
K.R. Abrams.
Meta-analysis of randomized clinical trials comparing open and
laparoscopic inguinal hernia repair. 
<em>British Journal of Surgery</em>, <b>90</b>(12):1479-1492, 2003.
<a href="https://doi.org/10.1002/bjs.4301">doi:10.1002/bjs.4301</a>.
</p>


<h3>References</h3>

<p>K. Sidik and J.N. Jonkman.
A comparison of heterogeneity variance estimators in combining results
of studies.
<em>Statistics in Medicine</em>, <b>26</b>(9):1964-1981, 2007.
<a href="https://doi.org/10.1002/sim.2688">doi:10.1002/sim.2688</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("SidikJonkman2007")
# add log-odds-ratios and corresponding standard errors:
sj &lt;- SidikJonkman2007
sj &lt;- cbind(sj, "log.or"=log(sj[,"lihr.events"])-log(sj[,"lihr.cases"]-sj[,"lihr.events"])
                             -log(sj[,"oihr.events"])+log(sj[,"oihr.cases"]-sj[,"oihr.events"]),
            "log.or.se"=sqrt(1/sj[,"lihr.events"] + 1/(sj[,"lihr.cases"]-sj[,"lihr.events"])
                             + 1/sj[,"oihr.events"] + 1/(sj[,"oihr.cases"]-sj[,"oihr.events"])))

## Not run: 
# analysis using weakly informative Cauchy prior
# (may take a few seconds to compute!):
ma &lt;- bayesmeta(y=sj[,"log.or"], sigma=sj[,"log.or.se"], label=sj[,"id.sj"],
                tau.prior=function(t){dhalfcauchy(t,scale=1)})

# show heterogeneity's posterior density:
plot(ma, which=4, main="Sidik/Jonkman example", prior=TRUE)

# show some numbers (mode, median and mean):
abline(v=ma$summary[c("mode","median","mean"),"tau"], col="blue")

# compare with Sidik and Jonkman's estimates:
sj.estimates &lt;- sqrt(c("MM"  = 0.429,   # method of moments estimator
                       "VC"  = 0.841,   # variance component type estimator
                       "ML"  = 0.562,   # maximum likelihood estimator
                       "REML"= 0.598,   # restricted maximum likelihood estimator
                       "EB"  = 0.703,   # empirical Bayes estimator
                       "MV"  = 0.818,   # model error variance estimator
                       "MVvc"= 0.747))  # a variation of the MV estimator
abline(v=sj.estimates, col="red", lty="dashed")

# generate forest plot:
fp &lt;- forestplot(ma, exponentiate=TRUE, plot=FALSE)
# add extra columns for ID and year:
labtext &lt;- fp$labeltext
labtext[1,1] &lt;- "ID 2"
labtext[31:32,1] &lt;- ""
labtext &lt;- cbind(c("ID 1", SidikJonkman2007[,"id"], "mean","prediction"),
                 labtext[,1],
                 c("year", as.character(SidikJonkman2007[,"year"]), "", ""),
                 labtext[,-1])
# plot:
forestplot(ma, labeltext=labtext, exponentiate=TRUE, 
           xlog=TRUE, xlab="odds ratio", xticks=c(0.1,1,10))


## End(Not run)
</code></pre>

<hr>
<h2 id='SnedecorCochran'>Artificial insemination of cows example data</h2><span id='topic+SnedecorCochran'></span>

<h3>Description</h3>

<p>This data set gives means and (squared) standard errors of
percentages of conceptions obtained from samples for six bulls.</p>


<h3>Usage</h3>

<pre><code class='language-R'>data("SnedecorCochran")</code></pre>


<h3>Format</h3>

<p>The data frame contains the following columns:
</p>

<table>
<tr>
 <td style="text-align: left;">
    <b>no</b>   </td><td style="text-align: left;"> <code>character</code> </td><td style="text-align: left;"> identifier </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>n</b>    </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> sample size </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>mean</b> </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> mean </td>
</tr>
<tr>
 <td style="text-align: left;">
    <b>var</b>  </td><td style="text-align: left;"> <code>numeric</code>   </td><td style="text-align: left;"> variance (squared standard error)
  </td>
</tr>

</table>



<h3>Details</h3>

<p>Quoting from Snedecor and Cochran (1967), Sec. 10.18:
&ldquo;In research on artificial insemination of cows, a series of
semen samples from a bull are sent out and tested for their ability
to produce conceptions. The following data from a larger set kindly
supplied by Dr. G. W. Salisbury, show the percentages of conceptions
obtained from the samples for six bulls.&rdquo;
</p>


<h3>Source</h3>

<p>J. Hartung, G. Knapp, and B.K. Sinha. <em>Statistical
meta-analysis with applications</em>. Wiley, Hoboken, NJ, USA, 2008.</p>


<h3>References</h3>

<p>G.W. Snedecor and W.G. Cochran. <em>Statistical Methods</em>. 
Iowa State University Press, Ames, IA, USA, 6th edition, 1967.</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("SnedecorCochran")

## Not run: 
# analyze using uniform prior:
bma1 &lt;- bayesmeta(y=SnedecorCochran[,"mean"],
                  sigma=sqrt(SnedecorCochran[,"var"]),
                  label=SnedecorCochran[,"no"],
                  tau.prior="uniform")

# analyze using Jeffreys prior:
bma2 &lt;- bayesmeta(y=SnedecorCochran[,"mean"],
                  sigma=sqrt(SnedecorCochran[,"var"]),
                  label=SnedecorCochran[,"no"],
                  tau.prior="Jeffreys")

# compare results:
print(bma1)
print(bma2)

forestplot(bma1)
forestplot(bma2)

## End(Not run)
</code></pre>

<hr>
<h2 id='summary.bmr'>
Summarizing a <code><a href="#topic+bmr">bmr</a></code> object).
</h2><span id='topic+summary.bmr'></span><span id='topic+print.summary.bmr'></span>

<h3>Description</h3>

<p>Summarizes a <code>bmr</code> object, and (potentially) computes
means and predictions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  ## S3 method for class 'bmr'
summary(object, X.mean, X.prediction, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="summary.bmr_+3A_object">object</code></td>
<td>

<p>a <code><a href="#topic+bmr">bmr</a></code> object.
</p>
</td></tr>
<tr><td><code id="summary.bmr_+3A_x.mean">X.mean</code></td>
<td>

<p>a regressor matrix (<code class="reqn">X</code>) for effect estimates that are to be
derived. The matrix' row names define the labels passed on to the
results.
</p>
</td></tr>
<tr><td><code id="summary.bmr_+3A_x.prediction">X.prediction</code></td>
<td>

<p>an optional regressor matrix (<code class="reqn">X</code>) for predictions that are to
be derived. The matrix' row names define the labels passed on to the
results.
</p>
</td></tr>
<tr><td><code id="summary.bmr_+3A_...">...</code></td>
<td>

<p>other arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Prints details of the supplied <code>bmr</code> oject.
</p>
<p>Specification of the (optional) &ldquo;<code>X.mean</code>&rdquo; or
&ldquo;<code>X.prediction</code>&rdquo; arguments allows to request computation
of mean estimates or predictions corresponding to the supplied
regressor matrices. Estimates (mode, median, mean, standard deviation,
and 95 percent CI) may be retrieved from the returned object's
&ldquo;<code>mean</code>&rdquo; or &ldquo;<code>prediction</code>&rdquo; elements (see
example below).
</p>


<h3>Value</h3>

<p>A list (of class <code>summary.bmr</code>) containing the following elements:
</p>
<table>
<tr><td><code>bmr</code></td>
<td>
<p>the supplied <code>bmr</code> object.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>an object of class <code>call</code> giving the
function call that generated the <code>summary.bmr</code> object.</p>
</td></tr>
<tr><td><code>X.mean</code>, <code>X.prediction</code></td>
<td>
<p>the &lsquo;<code>X.mean</code>&rsquo; and
&lsquo;<code>X.prediction</code>&rsquo; arguments.</p>
</td></tr>
<tr><td><code>mean</code>, <code>prediction</code></td>
<td>
<p>mean and predictions estimates (mode, median,
mean, sd, and 95 percent credible intervals)</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Roever <a href="mailto:christian.roever@med.uni-goettingen.de">christian.roever@med.uni-goettingen.de</a>
</p>


<h3>References</h3>

<p>C. Roever, T. Friede.
Using the bayesmeta R package for Bayesian random-effects meta-regression.
<em>Computer Methods and Programs in Biomedicine</em>,
<b>299</b>:107303, 2023.
<a href="https://doi.org/10.1016/j.cmpb.2022.107303">doi:10.1016/j.cmpb.2022.107303</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
# perform a meta-analysis using binary ("indicator") covariables;
# load data:
data("CrinsEtAl2014")
# compute effect measures (log-OR):
crins.es &lt;- escalc(measure="OR",
                   ai=exp.AR.events,  n1i=exp.total,
                   ci=cont.AR.events, n2i=cont.total,
                   slab=publication, data=CrinsEtAl2014)

# specify regressor matrix (binary indicator variables):
X &lt;- cbind("basiliximab"=as.numeric(crins.es$IL2RA=="basiliximab"),
           "daclizumab" =as.numeric(crins.es$IL2RA=="daclizumab"))
print(X)

# perform meta-analysis:
bmr01 &lt;- bmr(crins.es, X=X,
             tau.prior=function(t){dhalfnormal(t, scale=0.5)})

# show summary:
summary(bmr01)

# show summary with additional estimates and predictions:
summary(bmr01,
        X.mean = rbind("basiliximab" = c(1,0),
                       "daclizumab"  = c(0,1),
                       "difference"  = c(-1,1)),
        X.pred = rbind("basiliximab" = c(1,0),
                       "daclizumab"  = c(0,1)))

# compute mean estimates
smry &lt;- summary(bmr01,
                X.mean = rbind("basiliximab" = c(1,0),
                               "daclizumab"  = c(0,1),
                               "difference"  = c(-1,1)))
# show mean estimates:
smry$mean

## End(Not run)
</code></pre>

<hr>
<h2 id='traceplot'>
Illustrate conditional means of study-specific estimates as well as
overall mean (or other linear combinations) as a function of
heterogeneity.
</h2><span id='topic+traceplot'></span><span id='topic+traceplot.default'></span><span id='topic+traceplot.bayesmeta'></span><span id='topic+traceplot.bmr'></span>

<h3>Description</h3>

<p>Generates a trace plot of study-specific (shrinkage) estimates as a
function of the heterogeneity (<code class="reqn">\tau</code>), along with conditional
estimates of the overall mean or other linear combinations of
regression parameters.
The heterogeneity's posterior distribution is also shown at the bottom.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  traceplot(x, ...)
  ## S3 method for class 'bayesmeta'
traceplot(x, mulim, taulim, ci=FALSE,
          ylab="effect", prior=FALSE, infinity=FALSE,
          rightmargin=8, col=rainbow(x$k), labcol=col,
          meanlabel="overall mean", meancol="black",
          meanlabcol=meancol, ...)
  ## S3 method for class 'bmr'
traceplot(x, mulim, taulim, ci=FALSE,
          ylab="effect", prior=FALSE, infinity=FALSE,
          rightmargin=8, col=rainbow(x$k), labcol=col,
          X, Xlabels, Xcols="black", Xlabcols=Xcols, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="traceplot_+3A_x">x</code></td>
<td>

<p>a <code><a href="#topic+bayesmeta">bayesmeta</a></code> or <code><a href="#topic+bmr">bmr</a></code>object.
</p>
</td></tr>
<tr><td><code id="traceplot_+3A_mulim">mulim</code>, <code id="traceplot_+3A_taulim">taulim</code></td>
<td>
<p>(optional) ranges for the effect (mu) and
heterogeneity (tau) axes. If only one value is given for
<code>taulim</code>, then this is taken as the upper limit, and the lower
limit is zero.
</p>
</td></tr>
<tr><td><code id="traceplot_+3A_ci">ci</code></td>
<td>

<p>a logical flag indicating whether to also show (conditional)
confidence intervals.
</p>
</td></tr>
<tr><td><code id="traceplot_+3A_ylab">ylab</code></td>
<td>

<p>a label for the effect (mu) axis.
</p>
</td></tr>
<tr><td><code id="traceplot_+3A_prior">prior</code></td>
<td>

<p>a logical flag indicating whether to show the (heterogeneity) prior
density along with its posterior.
</p>
</td></tr>
<tr><td><code id="traceplot_+3A_infinity">infinity</code></td>
<td>

<p>a logical flag indicating whether add an &ldquo;infinity&rdquo; tickmark
to the heterogeneity (tau) axis and show the corresponding limiting
values.
</p>
</td></tr>
<tr><td><code id="traceplot_+3A_rightmargin">rightmargin</code></td>
<td>

<p>an additional margin to be added to the right side of the plot, in
order to accomodate the estimates' labels. In case study labels
still extend beyond the figure margin, try increasing this number.
</p>
</td></tr>
<tr><td><code id="traceplot_+3A_col">col</code></td>
<td>

<p>colors to be used for plotting the (<code class="reqn">k</code>) estimates.
</p>
</td></tr>
<tr><td><code id="traceplot_+3A_labcol">labcol</code></td>
<td>

<p>colors to be used for labelling the (<code class="reqn">k</code>) estimates.
</p>
</td></tr>
<tr><td><code id="traceplot_+3A_meanlabel">meanlabel</code></td>
<td>

<p>a label for the overall mean estimate
(<code>traceplot.bayesmeta()</code>).
</p>
</td></tr>
<tr><td><code id="traceplot_+3A_meancol">meancol</code></td>
<td>

<p>colour specification for the overall mean estimate
(<code>traceplot.bayesmeta()</code>).
</p>
</td></tr>
<tr><td><code id="traceplot_+3A_meanlabcol">meanlabcol</code></td>
<td>

<p>colour specification for the overall mean label
(<code>traceplot.bayesmeta()</code>).
</p>
</td></tr>
<tr><td><code id="traceplot_+3A_x">X</code></td>
<td>

<p>matrix (or vector) of coefficients defining linear combinations of
regression parameters to be shown (<code>traceplot.bmr()</code>).
</p>
</td></tr>
<tr><td><code id="traceplot_+3A_xlabels">Xlabels</code></td>
<td>

<p>labels for the linear combinations (<code>traceplot.bmr()</code>).
</p>
</td></tr>
<tr><td><code id="traceplot_+3A_xcols">Xcols</code></td>
<td>

<p>colour specification for the linear combinations
(<code>traceplot.bmr()</code>).
</p>
</td></tr>
<tr><td><code id="traceplot_+3A_xlabcols">Xlabcols</code></td>
<td>

<p>colour specification for the linear combination labels
(<code>traceplot.bmr()</code>).
</p>
</td></tr>
<tr><td><code id="traceplot_+3A_...">...</code></td>
<td>

<p>other arguments passed on to the
<code><a href="graphics.html#topic+plot">plot</a>()</code> function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a given heterogeneity (<code class="reqn">\tau</code>) value, the <em>conditional</em>
posterior distributions of the overall effect (<code class="reqn">\mu</code>) as well as
the study-specific parameters (<code class="reqn">\theta_i</code>) are again
normal. The conditional normal moments (mean and variance) then vary
as functions of the heterogeneity; for large heterogeneity, the
shrinkage estimates approach the original data (<code class="reqn">y_i</code>),
while the overall mean approaches an un-weighted overall average. For
small heterogeneity, both overall mean as well as study-specific
estimates are increasingly <em>shrunk</em> towards the
inverse-variance-weighted &lsquo;common-effect&rsquo; estimate (Roever,
2020).
</p>
<p>This trace plot illustrates the conditional (overall and
study-specific) estimates along with the heterogeneity's posterior
distribution (density) in a layout similar to that utilized
by Rubin (1981).
</p>


<h3>Author(s)</h3>

<p>Christian Roever <a href="mailto:christian.roever@med.uni-goettingen.de">christian.roever@med.uni-goettingen.de</a>
</p>


<h3>References</h3>

<p>C. Roever, D. Rindskopf, T. Friede.
How trace plots help interpret meta-analysis results.
<em>(submitted for publication)</em>, 2023.
<a href="https://arxiv.org/abs/2306.17043">https://arxiv.org/abs/2306.17043</a>.
</p>
<p>C. Roever.
Bayesian random-effects meta-analysis using the bayesmeta R package.
<em>Journal of Statistical Software</em>, <b>93</b>(6):1-51, 2020.
<a href="https://doi.org/10.18637/jss.v093.i06">doi:10.18637/jss.v093.i06</a>.
</p>
<p>C. Roever, T. Friede.
Using the bayesmeta R package for Bayesian random-effects meta-regression.
<em>Computer Methods and Programs in Biomedicine</em>,
<b>299</b>:107303, 2023.
<a href="https://doi.org/10.1016/j.cmpb.2022.107303">doi:10.1016/j.cmpb.2022.107303</a>.
</p>
<p>D.B. Rubin.
Estimation in parallel randomized experiments.
<em>Journal of Educational Statistics</em>, <b>6</b>(4):377-401, 1981.
<a href="https://doi.org/10.3102/10769986006004377">doi:10.3102/10769986006004377</a>.
</p>
<p>DuMouchel, W. H. (1994).
Hierarchical Bayes linear models for meta-analysis.
Technical Report 27, National Institute of Statistical Sciences (NISS);
Research Triangle Park, NC, USA.
<a href="https://www.niss.org/research/technical-reports/hierarchical-bayes-linear-models-meta-analysis-1994">https://www.niss.org/research/technical-reports/hierarchical-bayes-linear-models-meta-analysis-1994</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesmeta">bayesmeta</a></code>, <code><a href="#topic+bmr">bmr</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
########################
# SAT coaching example;
# load example data:
data("Rubin1981")

# perform meta-analysis:
bma01 &lt;- bayesmeta(y=Rubin1981[,"effect"], sigma=Rubin1981[,"stderr"],
                  labels=Rubin1981[,"school"], tau.prior="uniform")

# show meta-analysis results:
forestplot(bma01)

# show trace plot:
traceplot(bma01)


##################################
# COPD (meta-regression) example;
# load example data,
# compute effect sizes (log-ORs):
data("KarnerEtAl2014")
karner.exa &lt;- escalc(measure="OR",
                     ai=tiotropium.exa, n1i=tiotropium.total,
                     ci=placebo.exa,    n2i=placebo.total,
                     slab=study, data=KarnerEtAl2014)


#################################
# perform "plain" meta-analysis:
bma02 &lt;- bayesmeta(karner.exa,
                   tau.prior=function(t){dhalfnormal(t, scale=0.5)})

traceplot(bma02, ylab="log-OR",
          prior=TRUE, infi=TRUE, taulim=0.53)

forestplot(bma02)


############################
# perform meta-regressions:

# 1st regression;
# specify regressor matrix
# (indicator variables, "short" vs. "long" study duration):
X1 &lt;- cbind("short" = as.numeric(karner.exa$duration == "up to 1 year"),
            "long"  = as.numeric(karner.exa$duration == "1 year or longer"))

# perform meta-regression
# (two group means, common heterogeneity):
bmr01 &lt;- bmr(karner.exa, X=X1,
             tau.prior=function(t){dhalfnormal(t, scale=0.5)})

# show trace plot:
traceplot(bmr01, ylab="log-OR", prior=TRUE,
          taulim=0.53, mulim=c(-1, 0.2),
          X=rbind("short" = c(1,0),
                  "long"  = c(0,1)))

# 2nd regression;
# specify regressor matrix
# (baseline FEV1, an indicator of disease severity):
X2 &lt;- cbind("intercept" = 1,
            "fev1"      = karner.exa$baseline.fev1)

# perform meta-regression
# (linear effect of FEV1 on log-OR):
bmr02 &lt;- bmr(karner.exa, X=X2,
             tau.prior=function(t){dhalfnormal(t, scale=0.5)})

traceplot(bmr02, ylab="log-OR", prior=TRUE,
          taulim=0.53, mulim=c(-1.0, 0.2),
          X=rbind("FEV1 = 1.0"=c(1,1.0),
                  "FEV1 = 1.5"=c(1,1.5),
                  "FEV1 = 2.0"=c(1,2.0)))

## End(Not run)
</code></pre>

<hr>
<h2 id='TurnerEtAlPrior'>(Log-Normal) heterogeneity priors for binary outcomes
as proposed by Turner et al. (2015).</h2><span id='topic+TurnerEtAlPrior'></span><span id='topic+TurnerEtAlParameters'></span>

<h3>Description</h3>

<p>Use the prior specifications proposed in the paper by Turner et al.,
based on an analysis of studies using binary endpoints that were
published in the <em>Cochrane Database of Systematic Reviews</em>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>TurnerEtAlPrior(outcome=c(NA, "all-cause mortality", "obstetric outcomes",
  "cause-specific mortality / major morbidity event / composite (mortality or morbidity)",
  "resource use / hospital stay / process", "surgical / device related success / failure",
  "withdrawals / drop-outs", "internal / structure-related outcomes",
  "general physical health indicators", "adverse events",
  "infection / onset of new disease",
  "signs / symptoms reflecting continuation / end of condition", "pain",
  "quality of life / functioning (dichotomized)", "mental health indicators",
  "biological markers (dichotomized)", "subjective outcomes (various)"),
  comparator1=c("pharmacological", "non-pharmacological", "placebo / control"),
  comparator2=c("pharmacological", "non-pharmacological", "placebo / control"))
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="TurnerEtAlPrior_+3A_outcome">outcome</code></td>
<td>
<p>The type of outcome investigated (see below for a list
of possible values).</p>
</td></tr>
<tr><td><code id="TurnerEtAlPrior_+3A_comparator1">comparator1</code></td>
<td>
<p>One comparator's type.</p>
</td></tr>
<tr><td><code id="TurnerEtAlPrior_+3A_comparator2">comparator2</code></td>
<td>
<p>The other comparator's type.</p>
</td></tr>
</table>


<h3>Details</h3>

 
<p>Turner et al. conducted an analysis of studies listed in the
<em>Cochrane Database of Systematic Reviews</em> that were investigating
binary endpoints. As a result, they proposed empirically motivated
log-normal prior distributions for the (squared!) heterogeneity
parameter <code class="reqn">\tau^2</code>, depending on the particular type of outcome
investigated and the type of comparison in question. The log-normal
parameters (<code class="reqn">\mu</code> and <code class="reqn">\sigma</code>) here are internally stored in
a 3-dimensional array (named <code>TurnerEtAlParameters</code>) and are most
conveniently accessed using the <code>TurnerEtAlPrior()</code> function.
</p>
<p>The <code>outcome</code> argument specifies the type of outcome
investigated. It may take one of the following values
(partial matching is supported):
</p>

<ul>
<li> <p><code>NA</code>
</p>
</li>
<li> <p><code>"all-cause mortality"</code>
</p>
</li>
<li> <p><code>"obstetric outcomes"</code>
</p>
</li>
<li> <p><code>"cause-specific mortality / major morbidity event / composite (mortality or morbidity)"</code>
</p>
</li>
<li> <p><code>"resource use / hospital stay / process"</code>
</p>
</li>
<li> <p><code>"surgical / device related success / failure"</code>
</p>
</li>
<li> <p><code>"withdrawals / drop-outs"</code>
</p>
</li>
<li> <p><code>"internal / structure-related outcomes"</code>
</p>
</li>
<li> <p><code>"general physical health indicators"</code>
</p>
</li>
<li> <p><code>"adverse events"</code>
</p>
</li>
<li> <p><code>"infection / onset of new disease"</code>
</p>
</li>
<li> <p><code>"signs / symptoms reflecting continuation / end of condition"</code>
</p>
</li>
<li> <p><code>"pain"</code>
</p>
</li>
<li> <p><code>"quality of life / functioning (dichotomized)"</code>
</p>
</li>
<li> <p><code>"mental health indicators"</code>
</p>
</li>
<li> <p><code>"biological markers (dichotomized)"</code>
</p>
</li>
<li> <p><code>"subjective outcomes (various)"</code>
</p>
</li></ul>

<p>Specifying &ldquo;<code>outcome=NA</code>&rdquo; (the default) yields the
<em>marginal</em> setting, without considering meta-analysis
characteristics as covariates.
</p>
<p>The <code>comparator1</code> and <code>comparator2</code> arguments together
specify the type of comparison in question.  These may take one of the
following values (partial matching is supported):
</p>

<ul>
<li> <p><code>"pharmacological"</code>
</p>
</li>
<li> <p><code>"non-pharmacological"</code>
</p>
</li>
<li> <p><code>"placebo / control"</code>
</p>
</li></ul>

<p>Any combination is allowed for the <code>comparator1</code> and
<code>comparator2</code> arguments, as long as not both arguments are set to
<code>"placebo / control"</code>.
</p>
<p><b>Note</b> that the log-normal prior parameters refer to the
(<em>squared</em>) heterogeneity parameter <code class="reqn">\tau^2</code>. When you want
to use the prior specifications for <code class="reqn">\tau</code>, the square root,
as the parameter (as is necessary when using the <code>bayesmeta()</code>
function), you need to correct for the square root
transformation. Taking the square root is equivalent to dividing by
two on the log-scale, so the square root's distribution will still be
log-normal, but with halved mean and standard deviation. The relevant
transformations are already taken care of when using the resulting
<code>$dprior()</code>, <code>$pprior()</code> and <code>$qprior()</code> functions; see
also the example below.
</p>


<h3>Value</h3>

<p>a list with elements
</p>
<table>
<tr><td><code>parameters</code></td>
<td>
<p>the log-normal parameters (<code class="reqn">\mu</code> and
<code class="reqn">\sigma</code>, corresponding to the <em>squared</em> heterogeneity
parameter <code class="reqn">\tau^2</code> as well as <code class="reqn">\tau</code>).</p>
</td></tr>
<tr><td><code>outcome.type</code></td>
<td>
<p>the corresponding type of outcome.</p>
</td></tr>
<tr><td><code>comparison.type</code></td>
<td>
<p>the corresponding type of comparison.</p>
</td></tr>
<tr><td><code>dprior</code></td>
<td>
<p>a <code>function(tau)</code> returning the prior
density of <code class="reqn">\tau</code>.</p>
</td></tr>
<tr><td><code>pprior</code></td>
<td>
<p>a <code>function(tau)</code> returning the prior cumulative
distribution function (CDF) of <code class="reqn">\tau</code>.</p>
</td></tr>
<tr><td><code>qprior</code></td>
<td>
<p>a <code>function(p)</code> returning the prior quantile
function (inverse CDF) of <code class="reqn">\tau</code>.</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Christian Roever <a href="mailto:christian.roever@med.uni-goettingen.de">christian.roever@med.uni-goettingen.de</a>
</p>


<h3>References</h3>

<p>R.M. Turner, D. Jackson, Y. Wei, S.G. Thompson,
J.P.T. Higgins.
Predictive distributions for between-study heterogeneity and simple
methods for their application in Bayesian meta-analysis.
<em>Statistics in Medicine</em>, <b>34</b>(6):984-998, 2015.
<a href="https://doi.org/10.1002/sim.6381">doi:10.1002/sim.6381</a>.
</p>
<p>C. Roever, R. Bender, S. Dias, C.H. Schmid, H. Schmidli, S. Sturtz,
S. Weber, T. Friede.
On weakly informative prior distributions for the heterogeneity
parameter in Bayesian random-effects meta-analysis. 
<em>Research Synthesis Methods</em>, <b>12</b>(4):448-474, 2021.
<a href="https://doi.org/10.1002/jrsm.1475">doi:10.1002/jrsm.1475</a>.
</p>


<h3>See Also</h3>

<p><code><a href="stats.html#topic+dlnorm">dlnorm</a></code>, <code><a href="#topic+RhodesEtAlPrior">RhodesEtAlPrior</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example data:
data("CrinsEtAl2014")

# determine corresponding prior parameters:
TP &lt;- TurnerEtAlPrior("surgical", "pharma", "placebo / control")
print(TP)
# a prior 95 percent interval for tau:
TP$qprior(c(0.025,0.975))

## Not run: 
# compute effect sizes (log odds ratios) from count data
# (using "metafor" package's "escalc()" function):
crins.es &lt;- escalc(measure="OR",
                   ai=exp.AR.events,  n1i=exp.total,
                   ci=cont.AR.events, n2i=cont.total,
                   slab=publication, data=CrinsEtAl2014)
print(crins.es)

# perform meta analysis:
crins.ma01 &lt;- bayesmeta(crins.es, tau.prior=TP$dprior)
# for comparison perform analysis using weakly informative Cauchy prior:
crins.ma02 &lt;- bayesmeta(crins.es, tau.prior=function(t){dhalfcauchy(t,scale=1)})

# show results:
print(crins.ma01)
print(crins.ma02)
# compare estimates; heterogeneity (tau):
rbind("Turner prior"=crins.ma01$summary[,"tau"], "Cauchy prior"=crins.ma02$summary[,"tau"])
# effect (mu):
rbind("Turner prior"=crins.ma01$summary[,"mu"], "Cauchy prior"=crins.ma02$summary[,"mu"])

# illustrate heterogeneity priors and posteriors:
par(mfcol=c(2,2))
  plot(crins.ma01, which=4, prior=TRUE, taulim=c(0,2),
       main="informative log-normal prior")
  plot(crins.ma02, which=4, prior=TRUE, taulim=c(0,2),
       main="weakly informative half-Cauchy prior")
  plot(crins.ma01, which=3, mulim=c(-3,0),
       main="informative log-normal prior")
  abline(v=0, lty=3)
  plot(crins.ma02, which=3, mulim=c(-3,0),
       main="weakly informative half-Cauchy prior")
  abline(v=0, lty=3)
par(mfrow=c(1,1))

# compare prior and posterior 95 percent upper limits for tau:
TP$qprior(0.95)
crins.ma01$qposterior(0.95)
qhalfcauchy(0.95)
crins.ma02$qposterior(0.95)

## End(Not run)
</code></pre>

<hr>
<h2 id='uisd'>
Unit information standard deviation
</h2><span id='topic+uisd'></span><span id='topic+uisd.default'></span><span id='topic+uisd.escalc'></span>

<h3>Description</h3>

<p>This function estimates the unit information standard deviation (UISD)
from a given set of standard errors and associated sample sizes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  uisd(n, ...)
  ## Default S3 method:
uisd(n, sigma, sigma2=sigma^2, labels=NULL, individual=FALSE, ...)
  ## S3 method for class 'escalc'
uisd(n, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="uisd_+3A_n">n</code></td>
<td>

<p>vector of sample sizes <em>or</em> an <code><a href="metafor.html#topic+escalc">escalc</a></code> object.
</p>
</td></tr>
<tr><td><code id="uisd_+3A_sigma">sigma</code></td>
<td>

<p>vector of standard errors associated with <code>n</code>.
</p>
</td></tr>
<tr><td><code id="uisd_+3A_sigma2">sigma2</code></td>
<td>

<p>vector of <em>squared</em> standard errors (variances) associated with <code>n</code>.
</p>
</td></tr>
<tr><td><code id="uisd_+3A_labels">labels</code></td>
<td>

<p>(optional) a vector of labels corresponding to <code>n</code> and <code>sigma</code>.
</p>
</td></tr>
<tr><td><code id="uisd_+3A_individual">individual</code></td>
<td>

<p>a <code>logical</code> flag indicating whether individual (study-specific)
UISDs are to be returned.
</p>
</td></tr>
<tr><td><code id="uisd_+3A_...">...</code></td>
<td>

<p>other <code>uisd</code> arguments.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The <em>unit information standard deviation (UISD)</em> reflects the
&ldquo;within-study&rdquo; variability, which, depending on the effect
measure considered, sometimes is a somewhat
heuristic notion (Roever et al., 2020).
For a single study, presuming that standard errors result as
</p>
<p style="text-align: center;"><code class="reqn">\sigma_i=\frac{\sigma_\mathrm{u}}{\sqrt{n_i}},</code>
</p>

<p>where <code class="reqn">\sigma_\mathrm{u}</code> is the within-study (population) standard
deviation, the UISD simply results as
</p>
<p style="text-align: center;"><code class="reqn">\sigma_\mathrm{u} = \sqrt{n_i \, \sigma_i^2}.</code>
</p>

<p>This is often appropriate when assuming an (approximately) normal likelihood.
</p>
<p>Assuming a constant <code class="reqn">\sigma_\mathrm{u}</code> value across studies, this
figure then may be estimated by
</p>
<p style="text-align: center;"><code class="reqn">s_\mathrm{u} \;=\; \sqrt{\bar{n} \, \bar{s}^2_\mathrm{h}} \;=\; \sqrt{\frac{\sum_{i=1}^k n_i}{\sum_{i=1}^k \sigma_i^{-2}}},</code>
</p>

<p>where <code class="reqn">\bar{n}</code> is the average (arithmetic mean) of the
studies' sample sizes, and <code class="reqn">\bar{s}^2_\mathrm{h}</code> is the
harmonic mean of the squared standard errors (variances).
</p>
<p>The estimator <code class="reqn">s_\mathrm{u}</code> is motivated via meta-analysis
using the normal-normal hierarchical model (NNHM). In the special case
of homogeneity (zero heterogeneity, <code class="reqn">\tau=0</code>), the overall
mean estimate has standard error
</p>
<p style="text-align: center;"><code class="reqn">\left(\sum_{i=1}^k\sigma_i^{-2}\right)^{-1/2}.</code>
</p>

<p>Since this estimate corresponds to <em>complete pooling</em>, the
standard error may also be expressed via the UISD as
</p>
<p style="text-align: center;"><code class="reqn">\frac{\sigma_\mathrm{u}}{\sqrt{\sum_{i=1}^k n_i}}.</code>
</p>

<p>Equating both above standard error expressions yields
<code class="reqn">s_\mathrm{u}</code> as an estimator
of the UISD <code class="reqn">\sigma_\mathrm{u}</code> (Roever <em>et al</em>, 2020).
</p>


<h3>Value</h3>

<p>Either a (single) estimate of the UISD, or, if <code>individual</code> was
set to &lsquo;<code>TRUE</code>&rsquo;, a (potentially named) vector of UISDs for
each individual study.
</p>


<h3>Author(s)</h3>

<p>Christian Roever <a href="mailto:christian.roever@med.uni-goettingen.de">christian.roever@med.uni-goettingen.de</a>
</p>


<h3>References</h3>

<p>C. Roever, R. Bender, S. Dias, C.H. Schmid, H. Schmidli, S. Sturtz,
S. Weber, T. Friede.
On weakly informative prior distributions for the heterogeneity
parameter in Bayesian random-effects meta-analysis.
<em>Research Synthesis Methods</em>, <b>12</b>(4):448-474, 2021.
<a href="https://doi.org/10.1002/jrsm.1475">doi:10.1002/jrsm.1475</a>.
</p>


<h3>See Also</h3>

<p><code><a href="metafor.html#topic+escalc">escalc</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load data set:
data("CrinsEtAl2014")

# compute logarithmic odds ratios (log-ORs):
CrinsAR  &lt;- escalc(measure="OR",
                   ai=exp.AR.events,  n1i=exp.total,
                   ci=cont.AR.events, n2i=cont.total,
                   slab=publication, data=CrinsEtAl2014)

# estimate the UISD:
uisd(n     = CrinsAR$exp.total + CrinsAR$cont.total,
     sigma = sqrt(CrinsAR$vi),
     label = CrinsAR$publication)

# for an "escalc" object, one may also apply the function directly:
uisd(CrinsAR)

# compute study-specific UISDs:
uisd(CrinsAR, individual=TRUE)
</code></pre>

<hr>
<h2 id='weightsplot'>
Illustrate the posterior mean weights for a <code><a href="#topic+bayesmeta">bayesmeta</a></code> object.
</h2><span id='topic+weightsplot'></span><span id='topic+weightsplot.default'></span><span id='topic+weightsplot.bayesmeta'></span>

<h3>Description</h3>

<p>Generates a bar plot showing individual estimates' posterior mean
weights, either for the overall mean estimate, or for a shrinkage
estimate.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>  weightsplot(x, ...)
  ## S3 method for class 'bayesmeta'
weightsplot(x, individual=FALSE, ordered=TRUE,
            extramargin=4, priorlabel="prior mean", main, xlim, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="weightsplot_+3A_x">x</code></td>
<td>

<p>a <code><a href="#topic+bayesmeta">bayesmeta</a></code> object.
</p>
</td></tr>
<tr><td><code id="weightsplot_+3A_individual">individual</code></td>
<td>

<p>this argument allows to request weights for individual
<em>shrinkage estimates</em>. If <code>FALSE</code> (the default), weights
for the overall mean are returned. Otherwise, it may be an integer
number (<code>1,...,k</code>) giving the index, or a character string giving
the label.
</p>
</td></tr>
<tr><td><code id="weightsplot_+3A_ordered">ordered</code></td>
<td>

<p>a logical flag indicating whether to sort weights by their magnitude.
</p>
</td></tr>
<tr><td><code id="weightsplot_+3A_extramargin">extramargin</code></td>
<td>

<p>an additional margin to be added to the left side of the plot, in
order to accomodate the estimates' labels. The value will be added
to the 2nd element of the margin settings given by
&lsquo;<code>par("mar")</code>&rsquo;. In case study labels still extend beyond
the figure margin, try increasing this number. See also the
<code><a href="graphics.html#topic+par">par</a>()</code> function's help.
</p>
</td></tr>
<tr><td><code id="weightsplot_+3A_priorlabel">priorlabel</code></td>
<td>

<p>the label for the effect prior's weight. Only relevant for proper
effect priors.
</p>
</td></tr>
<tr><td><code id="weightsplot_+3A_main">main</code></td>
<td>

<p>the plot's main title.
</p>
</td></tr>
<tr><td><code id="weightsplot_+3A_xlim">xlim</code></td>
<td>

<p>the x-axis range.
</p>
</td></tr>
<tr><td><code id="weightsplot_+3A_...">...</code></td>
<td>

<p>other arguments passed on to the
<code><a href="graphics.html#topic+barplot">barplot</a>()</code> function.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The individual estimates' contributions to the overall mean estimate
are commonly illustrated in terms of <em>weights</em>, as the resulting
overall estimate may be expressed as a weighted average of the
estimates contributing to the analysis. The notion of &ldquo;study
weights&rdquo; may also be extended to the Bayesian setting, where these
result as <em>posterior mean weights</em>. Analogous weights may also be
derived for <em>shrinkage estimates</em> (Roever and Friede, 2021).
</p>
<p>This function generates a simple bar plot illustrating the
posterior mean weights. The actual numbers are taken from the
<code>bayesmeta</code> object's &ldquo;<code>$weights</code>&rdquo; or
&ldquo;<code>$weights.theta</code>&rdquo; elements.
</p>


<h3>Author(s)</h3>

<p>Christian Roever <a href="mailto:christian.roever@med.uni-goettingen.de">christian.roever@med.uni-goettingen.de</a>
</p>


<h3>References</h3>

<p>C. Roever, T. Friede.
Bounds for the weight of external data in shrinkage estimation.
<em>Biometrical Journal</em>, <b>65</b>(5):1131-1143, 2021.
<a href="https://doi.org/10.1002/bimj.202000227">doi:10.1002/bimj.202000227</a>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+bayesmeta">bayesmeta</a></code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># load example data:
data("Peto1980")
## Not run: 
# compute effect sizes (log odds ratios) from count data:
require("metafor")
peto.es &lt;- escalc(measure="OR",
                  ai=treat.events,   n1i=treat.cases,
                  ci=control.events, n2i=control.cases,
                  slab=publication, data=Peto1980)

# perform meta-analysis:
ma01 &lt;- bayesmeta(peto.es)
# show data and results:
forestplot(ma01)

# check out weights:
ma01$weights
ma01$weights.theta

# illustrate weights:
weightsplot(ma01)
weightsplot(ma01, ordered=FALSE)
weightsplot(ma01, ordered=FALSE, individual="BrMedJ1974")

## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
