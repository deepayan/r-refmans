<!DOCTYPE html><html><head><title>Help for package crandep</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {crandep}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#check_dep_word'><p>Check and convert dependency word(s)</p></a></li>
<li><a href='#chi_citations'><p>Citation network of CHI papers</p></a></li>
<li><a href='#cran_dependencies'><p>Dependencies of CRAN packages</p></a></li>
<li><a href='#cran_url'><p>Obtain the URL on CRAN using the package name</p></a></li>
<li><a href='#df_to_graph'><p>Construct the giant component of the network from two data frames</p></a></li>
<li><a href='#dmix2'><p>Probability mass function (PMF) of 2-component discrete extreme value mixture distribution</p></a></li>
<li><a href='#dmix3'><p>Probability mass function (PMF) of 3-component discrete extreme value mixture distribution</p></a></li>
<li><a href='#dpol'><p>Probability mass function (PMF) of Zipf-polylog distribution</p></a></li>
<li><a href='#get_dep_all_packages'><p>Dependencies of all CRAN packages</p></a></li>
<li><a href='#get_dep_df'><p>Multiple types of dependencies</p></a></li>
<li><a href='#get_dep_str'><p>Find string corresponding to &quot;Imports&quot;, &quot;Depends&quot; etc.</p></a></li>
<li><a href='#get_dep_vec'><p>Split a string to a list of dependencies</p></a></li>
<li><a href='#get_graph_all_packages'><p>Graph of dependencies of all CRAN packages</p></a></li>
<li><a href='#html_text_vec'><p>Scrap the page (of a package) as a text vector</p></a></li>
<li><a href='#lpost_bulk_wrapper'><p>Wrapper of lpost_bulk, assuming power law (theta = 1.0)</p></a></li>
<li><a href='#lpost_pol_wrapper'><p>Wrapper of lpost_pol, assuming power law (theta = 1.0)</p></a></li>
<li><a href='#lpost_pow'><p>Unnormalised log-posterior density of discrete power law</p></a></li>
<li><a href='#marg_pow'><p>Marginal log-likelihood and posterior density of discrete power law via numerical integration</p></a></li>
<li><a href='#mcmc_mix1'><p>Markov chain Monte Carlo for TZP-power-law mixture</p></a></li>
<li><a href='#mcmc_mix1_wrapper'><p>Wrapper of mcmc_mix1</p></a></li>
<li><a href='#mcmc_mix2'><p>Markov chain Monte Carlo for 2-component discrete extreme value mixture distribution</p></a></li>
<li><a href='#mcmc_mix2_wrapper'><p>Wrapper of mcmc_mix2</p></a></li>
<li><a href='#mcmc_mix3'><p>Markov chain Monte Carlo for 3-component discrete extreme value mixture distribution</p></a></li>
<li><a href='#mcmc_mix3_wrapper'><p>Wrapper of mcmc_mix3</p></a></li>
<li><a href='#mcmc_pol'><p>Markov chain Monte Carlo for Zipf-polylog distribution</p></a></li>
<li><a href='#mcmc_pol_wrapper'><p>Wrapper of mcmc_pol</p></a></li>
<li><a href='#obtain_u_set_mix1'><p>Obtain set of thresholds with high posterior density for the TZP-power-law mixture model</p></a></li>
<li><a href='#obtain_u_set_mix2'><p>Obtain set of thresholds with high posterior density for the 2-component mixture model</p></a></li>
<li><a href='#obtain_u_set_mix3'><p>Obtain set of thresholds with high posterior density for the 3-component mixture model</p></a></li>
<li><a href='#reshape_dep'><p>Reshape the data frame of dependencies</p></a></li>
<li><a href='#Smix2'><p>Survival function of 2-component discrete extreme value mixture distribution</p></a></li>
<li><a href='#Smix3'><p>Survival function of 3-component discrete extreme value mixture distribution</p></a></li>
<li><a href='#Spol'><p>Survival function of Zipf-polylog distribution</p></a></li>
<li><a href='#topo_sort_kahn'><p>Return a sorted vector of nodes id</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Title:</td>
<td>Network Analysis of Dependencies of CRAN Packages</td>
</tr>
<tr>
<td>Version:</td>
<td>0.3.7</td>
</tr>
<tr>
<td>Description:</td>
<td>The dependencies of CRAN packages can be analysed in a network fashion. For each package we can obtain the packages that it depends, imports, suggests, etc. By iterating this procedure over a number of packages, we can build, visualise, and analyse the dependency network, enabling us to have a bird's-eye view of the CRAN ecosystem. One aspect of interest is the number of reverse dependencies of the packages, or equivalently the in-degree distribution of the dependency network. This can be fitted by the power law and/or an extreme value mixture distribution &lt;<a href="https://arxiv.org/abs/2008.03073">arXiv:2008.03073</a>&gt;, of which functions are provided.</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.4)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/clement-lee/crandep">https://github.com/clement-lee/crandep</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/clement-lee/crandep/issues">https://github.com/clement-lee/crandep/issues</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>xml2, rvest, stringr, dplyr, igraph, Rcpp, pracma, gsl, stats</td>
</tr>
<tr>
<td>Suggests:</td>
<td>ggplot2, tibble, visNetwork, knitr, rmarkdown</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>pandoc (&gt;= 1.12.3) - http://pandoc.org</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-03-28 12:19:58 UTC; ntl34</td>
</tr>
<tr>
<td>Author:</td>
<td>Clement Lee <a href="https://orcid.org/0000-0003-1785-8671"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut,
    cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Clement Lee &lt;clement.lee.tm@outlook.com&gt;</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-03-28 16:10:09 UTC</td>
</tr>
</table>
<hr>
<h2 id='check_dep_word'>Check and convert dependency word(s)</h2><span id='topic+check_dep_word'></span>

<h3>Description</h3>

<p>Check and convert dependency word(s)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>check_dep_word(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="check_dep_word_+3A_x">x</code></td>
<td>
<p>A character vector of dependency words</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector of modified dependency words
</p>

<hr>
<h2 id='chi_citations'>Citation network of CHI papers</h2><span id='topic+chi_citations'></span>

<h3>Description</h3>

<p>A dataset containing the citations of conference papers of the ACM Conference on Human Factors in Computing Systems (CHI) from 1981 to 2019, obtained from the ACM digital library. The resulting citation network can be compared to the dependencies network of CRAN packages, in terms of network-related characteristics, such as degree distribution and sparsity.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>chi_citations
</code></pre>


<h3>Format</h3>

<p>A data from with21951 rows and 4 variables:
</p>

<dl>
<dt>from</dt><dd><p>the unique identifier (in the digital library) of the paper that cites other papers</p>
</dd>
<dt>to</dt><dd><p>the unique identifier of the paper that is being cited</p>
</dd>
<dt>year_from</dt><dd><p>the publication year of the citing paper</p>
</dd>
<dt>year_to</dt><dd><p>the publication year of the cited paper</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://dl.acm.org/conference/chi">https://dl.acm.org/conference/chi</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+cran_dependencies">cran_dependencies</a></code>
</p>

<hr>
<h2 id='cran_dependencies'>Dependencies of CRAN packages</h2><span id='topic+cran_dependencies'></span>

<h3>Description</h3>

<p>A dataset containing the dependencies of various types (Imports, Depends, Suggests, LinkingTo, and their reverse counterparts) of more than 14600 packages available on CRAN as of 2020-05-09.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cran_dependencies
</code></pre>


<h3>Format</h3>

<p>A data frame with 211408 rows and 4 variables:
</p>

<dl>
<dt>from</dt><dd><p>the name of the package that introduced the dependencies</p>
</dd>
<dt>to</dt><dd><p>the name of the package that the dependency is directed towards</p>
</dd>
<dt>type</dt><dd><p>the type of dependency, which can take the follow values (all in lowercase): &quot;depends&quot;, &quot;imports&quot;, &quot;linking to&quot;, &quot;suggests&quot;</p>
</dd>
<dt>reverse</dt><dd><p>a boolean representing whether the dependency is a reverse one (TRUE) or a forward one (FALSE)</p>
</dd>
</dl>



<h3>Source</h3>

<p>The CRAN pages of all the packages available on <a href="https://cran.r-project.org">https://cran.r-project.org</a>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+chi_citations">chi_citations</a></code>
</p>

<hr>
<h2 id='cran_url'>Obtain the URL on CRAN using the package name</h2><span id='topic+cran_url'></span>

<h3>Description</h3>

<p>Obtain the URL on CRAN using the package name
</p>


<h3>Usage</h3>

<pre><code class='language-R'>cran_url(name)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="cran_url_+3A_name">name</code></td>
<td>
<p>String, name of the package</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string of the URL for the package on CRAN
</p>


<h3>Examples</h3>

<pre><code class='language-R'>crandep:::cran_url("dplyr")
</code></pre>

<hr>
<h2 id='df_to_graph'>Construct the giant component of the network from two data frames</h2><span id='topic+df_to_graph'></span>

<h3>Description</h3>

<p>Construct the giant component of the network from two data frames
</p>


<h3>Usage</h3>

<pre><code class='language-R'>df_to_graph(edgelist, nodelist = NULL, gc = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="df_to_graph_+3A_edgelist">edgelist</code></td>
<td>
<p>A data frame with (at least) two columns: from and to</p>
</td></tr>
<tr><td><code id="df_to_graph_+3A_nodelist">nodelist</code></td>
<td>
<p>NULL, or a data frame with (at least) one column: name, that contains the nodes to include</p>
</td></tr>
<tr><td><code id="df_to_graph_+3A_gc">gc</code></td>
<td>
<p>Boolean, if 'TRUE' (default) then the giant component is extracted, if 'FALSE' then the whole graph is returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An igraph object &amp; a connected graph if gc is 'TRUE'
</p>


<h3>Examples</h3>

<pre><code class='language-R'>from &lt;- c("1", "2", "4")
to &lt;- c("2", "3", "5")
edges &lt;- data.frame(from = from, to = to, stringsAsFactors = FALSE)
nodes &lt;- data.frame(name = c("1", "2", "3", "4", "5"), stringsAsFactors = FALSE)
df_to_graph(edges, nodes)
</code></pre>

<hr>
<h2 id='dmix2'>Probability mass function (PMF) of 2-component discrete extreme value mixture distribution</h2><span id='topic+dmix2'></span>

<h3>Description</h3>

<p><code>dmix2</code> returns the PMF at x for the 2-component discrete extreme value mixture distribution. The components below and above the threshold u are the (truncated) Zipf-polylog(alpha,theta) and the generalised Pareto(shape, sigma) distributions, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmix2(x, u, alpha, theta, shape, sigma, phiu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmix2_+3A_x">x</code></td>
<td>
<p>Vector of positive integers</p>
</td></tr>
<tr><td><code id="dmix2_+3A_u">u</code></td>
<td>
<p>Positive integer representing the threshold</p>
</td></tr>
<tr><td><code id="dmix2_+3A_alpha">alpha</code></td>
<td>
<p>Real number, first parameter of the Zipf-polylog component</p>
</td></tr>
<tr><td><code id="dmix2_+3A_theta">theta</code></td>
<td>
<p>Real number in (0, 1], second parameter of the Zipf-polylog component</p>
</td></tr>
<tr><td><code id="dmix2_+3A_shape">shape</code></td>
<td>
<p>Real number, shape parameter of the generalised Pareto component</p>
</td></tr>
<tr><td><code id="dmix2_+3A_sigma">sigma</code></td>
<td>
<p>Real number, scale parameter of the generalised Pareto component</p>
</td></tr>
<tr><td><code id="dmix2_+3A_phiu">phiu</code></td>
<td>
<p>Real number in (0, 1), exceedance rate of the threshold u</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the same length as x
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Smix2">Smix2</a></code> for the corresponding survival function, <code><a href="#topic+dpol">dpol</a></code> and <code><a href="#topic+dmix3">dmix3</a></code> for the PMFs of the Zipf-polylog and 3-component discrete extreme value mixture distributions, respectively.
</p>

<hr>
<h2 id='dmix3'>Probability mass function (PMF) of 3-component discrete extreme value mixture distribution</h2><span id='topic+dmix3'></span>

<h3>Description</h3>

<p><code>dmix3</code> returns the PMF at x for the 3-component discrete extreme value mixture distribution. The component below v is the (truncated) Zipf-polylog(alpha1,theta1) distribution, between v &amp; u the (truncated) Zipf-polylog(alpha2,theta2) distribution, and above u the generalised Pareto(shape, sigma) distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dmix3(x, v, u, alpha1, theta1, alpha2, theta2, shape, sigma, phi1, phi2, phiu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dmix3_+3A_x">x</code></td>
<td>
<p>Vector of positive integers</p>
</td></tr>
<tr><td><code id="dmix3_+3A_v">v</code></td>
<td>
<p>Positive integer representing the lower threshold</p>
</td></tr>
<tr><td><code id="dmix3_+3A_u">u</code></td>
<td>
<p>Positive integer representing the upper threshold</p>
</td></tr>
<tr><td><code id="dmix3_+3A_alpha1">alpha1</code></td>
<td>
<p>Real number, first parameter of the Zipf-polylog component below v</p>
</td></tr>
<tr><td><code id="dmix3_+3A_theta1">theta1</code></td>
<td>
<p>Real number in (0, 1], second parameter of the Zipf-polylog component below v</p>
</td></tr>
<tr><td><code id="dmix3_+3A_alpha2">alpha2</code></td>
<td>
<p>Real number, first parameter of the Zipf-polylog component between v &amp; u</p>
</td></tr>
<tr><td><code id="dmix3_+3A_theta2">theta2</code></td>
<td>
<p>Real number in (0, 1], second parameter of the Zipf-polylog component between v &amp; u</p>
</td></tr>
<tr><td><code id="dmix3_+3A_shape">shape</code></td>
<td>
<p>Real number, shape parameter of the generalised Pareto component</p>
</td></tr>
<tr><td><code id="dmix3_+3A_sigma">sigma</code></td>
<td>
<p>Real number, scale parameter of the generalised Pareto component</p>
</td></tr>
<tr><td><code id="dmix3_+3A_phi1">phi1</code></td>
<td>
<p>Real number in (0, 1), proportion of values below v</p>
</td></tr>
<tr><td><code id="dmix3_+3A_phi2">phi2</code></td>
<td>
<p>Real number in (0, 1), proportion of values between v &amp; u</p>
</td></tr>
<tr><td><code id="dmix3_+3A_phiu">phiu</code></td>
<td>
<p>Real number in (0, 1), exceedance rate of the threshold u</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the same length as x
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Smix3">Smix3</a></code> for the corresponding survival function, <code><a href="#topic+dpol">dpol</a></code> and <code><a href="#topic+dmix2">dmix2</a></code> for the PMFs of the Zipf-polylog and 2-component discrete extreme value mixture distributions, respectively.
</p>

<hr>
<h2 id='dpol'>Probability mass function (PMF) of Zipf-polylog distribution</h2><span id='topic+dpol'></span>

<h3>Description</h3>

<p><code>dpol</code> returns the PMF at x for the Zipf-polylog distribution with parameters (alpha, theta). The distribution is reduced to the discrete power law when theta = 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dpol(x, alpha, theta, xmax = 100000L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="dpol_+3A_x">x</code></td>
<td>
<p>Vector of positive integers</p>
</td></tr>
<tr><td><code id="dpol_+3A_alpha">alpha</code></td>
<td>
<p>Real number greater than 1</p>
</td></tr>
<tr><td><code id="dpol_+3A_theta">theta</code></td>
<td>
<p>Real number in (0, 1]</p>
</td></tr>
<tr><td><code id="dpol_+3A_xmax">xmax</code></td>
<td>
<p>Scalar (default 100000), positive integer limit for computing the normalising constant</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The PMF is proportional to x^(-alpha) * theta^x. It is normalised in order to be a proper PMF.
</p>


<h3>Value</h3>

<p>A numeric vector of the same length as x
</p>


<h3>See Also</h3>

<p><code><a href="#topic+Spol">Spol</a></code> for the corresponding survival function, <code><a href="#topic+dmix2">dmix2</a></code> and <code><a href="#topic+dmix3">dmix3</a></code> for the PMFs of the 2-component and 3-component discrete extreme value mixture distributions, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>dpol(c(1,2,3,4,5), 1.2, 0.5)
</code></pre>

<hr>
<h2 id='get_dep_all_packages'>Dependencies of all CRAN packages</h2><span id='topic+get_dep_all_packages'></span>

<h3>Description</h3>

<p><code>get_dep_all_packages</code> returns the data frame of dependencies of all packages currently available on CRAN.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dep_all_packages()
</code></pre>


<h3>Details</h3>

<p>Unlike <code>get_dep</code>, there is no boolean argument 'scrape', as it is much faster to obtain the dependencies of all packages via 'tools::CRAN_package_db()'.
</p>


<h3>Value</h3>

<p>A data frame of dependencies of all CRAN packages
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_dep">get_dep</a></code> for multiple types of dependencies, and <code><a href="#topic+get_graph_all_packages">get_graph_all_packages</a></code> for obtaining directly a network of dependencies as an igraph object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
df.cran &lt;- get_dep_all_packages()

## End(Not run)
</code></pre>

<hr>
<h2 id='get_dep_df'>Multiple types of dependencies</h2><span id='topic+get_dep_df'></span><span id='topic+get_dep_all'></span><span id='topic+get_dep'></span>

<h3>Description</h3>

<p><code>get_dep</code> returns a data frame of multiple types of dependencies of a package
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dep_df(name, type, scrape = TRUE)

get_dep_all(name, type, scrape = TRUE)

get_dep(name, type, scrape = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_dep_df_+3A_name">name</code></td>
<td>
<p>String, name of the package</p>
</td></tr>
<tr><td><code id="get_dep_df_+3A_type">type</code></td>
<td>
<p>A character vector that contains one or more of the following dependency words: &quot;Depends&quot;, &quot;Imports&quot;, &quot;LinkingTo&quot;, &quot;Suggests&quot;, &quot;Enhances&quot;, &quot;Reverse depends&quot;, &quot;Reverse imports&quot;, &quot;Reverse linking to&quot;, &quot;Reverse suggests&quot;, &quot;Reverse enhances&quot;, up to letter case and space replaced by underscore. Alternatively, if 'type = &quot;all&quot;', all ten dependencies will be obtained.</p>
</td></tr>
<tr><td><code id="get_dep_df_+3A_scrape">scrape</code></td>
<td>
<p>Boolean. If 'TRUE' (default), the page of the package will be scraped. If 'FALSE', tools::CRAN_package_db() will be used. Whether the argument equals 'TRUE' or 'FALSE' should not affect the output, but only the time taken. Usually, the former is faster than the latter for a single package.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of dependencies
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_dep_all_packages">get_dep_all_packages</a></code> for the dependencies of all CRAN packages, and <code><a href="#topic+get_graph_all_packages">get_graph_all_packages</a></code> for obtaining directly a network of dependencies as an igraph object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>get_dep("dplyr", c("Imports", "Depends"))
get_dep("MASS", c("Suggests", "Depends", "Imports"), TRUE) # FALSE will give same result
</code></pre>

<hr>
<h2 id='get_dep_str'>Find string corresponding to &quot;Imports&quot;, &quot;Depends&quot; etc.</h2><span id='topic+get_dep_str'></span>

<h3>Description</h3>

<p>Find string corresponding to &quot;Imports&quot;, &quot;Depends&quot; etc.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dep_str(v, x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_dep_str_+3A_v">v</code></td>
<td>
<p>A vector of strings</p>
</td></tr>
<tr><td><code id="get_dep_str_+3A_x">x</code></td>
<td>
<p>One of the following dependency words: &quot;Depends&quot;, &quot;Imports&quot;, &quot;LinkingTo&quot;, &quot;Suggests&quot;, &quot;Enhances&quot;, &quot;Reverse_depends&quot;, &quot;Reverse_imports&quot;, &quot;Reverse_linking_to&quot;, &quot;Reverse_suggests&quot;, &quot;Reverse_enhances&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string of the concatenation of the dependencies
</p>

<hr>
<h2 id='get_dep_vec'>Split a string to a list of dependencies</h2><span id='topic+get_dep_vec'></span>

<h3>Description</h3>

<p>Split a string to a list of dependencies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_dep_vec(x)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_dep_vec_+3A_x">x</code></td>
<td>
<p>A scalar string, possibly an output of get_dep_str()</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string vector of dependencies
</p>

<hr>
<h2 id='get_graph_all_packages'>Graph of dependencies of all CRAN packages</h2><span id='topic+get_graph_all_packages'></span>

<h3>Description</h3>

<p><code>get_graph_all_packages</code> returns an igraph object representing the network of one or more types of dependencies of all CRAN packages.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_graph_all_packages(type, gc = TRUE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="get_graph_all_packages_+3A_type">type</code></td>
<td>
<p>A character vector that contains one or more of the following dependency words: &quot;Depends&quot;, &quot;Imports&quot;, &quot;LinkingTo&quot;, &quot;Suggests&quot;, &quot;Enhances&quot;, &quot;Reverse depends&quot;, &quot;Reverse imports&quot;, &quot;Reverse linking to&quot;, &quot;Reverse suggests&quot;, &quot;Reverse enhances&quot;, up to letter case and space replaced by underscore. Alternatively, if 'types = &quot;all&quot;', all ten dependencies will be obtained.</p>
</td></tr>
<tr><td><code id="get_graph_all_packages_+3A_gc">gc</code></td>
<td>
<p>Boolean, if 'TRUE' (default) then the giant component is extracted, if 'FALSE' then the whole graph is returned</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An igraph object &amp; a connected graph if gc is 'TRUE'
</p>


<h3>See Also</h3>

<p><code><a href="#topic+get_dep_all_packages">get_dep_all_packages</a></code> for the dependencies of all CRAN packages in a data frame, and <code><a href="#topic+df_to_graph">df_to_graph</a></code> for constructing the giant component of the network from two data frames
</p>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
g0.cran.depends &lt;- get_graph_all_packages("depends")
g1.cran.imports &lt;- get_graph_all_packages("reverse imports")

## End(Not run)
</code></pre>

<hr>
<h2 id='html_text_vec'>Scrap the page (of a package) as a text vector</h2><span id='topic+html_text_vec'></span>

<h3>Description</h3>

<p>Scrap the page (of a package) as a text vector
</p>


<h3>Usage</h3>

<pre><code class='language-R'>html_text_vec(url)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="html_text_vec_+3A_url">url</code></td>
<td>
<p>An URL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A string vector of the html text of the page according to the url
</p>

<hr>
<h2 id='lpost_bulk_wrapper'>Wrapper of lpost_bulk, assuming power law (theta = 1.0)</h2><span id='topic+lpost_bulk_wrapper'></span>

<h3>Description</h3>

<p>Wrapper of lpost_bulk, assuming power law (theta = 1.0)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lpost_bulk_wrapper(alpha, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lpost_bulk_wrapper_+3A_alpha">alpha</code></td>
<td>
<p>A scalar, positive</p>
</td></tr>
<tr><td><code id="lpost_bulk_wrapper_+3A_...">...</code></td>
<td>
<p>Other arguments passed to lpost_bulk</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar of the log-posterior density
</p>

<hr>
<h2 id='lpost_pol_wrapper'>Wrapper of lpost_pol, assuming power law (theta = 1.0)</h2><span id='topic+lpost_pol_wrapper'></span>

<h3>Description</h3>

<p>Wrapper of lpost_pol, assuming power law (theta = 1.0)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lpost_pol_wrapper(alpha, x, count, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lpost_pol_wrapper_+3A_alpha">alpha</code></td>
<td>
<p>A scalar, positive</p>
</td></tr>
<tr><td><code id="lpost_pol_wrapper_+3A_...">...</code></td>
<td>
<p>Other arguments passed to lpost_pol</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A scalar of the log-posterior density
</p>

<hr>
<h2 id='lpost_pow'>Unnormalised log-posterior density of discrete power law</h2><span id='topic+lpost_pow'></span>

<h3>Description</h3>

<p>Unnormalised log-posterior density of discrete power law
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lpost_pow(alpha, df, m_alpha, s_alpha)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="lpost_pow_+3A_alpha">alpha</code></td>
<td>
<p>Real number greater than 1</p>
</td></tr>
<tr><td><code id="lpost_pow_+3A_df">df</code></td>
<td>
<p>A data frame with at least two columns, x &amp; count</p>
</td></tr>
<tr><td><code id="lpost_pow_+3A_m_alpha">m_alpha</code></td>
<td>
<p>Real number, mean of the prior normal distribution for alpha</p>
</td></tr>
<tr><td><code id="lpost_pow_+3A_s_alpha">s_alpha</code></td>
<td>
<p>Positive real number, standard deviation of the prior normal distribution for alpha</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A real number
</p>

<hr>
<h2 id='marg_pow'>Marginal log-likelihood and posterior density of discrete power law via numerical integration</h2><span id='topic+marg_pow'></span>

<h3>Description</h3>

<p>Marginal log-likelihood and posterior density of discrete power law via numerical integration
</p>


<h3>Usage</h3>

<pre><code class='language-R'>marg_pow(df, lower, upper, m_alpha, s_alpha, by = 0.001)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="marg_pow_+3A_df">df</code></td>
<td>
<p>A data frame with at least two columns, x &amp; count</p>
</td></tr>
<tr><td><code id="marg_pow_+3A_lower">lower</code></td>
<td>
<p>Real number greater than 1, lower limit for numerical integration</p>
</td></tr>
<tr><td><code id="marg_pow_+3A_upper">upper</code></td>
<td>
<p>Real number greater than lower, upper limit for numerical integration</p>
</td></tr>
<tr><td><code id="marg_pow_+3A_m_alpha">m_alpha</code></td>
<td>
<p>Real number, mean of the prior normal distribution for alpha</p>
</td></tr>
<tr><td><code id="marg_pow_+3A_s_alpha">s_alpha</code></td>
<td>
<p>Positive real number, standard deviation of the prior normal distribution for alpha</p>
</td></tr>
<tr><td><code id="marg_pow_+3A_by">by</code></td>
<td>
<p>Positive real number, the width of subintervals between lower and upper, for numerical integration and posterior density evaluation</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list: <code>log_marginal</code> is the marginal log-likelihood, <code>posterior</code> is a data frame of non-zero posterior densities
</p>

<hr>
<h2 id='mcmc_mix1'>Markov chain Monte Carlo for TZP-power-law mixture</h2><span id='topic+mcmc_mix1'></span>

<h3>Description</h3>

<p><code>mcmc_mix1</code> returns the posterior samples of the parameters, for fitting the TZP-power-law mixture distribution. The samples are obtained using Markov chain Monte Carlo (MCMC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc_mix1(
  x,
  count,
  u_set,
  u,
  alpha1,
  theta1,
  alpha2,
  a_psiu,
  b_psiu,
  a_alpha1,
  b_alpha1,
  a_theta1,
  b_theta1,
  a_alpha2,
  b_alpha2,
  positive,
  iter,
  thin,
  burn,
  freq,
  invt,
  mc3_or_marg,
  xmax
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmc_mix1_+3A_x">x</code></td>
<td>
<p>Vector of the unique values (positive integers) of the data</p>
</td></tr>
<tr><td><code id="mcmc_mix1_+3A_count">count</code></td>
<td>
<p>Vector of the same length as x that contains the counts of each unique value in the full data, which is essentially rep(x, count)</p>
</td></tr>
<tr><td><code id="mcmc_mix1_+3A_u_set">u_set</code></td>
<td>
<p>Positive integer vector of the values u will be sampled from</p>
</td></tr>
<tr><td><code id="mcmc_mix1_+3A_u">u</code></td>
<td>
<p>Positive integer, initial value of the threshold</p>
</td></tr>
<tr><td><code id="mcmc_mix1_+3A_alpha1">alpha1</code></td>
<td>
<p>Real number, initial value of the parameter</p>
</td></tr>
<tr><td><code id="mcmc_mix1_+3A_theta1">theta1</code></td>
<td>
<p>Real number in (0, 1], initial value of the parameter</p>
</td></tr>
<tr><td><code id="mcmc_mix1_+3A_alpha2">alpha2</code></td>
<td>
<p>Real number greater than 1, initial value of the parameter</p>
</td></tr>
<tr><td><code id="mcmc_mix1_+3A_a_psiu">a_psiu</code>, <code id="mcmc_mix1_+3A_b_psiu">b_psiu</code>, <code id="mcmc_mix1_+3A_a_alpha1">a_alpha1</code>, <code id="mcmc_mix1_+3A_b_alpha1">b_alpha1</code>, <code id="mcmc_mix1_+3A_a_theta1">a_theta1</code>, <code id="mcmc_mix1_+3A_b_theta1">b_theta1</code>, <code id="mcmc_mix1_+3A_a_alpha2">a_alpha2</code>, <code id="mcmc_mix1_+3A_b_alpha2">b_alpha2</code></td>
<td>
<p>Scalars, real numbers representing the hyperparameters of the prior distributions for the respective parameters. See details for the specification of the priors.</p>
</td></tr>
<tr><td><code id="mcmc_mix1_+3A_positive">positive</code></td>
<td>
<p>Boolean, is alpha positive (TRUE) or unbounded (FALSE)?</p>
</td></tr>
<tr><td><code id="mcmc_mix1_+3A_iter">iter</code></td>
<td>
<p>Positive integer representing the length of the MCMC output</p>
</td></tr>
<tr><td><code id="mcmc_mix1_+3A_thin">thin</code></td>
<td>
<p>Positive integer representing the thinning in the MCMC</p>
</td></tr>
<tr><td><code id="mcmc_mix1_+3A_burn">burn</code></td>
<td>
<p>Non-negative integer representing the burn-in of the MCMC</p>
</td></tr>
<tr><td><code id="mcmc_mix1_+3A_freq">freq</code></td>
<td>
<p>Positive integer representing the frequency of the sampled values being printed</p>
</td></tr>
<tr><td><code id="mcmc_mix1_+3A_invt">invt</code></td>
<td>
<p>Vector of the inverse temperatures for Metropolis-coupled MCMC</p>
</td></tr>
<tr><td><code id="mcmc_mix1_+3A_mc3_or_marg">mc3_or_marg</code></td>
<td>
<p>Boolean, is invt for parallel tempering / Metropolis-coupled MCMC (TRUE, default) or marginal likelihood via power posterior (FALSE)?</p>
</td></tr>
<tr><td><code id="mcmc_mix1_+3A_xmax">xmax</code></td>
<td>
<p>Scalar, positive integer limit for computing the normalising constant</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the MCMC, a componentwise Metropolis-Hastings algorithm is used. The threshold u is treated as a parameter and therefore sampled. The hyperparameters are used in the following priors: u is such that the implied unique exceedance probability psiu ~ Uniform(a_psi, b_psi); alpha1 ~ Normal(mean = a_alpha1, sd = b_alpha1); theta1 ~ Beta(a_theta1, b_theta1); alpha2 ~ Normal(mean = a_alpha2, sd = b_alpha2)
</p>


<h3>Value</h3>

<p>A list: $pars is a data frame of iter rows of the MCMC samples, $fitted is a data frame of length(x) rows with the fitted values, amongst other quantities related to the MCMC
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcmc_pol">mcmc_pol</a></code>, <code><a href="#topic+mcmc_mix2">mcmc_mix2</a></code> and <code><a href="#topic+mcmc_mix3">mcmc_mix3</a></code> for MCMC for the Zipf-polylog, and 2-component and 3-component discrete extreme value mixture distributions, respectively.
</p>

<hr>
<h2 id='mcmc_mix1_wrapper'>Wrapper of mcmc_mix1</h2><span id='topic+mcmc_mix1_wrapper'></span>

<h3>Description</h3>

<p>Wrapper of mcmc_mix1
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc_mix1_wrapper(
  df,
  seed,
  a_psiu = 0.1,
  b_psiu = 0.9,
  m_alpha1 = 0,
  s_alpha1 = 10,
  a_theta1 = 1,
  b_theta1 = 1,
  m_alpha2 = 0,
  s_alpha2 = 10,
  positive = FALSE,
  iter = 20000L,
  thin = 1L,
  burn = 10000L,
  freq = 100L,
  invts = 0.001^((0:8)/8),
  mc3_or_marg = TRUE,
  xmax = 1e+05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmc_mix1_wrapper_+3A_df">df</code></td>
<td>
<p>A data frame with at least two columns, x &amp; count</p>
</td></tr>
<tr><td><code id="mcmc_mix1_wrapper_+3A_seed">seed</code></td>
<td>
<p>Integer for <code>set.seed</code></p>
</td></tr>
<tr><td><code id="mcmc_mix1_wrapper_+3A_a_psiu">a_psiu</code>, <code id="mcmc_mix1_wrapper_+3A_b_psiu">b_psiu</code>, <code id="mcmc_mix1_wrapper_+3A_m_alpha1">m_alpha1</code>, <code id="mcmc_mix1_wrapper_+3A_s_alpha1">s_alpha1</code>, <code id="mcmc_mix1_wrapper_+3A_a_theta1">a_theta1</code>, <code id="mcmc_mix1_wrapper_+3A_b_theta1">b_theta1</code>, <code id="mcmc_mix1_wrapper_+3A_m_alpha2">m_alpha2</code>, <code id="mcmc_mix1_wrapper_+3A_s_alpha2">s_alpha2</code></td>
<td>
<p>Scalars, real numbers representing the hyperparameters of the prior distributions for the respective parameters. See details for the specification of the priors.</p>
</td></tr>
<tr><td><code id="mcmc_mix1_wrapper_+3A_positive">positive</code></td>
<td>
<p>Boolean, is alpha1 positive (TRUE) or unbounded (FALSE)?</p>
</td></tr>
<tr><td><code id="mcmc_mix1_wrapper_+3A_iter">iter</code></td>
<td>
<p>Positive integer representing the length of the MCMC output</p>
</td></tr>
<tr><td><code id="mcmc_mix1_wrapper_+3A_thin">thin</code></td>
<td>
<p>Positive integer representing the thinning in the MCMC</p>
</td></tr>
<tr><td><code id="mcmc_mix1_wrapper_+3A_burn">burn</code></td>
<td>
<p>Non-negative integer representing the burn-in of the MCMC</p>
</td></tr>
<tr><td><code id="mcmc_mix1_wrapper_+3A_freq">freq</code></td>
<td>
<p>Positive integer representing the frequency of the sampled values being printed</p>
</td></tr>
<tr><td><code id="mcmc_mix1_wrapper_+3A_invts">invts</code></td>
<td>
<p>Vector of the inverse temperatures for Metropolis-coupled MCMC (if mc3_or_marg = TRUE) or power posterior (if mc3_or_marg = FALSE)</p>
</td></tr>
<tr><td><code id="mcmc_mix1_wrapper_+3A_mc3_or_marg">mc3_or_marg</code></td>
<td>
<p>Boolean, is Metropolis-coupled MCMC to be used? Ignored if invts = c(1.0)</p>
</td></tr>
<tr><td><code id="mcmc_mix1_wrapper_+3A_xmax">xmax</code></td>
<td>
<p>Scalar (default 100000), positive integer limit for computing the normalising constant</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list returned by <code>mcmc_mix1</code>
</p>

<hr>
<h2 id='mcmc_mix2'>Markov chain Monte Carlo for 2-component discrete extreme value mixture distribution</h2><span id='topic+mcmc_mix2'></span>

<h3>Description</h3>

<p><code>mcmc_mix2</code> returns the posterior samples of the parameters, for fitting the 2-component discrete extreme value mixture distribution. The samples are obtained using Markov chain Monte Carlo (MCMC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc_mix2(
  x,
  count,
  u_set,
  u,
  alpha,
  theta,
  shape,
  sigma,
  a_psiu,
  b_psiu,
  a_alpha,
  b_alpha,
  a_theta,
  b_theta,
  m_shape,
  s_shape,
  a_sigma,
  b_sigma,
  positive,
  a_pseudo,
  b_pseudo,
  pr_power,
  iter,
  thin,
  burn,
  freq,
  invt,
  mc3_or_marg = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmc_mix2_+3A_x">x</code></td>
<td>
<p>Vector of the unique values (positive integers) of the data</p>
</td></tr>
<tr><td><code id="mcmc_mix2_+3A_count">count</code></td>
<td>
<p>Vector of the same length as x that contains the counts of each unique value in the full data, which is essentially rep(x, count)</p>
</td></tr>
<tr><td><code id="mcmc_mix2_+3A_u_set">u_set</code></td>
<td>
<p>Positive integer vector of the values u will be sampled from</p>
</td></tr>
<tr><td><code id="mcmc_mix2_+3A_u">u</code></td>
<td>
<p>Positive integer, initial value of the threshold</p>
</td></tr>
<tr><td><code id="mcmc_mix2_+3A_alpha">alpha</code></td>
<td>
<p>Real number greater than 1, initial value of the parameter</p>
</td></tr>
<tr><td><code id="mcmc_mix2_+3A_theta">theta</code></td>
<td>
<p>Real number in (0, 1], initial value of the parameter</p>
</td></tr>
<tr><td><code id="mcmc_mix2_+3A_shape">shape</code></td>
<td>
<p>Real number, initial value of the parameter</p>
</td></tr>
<tr><td><code id="mcmc_mix2_+3A_sigma">sigma</code></td>
<td>
<p>Positive real number, initial value of the parameter</p>
</td></tr>
<tr><td><code id="mcmc_mix2_+3A_a_psiu">a_psiu</code>, <code id="mcmc_mix2_+3A_b_psiu">b_psiu</code>, <code id="mcmc_mix2_+3A_a_alpha">a_alpha</code>, <code id="mcmc_mix2_+3A_b_alpha">b_alpha</code>, <code id="mcmc_mix2_+3A_a_theta">a_theta</code>, <code id="mcmc_mix2_+3A_b_theta">b_theta</code>, <code id="mcmc_mix2_+3A_m_shape">m_shape</code>, <code id="mcmc_mix2_+3A_s_shape">s_shape</code>, <code id="mcmc_mix2_+3A_a_sigma">a_sigma</code>, <code id="mcmc_mix2_+3A_b_sigma">b_sigma</code></td>
<td>
<p>Scalars, real numbers representing the hyperparameters of the prior distributions for the respective parameters. See details for the specification of the priors.</p>
</td></tr>
<tr><td><code id="mcmc_mix2_+3A_positive">positive</code></td>
<td>
<p>Boolean, is alpha positive (TRUE) or unbounded (FALSE)?</p>
</td></tr>
<tr><td><code id="mcmc_mix2_+3A_a_pseudo">a_pseudo</code></td>
<td>
<p>Positive real number, first parameter of the pseudoprior beta distribution for theta in model selection; ignored if pr_power = 1.0</p>
</td></tr>
<tr><td><code id="mcmc_mix2_+3A_b_pseudo">b_pseudo</code></td>
<td>
<p>Positive real number, second parameter of the pseudoprior beta distribution for theta in model selection; ignored if pr_power = 1.0</p>
</td></tr>
<tr><td><code id="mcmc_mix2_+3A_pr_power">pr_power</code></td>
<td>
<p>Real number in [0, 1], prior probability of the discrete power law (below u)</p>
</td></tr>
<tr><td><code id="mcmc_mix2_+3A_iter">iter</code></td>
<td>
<p>Positive integer representing the length of the MCMC output</p>
</td></tr>
<tr><td><code id="mcmc_mix2_+3A_thin">thin</code></td>
<td>
<p>Positive integer representing the thinning in the MCMC</p>
</td></tr>
<tr><td><code id="mcmc_mix2_+3A_burn">burn</code></td>
<td>
<p>Non-negative integer representing the burn-in of the MCMC</p>
</td></tr>
<tr><td><code id="mcmc_mix2_+3A_freq">freq</code></td>
<td>
<p>Positive integer representing the frequency of the sampled values being printed</p>
</td></tr>
<tr><td><code id="mcmc_mix2_+3A_invt">invt</code></td>
<td>
<p>Vector of the inverse temperatures for Metropolis-coupled MCMC</p>
</td></tr>
<tr><td><code id="mcmc_mix2_+3A_mc3_or_marg">mc3_or_marg</code></td>
<td>
<p>Boolean, is invt for parallel tempering / Metropolis-coupled MCMC (TRUE, default) or marginal likelihood via power posterior (FALSE)?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the MCMC, a componentwise Metropolis-Hastings algorithm is used. The threshold u is treated as a parameter and therefore sampled. The hyperparameters are used in the following priors: u is such that the implied unique exceedance probability psiu ~ Uniform(a_psi, b_psi); alpha ~ Normal(mean = a_alpha, sd = b_alpha); theta ~ Beta(a_theta, b_theta); shape ~ Normal(mean = m_shape, sd = s_shape); sigma ~ Gamma(a_sigma, scale = b_sigma). If pr_power = 1.0, the discrete power law (below u) is assumed, and the samples of theta will be all 1.0. If pr_power is in (0.0, 1.0), model selection between the polylog distribution and the discrete power law will be performed within the MCMC.
</p>


<h3>Value</h3>

<p>A list: $pars is a data frame of iter rows of the MCMC samples, $fitted is a data frame of length(x) rows with the fitted values, amongst other quantities related to the MCMC
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcmc_pol">mcmc_pol</a></code> and <code><a href="#topic+mcmc_mix3">mcmc_mix3</a></code> for MCMC for the Zipf-polylog and 3-component discrete extreme value mixture distributions, respectively.
</p>

<hr>
<h2 id='mcmc_mix2_wrapper'>Wrapper of mcmc_mix2</h2><span id='topic+mcmc_mix2_wrapper'></span>

<h3>Description</h3>

<p>Wrapper of mcmc_mix2
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc_mix2_wrapper(
  df,
  seed,
  a_psiu = 0.001,
  b_psiu = 0.9,
  m_alpha = 0,
  s_alpha = 10,
  a_theta = 1,
  b_theta = 1,
  m_shape = 0,
  s_shape = 10,
  a_sigma = 1,
  b_sigma = 0.01,
  a_pseudo = 10,
  b_pseudo = 1,
  pr_power = 0.5,
  positive = FALSE,
  iter = 20000L,
  thin = 20L,
  burn = 100000L,
  freq = 1000L,
  invts = 0.001^((0:8)/8),
  mc3_or_marg = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmc_mix2_wrapper_+3A_df">df</code></td>
<td>
<p>A data frame with at least two columns, x &amp; count</p>
</td></tr>
<tr><td><code id="mcmc_mix2_wrapper_+3A_seed">seed</code></td>
<td>
<p>Integer for <code>set.seed</code></p>
</td></tr>
<tr><td><code id="mcmc_mix2_wrapper_+3A_a_psiu">a_psiu</code>, <code id="mcmc_mix2_wrapper_+3A_b_psiu">b_psiu</code>, <code id="mcmc_mix2_wrapper_+3A_m_alpha">m_alpha</code>, <code id="mcmc_mix2_wrapper_+3A_s_alpha">s_alpha</code>, <code id="mcmc_mix2_wrapper_+3A_a_theta">a_theta</code>, <code id="mcmc_mix2_wrapper_+3A_b_theta">b_theta</code>, <code id="mcmc_mix2_wrapper_+3A_m_shape">m_shape</code>, <code id="mcmc_mix2_wrapper_+3A_s_shape">s_shape</code>, <code id="mcmc_mix2_wrapper_+3A_a_sigma">a_sigma</code>, <code id="mcmc_mix2_wrapper_+3A_b_sigma">b_sigma</code></td>
<td>
<p>Scalars, real numbers representing the hyperparameters of the prior distributions for the respective parameters. See details for the specification of the priors.</p>
</td></tr>
<tr><td><code id="mcmc_mix2_wrapper_+3A_a_pseudo">a_pseudo</code></td>
<td>
<p>Positive real number, first parameter of the pseudoprior beta distribution for theta in model selection; ignored if pr_power = 1.0</p>
</td></tr>
<tr><td><code id="mcmc_mix2_wrapper_+3A_b_pseudo">b_pseudo</code></td>
<td>
<p>Positive real number, second parameter of the pseudoprior beta distribution for theta in model selection; ignored if pr_power = 1.0</p>
</td></tr>
<tr><td><code id="mcmc_mix2_wrapper_+3A_pr_power">pr_power</code></td>
<td>
<p>Real number in [0, 1], prior probability of the discrete power law (below u)</p>
</td></tr>
<tr><td><code id="mcmc_mix2_wrapper_+3A_positive">positive</code></td>
<td>
<p>Boolean, is alpha positive (TRUE) or unbounded (FALSE)?</p>
</td></tr>
<tr><td><code id="mcmc_mix2_wrapper_+3A_iter">iter</code></td>
<td>
<p>Positive integer representing the length of the MCMC output</p>
</td></tr>
<tr><td><code id="mcmc_mix2_wrapper_+3A_thin">thin</code></td>
<td>
<p>Positive integer representing the thinning in the MCMC</p>
</td></tr>
<tr><td><code id="mcmc_mix2_wrapper_+3A_burn">burn</code></td>
<td>
<p>Non-negative integer representing the burn-in of the MCMC</p>
</td></tr>
<tr><td><code id="mcmc_mix2_wrapper_+3A_freq">freq</code></td>
<td>
<p>Positive integer representing the frequency of the sampled values being printed</p>
</td></tr>
<tr><td><code id="mcmc_mix2_wrapper_+3A_invts">invts</code></td>
<td>
<p>Vector of the inverse temperatures for Metropolis-coupled MCMC (if mc3_or_marg = TRUE) or power posterior (if mc3_or_marg = FALSE)</p>
</td></tr>
<tr><td><code id="mcmc_mix2_wrapper_+3A_mc3_or_marg">mc3_or_marg</code></td>
<td>
<p>Boolean, is Metropolis-coupled MCMC to be used? Ignored if invts = c(1.0)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list returned by <code>mcmc_mix2</code>
</p>

<hr>
<h2 id='mcmc_mix3'>Markov chain Monte Carlo for 3-component discrete extreme value mixture distribution</h2><span id='topic+mcmc_mix3'></span>

<h3>Description</h3>

<p><code>mcmc_mix3</code> returns the posterior samples of the parameters, for fitting the 3-component discrete extreme value mixture distribution. The samples are obtained using Markov chain Monte Carlo (MCMC).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc_mix3(
  x,
  count,
  v_set,
  u_set,
  v,
  u,
  alpha1,
  theta1,
  alpha2,
  theta2,
  shape,
  sigma,
  a_psi1,
  a_psi2,
  a_psiu,
  b_psiu,
  a_alpha1,
  b_alpha1,
  a_theta1,
  b_theta1,
  a_alpha2,
  b_alpha2,
  a_theta2,
  b_theta2,
  m_shape,
  s_shape,
  a_sigma,
  b_sigma,
  powerlaw1,
  positive1,
  positive2,
  a_pseudo,
  b_pseudo,
  pr_power2,
  iter,
  thin,
  burn,
  freq,
  invt,
  mc3_or_marg = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmc_mix3_+3A_x">x</code></td>
<td>
<p>Vector of the unique values (positive integers) of the data</p>
</td></tr>
<tr><td><code id="mcmc_mix3_+3A_count">count</code></td>
<td>
<p>Vector of the same length as x that contains the counts of each unique value in the full data, which is essentially rep(x, count)</p>
</td></tr>
<tr><td><code id="mcmc_mix3_+3A_v_set">v_set</code></td>
<td>
<p>Positive integer vector of the values v will be sampled from</p>
</td></tr>
<tr><td><code id="mcmc_mix3_+3A_u_set">u_set</code></td>
<td>
<p>Positive integer vector of the values u will be sampled from</p>
</td></tr>
<tr><td><code id="mcmc_mix3_+3A_v">v</code></td>
<td>
<p>Positive integer, initial value of the lower threshold</p>
</td></tr>
<tr><td><code id="mcmc_mix3_+3A_u">u</code></td>
<td>
<p>Positive integer, initial value of the upper threshold</p>
</td></tr>
<tr><td><code id="mcmc_mix3_+3A_alpha1">alpha1</code></td>
<td>
<p>Real number greater than 1, initial value of the parameter</p>
</td></tr>
<tr><td><code id="mcmc_mix3_+3A_theta1">theta1</code></td>
<td>
<p>Real number in (0, 1], initial value of the parameter</p>
</td></tr>
<tr><td><code id="mcmc_mix3_+3A_alpha2">alpha2</code></td>
<td>
<p>Real number greater than 1, initial value of the parameter</p>
</td></tr>
<tr><td><code id="mcmc_mix3_+3A_theta2">theta2</code></td>
<td>
<p>Real number in (0, 1], initial value of the parameter</p>
</td></tr>
<tr><td><code id="mcmc_mix3_+3A_shape">shape</code></td>
<td>
<p>Real number, initial value of the parameter</p>
</td></tr>
<tr><td><code id="mcmc_mix3_+3A_sigma">sigma</code></td>
<td>
<p>Positive real number, initial value of the parameter</p>
</td></tr>
<tr><td><code id="mcmc_mix3_+3A_a_psi1">a_psi1</code>, <code id="mcmc_mix3_+3A_a_psi2">a_psi2</code>, <code id="mcmc_mix3_+3A_a_psiu">a_psiu</code>, <code id="mcmc_mix3_+3A_b_psiu">b_psiu</code>, <code id="mcmc_mix3_+3A_a_alpha1">a_alpha1</code>, <code id="mcmc_mix3_+3A_b_alpha1">b_alpha1</code>, <code id="mcmc_mix3_+3A_a_theta1">a_theta1</code>, <code id="mcmc_mix3_+3A_b_theta1">b_theta1</code>, <code id="mcmc_mix3_+3A_a_alpha2">a_alpha2</code>, <code id="mcmc_mix3_+3A_b_alpha2">b_alpha2</code>, <code id="mcmc_mix3_+3A_a_theta2">a_theta2</code>, <code id="mcmc_mix3_+3A_b_theta2">b_theta2</code>, <code id="mcmc_mix3_+3A_m_shape">m_shape</code>, <code id="mcmc_mix3_+3A_s_shape">s_shape</code>, <code id="mcmc_mix3_+3A_a_sigma">a_sigma</code>, <code id="mcmc_mix3_+3A_b_sigma">b_sigma</code></td>
<td>
<p>Scalars, real numbers representing the hyperparameters of the prior distributions for the respective parameters. See details for the specification of the priors.</p>
</td></tr>
<tr><td><code id="mcmc_mix3_+3A_powerlaw1">powerlaw1</code></td>
<td>
<p>Boolean, is the discrete power law assumed for below v?</p>
</td></tr>
<tr><td><code id="mcmc_mix3_+3A_positive1">positive1</code></td>
<td>
<p>Boolean, is alpha1 positive (TRUE) or unbounded (FALSE)?</p>
</td></tr>
<tr><td><code id="mcmc_mix3_+3A_positive2">positive2</code></td>
<td>
<p>Boolean, is alpha2 positive (TRUE) or unbounded (FALSE)?</p>
</td></tr>
<tr><td><code id="mcmc_mix3_+3A_a_pseudo">a_pseudo</code></td>
<td>
<p>Positive real number, first parameter of the pseudoprior beta distribution for theta2 in model selection; ignored if pr_power2 = 1.0</p>
</td></tr>
<tr><td><code id="mcmc_mix3_+3A_b_pseudo">b_pseudo</code></td>
<td>
<p>Positive real number, second parameter of the pseudoprior beta distribution for theta2 in model selection; ignored if pr_power2 = 1.0</p>
</td></tr>
<tr><td><code id="mcmc_mix3_+3A_pr_power2">pr_power2</code></td>
<td>
<p>Real number in [0, 1], prior probability of the discrete power law (between v and u)</p>
</td></tr>
<tr><td><code id="mcmc_mix3_+3A_iter">iter</code></td>
<td>
<p>Positive integer representing the length of the MCMC output</p>
</td></tr>
<tr><td><code id="mcmc_mix3_+3A_thin">thin</code></td>
<td>
<p>Positive integer representing the thinning in the MCMC</p>
</td></tr>
<tr><td><code id="mcmc_mix3_+3A_burn">burn</code></td>
<td>
<p>Non-negative integer representing the burn-in of the MCMC</p>
</td></tr>
<tr><td><code id="mcmc_mix3_+3A_freq">freq</code></td>
<td>
<p>Positive integer representing the frequency of the sampled values being printed</p>
</td></tr>
<tr><td><code id="mcmc_mix3_+3A_invt">invt</code></td>
<td>
<p>Vector of the inverse temperatures for Metropolis-coupled MCMC</p>
</td></tr>
<tr><td><code id="mcmc_mix3_+3A_mc3_or_marg">mc3_or_marg</code></td>
<td>
<p>Boolean, is invt for parallel tempering / Metropolis-coupled MCMC (TRUE, default) or marginal likelihood via power posterior (FALSE)?</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the MCMC, a componentwise Metropolis-Hastings algorithm is used. The thresholds v and u are treated as parameters and therefore sampled. The hyperparameters are used in the following priors: psi1 / (1.0 - psiu) ~ Beta(a_psi1, a_psi2); u is such that the implied unique exceedance probability psiu ~ Uniform(a_psi, b_psi); alpha1 ~ Normal(mean = a_alpha1, sd = b_alpha1); theta1 ~ Beta(a_theta1, b_theta1); alpha2 ~ Normal(mean = a_alpha2, sd = b_alpha2); theta2 ~ Beta(a_theta2, b_theta2); shape ~ Normal(mean = m_shape, sd = s_shape); sigma ~ Gamma(a_sigma, scale = b_sigma). If pr_power2 = 1.0, the discrete power law (between v and u) is assumed, and the samples of theta2 will be all 1.0. If pr_power2 is in (0.0, 1.0), model selection between the polylog distribution and the discrete power law will be performed within the MCMC.
</p>


<h3>Value</h3>

<p>A list: $pars is a data frame of iter rows of the MCMC samples, $fitted is a data frame of length(x) rows with the fitted values, amongst other quantities related to the MCMC
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcmc_pol">mcmc_pol</a></code> and <code><a href="#topic+mcmc_mix2">mcmc_mix2</a></code> for MCMC for the Zipf-polylog and 2-component discrete extreme value mixture distributions, respectively.
</p>

<hr>
<h2 id='mcmc_mix3_wrapper'>Wrapper of mcmc_mix3</h2><span id='topic+mcmc_mix3_wrapper'></span>

<h3>Description</h3>

<p>Wrapper of mcmc_mix3
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc_mix3_wrapper(
  df,
  seed,
  a_psi1 = 1,
  a_psi2 = 1,
  a_psiu = 0.001,
  b_psiu = 0.9,
  m_alpha = 0,
  s_alpha = 10,
  a_theta = 1,
  b_theta = 1,
  m_shape = 0,
  s_shape = 10,
  a_sigma = 1,
  b_sigma = 0.01,
  a_pseudo = 10,
  b_pseudo = 1,
  pr_power2 = 0.5,
  powerlaw1 = FALSE,
  positive1 = FALSE,
  positive2 = TRUE,
  iter = 20000L,
  thin = 20L,
  burn = 100000L,
  freq = 1000L,
  invts = 0.001^((0:8)/8),
  mc3_or_marg = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmc_mix3_wrapper_+3A_df">df</code></td>
<td>
<p>A data frame with at least two columns, x &amp; count</p>
</td></tr>
<tr><td><code id="mcmc_mix3_wrapper_+3A_seed">seed</code></td>
<td>
<p>Integer for <code>set.seed</code></p>
</td></tr>
<tr><td><code id="mcmc_mix3_wrapper_+3A_a_psi1">a_psi1</code>, <code id="mcmc_mix3_wrapper_+3A_a_psi2">a_psi2</code>, <code id="mcmc_mix3_wrapper_+3A_a_psiu">a_psiu</code>, <code id="mcmc_mix3_wrapper_+3A_b_psiu">b_psiu</code>, <code id="mcmc_mix3_wrapper_+3A_m_alpha">m_alpha</code>, <code id="mcmc_mix3_wrapper_+3A_s_alpha">s_alpha</code>, <code id="mcmc_mix3_wrapper_+3A_a_theta">a_theta</code>, <code id="mcmc_mix3_wrapper_+3A_b_theta">b_theta</code>, <code id="mcmc_mix3_wrapper_+3A_m_shape">m_shape</code>, <code id="mcmc_mix3_wrapper_+3A_s_shape">s_shape</code>, <code id="mcmc_mix3_wrapper_+3A_a_sigma">a_sigma</code>, <code id="mcmc_mix3_wrapper_+3A_b_sigma">b_sigma</code></td>
<td>
<p>Scalars, real numbers representing the hyperparameters of the prior distributions for the respective parameters. See details for the specification of the priors.</p>
</td></tr>
<tr><td><code id="mcmc_mix3_wrapper_+3A_a_pseudo">a_pseudo</code></td>
<td>
<p>Positive real number, first parameter of the pseudoprior beta distribution for theta2 in model selection; ignored if pr_power2 = 1.0</p>
</td></tr>
<tr><td><code id="mcmc_mix3_wrapper_+3A_b_pseudo">b_pseudo</code></td>
<td>
<p>Positive real number, second parameter of the pseudoprior beta distribution for theta2 in model selection; ignored if pr_power2 = 1.0</p>
</td></tr>
<tr><td><code id="mcmc_mix3_wrapper_+3A_pr_power2">pr_power2</code></td>
<td>
<p>Real number in [0, 1], prior probability of the discrete power law (between v and u)</p>
</td></tr>
<tr><td><code id="mcmc_mix3_wrapper_+3A_powerlaw1">powerlaw1</code></td>
<td>
<p>Boolean, is the discrete power law assumed for below v?</p>
</td></tr>
<tr><td><code id="mcmc_mix3_wrapper_+3A_positive1">positive1</code></td>
<td>
<p>Boolean, is alpha1 positive (TRUE) or unbounded (FALSE)?</p>
</td></tr>
<tr><td><code id="mcmc_mix3_wrapper_+3A_positive2">positive2</code></td>
<td>
<p>Boolean, is alpha2 positive (TRUE) or unbounded (FALSE)?</p>
</td></tr>
<tr><td><code id="mcmc_mix3_wrapper_+3A_iter">iter</code></td>
<td>
<p>Positive integer representing the length of the MCMC output</p>
</td></tr>
<tr><td><code id="mcmc_mix3_wrapper_+3A_thin">thin</code></td>
<td>
<p>Positive integer representing the thinning in the MCMC</p>
</td></tr>
<tr><td><code id="mcmc_mix3_wrapper_+3A_burn">burn</code></td>
<td>
<p>Non-negative integer representing the burn-in of the MCMC</p>
</td></tr>
<tr><td><code id="mcmc_mix3_wrapper_+3A_freq">freq</code></td>
<td>
<p>Positive integer representing the frequency of the sampled values being printed</p>
</td></tr>
<tr><td><code id="mcmc_mix3_wrapper_+3A_invts">invts</code></td>
<td>
<p>Vector of the inverse temperatures for Metropolis-coupled MCMC (if mc3_or_marg = TRUE) or power posterior (if mc3_or_marg = FALSE)</p>
</td></tr>
<tr><td><code id="mcmc_mix3_wrapper_+3A_mc3_or_marg">mc3_or_marg</code></td>
<td>
<p>Boolean, is Metropolis-coupled MCMC to be used? Ignored if invts = c(1.0)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list returned by <code>mcmc_mix3</code>
</p>

<hr>
<h2 id='mcmc_pol'>Markov chain Monte Carlo for Zipf-polylog distribution</h2><span id='topic+mcmc_pol'></span>

<h3>Description</h3>

<p><code>mcmc_pol</code> returns the samples from the posterior of alpha and theta, for fitting the Zipf-polylog distribution to the data x. The samples are obtained using Markov chain Monte Carlo (MCMC). In the MCMC, a Metropolis-Hastings algorithm is used.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc_pol(
  x,
  count,
  alpha,
  theta,
  a_alpha,
  b_alpha,
  a_theta,
  b_theta,
  a_pseudo,
  b_pseudo,
  pr_power,
  iter,
  thin,
  burn,
  freq,
  invt,
  mc3_or_marg,
  xmax
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmc_pol_+3A_x">x</code></td>
<td>
<p>Vector of the unique values (positive integers) of the data</p>
</td></tr>
<tr><td><code id="mcmc_pol_+3A_count">count</code></td>
<td>
<p>Vector of the same length as x that contains the counts of each unique value in the full data, which is essentially rep(x, count)</p>
</td></tr>
<tr><td><code id="mcmc_pol_+3A_alpha">alpha</code></td>
<td>
<p>Real number greater than 1, initial value of the parameter</p>
</td></tr>
<tr><td><code id="mcmc_pol_+3A_theta">theta</code></td>
<td>
<p>Real number in (0, 1], initial value of the parameter</p>
</td></tr>
<tr><td><code id="mcmc_pol_+3A_a_alpha">a_alpha</code></td>
<td>
<p>Real number, mean of the prior normal distribution for alpha</p>
</td></tr>
<tr><td><code id="mcmc_pol_+3A_b_alpha">b_alpha</code></td>
<td>
<p>Positive real number, standard deviation of the prior normal distribution for alpha</p>
</td></tr>
<tr><td><code id="mcmc_pol_+3A_a_theta">a_theta</code></td>
<td>
<p>Positive real number, first parameter of the prior beta distribution for theta; ignored if pr_power = 1.0</p>
</td></tr>
<tr><td><code id="mcmc_pol_+3A_b_theta">b_theta</code></td>
<td>
<p>Positive real number, second parameter of the prior beta distribution for theta; ignored if pr_power = 1.0</p>
</td></tr>
<tr><td><code id="mcmc_pol_+3A_a_pseudo">a_pseudo</code></td>
<td>
<p>Positive real number, first parameter of the pseudoprior beta distribution for theta in model selection; ignored if pr_power = 1.0</p>
</td></tr>
<tr><td><code id="mcmc_pol_+3A_b_pseudo">b_pseudo</code></td>
<td>
<p>Positive real number, second parameter of the pseudoprior beta distribution for theta in model selection; ignored if pr_power = 1.0</p>
</td></tr>
<tr><td><code id="mcmc_pol_+3A_pr_power">pr_power</code></td>
<td>
<p>Real number in [0, 1], prior probability of the discrete power law</p>
</td></tr>
<tr><td><code id="mcmc_pol_+3A_iter">iter</code></td>
<td>
<p>Positive integer representing the length of the MCMC output</p>
</td></tr>
<tr><td><code id="mcmc_pol_+3A_thin">thin</code></td>
<td>
<p>Positive integer representing the thinning in the MCMC</p>
</td></tr>
<tr><td><code id="mcmc_pol_+3A_burn">burn</code></td>
<td>
<p>Non-negative integer representing the burn-in of the MCMC</p>
</td></tr>
<tr><td><code id="mcmc_pol_+3A_freq">freq</code></td>
<td>
<p>Positive integer representing the frequency of the sampled values being printed</p>
</td></tr>
<tr><td><code id="mcmc_pol_+3A_invt">invt</code></td>
<td>
<p>Vector of the inverse temperatures for Metropolis-coupled MCMC</p>
</td></tr>
<tr><td><code id="mcmc_pol_+3A_mc3_or_marg">mc3_or_marg</code></td>
<td>
<p>Boolean, is invt for parallel tempering / Metropolis-coupled MCMC (TRUE, default) or marginal likelihood via power posterior (FALSE)?</p>
</td></tr>
<tr><td><code id="mcmc_pol_+3A_xmax">xmax</code></td>
<td>
<p>Scalar, positive integer limit for computing the normalising constant</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list: $pars is a data frame of iter rows of the MCMC samples, $fitted is a data frame of length(x) rows with the fitted values, amongst other quantities related to the MCMC
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcmc_mix2">mcmc_mix2</a></code> and <code><a href="#topic+mcmc_mix3">mcmc_mix3</a></code> for MCMC for the 2-component and 3-component discrete extreme value mixture distributions, respectively.
</p>

<hr>
<h2 id='mcmc_pol_wrapper'>Wrapper of mcmc_pol</h2><span id='topic+mcmc_pol_wrapper'></span>

<h3>Description</h3>

<p>Wrapper of mcmc_pol
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mcmc_pol_wrapper(
  df,
  seed,
  alpha_init = 1.5,
  theta_init = 0.5,
  m_alpha = 0,
  s_alpha = 10,
  a_theta = 1,
  b_theta = 1,
  a_pseudo = 10,
  b_pseudo = 1,
  pr_power = 0.5,
  iter = 20000L,
  thin = 20L,
  burn = 100000L,
  freq = 1000L,
  invts = 0.001^((0:8)/8),
  mc3_or_marg = TRUE,
  xmax = 1e+05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mcmc_pol_wrapper_+3A_df">df</code></td>
<td>
<p>A data frame with at least two columns, x &amp; count</p>
</td></tr>
<tr><td><code id="mcmc_pol_wrapper_+3A_seed">seed</code></td>
<td>
<p>Integer for <code>set.seed</code></p>
</td></tr>
<tr><td><code id="mcmc_pol_wrapper_+3A_alpha_init">alpha_init</code></td>
<td>
<p>Real number greater than 1, initial value of the parameter</p>
</td></tr>
<tr><td><code id="mcmc_pol_wrapper_+3A_theta_init">theta_init</code></td>
<td>
<p>Real number in (0, 1], initial value of the parameter</p>
</td></tr>
<tr><td><code id="mcmc_pol_wrapper_+3A_m_alpha">m_alpha</code></td>
<td>
<p>Real number, mean of the prior normal distribution for alpha</p>
</td></tr>
<tr><td><code id="mcmc_pol_wrapper_+3A_s_alpha">s_alpha</code></td>
<td>
<p>Positive real number, standard deviation of the prior normal distribution for alpha</p>
</td></tr>
<tr><td><code id="mcmc_pol_wrapper_+3A_a_theta">a_theta</code></td>
<td>
<p>Positive real number, first parameter of the prior beta distribution for theta; ignored if pr_power = 1.0</p>
</td></tr>
<tr><td><code id="mcmc_pol_wrapper_+3A_b_theta">b_theta</code></td>
<td>
<p>Positive real number, second parameter of the prior beta distribution for theta; ignored if pr_power = 1.0</p>
</td></tr>
<tr><td><code id="mcmc_pol_wrapper_+3A_a_pseudo">a_pseudo</code></td>
<td>
<p>Positive real number, first parameter of the pseudoprior beta distribution for theta in model selection; ignored if pr_power = 1.0</p>
</td></tr>
<tr><td><code id="mcmc_pol_wrapper_+3A_b_pseudo">b_pseudo</code></td>
<td>
<p>Positive real number, second parameter of the pseudoprior beta distribution for theta in model selection; ignored if pr_power = 1.0</p>
</td></tr>
<tr><td><code id="mcmc_pol_wrapper_+3A_pr_power">pr_power</code></td>
<td>
<p>Real number in [0, 1], prior probability of the discrete power law</p>
</td></tr>
<tr><td><code id="mcmc_pol_wrapper_+3A_iter">iter</code></td>
<td>
<p>Positive integer representing the length of the MCMC output</p>
</td></tr>
<tr><td><code id="mcmc_pol_wrapper_+3A_thin">thin</code></td>
<td>
<p>Positive integer representing the thinning in the MCMC</p>
</td></tr>
<tr><td><code id="mcmc_pol_wrapper_+3A_burn">burn</code></td>
<td>
<p>Non-negative integer representing the burn-in of the MCMC</p>
</td></tr>
<tr><td><code id="mcmc_pol_wrapper_+3A_freq">freq</code></td>
<td>
<p>Positive integer representing the frequency of the sampled values being printed</p>
</td></tr>
<tr><td><code id="mcmc_pol_wrapper_+3A_invts">invts</code></td>
<td>
<p>Vector of the inverse temperatures for Metropolis-coupled MCMC (if mc3_or_marg = TRUE) or power posterior (if mc3_or_marg = FALSE)</p>
</td></tr>
<tr><td><code id="mcmc_pol_wrapper_+3A_mc3_or_marg">mc3_or_marg</code></td>
<td>
<p>Boolean, is Metropolis-coupled MCMC to be used? Ignored if invts = c(1.0)</p>
</td></tr>
<tr><td><code id="mcmc_pol_wrapper_+3A_xmax">xmax</code></td>
<td>
<p>Scalar (default 100000), positive integer limit for computing the normalising constant</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list returned by <code>mcmc_pol</code>
</p>

<hr>
<h2 id='obtain_u_set_mix1'>Obtain set of thresholds with high posterior density for the TZP-power-law mixture model</h2><span id='topic+obtain_u_set_mix1'></span>

<h3>Description</h3>

<p><code>obtain_u_set_mix1</code> computes the profile posterior density of the threshold u, and subsets the thresholds (and other parameter values) with high profile values i.e. within a certain value from the maximum posterior density. The set of u can then be used for <code><a href="#topic+mcmc_mix1">mcmc_mix1</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obtain_u_set_mix1(
  df,
  positive = FALSE,
  u_max = 2000L,
  log_diff_max = 11,
  alpha1_init = 0.01,
  theta1_init = exp(-1),
  alpha2_init = 2,
  a_psiu = 0.1,
  b_psiu = 0.9,
  m_alpha1 = 0,
  s_alpha1 = 10,
  a_theta1 = 1,
  b_theta1 = 1,
  m_alpha2 = 0,
  s_alpha2 = 10,
  xmax = 1e+05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obtain_u_set_mix1_+3A_df">df</code></td>
<td>
<p>A data frame with at least two columns, x &amp; count</p>
</td></tr>
<tr><td><code id="obtain_u_set_mix1_+3A_positive">positive</code></td>
<td>
<p>Boolean, is alpha1 positive (TRUE) or unbounded (FALSE, default)?</p>
</td></tr>
<tr><td><code id="obtain_u_set_mix1_+3A_u_max">u_max</code></td>
<td>
<p>Positive integer for the maximum threshold</p>
</td></tr>
<tr><td><code id="obtain_u_set_mix1_+3A_log_diff_max">log_diff_max</code></td>
<td>
<p>Positive real number, the value such that thresholds with profile posterior density not less than the maximum posterior density - <code>log_diff_max</code> will be kept</p>
</td></tr>
<tr><td><code id="obtain_u_set_mix1_+3A_alpha1_init">alpha1_init</code></td>
<td>
<p>Scalar, initial value of alpha1</p>
</td></tr>
<tr><td><code id="obtain_u_set_mix1_+3A_theta1_init">theta1_init</code></td>
<td>
<p>Scalar, initial value of theta1</p>
</td></tr>
<tr><td><code id="obtain_u_set_mix1_+3A_alpha2_init">alpha2_init</code></td>
<td>
<p>Scalar, initial value of alpha2</p>
</td></tr>
<tr><td><code id="obtain_u_set_mix1_+3A_a_psiu">a_psiu</code>, <code id="obtain_u_set_mix1_+3A_b_psiu">b_psiu</code>, <code id="obtain_u_set_mix1_+3A_m_alpha1">m_alpha1</code>, <code id="obtain_u_set_mix1_+3A_s_alpha1">s_alpha1</code>, <code id="obtain_u_set_mix1_+3A_a_theta1">a_theta1</code>, <code id="obtain_u_set_mix1_+3A_b_theta1">b_theta1</code>, <code id="obtain_u_set_mix1_+3A_m_alpha2">m_alpha2</code>, <code id="obtain_u_set_mix1_+3A_s_alpha2">s_alpha2</code></td>
<td>
<p>Scalars, hyperparameters of the priors for the parameters</p>
</td></tr>
<tr><td><code id="obtain_u_set_mix1_+3A_xmax">xmax</code></td>
<td>
<p>Scalar (default 100000), positive integer limit for computing the normalising constant</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list: <code>u_set</code> is the vector of thresholds with high posterior density, <code>init</code> is the data frame with the maximum profile posterior density and associated parameter values, <code>profile</code> is the data frame with all thresholds with high posterior density and associated parameter values, <code>scalars</code> is the data frame with all arguments (except df)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcmc_mix1_wrapper">mcmc_mix1_wrapper</a></code> that wraps <code>obtain_u_set_mix1</code> and <code><a href="#topic+mcmc_mix1">mcmc_mix1</a></code>, <code><a href="#topic+obtain_u_set_mix2">obtain_u_set_mix2</a></code> for the equivalent function for the 2-component mixture model
</p>

<hr>
<h2 id='obtain_u_set_mix2'>Obtain set of thresholds with high posterior density for the 2-component mixture model</h2><span id='topic+obtain_u_set_mix2'></span>

<h3>Description</h3>

<p><code>obtain_u_set_mix2</code> computes the profile posterior density of the threshold u, and subsets the thresholds (and other parameter values) with high profile values i.e. within a certain value from the maximum posterior density. The set of u can then be used for <code><a href="#topic+mcmc_mix2">mcmc_mix2</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obtain_u_set_mix2(
  df,
  powerlaw = FALSE,
  positive = FALSE,
  u_max = 2000L,
  log_diff_max = 11,
  alpha_init = 0.01,
  theta_init = exp(-1),
  shape_init = 0.1,
  sigma_init = 1,
  a_psiu = 0.001,
  b_psiu = 0.9,
  m_alpha = 0,
  s_alpha = 10,
  a_theta = 1,
  b_theta = 1,
  m_shape = 0,
  s_shape = 10,
  a_sigma = 1,
  b_sigma = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obtain_u_set_mix2_+3A_df">df</code></td>
<td>
<p>A data frame with at least two columns, x &amp; count</p>
</td></tr>
<tr><td><code id="obtain_u_set_mix2_+3A_powerlaw">powerlaw</code></td>
<td>
<p>Boolean, is the power law (TRUE) or polylogarithm (FALSE, default) assumed?</p>
</td></tr>
<tr><td><code id="obtain_u_set_mix2_+3A_positive">positive</code></td>
<td>
<p>Boolean, is alpha positive (TRUE) or unbounded (FALSE, default)?</p>
</td></tr>
<tr><td><code id="obtain_u_set_mix2_+3A_u_max">u_max</code></td>
<td>
<p>Positive integer for the maximum threshold</p>
</td></tr>
<tr><td><code id="obtain_u_set_mix2_+3A_log_diff_max">log_diff_max</code></td>
<td>
<p>Positive real number, the value such that thresholds with profile posterior density not less than the maximum posterior density - <code>log_diff_max</code> will be kept</p>
</td></tr>
<tr><td><code id="obtain_u_set_mix2_+3A_alpha_init">alpha_init</code></td>
<td>
<p>Scalar, initial value of alpha</p>
</td></tr>
<tr><td><code id="obtain_u_set_mix2_+3A_theta_init">theta_init</code></td>
<td>
<p>Scalar, initial value of theta</p>
</td></tr>
<tr><td><code id="obtain_u_set_mix2_+3A_shape_init">shape_init</code></td>
<td>
<p>Scalar, initial value of shape parameter</p>
</td></tr>
<tr><td><code id="obtain_u_set_mix2_+3A_sigma_init">sigma_init</code></td>
<td>
<p>Scalar, initial value of sigma</p>
</td></tr>
<tr><td><code id="obtain_u_set_mix2_+3A_a_psiu">a_psiu</code>, <code id="obtain_u_set_mix2_+3A_b_psiu">b_psiu</code>, <code id="obtain_u_set_mix2_+3A_m_alpha">m_alpha</code>, <code id="obtain_u_set_mix2_+3A_s_alpha">s_alpha</code>, <code id="obtain_u_set_mix2_+3A_a_theta">a_theta</code>, <code id="obtain_u_set_mix2_+3A_b_theta">b_theta</code>, <code id="obtain_u_set_mix2_+3A_m_shape">m_shape</code>, <code id="obtain_u_set_mix2_+3A_s_shape">s_shape</code>, <code id="obtain_u_set_mix2_+3A_a_sigma">a_sigma</code>, <code id="obtain_u_set_mix2_+3A_b_sigma">b_sigma</code></td>
<td>
<p>Scalars, hyperparameters of the priors for the parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list: <code>u_set</code> is the vector of thresholds with high posterior density, <code>init</code> is the data frame with the maximum profile posterior density and associated parameter values, <code>profile</code> is the data frame with all thresholds with high posterior density and associated parameter values, <code>scalars</code> is the data frame with all arguments (except df)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcmc_mix2_wrapper">mcmc_mix2_wrapper</a></code> that wraps <code>obtain_u_set_mix2</code> and <code><a href="#topic+mcmc_mix2">mcmc_mix2</a></code>, <code><a href="#topic+obtain_u_set_mix1">obtain_u_set_mix1</a></code> for the equivalent function for the TZP-power-law mixture model
</p>

<hr>
<h2 id='obtain_u_set_mix3'>Obtain set of thresholds with high posterior density for the 3-component mixture model</h2><span id='topic+obtain_u_set_mix3'></span>

<h3>Description</h3>

<p><code>obtain_u_set_mix3</code> computes the profile posterior density of the thresholds v &amp; u, and subsets the thresholds (and other parameter values) with high profile values i.e. within a certain value from the maximum posterior density. The sets of v &amp; u can then be used for <code><a href="#topic+mcmc_mix3">mcmc_mix3</a></code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obtain_u_set_mix3(
  df,
  powerlaw1 = FALSE,
  powerlaw2 = FALSE,
  positive1 = FALSE,
  positive2 = TRUE,
  log_diff_max = 11,
  v_max = 100L,
  u_max = 2000L,
  alpha_init = 0.01,
  theta_init = exp(-1),
  shape_init = 1,
  sigma_init = 1,
  a_psi1 = 1,
  a_psi2 = 1,
  a_psiu = 0.001,
  b_psiu = 0.9,
  m_alpha = 0,
  s_alpha = 10,
  a_theta = 1,
  b_theta = 1,
  m_shape = 0,
  s_shape = 10,
  a_sigma = 1,
  b_sigma = 0.01
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obtain_u_set_mix3_+3A_df">df</code></td>
<td>
<p>A data frame with at least two columns, degree &amp; count</p>
</td></tr>
<tr><td><code id="obtain_u_set_mix3_+3A_powerlaw1">powerlaw1</code></td>
<td>
<p>Boolean, is the power law (TRUE) or polylogarithm (FALSE, default) assumed for the left tail?</p>
</td></tr>
<tr><td><code id="obtain_u_set_mix3_+3A_powerlaw2">powerlaw2</code></td>
<td>
<p>Boolean, is the power law (TRUE) or polylogarithm (FALSE, default) assumed for the middle bulk?</p>
</td></tr>
<tr><td><code id="obtain_u_set_mix3_+3A_positive1">positive1</code></td>
<td>
<p>Boolean, is alpha positive (TRUE) or unbounded (FALSE, default) for the left tail?</p>
</td></tr>
<tr><td><code id="obtain_u_set_mix3_+3A_positive2">positive2</code></td>
<td>
<p>Boolean, is alpha positive (TRUE) or unbounded (FALSE, default) for the middle bulk?</p>
</td></tr>
<tr><td><code id="obtain_u_set_mix3_+3A_log_diff_max">log_diff_max</code></td>
<td>
<p>Positive real number, the value such that thresholds with profile posterior density not less than the maximum posterior density - <code>log_diff_max</code> will be kept</p>
</td></tr>
<tr><td><code id="obtain_u_set_mix3_+3A_v_max">v_max</code></td>
<td>
<p>Positive integer for the maximum lower threshold</p>
</td></tr>
<tr><td><code id="obtain_u_set_mix3_+3A_u_max">u_max</code></td>
<td>
<p>Positive integer for the maximum upper threshold</p>
</td></tr>
<tr><td><code id="obtain_u_set_mix3_+3A_alpha_init">alpha_init</code></td>
<td>
<p>Scalar, initial value of alpha</p>
</td></tr>
<tr><td><code id="obtain_u_set_mix3_+3A_theta_init">theta_init</code></td>
<td>
<p>Scalar, initial value of theta</p>
</td></tr>
<tr><td><code id="obtain_u_set_mix3_+3A_shape_init">shape_init</code></td>
<td>
<p>Scalar, initial value of shape parameter</p>
</td></tr>
<tr><td><code id="obtain_u_set_mix3_+3A_sigma_init">sigma_init</code></td>
<td>
<p>Scalar, initial value of sigma</p>
</td></tr>
<tr><td><code id="obtain_u_set_mix3_+3A_a_psi1">a_psi1</code>, <code id="obtain_u_set_mix3_+3A_a_psi2">a_psi2</code>, <code id="obtain_u_set_mix3_+3A_a_psiu">a_psiu</code>, <code id="obtain_u_set_mix3_+3A_b_psiu">b_psiu</code>, <code id="obtain_u_set_mix3_+3A_m_alpha">m_alpha</code>, <code id="obtain_u_set_mix3_+3A_s_alpha">s_alpha</code>, <code id="obtain_u_set_mix3_+3A_a_theta">a_theta</code>, <code id="obtain_u_set_mix3_+3A_b_theta">b_theta</code>, <code id="obtain_u_set_mix3_+3A_m_shape">m_shape</code>, <code id="obtain_u_set_mix3_+3A_s_shape">s_shape</code>, <code id="obtain_u_set_mix3_+3A_a_sigma">a_sigma</code>, <code id="obtain_u_set_mix3_+3A_b_sigma">b_sigma</code></td>
<td>
<p>Scalars, hyperparameters of the priors for the parameters</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list: <code>v_set</code> is the vector of lower thresholds with high posterior density, <code>u_set</code> is the vector of upper thresholds with high posterior density, <code>init</code> is the data frame with the maximum profile posterior density and associated parameter values, <code>profile</code> is the data frame with all thresholds with high posterior density and associated parameter values, <code>scalars</code> is the data frame with all arguments (except df)
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mcmc_mix3_wrapper">mcmc_mix3_wrapper</a></code> that wraps <code>obtain_u_set_mix3</code> and <code><a href="#topic+mcmc_mix3">mcmc_mix3</a></code>
</p>

<hr>
<h2 id='reshape_dep'>Reshape the data frame of dependencies</h2><span id='topic+reshape_dep'></span>

<h3>Description</h3>

<p>Reshape the data frame of dependencies
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reshape_dep(x, names)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reshape_dep_+3A_x">x</code></td>
<td>
<p>A character vector of dependencies, each element of which corresponds to an individual package</p>
</td></tr>
<tr><td><code id="reshape_dep_+3A_names">names</code></td>
<td>
<p>A character vector of package names of the same length as x</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame of dependencies
</p>

<hr>
<h2 id='Smix2'>Survival function of 2-component discrete extreme value mixture distribution</h2><span id='topic+Smix2'></span>

<h3>Description</h3>

<p><code>Smix2</code> returns the survival function at x for the 2-component discrete extreme value mixture distribution. The components below and above the threshold u are the (truncated) Zipf-polylog(alpha,theta) and the generalised Pareto(shape, sigma) distributions, respectively.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Smix2(x, u, alpha, theta, shape, sigma, phiu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Smix2_+3A_x">x</code></td>
<td>
<p>Vector of positive integers</p>
</td></tr>
<tr><td><code id="Smix2_+3A_u">u</code></td>
<td>
<p>Positive integer representing the threshold</p>
</td></tr>
<tr><td><code id="Smix2_+3A_alpha">alpha</code></td>
<td>
<p>Real number, first parameter of the Zipf-polylog component</p>
</td></tr>
<tr><td><code id="Smix2_+3A_theta">theta</code></td>
<td>
<p>Real number in (0, 1], second parameter of the Zipf-polylog component</p>
</td></tr>
<tr><td><code id="Smix2_+3A_shape">shape</code></td>
<td>
<p>Real number, shape parameter of the generalised Pareto component</p>
</td></tr>
<tr><td><code id="Smix2_+3A_sigma">sigma</code></td>
<td>
<p>Real number, scale parameter of the generalised Pareto component</p>
</td></tr>
<tr><td><code id="Smix2_+3A_phiu">phiu</code></td>
<td>
<p>Real number in (0, 1), exceedance rate of the threshold u</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the same length as x
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dmix2">dmix2</a></code> for the corresponding probability mass function, <code><a href="#topic+Spol">Spol</a></code> and <code><a href="#topic+Smix3">Smix3</a></code> for the survival functions of the Zipf-polylog and 3-component discrete extreme value mixture distributions, respectively.
</p>

<hr>
<h2 id='Smix3'>Survival function of 3-component discrete extreme value mixture distribution</h2><span id='topic+Smix3'></span>

<h3>Description</h3>

<p><code>Smix3</code> returns the survival function at x for the 3-component discrete extreme value mixture distribution. The component below v is the (truncated) Zipf-polylog(alpha1,theta1) distribution, between v &amp; u the (truncated) Zipf-polylog(alpha2,theta2) distribution, and above u the generalised Pareto(shape, sigma) distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Smix3(x, v, u, alpha1, theta1, alpha2, theta2, shape, sigma, phi1, phi2, phiu)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Smix3_+3A_x">x</code></td>
<td>
<p>Vector of positive integers</p>
</td></tr>
<tr><td><code id="Smix3_+3A_v">v</code></td>
<td>
<p>Positive integer representing the lower threshold</p>
</td></tr>
<tr><td><code id="Smix3_+3A_u">u</code></td>
<td>
<p>Positive integer representing the upper threshold</p>
</td></tr>
<tr><td><code id="Smix3_+3A_alpha1">alpha1</code></td>
<td>
<p>Real number, first parameter of the Zipf-polylog component below v</p>
</td></tr>
<tr><td><code id="Smix3_+3A_theta1">theta1</code></td>
<td>
<p>Real number in (0, 1], second parameter of the Zipf-polylog component below v</p>
</td></tr>
<tr><td><code id="Smix3_+3A_alpha2">alpha2</code></td>
<td>
<p>Real number, first parameter of the Zipf-polylog component between v &amp; u</p>
</td></tr>
<tr><td><code id="Smix3_+3A_theta2">theta2</code></td>
<td>
<p>Real number in (0, 1], second parameter of the Zipf-polylog component between v &amp; u</p>
</td></tr>
<tr><td><code id="Smix3_+3A_shape">shape</code></td>
<td>
<p>Real number, shape parameter of the generalised Pareto component</p>
</td></tr>
<tr><td><code id="Smix3_+3A_sigma">sigma</code></td>
<td>
<p>Real number, scale parameter of the generalised Pareto component</p>
</td></tr>
<tr><td><code id="Smix3_+3A_phi1">phi1</code></td>
<td>
<p>Real number in (0, 1), proportion of values below v</p>
</td></tr>
<tr><td><code id="Smix3_+3A_phi2">phi2</code></td>
<td>
<p>Real number in (0, 1), proportion of values between v &amp; u</p>
</td></tr>
<tr><td><code id="Smix3_+3A_phiu">phiu</code></td>
<td>
<p>Real number in (0, 1), exceedance rate of the threshold u</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the same length as x
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dmix3">dmix3</a></code> for the corresponding probability mass function, <code><a href="#topic+Spol">Spol</a></code> and <code><a href="#topic+Smix2">Smix2</a></code> for the survival functions of the Zipf-polylog and 2-component discrete extreme value mixture distributions, respectively.
</p>

<hr>
<h2 id='Spol'>Survival function of Zipf-polylog distribution</h2><span id='topic+Spol'></span>

<h3>Description</h3>

<p><code>Spol</code> returns the survival function at x for the Zipf-polylog distribution with parameters (alpha, theta). The distribution is reduced to the discrete power law when theta = 1.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>Spol(x, alpha, theta, xmax = 100000L)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="Spol_+3A_x">x</code></td>
<td>
<p>Vector of positive integers</p>
</td></tr>
<tr><td><code id="Spol_+3A_alpha">alpha</code></td>
<td>
<p>Real number greater than 1</p>
</td></tr>
<tr><td><code id="Spol_+3A_theta">theta</code></td>
<td>
<p>Real number in (0, 1]</p>
</td></tr>
<tr><td><code id="Spol_+3A_xmax">xmax</code></td>
<td>
<p>Scalar (default 100000), positive integer limit for computing the normalising constant</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric vector of the same length as x
</p>


<h3>See Also</h3>

<p><code><a href="#topic+dpol">dpol</a></code> for the corresponding probability mass function, <code><a href="#topic+Smix2">Smix2</a></code> and <code><a href="#topic+Smix3">Smix3</a></code> for the survival functions of the 2-component and 3-component discrete extreme value mixture distributions, respectively.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>Spol(c(1,2,3,4,5), 1.2, 0.5)
</code></pre>

<hr>
<h2 id='topo_sort_kahn'>Return a sorted vector of nodes id</h2><span id='topic+topo_sort_kahn'></span>

<h3>Description</h3>

<p>Return a sorted vector of nodes id
</p>


<h3>Usage</h3>

<pre><code class='language-R'>topo_sort_kahn(g, random = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="topo_sort_kahn_+3A_g">g</code></td>
<td>
<p>An igraph object of a DAG</p>
</td></tr>
<tr><td><code id="topo_sort_kahn_+3A_random">random</code></td>
<td>
<p>Boolean, whether the order of selected nodes is randomised in the process</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with two columns: &quot;id&quot; is the names of nodes in g, and &quot;id_num&quot; is the topological ordering
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df0 &lt;- data.frame(from = c("a", "b"), to = c("b", "c"), stringsAsFactors = FALSE)
g0 &lt;- igraph::graph_from_data_frame(df0, directed = TRUE)
topo_sort_kahn(g0)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
