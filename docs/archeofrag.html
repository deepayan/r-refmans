<!DOCTYPE html><html><head><title>Help for package archeofrag</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {archeofrag}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#archeofrag-package'><p>Archeofrag: Refitting and Spatial Analysis in Archaeology</p></a></li>
<li><a href='#frag.cycles'>
<p>Count the k-cycles in a graph, for cycles =&lt; k</p></a></li>
<li><a href='#frag.diameters'><p>Diameter distribution for unconnected graphs</p></a></li>
<li><a href='#frag.edges.weighting'><p>Weighting the edges of a fragmentation graph</p></a></li>
<li><a href='#frag.get.layers'>
<p>Extracts the subgraph of each selected stratigraphic layer.</p></a></li>
<li><a href='#frag.get.layers.pair'>
<p>Extracts the subgraph corresponding to a pair of stratigraphic layers.</p></a></li>
<li><a href='#frag.get.parameters'><p>Returns a series of descriptive statistics for a fragmentation graph</p></a></li>
<li><a href='#frag.graph.plot'><p>Plot a fragmentation graph</p></a></li>
<li><a href='#frag.layers.admixture'><p>Admixture of two stratigraphic layers</p></a></li>
<li><a href='#frag.layers.cohesion'><p>Cohesion measure of layers</p></a></li>
<li><a href='#Frag.object-class'><p>Class <code>"Frag.object"</code></p></a></li>
<li><a href='#frag.observer.failure'><p>Simulate the failure of an observer to determine the relationships between fragments.</p></a></li>
<li><a href='#frag.path.lengths'><p>Path length distribution for unconnected graphs</p></a></li>
<li><a href='#frag.relations.by.layers'>
<p>Summary of the connection relationships between fragments within and between spatial units.</p></a></li>
<li><a href='#frag.simul.compare'><p>From an observed fragmentation graph, simulates two series of graphs corresponding to two deposition hypotheses.</p></a></li>
<li><a href='#frag.simul.process'>
<p>Simulate the fragmentation of archaeological objects scattered in two stratigraphic layers</p></a></li>
<li><a href='#frag.simul.summarise'><p>Summarise the comparison between an observed fragmentation graph and simulated graphs for two deposition hypotheses.</p></a></li>
<li><a href='#LiangAbu'><p>Dataset: Archeological relationships between pottery fragments in Liang Abu</p></a></li>
<li><a href='#make_cr_graph'>
<p>Make a &quot;connection&quot; relationships graph.</p></a></li>
<li><a href='#make_crsr_graph'>
<p>Makes a &quot;connection&quot; relationships graph including the &quot;similarity&quot; relationships.</p></a></li>
<li><a href='#make_frag_object'>
<p>Makes a &quot;frag.object&quot; object.</p></a></li>
<li><a href='#make_sr_graph'>
<p>Make a &quot;similarity&quot; relationships graph.</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Refitting and Spatial Analysis in Archaeology</td>
</tr>
<tr>
<td>Version:</td>
<td>0.8.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2022-09-11</td>
</tr>
<tr>
<td>Author:</td>
<td>Sebastien Plutniak
    <a href="https://orcid.org/0000-0002-6674-3806"><img alt="ORCID iD"src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [aut, cre]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Sebastien Plutniak &lt;sebastien.plutniak@posteo.net&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Methods to analyse fragmented objects in archaeology using refitting relationships between fragments scattered in archaeological spatial units (e.g. stratigraphic layers). Graphs and graph theory are used to model archaeological observations. The package is mainly based on the 'igraph' package for graph analysis. Functions can: 1) create, manipulate, and simulate fragmentation graphs, 2) measure the cohesion and admixture of archaeological spatial units, and 3) characterise the topology of a specific set of refitting relationships. An empirical dataset is also provided as an example. Documentation about 'archeofrag' is provided by the vignette included in this package and by the accompanying scientific papers: Plutniak (2021, Journal of Archaeological Science, &lt;<a href="https://doi.org/10.1016%2Fj.jas.2021.105501">doi:10.1016/j.jas.2021.105501</a>&gt;) and Plutniak (2022, Journal of Open Source Software, &lt;<a href="https://doi.org/10.21105%2Fjoss.04335">doi:10.21105/joss.04335</a>&gt;).</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>Imports:</td>
<td>igraph, graphics, stats, grDevices, methods, utils</td>
</tr>
<tr>
<td>Suggests:</td>
<td>RBGL, knitr, covr, rmarkdown, markdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/sebastien-plutniak/archeofrag">https://github.com/sebastien-plutniak/archeofrag</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/sebastien-plutniak/archeofrag/issues">https://github.com/sebastien-plutniak/archeofrag/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-09-11 20:42:18 UTC; seb</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-09-11 22:02:59 UTC</td>
</tr>
</table>
<hr>
<h2 id='archeofrag-package'>Archeofrag: Refitting and Spatial Analysis in Archaeology</h2><span id='topic+archeofrag-package'></span><span id='topic+archeofrag'></span>

<h3>Description</h3>

<p>Methods to analyse fragmented objects in archeology using refitting relationships between fragments scattered in archeological spatial units (e.g. stratigraphic layers). Graphs and graph theory are used to model archeological observations. The package is mainly based on the 'igraph' package for graph analysis. Functions can: 1) create, manipulate, and simulate fragmentation graphs, 2) measure the cohesion and admixture of archeological spatial units, and 3) characterise the topology of a specific set of refitting relationships. An empirical dataset is also provided as an example.
</p>


<h3>Details</h3>


<table>
<tr>
 <td style="text-align: left;">
        Package: </td><td style="text-align: left;"> archeofrag</td>
</tr>
<tr>
 <td style="text-align: left;">
        Type: </td><td style="text-align: left;"> Package</td>
</tr>
<tr>
 <td style="text-align: left;">
        Version: </td><td style="text-align: left;"> 0.7</td>
</tr>
<tr>
 <td style="text-align: left;">
        Date: </td><td style="text-align: left;"> 2021-04-26</td>
</tr>
<tr>
 <td style="text-align: left;">
        License: </td><td style="text-align: left;"> GPL-2</td>
</tr>
<tr>
 <td style="text-align: left;">
    </td>
</tr>

</table>



<h3>Author(s)</h3>

<p>Sebastien Plutniak
Maintainer: Sebastien Plutniak &lt;sebastien.plutniak at posteo.net&gt;
</p>


<h3>See Also</h3>

<p><code><a href="igraph.html#topic+igraph-package">igraph</a></code>,
<code><a href="RBGL.html#topic+RBGL.overview">RBGL</a></code> 
</p>

<hr>
<h2 id='frag.cycles'>
Count the k-cycles in a graph, for cycles =&lt; k
</h2><span id='topic+frag.cycles'></span>

<h3>Description</h3>

<p>Count the k-cycles in a graph, for cycles =&lt; k
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frag.cycles(graph, kmax, max.cycles.only=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frag.cycles_+3A_graph">graph</code></td>
<td>
<p>An <code>igraph</code> object, must be an undirected graph.</p>
</td></tr>
<tr><td><code id="frag.cycles_+3A_kmax">kmax</code></td>
<td>
<p>Maximal length of the cycles to detect.</p>
</td></tr>
<tr><td><code id="frag.cycles_+3A_max.cycles.only">max.cycles.only</code></td>
<td>
<p>Logical. If TRUE, the fragments are only reported as parts of their longer cycle.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A cycle can be part of larger cycle: if <code>max.cycles.only</code> all the cycles are reported but, if this parameter is True only the larger cycles are reported.
A warning recalls that for cycles k &gt; 4 the fragments of a cycle are not necessarily all connected to each other (a fragment, due to its location in the original object, can only be connected to a limited number of adjacent fragments).
</p>


<h3>Value</h3>

<p>A data frame with the number of k-cycles for each k values in [3;k].
</p>


<h3>Author(s)</h3>

<p>Sebastien Plutniak &lt;sebastien.plutniak at posteo.net&gt;</p>


<h3>See Also</h3>

<p><code><a href="igraph.html#topic+subgraph_isomorphisms">subgraph_isomorphisms</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- frag.simul.process(n.components=20, vertices=50, disturbance=.15)
frag.cycles(g, kmax=4, max.cycles.only=FALSE)
frag.cycles(g, kmax=4, max.cycles.only=TRUE)
</code></pre>

<hr>
<h2 id='frag.diameters'>Diameter distribution for unconnected graphs</h2><span id='topic+frag.diameters'></span>

<h3>Description</h3>

<p>Returns the distribution of the diameter values of a fragmentation graph.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frag.diameters(graph, cumulative = FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frag.diameters_+3A_graph">graph</code></td>
<td>
<p>An <code>igraph</code> object.</p>
</td></tr>
<tr><td><code id="frag.diameters_+3A_cumulative">cumulative</code></td>
<td>
<p>Logical. If TRUE the cumulative relative frequency of the diameters is reported.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>frag.diameters</code> wraps the <code>igraph</code> <code>diameter</code> function.
For graphs representing the fragmentation of archeological objects, the diameter of each component of the graph (i.e. archeological objects) can be interpreted:
as a measure of the intensity of fragmentation (when all the fragments of the initial object are known);
as a measure of the scattering of the fragments (when not all the fragments are known);
</p>


<h3>Value</h3>

<p>A numeric vector of the length equal to the maximum diameter value found. The first element is the frequency of the diameter values = 1, the second element is the frequency of diameter values = 2, etc. If <code>cumulative</code> is True, the cumulative density is returned.
</p>


<h3>Author(s)</h3>

<p>Sebastien Plutniak &lt;sebastien.plutniak at posteo.net&gt;</p>


<h3>See Also</h3>

<p><code><a href="igraph.html#topic+diameter">diameter</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- frag.simul.process(n.components=20, vertices=50, disturbance=.15)
frag.diameters(g)
frag.diameters(g, cumulative=TRUE)

</code></pre>

<hr>
<h2 id='frag.edges.weighting'>Weighting the edges of a fragmentation graph</h2><span id='topic+frag.edges.weighting'></span>

<h3>Description</h3>

<p>Weighting of the edges of an archeofrag fragmentation graph.</p>


<h3>Usage</h3>

<pre><code class='language-R'>frag.edges.weighting(graph, layer.attr, morphometry, x, y, z)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frag.edges.weighting_+3A_graph">graph</code></td>
<td>
<p>An undirected <code>igraph</code> object.</p>
</td></tr> 
<tr><td><code id="frag.edges.weighting_+3A_layer.attr">layer.attr</code></td>
<td>
<p>Character. The name of the vertex attribute with the layer of the fragments.</p>
</td></tr>
<tr><td><code id="frag.edges.weighting_+3A_morphometry">morphometry</code></td>
<td>
<p>Character. Optional, the name of the vertex attribute with the morphometric value of the fragments.</p>
</td></tr>
<tr><td><code id="frag.edges.weighting_+3A_x">x</code></td>
<td>
<p>Character. Optional, the name of the vertex attribute with the &quot;x&quot; coordinate of the fragments.</p>
</td></tr>
<tr><td><code id="frag.edges.weighting_+3A_y">y</code></td>
<td>
<p>Character. Optional, the name of the vertex attribute with the &quot;y&quot; coordinate of the fragments.</p>
</td></tr>
<tr><td><code id="frag.edges.weighting_+3A_z">z</code></td>
<td>
<p>Character. Optional, the name of the vertex attribute with the &quot;z&quot; coordinate of the fragments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In the framework of the TSAR method, this function weights the edges of a fragmentation graph, before computing the cohesion and admixture values.
The weights are computed from the topological properties  of the connection network and can be modified using  the morphometric properties of the fragments and/or the spatial distance between them. In summary, three different parameters can be used:
</p>
<p>1. topology, the basic weighting method;
2. morphometry, the length, length by width, surface, volume, etc.
3. spatial distance, expressed using the metric (or other) system, or an ad hoc relative system.
</p>
<p>The function must be applied to a fragmentation graph with two layers.
Internal connection relationships (within a layer) and external relationships (between the two layers) are distinguished, and their respective edge weights are computed in different ways.
Three subgraphs are first generated, one for each layer and only one for the external relations.
</p>
<p>The weight of an intra-layer edge (E) is equal to the sum of the degrees (d) of the vertices (i and j) it connects: 
</p>
<p style="text-align: center;"><code class="reqn">W_{intra(E_{ij})} = d_i + d_j</code>
</p>

<p>For an inter-layer edge, the same calculation is made but with a modifier to account for the balance of information available for each layer:  
</p>
<p style="text-align: center;"><code class="reqn">W(E_inter{ij}) = (d_i + d_j) \times \left(3 - \frac{2}{ 1 + (tr_i + tr_j)/2}\right) \times \left(1 - \frac{1}{\sqrt{(V_{sub} + E_{sub}) }}\right)^2</code>
</p>

<p>with <code>trans_i</code> and <code>trans_i</code> the local transitivity of the vertices i and j, and <code>sqrt(V_sub + E_sub)</code> the square root of the sum of the vertices count and edge count of the sub-graph.
</p>
<p>If the <code>morphometry</code> and/or coordinates (<code>x</code>, <code>y</code>, <code>z</code>) parameters are provided, the previous formula is modified using a factor which is computed as:
</p>
<p style="text-align: center;"><code class="reqn">f(E_{ij}) =  1 - \left(\sqrt{  \frac{size_i + size_j}{max(sizes)} \times \sqrt{\frac{\frac{size_i}{size_j}}{max(prop)}} \times \frac{distance_{ij}}{max(distances)}}\ \right) </code>
</p>

<p>with <code>size_i</code> the morphometric value of the smaller fragment, <code>max(sizes)</code> the maximum sum of morphometric values observed for the pairs of connected fragments in the dataset under study; <code>max(prop)</code> the maximum proportion between the size values of connected fragments observed in the dataset under study; distance ij the spatial distance between fragments i and j; <code>max(distances)</code> the maximum euclidean distance observed for the pairs of connected fragments in the dataset under study.
Results of the morphometric-spatial factor range in ]0,1].
</p>
<p>Error messages are displayed if the vertex &quot;layer&quot; attribute has more than two layers, and a warning is displayed if one or more of the values for the x, y, z parameters do not exist in the input graph.
</p>


<h3>Value</h3>

<p>The graph, with an additional &quot;weight&quot; edge attribute and, if the distance has been computed, a &quot;distance&quot; edge attribute.
</p>


<h3>Author(s)</h3>

<p>Sebastien Plutniak &lt;sebastien.plutniak at posteo.net&gt;</p>


<h3>See Also</h3>

<p><code><a href="igraph.html#topic+transitivity">transitivity</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- frag.simul.process(n.components=20, vertices=50, disturbance=.15)
frag.edges.weighting(g , "layer")
# with morphometric and spatial parameters:
library(igraph)
V(g)$morpho &lt;- sample(1:20, 50, replace=TRUE)
V(g)$x &lt;- sample(1:100, 50, replace=TRUE)
V(g)$y &lt;- sample(1:100, 50, replace=TRUE)
V(g)$z &lt;- sample(1:100, 50, replace=TRUE)
frag.edges.weighting(g, "layer", "morpho", "x", "y", "z")
</code></pre>

<hr>
<h2 id='frag.get.layers'>
Extracts the subgraph of each selected stratigraphic layer.
</h2><span id='topic+frag.get.layers'></span>

<h3>Description</h3>

<p>Extracts the subgraph of each selected stratigraphic layer (or any other type of archaeological spatial unit).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frag.get.layers(graph, layer.attr, sel.layers)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frag.get.layers_+3A_graph">graph</code></td>
<td>
<p>An undirected <code>igraph</code> object.</p>
</td></tr>
<tr><td><code id="frag.get.layers_+3A_layer.attr">layer.attr</code></td>
<td>
<p>Character. The name of the vertices attribute giving the layer of each fragment.</p>
</td></tr>
<tr><td><code id="frag.get.layers_+3A_sel.layers">sel.layers</code></td>
<td>
<p>Character. The identifier(s) of the stratigraphic layers to retrieve.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is only a convenient function to extract the subgraphs of selected stratigraphic layers (or any other type of archaeological spatial unit). 
A graph is created for each layer in the vertex attribute given by the <code>layer.attr</code> argument.
</p>


<h3>Value</h3>

<p>A list with a graph for each selected stratigraphic layer.
</p>


<h3>Author(s)</h3>

<p>Sebastien Plutniak &lt;sebastien.plutniak at posteo.net&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- frag.simul.process(n.components=20, vertices=50, disturbance = .15)
igraph::V(g)$layers &lt;- c(rep("layer1", 20), rep("layer2", 20), rep("layer3", 10))
frag.get.layers(g, layer.attr="layers", sel.layers=c("layer1", "layer2"))
</code></pre>

<hr>
<h2 id='frag.get.layers.pair'>
Extracts the subgraph corresponding to a pair of stratigraphic layers.
</h2><span id='topic+frag.get.layers.pair'></span>

<h3>Description</h3>

<p>Extracts the subraph corresponding to a pair of stratigraphic layers (or any other type of archaeological spatial unit).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frag.get.layers.pair(graph, layer.attr, sel.layers, size.mini=2,
                     mixed.components.only=FALSE)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frag.get.layers.pair_+3A_graph">graph</code></td>
<td>
<p>An <code>igraph</code> object.</p>
</td></tr>
<tr><td><code id="frag.get.layers.pair_+3A_layer.attr">layer.attr</code></td>
<td>
<p>Character. The name of the vertices attribute giving the layer of each fragment.</p>
</td></tr>
<tr><td><code id="frag.get.layers.pair_+3A_sel.layers">sel.layers</code></td>
<td>
<p>A numeric vector of length 2 with the name of the stratigraphic layer selected for extraction.</p>
</td></tr>
<tr><td><code id="frag.get.layers.pair_+3A_size.mini">size.mini</code></td>
<td>
<p>A minimal number of vertices for the components to include in the resulting graph.</p>
</td></tr>
<tr><td><code id="frag.get.layers.pair_+3A_mixed.components.only">mixed.components.only</code></td>
<td>
<p>Logical. If TRUE, only the components with fragments from the two selected layers are returned. If FALSE, all the components of the two layers are extracted.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The default setting of the <code>mixed.components.only</code> argument is FALSE, for convenience for other measurements.
</p>


<h3>Value</h3>

<p>An undirected graph object.
</p>


<h3>Author(s)</h3>

<p>Sebastien Plutniak &lt;sebastien.plutniak at posteo.net&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- frag.simul.process(n.components=20, vertices=50, disturbance=.15)
igraph::V(g)$layers &lt;- c(rep("layer1", 20), rep("layer2", 20), rep("layer3", 10))

frag.get.layers.pair(g, "layers", sel.layers=c("layer2","layer3"),
                     size.mini=2, mixed.components.only=FALSE)
frag.get.layers.pair(g, "layers", sel.layers=c("layer2","layer3"),  
                     size.mini=2, mixed.components.only=TRUE)
</code></pre>

<hr>
<h2 id='frag.get.parameters'>Returns a series of descriptive statistics for a fragmentation graph</h2><span id='topic+frag.get.parameters'></span>

<h3>Description</h3>

<p>Returns a series of descriptive statistics for a fragmentation graph.</p>


<h3>Usage</h3>

<pre><code class='language-R'>frag.get.parameters(graph, layer.attr)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frag.get.parameters_+3A_graph">graph</code></td>
<td>
<p>An <code>igraph</code> undirected graph.</p>
</td></tr>
<tr><td><code id="frag.get.parameters_+3A_layer.attr">layer.attr</code></td>
<td>
<p>Character. The name of the vertices attribute giving the layer of each fragment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a convenient function to obtain general information about a fragmentation graph. It is particularly useful for setting the parameters of the <code>frag.simul.process</code> function.
It returns the number of components, vertices, and edges, the balance (proportion of fragments in the smaller layer), components balance (proportion of components in the poorest layer), an estimation of the disturbance, the aggregation factor, and whether the graph is planar or not.
</p>
<p>The disturbance is estimated from the subset of components with fragments from the two layers: it is computed as the number of fragments belonging to the less represented layer in each component over the total number of fragments in this subset of components.
The aggregation factor reflects the diversity of the components' edge counts. The factor is calculated by: 1 - 1/(1 + sd(edge counts of the components)).
The optional RBGL package is required to determine the planarity of the graph. If it is not installed, the 'planar' value is set to FALSE by default.
</p>


<h3>Value</h3>

<p>A list of parameters values (n.components, vertices, edges, balance, components.balance, disturbance, aggreg.factor, planar).
</p>


<h3>Author(s)</h3>

<p>Sebastien Plutniak &lt;sebastien.plutniak at posteo.net&gt;</p>


<h3>See Also</h3>

<p><a href="#topic+frag.get.layers.pair">frag.get.layers.pair</a>, 
<a href="#topic+frag.simul.process">frag.simul.process</a>, 
<a href="stats.html#topic+sd">sd</a>, 
<code><a href="RBGL.html#topic+boyerMyrvoldPlanarityTest">boyerMyrvoldPlanarityTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- frag.simul.process(n.components=20, vertices=50, disturbance=0.1)
frag.get.parameters(g, "layer")
</code></pre>

<hr>
<h2 id='frag.graph.plot'>Plot a fragmentation graph</h2><span id='topic+frag.graph.plot'></span>

<h3>Description</h3>

<p>A function to plot the graph made by the <code>archeofrag</code> package. </p>


<h3>Usage</h3>

<pre><code class='language-R'>frag.graph.plot(graph, layer.attr, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frag.graph.plot_+3A_graph">graph</code></td>
<td>
<p>An <code>igraph</code> undirected object with a &quot;frag_type&quot; attribute.</p>
</td></tr> 
<tr><td><code id="frag.graph.plot_+3A_layer.attr">layer.attr</code></td>
<td>
<p>Character. The name of the vertices attribute giving the layer of each fragment.</p>
</td></tr>
<tr><td><code id="frag.graph.plot_+3A_...">...</code></td>
<td>
<p>Optional arguments sent to <code>plot.igraph</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper for the <code>plot.igraph</code> method for igraph objects. The layout is computed using the fruchterman-reingold algorithm, with some changes as a function of the value of the &quot;frag_type&quot; graph attribute.
For graphs including similarity relations, <code>igraph</code>' <code>component_wise</code> layout modifier is applied.
For graphs with connection and similarity relationships, the edges for connection relations are coloured in green.
For graphs with connection relationships only and two layers, the nodes from the two layers are located based on their layer in the upper and the lower part of the plot.
</p>


<h3>Value</h3>

<p>Returns <code>NULL</code> and plot the graph.
</p>


<h3>Author(s)</h3>

<p>Sebastien Plutniak &lt;sebastien.plutniak at posteo.net&gt;</p>


<h3>See Also</h3>

<p><a href="igraph.html#topic+plot.igraph">plot.igraph</a>, <a href="igraph.html#topic+component_wise">component_wise</a>, <a href="igraph.html#topic+layout_with_fr">layout_with_fr</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- frag.simul.process(n.components=20, vertices=50, disturbance=.15)
frag.graph.plot(g, "layer")
</code></pre>

<hr>
<h2 id='frag.layers.admixture'>Admixture of two stratigraphic layers</h2><span id='topic+frag.layers.admixture'></span>

<h3>Description</h3>

<p>Evaluate how reliable the distinction is between the two layers (or any other type of archaeological spatial units).</p>


<h3>Usage</h3>

<pre><code class='language-R'>frag.layers.admixture(graph, layer.attr)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frag.layers.admixture_+3A_graph">graph</code></td>
<td>
<p>An undirected <code>igraph</code> object.</p>
</td></tr> 
<tr><td><code id="frag.layers.admixture_+3A_layer.attr">layer.attr</code></td>
<td>
<p>Character. The name of the vertex attribute giving the layer of each fragment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function returns a value reflecting the robustness of the distinction between two layers (or any other relevant archaeological spatial unit).
The admixture value is computed as:
</p>
<p><code>1 - cohesion(layer 1) - cohesion(layer 2)</code>
</p>
<p>The admixture of two layers is equal to the cohesion of a virtual third layer, which is defined by the fragments and the connection relationships intersecting the two layers. 
Results range in [0;1] with 0 for two completely independent layers and values towards 1 as the robustness of the boundary between the two layers is lower.
As it appears, this function calls the <code>frag.layers.cohesion</code> function.
</p>
<p>The basic use of this function is intended for a graph with two layers, whose edges have been previously weighted using the <code>frag.edges.weighting</code> function (an error message is displayed if the vertice attribute &quot;layer&quot; contains less than two layers, and if the graph does not have an edge attribute &quot;weight&quot;).
</p>
<p>However, the function can also be used for a graph with more than two layers. In this case, a subgraph is generated for each pair of layers (using the <code>frag.get.layers.pair</code> function), the <code>frag.edges.weighting</code> function is applied to weight their edges (a warning message is displayed), and the admixture is computed.
</p>
<p>An error message is displayed if the vertex &quot;layer&quot; attribute has less than two layers.
</p>


<h3>Value</h3>

<p>A numeric vector with the admixture of each pair of layers.
</p>


<h3>Author(s)</h3>

<p>Sebastien Plutniak &lt;sebastien.plutniak at posteo.net&gt;</p>


<h3>See Also</h3>

<p><code><a href="#topic+frag.edges.weighting">frag.edges.weighting</a></code>,
<code><a href="#topic+frag.layers.cohesion">frag.layers.cohesion</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- frag.simul.process(n.components=20, vertices=50, disturbance = .15)
g &lt;- frag.edges.weighting(g, layer.attr="layer")
frag.layers.admixture(g, "layer")
</code></pre>

<hr>
<h2 id='frag.layers.cohesion'>Cohesion measure of layers</h2><span id='topic+frag.layers.cohesion'></span>

<h3>Description</h3>

<p>Returns the cohesion value of two stratigraphic layers (or any other type of archeological spatial units). Must be used after weighting the edges with <code>frag.edges.weighting</code>.</p>


<h3>Usage</h3>

<pre><code class='language-R'>frag.layers.cohesion(graph, layer.attr)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frag.layers.cohesion_+3A_graph">graph</code></td>
<td>
<p>An undirected <code>igraph</code> object.</p>
</td></tr> 
<tr><td><code id="frag.layers.cohesion_+3A_layer.attr">layer.attr</code></td>
<td>
<p>Character. The name of the vertices attribute giving the layer of the fragments.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The cohesion value of a spatial unit  is computed as: 
</p>
<p style="text-align: center;"><code class="reqn">\frac{V_{unit_i} + W_{unit_i}}{ \sum_{j=1}^{2} V_{unit_j} + W_{unit_j}} </code>
</p>

<p>with V the number of vertices in the unit and W the sum of the edge weights within the unit.
</p>
<p>The measure takes into account the balance between the information about each layer.
Results range in [0;1], with 0 for two layers with only inter-layer connection relationships, and 1 if there are not inter-layer relationships and a  significant imbalance of information on the two layers.
</p>
<p>The basic use of this function is intended for a graph with two layers, whose edges have been previously weighted using the <code>frag.edges.weighting</code> function (an error message is displayed if the vertice attribute &quot;layer&quot; contains less than two layers, and if the graph does not have an edge attribute &quot;weight&quot;).
</p>
<p>However, this function can also be used for a graph with more than two layers. In this case, a subgraph is generated for each pair of layers (using the <code>frag.get.layers.pair</code> function), the <code>frag.edges.weighting</code> function is applied to weight their edges (a warning message is displayed), and the cohesion is computed.
</p>


<h3>Value</h3>

<p>If the graph has only two layers, the function returns a numeric vector with a cohesion value ([0;1]) for each layer (sorted in alphanumerical order).
If the graph has more than two layers, the function returns a matrix with a cohesion value for each pair of layers.
</p>


<h3>Author(s)</h3>

<p>Sebastien Plutniak &lt;sebastien.plutniak at posteo.net&gt;</p>


<h3>See Also</h3>

<p><code><a href="#topic+frag.edges.weighting">frag.edges.weighting</a></code>,
<code><a href="#topic+frag.get.layers.pair">frag.get.layers.pair</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- frag.simul.process(n.components=20, vertices=50, disturbance=.1)
frag.layers.cohesion(g, layer.attr="layer")
</code></pre>

<hr>
<h2 id='Frag.object-class'>Class <code>"Frag.object"</code></h2><span id='topic+Frag.object-class'></span><span id='topic+make_cr_graph+2CFrag.object-method'></span><span id='topic+make_crsr_graph+2CFrag.object-method'></span><span id='topic+make_sr_graph+2CFrag.object-method'></span><span id='topic+show+2CFrag.object-method'></span>

<h3>Description</h3>

<p>A class for archaeological &quot;fragmentation&quot; datasets. This class construction aims to ensure that the data have been properly built before performing the next steps of the analysis.
A convenient constructor function, <a href="#topic+make_frag_object">make_frag_object</a>, is provided.
</p>


<h3>Objects from the Class</h3>

<p>Objects can be created by calls of the form:
</p>
<p><code>make_frag_object(cr, sr, fragments)</code>.
</p>


<h3>Slots</h3>


<dl>
<dt><code>df.cr</code>:</dt><dd><p>Object of class <code>"matrix"</code> (<code>"data.frame"</code> are allowed and automatically converted)</p>
</dd>
<dt><code>df.sr</code>:</dt><dd><p>Object of class <code>"matrix"</code>  (<code>"data.frame"</code> are allowed and automatically converted)</p>
</dd>
<dt><code>fragments.df</code>:</dt><dd><p>Object of class <code>"data.frame"</code></p>
</dd>
<dt><code>frag_type</code>:</dt><dd><p>Object of class <code>"character"</code> </p>
</dd>
</dl>



<h3>Methods</h3>


<dl>
<dt>make_cr_graph</dt><dd><p><code>signature(object = "Frag.object")</code>:  Makes an undirected graph representing the &quot;connection&quot; relationships between archaeological fragments.</p>
</dd>
<dt>make_sr_graph</dt><dd><p><code>signature(object = "Frag.object")</code>:  Makes an undirected graph representing the &quot;similarity&quot; relationships between archaeological fragments.</p>
</dd>
<dt>make_crsr_graph</dt><dd><p><code>signature(object = "Frag.object")</code>: Makes an undirected graph combining the &quot;connection&quot; and &quot;similarity&quot; relations between archaeological fragments.</p>
</dd>
<dt>show</dt><dd><p><code>signature(object = "Frag.object")</code>: <code>show</code> method for Frag.object </p>
</dd>
</dl>



<h3>Author(s)</h3>

<p>Sebastien Plutniak &lt;sebastien.plutniak at posteo.net&gt;</p>


<h3>See Also</h3>

<p><code><a href="#topic+make_frag_object">make_frag_object</a></code>,
<code><a href="#topic+make_cr_graph">make_cr_graph</a></code>,
<code><a href="#topic+make_sr_graph">make_sr_graph</a></code>,
<code><a href="#topic+make_crsr_graph">make_crsr_graph</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>showClass("Frag.object")
</code></pre>

<hr>
<h2 id='frag.observer.failure'>Simulate the failure of an observer to determine the relationships between fragments.</h2><span id='topic+frag.observer.failure'></span>

<h3>Description</h3>

<p>Simulate the failure of an observer to determine the relationships between fragments.</p>


<h3>Usage</h3>

<pre><code class='language-R'>frag.observer.failure(graph, likelihood, remove.vertices=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frag.observer.failure_+3A_graph">graph</code></td>
<td>
<p>An undirected <code>igraph</code> object.</p>
</td></tr> 
<tr><td><code id="frag.observer.failure_+3A_likelihood">likelihood</code></td>
<td>
<p>Numerical vector of values in [0,1] giving the likelihood of not observing a relationship between two fragments.</p>
</td></tr>
<tr><td><code id="frag.observer.failure_+3A_remove.vertices">remove.vertices</code></td>
<td>
<p>Logical. If TRUE, unconnected vertices are removed.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>In determining connection relationships between archaeological fragments, archaeologists often consider the likelihood that they fail in identifying some of these relationships.
Given an initial fragmentation graph, this function aims to simulate the effects of such different likelihood values.
</p>
<p>For each value in the <code>likelihood</code> parameter, a new graph is generated by randomly removing the given proportion of edges from the input graph.
To generate a series of comparable graphs with different likelihoods, the function internally resets the seed for random number generation, so ensuring that the edges will be removed in the same order when the function is run for multiple likelihood values.
</p>
<p>An error message is displayed if at least one of the <code>likelihood</code> values is &lt; 0 or &gt; 1.
</p>


<h3>Value</h3>

<p>A list of graphs.
</p>


<h3>Author(s)</h3>

<p>Sebastien Plutniak &lt;sebastien.plutniak at posteo.net&gt;</p>


<h3>See Also</h3>

<p><code><a href="base.html#topic+set.seed">set.seed</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- frag.simul.process(n.components=20, vertices=50, disturbance=.15)
frag.observer.failure(graph=g, likelihood=c(0.05, 0.1), remove.vertices=FALSE)
</code></pre>

<hr>
<h2 id='frag.path.lengths'>Path length distribution for unconnected graphs</h2><span id='topic+frag.path.lengths'></span>

<h3>Description</h3>

<p>Path length distribution for unconnected graphs</p>


<h3>Usage</h3>

<pre><code class='language-R'>frag.path.lengths(graph, cumulative=FALSE)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frag.path.lengths_+3A_graph">graph</code></td>
<td>
<p>An <code>igraph</code> object.</p>
</td></tr> 
<tr><td><code id="frag.path.lengths_+3A_cumulative">cumulative</code></td>
<td>
<p>Logical. If TRUE, the cumulative relative frequency of the path lengths is returned.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a wrapper of <code>igraph</code> <code>distance_table</code> returning the frequency of path lengths in undirected and unconnected graphs. In the context of archaeological fragmentation analysis, path lengths are interpreted to characterise the properties of fragmentation within a layer.
</p>


<h3>Value</h3>

<p>A numeric vector having the same length as the maximum path length. The first element of the vector is the frequency of the paths of length 1, the second element is the frequency of the paths of length 2, etc. 
</p>


<h3>Author(s)</h3>

<p>Sebastien Plutniak &lt;sebastien.plutniak at posteo.net&gt;</p>


<h3>See Also</h3>

<p><code><a href="igraph.html#topic+distance_table">distance_table</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- frag.simul.process(n.components=20, vertices=50, disturbance = .15)
frag.path.lengths(g)
frag.path.lengths(g, cumulative=TRUE)
</code></pre>

<hr>
<h2 id='frag.relations.by.layers'>
Summary of the connection relationships between fragments within and between spatial units.
</h2><span id='topic+frag.relations.by.layers'></span>

<h3>Description</h3>

<p>Return a matrix with the number of relationships within and between spatial units (e.g., layers).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frag.relations.by.layers(graph, layer.attr)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frag.relations.by.layers_+3A_graph">graph</code></td>
<td>
<p>An <code>igraph</code> object.</p>
</td></tr>
<tr><td><code id="frag.relations.by.layers_+3A_layer.attr">layer.attr</code></td>
<td>
<p>Character. The name of the vertices attribute giving the spatial unit of each fragment.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a useful method to summarise the distribution of connection relationships within and between spatial units (e.g., layers).
</p>


<h3>Value</h3>

<p>A symmetrical matrix with the number of connection  relationships within and between the spatial units. 
</p>


<h3>Author(s)</h3>

<p>Sebastien Plutniak &lt;sebastien.plutniak at posteo.net&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- frag.simul.process(n.components=20, vertices=50, disturbance=.15)
frag.relations.by.layers(g, "layer")
</code></pre>

<hr>
<h2 id='frag.simul.compare'>From an observed fragmentation graph, simulates two series of graphs corresponding to two deposition hypotheses.</h2><span id='topic+frag.simul.compare'></span>

<h3>Description</h3>

<p>Given an observed fragmentation graph, simulates two series of graphs corresponding to two deposition hypotheses, compares their properties and returns a summary table.</p>


<h3>Usage</h3>

<pre><code class='language-R'>frag.simul.compare(graph, layer.attr, iter, summarise=TRUE, ...)</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frag.simul.compare_+3A_graph">graph</code></td>
<td>
<p>An undirected <code>igraph</code> object. The 'observed' graph to compare to simulated graphs.</p>
</td></tr> 
<tr><td><code id="frag.simul.compare_+3A_layer.attr">layer.attr</code></td>
<td>
<p>Character. The name of the vertices attribute giving the layer of the fragments.</p>
</td></tr>
<tr><td><code id="frag.simul.compare_+3A_iter">iter</code></td>
<td>
<p>Numerical. The number of simulated graphs to generate for each hypothesis (minimal value: 30).</p>
</td></tr>
<tr><td><code id="frag.simul.compare_+3A_summarise">summarise</code></td>
<td>
<p>Logical. Whether to report a comparative summary of the results.</p>
</td></tr>
<tr><td><code id="frag.simul.compare_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the 'frag.simul.process' function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function is a convenient wrapper integrating several functions of the <code>archeofrag</code> package to compare an observed fragmentation graph to similar simulated graphs. The <code>frag.simul.process</code> is used to generate two series of graphs from the properties of the observed graph: the first series is generated under the formation hypothesis H1 (one initial spatial unit) and the second series is generated under the hypothesis H2 (two initial spatial units). 
The edge count, edge weights sum, balance, disturbance, admixture, and cohesion values of the generated graphs are measured.
</p>
<p>By default, the results are post-processed with the <code>frag.simul.summarise</code> function and a summary data frame is printed and included in the list of results which is silently returned. If the <code>summarise</code> parameter is set to FALSE, then the function returns a list of two data frames containing the numeric values measured for H1 and H2.
</p>


<h3>Value</h3>

<p>A named list with three items: 
&quot;h1.data&quot;, a data frame with the numerical values measured on the graphs generated for H1;
&quot;h2.data&quot;, a data frame with the numerical values measured on the graphs generated for H2;
&quot;summary&quot;, a data frame summarising the comparison between the results for the two hypotheses and the values measured on the empirical graph.
</p>


<h3>Author(s)</h3>

<p>Sebastien Plutniak &lt;sebastien.plutniak at posteo.net&gt;</p>


<h3>See Also</h3>

<p><code><a href="#topic+frag.simul.process">frag.simul.process</a></code>,
<code><a href="#topic+frag.simul.summarise">frag.simul.summarise</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- frag.simul.process(n.components=20, vertices=50, disturbance=.15)
g &lt;- frag.edges.weighting(g, layer.attr="layer")
## Not run: frag.simul.compare(g, layer.attr="layer", iter=30)
</code></pre>

<hr>
<h2 id='frag.simul.process'>
Simulate the fragmentation of archaeological objects scattered in two stratigraphic layers
</h2><span id='topic+frag.simul.process'></span>

<h3>Description</h3>

<p>Simulate the fragmentation of archaeological objects scattered in two stratigraphic layers (or any other kind of spatial unit).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frag.simul.process(initial.layers=2, n.components, vertices=Inf,
                   edges=Inf, balance=.5, components.balance=.5,
                   disturbance=0, aggreg.factor=0, planar=FALSE,
                   asymmetric.transport.from=NULL, 
                   from.observed.graph=NULL, observed.layer.attr=NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frag.simul.process_+3A_initial.layers">initial.layers</code></td>
<td>
<p>Integer (1 or 2). Number of hypothetical stratigraphic layers to use as initial condition.</p>
</td></tr>
<tr><td><code id="frag.simul.process_+3A_n.components">n.components</code></td>
<td>
<p>Integer. Number of objects to fragment (connected components).</p>
</td></tr>
<tr><td><code id="frag.simul.process_+3A_vertices">vertices</code></td>
<td>
<p>Integer. Number of fragments (vertices).</p>
</td></tr>
<tr><td><code id="frag.simul.process_+3A_edges">edges</code></td>
<td>
<p>Integer. Number of connection relationships between fragments (edges).</p>
</td></tr>
<tr><td><code id="frag.simul.process_+3A_balance">balance</code></td>
<td>
<p>Numeric ]0;1[. Proportion of fragments to generate in the first layer before applying disturbances.</p>
</td></tr>
<tr><td><code id="frag.simul.process_+3A_components.balance">components.balance</code></td>
<td>
<p>Numeric ]0;1[. Proportion of components in the first layer before applying fragmentation (only used when initial.layers=2).</p>
</td></tr>
<tr><td><code id="frag.simul.process_+3A_disturbance">disturbance</code></td>
<td>
<p>Numeric [0;1]. Proportion of fragments to randomly move from one layer to another.</p>
</td></tr>
<tr><td><code id="frag.simul.process_+3A_aggreg.factor">aggreg.factor</code></td>
<td>
<p>Numeric [0;1]. Higher values increase the likelihood that the biggest components are selected when adding fragments or connections.</p>
</td></tr>
<tr><td><code id="frag.simul.process_+3A_planar">planar</code></td>
<td>
<p>Logical. If TRUE, generates a planar graph (if FALSE, the graph can be planar or not).</p>
</td></tr>
<tr><td><code id="frag.simul.process_+3A_asymmetric.transport.from">asymmetric.transport.from</code></td>
<td>
<p>Numeric or character value in &quot;1&quot; or &quot;2&quot;. If not NULL, the disturbance process will be applied only to the fragments from this layer.</p>
</td></tr>
<tr><td><code id="frag.simul.process_+3A_from.observed.graph">from.observed.graph</code></td>
<td>
<p>igraph object. If not NULL, the parameters observed in this fragmentation graph are used instead of the previous parameters. See details.</p>
</td></tr>
<tr><td><code id="frag.simul.process_+3A_observed.layer.attr">observed.layer.attr</code></td>
<td>
<p>character. Required if the <code>from.observed.graph</code> option is used. Name of the layer attribute in the observed graph.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function simulates the fragmentation of archeological objects within and between two adjacent stratigraphic layers.
Fragments are represented by vertices and the &quot;connection&quot; relationships (&quot;refittings&quot;) between them are represented by edges.
All fragments have at least one relation (&quot;single&quot; fragments are not generated).
</p>
<p>Some parameters are optional or depend on other parameters (messages are displayed accordingly). 
Namely, setting <code>initial.layers</code>=1 enables to constraint the graph with the number of vertices only, the number of edges only, or both. 
With <code>initial.layers</code>=2, the <code>components.balance</code> can be used, and the <code>edges</code> parameter is not supported (only the <code>vertices</code> parameter can be used).
</p>
<p>The <code>components.balance</code> parameter determines the proportion of components (i.e. objects) in the first layer before the application of the fragmentation process;
the <code>balance</code> parameter determines the proportion of fragments in the first layer before the application of the disturbance process.
The <code>disturbance</code> parameter determines the proportion of fragments to &quot;move&quot; from one layer to another. Consequently, it generates inter-layer relationships.
If <code>asymmetric.transport.from</code> is set to 1 or 2, the disturbance process is only applied to the fragments from layer 1 or layer 2, respectively.s
</p>
<p>If a graph is given to the <code>from.observed.graph</code> parameter, the properties of this graph are internally retrieved with the <code>frag.get.parameters</code> function (including:  the number of components, number of vertices, balance, the components.balance, the disturbance, the aggregation factor, and whether the graph is planar or not; note that the number of edges is not included as a parameter). If some other parameters of the <code>frag.simul.process</code> function are set, the values retrieved from the observed graph are used in replacement.
The <code>frag.edges.weighting</code> is internally applied to weight the graph edges.
</p>
<p>Setting the <code>planar</code> argument to TRUE constraints the graph to be planar (if this parameter is FALSE, the graph can be planar or not). 
Note that using the <code>planar</code> argument requires to install the optional RBGL package and that the simulator is faster with <code>initial.layers</code>=2 and  <code>planar</code>=FALSE.
</p>


<h3>Value</h3>

<p>An igraph object with a &quot;frag_type&quot; graph attribute (with the value &quot;cr&quot;, for &quot;connection relationship&quot;) and three vertices attributes: &quot;name&quot; (vertices identifiers), &quot;layer&quot; (with the values &quot;1&quot; and &quot;2&quot;), and &quot;object.id&quot; (component identifiers).
</p>


<h3>Author(s)</h3>

<p>Sebastien Plutniak &lt;sebastien.plutniak at posteo.net&gt;</p>


<h3>See Also</h3>

<p><code><a href="#topic+frag.get.parameters">frag.get.parameters</a></code>,
<code><a href="#topic+frag.edges.weighting">frag.edges.weighting</a></code>,
<code><a href="RBGL.html#topic+boyerMyrvoldPlanarityTest">boyerMyrvoldPlanarityTest</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>frag.simul.process(n.components=20, vertices=50, disturbance=.15)

g &lt;- frag.simul.process(initial.layers=1, 
                            n.components=20,
                            vertices=50,
                            edges=40,
                            balance=.5,
                            components.balance=.5,
                            disturbance=.1,
                            planar=FALSE)
plot(g, vertex.color=factor(igraph::V(g)$layer), 
     vertex.size=4, vertex.label=NA)

</code></pre>

<hr>
<h2 id='frag.simul.summarise'>Summarise the comparison between an observed fragmentation graph and simulated graphs for two deposition hypotheses.</h2><span id='topic+frag.simul.summarise'></span>

<h3>Description</h3>

<p>Compare the parameters measured on simulated graphs generated for two deposition hypotheses with Wilcoxon tests, and the corresponding values measured on an empirical graph, and returns a summary data frame.</p>


<h3>Usage</h3>

<pre><code class='language-R'>frag.simul.summarise(graph, layer.attr, res.h1, res.h2, cohesion1.attr="cohesion1",
                            cohesion2.attr="cohesion2", admixture.attr="admixture")</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="frag.simul.summarise_+3A_graph">graph</code></td>
<td>
<p>An undirected <code>igraph</code> object. The graph to compare with simulated graphs.</p>
</td></tr> 
<tr><td><code id="frag.simul.summarise_+3A_layer.attr">layer.attr</code></td>
<td>
<p>Character. The name of the vertices attribute giving the layer of the fragments.</p>
</td></tr>
<tr><td><code id="frag.simul.summarise_+3A_res.h1">res.h1</code></td>
<td>
<p>data frame. A data frame with the parameters observed on the simulated graphs for H1.</p>
</td></tr>
<tr><td><code id="frag.simul.summarise_+3A_res.h2">res.h2</code></td>
<td>
<p>data frame. A data frame with the parameters observed on the simulated graphs for H2.</p>
</td></tr>
<tr><td><code id="frag.simul.summarise_+3A_cohesion1.attr">cohesion1.attr</code></td>
<td>
<p>character. The name of the column in the data frames res.h1 and res.h2 with the cohesion values of the spatial unit 1.</p>
</td></tr>
<tr><td><code id="frag.simul.summarise_+3A_cohesion2.attr">cohesion2.attr</code></td>
<td>
<p>character. The name of the column in the data frames res.h1 and res.h2 with the cohesion values of the spatial unit 2.</p>
</td></tr>
<tr><td><code id="frag.simul.summarise_+3A_admixture.attr">admixture.attr</code></td>
<td>
<p>character. The name of the column in the data frames res.h1 and res.h2 with the admixture values.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function compares and summarises the numerical values measured on the series of graphs generated for the two deposition hypotheses (H1: one initial spatial unit, H2: two initial spatial units). It is intended to post-process the results of the <code>frag.simul.compare</code> function, but it can also be applied to other inputs.
</p>
<p>The data frames with the results for H1 and H2 must have exactly the same column names, corresponding to parameters measured on the simulated graphs. When using the result generated with the <code>frag.simul.compare</code> function, the parameters considered include: the edge count, the sum of the edge weights, the balance, the disturbance, the admixture and the cohesion of the two spatial units). When using this function alone, the names of the columns of the data frames can be set with the cohesion1.attr, cohesion2.attr, and admixture.attr parameters (default values:  &quot;cohesion1&quot;, &quot;cohesion2&quot;,  &quot;admixture&quot; respectively).
</p>
<p>For each parameter, a two-sample Wilcoxon test is run to compare the series of values generated for H1 and H2. In addition, the value measured on the observed graph is compared with the range of values generated for the two hypotheses. The results of these comparisons are reported as a data frame with four columns: for each parameter studied, the data frame contains 1) whether the series of H1 values are statistically different to the H2 series (Boolean), 2) the p-value of the Wilcoxon test (numerical), 3) whether the observed value is &quot;within&quot;, &quot;higher&quot;, or &quot;lower&quot; to the interquartile range of values for H1, 4) whether the observed value is &quot;within&quot;, &quot;higher&quot;, or &quot;lower&quot; to the interquartile range of values for H2.
</p>


<h3>Value</h3>

<p>A data frame summarising the comparison between the simulated results for the two hypotheses, and the values measured on the empirical graph with the simulated results.
</p>


<h3>Author(s)</h3>

<p>Sebastien Plutniak &lt;sebastien.plutniak at posteo.net&gt;</p>


<h3>See Also</h3>

<p><code><a href="#topic+frag.simul.compare">frag.simul.compare</a></code>,
<code><a href="stats.html#topic+wilcox.test">wilcox.test</a></code>,
</p>


<h3>Examples</h3>

<pre><code class='language-R'>g &lt;- frag.simul.process(n.components=20, vertices=50, disturbance=.15)
g &lt;- frag.edges.weighting(g, layer.attr="layer")
## Not run: res &lt;- frag.simul.compare(g, layer.attr="layer", iter=30, summarise=FALSE)
frag.simul.summarise(g, layer.attr="layer", res.h1=res[[1]], res.h2=res[[2]])
## End(Not run)
</code></pre>

<hr>
<h2 id='LiangAbu'>Dataset: Archeological relationships between pottery fragments in Liang Abu</h2><span id='topic+LiangAbu'></span><span id='topic+df.cr'></span><span id='topic+df.sr'></span><span id='topic+fragments.info'></span>

<h3>Description</h3>

<p>Liang Abu is an archaeological site in East Kalimantan, Indonesia. This dataset describes the relationships between pottery fragments found during   excavations (2009-2012). Two types of relationships are defined.
</p>

<ul>
<li><p> A connection relationship refers to a physical connection between two fragments that were part of the same object. 
</p>
</li>
<li><p> A similarity relationship between fragments is defined if there is an acceptable likelihood that those fragments were part of the same object.
</p>
</li></ul>

<p>The dataset is composed of three tables, <code>df.cr</code>, <code>df.sr</code>, <code>fragments.info</code>.
</p>

<ul>
<li><p><code>df.cr</code>: &quot;connection&quot; relationships between fragments.
</p>
</li>
<li><p><code>df.sr</code>: &quot;similarity&quot; relationships between fragments.
</p>
</li>
<li><p><code>fragments.info</code>: contextual information concerning each fragment.
</p>
</li></ul>



<h3>Usage</h3>

<pre><code class='language-R'>data(LiangAbu)</code></pre>


<h3>Format</h3>


<ul>
<li><p><code>df.cr</code> is a 56x2 matrix. Each line describes a connection relationship between two fragments. There respective unique identifiers are given in column &quot;frg_id1&quot; and in column &quot;frg_id2&quot;. 
</p>
</li>
<li><p><code>df.sr</code> is a 147x2 matrix. Column &quot;frg_id&quot; gives a fragment unique identifier, column &quot;su_id&quot; gives a unique identifier for the group of similar fragments it belongs to (similarity unit).
</p>
</li>
<li><p><code>fragments.info</code> is 177x8 data frame:
</p>

<ul>
<li><p> frg_id: unique fragment identifier 
</p>
</li>
<li><p> layer:  stratigraphic layer
</p>
</li>
<li><p> zmin: minimal depth in centimetres where the fragment was found
</p>
</li>
<li><p> zmax: maximal depth in centimetres where the fragment was found
</p>
</li>
<li><p> square: square where the fragment was found
</p>
</li>
<li><p> sherd.type: type of pottery sherd
</p>
</li>
<li><p> thickness: thickness of the fragments in millimetres
</p>
</li>
<li><p> length: length of the fragments in millimetres
</p>
</li></ul>

</li></ul>



<h3>References</h3>


<ul>
<li><p> Plutniak, Sebastien, &quot;The Strength of Parthood Ties. Modelling Spatial Units and Fragmented Objects with the TSAR Method - Topological Study of Archaeological Refitting&quot;, Journal of Archaeological Science, vol. 136, 105501, doi: 10.1016/j.jas.2021.105501.
</p>
</li>
<li><p> Plutniak, Sebastien, &quot;Refitting pottery fragments from the Liang Abu rockshelter, Borneo&quot;, Zenodo, doi: 10.5281/zenodo.4719578.
</p>
</li>
<li><p> Plutniak, Sebastien, Astolfo Araujo, Simon Puaud, Jean-Georges Ferrie, Adhi Agus Oktaviana, Bambang Sugiyanto, Jean-Michel Chazine et Francois-Xavier Ricaut. 2015. &quot;Borneo as a half empty pot: Pottery assemblage from Liang Abu, East Kalimantan, Quaternary International, doi: 10.1016/j.quaint.2015.11.080.</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'>data(LiangAbu)
head(fragments.info)
</code></pre>

<hr>
<h2 id='make_cr_graph'>
Make a &quot;connection&quot; relationships graph.
</h2><span id='topic+make_cr_graph'></span><span id='topic+make_cr_graph-methods'></span>

<h3>Description</h3>

<p>Takes a <code><a href="#topic+Frag.object-class">frag.object</a></code> and returns an undirected graph representing the &quot;connection&quot; relationships between archaeological fragments. A &quot;connection&quot; relationship refers to a physical connection between two fragments that were part of the same object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_cr_graph(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_cr_graph_+3A_object">object</code></td>
<td>

<p>A <code><a href="#topic+Frag.object-class">frag.object</a></code> object.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns an undirected graph of &quot;<code>igraph</code>&quot; class. The &quot;fragments&quot; data frame of the frag.object is used to set the vertices attributes.</p>


<h3>Value</h3>

<p>An undirected <code>igraph</code> class graph. The &quot;frag_type&quot; graph attribute is set with the &quot;connection&quot; character value.
</p>


<h3>Author(s)</h3>

<p>Sebastien Plutniak &lt;sebastien.plutniak at posteo.net&gt;</p>


<h3>See Also</h3>

<p><a href="#topic+make_frag_object">make_frag_object</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>cr.df &lt;- matrix(c(1,2, 1,3, 2,3, 4,5, 4,6, 7,8), ncol=2, byrow=TRUE)
sr.df &lt;- matrix( c(1,1, 9,1, 10,1, 11,2, 12,2, 13,2), ncol=2, byrow=TRUE)
fragments.df &lt;- data.frame(1:13, letters[1:13]) 

cr_g &lt;- make_frag_object(cr=cr.df, fragments=fragments.df)
crsr_g &lt;- make_frag_object(cr=cr.df, sr=sr.df, fragments=fragments.df)

make_cr_graph(cr_g)
make_cr_graph(crsr_g)
</code></pre>

<hr>
<h2 id='make_crsr_graph'>
Makes a &quot;connection&quot; relationships graph including the &quot;similarity&quot; relationships.
</h2><span id='topic+make_crsr_graph'></span>

<h3>Description</h3>

<p>Takes a <code><a href="#topic+Frag.object-class">frag.object</a></code> in argument and returns an undirected graph representing the relationships between archaeological fragments. &quot;Connection&quot; and &quot;similiarity&quot; relationships are combined. A &quot;connection&quot; relationship refers to a physical connection between two fragments that were part of the same object. A &quot;similarity&quot; relationship between fragments is defined if there is an acceptable likelihood that those fragments were part of the same object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>    make_crsr_graph(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_crsr_graph_+3A_object">object</code></td>
<td>
<p>A <code><a href="#topic+Frag.object-class">frag.object</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A complementary function to the <code><a href="#topic+make_cr_graph">make_cr_graph</a></code> function. This function handles both the &quot;connection&quot; and &quot;similarity&quot; relationships.  This can be useful, given that &quot;similarity&quot; relations are more frequently documented in archaeological datasets than the &quot;connection&quot; relationships. 
</p>
<p>The function returns an undirected graph of &quot;<code>igraph</code>&quot; class, using the &quot;fragments&quot; data frame of the frag.object to set the vertices attributes. 
</p>
<p>Both &quot;connection&quot; and &quot;similarity&quot; relationships are included in the resulting graph. The edge attribute &quot;type_relation&quot; is set with a character &quot;cr&quot; value for &quot;connection&quot; relationships and with &quot;sr&quot; for &quot;similarity&quot; relationships. 
Edge weights are not set by this function, and it is recommended to use the <code>frag.edges.weighting</code> function. A &quot;frag_type&quot; graph attribute is set with a &quot;connection and similarity&quot; value.
</p>


<h3>Value</h3>

<p>An undirected &quot;igraph&quot; class graph.</p>


<h3>Author(s)</h3>

<p>Sebastien Plutniak &lt;sebastien.plutniak at posteo.net&gt;</p>


<h3>See Also</h3>

<p><a href="#topic+make_frag_object">make_frag_object</a>, <a href="#topic+make_cr_graph">make_cr_graph</a>, <a href="#topic+make_sr_graph">make_sr_graph</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>cr.df &lt;- matrix(c(1,2, 1,3, 2,3, 4,5, 4,6, 7,8), ncol=2, byrow=TRUE)
sr.df &lt;- matrix( c(1,1, 9,1, 10,1, 11,2, 12,2, 13,2), ncol=2, byrow=TRUE)
fragments.df &lt;- data.frame(1:13, letters[1:13]) 
crsr_g &lt;- make_frag_object(cr=cr.df, sr=sr.df, fragments=fragments.df)
make_crsr_graph(crsr_g)
</code></pre>

<hr>
<h2 id='make_frag_object'>
Makes a &quot;frag.object&quot; object.
</h2><span id='topic+make_frag_object'></span>

<h3>Description</h3>

<p>Makes a &quot;<code><a href="#topic+Frag.object-class">frag.object</a></code>&quot; object.    
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_frag_object(cr, sr, fragments)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_frag_object_+3A_cr">cr</code></td>
<td>

<p>A matrix or a data frame with two columns giving the vertex id of each pair of connected fragments.
</p>
</td></tr>
<tr><td><code id="make_frag_object_+3A_sr">sr</code></td>
<td>

<p>Optional. A matrix or a data frame with two columns: the first gives the fragment id, the second gives the &quot;similarity group&quot; id. Optional if <code>mode</code> is &quot;cr&quot;.
</p>
</td></tr>
<tr><td><code id="make_frag_object_+3A_fragments">fragments</code></td>
<td>

<p>A matrix or a data frame with information about each fragment. The first column must contain the fragments' id. 
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function checks the dataset and returns a &quot;frag.object&quot; which can be turned into a fragmentation graph using the <code><a href="#topic+make_cr_graph">make_cr_graph</a></code>, <code><a href="#topic+make_sr_graph">make_sr_graph</a></code>, or <code><a href="#topic+make_crsr_graph">make_crsr_graph</a></code> functions.</p>


<h3>Value</h3>

<p>An object of &quot;<code><a href="#topic+Frag.object-class">frag.object</a></code>&quot; class.
</p>


<h3>Author(s)</h3>

<p>Sebastien Plutniak &lt;sebastien.plutniak at posteo.net&gt;</p>


<h3>Examples</h3>

<pre><code class='language-R'>cr.df &lt;- matrix(c(1,2, 1,3, 2,3, 4,5, 4,6, 7,8), ncol=2, byrow=TRUE)
sr.df &lt;- matrix( c(1,1, 9,1, 10,1, 11,2, 12,2, 13,2), ncol=2, byrow=TRUE)
fragments.df &lt;- data.frame(1:13, letters[1:13]) 

make_frag_object(cr=cr.df, fragments=fragments.df)
make_frag_object(cr=cr.df, sr=sr.df, fragments=fragments.df)
</code></pre>

<hr>
<h2 id='make_sr_graph'>
Make a &quot;similarity&quot; relationships graph.
</h2><span id='topic+make_sr_graph'></span><span id='topic+make_sr_graph-methods'></span>

<h3>Description</h3>

<p>Takes a <code><a href="#topic+Frag.object-class">frag.object</a></code> and returns an undirected graph representing the &quot;similarity&quot; relationships between archaeological fragments. A &quot;similarity&quot; relationship  between fragments is defined if there is an acceptable likelihood that those fragments were part of the same object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>make_sr_graph(object)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="make_sr_graph_+3A_object">object</code></td>
<td>

<p>A <code><a href="#topic+Frag.object-class">frag.object</a></code> object.
</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Returns an undirected graph of &quot;<code>igraph</code>&quot; class. The &quot;fragments&quot; data frame of the frag.object is used to set the vertices attributes.</p>


<h3>Value</h3>

<p>An undirected <code>igraph</code> class graph. The &quot;frag_type&quot; graph attribute is set with the &quot;similarity&quot; character value.
</p>


<h3>Author(s)</h3>

<p>Sebastien Plutniak &lt;sebastien.plutniak at posteo.net&gt;</p>


<h3>See Also</h3>

<p><a href="#topic+make_frag_object">make_frag_object</a></p>


<h3>Examples</h3>

<pre><code class='language-R'>sr.df &lt;- matrix( c(1,1, 9,1, 10,1, 11,2, 12,2, 13,2), ncol=2, byrow=TRUE)
fragments.df &lt;- data.frame(1:13, letters[1:13]) 
crsr_g &lt;- make_frag_object(sr=sr.df, fragments=fragments.df)
make_sr_graph(crsr_g)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
