<!DOCTYPE html><html><head><title>Help for package parallelDist</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {parallelDist}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#parDist'><p>Parallel Distance Matrix Computation using multiple Threads</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Parallel Distance Matrix Computation using Multiple Threads</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.6</td>
</tr>
<tr>
<td>Author:</td>
<td>Alexander Eckert [aut, cre],
  Lucas Godoy [ctb],
  Srikanth KS [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Alexander Eckert &lt;info@alexandereckert.com&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>A fast parallelized alternative to R's native 'dist' function to
    calculate distance matrices for continuous, binary, and multi-dimensional
    input matrices, which supports a broad variety of 41 predefined distance
    functions from the 'stats', 'proxy' and 'dtw' R packages, as well as user-
    defined functions written in C++. For ease of use, the 'parDist' function
    extends the signature of the 'dist' function and uses the same parameter
    naming conventions as distance methods of existing R packages. The package
    is mainly implemented in C++ and leverages the 'RcppParallel' package to
    parallelize the distance computations with the help of the 'TinyThread'
    library. Furthermore, the 'Armadillo' linear algebra library is used for
    optimized matrix operations during distance calculations. The curiously
    recurring template pattern (CRTP) technique is applied to avoid virtual
    functions, which improves the Dynamic Time Warping calculations while
    the implementation stays flexible enough to support different DTW step
    patterns and normalization methods.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/alexeckert/parallelDist">https://github.com/alexeckert/parallelDist</a>,
<a href="https://www.alexandereckert.com/projects/#r-packages">https://www.alexandereckert.com/projects/#r-packages</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/alexeckert/parallelDist/issues">https://github.com/alexeckert/parallelDist/issues</a></td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.0.2)</td>
</tr>
<tr>
<td>Imports:</td>
<td>Rcpp (&ge; 0.12.6), RcppParallel (&ge; 4.3.20)</td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppParallel, RcppArmadillo</td>
</tr>
<tr>
<td>SystemRequirements:</td>
<td>C++11</td>
</tr>
<tr>
<td>Suggests:</td>
<td>dtw, ggplot2, proxy, testthat, RcppArmadillo, RcppXPtrUtils</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2022-02-03 22:25:21 UTC; phreazer</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2022-02-03 23:50:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='parDist'>Parallel Distance Matrix Computation using multiple Threads</h2><span id='topic+parDist'></span><span id='topic+parallelDist'></span>

<h3>Description</h3>

<p>Calculates distance matrices in parallel using multiple threads. Supports 41 predefined distance measures and user-defined distance functions.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>parDist(x, method = "euclidean", diag = FALSE, upper = FALSE, threads = NULL, ...)
parallelDist(x, method = "euclidean", diag = FALSE, upper = FALSE, threads = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="parDist_+3A_x">x</code></td>
<td>
<p>a numeric matrix (each row is one series) or list of numeric matrices for multidimensional series (each matrix is one series, a row is a dimension of a series)</p>
</td></tr>
<tr><td><code id="parDist_+3A_method">method</code></td>
<td>
<p>the distance measure to be used. A list of all available distance methods can be found in the details section below.</p>
</td></tr>
<tr><td><code id="parDist_+3A_diag">diag</code></td>
<td>
<p>logical value indicating whether the diagonal of the distance matrix should be printed by print.dist.</p>
</td></tr>
<tr><td><code id="parDist_+3A_upper">upper</code></td>
<td>
<p>logical value indicating whether the upper triangle of the distance matrix should be printed by print.dist</p>
</td></tr>
<tr><td><code id="parDist_+3A_threads">threads</code></td>
<td>
<p>number of cpu threads for calculating a distance matrix. Default is the maximum amount of cpu threads available on the system.</p>
</td></tr>
<tr><td><code id="parDist_+3A_...">...</code></td>
<td>
<p>additional parameters which will be passed to the distance methods. See details section below.</p>
</td></tr>
</table>


<h3>Details</h3>



<h4>User-defined distance functions</h4>


<dl>
<dt><code>custom</code></dt><dd>
<p>Defining and compiling a user-defined C++ distance function, as well as creating an external pointer to the function can easily be achieved with the <code><a href="RcppXPtrUtils.html#topic+cppXPtr">cppXPtr</a></code> function of the <span class="pkg">RcppXPtrUtils</span> package. The resulting <code style="white-space: pre;">&#8288;Xptr&#8288;</code> external pointer object needs to be passed to <code><a href="#topic+parDist">parDist</a></code> using the <code>func</code> parameter.
</p>
<p>Parameters:
</p>

<ul>
<li>

<dl>
<dt><code>func</code> (Xptr)</dt><dd><p>External pointer to a user-defined distance function with the following signature: <br /> <code>double customDist(const arma::mat &amp;A, const arma::mat &amp;B)</code> <br /> Note that the return value must be a <code style="white-space: pre;">&#8288;double&#8288;</code> and the two parameters must be of type <code style="white-space: pre;">&#8288;const arma::mat &amp;param&#8288;</code>.  <br /> <br />
More information about the Armadillo library can be found at <a href="http://arma.sourceforge.net/docs.html">http://arma.sourceforge.net/docs.html</a> or as part of the documentation of the <span class="pkg">RcppArmadillo</span> package.</p>
</dd>
</dl>


</li></ul>

<p>An exemplary definition and usage of an user-defined euclidean distance function can be found in the examples section below.
</p>
</dd>
</dl>




<h4>Available predefined distance measures (written for two vectors <code class="reqn">x</code> and <code class="reqn">y</code>)</h4>

<p><b>Distance methods for continuous input variables</b>
</p>

<dl>
<dt><code>bhjattacharyya</code></dt><dd>
<p>The Bhjattacharyya distance.<br /> Type: continuous<br /> Formula: <code class="reqn">sqrt(sum_i (sqrt(x_i) - sqrt(y_i))^2))</code>.<br /> Details: See <code>pr_DB$get_entry("bhjattacharyya")</code> in <span class="pkg">proxy</span>.
</p>
</dd>
<dt><code>bray</code></dt><dd>
<p>The Bray/Curtis dissimilarity.<br /> Type: continuous<br /> Formula: <code class="reqn">sum_i |x_i - y_i| / sum_i (x_i + y_i)</code>.<br /> Details: See <code>pr_DB$get_entry("bray")</code> in <span class="pkg">proxy</span>.
</p>
</dd>
<dt><code>canberra</code></dt><dd>
<p>The Canberra distance (with compensation for excluded components). Terms with zero numerator and denominator are omitted from the sum and treated as if the values were missing. <br /> Type: continuous<br /> Formula: <code class="reqn">sum_i |x_i - y_i| / |x_i + y_i|</code>.<br /> Details: See <code>pr_DB$get_entry("canberra")</code> in <span class="pkg">proxy</span>.
</p>
</dd>
<dt><code>chord</code></dt><dd>
<p>The Chord distance.<br /> Type: continuous<br /> Formula: <code class="reqn">sqrt(2 * (1 - xy / sqrt(xx * yy)))</code>.<br /> Details: See <code>pr_DB$get_entry("chord")</code> in <span class="pkg">proxy</span>.
</p>
</dd>
<dt><code>divergence</code></dt><dd>
<p>The Divergence distance.<br /> Type: continuous<br /> Formula: <code class="reqn">sum_i (x_i - y_i)^2 / (x_i + y_i)^2</code>.<br /> Details: See <code>pr_DB$get_entry("divergence")</code> in <span class="pkg">proxy</span>.
</p>
</dd>
<dt><code>dtw</code></dt><dd><p>Implementation of a multi-dimensional Dynamic Time Warping algorithm.<br /> Type: continuous<br /> Formula: Euclidean distance <code class="reqn">sqrt(sum_i (x_i - y_i)^2)</code>.<br />
Parameters:
</p>

<ul>
<li>

<dl>
<dt><code>window.size</code> (integer, optional)</dt><dd><p>Size of the window of the Sakoe-Chiba band. If the absolute length difference of two series x and y is larger than the window.size, the window.size is set to the length difference.</p>
</dd>
</dl>


</li>
<li>

<dl>
<dt><code>norm.method</code> (character, optional)</dt><dd><p>Normalization method for DTW distances.
</p>

<ul>
<li><p><code>path.length</code> Normalization with the length of the warping path.
</p>
</li>
<li><p><code>n</code> Normalization with n. n is the length of series x.
</p>
</li>
<li><p><code>n+m</code> Normalization with n + m. n is the length of series x, m is the length of series y.
</p>
</li></ul>

</dd>
</dl>


</li>
<li>

<dl>
<dt><code>step.pattern</code> (character or stepPattern of <span class="pkg">dtw</span> package, default: <code>symmetric1</code>)</dt><dd>
<p>The following step patterns of the <span class="pkg">dtw</span> package are supported:
</p>

<ul>
<li>
<p><code>asymmetric</code> (Normalization hint: n)

</p>
</li>
<li>
<p><code>asymmetricP0</code> (Normalization hint: n)

</p>
</li>
<li>
<p><code>asymmetricP05</code> (Normalization hint: n)

</p>
</li>
<li>
<p><code>asymmetricP1</code> (Normalization hint: n)

</p>
</li>
<li>
<p><code>asymmetricP2</code> (Normalization hint: n)

</p>
</li>
<li>
<p><code>symmetric1</code> (Normalization hint: path.length)

</p>
</li>
<li>
<p><code>symmetric2</code> or <code>symmetricP0</code> (Normalization hint: n+m)

</p>
</li>
<li>
<p><code>symmetricP05</code> (Normalization hint: n+m)

</p>
</li>
<li>
<p><code>symmetricP1</code> (Normalization hint: n+m)

</p>
</li>
<li>
<p><code>symmetricP2</code> (Normalization hint: n+m)

</p>
</li></ul>

<p>For a detailed description see <code><a href="dtw.html#topic+stepPattern">stepPattern</a></code> of the <span class="pkg">dtw</span> package.
</p>
</dd>
</dl>


</li></ul>

</dd>
<dt><code>euclidean</code></dt><dd>
<p>The Euclidean distance/L_2-norm (with compensation for excluded components).<br /> Type: continuous<br /> Formula: <code class="reqn">sqrt(sum_i (x_i - y_i)^2))</code>.<br /> Details: See <code>pr_DB$get_entry("euclidean")</code> in <span class="pkg">proxy</span>.
</p>
</dd>
<dt><code>fJaccard</code></dt><dd>
<p>The fuzzy Jaccard distance.<br /> Type: binary<br /> Formula: <code class="reqn">sum_i (min{x_i, y_i}) / sum_i(max{x_i, y_i})</code>.<br /> Details: See <code>pr_DB$get_entry("fJaccard")</code> in <span class="pkg">proxy</span>.
</p>
</dd>
<dt><code>geodesic</code></dt><dd>
<p>The geoedesic distance, i.e. the angle between x and y.<br /> Type: continuous<br /> Formula: <code class="reqn">arccos(xy / sqrt(xx * yy))</code>.<br /> Details: See <code>pr_DB$get_entry("geodesic")</code> in <span class="pkg">proxy</span>.
</p>
</dd>
<dt><code>hellinger</code></dt><dd>
<p>The Hellinger distance.<br /> Type: continuous<br /> Formula: <code class="reqn">sqrt(sum_i (sqrt(x_i / sum_i x) - sqrt(y_i / sum_i y)) ^ 2)</code>.<br /> Details: See <code>pr_DB$get_entry("hellinger")</code> in <span class="pkg">proxy</span>.
</p>
</dd>
<dt><code>kullback</code></dt><dd>
<p>The Kullback-Leibler distance.<br /> Type: continuous<br /> Formula: <code class="reqn">sum_i [x_i * log((x_i / sum_j x_j) / (y_i / sum_j y_j)) / sum_j x_j)]</code>.<br /> Details: See <code>pr_DB$get_entry("kullback")</code> in <span class="pkg">proxy</span>.
</p>
</dd>
<dt><code>mahalanobis</code></dt><dd>
<p>The Mahalanobis distance. The Variance-Covariance-Matrix is estimated from the input data if unspecified.<br /> Type: continuous<br /> Formula: <code class="reqn">sqrt((x - y) Sigma^(-1) (x - y))</code>.<br /> Parameters:
</p>

<ul>
<li>

<dl>
<dt><code>cov</code> (numeric matrix, optional)</dt><dd><p>The covariance matrix  (p x p) of the distribution.</p>
</dd>
</dl>


</li>
<li>

<dl>
<dt><code>inverted</code> (logical, optional)</dt><dd><p>If TRUE, cov is supposed to contain the inverse of the covariance matrix.</p>
</dd>
</dl>


</li></ul>

<p>Details: See <code>pr_DB$get_entry("mahalanobis")</code> in <span class="pkg">proxy</span> or <code>mahalanobis</code> in <span class="pkg">stats</span>.
</p>
</dd>
<dt><code>manhattan</code></dt><dd>
<p>The Manhattan/City-Block/Taxi/L_1-norm distance (with compensation for excluded components).<br /> Type: continuous<br /> Formula: <code class="reqn">sum_i |x_i - y_i|</code>.<br /> Details: See <code>pr_DB$get_entry("manhattan")</code> in <span class="pkg">proxy</span>.
</p>
</dd>
<dt><code>maximum</code></dt><dd>
<p>The Maximum/Supremum/Chebyshev distance.<br /> Type: continuous<br /> Formula: <code class="reqn">max_i |x_i - y_i|</code>.<br /> Details: See <code>pr_DB$get_entry("maximum")</code> in <span class="pkg">proxy</span>.
</p>
</dd>
<dt><code>minkowski</code></dt><dd>
<p>The Minkowski distance/p-norm (with compensation for excluded components). <br /> Type: continuous<br /> Formula: <code class="reqn">(sum_i (x_i - y_i)^p)^(1/p)</code>.<br /> Parameters:
</p>

<ul>
<li>

<dl>
<dt><code>p</code> (double, optional)</dt><dd><p>The <code class="reqn">p</code>th root of the sum of the <code class="reqn">p</code>th powers of the differences of the components.</p>
</dd>
</dl>


</li></ul>

<p>Details: See <code>pr_DB$get_entry("minkowski")</code> in <span class="pkg">proxy</span>.
</p>
</dd>
<dt><code>podani</code></dt><dd>
<p>The Podany measure of discordance is defined on ranks with ties. In the formula, for two given objects x and y, n is the number of variables, a is is the number of pairs of variables ordered identically, b the number of pairs reversely ordered, c the number of pairs tied in both x and y (corresponding to either joint presence or absence), and d the number of all pairs of variables tied at least for one of the objects compared such that one, two, or thee scores are zero.<br /> Type: continuous<br /> Formula: <code class="reqn">1 - 2 * (a - b + c - d) / (n * (n - 1))</code>.<br /> Details: See <code>pr_DB$get_entry("podani")</code> in <span class="pkg">proxy</span>.
</p>
</dd>
<dt><code>soergel</code></dt><dd>
<p>The Soergel distance.<br /> Type: continuous<br /> Formula: <code class="reqn">sum_i |x_i - y_i| / sum_i max{x_i, y_i}</code>.<br /> Details: See <code>pr_DB$get_entry("soergel")</code> in <span class="pkg">proxy</span>.
</p>
</dd>
<dt><code>wave</code></dt><dd>
<p>The Wave/Hedges distance.<br /> Type: continuous<br /> Formula: <code class="reqn">sum_i (1 - min(x_i, y_i) / max(x_i, y_i))</code>.<br /> Details: See <code>pr_DB$get_entry("wave")</code> in <span class="pkg">proxy</span>.
</p>
</dd>
<dt><code>whittaker</code></dt><dd>
<p>The Whittaker distance.<br /> Type: continuous<br /> Formula: <code class="reqn">sum_i |x_i / sum_i x - y_i / sum_i y| / 2</code>.<br /> Details: See <code>pr_DB$get_entry("whittaker")</code> in <span class="pkg">proxy</span>.
</p>
</dd>
</dl>

<p><b>Distance methods for binary input variables</b>
</p>
<p><em>Notation:</em>
</p>

<ul>
<li><p> a: number of (TRUE, TRUE) pairs
</p>
</li>
<li><p> b: number of (FALSE, TRUE) pairs
</p>
</li>
<li><p> c: number of (TRUE, FALSE) pairs
</p>
</li>
<li><p> d: number of (FALSE, FALSE) pairs
</p>
</li></ul>

<p><em>Note:</em> Similarities are converted to distances.
</p>

<dl>
<dt><code>binary</code></dt><dd>
<p>The Jaccard Similarity for binary data. It is the proportion of (TRUE, TRUE) pairs, but not considering (FALSE, FALSE) pairs.<br /> Type: binary<br /> Formula: <code class="reqn">a / (a + b + c)</code>.<br /> Details: See <code>pr_DB$get_entry("binary")</code> in <span class="pkg">proxy</span>.
</p>
</dd>
<dt><code>braun-blanquet</code></dt><dd>
<p>The Braun-Blanquet similarity.<br /> Type: binary<br /> Formula: <code class="reqn">a / max{(a + b), (a + c)}</code>.<br /> Details: See <code>pr_DB$get_entry("braun-blanquet")</code> in <span class="pkg">proxy</span>.
</p>
</dd>
<dt><code>cosine</code></dt><dd>
<p>The cosine similarity.<br /> Type: continuous<br /> Formula: <code class="reqn">(a * b) / (|a|*|b|)</code>.<br /> Details: See <code>pr_DB$get_entry("cosine")</code> in <span class="pkg">proxy</span>.
</p>
</dd>
<dt><code>dice</code></dt><dd>
<p>The Dice similarity.<br /> Type: binary<br /> Formula: <code class="reqn">2a / (2a + b + c)</code>.<br /> Details: See <code>pr_DB$get_entry("dice")</code> in <span class="pkg">proxy</span>.
</p>
</dd>
<dt><code>fager</code></dt><dd>
<p>The Fager / McGowan distance.<br /> Type: binary<br /> Formula: <code class="reqn">a / sqrt((a + b)(a + c)) - sqrt(a + c) / 2</code>.<br /> Details: See <code>pr_DB$get_entry("fager")</code> in <span class="pkg">proxy</span>.
</p>
</dd>
<dt><code>faith</code></dt><dd>
<p>The Faith similarity.<br /> Type: binary<br /> Formula: <code class="reqn">(a + d/2) / n</code>.<br /> Details: See <code>pr_DB$get_entry("faith")</code> in <span class="pkg">proxy</span>.
</p>
</dd>
<dt><code>hamman</code></dt><dd>
<p>The Hamman Matching similarity for binary data. It is the proportion difference of the concordant and discordant pairs.<br /> Type: binary<br /> Formula: <code class="reqn">([a + d] - [b + c]) / n</code>.<br /> Details: See <code>pr_DB$get_entry("hamman")</code> in <span class="pkg">proxy</span>.
</p>
</dd>
<dt><code>hamming</code></dt><dd>
<p>The hamming distance between two vectors A and B is the fraction of positions where there is a mismatch. <br /> Formula: <code class="reqn">\textit{\# of }(A != B) / \textit{\# in A (or B)}</code>
</p>
</dd>
<dt><code>kulczynski1</code></dt><dd>
<p>Kulczynski similarity for binary data. Relates the (TRUE, TRUE) pairs to discordant pairs.<br /> Type: binary<br /> Formula: <code class="reqn">a / (b + c)</code>.<br /> Details: See <code>pr_DB$get_entry("kulczynski1")</code> in <span class="pkg">proxy</span>.
</p>
</dd>
<dt><code>kulczynski2</code></dt><dd>
<p>Kulczynski similarity for binary data. Relates the (TRUE, TRUE) pairs to the discordant pairs.<br /> Type: binary<br /> Formula: <code class="reqn">[a / (a + b) + a / (a + c)] / 2</code>.<br /> Details: See <code>pr_DB$get_entry("kulczynski2")</code> in <span class="pkg">proxy</span>.
</p>
</dd>
<dt><code>michael</code></dt><dd>
<p>The Michael similarity.<br /> Type: binary<br /> Formula: <code class="reqn">4(ad - bc) / [(a + d)^2 + (b + c)^2]</code>.<br /> Details: See <code>pr_DB$get_entry("michael")</code> in <span class="pkg">proxy</span>.
</p>
</dd>
<dt><code>mountford</code></dt><dd>
<p>The Mountford similarity for binary data.<br /> Type: binary<br /> Formula: <code class="reqn">2a / (ab + ac + 2bc)</code>.<br /> Details: See <code>pr_DB$get_entry("mountford")</code> in <span class="pkg">proxy</span>.
</p>
</dd>
<dt><code>mozley</code></dt><dd>
<p>The Mozley/Margalef similarity.<br /> Type: binary<br /> Formula: <code class="reqn">an / (a + b)(a + c)</code>.<br /> Details: See <code>pr_DB$get_entry("mozley")</code> in <span class="pkg">proxy</span>.
</p>
</dd>
<dt><code>ochiai</code></dt><dd>
<p>The Ochiai similarity.<br /> Type: binary<br /> Formula: <code class="reqn">a / sqrt[(a + b)(a + c)]</code>.<br /> Details: See <code>pr_DB$get_entry("ochiai")</code> in <span class="pkg">proxy</span>.
</p>
</dd>
<dt><code>phi</code></dt><dd>
<p>The Phi similarity (= Product-Moment-Correlation for binary variables).<br /> Type: binary<br /> Formula: <code class="reqn">(ad - bc) / sqrt[(a + b)(c + d)(a + c)(b + d)]</code>.<br /> Details: See <code>pr_DB$get_entry("phi")</code> in <span class="pkg">proxy</span>.
</p>
</dd>
<dt><code>russel</code></dt><dd>
<p>The Russel/Raosimilarity for binary data. It is just the proportion of (TRUE, TRUE) pairs.<br /> Type: binary<br /> Formula: <code class="reqn">a / n</code>.<br /> Details: See <code>pr_DB$get_entry("russel")</code> in <span class="pkg">proxy</span>.
</p>
</dd>
<dt><code>simple matching</code></dt><dd>
<p>The Simple Matching similarity for binary data. It is the proportion of concordant pairs.<br /> Type: binary<br /> Formula: <code class="reqn">(a + d) / n</code>.<br /> Details: See <code>pr_DB$get_entry("simple matching")</code> in <span class="pkg">proxy</span>.
</p>
</dd>
<dt><code>simpson</code></dt><dd>
<p>The Simpson similarity.<br /> Type: binary<br /> Formula: <code class="reqn">a / min{(a + b), (a + c)}</code>.<br /> Details: See <code>pr_DB$get_entry("simpson")</code> in <span class="pkg">proxy</span>.
</p>
</dd>
<dt><code>stiles</code></dt><dd>
<p>The Stiles similarity. Identical to the logarithm of Krylov's distance.<br /> Type: binary<br /> Formula: <code class="reqn">log(n(|ad-bc| - 0.5n)^2 / [(a + b)(c + d)(a + c)(b + d)])</code>.<br /> Details: See <code>pr_DB$get_entry("stiles")</code> in <span class="pkg">proxy</span>.
</p>
</dd>
<dt><code>tanimoto</code></dt><dd>
<p>The Rogers/Tanimoto similarity for binary data. Similar to the simple matching coefficient, but putting double weight on the discordant pairs.<br /> Type: binary<br /> Formula: <code class="reqn">(a + d) / (a + 2b + 2c + d)</code>.<br /> Details: See <code>pr_DB$get_entry("tanimoto")</code> in <span class="pkg">proxy</span>.
</p>
</dd>
<dt><code>yule</code></dt><dd>
<p>The Yule similarity.<br /> Type: binary<br /> Formula: <code class="reqn">(ad - bc) / (ad + bc)</code>.<br /> Details: See <code>pr_DB$get_entry("yule")</code> in <span class="pkg">proxy</span>.
</p>
</dd>
<dt><code>yule2</code></dt><dd>
<p>The Yule similarity.<br /> Type: binary<br /> Formula: <code class="reqn">(sqrt(ad) - sqrt(bc)) / (sqrt(ad) + sqrt(bc))</code>.<br /> Details: See <code>pr_DB$get_entry("yule2")</code> in <span class="pkg">proxy</span>.
</p>
</dd>
</dl>




<h3>Value</h3>

<p><code>parDist</code> returns an object of class <code>"dist"</code>.
</p>
<p>The lower triangle of the distance matrix stored by columns in a
vector, say <code>do</code>. If <code>n</code> is the number of
observations, i.e., <code>n &lt;- attr(do, "Size")</code>, then
for <code class="reqn">i &lt; j \le n</code>, the dissimilarity between (row) i and j is
<code>do[n*(i-1) - i*(i-1)/2 + j-i]</code>.
The length of the vector is <code class="reqn">n*(n-1)/2</code>, i.e., of order <code class="reqn">n^2</code>.
</p>
<p>The object has the following attributes (besides <code>"class"</code> equal
to <code>"dist"</code>):
</p>
<table>
<tr><td><code>Size</code></td>
<td>
<p>integer, the number of observations in the dataset.</p>
</td></tr>
<tr><td><code>Labels</code></td>
<td>
<p>optionally, contains the labels, if any, of the
observations of the dataset.</p>
</td></tr>
<tr><td><code>Diag</code>, <code>Upper</code></td>
<td>
<p>logicals corresponding to the arguments <code>diag</code>
and <code>upper</code> above, specifying how the object should be printed.</p>
</td></tr>
<tr><td><code>call</code></td>
<td>
<p>optionally, the <code><a href="base.html#topic+call">call</a></code> used to create the
object.</p>
</td></tr>
<tr><td><code>method</code></td>
<td>
<p>optionally, the distance method used; resulting from
<code><a href="#topic+parDist">parDist</a>()</code>, the (<code><a href="base.html#topic+match.arg">match.arg</a>()</code>ed) <code>method</code>
argument.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'>## Not run: 
## predefined distance functions
# defining a matrix, where each row corresponds to one series
sample.matrix &lt;- matrix(c(1:100), ncol = 10)

# euclidean distance
parDist(x = sample.matrix, method = "euclidean")
# minkowski distance with parameter p=2
parDist(x = sample.matrix, method = "minkowski", p=2)
# dynamic time warping distance
parDist(x = sample.matrix, method = "dtw")
# dynamic time warping distance normalized with warping path length
parDist(x = sample.matrix, method = "dtw", norm.method="path.length")
# dynamic time warping with different step pattern
parDist(x = sample.matrix, method = "dtw", step.pattern="symmetric2")
# dynamic time warping with window size constraint
parDist(x = sample.matrix, method = "dtw", step.pattern="symmetric2", window.size=1)

## multi-dimensional distance functions using list of matrices
# defining a list of matrices, where each list entry row corresponds to a two dimensional series
tmp.mat &lt;- matrix(c(1:40), ncol = 10)
sample.matrix.list &lt;- list(tmp.mat[1:2,], tmp.mat[3:4,])

# multi-dimensional euclidean distance
parDist(x = sample.matrix.list, method = "euclidean")
# multi-dimensional dynamic time warping
parDist(x = sample.matrix.list, method = "dtw")

## user-defined distance function
library(RcppArmadillo)
# Use RcppXPtrUtils for simple usage of C++ external pointers
library(RcppXPtrUtils)

# compile user-defined function and return pointer (RcppArmadillo is used as dependency)
euclideanFuncPtr &lt;- cppXPtr(
"double customDist(const arma::mat &amp;A, const arma::mat &amp;B) {
  return sqrt(arma::accu(arma::square(A - B)));
}", depends = c("RcppArmadillo"))

# distance matrix for user-defined euclidean distance function (note that method is set to "custom")
parDist(matrix(1:16, ncol=2), method="custom", func = euclideanFuncPtr)
## End(Not run)
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
