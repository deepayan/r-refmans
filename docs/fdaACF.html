<!DOCTYPE html><html><head><title>Help for package fdaACF</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {fdaACF}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#elec_prices'><p>Daily electricity price profiles from the Day-Ahead Spanish Electricity Market</p></a></li>
<li><a href='#estimate_iid_distr_Imhof'><p>Estimate distribution of the fACF under the iid. hypothesis using Imhof's method</p></a></li>
<li><a href='#estimate_iid_distr_MC'><p>Estimate distribution of the fACF under the iid. hypothesis using MC method</p></a></li>
<li><a href='#fdaACF'><p>fdaACF: Autocorrelation function for Functional Time Series</p></a></li>
<li><a href='#fit_ARHp_FPCA'><p>Fit an ARH(p) to a given functional time series</p></a></li>
<li><a href='#FTS_identification'><p>Obtain the auto- and partial autocorrelation functions for a given FTS</p></a></li>
<li><a href='#integral_operator'><p>Integral transformation of a curve using an integral operator</p></a></li>
<li><a href='#mat2fd'><p>Obtain a fd object from a matrix</p></a></li>
<li><a href='#obtain_autocorrelation'><p>Estimate the autocorrelation function of the series</p></a></li>
<li><a href='#obtain_autocov_eigenvalues'><p>Estimate eigenvalues of the autocovariance function</p></a></li>
<li><a href='#obtain_autocovariance'><p>Estimate the autocovariance function of the series</p></a></li>
<li><a href='#obtain_FACF'><p>Obtain the autocorrelation function for a given functional time series.</p></a></li>
<li><a href='#obtain_FPACF'><p>Obtain the partial autocorrelation function for a given FTS.</p></a></li>
<li><a href='#obtain_suface_L2_norm'><p>Obtain L2 norm of the autocovariance functions</p></a></li>
<li><a href='#plot_autocovariance'><p>Generate a 3D plot of the autocovariance surface of a given FTS</p></a></li>
<li><a href='#plot_FACF'><p>Plot the autocorrelation function of a given FTS</p></a></li>
<li><a href='#reconstruct_fd_from_PCA'><p>Obtain the reconstructed curves after PCA</p></a></li>
<li><a href='#simulate_iid_brownian_bridge'><p>Simulate a FTS from a brownian bridge process</p></a></li>
<li><a href='#simulate_iid_brownian_motion'><p>Simulate a FTS from a brownian motion process</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Autocorrelation Function for Functional Time Series</td>
</tr>
<tr>
<td>Version:</td>
<td>1.0.0</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-10-20</td>
</tr>
<tr>
<td>Author:</td>
<td>Guillermo Mestre Marcos [aut, cre],
  José Portela González [aut],
  Gregory Rice [aut],
  Antonio Muñoz San Roque [ctb],
  Estrella Alonso Pérez [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Guillermo Mestre Marcos &lt;guillermo.mestre@comillas.edu&gt;</td>
</tr>
<tr>
<td>Description:</td>
<td>Quantify the serial correlation across lags of a given functional 
    time series using the autocorrelation function and a partial autocorrelation
    function for functional time series proposed in 
    Mestre et al. (2021) &lt;<a href="https://doi.org/10.1016%2Fj.csda.2020.107108">doi:10.1016/j.csda.2020.107108</a>&gt;.
    The autocorrelation functions are based on the L2 norm of the lagged covariance 
    operators of the series. Functions are available for estimating the 
    distribution of the autocorrelation functions under the assumption 
    of strong functional white noise.</td>
</tr>
<tr>
<td>Imports:</td>
<td>CompQuadForm, pracma, fda, vars</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/GMestreM/fdaACF">https://github.com/GMestreM/fdaACF</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/GMestreM/fdaACF/issues">https://github.com/GMestreM/fdaACF/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-2">GPL-2</a> | <a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a> [expanded from: GPL (&ge; 2)]</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.5.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.0.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, fields</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-10-20 17:14:23 UTC; Guille</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-10-20 20:00:16 UTC</td>
</tr>
</table>
<hr>
<h2 id='elec_prices'>Daily electricity price profiles from the Day-Ahead Spanish Electricity Market</h2><span id='topic+elec_prices'></span>

<h3>Description</h3>

<p>A dataset containing the hourly electricity prices for Spain
in the Day-Ahead Market (MIBEL)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>elec_prices
</code></pre>


<h3>Format</h3>

<p>A data frame with 365 rows and 24 variables:
</p>

<dl>
<dt>H1</dt><dd><p>Electricity price for hour 1</p>
</dd>
<dt>H2</dt><dd><p>Electricity price for hour 2</p>
</dd>
<dt>H3</dt><dd><p>Electricity price for hour 3</p>
</dd>
<dt>H4</dt><dd><p>Electricity price for hour 4</p>
</dd>
<dt>H5</dt><dd><p>Electricity price for hour 5</p>
</dd>
<dt>H6</dt><dd><p>Electricity price for hour 6</p>
</dd>
<dt>H7</dt><dd><p>Electricity price for hour 7</p>
</dd>
<dt>H8</dt><dd><p>Electricity price for hour 8</p>
</dd>
<dt>H9</dt><dd><p>Electricity price for hour 9</p>
</dd>
<dt>H10</dt><dd><p>Electricity price for hour 10</p>
</dd>
<dt>H11</dt><dd><p>Electricity price for hour 11</p>
</dd>
<dt>H12</dt><dd><p>Electricity price for hour 12</p>
</dd>
<dt>H13</dt><dd><p>Electricity price for hour 13</p>
</dd>
<dt>H14</dt><dd><p>Electricity price for hour 14</p>
</dd>
<dt>H15</dt><dd><p>Electricity price for hour 15</p>
</dd>
<dt>H16</dt><dd><p>Electricity price for hour 16</p>
</dd>
<dt>H17</dt><dd><p>Electricity price for hour 17</p>
</dd>
<dt>H18</dt><dd><p>Electricity price for hour 18</p>
</dd>
<dt>H19</dt><dd><p>Electricity price for hour 19</p>
</dd>
<dt>H20</dt><dd><p>Electricity price for hour 20</p>
</dd>
<dt>H21</dt><dd><p>Electricity price for hour 21</p>
</dd>
<dt>H22</dt><dd><p>Electricity price for hour 22</p>
</dd>
<dt>H23</dt><dd><p>Electricity price for hour 23</p>
</dd>
<dt>H24</dt><dd><p>Electricity price for hour 24</p>
</dd>
</dl>


<h3>Source</h3>

<p><a href="https://www.esios.ree.es/es/analisis/600">https://www.esios.ree.es/es/analisis/600</a>
</p>

<hr>
<h2 id='estimate_iid_distr_Imhof'>Estimate distribution of the fACF under the iid. hypothesis using Imhof's method</h2><span id='topic+estimate_iid_distr_Imhof'></span>

<h3>Description</h3>

<p>Estimate the distribution of the autocorrelation function
under the hypothesis of strong functional white noise. This
function uses Imhof's method to estimate the distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_iid_distr_Imhof(Y, v, autocovSurface, matindex, figure = FALSE,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_iid_distr_Imhof_+3A_y">Y</code></td>
<td>
<p>Matrix containing the discretized values
of the functional time series. The dimension of the
matrix is <code class="reqn">(n x m)</code>, where <code class="reqn">n</code> is the
number of curves and <code class="reqn">m</code> is the number of points
observed in each curve.</p>
</td></tr>
<tr><td><code id="estimate_iid_distr_Imhof_+3A_v">v</code></td>
<td>
<p>Discretization points of the curves, by default
<code>seq(from = 0, to = 1, length.out = 100)</code>.</p>
</td></tr>
<tr><td><code id="estimate_iid_distr_Imhof_+3A_autocovsurface">autocovSurface</code></td>
<td>
<p>An <code class="reqn">(m x m)</code> matrix with the discretized
values of the autocovariance operator <code class="reqn">\hat{C}_{0}</code>, obtained
by calling the function <code>obtain_autocovariance</code>.
The value <code class="reqn">m</code> indicates the number of points observed
in each curve.</p>
</td></tr>
<tr><td><code id="estimate_iid_distr_Imhof_+3A_matindex">matindex</code></td>
<td>
<p>A vector containing the L2 norm of
the autocovariance function. It can be obtained by calling
function <code>obtain_suface_L2_norm</code>.</p>
</td></tr>
<tr><td><code id="estimate_iid_distr_Imhof_+3A_figure">figure</code></td>
<td>
<p>Logical. If <code>TRUE</code>, plots the
estimated distribution.</p>
</td></tr>
<tr><td><code id="estimate_iid_distr_Imhof_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the  <code>plot</code>
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a list with:
</p>

<ul>
<li> <p><code>ex</code>: Knots where the
distribution has been estimated
</p>
</li>
<li> <p><code>ef</code>: Discretized values of
the estimated distribution.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Example 1

N &lt;- 100
v &lt;- seq(from = 0, to = 1, length.out = 10)
sig &lt;- 2
Y &lt;- simulate_iid_brownian_bridge(N, v, sig)
nlags &lt;- 1
autocovSurface &lt;- obtain_autocovariance(Y,nlags)
matindex &lt;- obtain_suface_L2_norm (v,autocovSurface)
# Remove lag 0
matindex &lt;- matindex[-1]
Imhof_dist &lt;- estimate_iid_distr_Imhof(Y,v,autocovSurface,matindex)
plot(Imhof_dist$ex,Imhof_dist$ef,type = "l",main = "ecdf obtained by Imhof's method")
grid()


# Example 2

N &lt;- 400
v &lt;- seq(from = 0, to = 1, length.out = 50)
sig &lt;- 2
Y &lt;- simulate_iid_brownian_bridge(N, v, sig)
autocovSurface &lt;- obtain_autocovariance(Y,nlags)
matindex &lt;- obtain_suface_L2_norm (v,autocovSurface)
# Remove lag 0
matindex &lt;- matindex[-1]
Imhof_dist &lt;- estimate_iid_distr_Imhof(Y,v,autocovSurface,matindex)
plot(Imhof_dist$ex,Imhof_dist$ef,type = "l",main = "ecdf obtained by Imhof's method")
grid()

</code></pre>

<hr>
<h2 id='estimate_iid_distr_MC'>Estimate distribution of the fACF under the iid. hypothesis using MC method</h2><span id='topic+estimate_iid_distr_MC'></span>

<h3>Description</h3>

<p>Estimate the distribution of the autocorrelation function
under the hypothesis of strong functional white noise. This
function uses Montecarlo's method to estimate the distribution.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>estimate_iid_distr_MC(Y, v, autocovSurface, matindex, nsimul = 10000,
  figure = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="estimate_iid_distr_MC_+3A_y">Y</code></td>
<td>
<p>Matrix containing the discretized values
of the functional time series. The dimension of the
matrix is <code class="reqn">(n x m)</code>, where <code class="reqn">n</code> is the
number of curves and <code class="reqn">m</code> is the number of points
observed in each curve.</p>
</td></tr>
<tr><td><code id="estimate_iid_distr_MC_+3A_v">v</code></td>
<td>
<p>Discretization points of the curves, by default
<code>seq(from = 0, to = 1, length.out = 100)</code>.</p>
</td></tr>
<tr><td><code id="estimate_iid_distr_MC_+3A_autocovsurface">autocovSurface</code></td>
<td>
<p>An <code class="reqn">(m x m)</code> matrix with the discretized
values of the autocovariance operator <code class="reqn">\hat{C}_{0}</code>, obtained
by calling the function <code>obtain_autocovariance</code>.
The value <code class="reqn">m</code> indicates the number of points observed
in each curve.</p>
</td></tr>
<tr><td><code id="estimate_iid_distr_MC_+3A_matindex">matindex</code></td>
<td>
<p>A vector containing the L2 norm of
the autocovariance function. It can be obtained by calling
function <code>obtain_suface_L2_norm</code>.</p>
</td></tr>
<tr><td><code id="estimate_iid_distr_MC_+3A_nsimul">nsimul</code></td>
<td>
<p>Positive integer indicating the number of
MC simulations that will be used to estimate the distribution
of the statistic. Increasing the number of simulations will
improve the estimation, but it will increase the computational
time.
By default, <code>nsimul = 10000</code>.</p>
</td></tr>
<tr><td><code id="estimate_iid_distr_MC_+3A_figure">figure</code></td>
<td>
<p>Logical. If <code>TRUE</code>, plots the
estimated distribution.</p>
</td></tr>
<tr><td><code id="estimate_iid_distr_MC_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the  <code>plot</code>
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a list with:
</p>

<ul>
<li> <p><code>ex</code>: Knots where the
distribution has been estimated
</p>
</li>
<li> <p><code>ef</code>: Discretized values of
the estimated distribution.
</p>
</li>
<li> <p><code>Reig</code>: Raw values of the i.i.d.
statistic for each MC simulation.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Example 1

N &lt;- 100
v &lt;- seq(from = 0, to = 1, length.out = 10)
sig &lt;- 2
Y &lt;- simulate_iid_brownian_bridge(N, v, sig)
nlags &lt;- 1
autocovSurface &lt;- obtain_autocovariance(Y,nlags)
matindex &lt;- obtain_suface_L2_norm (v,autocovSurface)
# Remove lag 0
matindex &lt;- matindex[-1]
MC_dist &lt;- estimate_iid_distr_MC(Y,v,autocovSurface,matindex)
plot(MC_dist$ex,MC_dist$ef,type = "l",main = "ecdf obtained by MC simulation")
grid()


# Example 2

N &lt;- 400
v &lt;- seq(from = 0, to = 1, length.out = 50)
sig &lt;- 2
Y &lt;- simulate_iid_brownian_bridge(N, v, sig)
nlags &lt;- 20
autocovSurface &lt;- obtain_autocovariance(Y,nlags)
matindex &lt;- obtain_suface_L2_norm (v,autocovSurface)
# Remove lag 0
matindex &lt;- matindex[-1]
MC_dist &lt;- estimate_iid_distr_MC(Y,v,autocovSurface,matindex)
plot(MC_dist$ex,MC_dist$ef,type = "l",main = "ecdf obtained by MC simulation")
grid()

</code></pre>

<hr>
<h2 id='fdaACF'>fdaACF: Autocorrelation function for Functional Time Series</h2><span id='topic+fdaACF'></span><span id='topic+fdaACF-package'></span>

<h3>Description</h3>

<p>The fdaACF package provides diagnostic and analysis tools
to quantify the serial autocorrelation across lags of a
given functional time series in order to improve the identification
and diagnosis of functional ARIMA models. The autocorrelation function
is based on the L2 norm of the lagged covariance operators of the series.
Several real-world datasets are included to illustrate the application
of these techniques.
</p>

<hr>
<h2 id='fit_ARHp_FPCA'>Fit an ARH(p) to a given functional time series</h2><span id='topic+fit_ARHp_FPCA'></span>

<h3>Description</h3>

<p>Fit an <code class="reqn">ARH(p)</code> model to a given functional
time series. The fitted model is based on the model proposed
in (Aue et al, 2015), first decomposing the original
functional observations into a vector time series of <code>n_harm</code>
FPCA scores, and then fitting a vector autoregressive
model of order <code class="reqn">p</code> (<code class="reqn">VAR(p)</code>) to the time series
of the scores. Once fitted, the Karhunen-Loève expansion
is used to re-transform the fitted values into functional
observations.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fit_ARHp_FPCA(y, v, p, n_harm, show_varprop = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="fit_ARHp_FPCA_+3A_y">y</code></td>
<td>
<p>Matrix containing the discretized values
of the functional time series. The dimension of the
matrix is <code class="reqn">(n x m)</code>, where <code class="reqn">n</code> is the
number of curves and <code class="reqn">m</code> is the number of points
observed in each curve.</p>
</td></tr>
<tr><td><code id="fit_ARHp_FPCA_+3A_v">v</code></td>
<td>
<p>Numeric vector that contains the 
discretization points of the curves.</p>
</td></tr>
<tr><td><code id="fit_ARHp_FPCA_+3A_p">p</code></td>
<td>
<p>Numeric value specifying the order 
of the functional autoregressive 
model to be fitted.</p>
</td></tr>
<tr><td><code id="fit_ARHp_FPCA_+3A_n_harm">n_harm</code></td>
<td>
<p>Numeric value specifying the number
of functional principal components to be used when fitting
the <code class="reqn">ARH(p)</code> model.</p>
</td></tr>
<tr><td><code id="fit_ARHp_FPCA_+3A_show_varprop">show_varprop</code></td>
<td>
<p>Logical. If <code>show_varprop = TRUE</code>,
a plot of the proportion of variance explained by the first
<code>n_harm</code> functional principal components will be shown.
By default <code>show_varprop = TRUE</code>.</p>
</td></tr>
</table>


<h3>References</h3>

<p>Aue, A., Norinho, D. D., Hormann, S. (2015).
<em>On the Prediction of Stationary Functional 
Time Series</em>
Journal of the American Statistical Association, 
110, 378&ndash;392. <a href="https://doi.org/10.1080/01621459.2014.909317">https://doi.org/10.1080/01621459.2014.909317</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1

# Simulate an ARH(1) process
N &lt;- 250
dv &lt;- 20
v &lt;- seq(from = 0, to = 1, length.out = 20)

phi &lt;- 1.3 * ((v) %*% t(v))

persp(v,v,phi, 
      ticktype = "detailed", 
      main = "Integral operator")

set.seed(3)
white_noise &lt;-  simulate_iid_brownian_bridge(N, v = v)

y &lt;- matrix(nrow = N, ncol = dv)
y[1,] &lt;- white_noise[1,]
for(jj in 2:N){
    y[jj,] &lt;- white_noise[jj,];
    
    y[jj,]=y[jj,]+integral_operator(operator_kernel = phi,
                                    v = v,
                                    curve = y[jj-1,])
}

# Fit an ARH(1) model
mod &lt;- fit_ARHp_FPCA(y = y,
                     v = v,
                     p = 1,
                     n_harm = 5)

# Plot results
plot(v, y[50,], type = "l", lty = 1, ylab = "")
lines(v, mod$y_est[50,], col = "red")
legend("bottomleft", legend = c("real","est"),
       lty = 1, col = c(1,2))

</code></pre>

<hr>
<h2 id='FTS_identification'>Obtain the auto- and partial autocorrelation functions for a given FTS</h2><span id='topic+FTS_identification'></span>

<h3>Description</h3>

<p>Estimate both the autocorrelation and partial 
autocorrelation function for a given functional time series 
and its distribution under the hypothesis of strong functional
white noise. Both correlograms are plotted to ease the identification
of the dependence structure of the functional time series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>FTS_identification(Y, v, nlags, n_harm = NULL, ci = 0.95,
  estimation = "MC", figure = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="FTS_identification_+3A_y">Y</code></td>
<td>
<p>Matrix containing the discretized values
of the functional time series. The dimension of the
matrix is <code class="reqn">(n x m)</code>, where <code class="reqn">n</code> is the
number of curves and <code class="reqn">m</code> is the number of points
observed in each curve.</p>
</td></tr>
<tr><td><code id="FTS_identification_+3A_v">v</code></td>
<td>
<p>Discretization points of the curves.</p>
</td></tr>
<tr><td><code id="FTS_identification_+3A_nlags">nlags</code></td>
<td>
<p>Number of lagged covariance operators
of the functional time series that will be used
to estimate the autocorrelation functions.</p>
</td></tr>
<tr><td><code id="FTS_identification_+3A_n_harm">n_harm</code></td>
<td>
<p>Number of principal components
that will be used to fit the ARH(p) models. If
this value is not supplied, <code>n_harm</code> will be
selected as the number of principal components that
explain more than 95 % of the variance of the
original data.
By default, <code>n_harm = NULL</code>.</p>
</td></tr>
<tr><td><code id="FTS_identification_+3A_ci">ci</code></td>
<td>
<p>A value between 0 and 1 that indicates
the confidence interval for the i.i.d. bounds
of the partial autocorrelation function. By default
<code>ci = 0.95</code>.</p>
</td></tr>
<tr><td><code id="FTS_identification_+3A_estimation">estimation</code></td>
<td>
<p>Character specifying the
method to be used when estimating the distribution
under the hypothesis of functional white noise.
Accepted values are:
</p>

<ul>
<li><p> &quot;MC&quot;: Monte-Carlo estimation.
</p>
</li>
<li><p> &quot;Imhof&quot;: Estimation using Imhof's method.
</p>
</li></ul>

<p>By default, <code>estimation = "MC"</code>.</p>
</td></tr>
<tr><td><code id="FTS_identification_+3A_figure">figure</code></td>
<td>
<p>Logical. If <code>TRUE</code>, plots the
estimated partial autocorrelation function with the
specified i.i.d. bound.</p>
</td></tr>
<tr><td><code id="FTS_identification_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the <code>plot_FACF</code>
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a list with:
</p>

<ul>
<li> <p><code>Blueline</code>: The upper prediction
bound for the i.i.d. distribution.
</p>
</li>
<li> <p><code>rho_FACF</code>: Autocorrelation
coefficients for
each lag of the functional time series.
</p>
</li>
<li> <p><code>rho_FPACF</code>: Partial autocorrelation
coefficients for
each lag of the functional time series.
</p>
</li></ul>



<h3>References</h3>

<p>Mestre G., Portela J., Rice G., Muñoz San Roque A., Alonso E. (2021).
<em>Functional time series model identification and diagnosis by 
means of auto- and partial autocorrelation analysis.</em>
Computational Statistics &amp; Data Analysis, 155, 107108.
<a href="https://doi.org/10.1016/j.csda.2020.107108">https://doi.org/10.1016/j.csda.2020.107108</a>
</p>
<p>Mestre, G., Portela, J., Muñoz-San Roque, A., Alonso, E. (2020).
<em>Forecasting hourly supply curves in the Italian Day-Ahead 
electricity market with a double-seasonal SARMAHX model.</em>
International Journal of Electrical Power &amp; Energy Systems, 
121, 106083. <a href="https://doi.org/10.1016/j.ijepes.2020.106083">https://doi.org/10.1016/j.ijepes.2020.106083</a>
</p>
<p>Kokoszka, P., Rice, G., Shang, H.L. (2017).
<em>Inference for the autocovariance of a functional
time series under conditional heteroscedasticity</em>
Journal of Multivariate Analysis, 
162, 32&ndash;50. <a href="https://doi.org/10.1016/j.jmva.2017.08.004">https://doi.org/10.1016/j.jmva.2017.08.004</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1 (Toy example)

N &lt;- 50
v &lt;- seq(from = 0, to = 1, length.out = 10)
sig &lt;- 2
set.seed(15)
Y &lt;- simulate_iid_brownian_bridge(N, v, sig)
FTS_identification(Y,v,3)


# Example 2

data(elec_prices)
v &lt;- seq(from = 1, to = 24)
nlags &lt;- 30
FTS_identification(Y = as.matrix(elec_prices), 
v = v,
nlags = nlags,
ci = 0.95,
figure = TRUE)

</code></pre>

<hr>
<h2 id='integral_operator'>Integral transformation of a curve using an integral operator</h2><span id='topic+integral_operator'></span>

<h3>Description</h3>

<p>Compute the integral transform of the
curve <code class="reqn">Y_i</code> with respect to a given integral
operator <code class="reqn">\Psi</code>. The transformation is given by
</p>
<p style="text-align: center;"><code class="reqn">\Psi(Y_{i})(v) = \int \psi(u,v)Y_{i}(u)du</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>integral_operator(operator_kernel, curve, v)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="integral_operator_+3A_operator_kernel">operator_kernel</code></td>
<td>
<p>Matrix with the values
of the kernel surface of the integral operator.
The dimension of the matrix is <code class="reqn">(g x m)</code>, where
<code class="reqn">g</code> is the number of discretization points of the
input curve and <code class="reqn">m</code> is the number of discretization
points of the output curve.</p>
</td></tr>
<tr><td><code id="integral_operator_+3A_curve">curve</code></td>
<td>
<p>Vector containing the discretized values
of a functional observation. The dimension of the
matrix is <code class="reqn">(1 x m)</code>, where <code class="reqn">m</code> is the
number of points observed in the curve.</p>
</td></tr>
<tr><td><code id="integral_operator_+3A_v">v</code></td>
<td>
<p>Numerical vector specifying the
discretization points of the curves.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a matrix the same size as
<code>curve</code> with the transformed values.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1

v &lt;- seq(from = 0, to = 1, length.out = 20)
set.seed(10)
curve &lt;- sin(v) + rnorm(length(v))
operator_kernel &lt;- 0.6*(v %*% t(v))
hat_curve &lt;- integral_operator(operator_kernel,curve,v)

</code></pre>

<hr>
<h2 id='mat2fd'>Obtain a fd object from a matrix</h2><span id='topic+mat2fd'></span>

<h3>Description</h3>

<p>This function returns a <code>fd</code> object
obtained from the discretized functional observations
contained in <code>mat_obj</code>.
</p>
<p>It is assumed that the functional observations
contained in <code>mat_obj</code> are real observations,
hence a poligonal base will be used to obtain
the functional object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mat2fd(mat_obj, range_val = c(0, 1), argvals = NULL)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="mat2fd_+3A_mat_obj">mat_obj</code></td>
<td>
<p>A matrix that contains the
discretized functional observations.</p>
</td></tr>
<tr><td><code id="mat2fd_+3A_range_val">range_val</code></td>
<td>
<p>A numeric vector of length 2
that contains the range of the observed functional
data. By default <code>range_val = c(0,1)</code>.</p>
</td></tr>
<tr><td><code id="mat2fd_+3A_argvals">argvals</code></td>
<td>
<p>Optinal argument that contains
a strictly increasing vector
of argument values at which line segments join
to form a polygonal line. If <code>argvals = NULL</code>,
it is assumed a equidistant discretization vector.
By default <code>argvals = NULL</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A fd object obtained from the functional
observations in <code>mat_obj</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1
N &lt;- 100
dv &lt;- 30
v &lt;- seq(from = 0, to = 1, length.out = dv)
set.seed(150) # For replication
mat_func_obs &lt;- matrix(rnorm(N*dv), 
                       nrow = N, 
                       ncol = dv)
fd_func_obs &lt;- mat2fd(mat_obj = mat_func_obs,
                      range_val = range(v),
                      argvals = v)
plot(fd_func_obs)
</code></pre>

<hr>
<h2 id='obtain_autocorrelation'>Estimate the autocorrelation function of the series</h2><span id='topic+obtain_autocorrelation'></span>

<h3>Description</h3>

<p>Obtain the empirical autocorrelation function for
lags <code class="reqn">= 0,...,</code><code>nlags</code> of the functional time
series. Given <code class="reqn">Y_{1},...,Y_{T}</code> a functional time
series, the sample autocovariance functions
<code class="reqn">\hat{C}_{h}(u,v)</code> are given by:
</p>
<p style="text-align: center;"><code class="reqn">\hat{C}_{h}(u,v) =  \frac{1}{T} \sum_{i=1}^{T-h}(Y_{i}(u) - \overline{Y}_{T}(u))(Y_{i+h}(v) - \overline{Y}_{T}(v))</code>
</p>

<p>where
<code class="reqn"> \overline{Y}_{T}(u) = \frac{1}{T} \sum_{i = 1}^{T} Y_{i}(t)</code>
denotes the sample mean function. By normalizing these
functions using the normalizing factor
<code class="reqn">\int\hat{C}_{0}(u,u)du</code>, the range of the
autocovariance functions becomes <code class="reqn">(0,1)</code>; thus
defining the autocorrelation functions of the series
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obtain_autocorrelation(Y, v = seq(from = 0, to = 1, length.out =
  ncol(Y)), nlags)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obtain_autocorrelation_+3A_y">Y</code></td>
<td>
<p>Matrix containing the discretized values
of the functional time series. The dimension of the
matrix is <code class="reqn">(n x m)</code>, where <code class="reqn">n</code> is the
number of curves and <code class="reqn">m</code> is the number of points
observed in each curve.</p>
</td></tr>
<tr><td><code id="obtain_autocorrelation_+3A_v">v</code></td>
<td>
<p>Discretization points of the curves, by default
<code>seq(from = 0, to = 1, length.out = 100)</code>.</p>
</td></tr>
<tr><td><code id="obtain_autocorrelation_+3A_nlags">nlags</code></td>
<td>
<p>Number of lagged covariance operators
of the functional time series that will be used
to estimate the autocorrelation function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a list with the lagged autocorrelation
functions estimated from the data. Each function is given
by a <code class="reqn">(m x m)</code> matrix, where <code class="reqn">m</code> is the
number of points observed in each curve.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1

N &lt;- 100
v &lt;- seq(from = 0, to = 1, length.out = 10)
sig &lt;- 2
bbridge &lt;- simulate_iid_brownian_bridge(N, v, sig)
nlags &lt;- 1
lagged_autocor &lt;- obtain_autocorrelation(Y = bbridge,
                                        nlags = nlags)
image(x = v, y = v, z = lagged_autocor$Lag0)


# Example 2
require(fields)
N &lt;- 500
v &lt;- seq(from = 0, to = 1, length.out = 50)
sig &lt;- 2
bbridge &lt;- simulate_iid_brownian_bridge(N, v, sig)
nlags &lt;- 4
lagged_autocov &lt;- obtain_autocovariance(Y = bbridge,
                                        nlags = nlags)
lagged_autocor &lt;- obtain_autocorrelation(Y = bbridge,
                                         v = v,
                                         nlags = nlags)

opar &lt;- par(no.readonly = TRUE)
par(mfrow = c(1,2))
z_lims &lt;- range(lagged_autocov$Lag1)
colors &lt;- heat.colors(12)
image.plot(x = v, 
           y = v,
           z = lagged_autocov$Lag1,
           legend.width = 2,
           zlim = z_lims,
           col = colors,
           xlab = "u",
           ylab = "v",
           main = "Autocovariance")
z_lims &lt;- range(lagged_autocor$Lag1)
image.plot(x = v, 
           y = v,
           z = lagged_autocor$Lag1,
           legend.width = 2,
           zlim = z_lims,
           col = colors,
           xlab = "u",
           ylab = "v",
           main = "Autocorrelation")
par(opar)

</code></pre>

<hr>
<h2 id='obtain_autocov_eigenvalues'>Estimate eigenvalues of the autocovariance function</h2><span id='topic+obtain_autocov_eigenvalues'></span>

<h3>Description</h3>

<p>Estimate the eigenvalues of the sample autocovariance
function <code class="reqn">\hat{C}_{0}</code>. This functions returns the
eigenvalues which are greater than the value <code>epsilon</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obtain_autocov_eigenvalues(v, Y, epsilon = 1e-04)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obtain_autocov_eigenvalues_+3A_v">v</code></td>
<td>
<p>Discretization points of the curves, by default
<code>seq(from = 0, to = 1, length.out = 100)</code>.</p>
</td></tr>
<tr><td><code id="obtain_autocov_eigenvalues_+3A_y">Y</code></td>
<td>
<p>Matrix containing the discretized values
of the functional time series. The dimension of the
matrix is <code class="reqn">(n x m)</code>, where <code class="reqn">n</code> is the
number of curves and <code class="reqn">m</code> is the number of points
observed in each curve.</p>
</td></tr>
<tr><td><code id="obtain_autocov_eigenvalues_+3A_epsilon">epsilon</code></td>
<td>
<p>Value used to determine how many
eigenvalues will be returned. The eigenvalues
<code class="reqn">\lambda_{j}/\lambda_{1} &gt; \code{epsilon}</code> 
will be returned.
By default <code>epsilon = 0.0001</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the <code class="reqn">k</code> eigenvalues
greater than <code>epsilon</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 100
v &lt;- seq(from = 0, to = 1, length.out = 10)
sig &lt;- 2
Y &lt;- simulate_iid_brownian_bridge(N, v, sig)
lambda &lt;- obtain_autocov_eigenvalues(v = v, Y = Y)

</code></pre>

<hr>
<h2 id='obtain_autocovariance'>Estimate the autocovariance function of the series</h2><span id='topic+obtain_autocovariance'></span>

<h3>Description</h3>

<p>Obtain the empirical autocovariance function for
lags <code class="reqn">= 0,...,</code><code>nlags</code> of the functional time
series. Given <code class="reqn">Y_{1},...,Y_{T}</code> a functional time
series, the sample autocovariance functions
<code class="reqn">\hat{C}_{h}(u,v)</code> are given by:
</p>
<p style="text-align: center;"><code class="reqn">\hat{C}_{h}(u,v) =  \frac{1}{T} \sum_{i=1}^{T-h}(Y_{i}(u) - \overline{Y}_{T}(u))(Y_{i+h}(v) - \overline{Y}_{T}(v))</code>
</p>

<p>where
<code class="reqn"> \overline{Y}_{T}(u) = \frac{1}{T} \sum_{i = 1}^{T} Y_{i}(t)</code>
denotes the sample mean function.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obtain_autocovariance(Y, nlags)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obtain_autocovariance_+3A_y">Y</code></td>
<td>
<p>Matrix containing the discretized values
of the functional time series. The dimension of the
matrix is <code class="reqn">(n x m)</code>, where <code class="reqn">n</code> is the
number of curves and <code class="reqn">m</code> is the number of points
observed in each curve.</p>
</td></tr>
<tr><td><code id="obtain_autocovariance_+3A_nlags">nlags</code></td>
<td>
<p>Number of lagged covariance operators
of the functional time series that will be used
to estimate the autocorrelation function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a list with the lagged autocovariance
functions estimated from the data. Each function is given
by a <code class="reqn">(m x m)</code> matrix, where <code class="reqn">m</code> is the
number of points observed in each curve.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1

N &lt;- 100
v &lt;- seq(from = 0, to = 1, length.out = 10)
sig &lt;- 2
bbridge &lt;- simulate_iid_brownian_bridge(N, v, sig)
nlags &lt;- 1
lagged_autocov &lt;- obtain_autocovariance(Y = bbridge,
                                        nlags = nlags)
image(x = v, y = v, z = lagged_autocov$Lag0)


# Example 2

N &lt;- 500
v &lt;- seq(from = 0, to = 1, length.out = 50)
sig &lt;- 2
bbridge &lt;- simulate_iid_brownian_bridge(N, v, sig)
nlags &lt;- 10
lagged_autocov &lt;- obtain_autocovariance(Y = bbridge,
                                        nlags = nlags)
image(x = v, y = v, z = lagged_autocov$Lag0)
image(x = v, y = v, z = lagged_autocov$Lag10)

# Example 3

require(fields)
N &lt;- 500
v &lt;- seq(from = 0, to = 1, length.out = 50)
sig &lt;- 2
bbridge &lt;- simulate_iid_brownian_bridge(N, v, sig)
nlags &lt;- 4
lagged_autocov &lt;- obtain_autocovariance(Y = bbridge,
                                        nlags = nlags)
z_lims &lt;- range(lagged_autocov$Lag0)
colors &lt;- heat.colors(12)
opar &lt;- par(no.readonly = TRUE)
par(mfrow = c(1,5))
par(oma=c( 0,0,0,6)) 
for(k in 0:nlags){
   image(x=v,
         y=v,
         z = lagged_autocov[[paste0("Lag",k)]],
         main = paste("Lag",k),
         col = colors,
         xlab = "u",
         ylab = "v")
}
par(oma=c( 0,0,0,2.5)) # reset margin to be much smaller.
image.plot( legend.only=TRUE, legend.width = 2,zlim=z_lims, col = colors)
par(opar)

</code></pre>

<hr>
<h2 id='obtain_FACF'>Obtain the autocorrelation function for a given functional time series.</h2><span id='topic+obtain_FACF'></span>

<h3>Description</h3>

<p>Estimate the lagged autocorrelation function for a given
functional time series and its distribution under the
hypothesis of strong functional white noise. This graphic tool
can be used to identify seasonal patterns in the functional
data as well as auto-regressive or moving average terms.
i.i.d. bounds are included to test the presence of serial
correlation in the data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obtain_FACF(Y, v, nlags, ci = 0.95, estimation = "MC", figure = TRUE,
  ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obtain_FACF_+3A_y">Y</code></td>
<td>
<p>Matrix containing the discretized values
of the functional time series. The dimension of the
matrix is <code class="reqn">(n x m)</code>, where <code class="reqn">n</code> is the
number of curves and <code class="reqn">m</code> is the number of points
observed in each curve.</p>
</td></tr>
<tr><td><code id="obtain_FACF_+3A_v">v</code></td>
<td>
<p>Discretization points of the curves, by default
<code>seq(from = 0, to = 1, length.out = 100)</code>.</p>
</td></tr>
<tr><td><code id="obtain_FACF_+3A_nlags">nlags</code></td>
<td>
<p>Number of lagged covariance operators
of the functional time series that will be used
to estimate the autocorrelation function.</p>
</td></tr>
<tr><td><code id="obtain_FACF_+3A_ci">ci</code></td>
<td>
<p>A value between 0 and 1 that indicates
the confidence interval for the i.i.d. bounds
of the autocorrelation function. By default
<code>ci = 0.95</code>.</p>
</td></tr>
<tr><td><code id="obtain_FACF_+3A_estimation">estimation</code></td>
<td>
<p>Character specifying the
method to be used when estimating the distribution
under the hypothesis of functional white noise.
Accepted values are:
</p>

<ul>
<li><p> &quot;MC&quot;: Monte-Carlo estimation.
</p>
</li>
<li><p> &quot;Imhof&quot;: Estimation using Imhof's method.
</p>
</li></ul>

<p>By default, <code>estimation = "MC"</code>.</p>
</td></tr>
<tr><td><code id="obtain_FACF_+3A_figure">figure</code></td>
<td>
<p>Logical. If <code>TRUE</code>, plots the
estimated autocorrelation function with the
specified i.i.d. bound.</p>
</td></tr>
<tr><td><code id="obtain_FACF_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the <code>plot_FACF</code>
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a list with:
</p>

<ul>
<li> <p><code>Blueline</code>: The upper prediction
bound for the i.i.d. distribution.
</p>
</li>
<li> <p><code>rho</code>: Autocorrelation values for
each lag of the functional time series.
</p>
</li></ul>



<h3>References</h3>

<p>Mestre G., Portela J., Rice G., Muñoz San Roque A., Alonso E. (2021).
<em>Functional time series model identification and diagnosis by 
means of auto- and partial autocorrelation analysis.</em>
Computational Statistics &amp; Data Analysis, 155, 107108.
<a href="https://doi.org/10.1016/j.csda.2020.107108">https://doi.org/10.1016/j.csda.2020.107108</a>
</p>
<p>Mestre, G., Portela, J., Muñoz-San Roque, A., Alonso, E. (2020).
<em>Forecasting hourly supply curves in the Italian Day-Ahead 
electricity market with a double-seasonal SARMAHX model.</em>
International Journal of Electrical Power &amp; Energy Systems, 
121, 106083. <a href="https://doi.org/10.1016/j.ijepes.2020.106083">https://doi.org/10.1016/j.ijepes.2020.106083</a>
</p>
<p>Kokoszka, P., Rice, G., Shang, H.L. (2017).
<em>Inference for the autocovariance of a functional
time series under conditional heteroscedasticity</em>
Journal of Multivariate Analysis, 
162, 32&ndash;50. <a href="https://doi.org/10.1016/j.jmva.2017.08.004">https://doi.org/10.1016/j.jmva.2017.08.004</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1

N &lt;- 100
v &lt;- seq(from = 0, to = 1, length.out = 5)
sig &lt;- 2
Y &lt;- simulate_iid_brownian_bridge(N, v, sig)
obtain_FACF(Y,v,20)


# Example 2

data(elec_prices)
v &lt;- seq(from = 1, to = 24)
nlags &lt;- 30
obtain_FACF(Y = as.matrix(elec_prices), 
v = v,
nlags = nlags,
ci = 0.95,
figure = TRUE)

</code></pre>

<hr>
<h2 id='obtain_FPACF'>Obtain the partial autocorrelation function for a given FTS.</h2><span id='topic+obtain_FPACF'></span>

<h3>Description</h3>

<p>Estimate the partial autocorrelation
function for a given functional time series and its
distribution under the hypothesis of strong functional
white noise.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>obtain_FPACF(Y, v, nlags, n_harm, ci = 0.95, estimation = "MC",
  figure = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obtain_FPACF_+3A_y">Y</code></td>
<td>
<p>Matrix containing the discretized values
of the functional time series. The dimension of the
matrix is <code class="reqn">(n x m)</code>, where <code class="reqn">n</code> is the
number of curves and <code class="reqn">m</code> is the number of points
observed in each curve.</p>
</td></tr>
<tr><td><code id="obtain_FPACF_+3A_v">v</code></td>
<td>
<p>Discretization points of the curves.</p>
</td></tr>
<tr><td><code id="obtain_FPACF_+3A_nlags">nlags</code></td>
<td>
<p>Number of lagged covariance operators
of the functional time series that will be used
to estimate the partial autocorrelation function.</p>
</td></tr>
<tr><td><code id="obtain_FPACF_+3A_n_harm">n_harm</code></td>
<td>
<p>Number of principal components
that will be used to fit the ARH(p) models.</p>
</td></tr>
<tr><td><code id="obtain_FPACF_+3A_ci">ci</code></td>
<td>
<p>A value between 0 and 1 that indicates
the confidence interval for the i.i.d. bounds
of the partial autocorrelation function. By default
<code>ci = 0.95</code>.</p>
</td></tr>
<tr><td><code id="obtain_FPACF_+3A_estimation">estimation</code></td>
<td>
<p>Character specifying the
method to be used when estimating the distribution
under the hypothesis of functional white noise.
Accepted values are:
</p>

<ul>
<li><p> &quot;MC&quot;: Monte-Carlo estimation.
</p>
</li>
<li><p> &quot;Imhof&quot;: Estimation using Imhof's method.
</p>
</li></ul>

<p>By default, <code>estimation = "MC"</code>.</p>
</td></tr>
<tr><td><code id="obtain_FPACF_+3A_figure">figure</code></td>
<td>
<p>Logical. If <code>TRUE</code>, plots the
estimated partial autocorrelation function with the
specified i.i.d. bound.</p>
</td></tr>
<tr><td><code id="obtain_FPACF_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the <code>plot_FACF</code>
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return a list with:
</p>

<ul>
<li> <p><code>Blueline</code>: The upper prediction
bound for the i.i.d. distribution.
</p>
</li>
<li> <p><code>rho</code>: Partial autocorrelation
coefficients for
each lag of the functional time series.
</p>
</li></ul>



<h3>References</h3>

<p>Mestre G., Portela J., Rice G., Muñoz San Roque A., Alonso E. (2021).
<em>Functional time series model identification and diagnosis by 
means of auto- and partial autocorrelation analysis.</em>
Computational Statistics &amp; Data Analysis, 155, 107108.
<a href="https://doi.org/10.1016/j.csda.2020.107108">https://doi.org/10.1016/j.csda.2020.107108</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1

N &lt;- 100
v &lt;- seq(from = 0, to = 1, length.out = 5)
sig &lt;- 2
set.seed(15)
Y &lt;- simulate_iid_brownian_bridge(N, v, sig)
obtain_FPACF(Y,v,10, n_harm = 2)


# Example 2

data(elec_prices)
v &lt;- seq(from = 1, to = 24)
nlags &lt;- 30
obtain_FPACF(Y = as.matrix(elec_prices), 
v = v,
nlags = nlags,
n_harm = 5, 
ci = 0.95,
figure = TRUE)

</code></pre>

<hr>
<h2 id='obtain_suface_L2_norm'>Obtain L2 norm of the autocovariance functions</h2><span id='topic+obtain_suface_L2_norm'></span>

<h3>Description</h3>

<p>Returns the L2 norm of the lagged autocovariance
functions <code class="reqn">\hat{C}_{h}</code>. The L2 norm of these
functions is defined as
</p>
<p style="text-align: center;"><code class="reqn">\sqrt(\int \int \hat{C}^{2}_{h}(u,v)du dv)</code>
</p>



<h3>Usage</h3>

<pre><code class='language-R'>obtain_suface_L2_norm(v, autocovSurface)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="obtain_suface_L2_norm_+3A_v">v</code></td>
<td>
<p>Discretization points of the curves, by default
<code>seq(from = 0, to = 1, length.out = 100)</code>.</p>
</td></tr>
<tr><td><code id="obtain_suface_L2_norm_+3A_autocovsurface">autocovSurface</code></td>
<td>
<p>An <code class="reqn">(m x m)</code> matrix with
the discretized values of the autocovariance operator
<code class="reqn">\hat{C}_{0}</code>, obtained by calling the
function <code>obtain_autocovariance</code>. The value
<code class="reqn">m</code> indicates the number of points observed in
each curve.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A vector containing the L2 norm of the
lagged autocovariance functions <code>autocovSurface</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1

N &lt;- 100
v &lt;- seq(from = 0, to = 1, length.out = 10)
sig &lt;- 2
Y &lt;- simulate_iid_brownian_bridge(N, v, sig)
nlags &lt;- 1
autocovSurface &lt;- obtain_autocovariance(Y=Y,nlags = nlags)
norms &lt;- obtain_suface_L2_norm(v = v,autocovSurface = autocovSurface)
plot_autocovariance(fun.autocovariance = autocovSurface,lag = 1)
title(sub = paste0("Lag ",1," - L2 Norm: ",norms[2]))


# Example 2

N &lt;- 400
v &lt;- seq(from = 0, to = 1, length.out = 50)
sig &lt;- 2
Y &lt;- simulate_iid_brownian_bridge(N, v, sig)
nlags &lt;- 2
autocovSurface &lt;- obtain_autocovariance(Y=Y,nlags = nlags)
norms &lt;- obtain_suface_L2_norm(v = v,autocovSurface = autocovSurface)
opar &lt;- par(no.readonly = TRUE)
par(mfrow = c(1,3))
plot_autocovariance(fun.autocovariance = autocovSurface,lag = 0)
title(sub = paste0("Lag ",0," - L2 Norm: ",norms[1]))
plot_autocovariance(fun.autocovariance = autocovSurface,lag = 1)
title(sub = paste0("Lag ",1," - L2 Norm: ",norms[2]))
plot_autocovariance(fun.autocovariance = autocovSurface,lag = 2)
title(sub = paste0("Lag ",2," - L2 Norm: ",norms[3]))
par(opar)

</code></pre>

<hr>
<h2 id='plot_autocovariance'>Generate a 3D plot of the autocovariance surface of a given FTS</h2><span id='topic+plot_autocovariance'></span>

<h3>Description</h3>

<p>Obtain a 3D plot of the autocovariance surfaces of a
given functional time series. This visualization is
useful to detect any kind of dependency between
the discretization points of the series.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_autocovariance(fun.autocovariance, lag = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_autocovariance_+3A_fun.autocovariance">fun.autocovariance</code></td>
<td>
<p>A list obtained by
calling the function <code>obtain_autocovariance</code>.</p>
</td></tr>
<tr><td><code id="plot_autocovariance_+3A_lag">lag</code></td>
<td>
<p>An integer between 0 and <code>nlags</code>, indicating
the lagged autocovariance function to be plotted.
By default 0.</p>
</td></tr>
<tr><td><code id="plot_autocovariance_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the  <code>persp</code>
function.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1

N &lt;- 100
v &lt;- seq(from = 0, to = 1, length.out = 10)
sig &lt;- 2
bbridge &lt;- simulate_iid_brownian_bridge(N, v, sig)
nlags &lt;- 1
lagged_autocov &lt;- obtain_autocovariance(Y = bbridge,nlags = nlags)
plot_autocovariance(lagged_autocov,1)


# Example 2

N &lt;- 500
v &lt;- seq(from = 0, to = 1, length.out = 50)
sig &lt;- 2
bbridge &lt;- simulate_iid_brownian_bridge(N, v, sig)
nlags &lt;- 4
lagged_autocov &lt;- obtain_autocovariance(Y = bbridge,nlags = nlags)
opar &lt;- par(no.readonly = TRUE)
par(mfrow = c(1,5))
for(k in 0:nlags){
   plot_autocovariance(lagged_autocov,k)
}
par(opar)

</code></pre>

<hr>
<h2 id='plot_FACF'>Plot the autocorrelation function of a given FTS</h2><span id='topic+plot_FACF'></span>

<h3>Description</h3>

<p>Plot a visual representation of the autocorrelation function
of a given functional time series, including the upper i.i.d.
bound.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_FACF(rho, Blueline, ci, ...)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="plot_FACF_+3A_rho">rho</code></td>
<td>
<p>Autocorrelation values for each lag of
the functional time series obtained by calling the
function <code>obtain_FACF</code>.</p>
</td></tr>
<tr><td><code id="plot_FACF_+3A_blueline">Blueline</code></td>
<td>
<p>The upper prediction bound for the
i.i.d. distribution obtained by calling the
function <code>obtain_FACF</code>.</p>
</td></tr>
<tr><td><code id="plot_FACF_+3A_ci">ci</code></td>
<td>
<p>Value between 0 and 1 that was used
when calling the function <code>obtain_FACF</code>.
This value is only used to display information
in the figure.</p>
</td></tr>
<tr><td><code id="plot_FACF_+3A_...">...</code></td>
<td>
<p>Further arguments passed to the  <code>plot</code>
function.</p>
</td></tr>
</table>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1

N &lt;- 100
v &lt;- seq(from = 0, to = 1, length.out = 10)
sig &lt;- 2
bbridge &lt;- simulate_iid_brownian_bridge(N, v, sig)
nlags &lt;- 15
upper_bound &lt;- 0.95
fACF &lt;- obtain_FACF(Y = bbridge,v = v,nlags = nlags,ci=upper_bound,figure = FALSE)
plot_FACF(rho = fACF$rho,Blueline = fACF$Blueline,ci = upper_bound)


# Example 2

N &lt;- 200
v &lt;- seq(from = 0, to = 1, length.out = 30)
sig &lt;- 2
bbridge &lt;- simulate_iid_brownian_bridge(N, v, sig)
nlags &lt;- 15
upper_bound &lt;- 0.95
fACF &lt;- obtain_FACF(Y = bbridge,v = v,nlags = nlags,ci=upper_bound,figure = FALSE)
plot_FACF(rho = fACF$rho,Blueline = fACF$Blueline,ci = upper_bound)

</code></pre>

<hr>
<h2 id='reconstruct_fd_from_PCA'>Obtain the reconstructed curves after PCA</h2><span id='topic+reconstruct_fd_from_PCA'></span>

<h3>Description</h3>

<p>This function reconstructs the
functional curves from a score vector
using the basis obtained after applying
functional PCA. This allows the user to
draw estimations from the joint density of
the FPCA scores and reconstruct the curves
for those new scores.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>reconstruct_fd_from_PCA(pca_struct, scores, centerfns = T)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="reconstruct_fd_from_PCA_+3A_pca_struct">pca_struct</code></td>
<td>
<p>List obtained after calling
function <code>pca.fd</code>.</p>
</td></tr>
<tr><td><code id="reconstruct_fd_from_PCA_+3A_scores">scores</code></td>
<td>
<p>Numerical vector that contains the
scores of the fPCA decomposition for one
functional observation.</p>
</td></tr>
<tr><td><code id="reconstruct_fd_from_PCA_+3A_centerfns">centerfns</code></td>
<td>
<p>Logical value specifying
wheter the FPCA performed used <code>centerfns = T</code>
or <code>centerfns = F</code>. By default
<code>centerfns = T</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a object of type <code>fd</code>
that contains the reconstructed curve.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Example 1

# Simulate fd
nobs &lt;- 200
dv &lt;- 10
basis&lt;-fda::create.bspline.basis(rangeval=c(0,1),nbasis=10)
set.seed(5)
C &lt;- matrix(rnorm(nobs*dv), ncol =  dv, nrow = nobs)
fd_sim &lt;- fda::fd(coef=t(C),basis)

# Perform FPCA
pca_struct &lt;- fda::pca.fd(fd_sim,nharm = 6)

# Reconstruct first curve
fd_rec &lt;- reconstruct_fd_from_PCA(pca_struct = pca_struct, scores = pca_struct$scores[1,])
plot(fd_sim[1])
plot(fd_rec, add = TRUE, col = "red")
legend("topright",
       legend = c("Real Curve", "PCA Reconstructed"),
       col = c("black","red"),
       lty = 1)

# Example 2 (Perfect reconstruction)

# Simulate fd
nobs &lt;- 200
dv &lt;- 7
basis&lt;-fda::create.bspline.basis(rangeval=c(0,1),nbasis=dv)
set.seed(5)
C &lt;- matrix(rnorm(nobs*dv), ncol =  dv, nrow = nobs)
fd_sim &lt;- fda::fd(coef=t(C),basis)

# Perform FPCA
pca_struct &lt;- fda::pca.fd(fd_sim,nharm = dv)

# Reconstruct first curve
fd_rec &lt;- reconstruct_fd_from_PCA(pca_struct = pca_struct, scores = pca_struct$scores[1,])
plot(fd_sim[1])
plot(fd_rec, add = TRUE, col = "red")
legend("topright",
       legend = c("Real Curve", "PCA Reconstructed"),
       col = c("black","red"),
       lty = 1)
</code></pre>

<hr>
<h2 id='simulate_iid_brownian_bridge'>Simulate a FTS from a brownian bridge process</h2><span id='topic+simulate_iid_brownian_bridge'></span>

<h3>Description</h3>

<p>Generate a functional time series from a Brownian Bridge process.
If <code class="reqn">W(t)</code> is a Wiener process, the Brownian Bridge is
defined as <code class="reqn">W(t) - tW(1)</code>.
Each functional observation is discretized in the points
indicated in <code>v</code>. The series obtained is i.i.d.
and does not exhibit any kind of serial correlation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_iid_brownian_bridge(N, v = seq(from = 0, to = 1, length.out =
  100), sig = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_iid_brownian_bridge_+3A_n">N</code></td>
<td>
<p>The number of observations of the simulated data.</p>
</td></tr>
<tr><td><code id="simulate_iid_brownian_bridge_+3A_v">v</code></td>
<td>
<p>Discretization points of the curves, by default
<code>seq(from = 0, to = 1, length.out = 100)</code>.</p>
</td></tr>
<tr><td><code id="simulate_iid_brownian_bridge_+3A_sig">sig</code></td>
<td>
<p>Standard deviation of the Brownian Motion process,
by default <code>1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return the simulated functional time series as a matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 100
v &lt;- seq(from = 0, to = 1, length.out = 20)
sig &lt;- 2
bbridge &lt;- simulate_iid_brownian_bridge(N, v, sig)
matplot(v,t(bbridge), type = "l", xlab = "v", ylab = "Value")
</code></pre>

<hr>
<h2 id='simulate_iid_brownian_motion'>Simulate a FTS from a brownian motion process</h2><span id='topic+simulate_iid_brownian_motion'></span>

<h3>Description</h3>

<p>Generate a functional time series from a Brownian Motion process.
Each functional observation is discretized in the points
indicated in <code>v</code>. The series obtained is i.i.d.
and does not exhibit any kind of serial correlation
</p>


<h3>Usage</h3>

<pre><code class='language-R'>simulate_iid_brownian_motion(N, v = seq(from = 0, to = 1, length.out =
  100), sig = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="simulate_iid_brownian_motion_+3A_n">N</code></td>
<td>
<p>The number of observations of the simulated data.</p>
</td></tr>
<tr><td><code id="simulate_iid_brownian_motion_+3A_v">v</code></td>
<td>
<p>Discretization points of the curves, by default
<code>seq(from = 0, to = 1, length.out = 100)</code>.</p>
</td></tr>
<tr><td><code id="simulate_iid_brownian_motion_+3A_sig">sig</code></td>
<td>
<p>Standard deviation of the Brownian Motion process,
by default <code>1</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Return the simulated functional time series as a matrix.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>N &lt;- 100
v &lt;- seq(from = 0, to = 1, length.out = 20)
sig &lt;- 2
bmotion &lt;- simulate_iid_brownian_motion(N, v, sig)
matplot(v,t(bmotion), type = "l", xlab = "v", ylab = "Value")
</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
