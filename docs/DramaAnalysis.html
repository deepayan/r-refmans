<!DOCTYPE html><html lang="en-US"><head><title>Help for package DramaAnalysis</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {DramaAnalysis}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#barplot.QDCharacterStatistics'><p>Stacked Bar Plot</p></a></li>
<li><a href='#base_dictionary'><p>Base dictionary</p></a></li>
<li><a href='#characterNames'><p>Format Names</p></a></li>
<li><a href='#characterStatistics'><p>Basic Character Statistics</p></a></li>
<li><a href='#combine'><p>Combine multiple plays</p></a></li>
<li><a href='#configuration'><p>Character Configuration</p></a></li>
<li><a href='#correlationAnalysis'><p>Correlation analysis</p></a></li>
<li><a href='#data'><p>Data sets</p></a></li>
<li><a href='#dictionaryStatistics'><p>Dictionary Use</p></a></li>
<li><a href='#dramaNames'><p>Format drama titles</p></a></li>
<li><a href='#ensureSuffix'><p>Utility functions</p></a></li>
<li><a href='#filterByDictionary'><p>Word frequencies</p></a></li>
<li><a href='#filterCharacters'><p>Filter characters</p></a></li>
<li><a href='#frequencytable2'><p>Extract bigrams instead of words (currently not taking utterance boundaries into account)</p></a></li>
<li><a href='#installCollectionData'><p>Download and install collection data</p></a></li>
<li><a href='#installData'><p>Download preprocessed drama data</p></a></li>
<li><a href='#isolateCharacterSpeech'><p>Isolate Character Speech</p></a></li>
<li><a href='#keyness'><p>Keywords</p></a></li>
<li><a href='#loadAllInstalledIds'><p>Installed texts</p></a></li>
<li><a href='#loadCharacters'><p>Character data loading</p></a></li>
<li><a href='#loadDrama'><p>Load drama</p></a></li>
<li><a href='#loadDramaTEI'><p>Load drama</p></a></li>
<li><a href='#loadFields'><p>Dictionary Handling</p></a></li>
<li><a href='#loadMeta'><p>Load meta data</p></a></li>
<li><a href='#loadSet'><p>Load Collections</p></a></li>
<li><a href='#loadText'><p>Load Text</p></a></li>
<li><a href='#mapPrefix'><p>Replace corpus prefix</p></a></li>
<li><a href='#newCollection'><p>Create or Extend a Collection</p></a></li>
<li><a href='#numberOfPlays'><p>Number of plays</p></a></li>
<li><a href='#personnelExchange'><p>Measuring Personnel Exchange over Boundaries</p></a></li>
<li><a href='#plot.QDHamming'><p>Personnel Exchange</p></a></li>
<li><a href='#plot.QDUtteranceStatistics'><p>Utterance positions</p></a></li>
<li><a href='#plotSpiderWebs'><p>Spider-Webs</p></a></li>
<li><a href='#postags'><p>Provides lists of groups of pos tags for various word classes.</p></a></li>
<li><a href='#presence'><p>Active and Passive Presence</p></a></li>
<li><a href='#qd.colors'><p>QuaDramA colors</p></a></li>
<li><a href='#report'><p>Report</p></a></li>
<li><a href='#segment'><p>Segment</p></a></li>
<li><a href='#setCollectionDirectory'><p>This function initializes the paths to data files.</p></a></li>
<li><a href='#split.QDDrama'><p>Split multiple plays</p></a></li>
<li><a href='#tfidf'><p>TF-IDF</p></a></li>
<li><a href='#utteranceStatistics'><p>Utterance Statistics</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Title:</td>
<td>Analysis of Dramatic Texts</td>
</tr>
<tr>
<td>Version:</td>
<td>3.0.2</td>
</tr>
<tr>
<td>Date:</td>
<td>2020-09-07</td>
</tr>
<tr>
<td>Language:</td>
<td>en-US</td>
</tr>
<tr>
<td>Description:</td>
<td>Analysis of preprocessed dramatic texts, with respect to literary research. 
  The package provides functions to analyze and visualize information about characters,
  stage directions, the dramatic structure and the text itself.
  The dramatic texts are expected to be in CSV format, which can be installed from within 
  the package, sample texts are provided. The package and the reasoning behind it are described in 
  Reiter et al. (2017) &lt;<a href="https://doi.org/10.18420%2Fin2017_119">doi:10.18420/in2017_119</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/quadrama/DramaAnalysis">https://github.com/quadrama/DramaAnalysis</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/quadrama/DramaAnalysis/issues">https://github.com/quadrama/DramaAnalysis/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL (&ge; 3)</a></td>
</tr>
<tr>
<td>LazyData:</td>
<td>TRUE</td>
</tr>
<tr>
<td>Imports:</td>
<td>stats, utils, reshape2 (&ge; 1.4.2), readr (&ge; 1.1.1),
data.table (&ge; 1.10.4), httr (&ge; 1.2.1), git2r (&ge; 0.24.0),
xml2 (&ge; 1.2.0), tokenizers (&ge; 0.2.1), stringr (&ge; 1.4.0)</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.3.0)</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.1.1</td>
</tr>
<tr>
<td>Suggests:</td>
<td>testthat, fmsb, knitr, magrittr, highcharter, rmarkdown (&ge;
1.8), igraph (&ge; 1.1.2)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2020-09-07 14:37:44 UTC; reiterns</td>
</tr>
<tr>
<td>Author:</td>
<td>Nils Reiter [aut, cre] (0000-0003-3193-6170),
  Tim Strohmayer [ctb],
  Janis Pagel [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nils Reiter &lt;nils.reiter@ims.uni-stuttgart.de&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2020-09-18 15:00:07 UTC</td>
</tr>
</table>
<hr>
<h2 id='barplot.QDCharacterStatistics'>Stacked Bar Plot</h2><span id='topic+barplot.QDCharacterStatistics'></span>

<h3>Description</h3>

<p>This function expects an object of type QDCharacterStatistics and 
plots the specified column as a stacked bar plot.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'QDCharacterStatistics'
barplot(
  height,
  col = qd.colors,
  column = "tokens",
  order = -1,
  labels = TRUE,
  top = 5,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="barplot.QDCharacterStatistics_+3A_height">height</code></td>
<td>
<p>The object of class QDCharacterStatistics that is to be plotted</p>
</td></tr>
<tr><td><code id="barplot.QDCharacterStatistics_+3A_col">col</code></td>
<td>
<p>The colors to use</p>
</td></tr>
<tr><td><code id="barplot.QDCharacterStatistics_+3A_column">column</code></td>
<td>
<p>Which column of the character statistics should be used?</p>
</td></tr>
<tr><td><code id="barplot.QDCharacterStatistics_+3A_order">order</code></td>
<td>
<p>Sort the fields inversely</p>
</td></tr>
<tr><td><code id="barplot.QDCharacterStatistics_+3A_labels">labels</code></td>
<td>
<p>Whether to add character labels into the plot</p>
</td></tr>
<tr><td><code id="barplot.QDCharacterStatistics_+3A_top">top</code></td>
<td>
<p>Limit the labels to the top 5 characters. Otherwise, 
labels will become unreadable.</p>
</td></tr>
<tr><td><code id="barplot.QDCharacterStatistics_+3A_...">...</code></td>
<td>
<p>All remaining options are passed to <code>barplot.default()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See <code>barplot.default()</code>.
</p>


<h3>See Also</h3>

<p>barplot.default
</p>

<hr>
<h2 id='base_dictionary'>Base dictionary</h2><span id='topic+base_dictionary'></span>

<h3>Description</h3>

<p>A list of word fields, i.e., collections of German lemmas associated 
with the five concepts Familie (family), Krieg (war), Liebe (love), Ratio 
(reason) and Religion (religion). The base dictionary is for <em>demo purposes</em> 
only, because it doesn't contain any umlaut characters.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>base_dictionary
</code></pre>


<h3>Format</h3>

<p>A list with five entries, each of them being a character vector.
</p>

<hr>
<h2 id='characterNames'>Format Names</h2><span id='topic+characterNames'></span>

<h3>Description</h3>

<p>The function <code>characterNames()</code> is applicable on 
all tables with a character table 
(that are of the class <code>QDHasCharacter</code>). It can be used to reformat the character 
names. The function <code>FUN</code> is applied to the character <em>name</em> entries within 
the <code>QDDrama</code> object. The factor levels in the character column of <code>x</code> are replaced by 
the result values of <code>FUN</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>characterNames(x, drama, FUN = stringr::str_to_title, sort = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="characterNames_+3A_x">x</code></td>
<td>
<p>The object in which we want to transform names, needs to inherit the type <code>QDHasCharacter</code>.</p>
</td></tr>
<tr><td><code id="characterNames_+3A_drama">drama</code></td>
<td>
<p>The QDDrama object with all the information.</p>
</td></tr>
<tr><td><code id="characterNames_+3A_fun">FUN</code></td>
<td>
<p>A function applied to the strings. 
Defaults to <code>stringr::str_to_title</code>, which
converts the strings to title case.</p>
</td></tr>
<tr><td><code id="characterNames_+3A_sort">sort</code></td>
<td>
<p>Numeric. If set to a non-zero value, the resulting data.frame will be sorted 
alphabetically
according to the drama and character name. If the value is above 0, the 
sorting will be ascending, if set to a negative value, the sorting is 
descending. If sort is set to 0 (the default), the order is unchanged. 
The ordering can also be specified explicitly, by passing an integer vector 
with as many elements as <code>x</code> has rows.</p>
</td></tr>
<tr><td><code id="characterNames_+3A_...">...</code></td>
<td>
<p>All other arguments are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns <code>x</code>, but with modified character
names.
</p>


<h3>See Also</h3>

<p><code>str_to_title</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rksp.0)
ustat &lt;- utteranceStatistics(rksp.0)
ustat &lt;- characterNames(ustat, rksp.0)
</code></pre>

<hr>
<h2 id='characterStatistics'>Basic Character Statistics</h2><span id='topic+characterStatistics'></span>

<h3>Description</h3>

<p>This function extracts character statistics from a drama object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>characterStatistics(
  drama,
  normalize = FALSE,
  segment = c("Drama", "Act", "Scene"),
  filterPunctuation = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="characterStatistics_+3A_drama">drama</code></td>
<td>
<p>A <code>QDDrama</code> object</p>
</td></tr>
<tr><td><code id="characterStatistics_+3A_normalize">normalize</code></td>
<td>
<p>Normalizing the individual columns</p>
</td></tr>
<tr><td><code id="characterStatistics_+3A_segment">segment</code></td>
<td>
<p>&quot;Drama&quot;, &quot;Act&quot;, or &quot;Scene&quot;. Allows calculating statistics on segments of the play</p>
</td></tr>
<tr><td><code id="characterStatistics_+3A_filterpunctuation">filterPunctuation</code></td>
<td>
<p>Whether to exclude all punctuation from token counts</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data frame with the additional classes 
<code>QDCharacterStatistics</code> and <code>QDHasCharacter</code>. It has following 
columns and one row for each character:
tokens: The number of tokens spoken by that character
types : The number of different tokens (= types) spoken by each character
utterances: The number of utterances
utteranceLengthMean: The mean length of utterances
utteranceLengthSd: The standard deviation in utterance length
</p>


<h3>See Also</h3>

<p><code><a href="#topic+characterNames">characterNames</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rksp.0)
stat &lt;- characterStatistics(rksp.0)
</code></pre>

<hr>
<h2 id='combine'>Combine multiple plays</h2><span id='topic+combine'></span>

<h3>Description</h3>

<p>The function <code>combine(x, y)</code> can be used to merge 
multiple objects of the type <code>QDDrama</code> into one.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>combine(x, y)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="combine_+3A_x">x</code></td>
<td>
<p>A <code>QDDrama</code></p>
</td></tr>
<tr><td><code id="combine_+3A_y">y</code></td>
<td>
<p>A <code>QDDrama</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A single QDDrama object that represents both plays.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
data(rksp.0)
data(rjmw.0)
d &lt;- combine(rjmw.0, rksp.0)
</code></pre>

<hr>
<h2 id='configuration'>Character Configuration</h2><span id='topic+configuration'></span><span id='topic+as.matrix.QDConfiguration'></span>

<h3>Description</h3>

<p>The function <code>configuration(...)</code> Creates drama configuration matrix as a <code>QDConfiguration</code> object, which is also a data.frame. The S3 function <code>as.matrix()</code> can be used to extract a numeric or logical matrix containing the core.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>configuration(
  d,
  segment = c("Act", "Scene"),
  mode = c("Active", "Passive"),
  onlyPresence = FALSE
)

## S3 method for class 'QDConfiguration'
as.matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="configuration_+3A_d">d</code></td>
<td>
<p>A <code>QDDrama</code> object</p>
</td></tr>
<tr><td><code id="configuration_+3A_segment">segment</code></td>
<td>
<p>A character vector, either &quot;Act&quot; or &quot;Scene&quot;. Partial matching allowed.</p>
</td></tr>
<tr><td><code id="configuration_+3A_mode">mode</code></td>
<td>
<p>Character vector, should be either &quot;Active&quot; or &quot;Passive&quot;.
Passive configurations express when characters are mentioned, active
ones when they speak themselves. Please note that extracting passive 
configuration only makes sense if some form of coreference resolution 
has taken place on the text, either manually or automatic. If not, 
only very basic references (first person pronouns and proper names) are 
represented, which usually gives a very wrong impression.</p>
</td></tr>
<tr><td><code id="configuration_+3A_onlypresence">onlyPresence</code></td>
<td>
<p>If TRUE, the function only records whether a character was present. If FALSE (which is the default), the function counts the number of tokens spoken (active) or referenced (passive).</p>
</td></tr>
<tr><td><code id="configuration_+3A_x">x</code></td>
<td>
<p>An object of class QDConfiguration</p>
</td></tr>
<tr><td><code id="configuration_+3A_...">...</code></td>
<td>
<p>All other arguments are passed to <code>as.matrix.data.frame</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Drama configuration matrix as a <code>QDConfiguration</code> object (of type <code>data.frame</code>).
</p>


<h3>Active and Passive Configurations</h3>

<p>By default, we generate active matrices that are based on 
the character speech. A character is present in a scene or 
act, if they make an utterance. 
Using the argument <code>mode</code>, we can also create passive
configuration matrices. They look very similar, but are based
on who's mentioned in a scene or an act.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+characterNames">characterNames</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Active configuration matrix
data(rksp.0)
cfg &lt;- configuration(rksp.0)

# Passive configuration matrix
cfg &lt;- configuration(rksp.0, mode="Passive")

</code></pre>

<hr>
<h2 id='correlationAnalysis'>Correlation analysis</h2><span id='topic+correlationAnalysis'></span>

<h3>Description</h3>

<p>Calculates correlation of a frequency table with an outcome 
list according to given method. The function currently only works for 
pairwise correlation, i.e., two categories. Note that the function 
<code><a href="#topic+keyness">keyness</a>()</code> is actually better to do the same thing, and this function
should not be used anymore in this fashion.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>correlationAnalysis(text.ft, categories, method = "spearman", culling = 0, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="correlationAnalysis_+3A_text.ft">text.ft</code></td>
<td>
<p>A matrix, containing words in columns and characters (or plays) in rows. 
This can be the result of the <code><a href="#topic+frequencytable">frequencytable</a>()</code> function.</p>
</td></tr>
<tr><td><code id="correlationAnalysis_+3A_categories">categories</code></td>
<td>
<p>A factor or numeric vector that represents a list of categories.</p>
</td></tr>
<tr><td><code id="correlationAnalysis_+3A_method">method</code></td>
<td>
<p>The correlation method, passed on to cor()</p>
</td></tr>
<tr><td><code id="correlationAnalysis_+3A_culling">culling</code></td>
<td>
<p>An integer. Words that appear in less items are removed. 
Defaults to 0 which doesn't remove anything.</p>
</td></tr>
<tr><td><code id="correlationAnalysis_+3A_...">...</code></td>
<td>
<p>Arguments passed to <code><a href="stats.html#topic+cor">cor</a>()</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a data.frame with three columns: The word, 
it's correlation score, and the category it is correlated to. The latter is 
mainly for an easier use of the results.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rksp.0)
ft &lt;- frequencytable(rksp.0, byCharacter=TRUE)
g &lt;- factor(c("m","m","m","m","f","m","m","m","f","m","m","f","m"))
rksp.0.cor &lt;- correlationAnalysis(ft, g)

# to pre-filter by the total frequency of a word
ft &lt;- frequencytable(rksp.0, byCharacter=TRUE)
ft &lt;- ft[,colSums(ft) &gt; 5]
correlationAnalysis(ft, g)
</code></pre>

<hr>
<h2 id='data'>Data sets</h2><span id='topic+data'></span><span id='topic+rksp.0'></span><span id='topic+rjmw.0'></span>

<h3>Description</h3>

<p><code>rksp.0</code> represents the data set exported from Lessings 
Emilia Galotti, <code>rjmw.0</code> is the one exported from Miss Sara Sampson 
(also written by Lessing). Please note that in both plays, special 
characters have been removed for technical reasons. The text is German, 
but all umlauts have been replaced by another character. This is only a 
restriction of the pre-packaged files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>rksp.0

rjmw.0
</code></pre>


<h3>Format</h3>

<p>A list containing data.frames and data.table.
</p>
<p>An object of class <code>QDDrama</code> (inherits from <code>list</code>) of length 6.
</p>

<hr>
<h2 id='dictionaryStatistics'>Dictionary Use</h2><span id='topic+dictionaryStatistics'></span><span id='topic+dictionaryStatisticsSingle'></span><span id='topic+as.matrix.QDDictionaryStatistics'></span>

<h3>Description</h3>

<p>These methods retrieve 
count the number of occurrences of the words in the dictionaries, 
across different speakers and/or segments.
The function <code>dictionaryStatistics()</code> calculates statistics for 
dictionaries with multiple entries, <code>dictionaryStatisticsSingle()</code> only
for a single word list.
</p>
<p>Extract the number part from a 
<code>QDDictionaryStatistics</code> table as a matrix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dictionaryStatistics(
  drama,
  fields = DramaAnalysis::base_dictionary[fieldnames],
  fieldnames = c("Liebe"),
  segment = c("Drama", "Act", "Scene"),
  normalizeByCharacter = FALSE,
  normalizeByField = FALSE,
  byCharacter = TRUE,
  column = "Token.lemma",
  ci = TRUE
)

dictionaryStatisticsSingle(
  drama,
  wordfield = c(),
  segment = c("Drama", "Act", "Scene"),
  normalizeByCharacter = FALSE,
  normalizeByField = FALSE,
  byCharacter = TRUE,
  fieldNormalizer = length(wordfield),
  column = "Token.lemma",
  ci = TRUE,
  colnames = NULL
)

## S3 method for class 'QDDictionaryStatistics'
as.matrix(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dictionaryStatistics_+3A_drama">drama</code></td>
<td>
<p>A QDDrama object.</p>
</td></tr>
<tr><td><code id="dictionaryStatistics_+3A_fields">fields</code></td>
<td>
<p>A list of lists that contains the actual field names. 
By default, we load the <code>base_dictionary</code>.</p>
</td></tr>
<tr><td><code id="dictionaryStatistics_+3A_fieldnames">fieldnames</code></td>
<td>
<p>A list of names for the dictionaries.</p>
</td></tr>
<tr><td><code id="dictionaryStatistics_+3A_segment">segment</code></td>
<td>
<p>The segment level that should be used. By default, 
the entire play will be used. Possible values are &quot;Drama&quot; (default), 
&quot;Act&quot; or &quot;Scene&quot;.</p>
</td></tr>
<tr><td><code id="dictionaryStatistics_+3A_normalizebycharacter">normalizeByCharacter</code></td>
<td>
<p>Logical. Whether to normalize by character 
speech length.</p>
</td></tr>
<tr><td><code id="dictionaryStatistics_+3A_normalizebyfield">normalizeByField</code></td>
<td>
<p>Logical. Whether to normalize by dictionary 
size. You usually want this.</p>
</td></tr>
<tr><td><code id="dictionaryStatistics_+3A_bycharacter">byCharacter</code></td>
<td>
<p>Logical, defaults to TRUE. If false, values will be calculated
for the entire segment (play, act, or scene), and not for individual characters.</p>
</td></tr>
<tr><td><code id="dictionaryStatistics_+3A_column">column</code></td>
<td>
<p>The table column we apply the dictionary on. 
Should be either &quot;Token.surface&quot; or &quot;Token.lemma&quot;, the latter is the default.</p>
</td></tr>
<tr><td><code id="dictionaryStatistics_+3A_ci">ci</code></td>
<td>
<p>Whether to ignore case. Defaults to TRUE, i.e., case is ignored.</p>
</td></tr>
<tr><td><code id="dictionaryStatistics_+3A_wordfield">wordfield</code></td>
<td>
<p>A character vector containing the words or lemmas 
to be counted (only for <code>*Single</code>-functions)</p>
</td></tr>
<tr><td><code id="dictionaryStatistics_+3A_fieldnormalizer">fieldNormalizer</code></td>
<td>
<p>Defaults to the length of the wordfield. 
If normalizeByField is given, the absolute numbers are divided 
by this number.</p>
</td></tr>
<tr><td><code id="dictionaryStatistics_+3A_colnames">colnames</code></td>
<td>
<p>The column names to be used in the output table.</p>
</td></tr>
<tr><td><code id="dictionaryStatistics_+3A_x">x</code></td>
<td>
<p>An object of the type <code>QDDictionaryStatistics</code>, 
e.g., the output of <code>dictionaryStatistics</code>.</p>
</td></tr>
<tr><td><code id="dictionaryStatistics_+3A_...">...</code></td>
<td>
<p>All other parameters are passed to <code>as.matrix.data.frame()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A numeric matrix that contains the frequency with which 
a dictionary is present in a subset of tokens
</p>


<h3>See Also</h3>

<p><code><a href="#topic+loadFields">loadFields</a></code> <code><a href="#topic+characterNames">characterNames</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Check multiple dictionary entries
data(rksp.0)
dstat &lt;- dictionaryStatistics(rksp.0, fieldnames=c("Krieg","Familie"))
# Check a single dictionary entries
data(rksp.0)
fstat &lt;- dictionaryStatisticsSingle(rksp.0, wordfield=c("der"))
mat &lt;- as.matrix(dictionaryStatistics(rksp.0, fieldnames=c("Krieg","Familie")))
</code></pre>

<hr>
<h2 id='dramaNames'>Format drama titles</h2><span id='topic+dramaNames'></span>

<h3>Description</h3>

<p>Given a QDDrama object, this function generates a list of nicely 
formatted names, following the format string.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dramaNames(x, ids = NULL, formatString = "%A: %T (%DM)", orderBy = "drama")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dramaNames_+3A_x">x</code></td>
<td>
<p>The QDDrama object</p>
</td></tr>
<tr><td><code id="dramaNames_+3A_ids">ids</code></td>
<td>
<p>If specified, should be a character vector of play ids (prefixed with corpus). 
Then the return value only contains the plays in the vector and in the order specified.</p>
</td></tr>
<tr><td><code id="dramaNames_+3A_formatstring">formatString</code></td>
<td>
<p>A character vector. Contains special symbols that
are replaced by meta data entries about the plays. The following symbols can
be used:
- %T: title of the play
- %A: Author name 
- %P: GND entry of the author (if known)
- %DR, 
- %DM: The minimal date 
- %L: The language
- %I: The id
- %C: The corpus prefix</p>
</td></tr>
<tr><td><code id="dramaNames_+3A_orderby">orderBy</code></td>
<td>
<p>The meta data key that the final list will be ordered by</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Character vector of formatted drama names
</p>

<hr>
<h2 id='ensureSuffix'>Utility functions</h2><span id='topic+ensureSuffix'></span>

<h3>Description</h3>

<p><code>ensureSuffix</code> makes certain that a character vector ends in 
a given suffix
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ensureSuffix(x, suffix)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ensureSuffix_+3A_x">x</code></td>
<td>
<p>The character vector</p>
</td></tr>
<tr><td><code id="ensureSuffix_+3A_suffix">suffix</code></td>
<td>
<p>The suffix</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The input character vector with the desired suffix
</p>

<hr>
<h2 id='filterByDictionary'>Word frequencies</h2><span id='topic+filterByDictionary'></span><span id='topic+frequencytable'></span>

<h3>Description</h3>

<p>The function <code>filterByDictionary()</code> can be used to filter a matrix as produced by 
<code>frequencytable()</code> by the words in the given dictionary(/-ies).
</p>
<p>The function <code>frequencytable()</code> generates a matrix of word frequencies 
by drama, act or scene and/or by character. The output of this function can be fed to stylo.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filterByDictionary(
  ft,
  fields = DramaAnalysis::base_dictionary[fieldnames],
  fieldnames = c("Liebe")
)

frequencytable(
  drama,
  acceptedPOS = postags$de$words,
  column = "Token.lemma",
  byCharacter = FALSE,
  sep = "|",
  normalize = FALSE,
  sortResult = FALSE,
  segment = c("Drama", "Act", "Scene")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filterByDictionary_+3A_ft">ft</code></td>
<td>
<p>A matrix as produced by <code>frequencytable()</code>.</p>
</td></tr>
<tr><td><code id="filterByDictionary_+3A_fields">fields</code></td>
<td>
<p>A list of lists that contains the actual field names. 
By default, we load the base_dictionary (as in <code>dictionaryStatistics()</code>).</p>
</td></tr>
<tr><td><code id="filterByDictionary_+3A_fieldnames">fieldnames</code></td>
<td>
<p>A list of names for the dictionaries.</p>
</td></tr>
<tr><td><code id="filterByDictionary_+3A_drama">drama</code></td>
<td>
<p>A <code>QDDrama</code>. May be covering multiple texts.</p>
</td></tr>
<tr><td><code id="filterByDictionary_+3A_acceptedpos">acceptedPOS</code></td>
<td>
<p>A list of accepted pos tags. Words of all POS tags not in this list 
are filtered out. Specify NULL or an empty list to include all words.</p>
</td></tr>
<tr><td><code id="filterByDictionary_+3A_column">column</code></td>
<td>
<p>The column name we should use (should be either Token.surface or Token.lemma)</p>
</td></tr>
<tr><td><code id="filterByDictionary_+3A_bycharacter">byCharacter</code></td>
<td>
<p>Logical. Whether the count is by character or by text.</p>
</td></tr>
<tr><td><code id="filterByDictionary_+3A_sep">sep</code></td>
<td>
<p>The separation symbol that goes between drama name and character (if applicable). 
Defaults to the pipe symbol.</p>
</td></tr>
<tr><td><code id="filterByDictionary_+3A_normalize">normalize</code></td>
<td>
<p>Whether to normalize values or not. If set to TRUE, the values are normalized by
row sums.</p>
</td></tr>
<tr><td><code id="filterByDictionary_+3A_sortresult">sortResult</code></td>
<td>
<p>Logical. If true, the columns with the highest sum are ordered left (i.e., frequent words are visible first). If false, the columns are ordered alphabetically by column name.</p>
</td></tr>
<tr><td><code id="filterByDictionary_+3A_segment">segment</code></td>
<td>
<p>Character vector. Whether the count is by drama (default), act or scene</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of word frequencies in the format words X segments
</p>


<h3>See Also</h3>

<p><code>stylo</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rksp.0)
ftable &lt;- frequencytable(rksp.0, 
                         byCharacter = TRUE)
                                              
filtered &lt;- filterByDictionary(ftable, 
                               fieldnames=c("Krieg", "Familie"))

data(rksp.0)
st &lt;- frequencytable(rksp.0)
</code></pre>

<hr>
<h2 id='filterCharacters'>Filter characters</h2><span id='topic+filterCharacters'></span>

<h3>Description</h3>

<p>This function can be used to filter characters from all tables 
that contain  a character column (and are of the class QDHasCharacter).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>filterCharacters(
  hasCharacter,
  drama,
  by = c("rank", "tokens", "name"),
  n = ifelse(by == "tokens", 500, ifelse(by == "rank", 10, c()))
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="filterCharacters_+3A_hascharacter">hasCharacter</code></td>
<td>
<p>The object we want to filter.</p>
</td></tr>
<tr><td><code id="filterCharacters_+3A_drama">drama</code></td>
<td>
<p>The QDDrama object.</p>
</td></tr>
<tr><td><code id="filterCharacters_+3A_by">by</code></td>
<td>
<p>Character vector. Specifies the filter mechanism.</p>
</td></tr>
<tr><td><code id="filterCharacters_+3A_n">n</code></td>
<td>
<p>The threshold or a list of character names/ids to keep.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The function supports three filter mechanisms: The filter by 
<code>rank</code> sorts the characters according to the number of tokens they speak
and <em>keeps</em> the top $n$ characters. The filter called <code>tokens</code> keeps 
all characters that speak $n$ or more tokens. The filter called <code>name</code> 
keeps the characters that are provided by name as a vector as <code>n</code>.
</p>


<h3>Value</h3>

<p>The filtered QDHasCharacter object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rjmw.0)
dstat &lt;- dictionaryStatistics(rjmw.0)
filterCharacters(dstat, rjmw.0, by="tokens", n=1000)


</code></pre>

<hr>
<h2 id='frequencytable2'>Extract bigrams instead of words (currently not taking utterance boundaries into account)</h2><span id='topic+frequencytable2'></span>

<h3>Description</h3>

<p>Extract bigrams instead of words (currently not taking utterance boundaries into account)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>frequencytable2(
  t,
  acceptedPOS = postags$de$words,
  names = FALSE,
  column = c("Token.surface", "Token.surface"),
  byCharacter = FALSE,
  segment = c("Drama", "Act", "Scene")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="frequencytable2_+3A_t">t</code></td>
<td>
<p>The text</p>
</td></tr>
<tr><td><code id="frequencytable2_+3A_acceptedpos">acceptedPOS</code></td>
<td>
<p>A list of accepted pos tags</p>
</td></tr>
<tr><td><code id="frequencytable2_+3A_names">names</code></td>
<td>
<p>Whether to use character names or ids</p>
</td></tr>
<tr><td><code id="frequencytable2_+3A_column">column</code></td>
<td>
<p>The column names we should use (should be either Token.surface or Token.lemma)</p>
</td></tr>
<tr><td><code id="frequencytable2_+3A_bycharacter">byCharacter</code></td>
<td>
<p>Wether the count is by character or by text</p>
</td></tr>
<tr><td><code id="frequencytable2_+3A_segment">segment</code></td>
<td>
<p>Whether the count is by drama (default), act or scene</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Matrix of bigram frequencies in the format bigrams X segments
</p>

<hr>
<h2 id='installCollectionData'>Download and install collection data</h2><span id='topic+installCollectionData'></span>

<h3>Description</h3>

<p>Function to download collection data (grouped texts) from github. 
Overwrites (!) the current collections.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>installCollectionData(
  dataDirectory = getOption("qd.datadir"),
  branchOrCommit = "master",
  repository = "metadata",
  baseUrl = "https://github.com/quadrama/"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="installCollectionData_+3A_datadirectory">dataDirectory</code></td>
<td>
<p>The data directory in which collection and data files are stored</p>
</td></tr>
<tr><td><code id="installCollectionData_+3A_branchorcommit">branchOrCommit</code></td>
<td>
<p>The git branch, commit id, or tag that we want to download</p>
</td></tr>
<tr><td><code id="installCollectionData_+3A_repository">repository</code></td>
<td>
<p>The repository</p>
</td></tr>
<tr><td><code id="installCollectionData_+3A_baseurl">baseUrl</code></td>
<td>
<p>The github user (or group)</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>

<hr>
<h2 id='installData'>Download preprocessed drama data</h2><span id='topic+installData'></span>

<h3>Description</h3>

<p>This function downloads pre-processed dramatic texts via http and stores them locally in your data directory
</p>


<h3>Usage</h3>

<pre><code class='language-R'>installData(
  dataSource = "tg",
  dataDirectory = getOption("qd.datadir"),
  downloadSource = "ims",
  removeZipFile = TRUE,
  baseUrl = "https://github.com/quadrama",
  remoteUrl = paste0(baseUrl, "/data_", dataSource, ".git")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="installData_+3A_datasource">dataSource</code></td>
<td>
<p>Currently, only &quot;tg&quot; (textgrid) is supported</p>
</td></tr>
<tr><td><code id="installData_+3A_datadirectory">dataDirectory</code></td>
<td>
<p>The directory in which the data is to be stored</p>
</td></tr>
<tr><td><code id="installData_+3A_downloadsource">downloadSource</code></td>
<td>
<p>No longer used.</p>
</td></tr>
<tr><td><code id="installData_+3A_removezipfile">removeZipFile</code></td>
<td>
<p>No longer used.</p>
</td></tr>
<tr><td><code id="installData_+3A_baseurl">baseUrl</code></td>
<td>
<p>The remote repository owner (e.g., https://github.com/quadrama)</p>
</td></tr>
<tr><td><code id="installData_+3A_remoteurl">remoteUrl</code></td>
<td>
<p>The URL of the remote repository.</p>
</td></tr>
</table>


<h3>Value</h3>

<p><code>NULL</code>
</p>

<hr>
<h2 id='isolateCharacterSpeech'>Isolate Character Speech</h2><span id='topic+isolateCharacterSpeech'></span>

<h3>Description</h3>

<p><code>isolateCharacterSpeech()</code> isolates the speeches
of individual characters and optionally saves them in separate text files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>isolateCharacterSpeech(
  drama,
  segment = c("Drama", "Act", "Scene"),
  minTokenCount = 0,
  countPunctuation = TRUE,
  writeToFiles = TRUE,
  dir = getOption("qd.datadir")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="isolateCharacterSpeech_+3A_drama">drama</code></td>
<td>
<p>A text (or multiple texts, as a QDDrama object)</p>
</td></tr>
<tr><td><code id="isolateCharacterSpeech_+3A_segment">segment</code></td>
<td>
<p>&quot;Drama&quot;, &quot;Act&quot;, or &quot;Scene&quot;. Determines on what segment-level the speech is isolated.</p>
</td></tr>
<tr><td><code id="isolateCharacterSpeech_+3A_mintokencount">minTokenCount</code></td>
<td>
<p>The minimal token count for a speech to be considered (default = 0)</p>
</td></tr>
<tr><td><code id="isolateCharacterSpeech_+3A_countpunctuation">countPunctuation</code></td>
<td>
<p>Whether to include punctuation in minTokenCount (default = TRUE)</p>
</td></tr>
<tr><td><code id="isolateCharacterSpeech_+3A_writetofiles">writeToFiles</code></td>
<td>
<p>Whether to write each isolated speech into a new text file (default = TRUE)</p>
</td></tr>
<tr><td><code id="isolateCharacterSpeech_+3A_dir">dir</code></td>
<td>
<p>The directory into which the files will be written (default = data directory)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list of character vectors, each corresponding to character speeches as defined by <code>segment</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rksp.0)
isolateCharacterSpeech(rksp.0, segment="Scene", writeToFiles=FALSE)
</code></pre>

<hr>
<h2 id='keyness'>Keywords</h2><span id='topic+keyness'></span>

<h3>Description</h3>

<p>Given a frequency table (with texts as rows and words as columns),
this function calculates log-likelihood and log ratio of one set of rows against the other rows. 
The return value is a list containing scores for each word. If the method 
is <code>loglikelihood</code>, the returned scores are unsigned G2 values. To estimate the 
<em>direction</em> of the keyness, the <code>log ratio</code> is more informative. A nice introduction 
into log ratio can be found <a href="http://cass.lancs.ac.uk/log-ratio-an-informal-introduction/">here</a>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>keyness(
  ft,
  categories = c(1, rep(2, nrow(ft) - 1)),
  epsilon = 1e-100,
  siglevel = 0.05,
  method = c("loglikelihood", "logratio"),
  minimalFrequency = 10
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="keyness_+3A_ft">ft</code></td>
<td>
<p>The frequency table</p>
</td></tr>
<tr><td><code id="keyness_+3A_categories">categories</code></td>
<td>
<p>A factor or numeric vector that represents an assignment of categories.</p>
</td></tr>
<tr><td><code id="keyness_+3A_epsilon">epsilon</code></td>
<td>
<p>null values are replaced by this value, in order to avoid division by zero</p>
</td></tr>
<tr><td><code id="keyness_+3A_siglevel">siglevel</code></td>
<td>
<p>Return only the keywords above the significance level. Set to 1 to get all words</p>
</td></tr>
<tr><td><code id="keyness_+3A_method">method</code></td>
<td>
<p>Either &quot;logratio&quot; or &quot;loglikelihood&quot; (default)</p>
</td></tr>
<tr><td><code id="keyness_+3A_minimalfrequency">minimalFrequency</code></td>
<td>
<p>Words less frequent than this value are not considered at all</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list of keywords, sorted by their log-likelihood or log ratio value, calculated according to <a href="http://ucrel.lancs.ac.uk/llwizard.html">http://ucrel.lancs.ac.uk/llwizard.html</a>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data("rksp.0")
ft &lt;- frequencytable(rksp.0, byCharacter = TRUE, normalize = FALSE)
# Calculate log ratio for all words
genders &lt;- factor(c("m", "m", "m", "m", "f", "m", "m", "m", "f", "m", "m", "f", "m"))
keywords &lt;- keyness(ft, method = "logratio", 
                    categories = genders, 
                    minimalFrequency = 5)
# Remove words that are not significantly different
keywords &lt;- keywords[names(keywords) %in% names(keyness(ft, siglevel = 0.01))]

</code></pre>

<hr>
<h2 id='loadAllInstalledIds'>Installed texts</h2><span id='topic+loadAllInstalledIds'></span>

<h3>Description</h3>

<p>Returns a list of all ids that are installed
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadAllInstalledIds(
  asDataFrame = FALSE,
  dataDirectory = getOption("qd.datadir")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loadAllInstalledIds_+3A_asdataframe">asDataFrame</code></td>
<td>
<p>Logical value. Controls whether 
the return value is a list (with colon-joined ids) 
or a data.frame with two columns (corpus, drama)</p>
</td></tr>
<tr><td><code id="loadAllInstalledIds_+3A_datadirectory">dataDirectory</code></td>
<td>
<p>The directory in which precompiled 
drama data is installed</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with all installed play ids
</p>

<hr>
<h2 id='loadCharacters'>Character data loading</h2><span id='topic+loadCharacters'></span>

<h3>Description</h3>

<p>Loads a table of characters and meta data
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadCharacters(
  ids,
  defaultCollection = "tg",
  dataDirectory = getOption("qd.datadir")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loadCharacters_+3A_ids">ids</code></td>
<td>
<p>a list or vector of ids</p>
</td></tr>
<tr><td><code id="loadCharacters_+3A_defaultcollection">defaultCollection</code></td>
<td>
<p>the default collection</p>
</td></tr>
<tr><td><code id="loadCharacters_+3A_datadirectory">dataDirectory</code></td>
<td>
<p>the data directory</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A data.frame extracted from the CSV file about characters
</p>

<hr>
<h2 id='loadDrama'>Load drama</h2><span id='topic+loadDrama'></span>

<h3>Description</h3>

<p>This function loads one or more of the installed plays and 
returns them as a <code>QDDrama</code> object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadDrama(ids, defaultCollection = "qd")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loadDrama_+3A_ids">ids</code></td>
<td>
<p>A vector of ids.</p>
</td></tr>
<tr><td><code id="loadDrama_+3A_defaultcollection">defaultCollection</code></td>
<td>
<p>If the ids do not have a collection prefix, the 
defaultCollection prefix is applied.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a <code>QDDrama</code> object. This is essentially a 
list of <code>data.table</code>s, covering the different aspects (utterances, segments, 
characters, ...). If multiple ids have been supplied as arguments, the tables 
contain the information of multiple plays.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># both are equivalent
## Not run: 
installData("test")
d &lt;- loadDrama(c("test:rksp.0", "test:rjmw.0"))
d &lt;- loadDrama(c("rksp.0", "rjmw.0"), defaultCollection = "test")

## End(Not run)
</code></pre>

<hr>
<h2 id='loadDramaTEI'>Load drama</h2><span id='topic+loadDramaTEI'></span>

<h3>Description</h3>

<p>This function parses and loads one or more dramas in raw TEI format.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadDramaTEI(filename)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loadDramaTEI_+3A_filename">filename</code></td>
<td>
<p>The filename of the drama to load (or a list thereof).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns an object of class <code>QDDrama</code>.
</p>

<hr>
<h2 id='loadFields'>Dictionary Handling</h2><span id='topic+loadFields'></span>

<h3>Description</h3>

<p><code>loadFields()</code> loads dictionaries that are available on the web as plain text files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadFields(
  fieldnames = c("Liebe", "Familie"),
  baseurl = paste("https://raw.githubusercontent.com/quadrama/metadata/master",
    ensureSuffix(directory, fileSep), sep = fileSep),
  directory = "fields/",
  fileSuffix = ".txt",
  fileSep = "/"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loadFields_+3A_fieldnames">fieldnames</code></td>
<td>
<p>A list of names for the dictionaries. It is expected that files with that name can be found below the URL.</p>
</td></tr>
<tr><td><code id="loadFields_+3A_baseurl">baseurl</code></td>
<td>
<p>The base path delivering the dictionaries. Should end in a /, field names will be appended and fed into read.csv().</p>
</td></tr>
<tr><td><code id="loadFields_+3A_directory">directory</code></td>
<td>
<p>The last component of the base url. 
Useful to retrieve enriched word fields from metadata repo.</p>
</td></tr>
<tr><td><code id="loadFields_+3A_filesuffix">fileSuffix</code></td>
<td>
<p>The suffix for the dictionary files</p>
</td></tr>
<tr><td><code id="loadFields_+3A_filesep">fileSep</code></td>
<td>
<p>The file separator used to construct the URL
Can be overwritten to load local dictionaries.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A named list that holds the loaded dictionaries as character vectors.
</p>


<h3>File Format</h3>

<p>Dictionary files should contain one word per line, with no comments 
or any other meta information. 
The entry name for the dictionary is given as the file name. 
It's therefore best if it does not contain
special characters. The dictionary must be in UTF-8 encoding, and the 
file needs to end on .txt.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># retrieves word fields from github
fields &lt;- loadFields(fieldnames=c("Liebe", "Familie", "Krieg"))
</code></pre>

<hr>
<h2 id='loadMeta'>Load meta data</h2><span id='topic+loadMeta'></span>

<h3>Description</h3>

<p>helper method to load meta data about dramatic texts (E.g., author, year). 
Does not load the texts, so it's much faster.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadMeta(ids)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loadMeta_+3A_ids">ids</code></td>
<td>
<p>A vector or list of drama ids</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data frame
</p>

<hr>
<h2 id='loadSet'>Load Collections</h2><span id='topic+loadSet'></span><span id='topic+loadSets'></span>

<h3>Description</h3>

<p>Function to load a set from collection files
Can optionally set the set name as a genre in the returned table. 
<code>loadSets()</code> returns table of all defined collections (and the
number of plays in each).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadSet(setName, addGenreColumn = FALSE)

loadSets()
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loadSet_+3A_setname">setName</code></td>
<td>
<p>A character vector. The name of the set(s) to retrieve.</p>
</td></tr>
<tr><td><code id="loadSet_+3A_addgenrecolumn">addGenreColumn</code></td>
<td>
<p>Logical. Whether to set the Genre-column in 
the returned table to the set name. If set to FALSE (default), a vector
is returned. In this case, association to collections is not returned.
Otherwise, it's a data.frame.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A character vector with play ids that belong to the set.
</p>

<hr>
<h2 id='loadText'>Load Text</h2><span id='topic+loadText'></span>

<h3>Description</h3>

<p>Load Text
</p>


<h3>Usage</h3>

<pre><code class='language-R'>loadText(
  ids,
  includeTokens = FALSE,
  defaultCollection = "tg",
  unifyCharacterFactors = FALSE,
  variant = "UtterancesWithTokens"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loadText_+3A_ids">ids</code></td>
<td>
<p>A vector containing drama ids to be downloaded</p>
</td></tr>
<tr><td><code id="loadText_+3A_includetokens">includeTokens</code></td>
<td>
<p>This argument has no meaning anymore. Tokens are always included.</p>
</td></tr>
<tr><td><code id="loadText_+3A_defaultcollection">defaultCollection</code></td>
<td>
<p>The collection prefix is added if no prefix is found</p>
</td></tr>
<tr><td><code id="loadText_+3A_unifycharacterfactors">unifyCharacterFactors</code></td>
<td>
<p>Logical value, defaults to TRUE. Controls whether columns 
representing characters (i.e., Speaker.* and Mentioned.*) are sharing factor levels</p>
</td></tr>
<tr><td><code id="loadText_+3A_variant">variant</code></td>
<td>
<p>The file variant to load</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a data.frame that is also of class <code>QDHasUtteranceBE</code>.
</p>

<hr>
<h2 id='mapPrefix'>Replace corpus prefix</h2><span id='topic+mapPrefix'></span>

<h3>Description</h3>

<p>This function can be used to replace corpus prefixes.
If a list of play ids contains textgrid prefixes, for instance, this 
function can be used to map them onto GerDraCor prefixes. Please note
that the function does <em>not</em> check whether the play actually exists 
in the corpus.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mapPrefix(idList, map)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mapPrefix_+3A_idlist">idList</code></td>
<td>
<p>The list of ids in which we want to replace.</p>
</td></tr>
<tr><td><code id="mapPrefix_+3A_map">map</code></td>
<td>
<p>A list containing the old prefix as name and the new one as
values.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a list of the same length of the input list, but
with replaced play prefixes.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# returns c("corpus2:play1", "corpus2:play2")
mapPrefix(c("corpus1:play1", "corpus1:play2"), list(corpus1="corpus2"))

</code></pre>

<hr>
<h2 id='newCollection'>Create or Extend a Collection</h2><span id='topic+newCollection'></span>

<h3>Description</h3>

<p><code>newCollection()</code> can be used to create new collections 
or add dramas to existing collection files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>newCollection(
  drama,
  name = ifelse(inherits(drama, "QDDrama"), paste(unique(drama$meta$drama)),
    paste(drama, collapse = "_")),
  writeToFile = TRUE,
  dir = getOption("qd.collectionDirectory"),
  append = TRUE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="newCollection_+3A_drama">drama</code></td>
<td>
<p>A text (or multiple texts, as data.frame or data.table), or a character 
vector containing the drama IDs to be collected</p>
</td></tr>
<tr><td><code id="newCollection_+3A_name">name</code></td>
<td>
<p>The name of the collection and its filename (default = concatenated drama IDs)</p>
</td></tr>
<tr><td><code id="newCollection_+3A_writetofile">writeToFile</code></td>
<td>
<p>= Whether to write the collection to a file (default = TRUE)</p>
</td></tr>
<tr><td><code id="newCollection_+3A_dir">dir</code></td>
<td>
<p>The directory into which the collection file will be written (default = collection directory)</p>
</td></tr>
<tr><td><code id="newCollection_+3A_append">append</code></td>
<td>
<p>Whether to extend the collection file if it already exists. 
If FALSE, the file will be overwritten. (default = TRUE)</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns the ids that belong to the collection as a character vector.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>t &lt;- combine(rksp.0, rjmw.0)
newCollection(t, writeToFile=FALSE)
newCollection(c("rksp.0", "rjmw.0"), writeToFile=FALSE) # produces identical file
newCollection(c("a", "b"), name="rksp.0_rjmw.0", writeToFile=FALSE) # adds "a" and "b" to the file
</code></pre>

<hr>
<h2 id='numberOfPlays'>Number of plays</h2><span id='topic+numberOfPlays'></span>

<h3>Description</h3>

<p>The function <code>numberOfPlays()</code> determines how many
different plays are contained in a single QDDrama object.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>numberOfPlays(x)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="numberOfPlays_+3A_x">x</code></td>
<td>
<p>The QDDrama object</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An integer. The number of plays contained in the QDDrama object.
</p>


<h3>Examples</h3>

<pre><code class='language-R'># returns 1
numberOfPlays(rksp.0)

# returns 2
numberOfPlays(combine(rksp.0, rjmw.0))
</code></pre>

<hr>
<h2 id='personnelExchange'>Measuring Personnel Exchange over Boundaries</h2><span id='topic+personnelExchange'></span><span id='topic+hamming'></span><span id='topic+scenicDifference'></span>

<h3>Description</h3>

<p>There are multiple ways to quantify the number of characters that are 
exchanged over a scene or act boundary.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hamming(drama, variant = c("Trilcke", "Hamming", "NormalizedHamming"))

scenicDifference(drama, norm = length(unique(drama$text$Speaker.figure_id)))
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="personnelExchange_+3A_drama">drama</code></td>
<td>
<p>The QDDrama Object</p>
</td></tr>
<tr><td><code id="personnelExchange_+3A_variant">variant</code></td>
<td>
<p>For <code>hamming()</code>, variants are &quot;Trilcke&quot; (default), &quot;NormalizedHamming&quot;, and &quot;Hamming&quot;</p>
</td></tr>
<tr><td><code id="personnelExchange_+3A_norm">norm</code></td>
<td>
<p>For <code>scenicDifference()</code>, specifies the normalization constant</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A QDHamming object, which is a list of values, one for each scene change.
The values indicate the (potentially) normalized number of characters that are exchanged.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rksp.0)
dist_trilcke  &lt;- hamming(rksp.0)
dist_hamming  &lt;- hamming(rksp.0, variant = "Hamming")
dist_nhamming &lt;- hamming(rksp.0, variant = "NormalizedHamming")
</code></pre>

<hr>
<h2 id='plot.QDHamming'>Personnel Exchange</h2><span id='topic+plot.QDHamming'></span>

<h3>Description</h3>

<p>Uses the default scatterplot function to plot the personnel 
exchange in each scene.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'QDHamming'
plot(x, drama = NULL, xlab = "Scene", ylab = "Exchange after Scene", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.QDHamming_+3A_x">x</code></td>
<td>
<p>A numeric vector generated from the function</p>
</td></tr>
<tr><td><code id="plot.QDHamming_+3A_drama">drama</code></td>
<td>
<p>Optional QDDrama object. If present, act boundaries
and correct scene labels are included in the plot.</p>
</td></tr>
<tr><td><code id="plot.QDHamming_+3A_xlab">xlab</code></td>
<td>
<p>A character vector that is used as x axis label. Defaults to
&quot;Scene&quot;.</p>
</td></tr>
<tr><td><code id="plot.QDHamming_+3A_ylab">ylab</code></td>
<td>
<p>A character vector that is used as y axis label. Defaults to
&quot;Exchange&quot;.</p>
</td></tr>
<tr><td><code id="plot.QDHamming_+3A_...">...</code></td>
<td>
<p>Parameters passed to <code>plot.default()</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See <code>plot.default()</code>.
</p>


<h3>See Also</h3>

<p>plot.default
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rksp.0)
h &lt;- hamming(rksp.0)
plot(h, drama=rksp.0)
</code></pre>

<hr>
<h2 id='plot.QDUtteranceStatistics'>Utterance positions</h2><span id='topic+plot.QDUtteranceStatistics'></span>

<h3>Description</h3>

<p>Uses the function <code>stripchart</code> to  plot each utterance at their position,
in a line representing the character. The dot is marked in the middle of each utterance.
Might look weird if very long utterances are present.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'QDUtteranceStatistics'
plot(x, drama = NULL, colors = qd.colors, xlab = "Time", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.QDUtteranceStatistics_+3A_x">x</code></td>
<td>
<p>A table generated from the function</p>
</td></tr>
<tr><td><code id="plot.QDUtteranceStatistics_+3A_drama">drama</code></td>
<td>
<p>Optional QDDrama object. If present, segment boundaries
are extracted from it and included in the plot.</p>
</td></tr>
<tr><td><code id="plot.QDUtteranceStatistics_+3A_colors">colors</code></td>
<td>
<p>The colors to be used</p>
</td></tr>
<tr><td><code id="plot.QDUtteranceStatistics_+3A_xlab">xlab</code></td>
<td>
<p>A character vector that is used as x axis label. Defaults to
&quot;Time&quot;.</p>
</td></tr>
<tr><td><code id="plot.QDUtteranceStatistics_+3A_...">...</code></td>
<td>
<p>Parameters passed to stripchart().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>See <code>stripchart()</code>.
</p>


<h3>See Also</h3>

<p>stripchart
</p>

<hr>
<h2 id='plotSpiderWebs'>Spider-Webs</h2><span id='topic+plotSpiderWebs'></span>

<h3>Description</h3>

<p>Generates spider-web like plot. 
Spider webs may look cool, but they are terrible 
to interpret. You should think of using a bar 
chart to represent the same information. <em>You have been warned.</em>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plotSpiderWebs(
  dstat,
  symbols = c(17, 16, 15, 4, 8),
  cglcol = "black",
  legend = TRUE,
  legend.cex = 0.7,
  legend.pos.x = "bottomright",
  legend.pos.y = NA,
  legend.horizontal = FALSE,
  pcol = qd.colors,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plotSpiderWebs_+3A_dstat">dstat</code></td>
<td>
<p>A data frame containing data, e.g., output from dictionaryStatistics()</p>
</td></tr>
<tr><td><code id="plotSpiderWebs_+3A_symbols">symbols</code></td>
<td>
<p>Symbols to be used in the plot</p>
</td></tr>
<tr><td><code id="plotSpiderWebs_+3A_cglcol">cglcol</code></td>
<td>
<p>The color for the spider net</p>
</td></tr>
<tr><td><code id="plotSpiderWebs_+3A_legend">legend</code></td>
<td>
<p>Whether to print a legend</p>
</td></tr>
<tr><td><code id="plotSpiderWebs_+3A_legend.cex">legend.cex</code></td>
<td>
<p>Scaling factor for legend</p>
</td></tr>
<tr><td><code id="plotSpiderWebs_+3A_legend.pos.x">legend.pos.x</code></td>
<td>
<p>X position of legend</p>
</td></tr>
<tr><td><code id="plotSpiderWebs_+3A_legend.pos.y">legend.pos.y</code></td>
<td>
<p>Y position of legend</p>
</td></tr>
<tr><td><code id="plotSpiderWebs_+3A_legend.horizontal">legend.horizontal</code></td>
<td>
<p>Whether to print legend horizontally or vertically</p>
</td></tr>
<tr><td><code id="plotSpiderWebs_+3A_pcol">pcol</code></td>
<td>
<p>The line color(s)</p>
</td></tr>
<tr><td><code id="plotSpiderWebs_+3A_...">...</code></td>
<td>
<p>Miscellaneous arguments to be given for radarchart().</p>
</td></tr>
</table>


<h3>Value</h3>

<p>No value is returned.
</p>


<h3>Note</h3>

<p>radar charts and spider web plots are dangerous, 
they can easily become misleading. They are in this package 
for historic reasons, but should not be used anymore.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rksp.0)
fnames &lt;- c("Krieg", "Liebe", "Familie", "Ratio","Religion")
ds &lt;- dictionaryStatistics(rksp.0, normalizeByField=TRUE, 
                           fieldnames=fnames)
plotSpiderWebs(ds)
</code></pre>

<hr>
<h2 id='postags'>Provides lists of groups of pos tags for various word classes.</h2><span id='topic+postags'></span>

<h3>Description</h3>

<p>Provides lists of groups of pos tags for various word classes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>postags
</code></pre>


<h3>Format</h3>

<p>An object of class <code>list</code> of length 1.
</p>

<hr>
<h2 id='presence'>Active and Passive Presence</h2><span id='topic+presence'></span>

<h3>Description</h3>

<p>This function should be called for a single text. It returns 
a data.frame with one row for each character in the play. The 
data.frame contains 
information about the number of scenes in which a character is actively 
speaking or passively mentions. Please note that the information about
passive presence is derived from coreference resolved texts, which is a
difficult task and not entirely reliable. The plays included in the package
feature manually annotated coreferences (and thus, the presence is calculated on
the basis of very well data).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>presence(drama, passiveOnlyWhenNotActive = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="presence_+3A_drama">drama</code></td>
<td>
<p>A single drama</p>
</td></tr>
<tr><td><code id="presence_+3A_passiveonlywhennotactive">passiveOnlyWhenNotActive</code></td>
<td>
<p>Logical. If true (default), passive presence is only 
counted if a character is not actively present in the scene.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>QDHasCharacter, data.frame. Columns <code>actives</code>, <code>passives</code> and 
<code>scenes</code> show the 
absolute number of scenes in which a character is actively/passively present, or the
total number of scenes in the play. The column <code>presence</code> is calculated as 
<code class="reqn">\frac{actives-passives}{scenes}</code>.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rksp.0)
presence(rksp.0)
</code></pre>

<hr>
<h2 id='qd.colors'>QuaDramA colors</h2><span id='topic+qd.colors'></span>

<h3>Description</h3>

<p>color scheme to be used for QuaDramA plots
Taken from http://google.github.io/palette.js/, tol-rainbow, 10 colors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>qd.colors
</code></pre>


<h3>Format</h3>

<p>An object of class <code>character</code> of length 10.
</p>

<hr>
<h2 id='report'>Report</h2><span id='topic+report'></span>

<h3>Description</h3>

<p>generates a report for a specific dramatic text
</p>


<h3>Usage</h3>

<pre><code class='language-R'>report(
  id = "test:rksp.0",
  of = file.path(getwd(), paste0(unlist(strsplit(id, ":", fixed = TRUE))[2], ".html")),
  type = c("Single", "Compare"),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="report_+3A_id">id</code></td>
<td>
<p>The id of the text or a list of ids</p>
</td></tr>
<tr><td><code id="report_+3A_of">of</code></td>
<td>
<p>The output file</p>
</td></tr>
<tr><td><code id="report_+3A_type">type</code></td>
<td>
<p>The type of the report. &quot;Single&quot; gives a report about a single play, 
while &quot;Compare&quot; can be used to compare multiple editions of a play. Please note that 
the &quot;Compare&quot; report is still under development.</p>
</td></tr>
<tr><td><code id="report_+3A_...">...</code></td>
<td>
<p>Arguments passed through to the rmarkdown document</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The return value of <code><a href="rmarkdown.html#topic+render">render</a></code>
</p>

<hr>
<h2 id='segment'>Segment</h2><span id='topic+segment'></span>

<h3>Description</h3>

<p>This function takes two tables and combines them. The first table is of the 
class QDHasUtteranceBE and contains text spans that are designated with 
begin and end character positions.
The second table of class QDHasSegments contains information about acts and scenes 
in the play. This function is used internally in many other functions, but is exported
because it might become useful.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>segment(hasUtteranceBE, hasSegments)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="segment_+3A_hasutterancebe">hasUtteranceBE</code></td>
<td>
<p>Table with utterances</p>
</td></tr>
<tr><td><code id="segment_+3A_hassegments">hasSegments</code></td>
<td>
<p>Table with segment info</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The function returns a <code>data.table</code> that has both the play
segmentation and the token data in it.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rksp.0)
segmentedText &lt;- segment(rksp.0$text, rksp.0$segments)
</code></pre>

<hr>
<h2 id='setCollectionDirectory'>This function initializes the paths to data files.</h2><span id='topic+setCollectionDirectory'></span><span id='topic+setDirectories'></span><span id='topic+setDataDirectory'></span>

<h3>Description</h3>

<p>This function initializes the paths to data files.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>setCollectionDirectory(
  collectionDirectory = file.path(getOption("qd.datadir"), "collections")
)

setDirectories(
  dataDirectory = file.path(path.expand("~"), "QuaDramA", "Data2"),
  collectionDirectory = file.path(dataDirectory, "collections")
)

setDataDirectory(
  dataDirectory = file.path(path.expand("~"), "QuaDramA", "Data2")
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="setCollectionDirectory_+3A_collectiondirectory">collectionDirectory</code></td>
<td>
<p>A path to the directory in which collections are stored. 
By default, the directory is called &quot;collection&quot; below the data directory.</p>
</td></tr>
<tr><td><code id="setCollectionDirectory_+3A_datadirectory">dataDirectory</code></td>
<td>
<p>A path to the directory in which data and metadata are located. 
&quot;~/QuaDramA/Data2&quot; by default.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The <code>set*Directory()</code> functions always return <code>NULL</code>.
</p>

<hr>
<h2 id='split.QDDrama'>Split multiple plays</h2><span id='topic+split.QDDrama'></span>

<h3>Description</h3>

<p>The function <code>split(x)</code> expects an object of type <code>QDDrama</code> and can 
be used to split a <code>QDDrama</code> object that consists of multiple dramas 
into a list thereof. It is the counterpart to <code>combine(x, y)</code>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'QDDrama'
split(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="split.QDDrama_+3A_x">x</code></td>
<td>
<p>The object of class <code>QDDrama</code> (consisting of multiple dramas). 
For <code>split()</code> it should consist of multiple plays. For <code>combine()</code> it 
can but doesn't have to.</p>
</td></tr>
<tr><td><code id="split.QDDrama_+3A_...">...</code></td>
<td>
<p>All other arguments are ignored.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns a list of individual QDDrama objects, each containing one text.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rksp.0)
data(rjmw.0)
d &lt;- combine(rjmw.0, rksp.0)
dlist &lt;- split(d)
</code></pre>

<hr>
<h2 id='tfidf'>TF-IDF</h2><span id='topic+tfidf'></span>

<h3>Description</h3>

<p>This function calculates a variant of TF-IDF. 
The input is assumed to contain relative frequencies.
IDF is calculated as follows: <code class="reqn">idf_t = \log\frac{N+1}{n_t}</code>, with <code class="reqn">N</code> being 
the total number of documents (i.e., rows) and <code class="reqn">n_t</code> the number of documents
containing term <code class="reqn">t</code>. We add one to the denominator to prevent terms that appear
in every document to become 0.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tfidf(ftable)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="tfidf_+3A_ftable">ftable</code></td>
<td>
<p>A matrix, containing &quot;documents&quot; as rows and &quot;terms&quot; as columns. 
Values are assumed to be normalized by document, i.e., contain relative frequencies.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A matrix containing TF*IDF values instead of relative frequencies.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rksp.0)
ftable &lt;- frequencytable(rksp.0, byCharacter=TRUE, normalize=TRUE)
rksp.0.tfidf &lt;- tfidf(ftable)
mat &lt;- matrix(c(0.10,0.2, 0,
                0,   0.2, 0,
                0.1, 0.2, 0.1,
                0.8, 0.4, 0.9),
              nrow=3,ncol=4)
mat2 &lt;- tfidf(mat)
print(mat2)
</code></pre>

<hr>
<h2 id='utteranceStatistics'>Utterance Statistics</h2><span id='topic+utteranceStatistics'></span>

<h3>Description</h3>

<p>This method calculates the length of each utterance, organized by 
character and drama.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>utteranceStatistics(drama, normalizeByDramaLength = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="utteranceStatistics_+3A_drama">drama</code></td>
<td>
<p>The dramatic text(s)</p>
</td></tr>
<tr><td><code id="utteranceStatistics_+3A_normalizebydramalength">normalizeByDramaLength</code></td>
<td>
<p>Logical value. If true, the resulting values will be normalized by the length of the drama.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Returns an object of class <code>QDUtteranceStatistics</code>, 
which is essentially a data.frame.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+characterNames">characterNames</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>data(rksp.0)
ustat &lt;- utteranceStatistics(rksp.0)

boxplot(ustat$utteranceLength ~ ustat$character,
   col=qd.colors[1:5],
   las=2, frame=FALSE)

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
