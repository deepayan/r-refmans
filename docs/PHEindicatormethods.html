<!DOCTYPE html><html><head><title>Help for package PHEindicatormethods</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {PHEindicatormethods}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#assign_funnel_significance'><p>Identifies whether each value in a dataset falls outside of 95 and/or 99.8</p>
percent control limits based on the aggregated average value across the whole
dataset as an indicator of statistically significant difference.</a></li>
<li><a href='#calculate_funnel_limits'><p>Calculate control limits for funnel plots</p></a></li>
<li><a href='#calculate_funnel_points'><p>For rate-based funnels: Derive rate and annual population values for charting</p>
based. Process removes rates where the rate type is dsr and the number of
observed events are below 10.</a></li>
<li><a href='#calculate_ISRate'><p>Calculate Indirectly Standardised Rates using calculate_ISRate</p></a></li>
<li><a href='#calculate_ISRatio'><p>Calculate Indirectly standardised ratios using calculate_ISRatio</p></a></li>
<li><a href='#DSR_data'><p>SII test datasets - DSR</p></a></li>
<li><a href='#esp2013'><p>European Standard Population 2013</p></a></li>
<li><a href='#LE_data'><p>SII test datasets - Life Expectancy</p></a></li>
<li><a href='#phe_dsr'><p>Calculate Directly Standardised Rates using phe_dsr</p></a></li>
<li><a href='#phe_life_expectancy'><p>Calculate Life Expectancy using phe_life_expectancy</p></a></li>
<li><a href='#phe_mean'><p>Calculate Means using phe_mean</p></a></li>
<li><a href='#phe_proportion'><p>Calculate Proportions using phe_proportion</p></a></li>
<li><a href='#phe_quantile'><p>Assign Quantiles using phe_quantile</p></a></li>
<li><a href='#phe_rate'><p>Calculate Rates using phe_rate</p></a></li>
<li><a href='#phe_sii'><p>Calculate Slope Index of Inequality using phe_sii</p></a></li>
<li><a href='#PHEindicatormethods'><p>PHEindicatormethods: A package for performing standard statistics for public</p>
health indicators</a></li>
<li><a href='#prevalence_data'><p>SII test datasets - Prevalence</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table>
<tr>
<td>Type:</td>
<td>Package</td>
</tr>
<tr>
<td>Version:</td>
<td>2.0.2</td>
</tr>
<tr>
<td>Title:</td>
<td>Common Public Health Statistics and their Confidence Intervals</td>
</tr>
<tr>
<td>Description:</td>
<td>Functions to calculate commonly used public health statistics and 
    their confidence intervals using methods approved for use in the production  
    of Public Health England indicators such as those presented via Fingertips 
    (<a href="http://fingertips.phe.org.uk/">http://fingertips.phe.org.uk/</a>). It provides functions for the generation 
    of proportions, crude rates, means, directly standardised rates, indirectly 
    standardised rates, standardised mortality ratios, slope and relative index
    of inequality and life expectancy. 
    Statistical methods are referenced in the following publications. 
    Breslow NE, Day NE (1987) &lt;<a href="https://doi.org/10.1002%2Fsim.4780080614">doi:10.1002/sim.4780080614</a>&gt;.
    Dobson et al (1991) &lt;<a href="https://doi.org/10.1002%2Fsim.4780100317">doi:10.1002/sim.4780100317</a>&gt;. 
    Armitage P, Berry G (2002) &lt;<a href="https://doi.org/10.1002%2F9780470773666">doi:10.1002/9780470773666</a>&gt;.
    Wilson EB. (1927) &lt;<a href="https://doi.org/10.1080%2F01621459.1927.10502953">doi:10.1080/01621459.1927.10502953</a>&gt;.
    Altman DG et al (2000, ISBN: 978-0-727-91375-3).
    Chiang CL. (1968, ISBN: 978-0-882-75200-6).
    Newell C. (1994, ISBN: 978-0-898-62451-9).
    Eayres DP, Williams ES (2004) &lt;<a href="https://doi.org/10.1136%2Fjech.2003.009654">doi:10.1136/jech.2003.009654</a>&gt;.
    Silcocks PBS et al (2001) &lt;<a href="https://doi.org/10.1136%2Fjech.55.1.38">doi:10.1136/jech.55.1.38</a>&gt;.
    Low and Low (2004) &lt;<a href="https://doi.org/10.1093%2Fpubmed%2Ffdh175">doi:10.1093/pubmed/fdh175</a>&gt;.</td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/ukhsa-collaboration/PHEindicatormethods/issues">https://github.com/ukhsa-collaboration/PHEindicatormethods/issues</a></td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.1.0)</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://www.r-project.org/Licenses/GPL-3">GPL-3</a></td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Imports:</td>
<td>broom, dplyr (&ge; 1.1.0), purrr (&ge; 1.0.0), rlang (&ge; 0.4.0),
stats, tibble, tidyselect (&ge; 1.2.0), tidyr (&ge; 1.3.0)</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, readxl, rmarkdown, testthat (&ge; 3.0.0), withr</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2024-01-25 09:18:25 UTC; GAnderson1</td>
</tr>
<tr>
<td>Author:</td>
<td>Anderson Georgina [aut, cre],
  Fox Sebastian [ctb],
  Francis Matthew [ctb],
  Fryers Paul [ctb],
  Clegg Emma [ctb],
  Westermann Annabel [ctb],
  Woolner Joshua [ctb],
  Fellows Charlotte [ctb]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Anderson Georgina &lt;georgina.anderson@dhsc.gov.uk&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2024-01-25 10:40:05 UTC</td>
</tr>
</table>
<hr>
<h2 id='assign_funnel_significance'>Identifies whether each value in a dataset falls outside of 95 and/or 99.8
percent control limits based on the aggregated average value across the whole
dataset as an indicator of statistically significant difference.</h2><span id='topic+assign_funnel_significance'></span>

<h3>Description</h3>

<p>This follows the funnel plot methodology published on the PHE Fingertips
Technical Guidance page:
https://fingertips.phe.org.uk/profile/guidance/supporting-information/PH-methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>assign_funnel_significance(
  data,
  numerator,
  denominator,
  rate,
  statistic = NULL,
  rate_type = NULL,
  multiplier = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="assign_funnel_significance_+3A_data">data</code></td>
<td>
<p>a data.frame containing the data to assign significance for;
unquoted string; no default</p>
</td></tr>
<tr><td><code id="assign_funnel_significance_+3A_numerator">numerator</code></td>
<td>
<p>field name from data containing the observed numbers of
cases in the sample meeting the required condition (the numerator or
observed counts for the control limits); unquoted string; no default</p>
</td></tr>
<tr><td><code id="assign_funnel_significance_+3A_denominator">denominator</code></td>
<td>
<p>field name from data containing the population(s) in the
sample (the denominator or expected counts for the control limits);
unquoted string; no default</p>
</td></tr>
<tr><td><code id="assign_funnel_significance_+3A_rate">rate</code></td>
<td>
<p>field name from data containing the rate data when creating
funnels for a Crude or Directly Standardised Rate; unquoted string; no
default</p>
</td></tr>
<tr><td><code id="assign_funnel_significance_+3A_statistic">statistic</code></td>
<td>
<p>type of statistic to inform funnel calculations. Acceptable
values are &quot;proportion&quot;, &quot;ratio&quot; or &quot;rate&quot;; string; no default</p>
</td></tr>
<tr><td><code id="assign_funnel_significance_+3A_rate_type">rate_type</code></td>
<td>
<p>if statistic is &quot;rate&quot;, specify either &quot;dsr&quot; or &quot;crude&quot;;
string; no default</p>
</td></tr>
<tr><td><code id="assign_funnel_significance_+3A_multiplier">multiplier</code></td>
<td>
<p>the multiplier that the rate is normalised with (ie, per
100,000); only required when statistic = &quot;rate&quot;; numeric; no default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the original data.frame with the significance level appended
</p>


<h3>Author(s)</h3>

<p>Matthew Francis
</p>


<h3>See Also</h3>

<p>Other PHEindicatormethods package functions: 
<code><a href="#topic+calculate_ISRate">calculate_ISRate</a>()</code>,
<code><a href="#topic+calculate_ISRatio">calculate_ISRatio</a>()</code>,
<code><a href="#topic+calculate_funnel_limits">calculate_funnel_limits</a>()</code>,
<code><a href="#topic+calculate_funnel_points">calculate_funnel_points</a>()</code>,
<code><a href="#topic+phe_dsr">phe_dsr</a>()</code>,
<code><a href="#topic+phe_life_expectancy">phe_life_expectancy</a>()</code>,
<code><a href="#topic+phe_mean">phe_mean</a>()</code>,
<code><a href="#topic+phe_proportion">phe_proportion</a>()</code>,
<code><a href="#topic+phe_quantile">phe_quantile</a>()</code>,
<code><a href="#topic+phe_rate">phe_rate</a>()</code>,
<code><a href="#topic+phe_sii">phe_sii</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
df &lt;- data.frame(
  Area = c("A", "B", "C", "D"),
  numerator = c(10232, 12321, 15123, 13213),
  denominator = c(15232, 16123, 17932, 18475)
)
df %&gt;%
  assign_funnel_significance(numerator, denominator,
                             statistic = "proportion", multiplier = 100)

</code></pre>

<hr>
<h2 id='calculate_funnel_limits'>Calculate control limits for funnel plots</h2><span id='topic+calculate_funnel_limits'></span>

<h3>Description</h3>

<p>Calculates control limits adopting a consistent method as per the PHE
Fingertips Technical Guidance: https://fingertips.phe.org.uk/profile/guidance/supporting-information/PH-methods
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_funnel_limits(
  data,
  numerator,
  denominator,
  rate,
  type = "full",
  multiplier = NULL,
  statistic = NULL,
  ratio_type = NULL,
  rate_type = NULL,
  years_of_data = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_funnel_limits_+3A_data">data</code></td>
<td>
<p>a data.frame containing the data to calculate control limits for;
unquoted string; no default</p>
</td></tr>
<tr><td><code id="calculate_funnel_limits_+3A_numerator">numerator</code></td>
<td>
<p>field name from data containing the observed numbers of
cases in the sample meeting the required condition (the numerator or
observed counts for the control limits); unquoted string; no default</p>
</td></tr>
<tr><td><code id="calculate_funnel_limits_+3A_denominator">denominator</code></td>
<td>
<p>field name from data containing the population(s) in the
sample (the denominator or expected counts for the control limits);
unquoted string; no default</p>
</td></tr>
<tr><td><code id="calculate_funnel_limits_+3A_rate">rate</code></td>
<td>
<p>field name from data containing the rate data when creating
funnels for a Crude or Directly Standardised Rate; unquoted string; no
default</p>
</td></tr>
<tr><td><code id="calculate_funnel_limits_+3A_type">type</code></td>
<td>
<p>defines the data and metadata columns to be included in output;
&quot;standard&quot; (for all data) or &quot;full&quot; (for all data and metadata); quoted
string; default = &quot;full&quot;</p>
</td></tr>
<tr><td><code id="calculate_funnel_limits_+3A_multiplier">multiplier</code></td>
<td>
<p>the multiplier used to express the final values (eg 100 =
percentage); numeric; no default</p>
</td></tr>
<tr><td><code id="calculate_funnel_limits_+3A_statistic">statistic</code></td>
<td>
<p>type of statistic to inform funnel calculations. Acceptable
values are &quot;proportion&quot;, &quot;ratio&quot; or &quot;rate&quot;; string; no default</p>
</td></tr>
<tr><td><code id="calculate_funnel_limits_+3A_ratio_type">ratio_type</code></td>
<td>
<p>if statistic is &quot;ratio&quot;, specify either &quot;count&quot; or &quot;isr&quot;
(indirectly standardised ratio); string; no default</p>
</td></tr>
<tr><td><code id="calculate_funnel_limits_+3A_rate_type">rate_type</code></td>
<td>
<p>if statistic is &quot;rate&quot;, specify either &quot;dsr&quot; or &quot;crude&quot;;
string; no default</p>
</td></tr>
<tr><td><code id="calculate_funnel_limits_+3A_years_of_data">years_of_data</code></td>
<td>
<p>number of years the data represents; this is required
for statistic = &quot;rate&quot;; numeric; no default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the original data.frame with the following appended: lower
0.025 limit, upper 0.025 limit, lower 0.001 limit, upper 0.001 limit and
baseline average
</p>


<h3>Author(s)</h3>

<p>Matthew Francis
</p>


<h3>See Also</h3>

<p>Other PHEindicatormethods package functions: 
<code><a href="#topic+assign_funnel_significance">assign_funnel_significance</a>()</code>,
<code><a href="#topic+calculate_ISRate">calculate_ISRate</a>()</code>,
<code><a href="#topic+calculate_ISRatio">calculate_ISRatio</a>()</code>,
<code><a href="#topic+calculate_funnel_points">calculate_funnel_points</a>()</code>,
<code><a href="#topic+phe_dsr">phe_dsr</a>()</code>,
<code><a href="#topic+phe_life_expectancy">phe_life_expectancy</a>()</code>,
<code><a href="#topic+phe_mean">phe_mean</a>()</code>,
<code><a href="#topic+phe_proportion">phe_proportion</a>()</code>,
<code><a href="#topic+phe_quantile">phe_quantile</a>()</code>,
<code><a href="#topic+phe_rate">phe_rate</a>()</code>,
<code><a href="#topic+phe_sii">phe_sii</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
set.seed(123)
df &lt;- data.frame(obs = sample(200, 19 * 2 * 5 * 4, replace = TRUE),
                 pop = sample(10000:20000, 19 * 2 * 5 * 4, replace = TRUE))
df %&gt;%
    calculate_funnel_limits(obs, pop, statistic = "proportion", multiplier = 100)

</code></pre>

<hr>
<h2 id='calculate_funnel_points'>For rate-based funnels: Derive rate and annual population values for charting
based. Process removes rates where the rate type is dsr and the number of
observed events are below 10.</h2><span id='topic+calculate_funnel_points'></span>

<h3>Description</h3>

<p>For rate-based funnels: Derive rate and annual population values for charting
based. Process removes rates where the rate type is dsr and the number of
observed events are below 10.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_funnel_points(
  data,
  numerator,
  denominator,
  rate,
  rate_type = NULL,
  years_of_data = NULL,
  multiplier = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_funnel_points_+3A_data">data</code></td>
<td>
<p>a data.frame containing the data to calculate control limits for;
unquoted string; no default</p>
</td></tr>
<tr><td><code id="calculate_funnel_points_+3A_numerator">numerator</code></td>
<td>
<p>field name from data containing the observed numbers of
cases in the sample meeting the required condition (the numerator or
observed counts for the control limits); unquoted string; no default</p>
</td></tr>
<tr><td><code id="calculate_funnel_points_+3A_denominator">denominator</code></td>
<td>
<p>field name from data containing the population(s) in the
sample (the denominator or expected counts for the control limits);
unquoted string; no default</p>
</td></tr>
<tr><td><code id="calculate_funnel_points_+3A_rate">rate</code></td>
<td>
<p>field name from data containing the rate data when creating
funnels for a Crude or Directly Standardised Rate; unquoted string; no
default</p>
</td></tr>
<tr><td><code id="calculate_funnel_points_+3A_rate_type">rate_type</code></td>
<td>
<p>if statistic is &quot;rate&quot;, specify either &quot;dsr&quot; or &quot;crude&quot;;
string; no default</p>
</td></tr>
<tr><td><code id="calculate_funnel_points_+3A_years_of_data">years_of_data</code></td>
<td>
<p>number of years the data represents; this is required
for statistic = &quot;rate&quot;; numeric; no default</p>
</td></tr>
<tr><td><code id="calculate_funnel_points_+3A_multiplier">multiplier</code></td>
<td>
<p>the multiplier used to express the final values (eg 100 =
percentage); numeric; no default</p>
</td></tr>
</table>


<h3>Value</h3>

<p>returns the same table as provided with two additional fields. First
will have the same name as the rate field, with the suffix &quot;_chart&quot;, the
second will be called denominator_derived
</p>


<h3>Author(s)</h3>

<p>Sebastian Fox, <a href="mailto:sebastian.fox@phe.gov.uk">sebastian.fox@phe.gov.uk</a>
</p>


<h3>See Also</h3>

<p>Other PHEindicatormethods package functions: 
<code><a href="#topic+assign_funnel_significance">assign_funnel_significance</a>()</code>,
<code><a href="#topic+calculate_ISRate">calculate_ISRate</a>()</code>,
<code><a href="#topic+calculate_ISRatio">calculate_ISRatio</a>()</code>,
<code><a href="#topic+calculate_funnel_limits">calculate_funnel_limits</a>()</code>,
<code><a href="#topic+phe_dsr">phe_dsr</a>()</code>,
<code><a href="#topic+phe_life_expectancy">phe_life_expectancy</a>()</code>,
<code><a href="#topic+phe_mean">phe_mean</a>()</code>,
<code><a href="#topic+phe_proportion">phe_proportion</a>()</code>,
<code><a href="#topic+phe_quantile">phe_quantile</a>()</code>,
<code><a href="#topic+phe_rate">phe_rate</a>()</code>,
<code><a href="#topic+phe_sii">phe_sii</a>()</code>
</p>

<hr>
<h2 id='calculate_ISRate'>Calculate Indirectly Standardised Rates using calculate_ISRate</h2><span id='topic+calculate_ISRate'></span>

<h3>Description</h3>

<p>Calculates indirectly standardised rates with confidence limits using Byar's
(1) or exact (2) CI method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_ISRate(
  data,
  x,
  n,
  x_ref,
  n_ref,
  refpoptype = "vector",
  type = "full",
  confidence = 0.95,
  multiplier = 1e+05,
  observed_totals = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_ISRate_+3A_data">data</code></td>
<td>
<p>data.frame containing the data to be standardised, pre-grouped if
multiple ISRs required; unquoted string; no default</p>
</td></tr>
<tr><td><code id="calculate_ISRate_+3A_x">x</code></td>
<td>
<p>field name from data containing the observed number of events for
each standardisation category (eg ageband) within each grouping set (eg
area). Alternatively, if not providing age breakdowns for observed events,
field name from observed_totals containing the observed number of events
within each grouping set ; unquoted string; no default</p>
</td></tr>
<tr><td><code id="calculate_ISRate_+3A_n">n</code></td>
<td>
<p>field name from data containing the populations for each
standardisation category (eg ageband) within each grouping set (eg area);
unquoted string; no default</p>
</td></tr>
<tr><td><code id="calculate_ISRate_+3A_x_ref">x_ref</code></td>
<td>
<p>the observed number of events in the reference population for
each standardisation category (eg age band); unquoted string referencing a
numeric vector or field name from data depending on value of refpoptype; no
default</p>
</td></tr>
<tr><td><code id="calculate_ISRate_+3A_n_ref">n_ref</code></td>
<td>
<p>the reference population for each standardisation category (eg
age band); unquoted string referencing a numeric vector or field name from
data depending on value of refpoptype; no default</p>
</td></tr>
<tr><td><code id="calculate_ISRate_+3A_refpoptype">refpoptype</code></td>
<td>
<p>whether x_ref and n_ref have been specified as vectors or a
field name from data; quoted string &quot;field&quot; or &quot;vector&quot;; default = &quot;vector&quot;</p>
</td></tr>
<tr><td><code id="calculate_ISRate_+3A_type">type</code></td>
<td>
<p>defines the data and metadata columns to be included in output;
can be &quot;value&quot;, &quot;lower&quot;, &quot;upper&quot;, &quot;standard&quot; (for all data) or &quot;full&quot; (for
all data and metadata); quoted string; default = &quot;full&quot;</p>
</td></tr>
<tr><td><code id="calculate_ISRate_+3A_confidence">confidence</code></td>
<td>
<p>the required level of confidence expressed as a number
between 0.9 and 1 or a number between 90 and 100 or can be a vector of 0.95
and 0.998, for example, to output both 95 percent and 99.8 percent percent CIs; numeric;
default 0.95</p>
</td></tr>
<tr><td><code id="calculate_ISRate_+3A_multiplier">multiplier</code></td>
<td>
<p>the multiplier used to express the final values (eg 100,000
= rate per 100,000); numeric; default 100,000</p>
</td></tr>
<tr><td><code id="calculate_ISRate_+3A_observed_totals">observed_totals</code></td>
<td>
<p>data.frame containing total observed events for each
group, if not provided with age-breakdowns in data. Must only contain the
count field (x) plus grouping columns required to join to data using the
same grouping column names; default = NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When type = &quot;full&quot;, returns a tibble of observed events, expected
events, indirectly standardised rate, lower confidence limit, upper
confidence limit, confidence level, statistic and method for each grouping
set
</p>


<h3>Notes</h3>

<p>User MUST ensure that x, n, x_ref and n_ref vectors are all
ordered by the same standardisation category values as records will be
matched by position. <br />  <br /> For numerators &gt;= 10 Byar's method (1) is
applied using the internal byars_lower and byars_upper functions.  For
small numerators Byar's method is less accurate and so an exact method (2)
based on the Poisson distribution is used. <br />  <br /> This function directly
replaced phe_isr which was fully deprecated in package version 2.0.0 due to
ambiguous naming
</p>


<h3>References</h3>

<p>(1) Breslow NE, Day NE. Statistical methods in cancer research,
volume II: The design and analysis of cohort studies. Lyon: International
Agency for Research on Cancer, World Health Organisation; 1987. <br /> <br />
(2) Armitage P, Berry G. Statistical methods in medical research (4th edn).
Oxford: Blackwell; 2002.
</p>


<h3>See Also</h3>

<p>Other PHEindicatormethods package functions: 
<code><a href="#topic+assign_funnel_significance">assign_funnel_significance</a>()</code>,
<code><a href="#topic+calculate_ISRatio">calculate_ISRatio</a>()</code>,
<code><a href="#topic+calculate_funnel_limits">calculate_funnel_limits</a>()</code>,
<code><a href="#topic+calculate_funnel_points">calculate_funnel_points</a>()</code>,
<code><a href="#topic+phe_dsr">phe_dsr</a>()</code>,
<code><a href="#topic+phe_life_expectancy">phe_life_expectancy</a>()</code>,
<code><a href="#topic+phe_mean">phe_mean</a>()</code>,
<code><a href="#topic+phe_proportion">phe_proportion</a>()</code>,
<code><a href="#topic+phe_quantile">phe_quantile</a>()</code>,
<code><a href="#topic+phe_rate">phe_rate</a>()</code>,
<code><a href="#topic+phe_sii">phe_sii</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
df &lt;- data.frame(indicatorid = rep(c(1234, 5678, 91011, 121314), each = 19 * 2 * 5),
                 year = rep(2006:2010, each = 19 * 2),
                 sex = rep(rep(c("Male", "Female"), each = 19), 5),
                 ageband = rep(c(0,5,10,15,20,25,30,35,40,45,
                                 50,55,60,65,70,75,80,85,90), times = 10),
                 obs = sample(200, 19 * 2 * 5 * 4, replace = TRUE),
                 pop = sample(10000:20000, 19 * 2 * 5 * 4, replace = TRUE))

refdf &lt;- data.frame(refcount = sample(200, 19, replace = TRUE),
                    refpop = sample(10000:20000, 19, replace = TRUE))

## calculate multiple ISRs in single execution
df %&gt;%
    group_by(indicatorid, year, sex) %&gt;%
    calculate_ISRate(obs, pop, refdf$refcount, refdf$refpop)

## execute without outputting metadata fields
df %&gt;%
    group_by(indicatorid, year, sex) %&gt;%
    calculate_ISRate(obs, pop, refdf$refcount, refdf$refpop, type="standard", confidence=99.8)

## calculate 95% and 99.8% CIs in single execution
df %&gt;%
    group_by(indicatorid, year, sex) %&gt;%
    calculate_ISRate(obs, pop, refdf$refcount, refdf$refpop, confidence = c(0.95, 0.998))

## Calculate ISR when observed totals aren't available with age-breakdowns
observed_totals &lt;- data.frame(indicatorid = rep(c(1234, 5678, 91011, 121314), each = 10),
                       year = rep(rep(2006:2010, each = 2),4),
                       sex = rep(rep(c("Male", "Female"), each = 1),20),
                       observed = sample(1500:2500, 40))

df %&gt;%
    group_by(indicatorid, year, sex) %&gt;%
    calculate_ISRate(observed, pop, refdf$refcount, refdf$refpop,
    observed_totals = observed_totals)


</code></pre>

<hr>
<h2 id='calculate_ISRatio'>Calculate Indirectly standardised ratios using calculate_ISRatio</h2><span id='topic+calculate_ISRatio'></span>

<h3>Description</h3>

<p>Calculates standard mortality ratios (or indirectly standardised ratios) with
confidence limits using Byar's (1) or exact (2) CI method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>calculate_ISRatio(
  data,
  x,
  n,
  x_ref,
  n_ref,
  refpoptype = "vector",
  type = "full",
  confidence = 0.95,
  refvalue = 1,
  observed_totals = NULL
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="calculate_ISRatio_+3A_data">data</code></td>
<td>
<p>data.frame containing the data to be standardised, pre-grouped if
multiple ISRs required; unquoted string; no default</p>
</td></tr>
<tr><td><code id="calculate_ISRatio_+3A_x">x</code></td>
<td>
<p>field name from data containing the observed number of events for
each standardisation category (eg ageband) within each grouping set (eg
area). Alternatively, if not providing age breakdowns for observed events,
field name from observed_totals containing the observed number of events
within each grouping set ; unquoted string; no default</p>
</td></tr>
<tr><td><code id="calculate_ISRatio_+3A_n">n</code></td>
<td>
<p>field name from data containing the populations for each
standardisation category (eg ageband) within each grouping set (eg area);
unquoted string; no default</p>
</td></tr>
<tr><td><code id="calculate_ISRatio_+3A_x_ref">x_ref</code></td>
<td>
<p>the observed number of events in the reference population for
each standardisation category (eg age band); unquoted numeric vector or
field name from data depending on value of refpoptype; no default</p>
</td></tr>
<tr><td><code id="calculate_ISRatio_+3A_n_ref">n_ref</code></td>
<td>
<p>the reference population for each standardisation category (eg
age band); unquoted numeric vector or field name from data depending on
value of refpoptype; no default</p>
</td></tr>
<tr><td><code id="calculate_ISRatio_+3A_refpoptype">refpoptype</code></td>
<td>
<p>whether x_ref and n_ref have been specified as vectors or a
field name from data; quoted string &quot;field&quot; or &quot;vector&quot;; default = &quot;vector&quot;</p>
</td></tr>
<tr><td><code id="calculate_ISRatio_+3A_type">type</code></td>
<td>
<p>defines the data and metadata columns to be included in output;
can be &quot;value&quot;, &quot;lower&quot;, &quot;upper&quot;, &quot;standard&quot; (for all data) or &quot;full&quot; (for
all data and metadata); quoted string; default = &quot;full&quot;</p>
</td></tr>
<tr><td><code id="calculate_ISRatio_+3A_confidence">confidence</code></td>
<td>
<p>the required level of confidence expressed as a number
between 0.9 and 1 or a number between 90 and 100 or can be a vector of 0.95
and 0.998, for example, to output both 95 percent and 99.8 percent percent CIs; numeric;
default 0.95</p>
</td></tr>
<tr><td><code id="calculate_ISRatio_+3A_refvalue">refvalue</code></td>
<td>
<p>the standardised reference ratio, numeric, default = 1</p>
</td></tr>
<tr><td><code id="calculate_ISRatio_+3A_observed_totals">observed_totals</code></td>
<td>
<p>data.frame containing total observed events for each
group, if not provided with age-breakdowns in data. Must only contain the
count field (x) plus grouping columns required to join to data using the
same grouping column names; default = NULL</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When type = &quot;full&quot;, returns a tibble of observed events, expected
events, standardised mortality ratios, lower confidence limits, upper
confidence limits, confidence level, statistic and method for each grouping
set
</p>


<h3>Notes</h3>

<p>User MUST ensure that x, n, x_ref and n_ref vectors are all
ordered by the same standardisation category values as records will be
matched by position. <br /> <br /> For numerators &gt;= 10 Byar's method (1) is
applied using the internal byars_lower and byars_upper functions.  For
small numerators Byar's method is less accurate and so an exact method (2)
based on the Poisson distribution is used. <br />  <br /> This function directly
replaced phe_smr which was fully deprecated in package version 2.0.0 due to
ambiguous naming
</p>


<h3>References</h3>

<p>(1) Breslow NE, Day NE. Statistical methods in cancer research,
volume II: The design and analysis of cohort studies. Lyon: International
Agency for Research on Cancer, World Health Organisation; 1987. <br /> <br />
(2) Armitage P, Berry G. Statistical methods in medical research (4th edn).
Oxford: Blackwell; 2002.
</p>


<h3>See Also</h3>

<p>Other PHEindicatormethods package functions: 
<code><a href="#topic+assign_funnel_significance">assign_funnel_significance</a>()</code>,
<code><a href="#topic+calculate_ISRate">calculate_ISRate</a>()</code>,
<code><a href="#topic+calculate_funnel_limits">calculate_funnel_limits</a>()</code>,
<code><a href="#topic+calculate_funnel_points">calculate_funnel_points</a>()</code>,
<code><a href="#topic+phe_dsr">phe_dsr</a>()</code>,
<code><a href="#topic+phe_life_expectancy">phe_life_expectancy</a>()</code>,
<code><a href="#topic+phe_mean">phe_mean</a>()</code>,
<code><a href="#topic+phe_proportion">phe_proportion</a>()</code>,
<code><a href="#topic+phe_quantile">phe_quantile</a>()</code>,
<code><a href="#topic+phe_rate">phe_rate</a>()</code>,
<code><a href="#topic+phe_sii">phe_sii</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
df &lt;- data.frame(indicatorid = rep(c(1234, 5678, 91011, 121314), each = 19 * 2 * 5),
                 year = rep(2006:2010, each = 19 * 2),
                 sex = rep(rep(c("Male", "Female"), each = 19), 5),
                 ageband = rep(c(0,5,10,15,20,25,30,35,40,45,
                                 50,55,60,65,70,75,80,85,90), times = 10),
                 obs = sample(200, 19 * 2 * 5 * 4, replace = TRUE),
                 pop = sample(10000:20000, 19 * 2 * 5 * 4, replace = TRUE))

refdf &lt;- data.frame(refcount = sample(200, 19, replace = TRUE),
                    refpop = sample(10000:20000, 19, replace = TRUE))

df %&gt;%
    group_by(indicatorid, year, sex) %&gt;%
    calculate_ISRatio(obs, pop, refdf$refcount, refdf$refpop, type="standard")

## OR

df %&gt;%
    group_by(indicatorid, year, sex) %&gt;%
    calculate_ISRatio(obs, pop, refdf$refcount, refdf$refpop, confidence=99.8, refvalue=100)

## Calculate ISR when observed totals aren't available with age-breakdowns
observed_totals &lt;- data.frame(indicatorid = rep(c(1234, 5678, 91011, 121314), each = 10),
                       year = rep(rep(2006:2010, each = 2),4),
                       sex = rep(rep(c("Male", "Female"), each = 1),20),
                       observed = sample(1500:2500, 40))

df %&gt;%
    group_by(indicatorid, year, sex) %&gt;%
    calculate_ISRatio(observed, pop, refdf$refcount, refdf$refpop,
    observed_totals = observed_totals)

</code></pre>

<hr>
<h2 id='DSR_data'>SII test datasets - DSR</h2><span id='topic+DSR_data'></span>

<h3>Description</h3>

<p>A data table of dummy Directly Standardised Rates by deprivation quintiles
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(DSR_data)
</code></pre>


<h3>Format</h3>

<p>A data table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>DSR_data

</code></pre>

<hr>
<h2 id='esp2013'>European Standard Population 2013</h2><span id='topic+esp2013'></span>

<h3>Description</h3>

<p>A numeric vector containing nineteen 5-year age band populations making up the 2013 European Standard Population
ordered from age 0-4, 5-9, 10-14 ... to ...  85-89, 90+.  Sorted by increasing age band.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>esp2013
</code></pre>


<h3>Format</h3>

<p>A numeric vector with 19 elements
</p>


<h3>Value</h3>

<p>5000 5500 5500 5500 6000 6000 6500 7000 7000 7000 7000 6500 6000 5500 5000 4000 2500 1500 1000
</p>


<h3>Notes</h3>

<p>The 2013 European Standard Population is modelled and published by Eurostat (1) for use in the production of
age-standardised rates.  It uses the unweighted average 2010-based population projections of the European Union (x27)
and European Free Trade Association (x4) countries for the period 2011-2030 broken down into 5-year age bands from
age 0 - age 95+ with the 0-5 age band separated into age 0 and age 1-4.  The version provided with this package combines
the age 0 and age 1-4 populations into a single 0-4 age band and combines the 90-94 and 95+ populations into a single 90+ age band,
giving 19 age bands in total.
</p>


<h3>References</h3>

<p>(1) Eurostat Methodologies and Working Papers. Revision of the European Standard Population: Report of Eurostat's Taskforce, 2013. <br />
<a href="https://ec.europa.eu/eurostat/documents/3859598/5926869/KS-RA-13-028-EN.PDF/e713fa79-1add-44e8-b23d-5e8fa09b3f8f">https://ec.europa.eu/eurostat/documents/3859598/5926869/KS-RA-13-028-EN.PDF/e713fa79-1add-44e8-b23d-5e8fa09b3f8f</a>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>esp2013

</code></pre>

<hr>
<h2 id='LE_data'>SII test datasets - Life Expectancy</h2><span id='topic+LE_data'></span>

<h3>Description</h3>

<p>A data table of life expectancy data by area and deprivation decile
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(LE_data)
</code></pre>


<h3>Format</h3>

<p>A data table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>LE_data

</code></pre>

<hr>
<h2 id='phe_dsr'>Calculate Directly Standardised Rates using phe_dsr</h2><span id='topic+phe_dsr'></span>

<h3>Description</h3>

<p>Calculates directly standardised rates with confidence limits using Byar's
method (1) with Dobson method adjustment (2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phe_dsr(
  data,
  x,
  n,
  stdpop = esp2013,
  stdpoptype = "vector",
  type = "full",
  confidence = 0.95,
  multiplier = 1e+05
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phe_dsr_+3A_data">data</code></td>
<td>
<p>data.frame containing the data to be standardised, pre-grouped if
multiple DSRs required; unquoted string; no default</p>
</td></tr>
<tr><td><code id="phe_dsr_+3A_x">x</code></td>
<td>
<p>field name from data containing the observed number of events for
each standardisation category (eg ageband) within each grouping set (eg
area); unquoted string; no default</p>
</td></tr>
<tr><td><code id="phe_dsr_+3A_n">n</code></td>
<td>
<p>field name from data containing the populations for each
standardisation category (eg ageband) within each grouping set (eg area);
unquoted string; no default</p>
</td></tr>
<tr><td><code id="phe_dsr_+3A_stdpop">stdpop</code></td>
<td>
<p>the standard populations for each standardisation category (eg
age band); unquoted string referencing a numeric vector or field name from
data depending on value of stdpoptype; default = esp2013</p>
</td></tr>
<tr><td><code id="phe_dsr_+3A_stdpoptype">stdpoptype</code></td>
<td>
<p>whether the stdpop has been specified as a vector or a
field name from data; quoted string &quot;field&quot; or &quot;vector&quot;; default = &quot;vector&quot;</p>
</td></tr>
<tr><td><code id="phe_dsr_+3A_type">type</code></td>
<td>
<p>defines the data and metadata columns to be included in output;
can be &quot;value&quot;, &quot;lower&quot;, &quot;upper&quot;, &quot;standard&quot; (for all data) or &quot;full&quot; (for
all data and metadata); quoted string; default = &quot;full&quot;</p>
</td></tr>
<tr><td><code id="phe_dsr_+3A_confidence">confidence</code></td>
<td>
<p>the required level of confidence expressed as a number
between 0.9 and 1 or a number between 90 and 100 or can be a vector of 0.95
and 0.998, for example, to output both 95 percent and 99.8 percent percent CIs; numeric;
default 0.95</p>
</td></tr>
<tr><td><code id="phe_dsr_+3A_multiplier">multiplier</code></td>
<td>
<p>the multiplier used to express the final values (eg 100,000
= rate per 100,000); numeric; default 100,000</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When type = &quot;full&quot;, returns a tibble of total counts, total
populations, directly standardised rates, lower confidence limits, upper
confidence limits, confidence level, statistic and method for each grouping
set
</p>


<h3>Notes</h3>

<p>User MUST ensure that x, n and stdpop vectors are all ordered
by the same standardisation category values as records will be matched by
position. <br /> <br /> For total counts &gt;= 10 Byar's method (1) is applied using
the internal byars_lower and byars_upper functions.
When the total count is &lt; 10 DSRs are not reliable and will therefore not
be calculated.
</p>


<h3>References</h3>

<p>(1) Breslow NE, Day NE. Statistical methods in cancer research,
volume II: The design and analysis of cohort studies. Lyon: International
Agency for Research on Cancer, World Health Organisation; 1987. <br /> <br />
(2) Dobson A et al. Confidence intervals for weighted sums of Poisson parameters. Stat Med 1991;10:457-62.
</p>


<h3>See Also</h3>

<p>Other PHEindicatormethods package functions: 
<code><a href="#topic+assign_funnel_significance">assign_funnel_significance</a>()</code>,
<code><a href="#topic+calculate_ISRate">calculate_ISRate</a>()</code>,
<code><a href="#topic+calculate_ISRatio">calculate_ISRatio</a>()</code>,
<code><a href="#topic+calculate_funnel_limits">calculate_funnel_limits</a>()</code>,
<code><a href="#topic+calculate_funnel_points">calculate_funnel_points</a>()</code>,
<code><a href="#topic+phe_life_expectancy">phe_life_expectancy</a>()</code>,
<code><a href="#topic+phe_mean">phe_mean</a>()</code>,
<code><a href="#topic+phe_proportion">phe_proportion</a>()</code>,
<code><a href="#topic+phe_quantile">phe_quantile</a>()</code>,
<code><a href="#topic+phe_rate">phe_rate</a>()</code>,
<code><a href="#topic+phe_sii">phe_sii</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
df &lt;- data.frame(indicatorid = rep(c(1234, 5678, 91011, 121314),
                 each = 19 * 2 * 5),
                 year = rep(2006:2010, each = 19 * 2),
                 sex = rep(rep(c("Male", "Female"), each = 19), 5),
                 ageband = rep(c(0,5,10,15,20,25,30,35,40,45,
                                 50,55,60,65,70,75,80,85,90), times = 10),
                 obs = sample(200, 19 * 2 * 5 * 4, replace = TRUE),
                 pop = sample(10000:20000, 19 * 2 * 5 * 4, replace = TRUE))

## default execution
df %&gt;%
    group_by(indicatorid, year, sex) %&gt;%
    phe_dsr(obs, pop)

## calculate both 95% and 99.8% CIs in single execution
df %&gt;%
    group_by(indicatorid, year, sex) %&gt;%
    phe_dsr(obs, pop, confidence = c(0.95, 0.998))

## calculate DSRs for multiple grouping sets in single execution

df %&gt;%
    group_by(indicatorid, year, sex) %&gt;%
    phe_dsr(obs, pop, type = "standard")

</code></pre>

<hr>
<h2 id='phe_life_expectancy'>Calculate Life Expectancy using phe_life_expectancy</h2><span id='topic+phe_life_expectancy'></span>

<h3>Description</h3>

<p>Compute life expectancy for a given age, and its standard error
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phe_life_expectancy(
  data,
  deaths,
  population,
  startage,
  age_contents = c(0L, 1L, 5L, 10L, 15L, 20L, 25L, 30L, 35L, 40L, 45L, 50L, 55L, 60L,
    65L, 70L, 75L, 80L, 85L, 90L),
  le_age = "all",
  type = "full",
  confidence = 0.95
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phe_life_expectancy_+3A_data">data</code></td>
<td>
<p>data.frame or tbl containing the deaths and population data</p>
</td></tr>
<tr><td><code id="phe_life_expectancy_+3A_deaths">deaths</code></td>
<td>
<p>field name from data containing the number of deaths within age
band; unquoted string; no default</p>
</td></tr>
<tr><td><code id="phe_life_expectancy_+3A_population">population</code></td>
<td>
<p>field name from data containing the population within age
band; unquoted string; no default</p>
</td></tr>
<tr><td><code id="phe_life_expectancy_+3A_startage">startage</code></td>
<td>
<p>field name from data containing the age band; no default</p>
</td></tr>
<tr><td><code id="phe_life_expectancy_+3A_age_contents">age_contents</code></td>
<td>
<p>vector; describes the contents of startage in the
ascending order. This vector is used to check whether each group in data
contains the complete set of age bands for the calculation to occur. It is also
used to reorder the data based on the startage field</p>
</td></tr>
<tr><td><code id="phe_life_expectancy_+3A_le_age">le_age</code></td>
<td>
<p>the age band to return the life expectancy for. The default is
&quot;all&quot;, where the function returns the life expectancy values for all ages
appended onto the input table. Any other value (or vector of values) must be age bands
described by the age_contents input</p>
</td></tr>
<tr><td><code id="phe_life_expectancy_+3A_type">type</code></td>
<td>
<p>type of output; can be &quot;standard&quot; or &quot;full&quot; (full contains
added details on the calculation within the dataframe); quoted
string; default full</p>
</td></tr>
<tr><td><code id="phe_life_expectancy_+3A_confidence">confidence</code></td>
<td>
<p>the required level of confidence expressed as a number
between 0.9 and 1 or a number between 90 and 100 or can be a vector of 0.95
and 0.998, for example, to output both 95 percent and 99.8 percent percent CIs; numeric;
default 0.95</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function aligns with the methodology in Public Health England's
Life Expectancy Calculator available on the
<a href="https://fingertips.phe.org.uk/profile/guidance/supporting-information/PH-methods">Fingertips Technical Guidance</a>
web page.
</p>
<p>The function is for an abridged life table using 5 year age intervals with
a final age interval of 90+. The table has been completed using the methods
described by Chiang.(1, 2)  This age structure and methodology is used by
The Office for National Statistics to produce life expectancy at national
and local authority level.(3)
</p>
<p>This function includes an adjustment to the method for calculating the
variance of the life expectancy estimate to include a term for the variance
associated with the final age interval. In the Chiang method the variance of
the life expectancy is the weighted sum of the variance of the probability
of survival across all the age intervals.  For the final age interval the
probability of survival is, Chiang argues, zero and has zero variance.
However, Silcocks et al argue(4) that in the case of the final age interval
the life expectancy is dependent not on the probability of survival but on
the mean length of survival <code class="reqn">(1/M&lt;sub&gt;omega&lt;/sub&gt;)</code>.
Therefore the variance associated with the final age interval depends on the
age-specific mortality rate <code class="reqn">M&lt;sub&gt;omega&lt;/sub&gt;</code>.
</p>
<p>Life expectancy cannot be calculated if the person-years in any given age
interval is zero. It will also not be calculated if the total person-years
is less than 5,000 as this is considered to be the minimum size for robust
calculation of life expectancy.(5)  Zero death counts are not a problem,
except for the final age interval - there must be at least one death in the
90+ interval for the calculations to be possible.
</p>
<p>Individual Life Expectancy values will be suppressed (although confidence
intervals will be shown) when the 95% confidence interval is greater
than 20 years.
</p>
<p>The methodology used in this function, along with discussion of alternative
options for life expectancy calculation for small areas, were described Eayres
and Williams.(6)
</p>


<h3>Value</h3>

<p>returns a data frame containing the life expectancies and confidence intervals
for each le_age requested.  When type = 'full' additionally returns the cumulative
populations and deaths used in each LE calculation and metadata indicating parameters passed.
</p>


<h3>Author(s)</h3>

<p>Sebastian Fox, <a href="mailto:sebastian.fox@phe.gov.uk">sebastian.fox@phe.gov.uk</a>
</p>


<h3>References</h3>

<p>(1) Chiang CL. The Life Table and its Construction. In: Introduction to
Stochastic Processes in Biostatistics. New York, John Wiley &amp; Sons, 1968:189-214. <br /> <br />
(2) Newell C. Methods and Models in Demography. Chichester, John Wiley &amp; Sons, 1994:63-81 <br /> <br />
(3) Office for National Statistics Report. Life expectancy at birth by
health and local authorities in the United Kingdom, 1998 to 2000 (3-year
aggregate figures.) Health Statistics Quarterly 2002;13:83-90 <br /> <br />
(4) Silcocks PBS, Jenner DA, Reza R.  Life expectancy as a summary of mortality
in a population: statistical considerations and suitability for use by health
authorities. J Epidemiol Community Health 2001;55:38-43 <br /> <br />
(5) Toson B, Baker A. Life expectancy at birth: methodological options for
small populations. National Statistics  Methodological Series No 33. HMSO 2003. <br /> <br />
(6) Eayres DP, Williams ES. Evaluation of methodologies for small area
life expectancy estimation. J Epidemiol Community Health 2004;58:243-249 <br /> <br />
</p>


<h3>See Also</h3>

<p>Other PHEindicatormethods package functions: 
<code><a href="#topic+assign_funnel_significance">assign_funnel_significance</a>()</code>,
<code><a href="#topic+calculate_ISRate">calculate_ISRate</a>()</code>,
<code><a href="#topic+calculate_ISRatio">calculate_ISRatio</a>()</code>,
<code><a href="#topic+calculate_funnel_limits">calculate_funnel_limits</a>()</code>,
<code><a href="#topic+calculate_funnel_points">calculate_funnel_points</a>()</code>,
<code><a href="#topic+phe_dsr">phe_dsr</a>()</code>,
<code><a href="#topic+phe_mean">phe_mean</a>()</code>,
<code><a href="#topic+phe_proportion">phe_proportion</a>()</code>,
<code><a href="#topic+phe_quantile">phe_quantile</a>()</code>,
<code><a href="#topic+phe_rate">phe_rate</a>()</code>,
<code><a href="#topic+phe_sii">phe_sii</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

## A simple example
df &lt;- data.frame(startage = c(0L, 1L, 5L, 10L, 15L, 20L, 25L, 30L, 35L, 40L, 45L, 50L, 55L,
                              60L, 65L, 70L, 75L, 80L, 85L, 90L),
                 pops = c(7060L, 35059L, 46974L, 48489L, 43219L, 38561L, 46009L, 57208L,
                          61435L, 55601L, 50209L, 56416L, 46411L, 39820L, 37978L,
                          37039L, 33288L, 23306L, 11936L, 11936L),
                 deaths = c(17L, 9L, 4L, 8L, 20L, 15L, 24L, 33L, 50L, 71L, 100L, 163L,
                            263L, 304L, 536L, 872L, 1390L, 1605L, 1936L, 1937L))
phe_life_expectancy(df, deaths, pops, startage)

## or with multiple confidence limits
phe_life_expectancy(df, deaths, pops, startage, confidence = c(95, 99.8))

## OR

phe_life_expectancy(df, deaths, pops, startage, le_age = c(5, 25), type = "standard")

## Unordered age bands example
df &lt;- data.frame(startage = c("0", "1-4", "5-9", "10 - 14", "15 - 19", "20 - 24", "25 - 29",
                              "30 - 34", "35 - 39", "40 - 44", "45 - 49", "50 - 54",
                              "55 - 59", "60 - 64", "65 - 69", "75 - 79", "80 - 84",
                              "85 - 89", "90 +", "70 - 74"),
                 pops = c(7060L, 35059L, 46974L, 48489L, 43219L, 38561L, 46009L, 57208L,
                          61435L, 55601L, 50209L, 56416L, 46411L, 39820L, 37039L,
                          23306L, 11936L, 11936L, 37978L, 33288L),
                 deaths = c(17L, 9L, 4L, 8L, 20L, 15L, 24L, 33L, 50L, 71L, 100L, 163L,
                            263L, 304L, 872L, 1605L, 1936L, 1937L, 536L, 1390L))
phe_life_expectancy(df, deaths, pops, startage,
                    age_contents = c("0", "1-4", "5-9",
                                     "10 - 14", "15 - 19",
                                     "20 - 24", "25 - 29",
                                     "30 - 34", "35 - 39",
                                     "40 - 44", "45 - 49",
                                     "50 - 54", "55 - 59",
                                     "60 - 64", "65 - 69",
                                     "70 - 74", "75 - 79",
                                     "80 - 84", "85 - 89",
                                     "90 +"))

df &lt;- data.frame(area = c(rep("Area 1", 20), rep("Area 2", 20)),
                 startage = rep(c(0L, 1L, 5L, 10L, 15L, 20L, 25L, 30L, 35L, 40L, 45L, 50L, 55L,
                                  60L, 65L, 70L, 75L, 80L, 85L, 90L), 2),
                 pops = rep(c(7060L, 35059L, 46974L, 48489L, 43219L, 38561L, 46009L, 57208L,
                              61435L, 55601L, 50209L, 56416L, 46411L, 39820L, 37978L,
                              37039L, 33288L, 23306L, 11936L, 11936L), 2),
                 deaths = rep(c(17L, 9L, 4L, 8L, 20L, 15L, 24L, 33L, 50L, 71L, 100L, 163L,
                                263L, 304L, 536L, 872L, 1390L, 1605L, 1936L, 1937L), 2))
df %&gt;%
       group_by(area) %&gt;%
       phe_life_expectancy(deaths, pops, startage)

</code></pre>

<hr>
<h2 id='phe_mean'>Calculate Means using phe_mean</h2><span id='topic+phe_mean'></span>

<h3>Description</h3>

<p>Calculates means with confidence limits using Student's t-distribution method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phe_mean(data, x, type = "full", confidence = 0.95)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phe_mean_+3A_data">data</code></td>
<td>
<p>a data.frame containing the data to calculate means for, pre-grouped if multiple means required; unquoted string; no default</p>
</td></tr>
<tr><td><code id="phe_mean_+3A_x">x</code></td>
<td>
<p>field name from data containing the values to calculate the means for; unquoted string; no default</p>
</td></tr>
<tr><td><code id="phe_mean_+3A_type">type</code></td>
<td>
<p>defines the data and metadata columns to be included in output;
can be &quot;value&quot;, &quot;lower&quot;, &quot;upper&quot;, &quot;standard&quot; (for all data) or &quot;full&quot; (for
all data and metadata); quoted string; default = &quot;full&quot;</p>
</td></tr>
<tr><td><code id="phe_mean_+3A_confidence">confidence</code></td>
<td>
<p>the required level of confidence expressed as a number
between 0.9 and 1 or a number between 90 and 100 or can be a vector of 0.95
and 0.998, for example, to output both 95 percent and 99.8 percent percent CIs; numeric;
default 0.95</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When type = &quot;full&quot;, returns a data.frame of value_sum, value_count, stdev, value, lowercl, uppercl, confidence, statistic and method
for each grouping set
</p>


<h3>See Also</h3>

<p>Other PHEindicatormethods package functions: 
<code><a href="#topic+assign_funnel_significance">assign_funnel_significance</a>()</code>,
<code><a href="#topic+calculate_ISRate">calculate_ISRate</a>()</code>,
<code><a href="#topic+calculate_ISRatio">calculate_ISRatio</a>()</code>,
<code><a href="#topic+calculate_funnel_limits">calculate_funnel_limits</a>()</code>,
<code><a href="#topic+calculate_funnel_points">calculate_funnel_points</a>()</code>,
<code><a href="#topic+phe_dsr">phe_dsr</a>()</code>,
<code><a href="#topic+phe_life_expectancy">phe_life_expectancy</a>()</code>,
<code><a href="#topic+phe_proportion">phe_proportion</a>()</code>,
<code><a href="#topic+phe_quantile">phe_quantile</a>()</code>,
<code><a href="#topic+phe_rate">phe_rate</a>()</code>,
<code><a href="#topic+phe_sii">phe_sii</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)
df &lt;- data.frame(values = c(30,40,50,60))

## default execution
phe_mean(df, values)

## calculate 95% and 99.8% CIs in single execution
phe_mean(df, values, confidence = c(0.95, 0.998))

## calculate multiple means in a single execution

df2 &lt;- data.frame(area = rep(c("Area1", "Area2"),each=3),
                  values = c(20,30,40,200,300,400)) %&gt;%
                  group_by(area)
phe_mean(df2,values)
phe_mean(df2,values,type="standard", confidence=0.998)


</code></pre>

<hr>
<h2 id='phe_proportion'>Calculate Proportions using phe_proportion</h2><span id='topic+phe_proportion'></span>

<h3>Description</h3>

<p>Calculates proportions with confidence limits using Wilson Score method (1,2).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phe_proportion(data, x, n, type = "full", confidence = 0.95, multiplier = 1)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phe_proportion_+3A_data">data</code></td>
<td>
<p>a data.frame containing the data to calculate proportions for, pre-grouped if proportions required for
group aggregates; unquoted string; no default</p>
</td></tr>
<tr><td><code id="phe_proportion_+3A_x">x</code></td>
<td>
<p>field name from data containing the observed numbers of cases in the sample meeting the required condition
(the numerator for the proportion); unquoted string; no default</p>
</td></tr>
<tr><td><code id="phe_proportion_+3A_n">n</code></td>
<td>
<p>field name from data containing the number of cases in the sample (the denominator for the proportion);
unquoted string; no default</p>
</td></tr>
<tr><td><code id="phe_proportion_+3A_type">type</code></td>
<td>
<p>defines the data and metadata columns to be included in output;
can be &quot;value&quot;, &quot;lower&quot;, &quot;upper&quot;, &quot;standard&quot; (for all data) or &quot;full&quot; (for
all data and metadata); quoted string; default = &quot;full&quot;</p>
</td></tr>
<tr><td><code id="phe_proportion_+3A_confidence">confidence</code></td>
<td>
<p>the required level of confidence expressed as a number
between 0.9 and 1 or a number between 90 and 100. The vector c(0.95, 0.998)
can also be passed to output both 95 percent and 99.8 percent CIs, or an NA
value can be passed if no confidence intervals are required.; numeric; default 0.95</p>
</td></tr>
<tr><td><code id="phe_proportion_+3A_multiplier">multiplier</code></td>
<td>
<p>the multiplier used to express the final values (eg 100 = percentage); numeric; default 1</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When type = &quot;full&quot;, returns the original data.frame with the following appended:
proportion, lower confidence limit, upper confidence limit, confidence level, statistic and method
</p>


<h3>Notes</h3>

<p>Wilson Score method (2) is applied using the internal wilson_lower
and wilson_upper functions. <br /> <br />
The percentage argument was deprecated in v1_1_0, please use multiplier argument instead
</p>


<h3>References</h3>

<p>(1) Wilson EB. Probable inference, the law of succession, and statistical
inference. J Am Stat Assoc; 1927; 22. Pg 209 to 212. <br />
(2) Newcombe RG, Altman DG. Proportions and their differences. In Altman
DG et al. (eds). Statistics with confidence (2nd edn). London: BMJ Books;
2000. Pg 46 to 48.
</p>


<h3>See Also</h3>

<p>Other PHEindicatormethods package functions: 
<code><a href="#topic+assign_funnel_significance">assign_funnel_significance</a>()</code>,
<code><a href="#topic+calculate_ISRate">calculate_ISRate</a>()</code>,
<code><a href="#topic+calculate_ISRatio">calculate_ISRatio</a>()</code>,
<code><a href="#topic+calculate_funnel_limits">calculate_funnel_limits</a>()</code>,
<code><a href="#topic+calculate_funnel_points">calculate_funnel_points</a>()</code>,
<code><a href="#topic+phe_dsr">phe_dsr</a>()</code>,
<code><a href="#topic+phe_life_expectancy">phe_life_expectancy</a>()</code>,
<code><a href="#topic+phe_mean">phe_mean</a>()</code>,
<code><a href="#topic+phe_quantile">phe_quantile</a>()</code>,
<code><a href="#topic+phe_rate">phe_rate</a>()</code>,
<code><a href="#topic+phe_sii">phe_sii</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# ungrouped data frame
df &lt;- data.frame(area = rep(c("Area1","Area2","Area3","Area4"), each=3),
                 numerator = c(NA,82,9,48, 6500,8200,10000,10000,8,7,750,900),
                 denominator = rep(c(100,10000,10000,10000), each=3))

phe_proportion(df, numerator, denominator)
phe_proportion(df, numerator, denominator, confidence=99.8)
phe_proportion(df, numerator, denominator, type="standard")
phe_proportion(df, numerator, denominator, confidence = c(0.95, 0.998))

# grouped data frame
library(dplyr)
dfg &lt;- df |&gt; group_by(area)
phe_proportion(dfg, numerator, denominator, multiplier=100)


</code></pre>

<hr>
<h2 id='phe_quantile'>Assign Quantiles using phe_quantile</h2><span id='topic+phe_quantile'></span>

<h3>Description</h3>

<p>Assigns data to quantiles based on numeric data rankings.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phe_quantile(
  data,
  values,
  nquantiles = 10L,
  invert = TRUE,
  inverttype = "logical",
  type = "full"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phe_quantile_+3A_data">data</code></td>
<td>
<p>a data frame containing the quantitative data to be assigned to
quantiles. If pre-grouped, separate sets of quantiles will be assigned for
each grouping set; unquoted string; no default</p>
</td></tr>
<tr><td><code id="phe_quantile_+3A_values">values</code></td>
<td>
<p>field name from data containing the numeric values to rank data
by and assign quantiles from; unquoted string; no default</p>
</td></tr>
<tr><td><code id="phe_quantile_+3A_nquantiles">nquantiles</code></td>
<td>
<p>the number of quantiles to separate each grouping set into;
numeric; default=10L</p>
</td></tr>
<tr><td><code id="phe_quantile_+3A_invert">invert</code></td>
<td>
<p>whether the quantiles should be directly (FALSE) or inversely
(TRUE) related to the numerical value order; logical (to apply same value
to all grouping sets) OR unquoted string referencing field name from data
that stores logical values for each grouping set; default = TRUE (ie
highest values assigned to quantile 1)</p>
</td></tr>
<tr><td><code id="phe_quantile_+3A_inverttype">inverttype</code></td>
<td>
<p>whether the invert argument has been specified as a logical
value or a field name from data; quoted string &quot;field&quot; or &quot;logical&quot;;
default = &quot;logical&quot;</p>
</td></tr>
<tr><td><code id="phe_quantile_+3A_type">type</code></td>
<td>
<p>defines whether to include metadata columns in output to
reference the arguments passed; can be &quot;standard&quot; or &quot;full&quot;; quoted string;
default = &quot;full&quot;</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When type = &quot;full&quot;, returns the original data.frame with quantile
(quantile value), nquantiles (number of quantiles requested), groupvars
(grouping sets quantiles assigned within) and invert (indicating direction
of quantile assignment) fields appended.
</p>


<h3>Notes</h3>

<p>See <a href="https://fingertips.phe.org.uk/profile/guidance/supporting-information/PH-methods">OHID Technical Guide - Assigning Deprivation Categories</a>
for methodology. In particular, note that this function strictly applies
the algorithm defined but some manual review, and potentially adjustment,
is advised in some cases where multiple small areas with equal rank fall
across a natural quantile boundary.
</p>


<h3>See Also</h3>

<p>Other PHEindicatormethods package functions: 
<code><a href="#topic+assign_funnel_significance">assign_funnel_significance</a>()</code>,
<code><a href="#topic+calculate_ISRate">calculate_ISRate</a>()</code>,
<code><a href="#topic+calculate_ISRatio">calculate_ISRatio</a>()</code>,
<code><a href="#topic+calculate_funnel_limits">calculate_funnel_limits</a>()</code>,
<code><a href="#topic+calculate_funnel_points">calculate_funnel_points</a>()</code>,
<code><a href="#topic+phe_dsr">phe_dsr</a>()</code>,
<code><a href="#topic+phe_life_expectancy">phe_life_expectancy</a>()</code>,
<code><a href="#topic+phe_mean">phe_mean</a>()</code>,
<code><a href="#topic+phe_proportion">phe_proportion</a>()</code>,
<code><a href="#topic+phe_rate">phe_rate</a>()</code>,
<code><a href="#topic+phe_sii">phe_sii</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>df &lt;- data.frame(
  region    = as.character(rep(c("Region1","Region2","Region3","Region4"),
                               each=250)),
  smallarea = as.character(paste0("Area",seq_along(1:1000))),
  vals      = as.numeric(sample(200, 1000, replace = TRUE)),
  stringsAsFactors = FALSE)

# assign small areas to deciles across whole data frame
phe_quantile(df, vals)

# assign small areas to deciles within regions by pre-grouping the data frame
library(dplyr)
df_grp &lt;- df %&gt;% group_by(region)
phe_quantile(df_grp, vals)

# assign small areas to quintiles, where highest value = highest quantile
phe_quantile(df, vals, nquantiles = 5L, invert=FALSE)

</code></pre>

<hr>
<h2 id='phe_rate'>Calculate Rates using phe_rate</h2><span id='topic+phe_rate'></span>

<h3>Description</h3>

<p>Calculates rates with confidence limits using Byar's (1) or exact (2) CI method.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phe_rate(data, x, n, type = "full", confidence = 0.95, multiplier = 1e+05)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phe_rate_+3A_data">data</code></td>
<td>
<p>the data.frame containing the data to calculate rates for,
pre-grouped if proportions required for group aggregates; unquoted string;
no default</p>
</td></tr>
<tr><td><code id="phe_rate_+3A_x">x</code></td>
<td>
<p>field name from data containing the rate numerators (eg observed
number of events); unquoted string; no default</p>
</td></tr>
<tr><td><code id="phe_rate_+3A_n">n</code></td>
<td>
<p>field name from data containing the rate denominators (eg
populations); unquoted string; no default</p>
</td></tr>
<tr><td><code id="phe_rate_+3A_type">type</code></td>
<td>
<p>defines the data and metadata columns to be included in output;
can be &quot;value&quot;, &quot;lower&quot;, &quot;upper&quot;, &quot;standard&quot; (for all data) or &quot;full&quot; (for
all data and metadata); quoted string; default = &quot;full&quot;</p>
</td></tr>
<tr><td><code id="phe_rate_+3A_confidence">confidence</code></td>
<td>
<p>the required level of confidence expressed as a number
between 0.9 and 1 or a number between 90 and 100 or can be a vector of 0.95
and 0.998, for example, to output both 95 percent and 99.8 percent percent CIs; numeric;
default 0.95</p>
</td></tr>
<tr><td><code id="phe_rate_+3A_multiplier">multiplier</code></td>
<td>
<p>the multiplier used to express the final values (eg 100,000
= rate per 100,000); numeric; default 100,000</p>
</td></tr>
</table>


<h3>Value</h3>

<p>When type = &quot;full&quot;, returns the original data.frame with the
following appended: rate, lower confidence limit, upper confidence limit,
confidence level, statistic and method
</p>


<h3>Notes</h3>

<p>For numerators &gt;= 10 Byar's method (1) is applied using the
internal byars_lower and byars_upper functions.  For
small numerators Byar's method is less accurate and so an exact method (2)
based on the Poisson distribution is used.
</p>


<h3>References</h3>

<p>(1) Breslow NE, Day NE. Statistical methods in cancer research,
volume II: The design and analysis of cohort studies. Lyon: International
Agency for Research on Cancer, World Health Organisation; 1987. <br />
(2) Armitage P, Berry G. Statistical methods in medical research (4th edn).
Oxford: Blackwell; 2002.
</p>


<h3>See Also</h3>

<p>Other PHEindicatormethods package functions: 
<code><a href="#topic+assign_funnel_significance">assign_funnel_significance</a>()</code>,
<code><a href="#topic+calculate_ISRate">calculate_ISRate</a>()</code>,
<code><a href="#topic+calculate_ISRatio">calculate_ISRatio</a>()</code>,
<code><a href="#topic+calculate_funnel_limits">calculate_funnel_limits</a>()</code>,
<code><a href="#topic+calculate_funnel_points">calculate_funnel_points</a>()</code>,
<code><a href="#topic+phe_dsr">phe_dsr</a>()</code>,
<code><a href="#topic+phe_life_expectancy">phe_life_expectancy</a>()</code>,
<code><a href="#topic+phe_mean">phe_mean</a>()</code>,
<code><a href="#topic+phe_proportion">phe_proportion</a>()</code>,
<code><a href="#topic+phe_quantile">phe_quantile</a>()</code>,
<code><a href="#topic+phe_sii">phe_sii</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'># ungrouped data frame
df &lt;- data.frame(area = rep(c("Area1","Area2","Area3","Area4"), each=3),
                 obs = c(NA,82,9,48, 6500,8200,10000,10000,8,7,750,900),
                 pop = rep(c(100,10000,10000,10000), each=3))

phe_rate(df, obs, pop)
phe_rate(df, obs, pop, type="standard")
phe_rate(df, obs, pop, confidence=99.8, multiplier=100)

# grouped data frame
library(dplyr)
dfg &lt;- df %&gt;% group_by(area)
phe_rate(dfg, obs, pop)

</code></pre>

<hr>
<h2 id='phe_sii'>Calculate Slope Index of Inequality using phe_sii</h2><span id='topic+phe_sii'></span>

<h3>Description</h3>

<p><code>phe_sii()</code>returns the slope index of inequality (SII) statistic for each
subgroup of the inputted dataframe, with lower and upper confidence limits
based on the specified confidence.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>phe_sii(
  data,
  quantile,
  population,
  x = NULL,
  value = NULL,
  value_type = 0,
  transform = FALSE,
  lower_cl = NULL,
  upper_cl = NULL,
  se = NULL,
  multiplier = 1,
  repetitions = 1e+05,
  confidence = 0.95,
  rii = FALSE,
  intercept = FALSE,
  reliability_stat = FALSE,
  type = "full"
)
</code></pre>


<h3>Arguments</h3>

<table>
<tr><td><code id="phe_sii_+3A_data">data</code></td>
<td>
<p>data.frame containing the required input fields, pre-grouped if
an SII is required for each subgroup; unquoted string; no default</p>
</td></tr>
<tr><td><code id="phe_sii_+3A_quantile">quantile</code></td>
<td>
<p>field name within data that contains the quantile label (e.g.
decile). The number of quantiles should be between 5 and 100; unquoted
string; no default</p>
</td></tr>
<tr><td><code id="phe_sii_+3A_population">population</code></td>
<td>
<p>field name within data that contains the quantile
populations (ie, denominator). Non-zero populations are required for all
quantiles to calculate SII for an area; unquoted string; no default</p>
</td></tr>
<tr><td><code id="phe_sii_+3A_x">x</code></td>
<td>
<p>(for indicators that are proportions) field name within data that
contains the members of the population with the attribute of interest (ie,
numerator). This will be divided by population to calculate a proportion as
the indicator value (if value field is not provided); unquoted string; no
default</p>
</td></tr>
<tr><td><code id="phe_sii_+3A_value">value</code></td>
<td>
<p>field name within data that contains the indicator value (this
does not need to be supplied for proportions if count and population are
given); unquoted string; no default</p>
</td></tr>
<tr><td><code id="phe_sii_+3A_value_type">value_type</code></td>
<td>
<p>indicates the indicator type (1 = rate, 2 = proportion, 0 =
other). The <code>value_type</code> argument is used to determine whether data should
be transformed prior to calculation of the standard error and/or SII. See
the <code>Tansformations</code> section for full details; integer; default 0</p>
</td></tr>
<tr><td><code id="phe_sii_+3A_transform">transform</code></td>
<td>
<p>option to transform input rates or proportions prior to
calculation of the SII. See the <code>Transformations</code> section for full
details; logical; default FALSE</p>
</td></tr>
<tr><td><code id="phe_sii_+3A_lower_cl">lower_cl</code></td>
<td>
<p>field name within data that contains 95 percent lower
confidence limit of indicator value (to calculate standard error of
indicator value). This field is needed if the se field is not supplied;
unquoted string; no default</p>
</td></tr>
<tr><td><code id="phe_sii_+3A_upper_cl">upper_cl</code></td>
<td>
<p>field name within data that contains 95 percent upper
confidence limit of indicator value (to calculate standard error of
indicator value). This field is needed if the se field is not supplied;
unquoted string; no default</p>
</td></tr>
<tr><td><code id="phe_sii_+3A_se">se</code></td>
<td>
<p>field name within data that contains the standard error of the
indicator value. If not supplied, this will be calculated from the 95
percent lower and upper confidence limits (i.e. one or the other of these
fields must be supplied); unquoted string; no default</p>
</td></tr>
<tr><td><code id="phe_sii_+3A_multiplier">multiplier</code></td>
<td>
<p>factor to multiply the SII and SII confidence limits by
(e.g. set to 100 to return prevalences on a percentage scale between 0 and
100). If the multiplier is negative, the inverse of the RII is taken to
account for the change in polarity; numeric; default 1;</p>
</td></tr>
<tr><td><code id="phe_sii_+3A_repetitions">repetitions</code></td>
<td>
<p>number of random samples to perform to return confidence
interval of SII (and RII). Minimum is 1000, no maximum (though the more
repetitions, the longer the run time); numeric; default 100,000</p>
</td></tr>
<tr><td><code id="phe_sii_+3A_confidence">confidence</code></td>
<td>
<p>confidence level used to calculate the lower and upper
confidence limits of SII, expressed as a number between 0.9 and 1, or 90
and 100. It can be a vector of 0.95 and 0.998, for example, to output both
95 percent and 99.8 percent CIs; numeric; default 0.95</p>
</td></tr>
<tr><td><code id="phe_sii_+3A_rii">rii</code></td>
<td>
<p>option to return the Relative Index of Inequality (RII) with
associated confidence limits as well as the SII; logical; default FALSE</p>
</td></tr>
<tr><td><code id="phe_sii_+3A_intercept">intercept</code></td>
<td>
<p>option to return the intercept value of the regression line
(y value where x=0); logical; default FALSE</p>
</td></tr>
<tr><td><code id="phe_sii_+3A_reliability_stat">reliability_stat</code></td>
<td>
<p>option to carry out the SII confidence interval
simulation 10 times instead of once and return the Mean Average Difference
between the first and subsequent samples (as a measure of the amount of
variation). Warning: this will significantly increase run time of the
function and should first be tested on a small number of repetitions;
logical; default FALSE</p>
</td></tr>
<tr><td><code id="phe_sii_+3A_type">type</code></td>
<td>
<p>&quot;full&quot; output includes columns in the output dataset specifying
the parameters the user has input to the function (value_type, multiplier,
CI_confidence, CI_method); character string either &quot;full&quot; or &quot;standard&quot;;
default &quot;full&quot;</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The Relative Index of Inequality (RII) can also be returned via an optional
argument.
</p>
<p>The SII and RII are two measures of health inequality. They show the relation
between the level of health or frequency of a health problem in different
population groups and the ranking of these groups on the social scale.
</p>
<p>The input dataframe should be grouped before passing to the function if an
SII/RII for each subgroup is required, and quantiles ordered from least to
most advantaged.
</p>


<h3>Value</h3>

<p>The SII with lower and upper confidence limits for each subgroup of
the inputted data.frame.
</p>


<h3>Calculation</h3>

<p>The SII is calculated using linear regression (1). To allow for differences
in population size between quantiles (e.g. deprivation deciles), each is
given a rank score (or relative rank) based on the midpoint of its range in
the cumulative distribution of the total area population. The quantiles are
first ordered (e.g from 1 most deprived to 10 least deprived for deprivation
deciles). If quantile 1 then contains 12 percent of the total population, its
relative rank is <code>0.12/2=0.6</code>. If quantile 2 includes 10 percent of the
population, its relative rank is <code>0.12+(0.10/2)=0.17</code>. A square root
transformation is applied to the regression to account for heteroskedasticity
(the tendancy for the variances of the quantile values to be related to the
size of the values, ie larger values will tend to have larger variances). A
regression model is fitted to the transformed data:  <code class="reqn">Y * \sqrt a = \sqrt
a + b * \sqrt a</code>, where Y is the value of the indicator for the quantile, a
is the proportion of the total population in the quantile and b is the
relative rank. The SII is the gradient of the resulting fitted line, and
could be positive or negative according to the indicator polarity. Since the
relative ranks, by definition, range from 0 to 1, the SII is the difference
between the fitted value at  <code>x=1</code> and  <code>x=0</code>. The RII is the ratio
of the fitted value at  <code>x=1,Y1</code> and the fitted value at <code>x=0,Y0</code>.
which can be calculated as:  <code>RII = (Y0 + SII)/Y0</code>
</p>


<h3>Transformations</h3>

<p>The indicator type can be specified as 1 (rate), 2 (proportion) or 0 (other),
using the <code>value_type</code> parameter. This setting determines the data
transformations that will be applied in the following two parts of the
method.
</p>
<p>Use in conjunction with the <code>transform</code> parameter in calculation of the
SII: It is recommended that rates and proportions are transformed prior to
calculation of the SII by setting the <code>transform</code> parameter to TRUE for
these indicator types. This will perform a log transformation for rates, or
logit for proportions, and return outputs transformed back to the original
units of the indicator. These transformations are recommended to improve the
linearity between the indicator values and the quantile, which is an
assumption of the method. A user-provided standard error will not be accepted
when the <code>transform</code> parameter is set to TRUE as the confidence limits
are required for this transformation.
</p>
<p>Use in calculation of the standard error: Rates and proportions, and their
confidence limits, are transformed prior to calculation of the standard error
for each quantile. This is because it is assumed that the confidence interval
around the indicator value is non-symmetric for these indicator types. Note
that this transformation is not controlled by the <code>transform</code> parameter
and is applied based on the value of the <code>value_type</code> parameter only. A
user-provided standard error will not be accepted when the <code>transform</code>
parameter is set to TRUE as the confidence limits are required for this
transformation.
</p>


<h3>Warning</h3>

<p>The SII calculation assumes a linear relationship between indicator value and
quantile. Where this is not the case the transform option should be considered.
Small populations within quantiles can make the SII unstable. This
function does not include checks for linearity or stability; it is the user's
responsibility to ensure the input data is suitable for the SII calculation.
</p>


<h3>References</h3>

<p>(1) Low A &amp; Low A. Measuring the gap: quantifying and comparing local health inequalities.
Journal of Public Health; 2004;26:388-395. <br /> <br />
</p>


<h3>See Also</h3>

<p>Other PHEindicatormethods package functions: 
<code><a href="#topic+assign_funnel_significance">assign_funnel_significance</a>()</code>,
<code><a href="#topic+calculate_ISRate">calculate_ISRate</a>()</code>,
<code><a href="#topic+calculate_ISRatio">calculate_ISRatio</a>()</code>,
<code><a href="#topic+calculate_funnel_limits">calculate_funnel_limits</a>()</code>,
<code><a href="#topic+calculate_funnel_points">calculate_funnel_points</a>()</code>,
<code><a href="#topic+phe_dsr">phe_dsr</a>()</code>,
<code><a href="#topic+phe_life_expectancy">phe_life_expectancy</a>()</code>,
<code><a href="#topic+phe_mean">phe_mean</a>()</code>,
<code><a href="#topic+phe_proportion">phe_proportion</a>()</code>,
<code><a href="#topic+phe_quantile">phe_quantile</a>()</code>,
<code><a href="#topic+phe_rate">phe_rate</a>()</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>library(dplyr)

data &lt;- data.frame(area = c(rep("Area1", 10), rep("Area2", 10)),
                   decile = c(1:10, 1:10),
                   population = c(7291, 7997, 6105, 7666, 5790, 6934, 5918, 5974, 7147, 7534, 21675,
                                  20065, 19750, 24713, 20112, 19618, 22408, 19752, 18939, 19312),
                   value = c(75.9, 78.3, 83.8, 83.6, 80.5, 81.1, 81.7, 84.2, 80.6, 86.3, 70.5,
                              71.6, 72.5, 73.5, 73.1, 76.2, 78.7, 80.6, 80.9, 80),
                   lowerCL = c(72.7,75.3,80.9,80.2,77.1,78,79,81.4,75.8,83.2,
                               70.1,71.1,72,73.1, 72.7, 75.7, 78.2,80.1,80.4,79.5),
                   upperCL = c(79.1,81.4,86.8,87.1,83.8,84.2,84.4,86.9,85.4,
                                89.4,71,72.1,73.2,73.7,75.8,78.8,79.8,81.2,81.3,80.9),
                   StandardError = c(1.64,1.58,1.51,1.78,1.7,1.56,1.37,1.4,2.43,
                                     1.57,0.23,0.26,0.3,0.16,0.79,0.78,0.4,0.28,0.23,0.35)
                   )


# Run SII function on the two areas in the data
phe_sii(group_by(data, area),
        decile,
        population,
        value_type = 0, # default normal distribution
        value = value,
        lower_cl = lowerCL,
        upper_cl = upperCL,
        confidence = 0.95,
        rii = TRUE,
        type = "standard")

# Supplying the standard error instead of the indicator 95 percent confidence limits
# gives the same result
phe_sii(group_by(data, area),
        decile,
        population,
        value_type = 0,
        value = value,
        se = StandardError,
        confidence = 0.95,
        rii = TRUE,
        type = "standard")

# multiple confidence intervals, log transforming the data if they are rates
phe_sii(group_by(data, area),
        decile,
        population,
        value_type = 1,
        transform = TRUE,
        value = value,
        lower_cl = lowerCL,
        upper_cl = upperCL,
        confidence = c(0.95, 0.998),
        repetitions = 10000,
        rii = TRUE,
        type = "standard")

</code></pre>

<hr>
<h2 id='PHEindicatormethods'>PHEindicatormethods: A package for performing standard statistics for public
health indicators</h2><span id='topic+PHEindicatormethods'></span>

<h3>Description</h3>

<p>A package for performing standard statistics for public
health indicators.
</p>

<hr>
<h2 id='prevalence_data'>SII test datasets - Prevalence</h2><span id='topic+prevalence_data'></span>

<h3>Description</h3>

<p>A data table of example prevalence data by area and deprivation decile
</p>


<h3>Usage</h3>

<pre><code class='language-R'>data(prevalence_data)
</code></pre>


<h3>Format</h3>

<p>A data table
</p>


<h3>Examples</h3>

<pre><code class='language-R'>prevalence_data

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
