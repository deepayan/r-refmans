<!DOCTYPE html><html lang="en"><head><title>Help for package bootwar</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {bootwar}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#analyze_game'><p>Analyze Game Results and Determine Winner</p></a></li>
<li><a href='#bootwar'><p>Bootwar Shiny App</p></a></li>
<li><a href='#deck'><p>Deck of Cards</p></a></li>
<li><a href='#play_round'><p>Play a Round of the Card Game</p></a></li>
<li><a href='#process_seed'><p>Process Seed Input for the Bootwar Game</p></a></li>
<li><a href='#score_keeper'><p>Calculate Scores and Effect Size</p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Nonparametric Bootstrap Test with Pooled Resampling Card Game</td>
</tr>
<tr>
<td>Version:</td>
<td>0.2.1</td>
</tr>
<tr>
<td>Description:</td>
<td>The card game War is simple in its rules but can be lengthy. In
    another domain, the nonparametric bootstrap test with pooled resampling
    (nbpr) methods, as outlined in Dwivedi, Mallawaarachchi, and Alvarado (2017) &lt;<a href="https://doi.org/10.1002%2Fsim.7263">doi:10.1002/sim.7263</a>&gt;,
    is optimal for comparing paired or unpaired means in non-normal data,
    especially for small sample size studies. However, many researchers are
    unfamiliar with these methods. The 'bootwar' package bridges this gap by
    enabling users to grasp the concepts of nbpr via Boot War, a variation of the
    card game War designed for small samples. The package provides functions like
    score_keeper() and play_round() to streamline gameplay and scoring. Once a
    predetermined number of rounds concludes, users can employ the analyze_game()
    function to derive game results. This function leverages the 'npboottprm'
    package's nonparboot() to report nbpr results and, for comparative analysis,
    also reports results from the 'stats' package's t.test() function. Additionally,
    'bootwar' features an interactive 'shiny' web application, bootwar(). This
    offers a user-centric interface to experience Boot War, enhancing understanding
    of nbpr methods across various distributions, sample sizes, number of bootstrap
    resamples, and confidence intervals.</td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.2.3</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/mightymetrika/bootwar">https://github.com/mightymetrika/bootwar</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/mightymetrika/bootwar/issues">https://github.com/mightymetrika/bootwar/issues</a></td>
</tr>
<tr>
<td>Imports:</td>
<td>ggplot2, mmcards, npboottprm, shiny, shinyjs, shinythemes</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 2.10)</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>Suggests:</td>
<td>knitr, rmarkdown, testthat (&ge; 3.0.0)</td>
</tr>
<tr>
<td>Config/testthat/edition:</td>
<td>3</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>no</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2023-10-01 16:13:58 UTC; Administrator</td>
</tr>
<tr>
<td>Author:</td>
<td>Mackson Ncube [aut, cre],
  mightymetrika, LLC [cph, fnd]</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Mackson Ncube &lt;macksonncube.stats@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2023-10-01 16:30:10 UTC</td>
</tr>
</table>
<hr>
<h2 id='analyze_game'>Analyze Game Results and Determine Winner</h2><span id='topic+analyze_game'></span>

<h3>Description</h3>

<p>This function analyzes the results of the game using both nonparametric
bootstrap with pooled resampling and classical t-tests. It then determines
the winner based on the bootstrap results and effect size.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>analyze_game(plyr_vv, comp_vv, mode = "t", conf.level = 0.95, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="analyze_game_+3A_plyr_vv">plyr_vv</code></td>
<td>
<p>A numeric vector storing the values of the cards dealt to the
player.</p>
</td></tr>
<tr><td><code id="analyze_game_+3A_comp_vv">comp_vv</code></td>
<td>
<p>A numeric vector storing the values of the cards dealt to the
computer.</p>
</td></tr>
<tr><td><code id="analyze_game_+3A_mode">mode</code></td>
<td>
<p>A character string indicating the type of test. Valid options are
&quot;t&quot; for independent t-test
and &quot;pt&quot; for paired t-test. Default is &quot;t&quot;.</p>
</td></tr>
<tr><td><code id="analyze_game_+3A_conf.level">conf.level</code></td>
<td>
<p>A confidence level for <code>npboottprm::nonparboot</code>,
<code>stats::t.test</code>. The confidence level is also used to set the alpha
level to alpha = 1 - conf.level</p>
</td></tr>
<tr><td><code id="analyze_game_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the <code>npboottprm::nonparboot</code>
function.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li> <p><code>bootstrap_results</code>: A list containing results from the bootstrap test.
</p>
</li>
<li> <p><code>classical_results</code>: A list containing results from the classical t-test.
</p>
</li>
<li> <p><code>winner</code>: A character string indicating the winner (&quot;Player Wins&quot;, &quot;Computer Wins&quot;, or &quot;Draw&quot;).
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Analyze a sample game
plyr_values &lt;- c(4, 3, 2, 1)
comp_values &lt;- c(1, 2, 3, 4)
game_results &lt;- analyze_game(plyr_values, comp_values, nboot = 1000,
                             mode = "t", seed = 150)

</code></pre>

<hr>
<h2 id='bootwar'>Bootwar Shiny App</h2><span id='topic+bootwar'></span>

<h3>Description</h3>

<p>Launches a Shiny application for the Bootwar card game.
The app allows users to play a card game where they can analyze the game
results using nonparametric bootstrap test with pooled resampling methods.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>bootwar()
</code></pre>


<h3>Details</h3>

<p>The Bootwar card game is a bootstrap variation of the card game War. The
Bootwar application has options to select different modes ('t' for
independent t-test and 'pt' for paired t-test) and decks.
Players can use a standard 52 card deck and they can also input a custom
anonymous function to generate a deck. The app will let users deal cards,
play the game, and then score and analyze results using nonparametric
bootstrap test with pooled resampling methods. The game is designed to help
users gain greater intuition on nonparametric bootstrap test with pooled
resampling methods; as such, players are encouraged to experiment with
different confidence levels, number of rounds, number of bootstrap resamples,
and custom decks.
</p>


<h3>Value</h3>

<p>A Shiny application object. Running this function will launch the Shiny app
in the user's default web browser.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>if(interactive()){
  bootwar()
}

</code></pre>

<hr>
<h2 id='deck'>Deck of Cards</h2><span id='topic+deck'></span>

<h3>Description</h3>

<p>A 52 card deck of playing cards with suit ranking.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>deck
</code></pre>


<h3>Format</h3>



<h4><code>deck</code></h4>

<p>A data frame with 52 rows and 4 columns:
</p>

<dl>
<dt>rank</dt><dd><p>A factor representing card rank taking values 2 - A</p>
</dd>
<dt>suit</dt><dd><p>A card suit with ranked order Club (C), Diamond (D), Heart (H), and Spade (S)</p>
</dd>
<dt>card</dt><dd><p>A card</p>
</dd>
<dt>value</dt><dd><p>A card value ranging from 2.00 (2C) to 14.75 (AS)</p>
</dd>
</dl>




<h3>Source</h3>

<p>Standard Deck of Playing Cards
</p>

<hr>
<h2 id='play_round'>Play a Round of the Card Game</h2><span id='topic+play_round'></span>

<h3>Description</h3>

<p>This function simulates a single round of the card game, where both the
computer and the player are dealt a card. The function returns the updated
state of the game after the round.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>play_round(
  cdeck,
  plyr_cv,
  plyr_vv,
  plyr_ic = NULL,
  comp_cv,
  comp_vv,
  comp_ic = NULL
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="play_round_+3A_cdeck">cdeck</code></td>
<td>
<p>A dataframe representing the current deck of cards.</p>
</td></tr>
<tr><td><code id="play_round_+3A_plyr_cv">plyr_cv</code></td>
<td>
<p>A character vector storing the cards dealt to the player so far.</p>
</td></tr>
<tr><td><code id="play_round_+3A_plyr_vv">plyr_vv</code></td>
<td>
<p>A numeric vector storing the values of the cards dealt to the
player so far.</p>
</td></tr>
<tr><td><code id="play_round_+3A_plyr_ic">plyr_ic</code></td>
<td>
<p>A character vector storing the image cards dealt to the player. Default is NULL.</p>
</td></tr>
<tr><td><code id="play_round_+3A_comp_cv">comp_cv</code></td>
<td>
<p>A character vector storing the cards dealt to the computer so
far.</p>
</td></tr>
<tr><td><code id="play_round_+3A_comp_vv">comp_vv</code></td>
<td>
<p>A numeric vector storing the values of the cards dealt to the
computer so far.</p>
</td></tr>
<tr><td><code id="play_round_+3A_comp_ic">comp_ic</code></td>
<td>
<p>A character vector storing the image cards dealt to the computer. Default is NULL.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li> <p><code>updated_deck</code>: A dataframe representing the updated deck of cards after the round.
</p>
</li>
<li> <p><code>plyr_cv</code>: Updated character vector of cards dealt to the player.
</p>
</li>
<li> <p><code>plyr_vv</code>: Updated numeric vector of values of cards dealt to the player.
</p>
</li>
<li> <p><code>plyr_ic</code>: Updated character vector of image cards dealt to the player.
</p>
</li>
<li> <p><code>comp_cv</code>: Updated character vector of cards dealt to the computer.
</p>
</li>
<li> <p><code>comp_vv</code>: Updated numeric vector of values of cards dealt to the computer.
</p>
</li>
<li> <p><code>comp_ic</code>: Updated character vector of image cards dealt to the computer.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Simulate a round of the game with a sample deck
deck &lt;- mmcards::shuffle_deck()
plyr_cards &lt;- character(0)
plyr_values &lt;- numeric(0)
comp_cards &lt;- character(0)
comp_values &lt;- numeric(0)
round_result &lt;- play_round(deck, plyr_cv = plyr_cards, plyr_vv = plyr_values,
                           comp_cv = comp_cards, comp_vv = comp_values)

</code></pre>

<hr>
<h2 id='process_seed'>Process Seed Input for the Bootwar Game</h2><span id='topic+process_seed'></span>

<h3>Description</h3>

<p>This function processes the seed input for the Bootwar game.
It converts the seed to an integer if it's not NA. If the seed is NA, it
returns NULL.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>process_seed(seed_input)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="process_seed_+3A_seed_input">seed_input</code></td>
<td>
<p>Numeric or NA. The input seed value from the Shiny app.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Integer or NULL. If the input is not NA, it returns the integer value
of the seed. Otherwise, it returns NULL.
</p>

<hr>
<h2 id='score_keeper'>Calculate Scores and Effect Size</h2><span id='topic+score_keeper'></span>

<h3>Description</h3>

<p>This function computes the sum and mean of the player's and computer's values
and calculates the effect size based on the given mode (<code>t</code> or <code>pt</code>).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>score_keeper(player_values, comp_values, mode)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="score_keeper_+3A_player_values">player_values</code></td>
<td>
<p>A numeric vector representing the values of the player's
cards.</p>
</td></tr>
<tr><td><code id="score_keeper_+3A_comp_values">comp_values</code></td>
<td>
<p>A numeric vector representing the values of the computer's
cards.</p>
</td></tr>
<tr><td><code id="score_keeper_+3A_mode">mode</code></td>
<td>
<p>A character string representing the mode of the game, either 't'
for independent t-test or 'pt' for paired t-test.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A list containing:
</p>

<ul>
<li> <p><code>player_sum</code>: Sum of player's values.
</p>
</li>
<li> <p><code>player_mean</code>: Mean of player's values.
</p>
</li>
<li> <p><code>comp_sum</code>: Sum of computer's values.
</p>
</li>
<li> <p><code>comp_mean</code>: Mean of computer's values.
</p>
</li>
<li> <p><code>effect_size</code>: Calculated effect size based on the given mode.
</p>
</li></ul>



<h3>Examples</h3>

<pre><code class='language-R'># Calculate scores for a simple game
player_vals &lt;- c(2.5, 3.0, 4.5)
comp_vals &lt;- c(3.5, 2.0, 4.0)
scores &lt;- score_keeper(player_vals, comp_vals, mode = "t")

</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
