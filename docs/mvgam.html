<!DOCTYPE html><html lang="en"><head><title>Help for package mvgam</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
<link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism.min.css" rel="stylesheet" />
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.css">
<script type="text/javascript">
const macros = { "\\R": "\\textsf{R}", "\\code": "\\texttt"};
function processMathHTML() {
    var l = document.getElementsByClassName('reqn');
    for (let e of l) { katex.render(e.textContent, e, { throwOnError: false, macros }); }
    return;
}</script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.3/dist/katex.min.js"
    onload="processMathHTML();"></script>
<link rel="stylesheet" type="text/css" href="R-nav.css" />
</head><body><div class="container"><nav class="package" aria-label="Topic Navigation">
<div class="dropdown-menu">
<h1>Package {mvgam}</h1>
<h2>Contents</h2>
<ul class="menu">
<li><a href='#mvgam-package'><p>mvgam: Multivariate (Dynamic) Generalized Additive Models</p></a></li>
<li><a href='#+25+26gt+3B+25'><p>Pipe operator</p></a></li>
<li><a href='#add_residuals.mvgam'><p>Calculate randomized quantile residuals for <span class="pkg">mvgam</span> objects</p></a></li>
<li><a href='#all_neon_tick_data'><p>NEON Amblyomma and Ixodes tick abundance survey data</p></a></li>
<li><a href='#augment.mvgam'><p>Augment an <span class="pkg">mvgam</span> object's data</p></a></li>
<li><a href='#code'><p>Stan code and data objects for <span class="pkg">mvgam</span> models</p></a></li>
<li><a href='#conditional_effects.mvgam'><p>Display conditional effects of predictors for <span class="pkg">mvgam</span> models</p></a></li>
<li><a href='#dynamic'><p>Defining dynamic coefficients in <span class="pkg">mvgam</span> formulae</p></a></li>
<li><a href='#ensemble.mvgam_forecast'><p>Combine forecasts from <span class="pkg">mvgam</span> models into evenly weighted ensembles</p></a></li>
<li><a href='#evaluate_mvgams'><p>Evaluate forecasts from fitted <span class="pkg">mvgam</span> objects</p></a></li>
<li><a href='#fevd.mvgam'><p>Calculate latent VAR forecast error variance decompositions</p></a></li>
<li><a href='#fitted.mvgam'><p>Expected values of the posterior predictive distribution for <span class="pkg">mvgam</span> objects</p></a></li>
<li><a href='#forecast.mvgam'><p>Extract or compute hindcasts and forecasts for a fitted <code>mvgam</code> object</p></a></li>
<li><a href='#formula.mvgam'><p>Extract formulae from <span class="pkg">mvgam</span> objects</p></a></li>
<li><a href='#get_mvgam_priors'><p>Extract information on default prior distributions for an <span class="pkg">mvgam</span> model</p></a></li>
<li><a href='#GP'><p>Specify dynamic Gaussian process trends in <span class="pkg">mvgam</span> models</p></a></li>
<li><a href='#gratia_mvgam_enhancements'><p>Enhance post-processing of <span class="pkg">mvgam</span> models using <span class="pkg">gratia</span> functionality</p></a></li>
<li><a href='#hindcast.mvgam'><p>Extract hindcasts for a fitted <code>mvgam</code> object</p></a></li>
<li><a href='#how_to_cite.mvgam'><p>Generate a methods description for <span class="pkg">mvgam</span> models</p></a></li>
<li><a href='#index-mvgam'><p>Index <code>mvgam</code> objects</p></a></li>
<li><a href='#irf.mvgam'><p>Calculate latent VAR impulse response functions</p></a></li>
<li><a href='#jsdgam'><p>Fit Joint Species Distribution Models in <span class="pkg">mvgam</span></p></a></li>
<li><a href='#lfo_cv.mvgam'><p>Approximate leave-future-out cross-validation of fitted <span class="pkg">mvgam</span> objects</p></a></li>
<li><a href='#logLik.mvgam'><p>Compute pointwise Log-Likelihoods from fitted <span class="pkg">mvgam</span> objects</p></a></li>
<li><a href='#loo.mvgam'><p>LOO information criteria for <span class="pkg">mvgam</span> models</p></a></li>
<li><a href='#lv_correlations'><p>Calculate trend correlations based on latent factor loadings for <span class="pkg">mvgam</span> models</p></a></li>
<li><a href='#mcmc_plot.mvgam'><p>MCMC plots of <span class="pkg">mvgam</span> parameters, as implemented in <span class="pkg">bayesplot</span></p></a></li>
<li><a href='#model.frame.mvgam'><p>Extract model.frame from a fitted <span class="pkg">mvgam</span> object</p></a></li>
<li><a href='#monotonic'><p>Monotonic splines in <span class="pkg">mvgam</span> models</p></a></li>
<li><a href='#mvgam'><p>Fit a Bayesian dynamic GAM to a univariate or multivariate set of time series</p></a></li>
<li><a href='#mvgam_diagnostics'><p>Extract diagnostic quantities of <span class="pkg">mvgam</span> models</p></a></li>
<li><a href='#mvgam_draws'><p>Extract posterior draws from fitted <span class="pkg">mvgam</span> objects</p></a></li>
<li><a href='#mvgam_families'><p>Supported <span class="pkg">mvgam</span> families</p></a></li>
<li><a href='#mvgam_fevd-class'><p><code>mvgam_fevd</code> object description</p></a></li>
<li><a href='#mvgam_forecast-class'><p><code>mvgam_forecast</code> object description</p></a></li>
<li><a href='#mvgam_formulae'><p>Details of formula specifications in <span class="pkg">mvgam</span> models</p></a></li>
<li><a href='#mvgam_irf-class'><p><code>mvgam_irf</code> object description</p></a></li>
<li><a href='#mvgam_marginaleffects'><p>Helper functions for <span class="pkg">marginaleffects</span> calculations in <span class="pkg">mvgam</span> models</p></a></li>
<li><a href='#mvgam_trends'><p>Supported latent trend models in <span class="pkg">mvgam</span></p></a></li>
<li><a href='#mvgam-class'><p>Fitted <code>mvgam</code> object description</p></a></li>
<li><a href='#pairs.mvgam'><p>Create a matrix of output plots from a <code>mvgam</code> object</p></a></li>
<li><a href='#plot_mvgam_factors'><p>Latent factor summaries for a fitted <span class="pkg">mvgam</span> object</p></a></li>
<li><a href='#plot_mvgam_forecasts'><p>Plot posterior forecast predictions from <span class="pkg">mvgam</span> models</p></a></li>
<li><a href='#plot_mvgam_pterms'><p>Plot parametric term partial effects for <span class="pkg">mvgam</span> models</p></a></li>
<li><a href='#plot_mvgam_randomeffects'><p>Plot random effect terms from <span class="pkg">mvgam</span> models</p></a></li>
<li><a href='#plot_mvgam_resids'><p>Residual diagnostics for a fitted <span class="pkg">mvgam</span> object</p></a></li>
<li><a href='#plot_mvgam_series'><p>Plot observed time series used for <span class="pkg">mvgam</span> modelling</p></a></li>
<li><a href='#plot_mvgam_smooth'><p>Plot smooth terms from <span class="pkg">mvgam</span> models</p></a></li>
<li><a href='#plot_mvgam_trend'><p>Plot latent trend predictions from <span class="pkg">mvgam</span> models</p></a></li>
<li><a href='#plot_mvgam_uncertainty'><p>Plot forecast uncertainty contributions from <span class="pkg">mvgam</span> models</p></a></li>
<li><a href='#plot.mvgam'><p>Default plots for <span class="pkg">mvgam</span> models</p></a></li>
<li><a href='#plot.mvgam_fevd'><p>Plot forecast error variance decompositions from an <code>mvgam_fevd</code> object</p></a></li>
<li><a href='#plot.mvgam_irf'><p>Plot impulse responses from an <code>mvgam_irf</code> object</p></a></li>
<li><a href='#plot.mvgam_lfo'><p>Plot Pareto-k and ELPD values from a <code>mvgam_lfo</code> object</p></a></li>
<li><a href='#plot.mvgam_residcor'><p>Plot residual correlations based on latent factors from a fitted jsdgam</p></a></li>
<li><a href='#portal_data'><p>Portal Project rodent capture survey data</p></a></li>
<li><a href='#posterior_epred.mvgam'><p>Draws from the expected value of the posterior predictive distribution for <span class="pkg">mvgam</span> objects</p></a></li>
<li><a href='#posterior_linpred.mvgam'><p>Posterior draws of the linear predictor for <span class="pkg">mvgam</span> objects</p></a></li>
<li><a href='#posterior_predict.mvgam'><p>Draws from the posterior predictive distribution for <span class="pkg">mvgam</span> objects</p></a></li>
<li><a href='#pp_check.mvgam'><p>Posterior Predictive Checks for <code>mvgam</code> models</p></a></li>
<li><a href='#ppc.mvgam'><p>Plot conditional posterior predictive checks from <span class="pkg">mvgam</span> models</p></a></li>
<li><a href='#predict.mvgam'><p>Predict from a fitted <span class="pkg">mvgam</span> model</p></a></li>
<li><a href='#print.mvgam'><p>Summary for a fitted <span class="pkg">mvgam</span> object</p></a></li>
<li><a href='#PW'><p>Specify piecewise linear or logistic trends in <span class="pkg">mvgam</span> models</p></a></li>
<li><a href='#reexports'><p>Objects exported from other packages</p></a></li>
<li><a href='#residual_cor.jsdgam'><p>Extract residual correlations based on latent factors from a fitted jsdgam</p></a></li>
<li><a href='#residuals.mvgam'><p>Posterior draws of residuals from <span class="pkg">mvgam</span> models</p></a></li>
<li><a href='#RW'><p>Specify autoregressive dynamic processes in <span class="pkg">mvgam</span></p></a></li>
<li><a href='#score.mvgam_forecast'><p>Compute probabilistic forecast scores for <span class="pkg">mvgam</span> models</p></a></li>
<li><a href='#series_to_mvgam'><p>Convert timeseries object to format necessary for <span class="pkg">mvgam</span> models</p></a></li>
<li><a href='#sim_mvgam'><p>Simulate a set of time series for modelling in <span class="pkg">mvgam</span></p></a></li>
<li><a href='#stability.mvgam'><p>Calculate measures of latent VAR community stability</p></a></li>
<li><a href='#summary.mvgam'><p>Summary for a fitted <span class="pkg">mvgam</span> models</p></a></li>
<li><a href='#summary.mvgam_fevd'><p>Posterior summary of forecast error variance decompositions</p></a></li>
<li><a href='#summary.mvgam_irf'><p>Posterior summary of impulse responses</p></a></li>
<li><a href='#update.mvgam'><p>Update an existing <span class="pkg">mvgam</span> model object</p></a></li>
<li><a href='#ZMVN'><p>Specify correlated residual processes in <span class="pkg">mvgam</span></p></a></li>
</ul>
</div>
<hr>
</nav>
<main>
<table role='presentation'>
<tr>
<td>Title:</td>
<td>Multivariate (Dynamic) Generalized Additive Models</td>
</tr>
<tr>
<td>Version:</td>
<td>1.1.51</td>
</tr>
<tr>
<td>Date:</td>
<td>2025-03-14</td>
</tr>
<tr>
<td>Description:</td>
<td>Fit Bayesian Dynamic Generalized Additive Models to multivariate observations. Users can build nonlinear State-Space models that can incorporate semiparametric effects in observation and process components, using a wide range of observation families. Estimation is performed using Markov Chain Monte Carlo with Hamiltonian Monte Carlo in the software 'Stan'. References: Clark &amp; Wells (2023) &lt;<a href="https://doi.org/10.1111%2F2041-210X.13974">doi:10.1111/2041-210X.13974</a>&gt;.</td>
</tr>
<tr>
<td>URL:</td>
<td><a href="https://github.com/nicholasjclark/mvgam">https://github.com/nicholasjclark/mvgam</a>,
<a href="https://nicholasjclark.github.io/mvgam/">https://nicholasjclark.github.io/mvgam/</a></td>
</tr>
<tr>
<td>BugReports:</td>
<td><a href="https://github.com/nicholasjclark/mvgam/issues">https://github.com/nicholasjclark/mvgam/issues</a></td>
</tr>
<tr>
<td>License:</td>
<td><a href="https://opensource.org/licenses/mit-license.php">MIT</a> + file LICENSE</td>
</tr>
<tr>
<td>Depends:</td>
<td>R (&ge; 3.6.0)</td>
</tr>
<tr>
<td>Imports:</td>
<td>brms (&ge; 2.21.0), methods, mgcv (&ge; 1.8-13), insight (&ge;
0.19.1), marginaleffects (&ge; 0.16.0), Rcpp (&ge; 0.12.0), rstan
(&ge; 2.29.0), posterior (&ge; 1.0.0), loo (&ge; 2.3.1), rstantools
(&ge; 2.1.1), bayesplot (&ge; 1.5.0), ggplot2 (&ge; 2.0.0), mvnfast,
purrr, dplyr, magrittr, rlang, generics, tibble (&ge; 3.0.0),
patchwork (&ge; 1.2.0)</td>
</tr>
<tr>
<td>Encoding:</td>
<td>UTF-8</td>
</tr>
<tr>
<td>LazyData:</td>
<td>true</td>
</tr>
<tr>
<td>RoxygenNote:</td>
<td>7.3.2</td>
</tr>
<tr>
<td>Suggests:</td>
<td>scoringRules, matrixStats, cmdstanr (&ge; 0.5.0), tweedie,
splines2, extraDistr, corpcor, wrswoR, xts, lubridate, knitr,
collapse, rmarkdown, rjags, coda, runjags, usethis, testthat</td>
</tr>
<tr>
<td>Enhances:</td>
<td>gratia (&ge; 0.9.0), tidyr</td>
</tr>
<tr>
<td>Additional_repositories:</td>
<td><a href="https://mc-stan.org/r-packages/">https://mc-stan.org/r-packages/</a></td>
</tr>
<tr>
<td>LinkingTo:</td>
<td>Rcpp, RcppArmadillo</td>
</tr>
<tr>
<td>VignetteBuilder:</td>
<td>knitr</td>
</tr>
<tr>
<td>NeedsCompilation:</td>
<td>yes</td>
</tr>
<tr>
<td>Packaged:</td>
<td>2025-03-14 05:44:31 UTC; uqnclar2</td>
</tr>
<tr>
<td>Author:</td>
<td>Nicholas J Clark <a href="https://orcid.org/0000-0001-7131-3301"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a>
    [aut, cre],
  Sarah Heaps <a href="https://orcid.org/0000-0002-5543-037X"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]
    (VARMA parameterisations),
  Scott Pease <a href="https://orcid.org/0009-0006-8977-9285"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb]
    (broom enhancements),
  Matthijs Hollanders
    <a href="https://orcid.org/0000-0003-0796-1018"><img alt="ORCID iD"  src="https://cloud.R-project.org/web/orcid.svg" style="width:16px; height:16px; margin-left:4px; margin-right:4px; vertical-align:middle" /></a> [ctb] (ggplot
    visualizations)</td>
</tr>
<tr>
<td>Maintainer:</td>
<td>Nicholas J Clark &lt;nicholas.j.clark1214@gmail.com&gt;</td>
</tr>
<tr>
<td>Repository:</td>
<td>CRAN</td>
</tr>
<tr>
<td>Date/Publication:</td>
<td>2025-03-14 08:40:02 UTC</td>
</tr>
</table>
<hr>
<h2 id='mvgam-package'>mvgam: Multivariate (Dynamic) Generalized Additive Models</h2><span id='topic+mvgam-package'></span>

<h3>Description</h3>

<p><img src="../help/figures/logo.png" style='float: right' alt='logo' width='120' />
</p>
<p>Fit Bayesian Dynamic Generalized Additive Models to multivariate observations. Users can build nonlinear State-Space models that can incorporate semiparametric effects in observation and process components, using a wide range of observation families. Estimation is performed using Markov Chain Monte Carlo with Hamiltonian Monte Carlo in the software 'Stan'. References: Clark &amp; Wells (2023) <a href="https://doi.org/10.1111/2041-210X.13974">doi:10.1111/2041-210X.13974</a>.
</p>


<h3>Author(s)</h3>

<p><strong>Maintainer</strong>: Nicholas J Clark <a href="mailto:nicholas.j.clark1214@gmail.com">nicholas.j.clark1214@gmail.com</a> (<a href="https://orcid.org/0000-0001-7131-3301">ORCID</a>)
</p>
<p>Other contributors:
</p>

<ul>
<li><p> Sarah Heaps (<a href="https://orcid.org/0000-0002-5543-037X">ORCID</a>) (VARMA parameterisations) [contributor]
</p>
</li>
<li><p> Scott Pease (<a href="https://orcid.org/0009-0006-8977-9285">ORCID</a>) (broom enhancements) [contributor]
</p>
</li>
<li><p> Matthijs Hollanders (<a href="https://orcid.org/0000-0003-0796-1018">ORCID</a>) (ggplot visualizations) [contributor]
</p>
</li></ul>



<h3>See Also</h3>

<p>Useful links:
</p>

<ul>
<li> <p><a href="https://github.com/nicholasjclark/mvgam">https://github.com/nicholasjclark/mvgam</a>
</p>
</li>
<li> <p><a href="https://nicholasjclark.github.io/mvgam/">https://nicholasjclark.github.io/mvgam/</a>
</p>
</li>
<li><p> Report bugs at <a href="https://github.com/nicholasjclark/mvgam/issues">https://github.com/nicholasjclark/mvgam/issues</a>
</p>
</li></ul>


<hr>
<h2 id='+25+26gt+3B+25'>Pipe operator</h2><span id='topic++25+3E+25'></span>

<h3>Description</h3>

<p>See <code>magrittr::<a href="magrittr.html#topic+pipe">%&gt;%</a></code> for details.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lhs %&gt;% rhs
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_lhs">lhs</code></td>
<td>
<p>A value or the magrittr placeholder.</p>
</td></tr>
<tr><td><code id="+2B25+2B26gt+2B3B+2B25_+3A_rhs">rhs</code></td>
<td>
<p>A function call using the magrittr semantics.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>The result of calling <code>rhs(lhs)</code>.
</p>

<hr>
<h2 id='add_residuals.mvgam'>Calculate randomized quantile residuals for <span class="pkg">mvgam</span> objects</h2><span id='topic+add_residuals.mvgam'></span><span id='topic+add_residuals'></span>

<h3>Description</h3>

<p>Calculate randomized quantile residuals for <span class="pkg">mvgam</span> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>add_residuals(object, ...)

## S3 method for class 'mvgam'
add_residuals(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="add_residuals.mvgam_+3A_object">object</code></td>
<td>
<p><code>list</code> object of class <code>mvgam</code>. See <code><a href="#topic+mvgam">mvgam()</a></code></p>
</td></tr>
<tr><td><code id="add_residuals.mvgam_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For each series, randomized quantile (i.e. Dunn-Smyth) residuals are calculated for inspecting model diagnostics
If the fitted model is appropriate then Dunn-Smyth residuals will be standard normal in distribution and no
autocorrelation will be evident. When a particular observation is missing, the residual is calculated by comparing independent
draws from the model's posterior distribution
</p>


<h3>Value</h3>

<p>A list object of class <code>mvgam</code> with residuals included in the <code>'resids'</code> slot
</p>

<hr>
<h2 id='all_neon_tick_data'>NEON Amblyomma and Ixodes tick abundance survey data</h2><span id='topic+all_neon_tick_data'></span>

<h3>Description</h3>

<p>A dataset containing timeseries of Amblyomma americanum and Ixodes scapularis nymph abundances at NEON sites
</p>


<h3>Usage</h3>

<pre><code class='language-R'>all_neon_tick_data
</code></pre>


<h3>Format</h3>

<p>A tibble/dataframe containing covariate information alongside the main fields of:
</p>

<dl>
<dt>Year</dt><dd><p>Year of sampling</p>
</dd>
<dt>epiWeek</dt><dd><p>Epidemiological week of sampling</p>
</dd>
<dt>plot_ID</dt><dd><p>NEON plot ID for survey location</p>
</dd>
<dt>siteID</dt><dd><p>NEON site ID for survey location</p>
</dd>
<dt>amblyomma_americanum</dt><dd><p>Counts of A. americanum nymphs</p>
</dd>
<dt>ixodes_scapularis</dt><dd><p>Counts of I. scapularis nymphs</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://www.neonscience.org/data">https://www.neonscience.org/data</a>
</p>

<hr>
<h2 id='augment.mvgam'>Augment an <span class="pkg">mvgam</span> object's data</h2><span id='topic+augment.mvgam'></span>

<h3>Description</h3>

<p>Add fits and residuals to the data, implementing the generic <code>augment</code> from
the package <span class="pkg">broom</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
augment(x, robust = FALSE, probs = c(0.025, 0.975), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="augment.mvgam_+3A_x">x</code></td>
<td>
<p>An object of class <code>mvgam</code>.</p>
</td></tr>
<tr><td><code id="augment.mvgam_+3A_robust">robust</code></td>
<td>
<p>If <code>FALSE</code> (the default) the mean is used as the measure of
central tendency and the standard deviation as the measure of variability.
If <code>TRUE</code>, the median and the median absolute deviation (MAD)
are applied instead.</p>
</td></tr>
<tr><td><code id="augment.mvgam_+3A_probs">probs</code></td>
<td>
<p>The percentiles to be computed by the quantile function.</p>
</td></tr>
<tr><td><code id="augment.mvgam_+3A_...">...</code></td>
<td>
<p>Unused, included for generic consistency only.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A <code>list</code> is returned if <code>class(x$obs_data) == 'list'</code>, otherwise a <code>tibble</code> is
returned, but the contents of either object is the same.
</p>
<p>The arguments <code>robust</code> and <code>probs</code> are applied to both the fit and
residuals calls (see <code><a href="#topic+fitted.mvgam">fitted.mvgam()</a></code> and <code><a href="#topic+residuals.mvgam">residuals.mvgam()</a></code> for details).
</p>


<h3>Value</h3>

<p>A <code>list</code> or <code>tibble</code> (see details) combining:
</p>

<ul>
<li><p> The data supplied to <code>mvgam()</code>.
</p>
</li>
<li><p> The outcome variable, named as <code>.observed</code>.
</p>
</li>
<li><p> The fitted backcasts, along with their variability and credible bounds.
</p>
</li>
<li><p> The residuals, along with their variability and credible bounds.
</p>
</li></ul>



<h3>See Also</h3>

<p><code><a href="#topic+residuals.mvgam">residuals.mvgam</a></code>, <code><a href="#topic+fitted.mvgam">fitted.mvgam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
set.seed(0)
dat &lt;- sim_mvgam(T = 80,
                 n_series = 3,
                 mu = 2,
                 trend_model = AR(p = 1),
                 prop_missing = 0.1,
                 prop_trend = 0.6)

mod1 &lt;- mvgam(formula = y ~ s(season, bs = 'cc', k = 6),
              data = dat$data_train,
              trend_model = AR(),
              family = poisson(),
              noncentred = TRUE,
              chains = 2,
              silent = 2)

augment(mod1, robust = TRUE, probs = c(0.25, 0.75))


</code></pre>

<hr>
<h2 id='code'>Stan code and data objects for <span class="pkg">mvgam</span> models</h2><span id='topic+code'></span><span id='topic+stancode.mvgam_prefit'></span><span id='topic+stancode.mvgam'></span><span id='topic+standata.mvgam_prefit'></span>

<h3>Description</h3>

<p>Generate Stan code and data objects for <span class="pkg">mvgam</span> models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>code(object)

## S3 method for class 'mvgam_prefit'
stancode(object, ...)

## S3 method for class 'mvgam'
stancode(object, ...)

## S3 method for class 'mvgam_prefit'
standata(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="code_+3A_object">object</code></td>
<td>
<p>An object of class <code>mvgam</code> or <code>mvgam_prefit</code>,
returned from a call to <code>mvgam</code></p>
</td></tr>
<tr><td><code id="code_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Either a character string containing the fully commented <span class="pkg">Stan</span> code
to fit a <span class="pkg">mvgam</span> model or a named list containing the data objects needed
to fit the model in Stan.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
simdat &lt;- sim_mvgam()
mod &lt;- mvgam(y ~ s(season) +
               s(time, by = series),
             family = poisson(),
             data = simdat$data_train,
             run_model = FALSE)

# View Stan model code
stancode(mod)

# View Stan model data
sdata &lt;- standata(mod)
str(sdata)


</code></pre>

<hr>
<h2 id='conditional_effects.mvgam'>Display conditional effects of predictors for <span class="pkg">mvgam</span> models</h2><span id='topic+conditional_effects.mvgam'></span><span id='topic+plot.mvgam_conditional_effects'></span><span id='topic+print.mvgam_conditional_effects'></span>

<h3>Description</h3>

<p>Display conditional effects of one or more numeric and/or categorical
predictors in models of class <code>mvgam</code> and <code>jsdgam</code>, including two-way interaction effects.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
conditional_effects(
  x,
  effects = NULL,
  type = "response",
  points = FALSE,
  rug = FALSE,
  ...
)

## S3 method for class 'mvgam_conditional_effects'
plot(x, plot = TRUE, ask = FALSE, ...)

## S3 method for class 'mvgam_conditional_effects'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="conditional_effects.mvgam_+3A_x">x</code></td>
<td>
<p>Object of class <code>mvgam</code>, <code>jsdgam</code> or <code>mvgam_conditional_effects</code></p>
</td></tr>
<tr><td><code id="conditional_effects.mvgam_+3A_effects">effects</code></td>
<td>
<p>An optional character vector naming effects (main effects or
interactions) for which to compute conditional plots. Interactions are
specified by a <code>:</code> between variable names. If <code>NULL</code> (the
default), plots are generated for all main effects and two-way interactions
estimated in the model. When specifying <code>effects</code> manually, <em>all</em>
two-way interactions (including grouping variables) may be plotted
even if not originally modeled.</p>
</td></tr>
<tr><td><code id="conditional_effects.mvgam_+3A_type">type</code></td>
<td>
<p><code>character</code> specifying the scale of predictions.
When this has the value <code>link</code> (default) the linear predictor is calculated on the link scale.
If <code>expected</code> is used, predictions reflect the expectation of the response (the mean)
but ignore uncertainty in the observation process. When <code>response</code> is used,
the predictions take uncertainty in the observation process into account to return
predictions on the outcome scale. Two special cases are also allowed:
type <code>latent_N</code> will return the estimated latent abundances from an N-mixture distribution,
while type <code>detection</code> will return the estimated detection probability from an N-mixture distribution</p>
</td></tr>
<tr><td><code id="conditional_effects.mvgam_+3A_points">points</code></td>
<td>
<p><code>Logical</code>. Indicates if the original data points should be added,
but only if <code>type == 'response'</code>. Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="conditional_effects.mvgam_+3A_rug">rug</code></td>
<td>
<p><code>Logical</code>. Indicates if displays tick marks should be plotted on the
axes to mark the distribution of raw data, but only if <code>type == 'response'</code>.
Default is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="conditional_effects.mvgam_+3A_...">...</code></td>
<td>
<p>other arguments to pass to <code><a href="marginaleffects.html#topic+plot_predictions">plot_predictions</a></code></p>
</td></tr>
<tr><td><code id="conditional_effects.mvgam_+3A_plot">plot</code></td>
<td>
<p>Logical; indicates if plots should be
plotted directly in the active graphic device.
Defaults to <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="conditional_effects.mvgam_+3A_ask">ask</code></td>
<td>
<p><code>Logical</code>. Indicates if the user is prompted before a new page is plotted.
Only used if plot is <code>TRUE</code>. Default is <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function acts as a wrapper to the more
flexible <code><a href="marginaleffects.html#topic+plot_predictions">plot_predictions</a></code>.
When creating <code>conditional_effects</code> for a particular predictor
(or interaction of two predictors), one has to choose the values of all
other predictors to condition on. By default, the mean is used for
continuous variables and the reference category is used for factors. Use
<code><a href="marginaleffects.html#topic+plot_predictions">plot_predictions</a></code> to change these
and create more bespoke conditional effects plots.
</p>


<h3>Value</h3>

<p><code>conditional_effects</code> returns an object of class
<code>mvgam_conditional_effects</code> which is a
named list with one slot per effect containing a <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object,
which can be further customized using the <span class="pkg">ggplot2</span> package.
The corresponding <code>plot</code> method will draw these plots in the active graphic device
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>See Also</h3>

<p><code><a href="marginaleffects.html#topic+plot_predictions">plot_predictions</a></code>, <code><a href="marginaleffects.html#topic+plot_slopes">plot_slopes</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate some data
simdat &lt;- sim_mvgam(family = poisson(),
                    seasonality = 'hierarchical')

# Fit a model
mod &lt;- mvgam(y ~ s(season, by = series, k = 5) + year:series,
             family = poisson(),
             data = simdat$data_train,
             chains = 2)

# Plot all main effects on the response scale
conditional_effects(mod)

# Change the prediction interval to 70% using plot_predictions() argument
# 'conf_level'
conditional_effects(mod, conf_level = 0.7)

# Plot all main effects on the link scale
conditional_effects(mod, type = 'link')

# Works the same for smooth terms, including smooth interactions
set.seed(0)
dat &lt;- mgcv::gamSim(1, n = 200, scale = 2)
mod &lt;- mvgam(y ~ te(x0, x1, k = 5) + s(x2, k = 6) + s(x3, k = 6),
            data = dat,
            family = gaussian(),
            chains = 2)
conditional_effects(mod)
conditional_effects(mod, conf_level = 0.5, type = 'link')

# ggplot objects can be modified and combined with the help of many
# additional packages. Here is an example using the patchwork package

# Simulate some nonlinear data
dat &lt;- mgcv::gamSim(1, n = 200, scale = 2)
mod &lt;- mvgam(y ~ s(x1, bs = 'moi') +
               te(x0, x2),
             data = dat,
             family = gaussian(),
             chains = 2,
             silent = 2)

# Extract the list of ggplot conditional_effect plots
m &lt;- plot(conditional_effects(mod), plot = FALSE)

# Add custom labels and arrange plots together using patchwork::wrap_plots()
library(patchwork)
library(ggplot2)
wrap_plots(m[[1]] + labs(title = 's(x1, bs = "moi")'),
           m[[2]] + labs(title = 'te(x0, x2)'))

</code></pre>

<hr>
<h2 id='dynamic'>Defining dynamic coefficients in <span class="pkg">mvgam</span> formulae</h2><span id='topic+dynamic'></span>

<h3>Description</h3>

<p>Set up time-varying (dynamic) coefficients for use in <span class="pkg">mvgam</span> models. Currently, only
low-rank Gaussian Process smooths are available for estimating the dynamics of the
time-varying coefficient.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>dynamic(variable, k, rho = 5, stationary = TRUE, scale = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="dynamic_+3A_variable">variable</code></td>
<td>
<p>The variable that the dynamic smooth will be a function of</p>
</td></tr>
<tr><td><code id="dynamic_+3A_k">k</code></td>
<td>
<p>Optional number of basis functions for computing approximate GPs. If missing,
<code>k</code> will be set as large as possible to accurately estimate the nonlinear function</p>
</td></tr>
<tr><td><code id="dynamic_+3A_rho">rho</code></td>
<td>
<p>Either a positive numeric stating the length scale to be used for approximating the
squared exponential Gaussian Process smooth (see <code><a href="mgcv.html#topic+gp.smooth">gp.smooth</a></code> for details)
or missing, in which case the length scale will be estimated by setting up a Hilbert space approximate
GP</p>
</td></tr>
<tr><td><code id="dynamic_+3A_stationary">stationary</code></td>
<td>
<p>Logical. If <code>TRUE</code> (the default) and <code>rho</code> is supplied,
the latent Gaussian Process smooth will not have a linear trend component. If <code>FALSE</code>,
a linear trend in the covariate is added to the Gaussian Process smooth. Leave at <code>TRUE</code>
if you do not believe the coefficient is evolving with much trend, as the linear component of the
basis functions can be hard to penalize to zero. This sometimes causes divergence issues in <code>Stan</code>.
See <code><a href="mgcv.html#topic+gp.smooth">gp.smooth</a></code> for details. Ignored if <code>rho</code> is missing (in which case a
Hilbert space approximate GP is used)</p>
</td></tr>
<tr><td><code id="dynamic_+3A_scale">scale</code></td>
<td>
<p>Logical; If <code>TRUE</code> (the default) and <code>rho</code> is missing, predictors
are scaled so that the maximum Euclidean distance between two points is <code>1</code>. This
often improves sampling speed and convergence. Scaling also affects the estimated
length-scale parameters in that they resemble those of scaled predictors
(not of the original predictors) if scale is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mvgam</code> currently sets up dynamic coefficients as low-rank
squared exponential Gaussian Process smooths via
the call <code>s(time, by = variable, bs = "gp", m = c(2, rho, 2))</code>. These smooths, if specified with
reasonable values for the length scale parameter, will give more realistic out of sample forecasts
than standard splines such as thin plate or cubic. But the user must set the
value for <code>rho</code>, as there is currently no support for estimating this value in <code>mgcv</code>.
This may not be too big of a problem, as estimating latent length scales is often difficult anyway. The
<code>rho</code> parameter should be thought of as a prior on the smoothness of the latent dynamic coefficient
function (where higher values of <code>rho</code> lead to smoother functions with more temporal covariance structure.
Values of <code>k</code> are
set automatically to ensure enough basis functions are used to approximate the expected
wiggliness of the underlying dynamic function (<code>k</code> will increase as <code>rho</code> decreases)
</p>


<h3>Value</h3>

<p>a <code>list</code> object for internal usage in 'mvgam'
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate a time-varying coefficient
# (as a Gaussian Process with length scale = 10)
set.seed(1111)
N &lt;- 200

# A function to simulate from a squared exponential Gaussian Process
sim_gp = function(N, c, alpha, rho){
 Sigma &lt;- alpha ^ 2 *
          exp(-0.5 * ((outer(1:N, 1:N, "-") / rho) ^ 2)) +
          diag(1e-9, N)
c + mgcv::rmvn(1,
               mu = rep(0, N),
               V = Sigma)
}

beta &lt;- sim_gp(alpha = 0.75,
              rho = 10,
              c = 0.5,
              N = N)
plot(beta, type = 'l', lwd = 3,
    bty = 'l', xlab = 'Time',
    ylab = 'Coefficient',
    col = 'darkred')

# Simulate the predictor as a standard normal
predictor &lt;- rnorm(N, sd = 1)

# Simulate a Gaussian outcome variable
out &lt;- rnorm(N, mean = 4 + beta * predictor,
            sd = 0.25)
time &lt;- seq_along(predictor)
plot(out,  type = 'l', lwd = 3,
    bty = 'l', xlab = 'Time', ylab = 'Outcome',
    col = 'darkred')

# Gather into a data.frame and fit a dynamic coefficient model
data &lt;- data.frame(out, predictor, time)

# Split into training and testing
data_train &lt;- data[1:190,]
data_test &lt;- data[191:200,]

# Fit a model using the dynamic function
mod &lt;- mvgam(out ~
             # mis-specify the length scale slightly as this
             # won't be known in practice
             dynamic(predictor, rho = 8, stationary = TRUE),
            family = gaussian(),
            data = data_train,
            chains = 2,
            silent = 2)

# Inspect the summary
summary(mod)

# Plot the time-varying coefficient estimates
plot(mod, type = 'smooths')

# Extrapolate the coefficient forward in time
plot_mvgam_smooth(mod, smooth = 1, newdata = data)
abline(v = 190, lty = 'dashed', lwd = 2)

# Overlay the true simulated time-varying coefficient
lines(beta, lwd = 2.5, col = 'white')
lines(beta, lwd = 2)

</code></pre>

<hr>
<h2 id='ensemble.mvgam_forecast'>Combine forecasts from <span class="pkg">mvgam</span> models into evenly weighted ensembles</h2><span id='topic+ensemble.mvgam_forecast'></span><span id='topic+ensemble'></span>

<h3>Description</h3>

<p>Generate evenly weighted ensemble forecast distributions from <code>mvgam_forecast</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ensemble(object, ...)

## S3 method for class 'mvgam_forecast'
ensemble(object, ..., ndraws = 5000)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ensemble.mvgam_forecast_+3A_object">object</code></td>
<td>
<p><code>list</code> object of class <code>mvgam_forecast</code>. See <code><a href="#topic+forecast.mvgam">forecast.mvgam()</a></code></p>
</td></tr>
<tr><td><code id="ensemble.mvgam_forecast_+3A_...">...</code></td>
<td>
<p>More <code>mvgam_forecast</code> objects.</p>
</td></tr>
<tr><td><code id="ensemble.mvgam_forecast_+3A_ndraws">ndraws</code></td>
<td>
<p>Positive integer specifying the number of draws to use from each
forecast distribution for creating the ensemble. If some of the ensemble members have
fewer draws than <code>ndraws</code>, their forecast distributions will be resampled with replacement
to achieve the correct number of draws</p>
</td></tr>
</table>


<h3>Details</h3>

<p>It is widely recognised in the forecasting literature that combining forecasts
from different models often results in improved forecast accuracy. The simplest way to create
an ensemble is to use evenly weighted combinations of forecasts from the different models.
This is straightforward to do in a Bayesian setting with <span class="pkg">mvgam</span> as the posterior MCMC draws
contained in each <code>mvgam_forecast</code> object will already implicitly capture correlations among
the temporal posterior predictions.
</p>


<h3>Value</h3>

<p>An object of class <code>mvgam_forecast</code> containing the ensemble predictions. This
object can be readily used with the supplied S3 functions <code>plot</code> and <code>score</code>
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot.mvgam_forecast">plot.mvgam_forecast</a></code>, <code><a href="#topic+score.mvgam_forecast">score.mvgam_forecast</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate some series and fit a few competing dynamic models
set.seed(1)
simdat &lt;- sim_mvgam(n_series = 1,
                    prop_trend = 0.6,
                    mu = 1)

plot_mvgam_series(data = simdat$data_train,
                 newdata = simdat$data_test)

m1 &lt;- mvgam(y ~ 1,
            trend_formula = ~ time +
              s(season, bs = 'cc', k = 9),
            trend_model = AR(p = 1),
            noncentred = TRUE,
            data = simdat$data_train,
            newdata = simdat$data_test,
            chains = 2,
            silent = 2)

m2 &lt;- mvgam(y ~ time,
            trend_model = RW(),
            noncentred = TRUE,
            data = simdat$data_train,
            newdata = simdat$data_test,
            chains = 2,
            silent = 2)

# Calculate forecast distributions for each model
fc1 &lt;- forecast(m1)
fc2 &lt;- forecast(m2)

# Generate the ensemble forecast
ensemble_fc &lt;- ensemble(fc1, fc2)

# Plot forecasts
plot(fc1)
plot(fc2)
plot(ensemble_fc)

# Score forecasts
score(fc1)
score(fc2)
score(ensemble_fc)

</code></pre>

<hr>
<h2 id='evaluate_mvgams'>Evaluate forecasts from fitted <span class="pkg">mvgam</span> objects</h2><span id='topic+evaluate_mvgams'></span><span id='topic+eval_mvgam'></span><span id='topic+roll_eval_mvgam'></span><span id='topic+compare_mvgams'></span>

<h3>Description</h3>

<p>Evaluate forecasts from fitted <span class="pkg">mvgam</span> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>eval_mvgam(
  object,
  n_samples = 5000,
  eval_timepoint = 3,
  fc_horizon = 3,
  n_cores = 1,
  score = "drps",
  log = FALSE,
  weights
)

roll_eval_mvgam(
  object,
  n_evaluations = 5,
  evaluation_seq,
  n_samples = 5000,
  fc_horizon = 3,
  n_cores = 1,
  score = "drps",
  log = FALSE,
  weights
)

compare_mvgams(
  model1,
  model2,
  n_samples = 1000,
  fc_horizon = 3,
  n_evaluations = 10,
  n_cores = 1,
  score = "drps",
  log = FALSE,
  weights
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="evaluate_mvgams_+3A_object">object</code></td>
<td>
<p><code>list</code> object returned from <code>mvgam</code></p>
</td></tr>
<tr><td><code id="evaluate_mvgams_+3A_n_samples">n_samples</code></td>
<td>
<p><code>integer</code> specifying the number of samples to generate from the model's
posterior distribution</p>
</td></tr>
<tr><td><code id="evaluate_mvgams_+3A_eval_timepoint">eval_timepoint</code></td>
<td>
<p><code>integer</code> indexing the timepoint that represents our last 'observed'
set of outcome data</p>
</td></tr>
<tr><td><code id="evaluate_mvgams_+3A_fc_horizon">fc_horizon</code></td>
<td>
<p><code>integer</code> specifying the length of the forecast horizon for evaluating forecasts</p>
</td></tr>
<tr><td><code id="evaluate_mvgams_+3A_n_cores">n_cores</code></td>
<td>
<p>Deprecated. Parallel processing is no longer supported</p>
</td></tr>
<tr><td><code id="evaluate_mvgams_+3A_score">score</code></td>
<td>
<p><code>character</code> specifying the type of ranked probability score to use for evaluation. Options are:
<code>variogram</code>, <code>drps</code> or <code>crps</code></p>
</td></tr>
<tr><td><code id="evaluate_mvgams_+3A_log">log</code></td>
<td>
<p><code>logical</code>. Should the forecasts and truths be logged prior to scoring?
This is often appropriate for comparing
performance of models when series vary in their observation ranges</p>
</td></tr>
<tr><td><code id="evaluate_mvgams_+3A_weights">weights</code></td>
<td>
<p>optional <code>vector</code> of weights (where <code>length(weights) == n_series</code>)
for weighting pairwise correlations when evaluating the variogram score for multivariate
forecasts. Useful for down-weighting series that have larger magnitude observations or that
are of less interest when forecasting. Ignored if <code>score != 'variogram'</code></p>
</td></tr>
<tr><td><code id="evaluate_mvgams_+3A_n_evaluations">n_evaluations</code></td>
<td>
<p><code>integer</code> specifying the total number of evaluations to perform</p>
</td></tr>
<tr><td><code id="evaluate_mvgams_+3A_evaluation_seq">evaluation_seq</code></td>
<td>
<p>Optional <code>integer sequence</code> specifying the exact set of timepoints for
evaluating the model's forecasts. This sequence cannot have values
<code>&lt;3</code> or <code>&gt; max(training timepoints) - fc_horizon</code></p>
</td></tr>
<tr><td><code id="evaluate_mvgams_+3A_model1">model1</code></td>
<td>
<p><code>list</code> object returned from <code>mvgam</code> representing the first model to be
evaluated</p>
</td></tr>
<tr><td><code id="evaluate_mvgams_+3A_model2">model2</code></td>
<td>
<p><code>list</code> object returned from <code>mvgam</code> representing the second model to be
evaluated</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>eval_mvgam</code> may be useful when both repeated fitting of a model using <code><a href="#topic+update.mvgam">update.mvgam</a></code>
for exact leave-future-out cross-validation and approximate
leave-future-out cross-validation using <code><a href="#topic+lfo_cv">lfo_cv</a></code> are impractical. The function generates a set of samples representing fixed parameters estimated from the full
<code>mvgam</code> model and latent trend states at a given point in time. The trends are rolled forward
a total of <code>fc_horizon</code> timesteps according to their estimated state space dynamics to
generate an 'out-of-sample' forecast that is evaluated against the true observations in the horizon window.
This function therefore simulates a situation where the model's parameters had already been estimated but
we have only observed data up to the evaluation timepoint and would like to generate forecasts from the
latent trends that have been observed up to that timepoint. Evaluation involves calculating an
appropriate Rank Probability Score and a binary indicator
for whether or not the true value lies within the forecast's 90% prediction interval
</p>
<p><code>roll_eval_mvgam</code> sets up a sequence of evaluation timepoints along a rolling window and iteratively
calls <code>eval_mvgam</code> to evaluate 'out-of-sample' forecasts.
Evaluation involves calculating the Rank Probability Scores and a binary indicator
for whether or not the true value lies within the forecast's 90% prediction interval
</p>
<p><code>compare_mvgams</code> automates the evaluation to compare two fitted models using rolling window forecast evaluation and
provides a series of summary plots to facilitate model selection. It is essentially a wrapper for
<code>roll_eval_mvgam</code>
</p>


<h3>Value</h3>

<p>For <code>eval_mvgam</code>, a <code>list</code> object containing information on specific evaluations for each series
(if using <code>drps</code> or <code>crps</code> as the score) or a vector of scores when using <code>variogram</code>.
</p>
<p>For <code>roll_eval_mvgam</code>, a <code>list</code> object containing information on specific evaluations for each series as well as
a total evaluation summary (taken by summing the forecast score for each series at each evaluation and averaging
the coverages at each evaluation)
</p>
<p>For <code>compare_mvgams</code>, a series of plots comparing forecast Rank Probability Scores for each competing
model. A lower score is preferred. Note however that it is possible to select a model that ultimately
would perform poorly in true out-of-sample forecasting. For example if a wiggly smooth function of 'year'
is included in the model then this function will be learned prior to evaluating rolling window forecasts,
and the model could generate very tight predictions as a result. But when forecasting ahead to timepoints
that the model has not seen (i.e. next year), the smooth function will end up extrapolating, sometimes
in very strange and unexpected ways. It is therefore recommended to only use smooth functions for
covariates that are adequately measured in the data (i.e. 'seasonality', for example) to reduce possible
extrapolation of smooths and let the latent trends in the <code>mvgam</code> model capture any
temporal dependencies in the data. These trends are time series models and so will provide much more
stable forecasts
</p>


<h3>See Also</h3>

<p><code><a href="#topic+forecast">forecast</a></code>, <code><a href="#topic+score">score</a></code>, <code><a href="#topic+lfo_cv">lfo_cv</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate from a Poisson-AR2 model with a seasonal smooth
set.seed(1)
dat &lt;- sim_mvgam(T = 75,
                n_series = 1,
                prop_trend = 0.75,
                trend_model = AR(p = 2),
                family = poisson())


# Fit an appropriate model
mod_ar2 &lt;- mvgam(y ~ s(season, bs = 'cc'),
                trend_model = AR(p = 2),
                family = poisson(),
                data = dat$data_train,
                newdata = dat$data_test,
                chains = 2,
                silent = 2)

# Fit a less appropriate model
mod_rw &lt;- mvgam(y ~ 1,
               trend_model = RW(),
               family = poisson(),
               data = dat$data_train,
               newdata = dat$data_test,
               chains = 2,
               silent = 2)

# Compare Discrete Ranked Probability Scores for the testing period
fc_ar2 &lt;- forecast(mod_ar2)
fc_rw &lt;- forecast(mod_rw)
score_ar2 &lt;- score(fc_ar2, score = 'drps')
score_rw &lt;- score(fc_rw, score = 'drps')
sum(score_ar2$series_1$score)
sum(score_rw$series_1$score)

# Use rolling evaluation for approximate comparisons of 3-step ahead
# forecasts across the training period
compare_mvgams(mod_ar2,
              mod_rw,
              fc_horizon = 3,
              n_samples = 1000,
              n_evaluations = 5)

# Now use approximate leave-future-out CV to compare
# rolling forecasts; start at time point 40 to reduce
# computational time and to ensure enough data is available
# for estimating model parameters
lfo_ar2 &lt;- lfo_cv(mod_ar2,
                 min_t = 40,
                 fc_horizon = 3,
                 silent = 2)
lfo_rw &lt;- lfo_cv(mod_rw,
                min_t = 40,
                fc_horizon = 3,
                silent = 2)

# Plot Pareto-K values and ELPD estimates
plot(lfo_ar2)
plot(lfo_rw)

# Proportion of timepoints in which AR2 model gives
# better forecasts
length(which((lfo_ar2$elpds - lfo_rw$elpds) &gt; 0)) /
      length(lfo_ar2$elpds)

# A higher total ELPD is preferred
lfo_ar2$sum_ELPD
lfo_rw$sum_ELPD

</code></pre>

<hr>
<h2 id='fevd.mvgam'>Calculate latent VAR forecast error variance decompositions</h2><span id='topic+fevd.mvgam'></span><span id='topic+fevd'></span>

<h3>Description</h3>

<p>Compute forecast error variance decompositions from
<code>mvgam</code> models with Vector Autoregressive dynamics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>fevd(object, ...)

## S3 method for class 'mvgam'
fevd(object, h = 10, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fevd.mvgam_+3A_object">object</code></td>
<td>
<p><code>list</code> object of class <code>mvgam</code> resulting from a call to <code><a href="#topic+mvgam">mvgam()</a></code>
that used a Vector Autoregressive latent process model (either as <code>VAR(cor = FALSE)</code> or
<code>VAR(cor = TRUE)</code>)</p>
</td></tr>
<tr><td><code id="fevd.mvgam_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="fevd.mvgam_+3A_h">h</code></td>
<td>
<p>Positive <code>integer</code> specifying the forecast horizon over which to calculate
the IRF</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A forecast error variance decomposition is useful for quantifying the amount
of information each series that in a Vector Autoregression contributes to the forecast
distributions of the other series in the autoregression. This function calculates
the forecast error variance decomposition using the
orthogonalised impulse response coefficient matrices <code class="reqn">\Psi_h</code>, which can be used to
quantify the contribution of series <code class="reqn">j</code> to the
h-step forecast error variance of series <code class="reqn">k</code>:
</p>
<p style="text-align: center;"><code class="reqn">
\sigma_k^2(h) = \sum_{j=1}^K(\psi_{kj, 0}^2 + \ldots + \psi_{kj,
h-1}^2) \quad
</code>
</p>

<p>If the orthogonalised impulse reponses <code class="reqn">(\psi_{kj, 0}^2 + \ldots + \psi_{kj, h-1}^2)</code>
are divided by the variance of the forecast error <code class="reqn">\sigma_k^2(h)</code>,
this yields an interpretable percentage representing how much of the
forecast error variance for <code class="reqn">k</code> can be explained by an exogenous shock to <code class="reqn">j</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>mvgam_fevd</code> containing the posterior forecast error
variance decompositions. This
object can be used with the supplied S3 functions <code>plot</code>
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>References</h3>

<p>Lütkepohl, H (2006).
New Introduction to Multiple Time Series Analysis. Springer, New York.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VAR">VAR</a></code>, <code><a href="#topic+irf">irf</a></code>, <code><a href="#topic+stability">stability</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate some time series that follow a latent VAR(1) process
simdat &lt;- sim_mvgam(
  family = gaussian(),
  n_series = 4,
  trend_model = VAR(cor = TRUE),
  prop_trend = 1
)
plot_mvgam_series(data = simdat$data_train, series = "all")

# Fit a model that uses a latent VAR(1)
mod &lt;- mvgam(y ~ -1,
  trend_formula = ~1,
  trend_model = VAR(cor = TRUE),
  family = gaussian(),
  data = simdat$data_train,
  chains = 2,
  silent = 2
)

# Calulate forecast error variance decompositions for each series
fevds &lt;- fevd(mod, h = 12)

# Plot median contributions to forecast error variance
plot(fevds)

# View a summary of the error variance decompositions
summary(fevds)

</code></pre>

<hr>
<h2 id='fitted.mvgam'>Expected values of the posterior predictive distribution for <span class="pkg">mvgam</span> objects</h2><span id='topic+fitted.mvgam'></span>

<h3>Description</h3>

<p>This method extracts posterior estimates of the fitted values
(i.e. the actual predictions, included estimates for any trend states,
that were obtained when fitting the model). It also includes an option
for obtaining summaries of the computed draws.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
fitted(
  object,
  process_error = TRUE,
  scale = c("response", "linear"),
  summary = TRUE,
  robust = FALSE,
  probs = c(0.025, 0.975),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="fitted.mvgam_+3A_object">object</code></td>
<td>
<p>An object of class <code>mvgam</code></p>
</td></tr>
<tr><td><code id="fitted.mvgam_+3A_process_error">process_error</code></td>
<td>
<p>Logical. If <code>TRUE</code> and a dynamic trend model was fit,
expected uncertainty in the process model is accounted for by using draws
from the latent trend SD parameters. If <code>FALSE</code>, uncertainty in the latent trend
component is ignored when calculating predictions</p>
</td></tr>
<tr><td><code id="fitted.mvgam_+3A_scale">scale</code></td>
<td>
<p>Either <code>"response"</code> or <code>"linear"</code>.
If <code>"response"</code>, results are returned on the scale
of the response variable. If <code>"linear"</code>,
results are returned on the scale of the linear predictor term,
that is without applying the inverse link function or
other transformations.</p>
</td></tr>
<tr><td><code id="fitted.mvgam_+3A_summary">summary</code></td>
<td>
<p>Should summary statistics be returned
instead of the raw values? Default is <code>TRUE</code>..</p>
</td></tr>
<tr><td><code id="fitted.mvgam_+3A_robust">robust</code></td>
<td>
<p>If <code>FALSE</code> (the default) the mean is used as
the measure of central tendency and the standard deviation as
the measure of variability. If <code>TRUE</code>, the median and the
median absolute deviation (MAD) are applied instead.
Only used if <code>summary</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fitted.mvgam_+3A_probs">probs</code></td>
<td>
<p>The percentiles to be computed by the <code>quantile</code>
function. Only used if <code>summary</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="fitted.mvgam_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="brms.html#topic+prepare_predictions">prepare_predictions</a></code>
that control several aspects of data validation and prediction.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method gives the actual fitted values from the model (i.e. what you
will see if you generate hindcasts from the fitted model using <code><a href="#topic+hindcast.mvgam">hindcast.mvgam</a></code>
with <code>type = 'expected'</code>). These
predictions can be overly precise if a flexible dynamic trend component was included
in the model. This is in contrast to the set of predict functions (i.e.
<code><a href="#topic+posterior_epred.mvgam">posterior_epred.mvgam</a></code> or <code><a href="#topic+predict.mvgam">predict.mvgam</a></code>), which will assume
any dynamic trend component has reached stationarity when returning hypothetical predictions
</p>


<h3>Value</h3>

<p>An <code>array</code> of predicted <em>mean</em> response values.
If <code>summary = FALSE</code> the output resembles those of
<code><a href="#topic+posterior_epred.mvgam">posterior_epred.mvgam</a></code> and <code><a href="#topic+predict.mvgam">predict.mvgam</a></code>.
</p>
<p>If <code>summary = TRUE</code> the output is an <code>n_observations</code> x <code>E</code>
matrix. The number of summary statistics <code>E</code> is equal to <code>2 +
  length(probs)</code>: The <code>Estimate</code> column contains point estimates (either
mean or median depending on argument <code>robust</code>), while the
<code>Est.Error</code> column contains uncertainty estimates (either standard
deviation or median absolute deviation depending on argument
<code>robust</code>). The remaining columns starting with <code>Q</code> contain
quantile estimates as specified via argument <code>probs</code>.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hindcast.mvgam">hindcast.mvgam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate some data and fit a model
simdat &lt;- sim_mvgam(n_series = 1, trend_model = AR())
mod &lt;- mvgam(y ~ s(season, bs = 'cc'),
            trend_model = AR(),
            data = simdat$data_train,
            chains = 2,
            silent = 2)

# Extract fitted values (posterior expectations)
expectations &lt;- fitted(mod)
str(expectations)

</code></pre>

<hr>
<h2 id='forecast.mvgam'>Extract or compute hindcasts and forecasts for a fitted <code>mvgam</code> object</h2><span id='topic+forecast.mvgam'></span><span id='topic+forecast'></span>

<h3>Description</h3>

<p>Extract or compute hindcasts and forecasts for a fitted <code>mvgam</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>forecast(object, ...)

## S3 method for class 'mvgam'
forecast(object, newdata, data_test, n_cores = 1, type = "response", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="forecast.mvgam_+3A_object">object</code></td>
<td>
<p><code>list</code> object of class <code>mvgam</code> or <code>jsdgam</code>. See <code><a href="#topic+mvgam">mvgam()</a></code></p>
</td></tr>
<tr><td><code id="forecast.mvgam_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="forecast.mvgam_+3A_newdata">newdata</code></td>
<td>
<p>Optional <code>dataframe</code> or <code>list</code> of test data containing the same variables
that were included in the original <code>data</code> used to fit the model. If included, the
covariate information in <code>newdata</code> will be used to generate forecasts from the fitted model equations. If
this same <code>newdata</code> was originally included in the call to <code>mvgam</code>, then forecasts have already been
produced by the generative model and these will simply be extracted and plotted. However if no <code>newdata</code> was
supplied to the original model call, an assumption is made that the <code>newdata</code> supplied here comes sequentially
after the data supplied in the original model (i.e. we assume there is no time gap between the last
observation of series 1 in the original data and the first observation for series 1 in <code>newdata</code>)</p>
</td></tr>
<tr><td><code id="forecast.mvgam_+3A_data_test">data_test</code></td>
<td>
<p>Deprecated. Still works in place of <code>newdata</code> but users are recommended to use
<code>newdata</code> instead for more seamless integration into <code>R</code> workflows</p>
</td></tr>
<tr><td><code id="forecast.mvgam_+3A_n_cores">n_cores</code></td>
<td>
<p>Deprecated. Parallel processing is no longer supported</p>
</td></tr>
<tr><td><code id="forecast.mvgam_+3A_type">type</code></td>
<td>
<p>When this has the value <code>link</code> (default) the linear predictor is
calculated on the link scale.
If <code>expected</code> is used, predictions reflect the expectation of the response (the mean)
but ignore uncertainty in the observation process. When <code>response</code> is used,
the predictions take uncertainty in the observation process into account to return
predictions on the outcome scale. When <code>variance</code> is used, the variance of the response
with respect to the mean (mean-variance relationship) is returned.
When <code>type = "terms"</code>, each component of the linear predictor is
returned separately in the form of a <code>list</code> (possibly with standard
errors, if <code>summary = TRUE</code>): this includes parametric model components,
followed by each smooth component, but excludes any offset and any intercept.
Two special cases are also allowed:
type <code>latent_N</code> will return the estimated latent abundances from an
N-mixture distribution, while type <code>detection</code> will return the estimated
detection probability from an N-mixture distribution</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Posterior predictions are drawn from the fitted <code>mvgam</code> and used to simulate a forecast distribution
</p>


<h3>Value</h3>

<p>An object of class <code>mvgam_forecast</code> containing hindcast and forecast distributions.
See <code><a href="#topic+mvgam_forecast-class">mvgam_forecast-class</a></code> for details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hindcast">hindcast</a></code>, <code><a href="#topic+score">score</a></code>, <code><a href="#topic+ensemble">ensemble</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
simdat &lt;- sim_mvgam(n_series = 3, trend_model = AR())
mod &lt;- mvgam(y ~ s(season, bs = 'cc', k = 6),
             trend_model = AR(),
             noncentred = TRUE,
             data = simdat$data_train,
             chains = 2,
             silent = 2)

# Hindcasts on response scale
hc &lt;- hindcast(mod)
str(hc)
plot(hc, series = 1)
plot(hc, series = 2)
plot(hc, series = 3)

# Forecasts on response scale
fc &lt;- forecast(mod,
               newdata = simdat$data_test)
str(fc)
plot(fc, series = 1)
plot(fc, series = 2)
plot(fc, series = 3)

# Forecasts as expectations
fc &lt;- forecast(mod,
               newdata = simdat$data_test,
               type = 'expected')
plot(fc, series = 1)
plot(fc, series = 2)
plot(fc, series = 3)

# Dynamic trend extrapolations
fc &lt;- forecast(mod,
               newdata = simdat$data_test,
               type = 'trend')
plot(fc, series = 1)
plot(fc, series = 2)
plot(fc, series = 3)

</code></pre>

<hr>
<h2 id='formula.mvgam'>Extract formulae from <span class="pkg">mvgam</span> objects</h2><span id='topic+formula.mvgam'></span><span id='topic+formula.mvgam_prefit'></span>

<h3>Description</h3>

<p>Extract formulae from <span class="pkg">mvgam</span> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
formula(x, trend_effects = FALSE, ...)

## S3 method for class 'mvgam_prefit'
formula(x, trend_effects = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="formula.mvgam_+3A_x">x</code></td>
<td>
<p><code>mvgam</code>, <code>jsdgam</code> or <code>mvgam_prefit</code> object</p>
</td></tr>
<tr><td><code id="formula.mvgam_+3A_trend_effects">trend_effects</code></td>
<td>
<p><code>logical</code>, return the formula from the
observation model (if <code>FALSE</code>) or from the underlying process
model (if<code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="formula.mvgam_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>formula</code> object
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>

<hr>
<h2 id='get_mvgam_priors'>Extract information on default prior distributions for an <span class="pkg">mvgam</span> model</h2><span id='topic+get_mvgam_priors'></span>

<h3>Description</h3>

<p>This function lists the parameters that can have their prior distributions
changed for a given model, as well listing their default distributions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>get_mvgam_priors(
  formula,
  trend_formula,
  factor_formula,
  knots,
  trend_knots,
  trend_model = "None",
  family = poisson(),
  data,
  unit = time,
  species = series,
  use_lv = FALSE,
  n_lv,
  trend_map,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="get_mvgam_priors_+3A_formula">formula</code></td>
<td>
<p>A <code>formula</code> object specifying the GAM observation model
formula. These are exactly like the formula
for a GLM except that smooth terms, <code>s()</code>, <code>te()</code>, <code>ti()</code>, <code>t2()</code>, as well
as time-varying <code>dynamic()</code> terms, nonparametric <code>gp()</code> terms and offsets using <code>offset()</code>,
can be added to the right hand side to specify that the linear predictor
depends on smooth functions of predictors (or linear functionals of these).
In <code>nmix()</code> family models, the <code>formula</code> is used to set up a linear predictor
for the detection probability. Details of the formula
syntax used by <span class="pkg">mvgam</span> can be found in <code><a href="#topic+mvgam_formulae">mvgam_formulae</a></code></p>
</td></tr>
<tr><td><code id="get_mvgam_priors_+3A_trend_formula">trend_formula</code></td>
<td>
<p>An optional <code>formula</code> object specifying the GAM
process model formula. If
supplied, a linear predictor will be modelled for the latent trends to capture
process model evolution
separately from the observation model. Should not have a response variable
specified on the left-hand side
of the formula (i.e. a valid option would be <code>~ season + s(year)</code>). Also note
that you should not use
the identifier <code>series</code> in this formula to specify effects that vary across
time series. Instead you should use
<code>trend</code>. This will ensure that models in which a <code>trend_map</code> is supplied will
still work consistently
(i.e. by allowing effects to vary across process models, even when some time
series share the same underlying
process model). This feature is only currently available for <code>RW()</code>, <code>AR()</code>
and <code>VAR()</code> trend models.
In <code>nmix()</code> family models, the <code>trend_formula</code> is used to set up a linear
predictor for the underlying
latent abundance. Be aware that it can be very challenging to simultaneously
estimate intercept parameters
for both the observation mode (captured by <code>formula</code>) and the process model
(captured by <code>trend_formula</code>).
Users are recommended to drop one of these using the <code>- 1</code> convention in the
formula right hand side.</p>
</td></tr>
<tr><td><code id="get_mvgam_priors_+3A_factor_formula">factor_formula</code></td>
<td>
<p>Can be supplied instead <code>trend_formula</code> to match syntax from
<a href="#topic+jsdgam">jsdgam</a></p>
</td></tr>
<tr><td><code id="get_mvgam_priors_+3A_knots">knots</code></td>
<td>
<p>An optional <code>list</code> containing user specified knot values to
be used for basis construction.
For most bases the user simply supplies the knots to be used, which must match
up with the <code>k</code> value supplied
(note that the number of knots is not always just <code>k</code>). Different terms can
use different numbers of knots,
unless they share a covariate</p>
</td></tr>
<tr><td><code id="get_mvgam_priors_+3A_trend_knots">trend_knots</code></td>
<td>
<p>As for <code>knots</code> above, this is an optional <code>list</code> of
knot values for smooth
functions within the <code>trend_formula</code></p>
</td></tr>
<tr><td><code id="get_mvgam_priors_+3A_trend_model">trend_model</code></td>
<td>
<p><code>character</code> or  <code>function</code> specifying the time
series dynamics for the latent trend. Options are:
</p>

<ul>
<li> <p><code>None</code> (no latent trend component; i.e. the GAM component is all that
contributes to the linear predictor, and the observation process is the only
source of error; similarly to what is estimated by <code><a href="mgcv.html#topic+gam">gam</a></code>)
</p>
</li>
<li> <p><code>ZMVN</code> or <code>ZMVN()</code> (Zero-Mean Multivariate Normal; only available in
<code>Stan</code>)
</p>
</li>
<li> <p><code>'RW'</code> or <code>RW()</code>
</p>
</li>
<li> <p><code>'AR1'</code> or <code>AR(p = 1)</code>
</p>
</li>
<li> <p><code>'AR2'</code> or <code>AR(p = 2)</code>
</p>
</li>
<li> <p><code>'AR3'</code> or <code>AR(p = 3)</code>
</p>
</li>
<li> <p><code>'CAR1'</code> or <code>CAR(p = 1)</code>
</p>
</li>
<li> <p><code>'VAR1'</code>  or <code>VAR()</code>(only available in <code>Stan</code>)
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;'PWlogistic&#8288;</code>, <code>'PWlinear'</code> or <code>PW()</code> (only available in <code>Stan</code>)
</p>
</li>
<li> <p><code>'GP'</code> or <code>GP()</code> (Gaussian Process with squared exponential kernel;
only available in <code>Stan</code>)</p>
</li></ul>

<p>For all trend types apart from <code>ZMVN()</code>, <code>GP()</code>, <code>CAR()</code> and <code>PW()</code>, moving
average and/or correlated process error terms can also be estimated (for
example, <code>RW(cor = TRUE)</code> will set up a multivariate Random Walk if <code>n_series &gt; 1</code>).
It is also possible for many multivariate trends to estimate hierarchical
correlations if the data are structured among levels of a relevant grouping
factor. See <a href="#topic+mvgam_trends">mvgam_trends</a> for more details and see <a href="#topic+ZMVN">ZMVN</a> for an example.</p>
</td></tr>
<tr><td><code id="get_mvgam_priors_+3A_family">family</code></td>
<td>
<p><code>family</code> specifying the exponential observation family for
the series. Currently supported
families are:
</p>

<ul>
<li><p><code>gaussian()</code> for real-valued data
</p>
</li>
<li><p><code>betar()</code> for proportional data on <code style="white-space: pre;">&#8288;(0,1)&#8288;</code>
</p>
</li>
<li><p><code>lognormal()</code> for non-negative real-valued data
</p>
</li>
<li><p><code>student_t()</code> for real-valued data
</p>
</li>
<li><p><code>Gamma()</code> for non-negative real-valued data
</p>
</li>
<li><p><code>bernoulli()</code> for binary data
</p>
</li>
<li><p><code>poisson()</code> for count data
</p>
</li>
<li><p><code>nb()</code> for overdispersed count data
</p>
</li>
<li><p><code>binomial()</code> for count data with imperfect detection when the number
of trials is known;
note that the <code>cbind()</code> function must be used to bind the discrete
observations and the discrete number
of trials
</p>
</li>
<li><p><code>beta_binomial()</code> as for <code>binomial()</code> but allows for overdispersion
</p>
</li>
<li><p><code>nmix()</code> for count data with imperfect detection when the number of
trials is unknown and should be modeled via a State-Space N-Mixture model.
The latent states are Poisson, capturing the 'true' latent
abundance, while the observation process is Binomial to account for
imperfect detection.
See <code><a href="#topic+mvgam_families">mvgam_families</a></code> for an example of how to use this family</p>
</li></ul>

<p>Default is <code>poisson()</code>.
See <code><a href="#topic+mvgam_families">mvgam_families</a></code> for more details</p>
</td></tr>
<tr><td><code id="get_mvgam_priors_+3A_data">data</code></td>
<td>
<p>A <code>dataframe</code> or <code>list</code> containing the model response
variable and covariates
required by the GAM <code>formula</code> and optional <code>trend_formula</code>. Most
models should include columns:
</p>

<ul>
<li><p><code>series</code> (a <code>factor</code> index of the series IDs; the number of
levels should be identical
to the number of unique series labels (i.e. <code>n_series = length(levels(data$series))</code>))
</p>
</li>
<li><p><code>time</code> (<code>numeric</code> or <code>integer</code> index of the time point for
each observation).
For most dynamic trend types available in <code>mvgam</code> (see argument <code>trend_model</code>),
time should be
measured in discrete, regularly spaced intervals (i.e. <code>c(1, 2, 3, ...)</code>).
However you can
use irregularly spaced intervals if using <code>trend_model = CAR(1)</code>, though
note that any
temporal intervals that are exactly <code>0</code> will be adjusted to a very small number
(<code>1e-12</code>) to prevent sampling errors. See an example of <code>CAR()</code> trends in
<code><a href="#topic+CAR">CAR</a></code>
</p>
</li></ul>

<p>Note however that there are special cases where these identifiers are not
needed. For
example, models with hierarchical temporal correlation processes (e.g.
<code>AR(gr = region, subgr = species)</code>)
should NOT include a <code>series</code> identifier, as this will be constructed
internally (see
<code><a href="#topic+mvgam_trends">mvgam_trends</a></code> and <code><a href="#topic+AR">AR</a></code> for details). <code>mvgam</code> can also
fit models that do not
include a <code>time</code> variable if there are no temporal dynamic structures included
(i.e. <code>trend_model = 'None'</code> or
<code>trend_model = ZMVN()</code>). <code>data</code> should also include any other variables to be
included in
the linear predictor of <code>formula</code></p>
</td></tr>
<tr><td><code id="get_mvgam_priors_+3A_unit">unit</code></td>
<td>
<p>The unquoted name of the variable that represents the unit of analysis in <code>data</code> over
which latent residuals should be correlated. This variable should be either a
<code>numeric</code> or <code>integer</code> variable in the supplied <code>data</code>.
Defaults to <code>time</code> to be consistent with other functionalities
in <span class="pkg">mvgam</span>, though note that the data need not be time series in this case. See examples below
for further details and explanations</p>
</td></tr>
<tr><td><code id="get_mvgam_priors_+3A_species">species</code></td>
<td>
<p>The unquoted name of the <code>factor</code> variable that indexes
the different response units in <code>data</code> (usually <code>'species'</code> in a JSDM).
Defaults to <code>series</code> to be consistent with other <code>mvgam</code> models</p>
</td></tr>
<tr><td><code id="get_mvgam_priors_+3A_use_lv">use_lv</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, use dynamic factors to estimate series'
latent trends in a reduced dimension format. Only available for
<code>RW()</code>, <code>AR()</code> and <code>GP()</code> trend models. Defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="get_mvgam_priors_+3A_n_lv">n_lv</code></td>
<td>
<p><code>integer</code> the number of latent dynamic factors to use if
<code>use_lv == TRUE</code>. Cannot be <code>&gt; n_series</code>. Defaults arbitrarily to
<code>min(2, floor(n_series / 2))</code></p>
</td></tr>
<tr><td><code id="get_mvgam_priors_+3A_trend_map">trend_map</code></td>
<td>
<p>Optional <code>data.frame</code> specifying which series should depend
on which latent trends. Useful for allowing multiple series to depend on the
same latent trend process, but with different observation processes. If
supplied, a latent factor model is set up by setting <code>use_lv = TRUE</code> and
using the mapping to set up the shared trends. Needs to have column names
<code>series</code> and <code>trend</code>, with integer values in the <code>trend</code> column to state which
trend each series should depend on. The <code>series</code> column should have a single
unique entry for each series in the data (names should perfectly match factor
levels of the <code>series</code> variable in <code>data</code>). Note that if this is supplied,
the intercept parameter in the process model will NOT be automatically suppressed.
Not yet supported for models in wich the latent factors evolve in continuous time (<code>CAR()</code>).
See examples for details</p>
</td></tr>
<tr><td><code id="get_mvgam_priors_+3A_...">...</code></td>
<td>
<p>Not currently used</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Users can supply a model formula, prior to fitting the model, so that default priors can be inspected and
altered. To make alterations, change the contents of the <code>prior</code> column and supplying this
<code>data.frame</code> to the <code><a href="#topic+mvgam">mvgam</a></code> or <code><a href="#topic+jsdgam">jsdgam</a></code> functions using the argument <code>priors</code>. If using <code>Stan</code> as the backend,
users can also modify the parameter bounds by modifying the <code>new_lowerbound</code> and/or <code>new_upperbound</code> columns.
This will be necessary if using restrictive distributions on some parameters, such as a Beta distribution
for the trend sd parameters for example (Beta only has support on  <code>(0,1)</code>), so the upperbound cannot
be above <code>1</code>. Another option is to make use of the prior modification functions in <span class="pkg">brms</span>
(i.e. <code><a href="brms.html#topic+prior">prior</a></code>) to change prior distributions and bounds (just use the name of the parameter that
you'd like to change as the <code>class</code> argument; see examples below)
</p>


<h3>Value</h3>

<p>either a <code>data.frame</code> containing the prior definitions (if any suitable
priors can be altered by the user) or <code>NULL</code>, indicating that no priors in the model
can be modified
</p>


<h3>Note</h3>

<p>Only the <code>prior</code>, <code>new_lowerbound</code> and/or <code>new_upperbound</code> columns of the output
should be altered when defining the user-defined priors for the model. Use only if you are
familiar with the underlying probabilistic programming language. There are no sanity checks done to
ensure that the code is legal (i.e. to check that lower bounds are smaller than upper bounds, for
example)
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvgam">mvgam</a></code>, <code><a href="#topic+mvgam_formulae">mvgam_formulae</a></code>, <code><a href="brms.html#topic+prior">prior</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate three integer-valued time series
library(mvgam)
dat &lt;- sim_mvgam(trend_rel = 0.5)

# Get a model file that uses default mvgam priors for inspection (not always necessary,
# but this can be useful for testing whether your updated priors are written correctly)
mod_default &lt;- mvgam(y ~ s(series, bs = 're') +
              s(season, bs = 'cc') - 1,
              family = nb(),
              data = dat$data_train,
              trend_model = AR(p = 2),
              run_model = FALSE)

# Inspect the model file with default mvgam priors
stancode(mod_default)

# Look at which priors can be updated in mvgam
test_priors &lt;- get_mvgam_priors(y ~ s(series, bs = 're') +
                              s(season, bs = 'cc') - 1,
                              family = nb(),
                              data = dat$data_train,
                              trend_model = AR(p = 2))
test_priors

# Make a few changes; first, change the population mean for the series-level
# random intercepts
test_priors$prior[2] &lt;- 'mu_raw ~ normal(0.2, 0.5);'

# Now use stronger regularisation for the series-level AR2 coefficients
test_priors$prior[5] &lt;- 'ar2 ~ normal(0, 0.25);'

# Check that the changes are made to the model file without any warnings by
# setting 'run_model = FALSE'
mod &lt;- mvgam(y ~ s(series, bs = 're') +
            s(season, bs = 'cc') - 1,
            family = nb(),
            data = dat$data_train,
            trend_model = AR(p = 2),
            priors = test_priors,
            run_model = FALSE)
stancode(mod)

# No warnings, the model is ready for fitting now in the usual way with the addition
# of the 'priors' argument

# The same can be done using 'brms' functions; here we will also change the ar1 prior
# and put some bounds on the ar coefficients to enforce stationarity; we set the
# prior using the 'class' argument in all brms prior functions
brmsprior &lt;- c(prior(normal(0.2, 0.5), class = mu_raw),
              prior(normal(0, 0.25), class = ar1, lb = -1, ub = 1),
              prior(normal(0, 0.25), class = ar2, lb = -1, ub = 1))
brmsprior

mod &lt;- mvgam(y ~ s(series, bs = 're') +
             s(season, bs = 'cc') - 1,
           family = nb(),
           data = dat$data_train,
           trend_model = AR(p = 2),
           priors = brmsprior,
           run_model = FALSE)
stancode(mod)

# Look at what is returned when an incorrect spelling is used
test_priors$prior[5] &lt;- 'ar2_bananas ~ normal(0, 0.25);'
mod &lt;- mvgam(y ~ s(series, bs = 're') +
             s(season, bs = 'cc') - 1,
            family = nb(),
            data = dat$data_train,
            trend_model = AR(p = 2),
            priors = test_priors,
            run_model = FALSE)
stancode(mod)

# Example of changing parametric (fixed effect) priors
simdat &lt;- sim_mvgam()

# Add a fake covariate
simdat$data_train$cov &lt;- rnorm(NROW(simdat$data_train))

priors &lt;- get_mvgam_priors(y ~ cov + s(season),
                          data = simdat$data_train,
                          family = poisson(),
                          trend_model = AR())

# Change priors for the intercept and fake covariate effects
priors$prior[1] &lt;- '(Intercept) ~ normal(0, 1);'
priors$prior[2] &lt;- 'cov ~ normal(0, 0.1);'

mod2 &lt;- mvgam(y ~ cov + s(season),
             data = simdat$data_train,
             trend_model = AR(),
             family = poisson(),
             priors = priors,
             run_model = FALSE)
stancode(mod2)

# Likewise using 'brms' utilities (note that you can use
# Intercept rather than `(Intercept)`) to change priors on the intercept
brmsprior &lt;- c(prior(normal(0.2, 0.5), class = cov),
              prior(normal(0, 0.25), class = Intercept))
brmsprior

mod2 &lt;- mvgam(y ~ cov + s(season),
             data = simdat$data_train,
             trend_model = AR(),
             family = poisson(),
             priors = brmsprior,
             run_model = FALSE)
stancode(mod2)

# The "class = 'b'" shortcut can be used to put the same prior on all
# 'fixed' effect coefficients (apart from any intercepts)
set.seed(0)
dat &lt;- mgcv::gamSim(1, n = 200, scale = 2)
dat$time &lt;- 1:NROW(dat)
mod &lt;- mvgam(y ~ x0 + x1 + s(x2) + s(x3),
            priors = prior(normal(0, 0.75), class = 'b'),
            data = dat,
            family = gaussian(),
            run_model = FALSE)
stancode(mod)

</code></pre>

<hr>
<h2 id='GP'>Specify dynamic Gaussian process trends in <span class="pkg">mvgam</span> models</h2><span id='topic+GP'></span>

<h3>Description</h3>

<p>Set up low-rank approximate Gaussian Process trend models using Hilbert
basis expansions in <span class="pkg">mvgam</span>. This function does not evaluate its arguments –
it exists purely to help set up a model with particular GP
trend models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>GP(...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="GP_+3A_...">...</code></td>
<td>
<p>unused</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A GP trend is estimated for each series using Hilbert space
approximate Gaussian Processes.
In <code>mvgam</code>, latent squared exponential GP trends are approximated using by
default <code>20</code> basis functions and using a multiplicative factor of <code>c = 5/4</code>,
which saves computational costs compared to fitting full GPs while adequately estimating
GP <code>alpha</code> and <code>rho</code> parameters.
</p>


<h3>Value</h3>

<p>An object of class <code>mvgam_trend</code>, which contains a list of
arguments to be interpreted by the parsing functions in <span class="pkg">mvgam</span>
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>References</h3>

<p>Riutort-Mayol G, Burkner PC, Andersen MR, Solin A and Vehtari A (2023).
Practical Hilbert space approximate Bayesian Gaussian processes for probabilistic
programming. Statistics and Computing 33, 1. https://doi.org/10.1007/s11222-022-10167-2
</p>


<h3>See Also</h3>

<p><code><a href="brms.html#topic+gp">gp</a></code>
</p>

<hr>
<h2 id='gratia_mvgam_enhancements'>Enhance post-processing of <span class="pkg">mvgam</span> models using <span class="pkg">gratia</span> functionality</h2><span id='topic+gratia_mvgam_enhancements'></span><span id='topic+drawDotmvgam'></span><span id='topic+draw.mvgam'></span><span id='topic+eval_smoothDothilbertDotsmooth'></span><span id='topic+eval_smooth.hilbert.smooth'></span><span id='topic+eval_smoothDotmodDotsmooth'></span><span id='topic+eval_smooth.mod.smooth'></span><span id='topic+eval_smoothDotmoiDotsmooth'></span><span id='topic+eval_smooth.moi.smooth'></span>

<h3>Description</h3>

<p>These evaluation and plotting functions exist to allow some popular <code>gratia</code>
methods to work with <code>mvgam</code> or <code>jsdgam</code> models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>drawDotmvgam(
  object,
  trend_effects = FALSE,
  data = NULL,
  select = NULL,
  parametric = FALSE,
  terms = NULL,
  residuals = FALSE,
  scales = c("free", "fixed"),
  ci_level = 0.95,
  n = 100,
  n_3d = 16,
  n_4d = 4,
  unconditional = FALSE,
  overall_uncertainty = TRUE,
  constant = NULL,
  fun = NULL,
  dist = 0.1,
  rug = TRUE,
  contour = TRUE,
  grouped_by = FALSE,
  ci_alpha = 0.2,
  ci_col = "black",
  smooth_col = "black",
  resid_col = "steelblue3",
  contour_col = "black",
  n_contour = NULL,
  partial_match = FALSE,
  discrete_colour = NULL,
  discrete_fill = NULL,
  continuous_colour = NULL,
  continuous_fill = NULL,
  position = "identity",
  angle = NULL,
  ncol = NULL,
  nrow = NULL,
  guides = "keep",
  widths = NULL,
  heights = NULL,
  crs = NULL,
  default_crs = NULL,
  lims_method = "cross",
  wrap = TRUE,
  envir = environment(formula(object)),
  ...
)

eval_smoothDothilbertDotsmooth(
  smooth,
  model,
  n = 100,
  n_3d = NULL,
  n_4d = NULL,
  data = NULL,
  unconditional = FALSE,
  overall_uncertainty = TRUE,
  dist = NULL,
  ...
)

eval_smoothDotmodDotsmooth(
  smooth,
  model,
  n = 100,
  n_3d = NULL,
  n_4d = NULL,
  data = NULL,
  unconditional = FALSE,
  overall_uncertainty = TRUE,
  dist = NULL,
  ...
)

eval_smoothDotmoiDotsmooth(
  smooth,
  model,
  n = 100,
  n_3d = NULL,
  n_4d = NULL,
  data = NULL,
  unconditional = FALSE,
  overall_uncertainty = TRUE,
  dist = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="gratia_mvgam_enhancements_+3A_object">object</code></td>
<td>
<p>a fitted mvgam, the result of a call to <code><a href="#topic+mvgam">mvgam()</a></code>.</p>
</td></tr>
<tr><td><code id="gratia_mvgam_enhancements_+3A_trend_effects">trend_effects</code></td>
<td>
<p>logical specifying whether smooth terms from the <code>trend_formula</code> should
be drawn. If <code>FALSE</code>, only terms from the observation formula are drawn. If <code>TRUE</code>, only
terms from the <code>trend_formula</code> are drawn.</p>
</td></tr>
<tr><td><code id="gratia_mvgam_enhancements_+3A_data">data</code></td>
<td>
<p>a data frame of covariate values at which to evaluate the
model's smooth functions.</p>
</td></tr>
<tr><td><code id="gratia_mvgam_enhancements_+3A_select">select</code></td>
<td>
<p>character, logical, or numeric; which smooths to plot. If
<code>NULL</code>, the default, then all model smooths are drawn.
Character <code>select</code> matches the labels for smooths
as shown for example in the output from <code>summary(object)</code>. Logical
<code>select</code> operates as per numeric <code>select</code> in the order that smooths are
stored.</p>
</td></tr>
<tr><td><code id="gratia_mvgam_enhancements_+3A_parametric">parametric</code></td>
<td>
<p>logical; plot parametric terms also? Note that <code>select</code> is
used for selecting which smooths to plot. The <code>terms</code> argument is used to
select which parametric effects are plotted. The default, as with
<code><a href="mgcv.html#topic+plot.gam">mgcv::plot.gam()</a></code>, is to not draw parametric effects.</p>
</td></tr>
<tr><td><code id="gratia_mvgam_enhancements_+3A_terms">terms</code></td>
<td>
<p>character; which model parametric terms should be drawn? The
Default of <code>NULL</code> will plot all parametric terms that can be drawn.</p>
</td></tr>
<tr><td><code id="gratia_mvgam_enhancements_+3A_residuals">residuals</code></td>
<td>
<p>currently ignored for <code>mvgam</code> models.</p>
</td></tr>
<tr><td><code id="gratia_mvgam_enhancements_+3A_scales">scales</code></td>
<td>
<p>character; should all univariate smooths be plotted with the
same y-axis scale? If <code>scales = "free"</code>, the default, each univariate
smooth has its own y-axis scale. If <code>scales = "fixed"</code>, a common y axis
scale is used for all univariate smooths.
</p>
<p>Currently does not affect the y-axis scale of plots of the parametric
terms.</p>
</td></tr>
<tr><td><code id="gratia_mvgam_enhancements_+3A_ci_level">ci_level</code></td>
<td>
<p>numeric between 0 and 1; the coverage of credible interval.</p>
</td></tr>
<tr><td><code id="gratia_mvgam_enhancements_+3A_n">n</code></td>
<td>
<p>numeric; the number of points over the range of the covariate at
which to evaluate the smooth.</p>
</td></tr>
<tr><td><code id="gratia_mvgam_enhancements_+3A_n_3d">n_3d</code>, <code id="gratia_mvgam_enhancements_+3A_n_4d">n_4d</code></td>
<td>
<p>numeric; the number of points over the range of last
covariate in a 3D or 4D smooth. The default is <code>NULL</code> which achieves the
standard behaviour of using <code>n</code> points over the range of all covariate,
resulting in <code>n^d</code> evaluation points, where <code>d</code> is the dimension of the
smooth. For <code>d &gt; 2</code> this can result in very many evaluation points and slow
performance. For smooths of <code>d &gt; 4</code>, the value of <code>n_4d</code> will be used for
all dimensions <code style="white-space: pre;">&#8288;&gt; 4&#8288;</code>, unless this is <code>NULL</code>, in which case the default
behaviour (using <code>n</code> for all dimensions) will be observed.</p>
</td></tr>
<tr><td><code id="gratia_mvgam_enhancements_+3A_unconditional">unconditional</code></td>
<td>
<p>ignored for <code>mvgam</code> models as all appropriate
uncertainties are already included in the posterior estimates.</p>
</td></tr>
<tr><td><code id="gratia_mvgam_enhancements_+3A_overall_uncertainty">overall_uncertainty</code></td>
<td>
<p>ignored for <code>mvgam</code> models as all appropriate
uncertainties are already included in the posterior estimates.</p>
</td></tr>
<tr><td><code id="gratia_mvgam_enhancements_+3A_constant">constant</code></td>
<td>
<p>numeric; a constant to add to the estimated values of the
smooth. <code>constant</code>, if supplied, will be added to the estimated value
before the confidence band is computed.</p>
</td></tr>
<tr><td><code id="gratia_mvgam_enhancements_+3A_fun">fun</code></td>
<td>
<p>function; a function that will be applied to the estimated values
and confidence interval before plotting. Can be a function or the name of a
function. Function <code>fun</code> will be applied after adding any <code>constant</code>, if
provided.</p>
</td></tr>
<tr><td><code id="gratia_mvgam_enhancements_+3A_dist">dist</code></td>
<td>
<p>numeric; if greater than 0, this is used to determine when
a location is too far from data to be plotted when plotting 2-D smooths.
The data are scaled into the unit square before deciding what to exclude,
and <code>dist</code> is a distance within the unit square. See
<code><a href="mgcv.html#topic+exclude.too.far">mgcv::exclude.too.far()</a></code> for further details.</p>
</td></tr>
<tr><td><code id="gratia_mvgam_enhancements_+3A_rug">rug</code></td>
<td>
<p>logical; draw a rug plot at the bottom of each plot for 1-D
smooths or plot locations of data for higher dimensions.</p>
</td></tr>
<tr><td><code id="gratia_mvgam_enhancements_+3A_contour">contour</code></td>
<td>
<p>logical; should contours be draw on the plot using
<code><a href="ggplot2.html#topic+geom_contour">ggplot2::geom_contour()</a></code>.</p>
</td></tr>
<tr><td><code id="gratia_mvgam_enhancements_+3A_grouped_by">grouped_by</code></td>
<td>
<p>logical; should factor by smooths be drawn as one panel
per level of the factor (<code>FALSE</code>, the default), or should the individual
smooths be combined into a single panel containing all levels (<code>TRUE</code>)?</p>
</td></tr>
<tr><td><code id="gratia_mvgam_enhancements_+3A_ci_alpha">ci_alpha</code></td>
<td>
<p>numeric; alpha transparency for confidence or simultaneous
interval.</p>
</td></tr>
<tr><td><code id="gratia_mvgam_enhancements_+3A_ci_col">ci_col</code></td>
<td>
<p>colour specification for the confidence/credible intervals
band. Affects the fill of the interval.</p>
</td></tr>
<tr><td><code id="gratia_mvgam_enhancements_+3A_smooth_col">smooth_col</code></td>
<td>
<p>colour specification for the smooth line.</p>
</td></tr>
<tr><td><code id="gratia_mvgam_enhancements_+3A_resid_col">resid_col</code></td>
<td>
<p>colour specification for residual points. Ignored.</p>
</td></tr>
<tr><td><code id="gratia_mvgam_enhancements_+3A_contour_col">contour_col</code></td>
<td>
<p>colour specification for contour lines.</p>
</td></tr>
<tr><td><code id="gratia_mvgam_enhancements_+3A_n_contour">n_contour</code></td>
<td>
<p>numeric; the number of contour bins. Will result in
<code>n_contour - 1</code> contour lines being drawn. See <code><a href="ggplot2.html#topic+geom_contour">ggplot2::geom_contour()</a></code>.</p>
</td></tr>
<tr><td><code id="gratia_mvgam_enhancements_+3A_partial_match">partial_match</code></td>
<td>
<p>logical; should smooths be selected by partial matches
with <code>select</code>? If <code>TRUE</code>, <code>select</code> can only be a single string to match
against.</p>
</td></tr>
<tr><td><code id="gratia_mvgam_enhancements_+3A_discrete_colour">discrete_colour</code></td>
<td>
<p>a suitable colour scale to be used when plotting
discrete variables.</p>
</td></tr>
<tr><td><code id="gratia_mvgam_enhancements_+3A_discrete_fill">discrete_fill</code></td>
<td>
<p>a suitable fill scale to be used when plotting
discrete variables.</p>
</td></tr>
<tr><td><code id="gratia_mvgam_enhancements_+3A_continuous_colour">continuous_colour</code></td>
<td>
<p>a suitable colour scale to be used when plotting
continuous variables.</p>
</td></tr>
<tr><td><code id="gratia_mvgam_enhancements_+3A_continuous_fill">continuous_fill</code></td>
<td>
<p>a suitable fill scale to be used when plotting
continuous variables.</p>
</td></tr>
<tr><td><code id="gratia_mvgam_enhancements_+3A_position">position</code></td>
<td>
<p>Position adjustment, either as a string, or the result of a
call to a position adjustment function.</p>
</td></tr>
<tr><td><code id="gratia_mvgam_enhancements_+3A_angle">angle</code></td>
<td>
<p>numeric; the angle at which the x axis tick labels are to be
drawn passed to the <code>angle</code> argument of <code><a href="ggplot2.html#topic+guide_axis">ggplot2::guide_axis()</a></code>.</p>
</td></tr>
<tr><td><code id="gratia_mvgam_enhancements_+3A_ncol">ncol</code>, <code id="gratia_mvgam_enhancements_+3A_nrow">nrow</code></td>
<td>
<p>numeric; the numbers of rows and columns over which to
spread the plots</p>
</td></tr>
<tr><td><code id="gratia_mvgam_enhancements_+3A_guides">guides</code></td>
<td>
<p>character; one of <code>"keep"</code> (the default), <code>"collect"</code>, or
<code>"auto"</code>. Passed to <code><a href="patchwork.html#topic+plot_layout">patchwork::plot_layout()</a></code></p>
</td></tr>
<tr><td><code id="gratia_mvgam_enhancements_+3A_widths">widths</code>, <code id="gratia_mvgam_enhancements_+3A_heights">heights</code></td>
<td>
<p>The relative widths and heights of each column and
row in the grid. Will get repeated to match the dimensions of the grid. If
there is more than 1 plot and <code>widths = NULL</code>, the value of <code>widths</code> will
be set internally to <code>widths = 1</code> to accommodate plots of smooths that
use a fixed aspect ratio.</p>
</td></tr>
<tr><td><code id="gratia_mvgam_enhancements_+3A_crs">crs</code></td>
<td>
<p>the coordinate reference system (CRS) to use for the plot. All
data will be projected into this CRS. See <code><a href="ggplot2.html#topic+ggsf">ggplot2::coord_sf()</a></code> for
details.</p>
</td></tr>
<tr><td><code id="gratia_mvgam_enhancements_+3A_default_crs">default_crs</code></td>
<td>
<p>the coordinate reference system (CRS) to use for the
non-sf layers in the plot. If left at the default <code>NULL</code>, the CRS used is
4326 (WGS84), which is appropriate for spline-on-the-sphere smooths, which
are parameterized in terms of latitude and longitude as coordinates. See
<code><a href="ggplot2.html#topic+ggsf">ggplot2::coord_sf()</a></code> for more details.</p>
</td></tr>
<tr><td><code id="gratia_mvgam_enhancements_+3A_lims_method">lims_method</code></td>
<td>
<p>character; affects how the axis limits are determined. See
<code><a href="ggplot2.html#topic+ggsf">ggplot2::coord_sf()</a></code>. Be careful; in testing of some examples, changing
this to <code>"orthogonal"</code> for example with the chlorophyll-a example from
Simon Wood's GAM book quickly used up all the RAM in my test system and the
OS killed R. This could be incorrect usage on my part; right now the grid
of points at which SOS smooths are evaluated (if not supplied by the user)
can produce invalid coordinates for the corners of tiles as the grid is
generated for tile centres without respect to the spacing of those tiles.</p>
</td></tr>
<tr><td><code id="gratia_mvgam_enhancements_+3A_wrap">wrap</code></td>
<td>
<p>logical; wrap plots as a patchwork? If <code>FALSE</code>, a list of
ggplot objects is returned, 1 per term plotted.</p>
</td></tr>
<tr><td><code id="gratia_mvgam_enhancements_+3A_envir">envir</code></td>
<td>
<p>an environment to look up the data within.</p>
</td></tr>
<tr><td><code id="gratia_mvgam_enhancements_+3A_...">...</code></td>
<td>
<p>additional arguments passed to other methods.</p>
</td></tr>
<tr><td><code id="gratia_mvgam_enhancements_+3A_smooth">smooth</code></td>
<td>
<p>a smooth object of class <code>"gp.smooth"</code> (returned from a model using either the
<code>dynamic()</code> function or the <code>gp()</code> function) or of class <code>"moi.smooth"</code> or <code>"mod.smooth"</code>
(returned from a model using the 'moi' or 'mod' basis).</p>
</td></tr>
<tr><td><code id="gratia_mvgam_enhancements_+3A_model">model</code></td>
<td>
<p>a fitted <code>mgcv</code> model of clas <code>gam</code> or <code>bam</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These methods allow <code>mvgam</code> models to be <em>Enhanced</em> if users have the <code>gratia</code>
package installed, making available the popular <code>draw()</code> function to plot partial effects
of <code>mvgam</code> smooth functions using <code><a href="ggplot2.html#topic+ggplot">ggplot2::ggplot()</a></code> utilities
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Fit a simple GAM and draw partial effects of smooths using gratia
set.seed(0)
dat &lt;- mgcv::gamSim(1, n = 200, scale = 2)
mod &lt;- mvgam(y ~ s(x1, bs = 'moi') +
              te(x0, x2),
             data = dat,
             family = gaussian(),
             chains = 2,
             silent = 2)

if(require("gratia")){
 gratia::draw(mod)
}


</code></pre>

<hr>
<h2 id='hindcast.mvgam'>Extract hindcasts for a fitted <code>mvgam</code> object</h2><span id='topic+hindcast.mvgam'></span><span id='topic+hindcast'></span>

<h3>Description</h3>

<p>Extract hindcasts for a fitted <code>mvgam</code> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>hindcast(object, ...)

## S3 method for class 'mvgam'
hindcast(object, type = "response", ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="hindcast.mvgam_+3A_object">object</code></td>
<td>
<p><code>list</code> object of class <code>mvgam</code> or <code>jsdgam</code>. See <code><a href="#topic+mvgam">mvgam()</a></code></p>
</td></tr>
<tr><td><code id="hindcast.mvgam_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="hindcast.mvgam_+3A_type">type</code></td>
<td>
<p>When this has the value <code>link</code> (default) the linear predictor is
calculated on the link scale.
If <code>expected</code> is used, predictions reflect the expectation of the response (the mean)
but ignore uncertainty in the observation process. When <code>response</code> is used,
the predictions take uncertainty in the observation process into account to return
predictions on the outcome scale. When <code>variance</code> is used, the variance of the response
with respect to the mean (mean-variance relationship) is returned.
When <code>type = "terms"</code>, each component of the linear predictor is
returned separately in the form of a <code>list</code> (possibly with standard
errors, if <code>summary = TRUE</code>): this includes parametric model components,
followed by each smooth component, but excludes any offset and any intercept.
Two special cases are also allowed:
type <code>latent_N</code> will return the estimated latent abundances from an
N-mixture distribution, while type <code>detection</code> will return the estimated
detection probability from an N-mixture distribution</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Posterior retrodictions are drawn from the fitted <code>mvgam</code> and
organized into a convenient format
</p>


<h3>Value</h3>

<p>An object of class <code>mvgam_forecast</code> containing hindcast distributions.
See <code><a href="#topic+mvgam_forecast-class">mvgam_forecast-class</a></code> for details.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+forecast.mvgam">forecast.mvgam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
simdat &lt;- sim_mvgam(n_series = 3, trend_model = AR())
mod &lt;- mvgam(y ~ s(season, bs = 'cc'),
             trend_model = AR(),
             noncentred = TRUE,
             data = simdat$data_train,
             chains = 2,
             silent = 2)

# Hindcasts on response scale
hc &lt;- hindcast(mod)
str(hc)
plot(hc, series = 1)
plot(hc, series = 2)
plot(hc, series = 3)

# Hindcasts as expectations
hc &lt;- hindcast(mod, type = 'expected')
str(hc)
plot(hc, series = 1)
plot(hc, series = 2)
plot(hc, series = 3)

# Estimated latent trends
hc &lt;- hindcast(mod, type = 'trend')
str(hc)
plot(hc, series = 1)
plot(hc, series = 2)
plot(hc, series = 3)

</code></pre>

<hr>
<h2 id='how_to_cite.mvgam'>Generate a methods description for <span class="pkg">mvgam</span> models</h2><span id='topic+how_to_cite.mvgam'></span><span id='topic+how_to_cite'></span>

<h3>Description</h3>

<p>Create a brief but fully referenced methods description, along with a useful list of references,
for fitted <code>mvgam</code> and <code>jsdgam</code> models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>how_to_cite(object, ...)

## S3 method for class 'mvgam'
how_to_cite(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="how_to_cite.mvgam_+3A_object">object</code></td>
<td>
<p><code>list</code> object of class <code>mvgam</code> resulting from a call to <code><a href="#topic+mvgam">mvgam()</a></code>
or <code><a href="#topic+jsdgam">jsdgam()</a></code></p>
</td></tr>
<tr><td><code id="how_to_cite.mvgam_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function uses the model's structure to come up with a very basic
but hopefully useful methods description that can help users to appropriately acknowledge
the hard work of developers and champion open science. Please do not consider the
text returned by this function to be a completely adequate methods section, it is only
meant to get you started.
</p>


<h3>Value</h3>

<p>An object of class <code>how_to_cite</code> containing a text description of the
methods as well as lists of both primary and additional references
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>See Also</h3>

<p><code><a href="utils.html#topic+citation">citation</a></code>, <code><a href="#topic+mvgam">mvgam</a></code>, <code><a href="#topic+jsdgam">jsdgam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate 4 time series with hierarchical seasonality
# and a VAR(1) dynamic process
set.seed(0)
simdat &lt;- sim_mvgam(seasonality = 'hierarchical',
                    trend_model = VAR(cor = TRUE),
                    family = gaussian())

# Fit an appropriate model
mod1 &lt;- mvgam(y ~ s(season, bs = 'cc', k = 6),
              data = simdat$data_train,
              family = gaussian(),
              trend_model = VAR(cor = TRUE),
              chains = 2,
              silent = 2)
how_to_cite(mod1)

# For a GP example, simulate data using the mgcv package
dat &lt;- mgcv::gamSim(1, n = 30, scale = 2)

# Fit a model that uses an approximate GP from the brms package
mod2 &lt;- mvgam(y ~ gp(x2, k = 12),
              data = dat,
              family = gaussian(),
              chains = 2,
              silent = 2)
how_to_cite(mod2)

</code></pre>

<hr>
<h2 id='index-mvgam'>Index <code>mvgam</code> objects</h2><span id='topic+index-mvgam'></span><span id='topic+variables'></span><span id='topic+Index'></span><span id='topic+and'></span><span id='topic+their'></span><span id='topic++60mgcv+60'></span><span id='topic+coefficient'></span><span id='topic+names'></span><span id='topic+variables.mvgam'></span>

<h3>Description</h3>

<p>Index <code>mvgam</code> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
variables(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="index-mvgam_+3A_x">x</code></td>
<td>
<p><code>list</code> object returned from <code>mvgam</code>. See <code><a href="#topic+mvgam">mvgam()</a></code></p>
</td></tr>
<tr><td><code id="index-mvgam_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods (if applicable).</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list</code> object of the variables that can be extracted, along
with their aliases
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
simdat &lt;- sim_mvgam(n_series = 1, trend_model = 'AR1')
mod &lt;- mvgam(y ~ s(season, bs = 'cc', k = 6),
             trend_model = AR(),
             data = simdat$data_train,
            chains = 2,
            silent = 2)
variables(mod)

</code></pre>

<hr>
<h2 id='irf.mvgam'>Calculate latent VAR impulse response functions</h2><span id='topic+irf.mvgam'></span><span id='topic+irf'></span>

<h3>Description</h3>

<p>Compute Generalized or Orthogonalized Impulse Response Functions (IRFs) from
<code>mvgam</code> models with Vector Autoregressive dynamics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>irf(object, ...)

## S3 method for class 'mvgam'
irf(object, h = 10, cumulative = FALSE, orthogonal = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="irf.mvgam_+3A_object">object</code></td>
<td>
<p><code>list</code> object of class <code>mvgam</code> resulting from a call to <code><a href="#topic+mvgam">mvgam()</a></code>
that used a Vector Autoregressive latent process model (either as <code>VAR(cor = FALSE)</code> or
<code>VAR(cor = TRUE)</code>)</p>
</td></tr>
<tr><td><code id="irf.mvgam_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="irf.mvgam_+3A_h">h</code></td>
<td>
<p>Positive <code>integer</code> specifying the forecast horizon over which to calculate
the IRF</p>
</td></tr>
<tr><td><code id="irf.mvgam_+3A_cumulative">cumulative</code></td>
<td>
<p><code>Logical</code> flag indicating whether the IRF should be cumulative</p>
</td></tr>
<tr><td><code id="irf.mvgam_+3A_orthogonal">orthogonal</code></td>
<td>
<p><code>Logical</code> flag indicating whether orthogonalized IRFs should be
calculated. Note that the order of the variables matters when calculating these</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Generalized or Orthogonalized Impulse Response Functions can be computed
using the posterior estimates of Vector Autoregressive parameters. This function
generates a positive &quot;shock&quot; for a target process at time <code>t = 0</code> and then
calculates how  each of the remaining processes in the latent VAR are expected
to respond over the forecast horizon <code>h</code>. The function computes IRFs for all
processes in the object and returns them in an array that can be plotted using
the S3 <code>plot</code> function. To inspect community-level metrics of stability using latent
VAR processes, you can use the related <code><a href="#topic+stability">stability</a></code> function.
</p>


<h3>Value</h3>

<p>An object of class <code>mvgam_irf</code> containing the posterior IRFs. This
object can be used with the supplied S3 functions <code>plot</code>
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>References</h3>

<p>PH Pesaran &amp; Shin Yongcheol (1998).
Generalized impulse response analysis in linear multivariate models.
Economics Letters 58: 17–29.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VAR">VAR</a></code>, <code><a href="#topic+plot.mvgam_irf">plot.mvgam_irf</a></code>, <code><a href="#topic+stability">stability</a></code>,
<code><a href="#topic+fevd">fevd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate some time series that follow a latent VAR(1) process
simdat &lt;- sim_mvgam(
  family = gaussian(),
  n_series = 4,
  trend_model = VAR(cor = TRUE),
  prop_trend = 1
)
plot_mvgam_series(data = simdat$data_train, series = "all")

# Fit a model that uses a latent VAR(1)
mod &lt;- mvgam(y ~ -1,
  trend_formula = ~1,
  trend_model = VAR(cor = TRUE),
  family = gaussian(),
  data = simdat$data_train,
  chains = 2,
  silent = 2
)

# Calulate Generalized IRFs for each series
irfs &lt;- irf(mod, h = 12, cumulative = FALSE)

# Plot them
plot(irfs, series = 1)
plot(irfs, series = 2)
plot(irfs, series = 3)

# Calculate posterior median, upper and lower 90th quantiles
# of the impulse responses
summary(irfs)

</code></pre>

<hr>
<h2 id='jsdgam'>Fit Joint Species Distribution Models in <span class="pkg">mvgam</span></h2><span id='topic+jsdgam'></span>

<h3>Description</h3>

<p>This function sets up a Joint Species Distribution Model whereby the residual associations among
species can be modelled in a reduced-rank format using a set of latent factors. The factor
specification is extremely flexible, allowing users to include spatial, temporal or any other type
of predictor effects to more efficiently capture unmodelled residual associations, while the
observation model can also be highly flexible (including all smooth, GP and other effects that
<span class="pkg">mvgam</span> can handle)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>jsdgam(
  formula,
  factor_formula = ~-1,
  knots,
  factor_knots,
  data,
  newdata,
  family = poisson(),
  unit = time,
  species = series,
  share_obs_params = FALSE,
  priors,
  n_lv = 2,
  backend = getOption("brms.backend", "cmdstanr"),
  algorithm = getOption("brms.algorithm", "sampling"),
  control = list(max_treedepth = 10, adapt_delta = 0.8),
  chains = 4,
  burnin = 500,
  samples = 500,
  thin = 1,
  parallel = TRUE,
  threads = 1,
  silent = 1,
  run_model = TRUE,
  return_model_data = FALSE,
  residuals = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="jsdgam_+3A_formula">formula</code></td>
<td>
<p>A <code>formula</code> object specifying the GAM observation model formula. These are exactly like the formula
for a GLM except that smooth terms, <code>s()</code>, <code>te()</code>, <code>ti()</code>, <code>t2()</code>, as well as time-varying
<code>dynamic()</code> terms, nonparametric <code>gp()</code> terms and offsets using <code>offset()</code>, can be added to the right hand side
to specify that the linear predictor depends on smooth functions of predictors
(or linear functionals of these). Details of the formula syntax used by <span class="pkg">mvgam</span>
can be found in <code><a href="#topic+mvgam_formulae">mvgam_formulae</a></code></p>
</td></tr>
<tr><td><code id="jsdgam_+3A_factor_formula">factor_formula</code></td>
<td>
<p>A <code>formula</code> object specifying the linear predictor
effects for the latent factors. Use <code>by = trend</code> within calls to functional terms
(i.e. <code>s()</code>, <code>te()</code>, <code>ti()</code>, <code>t2()</code>, <code>dynamic()</code>, or <code>gp()</code>) to ensure that each factor
captures a different axis of variation. See the example below as an illustration</p>
</td></tr>
<tr><td><code id="jsdgam_+3A_knots">knots</code></td>
<td>
<p>An optional <code>list</code> containing user specified knot values to
be used for basis construction.
For most bases the user simply supplies the knots to be used, which must match
up with the <code>k</code> value supplied
(note that the number of knots is not always just <code>k</code>). Different terms can
use different numbers of knots,
unless they share a covariate</p>
</td></tr>
<tr><td><code id="jsdgam_+3A_factor_knots">factor_knots</code></td>
<td>
<p>An optional <code>list</code> containing user specified knot values to
be used for basis construction of any smooth terms in <code>factor_formula</code>.
For most bases the user simply supplies the knots to be used, which must match up with the <code>k</code> value supplied
(note that the number of knots is not always just <code>k</code>). Different terms can use different numbers of knots,
unless they share a covariate</p>
</td></tr>
<tr><td><code id="jsdgam_+3A_data">data</code></td>
<td>
<p>A <code>dataframe</code> or <code>list</code> containing the model response variable and covariates
required by the GAM <code>formula</code> and <code>factor_formula</code> objects</p>
</td></tr>
<tr><td><code id="jsdgam_+3A_newdata">newdata</code></td>
<td>
<p>Optional <code>dataframe</code> or <code>list</code> of test data containing
the same variables
as in <code>data</code>. If included, the
observations in variable <code>y</code> will be set to <code>NA</code> when fitting the
model so that posterior
simulations can be obtained</p>
</td></tr>
<tr><td><code id="jsdgam_+3A_family">family</code></td>
<td>
<p><code>family</code> specifying the observation family for the outcomes. Currently supported
families are:
</p>

<ul>
<li><p><code>gaussian()</code> for real-valued data
</p>
</li>
<li><p><code>betar()</code> for proportional data on <code style="white-space: pre;">&#8288;(0,1)&#8288;</code>
</p>
</li>
<li><p><code>lognormal()</code> for non-negative real-valued data
</p>
</li>
<li><p><code>student_t()</code> for real-valued data
</p>
</li>
<li><p><code>Gamma()</code> for non-negative real-valued data
</p>
</li>
<li><p><code>bernoulli()</code> for binary data
</p>
</li>
<li><p><code>poisson()</code> for count data
</p>
</li>
<li><p><code>nb()</code> for overdispersed count data
</p>
</li>
<li><p><code>binomial()</code> for count data with imperfect detection when the number of trials is known;
note that the <code>cbind()</code> function must be used to bind the discrete observations and the discrete number
of trials
</p>
</li>
<li><p><code>beta_binomial()</code> as for <code>binomial()</code> but allows for overdispersion</p>
</li></ul>

<p>Default is <code>poisson()</code>. See <code><a href="#topic+mvgam_families">mvgam_families</a></code> for more details</p>
</td></tr>
<tr><td><code id="jsdgam_+3A_unit">unit</code></td>
<td>
<p>The unquoted name of the variable that represents the unit of analysis in <code>data</code> over
which latent residuals should be correlated. This variable should be either a
<code>numeric</code> or <code>integer</code> variable in the supplied <code>data</code>.
Defaults to <code>time</code> to be consistent with other functionalities
in <span class="pkg">mvgam</span>, though note that the data need not be time series in this case. See examples below
for further details and explanations</p>
</td></tr>
<tr><td><code id="jsdgam_+3A_species">species</code></td>
<td>
<p>The unquoted name of the <code>factor</code> variable that indexes
the different response units in <code>data</code> (usually <code>'species'</code> in a JSDM).
Defaults to <code>series</code> to be consistent with other <code>mvgam</code> models</p>
</td></tr>
<tr><td><code id="jsdgam_+3A_share_obs_params">share_obs_params</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code> and the <code>family</code>
has additional family-specific observation parameters (e.g. variance
components in
<code>student_t()</code> or <code>gaussian()</code>, or dispersion parameters in <code>nb()</code> or
<code>betar()</code>), these parameters will be shared across all outcome variables. This is handy
if you have multiple outcomes (time series in most <code>mvgam</code> models) that you
believe share some properties,
such as being from the same species over different spatial units. Default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="jsdgam_+3A_priors">priors</code></td>
<td>
<p>An optional <code>data.frame</code> with prior
definitions (in Stan syntax) or, preferentially, a vector containing
objects of class <code>brmsprior</code> (see. <code><a href="brms.html#topic+prior">prior</a></code> for details).
See <a href="#topic+get_mvgam_priors">get_mvgam_priors</a> and for more information on changing default prior distributions</p>
</td></tr>
<tr><td><code id="jsdgam_+3A_n_lv">n_lv</code></td>
<td>
<p><code>integer</code> the number of latent factors to use for modelling
residual associations.
Cannot be <code style="white-space: pre;">&#8288;&gt; n_species&#8288;</code>. Defaults arbitrarily to <code>2</code></p>
</td></tr>
<tr><td><code id="jsdgam_+3A_backend">backend</code></td>
<td>
<p>Character string naming the package to use as the backend for fitting
the Stan model. Options are &quot;cmdstanr&quot; (the default) or &quot;rstan&quot;. Can be set globally
for the current R session via the <code>"brms.backend"</code> option (see <code><a href="base.html#topic+options">options</a></code>). Details on
the rstan and cmdstanr packages are available at https://mc-stan.org/rstan/ and
https://mc-stan.org/cmdstanr/, respectively</p>
</td></tr>
<tr><td><code id="jsdgam_+3A_algorithm">algorithm</code></td>
<td>
<p>Character string naming the estimation approach to use.
Options are <code>"sampling"</code> for MCMC (the default), <code>"meanfield"</code> for
variational inference with factorized normal distributions,
<code>"fullrank"</code> for variational inference with a multivariate normal
distribution, <code>"laplace"</code> for a Laplace approximation (only available
when using cmdstanr as the backend) or <code>"pathfinder"</code> for the pathfinder
algorithm (only currently available when using cmdstanr as the backend).
Can be set globally for the current <span class="rlang"><b>R</b></span> session via the
<code>"brms.algorithm"</code> option (see <code><a href="base.html#topic+options">options</a></code>). Limited testing
suggests that <code>"meanfield"</code> performs best out of the non-MCMC approximations for
dynamic GAMs, possibly because of the difficulties estimating covariances among the
many spline parameters and latent trend parameters. But rigorous testing has not
been carried out</p>
</td></tr>
<tr><td><code id="jsdgam_+3A_control">control</code></td>
<td>
<p>A named <code>list</code> for controlling the sampler's behaviour. Valid
elements include <code>max_treedepth</code>, <code>adapt_delta</code> and <code>init</code></p>
</td></tr>
<tr><td><code id="jsdgam_+3A_chains">chains</code></td>
<td>
<p><code>integer</code> specifying the number of parallel chains for the model. Ignored
if <code>algorithm %in% c('meanfield', 'fullrank', 'pathfinder', 'laplace')</code></p>
</td></tr>
<tr><td><code id="jsdgam_+3A_burnin">burnin</code></td>
<td>
<p><code>integer</code> specifying the number of warmup iterations of the Markov chain to run
to tune sampling algorithms. Ignored
if <code>algorithm %in% c('meanfield', 'fullrank', 'pathfinder', 'laplace')</code></p>
</td></tr>
<tr><td><code id="jsdgam_+3A_samples">samples</code></td>
<td>
<p><code>integer</code> specifying the number of post-warmup iterations of the Markov chain to run for
sampling the posterior distribution</p>
</td></tr>
<tr><td><code id="jsdgam_+3A_thin">thin</code></td>
<td>
<p>Thinning interval for monitors.  Ignored
if <code>algorithm %in% c('meanfield', 'fullrank', 'pathfinder', 'laplace')</code></p>
</td></tr>
<tr><td><code id="jsdgam_+3A_parallel">parallel</code></td>
<td>
<p><code>logical</code> specifying whether multiple cores should be used for
generating MCMC simulations in parallel. If <code>TRUE</code>, the number of cores to use will be
<code>min(c(chains, parallel::detectCores() - 1))</code></p>
</td></tr>
<tr><td><code id="jsdgam_+3A_threads">threads</code></td>
<td>
<p><code>integer</code> Experimental option to use multithreading for within-chain
parallelisation in <code>Stan</code>. We recommend its use only if you are experienced with
<code>Stan</code>'s <code>reduce_sum</code> function and have a slow running model that cannot be sped
up by any other means. Currently works for all families when using <code>Cmdstan</code>
as the backend</p>
</td></tr>
<tr><td><code id="jsdgam_+3A_silent">silent</code></td>
<td>
<p>Verbosity level between <code>0</code> and <code>2</code>. If <code>1</code> (the default), most
of the informational messages of compiler and sampler are suppressed. If <code>2</code>,
even more messages are suppressed. The actual sampling progress is still printed.
Set <code>refresh = 0</code> to turn this off as well. If using <code>backend = "rstan"</code> you
can also set open_progress = FALSE to prevent opening additional progress bars.</p>
</td></tr>
<tr><td><code id="jsdgam_+3A_run_model">run_model</code></td>
<td>
<p><code>logical</code>. If <code>FALSE</code>, the model is not fitted but
instead the function will
return the model file and the data / initial values that are needed to fit the
model outside of <code>mvgam</code></p>
</td></tr>
<tr><td><code id="jsdgam_+3A_return_model_data">return_model_data</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, the list of data that
is needed to fit the
model is returned, along with the initial values for smooth and AR parameters,
once the model is fitted.
This will be helpful if users wish to modify the model file to add
other stochastic elements that are not currently available in <code>mvgam</code>.
Default is <code>FALSE</code> to reduce
the size of the returned object, unless <code>run_model == FALSE</code></p>
</td></tr>
<tr><td><code id="jsdgam_+3A_residuals">residuals</code></td>
<td>
<p>Logical indicating whether to compute series-level randomized quantile residuals and include
them as part of the returned object. Defaults to <code>TRUE</code>, but you can set to <code>FALSE</code> to save
computational time and reduce the size of the returned object (users can always add residuals to
an object of class <code>mvgam</code> using <a href="#topic+add_residuals">add_residuals</a>)</p>
</td></tr>
<tr><td><code id="jsdgam_+3A_...">...</code></td>
<td>
<p>Other arguments to pass to <a href="#topic+mvgam">mvgam</a></p>
</td></tr>
</table>


<h3>Details</h3>

<p>Joint Species Distribution Models allow for responses of multiple species to be
learned hierarchically, whereby responses to environmental variables in <code>formula</code> can be partially
pooled and any latent, unmodelled residual associations can also be learned. In <span class="pkg">mvgam</span>, both of
these effects can be modelled with the full power of latent factor Hierarchical GAMs, providing unmatched
flexibility to model full communities of species. When calling <a href="#topic+jsdgam">jsdgam</a>, an initial State-Space model using
<code>trend = 'None'</code> is set up and then modified to include the latent factors and their linear predictors.
Consequently, you can inspect priors for these models using <a href="#topic+get_mvgam_priors">get_mvgam_priors</a> by supplying the relevant
<code>formula</code>, <code>factor_formula</code>, <code>data</code> and <code>family</code> arguments and keeping the default <code>trend = 'None'</code>.
</p>
<p>In a JSDGAM, the expectation of response <code class="reqn">Y_{ij}</code> is modelled with
</p>
<p style="text-align: center;"><code class="reqn">g(\mu_{ij}) = X_i\beta + u_i\theta_j,</code>
</p>

<p>where <code class="reqn">g(.)</code> is a known link function,
<code class="reqn">X</code> is a design matrix of linear predictors (with associated <code class="reqn">\beta</code> coefficients),
<code class="reqn">u</code> are <code class="reqn">n_{lv}</code>-variate latent factors
(<code class="reqn">n_{lv}</code>&lt;&lt;<code class="reqn">n_{species}</code>) and
<code class="reqn">\theta_j</code> are species-specific loadings on the latent factors, respectively. The design matrix
<code class="reqn">X</code> and <code class="reqn">\beta</code> coefficients are constructed and modelled using <code>formula</code> and can contain
any of <code>mvgam</code>'s predictor effects, including random intercepts and slopes, multidimensional penalized
smooths, GP effects etc... The factor loadings <code class="reqn">\theta_j</code> are constrained for identifiability but can
be used to reconstruct an estimate of the species' residual variance-covariance matrix
using <code class="reqn">\Theta \Theta'</code> (see the example below and <code><a href="#topic+residual_cor">residual_cor()</a></code> for details).
The latent factors are further modelled using:
</p>
<p style="text-align: center;"><code class="reqn">
u_i \sim \text{Normal}(Q_i\beta_{factor}, 1) \quad
</code>
</p>

<p>where the second design matrix <code class="reqn">Q</code> and associated <code class="reqn">\beta_{factor}</code> coefficients are
constructed and modelled using <code>factor_formula</code>. Again, the effects that make up this linear
predictor can contain any of <code>mvgam</code>'s allowed predictor effects, providing enormous flexibility for
modelling species' communities.
</p>


<h3>Value</h3>

<p>A <code>list</code> object of class <code>mvgam</code> containing model output,
the text representation of the model file,
the mgcv model output (for easily generating simulations at
unsampled covariate values), Dunn-Smyth residuals for each species and key information needed
for other functions in the package. See <code><a href="#topic+mvgam-class">mvgam-class</a></code> for details.
Use <code>methods(class = "mvgam")</code> for an overview on available methods
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>References</h3>

<p>Nicholas J Clark &amp; Konstans Wells (2023). Dynamic generalised additive models (DGAMs) for forecasting discrete ecological time series.
Methods in Ecology and Evolution. 14:3, 771-784.
<br />
<br />
David I Warton, F Guillaume Blanchet, Robert B O’Hara, Otso Ovaskainen, Sara Taskinen, Steven C
Walker &amp; Francis KC Hui (2015). So many variables: joint modeling in community ecology.
Trends in Ecology &amp; Evolution 30:12, 766-779.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvgam">mvgam()</a></code>, <code><a href="#topic+residual_cor">residual_cor()</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate latent count data for 500 spatial locations and 10 species
set.seed(0)
N_points &lt;- 500
N_species &lt;- 10

# Species-level intercepts (on the log scale)
alphas &lt;- runif(N_species, 2, 2.25)

# Simulate a covariate and species-level responses to it
temperature &lt;- rnorm(N_points)
betas &lt;- runif(N_species, -0.5, 0.5)

# Simulate points uniformly over a space
lon &lt;- runif(N_points, min = 150, max = 155)
lat &lt;- runif(N_points, min = -20, max = -19)

# Set up spatial basis functions as a tensor product of lat and lon
sm &lt;- mgcv::smoothCon(mgcv::te(lon, lat, k = 5),
                      data = data.frame(lon, lat),
                      knots = NULL)[[1]]

# The design matrix for this smooth is in the 'X' slot
des_mat &lt;- sm$X
dim(des_mat)

# Function to generate a random covariance matrix where all variables
# have unit variance (i.e. diagonals are all 1)
random_Sigma = function(N){
  L_Omega &lt;- matrix(0, N, N);
  L_Omega[1, 1] &lt;- 1;
  for (i in 2 : N) {
    bound &lt;- 1;
    for (j in 1 : (i - 1)) {
      L_Omega[i, j] &lt;- runif(1, -sqrt(bound), sqrt(bound));
      bound &lt;- bound - L_Omega[i, j] ^ 2;
    }
    L_Omega[i, i] &lt;- sqrt(bound);
  }
  Sigma &lt;- L_Omega %*% t(L_Omega);
  return(Sigma)
}

# Simulate a variance-covariance matrix for the correlations among
# basis coefficients
Sigma &lt;- random_Sigma(N = NCOL(des_mat))

# Now simulate the species-level basis coefficients hierarchically, where
# spatial basis function correlations are a convex sum of a base correlation
# matrix and a species-level correlation matrix
basis_coefs &lt;- matrix(NA, nrow = N_species, ncol = NCOL(Sigma))
base_field &lt;- mgcv::rmvn(1, mu = rep(0, NCOL(Sigma)), V = Sigma)
for(t in 1:N_species){
  corOmega &lt;- (cov2cor(Sigma) * 0.7) +
                 (0.3 * cov2cor(random_Sigma(N = NCOL(des_mat))))
  basis_coefs[t, ] &lt;- mgcv::rmvn(1, mu = rep(0, NCOL(Sigma)), V = corOmega)
}

# Simulate the latent spatial processes
st_process &lt;- do.call(rbind, lapply(seq_len(N_species), function(t){
  data.frame(lat = lat,
             lon = lon,
             species = paste0('species_', t),
             temperature = temperature,
             process = alphas[t] +
               betas[t] * temperature +
               des_mat %*% basis_coefs[t,])
}))

# Now take noisy observations at some of the points (60)
obs_points &lt;- sample(1:N_points, size = 60, replace = FALSE)
obs_points &lt;- data.frame(lat = lat[obs_points],
                         lon = lon[obs_points],
                         site = 1:60)

# Keep only the process data at these points
st_process %&gt;%
  dplyr::inner_join(obs_points, by = c('lat', 'lon')) %&gt;%
  # now take noisy Poisson observations of the process
  dplyr::mutate(count = rpois(NROW(.), lambda = exp(process))) %&gt;%
  dplyr::mutate(species = factor(species,
                                 levels = paste0('species_', 1:N_species))) %&gt;%
  dplyr::group_by(lat, lon) -&gt; dat

# View the count distributions for each species
library(ggplot2); theme_set(theme_bw())
ggplot(dat, aes(x = count)) +
  geom_histogram() +
  facet_wrap(~ species, scales = 'free')

ggplot(dat, aes(x = lon, y = lat, col = log(count + 1))) +
  geom_point(size = 2.25) +
  facet_wrap(~ species, scales = 'free') +
  scale_color_viridis_c()

# Inspect default priors for a joint species model with three spatial factors
priors &lt;- get_mvgam_priors(formula = count ~
                            # Environmental model includes random slopes for
                            # a linear effect of temperature
                            s(species, bs = 're', by = temperature),

                          # Each factor estimates a different nonlinear spatial process, using
                          # 'by = trend' as in other mvgam State-Space models
                          factor_formula = ~ gp(lon, lat, k = 6, by = trend) - 1,
                          n_lv = 3,

                          # The data and grouping variables
                          data = dat,
                          unit = site,
                          species = species,

                          # Poisson observations
                          family = poisson())
head(priors)

# Fit a JSDM that estimates hierarchical temperature responses
# and that uses three latent spatial factors
mod &lt;- jsdgam(formula = count ~
                # Environmental model includes random slopes for a
                # linear effect of temperature
                s(species, bs = 're', by = temperature),

              # Each factor estimates a different nonlinear spatial process, using
              # 'by = trend' as in other mvgam State-Space models
              factor_formula = ~ gp(lon, lat, k = 6, by = trend) - 1,
              n_lv = 3,

              # Change default priors for fixed random effect variances and
              # factor P marginal deviations to standard normal
              priors = c(prior(std_normal(),
                               class = sigma_raw),
                         prior(std_normal(),
                               class = `alpha_gp_trend(lon, lat):trendtrend1`),
                         prior(std_normal(),
                               class = `alpha_gp_trend(lon, lat):trendtrend2`),
                         prior(std_normal(),
                               class = `alpha_gp_trend(lon, lat):trendtrend3`)),

              # The data and the grouping variables
              data = dat,
              unit = site,
              species = species,

              # Poisson observations
              family = poisson(),
              chains = 2,
              silent = 2)

# Plot species-level intercept estimates
plot_predictions(mod, condition = 'species',
                 type = 'link')

# Plot species' hierarchical responses to temperature
plot_predictions(mod, condition = c('temperature', 'species', 'species'),
                 type = 'link')

# Plot posterior median estimates of the latent spatial factors
plot(mod, type = 'smooths', trend_effects = TRUE)

# Or using gratia, if you have it installed
if(requireNamespace('gratia', quietly = TRUE)){
  gratia::draw(mod, trend_effects = TRUE, dist = 0)
}

# Plot species' randomized quantile residual distributions
# as a function of latitude
pp_check(mod,
         type = 'resid_ribbon_grouped',
         group = 'species',
         x = 'lat',
         ndraws = 200)

# Calculate residual spatial correlations
post_cors &lt;- residual_cor(mod)
names(post_cors)
# Look at lower and upper credible interval estimates for
# some of the estimated correlations
post_cors$cor[1:5, 1:5]
post_cors$cor_upper[1:5, 1:5]
post_cors$cor_lower[1:5, 1:5]
# Plot of the posterior median correlations for those estimated
# to be non-zero
plot(post_cors)

# Posterior predictive checks and ELPD-LOO can ascertain model fit
pp_check(mod,
         type = "pit_ecdf_grouped",
         group = "species",
         ndraws = 200)
loo(mod)

# Forecast log(counts) for entire region (site value doesn't matter as long
# as each spatial location has a different and unique site identifier);
# note this calculation takes a few minutes because of the need to calculate
# draws from the stochastic latent factors
newdata &lt;- st_process %&gt;%
                   dplyr::mutate(species = factor(species,
                                                  levels = paste0('species_',
                                                                  1:N_species))) %&gt;%
                   dplyr::group_by(lat, lon) %&gt;%
                   dplyr::mutate(site = dplyr::cur_group_id()) %&gt;%
                   dplyr::ungroup()
preds &lt;- predict(mod, newdata = newdata)

# Plot the median log(count) predictions on a grid
newdata$log_count &lt;- preds[,1]
ggplot(newdata, aes(x = lon, y = lat, col = log_count)) +
  geom_point(size = 1.5) +
  facet_wrap(~ species, scales = 'free') +
  scale_color_viridis_c() +
  theme_classic()

</code></pre>

<hr>
<h2 id='lfo_cv.mvgam'>Approximate leave-future-out cross-validation of fitted <span class="pkg">mvgam</span> objects</h2><span id='topic+lfo_cv.mvgam'></span><span id='topic+lfo_cv'></span>

<h3>Description</h3>

<p>Approximate leave-future-out cross-validation of fitted <span class="pkg">mvgam</span> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lfo_cv(object, ...)

## S3 method for class 'mvgam'
lfo_cv(
  object,
  data,
  min_t,
  fc_horizon = 1,
  pareto_k_threshold = 0.7,
  silent = 1,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lfo_cv.mvgam_+3A_object">object</code></td>
<td>
<p><code>list</code> object of class <code>mvgam</code>. See <code><a href="#topic+mvgam">mvgam()</a></code></p>
</td></tr>
<tr><td><code id="lfo_cv.mvgam_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="lfo_cv.mvgam_+3A_data">data</code></td>
<td>
<p>A <code>dataframe</code> or <code>list</code> containing the model response variable and covariates
required by the GAM <code>formula</code>. Should include columns:
'series' (character or factor index of the series IDs)
'time' (numeric index of the time point for each observation).
Any other variables to be included in the linear predictor of <code>formula</code> must also be present</p>
</td></tr>
<tr><td><code id="lfo_cv.mvgam_+3A_min_t">min_t</code></td>
<td>
<p>Integer specifying the minimum training time required before making predictions
from the data. Default is either the <code>30</code>th timepoint in the observational data,
or whatever training time allows for at least
<code>10</code> lfo-cv calculations, if possible.
This value is essentially arbitrary so it is highly recommended to change it
to something that is more suitable to the
data and models being evaluated.</p>
</td></tr>
<tr><td><code id="lfo_cv.mvgam_+3A_fc_horizon">fc_horizon</code></td>
<td>
<p>Integer specifying the number of time steps ahead for evaluating forecasts</p>
</td></tr>
<tr><td><code id="lfo_cv.mvgam_+3A_pareto_k_threshold">pareto_k_threshold</code></td>
<td>
<p>Proportion specifying the threshold over which the Pareto shape parameter
is considered unstable, triggering a model refit. Default is <code>0.7</code></p>
</td></tr>
<tr><td><code id="lfo_cv.mvgam_+3A_silent">silent</code></td>
<td>
<p>Verbosity level between <code>0</code> and <code>2</code>. If <code>1</code> (the default), most of the informational
messages of compiler and sampler are suppressed. If <code>2</code>, even more messages are suppressed. The
actual sampling progress is still printed. Set <code>refresh = 0</code> to turn this off as well. If using
<code>backend = "rstan"</code> you can also set open_progress = FALSE to prevent opening additional
progress bars.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Approximate leave-future-out cross-validation uses an expanding training window scheme
to evaluate a model on its forecasting ability. The steps used in this function mirror those laid out
in the <a href="https://mc-stan.org/loo/articles/loo2-lfo.html">lfo vignette from the <code>loo</code> package</a>,
written by Paul Bürkner, Jonah Gabry, Aki Vehtari. First, we refit the model using the first <code>min_t</code>
observations to perform a single exact <code>fc_horizon</code>-ahead forecast step. This forecast is evaluated against
the <code>min_t + fc_horizon</code> out of sample observations using the Expected Log Predictive Density (ELPD).
Next, we approximate each successive round of
expanding window forecasts by moving forward one step at a time <code style="white-space: pre;">&#8288;for i in 1:N_evaluations&#8288;</code> and re-weighting
draws from the model's posterior predictive distribution using Pareto Smoothed
Importance Sampling (PSIS). In each iteration <code>i</code>, PSIS weights are obtained for the next observation
that would have been included in the model if we had re-fit (i.e. the last observation that would have
been in the training data, or <code>min_t + i</code>). If these importance ratios are stable, we consider the
approximation adequate and use the re-weighted posterior's forecast for evaluating the next holdout
set of testing observations (<code>(min_t + i + 1):(min_t + i + fc_horizon)</code>). At some point the
importance ratio variability will become too large and importance sampling will fail. This is
indicated by the estimated shape parameter <code>k</code> of the generalized Pareto distribution
crossing a certain threshold <code>pareto_k_threshold</code>. Only then do we refit the model using
all of the observations up to the time of the failure. We then restart the process and iterate forward
until the next refit is triggered (Bürkner et al. 2020).
</p>


<h3>Value</h3>

<p>A <code>list</code> of class <code>mvgam_lfo</code> containing the approximate ELPD scores,
the Pareto-k shape values and 'the specified <code>pareto_k_threshold</code>
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>References</h3>

<p>Paul-Christian Bürkner, Jonah Gabry &amp; Aki Vehtari (2020). Approximate leave-future-out cross-validation for Bayesian time series models
Journal of Statistical Computation and Simulation. 90:14, 2499-2523.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+forecast">forecast</a></code>, <code><a href="#topic+score">score</a></code>, <code><a href="#topic+compare_mvgams">compare_mvgams</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate from a Poisson-AR2 model with a seasonal smooth
set.seed(100)
dat &lt;- sim_mvgam(T = 75,
                n_series = 1,
                prop_trend = 0.75,
                trend_model = 'AR2',
                family = poisson())

# Plot the time series
plot_mvgam_series(data = dat$data_train,
                 newdata = dat$data_test,
                 series = 1)

# Fit an appropriate model
mod_ar2 &lt;- mvgam(y ~ s(season, bs = 'cc', k = 6),
               trend_model = AR(p = 2),
               family = poisson(),
               data = dat$data_train,
               newdata = dat$data_test,
               chains = 2,
               silent = 2)

# Fit a less appropriate model
mod_rw &lt;- mvgam(y ~ s(season, bs = 'cc', k = 6),
              trend_model = RW(),
              family = poisson(),
              data = dat$data_train,
              newdata = dat$data_test,
              chains = 2,
              silent = 2)

# Compare Discrete Ranked Probability Scores for the testing period
fc_ar2 &lt;- forecast(mod_ar2)
fc_rw &lt;- forecast(mod_rw)
score_ar2 &lt;- score(fc_ar2, score = 'drps')
score_rw &lt;- score(fc_rw, score = 'drps')
sum(score_ar2$series_1$score)
sum(score_rw$series_1$score)

# Now use approximate leave-future-out CV to compare
# rolling forecasts; start at time point 40 to reduce
# computational time and to ensure enough data is available
# for estimating model parameters
lfo_ar2 &lt;- lfo_cv(mod_ar2,
                 min_t = 40,
                 fc_horizon = 3,
                 silent = 2)
lfo_rw &lt;- lfo_cv(mod_rw,
                min_t = 40,
                fc_horizon = 3,
                silent = 2)

# Plot Pareto-K values and ELPD estimates
plot(lfo_ar2)
plot(lfo_rw)

# Proportion of timepoints in which AR2 model gives better forecasts
length(which((lfo_ar2$elpds - lfo_rw$elpds) &gt; 0)) /
      length(lfo_ar2$elpds)

# A higher total ELPD is preferred
lfo_ar2$sum_ELPD
lfo_rw$sum_ELPD

</code></pre>

<hr>
<h2 id='logLik.mvgam'>Compute pointwise Log-Likelihoods from fitted <span class="pkg">mvgam</span> objects</h2><span id='topic+logLik.mvgam'></span>

<h3>Description</h3>

<p>Compute pointwise Log-Likelihoods from fitted <span class="pkg">mvgam</span> objects
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
logLik(object, linpreds, newdata, family_pars, include_forecast = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="logLik.mvgam_+3A_object">object</code></td>
<td>
<p><code>list</code> object of class <code>mvgam</code> or <code>jsdgam</code></p>
</td></tr>
<tr><td><code id="logLik.mvgam_+3A_linpreds">linpreds</code></td>
<td>
<p>Optional <code>matrix</code> of linear predictor draws to use for calculating
pointwise log-likelihoods</p>
</td></tr>
<tr><td><code id="logLik.mvgam_+3A_newdata">newdata</code></td>
<td>
<p>Optional <code>data.frame</code> or <code>list</code> object specifying which series each column
in <code>linpreds</code> belongs to. If <code>linpreds</code> is supplied, then <code>newdata</code> must also be supplied</p>
</td></tr>
<tr><td><code id="logLik.mvgam_+3A_family_pars">family_pars</code></td>
<td>
<p>Optional <code>list</code> containing posterior draws of
family-specific parameters (i.e. shape, scale or overdispersion parameters). Required if
<code>linpreds</code> and <code>newdata</code> are supplied</p>
</td></tr>
<tr><td><code id="logLik.mvgam_+3A_include_forecast">include_forecast</code></td>
<td>
<p>Logical. If <code>newdata</code> were fed to the model to compute
forecasts, should the log-likelihood draws for these observations also be returned.
Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="logLik.mvgam_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> of dimension <code style="white-space: pre;">&#8288;n_samples x n_observations&#8288;</code> containing the pointwise
log-likelihood draws for all observations in <code>newdata</code>. If no <code>newdata</code> is supplied,
log-likelihood draws are returned for all observations that were originally fed to
the model (training observations and, if supplied to the
original model via the <code>newdata</code> argument in <code><a href="#topic+mvgam">mvgam</a></code>,
testing observations)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate some data and fit a model
simdat &lt;- sim_mvgam(n_series = 1, trend_model = 'AR1')
mod &lt;- mvgam(y ~ s(season, bs = 'cc', k = 6),
             trend_model = AR(),
             data = simdat$data_train,
             chains = 2,
             silent = 2)

# Extract logLikelihood values
lls &lt;- logLik(mod)
str(lls)

</code></pre>

<hr>
<h2 id='loo.mvgam'>LOO information criteria for <span class="pkg">mvgam</span> models</h2><span id='topic+loo.mvgam'></span><span id='topic+loo_compare.mvgam'></span>

<h3>Description</h3>

<p>Extract the LOOIC (leave-one-out information criterion) using
<code><a href="loo.html#topic+loo">loo::loo()</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
loo(x, incl_dynamics = TRUE, ...)

## S3 method for class 'mvgam'
loo_compare(x, ..., model_names = NULL, incl_dynamics = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="loo.mvgam_+3A_x">x</code></td>
<td>
<p>Object of class <code>mvgam</code></p>
</td></tr>
<tr><td><code id="loo.mvgam_+3A_incl_dynamics">incl_dynamics</code></td>
<td>
<p>Logical; indicates if any latent dynamic structures that
were included in the model should be considered when calculating in-sample
log-likelihoods. Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="loo.mvgam_+3A_...">...</code></td>
<td>
<p>More <code>mvgam</code> objects.</p>
</td></tr>
<tr><td><code id="loo.mvgam_+3A_model_names">model_names</code></td>
<td>
<p>If <code>NULL</code> (the default) will use model names derived
from deparsing the call. Otherwise will use the passed values as model names.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>When comparing two (or more) fitted <code>mvgam</code> models, we can estimate the
difference in their in-sample predictive accuracies using the Expcted Log Predictive
Density (ELPD). This metric can be approximated using Pareto Smoothed Importance Sampling, which
is a method to re-weight posterior draws to approximate what predictions the models might have
made for a given datapoint had that datapoint not been included in the original model fit (i.e.
if we were to run a leave-one-out cross-validation and then made a prediction for the held-out
datapoint). See details from <code><a href="loo.html#topic+loo">loo::loo()</a></code> and <code><a href="loo.html#topic+loo_compare">loo::loo_compare()</a></code> for further information
on how this importance sampling works.
</p>
<p>There are two fundamentally different ways to calculate ELPD from <code>mvgam</code> models that included
dynamic latent processes (i.e. &quot;trend_models&quot;). The first is to use the predictions that were
generated when estimating these latent processes by setting <code>incl_dynamics = TRUE</code>. This works
in the same way that setting <code>incl_autocor = TRUE</code> in <code><a href="brms.html#topic+prepare_predictions">brms::prepare_predictions()</a></code>. But it may
also be desirable to compare predictions by considering that the dynamic processes are nuisance
parameters that we'd wish to account for when making inferences about other processes in the
model (i.e. the linear predictor effects). Setting <code>incl_dynamics = FALSE</code> will accomplish
this by ignoring the dynamic processes when making predictions. This option matches up with
what <code>mvgam</code>'s prediction functions return (i.e. <code><a href="#topic+predict.mvgam">predict.mvgam</a></code>, <code><a href="#topic+ppc">ppc</a></code>,
<code><a href="#topic+pp_check.mvgam">pp_check.mvgam</a></code>, <code><a href="#topic+posterior_epred.mvgam">posterior_epred.mvgam</a></code>) and will be far less forgiving
of models that may be overfitting the training data due to highly flexible dynamic processes
(such as Random Walks, for example). However setting <code>incl_dynamics = FALSE</code> will often result
in less stable Pareto k diagnostics for models with dynamic trends, making ELPD comparisons
difficult and unstable. It is therefore recommended to generally stick with
<code>incl_dynamics = TRUE</code> when comparing models based on in-sample fits, and then to perhaps use
forecast evaluations for further scrutiny of models (see for example <code><a href="#topic+forecast.mvgam">forecast.mvgam</a></code>,
<code><a href="#topic+score.mvgam_forecast">score.mvgam_forecast</a></code> and <code><a href="#topic+lfo_cv">lfo_cv</a></code>)
</p>


<h3>Value</h3>

<p>for <code>loo.mvgam</code>, an object of class <code>psis_loo</code> (see <code><a href="loo.html#topic+loo">loo::loo()</a></code>
for details). For <code>loo_compare.mvgam</code>, an object of class <code>compare.loo</code> (
<code><a href="loo.html#topic+loo_compare">loo::loo_compare()</a></code> for details)
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate 4 time series with hierarchical seasonality
# and independent AR1 dynamic processes
set.seed(111)
simdat &lt;- sim_mvgam(seasonality = 'hierarchical',
                   trend_model = AR(),
                   family = gaussian())

# Fit a model with shared seasonality
mod1 &lt;- mvgam(y ~ s(season, bs = 'cc', k = 6),
             data = rbind(simdat$data_train,
             simdat$data_test),
             family = gaussian(),
             chains = 2,
             silent = 2)

# Inspect the model and calculate LOO
conditional_effects(mod1)
mc.cores.def &lt;- getOption('mc.cores')
options(mc.cores = 1)
loo(mod1)

# Now fit a model with hierarchical seasonality
mod2 &lt;- update(mod1,
              formula = y ~ s(season, bs = 'cc', k = 6) +
              s(season, series, bs = 'fs',
              xt = list(bs = 'cc'), k = 4),
              chains = 2,
              silent = 2)
conditional_effects(mod2)
loo(mod2)

# Now add AR1 dynamic errors to mod2
mod3 &lt;- update(mod2,
              trend_model = AR(),
              chains = 2,
              silent = 2)
conditional_effects(mod3)
plot(mod3, type = 'trend')
loo(mod3)

# Compare models using LOO
loo_compare(mod1, mod2, mod3)
options(mc.cores = mc.cores.def)

# Compare forecast abilities using an expanding training window and
# forecasting ahead 1 timepoint from each window; the first window by includes
# the first 92 timepoints (of the 100 that were simulated)
max(mod2$obs_data$time)
lfo_mod2 &lt;- lfo_cv(mod2, min_t = 92)
lfo_mod3 &lt;- lfo_cv(mod3, min_t = 92)

# Take the difference in forecast ELPDs; a model with higher ELPD is preferred,
# so negative values here indicate that mod3 gave better forecasts for a particular
# out of sample timepoint
plot(y = lfo_mod2$elpds - lfo_mod3$elpds,
    x = lfo_mod2$eval_timepoints, pch = 16,
    ylab = 'ELPD_mod2 - ELPD_mod3',
    xlab = 'Evaluation timepoint')
abline(h = 0, lty = 'dashed')

</code></pre>

<hr>
<h2 id='lv_correlations'>Calculate trend correlations based on latent factor loadings for <span class="pkg">mvgam</span> models</h2><span id='topic+lv_correlations'></span>

<h3>Description</h3>

<p>This function uses samples of latent trends for each series from a fitted
mvgam model to calculates correlations among series' trends
</p>


<h3>Usage</h3>

<pre><code class='language-R'>lv_correlations(object)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="lv_correlations_+3A_object">object</code></td>
<td>
<p><code>list</code> object of class <code>mvgam</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> object containing the mean posterior correlations
and the full array of posterior correlations
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
simdat &lt;- sim_mvgam()
mod &lt;- mvgam(y ~ s(season, bs = 'cc',
                  k = 6),
            trend_model = AR(),
            use_lv = TRUE,
            n_lv = 2,
            data = simdat$data_train,
            burnin = 300,
            samples = 300,
            chains = 2,
            silent = 2)
lvcors &lt;- lv_correlations(mod)
names(lvcors)
lapply(lvcors, class)

</code></pre>

<hr>
<h2 id='mcmc_plot.mvgam'>MCMC plots of <span class="pkg">mvgam</span> parameters, as implemented in <span class="pkg">bayesplot</span></h2><span id='topic+mcmc_plot.mvgam'></span>

<h3>Description</h3>

<p>Convenient way to call MCMC plotting functions
implemented in the <span class="pkg">bayesplot</span> package for <span class="pkg">mvgam</span> models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
mcmc_plot(
  object,
  type = "intervals",
  variable = NULL,
  regex = FALSE,
  use_alias = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mcmc_plot.mvgam_+3A_object">object</code></td>
<td>
<p>An <span class="rlang"><b>R</b></span> object typically of class <code>brmsfit</code></p>
</td></tr>
<tr><td><code id="mcmc_plot.mvgam_+3A_type">type</code></td>
<td>
<p>The type of the plot.
Supported types are (as names) <code>hist</code>, <code>dens</code>,
<code>hist_by_chain</code>, <code>dens_overlay</code>,
<code>violin</code>, <code>intervals</code>, <code>areas</code>,
<code>areas_ridges</code>, <code>combo</code>, <code>acf</code>,
<code>acf_bar</code>, <code>trace</code>, <code>trace_highlight</code>,
<code>scatter</code>, <code>hex</code>, <code>pairs</code>, <code>violin</code>,
<code>rhat</code>, <code>rhat_hist</code>, <code>neff</code>, <code>neff_hist</code>
and <code>nuts_energy</code>.
For an overview on the various plot types see
<code><a href="bayesplot.html#topic+MCMC-overview">MCMC-overview</a></code>.</p>
</td></tr>
<tr><td><code id="mcmc_plot.mvgam_+3A_variable">variable</code></td>
<td>
<p>Names of the variables (parameters) to plot, as given by a
character vector or a regular expression (if <code>regex = TRUE</code>). By
default, a hopefully not too large selection of variables is plotted.</p>
</td></tr>
<tr><td><code id="mcmc_plot.mvgam_+3A_regex">regex</code></td>
<td>
<p>Logical; Indicates whether <code>variable</code> should
be treated as regular expressions. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mcmc_plot.mvgam_+3A_use_alias">use_alias</code></td>
<td>
<p>Logical. If more informative names for parameters are available
(i.e. for beta coefficients <code>b</code> or for smoothing parameters <code>rho</code>), replace the uninformative
names with the more informative alias. Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="mcmc_plot.mvgam_+3A_...">...</code></td>
<td>
<p>Additional arguments passed to the plotting functions.
See <code><a href="bayesplot.html#topic+MCMC-overview">MCMC-overview</a></code> for
more details.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object
that can be further customized using the <span class="pkg">ggplot2</span> package.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvgam_draws">mvgam_draws</a></code> for an overview of some of the shortcut strings
that can be used for argument <code>variable</code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
simdat &lt;- sim_mvgam(n_series = 1, trend_model = AR())
mod &lt;- mvgam(y ~ s(season, bs = 'cc', k = 6),
             trend_model = AR(),
             noncentred = TRUE,
             data = simdat$data_train,
             chains = 2,
             silent = 2)
mcmc_plot(mod)
mcmc_plot(mod, type = 'neff_hist')
mcmc_plot(mod, variable = 'betas', type = 'areas')
mcmc_plot(mod, variable = 'trend_params', type = 'combo')

</code></pre>

<hr>
<h2 id='model.frame.mvgam'>Extract model.frame from a fitted <span class="pkg">mvgam</span> object</h2><span id='topic+model.frame.mvgam'></span><span id='topic+model.frame.mvgam_prefit'></span>

<h3>Description</h3>

<p>Extract model.frame from a fitted <span class="pkg">mvgam</span> object
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
model.frame(formula, trend_effects = FALSE, ...)

## S3 method for class 'mvgam_prefit'
model.frame(formula, trend_effects = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="model.frame.mvgam_+3A_formula">formula</code></td>
<td>
<p>a model <code><a href="stats.html#topic+formula">formula</a></code> or <code><a href="stats.html#topic+terms">terms</a></code>
object or an <span class="rlang"><b>R</b></span> object.</p>
</td></tr>
<tr><td><code id="model.frame.mvgam_+3A_trend_effects">trend_effects</code></td>
<td>
<p><code>logical</code>, return the model.frame from the
observation model (if <code>FALSE</code>) or from the underlying process
model (if<code>TRUE</code>)</p>
</td></tr>
<tr><td><code id="model.frame.mvgam_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>matrix</code> containing the fitted model frame
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>

<hr>
<h2 id='monotonic'>Monotonic splines in <span class="pkg">mvgam</span> models</h2><span id='topic+monotonic'></span><span id='topic+smooth.construct.moi.smooth.spec'></span><span id='topic+smooth.construct.mod.smooth.spec'></span><span id='topic+Predict.matrix.moi.smooth'></span><span id='topic+Predict.matrix.mod.smooth'></span>

<h3>Description</h3>

<p>Uses constructors from package <span class="pkg">splines2</span> to build monotonically increasing
or decreasing splines. Details also in Wang &amp; Yan (2021).
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'moi.smooth.spec'
smooth.construct(object, data, knots)

## S3 method for class 'mod.smooth.spec'
smooth.construct(object, data, knots)

## S3 method for class 'moi.smooth'
Predict.matrix(object, data)

## S3 method for class 'mod.smooth'
Predict.matrix(object, data)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="monotonic_+3A_object">object</code></td>
<td>
<p>A smooth specification object, usually generated by a term
<code>s(x, bs = "moi", ...)</code> or <code>s(x, bs = "mod", ...)</code></p>
</td></tr>
<tr><td><code id="monotonic_+3A_data">data</code></td>
<td>
<p>a list containing just the data (including any <code>by</code> variable) required by this term, 
with names corresponding to <code>object$term</code> (and <code>object$by</code>). The <code>by</code> variable 
is the last element.</p>
</td></tr>
<tr><td><code id="monotonic_+3A_knots">knots</code></td>
<td>
<p>a list containing any knots supplied for basis setup &mdash; in same order and with same names as <code>data</code>. 
Can be <code>NULL</code>. See details for further information.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>The constructor is not normally called directly,
but is rather used internally by <a href="#topic+mvgam">mvgam</a>. If they are not supplied then the
knots of the spline are placed evenly throughout the covariate values to
which the term refers: For example, if fitting 101 data with an 11
knot spline of x then there would be a knot at every 10th (ordered) x value.
The spline is an implementation of the closed-form I-spline basis based
on the recursion formula given by Ramsay (1988), in which the basis coefficients
must be constrained to either be non-negative (for monotonically increasing
functions) or non-positive (monotonically decreasing)
<br />
<br />
Take note that when using either monotonic basis, the number of basis functions
<code>k</code> must be supplied as an even integer due to the manner in
which monotonic basis functions are constructed
</p>


<h3>Value</h3>

<p>An object of class <code>"moi.smooth"</code> or <code>"mod.smooth"</code>. In addition to
the usual elements of a smooth class documented under <code><a href="mgcv.html#topic+smooth.construct">smooth.construct</a></code>,
this object will contain a slot called <code>boundary</code> that defines the endpoints beyond
which the spline will begin extrapolating (extrapolation is flat due to the first
order penalty placed on the smooth function)
</p>


<h3>Note</h3>

<p>This constructor will result in a valid smooth if using a call to
<code><a href="mgcv.html#topic+gam">gam</a></code> or <code><a href="mgcv.html#topic+bam">bam</a></code>, however the resulting
functions will not be guaranteed to be monotonic because constraints on
basis coefficients will not be enforced
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>References</h3>

<p>Wang, Wenjie, and Jun Yan. &quot;Shape-Restricted Regression Splines with R Package splines2.&quot;
Journal of Data Science 19.3 (2021).
<br />
<br />
Ramsay, J. O. (1988). Monotone regression splines in action. Statistical Science, 3(4), 425&ndash;441.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate data from a monotonically increasing function
set.seed(123123)
x &lt;- runif(80) * 4 - 1
x &lt;- sort(x)
f &lt;- exp(4 * x) / (1 + exp(4 * x))
y &lt;- f + rnorm(80) * 0.1
plot(x, y)

# A standard TRPS smooth doesn't capture monotonicity
library(mgcv)
mod_data &lt;- data.frame(y = y, x = x)
mod &lt;- gam(y ~ s(x, k = 16),
           data = mod_data,
           family = gaussian())

library(marginaleffects)
plot_predictions(mod,
                 by = 'x',
                 newdata = data.frame(x = seq(min(x) - 0.5,
                                              max(x) + 0.5,
                                              length.out = 100)),
                 points = 0.5)

# Using the 'moi' basis in mvgam rectifies this
mod_data$time &lt;- 1:NROW(mod_data)
mod2 &lt;- mvgam(y ~ s(x, bs = 'moi', k = 18),
             data = mod_data,
             family = gaussian(),
             chains = 2,
             silent = 2)

plot_predictions(mod2,
                 by = 'x',
                 newdata = data.frame(x = seq(min(x) - 0.5,
                                              max(x) + 0.5,
                                              length.out = 100)),
                 points = 0.5)

plot(mod2, type = 'smooth', realisations = TRUE)

# 'by' terms that produce a different smooth for each level of the 'by'
# factor are also allowed
set.seed(123123)
x &lt;- runif(80) * 4 - 1
x &lt;- sort(x)

# Two different monotonic smooths, one for each factor level
f &lt;- exp(4 * x) / (1 + exp(4 * x))
f2 &lt;- exp(3.5 * x) / (1 + exp(3 * x))
fac &lt;- c(rep('a', 80), rep('b', 80))
y &lt;- c(f + rnorm(80) * 0.1,
       f2 + rnorm(80) * 0.2)
plot(x, y[1:80])
plot(x, y[81:160])

# Gather all data into a data.frame, including the factor 'by' variable
mod_data &lt;- data.frame(y, x, fac = as.factor(fac))
mod_data$time &lt;- 1:NROW(mod_data)

# Fit a model with different smooths per factor level
mod &lt;- mvgam(y ~ s(x, bs = 'moi', by = fac, k = 8),
             data = mod_data,
             family = gaussian(),
             chains = 2,
             silent = 2)

# Visualise the different monotonic functions
plot_predictions(mod, condition = c('x', 'fac', 'fac'),
                 points = 0.5)
plot(mod, type = 'smooth', realisations = TRUE)

# First derivatives (on the link scale) should never be
# negative for either factor level
(derivs &lt;- slopes(mod, variables = 'x',
                 by = c('x', 'fac'),
                 type = 'link'))
all(derivs$estimate &gt; 0)

</code></pre>

<hr>
<h2 id='mvgam'>Fit a Bayesian dynamic GAM to a univariate or multivariate set of time series</h2><span id='topic+mvgam'></span>

<h3>Description</h3>

<p>This function estimates the posterior distribution for Generalised Additive
Models (GAMs) that can include smooth spline functions, specified in the GAM
formula, as well as latent temporal processes, specified by <code>trend_model</code>.
Further modelling options include State-Space representations to allow covariates
and dynamic processes to occur on the latent 'State' level while also capturing
observation-level effects. Prior specifications are flexible and explicitly
encourage users to apply prior distributions that actually reflect their beliefs.
In addition, model fits can easily be assessed and
compared with posterior predictive checks, forecast comparisons and
leave-one-out / leave-future-out cross-validation.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>mvgam(
  formula,
  trend_formula,
  knots,
  trend_knots,
  trend_model = "None",
  noncentred = FALSE,
  family = poisson(),
  share_obs_params = FALSE,
  data,
  newdata,
  use_lv = FALSE,
  n_lv,
  trend_map,
  priors,
  run_model = TRUE,
  prior_simulation = FALSE,
  residuals = TRUE,
  return_model_data = FALSE,
  backend = getOption("brms.backend", "cmdstanr"),
  algorithm = getOption("brms.algorithm", "sampling"),
  control = list(max_treedepth = 10, adapt_delta = 0.8),
  chains = 4,
  burnin = 500,
  samples = 500,
  thin = 1,
  parallel = TRUE,
  threads = 1,
  save_all_pars = FALSE,
  silent = 1,
  autoformat = TRUE,
  refit = FALSE,
  lfo = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mvgam_+3A_formula">formula</code></td>
<td>
<p>A <code>formula</code> object specifying the GAM observation model
formula. These are exactly like the formula
for a GLM except that smooth terms, <code>s()</code>, <code>te()</code>, <code>ti()</code>, <code>t2()</code>, as well
as time-varying <code>dynamic()</code> terms, nonparametric <code>gp()</code> terms and offsets using <code>offset()</code>,
can be added to the right hand side to specify that the linear predictor
depends on smooth functions of predictors (or linear functionals of these).
In <code>nmix()</code> family models, the <code>formula</code> is used to set up a linear predictor
for the detection probability. Details of the formula
syntax used by <span class="pkg">mvgam</span> can be found in <code><a href="#topic+mvgam_formulae">mvgam_formulae</a></code></p>
</td></tr>
<tr><td><code id="mvgam_+3A_trend_formula">trend_formula</code></td>
<td>
<p>An optional <code>formula</code> object specifying the GAM
process model formula. If
supplied, a linear predictor will be modelled for the latent trends to capture
process model evolution
separately from the observation model. Should not have a response variable
specified on the left-hand side
of the formula (i.e. a valid option would be <code>~ season + s(year)</code>). Also note
that you should not use
the identifier <code>series</code> in this formula to specify effects that vary across
time series. Instead you should use
<code>trend</code>. This will ensure that models in which a <code>trend_map</code> is supplied will
still work consistently
(i.e. by allowing effects to vary across process models, even when some time
series share the same underlying
process model). This feature is only currently available for <code>RW()</code>, <code>AR()</code>
and <code>VAR()</code> trend models.
In <code>nmix()</code> family models, the <code>trend_formula</code> is used to set up a linear
predictor for the underlying
latent abundance. Be aware that it can be very challenging to simultaneously
estimate intercept parameters
for both the observation mode (captured by <code>formula</code>) and the process model
(captured by <code>trend_formula</code>).
Users are recommended to drop one of these using the <code>- 1</code> convention in the
formula right hand side.</p>
</td></tr>
<tr><td><code id="mvgam_+3A_knots">knots</code></td>
<td>
<p>An optional <code>list</code> containing user specified knot values to
be used for basis construction.
For most bases the user simply supplies the knots to be used, which must match
up with the <code>k</code> value supplied
(note that the number of knots is not always just <code>k</code>). Different terms can
use different numbers of knots,
unless they share a covariate</p>
</td></tr>
<tr><td><code id="mvgam_+3A_trend_knots">trend_knots</code></td>
<td>
<p>As for <code>knots</code> above, this is an optional <code>list</code> of
knot values for smooth
functions within the <code>trend_formula</code></p>
</td></tr>
<tr><td><code id="mvgam_+3A_trend_model">trend_model</code></td>
<td>
<p><code>character</code> or  <code>function</code> specifying the time
series dynamics for the latent trend. Options are:
</p>

<ul>
<li> <p><code>None</code> (no latent trend component; i.e. the GAM component is all that
contributes to the linear predictor, and the observation process is the only
source of error; similarly to what is estimated by <code><a href="mgcv.html#topic+gam">gam</a></code>)
</p>
</li>
<li> <p><code>ZMVN</code> or <code>ZMVN()</code> (Zero-Mean Multivariate Normal; only available in
<code>Stan</code>)
</p>
</li>
<li> <p><code>'RW'</code> or <code>RW()</code>
</p>
</li>
<li> <p><code>'AR1'</code> or <code>AR(p = 1)</code>
</p>
</li>
<li> <p><code>'AR2'</code> or <code>AR(p = 2)</code>
</p>
</li>
<li> <p><code>'AR3'</code> or <code>AR(p = 3)</code>
</p>
</li>
<li> <p><code>'CAR1'</code> or <code>CAR(p = 1)</code>
</p>
</li>
<li> <p><code>'VAR1'</code>  or <code>VAR()</code>(only available in <code>Stan</code>)
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;'PWlogistic&#8288;</code>, <code>'PWlinear'</code> or <code>PW()</code> (only available in <code>Stan</code>)
</p>
</li>
<li> <p><code>'GP'</code> or <code>GP()</code> (Gaussian Process with squared exponential kernel;
only available in <code>Stan</code>)</p>
</li></ul>

<p>For all trend types apart from <code>ZMVN()</code>, <code>GP()</code>, <code>CAR()</code> and <code>PW()</code>, moving
average and/or correlated process error terms can also be estimated (for
example, <code>RW(cor = TRUE)</code> will set up a multivariate Random Walk if <code>n_series &gt; 1</code>).
It is also possible for many multivariate trends to estimate hierarchical
correlations if the data are structured among levels of a relevant grouping
factor. See <a href="#topic+mvgam_trends">mvgam_trends</a> for more details and see <a href="#topic+ZMVN">ZMVN</a> for an example.</p>
</td></tr>
<tr><td><code id="mvgam_+3A_noncentred">noncentred</code></td>
<td>
<p><code>logical</code> Use the non-centred parameterisation for autoregressive
trend models? Setting to <code>TRUE</code> will reparameterise the model to avoid possible
degeneracies that can show up when estimating the latent dynamic random effects. For some
models, this can produce big gains in efficiency, meaning that fewer burnin and sampling
iterations are required for posterior exploration. But for other models, where the data
are highly informative about the latent dynamic processes, this can actually lead to worse
performance. Only available for certain trend models
(i.e. <code>RW()</code>, <code>AR()</code>, or <code>CAR()</code>, or for
<code>trend = 'None'</code> when using a <code>trend_formula</code>). Not yet available for moving average or
correlated error models</p>
</td></tr>
<tr><td><code id="mvgam_+3A_family">family</code></td>
<td>
<p><code>family</code> specifying the exponential observation family for
the series. Currently supported
families are:
</p>

<ul>
<li><p><code>gaussian()</code> for real-valued data
</p>
</li>
<li><p><code>betar()</code> for proportional data on <code style="white-space: pre;">&#8288;(0,1)&#8288;</code>
</p>
</li>
<li><p><code>lognormal()</code> for non-negative real-valued data
</p>
</li>
<li><p><code>student_t()</code> for real-valued data
</p>
</li>
<li><p><code>Gamma()</code> for non-negative real-valued data
</p>
</li>
<li><p><code>bernoulli()</code> for binary data
</p>
</li>
<li><p><code>poisson()</code> for count data
</p>
</li>
<li><p><code>nb()</code> for overdispersed count data
</p>
</li>
<li><p><code>binomial()</code> for count data with imperfect detection when the number
of trials is known;
note that the <code>cbind()</code> function must be used to bind the discrete
observations and the discrete number
of trials
</p>
</li>
<li><p><code>beta_binomial()</code> as for <code>binomial()</code> but allows for overdispersion
</p>
</li>
<li><p><code>nmix()</code> for count data with imperfect detection when the number of
trials is unknown and should be modeled via a State-Space N-Mixture model.
The latent states are Poisson, capturing the 'true' latent
abundance, while the observation process is Binomial to account for
imperfect detection.
See <code><a href="#topic+mvgam_families">mvgam_families</a></code> for an example of how to use this family</p>
</li></ul>

<p>Default is <code>poisson()</code>.
See <code><a href="#topic+mvgam_families">mvgam_families</a></code> for more details</p>
</td></tr>
<tr><td><code id="mvgam_+3A_share_obs_params">share_obs_params</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code> and the <code>family</code>
has additional family-specific observation parameters (e.g. variance
components in
<code>student_t()</code> or <code>gaussian()</code>, or dispersion parameters in <code>nb()</code> or
<code>betar()</code>), these parameters will be shared across all outcome variables. This is handy
if you have multiple outcomes (time series in most <code>mvgam</code> models) that you
believe share some properties,
such as being from the same species over different spatial units. Default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mvgam_+3A_data">data</code></td>
<td>
<p>A <code>dataframe</code> or <code>list</code> containing the model response
variable and covariates
required by the GAM <code>formula</code> and optional <code>trend_formula</code>. Most
models should include columns:
</p>

<ul>
<li><p><code>series</code> (a <code>factor</code> index of the series IDs; the number of
levels should be identical
to the number of unique series labels (i.e. <code>n_series = length(levels(data$series))</code>))
</p>
</li>
<li><p><code>time</code> (<code>numeric</code> or <code>integer</code> index of the time point for
each observation).
For most dynamic trend types available in <code>mvgam</code> (see argument <code>trend_model</code>),
time should be
measured in discrete, regularly spaced intervals (i.e. <code>c(1, 2, 3, ...)</code>).
However you can
use irregularly spaced intervals if using <code>trend_model = CAR(1)</code>, though
note that any
temporal intervals that are exactly <code>0</code> will be adjusted to a very small number
(<code>1e-12</code>) to prevent sampling errors. See an example of <code>CAR()</code> trends in
<code><a href="#topic+CAR">CAR</a></code>
</p>
</li></ul>

<p>Note however that there are special cases where these identifiers are not
needed. For
example, models with hierarchical temporal correlation processes (e.g.
<code>AR(gr = region, subgr = species)</code>)
should NOT include a <code>series</code> identifier, as this will be constructed
internally (see
<code><a href="#topic+mvgam_trends">mvgam_trends</a></code> and <code><a href="#topic+AR">AR</a></code> for details). <code>mvgam</code> can also
fit models that do not
include a <code>time</code> variable if there are no temporal dynamic structures included
(i.e. <code>trend_model = 'None'</code> or
<code>trend_model = ZMVN()</code>). <code>data</code> should also include any other variables to be
included in
the linear predictor of <code>formula</code></p>
</td></tr>
<tr><td><code id="mvgam_+3A_newdata">newdata</code></td>
<td>
<p>Optional <code>dataframe</code> or <code>list</code> of test data containing
the same variables
as in <code>data</code>. If included, the
observations in variable <code>y</code> will be set to <code>NA</code> when fitting the
model so that posterior
simulations can be obtained</p>
</td></tr>
<tr><td><code id="mvgam_+3A_use_lv">use_lv</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, use dynamic factors to estimate series'
latent trends in a reduced dimension format. Only available for
<code>RW()</code>, <code>AR()</code> and <code>GP()</code> trend models. Defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="mvgam_+3A_n_lv">n_lv</code></td>
<td>
<p><code>integer</code> the number of latent dynamic factors to use if
<code>use_lv == TRUE</code>. Cannot be <code>&gt; n_series</code>. Defaults arbitrarily to
<code>min(2, floor(n_series / 2))</code></p>
</td></tr>
<tr><td><code id="mvgam_+3A_trend_map">trend_map</code></td>
<td>
<p>Optional <code>data.frame</code> specifying which series should depend
on which latent trends. Useful for allowing multiple series to depend on the
same latent trend process, but with different observation processes. If
supplied, a latent factor model is set up by setting <code>use_lv = TRUE</code> and
using the mapping to set up the shared trends. Needs to have column names
<code>series</code> and <code>trend</code>, with integer values in the <code>trend</code> column to state which
trend each series should depend on. The <code>series</code> column should have a single
unique entry for each series in the data (names should perfectly match factor
levels of the <code>series</code> variable in <code>data</code>). Note that if this is supplied,
the intercept parameter in the process model will NOT be automatically suppressed.
Not yet supported for models in wich the latent factors evolve in continuous time (<code>CAR()</code>).
See examples for details</p>
</td></tr>
<tr><td><code id="mvgam_+3A_priors">priors</code></td>
<td>
<p>An optional <code>data.frame</code> with prior
definitions or, preferentially, a vector containing
objects of class <code>brmsprior</code> (see. <code><a href="brms.html#topic+prior">prior</a></code> for details).
See <a href="#topic+get_mvgam_priors">get_mvgam_priors</a> and Details' for more information on changing default prior distributions</p>
</td></tr>
<tr><td><code id="mvgam_+3A_run_model">run_model</code></td>
<td>
<p><code>logical</code>. If <code>FALSE</code>, the model is not fitted but
instead the function will
return the model file and the data / initial values that are needed to fit the
model outside of <code>mvgam</code></p>
</td></tr>
<tr><td><code id="mvgam_+3A_prior_simulation">prior_simulation</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, no observations are
fed to the model, and instead
simulations from prior distributions are returned</p>
</td></tr>
<tr><td><code id="mvgam_+3A_residuals">residuals</code></td>
<td>
<p>Logical indicating whether to compute series-level randomized quantile residuals and include
them as part of the returned object. Defaults to <code>TRUE</code>, but you can set to <code>FALSE</code> to save
computational time and reduce the size of the returned object (users can always add residuals to
an object of class <code>mvgam</code> using <a href="#topic+add_residuals">add_residuals</a>)</p>
</td></tr>
<tr><td><code id="mvgam_+3A_return_model_data">return_model_data</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, the list of data that
is needed to fit the
model is returned, along with the initial values for smooth and AR parameters,
once the model is fitted.
This will be helpful if users wish to modify the model file to add
other stochastic elements that are not currently available in <code>mvgam</code>.
Default is <code>FALSE</code> to reduce
the size of the returned object, unless <code>run_model == FALSE</code></p>
</td></tr>
<tr><td><code id="mvgam_+3A_backend">backend</code></td>
<td>
<p>Character string naming the package to use as the backend for fitting
the Stan model. Options are &quot;cmdstanr&quot; (the default) or &quot;rstan&quot;. Can be set globally
for the current R session via the <code>"brms.backend"</code> option (see <code><a href="base.html#topic+options">options</a></code>). Details on
the rstan and cmdstanr packages are available at https://mc-stan.org/rstan/ and
https://mc-stan.org/cmdstanr/, respectively</p>
</td></tr>
<tr><td><code id="mvgam_+3A_algorithm">algorithm</code></td>
<td>
<p>Character string naming the estimation approach to use.
Options are <code>"sampling"</code> for MCMC (the default), <code>"meanfield"</code> for
variational inference with factorized normal distributions,
<code>"fullrank"</code> for variational inference with a multivariate normal
distribution, <code>"laplace"</code> for a Laplace approximation (only available
when using cmdstanr as the backend) or <code>"pathfinder"</code> for the pathfinder
algorithm (only currently available when using cmdstanr as the backend).
Can be set globally for the current <span class="rlang"><b>R</b></span> session via the
<code>"brms.algorithm"</code> option (see <code><a href="base.html#topic+options">options</a></code>). Limited testing
suggests that <code>"meanfield"</code> performs best out of the non-MCMC approximations for
dynamic GAMs, possibly because of the difficulties estimating covariances among the
many spline parameters and latent trend parameters. But rigorous testing has not
been carried out</p>
</td></tr>
<tr><td><code id="mvgam_+3A_control">control</code></td>
<td>
<p>A named <code>list</code> for controlling the sampler's behaviour. Valid
elements include <code>max_treedepth</code>, <code>adapt_delta</code> and <code>init</code></p>
</td></tr>
<tr><td><code id="mvgam_+3A_chains">chains</code></td>
<td>
<p><code>integer</code> specifying the number of parallel chains for the model. Ignored
if <code>algorithm %in% c('meanfield', 'fullrank', 'pathfinder', 'laplace')</code></p>
</td></tr>
<tr><td><code id="mvgam_+3A_burnin">burnin</code></td>
<td>
<p><code>integer</code> specifying the number of warmup iterations of the Markov chain to run
to tune sampling algorithms. Ignored
if <code>algorithm %in% c('meanfield', 'fullrank', 'pathfinder', 'laplace')</code></p>
</td></tr>
<tr><td><code id="mvgam_+3A_samples">samples</code></td>
<td>
<p><code>integer</code> specifying the number of post-warmup iterations of the Markov chain to run for
sampling the posterior distribution</p>
</td></tr>
<tr><td><code id="mvgam_+3A_thin">thin</code></td>
<td>
<p>Thinning interval for monitors.  Ignored
if <code>algorithm %in% c('meanfield', 'fullrank', 'pathfinder', 'laplace')</code></p>
</td></tr>
<tr><td><code id="mvgam_+3A_parallel">parallel</code></td>
<td>
<p><code>logical</code> specifying whether multiple cores should be used for
generating MCMC simulations in parallel. If <code>TRUE</code>, the number of cores to use will be
<code>min(c(chains, parallel::detectCores() - 1))</code></p>
</td></tr>
<tr><td><code id="mvgam_+3A_threads">threads</code></td>
<td>
<p><code>integer</code> Experimental option to use multithreading for within-chain
parallelisation in <code>Stan</code>. We recommend its use only if you are experienced with
<code>Stan</code>'s <code>reduce_sum</code> function and have a slow running model that cannot be sped
up by any other means. Currently works for all families apart from <code>nmix()</code> and
when using <code>Cmdstan</code> as the backend</p>
</td></tr>
<tr><td><code id="mvgam_+3A_save_all_pars">save_all_pars</code></td>
<td>
<p><code>Logical</code> flag to indicate if draws from all
variables defined in Stan's <code>parameters</code> block should be saved
(default is <code>FALSE</code>).</p>
</td></tr>
<tr><td><code id="mvgam_+3A_silent">silent</code></td>
<td>
<p>Verbosity level between <code>0</code> and <code>2</code>. If <code>1</code> (the default), most
of the informational messages of compiler and sampler are suppressed. If <code>2</code>,
even more messages are suppressed. The actual sampling progress is still printed.
Set <code>refresh = 0</code> to turn this off as well. If using <code>backend = "rstan"</code> you
can also set open_progress = FALSE to prevent opening additional progress bars.</p>
</td></tr>
<tr><td><code id="mvgam_+3A_autoformat">autoformat</code></td>
<td>
<p><code>Logical</code>. Use the <code>stanc</code> parser to automatically format the
<code>Stan</code> code and check for deprecations. Only for development purposes, so leave to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="mvgam_+3A_refit">refit</code></td>
<td>
<p>Logical indicating whether this is a refit, called using <a href="#topic+update.mvgam">update.mvgam</a>. Users should leave
as <code>FALSE</code></p>
</td></tr>
<tr><td><code id="mvgam_+3A_lfo">lfo</code></td>
<td>
<p>Logical indicating whether this is part of a call to <a href="#topic+lfo_cv.mvgam">lfo_cv.mvgam</a>. Returns a
lighter version of the model with no residuals and fewer monitored parameters to speed up
post-processing. But other downstream functions will not work properly, so users should always
leave this set as <code>FALSE</code></p>
</td></tr>
<tr><td><code id="mvgam_+3A_...">...</code></td>
<td>
<p>Further arguments passed to Stan.
For <code>backend = "rstan"</code> the arguments are passed to
<code><a href="rstan.html#topic+sampling">sampling</a></code> or <code><a href="rstan.html#topic+vb">vb</a></code>.
For <code>backend = "cmdstanr"</code> the arguments are passed to the
<code>cmdstanr::sample</code>, <code>cmdstanr::variational</code>,
<code>cmdstanr::laplace</code> or
<code>cmdstanr::pathfinder</code> method</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Dynamic GAMs are useful when we wish to predict future values from time series that show temporal dependence
but we do not want to rely on extrapolating from a smooth term (which can sometimes lead to unpredictable and unrealistic behaviours).
In addition, smooths can often try to wiggle excessively to capture any autocorrelation that is present in a time series,
which exacerbates the problem of forecasting ahead. As GAMs are very naturally viewed through a Bayesian lens, and we often
must model time series that show complex distributional features and missing data, parameters for <code>mvgam</code> models are estimated
in a Bayesian framework using Markov Chain Monte Carlo by default. A general overview is provided
in the primary vignettes: <code>vignette("mvgam_overview")</code> and <code>vignette("data_in_mvgam")</code>.
For a full list of available vignettes see <code>vignette(package = "mvgam")</code>
<br />
<br />
<em>Formula syntax</em>: Details of the formula syntax used by <span class="pkg">mvgam</span> can be found in
<code><a href="#topic+mvgam_formulae">mvgam_formulae</a></code>. Note that it is possible to supply an empty formula where
there are no predictors or intercepts in the observation model (i.e. <code>y ~ 0</code> or <code>y ~ -1</code>).
In this case, an intercept-only observation model will be set up but the intercept coefficient
will be fixed at zero. This can be handy if you wish to fit pure State-Space models where
the variation in the dynamic trend controls the average expectation, and/or where intercepts
are non-identifiable (as in piecewise trends, see examples below)
<br />
<br />
<em>Families and link functions</em>: Details of families supported by <span class="pkg">mvgam</span>
can be found in <code><a href="#topic+mvgam_families">mvgam_families</a></code>.
<br />
<br />
<em>Trend models</em>: Details of latent error process models supported by <span class="pkg">mvgam</span>
can be found in <code><a href="#topic+mvgam_trends">mvgam_trends</a></code>.
<br />
<br />
<em>Priors</em>: Default priors for intercepts and any variance parameters are chosen
to be vaguely informative, but these should always be checked by the user.
Prior distributions for most important model parameters can be altered
(see <code><a href="#topic+get_mvgam_priors">get_mvgam_priors</a></code> for details).
Note that latent trends are estimated on the link scale so choose priors
accordingly. However more control over the model specification can be accomplished
by setting <code>run_model = FALSE</code> and then editing the model code (
found in the <code>model_file</code> slot in the returned object) before running the
model using either <span class="pkg">rstan</span> or <span class="pkg">cmdstanr</span>. This is encouraged for
complex modelling tasks. Note, no priors are formally checked to ensure
they are in the right syntax so it is up to the user to ensure these are correct
<br />
<br />
<em>Random effects</em>: For any smooth terms using the random effect basis (<code><a href="mgcv.html#topic+smooth.construct.re.smooth.spec">smooth.construct.re.smooth.spec</a></code>),
a non-centred parameterisation is automatically employed to avoid degeneracies that are common in hierarchical models.
Note however that centred versions may perform better for series that are particularly informative, so as with any
foray into Bayesian modelling, it is worth building an understanding of the model's assumptions and limitations by following a
principled workflow. Also note that models are parameterised using <code>drop.unused.levels = FALSE</code> in <code><a href="mgcv.html#topic+jagam">jagam</a></code>
to ensure predictions can be made for all levels of the supplied factor variable
<br />
<br />
<em>Observation level parameters</em>: When more than one series is included in <code>data</code> and an
observation family that contains more than one parameter is used, additional observation family parameters
(i.e. <code>phi</code> for <code>nb()</code> or <code>sigma</code> for <code>gaussian()</code>) are
by default estimated independently for each series. But if you wish for the series to share
the same observation parameters, set <code>share_obs_params = TRUE</code>
<br />
<br />
<em>Residuals</em>: For each series, randomized quantile (i.e. Dunn-Smyth) residuals are calculated for inspecting model diagnostics
If the fitted model is appropriate then Dunn-Smyth residuals will be standard normal in distribution and no
autocorrelation will be evident. When a particular observation is missing, the residual is calculated by comparing independent
draws from the model's posterior distribution
<br />
<br />
<em>Using Stan</em>: <code>mvgam</code> is primarily designed to use Hamiltonian Monte Carlo for parameter estimation
via the software <code>Stan</code> (using either the <code>cmdstanr</code> or <code>rstan</code> interface).
There are great advantages when using <code>Stan</code> over Gibbs / Metropolis Hastings samplers, which includes the option
to estimate nonlinear effects via <a href="https://arxiv.org/abs/2004.11408">Hilbert space approximate Gaussian Processes</a>,
the availability of a variety of inference algorithms (i.e. variational inference, laplacian inference etc...) and
<a href="https://www.tandfonline.com/doi/full/10.1080/10618600.2022.2079648">capabilities to enforce stationarity for complex Vector Autoregressions</a>.
Because of the many advantages of <code>Stan</code> over <code>JAGS</code>,
<em>further development of the package will only be applied to <code>Stan</code></em>. This includes the planned addition
of more response distributions, plans to handle zero-inflation, and plans to incorporate a greater
variety of trend models. Users are strongly encouraged to opt for <code>Stan</code> over <code>JAGS</code> in any proceeding workflows
<br />
<br />
<em>How to start?</em>: The <a href="https://github.com/nicholasjclark/mvgam/raw/master/misc/mvgam_cheatsheet.pdf"><code>mvgam</code> cheatsheet</a> is a
good starting place if you are just learning to use the package. It gives an overview of the package's key functions and objects,
as well as providing a reasonable workflow that new users can follow. In general it is recommended to
</p>

<ul>
<li><p> 1. Check that your time series data are in a suitable tidy format for <code>mvgam</code> modeling (see the <a href="https://nicholasjclark.github.io/mvgam/articles/data_in_mvgam.html">data formatting vignette</a> for guidance)
</p>
</li>
<li><p> 2. Inspect features of the data using <code><a href="#topic+plot_mvgam_series">plot_mvgam_series</a></code>. Now is also a good time to familiarise yourself
with the package's example workflows that are detailed in the vignettes. In particular,
the <a href="https://nicholasjclark.github.io/mvgam/articles/mvgam_overview.html">getting started vignette</a>,
the <a href="https://nicholasjclark.github.io/mvgam/articles/shared_states.html">shared latent states vignette</a>,
the <a href="https://nicholasjclark.github.io/mvgam/articles/time_varying_effects.html">time-varying effects vignette</a> and
the <a href="https://nicholasjclark.github.io/mvgam/articles/trend_formulas.html">State-Space models vignette</a> all provide
useful information about how to structure, fit and interrogate Dynamic Generalized Additive Models in <code>mvgam</code>. Some
more specialized how-to articles include
<a href="https://nicholasjclark.github.io/mvgam/articles/nmixtures.html">&quot;Fitting N-mixture models in <code>mgam</code></a>,
<a href="https://nicholasjclark.github.io/mvgam/reference/jsdgam.html">&quot;Joint Species Distribution Models in <code>mgam</code></a>,
<a href="https://ecogambler.netlify.app/blog/time-varying-seasonality/">&quot;Incorporating time-varying seasonality in forecast models&quot;</a>
and <a href="https://ecogambler.netlify.app/blog/autocorrelated-gams/">&quot;Temporal autocorrelation in GAMs and the <code>mvgam</code> package&quot;</a>
</p>
</li>
<li><p> 3. Carefully think about how to structure linear predictor effects (i.e. smooth terms using <code><a href="mgcv.html#topic+s">s</a></code>,
<code><a href="mgcv.html#topic+te">te</a></code> or <code><a href="mgcv.html#topic+ti">ti</a></code>, GPs using <code><a href="brms.html#topic+gp">gp</a></code>, dynamic time-varying effects using <code><a href="#topic+dynamic">dynamic</a></code>, and parametric terms), latent temporal trend components (see <code><a href="#topic+mvgam_trends">mvgam_trends</a></code>) and the appropriate
observation family (see <code><a href="#topic+mvgam_families">mvgam_families</a></code>). Use <code><a href="#topic+get_mvgam_priors">get_mvgam_priors</a></code> to see default prior distributions
for stochastic parameters
</p>
</li>
<li><p> 4. Change default priors using appropriate prior knowledge (see <code><a href="brms.html#topic+prior">prior</a></code>). When using State-Space models
with a <code>trend_formula</code>, pay particular attention to priors for any variance parameters such as process errors and observation
errors. Default priors on these parameters are chosen to be vaguely informative and to avoid
zero (using Inverse Gamma priors), but more informative priors will often help with
model efficiency and convergence
</p>
</li>
<li><p> 5. Fit the model using either Hamiltonian Monte Carlo or an approximation algorithm (i.e.
change the <code>backend</code> argument) and use <code><a href="#topic+summary.mvgam">summary.mvgam</a></code>, <code><a href="#topic+conditional_effects.mvgam">conditional_effects.mvgam</a></code>,
<code><a href="#topic+mcmc_plot.mvgam">mcmc_plot.mvgam</a></code>, <code><a href="#topic+pp_check.mvgam">pp_check.mvgam</a></code>, <code><a href="#topic+pairs.mvgam">pairs.mvgam</a></code> and
<code><a href="#topic+plot.mvgam">plot.mvgam</a></code> to inspect / interrogate the model
</p>
</li>
<li><p> 6. Update the model as needed and use <code><a href="#topic+loo_compare.mvgam">loo_compare.mvgam</a></code> for in-sample model comparisons,
or alternatively use <code><a href="#topic+forecast.mvgam">forecast.mvgam</a></code>, <code><a href="#topic+lfo_cv.mvgam">lfo_cv.mvgam</a></code> and
<code><a href="#topic+score.mvgam_forecast">score.mvgam_forecast</a></code> to compare models based on out-of-sample forecasts
(see the <a href="https://nicholasjclark.github.io/mvgam/articles/forecast_evaluation.html">forecast evaluation vignette</a>
for guidance)
</p>
</li>
<li><p> 7. When satisfied with the model structure, use <code><a href="#topic+predict.mvgam">predict.mvgam</a></code>,
<code><a href="marginaleffects.html#topic+plot_predictions">plot_predictions</a></code> and/or <code><a href="marginaleffects.html#topic+plot_slopes">plot_slopes</a></code> for
more targeted inferences (see <a href="https://ecogambler.netlify.app/blog/interpreting-gams/">&quot;How to interpret and report nonlinear effects from Generalized Additive Models&quot;</a> for some guidance on interpreting GAMs)
</p>
</li>
<li><p> 8. Use <code><a href="#topic+how_to_cite">how_to_cite</a></code> to obtain a scaffold methods section (with full references) to begin describing this
model in scientific publications
</p>
</li></ul>



<h3>Value</h3>

<p>A <code>list</code> object of class <code>mvgam</code> containing model output, the text representation of the model file,
the mgcv model output (for easily generating simulations at
unsampled covariate values), Dunn-Smyth residuals for each series and key information needed
for other functions in the package. See <code><a href="#topic+mvgam-class">mvgam-class</a></code> for details.
Use <code>methods(class = "mvgam")</code> for an overview on available methods.
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>References</h3>

<p>Nicholas J Clark &amp; Konstans Wells (2023). Dynamic generalised additive models (DGAMs) for forecasting discrete ecological time series.
Methods in Ecology and Evolution. 14:3, 771-784.
<br />
<br />
Nicholas J Clark, SK Morgan Ernest, Henry Senyondo, Juniper Simonis, Ethan P White,
Glenda M Yenni, KANK Karunarathna (2025). Beyond single-species models: leveraging
multispecies forecasts to navigate the dynamics of ecological predictability. PeerJ.
13:e18929 https://doi.org/10.7717/peerj.18929
</p>


<h3>See Also</h3>

<p><code><a href="mgcv.html#topic+jagam">jagam</a></code>, <code><a href="mgcv.html#topic+gam">gam</a></code>, <code><a href="mgcv.html#topic+gam.models">gam.models</a></code>,
<code><a href="#topic+get_mvgam_priors">get_mvgam_priors</a></code>, <code><a href="#topic+jsdgam">jsdgam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate a collection of three time series that have shared seasonal dynamics
# and independent AR1 trends, with a Poisson observation process
set.seed(0)
dat &lt;- sim_mvgam(
  T = 80,
  n_series = 3,
  mu = 2,
  trend_model = AR(p = 1),
  prop_missing = 0.1,
  prop_trend = 0.6
)

# Plot key summary statistics for a single series
plot_mvgam_series(data = dat$data_train, series = 1)

# Plot all series together
plot_mvgam_series(data = dat$data_train, series = "all")

# Formulate a model using Stan where series share a cyclic smooth for
# seasonality and each series has an independent AR1 temporal process.
# Note that 'noncentred = TRUE' will likely give performance gains.
# Set run_model = FALSE to inspect the returned objects
mod1 &lt;- mvgam(
  formula = y ~ s(season, bs = "cc", k = 6),
  data = dat$data_train,
  trend_model = AR(),
  family = poisson(),
  noncentred = TRUE,
  run_model = FALSE
)

# View the model code in Stan language
stancode(mod1)

# View the data objects needed to fit the model in Stan
sdata1 &lt;- standata(mod1)
str(sdata1)

# Now fit the model
mod1 &lt;- mvgam(
  formula = y ~ s(season, bs = "cc", k = 6),
  data = dat$data_train,
  trend_model = AR(),
  family = poisson(),
  noncentred = TRUE,
  chains = 2,
  silent = 2
)

# Extract the model summary
summary(mod1)

# Plot the estimated historical trend and forecast for one series
plot(mod1, type = "trend", series = 1)
plot(mod1, type = "forecast", series = 1)

# Residual diagnostics
plot(mod1, type = "residuals", series = 1)
resids &lt;- residuals(mod1)
str(resids)

# Fitted values and residuals can also be added to training data
augment(mod1)

# Compute the forecast using covariate information in data_test
fc &lt;- forecast(mod1, newdata = dat$data_test)
str(fc)
plot(fc)

# Plot the estimated seasonal smooth function
plot(mod1, type = "smooths")

# Plot estimated first derivatives of the smooth
plot(mod1, type = "smooths", derivatives = TRUE)

# Plot partial residuals of the smooth
plot(mod1, type = "smooths", residuals = TRUE)

# Plot posterior realisations for the smooth
plot(mod1, type = "smooths", realisations = TRUE)

# Plot conditional response predictions using marginaleffects
conditional_effects(mod1)
plot_predictions(mod1, condition = "season", points = 0.5)

# Generate posterior predictive checks using bayesplot
pp_check(mod1)

# Extract observation model beta coefficient draws as a data.frame
beta_draws_df &lt;- as.data.frame(mod1, variable = "betas")
head(beta_draws_df)
str(beta_draws_df)

# Investigate model fit
mc.cores.def &lt;- getOption("mc.cores")
options(mc.cores = 1)
loo(mod1)
options(mc.cores = mc.cores.def)


# Example of supplying a trend_map so that some series can share
# latent trend processes
sim &lt;- sim_mvgam(n_series = 3)
mod_data &lt;- sim$data_train

# Here, we specify only two latent trends; series 1 and 2 share a trend,
# while series 3 has it's own unique latent trend
trend_map &lt;- data.frame(
  series = unique(mod_data$series),
  trend = c(1, 1, 2)
)

# Fit the model using AR1 trends
mod &lt;- mvgam(
  formula = y ~ s(season, bs = "cc", k = 6),
  trend_map = trend_map,
  trend_model = AR(),
  data = mod_data,
  return_model_data = TRUE,
  chains = 2,
  silent = 2
)

# The mapping matrix is now supplied as data to the model in the 'Z' element
mod$model_data$Z
code(mod)

# The first two series share an identical latent trend; the third is different
plot(mod, type = "trend", series = 1)
plot(mod, type = "trend", series = 2)
plot(mod, type = "trend", series = 3)


# Example of how to use dynamic coefficients
# Simulate a time-varying coefficient for the effect of temperature
set.seed(123)
N &lt;- 200
beta_temp &lt;- vector(length = N)
beta_temp[1] &lt;- 0.4
for (i in 2:N) {
  beta_temp[i] &lt;- rnorm(1, mean = beta_temp[i - 1] - 0.0025, sd = 0.05)
}
plot(beta_temp)

# Simulate a covariate called 'temp'
temp &lt;- rnorm(N, sd = 1)

# Simulate some noisy Gaussian observations
out &lt;- rnorm(N,
  mean = 4 + beta_temp * temp,
  sd = 0.5
)

# Gather necessary data into a data.frame; split into training / testing
data &lt;- data.frame(out, temp, time = seq_along(temp))
data_train &lt;- data[1:180, ]
data_test &lt;- data[181:200, ]

# Fit the model using the dynamic() formula helper
mod &lt;- mvgam(
  formula =
    out ~ dynamic(temp,
      scale = FALSE,
      k = 40
    ),
  family = gaussian(),
  data = data_train,
  newdata = data_test,
  chains = 2,
  silent = 2
)

# Inspect the model summary, forecast and time-varying coefficient distribution
summary(mod)
plot(mod, type = "smooths")
fc &lt;- forecast(mod, newdata = data_test)
plot(fc)

# Propagating the smooth term shows how the coefficient is expected to evolve
plot_mvgam_smooth(mod, smooth = 1, newdata = data)
abline(v = 180, lty = "dashed", lwd = 2)
points(beta_temp, pch = 16)


# Example showing how to incorporate an offset; simulate some count data
# with different means per series
set.seed(100)
dat &lt;- sim_mvgam(
  prop_trend = 0, mu = c(0, 2, 2),
  seasonality = "hierarchical"
)

# Add offset terms to the training and testing data
dat$data_train$offset &lt;- 0.5 * as.numeric(dat$data_train$series)
dat$data_test$offset &lt;- 0.5 * as.numeric(dat$data_test$series)

# Fit a model that includes the offset in the linear predictor as well as
# hierarchical seasonal smooths
mod &lt;- mvgam(
  formula = y ~ offset(offset) +
    s(series, bs = "re") +
    s(season, bs = "cc") +
    s(season, by = series, m = 1, k = 5),
  data = dat$data_train,
  chains = 2,
  silent = 2
)

# Inspect the model file to see the modification to the linear predictor
# (eta)
code(mod)

# Forecasts for the first two series will differ in magnitude
fc &lt;- forecast(mod, newdata = dat$data_test)
layout(matrix(1:2, ncol = 2))
plot(fc, series = 1, ylim = c(0, 75))
plot(fc, series = 2, ylim = c(0, 75))
layout(1)

# Changing the offset for the testing data should lead to changes in
# the forecast
dat$data_test$offset &lt;- dat$data_test$offset - 2
fc &lt;- forecast(mod, newdata = dat$data_test)
plot(fc)

# Relative Risks can be computed by fixing the offset to the same value
# for each series
dat$data_test$offset &lt;- rep(1, NROW(dat$data_test))
preds_rr &lt;- predict(mod,
  type = "link", newdata = dat$data_test,
  summary = FALSE
)
series1_inds &lt;- which(dat$data_test$series == "series_1")
series2_inds &lt;- which(dat$data_test$series == "series_2")

# Relative Risks are now more comparable among series
layout(matrix(1:2, ncol = 2))
plot(preds_rr[1, series1_inds],
  type = "l", col = "grey75",
  ylim = range(preds_rr),
  ylab = "Series1 Relative Risk", xlab = "Time"
)
for (i in 2:50) {
  lines(preds_rr[i, series1_inds], col = "grey75")
}

plot(preds_rr[1, series2_inds],
  type = "l", col = "darkred",
  ylim = range(preds_rr),
  ylab = "Series2 Relative Risk", xlab = "Time"
)
for (i in 2:50) {
  lines(preds_rr[i, series2_inds], col = "darkred")
}
layout(1)


# Example showcasing how cbind() is needed for Binomial observations
# Simulate two time series of Binomial trials
trials &lt;- sample(c(20:25), 50, replace = TRUE)
x &lt;- rnorm(50)
detprob1 &lt;- plogis(-0.5 + 0.9 * x)
detprob2 &lt;- plogis(-0.1 - 0.7 * x)
dat &lt;- rbind(
  data.frame(
    y = rbinom(n = 50, size = trials, prob = detprob1),
    time = 1:50,
    series = "series1",
    x = x,
    ntrials = trials
  ),
  data.frame(
    y = rbinom(n = 50, size = trials, prob = detprob2),
    time = 1:50,
    series = "series2",
    x = x,
    ntrials = trials
  )
)
dat &lt;- dplyr::mutate(dat, series = as.factor(series))
dat &lt;- dplyr::arrange(dat, time, series)
plot_mvgam_series(data = dat, series = "all")

# Fit a model using the binomial() family; must specify observations
# and number of trials in the cbind() wrapper
mod &lt;- mvgam(
  formula =
    cbind(y, ntrials) ~ series + s(x, by = series),
  family = binomial(),
  data = dat,
  chains = 2,
  silent = 2
)
summary(mod)
pp_check(mod,
  type = "bars_grouped",
  group = "series", ndraws = 50
)
pp_check(mod,
  type = "ecdf_overlay_grouped",
  group = "series", ndraws = 50
)
conditional_effects(mod, type = "link")

</code></pre>

<hr>
<h2 id='mvgam_diagnostics'>Extract diagnostic quantities of <span class="pkg">mvgam</span> models</h2><span id='topic+mvgam_diagnostics'></span><span id='topic+nuts_params'></span><span id='topic+rhat'></span><span id='topic+neff_ratio'></span><span id='topic+nuts_params.mvgam'></span><span id='topic+log_posterior.mvgam'></span><span id='topic+rhat.mvgam'></span><span id='topic+neff_ratio.mvgam'></span>

<h3>Description</h3>

<p>Extract quantities that can be used to diagnose sampling behavior
of the algorithms applied by <span class="pkg">Stan</span> at the back-end of <span class="pkg">mvgam</span>.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
nuts_params(object, pars = NULL, ...)

## S3 method for class 'mvgam'
log_posterior(object, ...)

## S3 method for class 'mvgam'
rhat(x, pars = NULL, ...)

## S3 method for class 'mvgam'
neff_ratio(object, pars = NULL, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mvgam_diagnostics_+3A_object">object</code>, <code id="mvgam_diagnostics_+3A_x">x</code></td>
<td>
<p>A <code>mvgam</code> or <code>jsdgam</code> object.</p>
</td></tr>
<tr><td><code id="mvgam_diagnostics_+3A_pars">pars</code></td>
<td>
<p>An optional character vector of parameter names.
For <code>nuts_params</code> these will be NUTS sampler parameter
names rather than model parameters. If pars is omitted
all parameters are included.</p>
</td></tr>
<tr><td><code id="mvgam_diagnostics_+3A_...">...</code></td>
<td>
<p>Arguments passed to individual methods.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For more details see
<code><a href="bayesplot.html#topic+bayesplot-extractors">bayesplot-extractors</a></code>.
</p>


<h3>Value</h3>

<p>The exact form of the output depends on the method.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
simdat &lt;- sim_mvgam(n_series = 1, trend_model = 'AR1')
mod &lt;- mvgam(y ~ s(season, bs = 'cc', k = 6),
            trend_model = AR(),
            noncentred = TRUE,
            data = simdat$data_train,
            chains = 2)
np &lt;- nuts_params(mod)
head(np)

# extract the number of divergence transitions
sum(subset(np, Parameter == "divergent__")$Value)

head(neff_ratio(mod))

</code></pre>

<hr>
<h2 id='mvgam_draws'>Extract posterior draws from fitted <span class="pkg">mvgam</span> objects</h2><span id='topic+mvgam_draws'></span><span id='topic+as.data.frame.mvgam'></span><span id='topic+as.matrix.mvgam'></span><span id='topic+as.array.mvgam'></span><span id='topic+as_draws.mvgam'></span><span id='topic+as_draws_matrix.mvgam'></span><span id='topic+as_draws_df.mvgam'></span><span id='topic+as_draws_array.mvgam'></span><span id='topic+as_draws_list.mvgam'></span><span id='topic+as_draws_rvars.mvgam'></span>

<h3>Description</h3>

<p>Extract posterior draws in conventional formats as data.frames, matrices, or arrays.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
as.data.frame(
  x,
  row.names = NULL,
  optional = TRUE,
  variable = "betas",
  use_alias = TRUE,
  regex = FALSE,
  ...
)

## S3 method for class 'mvgam'
as.matrix(x, variable = "betas", regex = FALSE, use_alias = TRUE, ...)

## S3 method for class 'mvgam'
as.array(x, variable = "betas", regex = FALSE, use_alias = TRUE, ...)

## S3 method for class 'mvgam'
as_draws(
  x,
  variable = NULL,
  regex = FALSE,
  inc_warmup = FALSE,
  use_alias = TRUE,
  ...
)

## S3 method for class 'mvgam'
as_draws_matrix(
  x,
  variable = NULL,
  regex = FALSE,
  inc_warmup = FALSE,
  use_alias = TRUE,
  ...
)

## S3 method for class 'mvgam'
as_draws_df(
  x,
  variable = NULL,
  regex = FALSE,
  inc_warmup = FALSE,
  use_alias = TRUE,
  ...
)

## S3 method for class 'mvgam'
as_draws_array(
  x,
  variable = NULL,
  regex = FALSE,
  inc_warmup = FALSE,
  use_alias = TRUE,
  ...
)

## S3 method for class 'mvgam'
as_draws_list(
  x,
  variable = NULL,
  regex = FALSE,
  inc_warmup = FALSE,
  use_alias = TRUE,
  ...
)

## S3 method for class 'mvgam'
as_draws_rvars(x, variable = NULL, regex = FALSE, inc_warmup = FALSE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mvgam_draws_+3A_x">x</code></td>
<td>
<p><code>list</code> object of class <code>mvgam</code></p>
</td></tr>
<tr><td><code id="mvgam_draws_+3A_row.names">row.names</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="mvgam_draws_+3A_optional">optional</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="mvgam_draws_+3A_variable">variable</code></td>
<td>
<p>A character specifying which parameters to extract. Can either be one of the
following options:
</p>

<ul>
<li> <p><code>obs_params</code> (other parameters specific to the observation model, such as overdispsersions
for negative binomial models or observation error SD for gaussian / student-t models)
</p>
</li>
<li> <p><code>betas</code> (beta coefficients from the GAM observation model linear predictor; default)
</p>
</li>
<li> <p><code>smooth_params</code> (smoothing parameters from the GAM observation model)
</p>
</li>
<li> <p><code>linpreds</code> (estimated linear predictors on whatever link scale was used in the model)
</p>
</li>
<li> <p><code>trend_params</code> (parameters governing the trend dynamics, such as AR parameters,
trend SD parameters or Gaussian Process parameters)
</p>
</li>
<li> <p><code>trend_betas</code> (beta coefficients from the GAM latent process model linear predictor;
only available if a <code>trend_formula</code> was supplied in the original model)
</p>
</li>
<li> <p><code>trend_smooth_params</code> (process model GAM smoothing parameters;
only available if a <code>trend_formula</code> was supplied in the original model)
</p>
</li>
<li> <p><code>trend_linpreds</code> (process model linear predictors on the identity scale;
only available if a <code>trend_formula</code> was supplied in the original model)</p>
</li></ul>
<p> OR can be a character vector
providing the variables to extract</p>
</td></tr>
<tr><td><code id="mvgam_draws_+3A_use_alias">use_alias</code></td>
<td>
<p>Logical. If more informative names for parameters are available
(i.e. for beta coefficients <code>b</code> or for smoothing parameters <code>rho</code>), replace the uninformative
names with the more informative alias. Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="mvgam_draws_+3A_regex">regex</code></td>
<td>
<p>Logical. If not using one of the prespecified options for extractions,
should <code>variable</code> be treated as a (vector of)
regular expressions? Any variable in x matching at least one of the regular expressions
will be selected. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="mvgam_draws_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="mvgam_draws_+3A_inc_warmup">inc_warmup</code></td>
<td>
<p>Should warmup draws be included? Defaults to <code>FALSE</code>.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>data.frame</code>, <code>matrix</code>, or <code>array</code> containing the posterior draws.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
sim &lt;- sim_mvgam(family = Gamma())
mod1 &lt;- mvgam(y ~ s(season, bs = 'cc'),
             trend_model = 'AR1',
             data = sim$data_train,
             family = Gamma(),
             chains = 2,
             silent = 2)
beta_draws_df &lt;- as.data.frame(mod1, variable = 'betas')
head(beta_draws_df)
str(beta_draws_df)

beta_draws_mat &lt;- as.matrix(mod1, variable = 'betas')
head(beta_draws_mat)
str(beta_draws_mat)

shape_pars &lt;- as.matrix(mod1, variable = 'shape', regex = TRUE)
head(shape_pars)
</code></pre>

<hr>
<h2 id='mvgam_families'>Supported <span class="pkg">mvgam</span> families</h2><span id='topic+mvgam_families'></span><span id='topic+tweedie'></span><span id='topic+student_t'></span><span id='topic+betar'></span><span id='topic+nb'></span><span id='topic+lognormal'></span><span id='topic+student'></span><span id='topic+bernoulli'></span><span id='topic+beta_binomial'></span><span id='topic+nmix'></span>

<h3>Description</h3>

<p>Supported <span class="pkg">mvgam</span> families
</p>


<h3>Usage</h3>

<pre><code class='language-R'>tweedie(link = "log")

student_t(link = "identity")

betar(...)

nb(...)

lognormal(...)

student(...)

bernoulli(...)

beta_binomial(...)

nmix(link = "log")
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mvgam_families_+3A_link">link</code></td>
<td>
<p>a specification for the family link function. At present these cannot
be changed</p>
</td></tr>
<tr><td><code id="mvgam_families_+3A_...">...</code></td>
<td>
<p>Arguments to be passed to the <span class="pkg">mgcv</span> version of the associated functions</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>mvgam</code> currently supports the following standard observation families:
</p>

<ul>
<li> <p><code><a href="stats.html#topic+gaussian">gaussian</a></code> with identity link, for real-valued data
</p>
</li>
<li> <p><code><a href="stats.html#topic+poisson">poisson</a></code> with log-link, for count data
</p>
</li>
<li> <p><code><a href="stats.html#topic+Gamma">Gamma</a></code> with log-link, for non-negative real-valued data
</p>
</li>
<li> <p><code><a href="stats.html#topic+binomial">binomial</a></code> with logit-link, for count data when the number
of trials is known (and must be supplied)
</p>
</li></ul>

<p>In addition, the following extended families from the <code>mgcv</code> and <code>brms</code> packages are supported:
</p>

<ul>
<li> <p><code><a href="mgcv.html#topic+betar">betar</a></code> with logit-link, for proportional data on <code style="white-space: pre;">&#8288;(0,1)&#8288;</code>
</p>
</li>
<li> <p><code><a href="mgcv.html#topic+nb">nb</a></code> with log-link, for count data
</p>
</li>
<li> <p><code><a href="brms.html#topic+lognormal">lognormal</a></code> with identity-link, for non-negative real-valued data
</p>
</li>
<li> <p><code><a href="brms.html#topic+bernoulli">bernoulli</a></code> with logit-link, for binary data
</p>
</li>
<li> <p><code><a href="brms.html#topic+beta_binomial">beta_binomial</a></code> with logit-link, as for <code>binomial()</code> but allows
for overdispersion
</p>
</li></ul>

<p>Finally, <code>mvgam</code> supports the three extended families described here:
</p>

<ul>
<li> <p><code>tweedie</code> with log-link, for count data (power parameter <code>p</code> fixed at <code>1.5</code>)
</p>
</li>
<li> <p><code>student_t()</code> (or <code><a href="brms.html#topic+student">student</a></code>) with identity-link, for real-valued data
</p>
</li>
<li> <p><code>nmix</code> for count data with imperfect detection modeled via a
State-Space N-Mixture model. The latent states are Poisson (with log link), capturing the 'true' latent
abundance, while the observation process is Binomial to account for imperfect detection. The
observation <code>formula</code> in these models is used to set up a linear predictor for the detection
probability (with logit link). See the example below for a more detailed worked explanation
of the <code>nmix()</code> family
</p>
</li></ul>

<p>Only <code>poisson()</code>, <code>nb()</code>, and <code>tweedie()</code> are available if
using <code>JAGS</code>. All families, apart from <code>tweedie()</code>, are supported if
using <code>Stan</code>.
</p>
<p>Note that currently it is not possible to change the default link
functions in <code>mvgam</code>, so any call to change these will be silently ignored
</p>


<h3>Value</h3>

<p>Objects of class <code>family</code>
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example showing how to set up N-mixture models
set.seed(999)
# Simulate observations for species 1, which shows a declining trend and 0.7 detection probability
data.frame(site = 1,
          # five replicates per year; six years
          replicate = rep(1:5, 6),
          time = sort(rep(1:6, 5)),
          species = 'sp_1',
          # true abundance declines nonlinearly
          truth = c(rep(28, 5),
                    rep(26, 5),
                    rep(23, 5),
                    rep(16, 5),
                    rep(14, 5),
                    rep(14, 5)),
          # observations are taken with detection prob = 0.7
          obs = c(rbinom(5, 28, 0.7),
                  rbinom(5, 26, 0.7),
                  rbinom(5, 23, 0.7),
                  rbinom(5, 15, 0.7),
                  rbinom(5, 14, 0.7),
                  rbinom(5, 14, 0.7))) %&gt;%
 # add 'series' information, which is an identifier of site, replicate and species
 dplyr::mutate(series = paste0('site_', site,
                               '_', species,
                               '_rep_', replicate),
               time = as.numeric(time),
               # add a 'cap' variable that defines the maximum latent N to
               # marginalize over when estimating latent abundance; in other words
               # how large do we realistically think the true abundance could be?
               cap = 80) %&gt;%
 dplyr::select(- replicate) -&gt; testdat

# Now add another species that has a different temporal trend and a smaller
# detection probability (0.45 for this species)
testdat = testdat %&gt;%
 dplyr::bind_rows(data.frame(site = 1,
                             replicate = rep(1:5, 6),
                             time = sort(rep(1:6, 5)),
                             species = 'sp_2',
                             truth = c(rep(4, 5),
                                       rep(7, 5),
                                       rep(15, 5),
                                       rep(16, 5),
                                       rep(19, 5),
                                       rep(18, 5)),
                             obs = c(rbinom(5, 4, 0.45),
                                     rbinom(5, 7, 0.45),
                                     rbinom(5, 15, 0.45),
                                     rbinom(5, 16, 0.45),
                                     rbinom(5, 19, 0.45),
                                     rbinom(5, 18, 0.45))) %&gt;%
                    dplyr::mutate(series = paste0('site_', site,
                                                  '_', species,
                                                  '_rep_', replicate),
                                  time = as.numeric(time),
                                  cap = 50) %&gt;%
                    dplyr::select(-replicate))

# series identifiers
testdat$species &lt;- factor(testdat$species,
                          levels = unique(testdat$species))
testdat$series &lt;- factor(testdat$series,
                         levels = unique(testdat$series))

# The trend_map to state how replicates are structured
testdat %&gt;%
# each unique combination of site*species is a separate process
dplyr::mutate(trend = as.numeric(factor(paste0(site, species)))) %&gt;%
 dplyr::select(trend, series) %&gt;%
 dplyr::distinct() -&gt; trend_map
trend_map

# Fit a model
mod &lt;- mvgam(
            # the observation formula sets up linear predictors for
            # detection probability on the logit scale
            formula = obs ~ species - 1,

            # the trend_formula sets up the linear predictors for
            # the latent abundance processes on the log scale
            trend_formula = ~ s(time, by = trend, k = 4) + species,

            # the trend_map takes care of the mapping
            trend_map = trend_map,

            # nmix() family and data
            family = nmix(),
            data = testdat,

            # priors can be set in the usual way
            priors = c(prior(std_normal(), class = b),
                       prior(normal(1, 1.5), class = Intercept_trend)),
            chains = 2)

# The usual diagnostics
summary(mod)

# Plotting conditional effects
library(ggplot2); library(marginaleffects)
plot_predictions(mod, condition = 'species',
                 type = 'detection') +
     ylab('Pr(detection)') +
     ylim(c(0, 1)) +
     theme_classic() +
     theme(legend.position = 'none')

# Example showcasing how cbind() is needed for Binomial observations
# Simulate two time series of Binomial trials
trials &lt;- sample(c(20:25), 50, replace = TRUE)
x &lt;- rnorm(50)
detprob1 &lt;- plogis(-0.5 + 0.9*x)
detprob2 &lt;- plogis(-0.1 -0.7*x)
dat &lt;- rbind(data.frame(y = rbinom(n = 50, size = trials, prob = detprob1),
                        time = 1:50,
                        series = 'series1',
                        x = x,
                        ntrials = trials),
             data.frame(y = rbinom(n = 50, size = trials, prob = detprob2),
                        time = 1:50,
                        series = 'series2',
                        x = x,
                        ntrials = trials))
dat &lt;- dplyr::mutate(dat, series = as.factor(series))
dat &lt;- dplyr::arrange(dat, time, series)

# Fit a model using the binomial() family; must specify observations
# and number of trials in the cbind() wrapper
mod &lt;- mvgam(cbind(y, ntrials) ~ series + s(x, by = series),
             family = binomial(),
             data = dat)
summary(mod)

</code></pre>

<hr>
<h2 id='mvgam_fevd-class'><code>mvgam_fevd</code> object description</h2><span id='topic+mvgam_fevd-class'></span>

<h3>Description</h3>

<p>A <code>mvgam_fevd</code> object returned by function <code><a href="#topic+fevd">fevd</a></code>.
Run <code>methods(class = "mvgam_fevd")</code> to see an overview of available methods.
</p>


<h3>Details</h3>

<p>A <code>mvgam_fevd</code> object contains a <code>list</code> of posterior forecast
error variance decompositions, each stored as
its own <code>list</code>
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>See Also</h3>

<p><a href="#topic+mvgam">mvgam</a>, <a href="#topic+VAR">VAR</a>
</p>

<hr>
<h2 id='mvgam_forecast-class'><code>mvgam_forecast</code> object description</h2><span id='topic+mvgam_forecast-class'></span>

<h3>Description</h3>

<p>A <code>mvgam_forecast</code> object returned by function <code><a href="#topic+hindcast">hindcast</a></code> or <code><a href="#topic+forecast">forecast</a></code>.
Run <code>methods(class = "mvgam_forecast")</code> to see an overview of available methods.
</p>


<h3>Details</h3>

<p>A <code>mvgam_forecast</code> object contains the following elements:
</p>

<ul>
<li> <p><code>call</code> the original observation model formula
</p>
</li>
<li> <p><code>trend_call</code> If a <code style="white-space: pre;">&#8288;trend_formula was supplied&#8288;</code>, the original trend model formula is
returned. Otherwise <code>NULL</code>
</p>
</li>
<li> <p><code>family</code> <code>character</code> description of the observation distribution
</p>
</li>
<li> <p><code>family_pars</code> <code>list</code> containing draws of family-specific parameters (i.e.
shape, scale or overdispersion parameters). Only returned if <code>type = link</code>. Otherwise <code>NULL</code>
</p>
</li>
<li> <p><code>trend_model</code> <code>character</code> description of the latent trend model
</p>
</li>
<li> <p><code>drift</code> Logical specifying whether a drift term was used in the trend model
</p>
</li>
<li> <p><code>use_lv</code> Logical flag indicating whether latent dynamic factors were used in the model
</p>
</li>
<li> <p><code>fit_engine</code> <code>Character</code> describing the fit engine, either as <code>stan</code> or <code>jags</code>
</p>
</li>
<li> <p><code>type</code> The type of predictions included (either <code>link</code>, <code>response</code> or <code>trend</code>)
</p>
</li>
<li> <p><code>series_names</code> Names of the time series, taken from <code>levels(data$series)</code> in the original
model fit
</p>
</li>
<li> <p><code>train_observations</code> A <code>list</code> of training observation vectors of length <code>n_series</code>
</p>
</li>
<li> <p><code>train_times</code> A <code>vector</code> of the unique training times
</p>
</li>
<li> <p><code>test_observations</code> If the <code><a href="#topic+forecast">forecast</a></code> function was used,
a <code>list</code> of test observation vectors of length <code>n_series</code>. Otherwise <code>NULL</code>
</p>
</li>
<li> <p><code>test_times</code> If the <code><a href="#topic+forecast">forecast</a></code> function was used, a
<code>vector</code> of the unique validation (testing) times. Otherwise <code>NULL</code>
</p>
</li>
<li> <p><code>hindcasts</code> A <code>list</code> of posterior hindcast distributions of length <code>n_series</code>.
</p>
</li>
<li> <p><code>forecasts</code> If the <code><a href="#topic+forecast">forecast</a></code> function was used,
a <code>list</code> of posterior forecast distributions of length <code>n_series</code>. Otherwise <code>NULL</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>See Also</h3>

<p><a href="#topic+mvgam">mvgam</a>, <a href="#topic+hindcast.mvgam">hindcast.mvgam</a>, <a href="#topic+forecast.mvgam">forecast.mvgam</a>
</p>

<hr>
<h2 id='mvgam_formulae'>Details of formula specifications in <span class="pkg">mvgam</span> models</h2><span id='topic+mvgam_formulae'></span>

<h3>Description</h3>

<p>Details of formula specifications in <span class="pkg">mvgam</span> models
</p>


<h3>Details</h3>

<p><code><a href="#topic+mvgam">mvgam</a></code> will accept an observation model formula and an optional
process model formula (via the argument <code>trend_formula</code>). Neither of these formulae can
be specified as lists, contrary to the accepted behaviour in some <code>mgcv</code> or <code>brms</code> models.
<br />
<br />
Note that it is possible to supply an empty formula where
there are no predictors or intercepts in the observation model (i.e. <code>y ~ 0</code> or <code>y ~ -1</code>).
In this case, an intercept-only observation model will be set up but the intercept coefficient
will be fixed at zero. This can be handy if you wish to fit pure State-Space models where
the variation in the dynamic trend controls the average expectation, and/or where intercepts
are non-identifiable.
<br />
<br />
The formulae supplied to <code><a href="#topic+mvgam">mvgam</a></code> and <code><a href="#topic+jsdgam">jsdgam</a></code>
are exactly like those supplied to
<code><a href="stats.html#topic+glm">glm</a></code> except that smooth terms,
<code><a href="mgcv.html#topic+s">s</a></code>,
<code><a href="mgcv.html#topic+te">te</a></code>,
<code><a href="mgcv.html#topic+ti">ti</a></code> and
<code><a href="mgcv.html#topic+t2">t2</a></code>,
time-varying effects using <code><a href="#topic+dynamic">dynamic</a></code>,
monotonically increasing (using <code>s(x, bs = 'moi')</code>)
or decreasing splines (using <code>s(x, bs = 'mod')</code>;
see <code><a href="#topic+smooth.construct.moi.smooth.spec">smooth.construct.moi.smooth.spec</a></code> for
details), as well as
Gaussian Process functions using <code><a href="brms.html#topic+gp">gp</a></code> and offsets using
<code><a href="stats.html#topic+offset">offset</a></code>
can be added to the right hand side (and <code>.</code> is not supported in <code>mvgam</code> formulae).
<br />
<br />
Further details on specifying different kinds of smooth functions, and how to control their behaviours
by modifying their potential complexities and / or how the penalties behave, can be found in the
extensive documentation for the <code>mgcv</code> package.
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+mvgam">mvgam</a></code>,
<code><a href="mgcv.html#topic+formula.gam">formula.gam</a></code>,
<code><a href="mgcv.html#topic+gam.models">gam.models</a></code>,
<code><a href="mgcv.html#topic+jagam">jagam</a></code>,
<code><a href="mgcv.html#topic+gam">gam</a></code>,
<code><a href="mgcv.html#topic+s">s</a></code>,
<code><a href="brms.html#topic+gp">gp</a></code>,
<code><a href="stats.html#topic+formula">formula</a></code>
</p>

<hr>
<h2 id='mvgam_irf-class'><code>mvgam_irf</code> object description</h2><span id='topic+mvgam_irf-class'></span>

<h3>Description</h3>

<p>A <code>mvgam_irf</code> object returned by function <code><a href="#topic+irf">irf</a></code>.
Run <code>methods(class = "mvgam_irf")</code> to see an overview of available methods.
</p>


<h3>Details</h3>

<p>A <code>mvgam_irf</code> object contains a <code>list</code> of posterior impulse response
functions, each stored as its own <code>list</code>
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>See Also</h3>

<p><a href="#topic+mvgam">mvgam</a>, <a href="#topic+VAR">VAR</a>
</p>

<hr>
<h2 id='mvgam_marginaleffects'>Helper functions for <span class="pkg">marginaleffects</span> calculations in <span class="pkg">mvgam</span> models</h2><span id='topic+mvgam_marginaleffects'></span><span id='topic+get_coef.mvgam'></span><span id='topic+set_coef.mvgam'></span><span id='topic+get_vcov.mvgam'></span><span id='topic+get_predict.mvgam'></span><span id='topic+get_data.mvgam'></span><span id='topic+get_data.mvgam_prefit'></span><span id='topic+find_predictors.mvgam'></span><span id='topic+find_predictors.mvgam_prefit'></span>

<h3>Description</h3>

<p>Helper functions for <span class="pkg">marginaleffects</span> calculations in <span class="pkg">mvgam</span> models
</p>
<p>Functions needed for working with <span class="pkg">marginaleffects</span>
</p>
<p>Functions needed for getting data / objects with <span class="pkg">insight</span>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
get_coef(model, trend_effects = FALSE, ...)

## S3 method for class 'mvgam'
set_coef(model, coefs, trend_effects = FALSE, ...)

## S3 method for class 'mvgam'
get_vcov(model, vcov = NULL, ...)

## S3 method for class 'mvgam'
get_predict(model, newdata, type = "response", process_error = FALSE, ...)

## S3 method for class 'mvgam'
get_data(x, source = "environment", verbose = TRUE, ...)

## S3 method for class 'mvgam_prefit'
get_data(x, source = "environment", verbose = TRUE, ...)

## S3 method for class 'mvgam'
find_predictors(
  x,
  effects = c("fixed", "random", "all"),
  component = c("all", "conditional", "zi", "zero_inflated", "dispersion", "instruments",
    "correlation", "smooth_terms"),
  flatten = FALSE,
  verbose = TRUE,
  ...
)

## S3 method for class 'mvgam_prefit'
find_predictors(
  x,
  effects = c("fixed", "random", "all"),
  component = c("all", "conditional", "zi", "zero_inflated", "dispersion", "instruments",
    "correlation", "smooth_terms"),
  flatten = FALSE,
  verbose = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="mvgam_marginaleffects_+3A_model">model</code></td>
<td>
<p>Model object</p>
</td></tr>
<tr><td><code id="mvgam_marginaleffects_+3A_trend_effects">trend_effects</code></td>
<td>
<p><code>logical</code>, extract from the process model component
(only applicable if a <code>trend_formula</code> was specified in the model)</p>
</td></tr>
<tr><td><code id="mvgam_marginaleffects_+3A_...">...</code></td>
<td>
<p>Additional arguments are passed to the <code>predict()</code> method
supplied by the modeling package.These arguments are particularly useful
for mixed-effects or bayesian models (see the online vignettes on the
<code>marginaleffects</code> website). Available arguments can vary from model to
model, depending on the range of supported arguments by each modeling
package. See the &quot;Model-Specific Arguments&quot; section of the
<code>?slopes</code> documentation for a non-exhaustive list of available
arguments.</p>
</td></tr>
<tr><td><code id="mvgam_marginaleffects_+3A_coefs">coefs</code></td>
<td>
<p>vector of coefficients to insert in the model object</p>
</td></tr>
<tr><td><code id="mvgam_marginaleffects_+3A_vcov">vcov</code></td>
<td>
<p>Type of uncertainty estimates to report (e.g., for robust standard errors). Acceptable values:
</p>

<ul>
<li><p> FALSE: Do not compute standard errors. This can speed up computation considerably.
</p>
</li>
<li><p> TRUE: Unit-level standard errors using the default <code>vcov(model)</code> variance-covariance matrix.
</p>
</li>
<li><p> String which indicates the kind of uncertainty estimates to return.
</p>

<ul>
<li><p> Heteroskedasticity-consistent: <code>"HC"</code>, <code>"HC0"</code>, <code>"HC1"</code>, <code>"HC2"</code>, <code>"HC3"</code>, <code>"HC4"</code>, <code>"HC4m"</code>, <code>"HC5"</code>. See <code>?sandwich::vcovHC</code>
</p>
</li>
<li><p> Heteroskedasticity and autocorrelation consistent: <code>"HAC"</code>
</p>
</li>
<li><p> Mixed-Models degrees of freedom: &quot;satterthwaite&quot;, &quot;kenward-roger&quot;
</p>
</li>
<li><p> Other: <code>"NeweyWest"</code>, <code>"KernHAC"</code>, <code>"OPG"</code>. See the <code>sandwich</code> package documentation.
</p>
</li></ul>

</li>
<li><p> One-sided formula which indicates the name of cluster variables (e.g., <code>~unit_id</code>). This formula is passed to the <code>cluster</code> argument of the <code>sandwich::vcovCL</code> function.
</p>
</li>
<li><p> Square covariance matrix
</p>
</li>
<li><p> Function which returns a covariance matrix (e.g., <code>stats::vcov(model)</code>)
</p>
</li></ul>
</td></tr>
<tr><td><code id="mvgam_marginaleffects_+3A_newdata">newdata</code></td>
<td>
<p>Grid of predictor values at which we evaluate the slopes.
</p>

<ul>
<li><p> Warning: Please avoid modifying your dataset between fitting the model and calling a <code>marginaleffects</code> function. This can sometimes lead to unexpected results.
</p>
</li>
<li> <p><code>NULL</code> (default): Unit-level slopes for each observed value in the dataset (empirical distribution). The dataset is retrieved using <code><a href="insight.html#topic+get_data">insight::get_data()</a></code>, which tries to extract data from the environment. This may produce unexpected results if the original data frame has been altered since fitting the model.
</p>
</li>
<li> <p><code><a href="marginaleffects.html#topic+datagrid">datagrid()</a></code> call to specify a custom grid of regressors. For example:
</p>

<ul>
<li> <p><code>newdata = datagrid(cyl = c(4, 6))</code>: <code>cyl</code> variable equal to 4 and 6 and other regressors fixed at their means or modes.
</p>
</li>
<li><p> See the Examples section and the <code><a href="marginaleffects.html#topic+datagrid">datagrid()</a></code> documentation.
</p>
</li></ul>

</li>
<li> <p><code><a href="base.html#topic+subset">subset()</a></code> call with a single argument to select a subset of the dataset used to fit the model, ex: <code>newdata = subset(treatment == 1)</code>
</p>
</li>
<li> <p><code><a href="dplyr.html#topic+filter">dplyr::filter()</a></code> call with a single argument to select a subset of the dataset used to fit the model, ex: <code>newdata = filter(treatment == 1)</code>
</p>
</li>
<li><p> string:
</p>

<ul>
<li><p> &quot;mean&quot;: Slopes evaluated when each predictor is held at its mean or mode.
</p>
</li>
<li><p> &quot;median&quot;: Slopes evaluated when each predictor is held at its median or mode.
</p>
</li>
<li><p> &quot;balanced&quot;: Slopes evaluated on a balanced grid with every combination of categories and numeric variables held at their means.
</p>
</li>
<li><p> &quot;tukey&quot;: Slopes evaluated at Tukey's 5 numbers.
</p>
</li>
<li><p> &quot;grid&quot;: Slopes evaluated on a grid of representative numbers (Tukey's 5 numbers and unique values of categorical predictors).
</p>
</li></ul>

</li></ul>
</td></tr>
<tr><td><code id="mvgam_marginaleffects_+3A_type">type</code></td>
<td>
<p>string indicates the type (scale) of the predictions used to
compute contrasts or slopes. This can differ based on the model
type, but will typically be a string such as: &quot;response&quot;, &quot;link&quot;, &quot;probs&quot;,
or &quot;zero&quot;. When an unsupported string is entered, the model-specific list of
acceptable values is returned in an error message. When <code>type</code> is <code>NULL</code>, the
first entry in the error message is used by default.</p>
</td></tr>
<tr><td><code id="mvgam_marginaleffects_+3A_process_error">process_error</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, uncertainty in the latent
process (or trend) model is incorporated in predictions</p>
</td></tr>
<tr><td><code id="mvgam_marginaleffects_+3A_x">x</code></td>
<td>
<p>A fitted model.</p>
</td></tr>
<tr><td><code id="mvgam_marginaleffects_+3A_source">source</code></td>
<td>
<p>String, indicating from where data should be recovered. If
<code>source = "environment"</code> (default), data is recovered from the environment
(e.g. if the data is in the workspace). This option is usually the fastest
way of getting data and ensures that the original variables used for model
fitting are returned. Note that always the <em>current</em> data is recovered from
the environment. Hence, if the data was modified <em>after</em> model fitting
(e.g., variables were recoded or rows filtered), the returned data may no
longer equal the model data. If <code>source = "frame"</code> (or <code>"mf"</code>), the data
is taken from the model frame. Any transformed variables are back-transformed,
if possible. This option returns the data even if it is not available in
the environment, however, in certain edge cases back-transforming to the
original data may fail. If <code>source = "environment"</code> fails to recover the
data, it tries to extract the data from the model frame; if
<code>source = "frame"</code> and data cannot be extracted from the model frame, data
will be recovered from the environment. Both ways only returns observations
that have no missing data in the variables used for model fitting.</p>
</td></tr>
<tr><td><code id="mvgam_marginaleffects_+3A_verbose">verbose</code></td>
<td>
<p>Toggle messages and warnings.</p>
</td></tr>
<tr><td><code id="mvgam_marginaleffects_+3A_effects">effects</code></td>
<td>
<p>Should model data for fixed effects (<code>"fixed"</code>), random
effects (<code>"random"</code>) or both (<code>"all"</code>) be returned? Only applies to mixed
or gee models.</p>
</td></tr>
<tr><td><code id="mvgam_marginaleffects_+3A_component">component</code></td>
<td>
<p>Which type of parameters to return, such as parameters for
the conditional model, the zero-inflated part of the model, the dispersion
term, the instrumental variables or marginal effects be returned? Applies to
models with zero-inflated and/or dispersion formula, or to models with
instrumental variables (so called fixed-effects regressions), or models with
marginal effects (from <strong>mfx</strong>). See details in section <em>Model Components</em>
.May be abbreviated. Note that the <em>conditional</em> component also refers to the
<em>count</em> or <em>mean</em> component - names may differ, depending on the modeling
package. There are three convenient shortcuts (not applicable to <em>all</em> model
classes):
</p>

<ul>
<li> <p><code>component = "all"</code> returns all possible parameters.
</p>
</li>
<li><p> If <code>component = "location"</code>, location parameters such as <code>conditional</code>,
<code>zero_inflated</code>, <code>smooth_terms</code>, or <code>instruments</code> are returned (everything
that are fixed or random effects - depending on the <code>effects</code> argument -
but no auxiliary parameters).
</p>
</li>
<li><p> For <code>component = "distributional"</code> (or <code>"auxiliary"</code>), components like
<code>sigma</code>, <code>dispersion</code>, <code>beta</code> or <code>precision</code> (and other auxiliary
parameters) are returned.
</p>
</li></ul>
</td></tr>
<tr><td><code id="mvgam_marginaleffects_+3A_flatten">flatten</code></td>
<td>
<p>Logical, if <code>TRUE</code>, the values are returned as character
vector, not as list. Duplicated values are removed.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>Objects suitable for internal 'marginaleffects' functions to proceed.
See <code><a href="marginaleffects.html#topic+get_coef">marginaleffects::get_coef()</a></code>, <code><a href="marginaleffects.html#topic+set_coef">marginaleffects::set_coef()</a></code>,
<code><a href="marginaleffects.html#topic+get_vcov">marginaleffects::get_vcov()</a></code>, <code><a href="marginaleffects.html#topic+get_predict">marginaleffects::get_predict()</a></code>,
<code><a href="insight.html#topic+get_data">insight::get_data()</a></code> and <code><a href="insight.html#topic+find_predictors">insight::find_predictors()</a></code> for details
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>

<hr>
<h2 id='mvgam_trends'>Supported latent trend models in <span class="pkg">mvgam</span></h2><span id='topic+mvgam_trends'></span>

<h3>Description</h3>

<p>Supported latent trend models in <span class="pkg">mvgam</span>
</p>


<h3>Details</h3>

<p><code>mvgam</code> currently supports the following dynamic trend models:
</p>

<ul>
<li> <p><code>None</code> (no latent trend component; i.e. the GAM component is all that contributes to the linear predictor,
and the observation process is the only source of error; similarly to what is estimated by <code><a href="mgcv.html#topic+gam">gam</a></code>)
</p>
</li>
<li> <p><code>ZMVN()</code> (zero-mean correlated errors, useful for modelling time series where no
autoregressive terms are needed or for modelling data that are not sampled as time series)
</p>
</li>
<li> <p><code>RW()</code>
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;AR(p = 1, 2, or 3)&#8288;</code>
</p>
</li>
<li> <p><code>CAR(p = 1)</code>(continuous time autoregressive trends; only available in <code>Stan</code>)
</p>
</li>
<li> <p><code>VAR()</code>(only available in <code>Stan</code>)
</p>
</li>
<li> <p><code>PW()</code> (piecewise linear or logistic trends; only available in <code>Stan</code>)
</p>
</li>
<li> <p><code>GP()</code> (Gaussian Process with squared exponential kernel;
only available in <code>Stan</code>)</p>
</li></ul>

<p>For most dynamic trend types available in <code>mvgam</code> (see argument <code>trend_model</code>), time should be
measured in discrete, regularly spaced intervals (i.e. <code>c(1, 2, 3, ...)</code>). However you can
use irregularly spaced intervals if using <code>trend_model = CAR(1)</code>, though note that any
temporal intervals that are exactly <code>0</code> will be adjusted to a very small number
(<code>1e-12</code>) to prevent sampling errors. For all autoregressive trend types
apart from <code>CAR()</code>, moving average and/or correlated
process error terms can also be estimated (for example, <code>RW(cor = TRUE)</code> will set up a
multivariate Random Walk if <code>data</code> contains <code style="white-space: pre;">&#8288;&gt;1&#8288;</code> series). Hierarchical process error correlations
can also be handled if the data contain relevant observation units that are nested into
relevant grouping and subgrouping levels (i.e. using <code>AR(gr = region, subgr = species)</code>)
</p>
<p>Note that only <code>RW</code>, <code>AR1</code>, <code>AR2</code> and <code>AR3</code> are available if
using <code>JAGS</code>. All trend models are supported if using <code>Stan</code>.
Dynamic factor models can be used in which the latent factors evolve as either
<code>RW</code>, <code>AR1-3</code>, <code>VAR</code> or <code>GP</code>. For <code>VAR</code> models
(i.e. <code>VAR</code> and <code>VARcor</code> models), users can either fix the trend error covariances to be <code>0</code>
(using <code>VAR</code>) or estimate them and potentially allow for contemporaneously correlated errors using
<code>VARcor</code>. For all <code>VAR</code> models, stationarity of
the latent process is enforced through the prior using the parameterisation given by
Heaps (2022). Stationarity is not enforced when using <code>AR1</code>, <code>AR2</code> or <code>AR3</code> models,
though this can be changed by the user by specifying lower and upper bounds on autoregressive
parameters using functionality in <a href="#topic+get_mvgam_priors">get_mvgam_priors</a> and the <code>priors</code> argument in
<a href="#topic+mvgam">mvgam</a>. Piecewise trends follow the formulation in the popular <code>prophet</code> package produced
by <code>Facebook</code>, where users can allow for changepoints to control the potential flexibility
of the trend. See Taylor and Letham (2018) for details
</p>


<h3>References</h3>

<p>Sarah E. Heaps (2022) Enforcing stationarity through the prior in Vector Autoregressions.
Journal of Computational and Graphical Statistics. 32:1, 1-10.
</p>
<p>Sean J. Taylor and Benjamin Letham (2018) Forecasting at scale.
The American Statistician 72.1, 37-45.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+RW">RW</a></code>, <code><a href="#topic+AR">AR</a></code>, <code><a href="#topic+CAR">CAR</a></code>,
<code><a href="#topic+VAR">VAR</a></code>, <code><a href="#topic+PW">PW</a></code>, <code><a href="#topic+GP">GP</a></code>, <code><a href="#topic+ZMVN">ZMVN</a></code>
</p>

<hr>
<h2 id='mvgam-class'>Fitted <code>mvgam</code> object description</h2><span id='topic+mvgam-class'></span>

<h3>Description</h3>

<p>A fitted <code>mvgam</code> object returned by function <code><a href="#topic+mvgam">mvgam</a></code>.
Run <code>methods(class = "mvgam")</code> to see an overview of available methods.
</p>


<h3>Details</h3>

<p>A <code>mvgam</code> object contains the following elements:
</p>

<ul>
<li> <p><code>call</code> the original observation model formula
</p>
</li>
<li> <p><code>trend_call</code> If a <code style="white-space: pre;">&#8288;trend_formula was supplied&#8288;</code>, the original trend model formula is
returned. Otherwise <code>NULL</code>
</p>
</li>
<li> <p><code>family</code> <code>character</code> description of the observation distribution
</p>
</li>
<li> <p><code>trend_model</code> <code>character</code> description of the latent trend model
</p>
</li>
<li> <p><code>trend_map</code> <code>data.frame</code> describing the mapping of trend states to
observations, if supplied in the original model. Otherwise <code>NULL</code>
</p>
</li>
<li> <p><code>drift</code> Logical specifying whether a drift term was used in the trend model
</p>
</li>
<li> <p><code>priors</code> If the model priors were updated from their defaults, the prior <code>dataframe</code>
will be returned. Otherwise <code>NULL</code>
</p>
</li>
<li> <p><code>model_output</code> The <code>MCMC</code> object returned by the fitting engine. If the model was fitted
using <code>Stan</code>, this will be an object of class <code>stanfit</code> (see <code><a href="rstan.html#topic+stanfit-class">stanfit-class</a></code> for details).
If <code>JAGS</code> was used as the backend, this will be an object of class <code>runjags</code>
(see <code><a href="runjags.html#topic+runjags-class">runjags-class</a></code> for details)
</p>
</li>
<li> <p><code>model_file</code> The <code>character</code> string model file used to describe the model in either
<code>Stan</code> or <code>JAGS</code> syntax
</p>
</li>
<li> <p><code>model_data</code> If <code>return_model_data</code> was set to <code>TRUE</code> when fitting the model, the <code>list</code> object
containing all data objects needed to condition the model is returned. Each item in the <code>list</code> is described
in detail at the top of the <code>model_file</code>. Otherwise <code>NULL</code>
</p>
</li>
<li> <p><code>inits</code> If <code>return_model_data</code> was set to <code>TRUE</code> when fitting the model, the initial value
functions used to initialise the MCMC chains will be returned. Otherwise <code>NULL</code>
</p>
</li>
<li> <p><code>monitor_pars</code> The parameters
that were monitored during MCMC sampling are returned as a <code style="white-space: pre;">&#8288;character vector&#8288;</code>
</p>
</li>
<li> <p><code>sp_names</code> A <code style="white-space: pre;">&#8288;character vector&#8288;</code> specifying the names for each smoothing parameter
</p>
</li>
<li> <p><code>mgcv_model</code> An object of class <code>gam</code> containing the <code>mgcv</code> version of the observation model.
This object is used for generating the linear predictor matrix when making predictions for new data. The
coefficients in this model object will contain the posterior median coefficients from the GAM linear predictor,
but these are only used if generating plots of smooth functions that <code>mvgam</code> currently cannot handle
(such as plots for three-dimensional smooths). This model therefore should not be used for inference.
See <code><a href="mgcv.html#topic+gamObject">gamObject</a></code> for details
</p>
</li>
<li> <p><code>trend_mgcv_model</code> If a <code style="white-space: pre;">&#8288;trend_formula was supplied&#8288;</code>, an object of class <code>gam</code> containing
the <code>mgcv</code> version of the trend model. Otherwise <code>NULL</code>
</p>
</li>
<li> <p><code>ytimes</code> The <code>matrix</code> object used in model fitting for indexing which series and timepoints
were observed in each row of the supplied data. Used internally by some downstream plotting
and prediction functions
</p>
</li>
<li> <p><code>resids</code> A named <code>list</code> object containing posterior draws of Dunn-Smyth
randomized quantile residuals
</p>
</li>
<li> <p><code>use_lv</code> Logical flag indicating whether latent dynamic factors were used in the model
</p>
</li>
<li> <p><code>n_lv</code> If <code>use_lv == TRUE</code>, the number of latent dynamic factors used in the model
</p>
</li>
<li> <p><code>upper_bounds</code> If bounds were supplied in the original model fit, they will be returned.
Otherwise <code>NULL</code>
</p>
</li>
<li> <p><code>obs_data</code> The original data object (either a <code>list</code> or <code>dataframe</code>) supplied in model
fitting.
</p>
</li>
<li> <p><code>test_data</code> If test data were supplied (as argument <code>newdata</code> in the original model), it
will be returned. Othwerise <code>NULL</code>
</p>
</li>
<li> <p><code>fit_engine</code> <code>Character</code> describing the fit engine, either as <code>stan</code> or <code>jags</code>
</p>
</li>
<li> <p><code>backend</code> <code>Character</code> describing the backend used for modelling, either as <code>rstan</code>, <code>cmdstanr</code> or <code>rjags</code>
</p>
</li>
<li> <p><code>algorithm</code> <code>Character</code> describing the algorithm used for finding the posterior,
either as <code>sampling</code>, <code>laplace</code>, <code>pathfinder</code>, <code>meanfield</code> or <code>fullrank</code>
</p>
</li>
<li> <p><code>max_treedepth</code> If the model was fitted using <code>Stan</code>, the value supplied for the maximum
treedepth tuning parameter is returned (see <code><a href="rstan.html#topic+stan">stan</a></code> for details).
Otherwise <code>NULL</code>
</p>
</li>
<li> <p><code>adapt_delta</code> If the model was fitted using <code>Stan</code>, the value supplied for the adapt_delta
tuning parameter is returned (see <code><a href="rstan.html#topic+stan">stan</a></code> for details).
Otherwise <code>NULL</code>
</p>
</li></ul>



<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>See Also</h3>

<p><a href="#topic+mvgam">mvgam</a>
</p>

<hr>
<h2 id='pairs.mvgam'>Create a matrix of output plots from a <code>mvgam</code> object</h2><span id='topic+pairs.mvgam'></span>

<h3>Description</h3>

<p>A <code><a href="graphics.html#topic+pairs">pairs</a></code>
method that is customized for MCMC output.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
pairs(x, variable = NULL, regex = FALSE, use_alias = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pairs.mvgam_+3A_x">x</code></td>
<td>
<p>An object of class <code>mvgam</code> or <code>jsdgam</code></p>
</td></tr>
<tr><td><code id="pairs.mvgam_+3A_variable">variable</code></td>
<td>
<p>Names of the variables (parameters) to plot, as given by a
character vector or a regular expression (if <code>regex = TRUE</code>). By
default, a hopefully not too large selection of variables is plotted.</p>
</td></tr>
<tr><td><code id="pairs.mvgam_+3A_regex">regex</code></td>
<td>
<p>Logical; Indicates whether <code>variable</code> should
be treated as regular expressions. Defaults to <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="pairs.mvgam_+3A_use_alias">use_alias</code></td>
<td>
<p>Logical. If more informative names for parameters are available
(i.e. for beta coefficients <code>b</code> or for smoothing parameters <code>rho</code>), replace the uninformative
names with the more informative alias. Defaults to <code>TRUE</code></p>
</td></tr>
<tr><td><code id="pairs.mvgam_+3A_...">...</code></td>
<td>
<p>Further arguments to be passed to
<code><a href="bayesplot.html#topic+MCMC-scatterplots">mcmc_pairs</a></code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>For a detailed description see
<code><a href="bayesplot.html#topic+MCMC-scatterplots">mcmc_pairs</a></code>.
</p>


<h3>Value</h3>

<p>Plottable objects whose classes depend on the arguments supplied.
See <code><a href="bayesplot.html#topic+MCMC-scatterplots">mcmc_pairs</a></code> for details.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
simdat &lt;- sim_mvgam(n_series = 1, trend_model = 'AR1')
mod &lt;- mvgam(y ~ s(season, bs = 'cc'),
             trend_model = AR(),
             noncentred = TRUE,
             data = simdat$data_train,
             chains = 2)
pairs(mod)
pairs(mod, variable = c('ar1', 'sigma'), regex = TRUE)


</code></pre>

<hr>
<h2 id='plot_mvgam_factors'>Latent factor summaries for a fitted <span class="pkg">mvgam</span> object</h2><span id='topic+plot_mvgam_factors'></span>

<h3>Description</h3>

<p>This function takes a fitted <code>mvgam</code> object and returns plots and summary statistics for
the latent dynamic factors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_mvgam_factors(object, plot = TRUE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_mvgam_factors_+3A_object">object</code></td>
<td>
<p><code>list</code> object returned from <code>mvgam</code>. See <code><a href="#topic+mvgam">mvgam()</a></code></p>
</td></tr>
<tr><td><code id="plot_mvgam_factors_+3A_plot">plot</code></td>
<td>
<p><code>logical</code> specifying whether factors should be plotted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>If the model in <code>object</code> was estimated using dynamic factors, it is possible that not all factors
contributed to the estimated trends. This is due to the regularisation penalty that acts independently on each
factor's Gaussian precision, which will squeeze un-needed factors to a white noise process (effectively dropping
that factor from the model). In this function, each factor is tested against a null hypothesis of white noise by
calculating the sum of the factor's 2nd derivatives. A factor that has a larger contribution will have a larger
sum due to the weaker penalty on the factor's precision. If
<code>plot == TRUE</code>, the factors are also plotted.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> of factor contributions and,
optionally, a <code>ggplot</code> object
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
simdat &lt;- sim_mvgam()
mod &lt;- mvgam(y ~ s(season, bs = 'cc',
                  k = 6),
            trend_model = AR(),
            use_lv = TRUE,
            n_lv = 2,
            data = simdat$data_train,
            chains = 2,
            silent = 2)
plot_mvgam_factors(mod)

</code></pre>

<hr>
<h2 id='plot_mvgam_forecasts'>Plot posterior forecast predictions from <span class="pkg">mvgam</span> models</h2><span id='topic+plot_mvgam_forecasts'></span><span id='topic+plot_mvgam_fc'></span><span id='topic+plot.mvgam_forecast'></span>

<h3>Description</h3>

<p>Plot posterior forecast predictions from <span class="pkg">mvgam</span> models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_mvgam_fc(
  object,
  series = 1,
  newdata,
  data_test,
  realisations = FALSE,
  n_realisations = 15,
  hide_xlabels = FALSE,
  xlab,
  ylab,
  ylim,
  n_cores = 1,
  return_forecasts = FALSE,
  return_score = FALSE,
  ...
)

## S3 method for class 'mvgam_forecast'
plot(
  x,
  series = 1,
  realisations = FALSE,
  n_realisations = 15,
  xlab,
  ylab,
  ylim,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_mvgam_forecasts_+3A_object">object</code></td>
<td>
<p><code>list</code> object of class <code>mvgam</code>. See <code><a href="#topic+mvgam">mvgam()</a></code></p>
</td></tr>
<tr><td><code id="plot_mvgam_forecasts_+3A_series">series</code></td>
<td>
<p><code>integer</code> specifying which series in the set is to be plotted</p>
</td></tr>
<tr><td><code id="plot_mvgam_forecasts_+3A_newdata">newdata</code></td>
<td>
<p>Optional <code>dataframe</code> or <code>list</code> of test data containing at least 'series' and 'time'
in addition to any other variables included in the linear predictor of the original <code>formula</code>. If included, the
covariate information in <code>newdata</code> will be used to generate forecasts from the fitted model equations. If
this same <code>newdata</code> was originally included in the call to <code>mvgam</code>, then forecasts have already been
produced by the generative model and these will simply be extracted and plotted. However if no <code>newdata</code> was
supplied to the original model call, an assumption is made that the <code>newdata</code> supplied here comes sequentially
after the data supplied as <code>data</code> in the original model (i.e. we assume there is no time gap between the last
observation of series 1 in <code>data</code> and the first observation for series 1 in <code>newdata</code>). If
<code>newdata</code> contains observations in column <code>y</code>, these observations will be used to compute a Discrete Rank
Probability Score for the forecast distribution</p>
</td></tr>
<tr><td><code id="plot_mvgam_forecasts_+3A_data_test">data_test</code></td>
<td>
<p>Deprecated. Still works in place of <code>newdata</code> but users are recommended to use
<code>newdata</code> instead for more seamless integration into <code>R</code> workflows</p>
</td></tr>
<tr><td><code id="plot_mvgam_forecasts_+3A_realisations">realisations</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, forecast realisations are shown as a spaghetti plot,
making it easier to visualise the diversity of possible forecasts. If <code>FALSE</code>, the default,
empirical quantiles of the forecast distribution are shown</p>
</td></tr>
<tr><td><code id="plot_mvgam_forecasts_+3A_n_realisations">n_realisations</code></td>
<td>
<p><code>integer</code> specifying the number of posterior realisations to plot, if
<code>realisations = TRUE</code>. Ignored otherwise</p>
</td></tr>
<tr><td><code id="plot_mvgam_forecasts_+3A_hide_xlabels">hide_xlabels</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, no xlabels are printed to allow the user to add custom labels using
<code>axis</code> from base <code>R</code></p>
</td></tr>
<tr><td><code id="plot_mvgam_forecasts_+3A_xlab">xlab</code></td>
<td>
<p>label for x axis.</p>
</td></tr>
<tr><td><code id="plot_mvgam_forecasts_+3A_ylab">ylab</code></td>
<td>
<p>label for y axis.</p>
</td></tr>
<tr><td><code id="plot_mvgam_forecasts_+3A_ylim">ylim</code></td>
<td>
<p>Optional <code>vector</code> of y-axis limits (min, max)</p>
</td></tr>
<tr><td><code id="plot_mvgam_forecasts_+3A_n_cores">n_cores</code></td>
<td>
<p><code>integer</code> specifying number of cores for generating forecasts in parallel</p>
</td></tr>
<tr><td><code id="plot_mvgam_forecasts_+3A_return_forecasts">return_forecasts</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, the function will plot the forecast
as well as returning the forecast object (as a <code>matrix</code> of dimension <code>n_samples</code> x <code>horizon</code>)</p>
</td></tr>
<tr><td><code id="plot_mvgam_forecasts_+3A_return_score">return_score</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code> and out of sample test data is provided as
<code>newdata</code>, a probabilistic score will be calculated and returned. The score used will depend on the
observation family from the fitted model. Discrete families (<code>poisson</code>, <code>negative binomial</code>, <code>tweedie</code>)
use the Discrete Rank Probability Score. Other families use the Continuous Rank Probability Score. The value
returned is the <code>sum</code> of all scores within the out of sample forecast horizon</p>
</td></tr>
<tr><td><code id="plot_mvgam_forecasts_+3A_...">...</code></td>
<td>
<p>further <code><a href="graphics.html#topic+par">par</a></code> graphical parameters.</p>
</td></tr>
<tr><td><code id="plot_mvgam_forecasts_+3A_x">x</code></td>
<td>
<p>Object of class <code>mvgam_forecast</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>plot_mvgam_fc</code> generates posterior predictions from an object of class <code>mvgam</code>, calculates posterior
empirical quantiles and plots them against the observed data. If <code>realisations = FALSE</code>, the returned plot shows
90, 60, 40 and 20 percent posterior quantiles (as ribbons of increasingly darker shades or red)
as well as the posterior median (as a dark red line). If <code>realisations = FALSE</code>, a set of <code>n_realisations</code> posterior
draws are shown. This function produces an older style base <code>R</code> plot, as opposed to <code>plot.mvgam_forecast</code>
</p>
<p><code>plot.mvgam_forecast</code> takes an object of class <code>mvgam_forecast</code>, in which forecasts have already
been computed, and plots the resulting forecast distribution as a <code>ggplot</code> object. This function is therefore more
versatile and is recommended over the older and clunkier <code>plot_mvgam_fc</code> version
</p>
<p>If <code>realisations = FALSE</code>, these posterior quantiles are plotted along
with the true observed data that was used to train the model. Otherwise, a spaghetti plot is returned
to show possible forecast paths.
</p>


<h3>Value</h3>

<p>A base <code>R</code> graphics plot (for <code>plot_mvgam_fc</code>) or a <code>ggplot</code> object (for <code>plot.mvgam_forecast</code>) and an optional <code>list</code> containing the forecast distribution
and the out of sample probabilistic forecast score
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
simdat &lt;- sim_mvgam(n_series = 3, trend_model = AR())
mod &lt;- mvgam(y ~ s(season, bs = 'cc', k = 6),
            trend_model = AR(),
            noncentred = TRUE,
            data = simdat$data_train,
            chains = 2,
            silent = 2)

# Hindcasts on response scale
hc &lt;- hindcast(mod)
str(hc)
plot(hc, series = 1)
plot(hc, series = 2)
plot(hc, series = 3)

# Forecasts on response scale
fc &lt;- forecast(mod, newdata = simdat$data_test)
str(fc)
plot(fc, series = 1)
plot(fc, series = 2)
plot(fc, series = 3)

# Forecasts as expectations
fc &lt;- forecast(mod, newdata = simdat$data_test, type = 'expected')
plot(fc, series = 1)
plot(fc, series = 2)
plot(fc, series = 3)

# Dynamic trend extrapolations
fc &lt;- forecast(mod, newdata = simdat$data_test, type = 'trend')
plot(fc, series = 1)
plot(fc, series = 2)
plot(fc, series = 3)

</code></pre>

<hr>
<h2 id='plot_mvgam_pterms'>Plot parametric term partial effects for <span class="pkg">mvgam</span> models</h2><span id='topic+plot_mvgam_pterms'></span>

<h3>Description</h3>

<p>This function plots posterior empirical quantiles for partial effects of parametric terms
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_mvgam_pterms(object, trend_effects = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_mvgam_pterms_+3A_object">object</code></td>
<td>
<p><code>list</code> object of class <code>mvgam</code>. See <code><a href="#topic+mvgam">mvgam()</a></code></p>
</td></tr>
<tr><td><code id="plot_mvgam_pterms_+3A_trend_effects">trend_effects</code></td>
<td>
<p>logical. If <code>TRUE</code> and a <code>trend_formula</code> was used in model
fitting, terms from the trend (i.e. process) model will be plotted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Posterior empirical quantiles of each parametric term's partial effect estimates
(on the link scale) are calculated and visualised as ribbon plots. These effects can
be interpreted as the partial effect that a parametric term contributes when all other
terms in the model have been set to <code>0</code>
</p>


<h3>Value</h3>

<p>A base <code>R</code> graphics plot
</p>

<hr>
<h2 id='plot_mvgam_randomeffects'>Plot random effect terms from <span class="pkg">mvgam</span> models</h2><span id='topic+plot_mvgam_randomeffects'></span>

<h3>Description</h3>

<p>This function plots posterior empirical quantiles for random effect smooths (bs = re)
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_mvgam_randomeffects(object, trend_effects = FALSE)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_mvgam_randomeffects_+3A_object">object</code></td>
<td>
<p><code>list</code> object of class <code>mvgam</code>. See <code><a href="#topic+mvgam">mvgam()</a></code></p>
</td></tr>
<tr><td><code id="plot_mvgam_randomeffects_+3A_trend_effects">trend_effects</code></td>
<td>
<p>logical. If <code>TRUE</code> and a <code>trend_formula</code> was used in model
fitting, terms from the trend (i.e. process) model will be plotted</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Posterior empirical quantiles of random effect coefficient estimates
(on the link scale) are calculated and visualised as ribbon plots.
Labels for coefficients are taken from the levels of the original factor variable
that was used to specify the smooth in the model's formula
</p>


<h3>Value</h3>

<p>A base <code>R</code> graphics plot
</p>

<hr>
<h2 id='plot_mvgam_resids'>Residual diagnostics for a fitted <span class="pkg">mvgam</span> object</h2><span id='topic+plot_mvgam_resids'></span>

<h3>Description</h3>

<p>This function takes a fitted <code>mvgam</code> object and returns various residual diagnostic plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_mvgam_resids(object, series = 1, n_draws = 100L, n_points = 1000L)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_mvgam_resids_+3A_object">object</code></td>
<td>
<p><code>list</code> object returned from <code>mvgam</code>. See <code><a href="#topic+mvgam">mvgam()</a></code></p>
</td></tr>
<tr><td><code id="plot_mvgam_resids_+3A_series">series</code></td>
<td>
<p><code>integer</code> specifying which series in the set is to be plotted</p>
</td></tr>
<tr><td><code id="plot_mvgam_resids_+3A_n_draws">n_draws</code></td>
<td>
<p><code>integer</code> specifying the number of posterior residual draws
to use for calculating uncertainty in the &quot;ACF&quot; and &quot;pACF&quot; frames. Default is <code>100</code></p>
</td></tr>
<tr><td><code id="plot_mvgam_resids_+3A_n_points">n_points</code></td>
<td>
<p><code>integer</code> specifying the maximum number of points to show in the
&quot;Resids vs Fitted&quot; and &quot;Normal Q-Q Plot&quot; frames. Default is <code>1000</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>A total of four ggplot plots are generated to examine posterior
Dunn-Smyth residuals for the specified series. Plots include a residuals vs fitted values plot,
a Q-Q plot, and two plots to check for any remaining temporal autocorrelation in the residuals.
Note, all plots only report statistics from a sample of up to 100 posterior
draws (to save computational time), so uncertainty in these relationships may not be adequately represented.
</p>


<h3>Value</h3>

<p>A series of facetted ggplot object
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>
<p>Nicholas J Clark and Matthijs Hollanders
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
simdat &lt;- sim_mvgam(n_series = 3, trend_model = AR())
mod &lt;- mvgam(y ~ s(season, bs = 'cc', k = 6),
            trend_model = AR(),
            noncentred = TRUE,
            data = simdat$data_train,
            chains = 2,
            silent = 2)

# Plot Dunn Smyth residuals for some series
plot_mvgam_resids(mod)
plot_mvgam_resids(mod, series = 2)

</code></pre>

<hr>
<h2 id='plot_mvgam_series'>Plot observed time series used for <span class="pkg">mvgam</span> modelling</h2><span id='topic+plot_mvgam_series'></span>

<h3>Description</h3>

<p>This function takes either a fitted <code>mvgam</code> object or a <code>data.frame</code> object
and produces plots of observed time series, ACF, CDF and histograms for exploratory data analysis
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_mvgam_series(
  object,
  data,
  newdata,
  y = "y",
  lines = TRUE,
  series = 1,
  n_bins,
  log_scale = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_mvgam_series_+3A_object">object</code></td>
<td>
<p>Optional <code>list</code> object returned from <code>mvgam</code>. Either <code>object</code> or <code>data</code>
must be supplied.</p>
</td></tr>
<tr><td><code id="plot_mvgam_series_+3A_data">data</code></td>
<td>
<p>Optional <code>data.frame</code> or <code>list</code> of training data containing at least 'series' and 'time'.
Use this argument if training data have been gathered in the correct format for <code>mvgam</code> modelling
but no model has yet been fitted.</p>
</td></tr>
<tr><td><code id="plot_mvgam_series_+3A_newdata">newdata</code></td>
<td>
<p>Optional <code>data.frame</code> or <code>list</code> of test data containing at least 'series' and 'time'
for the forecast horizon, in addition to any other variables included in the linear predictor of <code>formula</code>. If
included, the observed values in the test data are compared to the model's forecast distribution for exploring
biases in model predictions.</p>
</td></tr>
<tr><td><code id="plot_mvgam_series_+3A_y">y</code></td>
<td>
<p>Character. What is the name of the outcome variable in the supplied data? Defaults to
<code>'y'</code></p>
</td></tr>
<tr><td><code id="plot_mvgam_series_+3A_lines">lines</code></td>
<td>
<p>Logical. If <code>TRUE</code>, line plots are used for visualizing time series. If
<code>FALSE</code>, points are used.</p>
</td></tr>
<tr><td><code id="plot_mvgam_series_+3A_series">series</code></td>
<td>
<p>Either a <code>integer</code> specifying which series in the set is to be plotted or
the string 'all', which plots all series available in the supplied data</p>
</td></tr>
<tr><td><code id="plot_mvgam_series_+3A_n_bins">n_bins</code></td>
<td>
<p><code>integer</code> specifying the number of bins to use for binning observed values when plotting
a the histogram. Default is to use the number of bins returned by a call to <code>hist</code> in base <code>R</code></p>
</td></tr>
<tr><td><code id="plot_mvgam_series_+3A_log_scale">log_scale</code></td>
<td>
<p><code>logical</code>. If <code>series == 'all'</code>, this flag is used to control whether
the time series plot is shown on the log scale (using <code>log(Y + 1)</code>). This can be useful when
visualizing many series that may have different observed ranges. Default is <code>FALSE</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A set of ggplot objects. If <code>series</code> is an integer, the plots will
show observed time series, autocorrelation and
cumulative distribution functions, and a histogram for the series. If <code>series == 'all'</code>,
a set of observed time series plots is returned in which all series are shown on each plot but
only a single focal series is highlighted, with all remaining series shown as faint gray lines.
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark and Matthijs Hollanders
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate and plot series with observations bounded at 0 and 1 (Beta responses)
sim_data &lt;- sim_mvgam(family = betar(),
                     trend_model = RW(), prop_trend = 0.6)
plot_mvgam_series(data = sim_data$data_train, series = 'all')
plot_mvgam_series(data = sim_data$data_train,
                 newdata = sim_data$data_test, series = 1)

# Now simulate series with overdispersed discrete observations
sim_data &lt;- sim_mvgam(family = nb(), trend_model = RW(),
                     prop_trend = 0.6, phi = 10)
plot_mvgam_series(data = sim_data$data_train, series = 'all')
</code></pre>

<hr>
<h2 id='plot_mvgam_smooth'>Plot smooth terms from <span class="pkg">mvgam</span> models</h2><span id='topic+plot_mvgam_smooth'></span>

<h3>Description</h3>

<p>This function plots posterior empirical quantiles for a series-specific smooth term
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_mvgam_smooth(
  object,
  trend_effects = FALSE,
  series = 1,
  smooth,
  residuals = FALSE,
  n_resid_bins = 25,
  realisations = FALSE,
  n_realisations = 15,
  derivatives = FALSE,
  newdata
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_mvgam_smooth_+3A_object">object</code></td>
<td>
<p><code>list</code> object of class <code>mvgam</code>. See <code><a href="#topic+mvgam">mvgam()</a></code></p>
</td></tr>
<tr><td><code id="plot_mvgam_smooth_+3A_trend_effects">trend_effects</code></td>
<td>
<p>logical. If <code>TRUE</code> and a <code>trend_formula</code> was used in model
fitting, terms from the trend (i.e. process) model will be plotted</p>
</td></tr>
<tr><td><code id="plot_mvgam_smooth_+3A_series">series</code></td>
<td>
<p><code>integer</code> specifying which series in the set is to be plotted</p>
</td></tr>
<tr><td><code id="plot_mvgam_smooth_+3A_smooth">smooth</code></td>
<td>
<p>either a <code>character</code> or <code>integer</code> specifying which smooth term to be plotted</p>
</td></tr>
<tr><td><code id="plot_mvgam_smooth_+3A_residuals">residuals</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code> then posterior quantiles of partial residuals are added
to plots of 1-D smooths as a series of ribbon rectangles.
Partial residuals for a smooth term are the median Dunn-Smyth residuals that would be obtained by dropping the term
concerned from the model, while leaving all other estimates fixed (i.e. the
estimates for the term plus the original median Dunn-Smyth residuals). Note that because <code>mvgam</code> works with
Dunn-Smyth residuals and not working residuals, which are used by <code>mgcv</code>, the magnitudes of
partial residuals will be different to what you would expect from <code><a href="mgcv.html#topic+plot.gam">plot.gam</a></code>. Interpretation
is similar though, as these partial residuals should be evenly scattered
around the smooth function if the function is well estimated</p>
</td></tr>
<tr><td><code id="plot_mvgam_smooth_+3A_n_resid_bins">n_resid_bins</code></td>
<td>
<p><code>integer</code> specifying the number of bins group the covariate into when plotting partial residuals.
Setting this argument too high can make for messy plots that are difficult to interpret, while setting it too
low will likely mask some potentially useful patterns in the partial residuals. Default is <code>25</code></p>
</td></tr>
<tr><td><code id="plot_mvgam_smooth_+3A_realisations">realisations</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, posterior realisations are shown as a spaghetti plot,
making it easier to visualise the diversity of possible functions. If <code>FALSE</code>, the default,
empirical quantiles of the posterior distribution are shown</p>
</td></tr>
<tr><td><code id="plot_mvgam_smooth_+3A_n_realisations">n_realisations</code></td>
<td>
<p><code>integer</code> specifying the number of posterior realisations to plot, if
<code>realisations = TRUE</code>. Ignored otherwise</p>
</td></tr>
<tr><td><code id="plot_mvgam_smooth_+3A_derivatives">derivatives</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, an additional plot will be returned to show the
estimated 1st derivative for the specified smooth (Note, this only works for univariate smooths)</p>
</td></tr>
<tr><td><code id="plot_mvgam_smooth_+3A_newdata">newdata</code></td>
<td>
<p>Optional <code>dataframe</code> for predicting the smooth, containing at least 'series'
in addition to any other variables included in the linear predictor of the original model's <code>formula</code>.
Note that this currently is only supported for plotting univariate smooths</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Smooth functions are shown as empirical quantiles (or spaghetti plots) of posterior partial expectations
across a sequence of values between the variable's <code>min</code> and <code>max</code>,
while zeroing out effects of all other variables. At present, only univariate and bivariate smooth plots
are allowed, though note that bivariate smooths rely on default behaviour from
<code><a href="mgcv.html#topic+plot.gam">plot.gam</a></code>. <code>plot_mvgam_smooth</code> generates posterior predictions from an
object of class <code>mvgam</code>, calculates posterior empirical quantiles and plots them.
If <code>realisations = FALSE</code>, the returned plot shows 90, 60, 40 and 20 percent posterior
quantiles (as ribbons of increasingly darker shades or red) as well as the posterior
median (as a dark red line). If <code>realisations = FALSE</code>, a set of <code>n_realisations</code> posterior
draws are shown. For more nuanced visualisation, supply
<code>newdata</code> just as you would when predicting from a <code><a href="mgcv.html#topic+gam">gam</a></code> model or use the more flexible <code><a href="#topic+conditional_effects.mvgam">conditional_effects.mvgam</a></code>. Alternatively, if you prefer to use partial
effect plots in the style of <code>gratia</code>, and if you have the <code>gratia</code> package installed, you can
use <code>draw.mvgam</code>. See <code><a href="#topic+gratia_mvgam_enhancements">gratia_mvgam_enhancements</a></code> for details.
</p>


<h3>Value</h3>

<p>A base <code>R</code> graphics plot
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>See Also</h3>

<p><code><a href="mgcv.html#topic+plot.gam">plot.gam</a></code>, <code><a href="#topic+conditional_effects.mvgam">conditional_effects.mvgam</a></code>,
<code><a href="#topic+gratia_mvgam_enhancements">gratia_mvgam_enhancements</a></code>
</p>

<hr>
<h2 id='plot_mvgam_trend'>Plot latent trend predictions from <span class="pkg">mvgam</span> models</h2><span id='topic+plot_mvgam_trend'></span>

<h3>Description</h3>

<p>Plot latent trend predictions from <span class="pkg">mvgam</span> models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_mvgam_trend(
  object,
  series = 1,
  newdata,
  data_test,
  realisations = FALSE,
  n_realisations = 15,
  n_cores = 1,
  derivatives = FALSE,
  xlab,
  ylab
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_mvgam_trend_+3A_object">object</code></td>
<td>
<p><code>list</code> object returned from <code>mvgam</code>. See <code><a href="#topic+mvgam">mvgam()</a></code></p>
</td></tr>
<tr><td><code id="plot_mvgam_trend_+3A_series">series</code></td>
<td>
<p><code>integer</code> specifying which series in the set is to be plotted</p>
</td></tr>
<tr><td><code id="plot_mvgam_trend_+3A_newdata">newdata</code></td>
<td>
<p>Optional <code>dataframe</code> or <code>list</code> of test data containing at least 'series' and 'time'
in addition to any other variables included in the linear predictor of the original <code>formula</code>.</p>
</td></tr>
<tr><td><code id="plot_mvgam_trend_+3A_data_test">data_test</code></td>
<td>
<p>Deprecated. Still works in place of <code>newdata</code> but users are recommended to use
<code>newdata</code> instead for more seamless integration into <code>R</code> workflows</p>
</td></tr>
<tr><td><code id="plot_mvgam_trend_+3A_realisations">realisations</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, posterior trend realisations are shown as a spaghetti plot,
making it easier to visualise the diversity of possible trend paths. If <code>FALSE</code>, the default,
empirical quantiles of the posterior distribution are shown</p>
</td></tr>
<tr><td><code id="plot_mvgam_trend_+3A_n_realisations">n_realisations</code></td>
<td>
<p><code>integer</code> specifying the number of posterior realisations to plot, if
<code>realisations = TRUE</code>. Ignored otherwise</p>
</td></tr>
<tr><td><code id="plot_mvgam_trend_+3A_n_cores">n_cores</code></td>
<td>
<p>Deprecated. Parallel processing is no longer supported</p>
</td></tr>
<tr><td><code id="plot_mvgam_trend_+3A_derivatives">derivatives</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, an additional plot will be returned to show the
estimated 1st derivative for the estimated trend</p>
</td></tr>
<tr><td><code id="plot_mvgam_trend_+3A_xlab">xlab</code></td>
<td>
<p>label for x axis.</p>
</td></tr>
<tr><td><code id="plot_mvgam_trend_+3A_ylab">ylab</code></td>
<td>
<p>label for y axis.</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
simdat &lt;- sim_mvgam(n_series = 3, trend_model = 'AR1')
mod &lt;- mvgam(y ~ s(season, bs = 'cc', k = 6),
            trend_model = AR(),
            noncentred = TRUE,
            data = simdat$data_train,
            chains = 2)

# Plot estimated trends for some series
plot_mvgam_trend(mod)
plot_mvgam_trend(mod, series = 2)

# Extrapolate trends forward in time and plot on response scale
plot_mvgam_trend(mod, newdata = simdat$data_test)
plot_mvgam_trend(mod, newdata = simdat$data_test, series = 2)

# But it is recommended to compute extrapolations for all series
# first and then plot
trend_fc &lt;- forecast(mod, newdata = simdat$data_test)
plot(trend_fc, series = 1)
plot(trend_fc, series = 2)

</code></pre>

<hr>
<h2 id='plot_mvgam_uncertainty'>Plot forecast uncertainty contributions from <span class="pkg">mvgam</span> models</h2><span id='topic+plot_mvgam_uncertainty'></span>

<h3>Description</h3>

<p>Plot forecast uncertainty contributions from <span class="pkg">mvgam</span> models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>plot_mvgam_uncertainty(
  object,
  series = 1,
  newdata,
  data_test,
  legend_position = "topleft",
  hide_xlabels = FALSE
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot_mvgam_uncertainty_+3A_object">object</code></td>
<td>
<p><code>list</code> object returned from <code>mvgam</code>. See <code><a href="#topic+mvgam">mvgam()</a></code></p>
</td></tr>
<tr><td><code id="plot_mvgam_uncertainty_+3A_series">series</code></td>
<td>
<p><code>integer</code> specifying which series in the set is to be plotted</p>
</td></tr>
<tr><td><code id="plot_mvgam_uncertainty_+3A_newdata">newdata</code></td>
<td>
<p>A <code>dataframe</code> or <code>list</code> containing at least 'series' and 'time' for the forecast horizon, in
addition to any other variables included in the linear predictor of <code>formula</code></p>
</td></tr>
<tr><td><code id="plot_mvgam_uncertainty_+3A_data_test">data_test</code></td>
<td>
<p>Deprecated. Still works in place of <code>newdata</code> but users are recommended to use
<code>newdata</code> instead for more seamless integration into <code>R</code> workflows</p>
</td></tr>
<tr><td><code id="plot_mvgam_uncertainty_+3A_legend_position">legend_position</code></td>
<td>
<p>The location may also be specified by setting x to a single keyword from the
list: &quot;none&quot;, &quot;bottomright&quot;, &quot;bottom&quot;, &quot;bottomleft&quot;, &quot;left&quot;, &quot;topleft&quot;, &quot;top&quot;, &quot;topright&quot;, &quot;right&quot; and &quot;center&quot;.
This places the legend on the inside of the plot frame at the given location (if it is not &quot;none&quot;).</p>
</td></tr>
<tr><td><code id="plot_mvgam_uncertainty_+3A_hide_xlabels">hide_xlabels</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, no xlabels are printed to allow the user to add custom labels using
<code>axis</code> from base <code>R</code></p>
</td></tr>
</table>


<h3>Details</h3>

<p>The basic idea of this function is to compute forecasts by ignoring one of the
two primary components in a correlated residual model (i.e. by either ignoring the
linear predictor effects or by ignoring the residual dynamics). Some caution is required
however, as this function was designed early in the <span class="pkg">mvgam</span> development cycle and
there are now many types of models that it cannot handle very well. For example,
models with shared latent states, or any type of State-Space models that include terms
in the <code>trend_formula</code>, will either fail or give nonsensical results. Improvements are
in the works to provide a more general way to decompose forecast uncertainties, so
please check back at a later date.
</p>


<h3>Value</h3>

<p>A base <code>R</code> graphics plot
</p>

<hr>
<h2 id='plot.mvgam'>Default plots for <span class="pkg">mvgam</span> models</h2><span id='topic+plot.mvgam'></span>

<h3>Description</h3>

<p>This function takes a fitted <code>mvgam</code> object and produces plots of smooth functions, forecasts, trends and
uncertainty components
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
plot(
  x,
  type = "residuals",
  series = 1,
  residuals = FALSE,
  newdata,
  data_test,
  trend_effects = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.mvgam_+3A_x">x</code></td>
<td>
<p><code>list</code> object returned from <code>mvgam</code>. See <code><a href="#topic+mvgam">mvgam()</a></code></p>
</td></tr>
<tr><td><code id="plot.mvgam_+3A_type">type</code></td>
<td>
<p><code>character</code> specifying which type of plot to return. Options are:
series,
residuals,
smooths,
re (random effect smooths),
pterms (parametric effects),
forecast,
trend,
uncertainty,
factors</p>
</td></tr>
<tr><td><code id="plot.mvgam_+3A_series">series</code></td>
<td>
<p><code>integer</code> specifying which series in the set is to be plotted. This is ignored
if <code>type == 're'</code></p>
</td></tr>
<tr><td><code id="plot.mvgam_+3A_residuals">residuals</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code> and <code>type = 'smooths'</code>, posterior quantiles of partial residuals are added
to plots of 1-D smooths as a series of ribbon rectangles.
Partial residuals for a smooth term are the median Dunn-Smyth residuals that would be obtained by dropping the term
concerned from the model, while leaving all other estimates fixed (i.e. the
estimates for the term plus the original median Dunn-Smyth residuals). Note that because <code>mvgam</code> works with
Dunn-Smyth residuals and not working residuals, which are used by <code>mgcv</code>, the magnitudes of
partial residuals will be different to what you would expect from <code><a href="mgcv.html#topic+plot.gam">plot.gam</a></code>. Interpretation
is similar though, as these partial residuals should be evenly scattered
around the smooth function if the function is well estimated</p>
</td></tr>
<tr><td><code id="plot.mvgam_+3A_newdata">newdata</code></td>
<td>
<p>Optional <code>dataframe</code> or <code>list</code> of test data containing at least 'series' and 'time'
in addition to any other variables included in the linear predictor of the original <code>formula</code>.
This argument is optional when plotting out of sample forecast period observations
(when <code>type = forecast</code>) and required when plotting
uncertainty components (<code>type = uncertainty</code>).</p>
</td></tr>
<tr><td><code id="plot.mvgam_+3A_data_test">data_test</code></td>
<td>
<p>Deprecated. Still works in place of <code>newdata</code> but users are recommended to use
<code>newdata</code> instead for more seamless integration into <code>R</code> workflows</p>
</td></tr>
<tr><td><code id="plot.mvgam_+3A_trend_effects">trend_effects</code></td>
<td>
<p>logical. If <code>TRUE</code> and a <code>trend_formula</code> was used in model
fitting, terms from the trend (i.e. process) model will be plotted</p>
</td></tr>
<tr><td><code id="plot.mvgam_+3A_...">...</code></td>
<td>
<p>Additional arguments for each individual plotting function.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These plots are useful for getting an overview of the fitted model and its estimated
random effects or smooth functions,
but the individual plotting functions and the functions from the <code>marginaleffects</code> and <code>gratia</code> packages
offer far more more customisation.
</p>


<h3>Value</h3>

<p>A base R plot or set of plots
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+plot_mvgam_resids">plot_mvgam_resids</a></code>, <code><a href="#topic+plot_mvgam_smooth">plot_mvgam_smooth</a></code>, <code><a href="#topic+plot_mvgam_fc">plot_mvgam_fc</a></code>,
<code><a href="#topic+plot_mvgam_trend">plot_mvgam_trend</a></code>, <code><a href="#topic+plot_mvgam_uncertainty">plot_mvgam_uncertainty</a></code>, <code><a href="#topic+plot_mvgam_factors">plot_mvgam_factors</a></code>,
<code><a href="#topic+plot_mvgam_randomeffects">plot_mvgam_randomeffects</a></code>, <code><a href="#topic+conditional_effects.mvgam">conditional_effects.mvgam</a></code>,
<code><a href="marginaleffects.html#topic+plot_predictions">plot_predictions</a></code>, <code><a href="marginaleffects.html#topic+plot_slopes">plot_slopes</a></code>,
<code><a href="#topic+gratia_mvgam_enhancements">gratia_mvgam_enhancements</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate some time series
dat &lt;- sim_mvgam(T = 80, n_series = 3)

# Fit a basic model
mod &lt;- mvgam(y ~ s(season, bs = 'cc') + s(series, bs = 're'),
            data = dat$data_train,
            trend_model = RW(),
            chains = 2,
            silent = 2)

# Plot predictions and residuals for each series
plot(mod, type = 'forecast', series = 1)
plot(mod, type = 'forecast', series = 2)
plot(mod, type = 'forecast', series = 3)
plot(mod, type = 'residuals', series = 1)
plot(mod, type = 'residuals', series = 2)
plot(mod, type = 'residuals', series = 3)

# Plot model effects
plot(mod, type = 'smooths')
plot(mod, type = 're')

# More flexible plots with 'marginaleffects' utilities
library(marginaleffects)
plot_predictions(mod, condition = 'season', type = 'link')
plot_predictions(mod,
                condition = c('season', 'series', 'series'),
                type = 'link')
plot_predictions(mod, condition = 'series', type = 'link')

# When using a State-Space model with predictors on the process
# model, set trend_effects = TRUE to visualise process effects
mod &lt;- mvgam(y ~ -1,
            trend_formula = ~ s(season, bs = 'cc'),
            data = dat$data_train,
            trend_model = RW(),
            chains = 2,
            silent = 2)
plot(mod, type = 'smooths', trend_effects = TRUE)

# But marginaleffects functions work without any modification
plot_predictions(mod, condition = 'season', type = 'link')


</code></pre>

<hr>
<h2 id='plot.mvgam_fevd'>Plot forecast error variance decompositions from an <code>mvgam_fevd</code> object</h2><span id='topic+plot.mvgam_fevd'></span>

<h3>Description</h3>

<p>This function takes an <code>mvgam_fevd</code> object and produces
a plot of the posterior median contributions to forecast variance for each series
in the fitted Vector Autoregression
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam_fevd'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.mvgam_fevd_+3A_x">x</code></td>
<td>
<p><code>list</code> object of class <code>mvgam_fevd</code>. See <code><a href="#topic+fevd">fevd()</a></code></p>
</td></tr>
<tr><td><code id="plot.mvgam_fevd_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code><a href="ggplot2.html#topic+ggplot">ggplot</a></code> object,
which can be further customized using the <span class="pkg">ggplot2</span> package
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>

<hr>
<h2 id='plot.mvgam_irf'>Plot impulse responses from an <code>mvgam_irf</code> object</h2><span id='topic+plot.mvgam_irf'></span>

<h3>Description</h3>

<p>This function takes an <code>mvgam_irf</code> object and produces plots of Impulse Response Functions
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam_irf'
plot(x, series = 1, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.mvgam_irf_+3A_x">x</code></td>
<td>
<p><code>list</code> object of class <code>mvgam_irf</code>. See <code><a href="#topic+irf">irf()</a></code></p>
</td></tr>
<tr><td><code id="plot.mvgam_irf_+3A_series">series</code></td>
<td>
<p><code>integer</code> specifying which process series should be given the shock</p>
</td></tr>
<tr><td><code id="plot.mvgam_irf_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A ggplot object showing the expected response of each latent time series to
a shock of the focal <code>series</code>
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>

<hr>
<h2 id='plot.mvgam_lfo'>Plot Pareto-k and ELPD values from a <code>mvgam_lfo</code> object</h2><span id='topic+plot.mvgam_lfo'></span>

<h3>Description</h3>

<p>This function takes an object of class <code>mvgam_lfo</code> and creates several
informative diagnostic plots
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam_lfo'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.mvgam_lfo_+3A_x">x</code></td>
<td>
<p>An object of class <code>mvgam_lfo</code></p>
</td></tr>
<tr><td><code id="plot.mvgam_lfo_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>ggplot</code> object presenting Pareto-k and ELPD values over the
evaluation timepoints. For the Pareto-k plot, a dashed red line indicates the
specified threshold chosen for triggering model refits. For the ELPD plot,
a dashed red line indicates the bottom 10% quantile of ELPD values. Points below
this threshold may represent outliers that were more difficult to forecast
</p>

<hr>
<h2 id='plot.mvgam_residcor'>Plot residual correlations based on latent factors from a fitted jsdgam</h2><span id='topic+plot.mvgam_residcor'></span>

<h3>Description</h3>

<p>Plot residual correlation estimates from Joint Species Distribution
<code>jsdgam</code> models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam_residcor'
plot(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="plot.mvgam_residcor_+3A_x">x</code></td>
<td>
<p><code>list</code> object of class <code>mvgam_residcor</code> resulting from a
call to <code>residual_cor(..., summary = TRUE)</code></p>
</td></tr>
<tr><td><code id="plot.mvgam_residcor_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This function plots the significant residual correlations from a
<code>mvgam_residcor</code> object
</p>


<h3>Value</h3>

<p>A <code>ggplot</code> object
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jsdgam">jsdgam</a></code>, <code><a href="#topic+residual_cor">residual_cor</a></code>
</p>

<hr>
<h2 id='portal_data'>Portal Project rodent capture survey data</h2><span id='topic+portal_data'></span>

<h3>Description</h3>

<p>A dataset containing timeseries of total captures (across all control plots) for select rodent species from the Portal Project
</p>


<h3>Usage</h3>

<pre><code class='language-R'>portal_data
</code></pre>


<h3>Format</h3>

<p>A <code>data.frame</code> containing the following fields:
</p>

<dl>
<dt>time</dt><dd><p>time of sampling, in lunar monthly cycles</p>
</dd>
<dt>series</dt><dd><p>factor indicator of the time series, i.e. the species</p>
</dd>
<dt>captures</dt><dd><p>total captures across all control plots</p>
</dd>
<dt>mintemp</dt><dd><p>monthly mean minimum temperature</p>
</dd>
<dt>ndvi_ma12</dt><dd><p>12-month moving average of the mean Normalised Difference Vegetation Index</p>
</dd>
<dt>mintemp</dt><dd><p>monthly mean of minimum temperature</p>
</dd>
</dl>



<h3>Source</h3>

<p><a href="https://github.com/weecology/PortalData/blob/main/SiteandMethods/Methods.md">https://github.com/weecology/PortalData/blob/main/SiteandMethods/Methods.md</a>
</p>

<hr>
<h2 id='posterior_epred.mvgam'>Draws from the expected value of the posterior predictive distribution for <span class="pkg">mvgam</span> objects</h2><span id='topic+posterior_epred.mvgam'></span>

<h3>Description</h3>

<p>Compute posterior draws of the expected value of the posterior predictive
distribution (i.e. the conditional expectation).
Can be performed for the data used to fit the model (posterior
predictive checks) or for new data. By definition, these predictions have
smaller variance than the posterior predictions performed by the
<code><a href="#topic+posterior_predict.mvgam">posterior_predict.mvgam</a></code> method. This is because only the
uncertainty in the expected value of the posterior predictive distribution is
incorporated in the draws computed by <code>posterior_epred</code> while the
residual error is ignored there. However, the estimated means of both methods
averaged across draws should be very similar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
posterior_epred(
  object,
  newdata,
  data_test,
  ndraws = NULL,
  process_error = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="posterior_epred.mvgam_+3A_object">object</code></td>
<td>
<p><code>list</code> object of class <code>mvgam</code> or <code>jsdgam</code>. See <code><a href="#topic+mvgam">mvgam()</a></code></p>
</td></tr>
<tr><td><code id="posterior_epred.mvgam_+3A_newdata">newdata</code></td>
<td>
<p>Optional <code>dataframe</code> or <code>list</code> of test data containing the same variables
that were included in the original <code>data</code> used to fit the model. If not supplied,
predictions are generated for the original observations used for the model fit.</p>
</td></tr>
<tr><td><code id="posterior_epred.mvgam_+3A_data_test">data_test</code></td>
<td>
<p>Deprecated. Still works in place of <code>newdata</code> but users are recommended to use
<code>newdata</code> instead for more seamless integration into <code>R</code> workflows</p>
</td></tr>
<tr><td><code id="posterior_epred.mvgam_+3A_ndraws">ndraws</code></td>
<td>
<p>Positive <code>integer</code> indicating how many posterior draws should be used.
If <code>NULL</code> (the default) all draws are used.</p>
</td></tr>
<tr><td><code id="posterior_epred.mvgam_+3A_process_error">process_error</code></td>
<td>
<p>Logical. If <code>TRUE</code> and <code>newdata</code> is supplied,
expected uncertainty in the process model is accounted for by using draws
from any latent trend SD parameters. If <code>FALSE</code>, uncertainty in the latent
trend component is ignored when calculating predictions. If no <code>newdata</code> is
supplied, draws from the fitted model's posterior predictive distribution will be used
(which will always include uncertainty in any latent trend components)</p>
</td></tr>
<tr><td><code id="posterior_epred.mvgam_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that for all types of predictions for models that did not include
a <code>trend_formula</code>, uncertainty in the dynamic trend
component can be ignored by setting <code>process_error = FALSE</code>. However,
if a <code>trend_formula</code> was supplied in the model, predictions for this component cannot be
ignored. If <code>process_error = TRUE</code>, trend predictions will ignore autocorrelation
coefficients or GP length scale coefficients, ultimately assuming the process is stationary.
This method is similar to the types of posterior predictions returned from <code>brms</code> models
when using autocorrelated error predictions for newdata.
This function is therefore more suited to posterior simulation from the GAM components
of a <code>mvgam</code> model, while the forecasting functions
<code><a href="#topic+plot_mvgam_fc">plot_mvgam_fc</a></code> and <code><a href="#topic+forecast.mvgam">forecast.mvgam</a></code> are better suited to generate h-step ahead forecasts
that respect the temporal dynamics of estimated latent trends.
</p>


<h3>Value</h3>

<p>A <code>matrix</code> of dimension <code>n_samples x new_obs</code>,
where <code>n_samples</code> is the number of posterior samples from the fitted object
and <code>n_obs</code> is the number of observations in <code>newdata</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hindcast.mvgam">hindcast.mvgam</a></code> <code><a href="#topic+posterior_linpred.mvgam">posterior_linpred.mvgam</a></code> <code><a href="#topic+posterior_predict.mvgam">posterior_predict.mvgam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate some data and fit a model
simdat &lt;- sim_mvgam(n_series = 1, trend_model = AR())
mod &lt;- mvgam(y ~ s(season, bs = 'cc'),
            trend_model = AR(),
            noncentred = TRUE,
            data = simdat$data_train,
            chains = 2,
            silent = 2)

# Compute posterior expectations
expectations &lt;- posterior_epred(mod)
str(expectations)

</code></pre>

<hr>
<h2 id='posterior_linpred.mvgam'>Posterior draws of the linear predictor for <span class="pkg">mvgam</span> objects</h2><span id='topic+posterior_linpred.mvgam'></span>

<h3>Description</h3>

<p>Compute posterior draws of the linear predictor, that is draws before
applying any link functions or other transformations. Can be performed for
the data used to fit the model (posterior predictive checks) or for new data.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
posterior_linpred(
  object,
  transform = FALSE,
  newdata,
  ndraws = NULL,
  data_test,
  process_error = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="posterior_linpred.mvgam_+3A_object">object</code></td>
<td>
<p><code>list</code> object of class <code>mvgam</code> or <code>jsdgam</code>. See <code><a href="#topic+mvgam">mvgam()</a></code></p>
</td></tr>
<tr><td><code id="posterior_linpred.mvgam_+3A_transform">transform</code></td>
<td>
<p>Logical; if <code>FALSE</code>
(the default), draws of the linear predictor are returned.
If <code>TRUE</code>, draws of the transformed linear predictor,
i.e. the conditional expectation, are returned.</p>
</td></tr>
<tr><td><code id="posterior_linpred.mvgam_+3A_newdata">newdata</code></td>
<td>
<p>Optional <code>dataframe</code> or <code>list</code> of test data containing the same variables
that were included in the original <code>data</code> used to fit the model. If not supplied,
predictions are generated for the original observations used for the model fit.</p>
</td></tr>
<tr><td><code id="posterior_linpred.mvgam_+3A_ndraws">ndraws</code></td>
<td>
<p>Positive <code>integer</code> indicating how many posterior draws should be used.
If <code>NULL</code> (the default) all draws are used.</p>
</td></tr>
<tr><td><code id="posterior_linpred.mvgam_+3A_data_test">data_test</code></td>
<td>
<p>Deprecated. Still works in place of <code>newdata</code> but users are recommended to use
<code>newdata</code> instead for more seamless integration into <code>R</code> workflows</p>
</td></tr>
<tr><td><code id="posterior_linpred.mvgam_+3A_process_error">process_error</code></td>
<td>
<p>Logical. If <code>TRUE</code> and <code>newdata</code> is supplied,
expected uncertainty in the process model is accounted for by using draws
from any latent trend SD parameters. If <code>FALSE</code>, uncertainty in the latent
trend component is ignored when calculating predictions. If no <code>newdata</code> is
supplied, draws from the fitted model's posterior predictive distribution will be used
(which will always include uncertainty in any latent trend components)</p>
</td></tr>
<tr><td><code id="posterior_linpred.mvgam_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that for all types of predictions for models that did not include
a <code>trend_formula</code>, uncertainty in the dynamic trend
component can be ignored by setting <code>process_error = FALSE</code>. However,
if a <code>trend_formula</code> was supplied in the model, predictions for this component cannot be
ignored. If <code>process_error = TRUE</code>, trend predictions will ignore autocorrelation
coefficients or GP length scale coefficients, ultimately assuming the process is stationary.
This method is similar to the types of posterior predictions returned from <code>brms</code> models
when using autocorrelated error predictions for newdata.
This function is therefore more suited to posterior simulation from the GAM components
of a <code>mvgam</code> model, while the forecasting functions
<code><a href="#topic+plot_mvgam_fc">plot_mvgam_fc</a></code> and <code><a href="#topic+forecast.mvgam">forecast.mvgam</a></code> are better suited to generate h-step ahead forecasts
that respect the temporal dynamics of estimated latent trends.
</p>


<h3>Value</h3>

<p>A <code>matrix</code> of dimension <code>n_samples x new_obs</code>,
where <code>n_samples</code> is the number of posterior samples from the fitted object
and <code>n_obs</code> is the number of observations in <code>newdata</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+posterior_epred.mvgam">posterior_epred.mvgam</a></code> <code><a href="#topic+posterior_predict.mvgam">posterior_predict.mvgam</a></code>
</p>
<p><code><a href="#topic+hindcast.mvgam">hindcast.mvgam</a></code> <code><a href="#topic+posterior_epred.mvgam">posterior_epred.mvgam</a></code> <code><a href="#topic+posterior_predict.mvgam">posterior_predict.mvgam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate some data and fit a model
simdat &lt;- sim_mvgam(n_series = 1, trend_model = AR())
mod &lt;- mvgam(y ~ s(season, bs = 'cc'),
             trend_model = AR(),
             noncentred = TRUE,
             data = simdat$data_train,
             chains = 2,
             silent = 2)

# Extract linear predictor values
linpreds &lt;- posterior_linpred(mod)
str(linpreds)

</code></pre>

<hr>
<h2 id='posterior_predict.mvgam'>Draws from the posterior predictive distribution for <span class="pkg">mvgam</span> objects</h2><span id='topic+posterior_predict.mvgam'></span>

<h3>Description</h3>

<p>Compute posterior draws of the posterior predictive distribution. Can be
performed for the data used to fit the model (posterior predictive checks) or
for new data. By definition, these draws have higher variance than draws
of the expected value of the posterior predictive distribution computed by
<code><a href="#topic+posterior_epred.mvgam">posterior_epred.mvgam</a></code>. This is because the residual error
is incorporated in <code>posterior_predict</code>. However, the estimated means of
both methods averaged across draws should be very similar.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
posterior_predict(
  object,
  newdata,
  data_test,
  ndraws = NULL,
  process_error = TRUE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="posterior_predict.mvgam_+3A_object">object</code></td>
<td>
<p><code>list</code> object of class <code>mvgam</code> or <code>jsdgam</code>. See <code><a href="#topic+mvgam">mvgam()</a></code></p>
</td></tr>
<tr><td><code id="posterior_predict.mvgam_+3A_newdata">newdata</code></td>
<td>
<p>Optional <code>dataframe</code> or <code>list</code> of test data containing the same variables
that were included in the original <code>data</code> used to fit the model. If not supplied,
predictions are generated for the original observations used for the model fit.</p>
</td></tr>
<tr><td><code id="posterior_predict.mvgam_+3A_data_test">data_test</code></td>
<td>
<p>Deprecated. Still works in place of <code>newdata</code> but users are recommended to use
<code>newdata</code> instead for more seamless integration into <code>R</code> workflows</p>
</td></tr>
<tr><td><code id="posterior_predict.mvgam_+3A_ndraws">ndraws</code></td>
<td>
<p>Positive <code>integer</code> indicating how many posterior draws should be used.
If <code>NULL</code> (the default) all draws are used.</p>
</td></tr>
<tr><td><code id="posterior_predict.mvgam_+3A_process_error">process_error</code></td>
<td>
<p>Logical. If <code>TRUE</code> and <code>newdata</code> is supplied,
expected uncertainty in the process model is accounted for by using draws
from any latent trend SD parameters. If <code>FALSE</code>, uncertainty in the latent
trend component is ignored when calculating predictions. If no <code>newdata</code> is
supplied, draws from the fitted model's posterior predictive distribution will be used
(which will always include uncertainty in any latent trend components)</p>
</td></tr>
<tr><td><code id="posterior_predict.mvgam_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that for all types of predictions for models that did not include
a <code>trend_formula</code>, uncertainty in the dynamic trend
component can be ignored by setting <code>process_error = FALSE</code>. However,
if a <code>trend_formula</code> was supplied in the model, predictions for this component cannot be
ignored. If <code>process_error = TRUE</code>, trend predictions will ignore autocorrelation
coefficients or GP length scale coefficients, ultimately assuming the process is stationary.
This method is similar to the types of posterior predictions returned from <code>brms</code> models
when using autocorrelated error predictions for newdata.
This function is therefore more suited to posterior simulation from the GAM components
of a <code>mvgam</code> model, while the forecasting functions
<code><a href="#topic+plot_mvgam_fc">plot_mvgam_fc</a></code> and <code><a href="#topic+forecast.mvgam">forecast.mvgam</a></code> are better suited to generate h-step ahead forecasts
that respect the temporal dynamics of estimated latent trends.
</p>


<h3>Value</h3>

<p>A <code>matrix</code> of dimension <code>n_samples x new_obs</code>,
where <code>n_samples</code> is the number of posterior samples from the fitted object
and <code>n_obs</code> is the number of observations in <code>newdata</code>
</p>


<h3>See Also</h3>

<p><code><a href="#topic+hindcast.mvgam">hindcast.mvgam</a></code> <code><a href="#topic+posterior_linpred.mvgam">posterior_linpred.mvgam</a></code> <code><a href="#topic+posterior_epred.mvgam">posterior_epred.mvgam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate some data and fit a model
simdat &lt;- sim_mvgam(n_series = 1, trend_model = AR())
mod &lt;- mvgam(y ~ s(season, bs = 'cc'),
            trend_model = AR(),
            data = simdat$data_train,
            chains = 2,
            silent = 2)

# Compute posterior predictions
predictions &lt;- posterior_predict(mod)
str(predictions)

</code></pre>

<hr>
<h2 id='pp_check.mvgam'>Posterior Predictive Checks for <code>mvgam</code> models</h2><span id='topic+pp_check.mvgam'></span><span id='topic+pp_check'></span>

<h3>Description</h3>

<p>Perform unconditional posterior predictive checks with the help
of the <span class="pkg">bayesplot</span> package.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
pp_check(
  object,
  type,
  ndraws = NULL,
  prefix = c("ppc", "ppd"),
  group = NULL,
  x = NULL,
  newdata = NULL,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="pp_check.mvgam_+3A_object">object</code></td>
<td>
<p>An object of class <code>mvgam</code>.</p>
</td></tr>
<tr><td><code id="pp_check.mvgam_+3A_type">type</code></td>
<td>
<p>Type of the ppc plot as given by a character string.
See <code><a href="bayesplot.html#topic+PPC-overview">PPC</a></code> for an overview
of currently supported types. You may also use an invalid
type (e.g. <code>type = "xyz"</code>) to get a list of supported
types in the resulting error message.</p>
</td></tr>
<tr><td><code id="pp_check.mvgam_+3A_ndraws">ndraws</code></td>
<td>
<p>Positive integer indicating how many
posterior draws should be used.
If <code>NULL</code> all draws are used. If not specified,
the number of posterior draws is chosen automatically.
Ignored if <code>draw_ids</code> is not <code>NULL</code>.</p>
</td></tr>
<tr><td><code id="pp_check.mvgam_+3A_prefix">prefix</code></td>
<td>
<p>The prefix of the <span class="pkg">bayesplot</span> function to be applied.
Either '&quot;ppc&quot;' (posterior predictive check; the default)
or '&quot;ppd&quot;' (posterior predictive distribution), the latter being the same
as the former except that the observed data is not shown for '&quot;ppd&quot;'.</p>
</td></tr>
<tr><td><code id="pp_check.mvgam_+3A_group">group</code></td>
<td>
<p>Optional name of a factor variable in the model
by which to stratify the ppc plot. This argument is required for
ppc <code>*_grouped</code> types and ignored otherwise.</p>
</td></tr>
<tr><td><code id="pp_check.mvgam_+3A_x">x</code></td>
<td>
<p>Optional name of a variable in the model.
Only used for ppc types having an <code>x</code> argument
and ignored otherwise.</p>
</td></tr>
<tr><td><code id="pp_check.mvgam_+3A_newdata">newdata</code></td>
<td>
<p>Optional <code>dataframe</code> or <code>list</code> of test data containing the
variables included in the linear predictor of <code>formula</code>. If not supplied,
predictions are generated for the original observations used for the model fit.
Ignored if using one of the residual plots (i.e. 'resid_hist')</p>
</td></tr>
<tr><td><code id="pp_check.mvgam_+3A_...">...</code></td>
<td>
<p>Further arguments passed to <code><a href="#topic+predict.mvgam">predict.mvgam</a></code>
as well as to the PPC function specified in <code>type</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Unlike the conditional posterior checks provided by <code><a href="#topic+ppc">ppc</a></code>,
This function computes <em>unconditional</em> posterior predictive checks (i.e. it generates
predictions for fake data without considering the true observations associated with those
fake data). For a detailed explanation of each of the ppc functions,
see the <code><a href="bayesplot.html#topic+PPC-overview">PPC</a></code>
documentation of the <span class="pkg"><a href="bayesplot.html#topic+bayesplot-package">bayesplot</a></span>
package.
</p>


<h3>Value</h3>

<p>A ggplot object that can be further
customized using the <span class="pkg">ggplot2</span> package.
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+ppc">ppc</a></code>, <code><a href="#topic+predict.mvgam">predict.mvgam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
simdat &lt;- sim_mvgam(seasonality = "hierarchical")
mod &lt;- mvgam(
  y ~ series +
    s(season, bs = "cc", k = 6) +
    s(season, series, bs = "fs", k = 4),
  data = simdat$data_train,
  chains = 2,
  silent = 2
)

# Use pp_check(mod, type = "xyz") for a list of available plot types

# Default is a density overlay for all observations
pp_check(mod)

# Rootograms particularly useful for count data
pp_check(mod, type = "rootogram")

# Grouping plots by series is useful
pp_check(mod,
  type = "bars_grouped",
  group = "series", ndraws = 50
)
pp_check(mod,
  type = "ecdf_overlay_grouped",
  group = "series", ndraws = 50
)
pp_check(mod,
  type = "stat_freqpoly_grouped",
  group = "series", ndraws = 50
)

# Several types can be used to plot distributions of randomized
# quantile residuals
pp_check(
  object = mod,
  x = "season",
  type = "resid_ribbon"
)
pp_check(
  object = mod,
  x = "season",
  group = "series",
  type = "resid_ribbon_grouped"
)
pp_check(mod,
  ndraws = 5,
  type = "resid_hist_grouped",
  group = "series"
)

# Custom functions accepted
pp_check(mod, type = "stat", stat = function(x) mean(x == 0))
pp_check(mod,
  type = "stat_grouped",
  stat = function(x) mean(x == 0),
  group = "series"
)

# Some functions accept covariates to set the x-axes
pp_check(mod,
  x = "season",
  type = "ribbon_grouped",
  prob = 0.5,
  prob_outer = 0.8,
  group = "series"
)

# Many plots can be made without the observed data
pp_check(mod, prefix = "ppd")


</code></pre>

<hr>
<h2 id='ppc.mvgam'>Plot conditional posterior predictive checks from <span class="pkg">mvgam</span> models</h2><span id='topic+ppc.mvgam'></span><span id='topic+ppc'></span>

<h3>Description</h3>

<p>Plot conditional posterior predictive checks from <span class="pkg">mvgam</span> models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ppc(object, ...)

## S3 method for class 'mvgam'
ppc(
  object,
  newdata,
  data_test,
  series = 1,
  type = "hist",
  n_bins,
  legend_position,
  xlab,
  ylab,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ppc.mvgam_+3A_object">object</code></td>
<td>
<p><code>list</code> object returned from <code>mvgam</code>. See <code><a href="#topic+mvgam">mvgam()</a></code></p>
</td></tr>
<tr><td><code id="ppc.mvgam_+3A_...">...</code></td>
<td>
<p>further <code><a href="graphics.html#topic+par">par</a></code> graphical parameters.</p>
</td></tr>
<tr><td><code id="ppc.mvgam_+3A_newdata">newdata</code></td>
<td>
<p>Optional <code>dataframe</code> or <code>list</code> of test data containing at least 'series' and 'time'
for the forecast horizon, in addition to any other variables included in the linear predictor of <code>formula</code>. If
included, the observed values in the test data are compared to the model's forecast distribution for exploring
biases in model predictions.
Note this is only useful if the same <code>newdata</code> was also included when fitting the original model.</p>
</td></tr>
<tr><td><code id="ppc.mvgam_+3A_data_test">data_test</code></td>
<td>
<p>Deprecated. Still works in place of <code>newdata</code> but users are recommended to use
<code>newdata</code> instead for more seamless integration into <code>R</code> workflows</p>
</td></tr>
<tr><td><code id="ppc.mvgam_+3A_series">series</code></td>
<td>
<p><code>integer</code> specifying which series in the set is to be plotted</p>
</td></tr>
<tr><td><code id="ppc.mvgam_+3A_type">type</code></td>
<td>
<p><code>character</code> specifying the type of posterior predictive check to calculate and plot.
Valid options are: 'rootogram', 'mean', 'hist', 'density', 'prop_zero', 'pit' and 'cdf'</p>
</td></tr>
<tr><td><code id="ppc.mvgam_+3A_n_bins">n_bins</code></td>
<td>
<p><code>integer</code> specifying the number of bins to use for binning observed values when plotting
a rootogram or histogram. Default is <code>50</code> bins for a rootogram, which means that if
there are <code style="white-space: pre;">&#8288;&gt;50&#8288;</code> unique observed values, bins will
be used to prevent overplotting and facilitate interpretation. Default for a histogram is to use the
number of bins returned by a call to <code>hist</code> in base <code>R</code></p>
</td></tr>
<tr><td><code id="ppc.mvgam_+3A_legend_position">legend_position</code></td>
<td>
<p>The location may also be specified by setting x to a single keyword from the
list &quot;bottomright&quot;, &quot;bottom&quot;, &quot;bottomleft&quot;, &quot;left&quot;, &quot;topleft&quot;, &quot;top&quot;, &quot;topright&quot;, &quot;right&quot; and &quot;center&quot;.
This places the legend on the inside of the plot frame at the given location. Or alternatively,
use &quot;none&quot; to hide the legend.</p>
</td></tr>
<tr><td><code id="ppc.mvgam_+3A_xlab">xlab</code></td>
<td>
<p>label for x axis.</p>
</td></tr>
<tr><td><code id="ppc.mvgam_+3A_ylab">ylab</code></td>
<td>
<p>label for y axis.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Conditional posterior predictions are drawn from the fitted <code>mvgam</code> and compared against
the empirical distribution of the observed data for a specified series to help evaluate the model's
ability to generate unbiased predictions. For all plots apart from <code>type = 'rootogram'</code>, posterior predictions
can also be compared to out of sample observations as long as these observations were included as
' data_test' in the original model fit and supplied here. Rootograms are currently only plotted using the
' hanging' style.
<br />
Note that the predictions used for these plots are <em>conditional on the observed data</em>, i.e. they
are those predictions that have been generated directly within
the <code>mvgam()</code> model. They can be misleading if the model included flexible dynamic trend components. For
a broader range of posterior checks that are created using <em>unconditional</em> &quot;new data&quot; predictions, see
<code><a href="#topic+pp_check.mvgam">pp_check.mvgam</a></code>
</p>


<h3>Value</h3>

<p>A base <code>R</code> graphics plot showing either a posterior rootogram (for <code>type == 'rootogram'</code>),
the predicted vs observed mean for the
series (for <code>type == 'mean'</code>), predicted vs observed proportion of zeroes for the
series (for <code>type == 'prop_zero'</code>),predicted vs observed histogram for the
series (for <code>type == 'hist'</code>), kernel density or empirical CDF estimates for
posterior predictions (for <code>type == 'density'</code> or <code>type == 'cdf'</code>) or a Probability
Integral Transform histogram (for <code>type == 'pit'</code>).
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+pp_check.mvgam">pp_check.mvgam</a></code>, <code><a href="#topic+predict.mvgam">predict.mvgam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate some smooth effects and fit a model
set.seed(0)
dat &lt;- mgcv::gamSim(1, n = 200, scale = 2)
mod &lt;- mvgam(y ~ s(x0) + s(x1) + s(x2) + s(x3),
  data = dat,
  family = gaussian(),
  chains = 2,
  silent = 2
)

# Posterior checks
ppc(mod, type = "hist")
ppc(mod, type = "density")
ppc(mod, type = "cdf")

# Many more options are available with pp_check()
pp_check(mod)
pp_check(mod, type = "ecdf_overlay")
pp_check(mod, type = "freqpoly")

</code></pre>

<hr>
<h2 id='predict.mvgam'>Predict from a fitted <span class="pkg">mvgam</span> model</h2><span id='topic+predict.mvgam'></span>

<h3>Description</h3>

<p>Predict from a fitted <span class="pkg">mvgam</span> model
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
predict(
  object,
  newdata,
  data_test,
  type = "link",
  process_error = FALSE,
  summary = TRUE,
  robust = FALSE,
  probs = c(0.025, 0.975),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="predict.mvgam_+3A_object">object</code></td>
<td>
<p><code>list</code> object of class <code>mvgam</code> or <code>jsdgam</code>. See <code><a href="#topic+mvgam">mvgam()</a></code></p>
</td></tr>
<tr><td><code id="predict.mvgam_+3A_newdata">newdata</code></td>
<td>
<p>Optional <code>dataframe</code> or <code>list</code> of test data containing the same variables
that were included in the original <code>data</code> used to fit the model. If not supplied,
predictions are generated for the original observations used for the model fit.</p>
</td></tr>
<tr><td><code id="predict.mvgam_+3A_data_test">data_test</code></td>
<td>
<p>Deprecated. Still works in place of <code>newdata</code> but users are recommended to use
<code>newdata</code> instead for more seamless integration into <code>R</code> workflows</p>
</td></tr>
<tr><td><code id="predict.mvgam_+3A_type">type</code></td>
<td>
<p>When this has the value <code>link</code> (default) the linear predictor is
calculated on the link scale.
If <code>expected</code> is used, predictions reflect the expectation of the response (the mean)
but ignore uncertainty in the observation process. When <code>response</code> is used,
the predictions take uncertainty in the observation process into account to return
predictions on the outcome scale. When <code>variance</code> is used, the variance of the response
with respect to the mean (mean-variance relationship) is returned.
When <code>type = "terms"</code>, each component of the linear predictor is
returned separately in the form of a <code>list</code> (possibly with standard
errors, if <code>summary = TRUE</code>): this includes parametric model components,
followed by each smooth component, but excludes any offset and any intercept.
Two special cases are also allowed:
type <code>latent_N</code> will return the estimated latent abundances from an
N-mixture distribution, while type <code>detection</code> will return the estimated
detection probability from an N-mixture distribution</p>
</td></tr>
<tr><td><code id="predict.mvgam_+3A_process_error">process_error</code></td>
<td>
<p>Logical. If <code>TRUE</code> and a dynamic trend model was fit,
expected uncertainty in the process model is accounted for by using draws
from the latent trend SD parameters. If <code>FALSE</code>, uncertainty in the latent trend
component is ignored when calculating predictions</p>
</td></tr>
<tr><td><code id="predict.mvgam_+3A_summary">summary</code></td>
<td>
<p>Should summary statistics be returned
instead of the raw values? Default is <code>TRUE</code>..</p>
</td></tr>
<tr><td><code id="predict.mvgam_+3A_robust">robust</code></td>
<td>
<p>If <code>FALSE</code> (the default) the mean is used as
the measure of central tendency and the standard deviation as
the measure of variability. If <code>TRUE</code>, the median and the
median absolute deviation (MAD) are applied instead.
Only used if <code>summary</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict.mvgam_+3A_probs">probs</code></td>
<td>
<p>The percentiles to be computed by the <code>quantile</code>
function. Only used if <code>summary</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="predict.mvgam_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Note that for all types of predictions for models that did not include
a <code>trend_formula</code>, uncertainty in the dynamic trend
component can be ignored by setting <code>process_error = FALSE</code>. However,
if a <code>trend_formula</code> was supplied in the model, predictions for this component cannot be
ignored. If <code>process_error = TRUE</code>, trend predictions will ignore autocorrelation
coefficients or GP length scale coefficients, ultimately assuming the process is stationary.
This method is similar to the types of posterior predictions returned from <code>brms</code> models
when using autocorrelated error predictions for newdata.
This function is therefore more suited to posterior simulation from the GAM components
of a <code>mvgam</code> model, while the forecasting functions
<code><a href="#topic+plot_mvgam_fc">plot_mvgam_fc</a></code> and <code><a href="#topic+forecast.mvgam">forecast.mvgam</a></code> are better suited to generate h-step ahead forecasts
that respect the temporal dynamics of estimated latent trends.
</p>


<h3>Value</h3>

<p>Predicted values on the appropriate scale.
If <code>summary = FALSE</code> and <code>type != "terms"</code>,
the output is a matrix of dimension <code style="white-space: pre;">&#8288;n_draw x n_observations&#8288;</code>
containing predicted values for each posterior draw in <code>object</code>.
</p>
<p>If <code>summary = TRUE</code> and <code>type != "terms"</code>, the output is an <code>n_observations</code> x <code>E</code>
matrix. The number of summary statistics <code>E</code> is equal to <code>2 +
  length(probs)</code>: The <code>Estimate</code> column contains point estimates (either
mean or median depending on argument <code>robust</code>), while the
<code>Est.Error</code> column contains uncertainty estimates (either standard
deviation or median absolute deviation depending on argument
<code>robust</code>). The remaining columns starting with <code>Q</code> contain
quantile estimates as specified via argument <code>probs</code>.
</p>
<p>If <code>type = "terms"</code> and <code>summary = FALSE</code>, the output is a named <code>list</code>
containing a separate slot for each effect, with the effects returned as
matrices of dimension <code style="white-space: pre;">&#8288;n_draw x 1&#8288;</code>. If <code>summary = TRUE</code>, the output resembles that
from <code><a href="mgcv.html#topic+predict.gam">predict.gam</a></code> when using the call
<code>predict.gam(object, type = "terms", se.fit = TRUE)</code>, where mean contributions
from each effect are returned in <code>matrix</code> form while standard errors (representing
the interval: <code>(max(probs) - min(probs)) / 2</code>) are returned in a separate <code>matrix</code>
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate 4 time series with hierarchical seasonality
# and independent AR1 dynamic processes
set.seed(111)
simdat &lt;- sim_mvgam(seasonality = 'hierarchical',
                   trend_model = 'AR1',
                   family = gaussian())

# Fit a model with shared seasonality
mod1 &lt;- mvgam(y ~ s(season, bs = 'cc', k = 6),
             data = simdat$data_train,
             family = gaussian(),
             trend_model = AR(),
             noncentred = TRUE,
             chains = 2,
             silent = 2)

# Generate predictions against observed data
preds &lt;- predict(mod1,
                summary = TRUE)
head(preds)

# Generate predictions against test data
preds &lt;- predict(mod1,
                newdata = simdat$data_test,
                summary = TRUE)
head(preds)

</code></pre>

<hr>
<h2 id='print.mvgam'>Summary for a fitted <span class="pkg">mvgam</span> object</h2><span id='topic+print.mvgam'></span>

<h3>Description</h3>

<p>This function takes a fitted <code>mvgam</code> or <code>jsdgam</code> object and prints a quick summary
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
print(x, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="print.mvgam_+3A_x">x</code></td>
<td>
<p><code>list</code> object returned from <code>mvgam</code></p>
</td></tr>
<tr><td><code id="print.mvgam_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>A brief summary of the model's call is printed
</p>


<h3>Value</h3>

<p>A <code>list</code> is printed on-screen
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>

<hr>
<h2 id='PW'>Specify piecewise linear or logistic trends in <span class="pkg">mvgam</span> models</h2><span id='topic+PW'></span>

<h3>Description</h3>

<p>Set up piecewise linear or logistic trend models
in <code>mvgam</code>. These functions do not evaluate their arguments –
they exist purely to help set up a model with particular piecewise
trend models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>PW(
  n_changepoints = 10,
  changepoint_range = 0.8,
  changepoint_scale = 0.05,
  growth = "linear"
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="PW_+3A_n_changepoints">n_changepoints</code></td>
<td>
<p>A non-negative integer specifying the number of potential
changepoints. Potential changepoints are selected uniformly from the
first <code>changepoint_range</code> proportion of timepoints in <code>data</code>. Default is <code>10</code></p>
</td></tr>
<tr><td><code id="PW_+3A_changepoint_range">changepoint_range</code></td>
<td>
<p>Proportion of history in <code>data</code> in which trend changepoints
will be estimated. Defaults to 0.8 for the first 80%.</p>
</td></tr>
<tr><td><code id="PW_+3A_changepoint_scale">changepoint_scale</code></td>
<td>
<p>Parameter modulating the flexibility of the
automatic changepoint selection by altering the scale parameter of a Laplace distribution.
The resulting prior will be <code>double_exponential(0, changepoint_scale)</code>.
Large values will allow many changepoints and a more flexible trend, while
small values will allow few changepoints. Default is <code>0.05</code>.</p>
</td></tr>
<tr><td><code id="PW_+3A_growth">growth</code></td>
<td>
<p>Character string specifying either 'linear' or 'logistic' growth of
the trend. If 'logistic', a variable labelled <code>cap</code> MUST be in <code>data</code> to specify the
maximum saturation point for the trend (see details and examples in <code><a href="#topic+mvgam">mvgam</a></code> for
more information).
Default is 'linear'.</p>
</td></tr>
</table>


<h3>Details</h3>

<p><em>Offsets and intercepts</em>:
For each of these trend models, an offset parameter is included in the trend
estimation process. This parameter will be incredibly difficult to identify
if you also include an intercept in the observation formula. For that reason,
it is highly recommended that you drop the intercept from the formula
(i.e. <code>y ~ x + 0</code> or <code>y ~ x - 1</code>, where <code>x</code> are your optional predictor terms).
<br />
<br />
<em>Logistic growth and the cap variable</em>:
When forecasting growth, there is often some maximum achievable point that
a time series can reach. For example, total market size, total population size
or carrying capacity in population dynamics. It can be advantageous for the forecast
to saturate at or near this point so that predictions are more sensible.
This function allows you to make forecasts using a logistic growth trend model,
with a specified carrying capacity. Note that this capacity does not need to be static
over time, it can vary with each series x timepoint combination if necessary. But you
must supply a <code>cap</code> value for each observation in the data when using <code>growth = 'logistic'</code>.
For observation families that use a non-identity link function, the <code>cap</code> value will
be internally transformed to the link scale (i.e. your specified <code>cap</code> will be log
transformed if you are using a <code>poisson()</code> or <code>nb()</code> family). It is therefore important
that you specify the <code>cap</code> values on the scale of your outcome. Note also that
no missing values are allowed in <code>cap</code>.
</p>


<h3>Value</h3>

<p>An object of class <code>mvgam_trend</code>, which contains a list of
arguments to be interpreted by the parsing functions in <code>mvgam</code>
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>References</h3>

<p>Taylor, Sean J., and Benjamin Letham. &quot;Forecasting at scale.&quot; The American Statistician 72.1 (2018): 37-45.
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Example of logistic growth with possible changepoints
# Simple logistic growth model
dNt = function(r, N, k){
   r * N * (k - N)
}

# Iterate growth through time
Nt = function(r, N, t, k) {
for (i in 1:(t - 1)) {

 # population at next time step is current population + growth,
 # but we introduce several 'shocks' as changepoints
 if(i %in% c(5, 15, 25, 41, 45, 60, 80)){
   N[i + 1] &lt;- max(1, N[i] + dNt(r + runif(1, -0.1, 0.1),
                                 N[i], k))
   } else {
   N[i + 1] &lt;- max(1, N[i] + dNt(r, N[i], k))
   }
  }
 N
}

# Simulate expected values
set.seed(11)
expected &lt;- Nt(0.004, 2, 100, 30)
plot(expected, xlab = 'Time')

# Take Poisson draws
y &lt;- rpois(100, expected)
plot(y, xlab = 'Time')

# Assemble data into dataframe and model. We set a
# fixed carrying capacity of 35 for this example, but note that
# this value is not required to be fixed at each timepoint
mod_data &lt;- data.frame(y = y,
                       time = 1:100,
                       cap = 35,
                       series = as.factor('series_1'))
plot_mvgam_series(data = mod_data)

# The intercept is nonidentifiable when using piecewise
# trends because the trend functions have their own offset
# parameters 'm'; it is recommended to always drop intercepts
# when using these trend models
mod &lt;- mvgam(y ~ 0,
             trend_model = PW(growth = 'logistic'),
             family = poisson(),
             data = mod_data,
             chains = 2,
             silent = 2)
summary(mod)

# Plot the posterior hindcast
hc &lt;- hindcast(mod)
plot(hc)

# View the changepoints with ggplot2 utilities
library(ggplot2)
mcmc_plot(mod, variable = 'delta_trend',
          regex = TRUE) +
scale_y_discrete(labels = mod$trend_model$changepoints) +
labs(y = 'Potential changepoint',
     x = 'Rate change')

# Generate a methods description scaffold
how_to_cite(mod)

</code></pre>

<hr>
<h2 id='reexports'>Objects exported from other packages</h2><span id='topic+reexports'></span><span id='topic+as_draws'></span><span id='topic+as_draws_matrix'></span><span id='topic+as_draws_df'></span><span id='topic+as_draws_array'></span><span id='topic+as_draws_list'></span><span id='topic+as_draws_rvars'></span><span id='topic+conditional_effects'></span><span id='topic+prior'></span><span id='topic+prior_'></span><span id='topic+set_prior'></span><span id='topic+prior_string'></span><span id='topic+loo'></span><span id='topic+loo_compare'></span><span id='topic+predictions'></span><span id='topic+avg_predictions'></span><span id='topic+plot_predictions'></span><span id='topic+slopes'></span><span id='topic+plot_slopes'></span><span id='topic+comparisons'></span><span id='topic+plot_comparisons'></span><span id='topic+datagrid'></span><span id='topic+hypotheses'></span><span id='topic+get_predict'></span><span id='topic+get_data'></span><span id='topic+mcmc_plot'></span><span id='topic+gp'></span><span id='topic+s'></span><span id='topic+te'></span><span id='topic+ti'></span><span id='topic+t2'></span><span id='topic+posterior_predict'></span><span id='topic+posterior_epred'></span><span id='topic+posterior_linpred'></span><span id='topic+stancode'></span><span id='topic+standata'></span><span id='topic+augment'></span>

<h3>Description</h3>

<p>These objects are imported from other packages. Follow the links
below to see their documentation.
</p>

<dl>
<dt>brms</dt><dd><p><code><a href="brms.html#topic+conditional_effects.brmsfit">conditional_effects</a></code>, <code><a href="brms.html#topic+gp">gp</a></code>, <code><a href="brms.html#topic+mcmc_plot.brmsfit">mcmc_plot</a></code>, <code><a href="brms.html#topic+set_prior">prior</a></code>, <code><a href="brms.html#topic+set_prior">prior_</a></code>, <code><a href="brms.html#topic+set_prior">prior_string</a></code>, <code><a href="brms.html#topic+set_prior">set_prior</a></code>, <code><a href="brms.html#topic+stancode">stancode</a></code>, <code><a href="brms.html#topic+standata">standata</a></code></p>
</dd>
<dt>generics</dt><dd><p><code><a href="generics.html#topic+augment">augment</a></code></p>
</dd>
<dt>insight</dt><dd><p><code><a href="insight.html#topic+get_data">get_data</a></code></p>
</dd>
<dt>loo</dt><dd><p><code><a href="loo.html#topic+loo">loo</a></code>, <code><a href="loo.html#topic+loo_compare">loo_compare</a></code></p>
</dd>
<dt>marginaleffects</dt><dd><p><code><a href="marginaleffects.html#topic+predictions">avg_predictions</a></code>, <code><a href="marginaleffects.html#topic+comparisons">comparisons</a></code>, <code><a href="marginaleffects.html#topic+datagrid">datagrid</a></code>, <code><a href="marginaleffects.html#topic+get_predict">get_predict</a></code>, <code><a href="marginaleffects.html#topic+hypotheses">hypotheses</a></code>, <code><a href="marginaleffects.html#topic+plot_comparisons">plot_comparisons</a></code>, <code><a href="marginaleffects.html#topic+plot_predictions">plot_predictions</a></code>, <code><a href="marginaleffects.html#topic+plot_slopes">plot_slopes</a></code>, <code><a href="marginaleffects.html#topic+predictions">predictions</a></code>, <code><a href="marginaleffects.html#topic+slopes">slopes</a></code></p>
</dd>
<dt>mgcv</dt><dd><p><code><a href="mgcv.html#topic+s">s</a></code>, <code><a href="mgcv.html#topic+t2">t2</a></code>, <code><a href="mgcv.html#topic+te">te</a></code>, <code><a href="mgcv.html#topic+te">ti</a></code></p>
</dd>
<dt>posterior</dt><dd><p><code><a href="posterior.html#topic+draws">as_draws</a></code>, <code><a href="posterior.html#topic+draws_array">as_draws_array</a></code>, <code><a href="posterior.html#topic+draws_df">as_draws_df</a></code>, <code><a href="posterior.html#topic+draws_list">as_draws_list</a></code>, <code><a href="posterior.html#topic+draws_matrix">as_draws_matrix</a></code>, <code><a href="posterior.html#topic+draws_rvars">as_draws_rvars</a></code></p>
</dd>
<dt>rstantools</dt><dd><p><code><a href="rstantools.html#topic+posterior_epred">posterior_epred</a></code>, <code><a href="rstantools.html#topic+posterior_linpred">posterior_linpred</a></code>, <code><a href="rstantools.html#topic+posterior_predict">posterior_predict</a></code></p>
</dd>
</dl>

<hr>
<h2 id='residual_cor.jsdgam'>Extract residual correlations based on latent factors from a fitted jsdgam</h2><span id='topic+residual_cor.jsdgam'></span><span id='topic+residual_cor'></span>

<h3>Description</h3>

<p>Compute residual correlation estimates from Joint Species Distribution
<code>jsdgam</code> models using latent factor loadings
</p>


<h3>Usage</h3>

<pre><code class='language-R'>residual_cor(object, ...)

## S3 method for class 'jsdgam'
residual_cor(
  object,
  summary = TRUE,
  robust = FALSE,
  probs = c(0.025, 0.975),
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residual_cor.jsdgam_+3A_object">object</code></td>
<td>
<p><code>list</code> object of class <code>mvgam</code> resulting from a call to <code><a href="#topic+jsdgam">jsdgam()</a></code></p>
</td></tr>
<tr><td><code id="residual_cor.jsdgam_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
<tr><td><code id="residual_cor.jsdgam_+3A_summary">summary</code></td>
<td>
<p>Should summary statistics be returned
instead of the raw values? Default is <code>TRUE</code>..</p>
</td></tr>
<tr><td><code id="residual_cor.jsdgam_+3A_robust">robust</code></td>
<td>
<p>If <code>FALSE</code> (the default) the mean is used as a measure of central tendency.
If <code>TRUE</code>, the median is used instead. Only used if <code>summary</code> is <code>TRUE</code></p>
</td></tr>
<tr><td><code id="residual_cor.jsdgam_+3A_probs">probs</code></td>
<td>
<p>The percentiles to be computed by the <code>quantile</code>
function. Only used if <code>summary</code> is <code>TRUE</code>.</p>
</td></tr>
</table>


<h3>Details</h3>

<p>Hui (2016) provides an excellent description of the quantities that this function calculates, so this passage
is heavily paraphrased from his associated <span class="pkg">boral</span> package.
</p>
<p>In Joint Species Distribution Models, the residual covariance matrix is calculated
based on the matrix of latent factor loading matrix <code class="reqn">\Theta</code>, where the residual covariance
matrix <code class="reqn">\Sigma = \Theta\Theta'</code>. A strong residual covariance/correlation matrix
between two species can be interpreted as evidence of species interaction (e.g.,
facilitation or competition),
missing covariates, as well as any additional species correlation not accounted for by shared
environmental captured in <code>formula</code>.
</p>
<p>The residual precision matrix (also known as partial correlation matrix, Ovaskainen et al., 2016)
is defined as the inverse of the residual correlation matrix. The precision matrix is often used to
identify direct or causal relationships between two species e.g., two species can have a zero
precision but still be correlated, which can be interpreted as saying that two species are not
directly associated, but they are still correlated <em>through</em> other species. In other words, they
are conditionally independent given the other species. It is important that the precision matrix
does not exhibit the exact same properties of the correlation e.g., the diagonal elements are
not equal to 1. Nevertheless, relatively larger values of precision may imply stronger
direct relationships between two species.
</p>
<p>In addition to the residual correlation and precision matrices, the median or mean point estimator
of trace of the residual covariance matrix is returned,
<code class="reqn">\sum\limits_{j=1}^p [\Theta\Theta']_{jj}</code>. Often used in other areas of multivariate
statistics, the trace may be interpreted as the amount of covariation explained by the latent factors.
One situation where the trace may be useful is when comparing a pure latent factor model
(where no terms are suppled to <code>formula</code>) versus a model with latent
factors and some additional predictors in <code>formula</code> &ndash; the proportional difference in trace
between these two models may be interpreted as the proportion of covariation between species explained
by the predictors in <code>formula</code>. Of course, the trace itself is random due to the MCMC sampling, and so it
is not always guaranteed to produce sensible answers.
</p>


<h3>Value</h3>

<p>If <code>summary = TRUE</code>, a <code>list</code> of class <code>mvgam_residcor</code> with the following components:
</p>
<table role = "presentation">
<tr><td><code>cor</code>, <code>cor_lower</code>, <code>cor_upper</code></td>
<td>
<p>A set of <code class="reqn">p \times p</code> correlation matrices,
containing either the posterior median or mean estimate, plus lower and upper limits
of the corresponding credible intervals supplied to <code>probs</code></p>
</td></tr>
<tr><td><code>sig_cor</code></td>
<td>
<p>A <code class="reqn">p \times p</code> correlation matrix containing only those correlations whose credible
interval does not contain zero. All other correlations are set to zero</p>
</td></tr>
<tr><td><code>prec</code>, <code>prec_lower</code>, <code>prec_upper</code></td>
<td>
<p>A set of <code class="reqn">p \times p</code> precision matrices,
containing either the posterior median or mean estimate, plus lower and upper limits
of the corresponding credible intervals supplied to <code>probs</code></p>
</td></tr>
<tr><td><code>sig_prec</code></td>
<td>
<p>A <code class="reqn">p \times p</code> precision matrix containing only those precisions whose credible
interval does not contain zero. All other precisions are set to zero</p>
</td></tr>
<tr><td><code>cov</code></td>
<td>
<p>A <code class="reqn">p \times p</code> posterior median or mean covariance matrix</p>
</td></tr>
<tr><td><code>trace</code></td>
<td>
<p>The median/mean point estimator of the trace (sum of the diagonal elements)
of the residual covariance matrix <code>cov</code></p>
</td></tr>
</table>
<p>If <code>summary = FALSE</code>, this function returns a <code>list</code> containing the following components:
</p>
<table role = "presentation">
<tr><td><code>all_cormat</code></td>
<td>
<p>A <code class="reqn">n_{draws} \times p \times p</code> <code>array</code> of posterior
residual correlation matrix draws</p>
</td></tr>
<tr><td><code>all_covmat</code></td>
<td>
<p>A <code class="reqn">n_{draws} \times p \times p</code> <code>array</code> of posterior
residual covariance matrix draws</p>
</td></tr>
<tr><td><code>all_presmat</code></td>
<td>
<p>A <code class="reqn">n_{draws} \times p \times p</code> <code>array</code> of posterior
residual precision matrix draws</p>
</td></tr>
<tr><td><code>all_trace</code></td>
<td>
<p>A <code class="reqn">n_{draws}</code> <code>vector</code> of posterior covariance trace draws</p>
</td></tr>
</table>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>References</h3>

<p>Francis KC Hui (2016). BORAL - Bayesian ordination and regression analysis of
multivariate abundance data in R. Methods in Ecology and Evolution. 7, 744-750.
<br />
<br />
Otso Ovaskainen et al. (2016). Using latent variable models to identify large networks of
species-to-species associations at different spatial scales. Methods in Ecology and Evolution,
7, 549-555.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+jsdgam">jsdgam()</a></code>
</p>

<hr>
<h2 id='residuals.mvgam'>Posterior draws of residuals from <span class="pkg">mvgam</span> models</h2><span id='topic+residuals.mvgam'></span>

<h3>Description</h3>

<p>This method extracts posterior draws of Dunn-Smyth (randomized quantile)
residuals in the order in which the data were supplied to the model. It included
additional arguments for obtaining summaries of the computed residuals
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
residuals(object, summary = TRUE, robust = FALSE, probs = c(0.025, 0.975), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="residuals.mvgam_+3A_object">object</code></td>
<td>
<p>An object of class <code>mvgam</code></p>
</td></tr>
<tr><td><code id="residuals.mvgam_+3A_summary">summary</code></td>
<td>
<p>Should summary statistics be returned
instead of the raw values? Default is <code>TRUE</code>..</p>
</td></tr>
<tr><td><code id="residuals.mvgam_+3A_robust">robust</code></td>
<td>
<p>If <code>FALSE</code> (the default) the mean is used as
the measure of central tendency and the standard deviation as
the measure of variability. If <code>TRUE</code>, the median and the
median absolute deviation (MAD) are applied instead.
Only used if <code>summary</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="residuals.mvgam_+3A_probs">probs</code></td>
<td>
<p>The percentiles to be computed by the <code>quantile</code>
function. Only used if <code>summary</code> is <code>TRUE</code>.</p>
</td></tr>
<tr><td><code id="residuals.mvgam_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>This method gives residuals as Dunn-Smyth (randomized quantile) residuals. Any
observations that were missing (i.e. <code>NA</code>) in the original data will have missing values
in the residuals
</p>


<h3>Value</h3>

<p>An <code>array</code> of randomized quantile residual values.
If <code>summary = FALSE</code> the output resembles those of
<code><a href="#topic+posterior_epred.mvgam">posterior_epred.mvgam</a></code> and <code><a href="#topic+predict.mvgam">predict.mvgam</a></code>.
</p>
<p>If <code>summary = TRUE</code> the output is an <code>n_observations</code> x <code>E</code>
matrix. The number of summary statistics <code>E</code> is equal to <code>2 +
  length(probs)</code>: The <code>Estimate</code> column contains point estimates (either
mean or median depending on argument <code>robust</code>), while the
<code>Est.Error</code> column contains uncertainty estimates (either standard
deviation or median absolute deviation depending on argument
<code>robust</code>). The remaining columns starting with <code>Q</code> contain
quantile estimates as specified via argument <code>probs</code>.
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+augment.mvgam">augment.mvgam</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate some data and fit a model
simdat &lt;- sim_mvgam(n_series = 1, trend_model = AR())
mod &lt;- mvgam(y ~ s(season, bs = 'cc'),
             trend_model = AR(),
             noncentred = TRUE,
             data = simdat$data_train,
             chains = 2,
             silent = 2)

# Extract posterior residuals
resids &lt;- residuals(mod)
str(resids)

# Or add them directly to the observed data, along with fitted values
augment(mod, robust = FALSE, probs = c(0.25, 0.75))

</code></pre>

<hr>
<h2 id='RW'>Specify autoregressive dynamic processes in <span class="pkg">mvgam</span></h2><span id='topic+RW'></span><span id='topic+AR'></span><span id='topic+CAR'></span><span id='topic+VAR'></span>

<h3>Description</h3>

<p>Set up autoregressive or autoregressive moving average trend models
in <span class="pkg">mvgam</span>. These functions do not evaluate their arguments –
they exist purely to help set up a model with particular autoregressive
trend models.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>RW(ma = FALSE, cor = FALSE, gr = NA, subgr = NA)

AR(p = 1, ma = FALSE, cor = FALSE, gr = NA, subgr = NA)

CAR(p = 1)

VAR(ma = FALSE, cor = FALSE, gr = NA, subgr = NA)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="RW_+3A_ma">ma</code></td>
<td>
<p><code>Logical</code> Include moving average terms of order <code>1</code>?
Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="RW_+3A_cor">cor</code></td>
<td>
<p><code>Logical</code> Include correlated process errors as part of a
multivariate normal process model? If <code>TRUE</code> and if <code>n_series &gt; 1</code>
in the supplied data, a fully structured covariance matrix will be estimated
for the process errors. Default is <code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="RW_+3A_gr">gr</code></td>
<td>
<p>An optional grouping variable, which must be a <code>factor</code> in the supplied <code>data</code>,
for setting up hierarchical residual correlation structures. If specified,
this will automatically set <code>cor = TRUE</code> and set up a model where the
residual correlations for a specific level of <code>gr</code> are modelled hierarchically:
<code class="reqn">\Omega_{group} = \alpha_{cor}\Omega_{global} + (1 - \alpha_{cor})\Omega_{group, local}</code>,
where <code class="reqn">\Omega_{global}</code> is a <em>global</em> correlation
matrix, <code class="reqn">\Omega_{group, local}</code> is a <em>local deviation</em> correlation matrix
and <code class="reqn">\alpha_{cor}</code> is a weighting parameter
controlling how strongly the local correlation matrix <code class="reqn">\Omega_{group}</code>
is shrunk towards the global
correlation matrix <code class="reqn">\Omega_{global}</code> (larger values of <code class="reqn">\alpha_{cor}</code> indicate
a greater degree of shrinkage, i.e. a greater degree of partial pooling). When used
within a <code>VAR()</code> model, this essentially sets up a hierarchical panel vector autoregression
where both the autoregressive and correlation matrices are learned hierarchically.
If <code>gr</code> is supplied then <code>subgr</code> <em>must</em> also be supplied</p>
</td></tr>
<tr><td><code id="RW_+3A_subgr">subgr</code></td>
<td>
<p>A subgrouping <code>factor</code> variable specifying which element in <code>data</code> represents the
different time series. Defaults to <code>series</code>, but note that
models that use the hierarchical correlations, where the <code>subgr</code> time series are measured in each level of <code>gr</code>,
<em>should not</em> include a <code>series</code> element in <code>data</code>. Rather, this element will be created internally based
on the supplied variables for <code>gr</code> and <code>subgr</code>. For example, if you are modelling
temporal counts for a group of species (labelled as <code>species</code> in <code>data</code>) across three
different geographical regions (labelled as <code>region</code>),
and you would like the residuals to be correlated within regions,
then you should specify <code>gr = region</code> and <code>subgr = species</code>. Internally, <code>mvgam()</code> will create
the <code>series</code> element for the data using: <code style="white-space: pre;">&#8288;series = interaction(group, subgroup, drop = TRUE))&#8288;</code></p>
</td></tr>
<tr><td><code id="RW_+3A_p">p</code></td>
<td>
<p>A non-negative integer specifying the autoregressive (AR) order.
Default is <code>1</code>. Cannot currently be larger than <code>3</code> for <code>AR</code> terms,
and cannot be anything other than <code>1</code> for continuous time AR (<code>CAR</code>) terms</p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>mvgam_trend</code>, which contains a list of
arguments to be interpreted by the parsing functions in <span class="pkg">mvgam</span>
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# A short example to illustrate CAR(1) models
# Function to simulate CAR1 data with seasonality
sim_corcar1 = function(n = 125,
                      phi = 0.5,
                      sigma = 2,
                      sigma_obs = 0.75){
# Sample irregularly spaced time intervals
time_dis &lt;- c(0, runif(n - 1, -0.1, 1))
time_dis[time_dis &lt; 0] &lt;- 0; time_dis &lt;- time_dis * 5

# Set up the latent dynamic process
x &lt;- vector(length = n); x[1] &lt;- -0.3
for(i in 2:n){
 # zero-distances will cause problems in sampling, so mvgam uses a
 # minimum threshold; this simulation function emulates that process
 if(time_dis[i] == 0){
   x[i] &lt;- rnorm(1, mean = (phi ^ 1e-12) * x[i - 1], sd = sigma)
  } else {
    x[i] &lt;- rnorm(1, mean = (phi ^ time_dis[i]) * x[i - 1], sd = sigma)
  }
}

# Add 12-month seasonality
cov1 &lt;- sin(2 * pi * (1 : n) / 12); cov2 &lt;- cos(2 * pi * (1 : n) / 12)
beta1 &lt;- runif(1, 0.3, 0.7); beta2 &lt;- runif(1, 0.2, 0.5)
seasonality &lt;- beta1 * cov1 + beta2 * cov2

# Take Gaussian observations with error and return
data.frame(y = rnorm(n, mean = x + seasonality, sd = sigma_obs),
           season = rep(1:12, 20)[1:n],
           time = cumsum(time_dis))
}

# Sample two time series
dat &lt;- rbind(dplyr::bind_cols(sim_corcar1(phi = 0.65,
                                         sigma_obs = 0.55),
                             data.frame(series = 'series1')),
            dplyr::bind_cols(sim_corcar1(phi = 0.8,
                             sigma_obs = 0.35),
                             data.frame(series = 'series2'))) %&gt;%
      dplyr::mutate(series = as.factor(series))

# mvgam with CAR(1) trends and series-level seasonal smooths; the
# State-Space representation (using trend_formula) will be more efficient;
# using informative priors on the sigmas often helps with convergence
mod &lt;- mvgam(formula = y ~ -1,
            trend_formula = ~ s(season, bs = 'cc',
                                k = 5, by = trend),
            trend_model = CAR(),
            priors = c(prior(exponential(3),
                           class = sigma),
                       prior(beta(4, 4),
                           class = sigma_obs)),
            data = dat,
            family = gaussian(),
            chains = 2,
            silent = 2)

# View usual summaries and plots
summary(mod)
conditional_effects(mod, type = 'expected')
plot(mod, type = 'trend', series = 1)
plot(mod, type = 'trend', series = 2)
plot(mod, type = 'residuals', series = 1)
plot(mod, type = 'residuals', series = 2)
mcmc_plot(mod,
         variable = 'ar1',
         regex = TRUE,
         type = 'hist')

# Now an example illustrating hierarchical dynamics
set.seed(123)
# Simulate three species monitored in three different
# regions, where dynamics can potentially vary across regions
simdat1 &lt;- sim_mvgam(trend_model = VAR(cor = TRUE),
                    prop_trend = 0.95,
                    n_series = 3,
                    mu = c(1, 2, 3))
simdat2 &lt;- sim_mvgam(trend_model = VAR(cor = TRUE),
                    prop_trend = 0.95,
                    n_series = 3,
                    mu = c(1, 2, 3))
simdat3 &lt;- sim_mvgam(trend_model = VAR(cor = TRUE),
                    prop_trend = 0.95,
                    n_series = 3,
                    mu = c(1, 2, 3))

# Set up the data but DO NOT include 'series'
all_dat &lt;- rbind(simdat1$data_train %&gt;%
                  dplyr::mutate(region = 'qld'),
                simdat2$data_train %&gt;%
                  dplyr::mutate(region = 'nsw'),
                simdat3$data_train %&gt;%
                  dplyr::mutate(region = 'vic')) %&gt;%
dplyr::mutate(species = gsub('series', 'species', series),
              species = as.factor(species),
              region = as.factor(region)) %&gt;%
dplyr::arrange(series, time) %&gt;%
dplyr::select(-series)

# Check priors for a hierarchical AR1 model
get_mvgam_priors(formula = y ~ species,
                trend_model = AR(gr = region, subgr = species),
                data = all_dat)

# Fit the model
mod &lt;- mvgam(formula = y ~ species,
            trend_model = AR(gr = region, subgr = species),
            data = all_dat,
            chains = 2,
            silent = 2)

# Check standard outputs
summary(mod)
conditional_effects(mod, type = 'link')

# Inspect posterior estimates for the correlation weighting parameter
mcmc_plot(mod, variable = 'alpha_cor', type = 'hist')

</code></pre>

<hr>
<h2 id='score.mvgam_forecast'>Compute probabilistic forecast scores for <span class="pkg">mvgam</span> models</h2><span id='topic+score.mvgam_forecast'></span><span id='topic+score'></span>

<h3>Description</h3>

<p>Compute probabilistic forecast scores for <span class="pkg">mvgam</span> models
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam_forecast'
score(
  object,
  score = "crps",
  log = FALSE,
  weights,
  interval_width = 0.9,
  n_cores = 1,
  ...
)

score(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="score.mvgam_forecast_+3A_object">object</code></td>
<td>
<p><code>mvgam_forecast</code> object. See <code><a href="#topic+forecast.mvgam">forecast.mvgam()</a></code>.</p>
</td></tr>
<tr><td><code id="score.mvgam_forecast_+3A_score">score</code></td>
<td>
<p><code>character</code> specifying the type of proper scoring rule to use for evaluation. Options are:
<code>sis</code> (i.e. the Scaled Interval Score), <code>energy</code>, <code>variogram</code>, <code>elpd</code>
(i.e. the Expected log pointwise Predictive Density),
<code>drps</code> (i.e. the Discrete Rank Probability Score), <code>crps</code> (the Continuous Rank Probability Score)
or <code>brier</code> (the latter of which is only applicable for <code>bernoulli</code> models.
Note that when choosing <code>elpd</code>, the supplied object must have forecasts on the <code>link</code> scale so that
expectations can be calculated prior to scoring. If choosing <code>brier</code>, the object must have forecasts
on the <code>expected</code> scale (i.e. probability predictions). For all other scores, forecasts should be supplied
on the <code>response</code> scale (i.e. posterior predictions)</p>
</td></tr>
<tr><td><code id="score.mvgam_forecast_+3A_log">log</code></td>
<td>
<p><code>logical</code>. Should the forecasts and truths be logged prior to scoring?
This is often appropriate for comparing
performance of models when series vary in their observation ranges. Ignored if <code>score = 'brier'</code></p>
</td></tr>
<tr><td><code id="score.mvgam_forecast_+3A_weights">weights</code></td>
<td>
<p>optional <code>vector</code> of weights (where <code>length(weights) == n_series</code>)
for weighting pairwise correlations when evaluating the variogram score for multivariate
forecasts. Useful for down-weighting series that have larger magnitude observations or that
are of less interest when forecasting. Ignored if <code>score != 'variogram'</code></p>
</td></tr>
<tr><td><code id="score.mvgam_forecast_+3A_interval_width">interval_width</code></td>
<td>
<p>proportional value on <code style="white-space: pre;">&#8288;[0.05,0.95]&#8288;</code> defining the forecast interval
for calculating coverage and, if <code>score = 'sis'</code>, for calculating the interval score.
Ignored if <code>score = 'brier'</code></p>
</td></tr>
<tr><td><code id="score.mvgam_forecast_+3A_n_cores">n_cores</code></td>
<td>
<p><code>integer</code> specifying number of cores for calculating scores in parallel</p>
</td></tr>
<tr><td><code id="score.mvgam_forecast_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>a <code>list</code> containing scores and interval coverages per forecast horizon.
If <code>score %in% c('drps', 'crps', 'elpd', 'brier')</code>,
the list will also contain return the sum of all series-level scores per horizon. If
<code>score %in% c('energy','variogram')</code>, no series-level scores are computed and the only score returned
will be for all series. For all scores apart from <code>elpd</code> and <code>brier</code>, the <code>in_interval</code> column in each series-level
slot is a binary indicator of whether or not the true value was within the forecast's corresponding
posterior empirical quantiles. Intervals are not calculated when using <code>elpd</code> because forecasts
will only contain the linear predictors
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+forecast.mvgam">forecast.mvgam</a></code>, <code><a href="#topic+ensemble">ensemble</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate observations for three count-valued time series
data &lt;- sim_mvgam()
# Fit a dynamic model using 'newdata' to automatically produce forecasts
mod &lt;- mvgam(y ~ 1,
            trend_model = RW(),
            data = data$data_train,
            newdata = data$data_test,
            chains = 2,
            silent = 2)

# Extract forecasts into a 'mvgam_forecast' object
fc &lt;- forecast(mod)
plot(fc)

# Compute Discrete Rank Probability Scores and 0.90 interval coverages
fc_scores &lt;- score(fc, score = 'drps')
str(fc_scores)

# An example using binary data
data &lt;- sim_mvgam(family = bernoulli())
mod &lt;- mvgam(y ~ s(season, bs = 'cc', k = 6),
            trend_model = AR(),
            data = data$data_train,
            newdata = data$data_test,
            family = bernoulli(),
            chains = 2,
            silent = 2)

# Extract forecasts on the expectation (probability) scale
fc &lt;- forecast(mod, type = 'expected')
plot(fc)

# Compute Brier scores
fc_scores &lt;- score(fc, score = 'brier')
str(fc_scores)

</code></pre>

<hr>
<h2 id='series_to_mvgam'>Convert timeseries object to format necessary for <span class="pkg">mvgam</span> models</h2><span id='topic+series_to_mvgam'></span>

<h3>Description</h3>

<p>This function converts univariate or multivariate time series (<code>xts</code> or <code>ts</code> objects)
to the format necessary for <code><a href="#topic+mvgam">mvgam</a></code>
</p>


<h3>Usage</h3>

<pre><code class='language-R'>series_to_mvgam(series, freq, train_prop = 0.85)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="series_to_mvgam_+3A_series">series</code></td>
<td>
<p><code><a href="xts.html#topic+xts">xts</a></code> or <code><a href="stats.html#topic+ts">ts</a></code> object to be converted to <code><a href="#topic+mvgam">mvgam</a></code> format</p>
</td></tr>
<tr><td><code id="series_to_mvgam_+3A_freq">freq</code></td>
<td>
<p><code>integer</code>. The seasonal frequency of the series</p>
</td></tr>
<tr><td><code id="series_to_mvgam_+3A_train_prop">train_prop</code></td>
<td>
<p><code>numeric</code> stating the proportion of data to use for training. Should be between <code>0.25</code> and <code>0.95</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> object containing outputs needed for <code><a href="#topic+mvgam">mvgam</a></code>,
including 'data_train' and 'data_test'
</p>


<h3>Examples</h3>

<pre><code class='language-R'># A ts object example
data("sunspots")
series &lt;- cbind(sunspots, sunspots)
colnames(series) &lt;- c('blood', 'bone')
head(series)
series_to_mvgam(series, frequency(series), 0.85)

# An xts object example
library(xts)
dates &lt;- seq(as.Date("2001-05-01"), length=30, by="quarter")
data  &lt;- cbind(c(gas = rpois(30, cumprod(1+rnorm(30, mean = 0.01, sd = 0.001)))),
c(oil = rpois(30, cumprod(1+rnorm(30, mean = 0.01, sd = 0.001)))))
series &lt;- xts(x = data, order.by = dates)
colnames(series) &lt;- c('gas', 'oil')
head(series)
series_to_mvgam(series, freq = 4, train_prop = 0.85)

</code></pre>

<hr>
<h2 id='sim_mvgam'>Simulate a set of time series for modelling in <span class="pkg">mvgam</span></h2><span id='topic+sim_mvgam'></span>

<h3>Description</h3>

<p>This function simulates sets of time series data for fitting a multivariate GAM that includes
shared seasonality and dependence on state-space latent dynamic factors. Random
dependencies among series, i.e. correlations in their long-term trends, are included
in the form of correlated loadings on the latent dynamic factors
</p>


<h3>Usage</h3>

<pre><code class='language-R'>sim_mvgam(
  T = 100,
  n_series = 3,
  seasonality = "shared",
  use_lv = FALSE,
  n_lv = 0,
  trend_model = RW(),
  drift = FALSE,
  prop_trend = 0.2,
  trend_rel,
  freq = 12,
  family = poisson(),
  phi,
  shape,
  sigma,
  nu,
  mu,
  prop_missing = 0,
  prop_train = 0.85
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="sim_mvgam_+3A_t">T</code></td>
<td>
<p><code>integer</code>. Number of observations (timepoints)</p>
</td></tr>
<tr><td><code id="sim_mvgam_+3A_n_series">n_series</code></td>
<td>
<p><code>integer</code>. Number of discrete time series</p>
</td></tr>
<tr><td><code id="sim_mvgam_+3A_seasonality">seasonality</code></td>
<td>
<p><code>character</code>. Either <code>shared</code>, meaning that
all series share the exact same seasonal pattern,
or <code>hierarchical</code>, meaning that there is a global seasonality but
each series' pattern can deviate slightly</p>
</td></tr>
<tr><td><code id="sim_mvgam_+3A_use_lv">use_lv</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, use dynamic factors to estimate series'
latent trends in a reduced dimension format. If <code>FALSE</code>, estimate independent
latent trends for each series</p>
</td></tr>
<tr><td><code id="sim_mvgam_+3A_n_lv">n_lv</code></td>
<td>
<p><code>integer</code>. Number of latent dynamic factors for generating the series' trends.
Defaults to <code>0</code>, meaning that dynamics are estimated independently for each series</p>
</td></tr>
<tr><td><code id="sim_mvgam_+3A_trend_model">trend_model</code></td>
<td>
<p><code>character</code> specifying the time series dynamics for the latent trend.
Options are:
</p>

<ul>
<li> <p><code>None</code> (no latent trend component; i.e. the GAM component is all that
contributes to the linear predictor, and the observation process is the only
source of error; similarly to what is estimated by <code><a href="mgcv.html#topic+gam">gam</a></code>)
</p>
</li>
<li> <p><code>RW</code> (random walk with possible drift)
</p>
</li>
<li> <p><code>AR1</code> (with possible drift)
</p>
</li>
<li> <p><code>AR2</code> (with possible drift)
</p>
</li>
<li> <p><code>AR3</code> (with possible drift)
</p>
</li>
<li> <p><code>VAR1</code> (contemporaneously uncorrelated VAR1)
</p>
</li>
<li> <p><code>VAR1cor</code> (contemporaneously correlated VAR1)
</p>
</li>
<li> <p><code>GP</code> (Gaussian Process with squared exponential kernel)</p>
</li></ul>
<p> See <a href="#topic+mvgam_trends">mvgam_trends</a> for more details</p>
</td></tr>
<tr><td><code id="sim_mvgam_+3A_drift">drift</code></td>
<td>
<p><code>logical</code>, simulate a drift term for each trend</p>
</td></tr>
<tr><td><code id="sim_mvgam_+3A_prop_trend">prop_trend</code></td>
<td>
<p><code>numeric</code>. Relative importance of the trend for each series.
Should be between <code>0</code> and <code>1</code></p>
</td></tr>
<tr><td><code id="sim_mvgam_+3A_trend_rel">trend_rel</code></td>
<td>
<p>Deprecated. Use <code>prop_trend</code> instead</p>
</td></tr>
<tr><td><code id="sim_mvgam_+3A_freq">freq</code></td>
<td>
<p><code>integer</code>. The seasonal frequency of the series</p>
</td></tr>
<tr><td><code id="sim_mvgam_+3A_family">family</code></td>
<td>
<p><code>family</code> specifying the exponential observation family for the series.
Currently supported
families are: <code>nb()</code>, <code>poisson()</code>, <code>bernoulli()</code>, <code>tweedie()</code>, <code>gaussian()</code>,
<code>betar()</code>, <code>lognormal()</code>, <code>student()</code> and <code>Gamma()</code></p>
</td></tr>
<tr><td><code id="sim_mvgam_+3A_phi">phi</code></td>
<td>
<p><code>vector</code> of dispersion parameters for the series
(i.e. <code>size</code> for <code>nb()</code> or
<code>phi</code> for <code>betar()</code>). If <code>length(phi) &lt; n_series</code>,
the first element of <code>phi</code> will
be replicated <code>n_series</code> times.
Defaults to <code>5</code> for <code>nb()</code> and <code>tweedie()</code>; <code>10</code> for
<code>betar()</code></p>
</td></tr>
<tr><td><code id="sim_mvgam_+3A_shape">shape</code></td>
<td>
<p><code>vector</code> of shape parameters for the series
(i.e. <code>shape</code> for <code>gamma()</code>)
If <code>length(shape) &lt; n_series</code>, the first element of <code>shape</code> will
be replicated <code>n_series</code> times. Defaults to <code>10</code></p>
</td></tr>
<tr><td><code id="sim_mvgam_+3A_sigma">sigma</code></td>
<td>
<p><code>vector</code> of scale parameters for the series
(i.e. <code>sd</code> for <code>gaussian()</code> or <code>student()</code>,
<code>log(sd)</code> for <code>lognormal()</code>). If <code>length(sigma) &lt; n_series</code>, the first element of <code>sigma</code> will
be replicated <code>n_series</code> times. Defaults to <code>0.5</code> for <code>gaussian()</code> and
<code>student()</code>; <code>0.2</code> for <code>lognormal()</code></p>
</td></tr>
<tr><td><code id="sim_mvgam_+3A_nu">nu</code></td>
<td>
<p><code>vector</code> of degrees of freedom parameters for the
series (i.e. <code>nu</code> for <code>student()</code>)
If <code>length(nu) &lt; n_series</code>, the first element of <code>nu</code> will
be replicated <code>n_series</code> times. Defaults to <code>3</code></p>
</td></tr>
<tr><td><code id="sim_mvgam_+3A_mu">mu</code></td>
<td>
<p><code>vector</code> of location parameters for the series.
If <code>length(mu) &lt; n_series</code>, the first element of <code>mu</code> will
be replicated <code>n_series</code> times. Defaults to small random values
between <code>-0.5</code> and <code>0.5</code> on the link scale</p>
</td></tr>
<tr><td><code id="sim_mvgam_+3A_prop_missing">prop_missing</code></td>
<td>
<p><code>numeric</code> stating proportion of observations that are missing.
Should be between
<code>0</code> and <code>0.8</code>, inclusive</p>
</td></tr>
<tr><td><code id="sim_mvgam_+3A_prop_train">prop_train</code></td>
<td>
<p><code>numeric</code> stating the proportion of data to use for training.
Should be between <code>0.2</code> and <code>1</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> object containing outputs needed for <code><a href="#topic+mvgam">mvgam</a></code>,
including 'data_train' and 'data_test', as well as some additional information
about the simulated seasonality and trend dependencies
</p>


<h3>Examples</h3>

<pre><code class='language-R'># Simulate series with observations bounded at 0 and 1 (Beta responses)
sim_data &lt;- sim_mvgam(family = betar(), trend_model = RW(), prop_trend = 0.6)
plot_mvgam_series(data = sim_data$data_train, series = 'all')

# Now simulate series with overdispersed discrete observations
sim_data &lt;- sim_mvgam(family = nb(), trend_model = RW(), prop_trend = 0.6, phi = 10)
plot_mvgam_series(data = sim_data$data_train, series = 'all')
</code></pre>

<hr>
<h2 id='stability.mvgam'>Calculate measures of latent VAR community stability</h2><span id='topic+stability.mvgam'></span><span id='topic+stability'></span>

<h3>Description</h3>

<p>Compute reactivity, return rates and contributions of interactions to
stationary forecast variance from
<span class="pkg">mvgam</span> models with Vector Autoregressive dynamics
</p>


<h3>Usage</h3>

<pre><code class='language-R'>stability(object, ...)

## S3 method for class 'mvgam'
stability(object, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="stability.mvgam_+3A_object">object</code></td>
<td>
<p><code>list</code> object of class <code>mvgam</code> resulting from a call to <code><a href="#topic+mvgam">mvgam()</a></code>
that used a Vector Autoregressive latent process model (either as <code>VAR(cor = FALSE)</code> or
<code>VAR(cor = TRUE)</code>)</p>
</td></tr>
<tr><td><code id="stability.mvgam_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Details</h3>

<p>These measures of stability can be used to assess how important inter-series
dependencies are to the variability of a multivariate system and to ask how systems
are expected to respond to environmental perturbations. Using the formula for a latent VAR(1) as:
</p>
<p style="text-align: center;"><code class="reqn">
\mu_t \sim \text{MVNormal}(A(\mu_{t - 1}), \Sigma) \quad
</code>
</p>

<p>this function will calculate the long-term stationary forecast distribution of the system, which
has mean <code class="reqn">\mu_{\infty}</code> and variance <code class="reqn">\Sigma_{\infty}</code>, to then calculate the following quantities:
</p>

<ul>
<li> <p><code>prop_int</code>: Proportion of the volume of the stationary forecast distribution
that is attributable to lagged interactions (i.e. how important are the autoregressive
interaction coefficients in <code class="reqn">A</code> for explaining the shape of the stationary forecast distribution?):
</p>
<p style="text-align: center;"><code class="reqn">
    det(A)^2 \quad
    </code>
</p>

</li>
<li> <p><code>prop_int_adj</code>: Same as <code>prop_int</code> but scaled by the number of series <code class="reqn">p</code> to facilitate
direct comparisons among systems with different numbers of interacting variables:
</p>
<p style="text-align: center;"><code class="reqn">
    det(A)^{2/p} \quad
    </code>
</p>

</li>
<li> <p><code>prop_int_offdiag</code>: Sensitivity of <code>prop_int</code> to inter-series
interactions (i.e. how important are the off-diagonals of the autoregressive coefficient
matrix <code class="reqn">A</code> for shaping <code>prop_int</code>?), calculated as the relative magnitude of the <em>off-diagonals</em> in
the partial derivative matrix:
</p>
<p style="text-align: center;"><code class="reqn">
    [2~det(A) (A^{-1})^T] \quad
    </code>
</p>

</li>
<li> <p><code>prop_int_diag</code>: Sensitivity of <code>prop_int</code> to intra-series
interactions (i.e. how important are the diagonals of the autoregressive coefficient matrix <code class="reqn">A</code>
for shaping <code>prop_int</code>?), calculated as the relative magnitude of the <em>diagonals</em> in the partial derivative
matrix:
</p>
<p style="text-align: center;"><code class="reqn">
    [2~det(A) (A^{-1})^T] \quad
    </code>
</p>

</li>
<li> <p><code>prop_cov_offdiag</code>: Sensitivity of <code class="reqn">\Sigma_{\infty}</code> to inter-series error correlations
(i.e. how important are off-diagonal covariances in <code class="reqn">\Sigma</code> for shaping
<code class="reqn">\Sigma_{\infty}</code>?), calculated as the relative magnitude of the <em>off-diagonals</em> in
the partial derivative matrix:
</p>
<p style="text-align: center;"><code class="reqn">
    [2~det(\Sigma_{\infty}) (\Sigma_{\infty}^{-1})^T] \quad
    </code>
</p>

</li>
<li> <p><code>prop_cov_diag</code>: Sensitivity of <code class="reqn">\Sigma_{\infty}</code> to error variances
(i.e. how important are diagonal variances in <code class="reqn">\Sigma</code> for shaping
<code class="reqn">\Sigma_{\infty}</code>?), calculated as the relative magnitude of the <em>diagonals</em> in
the partial derivative matrix:
</p>
<p style="text-align: center;"><code class="reqn">
    [2~det(\Sigma_{\infty}) (\Sigma_{\infty}^{-1})^T] \quad
    </code>
</p>

</li>
<li> <p><code>reactivity</code>: A measure of the degree to which the system moves
away from a stable equilibrium following a perturbation.
Values <code style="white-space: pre;">&#8288;&gt; 0&#8288;</code> suggest the system is reactive, whereby a
perturbation of the system in one period can be amplified in the next period. If
<code class="reqn">\sigma_{max}(A)</code> is the largest singular value of <code class="reqn">A</code>, then reactivity is defined as:
</p>
<p style="text-align: center;"><code class="reqn">
    log\sigma_{max}(A) \quad
    </code>
</p>

</li>
<li> <p><code>mean_return_rate</code>: Asymptotic (long-term) return rate of the mean of the transition distribution
to the stationary mean, calculated using the largest eigenvalue of the matrix <code class="reqn">A</code>:
</p>
<p style="text-align: center;"><code class="reqn">
   max(\lambda_{A}) \quad
   </code>
</p>

<p>Lower values suggest greater stability
</p>
</li>
<li> <p><code>var_return_rate</code>: Asymptotic (long-term) return rate of the variance of the transition distribution
to the stationary variance:
</p>
<p style="text-align: center;"><code class="reqn">
   max(\lambda_{A \otimes{A}}) \quad
   </code>
</p>

<p>Again, lower values suggest greater stability
</p>
</li></ul>

<p>Major advantages of using <span class="pkg">mvgam</span> to compute these metrics are that well-calibrated uncertainties are
available and that VAR processes are forced to be stationary. These properties make it simple and
insightful to calculate and inspect aspects of both long-term and short-term stability.
But it is also possible to more directly inspect possible interactions among the
time series in a latent VAR process. To do so, you can calculate
Generalized or Orthogonalized Impulse Response Functions using the <code><a href="#topic+irf">irf</a></code> function,
or you can calculate Forecast Error Variance Decompositions using the <code><a href="#topic+fevd">fevd</a></code> function.
</p>


<h3>Value</h3>

<p>A <code>data.frame</code> containing posterior draws for each stability metric.
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>References</h3>

<p>AR Ives, B Dennis, KL Cottingham &amp; SR Carpenter (2003).
Estimating community stability and ecological interactions from time-series data.
Ecological Monographs. 73, 301-330.
</p>


<h3>See Also</h3>

<p><code><a href="#topic+VAR">VAR</a></code>, <code><a href="#topic+irf">irf</a></code>, <code><a href="#topic+fevd">fevd</a></code>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate some time series that follow a latent VAR(1) process
simdat &lt;- sim_mvgam(family = gaussian(),
                    n_series = 4,
                    trend_model = VAR(cor = TRUE),
                    prop_trend = 1)
plot_mvgam_series(data = simdat$data_train, series = 'all')

# Fit a model that uses a latent VAR(1)
mod &lt;- mvgam(y ~ -1,
             trend_formula = ~ 1,
             trend_model = VAR(cor = TRUE),
             family = gaussian(),
             data = simdat$data_train,
             chains = 2,
             silent = 2)

# Calulate stability metrics for this system
metrics &lt;- stability(mod)

# Proportion of stationary forecast distribution
# attributable to lagged interactions
hist(metrics$prop_int,
     xlim = c(0, 1),
     xlab = 'Prop_int',
     main = '',
     col = '#B97C7C',
     border = 'white')

# Within this contribution of interactions, how important
# are inter-series interactions (offdiagonals of the A matrix) vs
# intra-series density dependence (diagonals of the A matrix)?
layout(matrix(1:2, nrow = 2))
hist(metrics$prop_int_offdiag,
     xlim = c(0, 1),
     xlab = '',
     main = 'Inter-series interactions',
     col = '#B97C7C',
     border = 'white')

hist(metrics$prop_int_diag,
     xlim = c(0, 1),
     xlab = 'Contribution to interaction effect',
     main = 'Intra-series interactions (density dependence)',
     col = 'darkblue',
     border = 'white')
layout(1)

# How important are inter-series error covariances
# (offdiagonals of the Sigma matrix) vs
# intra-series variances (diagonals of the Sigma matrix) for explaining
# the variance of the stationary forecast distribution?
layout(matrix(1:2, nrow = 2))
hist(metrics$prop_cov_offdiag,
     xlim = c(0, 1),
     xlab = '',
     main = 'Inter-series covariances',
     col = '#B97C7C',
     border = 'white')

hist(metrics$prop_cov_diag,
     xlim = c(0, 1),
     xlab = 'Contribution to forecast variance',
     main = 'Intra-series variances',
     col = 'darkblue',
     border = 'white')
layout(1)

# Reactivity, i.e. degree to which the system moves
# away from a stable equilibrium following a perturbation
# (values &gt; 1 suggest a more reactive, less stable system)
hist(metrics$reactivity,
     main = '',
     xlab = 'Reactivity',
     col = '#B97C7C',
     border = 'white',
     xlim = c(-1*max(abs(metrics$reactivity)),
              max(abs(metrics$reactivity))))
abline(v = 0, lwd = 2.5)

</code></pre>

<hr>
<h2 id='summary.mvgam'>Summary for a fitted <span class="pkg">mvgam</span> models</h2><span id='topic+summary.mvgam'></span><span id='topic+summary.mvgam_prefit'></span><span id='topic+coef.mvgam'></span>

<h3>Description</h3>

<p>These functions take a fitted <code>mvgam</code> or <code>jsdgam</code> object and
return various useful summaries
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
summary(object, include_betas = TRUE, smooth_test = TRUE, digits = 2, ...)

## S3 method for class 'mvgam_prefit'
summary(object, ...)

## S3 method for class 'mvgam'
coef(object, summarise = TRUE, ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.mvgam_+3A_object">object</code></td>
<td>
<p><code>list</code> object returned from <code>mvgam</code></p>
</td></tr>
<tr><td><code id="summary.mvgam_+3A_include_betas">include_betas</code></td>
<td>
<p>Logical. Print a summary that includes posterior summaries
of all linear predictor beta coefficients (including spline coefficients)?
Defaults to <code>TRUE</code> but use <code>FALSE</code> for a more concise summary</p>
</td></tr>
<tr><td><code id="summary.mvgam_+3A_smooth_test">smooth_test</code></td>
<td>
<p>Logical. Compute estimated degrees of freedom and approximate
p-values for smooth terms? Defaults to <code>TRUE</code>, but users may wish to set
to <code>FALSE</code> for complex models with many smooth or random effect terms</p>
</td></tr>
<tr><td><code id="summary.mvgam_+3A_digits">digits</code></td>
<td>
<p>The number of significant digits for printing out the summary;
defaults to <code>2</code>.</p>
</td></tr>
<tr><td><code id="summary.mvgam_+3A_...">...</code></td>
<td>
<p>Ignored</p>
</td></tr>
<tr><td><code id="summary.mvgam_+3A_summarise">summarise</code></td>
<td>
<p><code>logical</code>. Summaries of coefficients will be returned
if <code>TRUE</code>. Otherwise the full posterior distribution will be returned</p>
</td></tr>
</table>


<h3>Details</h3>

<p><code>summary.mvgam</code> and <code>summary.mvgam_prefit</code> return brief summaries of the model's call, along with posterior intervals for
some of the key parameters in the model. Note that some smooths have extra penalties on the null space,
so summaries for the <code>rho</code> parameters may include more penalty terms than the number of smooths in
the original model formula. Approximate p-values for smooth terms are also returned,
with methods used for their
calculation following those used for <code>mgcv</code> equivalents (see <code><a href="mgcv.html#topic+summary.gam">summary.gam</a></code> for details).
The Estimated Degrees of Freedom (edf) for smooth terms is computed using
either <code>edf.type = 1</code> for models with no trend component, or <code>edf.type = 0</code> for models with
trend components. These are described in the documentation for <code><a href="mgcv.html#topic+jagam">jagam</a></code>. Experiments suggest
these p-values tend to be more conservative than those that might be returned from an equivalent
model fit with <code><a href="mgcv.html#topic+summary.gam">summary.gam</a></code> using <code>method = 'REML'</code>
</p>
<p><code>coef.mvgam</code> returns either summaries or full posterior estimates for <code>GAM</code> component
coefficients
</p>


<h3>Value</h3>

<p>For <code>summary.mvgam</code> and <code>summary.mvgam_prefit</code>, a <code>list</code> is printed
on-screen showing the summaries for the model
</p>
<p>For <code>coef.mvgam</code>, either a <code>matrix</code> of posterior coefficient distributions
(if <code>summarise == FALSE</code> or <code>data.frame</code> of coefficient summaries)
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>

<hr>
<h2 id='summary.mvgam_fevd'>Posterior summary of forecast error variance decompositions</h2><span id='topic+summary.mvgam_fevd'></span>

<h3>Description</h3>

<p>This function takes an <code>mvgam_fevd</code> object and
calculates a posterior summary of the error variance decompositions of each
series, at all horizons
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam_fevd'
summary(object, probs = c(0.025, 0.975), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.mvgam_fevd_+3A_object">object</code></td>
<td>
<p>an object of class <code>mvgam_fevd</code> obtained using the
<code>fevd()</code> function. This object will contain draws from the posterior
distribution of the forecast error variance decompositions.</p>
</td></tr>
<tr><td><code id="summary.mvgam_fevd_+3A_probs">probs</code></td>
<td>
<p>The upper and lower percentiles to be computed by the <code>quantile</code> function,
in addition to the median</p>
</td></tr>
<tr><td><code id="summary.mvgam_fevd_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A long-format <code>tibble</code> reporting the posterior median,
upper and lower percentiles of the error variance decompositions of
each series at all horizons.
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+fevd">fevd</a></code>, <code><a href="#topic+plot.mvgam_fevd">plot.mvgam_fevd</a></code>
</p>

<hr>
<h2 id='summary.mvgam_irf'>Posterior summary of impulse responses</h2><span id='topic+summary.mvgam_irf'></span>

<h3>Description</h3>

<p>This function takes an <code>mvgam_irf</code> object and
calculates a posterior summary of the impulse responses of each
series to shocks from each of the other series, at all horizons
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam_irf'
summary(object, probs = c(0.025, 0.975), ...)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="summary.mvgam_irf_+3A_object">object</code></td>
<td>
<p>an object of class <code>mvgam_irf</code> obtained using the
<code>irf()</code> function. This object will contain draws from the posterior
distribution of the impulse responses.</p>
</td></tr>
<tr><td><code id="summary.mvgam_irf_+3A_probs">probs</code></td>
<td>
<p>The upper and lower percentiles to be computed by the <code>quantile</code> function,
in addition to the median</p>
</td></tr>
<tr><td><code id="summary.mvgam_irf_+3A_...">...</code></td>
<td>
<p>ignored</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A long-format <code>tibble</code> reporting the posterior median,
upper and lower percentiles of the impulse responses of each series to shocks
from each of the other series at all horizons.
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>See Also</h3>

<p><code><a href="#topic+irf">irf</a></code>, <code><a href="#topic+plot.mvgam_irf">plot.mvgam_irf</a></code>
</p>

<hr>
<h2 id='update.mvgam'>Update an existing <span class="pkg">mvgam</span> model object</h2><span id='topic+update.mvgam'></span><span id='topic+update.jsdgam'></span>

<h3>Description</h3>

<p>This function allows a previously fitted <span class="pkg">mvgam</span> model to be updated
</p>


<h3>Usage</h3>

<pre><code class='language-R'>## S3 method for class 'mvgam'
update(
  object,
  formula,
  trend_formula,
  knots,
  trend_knots,
  trend_model,
  family,
  share_obs_params,
  data,
  newdata,
  trend_map,
  use_lv,
  n_lv,
  priors,
  chains,
  burnin,
  samples,
  threads,
  algorithm,
  lfo = FALSE,
  ...
)

## S3 method for class 'jsdgam'
update(
  object,
  formula,
  factor_formula,
  knots,
  factor_knots,
  data,
  newdata,
  n_lv,
  family,
  share_obs_params,
  priors,
  chains,
  burnin,
  samples,
  threads,
  algorithm,
  lfo = FALSE,
  ...
)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="update.mvgam_+3A_object">object</code></td>
<td>
<p><code>list</code> object returned from <code>mvgam</code>. See <code><a href="#topic+mvgam">mvgam()</a></code></p>
</td></tr>
<tr><td><code id="update.mvgam_+3A_formula">formula</code></td>
<td>
<p>Optional new <code>formula</code> object. Note, <code>mvgam</code> currently does not support dynamic formula
updates such as removal of specific terms with <code>- term</code>. When updating, the entire formula needs
to be supplied</p>
</td></tr>
<tr><td><code id="update.mvgam_+3A_trend_formula">trend_formula</code></td>
<td>
<p>An optional <code>formula</code> object specifying the GAM
process model formula. If
supplied, a linear predictor will be modelled for the latent trends to capture
process model evolution
separately from the observation model. Should not have a response variable
specified on the left-hand side
of the formula (i.e. a valid option would be <code>~ season + s(year)</code>). Also note
that you should not use
the identifier <code>series</code> in this formula to specify effects that vary across
time series. Instead you should use
<code>trend</code>. This will ensure that models in which a <code>trend_map</code> is supplied will
still work consistently
(i.e. by allowing effects to vary across process models, even when some time
series share the same underlying
process model). This feature is only currently available for <code>RW()</code>, <code>AR()</code>
and <code>VAR()</code> trend models.
In <code>nmix()</code> family models, the <code>trend_formula</code> is used to set up a linear
predictor for the underlying
latent abundance. Be aware that it can be very challenging to simultaneously
estimate intercept parameters
for both the observation mode (captured by <code>formula</code>) and the process model
(captured by <code>trend_formula</code>).
Users are recommended to drop one of these using the <code>- 1</code> convention in the
formula right hand side.</p>
</td></tr>
<tr><td><code id="update.mvgam_+3A_knots">knots</code></td>
<td>
<p>An optional <code>list</code> containing user specified knot values to
be used for basis construction.
For most bases the user simply supplies the knots to be used, which must match
up with the <code>k</code> value supplied
(note that the number of knots is not always just <code>k</code>). Different terms can
use different numbers of knots,
unless they share a covariate</p>
</td></tr>
<tr><td><code id="update.mvgam_+3A_trend_knots">trend_knots</code></td>
<td>
<p>As for <code>knots</code> above, this is an optional <code>list</code> of
knot values for smooth
functions within the <code>trend_formula</code></p>
</td></tr>
<tr><td><code id="update.mvgam_+3A_trend_model">trend_model</code></td>
<td>
<p><code>character</code> or  <code>function</code> specifying the time
series dynamics for the latent trend. Options are:
</p>

<ul>
<li> <p><code>None</code> (no latent trend component; i.e. the GAM component is all that
contributes to the linear predictor, and the observation process is the only
source of error; similarly to what is estimated by <code><a href="mgcv.html#topic+gam">gam</a></code>)
</p>
</li>
<li> <p><code>ZMVN</code> or <code>ZMVN()</code> (Zero-Mean Multivariate Normal; only available in
<code>Stan</code>)
</p>
</li>
<li> <p><code>'RW'</code> or <code>RW()</code>
</p>
</li>
<li> <p><code>'AR1'</code> or <code>AR(p = 1)</code>
</p>
</li>
<li> <p><code>'AR2'</code> or <code>AR(p = 2)</code>
</p>
</li>
<li> <p><code>'AR3'</code> or <code>AR(p = 3)</code>
</p>
</li>
<li> <p><code>'CAR1'</code> or <code>CAR(p = 1)</code>
</p>
</li>
<li> <p><code>'VAR1'</code>  or <code>VAR()</code>(only available in <code>Stan</code>)
</p>
</li>
<li> <p><code style="white-space: pre;">&#8288;'PWlogistic&#8288;</code>, <code>'PWlinear'</code> or <code>PW()</code> (only available in <code>Stan</code>)
</p>
</li>
<li> <p><code>'GP'</code> or <code>GP()</code> (Gaussian Process with squared exponential kernel;
only available in <code>Stan</code>)</p>
</li></ul>

<p>For all trend types apart from <code>ZMVN()</code>, <code>GP()</code>, <code>CAR()</code> and <code>PW()</code>, moving
average and/or correlated process error terms can also be estimated (for
example, <code>RW(cor = TRUE)</code> will set up a multivariate Random Walk if <code>n_series &gt; 1</code>).
It is also possible for many multivariate trends to estimate hierarchical
correlations if the data are structured among levels of a relevant grouping
factor. See <a href="#topic+mvgam_trends">mvgam_trends</a> for more details and see <a href="#topic+ZMVN">ZMVN</a> for an example.</p>
</td></tr>
<tr><td><code id="update.mvgam_+3A_family">family</code></td>
<td>
<p><code>family</code> specifying the exponential observation family for
the series. Currently supported
families are:
</p>

<ul>
<li><p><code>gaussian()</code> for real-valued data
</p>
</li>
<li><p><code>betar()</code> for proportional data on <code style="white-space: pre;">&#8288;(0,1)&#8288;</code>
</p>
</li>
<li><p><code>lognormal()</code> for non-negative real-valued data
</p>
</li>
<li><p><code>student_t()</code> for real-valued data
</p>
</li>
<li><p><code>Gamma()</code> for non-negative real-valued data
</p>
</li>
<li><p><code>bernoulli()</code> for binary data
</p>
</li>
<li><p><code>poisson()</code> for count data
</p>
</li>
<li><p><code>nb()</code> for overdispersed count data
</p>
</li>
<li><p><code>binomial()</code> for count data with imperfect detection when the number
of trials is known;
note that the <code>cbind()</code> function must be used to bind the discrete
observations and the discrete number
of trials
</p>
</li>
<li><p><code>beta_binomial()</code> as for <code>binomial()</code> but allows for overdispersion
</p>
</li>
<li><p><code>nmix()</code> for count data with imperfect detection when the number of
trials is unknown and should be modeled via a State-Space N-Mixture model.
The latent states are Poisson, capturing the 'true' latent
abundance, while the observation process is Binomial to account for
imperfect detection.
See <code><a href="#topic+mvgam_families">mvgam_families</a></code> for an example of how to use this family</p>
</li></ul>

<p>Default is <code>poisson()</code>.
See <code><a href="#topic+mvgam_families">mvgam_families</a></code> for more details</p>
</td></tr>
<tr><td><code id="update.mvgam_+3A_share_obs_params">share_obs_params</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code> and the <code>family</code>
has additional family-specific observation parameters (e.g. variance
components in
<code>student_t()</code> or <code>gaussian()</code>, or dispersion parameters in <code>nb()</code> or
<code>betar()</code>), these parameters will be shared across all outcome variables. This is handy
if you have multiple outcomes (time series in most <code>mvgam</code> models) that you
believe share some properties,
such as being from the same species over different spatial units. Default is
<code>FALSE</code>.</p>
</td></tr>
<tr><td><code id="update.mvgam_+3A_data">data</code></td>
<td>
<p>A <code>dataframe</code> or <code>list</code> containing the model response
variable and covariates
required by the GAM <code>formula</code> and optional <code>trend_formula</code>. Most
models should include columns:
</p>

<ul>
<li><p><code>series</code> (a <code>factor</code> index of the series IDs; the number of
levels should be identical
to the number of unique series labels (i.e. <code>n_series = length(levels(data$series))</code>))
</p>
</li>
<li><p><code>time</code> (<code>numeric</code> or <code>integer</code> index of the time point for
each observation).
For most dynamic trend types available in <code>mvgam</code> (see argument <code>trend_model</code>),
time should be
measured in discrete, regularly spaced intervals (i.e. <code>c(1, 2, 3, ...)</code>).
However you can
use irregularly spaced intervals if using <code>trend_model = CAR(1)</code>, though
note that any
temporal intervals that are exactly <code>0</code> will be adjusted to a very small number
(<code>1e-12</code>) to prevent sampling errors. See an example of <code>CAR()</code> trends in
<code><a href="#topic+CAR">CAR</a></code>
</p>
</li></ul>

<p>Note however that there are special cases where these identifiers are not
needed. For
example, models with hierarchical temporal correlation processes (e.g.
<code>AR(gr = region, subgr = species)</code>)
should NOT include a <code>series</code> identifier, as this will be constructed
internally (see
<code><a href="#topic+mvgam_trends">mvgam_trends</a></code> and <code><a href="#topic+AR">AR</a></code> for details). <code>mvgam</code> can also
fit models that do not
include a <code>time</code> variable if there are no temporal dynamic structures included
(i.e. <code>trend_model = 'None'</code> or
<code>trend_model = ZMVN()</code>). <code>data</code> should also include any other variables to be
included in
the linear predictor of <code>formula</code></p>
</td></tr>
<tr><td><code id="update.mvgam_+3A_newdata">newdata</code></td>
<td>
<p>Optional <code>dataframe</code> or <code>list</code> of test data containing
the same variables
as in <code>data</code>. If included, the
observations in variable <code>y</code> will be set to <code>NA</code> when fitting the
model so that posterior
simulations can be obtained</p>
</td></tr>
<tr><td><code id="update.mvgam_+3A_trend_map">trend_map</code></td>
<td>
<p>Optional <code>data.frame</code> specifying which series should depend
on which latent trends. Useful for allowing multiple series to depend on the
same latent trend process, but with different observation processes. If
supplied, a latent factor model is set up by setting <code>use_lv = TRUE</code> and
using the mapping to set up the shared trends. Needs to have column names
<code>series</code> and <code>trend</code>, with integer values in the <code>trend</code> column to state which
trend each series should depend on. The <code>series</code> column should have a single
unique entry for each series in the data (names should perfectly match factor
levels of the <code>series</code> variable in <code>data</code>). Note that if this is supplied,
the intercept parameter in the process model will NOT be automatically suppressed.
Not yet supported for models in wich the latent factors evolve in continuous time (<code>CAR()</code>).
See examples for details</p>
</td></tr>
<tr><td><code id="update.mvgam_+3A_use_lv">use_lv</code></td>
<td>
<p><code>logical</code>. If <code>TRUE</code>, use dynamic factors to estimate series'
latent trends in a reduced dimension format. Only available for
<code>RW()</code>, <code>AR()</code> and <code>GP()</code> trend models. Defaults to <code>FALSE</code></p>
</td></tr>
<tr><td><code id="update.mvgam_+3A_n_lv">n_lv</code></td>
<td>
<p><code>integer</code> the number of latent dynamic factors to use if
<code>use_lv == TRUE</code>. Cannot be <code>&gt; n_series</code>. Defaults arbitrarily to
<code>min(2, floor(n_series / 2))</code></p>
</td></tr>
<tr><td><code id="update.mvgam_+3A_priors">priors</code></td>
<td>
<p>An optional <code>data.frame</code> with prior
definitions or, preferentially, a vector containing
objects of class <code>brmsprior</code> (see. <code><a href="brms.html#topic+prior">prior</a></code> for details).
See <a href="#topic+get_mvgam_priors">get_mvgam_priors</a> and Details' for more information on changing default prior distributions</p>
</td></tr>
<tr><td><code id="update.mvgam_+3A_chains">chains</code></td>
<td>
<p><code>integer</code> specifying the number of parallel chains for the model. Ignored
if <code>algorithm %in% c('meanfield', 'fullrank', 'pathfinder', 'laplace')</code></p>
</td></tr>
<tr><td><code id="update.mvgam_+3A_burnin">burnin</code></td>
<td>
<p><code>integer</code> specifying the number of warmup iterations of the Markov chain to run
to tune sampling algorithms. Ignored
if <code>algorithm %in% c('meanfield', 'fullrank', 'pathfinder', 'laplace')</code></p>
</td></tr>
<tr><td><code id="update.mvgam_+3A_samples">samples</code></td>
<td>
<p><code>integer</code> specifying the number of post-warmup iterations of the Markov chain to run for
sampling the posterior distribution</p>
</td></tr>
<tr><td><code id="update.mvgam_+3A_threads">threads</code></td>
<td>
<p><code>integer</code> Experimental option to use multithreading for within-chain
parallelisation in <code>Stan</code>. We recommend its use only if you are experienced with
<code>Stan</code>'s <code>reduce_sum</code> function and have a slow running model that cannot be sped
up by any other means. Currently works for all families apart from <code>nmix()</code> and
when using <code>Cmdstan</code> as the backend</p>
</td></tr>
<tr><td><code id="update.mvgam_+3A_algorithm">algorithm</code></td>
<td>
<p>Character string naming the estimation approach to use.
Options are <code>"sampling"</code> for MCMC (the default), <code>"meanfield"</code> for
variational inference with factorized normal distributions,
<code>"fullrank"</code> for variational inference with a multivariate normal
distribution, <code>"laplace"</code> for a Laplace approximation (only available
when using cmdstanr as the backend) or <code>"pathfinder"</code> for the pathfinder
algorithm (only currently available when using cmdstanr as the backend).
Can be set globally for the current <span class="rlang"><b>R</b></span> session via the
<code>"brms.algorithm"</code> option (see <code><a href="base.html#topic+options">options</a></code>). Limited testing
suggests that <code>"meanfield"</code> performs best out of the non-MCMC approximations for
dynamic GAMs, possibly because of the difficulties estimating covariances among the
many spline parameters and latent trend parameters. But rigorous testing has not
been carried out</p>
</td></tr>
<tr><td><code id="update.mvgam_+3A_lfo">lfo</code></td>
<td>
<p>Logical indicating whether this is part of a call to <a href="#topic+lfo_cv.mvgam">lfo_cv.mvgam</a>. Returns a
lighter version of the model with no residuals and fewer monitored parameters to speed up
post-processing. But other downstream functions will not work properly, so users should always
leave this set as <code>FALSE</code></p>
</td></tr>
<tr><td><code id="update.mvgam_+3A_...">...</code></td>
<td>
<p>Other arguments to be passed to <code><a href="#topic+mvgam">mvgam</a></code> or <code><a href="#topic+jsdgam">jsdgam</a></code></p>
</td></tr>
<tr><td><code id="update.mvgam_+3A_factor_formula">factor_formula</code></td>
<td>
<p>Optional new <code>formula</code> object for the factor linear predictors</p>
</td></tr>
<tr><td><code id="update.mvgam_+3A_factor_knots">factor_knots</code></td>
<td>
<p>An optional <code>list</code> containing user specified knot values to
be used for basis construction of any smooth terms in <code>factor_formula</code>.
For most bases the user simply supplies the knots to be used, which must match up with the <code>k</code> value supplied
(note that the number of knots is not always just <code>k</code>). Different terms can use different numbers of knots,
unless they share a covariate</p>
</td></tr>
</table>


<h3>Value</h3>

<p>A <code>list</code> object of class <code>mvgam</code> containing model output, the text representation of the model file,
the mgcv model output (for easily generating simulations at
unsampled covariate values), Dunn-Smyth residuals for each outcome variable and key information needed
for other functions in the package. See <code><a href="#topic+mvgam-class">mvgam-class</a></code> for details.
Use <code>methods(class = "mvgam")</code> for an overview on available methods.
</p>
<p>A <code>list</code> object of class <code>mvgam</code> containing model output, the text representation of the model file,
the mgcv model output (for easily generating simulations at
unsampled covariate values), Dunn-Smyth residuals for each series and key information needed
for other functions in the package. See <code><a href="#topic+mvgam-class">mvgam-class</a></code> for details.
Use <code>methods(class = "mvgam")</code> for an overview on available methods.
</p>


<h3>Author(s)</h3>

<p>Nicholas J Clark
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate some data and fit a Poisson AR1 model
simdat &lt;- sim_mvgam(n_series = 1, trend_model = AR())
mod &lt;- mvgam(y ~ s(season, bs = 'cc'),
             trend_model = AR(),
             noncentred = TRUE,
             data = simdat$data_train,
             chains = 2)
summary(mod)
conditional_effects(mod, type = 'link')

# Update to an AR2 model
updated_mod &lt;- update(mod, trend_model = AR(p = 2),
                      noncentred = TRUE)
summary(updated_mod)
conditional_effects(updated_mod, type = 'link')

# Now update to a Binomial AR1 by adding information on trials
# requires that we supply newdata that contains the 'trials' variable
simdat$data_train$trials &lt;- max(simdat$data_train$y) + 15
updated_mod &lt;- update(mod,
                      formula = cbind(y, trials) ~ s(season, bs = 'cc'),
                      noncentred = TRUE,
                      data = simdat$data_train,
                      family = binomial())
summary(updated_mod)
conditional_effects(updated_mod, type = 'link')

</code></pre>

<hr>
<h2 id='ZMVN'>Specify correlated residual processes in <span class="pkg">mvgam</span></h2><span id='topic+ZMVN'></span>

<h3>Description</h3>

<p>Set up latent correlated multivariate Gaussian residual processes
in <span class="pkg">mvgam</span>. This function does not evaluate it's arguments –
it exists purely to help set up a model with particular error processes.
</p>


<h3>Usage</h3>

<pre><code class='language-R'>ZMVN(unit = time, gr = NA, subgr = series)
</code></pre>


<h3>Arguments</h3>

<table role = "presentation">
<tr><td><code id="ZMVN_+3A_unit">unit</code></td>
<td>
<p>The unquoted name of the variable that represents the unit of analysis in <code>data</code> over
which latent residuals should be correlated. This variable should be either a
<code>numeric</code> or <code>integer</code> variable in the supplied <code>data</code>.
Defaults to <code>time</code> to be consistent with other functionalities
in <span class="pkg">mvgam</span>, though note that the data need not be time series in this case. See examples below
for further details and explanations</p>
</td></tr>
<tr><td><code id="ZMVN_+3A_gr">gr</code></td>
<td>
<p>An optional grouping variable, which must be a <code>factor</code> in the supplied <code>data</code>,
for setting up hierarchical residual correlation structures. If specified,
this will automatically set up a model where the
residual correlations for a specific level of <code>gr</code> are modelled hierarchically:
<code class="reqn">\Omega_{group} = p\Omega_{global} + (1 - p)\Omega_{group, local}</code>,
where <code class="reqn">\Omega_{global}</code> is a <em>global</em> correlation
matrix, <code class="reqn">\Omega_{group, local}</code> is a <em>local deviation</em> correlation matrix
and <code class="reqn">p</code> is a weighting parameter
controlling how strongly the local correlation matrix <code class="reqn">\Omega_{group}</code> is shrunk towards the global
correlation matrix <code class="reqn">\Omega_{global}</code>. If <code>gr</code> is supplied then <code>subgr</code> <em>must</em> also be supplied</p>
</td></tr>
<tr><td><code id="ZMVN_+3A_subgr">subgr</code></td>
<td>
<p>A subgrouping <code>factor</code> variable specifying which element in <code>data</code> represents the
different observational units. Defaults to <code>series</code> to be consistent with other functionalities
in <span class="pkg">mvgam</span>, though note that the data need not be time series in this case.
But note that models that use the hierarchical correlations (by supplying a value for <code>gr</code>)
<em>should not</em> include a <code>series</code> element in <code>data</code>. Rather, this element will be created internally based
on the supplied variables for <code>gr</code> and <code>subgr</code>. For example, if you are modelling
counts for a group of species (labelled as <code>species</code> in the data) across sampling sites
(labelled as <code>site</code> in the data) in three
different geographical regions (labelled as <code>region</code>), and you would like the residuals to be correlated
within regions, then you should specify
<code>unit = site</code>,  <code>gr = region</code>, and <code>subgr = species</code>. Internally, <code>mvgam()</code> will appropriately order
the data by <code>unit</code> (in this case, by <code>site</code>) and create
the <code>series</code> element for the data using something like: <code>series = as.factor(paste0(group, '_', subgroup))</code></p>
</td></tr>
</table>


<h3>Value</h3>

<p>An object of class <code>mvgam_trend</code>, which contains a list of
arguments to be interpreted by the parsing functions in <span class="pkg">mvgam</span>
</p>


<h3>Examples</h3>

<pre><code class='language-R'>
# Simulate counts of four species over ten sampling locations
site_dat &lt;- data.frame(site = rep(1:10, 4),
                      species = as.factor(sort(rep(letters[1:4], 10))),
                      y = c(NA, rpois(39, 3)))
head(site_dat)

# Set up a correlated residual (i.e. Joint Species Distribution) model,
# where 'site' represents the unit of analysis
trend_model &lt;- ZMVN(unit = site, subgr = species)
mod &lt;- mvgam(y ~ species,
            trend_model = ZMVN(unit = site,
                               subgr = species),
            data = site_dat,
            chains = 2,
            silent = 2)

# Inspect the estimated species-species residual covariances
mcmc_plot(mod, variable = 'Sigma', regex = TRUE, type = 'hist')

# A hierarchical correlation example; set up correlated counts
# for three species across two sampling locations
Sigma &lt;- matrix(c(1, -0.4, 0.5,
                 -0.4, 1, 0.3,
                 0.5, 0.3, 1),
               byrow = TRUE,
               nrow = 3)
               Sigma

make_site_dat = function(...){
 errors &lt;- mgcv::rmvn(n = 30,
                      mu = c(0.6, 0.8, 1.8),
                      V = Sigma)
 site_dat &lt;- do.call(rbind, lapply(1:3, function(spec){
   data.frame(y = rpois(30,
                        lambda = exp(errors[, spec])),
              species = paste0('species',
                               spec),
              site = 1:30)
}))
site_dat
}

site_dat &lt;- rbind(make_site_dat() %&gt;%
                   dplyr::mutate(group = 'group1'),
                 make_site_dat() %&gt;%
                   dplyr::mutate(group = 'group2')) %&gt;%
   dplyr::mutate(species = as.factor(species),
                 group = as.factor(group))

# Fit the hierarchical correlated residual model
mod &lt;- mvgam(y ~ species,
            trend_model = ZMVN(unit = site,
                               gr = group,
                               subgr = species),
            data = site_dat)

# Inspect the estimated species-species residual covariances
mcmc_plot(mod, variable = 'Sigma', regex = TRUE, type = 'hist')


</code></pre>

</main>

</div>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/prism.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-r.min.js"></script>
</body></html>
